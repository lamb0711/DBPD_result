Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Implements an operation log to write to disk. As of prPersistSprint2 this
- * file only supports persistent regions. For overflow only regions see
- * {@link OverflowOplog}.
+ * Implements an operation log to write to disk. As of prPersistSprint2 this file only supports
+ * persistent regions. For overflow only regions see {@link OverflowOplog}.
-   * Recovered version of the data. Usually this is same as {@link #gfversion}
-   * except for the case of upgrading disk store from previous version in which
-   * case the keys/values are carried forward as is and need to be interpreted
-   * in load by latest product code if required.
+   * Recovered version of the data. Usually this is same as {@link #gfversion} except for the case
+   * of upgrading disk store from previous version in which case the keys/values are carried forward
+   * as is and need to be interpreted in load by latest product code if required.
-   * This system property instructs that writes be synchronously written to disk
-   * and not to file system. (Use rwd instead of rw - RandomAccessFile property)
+   * This system property instructs that writes be synchronously written to disk and not to file
+   * system. (Use rwd instead of rw - RandomAccessFile property)
-  private static final boolean SYNC_WRITES = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "syncWrites");
+  private static final boolean SYNC_WRITES =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "syncWrites");
-   * The number of records in this oplog that contain the most recent value of
-   * the entry.
+   * The number of records in this oplog that contain the most recent value of the entry.
-  private final ConcurrentMap<Long, DiskRegionInfo> regionMap = new ConcurrentHashMap<Long, DiskRegionInfo>();
+  private final ConcurrentMap<Long, DiskRegionInfo> regionMap =
+      new ConcurrentHashMap<Long, DiskRegionInfo>();
-   * Written to CRF and DRF. Followed by 16 bytes which is the leastSigBits and
-   * mostSigBits of a UUID for the disk store we belong to. 1: EndOfRecord Is
-   * written once at the beginning of every oplog file.
+   * Written to CRF and DRF. Followed by 16 bytes which is the leastSigBits and mostSigBits of a
+   * UUID for the disk store we belong to. 1: EndOfRecord Is written once at the beginning of every
+   * oplog file.
-   * Written to CRF. Followed by 8 bytes which is the BASE_ID to use for any
-   * NEW_ENTRY records. 1: EndOfRecord Only needs to be written once per oplog
-   * and must preceed any OPLOG_NEW_ENTRY_0ID records.
+   * Written to CRF. Followed by 8 bytes which is the BASE_ID to use for any NEW_ENTRY records. 1:
+   * EndOfRecord Only needs to be written once per oplog and must preceed any OPLOG_NEW_ENTRY_0ID
+   * records.
-   * Written to CRF. The OplogEntryId is +1 the previous new_entry OplogEntryId.
-   * Byte Format: 1: userBits RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 4: keyLength
-   * keyLength: key bytes 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is +1 the previous new_entry OplogEntryId. Byte Format: 1:
+   * userBits RegionId 4: valueLength (optional depending on bits) valueLength: value bytes
+   * (optional depending on bits) 4: keyLength keyLength: key bytes 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 1 byte. Byte Format: 1:
-   * userBits 1: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 1 byte. Byte Format: 1: userBits 1: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 2 bytes. Byte Format: 1:
-   * userBits 2: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 2 bytes. Byte Format: 1: userBits 2: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 3 bytes. Byte Format: 1:
-   * userBits 3: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 3 bytes. Byte Format: 1: userBits 3: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 4 bytes. Byte Format: 1:
-   * userBits 4: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 4 bytes. Byte Format: 1: userBits 4: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 5 bytes. Byte Format: 1:
-   * userBits 5: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 5 bytes. Byte Format: 1: userBits 5: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 6 bytes. Byte Format: 1:
-   * userBits 6: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 6 bytes. Byte Format: 1: userBits 6: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 7 bytes. Byte Format: 1:
-   * userBits 7: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 7 bytes. Byte Format: 1: userBits 7: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 8 bytes. Byte Format: 1:
-   * userBits 8: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 8 bytes. Byte Format: 1: userBits 8: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 1 byte. Byte Format: 1:
-   * userBits 1: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 4: keyLength
-   * keyLength: key bytes 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 1 byte. Byte Format: 1: userBits 1: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 4: keyLength keyLength: key bytes 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 2 bytes. Byte Format: 1:
-   * userBits 2: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 4: keyLength
-   * keyLength: key bytes 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 2 bytes. Byte Format: 1: userBits 2: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 4: keyLength keyLength: key bytes 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 3 bytes. Byte Format: 1:
-   * userBits 3: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 4: keyLength
-   * keyLength: key bytes 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 3 bytes. Byte Format: 1: userBits 3: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 4: keyLength keyLength: key bytes 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 4 bytes. Byte Format: 1:
-   * userBits 4: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 4: keyLength
-   * keyLength: key bytes 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 4 bytes. Byte Format: 1: userBits 4: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 4: keyLength keyLength: key bytes 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 5 bytes. Byte Format: 1:
-   * userBits 5: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 4: keyLength
-   * keyLength: key bytes 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 5 bytes. Byte Format: 1: userBits 5: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 4: keyLength keyLength: key bytes 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 6 bytes. Byte Format: 1:
-   * userBits 6: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 4: keyLength
-   * keyLength: key bytes 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 6 bytes. Byte Format: 1: userBits 6: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 4: keyLength keyLength: key bytes 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 7 bytes. Byte Format: 1:
-   * userBits 7: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 4: keyLength
-   * keyLength: key bytes 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 7 bytes. Byte Format: 1: userBits 7: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 4: keyLength keyLength: key bytes 1: EndOfRecord
-   * Written to CRF. The OplogEntryId is relative to the previous mod_entry
-   * OplogEntryId. The signed difference is encoded in 8 bytes. Byte Format: 1:
-   * userBits 8: OplogEntryId RegionId 4: valueLength (optional depending on
-   * bits) valueLength: value bytes (optional depending on bits) 4: keyLength
-   * keyLength: key bytes 1: EndOfRecord
+   * Written to CRF. The OplogEntryId is relative to the previous mod_entry OplogEntryId. The signed
+   * difference is encoded in 8 bytes. Byte Format: 1: userBits 8: OplogEntryId RegionId 4:
+   * valueLength (optional depending on bits) valueLength: value bytes (optional depending on bits)
+   * 4: keyLength keyLength: key bytes 1: EndOfRecord
-   * Written to DRF. The OplogEntryId is relative to the previous del_entry
-   * OplogEntryId. The signed difference is encoded in 1 byte. Byte Format: 1:
-   * OplogEntryId 1: EndOfRecord
+   * Written to DRF. The OplogEntryId is relative to the previous del_entry OplogEntryId. The signed
+   * difference is encoded in 1 byte. Byte Format: 1: OplogEntryId 1: EndOfRecord
-   * Written to DRF. The OplogEntryId is relative to the previous del_entry
-   * OplogEntryId. The signed difference is encoded in 2 bytes. Byte Format: 2:
-   * OplogEntryId 1: EndOfRecord
+   * Written to DRF. The OplogEntryId is relative to the previous del_entry OplogEntryId. The signed
+   * difference is encoded in 2 bytes. Byte Format: 2: OplogEntryId 1: EndOfRecord
-   * Written to DRF. The OplogEntryId is relative to the previous del_entry
-   * OplogEntryId. The signed difference is encoded in 3 bytes. Byte Format: 3:
-   * OplogEntryId 1: EndOfRecord
+   * Written to DRF. The OplogEntryId is relative to the previous del_entry OplogEntryId. The signed
+   * difference is encoded in 3 bytes. Byte Format: 3: OplogEntryId 1: EndOfRecord
-   * Written to DRF. The OplogEntryId is relative to the previous del_entry
-   * OplogEntryId. The signed difference is encoded in 4 bytes. Byte Format: 4:
-   * OplogEntryId 1: EndOfRecord
+   * Written to DRF. The OplogEntryId is relative to the previous del_entry OplogEntryId. The signed
+   * difference is encoded in 4 bytes. Byte Format: 4: OplogEntryId 1: EndOfRecord
-   * Written to DRF. The OplogEntryId is relative to the previous del_entry
-   * OplogEntryId. The signed difference is encoded in 5 bytes. Byte Format: 5:
-   * OplogEntryId 1: EndOfRecord
+   * Written to DRF. The OplogEntryId is relative to the previous del_entry OplogEntryId. The signed
+   * difference is encoded in 5 bytes. Byte Format: 5: OplogEntryId 1: EndOfRecord
-   * Written to DRF. The OplogEntryId is relative to the previous del_entry
-   * OplogEntryId. The signed difference is encoded in 6 bytes. Byte Format: 6:
-   * OplogEntryId 1: EndOfRecord
+   * Written to DRF. The OplogEntryId is relative to the previous del_entry OplogEntryId. The signed
+   * difference is encoded in 6 bytes. Byte Format: 6: OplogEntryId 1: EndOfRecord
-   * Written to DRF. The OplogEntryId is relative to the previous del_entry
-   * OplogEntryId. The signed difference is encoded in 7 bytes. Byte Format: 7:
-   * OplogEntryId 1: EndOfRecord
+   * Written to DRF. The OplogEntryId is relative to the previous del_entry OplogEntryId. The signed
+   * difference is encoded in 7 bytes. Byte Format: 7: OplogEntryId 1: EndOfRecord
-   * Written to DRF. The OplogEntryId is relative to the previous del_entry
-   * OplogEntryId. The signed difference is encoded in 8 bytes. Byte Format: 8:
-   * OplogEntryId 1: EndOfRecord
+   * Written to DRF. The OplogEntryId is relative to the previous del_entry OplogEntryId. The signed
+   * difference is encoded in 8 bytes. Byte Format: 8: OplogEntryId 1: EndOfRecord
-   * The maximum size of a DEL_ENTRY record in bytes. Currenty this is 10; 1 for
-   * opcode and 8 for oplogEntryId and 1 for END_OF_RECORD_ID
+   * The maximum size of a DEL_ENTRY record in bytes. Currenty this is 10; 1 for opcode and 8 for
+   * oplogEntryId and 1 for END_OF_RECORD_ID
-   * Written to beginning of each CRF. Contains the RVV for all regions in the
-   * CRF. Byte Format 8: number of regions (variable length encoded number) for
-   * each region 4: number of members (variable length encoded number) for each
-   * member 4: canonical member id (variable length encoded number) 8: version
-   * id (variable length encoded number) 4: number of exceptions (variable
-   * length encoded number) variable: exceptions
+   * Written to beginning of each CRF. Contains the RVV for all regions in the CRF. Byte Format 8:
+   * number of regions (variable length encoded number) for each region 4: number of members
+   * (variable length encoded number) for each member 4: canonical member id (variable length
+   * encoded number) 8: version id (variable length encoded number) 4: number of exceptions
+   * (variable length encoded number) variable: exceptions
-   * When detected conflict, besides persisting the golden copy by modify(),
-   * also persist the conflict operation's region version and member id. and
-   * failedWritten to beginning of each CRF. Contains the RVV for all regions in
-   * the CRF. Byte Format regionId versions
+   * When detected conflict, besides persisting the golden copy by modify(), also persist the
+   * conflict operation's region version and member id. and failedWritten to beginning of each CRF.
+   * Contains the RVV for all regions in the CRF. Byte Format regionId versions
-   * persist Gemfire version string into crf, drf, krf Byte Format variable
-   * gemfire version string, such as 7.0.0.beta EndOfRecord
+   * persist Gemfire version string into crf, drf, krf Byte Format variable gemfire version string,
+   * such as 7.0.0.beta EndOfRecord
-   * Persist oplog file magic number. Written once at the beginning of every
-   * oplog file; CRF, DRF, KRF, IF and IRF. Followed by 6 byte magic number.
-   * Each oplog type has a different magic number Followed by EndOfRecord Fix
-   * for bug 43824
+   * Persist oplog file magic number. Written once at the beginning of every oplog file; CRF, DRF,
+   * KRF, IF and IRF. Followed by 6 byte magic number. Each oplog type has a different magic number
+   * Followed by EndOfRecord Fix for bug 43824
-    CRF(new byte[] { 0x47, 0x46, 0x43, 0x52, 0x46, 0x31 }), // GFCRF1
-    DRF(new byte[] { 0x47, 0x46, 0x44, 0x52, 0x46, 0x31 }), // GFDRF1
-    IRF(new byte[] { 0x47, 0x46, 0x49, 0x52, 0x46, 0x31 }), // GFIRF1
-    KRF(new byte[] { 0x47, 0x46, 0x4b, 0x52, 0x46, 0x31 }), // GFKRF1
-    IF(new byte[] { 0x47, 0x46, 0x49, 0x46, 0x30, 0x31 }); // GFIF01
+    CRF(new byte[] {0x47, 0x46, 0x43, 0x52, 0x46, 0x31}), // GFCRF1
+    DRF(new byte[] {0x47, 0x46, 0x44, 0x52, 0x46, 0x31}), // GFDRF1
+    IRF(new byte[] {0x47, 0x46, 0x49, 0x52, 0x46, 0x31}), // GFIRF1
+    KRF(new byte[] {0x47, 0x46, 0x4b, 0x52, 0x46, 0x31}), // GFKRF1
+    IF(new byte[] {0x47, 0x46, 0x49, 0x46, 0x30, 0x31}); // GFIF01
-   * Asif: This object is used to correctly identify the OpLog size so as to
-   * cause a switch of oplogs
+   * Asif: This object is used to correctly identify the OpLog size so as to cause a switch of
+   * oplogs
-   * Set to true when this oplog will no longer be written to. Never set to
-   * false once it becomes true.
+   * Set to true when this oplog will no longer be written to. Never set to false once it becomes
+   * true.
-   * Extra bytes to be skipped before reading value bytes. Value is currently 6
-   * : 1 byte for opcode, 1 byte for userbits and 4 bytes for value length.
+   * Extra bytes to be skipped before reading value bytes. Value is currently 6 : 1 byte for opcode,
+   * 1 byte for userbits and 4 bytes for value length.
-   * @param oplogId
-   *          int identifying the new oplog
-   * @param dirHolder
-   *          The directory in which to create new Oplog
+   * @param oplogId int identifying the new oplog
+   * @param dirHolder The directory in which to create new Oplog
-   * @throws DiskAccessException
-   *           if the disk files can not be initialized
+   * @throws DiskAccessException if the disk files can not be initialized
-      throw new IllegalStateException("Too many oplogs. The oplog id can not exceed " + DiskId.MAX_OPLOG_ID);
+      throw new IllegalStateException(
+          "Too many oplogs. The oplog id can not exceed " + DiskId.MAX_OPLOG_ID);
-        throw new DiskAccessException(LocalizedStrings.Oplog_PreAllocate_Failure_Init.toLocalizedString(this.dirHolder,
-            maxOplogSizeParam), new IOException("not enough space left to create and pre grow oplog files, available="
-            + availableSpace + ", required=" + maxOplogSizeParam), getParent());
+        throw new DiskAccessException(
+            LocalizedStrings.Oplog_PreAllocate_Failure_Init.toLocalizedString(this.dirHolder,
+                maxOplogSizeParam),
+            new IOException("not enough space left to create and pre grow oplog files, available="
+                + availableSpace + ", required=" + maxOplogSizeParam),
+            getParent());
-        logger.debug("Reducing maxOplogSize to {} because that is all the room remaining in the directory.", availableSpace);
+        logger.debug(
+            "Reducing maxOplogSize to {} because that is all the room remaining in the directory.",
+            availableSpace);
-      throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_CREATING_OPERATION_LOG_BECAUSE_0.toLocalizedString(ex),
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_FAILED_CREATING_OPERATION_LOG_BECAUSE_0.toLocalizedString(ex),
-   * Asif: A copy constructor used for creating a new oplog based on the
-   * previous Oplog. This constructor is invoked only from the function
-   * switchOplog
+   * Asif: A copy constructor used for creating a new oplog based on the previous Oplog. This
+   * constructor is invoked only from the function switchOplog
-   * @param oplogId
-   *          integer identifying the new oplog
-   * @param dirHolder
-   *          The directory in which to create new Oplog
-   * @param prevOplog
-   *          The previous oplog
+   * @param oplogId integer identifying the new oplog
+   * @param dirHolder The directory in which to create new Oplog
+   * @param prevOplog The previous oplog
-      throw new IllegalStateException("Too many oplogs. The oplog id can not exceed " + DiskId.MAX_OPLOG_ID);
+      throw new IllegalStateException(
+          "Too many oplogs. The oplog id can not exceed " + DiskId.MAX_OPLOG_ID);
-          logger.debug("Reducing maxOplogSize to {} because that is all the room remaining in the directory.", availableSpace);
+          logger.debug(
+              "Reducing maxOplogSize to {} because that is all the room remaining in the directory.",
+              availableSpace);
-      throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_CREATING_OPERATION_LOG_BECAUSE_0.toLocalizedString(ex),
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_FAILED_CREATING_OPERATION_LOG_BECAUSE_0.toLocalizedString(ex),
-              old.getKey(), System.identityHashCode(old), System.identityHashCode(repl), old.getDiskId(), repl.getDiskId(), old
-                  .getVersionStamp(), this.getOplogId());
+              old.getKey(), System.identityHashCode(old), System.identityHashCode(repl),
+              old.getDiskId(), repl.getDiskId(), old.getVersionStamp(), this.getOplogId());
-   * @param olf
-   *          the oplog to write to
-   * @param diskRegions
-   *          the set of disk regions we should write the RVV of
-   * @param writeGCRVV
-   *          true to write write the GC RVV
+   * @param olf the oplog to write to
+   * @param diskRegions the set of disk regions we should write the RVV of
+   * @param writeGCRVV true to write write the GC RVV
-  private void writeRVVRecord(OplogFile olf, Map<Long, AbstractDiskRegion> diskRegions, boolean writeGCRVV) throws IOException {
+  private void writeRVVRecord(OplogFile olf, Map<Long, AbstractDiskRegion> diskRegions,
+      boolean writeGCRVV) throws IOException {
-   * Write a OPLOG_NEW_ENTRY_BASE_ID to this oplog. Must be called before any
-   * OPLOG_NEW_ENTRY_0ID records are written to this oplog.
+   * Write a OPLOG_NEW_ENTRY_BASE_ID to this oplog. Must be called before any OPLOG_NEW_ENTRY_0ID
+   * records are written to this oplog.
-   * This constructor will get invoked only in case of persistent region when it
-   * is recovering an oplog.
+   * This constructor will get invoked only in case of persistent region when it is recovering an
+   * oplog.
-      throw new IllegalStateException("Too many oplogs. The oplog id can not exceed " + DiskId.MAX_OPLOG_ID);
+      throw new IllegalStateException(
+          "Too many oplogs. The oplog id can not exceed " + DiskId.MAX_OPLOG_ID);
-        throw new DiskAccessException("Oplog#" + getOplogId() + " has files in two different directories: \"" + this.dirHolder
-            + "\", and \"" + dh + "\". Both the crf and drf for this oplog should be in the same directory.", getParent());
+        throw new DiskAccessException(
+            "Oplog#" + getOplogId() + " has files in two different directories: \"" + this.dirHolder
+                + "\", and \"" + dh
+                + "\". Both the crf and drf for this oplog should be in the same directory.",
+            getParent());
-    this.diskFile = new File(this.drf.f.getParentFile(), oplogSet.getPrefix() + n + "_" + this.oplogId);
+    this.diskFile =
+        new File(this.drf.f.getParentFile(), oplogSet.getPrefix() + n + "_" + this.oplogId);
-      throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_CREATING_OPERATION_LOG_BECAUSE_0.toLocalizedString(ex),
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_FAILED_CREATING_OPERATION_LOG_BECAUSE_0.toLocalizedString(ex),
-      getOplogSet().removeOplog(getOplogId(), true/*
-                                                   * say we are deleting so that
-                                                   * undeletedOplogSize is not
-                                                   * inced
-                                                   */, null);
+      getOplogSet().removeOplog(getOplogId(),
+          true/*
+               * say we are deleting so that undeletedOplogSize is not inced
+               */, null);
-        logger.warn(LocalizedMessage.create(LocalizedStrings.Oplog_Close_Failed, olf.f.getAbsolutePath()), e);
+        logger.warn(
+            LocalizedMessage.create(LocalizedStrings.Oplog_Close_Failed, olf.f.getAbsolutePath()),
+            e);
-      throw new DiskAccessException(LocalizedStrings.Oplog_COULD_NOT_DELETE__0_.toLocalizedString(olf.f.getAbsolutePath()), ex,
-          getParent());
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_COULD_NOT_DELETE__0_.toLocalizedString(olf.f.getAbsolutePath()),
+          ex, getParent());
-         * { String os = System.getProperty("os.name"); if (os != null) { if
-         * (os.indexOf("Windows") != -1) { olf.raf.close(); olf.RAFClosed =
-         * true; if (!olf.f.delete() && olf.f.exists()) { throw new
-         * DiskAccessException
-         * (LocalizedStrings.Oplog_COULD_NOT_DELETE__0_.toLocalizedString
-         * (olf.f.getAbsolutePath()), getParent()); } olf.raf = new
-         * RandomAccessFile(olf.f, SYNC_WRITES ? "rwd" : "rw"); olf.RAFClosed =
-         * false; } } }
+         * { String os = System.getProperty("os.name"); if (os != null) { if (os.indexOf("Windows")
+         * != -1) { olf.raf.close(); olf.RAFClosed = true; if (!olf.f.delete() && olf.f.exists()) {
+         * throw new DiskAccessException
+         * (LocalizedStrings.Oplog_COULD_NOT_DELETE__0_.toLocalizedString (olf.f.getAbsolutePath()),
+         * getParent()); } olf.raf = new RandomAccessFile(olf.f, SYNC_WRITES ? "rwd" : "rw");
+         * olf.RAFClosed = false; } } }
-        throw new DiskAccessException(LocalizedStrings.Oplog_PreAllocate_Failure.toLocalizedString(olf.f
-            .getAbsolutePath(), maxSize), ioe, getParent());
+        throw new DiskAccessException(LocalizedStrings.Oplog_PreAllocate_Failure
+            .toLocalizedString(olf.f.getAbsolutePath(), maxSize), ioe, getParent());
-      throw new DiskAccessException(LocalizedStrings.Oplog_PreAllocate_Failure.toLocalizedString(
-          olf.f.getAbsolutePath(), maxSize), new IOException("not enough space left to pre-blow, available=" + availableSpace
-          + ", required=" + maxSize), getParent());
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_PreAllocate_Failure.toLocalizedString(olf.f.getAbsolutePath(),
+              maxSize),
+          new IOException("not enough space left to pre-blow, available=" + availableSpace
+              + ", required=" + maxSize),
+          getParent());
-    logger.info(LocalizedMessage.create(LocalizedStrings.Oplog_CREATE_0_1_2, new Object[] { toString(), getFileType(this.crf),
-        getParent().getName() }));
+    logger.info(LocalizedMessage.create(LocalizedStrings.Oplog_CREATE_0_1_2,
+        new Object[] {toString(), getFileType(this.crf), getParent().getName()}));
-    logger.info(LocalizedMessage.create(LocalizedStrings.Oplog_CREATE_0_1_2, new Object[] { toString(), getFileType(this.drf),
-        getParent().getName() }));
+    logger.info(LocalizedMessage.create(LocalizedStrings.Oplog_CREATE_0_1_2,
+        new Object[] {toString(), getFileType(this.drf), getParent().getName()}));
-   * Test Method to be used only for testing purposes. Gets the underlying File
-   * object for the Oplog . Oplog class uses this File object to obtain the
-   * RandomAccessFile object. Before returning the File object , the dat present
-   * in the buffers of the RandomAccessFile object is flushed. Otherwise, for
-   * windows the actual file length does not match with the File size obtained
-   * from the File object
+   * Test Method to be used only for testing purposes. Gets the underlying File object for the Oplog
+   * . Oplog class uses this File object to obtain the RandomAccessFile object. Before returning the
+   * File object , the dat present in the buffers of the RandomAccessFile object is flushed.
+   * Otherwise, for windows the actual file length does not match with the File size obtained from
+   * the File object
-   * Given a set of Oplog file names return a Set of the oplog files that match
-   * those names that are managed by this Oplog.
+   * Given a set of Oplog file names return a Set of the oplog files that match those names that are
+   * managed by this Oplog.
-   * @param oplogFileNames
-   *          a Set of operation log file names.
+   * @param oplogFileNames a Set of operation log file names.
-    if ((null != this.crf.f) && this.crf.f.exists() && oplogFileNames.contains(this.crf.f.getName())) {
+    if ((null != this.crf.f) && this.crf.f.exists()
+        && oplogFileNames.contains(this.crf.f.getName())) {
-    if ((null != this.drf.f) && this.drf.f.exists() && oplogFileNames.contains(this.drf.f.getName())) {
+    if ((null != this.drf.f) && this.drf.f.exists()
+        && oplogFileNames.contains(this.drf.f.getName())) {
-   * Returns a map of baseline oplog files to copy that match this oplog's files
-   * for a currently running backup.
+   * Returns a map of baseline oplog files to copy that match this oplog's files for a currently
+   * running backup.
-   * @param baselineOplogFiles
-   *          a List of files to match this oplog's filenames against.
-   * @return a map of baslineline oplog files to copy. May be empty if total
-   *         current set for this oplog does not match the baseline.
+   * @param baselineOplogFiles a List of files to match this oplog's filenames against.
+   * @return a map of baslineline oplog files to copy. May be empty if total current set for this
+   *         oplog does not match the baseline.
-    Map<String, File> baselineOplogMap = TransformUtils.transformAndMap(baselineOplogFiles, TransformUtils.fileNameTransformer);
+    Map<String, File> baselineOplogMap =
+        TransformUtils.transformAndMap(baselineOplogFiles, TransformUtils.fileNameTransformer);
-    if ((null != this.crf.f) && this.crf.f.exists() && baselineOplogMap.containsKey(this.crf.f.getName())) {
-      baselineToOplogMap
-          .put(baselineOplogMap.get(this.crf.f.getName()), IOUtils.tryGetCanonicalFileElseGetAbsoluteFile(this.crf.f));
+    if ((null != this.crf.f) && this.crf.f.exists()
+        && baselineOplogMap.containsKey(this.crf.f.getName())) {
+      baselineToOplogMap.put(baselineOplogMap.get(this.crf.f.getName()),
+          IOUtils.tryGetCanonicalFileElseGetAbsoluteFile(this.crf.f));
-    if ((null != this.drf.f) && this.drf.f.exists() && baselineOplogMap.containsKey(this.drf.f.getName())) {
-      baselineToOplogMap
-          .put(baselineOplogMap.get(this.drf.f.getName()), IOUtils.tryGetCanonicalFileElseGetAbsoluteFile(this.drf.f));
+    if ((null != this.drf.f) && this.drf.f.exists()
+        && baselineOplogMap.containsKey(this.drf.f.getName())) {
+      baselineToOplogMap.put(baselineOplogMap.get(this.drf.f.getName()),
+          IOUtils.tryGetCanonicalFileElseGetAbsoluteFile(this.drf.f));
-        baselineToOplogMap.put(baselineOplogMap.get(krfFile.getName()), IOUtils.tryGetCanonicalFileElseGetAbsoluteFile(krfFile));
+        baselineToOplogMap.put(baselineOplogMap.get(krfFile.getName()),
+            IOUtils.tryGetCanonicalFileElseGetAbsoluteFile(krfFile));
-   * Returns the unserialized bytes and bits for the given Entry. If Oplog is
-   * destroyed while querying, then the DiskRegion is queried again to obatin
-   * the value This method should never get invoked for an entry which has been
-   * destroyed
+   * Returns the unserialized bytes and bits for the given Entry. If Oplog is destroyed while
+   * querying, then the DiskRegion is queried again to obatin the value This method should never get
+   * invoked for an entry which has been destroyed
-   * @param id
-   *          The DiskId for the entry @param offset The offset in this OpLog
-   *          where the entry is present. @param faultingIn @param bitOnly
-   *          boolean indicating whether to extract just the UserBit or UserBit
-   *          with value @return BytesAndBits object wrapping the value & user
-   *          bit
+   * @param id The DiskId for the entry @param offset The offset in this OpLog where the entry is
+   *        present. @param faultingIn @param bitOnly boolean indicating whether to extract just the
+   *        UserBit or UserBit with value @return BytesAndBits object wrapping the value & user bit
-  public final BytesAndBits getBytesAndBits(DiskRegionView dr, DiskId id, boolean faultingIn, boolean bitOnly) {
+  public final BytesAndBits getBytesAndBits(DiskRegionView dr, DiskId id, boolean faultingIn,
+      boolean bitOnly) {
-          LocalizedStrings.Oplog_OPLOGBASICGET_ERROR_IN_READING_THE_DATA_FROM_DISK_FOR_DISK_ID_HAVING_DATA_AS_0, id), dae);
+          LocalizedStrings.Oplog_OPLOGBASICGET_ERROR_IN_READING_THE_DATA_FROM_DISK_FOR_DISK_ID_HAVING_DATA_AS_0,
+          id), dae);
-              .toLocalizedString(new Object[] { id, Boolean.valueOf(dr.isSync()) }));
+              .toLocalizedString(new Object[] {id, Boolean.valueOf(dr.isSync())}));
-   * Returns the object stored on disk with the given id. This method is used
-   * for testing purposes only. As such, it bypasses the buffer and goes
-   * directly to the disk. This is not a thread safe function , in the sense, it
-   * is possible that by the time the OpLog is queried , data might move HTree
-   * with the oplog being destroyed
+   * Returns the object stored on disk with the given id. This method is used for testing purposes
+   * only. As such, it bypasses the buffer and goes directly to the disk. This is not a thread safe
+   * function , in the sense, it is possible that by the time the OpLog is queried , data might move
+   * HTree with the oplog being destroyed
-   * @param id
-   *          A DiskId object for which the value on disk will be fetched
+   * @param id A DiskId object for which the value on disk will be fetched
-      BytesAndBits bb = basicGet(dr, id.getOffsetInOplog(), false, id.getValueLength(), id.getUserBits());
+      BytesAndBits bb =
+          basicGet(dr, id.getOffsetInOplog(), false, id.getValueLength(), id.getUserBits());
-          LocalizedStrings.Oplog_OPLOGGETNOBUFFEREXCEPTION_IN_RETRIEVING_VALUE_FROM_DISK_FOR_DISKID_0, id), dae);
+          LocalizedStrings.Oplog_OPLOGGETNOBUFFEREXCEPTION_IN_RETRIEVING_VALUE_FROM_DISK_FOR_DISKID_0,
+          id), dae);
-          LocalizedStrings.Oplog_OPLOGGETNOBUFFEREXCEPTION_IN_RETRIEVING_VALUE_FROM_DISK_FOR_DISKID_0, id), ise);
+          LocalizedStrings.Oplog_OPLOGGETNOBUFFEREXCEPTION_IN_RETRIEVING_VALUE_FROM_DISK_FOR_DISKID_0,
+          id), ise);
-   * Used during recovery to calculate the OplogEntryId of the next NEW_ENTRY
-   * record.
+   * Used during recovery to calculate the OplogEntryId of the next NEW_ENTRY record.
-   * Used during writing to remember the last MOD_ENTRY OplogEntryId written to
-   * this oplog.
+   * Used during writing to remember the last MOD_ENTRY OplogEntryId written to this oplog.
-   * Used during recovery to calculate the OplogEntryId of the next MOD_ENTRY
-   * record.
+   * Used during recovery to calculate the OplogEntryId of the next MOD_ENTRY record.
-   * Used during writing to remember the last DEL_ENTRY OplogEntryId written to
-   * this oplog.
+   * Used during writing to remember the last DEL_ENTRY OplogEntryId written to this oplog.
-   * Used during recovery to calculate the OplogEntryId of the next DEL_ENTRY
-   * record.
+   * Used during recovery to calculate the OplogEntryId of the next DEL_ENTRY record.
-      logger.trace(LogMarker.PERSIST_RECOVERY, "calcModEntryId delta={} recoverModEntryId={}  oplogKeyId={}", delta,
+      logger.trace(LogMarker.PERSIST_RECOVERY,
+          "calcModEntryId delta={} recoverModEntryId={}  oplogKeyId={}", delta,
-      logger.trace(LogMarker.PERSIST_RECOVERY, "calcDelEntryId delta={} recoverModEntryId={}  oplogKeyId={}", delta,
+      logger.trace(LogMarker.PERSIST_RECOVERY,
+          "calcDelEntryId delta={} recoverModEntryId={}  oplogKeyId={}", delta,
-      logger.info(LocalizedMessage.create(LocalizedStrings.DiskRegion_RECOVERING_OPLOG_0_1_2, new Object[] { toString(),
-          drfFile.getAbsolutePath(), getParent().getName() }));
+      logger.info(LocalizedMessage.create(LocalizedStrings.DiskRegion_RECOVERING_OPLOG_0_1_2,
+          new Object[] {toString(), drfFile.getAbsolutePath(), getParent().getName()}));
-          dis = new CountingDataInputStream(new BufferedInputStream(fis, 32 * 1024), drfFile.length());
+          dis = new CountingDataInputStream(new BufferedInputStream(fis, 32 * 1024),
+              drfFile.length());
-              logger.trace(LogMarker.PERSIST_RECOVERY, "drf byte={} location={}", opCode, Long.toHexString(dis.getCount()));
+              logger.trace(LogMarker.PERSIST_RECOVERY, "drf byte={} location={}", opCode,
+                  Long.toHexString(dis.getCount()));
-            case OPLOG_EOF_ID:
-              // we are at the end of the oplog. So we need to back up one byte
-              dis.decrementCount();
-              endOfLog = true;
-              break;
-            case OPLOG_DEL_ENTRY_1ID:
-            case OPLOG_DEL_ENTRY_2ID:
-            case OPLOG_DEL_ENTRY_3ID:
-            case OPLOG_DEL_ENTRY_4ID:
-            case OPLOG_DEL_ENTRY_5ID:
-            case OPLOG_DEL_ENTRY_6ID:
-            case OPLOG_DEL_ENTRY_7ID:
-            case OPLOG_DEL_ENTRY_8ID:
-              readDelEntry(dis, opCode, deletedIds, parent);
-              recordCount++;
-              break;
-            case OPLOG_DISK_STORE_ID:
-              readDiskStoreRecord(dis, this.drf.f);
-              foundDiskStoreRecord = true;
-              recordCount++;
-              break;
-            case OPLOG_MAGIC_SEQ_ID:
-              readOplogMagicSeqRecord(dis, this.drf.f, OPLOG_TYPE.DRF);
-              break;
-            case OPLOG_GEMFIRE_VERSION:
-              readGemfireVersionRecord(dis, this.drf.f);
-              recordCount++;
-              break;
+              case OPLOG_EOF_ID:
+                // we are at the end of the oplog. So we need to back up one byte
+                dis.decrementCount();
+                endOfLog = true;
+                break;
+              case OPLOG_DEL_ENTRY_1ID:
+              case OPLOG_DEL_ENTRY_2ID:
+              case OPLOG_DEL_ENTRY_3ID:
+              case OPLOG_DEL_ENTRY_4ID:
+              case OPLOG_DEL_ENTRY_5ID:
+              case OPLOG_DEL_ENTRY_6ID:
+              case OPLOG_DEL_ENTRY_7ID:
+              case OPLOG_DEL_ENTRY_8ID:
+                readDelEntry(dis, opCode, deletedIds, parent);
+                recordCount++;
+                break;
+              case OPLOG_DISK_STORE_ID:
+                readDiskStoreRecord(dis, this.drf.f);
+                foundDiskStoreRecord = true;
+                recordCount++;
+                break;
+              case OPLOG_MAGIC_SEQ_ID:
+                readOplogMagicSeqRecord(dis, this.drf.f, OPLOG_TYPE.DRF);
+                break;
+              case OPLOG_GEMFIRE_VERSION:
+                readGemfireVersionRecord(dis, this.drf.f);
+                recordCount++;
+                break;
-            case OPLOG_RVV:
-              long idx = dis.getCount();
-              readRVVRecord(dis, this.drf.f, true, latestOplog);
-              recordCount++;
-              break;
+              case OPLOG_RVV:
+                long idx = dis.getCount();
+                readRVVRecord(dis, this.drf.f, true, latestOplog);
+                recordCount++;
+                break;
-            default:
-              throw new DiskAccessException(LocalizedStrings.Oplog_UNKNOWN_OPCODE_0_FOUND_IN_DISK_OPERATION_LOG
-                  .toLocalizedString(opCode), getParent());
+              default:
+                throw new DiskAccessException(
+                    LocalizedStrings.Oplog_UNKNOWN_OPCODE_0_FOUND_IN_DISK_OPERATION_LOG
+                        .toLocalizedString(opCode),
+                    getParent());
-          throw new DiskAccessException("The oplog file \"" + this.drf.f + "\" does not belong to the init file \""
-              + getParent().getInitFile() + "\". Drf did not contain a disk store id.", getParent());
+          throw new DiskAccessException(
+              "The oplog file \"" + this.drf.f + "\" does not belong to the init file \""
+                  + getParent().getInitFile() + "\". Drf did not contain a disk store id.",
+              getParent());
-        throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_READING_FILE_DURING_RECOVERY_FROM_0.toLocalizedString(drfFile
-            .getPath()), ex, getParent());
+        throw new DiskAccessException(
+            LocalizedStrings.Oplog_FAILED_READING_FILE_DURING_RECOVERY_FROM_0
+                .toLocalizedString(drfFile.getPath()),
+            ex, getParent());
-   * This map is used during recovery to keep track of what entries were
-   * recovered. Its keys are the oplogEntryId; its values are the actual logical
-   * keys that end up in the Region's keys. It used to be a local variable in
-   * basicInitializeOwner but now that it needs to live longer than that method
-   * I made it an instance variable It is now only alive during
-   * recoverRegionsThatAreReady so it could once again be passed down into each
-   * oplog.
+   * This map is used during recovery to keep track of what entries were recovered. Its keys are the
+   * oplogEntryId; its values are the actual logical keys that end up in the Region's keys. It used
+   * to be a local variable in basicInitializeOwner but now that it needs to live longer than that
+   * method I made it an instance variable It is now only alive during recoverRegionsThatAreReady so
+   * it could once again be passed down into each oplog.
-   * If offlineCompaction the value in this map will have the key bytes, values
-   * bytes, user bits, etc (any info we need to copy forward).
+   * If offlineCompaction the value in this map will have the key bytes, values bytes, user bits,
+   * etc (any info we need to copy forward).
-   * This map is used during recover to keep track of keys that are skipped.
-   * Later modify records in the same oplog may use this map to retrieve the
-   * correct key.
+   * This map is used during recover to keep track of keys that are skipped. Later modify records in
+   * the same oplog may use this map to retrieve the correct key.
-  private boolean readKrf(OplogEntryIdSet deletedIds, boolean recoverValues, boolean recoverValuesSync,
-      Set<Oplog> oplogsNeedingValueRecovery, boolean latestOplog) {
+  private boolean readKrf(OplogEntryIdSet deletedIds, boolean recoverValues,
+      boolean recoverValuesSync, Set<Oplog> oplogsNeedingValueRecovery, boolean latestOplog) {
-      logger.info(LocalizedMessage.create(LocalizedStrings.Oplog_REMOVING_INCOMPLETE_KRF, new Object[] { f.getName(), this.oplogId,
-          getParent().getName() }));
+      logger.info(LocalizedMessage.create(LocalizedStrings.Oplog_REMOVING_INCOMPLETE_KRF,
+          new Object[] {f.getName(), this.oplogId, getParent().getName()}));
-      logger.info(LocalizedMessage.create(LocalizedStrings.DiskRegion_RECOVERING_OPLOG_0_1_2, new Object[] { toString(),
-          f.getAbsolutePath(), getParent().getName() }));
+      logger.info(LocalizedMessage.create(LocalizedStrings.DiskRegion_RECOVERING_OPLOG_0_1_2,
+          new Object[] {toString(), f.getAbsolutePath(), getParent().getName()}));
-            if (drs != null && !drs.getDiskRegionView().getFlags().contains(DiskRegionFlag.IS_WITH_VERSIONING)) {
+            if (drs != null && !drs.getDiskRegionView().getFlags()
+                .contains(DiskRegionFlag.IS_WITH_VERSIONING)) {
-                  "readNewEntry skipping oplogKeyId=<{}> drId={} userBits={} oplogOffset={} valueLen={}", oplogKeyId, drId, userBits,
-                  oplogOffset, valueLength);
+                  "readNewEntry skipping oplogKeyId=<{}> drId={} userBits={} oplogOffset={} valueLen={}",
+                  oplogKeyId, drId, userBits, oplogOffset, valueLength);
-                throw new AssertionError(LocalizedStrings.Oplog_DUPLICATE_CREATE.toLocalizedString(oplogKeyId));
+                throw new AssertionError(
+                    LocalizedStrings.Oplog_DUPLICATE_CREATE.toLocalizedString(oplogKeyId));
-                    "readNewEntry oplogKeyId=<{}> drId={} userBits={} oplogOffset={} valueLen={}", oplogKeyId, drId, userBits,
-                    oplogOffset, valueLength);
+                    "readNewEntry oplogKeyId=<{}> drId={} userBits={} oplogOffset={} valueLen={}",
+                    oplogKeyId, drId, userBits, oplogOffset, valueLength);
-              DiskEntry.RecoveredEntry re = createRecoveredEntry(valueBytes, valueLength, userBits, getOplogId(), oplogOffset,
-                  oplogKeyId, false, version, in);
+              DiskEntry.RecoveredEntry re = createRecoveredEntry(valueBytes, valueLength, userBits,
+                  getOplogId(), oplogOffset, oplogKeyId, false, version, in);
-                    "ignore readNewEntry because getOplogId()={} != curdid.getOplogId()={} for drId={} key={}", getOplogId(), curdid
-                    .getOplogId(), drId, key);
+                    "ignore readNewEntry because getOplogId()={} != curdid.getOplogId()={} for drId={} key={}",
+                    getOplogId(), curdid.getOplogId(), drId, key);
-        throw new DiskAccessException("Unable to recover from krf file for oplogId=" + oplogId + ", file=" + f.getName()
-            + ". This file is corrupt, but may be safely deleted.", ex, getParent());
+        throw new DiskAccessException("Unable to recover from krf file for oplogId=" + oplogId
+            + ", file=" + f.getName() + ". This file is corrupt, but may be safely deleted.", ex,
+            getParent());
-        dis = new CountingDataInputStream(new BufferedInputStream(fis, 1024 * 1024), this.crf.f.length());
+        dis = new CountingDataInputStream(new BufferedInputStream(fis, 1024 * 1024),
+            this.crf.f.length());
-          case OPLOG_EOF_ID:
-            // we are at the end of the oplog. So we need to back up one byte
-            dis.decrementCount();
-            endOfLog = true;
-            break;
-          case OPLOG_CONFLICT_VERSION:
-            this.readVersionTagOnlyEntry(dis, opCode);
-            break;
-          case OPLOG_NEW_ENTRY_BASE_ID: {
-            long newEntryBase = dis.readLong();
-            if (logger.isTraceEnabled(LogMarker.PERSIST_RECOVERY)) {
-              logger.trace(LogMarker.PERSIST_RECOVERY, "newEntryBase={}", newEntryBase);
+            case OPLOG_EOF_ID:
+              // we are at the end of the oplog. So we need to back up one byte
+              dis.decrementCount();
+              endOfLog = true;
+              break;
+            case OPLOG_CONFLICT_VERSION:
+              this.readVersionTagOnlyEntry(dis, opCode);
+              break;
+            case OPLOG_NEW_ENTRY_BASE_ID: {
+              long newEntryBase = dis.readLong();
+              if (logger.isTraceEnabled(LogMarker.PERSIST_RECOVERY)) {
+                logger.trace(LogMarker.PERSIST_RECOVERY, "newEntryBase={}", newEntryBase);
+              }
+              readEndOfRecord(dis);
+              setRecoverNewEntryId(newEntryBase);
+              recordCount++;
-            readEndOfRecord(dis);
-            setRecoverNewEntryId(newEntryBase);
-            recordCount++;
-          }
-            break;
-          case OPLOG_NEW_ENTRY_0ID:
-            readNewEntry(dis, opCode, deletedIds, recoverValues, currentRegion, version, in, hdos);
-            recordCount++;
-            break;
-          case OPLOG_MOD_ENTRY_1ID:
-          case OPLOG_MOD_ENTRY_2ID:
-          case OPLOG_MOD_ENTRY_3ID:
-          case OPLOG_MOD_ENTRY_4ID:
-          case OPLOG_MOD_ENTRY_5ID:
-          case OPLOG_MOD_ENTRY_6ID:
-          case OPLOG_MOD_ENTRY_7ID:
-          case OPLOG_MOD_ENTRY_8ID:
-            readModifyEntry(dis, opCode, deletedIds, recoverValues, currentRegion, version, in, hdos);
-            recordCount++;
-            break;
-          case OPLOG_MOD_ENTRY_WITH_KEY_1ID:
-          case OPLOG_MOD_ENTRY_WITH_KEY_2ID:
-          case OPLOG_MOD_ENTRY_WITH_KEY_3ID:
-          case OPLOG_MOD_ENTRY_WITH_KEY_4ID:
-          case OPLOG_MOD_ENTRY_WITH_KEY_5ID:
-          case OPLOG_MOD_ENTRY_WITH_KEY_6ID:
-          case OPLOG_MOD_ENTRY_WITH_KEY_7ID:
-          case OPLOG_MOD_ENTRY_WITH_KEY_8ID:
-            readModifyEntryWithKey(dis, opCode, deletedIds, recoverValues, currentRegion, version, in,
-                hdos);
-            recordCount++;
-            break;
+              break;
+            case OPLOG_NEW_ENTRY_0ID:
+              readNewEntry(dis, opCode, deletedIds, recoverValues, currentRegion, version, in,
+                  hdos);
+              recordCount++;
+              break;
+            case OPLOG_MOD_ENTRY_1ID:
+            case OPLOG_MOD_ENTRY_2ID:
+            case OPLOG_MOD_ENTRY_3ID:
+            case OPLOG_MOD_ENTRY_4ID:
+            case OPLOG_MOD_ENTRY_5ID:
+            case OPLOG_MOD_ENTRY_6ID:
+            case OPLOG_MOD_ENTRY_7ID:
+            case OPLOG_MOD_ENTRY_8ID:
+              readModifyEntry(dis, opCode, deletedIds, recoverValues, currentRegion, version, in,
+                  hdos);
+              recordCount++;
+              break;
+            case OPLOG_MOD_ENTRY_WITH_KEY_1ID:
+            case OPLOG_MOD_ENTRY_WITH_KEY_2ID:
+            case OPLOG_MOD_ENTRY_WITH_KEY_3ID:
+            case OPLOG_MOD_ENTRY_WITH_KEY_4ID:
+            case OPLOG_MOD_ENTRY_WITH_KEY_5ID:
+            case OPLOG_MOD_ENTRY_WITH_KEY_6ID:
+            case OPLOG_MOD_ENTRY_WITH_KEY_7ID:
+            case OPLOG_MOD_ENTRY_WITH_KEY_8ID:
+              readModifyEntryWithKey(dis, opCode, deletedIds, recoverValues, currentRegion, version,
+                  in, hdos);
+              recordCount++;
+              break;
-          case OPLOG_DISK_STORE_ID:
-            readDiskStoreRecord(dis, this.crf.f);
-            foundDiskStoreRecord = true;
-            recordCount++;
-            break;
-          case OPLOG_MAGIC_SEQ_ID:
-            readOplogMagicSeqRecord(dis, this.crf.f, OPLOG_TYPE.CRF);
-            break;
-          case OPLOG_GEMFIRE_VERSION:
-            readGemfireVersionRecord(dis, this.crf.f);
-            recordCount++;
-            break;
-          case OPLOG_RVV:
-            readRVVRecord(dis, this.drf.f, false, latestOplog);
-            recordCount++;
-            break;
-          default:
-            throw new DiskAccessException(LocalizedStrings.Oplog_UNKNOWN_OPCODE_0_FOUND_IN_DISK_OPERATION_LOG
-                .toLocalizedString(opCode), getParent());
+            case OPLOG_DISK_STORE_ID:
+              readDiskStoreRecord(dis, this.crf.f);
+              foundDiskStoreRecord = true;
+              recordCount++;
+              break;
+            case OPLOG_MAGIC_SEQ_ID:
+              readOplogMagicSeqRecord(dis, this.crf.f, OPLOG_TYPE.CRF);
+              break;
+            case OPLOG_GEMFIRE_VERSION:
+              readGemfireVersionRecord(dis, this.crf.f);
+              recordCount++;
+              break;
+            case OPLOG_RVV:
+              readRVVRecord(dis, this.drf.f, false, latestOplog);
+              recordCount++;
+              break;
+            default:
+              throw new DiskAccessException(
+                  LocalizedStrings.Oplog_UNKNOWN_OPCODE_0_FOUND_IN_DISK_OPERATION_LOG
+                      .toLocalizedString(opCode),
+                  getParent());
-        throw new DiskAccessException("The oplog file \"" + this.crf.f + "\" does not belong to the init file \""
-            + getParent().getInitFile() + "\". Crf did not contain a disk store id.", getParent());
+        throw new DiskAccessException(
+            "The oplog file \"" + this.crf.f + "\" does not belong to the init file \""
+                + getParent().getInitFile() + "\". Crf did not contain a disk store id.",
+            getParent());
-      throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_READING_FILE_DURING_RECOVERY_FROM_0.toLocalizedString(this.crf.f
-          .getPath()), ex, getParent());
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_FAILED_READING_FILE_DURING_RECOVERY_FROM_0
+              .toLocalizedString(this.crf.f.getPath()),
+          ex, getParent());
-   * @throws DiskAccessException
-   *           if this file does not belong to our parent
+   * @throws DiskAccessException if this file does not belong to our parent
-      throw new DiskAccessException("The oplog file \"" + f + "\" does not belong to the init file \"" + getParent().getInitFile()
-          + "\".", getParent());
+      throw new DiskAccessException("The oplog file \"" + f
+          + "\" does not belong to the init file \"" + getParent().getInitFile() + "\".",
+          getParent());
-   * Reads and validates magic sequence in oplog header. For existing files this
-   * will not exist. This method will throw a DiskAccessException in that case
-   * too.
+   * Reads and validates magic sequence in oplog header. For existing files this will not exist.
+   * This method will throw a DiskAccessException in that case too.
-          logger.trace(LogMarker.PERSIST_RECOVERY, "oplog magic code mismatched at byte:{}, value:{}", (i + 1), seq[i]);
+          logger.trace(LogMarker.PERSIST_RECOVERY,
+              "oplog magic code mismatched at byte:{}, value:{}", (i + 1), seq[i]);
-        throw new DiskAccessException("Invalid oplog (" + type.name() + ") file provided: " + f, getParent());
+        throw new DiskAccessException("Invalid oplog (" + type.name() + ") file provided: " + f,
+            getParent());
-   * @throws DiskAccessException
-   *           if this file does not belong to our parent
+   * @throws DiskAccessException if this file does not belong to our parent
-            LocalizedStrings.Oplog_UNKNOWN_OPCODE_0_FOUND_IN_DISK_OPERATION_LOG.toLocalizedString(opCode), getParent());
+            LocalizedStrings.Oplog_UNKNOWN_OPCODE_0_FOUND_IN_DISK_OPERATION_LOG
+                .toLocalizedString(opCode),
+            getParent());
-            LocalizedStrings.Oplog_UNKNOWN_OPCODE_0_FOUND_IN_DISK_OPERATION_LOG.toLocalizedString(opCode), getParent());
+            LocalizedStrings.Oplog_UNKNOWN_OPCODE_0_FOUND_IN_DISK_OPERATION_LOG
+                .toLocalizedString(opCode),
+            getParent());
-      throw new DiskAccessException(LocalizedStrings.Oplog_UNEXPECTED_PRODUCT_VERSION_0.toLocalizedString(ver), e, getParent());
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_UNEXPECTED_PRODUCT_VERSION_0.toLocalizedString(ver), e,
+          getParent());
-  private void readRVVRecord(DataInput dis, File f, boolean gcRVV, boolean latestOplog) throws IOException {
+  private void readRVVRecord(DataInput dis, File f, boolean gcRVV, boolean latestOplog)
+      throws IOException {
-    
+
-              logger.trace(LogMarker.PERSIST_RECOVERY, "adding gcRVV entry drId={}, member={}, version={}", drId, memberId, gcVersion);
+              logger.trace(LogMarker.PERSIST_RECOVERY,
+                  "adding gcRVV entry drId={}, member={}, version={}", drId, memberId, gcVersion);
-              logger.trace(LogMarker.PERSIST_RECOVERY, "skipping gcRVV entry drId={}, member={}, version={}", drId, memberId,
-                  gcVersion);
+              logger.trace(LogMarker.PERSIST_RECOVERY,
+                  "skipping gcRVV entry drId={}, member={}, version={}", drId, memberId, gcVersion);
-              logger.trace(LogMarker.PERSIST_RECOVERY, "marking RVV trusted drId={},tvvTrusted={}", drId, rvvTrusted);
+              logger.trace(LogMarker.PERSIST_RECOVERY, "marking RVV trusted drId={},tvvTrusted={}",
+                  drId, rvvTrusted);
-                  "adding RVV entry drId={},member={},versionHolder={},latestOplog={},oplogId={}", drId, memberId, versionHolder,
-                  latestOplog, getOplogId());
+                  "adding RVV entry drId={},member={},versionHolder={},latestOplog={},oplogId={}",
+                  drId, memberId, versionHolder, latestOplog, getOplogId());
-              logger.trace(LogMarker.PERSIST_RECOVERY, "skipping RVV entry drId={}, member={}, versionHolder={}", drId, memberId,
+              logger.trace(LogMarker.PERSIST_RECOVERY,
+                  "skipping RVV entry drId={}, member={}, versionHolder={}", drId, memberId,
-   * @param latestOplog
-   *          - true if this oplog is the latest oplog in the disk store.
+   * @param latestOplog - true if this oplog is the latest oplog in the disk store.
-  long recoverCrf(OplogEntryIdSet deletedIds, boolean recoverValues, boolean recoverValuesSync, boolean alreadyRecoveredOnce,
-      Set<Oplog> oplogsNeedingValueRecovery, boolean latestOplog) {
+  long recoverCrf(OplogEntryIdSet deletedIds, boolean recoverValues, boolean recoverValuesSync,
+      boolean alreadyRecoveredOnce, Set<Oplog> oplogsNeedingValueRecovery, boolean latestOplog) {
-    this.diskFile = new File(this.drf.f.getParentFile(), oplogSet.getPrefix() + getParent().getName() + "_" + this.oplogId);
+    this.diskFile = new File(this.drf.f.getParentFile(),
+        oplogSet.getPrefix() + getParent().getName() + "_" + this.oplogId);
-      if (!readKrf(deletedIds, recoverValues, recoverValuesSync, oplogsNeedingValueRecovery, latestOplog)) {
-        logger.info(LocalizedMessage.create(LocalizedStrings.DiskRegion_RECOVERING_OPLOG_0_1_2, new Object[] { toString(),
-            crfFile.getAbsolutePath(), getParent().getName() }));
+      if (!readKrf(deletedIds, recoverValues, recoverValuesSync, oplogsNeedingValueRecovery,
+          latestOplog)) {
+        logger.info(LocalizedMessage.create(LocalizedStrings.DiskRegion_RECOVERING_OPLOG_0_1_2,
+            new Object[] {toString(), crfFile.getAbsolutePath(), getParent().getName()}));
-  public DiskEntry.RecoveredEntry createRecoveredEntry(byte[] valueBytes, int valueLength, byte userBits, long oplogId,
-      long offsetInOplog, long oplogKeyId, boolean recoverValue, Version version, ByteArrayDataInput in) {
+  public DiskEntry.RecoveredEntry createRecoveredEntry(byte[] valueBytes, int valueLength,
+      byte userBits, long oplogId, long offsetInOplog, long oplogKeyId, boolean recoverValue,
+      Version version, ByteArrayDataInput in) {
-      re = new DiskEntry.RecoveredEntry(oplogKeyId, oplogId, offsetInOplog, userBits, valueLength, value);
+      re = new DiskEntry.RecoveredEntry(oplogKeyId, oplogId, offsetInOplog, userBits, valueLength,
+          value);
-        throw new IllegalStateException("expected end of record (byte==" + END_OF_RECORD_ID + ") or zero but found " + b);
+        throw new IllegalStateException(
+            "expected end of record (byte==" + END_OF_RECORD_ID + ") or zero but found " + b);
-   * @param dis
-   *          DataInputStream from which the oplog is being read
-   * @param opcode
-   *          byte whether the id is short/int/long
+   * @param dis DataInputStream from which the oplog is being read
+   * @param opcode byte whether the id is short/int/long
-  private void readNewEntry(CountingDataInputStream dis, byte opcode, OplogEntryIdSet deletedIds, boolean recoverValue,
-      final LocalRegion currentRegion, Version version, ByteArrayDataInput in,
+  private void readNewEntry(CountingDataInputStream dis, byte opcode, OplogEntryIdSet deletedIds,
+      boolean recoverValue, final LocalRegion currentRegion, Version version, ByteArrayDataInput in,
-    
+
-    if (drs != null && !drs.getDiskRegionView().getFlags().contains(DiskRegionFlag.IS_WITH_VERSIONING)) {
+    if (drs != null
+        && !drs.getDiskRegionView().getFlags().contains(DiskRegionFlag.IS_WITH_VERSIONING)) {
-              "readNewEntry SKIPPING oplogKeyId=<{}> drId={} userBits={} keyLen={} valueLen={} tag={}", oplogKeyId, drId, userBits,
-              len, valueLength, tag);
+              "readNewEntry SKIPPING oplogKeyId=<{}> drId={} userBits={} keyLen={} valueLen={} tag={}",
+              oplogKeyId, drId, userBits, len, valueLength, tag);
-            getOplogSet().getChild().copyForwardForOfflineCompact(oplogKeyId, p2cr.getKeyBytes(), objValue, userBits, drId, tag);
+            getOplogSet().getChild().copyForwardForOfflineCompact(oplogKeyId, p2cr.getKeyBytes(),
+                objValue, userBits, drId, tag);
-              logger.trace(LogMarker.PERSIST_RECOVERY, "readNewEntry copyForward oplogKeyId=<{}>", oplogKeyId);
+              logger.trace(LogMarker.PERSIST_RECOVERY, "readNewEntry copyForward oplogKeyId=<{}>",
+                  oplogKeyId);
-              throw new AssertionError(LocalizedStrings.Oplog_DUPLICATE_CREATE.toLocalizedString(oplogKeyId));
+              throw new AssertionError(
+                  LocalizedStrings.Oplog_DUPLICATE_CREATE.toLocalizedString(oplogKeyId));
-                  "readNewEntry oplogKeyId=<{}> drId={} key={} userBits={} oplogOffset={} valueLen={} tag={}", oplogKeyId, drId, key,
-                  userBits, oplogOffset, valueLength, tag);
+                  "readNewEntry oplogKeyId=<{}> drId={} key={} userBits={} oplogOffset={} valueLen={} tag={}",
+                  oplogKeyId, drId, key, userBits, oplogOffset, valueLength, tag);
-            DiskEntry.RecoveredEntry re = createRecoveredEntry(objValue, valueLength, userBits, getOplogId(), oplogOffset,
-                oplogKeyId, recoverValue, version, in);
+            DiskEntry.RecoveredEntry re = createRecoveredEntry(objValue, valueLength, userBits,
+                getOplogId(), oplogOffset, oplogKeyId, recoverValue, version, in);
-                  "ignore readNewEntry because getOplogId()={} != curdid.getOplogId()={} for drId={} key={}", getOplogId(), curdid
-                  .getOplogId(), drId, key);
+                  "ignore readNewEntry because getOplogId()={} != curdid.getOplogId()={} for drId={} key={}",
+                  getOplogId(), curdid.getOplogId(), drId, key);
-   * @param dis
-   *          DataInputStream from which the oplog is being read
-   * @param opcode
-   *          byte whether the id is short/int/long
+   * @param dis DataInputStream from which the oplog is being read
+   * @param opcode byte whether the id is short/int/long
-  private void readModifyEntry(CountingDataInputStream dis, byte opcode, OplogEntryIdSet deletedIds, boolean recoverValue,
-      LocalRegion currentRegion, Version version, ByteArrayDataInput in, HeapDataOutputStream hdos)
-      throws IOException {
+  private void readModifyEntry(CountingDataInputStream dis, byte opcode, OplogEntryIdSet deletedIds,
+      boolean recoverValue, LocalRegion currentRegion, Version version, ByteArrayDataInput in,
+      HeapDataOutputStream hdos) throws IOException {
-    
+
-    if (drs != null && !drs.getDiskRegionView().getFlags().contains(DiskRegionFlag.IS_WITH_VERSIONING)) {
+    if (drs != null
+        && !drs.getDiskRegionView().getFlags().contains(DiskRegionFlag.IS_WITH_VERSIONING)) {
-            "readModifyEntry oplogKeyId=<{}> drId={} key=<{}> userBits={} oplogOffset={} tag={} valueLen={}", oplogKeyId, drId, key,
-            userBits, oplogOffset, tag, valueLength);
+            "readModifyEntry oplogKeyId=<{}> drId={} key=<{}> userBits={} oplogOffset={} tag={} valueLen={}",
+            oplogKeyId, drId, key, userBits, oplogOffset, tag, valueLength);
-          getOplogSet().getChild().copyForwardForOfflineCompact(oplogKeyId, p2cr.getKeyBytes(), objValue, userBits, drId, tag);
+          getOplogSet().getChild().copyForwardForOfflineCompact(oplogKeyId, p2cr.getKeyBytes(),
+              objValue, userBits, drId, tag);
-            logger.trace(LogMarker.PERSIST_RECOVERY, "readModifyEntry copyForward oplogKeyId=<{}>", oplogKeyId);
+            logger.trace(LogMarker.PERSIST_RECOVERY, "readModifyEntry copyForward oplogKeyId=<{}>",
+                oplogKeyId);
-          DiskEntry.RecoveredEntry re = createRecoveredEntry(objValue, valueLength, userBits, getOplogId(), oplogOffset,
-              oplogKeyId, recoverValue, version, in);
+          DiskEntry.RecoveredEntry re = createRecoveredEntry(objValue, valueLength, userBits,
+              getOplogId(), oplogOffset, oplogKeyId, recoverValue, version, in);
-                "readModEntryWK init oplogKeyId=<{}> drId={} key=<{}> oplogOffset={} userBits={} valueLen={} tag={}", oplogKeyId,
-                drId, key, oplogOffset, userBits, valueLength, tag);
+                "readModEntryWK init oplogKeyId=<{}> drId={} key=<{}> oplogOffset={} userBits={} valueLen={} tag={}",
+                oplogKeyId, drId, key, oplogOffset, userBits, valueLength, tag);
-          DiskEntry.RecoveredEntry re = createRecoveredEntry(objValue, valueLength, userBits, getOplogId(), oplogOffset,
-              oplogKeyId, recoverValue, version, in);
+          DiskEntry.RecoveredEntry re = createRecoveredEntry(objValue, valueLength, userBits,
+              getOplogId(), oplogOffset, oplogKeyId, recoverValue, version, in);
-        logger.trace(LogMarker.PERSIST_RECOVERY, "skipping readModifyEntry oplogKeyId=<{}> drId={}", oplogKeyId, drId);
+        logger.trace(LogMarker.PERSIST_RECOVERY, "skipping readModifyEntry oplogKeyId=<{}> drId={}",
+            oplogKeyId, drId);
-  private void readVersionTagOnlyEntry(CountingDataInputStream dis, byte opcode) throws IOException {
+  private void readVersionTagOnlyEntry(CountingDataInputStream dis, byte opcode)
+      throws IOException {
-  private void validateValue(byte[] valueBytes, byte userBits, Version version, ByteArrayDataInput in) {
+  private void validateValue(byte[] valueBytes, byte userBits, Version version,
+      ByteArrayDataInput in) {
-   * @param dis
-   *          DataInputStream from which the oplog is being read
-   * @param opcode
-   *          byte whether the id is short/int/long
+   * @param dis DataInputStream from which the oplog is being read
+   * @param opcode byte whether the id is short/int/long
-  private void readModifyEntryWithKey(CountingDataInputStream dis, byte opcode, OplogEntryIdSet deletedIds, boolean recoverValue,
-      final LocalRegion currentRegion, Version version, ByteArrayDataInput in,
-      HeapDataOutputStream hdos) throws IOException {
+  private void readModifyEntryWithKey(CountingDataInputStream dis, byte opcode,
+      OplogEntryIdSet deletedIds, boolean recoverValue, final LocalRegion currentRegion,
+      Version version, ByteArrayDataInput in, HeapDataOutputStream hdos) throws IOException {
-    if (drs != null && !drs.getDiskRegionView().getFlags().contains(DiskRegionFlag.IS_WITH_VERSIONING)) {
+    if (drs != null
+        && !drs.getDiskRegionView().getFlags().contains(DiskRegionFlag.IS_WITH_VERSIONING)) {
-        logger.trace(LogMarker.PERSIST_RECOVERY, "skipping readModEntryWK init oplogKeyId=<{}> drId={}", oplogKeyId, drId);
+        logger.trace(LogMarker.PERSIST_RECOVERY,
+            "skipping readModEntryWK init oplogKeyId=<{}> drId={}", oplogKeyId, drId);
-          getOplogSet().getChild().copyForwardForOfflineCompact(oplogKeyId, p2cr.getKeyBytes(), objValue, userBits, drId, tag);
+          getOplogSet().getChild().copyForwardForOfflineCompact(oplogKeyId, p2cr.getKeyBytes(),
+              objValue, userBits, drId, tag);
-            logger.trace(LogMarker.PERSIST_RECOVERY, "readModifyEntryWithKey copyForward oplogKeyId=<{}>", oplogKeyId);
+            logger.trace(LogMarker.PERSIST_RECOVERY,
+                "readModifyEntryWithKey copyForward oplogKeyId=<{}>", oplogKeyId);
-          throw new AssertionError(LocalizedStrings.Oplog_DUPLICATE_CREATE.toLocalizedString(oplogKeyId));
+          throw new AssertionError(
+              LocalizedStrings.Oplog_DUPLICATE_CREATE.toLocalizedString(oplogKeyId));
-          DiskEntry.RecoveredEntry re = createRecoveredEntry(objValue, valueLength, userBits, getOplogId(), oplogOffset,
-              oplogKeyId, recoverValue, version, in);
+          DiskEntry.RecoveredEntry re = createRecoveredEntry(objValue, valueLength, userBits,
+              getOplogId(), oplogOffset, oplogKeyId, recoverValue, version, in);
-                "readModEntryWK init oplogKeyId=<{}> drId={} key={} oplogOffset={} userBits={} valueLen={} tag={}", oplogKeyId, drId,
-                key, oplogOffset, userBits, valueLength, tag);
+                "readModEntryWK init oplogKeyId=<{}> drId={} key={} oplogOffset={} userBits={} valueLen={} tag={}",
+                oplogKeyId, drId, key, oplogOffset, userBits, valueLength, tag);
-          assert curdid.getOplogId() != getOplogId() : "Mutiple ModEntryWK in the same oplog for getOplogId()=" + getOplogId()
-              + " , curdid.getOplogId()=" + curdid.getOplogId() + " , for drId=" + drId + " , key=" + key;
+          assert curdid
+              .getOplogId() != getOplogId() : "Mutiple ModEntryWK in the same oplog for getOplogId()="
+                  + getOplogId() + " , curdid.getOplogId()=" + curdid.getOplogId() + " , for drId="
+                  + drId + " , key=" + key;
-                "ignore readModEntryWK because getOplogId()={} != curdid.getOplogId()={} for drId={} key={}", getOplogId(), curdid
-                .getOplogId(), drId, key);
+                "ignore readModEntryWK because getOplogId()={} != curdid.getOplogId()={} for drId={} key={}",
+                getOplogId(), curdid.getOplogId(), drId, key);
-   * @param dis
-   *          DataInputStream from which the oplog is being read
-   * @param opcode
-   *          byte whether the id is short/int/long
-   * @param parent
-   *          instance of disk region
+   * @param dis DataInputStream from which the oplog is being read
+   * @param opcode byte whether the id is short/int/long
+   * @param parent instance of disk region
-  private void readDelEntry(CountingDataInputStream dis, byte opcode, OplogEntryIdSet deletedIds, DiskStoreImpl parent)
-      throws IOException
+  private void readDelEntry(CountingDataInputStream dis, byte opcode, OplogEntryIdSet deletedIds,
+      DiskStoreImpl parent) throws IOException
-   * Keeps track of the drId of Regions that have records in this oplog that
-   * have not yet been recovered. If this count is > 0 then this oplog can not
-   * be compacted.
+   * Keeps track of the drId of Regions that have records in this oplog that have not yet been
+   * recovered. If this count is > 0 then this oplog can not be compacted.
-   * For each dri that this oplog has that is currently unrecoverable check to
-   * see if a DiskRegion that is recoverable now exists.
+   * For each dri that this oplog has that is currently unrecoverable check to see if a DiskRegion
+   * that is recoverable now exists.
-   * Returns true if it is ok the skip the current modify record which had the
-   * given oplogEntryId. It is ok to skip if any of the following are true: 1.
-   * deletedIds contains the id 2. the last modification of the entry was done
-   * by a record read from an oplog other than this oplog
+   * Returns true if it is ok the skip the current modify record which had the given oplogEntryId.
+   * It is ok to skip if any of the following are true: 1. deletedIds contains the id 2. the last
+   * modification of the entry was done by a record read from an oplog other than this oplog
-  private OkToSkipResult okToSkipModifyRecord(OplogEntryIdSet deletedIds, long drId, DiskRecoveryStore drs, long oplogEntryId,
-      boolean checkRecoveryMap, VersionTag tag) {
+  private OkToSkipResult okToSkipModifyRecord(OplogEntryIdSet deletedIds, long drId,
+      DiskRecoveryStore drs, long oplogEntryId, boolean checkRecoveryMap, VersionTag tag) {
-        logger.trace(LogMarker.PERSIST_RECOVERY, "okToSkip because oplogEntryId={} was deleted for drId={}", oplogEntryId, drId);
+        logger.trace(LogMarker.PERSIST_RECOVERY,
+            "okToSkip because oplogEntryId={} was deleted for drId={}", oplogEntryId, drId);
-                    "okToSkip because getOplogId()={} != curdid.getOplogId()={} for drId={} key={}", getOplogId(), curdid
-                    .getOplogId(), drId, key);
+                    "okToSkip because getOplogId()={} != curdid.getOplogId()={} for drId={} key={}",
+                    getOplogId(), curdid.getOplogId(), drId, key);
-   * Returns true if the drId region has been destroyed or if oplogKeyId
-   * preceeds the last clear done on the drId region
+   * Returns true if the drId region has been destroyed or if oplogKeyId preceeds the last clear
+   * done on the drId region
-        logger.trace(LogMarker.PERSIST_RECOVERY, "lastClearKeyId={} oplogKeyId={}", lastClearKeyId, oplogKeyId);
+        logger.trace(LogMarker.PERSIST_RECOVERY, "lastClearKeyId={} oplogKeyId={}", lastClearKeyId,
+            oplogKeyId);
-            logger.trace(LogMarker.PERSIST_RECOVERY, "okToSkip because oplogKeyId={} <= lastClearKeyId={} for drId={}", oplogKeyId,
+            logger.trace(LogMarker.PERSIST_RECOVERY,
+                "okToSkip because oplogKeyId={} <= lastClearKeyId={} for drId={}", oplogKeyId,
-            logger.trace(LogMarker.PERSIST_RECOVERY, "okToSkip because oplogKeyId={} <= lastClearKeyId={} for drId={}", oplogKeyId,
+            logger.trace(LogMarker.PERSIST_RECOVERY,
+                "okToSkip because oplogKeyId={} <= lastClearKeyId={} for drId={}", oplogKeyId,
-          logger.trace(LogMarker.PERSIST_RECOVERY, "okToSkip because tag={} <= clearRVV={} for drId={}", tag, clearRVV, drv.getId());
+          logger.trace(LogMarker.PERSIST_RECOVERY,
+              "okToSkip because tag={} <= clearRVV={} for drId={}", tag, clearRVV, drv.getId());
-  private/* HACK DEBUG */static long getEntryIdDelta(CountingDataInputStream dis, int idByteCount) throws IOException {
+  private/* HACK DEBUG */static long getEntryIdDelta(CountingDataInputStream dis, int idByteCount)
+      throws IOException {
-   * Call this when the cache is closed or region is destroyed. Deletes the lock
-   * files.
+   * Call this when the cache is closed or region is destroyed. Deletes the lock files.
-   * Note that this can return true even when we still need to keep the oplog
-   * around because its drf is still needed.
+   * Note that this can return true even when we still need to keep the oplog around because its drf
+   * is still needed.
-   * Destroys this oplog. First it will call close which will cleanly close all
-   * Async threads and then the oplog file will be deleted. The deletion of lock
-   * files will be taken care of by the close.
+   * Destroys this oplog. First it will call close which will cleanly close all Async threads and
+   * then the oplog file will be deleted. The deletion of lock files will be taken care of by the
+   * close.
-   * In offline compaction, after compacted each oplog, only the crf will be
-   * deleted. Oplog with drf only will be housekepted later.
+   * In offline compaction, after compacted each oplog, only the crf will be deleted. Oplog with drf
+   * only will be housekepted later.
-   * A check to confirm that the oplog has been closed because of the cache
-   * being closed
+   * A check to confirm that the oplog has been closed because of the cache being closed
-   * Return the number of bytes needed to encode the given long. Value returned
-   * will be >= 1 and <= 8.
+   * Return the number of bytes needed to encode the given long. Value returned will be >= 1 and <=
+   * 8.
-   * @param opCode
-   *          The int value identifying whether it is create/modify or delete
-   *          operation
-   * @param entry
-   *          The DiskEntry object being operated upon
-   * @param value
-   *          The byte array representing the value
+   * @param opCode The int value identifying whether it is create/modify or delete operation
+   * @param entry The DiskEntry object being operated upon
+   * @param value The byte array representing the value
-  private void initOpState(byte opCode, DiskRegionView dr, DiskEntry entry, ValueWrapper value, byte userBits,
-      boolean notToUseUserBits) throws IOException {
+  private void initOpState(byte opCode, DiskRegionView dr, DiskEntry entry, ValueWrapper value,
+      byte userBits, boolean notToUseUserBits) throws IOException {
-   * Asif: Modified the code so as to reuse the already created ByteBuffer
-   * during transition. Creates a key/value pair from a region entry on disk.
-   * Updates all of the necessary {@linkplain DiskStoreStats statistics} and
-   * invokes basicCreate
+   * Asif: Modified the code so as to reuse the already created ByteBuffer during transition.
+   * Creates a key/value pair from a region entry on disk. Updates all of the necessary
+   * {@linkplain DiskStoreStats statistics} and invokes basicCreate
-   * @param entry
-   *          The DiskEntry object for this key/value pair.
-   * @param value
-   *          byte array representing the value
+   * @param entry The DiskEntry object for this key/value pair.
+   * @param value byte array representing the value
-            throw new AssertionError("Version stamp should have a member at this point for entry " + entry);
+            throw new AssertionError(
+                "Version stamp should have a member at this point for entry " + entry);
-        throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()),
-            ex, region.getFullPath());
+        throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0
+            .toLocalizedString(this.diskFile.getPath()), ex, region.getFullPath());
-                .toLocalizedString(this.diskFile.getPath()), ie, region.getFullPath());
+                .toLocalizedString(this.diskFile.getPath()),
+            ie, region.getFullPath());
-   * Asif: A helper function which identifies whether to create the entry in the
-   * current oplog or to make the switch to the next oplog. This function
-   * enables us to reuse the byte buffer which got created for an oplog which no
-   * longer permits us to use itself
+   * Asif: A helper function which identifies whether to create the entry in the current oplog or to
+   * make the switch to the next oplog. This function enables us to reuse the byte buffer which got
+   * created for an oplog which no longer permits us to use itself
-   * @param entry
-   *          DiskEntry object representing the current Entry
+   * @param entry DiskEntry object representing the current Entry
-  private void basicCreate(DiskRegion dr, DiskEntry entry, ValueWrapper value, byte userBits, boolean async) throws IOException,
-      InterruptedException {
+  private void basicCreate(DiskRegion dr, DiskEntry entry, ValueWrapper value, byte userBits,
+      boolean async) throws IOException, InterruptedException {
-              abs(id.getKeyId()), entry.getKey(), startPosForSynchOp, userBits, (value != null ? value.getLength() : 0),
-              value.getBytesAsString(), dr.getId(), tag, getOplogId());
+              abs(id.getKeyId()), entry.getKey(), startPosForSynchOp, userBits,
+              (value != null ? value.getLength() : 0), value.getBytesAsString(), dr.getId(), tag,
+              getOplogId());
-          rvv.recordVersion(entry.getVersionStamp().getMemberID(), entry.getVersionStamp().getRegionVersion());
+          rvv.recordVersion(entry.getVersionStamp().getMemberID(),
+              entry.getVersionStamp().getRegionVersion());
-   * public void forceRolling() { if (getOplogSet().getChild() == this) {
-   * synchronized (this.lock) { if (getOplogSet().getChild() == this) {
-   * switchOpLog(0, null); } } if (!this.sync) {
+   * public void forceRolling() { if (getOplogSet().getChild() == this) { synchronized (this.lock) {
+   * if (getOplogSet().getChild() == this) { switchOpLog(0, null); } } if (!this.sync) {
-   * Asif: This function is used to switch from one op Log to another , when the
-   * size of the current oplog has reached the maximum permissible. It is always
-   * called from synch block with lock object being the OpLog File object We
-   * will reuse the ByteBuffer Pool. We should add the current Oplog for
-   * compaction first & then try to get next directory holder as in case there
-   * is only a single directory with space being full, compaction has to happen
-   * before it can be given a new directory. If the operation causing the
-   * switching is on an Entry which already is referencing the oplog to be
-   * compacted, then the compactor thread will skip compaction that entry & the
+   * Asif: This function is used to switch from one op Log to another , when the size of the current
+   * oplog has reached the maximum permissible. It is always called from synch block with lock
+   * object being the OpLog File object We will reuse the ByteBuffer Pool. We should add the current
+   * Oplog for compaction first & then try to get next directory holder as in case there is only a
+   * single directory with space being full, compaction has to happen before it can be given a new
+   * directory. If the operation causing the switching is on an Entry which already is referencing
+   * the oplog to be compacted, then the compactor thread will skip compaction that entry & the
-   * @param lengthOfOperationCausingSwitch
-   *          length of the operation causing the switch
-   * @param entryCausingSwitch
-   *          DiskEntry object operation on which caused the switching of Oplog.
-   *          This can be null if the switching has been invoked by the
-   *          forceRolling which does not need an operation on entry to cause
-   *          the switch
+   * @param lengthOfOperationCausingSwitch length of the operation causing the switch
+   * @param entryCausingSwitch DiskEntry object operation on which caused the switching of Oplog.
+   *        This can be null if the switching has been invoked by the forceRolling which does not
+   *        need an operation on entry to cause the switch
-  private void switchOpLog(DiskRegionView dr, int lengthOfOperationCausingSwitch, DiskEntry entryCausingSwitch) {
+  private void switchOpLog(DiskRegionView dr, int lengthOfOperationCausingSwitch,
+      DiskEntry entryCausingSwitch) {
-              .toLocalizedString((entryCausingSwitch != null ? entryCausingSwitch.getDiskId().toString() : "\"null Entry\"")),
+              .toLocalizedString((entryCausingSwitch != null
+                  ? entryCausingSwitch.getDiskId().toString() : "\"null Entry\"")),
-      logger.debug("Oplog::switchOpLog: About to add the Oplog = {} for compaction. Entry causing the switch is having DiskID = {}",
-          this.oplogId, (entryCausingSwitch != null ? entryCausingSwitch.getDiskId() : "null Entry"));
+      logger.debug(
+          "Oplog::switchOpLog: About to add the Oplog = {} for compaction. Entry causing the switch is having DiskID = {}",
+          this.oplogId,
+          (entryCausingSwitch != null ? entryCausingSwitch.getDiskId() : "null Entry"));
-      DirectoryHolder nextDirHolder = getOplogSet().getNextDir(lengthOfOperationCausingSwitch, true);
+      DirectoryHolder nextDirHolder =
+          getOplogSet().getNextDir(lengthOfOperationCausingSwitch, true);
-   * Used when creating a KRF to keep track of what DiskRegionView a DiskEntry
-   * belongs to.
+   * Used when creating a KRF to keep track of what DiskRegionView a DiskEntry belongs to.
-     * Fix for 42733 - a stable snapshot of the offset so we can sort It doesn't
-     * matter that this is stale, we'll filter out these entries later.
+     * Fix for 42733 - a stable snapshot of the offset so we can sort It doesn't matter that this is
+     * stale, we'll filter out these entries later.
-          "krf oplogId={} key={} oplogKeyId={} de={} vo={} vl={} diskRegionId={} version tag={}", oplogId, deKey, oplogKeyId,
-          System.identityHashCode(de), valueOffset, valueLength, diskRegionId, tag);
+          "krf oplogId={} key={} oplogKeyId={} de={} vo={} vl={} diskRegionId={} version tag={}",
+          oplogId, deKey, oplogKeyId, System.identityHashCode(de), valueOffset, valueLength,
+          diskRegionId, tag);
-    writeOneKeyEntryForKRF(keyBytes, userBits, valueLength, diskRegionId, oplogKeyId, valueOffset, tag);
+    writeOneKeyEntryForKRF(keyBytes, userBits, valueLength, diskRegionId, oplogKeyId, valueOffset,
+        tag);
-  private void writeOneKeyEntryForKRF(byte[] keyBytes, byte userBits, int valueLength, long diskRegionId, long oplogKeyId,
-      long valueOffset, VersionHolder tag) throws IOException {
+  private void writeOneKeyEntryForKRF(byte[] keyBytes, byte userBits, int valueLength,
+      long diskRegionId, long oplogKeyId, long valueOffset, VersionHolder tag) throws IOException {
-        logger.info(LocalizedMessage.create(LocalizedStrings.Oplog_CREATE_0_1_2, new Object[] { toString(), "krf",
-            getParent().getName() }));
+        logger.info(LocalizedMessage.create(LocalizedStrings.Oplog_CREATE_0_1_2,
+            new Object[] {toString(), "krf", getParent().getName()}));
-        logger.info("Fail to close krf file " + this.krf.f+", but a DiskAccessException happened ealier", getParent().getDiskAccessException());
+        logger.info(
+            "Fail to close krf file " + this.krf.f + ", but a DiskAccessException happened ealier",
+            getParent().getDiskAccessException());
-   * Create the KRF file for this oplog. It is ok for this method to be async.
-   * finishKRF will be called and it must block until KRF generation is
-   * complete.
+   * Create the KRF file for this oplog. It is ok for this method to be async. finishKRF will be
+   * called and it must block until KRF generation is complete.
-   * @param cancel
-   *          if true then prevent the krf from being created if possible
+   * @param cancel if true then prevent the krf from being created if possible
-   * Asif:This function retrieves the value for an entry being compacted subject
-   * to entry referencing the oplog being compacted. Attempt is made to retrieve
-   * the value from in memory , if available, else from asynch buffers ( if
-   * asynch mode is enabled), else from the Oplog being compacted. It is invoked
-   * from switchOplog as well as OplogCompactor's compact function.
+   * Asif:This function retrieves the value for an entry being compacted subject to entry
+   * referencing the oplog being compacted. Attempt is made to retrieve the value from in memory ,
+   * if available, else from asynch buffers ( if asynch mode is enabled), else from the Oplog being
+   * compacted. It is invoked from switchOplog as well as OplogCompactor's compact function.
-   * @param entry
-   *          DiskEntry being compacted referencing the Oplog being compacted
-   * @param wrapper
-   *          Object of type BytesAndBitsForCompactor. The data if found is set
-   *          in the wrapper Object. The wrapper Object also contains the user
-   *          bit associated with the entry
-   * @return boolean false indicating that entry need not be compacted. If true
-   *         it means that wrapper has been appropriately filled with data
+   * @param entry DiskEntry being compacted referencing the Oplog being compacted
+   * @param wrapper Object of type BytesAndBitsForCompactor. The data if found is set in the wrapper
+   *        Object. The wrapper Object also contains the user bit associated with the entry
+   * @return boolean false indicating that entry need not be compacted. If true it means that
+   *         wrapper has been appropriately filled with data
-  private boolean getBytesAndBitsForCompaction(DiskRegionView dr, DiskEntry entry, BytesAndBitsForCompactor wrapper) {
+  private boolean getBytesAndBitsForCompaction(DiskRegionView dr, DiskEntry entry,
+      BytesAndBitsForCompactor wrapper) {
-    @Retained @Released Object value = entry._getValueRetain(dr, true);
+    @Retained
+    @Released
+    Object value = entry._getValueRetain(dr, true);
-      foundData = basicGetForCompactor(dr, oplogOffset, false, did.getValueLength(), did.getUserBits(), wrapper);
+      foundData = basicGetForCompactor(dr, oplogOffset, false, did.getValueLength(),
+          did.getUserBits(), wrapper);
-          wrapper.setData(DiskEntry.INVALID_BYTES, userBits, DiskEntry.INVALID_BYTES.length, false/*
-                                                                                                   * Can
-                                                                                                   * not
-                                                                                                   * be
-                                                                                                   * reused
-                                                                                                   */);
+          wrapper.setData(DiskEntry.INVALID_BYTES, userBits, DiskEntry.INVALID_BYTES.length,
+              false/*
+                    * Can not be reused
+                    */);
-          wrapper.setData(DiskEntry.LOCAL_INVALID_BYTES, userBits, DiskEntry.LOCAL_INVALID_BYTES.length, false/*
-                                                                                                               * Can
-                                                                                                               * not
-                                                                                                               * be
-                                                                                                               * reused
-                                                                                                               */);
+          wrapper.setData(DiskEntry.LOCAL_INVALID_BYTES, userBits,
+              DiskEntry.LOCAL_INVALID_BYTES.length, false/*
+                                                          * Can not be reused
+                                                          */);
-        wrapper.setData(DiskEntry.TOMBSTONE_BYTES, userBits, DiskEntry.TOMBSTONE_BYTES.length, false/*
-                                                                                                     * Can
-                                                                                                     * not
-                                                                                                     * be
-                                                                                                     * reused
-                                                                                                     */);
+        wrapper.setData(DiskEntry.TOMBSTONE_BYTES, userBits, DiskEntry.TOMBSTONE_BYTES.length,
+            false/*
+                  * Can not be reused
+                  */);
-        wrapper.setData(DiskEntry.INVALID_BYTES, userBits, DiskEntry.INVALID_BYTES.length, false /*
-                                                                                                  * Cannot
-                                                                                                  * be
-                                                                                                  * reused
-                                                                                                  */);
+        wrapper.setData(DiskEntry.INVALID_BYTES, userBits, DiskEntry.INVALID_BYTES.length,
+            false /*
+                   * Cannot be reused
+                   */);
-        wrapper.setData(DiskEntry.LOCAL_INVALID_BYTES, userBits, DiskEntry.LOCAL_INVALID_BYTES.length, false /*
-                                                                                                              * Cannot
-                                                                                                              * be
-                                                                                                              * reused
-                                                                                                              */);
+        wrapper.setData(DiskEntry.LOCAL_INVALID_BYTES, userBits,
+            DiskEntry.LOCAL_INVALID_BYTES.length, false /*
+                                                         * Cannot be reused
+                                                         */);
-        wrapper.setData(DiskEntry.TOMBSTONE_BYTES, userBits, DiskEntry.TOMBSTONE_BYTES.length, false /*
-                                                                                                      * Cannot
-                                                                                                      * be
-                                                                                                      * reused
-                                                                                                      */);
+        wrapper.setData(DiskEntry.TOMBSTONE_BYTES, userBits, DiskEntry.TOMBSTONE_BYTES.length,
+            false /*
+                   * Cannot be reused
+                   */);
-          @Released StoredObject ohproxy = (StoredObject) proxy;
+          @Released
+          StoredObject ohproxy = (StoredObject) proxy;
-        wrapper.setData(valueBytes, userBits, valueBytes.length, false /*
-                                                                        * the
-                                                                        * wrapper
-                                                                        * is not
-                                                                        * reusable
-                                                                        */);
+        wrapper.setData(valueBytes, userBits, valueBytes.length,
+            false /*
+                   * the wrapper is not reusable
+                   */);
-            throw new DiskAccessException(
-                LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()), ex, dr.getName());
+            throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0
+                .toLocalizedString(this.diskFile.getPath()), ex, dr.getName());
-                    .toLocalizedString(this.diskFile.getPath()), ie, dr.getName());
+                    .toLocalizedString(this.diskFile.getPath()),
+                ie, dr.getName());
-   * Modifies a key/value pair from a region entry on disk. Updates all of the
-   * necessary {@linkplain DiskStoreStats statistics} and invokes basicModify
+   * Modifies a key/value pair from a region entry on disk. Updates all of the necessary
+   * {@linkplain DiskStoreStats statistics} and invokes basicModify
-   * @param entry
-   *          DiskEntry object representing the current Entry
+   * @param entry DiskEntry object representing the current Entry
-   * @param value
-   *          byte array representing the value
+   * @param value byte array representing the value
-   * Asif: Modified the code so as to reuse the already created ByteBuffer
-   * during transition. Minimizing the synchronization allowing multiple put
-   * operations for different entries to proceed concurrently for asynch mode
+   * Asif: Modified the code so as to reuse the already created ByteBuffer during transition.
+   * Minimizing the synchronization allowing multiple put operations for different entries to
+   * proceed concurrently for asynch mode
-            throw new AssertionError("Version stamp should have a member at this point for entry " + entry);
+            throw new AssertionError(
+                "Version stamp should have a member at this point for entry " + entry);
-        throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()),
-            ex, region.getFullPath());
+        throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0
+            .toLocalizedString(this.diskFile.getPath()), ex, region.getFullPath());
-                .toLocalizedString(this.diskFile.getPath()), ie, region.getFullPath());
+                .toLocalizedString(this.diskFile.getPath()),
+            ie, region.getFullPath());
-          throw new AssertionError("Version stamp should have a member at this point for entry " + entry);
+          throw new AssertionError(
+              "Version stamp should have a member at this point for entry " + entry);
-        vt.setEntryVersion(vt.getEntryVersion()+1);
+        vt.setEntryVersion(vt.getEntryVersion() + 1);
-      throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()), ex, drv.getName());
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()),
+          ex, drv.getName());
-              .toLocalizedString(this.diskFile.getPath()), ie, drv.getName());
+              .toLocalizedString(this.diskFile.getPath()),
+          ie, drv.getName());
-    
+
-        throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_CONFLICT_VERSION_TAG_0.toLocalizedString(this.diskFile
-            .getPath()), ex, region.getFullPath());
+        throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_CONFLICT_VERSION_TAG_0
+            .toLocalizedString(this.diskFile.getPath()), ex, region.getFullPath());
-        throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_CONFLICT_VERSION_TAG_0.toLocalizedString(this.diskFile
-            .getPath()), ie, region.getFullPath());
+        throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_CONFLICT_VERSION_TAG_0
+            .toLocalizedString(this.diskFile.getPath()), ie, region.getFullPath());
-  private final void copyForwardForOfflineCompact(long oplogKeyId, byte[] keyBytes, byte[] valueBytes, byte userBits, long drId,
-      VersionTag tag) {
+  private final void copyForwardForOfflineCompact(long oplogKeyId, byte[] keyBytes,
+      byte[] valueBytes, byte userBits, long drId, VersionTag tag) {
-      throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()), ex,
-          getParent());
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()),
+          ex, getParent());
-              .toLocalizedString(this.diskFile.getPath()), ie, getParent());
+              .toLocalizedString(this.diskFile.getPath()),
+          ie, getParent());
-  private final void copyForwardModifyForCompact(DiskRegionView dr, DiskEntry entry, BytesAndBitsForCompactor wrapper) {
+  private final void copyForwardModifyForCompact(DiskRegionView dr, DiskEntry entry,
+      BytesAndBitsForCompactor wrapper) {
-          vw = new DiskEntry.Helper.CompactorValueWrapper(wrapper.getBytes(), wrapper.getValidLength());
+          vw = new DiskEntry.Helper.CompactorValueWrapper(wrapper.getBytes(),
+              wrapper.getValidLength());
-        throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()),
-            ex, getParent());
+        throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0
+            .toLocalizedString(this.diskFile.getPath()), ex, getParent());
-                .toLocalizedString(this.diskFile.getPath()), ie, getParent());
+                .toLocalizedString(this.diskFile.getPath()),
+            ie, getParent());
-   * Asif: A helper function which identifies whether to modify the entry in the
-   * current oplog or to make the switch to the next oplog. This function
-   * enables us to reuse the byte buffer which got created for an oplog which no
-   * longer permits us to use itself. It will also take acre of compaction if
-   * required
+   * Asif: A helper function which identifies whether to modify the entry in the current oplog or to
+   * make the switch to the next oplog. This function enables us to reuse the byte buffer which got
+   * created for an oplog which no longer permits us to use itself. It will also take acre of
+   * compaction if required
-   * @param entry
-   *          DiskEntry object representing the current Entry
+   * @param entry DiskEntry object representing the current Entry
-  private void basicModify(DiskRegionView dr, DiskEntry entry, ValueWrapper value, byte userBits, boolean async,
-      boolean calledByCompactor) throws IOException, InterruptedException {
+  private void basicModify(DiskRegionView dr, DiskEntry entry, ValueWrapper value, byte userBits,
+      boolean async, boolean calledByCompactor) throws IOException, InterruptedException {
-              "basicModify: id=<{}> key=<{}> valueOffset={} userBits={} valueLen={} valueBytes=<{}> drId={} versionStamp={} oplog#{}",
-              abs(id.getKeyId()), entry.getKey(), startPosForSynchOp, userBits, value.getLength(), value.getBytesAsString(),
-              dr.getId(), tag, getOplogId());
+                "basicModify: id=<{}> key=<{}> valueOffset={} userBits={} valueLen={} valueBytes=<{}> drId={} versionStamp={} oplog#{}",
+                abs(id.getKeyId()), entry.getKey(), startPosForSynchOp, userBits, value.getLength(),
+                value.getBytesAsString(), dr.getId(), tag, getOplogId());
-            rvv.recordVersion(entry.getVersionStamp().getMemberID(), entry.getVersionStamp().getRegionVersion());
+            rvv.recordVersion(entry.getVersionStamp().getMemberID(),
+                entry.getVersionStamp().getRegionVersion());
-      if (emptyOplog != null && (!emptyOplog.isCompacting() || emptyOplog.calledByCompactorThread())) {
+      if (emptyOplog != null
+          && (!emptyOplog.isCompacting() || emptyOplog.calledByCompactorThread())) {
-  private void basicSaveConflictVersionTag(DiskRegionView dr, VersionTag tag, boolean async) throws IOException,
-      InterruptedException {
+  private void basicSaveConflictVersionTag(DiskRegionView dr, VersionTag tag, boolean async)
+      throws IOException, InterruptedException {
-            logger.trace(LogMarker.PERSIST_WRITES, "basicSaveConflictVersionTag: drId={} versionStamp={} oplog#", dr.getId(), tag,
+            logger.trace(LogMarker.PERSIST_WRITES,
+                "basicSaveConflictVersionTag: drId={} versionStamp={} oplog#", dr.getId(), tag,
-  private void basicCopyForwardForOfflineCompact(long oplogKeyId, byte[] keyBytes, byte[] valueBytes, byte userBits, long drId,
-      VersionTag tag) throws IOException, InterruptedException {
+  private void basicCopyForwardForOfflineCompact(long oplogKeyId, byte[] keyBytes,
+      byte[] valueBytes, byte userBits, long drId, VersionTag tag)
+      throws IOException, InterruptedException {
-          getOplogSet().getChild().writeOneKeyEntryForKRF(keyBytes, userBits, valueBytes.length, drId, oplogKeyId,
-              startPosForSynchOp, tag);
+          getOplogSet().getChild().writeOneKeyEntryForKRF(keyBytes, userBits, valueBytes.length,
+              drId, oplogKeyId, startPosForSynchOp, tag);
-                oplogKeyId, baToString(keyBytes), startPosForSynchOp, userBits, valueBytes.length, baToString(valueBytes),
-                getOplogId());
+                oplogKeyId, baToString(keyBytes), startPosForSynchOp, userBits, valueBytes.length,
+                baToString(valueBytes), getOplogId());
-      getOplogSet().getChild().basicCopyForwardForOfflineCompact(oplogKeyId, keyBytes, valueBytes, userBits, drId, tag);
+      getOplogSet().getChild().basicCopyForwardForOfflineCompact(oplogKeyId, keyBytes, valueBytes,
+          userBits, drId, tag);
-      dri = (isCompactionPossible() || couldHaveKrf()) ? new DiskRegionInfoWithList(dr, couldHaveKrf(), this.krfCreated.get())
+      dri = (isCompactionPossible() || couldHaveKrf())
+          ? new DiskRegionInfoWithList(dr, couldHaveKrf(), this.krfCreated.get())
-      dri = (isCompactionPossible() || couldHaveKrf()) ? new DiskRegionInfoWithList(null, couldHaveKrf(), this.krfCreated.get())
+      dri = (isCompactionPossible() || couldHaveKrf())
+          ? new DiskRegionInfoWithList(null, couldHaveKrf(), this.krfCreated.get())
-   * @param entry
-   *          DiskEntry object on which remove operation is called
+   * @param entry DiskEntry object on which remove operation is called
-        throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()),
-            ex, dr.getName());
+        throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0
+            .toLocalizedString(this.diskFile.getPath()), ex, dr.getName());
-                .toLocalizedString(this.diskFile.getPath()), ie, dr.getName());
+                .toLocalizedString(this.diskFile.getPath()),
+            ie, dr.getName());
-          writeRVVRecord(this.drf, Collections.<Long, AbstractDiskRegion> singletonMap(dr.getId(), dr), true);
+          writeRVVRecord(this.drf,
+              Collections.<Long, AbstractDiskRegion>singletonMap(dr.getId(), dr), true);
-          throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_RECORDING_RVV_BECAUSE_OF_0.toLocalizedString(this.diskFile
-              .getPath()), ex, dr.getName());
+          throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_RECORDING_RVV_BECAUSE_OF_0
+              .toLocalizedString(this.diskFile.getPath()), ex, dr.getName());
-   * There're 3 cases to use writeRVV: 1) endGII:
-   * DiskRegion.writeRVV(region=null, true), Oplog.writeRVV(true,null) 2)
-   * beginGII: DiskRegion.writeRVV(region=this, false),
-   * Oplog.writeRVV(false,sourceRVV!=null) 3) clear:
-   * DiskRegion.writeRVV(region=this, null),
+   * There're 3 cases to use writeRVV: 1) endGII: DiskRegion.writeRVV(region=null, true),
+   * Oplog.writeRVV(true,null) 2) beginGII: DiskRegion.writeRVV(region=this, false),
+   * Oplog.writeRVV(false,sourceRVV!=null) 3) clear: DiskRegion.writeRVV(region=this, null),
-          writeRVVRecord(this.crf, Collections.<Long, AbstractDiskRegion> singletonMap(dr.getId(), dr), false);
+          writeRVVRecord(this.crf,
+              Collections.<Long, AbstractDiskRegion>singletonMap(dr.getId(), dr), false);
-          throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_RECORDING_RVV_BECAUSE_OF_0.toLocalizedString(this.diskFile
-              .getPath()), ex, dr.getName());
+          throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_RECORDING_RVV_BECAUSE_OF_0
+              .toLocalizedString(this.diskFile.getPath()), ex, dr.getName());
-   * Asif: A helper function which identifies whether to record a removal of
-   * entry in the current oplog or to make the switch to the next oplog. This
-   * function enables us to reuse the byte buffer which got created for an oplog
-   * which no longer permits us to use itself. It will also take acre of
-   * compaction if required
+   * Asif: A helper function which identifies whether to record a removal of entry in the current
+   * oplog or to make the switch to the next oplog. This function enables us to reuse the byte
+   * buffer which got created for an oplog which no longer permits us to use itself. It will also
+   * take acre of compaction if required
-   * @param entry
-   *          DiskEntry object representing the current Entry
+   * @param entry DiskEntry object representing the current Entry
-  private void basicRemove(DiskRegionView dr, DiskEntry entry, boolean async, boolean isClear) throws IOException,
-      InterruptedException {
+  private void basicRemove(DiskRegionView dr, DiskEntry entry, boolean async, boolean isClear)
+      throws IOException, InterruptedException {
-      } else if ((this.drf.currSize + MAX_DELETE_ENTRY_RECORD_BYTES) > getMaxDrfSize() && !isFirstRecord()) {
+      } else if ((this.drf.currSize + MAX_DELETE_ENTRY_RECORD_BYTES) > getMaxDrfSize()
+          && !isFirstRecord()) {
-          
+
-            logger.debug("basicRemove: id=<{}> key=<{}> drId={} oplog#{}", abs(id.getKeyId()), entry.getKey(), dr.getId(),
-                getOplogId());
+            logger.debug("basicRemove: id=<{}> key=<{}> drId={} oplog#{}", abs(id.getKeyId()),
+                entry.getKey(), dr.getId(), getOplogId());
-      if (emptyOplog != null && (!emptyOplog.isCompacting() || emptyOplog.calledByCompactorThread())) {
+      if (emptyOplog != null
+          && (!emptyOplog.isCompacting() || emptyOplog.calledByCompactorThread())) {
-  
+
-  
+
-      throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()), ex,
-          getParent());
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()),
+          ex, getParent());
-   * Asif: Since the ByteBuffer being writen to can have additional bytes which
-   * are used for extending the size of the file, it is necessary that the
-   * ByteBuffer provided should have limit which is set to the position till
-   * which it contains the actual bytes. If the mode is synched write then only
-   * we will write up to the capacity & opLogSpace variable have any meaning.
-   * For asynch mode it will be zero. Also this method must be synchronized on
-   * the file , whether we use synch or asynch write because the fault in
-   * operations can clash with the asynch writing. Write the specified bytes to
-   * the oplog. Note that since extending a file is expensive this code will
-   * possibly write OPLOG_EXTEND_SIZE zero bytes to reduce the number of times
-   * the file is extended.
+   * Asif: Since the ByteBuffer being writen to can have additional bytes which are used for
+   * extending the size of the file, it is necessary that the ByteBuffer provided should have limit
+   * which is set to the position till which it contains the actual bytes. If the mode is synched
+   * write then only we will write up to the capacity & opLogSpace variable have any meaning. For
+   * asynch mode it will be zero. Also this method must be synchronized on the file , whether we use
+   * synch or asynch write because the fault in operations can clash with the asynch writing. Write
+   * the specified bytes to the oplog. Note that since extending a file is expensive this code will
+   * possibly write OPLOG_EXTEND_SIZE zero bytes to reduce the number of times the file is extended.
-   * @param olf
-   *          the file to write the bytes to
-   * @return The long offset at which the data present in the ByteBuffer gets
-   *         written to
+   * @param olf the file to write the bytes to
+   * @return The long offset at which the data present in the ByteBuffer gets written to
-  private long writeOpLogBytes(OplogFile olf, boolean async, boolean doFlushIfSync) throws IOException {
+  private long writeOpLogBytes(OplogFile olf, boolean async, boolean doFlushIfSync)
+      throws IOException {
-   * If crfRAF has been closed then attempt to reopen the oplog for this read.
-   * Verify that this only happens when test methods are invoked.
+   * If crfRAF has been closed then attempt to reopen the oplog for this read. Verify that this only
+   * happens when test methods are invoked.
-  private BytesAndBits attemptGet(DiskRegionView dr, long offsetInOplog, boolean bitOnly, int valueLength, byte userBits)
-      throws IOException {
+  private BytesAndBits attemptGet(DiskRegionView dr, long offsetInOplog, boolean bitOnly,
+      int valueLength, byte userBits) throws IOException {
-            final long writePosition = (this.doneAppending) ? this.crf.bytesFlushed : myRAF.getFilePointer();
+            final long writePosition =
+                (this.doneAppending) ? this.crf.bytesFlushed : myRAF.getFilePointer();
-                      .toLocalizedString(new Object[] { readPosition + valueLength, writePosition, this.crf.raf }), dr.getName());
+                      .toLocalizedString(
+                          new Object[] {readPosition + valueLength, writePosition, this.crf.raf}),
+                  dr.getName());
-              throw new DiskAccessException(LocalizedStrings.Oplog_CANNOT_FIND_RECORD_0_WHEN_READING_FROM_1
-                  .toLocalizedString(new Object[] { offsetInOplog, this.diskFile.getPath() }), dr.getName());
+              throw new DiskAccessException(
+                  LocalizedStrings.Oplog_CANNOT_FIND_RECORD_0_WHEN_READING_FROM_1.toLocalizedString(
+                      new Object[] {offsetInOplog, this.diskFile.getPath()}),
+                  dr.getName());
-   * @param offsetInOplog
-   *          The starting position from which to read the data in the opLog
-   * @param bitOnly
-   *          boolean indicating whether the value needs to be extracted along
-   *          with the UserBit or not.
-   * @param valueLength
-   *          The length of the byte array which represents the value
-   * @param userBits
-   *          The userBits of the value.
+   * @param offsetInOplog The starting position from which to read the data in the opLog
+   * @param bitOnly boolean indicating whether the value needs to be extracted along with the
+   *        UserBit or not.
+   * @param valueLength The length of the byte array which represents the value
+   * @param userBits The userBits of the value.
-  private BytesAndBits basicGet(DiskRegionView dr, long offsetInOplog, boolean bitOnly, int valueLength, byte userBits) {
+  private BytesAndBits basicGet(DiskRegionView dr, long offsetInOplog, boolean bitOnly,
+      int valueLength, byte userBits) {
-    if (EntryBits.isAnyInvalid(userBits) || EntryBits.isTombstone(userBits) || bitOnly || valueLength == 0) {
+    if (EntryBits.isAnyInvalid(userBits) || EntryBits.isTombstone(userBits) || bitOnly
+        || valueLength == 0) {
-                .toLocalizedString(new Object[] { this.diskFile.getPath(), Long.valueOf(this.oplogId), Long.valueOf(offsetInOplog),
-                    Long.valueOf(this.crf.currSize), Long.valueOf(this.crf.bytesFlushed), Boolean.valueOf(!dr.isSync()),
-                    Boolean.valueOf(false) }), ex, dr.getName());
+                .toLocalizedString(new Object[] {this.diskFile.getPath(),
+                    Long.valueOf(this.oplogId), Long.valueOf(offsetInOplog),
+                    Long.valueOf(this.crf.currSize), Long.valueOf(this.crf.bytesFlushed),
+                    Boolean.valueOf(!dr.isSync()), Boolean.valueOf(false)}),
+            ex, dr.getName());
-   * Asif: Extracts the Value byte array & UserBit from the OpLog and inserts it
-   * in the wrapper Object of type BytesAndBitsForCompactor which is passed
+   * Asif: Extracts the Value byte array & UserBit from the OpLog and inserts it in the wrapper
+   * Object of type BytesAndBitsForCompactor which is passed
-   * @param offsetInOplog
-   *          The starting position from which to read the data in the opLog
-   * @param bitOnly
-   *          boolean indicating whether the value needs to be extracted along
-   *          with the UserBit or not.
-   * @param valueLength
-   *          The length of the byte array which represents the value
-   * @param userBits
-   *          The userBits of the value.
-   * @param wrapper
-   *          Object of type BytesAndBitsForCompactor. The data is set in the
-   *          wrapper Object. The wrapper Object also contains the user bit
-   *          associated with the entry
+   * @param offsetInOplog The starting position from which to read the data in the opLog
+   * @param bitOnly boolean indicating whether the value needs to be extracted along with the
+   *        UserBit or not.
+   * @param valueLength The length of the byte array which represents the value
+   * @param userBits The userBits of the value.
+   * @param wrapper Object of type BytesAndBitsForCompactor. The data is set in the wrapper Object.
+   *        The wrapper Object also contains the user bit associated with the entry
-  private boolean basicGetForCompactor(DiskRegionView dr, long offsetInOplog, boolean bitOnly, int valueLength, byte userBits,
-      BytesAndBitsForCompactor wrapper) {
-    if (EntryBits.isAnyInvalid(userBits) || EntryBits.isTombstone(userBits) || bitOnly || valueLength == 0) {
+  private boolean basicGetForCompactor(DiskRegionView dr, long offsetInOplog, boolean bitOnly,
+      int valueLength, byte userBits, BytesAndBitsForCompactor wrapper) {
+    if (EntryBits.isAnyInvalid(userBits) || EntryBits.isTombstone(userBits) || bitOnly
+        || valueLength == 0) {
-        wrapper.setData(DiskEntry.INVALID_BYTES, userBits, DiskEntry.INVALID_BYTES.length, false /*
-                                                                                                  * Cannot
-                                                                                                  * be
-                                                                                                  * reused
-                                                                                                  */);
+        wrapper.setData(DiskEntry.INVALID_BYTES, userBits, DiskEntry.INVALID_BYTES.length,
+            false /*
+                   * Cannot be reused
+                   */);
-        wrapper.setData(DiskEntry.TOMBSTONE_BYTES, userBits, DiskEntry.TOMBSTONE_BYTES.length, false /*
-                                                                                                      * Cannot
-                                                                                                      * be
-                                                                                                      * reused
-                                                                                                      */);
+        wrapper.setData(DiskEntry.TOMBSTONE_BYTES, userBits, DiskEntry.TOMBSTONE_BYTES.length,
+            false /*
+                   * Cannot be reused
+                   */);
-        wrapper.setData(DiskEntry.LOCAL_INVALID_BYTES, userBits, DiskEntry.LOCAL_INVALID_BYTES.length, false /*
-                                                                                                              * Cannot
-                                                                                                              * be
-                                                                                                              * reused
-                                                                                                              */);
+        wrapper.setData(DiskEntry.LOCAL_INVALID_BYTES, userBits,
+            DiskEntry.LOCAL_INVALID_BYTES.length, false /*
+                                                         * Cannot be reused
+                                                         */);
-          final long writePosition = (this.doneAppending) ? this.crf.bytesFlushed : this.crf.raf.getFilePointer();
+          final long writePosition =
+              (this.doneAppending) ? this.crf.bytesFlushed : this.crf.raf.getFilePointer();
-                    .toLocalizedString(new Object[] { readPosition + valueLength, writePosition, this.crf.raf }), dr.getName());
+                    .toLocalizedString(
+                        new Object[] {readPosition + valueLength, writePosition, this.crf.raf}),
+                dr.getName());
-            throw new DiskAccessException(LocalizedStrings.Oplog_CANNOT_FIND_RECORD_0_WHEN_READING_FROM_1
-                .toLocalizedString(new Object[] { Long.valueOf(offsetInOplog), this.diskFile.getPath() }), dr.getName());
+            throw new DiskAccessException(
+                LocalizedStrings.Oplog_CANNOT_FIND_RECORD_0_WHEN_READING_FROM_1.toLocalizedString(
+                    new Object[] {Long.valueOf(offsetInOplog), this.diskFile.getPath()}),
+                dr.getName());
-        throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_READING_FROM_0_OPLOG_DETAILS_1_2_3_4_5_6
-            .toLocalizedString(new Object[] { this.diskFile.getPath(), Long.valueOf(this.oplogId), Long.valueOf(offsetInOplog),
-                Long.valueOf(this.crf.currSize), Long.valueOf(this.crf.bytesFlushed), Boolean.valueOf(/*
-                                                                                                       * !
-                                                                                                       * dr
-                                                                                                       * .
-                                                                                                       * isSync
-                                                                                                       * (
-                                                                                                       * )
-                                                                                                       * @
-                                                                                                       * todo
-                                                                                                       */false),
-                Boolean.valueOf(false) }), ex, dr.getName());
+        throw new DiskAccessException(
+            LocalizedStrings.Oplog_FAILED_READING_FROM_0_OPLOG_DETAILS_1_2_3_4_5_6
+                .toLocalizedString(new Object[] {this.diskFile.getPath(),
+                    Long.valueOf(this.oplogId), Long.valueOf(offsetInOplog),
+                    Long.valueOf(this.crf.currSize), Long.valueOf(this.crf.bytesFlushed),
+                    Boolean.valueOf(/*
+                                     * ! dr . isSync ( )
+                                     * 
+                                     * @ todo
+                                     */false), Boolean.valueOf(false)}),
+            ex, dr.getName());
-      final File krf = new File(this.crf.f.getAbsolutePath().replaceFirst("\\" + CRF_FILE_EXT + "$", KRF_FILE_EXT));
+      final File krf = new File(
+          this.crf.f.getAbsolutePath().replaceFirst("\\" + CRF_FILE_EXT + "$", KRF_FILE_EXT));
-              logger.warn(LocalizedMessage.create(LocalizedStrings.Oplog_DELETE_FAIL_0_1_2, new Object[] { Oplog.this.toString(),
-                  "krf", getParent().getName() }));
+              logger.warn(LocalizedMessage.create(LocalizedStrings.Oplog_DELETE_FAIL_0_1_2,
+                  new Object[] {Oplog.this.toString(), "krf", getParent().getName()}));
-            logger.info(LocalizedMessage.create(LocalizedStrings.Oplog_DELETE_0_1_2, new Object[] { Oplog.this.toString(), "krf",
-                getParent().getName() }));
+            logger.info(LocalizedMessage.create(LocalizedStrings.Oplog_DELETE_0_1_2,
+                new Object[] {Oplog.this.toString(), "krf", getParent().getName()}));
-            logger.warn(LocalizedMessage.create(LocalizedStrings.Oplog_DELETE_FAIL_0_1_2, new Object[] { Oplog.this.toString(),
-                getFileType(olf), getParent().getName() }));
+            logger.warn(LocalizedMessage.create(LocalizedStrings.Oplog_DELETE_FAIL_0_1_2,
+                new Object[] {Oplog.this.toString(), getFileType(olf), getParent().getName()}));
-            logger.info(LocalizedMessage.create(LocalizedStrings.Oplog_DELETE_0_1_2, new Object[] { Oplog.this.toString(),
-                getFileType(olf), getParent().getName() }));
+            logger.info(LocalizedMessage.create(LocalizedStrings.Oplog_DELETE_0_1_2,
+                new Object[] {Oplog.this.toString(), getFileType(olf), getParent().getName()}));
-  UninterruptibleFileChannel getFileChannel()
-  {
+  UninterruptibleFileChannel getFileChannel() {
-   * The current size of Oplog. It may be less than the actual Oplog file size (
-   * in case of asynch writing as it also takes into account data present in
-   * asynch buffers which will get flushed in course of time o
+   * The current size of Oplog. It may be less than the actual Oplog file size ( in case of asynch
+   * writing as it also takes into account data present in asynch buffers which will get flushed in
+   * course of time o
-    // if we have an unrecoveredRegion then we don't know how many liveValues we
-    // have
+        // if we have an unrecoveredRegion then we don't know how many liveValues we
+        // have
-      logger.debug("Deleting oplog early because it is empty. It is for disk store {} and has oplog#{}", getParent().getName(),
-          oplogId);
+      logger.debug(
+          "Deleting oplog early because it is empty. It is for disk store {} and has oplog#{}",
+          getParent().getName(), oplogId);
-        logger.info(LocalizedMessage.create(LocalizedStrings.Oplog_CLOSING_EMPTY_OPLOG_0_1, new Object[] { getParent().getName(),
-            toString() }));
+        logger.info(LocalizedMessage.create(LocalizedStrings.Oplog_CLOSING_EMPTY_OPLOG_0_1,
+            new Object[] {getParent().getName(), toString()}));
-   * The oplogId in re points to the oldOplogId. "this" oplog is the current
-   * oplog.
+   * The oplogId in re points to the oldOplogId. "this" oplog is the current oplog.
-   * Copy any live entries last stored in this oplog to the current oplog. No
-   * need to copy deletes in the drf. Backup only needs them until all the older
-   * crfs are empty.
+   * Copy any live entries last stored in this oplog to the current oplog. No need to copy deletes
+   * in the drf. Backup only needs them until all the older crfs are empty.
-    return crfFilename.substring(0, crfFilename.length() - Oplog.CRF_FILE_EXT.length()) + Oplog.KRF_FILE_EXT;
+    return crfFilename.substring(0, crfFilename.length() - Oplog.CRF_FILE_EXT.length())
+        + Oplog.KRF_FILE_EXT;
-   * This method is called by the async value recovery task to recover the
-   * values from the crf if the keys were recovered from the krf.
+   * This method is called by the async value recovery task to recover the values from the crf if
+   * the keys were recovered from the krf.
-  private byte[] serializeRVVs(Map<Long, AbstractDiskRegion> drMap, boolean gcRVV) throws IOException {
+  private byte[] serializeRVVs(Map<Long, AbstractDiskRegion> drMap, boolean gcRVV)
+      throws IOException {
-    for (Iterator<Map.Entry<Long, AbstractDiskRegion>> itr = drMap.entrySet().iterator(); itr.hasNext();) {
+    for (Iterator<Map.Entry<Long, AbstractDiskRegion>> itr = drMap.entrySet().iterator(); itr
+        .hasNext();) {
-        logger.trace(LogMarker.PERSIST_WRITES, "serializeRVVs: isGCRVV={} drId={} rvv={} oplog#{}", gcRVV, diskRegionID, rvv
-            .fullToString(), getOplogId());
+        logger.trace(LogMarker.PERSIST_WRITES, "serializeRVVs: isGCRVV={} drId={} rvv={} oplog#{}",
+            gcRVV, diskRegionID, rvv.fullToString(), getOplogId());
-        for (Map.Entry<VersionSource, RegionVersionHolder> memberEntry : memberToVersion.entrySet()) {
+        for (Map.Entry<VersionSource, RegionVersionHolder> memberEntry : memberToVersion
+            .entrySet()) {
-  private byte[] serializeVersionTag(int entryVersion, long regionVersion, VersionSource versionMember, long timestamp, int dsId)
-      throws IOException {
+  private byte[] serializeVersionTag(int entryVersion, long regionVersion,
+      VersionSource versionMember, long timestamp, int dsId) throws IOException {
-  private void serializeVersionTag(int entryVersion, long regionVersion, VersionSource versionMember, long timestamp, int dsId,
-      DataOutput out) throws IOException {
+  private void serializeVersionTag(int entryVersion, long regionVersion,
+      VersionSource versionMember, long timestamp, int dsId, DataOutput out) throws IOException {
-   * Holds all the state for the current operation. Since an oplog can only have
-   * one operation in progress at any given time we only need a single instance
-   * of this class per oplog.
+   * Holds all the state for the current operation. Since an oplog can only have one operation in
+   * progress at any given time we only need a single instance of this class per oplog.
-      sb.append(" opcode=").append(this.opCode).append(" len=").append(this.value.getLength()).append(" vb=").append(this.value.getBytesAsString());
+      sb.append(" opcode=").append(this.opCode).append(" len=").append(this.value.getLength())
+          .append(" vb=").append(this.value.getBytesAsString());
-    
+
-    public void initialize(long oplogKeyId, byte[] keyBytes, byte[] valueBytes, byte userBits, long drId, VersionTag tag,
-        boolean notToUseUserBits) throws IOException {
+    public void initialize(long oplogKeyId, byte[] keyBytes, byte[] valueBytes, byte userBits,
+        long drId, VersionTag tag, boolean notToUseUserBits) throws IOException {
-    public void initialize(byte opCode, DiskRegionView dr, DiskEntry entry, ValueWrapper value, byte userBits,
-        boolean notToUseUserBits) throws IOException {
+    public void initialize(byte opCode, DiskRegionView dr, DiskEntry entry, ValueWrapper value,
+        byte userBits, boolean notToUseUserBits) throws IOException {
-          Assert.fail("Attempting to write an entry with keyId=0 to oplog. Entry key=" + entry.getKey() + " diskId="
-              + entry.getDiskId() + " region=" + dr);
+          Assert.fail("Attempting to write an entry with keyId=0 to oplog. Entry key="
+              + entry.getKey() + " diskId=" + entry.getDiskId() + " region=" + dr);
-      // + 8 /* HACK DEBUG */
+          // + 8 /* HACK DEBUG */
-        if (EntryBits.isWithVersions(this.userBits) && this.versionsBytes != null && this.opCode != OPLOG_DEL_ENTRY_1ID) {
+        if (EntryBits.isWithVersions(this.userBits) && this.versionsBytes != null
+            && this.opCode != OPLOG_DEL_ENTRY_1ID) {
-   * Fake disk entry used to implement the circular linked list of entries an
-   * oplog has. Each Oplog will have one OplogDiskEntry whose prev and next
-   * fields point to the actual DiskEntrys currently stored in its crf. Items
-   * are added at "next" so the most recent entry written will be at next and
-   * the oldest item written will be at "prev".
+   * Fake disk entry used to implement the circular linked list of entries an oplog has. Each Oplog
+   * will have one OplogDiskEntry whose prev and next fields point to the actual DiskEntrys
+   * currently stored in its crf. Items are added at "next" so the most recent entry written will be
+   * at next and the oldest item written will be at "prev".
-    public synchronized int clear(RegionVersionVector rvv, Map<DiskEntry, VersionHolder> pendingKrfTags) {
+    public synchronized int clear(RegionVersionVector rvv,
+        Map<DiskEntry, VersionHolder> pendingKrfTags) {
-     * Clear using an RVV. Remove live entries that are contained within the
-     * clear RVV.
+     * Clear using an RVV. Remove live entries that are contained within the clear RVV.
-    public void handleValueOverflow(RegionEntryContext context) {throw new IllegalStateException();}
+    public void handleValueOverflow(RegionEntryContext context) {
+      throw new IllegalStateException();
+    }
-    public Object prepareValueForCache(RegionEntryContext r, Object val, boolean isEntryUpdate) { throw new IllegalStateException("Should never be called");  }
+    public Object prepareValueForCache(RegionEntryContext r, Object val, boolean isEntryUpdate) {
+      throw new IllegalStateException("Should never be called");
+    }
-     * Adds any live entries in this list to liveEntries and returns the index
-     * of the next free slot.
+     * Adds any live entries in this list to liveEntries and returns the index of the next free
+     * slot.
-     * @param liveEntries
-     *          the array to fill with the live entries
-     * @param idx
-     *          the first free slot in liveEntries
-     * @param drv
-     *          the disk region these entries are on
+     * @param liveEntries the array to fill with the live entries
+     * @param idx the first free slot in liveEntries
+     * @param drv the disk region these entries are on
-    public synchronized int addLiveEntriesToList(KRFEntry[] liveEntries, int idx, DiskRegionView drv,
-        Map<DiskEntry, VersionHolder> pendingKrfTags) {
+    public synchronized int addLiveEntriesToList(KRFEntry[] liveEntries, int idx,
+        DiskRegionView drv, Map<DiskEntry, VersionHolder> pendingKrfTags) {
-    public VersionTag generateVersionTag(VersionSource member, boolean withDelta, LocalRegion region, EntryEventImpl event) {
+    public VersionTag generateVersionTag(VersionSource member, boolean withDelta,
+        LocalRegion region, EntryEventImpl event) {
-    public boolean fillInValue(LocalRegion r, org.apache.geode.internal.cache.InitialImageOperation.Entry entry,
-        ByteArrayDataInput in, DM mgr) {
+    public boolean fillInValue(LocalRegion r,
+        org.apache.geode.internal.cache.InitialImageOperation.Entry entry, ByteArrayDataInput in,
+        DM mgr) {
-    public void setValueWithTombstoneCheck(Object value, EntryEvent event) throws RegionClearedException {
+    public void setValueWithTombstoneCheck(Object value, EntryEvent event)
+        throws RegionClearedException {
-    public boolean initialImagePut(LocalRegion region, long lastModified, Object newValue, boolean wasRecovered,
-        boolean acceptedVersionTag) throws RegionClearedException {
+    public boolean initialImagePut(LocalRegion region, long lastModified, Object newValue,
+        boolean wasRecovered, boolean acceptedVersionTag) throws RegionClearedException {
-    public boolean initialImageInit(LocalRegion region, long lastModified, Object newValue, boolean create, boolean wasRecovered,
-        boolean acceptedVersionTag) throws RegionClearedException {
+    public boolean initialImageInit(LocalRegion region, long lastModified, Object newValue,
+        boolean create, boolean wasRecovered, boolean acceptedVersionTag)
+        throws RegionClearedException {
-    public boolean destroy(LocalRegion region, EntryEventImpl event, boolean inTokenMode, boolean cacheWrite,
-        Object expectedOldValue, boolean forceDestroy, boolean removeRecoveredEntry) throws CacheWriterException,
-        EntryNotFoundException, TimeoutException, RegionClearedException {
+    public boolean destroy(LocalRegion region, EntryEventImpl event, boolean inTokenMode,
+        boolean cacheWrite, Object expectedOldValue, boolean forceDestroy,
+        boolean removeRecoveredEntry) throws CacheWriterException, EntryNotFoundException,
+        TimeoutException, RegionClearedException {
+
+
-    public void setValue(RegionEntryContext context, Object value,
-        EntryEventImpl event) throws RegionClearedException {
-    }
-    
+    public void setValue(RegionEntryContext context, Object value, EntryEventImpl event)
+        throws RegionClearedException {}
+
-    @Override
-    public void setInUseByTransaction(boolean v) {
-    }
-    @Override
-    public void incRefCount() {
-    }
-    @Override
-    public void decRefCount(NewLRUClockHand lruList, LocalRegion lr) {
-    }
-    @Override
-    public void resetRefCount(NewLRUClockHand lruList) {
-    }
-    public Object prepareValueForCache(RegionEntryContext r, Object val,
-        EntryEventImpl event, boolean isEntryUpdate) {
+    public void setInUseByTransaction(boolean v) {}
+
+    @Override
+    public void incRefCount() {}
+
+    @Override
+    public void decRefCount(NewLRUClockHand lruList, LocalRegion lr) {}
+
+    @Override
+    public void resetRefCount(NewLRUClockHand lruList) {}
+
+    @Override
+    public Object prepareValueForCache(RegionEntryContext r, Object val, EntryEventImpl event,
+        boolean isEntryUpdate) {
-    
+
-   * Used as the value in the regionMap. Tracks information about what the
-   * region has in this oplog.
+   * Used as the value in the regionMap. Tracks information about what the region has in this oplog.
-    public void replaceLive(DiskEntry old, DiskEntry de) {
-    }
+    public void replaceLive(DiskEntry old, DiskEntry de) {}
-     * A linked list of the live entries in this oplog. Updates to
-     * pendingKrfTags are protected by synchronizing on object.
+     * A linked list of the live entries in this oplog. Updates to pendingKrfTags are protected by
+     * synchronizing on object.
-     * A map of DiskEntry to the VersionTag that is written to disk associated
-     * with this tag. Only needed for async regions so that we can generate a
-     * krf with a version tag that matches the the tag we have written to disk
-     * for this oplog.
+     * A map of DiskEntry to the VersionTag that is written to disk associated with this tag. Only
+     * needed for async regions so that we can generate a krf with a version tag that matches the
+     * the tag we have written to disk for this oplog.
-        int result = this.liveEntries.addLiveEntriesToList(liveEntries, idx, getDiskRegion(), pendingKrfTags);
+        int result = this.liveEntries.addLiveEntriesToList(liveEntries, idx, getDiskRegion(),
+            pendingKrfTags);
-   * Used during offline compaction to hold information that may need to be
-   * copied forward.
+   * Used during offline compaction to hold information that may need to be copied forward.
-   * Mpa of OplogEntryIds (longs). Memory is optimized by using an int[] for ids
-   * in the unsigned int range.
+   * Mpa of OplogEntryIds (longs). Memory is optimized by using an int[] for ids in the unsigned int
+   * range.
-    private final Int2ObjectOpenHashMap ints = new Int2ObjectOpenHashMap((int) DiskStoreImpl.INVALID_ID);
-    private final Long2ObjectOpenHashMap longs = new Long2ObjectOpenHashMap((int)DiskStoreImpl.INVALID_ID);
+    private final Int2ObjectOpenHashMap ints =
+        new Int2ObjectOpenHashMap((int) DiskStoreImpl.INVALID_ID);
+    private final Long2ObjectOpenHashMap longs =
+        new Long2ObjectOpenHashMap((int) DiskStoreImpl.INVALID_ID);
-      ObjectIterator<Int2ObjectMap.Entry <?>> intIt = ints.int2ObjectEntrySet().fastIterator();
-      ObjectIterator<Long2ObjectMap.Entry <?>> longIt = longs.long2ObjectEntrySet().fastIterator();
+      ObjectIterator<Int2ObjectMap.Entry<?>> intIt = ints.int2ObjectEntrySet().fastIterator();
+      ObjectIterator<Long2ObjectMap.Entry<?>> longIt = longs.long2ObjectEntrySet().fastIterator();
-  private Object deserializeKey(byte[] keyBytes, final Version version, final ByteArrayDataInput in) {
+  private Object deserializeKey(byte[] keyBytes, final Version version,
+      final ByteArrayDataInput in) {
-   * If this OpLog is from an older version of the product, then return that
-   * {@link Version} else return null.
+   * If this OpLog is from an older version of the product, then return that {@link Version} else
+   * return null.
-   * If this OpLog has data that was written by an older version of the product,
-   * then return that {@link Version} else return null.
+   * If this OpLog has data that was written by an older version of the product, then return that
+   * {@link Version} else return null.
-   * Used in offline mode to prevent pdx deserialization of keys. The raw bytes
-   * are a serialized pdx.
+   * Used in offline mode to prevent pdx deserialization of keys. The raw bytes are a serialized
+   * pdx.

INS29 MOV29 UPD66 UPD66 MOV65 MOV65 MOV65 MOV65 MOV65 MOV65 MOV65 MOV65 MOV65 MOV65 MOV65 MOV65 MOV65 MOV65 INS65 MOV65 INS65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 MOV65 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 MOV65 INS66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29
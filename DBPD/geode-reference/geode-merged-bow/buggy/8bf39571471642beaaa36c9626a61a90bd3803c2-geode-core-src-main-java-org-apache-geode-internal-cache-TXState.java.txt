Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-/** TXState is the entity that tracks the transaction state on a per
- * thread basis, noting changes to Region entries on a per operation
- * basis. It lives on the node where transaction data exists.
+/**
+ * TXState is the entity that tracks the transaction state on a per thread basis, noting changes to
+ * Region entries on a per operation basis. It lives on the node where transaction data exists.
-  
+
-  // A map of transaction state by Region 
+  // A map of transaction state by Region
-  
+
-  
+
-  
+
-  
+
-   * Used to hand out modification serial numbers used to preserve
-   * the order of operation done by this transaction.
+   * Used to hand out modification serial numbers used to preserve the order of operation done by
+   * this transaction.
-  private final List<EntryEventImpl> pendingCallbacks =
-    new ArrayList<EntryEventImpl>();
+  private final List<EntryEventImpl> pendingCallbacks = new ArrayList<EntryEventImpl>();
- // Internal testing hooks
+  // Internal testing hooks
-  /** keeps track of events, so as not to re-apply events*/
+  /** keeps track of events, so as not to re-apply events */
-  
+
-  public TXState(TXStateProxy proxy,boolean onBehalfOfRemoteStub) 
-  {
+  public TXState(TXStateProxy proxy, boolean onBehalfOfRemoteStub) {
-    this.proxy = proxy; 
+    this.proxy = proxy;
-  
+
-  
+
-    builder.append(this.getClass())
-            .append("@")
-            .append(System.identityHashCode(this))
-            .append(" onBehalfOfRemoteStub:")
-            .append(this.onBehalfOfRemoteStub);
+    builder.append(this.getClass()).append("@").append(System.identityHashCode(this))
+        .append(" onBehalfOfRemoteStub:").append(this.onBehalfOfRemoteStub);
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  
+
-    for (EntryEventImpl ee: getPendingCallbacks()) {
-      if(ee.getOperation().isDestroy()) {
+    for (EntryEventImpl ee : getPendingCallbacks()) {
+      if (ee.getOperation().isDestroy()) {
-      } else if(ee.getOperation().isInvalidate()) {
+      } else if (ee.getOperation().isInvalidate()) {
-      } else if(ee.getOperation().isCreate()) {
+      } else if (ee.getOperation().isCreate()) {
-    for (EntryEventImpl ee: getPendingCallbacks()) {
+    for (EntryEventImpl ee : getPendingCallbacks()) {
-  
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#readRegion(org.apache.geode.internal.cache.LocalRegion)
+
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.TXStateInterface#readRegion(org.apache.geode.internal.cache.
+   * LocalRegion)
+
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#writeRegion(org.apache.geode.internal.cache.LocalRegion)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.TXStateInterface#writeRegion(org.apache.geode.internal.cache.
+   * LocalRegion)
-        result = new TXBucketRegionState((BucketRegion) r,this);
+        result = new TXBucketRegionState((BucketRegion) r, this);
-        result = new TXRegionState(r,this);
+        result = new TXRegionState(r, this);
-      logger.debug("TXState writeRegion flag {} region-state {} ",
-          false, result/*, new Throwable()*/);
+      logger.debug("TXState writeRegion flag {} region-state {} ", false,
+          result/* , new Throwable() */);
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  
+
-        this.proxy.getTxMgr().getCachePerfStats().incTxConflictCheckTime(CachePerfStats.getStatTime()-conflictStart);
+        this.proxy.getTxMgr().getCachePerfStats()
+            .incTxConflictCheckTime(CachePerfStats.getStatTime() - conflictStart);
+
+
-  
+
-  public void precommit() throws CommitConflictException,
-      UnsupportedOperationInTransactionException {
+  public void precommit()
+      throws CommitConflictException, UnsupportedOperationInTransactionException {
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  public void commit() throws CommitConflictException {    
+  public void commit() throws CommitConflictException {
-    
+
-    synchronized(this.completionGuard) {
+    synchronized (this.completionGuard) {
-    
-    if (onBehalfOfRemoteStub
-        && !proxy.isCommitOnBehalfOfRemoteStub()) {
-      throw new UnsupportedOperationInTransactionException(LocalizedStrings.TXState_CANNOT_COMMIT_REMOTED_TRANSACTION.toLocalizedString());
+
+    if (onBehalfOfRemoteStub && !proxy.isCommitOnBehalfOfRemoteStub()) {
+      throw new UnsupportedOperationInTransactionException(
+          LocalizedStrings.TXState_CANNOT_COMMIT_REMOTED_TRANSACTION.toLocalizedString());
-       * Lock buckets so they can't be rebalanced
-       * then perform the conflict check to fix #43489
+       * Lock buckets so they can't be rebalanced then perform the conflict check to fix #43489
-      } catch(PrimaryBucketException pbe) {
+      } catch (PrimaryBucketException pbe) {
-        RuntimeException re = new TransactionDataRebalancedException(LocalizedStrings.PartitionedRegion_TRANSACTIONAL_DATA_MOVED_DUE_TO_REBALANCING.toLocalizedString());
+        RuntimeException re = new TransactionDataRebalancedException(
+            LocalizedStrings.PartitionedRegion_TRANSACTIONAL_DATA_MOVED_DUE_TO_REBALANCING
+                .toLocalizedString());
-       * If there is a TransactionWriter plugged in,
-       * we need to to give it an opportunity to 
-       * abort the transaction.
+       * If there is a TransactionWriter plugged in, we need to to give it an opportunity to abort
+       * the transaction.
-      if(!firedWriter && writer!=null) {
+      if (!firedWriter && writer != null) {
-        } catch(TransactionWriterException twe) {
+        } catch (TransactionWriterException twe) {
-          //cleanup(); this allocates objects so I don't think we can do it - that leaves the TX open, but we are poison pilling so we should be ok??
-          
+          // cleanup(); this allocates objects so I don't think we can do it - that leaves the TX
+          // open, but we are poison pilling so we should be ok??
+
-          // If this ever returns, rethrow the error.  We're poisoned
+          // If this ever returns, rethrow the error. We're poisoned
-        }
-        catch (Throwable t) {
+        } catch (Throwable t) {
-          // catch VirtualMachineError (see above).  However, there is
+          // catch VirtualMachineError (see above). However, there is
-    
-      List/*<TXEntryStateWithRegionAndKey>*/ entries = generateEventOffsets();
+
+      List/* <TXEntryStateWithRegionAndKey> */ entries = generateEventOffsets();
-        
-        /* 
-         * In order to preserve data consistency, 
-         * we need to:
-         * 1. Modify the cache first (applyChanges)
-         * 2. Ask for advice on who to send to (buildMessage)
-         * 3. Send out to other members.
+
+        /*
+         * In order to preserve data consistency, we need to: 1. Modify the cache first
+         * (applyChanges) 2. Ask for advice on who to send to (buildMessage) 3. Send out to other
+         * members.
-         * If this is done out of order, we will have problems with GII, split brain, and HA.
-         * See bug #41187
+         * If this is done out of order, we will have problems with GII, split brain, and HA. See
+         * bug #41187
+         * 
-        
+
-        
+
-        // For internal testing 
+        // For internal testing
-        
+
-    
-      
-        
+
+
+
-        // For internal testing 
+        // For internal testing
-        
+
-        
+
-        // For internal testing 
+        // For internal testing
-  
+
-      Iterator/*<TXEntryStateWithRegionAndKey>*/ it = entries.iterator();
+      Iterator/* <TXEntryStateWithRegionAndKey> */ it = entries.iterator();
-        TXEntryStateWithRegionAndKey o = (TXEntryStateWithRegionAndKey)it.next();
+        TXEntryStateWithRegionAndKey o = (TXEntryStateWithRegionAndKey) it.next();
-          if(o.r.isUsedForPartitionedRegionBucket()) {
-            BucketRegion bucket = (BucketRegion)o.r;
+          if (o.r.isUsedForPartitionedRegionBucket()) {
+            BucketRegion bucket = (BucketRegion) o.r;
-            @Released EntryEventImpl ev = (EntryEventImpl)o.es.getEvent(o.r, o.key, o.es.getTXRegionState().getTXState());
+            @Released
+            EntryEventImpl ev =
+                (EntryEventImpl) o.es.getEvent(o.r, o.key, o.es.getTXRegionState().getTXState());
-            /*
-             * The routing information is derived from the PR advisor, not the bucket advisor.
-             */
-            FilterRoutingInfo fri = bucket.getPartitionedRegion().getRegionAdvisor().adviseFilterRouting(ev, Collections.EMPTY_SET);
-            o.es.setFilterRoutingInfo(fri);
-            Set set = bucket.getAdjunctReceivers(ev, Collections.EMPTY_SET, new HashSet(), fri);
-            o.es.setAdjunctRecipients(set);
+              /*
+               * The routing information is derived from the PR advisor, not the bucket advisor.
+               */
+              FilterRoutingInfo fri = bucket.getPartitionedRegion().getRegionAdvisor()
+                  .adviseFilterRouting(ev, Collections.EMPTY_SET);
+              o.es.setFilterRoutingInfo(fri);
+              Set set = bucket.getAdjunctReceivers(ev, Collections.EMPTY_SET, new HashSet(), fri);
+              o.es.setAdjunctRecipients(set);
-        } 
-        catch (CancelException ex) {
+        } catch (CancelException ex) {
-    
+
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-    synchronized(this.completionGuard) {
+    synchronized (this.completionGuard) {
-  
+
-   * This is a fix for bug #42228 where a client fails over from one server to
-   * another but gets a conflict on completion because completion had already
-   * been initiated and had not yet completed
+   * This is a fix for bug #42228 where a client fails over from one server to another but gets a
+   * conflict on completion because completion had already been initiated and had not yet completed
+   * 
-    synchronized(this.completionGuard) {// should have already been done, but just to be sure
+    synchronized (this.completionGuard) {// should have already been done, but just to be sure
-   * Generate an event id for each operation that will be done by this tx
-   * during the application phase of its commit.
-   * @return a sorted list of TXEntryStateWithRegionAndKey that will be used
-   *  to apply the ops on the nearside in the correct order.
+   * Generate an event id for each operation that will be done by this tx during the application
+   * phase of its commit.
+   * 
+   * @return a sorted list of TXEntryStateWithRegionAndKey that will be used to apply the ops on the
+   *         nearside in the correct order.
-  protected List/*<TXEntryStateWithRegionAndKey>*/ generateEventOffsets() {
+  protected List/* <TXEntryStateWithRegionAndKey> */ generateEventOffsets() {
-    
-     List/*<TXEntryStateWithRegionAndKey>*/ entries = getSortedEntries();
+
+    List/* <TXEntryStateWithRegionAndKey> */ entries = getSortedEntries();
-      logger.debug("generateEventOffsets() entries " + entries
-          + " RegionState Map=" + this.regions);
+      logger
+          .debug("generateEventOffsets() entries " + entries + " RegionState Map=" + this.regions);
-     Iterator it = entries.iterator();
-     while (it.hasNext()) {
-       TXEntryStateWithRegionAndKey o = (TXEntryStateWithRegionAndKey)it.next();
-       o.es.generateEventOffsets(this);
-     }
-     return entries;
+    Iterator it = entries.iterator();
+    while (it.hasNext()) {
+      TXEntryStateWithRegionAndKey o = (TXEntryStateWithRegionAndKey) it.next();
+      o.es.generateEventOffsets(this);
+    }
+    return entries;
-  
+
-  private void checkForConflicts() throws CommitConflictException,PrimaryBucketException {
+
+  private void checkForConflicts() throws CommitConflictException, PrimaryBucketException {
-      }catch(DiskAccessException dae) {
+      } catch (DiskAccessException dae) {
-      } 
+      }
-  
-  
+
+
-    
+
-        if (r instanceof BucketRegion && (((BucketRegion)r).getBucketAdvisor().isPrimary())) {
-          BucketRegion b = (BucketRegion)r;
+        if (r instanceof BucketRegion && (((BucketRegion) r).getBucketAdvisor().isPrimary())) {
+          BucketRegion b = (BucketRegion) r;
-              // if we can't get locks then someone has a write-lock.  To prevent
+              // if we can't get locks then someone has a write-lock. To prevent
-                logger.debug("tryLock failed for commit on {}. Releasing locks and retrying", r.getFullPath());
+                logger.debug("tryLock failed for commit on {}. Releasing locks and retrying",
+                    r.getFullPath());
-          } catch(RegionDestroyedException rde) {
+          } catch (RegionDestroyedException rde) {
-              logger.debug("RegionDestroyedException while locking bucket region {}", r.getFullPath(),rde);
+              logger.debug("RegionDestroyedException while locking bucket region {}",
+                  r.getFullPath(), rde);
-            throw new TransactionDataRebalancedException("Bucket rebalanced during commit: " + r.getFullPath());
+            throw new TransactionDataRebalancedException(
+                "Bucket rebalanced during commit: " + r.getFullPath());
-              // fix for bug #41708 - unlock operation-locks already obtained 
+              // fix for bug #41708 - unlock operation-locks already obtained
-              for (BucketRegion br: obtained) {
+              for (BucketRegion br : obtained) {
-  
-  
+
+
-        Iterator<Map.Entry<LocalRegion, TXRegionState>> it = this.regions.entrySet().iterator();
+    Iterator<Map.Entry<LocalRegion, TXRegionState>> it = this.regions.entrySet().iterator();
+
+   * 
-    TXCommitMessage msg = new TXCommitMessage(this.proxy.getTxId(), this.proxy.getTxMgr().getDM(), this);
+    TXCommitMessage msg =
+        new TXCommitMessage(this.proxy.getTxId(), this.proxy.getTxMgr().getDM(), this);
-  
-  
+
+
+   * 
-    TXCommitMessage msg = new TXCommitMessage(this.proxy.getTxId(), this.proxy.getTxMgr().getDM(), this);
+    TXCommitMessage msg =
+        new TXCommitMessage(this.proxy.getTxId(), this.proxy.getTxMgr().getDM(), this);
-      //rcl.add(r);
+      // rcl.add(r);
-  
+
-  protected void applyChanges(List/*<TXEntryStateWithRegionAndKey>*/ entries) {
-    {      
+  protected void applyChanges(List/* <TXEntryStateWithRegionAndKey> */ entries) {
+    {
-      Iterator/*<TXEntryStateWithRegionAndKey>*/ it = entries.iterator();
+      Iterator/* <TXEntryStateWithRegionAndKey> */ it = entries.iterator();
-        TXEntryStateWithRegionAndKey o = (TXEntryStateWithRegionAndKey)it.next();
+        TXEntryStateWithRegionAndKey o = (TXEntryStateWithRegionAndKey) it.next();
-        } 
-        catch (CancelException ex) {
+        } catch (CancelException ex) {
+
-  
+
-   * Note that cleanup does more than is needed in this method.
-   * This method only needs to do stuff that is required when a
-   * Cache close is done and we have txs that are still in progress.
-   * Currently the only thing that is needed is to decrement off-heap
-   * refcounts since off-heap memory lives after a cache close.
+   * Note that cleanup does more than is needed in this method. This method only needs to do stuff
+   * that is required when a Cache close is done and we have txs that are still in progress.
+   * Currently the only thing that is needed is to decrement off-heap refcounts since off-heap
+   * memory lives after a cache close.
-  @Override 
+  @Override
-      for (TXRegionState r: this.regions.values()) {
+      for (TXRegionState r : this.regions.values()) {
-  
+
-      if (this.locks!=null) {
+      if (this.locks != null) {
-          this.proxy.getTxMgr().getCachePerfStats().incTxConflictCheckTime(CachePerfStats.getStatTime()-conflictStart);
+          this.proxy.getTxMgr().getCachePerfStats()
+              .incTxConflictCheckTime(CachePerfStats.getStatTime() - conflictStart);
-          if (r instanceof BucketRegion && (((BucketRegion)r).getBucketAdvisor().isPrimary())) {
+          if (r instanceof BucketRegion && (((BucketRegion) r).getBucketAdvisor().isPrimary())) {
-              ((BucketRegion)r).doUnlockForPrimary();
-            } catch(RegionDestroyedException rde) {
+              ((BucketRegion) r).doUnlockForPrimary();
+            } catch (RegionDestroyedException rde) {
-                logger.debug("RegionDestroyedException while unlocking bucket region {}", r.getFullPath(), rde);
+                logger.debug("RegionDestroyedException while unlocking bucket region {}",
+                    r.getFullPath(), rde);
-            } catch(Exception rde) {
+            } catch (Exception rde) {
-                logger.debug("Exception while unlocking bucket region {} this is probably because the bucket was destroyed and never locked initially.",
+                logger.debug(
+                    "Exception while unlocking bucket region {} this is probably because the bucket was destroyed and never locked initially.",
-      synchronized(this.completionGuard) {
+      synchronized (this.completionGuard) {
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-      LocalRegion r = (LocalRegion)me.getKey();
-      TXRegionState txrs = (TXRegionState)me.getValue();
+      LocalRegion r = (LocalRegion) me.getKey();
+      TXRegionState txrs = (TXRegionState) me.getValue();
-  private List/*<TXEntryStateWithRegionAndKey>*/ getSortedEntries() {
-    ArrayList/*<TXEntryStateWithRegionAndKey>*/  entries = new ArrayList();
+  private List/* <TXEntryStateWithRegionAndKey> */ getSortedEntries() {
+    ArrayList/* <TXEntryStateWithRegionAndKey> */ entries = new ArrayList();
-      Map.Entry me = (Map.Entry)it.next();
-      LocalRegion r = (LocalRegion)me.getKey();
-      TXRegionState txrs = (TXRegionState)me.getValue();
+      Map.Entry me = (Map.Entry) it.next();
+      LocalRegion r = (LocalRegion) me.getKey();
+      TXRegionState txrs = (TXRegionState) me.getValue();
-   * Used to keep track of the region and key associated with a TXEntryState.
-   * Also used to sort the entries into the order in which they will be applied.
+   * Used to keep track of the region and key associated with a TXEntryState. Also used to sort the
+   * entries into the order in which they will be applied.
+   * 
+
+
+
-      TXEntryStateWithRegionAndKey other = (TXEntryStateWithRegionAndKey)o;
+      TXEntryStateWithRegionAndKey other = (TXEntryStateWithRegionAndKey) o;
-      if (o == null || !(o instanceof TXEntryStateWithRegionAndKey)) return false;
+      if (o == null || !(o instanceof TXEntryStateWithRegionAndKey))
+        return false;
-  
+
-  //           JTA Synchronization implementation                 //
+  // JTA Synchronization implementation //
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-    
-    
+
+
-       * If there is a TransactionWriter plugged in,
-       * we need to to give it an opportunity to 
-       * abort the transaction.
+       * If there is a TransactionWriter plugged in, we need to to give it an opportunity to abort
+       * the transaction.
-      if(writer!=null) {
+      if (writer != null) {
-          firedWriter  = true;
+          firedWriter = true;
-        } catch(TransactionWriterException twe) {
+        } catch (TransactionWriterException twe) {
-          //cleanup(); this allocates objects so I don't think we can do it - that leaves the TX open, but we are poison pilling so we should be ok??
-          
+          // cleanup(); this allocates objects so I don't think we can do it - that leaves the TX
+          // open, but we are poison pilling so we should be ok??
+
-          // If this ever returns, rethrow the error.  We're poisoned
+          // If this ever returns, rethrow the error. We're poisoned
-        }
-        catch (Throwable t) {
+        } catch (Throwable t) {
-          // catch VirtualMachineError (see above).  However, there is
+          // catch VirtualMachineError (see above). However, there is
-      
-      
+
+
-      throw new SynchronizationCommitConflictException(LocalizedStrings.TXState_CONFLICT_DETECTED_IN_GEMFIRE_TRANSACTION_0.toLocalizedString(getTransactionId()), commitConflict);
+      throw new SynchronizationCommitConflictException(
+          LocalizedStrings.TXState_CONFLICT_DETECTED_IN_GEMFIRE_TRANSACTION_0
+              .toLocalizedString(getTransactionId()),
+          commitConflict);
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-    case Status.STATUS_COMMITTED:
-      // System.err.println("begin commit in afterCompletion");
-      Assert.assertTrue(this.locks!=null, 
-                        "Gemfire Transaction afterCompletion called with illegal state.");
-      try {
+      case Status.STATUS_COMMITTED:
+        // System.err.println("begin commit in afterCompletion");
+        Assert.assertTrue(this.locks != null,
+            "Gemfire Transaction afterCompletion called with illegal state.");
+        try {
+          this.proxy.getTxMgr().setTXState(null);
+          commit();
+        } catch (CommitConflictException error) {
+          Assert.assertTrue(false, "Gemfire Transaction " + getTransactionId()
+              + " afterCompletion failed.due to CommitConflictException: " + error);
+        }
+
+        this.proxy.getTxMgr().noteCommitSuccess(opStart, this.jtaLifeTime, this);
+        this.locks = null;
+        // System.err.println("end commit in afterCompletion");
+        break;
+      case Status.STATUS_ROLLEDBACK:
+        this.jtaLifeTime = opStart - getBeginTime();
-        commit();
-      } catch (CommitConflictException error) {
-        Assert.assertTrue(false, "Gemfire Transaction " + getTransactionId() + 
-                          " afterCompletion failed.due to CommitConflictException: " + error);
-      } 
-      
-      this.proxy.getTxMgr().noteCommitSuccess(opStart, this.jtaLifeTime, this);
-      this.locks = null;
-      // System.err.println("end commit in afterCompletion");
-      break;
-    case Status.STATUS_ROLLEDBACK:
-      this.jtaLifeTime = opStart - getBeginTime();
-      this.proxy.getTxMgr().setTXState(null);
-      rollback();
-      this.proxy.getTxMgr().noteRollbackSuccess(opStart, this.jtaLifeTime, this);
-      break;
-    default:
-      Assert.assertTrue(false, "Unknown JTA Synchronization status " + status);
+        rollback();
+        this.proxy.getTxMgr().noteRollbackSuccess(opStart, this.jtaLifeTime, this);
+        break;
+      default:
+        Assert.assertTrue(false, "Unknown JTA Synchronization status " + status);
-  /** Add an internal callback which is run after the reservation/lock
-   * is returned from the Grantor but before the local identity/conflict check.
-   * This is the first callback to be called during the commit.
+  /**
+   * Add an internal callback which is run after the reservation/lock is returned from the Grantor
+   * but before the local identity/conflict check. This is the first callback to be called during
+   * the commit.
-  
-  /** Add an internal callback which is run after the local identity/conflict check
-   * has completed but before the changes have been applied to committed state.
+
+  /**
+   * Add an internal callback which is run after the local identity/conflict check has completed but
+   * before the changes have been applied to committed state.
-  
-  /** Add an internal callback which is run after the transaction
-   * changes have been applied to committed state (locally) but before
-   * local locks are released (occurs for regions of Local and
+
+  /**
+   * Add an internal callback which is run after the transaction changes have been applied to
+   * committed state (locally) but before local locks are released (occurs for regions of Local and
-  
-  /** Add an internal callback which is run after the the local locks
-   * are released (which occurs for regions of Local and Distributed
-   * No Ack scope) but before commit data is sent to recipients aka
+
+  /**
+   * Add an internal callback which is run after the the local locks are released (which occurs for
+   * regions of Local and Distributed No Ack scope) but before commit data is sent to recipients aka
-  
-  /** Add an internal callback which is run once for each recipient
-   * (aka Far Sider) of commit data, prior to actually sending the
-   * data.  This is called prior to calling <code>setAfterIndividualSend</code>.
+
+  /**
+   * Add an internal callback which is run once for each recipient (aka Far Sider) of commit data,
+   * prior to actually sending the data. This is called prior to calling
+   * <code>setAfterIndividualSend</code>.
-  
-  /** Add an internal callback which is run once after all the commit
-   * data has been sent to each recipient but before the "commit
-   * process" message is sent (only sent in the case there regions
+
+  /**
+   * Add an internal callback which is run once after all the commit data has been sent to each
+   * recipient but before the "commit process" message is sent (only sent in the case there regions
-  
-  /** Add an internal callback which is run once for each recipient
-   * (aka Far Sider) of the "commit process" message (only for
-   * recipients with Distributed Ack regions), prior to actually
-   * sending the message.
+
+  /**
+   * Add an internal callback which is run once for each recipient (aka Far Sider) of the "commit
+   * process" message (only for recipients with Distributed Ack regions), prior to actually sending
+   * the message.
-  /** Add an internal callback which is run once after all the "commit
-   * process" messages (only for recipients with Distributed Ack
-   * regions) have been sent but before <code>setAfterSend</code>
+  /**
+   * Add an internal callback which is run once after all the "commit process" messages (only for
+   * recipients with Distributed Ack regions) have been sent but before <code>setAfterSend</code>
-  
-  
-  /** Add an internal callback which is run after all data has been
-   * sent (for Distributed scope regions) and any acknowledgements
-   * have been received (for Distributed Ack scope regions) a but
+
+
+  /**
+   * Add an internal callback which is run after all data has been sent (for Distributed scope
+   * regions) and any acknowledgements have been received (for Distributed Ack scope regions) a but
-  
+
-   * Add an internal callback which is run after the commit message is
-   * formed but before it is sent.
+   * Add an internal callback which is run after the commit message is formed but before it is sent.
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  
-  public TXRegionState txWriteRegion(final LocalRegion localRegion, final KeyInfo entryKey)
-  {
+
+  public TXRegionState txWriteRegion(final LocalRegion localRegion, final KeyInfo entryKey) {
-  
-  public TXRegionState txReadRegion(LocalRegion localRegion)
-  {
+
+  public TXRegionState txReadRegion(LocalRegion localRegion) {
-  
-  final TXEntryState txWriteEntry(LocalRegion region, EntryEventImpl event,
-      boolean ifNew, boolean requireOldValue) {
+
+  final TXEntryState txWriteEntry(LocalRegion region, EntryEventImpl event, boolean ifNew,
+      boolean requireOldValue) {
+
-   * @param requireOldValue if true set the old value in the event,
-   *        even if ifNew and entry doesn't
-   * currently exist (this is needed for putIfAbsent).
-   * @param ifNew
-   *          only write the entry if it currently does not exist
+   * @param requireOldValue if true set the old value in the event, even if ifNew and entry doesn't
+   *        currently exist (this is needed for putIfAbsent).
+   * @param ifNew only write the entry if it currently does not exist
-  final TXEntryState txWriteEntry(LocalRegion region,
-                                          EntryEventImpl event,
-                                          boolean ifNew,
-                                          boolean requireOldValue,
-                                          Object expectedOldValue)
-  throws EntryNotFoundException {
+  final TXEntryState txWriteEntry(LocalRegion region, EntryEventImpl event, boolean ifNew,
+      boolean requireOldValue, Object expectedOldValue) throws EntryNotFoundException {
-    TXEntryState tx = txReadEntry(event.getKeyInfo(), region, true,
-        expectedOldValue, createIfAbsent);
-      if (tx != null) {
-        if (requireOldValue && tx.existsLocally()) {
-          event.setOldValue(tx.getNearSidePendingValue(), true); 
-        }
-        boolean existsLocally = tx.existsLocally();
-        if (!existsLocally && event.getOperation() == Operation.REPLACE) {
-          throw new EntryNotFoundException("No previously created Entry to be updated");
-        }
-        if (existsLocally && ifNew) {
-          // Since "ifNew" is true then let caller know entry exists
-          // in tx state or cmt state
-          return ENTRY_EXISTS;
-        }
-        else {
-          tx.updateForWrite(nextModSerialNum());
-        }
-      } else {
-        if (!createIfAbsent) {
-          throw new EntryNotFoundException("No previously created Entry to be updated");
-        }
+    TXEntryState tx =
+        txReadEntry(event.getKeyInfo(), region, true, expectedOldValue, createIfAbsent);
+    if (tx != null) {
+      if (requireOldValue && tx.existsLocally()) {
+        event.setOldValue(tx.getNearSidePendingValue(), true);
-      return tx;
+      boolean existsLocally = tx.existsLocally();
+      if (!existsLocally && event.getOperation() == Operation.REPLACE) {
+        throw new EntryNotFoundException("No previously created Entry to be updated");
+      }
+      if (existsLocally && ifNew) {
+        // Since "ifNew" is true then let caller know entry exists
+        // in tx state or cmt state
+        return ENTRY_EXISTS;
+      } else {
+        tx.updateForWrite(nextModSerialNum());
+      }
+    } else {
+      if (!createIfAbsent) {
+        throw new EntryNotFoundException("No previously created Entry to be updated");
+      }
+    }
+    return tx;
-  
+
-   * this version of txPutEntry takes a ConcurrentMap expectedOldValue parameter.
-   * If not null, this value must match the current value of the entry or false
-   * is returned
+   * this version of txPutEntry takes a ConcurrentMap expectedOldValue parameter. If not null, this
+   * value must match the current value of the entry or false is returned
-  public boolean txPutEntry(final EntryEventImpl event,
-      boolean ifNew, boolean requireOldValue,
+  public boolean txPutEntry(final EntryEventImpl event, boolean ifNew, boolean requireOldValue,
-    
-    if(bridgeContext==null) {
+
+    if (bridgeContext == null) {
-    
+
-    
+
-      }
-      else {
+      } else {
-    }
-    catch (EntryNotFoundException e) {
+    } catch (EntryNotFoundException e) {
-  
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#containsValueForKey(java.lang.Object, org.apache.geode.internal.cache.LocalRegion)
+
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateInterface#containsValueForKey(java.lang.Object,
+   * org.apache.geode.internal.cache.LocalRegion)
-    TXEntryState tx = txReadEntry(keyInfo, region, true, true/*create txEntry is absent*/);
+    TXEntryState tx = txReadEntry(keyInfo, region, true, true/* create txEntry is absent */);
-       * Note that we don't consult this.getDataPolicy().isProxy() when
-       * setting this because in this context we don't want proxies to pretend
-       * they have a value.
+       * Note that we don't consult this.getDataPolicy().isProxy() when setting this because in this
+       * context we don't want proxies to pretend they have a value.
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#destroyExistingEntry(org.apache.geode.internal.cache.EntryEventImpl, boolean, java.lang.Object)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.TXStateInterface#destroyExistingEntry(org.apache.geode.internal
+   * .cache.EntryEventImpl, boolean, java.lang.Object)
-  public void destroyExistingEntry(final EntryEventImpl event, final boolean cacheWrite, Object expectedOldValue) {
-    if(bridgeContext==null) {
+  public void destroyExistingEntry(final EntryEventImpl event, final boolean cacheWrite,
+      Object expectedOldValue) {
+    if (bridgeContext == null) {
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#invalidateExistingEntry(org.apache.geode.internal.cache.EntryEventImpl, boolean, boolean)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateInterface#invalidateExistingEntry(org.apache.geode.
+   * internal.cache.EntryEventImpl, boolean, boolean)
-  public void invalidateExistingEntry(final EntryEventImpl event, boolean invokeCallbacks, boolean forceNewEntry) {
-    if(bridgeContext==null) {
+  public void invalidateExistingEntry(final EntryEventImpl event, boolean invokeCallbacks,
+      boolean forceNewEntry) {
+    if (bridgeContext == null) {
-  
+
-   * Write an existing entry.  This form takes an expectedOldValue which, if not
-   * null, must be equal to the current value of the entry.  If it is not,
-   * an EntryNotFoundException is thrown.
+   * Write an existing entry. This form takes an expectedOldValue which, if not null, must be equal
+   * to the current value of the entry. If it is not, an EntryNotFoundException is thrown.
-      throws EntryNotFoundException
-  {
+      throws EntryNotFoundException {
-    TXEntryState tx = txReadEntry(event.getKeyInfo(), region, true,
-        expectedOldValue, true/*create txEntry is absent*/);
+    TXEntryState tx = txReadEntry(event.getKeyInfo(), region, true, expectedOldValue,
+        true/* create txEntry is absent */);
-      final boolean invalidatingInvalidEntry = op.isInvalidate() 
-        && Token.isInvalid(tx.getValueInVM(entryKey));
+      final boolean invalidatingInvalidEntry =
+          op.isInvalidate() && Token.isInvalid(tx.getValueInVM(entryKey));
-    }
-    else {
+    } else {
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#getEntry(java.lang.Object, org.apache.geode.internal.cache.LocalRegion)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateInterface#getEntry(java.lang.Object,
+   * org.apache.geode.internal.cache.LocalRegion)
-    TXEntryState tx = txReadEntry(keyInfo, region, true, true/*create txEntry is absent*/);
+    TXEntryState tx = txReadEntry(keyInfo, region, true, true/* create txEntry is absent */);
-   * @param rememberRead true if the value read from committed state
-   *   needs to be remembered in tx state for repeatable read.
-   * @param createIfAbsent should a transactional entry be created if not present. 
-   * @return a txEntryState or null if the entry doesn't exist in the transaction and/or committed state. 
+   * @param rememberRead true if the value read from committed state needs to be remembered in tx
+   *        state for repeatable read.
+   * @param createIfAbsent should a transactional entry be created if not present.
+   * @return a txEntryState or null if the entry doesn't exist in the transaction and/or committed
+   *         state.
-  public TXEntryState txReadEntry(KeyInfo keyInfo, LocalRegion localRegion,
-      boolean rememberRead, boolean createIfAbsent) {
+  public TXEntryState txReadEntry(KeyInfo keyInfo, LocalRegion localRegion, boolean rememberRead,
+      boolean createIfAbsent) {
-   * This form of txReadEntry takes a concurrent-map argument, expectedOldValue.
-   * If this parameter is not null it must match the current value of the entry
-   * or an EntryNotFoundException is thrown.
+   * This form of txReadEntry takes a concurrent-map argument, expectedOldValue. If this parameter
+   * is not null it must match the current value of the entry or an EntryNotFoundException is
+   * thrown.
-  protected TXEntryState txReadEntry(KeyInfo keyInfo, LocalRegion localRegion,
-      boolean rememberRead, Object expectedOldValue, boolean createIfAbsent)
-  throws EntryNotFoundException
-  {
+  protected TXEntryState txReadEntry(KeyInfo keyInfo, LocalRegion localRegion, boolean rememberRead,
+      Object expectedOldValue, boolean createIfAbsent) throws EntryNotFoundException {
-    
+
-      if (expectedOldValue != null) { 
+      if (expectedOldValue != null) {
-          throw new EntryNotFoundException(LocalizedStrings.AbstractRegionMap_THE_CURRENT_VALUE_WAS_NOT_EQUAL_TO_EXPECTED_VALUE.toLocalizedString());
+          throw new EntryNotFoundException(
+              LocalizedStrings.AbstractRegionMap_THE_CURRENT_VALUE_WAS_NOT_EQUAL_TO_EXPECTED_VALUE
+                  .toLocalizedString());
-       * This means it isn't in the cache and rememberReads = false. This should only happen from test hooks at this point.
+       * This means it isn't in the cache and rememberReads = false. This should only happen from
+       * test hooks at this point.
-      if (txr!=null) {
+      if (txr != null) {
-      if (expectedOldValue==null) {
+      if (expectedOldValue == null) {
-         * They were expecting non-existence. 
+         * They were expecting non-existence.
-        if(!Token.isInvalid(expectedOldValue)) {
-          throw new EntryNotFoundException(LocalizedStrings.AbstractRegionMap_THE_CURRENT_VALUE_WAS_NOT_EQUAL_TO_EXPECTED_VALUE.toLocalizedString());
+        if (!Token.isInvalid(expectedOldValue)) {
+          throw new EntryNotFoundException(
+              LocalizedStrings.AbstractRegionMap_THE_CURRENT_VALUE_WAS_NOT_EQUAL_TO_EXPECTED_VALUE
+                  .toLocalizedString());
-    } 
+    }
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#getDeserializedValue(java.lang.Object, org.apache.geode.internal.cache.LocalRegion, boolean)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateInterface#getDeserializedValue(java.lang.Object,
+   * org.apache.geode.internal.cache.LocalRegion, boolean)
-  public Object getDeserializedValue(KeyInfo keyInfo,
-                                     LocalRegion localRegion,
-                                     boolean updateStats,
-                                     boolean disableCopyOnRead,
-                                     boolean preferCD,
-                                     EntryEventImpl clientEvent,
-                                     boolean returnTombstones,
-                                     boolean retainResult) {
-    TXEntryState tx = txReadEntry(keyInfo, localRegion, true, true/*create txEntry is absent*/);
+  public Object getDeserializedValue(KeyInfo keyInfo, LocalRegion localRegion, boolean updateStats,
+      boolean disableCopyOnRead, boolean preferCD, EntryEventImpl clientEvent,
+      boolean returnTombstones, boolean retainResult) {
+    TXEntryState tx = txReadEntry(keyInfo, localRegion, true, true/* create txEntry is absent */);
-      if(!disableCopyOnRead) {
+      if (!disableCopyOnRead) {
-      return localRegion.getDeserializedValue(null, keyInfo, updateStats, disableCopyOnRead, preferCD, clientEvent, returnTombstones,
-        retainResult);
+      return localRegion.getDeserializedValue(null, keyInfo, updateStats, disableCopyOnRead,
+          preferCD, clientEvent, returnTombstones, retainResult);
-   * @see org.apache.geode.internal.cache.InternalDataView#getSerializedValue(org.apache.geode.internal.cache.LocalRegion, java.lang.Object, java.lang.Object)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#getSerializedValue(org.apache.geode.internal.
+   * cache.LocalRegion, java.lang.Object, java.lang.Object)
-  public Object getSerializedValue(LocalRegion localRegion,
-                                   KeyInfo keyInfo,
-                                   boolean doNotLockEntry,
-                                   ClientProxyMembershipID requestingClient,
-                                   EntryEventImpl clientEvent,
-                                   boolean returnTombstones) throws DataLocationException {
+  public Object getSerializedValue(LocalRegion localRegion, KeyInfo keyInfo, boolean doNotLockEntry,
+      ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent,
+      boolean returnTombstones) throws DataLocationException {
-    TXEntryState tx = txReadEntry(keyInfo, localRegion, true,true/*create txEntry is absent*/);
+    TXEntryState tx = txReadEntry(keyInfo, localRegion, true, true/* create txEntry is absent */);
-      if(val==null || Token.isInvalidOrRemoved(val)) {
-        val = findObject(keyInfo,localRegion, val!=Token.INVALID,
-            true, val, false, false, requestingClient, clientEvent, false);
+      if (val == null || Token.isInvalidOrRemoved(val)) {
+        val = findObject(keyInfo, localRegion, val != Token.INVALID, true, val, false, false,
+            requestingClient, clientEvent, false);
-      PartitionedRegion pr = (PartitionedRegion)localRegion;
-      return pr.getDataStore().getSerializedLocally(keyInfo, doNotLockEntry, null, null, returnTombstones);
+      PartitionedRegion pr = (PartitionedRegion) localRegion;
+      return pr.getDataStore().getSerializedLocally(keyInfo, doNotLockEntry, null, null,
+          returnTombstones);
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#entryCount(org.apache.geode.internal.cache.LocalRegion)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#entryCount(org.apache.geode.internal.cache.
+   * LocalRegion)
-    if(result>0) {
+    if (result > 0) {
-      // This is to work around bug #40946. 
-      // Other threads can destroy all the keys, and so our entryModCount 
+      // This is to work around bug #40946.
+      // Other threads can destroy all the keys, and so our entryModCount
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#containsKey(java.lang.Object, org.apache.geode.internal.cache.LocalRegion)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateInterface#containsKey(java.lang.Object,
+   * org.apache.geode.internal.cache.LocalRegion)
-    TXEntryState tx = txReadEntry(keyInfo, localRegion, true,true/*create txEntry is absent*/);
+    TXEntryState tx = txReadEntry(keyInfo, localRegion, true, true/* create txEntry is absent */);
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#getValueInVM(java.lang.Object, org.apache.geode.internal.cache.LocalRegion, boolean)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateInterface#getValueInVM(java.lang.Object,
+   * org.apache.geode.internal.cache.LocalRegion, boolean)
-  public Object getValueInVM(KeyInfo keyInfo, LocalRegion localRegion,
-      boolean rememberRead) {
-    TXEntryState tx = txReadEntry(keyInfo, localRegion, rememberRead,true/*create txEntry is absent*/);
+  public Object getValueInVM(KeyInfo keyInfo, LocalRegion localRegion, boolean rememberRead) {
+    TXEntryState tx =
+        txReadEntry(keyInfo, localRegion, rememberRead, true/* create txEntry is absent */);
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#putEntry(org.apache.geode.internal.cache.EntryEventImpl, boolean, boolean, java.lang.Object, boolean, long, boolean)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateInterface#putEntry(org.apache.geode.internal.cache.
+   * EntryEventImpl, boolean, boolean, java.lang.Object, boolean, long, boolean)
+   * 
-    if (event.getDeltaBytes() != null
-        && !event.getRegion().getAttributes().getCloningEnabled()) {
+    if (event.getDeltaBytes() != null && !event.getRegion().getAttributes().getCloningEnabled()) {
-          LocalizedStrings.TXState_DELTA_WITHOUT_CLONING_CANNOT_BE_USED_IN_TX
-              .toLocalizedString());
+          LocalizedStrings.TXState_DELTA_WITHOUT_CLONING_CANNOT_BE_USED_IN_TX.toLocalizedString());
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#findObject(org.apache.geode.internal.cache.LocalRegion, java.lang.Object, java.lang.Object, boolean, boolean, java.lang.Object)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.TXStateInterface#findObject(org.apache.geode.internal.cache.
+   * LocalRegion, java.lang.Object, java.lang.Object, boolean, boolean, java.lang.Object)
-  public Object findObject(KeyInfo key,
-                           LocalRegion r,
-                           boolean isCreate,
-                           boolean generateCallbacks,
-                           Object value,
-                           boolean disableCopyOnRead,
-                           boolean preferCD,
-                           ClientProxyMembershipID requestingClient,
-                           EntryEventImpl clientEvent,
-                           boolean returnTombstones) {
-    return r.findObjectInSystem(key, isCreate, this, generateCallbacks, value, disableCopyOnRead, preferCD, requestingClient, clientEvent, returnTombstones);
+  public Object findObject(KeyInfo key, LocalRegion r, boolean isCreate, boolean generateCallbacks,
+      Object value, boolean disableCopyOnRead, boolean preferCD,
+      ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent,
+      boolean returnTombstones) {
+    return r.findObjectInSystem(key, isCreate, this, generateCallbacks, value, disableCopyOnRead,
+        preferCD, requestingClient, clientEvent, returnTombstones);
-    TXEntryState tx = txReadEntry(keyInfo, localRegion, rememberReads, true/*create txEntry is absent*/); 
+    TXEntryState tx =
+        txReadEntry(keyInfo, localRegion, rememberReads, true/* create txEntry is absent */);
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#getEntryForIterator(org.apache.geode.internal.cache.LocalRegion, java.lang.Object, boolean)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.TXStateInterface#getEntryForIterator(org.apache.geode.internal.
+   * cache.LocalRegion, java.lang.Object, boolean)
-  public Object getEntryForIterator(KeyInfo curr, LocalRegion currRgn,
-      boolean rememberReads, boolean allowTombstones) {
+  public Object getEntryForIterator(KeyInfo curr, LocalRegion currRgn, boolean rememberReads,
+      boolean allowTombstones) {
-      PartitionedRegion pr = (PartitionedRegion)currRgn;
+      PartitionedRegion pr = (PartitionedRegion) currRgn;
-    if (! readEntryAndCheckIfDestroyed(curr, currRgn, rememberReads)) {
+    if (!readEntryAndCheckIfDestroyed(curr, currRgn, rememberReads)) {
-      return new TXEntry(currRgn, new KeyInfo(curr.getKey(),
-          curr.getCallbackArg(), curr.getBucketId()), proxy, rememberReads);
-    } else { 
+      return new TXEntry(currRgn,
+          new KeyInfo(curr.getKey(), curr.getCallbackArg(), curr.getBucketId()), proxy,
+          rememberReads);
+    } else {
-   * @see org.apache.geode.internal.cache.InternalDataView#getKeyForIterator(java.lang.Object, org.apache.geode.internal.cache.LocalRegion, boolean)
+   * 
+   * @see org.apache.geode.internal.cache.InternalDataView#getKeyForIterator(java.lang.Object,
+   * org.apache.geode.internal.cache.LocalRegion, boolean)
-  public Object getKeyForIterator(KeyInfo curr, LocalRegion currRgn,
-      boolean rememberReads, boolean allowTombstones) {
+  public Object getKeyForIterator(KeyInfo curr, LocalRegion currRgn, boolean rememberReads,
+      boolean allowTombstones) {
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#getAdditionalKeysForIterator(org.apache.geode.internal.cache.LocalRegion)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#getAdditionalKeysForIterator(org.apache.geode.
+   * internal.cache.LocalRegion)
-      for (TXRegionState rs: this.regions.values()) {
+      for (TXRegionState rs : this.regions.values()) {
-          TXBucketRegionState brs = (TXBucketRegionState)rs;
+          TXBucketRegionState brs = (TXBucketRegionState) rs;
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.TXStateInterface#isInProgressAndSameAs(org.apache.geode.internal.cache.TXStateInterface)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.TXStateInterface#isInProgressAndSameAs(org.apache.geode.
+   * internal.cache.TXStateInterface)
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#putEntryOnRemote(org.apache.geode.internal.cache.EntryEventImpl, boolean, boolean, java.lang.Object, boolean, long, boolean)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#putEntryOnRemote(org.apache.geode.internal.
+   * cache.EntryEventImpl, boolean, boolean, java.lang.Object, boolean, long, boolean)
-  public boolean putEntryOnRemote(EntryEventImpl event, boolean ifNew,
-      boolean ifOld, Object expectedOldValue, boolean requireOldValue,
-      long lastModified, boolean overwriteDestroyed)
-      throws DataLocationException {
+  public boolean putEntryOnRemote(EntryEventImpl event, boolean ifNew, boolean ifOld,
+      Object expectedOldValue, boolean requireOldValue, long lastModified,
+      boolean overwriteDestroyed) throws DataLocationException {
-    
+
-  public void destroyOnRemote(EntryEventImpl event, boolean cacheWrite,
-      Object expectedOldValue) throws DataLocationException {
+  public void destroyOnRemote(EntryEventImpl event, boolean cacheWrite, Object expectedOldValue)
+      throws DataLocationException {
-  
-  public void checkSupportsRegionDestroy()
-    throws UnsupportedOperationInTransactionException {
-    throw new UnsupportedOperationInTransactionException(LocalizedStrings.TXState_REGION_DESTROY_NOT_SUPPORTED_IN_A_TRANSACTION.toLocalizedString());
+
+  public void checkSupportsRegionDestroy() throws UnsupportedOperationInTransactionException {
+    throw new UnsupportedOperationInTransactionException(
+        LocalizedStrings.TXState_REGION_DESTROY_NOT_SUPPORTED_IN_A_TRANSACTION.toLocalizedString());
-  
-  public void checkSupportsRegionInvalidate()
-    throws UnsupportedOperationInTransactionException {
-    throw new UnsupportedOperationInTransactionException(LocalizedStrings.TXState_REGION_INVALIDATE_NOT_SUPPORTED_IN_A_TRANSACTION.toLocalizedString());
+
+  public void checkSupportsRegionInvalidate() throws UnsupportedOperationInTransactionException {
+    throw new UnsupportedOperationInTransactionException(
+        LocalizedStrings.TXState_REGION_INVALIDATE_NOT_SUPPORTED_IN_A_TRANSACTION
+            .toLocalizedString());
-  public void checkSupportsRegionClear()
-      throws UnsupportedOperationInTransactionException {
-    throw new UnsupportedOperationInTransactionException(LocalizedStrings.TXState_REGION_CLEAR_NOT_SUPPORTED_IN_A_TRANSACTION.toLocalizedString());
+  public void checkSupportsRegionClear() throws UnsupportedOperationInTransactionException {
+    throw new UnsupportedOperationInTransactionException(
+        LocalizedStrings.TXState_REGION_CLEAR_NOT_SUPPORTED_IN_A_TRANSACTION.toLocalizedString());
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#getBucketKeys(org.apache.geode.internal.cache.LocalRegion, int)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#getBucketKeys(org.apache.geode.internal.cache.
+   * LocalRegion, int)
-    PartitionedRegion pr = (PartitionedRegion)localRegion;
+    PartitionedRegion pr = (PartitionedRegion) localRegion;
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#getEntryOnRemote(java.lang.Object, org.apache.geode.internal.cache.LocalRegion)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.InternalDataView#getEntryOnRemote(java.lang.Object,
+   * org.apache.geode.internal.cache.LocalRegion)
-    PartitionedRegion pr = (PartitionedRegion)localRegion;
+    PartitionedRegion pr = (PartitionedRegion) localRegion;
-    if(txval==null) {
-      throw new EntryNotFoundException(LocalizedStrings.PartitionedRegionDataStore_ENTRY_NOT_FOUND.toLocalizedString());
+    if (txval == null) {
+      throw new EntryNotFoundException(
+          LocalizedStrings.PartitionedRegionDataStore_ENTRY_NOT_FOUND.toLocalizedString());
-      return new EntrySnapshot(nlre,dataReg,(LocalRegion)txval.getRegion(), allowTombstones);
+      return new EntrySnapshot(nlre, dataReg, (LocalRegion) txval.getRegion(), allowTombstones);
+   * 
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.InternalDataView#getRegionKeysForIteration(org.apache.geode.internal.cache.LocalRegion)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#getRegionKeysForIteration(org.apache.geode.
+   * internal.cache.LocalRegion)
-  
-  public boolean isRealDealLocal()
-  {    
+
+  public boolean isRealDealLocal() {
-     return false;
+    return false;
-  
-  
+
+
-   * @see org.apache.geode.internal.cache.InternalDataView#postPutAll(org.apache.geode.internal.cache.DistributedPutAllOperation, java.util.Map, org.apache.geode.internal.cache.LocalRegion)
+   * @see
+   * org.apache.geode.internal.cache.InternalDataView#postPutAll(org.apache.geode.internal.cache.
+   * DistributedPutAllOperation, java.util.Map, org.apache.geode.internal.cache.LocalRegion)
-  public void postPutAll(final DistributedPutAllOperation putallOp, final VersionedObjectList successfulPuts,LocalRegion reg) {
-	  
-	  final LocalRegion theRegion;
-	  if(reg instanceof BucketRegion) {
-		  theRegion = ((BucketRegion)reg).getPartitionedRegion();
-	  } else {
-		  theRegion = reg;
-	  }
-	  /*
-	   * Don't fire events here.
-	   */
-	  /*
-	   * We are on the data store, we don't need to do anything here. Commit will push them out.
-	   */
-	  /*
-	   * We need to put this into the tx state.
-	   */
-	  theRegion.syncBulkOp(new Runnable() {
-	      public void run() {
-//	        final boolean requiresRegionContext = theRegion.keyRequiresRegionContext();
-	        InternalDistributedMember myId = theRegion.getDistributionManager().getDistributionManagerId();
-	        for (int i = 0; i < putallOp.putAllDataSize; ++i) {
-	          @Released EntryEventImpl ev = PutAllPRMessage.getEventFromEntry(theRegion, myId,myId, i, putallOp.putAllData, false, putallOp.getBaseEvent().getContext(), false, !putallOp.getBaseEvent().isGenerateCallbacks());
-	          try {
-	          ev.setPutAllOperation(putallOp);
-	          if (theRegion.basicPut(ev, false, false, null, false)) {
-	            successfulPuts.addKeyAndVersion(putallOp.putAllData[i].key, null);
-	          }
-	          } finally {
-	            ev.release();
-	          }
-	        }
-	      }
-	    }, putallOp.getBaseEvent().getEventId());
+  public void postPutAll(final DistributedPutAllOperation putallOp,
+      final VersionedObjectList successfulPuts, LocalRegion reg) {
-  }
-  @Override
-  public void postRemoveAll(final DistributedRemoveAllOperation op, final VersionedObjectList successfulOps, LocalRegion reg) {
-    if(reg instanceof BucketRegion) {
-      theRegion = ((BucketRegion)reg).getPartitionedRegion();
+    if (reg instanceof BucketRegion) {
+      theRegion = ((BucketRegion) reg).getPartitionedRegion();
+     */
+    /*
+     */
+    /*
-        public void run() {
-          InternalDistributedMember myId = theRegion.getDistributionManager().getDistributionManagerId();
-          for (int i = 0; i < op.removeAllDataSize; ++i) {
-            @Released EntryEventImpl ev = RemoveAllPRMessage.getEventFromEntry(theRegion, myId, myId, i, op.removeAllData, false, op.getBaseEvent().getContext(), false, !op.getBaseEvent().isGenerateCallbacks());
-            ev.setRemoveAllOperation(op);
-            try {
-              theRegion.basicDestroy(ev, true/* should we invoke cacheWriter? */, null);
-            } catch (EntryNotFoundException ignore) {
-            } finally {
-              ev.release();
+      public void run() {
+        // final boolean requiresRegionContext = theRegion.keyRequiresRegionContext();
+        InternalDistributedMember myId =
+            theRegion.getDistributionManager().getDistributionManagerId();
+        for (int i = 0; i < putallOp.putAllDataSize; ++i) {
+          @Released
+          EntryEventImpl ev = PutAllPRMessage.getEventFromEntry(theRegion, myId, myId, i,
+              putallOp.putAllData, false, putallOp.getBaseEvent().getContext(), false,
+              !putallOp.getBaseEvent().isGenerateCallbacks());
+          try {
+            ev.setPutAllOperation(putallOp);
+            if (theRegion.basicPut(ev, false, false, null, false)) {
+              successfulPuts.addKeyAndVersion(putallOp.putAllData[i].key, null);
-            successfulOps.addKeyAndVersion(op.removeAllData[i].key, null);
+          } finally {
+            ev.release();
-      }, op.getBaseEvent().getEventId());
-    
+      }
+    }, putallOp.getBaseEvent().getEventId());
+
+  }
+
+  @Override
+  public void postRemoveAll(final DistributedRemoveAllOperation op,
+      final VersionedObjectList successfulOps, LocalRegion reg) {
+    final LocalRegion theRegion;
+    if (reg instanceof BucketRegion) {
+      theRegion = ((BucketRegion) reg).getPartitionedRegion();
+    } else {
+      theRegion = reg;
+    }
+    /*
+     * Don't fire events here. We are on the data store, we don't need to do anything here. Commit
+     * will push them out. We need to put this into the tx state.
+     */
+    theRegion.syncBulkOp(new Runnable() {
+      public void run() {
+        InternalDistributedMember myId =
+            theRegion.getDistributionManager().getDistributionManagerId();
+        for (int i = 0; i < op.removeAllDataSize; ++i) {
+          @Released
+          EntryEventImpl ev = RemoveAllPRMessage.getEventFromEntry(theRegion, myId, myId, i,
+              op.removeAllData, false, op.getBaseEvent().getContext(), false,
+              !op.getBaseEvent().isGenerateCallbacks());
+          ev.setRemoveAllOperation(op);
+          try {
+            theRegion.basicDestroy(ev, true/* should we invoke cacheWriter? */, null);
+          } catch (EntryNotFoundException ignore) {
+          } finally {
+            ev.release();
+          }
+          successfulOps.addKeyAndVersion(op.removeAllData[i].key, null);
+        }
+      }
+    }, op.getBaseEvent().getEventId());
+
-  public void recordTXOperation(ServerRegionDataAccess region, ServerRegionOperation op, Object key, Object arguments[]) {
+  public void recordTXOperation(ServerRegionDataAccess region, ServerRegionOperation op, Object key,
+      Object arguments[]) {
-  public void updateEntryVersion(EntryEventImpl event)
-      throws EntryNotFoundException {
-    // Do nothing. Not applicable for transactions.    
+  public void updateEntryVersion(EntryEventImpl event) throws EntryNotFoundException {
+    // Do nothing. Not applicable for transactions.
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
Fixing problems with network partition detection

Recent changes in GMSJoinLeave and GMSHealthMonitor destabilized network
partition detection to the point that it was barely working.  This corrects
faults that were causing the failures - exponential barrages of suspect
processing and failure to detect loss of members during membership view
creation.

GMSJoinLeave's removeHealthyMembers and filterMembers methods had some problems
that resulted in unhealthy members not being detected.  GMSHealthMonitor
did not have barriers in place to prevent initiation of concurrent suspect
processing on the same member.  JGroupsMessenger was initiating final checks
on members if unable to send a message to them instead of merely raising
suspicion.

+  /** members who we have been declared dead in the current view */
+  
+  @Override
+  public boolean isMemberLeaving(DistributedMember mbr) {
+    if (getPendingRequestIDs(LEAVE_REQUEST_MESSAGE).contains(mbr)
+        || getPendingRequestIDs(REMOVE_MEMBER_REQUEST).contains(mbr)
+        || !currentView.contains(mbr)) {
+      return true;
+    }
+    synchronized(removedMembers) {
+      if (removedMembers.contains(mbr)) {
+        return true;
+      }
+    }
+    synchronized(leftMembers) {
+      if (leftMembers.contains(mbr)) {
+        return true;
+      }
+    }
+    return false;
+  }
-      logger.info("I am being told to leave the distributed system");
+      logger.info("I am being told to leave the distributed system by {}", incomingRequest.getSender());
+      return;
+    boolean fromMe = incomingRequest.getSender() == null ||
+        incomingRequest.getSender().equals(localAddress);
-    logger.info("Membership received a request to remove " + mbr
+    if (!fromMe) {
+      logger.info("Membership received a request to remove " + mbr
+    }
-      logger.debug("ignoring request as I already have a removal request for this member");
+      logger.debug("ignoring removal request as I already have a removal request for this member");
+        logger.fatal("This member is no longer in the membership view.  My ID is {} and the new view is {}", localAddress, view);
+        logger.debug("unresponsive members that could not be reached: {}", unresponsive);
+        
-     * @param mbrs
+     * @param suspects
-    private void removeHealthyMembers(final Collection<InternalDistributedMember> mbrs) throws InterruptedException {
-      List<Callable<InternalDistributedMember>> checkers = new ArrayList<Callable<InternalDistributedMember>>(mbrs.size());
+    private void removeHealthyMembers(final Set<InternalDistributedMember> suspects) throws InterruptedException {
+      List<Callable<InternalDistributedMember>> checkers = new ArrayList<Callable<InternalDistributedMember>>(suspects.size());
-      filterMembers(mbrs, newRemovals, REMOVE_MEMBER_REQUEST);
-      filterMembers(mbrs, newLeaves, LEAVE_REQUEST_MESSAGE);   
+      filterMembers(suspects, newRemovals, REMOVE_MEMBER_REQUEST);
+      filterMembers(suspects, newLeaves, LEAVE_REQUEST_MESSAGE);
+      newRemovals.removeAll(newLeaves);  // if we received a Leave req the member is "healthy" 
-      for (InternalDistributedMember mbr : mbrs) {
+      suspects.removeAll(newLeaves);
+      
+      for (InternalDistributedMember mbr : suspects) {
+        if (newRemovals.contains(mbr) || newLeaves.contains(mbr)) {
+          continue; // no need to check this member - it's already been checked or is leaving
+        }
-            // return the member id if it fails health checks
-                mbrs.remove(mbr);
+                suspects.remove(mbr);
+          @Override
+          public String toString() {
+            return mbr.toString();
+          }
-
-      mbrs.removeAll(newLeaves);
-
-      if (mbrs.isEmpty()) {
+      
+      if (checkers.isEmpty()) {
+        logger.debug("all unresponsive members are already scheduled to be removed");
-      
-      ExecutorService svc = Executors.newFixedThreadPool(mbrs.size(), new ThreadFactory() {
+
+      logger.debug("checking availability of these members: {}", checkers);
+      ExecutorService svc = Executors.newFixedThreadPool(suspects.size(), new ThreadFactory() {
-        List<Future<InternalDistributedMember>> futures;
-        futures = submitAll(svc, checkers);
+        // submit the tasks that will remove dead members from the suspects collection
+        submitAll(svc, checkers);
+        
+        // now wait for the tasks to do their work
-          while(waitTime>0 ) {
-            logger.debug("removeHealthyMembers: mbrs" + mbrs.size());
+          while ( waitTime > 0 ) {
+            logger.debug("removeHealthyMembers: mbrs" + suspects.size());
-            filterMembers(mbrs, newRemovals, REMOVE_MEMBER_REQUEST);
-            filterMembers(mbrs, newLeaves, LEAVE_REQUEST_MESSAGE);   
+            filterMembers(suspects, newRemovals, REMOVE_MEMBER_REQUEST);
+            filterMembers(suspects, newLeaves, LEAVE_REQUEST_MESSAGE);
+            newRemovals.removeAll(newLeaves);
-            if(mbrs.isEmpty()) {
+            suspects.removeAll(newLeaves);
+            
+            if(suspects.isEmpty() || newRemovals.containsAll(suspects)) {
-        
-        //we have waited for all members, now check if we considered any removeRequest;
-        //add them back to create new view
-        if(!newRemovals.isEmpty()) {
-          newRemovals.removeAll(newLeaves);
-          mbrs.addAll(newRemovals);
-        }
-        
-    protected void filterMembers(Collection<InternalDistributedMember> mbrs, Set<InternalDistributedMember> removalRequestForMembers, short requestType) {
-      Set<InternalDistributedMember> gotRemovalRequests = getPendingRequestIDs(requestType);
+    /**
+     * This gets pending requests and returns the IDs of any that are in the given collection
+     * @param mbrs collection of IDs to search for
+     * @param matchingMembers collection to store matching IDs in
+     * @param requestType leave/remove/join
+     */
+    protected void filterMembers(Collection<InternalDistributedMember> mbrs, Set<InternalDistributedMember> matchingMembers, short requestType) {
+      Set<InternalDistributedMember> requests = getPendingRequestIDs(requestType);
-      if(!gotRemovalRequests.isEmpty()) {
-        logger.debug("removeHealthyMembers: gotRemovalRequests " + gotRemovalRequests.size());
-        Iterator<InternalDistributedMember> itr = gotRemovalRequests.iterator();
+      if(!requests.isEmpty()) {
+        logger.debug("filterMembers: processing " + requests.size() + " requests for type " + requestType);
+        Iterator<InternalDistributedMember> itr = requests.iterator();
-          InternalDistributedMember removeMember = itr.next();
-          if(mbrs.contains(removeMember)) {
+          InternalDistributedMember memberID = itr.next();
+          if(mbrs.contains(memberID)) {
-            removalRequestForMembers.add(removeMember);
-            mbrs.remove(removeMember);
+            matchingMembers.add(memberID);

INS31 INS29 INS78 INS83 INS39 INS42 INS44 INS8 INS65 INS42 INS43 INS42 INS25 INS51 INS51 INS41 INS60 INS25 MOV70 INS29 INS66 INS42 INS27 INS8 INS42 INS8 INS42 INS8 INS9 INS39 INS59 INS38 INS8 UPD74 UPD42 INS21 INS21 INS65 INS65 INS65 INS65 UPD42 INS32 INS32 INS38 INS41 INS25 INS25 INS41 INS42 INS27 INS42 MOV21 UPD42 UPD43 INS32 UPD42 INS32 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS9 INS32 INS8 INS32 INS8 INS27 INS32 INS21 UPD42 UPD42 UPD42 INS42 INS42 INS42 UPD42 INS25 UPD42 INS21 INS42 INS42 INS45 INS42 INS51 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS41 INS42 INS42 INS42 INS41 UPD45 INS32 INS32 INS33 INS32 INS42 INS42 UPD45 INS21 INS32 INS27 INS8 INS32 MOV32 MOV42 INS8 UPD42 INS9 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS45 INS42 UPD42 INS32 INS32 INS18 INS42 INS42 INS45 UPD42 INS61 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV27 INS8 UPD45 INS45 INS42 UPD42 INS31 MOV21 MOV21 MOV21 MOV21 INS21 MOV25 MOV21 MOV21 UPD42 UPD42 UPD42 INS78 INS83 INS43 INS42 INS8 INS32 INS27 MOV8 INS42 INS42 INS41 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS32 UPD42 UPD42 INS32 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL59 DEL60 DEL42 DEL7 DEL32 DEL38 DEL32 DEL21 DEL8 DEL32 DEL25 DEL8 DEL61 DEL8 DEL51 DEL42 DEL42 DEL42 DEL32 DEL21
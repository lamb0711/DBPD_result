GEODE-1994: Overhaul of internal.lang.StringUtils to extend and heavily use commons.lang.StringUtils

*   geode.internal.lang.StringUtils has been deprecated.  In the interim, it has been heavily refactored and extends commons.lang.StringUtils.
*
*   Renamed:
*   --  EMPTY_STRING -> EMPTY (inherited)
*   --  toUpperCase  -> upperCase (inherited)
*   --  toLowerCase  -> lowerCase (inherited)
*   --  padEnding    -> rightPad (inherited)
*
*   Removed:
*   --  EMPTY_STRING_ARRAY; usage replaced with commons.lang.ArrayUtils.EMPTY_STRING_ARRAY
*   --  SPACES
*   --  UTF_8; rare usage replaced with raw string
*   --  concat; usage replaced with commons.lang.join, refactoring as necessary.
*   --  getLettersOnly
*   --  getSpaces
*   --  truncate
*   --  valueOf; usage refactored to use defaultString
*
*   Refactored
*   --  defaultIfBlank: previously relied on varargs and could return null.  Usage refactored to allow inheritance from commons.
*   --  defaultString(s, EMPTY) refactored to use standard signature defaultString(s) for consistency throughout codebase.
*   --  isBlank: usage refactored to resolve discrepancies with commons.lang.isBlank, which is now inherited.
*   --  isEmpty: usage refactored to resolve discrepancies with commons.lang.isEmpty, which is now inherited.
*
*   Code Cleanup:
*   --  Many uses of !isBlank -> isNotBlank
*   --  Changes suggested by Inspections on most touched files.
*   --     Explicit <T> -> <> when type is inferable
*   --     while loops operating on iterators converted to for each loops
*   --     for loops operating on array indices converted to for each loops
*   --  Various string typos corrected.
*   --  isEmpty(s.trim()) -> isBlank(s)
*   --  s.trim().isEmpty() -> isEmpty(s)
*   --  Removed some instances of 'dead' code
*   --  Optimized imports in every touched file
*
*   Qualitative Changes:
*   --  The following functions now throw an error when called with a null string input:
*   --  *  LocatorLauncher.Builder.setMemberName
*   --  *  ServerLauncher.Builder.setMemberName
*   --  *  ServerLauncher.Builder.setHostnameForClients
*   --  (Unit tests added to capture these changes)
*
*   Notes:
*   --  StringUtils.wraps may be inherited from Apache Commons when the dependency is updated.
*   --  AbstractLauncher.getMember has the documented behavior of returning null when both MemberName and ID are blank.  Is this the best behavior for this method?

* this closes #521

-import java.io.File;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.SortedSet;
-import java.util.TreeSet;
-import java.util.UUID;
-import java.util.concurrent.ConcurrentHashMap;
-
-import javax.management.InstanceNotFoundException;
-import javax.management.ListenerNotFoundException;
-import javax.management.MBeanServer;
-import javax.management.Notification;
-import javax.management.NotificationBroadcasterSupport;
-import javax.management.NotificationListener;
-import javax.management.ObjectName;
-
-import org.apache.logging.log4j.Logger;
-
+import org.apache.commons.lang.StringUtils;
+import org.apache.logging.log4j.Logger;
+
+import java.io.File;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.SortedSet;
+import java.util.TreeSet;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import javax.management.InstanceNotFoundException;
+import javax.management.ListenerNotFoundException;
+import javax.management.MBeanServer;
+import javax.management.Notification;
+import javax.management.NotificationBroadcasterSupport;
+import javax.management.NotificationListener;
+import javax.management.ObjectName;
-   * Gatway Sender Proxy set size
+   * Gateway Sender Proxy set size
-   * Gatway Receiver Proxy set size
+   * Gateway Receiver Proxy set size
-    this.distrLockServiceMap = new ConcurrentHashMap<ObjectName, DistributedLockServiceBridge>();
-    this.distrRegionMap = new ConcurrentHashMap<ObjectName, DistributedRegionBridge>();
-    this.mapOfMembers = new ConcurrentHashMap<ObjectName, MemberMXBean>();
-    this.mapOfServers = new ConcurrentHashMap<ObjectName, CacheServerMXBean>();
-    this.mapOfGatewayReceivers = new ConcurrentHashMap<ObjectName, GatewayReceiverMXBean>();
-    this.mapOfGatewaySenders = new ConcurrentHashMap<ObjectName, GatewaySenderMXBean>();
+    this.distrLockServiceMap = new ConcurrentHashMap<>();
+    this.distrRegionMap = new ConcurrentHashMap<>();
+    this.mapOfMembers = new ConcurrentHashMap<>();
+    this.mapOfServers = new ConcurrentHashMap<>();
+    this.mapOfGatewayReceivers = new ConcurrentHashMap<>();
+    this.mapOfGatewaySenders = new ConcurrentHashMap<>();
-        Map<String, String[]> backedUpDiskStores = new HashMap<String, String[]>();
+        Map<String, String[]> backedUpDiskStores = new HashMap<>();
-      List<String> listOfReceivers = new ArrayList<String>();
+      List<String> listOfReceivers = new ArrayList<>();
-      List<String> listOfServer = new ArrayList<String>();
+      List<String> listOfServer = new ArrayList<>();
-      List<String> listOfServer = new ArrayList<String>();
+      List<String> listOfServer = new ArrayList<>();
-  public String[] listGatwaySenders() {
+  public String[] listGatewaySenders() {
-      List<String> listOfSenders = new ArrayList<String>();
+      List<String> listOfSenders = new ArrayList<>();
-      Set<String> set = new HashSet<String>();
+      Set<String> set = new HashSet<>();
-        for (String locator : hostedLocators) {
-          set.add(locator);
-        }
+        set.addAll(hostedLocators);
-      String[] locators = set.toArray(new String[set.size()]);
-      return locators;
+      return set.toArray(new String[set.size()]);
-      Map<String, String[]> mapOfDisks = new HashMap<String, String[]>();
+      Map<String, String[]> mapOfDisks = new HashMap<>();
-        Set<String> locatorMemberSet = new TreeSet<String>();
+        Set<String> locatorMemberSet = new TreeSet<>();
-    Set<DistributedMember> members = new HashSet<DistributedMember>();
+    Set<DistributedMember> members = new HashSet<>();
-      Set<String> locatorMemberSet = new TreeSet<String>();
+      Set<String> locatorMemberSet = new TreeSet<>();
-          name = name != null && !name.trim().isEmpty() ? name : member.getId();
+          name = StringUtils.isNotBlank(name) ? name : member.getId();
-      Set<String> groupSet = new TreeSet<String>();
+      Set<String> groupSet = new TreeSet<>();
-   * @return basic Opertaing metrics for a given member.
+   * @return basic Operating metrics for a given member.
-    SortedSet<String> regionPathsSet = new TreeSet<String>();
+    SortedSet<String> regionPathsSet = new TreeSet<>();
-      Iterator<InternalDistributedMember> it = members.iterator();
-      while (it.hasNext()) {
-        shutDownMembers[j] = it.next().getId();
+      for (InternalDistributedMember member : members) {
+        shutDownMembers[j] = member.getId();
-   * @return Array of PeristentMemberDetails (which contains host, directory and disk store id)
+   * @return Array of PersistentMemberDetails (which contains host, directory and disk store id)
-    Set<PersistentID> persitentMemberSet = MissingPersistentIDsRequest.send(dm);
-    if (persitentMemberSet != null && persitentMemberSet.size() > 0) {
-      missingDiskStores = new PersistentMemberDetails[persitentMemberSet.size()];
+    Set<PersistentID> persistentMemberSet = MissingPersistentIDsRequest.send(dm);
+    if (persistentMemberSet != null && persistentMemberSet.size() > 0) {
+      missingDiskStores = new PersistentMemberDetails[persistentMemberSet.size()];
-      for (PersistentID id : persitentMemberSet) {
+      for (PersistentID id : persistentMemberSet) {
-  public boolean revokeMissingDiskStores(final String diskStoreId) throws Exception {
+  public boolean revokeMissingDiskStores(final String diskStoreId) {
-    ObjectName memberName = MBeanJMXAdapter.getMemberMBeanName(member);
-    return memberName;
+    return MBeanJMXAdapter.getMemberMBeanName(member);
-    List<ObjectName> list = new ArrayList<ObjectName>();
+    List<ObjectName> list = new ArrayList<>();
-    List<ObjectName> list = new ArrayList<ObjectName>();
-    Iterator<ObjectName> it = distrRegionMap.keySet().iterator();
-    while (it.hasNext()) {
-      list.add(it.next());
-    }
+    List<ObjectName> list = new ArrayList<>();
+    list.addAll(distrRegionMap.keySet());
-      ObjectName lockSerName = service.getDistributedLockServiceMBeanName(lockServiceName);
-      return lockSerName;
+      return service.getDistributedLockServiceMBeanName(lockServiceName);
-      listName = new ArrayList<ObjectName>();
+      listName = new ArrayList<>();
-      ObjectName[] arry = new ObjectName[listName.size()];
-      return listName.toArray(arry);
+      ObjectName[] array = new ObjectName[listName.size()];
+      return listName.toArray(array);
-      Set<String> uniqueClientSet = new HashSet<String>();
-      Iterator<CacheServerMXBean> it = mapOfServers.values().iterator();
-      while (it.hasNext()) {
-        String[] clients = null;
+      Set<String> uniqueClientSet = new HashSet<>();
+      for (CacheServerMXBean cacheServerMXBean : mapOfServers.values()) {
+        String[] clients;
-          clients = it.next().getClientIds();
+          clients = cacheServerMXBean.getClientIds();
-          for (String client : clients) {
-            uniqueClientSet.add(client);
-          }
+          Collections.addAll(uniqueClientSet, clients);
-      Map<String, Boolean> senderMap = new HashMap<String, Boolean>();
-      Iterator<GatewaySenderMXBean> it = mapOfGatewaySenders.values().iterator();
-      while (it.hasNext()) {
-        GatewaySenderMXBean bean = it.next();
+      Map<String, Boolean> senderMap = new HashMap<>();
+      for (GatewaySenderMXBean bean : mapOfGatewaySenders.values()) {
-        FederationComponent newObj = (FederationComponent) (fedComp);
+        FederationComponent newObj = fedComp;
-        FederationComponent newObj = (FederationComponent) (fedComp);
+        FederationComponent newObj = fedComp;
-      FederationComponent newProxy = (FederationComponent) (newValue);
+      FederationComponent newProxy = newValue;
-        oldProxy = (FederationComponent) oldValue;
+        oldProxy = oldValue;
-    // neeeded.
+    // needed.

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS40 UPD42 MOV43 INS60 MOV60 MOV21 UPD66 UPD66 UPD66 UPD66 MOV32 MOV74 INS59 MOV32 MOV32 MOV14 MOV14 MOV14 MOV14 MOV60 MOV60 INS70 UPD42 INS42 INS14 UPD42 INS42 INS70 INS70 UPD74 UPD74 UPD74 UPD74 UPD74 UPD74 MOV8 MOV32 UPD74 UPD74 INS44 INS42 MOV8 UPD42 UPD42 INS74 UPD74 MOV32 INS44 MOV32 MOV8 INS44 MOV32 MOV8 MOV43 INS60 UPD42 MOV43 INS42 UPD42 MOV43 UPD42 UPD42 MOV43 INS42 MOV43 INS42 INS42 UPD74 UPD74 UPD74 UPD74 UPD74 UPD74 MOV74 INS59 UPD74 UPD74 UPD74 UPD74 INS8 UPD74 MOV43 MOV43 UPD42 UPD42 INS42 INS14 UPD42 MOV21 INS42 INS42 INS42 UPD74 INS74 UPD42 MOV42 MOV43 UPD42 UPD42 INS42 UPD42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL85 DEL5 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL70 DEL8 DEL42 DEL43 DEL85 DEL5 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL43 DEL85 DEL5 DEL42 DEL43 DEL42 DEL43 DEL42 DEL33 DEL27 DEL32 DEL32 DEL38 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL32 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL43 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL8 DEL61 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL43 DEL33 DEL42 DEL32 DEL42 DEL43 DEL42 DEL44 DEL42 DEL8 DEL70 DEL8 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL36 DEL11 DEL42 DEL43 DEL42 DEL36 DEL11 DEL42 DEL43 DEL42 DEL43 DEL42 DEL36 DEL11 DEL42 DEL43 DEL42 DEL11
GEODE-4176 locator creates "locator0view.dat" file when started with port 0

Modified the locator to ensure that the wildcard bind has occurred before
GMSLocator creates its persistent view file.  I also did some code
cleanup and addressed GEODE-1243.

This closes #1214

-  public static final int NON_GOSSIP_REQUEST_VERSION = 0;
+
-  private static/* GemStoneAddition */ final Map GOSSIP_TO_GEMFIRE_VERSION_MAP = new HashMap();
-
-  /**
-   * For the new client-server protocol, which ignores the usual handshake mechanism.
-   */
-  public static final byte PROTOBUF_CLIENT_SERVER_PROTOCOL = (byte) 110;
+  private static final Map GOSSIP_TO_GEMFIRE_VERSION_MAP = new HashMap();
-  protected/* GemStoneAddition */ final/* GemStoneAddition */ static int READ_TIMEOUT =
+  protected static final int READ_TIMEOUT =
-  private final int port;
-  private int serverSocketPortAtClose;
+  private int port;
-  private volatile boolean shuttingDown = false; // GemStoneAddition
+  private volatile boolean shuttingDown = false;
-   * GemStoneAddition - Initialize versions map. Warning: This map must be compatible with all
-   * GemFire versions being handled by this member "With different GOSSIPVERION". If GOSSIPVERIONS
-   * are same for then current GOSSIPVERSION should be used.
-   *
-   * @since GemFire 7.1
+   * Initialize versions map. Warning: This map must be compatible with all GemFire versions being
+   * handled by this member "With different GOSSIPVERION". If GOSSIPVERIONS are same for then
+   * current GOSSIPVERSION should be used.
-  /**
-   * returns the message handler used for client/locator communications processing
-   */
-  public ClientProtocolServiceLoader getClientProtocolServiceLoader() {
-    return clientProtocolServiceLoader;
-  }
-
+    initializeServerSocket();
+    if (serverThread == null || !serverThread.isAlive()) {
+      serverThread = new Thread(threadGroup, threadName) {
+        @Override
+        public void run() {
+          TcpServer.this.run();
+        }
+      };
+      serverThread.setDaemon(true);
+      serverThread.start();
+    }
+  }
+
+  private void initializeServerSocket() throws IOException {
+      // GEODE-4176 - set the port from a wild-card bind so that handlers know the correct value
+      if (this.port <= 0) {
+        this.port = srv_sock.getLocalPort();
+      }
-      srv_sock.setReuseAddress(true); // GemStoneAddition
-    }
-    if (serverThread == null || !serverThread.isAlive()) {
-      serverThread = new Thread(threadGroup, threadName) {
-        @Override // GemStoneAddition
-        public void run() {
-          TcpServer.this.run();
-        }
-      };
-      serverThread.setDaemon(true);
-      serverThread.start();
+      srv_sock.setReuseAddress(true);
-   * @return the locator's tcp/ip port. This will be zero if the locator hasn't been started.
+   * @return the locator's tcp/ip port. This will be zero if the TcpServer hasn't been started.
-    if (srv_sock != null && !srv_sock.isClosed()) {
-      return srv_sock.getLocalPort();
-    }
-    return serverSocketPortAtClose;
+    return port;
+          return;
+      if (srv_sock.isClosed()) {
+        log.error("Locator socket was closed unexpectedly - server thread is exiting.");
+        shuttingDown = true;
+        break;
+      }
-        // looping=false; GemStoneAddition change
-    try {
-      srv_sock.close();
-
-    } catch (java.io.IOException ex) {
-      log.warn("exception closing server socket during shutdown", ex);
+    if (!srv_sock.isClosed()) {
+      try {
+        srv_sock.close();
+      } catch (java.io.IOException ex) {
+        log.warn("exception closing server socket during shutdown", ex);
+      }
-        this.serverSocketPortAtClose = srv_sock.getLocalPort();
-  /**
-   * Returns GossipVersion for older Gemfire versions.
-   *
-   * @return gossip version
-   */
-  public static int getGossipVersionForOrdinal(short ordinal) {
-
-    // Sanity check
-    short closest = -1;
-    int closestGV = getCurrentGossipVersion();
-
-    if (ordinal < Version.CURRENT_ORDINAL) {
-      Iterator<Map.Entry> itr = TcpServer.GOSSIP_TO_GEMFIRE_VERSION_MAP.entrySet().iterator();
-      while (itr.hasNext()) {
-        Map.Entry entry = itr.next();
-        short o = (Short) entry.getValue();
-        if (o == ordinal) {
-          return (Integer) entry.getKey();
-        } else if (o < ordinal && o > closest) {
-          closest = o;
-          closestGV = (Integer) entry.getKey();
-        }
-      }
-    }
-
-    return closestGV;
-  }
-

MOV31 INS31 INS83 INS83 INS39 INS42 UPD43 MOV43 INS8 UPD42 MOV29 INS42 INS8 UPD42 INS21 MOV25 MOV41 INS25 INS32 UPD66 INS42 MOV38 INS8 UPD42 MOV42 INS25 INS25 MOV54 INS27 INS8 INS32 INS8 INS22 INS34 INS21 INS42 INS42 INS21 INS21 INS10 INS52 INS42 INS7 INS32 INS7 INS22 MOV32 INS41 INS42 INS42 INS45 INS42 INS9 INS52 INS42 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL39 DEL34 DEL11 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL42 DEL39 DEL42 DEL44 DEL39 DEL42 DEL34 DEL38 DEL59 DEL60 DEL39 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL40 DEL27 DEL42 DEL43 DEL40 DEL43 DEL74 DEL42 DEL40 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL40 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL27 DEL8 DEL42 DEL42 DEL27 DEL42 DEL42 DEL27 DEL27 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL25 DEL25 DEL8 DEL61 DEL8 DEL25 DEL42 DEL41 DEL8 DEL83 DEL39 DEL42 DEL42 DEL33 DEL27 DEL27 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL52 DEL42 DEL22 DEL7 DEL21
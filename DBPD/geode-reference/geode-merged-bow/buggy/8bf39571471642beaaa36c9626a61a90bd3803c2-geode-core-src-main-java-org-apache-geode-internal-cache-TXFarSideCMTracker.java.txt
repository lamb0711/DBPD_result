Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+
-/** 
- * TXFarSideCMTracker tracks received and processed TXCommitMessages,
- * for transactions that contain changes for DACK regions.  Its main
- * purpose is to allow recovery in the event that the VM which
- * orinated the TXCommitMessage exits the DistributedSystem. Tracking
- * is done by using TXLockIds or TXIds.  It is designed for these
- * failure cases:
+/**
+ * TXFarSideCMTracker tracks received and processed TXCommitMessages, for transactions that contain
+ * changes for DACK regions. Its main purpose is to allow recovery in the event that the VM which
+ * orinated the TXCommitMessage exits the DistributedSystem. Tracking is done by using TXLockIds or
+ * TXIds. It is designed for these failure cases:
- *   <li>The TX Originator has died during sending the second
- *   message which one or more of the recipients (aka Far Siders)
- *   missed.  To help in this case, each of the Far Siders will
- *   broadcast a message to determine if the second commit 
- *   message was received.</li>
+ * <li>The TX Originator has died during sending the second message which one or more of the
+ * recipients (aka Far Siders) missed. To help in this case, each of the Far Siders will broadcast a
+ * message to determine if the second commit message was received.</li>
- *   <li>The TX Grantor (the reservation system) has noticed that the
- *   TX Originator has died and queries each of the Far Siders to
- *   determine if the reservation (aka <code>TXLockId</code>) given to
- *   the TX Originator is no longer needed (the transaction has been
- *   processed)</li>
+ * <li>The TX Grantor (the reservation system) has noticed that the TX Originator has died and
+ * queries each of the Far Siders to determine if the reservation (aka <code>TXLockId</code>) given
+ * to the TX Originator is no longer needed (the transaction has been processed)</li>
- *   <li>The TX Grantor has died and a new one is considering granting
- *   new reservations, but before doing so must query all of the
- *   members to know if all the previous granted reservations (aka
- *   <code>TXLockId</code>s are no longer needed (the transactions
- *   have been processed)</li>
+ * <li>The TX Grantor has died and a new one is considering granting new reservations, but before
+ * doing so must query all of the members to know if all the previous granted reservations (aka
+ * <code>TXLockId</code>s are no longer needed (the transactions have been processed)</li>
-public class TXFarSideCMTracker
-{
+public class TXFarSideCMTracker {
-  
+
-  /** 
+  /**
-   * @param historySize The number of processed transactions to
-   * remember in the event that fellow Far Siders did not receive the second message.
+   * @param historySize The number of processed transactions to remember in the event that fellow
+   *        Far Siders did not receive the second message.
-  public TXFarSideCMTracker(int historySize)  {
-    // InternalDistributedSystem sys = (InternalDistributedSystem) CacheFactory.getAnyInstance().getDistributedSystem();
+  public TXFarSideCMTracker(int historySize) {
+    // InternalDistributedSystem sys = (InternalDistributedSystem)
+    // CacheFactory.getAnyInstance().getDistributedSystem();
-   * Answers fellow "Far Siders" question about an DACK transaction
-   * when the transaction originator died before it sent the CommitProcess message.
+   * Answers fellow "Far Siders" question about an DACK transaction when the transaction originator
+   * died before it sent the CommitProcess message.
-    // Assume that after the member has departed that we have all its pending 
+    // Assume that after the member has departed that we have all its pending
-      
+
-    synchronized(this.txInProgress) {
+    synchronized (this.txInProgress) {
-      if (null!=mess && mess.isProcessing()) {
+      if (null != mess && mess.isProcessing()) {
-      for(int i=this.txHistory.length-1; i>=0; --i) {
+      for (int i = this.txHistory.length - 1; i >= 0; --i) {
-    if(mess!=null) {
-      synchronized(mess) {
-        if(!mess.isProcessing()) {
+    if (mess != null) {
+      synchronized (mess) {
+        if (!mess.isProcessing()) {
-   *  Answers new Grantor query regarding whether it can start handing
-   *  out new locks. Waits until txInProgress is empty.
+   * Answers new Grantor query regarding whether it can start handing out new locks. Waits until
+   * txInProgress is empty.
-  public final void waitForAllToProcess() 
-    throws InterruptedException
-  {
-    if (Thread.interrupted()) throw new InterruptedException(); // wisest to do this before the synchronize below
+  public final void waitForAllToProcess() throws InterruptedException {
+    if (Thread.interrupted())
+      throw new InterruptedException(); // wisest to do this before the synchronize below
-    synchronized(this.txInProgress) {
+    synchronized (this.txInProgress) {
-   * Answers existing Grantor's question about the status of a
-   * reservation/lock given to a departed/ing Originator (this will most likely be 
-   * called nearly the same time as commitProcessReceived
+   * Answers existing Grantor's question about the status of a reservation/lock given to a
+   * departed/ing Originator (this will most likely be called nearly the same time as
+   * commitProcessReceived
-    synchronized(this.txInProgress) {
-      mess=(TXCommitMessage) this.txInProgress.get(lk);
+    synchronized (this.txInProgress) {
+      mess = (TXCommitMessage) this.txInProgress.get(lk);
-    if (mess!=null) {
-      synchronized(mess) {
+    if (mess != null) {
+      synchronized (mess) {
-                LocalizedStrings.TxFarSideTracker_WAITING_TO_COMPLETE_ON_MESSAGE_0_CAUGHT_AN_INTERRUPTED_EXCEPTION, mess), ie);
-             break;
+                LocalizedStrings.TxFarSideTracker_WAITING_TO_COMPLETE_ON_MESSAGE_0_CAUGHT_AN_INTERRUPTED_EXCEPTION,
+                mess), ie);
+            break;
-    } 
-    else {
+    } else {
-      for(int i=this.txHistory.length-1; i>=0; --i) {
+      for (int i = this.txHistory.length - 1; i >= 0; --i) {
-        // MembershipListener implementation
-        public void memberJoined(InternalDistributedMember id) {
-        }
-        public void memberSuspect(InternalDistributedMember id,
-            InternalDistributedMember whoSuspected, String reason) {
-        }
-        public void memberDeparted(InternalDistributedMember id, boolean crashed) {
-          if (memberId.equals(id)) {
-            synchronized(lock) {
-              lock.notifyAll();
-            }
+      // MembershipListener implementation
+      public void memberJoined(InternalDistributedMember id) {}
+
+      public void memberSuspect(InternalDistributedMember id,
+          InternalDistributedMember whoSuspected, String reason) {}
+
+      public void memberDeparted(InternalDistributedMember id, boolean crashed) {
+        if (memberId.equals(id)) {
+          synchronized (lock) {
+            lock.notifyAll();
-        public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
-        }
-      };
+      }
+
+      public void quorumLost(Set<InternalDistributedMember> failures,
+          List<InternalDistributedMember> remaining) {}
+    };
-      synchronized(lock) {
+      synchronized (lock) {
-    } 
-    finally {
+    } finally {
-   * Indicate that the transaction message has been processed
-   * and to place it in the transaction history
+   * Indicate that the transaction message has been processed and to place it in the transaction
+   * history
-    synchronized(this.txInProgress) {
+    synchronized (this.txInProgress) {
-    if (mess!=null) {
-      synchronized(mess) {
+    if (mess != null) {
+      synchronized (mess) {
-  /** 
-   * Indicate that this message is never going to be processed,
-   * typically used in the case where none of the FarSiders
-   * received the CommitProcessMessage
+  /**
+   * Indicate that this message is never going to be processed, typically used in the case where
+   * none of the FarSiders received the CommitProcessMessage
-    synchronized(this.txInProgress) {
+    synchronized (this.txInProgress) {
-    synchronized(this.txInProgress) {
+    synchronized (this.txInProgress) {
-    synchronized(this.txInProgress) {
+    synchronized (this.txInProgress) {
-      if (key == null) { 
+      if (key == null) {
-  
-  //TODO we really need to keep around only one msg for each thread on a client
-  private Map<TXId ,TXCommitMessage> failoverMap = Collections.synchronizedMap(new LinkedHashMap<TXId, TXCommitMessage>() {
-    protected boolean removeEldestEntry(Entry eldest) {
-      return size() > TXManagerImpl.FAILOVER_TX_MAP_SIZE;
-    };
-  });
+
+  // TODO we really need to keep around only one msg for each thread on a client
+  private Map<TXId, TXCommitMessage> failoverMap =
+      Collections.synchronizedMap(new LinkedHashMap<TXId, TXCommitMessage>() {
+        protected boolean removeEldestEntry(Entry eldest) {
+          return size() > TXManagerImpl.FAILOVER_TX_MAP_SIZE;
+        };
+      });
-  
+
-  
+
-   * a static TXFarSideCMTracker is held by TXCommitMessage and is 
-   * cleared when the cache has finished closing
+   * a static TXFarSideCMTracker is held by TXCommitMessage and is cleared when the cache has
+   * finished closing

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
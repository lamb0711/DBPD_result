GEODE-4650: Refactor Elder selection (#2393)

GEODE-4650: Resolve race condition in selection of the elder

* no longer cache the elder, re-compute the elder when needed
* extract elder logic to a new class to make unit testing possible
* adds tests for elder selection
* adds tests of DLock Grantor failover
* removes isAdam() - isAdam used to mean that the member was alone (that there were no non-surprise, non-admin members in the cluster) when it joined. This was only used in two places. The first, in the DLockService, protected against recovering dlocks when there isn't a cluster. This usage is replaced with a check for isLoner(). The other use of isAdam was in ElderInitProcessor and was redundant with an inner check if there were other members in the distributed system.
* fix testFairness so that it can be run repeatedly in the same JVM 

Signed-off-by: Dan Smith <dsmith@pivotal.io>
Signed-off-by: Galen O'Sullivan <gosullivan@pivotal.io>
Signed-off-by: Ken Howe <khowe@pivotal.io>

-      findServices();
-
-      FindCoordinatorRequest findRequest = (FindCoordinatorRequest) request;
-      if (!findRequest.getDHAlgo().equals(securityUDPDHAlgo)) {
-        return new FindCoordinatorResponse(
-            "Rejecting findCoordinatorRequest, as member not configured same udp security("
-                + findRequest.getDHAlgo() + " )as locator (" + securityUDPDHAlgo + ")");
-      }
-
-      if (services != null) {
-        services.getMessenger().setPublicKey(findRequest.getMyPublicKey(),
-            findRequest.getMemberID());
-      } else {
-        if (findRequest.getMyPublicKey() != null) {
-          registerMbrVsPK.put(new InternalDistributedMemberWrapper(findRequest.getMemberID()),
-              findRequest.getMyPublicKey());
-        }
-        logger.debug("Rejecting a request to find the coordinator - membership services are"
-            + " still initializing");
-        return null;
-      }
-
-      if (findRequest.getMemberID() != null) {
-        InternalDistributedMember coord = null;
-
-        // at this level we want to return the coordinator known to membership services,
-        // which may be more up-to-date than the one known by the membership manager
-        if (view == null) {
-          findServices();
-          if (services == null) {
-            // we must know this process's identity in order to respond
-            return null;
-          }
-        }
-
-        boolean fromView = false;
-        NetView v = this.view;
-        if (v == null) {
-          v = this.recoveredView;
-        }
-
-        synchronized (registrants) {
-          registrants.add(findRequest.getMemberID());
-        }
-
-        if (v != null) {
-          // if the ID of the requester matches an entry in the membership view then remove
-          // that entry - it's obviously an old member since the ID has been reused
-          InternalDistributedMember rid = findRequest.getMemberID();
-          for (InternalDistributedMember id : v.getMembers()) {
-            if (rid.compareTo(id, false) == 0) {
-              NetView newView = new NetView(v, v.getViewId());
-              newView.remove(id);
-              v = newView;
-              break;
-            }
-          }
-
-          if (v.getViewId() > findRequest.getLastViewId()) {
-            // ignore the requests rejectedCoordinators if the view has changed
-            coord = v.getCoordinator(Collections.emptyList());
-          } else {
-            coord = v.getCoordinator(findRequest.getRejectedCoordinators());
-          }
-          logger.debug("Peer locator: coordinator from view is {}", coord);
-          fromView = true;
-        }
-
-        if (coord == null) {
-          // find the "oldest" registrant
-          Collection<InternalDistributedMember> rejections = findRequest.getRejectedCoordinators();
-          if (rejections == null) {
-            rejections = Collections.emptyList();
-          }
-          synchronized (registrants) {
-            coord = services.getJoinLeave().getMemberID();
-            for (InternalDistributedMember mbr : registrants) {
-              if (mbr != coord && (coord == null || mbr.compareTo(coord) < 0)) {
-                if (!rejections.contains(mbr) && (mbr.getNetMember().preferredForCoordinator()
-                    || !mbr.getNetMember().isNetworkPartitionDetectionEnabled())) {
-                  coord = mbr;
-                }
-              }
-            }
-            logger.debug("Peer locator: coordinator from registrations is {}", coord);
-          }
-        }
-
-        synchronized (registrants) {
-          if (isCoordinator) {
-            coord = localAddress;
-            InternalDistributedMember viewCoordinator = null;
-            if (v != null) {
-              viewCoordinator = v.getCoordinator();
-            }
-            fromView = viewCoordinator != null && !viewCoordinator.equals(localAddress);
-            if (!fromView) {
-              v = null;
-            }
-          }
-          byte[] coordPk = null;
-          if (v != null) {
-            coordPk = (byte[]) v.getPublicKey(coord);
-          }
-          if (coordPk == null) {
-            coordPk = services.getMessenger().getPublicKey(coord);
-          }
-          response = new FindCoordinatorResponse(coord, localAddress, fromView, v,
-              new HashSet<InternalDistributedMember>(registrants),
-              this.networkPartitionDetectionEnabled, this.usePreferredCoordinators, coordPk);
-        }
-      }
+      response = processFindCoordinatorRequest((FindCoordinatorRequest) request);
+  private FindCoordinatorResponse processFindCoordinatorRequest(
+      FindCoordinatorRequest findRequest) {
+    findServices();
+    if (!findRequest.getDHAlgo().equals(securityUDPDHAlgo)) {
+      return new FindCoordinatorResponse(
+          "Rejecting findCoordinatorRequest, as member not configured same udp security("
+              + findRequest.getDHAlgo() + " )as locator (" + securityUDPDHAlgo + ")");
+    }
+
+    if (services == null) {
+      if (findRequest.getMyPublicKey() != null) {
+        registerMbrVsPK.put(new InternalDistributedMemberWrapper(findRequest.getMemberID()),
+            findRequest.getMyPublicKey());
+      }
+      logger.debug("Rejecting a request to find the coordinator - membership services are"
+          + " still initializing");
+      return null;
+    }
+
+    if (findRequest.getMemberID() == null) {
+      return null;
+    }
+
+    services.getMessenger().setPublicKey(findRequest.getMyPublicKey(),
+        findRequest.getMemberID());
+
+    InternalDistributedMember coordinator = null;
+
+    // at this level we want to return the coordinator known to membership services,
+    // which may be more up-to-date than the one known by the membership manager
+    if (view == null) {
+      findServices();
+      if (services == null) {
+        // we must know this process's identity in order to respond
+        return null;
+      }
+    }
+
+    boolean fromView = false;
+    NetView v = this.view;
+    if (v == null) {
+      v = this.recoveredView;
+    }
+
+    synchronized (registrants) {
+      registrants.add(findRequest.getMemberID());
+    }
+
+    if (v != null) {
+      // if the ID of the requester matches an entry in the membership view then remove
+      // that entry - it's obviously an old member since the ID has been reused
+      InternalDistributedMember requestingMemberID = findRequest.getMemberID();
+      for (InternalDistributedMember id : v.getMembers()) {
+        if (requestingMemberID.compareTo(id, false) == 0) {
+          NetView newView = new NetView(v, v.getViewId());
+          newView.remove(id);
+          v = newView;
+          break;
+        }
+      }
+
+      if (v.getViewId() > findRequest.getLastViewId()) {
+        // ignore the requests rejectedCoordinators if the view has changed
+        coordinator = v.getCoordinator(Collections.emptyList());
+      } else {
+        coordinator = v.getCoordinator(findRequest.getRejectedCoordinators());
+      }
+      logger.info("Peer locator: coordinator from view is {}", coordinator);
+      fromView = true;
+    }
+
+    if (coordinator == null) {
+      // find the "oldest" registrant
+      Collection<InternalDistributedMember> rejections = findRequest.getRejectedCoordinators();
+      if (rejections == null) {
+        rejections = Collections.emptyList();
+      }
+
+      synchronized (registrants) {
+        coordinator = services.getJoinLeave().getMemberID();
+        for (InternalDistributedMember mbr : registrants) {
+          if (mbr != coordinator && (coordinator == null || mbr.compareTo(coordinator) < 0)) {
+            if (!rejections.contains(mbr) && (mbr.getNetMember().preferredForCoordinator()
+                || !mbr.getNetMember().isNetworkPartitionDetectionEnabled())) {
+              coordinator = mbr;
+            }
+          }
+        }
+        logger.info("Peer locator: coordinator from registrations is {}", coordinator);
+      }
+    }
+
+    synchronized (registrants) {
+      if (isCoordinator) {
+        coordinator = localAddress;
+
+        if (v != null && !v.getCoordinator().equals(localAddress)) {
+          logger.info("This member is becoming coordinator since view {}", v);
+          v = null;
+        }
+      }
+
+      byte[] coordinatorPublicKey = null;
+      if (v != null) {
+        coordinatorPublicKey = (byte[]) v.getPublicKey(coordinator);
+      }
+      if (coordinatorPublicKey == null) {
+        coordinatorPublicKey = services.getMessenger().getPublicKey(coordinator);
+      }
+
+      return new FindCoordinatorResponse(coordinator, localAddress, fromView, v,
+          new HashSet<>(registrants),
+          this.networkPartitionDetectionEnabled, this.usePreferredCoordinators,
+          coordinatorPublicKey);
+    }
+  }
+

INS31 MOV78 INS83 MOV43 INS42 MOV44 MOV43 INS8 UPD83 INS43 UPD42 INS44 MOV8 MOV60 MOV25 MOV25 INS25 MOV25 MOV41 INS42 MOV43 INS42 MOV21 MOV25 MOV25 INS25 MOV21 MOV62 MOV8 INS25 UPD27 UPD27 MOV27 INS8 MOV62 INS8 INS41 UPD42 UPD42 INS41 INS21 INS33 MOV5 MOV14 INS7 UPD42 UPD42 UPD42 INS25 UPD42 UPD42 UPD42 UPD42 INS42 INS32 INS27 MOV8 UPD74 INS42 MOV11 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV27 MOV38 INS21 UPD42 UPD42 UPD42 INS32 MOV5 UPD42 MOV32 INS42 INS42 INS45 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 DEL8 DEL42 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL33 DEL27 DEL27 DEL7 DEL21 DEL42 DEL38 DEL25 DEL42 DEL43 DEL42 DEL7 DEL21 DEL42 DEL59 DEL60 DEL25 DEL8 DEL25 DEL25 DEL8
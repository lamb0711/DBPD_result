Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Agent implementation that controls the JMX server end points for JMX clients
- * to connect, such as an RMI server.
+ * Agent implementation that controls the JMX server end points for JMX clients to connect, such as
+ * an RMI server.
- * The ManagementAgent could be used in a loner or GemFire client to define and
- * control JMX server end points for the Platform MBeanServer and the GemFire
- * MBeans hosted within it.
+ * The ManagementAgent could be used in a loner or GemFire client to define and control JMX server
+ * end points for the Platform MBeanServer and the GemFire MBeans hosted within it.
+ * 
-   * True if running. Protected by synchronizing on this Manager instance. I
-   * used synchronization because I think we'll want to hold the same
-   * synchronize while configuring, starting, and eventually stopping the RMI
-   * server, the hidden management regions (in FederatingManager), etc
+   * True if running. Protected by synchronizing on this Manager instance. I used synchronization
+   * because I think we'll want to hold the same synchronize while configuring, starting, and
+   * eventually stopping the RMI server, the hidden management regions (in FederatingManager), etc
-   * This system property is set to true when the embedded HTTP server is
-   * started so that the embedded pulse webapp can use a local MBeanServer
-   * instead of a remote JMX connection.
+   * This system property is set to true when the embedded HTTP server is started so that the
+   * embedded pulse webapp can use a local MBeanServer instead of a remote JMX connection.
-    return (cache.getDistributedSystem().getDistributedMember().getVmKind() != DistributionManager.LOCATOR_DM_TYPE && cache.getDistributedSystem()
-                                                                                                                           .getDistributedMember()
-                                                                                                                           .getVmKind() != DistributionManager.ADMIN_ONLY_DM_TYPE && !cache
-      .isClient());
+    return (cache.getDistributedSystem().getDistributedMember()
+        .getVmKind() != DistributionManager.LOCATOR_DM_TYPE
+        && cache.getDistributedSystem().getDistributedMember()
+            .getVmKind() != DistributionManager.ADMIN_ONLY_DM_TYPE
+        && !cache.isClient());
-        logger.debug("Developer REST APIs webapp is already running, Not Starting M&M REST and pulse!");
+        logger.debug(
+            "Developer REST APIs webapp is already running, Not Starting M&M REST and pulse!");
-    final SystemManagementService managementService = (SystemManagementService) ManagementService.getManagementService(CacheFactory.getAnyInstance());
+    final SystemManagementService managementService = (SystemManagementService) ManagementService
+        .getManagementService(CacheFactory.getAnyInstance());
-        logger.debug("Attempting to start HTTP service on port ({}) at bind-address ({})...", this.config.getHttpServicePort(), this.config.getHttpServiceBindAddress());
+        logger.debug("Attempting to start HTTP service on port ({}) at bind-address ({})...",
+            this.config.getHttpServicePort(), this.config.getHttpServiceBindAddress());
-          logger.debug("Unable to find GemFire Management REST API WAR file; the Management REST Interface for GemFire will not be accessible.");
+          logger.debug(
+              "Unable to find GemFire Management REST API WAR file; the Management REST Interface for GemFire will not be accessible.");
-        final String message = "Unable to find Pulse web application WAR file; Pulse for GemFire will not be accessible";
+        final String message =
+            "Unable to find Pulse web application WAR file; Pulse for GemFire will not be accessible";
-        final String message = "Unable to find GemFire Developer REST API WAR file; the Developer REST Interface for GemFire will not be accessible.";
+        final String message =
+            "Unable to find GemFire Developer REST API WAR file; the Developer REST Interface for GemFire will not be accessible.";
-          this.httpServer = JettyHelper.initJetty(bindAddress, port, SSLConfigurationFactory.getSSLConfigForComponent(SecurableCommunicationChannel.WEB));
+          this.httpServer = JettyHelper.initJetty(bindAddress, port,
+              SSLConfigurationFactory.getSSLConfigForComponent(SecurableCommunicationChannel.WEB));
-            this.httpServer = JettyHelper
-                .addWebApplication(this.httpServer, "/gemfire", gemfireWar);
-            this.httpServer = JettyHelper
-                .addWebApplication(this.httpServer, "/geode-mgmt", gemfireWar);
+            this.httpServer =
+                JettyHelper.addWebApplication(this.httpServer, "/gemfire", gemfireWar);
+            this.httpServer =
+                JettyHelper.addWebApplication(this.httpServer, "/geode-mgmt", gemfireWar);
-              this.httpServer = JettyHelper.addWebApplication(this.httpServer, "/geode",
-                  gemfireAPIWar);
-              this.httpServer = JettyHelper.addWebApplication(this.httpServer, "/gemfire-api",
-                  gemfireAPIWar);
+              this.httpServer =
+                  JettyHelper.addWebApplication(this.httpServer, "/geode", gemfireAPIWar);
+              this.httpServer =
+                  JettyHelper.addWebApplication(this.httpServer, "/gemfire-api", gemfireAPIWar);
-            final String message = "Developer REST API web application will not start when start-dev-rest-api is not set and node is not server";
+            final String message =
+                "Developer REST API web application will not start when start-dev-rest-api is not set and node is not server";
-            logger.debug("Starting HTTP embedded server on port ({}) at bind-address ({})...", ((ServerConnector) this.httpServer.getConnectors()[0]).getPort(), bindAddress);
+            logger.debug("Starting HTTP embedded server on port ({}) at bind-address ({})...",
+                ((ServerConnector) this.httpServer.getConnectors()[0]).getPort(), bindAddress);
-            managerBean.setPulseURL("http://".concat(getHost(bindAddress)).concat(":").concat(String.valueOf(port)).concat("/pulse/"));
+            managerBean.setPulseURL("http://".concat(getHost(bindAddress)).concat(":")
+                .concat(String.valueOf(port)).concat("/pulse/"));
-        setStatusMessage(managerBean, "HTTP service failed to start with " + e.getClass().getSimpleName() + " '" + e.getMessage() + "'");
+        setStatusMessage(managerBean, "HTTP service failed to start with "
+            + e.getClass().getSimpleName() + " '" + e.getMessage() + "'");
-      setStatusMessage(managerBean, "Embedded HTTP server configured not to start (http-service-port=0) or (jmx-manager-http-port=0)");
+      setStatusMessage(managerBean,
+          "Embedded HTTP server configured not to start (http-service-port=0) or (jmx-manager-http-port=0)");
-          logger.error("Failed to properly release resources held by the HTTP service: {}", ignore.getMessage(), ignore);
+          logger.error("Failed to properly release resources held by the HTTP service: {}",
+              ignore.getMessage(), ignore);
-   * http://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html
-   * #gdfvq https://blogs.oracle.com/jmxetc/entry/java_5_premain_rmi_connectors
+   * http://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html #gdfvq
+   * https://blogs.oracle.com/jmxetc/entry/java_5_premain_rmi_connectors
-    final SocketCreator socketCreator = SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.JMX);
+    final SocketCreator socketCreator =
+        SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.JMX);
-      logger.debug("Starting jmx manager agent on port {}{}", port, (bindAddr != null ? (" bound to " + bindAddr) : "") + (ssl ? " using SSL" : ""));
+      logger.debug("Starting jmx manager agent on port {}{}", port,
+          (bindAddr != null ? (" bound to " + bindAddr) : "") + (ssl ? " using SSL" : ""));
-    RMIServerSocketFactory rmiServerSocketFactory = new GemFireRMIServerSocketFactory(socketCreator, bindAddr);
+    RMIServerSocketFactory rmiServerSocketFactory =
+        new GemFireRMIServerSocketFactory(socketCreator, bindAddr);
-    final RMIServerImpl stub = new RMIJRMPServerImpl(port, rmiClientSocketFactory, rmiServerSocketFactory, env);
+    final RMIServerImpl stub =
+        new RMIJRMPServerImpl(port, rmiClientSocketFactory, rmiServerSocketFactory, env);
-    final JMXServiceURL url = new JMXServiceURL("service:jmx:rmi://" + hostname + ":" + port + "/jndi/rmi://" + hostname + ":" + port + "/jmxrmi");
+    final JMXServiceURL url = new JMXServiceURL("service:jmx:rmi://" + hostname + ":" + port
+        + "/jndi/rmi://" + hostname + ":" + port + "/jmxrmi");
-    jmxConnectorServer = new RMIConnectorServer(new JMXServiceURL("rmi", hostname, port), env, stub, mbs) {
-      @Override
-      public JMXServiceURL getAddress() {
-        return url;
-      }
+    jmxConnectorServer =
+        new RMIConnectorServer(new JMXServiceURL("rmi", hostname, port), env, stub, mbs) {
+          @Override
+          public JMXServiceURL getAddress() {
+            return url;
+          }
-      @Override
-      public synchronized void start() throws IOException {
-        try {
-          registry.bind("jmxrmi", stub);
-        } catch (AlreadyBoundException x) {
-          final IOException io = new IOException(x.getMessage());
-          io.initCause(x);
-          throw io;
-        }
-        super.start();
-      }
-    };
+          @Override
+          public synchronized void start() throws IOException {
+            try {
+              registry.bind("jmxrmi", stub);
+            } catch (AlreadyBoundException x) {
+              final IOException io = new IOException(x.getMessage());
+              io.initCause(x);
+              throw io;
+            }
+            super.start();
+          }
+        };
-      jmxConnectorServer.addNotificationListener(shiroAuthenticator, null, jmxConnectorServer.getAttributes());
-      // always going to assume authorization is needed as well, if no custom AccessControl, then the CustomAuthRealm
+      jmxConnectorServer.addNotificationListener(shiroAuthenticator, null,
+          jmxConnectorServer.getAttributes());
+      // always going to assume authorization is needed as well, if no custom AccessControl, then
+      // the CustomAuthRealm
-          throw new GemFireConfigException("Error while configuring accesscontrol for jmx resource", e);
+          throw new GemFireConfigException("Error while configuring accesscontrol for jmx resource",
+              e);
-          throw new GemFireConfigException("Error while configuring accesscontrol for jmx resource", e);
+          throw new GemFireConfigException("Error while configuring accesscontrol for jmx resource",
+              e);
-          throw new GemFireConfigException("Error while configuring accesscontrol for jmx resource", e);
+          throw new GemFireConfigException("Error while configuring accesscontrol for jmx resource",
+              e);
-  private static class GemFireRMIClientSocketFactory implements RMIClientSocketFactory, Serializable {
+  private static class GemFireRMIClientSocketFactory
+      implements RMIClientSocketFactory, Serializable {
-  private static class GemFireRMIServerSocketFactory implements RMIServerSocketFactory, Serializable {
+  private static class GemFireRMIServerSocketFactory
+      implements RMIServerSocketFactory, Serializable {

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * RegionVersionHolders are part of a RegionVersionVector.  A RVH holds the
- * current version for a member and a list of exceptions, which are
- * holes in the list of versions received from that member.
+ * RegionVersionHolders are part of a RegionVersionVector. A RVH holds the current version for a
+ * member and a list of exceptions, which are holes in the list of versions received from that
+ * member.
- * Starting in 7.0.1 the holder has a BitSet that records the most recent
- * versions.  The variable bitSetVersion corresponds to bit zero, and
- * subsequent bits represent bitSetVersion+1, +2, etc.  The method
- * mergeBitSet() should be used to dump the BitSet's exceptions into
- * the regular exceptions list prior to performing operations like exceptions-
- * comparisons or dominance checks.
+ * Starting in 7.0.1 the holder has a BitSet that records the most recent versions. The variable
+ * bitSetVersion corresponds to bit zero, and subsequent bits represent bitSetVersion+1, +2, etc.
+ * The method mergeBitSet() should be used to dump the BitSet's exceptions into the regular
+ * exceptions list prior to performing operations like exceptions- comparisons or dominance checks.
- * Starting in 8.0, the holder introduced a special exception to describe following use case of unfinished operation:
- * Operation R4 and R5 are applied locally, but never distributed to P. So P's RVV for R is still 3.
- * After R GIIed from P, R's RVV becomes R5(3-6), i.e. Exception's nextVersion is currentVersion+1. 
+ * Starting in 8.0, the holder introduced a special exception to describe following use case of
+ * unfinished operation: Operation R4 and R5 are applied locally, but never distributed to P. So P's
+ * RVV for R is still 3. After R GIIed from P, R's RVV becomes R5(3-6), i.e. Exception's nextVersion
+ * is currentVersion+1.
-  
+
-  
+
-    
+
-  //non final for tests
-  public static int BIT_SET_WIDTH = 64 * 16;  // should be a multiple of 4 64-bit longs
+  // non final for tests
+  public static int BIT_SET_WIDTH = 64 * 16; // should be a multiple of 4 64-bit longs
-  
+
-   * This contructor should only be used for cloning a RegionVersionHolder
-   * or initializing and invalid version holder (with version -1)
+   * This contructor should only be used for cloning a RegionVersionHolder or initializing and
+   * invalid version holder (with version -1)
+   * 
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
-  
+
+
-  
+
-      for (RVVException e: this.exceptions) {
+      for (RVVException e : this.exceptions) {
-      clone.bitSet = (BitSet)this.bitSet.clone();
+      clone.bitSet = (BitSet) this.bitSet.clone();
-  
+
-//    mergeBitSet();
+    // mergeBitSet();
-    sb.append("{rv").append(this.version)
-      .append(" bsv").append(this.bitSetVersion)
-      .append(" bs=[");
+    sb.append("{rv").append(this.version).append(" bsv").append(this.bitSetVersion).append(" bs=[");
-      int i=this.bitSet.nextSetBit(0);
-      if (i>=0) {
+      int i = this.bitSet.nextSetBit(0);
+      if (i >= 0) {
-        for (i=this.bitSet.nextSetBit(1); i > 0; i=this.bitSet.nextSetBit(i+1)) {
+        for (i = this.bitSet.nextSetBit(1); i > 0; i = this.bitSet.nextSetBit(i + 1)) {
-      sb.append(this.exceptions.toString()); 
+      sb.append(this.exceptions.toString());
-  
+
-    for (Iterator<RVVException> it = this.exceptions.iterator(); it.hasNext(); ) {
+    for (Iterator<RVVException> it = this.exceptions.iterator(); it.hasNext();) {
-        return;  // there is no RVVException for this version
+        return; // there is no RVVException for this version
-      if (e.previousVersion < missingVersion  &&  missingVersion < e.nextVersion) {
+      if (e.previousVersion < missingVersion && missingVersion < e.nextVersion) {
-        } else if(e.shouldChangeForm()) {
+        } else if (e.shouldChangeForm()) {
-  
+
-    
+
-    
+
-      logger.trace(LogMarker.RVV, "flushing RVV bitset bitSetVersion={}; bits={}", this.bitSetVersion, this.bitSet);
+      logger.trace(LogMarker.RVV, "flushing RVV bitset bitSetVersion={}; bits={}",
+          this.bitSetVersion, this.bitSet);
-      // yes - flush the lower part.  We can only flush up to the last set bit because
+      // yes - flush the lower part. We can only flush up to the last set bit because
-      addBitSetExceptions(bitCountToFlush, this.bitSetVersion+bitCountToFlush);
+      addBitSetExceptions(bitCountToFlush, this.bitSetVersion + bitCountToFlush);
-      logger.trace(LogMarker.RVV, "After flushing bitSetVersion={}; bits={}", this.bitSetVersion, this.bitSet);
+      logger.trace(LogMarker.RVV, "After flushing bitSetVersion={}; bits={}", this.bitSetVersion,
+          this.bitSet);
-  
-  
+
+
-      addBitSetExceptions((int)(this.version-this.bitSetVersion), this.version);
+      addBitSetExceptions((int) (this.version - this.bitSetVersion), this.version);
-  
+
-   * Add exceptions from the BitSet array to the exceptions list.  Assumes that
-   * the BitSet[0] corresponds to this.bitSetVersion.  This scans the bitset
-   * looking for gaps that are recorded as RVV exceptions.  The scan terminates
-   * at numBits or when the last set bit is found.  The bitSet is adjusted and
-   * a new bitSetVersion is established.
+   * Add exceptions from the BitSet array to the exceptions list. Assumes that the BitSet[0]
+   * corresponds to this.bitSetVersion. This scans the bitset looking for gaps that are recorded as
+   * RVV exceptions. The scan terminates at numBits or when the last set bit is found. The bitSet is
+   * adjusted and a new bitSetVersion is established.
-   * @param newVersion  the desired new bitSetVersion, which may be > the max representable in the bitset
+   * @param newVersion the desired new bitSetVersion, which may be > the max representable in the
+   *        bitset
-    
+
-      logger.trace(LogMarker.RVV, "addBitSetExceptions({},{})",numBits, newVersion);
+      logger.trace(LogMarker.RVV, "addBitSetExceptions({},{})", numBits, newVersion);
-    for (int idx = 0; idx < numBits; ) {
+    for (int idx = 0; idx < numBits;) {
-      lastSetIndex = nextMissingIndex-1;
-      
-      int nextReceivedIndex = this.bitSet.nextSetBit(nextMissingIndex+1);
+      lastSetIndex = nextMissingIndex - 1;
+
+      int nextReceivedIndex = this.bitSet.nextSetBit(nextMissingIndex + 1);
-        nextReceivedVersion = (long)(nextReceivedIndex) + this.bitSetVersion;
-        idx = nextReceivedIndex+1;
+        nextReceivedVersion = (long) (nextReceivedIndex) + this.bitSetVersion;
+        idx = nextReceivedIndex + 1;
-          logger.trace(LogMarker.RVV, "found gap in bitSet: missing bit at index={}; next set index={}", nextMissingIndex, nextReceivedIndex);
+          logger.trace(LogMarker.RVV,
+              "found gap in bitSet: missing bit at index={}; next set index={}", nextMissingIndex,
+              nextReceivedIndex);
-        //are no more received versions
+        // are no more received versions
-          logger.trace(LogMarker.RVV, "terminating flush at bit {} because of missing entries", lastSetIndex);
+          logger.trace(LogMarker.RVV, "terminating flush at bit {} because of missing entries",
+              lastSetIndex);
-        if(lastSetIndex != -1) {
+        if (lastSetIndex != -1) {
-      long nextMissingVersion = Math.max(1, nextMissingIndex+this.bitSetVersion);
+      long nextMissingVersion = Math.max(1, nextMissingIndex + this.bitSetVersion);
-        addException(nextMissingVersion-1, nextReceivedVersion);
+        addException(nextMissingVersion - 1, nextReceivedVersion);
-          logger.trace(LogMarker.RVV,  "Added rvv exception e<rv{} - rv{}>", (nextMissingVersion-1), nextReceivedVersion);
+          logger.trace(LogMarker.RVV, "Added rvv exception e<rv{} - rv{}>",
+              (nextMissingVersion - 1), nextReceivedVersion);
-    this.bitSet = this.bitSet.get(lastSetIndex, Math.max(lastSetIndex+1, bitSet.size()));
+    this.bitSet = this.bitSet.get(lastSetIndex, Math.max(lastSetIndex + 1, bitSet.size()));
-      this.bitSetVersion = this.bitSetVersion + (long)lastSetIndex;
+      this.bitSetVersion = this.bitSetVersion + (long) lastSetIndex;
-  
+
-    if ( (version - this.version) > 1) {
+    if ((version - this.version) > 1) {
-    
+
-    this.bitSet.set((int)(version-this.bitSetVersion));
+    this.bitSet.set((int) (version - this.bitSetVersion));
-  
+
-  
+
-    for (Iterator<RVVException> it=this.exceptions.iterator(); it.hasNext(); i++) {
+    for (Iterator<RVVException> it = this.exceptions.iterator(); it.hasNext(); i++) {
-  
+
-      for (Iterator<RVVException> it=this.exceptions.iterator(); it.hasNext();) {
+      for (Iterator<RVVException> it = this.exceptions.iterator(); it.hasNext();) {
-  
+
-   * Initialize this version holder from another version holder
-   * This is called during GII.
+   * Initialize this version holder from another version holder This is called during GII.
-   * It's more likely that the other holder has seen most of the
-   * versions, and this version holder only has
-   * a few updates that happened since the GII started. So we apply
-   * our seen versions to the other version holder and then initialize
-   * this version holder from the other version holder. 
+   * It's more likely that the other holder has seen most of the versions, and this version holder
+   * only has a few updates that happened since the GII started. So we apply our seen versions to
+   * the other version holder and then initialize this version holder from the other version holder.
-    //Make sure the bitsets are merged in both the source
-    //and this vector
+    // Make sure the bitsets are merged in both the source
+    // and this vector
-    
+
-    //Get a copy of the local version and exceptions
+    // Get a copy of the local version and exceptions
-    
-    //initialize our version and exceptions to match the others
+
+    // initialize our version and exceptions to match the others
-    
-    //Initialize the bit set to be empty. Merge bit set should
-    //have already done this, but just to be sure.
-    if(this.bitSet != null) {
-      this.bitSetVersion=this.version;
-    //Make sure the bit set is empty except for the first, bit, indicating
-    //that the version has been received.
+
+    // Initialize the bit set to be empty. Merge bit set should
+    // have already done this, but just to be sure.
+    if (this.bitSet != null) {
+      this.bitSetVersion = this.version;
+      // Make sure the bit set is empty except for the first, bit, indicating
+      // that the version has been received.
-    
+
-      RVVException e = RVVException.createException(this.version, myVersion+1);
+      RVVException e = RVVException.createException(this.version, myVersion + 1);
-      int i=0;
-      for (RVVException exception: this.exceptions) {
+      int i = 0;
+      for (RVVException exception : this.exceptions) {
-  
+
-   * initialize a holder that was cloned from another holder so it is
-   * ready for use in a live vector
+   * initialize a holder that was cloned from another holder so it is ready for use in a live vector
-  
+
-        return this.bitSet.get((int)(v-this.bitSetVersion));
+        return this.bitSet.get((int) (v - this.bitSetVersion));
-      for (Iterator<RVVException> it = this.exceptions.iterator(); it.hasNext(); ) {
+      for (Iterator<RVVException> it = this.exceptions.iterator(); it.hasNext();) {
-          return true ;  // there is no RVVException for this version
+          return true; // there is no RVVException for this version
-        if (e.previousVersion < v  &&  v < e.nextVersion) {
+        if (e.previousVersion < v && v < e.nextVersion) {
-  
+
-   * Returns true if this version hold has an exception in the exception list
-   * for the given version number.
+   * Returns true if this version hold has an exception in the exception list for the given version
+   * number.
-   * This differs from contains because it returns true if v is greater
-   * than the last seen version for this holder.
+   * This differs from contains because it returns true if v is greater than the last seen version
+   * for this holder.
-      if (v > this.bitSetVersion+this.bitSet.length()) {
+      if (v > this.bitSetVersion + this.bitSet.length()) {
-      return this.bitSet.get((int)(v-this.bitSetVersion));
+      return this.bitSet.get((int) (v - this.bitSetVersion));
-    for (Iterator<RVVException> it = this.exceptions.iterator(); it.hasNext(); ) {
+    for (Iterator<RVVException> it = this.exceptions.iterator(); it.hasNext();) {
-        return false;  // there is no RVVException for this version
+        return false; // there is no RVVException for this version
-      if (e.previousVersion < v  &&  v < e.nextVersion) {
+      if (e.previousVersion < v && v < e.nextVersion) {
-  
+
-    // For example, P was at P3, operation P4 is on-going and identified as unfinished operation. 
+    // For example, P was at P3, operation P4 is on-going and identified as unfinished operation.
-    
-    //Prevent synhronization issues if other is a live version vector.
+
+    // Prevent synhronization issues if other is a live version vector.
-    
+
-//    System.out.println("comparing " + mine + " with " + his);
-    RVVException myException = myIterator.hasNext()? myIterator.next() : null;
-    RVVException otherException = otherIterator.hasNext()? otherIterator.next() : null;
+    // System.out.println("comparing " + mine + " with " + his);
+    RVVException myException = myIterator.hasNext() ? myIterator.next() : null;
+    RVVException otherException = otherIterator.hasNext() ? otherIterator.next() : null;
-      otherException = otherIterator.hasNext()? otherIterator.next() : null;
+      otherException = otherIterator.hasNext() ? otherIterator.next() : null;
-//      System.out.println("comparing " + myException + " with " + otherException);
+      // System.out.println("comparing " + myException + " with " + otherException);
-        myException = myIterator.hasNext()? myIterator.next() : null;
+        myException = myIterator.hasNext() ? myIterator.next() : null;
-        otherException = otherIterator.hasNext()? otherIterator.next() : null;
+        otherException = otherIterator.hasNext() ? otherIterator.next() : null;
-        //        |____|  my exception
-        // |____|         other exception
+        // |____| my exception
+        // |____| other exception
-        myException = myIterator.hasNext()? myIterator.next() : null;
+        myException = myIterator.hasNext() ? myIterator.next() : null;
-        // |____|         my exception
-        //        |____|  other exception
+        // |____| my exception
+        // |____| other exception
-        // |____|   -- other exception
+        // |____| -- other exception
-        myException = myIterator.hasNext()? myIterator.next() : null;
-        otherException = otherIterator.hasNext()? otherIterator.next() : null;
+        myException = myIterator.hasNext() ? myIterator.next() : null;
+        otherException = otherIterator.hasNext() ? otherIterator.next() : null;
-      //     |_________________|       my exception
-      //   |____|                   \
-      //            |____|*          \ the other exception is one of
-      //                    |____|   / these
-      //   |_____________________|  /
+      // |_________________| my exception
+      // |____| \
+      // |____|* \ the other exception is one of
+      // |____| / these
+      // |_____________________| /
-      otherException = otherIterator.hasNext()? otherIterator.next() : null;
+      otherException = otherIterator.hasNext() ? otherIterator.next() : null;
-//    System.out.println("Done iterating and returning false");
+    // System.out.println("Done iterating and returning false");
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-   * Version Holders serialized to disk, so if the serialization
-   * format of version holder changes, we need to upgrade our persistence
-   * format.
+   * Version Holders serialized to disk, so if the serialization format of version holder changes,
+   * we need to upgrade our persistence format.
-      for (RVVException e: this.exceptions) {
+      for (RVVException e : this.exceptions) {
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-      for (int i=0; i<size; i++) {
+      for (int i = 0; i < size; i++) {
-  
-  
-  /* Warning: this hashcode uses mutable state and is only good for as long
-   * as the holder is not modified.  It was added for unit testing.
+
+
+  /*
+   * Warning: this hashcode uses mutable state and is only good for as long as the holder is not
+   * modified. It was added for unit testing.
+   * 
-    result = prime * result + (int)version;
-    result = prime * result + (int)(version>>32);
+    result = prime * result + (int) version;
+    result = prime * result + (int) (version >> 32);
-      for (Iterator<RVVException> it=this.exceptions.iterator(); it.hasNext();) {
+      for (Iterator<RVVException> it = this.exceptions.iterator(); it.hasNext();) {
-  
-  /** For test purposes only. Two
-   * RVVs that have effectively same exceptions
-   * may represent the exceptions differently. This
-   * method will test to see if the exception lists are
-   * effectively the same, regardless of representation.
+
+  /**
+   * For test purposes only. Two RVVs that have effectively same exceptions may represent the
+   * exceptions differently. This method will test to see if the exception lists are effectively the
+   * same, regardless of representation.
-    
+
-  
+
-    return sameAs((RegionVersionHolder)obj);
+    return sameAs((RegionVersionHolder) obj);
-   * Canonicalize an ordered set of exceptions. In the canonical form,
-   * none of the RVVExceptions have any received versions.
+   * Canonicalize an ordered set of exceptions. In the canonical form, none of the RVVExceptions
+   * have any received versions.
+   * 
-      //Iterate through the set of exceptions
-      for(RVVException exception : exceptions) {
+      // Iterate through the set of exceptions
+      for (RVVException exception : exceptions) {
-          //Iterate through the set of received versions for this exception
+          // Iterate through the set of received versions for this exception
-          for(ReceivedVersionsIterator it = exception.receivedVersionsIterator(); it.hasNext(); ) {
+          for (ReceivedVersionsIterator it = exception.receivedVersionsIterator(); it.hasNext();) {
-            //If we find a gap between the previous received version and the
-            //next received version, add an exception.
-            if(received != previous + 1) {
+            // If we find a gap between the previous received version and the
+            // next received version, add an exception.
+            if (received != previous + 1) {
-            //move the previous reference
+            // move the previous reference
-          
-          //if there is a gap between the last received version and the next
-          //version, add an exception
-          //this also handles the case where the RVV has no received versions,
-          //because previous==exception.previousVersion in that case.
-          if(exception.nextVersion != previous + 1) {
+
+          // if there is a gap between the last received version and the next
+          // version, add an exception
+          // this also handles the case where the RVV has no received versions,
+          // because previous==exception.previousVersion in that case.
+          if (exception.nextVersion != previous + 1) {
-  
-  
+
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
GEODE-2113 Implement SSL over NIO

This fixes several bugs in the original implementation of SSL over NIO.
Notably there were buffer handling problems in MsgReader and the
NioFilters.  This new commit includes code coverage for these classes
in new tests.

Original commit message:

This removes old-I/O use in TCPConduit peer-to-peer communications.
This was used for SSL/TLS secure commuications but Java has had an
SSLEngine implementation that allows you to implement secure communications
on new-I/O SocketChannels or any other transport mechanism.

A new NioSSLEngine class wraps the JDK's SSLEngine and provides the
SSL handshake as well as encryption/decryption of messages. SocketCreator
performs the SSL handshake and returns a NioSslEngine that TCPConduit
then uses for messaging.

The SSL handshake needs to be done in Connection.java now because the
ByteBuffer used to do the handshake is also used for reading messages
in Receivers. Because of this the Handshake pool in TCPConduit became
obsolete and I deleted it.

I've also done a lot of cleanup of compilation warnings in Connection.java
and removed references to "NIO". The primary SSL/TLS changes in that class
are in writeFully (renamed from nioWriteFully) and processBuffer (renamed
from processNIOBuffer).

While testing I noticed some places where we're creating non-daemon
threads that were keeping DUnit ChildVM processes from exiting.  I've
changed these places to use daemon threads.  Very few threads in Geode
should be non-daemon.

Porting client/server to use NioSSLEngine will be done under a separate
ticket and a different version of NioEngine may be created to secure
UDP messaging.

+import java.nio.BufferUnderflowException;
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.internal.Assert;
+import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.internal.net.Buffers;
+import org.apache.geode.internal.net.NioFilter;
-public abstract class MsgReader {
+public class MsgReader {
+  private static final Logger logger = LogService.getLogger();
+
-  private final ByteBufferInputStream bbis;
+  private final NioFilter ioFilter;
+  private ByteBuffer peerNetData;
+  private final ByteBufferInputStream byteBufferInputStream;
-  public MsgReader(Connection conn, Version version) {
+
+
+  MsgReader(Connection conn, NioFilter nioFilter, ByteBuffer peerNetData, Version version) {
-    this.bbis =
+    this.ioFilter = nioFilter;
+    this.peerNetData = peerNetData;
+    if (conn.getConduit().useSSL()) {
+      ByteBuffer buffer = ioFilter.getUnwrappedBuffer(peerNetData);
+      buffer.position(0).limit(0);
+    }
+    this.byteBufferInputStream =
-  public Header readHeader() throws IOException {
-    ByteBuffer nioInputBuffer = readAtLeast(Connection.MSG_HEADER_BYTES);
-    int nioMessageLength = nioInputBuffer.getInt();
-    /* nioMessageVersion = */ Connection.calcHdrVersion(nioMessageLength);
-    nioMessageLength = Connection.calcMsgByteSize(nioMessageLength);
-    byte nioMessageType = nioInputBuffer.get();
-    short nioMsgId = nioInputBuffer.getShort();
-    boolean directAck = (nioMessageType & Connection.DIRECT_ACK_BIT) != 0;
-    if (directAck) {
-      // logger.info("DEBUG: msg from " + getRemoteAddress() + " is direct ack" );
-      nioMessageType &= ~Connection.DIRECT_ACK_BIT; // clear the ack bit
+  Header readHeader() throws IOException {
+    ByteBuffer unwrappedBuffer = readAtLeast(Connection.MSG_HEADER_BYTES);
+
+    Assert.assertTrue(unwrappedBuffer.remaining() >= Connection.MSG_HEADER_BYTES);
+
+    int position = unwrappedBuffer.position();
+    int limit = unwrappedBuffer.limit();
+
+    try {
+      int nioMessageLength = unwrappedBuffer.getInt();
+      /* nioMessageVersion = */
+      Connection.calcHdrVersion(nioMessageLength);
+      nioMessageLength = Connection.calcMsgByteSize(nioMessageLength);
+      byte nioMessageType = unwrappedBuffer.get();
+      short nioMsgId = unwrappedBuffer.getShort();
+
+      boolean directAck = (nioMessageType & Connection.DIRECT_ACK_BIT) != 0;
+      if (directAck) {
+        nioMessageType &= ~Connection.DIRECT_ACK_BIT; // clear the ack bit
+      }
+
+      header.setFields(nioMessageLength, nioMessageType, nioMsgId);
+
+      return header;
+    } catch (BufferUnderflowException e) {
+      throw e;
-    header.nioMessageLength = nioMessageLength;
-    header.nioMessageType = nioMessageType;
-    header.nioMsgId = nioMsgId;
-    return header;
-  public DistributionMessage readMessage(Header header)
-      throws IOException, ClassNotFoundException, InterruptedException {
-    ByteBuffer nioInputBuffer = readAtLeast(header.nioMessageLength);
-    this.getStats().incMessagesBeingReceived(true, header.nioMessageLength);
+  DistributionMessage readMessage(Header header)
+      throws IOException, ClassNotFoundException {
+    ByteBuffer nioInputBuffer = readAtLeast(header.messageLength);
+    Assert.assertTrue(nioInputBuffer.remaining() >= header.messageLength);
+    this.getStats().incMessagesBeingReceived(true, header.messageLength);
+    int position = nioInputBuffer.position();
+    int limit = nioInputBuffer.limit();
-      bbis.setBuffer(nioInputBuffer);
-      DistributionMessage msg = null;
+      byteBufferInputStream.setBuffer(nioInputBuffer);
-      // add serialization stats
-      msg = (DistributionMessage) InternalDataSerializer.readDSFID(bbis);
-      return msg;
+      // dumpState("readMessage ready to deserialize", null, nioInputBuffer, position, limit);
+      return (DistributionMessage) InternalDataSerializer.readDSFID(byteBufferInputStream);
+    } catch (RuntimeException e) {
+      throw e;
+    } catch (IOException e) {
+      throw e;
-      this.getStats().decMessagesBeingReceived(header.nioMessageLength);
+      this.getStats().decMessagesBeingReceived(header.messageLength);
+      ioFilter.doneReading(nioInputBuffer);
-  public void readChunk(Header header, MsgDestreamer md)
-      throws IOException, ClassNotFoundException, InterruptedException {
-    ByteBuffer nioInputBuffer = readAtLeast(header.nioMessageLength);
-    this.getStats().incMessagesBeingReceived(md.size() == 0, header.nioMessageLength);
-    md.addChunk(nioInputBuffer, header.nioMessageLength);
+  void readChunk(Header header, MsgDestreamer md)
+      throws IOException {
+    ByteBuffer unwrappedBuffer = readAtLeast(header.messageLength);
+    this.getStats().incMessagesBeingReceived(md.size() == 0, header.messageLength);
+    md.addChunk(unwrappedBuffer, header.messageLength);
+    // show that the bytes have been consumed by adjusting the buffer's position
+    unwrappedBuffer.position(unwrappedBuffer.position() + header.messageLength);
-  public abstract ByteBuffer readAtLeast(int bytes) throws IOException;
-  protected DMStats getStats() {
+
+  private ByteBuffer readAtLeast(int bytes) throws IOException {
+    peerNetData = ioFilter.ensureWrappedCapacity(bytes, peerNetData,
+        Buffers.BufferType.TRACKED_RECEIVER, getStats());
+    return ioFilter.readAtLeast(conn.getSocket().getChannel(), bytes, peerNetData, getStats());
+  }
+
+
+
+  private DMStats getStats() {
-    int nioMessageLength;
-    byte nioMessageType;
-    short nioMsgId;
+    private int messageLength;
+    private byte messageType;
+    private short messageId;
-    public Header() {}
-
-    public int getNioMessageLength() {
-      return nioMessageLength;
+    public void setFields(int nioMessageLength, byte nioMessageType, short nioMsgId) {
+      messageLength = nioMessageLength;
+      messageType = nioMessageType;
+      messageId = nioMsgId;
-    public byte getNioMessageType() {
-      return nioMessageType;
+    int getMessageLength() {
+      return messageLength;
-    public short getNioMessageId() {
-      return nioMsgId;
+    byte getMessageType() {
+      return messageType;
-
+    short getMessageId() {
+      return messageId;
+    }
-  public void close() {}
-

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS42 INS23 INS23 INS23 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS43 INS59 INS44 INS44 INS8 UPD83 INS8 UPD83 INS42 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 INS43 INS42 INS43 INS42 INS21 INS21 INS25 MOV60 INS21 INS60 INS60 INS54 MOV21 MOV21 MOV60 INS60 INS54 INS21 INS21 INS41 INS83 INS83 INS83 INS39 UPD42 INS44 INS44 INS44 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS7 INS7 INS32 INS8 INS32 INS39 INS59 INS39 INS59 MOV8 INS12 INS39 INS59 INS39 INS59 INS8 INS12 INS12 INS8 INS32 INS7 INS32 UPD42 UPD42 UPD42 INS39 INS42 INS39 INS42 INS39 INS42 INS21 INS21 INS21 INS22 INS42 INS22 INS42 INS32 INS42 INS60 INS21 UPD42 INS42 INS42 INS27 INS42 INS32 INS42 INS32 INS21 INS44 INS8 UPD42 UPD42 INS27 UPD42 INS9 UPD40 INS42 INS32 INS42 INS32 INS21 MOV21 INS41 INS44 INS8 INS44 INS8 MOV21 MOV21 INS21 UPD42 UPD40 UPD42 UPD40 INS42 INS42 INS27 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS7 INS7 INS7 UPD42 UPD42 UPD42 INS52 INS42 INS52 INS42 INS42 INS42 INS43 INS59 INS32 UPD42 INS32 INS40 INS42 INS42 INS42 INS42 INS32 INS43 INS42 INS53 UPD40 INS32 INS40 INS42 INS42 INS42 INS42 INS32 INS11 INS43 INS42 INS53 INS43 INS42 INS53 INS32 UPD40 INS32 INS40 INS42 INS42 INS42 INS42 INS40 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 INS42 INS42 INS42 INS42 MOV43 MOV32 INS42 INS42 INS42 INS42 UPD42 UPD40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 UPD42 UPD42 UPD42 UPD42 DEL83 DEL42 DEL83 DEL83 DEL40 DEL42 DEL7 DEL21 DEL40 DEL42 DEL7 DEL21 DEL40 DEL42 DEL7 DEL21 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL33 DEL59 DEL9 DEL42 DEL11 DEL7 DEL21 DEL42 DEL41 DEL8 DEL8 DEL54 DEL83 DEL42 DEL43 DEL42 DEL43 DEL83 DEL83 DEL83 DEL83 DEL83 DEL39 DEL42 DEL8 DEL31
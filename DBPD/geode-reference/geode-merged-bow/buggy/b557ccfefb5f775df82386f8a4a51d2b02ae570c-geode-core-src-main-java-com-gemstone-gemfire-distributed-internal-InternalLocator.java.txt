GEODE-420: Locator ssl config.

+import static com.gemstone.gemfire.distributed.ConfigurationProperties.*;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.ConnectException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Properties;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apache.logging.log4j.Logger;
+
-import com.gemstone.gemfire.cache.client.internal.locator.*;
+import com.gemstone.gemfire.cache.client.internal.locator.ClientConnectionRequest;
+import com.gemstone.gemfire.cache.client.internal.locator.ClientReplacementRequest;
+import com.gemstone.gemfire.cache.client.internal.locator.GetAllServersRequest;
+import com.gemstone.gemfire.cache.client.internal.locator.LocatorListRequest;
+import com.gemstone.gemfire.cache.client.internal.locator.LocatorStatusRequest;
+import com.gemstone.gemfire.cache.client.internal.locator.QueueConnectionRequest;
+import com.gemstone.gemfire.cache.client.internal.locator.ServerLocationRequest;
+import com.gemstone.gemfire.distributed.internal.tcpserver.LocatorCancelException;
-import com.gemstone.gemfire.internal.net.*;
+import com.gemstone.gemfire.internal.net.SocketCreator;
+import com.gemstone.gemfire.internal.net.SocketCreatorFactory;
-import org.apache.logging.log4j.Logger;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.ConnectException;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.*;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import static com.gemstone.gemfire.distributed.ConfigurationProperties.*;
- * 
- * This class has APIs that perform essentially three layers of 
+ * <p>
+ * This class has APIs that perform essentially three layers of
- * 
+ * <p>
- * 
+ * <p>
- * services in one call. Otherwise, the services can be started 
+ * services in one call. Otherwise, the services can be started
- *
-  
-  /** How long (in milliseconds) a member that we haven't heard from
-   * in a while should live before we call it dead? */
+
+  /**
+   * How long (in milliseconds) a member that we haven't heard from
+   * in a while should live before we call it dead?
+   */
-  
+
-  
-  /** system property name for forcing an locator distribution manager type */
+
+  /**
+   * system property name for forcing an locator distribution manager type
+   */
-  
-  /** system property name for inhibiting DM banner */
+
+  /**
+   * system property name for inhibiting DM banner
+   */
-  
-  /** system property name for forcing locators to be preferred as coordinators */
+
+  /**
+   * system property name for forcing locators to be preferred as coordinators
+   */
-  /** The tcp server responding to locator requests */
+  /**
+   * The tcp server responding to locator requests
+   */
-  
-  /** The distributed system owned by this locator, if any.
+
+  /**
+   * The distributed system owned by this locator, if any.
-  /** The cache owned by this locator, if any.
+  /**
+   * The cache owned by this locator, if any.
-  
-  /** locator state file */
+
+  /**
+   * locator state file
+   */
-  
-  /** product use logging */
+
+  /**
+   * product use logging
+   */
-  
+
-  
+
-  
+
-  
-  /** the TcpHandler used for peer location */
+
+  /**
+   * the TcpHandler used for peer location
+   */
-  
+
-  
+
-  
-  /** whether the locator was stopped during forced-disconnect processing but a reconnect will occur */
+
+  /**
+   * whether the locator was stopped during forced-disconnect processing but a reconnect will occur
+   */
-  
-  /** whether the locator was stopped during forced-disconnect processing */
+
+  /**
+   * whether the locator was stopped during forced-disconnect processing
+   */
-  
+
-  
+
-  
-  private volatile boolean isSharedConfigurationStarted = false; 
-  
+
+  private volatile boolean isSharedConfigurationStarted = false;
+
-  
+
-  
+
-  
+
-  
-  /** the locator hosted by this JVM. As of 7.0 it is a singleton. */
+
+  /**
+   * the locator hosted by this JVM. As of 7.0 it is a singleton.
+   */
+
+
-    if (l == null) return false;
+    if (l == null) {
+      return false;
+    }
-  
+
-   * 
-   * @param port
-   *                the tcp/ip port to listen on
-   * @param logFile
-   *                the file that log messages should be written to
-   * @param stateFile
-   *                the file that state should be read from / written to for recovery               
-   * @param logger
-   *                a log writer that should be used (logFile parameter is
-   *                ignored)
-   * @param securityLogger
-   *                the logger to be used for security related log messages
-   * @param distributedSystemProperties
-   *                optional properties to configure the distributed system
-   *                (e.g., mcast addr/port, other locators)
+   * @param port the tcp/ip port to listen on
+   * @param logFile the file that log messages should be written to
+   * @param stateFile the file that state should be read from / written to for recovery
+   * @param logger a log writer that should be used (logFile parameter is
+   * ignored)
+   * @param securityLogger the logger to be used for security related log messages
+   * @param distributedSystemProperties optional properties to configure the distributed system
+   * (e.g., mcast addr/port, other locators)
-  public static InternalLocator createLocator(
-      int port,
-      File logFile,
-      File stateFile,
-      InternalLogWriter logger,
-      InternalLogWriter securityLogger,
-      InetAddress bindAddress,
-      String hostnameForClients,
-      java.util.Properties distributedSystemProperties, boolean startDistributedSystem) throws IOException {
+  public static InternalLocator createLocator(int port,
+                                              File logFile,
+                                              File stateFile,
+                                              InternalLogWriter logger,
+                                              InternalLogWriter securityLogger,
+                                              InetAddress bindAddress,
+                                              String hostnameForClients,
+                                              java.util.Properties distributedSystemProperties,
+                                              boolean startDistributedSystem) throws IOException {
-  
+
-    synchronized(locatorLock) {
-      if (locator != null  &&  locator != l) {
+    synchronized (locatorLock) {
+      if (locator != null && locator != l) {
-  
+
-   * 
-   * @param port
-   *    the tcp/ip port to listen on
-   * @param logFile
-   *    the file that log messages should be written to
-   * @param logger
-   *    a log writer that should be used (logFile parameter is ignored)
-   * @param securityLogger
-   *    the logger to be used for security related log messages
-   * @param dsProperties
-   *    optional properties to configure the distributed system (e.g., mcast addr/port, other locators)
-   * @param peerLocator
-   *    enable peer location services
-   * @param enableServerLocator
-   *    enable server location services
-   * @param hostnameForClients
-   *    the name to give to clients for connecting to this locator
-   * @param loadSharedConfigFromDir 
-   *    load the shared configuration from the shared configuration directory
-   * @throws IOException 
+   * @param port the tcp/ip port to listen on
+   * @param logFile the file that log messages should be written to
+   * @param logger a log writer that should be used (logFile parameter is ignored)
+   * @param securityLogger the logger to be used for security related log messages
+   * @param dsProperties optional properties to configure the distributed system (e.g., mcast addr/port, other locators)
+   * @param peerLocator enable peer location services
+   * @param enableServerLocator enable server location services
+   * @param hostnameForClients the name to give to clients for connecting to this locator
+   * @param loadSharedConfigFromDir load the shared configuration from the shared configuration directory
+   *
+   * @throws IOException
-  public static InternalLocator startLocator(
-      int port,
-      File logFile,
-      File stateFile,
-      InternalLogWriter logger,
-      InternalLogWriter securityLogger,
-      InetAddress bindAddress,
-      java.util.Properties dsProperties,
-      boolean peerLocator, 
-      boolean enableServerLocator,
-      String hostnameForClients, 
-      boolean loadSharedConfigFromDir
-      )
-      throws IOException {
+  public static InternalLocator startLocator(int port,
+                                             File logFile,
+                                             File stateFile,
+                                             InternalLogWriter logger,
+                                             InternalLogWriter securityLogger,
+                                             InetAddress bindAddress,
+                                             java.util.Properties dsProperties,
+                                             boolean peerLocator,
+                                             boolean enableServerLocator,
+                                             String hostnameForClients,
+                                             boolean loadSharedConfigFromDir) throws IOException {
-  
-  
+
+
-   * 
+   * <p>
-   * 
-   * @param port
-   *    the tcp/ip port to listen on
-   * @param logFile
-   *    the file that log messages should be written to
-   * @param logger
-   *    a log writer that should be used (logFile parameter is ignored)
-   * @param securityLogger
-   *    the logger to be used for security related log messages
-   * @param startDistributedSystem
-   *    if true, a distributed system is started
-   * @param dsProperties
-   *    optional properties to configure the distributed system (e.g., mcast addr/port, other locators)
-   * @param peerLocator
-   *    enable peer location services
-   * @param enableServerLocator
-   *    enable server location services
-   * @param hostnameForClients
-   *    the name to give to clients for connecting to this locator
+   * @param port the tcp/ip port to listen on
+   * @param logFile the file that log messages should be written to
+   * @param logger a log writer that should be used (logFile parameter is ignored)
+   * @param securityLogger the logger to be used for security related log messages
+   * @param startDistributedSystem if true, a distributed system is started
+   * @param dsProperties optional properties to configure the distributed system (e.g., mcast addr/port, other locators)
+   * @param peerLocator enable peer location services
+   * @param enableServerLocator enable server location services
+   * @param hostnameForClients the name to give to clients for connecting to this locator
-   * @throws IOException 
+   *
+   * @throws IOException
-  public static InternalLocator startLocator(
-    int port,
-    File logFile,
-    File stateFile,
-    InternalLogWriter logger,
-    InternalLogWriter securityLogger,
-    InetAddress bindAddress,
-    boolean startDistributedSystem,
-    java.util.Properties dsProperties,
-    boolean peerLocator, 
-    boolean enableServerLocator, 
-    String hostnameForClients, 
-    boolean loadSharedConfigFromDir
-    )
-    throws IOException
-  {
+  public static InternalLocator startLocator(int port,
+                                             File logFile,
+                                             File stateFile,
+                                             InternalLogWriter logger,
+                                             InternalLogWriter securityLogger,
+                                             InetAddress bindAddress,
+                                             boolean startDistributedSystem,
+                                             java.util.Properties dsProperties,
+                                             boolean peerLocator,
+                                             boolean enableServerLocator,
+                                             String hostnameForClients,
+                                             boolean loadSharedConfigFromDir) throws IOException {
-    if(!peerLocator && !enableServerLocator) {
+    if (!peerLocator && !enableServerLocator) {
-    
+
-    
+
-      
-    slocator = createLocator(port, logFile, stateFile, logger, securityLogger, bindAddress, hostnameForClients, dsProperties, startDistributedSystem);
-    
-    // TODO:GEODE-1243: this.server is now a TcpServer and it should store or return its non-zero port in a variable to use here
-    if (enableServerLocator) {
-      slocator.handler.willHaveServerLocator = true;
-    }
-    
-    if(peerLocator)  {
-      slocator.startPeerLocation(startDistributedSystem);
-    }
-    
-    if (startDistributedSystem) {
+      slocator = createLocator(port, logFile, stateFile, logger, securityLogger, bindAddress, hostnameForClients, dsProperties, startDistributedSystem);
+
+      // TODO:GEODE-1243: this.server is now a TcpServer and it should store or return its non-zero port in a variable to use here
+
+      if (enableServerLocator) {
+        slocator.handler.willHaveServerLocator = true;
+      }
-        slocator.startDistributedSystem(); // TODO:GEODE-1243: throws Exception if TcpServer still has zero for its locator port
-      } catch (RuntimeException e) {
+        if (peerLocator) {
+          slocator.startPeerLocation(startDistributedSystem);
+        }
+        if (startDistributedSystem) {
+          try {
+            slocator.startDistributedSystem(); // TODO:GEODE-1243: throws Exception if TcpServer still has zero for its locator port
+          } catch (RuntimeException e) {
+            slocator.stop();
+            throw e;
+          }
+          // fix bug #46324
+          final InternalDistributedSystem ids = (InternalDistributedSystem) slocator.myDs;
+          if (ids != null) {
+            ids.getDistributionManager().addHostedLocators(ids.getDistributedMember(), getLocatorStrings(), slocator.isSharedConfigurationEnabled());
+          }
+        }
+      } catch (LocatorCancelException e) {
-        throw e;
-      // fix bug #46324
-      final InternalDistributedSystem ids = (InternalDistributedSystem)slocator.myDs;
-      if (ids != null) {
-        ids.getDistributionManager().addHostedLocators(ids.getDistributedMember(), getLocatorStrings(), slocator.isSharedConfigurationEnabled());
+
+
+      // during the period when the product is using only paper licenses we always
+      // start server location services in order to be able to log information
+      // about the use of cache servers
+      //    if(enableServerLocator) {
+      //      slocator.startServerLocation(InternalDistributedSystem.getConnectedInstance());
+      //  }
+      InternalDistributedSystem sys = InternalDistributedSystem.getConnectedInstance();
+      if (sys != null) {
+        try {
+          slocator.startServerLocation(sys);
+        } catch (RuntimeException e) {
+          slocator.stop();
+          throw e;
+        }
-    }
-    // during the period when the product is using only paper licenses we always
-    // start server location services in order to be able to log information
-    // about the use of cache servers
-//    if(enableServerLocator) {
-//      slocator.startServerLocation(InternalDistributedSystem.getConnectedInstance());
-//  }
-    InternalDistributedSystem sys = InternalDistributedSystem.getConnectedInstance();
-    if (sys != null) {
-      try {
-        slocator.startServerLocation(sys);
-      } catch (RuntimeException e) {
-        slocator.stop();
-        throw e;
-      }
-    }
-    
-    slocator.endStartLocator(null);
-    startedLocator = true;
-    return slocator;
+
+      slocator.endStartLocator(null);
+      startedLocator = true;
+      return slocator;
-  
+
-    if (internalLocator == null)
+    if (internalLocator == null) {
-    
-    InternalDistributedSystem ids = (InternalDistributedSystem)internalLocator.myDs;
+    }
+
+    InternalDistributedSystem ids = (InternalDistributedSystem) internalLocator.myDs;
-    DistributionManager distMgr = (DistributionManager)ids.getDistributionManager();
+    DistributionManager distMgr = (DistributionManager) ids.getDistributionManager();
-  
+
-   * 
-   * @param port
-   *                the tcp/ip port to listen on
-   * @param logF
-   *                the file that log messages should be written to
-   * @param stateF
-   *    the file that state should be read from / written to for recovery
-   * @param logWriter
-   *                a log writer that should be used (logFile parameter is
-   *                ignored)
-   * @param securityLogWriter
-   *                the log writer to be used for security related log messages
-   * @param hostnameForClients
-   *    the name to give to clients for connecting to this locator
-   * @param distributedSystemProperties
-   *                optional properties to configure the distributed system
-   *                (e.g., mcast addr/port, other locators)
+   * @param port the tcp/ip port to listen on
+   * @param logF the file that log messages should be written to
+   * @param stateF the file that state should be read from / written to for recovery
+   * @param logWriter a log writer that should be used (logFile parameter is
+   * ignored)
+   * @param securityLogWriter the log writer to be used for security related log messages
+   * @param hostnameForClients the name to give to clients for connecting to this locator
+   * @param distributedSystemProperties optional properties to configure the distributed system
+   * (e.g., mcast addr/port, other locators)
-  private InternalLocator(
-    int port,
-    File logF,
-    File stateF,
-    InternalLogWriter logWriter, // LOG: 3 non-null sources: GemFireDistributionLocator, InternalDistributedSystem, LocatorLauncher
-    InternalLogWriter securityLogWriter, // LOG: 1 non-null source: GemFireDistributionLocator(same instance as logWriter), InternalDistributedSystem
-    InetAddress bindAddress,
-    String hostnameForClients,
-    java.util.Properties distributedSystemProperties, DistributionConfigImpl cfg, boolean startDistributedSystem) {
+  private InternalLocator(int port,
+                          File logF,
+                          File stateF,
+                          InternalLogWriter logWriter,
+                          // LOG: 3 non-null sources: GemFireDistributionLocator, InternalDistributedSystem, LocatorLauncher
+                          InternalLogWriter securityLogWriter,
+                          // LOG: 1 non-null source: GemFireDistributionLocator(same instance as logWriter), InternalDistributedSystem
+                          InetAddress bindAddress,
+                          String hostnameForClients,
+                          java.util.Properties distributedSystemProperties,
+                          DistributionConfigImpl cfg,
+                          boolean startDistributedSystem) {
-    }
-    else {
+    } else {
-    File productUseFile = new File("locator"+port+"views.log");
+    File productUseFile = new File("locator" + port + "views.log");
-    
+
-      env.setProperty(BIND_ADDRESS,
-          bindAddress.getHostAddress());
+      env.setProperty(BIND_ADDRESS, bindAddress.getHostAddress());
-    
+
-    
-    final boolean hasLogFileButConfigDoesNot = this.logFile != null && this.config.getLogFile().toString().equals(DistributionConfig.DEFAULT_LOG_FILE.toString());
+
+    final boolean hasLogFileButConfigDoesNot = this.logFile != null && this.config.getLogFile()
+                                                                                  .toString()
+                                                                                  .equals(DistributionConfig.DEFAULT_LOG_FILE.toString());
-      
+
-      
+
-        
+
-    }    
+    }
-    
+
-    
+
-    if(locatorListener != null) {
+    if (locatorListener != null) {
-  
+
-    server = new TcpServer(port, this.bindAddress, null, this.config,
-        this.handler, new DelayedPoolStatHelper(), group, this.toString());
+
+    SocketCreatorFactory.setDistributionConfig(this.config);
+    server = new TcpServer(port, this.bindAddress, null, this.config, this.handler, new DelayedPoolStatHelper(), group, this.toString());
-  public void resetInternalLocatorFileNamesWithCorrectPortNumber(int port){
+  public void resetInternalLocatorFileNamesWithCorrectPortNumber(int port) {
-    File productUseFile = new File("locator"+port+"views.log");
+    File productUseFile = new File("locator" + port + "views.log");
-  
+
-  
+
-  
+
-   * 
+   *
-    if(isPeerLocator()) {
+    if (isPeerLocator()) {
-    
+
-    
+
-    }
-    else {
+    } else {
-      locatorsAreCoordinators =  (prop != null && prop.length() > 0);
+      locatorsAreCoordinators = (prop != null && prop.length() > 0);
-    this.locatorImpl = MemberFactory.newLocatorHandler(this.bindAddress, this.stateFile,
-        locatorsProp, locatorsAreCoordinators, networkPartitionDetectionEnabled, stats);
+    this.locatorImpl = MemberFactory.newLocatorHandler(this.bindAddress, this.stateFile, locatorsProp, locatorsAreCoordinators, networkPartitionDetectionEnabled, stats);
-    if(!server.isAlive()) {
+    if (!server.isAlive()) {
-  
-  class SharedConfigurationRunnable implements Runnable{
-    
+
+  class SharedConfigurationRunnable implements Runnable {
+
-    
+
+
-   * 
-    
+
-    }
-    else {
+    } else {
-        }
-        else {
+        } else {
-      
-      if(peerLocator) {
-          // append this locator to the locators list from the config properties
-          //this.logger.config("ensuring that this locator is in the locators list");
-          boolean setLocatorsProp = false;
-          String locatorsProp = this.config.getLocators();
-          if (locatorsProp != null && locatorsProp.trim().length() > 0) {
-            if (!locatorsProp.contains(thisLocator)) {
-              locatorsProp = locatorsProp + "," + thisLocator;
-              setLocatorsProp = true;
-            }
-          }
-          else {
-            locatorsProp = thisLocator;
+
+      if (peerLocator) {
+        // append this locator to the locators list from the config properties
+        //this.logger.config("ensuring that this locator is in the locators list");
+        boolean setLocatorsProp = false;
+        String locatorsProp = this.config.getLocators();
+        if (locatorsProp != null && locatorsProp.trim().length() > 0) {
+          if (!locatorsProp.contains(thisLocator)) {
+            locatorsProp = locatorsProp + "," + thisLocator;
-          if (setLocatorsProp) {
-            Properties updateEnv = new Properties();
-            updateEnv.setProperty(LOCATORS, locatorsProp);
-            this.config.setApiProps(updateEnv);
-            // fix for bug 41248
-            String propName = DistributionConfig.GEMFIRE_PREFIX +
-                LOCATORS;
-            if (System.getProperty(propName) != null) {
-              System.setProperty(propName, locatorsProp);
-            }
+        } else {
+          locatorsProp = thisLocator;
+          setLocatorsProp = true;
+        }
+        if (setLocatorsProp) {
+          Properties updateEnv = new Properties();
+          updateEnv.setProperty(LOCATORS, locatorsProp);
+          this.config.setApiProps(updateEnv);
+          // fix for bug 41248
+          String propName = DistributionConfig.GEMFIRE_PREFIX + LOCATORS;
+          if (System.getProperty(propName) != null) {
+            System.setProperty(propName, locatorsProp);
-
-          // No longer default mcast-port to zero. See 46277.
-        
-        Properties connectEnv = new Properties();
-        // LogWriterAppender is now shared via that class
-        // using a DistributionConfig earlier in this method
-        connectEnv.put(DistributionConfig.DS_CONFIG_NAME, this.config);
+        // No longer default mcast-port to zero. See 46277.
+      }
-        logger.info(LocalizedMessage.create(LocalizedStrings.InternalLocator_STARTING_DISTRIBUTED_SYSTEM));
-        // LOG:CONFIG: changed from config to info
-        logger.info(LogMarker.CONFIG, LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_STARTUP_CONFIGURATIONN_0, this.config.toLoggerString()));
-        myDs = (InternalDistributedSystem)DistributedSystem.connect(connectEnv);
-        
-        if (peerLocator) {
-          this.locatorImpl.setMembershipManager(myDs.getDM().getMembershipManager());
+      Properties connectEnv = new Properties();
+      // LogWriterAppender is now shared via that class
+      // using a DistributionConfig earlier in this method
+      connectEnv.put(DistributionConfig.DS_CONFIG_NAME, this.config);
+
+      logger.info(LocalizedMessage.create(LocalizedStrings.InternalLocator_STARTING_DISTRIBUTED_SYSTEM));
+      // LOG:CONFIG: changed from config to info
+      logger.info(LogMarker.CONFIG, LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_STARTUP_CONFIGURATIONN_0, this.config.toLoggerString()));
+
+      myDs = (InternalDistributedSystem) DistributedSystem.connect(connectEnv);
+
+      if (peerLocator) {
+        this.locatorImpl.setMembershipManager(myDs.getDM().getMembershipManager());
+      }
+
+      myDs.addDisconnectListener(new DisconnectListener() {
+        @Override
+        public void onDisconnect(InternalDistributedSystem sys) {
+          stop(false, false, false);
-        
-        myDs.addDisconnectListener(new DisconnectListener() {
-          @Override
-          public void onDisconnect(InternalDistributedSystem sys) {
-            stop(false, false, false);
-          }
-        });
-        
-        startCache(myDs);
-        
-        logger.info(LocalizedMessage.create(LocalizedStrings.InternalLocator_LOCATOR_STARTED_ON__0, thisLocator));
-          
-        ((InternalDistributedSystem)myDs).setDependentLocator(this);
+      });
+
+      startCache(myDs);
+
+      logger.info(LocalizedMessage.create(LocalizedStrings.InternalLocator_LOCATOR_STARTED_ON__0, thisLocator));
+
+      ((InternalDistributedSystem) myDs).setDependentLocator(this);
-  
-  
+
+
-  
+
-      gfc = (GemFireCacheImpl)this.myCache;
+      gfc = (GemFireCacheImpl) this.myCache;
-      ((InternalDistributedSystem) ds).handleResourceEvent(
-          ResourceEvent.LOCATOR_START, this);
+      ((InternalDistributedSystem) ds).handleResourceEvent(ResourceEvent.LOCATOR_START, this);
-    
+
-  
+
-   * 
-   * @param distributedSystem
-   *                The distributed system to use for the statistics.
-   *                
-   * @since GemFire 5.7
-   * 
+   * @param distributedSystem The distributed system to use for the statistics.
+   *
+   * @since GemFire 5.7
-    if(distributedSystem != null) {
+    if (distributedSystem != null) {
-    
+
-    if(this.locatorDiscoverer != null) {
+    if (this.locatorDiscoverer != null) {
-  
+
-   * 
-   * @param distributedSystem
-   *                The distributed system which the server location services
-   *                should use. If null, the method will try to find an already
-   *                connected distributed system.
+   * @param distributedSystem The distributed system which the server location services
+   * should use. If null, the method will try to find an already
+   * connected distributed system.
+   *
-  public void startServerLocation(InternalDistributedSystem distributedSystem)
-    throws IOException
-  {
-    if(isServerLocator()) {
+  public void startServerLocation(InternalDistributedSystem distributedSystem) throws IOException {
+    if (isServerLocator()) {
-    
+
-    
-    ServerLocator sl = new ServerLocator(getPort(),
-                                         this.bindAddress,
-                                         this.hostnameForClients,
-                                         this.logFile,
-                                         this.productUseLog,
-                                         getConfig().getName(),
-                                         distributedSystem,
-                                         stats);
+
+    ServerLocator sl = new ServerLocator(getPort(), this.bindAddress, this.hostnameForClients, this.logFile, this.productUseLog, getConfig().getName(), distributedSystem, stats);
-    if(!server.isAlive()) {
+    if (!server.isAlive()) {
-  
+
+//    SocketCreatorFactory.close();
-  
+
-  
+
-    
+
-    
+
-          try { Thread.sleep(500); } catch (InterruptedException e) {
+          try {
+            Thread.sleep(500);
+          } catch (InterruptedException e) {
-      } catch ( ConnectException ignore ) {
+      } catch (ConnectException ignore) {
-  
+
-        
+
-      }
-      finally {
+      } finally {
-  
+
-    
+
-  
-  
-  /** answers whether this locator is currently stopped */
+
+
+  /**
+   * answers whether this locator is currently stopped
+   */
-    return this.server == null  ||  !this.server.isAlive();
+    return this.server == null || !this.server.isAlive();
-  
+
-      ((InternalDistributedSystem)myDs).setDependentLocator(null);
+      ((InternalDistributedSystem) myDs).setDependentLocator(null);
-    
-    if(stats != null) {
+
+    if (stats != null) {
-    
-    if(this.locatorListener != null){
+
+    if (this.locatorListener != null) {
-    
+
-   * 
-  
-  /** launch a thread that will restart location services */
+
+  /**
+   * launch a thread that will restart location services
+   */
-          if (! restarted) {
+          if (!restarted) {
+
-      long waitTime = ds.getConfig().getMaxWaitTimeForReconnect()/2;
+      long waitTime = ds.getConfig().getMaxWaitTimeForReconnect() / 2;
-      while (ds.getReconnectedSystem() == null &&
-          !ds.isReconnectCancelled()) {
+      while (ds.getReconnectedSystem() == null && !ds.isReconnectCancelled()) {
-          boolean start = checker.checkForQuorum(3*this.myDs.getConfig().getMemberTimeout());
+          boolean start = checker.checkForQuorum(3 * this.myDs.getConfig().getMemberTimeout());
-            if(this.locatorListener != null){
+            if (this.locatorListener != null) {
-      InternalDistributedSystem newSystem = (InternalDistributedSystem)ds.getReconnectedSystem();
-//      LogWriter log = new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out);
+      InternalDistributedSystem newSystem = (InternalDistributedSystem) ds.getReconnectedSystem();
+      //      LogWriter log = new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out);
-//        log.fine("reconnecting locator: starting location services");
+        //        log.fine("reconnecting locator: starting location services");
-          if(this.locatorListener != null){
+          if (this.locatorListener != null) {
-    logger.info("restart thread exiting.  Service was "+(restarted? "" : "not ") + "restarted");
+    logger.info("restart thread exiting.  Service was " + (restarted ? "" : "not ") + "restarted");
-  
-  
+
+
-  
+
-      ((InternalDistributedSystem)myDs).setDependentLocator(this);
+      ((InternalDistributedSystem) myDs).setDependentLocator(this);
-      endStartLocator((InternalDistributedSystem)myDs);
+      endStartLocator((InternalDistributedSystem) myDs);
-  
-  
+
+
-  
+
-  
+
-   *
-  
+
-   * 
+   *
+
+
-      
+
-      for (int i=0; i<MAX_RETRIES; i++) {
+      for (int i = 0; i < MAX_RETRIES; i++) {
-  
-  
+
+
-    ExecutorService es = ((GemFireCacheImpl)myCache).getDistributionManager().getWaitingThreadPool();
+    ExecutorService es = ((GemFireCacheImpl) myCache).getDistributionManager().getWaitingThreadPool();
-      response =  new SharedConfigurationStatusResponse();
+      response = new SharedConfigurationStatusResponse();
-    } 
+    }
-  
-  
+
+
+
-    
-    public PrimaryHandler(InternalLocator locator,
-        LocatorMembershipListener listener) {
+
+    public PrimaryHandler(InternalLocator locator, LocatorMembershipListener listener) {
-      for(Iterator itr = allHandlers.iterator(); itr.hasNext();) {
+      for (Iterator itr = allHandlers.iterator(); itr.hasNext(); ) {
-        for (TcpHandler handler: this.allHandlers) {
+        for (TcpHandler handler : this.allHandlers) {
-        handler = (TcpHandler)handlerMapping.get(PeerLocatorRequest.class);
+        handler = (TcpHandler) handlerMapping.get(PeerLocatorRequest.class);
+      } else {
+        handler = (TcpHandler) handlerMapping.get(request.getClass());
-      else {
-        handler = (TcpHandler)handlerMapping.get(request.getClass());
-      }
-      
+
-      }
-      else {  
+      } else {
-        if(locatorListener != null){
+        if (locatorListener != null) {
-        }
-        else {
+        } else {
-            logger
-                .warn(LocalizedMessage
-                    .create(
-                        LocalizedStrings.InternalLocator_EXPECTED_ONE_OF_THESE_0_BUT_RECEIVED_1,
-                        new Object[] { handlerMapping.keySet(), request }));
+            logger.warn(LocalizedMessage.create(LocalizedStrings.InternalLocator_EXPECTED_ONE_OF_THESE_0_BUT_RECEIVED_1, new Object[] {
+              handlerMapping.keySet(), request
+            }));
-    
+
-      for(Iterator itr = allHandlers.iterator(); itr.hasNext(); ) {
-        TcpHandler handler = (TcpHandler) itr.next();
-        handler.shutDown();
-      }
+        for (Iterator itr = allHandlers.iterator(); itr.hasNext(); ) {
+          TcpHandler handler = (TcpHandler) itr.next();
+          handler.shutDown();
+        }
-    
+
-    
+
-      if(tmpAllHandlers.add(handler) && tcpServer != null ) {
+      if (tmpAllHandlers.add(handler) && tcpServer != null) {
-    
-    public void endRequest(Object request,long startTime) {
+
+    public void endRequest(Object request, long startTime) {
-      if(handler != null) {
+      if (handler != null) {
-    
-    public void endResponse(Object request,long startTime) {
+
+    public void endResponse(Object request, long startTime) {
-      if(handler != null) {
+      if (handler != null) {
-  
+
-      stats.hookupStats(sys,  SocketCreator.getLocalHost().getCanonicalHostName() + "-" + server.getBindAddress().toString());
-    } catch(UnknownHostException uhe) {
+      stats.hookupStats(sys, SocketCreator.getLocalHost().getCanonicalHostName() + "-" + server.getBindAddress().toString());
+    } catch (UnknownHostException uhe) {
-   * 
-      Collection<DistributionLocatorId> locatorIds = 
-          DistributionLocatorId.asDistributionLocatorIds(getLocators());
+      Collection<DistributionLocatorId> locatorIds = DistributionLocatorId.asDistributionLocatorIds(getLocators());
-  
+
-   * 
-    
+
-      
+
+
-  
-  public void startSharedConfigurationService(GemFireCacheImpl gfc){
-    
-    
+
+  public void startSharedConfigurationService(GemFireCacheImpl gfc) {
+
+
-      } 
-      
+      }
+
-  
+
-  
+
-  
+

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 UPD40 UPD40 MOV65 INS66 UPD66 INS66 INS66 UPD66 INS21 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS8 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS8 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS32 UPD66 UPD66 UPD66 UPD66 MOV41 INS54 MOV41 INS42 INS42 INS22 INS8 INS12 INS52 INS42 MOV25 MOV25 INS44 INS8 INS43 INS42 INS21 INS42 INS32 INS42 INS42 DEL66 DEL66 DEL66
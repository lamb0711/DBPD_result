GEODE-2632: cleanup GemFireCacheImpl

* change SecurityService from static constant to final member field
* fix typos and javadocs
* narrow scope of constants, variables, methods
* remove deadcode and useless comments/javadocs
* fix misc IntelliJ warnings
* add @Override annotations
* improve some variable names
* fix (some) generics and types
* add TODOs for a couple problem areas that need further fixing

-
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.Closeable;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.PrintStream;
+import java.io.Reader;
+import java.io.StringBufferInputStream;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.net.InetSocketAddress;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Properties;
+import java.util.ServiceLoader;
+import java.util.Set;
+import java.util.SortedMap;
+import java.util.TreeMap;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.regex.Pattern;
+
+import javax.naming.Context;
+import javax.transaction.TransactionManager;
+
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.distributed.internal.ClusterConfigurationService;
-import org.apache.geode.distributed.internal.ClusterConfigurationService;
-import org.apache.geode.internal.cache.persistence.query.TemporaryResultSetFactory;
-import org.apache.logging.log4j.Logger;
-
-import java.io.BufferedReader;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.PrintStream;
-import java.io.Reader;
-import java.io.StringBufferInputStream;
-import java.io.StringWriter;
-import java.io.Writer;
-import java.net.InetSocketAddress;
-import java.net.URL;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Properties;
-import java.util.ServiceLoader;
-import java.util.Set;
-import java.util.TreeMap;
-import java.util.concurrent.ArrayBlockingQueue;
-import java.util.concurrent.CancellationException;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.concurrent.CopyOnWriteArraySet;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executor;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.naming.Context;
- * GemFire's implementation of a distributed {@link org.apache.geode.cache.Cache}.
+ * GemFire's implementation of a distributed {@link Cache}.
-  // moved *SERIAL_NUMBER stuff to DistributionAdvisor
-
-  public static final int DEFAULT_LOCK_TIMEOUT = Integer
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.defaultLockTimeout", 60).intValue();
+  public static final int DEFAULT_LOCK_TIMEOUT =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.defaultLockTimeout", 60);
-  public static final int DEFAULT_LOCK_LEASE = Integer
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.defaultLockLease", 120).intValue();
+  public static final int DEFAULT_LOCK_LEASE =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.defaultLockLease", 120);
+
-   * The default amount of time to wait for a <code>netSearch</code> to complete
+   * The default amount of time to wait for a {@code netSearch} to complete
-  public static final int DEFAULT_SEARCH_TIMEOUT = Integer
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.defaultSearchTimeout", 300).intValue();
+  public static final int DEFAULT_SEARCH_TIMEOUT =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.defaultSearchTimeout", 300);
-   * The <code>CacheLifecycleListener</code> s that have been registered in this VM
+   * The {@code CacheLifecycleListener} s that have been registered in this VM
-  private static final Set<CacheLifecycleListener> cacheLifecycleListeners =
-      new HashSet<CacheLifecycleListener>();
+  private static final Set<CacheLifecycleListener> cacheLifecycleListeners = new HashSet<>();
-   * @since GemFire hitachi 6.1.2.9
+   * @since GemFire h****** 6.1.2.9
-  public static boolean DELTAS_RECALCULATE_SIZE =
+  static boolean DELTAS_RECALCULATE_SIZE =
-  public static final int EVENT_QUEUE_LIMIT = Integer
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.EVENT_QUEUE_LIMIT", 4096).intValue();
-  public static final int EVENT_THREAD_LIMIT = Integer
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.EVENT_THREAD_LIMIT", 16).intValue();
+  private static final int EVENT_QUEUE_LIMIT =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.EVENT_QUEUE_LIMIT", 4096);
+
+  static final int EVENT_THREAD_LIMIT =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.EVENT_THREAD_LIMIT", 16);
-   * is set in MiliSecs.
+   * is set in milliseconds.
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.MAX_QUERY_EXECUTION_TIME", -1)
-          .intValue();
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.MAX_QUERY_EXECUTION_TIME", -1);
-  public final boolean QUERY_MONITOR_DISABLED_FOR_LOW_MEM = Boolean
+  private final boolean queryMonitorDisabledForLowMem = Boolean
-  public static Boolean QUERY_MONITOR_REQUIRED_FOR_RESOURCE_MANAGER = Boolean.FALSE;
+  private static boolean queryMonitorRequiredForResourceManager = false;
-  /**
-   * This property defines internal function that will get executed on each node to fetch active
-   * REST service endpoints (servers).
-   */
-  public static final String FIND_REST_ENABLED_SERVERS_FUNCTION_ID =
-      FindRestEnabledServersFunction.class.getName();
-
-  /**
-   * True if the user is allowed lock when memory resources appear to be overcommitted.
-   */
-  public static final boolean ALLOW_MEMORY_LOCK_WHEN_OVERCOMMITTED =
-      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "Cache.ALLOW_MEMORY_OVERCOMMIT");
-
-  // time in ms
+  /** time in milliseconds */
-  /** To test MAX_QUERY_EXECUTION_TIME option. */
-  public int TEST_MAX_QUERY_EXECUTION_TIME = -1;
-  public boolean TEST_MAX_QUERY_EXECUTION_TIME_OVERRIDE_EXCEPTION = false;
-  // ///////////////////// Instance Fields ///////////////////////
+  private static final Pattern DOUBLE_BACKSLASH = Pattern.compile("\\\\");
+
+  /** To test MAX_QUERY_EXECUTION_TIME option. */
+  public int testMaxQueryExecutionTime = -1;
-  // This is a HashMap because I know that clear() on it does
-  // not allocate objects.
-  private final HashMap rootRegions;
+  private final Map<String, LocalRegion> rootRegions;
-  private PoolFactory clientpf;
+
+  private PoolFactory poolFactory;
+
-  private final ConcurrentMap pathToRegion = new ConcurrentHashMap();
+  private final ConcurrentMap<String, Region<?, ?>> pathToRegion = new ConcurrentHashMap<>();
-  protected volatile boolean isInitialized = false;
-  protected volatile boolean isClosing = false;
-  protected volatile boolean closingGatewaySendersByShutdownAll = false;
-  protected volatile boolean closingGatewayReceiversByShutdownAll = false;
+  private volatile boolean isInitialized;
+
+  volatile boolean isClosing = false; // used in Stopper inner class
-  /** Amount of time to wait for a <code>netSearch</code> to complete */
+  /** Amount of time to wait for a {@code netSearch} to complete */
-  private volatile List allCacheServers = new CopyOnWriteArrayList();
+  private final List<CacheServerImpl> allCacheServers = new CopyOnWriteArrayList<>();
-  public final Object allGatewaySendersLock = new Object();
+  private final Object allGatewaySendersLock = new Object();
-  private volatile Set<AsyncEventQueue> allVisibleAsyncEventQueues =
-      new CopyOnWriteArraySet<AsyncEventQueue>();
+  private final Set<AsyncEventQueue> allVisibleAsyncEventQueues = new CopyOnWriteArraySet<>();
-  private volatile Set<AsyncEventQueue> allAsyncEventQueues =
-      new CopyOnWriteArraySet<AsyncEventQueue>();
+  private final Set<AsyncEventQueue> allAsyncEventQueues = new CopyOnWriteArraySet<>();
-  public final Object allGatewayReceiversLock = new Object();
+  private final Object allGatewayReceiversLock = new Object();
-  /** PartitionedRegion instances (for required-events notification */
-  // This is a HashSet because I know that clear() on it does not
-  // allocate any objects.
-  private final HashSet<PartitionedRegion> partitionedRegions = new HashSet<PartitionedRegion>();
+  /**
+   * PartitionedRegion instances (for required-events notification
+   */
+  private final Set<PartitionedRegion> partitionedRegions = new HashSet<>();
-      new ConcurrentHashMap<String, DistributedRegion>();
+      new ConcurrentHashMap<>();
-  public final Object allGatewayHubsLock = new Object();
+  private final Object allGatewayHubsLock = new Object();
-   * @guarded.By {@link #allGatewayHubsLock}
+   * GuardedBy {@link #allGatewayHubsLock}
-  private final TXManagerImpl txMgr;
+  private final TXManagerImpl transactionManager;
-  private final Map namedRegionAttributes = Collections.synchronizedMap(new HashMap());
+  private final Map<String, RegionAttributes<?, ?>> namedRegionAttributes =
+      Collections.synchronizedMap(new HashMap<>());
-  protected volatile Throwable disconnectCause = null;
+  volatile Throwable disconnectCause; // used in Stopper inner class
-  public Exception creationStack = null;
+  private Exception creationStack = null;
-  private EventTracker.ExpiryTask recordedEventSweeper;
+  private final EventTracker.ExpiryTask recordedEventSweeper;
-  private TombstoneService tombstoneService;
+  private final TombstoneService tombstoneService;
-   * @guarded.By prLockServiceLock
+   * GuardedBy prLockServiceLock
-   * @guarded.By gatewayLockServiceLock
+   * GuardedBy gatewayLockServiceLock
-  private final AtomicReference<BackupManager> backupManager = new AtomicReference<BackupManager>();
+  private final AtomicReference<BackupManager> backupManager = new AtomicReference<>();
-  private ResourceEventsListener listener;
+  private ResourceEventsListener resourceEventsListener;
-  private ClientMetadataService clientMetadatService = null;
+  private ClientMetadataService clientMetadataService = null;
-  // Stores the properties used to initialize declarables.
-  private final Map<Declarable, Properties> declarablePropertiesMap =
-      new ConcurrentHashMap<Declarable, Properties>();
+  /**
+   * Stores the properties used to initialize declarables.
+   */
+  private final Map<Declarable, Properties> declarablePropertiesMap = new ConcurrentHashMap<>();
-  protected static PropertyResolver resolver;
+  private final PropertyResolver resolver;
-  protected static boolean xmlParameterizationEnabled =
+  private static final boolean XML_PARAMETERIZATION_ENABLED =
-  public static Runnable internalBeforeApplyChanges;
-
-  public static Runnable internalBeforeNonTXBasicPut;
-
-  private SimpleExtensionPoint<Cache> extensionPoint = new SimpleExtensionPoint<Cache>(this, this);
+  private final SimpleExtensionPoint<Cache> extensionPoint = new SimpleExtensionPoint<>(this, this);
-  private final Set<RegionListener> regionListeners = new ConcurrentHashSet<RegionListener>();
+  private final Set<RegionListener> regionListeners = new ConcurrentHashSet<>();
-  private final Map<Class<? extends CacheService>, CacheService> services =
-      new HashMap<Class<? extends CacheService>, CacheService>();
+  private final Map<Class<? extends CacheService>, CacheService> services = new HashMap<>();
-  private final static Boolean DISABLE_AUTO_EVICTION =
-      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "disableAutoEviction");
-
-  private static SecurityService securityService = SecurityService.getSecurityService();
+  private final SecurityService securityService = SecurityService.getSecurityService();
-   * 
-    int result = 0;
-      result = mlockall(1);
+      int result = mlockall(1);
-    int errno = Native.getLastError();
-    String msg = "mlockall failed: " + errno;
-    if (errno == 1 || errno == 12) { // EPERM || ENOMEM
-      msg = "Unable to lock memory due to insufficient free space or privileges.  "
+    int lastError = Native.getLastError();
+    String message = "mlockall failed: " + lastError;
+    if (lastError == 1 || lastError == 12) { // EPERM || ENOMEM
+      message = "Unable to lock memory due to insufficient free space or privileges.  "
-    throw new IllegalStateException(msg);
+    throw new IllegalStateException(message);
-   * This is for debugging cache-open issues (esp.
-   * {@link org.apache.geode.cache.CacheExistsException})
+   * This is for debugging cache-open issues (esp. {@link CacheExistsException})
-    final StringBuffer sb = new StringBuffer();
+    final StringBuilder sb = new StringBuilder();
-    sb.append("id = " + System.identityHashCode(this));
-    sb.append("; isClosing = " + this.isClosing);
-    sb.append("; isShutDownAll = " + isCacheAtShutdownAll());
-    sb.append("; created = " + this.creationDate);
-    sb.append("; server = " + this.isServer);
-    sb.append("; copyOnRead = " + this.copyOnRead);
-    sb.append("; lockLease = " + this.lockLease);
-    sb.append("; lockTimeout = " + this.lockTimeout);
+    sb.append("id = ").append(System.identityHashCode(this));
+    sb.append("; isClosing = ").append(this.isClosing);
+    sb.append("; isShutDownAll = ").append(isCacheAtShutdownAll());
+    sb.append("; created = ").append(this.creationDate);
+    sb.append("; server = ").append(this.isServer);
+    sb.append("; copyOnRead = ").append(this.copyOnRead);
+    sb.append("; lockLease = ").append(this.lockLease);
+    sb.append("; lockTimeout = ").append(this.lockTimeout);
-      sb.append("\nCreation context:\n");
+      sb.append(System.lineSeparator()).append("Creation context:").append(System.lineSeparator());
-  /*
+  /**
-  public static final GemFireCacheImpl getExisting() {
+  public static GemFireCacheImpl getExisting() {
-  // /**
-  // * @deprecated remove when Lise allows a Hydra VM to
-  // * be re-created
-  // */
-  // public static void clearInstance() {
-  // System.err.println("DEBUG: do not commit GemFireCache#clearInstance");
-  // instance = null;
-  // }
-
-  public static GemFireCacheImpl createWithAsyncEventListeners(DistributedSystem system,
+  static GemFireCacheImpl createWithAsyncEventListeners(DistributedSystem system,
-
-
-      logger.error(e.getLocalizedMessage());
+      logger.error(e.getLocalizedMessage()); // TODO: log the full stack trace or not?
-   * Creates a new instance of GemFireCache and populates it according to the
-   * <code>cache.xml</code>, if appropriate.
+   * Creates a new instance of GemFireCache and populates it according to the {@code cache.xml}, if
+   * appropriate.
-    this.clientpf = pf;
+    this.poolFactory = pf;
-        this.listener = new ManagementListener();
-        this.system.addResourceListener(listener);
+        this.resourceEventsListener = new ManagementListener();
+        this.system.addResourceListener(this.resourceEventsListener);
-        getLogger().info("Running in client mode");
-        this.listener = null;
+        logger.info("Running in client mode");
+        this.resourceEventsListener = null;
-      DM dm = this.system.getDistributionManager();
-      if (dm instanceof DistributionManager) {
-        if (((DistributionManager) dm).getDMType() == DistributionManager.ADMIN_ONLY_DM_TYPE) {
-          throw new IllegalStateException(
-              LocalizedStrings.GemFireCache_CANNOT_CREATE_A_CACHE_IN_AN_ADMINONLY_VM
-                  .toLocalizedString());
-        }
+      if (this.dm.getDMType() == DistributionManager.ADMIN_ONLY_DM_TYPE) {
+        throw new IllegalStateException(
+            LocalizedStrings.GemFireCache_CANNOT_CREATE_A_CACHE_IN_AN_ADMINONLY_VM
+                .toLocalizedString());
-      this.rootRegions = new HashMap();
+      this.rootRegions = new HashMap<>();
-      this.txMgr = new TXManagerImpl(this.cachePerfStats, this);
-      dm.addMembershipListener(this.txMgr);
+      this.transactionManager = new TXManagerImpl(this.cachePerfStats, this);
+      this.dm.addMembershipListener(this.transactionManager);
-        final ThreadGroup group =
+        final ThreadGroup threadGroup =
-        ThreadFactory tf = new ThreadFactory() {
-          @Override
-          public Thread newThread(final Runnable command) {
-            final Runnable r = new Runnable() {
-              @Override
-              public void run() {
-                ConnectionTable.threadWantsSharedResources();
-                command.run();
-              }
-            };
-            Thread thread = new Thread(group, r, "Message Event Thread");
-            thread.setDaemon(true);
-            return thread;
-          }
+        ThreadFactory threadFactory = (Runnable command) -> {
+          final Runnable runnable = () -> {
+            ConnectionTable.threadWantsSharedResources();
+            command.run();
+          };
+          Thread thread = new Thread(threadGroup, runnable, "Message Event Thread");
+          thread.setDaemon(true);
+          return thread;
-        ArrayBlockingQueue q = new ArrayBlockingQueue(EVENT_QUEUE_LIMIT);
-        this.eventThreadPool = new PooledExecutorWithDMStats(q, EVENT_THREAD_LIMIT,
-            this.cachePerfStats.getEventPoolHelper(), tf, 1000);
+        ArrayBlockingQueue<Runnable> queue = new ArrayBlockingQueue<>(EVENT_QUEUE_LIMIT);
+        this.eventThreadPool = new PooledExecutorWithDMStats(queue, EVENT_THREAD_LIMIT,
+            this.cachePerfStats.getEventPoolHelper(), threadFactory, 1000);
+
-      resourceManager = InternalResourceManager.createResourceManager(this);
+      this.resourceManager = InternalResourceManager.createResourceManager(this);
-      recordedEventSweeper = EventTracker.startTrackerServices(this);
-      tombstoneService = TombstoneService.initialize(this);
+      this.recordedEventSweeper = EventTracker.startTrackerServices(this);
+      this.tombstoneService = TombstoneService.initialize(this);
-        // Initialize the QRM thread freqeuncy to default (1 second )to prevent spill
+        // Initialize the QRM thread frequency to default (1 second )to prevent spill
-      if (xmlParameterizationEnabled) {
-        /** If product properties file is available replace properties from there */
+      if (XML_PARAMETERIZATION_ENABLED) {
+        // If product properties file is available replace properties from there
-          resolver = new CacheXmlPropertyResolver(false,
+          this.resolver = new CacheXmlPropertyResolver(false,
-          resolver = new CacheXmlPropertyResolver(false,
+          this.resolver = new CacheXmlPropertyResolver(false,
+      } else {
+        this.resolver = null;
-      diskMonitor = new DiskStoreMonitor();
+      this.diskMonitor = new DiskStoreMonitor();
-    return isRESTServiceRunning;
+    return this.isRESTServiceRunning;
-    return restAgent;
+    return this.restAgent;
-  /*****
+  /**
-  public ConfigurationResponse requestSharedConfiguration() {
+  private ConfigurationResponse requestSharedConfiguration() {
-    if (!(dm instanceof DistributionManager))
+    if (!(this.dm instanceof DistributionManager)) {
+    }
-    if (((DistributionManager) dm).getDMType() == DistributionManager.LOCATOR_DM_TYPE || isClient
-        || Locator.getLocator() != null)
+    if (this.dm.getDMType() == DistributionManager.LOCATOR_DM_TYPE || this.isClient
+        || Locator.getLocator() != null) {
+    }
-        this.getDistributionManager().getAllHostedLocatorsWithSharedConfiguration();
+        getDistributionManager().getAllHostedLocatorsWithSharedConfiguration();
-
-    ConfigurationResponse response = null;
-      response = ClusterConfigurationLoader.requestConfigurationFromLocators(system.getConfig(),
-          locatorConnectionStrings);
+      ConfigurationResponse response = ClusterConfigurationLoader
+          .requestConfigurationFromLocators(this.system.getConfig(), locatorConnectionStrings);
-          (clusterConfig == null) ? new Properties() : clusterConfig.getGemfireProperties();
+          clusterConfig == null ? new Properties() : clusterConfig.getGemfireProperties();
-  public void deployJarsRecevedFromClusterConfiguration(ConfigurationResponse response) {
+  private void deployJarsReceivedFromClusterConfiguration(ConfigurationResponse response) {
-    } catch (IOException e) {
-      throw new GemFireConfigException(
-          LocalizedStrings.GemFireCache_EXCEPTION_OCCURED_WHILE_DEPLOYING_JARS_FROM_SHARED_CONDFIGURATION
-              .toLocalizedString(),
-          e);
-    } catch (ClassNotFoundException e) {
+    } catch (IOException | ClassNotFoundException e) {
-
-  // When called, clusterProps and serverProps and key could not be null
-  public static boolean isMisConfigured(Properties clusterProps, Properties serverProps,
-      String key) {
+  /**
+   * When called, clusterProps and serverProps and key could not be null
+   */
+  static boolean isMisConfigured(Properties clusterProps, Properties serverProps, String key) {
-    // at this point check for eqality
+    // at this point check for equality
-  public List<String> getSharedConfigLocatorConnectionStringList() {
-    List<String> locatorConnectionStringList = new ArrayList<String>();
+  private List<String> getSharedConfigLocatorConnectionStringList() {
+    List<String> locatorConnectionStringList = new ArrayList<>();
-    Map<InternalDistributedMember, Collection<String>> scl =
-        this.getDistributionManager().getAllHostedLocatorsWithSharedConfiguration();
+    Map<InternalDistributedMember, Collection<String>> locatorsWithClusterConfig =
+        getDistributionManager().getAllHostedLocatorsWithSharedConfiguration();
-    if (!scl.isEmpty()) {
-      Set<Entry<InternalDistributedMember, Collection<String>>> locs = scl.entrySet();
+    if (!locatorsWithClusterConfig.isEmpty()) {
+      Set<Entry<InternalDistributedMember, Collection<String>>> locators =
+          locatorsWithClusterConfig.entrySet();
-      for (Entry<InternalDistributedMember, Collection<String>> loc : locs) {
+      for (Entry<InternalDistributedMember, Collection<String>> loc : locators) {
-        Iterator<String> locStringIter = locStrings.iterator();
-
-        while (locStringIter.hasNext()) {
-          locatorConnectionStringList.add(locStringIter.next());
-        }
+        locatorConnectionStringList.addAll(locStrings);
-
-
-  private Collection<Pool> getAllPools() {
+  private static Collection<Pool> getAllPools() {
-  private void setDefaultPool(Pool v) {
-    this.defaultPool = v;
+  private void setDefaultPool(Pool value) {
+    this.defaultPool = value;
-    for (Iterator<CacheLifecycleListener> iter = cacheLifecycleListeners.iterator(); iter
-        .hasNext();) {
-      CacheLifecycleListener listener = (CacheLifecycleListener) iter.next();
+    for (CacheLifecycleListener listener : cacheLifecycleListeners) {
-    deployJarsRecevedFromClusterConfiguration(configurationResponse);
+    deployJarsReceivedFromClusterConfiguration(configurationResponse);
-        system.getConfig());
+        this.system.getConfig());
-    securityService.initSecurity(system.getConfig().getSecurityProps());
+    this.securityService.initSecurity(this.system.getConfig().getSecurityProps());
-    if (cacheConfig.getSecurityManager() != null) {
-      securityService.setSecurityManager(cacheConfig.getSecurityManager());
+    if (this.cacheConfig.getSecurityManager() != null) {
+      this.securityService.setSecurityManager(this.cacheConfig.getSecurityManager());
-    if (cacheConfig.getPostProcessor() != null) {
-      securityService.setPostProcessor(cacheConfig.getPostProcessor());
+    if (this.cacheConfig.getPostProcessor() != null) {
+      this.securityService.setPostProcessor(this.cacheConfig.getPostProcessor());
-
-    /** Entry to GemFire Management service **/
-    this.jmxAdvisor.initializationGate();
+    this.jmxAdvisor.initializationGate(); // Entry to GemFire Management service
-    system.handleResourceEvent(ResourceEvent.CACHE_CREATE, this);
-
-    boolean completedCacheXml = false;
+    this.system.handleResourceEvent(ResourceEvent.CACHE_CREATE, this);
+    boolean completedCacheXml = false;
-          system.getConfig());
+          this.system.getConfig());
-    this.clientpf = null;
+    this.poolFactory = null;
-    isInitialized = true;
+    this.isInitialized = true;
-      system.handleResourceEvent(ResourceEvent.CACHE_SERVICE_CREATE, service);
+      this.system.handleResourceEvent(ResourceEvent.CACHE_SERVICE_CREATE, service);
-    return (this.system.getConfig().getJmxManagerStart() != true);
+    return !this.system.getConfig().getJmxManagerStart();
-    return (this.system.getDistributedMember().getVmKind() != DistributionManager.LOCATOR_DM_TYPE
+    return this.system.getDistributedMember().getVmKind() != DistributionManager.LOCATOR_DM_TYPE
-        && !isClient());
+        && !isClient();
-      restAgent.start(cache);
+      this.restAgent.start(cache);
-    int port = system.getConfig().getMemcachedPort();
+    int port = this.system.getConfig().getMemcachedPort();
-      String protocol = system.getConfig().getMemcachedProtocol();
+      String protocol = this.system.getConfig().getMemcachedProtocol();
-      String bindAddress = system.getConfig().getMemcachedBindAddress();
+      String bindAddress = this.system.getConfig().getMemcachedBindAddress();
-    int port = system.getConfig().getRedisPort();
+    int port = this.system.getConfig().getRedisPort();
-      String bindAddress = system.getConfig().getRedisBindAddress();
+      String bindAddress = this.system.getConfig().getRedisBindAddress();
-
-    if ("".equals(xmlFile.getName())) {
+    if (xmlFile.getName().isEmpty()) {
-    URL url = null;
+    URL url;
-      resource = resource.replaceAll("\\\\", "/");
+      resource = DOUBLE_BACKSLASH.matcher(resource).replaceAll("/");
-      } catch (IOException ex) {
+      } catch (MalformedURLException ex) {
-        } else /* if (!xmlFile.isFile()) */ {
+        } else {
-   * Initializes the contents of this <code>Cache</code> according to the declarative caching XML
-   * file specified by the given <code>DistributedSystem</code>. Note that this operation cannot be
-   * performed in the constructor because creating regions in the cache, etc. uses the cache itself
-   * (which isn't initialized until the constructor returns).
+   * Initializes the contents of this {@code Cache} according to the declarative caching XML file
+   * specified by the given {@code DistributedSystem}. Note that this operation cannot be performed
+   * in the constructor because creating regions in the cache, etc. uses the cache itself (which
+   * isn't initialized until the constructor returns).
-   * @throws TimeoutException If a {@link org.apache.geode.cache.Region#put(Object, Object)}times
-   *         out while initializing the cache.
-   * @throws CacheWriterException If a <code>CacheWriterException</code> is thrown while
-   *         initializing the cache.
-   * @throws RegionExistsException If the declarative caching XML file desribes a region that
-   *         already exists (including the root region).
-   * @throws GatewayException If a <code>GatewayException</code> is thrown while initializing the
+   * @throws TimeoutException If a {@link Region#put(Object, Object)}times out while initializing
+   *         the cache.
+   * @throws CacheWriterException If a {@code CacheWriterException} is thrown while initializing the
+   * @throws RegionExistsException If the declarative caching XML file describes a region that
+   *         already exists (including the root region).
+   * @throws GatewayException If a {@code GatewayException} is thrown while initializing the cache.
+    InputStream stream = null;
-      InputStream stream = null;
-      try {
-        stream.close();
-      } catch (IOException ignore) {
-      }
+
-              .toLocalizedString(new Object[] {url.toString(), ex}));
+              .toLocalizedString(url.toString(), ex));
-              .toLocalizedString(new Object[] {url, ex.getMessage()}));
+              .toLocalizedString(url, ex.getMessage()));
+      /*
+       * TODO: why use setStackTrace and initCause? removal breaks several tests: OplogRVVJUnitTest,
+       * NewDeclarativeIndexCreationJUnitTest CacheXml70DUnitTest, CacheXml80DUnitTest,
+       * CacheXml81DUnitTest, CacheXmlGeode10DUnitTest RegionManagementDUnitTest
+       */
+
+    } finally {
+      closeQuietly(stream);
-  private void logCacheXML(URL url, String cacheXmlDescription) {
+  private static void logCacheXML(URL url, String cacheXmlDescription) {
+      BufferedReader br = null;
-        final String EOLN = System.getProperty("line.separator");
-        BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));
-        String l = br.readLine();
-        while (l != null) {
-          if (!l.isEmpty()) {
-            sb.append(EOLN).append(l);
+        final String lineSeparator = System.getProperty("line.separator");
+        br = new BufferedReader(new InputStreamReader(url.openStream()));
+        String line = br.readLine();
+        while (line != null) {
+          if (!line.isEmpty()) {
+            sb.append(lineSeparator).append(line);
-          l = br.readLine();
+          line = br.readLine();
-        br.close();
+      } finally {
+        closeQuietly(br);
-   * create diskstore factory with default attributes
+   * create diskStore factory with default attributes
-   * create diskstore factory with predefined attributes
+   * create diskStore factory with predefined attributes
-  protected class Stopper extends CancelCriterion {
+  class Stopper extends CancelCriterion {
-    /*
-     * (non-Javadoc)
-     *
-     * @see org.apache.geode.CancelCriterion#cancelInProgress()
-     */
-      String reason =
-          GemFireCacheImpl.this.getDistributedSystem().getCancelCriterion().cancelInProgress();
+      String reason = getDistributedSystem().getCancelCriterion().cancelInProgress();
-        return disconnectCause.getMessage();
+        return GemFireCacheImpl.this.disconnectCause.getMessage();
-    /*
-     * (non-Javadoc)
-     *
-     * @see org.apache.geode.CancelCriterion#generateCancelledException(java.lang.Throwable)
-     */
-    public RuntimeException generateCancelledException(Throwable e) {
+    public RuntimeException generateCancelledException(Throwable throwable) {
-          getDistributedSystem().getCancelCriterion().generateCancelledException(e);
+          getDistributedSystem().getCancelCriterion().generateCancelledException(throwable);
-        return new CacheClosedException(reason, e);
+        return new CacheClosedException(reason, throwable);
-      if (e == null) {
+      if (throwable == null) {
-      Throwable nt = e;
+      Throwable nt = throwable;
-        return new CacheClosedException(reason, e);
-      } catch (IllegalStateException e2) {
-        // Bug 39496 (Jrockit related) Give up. The following
+        return new CacheClosedException(reason, throwable);
+      } catch (IllegalStateException ignore) {
+        // Bug 39496 (JRockit related) Give up. The following
-    return stopper;
+    return this.stopper;
-    GemFireCacheImpl inst = GemFireCacheImpl.instance;
-    if (inst == null) {
+    GemFireCacheImpl cache = GemFireCacheImpl.instance;
+    if (cache == null) {
-    // TypeRegistry.setPdxSerializer(null);
-    InternalDistributedSystem ids = inst.system;
+    InternalDistributedSystem ids = cache.system;
-    inst.disconnectCause = SystemFailure.getFailure();
-    inst.isClosing = true;
+    cache.disconnectCause = SystemFailure.getFailure();
+    cache.isClosing = true;
-    {
-      Iterator allCacheServersItr = inst.allCacheServers.iterator();
-      while (allCacheServersItr.hasNext()) {
-        CacheServerImpl bs = (CacheServerImpl) allCacheServersItr.next();
-        AcceptorImpl ai = bs.getAcceptor();
-        if (ai != null) {
-          ai.emergencyClose();
-        }
+
+    for (CacheServerImpl cacheServer : cache.allCacheServers) {
+      AcceptorImpl acceptor = cacheServer.getAcceptor();
+      if (acceptor != null) {
+        acceptor.emergencyClose();
-    // These are synchronized sets -- avoid potential deadlocks
-    // instance.pathToRegion.clear(); // garbage collection
-    // instance.gatewayHubs.clear();
-
-    inst.rootRegions.clear();
+    cache.rootRegions.clear();
+
-    inst.partitionedRegions.clear();
+    cache.partitionedRegions.clear();
-    return isShutDownAll.get();
+    return this.isShutDownAll.get();
-  void shutdownSubTreeGracefully(Map<String, PartitionedRegion> prSubMap) {
+  private void shutdownSubTreeGracefully(Map<String, PartitionedRegion> prSubMap) {
-      } catch (InterruptedException e) {
+      } catch (InterruptedException ignore) {
-          InternalGemFireError assErr = new InternalGemFireError(
+          throw new InternalGemFireError(
-          throw assErr;
-        // bug 44031 requires multithread shutdownall should be grouped
+        // bug 44031 requires multithread shutDownAll should be grouped
-        TreeMap<String, Map<String, PartitionedRegion>> prTrees = getPRTrees();
+        SortedMap<String, Map<String, PartitionedRegion>> prTrees = getPRTrees();
-            es.execute(new Runnable() {
-              @Override
-              public void run() {
-                ConnectionTable.threadWantsSharedResources();
-                shutdownSubTreeGracefully(prSubMap);
-              }
+            es.execute(() -> {
+              ConnectionTable.threadWantsSharedResources();
+              shutdownSubTreeGracefully(prSubMap);
-          } catch (InterruptedException e) {
+          } catch (InterruptedException ignore) {
-    final ThreadGroup thrGrp = LoggingThreadGroup.createThreadGroup("ShutdownAllGroup", logger);
-    ThreadFactory thrFactory = new ThreadFactory() {
+    final ThreadGroup threadGroup =
+        LoggingThreadGroup.createThreadGroup("ShutdownAllGroup", logger);
+    ThreadFactory threadFactory = new ThreadFactory() {
-      public Thread newThread(Runnable r) {
-        Thread t = new Thread(thrGrp, r, "ShutdownAll-" + threadCount.getAndIncrement());
-        t.setDaemon(true);
-        return t;
+      public Thread newThread(Runnable runnable) {
+        Thread thread =
+            new Thread(threadGroup, runnable, "ShutdownAll-" + this.threadCount.getAndIncrement());
+        thread.setDaemon(true);
+        return thread;
-    ExecutorService es = Executors
-        .newFixedThreadPool(shutdownAllPoolSize == -1 ? size : shutdownAllPoolSize, thrFactory);
-    return es;
+    return Executors.newFixedThreadPool(shutdownAllPoolSize == -1 ? size : shutdownAllPoolSize,
+        threadFactory);
-  private void shutDownOnePRGracefully(PartitionedRegion pr) {
+  private void shutDownOnePRGracefully(PartitionedRegion partitionedRegion) {
-      pr.acquireDestroyLock();
+      partitionedRegion.acquireDestroyLock();
-      synchronized (pr.getRedundancyProvider()) {
-        if (pr.isDataStore() && pr.getDataStore() != null
-            && pr.getDataPolicy() == DataPolicy.PERSISTENT_PARTITION) {
-          int numBuckets = pr.getTotalNumberOfBuckets();
-          Map<InternalDistributedMember, PersistentMemberID> bucketMaps[] = new Map[numBuckets];
-          PartitionedRegionDataStore prds = pr.getDataStore();
+      synchronized (partitionedRegion.getRedundancyProvider()) {
+        if (partitionedRegion.isDataStore() && partitionedRegion.getDataStore() != null
+            && partitionedRegion.getDataPolicy() == DataPolicy.PERSISTENT_PARTITION) {
+          int numBuckets = partitionedRegion.getTotalNumberOfBuckets();
+          Map<InternalDistributedMember, PersistentMemberID>[] bucketMaps = new Map[numBuckets];
+          PartitionedRegionDataStore dataStore = partitionedRegion.getDataStore();
-          Set<Entry<Integer, BucketRegion>> bucketEntries = prds.getAllLocalBuckets();
-          for (Map.Entry e : bucketEntries) {
-            BucketRegion br = (BucketRegion) e.getValue();
-            if (br == null || br.isDestroyed) {
+          Set<Entry<Integer, BucketRegion>> bucketEntries = dataStore.getAllLocalBuckets();
+          for (Entry e : bucketEntries) {
+            BucketRegion bucket = (BucketRegion) e.getValue();
+            if (bucket == null || bucket.isDestroyed) {
-            br.getBucketAdvisor().tryLockIfPrimary();
+            bucket.getBucketAdvisor().tryLockIfPrimary();
-            // get map <InternalDistriutedMemeber, persistentID> for this bucket's
+            // get map <InternalDistributedMember, persistentID> for this bucket's
-            bucketMaps[br.getId()] = br.getBucketAdvisor().adviseInitializedPersistentMembers();
+            bucketMaps[bucket.getId()] =
+                bucket.getBucketAdvisor().adviseInitializedPersistentMembers();
-                  pr.getName(), br.getId(), bucketMaps[br.getId()]);
+                  partitionedRegion.getName(), bucket.getId(), bucketMaps[bucket.getId()]);
-            logger.debug("shutDownAll: All buckets for PR {} are locked.", pr.getName());
+            logger.debug("shutDownAll: All buckets for PR {} are locked.",
+                partitionedRegion.getName());
-          pr.setShutDownAllStatus(PartitionedRegion.PRIMARY_BUCKETS_LOCKED);
-          new UpdateAttributesProcessor(pr).distribute(false);
-          pr.getRegionAdvisor().waitForProfileStatus(PartitionedRegion.PRIMARY_BUCKETS_LOCKED);
+          partitionedRegion.setShutDownAllStatus(PartitionedRegion.PRIMARY_BUCKETS_LOCKED);
+          new UpdateAttributesProcessor(partitionedRegion).distribute(false);
+          partitionedRegion.getRegionAdvisor()
+              .waitForProfileStatus(PartitionedRegion.PRIMARY_BUCKETS_LOCKED);
-            logger.debug("shutDownAll: PR {}: all bucketlock profiles received.", pr.getName());
+            logger.debug("shutDownAll: PR {}: all bucketLock profiles received.",
+                partitionedRegion.getName());
-          if (!pr.getAttributes().isDiskSynchronous()) {
-            // several PRs might share the same diskstore, we will only flush once
+          if (!partitionedRegion.getAttributes().isDiskSynchronous()) {
+            // several PRs might share the same diskStore, we will only flush once
-            pr.getDiskStore().forceFlush();
+            partitionedRegion.getDiskStore().forceFlush();
-            pr.setShutDownAllStatus(PartitionedRegion.DISK_STORE_FLUSHED);
-            new UpdateAttributesProcessor(pr).distribute(false);
-            pr.getRegionAdvisor().waitForProfileStatus(PartitionedRegion.DISK_STORE_FLUSHED);
+            partitionedRegion.setShutDownAllStatus(PartitionedRegion.DISK_STORE_FLUSHED);
+            new UpdateAttributesProcessor(partitionedRegion).distribute(false);
+            partitionedRegion.getRegionAdvisor()
+                .waitForProfileStatus(PartitionedRegion.DISK_STORE_FLUSHED);
-              logger.debug("shutDownAll: PR {}: all flush profiles received.", pr.getName());
+              logger.debug("shutDownAll: PR {}: all flush profiles received.",
+                  partitionedRegion.getName());
-              pr.getRegionAdvisor().adviseDataStore();
-          for (Map.Entry e : bucketEntries) {
-            BucketRegion br = (BucketRegion) e.getValue();
-            if (br == null || br.isDestroyed) {
+              partitionedRegion.getRegionAdvisor().adviseDataStore();
+          for (Entry e : bucketEntries) {
+            BucketRegion bucket = (BucketRegion) e.getValue();
+            if (bucket == null || bucket.isDestroyed) {
-                getSubMapForLiveMembers(pr, membersToPersistOfflineEqual, bucketMaps[br.getId()]);
+                getSubMapForLiveMembers(membersToPersistOfflineEqual, bucketMaps[bucket.getId()]);
-              br.getPersistenceAdvisor().persistMembersOfflineAndEqual(persistMap);
+              bucket.getPersistenceAdvisor().persistMembersOfflineAndEqual(persistMap);
-                logger.debug("shutDownAll: PR {}: pesisting bucket {}:{}", pr.getName(), br.getId(),
-                    persistMap);
+                logger.debug("shutDownAll: PR {}: persisting bucket {}:{}",
+                    partitionedRegion.getName(), bucket.getId(), persistMap);
-          // send persited profile update to other members, let all members to persist
+          // send persisted profile update to other members, let all members to persist
-          pr.setShutDownAllStatus(PartitionedRegion.OFFLINE_EQUAL_PERSISTED);
-          new UpdateAttributesProcessor(pr).distribute(false);
-          pr.getRegionAdvisor().waitForProfileStatus(PartitionedRegion.OFFLINE_EQUAL_PERSISTED);
+          partitionedRegion.setShutDownAllStatus(PartitionedRegion.OFFLINE_EQUAL_PERSISTED);
+          new UpdateAttributesProcessor(partitionedRegion).distribute(false);
+          partitionedRegion.getRegionAdvisor()
+              .waitForProfileStatus(PartitionedRegion.OFFLINE_EQUAL_PERSISTED);
-            logger.debug("shutDownAll: PR {}: all offline_equal profiles received.", pr.getName());
+            logger.debug("shutDownAll: PR {}: all offline_equal profiles received.",
+                partitionedRegion.getName());
-        } // datastore
+        } // dataStore
-        // after done all steps for buckets, close pr
+        // after done all steps for buckets, close partitionedRegion
-        RegionEventImpl event =
-            new RegionEventImpl(pr, Operation.REGION_CLOSE, null, false, getMyId(), true);
+        RegionEventImpl event = new RegionEventImpl(partitionedRegion, Operation.REGION_CLOSE, null,
+            false, getMyId(), true);
-          pr.basicDestroyRegion(event, false, false, true);
+          partitionedRegion.basicDestroyRegion(event, false, false, true);
-        // pr.close();
-          pr.getFullPath(), cce.getMessage());
+          partitionedRegion.getFullPath(), cce.getMessage());
-          pr.getFullPath(), ce.getMessage());
+          partitionedRegion.getFullPath(), ce.getMessage());
-          pr.getFullPath(), rde.getMessage());
+          partitionedRegion.getFullPath(), rde.getMessage());
-        pr.releaseDestroyLock();
+        partitionedRegion.releaseDestroyLock();
-  private Map<InternalDistributedMember, PersistentMemberID> getSubMapForLiveMembers(
-      PartitionedRegion pr, Set<InternalDistributedMember> membersToPersistOfflineEqual,
+  private static Map<InternalDistributedMember, PersistentMemberID> getSubMapForLiveMembers(
+      Set<InternalDistributedMember> membersToPersistOfflineEqual,
-    Map<InternalDistributedMember, PersistentMemberID> persistMap = new HashMap();
-    Iterator itor = membersToPersistOfflineEqual.iterator();
-    while (itor.hasNext()) {
-      InternalDistributedMember idm = (InternalDistributedMember) itor.next();
-      if (bucketMap.containsKey(idm)) {
-        persistMap.put(idm, bucketMap.get(idm));
+    Map<InternalDistributedMember, PersistentMemberID> persistMap = new HashMap<>();
+    for (InternalDistributedMember member : membersToPersistOfflineEqual) {
+      if (bucketMap.containsKey(member)) {
+        persistMap.put(member, bucketMap.get(member));
-  public void close(String reason, boolean keepalive, boolean keepDS) {
-    close(reason, null, keepalive, keepDS);
+  public void close(String reason, boolean keepAlive, boolean keepDS) {
+    close(reason, null, keepAlive, keepDS);
-  public void close(boolean keepalive) {
-    close("Normal disconnect", null, keepalive, false);
+  public void close(boolean keepAlive) {
+    close("Normal disconnect", null, keepAlive, false);
-      stopper.checkCancelInProgress(null);
+      this.stopper.checkCancelInProgress(null);
-        stopper.checkCancelInProgress(null);
+        this.stopper.checkCancelInProgress(null);
-    } catch (IllegalArgumentException e) {
+    } catch (IllegalArgumentException ignore) {
-      } catch (IllegalArgumentException e) {
+      } catch (IllegalArgumentException ignore) {
-      stopper.checkCancelInProgress(null);
+      this.stopper.checkCancelInProgress(null);
-      stopper.checkCancelInProgress(null);
+      this.stopper.checkCancelInProgress(null);
-    return persistentMemberManager;
+    return this.persistentMemberManager;
-      stopper.checkCancelInProgress(null);
-      if (this.clientMetadatService == null) {
-        this.clientMetadatService = new ClientMetadataService(this);
+      this.stopper.checkCancelInProgress(null);
+      if (this.clientMetadataService == null) {
+        this.clientMetadataService = new ClientMetadataService(this);
-      return this.clientMetadatService;
+      return this.clientMetadataService;
-  /**
-   * close the cache
-   *
-   * @param reason the reason the cache is being closed
-   * @param systemFailureCause whether this member was ejected from the distributed system
-   * @param keepalive whoever added this should javadoc it
-   */
-  public void close(String reason, Throwable systemFailureCause, boolean keepalive) {
-    close(reason, systemFailureCause, keepalive, false);
-  }
-
-  public void close(String reason, Throwable systemFailureCause, boolean keepalive,
+  public void close(String reason, Throwable systemFailureCause, boolean keepAlive,
-    securityService.close();
+    this.securityService.close();
-      // bugfix for bug 36512 "GemFireCache.close is not thread safe"
+      // fix for bug 36512 "GemFireCache.close is not thread safe"
-      /**
+      /*
-       **/
-      system.handleResourceEvent(ResourceEvent.CACHE_REMOVE, this);
-      if (this.listener != null) {
-        this.system.removeResourceListener(listener);
-        this.listener = null;
+       */
+      this.system.handleResourceEvent(ResourceEvent.CACHE_REMOVE, this);
+      if (this.resourceEventsListener != null) {
+        this.system.removeResourceListener(this.resourceEventsListener);
+        this.resourceEventsListener = null;
-      this.keepAlive = keepalive;
-      isClosing = true;
+      this.keepAlive = keepAlive;
+      this.isClosing = true;
-        if (this.txMgr != null) {
-          tx = this.txMgr.internalSuspend();
+        if (this.transactionManager != null) {
+          tx = this.transactionManager.internalSuspend();
-        resourceManager.close();
+        this.resourceManager.close();
-        } catch (CancelException e) {
+        } catch (CancelException ignore) {
-        } catch (CancelException e) {
+        } catch (CancelException ignore) {
-        GatewaySenderAdvisor advisor = null;
-        for (GatewaySender sender : this.getAllGatewaySenders()) {
+        for (GatewaySender sender : this.allGatewaySenders) {
-            advisor = ((AbstractGatewaySender) sender).getSenderAdvisor();
+            GatewaySenderAdvisor advisor = ((AbstractGatewaySender) sender).getSenderAdvisor();
-          } catch (CancelException ce) {
+          } catch (CancelException ignore) {
-          List rootRegionValues = null;
+          List<LocalRegion> rootRegionValues;
-            rootRegionValues = new ArrayList(this.rootRegions.values());
+            rootRegionValues = new ArrayList<>(this.rootRegions.values());
-            for (Iterator itr = rootRegionValues.iterator(); itr.hasNext();) {
-              LocalRegion lr = (LocalRegion) itr.next();
+            for (LocalRegion lr : rootRegionValues) {
-                } catch (Exception e) {
-                  if (isDebugEnabled || !forcedDisconnect) {
+                } catch (RuntimeException e) {
+                  if (isDebugEnabled || !this.forcedDisconnect) {
-          diskMonitor.close();
+          this.diskMonitor.close();
-            cqService.close();
-          } catch (Exception ex) {
+            this.cqService.close();
+          } catch (RuntimeException ignore) {
-          PoolManager.close(keepalive);
+          PoolManager.close(keepAlive);
-          } catch (CancelException e) {
+          } catch (CancelException ignore) {
-          DM dm = null;
+          DM distributionManager = null;
-            dm = system.getDistributionManager();
-            dm.removeMembershipListener(this.txMgr);
-          } catch (CancelException e) {
-            // dm = null;
+            distributionManager = this.system.getDistributionManager();
+            distributionManager.removeMembershipListener(this.transactionManager);
+          } catch (CancelException ignore) {
+            // distributionManager = null;
-          if (dm != null) { // Send CacheClosedMessage (and NOTHING ELSE) here
+          if (distributionManager != null) { // Send CacheClosedMessage (and NOTHING ELSE) here
-            Set otherMembers = dm.getOtherDistributionManagerIds();
-            ReplyProcessor21 processor = new ReplyProcessor21(system, otherMembers);
+            Set otherMembers = distributionManager.getOtherDistributionManagerIds();
+            ReplyProcessor21 processor = new ReplyProcessor21(this.system, otherMembers);
-            dm.putOutgoing(msg);
+            distributionManager.putOutgoing(msg);
-            } catch (InterruptedException ex) {
+            } catch (InterruptedException ignore) {
-            } catch (ReplyException ex) {
+            } catch (ReplyException ignore) {
-          {
-            ClientMetadataService cms = this.clientMetadatService;
-            if (cms != null) {
-              cms.close();
-            }
-            HeapEvictor he = this.heapEvictor;
-            if (he != null) {
-              he.close();
-            }
+          ClientMetadataService cms = this.clientMetadataService;
+          if (cms != null) {
+            cms.close();
-        } catch (CancelException e) {
+          HeapEvictor he = this.heapEvictor;
+          if (he != null) {
+            he.close();
+          }
+        } catch (CancelException ignore) {
-
-          // okay, we're taking too long to do this stuff, so let's
-          // be mean to other processes and skip the rest of the messaging
-          // phase
-          // [bruce] the following code is unnecessary since someone put the
-          // same actions in a finally block
-          // if (!this.closed) {
-          // this.closed = true;
-          // this.txMgr.close();
-          // if (GemFireCache.instance == this) {
-          // GemFireCache.instance = null;
-          // }
-          // ((DynamicRegionFactoryImpl)DynamicRegionFactory.get()).close();
-          // }
-          cqService.close();
-        } catch (Exception ex) {
+          this.cqService.close();
+        } catch (RuntimeException ignore) {
-        synchronized (ccpTimerMutex) {
+        synchronized (this.ccpTimerMutex) {
-        if (this.txMgr != null) {
-          this.txMgr.close();
+        if (this.transactionManager != null) {
+          this.transactionManager.close();
-        if (this.txMgr != null) {
-          this.txMgr.internalResume(tx);
+        if (this.transactionManager != null) {
+          this.transactionManager.internalResume(tx);
-        if (!DISABLE_DISCONNECT_DS_ON_CACHE_CLOSE) {
+        if (!this.DISABLE_DISCONNECT_DS_ON_CACHE_CLOSE) {
-      for (Iterator iter = cacheLifecycleListeners.iterator(); iter.hasNext();) {
-        CacheLifecycleListener listener = (CacheLifecycleListener) iter.next();
+      for (CacheLifecycleListener listener : cacheLifecycleListeners) {
-  // see Cache.isReconnecting()
-  // see Cache.waitUntilReconnected(long, TimeUnit)
-    if (cache == null || !cache.isInitialized()) {
-      return false;
-    }
-    return true;
+    return cache != null && cache.isInitialized();
-    GemFireCacheImpl c = GemFireCacheImpl.getInstance();
-    if (c == null) {
+    GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
+    if (cache == null) {
-    if (c == this || !c.isInitialized()) {
-      c = null;
+    if (cache == this || !cache.isInitialized()) {
+      cache = null;
-    return c;
+    return cache;
-    if (redisServer != null)
+    if (this.redisServer != null)
-    DiskStoreImpl pdxdsi = null;
+    DiskStoreImpl pdxDiskStore = null;
-        pdxdsi = dsi;
+        pdxDiskStore = dsi;
-    if (pdxdsi != null) {
-      pdxdsi.prepareForClose();
+    if (pdxDiskStore != null) {
+      pdxDiskStore.prepareForClose();
+
-   * Lazily initialized.
+   * Lazily initialized. TODO: this is always null
-  private void createDiskStoreTaskPool() {
-    int MAXT = DiskStoreImpl.MAX_CONCURRENT_COMPACTIONS;
-    final ThreadGroup compactThreadGroup =
-        LoggingThreadGroup.createThreadGroup("Oplog Compactor Thread Group", logger);
-    /*
-     * final ThreadFactory compactThreadFactory = new ThreadFactory() { public Thread
-     * newThread(Runnable command) { Thread thread = new Thread(compactThreadGroup, command,
-     * "Idle OplogCompactor"); thread.setDaemon(true); return thread; } };
-     */
+  private final ConcurrentMap<String, DiskStoreImpl> diskStores = new ConcurrentHashMap<>();
-    final ThreadFactory compactThreadFactory =
-        GemfireCacheHelper.CreateThreadFactory(compactThreadGroup, "Idle OplogCompactor");
-    this.diskStoreTaskPool = new ThreadPoolExecutor(MAXT, MAXT, 1, TimeUnit.SECONDS,
-        new LinkedBlockingQueue(), compactThreadFactory);
-  }
-
-  private final ConcurrentMap<String, DiskStoreImpl> diskStores =
-      new ConcurrentHashMap<String, DiskStoreImpl>();
-      new ConcurrentHashMap<String, DiskStoreImpl>();
+      new ConcurrentHashMap<>();
-  public void addDiskStore(DiskStoreImpl dsi) {
+  void addDiskStore(DiskStoreImpl dsi) {
-      getDiskStoreMonitor().addDiskStore(dsi);
+      this.diskMonitor.addDiskStore(dsi);
-  public void removeDiskStore(DiskStoreImpl dsi) {
+  void removeDiskStore(DiskStoreImpl dsi) {
-    /** Added for M&M **/
+    // Added for M&M
-      system.handleResourceEvent(ResourceEvent.DISKSTORE_REMOVE, dsi);
+      this.system.handleResourceEvent(ResourceEvent.DISKSTORE_REMOVE, dsi);
-  public void addRegionOwnedDiskStore(DiskStoreImpl dsi) {
+  void addRegionOwnedDiskStore(DiskStoreImpl dsi) {
-      getDiskStoreMonitor().addDiskStore(dsi);
+      this.diskMonitor.addDiskStore(dsi);
-        /** Added for M&M **/
-        system.handleResourceEvent(ResourceEvent.DISKSTORE_REMOVE, dsi);
-      } catch (Exception e) {
+        // Added for M&M
+        this.system.handleResourceEvent(ResourceEvent.DISKSTORE_REMOVE, dsi);
+      } catch (RuntimeException e) {
-    DEFAULT_DS_NAME = dsName;
-  }
-
-  /**
-   * Used by unit tests to undo a change to the default disk store name.
-   */
-  public static void unsetDefaultDiskStoreName() {
-    DEFAULT_DS_NAME = DiskStoreFactory.DEFAULT_DISK_STORE_NAME;
+    defaultDiskStoreName = dsName;
-    return DEFAULT_DS_NAME;
+    return defaultDiskStoreName;
-  public static String DEFAULT_DS_NAME = DiskStoreFactory.DEFAULT_DISK_STORE_NAME;
+  private static String defaultDiskStoreName = DiskStoreFactory.DEFAULT_DISK_STORE_NAME;
-          result = (DiskStoreImpl) createDiskStoreFactory().create(DEFAULT_DS_NAME);
+          result = (DiskStoreImpl) createDiskStoreFactory().create(defaultDiskStoreName);
-      name = DEFAULT_DS_NAME;
+      name = defaultDiskStoreName;
-    HashSet<DiskStoreImpl> allDiskStores = new HashSet<DiskStoreImpl>();
+    Collection<DiskStoreImpl> allDiskStores = new HashSet<>();
-  public boolean executeDiskStoreTask(DiskStoreTask r) {
-    synchronized (this.diskStoreTaskSync) {
-      if (!this.diskStoreTaskSync.get()) {
-        if (this.diskStoreTaskPool == null) {
-          createDiskStoreTaskPool();
-        }
-        try {
-          this.diskStoreTaskPool.execute(r);
-          return true;
-        } catch (RejectedExecutionException ex) {
-          if (logger.isDebugEnabled()) {
-            logger.debug("Ignored compact schedule during shutdown", ex);
-          }
-        }
-      }
-    }
-    return false;
-  }
-
-        List<Runnable> l = this.diskStoreTaskPool.shutdownNow();
-        for (Runnable runnable : l) {
-          if (l instanceof DiskStoreTask) {
-            ((DiskStoreTask) l).taskCancelled();
+        List<Runnable> listOfRunnables = this.diskStoreTaskPool.shutdownNow();
+        for (Runnable runnable : listOfRunnables) {
+          // TODO: fix this for-loop and the one in DiskStoreImpl
+          if (listOfRunnables instanceof DiskStoreTask) {
+            ((DiskStoreTask) listOfRunnables).taskCancelled();
-      // this.diskStoreTaskPool = null;
-  public int stopGatewaySenders(boolean byShutdownAll) {
+  private void stopServers() {
-
-    int cnt = 0;
-    closingGatewaySendersByShutdownAll = byShutdownAll;
-    synchronized (allGatewaySendersLock) {
-      GatewaySenderAdvisor advisor = null;
-      Iterator<GatewaySender> itr = allGatewaySenders.iterator();
-      while (itr.hasNext()) {
-        GatewaySender sender = itr.next();
-        if (isDebugEnabled) {
-          logger.debug("{}: stopping gateway sender {}", this, sender);
-        }
-        try {
-          sender.stop();
-          advisor = ((AbstractGatewaySender) sender).getSenderAdvisor();
-          if (advisor != null) {
-            if (isDebugEnabled) {
-              logger.debug("Stopping the GatewaySender advisor");
-            }
-            advisor.close();
-          }
-          cnt++;
-        } catch (CancelException e) {
-          if (isDebugEnabled) {
-            logger.debug("Ignored cache closure while closing sender {}", sender, e);
-          }
-        }
-      }
-    } // synchronized
-
-    destroyGatewaySenderLockService();
-
-    if (isDebugEnabled) {
-      logger.debug("{}: finished stopping {} gateway sender(s), total is {}", this, cnt,
-          allGatewaySenders.size());
-    }
-    return cnt;
-  }
-
-  public int stopGatewayReceivers(boolean byShutdownAll) {
-    int cnt = 0;
-    closingGatewayReceiversByShutdownAll = byShutdownAll;
-    synchronized (allGatewayReceiversLock) {
-      Iterator<GatewayReceiver> itr = allGatewayReceivers.iterator();
-      while (itr.hasNext()) {
-        GatewayReceiver receiver = itr.next();
-        if (logger.isDebugEnabled()) {
-          logger.debug("{}: stopping gateway receiver {}", this, receiver);
-        }
-        try {
-          receiver.stop();
-          cnt++;
-        } catch (CancelException e) {
-          if (logger.isDebugEnabled()) {
-            logger.debug("Ignored cache closure while closing receiver {}", receiver, e);
-          }
-        }
-      }
-    } // synchronized
-
-    if (logger.isDebugEnabled()) {
-      logger.debug("{}: finished stopping {} gateway receiver(s), total is {}", this, cnt,
-          allGatewayReceivers.size());
-    }
-    return cnt;
-  }
-
-  void stopServers() {
-
-    final boolean isDebugEnabled = logger.isDebugEnabled();
-
+
-    Iterator allCacheServersIterator = this.allCacheServers.iterator();
-    while (allCacheServersIterator.hasNext()) {
-      CacheServerImpl bridge = (CacheServerImpl) allCacheServersIterator.next();
+
+    for (CacheServerImpl cacheServer : this.allCacheServers) {
-        logger.debug("stopping bridge {}", bridge);
+        logger.debug("stopping bridge {}", cacheServer);
-        bridge.stop();
+        cacheServer.stop();
-          logger.debug("Ignored cache closure while closing bridge {}", bridge, e);
+          logger.debug("Ignored cache closure while closing bridge {}", cacheServer, e);
-      allCacheServers.remove(bridge);
+      this.allCacheServers.remove(cacheServer);
-
-    return Collections.unmodifiableSet(this.dm.getOtherNormalDistributionManagerIds());
+    return Collections
+        .unmodifiableSet((Set<DistributedMember>) this.dm.getOtherNormalDistributionManagerIds());
-    return this.dm.getAdminMemberSet();
+    return (Set<DistributedMember>) this.dm.getAdminMemberSet();
-  public Set<DistributedMember> getMembers(Region r) {
-    if (r instanceof DistributedRegion) {
-      DistributedRegion d = (DistributedRegion) r;
-      return d.getDistributionAdvisor().adviseCacheOp();
-    } else if (r instanceof PartitionedRegion) {
-      PartitionedRegion p = (PartitionedRegion) r;
-      return p.getRegionAdvisor().adviseAllPRNodes();
+  public Set<DistributedMember> getMembers(Region region) {
+    if (region instanceof DistributedRegion) {
+      DistributedRegion distributedRegion = (DistributedRegion) region;
+      return (Set<DistributedMember>) distributedRegion.getDistributionAdvisor().adviseCacheOp();
+    } else if (region instanceof PartitionedRegion) {
+      PartitionedRegion partitionedRegion = (PartitionedRegion) region;
+      return (Set<DistributedMember>) partitionedRegion.getRegionAdvisor().adviseAllPRNodes();
-      return Collections.EMPTY_SET;
+      return Collections.emptySet();
-    Set result = null;
-    for (Pool p : pools.values()) {
-      PoolImpl pi = (PoolImpl) p;
-      for (Object o : pi.getCurrentServers()) {
-        ServerLocation sl = (ServerLocation) o;
+    Set<InetSocketAddress> result = null;
+    for (Pool pool : pools.values()) {
+      PoolImpl poolImpl = (PoolImpl) pool;
+      for (ServerLocation serverLocation : poolImpl.getCurrentServers()) {
-          result = new HashSet<DistributedMember>();
+          result = new HashSet<>();
-        result.add(new InetSocketAddress(sl.getHostName(), sl.getPort()));
+        result.add(new InetSocketAddress(serverLocation.getHostName(), serverLocation.getPort()));
-      return Collections.EMPTY_SET;
+      return Collections.emptySet();
-   * get the threadid/sequenceid sweeper task for this cache
+   * get the threadId/sequenceId sweeper task for this cache
-  protected EventTracker.ExpiryTask getEventTrackerTask() {
+  EventTracker.ExpiryTask getEventTrackerTask() {
-    List<Properties> propertiesList = new ArrayList<Properties>();
+    List<Properties> propertiesList = new ArrayList<>();
-      for (Map.Entry<Declarable, Properties> entry : this.declarablePropertiesMap.entrySet()) {
+      for (Entry<Declarable, Properties> entry : this.declarablePropertiesMap.entrySet()) {
-   * Returns the date and time that this cache was created.
-   *
-   * @since GemFire 3.5
-   */
-  public Date getCreationDate() {
-    return this.creationDate;
-  }
-
-  /**
-    return (int) ((System.currentTimeMillis() - this.creationDate.getTime()) / 1000);
+    return (int) (System.currentTimeMillis() - this.creationDate.getTime()) / 1000;
-  public Region createVMRegion(String name, RegionAttributes attrs)
+  public <K, V> Region<K, V> createVMRegion(String name, RegionAttributes<K, V> aRegionAttributes)
-    return createRegion(name, attrs);
+    return createRegion(name, aRegionAttributes);
-    PoolFactory defpf = PoolManager.createFactory();
+    PoolFactory defaultPoolFactory = PoolManager.createFactory();
-      defpf.addServer(localHostName, CacheServer.DEFAULT_PORT);
+      defaultPoolFactory.addServer(localHostName, CacheServer.DEFAULT_PORT);
-      throw new IllegalStateException("Could not determine local host name");
+      throw new IllegalStateException("Could not determine local host name", ex);
-    return defpf;
+    return defaultPoolFactory;
-    if (this.clientpf == null) {
+    if (this.poolFactory == null) {
-        this.clientpf = createDefaultPF();
+        this.poolFactory = createDefaultPF();
+        // act as if the default pool was configured
+        // and see if we can find an existing one that is compatible
+        PoolFactoryImpl pfi = (PoolFactoryImpl) createDefaultPF();
+        for (Pool p : pools.values()) {
+          if (((PoolImpl) p).isCompatible(pfi.getPoolAttributes())) {
+            pool = p;
+            break;
+          }
+        }
-          // act as if the default pool was configured
-          // and see if we can find an existing one that is compatible
-          PoolFactoryImpl pfi = (PoolFactoryImpl) createDefaultPF();
-          for (Pool p : pools.values()) {
-            if (((PoolImpl) p).isCompatible(pfi.getPoolAttributes())) {
-              pool = p;
-              break;
-            }
-          }
-          if (pool == null) {
-            // if pool is still null then we will not have a default pool for this ClientCache
-            setDefaultPool(null);
-            return;
-          }
+          // if pool is still null then we will not have a default pool for this ClientCache
+          this.defaultPool = null;
+          return;
-      PoolFactoryImpl pfi = (PoolFactoryImpl) this.clientpf;
+      PoolFactoryImpl pfi = (PoolFactoryImpl) this.poolFactory;
-          throw new IllegalStateException("Could not determine local host name");
+          throw new IllegalStateException("Could not determine local host name", ex);
-      pool = this.clientpf.create(poolName);
+      pool = this.poolFactory.create(poolName);
-    setDefaultPool(pool);
+    this.defaultPool = pool;
-  public Pool determineDefaultPool(PoolFactory pf) {
-    Pool pool = null;
+  public Pool determineDefaultPool(PoolFactory poolFactory) {
+    Pool pool;
-    if (pf == null) {
+    if (poolFactory == null) {
-      PoolFactoryImpl pfi = (PoolFactoryImpl) pf;
-      if (pfi.getPoolAttributes().locators.isEmpty() && pfi.getPoolAttributes().servers.isEmpty()) {
+      PoolFactoryImpl poolFactoryImpl = (PoolFactoryImpl) poolFactory;
+      if (poolFactoryImpl.getPoolAttributes().locators.isEmpty()
+          && poolFactoryImpl.getPoolAttributes().servers.isEmpty()) {
-          pfi.addServer(localHostName, CacheServer.DEFAULT_PORT);
+          poolFactoryImpl.addServer(localHostName, CacheServer.DEFAULT_PORT);
-          throw new IllegalStateException("Could not determine local host name");
+          throw new IllegalStateException("Could not determine local host name", ex);
-      PoolImpl defPool = (PoolImpl) getDefaultPool();
-      if (defPool != null && defPool.isCompatible(pfi.getPoolAttributes())) {
-        pool = defPool;
+      PoolImpl defaultPool = (PoolImpl) getDefaultPool();
+      if (defaultPool != null && defaultPool.isCompatible(poolFactoryImpl.getPoolAttributes())) {
+        pool = defaultPool;
-  public Region createRegion(String name, RegionAttributes attrs)
+  public <K, V> Region<K, V> createRegion(String name, RegionAttributes<K, V> aRegionAttributes)
-    return basicCreateRegion(name, attrs);
+    return basicCreateRegion(name, aRegionAttributes);
-  public Region basicCreateRegion(String name, RegionAttributes attrs)
+  public <K, V> Region<K, V> basicCreateRegion(String name, RegionAttributes<K, V> attrs)
-      InternalGemFireError assErr = new InternalGemFireError(
-          LocalizedStrings.GemFireCache_UNEXPECTED_EXCEPTION.toLocalizedString());
-      assErr.initCause(e);
-      throw assErr;
+      throw new InternalGemFireError(
+          LocalizedStrings.GemFireCache_UNEXPECTED_EXCEPTION.toLocalizedString(), e);
+    // TODO: refactor overly complex method
-    stopper.checkCancelInProgress(null);
+    this.stopper.checkCancelInProgress(null);
-    LocalRegion rgn = null;
-    // final boolean getDestroyLock = attrs.getDestroyLockFlag();
+    LocalRegion region;
-    final boolean isReinitCreate = snapshotInputStream != null || imageTarget != null || recreate;
-
-    final String regionPath = LocalRegion.calcFullPath(name, null);
+    final boolean isReInitCreate = snapshotInputStream != null || imageTarget != null || recreate;
-          rgn = (LocalRegion) this.rootRegions.get(name);
-          if (rgn != null) {
-            throw new RegionExistsException(rgn);
+          region = this.rootRegions.get(name);
+          if (region != null) {
+            throw new RegionExistsException(region);
-          if (!isReinitCreate) { // fix bug 33523
+          if (!isReInitCreate) { // fix bug 33523
-              rgn = internalRegionArgs.getInternalMetaRegion();
+              region = internalRegionArgs.getInternalMetaRegion();
-              rgn = new PartitionedRegion(name, attrs, null, this, internalRegionArgs);
+              region = new PartitionedRegion(name, attrs, null, this, internalRegionArgs);
-              /*
-               * for (String senderId : attrs.getGatewaySenderIds()) { if
-               * (getGatewaySender(senderId) != null && getGatewaySender(senderId).isParallel()) {
-               * throw new IllegalStateException( LocalizedStrings.
-               * AttributesFactory_PARALLELGATEWAYSENDER_0_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION
-               * .toLocalizedString(senderId)); } }
-               */
-                rgn = new LocalRegion(name, attrs, null, this, internalRegionArgs);
+                region = new LocalRegion(name, attrs, null, this, internalRegionArgs);
-                rgn = new DistributedRegion(name, attrs, null, this, internalRegionArgs);
+                region = new DistributedRegion(name, attrs, null, this, internalRegionArgs);
-            this.rootRegions.put(name, rgn);
-            if (isReinitCreate) {
-              regionReinitialized(rgn);
+            this.rootRegions.put(name, region);
+            if (isReInitCreate) {
+              regionReinitialized(region);
-          LocalRegion region = (LocalRegion) future.get(); // wait on Future
-          throw new RegionExistsException(region);
-        } catch (InterruptedException e) {
+          LocalRegion localRegion = (LocalRegion) future.get(); // wait on Future
+          throw new RegionExistsException(localRegion);
+        } catch (InterruptedException ignore) {
-        } catch (CancellationException e) {
+        } catch (CancellationException ignore) {
-          if (interrupted)
+          if (interrupted) {
+          }
-        setRegionByPath(rgn.getFullPath(), rgn);
-        rgn.initialize(snapshotInputStream, imageTarget, internalRegionArgs);
+        setRegionByPath(region.getFullPath(), region);
+        region.initialize(snapshotInputStream, imageTarget, internalRegionArgs);
-      } catch (CancelException e) {
+      } catch (CancelException | RedundancyAlreadyMetException e) {
-      } catch (RedundancyAlreadyMetException e) {
-        // don't log this
-        throw e;
-      } catch (final RuntimeException validationException) {
+      } catch (RuntimeException validationException) {
-            LocalizedStrings.GemFireCache_INITIALIZATION_FAILED_FOR_REGION_0, rgn.getFullPath()),
+            LocalizedStrings.GemFireCache_INITIALIZATION_FAILED_FOR_REGION_0, region.getFullPath()),
-            rgn.cleanupFailedInitialization();
+            region.cleanupFailedInitialization();
-            stopper.checkCancelInProgress(t);
+            this.stopper.checkCancelInProgress(t);
-                LocalizedStrings.GemFireCache_INIT_CLEANUP_FAILED_FOR_REGION_0, rgn.getFullPath()),
-                t);
+                LocalizedStrings.GemFireCache_INIT_CLEANUP_FAILED_FOR_REGION_0,
+                region.getFullPath()), t);
-            setRegionByPath(rgn.getFullPath(), null);
+            setRegionByPath(region.getFullPath(), null);
-              Region r = (Region) this.rootRegions.get(name);
-              if (r == rgn) {
+              Region rootRegion = this.rootRegions.get(name);
+              if (rootRegion == region) {
-
-
-      rgn.postCreateRegion();
+      region.postCreateRegion();
-      LocalRegion r = (LocalRegion) ex.getRegion();
-      r.waitOnInitialization(); // don't give out ref until initialized
+      LocalRegion localRegion = (LocalRegion) ex.getRegion();
+      localRegion.waitOnInitialization(); // don't give out ref until initialized
-    invokeRegionAfter(rgn);
-    /**
-     * Added for M&M . Putting the callback here to avoid creating RegionMBean in case of Exception
-     **/
-    if (!rgn.isInternalRegion()) {
-      system.handleResourceEvent(ResourceEvent.REGION_CREATE, rgn);
+    invokeRegionAfter(region);
+
+    // Added for M&M . Putting the callback here to avoid creating RegionMBean in case of Exception
+    if (!region.isInternalRegion()) {
+      this.system.handleResourceEvent(ResourceEvent.REGION_CREATE, region);
-    return rgn;
+    return region;
-  public RegionAttributes invokeRegionBefore(LocalRegion parent, String name,
-      RegionAttributes attrs, InternalRegionArguments internalRegionArgs) {
-    for (RegionListener listener : regionListeners) {
-      attrs = listener.beforeCreate(parent, name, attrs, internalRegionArgs);
+  public <K, V> RegionAttributes<K, V> invokeRegionBefore(LocalRegion parent, String name,
+      RegionAttributes<K, V> attrs, InternalRegionArguments internalRegionArgs) {
+    for (RegionListener listener : this.regionListeners) {
+      attrs =
+          (RegionAttributes<K, V>) listener.beforeCreate(parent, name, attrs, internalRegionArgs);
-    for (RegionListener listener : regionListeners) {
+    for (RegionListener listener : this.regionListeners) {
+  /**
+   * TODO: any changes to this method breaks ParallelQueueRemovalMessageJUnitTest
+   */
-  public final Region getRegion(String path) {
+  public Region getRegion(String path) {
-    Set<LocalRegion> result = new HashSet();
+    Set<LocalRegion> result = new HashSet<>();
-      for (Object r : this.rootRegions.values()) {
-        if (r instanceof PartitionedRegion) {
-          PartitionedRegion p = (PartitionedRegion) r;
-          PartitionedRegionDataStore prds = p.getDataStore();
-          if (prds != null) {
-            Set<Entry<Integer, BucketRegion>> bucketEntries = p.getDataStore().getAllLocalBuckets();
-            for (Map.Entry e : bucketEntries) {
-              result.add((LocalRegion) e.getValue());
+      for (Region region : this.rootRegions.values()) {
+        if (region instanceof PartitionedRegion) {
+          PartitionedRegion partitionedRegion = (PartitionedRegion) region;
+          PartitionedRegionDataStore dataStore = partitionedRegion.getDataStore();
+          if (dataStore != null) {
+            Set<Entry<Integer, BucketRegion>> bucketEntries =
+                partitionedRegion.getDataStore().getAllLocalBuckets();
+            for (Entry entry : bucketEntries) {
+              result.add((LocalRegion) entry.getValue());
-        } else if (r instanceof LocalRegion) {
-          LocalRegion l = (LocalRegion) r;
-          result.add(l);
-          result.addAll(l.basicSubregions(true));
+        } else if (region instanceof LocalRegion) {
+          LocalRegion localRegion = (LocalRegion) region;
+          result.add(localRegion);
+          result.addAll(localRegion.basicSubregions(true));
-    Set<LocalRegion> result = new HashSet<LocalRegion>();
+    Set<LocalRegion> result = new HashSet<>();
-      for (Object r : this.rootRegions.values()) {
-        LocalRegion rgn = (LocalRegion) r;
-        if (rgn.isSecret() || rgn.isUsedForMetaRegion() || rgn instanceof HARegion
-            || rgn.isUsedForPartitionedRegionAdmin()
-            || rgn.isInternalRegion()/* rgn.isUsedForPartitionedRegionBucket() */) {
+      for (Object region : this.rootRegions.values()) {
+        LocalRegion localRegion = (LocalRegion) region;
+        if (localRegion.isSecret() || localRegion.isUsedForMetaRegion()
+            || localRegion instanceof HARegion || localRegion.isUsedForPartitionedRegionAdmin()
+            || localRegion.isInternalRegion()/* localRegion.isUsedForPartitionedRegionBucket() */) {
-        result.add(rgn);
-        result.addAll(rgn.basicSubregions(true));
+        result.add(localRegion);
+        result.addAll(localRegion.basicSubregions(true));
-    if (path.length() == 0) {
+    if (path.isEmpty()) {
-    { // do this before checking the pathToRegion map
-      LocalRegion result = getReinitializingRegion(path);
-      if (result != null) {
-        return result;
-      }
+    // do this before checking the pathToRegion map
+    LocalRegion result = getReinitializingRegion(path);
+    if (result != null) {
+      return result;
-      stopper.checkCancelInProgress(null);
+      this.stopper.checkCancelInProgress(null);
-      // initialization
-      // latches
+      // initialization latches
-        LocalRegion root;
+        LocalRegion rootRegion;
-          root = (LocalRegion) this.rootRegions.get(pathParts[0]);
-          if (root == null)
+          rootRegion = this.rootRegions.get(pathParts[0]);
+          if (rootRegion == null)
-          logger.debug("GemFireCache.getRegion, calling getSubregion on root({}): {}", pathParts[0],
-              pathParts[1]);
+          logger.debug("GemFireCache.getRegion, calling getSubregion on rootRegion({}): {}",
+              pathParts[0], pathParts[1]);
-        result = (LocalRegion) root.getSubregion(pathParts[1], true);
+        result = (LocalRegion) rootRegion.getSubregion(pathParts[1], true);
-    stopper.checkCancelInProgress(null);
-    {
-      LocalRegion result = getRegionByPath(path);
-      // Do not waitOnInitialization() for PR
-      // if (result != null && !(result instanceof PartitionedRegion)) {
-      if (result != null) {
-        result.waitOnInitialization();
-        if (!returnDestroyedRegion && result.isDestroyed()) {
-          stopper.checkCancelInProgress(null);
-          return null;
-        } else {
-          return result;
-        }
+    this.stopper.checkCancelInProgress(null);
+
+    LocalRegion result = getRegionByPath(path);
+    // Do not waitOnInitialization() for PR
+    if (result != null) {
+      result.waitOnInitialization();
+      if (!returnDestroyedRegion && result.isDestroyed()) {
+        this.stopper.checkCancelInProgress(null);
+        return null;
+      } else {
+        return result;
-    LocalRegion root;
+    LocalRegion rootRegion;
-      root = (LocalRegion) this.rootRegions.get(pathParts[0]);
-      if (root == null) {
+      rootRegion = this.rootRegions.get(pathParts[0]);
+      if (rootRegion == null) {
-        stopper.checkCancelInProgress(null);
+        this.stopper.checkCancelInProgress(null);
-      if (!returnDestroyedRegion && root.isDestroyed()) {
-        stopper.checkCancelInProgress(null);
+      if (!returnDestroyedRegion && rootRegion.isDestroyed()) {
+        this.stopper.checkCancelInProgress(null);
-      logger.debug("GemFireCache.getRegion, calling getSubregion on root({}): {}", pathParts[0],
-          pathParts[1]);
+      logger.debug("GemFireCache.getRegion, calling getSubregion on rootRegion({}): {}",
+          pathParts[0], pathParts[1]);
-    return root.getSubregion(pathParts[1], returnDestroyedRegion);
-  }
-
-  /**
-   * @param returnDestroyedRegion if true, okay to return a destroyed partitioned region
-   */
-  public final Region getPartitionedRegion(String path, boolean returnDestroyedRegion) {
-    stopper.checkCancelInProgress(null);
-    {
-      LocalRegion result = getRegionByPath(path);
-      // Do not waitOnInitialization() for PR
-      if (result != null) {
-        if (!(result instanceof PartitionedRegion)) {
-          return null;
-        } else {
-          return result;
-        }
-      }
-    }
-
-    String[] pathParts = parsePath(path);
-    LocalRegion root;
-    LogWriterI18n logger = getLoggerI18n();
-    synchronized (this.rootRegions) {
-      root = (LocalRegion) this.rootRegions.get(pathParts[0]);
-      if (root == null) {
-        if (logger.fineEnabled()) {
-          logger.fine("GemFireCache.getRegion, no region found for " + pathParts[0]);
-        }
-        stopper.checkCancelInProgress(null);
-        return null;
-      }
-      if (!returnDestroyedRegion && root.isDestroyed()) {
-        stopper.checkCancelInProgress(null);
-        return null;
-      }
-    }
-    if (logger.fineEnabled()) {
-      logger.fine("GemFireCache.getPartitionedRegion, calling getSubregion on root(" + pathParts[0]
-          + "): " + pathParts[1]);
-    }
-    Region result = root.getSubregion(pathParts[1], returnDestroyedRegion);
-    if (result != null && !(result instanceof PartitionedRegion)) {
-      return null;
-    } else {
-      return result;
-    }
+    return rootRegion.getSubregion(pathParts[1], returnDestroyedRegion);
-    stopper.checkCancelInProgress(null);
+    this.stopper.checkCancelInProgress(null);
-    // initialization
-    // latches
+    // initialization latches
-  boolean isGlobalRegionInitializing(LocalRegion region) {
+  private boolean isGlobalRegionInitializing(LocalRegion region) {
-  public Set rootRegions() {
+  public Set<Region<?, ?>> rootRegions() {
-  public final Set rootRegions(boolean includePRAdminRegions) {
+  public Set<Region<?, ?>> rootRegions(boolean includePRAdminRegions) {
-  private final Set rootRegions(boolean includePRAdminRegions, boolean waitForInit) {
-    stopper.checkCancelInProgress(null);
-    Set regions = new HashSet();
+  private Set<Region<?, ?>> rootRegions(boolean includePRAdminRegions, boolean waitForInit) {
+    this.stopper.checkCancelInProgress(null);
+    Set<Region<?, ?>> regions = new HashSet<>();
-      for (Iterator itr = this.rootRegions.values().iterator(); itr.hasNext();) {
-        LocalRegion r = (LocalRegion) itr.next();
+      for (LocalRegion region : this.rootRegions.values()) {
-        if (r.isSecret() || r.isUsedForMetaRegion() || r instanceof HARegion
-            || !includePRAdminRegions
-                && (r.isUsedForPartitionedRegionAdmin() || r.isUsedForPartitionedRegionBucket())) {
+        if (region.isSecret() || region.isUsedForMetaRegion() || region instanceof HARegion
+            || !includePRAdminRegions && (region.isUsedForPartitionedRegionAdmin()
+                || region.isUsedForPartitionedRegionBucket())) {
-        regions.add(r);
+        regions.add(region);
-      for (Iterator r = regions.iterator(); r.hasNext();) {
-        LocalRegion lr = (LocalRegion) r.next();
-        // lr.waitOnInitialization();
-        if (!lr.checkForInitialization()) {
-          r.remove();
+      for (Iterator<Region<?, ?>> iterator = regions.iterator(); iterator.hasNext();) {
+        LocalRegion region = (LocalRegion) iterator.next();
+        if (!region.checkForInitialization()) {
+          iterator.remove();
-   * Called by ccn when a client goes away
+   * Called by notifier when a client goes away
-      if (isClosed())
+      if (isClosed()) {
-      Iterator it = rootRegions(false, false).iterator();
-      while (it.hasNext()) {
-        LocalRegion lr = (LocalRegion) it.next();
-        lr.cleanupForClient(ccn, client);
+      }
+      for (Object region : rootRegions(false, false)) {
+        LocalRegion localRegion = (LocalRegion) region;
+        localRegion.cleanupForClient(ccn, client);
-  public boolean isInitialized() {
+  private boolean isInitialized() {
-    stopper.checkCancelInProgress(null);
+    this.stopper.checkCancelInProgress(null);
-    stopper.checkCancelInProgress(null);
+    this.stopper.checkCancelInProgress(null);
-    stopper.checkCancelInProgress(null);
+    this.stopper.checkCancelInProgress(null);
-    stopper.checkCancelInProgress(null);
+    this.stopper.checkCancelInProgress(null);
-    } catch (InterruptedException e) {
+    } catch (InterruptedException ignore) {
-    } catch (CancellationException e) {
+    } catch (CancellationException ignore) {
-   * Implementation of {@link org.apache.geode.cache.Cache#setCopyOnRead}
+   * Implementation of {@link Cache#setCopyOnRead}
-   * Implementation of {@link org.apache.geode.cache.Cache#getCopyOnRead}
+   * Implementation of {@link Cache#getCopyOnRead}
-      String rgnName = rootRgn.getName();
-      LocalRegion found = (LocalRegion) this.rootRegions.get(rgnName);
+      String regionName = rootRgn.getName();
+      LocalRegion found = this.rootRegions.get(regionName);
-        LocalRegion previous = (LocalRegion) this.rootRegions.remove(rgnName);
+        LocalRegion previous = this.rootRegions.remove(regionName);
-   * @return array of two Strings, the root name and the relative path from root If there is no
+   * @return array of two Strings, the root name and the relative path from root. If there is no
-  static String[] parsePath(String p_path) {
-    String path = p_path;
+  static String[] parsePath(String path) {
-   * Makes note of a <code>CacheLifecycleListener</code>
+   * Makes note of a {@code CacheLifecycleListener}
-  public static void addCacheLifecycleListener(CacheLifecycleListener l) {
+  public static void addCacheLifecycleListener(CacheLifecycleListener listener) {
-      cacheLifecycleListeners.add(l);
+      cacheLifecycleListeners.add(listener);
-   * Removes a <code>CacheLifecycleListener</code>
+   * Removes a {@code CacheLifecycleListener}
-  public static boolean removeCacheLifecycleListener(CacheLifecycleListener l) {
+  public static boolean removeCacheLifecycleListener(CacheLifecycleListener listener) {
-      return cacheLifecycleListeners.remove(l);
+      return cacheLifecycleListeners.remove(listener);
+  @Override
+  @Override
+  @Override
-  @SuppressWarnings("unchecked")
-    return (T) services.get(clazz);
+    return clazz.cast(this.services.get(clazz));
-   * Creates the single instance of the Transation Manager for this cache. Returns the existing one
+   * Creates the single instance of the Transaction Manager for this cache. Returns the existing one
-    return this.txMgr;
+    return this.transactionManager;
+   * GuardedBy {@link #ccpTimerMutex}
+   *
-   * @guarded.By {@link #ccpTimerMutex}
-    synchronized (ccpTimerMutex) {
-      if (ccpTimer != null) {
-        return ccpTimer;
+    synchronized (this.ccpTimerMutex) {
+      if (this.ccpTimer != null) {
+        return this.ccpTimer;
-      ccpTimer = new SystemTimer(getDistributedSystem(), true);
+      this.ccpTimer = new SystemTimer(getDistributedSystem(), true);
-        ccpTimer.cancel(); // poison it, don't throw.
+        this.ccpTimer.cancel(); // poison it, don't throw.
-      return ccpTimer;
+      return this.ccpTimer;
+
-    synchronized (ccpTimerMutex) {
-      if (ccpTimer != null) {
-        cancelCount++;
-        if (cancelCount == PURGE_INTERVAL) {
-          cancelCount = 0;
-          ccpTimer.timerPurge();
+    synchronized (this.ccpTimerMutex) {
+      if (this.ccpTimer != null) {
+        this.cancelCount++;
+        if (this.cancelCount == PURGE_INTERVAL) {
+          this.cancelCount = 0;
+          this.ccpTimer.timerPurge();
-    return this.txMgr;
+    return this.transactionManager;
-   * Returns the <code>Executor</code> (thread pool) that is used to execute cache event listeners.
-   * Returns <code>null</code> if no pool exists.
+   * Returns the {@code Executor} (thread pool) that is used to execute cache event listeners.
+   * Returns {@code null} if no pool exists.
-    stopper.checkCancelInProgress(null);
+    this.stopper.checkCancelInProgress(null);
-    CacheServerImpl bridge = new CacheServerImpl(this, isGatewayReceiver);
-    allCacheServers.add(bridge);
+    CacheServerImpl cacheServer = new CacheServerImpl(this, isGatewayReceiver);
+    this.allCacheServers.add(cacheServer);
-    return bridge;
+    return cacheServer;
-    stopper.checkCancelInProgress(null);
+    this.stopper.checkCancelInProgress(null);
-    synchronized (allGatewaySendersLock) {
-      if (!allGatewaySenders.contains(sender)) {
-        new UpdateAttributesProcessor((AbstractGatewaySender) sender).distribute(true);
-        Set<GatewaySender> tmp = new HashSet<GatewaySender>(allGatewaySenders.size() + 1);
-        if (!allGatewaySenders.isEmpty()) {
-          tmp.addAll(allGatewaySenders);
+    synchronized (this.allGatewaySendersLock) {
+      if (!this.allGatewaySenders.contains(sender)) {
+        new UpdateAttributesProcessor((DistributionAdvisee) sender).distribute(true);
+        Set<GatewaySender> newSenders = new HashSet<>(this.allGatewaySenders.size() + 1);
+        if (!this.allGatewaySenders.isEmpty()) {
+          newSenders.addAll(this.allGatewaySenders);
-        tmp.add(sender);
-        this.allGatewaySenders = Collections.unmodifiableSet(tmp);
+        newSenders.add(sender);
+        this.allGatewaySenders = Collections.unmodifiableSet(newSenders);
-      Set<LocalRegion> appRegions = getApplicationRegions();
-      for (LocalRegion r : appRegions) {
-        Set<String> senders = r.getAllGatewaySenderIds();
+      Set<LocalRegion> applicationRegions = getApplicationRegions();
+      for (LocalRegion region : applicationRegions) {
+        Set<String> senders = region.getAllGatewaySenderIds();
-          r.senderCreated();
+          region.senderCreated();
-      system.handleResourceEvent(ResourceEvent.GATEWAYSENDER_CREATE, sender);
+      this.system.handleResourceEvent(ResourceEvent.GATEWAYSENDER_CREATE, sender);
-    stopper.checkCancelInProgress(null);
+    this.stopper.checkCancelInProgress(null);
-    synchronized (allGatewaySendersLock) {
-      if (allGatewaySenders.contains(sender)) {
-        new UpdateAttributesProcessor((AbstractGatewaySender) sender, true).distribute(true);
-        Set<GatewaySender> tmp = new HashSet<GatewaySender>(allGatewaySenders.size() - 1);
-        if (!allGatewaySenders.isEmpty()) {
-          tmp.addAll(allGatewaySenders);
+    synchronized (this.allGatewaySendersLock) {
+      if (this.allGatewaySenders.contains(sender)) {
+        new UpdateAttributesProcessor((DistributionAdvisee) sender, true).distribute(true);
+        Set<GatewaySender> newSenders = new HashSet<>(this.allGatewaySenders.size() - 1);
+        if (!this.allGatewaySenders.isEmpty()) {
+          newSenders.addAll(this.allGatewaySenders);
-        tmp.remove(sender);
-        this.allGatewaySenders = Collections.unmodifiableSet(tmp);
+        newSenders.remove(sender);
+        this.allGatewaySenders = Collections.unmodifiableSet(newSenders);
-  public void addGatewayReceiver(GatewayReceiver recv) {
+  public void addGatewayReceiver(GatewayReceiver receiver) {
-    stopper.checkCancelInProgress(null);
-    synchronized (allGatewayReceiversLock) {
-      Set<GatewayReceiver> tmp = new HashSet<GatewayReceiver>(allGatewayReceivers.size() + 1);
-      if (!allGatewayReceivers.isEmpty()) {
-        tmp.addAll(allGatewayReceivers);
+    this.stopper.checkCancelInProgress(null);
+    synchronized (this.allGatewayReceiversLock) {
+      Set<GatewayReceiver> newReceivers = new HashSet<>(this.allGatewayReceivers.size() + 1);
+      if (!this.allGatewayReceivers.isEmpty()) {
+        newReceivers.addAll(this.allGatewayReceivers);
-      tmp.add(recv);
-      this.allGatewayReceivers = Collections.unmodifiableSet(tmp);
+      newReceivers.add(receiver);
+      this.allGatewayReceivers = Collections.unmodifiableSet(newReceivers);
-    system.handleResourceEvent(ResourceEvent.ASYNCEVENTQUEUE_CREATE, asyncQueue);
+    this.system.handleResourceEvent(ResourceEvent.ASYNCEVENTQUEUE_CREATE, asyncQueue);
-    Set<GatewaySender> tempSet = new HashSet<GatewaySender>();
-    for (GatewaySender sender : allGatewaySenders) {
+    Set<GatewaySender> senders = new HashSet<>();
+    for (GatewaySender sender : this.allGatewaySenders) {
-        tempSet.add(sender);
+        senders.add(sender);
-    return tempSet;
+    return senders;
-  public GatewaySender getGatewaySender(String Id) {
+  public GatewaySender getGatewaySender(String id) {
-      if (sender.getId().equals(Id)) {
+      if (sender.getId().equals(id)) {
-    synchronized (allGatewaySendersLock) {
+    synchronized (this.allGatewaySendersLock) {
-    system.handleResourceEvent(ResourceEvent.ASYNCEVENTQUEUE_REMOVE, asyncQueue);
+    this.system.handleResourceEvent(ResourceEvent.ASYNCEVENTQUEUE_REMOVE, asyncQueue);
-  /* Cache API - get the conflict resolver for WAN */
+  /** get the conflict resolver for WAN */
-  /* Cache API - set the conflict resolver for WAN */
+  /** set the conflict resolver for WAN */
-    List cacheServersWithoutReceiver = null;
-    if (!allCacheServers.isEmpty()) {
-      Iterator allCacheServersIterator = allCacheServers.iterator();
-      while (allCacheServersIterator.hasNext()) {
-        CacheServerImpl cacheServer = (CacheServerImpl) allCacheServersIterator.next();
+    List<CacheServer> cacheServersWithoutReceiver = null;
+    if (!this.allCacheServers.isEmpty()) {
+      for (CacheServerImpl cacheServer : this.allCacheServers) {
-            cacheServersWithoutReceiver = new ArrayList();
+            cacheServersWithoutReceiver = new ArrayList<>();
-    return allCacheServers;
-  }
-
-  /**
-   * notify partitioned regions that this cache requires all of their events
-   */
-  public void requiresPREvents() {
-    synchronized (this.partitionedRegions) {
-      for (Iterator it = this.partitionedRegions.iterator(); it.hasNext();) {
-        ((PartitionedRegion) it.next()).cacheRequiresNotification();
-      }
-    }
+    return this.allCacheServers;
-  public void addPartitionedRegion(PartitionedRegion r) {
+  void addPartitionedRegion(PartitionedRegion region) {
-      if (r.isDestroyed()) {
+      if (region.isDestroyed()) {
-          logger.debug("GemFireCache#addPartitionedRegion did not add destroyed {}", r);
+          logger.debug("GemFireCache#addPartitionedRegion did not add destroyed {}", region);
-      if (this.partitionedRegions.add(r)) {
+      if (this.partitionedRegions.add(region)) {
+  @Override
-      return new HashSet<PartitionedRegion>(this.partitionedRegions);
+      return new HashSet<>(this.partitionedRegions);
-  private TreeMap<String, Map<String, PartitionedRegion>> getPRTrees() {
+  private SortedMap<String, Map<String, PartitionedRegion>> getPRTrees() {
-    TreeMap<String, Map<String, PartitionedRegion>> prTrees = new TreeMap();
-    TreeMap<String, PartitionedRegion> prMap = getPartitionedRegionMap();
+    SortedMap<String, PartitionedRegion> prMap = getPartitionedRegionMap();
-      List<PartitionedRegion> childlist = ColocationHelper.getColocatedChildRegions(pr);
-      if (childlist != null && childlist.size() > 0) {
+      List<PartitionedRegion> childList = ColocationHelper.getColocatedChildRegions(pr);
+      if (childList != null && !childList.isEmpty()) {
+    TreeMap<String, Map<String, PartitionedRegion>> prTrees = new TreeMap<>();
-      LinkedHashMap<String, PartitionedRegion> orderedPrMap = orderByColocation(prMap);
+      Map<String, PartitionedRegion> orderedPrMap = orderByColocation(prMap);
-        TreeMap<String, PartitionedRegion> prSubMap =
-            (TreeMap<String, PartitionedRegion>) prTrees.get(rootName);
+        Map<String, PartitionedRegion> prSubMap = prTrees.get(rootName);
-          prSubMap = new TreeMap();
+          prSubMap = new TreeMap<>();
-  private TreeMap<String, PartitionedRegion> getPartitionedRegionMap() {
-    TreeMap<String, PartitionedRegion> prMap = new TreeMap();
-    for (Map.Entry<String, Region> entry : ((Map<String, Region>) pathToRegion).entrySet()) {
-      String regionName = (String) entry.getKey();
-      Region region = entry.getValue();
+  private SortedMap<String, PartitionedRegion> getPartitionedRegionMap() {
+    SortedMap<String, PartitionedRegion> prMap = new TreeMap<>();
+    for (Entry<String, Region<?, ?>> entry : this.pathToRegion.entrySet()) {
+      String regionName = entry.getKey();
+      Region<?, ?> region = entry.getValue();
-      } catch (CancelException ce) {
+      } catch (CancelException ignore) {
-        // then no need to shutdownall them gracefully
+        // then no need to shutDownAll them gracefully
-  private LinkedHashMap<String, PartitionedRegion> orderByColocation(
-      TreeMap<String, PartitionedRegion> prMap) {
-    LinkedHashMap<String, PartitionedRegion> orderedPrMap = new LinkedHashMap();
+  private Map<String, PartitionedRegion> orderByColocation(Map<String, PartitionedRegion> prMap) {
+    LinkedHashMap<String, PartitionedRegion> orderedPrMap = new LinkedHashMap<>();
-    boolean result = hasSerialSenders;
-    if (!result) {
-      Iterator allCacheServersIterator = allCacheServers.iterator();
-      while (allCacheServersIterator.hasNext()) {
-        CacheServerImpl server = (CacheServerImpl) allCacheServersIterator.next();
+    if (!hasSerialSenders) {
+      for (CacheServerImpl server : this.allCacheServers) {
-          result = true;
+          hasSerialSenders = true;
-    return result;
+    return hasSerialSenders;
-  private boolean hasSerialSenders(PartitionedRegion r) {
+  private boolean hasSerialSenders(PartitionedRegion region) {
-    Set<String> senders = r.getAllGatewaySenderIds();
+    Set<String> senders = region.getAllGatewaySenderIds();
-      GatewaySender gs = this.getGatewaySender(sender);
-      if (gs != null && !gs.isParallel()) {
+      GatewaySender gatewaySender = this.getGatewaySender(sender);
+      if (gatewaySender != null && !gatewaySender.isParallel()) {
-  public void removePartitionedRegion(PartitionedRegion r) {
+  void removePartitionedRegion(PartitionedRegion region) {
-      if (this.partitionedRegions.remove(r)) {
+      if (this.partitionedRegions.remove(region)) {
-    stopper.checkCancelInProgress(null);
+    this.stopper.checkCancelInProgress(null);
-    stopper.checkCancelInProgress(null);
+    this.stopper.checkCancelInProgress(null);
-    if (!this.isServer) {
-      return (this.allCacheServers.size() > 0);
-    } else {
-      return true;
-    }
+    return this.isServer || !this.allCacheServers.isEmpty();
-      Pool p = getDefaultPool();
-      if (p == null) {
+      Pool pool = getDefaultPool();
+      if (pool == null) {
-        return p.getQueryService();
+        return pool.getQueryService();
-  public javax.transaction.TransactionManager getJTATransactionManager() {
+  public TransactionManager getJTATransactionManager() {
-  public RegionAttributes getRegionAttributes(String id) {
-    return (RegionAttributes) this.namedRegionAttributes.get(id);
+  public <K, V> RegionAttributes<K, V> getRegionAttributes(String id) {
+    return (RegionAttributes<K, V>) this.namedRegionAttributes.get(id);
-  public void setRegionAttributes(String id, RegionAttributes attrs) {
+  public <K, V> void setRegionAttributes(String id, RegionAttributes<K, V> attrs) {
-  public Map listRegionAttributes() {
+  public Map<String, RegionAttributes<?, ?>> listRegionAttributes() {
-  private static final ThreadLocal xmlCache = new ThreadLocal();
-
-  /**
-   * Returns the cache currently being xml initialized by the thread that calls this method. The
-   * result will be null if the thread is not initializing a cache.
-   */
-  public static GemFireCacheImpl getXmlCache() {
-    return (GemFireCacheImpl) xmlCache.get();
-  }
+  private static final ThreadLocal<GemFireCacheImpl> xmlCache = new ThreadLocal<>();
-  public void loadCacheXml(InputStream stream)
+  public void loadCacheXml(InputStream is)
-    final Object oldValue = xmlCache.get();
+    final GemFireCacheImpl oldValue = xmlCache.get();
+
+    Reader reader = null;
+    Writer stringWriter = null;
+    OutputStreamWriter writer = null;
+
-      if (xmlParameterizationEnabled) {
+      if (XML_PARAMETERIZATION_ENABLED) {
-        Reader reader = new BufferedReader(new InputStreamReader(stream, "ISO-8859-1"));
-        Writer stringWriter = new StringWriter();
+        reader = new BufferedReader(new InputStreamReader(is, "ISO-8859-1"));
+        stringWriter = new StringWriter();
-        int n = -1;
-        while ((n = reader.read(buffer)) != -1) {
-          stringWriter.write(buffer, 0, n);
+        int numChars;
+        while ((numChars = reader.read(buffer)) != -1) {
+          stringWriter.write(buffer, 0, numChars);
-        /**
-         * Now replace all replaceable system properties here using <code>PropertyResolver</code>
+        /*
+         * Now replace all replaceable system properties here using {@code PropertyResolver}
-        String replacedXmlString = resolver.processUnresolvableString(stringWriter.toString());
+        String replacedXmlString = this.resolver.processUnresolvableString(stringWriter.toString());
-        OutputStreamWriter writer = new OutputStreamWriter(baos, "ISO-8859-1");
+        writer = new OutputStreamWriter(baos, "ISO-8859-1");
-        xml = CacheXmlParser.parse(stream);
+        xml = CacheXmlParser.parse(is);
-          "Input Stream could not be read for system property substitutions.");
+          "Input Stream could not be read for system property substitutions.", e);
+      closeQuietly(reader);
+      closeQuietly(stringWriter);
+      closeQuietly(writer);
+    }
+  }
+
+  private static void closeQuietly(Closeable closeable) { // KIRK
+    try {
+      if (closeable != null) {
+        closeable.close();
+      }
+    } catch (IOException ignore) {
-  public InternalResourceManager getInternalResourceManager() {
+  public final InternalResourceManager getInternalResourceManager() {
-      stopper.checkCancelInProgress(null);
+      this.stopper.checkCancelInProgress(null);
-      // TODO prpersist internationalize this
-  private final ArrayList<SimpleWaiter> riWaiters = new ArrayList<SimpleWaiter>();
+  private final List<SimpleWaiter> riWaiters = new ArrayList<>();
-  private TypeRegistry pdxRegistry; // never changes but is currently only
-                                    // initialized in constructor by unit tests
+  // never changes but is currently only initialized in constructor by unit tests
+  private TypeRegistry pdxRegistry;
-    // GemFireCache.this.getCancelCriterion().checkCancelInProgress(null);
-    int cv = registerInterestsInProgress.decrementAndGet();
+    int numInProgress = this.registerInterestsInProgress.decrementAndGet();
-      logger.debug("registerInterestCompleted: new value = {}", cv);
+      logger.debug("registerInterestCompleted: new value = {}", numInProgress);
-    if (cv == 0) {
-      synchronized (riWaiters) {
-        // TODO double-check
-        cv = registerInterestsInProgress.get();
-        if (cv == 0) { // all clear
+    if (numInProgress == 0) {
+      synchronized (this.riWaiters) {
+        // TODO: get rid of double-check
+        numInProgress = this.registerInterestsInProgress.get();
+        if (numInProgress == 0) { // all clear
-          Iterator it = riWaiters.iterator();
-          while (it.hasNext()) {
-            SimpleWaiter sw = (SimpleWaiter) it.next();
+          for (SimpleWaiter sw : this.riWaiters) {
-          riWaiters.clear();
+          this.riWaiters.clear();
-    // GemFireCache.this.getCancelCriterion().checkCancelInProgress(null);
-    int newVal = registerInterestsInProgress.incrementAndGet();
+    int newVal = this.registerInterestsInProgress.incrementAndGet();
-    GemFireCacheImpl.this.getCancelCriterion().checkCancelInProgress(null);
+    getCancelCriterion().checkCancelInProgress(null);
-    int count = registerInterestsInProgress.get();
-    SimpleWaiter sw = null;
+    int count = this.registerInterestsInProgress.get();
-      synchronized (riWaiters) {
+      SimpleWaiter simpleWaiter = null;
+      synchronized (this.riWaiters) {
-        count = registerInterestsInProgress.get();
+        count = this.registerInterestsInProgress.get();
-          sw = new SimpleWaiter();
-          riWaiters.add(sw);
+          simpleWaiter = new SimpleWaiter();
+          this.riWaiters.add(simpleWaiter);
-      if (sw != null) {
-        sw.doWait();
+      if (simpleWaiter != null) {
+        simpleWaiter.doWait();
-  /**
-   * Wait for given sender queue to flush for given timeout.
-   * 
-   * @param id ID of GatewaySender or AsyncEventQueue
-   * @param isAsyncListener true if this is for an AsyncEventQueue and false if for a GatewaySender
-   * @param maxWaitTime maximum time to wait in seconds; zero or -ve means infinite wait
-   * 
-   * @return zero if maxWaitTime was not breached, -1 if queue could not be found or is closed, and
-   *         elapsed time if timeout was breached
-   */
-  public int waitForSenderQueueFlush(String id, boolean isAsyncListener, int maxWaitTime) {
-    getCancelCriterion().checkCancelInProgress(null);
-    AbstractGatewaySender gatewaySender = null;
-    if (isAsyncListener) {
-      AsyncEventQueueImpl asyncQueue = (AsyncEventQueueImpl) getAsyncEventQueue(id);
-      if (asyncQueue != null) {
-        gatewaySender = (AbstractGatewaySender) asyncQueue.getSender();
-      }
-    } else {
-      gatewaySender = (AbstractGatewaySender) getGatewaySender(id);
-    }
-    RegionQueue rq;
-    final long startTime = System.currentTimeMillis();
-    long elapsedTime;
-    if (maxWaitTime <= 0) {
-      maxWaitTime = Integer.MAX_VALUE;
-    }
-    while (gatewaySender != null && gatewaySender.isRunning()
-        && (rq = gatewaySender.getQueue()) != null) {
-      if (rq.size() == 0) {
-        // return zero since it was not a timeout
-        return 0;
-      }
-      try {
-        Thread.sleep(500);
-        getCancelCriterion().checkCancelInProgress(null);
-      } catch (InterruptedException ie) {
-        Thread.currentThread().interrupt();
-        getCancelCriterion().checkCancelInProgress(ie);
-      }
-      // clear interrupted flag before retry
-      Thread.interrupted();
-      elapsedTime = System.currentTimeMillis() - startTime;
-      if (elapsedTime >= (maxWaitTime * 1000L)) {
-        // return elapsed time
-        return (int) (elapsedTime / 1000L);
-      }
-    }
-    return -1;
-  }
-
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(
-      value = "ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD")
+  @SuppressWarnings("ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD")
-    QUERY_MONITOR_REQUIRED_FOR_RESOURCE_MANAGER = required;
+    queryMonitorRequiredForResourceManager = required;
-    return QUERY_MONITOR_DISABLED_FOR_LOW_MEM;
+    return this.queryMonitorDisabledForLowMem;
-    // @see org.apache.geode.cache.control.ResourceManager#setCriticalHeapPercentage(int)
-        !QUERY_MONITOR_DISABLED_FOR_LOW_MEM && QUERY_MONITOR_REQUIRED_FOR_RESOURCE_MANAGER;
-    // Added for DUnit test purpose, which turns-on and off the this.TEST_MAX_QUERY_EXECUTION_TIME.
-    if (!(this.MAX_QUERY_EXECUTION_TIME > 0 || this.TEST_MAX_QUERY_EXECUTION_TIME > 0
-        || monitorRequired)) {
-      // if this.TEST_MAX_QUERY_EXECUTION_TIME is set, send the QueryMonitor.
+        !this.queryMonitorDisabledForLowMem && queryMonitorRequiredForResourceManager;
+    // Added for DUnit test purpose, which turns-on and off the this.testMaxQueryExecutionTime.
+    if (!(MAX_QUERY_EXECUTION_TIME > 0 || this.testMaxQueryExecutionTime > 0 || monitorRequired)) {
+      // if this.testMaxQueryExecutionTime is set, send the QueryMonitor.
-    // ResourceManager and not overriden by system property.
-    if ((this.MAX_QUERY_EXECUTION_TIME > 0 || this.TEST_MAX_QUERY_EXECUTION_TIME > 0
-        || monitorRequired) && this.queryMonitor == null) {
-      synchronized (queryMonitorLock) {
+    // ResourceManager and not overridden by system property.
+    boolean needQueryMonitor =
+        MAX_QUERY_EXECUTION_TIME > 0 || this.testMaxQueryExecutionTime > 0 || monitorRequired;
+    if (needQueryMonitor && this.queryMonitor == null) {
+      synchronized (this.queryMonitorLock) {
-          int maxTime = MAX_QUERY_EXECUTION_TIME > TEST_MAX_QUERY_EXECUTION_TIME
-              ? MAX_QUERY_EXECUTION_TIME : TEST_MAX_QUERY_EXECUTION_TIME;
+          int maxTime = MAX_QUERY_EXECUTION_TIME > this.testMaxQueryExecutionTime
+              ? MAX_QUERY_EXECUTION_TIME : this.testMaxQueryExecutionTime;
-
-    private boolean notified = false;
+    private boolean notified;
-    public void doWait() {
+    void doWait() {
-          GemFireCacheImpl.this.getCancelCriterion().checkCancelInProgress(null);
+          getCancelCriterion().checkCancelInProgress(null);
-            this.wait(1000);
-          } catch (InterruptedException ex) {
+            wait(1000);
+          } catch (InterruptedException ignore) {
-    public void doNotify() {
+    void doNotify() {
-        this.notifyAll();
+        notifyAll();
-    DM dm = getInternalDistributedSystem().getDistributionManager();
-    Set otherMembers = dm.getOtherDistributionManagerIds();
-    AddCacheServerProfileMessage msg = new AddCacheServerProfileMessage();
-    msg.operateOnLocalCache(this);
+    Set otherMembers = this.dm.getOtherDistributionManagerIds();
+    AddCacheServerProfileMessage message = new AddCacheServerProfileMessage();
+    message.operateOnLocalCache(this);
-      ReplyProcessor21 rp = new ReplyProcessor21(dm, otherMembers);
-      msg.setRecipients(otherMembers);
-      msg.processorId = rp.getProcessorId();
-      dm.putOutgoing(msg);
+      ReplyProcessor21 replyProcessor = new ReplyProcessor21(this.dm, otherMembers);
+      message.setRecipients(otherMembers);
+      message.processorId = replyProcessor.getProcessorId();
+      this.dm.putOutgoing(message);
-        rp.waitForReplies();
-      } catch (InterruptedException ie) {
+        replyProcessor.waitForReplies();
+      } catch (InterruptedException ignore) {
-    return this.txMgr;
+    return this.transactionManager;
-  public <K, V> RegionFactory<K, V> createRegionFactory(RegionShortcut atts) {
+  public <K, V> RegionFactory<K, V> createRegionFactory(RegionShortcut shortcut) {
-      return new RegionFactoryImpl<K, V>(this, atts);
+      return new RegionFactoryImpl<>(this, shortcut);
-    return new RegionFactoryImpl<K, V>(this);
+    return new RegionFactoryImpl<>(this);
-    return new RegionFactoryImpl<K, V>(this, regionAttributesId);
+    return new RegionFactoryImpl<>(this, regionAttributesId);
-    return new RegionFactoryImpl<K, V>(this, regionAttributes);
+    return new RegionFactoryImpl<>(this, regionAttributes);
-  public <K, V> ClientRegionFactory<K, V> createClientRegionFactory(ClientRegionShortcut atts) {
-    return new ClientRegionFactoryImpl<K, V>(this, atts);
+  public <K, V> ClientRegionFactory<K, V> createClientRegionFactory(ClientRegionShortcut shortcut) {
+    return new ClientRegionFactoryImpl<>(this, shortcut);
-  public <K, V> ClientRegionFactory<K, V> createClientRegionFactory(String refid) {
-    return new ClientRegionFactoryImpl<K, V>(this, refid);
+  public <K, V> ClientRegionFactory<K, V> createClientRegionFactory(String regionAttributesId) {
+    return new ClientRegionFactoryImpl<>(this, regionAttributesId);
-    Pool p = PoolManager.find(poolName);
-    if (p == null) {
+    Pool pool = PoolManager.find(poolName);
+    if (pool == null) {
-      return p.getQueryService();
+      return pool.getQueryService();
-  public RegionService createAuthenticatedView(Properties properties) {
+  public RegionService createAuthenticatedView(Properties userSecurityProperties) {
-    return createAuthenticatedCacheView(pool, properties);
+    return createAuthenticatedCacheView(pool, userSecurityProperties);
-  public RegionService createAuthenticatedView(Properties properties, String poolName) {
+  public RegionService createAuthenticatedView(Properties userSecurityProperties, String poolName) {
-    return createAuthenticatedCacheView(pool, properties);
+    return createAuthenticatedCacheView(pool, userSecurityProperties);
-  public RegionService createAuthenticatedCacheView(Pool pool, Properties properties) {
+  private static RegionService createAuthenticatedCacheView(Pool pool, Properties properties) {
-  public static void initializeRegionShortcuts(Cache c) {
-    for (RegionShortcut pra : RegionShortcut.values()) {
-      switch (pra) {
+  public static void initializeRegionShortcuts(Cache cache) {
+    for (RegionShortcut shortcut : RegionShortcut.values()) {
+      switch (shortcut) {
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          throw new IllegalStateException("unhandled enum " + pra);
+          throw new IllegalStateException("unhandled enum " + shortcut);
-  public static void initializeClientRegionShortcuts(Cache c) {
-    for (ClientRegionShortcut pra : ClientRegionShortcut.values()) {
-      switch (pra) {
+  public static void initializeClientRegionShortcuts(Cache cache) {
+    for (ClientRegionShortcut shortcut : ClientRegionShortcut.values()) {
+      switch (shortcut) {
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          c.setRegionAttributes(pra.toString(), af.create());
+          cache.setRegionAttributes(shortcut.toString(), af.create());
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          UserSpecifiedRegionAttributes ra = (UserSpecifiedRegionAttributes) af.create();
-          ra.requiresPoolName = true;
-          c.setRegionAttributes(pra.toString(), ra);
+          UserSpecifiedRegionAttributes<?, ?> attributes =
+              (UserSpecifiedRegionAttributes) af.create();
+          attributes.requiresPoolName = true;
+          cache.setRegionAttributes(shortcut.toString(), attributes);
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          UserSpecifiedRegionAttributes ra = (UserSpecifiedRegionAttributes) af.create();
-          ra.requiresPoolName = true;
-          c.setRegionAttributes(pra.toString(), ra);
+          UserSpecifiedRegionAttributes<?, ?> attributes =
+              (UserSpecifiedRegionAttributes) af.create();
+          attributes.requiresPoolName = true;
+          cache.setRegionAttributes(shortcut.toString(), attributes);
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          UserSpecifiedRegionAttributes ra = (UserSpecifiedRegionAttributes) af.create();
-          ra.requiresPoolName = true;
-          c.setRegionAttributes(pra.toString(), ra);
+          UserSpecifiedRegionAttributes<?, ?> attributes =
+              (UserSpecifiedRegionAttributes) af.create();
+          attributes.requiresPoolName = true;
+          cache.setRegionAttributes(shortcut.toString(), attributes);
-          AttributesFactory af = new AttributesFactory();
+          AttributesFactory<?, ?> af = new AttributesFactory();
-          UserSpecifiedRegionAttributes ra = (UserSpecifiedRegionAttributes) af.create();
-          ra.requiresPoolName = true;
-          c.setRegionAttributes(pra.toString(), ra);
+          UserSpecifiedRegionAttributes<?, ?> attributes =
+              (UserSpecifiedRegionAttributes) af.create();
+          attributes.requiresPoolName = true;
+          cache.setRegionAttributes(shortcut.toString(), attributes);
-          throw new IllegalStateException("unhandled enum " + pra);
+          throw new IllegalStateException("unhandled enum " + shortcut);
-  public DistributedRegion getRegionInDestroy(String path) {
+  DistributedRegion getRegionInDestroy(String path) {
-   *
-    if ((getPdxReadSerialized() || DefaultQuery.getPdxReadSerialized())
-        && PdxInstanceImpl.getPdxReadSerialized()) {
-      return true;
-    }
-    return false;
+    return (getPdxReadSerialized() || DefaultQuery.getPdxReadSerialized())
+        && PdxInstanceImpl.getPdxReadSerialized();
+  @Override
-
-    return resourceAdvisor;
+    return this.resourceAdvisor;
-    return resourceAdvisor.createProfile();
+    return this.resourceAdvisor.createProfile();
-    resourceManager.fillInProfile(profile);
+    this.resourceManager.fillInProfile(profile);
-  public TXEntryStateFactory getTXEntryStateFactory() {
+  TXEntryStateFactory getTXEntryStateFactory() {
-  public void setPdxSerializer(PdxSerializer v) {
-    this.cacheConfig.setPdxSerializer(v);
-    basicSetPdxSerializer(v);
+  public void setPdxSerializer(PdxSerializer serializer) {
+    this.cacheConfig.setPdxSerializer(serializer);
+    basicSetPdxSerializer(serializer);
-  private void basicSetPdxSerializer(PdxSerializer v) {
-    TypeRegistry.setPdxSerializer(v);
-    if (v instanceof ReflectionBasedAutoSerializer) {
-      AutoSerializableManager asm =
-          (AutoSerializableManager) ((ReflectionBasedAutoSerializer) v).getManager();
-      if (asm != null) {
-        asm.setRegionService(this);
+  private void basicSetPdxSerializer(PdxSerializer serializer) {
+    TypeRegistry.setPdxSerializer(serializer);
+    if (serializer instanceof ReflectionBasedAutoSerializer) {
+      AutoSerializableManager autoSerializableManager =
+          (AutoSerializableManager) ((ReflectionBasedAutoSerializer) serializer).getManager();
+      if (autoSerializableManager != null) {
+        autoSerializableManager.setRegionService(this);
-  public void setReadSerialized(boolean v) {
-    this.cacheConfig.setPdxReadSerialized(v);
+  public void setReadSerialized(boolean value) {
+    this.cacheConfig.setPdxReadSerialized(value);
-      for (Map.Entry<Declarable, Properties> newEntry : mapOfNewDeclarableProps.entrySet()) {
+      for (Entry<Declarable, Properties> newEntry : mapOfNewDeclarableProps.entrySet()) {
-        Class clazz = newEntry.getKey().getClass();
+        Class<? extends Declarable> clazz = newEntry.getKey().getClass();
-        Object matchingDeclarable = null;
-        for (Map.Entry<Declarable, Properties> oldEntry : this.declarablePropertiesMap.entrySet()) {
-          if (clazz.getName().equals(oldEntry.getKey().getClass().getName()) && (newEntry.getValue()
-              .equals(oldEntry.getValue())
-              || ((newEntry.getKey() instanceof Identifiable) && (((Identifiable) oldEntry.getKey())
-                  .getId().equals(((Identifiable) newEntry.getKey()).getId()))))) {
+        Declarable matchingDeclarable = null;
+        for (Entry<Declarable, Properties> oldEntry : this.declarablePropertiesMap.entrySet()) {
+          boolean isKeyClassSame = clazz.getName().equals(oldEntry.getKey().getClass().getName());
+          boolean isValueEqual = newEntry.getValue().equals(oldEntry.getValue());
+          boolean isKeyIdentifiableAndSameId =
+              Identifiable.class.isInstance(newEntry.getKey()) && ((Identifiable) oldEntry.getKey())
+                  .getId().equals(((Identifiable) newEntry.getKey()).getId());
+          if (isKeyClassSame && (isValueEqual || isKeyIdentifiableAndSameId)) {
-  public static boolean isXmlParameterizationEnabled() {
-    return xmlParameterizationEnabled;
-  }
-
-  public static void setXmlParameterizationEnabled(boolean isXmlParameterizationEnabled) {
-    xmlParameterizationEnabled = isXmlParameterizationEnabled;
-  }
-
-  private Properties initializerProps;
-  /**
-   * A factory for temporary result sets than can overflow to disk.
-   */
-  private TemporaryResultSetFactory resultSetFactory;
+  private Properties initializerProps;
-  public PdxInstanceFactory createPdxInstanceFactory(String className, boolean b) {
-    return PdxInstanceFactoryImpl.newCreator(className, b);
+  public PdxInstanceFactory createPdxInstanceFactory(String className, boolean expectDomainClass) {
+    return PdxInstanceFactoryImpl.newCreator(className, expectDomainClass);
-  public TemporaryResultSetFactory getResultSetFactory() {
-    return this.resultSetFactory;
-  }
-
-  public DiskStoreMonitor getDiskStoreMonitor() {
-    return diskMonitor;
+  DiskStoreMonitor getDiskStoreMonitor() {
+    return this.diskMonitor;
-    return extensionPoint;
+    return this.extensionPoint;

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 MOV23 MOV23 MOV31 MOV31 UPD40 INS40 UPD40 UPD40 INS40 INS29 INS83 INS42 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS65 UPD83 UPD83 MOV29 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS74 MOV59 INS83 MOV43 INS59 INS74 INS83 INS83 INS39 INS59 INS29 INS83 INS39 MOV59 UPD83 INS74 UPD83 UPD83 UPD83 UPD83 INS29 INS83 INS83 INS74 INS59 UPD83 INS74 UPD83 INS83 INS83 INS29 INS83 MOV43 MOV59 INS29 INS83 INS83 MOV43 MOV59 INS83 INS83 MOV74 INS59 INS83 MOV43 INS59 INS83 MOV43 INS59 INS29 UPD83 UPD83 UPD83 INS83 INS83 UPD83 INS29 INS83 INS39 INS42 INS8 UPD83 UPD83 UPD42 INS29 UPD83 INS83 MOV60 INS83 INS29 MOV29 MOV78 INS83 MOV43 INS42 INS8 MOV78 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS8 INS83 INS39 INS42 MOV44 INS44 MOV44 INS8 MOV78 INS83 INS39 INS42 INS44 INS8 MOV78 INS83 MOV43 INS42 INS8 MOV78 INS83 MOV43 INS42 INS8 MOV29 INS83 INS83 INS39 INS42 MOV44 INS8 INS83 INS83 MOV43 INS42 INS8 INS83 INS83 MOV43 INS59 INS83 INS74 INS74 MOV78 MOV78 INS83 INS73 INS73 INS74 INS42 MOV44 INS44 MOV43 MOV43 INS8 INS83 MOV43 INS42 INS8 MOV78 INS83 INS73 INS73 INS74 INS42 MOV44 INS44 MOV43 MOV43 MOV8 INS73 INS73 INS74 MOV60 INS73 INS73 INS74 INS29 INS83 MOV74 INS42 INS8 MOV8 INS83 MOV43 INS42 MOV44 INS8 INS83 INS74 INS74 INS83 INS74 INS42 MOV44 MOV44 INS8 MOV29 MOV78 INS83 INS39 INS42 MOV44 MOV44 INS8 UPD83 INS29 MOV78 INS83 INS39 INS42 MOV8 MOV44 INS29 INS83 INS83 INS39 INS42 MOV44 INS8 INS29 INS83 INS83 INS39 INS42 MOV44 INS8 MOV78 MOV78 MOV78 MOV65 MOV29 MOV78 INS83 MOV43 INS42 INS8 MOV29 MOV78 INS83 INS39 INS42 INS8 MOV78 INS83 MOV43 INS42 INS8 INS83 INS39 INS42 MOV44 INS8 INS83 INS39 INS42 MOV44 INS8 MOV44 INS29 INS29 INS83 MOV43 INS42 INS8 MOV29 INS78 INS83 MOV74 INS42 INS8 UPD74 MOV60 UPD74 UPD74 MOV74 MOV29 MOV78 INS83 INS39 INS42 MOV44 INS8 UPD43 INS73 INS73 INS74 INS73 INS73 INS74 INS74 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS83 INS74 INS59 MOV29 MOV78 INS83 INS39 INS42 INS8 INS79 INS83 INS39 INS42 MOV44 INS8 INS83 INS39 INS42 INS8 MOV78 INS83 MOV43 INS42 INS8 INS44 MOV29 MOV78 INS83 MOV73 MOV73 MOV74 INS42 MOV8 MOV74 MOV8 MOV29 MOV78 INS83 MOV73 MOV73 MOV74 INS42 MOV44 INS8 MOV78 INS83 MOV73 MOV73 MOV74 INS42 INS44 INS8 INS83 UPD83 INS44 INS83 INS83 INS39 INS42 MOV44 INS8 INS78 MOV78 INS83 MOV43 INS42 INS8 MOV78 INS83 MOV43 INS42 INS8 MOV78 INS83 INS39 INS42 MOV44 INS8 UPD42 MOV44 MOV44 UPD42 INS44 MOV8 INS83 MOV43 INS42 MOV44 INS44 INS8 MOV43 INS42 INS8 INS66 INS65 INS66 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 UPD42 INS42 INS9 INS65 INS42 INS42 INS32 UPD42 INS43 MOV43 MOV43 INS42 MOV43 MOV43 INS74 INS42 INS65 MOV43 MOV43 UPD42 UPD42 INS65 INS43 INS43 INS42 INS14 UPD65 UPD42 MOV43 MOV43 INS74 INS65 INS65 INS42 INS14 INS42 INS42 INS33 INS65 UPD42 INS65 INS41 INS65 UPD42 INS70 MOV60 INS65 MOV65 INS41 INS70 INS41 MOV43 INS42 MOV60 INS54 MOV25 MOV60 INS70 MOV41 INS39 INS42 INS21 INS39 INS42 INS21 INS41 UPD42 MOV41 MOV60 MOV25 INS25 INS41 UPD42 UPD42 INS21 INS41 INS42 INS40 INS70 INS43 INS43 INS43 INS43 UPD42 INS42 INS42 INS43 INS43 INS43 INS74 INS42 INS41 MOV60 INS54 INS41 MOV25 MOV21 UPD42 INS42 INS42 INS43 INS43 INS43 INS74 INS42 INS42 INS42 INS43 INS43 INS43 INS74 INS42 INS42 MOV43 MOV43 MOV43 INS74 INS65 INS60 MOV41 MOV60 INS51 MOV41 MOV21 MOV41 MOV60 INS25 MOV41 MOV60 MOV25 MOV25 MOV43 INS74 MOV43 INS74 MOV43 INS74 INS21 INS60 INS51 INS25 MOV41 INS54 MOV65 INS65 MOV65 INS65 UPD42 INS51 INS65 MOV65 UPD42 INS51 UPD65 INS51 INS51 INS41 MOV25 INS21 INS51 UPD42 MOV25 INS21 INS51 MOV60 INS65 INS65 INS41 MOV43 INS42 INS42 INS51 UPD43 MOV43 UPD43 MOV43 UPD43 UPD74 MOV74 MOV60 INS25 INS41 UPD42 MOV60 MOV43 INS42 MOV41 INS42 INS42 INS42 INS43 MOV43 MOV43 INS42 INS42 INS74 MOV43 MOV43 INS74 MOV43 MOV43 UPD42 INS60 INS60 INS60 INS43 INS42 INS54 MOV43 MOV43 INS42 INS14 MOV25 INS60 INS25 INS25 INS42 INS45 INS21 INS41 INS60 INS41 MOV43 INS42 MOV41 MOV41 INS41 UPD42 INS41 INS43 INS42 INS41 MOV43 INS42 MOV43 INS42 MOV43 INS42 UPD42 INS70 MOV41 INS42 INS41 INS41 INS21 UPD42 INS21 UPD42 INS39 INS42 INS51 INS39 INS42 INS41 INS41 INS42 UPD66 INS65 INS66 INS66 INS65 UPD66 UPD74 UPD66 UPD66 INS66 INS42 INS42 INS45 INS42 MOV43 INS76 INS76 INS74 INS66 INS65 INS66 INS74 UPD74 UPD74 INS66 INS42 INS42 UPD74 MOV74 UPD74 INS66 UPD66 INS43 INS76 INS76 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS74 INS66 UPD74 UPD74 UPD74 UPD74 UPD66 UPD43 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS66 UPD66 INS65 INS66 UPD66 INS22 INS22 MOV8 MOV8 INS66 INS44 INS42 MOV8 INS38 MOV27 MOV42 INS66 INS65 UPD66 INS66 INS65 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS65 UPD66 INS66 UPD66 INS66 INS65 UPD66 INS8 INS66 UPD66 MOV43 UPD42 INS22 INS44 INS40 INS8 INS32 MOV32 INS8 INS12 INS12 INS12 INS8 INS44 INS42 INS8 INS32 INS32 INS12 INS22 INS27 MOV27 MOV27 INS8 INS42 UPD66 UPD74 UPD74 MOV38 MOV38 INS7 INS42 INS74 INS44 INS22 INS8 INS42 INS42 INS42 INS42 INS11 INS74 MOV27 UPD66 MOV27 INS42 INS42 INS42 INS43 INS43 INS43 INS32 INS8 MOV12 INS42 INS27 INS8 MOV43 INS42 INS42 INS42 MOV43 INS43 INS43 INS42 INS42 INS42 MOV43 INS43 INS43 MOV43 INS59 UPD42 UPD42 MOV42 MOV43 MOV43 MOV43 INS22 INS22 INS66 MOV74 INS59 MOV22 MOV22 INS8 INS32 MOV27 INS8 MOV43 MOV32 MOV43 INS76 INS76 MOV43 INS76 INS76 MOV43 INS76 INS76 INS32 INS74 MOV59 MOV22 INS8 INS42 INS8 UPD66 INS8 MOV12 INS66 INS65 UPD66 INS66 INS65 MOV57 INS8 INS66 INS65 MOV57 INS8 INS32 UPD66 UPD66 INS22 INS8 INS22 INS8 INS22 INS66 INS65 UPD66 INS66 INS65 UPD66 UPD42 INS22 INS32 INS22 INS8 INS32 INS22 INS8 INS22 UPD42 INS22 INS66 INS66 INS74 INS22 MOV22 INS8 UPD42 MOV43 MOV43 INS74 INS59 UPD42 UPD74 MOV59 UPD42 MOV43 INS38 INS8 INS42 UPD27 MOV27 INS42 MOV43 MOV43 MOV43 MOV43 INS76 INS76 INS74 MOV43 MOV43 INS59 MOV43 INS59 MOV43 INS59 INS42 INS8 MOV12 UPD74 MOV74 INS39 INS59 MOV32 INS8 INS27 INS8 MOV32 INS7 INS22 INS39 INS59 INS22 INS14 INS14 INS42 INS14 MOV44 MOV44 MOV32 INS8 MOV27 INS22 INS32 INS32 INS32 MOV22 MOV8 INS32 INS22 INS22 INS66 INS66 MOV43 INS66 MOV43 INS42 INS74 INS43 INS60 UPD42 UPD42 UPD42 INS42 UPD42 INS32 INS42 MOV32 INS32 INS42 MOV22 INS32 INS42 MOV32 INS32 INS42 MOV22 INS32 INS42 MOV22 INS32 INS42 MOV22 INS32 INS42 MOV22 INS32 INS42 MOV22 INS66 MOV25 INS52 INS42 INS52 INS42 INS60 UPD42 UPD42 MOV43 INS42 UPD42 INS22 INS22 INS22 MOV32 UPD42 INS66 INS66 UPD66 MOV66 UPD66 MOV66 INS21 INS60 INS8 MOV8 MOV43 MOV8 INS52 INS42 UPD42 UPD42 UPD40 UPD40 UPD40 MOV43 INS42 MOV60 MOV25 UPD40 UPD40 INS22 INS42 UPD42 UPD42 UPD42 INS21 MOV21 INS51 MOV44 INS8 MOV44 INS8 MOV44 INS8 INS25 MOV43 UPD42 MOV42 MOV25 INS42 INS42 INS33 INS42 INS42 INS42 INS45 INS33 INS42 INS9 INS44 INS8 INS52 INS42 INS22 INS70 INS27 INS32 UPD42 INS27 INS21 INS22 UPD42 UPD42 INS42 INS42 INS43 INS43 INS14 MOV43 INS42 INS52 INS42 MOV25 MOV54 MOV21 MOV21 INS11 MOV74 MOV32 UPD42 INS43 INS43 INS43 UPD42 INS11 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS60 INS21 INS22 INS33 MOV60 INS25 INS60 INS25 MOV60 MOV70 INS42 UPD42 INS42 INS42 UPD42 INS42 INS42 INS42 INS22 INS42 UPD42 UPD42 INS52 INS42 INS52 INS42 INS42 MOV14 INS70 MOV42 UPD42 MOV42 INS21 MOV60 INS54 INS22 UPD42 MOV21 UPD42 INS42 INS22 INS22 INS42 INS33 MOV43 INS74 UPD42 INS70 INS24 INS25 INS70 INS22 INS22 INS22 INS22 INS67 INS66 INS21 INS66 INS41 INS42 INS42 INS32 UPD42 INS52 INS42 INS25 MOV21 INS25 INS41 INS52 INS42 INS25 INS52 INS42 INS66 INS66 INS22 UPD42 INS22 UPD42 INS22 INS52 INS42 INS22 INS42 INS33 INS52 INS42 INS25 INS22 INS42 INS33 INS52 INS42 INS60 INS25 INS21 INS21 INS22 UPD42 INS52 INS42 INS52 INS42 INS22 INS43 INS43 INS70 INS52 INS42 INS41 INS43 MOV43 MOV43 INS42 INS14 UPD43 MOV43 UPD42 UPD74 INS22 INS42 INS70 INS22 INS22 MOV22 INS38 INS74 MOV43 INS42 INS33 INS42 INS33 INS42 INS33 INS21 INS21 INS21 INS25 INS42 INS32 INS21 INS42 INS34 INS51 INS60 INS42 INS42 INS52 INS42 INS42 INS27 UPD42 MOV42 UPD42 UPD42 INS52 INS42 UPD74 UPD74 INS42 UPD74 MOV74 INS52 INS42 UPD74 MOV74 INS52 INS42 UPD74 MOV74 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 UPD42 INS50 INS52 INS42 INS22 INS42 INS22 INS42 INS42 UPD42 UPD42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 INS70 INS42 INS42 INS42 INS42 INS52 INS42 INS52 INS42 MOV43 INS42 INS39 INS59 UPD42 UPD42 UPD42 UPD43 MOV42 MOV42 INS45 MOV42 MOV42 INS45 MOV42 MOV42 INS45 MOV42 MOV42 INS45 MOV42 MOV42 INS45 MOV42 MOV42 INS45 MOV42 MOV42 INS45 MOV42 MOV42 INS45 INS32 UPD42 UPD42 INS8 INS22 MOV43 INS59 INS84 UPD74 UPD42 UPD42 INS8 INS22 INS52 INS42 INS22 INS22 INS52 INS42 UPD42 INS52 INS42 MOV43 MOV43 MOV43 INS42 INS32 MOV43 INS59 INS8 INS41 UPD42 UPD42 MOV21 MOV8 INS52 INS42 INS32 INS32 INS8 INS21 INS21 INS21 INS42 INS8 INS74 MOV43 INS42 MOV12 INS52 INS42 INS44 INS42 MOV8 INS42 INS33 INS42 INS42 INS42 INS52 INS7 INS52 INS42 INS22 INS42 INS42 UPD74 MOV74 MOV32 MOV74 MOV32 MOV43 INS11 UPD42 INS42 INS42 INS42 MOV43 INS32 UPD74 INS39 MOV36 INS43 INS59 INS32 INS52 INS42 MOV32 INS8 MOV25 MOV43 INS59 MOV27 INS8 UPD42 MOV43 MOV8 INS53 INS52 INS42 UPD42 UPD74 INS44 MOV32 INS74 MOV44 MOV32 INS8 INS32 INS8 MOV8 INS52 INS42 INS52 INS42 INS52 INS42 MOV43 INS76 INS76 UPD74 INS44 MOV32 INS8 MOV58 INS32 INS8 INS32 INS8 MOV44 MOV32 INS8 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 UPD42 UPD42 INS42 INS42 INS42 MOV43 INS32 INS32 INS22 MOV42 MOV42 INS27 INS8 MOV22 INS8 INS22 INS27 INS8 INS52 INS42 INS52 INS42 INS52 INS42 UPD42 INS52 INS42 INS32 INS8 INS52 INS42 MOV74 INS59 INS38 INS8 INS32 INS7 INS52 INS42 UPD74 INS52 INS42 INS42 INS42 INS22 INS44 INS22 MOV8 INS14 INS42 INS74 UPD74 UPD42 INS74 UPD43 MOV43 INS74 INS52 INS42 MOV43 INS74 INS74 INS44 INS22 INS8 UPD42 INS52 INS42 INS52 INS42 MOV32 MOV27 MOV43 MOV43 MOV43 UPD42 INS32 INS32 INS32 INS27 INS8 INS22 INS42 INS32 INS22 INS8 INS22 INS22 MOV43 INS59 INS22 UPD42 INS27 INS42 INS22 INS22 MOV43 UPD42 INS8 INS8 INS8 INS42 MOV49 INS8 MOV49 INS8 MOV49 INS8 MOV49 INS8 MOV49 INS8 MOV49 INS8 MOV49 INS8 MOV49 INS8 MOV49 INS8 INS49 INS53 INS52 INS42 INS52 INS42 MOV43 MOV44 MOV32 INS8 INS42 MOV32 UPD42 UPD42 INS32 INS42 INS32 INS22 INS22 INS22 INS22 INS21 INS22 INS22 INS52 INS42 INS42 INS32 INS43 INS43 UPD42 MOV60 MOV21 INS52 INS42 INS22 INS52 INS42 INS22 INS52 INS42 INS22 INS22 INS22 INS22 INS22 INS42 INS42 INS42 INS33 INS21 INS21 MOV32 UPD42 INS14 UPD42 UPD42 UPD42 INS44 INS42 INS42 INS42 INS42 INS25 INS60 MOV54 INS32 INS32 INS32 INS21 MOV43 UPD42 INS22 INS22 INS22 INS22 UPD42 INS22 UPD42 INS22 MOV43 INS42 INS42 INS33 UPD42 INS22 INS52 INS42 INS22 UPD42 MOV44 INS42 UPD42 UPD42 INS74 INS32 MOV43 INS11 INS32 UPD42 MOV43 INS42 UPD42 INS42 INS42 UPD74 INS42 INS42 INS32 INS42 INS42 INS42 INS40 INS21 MOV27 MOV8 INS42 INS11 INS54 UPD42 UPD42 INS14 UPD42 INS22 UPD42 INS11 MOV43 INS42 MOV43 UPD42 INS60 INS25 INS21 INS21 INS22 INS42 INS33 MOV60 INS60 INS51 MOV25 INS21 UPD42 MOV32 UPD42 MOV41 UPD45 INS43 INS42 INS25 INS21 INS74 INS42 INS42 INS60 INS25 INS42 INS41 UPD42 INS60 INS21 UPD42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS22 INS33 INS41 INS22 INS21 INS52 INS42 INS22 INS33 INS21 INS25 INS60 UPD42 UPD42 INS60 INS22 INS22 INS42 INS42 INS21 INS60 INS25 INS21 INS21 INS42 INS14 INS32 INS21 INS42 INS42 INS42 MOV22 INS32 UPD42 INS52 INS42 MOV43 INS42 INS52 INS42 UPD42 UPD42 UPD74 MOV74 MOV22 UPD42 INS38 INS43 UPD43 MOV43 MOV43 INS42 MOV43 INS76 INS76 MOV32 MOV43 INS76 INS76 MOV43 MOV43 INS42 INS52 INS42 INS25 UPD42 MOV27 MOV22 UPD42 UPD42 UPD42 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS21 INS22 INS52 INS42 INS42 INS42 INS45 INS42 INS52 INS42 INS21 INS25 INS52 INS42 INS52 INS42 INS42 INS33 INS52 INS42 UPD42 INS22 INS27 INS27 INS52 INS42 INS52 INS42 UPD42 UPD42 UPD40 INS22 UPD42 MOV44 INS74 UPD42 UPD42 INS60 MOV21 MOV60 MOV21 INS60 MOV21 MOV60 MOV21 MOV21 INS60 MOV21 MOV60 MOV21 INS60 MOV21 MOV60 MOV21 MOV21 INS60 MOV21 MOV60 MOV21 INS60 MOV21 MOV60 MOV21 INS60 MOV21 MOV60 MOV21 MOV21 INS60 MOV21 MOV60 MOV21 MOV21 MOV21 INS60 MOV21 MOV60 MOV21 MOV21 MOV60 MOV21 MOV60 MOV21 MOV21 MOV21 MOV60 MOV21 MOV21 MOV60 MOV21 MOV21 MOV60 MOV21 MOV21 MOV21 MOV60 MOV21 MOV21 MOV21 MOV60 MOV21 MOV21 MOV21 MOV60 MOV21 MOV21 MOV21 MOV10 MOV60 MOV21 MOV60 MOV21 MOV21 MOV60 MOV21 MOV21 MOV21 MOV21 INS10 MOV60 MOV21 MOV21 MOV21 MOV21 MOV10 MOV21 INS21 INS21 MOV21 INS21 MOV60 MOV21 MOV21 MOV60 MOV21 INS21 INS10 MOV60 MOV21 INS21 INS10 MOV60 MOV21 MOV21 INS21 INS10 MOV60 MOV21 MOV21 INS21 INS10 MOV60 MOV21 MOV21 INS21 INS10 MOV60 MOV21 MOV60 INS21 INS21 INS10 MOV60 MOV21 MOV60 INS21 INS21 INS10 MOV60 MOV21 MOV21 MOV60 INS21 INS21 INS10 MOV60 MOV21 MOV21 MOV60 INS21 INS21 INS10 INS14 UPD42 UPD42 UPD74 UPD42 MOV60 MOV60 MOV70 MOV25 MOV21 INS32 INS42 UPD45 MOV45 INS42 INS42 INS22 INS74 UPD42 INS52 INS42 UPD42 MOV43 INS74 INS52 INS42 INS52 INS42 INS52 INS42 INS7 INS52 INS42 INS52 INS42 INS22 MOV42 MOV42 MOV32 MOV42 MOV27 MOV42 INS42 UPD42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS32 UPD43 INS7 INS32 INS32 INS22 UPD42 MOV43 INS42 INS42 UPD42 UPD42 MOV43 INS42 UPD74 MOV78 INS27 INS8 MOV43 INS59 INS42 INS42 INS45 INS32 MOV32 INS42 INS42 INS45 INS32 MOV32 INS42 INS42 INS45 INS32 MOV32 INS32 INS52 INS42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 UPD42 INS52 INS42 UPD42 INS52 INS42 INS22 INS22 INS52 INS42 INS52 INS42 UPD43 UPD42 MOV43 UPD42 INS43 INS43 MOV32 MOV42 UPD42 INS74 INS32 INS42 INS42 MOV43 UPD42 MOV27 UPD43 INS42 INS42 INS32 INS42 INS7 MOV43 INS22 MOV8 INS12 MOV43 INS42 UPD42 UPD42 MOV43 MOV32 INS42 MOV8 INS84 UPD42 UPD42 INS52 INS42 INS74 MOV32 MOV43 INS59 INS27 MOV8 INS32 INS32 INS52 INS42 MOV43 INS59 MOV22 INS8 INS7 UPD42 INS42 INS27 MOV8 INS32 MOV43 INS74 UPD42 MOV43 INS59 INS38 INS8 MOV43 INS59 INS32 MOV22 MOV42 UPD42 MOV42 MOV43 INS52 INS42 INS22 INS52 INS42 INS32 INS52 INS42 INS37 INS27 INS8 INS22 MOV74 INS59 MOV74 INS59 INS52 INS42 INS52 INS42 INS32 MOV74 INS59 INS38 INS8 INS32 INS7 UPD74 MOV74 INS27 INS22 INS42 INS32 INS42 INS42 INS42 UPD42 INS32 INS42 UPD42 MOV42 INS74 INS59 UPD42 MOV38 INS8 UPD42 MOV42 MOV33 INS7 INS7 INS7 INS42 INS32 INS52 INS42 INS7 INS27 INS8 INS52 INS42 INS42 INS34 INS22 INS34 MOV21 MOV43 INS22 UPD42 INS52 INS42 UPD42 MOV43 INS74 MOV59 INS74 MOV59 INS74 MOV59 INS74 MOV59 INS74 MOV59 INS74 MOV59 INS74 MOV59 INS74 MOV59 INS74 MOV59 INS74 INS74 INS74 INS74 INS74 INS74 INS74 MOV32 INS74 INS74 MOV32 INS74 INS74 INS74 INS32 INS74 INS32 INS32 INS74 MOV43 INS74 INS32 INS74 INS32 INS74 INS32 INS74 INS32 INS74 INS32 INS74 INS74 INS7 INS32 INS74 INS74 INS7 INS32 INS74 INS74 INS7 INS32 INS74 INS74 INS7 INS32 MOV43 INS27 MOV43 UPD43 INS74 UPD43 MOV44 MOV42 MOV42 INS32 INS22 UPD42 MOV42 INS52 INS42 MOV43 UPD42 UPD42 INS86 MOV43 MOV43 UPD42 INS22 INS33 INS52 INS42 INS22 UPD42 UPD42 MOV42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS22 INS22 INS42 INS42 MOV42 UPD42 MOV32 INS42 UPD42 INS42 MOV14 UPD42 MOV32 UPD42 INS42 INS42 INS42 MOV52 INS42 UPD42 UPD43 MOV43 UPD42 INS27 INS27 INS60 MOV60 INS60 MOV60 INS70 INS25 INS21 MOV21 INS21 INS25 INS25 INS60 INS70 INS21 MOV21 INS21 INS25 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS22 INS22 INS22 INS52 INS42 MOV60 MOV25 MOV60 MOV25 INS52 INS42 INS22 UPD42 INS22 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 MOV43 UPD42 INS43 INS43 MOV32 MOV42 INS42 INS42 INS42 INS22 MOV32 MOV27 INS52 INS42 MOV44 INS8 UPD42 UPD42 UPD42 INS60 UPD42 UPD42 INS43 MOV43 MOV43 MOV43 MOV43 UPD42 INS42 INS11 INS32 INS32 MOV62 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 MOV21 INS25 INS42 INS11 INS22 INS22 INS22 INS32 INS32 MOV62 INS27 INS42 INS42 INS42 MOV43 INS76 INS76 INS42 INS11 INS32 INS21 INS42 INS11 INS42 INS42 INS42 INS42 INS32 INS52 INS42 INS22 INS42 INS22 INS22 INS42 INS21 INS21 INS52 INS42 INS42 INS14 UPD42 INS22 INS42 INS32 INS14 INS42 INS9 INS42 INS14 INS32 INS21 INS42 INS42 INS42 MOV22 INS32 INS32 INS34 INS52 INS42 INS42 INS42 INS22 UPD42 UPD42 MOV42 UPD42 MOV42 UPD43 MOV43 MOV43 MOV43 INS42 MOV32 INS21 INS10 UPD42 UPD42 INS42 MOV14 INS42 MOV14 UPD42 INS42 MOV14 INS42 INS42 INS42 INS32 INS42 INS34 MOV25 INS70 INS21 UPD42 INS42 INS52 INS42 INS52 INS42 UPD42 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 UPD42 MOV40 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV42 UPD42 MOV32 MOV43 INS76 INS76 MOV42 MOV42 MOV40 UPD42 UPD42 MOV32 MOV43 INS76 INS76 UPD42 MOV32 MOV43 INS76 INS76 INS42 INS42 MOV34 UPD42 MOV43 INS76 INS76 INS42 INS42 MOV34 INS42 INS42 INS32 UPD42 MOV43 INS76 INS76 UPD42 MOV32 UPD42 MOV43 INS76 INS76 INS42 INS42 INS32 MOV32 MOV43 INS76 INS76 INS42 INS42 INS32 MOV32 MOV43 INS76 INS76 INS42 INS42 INS32 MOV32 MOV43 INS76 INS76 INS42 INS42 INS32 MOV32 MOV43 INS76 INS76 INS42 INS42 INS32 MOV32 MOV43 INS76 INS76 MOV43 INS76 INS76 UPD42 INS40 INS9 INS42 INS42 INS32 INS42 MOV43 INS76 INS76 MOV43 INS76 INS76 UPD42 INS40 INS9 INS42 INS42 INS32 INS42 MOV43 INS76 INS76 MOV43 INS76 INS76 UPD42 INS40 INS9 INS42 INS42 INS32 INS42 MOV43 INS76 INS76 MOV43 INS76 INS76 UPD42 INS40 INS9 INS42 INS42 INS32 INS42 INS45 INS42 UPD42 INS42 MOV43 INS76 UPD42 UPD74 UPD42 INS60 INS60 INS60 INS42 INS42 UPD42 INS52 INS42 UPD42 INS44 MOV8 INS74 UPD42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 MOV32 MOV14 UPD42 MOV43 MOV43 MOV43 UPD42 INS32 INS27 INS32 INS40 INS39 INS59 INS5 MOV43 INS59 INS44 INS42 INS8 MOV32 INS8 INS32 INS32 MOV32 INS8 INS38 INS8 MOV74 INS59 INS44 INS42 INS8 INS32 INS32 MOV32 INS8 MOV43 INS42 INS40 INS33 INS9 MOV32 INS9 UPD42 INS52 INS42 UPD42 INS52 INS42 UPD42 UPD42 INS52 INS42 UPD42 UPD42 INS74 INS70 UPD42 UPD43 UPD42 UPD42 UPD42 INS52 INS42 INS52 INS42 INS42 INS42 UPD42 INS52 INS42 INS53 UPD42 UPD42 INS8 MOV43 INS59 UPD42 UPD42 INS8 UPD42 INS42 MOV43 UPD42 MOV43 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS27 MOV41 MOV43 MOV32 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS42 UPD42 MOV38 INS36 MOV43 INS32 INS42 INS42 INS32 MOV43 INS42 MOV22 MOV42 UPD42 MOV42 INS52 INS42 INS52 INS42 INS52 INS42 INS7 INS32 MOV43 INS74 INS27 INS22 INS52 INS42 UPD42 INS42 INS42 MOV43 INS11 INS9 UPD74 MOV74 INS27 MOV22 INS42 INS32 INS42 INS42 INS42 INS22 INS42 INS52 INS42 UPD42 INS7 INS22 UPD42 INS22 INS42 INS44 INS22 INS8 INS32 INS22 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 UPD43 INS39 INS59 INS39 INS59 INS39 INS59 MOV43 MOV42 MOV43 INS22 INS22 UPD42 MOV32 MOV44 UPD42 UPD42 INS42 INS42 INS32 INS33 INS42 INS42 INS42 INS32 MOV74 INS85 INS42 INS32 INS43 INS42 MOV60 INS25 INS21 INS21 INS25 INS21 INS42 INS42 INS40 INS32 INS42 INS40 INS21 INS32 INS21 INS21 MOV21 INS21 INS25 INS42 INS32 INS43 INS42 MOV60 INS25 INS60 INS25 INS42 INS42 INS40 INS32 INS42 INS40 INS21 UPD42 INS60 MOV43 MOV43 INS44 INS42 MOV8 INS22 UPD42 UPD42 UPD42 INS22 UPD42 UPD42 MOV14 UPD42 UPD42 INS7 INS14 UPD42 UPD42 MOV32 UPD42 MOV53 UPD42 INS42 MOV11 UPD42 INS21 UPD42 UPD42 UPD42 MOV43 INS42 MOV32 INS42 INS33 UPD45 UPD42 INS9 INS27 INS42 INS42 INS42 INS42 INS22 INS34 INS22 INS42 UPD43 MOV43 INS32 INS34 INS52 INS42 UPD42 INS22 UPD42 INS43 INS42 INS32 INS34 INS42 INS42 INS22 INS52 INS42 UPD42 INS42 INS9 UPD42 UPD42 UPD42 INS52 INS42 INS52 INS42 MOV43 INS42 INS52 INS42 MOV21 INS22 INS42 INS52 INS42 UPD42 INS22 UPD42 UPD42 UPD42 INS42 INS42 MOV32 INS42 MOV32 INS42 MOV27 INS42 UPD42 MOV42 MOV43 MOV43 INS52 INS42 INS52 INS42 UPD42 UPD42 MOV43 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS27 MOV8 INS32 INS7 MOV32 INS8 INS32 UPD42 INS42 INS42 INS32 INS32 INS42 INS32 INS32 INS32 MOV32 INS8 INS32 INS42 INS42 INS27 MOV8 MOV74 INS59 MOV27 INS8 UPD42 INS42 INS42 INS32 MOV43 INS59 UPD42 MOV43 INS42 INS52 INS42 UPD43 UPD42 UPD42 UPD42 MOV43 UPD42 INS52 INS42 UPD42 UPD42 UPD42 UPD74 INS22 INS33 MOV43 INS45 INS42 INS42 UPD42 MOV32 UPD42 MOV43 UPD42 UPD42 UPD42 UPD42 INS32 INS32 INS52 INS42 INS52 INS42 UPD42 INS22 INS42 INS52 INS42 INS42 INS22 INS42 INS52 INS42 INS74 INS52 INS42 INS52 INS42 INS22 INS32 MOV32 INS42 INS86 UPD42 INS86 UPD42 INS27 INS40 INS32 INS42 INS2 INS32 INS21 INS42 INS42 INS45 INS32 INS42 INS42 INS45 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS40 INS32 INS42 INS40 INS21 INS42 INS42 UPD42 INS27 INS40 INS42 INS32 INS21 INS25 INS42 INS42 INS45 INS32 UPD42 INS42 MOV32 INS22 UPD42 INS42 MOV32 UPD42 UPD42 UPD42 INS52 INS42 MOV22 UPD42 UPD42 UPD43 UPD42 MOV43 UPD42 UPD42 INS42 INS42 INS42 INS42 INS52 INS42 INS52 INS42 MOV43 INS22 INS52 INS42 INS57 INS42 MOV32 INS42 INS42 MOV8 MOV43 UPD42 UPD42 UPD42 MOV8 INS22 INS42 INS33 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS32 INS42 INS33 INS42 INS42 INS2 INS32 MOV32 INS8 INS42 INS42 INS74 INS52 INS42 UPD42 UPD42 MOV43 INS22 UPD42 UPD42 INS22 UPD42 MOV43 INS42 INS74 INS52 INS42 MOV43 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS32 INS2 INS42 INS42 INS45 INS32 INS42 INS32 INS32 INS42 INS42 INS21 MOV43 INS52 INS42 MOV43 UPD42 UPD42 UPD42 INS52 INS42 INS42 MOV32 UPD42 UPD42 UPD42 MOV43 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 UPD42 MOV43 INS42 INS42 INS42 INS42 INS45 INS32 INS32 INS42 UPD43 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 INS22 INS52 INS42 DEL66 DEL40 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL83 DEL42 DEL32 DEL83 DEL42 DEL32 DEL42 DEL32 DEL83 DEL83 DEL42 DEL43 DEL42 DEL40 DEL59 DEL23 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL57 DEL42 DEL32 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL40 DEL45 DEL27 DEL32 DEL59 DEL23 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL23 DEL83 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL39 DEL23 DEL42 DEL43 DEL42 DEL43 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL23 DEL42 DEL43 DEL66 DEL65 DEL83 DEL33 DEL66 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL23 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL23 DEL83 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL23 DEL83 DEL42 DEL59 DEL23 DEL83 DEL42 DEL33 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL76 DEL74 DEL42 DEL43 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL40 DEL45 DEL27 DEL32 DEL59 DEL23 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL7 DEL21 DEL40 DEL45 DEL27 DEL45 DEL27 DEL32 DEL45 DEL27 DEL32 DEL45 DEL27 DEL32 DEL45 DEL27 DEL32 DEL45 DEL27 DEL32 DEL45 DEL27 DEL32 DEL45 DEL27 DEL32 DEL32 DEL83 DEL83 DEL42 DEL32 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL62 DEL8 DEL25 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL83 DEL39 DEL42 DEL31 DEL1 DEL14 DEL83 DEL43 DEL42 DEL83 DEL44 DEL31 DEL1 DEL14 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL42 DEL41 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL41 DEL52 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL32 DEL7 DEL21 DEL36 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL40 DEL42 DEL32 DEL42 DEL14 DEL53 DEL8 DEL12 DEL83 DEL52 DEL42 DEL32 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL8 DEL61 DEL8 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL27 DEL36 DEL36 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL45 DEL33 DEL45 DEL40 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL32 DEL42 DEL42 DEL14 DEL41 DEL8 DEL83 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL40 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL61 DEL8 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL83 DEL39 DEL42 DEL31 DEL1 DEL14 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL85 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL33 DEL27 DEL27 DEL42 DEL42 DEL32 DEL40 DEL27 DEL27 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL43 DEL42 DEL44 DEL42 DEL42 DEL33 DEL27 DEL40 DEL27 DEL25 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL2 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL2 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL40 DEL43 DEL42 DEL44 DEL42 DEL42 DEL33 DEL27 DEL40 DEL27 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL2 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL70 DEL42 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL40 DEL33 DEL9 DEL9 DEL14 DEL59 DEL60 DEL8 DEL51 DEL8 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL12 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL12 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL12 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL31 DEL42 DEL43 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL61 DEL8 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL33 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL45 DEL33 DEL42 DEL9 DEL32 DEL21 DEL8 DEL31 DEL42 DEL42 DEL42 DEL44 DEL8 DEL12 DEL42 DEL42 DEL83 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL31 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL59 DEL60 DEL52 DEL42 DEL32 DEL42 DEL7 DEL21 DEL33 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL9 DEL8 DEL25 DEL9 DEL41 DEL42 DEL33 DEL27 DEL83 DEL42 DEL42 DEL52 DEL27 DEL42 DEL42 DEL32 DEL38 DEL27 DEL42 DEL33 DEL7 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL42 DEL83 DEL39 DEL42 DEL39 DEL42 DEL40 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL45 DEL42 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL45 DEL32 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL42 DEL34 DEL40 DEL42 DEL43 DEL14 DEL42 DEL14 DEL7 DEL21 DEL8 DEL31 DEL42 DEL43 DEL42 DEL43 DEL83 DEL42 DEL32 DEL83 DEL42 DEL83 DEL42 DEL32 DEL42 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL40 DEL7 DEL21 DEL8 DEL31 DEL83 DEL83 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL83 DEL42 DEL40 DEL59 DEL23 DEL42 DEL43 DEL83 DEL39 DEL42 DEL42 DEL44 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL38 DEL52 DEL42 DEL22 DEL33 DEL27 DEL42 DEL32 DEL21 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL21 DEL9 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL51 DEL9 DEL41 DEL8 DEL31 DEL42 DEL43 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL45 DEL52 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL37 DEL21 DEL8 DEL42 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL12 DEL54 DEL8 DEL61 DEL8 DEL51 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL45 DEL52 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL52 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL37 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL12 DEL54 DEL8 DEL61 DEL8 DEL51 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL52 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL61 DEL32 DEL32 DEL40 DEL42 DEL43 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL43 DEL40 DEL83 DEL40 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL39 DEL36 DEL11 DEL83 DEL42 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL83 DEL42 DEL31 DEL42 DEL33 DEL32 DEL52 DEL42 DEL22 DEL33 DEL27 DEL8 DEL25 DEL8 DEL42 DEL52 DEL42 DEL22 DEL11 DEL59 DEL60 DEL45 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL33 DEL42 DEL42 DEL41 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL40 DEL32 DEL21 DEL8 DEL54 DEL8 DEL83 DEL42 DEL42 DEL44 DEL31 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL42 DEL83 DEL42 DEL42 DEL42 DEL42 DEL33 DEL32 DEL59 DEL42 DEL33 DEL59 DEL60 DEL11 DEL42 DEL59 DEL60 DEL8 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL53 DEL8 DEL12 DEL83 DEL42 DEL42 DEL11 DEL42 DEL42 DEL42 DEL83 DEL42 DEL43 DEL40 DEL83 DEL42 DEL60 DEL42 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL32 DEL21 DEL8 DEL70 DEL8 DEL51 DEL8 DEL31 DEL32 DEL34 DEL27 DEL8 DEL42 DEL11 DEL42 DEL83 DEL42 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL25 DEL8 DEL51 DEL42 DEL11 DEL7 DEL21 DEL8 DEL54 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL8 DEL11 DEL42 DEL42 DEL9 DEL42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL62 DEL36 DEL38 DEL42 DEL41 DEL8 DEL25 DEL8 DEL25 DEL8 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL42 DEL34 DEL2 DEL32 DEL11 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL34 DEL2 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL33 DEL32 DEL21 DEL33 DEL41 DEL8 DEL25 DEL42 DEL38 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL33 DEL32 DEL21 DEL33 DEL41 DEL8 DEL25 DEL8 DEL51 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL34 DEL2 DEL45 DEL42 DEL34 DEL2 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL34 DEL2 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL62 DEL36 DEL38 DEL27 DEL42 DEL41 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL43 DEL83 DEL42 DEL43 DEL83 DEL83 DEL42 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL36 DEL27 DEL27 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL8 DEL51 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL8 DEL25 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL32 DEL41 DEL25 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL61 DEL8 DEL54 DEL8 DEL31 DEL42 DEL42 DEL42 DEL42 DEL40 DEL66 DEL40 DEL42 DEL67 DEL65 DEL65 DEL29 DEL83 DEL39 DEL42 DEL31 DEL42 DEL43 DEL42 DEL43 DEL32 DEL11 DEL42 DEL43 DEL42 DEL43 DEL52 DEL42 DEL22 DEL32 DEL11 DEL42 DEL44 DEL42 DEL42 DEL59 DEL60 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL51 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL51 DEL8 DEL31 DEL42 DEL45 DEL79 DEL42 DEL43 DEL42 DEL32 DEL11 DEL42 DEL83 DEL42 DEL42 DEL42 DEL33 DEL27 DEL42 DEL41 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL51 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL42 DEL33 DEL27 DEL42 DEL37 DEL21 DEL42 DEL42 DEL27 DEL42 DEL34 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL51 DEL8 DEL31 DEL83 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL43 DEL83 DEL39 DEL42 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL11 DEL9 DEL14 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL51 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL51 DEL8 DEL31 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL83 DEL42 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL11 DEL36 DEL42 DEL32 DEL21 DEL8 DEL24 DEL8 DEL51 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL83 DEL42 DEL52 DEL42 DEL22 DEL42 DEL43 DEL74 DEL14 DEL41 DEL8 DEL51 DEL8 DEL31 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL32 DEL34 DEL27 DEL42 DEL74 DEL11 DEL59 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL40 DEL74 DEL42 DEL11 DEL36 DEL42 DEL43 DEL11 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL43 DEL74 DEL83 DEL39 DEL42 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL38 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL10 DEL8 DEL25 DEL8 DEL61 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL34 DEL36 DEL38 DEL8 DEL9 DEL41 DEL8 DEL25 DEL42 DEL33 DEL27 DEL40 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL42 DEL42 DEL32 DEL11 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL59 DEL60 DEL34 DEL38 DEL42 DEL42 DEL59 DEL60 DEL42 DEL83 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL23 DEL83 DEL39 DEL42 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL34 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL61 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL51 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL52 DEL42 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL59 DEL60 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL40 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL36 DEL33 DEL27 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL34 DEL41 DEL8 DEL25 DEL42 DEL42 DEL34 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL7 DEL21 DEL42 DEL42 DEL34 DEL27 DEL36 DEL27 DEL39 DEL42 DEL34 DEL27 DEL36 DEL11 DEL41 DEL8 DEL25 DEL8 DEL61 DEL34 DEL38 DEL41 DEL8 DEL31 DEL40 DEL42 DEL45 DEL80 DEL77 DEL83 DEL39 DEL42 DEL42 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL34 DEL27 DEL52 DEL42 DEL22 DEL34 DEL27 DEL27 DEL27 DEL36 DEL42 DEL42 DEL42 DEL9 DEL83 DEL42 DEL52 DEL42 DEL32 DEL42 DEL33 DEL32 DEL21 DEL52 DEL83 DEL52 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL42 DEL74 DEL52 DEL42 DEL14 DEL41 DEL83 DEL42 DEL31 DEL83 DEL42 DEL52 DEL42 DEL14 DEL41 DEL8 DEL31 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL14 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL44 DEL42 DEL42 DEL32 DEL10 DEL8 DEL8 DEL8 DEL83 DEL83 DEL39 DEL42 DEL42 DEL44 DEL42 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL10 DEL8 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL10 DEL8 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL10 DEL8 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL10 DEL8 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL10 DEL8 DEL60 DEL40 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL10 DEL8 DEL60 DEL40 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL10 DEL8 DEL60 DEL40 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL10 DEL8 DEL60 DEL40 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL10 DEL8 DEL49 DEL45 DEL42 DEL27 DEL14 DEL53 DEL50 DEL8 DEL70 DEL8 DEL31 DEL83 DEL9 DEL8 DEL25 DEL9 DEL41 DEL83 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL40 DEL40 DEL62 DEL36 DEL36 DEL36 DEL70 DEL51 DEL8 DEL83 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL83 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42
GEODE-4080: Protobuf JSON objects are in a proto string (#1171)

* GEODE-4080: Protobuf JSON objects are in a proto string

In the process, remove a couple of serialization-related classes that
are no longer really applicable.

* Catch `JSONFormatterException` and return it as a `EncodingException`.
* Change some names and add ProtobufSerializationService, which is the big
reason for all this churn.
* Get rid of the codec package
* Inline the serialization type enum
* Make encoding methods throw EncodingException.
* Don't use exceptions for control flow.

This meant renaming ProtobufPrimitiveTypes to ProtobufEncodingTypes.

Signed-off-by: Brian Rowe <browe@pivotal.io>
+import com.google.protobuf.ByteString;
+
+import org.apache.geode.internal.protocol.protobuf.v1.utilities.exception.UnknownProtobufEncodingType;
+import org.apache.geode.internal.protocol.serialization.JsonPdxConverter;
-import org.apache.geode.internal.protocol.serialization.SerializationType;
-import org.apache.geode.internal.protocol.serialization.TypeCodec;
-import org.apache.geode.internal.protocol.serialization.exception.UnsupportedEncodingTypeException;
-import org.apache.geode.internal.protocol.serialization.registry.SerializationCodecRegistry;
-import org.apache.geode.internal.protocol.serialization.registry.exception.CodecNotRegisteredForTypeException;
+import org.apache.geode.internal.protocol.serialization.exception.EncodingException;
+import org.apache.geode.pdx.PdxInstance;
-public class ProtobufSerializationService implements SerializationService<BasicTypes.EncodingType> {
-  private SerializationCodecRegistry serializationCodecRegistry = new SerializationCodecRegistry();
+public class ProtobufSerializationService implements SerializationService<BasicTypes.EncodedValue> {
+  private final JsonPdxConverter jsonPdxConverter = new JsonPdxConverter();
+  /**
+   * @param value the value to be encoded
+   *
+   * @return EncodedValue message with the serialized value
+   * @throws EncodingException
+   */
-  public byte[] encode(BasicTypes.EncodingType encodingTypeValue, Object value)
-      throws UnsupportedEncodingTypeException, CodecNotRegisteredForTypeException {
-    TypeCodec codecForType = getTypeCodecForProtobufType(encodingTypeValue);
-    return codecForType.encode(value);
-  }
-
-  @Override
-  public Object decode(BasicTypes.EncodingType encodingTypeValue, byte[] value)
-      throws UnsupportedEncodingTypeException, CodecNotRegisteredForTypeException {
-    if (encodingTypeValue == BasicTypes.EncodingType.INVALID) {
-      return null;
+  public BasicTypes.EncodedValue encode(Object value) throws EncodingException {
+    BasicTypes.EncodedValue.Builder builder = BasicTypes.EncodedValue.newBuilder();
+    try {
+      ProtobufEncodingTypes protobufEncodingTypes = ProtobufEncodingTypes.valueOf(value.getClass());
+      switch (protobufEncodingTypes) {
+        case INT: {
+          builder.setIntResult((Integer) value);
+          break;
+        }
+        case LONG: {
+          builder.setLongResult((Long) value);
+          break;
+        }
+        case SHORT: {
+          builder.setShortResult((Short) value);
+          break;
+        }
+        case BYTE: {
+          builder.setByteResult((Byte) value);
+          break;
+        }
+        case DOUBLE: {
+          builder.setDoubleResult((Double) value);
+          break;
+        }
+        case FLOAT: {
+          builder.setFloatResult((Float) value);
+          break;
+        }
+        case BINARY: {
+          builder.setBinaryResult(ByteString.copyFrom((byte[]) value));
+          break;
+        }
+        case BOOLEAN: {
+          builder.setBooleanResult((Boolean) value);
+          break;
+        }
+        case STRING: {
+          builder.setStringResult((String) value);
+          break;
+        }
+        case PDX_OBJECT: {
+          builder.setJsonObjectResult(jsonPdxConverter.encode((PdxInstance) value));
+          break;
+        }
+      }
+    } catch (UnknownProtobufEncodingType unknownProtobufEncodingType) {
+      throw new EncodingException("No protobuf encoding for type " + value.getClass().getName());
-    TypeCodec codecForType = getTypeCodecForProtobufType(encodingTypeValue);
-    return codecForType.decode(value);
+    return builder.build();
-  private TypeCodec getTypeCodecForProtobufType(BasicTypes.EncodingType encodingTypeValue)
-      throws UnsupportedEncodingTypeException, CodecNotRegisteredForTypeException {
-    SerializationType serializationTypeForEncodingType =
-        EncodingTypeTranslator.getSerializationTypeForEncodingType(encodingTypeValue);
-
-    return serializationCodecRegistry.getCodecForType(serializationTypeForEncodingType);
+  /**
+   * @param encodedValue - The value to be decoded
+   * @return A decoded object representing encodedValue
+   * @throws EncodingException if the value cannot be decoded.
+   */
+  @Override
+  public Object decode(BasicTypes.EncodedValue encodedValue) throws EncodingException {
+    switch (encodedValue.getValueCase()) {
+      case BINARYRESULT:
+        return encodedValue.getBinaryResult().toByteArray();
+      case BOOLEANRESULT:
+        return encodedValue.getBooleanResult();
+      case BYTERESULT:
+        return (byte) encodedValue.getByteResult();
+      case DOUBLERESULT:
+        return encodedValue.getDoubleResult();
+      case FLOATRESULT:
+        return encodedValue.getFloatResult();
+      case INTRESULT:
+        return encodedValue.getIntResult();
+      case LONGRESULT:
+        return encodedValue.getLongResult();
+      case SHORTRESULT:
+        return (short) encodedValue.getShortResult();
+      case STRINGRESULT:
+        return encodedValue.getStringResult();
+      case JSONOBJECTRESULT:
+        return jsonPdxConverter.decode(encodedValue.getJsonObjectResult());
+      case VALUE_NOT_SET:
+        return null;
+      default:
+        throw new EncodingException(
+            "Unknown Protobuf encoding type: " + encodedValue.getValueCase());
+    }
+
+  /**
+   * Maps classes to encoding for protobuf.
+   *
+   * This currently conflates object type with serialization, which may be an issue if we add more
+   * types of object serialization.
+   */
+  private enum ProtobufEncodingTypes {
+
+    STRING(String.class),
+    INT(Integer.class),
+    LONG(Long.class),
+    SHORT(Short.class),
+    BYTE(Byte.class),
+    BOOLEAN(Boolean.class),
+    DOUBLE(Double.class),
+    FLOAT(Float.class),
+    BINARY(byte[].class),
+
+    // This will probably have to change once the protocol supports multiple object encodings.
+    PDX_OBJECT(PdxInstance.class);
+
+    private Class clazz;
+
+    ProtobufEncodingTypes(Class clazz) {
+      this.clazz = clazz;
+    }
+
+    public static ProtobufEncodingTypes valueOf(Class unencodedValueClass)
+        throws UnknownProtobufEncodingType {
+      for (ProtobufEncodingTypes protobufEncodingTypes : values()) {
+        if (protobufEncodingTypes.clazz.equals(unencodedValueClass)) {
+          return protobufEncodingTypes;
+        }
+      }
+      throw new UnknownProtobufEncodingType(
+          "There is no primitive protobuf type mapping for class:" + unencodedValueClass);
+    }
+  }
+

MOV26 MOV26 UPD40 UPD40 UPD40 UPD40 UPD40 UPD74 INS71 UPD43 INS83 UPD43 INS29 INS43 INS42 UPD43 INS8 INS29 UPD43 INS8 INS29 INS83 INS42 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS23 INS31 INS31 UPD40 UPD42 UPD42 INS65 INS65 INS65 UPD40 MOV40 UPD42 INS60 INS54 INS41 INS65 INS65 INS65 UPD43 UPD42 UPD42 INS50 INS65 INS42 INS57 INS42 INS57 INS42 INS57 INS42 INS57 INS42 INS57 INS42 INS57 INS42 INS57 INS42 INS57 INS42 INS57 INS42 INS57 INS83 INS43 INS59 UPD42 MOV42 MOV44 INS8 INS83 INS83 UPD43 MOV43 INS42 INS44 UPD43 MOV43 MOV8 UPD43 INS42 INS66 INS66 INS42 INS43 INS59 INS8 INS12 INS32 INS42 INS66 INS66 INS42 INS66 UPD40 INS32 INS49 INS41 INS49 INS41 INS49 INS41 INS49 INS41 INS49 INS41 INS49 INS41 INS49 INS41 INS49 INS41 INS49 INS41 INS49 INS41 INS49 MOV41 INS49 INS53 INS66 INS66 INS66 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 MOV5 INS43 INS42 INS42 UPD43 UPD42 INS21 UPD42 INS43 INS42 UPD42 INS70 INS53 UPD42 INS40 INS42 INS32 MOV60 INS50 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS11 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS11 INS42 INS32 INS42 MOV32 INS42 INS14 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS44 INS32 INS8 INS14 INS40 INS42 UPD43 INS42 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS43 INS42 INS53 INS32 INS42 INS42 INS42 INS39 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 INS32 INS43 INS27 INS22 INS42 INS43 INS42 UPD42 MOV42 INS25 INS43 INS27 UPD42 UPD42 INS42 INS21 INS10 INS42 INS21 INS10 INS42 INS21 INS10 INS42 INS21 INS10 INS42 INS21 INS10 INS42 INS21 INS10 INS42 INS21 INS10 INS42 INS21 INS10 INS42 INS21 INS10 INS42 INS21 INS10 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS45 INS32 INS52 INS42 UPD42 MOV42 INS32 INS8 INS42 INS45 INS42 UPD42 INS42 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS43 INS27 INS42 INS42 INS40 UPD42 MOV42 UPD42 MOV42 INS41 UPD42 MOV42 INS42 INS42 INS42 INS11 INS42 INS42 INS11 INS42 INS42 INS11 INS42 INS42 INS11 INS42 INS42 INS11 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS11 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS45 INS32 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS11 INS43 INS42 INS43 INS42 UPD42 MOV42 MOV42 INS11 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV5 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL32 DEL41 DEL8 DEL42 DEL44 DEL42 DEL43 DEL42 DEL40 DEL27 DEL8 DEL25 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL41 DEL8 DEL40 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL41 DEL83 DEL43 DEL31
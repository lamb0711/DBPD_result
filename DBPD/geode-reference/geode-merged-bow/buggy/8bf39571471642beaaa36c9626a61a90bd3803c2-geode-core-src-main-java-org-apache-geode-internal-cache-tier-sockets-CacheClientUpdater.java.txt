Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * <code>CacheClientUpdater</code> is a thread that processes update messages
- * from a cache server and
- * {@linkplain org.apache.geode.cache.Region#localInvalidate(Object) invalidates}
- * the local cache based on the contents of those messages.
+ * <code>CacheClientUpdater</code> is a thread that processes update messages from a cache server
+ * and {@linkplain org.apache.geode.cache.Region#localInvalidate(Object) invalidates} the local
+ * cache based on the contents of those messages.
-public class CacheClientUpdater extends Thread implements ClientUpdater,
-    DisconnectListener {
-  
+public class CacheClientUpdater extends Thread implements ClientUpdater, DisconnectListener {
+
-  
+
-   * true if the constructor successfully created a connection. If false, the
-   * run method for this thread immediately exits.
+   * true if the constructor successfully created a connection. If false, the run method for this
+   * thread immediately exits.
-  
+
-  
+
-  private /*final*/ GemFireCacheImpl cache;
-  private /*final*/ CachedRegionHelper cacheHelper;
-  
-  
+  private /* final */ GemFireCacheImpl cache;
+  private /* final */ CachedRegionHelper cacheHelper;
+
+
-   * Is the client durable
-   * Used for bug 39010 fix 
+   * Is the client durable Used for bug 39010 fix
-   * Added to avoid recording of the event if the concerned operation failed.
-   * See #43247
+   * Added to avoid recording of the event if the concerned operation failed. See #43247
-   * Indicates if full value was requested from server as a result of failure in
-   * applying delta bytes.
+   * Indicates if full value was requested from server as a result of failure in applying delta
+   * bytes.
-//  /**
-//   * True if this thread been initialized. Indicates that the run thread is
-//   * initialized and ready to process messages
-//   * <p>
-//   * TODO is this still needed?
-//   * <p>
-//   * Accesses synchronized via <code>this</code>
-//   * 
-//   * @see #notifyInitializationComplete()
-//   * @see #waitForInitialization()
-//   */
-//  private boolean initialized = false;
+  // /**
+  // * True if this thread been initialized. Indicates that the run thread is
+  // * initialized and ready to process messages
+  // * <p>
+  // * TODO is this still needed?
+  // * <p>
+  // * Accesses synchronized via <code>this</code>
+  // *
+  // * @see #notifyInitializationComplete()
+  // * @see #waitForInitialization()
+  // */
+  // private boolean initialized = false;
-  static private final long MAX_CACHE_WAIT =
-      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "CacheClientUpdater.MAX_WAIT", 120).longValue(); // seconds
+  static private final long MAX_CACHE_WAIT = Long
+      .getLong(DistributionConfig.GEMFIRE_PREFIX + "CacheClientUpdater.MAX_WAIT", 120).longValue(); // seconds
+
+   * 
-        logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_0_ABANDONED_WAIT_DUE_TO_CANCELLATION, this));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.CacheClientUpdater_0_ABANDONED_WAIT_DUE_TO_CANCELLATION, this));
-        logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_0_ABANDONED_WAIT_BECAUSE_IT_IS_NO_LONGER_CONNECTED, this));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.CacheClientUpdater_0_ABANDONED_WAIT_BECAUSE_IT_IS_NO_LONGER_CONNECTED,
+            this));
-        logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_0_WAIT_TIMED_OUT_MORE_THAN_1_SECONDS, new Object[] { this,MAX_CACHE_WAIT }));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.CacheClientUpdater_0_WAIT_TIMED_OUT_MORE_THAN_1_SECONDS,
+            new Object[] {this, MAX_CACHE_WAIT}));
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {
-      }
-      finally {
+      } finally {
-  
+
-   * Creates a new <code>CacheClientUpdater</code> with a given name that
-   * waits for a server to connect on a given port.
+   * Creates a new <code>CacheClientUpdater</code> with a given name that waits for a server to
+   * connect on a given port.
-   * @param name
-   *                descriptive name, used for our ThreadGroup
-   * @param location
-   *                the endpoint we represent
-   * @param primary
-   *                true if our endpoint is primary TODO ask the ep for this?
-   * @param ids
-   *                the system we are distributing messages through
+   * @param name descriptive name, used for our ThreadGroup
+   * @param location the endpoint we represent
+   * @param primary true if our endpoint is primary TODO ask the ep for this?
+   * @param ids the system we are distributing messages through
-   * @throws AuthenticationRequiredException
-   *                 when client is not configured to send credentials using
-   *                 security-* system properties but server expects credentials
-   * @throws AuthenticationFailedException
-   *                 when authentication of the client fails
-   * @throws ServerRefusedConnectionException
-   *                 when handshake fails for other reasons like using durable
-   *                 client ID that is already in use by another client or some
-   *                 server side exception while reading handshake/verifying
-   *                 credentials
+   * @throws AuthenticationRequiredException when client is not configured to send credentials using
+   *         security-* system properties but server expects credentials
+   * @throws AuthenticationFailedException when authentication of the client fails
+   * @throws ServerRefusedConnectionException when handshake fails for other reasons like using
+   *         durable client ID that is already in use by another client or some server side
+   *         exception while reading handshake/verifying credentials
-  public CacheClientUpdater(
-      String name, ServerLocation location,
-      boolean primary, DistributedSystem ids,
-      HandShake handshake, QueueManager qManager, EndpointManager eManager,
-      Endpoint endpoint, int handshakeTimeout,
-      SocketCreator socketCreator) throws AuthenticationRequiredException,
-      AuthenticationFailedException, ServerRefusedConnectionException {
+  public CacheClientUpdater(String name, ServerLocation location, boolean primary,
+      DistributedSystem ids, HandShake handshake, QueueManager qManager, EndpointManager eManager,
+      Endpoint endpoint, int handshakeTimeout, SocketCreator socketCreator)
+      throws AuthenticationRequiredException, AuthenticationFailedException,
+      ServerRefusedConnectionException {
-    this.system = (InternalDistributedSystem)ids;
+    this.system = (InternalDistributedSystem) ids;
-    //this holds the connection which this threads reads
+    // this holds the connection which this threads reads
-      int socketBufferSize = Integer.getInteger(
-          "BridgeServer.SOCKET_BUFFER_SIZE", 32768).intValue();
+      int socketBufferSize =
+          Integer.getInteger("BridgeServer.SOCKET_BUFFER_SIZE", 32768).intValue();
-      mySock = socketCreator.connectForClient(
-          location.getHostName(), location.getPort(), handshakeTimeout, socketBufferSize);
+      mySock = socketCreator.connectForClient(location.getHostName(), location.getPort(),
+          handshakeTimeout, socketBufferSize);
-        logger.debug("Initialized server-to-client socket with send buffer size: {} bytes and receive buffer size: {} bytes", mySock.getSendBufferSize(), mySock.getReceiveBufferSize());
+        logger.debug(
+            "Initialized server-to-client socket with send buffer size: {} bytes and receive buffer size: {} bytes",
+            mySock.getSendBufferSize(), mySock.getReceiveBufferSize());
-        logger.debug("Created connection from {}:{} to CacheClientNotifier on port {} for server-to-client communication", mySock.getInetAddress().getHostAddress(), mySock.getLocalPort(), mySock.getPort());
+        logger.debug(
+            "Created connection from {}:{} to CacheClientNotifier on port {} for server-to-client communication",
+            mySock.getInetAddress().getHostAddress(), mySock.getLocalPort(), mySock.getPort());
-        PoolImpl pool = (PoolImpl)this.qManager.getPool();
+        PoolImpl pool = (PoolImpl) this.qManager.getPool();
-        } 
-        catch (SocketException ignore) {
+        } catch (SocketException ignore) {
-        MemberAttributes ma = new MemberAttributes(0, -1, DistributionManager.NORMAL_DM_TYPE, -1, null, null, null);
-        sid = new InternalDistributedMember(mySock.getInetAddress(), mySock.getPort(), false, true, ma);
+        MemberAttributes ma =
+            new MemberAttributes(0, -1, DistributionManager.NORMAL_DM_TYPE, -1, null, null, null);
+        sid = new InternalDistributedMember(mySock.getInetAddress(), mySock.getPort(), false, true,
+            ma);
-    }
-    catch (ConnectException e) {
+    } catch (ConnectException e) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_0_CONNECTION_WAS_REFUSED, this));
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.CacheClientUpdater_0_CONNECTION_WAS_REFUSED, this));
-    } 
-    catch (SSLException ex) {
+    } catch (SSLException ex) {
-        getSecurityLogger().warning(
-          LocalizedStrings.CacheClientUpdater_0_SSL_NEGOTIATION_FAILED_1,
-          new Object[] { this, ex});
+        getSecurityLogger().warning(LocalizedStrings.CacheClientUpdater_0_SSL_NEGOTIATION_FAILED_1,
+            new Object[] {this, ex});
-          LocalizedStrings.CacheClientUpdater_SSL_NEGOTIATION_FAILED_WITH_ENDPOINT_0
-            .toLocalizedString(location), ex);
+            LocalizedStrings.CacheClientUpdater_SSL_NEGOTIATION_FAILED_WITH_ENDPOINT_0
+                .toLocalizedString(location),
+            ex);
-    } 
-    catch (GemFireSecurityException ex) {
+    } catch (GemFireSecurityException ex) {
-          LocalizedStrings.CacheClientUpdater_0_SECURITY_EXCEPTION_WHEN_CREATING_SERVERTOCLIENT_COMMUNICATION_SOCKET_1,
-          new Object[] {this, ex});
+            LocalizedStrings.CacheClientUpdater_0_SECURITY_EXCEPTION_WHEN_CREATING_SERVERTOCLIENT_COMMUNICATION_SOCKET_1,
+            new Object[] {this, ex});
-    }
-    catch (IOException e) {
-     if (!quitting()) {
-       logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_0_CAUGHT_FOLLOWING_EXECPTION_WHILE_ATTEMPTING_TO_CREATE_A_SERVER_TO_CLIENT_COMMUNICATION_SOCKET_AND_WILL_EXIT_1, new Object[] {this, e}), logger.isDebugEnabled() ? e : null);
-     }
-     eManager.serverCrashed(this.endpoint);
-    }
-    catch (ClassNotFoundException e) {
+    } catch (IOException e) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_CLASS_NOT_FOUND, e.getMessage()));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.CacheClientUpdater_0_CAUGHT_FOLLOWING_EXECPTION_WHILE_ATTEMPTING_TO_CREATE_A_SERVER_TO_CLIENT_COMMUNICATION_SOCKET_AND_WILL_EXIT_1,
+            new Object[] {this, e}), logger.isDebugEnabled() ? e : null);
-    }
-    finally {
+      eManager.serverCrashed(this.endpoint);
+    } catch (ClassNotFoundException e) {
+      if (!quitting()) {
+        logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_CLASS_NOT_FOUND,
+            e.getMessage()));
+      }
+    } finally {
-        try {   
+        try {
-      }
-      else {
+      } else {
-        
+
-          } 
-          catch (IOException ioe) {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_CLOSING_SOCKET_IN_0_FAILED, this), ioe);
+          } catch (IOException ioe) {
+            logger.warn(LocalizedMessage
+                .create(LocalizedStrings.CacheClientUpdater_CLOSING_SOCKET_IN_0_FAILED, this), ioe);
-  
+
-  
+
-  
+
-  
+
-   * Performs the work of the client update thread. Creates a
-   * <code>ServerSocket</code> and waits for the server to connect to it.
+   * Performs the work of the client update thread. Creates a <code>ServerSocket</code> and waits
+   * for the server to connect to it.
-      
+
-        logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_0_NO_CACHE_EXITING, this));
+        logger.warn(
+            LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_0_NO_CACHE_EXITING, this));
-    } 
-    catch (CancelException e) {
+    } catch (CancelException e) {
-    } 
-    finally {
+    } finally {
-//  /**
-//   * Waits for this thread to be initialized
-//   * 
-//   * @return true if initialized; false if stopped before init
-//   */
-//  public boolean waitForInitialization() {
-//    boolean result = false;
-//    // Yogesh : waiting on this thread object is a bad idea
-//    // as when thread exits it notifies to the waiting threads.
-//      synchronized (this) {
-//        for (;;) {
-//          if (quitting()) {
-//            break;
-//          }
-//          boolean interrupted = Thread.interrupted();
-//          try {
-//            this.wait(100); // spurious wakeup ok // timed wait, should fix lost notification problem rahul.
-//          }
-//          catch (InterruptedException e) {
-//            interrupted = true;
-//          }
-//          finally {
-//            if (interrupted) {
-//              Thread.currentThread().interrupt();
-//            }
-//          }
-//        } // while
-//        // Even if we succeed, there is a risk that we were shut down
-//        // Can't check for cache; it isn't set yet :-(
-//        this.system.getCancelCriterion().checkCancelInProgress(null);
-//        result = this.continueProcessing;
-//      } // synchronized
-//    return result;
-//  }
+  // /**
+  // * Waits for this thread to be initialized
+  // *
+  // * @return true if initialized; false if stopped before init
+  // */
+  // public boolean waitForInitialization() {
+  // boolean result = false;
+  // // Yogesh : waiting on this thread object is a bad idea
+  // // as when thread exits it notifies to the waiting threads.
+  // synchronized (this) {
+  // for (;;) {
+  // if (quitting()) {
+  // break;
+  // }
+  // boolean interrupted = Thread.interrupted();
+  // try {
+  // this.wait(100); // spurious wakeup ok // timed wait, should fix lost notification problem
+  // rahul.
+  // }
+  // catch (InterruptedException e) {
+  // interrupted = true;
+  // }
+  // finally {
+  // if (interrupted) {
+  // Thread.currentThread().interrupt();
+  // }
+  // }
+  // } // while
+  // // Even if we succeed, there is a risk that we were shut down
+  // // Can't check for cache; it isn't set yet :-(
+  // this.system.getCancelCriterion().checkCancelInProgress(null);
+  // result = this.continueProcessing;
+  // } // synchronized
+  // return result;
+  // }
-//  /**
-//   * @see #waitForInitialization()
-//   */
-//  private void notifyInitializationComplete() {
-//    synchronized (this) {
-//      this.initialized = true;
-//      this.notifyAll();
-//    }
-//  }
+  // /**
+  // * @see #waitForInitialization()
+  // */
+  // private void notifyInitializationComplete() {
+  // synchronized (this) {
+  // this.initialized = true;
+  // this.notifyAll();
+  // }
+  // }
-   * Stops the updater. It will wait for a while for the thread to finish to try
-   * to prevent duplicates. Note: this method is not named stop because this is
-   * a Thread which has a deprecated stop method.
+   * Stops the updater. It will wait for a while for the thread to finish to try to prevent
+   * duplicates. Note: this method is not named stop because this is a Thread which has a deprecated
+   * stop method.
-        logger.debug("{}: Stopping {}" , this.location, this);
+        logger.debug("{}: Stopping {}", this.location, this);
-        } 
-        catch (VirtualMachineError err) {
+        } catch (VirtualMachineError err) {
-          // If this ever returns, rethrow the error.  We're poisoned
+          // If this ever returns, rethrow the error. We're poisoned
-        }
-        catch (Throwable t) {
+        } catch (Throwable t) {
-          // catch VirtualMachineError (see above).  However, there is
+          // catch VirtualMachineError (see above). However, there is
-     } // !isSelfDestroying
+      } // !isSelfDestroying
-    
+
-   * Creates a cached {@link Message}object whose state is filled in with a
-   * message received from the server.
+   * Creates a cached {@link Message}object whose state is filled in with a message received from
+   * the server.
-    } 
-    catch (IOException e) {
+    } catch (IOException e) {
-        if (logger.isDebugEnabled()){
-          logger.debug("{}: Caught following exception while attempting to initialize a server-to-client communication socket and will exit", this, e);
+        if (logger.isDebugEnabled()) {
+          logger.debug(
+              "{}: Caught following exception while attempting to initialize a server-to-client communication socket and will exit",
+              this, e);
-    return this.getName() + " (" + this.location.getHostName() + ":"
-        + this.location.getPort() + ")";
+    return this.getName() + " (" + this.location.getHostName() + ":" + this.location.getPort()
+        + ")";
-   * @param m
-   *                message containing the data
+   * @param m message containing the data
-    	  logger.debug("Received marker message of length ({} bytes)", m.getPayloadLength());
+        logger.debug("Received marker message of length ({} bytes)", m.getPayloadLength());
-    	  logger.debug("Processed marker message");
+        logger.debug("Processed marker message");
-      String message = 
-        LocalizedStrings.CacheClientUpdater_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_ATTEMPTING_TO_HANDLE_A_MARKER.toLocalizedString();
+      String message =
+          LocalizedStrings.CacheClientUpdater_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_ATTEMPTING_TO_HANDLE_A_MARKER
+              .toLocalizedString();
-   * @param m
-   *                message containing the data
+   * @param m message containing the data
-      boolean isDeltaSent = ((Boolean)m.getPart(partCnt++).getObject())
-          .booleanValue();
+      boolean isDeltaSent = ((Boolean) m.getPart(partCnt++).getObject()).booleanValue();
-      VersionTag versionTag = (VersionTag)m.getPart(partCnt++).getObject();
+      VersionTag versionTag = (VersionTag) m.getPart(partCnt++).getObject();
-      
-      EventID eventId = (EventID)m.getPart(m.getNumberOfParts() - 1)
-          .getObject();
-      boolean withInterest = ((Boolean)isInterestListPassedPart.getObject()).booleanValue();
-      boolean withCQs = ((Boolean)hasCqsPart.getObject()).booleanValue();
+      EventID eventId = (EventID) m.getPart(m.getNumberOfParts() - 1).getObject();
+
+      boolean withInterest = ((Boolean) isInterestListPassedPart.getObject()).booleanValue();
+      boolean withCQs = ((Boolean) hasCqsPart.getObject()).booleanValue();
-        logger.debug("Putting entry for region: {} key: {} create: {}{} callbackArgument: {} withInterest={} withCQs={} eventID={} version={}",
-                regionName, key, isCreate, (valuePart.isObject() ? new StringBuilder(" value: ").append(deserialize(valuePart.getSerializedForm())) : ""), 
+        logger
+            .debug(
+                "Putting entry for region: {} key: {} create: {}{} callbackArgument: {} withInterest={} withCQs={} eventID={} version={}",
+                regionName, key, isCreate,
+                (valuePart.isObject() ? new StringBuilder(" value: ")
+                    .append(deserialize(valuePart.getSerializedForm())) : ""),
-          //newValue = null;  newValue is already null
+          // newValue = null; newValue is already null
-        if (withCQs) { 
+        if (withCQs) {
-      }
-      else if (region.hasServerProxy()
-          && ServerResponseMatrix.checkForValidStateAfterNotification(region,
-              key, m.getMessageType()) && (withInterest || !withCQs)) {
-        @Released EntryEventImpl newEvent = null;
+      } else if (region.hasServerProxy() && ServerResponseMatrix
+          .checkForValidStateAfterNotification(region, key, m.getMessageType())
+          && (withInterest || !withCQs)) {
+        @Released
+        EntryEventImpl newEvent = null;
-          newEvent = EntryEventImpl.create(
-              region,
+          newEvent = EntryEventImpl.create(region,
-                  : Operation.UPDATE), key, null /* newValue */,
-              callbackArgument /* callbackArg */, true /* originRemote */,
+                  : Operation.UPDATE),
+              key, null /* newValue */, callbackArgument /* callbackArg */, true /* originRemote */,
-          region.basicBridgeClientUpdate(eventId.getDistributedMember(), key,
-              newValue, deltaBytes, isValueObject, callbackArgument, m
-                  .getMessageType() == MessageType.LOCAL_CREATE, qManager
-                  .getState().getProcessedMarker()
-                  || !this.isDurableClient, newEvent, eventId);
+          region.basicBridgeClientUpdate(eventId.getDistributedMember(), key, newValue, deltaBytes,
+              isValueObject, callbackArgument, m.getMessageType() == MessageType.LOCAL_CREATE,
+              qManager.getState().getProcessedMarker() || !this.isDurableClient, newEvent, eventId);
-          // bug 45520 - ConcurrentCacheModificationException is not thrown and we must check this flag
-//          if (newEvent.isConcurrencyConflict()) {
-//            return; // this is logged elsewhere at fine level
-//          }
+          // bug 45520 - ConcurrentCacheModificationException is not thrown and we must check this
+          // flag
+          // if (newEvent.isConcurrencyConflict()) {
+          // return; // this is logged elsewhere at fine level
+          // }
-          Part fullValuePart = requestFullValue(eventId,
-              "Caught InvalidDeltaException.");
+          Part fullValuePart = requestFullValue(eventId, "Caught InvalidDeltaException.");
-          region.basicBridgeClientUpdate(eventId.getDistributedMember(), key,
-              newValue, null, isValueObject, callbackArgument, m
-                  .getMessageType() == MessageType.LOCAL_CREATE, qManager
-                  .getState().getProcessedMarker()
-                  || !this.isDurableClient, newEvent, eventId);
+          region.basicBridgeClientUpdate(eventId.getDistributedMember(), key, newValue, null,
+              isValueObject, callbackArgument, m.getMessageType() == MessageType.LOCAL_CREATE,
+              qManager.getState().getProcessedMarker() || !this.isDurableClient, newEvent, eventId);
-          if (newEvent != null) newEvent.release();
+          if (newEvent != null)
+            newEvent.release();
-          logger.debug("Put entry for region: {} key: {} callbackArgument: {}", regionName, key, callbackArgument);
+          logger.debug("Put entry for region: {} key: {} callbackArgument: {}", regionName, key,
+              callbackArgument);
-      
+
-          logger.debug("Received message has CQ Event. Number of cqs interested in the event : {}", numCqsPart.getInt()/2);
-        }        
-        partCnt = processCqs(m, partCnt, numCqsPart.getInt(), m
-            .getMessageType(), key, fullValue, deltaBytes, eventId);
+          logger.debug("Received message has CQ Event. Number of cqs interested in the event : {}",
+              numCqsPart.getInt() / 2);
+        }
+        partCnt = processCqs(m, partCnt, numCqsPart.getInt(), m.getMessageType(), key, fullValue,
+            deltaBytes, eventId);
-      String message = LocalizedStrings.CacheClientUpdater_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_ATTEMPTING_TO_PUT_ENTRY_REGION_0_KEY_1_VALUE_2.toLocalizedString(new Object[] { regionName, key, deserialize(valuePart.getSerializedForm())});
+      String message =
+          LocalizedStrings.CacheClientUpdater_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_ATTEMPTING_TO_PUT_ENTRY_REGION_0_KEY_1_VALUE_2
+              .toLocalizedString(
+                  new Object[] {regionName, key, deserialize(valuePart.getSerializedForm())});
-    Part result = (Part)GetEventValueOp.executeOnPrimary(qManager.getPool(),
-        eventId, null);
-    
+    Part result = (Part) GetEventValueOp.executeOnPrimary(qManager.getPool(), eventId, null);
+
-      throw new Exception("Could not retrieve full value for "
-          + eventId);
+      throw new Exception("Could not retrieve full value for " + eventId);
-   * @param m
-   *                message describing the entry
+   * @param m message describing the entry
-      VersionTag versionTag = (VersionTag)m.getPart(partCnt++).getObject();
+      VersionTag versionTag = (VersionTag) m.getPart(partCnt++).getObject();
-      
+
-      boolean withInterest = ((Boolean)isInterestListPassedPart.getObject()).booleanValue();
-      boolean withCQs = ((Boolean)hasCqsPart.getObject()).booleanValue();
-      
+      boolean withInterest = ((Boolean) isInterestListPassedPart.getObject()).booleanValue();
+      boolean withCQs = ((Boolean) hasCqsPart.getObject()).booleanValue();
+
-        logger.debug("Invalidating entry for region: {} key: {} callbackArgument: {} withInterest={} withCQs={} version={}",
+        logger.debug(
+            "Invalidating entry for region: {} key: {} callbackArgument: {} withInterest={} withCQs={} version={}",
-        if (region.hasServerProxy()
-          && (withInterest || !withCQs)) {
-        try {
-          Part eid = m.getPart(m.getNumberOfParts() - 1);
-          EventID eventId = (EventID)eid.getObject();
+        if (region.hasServerProxy() && (withInterest || !withCQs)) {
-            region.basicBridgeClientInvalidate(eventId.getDistributedMember(), key,
-              callbackArgument, qManager.getState().getProcessedMarker() || !this.isDurableClient,
-              eventId, versionTag);
-          } catch (ConcurrentCacheModificationException e) {
-//            return; allow CQs to be processed
-          }
-          this.isOpCompleted = true;
-          //fix for 36615
-          qManager.getState().incrementInvalidatedStats();
+            Part eid = m.getPart(m.getNumberOfParts() - 1);
+            EventID eventId = (EventID) eid.getObject();
+            try {
+              region.basicBridgeClientInvalidate(eventId.getDistributedMember(), key,
+                  callbackArgument,
+                  qManager.getState().getProcessedMarker() || !this.isDurableClient, eventId,
+                  versionTag);
+            } catch (ConcurrentCacheModificationException e) {
+              // return; allow CQs to be processed
+            }
+            this.isOpCompleted = true;
+            // fix for 36615
+            qManager.getState().incrementInvalidatedStats();
-          if (isDebugEnabled) {
-            logger.debug("Invalidated entry for region: {} key: {} callbackArgument: {}", regionName, key, callbackArgument);
+            if (isDebugEnabled) {
+              logger.debug("Invalidated entry for region: {} key: {} callbackArgument: {}",
+                  regionName, key, callbackArgument);
+            }
+          } catch (EntryNotFoundException e) {
+            /* ignore */
+            if (isDebugEnabled && !quitting()) {
+              logger.debug("Already invalidated entry for region: {} key: {} callbackArgument: {}",
+                  regionName, key, callbackArgument);
+            }
+            this.isOpCompleted = true;
-        catch (EntryNotFoundException e) {
-          /*ignore*/
-          if (isDebugEnabled && !quitting()) {
-            logger.debug("Already invalidated entry for region: {} key: {} callbackArgument: {}", regionName, key, callbackArgument);
-          }
-          this.isOpCompleted = true;
-        }
-      }
-    if (withCQs) {
-        // The client may have been registered to receive invalidates for 
+      if (withCQs) {
+        // The client may have been registered to receive invalidates for
-        Part regionOpType = m.getPart(partCnt++); 
+        Part regionOpType = m.getPart(partCnt++);
-          logger.debug("Received message has CQ Event. Number of cqs interested in the event : {}", numCqsPart.getInt() / 2);
+          logger.debug("Received message has CQ Event. Number of cqs interested in the event : {}",
+              numCqsPart.getInt() / 2);
-    }
-    catch (Exception e) {
-      final String message = LocalizedStrings.CacheClientUpdater_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_ATTEMPTING_TO_INVALIDATE_ENTRY_REGION_0_KEY_1.toLocalizedString(new Object[] { regionName, key });
+    } catch (Exception e) {
+      final String message =
+          LocalizedStrings.CacheClientUpdater_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_ATTEMPTING_TO_INVALIDATE_ENTRY_REGION_0_KEY_1
+              .toLocalizedString(new Object[] {regionName, key});
-   * @param m
-   *                message describing the entry
+   * @param m message describing the entry
-      VersionTag versionTag = (VersionTag)m.getPart(partCnt++).getObject();
+      VersionTag versionTag = (VersionTag) m.getPart(partCnt++).getObject();
-      
+
-      
-      boolean withInterest = ((Boolean)isInterestListPassedPart.getObject()).booleanValue();
-      boolean withCQs = ((Boolean)hasCqsPart.getObject()).booleanValue();
+
+      boolean withInterest = ((Boolean) isInterestListPassedPart.getObject()).booleanValue();
+      boolean withCQs = ((Boolean) hasCqsPart.getObject()).booleanValue();
-        logger.debug("Destroying entry for region: {} key: {} callbackArgument: {} withInterest={} withCQs={} version={}",
+        logger.debug(
+            "Destroying entry for region: {} key: {} callbackArgument: {} withInterest={} withCQs={} version={}",
-      
+
-      } 
-      else if (region.hasServerProxy()
-          && (withInterest || !withCQs)) {
+      } else if (region.hasServerProxy() && (withInterest || !withCQs)) {
-          eventId = (EventID)eid.getObject();
+          eventId = (EventID) eid.getObject();
-            region.basicBridgeClientDestroy(eventId.getDistributedMember(),
-              key, callbackArgument, 
-              qManager.getState().getProcessedMarker() || !this.isDurableClient,
-              eventId, versionTag);
+            region.basicBridgeClientDestroy(eventId.getDistributedMember(), key, callbackArgument,
+                qManager.getState().getProcessedMarker() || !this.isDurableClient, eventId,
+                versionTag);
-//            return;  allow CQs to be processed
+            // return; allow CQs to be processed
-            logger.debug("Destroyed entry for region: {} key: {} callbackArgument: {}", regionName, key, callbackArgument);
+            logger.debug("Destroyed entry for region: {} key: {} callbackArgument: {}", regionName,
+                key, callbackArgument);
-        }
-        catch (EntryNotFoundException e) {
-          /*ignore*/
+        } catch (EntryNotFoundException e) {
+          /* ignore */
-            logger.debug("Already destroyed entry for region: {} key: {} callbackArgument: {} eventId={}", regionName, key, callbackArgument, eventId.expensiveToString());
+            logger.debug(
+                "Already destroyed entry for region: {} key: {} callbackArgument: {} eventId={}",
+                regionName, key, callbackArgument, eventId.expensiveToString());
-          logger.debug("Received message has CQ Event. Number of cqs interested in the event : {}", numCqsPart.getInt() / 2);
+          logger.debug("Received message has CQ Event. Number of cqs interested in the event : {}",
+              numCqsPart.getInt() / 2);
-    }
-    catch (Exception e) {
-      String message = LocalizedStrings.CacheClientUpdater_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_ATTEMPTING_TO_DESTROY_ENTRY_REGION_0_KEY_1.toLocalizedString(new Object[] { regionName, key });
+    } catch (Exception e) {
+      String message =
+          LocalizedStrings.CacheClientUpdater_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_ATTEMPTING_TO_DESTROY_ENTRY_REGION_0_KEY_1
+              .toLocalizedString(new Object[] {regionName, key});
-   * @param m
-   *                message describing the region
+   * @param m message describing the region
-      if (((Boolean)hasCqsPart.getObject()).booleanValue()) {
+      if (((Boolean) hasCqsPart.getObject()).booleanValue()) {
-          logger.debug("Received message has CQ Event. Number of cqs interested in the event : {}", numCqsPart.getInt() / 2);
+          logger.debug("Received message has CQ Event. Number of cqs interested in the event : {}",
+              numCqsPart.getInt() / 2);
-      
+
-      String message = LocalizedStrings.CacheClientUpdater_CAUGHT_AN_EXCEPTION_WHILE_ATTEMPTING_TO_DESTROY_REGION_0.toLocalizedString(regionName);
+      String message =
+          LocalizedStrings.CacheClientUpdater_CAUGHT_AN_EXCEPTION_WHILE_ATTEMPTING_TO_DESTROY_REGION_0
+              .toLocalizedString(regionName);
-   * @param m
-   *                message describing the region to clear
+   * @param m message describing the region to clear
-        logger.debug("{}: Received clear region message of length ({} bytes)", this, m.getPayloadLength());
+        logger.debug("{}: Received clear region message of length ({} bytes)", this,
+            m.getPayloadLength());
-          logger.debug("Received message has CQ Event. Number of cqs interested in the event : {}", numCqsPart.getInt() / 2);
+          logger.debug("Received message has CQ Event. Number of cqs interested in the event : {}",
+              numCqsPart.getInt() / 2);
-        partCnt = processCqs(m, partCnt, numCqsPart.getInt(), m
-            .getMessageType(), null, null);
+        partCnt = processCqs(m, partCnt, numCqsPart.getInt(), m.getMessageType(), null, null);
-        region.basicBridgeClientClear(callbackArgument, qManager.getState()
-            .getProcessedMarker() || !this.isDurableClient);
+        region.basicBridgeClientClear(callbackArgument,
+            qManager.getState().getProcessedMarker() || !this.isDurableClient);
-    } 
-    catch (Exception e) {
-      String message = LocalizedStrings.CacheClientUpdater_CAUGHT_THE_FOLLOWING_EXCEPTION_WHILE_ATTEMPTING_TO_CLEAR_REGION_0.toLocalizedString(regionName);
+    } catch (Exception e) {
+      String message =
+          LocalizedStrings.CacheClientUpdater_CAUGHT_THE_FOLLOWING_EXCEPTION_WHILE_ATTEMPTING_TO_CLEAR_REGION_0
+              .toLocalizedString(regionName);
-   * Locally invalidate a region
-   * NOTE: Added as part of bug#38048. The code only takes care of CQ processing.
-   *       Support needs to be added for local region invalidate.
+   * Locally invalidate a region NOTE: Added as part of bug#38048. The code only takes care of CQ
+   * processing. Support needs to be added for local region invalidate.
+   * 
-        logger.debug("{}: Received invalidate region message of length ({} bytes)", this, m.getPayloadLength());
+        logger.debug("{}: Received invalidate region message of length ({} bytes)", this,
+            m.getPayloadLength());
-      partCnt ++; // Part callbackArgumentPart = m.getPart(partCnt++);
+      partCnt++; // Part callbackArgumentPart = m.getPart(partCnt++);
-//      Object callbackArgument = callbackArgumentPart.getObject();
+      // Object callbackArgument = callbackArgumentPart.getObject();
-          logger.debug("Received message has CQ Event. Number of cqs interested in the event : {}", numCqsPart.getInt() / 2);
+          logger.debug("Received message has CQ Event. Number of cqs interested in the event : {}",
+              numCqsPart.getInt() / 2);
-      
+
-      if (region.hasServerProxy()){
+      if (region.hasServerProxy()) {
-        // 
+        //
-        //if (logger.debugEnabled()) {
-        //  logger.debug(toString() + ": Cleared region: " + regionName
-        //               + " callbackArgument: " + callbackArgument);
-        //}
+        // if (logger.debugEnabled()) {
+        // logger.debug(toString() + ": Cleared region: " + regionName
+        // + " callbackArgument: " + callbackArgument);
+        // }
-    } 
-    catch (Exception e) {
-      String message = 
-        LocalizedStrings.CacheClientUpdater_CAUGHT_THE_FOLLOWING_EXCEPTION_WHILE_ATTEMPTING_TO_INVALIDATE_REGION_0.toLocalizedString(regionName);
+    } catch (Exception e) {
+      String message =
+          LocalizedStrings.CacheClientUpdater_CAUGHT_THE_FOLLOWING_EXCEPTION_WHILE_ATTEMPTING_TO_INVALIDATE_REGION_0
+              .toLocalizedString(regionName);
-   * @param msg
-   *                message describing the new instantiators
-   * @param eventId
-   *                eventId of the instantiators
+   * @param msg message describing the new instantiators
+   * @param eventId eventId of the instantiators
-        logger.debug("{}: Received register instantiators message of parts {}", getName(), noOfParts);
+        logger.debug("{}: Received register instantiators message of parts {}", getName(),
+            noOfParts);
-        instantiatorClassName = (String) CacheServerHelper
-            .deserialize(msg.getPart(i).getSerializedForm());
-        String instantiatedClassName = (String) CacheServerHelper
-            .deserialize(msg.getPart(i + 1).getSerializedForm());
+        instantiatorClassName =
+            (String) CacheServerHelper.deserialize(msg.getPart(i).getSerializedForm());
+        String instantiatedClassName =
+            (String) CacheServerHelper.deserialize(msg.getPart(i + 1).getSerializedForm());
-        InternalInstantiator.register(instantiatorClassName, instantiatedClassName, id,
-            false, eventId, null/* context */);
+        InternalInstantiator.register(instantiatorClassName, instantiatedClassName, id, false,
+            eventId, null/* context */);
-      
+
-        logger.debug("{}: Caught following exception while attempting to read Instantiator : {}", this, instantiatorClassName, e);
+        logger.debug("{}: Caught following exception while attempting to read Instantiator : {}",
+            this, instantiatorClassName, e);
-  
+
-    Class dataSerializerClass = null ;
+    Class dataSerializerClass = null;
-//      int numOfClasses = noOfParts - 3; // 1 for ds classname, 1 for ds id and 1 for eventId.
+      // int numOfClasses = noOfParts - 3; // 1 for ds classname, 1 for ds id and 1 for eventId.
-        logger.debug("{}: Received register dataserializer message of parts {}", getName(), noOfParts);
+        logger.debug("{}: Received register dataserializer message of parts {}", getName(),
+            noOfParts);
-      
+
-          String dataSerializerClassName = (String) CacheServerHelper
-              .deserialize(msg.getPart(i).getSerializedForm());
+          String dataSerializerClassName =
+              (String) CacheServerHelper.deserialize(msg.getPart(i).getSerializedForm());
-          InternalDataSerializer.register(dataSerializerClassName, false, eventId, null/* context */, id);
+          InternalDataSerializer.register(dataSerializerClassName, false, eventId,
+              null/* context */, id);
-            String className = (String)CacheServerHelper.deserialize(msg
-                .getPart(i + 3 + j).getSerializedForm());
-            InternalDataSerializer.updateSupportedClassesMap(
-                dataSerializerClassName, className);
+            String className =
+                (String) CacheServerHelper.deserialize(msg.getPart(i + 3 + j).getSerializedForm());
+            InternalDataSerializer.updateSupportedClassesMap(dataSerializerClassName, className);
-            logger.debug("{}: Caught following exception while attempting to read DataSerializer : {}", this, dataSerializerClass, e);
+            logger.debug(
+                "{}: Caught following exception while attempting to read DataSerializer : {}", this,
+                dataSerializerClass, e);
-      
+
-     ///////////////////////////////////////
+      ///////////////////////////////////////
-        logger.debug("{}: Caught following exception while attempting to read DataSerializer : {}", this, dataSerializerClass, e);
+        logger.debug("{}: Caught following exception while attempting to read DataSerializer : {}",
+            this, dataSerializerClass, e);
-  private int processCqs(Message m, int startMessagePart, int numCqParts,
-      int messageType, Object key, Object value) {
-    return processCqs(m, startMessagePart, numCqParts, messageType, key, value,
-        null, null/* eventId */);
+  private int processCqs(Message m, int startMessagePart, int numCqParts, int messageType,
+      Object key, Object value) {
+    return processCqs(m, startMessagePart, numCqParts, messageType, key, value, null,
+        null/* eventId */);
-  private int processCqs(Message m, int startMessagePart, int numCqParts,
-      int messageType, Object key, Object value, byte[] delta, EventID eventId) {
-    //String[] cqs = new String[numCqs/2];
+  private int processCqs(Message m, int startMessagePart, int numCqParts, int messageType,
+      Object key, Object value, byte[] delta, EventID eventId) {
+    // String[] cqs = new String[numCqs/2];
-      for (int cqCnt=0; cqCnt < numCqParts;) {
-        StringBuilder str = null;
+    for (int cqCnt = 0; cqCnt < numCqParts;) {
+      StringBuilder str = null;
+      if (isDebugEnabled) {
+        str = new StringBuilder(100);
+        str.append("found these queries: ");
+      }
+      try {
+        // Get CQ Name.
+        Part cqNamePart = m.getPart(startMessagePart + (cqCnt++));
+        // Get CQ Op.
+        Part cqOpPart = m.getPart(startMessagePart + (cqCnt++));
+        cqs.put(cqNamePart.getString(), Integer.valueOf(cqOpPart.getInt()));
+
+        if (str != null) {
+          str.append(cqNamePart.getString()).append(" op=").append(cqOpPart.getInt()).append("  ");
+        }
+      } catch (Exception ex) {
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.CacheClientUpdater_ERROR_WHILE_PROCESSING_THE_CQ_MESSAGE_PROBLEM_WITH_READING_MESSAGE_FOR_CQ_0,
+            cqCnt));
+      }
+      if (isDebugEnabled && str != null) {
+        logger.debug(str);
+      }
+    }
+
+    {
+      CqService cqService = this.cache.getCqService();
+      try {
+        cqService.dispatchCqListeners(cqs, messageType, key, value, delta, qManager, eventId);
+      } catch (Exception ex) {
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.CacheClientUpdater_FAILED_TO_INVOKE_CQ_DISPATCHER_ERROR___0,
+            ex.getMessage()));
-          str = new StringBuilder(100);
-          str.append("found these queries: ");
-        }
-        try {
-          // Get CQ Name.
-          Part cqNamePart = m.getPart(startMessagePart + (cqCnt++));
-          // Get CQ Op.
-          Part cqOpPart = m.getPart(startMessagePart + (cqCnt++));
-          cqs.put(cqNamePart.getString(), Integer.valueOf(cqOpPart.getInt()));
-
-          if (str != null) {
-             str.append(cqNamePart.getString())
-               .append(" op=").append(cqOpPart.getInt()).append("  ");
-          }
-        } catch (Exception ex) {
-          logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_ERROR_WHILE_PROCESSING_THE_CQ_MESSAGE_PROBLEM_WITH_READING_MESSAGE_FOR_CQ_0, cqCnt));
-        }
-        if (isDebugEnabled && str != null) {
-          logger.debug(str);
+          logger.debug("Failed to invoke CQ Dispatcher.", ex);
-
-      {
-        CqService cqService = this.cache.getCqService();
-        try {
-          cqService.dispatchCqListeners(cqs, messageType, key, value, delta,
-            qManager, eventId);
-        }
-        catch (Exception ex) {
-          logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_FAILED_TO_INVOKE_CQ_DISPATCHER_ERROR___0, ex.getMessage()));
-          if (isDebugEnabled) {
-            logger.debug("Failed to invoke CQ Dispatcher.", ex);
-          }
-        }
-      }
+    }
-        logger.debug("{}: Received add interest message of length ({} bytes)", this, m.getPayloadLength());
+        logger.debug("{}: Received add interest message of length ({} bytes)", this,
+            m.getPayloadLength());
-      receiveUpdatesAsInvalidates = ((Boolean) receiveUpdatesAsInvalidatesPart.getObject()).booleanValue();
+      receiveUpdatesAsInvalidates =
+          ((Boolean) receiveUpdatesAsInvalidatesPart.getObject()).booleanValue();
-      LocalRegion region = (LocalRegion)cacheHelper.getRegion(regionName);
+      LocalRegion region = (LocalRegion) cacheHelper.getRegion(regionName);
-    }
-    catch (Exception e) {
-      String message = ": The following exception occurred while attempting to add interest (region: " + regionName
-         + " key: " + key + "): ";
+    } catch (Exception e) {
+      String message =
+          ": The following exception occurred while attempting to add interest (region: "
+              + regionName + " key: " + key + "): ";
-        logger.debug("{}: Received remove interest message of length ({} bytes)", this, m.getPayloadLength());
+        logger.debug("{}: Received remove interest message of length ({} bytes)", this,
+            m.getPayloadLength());
-        ((Boolean) receiveUpdatesAsInvalidatesPart.getObject()).booleanValue();
+          ((Boolean) receiveUpdatesAsInvalidatesPart.getObject()).booleanValue();
-      LocalRegion region = (LocalRegion)cacheHelper.getRegion(regionName);
+      LocalRegion region = (LocalRegion) cacheHelper.getRegion(regionName);
-        region.getServerProxy().removeSingleInterest(key, interestType,
-            isDurable, receiveUpdatesAsInvalidates);
+        region.getServerProxy().removeSingleInterest(key, interestType, isDurable,
+            receiveUpdatesAsInvalidates);
-    }
-    catch (Exception e) {
-      String message = ": The following exception occurred while attempting to add interest (region: " + regionName
-         + " key: " + key + "): ";
+    } catch (Exception e) {
+      String message =
+          ": The following exception occurred while attempting to add interest (region: "
+              + regionName + " key: " + key + "): ";
-  
-  
+
+
-      LocalRegion region = (LocalRegion)cacheHelper.getRegion(regionName);
+      LocalRegion region = (LocalRegion) cacheHelper.getRegion(regionName);
-        logger.debug("{}: Received tombstone operation for region {} with operation={}", this, region, op);
+        logger.debug("{}: Received tombstone operation for region {} with operation={}", this,
+            region, op);
-      case 0:
-        Map<VersionSource, Long> regionGCVersions = 
-          (Map<VersionSource, Long>)msg.getPart(partIdx++).getObject();
-        EventID eventID = (EventID)msg.getPart(partIdx++).getObject();
-        region.expireTombstones(regionGCVersions, eventID, null);
-        break;
-      case 1:
-        Set<Object> removedKeys = (Set<Object>)msg.getPart(partIdx++).getObject();
-        region.expireTombstoneKeys(removedKeys);
-        break;
-      default:
-        throw new IllegalArgumentException("unknown operation type " + op);
+        case 0:
+          Map<VersionSource, Long> regionGCVersions =
+              (Map<VersionSource, Long>) msg.getPart(partIdx++).getObject();
+          EventID eventID = (EventID) msg.getPart(partIdx++).getObject();
+          region.expireTombstones(regionGCVersions, eventID, null);
+          break;
+        case 1:
+          Set<Object> removedKeys = (Set<Object>) msg.getPart(partIdx++).getObject();
+          region.expireTombstoneKeys(removedKeys);
+          break;
+        default:
+          throw new IllegalArgumentException("unknown operation type " + op);
-    // system that is not the same as our cache.  Check it just in case...
+    // system that is not the same as our cache. Check it just in case...
-  
+
-        logger.info(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater__0_IS_WAITING_FOR_1_TO_COMPLETE, new Object[] {this, this.failedUpdater}));
-        while (this.failedUpdater.isAlive()){
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.CacheClientUpdater__0_IS_WAITING_FOR_1_TO_COMPLETE,
+            new Object[] {this, this.failedUpdater}));
+        while (this.failedUpdater.isAlive()) {
-    }
-    catch (InterruptedException ie) {
+    } catch (InterruptedException ie) {
-    }
-    finally {
-      if (!gotInterrupted && this.failedUpdater != null ) {
-        logger.info(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_0_HAS_COMPLETED_WAITING_FOR_1, new Object[] {this, this.failedUpdater}));
+    } finally {
+      if (!gotInterrupted && this.failedUpdater != null) {
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.CacheClientUpdater_0_HAS_COMPLETED_WAITING_FOR_1,
+            new Object[] {this, this.failedUpdater}));
-      logger.info(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_0_READY_TO_PROCESS_MESSAGES, this));
+      logger.info(LocalizedMessage
+          .create(LocalizedStrings.CacheClientUpdater_0_READY_TO_PROCESS_MESSAGES, this));
-          
+
-            isDeltaSent = ((Boolean)_message.getPart(2).getObject())
-                .booleanValue();
+            isDeltaSent = ((Boolean) _message.getPart(2).getObject()).booleanValue();
-          
+
-          EventID eventId = (EventID)eid.getObject();
+          EventID eventId = (EventID) eid.getObject();
-          if (_message.getMessageType() != MessageType.REGISTER_INSTANTIATORS && _message.getMessageType() != MessageType.REGISTER_DATASERIALIZERS ) {
-            if (this.qManager.getState().verifyIfDuplicate(eventId, !(this.isDurableClient || isDeltaSent))) {
+          if (_message.getMessageType() != MessageType.REGISTER_INSTANTIATORS
+              && _message.getMessageType() != MessageType.REGISTER_DATASERIALIZERS) {
+            if (this.qManager.getState().verifyIfDuplicate(eventId,
+                !(this.isDurableClient || isDeltaSent))) {
-            logger.trace(LogMarker.BRIDGE_SERVER, "Processing event with id {}" + eventId.expensiveToString());
+            logger.trace(LogMarker.BRIDGE_SERVER,
+                "Processing event with id {}" + eventId.expensiveToString());
-          case MessageType.LOCAL_CREATE:
-          case MessageType.LOCAL_UPDATE:
-            handleUpdate(_message);
-            break;
-          case MessageType.LOCAL_INVALIDATE:
-            handleInvalidate(_message);
-            break;
-          case MessageType.LOCAL_DESTROY:
-            handleDestroy(_message);
-            break;
-          case MessageType.LOCAL_DESTROY_REGION:
-            handleDestroyRegion(_message);
-            break;
-          case MessageType.CLEAR_REGION:
-            handleClearRegion(_message);
-            break;
-          case MessageType.REGISTER_INSTANTIATORS:
-            handleRegisterInstantiator(_message, eventId);
-            break;
-          case MessageType.REGISTER_DATASERIALIZERS:
-          handleRegisterDataSerializer(_message, eventId);
-            break;
-          case MessageType.CLIENT_MARKER:
-            handleMarker(_message);
-            break;
-          case MessageType.INVALIDATE_REGION:
-            handleInvalidateRegion(_message);
-            break;
-          case MessageType.CLIENT_REGISTER_INTEREST:
-            handleRegisterInterest(_message);
-            break;
-          case MessageType.CLIENT_UNREGISTER_INTEREST:
-            handleUnregisterInterest(_message);
-            break;
-          case MessageType.TOMBSTONE_OPERATION:
-            handleTombstoneOperation(_message);
-            break;
-          default:
-            logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_0_RECEIVED_AN_UNSUPPORTED_MESSAGE_TYPE_1, new Object[] {this, MessageType.getString(_message.getMessageType())}));
-            break;
+            case MessageType.LOCAL_CREATE:
+            case MessageType.LOCAL_UPDATE:
+              handleUpdate(_message);
+              break;
+            case MessageType.LOCAL_INVALIDATE:
+              handleInvalidate(_message);
+              break;
+            case MessageType.LOCAL_DESTROY:
+              handleDestroy(_message);
+              break;
+            case MessageType.LOCAL_DESTROY_REGION:
+              handleDestroyRegion(_message);
+              break;
+            case MessageType.CLEAR_REGION:
+              handleClearRegion(_message);
+              break;
+            case MessageType.REGISTER_INSTANTIATORS:
+              handleRegisterInstantiator(_message, eventId);
+              break;
+            case MessageType.REGISTER_DATASERIALIZERS:
+              handleRegisterDataSerializer(_message, eventId);
+              break;
+            case MessageType.CLIENT_MARKER:
+              handleMarker(_message);
+              break;
+            case MessageType.INVALIDATE_REGION:
+              handleInvalidateRegion(_message);
+              break;
+            case MessageType.CLIENT_REGISTER_INTEREST:
+              handleRegisterInterest(_message);
+              break;
+            case MessageType.CLIENT_UNREGISTER_INTEREST:
+              handleUnregisterInterest(_message);
+              break;
+            case MessageType.TOMBSTONE_OPERATION:
+              handleTombstoneOperation(_message);
+              break;
+            default:
+              logger.warn(LocalizedMessage.create(
+                  LocalizedStrings.CacheClientUpdater_0_RECEIVED_AN_UNSUPPORTED_MESSAGE_TYPE_1,
+                  new Object[] {this, MessageType.getString(_message.getMessageType())}));
+              break;
-        }
-        catch (InterruptedIOException e) {
+        } catch (InterruptedIOException e) {
-          
+
-        }
-        catch (IOException e) {
+        } catch (IOException e) {
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
-        }
-        finally {
+        } finally {
-    }
-    finally {
+    } finally {
-      //this will make sure that if this thread dies without starting QueueMgr then it will start..
-      //1. above we ignore InterruptedIOException and this thread dies without informing QueueMgr
-      //2. if there is some other race codition with continueProcessing flag
+      // this will make sure that if this thread dies without starting QueueMgr then it will start..
+      // 1. above we ignore InterruptedIOException and this thread dies without informing QueueMgr
+      // 2. if there is some other race codition with continueProcessing flag
-   * Signals run thread to stop. Messages are not printed if the thread or the
-   * distributed system has already been instructed to terminate.
+   * Signals run thread to stop. Messages are not printed if the thread or the distributed system
+   * has already been instructed to terminate.
-   * @param message
-   *                contextual string for the failure
-   * @param exception
-   *                underlying exception
+   * @param message contextual string for the failure
+   * @param exception underlying exception
-      logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_0__1__2, new Object[] {this, message, exception}), exception);
+      logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientUpdater_0__1__2,
+          new Object[] {this, message, exception}), exception);
-   * @param serializedBytes
-   *                the serialized form
+   * @param serializedBytes the serialized form
-      DataInputStream dis = new DataInputStream(new ByteArrayInputStream(
-          serializedBytes));
+      DataInputStream dis = new DataInputStream(new ByteArrayInputStream(serializedBytes));
-   * @see org.apache.geode.distributed.internal.InternalDistributedSystem.DisconnectListener#onDisconnect(org.apache.geode.distributed.internal.InternalDistributedSystem)
+   * @see
+   * org.apache.geode.distributed.internal.InternalDistributedSystem.DisconnectListener#onDisconnect
+   * (org.apache.geode.distributed.internal.InternalDistributedSystem)
+   * 
-  return this.endPointDied;
+    return this.endPointDied;
-  
+
-          new Object[] { type + " buffer size", actualBufferSize, requestedBufferSize }));
+          new Object[] {type + " buffer size", actualBufferSize, requestedBufferSize}));
-   * Stats for a CacheClientUpdater. Currently the only thing measured
-   * are incoming bytes on the wire
+   * Stats for a CacheClientUpdater. Currently the only thing measured are incoming bytes on the
+   * wire
+   * 
-    // static fields 
+    // static fields
-    
+
-      type = f.createType(
-                          "CacheClientUpdaterStats", 
-                          "Statistics about incoming subscription data",
-                          new StatisticDescriptor[] {
-                            f.createLongCounter("receivedBytes",
-                                                "Total number of bytes received from the server.",
-                                                "bytes"),
-                            f.createIntGauge("messagesBeingReceived",
-                                             "Current number of message being received off the network or being processed after reception.",
-                                             "messages"),
-                            f.createLongGauge("messageBytesBeingReceived",
-                                              "Current number of bytes consumed by messages being received or processed.",
-                                              "bytes"),
-                          });
+      type = f.createType("CacheClientUpdaterStats", "Statistics about incoming subscription data",
+          new StatisticDescriptor[] {
+              f.createLongCounter("receivedBytes",
+                  "Total number of bytes received from the server.", "bytes"),
+              f.createIntGauge("messagesBeingReceived",
+                  "Current number of message being received off the network or being processed after reception.",
+                  "messages"),
+              f.createLongGauge("messageBytesBeingReceived",
+                  "Current number of bytes consumed by messages being received or processed.",
+                  "bytes"),});
-    
+
-    
+
+
+
+
+     * 
-    public long startTime()
-    {
+    public long startTime() {

UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66
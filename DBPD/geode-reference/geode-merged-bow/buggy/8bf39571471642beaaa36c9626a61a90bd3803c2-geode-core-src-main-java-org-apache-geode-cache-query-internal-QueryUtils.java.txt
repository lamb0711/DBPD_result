Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-   * Return a SelectResults that is the intersection of c1 and c2. May or may
-   * not return a modified c1 or c2.
+   * Return a SelectResults that is the intersection of c1 and c2. May or may not return a modified
+   * c1 or c2.
-  public static SelectResults intersection(SelectResults c1,
-                                           SelectResults c2,
-                                           ExecutionContext contextOrNull) {
-    QueryObserverHolder.getInstance().invokedQueryUtilsIntersection(c1,c2);
+  public static SelectResults intersection(SelectResults c1, SelectResults c2,
+      ExecutionContext contextOrNull) {
+    QueryObserverHolder.getInstance().invokedQueryUtilsIntersection(c1, c2);
-    if (c1.isEmpty()) { return c1; }
-    if (c2.isEmpty()) { return c2; }
+    if (c1.isEmpty()) {
+      return c1;
+    }
+    if (c2.isEmpty()) {
+      return c2;
+    }
-    }
-    else {
+    } else {
-   * Return a SelectResults that is the union of c1 and c2. May or may not
-   * return a modified c1 or c2.
+   * Return a SelectResults that is the union of c1 and c2. May or may not return a modified c1 or
+   * c2.
-  public static SelectResults union(SelectResults c1,
-                                    SelectResults c2,
-                                    ExecutionContext contextOrNull) {
-    QueryObserverHolder.getInstance().invokedQueryUtilsUnion(c1,c2);
+  public static SelectResults union(SelectResults c1, SelectResults c2,
+      ExecutionContext contextOrNull) {
+    QueryObserverHolder.getInstance().invokedQueryUtilsUnion(c1, c2);
-    }
-    else {
+    } else {
-    Assert.assertTrue(sr1.getCollectionType().getElementType().equals(
-        sr2.getCollectionType().getElementType()));
+    Assert.assertTrue(
+        sr1.getCollectionType().getElementType().equals(sr2.getCollectionType().getElementType()));
-  
-  public static SelectResults createResultCollection(ExecutionContext context, ObjectType elementType) {
-    return context.isDistinct() ? new ResultsSet(elementType) :
-      new ResultsBag(elementType, context.getCachePerfStats());
+
+  public static SelectResults createResultCollection(ExecutionContext context,
+      ObjectType elementType) {
+    return context.isDistinct() ? new ResultsSet(elementType)
+        : new ResultsBag(elementType, context.getCachePerfStats());
-  
-  public static SelectResults createStructCollection(ExecutionContext context, StructType elementType) {
-    return context.isDistinct() ? new StructSet(elementType) :
-      new StructBag(elementType, context.getCachePerfStats()) ;
+
+  public static SelectResults createStructCollection(ExecutionContext context,
+      StructType elementType) {
+    return context.isDistinct() ? new StructSet(elementType)
+        : new StructBag(elementType, context.getCachePerfStats());
-  
+
-    return distinct ? new ResultsSet(elementType) :
-      new ResultsBag(elementType, context.getCachePerfStats());
+    return distinct ? new ResultsSet(elementType)
+        : new ResultsBag(elementType, context.getCachePerfStats());
-  
-  public static SelectResults createStructCollection(boolean distinct, StructType elementType, 
+
+  public static SelectResults createStructCollection(boolean distinct, StructType elementType,
-    return distinct ? new StructSet(elementType) :
-      new StructBag(elementType, context.getCachePerfStats()) ;
+    return distinct ? new StructSet(elementType)
+        : new StructBag(elementType, context.getCachePerfStats());
-  
+
+   * 
-                                                    CachePerfStats statsOrNull) {
+      CachePerfStats statsOrNull) {
+   * 
-                                                    CachePerfStats statsOrNull) {
+      CachePerfStats statsOrNull) {
-    }
-    else if (!collectionType.allowsDuplicates()) {
+    } else if (!collectionType.allowsDuplicates()) {
-    }
-    else {
+    } else {
-      emptyResults = getEmptySelectResults(collectionType.getElementType(),
-                                           statsOrNull);
+      emptyResults = getEmptySelectResults(collectionType.getElementType(), statsOrNull);
-  private static SelectResults sizeSortedIntersection(SelectResults small,
-                                                      SelectResults large,
-                                                      ExecutionContext contextOrNull) {
+  private static SelectResults sizeSortedIntersection(SelectResults small, SelectResults large,
+      ExecutionContext contextOrNull) {
-        for (Iterator itr = small.iterator(); itr.hasNext(); ) {
+        for (Iterator itr = small.iterator(); itr.hasNext();) {
-          if (small.occurrences(element) > count) { // bag intersection: only retain smaller number of dups
+          if (small.occurrences(element) > count) { // bag intersection: only retain smaller number
+                                                    // of dups
-      }
-      catch (UnsupportedOperationException e1) {
+      } catch (UnsupportedOperationException e1) {
-        for (Iterator itr = large.iterator(); itr.hasNext(); ) {
+        for (Iterator itr = large.iterator(); itr.hasNext();) {
-          if (large.occurrences(element) > count) { // bag intersection: only retain smaller number of dups
+          if (large.occurrences(element) > count) { // bag intersection: only retain smaller number
+                                                    // of dups
-      }
-      catch (UnsupportedOperationException e2) {
+      } catch (UnsupportedOperationException e2) {
-    
-    SelectResults rs ;
-    if(contextOrNull != null) {
-        rs =  contextOrNull.isDistinct() ? new ResultsSet(small) :new ResultsBag(small,
-            contextOrNull.getCachePerfStats());
-    }else {
-      rs =new ResultsBag(small,null);
+
+    SelectResults rs;
+    if (contextOrNull != null) {
+      rs = contextOrNull.isDistinct() ? new ResultsSet(small)
+          : new ResultsBag(small, contextOrNull.getCachePerfStats());
+    } else {
+      rs = new ResultsBag(small, null);
-    
-    for (Iterator itr = rs.iterator(); itr.hasNext(); ) {
+
+    for (Iterator itr = rs.iterator(); itr.hasNext();) {
-  
-  private static SelectResults sizeSortedUnion(SelectResults small,
-                                               SelectResults large,
-                                               ExecutionContext contextOrNull) {
+
+  private static SelectResults sizeSortedUnion(SelectResults small, SelectResults large,
+      ExecutionContext contextOrNull) {
-        for (Iterator itr = small.iterator(); itr.hasNext(); ) {
+        for (Iterator itr = small.iterator(); itr.hasNext();) {
-      }
-      catch (UnsupportedOperationException e1) {
+      } catch (UnsupportedOperationException e1) {
-        for (Iterator itr = large.iterator(); itr.hasNext(); ) {
+        for (Iterator itr = large.iterator(); itr.hasNext();) {
-      }
-      catch (UnsupportedOperationException e2) {
+      } catch (UnsupportedOperationException e2) {
-    if(contextOrNull != null) {
-      rs =  contextOrNull.isDistinct() ? new ResultsSet(large) :new ResultsBag(large,
-          contextOrNull.getCachePerfStats());
-    }else {
-      rs =new ResultsBag(large, null);
+    if (contextOrNull != null) {
+      rs = contextOrNull.isDistinct() ? new ResultsSet(large)
+          : new ResultsBag(large, contextOrNull.getCachePerfStats());
+    } else {
+      rs = new ResultsBag(large, null);
-    
-   for (Iterator itr = small.iterator(); itr.hasNext(); ) {
+
+    for (Iterator itr = small.iterator(); itr.hasNext();) {
-   * This function returns a list of runtime iterators in current scope which
-   * are exclusively dependent on given independent RuntimeIterators. The order
-   * of dependent iterators in the List is based on the order of independent
-   * Iterators present in the array . For each group the first iterator is its
-   * independent iterator
+   * This function returns a list of runtime iterators in current scope which are exclusively
+   * dependent on given independent RuntimeIterators. The order of dependent iterators in the List
+   * is based on the order of independent Iterators present in the array . For each group the first
+   * iterator is its independent iterator
-  public static List getDependentItrChainForIndpndntItrs(
-      RuntimeIterator[] indpndntItrs, ExecutionContext context) {
+  public static List getDependentItrChainForIndpndntItrs(RuntimeIterator[] indpndntItrs,
+      ExecutionContext context) {
-      ret.addAll(context
-          .getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(indpndntItrs[k]));
+      ret.addAll(context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(indpndntItrs[k]));
-  } 
-  
+  }
+
-   * This util function does a cartesian of the array of SelectResults
-   * object , expanding the resultant set to the number of iterators passed in
-   * expansionList. The position of the iterator fields in the final result is
-   * governed by the order of RuntimeIterators present in the finalList. If any
-   * condition needs to be evaluated during cartesian , it can be passed as
+   * This util function does a cartesian of the array of SelectResults object , expanding the
+   * resultant set to the number of iterators passed in expansionList. The position of the iterator
+   * fields in the final result is governed by the order of RuntimeIterators present in the
+   * finalList. If any condition needs to be evaluated during cartesian , it can be passed as
-   * @param itrsForResultFields A two dimensional array of RuntimeIterator. Each
-   *          row of this two dimensional RuntimeIterator array , maps to a
-   *          SelectResults object in the results array. Thus the 0th row of two
-   *          dimensional RuntimeIterator array will map to the 0th element of
-   *          the SelectResults array. The order of RuntimeIterator in a row
-   *          will map to the fields in the SelectResults object. The 0th
-   *          RuntimeIterator will map to the 0th field of the corresponding
-   *          SelectResults object. The number of rows in the two
-   *          dimensional array of RuntimeIterator should be equal to the size
-   *          of array of SelectResults object passed and the number of
-   *          RuntimeIterators in each row should be equal to the number of
-   *          fields in the SelectResults object . The SelectResults object
-   *          itself may be a ResultBag object or a StructBag object.
+   * @param itrsForResultFields A two dimensional array of RuntimeIterator. Each row of this two
+   *        dimensional RuntimeIterator array , maps to a SelectResults object in the results array.
+   *        Thus the 0th row of two dimensional RuntimeIterator array will map to the 0th element of
+   *        the SelectResults array. The order of RuntimeIterator in a row will map to the fields in
+   *        the SelectResults object. The 0th RuntimeIterator will map to the 0th field of the
+   *        corresponding SelectResults object. The number of rows in the two dimensional array of
+   *        RuntimeIterator should be equal to the size of array of SelectResults object passed and
+   *        the number of RuntimeIterators in each row should be equal to the number of fields in
+   *        the SelectResults object . The SelectResults object itself may be a ResultBag object or
+   *        a StructBag object.
-   * @param expansionList List containing RunimeIterators to which the final
-   *          Results should be expanded to.
-   * @param finalList List containing RuntimeIterators which define the number
-   *          of fields to be present in the resultant SelectResults and their
-   *          relative positions. The Runtime Iterators present in the List
-   *          should be either available in the expansion List or should be
-   *          present in each row of the two dimensional RuntimeIterator array.
+   * @param expansionList List containing RunimeIterators to which the final Results should be
+   *        expanded to.
+   * @param finalList List containing RuntimeIterators which define the number of fields to be
+   *        present in the resultant SelectResults and their relative positions. The Runtime
+   *        Iterators present in the List should be either available in the expansion List or should
+   *        be present in each row of the two dimensional RuntimeIterator array.
-   * @param operand The CompiledValue which needs to be iter evaluated during
-   *          cartesian. Only those tuples will be selected in the final Result
-   *          for which oerand evaluates to true.
+   * @param operand The CompiledValue which needs to be iter evaluated during cartesian. Only those
+   *        tuples will be selected in the final Result for which oerand evaluates to true.
-   *  
+   * 
-      RuntimeIterator[][] itrsForResultFields, List expansionList,
-      List finalList, ExecutionContext context, CompiledValue operand)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+      RuntimeIterator[][] itrsForResultFields, List expansionList, List finalList,
+      ExecutionContext context, CompiledValue operand) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-      ObjectType type = ((RuntimeIterator) finalList.iterator().next())
-          .getElementType();
+      ObjectType type = ((RuntimeIterator) finalList.iterator().next()).getElementType();
-        returnSet = QueryUtils.createStructCollection(context,(StructTypeImpl) type) ;
-      }
-      else {
+        returnSet = QueryUtils.createStructCollection(context, (StructTypeImpl) type);
+      } else {
-    }
-    else {
+    } else {
-    doNestedIterations(0, returnSet, results, itrsForResultFields, finalList,
-        expnItr, (results.length + expansionList.size()), context, operand);
+    doNestedIterations(0, returnSet, results, itrsForResultFields, finalList, expnItr,
+        (results.length + expansionList.size()), context, operand);
-  //TODO:Optimize the function further in terms of reducing the
+  // TODO:Optimize the function further in terms of reducing the
-      SelectResults[] results, RuntimeIterator[][] itrsForResultFields,
-      List finalItrs, ListIterator expansionItrs, int finalLevel,
-      ExecutionContext context, CompiledValue operand)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+      SelectResults[] results, RuntimeIterator[][] itrsForResultFields, List finalItrs,
+      ListIterator expansionItrs, int finalLevel, ExecutionContext context, CompiledValue operand)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-      //end recusrion
+      // end recusrion
-          
-            ((StructFields) returnSet).addFieldValues(values);
-          
+
+          ((StructFields) returnSet).addFieldValues(values);
+
-      }
-      else {
+      } else {
-            returnSet.add(((RuntimeIterator) itr.next()).evaluate(context));
+          returnSet.add(((RuntimeIterator) itr.next()).evaluate(context));
-    }
-    else if (level < results.length) {
+    } else if (level < results.length) {
-        }
-        else {
+        } else {
-        doNestedIterations(level + 1, returnSet, results, itrsForResultFields,
-            finalItrs, expansionItrs, finalLevel, context, operand);
+        doNestedIterations(level + 1, returnSet, results, itrsForResultFields, finalItrs,
+            expansionItrs, finalLevel, context, operand);
-    }
-    else {
+    } else {
-        //TODO:Asif Check this out
+        // TODO:Asif Check this out
-        doNestedIterations(level + 1, returnSet, results, itrsForResultFields,
-            finalItrs, expansionItrs, finalLevel, context, operand);
+        doNestedIterations(level + 1, returnSet, results, itrsForResultFields, finalItrs,
+            expansionItrs, finalLevel, context, operand);
-  public static boolean applyCondition(CompiledValue operand,
-      ExecutionContext context) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+  public static boolean applyCondition(CompiledValue operand, ExecutionContext context)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-    if(operand == null) return true;
+    if (operand == null)
+      return true;
-    }
-    else if (result != null && result != QueryService.UNDEFINED) {
-      throw new TypeMismatchException(LocalizedStrings.QueryUtils_ANDOR_OPERANDS_MUST_BE_OF_TYPE_BOOLEAN_NOT_TYPE_0.toLocalizedString(result.getClass().getName()));
-    }
-    else {
+    } else if (result != null && result != QueryService.UNDEFINED) {
+      throw new TypeMismatchException(
+          LocalizedStrings.QueryUtils_ANDOR_OPERANDS_MUST_BE_OF_TYPE_BOOLEAN_NOT_TYPE_0
+              .toLocalizedString(result.getClass().getName()));
+    } else {
-  //TODO:Asif This function is used to do cartesian of index resultset while
+  // TODO:Asif This function is used to do cartesian of index resultset while
-  //TODO :Asif :Explain the parameters& Unit test it
-  private static void mergeRelationshipIndexResultsWithIntermediateResults(
-      SelectResults returnSet, SelectResults[] intermediateResults /*
-                                                                    * Asif This
-                                                                    * should be
-                                                                    * a single
-                                                                    * element
-                                                                    * array
-                                                                    */, RuntimeIterator[][] itrsForIntermediateResults /*
-                                                           * Asif This should be
-                                                           * a two dimensional
-                                                           * array but with only
-                                                           * one row
-                                                           */, Object[][] indexResults, RuntimeIterator[][] indexFieldToItrsMapping,
-      ListIterator expansionListItr, List finalItrs, ExecutionContext context,
-      List[] checkList, CompiledValue iterOps,
+  // TODO :Asif :Explain the parameters& Unit test it
+  private static void mergeRelationshipIndexResultsWithIntermediateResults(SelectResults returnSet,
+      SelectResults[] intermediateResults /*
+                                           * Asif This should be a single element array
+                                           */,
+      RuntimeIterator[][] itrsForIntermediateResults /*
+                                                      * Asif This should be a two dimensional array
+                                                      * but with only one row
+                                                      */, Object[][] indexResults,
+      RuntimeIterator[][] indexFieldToItrsMapping, ListIterator expansionListItr, List finalItrs,
+      ExecutionContext context, List[] checkList, CompiledValue iterOps,
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
-//    Object[] checkFields = null;
-//    int len = indexFieldToItrsMapping[level].length;
-//    RuntimeIterator rItr = null;
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
+    // Object[] checkFields = null;
+    // int len = indexFieldToItrsMapping[level].length;
+    // RuntimeIterator rItr = null;
-    //TODO ASif : Since this is constant for a given merge call, pass it as a
+    // TODO ASif : Since this is constant for a given merge call, pass it as a
-    //the function rather than calling it every time
+    // the function rather than calling it every time
-          //Asif :Set the values in the Intermedaite Resultset
-          doNestedIterations(0, returnSet, intermediateResults,
-              itrsForIntermediateResults, finalItrs, expansionListItr,
-              maxExpnCartesianDepth, context, iterOps);
-        }
-        else {
-          mergeRelationshipIndexResultsWithIntermediateResults(returnSet,
-              intermediateResults, itrsForIntermediateResults, indexResults,
-              indexFieldToItrsMapping, expansionListItr, finalItrs, context,
-              checkList, iterOps, icdeh, level + 1, maxExpnCartesianDepth);
+          // Asif :Set the values in the Intermedaite Resultset
+          doNestedIterations(0, returnSet, intermediateResults, itrsForIntermediateResults,
+              finalItrs, expansionListItr, maxExpnCartesianDepth, context, iterOps);
+        } else {
+          mergeRelationshipIndexResultsWithIntermediateResults(returnSet, intermediateResults,
+              itrsForIntermediateResults, indexResults, indexFieldToItrsMapping, expansionListItr,
+              finalItrs, context, checkList, iterOps, icdeh, level + 1, maxExpnCartesianDepth);
-  //TODO:Asif : Test the function & write expnanation of the parameters
-  private static void mergeAndExpandCutDownRelationshipIndexResults(
-      Object[][] values, SelectResults result,
-      RuntimeIterator[][] indexFieldToItrsMapping,
-      ListIterator expansionListIterator, List finalItrs,
-      ExecutionContext context, List[] checkList, CompiledValue iterOps,
-      IndexCutDownExpansionHelper icdeh[], int level)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
-//    int len = indexFieldToItrsMapping[level].length;
-//    RuntimeIterator rItr = null;
+  // TODO:Asif : Test the function & write expnanation of the parameters
+  private static void mergeAndExpandCutDownRelationshipIndexResults(Object[][] values,
+      SelectResults result, RuntimeIterator[][] indexFieldToItrsMapping,
+      ListIterator expansionListIterator, List finalItrs, ExecutionContext context,
+      List[] checkList, CompiledValue iterOps, IndexCutDownExpansionHelper icdeh[], int level)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
+    // int len = indexFieldToItrsMapping[level].length;
+    // RuntimeIterator rItr = null;
-    //stops recursion if limit has already been met
+    // stops recursion if limit has already been met
-    }   
+    }
-      if (setIndexFieldValuesInRespectiveIterators(values[level][j],
-          indexFieldToItrsMapping[level], icdeh[level])) {
+      if (setIndexFieldValuesInRespectiveIterators(values[level][j], indexFieldToItrsMapping[level],
+          icdeh[level])) {
-          doNestedIterationsForIndex(expansionListIterator.hasNext(), result,
-              finalItrs, expansionListIterator, context, iterOps, limit, null);
+          doNestedIterationsForIndex(expansionListIterator.hasNext(), result, finalItrs,
+              expansionListIterator, context, iterOps, limit, null);
-          }     
-        }
-        else {
-          mergeAndExpandCutDownRelationshipIndexResults(values, result,
-              indexFieldToItrsMapping, expansionListIterator, finalItrs,
-              context, checkList, iterOps, icdeh, level + 1);
+          }
+        } else {
+          mergeAndExpandCutDownRelationshipIndexResults(values, result, indexFieldToItrsMapping,
+              expansionListIterator, finalItrs, context, checkList, iterOps, icdeh, level + 1);
-  //TODO:Asif : Explain the function & write test cases. A boolean false means
+  // TODO:Asif : Explain the function & write test cases. A boolean false means
-  
-  //End result if we have not already expanded is that we have created a new struct and added to a set to prevent future expansions of the same object
-  //It also advances the current object for the iterator.
+
+  // End result if we have not already expanded is that we have created a new struct and added to a
+  // set to prevent future expansions of the same object
+  // It also advances the current object for the iterator.
-      RuntimeIterator[] indexFieldToItrsMapping,
-      IndexCutDownExpansionHelper icdeh) {
+      RuntimeIterator[] indexFieldToItrsMapping, IndexCutDownExpansionHelper icdeh) {
-      //Asif : this means we have a ResultSet
-      Support
-          .Assert(
-              !icdeh.cutDownNeeded,
-              "If the index fields to iter mapping is of of size 1 then cut down cannot occur");
+      // Asif : this means we have a ResultSet
+      Support.Assert(!icdeh.cutDownNeeded,
+          "If the index fields to iter mapping is of of size 1 then cut down cannot occur");
-    }
-    else {
+    } else {
-      if (icdeh.cutDownNeeded) checkFields = new Object[icdeh.checkSize];
+      if (icdeh.cutDownNeeded)
+        checkFields = new Object[icdeh.checkSize];
-        }
-        else {
+        } else {
-        }
-        else {
+        } else {
-  //creates the returned set and then calls other methods to do actual work
-  private static SelectResults cutDownAndExpandIndexResults(
-      SelectResults result, RuntimeIterator[] indexFieldToItrsMapping,
-      List expansionList, List finalItrs, ExecutionContext context,
-      List checkList, CompiledValue iterOps, IndexInfo theFilteringIndex) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+  // creates the returned set and then calls other methods to do actual work
+  private static SelectResults cutDownAndExpandIndexResults(SelectResults result,
+      RuntimeIterator[] indexFieldToItrsMapping, List expansionList, List finalItrs,
+      ExecutionContext context, List checkList, CompiledValue iterOps, IndexInfo theFilteringIndex)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-    boolean useLinkedDataStructure = false; 
+    boolean useLinkedDataStructure = false;
-    Boolean orderByClause = (Boolean)context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-    if(orderByClause != null && orderByClause.booleanValue()) {
-      List orderByAttrs = (List)context.cacheGet(CompiledValue.ORDERBY_ATTRIB);        
-      useLinkedDataStructure = orderByAttrs.size()==1; 
-      nullValuesAtStart = !((CompiledSortCriterion)orderByAttrs.get(0)).getCriterion();
+    Boolean orderByClause = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
+    if (orderByClause != null && orderByClause.booleanValue()) {
+      List orderByAttrs = (List) context.cacheGet(CompiledValue.ORDERBY_ATTRIB);
+      useLinkedDataStructure = orderByAttrs.size() == 1;
+      nullValuesAtStart = !((CompiledSortCriterion) orderByAttrs.get(0)).getCriterion();
-        returnSet = context.isDistinct() ? new LinkedResultSet(resultType): 
-          new SortedResultsBag(resultType, nullValuesAtStart); 
+        returnSet = context.isDistinct() ? new LinkedResultSet(resultType)
+            : new SortedResultsBag(resultType, nullValuesAtStart);
-        returnSet =QueryUtils.createResultCollection(context, resultType);
+        returnSet = QueryUtils.createResultCollection(context, resultType);
-    
-    }
-    else {
-      StructTypeImpl resultType =  (StructTypeImpl) createStructTypeForRuntimeIterators(finalItrs);
-      if(useLinkedDataStructure) {
+
+    } else {
+      StructTypeImpl resultType = (StructTypeImpl) createStructTypeForRuntimeIterators(finalItrs);
+      if (useLinkedDataStructure) {
-        : new SortedResultsBag<Struct>((StructTypeImpl)resultType, nullValuesAtStart);
-      }else {
+            : new SortedResultsBag<Struct>((StructTypeImpl) resultType, nullValuesAtStart);
+      } else {
-      
+
-    cutDownAndExpandIndexResults(returnSet, result, indexFieldToItrsMapping,
-        expansionList, finalItrs, context, checkList, iterOps, theFilteringIndex);
+    cutDownAndExpandIndexResults(returnSet, result, indexFieldToItrsMapping, expansionList,
+        finalItrs, context, checkList, iterOps, theFilteringIndex);
-  //TODO:Asif Explain the parameters passed
-  private static void cutDownAndExpandIndexResults(SelectResults returnSet,
-      SelectResults result, RuntimeIterator[] indexFieldToItrsMapping,
-      List expansionList, List finalItrs, ExecutionContext context,
-      List checkList, CompiledValue iterOps, IndexInfo theFilteringIndex) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+  // TODO:Asif Explain the parameters passed
+  private static void cutDownAndExpandIndexResults(SelectResults returnSet, SelectResults result,
+      RuntimeIterator[] indexFieldToItrsMapping, List expansionList, List finalItrs,
+      ExecutionContext context, List checkList, CompiledValue iterOps, IndexInfo theFilteringIndex)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-//    Object[] checkFields = null;
-    IndexCutDownExpansionHelper icdeh =
-                                new IndexCutDownExpansionHelper(checkList,
-                                                                context);
+    // Object[] checkFields = null;
+    IndexCutDownExpansionHelper icdeh = new IndexCutDownExpansionHelper(checkList, context);
-      Support.Assert(len == 1, "The array size of iterators should be 1 here, but got "
-                     + len);
+      Support.Assert(len == 1, "The array size of iterators should be 1 here, but got " + len);
-    
+
-      if (setIndexFieldValuesInRespectiveIterators(value,  
-          indexFieldToItrsMapping, icdeh)) {  //does that mean we don't get dupes even if they exist in the index?
-        //         DO NESTED LOOPING
+      if (setIndexFieldValuesInRespectiveIterators(value, indexFieldToItrsMapping, icdeh)) { // does
+                                                                                             // that
+                                                                                             // mean
+                                                                                             // we
+                                                                                             // don't
+                                                                                             // get
+                                                                                             // dupes
+                                                                                             // even
+                                                                                             // if
+                                                                                             // they
+                                                                                             // exist
+                                                                                             // in
+                                                                                             // the
+                                                                                             // index?
+        // DO NESTED LOOPING
-        }  
-        doNestedIterationsForIndex(expansionListIterator.hasNext(), returnSet,
-            finalItrs, expansionListIterator, context, iterOps, limit, derivedInfo.derivedResults);
+        }
+        doNestedIterationsForIndex(expansionListIterator.hasNext(), returnSet, finalItrs,
+            expansionListIterator, context, iterOps, limit, derivedInfo.derivedResults);
-        }     
+        }
-  
-  //returns the limit value from the context.  This was set in CompiledSelect evaluate
-  //We do not apply limit if we have an order by attribute at this time
-  //it may be possible but we need better understanding of when ordering is taking place
-  //If it's at the index level, we may be able to apply limits at this point
-  //however a lot of the code in this class is fragile/unreadable/hard to maintain
+
+  // returns the limit value from the context. This was set in CompiledSelect evaluate
+  // We do not apply limit if we have an order by attribute at this time
+  // it may be possible but we need better understanding of when ordering is taking place
+  // If it's at the index level, we may be able to apply limits at this point
+  // however a lot of the code in this class is fragile/unreadable/hard to maintain
-      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)) != null?((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue(): -1;
-    }   
+      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)) != null
+          ? ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue() : -1;
+    }
-  
+
-    } 
+    }
-  //Add comments
-  private static void doNestedIterationsForIndex(boolean continueRecursion,
-      SelectResults resultSet, List finalItrs, ListIterator expansionItrs,
-      ExecutionContext context, CompiledValue iterOps, int limit, Map<String, SelectResults> derivedResults)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
-    
+  // Add comments
+  private static void doNestedIterationsForIndex(boolean continueRecursion, SelectResults resultSet,
+      List finalItrs, ListIterator expansionItrs, ExecutionContext context, CompiledValue iterOps,
+      int limit, Map<String, SelectResults> derivedResults) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+
-      //end recusrion
+      // end recusrion
-        StructTypeImpl elementType = (StructTypeImpl)resultSet.getCollectionType().getElementType();
-        //TODO:Asif Optimize the LinkedStructSet implementation so that
+        StructTypeImpl elementType =
+            (StructTypeImpl) resultSet.getCollectionType().getElementType();
+        // TODO:Asif Optimize the LinkedStructSet implementation so that
-        
+
-        //creates tuple
+        // creates tuple
-          if(isOrdered) {
-            //((LinkedStructSet) resultSet).add(new StructImpl(elementType, values));
+          if (isOrdered) {
+            // ((LinkedStructSet) resultSet).add(new StructImpl(elementType, values));
-          }else {
-            
-              ((StructFields) resultSet).addFieldValues(values);
-            
+          } else {
+
+            ((StructFields) resultSet).addFieldValues(values);
+
-      }
-      else {
+      } else {
-           resultSet.add(((RuntimeIterator) itr.next()).evaluate(context));
+          resultSet.add(((RuntimeIterator) itr.next()).evaluate(context));
-    }
-    else {
+    } else {
-      // Calculate the key to find the derived join results. If we are a non nested lookup it will be a Compiled Region otherwise it will be a CompiledPath that
-      // we can extract the id from. In the end the result will be the alias which is used as a prefix
+      // Calculate the key to find the derived join results. If we are a non nested lookup it will
+      // be a Compiled Region otherwise it will be a CompiledPath that
+      // we can extract the id from. In the end the result will be the alias which is used as a
+      // prefix
-      if (currentLevel.getCmpIteratorDefn().getCollectionExpr().getType() == OQLLexerTokenTypes.RegionPath) {
+      if (currentLevel.getCmpIteratorDefn().getCollectionExpr()
+          .getType() == OQLLexerTokenTypes.RegionPath) {
-      } else if (currentLevel.getCmpIteratorDefn().getCollectionExpr().getType() == OQLLexerTokenTypes.LITERAL_select) {
+      } else if (currentLevel.getCmpIteratorDefn().getCollectionExpr()
+          .getType() == OQLLexerTokenTypes.LITERAL_select) {
-        key = getCompiledIdFromPath(currentLevel.getCmpIteratorDefn().getCollectionExpr()).getId() + ":" + currentLevel.getDefinition();
+        key = getCompiledIdFromPath(currentLevel.getCmpIteratorDefn().getCollectionExpr()).getId()
+            + ":" + currentLevel.getDefinition();
-      //  RuntimeIterator next = expansionItrs.hasNext() ?
+      // RuntimeIterator next = expansionItrs.hasNext() ?
-        //TODO:Asif Check this out
+        // TODO:Asif Check this out
-        doNestedIterationsForIndex(expansionItrs.hasNext(), resultSet,
-            finalItrs, expansionItrs, context, iterOps, limit, derivedResults);
+        doNestedIterationsForIndex(expansionItrs.hasNext(), resultSet, finalItrs, expansionItrs,
+            context, iterOps, limit, derivedResults);
-        }     
+        }
-   * Ketan/Asif : This function will evaluate the starting CompiledValue for a
-   * given CompliedValue. The value returned will always be either the original
-   * CompiledValue, or a CompiledID, or a CompiledRegion, or a
-   * CompiledBindArgument, or a CompiledOperation. The ExecutionContext passed can
-   * be null. If it is null, then for a CompiledOperation , if supposed to get
-   * resolved implicitly, will have its receiver as null. This is because in normal
-   * cases , a CompiledID marks the termination, but in case of
-   * CompiledOperation this is not the case
+   * Ketan/Asif : This function will evaluate the starting CompiledValue for a given CompliedValue.
+   * The value returned will always be either the original CompiledValue, or a CompiledID, or a
+   * CompiledRegion, or a CompiledBindArgument, or a CompiledOperation. The ExecutionContext passed
+   * can be null. If it is null, then for a CompiledOperation , if supposed to get resolved
+   * implicitly, will have its receiver as null. This is because in normal cases , a CompiledID
+   * marks the termination, but in case of CompiledOperation this is not the case
-  public static CompiledValue obtainTheBottomMostCompiledValue(
-      CompiledValue expr) {
+  public static CompiledValue obtainTheBottomMostCompiledValue(CompiledValue expr) {
-                                            * pass the ExecutionContext as null,
-                                            * thus never implicitly resolving to
-                                            * RuntimeIterator
+                                            * pass the ExecutionContext as null, thus never
+                                            * implicitly resolving to RuntimeIterator
-      if (toContinue) exprType = expr.getType();
+      if (toContinue)
+        exprType = expr.getType();
-   * Asif : This function creates a StructType using Internal IDs of the
-   * iterators as the field names for the StructType. It should be invoked iff
-   * the iterators size is greater than 1
+   * Asif : This function creates a StructType using Internal IDs of the iterators as the field
+   * names for the StructType. It should be invoked iff the iterators size is greater than 1
-   *  
+   * 
-  public static StructType createStructTypeForRuntimeIterators(
-      List runTimeIterators) {
-    Support
-        .Assert(runTimeIterators.size() > 1,
-            "The number of Iterators passed should be greater than 1 to create a structSet");
+  public static StructType createStructTypeForRuntimeIterators(List runTimeIterators) {
+    Support.Assert(runTimeIterators.size() > 1,
+        "The number of Iterators passed should be greater than 1 to create a structSet");
-    //Asif : use an Iterator as the chances are that we will be sending
-    //LinkedList rather than ArrayList
+    // Asif : use an Iterator as the chances are that we will be sending
+    // LinkedList rather than ArrayList
-      fieldNames[i] =  iter.getInternalId();
+      fieldNames[i] = iter.getInternalId();
-   * Asif :This function returns the ultimate independent RuntimeIterators of
-   * current scope on which the CompiledValue passed is dependent upon. This
-   * does not return the RuntimeIterators on which it may be dependent but are
-   * not part of the current scope. If no such RuntimeIterator exists it returns
-   * empty set.
+   * Asif :This function returns the ultimate independent RuntimeIterators of current scope on which
+   * the CompiledValue passed is dependent upon. This does not return the RuntimeIterators on which
+   * it may be dependent but are not part of the current scope. If no such RuntimeIterator exists it
+   * returns empty set.
-   * @return Set containing the ultimate independent RuntimeIterators of current
-   *         scope
-   *  
+   * @return Set containing the ultimate independent RuntimeIterators of current scope
+   * 
-  public static Set getCurrentScopeUltimateRuntimeIteratorsIfAny(
-      CompiledValue compiledValue, ExecutionContext context) {
+  public static Set getCurrentScopeUltimateRuntimeIteratorsIfAny(CompiledValue compiledValue,
+      ExecutionContext context) {
-    //if (set.size() != 1) return null;
+    // if (set.size() != 1) return null;
-      if (rIter.getScopeID() != context.currentScope().getScopeID()/*context.getScopeCount()*/) iter.remove();
+      if (rIter.getScopeID() != context.currentScope().getScopeID()/* context.getScopeCount() */)
+        iter.remove();
-   * Asif :Returns the pair of RangeIndexes available for a composite condition (
-   * equi join across the region). It will either return two indexes or will
-   * return null. *
+   * Asif :Returns the pair of RangeIndexes available for a composite condition ( equi join across
+   * the region). It will either return two indexes or will return null. *
-   * @return An array of IndexData object with 0th IndexData for the lhs operand &
-   *         1th object for rhs operad
+   * @return An array of IndexData object with 0th IndexData for the lhs operand & 1th object for
+   *         rhs operad
-   *  
+   * 
-  static IndexData[] getRelationshipIndexIfAny(CompiledValue lhs,
-      CompiledValue rhs, ExecutionContext context, int operator)
+  static IndexData[] getRelationshipIndexIfAny(CompiledValue lhs, CompiledValue rhs,
+      ExecutionContext context, int operator)
-    if (operator != OQLLexerTokenTypes.TOK_EQ) return null;// Operator must be
+    if (operator != OQLLexerTokenTypes.TOK_EQ)
+      return null;// Operator must be
-    IndexData lhsIndxData = QueryUtils.getAvailableIndexIfAny(lhs, context,
-        false /* Do not use PrimaryKey Index */);// findOnlyFunctionalIndex.
-    if (lhsIndxData == null) return null;
-    IndexData rhsIndxData = QueryUtils.getAvailableIndexIfAny(rhs, context,
-        false /* Do not use PrimaryKey Index */);// findOnlyFunctionalIndex.
+    IndexData lhsIndxData =
+        QueryUtils.getAvailableIndexIfAny(lhs, context, false /* Do not use PrimaryKey Index */);// findOnlyFunctionalIndex.
+    if (lhsIndxData == null)
+      return null;
+    IndexData rhsIndxData =
+        QueryUtils.getAvailableIndexIfAny(rhs, context, false /* Do not use PrimaryKey Index */);// findOnlyFunctionalIndex.
-      } else {      
-         ((AbstractIndex) index).releaseIndexReadLockForRemove();
+      } else {
+        ((AbstractIndex) index).releaseIndexReadLockForRemove();
-    if (((IndexProtocol) lhsIndx).isValid()
-       && ((IndexProtocol) rhsIndx).isValid()) { 
-       return new IndexData[] {lhsIndxData, rhsIndxData}; 
+    if (((IndexProtocol) lhsIndx).isValid() && ((IndexProtocol) rhsIndx).isValid()) {
+      return new IndexData[] {lhsIndxData, rhsIndxData};
-   *  
+   * 
-  static IndexData getAvailableIndexIfAny(CompiledValue cv,
-      ExecutionContext context, int operator) throws AmbiguousNameException,
-      TypeMismatchException, NameResolutionException {
+  static IndexData getAvailableIndexIfAny(CompiledValue cv, ExecutionContext context, int operator)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-    boolean usePrimaryIndex = (operator == OQLLexerTokenTypes.TOK_EQ || operator == OQLLexerTokenTypes.TOK_NE);
+    boolean usePrimaryIndex =
+        (operator == OQLLexerTokenTypes.TOK_EQ || operator == OQLLexerTokenTypes.TOK_NE);
-  //TODO:Asif : Provide description of the function.
-  private static IndexData getAvailableIndexIfAny(CompiledValue cv,
-      ExecutionContext context, boolean usePrimaryIndex)
+  // TODO:Asif : Provide description of the function.
+  private static IndexData getAvailableIndexIfAny(CompiledValue cv, ExecutionContext context,
+      boolean usePrimaryIndex)
-    if (set.size() != 1) return null;
+    if (set.size() != 1)
+      return null;
-    if (rIter.getScopeID() != context.currentScope().getScopeID() /*context.getScopeCount()*/
-        || (regionPath = context
-            .getRegionPathForIndependentRuntimeIterator(rIter)) == null) {
+    if (rIter.getScopeID() != context.currentScope().getScopeID() /* context.getScopeCount() */
+        || (regionPath = context.getRegionPathForIndependentRuntimeIterator(rIter)) == null) {
-    //  Asif : The independent iterator is added as the first element
-    List groupRuntimeItrs = context
-        .getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(rIter);
+    // Asif : The independent iterator is added as the first element
+    List groupRuntimeItrs = context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(rIter);
-      
+
-    
-//    StringBuffer sb = new StringBuffer();
-//    cv.generateCanonicalizedExpression(sb, context);
-    IndexData indexData = IndexUtils.findIndex(regionPath, definitions, cv,
-        "*", context.getCache(), usePrimaryIndex, context);
+
+    // StringBuffer sb = new StringBuffer();
+    // cv.generateCanonicalizedExpression(sb, context);
+    IndexData indexData = IndexUtils.findIndex(regionPath, definitions, cv, "*", context.getCache(),
+        usePrimaryIndex, context);
-      if (logger.isDebugEnabled() ) {
-        logger.debug("Indexed expression for indexed data : {}  for region : {}", indexData.getIndex().getCanonicalizedIndexedExpression(), regionPath);
+      if (logger.isDebugEnabled()) {
+        logger.debug("Indexed expression for indexed data : {}  for region : {}",
+            indexData.getIndex().getCanonicalizedIndexedExpression(), regionPath);
-    
+
-   * Asif : Conditions the raw index result obtained on a non composite
-   * condition ( i.e a condition with a format of variable = constant . A
-   * constant may be either a CompiledLiteral or an expression which is
-   * completely dependent on iterators other than the current scope. The
-   * variable is a path expression which is completely dependent on iterators
-   * belonging only to a single region ( i.e iterators belonging to a Group of
-   * iterators only dependent on a single indpendent iterator for the region).
-   * The raw index result is appropriately expanded / cutdown with evaluation of
-   * iter operand if any , StructType/ObjectType appropriately set, Shuffling of
-   * the fields appropriately done, such that the final result is compatible, in
-   * terms of the position and names of the fields of SelectResults( StructBag) ,
-   * with the Iterators of the query from clause ( if complete expansion flag is
-   * true) or the chain of iterators identified by the indpendent iterator for
-   * the group.
+   * Asif : Conditions the raw index result obtained on a non composite condition ( i.e a condition
+   * with a format of variable = constant . A constant may be either a CompiledLiteral or an
+   * expression which is completely dependent on iterators other than the current scope. The
+   * variable is a path expression which is completely dependent on iterators belonging only to a
+   * single region ( i.e iterators belonging to a Group of iterators only dependent on a single
+   * indpendent iterator for the region). The raw index result is appropriately expanded / cutdown
+   * with evaluation of iter operand if any , StructType/ObjectType appropriately set, Shuffling of
+   * the fields appropriately done, such that the final result is compatible, in terms of the
+   * position and names of the fields of SelectResults( StructBag) , with the Iterators of the query
+   * from clause ( if complete expansion flag is true) or the chain of iterators identified by the
+   * indpendent iterator for the group.
-   * @param indexResults The raw index results which may be a ResultBag object
-   *          or an StructBag object
-   * @param indexInfo IndexInfo object containing data such as match level & the
-   *          mapping of the position of Runtime Iterators of the group to the
-   *          position of the corresponding field in the index result (
-   *          StructBag)
+   * @param indexResults The raw index results which may be a ResultBag object or an StructBag
+   *        object
+   * @param indexInfo IndexInfo object containing data such as match level & the mapping of the
+   *        position of Runtime Iterators of the group to the position of the corresponding field in
+   *        the index result ( StructBag)
-   * @param indexFieldsSize The number of fields contained in the raw index
-   *          resultset
-   * @param completeExpansion The boolean indicating whether the index resultset
-   *          needs to be expanded to the query from clause level ( i.e top
-   *          level)
-   * @param iterOperands The CompiledValue representing the iter operand which
-   *          needs to be evaluated during conditioning of index resultset
-   * @param grpIndpndntItr An Array of Independent Iterators representing their
-   *          respective groups. The conditioned Index Resultset will be created
-   *          as per the chain of dependent iterators for each group.
+   * @param indexFieldsSize The number of fields contained in the raw index resultset
+   * @param completeExpansion The boolean indicating whether the index resultset needs to be
+   *        expanded to the query from clause level ( i.e top level)
+   * @param iterOperands The CompiledValue representing the iter operand which needs to be evaluated
+   *        during conditioning of index resultset
+   * @param grpIndpndntItr An Array of Independent Iterators representing their respective groups.
+   *        The conditioned Index Resultset will be created as per the chain of dependent iterators
+   *        for each group.
-   *  
+   * 
-  static SelectResults getconditionedIndexResults(SelectResults indexResults,
-      IndexInfo indexInfo, ExecutionContext context, int indexFieldsSize,
-      boolean completeExpansion, CompiledValue iterOperands,
-      RuntimeIterator[] grpIndpndntItr) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
-    if (!completeExpansion && grpIndpndntItr != null
-        && grpIndpndntItr.length > 1) {
-      //Asif : If for a Single Base Collection Index usage we are having
+  static SelectResults getconditionedIndexResults(SelectResults indexResults, IndexInfo indexInfo,
+      ExecutionContext context, int indexFieldsSize, boolean completeExpansion,
+      CompiledValue iterOperands, RuntimeIterator[] grpIndpndntItr) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+    if (!completeExpansion && grpIndpndntItr != null && grpIndpndntItr.length > 1) {
+      // Asif : If for a Single Base Collection Index usage we are having
-      //If it so happens that Complete expansion is false, this implies that we
+      // If it so happens that Complete expansion is false, this implies that we
-      //it to CompositeGroupJunction level. We will esnure in
+      // it to CompositeGroupJunction level. We will esnure in
-      IndexConditioningHelper ich = new IndexConditioningHelper(indexInfo,
-          context, indexFieldsSize, completeExpansion, iterOperands, null);
+      IndexConditioningHelper ich = new IndexConditioningHelper(indexInfo, context, indexFieldsSize,
+          completeExpansion, iterOperands, null);
-      ich.finalList = getDependentItrChainForIndpndntItrs(grpIndpndntItr,
-          context);
-      //Add the iterators of remaining independent grp to the expansion list
+      ich.finalList = getDependentItrChainForIndpndntItrs(grpIndpndntItr, context);
+      // Add the iterators of remaining independent grp to the expansion list
-          newExpList.addAll(context
-              .getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(tempItr));
+          newExpList.addAll(context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(tempItr));
-        observer.beforeCutDownAndExpansionOfSingleIndexResult(indexInfo._index,
-            indexResults);
-        indexResults = QueryUtils.cutDownAndExpandIndexResults(indexResults,
-            ich.indexFieldToItrsMapping, ich.expansionList, ich.finalList,
-            context, ich.checkList, iterOperands, indexInfo);
-      }
-      finally {
+        observer.beforeCutDownAndExpansionOfSingleIndexResult(indexInfo._index, indexResults);
+        indexResults =
+            QueryUtils.cutDownAndExpandIndexResults(indexResults, ich.indexFieldToItrsMapping,
+                ich.expansionList, ich.finalList, context, ich.checkList, iterOperands, indexInfo);
+      } finally {
-    }
-    else {
-      IndexConditioningHelper ich = new IndexConditioningHelper(indexInfo,
-          context, indexFieldsSize, completeExpansion, iterOperands,
-          grpIndpndntItr != null ? grpIndpndntItr[0] : null);
+    } else {
+      IndexConditioningHelper ich = new IndexConditioningHelper(indexInfo, context, indexFieldsSize,
+          completeExpansion, iterOperands, grpIndpndntItr != null ? grpIndpndntItr[0] : null);
-          observer.beforeCutDownAndExpansionOfSingleIndexResult(
-              indexInfo._index, indexResults);
+          observer.beforeCutDownAndExpansionOfSingleIndexResult(indexInfo._index, indexResults);
-              ich.indexFieldToItrsMapping, ich.expansionList, ich.finalList,
-              context, ich.checkList, iterOperands, indexInfo);
-        }
-        finally {
+              ich.indexFieldToItrsMapping, ich.expansionList, ich.finalList, context, ich.checkList,
+              iterOperands, indexInfo);
+        } finally {
-      }
-      else if (indexInfo.mapping.length > 1) {
+      } else if (indexInfo.mapping.length > 1) {
-   * Asif :This function is used to evaluate a filter evaluatable
-   * CompositeCondition(ie Range Indexes available on both LHS & RHS
-   * operands).This function is invoked from AND junction evaluation of
-   * CompositeGroupJunction. It expands the intermediate resultset passed , to
-   * the level of groups determined by the LHS & RHS operand, using the range
-   * indexes. It is possible that the group of iterators for an operand of
-   * condition already exists in the intermediate resultset passed. In such
-   * situation, the intermediate resultset is iterated & the operand ( whose group
-   * of iterators are available in the intermediate resultset ) is evaluated.
-   * For each such evaluated value , the other operand's Range Index is queried &
-   * the Range Index's results are appropriately expanded & cut down & a final
-   * tuple obtained( which includes the previously existing fields of
-   * intermediate resultset). The array of independent iterators passed from the
-   * Composite Group junction will be null, except for the final condition (
-   * subject to the fact that complete expansion flag is false. Otherwise even
-   * for final condition , the array will be null) as that array will be used to
-   * get the final position of iterators in the resultant StructBag
+   * Asif :This function is used to evaluate a filter evaluatable CompositeCondition(ie Range
+   * Indexes available on both LHS & RHS operands).This function is invoked from AND junction
+   * evaluation of CompositeGroupJunction. It expands the intermediate resultset passed , to the
+   * level of groups determined by the LHS & RHS operand, using the range indexes. It is possible
+   * that the group of iterators for an operand of condition already exists in the intermediate
+   * resultset passed. In such situation, the intermediate resultset is iterated & the operand (
+   * whose group of iterators are available in the intermediate resultset ) is evaluated. For each
+   * such evaluated value , the other operand's Range Index is queried & the Range Index's results
+   * are appropriately expanded & cut down & a final tuple obtained( which includes the previously
+   * existing fields of intermediate resultset). The array of independent iterators passed from the
+   * Composite Group junction will be null, except for the final condition ( subject to the fact
+   * that complete expansion flag is false. Otherwise even for final condition , the array will be
+   * null) as that array will be used to get the final position of iterators in the resultant
+   * StructBag
-   * @param intermediateResults SelectResults object containing the intermediate
-   *          resultset obtained by evaluation of previous filter evaluatable
-   *          composite conditions of the CompositeGroupJunction
-   * @param indxInfo Array of IndexInfo objects ( size 2), representing the
-   *          range index for the two operands of the condition
+   * @param intermediateResults SelectResults object containing the intermediate resultset obtained
+   *        by evaluation of previous filter evaluatable composite conditions of the
+   *        CompositeGroupJunction
+   * @param indxInfo Array of IndexInfo objects ( size 2), representing the range index for the two
+   *        operands of the condition
-   * @param completeExpansionNeeded A boolean when true indicates that the final
-   *          result from Composite GroupJunction needs to be evaluated to the
-   *          query from clause ( top ) level.
-   * @param iterOperands CompiledValue representing the conditions which are to
-   *          be iter evaluated. This can exist only if instead of
-   *          AllGroupJunction we have a single CompositeGroupJunction
-   * @param indpdntItrs Array of RuntimeIterators representing the independent
-   *          iterators of their representative groups forming the
-   *          CompositeGroupJunction *
-   * @return SelectResults The Result object created by evaluating the filter
-   *         evaluatable condition merged with the intermediate results
+   * @param completeExpansionNeeded A boolean when true indicates that the final result from
+   *        Composite GroupJunction needs to be evaluated to the query from clause ( top ) level.
+   * @param iterOperands CompiledValue representing the conditions which are to be iter evaluated.
+   *        This can exist only if instead of AllGroupJunction we have a single
+   *        CompositeGroupJunction
+   * @param indpdntItrs Array of RuntimeIterators representing the independent iterators of their
+   *        representative groups forming the CompositeGroupJunction *
+   * @return SelectResults The Result object created by evaluating the filter evaluatable condition
+   *         merged with the intermediate results
-   *  
+   * 
-      SelectResults intermediateResults, IndexInfo[] indxInfo,
-      ExecutionContext context, boolean completeExpansionNeeded,
-      CompiledValue iterOperands, RuntimeIterator[] indpdntItrs)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+      SelectResults intermediateResults, IndexInfo[] indxInfo, ExecutionContext context,
+      boolean completeExpansionNeeded, CompiledValue iterOperands, RuntimeIterator[] indpdntItrs)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-    int indexFieldsSize1 = resultType1 instanceof StructType ? ((StructTypeImpl) resultType1)
-        .getFieldNames().length
-        : 1;
+    int indexFieldsSize1 = resultType1 instanceof StructType
+        ? ((StructTypeImpl) resultType1).getFieldNames().length : 1;
-    int indexFieldsSize2 = resultType2 instanceof StructType ? ((StructTypeImpl) resultType2)
-        .getFieldNames().length
-        : 1;
+    int indexFieldsSize2 = resultType2 instanceof StructType
+        ? ((StructTypeImpl) resultType2).getFieldNames().length : 1;
-     * Asif : even if th complete expansion is needed pass the flag of complete
-     * expansion as false. Thus for LHS & RHS we will get the expnasionList for
-     * that individual group.
+     * Asif : even if th complete expansion is needed pass the flag of complete expansion as false.
+     * Thus for LHS & RHS we will get the expnasionList for that individual group.
-    IndexConditioningHelper ich1 = new IndexConditioningHelper(indxInfo[0],
-        context, indexFieldsSize1,
-        false/* Asif : pass it as false, irrespective of actual value */,
-        iterOperands, null);
-    IndexConditioningHelper ich2 = new IndexConditioningHelper(indxInfo[1],
-        context, indexFieldsSize2,
-        false/* Asif : pass it as false, irrespective of actual value */,
-        iterOperands, null);
-    //Asif : We cannot have a condition where in intermediateResultset is empty
+    IndexConditioningHelper ich1 =
+        new IndexConditioningHelper(indxInfo[0], context, indexFieldsSize1,
+            false/* Asif : pass it as false, irrespective of actual value */, iterOperands, null);
+    IndexConditioningHelper ich2 =
+        new IndexConditioningHelper(indxInfo[1], context, indexFieldsSize2,
+            false/* Asif : pass it as false, irrespective of actual value */, iterOperands, null);
+    // Asif : We cannot have a condition where in intermediateResultset is empty
-    //getconditionedRelationshipIndexResultsExpandedToTopOrCGJLevel
-    int noOfIndexesToUse = (intermediateResults == null || intermediateResults
-        .isEmpty()) ? 2 : 0;
+    // getconditionedRelationshipIndexResultsExpandedToTopOrCGJLevel
+    int noOfIndexesToUse = (intermediateResults == null || intermediateResults.isEmpty()) ? 2 : 0;
-    List finalList = completeExpansionNeeded ? allItrs
-        : indpdntItrs == null ? new ArrayList() : null;
+    List finalList =
+        completeExpansionNeeded ? allItrs : indpdntItrs == null ? new ArrayList() : null;
-      //If the intermediate Resultset is not empty then check if the resultset
+      // If the intermediate Resultset is not empty then check if the resultset
-      //resultset contains any independent iterator of the current condition
+      // resultset contains any independent iterator of the current condition
-      StructType stype = (StructType) intermediateResults.getCollectionType()
-          .getElementType();
+      StructType stype = (StructType) intermediateResults.getCollectionType().getElementType();
-          }
-          else if (fieldName.equals(rhsID)) {
+          } else if (fieldName.equals(rhsID)) {
-        RuntimeIterator itrPrsntInIntermdtRes = (RuntimeIterator) allItrs
-            .get(pos - 1);
+        RuntimeIterator itrPrsntInIntermdtRes = (RuntimeIterator) allItrs.get(pos - 1);
-        //Asif : the iterator below is already present in resultset so needs to
+        // Asif : the iterator below is already present in resultset so needs to
-        }
-        else if (indpdntItrs == null) {
+        } else if (indpdntItrs == null) {
-          //But if the independent group of iterators is passed, the final list needs
+          // But if the independent group of iterators is passed, the final list needs
-        observer.beforeIndexLookup(indxInfo[0]._index,
-            OQLLexerTokenTypes.TOK_EQ, null);
-        observer.beforeIndexLookup(indxInfo[1]._index,
-            OQLLexerTokenTypes.TOK_EQ, null);
+        observer.beforeIndexLookup(indxInfo[0]._index, OQLLexerTokenTypes.TOK_EQ, null);
+        observer.beforeIndexLookup(indxInfo[1]._index, OQLLexerTokenTypes.TOK_EQ, null);
-      }
-      finally {
+      } finally {
-      //For sure we need to evaluate both the conditions & expand it only to
+      // For sure we need to evaluate both the conditions & expand it only to
-          //Asif : The expnItrsToIgnore set being null at this point implies
+          // Asif : The expnItrsToIgnore set being null at this point implies
-          Support
-              .Assert(
-                  intermediateResults == null || intermediateResults.isEmpty(),
-                  "expnItrsToIgnore should not have been null if the intermediate result set is not empty");
+          Support.Assert(intermediateResults == null || intermediateResults.isEmpty(),
+              "expnItrsToIgnore should not have been null if the intermediate result set is not empty");
-        //Asif : identify the iterators which we need to expand to
-        //TODO:Asif :Make the code compact by using a common function to take
+        // Asif : identify the iterators which we need to expand to
+        // TODO:Asif :Make the code compact by using a common function to take
-          //Asif :If the runtimeIterators of scope not present in CheckSet add
+          // Asif :If the runtimeIterators of scope not present in CheckSet add
-      }
-      else {
-        //Asif : If the independent itrs passed is not null, this implies
+      } else {
+        // Asif : If the independent itrs passed is not null, this implies
-        //set mismatch while doing intersection with GroupJunction results
+        // set mismatch while doing intersection with GroupJunction results
-        }
-        else {
+        } else {
-      List[] checkList = new List[] { ich1.checkList, ich2.checkList};
+      List[] checkList = new List[] {ich1.checkList, ich2.checkList};
-      SelectResults returnSet = QueryUtils.createStructCollection(context, stype) ;
+      SelectResults returnSet = QueryUtils.createStructCollection(context, stype);
-      List[] totalCheckList = new List[] { ich1.checkList, ich2.checkList};
+      List[] totalCheckList = new List[] {ich1.checkList, ich2.checkList};
-          observer.beforeMergeJoinOfDoubleIndexResults(indxInfo[0]._index,
-              indxInfo[1]._index, data);
-          boolean doMergeWithIntermediateResults = intermediateResults != null
-              && !intermediateResults.isEmpty();
-          int maxCartesianDepth = totalExpList.size()
-              + (doMergeWithIntermediateResults ? 1 : 0);
+          observer.beforeMergeJoinOfDoubleIndexResults(indxInfo[0]._index, indxInfo[1]._index,
+              data);
+          boolean doMergeWithIntermediateResults =
+              intermediateResults != null && !intermediateResults.isEmpty();
+          int maxCartesianDepth = totalExpList.size() + (doMergeWithIntermediateResults ? 1 : 0);
-            //TODO:Asif Change the code in range Index so that while collecting
+            // TODO:Asif Change the code in range Index so that while collecting
-            //two dimensional object array , we create one dimensional Object
+            // two dimensional object array , we create one dimensional Object
-            //stores an Object array
+            // stores an Object array
-            //Asif : Before doing the cartesian of the Results , we need to
+            // Asif : Before doing the cartesian of the Results , we need to
-                  new SelectResults[] { intermediateResults}, resultMappings,
-                  values, mappings, expansionListIterator, finalList, context,
-                  checkList, iterOperands, icdeh, 0, maxCartesianDepth);
+                  new SelectResults[] {intermediateResults}, resultMappings, values, mappings,
+                  expansionListIterator, finalList, context, checkList, iterOperands, icdeh, 0,
+                  maxCartesianDepth);
+            } else {
+              mergeAndExpandCutDownRelationshipIndexResults(values, returnSet, mappings,
+                  expansionListIterator, finalList, context, totalCheckList, iterOperands, icdeh,
+                  0 /* Level */);
-            else {
-              mergeAndExpandCutDownRelationshipIndexResults(values, returnSet,
-                  mappings, expansionListIterator, finalList, context,
-                  totalCheckList, iterOperands, icdeh, 0 /* Level */);
-            }
-            if (icdeh[0].cutDownNeeded) icdeh[0].checkSet.clear();
+            if (icdeh[0].cutDownNeeded)
+              icdeh[0].checkSet.clear();
-        }
-        finally {
+        } finally {
-    }
-    else if (noOfIndexesToUse == 1) {
-      //Asif : There exists one independent iterator in the current condition
+    } else if (noOfIndexesToUse == 1) {
+      // Asif : There exists one independent iterator in the current condition
-        Support
-            .Assert(
-                expnItrsToIgnore != null,
-                "expnItrsToIgnore should not have been null as we are in this block itself indicates that intermediate results was not null");
+        Support.Assert(expnItrsToIgnore != null,
+            "expnItrsToIgnore should not have been null as we are in this block itself indicates that intermediate results was not null");
-        //Asif : identify the iterators which we need to expand to
-        //TODO:Asif :Make the code compact by using a common function to take
+        // Asif : identify the iterators which we need to expand to
+        // TODO:Asif :Make the code compact by using a common function to take
-          //Asif :If the runtimeIterators of scope not present in CheckSet add
+          // Asif :If the runtimeIterators of scope not present in CheckSet add
-      }
-      else {
-        //        Asif : If the independent itrs passed is not null, this implies
+      } else {
+        // Asif : If the independent itrs passed is not null, this implies
-        //set mismatch while doing intersection with GroupJunction results
+        // set mismatch while doing intersection with GroupJunction results
-        }
-        else {
+        } else {
-//      List[] checkList = new List[] { ich1.checkList, ich2.checkList};
+      // List[] checkList = new List[] { ich1.checkList, ich2.checkList};
-      SelectResults returnSet = QueryUtils.createStructCollection(context, stype) ;
-      //Asif :Obtain the empty resultset for the single usable index
+      SelectResults returnSet = QueryUtils.createStructCollection(context, stype);
+      // Asif :Obtain the empty resultset for the single usable index
-//      int singleUsblIndexFieldsSize = -1;
+      // int singleUsblIndexFieldsSize = -1;
-        singlUsblIndxRes = QueryUtils.createStructCollection(context,(StructTypeImpl) singlUsblIndxResType);
-//        singleUsblIndexFieldsSize = ((StructTypeImpl) singlUsblIndxResType)
-//            .getFieldNames().length;
-      }
-      else {
+        singlUsblIndxRes =
+            QueryUtils.createStructCollection(context, (StructTypeImpl) singlUsblIndxResType);
+        // singleUsblIndexFieldsSize = ((StructTypeImpl) singlUsblIndxResType)
+        // .getFieldNames().length;
+      } else {
-//        singleUsblIndexFieldsSize = 1;
+        // singleUsblIndexFieldsSize = 1;
-      //Asif iterate over the intermediate structset
+      // Asif iterate over the intermediate structset
-        observer.beforeIndexLookup(singleUsblIndex, OQLLexerTokenTypes.TOK_EQ,
-            null);
-        observer.beforeIterJoinOfSingleIndexResults(singleUsblIndex,
-            nonUsableICH.indxInfo._index);
+        observer.beforeIndexLookup(singleUsblIndex, OQLLexerTokenTypes.TOK_EQ, null);
+        observer.beforeIterJoinOfSingleIndexResults(singleUsblIndex, nonUsableICH.indxInfo._index);
-          //TODO:Asif : Issue relevant index use callbacks to QueryObserver
+          // TODO:Asif : Issue relevant index use callbacks to QueryObserver
-          //TODO:Asif : Check this logic out
-          if (key != null && key.equals(QueryService.UNDEFINED)) continue;
-          singleUsblIndex.query(key, OQLLexerTokenTypes.TOK_EQ,
-              singlUsblIndxRes, context);
+          // TODO:Asif : Check this logic out
+          if (key != null && key.equals(QueryService.UNDEFINED))
+            continue;
+          singleUsblIndex.query(key, OQLLexerTokenTypes.TOK_EQ, singlUsblIndxRes, context);
-              singleUsableICH.indexFieldToItrsMapping, totalExpList, finalList,
-              context, singleUsableICH.checkList, iterOperands, singleUsableICH.indxInfo);
+              singleUsableICH.indexFieldToItrsMapping, totalExpList, finalList, context,
+              singleUsableICH.checkList, iterOperands, singleUsableICH.indxInfo);
-      }
-      finally {
+      } finally {
-    }
-    else {
-      //Asif : This condition is filter evaluatable but both the RHS group as
+    } else {
+      // Asif : This condition is filter evaluatable but both the RHS group as
-      //PART OF ITER OPERANDS
+      // PART OF ITER OPERANDS
-        ich1.indxInfo._path.generateCanonicalizedExpression(tempBuffLhs,
-            context);
-        ich2.indxInfo._path.generateCanonicalizedExpression(tempBuffRhs,
-            context);
-        logger.debug("For better performance indexes are not used for the condition {} = {}", tempBuffLhs, tempBuffRhs);
+        ich1.indxInfo._path.generateCanonicalizedExpression(tempBuffLhs, context);
+        ich2.indxInfo._path.generateCanonicalizedExpression(tempBuffRhs, context);
+        logger.debug("For better performance indexes are not used for the condition {} = {}",
+            tempBuffLhs, tempBuffRhs);
-      CompiledValue reconstructedVal = new CompiledComparison(
-          ich1.indxInfo._path, ich2.indxInfo._path, OQLLexerTokenTypes.TOK_EQ);
-      //Add this reconstructed value to the iter operand if any
+      CompiledValue reconstructedVal = new CompiledComparison(ich1.indxInfo._path,
+          ich2.indxInfo._path, OQLLexerTokenTypes.TOK_EQ);
+      // Add this reconstructed value to the iter operand if any
-        //Asif : The type of CompiledJunction has to be AND junction as this
+        // Asif : The type of CompiledJunction has to be AND junction as this
-        //itself is a CompiledJunction. We can have a tree of CompiledJunction
+        // itself is a CompiledJunction. We can have a tree of CompiledJunction
-        finalVal = new CompiledJunction(new CompiledValue[] { iterOperands,
-            reconstructedVal}, OQLLexerTokenTypes.LITERAL_and);
+        finalVal = new CompiledJunction(new CompiledValue[] {iterOperands, reconstructedVal},
+            OQLLexerTokenTypes.LITERAL_and);
-      return cartesian(new SelectResults[] { intermediateResults},
-          resultMappings, Collections.EMPTY_LIST, finalList, context, finalVal);
+      return cartesian(new SelectResults[] {intermediateResults}, resultMappings,
+          Collections.EMPTY_LIST, finalList, context, finalVal);
-   * Asif :This function is used to evaluate a filter evaluatable composite
-   * condition. It gets invoked either from a CompositeGroupJunction of "OR"
-   * type or a where clause containing single composite condition. In the later
-   * case the boolean completeExpansion flag is always true. While in the former
-   * case it may be true or false. If it is false, the array of independent
-   * iterators passed is not null.
+   * Asif :This function is used to evaluate a filter evaluatable composite condition. It gets
+   * invoked either from a CompositeGroupJunction of "OR" type or a where clause containing single
+   * composite condition. In the later case the boolean completeExpansion flag is always true. While
+   * in the former case it may be true or false. If it is false, the array of independent iterators
+   * passed is not null.
-   * @param data A List object whose elements are two dimensional object array.
-   *          Each element of the List represent a value which satisfies the
-   *          equi-join condition. Since there may be more than one tuples on
-   *          either side of the equality condition which meet the criteria for
-   *          a given value, we require a 2 dimensional Object array. The
-   *          cartesian of the two rows will give us the set of tuples
-   *          satisfying the join criteria. Each element of the row of Object
-   *          Array may be either an Object or a Struct object.
+   * @param data A List object whose elements are two dimensional object array. Each element of the
+   *        List represent a value which satisfies the equi-join condition. Since there may be more
+   *        than one tuples on either side of the equality condition which meet the criteria for a
+   *        given value, we require a 2 dimensional Object array. The cartesian of the two rows will
+   *        give us the set of tuples satisfying the join criteria. Each element of the row of
+   *        Object Array may be either an Object or a Struct object.
-   * @param indxInfo An array of IndexInfo objects of size 2 , representing the
-   *          range indexes of the two operands. The other Index maps to the 0th
-   *          Object array row of the List object ( data ) & so on.
+   * @param indxInfo An array of IndexInfo objects of size 2 , representing the range indexes of the
+   *        two operands. The other Index maps to the 0th Object array row of the List object ( data
+   *        ) & so on.
-   * @param completeExpansionNeeded boolean if true indicates that the CGJ needs
-   *          to be expanded to the query from clause ( top level )
-   * @param iterOperands This will be null as for OR junction we cannot have
-   *          iter operand
-   * @param indpdntItrs Array of independent iterators representing the various
-   *          Groups forming the composite group junction. It will be null, if
-   *          complete expansion flag is true
-   * @return SelectResults objet representing the result obtained by evaluating
-   *         a filter evaluatable composite condition in an OR junction. The
-   *         returned Result is expanded either to the CompositeGroupJunction
-   *         level or to the top level as the case may be
+   * @param completeExpansionNeeded boolean if true indicates that the CGJ needs to be expanded to
+   *        the query from clause ( top level )
+   * @param iterOperands This will be null as for OR junction we cannot have iter operand
+   * @param indpdntItrs Array of independent iterators representing the various Groups forming the
+   *        composite group junction. It will be null, if complete expansion flag is true
+   * @return SelectResults objet representing the result obtained by evaluating a filter evaluatable
+   *         composite condition in an OR junction. The returned Result is expanded either to the
+   *         CompositeGroupJunction level or to the top level as the case may be
-   *  
+   * 
-  static SelectResults getconditionedRelationshipIndexResultsExpandedToTopOrCGJLevel(
-      List data, IndexInfo[] indxInfo, ExecutionContext context,
-      boolean completeExpansionNeeded, CompiledValue iterOperands,
-      RuntimeIterator[] indpdntItrs) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
+  static SelectResults getconditionedRelationshipIndexResultsExpandedToTopOrCGJLevel(List data,
+      IndexInfo[] indxInfo, ExecutionContext context, boolean completeExpansionNeeded,
+      CompiledValue iterOperands, RuntimeIterator[] indpdntItrs) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    int indexFieldsSize1 = resultType1 instanceof StructType ? ((StructTypeImpl) resultType1)
-        .getFieldNames().length
-        : 1;
+    int indexFieldsSize1 = resultType1 instanceof StructType
+        ? ((StructTypeImpl) resultType1).getFieldNames().length : 1;
-    int indexFieldsSize2 = resultType2 instanceof StructType ? ((StructTypeImpl) resultType2)
-        .getFieldNames().length
-        : 1;
+    int indexFieldsSize2 = resultType2 instanceof StructType
+        ? ((StructTypeImpl) resultType2).getFieldNames().length : 1;
-     * Asif : even if th complete expansion is needed pass the flag of complete
-     * expansion as false. Thus for LHS & RHS we will get the expansionList for
-     * that individual group. Thus the total expansion List wil contain sum of
-     * the individual expansion lists plus all the iterators of the current
-     * scope which are dependent on any other groups or are composite iterators (
-     * i.e dependent on both the independent groups currently under
-     * consideration
+     * Asif : even if th complete expansion is needed pass the flag of complete expansion as false.
+     * Thus for LHS & RHS we will get the expansionList for that individual group. Thus the total
+     * expansion List wil contain sum of the individual expansion lists plus all the iterators of
+     * the current scope which are dependent on any other groups or are composite iterators ( i.e
+     * dependent on both the independent groups currently under consideration
-    IndexConditioningHelper ich1 = new IndexConditioningHelper(indxInfo[0],
-        context, indexFieldsSize1,
-        false/* Asif : pass it as false, irrespective of actual value */,
-        iterOperands, null);
-    IndexConditioningHelper ich2 = new IndexConditioningHelper(indxInfo[1],
-        context, indexFieldsSize2,
-        false/* Asif : pass it as false, irrespective of actual value */,
-        iterOperands, null);
+    IndexConditioningHelper ich1 =
+        new IndexConditioningHelper(indxInfo[0], context, indexFieldsSize1,
+            false/* Asif : pass it as false, irrespective of actual value */, iterOperands, null);
+    IndexConditioningHelper ich2 =
+        new IndexConditioningHelper(indxInfo[1], context, indexFieldsSize2,
+            false/* Asif : pass it as false, irrespective of actual value */, iterOperands, null);
-//    List[] checkList = new List[] { ich1.checkList, ich2.checkList};
+    // List[] checkList = new List[] { ich1.checkList, ich2.checkList};
-        //Asif :If the runtimeIterators of scope not present in CheckSet add it
+        // Asif :If the runtimeIterators of scope not present in CheckSet add it
-    }
-    else {
+    } else {
-        }
-        else if (indpndntItr == ich2.finalList.get(0)) {
+        } else if (indpndntItr == ich2.finalList.get(0)) {
-        }
-        else {
-          List temp = context
-              .getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(indpndntItr);
+        } else {
+          List temp = context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(indpndntItr);
-    Support
-        .Assert(
-            totalFinalList.size() > 1,
-            " Since we are in relationship index this itself means that we have atleast two RuntimeIterators");
+    Support.Assert(totalFinalList.size() > 1,
+        " Since we are in relationship index this itself means that we have atleast two RuntimeIterators");
-    SelectResults returnSet = QueryUtils.createStructCollection(context, stype) ; 
+    SelectResults returnSet = QueryUtils.createStructCollection(context, stype);
-    List[] totalCheckList = new List[] { ich1.checkList, ich2.checkList};
+    List[] totalCheckList = new List[] {ich1.checkList, ich2.checkList};
-    IndexCutDownExpansionHelper[] icdeh = new IndexCutDownExpansionHelper[] {
-        new IndexCutDownExpansionHelper(ich1.checkList, context),
-        new IndexCutDownExpansionHelper(ich2.checkList, context)};
+    IndexCutDownExpansionHelper[] icdeh =
+        new IndexCutDownExpansionHelper[] {new IndexCutDownExpansionHelper(ich1.checkList, context),
+            new IndexCutDownExpansionHelper(ich2.checkList, context)};
-        observer.beforeMergeJoinOfDoubleIndexResults(ich1.indxInfo._index,
-            ich2.indxInfo._index, data);
+        observer.beforeMergeJoinOfDoubleIndexResults(ich1.indxInfo._index, ich2.indxInfo._index,
+            data);
-          //TODO:Asif Change the code in range Index so that while collecting
+          // TODO:Asif Change the code in range Index so that while collecting
-          //two dimensional object array , we create one dimensional Object
+          // two dimensional object array , we create one dimensional Object
-          //stores an Object array
+          // stores an Object array
-          //Asif : Before doing the cartesian of the Results , we need to clear
+          // Asif : Before doing the cartesian of the Results , we need to clear
-          //skip the similar row of a set , even when the row in its entirety
+          // skip the similar row of a set , even when the row in its entirety
-          mergeAndExpandCutDownRelationshipIndexResults(values, returnSet,
-              mappings, expansionListIterator, totalFinalList, context,
-              totalCheckList, iterOperands, icdeh, 0 /* Level */);
-          if (icdeh[0].cutDownNeeded) icdeh[0].checkSet.clear();
+          mergeAndExpandCutDownRelationshipIndexResults(values, returnSet, mappings,
+              expansionListIterator, totalFinalList, context, totalCheckList, iterOperands, icdeh,
+              0 /* Level */);
+          if (icdeh[0].cutDownNeeded)
+            icdeh[0].checkSet.clear();
-      }
-      finally {
+      } finally {
-   * Asif : This function is used ony for testing the private visibility
-   * function
+   * Asif : This function is used ony for testing the private visibility function
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-        (RuntimeIterator[]) dataList.get(1), (List) dataList.get(2),
-        (List) dataList.get(3), (ExecutionContext) dataList.get(4),
-        (List) dataList.get(5), null, null);
-  } 
-  
-  static List queryEquijoinConditionBucketIndexes(IndexInfo[] indxInfo,
-      ExecutionContext context)
-      throws QueryInvocationTargetException, TypeMismatchException,
-      FunctionDomainException, NameResolutionException {
+        (RuntimeIterator[]) dataList.get(1), (List) dataList.get(2), (List) dataList.get(3),
+        (ExecutionContext) dataList.get(4), (List) dataList.get(5), null, null);
+  }
+
+  static List queryEquijoinConditionBucketIndexes(IndexInfo[] indxInfo, ExecutionContext context)
+      throws QueryInvocationTargetException, TypeMismatchException, FunctionDomainException,
+      NameResolutionException {
-      i0 = (pr0 != null) ? PartitionedIndex.getBucketIndex(pr0,
-          index0.getName(), (Integer) b) : indxInfo[0]._index;
-      i1 = (pr1 != null) ? PartitionedIndex.getBucketIndex(pr1,
-          index1.getName(), (Integer) b) : indxInfo[1]._index;
+      i0 = (pr0 != null) ? PartitionedIndex.getBucketIndex(pr0, index0.getName(), (Integer) b)
+          : indxInfo[0]._index;
+      i1 = (pr1 != null) ? PartitionedIndex.getBucketIndex(pr1, index1.getName(), (Integer) b)
+          : indxInfo[1]._index;
+
+
- * This is a helper class which provides information on how an
- * index data be used so as to make it compatible with the query.
- *  
+ * This is a helper class which provides information on how an index data be used so as to make it
+ * compatible with the query.
+ * 
-   * boolean if true implies that the index results need to be iterated so as to
-   * make it compatible with from clause. Shuffling may be needed for any of the
-   * following reasons: 1) Match level not zero ( implying index result
-   * expansion or cutdown) 2) Match level zero , but the relative positions of
-   * iterators in the List of iterators for the group not matching the positions
-   * in the index result StructBag 3) Iter operand is not null. *
-   *  
+   * boolean if true implies that the index results need to be iterated so as to make it compatible
+   * with from clause. Shuffling may be needed for any of the following reasons: 1) Match level not
+   * zero ( implying index result expansion or cutdown) 2) Match level zero , but the relative
+   * positions of iterators in the List of iterators for the group not matching the positions in the
+   * index result StructBag 3) Iter operand is not null. *
+   * 
-  //If shuffling is not needed , then it can be bcoz of two reasons
-  //1) The Index results is a ResultSet & match level is zero ( in that case we
+  // If shuffling is not needed , then it can be bcoz of two reasons
+  // 1) The Index results is a ResultSet & match level is zero ( in that case we
-  //2) The Index results is a StructBag with match level as zero & inddex
+  // 2) The Index results is a StructBag with match level as zero & inddex
-  //   the order of RuntimeIterators. In that case we just have to change the
+  // the order of RuntimeIterators. In that case we just have to change the
-   * An arary of RuntimeIterators whose size is equal to the number of fields in
-   * the Index results. It identifies the RuntimeIterator for the field in the
-   * Index Results. Thus the Runtime Iterator at position 0 will be that for
-   * field 0 in the index result & so on. For those index fields which do not
-   * have a Runtime Iterator assosciated , the value is null (This is the case
-   * if index results require cut down)
-   *  
+   * An arary of RuntimeIterators whose size is equal to the number of fields in the Index results.
+   * It identifies the RuntimeIterator for the field in the Index Results. Thus the Runtime Iterator
+   * at position 0 will be that for field 0 in the index result & so on. For those index fields
+   * which do not have a Runtime Iterator assosciated , the value is null (This is the case if index
+   * results require cut down)
+   * 
-   * The List containing RuntimeIterators to which the index results need to be
-   * expanded This will usually be Final List of RuntimeIterators -
-   * RuntimeIteratosr already accounted for in the index results
+   * The List containing RuntimeIterators to which the index results need to be expanded This will
+   * usually be Final List of RuntimeIterators - RuntimeIteratosr already accounted for in the index
+   * results
-  //Asif : The default is initialized as empty List rather than null to avoid
+  // Asif : The default is initialized as empty List rather than null to avoid
-   * The List containing RuntimeIterators which define the final SelectResults
-   * after the relevant expansion/cutdown of index results
+   * The List containing RuntimeIterators which define the final SelectResults after the relevant
+   * expansion/cutdown of index results
-  //Asif : Though in case of single index usage , if no shuffling is needed (
+  // Asif : Though in case of single index usage , if no shuffling is needed (
-   * This is the List of RuntimeIterators which gets created only if the index
-   * resulst require a cutdown. In such cases , it identifies those Runtime
-   * Iterators of Index Results which will be selected to form the result tuple.
-   * The RuntimeIterators in this List will have corresponding fields in the
-   * resultset obtained from Index usage. This List will be populated only if
-   * there exists fields in index resultset which will not be selected.If all
-   * the fields of index resultset will be used , then this List should be null
-   * or empty. It is used in preventing unnecessary expansion of same type, when
-   * a similar expansion has already occured. as for eg
+   * This is the List of RuntimeIterators which gets created only if the index resulst require a
+   * cutdown. In such cases , it identifies those Runtime Iterators of Index Results which will be
+   * selected to form the result tuple. The RuntimeIterators in this List will have corresponding
+   * fields in the resultset obtained from Index usage. This List will be populated only if there
+   * exists fields in index resultset which will not be selected.If all the fields of index
+   * resultset will be used , then this List should be null or empty. It is used in preventing
+   * unnecessary expansion of same type, when a similar expansion has already occured. as for eg
-   * consider a index result containing 3 fields field1 field2 & field3 . Assume
-   * that field3 is for cutdown. Since the expansion iterators can either be
-   * independent of all the fields in the index result or at the max be
-   * dependent on field1 & field2, we should expand for a given combination of
-   * field1 & field2 , only once ( as we have resulst as Set, we can only have
-   * unique entries) ie. suppose a index result tuple has values ( 1,2 , 3 ) & (
-   * 1,2,4) , we should expand only once ( as field with value 3 & 4 are to be
-   * discarded).
+   * consider a index result containing 3 fields field1 field2 & field3 . Assume that field3 is for
+   * cutdown. Since the expansion iterators can either be independent of all the fields in the index
+   * result or at the max be dependent on field1 & field2, we should expand for a given combination
+   * of field1 & field2 , only once ( as we have resulst as Set, we can only have unique entries)
+   * ie. suppose a index result tuple has values ( 1,2 , 3 ) & ( 1,2,4) , we should expand only once
+   * ( as field with value 3 & 4 are to be discarded).
-   *  
+   * 
-   * Asif: Below Can be null or empty collections if the match level is exact &
-   * no shuffling needed
+   * Asif: Below Can be null or empty collections if the match level is exact & no shuffling needed
-   * Asif : This field is meaninful iff the match level is zero, no shuffling
-   * needed & there exists a StructBag (& not a ResultBag)
+   * Asif : This field is meaninful iff the match level is zero, no shuffling needed & there exists
+   * a StructBag (& not a ResultBag)
-  //TODO:Asif :Test this function out
-  public IndexConditioningHelper(IndexInfo indexInfo, ExecutionContext context,
-      int indexFieldsSize, boolean completeExpansion,
-      CompiledValue iterOperands, RuntimeIterator grpIndpndntItr) {
+  // TODO:Asif :Test this function out
+  public IndexConditioningHelper(IndexInfo indexInfo, ExecutionContext context, int indexFieldsSize,
+      boolean completeExpansion, CompiledValue iterOperands, RuntimeIterator grpIndpndntItr) {
-     * Asif : First obtain the match level of index resultset. If the match
-     * level happens to be zero , this implies that we just have to change the
-     * StructType ( again if only the Index resultset is a StructBag). If the
-     * match level is zero & expand to to top level flag is true & iff the total
-     * no. of iterators in current scope is greater than the no. of fields in
-     * StructBag , then only we need to do any expansion. The grpIndpndtItr
-     * passed can be null if the where clause comprises of just this condition.
-     * However if it is invoked from GroupJunction , it will be not null
-     *  
+     * Asif : First obtain the match level of index resultset. If the match level happens to be zero
+     * , this implies that we just have to change the StructType ( again if only the Index resultset
+     * is a StructBag). If the match level is zero & expand to to top level flag is true & iff the
+     * total no. of iterators in current scope is greater than the no. of fields in StructBag , then
+     * only we need to do any expansion. The grpIndpndtItr passed can be null if the where clause
+     * comprises of just this condition. However if it is invoked from GroupJunction , it will be
+     * not null
+     * 
-    //  Asif Obtain the grpIndpndt iterator if it is passed as null
+    // Asif Obtain the grpIndpndt iterator if it is passed as null
-      Support
-          .Assert(
-              set1.size() == 1,
-              " Since we are in Indexed Evaluate that means there has to be exactly one independent iterator for this compiled comparison");
+      Support.Assert(set1.size() == 1,
+          " Since we are in Indexed Evaluate that means there has to be exactly one independent iterator for this compiled comparison");
-      Support
-          .Assert(
-              this.indpndntItr.getScopeID() == context.currentScope().getScopeID()/*context.getScopeCount()*/,
-              " Since we are in Indexed Evaluate that means the current scope count & indpenedent iterator's scope count should match");
+      Support.Assert(
+          this.indpndntItr.getScopeID() == context.currentScope()
+              .getScopeID()/* context.getScopeCount() */,
+          " Since we are in Indexed Evaluate that means the current scope count & indpenedent iterator's scope count should match");
-      //Asif: Don't do anything , just change the StructType if the set is
+      // Asif: Don't do anything , just change the StructType if the set is
-        Support
-            .Assert(
-                indexInfo._index.getResultSetType() instanceof StructType,
-                " If the match level is zero & the size of mapping array is 1 then Index is surely ResultBag else StructBag");
-        //Asif : The independent iterator is added as the first element
-        grpItrs = context
-            .getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(this.indpndntItr);
-        //Asif : Check if reshuffling is needed or just changing the struct
+        Support.Assert(indexInfo._index.getResultSetType() instanceof StructType,
+            " If the match level is zero & the size of mapping array is 1 then Index is surely ResultBag else StructBag");
+        // Asif : The independent iterator is added as the first element
+        grpItrs = context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(this.indpndntItr);
+        // Asif : Check if reshuffling is needed or just changing the struct
-          this.indexFieldToItrsMapping[pos - 1] = (RuntimeIterator) grpItrs
-              .get(i);
+          this.indexFieldToItrsMapping[pos - 1] = (RuntimeIterator) grpItrs.get(i);
-        //Asif : Even if Reshuffle is not need but if the iter conditions are
+        // Asif : Even if Reshuffle is not need but if the iter conditions are
-          //this.expansionList = Collections.EMPTY_LIST;
+          // this.expansionList = Collections.EMPTY_LIST;
-          //indexReults = QueryUtils.cutDownAndExpandIndexResults(indexReults,
-          //  indexFieldToItrsMapping, Collections.EMPTY_LIST, grpItrs,
-          //context, Collections.EMPTY_LIST, iterOperands);
-        }
-        else {
-          this.structType = QueryUtils
-              .createStructTypeForRuntimeIterators(grpItrs);
-          //indexReults.setElementType(structType);
-          //Asif : Shuffling is not needed. Index results is a StructBag
+          // indexReults = QueryUtils.cutDownAndExpandIndexResults(indexReults,
+          // indexFieldToItrsMapping, Collections.EMPTY_LIST, grpItrs,
+          // context, Collections.EMPTY_LIST, iterOperands);
+        } else {
+          this.structType = QueryUtils.createStructTypeForRuntimeIterators(grpItrs);
+          // indexReults.setElementType(structType);
+          // Asif : Shuffling is not needed. Index results is a StructBag
-          //of the StructBag
+          // of the StructBag
-      }
-      else {
-        //Asif : The finalList should not be left uninitialized, & if the match
+      } else {
+        // Asif : The finalList should not be left uninitialized, & if the match
-        //1 , then the final List should contain only the independent iterator
+        // 1 , then the final List should contain only the independent iterator
-        Support
-            .Assert(
-                this.indexFieldToItrsMapping.length == 1,
-                "In this else block , it should be guaranteed that there exists only one iterator in query as well as index from clause & that should be nothing but the independent RuntimeIterator of the group  ");
+        Support.Assert(this.indexFieldToItrsMapping.length == 1,
+            "In this else block , it should be guaranteed that there exists only one iterator in query as well as index from clause & that should be nothing but the independent RuntimeIterator of the group  ");
-        //Asif :Shuffling is needed if iter operand is not null even if index results is a ResultSet
-        // with match level zero & no expansion needed       
-        this.shufflingNeeded = (iterOperands != null)  ;        
+        // Asif :Shuffling is needed if iter operand is not null even if index results is a
+        // ResultSet
+        // with match level zero & no expansion needed
+        this.shufflingNeeded = (iterOperands != null);
-    }
-    else {
-      //Asif : There is some expansion or truncation needed on the data
+    } else {
+      // Asif : There is some expansion or truncation needed on the data
-      grpItrs = context
-          .getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(this.indpndntItr);
-      //Asif Create an array of RuntimeIterators which map to the fields of the
+      grpItrs = context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(this.indpndntItr);
+      // Asif Create an array of RuntimeIterators which map to the fields of the
-      this.finalList = completeExpansion ? context.getCurrentIterators()
-          : grpItrs;
+      this.finalList = completeExpansion ? context.getCurrentIterators() : grpItrs;
-      //This List contains the RuntimeIterators which are missing from
+      // This List contains the RuntimeIterators which are missing from
-      //boolean cutDownNeeded = false;
+      // boolean cutDownNeeded = false;
-      if (!cutDownNeeded) this.checkList = null;
+      if (!cutDownNeeded)
+        this.checkList = null;
-       * indexReults = QueryUtils.cutDownAndExpandIndexResults(indexReults,
-       * indexFieldToItrsMapping, expansionList, finalList, context, checkList,
-       * iterOperands);
+       * indexReults = QueryUtils.cutDownAndExpandIndexResults(indexReults, indexFieldToItrsMapping,
+       * expansionList, finalList, context, checkList, iterOperands);
+
+
- * This is a helper class which contains informaion on how to
- * expand / cutdown index results for making it compatible with the
- * query.
- *  
+ * This is a helper class which contains informaion on how to expand / cutdown index results for
+ * making it compatible with the query.
+ * 
-   * A SelectResults ( ResultBag or StructBag) object used to prevent
-   * unnecessary expansion of index results as described in
-   * IndexConditionalHelper class.
+   * A SelectResults ( ResultBag or StructBag) object used to prevent unnecessary expansion of index
+   * results as described in IndexConditionalHelper class.
-   * ObjectType for the checkSet object ( An ObjectType for a ResultBag &
-   * StructType for a StructBag)
+   * ObjectType for the checkSet object ( An ObjectType for a ResultBag & StructType for a
+   * StructBag)
-      Boolean orderByClause = (Boolean)context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
+      Boolean orderByClause = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-      if(orderByClause != null && orderByClause.booleanValue()) {
-        List orderByAttrs = (List)context.cacheGet(CompiledValue.ORDERBY_ATTRIB);        
-        useLinkedDataStructure =orderByAttrs.size()==1;
-        nullValuesAtStart = !((CompiledSortCriterion)orderByAttrs.get(0)).getCriterion();
+      if (orderByClause != null && orderByClause.booleanValue()) {
+        List orderByAttrs = (List) context.cacheGet(CompiledValue.ORDERBY_ATTRIB);
+        useLinkedDataStructure = orderByAttrs.size() == 1;
+        nullValuesAtStart = !((CompiledSortCriterion) orderByAttrs.get(0)).getCriterion();
-        
+
-          checkSet = context.isDistinct() ? new LinkedStructSet((StructTypeImpl) checkType) 
-          : new SortedResultsBag<Struct>((StructTypeImpl)checkType, nullValuesAtStart);
+          checkSet = context.isDistinct() ? new LinkedStructSet((StructTypeImpl) checkType)
+              : new SortedResultsBag<Struct>((StructTypeImpl) checkType, nullValuesAtStart);
-          checkSet = QueryUtils.createStructCollection(context, (StructTypeImpl)checkType) ;
+          checkSet = QueryUtils.createStructCollection(context, (StructTypeImpl) checkType);
-      }
-      else {
+      } else {
-          checkSet = context.isDistinct() ? new LinkedResultSet(checkType) :
-            new SortedResultsBag(checkType, nullValuesAtStart); 
+          checkSet = context.isDistinct() ? new LinkedResultSet(checkType)
+              : new SortedResultsBag(checkType, nullValuesAtStart);
-          checkSet = QueryUtils.createResultCollection(context, checkType) ;
+          checkSet = QueryUtils.createResultCollection(context, checkType);
-  
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
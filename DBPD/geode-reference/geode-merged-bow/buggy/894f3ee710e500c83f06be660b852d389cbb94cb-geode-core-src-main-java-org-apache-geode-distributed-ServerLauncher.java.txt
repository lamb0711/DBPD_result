GEODE-3413: overhaul launcher and process classes and tests

This is primarily an overall of all ServerLauncher and LocatorLauncher
tests and org.apache.geode.internal.process tests. The main classes in
org.apachage.geode.internal.process package are also cleaned up.

In addition, several bugs involving these classes and tests are fixed.

Here is the complete list of tickets that are resolved in this overhaul:

* GEODE-1229: LocatorLauncherRemoteJUnitTest.testStartOverwritesStalePidFile
* GEODE-2791: LocatorLauncherAssemblyIntegrationTest.testLocatorStopsWhenJmxPortIsNonZero fails intermittently with AssertionError
* GEODE-1308: CI failure: LocatorLauncherTest.testSetBindAddressToNonLocalHost
* GEODE-1309: CI failure: ServerLauncherTest.testSetServerBindAddressToNonLocalHost
* GEODE-3193: locator pid file is removed even if there was a problem while shutting down
* GEODE-3413: Overhaul launcher tests and process tests
* GEODE-3414: Cleanup org.apache.geode.internal.process package

Note I moved all useful tests from LocatorLauncherAssemblyIntegrationTest
into the other launcher tests in geode-core.

-
+import static org.apache.commons.lang.StringUtils.EMPTY;
+import static org.apache.commons.lang.StringUtils.defaultIfBlank;
+import static org.apache.commons.lang.StringUtils.isBlank;
+import static org.apache.commons.lang.StringUtils.isNotBlank;
+import static org.apache.commons.lang.StringUtils.lowerCase;
+import static org.apache.geode.internal.lang.ObjectUtils.defaultIfNull;
+import static org.apache.geode.internal.lang.StringUtils.wrap;
+import static org.apache.geode.internal.lang.SystemUtils.CURRENT_DIRECTORY;
+import static org.apache.geode.internal.util.IOUtils.tryGetCanonicalPathElseGetAbsolutePath;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.lang.management.ManagementFactory;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.ServiceLoader;
+import java.util.TreeMap;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+import javax.management.MalformedObjectNameException;
+import javax.management.ObjectName;
+
+import joptsimple.OptionException;
+import joptsimple.OptionParser;
+import joptsimple.OptionSet;
-import org.apache.geode.internal.lang.StringUtils;
-import org.apache.geode.internal.lang.SystemUtils;
-import org.apache.geode.internal.process.ClusterConfigurationNotAvailableException;
-import org.apache.geode.internal.util.IOUtils;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.lang.management.ManagementFactory;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.ServiceLoader;
-import java.util.TreeMap;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.management.MalformedObjectNameException;
-import javax.management.ObjectName;
-import joptsimple.OptionException;
-import joptsimple.OptionParser;
-import joptsimple.OptionSet;
-
+    helpMap.put("delete-pid-file-on-stop",
+        "Specifies that this Server's PID file should be deleted on stop.  The default is to not delete this Server's PID file until JVM exit if --delete-pid-file-on-stop is not specified.");
+  private final boolean deletePidFileOnStop;
-    } catch (AttachAPINotFoundException e) {
-      System.err.println(e.getMessage());
+    } catch (AttachAPINotFoundException handled) {
+      System.err.println(handled.getMessage());
-    return (getInstance() != null ? getInstance().status() : null);
+    return getInstance() != null ? getInstance().status() : null;
+    this.deletePidFileOnStop = Boolean.TRUE.equals(builder.getDeletePidFileOnStop());
-    if (StringUtils.isNotBlank(serverPort)) {
+    if (isNotBlank(serverPort)) {
+  @Override
-    return StringUtils.defaultIfBlank(getMemberName(), DEFAULT_SERVER_LOG_NAME)
-        .concat(DEFAULT_SERVER_LOG_EXT);
+    return defaultIfBlank(getMemberName(), DEFAULT_SERVER_LOG_NAME).concat(DEFAULT_SERVER_LOG_EXT);
-    return StringUtils.defaultIfBlank(this.memberName, super.getMemberName());
+    return defaultIfBlank(this.memberName, super.getMemberName());
-    } catch (UnknownHostException ignore) {
-      // TODO determine a better value for the host on which the Server is running to return here...
+    } catch (UnknownHostException handled) {
-      // for localhost
-      // could be found
+      // for localhost could be found
-    return ObjectUtils.defaultIfNull(getServerPort(), getDefaultServerPort()).toString();
+    return defaultIfNull(getServerPort(), getDefaultServerPort()).toString();
+  @Override
-    return StringUtils.isNotBlank(this.springXmlLocation);
+    return isNotBlank(this.springXmlLocation);
-      info(StringUtils.wrap(helpMap.get(command.getName()), 80, ""));
+      info(wrap(helpMap.get(command.getName()), 80, ""));
-      info(StringUtils.wrap("> java ... " + getClass().getName() + ' ' + usageMap.get(command), 80,
-          "\t\t"));
+      info(wrap("> java ... " + getClass().getName() + ' ' + usageMap.get(command), 80, "\t\t"));
-        info(StringUtils.wrap("--" + option + ": " + helpMap.get(option) + '\n', 80, "\t"));
+        info(wrap("--" + option + ": " + helpMap.get(option) + '\n', 80, "\t"));
-    info(StringUtils.wrap(helpMap.get("launcher"), 80, "\t"));
+    info(wrap(helpMap.get("launcher"), 80, "\t"));
-    return (!isRunning() && this.starting.compareAndSet(false, true));
+    return !isRunning() && this.starting.compareAndSet(false, true);
-      } catch (ClusterConfigurationNotAvailableException e) {
-        failOnStart(e);
-        throw e;
-      } catch (RuntimeException e) {
+      } catch (RuntimeException | Error e) {
-      } catch (Error e) {
-        failOnStart(e);
-        throw e;
-      this.process.stop();
+      this.process.stop(this.deletePidFileOnStop);
-    return (isRunning() && (cache.getDistributedSystem().isConnected() || cache.isReconnecting()));
+    return isRunning() && (cache.getDistributedSystem().isConnected() || cache.isReconnecting());
-              wait(500l);
+              wait(500L);
-          } catch (InterruptedException ignore) {
+          } catch (InterruptedException handled) {
+            // loop back around
-    return (cache.getCacheServers().isEmpty() && !isDisableDefaultServer());
+    return cache.getCacheServers().isEmpty() && !isDisableDefaultServer();
-          (getServerBindAddress() == null ? null : getServerBindAddress().getHostAddress());
+          getServerBindAddress() == null ? null : getServerBindAddress().getHostAddress();
-    return (this.starting.get() || isRunning());
+    return this.starting.get() || isRunning();
-      return new ServerState(this, (isRunning() ? Status.ONLINE : Status.STARTING));
+      return new ServerState(this, isRunning() ? Status.ONLINE : Status.STARTING);
-      return new ServerState(this, (isRunning() ? Status.ONLINE : Status.STARTING));
+      return new ServerState(this, isRunning() ? Status.ONLINE : Status.STARTING);
-    }
-    // catch (NoClassDefFoundError error) {
-    // if (isAttachAPINotFound(error)) {
-    // throw new
-    // AttachAPINotFoundException(LocalizedStrings.Launcher_ATTACH_API_NOT_FOUND_ERROR_MESSAGE
-    // .toLocalizedString(), error);
-    // }
-    //
-    // throw error;
-    // }
-    catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException handled) {
-      return createNoResponseState(e, "Failed to connect to server with process id " + getPid());
-    } catch (IOException e) {
-      // failed to open or read file or dir
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + getPid());
-    }
-    // catch (MalformedObjectNameException e) { // impossible
-    // // JMX object name is bad
-    // return createNoResponseState(e, "Failed to communicate with server with process id " +
-    // getPid());
-    // }
-    catch (MBeanInvocationFailedException e) {
-      // MBean either doesn't exist or method or attribute don't exist
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + getPid());
-    }
-    // catch (PidUnavailableException e) {
-    // // couldn't determine pid from within server JVM
-    // return createNoResponseState(e, "Failed to communicate with server with process id " +
-    // getPid());
-    // }
-    catch (UnableToControlProcessException e) {
-      // TODO comment me
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + getPid());
-    } catch (InterruptedException e) {
-      // TODO comment me
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + getPid());
-    } catch (TimeoutException e) {
-      // TODO comment me
-      return createNoResponseState(e,
+      return createNoResponseState(handled,
+          "Failed to connect to server with process id " + getPid());
+    } catch (IOException | MBeanInvocationFailedException | UnableToControlProcessException
+        | InterruptedException | TimeoutException handled) {
+      return createNoResponseState(handled,
-      final ProcessController controller = new ProcessControllerFactory().createProcessController(
-          this.controllerParameters, new File(getWorkingDirectory()),
-          ProcessType.SERVER.getPidFileName(), READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
+      final ProcessController controller =
+          new ProcessControllerFactory().createProcessController(this.controllerParameters,
+              new File(getWorkingDirectory()), ProcessType.SERVER.getPidFileName());
-    } catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException handled) {
-      return createNoResponseState(e, "Failed to connect to server with process id " + parsedPid);
-    } catch (FileNotFoundException e) {
+      return createNoResponseState(handled,
+          "Failed to connect to server with process id " + parsedPid);
+    } catch (FileNotFoundException handled) {
-      return createNoResponseState(e, "Failed to find process file "
+      return createNoResponseState(handled, "Failed to find process file "
-    } catch (IOException e) {
-      // failed to open or read file or dir
-      return createNoResponseState(e,
+    } catch (IOException | MBeanInvocationFailedException | UnableToControlProcessException
+        | TimeoutException handled) {
+      return createNoResponseState(handled,
-    } catch (InterruptedException e) {
+    } catch (InterruptedException handled) {
-      return createNoResponseState(e,
+      return createNoResponseState(handled,
-    } catch (MBeanInvocationFailedException e) {
-      // MBean either doesn't exist or method or attribute don't exist
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + parsedPid);
-    } catch (PidUnavailableException e) {
+    } catch (PidUnavailableException handled) {
-      return createNoResponseState(e, "Failed to find usable process id within file "
+      return createNoResponseState(handled, "Failed to find usable process id within file "
-    } catch (UnableToControlProcessException e) {
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + parsedPid);
-    } catch (TimeoutException e) {
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + parsedPid);
-    // TODO give user detailed error message?
-        this.process.stop();
+        this.process.stop(this.deletePidFileOnStop);
-    }
-    // catch (NoClassDefFoundError error) {
-    // if (isAttachAPINotFound(error)) {
-    // throw new
-    // AttachAPINotFoundException(LocalizedStrings.Launcher_ATTACH_API_NOT_FOUND_ERROR_MESSAGE
-    // .toLocalizedString(), error);
-    // }
-    //
-    // throw error;
-    // }
-    catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException handled) {
-      return createNoResponseState(e, "Failed to connect to server with process id " + getPid());
-    } catch (IOException e) {
-      // failed to open or read file or dir
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + getPid());
-    }
-    // catch (MalformedObjectNameException e) { // impossible
-    // // JMX object name is bad
-    // return createNoResponseState(e, "Failed to communicate with server with process id " +
-    // getPid());
-    // }
-    catch (MBeanInvocationFailedException e) {
-      // MBean either doesn't exist or method or attribute don't exist
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + getPid());
-    }
-    // catch (PidUnavailableException e) {
-    // // couldn't determine pid from within server JVM
-    // return createNoResponseState(e, "Failed to communicate with server with process id " +
-    // getPid());
-    // }
-    catch (UnableToControlProcessException e) {
-      // TODO comment me
-      return createNoResponseState(e,
+      return createNoResponseState(handled,
+          "Failed to connect to server with process id " + getPid());
+    } catch (IOException | MBeanInvocationFailedException
+        | UnableToControlProcessException handled) {
+      return createNoResponseState(handled,
-      final ProcessController controller = new ProcessControllerFactory().createProcessController(
-          this.controllerParameters, new File(getWorkingDirectory()),
-          ProcessType.SERVER.getPidFileName(), READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
+      final ProcessController controller =
+          new ProcessControllerFactory().createProcessController(this.controllerParameters,
+              new File(getWorkingDirectory()), ProcessType.SERVER.getPidFileName());
-    } catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException handled) {
-      return createNoResponseState(e, "Failed to connect to server with process id " + parsedPid);
-    } catch (FileNotFoundException e) {
+      return createNoResponseState(handled,
+          "Failed to connect to server with process id " + parsedPid);
+    } catch (FileNotFoundException handled) {
-      return createNoResponseState(e, "Failed to find process file "
+      return createNoResponseState(handled, "Failed to find process file "
-    } catch (IOException e) {
-      // failed to open or read file or dir
-      return createNoResponseState(e,
+    } catch (IOException | MBeanInvocationFailedException
+        | UnableToControlProcessException handled) {
+      return createNoResponseState(handled,
-    } catch (InterruptedException e) {
+    } catch (InterruptedException handled) {
-      return createNoResponseState(e,
+      return createNoResponseState(handled,
-    } catch (MBeanInvocationFailedException e) {
-      // MBean either doesn't exist or method or attribute don't exist
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + parsedPid);
-    } catch (PidUnavailableException e) {
+    } catch (PidUnavailableException handled) {
-      return createNoResponseState(e, "Failed to find usable process id within file "
+      return createNoResponseState(handled, "Failed to find usable process id within file "
-    } catch (TimeoutException e) {
-      return createNoResponseState(e, "Timed out trying to find usable process id within file "
-          + ProcessType.SERVER.getPidFileName() + " in " + getWorkingDirectory());
-    } catch (UnableToControlProcessException e) {
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + parsedPid);
+    } catch (TimeoutException handled) {
+      return createNoResponseState(handled,
+          "Timed out trying to find usable process id within file "
+              + ProcessType.SERVER.getPidFileName() + " in " + getWorkingDirectory());
-
-  private Properties getOverriddenDefaults() {
+  private Properties getOverriddenDefaults() throws IOException {
-        getLogFileName());
+        getLogFile().getCanonicalPath());
-    public File getWorkingDirectory() {
+    public File getDirectory() {
-      } catch (MalformedObjectNameException | NullPointerException ignore) {
+      } catch (MalformedObjectNameException | NullPointerException handled) {
+    private Boolean deletePidFileOnStop;
+        setDeletePidFileOnStop(options.has("delete-pid-file-on-stop"));
-        // TODO why are these option not inside the 'if (!isHelping())' conditional block!?
+        // why are these option not inside the 'if (!isHelping())' conditional block?
-      return ObjectUtils.defaultIfNull(this.command, DEFAULT_COMMAND);
+      return defaultIfNull(this.command, DEFAULT_COMMAND);
-     * Determines whether a default cache server will be added when the GemFire Server comes online.
+     * Determines whether the Geode Server should delete the pid file when its service stops or when
+     * the JVM exits.
+     *
+     * @return a boolean value indicating if the pid file should be deleted when this service stops
+     *         or when the JVM exits.
+     * @see #setDeletePidFileOnStop(Boolean)
+     */
+    public Boolean getDeletePidFileOnStop() {
+      return this.deletePidFileOnStop;
+    }
+
+    /**
+     * Sets whether the Geode Server should delete the pid file when its service stops or when the
+     * JVM exits.
+     *
+     * @param deletePidFileOnStop a boolean value indicating if the pid file should be deleted when
+     *        this service stops or when the JVM exits.
+     * @return this Builder instance.
+     * @see #getDeletePidFileOnStop()
+     */
+    public Builder setDeletePidFileOnStop(final Boolean deletePidFileOnStop) {
+      this.deletePidFileOnStop = deletePidFileOnStop;
+      return this;
+    }
+
+    /**
+     * Determines whether a default cache server will be added when the Geode Server comes online.
-     * @see org.apache.geode.internal.process.LocalProcessLauncher
-      return ObjectUtils.defaultIfNull(this.force, DEFAULT_FORCE);
+      return defaultIfNull(this.force, DEFAULT_FORCE);
-     * @see org.apache.geode.internal.process.LocalProcessLauncher
-      if (StringUtils.isBlank(memberName)) {
+      if (isBlank(memberName)) {
-     * Determines whether the new instance of LocatorLauncher will redirect output to system logs
-     * when starting a Locator.
+     * Determines whether the new instance of ServerLauncher will redirect output to system logs
+     * when starting a Server.
-     *         a Locator
+     *         a Server
-     * Sets whether the new instance of LocatorLauncher will redirect output to system logs when
-     * starting a Locator.
+     * Sets whether the new instance of ServerLauncher will redirect output to system logs when
+     * starting a Server.
-     *        when starting a Locator.
+     *        when starting a Server.
-      if (StringUtils.isBlank(serverBindAddress)) {
+      if (isBlank(serverBindAddress)) {
-      return ObjectUtils.defaultIfNull(this.serverPort, getDefaultServerPort());
+      return defaultIfNull(this.serverPort, getDefaultServerPort());
-      return IOUtils.tryGetCanonicalPathElseGetAbsolutePath(
-          new File(StringUtils.defaultIfBlank(this.workingDirectory, DEFAULT_WORKING_DIRECTORY)));
+      return tryGetCanonicalPathElseGetAbsolutePath(
+          new File(defaultIfBlank(this.workingDirectory, DEFAULT_WORKING_DIRECTORY)));
-      if (!(new File(StringUtils.defaultIfBlank(workingDirectory, DEFAULT_WORKING_DIRECTORY))
-          .isDirectory())) {
+      if (!new File(defaultIfBlank(workingDirectory, DEFAULT_WORKING_DIRECTORY)).isDirectory()) {
+      if (isBlank(hostNameForClients)) {
+        throw new IllegalArgumentException(
+            "The hostname used by clients to connect to the Server must have an argument if the --hostname-for-clients command-line option is specified!");
+      }
-        if (StringUtils.isBlank(getMemberName())
+        if (isBlank(getMemberName())
-        if (!SystemUtils.CURRENT_DIRECTORY.equals(getWorkingDirectory())) {
+        if (!CURRENT_DIRECTORY.equals(getWorkingDirectory())) {
-      assert StringUtils.isNotBlank(name) : "The name of the command must be specified!";
+      assert isNotBlank(name) : "The name of the command must be specified!";
-      this.options = (options != null ? Collections.unmodifiableList(Arrays.asList(options))
-          : Collections.<String>emptyList());
+      this.options = options != null ? Collections.unmodifiableList(Arrays.asList(options))
+          : Collections.<String>emptyList();
-      return (valueOfName(name) != null);
+      return valueOfName(name) != null;
-      return (command == null || command.isUnspecified());
+      return command == null || command.isUnspecified();
-     * Gets a set of valid options that can be used with the Locator launcher command when used from
+     * Gets a set of valid options that can be used with the Server launcher command when used from
-     * Determines whether this Locator launcher command has the specified command-line option.
+     * Determines whether this Server launcher command has the specified command-line option.
-      return getOptions().contains(StringUtils.lowerCase(option));
+      return getOptions().contains(lowerCase(option));
-      return (this == UNSPECIFIED);
+      return this == UNSPECIFIED;
-   * The ServerState is an immutable type representing the state of the specified Locator at any
-   * given moment in time. The state of the Locator is assessed at the exact moment an instance of
+   * The ServerState is an immutable type representing the state of the specified Server at any
+   * given moment in time. The state of the Server is assessed at the exact moment an instance of
-        // TODO: or should we return OFFLINE?
-          final String logFileCanonicalPath =
-              IOUtils.tryGetCanonicalPathElseGetAbsolutePath(logFile);
-          if (StringUtils.isNotBlank(logFileCanonicalPath)) {
+          final String logFileCanonicalPath = tryGetCanonicalPathElseGetAbsolutePath(logFile);
+          if (isNotBlank(logFileCanonicalPath)) {
-          if (StringUtils.isNotBlank(serverBindAddressAsString)) {
+          if (isNotBlank(serverBindAddressAsString)) {
-          if (StringUtils.isNotBlank(portAsString)) {
+          if (isNotBlank(portAsString)) {
-      return (launcher.isDisableDefaultServer() ? StringUtils.EMPTY
-          : launcher.getServerPortAsString());
+      return launcher.isDisableDefaultServer() ? EMPTY : launcher.getServerPortAsString();

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 UPD40 INS40 INS40 INS40 INS40 UPD40 UPD40 UPD40 UPD40 INS23 INS83 INS83 INS39 INS59 INS78 INS78 INS43 INS23 INS31 INS31 INS21 INS42 INS21 INS42 INS42 INS42 UPD42 INS83 INS43 INS59 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS44 INS8 INS32 MOV16 INS7 MOV27 MOV27 MOV27 MOV27 INS42 INS42 INS65 INS65 INS65 INS42 INS41 INS65 INS65 INS65 INS65 INS42 INS83 INS43 INS42 INS21 INS41 INS25 UPD66 UPD66 INS42 INS42 INS45 INS45 INS22 INS32 MOV12 INS44 MOV44 INS32 INS66 INS66 INS66 INS66 INS68 INS22 INS66 INS66 INS42 INS66 INS66 INS66 INS68 INS42 INS7 INS52 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS32 INS8 MOV27 MOV27 UPD66 UPD66 MOV27 MOV16 UPD42 INS52 INS42 INS40 INS42 INS32 UPD42 UPD42 INS84 INS42 UPD42 UPD42 INS84 INS42 UPD42 UPD42 MOV43 INS42 INS84 INS42 UPD42 UPD42 INS84 INS42 UPD42 UPD42 UPD42 MOV32 INS42 INS21 INS42 INS69 INS52 INS42 INS42 INS22 INS42 INS32 INS42 INS42 INS53 MOV16 INS42 INS42 INS42 INS22 MOV16 MOV16 MOV16 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 UPD42 UPD42 INS32 INS43 INS52 INS42 MOV14 MOV42 INS14 INS84 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS32 INS42 INS43 INS45 UPD42 MOV43 MOV43 INS22 INS42 INS42 INS45 INS42 INS42 INS52 INS42 UPD42 UPD34 DEL36 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL36 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL36 DEL36 DEL36 DEL36 DEL36 DEL36 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL40 DEL42 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL40 DEL42 DEL44 DEL42 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL40 DEL65 DEL42 DEL40 DEL65 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL36 DEL42 DEL40 DEL42 DEL36 DEL36 DEL36 DEL42 DEL36 DEL42 DEL42 DEL42 DEL42 DEL40 DEL36
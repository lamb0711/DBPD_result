GEODE-2410: Lucene afterPrimary and afterSecondary calls pass through the same crit section.

	* afterPrimary and afterSecondary calls are passed through the same critical section.
	* If the caller is primary bucket, it will try to acquire a Dlock on the bucket and create the index repo.
	* If it is secondary it will clean up the repo - close the writer and release the locks.
	* If the primary changes to secondary while waiting for indexes to be created, it will exit from the critical section without acquiring the lock.

-  public IndexRepository createIndexRepository(final Integer bucketId, LuceneSerializer serializer,
-      LuceneIndexImpl index, PartitionedRegion userRegion) throws IOException {
-    final IndexRepository repo;
+  public IndexRepository computeIndexRepository(final Integer bucketId, LuceneSerializer serializer,
+      LuceneIndexImpl index, PartitionedRegion userRegion, final IndexRepository oldRepository)
+      throws IOException {
+      oldRepository.cleanup();
-      throw new IOException("Not creating the index because we are not the primary");
+      oldRepository.cleanup();
+      return null;
-    DistributedLockService lockService =
-        DistributedLockService.getServiceNamed(PartitionedRegionHelper.PARTITION_LOCK_SERVICE_NAME);
-    String lockName = FILE_REGION_LOCK_FOR_BUCKET_ID + fileBucket.getFullPath() + bucketId;
-    if (lockService != null) {
-      // lockService will be null for testing at this point
-      lockService.lock(lockName, -1, -1);
+
+    if (oldRepository != null && !oldRepository.isClosed()) {
+      return oldRepository;
+
+    if (oldRepository != null && oldRepository.isClosed()) {
+      oldRepository.cleanup();
+    }
+    DistributedLockService lockService = getLockService();
+    String lockName = getLockName(bucketId, fileBucket);
+    while (!lockService.lock(lockName, 100, -1)) {
+      if (!fileBucket.getBucketAdvisor().isPrimary()) {
+        return null;
+      }
+    }
+
+
+    final IndexRepository repo;
-        if (lockService != null) {
-          lockService.unlock(lockName);
-        }
+        lockService.unlock(lockName);
+  private String getLockName(final Integer bucketId, final BucketRegion fileBucket) {
+    return FILE_REGION_LOCK_FOR_BUCKET_ID + fileBucket.getFullPath() + bucketId;
+  }
+
+  private DistributedLockService getLockService() {
+    return DistributedLockService
+        .getServiceNamed(PartitionedRegionHelper.PARTITION_LOCK_SERVICE_NAME);
+  }
+

INS31 INS31 UPD42 INS44 MOV60 INS83 MOV43 INS42 INS44 INS44 INS8 INS83 MOV43 INS42 INS8 INS83 INS43 INS42 INS25 INS25 INS61 INS83 INS43 INS42 INS83 INS43 INS42 INS41 INS41 INS42 INS8 INS27 INS8 INS27 INS8 INS43 INS43 INS38 INS8 MOV8 INS42 INS42 MOV27 MOV32 INS21 INS41 INS21 INS41 INS27 INS38 INS41 INS27 INS32 INS21 INS42 INS32 INS42 INS32 INS32 INS25 INS32 INS33 INS32 INS33 INS42 INS33 INS32 INS42 INS42 INS33 INS42 INS42 INS32 INS42 INS42 INS42 INS42 MOV42 MOV42 MOV42 INS34 MOV38 INS38 MOV8 MOV38 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 DEL42 DEL43 DEL45 DEL14 DEL53 DEL42 DEL33 DEL27 DEL34 DEL38 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL25 DEL8
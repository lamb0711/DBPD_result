GEODE-1659: put security properties in the cluster config and applied to all the members in the cluster.

 * break down request and apply cluster configuration into individual steps so that we can apply properties before starting services, and apply cache.xml after services are started
 * added more dunit tests

-import org.apache.geode.redis.GeodeRedisServer;
+import org.apache.commons.lang.StringUtils;
+import org.apache.geode.GemFireConfigException;
-import org.apache.geode.cache.CacheRuntimeException;
+import org.apache.geode.distributed.ConfigurationProperties;
+import org.apache.geode.distributed.internal.SharedConfiguration;
-import org.apache.geode.internal.net.SocketCreator;
+import org.apache.geode.internal.security.SecurityService;
+import org.apache.geode.management.internal.configuration.domain.Configuration;
+import org.apache.geode.redis.GeodeRedisServer;
+  private static SecurityService securityService = SecurityService.getSecurityService();
+
-   * Applies the shared configuration to this cache, only if its a GEMFIRE && NON-LOCATOR && NON-CLIENT cache 
-  public void requestAndApplySharedConfiguration() {
+  public ConfigurationResponse requestSharedConfiguration() {
-    if (dm instanceof DistributionManager) {
-      if (((DistributionManager) dm).getDMType() != DistributionManager.LOCATOR_DM_TYPE
-          && !isClient
-          && Locator.getLocator() == null
-          ) {
-        
-        boolean useSharedConfiguration = config.getUseSharedConfiguration();
+    if (!(dm instanceof DistributionManager))
+      return null;
-        if (useSharedConfiguration) {
-          Map<InternalDistributedMember, Collection<String>> scl = this.getDistributionManager().getAllHostedLocatorsWithSharedConfiguration();
+    // do nothing if this vm is/has locator or this is a client
+    if( ((DistributionManager)dm).getDMType() == DistributionManager.LOCATOR_DM_TYPE
+      || isClient
+      || Locator.getLocator() !=null )
+      return null;
-          //If there are no locators with Shared configuration, that means the system has been started without shared configuration 
-          //then do not make requests to the locators
-          if (!scl.isEmpty()) {
-            String groupsString = config.getGroups();
-            ConfigurationResponse response = null;
-            List<String> locatorConnectionStrings = getSharedConfigLocatorConnectionStringList();
-            
-            try {
-              response = ClusterConfigurationLoader.requestConfigurationFromLocators(ClusterConfigurationLoader.getGroups(groupsString), locatorConnectionStrings);
+    Map<InternalDistributedMember, Collection<String>> scl = this.getDistributionManager().getAllHostedLocatorsWithSharedConfiguration();
-              //log the configuration received from the locator
-              logger.info(LocalizedMessage.create(LocalizedStrings.GemFireCache_RECEIVED_SHARED_CONFIGURATION_FROM_LOCATORS));
-              logger.info(response.describeConfig());
-              
-              //deploy the Jars
-              ClusterConfigurationLoader.deployJarsReceivedFromClusterConfiguration(this, response);
+    //If there are no locators with Shared configuration, that means the system has been started without shared configuration
+    //then do not make requests to the locators
+    if(scl.isEmpty()) {
+      logger.info(LocalizedMessage.create(LocalizedStrings.GemFireCache_NO_LOCATORS_FOUND_WITH_SHARED_CONFIGURATION));
+      return null;
+    }
-              //Apply the xml configuration 
-              ClusterConfigurationLoader.applyClusterConfiguration(this, response, ClusterConfigurationLoader.getGroups(groupsString));
+    String groupsString = config.getGroups();
+    ConfigurationResponse response = null;
+    List<String> locatorConnectionStrings = getSharedConfigLocatorConnectionStringList();
-            } catch (ClusterConfigurationNotAvailableException e) {
-              throw new CacheRuntimeException(LocalizedStrings.GemFireCache_SHARED_CONFIGURATION_NOT_AVAILABLE.toLocalizedString(), e) {
-                private static final long serialVersionUID = 1L;
-              };
-            } catch (IOException e) {
-              throw new CacheRuntimeException(LocalizedStrings.GemFireCache_EXCEPTION_OCCURED_WHILE_DEPLOYING_JARS_FROM_SHARED_CONDFIGURATION.toLocalizedString(), e) {
-                private static final long serialVersionUID = 1L;
-              };      
-            } catch (ClassNotFoundException e) {
-              throw new CacheRuntimeException(LocalizedStrings.GemFireCache_EXCEPTION_OCCURED_WHILE_DEPLOYING_JARS_FROM_SHARED_CONDFIGURATION.toLocalizedString(), e) {
-                private static final long serialVersionUID = 1L;
-              };
-            }
-          } else {
-            logger.info(LocalizedMessage.create(LocalizedStrings.GemFireCache_NO_LOCATORS_FOUND_WITH_SHARED_CONFIGURATION));
-          }
+    try {
+      response = ClusterConfigurationLoader.requestConfigurationFromLocators(system.getConfig(), locatorConnectionStrings);
+
+      //log the configuration received from the locator
+      logger.info(LocalizedMessage.create(LocalizedStrings.GemFireCache_RECEIVED_SHARED_CONFIGURATION_FROM_LOCATORS));
+      logger.info(response.describeConfig());
+
+      Configuration clusterConfig = response.getRequestedConfiguration().get(SharedConfiguration.CLUSTER_CONFIG);
+      Properties clusterSecProperties = (clusterConfig==null) ? new Properties():clusterConfig.getGemfireProperties();
+
+      // If not using shared configuration, return null or throw an exception is locator is secured
+      if(!config.getUseSharedConfiguration()){
+        if (clusterSecProperties.containsKey(ConfigurationProperties.SECURITY_MANAGER)) {
+          throw new GemFireConfigException(LocalizedStrings.GEMFIRE_CACHE_SECURITY_MISCONFIGURATION_2.toLocalizedString());
+          return null;
+
+      Properties serverSecProperties = config.getSecurityProps();
+      //check for possible mis-configuration
+      if (isMisConfigured(clusterSecProperties, serverSecProperties, ConfigurationProperties.SECURITY_MANAGER)
+       || isMisConfigured(clusterSecProperties, serverSecProperties, ConfigurationProperties.SECURITY_POST_PROCESSOR)) {
+        throw new GemFireConfigException(LocalizedStrings.GEMFIRE_CACHE_SECURITY_MISCONFIGURATION.toLocalizedString());
+      }
+      return response;
+
+    } catch (ClusterConfigurationNotAvailableException e) {
+      throw new GemFireConfigException(LocalizedStrings.GemFireCache_SHARED_CONFIGURATION_NOT_AVAILABLE.toLocalizedString(), e);
+    } catch (UnknownHostException e) {
+      throw new GemFireConfigException(e.getLocalizedMessage(), e);
-  
+
+  public void deployJarsRecevedFromClusterConfiguration(ConfigurationResponse response){
+    try{
+      ClusterConfigurationLoader.deployJarsReceivedFromClusterConfiguration(this, response);
+    } catch (IOException e) {
+      throw new GemFireConfigException(LocalizedStrings.GemFireCache_EXCEPTION_OCCURED_WHILE_DEPLOYING_JARS_FROM_SHARED_CONDFIGURATION.toLocalizedString(), e);
+    } catch (ClassNotFoundException e) {
+      throw new GemFireConfigException(LocalizedStrings.GemFireCache_EXCEPTION_OCCURED_WHILE_DEPLOYING_JARS_FROM_SHARED_CONDFIGURATION.toLocalizedString(), e);
+    }
+  }
+
+
+  // When called, clusterProps and serverProps and key could not be null
+  public static boolean isMisConfigured(Properties clusterProps, Properties serverProps, String key){
+    String clusterPropValue = clusterProps.getProperty(key);
+    String serverPropValue = serverProps.getProperty(key);
+
+    // if this server prop is not specified, this is always OK.
+    if(StringUtils.isBlank(serverPropValue))
+      return false;
+
+    // server props is not blank, but cluster props is blank, NOT OK.
+    if(StringUtils.isBlank(clusterPropValue))
+      return true;
+
+    // at this point check for eqality
+    return !clusterPropValue.equals(serverPropValue);
+  }
+
+
+    //request and check cluster configuration
+    ConfigurationResponse configurationResponse = requestSharedConfiguration();
+    deployJarsRecevedFromClusterConfiguration(configurationResponse);
+
+    // apply the cluster's properties configuration and initialize security using that configuration
+    ClusterConfigurationLoader.applyClusterPropertiesConfiguration(this, configurationResponse, system.getConfig());
+    securityService.initSecurity(system.getConfig().getSecurityProps());
-    
+
-    this.jmxAdvisor.initializationGate();  
+    this.jmxAdvisor.initializationGate();
+
+    // this starts up the ManagementService, register and federate the internal beans
-    
-    
+
-    
+
-      requestAndApplySharedConfiguration();
+      ClusterConfigurationLoader.applyClusterXmlConfiguration(this, configurationResponse, system.getConfig());
+    securityService.close();
+

MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS40 UPD40 INS40 INS40 UPD40 INS40 INS23 INS31 INS31 INS83 INS83 INS43 INS59 INS43 UPD42 MOV8 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS42 INS42 INS32 INS42 MOV60 INS25 INS25 MOV60 INS25 MOV60 MOV60 MOV60 MOV54 INS43 INS42 INS54 INS43 INS42 INS43 INS42 INS43 INS42 INS60 INS60 INS25 INS25 INS41 INS60 INS21 INS21 INS21 INS21 INS42 INS42 MOV38 INS41 UPD27 MOV27 INS41 MOV32 MOV8 INS8 INS42 INS8 INS12 INS12 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS41 INS32 INS41 INS38 INS43 INS59 INS32 INS32 INS32 INS32 INS36 INS33 UPD27 UPD27 INS33 INS41 MOV21 MOV21 MOV21 INS60 INS60 INS25 INS60 INS25 INS41 MOV44 INS44 MOV21 MOV44 INS8 MOV44 INS8 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS9 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS52 INS42 INS32 INS42 INS42 INS32 INS42 INS42 MOV62 UPD27 INS42 INS33 INS43 INS59 INS43 INS59 INS38 INS8 INS43 INS59 INS27 INS8 INS42 INS43 INS42 INS53 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS16 MOV32 INS25 INS42 INS42 INS32 INS32 INS32 MOV53 INS42 INS14 INS14 INS42 INS42 INS42 UPD42 INS52 INS42 INS32 INS32 INS42 INS40 INS36 INS14 INS32 INS32 INS8 MOV8 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS40 INS42 INS42 INS42 INS40 UPD43 MOV32 UPD43 INS32 INS42 INS43 MOV32 INS42 INS43 MOV32 INS42 INS42 INS42 UPD42 UPD42 MOV42 INS42 INS27 INS43 INS42 INS42 INS42 INS42 INS40 INS53 INS41 UPD43 INS32 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS14 INS33 UPD42 INS40 INS42 INS43 INS32 INS42 INS40 INS42 DEL66 DEL39 DEL42 DEL38 DEL42 DEL42 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL1 DEL42 DEL42 DEL52 DEL32 DEL32 DEL21 DEL8 DEL8 DEL12 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL1 DEL42 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL1 DEL39 DEL42 DEL59 DEL60 DEL42 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL25 DEL8
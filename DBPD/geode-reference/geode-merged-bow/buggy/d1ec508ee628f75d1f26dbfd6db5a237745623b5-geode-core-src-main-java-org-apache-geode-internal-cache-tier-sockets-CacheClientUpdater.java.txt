GEODE-2632: refactoring preparations for SecurityService and BaseCommand changes

- * <code>CacheClientUpdater</code> is a thread that processes update messages from a cache server
- * and {@linkplain org.apache.geode.cache.Region#localInvalidate(Object) invalidates} the local
- * cache based on the contents of those messages.
+ * {@code CacheClientUpdater} is a thread that processes update messages from a cache server and
+ * {@linkplain org.apache.geode.cache.Region#localInvalidate(Object) invalidates} the local cache
+ * based on the contents of those messages.
+  private static final int DEFAULT_SOCKET_BUFFER_SIZE = 32768;
+
+
-  private boolean commBufferReleased;
+  private boolean commBufferReleased; // TODO: fix synchronization
-   * Cache for which we provide service
+   * Cache for which we provide service TODO: lifecycle and synchronization need work
-  public final static String CLIENT_UPDATER_THREAD_NAME = "Cache Client Updater Thread ";
+  public static final String CLIENT_UPDATER_THREAD_NAME = "Cache Client Updater Thread ";
-   * to enable test flag
+   * to enable test flag TODO: eliminate isUsedByTest
-   * bytes.
+   * bytes. TODO: only used for test assertion
-  public static boolean fullValueRequested = false;
+  static boolean fullValueRequested = false;
-  static private final long MAX_CACHE_WAIT = Long
-      .getLong(DistributionConfig.GEMFIRE_PREFIX + "CacheClientUpdater.MAX_WAIT", 120).longValue(); // seconds
+  private static final long MAX_CACHE_WAIT =
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "CacheClientUpdater.MAX_WAIT", 120); // seconds
-      } catch (InterruptedException e) {
+      } catch (InterruptedException ignore) {
-   * Creates a new <code>CacheClientUpdater</code> with a given name that waits for a server to
-   * connect on a given port.
+   * Creates a new {@code CacheClientUpdater} with a given name that waits for a server to connect
+   * on a given port.
-   * @param primary true if our endpoint is primary TODO ask the ep for this?
+   * @param primary true if our endpoint is primary
+
+
-          Integer.getInteger("BridgeServer.SOCKET_BUFFER_SIZE", 32768).intValue();
+          Integer.getInteger("BridgeServer.SOCKET_BUFFER_SIZE", DEFAULT_SOCKET_BUFFER_SIZE);
-      {
-        int bufSize = 1024;
-        try {
-          bufSize = mySock.getSendBufferSize();
-          if (bufSize < 1024) {
-            bufSize = 1024;
-          }
-        } catch (SocketException ignore) {
+      int bufSize = 1024;
+      try {
+        bufSize = mySock.getSendBufferSize();
+        if (bufSize < 1024) {
+          bufSize = 1024;
-        cb = ServerConnection.allocateCommBuffer(bufSize, mySock);
+      } catch (SocketException ignore) {
-      {
-        // create a "server" memberId we currently don't know much about the
-        // server.
-        // Would be nice for it to send us its member id
-        // TODO: change the serverId to use the endpoint's getMemberId() which
-        // returns a
-        // DistributedMember (once gfecq branch is merged to trunk).
-        MemberAttributes ma =
-            new MemberAttributes(0, -1, DistributionManager.NORMAL_DM_TYPE, -1, null, null, null);
-        sid = new InternalDistributedMember(mySock.getInetAddress(), mySock.getPort(), false, true,
-            ma);
-      }
+      cb = ServerConnection.allocateCommBuffer(bufSize, mySock);
+
+      // create a "server" memberId we currently don't know much about the server.
+      // Would be nice for it to send us its member id
+      // TODO: change the serverId to use the endpoint's getMemberId() which returns a
+      // DistributedMember (once gfecq branch is merged to trunk).
+      MemberAttributes ma =
+          new MemberAttributes(0, -1, DistributionManager.NORMAL_DM_TYPE, -1, null, null, null);
+      sid =
+          new InternalDistributedMember(mySock.getInetAddress(), mySock.getPort(), false, true, ma);
+
-    } catch (ConnectException e) {
+    } catch (ConnectException ignore) {
-      connected = success;
+      this.connected = success;
-        } catch (SocketException e) {
+        } catch (SocketException ignore) {
-      if (connected) {
-        socket = mySock;
-        out = tmpOut;
-        in = tmpIn;
-        serverId = sid;
-        commBuffer = cb;
+
+      if (this.connected) {
+        this.socket = mySock;
+        this.out = tmpOut;
+        this.in = tmpIn;
+        this.serverId = sid;
+        this.commBuffer = cb;
+
+
-        socket = null;
-        serverId = null;
-        commBuffer = null;
-        out = null;
-        in = null;
+        this.socket = null;
+        this.serverId = null;
+        this.commBuffer = null;
+        this.out = null;
+        this.in = null;
-    return connected;
+    return this.connected;
+  @Override
-    return isPrimary;
+    return this.isPrimary;
+  @Override
-   * Performs the work of the client update thread. Creates a <code>ServerSocket</code> and waits
-   * for the server to connect to it.
+   * Performs the work of the client update thread. Creates a {@code ServerSocket} and waits for the
+   * server to connect to it.
+    EntryLogger.setSource(this.serverId, "RI");
-    EntryLogger.setSource(serverId, "RI");
-    } catch (CancelException e) {
-      return; // just bail
+
+    } catch (CancelException ignore) {
+      // just bail
+
-  protected void stopProcessing() {
-    continueProcessing.set(false);// = false;
+  private void stopProcessing() {
+    this.continueProcessing.set(false);
-  public void stopUpdater() {
+  private void stopUpdater() {
-
+
-    // this.close(); // this should not be done here.
+
-          if (socket != null) {
-            socket.close();
+          if (this.socket != null) {
+            this.socket.close();
-        } catch (VirtualMachineError err) {
-          SystemFailure.initiateFailure(err);
-          // If this ever returns, rethrow the error. We're poisoned
-          // now, so don't let this thread continue.
-          throw err;
-        } catch (Throwable t) {
-          // Whenever you catch Error or Throwable, you must also
-          // catch VirtualMachineError (see above). However, there is
-          // _still_ a possibility that you are dealing with a cascading
-          // error condition, so you also need to check to see if the JVM
-          // is still usable:
-          SystemFailure.checkFailure();
-          // dont care...
+        } catch (IOException e) {
-            logger.debug(t.getMessage(), t);
+            logger.debug(e.getMessage(), e);
+  @Override
-    this.continueProcessing.set(false);// = false; // signals we are done.
+    this.continueProcessing.set(false); // signals we are done.
-    // Close the socket
-    // This will also cause the underlying streams to fail.
+    // Close the socket. This will also cause the underlying streams to fail.
-      if (socket != null) {
-        socket.close();
+      if (this.socket != null) {
+        this.socket.close();
-    } catch (Exception e) {
+    } catch (IOException ignore) {
-    try {
-      this.stats.close();
-    } catch (Exception e) {
-      // ignore
-    }
+    this.stats.close();
-    try {
-      if (cacheHelper != null) {
-        cacheHelper.close();
-      }
-    } catch (Exception e) {
-      // ignore
+    if (this.cacheHelper != null) {
+      this.cacheHelper.close();
-    Message _message = new Message(2, Version.CURRENT);
-    try {
-      _message.setComms(socket, in, out, commBuffer, this.stats);
-    } catch (IOException e) {
-      if (!quitting()) {
-        if (logger.isDebugEnabled()) {
-          logger.debug(
-              "{}: Caught following exception while attempting to initialize a server-to-client communication socket and will exit",
-              this, e);
-        }
-        stopProcessing();
-      }
-    }
-    return _message;
+    Message message = new Message(2, Version.CURRENT);
+    message.setComms(this.socket, this.in, this.out, this.commBuffer, this.stats);
+    return message;
-    return this.getName() + " (" + this.location.getHostName() + ":" + this.location.getPort()
-        + ")";
+    return getName() + " (" + this.location.getHostName() + ':' + this.location.getPort() + ')';
-   * @param m message containing the data
+   * @param clientMessage message containing the data
-  private void handleMarker(Message m) {
+  private void handleMarker(Message clientMessage) {
-        logger.debug("Received marker message of length ({} bytes)", m.getPayloadLength());
+        logger.debug("Received marker message of length ({} bytes)",
+            clientMessage.getPayloadLength());
+
+
-   * @param m message containing the data
+   * @param clientMessage message containing the data
-  private void handleUpdate(Message m) {
+  private void handleUpdate(Message clientMessage) {
-    Object newValue = null;
-    byte[] deltaBytes = null;
-    Object fullValue = null;
-    boolean isValueObject = false;
-    int partCnt = 0;
+
+
-        logger.debug("Received put message of length ({} bytes)", m.getPayloadLength());
+        logger.debug("Received put message of length ({} bytes)", clientMessage.getPayloadLength());
-      Part regionNamePart = m.getPart(partCnt++);
-      Part keyPart = m.getPart(partCnt++);
-      boolean isDeltaSent = ((Boolean) m.getPart(partCnt++).getObject()).booleanValue();
-      valuePart = m.getPart(partCnt++);
-      Part callbackArgumentPart = m.getPart(partCnt++);
-      VersionTag versionTag = (VersionTag) m.getPart(partCnt++).getObject();
+      int partCnt = 0;
+      Part regionNamePart = clientMessage.getPart(partCnt++);
+      Part keyPart = clientMessage.getPart(partCnt++);
+      boolean isDeltaSent = (Boolean) clientMessage.getPart(partCnt++).getObject();
+      valuePart = clientMessage.getPart(partCnt++);
+      Part callbackArgumentPart = clientMessage.getPart(partCnt++);
+      VersionTag versionTag = (VersionTag) clientMessage.getPart(partCnt++).getObject();
-      Part isInterestListPassedPart = m.getPart(partCnt++);
-      Part hasCqsPart = m.getPart(partCnt++);
+      Part isInterestListPassedPart = clientMessage.getPart(partCnt++);
+      Part hasCqsPart = clientMessage.getPart(partCnt++);
-      EventID eventId = (EventID) m.getPart(m.getNumberOfParts() - 1).getObject();
+      EventID eventId =
+          (EventID) clientMessage.getPart(clientMessage.getNumberOfParts() - 1).getObject();
-      boolean withInterest = ((Boolean) isInterestListPassedPart.getObject()).booleanValue();
-      boolean withCQs = ((Boolean) hasCqsPart.getObject()).booleanValue();
+      boolean withInterest = (Boolean) isInterestListPassedPart.getObject();
+      boolean withCQs = (Boolean) hasCqsPart.getObject();
-      boolean isCreate = (m.getMessageType() == MessageType.LOCAL_CREATE);
+      boolean isCreate = clientMessage.getMessageType() == MessageType.LOCAL_CREATE;
+
-        logger
-            .debug(
-                "Putting entry for region: {} key: {} create: {}{} callbackArgument: {} withInterest={} withCQs={} eventID={} version={}",
-                regionName, key, isCreate,
-                (valuePart.isObject() ? new StringBuilder(" value: ")
-                    .append(deserialize(valuePart.getSerializedForm())) : ""),
-                callbackArgument, withInterest, withCQs, eventId, versionTag);
+        logger.debug(
+            "Putting entry for region: {} key: {} create: {}{} callbackArgument: {} withInterest={} withCQs={} eventID={} version={}",
+            regionName, key, isCreate,
+            valuePart.isObject()
+                ? new StringBuilder(" value: ").append(deserialize(valuePart.getSerializedForm()))
+                : "",
+            callbackArgument, withInterest, withCQs, eventId, versionTag);
-      LocalRegion region = (LocalRegion) cacheHelper.getRegion(regionName);
+      LocalRegion region = (LocalRegion) this.cacheHelper.getRegion(regionName);
+
+      Object newValue = null;
+      byte[] deltaBytes = null;
+      Object fullValue = null;
+      boolean isValueObject;
+
+
+
+
-          .checkForValidStateAfterNotification(region, key, m.getMessageType())
+          .checkForValidStateAfterNotification(region, key, clientMessage.getMessageType())
+
-              ((m.getMessageType() == MessageType.LOCAL_CREATE) ? Operation.CREATE
-                  : Operation.UPDATE),
+              clientMessage.getMessageType() == MessageType.LOCAL_CREATE ? Operation.CREATE
+                  : Operation.UPDATE,
+
+
-              isValueObject, callbackArgument, m.getMessageType() == MessageType.LOCAL_CREATE,
-              qManager.getState().getProcessedMarker() || !this.isDurableClient, newEvent, eventId);
+              isValueObject, callbackArgument,
+              clientMessage.getMessageType() == MessageType.LOCAL_CREATE,
+              this.qManager.getState().getProcessedMarker() || !this.isDurableClient, newEvent,
+              eventId);
+
+
-          // if (newEvent.isConcurrencyConflict()) {
-          // return; // this is logged elsewhere at fine level
-          // }
-        } catch (InvalidDeltaException ide) {
+        } catch (InvalidDeltaException ignore) {
-          fullValue = newValue = fullValuePart.getObject();
-          isValueObject = Boolean.valueOf(fullValuePart.isObject());
+          fullValue = newValue = fullValuePart.getObject(); // TODO: fix this line
+          isValueObject = fullValuePart.isObject();
+
-              isValueObject, callbackArgument, m.getMessageType() == MessageType.LOCAL_CREATE,
-              qManager.getState().getProcessedMarker() || !this.isDurableClient, newEvent, eventId);
+              isValueObject, callbackArgument,
+              clientMessage.getMessageType() == MessageType.LOCAL_CREATE,
+              this.qManager.getState().getProcessedMarker() || !this.isDurableClient, newEvent,
+              eventId);
+
-        Part numCqsPart = m.getPart(partCnt++);
+        Part numCqsPart = clientMessage.getPart(partCnt++);
-        partCnt = processCqs(m, partCnt, numCqsPart.getInt(), m.getMessageType(), key, fullValue,
-            deltaBytes, eventId);
+        partCnt = processCqs(clientMessage, partCnt, numCqsPart.getInt(),
+            clientMessage.getMessageType(), key, fullValue, deltaBytes, eventId);
-              .toLocalizedString(
-                  new Object[] {regionName, key, deserialize(valuePart.getSerializedForm())});
+              .toLocalizedString(regionName, key, deserialize(valuePart.getSerializedForm()));
-    Part result = (Part) GetEventValueOp.executeOnPrimary(qManager.getPool(), eventId, null);
+    Part result = (Part) GetEventValueOp.executeOnPrimary(this.qManager.getPool(), eventId, null);
+      // TODO: throw a subclass of Exception
+
-   * @param m message describing the entry
+   * @param clientMessage message describing the entry
-  private void handleInvalidate(Message m) {
+  private void handleInvalidate(Message clientMessage) {
-    int partCnt = 0;
-
+
+
-        logger.debug("Received invalidate message of length ({} bytes)", m.getPayloadLength());
+        logger.debug("Received invalidate message of length ({} bytes)",
+            clientMessage.getPayloadLength());
-      Part regionNamePart = m.getPart(partCnt++);
-      Part keyPart = m.getPart(partCnt++);
-      Part callbackArgumentPart = m.getPart(partCnt++);
+      int partCnt = 0;
+      Part regionNamePart = clientMessage.getPart(partCnt++);
+      Part keyPart = clientMessage.getPart(partCnt++);
+      Part callbackArgumentPart = clientMessage.getPart(partCnt++);
-      VersionTag versionTag = (VersionTag) m.getPart(partCnt++).getObject();
+      VersionTag versionTag = (VersionTag) clientMessage.getPart(partCnt++).getObject();
-      Part isInterestListPassedPart = m.getPart(partCnt++);
-      Part hasCqsPart = m.getPart(partCnt++);
+      Part isInterestListPassedPart = clientMessage.getPart(partCnt++);
+      Part hasCqsPart = clientMessage.getPart(partCnt++);
-      boolean withInterest = ((Boolean) isInterestListPassedPart.getObject()).booleanValue();
-      boolean withCQs = ((Boolean) hasCqsPart.getObject()).booleanValue();
+      boolean withInterest = (Boolean) isInterestListPassedPart.getObject();
+      boolean withCQs = (Boolean) hasCqsPart.getObject();
-      LocalRegion region = (LocalRegion) cacheHelper.getRegion(regionName);
+      LocalRegion region = (LocalRegion) this.cacheHelper.getRegion(regionName);
+
-            Part eid = m.getPart(m.getNumberOfParts() - 1);
+            Part eid = clientMessage.getPart(clientMessage.getNumberOfParts() - 1);
+
-                  qManager.getState().getProcessedMarker() || !this.isDurableClient, eventId,
+                  this.qManager.getState().getProcessedMarker() || !this.isDurableClient, eventId,
-            } catch (ConcurrentCacheModificationException e) {
-              // return; allow CQs to be processed
+            } catch (ConcurrentCacheModificationException ignore) {
+              // allow CQs to be processed
+
-            qManager.getState().incrementInvalidatedStats();
+            this.qManager.getState().incrementInvalidatedStats();
-          } catch (EntryNotFoundException e) {
-            /* ignore */
+          } catch (EntryNotFoundException ignore) {
-        Part regionOpType = m.getPart(partCnt++);
-        Part numCqsPart = m.getPart(partCnt++);
+        Part regionOpType = clientMessage.getPart(partCnt++);
+        Part numCqsPart = clientMessage.getPart(partCnt++);
-        partCnt = processCqs(m, partCnt, numCqsPart.getInt(), regionOpType.getInt(), key, null);
+        partCnt = processCqs(clientMessage, partCnt, numCqsPart.getInt(), regionOpType.getInt(),
+            key, null);
-              .toLocalizedString(new Object[] {regionName, key});
+              .toLocalizedString(regionName, key);
-   * @param m message describing the entry
+   * @param clientMessage message describing the entry
-  private void handleDestroy(Message m) {
+  private void handleDestroy(Message clientMessage) {
-    int partCnt = 0;
-
+
-        logger.debug("Received destroy message of length ({} bytes)", m.getPayloadLength());
+        logger.debug("Received destroy message of length ({} bytes)",
+            clientMessage.getPayloadLength());
-      Part regionNamePart = m.getPart(partCnt++);
-      Part keyPart = m.getPart(partCnt++);
-      Part callbackArgumentPart = m.getPart(partCnt++);
+      int partCnt = 0;
+      Part regionNamePart = clientMessage.getPart(partCnt++);
+      Part keyPart = clientMessage.getPart(partCnt++);
+      Part callbackArgumentPart = clientMessage.getPart(partCnt++);
-      VersionTag versionTag = (VersionTag) m.getPart(partCnt++).getObject();
+      VersionTag versionTag = (VersionTag) clientMessage.getPart(partCnt++).getObject();
-      Part isInterestListPassedPart = m.getPart(partCnt++);
-      Part hasCqsPart = m.getPart(partCnt++);
+      Part isInterestListPassedPart = clientMessage.getPart(partCnt++);
+      Part hasCqsPart = clientMessage.getPart(partCnt++);
-      LocalRegion region = (LocalRegion) cacheHelper.getRegion(regionName);
-      EventID eventId = null;
+      LocalRegion region = (LocalRegion) this.cacheHelper.getRegion(regionName);
+
+        EventID eventId = null;
-          Part eid = m.getPart(m.getNumberOfParts() - 1);
+          Part eid = clientMessage.getPart(clientMessage.getNumberOfParts() - 1);
+
-                qManager.getState().getProcessedMarker() || !this.isDurableClient, eventId,
+                this.qManager.getState().getProcessedMarker() || !this.isDurableClient, eventId,
-          } catch (ConcurrentCacheModificationException e) {
-            // return; allow CQs to be processed
+          } catch (ConcurrentCacheModificationException ignore) {
+            // allow CQs to be processed
+
-        } catch (EntryNotFoundException e) {
-          /* ignore */
+        } catch (EntryNotFoundException ignore) {
-        Part numCqsPart = m.getPart(partCnt++);
+        Part numCqsPart = clientMessage.getPart(partCnt++);
-        partCnt = processCqs(m, partCnt, numCqsPart.getInt(), m.getMessageType(), key, null);
+        partCnt = processCqs(clientMessage, partCnt, numCqsPart.getInt(),
+            clientMessage.getMessageType(), key, null);
-              .toLocalizedString(new Object[] {regionName, key});
+              .toLocalizedString(regionName, key);
-   * @param m message describing the region
+   * @param clientMessage message describing the region
-  private void handleDestroyRegion(Message m) {
-    Part regionNamePart = null, callbackArgumentPart = null;
+  private void handleDestroyRegion(Message clientMessage) {
-    Object callbackArgument = null;
-    LocalRegion region = null;
-    int partCnt = 0;
-
+
-        logger.debug("Received destroy region message of length ({} bytes)", m.getPayloadLength());
+        logger.debug("Received destroy region message of length ({} bytes)",
+            clientMessage.getPayloadLength());
-      regionNamePart = m.getPart(partCnt++);
-      callbackArgumentPart = m.getPart(partCnt++);
+      int partCnt = 0;
+      Part regionNamePart = clientMessage.getPart(partCnt++);
+      Part callbackArgumentPart = clientMessage.getPart(partCnt++);
-      callbackArgument = callbackArgumentPart.getObject();
+      Object callbackArgument = callbackArgumentPart.getObject();
-      Part hasCqsPart = m.getPart(partCnt++);
+      Part hasCqsPart = clientMessage.getPart(partCnt++);
-      if (((Boolean) hasCqsPart.getObject()).booleanValue()) {
-        Part numCqsPart = m.getPart(partCnt++);
+      if ((Boolean) hasCqsPart.getObject()) {
+        Part numCqsPart = clientMessage.getPart(partCnt++);
-        partCnt = processCqs(m, partCnt, numCqsPart.getInt(), m.getMessageType(), null, null);
+        // TODO: partCnt is unused -- does processCqs have side effects
+        partCnt = processCqs(clientMessage, partCnt, numCqsPart.getInt(),
+            clientMessage.getMessageType(), null, null);
-      region = (LocalRegion) cacheHelper.getRegion(regionName);
+      LocalRegion region = (LocalRegion) this.cacheHelper.getRegion(regionName);
-    } catch (RegionDestroyedException e) { // already destroyed
+    } catch (RegionDestroyedException ignore) { // already destroyed
-   * @param m message describing the region to clear
+   * @param clientMessage message describing the region to clear
-  private void handleClearRegion(Message m) {
+  private void handleClearRegion(Message clientMessage) {
-    int partCnt = 0;
-
+
-            m.getPayloadLength());
+            clientMessage.getPayloadLength());
-      Part regionNamePart = m.getPart(partCnt++);
-      Part callbackArgumentPart = m.getPart(partCnt++);
+      int partCnt = 0;
+      Part regionNamePart = clientMessage.getPart(partCnt++);
+      Part callbackArgumentPart = clientMessage.getPart(partCnt++);
-      Part hasCqsPart = m.getPart(partCnt++);
+      Part hasCqsPart = clientMessage.getPart(partCnt++);
-      if (((Boolean) hasCqsPart.getObject()).booleanValue()) {
-        Part numCqsPart = m.getPart(partCnt++);
+      if ((Boolean) hasCqsPart.getObject()) {
+        Part numCqsPart = clientMessage.getPart(partCnt++);
-        partCnt = processCqs(m, partCnt, numCqsPart.getInt(), m.getMessageType(), null, null);
+        partCnt = processCqs(clientMessage, partCnt, numCqsPart.getInt(),
+            clientMessage.getMessageType(), null, null);
-      LocalRegion region = (LocalRegion) cacheHelper.getRegion(regionName);
+      LocalRegion region = (LocalRegion) this.cacheHelper.getRegion(regionName);
-            qManager.getState().getProcessedMarker() || !this.isDurableClient);
+            this.qManager.getState().getProcessedMarker() || !this.isDurableClient);
-   * @param m message describing the region to clear
+   * @param clientMessage message describing the region to clear
-  private void handleInvalidateRegion(Message m) {
+  private void handleInvalidateRegion(Message clientMessage) {
-    int partCnt = 0;
-
+
-            m.getPayloadLength());
+            clientMessage.getPayloadLength());
-      Part regionNamePart = m.getPart(partCnt++);
+      int partCnt = 0;
+      Part regionNamePart = clientMessage.getPart(partCnt++);
-      Part hasCqsPart = m.getPart(partCnt++);
+      Part hasCqsPart = clientMessage.getPart(partCnt++);
-      // Object callbackArgument = callbackArgumentPart.getObject();
-      if (((Boolean) hasCqsPart.getObject()).booleanValue()) {
-        Part numCqsPart = m.getPart(partCnt++);
+      if ((Boolean) hasCqsPart.getObject()) {
+        Part numCqsPart = clientMessage.getPart(partCnt++);
-        partCnt = processCqs(m, partCnt, numCqsPart.getInt(), m.getMessageType(), null, null);
+        // TODO: partCnt is unused
+        partCnt = processCqs(clientMessage, partCnt, numCqsPart.getInt(),
+            clientMessage.getMessageType(), null, null);
-      LocalRegion region = (LocalRegion) cacheHelper.getRegion(regionName);
+      LocalRegion region = (LocalRegion) this.cacheHelper.getRegion(regionName);
-        return;
-      }
-
-      // Verify that the region in question should respond to this
-      // message
-      if (region.hasServerProxy()) {
-        return;
-   * @param msg message describing the new instantiators
+   * @param clientMessage message describing the new instantiators
-  private void handleRegisterInstantiator(Message msg, EventID eventId) {
+  private void handleRegisterInstantiator(Message clientMessage, EventID eventId) {
+
-      int noOfParts = msg.getNumberOfParts();
+      int noOfParts = clientMessage.getNumberOfParts();
+
-      for (int i = 0; i < noOfParts - 1; i = i + 3) {
+      for (int i = 0; i < noOfParts - 1; i += 3) {
-            (String) CacheServerHelper.deserialize(msg.getPart(i).getSerializedForm());
-        String instantiatedClassName =
-            (String) CacheServerHelper.deserialize(msg.getPart(i + 1).getSerializedForm());
-        int id = msg.getPart(i + 2).getInt();
+            (String) CacheServerHelper.deserialize(clientMessage.getPart(i).getSerializedForm());
+        String instantiatedClassName = (String) CacheServerHelper
+            .deserialize(clientMessage.getPart(i + 1).getSerializedForm());
+        int id = clientMessage.getPart(i + 2).getInt();
-            eventId, null/* context */);
-        // distribute is false because we don't want to propagate this to
-        // servers recursively
+            eventId, null);
+        // distribute is false because we don't want to propagate this to servers recursively
-        ClientServerObserver bo = ClientServerObserverHolder.getInstance();
-        bo.afterReceivingFromServer(eventId);
+        ClientServerObserver clientServerObserver = ClientServerObserverHolder.getInstance();
+        clientServerObserver.afterReceivingFromServer(eventId);
-    }
-    // TODO bug: can the following catch be more specific?
-    catch (Exception e) {
+    } catch (Exception e) {
+
-          // distribute is false because we don't want to propagate this to
-          // servers recursively
+          // distribute is false because we don't want to propagate this to servers recursively
-          i = i + 3 + j;
+
+          i += 3 + j;
-    }
-    // TODO bug: can the following catch be more specific?
-    catch (Exception e) {
+    } catch (Exception e) {
-  private int processCqs(Message m, int startMessagePart, int numCqParts, int messageType,
-      Object key, Object value) {
-    return processCqs(m, startMessagePart, numCqParts, messageType, key, value, null,
-        null/* eventId */);
+  private int processCqs(Message clientMessage, int startMessagePart, int numCqParts,
+      int messageType, Object key, Object value) {
+    return processCqs(clientMessage, startMessagePart, numCqParts, messageType, key, value, null,
+        null);
-  private int processCqs(Message m, int startMessagePart, int numCqParts, int messageType,
-      Object key, Object value, byte[] delta, EventID eventId) {
+  private int processCqs(Message clientMessage, int startMessagePart, int numCqParts,
+      int messageType, Object key, Object value, byte[] delta, EventID eventId) {
-      StringBuilder str = null;
+      StringBuilder sb = null;
-        str = new StringBuilder(100);
-        str.append("found these queries: ");
+        sb = new StringBuilder(100);
+        sb.append("found these queries: ");
-        Part cqNamePart = m.getPart(startMessagePart + (cqCnt++));
+        Part cqNamePart = clientMessage.getPart(startMessagePart + cqCnt++);
-        Part cqOpPart = m.getPart(startMessagePart + (cqCnt++));
-        cqs.put(cqNamePart.getString(), Integer.valueOf(cqOpPart.getInt()));
+        Part cqOpPart = clientMessage.getPart(startMessagePart + cqCnt++);
+        cqs.put(cqNamePart.getString(), cqOpPart.getInt());
-        if (str != null) {
-          str.append(cqNamePart.getString()).append(" op=").append(cqOpPart.getInt()).append("  ");
+        if (sb != null) {
+          sb.append(cqNamePart.getString()).append(" op=").append(cqOpPart.getInt()).append("  ");
-      } catch (Exception ex) {
+      } catch (Exception ignore) {
-      if (isDebugEnabled && str != null) {
-        logger.debug(str);
+      if (isDebugEnabled) {
+        logger.debug(sb);
-    {
-      CqService cqService = this.cache.getCqService();
-      try {
-        cqService.dispatchCqListeners(cqs, messageType, key, value, delta, qManager, eventId);
-      } catch (Exception ex) {
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.CacheClientUpdater_FAILED_TO_INVOKE_CQ_DISPATCHER_ERROR___0,
-            ex.getMessage()));
-        if (isDebugEnabled) {
-          logger.debug("Failed to invoke CQ Dispatcher.", ex);
-        }
+    CqService cqService = this.cache.getCqService();
+    try {
+      cqService.dispatchCqListeners(cqs, messageType, key, value, delta, this.qManager, eventId);
+    } catch (Exception ex) {
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.CacheClientUpdater_FAILED_TO_INVOKE_CQ_DISPATCHER_ERROR___0,
+          ex.getMessage()));
+      if (isDebugEnabled) {
+        logger.debug("Failed to invoke CQ Dispatcher.", ex);
-    return (startMessagePart + numCqParts);
+    return startMessagePart + numCqParts;
-  private void handleRegisterInterest(Message m) {
+  private void handleRegisterInterest(Message clientMessage) {
-    int interestType;
-    byte interestResultPolicy;
-    boolean isDurable;
-    boolean receiveUpdatesAsInvalidates;
-    int partCnt = 0;
-
+
-            m.getPayloadLength());
+            clientMessage.getPayloadLength());
-      Part regionNamePart = m.getPart(partCnt++);
-      Part keyPart = m.getPart(partCnt++);
-      Part interestTypePart = m.getPart(partCnt++);
-      Part interestResultPolicyPart = m.getPart(partCnt++);
-      Part isDurablePart = m.getPart(partCnt++);
-      Part receiveUpdatesAsInvalidatesPart = m.getPart(partCnt++);
+
+      int partCnt = 0;
+      Part regionNamePart = clientMessage.getPart(partCnt++);
+      Part keyPart = clientMessage.getPart(partCnt++);
+      Part interestTypePart = clientMessage.getPart(partCnt++);
+      Part interestResultPolicyPart = clientMessage.getPart(partCnt++);
+      Part isDurablePart = clientMessage.getPart(partCnt++);
+      Part receiveUpdatesAsInvalidatesPart = clientMessage.getPart(partCnt++);
-      interestType = ((Integer) interestTypePart.getObject()).intValue();
-      interestResultPolicy = ((Byte) interestResultPolicyPart.getObject()).byteValue();
-      isDurable = ((Boolean) isDurablePart.getObject()).booleanValue();
-      receiveUpdatesAsInvalidates =
-          ((Boolean) receiveUpdatesAsInvalidatesPart.getObject()).booleanValue();
+      int interestType = (Integer) interestTypePart.getObject();
+      byte interestResultPolicy = (Byte) interestResultPolicyPart.getObject();
+      boolean isDurable = (Boolean) isDurablePart.getObject();
+      boolean receiveUpdatesAsInvalidates = (Boolean) receiveUpdatesAsInvalidatesPart.getObject();
-      LocalRegion region = (LocalRegion) cacheHelper.getRegion(regionName);
+      LocalRegion region = (LocalRegion) this.cacheHelper.getRegion(regionName);
-  private void handleUnregisterInterest(Message m) {
+  private void handleUnregisterInterest(Message clientMessage) {
-    int interestType;
-    boolean isDurable;
-    boolean receiveUpdatesAsInvalidates;
-    int partCnt = 0;
-
+
-            m.getPayloadLength());
+            clientMessage.getPayloadLength());
-      Part regionNamePart = m.getPart(partCnt++);
-      Part keyPart = m.getPart(partCnt++);
-      Part interestTypePart = m.getPart(partCnt++);
-      Part isDurablePart = m.getPart(partCnt++);
-      Part receiveUpdatesAsInvalidatesPart = m.getPart(partCnt++);
+      int partCnt = 0;
+      Part regionNamePart = clientMessage.getPart(partCnt++);
+      Part keyPart = clientMessage.getPart(partCnt++);
+      Part interestTypePart = clientMessage.getPart(partCnt++);
+      Part isDurablePart = clientMessage.getPart(partCnt++);
+      Part receiveUpdatesAsInvalidatesPart = clientMessage.getPart(partCnt++);
-      interestType = ((Integer) interestTypePart.getObject()).intValue();
-      isDurable = ((Boolean) isDurablePart.getObject()).booleanValue();
-      receiveUpdatesAsInvalidates =
-          ((Boolean) receiveUpdatesAsInvalidatesPart.getObject()).booleanValue();
+      int interestType = (Integer) interestTypePart.getObject();
+      boolean isDurable = (Boolean) isDurablePart.getObject();
+      boolean receiveUpdatesAsInvalidates = (Boolean) receiveUpdatesAsInvalidatesPart.getObject();
-      LocalRegion region = (LocalRegion) cacheHelper.getRegion(regionName);
+      LocalRegion region = (LocalRegion) this.cacheHelper.getRegion(regionName);
-  private void handleTombstoneOperation(Message msg) {
+  private void handleTombstoneOperation(Message clientMessage) {
+
+
-      regionName = msg.getPart(partIdx++).getString();
-      int op = msg.getPart(partIdx++).getInt();
-      LocalRegion region = (LocalRegion) cacheHelper.getRegion(regionName);
+      regionName = clientMessage.getPart(partIdx++).getString();
+      int op = clientMessage.getPart(partIdx++).getInt();
+      LocalRegion region = (LocalRegion) this.cacheHelper.getRegion(regionName);
+
+
+
+
-              (Map<VersionSource, Long>) msg.getPart(partIdx++).getObject();
-          EventID eventID = (EventID) msg.getPart(partIdx++).getObject();
+              (Map<VersionSource, Long>) clientMessage.getPart(partIdx++).getObject();
+          EventID eventID = (EventID) clientMessage.getPart(partIdx++).getObject();
+
-          Set<Object> removedKeys = (Set<Object>) msg.getPart(partIdx++).getObject();
+          Set<Object> removedKeys = (Set<Object>) clientMessage.getPart(partIdx++).getObject();
+
-      // Any time an interrupt is thrown at this thread, regard it as a
-      // request to terminate
+      // Any time an interrupt is thrown at this thread, regard it as a request to terminate
-    if (!continueProcessing.get()) {
+    if (!this.continueProcessing.get()) {
-    if (cache != null && cache.getCancelCriterion().isCancelInProgress()) {
+    if (this.cache != null && this.cache.getCancelCriterion().isCancelInProgress()) {
-    if (system.getCancelCriterion().isCancelInProgress()) {
+    if (this.system.getCancelCriterion().isCancelInProgress()) {
-    } catch (InterruptedException ie) {
+    } catch (InterruptedException ignore) {
-      return; // just bail, because I have not done anything yet
+      // just bail, because I have not done anything yet
-        failedUpdater = null;
+        this.failedUpdater = null;
+   *
+   * TODO: Method 'processMessages' is too complex to analyze by data flow algorithm
-  protected void processMessages() {
+  private void processMessages() {
-      Part eid = null;
-      Message _message = initializeMessage();
+      Message clientMessage = initializeMessage();
+
+
-      while (continueProcessing.get()) {
-        // SystemFailure.checkFailure(); dm will check this
+      while (this.continueProcessing.get()) {
-          _message.recv();
+          clientMessage.recv();
-          cache.waitForRegisterInterestsInProgress();
+          this.cache.waitForRegisterInterestsInProgress();
-          if (_message.getMessageType() == MessageType.SERVER_TO_CLIENT_PING) {
+          if (clientMessage.getMessageType() == MessageType.SERVER_TO_CLIENT_PING) {
-          boolean isCreateOrUpdate = _message.getMessageType() == MessageType.LOCAL_CREATE
-              || _message.getMessageType() == MessageType.LOCAL_UPDATE;
+          boolean isCreateOrUpdate = clientMessage.getMessageType() == MessageType.LOCAL_CREATE
+              || clientMessage.getMessageType() == MessageType.LOCAL_UPDATE;
-            isDeltaSent = ((Boolean) _message.getPart(2).getObject()).booleanValue();
+            isDeltaSent = (Boolean) clientMessage.getPart(2).getObject();
-          int numberOfParts = _message.getNumberOfParts();
-          eid = _message.getPart(numberOfParts - 1);
+          int numberOfParts = clientMessage.getNumberOfParts();
+          Part eid = clientMessage.getPart(numberOfParts - 1);
+
-          if (_message.getMessageType() != MessageType.REGISTER_INSTANTIATORS
-              && _message.getMessageType() != MessageType.REGISTER_DATASERIALIZERS) {
+          if (clientMessage.getMessageType() != MessageType.REGISTER_INSTANTIATORS
+              && clientMessage.getMessageType() != MessageType.REGISTER_DATASERIALIZERS) {
+
-            logger.trace(LogMarker.BRIDGE_SERVER,
-                "Processing event with id {}" + eventId.expensiveToString());
+            logger.trace(LogMarker.BRIDGE_SERVER, "Processing event with id {}",
+                eventId.expensiveToString());
+
+
-          switch (_message.getMessageType()) {
+          switch (clientMessage.getMessageType()) {
-              handleUpdate(_message);
+              handleUpdate(clientMessage);
-              handleInvalidate(_message);
+              handleInvalidate(clientMessage);
-              handleDestroy(_message);
+              handleDestroy(clientMessage);
-              handleDestroyRegion(_message);
+              handleDestroyRegion(clientMessage);
-              handleClearRegion(_message);
+              handleClearRegion(clientMessage);
-              handleRegisterInstantiator(_message, eventId);
+              handleRegisterInstantiator(clientMessage, eventId);
-              handleRegisterDataSerializer(_message, eventId);
+              handleRegisterDataSerializer(clientMessage, eventId);
-              handleMarker(_message);
+              handleMarker(clientMessage);
-              handleInvalidateRegion(_message);
+              handleInvalidateRegion(clientMessage);
-              handleRegisterInterest(_message);
+              handleRegisterInterest(clientMessage);
-              handleUnregisterInterest(_message);
+              handleUnregisterInterest(clientMessage);
-              handleTombstoneOperation(_message);
+              handleTombstoneOperation(clientMessage);
-                  new Object[] {this, MessageType.getString(_message.getMessageType())}));
+                  new Object[] {this, MessageType.getString(clientMessage.getMessageType())}));
-        } catch (InterruptedIOException e) {
+        } catch (InterruptedIOException ignore) {
-          this.endPointDied = true;
-          continueProcessing.set(false);// = false;
+          this.continueProcessing.set(false);
+
-          this.endPointDied = true;
-            String message = ": Caught the following exception and will exit: ";
-            String errMessage = e.getMessage();
-            if (errMessage == null) {
-              errMessage = "";
-            }
-            ClientServerObserver bo = ClientServerObserverHolder.getInstance();
-            bo.beforeFailoverByCacheClientUpdater(this.location);
-            eManager.serverCrashed(this.endpoint);
+            ClientServerObserver clientServerObserver = ClientServerObserverHolder.getInstance();
+            clientServerObserver.beforeFailoverByCacheClientUpdater(this.location);
+            this.eManager.serverCrashed(this.endpoint);
-              logger.debug("" + message + e);
+              logger.debug("Caught the following exception and will exit", e);
-          continueProcessing.set(false);// = false;
+          this.continueProcessing.set(false);
+
-            this.endPointDied = true;
-            ClientServerObserver bo = ClientServerObserverHolder.getInstance();
-            bo.beforeFailoverByCacheClientUpdater(this.location);
-            eManager.serverCrashed(this.endpoint);
+            ClientServerObserver clientServerObserver = ClientServerObserverHolder.getInstance();
+            clientServerObserver.beforeFailoverByCacheClientUpdater(this.location);
+            this.eManager.serverCrashed(this.endpoint);
+
-          continueProcessing.set(false);// = false; // force termination
+          this.continueProcessing.set(false);// = false; // force termination
+
-          _message.clear();
+          clientMessage.clear();
+
-      this.close(); // added to fixes some race conditions associated with 38382
+      close(); // added to fix some race conditions associated with 38382
-      // 2. if there is some other race codition with continueProcessing flag
-      this.qManager.checkEndpoint(this, endpoint);
+      // 2. if there is some other race condition with continueProcessing flag
+      this.qManager.checkEndpoint(this, this.endpoint);
-    // This is a debugging method so ignore all exceptions like
-    // ClassNotFoundException
+    // This is a debugging method so ignore all exceptions like ClassNotFoundException
-    } catch (Exception e) {
+    } catch (ClassNotFoundException | IOException ignore) {
-    return socket.getLocalPort();
+    return this.socket.getLocalPort();
+  @Override
-  /**
-   * true if the EndPoint represented by this updater thread has died.
-   */
-  private volatile boolean endPointDied = false;
-
-    // static fields
+
-    private final static int messagesBeingReceivedId;
-    private final static int messageBytesBeingReceivedId;
-    private final static int receivedBytesId;
+    private static final int messagesBeingReceivedId;
+    private static final int messageBytesBeingReceivedId;
+    private static final int receivedBytesId;
-    public CCUStats(DistributedSystem ids, ServerLocation location) {
+    CCUStats(DistributedSystem ids, ServerLocation location) {
+    @Override
+    @Override
+    @Override
-      stats.incInt(messagesBeingReceivedId, 1);
+      this.stats.incInt(messagesBeingReceivedId, 1);
-        stats.incLong(messageBytesBeingReceivedId, bytes);
+        this.stats.incLong(messageBytesBeingReceivedId, bytes);
+    @Override
-      stats.incInt(messagesBeingReceivedId, -1);
+      this.stats.incInt(messagesBeingReceivedId, -1);
-        stats.incLong(messageBytesBeingReceivedId, -bytes);
+        this.stats.incLong(messageBytesBeingReceivedId, -bytes);
+  @Override
-    return continueProcessing.get();
+    return this.continueProcessing.get();

INS23 INS31 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS78 INS78 MOV60 UPD83 UPD83 INS78 INS44 MOV44 UPD83 INS78 INS78 MOV83 MOV39 MOV42 MOV8 INS65 UPD66 UPD66 UPD66 INS42 INS34 MOV32 INS42 INS42 INS42 MOV21 MOV25 MOV21 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 INS42 UPD42 MOV60 MOV54 UPD42 UPD42 UPD42 INS42 INS83 INS83 INS83 INS78 INS78 INS78 INS78 INS42 UPD66 MOV66 UPD66 UPD66 UPD66 INS66 INS65 UPD66 UPD66 UPD66 INS22 INS22 UPD66 INS65 INS66 UPD66 UPD42 UPD42 UPD42 MOV60 MOV60 MOV60 MOV60 MOV43 UPD42 MOV60 MOV60 UPD42 MOV60 MOV60 MOV60 UPD42 UPD42 MOV60 UPD42 UPD42 MOV27 MOV60 MOV60 MOV60 MOV60 MOV60 MOV60 MOV60 MOV60 MOV60 MOV8 MOV8 INS66 INS42 INS42 INS42 INS42 INS66 MOV60 MOV54 MOV21 MOV60 MOV21 INS52 INS42 INS52 INS42 INS66 INS22 INS22 INS22 UPD42 UPD42 INS22 INS22 INS22 INS22 INS13 INS13 MOV60 INS60 MOV60 MOV60 MOV60 INS60 MOV60 MOV60 MOV60 MOV60 INS60 INS60 INS60 INS60 MOV60 MOV60 MOV60 MOV60 UPD42 MOV60 INS60 INS60 INS60 INS60 MOV60 INS60 INS60 INS60 INS60 MOV60 INS22 INS22 UPD42 INS22 INS52 INS42 UPD42 INS52 INS42 UPD43 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 MOV43 INS39 MOV43 MOV43 INS59 MOV43 MOV43 MOV43 INS39 INS59 MOV43 MOV43 MOV43 MOV43 MOV43 MOV60 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 INS43 INS59 INS43 INS59 MOV43 INS59 MOV11 MOV43 INS59 UPD42 MOV11 MOV43 MOV11 MOV43 UPD7 MOV60 INS42 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 MOV43 INS39 INS59 INS39 INS59 INS39 INS59 MOV43 MOV59 INS39 MOV43 MOV60 INS22 INS22 INS22 UPD42 INS84 UPD42 INS52 INS42 INS22 INS22 INS52 INS42 INS22 INS52 INS42 INS22 UPD42 INS22 UPD42 UPD42 INS42 INS11 MOV32 UPD42 MOV32 INS42 INS11 INS42 MOV32 UPD42 INS11 INS11 INS27 INS42 UPD42 UPD42 UPD42 INS42 INS11 UPD42 MOV42 INS42 MOV32 UPD42 INS11 INS11 UPD42 UPD42 UPD42 INS42 INS11 UPD42 MOV42 INS42 MOV32 UPD42 UPD42 INS42 INS42 MOV32 INS42 INS42 INS32 INS42 MOV32 MOV60 INS42 INS11 UPD42 UPD42 MOV60 UPD42 MOV60 INS34 UPD42 MOV21 INS22 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 MOV11 INS42 MOV11 INS42 MOV11 INS42 MOV11 UPD42 UPD42 UPD42 UPD42 INS42 MOV11 INS42 MOV11 INS42 MOV11 MOV32 UPD42 MOV32 MOV74 INS59 MOV43 MOV74 MOV59 INS52 INS42 INS52 INS42 INS22 INS52 INS42 UPD42 INS22 MOV12 INS22 INS43 INS43 INS52 INS42 INS52 INS42 UPD42 MOV42 MOV42 MOV45 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 UPD42 UPD42 MOV43 INS32 UPD42 UPD42 MOV43 INS32 UPD42 UPD42 MOV43 MOV43 MOV32 MOV43 MOV32 MOV32 MOV40 MOV43 INS22 UPD42 UPD42 UPD42 INS43 INS32 UPD42 UPD42 MOV43 MOV32 MOV43 MOV32 MOV43 UPD42 UPD42 UPD42 INS43 INS32 UPD42 UPD42 MOV43 MOV60 UPD42 UPD42 MOV42 MOV42 UPD42 MOV43 MOV32 UPD42 UPD42 UPD42 MOV43 UPD42 UPD42 MOV43 UPD42 MOV32 UPD42 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 UPD42 UPD42 MOV43 INS42 INS11 UPD42 INS11 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 UPD42 MOV42 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 MOV32 INS42 MOV32 INS42 UPD42 MOV16 INS22 INS42 INS42 MOV32 INS52 INS42 INS42 MOV32 INS42 INS22 UPD42 UPD42 INS42 INS42 INS42 MOV32 INS42 INS22 INS42 INS42 UPD42 INS22 UPD42 INS22 UPD42 INS22 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 MOV32 UPD42 MOV21 UPD42 INS22 INS22 UPD42 UPD42 INS22 MOV74 MOV32 MOV43 MOV32 MOV74 INS22 INS60 MOV44 MOV44 MOV21 INS52 INS42 INS52 INS42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 UPD43 MOV42 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS52 INS42 UPD42 UPD42 UPD42 INS52 INS42 UPD42 UPD42 UPD42 INS52 INS42 UPD7 UPD42 UPD42 UPD42 MOV42 INS32 UPD42 INS52 INS42 UPD42 INS52 INS42 INS52 INS42 UPD42 UPD42 INS52 INS42 MOV43 INS59 UPD42 MOV25 MOV25 INS22 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV37 MOV37 MOV32 INS42 INS45 UPD42 UPD42 UPD42 UPD42 INS22 INS42 MOV32 UPD42 MOV60 INS32 UPD42 INS52 INS42 UPD42 UPD42 INS22 INS32 UPD42 MOV42 MOV32 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS22 INS25 INS22 MOV21 INS22 INS42 INS9 MOV21 INS22 INS16 MOV32 UPD42 UPD42 INS52 INS42 UPD42 UPD42 INS32 UPD42 MOV42 INS45 INS11 UPD42 UPD42 INS45 MOV32 INS52 INS42 INS42 INS8 INS52 INS42 MOV43 MOV52 UPD42 MOV42 MOV32 INS52 INS42 UPD42 INS27 MOV40 MOV40 UPD42 UPD42 UPD42 INS22 UPD42 MOV42 UPD42 MOV42 MOV32 UPD42 UPD42 MOV43 MOV32 UPD42 UPD42 INS22 MOV21 UPD42 UPD42 INS22 UPD42 INS42 INS42 UPD42 MOV42 UPD42 MOV32 MOV40 INS22 UPD42 INS52 INS42 UPD42 INS52 INS42 INS52 INS42 UPD42 INS52 INS42 INS22 UPD42 UPD42 UPD42 UPD42 INS45 INS52 INS42 INS22 UPD42 INS22 INS52 INS42 INS52 INS42 DEL83 DEL83 DEL83 DEL42 DEL32 DEL34 DEL32 DEL8 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL41 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL42 DEL8 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL52 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL12 DEL54 DEL52 DEL45 DEL45 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL42 DEL59 DEL60 DEL39 DEL42 DEL32 DEL11 DEL36 DEL42 DEL32 DEL42 DEL42 DEL32 DEL11 DEL11 DEL36 DEL42 DEL32 DEL11 DEL36 DEL42 DEL32 DEL27 DEL36 DEL36 DEL42 DEL27 DEL36 DEL16 DEL36 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL42 DEL42 DEL42 DEL42 DEL32 DEL11 DEL11 DEL36 DEL42 DEL32 DEL11 DEL36 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL42 DEL42 DEL42 DEL32 DEL11 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL42 DEL33 DEL59 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL33 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL42 DEL32 DEL7 DEL21 DEL36 DEL42 DEL32 DEL42 DEL42 DEL11 DEL7 DEL21 DEL36 DEL42 DEL32 DEL42 DEL42 DEL36 DEL42 DEL32 DEL42 DEL41 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL34 DEL27 DEL42 DEL42 DEL44 DEL36 DEL36 DEL42 DEL45 DEL32 DEL42 DEL32 DEL42 DEL45 DEL32 DEL32 DEL42 DEL42 DEL33 DEL27 DEL27 DEL42 DEL8 DEL36 DEL39 DEL42 DEL59 DEL60 DEL39 DEL42 DEL59 DEL60 DEL39 DEL42 DEL59 DEL60 DEL39 DEL42 DEL59 DEL60 DEL42 DEL36 DEL42 DEL32 DEL7 DEL21 DEL42 DEL36 DEL42 DEL32 DEL7 DEL21 DEL42 DEL36 DEL42 DEL32 DEL7 DEL21 DEL42 DEL36 DEL42 DEL32 DEL7 DEL21 DEL42 DEL39 DEL42 DEL59 DEL60 DEL39 DEL42 DEL59 DEL60 DEL39 DEL42 DEL59 DEL60 DEL42 DEL42 DEL36 DEL42 DEL32 DEL7 DEL21 DEL42 DEL36 DEL42 DEL32 DEL7 DEL21 DEL42 DEL36 DEL42 DEL32 DEL7 DEL21 DEL60 DEL11 DEL42 DEL39 DEL42 DEL11 DEL59 DEL42 DEL42 DEL42 DEL42 DEL41 DEL42 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL11 DEL36 DEL42 DEL32 DEL42 DEL7 DEL21 DEL45 DEL27 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL42 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL45 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL45 DEL42 DEL42 DEL27 DEL42 DEL8 DEL25 DEL22 DEL9 DEL7 DEL9 DEL52 DEL42 DEL43 DEL42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL83 DEL83 DEL83 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL31
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Allows for the setting of eviction and critical thresholds. These thresholds
- * are compared against current heap usage and, with the help of {#link
- * InternalResourceManager}, dispatches events when the thresholds are crossed.
- * Gathering memory usage information from the JVM is done using a listener on
- * the MemoryMXBean, by polling the JVM and as a listener on GemFire Statistics
- * output in order to accommodate differences in the various JVMs.
+ * Allows for the setting of eviction and critical thresholds. These thresholds are compared against
+ * current heap usage and, with the help of {#link InternalResourceManager}, dispatches events when
+ * the thresholds are crossed. Gathering memory usage information from the JVM is done using a
+ * listener on the MemoryMXBean, by polling the JVM and as a listener on GemFire Statistics output
+ * in order to accommodate differences in the various JVMs.
-  
+
-  private static final String HEAP_POOL = System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "ResourceManager.HEAP_POOL");
-  
+  private static final String HEAP_POOL =
+      System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "ResourceManager.HEAP_POOL");
+
-  public static final String POLLER_INTERVAL_PROP = DistributionConfig.GEMFIRE_PREFIX + "heapPollerInterval";
-  
-   // Internal for polling the JVM for changes in heap memory usage.
-  private static final int POLLER_INTERVAL = Integer.getInteger(POLLER_INTERVAL_PROP, 500).intValue();
-  
+  public static final String POLLER_INTERVAL_PROP =
+      DistributionConfig.GEMFIRE_PREFIX + "heapPollerInterval";
+
+  // Internal for polling the JVM for changes in heap memory usage.
+  private static final int POLLER_INTERVAL =
+      Integer.getInteger(POLLER_INTERVAL_PROP, 500).intValue();
+
-  
+
-  
+
-   * Number of eviction or critical state changes that have to occur before the
-   * event is delivered. This was introduced because we saw sudden memory usage
-   * spikes in jrockit VM.
+   * Number of eviction or critical state changes that have to occur before the event is delivered.
+   * This was introduced because we saw sudden memory usage spikes in jrockit VM.
-      memoryStateChangeTolerance = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "memoryEventTolerance", 1);
+      memoryStateChangeTolerance =
+          Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "memoryEventTolerance", 1);
-      memoryStateChangeTolerance = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "memoryEventTolerance", 5);
+      memoryStateChangeTolerance =
+          Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "memoryEventTolerance", 5);
-      logger.error(LocalizedMessage.create(LocalizedStrings.HeapMemoryMonitor_NO_POOL_FOUND_POOLS_0, getAllMemoryPoolNames()));
+      logger.error(LocalizedMessage.create(LocalizedStrings.HeapMemoryMonitor_NO_POOL_FOUND_POOLS_0,
+          getAllMemoryPoolNames()));
-   * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7078465 by getting max
-   * memory from runtime and subtracting all other heap pools from it.
+   * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7078465 by getting max memory from runtime
+   * and subtracting all other heap pools from it.
-  private volatile MemoryEvent mostRecentEvent = new MemoryEvent(ResourceType.HEAP_MEMORY, MemoryState.DISABLED,
-      MemoryState.DISABLED, null, 0L, true, this.thresholds);
+  private volatile MemoryEvent mostRecentEvent = new MemoryEvent(ResourceType.HEAP_MEMORY,
+      MemoryState.DISABLED, MemoryState.DISABLED, null, 0L, true, this.thresholds);
-  //Set when startMonitoring() and stopMonitoring() are called
+  // Set when startMonitoring() and stopMonitoring() are called
-  // Only change state when these counters exceed {@link HeapMemoryMonitor#memoryStateChangeTolerance}
+  // Only change state when these counters exceed {@link
+  // HeapMemoryMonitor#memoryStateChangeTolerance}
-
-
- 
-   * Determines if the name of the memory pool MXBean provided matches a list of
-   * known tenured pool names.
+   * Determines if the name of the memory pool MXBean provided matches a list of known tenured pool
+   * names.
-   * @param memoryPoolMXBean
-   *          The memory pool MXBean to check.
-   * @return True if the pool name matches a known tenured pool name, false
-   *         otherwise.
+   * @param memoryPoolMXBean The memory pool MXBean to check.
+   * @return True if the pool name matches a known tenured pool name, false otherwise.
-    
+
-    
-    return name.equals("CMS Old Gen")     // Sun Concurrent Mark Sweep GC
-        || name.equals("PS Old Gen")      // Sun Parallel GC
-        || name.equals("G1 Old Gen")      // Sun G1 GC
-        || name.equals("Old Space")       // BEA JRockit 1.5, 1.6 GC
-        || name.equals("Tenured Gen")     // Hitachi 1.5 GC
-        || name.equals("Java heap")       // IBM 1.5, 1.6 GC
+
+    return name.equals("CMS Old Gen") // Sun Concurrent Mark Sweep GC
+        || name.equals("PS Old Gen") // Sun Parallel GC
+        || name.equals("G1 Old Gen") // Sun G1 GC
+        || name.equals("Old Space") // BEA JRockit 1.5, 1.6 GC
+        || name.equals("Tenured Gen") // Hitachi 1.5 GC
+        || name.equals("Java heap") // IBM 1.5, 1.6 GC
-        
+
-  
-  HeapMemoryMonitor(final InternalResourceManager resourceManager, final GemFireCacheImpl cache, final ResourceManagerStats stats) {
+
+  HeapMemoryMonitor(final InternalResourceManager resourceManager, final GemFireCacheImpl cache,
+      final ResourceManagerStats stats) {
-   * Returns the tenured pool MXBean or throws an IllegaleStateException if one
-   * couldn't be found.
+   * Returns the tenured pool MXBean or throws an IllegaleStateException if one couldn't be found.
-      builder.append("(Name=").append(memoryPoolBean.getName()).append(";Type=").append(memoryPoolBean.getType()).append(
-          ";UsageThresholdSupported=").append(memoryPoolBean.isUsageThresholdSupported()).append("), ");
+      builder.append("(Name=").append(memoryPoolBean.getName()).append(";Type=")
+          .append(memoryPoolBean.getType()).append(";UsageThresholdSupported=")
+          .append(memoryPoolBean.isUsageThresholdSupported()).append("), ");
-    
+
-    
+
- 
+
-   * Monitoring is done using a combination of data from the JVM and statistics
-   * collected from the cache. A usage threshold is set on the MemoryMXBean of
-   * the JVM to get notifications when the JVM crosses the eviction or critical
-   * thresholds. A separate usage collection is done either by setting up a
-   * listener on the cache stats or polling of the JVM, depending on whether
-   * stats have been enabled. This separate collection is done to return the
-   * state of the heap memory back to a normal state when memory has been freed.
+   * Monitoring is done using a combination of data from the JVM and statistics collected from the
+   * cache. A usage threshold is set on the MemoryMXBean of the JVM to get notifications when the
+   * JVM crosses the eviction or critical thresholds. A separate usage collection is done either by
+   * setting up a listener on the cache stats or polling of the JVM, depending on whether stats have
+   * been enabled. This separate collection is done to return the state of the heap memory back to a
+   * normal state when memory has been freed.
-      
+
-  
+
- @Override
-public void stopMonitoring() {
+  @Override
+  public void stopMonitoring() {
-      
+
-        this.cache.getLoggerI18n().fine("This instance '" + toString() + "' was not registered as a Memory MXBean listener");
+        this.cache.getLoggerI18n().fine(
+            "This instance '" + toString() + "' was not registered as a Memory MXBean listener");
-  
+
-    
+
-          if (si.getTextId().contains(tenuredPoolName) && si.getType().getName().contains("PoolStats")) {
+          if (si.getTextId().contains(tenuredPoolName)
+              && si.getType().getName().contains("PoolStats")) {
-    
+
-  
+
-    
+
-    
+
-    this.pollerExecutor.scheduleAtFixedRate(new HeapPoller(), POLLER_INTERVAL, POLLER_INTERVAL, TimeUnit.MILLISECONDS);
-    
+    this.pollerExecutor.scheduleAtFixedRate(new HeapPoller(), POLLER_INTERVAL, POLLER_INTERVAL,
+        TimeUnit.MILLISECONDS);
+
-      this.cache.getLoggerI18n().fine("Started GemfireHeapPoller to poll the heap every " + POLLER_INTERVAL + " milliseconds");
+      this.cache.getLoggerI18n().fine(
+          "Started GemfireHeapPoller to poll the heap every " + POLLER_INTERVAL + " milliseconds");
-  
+
-        throw new IllegalArgumentException(LocalizedStrings.MemoryThresholds_CRITICAL_PERCENTAGE_GT_ZERO_AND_LTE_100
-            .toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.MemoryThresholds_CRITICAL_PERCENTAGE_GT_ZERO_AND_LTE_100
+                .toLocalizedString());
-        throw new IllegalArgumentException(LocalizedStrings.MemoryThresholds_CRITICAL_PERCENTAGE_GTE_EVICTION_PERCENTAGE
-            .toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.MemoryThresholds_CRITICAL_PERCENTAGE_GTE_EVICTION_PERCENTAGE
+                .toLocalizedString());
-       
+
-      this.thresholds = new MemoryThresholds(this.thresholds.getMaxMemoryBytes(), criticalThreshold, this.thresholds
-          .getEvictionThreshold());
+      this.thresholds = new MemoryThresholds(this.thresholds.getMaxMemoryBytes(), criticalThreshold,
+          this.thresholds.getEvictionThreshold());
-      
+
-      if (this.thresholds.isEvictionThresholdEnabled() || this.thresholds.isCriticalThresholdEnabled()) {
+      if (this.thresholds.isEvictionThresholdEnabled()
+          || this.thresholds.isCriticalThresholdEnabled()) {
-      } else if (!this.thresholds.isEvictionThresholdEnabled() && !this.thresholds.isCriticalThresholdEnabled()) {
+      } else if (!this.thresholds.isEvictionThresholdEnabled()
+          && !this.thresholds.isCriticalThresholdEnabled()) {
-  
+
-  
+
-    
+
-        throw new IllegalArgumentException(LocalizedStrings.MemoryThresholds_EVICTION_PERCENTAGE_GT_ZERO_AND_LTE_100
-            .toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.MemoryThresholds_EVICTION_PERCENTAGE_GT_ZERO_AND_LTE_100
+                .toLocalizedString());
-        throw new IllegalArgumentException(LocalizedStrings.MemoryMonitor_EVICTION_PERCENTAGE_LTE_CRITICAL_PERCENTAGE
-            .toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.MemoryMonitor_EVICTION_PERCENTAGE_LTE_CRITICAL_PERCENTAGE
+                .toLocalizedString());
-      this.thresholds = new MemoryThresholds(this.thresholds.getMaxMemoryBytes(), this.thresholds.getCriticalThreshold(),
-          evictionThreshold);
+      this.thresholds = new MemoryThresholds(this.thresholds.getMaxMemoryBytes(),
+          this.thresholds.getCriticalThreshold(), evictionThreshold);
-      if (this.thresholds.isEvictionThresholdEnabled() || this.thresholds.isCriticalThresholdEnabled()) {
+      if (this.thresholds.isEvictionThresholdEnabled()
+          || this.thresholds.isCriticalThresholdEnabled()) {
-      } else if (!this.thresholds.isEvictionThresholdEnabled() && !this.thresholds.isCriticalThresholdEnabled()) {
+      } else if (!this.thresholds.isEvictionThresholdEnabled()
+          && !this.thresholds.isCriticalThresholdEnabled()) {
-  
+
-  
+
-   * Compare the number of bytes used (fetched from the JVM) to the thresholds.
-   * If necessary, change the state and send an event for the state change.
+   * Compare the number of bytes used (fetched from the JVM) to the thresholds. If necessary, change
+   * the state and send an event for the state change.
-    updateStateAndSendEvent(testBytesUsedForThresholdSet != -1 ? testBytesUsedForThresholdSet : getBytesUsed());
+    updateStateAndSendEvent(
+        testBytesUsedForThresholdSet != -1 ? testBytesUsedForThresholdSet : getBytesUsed());
-  
+
-   * Compare the number of bytes used to the thresholds.  If necessary, change the state
-   * and send an event for the state change.
+   * Compare the number of bytes used to the thresholds. If necessary, change the state and send an
+   * event for the state change.
-        
+
-          
-          MemoryEvent event = new MemoryEvent(ResourceType.HEAP_MEMORY, oldState, newState, this.cache.getMyId(), bytesUsed, true,
-              this.thresholds);
+
+          MemoryEvent event = new MemoryEvent(ResourceType.HEAP_MEMORY, oldState, newState,
+              this.cache.getMyId(), bytesUsed, true, this.thresholds);
-        
-      // The state didn't change.  However, if the state isn't normal and the
-      // number of bytes used changed, then go ahead and send the event
-      // again with an updated number of bytes used.
+
+        // The state didn't change. However, if the state isn't normal and the
+        // number of bytes used changed, then go ahead and send the event
+        // again with an updated number of bytes used.
-        MemoryEvent event = new MemoryEvent(ResourceType.HEAP_MEMORY, oldState, newState, this.cache.getMyId(), bytesUsed, true,
-            this.thresholds);
+        MemoryEvent event = new MemoryEvent(ResourceType.HEAP_MEMORY, oldState, newState,
+            this.cache.getMyId(), bytesUsed, true, this.thresholds);
-   * @param event
-   *          Event from which to derive data for updating stats.
+   * @param event Event from which to derive data for updating stats.
-      
+
-  
+
-   * @param profile
-   *          Profile to populate.
+   * @param profile Profile to populate.
-    profile.setHeapData(eventToPopulate.getBytesUsed(), eventToPopulate.getState(), eventToPopulate.getThresholds());
+    profile.setHeapData(eventToPopulate.getBytesUsed(), eventToPopulate.getState(),
+        eventToPopulate.getThresholds());
-  
+
-  
+
-    
-    return new MemoryThresholds(saveThresholds.getMaxMemoryBytes(), saveThresholds.getCriticalThreshold(),
-        saveThresholds.getEvictionThreshold());
+
+    return new MemoryThresholds(saveThresholds.getMaxMemoryBytes(),
+        saveThresholds.getCriticalThreshold(), saveThresholds.getEvictionThreshold());
-  
+
-   * Sets the usage threshold on the tenured pool to either the eviction
-   * threshold or the critical threshold depending on the current number of
-   * bytes used
+   * Sets the usage threshold on the tenured pool to either the eviction threshold or the critical
+   * threshold depending on the current number of bytes used
-   * @param bytesUsed
-   *          Number of bytes of heap memory currently used.
+   * @param bytesUsed Number of bytes of heap memory currently used.
-	  //// this method has been made a no-op to fix bug 49064 
+    //// this method has been made a no-op to fix bug 49064
-  
+
-    
+
-        new Object[] { Long.valueOf(usageThreshold), memoryPoolMXBean.getName() });
+        new Object[] {Long.valueOf(usageThreshold), memoryPoolMXBean.getName()});
-   * To avoid memory spikes in jrockit, we only deliver events if we receive
-   * more than {@link HeapMemoryMonitor#memoryStateChangeTolerance} of the same
-   * state change.
+   * To avoid memory spikes in jrockit, we only deliver events if we receive more than
+   * {@link HeapMemoryMonitor#memoryStateChangeTolerance} of the same state change.
-    
+
-          this.cache.getLoggerI18n().fine("State "+newState+" ignored. toleranceCounter:"
-              +this.evictionToleranceCounter+" MEMORY_EVENT_TOLERANCE:" + memoryStateChangeTolerance);
+          this.cache.getLoggerI18n()
+              .fine("State " + newState + " ignored. toleranceCounter:"
+                  + this.evictionToleranceCounter + " MEMORY_EVENT_TOLERANCE:"
+                  + memoryStateChangeTolerance);
-          this.cache.getLoggerI18n().fine("State "+newState+" ignored. toleranceCounter:"
-              +this.criticalToleranceCounter+" MEMORY_EVENT_TOLERANCE:" + memoryStateChangeTolerance);
+          this.cache.getLoggerI18n()
+              .fine("State " + newState + " ignored. toleranceCounter:"
+                  + this.criticalToleranceCounter + " MEMORY_EVENT_TOLERANCE:"
+                  + memoryStateChangeTolerance);
-   * Returns the number of bytes of memory reported by the tenured pool as
-   * currently in use.
+   * Returns the number of bytes of memory reported by the tenured pool as currently in use.
-  
+
-   * Deliver a memory event from one of the monitors to both local listeners and
-   * remote resource managers. Also, if a critical event is received and a query
-   * monitor has been enabled, then the query monitor will be notified.
+   * Deliver a memory event from one of the monitors to both local listeners and remote resource
+   * managers. Also, if a critical event is received and a query monitor has been enabled, then the
+   * query monitor will be notified.
-   * @param event
-   *          Event to process.
+   * @param event Event to process.
-      this.cache.getLoggerI18n().error(LocalizedStrings.MemoryMonitor_MEMBER_ABOVE_CRITICAL_THRESHOLD,
-          new Object[] { event.getMember(), "heap" });
+      this.cache.getLoggerI18n().error(
+          LocalizedStrings.MemoryMonitor_MEMBER_ABOVE_CRITICAL_THRESHOLD,
+          new Object[] {event.getMember(), "heap"});
-      this.cache.getLoggerI18n().error(LocalizedStrings.MemoryMonitor_MEMBER_BELOW_CRITICAL_THRESHOLD,
-          new Object[] { event.getMember(), "heap" });
+      this.cache.getLoggerI18n().error(
+          LocalizedStrings.MemoryMonitor_MEMBER_BELOW_CRITICAL_THRESHOLD,
+          new Object[] {event.getMember(), "heap"});
-          new Object[] { event.getMember(), "heap" });
+          new Object[] {event.getMember(), "heap"});
-          new Object[] { event.getMember(),  "heap" });
+          new Object[] {event.getMember(), "heap"});
-    
+
-  
+
-        this.cache.getLoggerI18n().error(LocalizedStrings.MemoryMonitor_EXCEPTION_OCCURED_WHEN_NOTIFYING_LISTENERS, t);
+        this.cache.getLoggerI18n()
+            .error(LocalizedStrings.MemoryMonitor_EXCEPTION_OCCURED_WHEN_NOTIFYING_LISTENERS, t);
-   * Given a set of members, determine if any member in the set is above
-   * critical threshold.
+   * Given a set of members, determine if any member in the set is above critical threshold.
-   * @param members
-   *          The set of members to check.
-   * @return True if the set contains a member above critical threshold, false
-   *         otherwise
+   * @param members The set of members to check.
+   * @return True if the set contains a member above critical threshold, false otherwise
-   * @param member
-   *          Member to check.
+   * @param member Member to check.
-   * @return True if the member's heap memory is in a critical state, false
-   *         otherwise.
+   * @return True if the member's heap memory is in a critical state, false otherwise.
-  
+
-    /* (non-Javadoc)
+    /*
+     * (non-Javadoc)
+     * 
-      final long usedBytes = (long)value;
+      final long usedBytes = (long) value;
-        HeapMemoryMonitor.this.resourceManager.runWithNotifyExecutor(new Runnable(){
+        HeapMemoryMonitor.this.resourceManager.runWithNotifyExecutor(new Runnable() {
-        if (HeapMemoryMonitor.this.cache.getLoggerI18n().fineEnabled()) {          
-          HeapMemoryMonitor.this.cache.getLoggerI18n().fine("StatSampler scheduled a " +
-                        "handleNotification call with "+usedBytes+" bytes");
+        if (HeapMemoryMonitor.this.cache.getLoggerI18n().fineEnabled()) {
+          HeapMemoryMonitor.this.cache.getLoggerI18n().fine(
+              "StatSampler scheduled a " + "handleNotification call with " + usedBytes + " bytes");
-          HeapMemoryMonitor.this.cache.getLoggerI18n().warning(LocalizedStrings.ResourceManager_REJECTED_EXECUTION_CAUSE_NOHEAP_EVENTS);
+          HeapMemoryMonitor.this.cache.getLoggerI18n()
+              .warning(LocalizedStrings.ResourceManager_REJECTED_EXECUTION_CAUSE_NOHEAP_EVENTS);
-  
+
-    return "HeapMemoryMonitor [thresholds=" + this.thresholds
-        + ", mostRecentEvent=" + this.mostRecentEvent
-        + ", criticalToleranceCounter=" + this.criticalToleranceCounter
+    return "HeapMemoryMonitor [thresholds=" + this.thresholds + ", mostRecentEvent="
+        + this.mostRecentEvent + ", criticalToleranceCounter=" + this.criticalToleranceCounter
-        HeapMemoryMonitor.this.cache.getLoggerI18n().fine("Poller Thread caught exception:",e);
+        HeapMemoryMonitor.this.cache.getLoggerI18n().fine("Poller Thread caught exception:", e);
-      //TODO: do we need to handle errors too?
+      // TODO: do we need to handle errors too?
-  
+
-   * Overrides the value returned by the JVM as the number of bytes of available
-   * memory.
+   * Overrides the value returned by the JVM as the number of bytes of available memory.
-   * @param testMaxMemoryBytes
-   *          The value to use as the maximum number of bytes of memory
-   *          available.
+   * @param testMaxMemoryBytes The value to use as the maximum number of bytes of memory available.
-        newThresholds = new MemoryThresholds(testMaxMemoryBytes, this.thresholds.getCriticalThreshold(), this.thresholds
-            .getEvictionThreshold());
+        newThresholds = new MemoryThresholds(testMaxMemoryBytes,
+            this.thresholds.getCriticalThreshold(), this.thresholds.getEvictionThreshold());
-  
+
-  
+
-   * Since the setter methods for the eviction and critical thresholds
-   * immediately update state based upon the new threshold value and the number
-   * of bytes currently used by the JVM, there needs to be a way to override the
-   * number of bytes of memory reported as in use for testing. That's what this
-   * method and the value it sets are for.
+   * Since the setter methods for the eviction and critical thresholds immediately update state
+   * based upon the new threshold value and the number of bytes currently used by the JVM, there
+   * needs to be a way to override the number of bytes of memory reported as in use for testing.
+   * That's what this method and the value it sets are for.
-   * @param newTestBytesUsedForThresholdSet
-   *          Value to use as the amount of memory in use when calling the
-   *          setEvictionThreshold or setCriticalThreshold methods are called.
+   * @param newTestBytesUsedForThresholdSet Value to use as the amount of memory in use when calling
+   *        the setEvictionThreshold or setCriticalThreshold methods are called.

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
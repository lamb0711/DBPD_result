GEODE-982: refactor off-heap

- removed unused MemoryChunk implementations
- collapsed OffHeapCacheDeserializable into StoredObject
- Added Slab, SlabFactory, SlabImpl, and AddressableMemoryManager.
- collapsed MemoryChunkWithRefCount into StoredObject
- methods that access and modify the data now have Data in their name
- collapsed AddressableStoredObject into StoredObject
- changed product code to use the StoredObject interface
  instead of internal class implementations of it
- renamed DataAsAddress to TinyStoredObject
- renamed ObjectChunk to OffHeapStoredObject
- renamed ObjectChunkWithHeapForm to OffHeapStoredObjectWithHeapForm
- renamed allocateChunk to allocateOffHeapStoredObject
- renamed FakeChunk to SearchMarker
- renamed ObjectChunkSlice to OffHeapStoredObjectSlice
- renamed SyncChunkStack to OffHeapStoredObjectAddressStack
- renamed ChunkValueWrapper to OffHeapValueWrapper

-import com.gemstone.gemfire.internal.offheap.ObjectChunk;
-        if (ov instanceof StoredObject) {
-          // TODO OFFHEAP: returns off-heap PdxInstance
-          return ((StoredObject) ov).getValueAsDeserializedHeapObject();
-        } else
+        // TODO OFFHEAP: returns off-heap PdxInstance
-    if (v instanceof ObjectChunk) {
+    if (isOffHeapReference(v)) {
-      if (!((ObjectChunk) v).retain()) {
+      if (!((StoredObject) v).retain()) {
-    return (this.newValue instanceof ObjectChunk) || (this.oldValue instanceof ObjectChunk);
+    return isOffHeapReference(this.newValue) || isOffHeapReference(this.oldValue);
-    if (!this.offHeapOk && result instanceof ObjectChunk) {
+    if (!this.offHeapOk && isOffHeapReference(result)) {
+  private static boolean isOffHeapReference(Object ref) {
+    return (ref instanceof StoredObject) && ((StoredObject)ref).hasRefCount();
+  }
+  
-      if (curOldValue instanceof ObjectChunk) {
-        if (ReferenceCountHelper.trackReferenceCounts()) {
-          OffHeapHelper.releaseAndTrackOwner(curOldValue, new OldValueOwner());
-        } else {
-          OffHeapHelper.release(curOldValue);
-        }
+      if (ReferenceCountHelper.trackReferenceCounts()) {
+        OffHeapHelper.releaseAndTrackOwner(curOldValue, new OldValueOwner());
+      } else {
+        OffHeapHelper.release(curOldValue);
-    if (v instanceof ObjectChunk) {
+    if (isOffHeapReference(v)) {
+      StoredObject so = (StoredObject) v;
-        boolean couldNotRetain = (!((ObjectChunk) v).retain());
+        boolean couldNotRetain = (!so.retain());
-        if (!((ObjectChunk) v).retain()) {
+        if (!so.retain()) {
-    if (!this.offHeapOk && result instanceof ObjectChunk) {
+    if (!this.offHeapOk && isOffHeapReference(result)) {
-   * Note that in some cases sqlf ignores the request to deserialize.
-      if (nv instanceof StoredObject) {
-        // TODO OFFHEAP currently we copy offheap new value to the heap here. Check callers of this method to see if they can be optimized to use offheap values.
-        // TODO OFFHEAP: returns off-heap PdxInstance
-        return ((StoredObject) nv).getValueAsDeserializedHeapObject();
-      } else
+      // TODO OFFHEAP currently we copy offheap new value to the heap here. Check callers of this method to see if they can be optimized to use offheap values.
+      // TODO OFFHEAP: returns off-heap PdxInstance
-      if (tmp instanceof StoredObject) {
-        if (!((StoredObject) tmp).isSerialized()) {
-          // TODO OFFHEAP can we handle offheap byte[] better?
-          return null;
-        }
+      CachedDeserializable cd = (CachedDeserializable) tmp;
+      if (!cd.isSerialized()) {
+        // TODO OFFHEAP can we handle offheap byte[] better?
+        return null;
-      return new SerializedCacheValueImpl(this, getRegion(), this.re,
-          (CachedDeserializable)tmp, bytes);
+      return new SerializedCacheValueImpl(this, getRegion(), this.re, cd, bytes);
-      if (nv instanceof ObjectChunk) {
+      if (so.hasRefCount()) {
-      if (ov instanceof ObjectChunk) {
+      if (so.hasRefCount()) {
-   * Note that in some cases sqlf ignores the request to deserialize.
-    final Object tmp = basicGetNewValue();
-    if (tmp instanceof StoredObject) {
-      StoredObject result = (StoredObject) tmp;
-      if (!result.retain()) {
-        return null;
-      }
-      return result;
-    } else {
-      return null;
-    }
+    return convertToStoredObject(basicGetNewValue());
-    final Object tmp = basicGetOldValue();
-    if (tmp instanceof StoredObject) {
-      StoredObject result = (StoredObject) tmp;
-      if (!result.retain()) {
-        return null;
-      }
-      return result;
-    } else {
-      return null;
-    }
+    return convertToStoredObject(basicGetOldValue());
-  /**
-   * Result may be unretained because sqlf getDeserializedForReading returns unretained.
-   */
+  private static StoredObject convertToStoredObject(final Object tmp) {
+    if (!(tmp instanceof StoredObject)) {
+      return null;
+    }
+    StoredObject result = (StoredObject) tmp;
+    if (!result.retain()) {
+      return null;
+    }
+    return result;
+  }
+  
-      if (val instanceof StoredObject) {
-        // TODO OFFHEAP: returns off-heap PdxInstance
-        return ((StoredObject) val).getValueAsDeserializedHeapObject();
-      } else 
-      if (v instanceof ObjectChunk) {
-        if (!((ObjectChunk) v).isCompressed()) { // fix bug 52109
+      if (v instanceof StoredObject) {
+        if (!((StoredObject) v).isCompressed()) { // fix bug 52109
-      if (!success && reentry instanceof OffHeapRegionEntry && v instanceof ObjectChunk) {
-        OffHeapRegionEntryHelper.releaseEntry((OffHeapRegionEntry)reentry, (ObjectChunk)v);
+      if (!success && reentry instanceof OffHeapRegionEntry && v instanceof StoredObject) {
+        OffHeapRegionEntryHelper.releaseEntry((OffHeapRegionEntry)reentry, (StoredObject)v);
-   * to Chunk's off-heap address.
+   * to the StoredObject's off-heap address.
-  public static @Unretained Object deserializeChunk(ObjectChunk bytes) {
+  public static @Unretained Object deserializeOffHeap(StoredObject bytes) {
-          if (nv instanceof StoredObject) {
-            newValueSerialized = ((StoredObject) nv).isSerialized();
-          }
+          newValueSerialized = ((CachedDeserializable) nv).isSerialized();
-        if (ov instanceof StoredObject) {
-          oldValueSerialized = ((StoredObject) ov).isSerialized();
-        }
+        oldValueSerialized = ((CachedDeserializable) ov).isSerialized();
-      if (tmp instanceof StoredObject) {
-        if (!((StoredObject) tmp).isSerialized()) {
-          // TODO OFFHEAP can we handle offheap byte[] better?
-          return null;
-        }
+      CachedDeserializable cd = (CachedDeserializable) tmp;
+      if (!cd.isSerialized()) {
+        // TODO OFFHEAP can we handle offheap byte[] better?
+        return null;
-      return new SerializedCacheValueImpl(this, this.region, this.re,
-          (CachedDeserializable)tmp, this.oldValueBytes);
+      return new SerializedCacheValueImpl(this, this.region, this.re, cd, this.oldValueBytes);
-      if (cd instanceof ObjectChunk) {
+      if (isOffHeapReference(cd)) {
+
+    @Override
+    public boolean isSerialized() {
+      return getCd().isSerialized();
+    }
+
+    @Override
+    public boolean usesHeapForStorage() {
+      return getCd().usesHeapForStorage();
+    }
-    if (ov instanceof ObjectChunk) {
+    if (ov instanceof StoredObject) {
-        ((ObjectChunk) ov).release();
+        ((StoredObject) ov).release();
-        ((ObjectChunk) ov).release();
+        ((StoredObject) ov).release();
-    if (this.newValue instanceof ObjectChunk || this.oldValue instanceof ObjectChunk) {
+    if (isOffHeapReference(this.newValue) || isOffHeapReference(this.oldValue)) {
-   * @throws IllegalStateException if called with an event for sqlf data.
-    if (ov instanceof ObjectChunk) {
+    if (isOffHeapReference(ov)) {
-    if (nv instanceof ObjectChunk) {
+    if (isOffHeapReference(nv)) {
-    if (this.newValue instanceof ObjectChunk || this.oldValue instanceof ObjectChunk) {
+    if (isOffHeapReference(this.newValue) || isOffHeapReference(this.oldValue)) {
-    return this.oldValue instanceof ObjectChunk;
+    return isOffHeapReference(this.oldValue);

INS31 INS31 INS31 MOV8 INS83 UPD83 MOV83 INS39 UPD42 MOV42 INS44 INS8 MOV8 MOV8 MOV29 MOV79 INS83 MOV43 INS42 INS8 MOV29 MOV79 INS83 MOV43 INS42 INS8 INS83 UPD83 INS43 INS42 INS44 MOV8 MOV8 UPD42 INS31 INS31 INS54 MOV43 INS42 INS41 MOV60 MOV25 MOV21 MOV60 MOV54 MOV60 MOV41 MOV41 MOV41 INS42 INS83 MOV43 INS42 INS25 MOV25 UPD43 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS8 MOV25 MOV8 MOV12 INS32 INS27 MOV22 INS32 MOV27 INS32 INS32 INS38 MOV8 MOV27 INS8 MOV8 MOV27 UPD66 UPD42 INS42 INS41 INS42 INS41 INS8 INS32 INS32 INS32 MOV25 MOV60 MOV25 MOV60 MOV41 INS42 INS42 INS32 INS32 INS32 INS36 INS32 INS42 INS42 INS60 INS32 MOV25 MOV25 INS60 MOV25 INS42 MOV32 INS42 MOV32 INS36 MOV60 MOV25 MOV21 INS60 MOV25 INS32 INS32 INS32 INS25 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS32 INS42 MOV22 MOV27 INS8 INS42 MOV22 INS42 MOV22 INS42 INS42 INS62 INS36 UPD42 MOV42 MOV43 INS59 INS42 INS42 INS43 INS59 INS32 INS32 MOV62 MOV62 MOV8 INS21 INS43 INS59 INS42 INS42 INS32 INS42 INS32 INS42 MOV32 MOV8 MOV8 INS42 MOV22 INS42 MOV22 INS42 MOV22 INS42 MOV22 MOV25 UPD42 MOV42 MOV43 INS11 INS42 INS11 INS42 INS42 MOV11 INS42 INS42 INS42 INS42 INS42 UPD42 INS25 MOV8 INS7 INS42 INS42 MOV11 INS42 INS42 INS42 MOV21 MOV21 INS21 MOV43 UPD42 MOV42 MOV43 INS42 INS42 INS38 MOV8 UPD43 INS42 INS32 INS42 MOV32 MOV32 MOV32 UPD42 INS36 INS42 UPD42 UPD42 UPD43 INS42 UPD42 MOV43 INS11 UPD42 INS43 INS42 INS42 UPD42 INS42 UPD43 UPD42 DEL40 DEL26 DEL42 DEL42 DEL43 DEL62 DEL25 DEL54 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL62 DEL36 DEL42 DEL43 DEL62 DEL36 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL25 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL43 DEL62 DEL66 DEL42 DEL42 DEL43 DEL62 DEL42 DEL11 DEL36 DEL42 DEL32 DEL41 DEL25 DEL8 DEL42 DEL11 DEL36 DEL42 DEL42 DEL43 DEL62 DEL8 DEL25 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL66 DEL33 DEL33 DEL42 DEL83 DEL42 DEL59 DEL60 DEL25 DEL8 DEL83 DEL42 DEL59 DEL60 DEL62 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL32 DEL38 DEL8 DEL25 DEL42 DEL41 DEL8 DEL8 DEL25 DEL8 DEL31 DEL66 DEL65 DEL29 DEL25 DEL8 DEL42 DEL42 DEL43 DEL62 DEL41 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL38 DEL8 DEL25 DEL42 DEL42 DEL43 DEL62 DEL25 DEL8 DEL42 DEL11 DEL36 DEL42 DEL42 DEL43 DEL62 DEL8 DEL25 DEL42 DEL42 DEL43 DEL62 DEL42 DEL7 DEL41 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL43 DEL62 DEL42 DEL43 DEL62 DEL42 DEL66 DEL65 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL62 DEL42 DEL43 DEL62 DEL42 DEL43 DEL62
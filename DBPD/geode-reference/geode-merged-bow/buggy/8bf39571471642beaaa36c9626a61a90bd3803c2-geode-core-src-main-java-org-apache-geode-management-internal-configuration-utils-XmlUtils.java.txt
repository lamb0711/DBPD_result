Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-   * @param reader
-   *          to create document from.
+   * @param reader to create document from.
-   * @throws ParserConfigurationException 
-   * @throws SAXException 
-   * @throws IOException 
+   * @throws ParserConfigurationException
+   * @throws SAXException
+   * @throws IOException
-  public static Document createDocumentFromReader(final Reader reader) throws SAXException, ParserConfigurationException, IOException {
+  public static Document createDocumentFromReader(final Reader reader)
+      throws SAXException, ParserConfigurationException, IOException {
-   
+
-    
+
-  
+
-  
-  public static NodeList query(Node node, String searchString, XPathContext xpathcontext) throws XPathExpressionException {
+
+  public static NodeList query(Node node, String searchString, XPathContext xpathcontext)
+      throws XPathExpressionException {
-  public static Element querySingleElement(Node node, String searchString, final XPathContext xPathContext) throws XPathExpressionException {
+  public static Element querySingleElement(Node node, String searchString,
+      final XPathContext xPathContext) throws XPathExpressionException {
-      try {
+    try {
-    } catch(ClassCastException e) {
+    } catch (ClassCastException e) {
-  
+
+   * 
-   * @throws ParserConfigurationException 
-   * @throws SAXException 
-   * @throws XPathExpressionException 
+   * @throws ParserConfigurationException
+   * @throws SAXException
+   * @throws XPathExpressionException
-  public static void addNewNode(final Document doc, final XmlEntity xmlEntity) throws IOException, XPathExpressionException, SAXException, ParserConfigurationException {
+  public static void addNewNode(final Document doc, final XmlEntity xmlEntity)
+      throws IOException, XPathExpressionException, SAXException, ParserConfigurationException {
-    
+
-    final int incomingElementOrder = getElementOrder(elementOrderMap, xmlEntity.getNamespace(), xmlEntity.getType());
+    final int incomingElementOrder =
+        getElementOrder(elementOrderMap, xmlEntity.getNamespace(), xmlEntity.getType());
-    for (int i=0; i < length; i++) {
+    for (int i = 0; i < length; i++) {
-      
+
-        
-        if (namespace.equals(xmlEntity.getNamespace()) 
-            && type.equals(xmlEntity.getType())) {
+
+        if (namespace.equals(xmlEntity.getNamespace()) && type.equals(xmlEntity.getType())) {
-          //First check if the element has a name
+          // First check if the element has a name
-          //If not then check if the element has an Id
+          // If not then check if the element has an Id
-          } 
-          
+          }
+
-            //If there is a match , then replace the existing node with the incoming node
+            // If there is a match , then replace the existing node with the incoming node
-            //This element does not have any name or id identifier for e.g PDX and gateway-receiver
-            //If there is only one element of that type then replace it with the incoming node
+            // This element does not have any name or id identifier for e.g PDX and gateway-receiver
+            // If there is only one element of that type then replace it with the incoming node
-  
+
-   * @return <code>true</code> if element allows multiple, otherwise
-   *         <code>false</code>.
+   * @return <code>true</code> if element allows multiple, otherwise <code>false</code>.
-  private static boolean isMultiple(final LinkedHashMap<String, CacheElement> elementOrderMap, final String namespace, final String type) {
+  private static boolean isMultiple(final LinkedHashMap<String, CacheElement> elementOrderMap,
+      final String namespace, final String type) {
-  
+
-   * @return position of the element if in map, otherwise
-   *         {@link Integer#MAX_VALUE}.
+   * @return position of the element if in map, otherwise {@link Integer#MAX_VALUE}.
-  private static int getElementOrder(final LinkedHashMap<String, CacheElement> elementOrderMap, final String namespace, final String type) {
+  private static int getElementOrder(final LinkedHashMap<String, CacheElement> elementOrderMap,
+      final String namespace, final String type) {
-  
+
-   * @param owner 
+   * 
+   * @param owner
-   * @return Node representing the xml definition 
-   * @throws ParserConfigurationException 
-   * @throws IOException 
-   * @throws SAXException 
+   * @return Node representing the xml definition
+   * @throws ParserConfigurationException
+   * @throws IOException
+   * @throws SAXException
-  private static Node createNode(Document owner, String xmlDefintion) throws SAXException, IOException, ParserConfigurationException  {
+  private static Node createNode(Document owner, String xmlDefintion)
+      throws SAXException, IOException, ParserConfigurationException {
-  
+
-    if(attributes == null) {
+    if (attributes == null) {
-    
+
-    if(attributeNode == null) {
+    if (attributeNode == null) {
-  
+
-    if(attributeNode == null) {
+    if (attributeNode == null) {
-  
+
-   * Build schema location map of schemas used in given
-   * <code>schemaLocationAttribute</code>.
+   * Build schema location map of schemas used in given <code>schemaLocationAttribute</code>.
-   * @see <a href="http://www.w3.org/TR/xmlschema-0/#schemaLocation">XML Schema
-   *      Part 0: Primer Second Edition | 5.6 schemaLocation</a>
+   * @see <a href="http://www.w3.org/TR/xmlschema-0/#schemaLocation">XML Schema Part 0: Primer
+   *      Second Edition | 5.6 schemaLocation</a>
-   * @param schemaLocation
-   *          attribute value to build schema location map from.
+   * @param schemaLocation attribute value to build schema location map from.
-  public static final Map<String, List<String>> buildSchemaLocationMap(final String schemaLocation) {
+  public static final Map<String, List<String>> buildSchemaLocationMap(
+      final String schemaLocation) {
-  
+
-  * Build schema location map of schemas used in given
-  * <code>schemaLocationAttribute</code> and adds them to the given
-  * <code>schemaLocationMap</code>.
-  * 
-  * @see <a href="http://www.w3.org/TR/xmlschema-0/#schemaLocation">XML Schema
-  *      Part 0: Primer Second Edition | 5.6 schemaLocation</a>
-  * 
-  * @param schemaLocationMap
-  *          {@link Map} to add schema locations to.
-  * @param schemaLocation
-  *          attribute value to build schema location map from.
-  * @return {@link Map} of schema namespace URIs to location URLs.
-  * @since GemFire 8.1
-  */
- static final Map<String, List<String>> buildSchemaLocationMap(Map<String, List<String>> schemaLocationMap, final String schemaLocation) {
-   if (null == schemaLocation) {
-     return schemaLocationMap;
-   }
-   
-   if (null == schemaLocation || schemaLocation.isEmpty()) {
-     // should really ever be null but being safe.
-     return schemaLocationMap;
-   }
+   * Build schema location map of schemas used in given <code>schemaLocationAttribute</code> and
+   * adds them to the given <code>schemaLocationMap</code>.
+   * 
+   * @see <a href="http://www.w3.org/TR/xmlschema-0/#schemaLocation">XML Schema Part 0: Primer
+   *      Second Edition | 5.6 schemaLocation</a>
+   * 
+   * @param schemaLocationMap {@link Map} to add schema locations to.
+   * @param schemaLocation attribute value to build schema location map from.
+   * @return {@link Map} of schema namespace URIs to location URLs.
+   * @since GemFire 8.1
+   */
+  static final Map<String, List<String>> buildSchemaLocationMap(
+      Map<String, List<String>> schemaLocationMap, final String schemaLocation) {
+    if (null == schemaLocation) {
+      return schemaLocationMap;
+    }
-   final StringTokenizer st = new StringTokenizer(schemaLocation, " \n\t\r");
-   while (st.hasMoreElements()) {
-     final String ns = st.nextToken();
-     final String loc = st.nextToken();
-     List<String> locs = schemaLocationMap.get(ns);
-     if (null == locs) {
-       locs = new ArrayList<>();
-       schemaLocationMap.put(ns, locs);
-     }
-     if (!locs.contains(loc)) {
-       locs.add(loc);
-     }
-   }
+    if (null == schemaLocation || schemaLocation.isEmpty()) {
+      // should really ever be null but being safe.
+      return schemaLocationMap;
+    }
-   return schemaLocationMap;
- }
- 
- /*****
-  * Deletes all the node from the document which match the definition provided by xmlentity
-  * @param doc 
-  * @param xmlEntity
-  * @throws Exception
-  */
- public static void deleteNode(Document doc , XmlEntity xmlEntity) throws Exception {
-   NodeList nodes = getNodes(doc, xmlEntity);
-   if (nodes != null) {
-     int length = nodes.getLength();
-     
-     for (int i=0; i<length; i++) {
-       Node node = nodes.item(i);
-       node.getParentNode().removeChild(node);
-     }
-   } 
- }
- 
- /****
-  * Gets all the nodes matching the definition given by the xml entity
-  * @param doc
-  * @param xmlEntity
-  * @return Nodes 
- * @throws XPathExpressionException 
-  */
- public static NodeList getNodes(Document doc, XmlEntity xmlEntity) throws XPathExpressionException {
-   return query(doc, xmlEntity.getSearchString(), new XPathContext(xmlEntity.getPrefix(), xmlEntity.getNamespace()));
- }
-  
+    final StringTokenizer st = new StringTokenizer(schemaLocation, " \n\t\r");
+    while (st.hasMoreElements()) {
+      final String ns = st.nextToken();
+      final String loc = st.nextToken();
+      List<String> locs = schemaLocationMap.get(ns);
+      if (null == locs) {
+        locs = new ArrayList<>();
+        schemaLocationMap.put(ns, locs);
+      }
+      if (!locs.contains(loc)) {
+        locs.add(loc);
+      }
+    }
+
+    return schemaLocationMap;
+  }
+
+  /*****
+   * Deletes all the node from the document which match the definition provided by xmlentity
+   * 
+   * @param doc
+   * @param xmlEntity
+   * @throws Exception
+   */
+  public static void deleteNode(Document doc, XmlEntity xmlEntity) throws Exception {
+    NodeList nodes = getNodes(doc, xmlEntity);
+    if (nodes != null) {
+      int length = nodes.getLength();
+
+      for (int i = 0; i < length; i++) {
+        Node node = nodes.item(i);
+        node.getParentNode().removeChild(node);
+      }
+    }
+  }
+
+  /****
+   * Gets all the nodes matching the definition given by the xml entity
+   * 
+   * @param doc
+   * @param xmlEntity
+   * @return Nodes
+   * @throws XPathExpressionException
+   */
+  public static NodeList getNodes(Document doc, XmlEntity xmlEntity)
+      throws XPathExpressionException {
+    return query(doc, xmlEntity.getSearchString(),
+        new XPathContext(xmlEntity.getPrefix(), xmlEntity.getNamespace()));
+  }
+
-    
-    public XPathContext() {
-    }
-    
+
+    public XPathContext() {}
+
-    
+
-    
+
-  
+
+   * 
-   * @throws TransformerException 
-   * @throws TransformerFactoryConfigurationError 
+   * @throws TransformerException
+   * @throws TransformerFactoryConfigurationError
-  public static String prettyXml(Node doc) throws IOException, TransformerFactoryConfigurationError, TransformerException {
+  public static String prettyXml(Node doc)
+      throws IOException, TransformerFactoryConfigurationError, TransformerException {
-  
-  public static final String elementToString(Node element) throws TransformerFactoryConfigurationError, TransformerException {
+
+  public static final String elementToString(Node element)
+      throws TransformerFactoryConfigurationError, TransformerException {
-  
-  private static final String transform(Transformer transformer, Node element) throws TransformerException {
+
+  private static final String transform(Transformer transformer, Node element)
+      throws TransformerException {
-  
+
+   * 
-   * @throws TransformerException 
-   * @throws TransformerFactoryConfigurationError 
-   * @throws ParserConfigurationException 
-   * @throws SAXException 
+   * @throws TransformerException
+   * @throws TransformerFactoryConfigurationError
+   * @throws ParserConfigurationException
+   * @throws SAXException
-  public static String prettyXml(String xmlContent) throws IOException, TransformerFactoryConfigurationError, TransformerException, SAXException, ParserConfigurationException {
+  public static String prettyXml(String xmlContent)
+      throws IOException, TransformerFactoryConfigurationError, TransformerException, SAXException,
+      ParserConfigurationException {
-  
+
-   * Create a document from the xml 
+   * Create a document from the xml
+   * 
-   * @return Document 
-   * @throws IOException 
-   * @throws ParserConfigurationException 
-   * @throws SAXException 
+   * @return Document
+   * @throws IOException
+   * @throws ParserConfigurationException
+   * @throws SAXException
-  public static Document createDocumentFromXml(String xmlContent) throws SAXException, ParserConfigurationException, IOException {
+  public static Document createDocumentFromXml(String xmlContent)
+      throws SAXException, ParserConfigurationException, IOException {
-  
+
-   * <code>namespace</code>, <code>schemaLocation</code> and
-   * <code>version</code>.
+   * <code>namespace</code>, <code>schemaLocation</code> and <code>version</code>.
-   * @param document
-   *          Config XML {@link Document} to upgrade.
-   * @param namespaceUri
-   *          Namespace URI to upgrade to.
-   * @param schemaLocation
-   *          Schema location to upgrade to.
-   * @throws XPathExpressionException 
-   * @throws ParserConfigurationException 
+   * @param document Config XML {@link Document} to upgrade.
+   * @param namespaceUri Namespace URI to upgrade to.
+   * @param schemaLocation Schema location to upgrade to.
+   * @throws XPathExpressionException
+   * @throws ParserConfigurationException
-  public static Document upgradeSchema(Document document, final String namespaceUri, final String schemaLocation, String schemaVersion) throws XPathExpressionException, ParserConfigurationException {
+  public static Document upgradeSchema(Document document, final String namespaceUri,
+      final String schemaLocation, String schemaVersion)
+      throws XPathExpressionException, ParserConfigurationException {
-      //doc.setDocType(null);
+      // doc.setDocType(null);
-    
+
-    
+
-    
+
-      changeNamespace(root, NULL_NS_URI, namespaceUri);      
+      changeNamespace(root, NULL_NS_URI, namespaceUri);
-    
+
-    
+
-    final String schemaLocationAttribute = getAttribute(root, W3C_XML_SCHEMA_INSTANCE_ATTRIBUTE_SCHEMA_LOCATION, W3C_XML_SCHEMA_INSTANCE_NS_URI);
-    
+    final String schemaLocationAttribute = getAttribute(root,
+        W3C_XML_SCHEMA_INSTANCE_ATTRIBUTE_SCHEMA_LOCATION, W3C_XML_SCHEMA_INSTANCE_NS_URI);
+
-    final Map<String, List<String>> schemaLocationMap = buildSchemaLocationMap(schemaLocationAttribute);
+    final Map<String, List<String>> schemaLocationMap =
+        buildSchemaLocationMap(schemaLocationAttribute);
-    root.setAttributeNS(W3C_XML_SCHEMA_INSTANCE_NS_URI, xsiPrefix + ":" + W3C_XML_SCHEMA_INSTANCE_ATTRIBUTE_SCHEMA_LOCATION, schemaLocationValue);
+    root.setAttributeNS(W3C_XML_SCHEMA_INSTANCE_NS_URI,
+        xsiPrefix + ":" + W3C_XML_SCHEMA_INSTANCE_ATTRIBUTE_SCHEMA_LOCATION, schemaLocationValue);
-    if(cachePrefix== null || cachePrefix.isEmpty()) {
+    if (cachePrefix == null || cachePrefix.isEmpty()) {
-        
+
-  
-  
+
+
-   * @see <a href="http://www.w3.org/TR/xmlschema-0/#schemaLocation">XML Schema
-   *      Part 0: Primer Second Edition | 5.6 schemaLocation</a>
+   * @see <a href="http://www.w3.org/TR/xmlschema-0/#schemaLocation">XML Schema Part 0: Primer
+   *      Second Edition | 5.6 schemaLocation</a>
-   * @param schemaLocationMap
-   *          {@link Map} to get schema locations from.
+   * @param schemaLocationMap {@link Map} to get schema locations from.
-  private static final String getSchemaLocationValue(final Map<String, List<String>> schemaLocationMap) {
+  private static final String getSchemaLocationValue(
+      final Map<String, List<String>> schemaLocationMap) {
-  
+
-   * @param root
-   *          {@link Element} to get namespaces and prefixes from.
+   * @param root {@link Element} to get namespaces and prefixes from.
-    //Look for all of the attributes of cache that start with
-    //xmlns
+    // Look for all of the attributes of cache that start with
+    // xmlns
-    for(int i = 0; i < attributes.getLength(); i++) {
+    for (int i = 0; i < attributes.getLength(); i++) {
-      if(item.getNodeName().startsWith("xmlns")) {
-        //Anything after the colon is the prefix
-        //eg xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-        //has a prefix of xsi
+      if (item.getNodeName().startsWith("xmlns")) {
+        // Anything after the colon is the prefix
+        // eg xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+        // has a prefix of xsi
-        if(splitName.length > 1) {
+        if (splitName.length > 1) {
-    
+
-  
+
-   * <code>newNamespaceUri</code> if that node is in the given
-   * <code>oldNamespaceUri</code> namespace URI.
+   * <code>newNamespaceUri</code> if that node is in the given <code>oldNamespaceUri</code>
+   * namespace URI.
-   * @param node
-   *          {@link Node} to change namespace URI on.
-   * @param oldNamespaceUri
-   *          old namespace URI to change from.
-   * @param newNamespaceUri
-   *          new Namespace URI to change to.
+   * @param node {@link Node} to change namespace URI on.
+   * @param oldNamespaceUri old namespace URI to change from.
+   * @param newNamespaceUri new Namespace URI to change to.
-   * @return the modified version of the passed in node. 
+   * @return the modified version of the passed in node.
-  static final Node changeNamespace(final Node node, final String oldNamespaceUri, final String newNamespaceUri) throws XPathExpressionException {
+  static final Node changeNamespace(final Node node, final String oldNamespaceUri,
+      final String newNamespaceUri) throws XPathExpressionException {
-        Node renamed = node.getOwnerDocument().renameNode(element, newNamespaceUri, element.getNodeName());
-        if(element == node) {
+        Node renamed =
+            node.getOwnerDocument().renameNode(element, newNamespaceUri, element.getNodeName());
+        if (element == node) {
-  
+
-   * Method to modify the root attribute (cache) of the XML 
+   * Method to modify the root attribute (cache) of the XML
+   * 
-    String type =  xmlEntity.getType();
+    String type = xmlEntity.getType();
-    
+
-      
+
-        
-        //Remove the existing attribute
+
+        // Remove the existing attribute
-        
-        //Add the new attribute with new value
+
+        // Add the new attribute with new value
-  
+
+   * 
-   * @throws ParserConfigurationException 
-   * @throws SAXException 
-   * @throws TransformerException 
-   * @throws TransformerFactoryConfigurationError 
+   * @throws ParserConfigurationException
+   * @throws SAXException
+   * @throws TransformerException
+   * @throws TransformerFactoryConfigurationError
-  public static String readXmlAsStringFromFile(String xmlFilePath) throws IOException, SAXException, ParserConfigurationException, TransformerFactoryConfigurationError, TransformerException{
-	File file = new File(xmlFilePath);
-	//The file can be empty if the only command we have issued for this group is deployJar
-	if(file.length() == 0) {
+  public static String readXmlAsStringFromFile(String xmlFilePath) throws IOException, SAXException,
+      ParserConfigurationException, TransformerFactoryConfigurationError, TransformerException {
+    File file = new File(xmlFilePath);
+    // The file can be empty if the only command we have issued for this group is deployJar
+    if (file.length() == 0) {
-	}
-	
-	Document doc = getDocumentBuilder().parse(file);
-	return elementToString(doc);
+    }
+
+    Document doc = getDocumentBuilder().parse(file);
+    return elementToString(doc);

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class stands between {@link Executor} and {@link Cache#getRegion(String)}.
- * This is needed because some keys for Redis represented as a {@link Region} in
- * {@link GeodeRedisServer} come with additional state. Therefore getting, creating,
- * or destroying a {@link Region} needs to be synchronized, which is done away with
- * and abstracted by this class.
+ * This class stands between {@link Executor} and {@link Cache#getRegion(String)}. This is needed
+ * because some keys for Redis represented as a {@link Region} in {@link GeodeRedisServer} come with
+ * additional state. Therefore getting, creating, or destroying a {@link Region} needs to be
+ * synchronized, which is done away with and abstracted by this class.
-   * This is the Redis meta data {@link Region} that holds the {@link RedisDataType}
-   * information for all Regions created. The mapping is a {@link String} key which is the name
-   * of the {@link Region} created to hold the data to the RedisDataType it contains.
+   * This is the Redis meta data {@link Region} that holds the {@link RedisDataType} information for
+   * all Regions created. The mapping is a {@link String} key which is the name of the
+   * {@link Region} created to hold the data to the RedisDataType it contains.
-   * This is the {@link RedisDataType#REDIS_STRING} {@link Region}. This is the Region
-   * that stores all string contents
+   * This is the {@link RedisDataType#REDIS_STRING} {@link Region}. This is the Region that stores
+   * all string contents
-   * This is the {@link RedisDataType#REDIS_HLL} {@link Region}. This is the Region
-   * that stores all HyperLogLog contents
+   * This is the {@link RedisDataType#REDIS_HLL} {@link Region}. This is the Region that stores all
+   * HyperLogLog contents
-  private final ConcurrentMap<ByteArrayWrapper, Map<Enum<?>, Query>> preparedQueries = new ConcurrentHashMap<ByteArrayWrapper, Map<Enum<?>, Query>>();
+  private final ConcurrentMap<ByteArrayWrapper, Map<Enum<?>, Query>> preparedQueries =
+      new ConcurrentHashMap<ByteArrayWrapper, Map<Enum<?>, Query>>();
-  private static final CreateAlterDestroyRegionCommands cliCmds = new CreateAlterDestroyRegionCommands();
+  private static final CreateAlterDestroyRegionCommands cliCmds =
+      new CreateAlterDestroyRegionCommands();
-  public RegionProvider(Region<ByteArrayWrapper, ByteArrayWrapper> stringsRegion, Region<ByteArrayWrapper, HyperLogLogPlus> hLLRegion, Region<String, RedisDataType> redisMetaRegion, ConcurrentMap<ByteArrayWrapper, ScheduledFuture<?>> expirationsMap, ScheduledExecutorService expirationExecutor, RegionShortcut defaultShortcut) {
+  public RegionProvider(Region<ByteArrayWrapper, ByteArrayWrapper> stringsRegion,
+      Region<ByteArrayWrapper, HyperLogLogPlus> hLLRegion,
+      Region<String, RedisDataType> redisMetaRegion,
+      ConcurrentMap<ByteArrayWrapper, ScheduledFuture<?>> expirationsMap,
+      ScheduledExecutorService expirationExecutor, RegionShortcut defaultShortcut) {
-      if (lock != null)  {// Strings/hlls will not have locks
+      if (lock != null) {// Strings/hlls will not have locks
-  public Region<?, ?> getOrCreateRegion(ByteArrayWrapper key, RedisDataType type, ExecutionHandlerContext context) {
+  public Region<?, ?> getOrCreateRegion(ByteArrayWrapper key, RedisDataType type,
+      ExecutionHandlerContext context) {
-              //ignore
+              // ignore
-  private Region<?, ?> getOrCreateRegion0(ByteArrayWrapper key, RedisDataType type, ExecutionHandlerContext context, boolean addToMeta) {
+  private Region<?, ?> getOrCreateRegion0(ByteArrayWrapper key, RedisDataType type,
+      ExecutionHandlerContext context, boolean addToMeta) {
-          boolean hasTransaction = context != null && context.hasTransaction(); // Can create without context
+          boolean hasTransaction = context != null && context.hasTransaction(); // Can create
+                                                                                // without context
-            } while(concurrentCreateDestroyException != null);
-            this.regions.put(key, r);            
+            } while (concurrentCreateDestroyException != null);
+            this.regions.put(key, r);
-                throw new RedisDataTypeMismatchException("The key name \"" + key + "\" is already used by a " + existingType.toString());
+                throw new RedisDataTypeMismatchException(
+                    "The key name \"" + key + "\" is already used by a " + existingType.toString());
-  private void doInitializeSortedSet(ByteArrayWrapper key, Region<?, ?> r) throws RegionNotFoundException, IndexInvalidException {
+  private void doInitializeSortedSet(ByteArrayWrapper key, Region<?, ?> r)
+      throws RegionNotFoundException, IndexInvalidException {
-      queryService.createIndex("scoreIndex", "entry.value.score", r.getFullPath() + ".entrySet entry");
+      queryService.createIndex("scoreIndex", "entry.value.score",
+          r.getFullPath() + ".entrySet entry");
-    for (SortedSetQuery lq: SortedSetQuery.values()) {
+    for (SortedSetQuery lq : SortedSetQuery.values()) {
-    for (ListQuery lq: ListQuery.values()) {
+    for (ListQuery lq : ListQuery.values()) {
-   * This method creates a Region globally with the given name. If
-   * there is an error in the creation, a runtime exception will
-   * be thrown.
+   * This method creates a Region globally with the given name. If there is an error in the
+   * creation, a runtime exception will be thrown.
-    if (r != null) return r;
+    if (r != null)
+      return r;
-      Result result = cliCmds.createRegion(key, defaultRegionType, null, null, true, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
+      Result result = cliCmds.createRegion(key, defaultRegionType, null, null, true, null, null,
+          null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,
+          null, null, null, null, null, null, null, null, null, null, null, null, null, null, null,
+          null);
-        while(result.hasNextLine())
+        while (result.hasNextLine())
-    } while(r == null); // The region can be null in the case that it is concurrently destroyed by
+    } while (r == null); // The region can be null in the case that it is concurrently destroyed by
-    if (query instanceof ListQuery) {
-      return this.queryService.newQuery(((ListQuery)query).getQueryString(this.regions.get(key).getFullPath()));
-    } else {
-      return this.queryService.newQuery(((SortedSetQuery)query).getQueryString(this.regions.get(key).getFullPath()));
-    }
+     * if (query instanceof ListQuery) { return
+     * this.queryService.newQuery(((ListQuery)query).getQueryString(this.regions.get(key).
+     * getFullPath())); } else { return
+     * this.queryService.newQuery(((SortedSetQuery)query).getQueryString(this.regions.get(key).
+     * getFullPath())); }
-   * Checks if the given key is associated with the passed data type.
-   * If there is a mismatch, a {@link RuntimeException} is thrown
+   * Checks if the given key is associated with the passed data type. If there is a mismatch, a
+   * {@link RuntimeException} is thrown
-      throw new RedisDataTypeMismatchException("The key name \"" + key + "\" is already used by a " + currentType.toString());
+      throw new RedisDataTypeMismatchException(
+          "The key name \"" + key + "\" is already used by a " + currentType.toString());
-   * Sets the expiration for a key. The setting and modifying of a key expiration can only be set by a delay,
-   * which means that both expiring after a time and at a time can be done but
-   * the delay to expire at a time must be calculated before these calls. It is
-   * also important to note that the delay is always handled in milliseconds
+   * Sets the expiration for a key. The setting and modifying of a key expiration can only be set by
+   * a delay, which means that both expiring after a time and at a time can be done but the delay to
+   * expire at a time must be calculated before these calls. It is also important to note that the
+   * delay is always handled in milliseconds
-    ScheduledFuture<?> future = this.expirationExecutor.schedule(new ExpirationExecutor(key, type, this), delay, TimeUnit.MILLISECONDS);
+    ScheduledFuture<?> future = this.expirationExecutor
+        .schedule(new ExpirationExecutor(key, type, this), delay, TimeUnit.MILLISECONDS);
-    ScheduledFuture<?> future = this.expirationExecutor.schedule(new ExpirationExecutor(key, type, this), delay, TimeUnit.MILLISECONDS);
+    ScheduledFuture<?> future = this.expirationExecutor
+        .schedule(new ExpirationExecutor(key, type, this), delay, TimeUnit.MILLISECONDS);

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66
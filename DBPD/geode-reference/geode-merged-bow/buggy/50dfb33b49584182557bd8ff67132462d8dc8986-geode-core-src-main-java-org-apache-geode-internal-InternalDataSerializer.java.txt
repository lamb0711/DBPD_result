GEODE-6588: Cleanup generics and other static analyzer issues. (#3391)


+import java.util.Objects;
-  private static final ConcurrentMap/* <Integer, DataSerializer|Marker> */ idsToSerializers =
-      new ConcurrentHashMap();
+  private static final ConcurrentMap<Integer, Object /* DataSerializer|Marker */> idsToSerializers =
+      new ConcurrentHashMap<>();
-  private static final ConcurrentMap dsfidToClassMap =
-      logger.isTraceEnabled(LogMarker.SERIALIZER_WRITE_DSFID_VERBOSE) ? new ConcurrentHashMap()
+  private static final ConcurrentMap<Integer, String> dsfidToClassMap =
+      logger.isTraceEnabled(LogMarker.SERIALIZER_WRITE_DSFID_VERBOSE) ? new ConcurrentHashMap<>()
-  private static volatile Set listeners = new HashSet();
-  @MakeNotStatic
-  private static DataSerializer dvddeserializer;
+  private static volatile Set<RegistrationListener> listeners = new HashSet<>();
-    Collection<String> result = new ArrayList(1000);
+    ArrayList<String> result = new ArrayList<>(1000);
-        if (line.startsWith("#") || line.startsWith("//")) {
-          // comment line
-        } else {
+        if (!(line.startsWith("#") || line.startsWith("//"))) {
-  static DataSerializer newInstance(Class c) {
+  static DataSerializer newInstance(Class<? extends DataSerializer> c)
+      throws IllegalArgumentException {
-    Constructor init;
+    Constructor<? extends DataSerializer> init;
-      init = c.getDeclaredConstructor(new Class[0]);
+      init = c.getDeclaredConstructor();
-      s = (DataSerializer) init.newInstance(new Object[0]);
+      s = init.newInstance();
-  public static DataSerializer register(Class c, boolean distribute, EventID eventId,
+  public static DataSerializer register(Class<? extends DataSerializer> c, boolean distribute,
+      EventID eventId,
-  public static DataSerializer register(Class c, boolean distribute) {
+  public static DataSerializer register(Class<? extends DataSerializer> c, boolean distribute) {
-                  new Object[] {other.getClass().getName(), other.getId()}));
+                  other.getClass().getName(), other.getId()));
-    InternalCache cache = GemFireCacheImpl.getInstance();
+    InternalCache cache = getInternalCache();
+  @SuppressWarnings("deprecation")
+  private static InternalCache getInternalCache() {
+    return GemFireCacheImpl.getInstance();
+  }
+
-                new Object[] {oldValue.getClass().getName(), oldValue.getId()}));
+                oldValue.getClass().getName(), oldValue.getId()));
-    InternalCache cache = GemFireCacheImpl.getInstance();
+    InternalCache cache = getInternalCache();
-    InternalCache cache = GemFireCacheImpl.getInstance();
+    InternalCache cache = getInternalCache();
-        Class dsClass = null;
+        Class<DataSerializer> dsClass;
-          dsClass = getCachedClass(sah.getClassName());
-
+          dsClass = InternalDataSerializer.getCachedClass(sah.getClassName());
-              dsClass);
+              c.getName());
-        Class dsClass = null;
+        Class<DataSerializer> dsClass;
-
-          logger.info(LogMarker.SERIALIZER_MARKER,
-              "Could not load DataSerializer class: {}",
-              dsClass);
+          logger.info(LogMarker.SERIALIZER_MARKER, "Could not load DataSerializer class: {}",
+              sah.getClassName());
-    Collection coll = new ArrayList(size);
+    List<DataSerializer> coll = new ArrayList<>(size);
-        coll.add(v);
+        coll.add((DataSerializer) v);
-        Class cl = getCachedClass(name);
+        Class<? extends DataSerializer> cl = getCachedClass(name);
-    return (DataSerializer[]) coll.toArray(new DataSerializer[coll.size()]);
+    return coll.toArray(new DataSerializer[0]);
-    return coll.toArray(new SerializerAttributesHolder[coll.size()]);
-  }
-
-  /**
-   * Persist this class's map to out TODO: saveRegistrations is unused
-   */
-  public static void saveRegistrations(DataOutput out) throws IOException {
-    for (Object v : idsToSerializers.values()) {
-      if (v instanceof InitMarker) {
-        v = ((Marker) v).getSerializer();
-      }
-      if (v instanceof DataSerializer) {
-        DataSerializer ds = (DataSerializer) v;
-        out.writeInt(ds.getId()); // since 5.7 an int instead of a byte
-        DataSerializer.writeClass(ds.getClass(), out);
-      }
-    }
-    if (!dsClassesToHolders.isEmpty()) {
-      Iterator<Entry<String, SerializerAttributesHolder>> iterator =
-          dsClassesToHolders.entrySet().iterator();
-      Class dsClass = null;
-      while (iterator.hasNext()) {
-        try {
-          dsClass = getCachedClass(iterator.next().getKey());
-        } catch (ClassNotFoundException ignored) {
-          logger.info(LogMarker.SERIALIZER_MARKER, "Could not load DataSerializer class: {}",
-              dsClass);
-          continue;
-        }
-        DataSerializer ds = register(dsClass, false);
-        iterator.remove();
-        idsToHolders.remove(ds.getId());
-        for (Class clazz : ds.getSupportedClasses()) {
-          supportedClassesToHolders.remove(clazz.getName());
-        }
-
-        out.writeInt(ds.getId()); // since 5.7 an int instead of a byte
-        DataSerializer.writeClass(ds.getClass(), out);
-      }
-    }
-    // We know that DataSerializer's id must be > 0 so write a zero
-    // to mark the end of the ds list.
-    out.writeInt(0); // since 5.7 an int instead of a byte
-  }
-
-  /**
-   * Read the data from in and register it with this class. TODO: loadRegistrations is unused
-   *
-   * @throws IllegalArgumentException if a registration fails
-   */
-  public static void loadRegistrations(DataInput in) throws IOException {
-    while (in.readInt() != 0) {
-      Class dsClass = null;
-      boolean skip = false;
-      try {
-        dsClass = DataSerializer.readClass(in);
-      } catch (ClassNotFoundException ignored) {
-        skip = true;
-      }
-      if (skip) {
-        continue;
-      }
-      register(dsClass, /* dsId, */ true);
-    }
+    return coll.toArray(new SerializerAttributesHolder[0]);
-      Set newSet = new HashSet(listeners);
+      Set<RegistrationListener> newSet = new HashSet<>(listeners);
-      Set newSet = new HashSet(listeners);
+      Set<RegistrationListener> newSet = new HashSet<>(listeners);
-    for (Object listener1 : listeners) {
-      RegistrationListener listener = (RegistrationListener) listener1;
+    for (RegistrationListener listener : listeners) {
-    for (Object listener1 : listeners) {
-      RegistrationListener listener = (RegistrationListener) listener1;
+    for (RegistrationListener listener : listeners) {
-        String existingClassName = (String) dsfidToClassMap.putIfAbsent(dsfid, newClassName);
+        String existingClassName = dsfidToClassMap.putIfAbsent(dsfid, newClassName);
-      throw new IOException(String.format("Serializer with Id %s is not registered",
-          new Object[] {serializerId}));
+      throw new IOException(String.format("Serializer with Id %s is not registered", serializerId));
-            .trace(LogMarker.SERIALIZER_VERBOSE, "Writing HashSet with {} elements: {}", size, set);
+            .trace(LogMarker.SERIALIZER_VERBOSE, "Writing Set with {} elements: {}", size, set);
-            .trace(LogMarker.SERIALIZER_VERBOSE, "Writing HashSet with {} elements: {}", -1, set);
+            .trace(LogMarker.SERIALIZER_VERBOSE, "Writing Set with {} elements: {}", -1, null);
-   * Reads a {@code Set} from a {@code DataInput} into the given non-null collection. Returns true
-   * if collection read is non-null else returns false. TODO: readCollection is unused
-   *
-   * @throws IOException A problem occurs while reading from {@code in}
-   * @throws ClassNotFoundException The class of one of the {@code Set}'s elements cannot be found.
-   * @see #writeSet
-   */
-  public static <E> boolean readCollection(DataInput in, Collection<E> c)
-      throws IOException, ClassNotFoundException {
-
-    checkIn(in);
-
-    final int size = readArrayLength(in);
-    if (size >= 0) {
-      for (int index = 0; index < size; ++index) {
-        E element = DataSerializer.readObject(in);
-        c.add(element);
-      }
-
-      if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
-        logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read Collection with {} elements: {}", size, c);
-      }
-      return true;
-    }
-    return false;
-  }
-
-  /**
-      Set result = new HashSet(size);
-      boolean longIDs = in.readBoolean();
-      for (int i = 0; i < size; i++) {
-        long l = longIDs ? in.readLong() : in.readInt();
-        result.add(l);
-      }
-      return result;
-    }
-  }
-
-  /**
-   * write a set of Long objects TODO: writeListOfLongs is unused
-   *
-   * @param list the set of Long objects
-   * @param hasLongIDs if false, write only ints, not longs
-   * @param out the output stream
-   */
-  public static void writeListOfLongs(List list, boolean hasLongIDs, DataOutput out)
-      throws IOException {
-    if (list == null) {
-      out.writeInt(-1);
-    } else {
-      out.writeInt(list.size());
-      out.writeBoolean(hasLongIDs);
-      for (Object aList : list) {
-        Long l = (Long) aList;
-        if (hasLongIDs) {
-          out.writeLong(l);
-        } else {
-          out.writeInt((int) l.longValue());
-        }
-      }
-    }
-  }
-
-  /**
-   * read a set of Long objects
-   */
-  public static List<Long> readListOfLongs(DataInput in) throws IOException {
-    int size = in.readInt();
-    if (size < 0) {
-      return null;
-    } else {
-      List result = new LinkedList();
+      Set<Long> result = new HashSet<>(size);
-  public static Class decodePrimitiveClass(byte typeCode) throws IOException {
+  public static Class<?> decodePrimitiveClass(byte typeCode) throws IOException {
-    BigInteger result = new BigInteger(DataSerializer.readByteArray(in));
+    BigInteger result = new BigInteger(Objects.requireNonNull(DataSerializer.readByteArray(in)));
-    InternalCache internalCache = GemFireCacheImpl.getInstance();
+    InternalCache internalCache = getInternalCache();
+  @SuppressWarnings("unchecked")
-    Class c = readClass(in);
+    Class<? extends DataSerializer> c = (Class<? extends DataSerializer>) readClass(in);
-      Constructor init = c.getConstructor(new Class[0]);
+      Constructor<? extends DataSerializer> init = c.getConstructor();
-      Object o = init.newInstance(new Object[0]);
+      Object o = init.newInstance();
-  // TODO: registerDVDDeserializer is unused
-  public static void registerDVDDeserializer(DataSerializer dvddeslzr) {
-    dvddeserializer = dvddeslzr;
-  }
-
+      case DATA_SERIALIZABLE:
-        return null;
-      case DATA_SERIALIZABLE:
-        return readDataSerializable(in);
-      out.write((int) data >>> 0 & 0xFF);
+      out.write((int) data & 0xFF);
-    } else if (code == LONG_VL) {
-      result = in.readLong();
-      throw new IllegalStateException("unexpected variable length code=" + code);
+      result = in.readLong();
-  public static Class<?> getCachedClass(String p_className) throws ClassNotFoundException {
+  @SuppressWarnings("unchecked")
+  public static <T> Class<T> getCachedClass(String p_className) throws ClassNotFoundException {
-      return ClassPathLoader.getLatest().forName(className);
+      return (Class<T>) ClassPathLoader.getLatest().forName(className);
-      return result;
+      return (Class<T>) result;
-   * Serializes a list of Integers. The argument may be null. Deserialize with
-   * readListOfIntegers().
-   *
-   * TODO: writeListOfIntegers is unused
-   */
-  public void writeListOfIntegers(List<Integer> list, DataOutput out) throws IOException {
-    if (list != null) {
-      InternalDataSerializer.writeArrayLength(list.size(), out);
-      for (Integer entry : list) {
-        out.writeInt(entry);
-      }
-    } else {
-      InternalDataSerializer.writeArrayLength(-1, out);
-    }
-  }
-
-  /**
-        Class<?> c;
+        Class<? extends DataSerializer> c;
-          c = getCachedClass(this.className); // fix for bug 41206
+          c = getCachedClass(this.className);
-        } catch (IllegalArgumentException ex) {
-          logger.warn(
-              "Could not register data serializer for class {} so both clients of this server and this server will not have this data serializer. Registration failed because: {}",
-              this.className, getFullMessage(ex));
-        } catch (IllegalStateException ex) {
+        } catch (IllegalArgumentException | IllegalStateException ex) {
-        } catch (IllegalArgumentException ex) {
-          logger.warn(
-              "Could not register data serializer for class {} so it will not be available in this JVM. Registration failed because: {}",
-              this.className, getFullMessage(ex));
-        } catch (IllegalStateException ex) {
+        } catch (IllegalArgumentException | IllegalStateException ex) {
-      this.eventId = (EventID) DataSerializer.readObject(in);
+      this.eventId = DataSerializer.readObject(in);
-    protected Class resolveProxyClass(String[] interfaces)
-        throws IOException, ClassNotFoundException {
+    protected Class resolveProxyClass(String[] interfaces) throws ClassNotFoundException {
-  protected abstract static class WellKnownPdxDS extends WellKnownDS {
+  abstract static class WellKnownPdxDS extends WellKnownDS {

INS26 INS40 INS31 INS74 INS74 INS74 INS43 INS79 INS83 INS83 INS43 INS42 INS8 MOV8 INS74 INS79 INS79 INS73 UPD74 MOV43 MOV43 MOV43 MOV43 MOV43 INS43 MOV43 INS43 INS74 INS42 INS74 INS74 INS42 INS45 UPD42 MOV42 MOV41 INS70 INS43 MOV76 INS42 INS45 MOV49 INS42 INS45 INS42 MOV43 UPD43 INS74 INS42 MOV42 INS42 INS74 UPD74 MOV43 INS76 INS74 MOV43 INS76 MOV43 INS76 MOV32 INS74 MOV44 MOV32 INS44 INS42 INS8 INS42 INS74 UPD42 MOV43 INS74 MOV43 MOV43 INS43 MOV43 INS76 INS43 MOV43 INS32 MOV43 INS43 MOV42 INS60 MOV60 MOV43 INS42 MOV21 MOV43 UPD42 MOV43 INS76 INS11 MOV43 INS74 UPD42 MOV42 MOV43 INS42 INS42 UPD42 UPD42 INS42 INS74 MOV42 MOV62 MOV8 INS34 INS34 INS74 INS59 INS74 MOV32 MOV32 INS74 INS32 UPD42 INS43 INS74 MOV32 INS74 MOV8 INS11 INS11 MOV32 INS43 INS32 MOV43 MOV42 MOV42 MOV43 MOV43 MOV43 INS42 INS14 MOV43 MOV43 INS43 INS43 INS42 INS42 MOV32 INS42 MOV43 INS76 MOV43 INS76 INS74 MOV32 INS74 INS42 UPD74 INS42 INS38 MOV42 MOV42 INS74 INS74 MOV7 MOV42 INS74 INS74 INS42 INS74 MOV43 INS42 MOV42 INS42 INS74 INS43 MOV43 UPD27 MOV27 INS43 INS43 INS43 INS43 UPD76 INS36 MOV43 MOV43 MOV43 INS43 MOV32 MOV11 MOV43 INS76 MOV43 MOV43 MOV32 UPD45 UPD45 INS33 MOV43 INS42 UPD34 INS42 INS42 INS42 INS42 INS43 INS84 INS84 MOV27 MOV32 MOV32 INS42 MOV43 INS42 MOV43 MOV43 MOV43 MOV43 INS42 INS32 INS32 MOV42 MOV32 MOV32 UPD42 MOV42 INS42 INS42 UPD42 MOV42 DEL43 DEL42 DEL78 DEL83 DEL83 DEL42 DEL59 DEL23 DEL42 DEL43 DEL8 DEL43 DEL85 DEL5 DEL34 DEL3 DEL85 DEL5 DEL34 DEL3 DEL32 DEL11 DEL43 DEL43 DEL42 DEL43 DEL85 DEL5 DEL4 DEL3 DEL9 DEL42 DEL43 DEL85 DEL5 DEL4 DEL3 DEL42 DEL42 DEL33 DEL33 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL85 DEL5 DEL11 DEL42 DEL42 DEL32 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL42 DEL32 DEL38 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL40 DEL45 DEL42 DEL32 DEL21 DEL18 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL70 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL61 DEL8 DEL25 DEL42 DEL42 DEL34 DEL32 DEL21 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL33 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL9 DEL7 DEL21 DEL8 DEL12 DEL54 DEL42 DEL18 DEL8 DEL25 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL61 DEL8 DEL31 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL70 DEL8 DEL42 DEL43 DEL42 DEL42 DEL11 DEL59 DEL60 DEL11 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL42 DEL66 DEL66 DEL65 DEL66 DEL66 DEL65 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL65 DEL42 DEL66 DEL66 DEL65 DEL66 DEL65 DEL42 DEL67 DEL65 DEL29 DEL83 DEL83 DEL42 DEL73 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL21 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL38 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL45 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL9 DEL41 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL33 DEL27 DEL42 DEL42 DEL34 DEL38 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL39 DEL42 DEL42 DEL32 DEL11 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL8 DEL25 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL33 DEL41 DEL8 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL16 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL42 DEL41 DEL8 DEL25 DEL8 DEL31 DEL42 DEL85 DEL5 DEL34 DEL3 DEL42 DEL43 DEL85 DEL5 DEL34 DEL3 DEL83 DEL83 DEL39 DEL42 DEL42 DEL44 DEL42 DEL42 DEL7 DEL21 DEL8 DEL31 DEL33 DEL41 DEL42 DEL42 DEL32 DEL41 DEL34 DEL27 DEL42 DEL42 DEL27 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL8 DEL42 DEL42 DEL34 DEL38 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL42 DEL44 DEL42 DEL42 DEL45 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL12 DEL42 DEL43 DEL11 DEL42 DEL43 DEL83
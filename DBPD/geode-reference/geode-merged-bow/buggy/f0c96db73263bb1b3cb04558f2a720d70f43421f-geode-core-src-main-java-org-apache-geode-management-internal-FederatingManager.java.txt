GEODE-7330: Prevent RegionDestroyedException in FederatingManager (#4193)

* GEODE-7330: Prevent RegionDestroyedException in FederatingManager

Cleanup management classes:
* Reduce method and field visibility as much as possible
* Remove unnecessary uses of this
* Reorder fields and methods based on visibility and other modifiers
* Use @VisibleForTesting annotation
* Fixup formatting and variable names

Make all FederatingManager fields final:
* Remove field setters for tests
* Introduce FederatingManagerFactory
* Add FederatingManagerFactory system property for tests to
  SystemManagementService
* Inject all FederatingManager fields via constructor
* Use Geode APIs in MBeanFederationErrorPathDUnitTest

Rename MBeanFederationErrorHandlingDistributedTest:
* Rename MBeanFederationErrorPathDUnitTest as
  MBeanFederationErrorHandlingDistributedTest
+import org.apache.geode.cache.RegionDestroyedException;
-import org.apache.geode.internal.logging.LoggingExecutors;
-  public static final Logger logger = LogService.getLogger();
+  private static final Logger logger = LogService.getLogger();
+
+  private final SystemManagementService service;
+  private final AtomicReference<Exception> latestException = new AtomicReference<>();
-  private ExecutorService pooledMembershipExecutor;
+  private final ExecutorService executorService;
+  private final MBeanProxyFactory proxyFactory;
+  private final MemberMessenger messenger;
-  /**
-   * Proxy factory is used to create , remove proxies
-   */
-  private MBeanProxyFactory proxyFactory;
-
-  private MemberMessenger messenger;
-
-  private final SystemManagementService service;
-
-  private final AtomicReference<Exception> latestException = new AtomicReference<>(null);
-
-  FederatingManager(MBeanJMXAdapter jmxAdapter, ManagementResourceRepo repo,
-      InternalDistributedSystem system, SystemManagementService service, InternalCache cache,
-      StatisticsFactory statisticsFactory, StatisticsClock statisticsClock) {
+  FederatingManager(ManagementResourceRepo repo, InternalDistributedSystem system,
+      SystemManagementService service, InternalCache cache, StatisticsFactory statisticsFactory,
+      StatisticsClock statisticsClock, MBeanProxyFactory proxyFactory, MemberMessenger messenger,
+      ExecutorService executorService) {
-    proxyFactory = new MBeanProxyFactory(jmxAdapter, service);
-    messenger = new MemberMessenger(jmxAdapter, system);
-  }
-
-  @VisibleForTesting
-  void setProxyFactory(MBeanProxyFactory newProxyFactory) {
-    proxyFactory = newProxyFactory;
+    this.proxyFactory = proxyFactory;
+    this.messenger = messenger;
+    this.executorService = executorService;
-      pooledMembershipExecutor = LoggingExecutors.newFixedThreadPool("FederatingManager", true,
-          Runtime.getRuntime().availableProcessors());
-
-  /**
-   * This method will be invoked whenever a member stops being a managing node. The
-   * {@code ManagementException} has to be handled by the caller.
-   */
-  private void stopManagingActivity() {
-    try {
-      pooledMembershipExecutor.shutdownNow();
-
-      for (DistributedMember distributedMember : repo.getMonitoringRegionMap().keySet()) {
-        removeMemberArtifacts(distributedMember, false);
-      }
-    } catch (Exception e) {
-      throw new ManagementException(e);
-    }
-  }
-
-  /**
-   * This method will be invoked from MembershipListener which is registered when the member becomes
-   * a Management node.
-   *
-   * <p>
-   * This method will delegate task to another thread and exit, so that it wont block the membership
-   * listener
-   */
-  @VisibleForTesting
-  public void addMember(InternalDistributedMember member) {
-    GIITask giiTask = new GIITask(member);
-    executeTask(() -> {
-      try {
-        giiTask.call();
-      } catch (RuntimeException e) {
-        logger.warn("Error federating new member {}", member.getId(), e);
-        latestException.set(e);
-      }
-    });
+  public MemberMessenger getMessenger() {
+    return messenger;
-  private void executeTask(Runnable task) {
-    try {
-      pooledMembershipExecutor.execute(task);
-    } catch (RejectedExecutionException ignored) {
-      // Ignore, we are getting shutdown
-    }
-  }
-
-  private void removeMemberArtifacts(DistributedMember member, boolean crashed) {
-    Region<String, Object> proxyRegion = repo.getEntryFromMonitoringRegionMap(member);
-    Region<NotificationKey, Notification> notificationRegion =
-        repo.getEntryFromNotifRegionMap(member);
-
-    if (proxyRegion == null && notificationRegion == null) {
-      return;
-    }
-
-    repo.romoveEntryFromMonitoringRegionMap(member);
-    repo.removeEntryFromNotifRegionMap(member);
-
-    // If cache is closed all the regions would have been destroyed implicitly
-    if (!cache.isClosed()) {
-      proxyFactory.removeAllProxies(member, proxyRegion);
-      proxyRegion.localDestroyRegion();
-      notificationRegion.localDestroyRegion();
-    }
-
-    if (!system.getDistributedMember().equals(member)) {
-      service.memberDeparted((InternalDistributedMember) member, crashed);
-    }
-  }
-
+   * This will return the last updated time of the proxyMBean.
+   *
+   * @param objectName {@link ObjectName} of the MBean
+   *
+   * @return last updated time of the proxy
+   */
+  long getLastUpdateTime(ObjectName objectName) {
+    return proxyFactory.getLastUpdateTime(objectName);
+  }
+
+  /**
+   * Find a particular proxy instance for a {@link ObjectName}, {@link DistributedMember} and
+   * interface class If the proxy interface does not implement the given interface class a
+   * {@link ClassCastException} will be thrown
+   *
+   * @param objectName {@link ObjectName} of the MBean
+   * @param interfaceClass interface class implemented by proxy
+   *
+   * @return an instance of proxy exposing the given interface
+   */
+  <T> T findProxy(ObjectName objectName, Class<T> interfaceClass) {
+    return proxyFactory.findProxy(objectName, interfaceClass);
+  }
+
+  /**
+   * Find a set of proxies given a {@link DistributedMember}.
+   *
+   * @param member {@link DistributedMember}
+   *
+   * @return a set of {@link ObjectName}
+   */
+  Set<ObjectName> findAllProxies(DistributedMember member) {
+    return proxyFactory.findAllProxies(member);
+  }
+
+  /**
+   * This method will be invoked whenever a member stops being a managing node. The
+   * {@code ManagementException} has to be handled by the caller.
+   */
+  private void stopManagingActivity() {
+    try {
+      executorService.shutdownNow();
+
+      for (DistributedMember distributedMember : repo.getMonitoringRegionMap().keySet()) {
+        removeMemberArtifacts(distributedMember, false);
+      }
+    } catch (Exception e) {
+      throw new ManagementException(e);
+    }
+  }
+
+  private void executeTask(Runnable task) {
+    try {
+      executorService.execute(task);
+    } catch (RejectedExecutionException ignored) {
+      // Ignore, we are getting shutdown
+    }
+  }
+
+  /**
-          pooledMembershipExecutor.invokeAll(giiTaskList);
+          executorService.invokeAll(giiTaskList);
-   * For internal Use only
+   * This method will be invoked from MembershipListener which is registered when the member becomes
+   * a Management node.
+   *
+   * <p>
+   * This method will delegate task to another thread and exit, so that it wont block the membership
+   * listener
+  void addMember(InternalDistributedMember member) {
+    GIITask giiTask = new GIITask(member);
+    executeTask(() -> {
+      try {
+        giiTask.call();
+      } catch (RuntimeException e) {
+        logger.warn("Error federating new member {}", member.getId(), e);
+        latestException.set(e);
+      }
+    });
+  }
+
+  @VisibleForTesting
+  void removeMemberArtifacts(DistributedMember member, boolean crashed) {
+    Region<String, Object> monitoringRegion = repo.getEntryFromMonitoringRegionMap(member);
+    Region<NotificationKey, Notification> notificationRegion =
+        repo.getEntryFromNotifRegionMap(member);
+
+    if (monitoringRegion == null && notificationRegion == null) {
+      return;
+    }
+
+    repo.romoveEntryFromMonitoringRegionMap(member);
+    repo.removeEntryFromNotifRegionMap(member);
+
+    // If cache is closed all the regions would have been destroyed implicitly
+    if (!cache.isClosed()) {
+      try {
+        proxyFactory.removeAllProxies(member, monitoringRegion);
+      } catch (RegionDestroyedException ignore) {
+        // ignored
+      }
+      try {
+        monitoringRegion.localDestroyRegion();
+      } catch (RegionDestroyedException ignore) {
+        // ignored
+      }
+      try {
+        notificationRegion.localDestroyRegion();
+      } catch (RegionDestroyedException ignore) {
+        // ignored
+      }
+    }
+
+    if (!system.getDistributedMember().equals(member)) {
+      service.memberDeparted((InternalDistributedMember) member, crashed);
+    }
+  }
+
+  @VisibleForTesting
-  /**
-   * This will return the last updated time of the proxyMBean.
-   *
-   * @param objectName {@link ObjectName} of the MBean
-   *
-   * @return last updated time of the proxy
-   */
-  long getLastUpdateTime(ObjectName objectName) {
-    return proxyFactory.getLastUpdateTime(objectName);
-  }
-
-  /**
-   * Find a particular proxy instance for a {@link ObjectName}, {@link DistributedMember} and
-   * interface class If the proxy interface does not implement the given interface class a
-   * {@link ClassCastException} will be thrown
-   *
-   * @param objectName {@link ObjectName} of the MBean
-   * @param interfaceClass interface class implemented by proxy
-   *
-   * @return an instance of proxy exposing the given interface
-   */
-  <T> T findProxy(ObjectName objectName, Class<T> interfaceClass) {
-    return proxyFactory.findProxy(objectName, interfaceClass);
-  }
-
-  /**
-   * Find a set of proxies given a {@link DistributedMember}.
-   *
-   * @param member {@link DistributedMember}
-   *
-   * @return a set of {@link ObjectName}
-   */
-  Set<ObjectName> findAllProxies(DistributedMember member) {
-    return proxyFactory.findAllProxies(member);
-  }
-
-  public MemberMessenger getMessenger() {
-    return messenger;
-  }
-
-  public void setMessenger(MemberMessenger messenger) {
-    this.messenger = messenger;
-  }
-
-  @VisibleForTesting
-  public synchronized Exception getAndResetLatestException() {
+  synchronized Exception getAndResetLatestException() {
-      service.memberJoined((InternalDistributedMember) member);
+      service.memberJoined(member);
-    GIITask(InternalDistributedMember member) {
+    private GIITask(InternalDistributedMember member) {
-    RemoveMemberTask(DistributedMember member, boolean crashed) {
+    private RemoveMemberTask(DistributedMember member, boolean crashed) {

MOV26 MOV23 MOV23 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 UPD40 MOV44 UPD83 INS83 INS83 INS83 INS44 INS44 MOV78 UPD42 MOV43 INS42 UPD43 UPD42 INS43 INS42 MOV21 INS21 INS83 INS83 MOV42 INS42 INS7 INS22 INS42 INS22 INS42 UPD42 INS54 INS54 INS54 INS52 INS42 INS52 INS42 UPD42 INS8 INS12 INS8 INS12 INS8 INS12 UPD42 UPD42 MOV21 INS44 INS8 MOV21 INS44 INS8 MOV21 INS44 INS8 INS42 UPD42 INS43 INS42 INS43 INS42 INS43 INS42 UPD42 INS42 UPD42 INS42 INS42 DEL33 DEL66 DEL65 DEL29 DEL42 DEL42 DEL42 DEL14 DEL42 DEL42 DEL43 DEL42 DEL42 DEL14 DEL42 DEL78 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL7 DEL21 DEL8 DEL31 DEL42 DEL42 DEL42 DEL45 DEL9 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL7 DEL21 DEL83 DEL83 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL11
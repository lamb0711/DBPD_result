GEODE-7832: Remove Connection Semaphores (#4754)

Removed the semaphores and related methods from DirectChannel and
Connection classes. They were used to constrain messaging when some
undocumented system properties were set.
-import java.util.concurrent.Semaphore;
-import org.apache.geode.distributed.DistributedSystemDisconnectedException;
-import org.apache.geode.internal.util.concurrent.ReentrantSemaphore;
-      this.groupOrderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
-      this.groupUnorderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
-      this.groupOrderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
-      this.groupUnorderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
-
-  /**
-   * Return how many concurrent operations should be allowed by default. since 6.6, this has been
-   * raised to Integer.MAX value from the number of available processors. Setting this to a lower
-   * value raises the possibility of a deadlock when serializing a message with PDX objects, because
-   * the PDX serialization can trigger further distribution.
-   */
-  public static final int DEFAULT_CONCURRENCY_LEVEL =
-      Integer.getInteger("p2p.defaultConcurrencyLevel", Integer.MAX_VALUE / 2).intValue();
-
-  /**
-   * The maximum number of concurrent senders sending a message to a group of recipients.
-   */
-  private static final int MAX_GROUP_SENDERS =
-      Integer.getInteger("p2p.maxGroupSenders", DEFAULT_CONCURRENCY_LEVEL).intValue();
-  private Semaphore groupUnorderedSenderSem;
-  private Semaphore groupOrderedSenderSem;
-
-  private Semaphore getGroupSem(boolean ordered) {
-    if (ordered) {
-      return this.groupOrderedSenderSem;
-    } else {
-      return this.groupUnorderedSenderSem;
-    }
-  }
-
-  private void acquireGroupSendPermission(boolean ordered) {
-    if (this.disconnected) {
-      throw new org.apache.geode.distributed.DistributedSystemDisconnectedException(
-          "Direct channel has been stopped");
-    }
-    // @todo darrel: add some stats
-    final Semaphore s = getGroupSem(ordered);
-    for (;;) {
-      this.conduit.getCancelCriterion().checkCancelInProgress(null);
-      boolean interrupted = Thread.interrupted();
-      try {
-        s.acquire();
-        break;
-      } catch (InterruptedException ex) {
-        interrupted = true;
-      } finally {
-        if (interrupted) {
-          Thread.currentThread().interrupt();
-        }
-      }
-    } // for
-    if (this.disconnected) {
-      s.release();
-      throw new DistributedSystemDisconnectedException(
-          "communications disconnected");
-    }
-  }
-
-  private void releaseGroupSendPermission(boolean ordered) {
-    final Semaphore s = getGroupSem(ordered);
-    s.release();
-  }
-
-        boolean sendingToGroup = cons.size() > 1;
-        Connection permissionCon = null;
-        if (sendingToGroup) {
-          acquireGroupSendPermission(orderedMsg);
-        } else {
-          // sending over just one connection
-          permissionCon = (Connection) cons.get(0);
-          if (permissionCon != null) {
-            try {
-              permissionCon.acquireSendPermission();
-            } catch (ConnectionException conEx) {
-              // Set retryInfo and then retry.
-              // We want to keep calling TCPConduit.getConnection until it doesn't
-              // return a connection.
-              retryInfo = new ConnectExceptions();
-              retryInfo.addFailure(permissionCon.getRemoteAddress(), conEx);
-              continue;
-            }
-          }
+        if (retry && logger.isDebugEnabled()) {
+          logger.debug("Retrying send ({}{}) to {} peers ({}) via tcp/ip",
+              msg, cons.size(), cons);
+        DMStats stats = getDMStats();
+        List<?> sentCons; // used for cons we sent to this time
+        final BaseMsgStreamer ms =
+            MsgStreamer.create(cons, msg, directReply, stats, getConduit().getBufferPool());
-          if (retry && logger.isDebugEnabled()) {
-            logger.debug("Retrying send ({}{}) to {} peers ({}) via tcp/ip",
-                msg, cons.size(), cons);
+          startTime = 0;
+          if (ackTimeout > 0) {
+            startTime = System.currentTimeMillis();
-          DMStats stats = getDMStats();
-          List<?> sentCons; // used for cons we sent to this time
+          ms.reserveConnections(startTime, ackTimeout, ackSDTimeout);
-          final BaseMsgStreamer ms =
-              MsgStreamer.create(cons, msg, directReply, stats, getConduit().getBufferPool());
-          try {
-            startTime = 0;
-            if (ackTimeout > 0) {
-              startTime = System.currentTimeMillis();
-            }
-            ms.reserveConnections(startTime, ackTimeout, ackSDTimeout);
-
-            int result = ms.writeMessage();
-            if (bytesWritten == 0) {
-              // bytesWritten only needs to be set once.
-              // if we have to do a retry we don't want to count
-              // each one's bytes.
-              bytesWritten = result;
-            }
-            ce = ms.getConnectExceptions();
-            sentCons = ms.getSentConnections();
-
-            totalSentCons.addAll(sentCons);
-          } catch (NotSerializableException e) {
-            throw e;
-          } catch (IOException ex) {
-            throw new InternalGemFireException(
-                "Unknown error serializing message",
-                ex);
-          } finally {
-            try {
-              ms.close();
-            } catch (IOException e) {
-              throw new InternalGemFireException("Unknown error serializing message", e);
-            }
+          int result = ms.writeMessage();
+          if (bytesWritten == 0) {
+            // bytesWritten only needs to be set once.
+            // if we have to do a retry we don't want to count
+            // each one's bytes.
+            bytesWritten = result;
+          ce = ms.getConnectExceptions();
+          sentCons = ms.getSentConnections();
-          if (ce != null) {
-            retryInfo = ce;
-            ce = null;
-          }
-
-          if (directReply && !sentCons.isEmpty()) {
-            long readAckStart = 0;
-            if (stats != null) {
-              readAckStart = stats.startReplyWait();
-            }
-            try {
-              ce = readAcks(sentCons, startTime, ackTimeout, ackSDTimeout, ce,
-                  directMsg.getDirectReplyProcessor());
-            } finally {
-              if (stats != null) {
-                stats.endReplyWait(readAckStart, startTime);
-              }
-            }
-          }
+          totalSentCons.addAll(sentCons);
+        } catch (NotSerializableException e) {
+          throw e;
+        } catch (IOException ex) {
+          throw new InternalGemFireException(
+              "Unknown error serializing message",
+              ex);
-          if (sendingToGroup) {
-            releaseGroupSendPermission(orderedMsg);
-          } else if (permissionCon != null) {
-            permissionCon.releaseSendPermission();
+          try {
+            ms.close();
+          } catch (IOException e) {
+            throw new InternalGemFireException("Unknown error serializing message", e);
+
+        if (ce != null) {
+          retryInfo = ce;
+          ce = null;
+        }
+
+        if (directReply && !sentCons.isEmpty()) {
+          long readAckStart = 0;
+          if (stats != null) {
+            readAckStart = stats.startReplyWait();
+          }
+          try {
+            ce = readAcks(sentCons, startTime, ackTimeout, ackSDTimeout, ce,
+                directMsg.getDirectReplyProcessor());
+          } finally {
+            if (stats != null) {
+              stats.endReplyWait(readAckStart, startTime);
+            }
+          }
+        }
+
-    try {
-      groupOrderedSenderSem.release();
-    } catch (Error e) {
-      // GEODE-1076 - already released
-    }
-    try {
-      groupUnorderedSenderSem.release();
-    } catch (Error e) {
-      // GEODE-1076 - already released
-    }

MOV8 MOV60 MOV60 MOV60 MOV60 MOV60 MOV60 MOV60 MOV60 MOV60 MOV60 MOV60 MOV60 MOV25 MOV25 MOV60 MOV25 MOV25 MOV25 MOV41 INS8 MOV8 INS19 MOV25 MOV24 MOV42 MOV53 MOV8 MOV27 MOV21 MOV25 MOV60 MOV60 MOV25 MOV25 MOV25 INS25 MOV25 MOV21 INS27 MOV8 MOV32 INS42 INS33 UPD42 MOV42 UPD42 MOV42 INS8 UPD42 MOV42 MOV21 MOV21 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL14 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL14 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL14 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL14 DEL7 DEL21 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL40 DEL34 DEL27 DEL32 DEL42 DEL32 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL42 DEL32 DEL42 DEL32 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL39 DEL42 DEL44 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL52 DEL42 DEL22 DEL41 DEL8 DEL25 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL40 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL33 DEL32 DEL21 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL10 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL9 DEL7 DEL21 DEL8 DEL12 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL24 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL39 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL43 DEL42 DEL42 DEL34 DEL32 DEL11 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL18 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL25 DEL32 DEL42 DEL33 DEL27 DEL8 DEL25 DEL25 DEL19 DEL8 DEL54 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54
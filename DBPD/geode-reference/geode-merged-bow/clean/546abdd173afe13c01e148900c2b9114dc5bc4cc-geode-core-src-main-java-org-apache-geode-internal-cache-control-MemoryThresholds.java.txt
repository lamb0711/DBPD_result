GEODE-6304: Refactor memory monitor to properly reset tolerance counter (#3102)

The tolerance counter was not properly being reset between
non-consecutive EVICTION and CRITICAL events.  To fix this and make it
more understandable, the threshold logic was combined with the logic to
compute the next state in the MemoryThreshold state machine.  The
counter is now reset between non-consecutive EVICTION and CRITICAL
events.

+  /*
+   * Number of eviction or critical state changes that have to occur before the event is delivered.
+   * The default is 0 so we will change states immediately by default.
+   */
+  private static int memoryStateChangeTolerance =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "memoryEventTolerance", 0);
+
+  // Only change state when these counters exceed {@link
+  // HeapMemoryMonitor#memoryStateChangeTolerance}
+  private transient int toleranceCounter;
+
+        toleranceCounter = 0;
-        return MemoryState.EVICTION;
+        return checkToleranceAndGetNextState(MemoryState.EVICTION, oldState);
-      return MemoryState.EVICTION_CRITICAL;
+      return checkToleranceAndGetNextState(MemoryState.EVICTION_CRITICAL, oldState);
+        toleranceCounter = 0;
-      return MemoryState.EVICTION_DISABLED_CRITICAL;
+      return checkToleranceAndGetNextState(MemoryState.EVICTION_DISABLED_CRITICAL, oldState);
+      toleranceCounter = 0;
-    return MemoryState.EVICTION_CRITICAL_DISABLED;
+    return checkToleranceAndGetNextState(MemoryState.EVICTION_CRITICAL_DISABLED, oldState);
+  void setMemoryStateChangeTolerance(int memoryStateChangeTolerance) {
+    MemoryThresholds.memoryStateChangeTolerance = memoryStateChangeTolerance;
+  }
+
+  int getMemoryStateChangeTolerance() {
+    return MemoryThresholds.memoryStateChangeTolerance;
+  }
+
+
+  /**
+   * To avoid memory spikes in JVMs susceptible to bad heap memory
+   * reads/outliers, we only deliver events if we receive more than
+   * memoryStateChangeTolerance of the same state change.
+   *
+   * @return New state if above tolerance, old state if below
+   */
+  private MemoryState checkToleranceAndGetNextState(MemoryState newState, MemoryState oldState) {
+    return memoryStateChangeTolerance > 0
+        && toleranceCounter++ < memoryStateChangeTolerance ? oldState : newState;
+  }

INS23 INS23 INS31 INS31 INS31 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS39 INS42 INS44 INS8 INS39 INS42 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS8 INS42 INS32 INS42 INS39 INS42 INS21 INS41 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS41 INS42 INS42 INS27 INS34 INS32 INS7 INS40 INS66 INS66 INS66 INS66 INS42 INS42 INS16 INS40 INS45 INS21 INS42 INS40 INS42 INS40 INS42 INS27 INS42 INS42 INS32 INS32 INS7 INS27 INS27 INS21 INS42 INS40 INS42 INS21 INS42 INS40 INS42 INS42 INS34 INS42 INS34 INS37 INS42 INS7 INS32 INS7 INS42 INS42 INS34 INS42 INS40 INS42 INS42 INS34 DEL40 DEL40 DEL40 DEL40
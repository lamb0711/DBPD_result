GEODE-4299: refactor eviction (#1290)

GEODE-4299: refactor eviction

The EvictionController classes are no longer Serializable nor Cloneable. These internal classes used to be external and needed to be these things in the past because they were stored in the configuration. But they no longer are so these interfaces were removed for clarity.
The EvictionController classes are no longer responsible for creating InternalEvictionStatistics. Instead the other entities it depends on are passed in to its constructor.

The only class with an EvictionController instance is now VMLRURegionMap which makes the code easier to understand and reduces the number of inter-module dependencies.

renamed internalSetMaximum to setMaximum on EvictionAttributesImpl

AbstractBucketRegionQueue no longer uses EvictionStatistics to notify itself that it removed some objects from the queue. So it no longer needs to access all the EvictionStatistics.

AbstractLRURegionMap has been moved to VMLRURegionMap
Casts to AbstractLRURegionMap have been removed by added additional methods to RegionMap.

new EvictableRegion interface make clear the things a region implementation needs to do/provide for the eviction implementation

EvictionAttributesMutator is now implemented by the dedicated class EvictionAttributesMutatorImpl

close and clear on RegionMap now take a BucketRegion parameter so that the eviction classes do not need to keep track of the BucketRegion.

EvictionList no longer does some of the things it did before that should have been the responsibility of the EvictionController. Now the EvictionList is given the EvictionController it should defer to. The EvictionListBuilder has been simplified since EvictionList now only needs a controller.

The eviction classes that track statistics have been refactored to be clearer. Now the EvictionStats interface is implemented by classes that provide vsd type stats. The EvictionCounters interface is implemented by a class that wraps EvictionStats and provides atomics for some of them.* Removed old code that made the EvictionController classes
Serializable, Declarable, and Clonable.

-import java.util.Properties;
-
-import org.apache.geode.StatisticDescriptor;
-import org.apache.geode.StatisticsType;
-import org.apache.geode.StatisticsTypeFactory;
-import org.apache.geode.cache.Declarable;
-import org.apache.geode.cache.EvictionAttributes;
-import org.apache.geode.cache.Region;
-import org.apache.geode.cache.RegionAttributes;
+import org.apache.geode.cache.EvictionAlgorithm;
-import org.apache.geode.internal.ClassPathLoader;
-import org.apache.geode.internal.cache.CachedDeserializableFactory;
-import org.apache.geode.internal.size.Sizeable;
-import org.apache.geode.internal.statistics.StatisticsTypeFactoryImpl;
- * A {@code CapacityController} that will remove the least recently used (LRU) entry from a region
- * once the region reaches a certain byte {@linkplain #setMaximumMegabytes capacity}. Capacity is
- * determined by monitoring the size of entries added and evicted. Capacity is specified in terms of
- * megabytes. GemFire uses an efficient algorithm to determine the amount of space a region entry
- * occupies in the VM. However, this algorithm may not yield optimal results for all kinds of data.
- * The user may provide his or her own algorithm for determining the size of objects by implementing
- * an {@link ObjectSizer}.
- *
- * <p>
- * MemoryLRUController must be set in the {@link RegionAttributes} before the region is created. A
- * Region with MemoryLRUController set will throw an {@link IllegalStateException} if an attempt is
- * made to replace the Region's capacity controller. While the capacity controller cannot be
- * replaced, it does support changing the limit with the {@link #setMaximumMegabytes} method.
- *
- * <p>
- * If you are using a {@code cache.xml} file to create a JCache region declaratively, you can
- * include the following to associate a {@code MemoryLRUController} with a region:
- *
- * <pre>
- *  &lt;region-attributes&gt;
- *    &lt;capacity-controller&gt;
- *      &lt;classname&gt;org.apache.geode.cache.MemoryLRUController&lt;/classname&gt;
- *         &lt;parameter name="maximum-megabytes"&gt;
- *           &lt;string&gt;50&lt;/string&gt;
- *         &lt;/parameter&gt;
- *         &lt;parameter name="eviction-action"&gt;
- *           &lt;string&gt;overflow-to-disk&lt;/string&gt;
- *         &lt;/parameter&gt;
- *    &lt;/capacity-controller&gt;
- *  &lt;/region-attributes&gt;
- * </pre>
+ * An {@code EvictionController} that will evict one more entries from a region once the region
+ * reaches a certain byte {@linkplain #setMaximumMegabytes capacity}. Capacity is determined by
+ * monitoring the size of entries. Capacity is specified in terms of megabytes. GemFire uses an
+ * efficient algorithm to determine the amount of space a region entry occupies in the JVM. However,
+ * this algorithm may not yield optimal results for all kinds of data. The user may provide their
+ * own algorithm for determining the size of objects by implementing an {@link ObjectSizer}.
-public class MemoryLRUController extends SizeLRUController implements Declarable {
+public class MemoryLRUController extends SizeLRUController {
-  private static final long serialVersionUID = 6364183985590572514L;
-
-  private static final int OVERHEAD_PER_ENTRY = 250;
-
-  /**
-   * The key for setting the maximum-entries property declaratively.
-   *
-   * @see #init
-   */
-  private static final String MAXIMUM_MEGABYTES = "maximum-megabytes";
-
-  /**
-   * The {@link #init initialization} property that specifies the name of the {@link ObjectSizer}
-   * implementation class.
-   */
-  private static final String SIZER_IMPL = "sizer";
+  private long limit;
+  private final boolean isOffHeap;
-  protected static final StatisticsType statType;
-
-  static {
-    // create the stats type for MemLRU.
-    StatisticsTypeFactory f = StatisticsTypeFactoryImpl.singleton();
-
-    final String bytesAllowedDesc = "Number of total bytes allowed in this region.";
-    final String byteCountDesc = "Number of bytes in region.";
-    final String lruEvictionsDesc = "Number of total entry evictions triggered by LRU.";
-    final String lruDestroysDesc =
-        "Number of entries destroyed in the region through both destroy cache operations and eviction. Reset to zero each time it exceeds lruDestroysLimit.";
-    final String lruDestroysLimitDesc =
-        "Maximum number of entry destroys triggered by LRU before scan occurs.";
-    final String lruEvaluationsDesc = "Number of entries evaluated during LRU operations.";
-    final String lruGreedyReturnsDesc = "Number of non-LRU entries evicted during LRU operations";
-
-    statType = f.createType("MemLRUStatistics",
-        "Statistics about byte based Least Recently Used region entry disposal",
-        new StatisticDescriptor[] {f.createLongGauge("bytesAllowed", bytesAllowedDesc, "bytes"),
-            f.createLongGauge("byteCount", byteCountDesc, "bytes"),
-            f.createLongCounter("lruEvictions", lruEvictionsDesc, "entries"),
-            f.createLongCounter("lruDestroys", lruDestroysDesc, "entries"),
-            f.createLongGauge("lruDestroysLimit", lruDestroysLimitDesc, "entries"),
-            f.createLongCounter("lruEvaluations", lruEvaluationsDesc, "entries"),
-            f.createLongCounter("lruGreedyReturns", lruGreedyReturnsDesc, "entries"),});
-  }
-
-  private long limit = (EvictionAttributes.DEFAULT_MEMORY_MAXIMUM) * ONE_MEG;
-
-  private int perEntryOverHead = OVERHEAD_PER_ENTRY;
-
-  private final boolean isOffHeap;
-
-  /**
-   * Create an instance of the capacity controller with default settings. The default settings are 0
-   * {@code maximum-megabytes} and a default {@code sizer}, requiring either the {@link #init}
-   * method to be called, or the {@link #setMaximumMegabytes} method.
-   */
-  public MemoryLRUController(Region region) {
-    this(EvictionAttributes.DEFAULT_MEMORY_MAXIMUM, region);
-  }
-
-   * @param megabytes the amount of memory allowed in this region specified in megabytes.<br>
-   *        <p>
-   *        For a region with {@link org.apache.geode.cache.DataPolicy#PARTITION}, it is overridden
-   *        by {@link org.apache.geode.cache.PartitionAttributesFactory#setLocalMaxMemory(int) "
-   *        local max memory "} specified for the
-   *        {@link org.apache.geode.cache.PartitionAttributes}. It signifies the amount of memory
-   *        allowed in the region, collectively for its primary buckets and redundant copies for
-   *        this VM. It can be different for the same region in different VMs.
-   */
-  public MemoryLRUController(int megabytes, Region region) {
-    this(megabytes, null /* sizerImpl */, region);
-  }
-
-  /**
-   * Create an instance of the capacity controller the given settings.
-   *
-   * @param megabytes the amount of memory allowed in this region specified in megabytes.<br>
-   *        <p>
-   *        For a region with {@link org.apache.geode.cache.DataPolicy#PARTITION}, it is overridden
-   *        by {@link org.apache.geode.cache.PartitionAttributesFactory#setLocalMaxMemory(int) "
-   *        local max memory "} specified for the
-   *        {@link org.apache.geode.cache.PartitionAttributes}. It signifies the amount of memory
-   *        allowed in the region, collectively for its primary buckets and redundant copies for
-   *        this VM. It can be different for the same region in different VMs.
-   * @param sizerImpl classname of a class that implements ObjectSizer, used to compute object sizes
-   *        for MemLRU
-   */
-  public MemoryLRUController(int megabytes, ObjectSizer sizerImpl, Region region) {
-    this(megabytes, sizerImpl, EvictionAction.DEFAULT_EVICTION_ACTION, region, false);
-  }
-
-  /**
-   * Create an instance of the capacity controller the given settings.
+   * @param evictionCounters
-  public MemoryLRUController(int megabytes, ObjectSizer sizer, EvictionAction evictionAction,
-      Region region, boolean isOffHeap) {
-    super(evictionAction, region, sizer);
+  public MemoryLRUController(EvictionCounters evictionCounters, int megabytes, ObjectSizer sizer,
+      EvictionAction evictionAction, boolean isOffHeap, EvictionAlgorithm algorithm) {
+    super(evictionCounters, evictionAction, sizer, algorithm);
-   * Declaratively initializes this capacity controller. Supported properties are:
-   *
-   * <ul>
-   * <li>{@link #MAXIMUM_MEGABYTES maximum-megabytes}: The number of megabytes to limit the region
-   * to.</li>
-   * <li>{@link #EVICTION_ACTION eviction-action}: The action to perform when the LRU region entry
-   * is evicted.</li>
-   * <li>{@link #SIZER_IMPL sizer}: The name of the {@link ObjectSizer} implementation class to use
-   * for computing the size of region entries.</li>
-   * </ul>
-   *
-   * @throws NumberFormatException The {@code maximum-megabytes} property cannot be parsed as an
-   *         integer
-   * @throws IllegalArgumentException The value of the {@code eviction-action} property is not
-   *         recognized.
-   */
-  @Override
-  public void init(Properties props) {
-    String prop;
-    String sizerStr;
-    if ((sizerStr = props.getProperty(SIZER_IMPL)) != null) {
-      try {
-        Class c = ClassPathLoader.getLatest().forName(sizerStr);
-        setSizer((ObjectSizer) c.newInstance());
-      } catch (Exception e) {
-        throw new IllegalArgumentException(
-            LocalizedStrings.MemLRUCapacityController_COULD_NOT_CREATE_SIZER_INSTANCE_GIVEN_THE_CLASS_NAME_0
-                .toLocalizedString(sizerStr),
-            e);
-      }
-    }
-
-    if ((prop = props.getProperty(MAXIMUM_MEGABYTES)) != null) {
-      this.limit = Integer.parseInt(prop) * ONE_MEG;
-    }
-
-    if ((prop = props.getProperty(EVICTION_ACTION)) != null) {
-      setEvictionAction(EvictionAction.parseAction(prop));
-    }
-  }
-
-  /**
-  public void setMaximumMegabytes(int megabytes) {
+  private void setMaximumMegabytes(int megabytes) {
-    this.limit = (megabytes) * ONE_MEG;
-    if (bucketRegion != null) {
-      bucketRegion.setLimit(this.limit);
-    } else if (this.stats != null) {
-      this.stats.setLimit(this.limit);
-    }
+    this.limit = megabytes * ONE_MEG;
+    getCounters().setLimit(this.limit);
-  /**
-   * Sets the the number of bytes of overhead each object occupies in the VM. This value may vary
-   * between VM implementations.
-   */
-  public void setEntryOverHead(int entryOverHead) {
-    this.perEntryOverHead = entryOverHead;
-  }
-
-   * Indicate what kind of {@code AbstractEvictionController} this helper implements
-   */
-  @Override
-  public org.apache.geode.cache.EvictionAlgorithm getEvictionAlgorithm() {
-    return org.apache.geode.cache.EvictionAlgorithm.LRU_MEMORY;
-  }
-
-
-  /**
-  public int entrySize(Object key, Object value) throws IllegalArgumentException {
+  public int entrySize(Object key, Object value) {
-    if (!MemoryLRUController.this.isOffHeap) {
-      size += MemoryLRUController.this.getPerEntryOverhead();
+    if (!this.isOffHeap) {
+      size += getPerEntryOverhead();
-  public StatisticsType getStatisticsType() {
-    return statType;
+  public boolean mustEvict(EvictionCounters counters, InternalRegion region, int delta) {
+    return counters.getCounter() + delta > counters.getLimit();
-  public String getStatisticsName() {
-    return "MemLRUStatistics";
-  }
-
-  @Override
-  public int getLimitStatId() {
-    return statType.nameToId("bytesAllowed");
-  }
-
-  @Override
-  public int getCountStatId() {
-    return statType.nameToId("byteCount");
-  }
-
-  @Override
-  public int getEvictionsStatId() {
-    return statType.nameToId("lruEvictions");
-  }
-
-  @Override
-  public int getDestroysStatId() {
-    return statType.nameToId("lruDestroys");
-  }
-
-  @Override
-  public int getDestroysLimitStatId() {
-    return statType.nameToId("lruDestroysLimit");
-  }
-
-  @Override
-  public int getEvaluationsStatId() {
-    return statType.nameToId("lruEvaluations");
-  }
-
-  @Override
-  public int getGreedyReturnsStatId() {
-    return statType.nameToId("lruGreedyReturns");
-  }
-
-  @Override
-  public boolean mustEvict(EvictionStatistics stats, InternalRegion region, int delta) {
-    return stats.getCounter() + delta > stats.getLimit();
-  }
-
-  @Override
-  public boolean lruLimitExceeded(EvictionStatistics stats, DiskRegionView diskRegionView) {
-    return stats.getCounter() > stats.getLimit();
-  }
-
-  // added to fix bug 40718
-  static int basicSizeof(Object o, ObjectSizer sizer) throws IllegalArgumentException {
-    final boolean cdChangingForm = o instanceof CachedDeserializableValueWrapper;
-    if (cdChangingForm) {
-      o = ((CachedDeserializableValueWrapper) o).getValue();
-    }
-    if (o == null || o == Token.INVALID || o == Token.LOCAL_INVALID || o == Token.DESTROYED
-        || o == Token.TOMBSTONE) {
-      return 0;
-    }
-
-    int size;
-    // Shouldn't we defer to the user's object sizer for these things?
-    if (o instanceof byte[] || o instanceof String) {
-      size = ObjectSizer.DEFAULT.sizeof(o);
-    } else if (o instanceof Sizeable) {
-      size = ((Sizeable) o).getSizeInBytes();
-    } else if (sizer != null) {
-      size = sizer.sizeof(o);
-    } else {
-      size = ObjectSizer.DEFAULT.sizeof(o);
-    }
-    if (cdChangingForm) {
-      size += CachedDeserializableFactory.overhead();
-    }
-    return size;
-  }
-
-  public int getPerEntryOverhead() {
-    return perEntryOverHead;
-  }
-
-  @Override
-  public boolean equals(Object cc) {
-    if (!super.equals(cc))
-      return false;
-    MemoryLRUController other = (MemoryLRUController) cc;
-    if (this.limit != other.limit)
-      return false;
-    return true;
-  }
-
-  @Override
-  public int hashCode() {
-    int result = super.hashCode();
-    result += this.limit;
-    return result;
+  public boolean lruLimitExceeded(EvictionCounters counters, DiskRegionView diskRegionView) {
+    return counters.getCounter() > counters.getLimit();

MOV23 UPD40 MOV44 INS44 UPD83 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS65 UPD43 UPD42 INS43 INS42 MOV21 UPD43 UPD42 UPD43 UPD42 UPD66 INS42 UPD42 INS42 UPD42 UPD42 INS42 UPD42 UPD42 MOV22 INS32 INS42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL66 DEL66 DEL42 DEL65 DEL66 DEL66 DEL42 DEL65 DEL66 DEL66 DEL66 DEL42 DEL67 DEL65 DEL66 DEL66 DEL66 DEL66 DEL65 DEL66 DEL66 DEL66 DEL65 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL43 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL66 DEL65 DEL42 DEL67 DEL65 DEL29 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL23 DEL66 DEL42 DEL67 DEL66 DEL65 DEL66 DEL42 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL23 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL45 DEL45 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL45 DEL42 DEL45 DEL32 DEL42 DEL42 DEL45 DEL42 DEL45 DEL32 DEL42 DEL42 DEL45 DEL42 DEL45 DEL32 DEL42 DEL42 DEL45 DEL42 DEL45 DEL32 DEL42 DEL42 DEL45 DEL42 DEL45 DEL32 DEL42 DEL42 DEL45 DEL42 DEL45 DEL32 DEL42 DEL42 DEL45 DEL42 DEL45 DEL32 DEL4 DEL3 DEL32 DEL7 DEL21 DEL8 DEL28 DEL40 DEL36 DEL42 DEL27 DEL83 DEL39 DEL42 DEL42 DEL59 DEL23 DEL66 DEL66 DEL65 DEL66 DEL66 DEL65 DEL66 DEL42 DEL67 DEL65 DEL66 DEL42 DEL67 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL40 DEL42 DEL17 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL66 DEL66 DEL40 DEL42 DEL67 DEL65 DEL66 DEL66 DEL40 DEL42 DEL39 DEL69 DEL68 DEL66 DEL66 DEL65 DEL66 DEL40 DEL65 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL42 DEL17 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL66 DEL66 DEL40 DEL42 DEL67 DEL65 DEL66 DEL66 DEL40 DEL42 DEL39 DEL69 DEL68 DEL66 DEL66 DEL65 DEL66 DEL40 DEL65 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL40 DEL42 DEL9 DEL17 DEL8 DEL31 DEL66 DEL66 DEL66 DEL42 DEL67 DEL66 DEL65 DEL66 DEL66 DEL66 DEL42 DEL67 DEL66 DEL65 DEL66 DEL66 DEL66 DEL42 DEL67 DEL66 DEL65 DEL66 DEL42 DEL65 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL36 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL40 DEL42 DEL42 DEL32 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL36 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL36 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL52 DEL42 DEL22 DEL42 DEL36 DEL42 DEL33 DEL27 DEL8 DEL52 DEL42 DEL22 DEL33 DEL27 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL32 DEL21 DEL8 DEL25 DEL25 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL78 DEL83 DEL40 DEL43 DEL42 DEL40 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL52 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL45 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL32 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL32 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL32 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL32 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL32 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL32 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL32 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL83 DEL39 DEL42 DEL42 DEL42 DEL43 DEL62 DEL59 DEL60 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL40 DEL27 DEL27 DEL34 DEL41 DEL8 DEL25 DEL39 DEL42 DEL59 DEL60 DEL42 DEL39 DEL85 DEL5 DEL62 DEL42 DEL42 DEL43 DEL62 DEL27 DEL42 DEL40 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL40 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL25 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL48 DEL38 DEL9 DEL41 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL52 DEL42 DEL22 DEL40 DEL27 DEL9 DEL41 DEL25 DEL9 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL39 DEL42 DEL42 DEL48 DEL59 DEL60 DEL42 DEL52 DEL42 DEL22 DEL7 DEL21 DEL42 DEL41 DEL8 DEL31
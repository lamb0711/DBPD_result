Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import org.apache.geode.cache.query.types.*;
+import org.apache.geode.cache.query.types.*;
-//import org.apache.geode.cache.query.internal.types.TypeUtils;
+// import org.apache.geode.cache.query.internal.types.TypeUtils;
-public abstract class AbstractCompiledValue implements CompiledValue, Filter,
-    OQLLexerTokenTypes {
+public abstract class AbstractCompiledValue implements CompiledValue, Filter, OQLLexerTokenTypes {
-   * Asif : This function has a meaningful implementaion only in
-   * CompiledComparison & Compiled Undefined
+   * Asif : This function has a meaningful implementaion only in CompiledComparison & Compiled
+   * Undefined
-   
-  public SelectResults filterEvaluate(ExecutionContext context,
-      SelectResults iterationLimit, boolean completeExpansionNeeded,
-      CompiledValue iterOperands, RuntimeIterator[] indpndntItrs, boolean isIntersection, boolean conditioningNeeded, boolean evalProj)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
-    Support
-        .assertionFailed("This method should not have invoked as CompieldComparison & CompiledUndefined are the only classes on which this invocation should have occured ");
+
+  public SelectResults filterEvaluate(ExecutionContext context, SelectResults iterationLimit,
+      boolean completeExpansionNeeded, CompiledValue iterOperands, RuntimeIterator[] indpndntItrs,
+      boolean isIntersection, boolean conditioningNeeded, boolean evalProj)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
+    Support.assertionFailed(
+        "This method should not have invoked as CompieldComparison & CompiledUndefined are the only classes on which this invocation should have occured ");
-  public PlanInfo getPlanInfo(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  public PlanInfo getPlanInfo(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    //RuntimeIterator itr = context.getCurrentIterator();
-    //Support.Assert(itr != null);
+    // RuntimeIterator itr = context.getCurrentIterator();
+    // Support.Assert(itr != null);
-          throw new TypeMismatchException(LocalizedStrings.AbstractCompiledValue_BOOLEAN_VALUE_EXPECTED_NOT_TYPE_0.toLocalizedString(result.getClass().getName()));
+        throw new TypeMismatchException(
+            LocalizedStrings.AbstractCompiledValue_BOOLEAN_VALUE_EXPECTED_NOT_TYPE_0
+                .toLocalizedString(result.getClass().getName()));
-      throws TypeMismatchException, AmbiguousNameException,
-      NameResolutionException {
+      throws TypeMismatchException, AmbiguousNameException, NameResolutionException {
-  public boolean isDependentOnIterator(RuntimeIterator itr,
-      ExecutionContext context) {
+  public boolean isDependentOnIterator(RuntimeIterator itr, ExecutionContext context) {
-  protected PlanInfo protGetPlanInfo(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  protected PlanInfo protGetPlanInfo(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-   * return operator used when terms are reversed, maintaining the semantics e.g
-   * salary < 100000 swapped to 100000 > salary, salary >= 100000 swapped to
-   * 100000 <= salary or salary = 100000 swapped to salary = 100000
+   * return operator used when terms are reversed, maintaining the semantics e.g salary < 100000
+   * swapped to 100000 > salary, salary >= 100000 swapped to 100000 <= salary or salary = 100000
+   * swapped to salary = 100000
-   * return operator to invert the value of the result. e.g. salary < 100000
-   * will become salary >= 100000 or salary = 100000 becomes salary != 100000
+   * return operator to invert the value of the result. e.g. salary < 100000 will become salary >=
+   * 100000 or salary = 100000 becomes salary != 100000
-   * this is a lower level filter evaluation call. Most Filters do nothing
-   * different here than a normal filterEvaluate. This is here for benefit of
-   * nested CompiledJunctions: filterEvaluate is called first, then
-   * auxFilterEvaluate is called on the operands that have been organized to be
+   * this is a lower level filter evaluation call. Most Filters do nothing different here than a
+   * normal filterEvaluate. This is here for benefit of nested CompiledJunctions: filterEvaluate is
+   * called first, then auxFilterEvaluate is called on the operands that have been organized to be
-      SelectResults intermediateResults) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
+      SelectResults intermediateResults) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
-  public SelectResults filterEvaluate(ExecutionContext context,
-      SelectResults intermediateResults) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+  public SelectResults filterEvaluate(ExecutionContext context, SelectResults intermediateResults)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-    //RuntimeIterator itr = context.getCurrentIterator();
-    //Support.Assert(itr != null);
+    // RuntimeIterator itr = context.getCurrentIterator();
+    // Support.Assert(itr != null);
-        return new ResultsBag(intermediateResults.getCollectionType()
-            .getElementType(), 0, context.getCachePerfStats());
+      return new ResultsBag(intermediateResults.getCollectionType().getElementType(), 0,
+          context.getCachePerfStats());
-        throw new TypeMismatchException(LocalizedStrings.AbstractCompiledValue_BOOLEAN_VALUE_EXPECTED_NOT_TYPE_0.toLocalizedString(result.getClass().getName()));
+      throw new TypeMismatchException(
+          LocalizedStrings.AbstractCompiledValue_BOOLEAN_VALUE_EXPECTED_NOT_TYPE_0
+              .toLocalizedString(result.getClass().getName()));
-    //Asif : Boolean true, means the cartesian of all the RuntimeIterators
+    // Asif : Boolean true, means the cartesian of all the RuntimeIterators
-    }
-    else {
-      //Asif : We need to return either an empty ResultSet or an empty
+    } else {
+      // Asif : We need to return either an empty ResultSet or an empty
-        ObjectType elementType = ((RuntimeIterator) iterators.get(0))
-            .getElementType();
-        emptySet = context.isDistinct() ? new ResultsSet(elementType) :
-          new ResultsBag(elementType, 0,  context.getCachePerfStats());
-      }
-      else {
+        ObjectType elementType = ((RuntimeIterator) iterators.get(0)).getElementType();
+        emptySet = context.isDistinct() ? new ResultsSet(elementType)
+            : new ResultsBag(elementType, 0, context.getCachePerfStats());
+      } else {
-        :new StructBag(0, new StructTypeImpl(fieldNames, fieldTypes), context.getCachePerfStats());
+            : new StructBag(0, new StructTypeImpl(fieldNames, fieldTypes),
+                context.getCachePerfStats());
-  public void generateCanonicalizedExpression(StringBuffer clauseBuffer,
-      ExecutionContext context) throws AmbiguousNameException,
-      TypeMismatchException, NameResolutionException {
+  public void generateCanonicalizedExpression(StringBuffer clauseBuffer, ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-  
+
-    for (Iterator itr = getChildren().iterator(); itr.hasNext(); ) {
-      CompiledValue v = (CompiledValue)itr.next();
+    for (Iterator itr = getChildren().iterator(); itr.hasNext();) {
+      CompiledValue v = (CompiledValue) itr.next();
-        throw new NullPointerException(LocalizedStrings.AbstractCompiledValue_GOT_NULL_AS_A_CHILD_FROM_0.toLocalizedString(this));
+        throw new NullPointerException(
+            LocalizedStrings.AbstractCompiledValue_GOT_NULL_AS_A_CHILD_FROM_0
+                .toLocalizedString(this));
-  
+
-  public int getSizeEstimate(ExecutionContext context)throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException  {
-	  throw new UnsupportedOperationException("This method should not have been invoked");
+
+  public int getSizeEstimate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+    throw new UnsupportedOperationException("This method should not have been invoked");
+
-    for (Iterator itr = getChildren().iterator(); itr.hasNext(); ) {
-      if (!visitor.visit((CompiledValue)itr.next())) {
+    for (Iterator itr = getChildren().iterator(); itr.hasNext();) {
+      if (!visitor.visit((CompiledValue) itr.next())) {
-    
-  public boolean isProjectionEvaluationAPossibility(ExecutionContext context) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException
-  {
+
+  public boolean isProjectionEvaluationAPossibility(ExecutionContext context)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-  
-  public boolean isLimitApplicableAtIndexLevel(ExecutionContext context) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException  {
+
+  public boolean isLimitApplicableAtIndexLevel(ExecutionContext context)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-  
-  public boolean isOrderByApplicableAtIndexLevel(ExecutionContext context, String canonicalizedOrderByClause) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+
+  public boolean isOrderByApplicableAtIndexLevel(ExecutionContext context,
+      String canonicalizedOrderByClause) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
-  
-  public boolean isConditioningNeededForIndex(RuntimeIterator independentIter, ExecutionContext context,  boolean completeExpnsNeeded) throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+
+  public boolean isConditioningNeededForIndex(RuntimeIterator independentIter,
+      ExecutionContext context, boolean completeExpnsNeeded)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-  
+
-  
-  public boolean isBetterFilter(Filter comparedTo, ExecutionContext context, int thisSize)  throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+
+  public boolean isBetterFilter(Filter comparedTo, ExecutionContext context, int thisSize)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-      throw new UnsupportedOperationException("This method should not have been invoked");
+    throw new UnsupportedOperationException("This method should not have been invoked");

MOV26 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66
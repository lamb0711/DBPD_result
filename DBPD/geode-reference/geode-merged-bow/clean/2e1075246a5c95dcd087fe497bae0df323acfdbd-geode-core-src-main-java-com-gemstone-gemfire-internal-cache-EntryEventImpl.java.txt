Merge branch 'release/1.0.0-incubating.M3'

-import java.io.ByteArrayInputStream;
-import java.io.DataInput;
-import java.io.DataInputStream;
-import java.io.DataOutput;
-import java.io.IOException;
-
-import org.apache.logging.log4j.Logger;
-
-import com.gemstone.gemfire.CopyHelper;
-import com.gemstone.gemfire.DataSerializer;
-import com.gemstone.gemfire.DeltaSerializationException;
-import com.gemstone.gemfire.GemFireIOException;
-import com.gemstone.gemfire.InvalidDeltaException;
-import com.gemstone.gemfire.SerializationException;
-import com.gemstone.gemfire.SystemFailure;
-import com.gemstone.gemfire.cache.EntryEvent;
-import com.gemstone.gemfire.cache.EntryNotFoundException;
-import com.gemstone.gemfire.cache.EntryOperation;
-import com.gemstone.gemfire.cache.Operation;
-import com.gemstone.gemfire.cache.Region;
-import com.gemstone.gemfire.cache.SerializedCacheValue;
-import com.gemstone.gemfire.cache.TransactionId;
+import com.gemstone.gemfire.*;
+import com.gemstone.gemfire.cache.*;
-import com.gemstone.gemfire.cache.query.internal.IndexUpdater;
+import com.gemstone.gemfire.distributed.internal.DistributionConfig;
-import com.gemstone.gemfire.internal.Assert;
-import com.gemstone.gemfire.internal.ByteArrayDataInput;
-import com.gemstone.gemfire.internal.DSFIDFactory;
-import com.gemstone.gemfire.internal.DataSerializableFixedID;
-import com.gemstone.gemfire.internal.HeapDataOutputStream;
-import com.gemstone.gemfire.internal.InternalDataSerializer;
-import com.gemstone.gemfire.internal.Sendable;
-import com.gemstone.gemfire.internal.Version;
+import com.gemstone.gemfire.internal.*;
-import com.gemstone.gemfire.internal.cache.delta.Delta;
-import com.gemstone.gemfire.internal.offheap.OffHeapHelper;
-import com.gemstone.gemfire.internal.offheap.OffHeapRegionEntryHelper;
-import com.gemstone.gemfire.internal.offheap.ReferenceCountHelper;
-import com.gemstone.gemfire.internal.offheap.Releasable;
-import com.gemstone.gemfire.internal.offheap.StoredObject;
+import com.gemstone.gemfire.internal.offheap.*;
-
-import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_NEW_VALUE;
-import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_OLD_VALUE;
-
+import org.apache.logging.log4j.Logger;
+
+import java.io.*;
+
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_NEW_VALUE;
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_OLD_VALUE;
-  protected Delta delta = null;
-   * @since 5.0
+   * @since GemFire 5.0
-   * @since 8.1
+   * @since GemFire 8.1
-   * @since 5.0
+   * @since GemFire 5.0
-   * @since 5.1
+   * @since GemFire 5.1
-   * A custom context object that can be used for any other contextual
-   * information. Currently used by SQL Fabric to pass around evaluated rows
-   * from raw byte arrays and routing object.
-   */
-  private transient Object contextObj = null;
-
-  /**
-  /** boolean to indicate that this operation should be optimized by not fetching from HDFS*/
-  private transient boolean fetchFromHDFS = true;
-  
-  private transient boolean isPutDML = false;
-
-  /** boolean to indicate that the RegionEntry for this event was loaded from HDFS*/
-  private transient boolean loadedFromHDFS= false;
-  
-  private transient boolean isCustomEviction = false;
-  
-   * create a new entry event that will be used for conveying version information
-   * and anything else of use while processing another event
-   * @return the empty event object
-   */
-  @Retained
-  public static EntryEventImpl createVersionTagHolder() {
-    return createVersionTagHolder(null);
-  }
-  
-  /**
-   * create a new entry event that will be used for conveying version information
-   * and anything else of use while processing another event
-   * @return the empty event object
-   */
-  @Retained
-  public static EntryEventImpl createVersionTagHolder(VersionTag tag) {
-    EntryEventImpl result = new EntryEventImpl();
-    result.setVersionTag(tag);
-    result.disallowOffHeapValues();
-    return result;
-  }
-
-  /**
-      this.delta = (Delta)DataSerializer.readObject(in);
+      assert false : "isDelta should never be true";
-    if (newVal instanceof Delta) {
-      this.delta = (Delta)newVal;
-    }
-    else if (!Token.isInvalid(newVal)) {
+    if (!Token.isInvalid(newVal)) {
-    this.delta = other.delta;
-  
-  /**
-   * This constructor is used to create a bridge event in server-side
-   * command classes.  Events created with this are not intended to be
-   * used in cache operations.
-   * @param id the identity of the client's event
-   */
-  @Retained
-  public EntryEventImpl(EventID id) {
-    this.eventID = id;
-    this.offHeapOk = false;
-  }
-   * @since 5.0
+   * @since GemFire 5.0
-    EntryEventImpl e;
+    @Retained EntryEventImpl e;
+  @Retained
-    EntryEventImpl e;
+    @Retained EntryEventImpl e;
-  public final boolean isCustomEviction() {
-    return this.isCustomEviction;
-  }
-  
-  public final void setCustomEviction(boolean customEvict) {
-    this.isCustomEviction = customEvict;
-  }
-  
-        // TODO OFFHEAP: returns off-heap PdxInstance
-   * ALERT: If there is a Delta, returns that, not the (applied) new value.
-   * TODO OFFHEAP: to prevent the heap copy use getRawNewValue instead
+   * Note: to prevent the heap copy use getRawNewValue instead
-    if (this.delta != null) {
-      return this.delta;
-    }
-   * If new value is a Delta return it.
-   * Else if new value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). 
+   * If new value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). 
-    if (this.delta != null) return this.delta;
-  /**
-   * Returns the delta that represents the new value; null if no delta.
-   * @return the delta that represents the new value; null if no delta.
-   */
-  public final Delta getDeltaNewValue() {
-    return this.delta;
-  }
-
-  /**
-   *  Applies the delta 
-   */
-  private Object applyDeltaWithCopyOnRead(boolean doCopyOnRead) {
-    //try {
-      if (applyDelta(true)) {
-        Object applied = basicGetNewValue();
-        // if applyDelta returns true then newValue should not be off-heap
-        assert !(applied instanceof StoredObject);
-        if (applied == this.oldValue && doCopyOnRead) {
-          applied = CopyHelper.copy(applied);
-        }
-        return applied;
-      }
-    //} catch (EntryNotFoundException ex) {
-      // only (broken) product code has the opportunity to call this before
-      // this.oldValue is set. If oldValue is not set yet, then
-      // we most likely haven't synchronized on the region entry yet.
-      // (If we have, then make sure oldValue is set before
-      // calling this method).
-      //throw new AssertionError("too early to call getNewValue");
-    //}
-    return null;
-  }
-
-    try {
-      if (applyDelta(true)) {
-        @Unretained(ENTRY_EVENT_NEW_VALUE)
-        Object applied = basicGetNewValue();
-        if (applied == this.oldValue && doCopyOnRead) {
-          applied = CopyHelper.copy(applied);
-        }
-        return applied;
-      }
-    } catch (EntryNotFoundException ex) {
-      // only (broken) product code has the opportunity to call this before
-      // this.oldValue is set. If oldValue is not set yet, then
-      // we most likely haven't synchronized on the region entry yet.
-      // (If we have, then make sure oldValue is set before
-      // calling this method).
-      throw new AssertionError("too early to call getNewValue");
-    }
-      // TODO OFFHEAP currently we copy offheap new value to the heap here. Check callers of this method to see if they can be optimized to use offheap values.
-      // TODO OFFHEAP: returns off-heap PdxInstance
-  protected boolean applyDelta(boolean throwOnNullOldValue)
-      throws EntryNotFoundException {
-    if (this.newValue != null || this.delta == null) {
-      return false;
-    }
-    if (this.oldValue == null) {
-      if (throwOnNullOldValue) {
-        // !!!:ezoerner:20080611 It would be nice if the client got this
-        // exception
-        throw new EntryNotFoundException(
-            "Cannot apply a delta without an existing value");
-      }
-      return false;
-    }
-    // swizzle BucketRegion in event for Delta.
-    // !!!:ezoerner:20090602 this is way ugly; this whole class severely
-    // needs refactoring
-    LocalRegion originalRegion = this.region;
-    try {
-      if (originalRegion instanceof BucketRegion) {
-        this.region = ((BucketRegion)this.region).getPartitionedRegion();
-      }
-      basicSetNewValue(this.delta.apply(this));
-    } finally {
-      this.region = originalRegion;
-    }
-    return true;
-  }
-
-    if (obj instanceof Delta) {
-      this.delta = (Delta)obj;
-      basicSetNewValue(null);
-    }
-    else {
-      basicSetNewValue(obj);
-    }
+    basicSetNewValue(obj);
-   * @since 5.5 
+   * @since GemFire 5.5
-        // TODO OFFHEAP can we handle offheap byte[] better?
-      } else {
-      if (this.newValueBytes != null && this.newValue instanceof CachedDeserializable) {
+      } else if (this.newValueBytes != null && this.newValue instanceof CachedDeserializable) {
-      }
-      if (so.hasRefCount()) {
-        if (importer.isUnretainedNewReferenceOk()) {
-          importer.importNewObject(nv, isSerialized);
-        } else {
-          if (!isSerialized || prefersSerialized) {
-            byte[] bytes = so.getValueAsHeapByteArray();
-            importer.importNewBytes(bytes, isSerialized);
-            if (isSerialized) {
-              setCachedSerializedNewValue(bytes);
-            }
-          } else {
-            // TODO OFFHEAP: returns off-heap PdxInstance which is not ok since isUnretainedNewReferenceOk returned false
-            importer.importNewObject(so.getValueAsDeserializedHeapObject(), true);
-          }
+      if (importer.isUnretainedNewReferenceOk()) {
+        importer.importNewObject(nv, isSerialized);
+      } else if (!isSerialized || prefersSerialized) {
+        byte[] bytes = so.getValueAsHeapByteArray();
+        importer.importNewBytes(bytes, isSerialized);
+        if (isSerialized) {
+          setCachedSerializedNewValue(bytes);
-        importer.importNewObject(nv, isSerialized);
+        importer.importNewObject(so.getValueAsDeserializedHeapObject(), true);
-      if (so.hasRefCount()) {
-        if (importer.isUnretainedOldReferenceOk()) {
-          importer.importOldObject(ov, isSerialized);
-        } else {
-          if (!isSerialized || prefersSerialized) {
-            importer.importOldBytes(so.getValueAsHeapByteArray(), isSerialized);
-          } else {
-            // TODO OFFHEAP: returns off-heap PdxInstance which is not ok since isUnretainedNewReferenceOk returned false
-           importer.importOldObject(so.getValueAsDeserializedHeapObject(), true);
-          }
-        }
-      } else {
+      if (importer.isUnretainedOldReferenceOk()) {
+      } else if (!isSerialized || prefersSerialized) {
+        importer.importOldBytes(so.getValueAsHeapByteArray(), isSerialized);
+      } else {
+        importer.importOldObject(so.getValueAsDeserializedHeapObject(), true);
-      importer.importOldObject(ov, true);
+      importer.importOldObject(AbstractRegion.handleNotAvailable(ov), true);
-   * If applyDelta is true then first attempt to apply a delta (if we have one) and return the value.
-   * Else if new value is a Delta return it.
-   * Else if new value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). 
-   * Its refcount is not inced by this call and the returned object can only be safely used for the lifetime of the EntryEventImpl instance that returned the value.
-   * Else return the raw form.
-   */
-  @Unretained(ENTRY_EVENT_NEW_VALUE)
-  public final Object getRawNewValue(boolean applyDelta) {
-    if (applyDelta) {
-      boolean doCopyOnRead = getRegion().isCopyOnRead();
-      Object newValueWithDelta = applyDeltaWithCopyOnRead(doCopyOnRead);
-      if (newValueWithDelta != null) {
-        return newValueWithDelta;
-      }
-      // if applyDelta is true and we have already applied the delta then
-      // just return the applied value instead of the delta object.
-      @Unretained(ENTRY_EVENT_NEW_VALUE)
-      Object newValue = basicGetNewValue();
-      if (newValue != null) return newValue;
-    }
-    return getRawNewValue();
-  }
-  /**
-    Object result = getRawNewValue(true);
+    Object result = getRawNewValue();
-    if (this.delta == null) {
-    }
-    else {
-      return this.delta;
-    }
-      if (this.delta == null) {
-      }
-      else {
-        val = this.delta;
-      }
-   * @since 5.0.2
+   * @since GemFire 5.0.2
-    else if (obj == null && this.delta != null) {
-      // defer serialization until setNewValueInRegion
-      this.setSerializationDeferred(true);
-      return;
-    }
-                            || obj instanceof com.gemstone.gemfire.Delta
-                            || obj instanceof Delta) { // internal delta
+                            || obj instanceof com.gemstone.gemfire.Delta) { // internal delta
-    // avoid unneeded serialization of byte[][] used by SQLFabric that
+    // avoid unneeded serialization of byte[][] that
-      if (CachedDeserializableFactory.preferObject()) {
-        newVal = deserialize(serializedValue);
-      } else {
-        newVal = CachedDeserializableFactory.create(serializedValue);
-      }
-      if (newVal instanceof Delta) {
-        this.delta = (Delta)newVal;
-        newVal = null;
-        // We need the newValueBytes field and the newValue field to be in sync.
-        // In the case of non-null delta set both fields to null.
-        serializedValue = null;
-      }
+      newVal = CachedDeserializableFactory.create(serializedValue);
-    if (CachedDeserializableFactory.preferObject()) {
-      ov = deserialize(serializedOldValue);
-    }
-    else if (serializedOldValue != null) {
+    if (serializedOldValue != null) {
-  private static final boolean EVENT_OLD_VALUE = !Boolean.getBoolean("gemfire.disable-event-old-value");
+  private static final boolean EVENT_OLD_VALUE = !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "disable-event-old-value");
-            || GemFireCacheImpl.sqlfSystem()
-            if (GemFireCacheImpl.sqlfSystem()) {
-              ov = reentry.getValueOffHeapOrDiskWithoutFaultIn(this.region);
-            } else {
-              ov = reentry._getValueRetain(owner, true);
-            }
+            ov = reentry._getValueRetain(owner, true);
-            if (GemFireCacheImpl.sqlfSystem()) {
-              ov = reentry.getValueOffHeapOrDiskWithoutFaultIn(this.region);
-            } else {
-              ov = reentry._getValueRetain(owner, true);
-            }
+            ov = reentry._getValueRetain(owner, true);
-   * @since 5.0
+   * @since GemFire 5.0
-   * @since 5.0
+   * @since GemFire 5.0
-    if (applyDelta(this.op.isCreate())) {
-      if (this.isSerializationDeferred()) {
-        makeSerializedNewValue(true);
-      }
-    }
-
-    Object preparedV = reentry.prepareValueForCache(this.region, v, this, this.hasDelta());
+    Object preparedV = reentry.prepareValueForCache(this.region, v, this, false);
-    final IndexUpdater indexUpdater = this.region.getIndexUpdater();
-    if (indexUpdater != null) {
-      final LocalRegion indexRegion;
-      if (owner != null) {
-        indexRegion = owner;
-      }
-      else {
-        indexRegion = this.region;
-      }
-      try {
-        indexUpdater.onEvent(indexRegion, this, reentry);
-        calledSetValue = true;
-        reentry.setValueWithTombstoneCheck(v, this); // already called prepareValueForCache
-        success = true;
-      } finally {
-        indexUpdater.postEvent(indexRegion, this, reentry, success);
-      }
-    }
-    else {
-      calledSetValue = true;
-      reentry.setValueWithTombstoneCheck(v, this); // already called prepareValueForCache
-      success = true;
-    }
+    calledSetValue = true;
+    reentry.setValueWithTombstoneCheck(v, this); // already called prepareValueForCache
+    success = true;
-      } else if (this.delta != null) {
-        v = this.delta;
-      tx.setPendingValue(OffHeapHelper.copyIfNeeded(v)); // TODO OFFHEAP optimize
+      tx.setPendingValue(OffHeapHelper.copyIfNeeded(v));
-    if (tmp == null && hasDelta()) {
-      // ???:ezoerner:20080611 what if applying the delta would produce
-      // null or (strangely) NOT_AVAILABLE.. do we need to apply it here to
-      // find out?
-      return true;
-    }
-  /**
-   * This should only be used in case of internal delta and <B>not for Delta of
-   * Delta Propagation feature</B>.
-   * 
-   * @return boolean
-   */
-  public boolean hasDelta() {
-    return (this.delta != null);
-  }
-
+    buf.append(";region=");
+    buf.append(getRegion().getFullPath());
-      boolean isDelta = this.delta != null;
-      out.writeBoolean(isDelta);
-      if (isDelta) {
-        DataSerializer.writeObject(this.delta, out);
-      }
-      else {
+      out.writeBoolean(false);
+      {
-        // TODO OFFHEAP can we handle offheap byte[] better?
-    applyDelta(false);
-   * @since 5.7
+   * @since GemFire 5.7
-   * @since 5.7
+   * @since GemFire 5.7
-  public final void setContextObject(Object ctx) {
-    this.contextObj = ctx;
-  }
-
-  public final Object getContextObject() {
-    return this.contextObj;
-  }
-
-      // TODO OFFHEAP: returns off-heap PdxInstance
-      // TODO OFFHEAP: returns off-heap PdxInstance
-      // TODO OFFHEAP: returns off-heap PdxInstance
+  @Retained
-//    LocalRegion lr = getLocalRegion();
-//    if (lr != null) {
-//      if (lr.isCacheClosing()) {
-//        // to fix races during closing and recreating cache (see bug 47883) don't bother
-//        // trying to decrement reference counts if we are closing the cache.
-//        // TODO OFFHEAP: this will cause problems once offheap lives longer than a cache.
-//        this.offHeapOk = false;
-//        return;
-//      }
-//    }
-  public final boolean isFetchFromHDFS() {
-    return fetchFromHDFS;
-  }
-
-  public final void setFetchFromHDFS(boolean fetchFromHDFS) {
-    this.fetchFromHDFS = fetchFromHDFS;
-  }
-
-  public final boolean isPutDML() {
-    return this.isPutDML;
-  }
-
-  public final void setPutDML(boolean val) {
-    this.isPutDML = val;
-  }
-
-  public final boolean isLoadedFromHDFS() {
-    return loadedFromHDFS;
-  }
-
-  public final void setLoadedFromHDFS(boolean loadedFromHDFS) {
-    this.loadedFromHDFS = loadedFromHDFS;
-  }
-}
+}

MOV26 MOV26 MOV26 MOV26 MOV26 UPD40 UPD40 UPD40 UPD40 UPD40 UPD40 MOV78 MOV8 MOV8 MOV8 MOV8 MOV8 MOV78 MOV25 INS60 MOV60 MOV60 MOV25 MOV60 MOV25 MOV25 MOV25 MOV21 MOV25 MOV21 INS21 INS21 UPD66 UPD66 UPD66 UPD66 UPD66 MOV78 MOV43 MOV59 INS78 UPD66 UPD66 UPD66 INS42 MOV62 MOV25 MOV8 MOV43 MOV27 MOV8 UPD66 MOV27 MOV27 MOV27 UPD66 UPD66 MOV43 INS32 INS32 MOV8 UPD66 UPD66 INS6 INS42 INS25 MOV60 MOV60 INS25 MOV60 MOV60 INS25 MOV32 MOV60 MOV54 INS27 MOV32 MOV21 MOV21 MOV21 INS42 INS42 INS45 INS42 INS42 INS32 INS9 INS45 MOV27 MOV8 MOV25 MOV32 MOV8 MOV25 MOV32 MOV8 MOV25 INS40 INS45 MOV38 UPD42 INS42 INS52 INS9 MOV8 INS32 INS42 INS9 UPD42 MOV42 MOV25 INS42 MOV27 MOV8 MOV8 INS32 MOV60 INS25 MOV25 MOV21 MOV21 INS42 INS42 MOV42 MOV32 INS8 MOV8 MOV32 MOV21 INS21 MOV21 UPD42 MOV42 INS7 MOV42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS9 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL42 DEL43 DEL42 DEL33 DEL59 DEL23 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL33 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL33 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL42 DEL42 DEL43 DEL62 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL11 DEL7 DEL21 DEL8 DEL25 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL8 DEL31 DEL60 DEL83 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL52 DEL42 DEL22 DEL33 DEL27 DEL52 DEL42 DEL22 DEL41 DEL8 DEL25 DEL66 DEL52 DEL42 DEL22 DEL33 DEL27 DEL52 DEL42 DEL22 DEL41 DEL25 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL39 DEL42 DEL44 DEL42 DEL9 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL62 DEL36 DEL38 DEL6 DEL42 DEL52 DEL42 DEL22 DEL27 DEL42 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL25 DEL33 DEL41 DEL8 DEL31 DEL42 DEL9 DEL32 DEL42 DEL42 DEL79 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL52 DEL42 DEL22 DEL27 DEL42 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL12 DEL54 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL52 DEL42 DEL22 DEL33 DEL27 DEL52 DEL42 DEL22 DEL33 DEL27 DEL27 DEL9 DEL41 DEL8 DEL25 DEL52 DEL42 DEL22 DEL33 DEL27 DEL42 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL9 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL59 DEL60 DEL42 DEL42 DEL43 DEL62 DEL52 DEL42 DEL22 DEL42 DEL43 DEL52 DEL42 DEL22 DEL11 DEL36 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL32 DEL32 DEL21 DEL8 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL54 DEL9 DEL41 DEL8 DEL31 DEL42 DEL42 DEL43 DEL62 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL11 DEL7 DEL21 DEL42 DEL33 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL8 DEL25 DEL25 DEL8 DEL42 DEL42 DEL32 DEL25 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL42 DEL79 DEL83 DEL83 DEL42 DEL43 DEL42 DEL39 DEL42 DEL44 DEL42 DEL39 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL41 DEL8 DEL25 DEL42 DEL42 DEL79 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL41 DEL25 DEL8 DEL25 DEL41 DEL8 DEL31 DEL42 DEL9 DEL32 DEL52 DEL42 DEL22 DEL33 DEL27 DEL52 DEL42 DEL22 DEL41 DEL8 DEL25 DEL8 DEL52 DEL42 DEL22 DEL33 DEL27 DEL42 DEL22 DEL7 DEL21 DEL25 DEL8 DEL42 DEL33 DEL27 DEL52 DEL42 DEL22 DEL33 DEL27 DEL27 DEL52 DEL42 DEL9 DEL32 DEL21 DEL41 DEL8 DEL25 DEL42 DEL42 DEL43 DEL62 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL62 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL11 DEL7 DEL21 DEL42 DEL33 DEL7 DEL21 DEL42 DEL33 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL45 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL9 DEL32 DEL7 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL32 DEL7 DEL21 DEL8 DEL8 DEL25 DEL25 DEL8 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL32 DEL52 DEL42 DEL32 DEL42 DEL9 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL52 DEL42 DEL32 DEL32 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL83 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL42 DEL52 DEL42 DEL22 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL52 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL52 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL52 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL52 DEL42 DEL22 DEL33 DEL27 DEL42 DEL52 DEL42 DEL22 DEL7 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL32 DEL27 DEL9 DEL41 DEL8 DEL25 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL33 DEL27 DEL36 DEL41 DEL8 DEL31 DEL39 DEL42 DEL52 DEL42 DEL22 DEL33 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL9 DEL32 DEL21 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31
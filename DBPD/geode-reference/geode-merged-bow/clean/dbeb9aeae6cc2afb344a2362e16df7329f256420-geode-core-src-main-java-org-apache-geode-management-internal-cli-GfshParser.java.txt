Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import java.lang.reflect.InvocationTargetException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.TreeMap;
-import java.util.TreeSet;
-import java.util.logging.Logger;
-import java.util.regex.Pattern;
-
-import org.springframework.shell.core.AbstractShell;
-import org.springframework.shell.core.Completion;
-import org.springframework.shell.core.Converter;
-import org.springframework.shell.core.MethodTarget;
-import org.springframework.shell.core.Parser;
-import org.springframework.shell.event.ParseResult;
-
+import org.springframework.shell.core.AbstractShell;
+import org.springframework.shell.core.Completion;
+import org.springframework.shell.core.Converter;
+import org.springframework.shell.core.MethodTarget;
+import org.springframework.shell.core.Parser;
+import org.springframework.shell.event.ParseResult;
+
+import java.lang.reflect.InvocationTargetException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.TreeSet;
+import java.util.logging.Logger;
+import java.util.regex.Pattern;
- * Implementation of the {@link Parser} interface for GemFire SHell (gfsh)
- * requirements.
+ * Implementation of the {@link Parser} interface for GemFire SHell (gfsh) requirements.
-   * Populates a list of completion candidates. See
-   * {@link Parser#complete(String, int, List)} for details.
+   * Populates a list of completion candidates. See {@link Parser#complete(String, int, List)} for
+   * details.
-    if (cursor <= buffer.length() - 1 && !PreprocessorUtils.containsOnlyWhiteSpaces(buffer.substring(cursor)) || (ParserUtils
-                                                                                                                    .contains(buffer, SyntaxConstants.COMMAND_DELIMITER))) {
+    if (cursor <= buffer.length() - 1
+        && !PreprocessorUtils.containsOnlyWhiteSpaces(buffer.substring(cursor))
+        || (ParserUtils.contains(buffer, SyntaxConstants.COMMAND_DELIMITER))) {
-        String padding = desiredCursorPosition != 0 ? ParserUtils.getPadding(desiredCursorPosition) : "";
+        String padding =
+            desiredCursorPosition != 0 ? ParserUtils.getPadding(desiredCursorPosition) : "";
-          completionCandidates.add(new Completion(padding + commandTarget.getGfshMethodTarget().getKey()));
+          completionCandidates
+              .add(new Completion(padding + commandTarget.getGfshMethodTarget().getKey()));
-          if (simpleTrim.getString().length() >= commandTarget.getGfshMethodTarget().getKey().length()) {
+          if (simpleTrim.getString().length() >= commandTarget.getGfshMethodTarget().getKey()
+              .length()) {
-            return completeParameters(commandTarget, desiredCursorPosition + commandTarget.getGfshMethodTarget()
-                                                                                          .getKey()
-                                                                                          .length(), commandTarget.getGfshMethodTarget()
-                                                                                                                  .getRemainingBuffer(), cursor, completionCandidates);
+            return completeParameters(commandTarget,
+                desiredCursorPosition + commandTarget.getGfshMethodTarget().getKey().length(),
+                commandTarget.getGfshMethodTarget().getRemainingBuffer(), cursor,
+                completionCandidates);
-             * updateCompletionCandidates(completionCandidates, buffer,
-             * position); return 0;
+             * updateCompletionCandidates(completionCandidates, buffer, position); return 0;
-            String padding = desiredCursorPosition != 0 ? ParserUtils.getPadding(desiredCursorPosition) : "";
+            String padding =
+                desiredCursorPosition != 0 ? ParserUtils.getPadding(desiredCursorPosition) : "";
-            completionCandidates.add(new Completion(padding + commandTarget.getGfshMethodTarget().getKey()));
+            completionCandidates
+                .add(new Completion(padding + commandTarget.getGfshMethodTarget().getKey()));
-  private void updateCompletionCandidates(List<Completion> completionCandidates, String buffer, int position) {
+  private void updateCompletionCandidates(List<Completion> completionCandidates, String buffer,
+      int position) {
-      completionCandidates.add(new Completion(buffer.substring(0, position) + completion.getValue(), completion.getFormattedValue(), completion
-        .getHeading(), completion.getOrder()));
+      completionCandidates.add(new Completion(buffer.substring(0, position) + completion.getValue(),
+          completion.getFormattedValue(), completion.getHeading(), completion.getOrder()));
-  private int completeParameters(CommandTarget commandTarget,
-                                 int cursorStart,
-                                 String remainingBuffer,
-                                 int cursor,
-                                 List<Completion> completionCandidates) {
+  private int completeParameters(CommandTarget commandTarget, int cursorStart,
+      String remainingBuffer, int cursor, List<Completion> completionCandidates) {
-            if (getAllPossibleValuesForParameter(completionCandidates, argument, userOptionSet.getValue(argument), commandTarget
-              .getGfshMethodTarget())) {
+            if (getAllPossibleValuesForParameter(completionCandidates, argument,
+                userOptionSet.getValue(argument), commandTarget.getGfshMethodTarget())) {
-                  modifyCompletionCandidates(completionCandidates, argumentSeparator, userOptionSet.getValue(argument));
+                  modifyCompletionCandidates(completionCandidates, argumentSeparator,
+                      userOptionSet.getValue(argument));
-              desiredCursorPosition += userOptionSet.getValue(argument).length() + argumentSeparator.length();
+              desiredCursorPosition +=
+                  userOptionSet.getValue(argument).length() + argumentSeparator.length();
-              if (getAllPossibleValuesForParameter(completionCandidates, argument, null, commandTarget.getGfshMethodTarget())) {
+              if (getAllPossibleValuesForParameter(completionCandidates, argument, null,
+                  commandTarget.getGfshMethodTarget())) {
-              if (endsWithOptionSpecifiers(userOptionSet.getUserInput()) || hasOptionSpecified(userOptionSet.getUserInput())) {
+              if (endsWithOptionSpecifiers(userOptionSet.getUserInput())
+                  || hasOptionSpecified(userOptionSet.getUserInput())) {
-                getAllPossibleValuesForParameter(completionCandidates, argument, null, commandTarget.getGfshMethodTarget());
+                getAllPossibleValuesForParameter(completionCandidates, argument, null,
+                    commandTarget.getGfshMethodTarget());
-            String argMessage = argument.getArgumentName() + ((argument.getHelp() != null && !argument.getHelp()
-                                                                                                      .equals("")) ? ": " + argument
-              .getHelp() : "");
-            logWarning(CliStrings.format(CliStrings.GFSHPARSER__MSG__REQUIRED_ARGUMENT_0, argMessage));
+            String argMessage = argument.getArgumentName()
+                + ((argument.getHelp() != null && !argument.getHelp().equals(""))
+                    ? ": " + argument.getHelp() : "");
+            logWarning(
+                CliStrings.format(CliStrings.GFSHPARSER__MSG__REQUIRED_ARGUMENT_0, argMessage));
-                  desiredCursorPosition += /* space */1 + SyntaxConstants.LONG_OPTION_SPECIFIER.length() + option.getLongOption()
-                                                                                                                 .length();
+                  desiredCursorPosition +=
+                      /* space */1 + SyntaxConstants.LONG_OPTION_SPECIFIER.length()
+                          + option.getLongOption().length();
-                      desiredCursorPosition += /* space */1 + SyntaxConstants.LONG_OPTION_SPECIFIER.length() + optionSynonym
-                        .length();
+                      desiredCursorPosition += /* space */1
+                          + SyntaxConstants.LONG_OPTION_SPECIFIER.length() + optionSynonym.length();
-              if (userOptionElement.equals(value) || (userOptionElement).equals(value + valueSeparator)) {
+              if (userOptionElement.equals(value)
+                  || (userOptionElement).equals(value + valueSeparator)) {
-              if (!endsWithOptionSpecifiers(userOptionSet.getUserInput()) && getAllPossibleValuesForParameter(completionCandidates, option, value, commandTarget
-                .getGfshMethodTarget())) {
+              if (!endsWithOptionSpecifiers(userOptionSet.getUserInput())
+                  && getAllPossibleValuesForParameter(completionCandidates, option, value,
+                      commandTarget.getGfshMethodTarget())) {
-                modifyCompletionCandidates(completionCandidates, prefix, bufferEndsWithValueSeparator, split);
+                modifyCompletionCandidates(completionCandidates, prefix,
+                    bufferEndsWithValueSeparator, split);
-            //                value would be:  cmd --opt1=val1,val2  ---> not there's no comma in the end.
-            // This doesn't give us the real last index of valueSeparator, hence add extra valueSeparator.
-            lastIndexOf = ParserUtils.lastIndexOf(bufferEndsWithValueSeparator ? value + valueSeparator : value, valueSeparator);
-            lengthToBeAdded = value.substring(0, (lastIndexOf > 0 ? lastIndexOf : value.length())).length();
+            // value would be: cmd --opt1=val1,val2 ---> not there's no comma in the end.
+            // This doesn't give us the real last index of valueSeparator, hence add extra
+            // valueSeparator.
+            lastIndexOf = ParserUtils.lastIndexOf(
+                bufferEndsWithValueSeparator ? value + valueSeparator : value, valueSeparator);
+            lengthToBeAdded =
+                value.substring(0, (lastIndexOf > 0 ? lastIndexOf : value.length())).length();
-              desiredCursorPosition += /* value specifier length */SyntaxConstants.OPTION_VALUE_SPECIFIER.length() + lengthToBeAdded + ((considerLastValue) ? value
-                                                                                                                                                                .length() - lengthToBeAdded : 0);
+              desiredCursorPosition +=
+                  /* value specifier length */SyntaxConstants.OPTION_VALUE_SPECIFIER.length()
+                      + lengthToBeAdded
+                      + ((considerLastValue) ? value.length() - lengthToBeAdded : 0);
-              if (getAllPossibleValuesForParameter(completionCandidates, option, null, commandTarget.getGfshMethodTarget())) {
+              if (getAllPossibleValuesForParameter(completionCandidates, option, null,
+                  commandTarget.getGfshMethodTarget())) {
-                  modifyCompletionCandidates(completionCandidates, SyntaxConstants.OPTION_VALUE_SPECIFIER, new String[] {
-                    null
-                  });
+                  modifyCompletionCandidates(completionCandidates,
+                      SyntaxConstants.OPTION_VALUE_SPECIFIER, new String[] {null});
-              userOptString = StringUtils.removeStart(userOptString, SyntaxConstants.LONG_OPTION_SPECIFIER);
-              if (option.getLongOption()
-                        .startsWith(userOptString) && !userOptString.equals("") && !option.getLongOption()
-                                                                                          .equals(userOptString) && !optionsPresentMap
-                .containsKey(userOptString)) {
+              userOptString =
+                  StringUtils.removeStart(userOptString, SyntaxConstants.LONG_OPTION_SPECIFIER);
+              if (option.getLongOption().startsWith(userOptString) && !userOptString.equals("")
+                  && !option.getLongOption().equals(userOptString)
+                  && !optionsPresentMap.containsKey(userOptString)) {
-                completionCandidates.add(new Completion(" " + SyntaxConstants.LONG_OPTION_SPECIFIER + option.getLongOption(), option
-                  .getLongOption(), "", 0));
+                completionCandidates.add(new Completion(
+                    " " + SyntaxConstants.LONG_OPTION_SPECIFIER + option.getLongOption(),
+                    option.getLongOption(), "", 0));
-                  if (optionSynonym.startsWith(userOptString) && !userOptString.equals("") && !optionSynonym.equals(userOptString)) {
-                    completionCandidates.add(new Completion(" " + SyntaxConstants.LONG_OPTION_SPECIFIER + optionSynonym, optionSynonym, "", 0));
+                  if (optionSynonym.startsWith(userOptString) && !userOptString.equals("")
+                      && !optionSynonym.equals(userOptString)) {
+                    completionCandidates.add(
+                        new Completion(" " + SyntaxConstants.LONG_OPTION_SPECIFIER + optionSynonym,
+                            optionSynonym, "", 0));
-        String optionMsg = warningOption.getLongOption() + ((warningOption.getHelp() != null && !warningOption.getHelp()
-                                                                                                              .equals("")) ? ": " + warningOption
-          .getHelp() : "");
-        logWarning(CliStrings.format(CliStrings.GFSHPARSER__MSG__VALUE_REQUIRED_FOR_OPTION_0, optionMsg));
+        String optionMsg = warningOption.getLongOption()
+            + ((warningOption.getHelp() != null && !warningOption.getHelp().equals(""))
+                ? ": " + warningOption.getHelp() : "");
+        logWarning(
+            CliStrings.format(CliStrings.GFSHPARSER__MSG__VALUE_REQUIRED_FOR_OPTION_0, optionMsg));
-        completionCandidates.add(new Completion(SyntaxConstants.OPTION_VALUE_SPECIFIER, "", null, 0));
+        completionCandidates
+            .add(new Completion(SyntaxConstants.OPTION_VALUE_SPECIFIER, "", null, 0));
-    int newCursor = desiredCursorPosition + ((userOptionSet != null) ? userOptionSet.getNoOfSpacesRemoved() : 0);
+    int newCursor = desiredCursorPosition
+        + ((userOptionSet != null) ? userOptionSet.getNoOfSpacesRemoved() : 0);
-      && newCursor < cursor // newCursorIsEarlierThanCursor
-      && completionCandidates.size() == 0 // zeroCompletionCandidates
-      &&!(PreprocessorUtils.containsOnlyWhiteSpaces(subString) // onlyHasWhiteSpaces
-        || ((subString.endsWith(SyntaxConstants.LONG_OPTION_SPECIFIER) && subString.startsWith(SyntaxConstants.LONG_OPTION_SPECIFIER)) // isHypenHyphen
-        || (subString.startsWith(SyntaxConstants.SHORT_OPTION_SPECIFIER) && subString.endsWith(SyntaxConstants.SHORT_OPTION_SPECIFIER))))) { // isHyphen
+        && newCursor < cursor // newCursorIsEarlierThanCursor
+        && completionCandidates.size() == 0 // zeroCompletionCandidates
+        && !(PreprocessorUtils.containsOnlyWhiteSpaces(subString) // onlyHasWhiteSpaces
+            || ((subString.endsWith(SyntaxConstants.LONG_OPTION_SPECIFIER)
+                && subString.startsWith(SyntaxConstants.LONG_OPTION_SPECIFIER)) // isHypenHyphen
+                || (subString.startsWith(SyntaxConstants.SHORT_OPTION_SPECIFIER)
+                    && subString.endsWith(SyntaxConstants.SHORT_OPTION_SPECIFIER))))) { // isHyphen
-          completionCandidates.add(new Completion(" " + SyntaxConstants.LONG_OPTION_SPECIFIER + option.getLongOption(), option
-            .getLongOption(), "", 0));
+          completionCandidates.add(
+              new Completion(" " + SyntaxConstants.LONG_OPTION_SPECIFIER + option.getLongOption(),
+                  option.getLongOption(), "", 0));
-        unspecifiedOptions = getUnspecifiedOptionsWithMode(unspecifiedOptions, commandTarget, optionsPresentMap);
+        unspecifiedOptions =
+            getUnspecifiedOptionsWithMode(unspecifiedOptions, commandTarget, optionsPresentMap);
-          completionCandidates.add(new Completion(" " + SyntaxConstants.LONG_OPTION_SPECIFIER + option.getLongOption(), option
-            .getLongOption(), "", 0));
+          completionCandidates.add(
+              new Completion(" " + SyntaxConstants.LONG_OPTION_SPECIFIER + option.getLongOption(),
+                  option.getLongOption(), "", 0));
-                                                     CommandTarget commandTarget,
-                                                     Map<String, Option> optionsPresentMap) {
+      CommandTarget commandTarget, Map<String, Option> optionsPresentMap) {
-    Collection<CommandMode> cmodes = CommandModes.getInstance().getCommandModes(commandTarget.getCommandName());
+    Collection<CommandMode> cmodes =
+        CommandModes.getInstance().getCommandModes(commandTarget.getCommandName());
-      //Populate with default options
+      // Populate with default options
-                                            .getCommandMode(commandTarget.getCommandName(), CommandModes.DEFAULT_MODE);
+          .getCommandMode(commandTarget.getCommandName(), CommandModes.DEFAULT_MODE);
-      //Now add options only for detected command mode
+      // Now add options only for detected command mode
-        //Here return only lead-option of the command-modes
+        // Here return only lead-option of the command-modes
-  private void checkOptionSetForValidCommandModes(OptionSet userOptionSet, CommandTarget commandTarget)
-    throws CliCommandMultiModeOptionException {
+  private void checkOptionSetForValidCommandModes(OptionSet userOptionSet,
+      CommandTarget commandTarget) throws CliCommandMultiModeOptionException {
-      CommandMode defaultMode = modes.getCommandMode(commandTarget.getCommandName(), CommandModes.DEFAULT_MODE);
+      CommandMode defaultMode =
+          modes.getCommandMode(commandTarget.getCommandName(), CommandModes.DEFAULT_MODE);
-          throw new CliCommandMultiModeOptionException(commandTarget, userOptions.get(cmd.leadOption), sb.toString(), CliCommandMultiModeOptionException.MULTIPLE_LEAD_OPTIONS);
+          throw new CliCommandMultiModeOptionException(commandTarget,
+              userOptions.get(cmd.leadOption), sb.toString(),
+              CliCommandMultiModeOptionException.MULTIPLE_LEAD_OPTIONS);
-          //Check only for non-default options, default options are allowed with any other mode
+          // Check only for non-default options, default options are allowed with any other mode
-                throw new CliCommandMultiModeOptionException(commandTarget, opt, opt.getLongOption(), CliCommandMultiModeOptionException.OPTIONS_FROM_MULTIPLE_MODES);
+                throw new CliCommandMultiModeOptionException(commandTarget, opt,
+                    opt.getLongOption(),
+                    CliCommandMultiModeOptionException.OPTIONS_FROM_MULTIPLE_MODES);
-    if (userInput.endsWith(" " + SyntaxConstants.LONG_OPTION_SPECIFIER) || userInput.endsWith(" " + SyntaxConstants.SHORT_OPTION_SPECIFIER)) {
+    if (userInput.endsWith(" " + SyntaxConstants.LONG_OPTION_SPECIFIER)
+        || userInput.endsWith(" " + SyntaxConstants.SHORT_OPTION_SPECIFIER)) {
-   * Verifies whether the userInput has any one of the following:
-   * --some-opt
-   * --s
-   * --some-opt=some-val --something-else
+   * Verifies whether the userInput has any one of the following: --some-opt --s --some-opt=some-val
+   * --something-else
-      //TODO fetch from system properties
+      // TODO fetch from system properties
-  private void modifyCompletionCandidates(List<Completion> completionCandidates,
-                                          String prefix,
-                                          String... existingData) {
+  private void modifyCompletionCandidates(List<Completion> completionCandidates, String prefix,
+      String... existingData) {
-  private void modifyCompletionCandidates(List<Completion> completionCandidates,
-                                          String prefix,
-                                          boolean endsWithValueSeparator,
-                                          String... existingData) {
+  private void modifyCompletionCandidates(List<Completion> completionCandidates, String prefix,
+      boolean endsWithValueSeparator, String... existingData) {
-          if (existingData[existingData.length - 1] != null && (!value.startsWith(existingData[existingData.length - 1]) && !endsWithValueSeparator)) {
+          if (existingData[existingData.length - 1] != null
+              && (!value.startsWith(existingData[existingData.length - 1])
+                  && !endsWithValueSeparator)) {
-        completionCandidates.add(new Completion(prefix + completion.getValue(), completion.getValue(), "", 0));
+        completionCandidates
+            .add(new Completion(prefix + completion.getValue(), completion.getValue(), "", 0));
-  @SuppressWarnings({ "rawtypes", "unchecked" })
+  @SuppressWarnings({"rawtypes", "unchecked"})
-                                                   Parameter parameter,
-                                                   String existingData,
-                                                   GfshMethodTarget gfshMethodTarget) {
+      Parameter parameter, String existingData, GfshMethodTarget gfshMethodTarget) {
-      parameter.setConverter(commandManager.getConverter(parameter.getDataType(), parameter.getContext()));
+      parameter.setConverter(
+          commandManager.getConverter(parameter.getDataType(), parameter.getContext()));
-        ((MultipleValueConverter) converter).getAllPossibleValues(completionCandidates, parameter.getDataType(), ParserUtils
-          .splitValues(existingData, valueSeparator), parameter.getContext(), new MethodTarget(gfshMethodTarget.getMethod(), gfshMethodTarget
-          .getTarget(), gfshMethodTarget.getRemainingBuffer(), gfshMethodTarget.getKey()));
+        ((MultipleValueConverter) converter).getAllPossibleValues(completionCandidates,
+            parameter.getDataType(), ParserUtils.splitValues(existingData, valueSeparator),
+            parameter.getContext(),
+            new MethodTarget(gfshMethodTarget.getMethod(), gfshMethodTarget.getTarget(),
+                gfshMethodTarget.getRemainingBuffer(), gfshMethodTarget.getKey()));
-        converter.getAllPossibleValues(completionCandidates, parameter.getDataType(), existingData, parameter.getContext(), new MethodTarget(gfshMethodTarget
-          .getMethod(), gfshMethodTarget.getTarget(), gfshMethodTarget.getRemainingBuffer(), gfshMethodTarget.getKey()));
+        converter.getAllPossibleValues(completionCandidates, parameter.getDataType(), existingData,
+            parameter.getContext(),
+            new MethodTarget(gfshMethodTarget.getMethod(), gfshMethodTarget.getTarget(),
+                gfshMethodTarget.getRemainingBuffer(), gfshMethodTarget.getKey()));
-    if ((ParserUtils.contains(userInput, SyntaxConstants.COMMAND_DELIMITER) && StringUtils.endsWithIgnoreCase(userInput, SyntaxConstants.COMMAND_DELIMITER))) {
+    if ((ParserUtils.contains(userInput, SyntaxConstants.COMMAND_DELIMITER)
+        && StringUtils.endsWithIgnoreCase(userInput, SyntaxConstants.COMMAND_DELIMITER))) {
-          handleCondition(CliStrings.format(CliStrings.GFSHPARSER__MSG__AMBIGIOUS_COMMAND_0_FOR_ASSISTANCE_USE_1_OR_HINT_HELP, new Object[] {
-            userInput, AbstractShell.completionKeys
-          }), CommandProcessingException.COMMAND_NAME_AMBIGUOUS, userInput);
+          handleCondition(
+              CliStrings.format(
+                  CliStrings.GFSHPARSER__MSG__AMBIGIOUS_COMMAND_0_FOR_ASSISTANCE_USE_1_OR_HINT_HELP,
+                  new Object[] {userInput, AbstractShell.completionKeys}),
+              CommandProcessingException.COMMAND_NAME_AMBIGUOUS, userInput);
-
-            parseResult = new GfshParseResult(gfshMethodTarget.getMethod(), gfshMethodTarget.getTarget(), methodParameters, userInput, commandTarget
-              .getCommandName(), paramValMap);
+            parseResult =
+                new GfshParseResult(gfshMethodTarget.getMethod(), gfshMethodTarget.getTarget(),
+                    methodParameters, userInput, commandTarget.getCommandName(), paramValMap);
-              ExceptionHandler.handleException(coe); // TODO: this eats exception that would make it easier to debug GemfireDataCommandsDUnitTest
+              ExceptionHandler.handleException(coe); // TODO: this eats exception that would make it
+                                                     // easier to debug GemfireDataCommandsDUnitTest
-                handleCondition(CliStrings.format(CliStrings.GFSHPARSER__MSG__INVALID_COMMAND_STRING_0, userInput), coe, CommandProcessingException.COMMAND_INVALID, userInput);
+                handleCondition(CliStrings
+                    .format(CliStrings.GFSHPARSER__MSG__INVALID_COMMAND_STRING_0, userInput), coe,
+                    CommandProcessingException.COMMAND_INVALID, userInput);
-          String message = CliStrings.format(CliStrings.GFSHPARSER__MSG__COMMAND_0_IS_NOT_VALID, userInput);
+          String message =
+              CliStrings.format(CliStrings.GFSHPARSER__MSG__COMMAND_0_IS_NOT_VALID, userInput);
-            message = CliStrings.format(CliStrings.GFSHPARSER__MSG__0_IS_NOT_AVAILABLE_REASON_1, new Object[] {
-              commandName, availabilityIndicator.getAvailabilityDescription()
-            });
+            message = CliStrings.format(CliStrings.GFSHPARSER__MSG__0_IS_NOT_AVAILABLE_REASON_1,
+                new Object[] {commandName, availabilityIndicator.getAvailabilityDescription()});
-          handleCondition(message, CommandProcessingException.COMMAND_INVALID_OR_UNAVAILABLE, userInput);
+          handleCondition(message, CommandProcessingException.COMMAND_INVALID_OR_UNAVAILABLE,
+              userInput);
-        argument.setConverter(commandManager.getConverter(argument.getDataType(), argument.getContext()));
+        argument.setConverter(
+            commandManager.getConverter(argument.getDataType(), argument.getContext()));
-  private boolean processOptions(OptionSet parse,
-                                 CommandTarget commandTarget,
-                                 Map<String, String> paramValMap,
-                                 List<MethodParameter> parameters,
-                                 boolean errorState) {
+  private boolean processOptions(OptionSet parse, CommandTarget commandTarget,
+      Map<String, String> paramValMap, List<MethodParameter> parameters, boolean errorState) {
-          handleCondition(CliStrings.format(CliStrings.GFSHPARSER__MSG__VALUE_REQUIRED_FOR_OPTION_0, option.getLongOption()), CommandProcessingException.OPTION_VALUE_REQUIRED, option
-            .getLongOption());
+          handleCondition(
+              CliStrings.format(CliStrings.GFSHPARSER__MSG__VALUE_REQUIRED_FOR_OPTION_0,
+                  option.getLongOption()),
+              CommandProcessingException.OPTION_VALUE_REQUIRED, option.getLongOption());
-          handleCondition(CliStrings.format(CliStrings.GFSHPARSER__MSG__COMMAND_OPTION_0_IS_REQUIRED_USE_HELP, option.getLongOption()), CommandProcessingException.REQUIRED_OPTION_MISSING, option
-            .getLongOption());
+          handleCondition(
+              CliStrings.format(CliStrings.GFSHPARSER__MSG__COMMAND_OPTION_0_IS_REQUIRED_USE_HELP,
+                  option.getLongOption()),
+              CommandProcessingException.REQUIRED_OPTION_MISSING, option.getLongOption());
-      Object object = getConversionObject(option.getConverter(), value, option.getDataType(), option.getContext(), valueSeparator);
+      Object object = getConversionObject(option.getConverter(), value, option.getDataType(),
+          option.getContext(), valueSeparator);
-        handleCondition(CliStrings.format(CliStrings.GFSHPARSER__MSG__VALUE_0_IS_NOT_APPLICABLE_FOR_1, new Object[] {
-          value.trim(),
-          option.getLongOption()
-        }), CommandProcessingException.OPTION_VALUE_INVALID, option.getLongOption() + "=" + value);
-        logWrapper.fine("Value \"" + value.trim() + "\" is not applicable for " + option.getLongOption());
+        handleCondition(
+            CliStrings.format(CliStrings.GFSHPARSER__MSG__VALUE_0_IS_NOT_APPLICABLE_FOR_1,
+                new Object[] {value.trim(), option.getLongOption()}),
+            CommandProcessingException.OPTION_VALUE_INVALID, option.getLongOption() + "=" + value);
+        logWrapper
+            .fine("Value \"" + value.trim() + "\" is not applicable for " + option.getLongOption());
-  private boolean processArguments(OptionSet parse,
-                                   CommandTarget commandTarget,
-                                   Map<String, String> paramValMap,
-                                   List<MethodParameter> parameters,
-                                   boolean errorState) {
+  private boolean processArguments(OptionSet parse, CommandTarget commandTarget,
+      Map<String, String> paramValMap, List<MethodParameter> parameters, boolean errorState) {
-          handleCondition(CliStrings.format(CliStrings.GFSHPARSER__MSG__COMMAND_ARGUMENT_0_IS_REQUIRED_USE_HELP, argument
-            .getArgumentName()), CommandProcessingException.REQUIRED_ARGUMENT_MISSING, argument.getArgumentName());
+          handleCondition(
+              CliStrings.format(CliStrings.GFSHPARSER__MSG__COMMAND_ARGUMENT_0_IS_REQUIRED_USE_HELP,
+                  argument.getArgumentName()),
+              CommandProcessingException.REQUIRED_ARGUMENT_MISSING, argument.getArgumentName());
-      Object conversionObject = getConversionObject(argument.getConverter(), value, argument.getDataType(), argument.getContext(), SyntaxConstants.VALUE_SEPARATOR);
+      Object conversionObject = getConversionObject(argument.getConverter(), value,
+          argument.getDataType(), argument.getContext(), SyntaxConstants.VALUE_SEPARATOR);
-        handleCondition(CliStrings.format(CliStrings.GFSHPARSER__MSG__VALUE_0_IS_NOT_APPLICABLE_FOR_1, new Object[] {
-          value.trim(),
-          argument.getArgumentName()
-        }), CommandProcessingException.ARGUMENT_INVALID, argument.getArgumentName() + "=" + value);
-        logWrapper.fine("Value '" + value.trim() + "' not applicable for argument: " + argument.getArgumentName());
+        handleCondition(
+            CliStrings.format(CliStrings.GFSHPARSER__MSG__VALUE_0_IS_NOT_APPLICABLE_FOR_1,
+                new Object[] {value.trim(), argument.getArgumentName()}),
+            CommandProcessingException.ARGUMENT_INVALID, argument.getArgumentName() + "=" + value);
+        logWrapper.fine("Value '" + value.trim() + "' not applicable for argument: "
+            + argument.getArgumentName());
-  @SuppressWarnings({ "rawtypes", "unchecked" })
-  private Object getConversionObject(Converter<?> converter,
-                                     String string,
-                                     Class<?> dataType,
-                                     String context,
-                                     String valueSeparator) {
+  @SuppressWarnings({"rawtypes", "unchecked"})
+  private Object getConversionObject(Converter<?> converter, String string, Class<?> dataType,
+      String context, String valueSeparator) {
-        return ((MultipleValueConverter) converter).convertFromText(ParserUtils.splitValues(((string != null) ? string.trim() : null), valueSeparator), dataType, context);
+        return ((MultipleValueConverter) converter).convertFromText(
+            ParserUtils.splitValues(((string != null) ? string.trim() : null), valueSeparator),
+            dataType, context);
-        return converter.convertFromText((string != null) ? string.trim() : null, dataType, context);
+        return converter.convertFromText((string != null) ? string.trim() : null, dataType,
+            context);
-      //TODO consider multiple value case for primitives
+      // TODO consider multiple value case for primitives
-        } else if (Short.class.isAssignableFrom(dataType) || short.class.isAssignableFrom(dataType)) {
+        } else if (Short.class.isAssignableFrom(dataType)
+            || short.class.isAssignableFrom(dataType)) {
-        } else if (Boolean.class.isAssignableFrom(dataType) || boolean.class.isAssignableFrom(dataType)) {
+        } else if (Boolean.class.isAssignableFrom(dataType)
+            || boolean.class.isAssignableFrom(dataType)) {
-        } else if (Integer.class.isAssignableFrom(dataType) || int.class.isAssignableFrom(dataType)) {
+        } else if (Integer.class.isAssignableFrom(dataType)
+            || int.class.isAssignableFrom(dataType)) {
-        } else if (Float.class.isAssignableFrom(dataType) || float.class.isAssignableFrom(dataType)) {
+        } else if (Float.class.isAssignableFrom(dataType)
+            || float.class.isAssignableFrom(dataType)) {
-        } else if (Double.class.isAssignableFrom(dataType) || double.class.isAssignableFrom(dataType)) {
+        } else if (Double.class.isAssignableFrom(dataType)
+            || double.class.isAssignableFrom(dataType)) {
-        } else if (Character.class.isAssignableFrom(dataType) || char.class.isAssignableFrom(dataType)) {
+        } else if (Character.class.isAssignableFrom(dataType)
+            || char.class.isAssignableFrom(dataType)) {
-    throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
+      throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
-    throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
+      throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
-          if (remainingBuffer.length() == 0 || remainingBuffer.startsWith(" ") || remainingBuffer.startsWith(GfshParser.LINE_SEPARATOR)) {
+          if (remainingBuffer.length() == 0 || remainingBuffer.startsWith(" ")
+              || remainingBuffer.startsWith(GfshParser.LINE_SEPARATOR)) {
-  //TODO - Abhishek - create an inner CommandTargetLocater instead of multiple
-  //methods like these.
-  private CommandTarget locateExactMatchingTarget(final String userInput)//exact matching
-    throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
+  // TODO - Abhishek - create an inner CommandTargetLocater instead of multiple
+  // methods like these.
+  private CommandTarget locateExactMatchingTarget(final String userInput)// exact matching
+      throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
-                                                               Set<String> requiredCommands)
-    throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
+      Set<String> requiredCommands)
+      throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
-        if (commandName.startsWith(userSpecifiedCommand) && !commandTarget.equals(exactCommandTarget)) {
+        if (commandName.startsWith(userSpecifiedCommand)
+            && !commandTarget.equals(exactCommandTarget)) {
-    throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
+      throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
-      Map<Short, List<CommandTarget>> matchingCommandsMap = findMatchingCommands(userInput, commandNames);
+      Map<Short, List<CommandTarget>> matchingCommandsMap =
+          findMatchingCommands(userInput, commandNames);
-        helpText.append(CliStrings.GFSHPARSER__MSG__NO_MATCHING_COMMAND).append(GfshParser.LINE_SEPARATOR);
+        helpText.append(CliStrings.GFSHPARSER__MSG__NO_MATCHING_COMMAND)
+            .append(GfshParser.LINE_SEPARATOR);
-            helpText.append(CliStrings.format(CliStrings.GFSHPARSER__MSG__OTHER_COMMANDS_STARTING_WITH_0_ARE, userInput));
+            helpText.append(CliStrings
+                .format(CliStrings.GFSHPARSER__MSG__OTHER_COMMANDS_STARTING_WITH_0_ARE, userInput));
-            String availability = commandTarget.isAvailable() ? HelpUtils.HELP__COMMAND_AVAILABLE : HelpUtils.HELP__COMMAND_NOTAVAILABLE;
+            String availability = commandTarget.isAvailable() ? HelpUtils.HELP__COMMAND_AVAILABLE
+                : HelpUtils.HELP__COMMAND_NOTAVAILABLE;
-            helpText.append(Gfsh.wrapText(commandTarget.getCommandHelp(), 1)).append(GfshParser.LINE_SEPARATOR);
+            helpText.append(Gfsh.wrapText(commandTarget.getCommandHelp(), 1))
+                .append(GfshParser.LINE_SEPARATOR);
-            helpText.append(Gfsh.wrapText(CliStrings.format(CliStrings.GFSHPARSER__MSG__USE_0_HELP_COMMAND_TODISPLAY_DETAILS, appName), 0))
-                    .append(GfshParser.LINE_SEPARATOR);
-            helpText.append(Gfsh.wrapText(CliStrings.format(CliStrings.GFSHPARSER__MSG__HELP_CAN_ALSO_BE_OBTAINED_BY_0_KEY, AbstractShell.completionKeys), 0));
+            helpText
+                .append(Gfsh.wrapText(
+                    CliStrings.format(
+                        CliStrings.GFSHPARSER__MSG__USE_0_HELP_COMMAND_TODISPLAY_DETAILS, appName),
+                    0))
+                .append(GfshParser.LINE_SEPARATOR);
+            helpText.append(Gfsh.wrapText(
+                CliStrings.format(CliStrings.GFSHPARSER__MSG__HELP_CAN_ALSO_BE_OBTAINED_BY_0_KEY,
+                    AbstractShell.completionKeys),
+                0));
-      logWarning(message); //TODO - Abhishek add throwable if debug is ON
+      logWarning(message); // TODO - Abhishek add throwable if debug is ON
-        throw new CommandProcessingException(message + ": " + th.getMessage(), errorType, errorData);
+        throw new CommandProcessingException(message + ": " + th.getMessage(), errorType,
+            errorData);
-      consoleLogger.warning(CLIConsoleBufferUtil.processMessegeForExtraCharactersFromConsoleBuffer(message));
+      consoleLogger
+          .warning(CLIConsoleBufferUtil.processMessegeForExtraCharactersFromConsoleBuffer(message));
-  //  private void logInfo(String message) {
-  //    if (consoleLogger != null) {
-  //      consoleLogger.info(message);
-  //    } else {
-  //      Gfsh.println(message);
-  //    }
-  //  }
+  // private void logInfo(String message) {
+  // if (consoleLogger != null) {
+  // consoleLogger.info(message);
+  // } else {
+  // Gfsh.println(message);
+  // }
+  // }

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 UPD66 UPD66 INS66 UPD66 DEL66
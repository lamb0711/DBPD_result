Merge branch 'feature/GEODE-8' into develop

+import com.gemstone.gemfire.GemFireIOException;
-import com.gemstone.gemfire.internal.InternalDataSerializer.Sendable;
+import com.gemstone.gemfire.internal.Sendable;
+import com.gemstone.gemfire.internal.cache.tier.sockets.CacheServerHelper;
+import com.gemstone.gemfire.internal.cache.tx.DistTxKeyInfo;
+import com.gemstone.gemfire.internal.offheap.OffHeapHelper;
+import com.gemstone.gemfire.internal.offheap.OffHeapReference;
+import com.gemstone.gemfire.internal.offheap.OffHeapRegionEntryHelper;
+import com.gemstone.gemfire.internal.offheap.Releasable;
+import com.gemstone.gemfire.internal.offheap.SimpleMemoryAllocatorImpl;
+import com.gemstone.gemfire.internal.offheap.SimpleMemoryAllocatorImpl.Chunk;
+import com.gemstone.gemfire.internal.offheap.StoredObject;
+import com.gemstone.gemfire.internal.offheap.annotations.Released;
+import com.gemstone.gemfire.internal.offheap.annotations.Retained;
+import com.gemstone.gemfire.internal.offheap.annotations.Unretained;
+
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_NEW_VALUE;
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_OLD_VALUE;
+
+import com.gemstone.gemfire.internal.util.ArrayUtils;
+             , Releasable
-  protected Object oldValue = null;
+  @Retained(ENTRY_EVENT_OLD_VALUE)
+  private Object oldValue = null;
-  private transient DistributedPutAllOperation putAllOp;
+  protected transient DistributedPutAllOperation putAllOp;
-  private transient DistributedRemoveAllOperation removeAllOp;
+  protected transient DistributedRemoveAllOperation removeAllOp;
+  /** boolean to indicate that this operation should be optimized by not fetching from HDFS*/
+  private transient boolean fetchFromHDFS = true;
+  
+  private transient boolean isPutDML = false;
+
+  /** boolean to indicate that the RegionEntry for this event was loaded from HDFS*/
+  private transient boolean loadedFromHDFS= false;
+  
+  private transient boolean isCustomEviction = false;
+  
+  /** boolean to indicate that the RegionEntry for this event has been evicted*/
+  private transient boolean isEvicted = false;
+  @Retained
-    return new EntryEventImpl();
+    return createVersionTagHolder(null);
+  @Retained
+    result.disallowOffHeapValues();
-  public EntryEventImpl(LocalRegion region,
-      Operation op,
-      Object key, Object newValue, Object callbackArgument,
-      boolean originRemote, DistributedMember distributedMember) {
-    // Added initializeId=true as the default case. This doesn't
-    // mean that the id will be initialized for sure. It only
-    // means that it will not be set after the entry is instantiated.
-    // UpdateOperation and DestroyOperation both set the id after the
-    // entry is instantiated. Other callers do not.
-    this(region, op, key, newValue, callbackArgument,
-        originRemote, distributedMember, true/* generateCallbacks */,
-        true /*initializeId*/);
-  }
-
-  public EntryEventImpl(LocalRegion region,
-      Operation op,
-      Object key,
-      Object newValue,
-      Object callbackArgument,
-      boolean originRemote,
-      DistributedMember distributedMember,
-      boolean generateCallbacks) {
-    // Added initializeId=true as the default case. This doesn't
-    // mean that the id will be initialized for sure. It only
-    // means that it will not be set after the entry is instantiated.
-    // UpdateOperation and DestroyOperation both set the id after the
-    // entry is instantiated. Other callers do not.
-    this(region, op, key, newValue, callbackArgument, originRemote,
-        distributedMember, generateCallbacks, true/*initializeId*/);
-  }
-  
-  public EntryEventImpl(LocalRegion region, Operation op, Object key,
+  @Retained
+  protected EntryEventImpl(LocalRegion region, Operation op, Object key,
-  public EntryEventImpl(
+  @Retained
+  protected EntryEventImpl(
-      Operation op, Object key, Object newVal,
+      Operation op, Object key, @Retained(ENTRY_EVENT_NEW_VALUE) Object newVal,
-  public EntryEventImpl(LocalRegion region, Operation op, Object key,
-      Object newValue, Object callbackArgument, boolean originRemote,
+  @Retained
+  protected EntryEventImpl(LocalRegion region, Operation op, Object key,
+      @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue, Object callbackArgument, boolean originRemote,
-  public EntryEventImpl(EntryEventImpl other) {
+  @Retained
+  public EntryEventImpl(@Retained({ENTRY_EVENT_NEW_VALUE, ENTRY_EVENT_OLD_VALUE}) EntryEventImpl other) {
+    this(other, true);
+  }
+  
+  @Retained
+  public EntryEventImpl(@Retained({ENTRY_EVENT_NEW_VALUE, ENTRY_EVENT_OLD_VALUE}) EntryEventImpl other, boolean setOldValue) {
-    
+
-    basicSetOldValue(other.basicGetOldValue(), true);
-    this.oldValueBytes = other.oldValueBytes;
-    eventFlags = other.eventFlags;
+    if (setOldValue) {
+      retainAndSetOldValue(other.basicGetOldValue());
+      this.oldValueBytes = other.oldValueBytes;
+    }
+    this.eventFlags = other.eventFlags;
+    this.keyInfo = other.keyInfo.isDistKeyInfo() ? new DistTxKeyInfo(
+        (DistTxKeyInfo) other.keyInfo) : new KeyInfo(other.keyInfo);
-      this.keyInfo = new KeyInfo(other.keyInfo);
-      this.keyInfo.setCallbackArg((new GatewaySenderEventCallbackArgument(
-          (GatewaySenderEventCallbackArgument)other.getRawCallbackArgument())));
-    } else {
-      this.keyInfo = new KeyInfo(other.keyInfo);
+      this.keyInfo
+          .setCallbackArg((new GatewaySenderEventCallbackArgument(
+              (GatewaySenderEventCallbackArgument) other
+                  .getRawCallbackArgument())));
+  @Retained
+  @Retained
+    this.offHeapOk = false;
+   * Creates and returns an EntryEventImpl.  Generates and assigns a bucket id to the
+   * EntryEventImpl if the region parameter is a PartitionedRegion.
+   */  
+  @Retained
+  public static EntryEventImpl create(LocalRegion region,
+      Operation op,
+      Object key, @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue, Object callbackArgument,
+      boolean originRemote, DistributedMember distributedMember) {
+    return create(region,op,key,newValue,callbackArgument,originRemote,distributedMember,true,true);
+  }
+  
+  /**
+   * Creates and returns an EntryEventImpl.  Generates and assigns a bucket id to the
+   * EntryEventImpl if the region parameter is a PartitionedRegion.
+   */
+  @Retained
+  public static EntryEventImpl create(LocalRegion region,
+      Operation op,
+      Object key,
+      @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue,
+      Object callbackArgument,
+      boolean originRemote,
+      DistributedMember distributedMember,
+      boolean generateCallbacks) {
+    return create(region, op, key, newValue, callbackArgument, originRemote,
+        distributedMember, generateCallbacks,true);
+  }
+  
+  /**
+   * Creates and returns an EntryEventImpl.  Generates and assigns a bucket id to the
+   * EntryEventImpl if the region parameter is a PartitionedRegion.
+   *  
+   * Called by BridgeEntryEventImpl to use existing EventID
+   * 
+   * {@link EntryEventImpl#EntryEventImpl(LocalRegion, Operation, Object, Object, Object, boolean, DistributedMember, boolean, EventID)}
+   */ 
+  @Retained
+  public static EntryEventImpl create(LocalRegion region, Operation op, Object key,
+      @Retained(ENTRY_EVENT_NEW_VALUE) Object newValue, Object callbackArgument, boolean originRemote,
+      DistributedMember distributedMember, boolean generateCallbacks,
+      EventID eventID) {
+    EntryEventImpl entryEvent = new EntryEventImpl(region,op,key,newValue,callbackArgument,originRemote,distributedMember,generateCallbacks,eventID);
+    return entryEvent;
+  }
+  
+  /**
+   * Creates and returns an EntryEventImpl.  Generates and assigns a bucket id to the
+   * EntryEventImpl if the region parameter is a PartitionedRegion.
+   * 
+   * {@link EntryEventImpl#EntryEventImpl(LocalRegion, Operation, Object, boolean, DistributedMember, boolean, boolean)}
+   */
+  @Retained
+  public static EntryEventImpl create(LocalRegion region, Operation op, Object key,
+      boolean originRemote, DistributedMember distributedMember,
+      boolean generateCallbacks, boolean fromRILocalDestroy) {
+    EntryEventImpl entryEvent = new EntryEventImpl(region,op,key,originRemote,distributedMember,generateCallbacks,fromRILocalDestroy);
+    return entryEvent;
+  }  
+  
+  /**
+   * Creates and returns an EntryEventImpl.  Generates and assigns a bucket id to the
+   * EntryEventImpl if the region parameter is a PartitionedRegion.
+   * 
+   * This creator does not specify the oldValue as this will be filled in later as part of an
+   * operation on the region, or lets it default to null.
+   * 
+   * {@link EntryEventImpl#EntryEventImpl(LocalRegion, Operation, Object, Object, Object, boolean, DistributedMember, boolean, boolean)}
+   */
+  @Retained
+  public static EntryEventImpl create(final LocalRegion region,
+      Operation op, Object key, @Retained(ENTRY_EVENT_NEW_VALUE) Object newVal,
+      Object callbackArgument,
+      boolean originRemote, DistributedMember distributedMember,
+      boolean generateCallbacks, boolean initializeId)  {
+    EntryEventImpl entryEvent = new EntryEventImpl(region,op,key,newVal,callbackArgument,
+        originRemote,distributedMember,generateCallbacks,initializeId);
+    return entryEvent;
+  }
+  
+  /**
+  @Retained
-      Operation entryOp, Object entryKey, Object entryNewValue)
+      Operation entryOp, Object entryKey, @Retained(ENTRY_EVENT_NEW_VALUE) Object entryNewValue)
-        e = new EntryEventImpl(region, entryOp, entryKey, entryNewValue,
+        e = EntryEventImpl.create(region, entryOp, entryKey, entryNewValue,
-        e = new EntryEventImpl(region, entryOp, entryKey, entryNewValue, event.getCallbackArgument(),
+        e = EntryEventImpl.create(region, entryOp, entryKey, entryNewValue, event.getCallbackArgument(),
-      e = new EntryEventImpl(region, entryOp, entryKey, entryNewValue, null,
+      e = EntryEventImpl.create(region, entryOp, entryKey, entryNewValue, null,
-  static EntryEventImpl createRemoveAllEvent(
+  protected static EntryEventImpl createRemoveAllEvent(
-        e = new EntryEventImpl(region, entryOp, entryKey, null,
+        e = EntryEventImpl.create(region, entryOp, entryKey, null,
-        e = new EntryEventImpl(region, entryOp, entryKey, null, event.getCallbackArgument(),
+        e = EntryEventImpl.create(region, entryOp, entryKey, null, event.getCallbackArgument(),
-      e = new EntryEventImpl(region, entryOp, entryKey, null, null,
+      e = EntryEventImpl.create(region, entryOp, entryKey, null, null,
+  public final boolean isCustomEviction() {
+    return this.isCustomEviction;
+  }
+  
+  public final void setCustomEviction(boolean customEvict) {
+    this.isCustomEviction = customEvict;
+  }
+  
+  public final void setEvicted() {
+    this.isEvicted = true;
+  }
+  
+  public final boolean isEvicted() {
+    return this.isEvicted;
+  }
+  
-  public Object getOldValue()
-  {
+  public final Object getOldValue() {
-      Object ov = basicGetOldValue();
+      @Unretained Object ov = basicGetOldValue();
+        if (ov instanceof StoredObject) {
+          // TODO OFFHEAP: returns off-heap PdxInstance
+          return ((StoredObject) ov).getValueAsDeserializedHeapObject();
+        } else
-   * Returns the new value as is; no deserialization or copying.
+   * Like getRawNewValue except that if the result is an off-heap reference then copy it to the heap.
+   * TODO OFFHEAP: to prevent the heap copy use getRawNewValue instead
-  public Object getRawNewValue() {
+  public final Object getRawNewValueAsHeapObject() {
+    return OffHeapHelper.getHeapForm(OffHeapHelper.copyIfNeeded(basicGetNewValue()));
+  }
+  
+  /**
+   * If new value is a Delta return it.
+   * Else if new value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). 
+   * Its refcount is not inced by this call and the returned object can only be safely used for the lifetime of the EntryEventImpl instance that returned the value.
+   * Else return the raw form.
+   */
+  @Unretained(ENTRY_EVENT_NEW_VALUE)
+  public final Object getRawNewValue() {
+    if (this.delta != null) return this.delta;
+    return basicGetNewValue();
+  }
+
+  @Unretained(ENTRY_EVENT_NEW_VALUE)
+  public Object getValue() {
-  private void basicSetNewValue(Object v) {
-    if (v == this.newValue) return;
-    this.newValue = v;
-    this.cachedSerializedNewValue = null;
-  }
-  protected Object basicGetNewValue() {
-    Object result = this.newValue;
-    return result;
-  }
-  private void basicSetOldValue(Object v, boolean incRefCount) {
-    if (v == this.oldValue) return;
-    this.oldValue = v;
-  }
-  private Object basicGetOldValue() {
-    Object result = this.oldValue;
-    return result;
-  }
-
-  public Object getRawOldValue() {
-    return basicGetOldValue();
+  /**
+   * Returns the delta that represents the new value; null if no delta.
+   * @return the delta that represents the new value; null if no delta.
+   */
+  public final Delta getDeltaNewValue() {
+    return this.delta;
-   * Get the new value preferring the real value over delta if newValue has
-   * already been calculated. This is to correct size calculations when using
-   * delta (used by SQLFabric). See bug #40866.
+   *  Applies the delta 
-  public Object getNewValueForSize() {
-    applyDelta(false);
-    return basicGetNewValue();
+  private Object applyDeltaWithCopyOnRead(boolean doCopyOnRead) {
+    //try {
+      if (applyDelta(true)) {
+        Object applied = basicGetNewValue();
+        // if applyDelta returns true then newValue should not be off-heap
+        assert !(applied instanceof StoredObject);
+        if (applied == this.oldValue && doCopyOnRead) {
+          applied = CopyHelper.copy(applied);
+        }
+        return applied;
+      }
+    //} catch (EntryNotFoundException ex) {
+      // only (broken) product code has the opportunity to call this before
+      // this.oldValue is set. If oldValue is not set yet, then
+      // we most likely haven't synchronized on the region entry yet.
+      // (If we have, then make sure oldValue is set before
+      // calling this method).
+      //throw new AssertionError("too early to call getNewValue");
+    //}
+    return null;
+  }
+
+  @Released(ENTRY_EVENT_NEW_VALUE)
+  protected void basicSetNewValue(@Retained(ENTRY_EVENT_NEW_VALUE) Object v) {
+    if (v == this.newValue) return;
+    if (this.offHeapOk) {
+      OffHeapHelper.releaseAndTrackOwner(this.newValue, this);
+    }
+    if (v instanceof Chunk) {
+      SimpleMemoryAllocatorImpl.setReferenceCountOwner(this);
+      if (!((Chunk) v).retain()) {
+        SimpleMemoryAllocatorImpl.setReferenceCountOwner(null);
+        this.newValue = null;
+        return;
+      }
+      SimpleMemoryAllocatorImpl.setReferenceCountOwner(null);
+    }
+    this.newValue = v;
+    this.cachedSerializedNewValue = null;
+  }
+  /**
+   * Returns true if this event has a reference to an off-heap new or old value.
+   */
+  public boolean hasOffHeapValue() {
+    return (this.newValue instanceof Chunk) || (this.oldValue instanceof Chunk);
+  @Unretained
+  protected final Object basicGetNewValue() {
+    Object result = this.newValue;
+    if (!this.offHeapOk && result instanceof Chunk) {
+      //this.region.getCache().getLogger().info("DEBUG new value already freed " + System.identityHashCode(result));
+      throw new IllegalStateException("Attempt to access off heap value after the EntryEvent was released.");
+    }
+    return result;
+  }
+  
+  private class OldValueOwner {
+    private EntryEventImpl getEvent() {
+      return EntryEventImpl.this;
+    }
+    @Override
+    public int hashCode() {
+      return getEvent().hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (obj instanceof OldValueOwner) {
+        return getEvent().equals(((OldValueOwner) obj).getEvent());
+      } else {
+        return false;
+      }
+    }
+    @Override
+    public String toString() {
+      return "OldValueOwner " + getEvent().toString();
+    }
+  }
+
+  /**
+   * Note if v might be an off-heap reference that you did not retain for this EntryEventImpl
+   * then call retainsAndSetOldValue instead of this method.
+   * @param v the caller should have already retained this off-heap reference.
+   */
+  @Released(ENTRY_EVENT_OLD_VALUE)
+  private void basicSetOldValue(@Unretained(ENTRY_EVENT_OLD_VALUE) Object v) {
+    @Released final Object curOldValue = this.oldValue;
+    if (v == curOldValue) return;
+    if (this.offHeapOk) {
+      if (curOldValue instanceof Chunk) {
+        if (SimpleMemoryAllocatorImpl.trackReferenceCounts()) {
+          OffHeapHelper.releaseAndTrackOwner(curOldValue, new OldValueOwner());
+        } else {
+          OffHeapHelper.release(curOldValue);
+        }
+      }
+    }
+    
+    this.oldValue = v;
+  }
+
+  @Released(ENTRY_EVENT_OLD_VALUE)
+  private void retainAndSetOldValue(@Retained(ENTRY_EVENT_OLD_VALUE) Object v) {
+    if (v == this.oldValue) return;
+    
+    if (v instanceof Chunk) {
+      if (SimpleMemoryAllocatorImpl.trackReferenceCounts()) {
+        SimpleMemoryAllocatorImpl.setReferenceCountOwner(new OldValueOwner());
+        boolean couldNotRetain = (!((Chunk) v).retain());
+        SimpleMemoryAllocatorImpl.setReferenceCountOwner(null);
+        if (couldNotRetain) {
+          this.oldValue = null;
+          return;
+        }
+      } else {
+        if (!((Chunk) v).retain()) {
+          this.oldValue = null;
+          return;
+        }
+      }
+    }
+    basicSetOldValue(v);
+  }
+
+  @Unretained(ENTRY_EVENT_OLD_VALUE)
+  private Object basicGetOldValue() {
+    @Unretained(ENTRY_EVENT_OLD_VALUE)
+    Object result = this.oldValue;
+    if (!this.offHeapOk && result instanceof Chunk) {
+      //this.region.getCache().getLogger().info("DEBUG old value already freed " + System.identityHashCode(result));
+      throw new IllegalStateException("Attempt to access off heap value after the EntryEvent was released.");
+    }
+    return result;
+  }
+
+  /**
+   * Like getRawOldValue except that if the result is an off-heap reference then copy it to the heap.
+   * To avoid the heap copy use getRawOldValue instead.
+   */
+  public final Object getRawOldValueAsHeapObject() {
+    return OffHeapHelper.getHeapForm(OffHeapHelper.copyIfNeeded(basicGetOldValue()));
+  }
+  /*
+   * If the old value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). 
+   * Its refcount is not inced by this call and the returned object can only be safely used for the lifetime of the EntryEventImpl instance that returned the value.
+   * Else return the raw form.
+   */
+  @Unretained
+  public final Object getRawOldValue() {
+    return basicGetOldValue();
+  }
+  /**
+   * Just like getRawOldValue except if the raw old value is off-heap deserialize it.
+   * Note that in some cases sqlf ignores the request to deserialize.
+   */
+  @Unretained(ENTRY_EVENT_OLD_VALUE)
+  public final Object getOldValueAsOffHeapDeserializedOrRaw() {
+    Object result = basicGetOldValue();
+    if (result instanceof StoredObject) {
+      result = ((StoredObject) result).getDeserializedForReading();
+    }
+    return AbstractRegion.handleNotAvailable(result); // fixes 49499
+  }
+
-  public Object getNewValue() {
+  public final Object getNewValue() {
+    
+        @Unretained(ENTRY_EVENT_NEW_VALUE)
+      if (nv instanceof StoredObject) {
+        // TODO OFFHEAP currently we copy offheap new value to the heap here. Check callers of this method to see if they can be optimized to use offheap values.
+        // TODO OFFHEAP: returns off-heap PdxInstance
+        return ((StoredObject) nv).getValueAsDeserializedHeapObject();
+      } else
-        // TODO OFFHEAP currently we copy offheap new value to the heap here. Check callers of this method to see if they can be optimized to use offheap values.
-  public void setNewValue(Object obj) {
+  public final void setNewValue(@Retained(ENTRY_EVENT_NEW_VALUE) Object obj) {
-
-   * Return the new value iff it is already in serialized form,
-   * otherwise return null
+   * @return null if new value is not serialized; otherwise returns a SerializedCacheValueImpl containing the new value.
+    @Unretained(ENTRY_EVENT_NEW_VALUE)
+      if (tmp instanceof StoredObject) {
+        if (!((StoredObject) tmp).isSerialized()) {
+          // TODO OFFHEAP can we handle offheap byte[] better?
+          return null;
+        }
+      }
-      return new SerializedCacheValueImpl(getRegion(), this.re,
+      return new SerializedCacheValueImpl(this, getRegion(), this.re,
+   * Implement this interface if you want to call {@link #exportNewValue}.
+   * 
+   * @author darrel
+   *
+   */
+  public interface NewValueImporter {
+    /**
+     * @return true if the importer prefers the value to be in serialized form.
+     */
+    boolean prefersNewSerialized();
+
+    /**
+     * Only return true if the importer can use the value before the event that exported it is released.
+     * If false is returned then off-heap values will be copied to the heap for the importer.
+     * @return true if the importer can deal with the value being an unretained OFF_HEAP_REFERENCE.
+     */
+    boolean isUnretainedNewReferenceOk();
+
+    /**
+     * Import a new value that is currently in object form.
+     * @param nv the new value to import; unretained if isUnretainedNewReferenceOk returns true
+     * @param isSerialized true if the imported new value represents data that needs to be serialized; false if the imported new value is a simple sequence of bytes.
+     */
+    void importNewObject(@Unretained(ENTRY_EVENT_NEW_VALUE) Object nv, boolean isSerialized);
+
+    /**
+     * Import a new value that is currently in byte array form.
+     * @param nv the new value to import
+     * @param isSerialized true if the imported new value represents data that needs to be serialized; false if the imported new value is a simple sequence of bytes.
+     */
+    void importNewBytes(byte[] nv, boolean isSerialized);
+  }
+  
+  /**
+   * Export the event's new value to the given importer.
+   */
+  public final void exportNewValue(NewValueImporter importer) {
+    final boolean prefersSerialized = importer.prefersNewSerialized();
+    if (prefersSerialized) {
+      if (getCachedSerializedNewValue() != null) {
+        importer.importNewBytes(getCachedSerializedNewValue(), true);
+        return;
+      } else {
+      if (this.newValueBytes != null && this.newValue instanceof CachedDeserializable) {
+        importer.importNewBytes(this.newValueBytes, true);
+        return;
+      }
+      }
+    }
+    @Unretained(ENTRY_EVENT_NEW_VALUE) 
+    final Object nv = getRawNewValue();
+    if (nv instanceof StoredObject) {
+      @Unretained(ENTRY_EVENT_NEW_VALUE)
+      final StoredObject so = (StoredObject) nv;
+      final boolean isSerialized = so.isSerialized();
+      if (nv instanceof Chunk) {
+        if (importer.isUnretainedNewReferenceOk()) {
+          importer.importNewObject(nv, isSerialized);
+        } else {
+          if (!isSerialized || prefersSerialized) {
+            byte[] bytes = so.getValueAsHeapByteArray();
+            importer.importNewBytes(bytes, isSerialized);
+            if (isSerialized) {
+              setCachedSerializedNewValue(bytes);
+            }
+          } else {
+            // TODO OFFHEAP: returns off-heap PdxInstance which is not ok since isUnretainedNewReferenceOk returned false
+            importer.importNewObject(so.getValueAsDeserializedHeapObject(), true);
+          }
+        }
+      } else {
+        importer.importNewObject(nv, isSerialized);
+      }
+    } else if (nv instanceof byte[]) {
+      importer.importNewBytes((byte[])nv, false);
+    } else if (nv instanceof CachedDeserializable) {
+      CachedDeserializable cd = (CachedDeserializable) nv;
+      Object cdV = cd.getValue();
+      if (cdV instanceof byte[]) {
+        importer.importNewBytes((byte[]) cdV, true);
+        setCachedSerializedNewValue((byte[]) cdV);
+      } else {
+        importer.importNewObject(cdV, true);
+      }
+    } else {
+      importer.importNewObject(nv, true);
+    }
+  }
+  /**
+   * Implement this interface if you want to call {@link #exportOldValue}.
+   * 
+   * @author darrel
+   *
+   */
+  public interface OldValueImporter {
+    /**
+     * @return true if the importer prefers the value to be in serialized form.
+     */
+    boolean prefersOldSerialized();
+
+    /**
+     * Only return true if the importer can use the value before the event that exported it is released.
+     * @return true if the importer can deal with the value being an unretained OFF_HEAP_REFERENCE.
+     */
+    boolean isUnretainedOldReferenceOk();
+    
+    /**
+     * @return return true if you want the old value to possibly be an instanceof CachedDeserializable; false if you want the value contained in a CachedDeserializable.
+     */
+    boolean isCachedDeserializableValueOk();
+
+    /**
+     * Import an old value that is currently in object form.
+     * @param ov the old value to import; unretained if isUnretainedOldReferenceOk returns true
+     * @param isSerialized true if the imported old value represents data that needs to be serialized; false if the imported old value is a simple sequence of bytes.
+     */
+    void importOldObject(@Unretained(ENTRY_EVENT_OLD_VALUE) Object ov, boolean isSerialized);
+
+    /**
+     * Import an old value that is currently in byte array form.
+     * @param ov the old value to import
+     * @param isSerialized true if the imported old value represents data that needs to be serialized; false if the imported old value is a simple sequence of bytes.
+     */
+    void importOldBytes(byte[] ov, boolean isSerialized);
+  }
+  
+  /**
+   * Export the event's old value to the given importer.
+   */
+  public final void exportOldValue(OldValueImporter importer) {
+    final boolean prefersSerialized = importer.prefersOldSerialized();
+    if (prefersSerialized) {
+      if (this.oldValueBytes != null && this.oldValue instanceof CachedDeserializable) {
+        importer.importOldBytes(this.oldValueBytes, true);
+        return;
+      }
+    }
+    @Unretained(ENTRY_EVENT_OLD_VALUE)
+    final Object ov = getRawOldValue();
+    if (ov instanceof StoredObject) {
+      final StoredObject so = (StoredObject) ov;
+      final boolean isSerialized = so.isSerialized();
+      if (ov instanceof Chunk) {
+        if (importer.isUnretainedOldReferenceOk()) {
+          importer.importOldObject(ov, isSerialized);
+        } else {
+          if (!isSerialized || prefersSerialized) {
+            importer.importOldBytes(so.getValueAsHeapByteArray(), isSerialized);
+          } else {
+            // TODO OFFHEAP: returns off-heap PdxInstance which is not ok since isUnretainedNewReferenceOk returned false
+           importer.importOldObject(so.getValueAsDeserializedHeapObject(), true);
+          }
+        }
+      } else {
+        importer.importOldObject(ov, isSerialized);
+      }
+    } else if (ov instanceof byte[]) {
+      importer.importOldBytes((byte[])ov, false);
+    } else if (!importer.isCachedDeserializableValueOk() && ov instanceof CachedDeserializable) {
+      CachedDeserializable cd = (CachedDeserializable) ov;
+      Object cdV = cd.getValue();
+      if (cdV instanceof byte[]) {
+        importer.importOldBytes((byte[]) cdV, true);
+      } else {
+        importer.importOldObject(cdV, true);
+      }
+    } else {
+      importer.importOldObject(ov, true);
+    }
+  }
+
+  /**
+   * If applyDelta is true then first attempt to apply a delta (if we have one) and return the value.
+   * Else if new value is a Delta return it.
+   * Else if new value is off-heap return the StoredObject form (unretained OFF_HEAP_REFERENCE). 
+   * Its refcount is not inced by this call and the returned object can only be safely used for the lifetime of the EntryEventImpl instance that returned the value.
+   * Else return the raw form.
+   */
+  @Unretained(ENTRY_EVENT_NEW_VALUE)
+  public final Object getRawNewValue(boolean applyDelta) {
+    if (applyDelta) {
+      boolean doCopyOnRead = getRegion().isCopyOnRead();
+      Object newValueWithDelta = applyDeltaWithCopyOnRead(doCopyOnRead);
+      if (newValueWithDelta != null) {
+        return newValueWithDelta;
+      }
+      // if applyDelta is true and we have already applied the delta then
+      // just return the applied value instead of the delta object.
+      @Unretained(ENTRY_EVENT_NEW_VALUE)
+      Object newValue = basicGetNewValue();
+      if (newValue != null) return newValue;
+    }
+    return getRawNewValue();
+  }
+  /**
+   * Just like getRawNewValue(true) except if the raw new value is off-heap deserialize it.
+   * Note that in some cases sqlf ignores the request to deserialize.
+   */
+  @Unretained(ENTRY_EVENT_NEW_VALUE)
+  public final Object getNewValueAsOffHeapDeserializedOrRaw() {
+    Object result = getRawNewValue(true);
+    if (result instanceof StoredObject) {
+      result = ((StoredObject) result).getDeserializedForReading();
+    }
+    return AbstractRegion.handleNotAvailable(result); // fixes 49499
+  }
+
+  /**
+   * If the new value is stored off-heap return a retained OFF_HEAP_REFERENCE (caller must release).
+   * @return a retained OFF_HEAP_REFERENCE if the new value is off-heap; otherwise returns null
+   */
+  @Retained(ENTRY_EVENT_NEW_VALUE)
+  public StoredObject getOffHeapNewValue() {
+    final Object tmp = basicGetNewValue();
+    if (tmp instanceof StoredObject) {
+      StoredObject result = (StoredObject) tmp;
+      if (!result.retain()) {
+        return null;
+      }
+      return result;
+    } else {
+      return null;
+    }
+  }
+  
+  /**
+   * If the old value is stored off-heap return a retained OFF_HEAP_REFERENCE (caller must release).
+   * @return a retained OFF_HEAP_REFERENCE if the old value is off-heap; otherwise returns null
+   */
+  @Retained(ENTRY_EVENT_OLD_VALUE)
+  public StoredObject getOffHeapOldValue() {
+    final Object tmp = basicGetOldValue();
+    if (tmp instanceof StoredObject) {
+      StoredObject result = (StoredObject) tmp;
+      if (!result.retain()) {
+        return null;
+      }
+      return result;
+    } else {
+      return null;
+    }
+  }
+
+  /**
+   * Result may be unretained because sqlf getDeserializedForReading returns unretained.
+   */
+  public final Object getDeserializedValue() {
+    if (this.delta == null) {
+      final Object val = basicGetNewValue();
+      if (val instanceof StoredObject) {
+        // TODO OFFHEAP: returns off-heap PdxInstance
+        return ((StoredObject) val).getValueAsDeserializedHeapObject();
+      } else 
+      if (val instanceof CachedDeserializable) {
+        return ((CachedDeserializable)val).getDeserializedForReading();
+      }
+      else {
+        return val;
+      }
+    }
+    else {
+      return this.delta;
+    }
+  }
+
+  public final byte[] getSerializedValue() {
+    if (this.newValueBytes == null) {
+      final Object val;
+      if (this.delta == null) {
+        val = basicGetNewValue();
+        if (val instanceof byte[]) {
+          return (byte[])val;
+        }
+        else if (val instanceof CachedDeserializable) {
+          return ((CachedDeserializable)val).getSerializedValue();
+        }
+      }
+      else {
+        val = this.delta;
+      }
+      try {
+        return CacheServerHelper.serialize(val);
+      } catch (IOException ioe) {
+        throw new GemFireIOException("unexpected exception", ioe);
+      }
+    }
+    else {
+      return this.newValueBytes;
+    }
+  }
+
+  /**
-  private void makeSerializedNewValue(boolean isSynced) {
-    Object obj = this.newValue;
+  private final void makeSerializedNewValue(boolean isSynced) {
+    Object obj = basicGetNewValue();
-  public void setSerializedNewValue(byte[] serializedValue) {
+  public final void setSerializedNewValue(byte[] serializedValue) {
+    Object newVal = null;
+    if (serializedValue != null) {
+      if (CachedDeserializableFactory.preferObject()) {
+        newVal = deserialize(serializedValue);
+      } else {
+        newVal = CachedDeserializableFactory.create(serializedValue);
+      }
+      if (newVal instanceof Delta) {
+        this.delta = (Delta)newVal;
+        newVal = null;
+        // We need the newValueBytes field and the newValue field to be in sync.
+        // In the case of non-null delta set both fields to null.
+        serializedValue = null;
+      }
+    }
-    basicSetNewValue(CachedDeserializableFactory.create(serializedValue));
+    basicSetNewValue(newVal);
-    basicSetOldValue(CachedDeserializableFactory.create(serializedOldValue), true);
+    final Object ov;
+    if (CachedDeserializableFactory.preferObject()) {
+      ov = deserialize(serializedOldValue);
+    }
+    else if (serializedOldValue != null) {
+      ov = CachedDeserializableFactory.create(serializedOldValue);
+    }
+    else {
+      ov = null;
+    }
+    retainAndSetOldValue(ov);
+            || GemFireCacheImpl.sqlfSystem()
-          Object ov = reentry._getValueUse(owner, true); // TODO:KIRK:OK 
+          @Retained Object ov;
+          if (SimpleMemoryAllocatorImpl.trackReferenceCounts()) {
+            SimpleMemoryAllocatorImpl.setReferenceCountOwner(new OldValueOwner());
+            if (GemFireCacheImpl.sqlfSystem()) {
+              ov = reentry.getValueOffHeapOrDiskWithoutFaultIn(this.region);
+            } else {
+              ov = reentry._getValueRetain(owner, true);
+            }
+            SimpleMemoryAllocatorImpl.setReferenceCountOwner(null);
+          } else {
+            if (GemFireCacheImpl.sqlfSystem()) {
+              ov = reentry.getValueOffHeapOrDiskWithoutFaultIn(this.region);
+            } else {
+              ov = reentry._getValueRetain(owner, true);
+            }
+          }
-          basicSetOldValue(ov, false);
+          // ov has already been retained so call basicSetOldValue instead of retainAndSetOldValue
+          basicSetOldValue(ov);
-          basicSetOldValue(Token.NOT_AVAILABLE, true);
+          basicSetOldValue(Token.NOT_AVAILABLE);
-      basicSetOldValue(null, true);
+      basicSetOldValue(null);
+  @Retained(ENTRY_EVENT_NEW_VALUE)
-    } 
- 
-    v = AbstractRegionMap.prepareValueForCache(this.region, v, this);
+    }
+    Object preparedV = reentry.prepareValueForCache(this.region, v, this, this.hasDelta());
+    if (preparedV != v) {
+      v = preparedV;
+      if (v instanceof Chunk) {
+        if (!((Chunk) v).isCompressed()) { // fix bug 52109
+          // If we put it off heap and it is not compressed then remember that value.
+          // Otherwise we want to remember the decompressed value in the event.
+          basicSetNewValue(v);
+        }
+      }
+    }
+    boolean isTombstone = (v == Token.TOMBSTONE);
+    boolean success = false;
+    boolean calledSetValue = false;
+    try {
-    boolean isTombstone = (v == Token.TOMBSTONE);
-    
-      boolean success = false;
+        calledSetValue = true;
+      calledSetValue = true;
+      success = true;
+    }
+    } finally {
+      if (!success && reentry instanceof OffHeapRegionEntry && v instanceof Chunk) {
+        OffHeapRegionEntryHelper.releaseEntry((OffHeapRegionEntry)reentry, (Chunk)v);
+      }      
-  void setTXEntryOldValue(Object oldVal, boolean mustBeAvailable)
-  {
-    if (Token.isInvalidOrRemoved(oldVal) || oldVal == null) {
-      basicSetOldValue(null, true);
+  void setTXEntryOldValue(Object oldVal, boolean mustBeAvailable) {
+    if (Token.isInvalidOrRemoved(oldVal)) {
+      oldVal = null;
-      if (mustBeAvailable) {
-        basicSetOldValue(oldVal, true);
-      } else if (EVENT_OLD_VALUE) {
-        basicSetOldValue(oldVal, true);
-      } else {
-        basicSetOldValue(Token.NOT_AVAILABLE, true);
+      if (mustBeAvailable || oldVal == null || EVENT_OLD_VALUE) {
+        // set oldValue to oldVal
+      }
+      else {
+        oldVal = Token.NOT_AVAILABLE;
+    retainAndSetOldValue(oldVal);
-      tx.setPendingValue(v);
+      tx.setPendingValue(OffHeapHelper.copyIfNeeded(v)); // TODO OFFHEAP optimize
-      Object v = re._getValueUse(this.region, true);
+      SimpleMemoryAllocatorImpl.skipRefCountTracking();
+      Object v = re._getValueRetain(this.region, true);
+      SimpleMemoryAllocatorImpl.unskipRefCountTracking();
+      try {
+      } finally {
+        OffHeapHelper.releaseWithNoTracking(v);
+      }
-    basicSetOldValue(Token.DESTROYED, true);
+    basicSetOldValue(Token.DESTROYED);
-        basicSetOldValue(null, true);
+        v = null;
-          basicSetOldValue(v, true);
+          // set oldValue to "v".
-          basicSetOldValue(v, true);
+          // set oldValue to "v".
-          basicSetOldValue(Token.NOT_AVAILABLE, true);
+          v = Token.NOT_AVAILABLE;
+      retainAndSetOldValue(v);
-    } else if (Token.isInvalid(v)) {
-      basicSetOldValue(null, true);
-      basicSetOldValue(v, true);
+      if (Token.isInvalid(v)) {
+        v = null;
+      }   
+      retainAndSetOldValue(v);
-    if (tmp == null && this.delta != null) {
+    if (tmp == null && hasDelta()) {
-  final public boolean hasOldValue() {
-    return this.oldValue != null  && basicGetOldValue() != Token.NOT_AVAILABLE;
+  public final boolean hasOldValue() {
+    return this.oldValue != null && this.oldValue != Token.NOT_AVAILABLE;
+  }
+  public final boolean isOldValueAToken() {
+    return this.oldValue instanceof Token;
-    basicSetOldValue(Token.NOT_AVAILABLE, true);
+    basicSetOldValue(Token.NOT_AVAILABLE);
+   * If a PdxInstance is returned then it will have an unretained reference
+   * to Chunk's off-heap address.
+   */
+  public static @Unretained Object deserializeChunk(Chunk bytes) {
+    if (bytes == null)
+      return null;
+    try {
+      return BlobHelper.deserializeOffHeapBlob(bytes);
+    }
+    catch (IOException e) {
+      throw new SerializationException(LocalizedStrings.EntryEventImpl_AN_IOEXCEPTION_WAS_THROWN_WHILE_DESERIALIZING.toLocalizedString(), e);
+    }
+    catch (ClassNotFoundException e) {
+      // fix for bug 43602
+      throw new SerializationException(LocalizedStrings.EntryEventImpl_A_CLASSNOTFOUNDEXCEPTION_WAS_THROWN_WHILE_TRYING_TO_DESERIALIZE_CACHED_VALUE.toLocalizedString(), e);
+    }
+  }
+
+  /**
-    buf.append(basicGetOldValue());
+    try {
+      ArrayUtils.objectStringNonRecursive(basicGetOldValue(), buf);
+    } catch (IllegalStateException ex) {
+      buf.append("OFFHEAP_VALUE_FREED");
+    }
-    buf.append(basicGetNewValue());
+    try {
+      ArrayUtils.objectStringNonRecursive(basicGetNewValue(), buf);
+    } catch (IllegalStateException ex) {
+      buf.append("OFFHEAP_VALUE_FREED");
+    }
+        if (newValueSerialized) {
+          if (nv instanceof StoredObject) {
+            newValueSerialized = ((StoredObject) nv).isSerialized();
+          }
+        }
+      if (oldValueSerialized) {
+        if (ov instanceof StoredObject) {
+          oldValueSerialized = ((StoredObject) ov).isSerialized();
+        }
+      }
-  public SerializedCacheValue<?> getSerializedOldValue() {
+  /**
+   * @return null if old value is not serialized; otherwise returns a SerializedCacheValueImpl containing the old value.
+   */
+  public final SerializedCacheValue<?> getSerializedOldValue() {
+    @Unretained(ENTRY_EVENT_OLD_VALUE)
-      return new SerializedCacheValueImpl(this.region, this.re,
+      if (tmp instanceof StoredObject) {
+        if (!((StoredObject) tmp).isSerialized()) {
+          // TODO OFFHEAP can we handle offheap byte[] better?
+          return null;
+        }
+      }
+      return new SerializedCacheValueImpl(this, this.region, this.re,
-
+  
+   * Used to store next region version generated for a change on this entry
+   * by phase-1 commit on the primary.  
+   * 
+   * Not to be used in fromData and toData
+   */
+  protected transient long nextRegionVersion = -1L;
+  
+  public void setNextRegionVersion(long regionVersion) {
+    this.nextRegionVersion = regionVersion;
+  }
+  
+  public long getNextRegionVersion() {
+    return this.nextRegionVersion;
+  }
+  
+  /**
-      Object v = reentry.getValueOffHeapOrDiskWithoutFaultIn(this.region);
+      @Retained Object v = reentry.getValueOffHeapOrDiskWithoutFaultIn(this.region);
-        basicSetOldValue(v, false);
+        // v has already been retained.
+        basicSetOldValue(v);
+        // this event now owns the retention of v.
-
-  // TODO this class is trouble for OffHeap storage.
-  // If the cd is a OffHeapCachedDeserializable we don't want to have a reference
-  // to it in this class since customers can hold onto SerializedCacheValue
-  // as long as they want and we would need to use finalization to know when
-  // they are done with it.
-  // TODO this class is also used in a number of places internally and those
-  // we want to be optimized. I think those places can be changed not to use
-  // this class.
-  public static class SerializedCacheValueImpl
+  public static final class SerializedCacheValueImpl
-    private final CachedDeserializable cd;
+    private final EntryEventImpl event;
+    @Unretained private final CachedDeserializable cd;
-    SerializedCacheValueImpl(Region r, RegionEntry re, CachedDeserializable cd, byte[] serializedBytes) {
+    SerializedCacheValueImpl(EntryEventImpl event, Region r, RegionEntry re, @Unretained CachedDeserializable cd, byte[] serializedBytes) {
+      if (cd instanceof Chunk) {
+        this.event = event;
+      } else {
+        this.event = null;
+      }
-      return this.cd.getSerializedValue();
+      return getCd().getSerializedValue();
+    }
+    
+    private CachedDeserializable getCd() {
+      if (this.event != null && !this.event.offHeapOk) {
+        throw new IllegalStateException("Attempt to access off heap value after the EntryEvent was released.");
+      }
+      return this.cd;
-      return this.cd.getDeserializedForReading();
+      // TODO OFFHEAP: returns off-heap PdxInstance
+      return OffHeapHelper.getHeapForm(getCd().getDeserializedForReading());
-      return this.cd.getDeserializedWritableCopy(rgn, entry);
+      // TODO OFFHEAP: returns off-heap PdxInstance
+      return OffHeapHelper.getHeapForm(getCd().getDeserializedWritableCopy(rgn, entry));
-      return this.cd.getDeserializedValue(rgn, reentry);
+      // TODO OFFHEAP: returns off-heap PdxInstance
+      return OffHeapHelper.getHeapForm(getCd().getDeserializedValue(rgn, reentry));
-      return this.cd.getValue();
+      return getCd().getValue();
-        this.cd.writeValueAsByteArray(out);
+        getCd().writeValueAsByteArray(out);
-        this.cd.fillSerializedValue(wrapper, userBits);
+        getCd().fillSerializedValue(wrapper, userBits);
-      return this.cd.getValueSizeInBytes();
+      return getCd().getValueSizeInBytes();
-      return this.cd.getSizeInBytes();
+      return getCd().getSizeInBytes();
-      return this.cd.getStringForm();
+      return getCd().getStringForm();
-      DataSerializer.writeObject(this.cd, out);
+      DataSerializer.writeObject(getCd(), out);
+
+  /**
+   * True if it is ok to use old/new values that are stored off heap.
+   * False if an exception should be thrown if an attempt is made to access old/new offheap values.
+   */
+  private transient boolean offHeapOk = true;
+ 
+  @Override
+  @Released({ENTRY_EVENT_NEW_VALUE, ENTRY_EVENT_OLD_VALUE})
+  public void release() {
+    // noop if already freed or values can not be off-heap
+    if (!this.offHeapOk) return;
+    // Note that this method does not set the old/new values to null but
+    // leaves them set to the off-heap value so that future calls to getOld/NewValue
+    // will fail with an exception.
+//    LocalRegion lr = getLocalRegion();
+//    if (lr != null) {
+//      if (lr.isCacheClosing()) {
+//        // to fix races during closing and recreating cache (see bug 47883) don't bother
+//        // trying to decrement reference counts if we are closing the cache.
+//        // TODO OFFHEAP: this will cause problems once offheap lives longer than a cache.
+//        this.offHeapOk = false;
+//        return;
+//      }
+//    }
+    Object ov = basicGetOldValue();
+    Object nv = basicGetNewValue();
+    this.offHeapOk = false;
+    
+    if (ov instanceof Chunk) {
+      //this.region.getCache().getLogger().info("DEBUG freeing ref to old value on " + System.identityHashCode(ov));
+      if (SimpleMemoryAllocatorImpl.trackReferenceCounts()) {
+        SimpleMemoryAllocatorImpl.setReferenceCountOwner(new OldValueOwner());
+        ((Chunk) ov).release();
+        SimpleMemoryAllocatorImpl.setReferenceCountOwner(null);
+      } else {
+        ((Chunk) ov).release();
+      }
+    }
+    OffHeapHelper.releaseAndTrackOwner(nv, this);
+  }
+
+  /**
+   * Make sure that this event will never own an off-heap value.
+   * Once this is called on an event it does not need to have release called.
+   */
+  public void disallowOffHeapValues() {
+    if (this.newValue instanceof Chunk || this.oldValue instanceof Chunk) {
+      throw new IllegalStateException("This event does not support off-heap values");
+    }
+    this.offHeapOk = false;
+  }
+  
+  /**
+   * This copies the off-heap new and/or old value to the heap.
+   * As a result the current off-heap new/old will be released.
+   * @throws IllegalStateException if called with an event for sqlf data.
+   */
+  @Released({ENTRY_EVENT_NEW_VALUE, ENTRY_EVENT_OLD_VALUE})
+  public void copyOffHeapToHeap() {
+    Object ov = basicGetOldValue();
+    if (ov instanceof Chunk) {
+      if (SimpleMemoryAllocatorImpl.trackReferenceCounts()) {
+        SimpleMemoryAllocatorImpl.setReferenceCountOwner(new OldValueOwner());
+        this.oldValue = OffHeapHelper.copyAndReleaseIfNeeded(ov);
+        SimpleMemoryAllocatorImpl.setReferenceCountOwner(null);
+      } else {
+        this.oldValue = OffHeapHelper.copyAndReleaseIfNeeded(ov);
+      }
+    }
+    Object nv = basicGetNewValue();
+    if (nv instanceof Chunk) {
+      SimpleMemoryAllocatorImpl.setReferenceCountOwner(this);
+      this.newValue = OffHeapHelper.copyAndReleaseIfNeeded(nv);
+      SimpleMemoryAllocatorImpl.setReferenceCountOwner(null);
+    }
+    if (this.newValue instanceof Chunk || this.oldValue instanceof Chunk) {
+      throw new IllegalStateException("event's old/new value still off-heap after calling copyOffHeapToHeap");
+    }
+    this.offHeapOk = false;
+  }
+
+  public boolean isOldValueOffHeap() {
+    return this.oldValue instanceof Chunk;
+  }
+  public final boolean isFetchFromHDFS() {
+    return fetchFromHDFS;
+  }
+
+  public final void setFetchFromHDFS(boolean fetchFromHDFS) {
+    this.fetchFromHDFS = fetchFromHDFS;
+  }
+
+  public final boolean isPutDML() {
+    return this.isPutDML;
+  }
+
+  public final void setPutDML(boolean val) {
+    this.isPutDML = val;
+  }
+
+  public final boolean isLoadedFromHDFS() {
+    return loadedFromHDFS;
+  }
+
+  public final void setLoadedFromHDFS(boolean loadedFromHDFS) {
+    this.loadedFromHDFS = loadedFromHDFS;
+  }

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV31 MOV31 MOV31 MOV31 MOV31 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS43 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS55 INS31 INS55 INS55 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS23 INS31 INS31 MOV31 MOV31 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS42 INS79 UPD83 UPD83 UPD83 INS29 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS39 INS59 INS78 INS43 INS78 INS78 UPD83 INS78 UPD83 INS78 UPD83 MOV29 INS78 INS83 INS42 INS44 INS8 INS78 INS44 INS44 INS78 INS78 INS29 INS78 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS29 INS78 INS83 INS43 INS42 MOV44 INS44 INS44 INS44 INS44 INS44 INS44 INS29 INS78 INS83 INS83 MOV43 INS42 MOV44 MOV44 MOV44 INS44 MOV44 MOV44 MOV44 INS44 INS44 INS8 INS29 INS78 INS83 INS83 INS43 INS42 INS44 INS44 INS44 MOV44 MOV44 MOV44 INS44 INS8 INS29 INS78 INS83 INS83 MOV43 INS42 INS44 MOV44 MOV44 INS44 MOV44 INS44 INS44 INS44 INS44 INS8 INS78 INS83 INS83 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS8 INS83 INS83 UPD42 INS29 INS79 INS83 INS83 INS43 INS42 INS8 INS79 INS83 MOV43 INS42 INS8 INS29 INS83 INS83 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS44 MOV8 INS79 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS8 INS78 INS83 INS83 INS42 INS31 INS31 INS31 INS31 INS29 INS79 UPD42 INS8 INS79 UPD42 INS8 INS79 INS29 INS83 INS83 INS43 INS42 INS8 INS78 INS83 INS79 INS83 INS43 UPD42 INS8 INS83 INS83 INS44 INS29 INS83 INS42 INS31 INS31 INS31 INS31 INS29 INS83 INS42 INS44 INS8 INS29 INS83 INS42 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS83 UPD42 INS44 INS29 INS79 INS83 INS83 INS43 INS42 INS44 INS8 INS29 INS79 INS83 INS83 INS43 INS42 INS8 INS29 INS79 INS83 INS43 INS42 INS8 INS29 INS79 INS83 INS43 INS42 INS8 INS29 INS83 INS83 INS43 INS42 INS8 INS83 INS83 INS5 INS42 INS8 INS83 INS83 INS83 INS39 INS42 MOV44 INS8 INS83 INS39 INS42 MOV44 INS8 INS79 INS39 INS42 MOV44 MOV44 INS8 INS83 INS83 INS83 INS39 INS42 INS8 INS29 INS83 INS83 INS78 INS43 INS42 INS44 INS8 INS29 INS83 INS29 INS83 INS83 INS39 INS59 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS8 INS83 INS23 INS31 INS29 INS83 INS83 INS39 INS59 INS78 INS79 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS79 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS42 INS42 INS65 INS42 INS9 INS42 INS9 INS65 INS42 INS9 INS42 INS9 INS65 INS42 INS9 INS42 INS42 INS42 INS21 INS42 INS42 INS79 INS43 INS42 INS79 INS43 INS42 INS79 INS43 INS42 INS17 INS42 INS79 INS43 INS42 INS39 INS42 INS25 MOV21 INS42 INS42 INS21 INS65 INS42 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS79 INS43 INS43 INS42 INS39 INS42 INS43 INS42 INS41 INS65 INS42 INS42 INS43 INS42 INS43 INS42 INS79 INS43 INS43 INS42 INS39 INS42 INS43 INS42 INS39 INS42 INS41 INS65 INS42 INS79 INS43 INS42 INS39 INS42 INS43 INS42 INS60 INS41 INS65 INS42 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS60 INS41 INS65 INS42 INS83 INS43 INS42 INS79 INS43 INS42 INS39 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS60 INS41 INS42 INS79 INS43 INS41 INS39 INS42 INS21 INS21 INS41 INS41 INS65 INS42 INS42 INS42 INS25 MOV41 INS42 INS42 MOV41 INS65 INS65 INS42 INS41 INS65 INS42 INS39 INS42 INS41 INS42 INS42 INS79 INS43 INS42 MOV25 INS25 INS25 MOV21 MOV21 INS65 INS41 INS42 INS25 INS83 INS43 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 MOV44 INS8 INS78 INS83 INS43 INS42 INS8 INS65 INS65 INS42 INS42 INS79 INS60 INS25 INS25 MOV21 INS42 INS42 INS79 MOV25 INS25 INS21 INS42 INS42 INS25 INS65 INS42 INS41 INS42 INS42 INS42 INS42 INS60 INS25 INS41 INS79 INS43 INS42 UPD65 INS60 INS65 INS65 INS29 INS39 INS42 INS29 INS39 INS42 INS29 INS39 INS42 INS44 INS44 INS29 INS39 INS42 INS44 INS44 INS65 INS43 INS42 INS60 INS25 INS60 INS25 INS65 INS65 INS29 INS39 INS42 INS29 INS39 INS42 INS29 INS39 INS42 INS29 MOV39 INS42 INS44 INS44 INS29 INS39 INS42 INS44 INS44 INS65 INS43 INS42 INS60 INS25 INS60 INS65 INS42 INS42 INS42 INS39 INS42 INS25 INS41 INS65 INS42 INS42 INS42 INS60 INS25 INS41 INS65 INS65 INS42 INS42 INS42 MOV60 INS25 INS65 INS65 INS42 INS42 INS42 MOV60 INS25 INS65 INS42 INS25 INS39 INS85 INS25 INS60 INS25 MOV21 INS21 MOV21 MOV21 INS60 INS25 INS21 INS42 INS42 INS60 INS25 MOV60 INS60 INS54 INS25 INS21 INS25 INS41 INS65 INS42 INS42 INS43 INS42 INS25 INS54 INS54 INS54 INS65 INS60 INS65 INS42 INS38 INS39 INS42 INS21 INS41 INS83 INS83 INS43 INS59 INS78 MOV44 INS5 UPD42 INS83 INS43 INS42 INS8 INS43 UPD42 INS65 INS42 INS9 INS42 INS42 INS4 INS25 MOV60 INS60 INS21 INS25 INS21 INS65 INS25 INS21 INS65 INS65 INS42 INS4 INS60 INS25 INS60 INS25 INS25 INS21 INS41 INS41 INS39 INS42 INS21 INS41 INS39 INS42 INS21 INS41 INS39 INS42 INS21 INS66 INS66 INS66 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS4 INS42 INS42 INS9 INS42 INS4 INS42 INS42 INS8 INS7 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS66 INS66 INS66 INS65 INS42 INS42 INS42 INS42 MOV43 INS59 INS42 INS66 INS66 INS65 INS42 INS42 INS42 MOV43 INS59 INS42 INS66 INS66 INS66 INS66 INS65 INS42 INS42 INS42 INS42 INS42 MOV43 INS59 INS42 INS42 INS42 INS42 INS22 INS7 INS7 INS22 UPD66 INS66 INS32 INS66 INS66 INS66 INS66 MOV27 INS41 INS66 INS66 INS22 INS66 INS33 INS42 INS42 INS42 INS22 INS8 INS62 INS8 INS66 INS27 INS27 INS8 INS42 INS41 INS42 INS41 INS42 INS25 INS42 INS42 INS41 INS66 INS66 INS42 INS66 INS42 INS42 INS78 INS83 INS43 INS59 INS27 INS41 INS22 INS8 INS42 INS42 INS62 INS8 INS32 INS79 INS27 INS8 INS66 INS66 INS32 UPD66 UPD66 MOV43 INS59 INS62 INS8 INS32 INS8 INS42 INS42 INS42 UPD66 INS79 INS83 INS43 INS59 INS66 INS65 INS66 INS66 INS65 INS65 INS65 INS65 INS65 INS65 INS79 INS43 INS42 INS39 INS42 INS65 INS65 INS65 INS5 INS42 INS39 INS42 INS66 INS42 INS83 INS39 INS59 INS42 INS8 INS79 INS83 INS43 INS59 INS62 INS8 INS25 INS66 INS65 INS66 INS66 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS79 INS43 INS42 INS39 INS42 INS65 INS65 INS65 INS5 INS42 INS39 INS42 INS66 INS42 INS83 INS39 INS59 INS42 INS8 INS79 INS83 INS43 INS59 INS62 INS8 INS25 INS66 INS66 INS66 INS66 INS66 INS42 INS8 INS32 INS66 INS66 INS43 INS59 INS62 INS8 INS32 INS66 INS66 INS62 INS8 INS8 INS66 INS66 INS62 INS8 MOV8 INS66 INS27 INS8 INS8 INS27 INS8 INS8 INS43 INS43 INS59 INS27 INS8 INS32 INS83 MOV43 INS59 INS32 INS8 INS25 INS32 INS43 INS59 INS27 INS8 INS39 INS59 INS8 INS8 MOV32 INS8 INS8 INS32 MOV32 MOV8 INS8 INS62 INS66 INS66 INS42 INS27 INS41 INS8 INS12 INS12 INS8 INS12 INS8 INS12 INS25 INS66 INS79 INS83 INS43 INS59 INS8 INS66 INS66 INS66 INS34 INS7 INS22 INS42 INS42 INS42 UPD42 INS78 INS43 INS25 INS39 INS85 INS42 INS25 MOV41 INS42 INS41 INS66 INS66 INS42 INS42 INS38 INS41 INS43 INS59 INS7 INS62 INS8 INS32 INS66 INS66 INS27 INS8 INS7 INS66 INS66 INS42 INS66 INS42 INS42 INS43 INS59 INS62 INS8 INS43 INS59 INS62 INS8 INS27 INS8 INS7 INS62 INS42 INS7 INS22 INS7 INS42 INS7 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 MOV21 MOV21 INS22 INS16 INS22 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS68 INS42 INS14 INS68 INS42 INS14 INS68 INS42 INS14 INS52 INS42 INS22 INS42 INS22 INS9 INS52 INS42 INS60 INS42 INS42 INS32 INS22 INS52 INS42 INS6 INS52 INS42 INS21 INS42 INS43 INS21 INS25 INS21 INS36 INS36 INS38 INS62 INS53 INS52 INS32 INS62 INS8 INS8 INS27 INS42 INS42 INS42 INS22 INS42 INS42 INS52 INS42 INS25 INS42 INS43 INS25 INS42 INS42 INS42 INS42 INS38 INS62 INS53 INS42 INS42 MOV32 INS42 MOV32 INS42 INS43 MOV21 INS42 INS42 INS42 INS25 INS25 INS42 INS42 INS42 INS42 INS32 INS25 INS67 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS66 INS42 INS66 INS42 INS66 INS39 INS85 INS42 INS32 INS25 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS60 INS60 INS25 INS62 INS8 INS25 INS67 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS42 INS42 INS66 INS42 INS66 INS42 INS66 INS39 INS85 INS42 INS32 INS25 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS60 INS60 INS25 INS62 MOV8 INS25 INS60 INS60 INS25 INS60 INS25 INS42 INS42 INS42 INS32 INS42 INS43 INS21 INS42 INS42 INS42 INS42 INS43 INS60 INS25 INS41 INS41 INS42 INS43 INS60 INS25 INS41 INS22 INS33 INS60 INS25 INS41 INS22 INS33 INS60 INS25 INS54 INS41 INS42 INS32 INS42 INS42 INS33 INS42 INS33 INS25 INS25 INS42 INS42 INS42 INS42 INS42 INS21 INS27 MOV8 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS21 INS25 INS42 INS9 MOV21 MOV25 MOV60 MOV25 INS25 INS21 INS25 INS42 INS42 INS21 INS21 INS54 INS21 INS25 MOV21 INS32 INS22 INS43 INS42 INS33 INS33 INS41 INS44 INS8 INS44 INS8 MOV21 INS44 INS8 INS21 INS44 INS8 INS42 INS8 INS42 INS42 INS42 INS42 INS32 INS25 INS41 INS22 INS42 INS52 INS42 INS42 INS42 INS62 INS8 INS8 INS27 INS8 MOV22 INS32 INS32 INS32 INS32 INS22 INS42 INS42 INS32 INS22 INS9 INS42 INS43 INS25 INS42 INS42 INS42 INS52 INS62 INS62 INS53 INS22 INS9 INS42 INS42 INS32 INS42 INS43 INS25 INS42 INS42 INS32 INS42 INS43 INS21 INS21 INS21 INS62 INS62 INS53 INS22 INS9 INS22 INS43 INS22 INS42 INS52 INS42 INS22 INS42 INS22 INS42 INS52 INS42 INS32 INS14 MOV14 INS52 INS42 INS42 INS42 INS69 INS69 INS69 INS69 INS69 INS69 INS69 INS69 INS69 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS69 INS69 INS69 INS69 INS69 INS69 INS69 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS69 INS69 INS69 INS69 INS69 INS69 INS69 INS69 INS69 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 MOV32 INS52 INS42 INS52 INS42 INS78 INS43 INS59 INS42 INS42 INS32 INS52 INS42 INS38 INS32 INS42 INS32 INS38 INS8 INS32 INS62 INS62 INS22 INS42 INS43 INS14 INS42 INS32 INS42 INS42 INS43 INS41 INS41 INS45 INS32 INS52 INS42 INS62 INS8 INS42 INS32 INS8 INS8 INS22 INS42 INS43 INS14 UPD42 UPD42 INS42 INS7 INS32 INS8 INS62 INS8 MOV25 INS42 INS62 INS8 INS42 INS42 INS42 INS27 INS8 INS8 INS42 INS42 INS79 INS83 INS43 INS59 INS83 INS39 INS59 INS62 INS8 INS8 INS42 INS5 INS21 INS62 INS8 INS8 INS42 INS42 INS42 INS27 INS8 INS42 INS42 INS83 INS43 INS59 INS83 INS39 INS59 INS62 INS8 INS8 INS42 INS5 INS27 INS8 INS8 INS39 INS59 INS43 INS59 INS27 INS8 INS79 INS43 INS59 INS27 INS41 INS42 INS9 INS42 INS7 INS42 INS43 INS59 INS38 INS8 INS42 INS33 INS42 INS43 INS59 INS38 INS8 INS42 INS52 INS42 INS83 INS43 INS59 INS62 INS8 INS25 INS22 INS52 INS42 INS83 INS43 INS59 INS27 INS8 INS8 INS8 INS12 INS22 INS42 INS32 INS8 INS8 INS62 INS8 INS7 INS42 INS33 INS21 UPD42 MOV42 MOV42 MOV22 MOV42 MOV52 INS32 INS7 INS62 INS8 INS27 INS8 INS7 INS27 INS8 INS8 INS32 INS43 INS32 INS8 INS8 INS32 MOV32 MOV8 INS42 INS22 INS52 INS42 INS42 INS32 INS43 INS42 INS53 INS43 INS42 INS53 INS32 INS43 INS42 MOV21 INS32 INS43 INS42 INS21 INS25 INS25 INS42 INS62 INS8 INS33 INS52 INS42 INS78 INS42 INS43 INS21 INS21 INS32 UPD42 INS27 INS38 INS53 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS32 UPD42 INS32 INS32 INS32 INS42 INS32 INS52 INS42 INS42 INS52 INS42 INS42 INS32 INS8 INS8 INS22 INS43 INS22 INS43 INS14 INS52 INS42 INS42 INS42 INS32 INS8 INS8 INS42 INS42 INS32 INS7 INS32 INS22 INS43 INS22 INS43 INS14 INS52 INS42 INS52 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 UPD42 INS40 INS42 INS43 INS11 INS43 INS43 MOV43 MOV43 MOV43 INS39 INS43 INS39 INS43 INS43 INS43 MOV43 INS39 INS43 INS39 INS39 INS43 INS43 MOV43 INS43 INS43 INS39 INS43 INS39 INS39 MOV21 INS32 MOV21 INS32 INS42 INS42 INS42 INS32 INS25 INS42 INS36 INS42 INS42 MOV22 INS52 INS42 INS42 INS52 INS32 INS21 INS21 INS41 INS42 INS42 INS33 INS22 INS43 INS22 INS43 INS52 INS42 INS42 INS43 INS45 INS42 INS42 INS32 INS9 INS32 INS42 INS42 INS43 INS25 INS42 INS42 INS21 INS60 INS21 INS25 INS25 INS52 INS42 INS42 INS43 INS45 INS42 INS32 INS42 INS9 INS60 INS25 INS41 INS42 INS43 INS41 INS42 INS43 INS25 INS52 INS32 INS33 INS21 INS41 INS25 INS42 INS42 INS42 INS42 INS11 INS42 INS32 INS42 INS43 INS25 INS21 INS39 INS85 INS32 INS42 INS43 INS60 INS60 INS25 INS21 INS27 INS62 INS21 INS41 INS42 INS42 INS11 INS42 INS32 INS42 INS43 INS25 INS21 INS39 INS85 INS38 INS62 INS60 INS60 INS25 INS21 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS41 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS42 INS42 INS32 INS42 INS42 INS11 INS32 INS41 INS42 INS42 INS11 INS32 INS41 INS42 INS42 INS32 INS42 INS43 INS41 INS62 INS8 INS8 INS52 INS42 INS42 INS42 INS22 INS33 INS21 INS25 INS21 INS41 INS44 INS8 INS52 INS42 INS42 INS42 INS21 MOV21 INS42 INS43 INS21 INS21 INS21 INS42 INS32 INS7 INS7 INS52 INS42 INS42 INS42 INS42 INS43 INS25 INS21 INS21 INS38 INS62 INS62 INS21 INS42 INS33 MOV27 INS42 INS21 INS32 INS42 INS42 INS42 INS42 INS42 MOV41 INS21 INS42 INS42 UPD42 INS52 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS14 INS42 INS42 INS32 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS32 INS42 INS8 INS62 INS8 INS42 INS43 INS25 INS52 INS42 INS42 INS7 INS7 INS42 INS22 INS33 INS22 INS14 INS32 MOV42 INS32 MOV42 MOV42 MOV42 INS32 MOV42 MOV42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS21 INS21 INS21 INS52 INS42 INS42 INS52 INS42 INS42 INS43 INS45 INS42 INS42 INS21 INS21 INS21 INS21 INS42 INS42 INS52 INS22 INS32 INS42 INS42 INS33 INS52 INS42 INS42 INS52 INS42 INS42 INS43 INS45 INS42 INS43 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS9 MOV32 INS9 INS42 INS42 INS42 INS42 INS42 INS33 INS33 INS9 MOV32 INS9 INS42 INS62 INS8 MOV25 INS62 INS36 INS42 INS32 INS7 INS52 INS42 INS42 INS52 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS8 INS8 INS32 INS39 INS59 INS32 INS42 INS8 INS38 INS8 INS42 INS36 INS42 INS79 INS43 INS59 INS27 INS8 INS42 INS42 INS32 INS42 INS38 INS8 INS42 INS32 INS27 INS8 INS43 INS42 INS42 INS42 INS42 INS32 INS8 INS8 INS32 INS42 INS42 INS11 INS9 INS42 INS43 INS59 MOV43 INS59 INS62 INS8 INS8 INS32 INS22 INS33 INS22 INS43 INS32 INS43 INS42 INS42 INS42 INS42 INS32 INS8 INS8 INS32 INS42 UPD42 INS11 UPD9 INS32 INS42 INS43 INS43 INS59 MOV43 INS59 INS62 MOV8 MOV8 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS36 INS42 INS43 INS42 INS42 INS42 INS33 INS43 INS42 INS42 INS42 INS33 INS42 INS42 INS32 INS42 INS43 INS41 INS41 INS52 INS42 INS7 INS62 INS8 INS25 INS7 INS32 INS43 INS42 INS53 INS7 INS7 INS42 INS7 INS7 INS7 INS42 INS42 INS42 MOV32 INS42 INS33 INS42 INS38 INS8 INS7 INS7 INS42 INS42 INS43 INS42 INS43 INS32 INS42 INS7 INS42 INS42 MOV42 UPD42 INS32 INS7 INS7 INS43 INS32 INS42 INS43 INS32 INS42 INS42 INS45 INS42 INS42 INS45 INS25 INS42 INS43 INS21 INS42 INS38 INS8 INS22 INS42 INS22 INS33 INS52 INS42 INS22 INS42 INS43 INS45 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS32 INS32 INS42 INS32 INS7 INS32 INS7 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS32 INS42 INS43 INS41 INS42 INS43 INS11 INS42 INS42 INS33 INS22 INS33 INS42 INS36 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS14 INS42 INS36 INS42 INS42 INS33 INS21 INS41 INS32 INS21 INS41 INS11 INS42 INS42 INS42 INS42 INS32 INS27 INS42 INS21 INS36 INS42 INS32 INS41 INS42 INS42 INS32 INS9 INS27 INS62 INS21 INS41 INS42 INS42 INS42 INS21 INS25 INS42 INS42 INS42 INS42 INS5 INS42 INS42 INS42 INS11 INS42 INS32 INS42 INS5 INS21 INS21 INS21 INS42 INS42 INS42 INS9 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS22 INS9 INS42 INS42 INS42 INS21 INS25 INS42 INS42 INS42 INS42 INS5 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS32 INS42 INS5 INS42 INS42 INS42 INS9 INS42 INS11 INS42 INS42 INS36 INS42 INS42 INS32 INS42 INS42 INS32 INS42 MOV5 INS41 INS62 INS8 INS42 INS22 INS42 INS42 INS42 INS42 INS14 INS42 INS32 INS42 MOV32 INS22 INS11 INS42 INS33 INS42 INS33 INS32 INS60 INS25 INS32 INS21 INS21 INS42 INS9 INS42 INS9 INS42 INS42 INS42 INS42 INS11 INS11 INS42 INS40 INS42 INS42 INS42 INS42 INS33 INS42 INS33 INS42 INS40 INS42 INS42 INS40 INS42 INS62 INS8 INS42 INS7 INS32 INS41 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS36 INS42 INS42 INS42 INS33 INS36 INS42 INS42 INS42 INS14 INS22 INS32 INS42 INS42 INS33 INS22 INS32 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS9 INS40 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS9 MOV32 MOV32 INS42 INS42 INS42 INS42 INS42 INS33 MOV32 INS9 INS40 MOV32 INS42 INS42 INS42 INS42 INS42 INS33 MOV32 INS9 MOV32 MOV32 INS42 INS32 INS42 INS43 INS42 INS52 INS42 INS11 INS32 INS32 INS43 INS38 INS7 INS36 INS42 INS7 INS43 INS42 INS42 INS42 INS22 INS7 INS11 INS36 INS42 INS33 INS42 INS22 INS33 INS22 INS43 INS32 INS32 INS27 INS8 INS8 INS39 INS85 INS43 INS42 INS42 INS42 INS39 INS85 INS32 INS32 INS32 INS52 INS42 INS32 INS27 INS8 MOV8 INS39 INS85 INS43 INS42 INS42 INS42 INS39 INS85 INS43 INS42 INS11 INS36 INS42 INS42 INS11 INS42 INS43 INS41 INS52 INS42 INS43 INS45 INS42 INS42 INS42 INS52 INS42 INS43 INS42 INS42 INS42 INS78 INS43 INS59 INS32 INS8 INS8 INS36 INS42 INS32 INS7 INS43 INS42 INS43 INS42 INS42 INS43 INS21 INS42 INS32 INS36 INS42 INS33 INS43 INS11 INS11 INS43 INS52 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS36 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS32 INS22 INS33 INS11 INS22 INS33 INS42 INS52 INS42 INS42 INS32 INS43 INS42 INS11 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS22 INS9 INS42 INS42 INS42 INS42 INS38 INS42 INS60 INS21 INS25 INS21 INS42 INS42 INS42 INS11 INS9 INS42 INS11 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS38 INS42 INS21 INS42 INS42 UPD42 INS11 INS42 UPD42 INS42 INS42 INS43 INS42 INS11 INS5 INS42 INS42 INS32 INS42 INS42 INS42 INS42 MOV42 INS42 INS42 INS21 INS25 INS21 INS25 INS11 INS42 INS42 INS42 INS9 INS42 INS42 INS7 INS42 INS7 INS36 INS42 INS11 INS42 INS43 INS42 INS43 INS42 INS42 INS11 INS42 INS43 INS36 INS42 INS52 INS42 INS43 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS52 INS42 INS42 INS5 INS59 INS32 INS42 INS8 INS32 INS5 INS42 INS5 INS42 INS42 INS32 INS5 INS42 INS42 INS43 INS42 INS39 INS85 INS36 INS42 INS32 INS32 INS8 INS8 INS32 INS32 INS8 INS8 INS43 INS42 INS42 INS40 INS42 INS32 INS11 INS43 INS42 INS42 INS42 INS43 INS42 INS42 INS11 INS42 INS42 INS39 INS85 INS42 INS32 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS32 INS9 INS39 INS85 INS39 INS85 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS39 INS85 INS42 INS11 INS42 INS42 INS14 INS42 INS42 INS21 INS21 INS42 INS42 INS33 INS42 INS42 INS21 INS21 INS42 INS36 INS42 INS43 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 MOV43 INS42 INS43 INS7 INS7 INS7 INS7 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS43 INS42 INS42 INS42 INS22 MOV42 UPD42 MOV42 MOV42 MOV9 INS42 INS42 INS22 INS42 INS42 INS42 INS9 INS42 INS52 INS42 INS52 INS42 DEL14 DEL9 DEL42 DEL52 DEL42 DEL22 DEL42 DEL43 DEL40 DEL14 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL9 DEL17 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL17 DEL42 DEL42 DEL42 DEL42 DEL9 DEL40 DEL14 DEL42 DEL42 DEL42 DEL42 DEL9 DEL14 DEL42 DEL42 DEL42 DEL42 DEL33 DEL9 DEL9 DEL14 DEL42 DEL42 DEL42 DEL33 DEL9 DEL40 DEL14 DEL42 DEL42 DEL42 DEL33 DEL9 DEL14 DEL42 DEL42 DEL42 DEL33 DEL33 DEL9 DEL9 DEL14 DEL8 DEL39 DEL42 DEL44 DEL8 DEL66 DEL42 DEL9 DEL32 DEL8 DEL66 DEL42 DEL8 DEL33 DEL42 DEL42 DEL40 DEL42 DEL42 DEL25 DEL25 DEL8 DEL42 DEL32 DEL42 DEL9 DEL32 DEL83 DEL42 DEL31 DEL32 DEL59 DEL60 DEL9 DEL9 DEL9 DEL42 DEL32 DEL7 DEL21 DEL9 DEL42 DEL33 DEL9 DEL32 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL40 DEL9 DEL32 DEL42 DEL33 DEL9 DEL32 DEL9 DEL8 DEL25 DEL25 DEL83 DEL9 DEL9 DEL52 DEL42 DEL22 DEL42 DEL32 DEL52 DEL42 DEL22 DEL32 DEL52 DEL42 DEL22 DEL32 DEL52 DEL42 DEL22 DEL32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22
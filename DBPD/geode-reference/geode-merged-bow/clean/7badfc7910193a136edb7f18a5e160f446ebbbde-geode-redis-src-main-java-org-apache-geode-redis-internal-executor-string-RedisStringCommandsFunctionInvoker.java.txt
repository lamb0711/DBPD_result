GEODE-8332: Refactor inregion classes (#5320)

* the *InRegion classes are now CommandHelper and Redis*CommandFunctionExecutor.
Instead of creating an instance for every function exec
a stable instance is created at startup and reused for
the life of the server.
The implementation of an operation when an instance of RedisData does
not exist is now done in the NullRedis* classes.

-public class RedisStringCommandsFunctionExecutor implements RedisStringCommands {
+/**
+ * This class is used by netty redis string command executors
+ * to invoke a geode function that will run on a
+ * particular server to do the redis command.
+ */
+public class RedisStringCommandsFunctionInvoker implements RedisStringCommands {
-  public RedisStringCommandsFunctionExecutor(Region<ByteArrayWrapper, RedisData> region) {
+  public RedisStringCommandsFunctionInvoker(Region<ByteArrayWrapper, RedisData> region) {
-    return CommandFunction.execute(APPEND, key, valueToAppend, region);
+    return CommandFunction.invoke(APPEND, key, valueToAppend, region);
-    return CommandFunction.execute(GET, key, null, region);
+    return CommandFunction.invoke(GET, key, null, region);
-    return CommandFunction.execute(SET, key, new Object[] {value, options}, region);
+    return CommandFunction.invoke(SET, key, new Object[] {value, options}, region);
-    return CommandFunction.execute(INCR, key, null, region);
+    return CommandFunction.invoke(INCR, key, null, region);
-    return CommandFunction.execute(DECR, key, null, region);
+    return CommandFunction.invoke(DECR, key, null, region);
-    return CommandFunction.execute(GETSET, key, value, region);
+    return CommandFunction.invoke(GETSET, key, value, region);
-    return CommandFunction.execute(INCRBY, key, increment, region);
+    return CommandFunction.invoke(INCRBY, key, increment, region);
-    return CommandFunction.execute(DECRBY, key, decrement, region);
+    return CommandFunction.invoke(DECRBY, key, decrement, region);
-    return CommandFunction.execute(GETRANGE, key, new Object[] {start, end}, region);
+    return CommandFunction.invoke(GETRANGE, key, new Object[] {start, end}, region);
-    return CommandFunction.execute(BITCOUNT, key, new Object[] {start, end}, region);
+    return CommandFunction.invoke(BITCOUNT, key, new Object[] {start, end}, region);
-    return CommandFunction.execute(BITCOUNT, key, null, region);
+    return CommandFunction.invoke(BITCOUNT, key, null, region);
-    return CommandFunction.execute(STRLEN, key, null, region);
+    return CommandFunction.invoke(STRLEN, key, null, region);
-    return CommandFunction.execute(GETBIT, key, offset, region);
+    return CommandFunction.invoke(GETBIT, key, offset, region);
-    return CommandFunction.execute(SETBIT, key, new Object[] {offset, value}, region);
+    return CommandFunction.invoke(SETBIT, key, new Object[] {offset, value}, region);
-    return CommandFunction.execute(INCRBYFLOAT, key, increment, region);
+    return CommandFunction.invoke(INCRBYFLOAT, key, increment, region);
-    return CommandFunction.execute(BITOP, destKey, new Object[] {operation, sources}, region);
+    return CommandFunction.invoke(BITOP, destKey, new Object[] {operation, sources}, region);
-    return CommandFunction.execute(BITPOS, key, new Object[] {bit, start, end}, region);
+    return CommandFunction.invoke(BITPOS, key, new Object[] {bit, start, end}, region);
-    return CommandFunction.execute(SETRANGE, key, new Object[] {offset, value}, region);
+    return CommandFunction.invoke(SETRANGE, key, new Object[] {offset, value}, region);
-    return CommandFunction.execute(MGET, key, null, region);
+    return CommandFunction.invoke(MGET, key, null, region);

INS29 UPD42 INS65 UPD42 INS66 INS66 INS66 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42
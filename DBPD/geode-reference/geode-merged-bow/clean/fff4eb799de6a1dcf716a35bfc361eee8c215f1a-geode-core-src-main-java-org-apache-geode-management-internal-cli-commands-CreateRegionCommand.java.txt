GEODE-6103 RegionCreateFunction takes RegionConfig in argument (#2998)

* reduce dependence on RegionFunctionArgs
* Also clean up CreateRegionCommand to achieve a clean separation between validations and calling RegionCreateFunction

Signed-off-by: Aditya Anchuri <aanchuri@pivotal.io>
Signed-off-by: Peter Tran <ptran@pivotal.io>
Signed-off-by: Ken Howe <khowe@pivotal.io>
+import java.util.HashSet;
+import java.util.Optional;
-import org.apache.geode.cache.DataPolicy;
+import org.apache.geode.management.internal.cli.domain.PartitionArgs;
+import org.apache.geode.management.internal.cli.functions.CreateRegionFunctionArgs;
-import org.apache.geode.management.internal.cli.functions.RegionFunctionArgs;
+    try {
+      failIfRegionAlreadyExists(regionPath, regionShortcut, groups);
+    } catch (EntityExistsException e) {
+      return ifNotExists ? ResultModel.createInfo("Skipping: " + e.getMessage())
+          : ResultModel.createError(e.getMessage());
+    }
+
-    /*
-     * Adding name collision check for regions created with regionShortcut only.
-     * Regions can be categories as Proxy(replicate/partition), replicate/partition, and local
-     * For concise purpose: we call existing region (E) and region to be created (C)
-     */
-    DistributedRegionMXBean regionBean =
-        getManagementService().getDistributedRegionMXBean(regionPath);
-
-    if (regionBean != null && regionShortcut != null) {
-      String existingDataPolicy = regionBean.getRegionType();
-      // either C is local, or E is local or E and C are both non-proxy regions. this is to make
-      // sure local, replicate or partition regions have unique names across the entire cluster
-      if (regionShortcut.isLocal() || existingDataPolicy.equals("NORMAL")
-          || !regionShortcut.isProxy()
-              && (regionBean.getMemberCount() > regionBean.getEmptyNodes())) {
-        throw new EntityExistsException(
-            String.format("Region %s already exists on the cluster.", regionPath), ifNotExists);
-      }
-
-      // after this, one of E and C is proxy region or both are proxy regions.
-
-      // we first make sure E and C have the compatible data policy
-      if (regionShortcut.isPartition() && !existingDataPolicy.contains("PARTITION")) {
-        LogService.getLogger().info("Create region command: got EntityExists exception");
-        throw new EntityExistsException("The existing region is not a partitioned region",
-            ifNotExists);
-      }
-      if (regionShortcut.isReplicate()
-          && !(existingDataPolicy.equals("EMPTY") || existingDataPolicy.contains("REPLICATE")
-              || existingDataPolicy.contains("PRELOADED"))) {
-        throw new EntityExistsException("The existing region is not a replicate region",
-            ifNotExists);
-      }
-      // then we make sure E and C are on different members
-      Set<String> membersWithThisRegion =
-          Arrays.stream(regionBean.getMembers()).collect(Collectors.toSet());
-      Set<String> membersWithinGroup = findMembers(groups, null).stream()
-          .map(DistributedMember::getName).collect(Collectors.toSet());
-      if (!Collections.disjoint(membersWithinGroup, membersWithThisRegion)) {
-        throw new EntityExistsException(
-            String.format("Region %s already exists on these members: %s.", regionPath,
-                StringUtils.join(membersWithThisRegion, ",")),
-            ifNotExists);
-      }
-    }
-
-    // validating the parent region
+    // validate the parent region
-    String parentRegionPath = regionPathData.getParent();
-    if (parentRegionPath != null && !Region.SEPARATOR.equals(parentRegionPath)) {
-      if (!regionExists(cache, parentRegionPath)) {
-        return ResultModel.createError(
-            CliStrings.format(CliStrings.CREATE_REGION__MSG__PARENT_REGION_FOR_0_DOES_NOT_EXIST,
-                new Object[] {regionPath}));
-      }
+    if (!regionPathData.isRoot() && !regionExists(regionPathData.getParent())) {
+      return ResultModel.createError(
+          CliStrings.format(CliStrings.CREATE_REGION__MSG__PARENT_REGION_FOR_0_DOES_NOT_EXIST,
+              new Object[] {regionPath}));
-    // creating the RegionFunctionArgs
-    RegionFunctionArgs functionArgs = new RegionFunctionArgs();
-    functionArgs.setRegionPath(regionPath);
-    functionArgs.setIfNotExists(ifNotExists);
-    functionArgs.setStatisticsEnabled(statisticsEnabled);
-    functionArgs.setEntryExpirationIdleTime(entryExpirationIdleTime, entryExpirationIdleTimeAction);
-    functionArgs.setEntryExpirationTTL(entryExpirationTTL, entryExpirationTTLAction);
-    functionArgs.setRegionExpirationIdleTime(regionExpirationIdleTime,
-        regionExpirationIdleTimeAction);
-    functionArgs.setRegionExpirationTTL(regionExpirationTTL, regionExpirationTTLAction);
-    functionArgs.setEntryIdleTimeCustomExpiry(entryIdleTimeCustomExpiry);
-    functionArgs.setEntryTTLCustomExpiry(entryTTLCustomExpiry);
-    functionArgs.setEvictionAttributes(evictionAction, evictionMaxMemory, evictionEntryCount,
-        evictionObjectSizer);
-    functionArgs.setDiskStore(diskStore);
-    functionArgs.setDiskSynchronous(diskSynchronous);
-    functionArgs.setEnableAsyncConflation(enableAsyncConflation);
-    functionArgs.setEnableSubscriptionConflation(enableSubscriptionConflation);
-    functionArgs.setAsyncEventQueueIds(asyncEventQueueIds);
-    functionArgs.setGatewaySenderIds(gatewaySenderIds);
-    functionArgs.setConcurrencyChecksEnabled(concurrencyChecksEnabled);
-    functionArgs.setCloningEnabled(cloningEnabled);
-    functionArgs.setConcurrencyLevel(concurrencyLevel);
-    functionArgs.setPartitionArgs(prColocatedWith, prLocalMaxMemory, prRecoveryDelay,
-        prRedundantCopies, prStartupRecoveryDelay, prTotalMaxMemory, prTotalNumBuckets,
-        partitionResolver);
-    functionArgs.setOffHeap(offHeap);
-    functionArgs.setMcastEnabled(mcastEnabled);
+    // validate if partition args are supplied only for partitioned regions
+    PartitionArgs partitionArgs =
+        new PartitionArgs(prColocatedWith, prLocalMaxMemory, prRecoveryDelay,
+            prRedundantCopies, prStartupRecoveryDelay, prTotalMaxMemory, prTotalNumBuckets,
+            partitionResolver);
+    if (regionShortcut != null && !regionShortcut.name().startsWith("PARTITION")
+        && !partitionArgs.isEmpty()) {
+      return ResultModel.createError(CliStrings.format(
+          CliStrings.CREATE_REGION__MSG__OPTION_0_CAN_BE_USED_ONLY_FOR_PARTITIONEDREGION,
+          partitionArgs.getUserSpecifiedPartitionAttributes()) + " "
+          + CliStrings.format(CliStrings.CREATE_REGION__MSG__0_IS_NOT_A_PARITIONEDREGION,
+              regionPath));
+    }
-    RegionAttributes<?, ?> regionAttributes = null;
-    if (regionShortcut != null) {
-      if (!regionShortcut.name().startsWith("PARTITION") && functionArgs.hasPartitionAttributes()) {
-        return ResultModel.createError(CliStrings.format(
-            CliStrings.CREATE_REGION__MSG__OPTION_0_CAN_BE_USED_ONLY_FOR_PARTITIONEDREGION,
-            functionArgs.getPartitionArgs().getUserSpecifiedPartitionAttributes()) + " "
-            + CliStrings.format(CliStrings.CREATE_REGION__MSG__0_IS_NOT_A_PARITIONEDREGION,
-                regionPath));
-      }
-      functionArgs.setRegionShortcut(regionShortcut);
-      functionArgs.setRegionAttributes(cache.getRegionAttributes(regionShortcut.toString()));
-    } else { // templateRegion != null
-      if (!regionExists(cache, templateRegion)) {
+    // validate colocation for partitioned regions
+    if (prColocatedWith != null) {
+      DistributedRegionMXBean colocatedRegionBean =
+          getManagementService().getDistributedRegionMXBean(prColocatedWith);
+
+      if (colocatedRegionBean == null) {
-            CliStrings.CREATE_REGION__USEATTRIBUTESFROM, templateRegion));
+            CliStrings.CREATE_REGION__COLOCATEDWITH, prColocatedWith));
-      RegionAttributesWrapper<?, ?> wrappedAttributes = getRegionAttributes(cache, templateRegion);
+      if (!colocatedRegionBean.getRegionType().equals("PARTITION") &&
+          !colocatedRegionBean.getRegionType().equals("PERSISTENT_PARTITION")) {
+        return ResultModel.createError(CliStrings.format(
+            CliStrings.CREATE_REGION__MSG__COLOCATEDWITH_REGION_0_IS_NOT_PARTITIONEDREGION,
+            new String[] {prColocatedWith}));
+      }
+    }
-      if (wrappedAttributes == null) {
+    // validate gateway senders
+    if (gatewaySenderIds != null) {
+      Set<String> existingGatewaySenders =
+          Arrays.stream(getDSMBean().listGatewaySenders()).collect(Collectors.toSet());
+      if (existingGatewaySenders.isEmpty()) {
+        return ResultModel
+            .createError(CliStrings.CREATE_REGION__MSG__NO_GATEWAYSENDERS_IN_THE_SYSTEM);
+      }
+
+      if (Arrays.stream(gatewaySenderIds).anyMatch(id -> !existingGatewaySenders.contains(id))) {
+        return ResultModel.createError(CliStrings.format(
+            CliStrings.CREATE_REGION__MSG__SPECIFY_VALID_GATEWAYSENDER_ID_UNKNOWN_0,
+            (Object[]) gatewaySenderIds));
+      }
+    }
+
+    // validate if template region exists, if provided
+    if (templateRegion != null && !regionExists(templateRegion)) {
+      return ResultModel.createError(CliStrings.format(
+          CliStrings.CREATE_REGION__MSG__SPECIFY_VALID_REGION_PATH_FOR_0_REGIONPATH_1_NOT_FOUND,
+          CliStrings.CREATE_REGION__USEATTRIBUTESFROM, templateRegion));
+    }
+
+    // get predefined attributes for a template region
+    RegionAttributesWrapper<?, ?> wrappedTemplateAttributes = null;
+    if (templateRegion != null) {
+      wrappedTemplateAttributes = getRegionAttributes(cache, templateRegion);
+      if (wrappedTemplateAttributes == null) {
-      if (wrappedAttributes.getRegionAttributes().getPartitionAttributes() == null
-          && functionArgs.hasPartitionAttributes()) {
+      if (wrappedTemplateAttributes.getRegionAttributes().getPartitionAttributes() == null
+          && !partitionArgs.isEmpty()) {
-            functionArgs.getPartitionArgs().getUserSpecifiedPartitionAttributes()) + " "
+            partitionArgs.getUserSpecifiedPartitionAttributes()) + " "
-      functionArgs.setTemplateRegion(templateRegion);
-
-      // These attributes will have the actual callback fields (if previously present) nulled out.
-      functionArgs.setRegionAttributes(wrappedAttributes.getRegionAttributes());
-
-      functionArgs
-          .setCacheListeners(wrappedAttributes.getCacheListenerClasses().toArray(new ClassName[0]));
-      functionArgs.setCacheWriter(wrappedAttributes.getCacheWriterClass());
-      functionArgs.setCacheLoader(wrappedAttributes.getCacheLoaderClass());
-      functionArgs.setCompressor(wrappedAttributes.getCompressorClass());
-      functionArgs.setKeyConstraint(wrappedAttributes.getKeyConstraintClass());
-      functionArgs.setValueConstraint(wrappedAttributes.getValueConstraintClass());
-    if (cacheListener != null) {
-      functionArgs.setCacheListeners(cacheListener);
-    }
-
-    if (cacheLoader != null) {
-      functionArgs.setCacheLoader(cacheLoader);
-    }
-
-    if (cacheWriter != null) {
-      functionArgs.setCacheWriter(cacheWriter);
-    }
-
-    if (compressor != null) {
-      functionArgs.setCompressor(compressor);
-    }
-
-    if (keyConstraint != null) {
-      functionArgs.setKeyConstraint(keyConstraint);
-    }
-
-    if (valueConstraint != null) {
-      functionArgs.setValueConstraint(valueConstraint);
-    }
-
-    DistributedSystemMXBean dsMBean = getDSMBean();
-    // validating colocation
-    if (functionArgs.hasPartitionAttributes()) {
-      if (prColocatedWith != null) {
-        ManagementService mgmtService = getManagementService();
-        DistributedRegionMXBean distributedRegionMXBean =
-            mgmtService.getDistributedRegionMXBean(prColocatedWith);
-        if (distributedRegionMXBean == null) {
-          return ResultModel.createError(CliStrings.format(
-              CliStrings.CREATE_REGION__MSG__SPECIFY_VALID_REGION_PATH_FOR_0_REGIONPATH_1_NOT_FOUND,
-              CliStrings.CREATE_REGION__COLOCATEDWITH, prColocatedWith));
-        }
-        String regionType = distributedRegionMXBean.getRegionType();
-        if (!(DataPolicy.PARTITION.toString().equals(regionType)
-            || DataPolicy.PERSISTENT_PARTITION.toString().equals(regionType))) {
-          return ResultModel.createError(CliStrings.format(
-              CliStrings.CREATE_REGION__MSG__COLOCATEDWITH_REGION_0_IS_NOT_PARTITIONEDREGION,
-              new Object[] {prColocatedWith}));
-        }
-      }
-    }
-
-    // validating gateway senders
-    if (gatewaySenderIds != null) {
-      Set<String> existingGatewaySenders =
-          Arrays.stream(dsMBean.listGatewaySenders()).collect(Collectors.toSet());
-      if (existingGatewaySenders.size() == 0) {
-        return ResultModel
-            .createError(CliStrings.CREATE_REGION__MSG__NO_GATEWAYSENDERS_IN_THE_SYSTEM);
-      } else {
-        Set<String> specifiedGatewaySenders =
-            Arrays.stream(gatewaySenderIds).collect(Collectors.toSet());
-        specifiedGatewaySenders.removeAll(existingGatewaySenders);
-        if (!specifiedGatewaySenders.isEmpty()) {
-          return ResultModel.createError(CliStrings.format(
-              CliStrings.CREATE_REGION__MSG__SPECIFY_VALID_GATEWAYSENDER_ID_UNKNOWN_0,
-              (Object[]) gatewaySenderIds));
-        }
-      }
+    RegionAttributes<?, ?> regionAttributes;
+    if (wrappedTemplateAttributes != null) {
+      regionAttributes = wrappedTemplateAttributes.getRegionAttributes();
+    } else {
+      regionAttributes = cache.getRegionAttributes(regionShortcut.toString());
-    if (diskStore != null) {
-      regionAttributes = functionArgs.getRegionAttributes();
-      if (regionAttributes != null && !regionAttributes.getDataPolicy().withPersistence()) {
-        String subMessage =
-            "Only regions with persistence or overflow to disk can specify DiskStore";
-        String message = subMessage + ". "
-            + CliStrings.format(
-                CliStrings.CREATE_REGION__MSG__USE_ATTRIBUTES_FROM_REGION_0_IS_NOT_WITH_PERSISTENCE,
-                new Object[] {String.valueOf(functionArgs.getTemplateRegion())});
+    if (diskStore != null && !regionAttributes.getDataPolicy().withPersistence()) {
+      String subMessage = "Only regions with persistence or overflow to disk can specify DiskStore";
+      String message = subMessage + ". "
+          + CliStrings.format(
+              CliStrings.CREATE_REGION__MSG__USE_ATTRIBUTES_FROM_REGION_0_IS_NOT_WITH_PERSISTENCE,
+              new Object[] {templateRegion});
-        return ResultModel.createError(message);
-      }
+      return ResultModel.createError(message);
+    }
-      if (!diskStoreExists(cache, diskStore)) {
-        return ResultModel.createError(CliStrings.format(
-            CliStrings.CREATE_REGION__MSG__SPECIFY_VALID_DISKSTORE_UNKNOWN_DISKSTORE_0,
-            new Object[] {diskStore}));
-      }
+    if (diskStore != null && !diskStoreExists(diskStore)) {
+      return ResultModel.createError(CliStrings.format(
+          CliStrings.CREATE_REGION__MSG__SPECIFY_VALID_DISKSTORE_UNKNOWN_DISKSTORE_0,
+          new Object[] {diskStore}));
-    if ((functionArgs.getRegionShortcut() != null
-        && functionArgs.getRegionShortcut().isPersistent())
-        || isAttributePersistent(functionArgs.getRegionAttributes())) {
+    if (isAttributePersistent(regionAttributes)) {
-    // just in case we found no members with this group name
-      } else {
-        return ResultModel.createError(
-            CliStrings.format(CliStrings.CREATE_REGION__MSG__GROUPS_0_ARE_INVALID,
-                (Object[]) groups));
+
+      return ResultModel.createError(
+          CliStrings.format(CliStrings.CREATE_REGION__MSG__GROUPS_0_ARE_INVALID,
+              (Object[]) groups));
+    // generate the RegionConfig object for passing to distributed function and persisting
+    Set<ClassName<CacheListener>> cacheListeners = new HashSet<>();
+    if (cacheListener != null) {
+      Arrays.stream(cacheListener).forEach(c -> cacheListeners.add(c));
+    } else if (wrappedTemplateAttributes != null
+        && wrappedTemplateAttributes.getCacheListenerClasses() != null) {
+      cacheListeners.addAll(wrappedTemplateAttributes.getCacheListenerClasses());
+    }
+
+    ClassName<CacheLoader> cacheLoaderClassNameToPersist = null;
+    if (cacheLoader != null) {
+      cacheLoaderClassNameToPersist = cacheLoader;
+    } else if (wrappedTemplateAttributes != null
+        && wrappedTemplateAttributes.getCacheLoaderClass() != null) {
+      cacheLoaderClassNameToPersist = wrappedTemplateAttributes.getCacheLoaderClass();
+    }
+
+    ClassName<CacheWriter> cacheWriterClassNameToPersist = null;
+    if (cacheWriter != null) {
+      cacheWriterClassNameToPersist = cacheWriter;
+    } else if (wrappedTemplateAttributes != null
+        && wrappedTemplateAttributes.getCacheWriterClass() != null) {
+      cacheWriterClassNameToPersist = wrappedTemplateAttributes.getCacheWriterClass();
+    }
+
+    String compressorClassNameToPersist = null;
+    if (compressor != null) {
+      compressorClassNameToPersist = compressor;
+    } else if (wrappedTemplateAttributes != null
+        && wrappedTemplateAttributes.getCompressorClass() != null) {
+      compressorClassNameToPersist = wrappedTemplateAttributes.getCompressorClass();
+    }
+
+    String keyConstraintToPersist = null;
+    if (keyConstraint != null) {
+      keyConstraintToPersist = keyConstraint;
+    } else if (wrappedTemplateAttributes != null
+        && wrappedTemplateAttributes.getKeyConstraintClass() != null) {
+      keyConstraintToPersist = wrappedTemplateAttributes.getKeyConstraintClass();
+    }
+
+    String valueConstraintToPersist = null;
+    if (valueConstraint != null) {
+      valueConstraintToPersist = valueConstraint;
+    } else if (wrappedTemplateAttributes != null
+        && wrappedTemplateAttributes.getValueConstraintClass() != null) {
+      valueConstraintToPersist = wrappedTemplateAttributes.getValueConstraintClass();
+    }
+
+    Set<String> asyncEventQueueIdSet = Optional.ofNullable(asyncEventQueueIds)
+        .map(a -> Arrays.stream(a).collect(Collectors.toSet()))
+        .orElse(null);
+    Set<String> gatewaySenderIdSet = Optional.ofNullable(gatewaySenderIds)
+        .map(a -> Arrays.stream(a).collect(Collectors.toSet()))
+        .orElse(null);
+
+    RegionConfig config = (new RegionConfigFactory()).generate(regionPath, keyConstraintToPersist,
+        valueConstraintToPersist, statisticsEnabled, entryExpirationIdleTime,
+        entryExpirationIdleTimeAction, entryExpirationTTL, entryExpirationTTLAction,
+        entryIdleTimeCustomExpiry,
+        entryTTLCustomExpiry, regionExpirationIdleTime, regionExpirationIdleTimeAction,
+        regionExpirationTTL, regionExpirationTTLAction, evictionAction, evictionMaxMemory,
+        evictionEntryCount, evictionObjectSizer, diskStore, diskSynchronous, enableAsyncConflation,
+        enableSubscriptionConflation, cacheListeners, cacheLoaderClassNameToPersist,
+        cacheWriterClassNameToPersist,
+        asyncEventQueueIdSet, gatewaySenderIdSet, concurrencyChecksEnabled, cloningEnabled,
+        mcastEnabled,
+        concurrencyLevel, partitionArgs, compressorClassNameToPersist, offHeap, regionAttributes);
+
+    // creating the RegionFunctionArgs
+    CreateRegionFunctionArgs functionArgs =
+        new CreateRegionFunctionArgs(regionPath, config, ifNotExists);
+
-    InternalConfigurationPersistenceService service =
-        (InternalConfigurationPersistenceService) getConfigurationPersistenceService();
-
+    InternalConfigurationPersistenceService service = getConfigurationPersistenceService();
-    // otherwise, prepare the regionConfig for persistence
+    if (resultModel.isSuccessful() && regionCreateResults.stream()
+        .anyMatch(
+            res -> res.getStatusMessage() != null && res.getStatusMessage().contains("Skipping"))) {
+      return resultModel;
+    }
+
+    // persist the RegionConfig object if the function is successful on all members
-      RegionConfig config = (new RegionConfigFactory()).generate(functionArgs);
+
-      resultModel.setConfigObject(new CreateRegionResultConfig(config,
-          functionArgs.getRegionPath()));
+      resultModel.setConfigObject(new CreateRegionResult(config, regionPath));
-  private class CreateRegionResultConfig {
+  private class CreateRegionResult {
-    public CreateRegionResultConfig(RegionConfig regionConfig, String fullRegionPath) {
+    public CreateRegionResult(RegionConfig regionConfig, String fullRegionPath) {
-    CreateRegionResultConfig regionResultConfigObject = (CreateRegionResultConfig) configObject;
+    CreateRegionResult regionResultConfigObject = (CreateRegionResult) configObject;
+  private void failIfRegionAlreadyExists(String regionPath, RegionShortcut regionShortcut,
+      String[] groups) throws EntityExistsException {
+    /*
+     * Adding name collision check for regions created with regionShortcut only.
+     * Regions can be categories as Proxy(replicate/partition), replicate/partition, and local
+     * For concise purpose: we call existing region (E) and region to be created (C)
+     */
+    DistributedRegionMXBean regionBean =
+        getManagementService().getDistributedRegionMXBean(regionPath);
+    if (regionBean == null || regionShortcut == null) {
+      return;
+    }
+
+    String existingDataPolicy = regionBean.getRegionType();
+    // either C is local, or E is local or E and C are both non-proxy regions. this is to make
+    // sure local, replicate or partition regions have unique names across the entire cluster
+    if (regionShortcut.isLocal() || existingDataPolicy.equals("NORMAL") || !regionShortcut.isProxy()
+        && (regionBean.getMemberCount() > regionBean.getEmptyNodes())) {
+      throw new EntityExistsException(
+          String.format("Region %s already exists on the cluster.", regionPath));
+    }
+
+    // after this, one of E and C is proxy region or both are proxy regions.
+
+    // we first make sure E and C have the compatible data policy
+    if (regionShortcut.isPartition() && !existingDataPolicy.contains("PARTITION")) {
+      LogService.getLogger().info("Create region command: got EntityExists exception");
+      throw new EntityExistsException("The existing region is not a partitioned region");
+    }
+
+    if (regionShortcut.isReplicate() && !existingDataPolicy.equals("EMPTY")
+        && !existingDataPolicy.contains("REPLICATE") && !existingDataPolicy.contains("PRELOADED")) {
+      throw new EntityExistsException("The existing region is not a replicate region");
+    }
+
+    // then we make sure E and C are on different members
+    Set<String> membersWithThisRegion =
+        Arrays.stream(regionBean.getMembers()).collect(Collectors.toSet());
+    Set<String> membersWithinGroup = findMembers(groups, null).stream()
+        .map(DistributedMember::getName).collect(Collectors.toSet());
+    if (!Collections.disjoint(membersWithinGroup, membersWithThisRegion)) {
+      throw new EntityExistsException(
+          String.format("Region %s already exists on these members: %s.", regionPath,
+              StringUtils.join(membersWithThisRegion, ",")));
+    }
+  }
+
-  boolean regionExists(InternalCache cache, String regionPath) {
+  boolean regionExists(String regionPath) {
-  private boolean diskStoreExists(InternalCache cache, String diskStoreName) {
+  private boolean diskStoreExists(String diskStoreName) {

MOV26 MOV26 INS26 INS26 INS40 INS40 UPD40 UPD40 INS31 UPD42 INS83 INS39 INS42 INS44 INS44 INS44 INS43 MOV8 INS54 MOV25 INS60 INS25 INS25 MOV25 MOV25 MOV60 INS25 INS25 INS25 MOV25 INS25 MOV25 INS60 INS25 INS60 INS25 INS60 INS25 INS60 INS25 INS60 INS25 MOV60 INS25 INS60 MOV60 INS60 INS60 INS25 UPD42 INS43 INS42 INS43 INS42 INS5 INS42 INS42 MOV60 INS25 INS8 INS12 INS27 INS43 INS59 INS27 INS8 MOV27 INS8 MOV27 INS8 INS27 INS27 INS8 INS27 INS8 INS8 MOV27 INS8 INS27 INS32 MOV8 MOV32 INS74 INS59 MOV27 INS8 INS25 INS74 INS59 MOV27 INS8 INS25 INS74 INS59 MOV27 MOV8 INS25 INS43 INS59 MOV27 MOV8 INS25 MOV43 INS59 MOV27 MOV8 INS25 MOV43 MOV27 INS8 INS25 MOV74 INS59 MOV74 MOV43 INS59 INS43 INS59 MOV43 INS27 INS8 UPD43 INS42 INS42 INS43 INS85 INS27 INS8 UPD27 MOV27 MOV21 INS44 INS8 INS38 INS38 INS42 INS42 INS14 MOV27 INS38 INS41 INS60 MOV25 INS25 INS60 INS25 MOV25 INS27 INS38 UPD42 INS33 INS42 INS33 INS21 MOV25 MOV25 INS42 INS33 MOV21 MOV21 MOV27 MOV60 INS60 MOV41 INS27 INS38 UPD42 MOV42 UPD42 MOV42 INS25 INS43 INS74 INS42 INS14 MOV21 INS27 INS8 INS43 INS43 INS42 INS33 INS21 INS27 INS8 INS43 INS43 INS42 INS33 INS27 MOV8 INS42 INS42 INS33 INS27 MOV8 INS42 INS33 INS27 INS8 UPD42 INS33 INS21 INS27 INS8 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS14 MOV32 INS32 INS32 INS41 UPD42 INS42 INS27 INS27 INS41 MOV32 INS38 INS38 INS38 MOV43 INS42 INS41 MOV32 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV27 INS32 INS32 MOV43 INS59 INS27 MOV8 INS74 MOV59 INS32 MOV8 INS32 INS42 INS33 MOV32 INS7 INS7 INS7 INS43 INS59 INS42 INS33 MOV32 MOV27 MOV8 INS42 MOV43 INS43 INS74 INS27 INS27 MOV21 INS42 INS42 INS7 INS27 INS27 MOV21 INS42 INS42 INS7 INS27 INS27 INS7 INS27 INS27 INS7 INS27 INS27 INS21 INS7 INS27 INS27 INS21 INS32 UPD42 MOV42 INS33 INS32 INS42 INS33 MOV36 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS43 INS42 INS42 INS42 UPD42 MOV42 INS42 MOV32 INS42 INS86 INS42 UPD43 INS42 INS33 INS42 INS33 MOV32 MOV32 MOV32 UPD42 UPD42 UPD42 INS42 INS16 UPD42 UPD42 INS42 MOV32 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS27 INS42 INS32 UPD42 INS38 INS38 INS43 INS43 UPD42 UPD42 MOV42 UPD42 MOV42 MOV32 INS42 INS86 INS42 MOV32 UPD42 INS38 INS42 INS32 INS42 MOV32 INS42 INS42 INS27 INS42 INS43 INS32 INS42 INS86 INS42 INS33 INS32 INS33 INS42 INS42 INS42 INS33 INS32 INS33 INS7 INS42 INS42 INS42 INS33 INS32 INS33 INS7 INS42 INS42 INS42 INS33 INS32 INS33 INS7 INS42 INS42 INS42 INS33 INS32 INS33 INS7 INS42 INS42 INS42 INS33 INS32 INS33 INS7 MOV32 UPD42 MOV42 INS86 INS32 INS42 INS86 INS42 UPD42 UPD42 INS59 INS27 UPD42 INS43 INS42 INS32 INS32 INS32 INS45 MOV32 MOV32 UPD42 MOV42 MOV42 INS32 INS32 INS42 INS42 INS32 INS32 INS59 INS38 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS45 MOV32 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS59 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS32 UPD42 INS42 INS42 INS59 INS32 INS42 INS42 INS42 INS59 INS32 INS42 MOV27 MOV32 UPD43 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS27 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 INS40 INS32 INS32 UPD42 MOV42 INS45 INS32 UPD42 MOV42 INS45 INS32 INS42 INS42 INS32 INS42 INS42 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 UPD40 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 UPD42 MOV42 MOV32 INS42 MOV32 MOV42 MOV32 UPD42 INS45 UPD42 INS45 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV42 MOV42 UPD40 MOV40 INS3 MOV32 INS42 UPD42 INS42 UPD42 UPD42 INS4 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS5 MOV4 INS42 MOV43 INS85 UPD42 MOV42 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL27 DEL25 DEL42 DEL38 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL45 DEL27 DEL38 DEL42 DEL42 DEL32 DEL34 DEL27 DEL60 DEL42 DEL32 DEL21 DEL8 DEL42 DEL38 DEL32 DEL42 DEL32 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL42 DEL42 DEL32 DEL38 DEL27 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL32 DEL21 DEL32 DEL21 DEL33 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL42 DEL38 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL25 DEL25 DEL25 DEL25 DEL25 DEL42 DEL43 DEL42 DEL59 DEL60 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL40 DEL32 DEL32 DEL27 DEL36 DEL38 DEL32 DEL41 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL45 DEL42 DEL42 DEL40 DEL42 DEL43 DEL85 DEL5 DEL42 DEL32 DEL4 DEL3 DEL32 DEL27 DEL59 DEL60 DEL8 DEL25 DEL8 DEL25 DEL27 DEL36 DEL42 DEL42 DEL42 DEL32 DEL32 DEL27 DEL25 DEL32 DEL85 DEL5 DEL34 DEL3 DEL32 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL40 DEL42 DEL32 DEL42 DEL32 DEL8 DEL25 DEL42 DEL43 DEL11 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL36 DEL38 DEL27 DEL42 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44
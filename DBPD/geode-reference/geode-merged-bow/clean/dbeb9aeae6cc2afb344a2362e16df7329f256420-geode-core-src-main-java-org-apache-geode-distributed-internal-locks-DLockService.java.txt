Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import org.apache.geode.*;
-import org.apache.geode.distributed.*;
+import org.apache.geode.CancelCriterion;
+import org.apache.geode.CancelException;
+import org.apache.geode.InternalGemFireError;
+import org.apache.geode.InternalGemFireException;
+import org.apache.geode.StatisticsFactory;
+import org.apache.geode.SystemFailure;
+import org.apache.geode.distributed.DistributedLockService;
+import org.apache.geode.distributed.DistributedSystem;
+import org.apache.geode.distributed.DistributedSystemDisconnectedException;
+import org.apache.geode.distributed.LeaseExpiredException;
+import org.apache.geode.distributed.LockNotHeldException;
+import org.apache.geode.distributed.LockServiceDestroyedException;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
-  
+
-  public static final long NOT_GRANTOR_SLEEP = Long.getLong(
-      DistributionConfig.GEMFIRE_PREFIX + "DLockService.notGrantorSleep", 100).longValue();
-  
-  public static final boolean DEBUG_DISALLOW_NOT_HOLDER = Boolean.getBoolean(
-      DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.disallowNotHolder");
+  public static final long NOT_GRANTOR_SLEEP = Long
+      .getLong(DistributionConfig.GEMFIRE_PREFIX + "DLockService.notGrantorSleep", 100).longValue();
-  public static final boolean DEBUG_LOCK_REQUEST_LOOP = Boolean.getBoolean(
-      DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.disallowLockRequestLoop");
+  public static final boolean DEBUG_DISALLOW_NOT_HOLDER = Boolean
+      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.disallowNotHolder");
-  public static final int DEBUG_LOCK_REQUEST_LOOP_COUNT = Integer.getInteger(
-      DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.disallowLockRequestLoopCount", 20).intValue();
+  public static final boolean DEBUG_LOCK_REQUEST_LOOP = Boolean
+      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.disallowLockRequestLoop");
-  public static final boolean DEBUG_NONGRANTOR_DESTROY_LOOP = Boolean.getBoolean(
-      DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.nonGrantorDestroyLoop");
+  public static final int DEBUG_LOCK_REQUEST_LOOP_COUNT = Integer
+      .getInteger(
+          DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.disallowLockRequestLoopCount", 20)
+      .intValue();
-  public static final int DEBUG_NONGRANTOR_DESTROY_LOOP_COUNT = Integer.getInteger(
-      DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.nonGrantorDestroyLoopCount", 20).intValue();
+  public static final boolean DEBUG_NONGRANTOR_DESTROY_LOOP = Boolean
+      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.nonGrantorDestroyLoop");
-  public static final boolean DEBUG_ENFORCE_SAFE_EXIT = Boolean.getBoolean(
-      DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.enforceSafeExit");
-  
-  public static final boolean AUTOMATE_FREE_RESOURCES = Boolean.getBoolean(
-      DistributionConfig.GEMFIRE_PREFIX + "DLockService.automateFreeResources");
-  
+  public static final int DEBUG_NONGRANTOR_DESTROY_LOOP_COUNT = Integer
+      .getInteger(
+          DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.nonGrantorDestroyLoopCount", 20)
+      .intValue();
+
+  public static final boolean DEBUG_ENFORCE_SAFE_EXIT =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.enforceSafeExit");
+
+  public static final boolean AUTOMATE_FREE_RESOURCES =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "DLockService.automateFreeResources");
+
-  
+
-  
+
-  
-  /** 
-   * DistributedSystem connection for this member 
-   * (used for DisconnectListener, logging, etc) 
+
+  /**
+   * DistributedSystem connection for this member (used for DisconnectListener, logging, etc)
-  
+
-  
-  /** 
-   * True if this member has destroyed this named locking service. Field is 
-   * volatile only because it's referenced in {@link #toString()} (never 
-   * synchronize in <code>toString</code>).
+
+  /**
+   * True if this member has destroyed this named locking service. Field is volatile only because
+   * it's referenced in {@link #toString()} (never synchronize in <code>toString</code>).
-  
-  /** 
-   * True if this is a distributed lock service; false if local to this vm 
-   * only. TX has a "local" lock service which sets this to false. 
+
+  /**
+   * True if this is a distributed lock service; false if local to this vm only. TX has a "local"
+   * lock service which sets this to false.
-  
+
-  /** 
-   * Hook for transactions which allows custom behavior in processing 
-   * DLockRecoverGrantorMessage 
+  /**
+   * Hook for transactions which allows custom behavior in processing DLockRecoverGrantorMessage
-  
+
-  
-  /** 
-   * Protects {@link #lockGrantorId}, {@link #grantor} and 
-   * {@link #lockGrantorFutureResult}. Final granting of a lock occurs under 
-   * this synchronization and only if <code>lockGrantorId</code> matches the
-   * grantor that granted the lock.  
+
+  /**
+   * Protects {@link #lockGrantorId}, {@link #grantor} and {@link #lockGrantorFutureResult}. Final
+   * granting of a lock occurs under this synchronization and only if <code>lockGrantorId</code>
+   * matches the grantor that granted the lock.
-  
+
-  
-  /** 
-   * Local instance of the lock grantor if this process is the grantor. This 
-   * field is volatile for one use: 1) {@link #toString()} which should not
-   * use synchronization due to potential for wrong lock ordering. Can
-   * we make this non-volatile??
+
+  /**
+   * Local instance of the lock grantor if this process is the grantor. This field is volatile for
+   * one use: 1) {@link #toString()} which should not use synchronization due to potential for wrong
+   * lock ordering. Can we make this non-volatile??
-  
-  /** 
-   * Count of currently active locks and lock requests. Used to determine if
-   * destroy must tell the grantor to release all held locks. 
+
+  /**
+   * Count of currently active locks and lock requests. Used to determine if destroy must tell the
+   * grantor to release all held locks.
-  
+
-  
+
-  
+
-  
-  ///** Held during destory and creation of this lock service. */
-  //private final Object serviceLock = new Object();
-  
+
+  /// ** Held during destory and creation of this lock service. */
+  // private final Object serviceLock = new Object();
+
-  
-  /** 
-   * Created by the thread communicating directly with the elder. Other threads
-   * will wait on this and then use the resulting lockGrantorId. This ensures
-   * that only one message is sent to the elder and that only one thread does
-   * so at a time. Protected by {@link #lockGrantorIdLock} and holds a
-   * reference to a {@link LockGrantorId}.
+
+  /**
+   * Created by the thread communicating directly with the elder. Other threads will wait on this
+   * and then use the resulting lockGrantorId. This ensures that only one message is sent to the
+   * elder and that only one thread does so at a time. Protected by {@link #lockGrantorIdLock} and
+   * holds a reference to a {@link LockGrantorId}.
-   * Only outbound threads and operations should ever wait on this. Do NOT
-   * allow inbound threads to use the <code>lockGrantorFutureResult</code>.
+   * Only outbound threads and operations should ever wait on this. Do NOT allow inbound threads to
+   * use the <code>lockGrantorFutureResult</code>.
-  
+
-  
+
-  //   State and concurrency construct methods
+  // State and concurrency construct methods
-  
+
-  
+
-      throw generateLockServiceDestroyedException(
-          generateLockServiceDestroyedMessage());
+      throw generateLockServiceDestroyedException(generateLockServiceDestroyedMessage());
-  
+
-  
+
-   * Returns the string message to use in a LockServiceDestroyedException for 
-   * this lock service.
+   * Returns the string message to use in a LockServiceDestroyedException for this lock service.
-    return LocalizedStrings.DLockService_0_HAS_BEEN_DESTROYED
-      .toLocalizedString(this);
+    return LocalizedStrings.DLockService_0_HAS_BEEN_DESTROYED.toLocalizedString(this);
-  
+
-   * Returns true if {@link #lockGrantorId} is the same as the specified
-   * LockGrantorId. Caller must synchronize on {@link #lockGrantorIdLock}.
+   * Returns true if {@link #lockGrantorId} is the same as the specified LockGrantorId. Caller must
+   * synchronize on {@link #lockGrantorIdLock}.
-   * @param someLockGrantorId the LockGrantorId to check 
+   * @param someLockGrantorId the LockGrantorId to check
-    Assert.assertHoldsLock(this.lockGrantorIdLock,true);
+    Assert.assertHoldsLock(this.lockGrantorIdLock, true);
-  
+
-   * Returns true if lockGrantorId is the same as the specified
-   * LockGrantorId. Caller must synchronize on lockGrantorIdLock.
+   * Returns true if lockGrantorId is the same as the specified LockGrantorId. Caller must
+   * synchronize on lockGrantorIdLock.
-   * @param someLockGrantorId the LockGrantorId to check 
+   * @param someLockGrantorId the LockGrantorId to check
-    synchronized(this.lockGrantorIdLock) {
+    synchronized (this.lockGrantorIdLock) {
-  
+
-  
+
-   * Returns id of the current lock grantor for this service. If necessary,
-   * a request will be sent to the elder to fetch this information.
+   * Returns id of the current lock grantor for this service. If necessary, a request will be sent
+   * to the elder to fetch this information.
-  public LockGrantorId getLockGrantorId() { 
+  public LockGrantorId getLockGrantorId() {
-      
+
-        Assert.assertHoldsLock(this.destroyLock,false);
+        Assert.assertHoldsLock(this.destroyLock, false);
-          }
-          else if (this.lockGrantorId != null) {
+          } else if (this.lockGrantorId != null) {
-          }
-          else {
+          } else {
-            lockGrantorFutureResultRef = 
-                new FutureResult(this.dm.getCancelCriterion());
+            lockGrantorFutureResultRef = new FutureResult(this.dm.getCancelCriterion());
-      
+
-          LockGrantorId lockGrantorIdRef = 
-            waitForLockGrantorFutureResult(lockGrantorFutureResultRef);
+          LockGrantorId lockGrantorIdRef =
+              waitForLockGrantorFutureResult(lockGrantorFutureResultRef, 0, TimeUnit.MILLISECONDS);
-          }
-          else {
+          } else {
-      
+
-        
+
-        theLockGrantorId = new LockGrantorId(
-            this.dm, gi.getId(), gi.getVersionId(), gi.getSerialNumber());
+        theLockGrantorId =
+            new LockGrantorId(this.dm, gi.getId(), gi.getVersionId(), gi.getSerialNumber());
-          logger.trace(LogMarker.DLS, "[getLockGrantorId] elder says grantor is {}", theLockGrantorId);
+          logger.trace(LogMarker.DLS, "[getLockGrantorId] elder says grantor is {}",
+              theLockGrantorId);
-        
+
-              Assert.assertTrue(this.lockGrantorId == null ||
-                  this.lockGrantorId.isNewerThan(theLockGrantorId) ||
-                  this.lockGrantorId.sameAs(theLockGrantorId),
-                  this.lockGrantorId + " should be null or newer than or same as " + theLockGrantorId);
+              Assert.assertTrue(
+                  this.lockGrantorId == null || this.lockGrantorId.isNewerThan(theLockGrantorId)
+                      || this.lockGrantorId.sameAs(theLockGrantorId),
+                  this.lockGrantorId + " should be null or newer than or same as "
+                      + theLockGrantorId);
-        
+
-      }
-      finally {
+      } finally {
-            Assert.assertTrue(
-                this.lockGrantorFutureResult == lockGrantorFutureResultRef);
+            Assert.assertTrue(this.lockGrantorFutureResult == lockGrantorFutureResultRef);
-            }
-            else {
+            } else {
-   * 
-   * if (!createLocalGrantor(xxx)) {
-   *    theLockGrantorId = this.lockGrantorId;
-   * }
+   *
+   * if (!createLocalGrantor(xxx)) { theLockGrantorId = this.lockGrantorId; }
-  private boolean createLocalGrantor(InternalDistributedMember elder, 
-                                     boolean needsRecovery, 
-                                     LockGrantorId myLockGrantorId) {
-    DLockGrantor myGrantor = DLockGrantor.createGrantor(
-        this, myLockGrantorId.getLockGrantorVersion());
+  private boolean createLocalGrantor(InternalDistributedMember elder, boolean needsRecovery,
+      LockGrantorId myLockGrantorId) {
+    DLockGrantor myGrantor =
+        DLockGrantor.createGrantor(this, myLockGrantorId.getLockGrantorVersion());
-  private boolean makeLocalGrantor(InternalDistributedMember elder, 
-                                   boolean needsRecovery, 
-                                   LockGrantorId myLockGrantorId,
-                                   DLockGrantor myGrantor) {
+
+  private boolean makeLocalGrantor(InternalDistributedMember elder, boolean needsRecovery,
+      LockGrantorId myLockGrantorId, DLockGrantor myGrantor) {
-        
+
-            logger.trace(LogMarker.DLS, "Failed to create {} because elder changed from {} to {}", myLockGrantorId, elder, currentElder);
+            logger.trace(LogMarker.DLS, "Failed to create {} because elder changed from {} to {}",
+                myLockGrantorId, elder, currentElder);
-        
+
-              logger.trace(LogMarker.DLS, "Failed to create {} because I was deposed by {}", myLockGrantorId,  this.deposingLockGrantorId);
+              logger.trace(LogMarker.DLS, "Failed to create {} because I was deposed by {}",
+                  myLockGrantorId, this.deposingLockGrantorId);
-          
+
-            logger.trace(LogMarker.DLS, "{} failed to depose {}", this.deposingLockGrantorId, myLockGrantorId);
+            logger.trace(LogMarker.DLS, "{} failed to depose {}", this.deposingLockGrantorId,
+                myLockGrantorId);
-        
+
-            logger.trace(LogMarker.DLS, "[getLockGrantorId] failed to create {} because current grantor is {}", myLockGrantorId, this.lockGrantorId);
+            logger.trace(LogMarker.DLS,
+                "[getLockGrantorId] failed to create {} because current grantor is {}",
+                myLockGrantorId, this.lockGrantorId);
-      
-      // do NOT sync while doing recovery (because it waits for replies) 
+
+      // do NOT sync while doing recovery (because it waits for replies)
-        boolean recovered = DLockRecoverGrantorProcessor.recoverLockGrantor(
-            this.dm.getDistributionManagerIds(), // include this vm
-            this, // this lock service
-            myGrantor,
-            this.dm,
-            elder); // the elder that told us to be the grantor
+        boolean recovered =
+            DLockRecoverGrantorProcessor.recoverLockGrantor(this.dm.getDistributionManagerIds(), // include
+                                                                                                 // this
+                                                                                                 // vm
+                this, // this lock service
+                myGrantor, this.dm, elder); // the elder that told us to be the grantor
-      
+
-        
+
-              logger.trace(LogMarker.DLS, "Failed to create {} because I was deposed by {}", myLockGrantorId, this.deposingLockGrantorId);
+              logger.trace(LogMarker.DLS, "Failed to create {} because I was deposed by {}",
+                  myLockGrantorId, this.deposingLockGrantorId);
-          
+
-            logger.trace(LogMarker.DLS, "{} failed to depose {}", this.deposingLockGrantorId, myLockGrantorId);
+            logger.trace(LogMarker.DLS, "{} failed to depose {}", this.deposingLockGrantorId,
+                myLockGrantorId);
-        
+
-      
+
-    }
-    catch (VirtualMachineError err) {
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Error e) {
+    } catch (Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-    }
-    catch (RuntimeException e) {
+    } catch (RuntimeException e) {
-    }
-    finally {
-      
+    } finally {
+
-            logger.trace(LogMarker.DLS, "[makeLocalGrantor] aborting {} and {}", myLockGrantorId, myGrantor);
+            logger.trace(LogMarker.DLS, "[makeLocalGrantor] aborting {} and {}", myLockGrantorId,
+                myGrantor);
-      }
-      finally {
+      } finally {
-      
-        if (myGrantor.isInitializing() && 
-            !dm.getCancelCriterion().isCancelInProgress()) {
-          logger.error(LogMarker.DLS, LocalizedMessage.create(LocalizedStrings.DLockService_GRANTOR_IS_STILL_INITIALIZING));
+
+        if (myGrantor.isInitializing() && !dm.getCancelCriterion().isCancelInProgress()) {
+          logger.error(LogMarker.DLS,
+              LocalizedMessage.create(LocalizedStrings.DLockService_GRANTOR_IS_STILL_INITIALIZING));
-        if (!success && !myGrantor.isDestroyed() && 
-            !dm.getCancelCriterion().isCancelInProgress()) {
+        if (!success && !myGrantor.isDestroyed() && !dm.getCancelCriterion().isCancelInProgress()) {
-  
-  /** 
-   * Set {@link #lockGrantorId} to the given new value if the 
-   * current value is null or is an older grantor version. Caller must hold 
-   * {@link #lockGrantorIdLock}.
+
+  /**
+   * Set {@link #lockGrantorId} to the given new value if the current value is null or is an older
+   * grantor version. Caller must hold {@link #lockGrantorIdLock}.
-    Assert.assertHoldsLock(this.lockGrantorIdLock,true);
+    Assert.assertHoldsLock(this.lockGrantorIdLock, true);
-    } 
-    else if (!newLockGrantorId.hasLockGrantorVersion()) {
+    } else if (!newLockGrantorId.hasLockGrantorVersion()) {
-    }
-    else if (newLockGrantorId.isRemote() &&
-             this.lockGrantorId != null &&
-             this.lockGrantorId.hasLockGrantorVersion()) {
+    } else if (newLockGrantorId.isRemote() && this.lockGrantorId != null
+        && this.lockGrantorId.hasLockGrantorVersion()) {
-        logger.trace(LogMarker.DLS, "[setLockGrantorId] tried to replace {} with {}", this.lockGrantorId, newLockGrantorId);
+        logger.trace(LogMarker.DLS, "[setLockGrantorId] tried to replace {} with {}",
+            this.lockGrantorId, newLockGrantorId);
-    }
-    else if (newLockGrantorId.isNewerThan(this.lockGrantorId)) {
+    } else if (newLockGrantorId.isNewerThan(this.lockGrantorId)) {
-    }
-    else {
+    } else {
-  /** 
-   * Set {@link #lockGrantorId} to the <code>localLockGrantorId</code> if
-   * current value is null or is an older grantor version. This also atomically
-   * sets {@link #grantor} to ensure that the two fields are kept in sync.
-   * Caller must hold {@link #lockGrantorIdLock}.
+  /**
+   * Set {@link #lockGrantorId} to the <code>localLockGrantorId</code> if current value is null or
+   * is an older grantor version. This also atomically sets {@link #grantor} to ensure that the two
+   * fields are kept in sync. Caller must hold {@link #lockGrantorIdLock}.
-  private boolean setLockGrantorId(LockGrantorId localLockGrantorId,
-                                   DLockGrantor localGrantor) {
-    Assert.assertHoldsLock(this.lockGrantorIdLock,true);
+  private boolean setLockGrantorId(LockGrantorId localLockGrantorId, DLockGrantor localGrantor) {
+    Assert.assertHoldsLock(this.lockGrantorIdLock, true);
-  
+
-        logger.trace(LogMarker.DLS, "[deposeOlderLockGrantorId] pre-deposing {} for new {}", deposedLockGrantorId, newLockGrantorId);
+        logger.trace(LogMarker.DLS, "[deposeOlderLockGrantorId] pre-deposing {} for new {}",
+            deposedLockGrantorId, newLockGrantorId);
-    if (deposedLockGrantorId != null &&
-        deposedLockGrantorId.hasLockGrantorVersion() &&
-        newLockGrantorId.isNewerThan(deposedLockGrantorId)) {
+    if (deposedLockGrantorId != null && deposedLockGrantorId.hasLockGrantorVersion()
+        && newLockGrantorId.isNewerThan(deposedLockGrantorId)) {
-        logger.trace(LogMarker.DLS, "[deposeOlderLockGrantorId] post-deposing {} for new {}", deposedLockGrantorId, newLockGrantorId);
+        logger.trace(LogMarker.DLS, "[deposeOlderLockGrantorId] post-deposing {} for new {}",
+            deposedLockGrantorId, newLockGrantorId);
-   * Sets {@link #lockGrantorId} to null if the current value equals the
-   * expected old value. Caller must hold {@link #lockGrantorIdLock}.
+   * Sets {@link #lockGrantorId} to null if the current value equals the expected old value. Caller
+   * must hold {@link #lockGrantorIdLock}.
-    Assert.assertHoldsLock(this.destroyLock,false);
-    Assert.assertHoldsLock(this.lockGrantorIdLock,false);
+    Assert.assertHoldsLock(this.destroyLock, false);
+    Assert.assertHoldsLock(this.lockGrantorIdLock, false);
-        if (equalsLockGrantorId(oldLockGrantorId) ||
-            (oldLockGrantorId.isLocal(getSerialNumber()) && isMakingLockGrantor())) {
-//            this.lockGrantorId != null && this.lockGrantorId.isLocal())) {
-          if (oldLockGrantorId.isLocal(getSerialNumber()) && 
-              isLockGrantorVersion(
-                  this.grantor, oldLockGrantorId.getLockGrantorVersion())) {
+        if (equalsLockGrantorId(oldLockGrantorId)
+            || (oldLockGrantorId.isLocal(getSerialNumber()) && isMakingLockGrantor())) {
+          // this.lockGrantorId != null && this.lockGrantorId.isLocal())) {
+          if (oldLockGrantorId.isLocal(getSerialNumber())
+              && isLockGrantorVersion(this.grantor, oldLockGrantorId.getLockGrantorVersion())) {
-        }
-        else {
+        } else {
-    }
-    finally {
+    } finally {
-   * Returns true if the grantor version of <code>dlockGrantor</code> equals
-   * the <code>grantorVersion</code>.
+   * Returns true if the grantor version of <code>dlockGrantor</code> equals the
+   * <code>grantorVersion</code>.
-  private boolean isLockGrantorVersion(DLockGrantor dlockGrantor,
-                                       long grantorVersion) {
+  private boolean isLockGrantorVersion(DLockGrantor dlockGrantor, long grantorVersion) {
-  
+
-   * Returns true if <code>someLockGrantor</code> equals the current
-   * {@link #lockGrantorId}.
+   * Returns true if <code>someLockGrantor</code> equals the current {@link #lockGrantorId}.
-    Assert.assertHoldsLock(this.lockGrantorIdLock,true);
+    Assert.assertHoldsLock(this.lockGrantorIdLock, true);
-  
+
-   * Returns id of the current lock grantor for this service. If necessary,
-   * a request will be sent to the elder to fetch this information.
-   * Unlike getLockGrantorId this call will not become the lock grantor.
+   * Returns id of the current lock grantor for this service. If necessary, a request will be sent
+   * to the elder to fetch this information. Unlike getLockGrantorId this call will not become the
+   * lock grantor.
-  public LockGrantorId peekLockGrantorId() { 
-    Assert.assertHoldsLock(this.destroyLock,false);
+  public LockGrantorId peekLockGrantorId() {
+    Assert.assertHoldsLock(this.destroyLock, false);
-      theLockGrantorId = new LockGrantorId(
-          this.dm, lockGrantorMember, gi.getVersionId(), gi.getSerialNumber());
+      theLockGrantorId =
+          new LockGrantorId(this.dm, lockGrantorMember, gi.getVersionId(), gi.getSerialNumber());
-    }
-    finally {
+    } finally {
-   * Increments {@link #activeLocks} while synchronized on {@link #destroyLock}
-   * after calling {@link #checkDestroyed()}.
+   * Increments {@link #activeLocks} while synchronized on {@link #destroyLock} after calling
+   * {@link #checkDestroyed()}.
-  
+
-  
+
-   * Returns lockGrantorId when lockGrantorFutureResultRef has been set by 
-   * another thread.
+   * Returns lockGrantorId when lockGrantorFutureResultRef has been set by another thread.
+   * @param timeToWait how many ms to wait, 0 = forever
+   * @param timeUnit the unit of measure for timeToWait
-  private LockGrantorId waitForLockGrantorFutureResult(FutureResult lockGrantorFutureResultRef) {
+  private LockGrantorId waitForLockGrantorFutureResult(FutureResult lockGrantorFutureResultRef,
+      long timeToWait, final TimeUnit timeUnit) {
-        lockGrantorIdRef = (LockGrantorId) lockGrantorFutureResultRef.get();
-      }
-      catch (InterruptedException e) {
+        if (timeToWait == 0) {
+          lockGrantorIdRef = (LockGrantorId) lockGrantorFutureResultRef.get();
+        } else {
+          lockGrantorIdRef = (LockGrantorId) lockGrantorFutureResultRef.get(timeToWait, timeUnit);
+        }
+      } catch (TimeoutException e) {
+        break;
+      } catch (InterruptedException e) {
-      }
-      catch (CancellationException e) { // Future was cancelled
+      } catch (CancellationException e) { // Future was cancelled
-      }
-      finally {
+      } finally {
-  
-  private void notLockGrantorId(LockGrantorId notLockGrantorId, boolean waitForGrantor) {
+
+  /**
+   * nulls out grantor to force call to elder
+   * 
+   * @param timeToWait how long to wait for a new grantor. -1 don't wait, 0 no time limit
+   * @param timeUnit the unit of measure of timeToWait
+   */
+  private void notLockGrantorId(LockGrantorId notLockGrantorId, long timeToWait,
+      final TimeUnit timeUnit) {
-        logger.trace(LogMarker.DLS, "notLockGrantorId {} returning early because notGrantor {} was equal to the local dm {}", this.serviceName, notLockGrantorId, this.dm.getId());
+        logger.trace(LogMarker.DLS,
+            "notLockGrantorId {} returning early because notGrantor {} was equal to the local dm {}",
+            this.serviceName, notLockGrantorId, this.dm.getId());
-    
+
-    
+
-      Assert.assertHoldsLock(this.destroyLock,false);
+      Assert.assertHoldsLock(this.destroyLock, false);
-        }
-        else if (!notLockGrantorId.sameAs(currentLockGrantorId)) {
+        } else if (!notLockGrantorId.sameAs(currentLockGrantorId)) {
-        }
-        else {
+        } else {
-          lockGrantorFutureResultRef = 
-              new FutureResult(this.dm.getCancelCriterion());
+          lockGrantorFutureResultRef = new FutureResult(this.dm.getCancelCriterion());
-    
+
-        if (waitForGrantor) { // fix for bug #43708
-          waitForLockGrantorFutureResult(lockGrantorFutureResultRef);
+        if (timeToWait >= 0) {
+          waitForLockGrantorFutureResult(lockGrantorFutureResultRef, timeToWait, timeUnit);
-    
+
-      
+
-        elderLockGrantorId = 
-          new LockGrantorId(this.dm, gi.getId(), gi.getVersionId(), gi.getSerialNumber());
+        elderLockGrantorId =
+            new LockGrantorId(this.dm, gi.getId(), gi.getVersionId(), gi.getSerialNumber());
-      
+
-      }
-      else {
+      } else {
-          logger.trace(LogMarker.DLS, "notLockGrantorId cleared lockGrantorId for service {}", this.serviceName);
+          logger.trace(LogMarker.DLS, "notLockGrantorId cleared lockGrantorId for service {}",
+              this.serviceName);
-    }
-    finally {
+    } finally {
-          Assert.assertTrue(
-              this.lockGrantorFutureResult == lockGrantorFutureResultRef);
+          Assert.assertTrue(this.lockGrantorFutureResult == lockGrantorFutureResultRef);
-  
-  /** 
-   * All calls to GrantorRequestProcessor.clearGrantor must come through
-   * this synchronization point.
+
+  /**
+   * All calls to GrantorRequestProcessor.clearGrantor must come through this synchronization point.
-   * This fixes a deadlock between this.becomeGrantorMonitor and 
-   * DistributionManager.elderLock
+   * This fixes a deadlock between this.becomeGrantorMonitor and DistributionManager.elderLock
-   * All calls to the elder may result in elder recovery which may call back
-   * into dlock and acquire synchronization on this.becomeGrantorMonitor.
+   * All calls to the elder may result in elder recovery which may call back into dlock and acquire
+   * synchronization on this.becomeGrantorMonitor.
-    GrantorRequestProcessor.clearGrantor(grantorVersion, this, getSerialNumber(), 
-        this.ds, withLocks);
-  } 
-  /** 
-   * All calls to GrantorRequestProcessor.getGrantor must come through
-   * this synchronization point.
+    GrantorRequestProcessor.clearGrantor(grantorVersion, this, getSerialNumber(), this.ds,
+        withLocks);
+  }
+
+  /**
+   * All calls to GrantorRequestProcessor.getGrantor must come through this synchronization point.
-   * This fixes a deadlock between this.becomeGrantorMonitor and 
-   * DistributionManager.elderLock
+   * This fixes a deadlock between this.becomeGrantorMonitor and DistributionManager.elderLock
-   * All calls to the elder may result in elder recovery which may call back
-   * into dlock and acquire synchronization on this.becomeGrantorMonitor.
+   * All calls to the elder may result in elder recovery which may call back into dlock and acquire
+   * synchronization on this.becomeGrantorMonitor.
-    return GrantorRequestProcessor.getGrantor(this, getSerialNumber(), 
-        this.ds);
+    return GrantorRequestProcessor.getGrantor(this, getSerialNumber(), this.ds);
-  /** 
-   * All calls to GrantorRequestProcessor.peekGrantor must come through
-   * this synchronization point.
+
+  /**
+   * All calls to GrantorRequestProcessor.peekGrantor must come through this synchronization point.
-   * This fixes a deadlock between this.becomeGrantorMonitor and 
-   * DistributionManager.elderLock
+   * This fixes a deadlock between this.becomeGrantorMonitor and DistributionManager.elderLock
-   * All calls to the elder may result in elder recovery which may call back
-   * into dlock and acquire synchronization on this.becomeGrantorMonitor.
+   * All calls to the elder may result in elder recovery which may call back into dlock and acquire
+   * synchronization on this.becomeGrantorMonitor.
-    return GrantorRequestProcessor.peekGrantor(this, 
-        this.ds);
-  } 
-  /** 
-   * All calls to GrantorRequestProcessor.becomeGrantor must come through
-   * this synchronization point.
+    return GrantorRequestProcessor.peekGrantor(this, this.ds);
+  }
+
+  /**
+   * All calls to GrantorRequestProcessor.becomeGrantor must come through this synchronization
+   * point.
-   * This fixes a deadlock between this.becomeGrantorMonitor and 
-   * DistributionManager.elderLock
+   * This fixes a deadlock between this.becomeGrantorMonitor and DistributionManager.elderLock
-   * All calls to the elder may result in elder recovery which may call back
-   * into dlock and acquire synchronization on this.becomeGrantorMonitor.
+   * All calls to the elder may result in elder recovery which may call back into dlock and acquire
+   * synchronization on this.becomeGrantorMonitor.
-    return GrantorRequestProcessor.becomeGrantor(this, getSerialNumber(), 
-        predecessor, this.ds);
-  } 
-  
+    return GrantorRequestProcessor.becomeGrantor(this, getSerialNumber(), predecessor, this.ds);
+  }
+
-  //   New external API methods
+  // New external API methods
-    becomeLockGrantor((InternalDistributedMember)null);
+    becomeLockGrantor((InternalDistributedMember) null);
-    Assert.assertHoldsLock(this.destroyLock,false);
+    Assert.assertHoldsLock(this.destroyLock, false);
-  
+
-  
+
-  
+
-    
+
-    LockGrantorId myLockGrantorId = null;    
+    LockGrantorId myLockGrantorId = null;
-      
+
-      //   terminate loop if other thread has already made us lock grantor
-      //   terminate loop if this thread gets control of lockGrantorFutureResult
+      // terminate loop if other thread has already made us lock grantor
+      // terminate loop if this thread gets control of lockGrantorFutureResult
-        Assert.assertHoldsLock(this.destroyLock,false);
+        Assert.assertHoldsLock(this.destroyLock, false);
-          }
-          else if (this.lockGrantorFutureResult != null) {
+          } else if (this.lockGrantorFutureResult != null) {
-          }
-          else {
+          } else {
-            lockGrantorFutureResultRef = 
-                new FutureResult(this.dm.getCancelCriterion());
+            lockGrantorFutureResultRef = new FutureResult(this.dm.getCancelCriterion());
-          waitForLockGrantorFutureResult(lockGrantorFutureResultRef);
+          waitForLockGrantorFutureResult(lockGrantorFutureResultRef, 0, TimeUnit.MILLISECONDS);
-      
+
-  
+
-      LockGrantorId tempLockGrantorId =new LockGrantorId(
-          this.dm, this.dm.getId(), tempGrantorVersion, getSerialNumber());
-  
-      DLockGrantor myGrantor = 
-          DLockGrantor.createGrantor(this, tempGrantorVersion);
-        
+      LockGrantorId tempLockGrantorId =
+          new LockGrantorId(this.dm, this.dm.getId(), tempGrantorVersion, getSerialNumber());
+
+      DLockGrantor myGrantor = DLockGrantor.createGrantor(this, tempGrantorVersion);
+
-        
+
-          logger.trace(LogMarker.DLS, "become set lockGrantorId to {} for service {}", this.lockGrantorId, this.serviceName);
+          logger.trace(LogMarker.DLS, "become set lockGrantorId to {} for service {}",
+              this.lockGrantorId, this.serviceName);
-          
+
-        
+
-        GrantorInfo gi = becomeGrantor(predecessor); 
+        GrantorInfo gi = becomeGrantor(predecessor);
-        long myGrantorVersion = gi.getVersionId()+1;
+        long myGrantorVersion = gi.getVersionId() + 1;
-        
-        myLockGrantorId = new LockGrantorId(
-            this.dm, this.dm.getId(), myGrantorVersion, getSerialNumber());
+
+        myLockGrantorId =
+            new LockGrantorId(this.dm, this.dm.getId(), myGrantorVersion, getSerialNumber());
-        
-      }
-      finally {
-        Assert.assertTrue(myGrantor == null 
-            || !myGrantor.isInitializing()
-            || this.dm.getCancelCriterion().isCancelInProgress()
-            || isDestroyed(),
+
+      } finally {
+        Assert.assertTrue(
+            myGrantor == null || !myGrantor.isInitializing()
+                || this.dm.getCancelCriterion().isCancelInProgress() || isDestroyed(),
-    }
-    finally {
+    } finally {
-          Assert.assertTrue(
-              this.lockGrantorFutureResult == lockGrantorFutureResultRef);
+          Assert.assertTrue(this.lockGrantorFutureResult == lockGrantorFutureResultRef);
-          }
-          else {
-            this.dm.getCancelCriterion().checkCancelInProgress(null); // don't succeed if shutting down
+          } else {
+            this.dm.getCancelCriterion().checkCancelInProgress(null); // don't succeed if shutting
+                                                                      // down
-  
+
-    Assert.assertHoldsLock(this.destroyLock,false);
+    Assert.assertHoldsLock(this.destroyLock, false);
-      return this.lockGrantorId != null && 
-             this.lockGrantorId.isLocal(getSerialNumber()) &&
-             this.grantor != null &&
-             this.grantor.isInitializing();
+      return this.lockGrantorId != null && this.lockGrantorId.isLocal(getSerialNumber())
+          && this.grantor != null && this.grantor.isInitializing();
-  
+
-    Assert.assertHoldsLock(this.destroyLock,false);
+    Assert.assertHoldsLock(this.destroyLock, false);
-      return this.lockGrantorId != null && 
-             this.lockGrantorId.isLocal(getSerialNumber());
+      return this.lockGrantorId != null && this.lockGrantorId.isLocal(getSerialNumber());
-  
+
-    Assert.assertHoldsLock(this.destroyLock,false);
+    Assert.assertHoldsLock(this.destroyLock, false);
-      return this.lockGrantorId != null && 
-             this.lockGrantorId.isLocal(getSerialNumber()) &&
-             this.grantor != null &&
-             this.grantor.isReady();
+      return this.lockGrantorId != null && this.lockGrantorId.isLocal(getSerialNumber())
+          && this.grantor != null && this.grantor.isReady();
-  
+
-  //   External API methods
+  // External API methods
-  
+
-    }
-    else {
+    } else {
-  
-  /** 
-   * Attempt to destroy and remove lock token. Synchronizes on tokens map
-   * and the lock token.
+
+  /**
+   * Attempt to destroy and remove lock token. Synchronizes on tokens map and the lock token.
-  /** 
-   * Attempt to destroy and remove all unused lock tokens. Synchronizes on
-   * tokens map and each lock token.
+  /**
+   * Attempt to destroy and remove all unused lock tokens. Synchronizes on tokens map and each lock
+   * token.
-          }
-          else {
+          } else {
-        DLockToken token = (DLockToken)iter.next();
+        DLockToken token = (DLockToken) iter.next();
-      }        
+      }
-   * Destroys and removes all lock tokens. Caller must synchronize on 
-   * destroyLock. Synchronizes on tokens map and each token.
+   * Destroys and removes all lock tokens. Caller must synchronize on destroyLock. Synchronizes on
+   * tokens map and each token.
-  
+
-      if (token == null) return false;
-      synchronized(token) {
+      if (token == null)
+        return false;
+      synchronized (token) {
-  
+
-      if (token == null) return false;
-      synchronized(token) {
+      if (token == null)
+        return false;
+      synchronized (token) {
-  
+
-  
+
-  
-  public boolean lock(Object name, 
-                      long waitTimeMillis, 
-                      long leaseTimeMillis,
-                      boolean tryLock) {
+
+  public boolean lock(Object name, long waitTimeMillis, long leaseTimeMillis, boolean tryLock) {
-  
-  public boolean lock(Object name, 
-      long waitTimeMillis, 
-      long leaseTimeMillis,
-      boolean tryLock,
+
+  public boolean lock(Object name, long waitTimeMillis, long leaseTimeMillis, boolean tryLock,
-}
+  }
-  
-  public boolean lock(Object name, 
-                      long waitTimeMillis, 
-                      long leaseTimeMillis,
-                      boolean tryLock,
-                      boolean disallowReentrant,
-                      boolean diableAlerts) {
+
+  public boolean lock(Object name, long waitTimeMillis, long leaseTimeMillis, boolean tryLock,
+      boolean disallowReentrant, boolean diableAlerts) {
-      return lockInterruptibly(name, waitTimeMillis, leaseTimeMillis, tryLock, interruptible, disallowReentrant, diableAlerts);
-    } 
-    catch (InterruptedException ex) { // LOST INTERRUPT
+      return lockInterruptibly(name, waitTimeMillis, leaseTimeMillis, tryLock, interruptible,
+          disallowReentrant, diableAlerts);
+    } catch (InterruptedException ex) { // LOST INTERRUPT
-      logger.error(LogMarker.DLS, LocalizedMessage.create(LocalizedStrings.DLockService_LOCK_WAS_INTERRUPTED), ex);
+      logger.error(LogMarker.DLS,
+          LocalizedMessage.create(LocalizedStrings.DLockService_LOCK_WAS_INTERRUPTED), ex);
-  throws InterruptedException {
+      throws InterruptedException {
-  
+
-      if (Thread.interrupted()) throw new InterruptedException();
+      if (Thread.interrupted())
+        throw new InterruptedException();
-    }
-    else {
+    } else {
-  
-  /** Causes the current thread to sleep for millis uninterruptibly */ 
+
+  /** Causes the current thread to sleep for millis uninterruptibly */
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {
-      }
-      finally {
+      } finally {
-  protected DLockRequestProcessor createRequestProcessor(
-      LockGrantorId grantorId, Object name, int threadId, long startTime,
-      long requestLeaseTime, long requestWaitTime, boolean reentrant,
+  protected DLockRequestProcessor createRequestProcessor(LockGrantorId grantorId, Object name,
+      int threadId, long startTime, long requestLeaseTime, long requestWaitTime, boolean reentrant,
-    return createRequestProcessor(grantorId, name, threadId, startTime,
-        requestLeaseTime, requestWaitTime,  reentrant,  tryLock, false );
-  }
-  
-  protected DLockRequestProcessor createRequestProcessor(
-      LockGrantorId grantorId, Object name, int threadId, long startTime,
-      long requestLeaseTime, long requestWaitTime, boolean reentrant,
-      boolean tryLock, boolean disableAlerts) {
-    return new DLockRequestProcessor(grantorId, this, name, threadId,
-        startTime, requestLeaseTime, requestWaitTime, reentrant, tryLock, disableAlerts,
-        this.dm);
-  }
-  
-  protected boolean callReleaseProcessor(InternalDistributedMember grantor,
-      Object name, boolean lockBatch, int lockId) {
-    return DLockService.callReleaseProcessor(this.dm, this.serviceName,
-        grantor, name, lockBatch, lockId);
+    return createRequestProcessor(grantorId, name, threadId, startTime, requestLeaseTime,
+        requestWaitTime, reentrant, tryLock, false);
-  protected static boolean callReleaseProcessor(DM dm,
-      String serviceName, InternalDistributedMember grantor, Object name,
+  protected DLockRequestProcessor createRequestProcessor(LockGrantorId grantorId, Object name,
+      int threadId, long startTime, long requestLeaseTime, long requestWaitTime, boolean reentrant,
+      boolean tryLock, boolean disableAlerts) {
+    return new DLockRequestProcessor(grantorId, this, name, threadId, startTime, requestLeaseTime,
+        requestWaitTime, reentrant, tryLock, disableAlerts, this.dm);
+  }
+
+  protected boolean callReleaseProcessor(InternalDistributedMember grantor, Object name,
-    DLockReleaseProcessor processor = new DLockReleaseProcessor(dm,
-        grantor, serviceName, name);
+    return DLockService.callReleaseProcessor(this.dm, this.serviceName, grantor, name, lockBatch,
+        lockId);
+  }
+
+  protected static boolean callReleaseProcessor(DM dm, String serviceName,
+      InternalDistributedMember grantor, Object name, boolean lockBatch, int lockId) {
+    DLockReleaseProcessor processor = new DLockReleaseProcessor(dm, grantor, serviceName, name);
-  
-  public boolean lockInterruptibly(final Object name, 
-      final long waitTimeMillis, 
-      final long leaseTimeMillis,
-      final boolean tryLock,
-      final boolean interruptible,
+
+  public boolean lockInterruptibly(final Object name, final long waitTimeMillis,
+      final long leaseTimeMillis, final boolean tryLock, final boolean interruptible,
-    return lockInterruptibly(name, waitTimeMillis, leaseTimeMillis, tryLock,
-        interruptible, disallowReentrant, false);
+    return lockInterruptibly(name, waitTimeMillis, leaseTimeMillis, tryLock, interruptible,
+        disallowReentrant, false);
-  
+
-   * @param name the name of the lock to acquire in this service.  This object 
-   * must conform to the general contract of <code>equals(Object)</code> and 
-   * <code>hashCode()</code> as described in 
-   * {@link java.lang.Object#hashCode()}.
+   * @param name the name of the lock to acquire in this service. This object must conform to the
+   *        general contract of <code>equals(Object)</code> and <code>hashCode()</code> as described
+   *        in {@link java.lang.Object#hashCode()}.
-   * @param waitTimeMillis the number of milliseconds to try to acquire
-   * the lock before giving up and returning false.  A value of -1 causes
-   * this method to block until the lock is acquired.
+   * @param waitTimeMillis the number of milliseconds to try to acquire the lock before giving up
+   *        and returning false. A value of -1 causes this method to block until the lock is
+   *        acquired.
-   * @param leaseTimeMillis the number of milliseconds to hold the lock after
-   * granting it, before automatically releasing it if it hasn't already
-   * been released by invoking {@link #unlock(Object)}.  If 
-   * <code>leaseTimeMillis</code> is -1, hold the lock until explicitly 
-   * unlocked.
+   * @param leaseTimeMillis the number of milliseconds to hold the lock after granting it, before
+   *        automatically releasing it if it hasn't already been released by invoking
+   *        {@link #unlock(Object)}. If <code>leaseTimeMillis</code> is -1, hold the lock until
+   *        explicitly unlocked.
-   * @param tryLock true if the lock should be acquired or fail if currently
-   * held.  waitTimeMillis will be ignored if the lock is currently held by
-   * another client.
+   * @param tryLock true if the lock should be acquired or fail if currently held. waitTimeMillis
+   *        will be ignored if the lock is currently held by another client.
-   * 
-   * @param disableAlerts true to disable logging alerts if the dlock
-   * is taking a long time to acquired.
-   * @return true if the lock was acquired, false if the timeout
-   * <code>waitTimeMillis</code> passed without acquiring the lock.
-   * 
-   * @throws InterruptedException if the thread is interrupted before
-   * or during this method.
+   * @param disableAlerts true to disable logging alerts if the dlock is taking a long time to
+   *        acquired.
-   * @throws UnsupportedOperationException if attempt to lock batch involves
-   * non-tryLocks
+   * @return true if the lock was acquired, false if the timeout <code>waitTimeMillis</code> passed
+   *         without acquiring the lock.
+   * 
+   * @throws InterruptedException if the thread is interrupted before or during this method.
+   *
+   * @throws UnsupportedOperationException if attempt to lock batch involves non-tryLocks
-  public boolean lockInterruptibly(final Object name, 
-                                   final long waitTimeMillis, 
-                                   final long leaseTimeMillis,
-                                   final boolean tryLock,
-                                   final boolean interruptible,
-                                   final boolean disallowReentrant,
-                                   final boolean disableAlerts)
-  throws InterruptedException {
+  public boolean lockInterruptibly(final Object name, final long waitTimeMillis,
+      final long leaseTimeMillis, final boolean tryLock, final boolean interruptible,
+      final boolean disallowReentrant, final boolean disableAlerts) throws InterruptedException {
-    
+
-    
+
-      
-    long statStart = getStats().startLockWait();
-    long startTime = getLockTimeStamp(dm);
-    
-    long requestWaitTime = waitTimeMillis;
-    long requestLeaseTime = leaseTimeMillis;
-    
-    // -1 means "lease forever".  Long.MAX_VALUE is pretty close.
-    if (requestLeaseTime == -1) requestLeaseTime = Long.MAX_VALUE;
-    // -1 means "wait forever".  Long.MAX_VALUE is pretty close.
-    if (requestWaitTime == -1) requestWaitTime = Long.MAX_VALUE;
-    
-    long waitLimit = startTime + requestWaitTime;
-    if (waitLimit < 0) waitLimit = Long.MAX_VALUE;
-    if (isDebugEnabled_DLS) {
-      logger.trace(LogMarker.DLS, "{}, name: {} - entering lock()", this, name);
-    }
+      long statStart = getStats().startLockWait();
+      long startTime = getLockTimeStamp(dm);
-    DLockToken token = getOrCreateToken(name);
-    boolean gotLock = false;
-    blockedOn.set(name);
-    try { // try-block for end stats, token cleanup, and interrupt check
-    
-      ThreadRequestState requestState = 
-          (ThreadRequestState) this.threadRequestState.get();
-      if (requestState == null) {
-        requestState = 
-            new ThreadRequestState(incThreadSequence(), interruptible);
-        this.threadRequestState.set(requestState);
+      long requestWaitTime = waitTimeMillis;
+      long requestLeaseTime = leaseTimeMillis;
+
+      // -1 means "lease forever". Long.MAX_VALUE is pretty close.
+      if (requestLeaseTime == -1)
+        requestLeaseTime = Long.MAX_VALUE;
+      // -1 means "wait forever". Long.MAX_VALUE is pretty close.
+      if (requestWaitTime == -1)
+        requestWaitTime = Long.MAX_VALUE;
+
+      long waitLimit = startTime + requestWaitTime;
+      if (waitLimit < 0)
+        waitLimit = Long.MAX_VALUE;
+
+      if (isDebugEnabled_DLS) {
+        logger.trace(LogMarker.DLS, "{}, name: {} - entering lock()", this, name);
-      else {
-        requestState.interruptible = interruptible;
-      }
-      final int threadId = requestState.threadId;
-      
-      // if reentry and no change to expiration then grantor is not bothered
-      
-      long leaseExpireTime = 0;
-      boolean keepTrying = true;
-      int lockId = -1;
-      incActiveLocks();
-      
-      int loopCount = 0;
-      while (keepTrying) {
-        if (DEBUG_LOCK_REQUEST_LOOP) {
-          loopCount++;
-          if (loopCount > DEBUG_LOCK_REQUEST_LOOP_COUNT) {
-            Integer count = Integer.valueOf(DEBUG_LOCK_REQUEST_LOOP_COUNT);
-            String s = LocalizedStrings.DLockService_DEBUG_LOCKINTERRUPTIBLY_HAS_GONE_HOT_AND_LOOPED_0_TIMES.toLocalizedString(count);
-            
-            
-            InternalGemFireError e = new InternalGemFireError(s);
-            logger.error(LogMarker.DLS, LocalizedMessage.create(
-              LocalizedStrings.DLockService_DEBUG_LOCKINTERRUPTIBLY_HAS_GONE_HOT_AND_LOOPED_0_TIMES, count), e);
-            throw e;
-          }
-          /*if (loopCount > 1) {
-            Thread.sleep(1000);
-          }*/
-        }
-        
-        checkDestroyed();
-        interrupted = Thread.interrupted() || interrupted; // clear
-        if (interrupted && interruptible) {
-          throw new InterruptedException();
-        }
-        // Check for recursive lock
-        boolean reentrant = false;
-        int recursionBefore = -1;
-        
-        synchronized(token) {
-          token.checkForExpiration();
-          if (token.isLeaseHeldByCurrentThread()) {
-            if (isDebugEnabled_DLS) {
-              logger.trace(LogMarker.DLS, "{} , name: {} - lock() is reentrant: {}", this, name, token);
-            }
-            reentrant = true;
-            if (reentrant && disallowReentrant) {
-              throw new IllegalStateException(LocalizedStrings.DLockService_0_ATTEMPTED_TO_REENTER_NONREENTRANT_LOCK_1.toLocalizedString(new Object[] {Thread.currentThread(), token}));
-            }
-            recursionBefore = token.getRecursion();
-            leaseExpireTime = token.getLeaseExpireTime(); // moved here from processor null-check under gotLock
-            lockId = token.getLeaseId(); // keep lockId
-            if (lockId < 0) {
-              // loop back around due to expiration
-              continue;
-            }
-          } // isLeaseHeldByCurrentThread
-        } // token sync
-        
-        LockGrantorId theLockGrantorId = getLockGrantorId();
-        
-        if (reentrant) {
-          Assert.assertTrue(lockId > -1, "Reentrant lock must have lockId > -1");
-          //lockId = token.getLockId(); // keep lockId
+      DLockToken token = getOrCreateToken(name);
+      boolean gotLock = false;
+      blockedOn.set(name);
+      try { // try-block for end stats, token cleanup, and interrupt check
+
+        ThreadRequestState requestState = (ThreadRequestState) this.threadRequestState.get();
+        if (requestState == null) {
+          requestState = new ThreadRequestState(incThreadSequence(), interruptible);
+          this.threadRequestState.set(requestState);
+        } else {
+          requestState.interruptible = interruptible;
-        else {
-          // this thread is not current owner...
-          lockId = -1; // reset lockId back to -1
-        }
-        
-        DLockRequestProcessor processor = null;
-        
-        // if reentrant w/ infinite lease TODO: remove false to restore this...
-        if (false && reentrant && leaseTimeMillis == Long.MAX_VALUE) {
-          // Optimization:
-          // thread is reentering lock and lease time is infinite so no
-          // need to trouble the poor grantor
-          gotLock = true;
-          // check for race condition...
-          Assert.assertTrue(token.isLeaseHeldByCurrentThread());
-        }
-        
-        // non-reentrant or reentrant w/ non-infinite lease
-        else {
-          processor = createRequestProcessor(theLockGrantorId, name,
-                threadId, startTime, requestLeaseTime, requestWaitTime,
-                reentrant, tryLock, disableAlerts);
-          if (reentrant) {
-            // check for race condition... reentrant expired already...
-            // related to bug 32765, but client-side... see bug 33402
-            synchronized (token) {
-              if (!token.isLeaseHeldByCurrentThread()) {
-                reentrant = false;
-                recursionBefore = -1;
-                token.checkForExpiration();
-              }
-            }
-          }
-          else {
-            // set lockId since this is the first granting (non-reentrant)
-            lockId = processor.getProcessorId();
-          }
-          
-          try {
-            safeExit = false;
-            gotLock = processor.requestLock(interruptible, lockId);
-          }
-          catch (InterruptedException e) { // LOST INTERRUPT
-            if (interruptible) {
-              // TODO: BUG 37158: this can cause a stuck lock
+        final int threadId = requestState.threadId;
+
+        // if reentry and no change to expiration then grantor is not bothered
+
+        long leaseExpireTime = 0;
+        boolean keepTrying = true;
+        int lockId = -1;
+        incActiveLocks();
+
+        int loopCount = 0;
+        while (keepTrying) {
+          if (DEBUG_LOCK_REQUEST_LOOP) {
+            loopCount++;
+            if (loopCount > DEBUG_LOCK_REQUEST_LOOP_COUNT) {
+              Integer count = Integer.valueOf(DEBUG_LOCK_REQUEST_LOOP_COUNT);
+              String s =
+                  LocalizedStrings.DLockService_DEBUG_LOCKINTERRUPTIBLY_HAS_GONE_HOT_AND_LOOPED_0_TIMES
+                      .toLocalizedString(count);
+
+              InternalGemFireError e = new InternalGemFireError(s);
+              logger.error(LogMarker.DLS,
+                  LocalizedMessage.create(
+                      LocalizedStrings.DLockService_DEBUG_LOCKINTERRUPTIBLY_HAS_GONE_HOT_AND_LOOPED_0_TIMES,
+                      count),
+                  e);
-            else {
-              interrupted = true;
-              Assert.assertTrue(false, "Non-interruptible lock is trying to throw InterruptedException");
-            }
+            /*
+             * if (loopCount > 1) { Thread.sleep(1000); }
+             */
-          if (isDebugEnabled_DLS) {
-            logger.trace(LogMarker.DLS, "Grantor {} replied {}", theLockGrantorId, processor.getResponseCodeString());
-          }
-        } // else: non-reentrant or reentrant w/ non-infinite lease
-        
-          
-        if (gotLock) {
-//          if (processor != null) (cannot be null) 
-          { // TODO: can be null after restoring above optimization
-            // non-reentrant lock needs to getLeaseExpireTime
-            leaseExpireTime = processor.getLeaseExpireTime();
-          }
-          int recursion = recursionBefore + 1;
-          
-          boolean granted = false;
-          boolean needToReleaseOrphanedGrant = false;
-          
-          Assert.assertHoldsLock(this.destroyLock,false);
-          synchronized (this.lockGrantorIdLock) {
-            if (!checkLockGrantorId(theLockGrantorId)) {
-              safeExit = true;
-              // race: grantor changed
-              if (isDebugEnabled_DLS) {
-                logger.trace(LogMarker.DLS, "Cannot honor grant from {} because {} is now a grantor.", theLockGrantorId, this.lockGrantorId);
-              }
-              continue;
-            }
-            
-            else if (isDestroyed()) {
-              // race: dls was destroyed
-              if (isDebugEnabled_DLS) {
-                logger.trace(LogMarker.DLS, "Cannot honor grant from {} because this lock service has been destroyed.", theLockGrantorId);
-              }
-              needToReleaseOrphanedGrant = true;
-            }
-            
-            else {
-              safeExit = true;
-              synchronized (this.tokens) {
-                checkDestroyed();
-                Assert.assertTrue(token == basicGetToken(name));
-                RemoteThread rThread = new RemoteThread(
-                    getDistributionManager().getId(), threadId);
-                granted = token.grantLock(
-                    leaseExpireTime, lockId, recursion, rThread);
-              } // tokens sync
-            }
-          }
-              
-          if (needToReleaseOrphanedGrant /* && processor != null*/) {
-            processor.getResponse().releaseOrphanedGrant(this.dm);
-            safeExit = true;
-            continue;
-          }
-          
-          if (!granted) {
-            Assert.assertTrue(granted, 
-                "Failed to perform client-side granting on " + token +
-                " which was granted by " + theLockGrantorId);
-          }
-          
-          // make sure token is THE instance in the map to avoid race with
-          // freeResources... ok to overwrite a newer instance too since only
-          // one thread will own the lock at a time
-//          synchronized (tokens) { // TODO: verify if this is needed
-//            synchronized (token) {
-//              if (tokens.put(name, token) == null) {
-//                getStats().incTokens(1);
-//              }
-//            }
-//          }
-          
-          if (isDebugEnabled_DLS) {
-            logger.trace(LogMarker.DLS, "{}, name: {} - granted lock: {}", this, name, token);
-          }
-          keepTrying = false;
-        } // gotLock is true
-        
-        // grantor replied destroyed (getLock is false)
-        else if (processor.repliedDestroyed()) {
-          safeExit = true;
+
-          // should have thrown LockServiceDestroyedException
-          Assert.assertTrue(isDestroyed(),
-              "Grantor reports service " + this + " is destroyed: " + name);
-        } // grantor replied destroyed
-        
-        // grantor replied NOT_GRANTOR or departed (getLock is false)
-        else if (processor.repliedNotGrantor() || processor.hadNoResponse()) {
-          safeExit = true;
-          notLockGrantorId(theLockGrantorId, true);
-          // keepTrying is still true... loop back around
-        } // grantor replied NOT_GRANTOR or departed
-        
-        // grantor replied NOT_HOLDER for reentrant lock (getLock is false)
-        else if (processor.repliedNotHolder()) {
-          safeExit = true;
-          if (DEBUG_DISALLOW_NOT_HOLDER) {
-            String s = LocalizedStrings.DLockService_DEBUG_GRANTOR_REPORTS_NOT_HOLDER_FOR_0.toLocalizedString(token);
-            InternalGemFireError e = new InternalGemFireError(s);
-            logger.error(LogMarker.DLS, LocalizedMessage.create(LocalizedStrings.DLockService_DEBUG_GRANTOR_REPORTS_NOT_HOLDER_FOR_0, token), e);
-            throw e;
+          interrupted = Thread.interrupted() || interrupted; // clear
+          if (interrupted && interruptible) {
+            throw new InterruptedException();
-          
-          // fix part of bug 32765 - reentrant/expiration problem
-          // probably expired... try to get non-reentrant lock
-          reentrant = false;
-          recursionBefore = -1;
-          synchronized(token) {
+
+          // Check for recursive lock
+          boolean reentrant = false;
+          int recursionBefore = -1;
+
+          synchronized (token) {
-              // THIS SHOULDN'T HAPPEN -- some sort of weird consistency
-              // problem. Do what the grantor says and release the lock...
-              logger.warn(LogMarker.DLS, LocalizedMessage.create(LocalizedStrings.DLockService_GRANTOR_REPORTS_REENTRANT_LOCK_NOT_HELD_0,token));
-              
-              // Attempt at fault tolerance: We thought we owned it, but we 
-              // don't; let's release it.  Removes hot loop in bug 37276, 
-              // but does not address underlying consistency failure.
-              RemoteThread rThread = new RemoteThread(
-                  getDistributionManager().getId(), threadId);
-              token.releaseLock(lockId, rThread, false);
-            }
+              if (isDebugEnabled_DLS) {
+                logger.trace(LogMarker.DLS, "{} , name: {} - lock() is reentrant: {}", this, name,
+                    token);
+              }
+              reentrant = true;
+              if (reentrant && disallowReentrant) {
+                throw new IllegalStateException(
+                    LocalizedStrings.DLockService_0_ATTEMPTED_TO_REENTER_NONREENTRANT_LOCK_1
+                        .toLocalizedString(new Object[] {Thread.currentThread(), token}));
+              }
+              recursionBefore = token.getRecursion();
+              leaseExpireTime = token.getLeaseExpireTime(); // moved here from processor null-check
+                                                            // under gotLock
+              lockId = token.getLeaseId(); // keep lockId
+              if (lockId < 0) {
+                // loop back around due to expiration
+                continue;
+              }
+            } // isLeaseHeldByCurrentThread
-        } // grantor replied NOT_HOLDER for reentrant lock
-        
-        // TODO: figure out when this else case can actually happen...
-        else {
-          safeExit = true;
-          // either dlock service is suspended or tryLock failed
-          // fixed the math here... bug 32765
-          if (waitLimit > token.getCurrentTime() + 20) {
-            sleep(20, interruptible);
-          }
-          keepTrying = waitLimit > token.getCurrentTime();
-        }
-        
-      } // while (keepTrying)
-    } // try-block for end stats, token cleanup, and interrupt check
-    
-    // finally-block for end stats, token cleanup, and interrupt check
-    finally {
-      getStats().endLockWait(statStart, gotLock);
-      
-      // cleanup token if failed to get lock
-      if (!gotLock) {
-        synchronized (token) {
-          token.decUsage();
-        }
-        freeResources(token.getName());
-      }
-      
-      // reset the interrupt state
-      if (interrupted) {
-        Thread.currentThread().interrupt();
-      }
-      
-      // throw InterruptedException only if failed to get lock and interrupted
-      if (!gotLock && interruptible && Thread.interrupted()) {
-        throw new InterruptedException();
-      }
-      blockedOn.set(null);
-    }
-    if (isDebugEnabled_DLS) {
-      logger.trace(LogMarker.DLS, "{}, name: {} - exiting lock() returning {}", this, name, gotLock);
-    }
-    abnormalExit = false;
-    return gotLock;
+          LockGrantorId theLockGrantorId = getLockGrantorId();
+
+          if (reentrant) {
+            Assert.assertTrue(lockId > -1, "Reentrant lock must have lockId > -1");
+            // lockId = token.getLockId(); // keep lockId
+          } else {
+            // this thread is not current owner...
+            lockId = -1; // reset lockId back to -1
+          }
+
+          DLockRequestProcessor processor = null;
+
+          // if reentrant w/ infinite lease TODO: remove false to restore this...
+          if (false && reentrant && leaseTimeMillis == Long.MAX_VALUE) {
+            // Optimization:
+            // thread is reentering lock and lease time is infinite so no
+            // need to trouble the poor grantor
+            gotLock = true;
+            // check for race condition...
+            Assert.assertTrue(token.isLeaseHeldByCurrentThread());
+          }
+
+          // non-reentrant or reentrant w/ non-infinite lease
+          else {
+            processor = createRequestProcessor(theLockGrantorId, name, threadId, startTime,
+                requestLeaseTime, requestWaitTime, reentrant, tryLock, disableAlerts);
+            if (reentrant) {
+              // check for race condition... reentrant expired already...
+              // related to bug 32765, but client-side... see bug 33402
+              synchronized (token) {
+                if (!token.isLeaseHeldByCurrentThread()) {
+                  reentrant = false;
+                  recursionBefore = -1;
+                  token.checkForExpiration();
+                }
+              }
+            } else {
+              // set lockId since this is the first granting (non-reentrant)
+              lockId = processor.getProcessorId();
+            }
+
+            try {
+              safeExit = false;
+              gotLock = processor.requestLock(interruptible, lockId);
+            } catch (InterruptedException e) { // LOST INTERRUPT
+              if (interruptible) {
+                // TODO: BUG 37158: this can cause a stuck lock
+                throw e;
+              } else {
+                interrupted = true;
+                Assert.assertTrue(false,
+                    "Non-interruptible lock is trying to throw InterruptedException");
+              }
+            }
+            if (isDebugEnabled_DLS) {
+              logger.trace(LogMarker.DLS, "Grantor {} replied {}", theLockGrantorId,
+                  processor.getResponseCodeString());
+            }
+          } // else: non-reentrant or reentrant w/ non-infinite lease
+
+          if (gotLock) {
+            // if (processor != null) (cannot be null)
+            { // TODO: can be null after restoring above optimization
+              // non-reentrant lock needs to getLeaseExpireTime
+              leaseExpireTime = processor.getLeaseExpireTime();
+            }
+            int recursion = recursionBefore + 1;
+
+            boolean granted = false;
+            boolean needToReleaseOrphanedGrant = false;
+
+            Assert.assertHoldsLock(this.destroyLock, false);
+            synchronized (this.lockGrantorIdLock) {
+              if (!checkLockGrantorId(theLockGrantorId)) {
+                safeExit = true;
+                // race: grantor changed
+                if (isDebugEnabled_DLS) {
+                  logger.trace(LogMarker.DLS,
+                      "Cannot honor grant from {} because {} is now a grantor.", theLockGrantorId,
+                      this.lockGrantorId);
+                }
+                continue;
+              } else if (isDestroyed()) {
+                // race: dls was destroyed
+                if (isDebugEnabled_DLS) {
+                  logger.trace(LogMarker.DLS,
+                      "Cannot honor grant from {} because this lock service has been destroyed.",
+                      theLockGrantorId);
+                }
+                needToReleaseOrphanedGrant = true;
+              } else {
+                safeExit = true;
+                synchronized (this.tokens) {
+                  checkDestroyed();
+                  Assert.assertTrue(token == basicGetToken(name));
+                  RemoteThread rThread =
+                      new RemoteThread(getDistributionManager().getId(), threadId);
+                  granted = token.grantLock(leaseExpireTime, lockId, recursion, rThread);
+                } // tokens sync
+              }
+            }
+
+            if (needToReleaseOrphanedGrant /* && processor != null */) {
+              processor.getResponse().releaseOrphanedGrant(this.dm);
+              safeExit = true;
+              continue;
+            }
+
+            if (!granted) {
+              Assert.assertTrue(granted, "Failed to perform client-side granting on " + token
+                  + " which was granted by " + theLockGrantorId);
+            }
+
+            // make sure token is THE instance in the map to avoid race with
+            // freeResources... ok to overwrite a newer instance too since only
+            // one thread will own the lock at a time
+            // synchronized (tokens) { // TODO: verify if this is needed
+            // synchronized (token) {
+            // if (tokens.put(name, token) == null) {
+            // getStats().incTokens(1);
+            // }
+            // }
+            // }
+
+            if (isDebugEnabled_DLS) {
+              logger.trace(LogMarker.DLS, "{}, name: {} - granted lock: {}", this, name, token);
+            }
+            keepTrying = false;
+          } // gotLock is true
+
+          // grantor replied destroyed (getLock is false)
+          else if (processor.repliedDestroyed()) {
+            safeExit = true;
+            checkDestroyed();
+            // should have thrown LockServiceDestroyedException
+            Assert.assertTrue(isDestroyed(),
+                "Grantor reports service " + this + " is destroyed: " + name);
+          } // grantor replied destroyed
+
+          // grantor replied NOT_GRANTOR or departed (getLock is false)
+          else if (processor.repliedNotGrantor() || processor.hadNoResponse()) {
+            safeExit = true;
+            notLockGrantorId(theLockGrantorId, 0, TimeUnit.MILLISECONDS);
+            // keepTrying is still true... loop back around
+          } // grantor replied NOT_GRANTOR or departed
+
+          // grantor replied NOT_HOLDER for reentrant lock (getLock is false)
+          else if (processor.repliedNotHolder()) {
+            safeExit = true;
+            if (DEBUG_DISALLOW_NOT_HOLDER) {
+              String s = LocalizedStrings.DLockService_DEBUG_GRANTOR_REPORTS_NOT_HOLDER_FOR_0
+                  .toLocalizedString(token);
+              InternalGemFireError e = new InternalGemFireError(s);
+              logger.error(LogMarker.DLS,
+                  LocalizedMessage.create(
+                      LocalizedStrings.DLockService_DEBUG_GRANTOR_REPORTS_NOT_HOLDER_FOR_0, token),
+                  e);
+              throw e;
+            }
+
+            // fix part of bug 32765 - reentrant/expiration problem
+            // probably expired... try to get non-reentrant lock
+            reentrant = false;
+            recursionBefore = -1;
+            synchronized (token) {
+              token.checkForExpiration();
+              if (token.isLeaseHeldByCurrentThread()) {
+                // THIS SHOULDN'T HAPPEN -- some sort of weird consistency
+                // problem. Do what the grantor says and release the lock...
+                logger.warn(LogMarker.DLS,
+                    LocalizedMessage.create(
+                        LocalizedStrings.DLockService_GRANTOR_REPORTS_REENTRANT_LOCK_NOT_HELD_0,
+                        token));
+
+                // Attempt at fault tolerance: We thought we owned it, but we
+                // don't; let's release it. Removes hot loop in bug 37276,
+                // but does not address underlying consistency failure.
+                RemoteThread rThread = new RemoteThread(getDistributionManager().getId(), threadId);
+                token.releaseLock(lockId, rThread, false);
+              }
+            } // token sync
+          } // grantor replied NOT_HOLDER for reentrant lock
+
+          // TODO: figure out when this else case can actually happen...
+          else {
+            safeExit = true;
+            // either dlock service is suspended or tryLock failed
+            // fixed the math here... bug 32765
+            if (waitLimit > token.getCurrentTime() + 20) {
+              sleep(20, interruptible);
+            }
+            keepTrying = waitLimit > token.getCurrentTime();
+          }
+
+        } // while (keepTrying)
+      } // try-block for end stats, token cleanup, and interrupt check
+
+      // finally-block for end stats, token cleanup, and interrupt check
+      finally {
+        getStats().endLockWait(statStart, gotLock);
+
+        // cleanup token if failed to get lock
+        if (!gotLock) {
+          synchronized (token) {
+            token.decUsage();
+          }
+          freeResources(token.getName());
+        }
+
+        // reset the interrupt state
+        if (interrupted) {
+          Thread.currentThread().interrupt();
+        }
+
+        // throw InterruptedException only if failed to get lock and interrupted
+        if (!gotLock && interruptible && Thread.interrupted()) {
+          throw new InterruptedException();
+        }
+        blockedOn.set(null);
+      }
+
+      if (isDebugEnabled_DLS) {
+        logger.trace(LogMarker.DLS, "{}, name: {} - exiting lock() returning {}", this, name,
+            gotLock);
+      }
+      abnormalExit = false;
+      return gotLock;
-    
+
-        logger.trace(LogMarker.DLS, "{}, name: {} - exiting lock() without returning value", this, name);
+        logger.trace(LogMarker.DLS, "{}, name: {} - exiting lock() without returning value", this,
+            name);
-   * Allow locking to resume. 
+   * Allow locking to resume.
-    }
-    catch (IllegalStateException e) {
+    } catch (IllegalStateException e) {
-   * Suspends granting of locks for this instance of DLockService.  If
-   * distribute is true, sends suspendLocking to all other members that
-   * have created this service.  Blocks until all outstanding locks have
-   * been released (excluding those held by the initial calling thread).
+   * Suspends granting of locks for this instance of DLockService. If distribute is true, sends
+   * suspendLocking to all other members that have created this service. Blocks until all
+   * outstanding locks have been released (excluding those held by the initial calling thread).
-   * @return true if locking is suspended and all locks have been
-   * released.  Otherwise, resumeLocking is invoked and false is returned.
+   * @return true if locking is suspended and all locks have been released. Otherwise, resumeLocking
+   *         is invoked and false is returned.
-    
+
-      
+
-      if (interrupted) Thread.currentThread().interrupt();
+      if (interrupted)
+        Thread.currentThread().interrupt();
-    
+
-  
+
-  public boolean suspendLockingInterruptibly(long waitTimeMillis)
-  throws InterruptedException {
+  public boolean suspendLockingInterruptibly(long waitTimeMillis) throws InterruptedException {
-  
-  public boolean suspendLockingInterruptibly(long waitTimeMillis,
-                                             boolean interruptible)
-  throws InterruptedException {
+
+  public boolean suspendLockingInterruptibly(long waitTimeMillis, boolean interruptible)
+      throws InterruptedException {
-    
+
-      }
-      else {
+      } else {
-    
+
-    if (isLockingSuspendedByCurrentThread()) {
-      throw new IllegalStateException(LocalizedStrings.DLockService_CURRENT_THREAD_HAS_ALREADY_LOCKED_ENTIRE_SERVICE.toLocalizedString());
-    }
-    
-    // have to use tryLock to avoid deadlock with other members that are
-    // simultaneously attempting to suspend locking
-    boolean tryLock = false; // go with false to queue up suspend lock requests
-    // when tryLock is false, we get deadlock:
-    //   thread 1 is this thread
-    //   thread 2 is processing a SuspendMessage... goes thru 
-    //     suspendLocking with distribute=false and gets stuck in
-    //     waitForGrantorCallsInProgress
-    
-    SuspendLockingToken suspendToken = SUSPEND_LOCKING_TOKEN;
-    
-    boolean gotToken = false;
-    boolean keepTrying = true;
-    
-    long startTime = System.currentTimeMillis();
-    long waitLimit = startTime + waitTimeMillis;
-    if (waitLimit < 0) waitLimit = Long.MAX_VALUE;
-    
-//    try {
+      if (isLockingSuspendedByCurrentThread()) {
+        throw new IllegalStateException(
+            LocalizedStrings.DLockService_CURRENT_THREAD_HAS_ALREADY_LOCKED_ENTIRE_SERVICE
+                .toLocalizedString());
+      }
+
+      // have to use tryLock to avoid deadlock with other members that are
+      // simultaneously attempting to suspend locking
+      boolean tryLock = false; // go with false to queue up suspend lock requests
+      // when tryLock is false, we get deadlock:
+      // thread 1 is this thread
+      // thread 2 is processing a SuspendMessage... goes thru
+      // suspendLocking with distribute=false and gets stuck in
+      // waitForGrantorCallsInProgress
+
+      SuspendLockingToken suspendToken = SUSPEND_LOCKING_TOKEN;
+
+      boolean gotToken = false;
+      boolean keepTrying = true;
+
+      long startTime = System.currentTimeMillis();
+      long waitLimit = startTime + waitTimeMillis;
+      if (waitLimit < 0)
+        waitLimit = Long.MAX_VALUE;
+
+      // try {
-        gotToken = lockInterruptibly(
-          suspendToken, waitTimeMillis, -1, tryLock, interruptible, false);
+        gotToken =
+            lockInterruptibly(suspendToken, waitTimeMillis, -1, tryLock, interruptible, false);
-//    }
-//    finally {
-//      synchronized(this.lockingSuspendedMonitor) {
-//        this.lockingSuspendedMonitor.notifyAll();
-//      }
-//    }
-    
-    }
-    finally {
+      // }
+      // finally {
+      // synchronized(this.lockingSuspendedMonitor) {
+      // this.lockingSuspendedMonitor.notifyAll();
+      // }
+      // }
+
+    } finally {
-  
+
-  public void unlock(Object name) 
-  throws LockNotHeldException, LeaseExpiredException {
+  public void unlock(Object name) throws LockNotHeldException, LeaseExpiredException {
-    
+
-        logger.trace(LogMarker.DLS, "{}, name: {} - disconnect listener thread is exiting unlock()", this, name);
+        logger.trace(LogMarker.DLS, "{}, name: {} - disconnect listener thread is exiting unlock()",
+            this, name);
-    
+
-    
+
-    
+
-    
+
-      
+
-          throw new LockNotHeldException(LocalizedStrings.DLockService_ATTEMPTING_TO_UNLOCK_0_1_BUT_THIS_THREAD_DOESNT_OWN_THE_LOCK.toLocalizedString(new Object[] {this, name}));
+          throw new LockNotHeldException(
+              LocalizedStrings.DLockService_ATTEMPTING_TO_UNLOCK_0_1_BUT_THIS_THREAD_DOESNT_OWN_THE_LOCK
+                  .toLocalizedString(new Object[] {this, name}));
-        
+
-              logger.trace(LogMarker.DLS, "{}, [unlock] {} not leased by this thread.", this, token);
+              logger.trace(LogMarker.DLS, "{}, [unlock] {} not leased by this thread.", this,
+                  token);
-            throw new LockNotHeldException(LocalizedStrings.DLockService_ATTEMPTING_TO_UNLOCK_0_1_BUT_THIS_THREAD_DOESNT_OWN_THE_LOCK_2.toLocalizedString(new Object[] {this, name, token}));
+            throw new LockNotHeldException(
+                LocalizedStrings.DLockService_ATTEMPTING_TO_UNLOCK_0_1_BUT_THIS_THREAD_DOESNT_OWN_THE_LOCK_2
+                    .toLocalizedString(new Object[] {this, name, token}));
-          }
-          else {
+          } else {
-  
+
-        
+
-            released = callReleaseProcessor(theLockGrantorId
-                .getLockGrantorMember(), name, lockBatch, lockId);
+            released = callReleaseProcessor(theLockGrantorId.getLockGrantorMember(), name,
+                lockBatch, lockId);
-          }
-          catch (LockGrantorDestroyedException e) { // part of fix for bug 35239
+          } catch (LockGrantorDestroyedException e) { // part of fix for bug 35239
-          }
-          catch (LockServiceDestroyedException e) { // part of fix for bug 35239
+          } catch (LockServiceDestroyedException e) { // part of fix for bug 35239
-          }
-          finally {
+          } finally {
-              notLockGrantorId(theLockGrantorId, true);
+              notLockGrantorId(theLockGrantorId, 0, TimeUnit.MILLISECONDS);
-      
+
-//            // token is still held if grantor was remote, so now we unlock...
-//            checkDestroyed(); // part of fix for bug 35239
-//            // this release is ok even if we have become the lock grantor
-//            //   because the grantor will have no state for this lock
+            // // token is still held if grantor was remote, so now we unlock...
+            // checkDestroyed(); // part of fix for bug 35239
+            // // this release is ok even if we have become the lock grantor
+            // // because the grantor will have no state for this lock
-      }
-      finally {
+      } finally {
-   * Query the grantor for current leasing information of a lock. Returns
-   * the current lease info.
+   * Query the grantor for current leasing information of a lock. Returns the current lease info.
-   * @throws LockServiceDestroyedException if local instance of lock service
-   * has been destroyed
+   * @throws LockServiceDestroyedException if local instance of lock service has been destroyed
-    //long statStart = getStats().startLockRelease();
+    // long statStart = getStats().startLockRelease();
-      
+
-          queryReply = DLockQueryProcessor.query(
-              theLockGrantorId.getLockGrantorMember(), 
-              this.serviceName, 
-              name, 
-              false /* lockBatch */, 
-              this.dm);
-        }
-        catch (LockGrantorDestroyedException e) {
+          queryReply = DLockQueryProcessor.query(theLockGrantorId.getLockGrantorMember(),
+              this.serviceName, name, false /* lockBatch */, this.dm);
+        } catch (LockGrantorDestroyedException e) {
-        }
-        finally {
+        } finally {
-            notLockGrantorId(theLockGrantorId, true);
+            notLockGrantorId(theLockGrantorId, 0, TimeUnit.MILLISECONDS);
-      
-      return DLockRemoteToken.create(
-          name, queryReply.getLesseeThread(),
-          queryReply.getLeaseId(), queryReply.getLeaseExpireTime());
-      
+
+      return DLockRemoteToken.create(name, queryReply.getLesseeThread(), queryReply.getLeaseId(),
+          queryReply.getLeaseExpireTime());
+
-  
+
-  //   Creation methods
+  // Creation methods
-  
+
-   * Factory method for creating a new instance of <code>DLockService</code>.
-   * This ensures that adding the {@link #disconnectListener} is done while
-   * synchronized on the fully constructed instance.
+   * Factory method for creating a new instance of <code>DLockService</code>. This ensures that
+   * adding the {@link #disconnectListener} is done while synchronized on the fully constructed
+   * instance.
-   * Caller must be synchronized on {@link 
-   * DLockService#services}.
+   * Caller must be synchronized on {@link DLockService#services}.
-  static DLockService basicCreate(String serviceName, 
-                                  InternalDistributedSystem ds,
-                                  boolean isDistributed,
-                                  boolean destroyOnDisconnect,
-                                  boolean automateFreeResources)
-  throws IllegalArgumentException {
-    Assert.assertHoldsLock(services,true);
-    
+  static DLockService basicCreate(String serviceName, InternalDistributedSystem ds,
+      boolean isDistributed, boolean destroyOnDisconnect, boolean automateFreeResources)
+      throws IllegalArgumentException {
+    Assert.assertHoldsLock(services, true);
+
-    
-    DLockService svc = new DLockService(
-        serviceName, ds, isDistributed, destroyOnDisconnect, 
-            automateFreeResources);
+
+    DLockService svc = new DLockService(serviceName, ds, isDistributed, destroyOnDisconnect,
+        automateFreeResources);
-    
+
-  //   Constructors
+  // Constructors
-   * To create an instance, use 
-   * DistributedLockService.create(Object, DistributedSystem) or
+   * To create an instance, use DistributedLockService.create(Object, DistributedSystem) or
-  protected DLockService(String serviceName, 
-                         DistributedSystem ds,
-                         boolean isDistributed,
-                         boolean destroyOnDisconnect,
-                         boolean automateFreeResources) {
+  protected DLockService(String serviceName, DistributedSystem ds, boolean isDistributed,
+      boolean destroyOnDisconnect, boolean automateFreeResources) {
-    this.dm = this.ds.getDistributionManager();    
+    this.dm = this.ds.getDistributionManager();
-    this.automateFreeResources = 
-        automateFreeResources || AUTOMATE_FREE_RESOURCES;
+    this.automateFreeResources = automateFreeResources || AUTOMATE_FREE_RESOURCES;
-  
+
-  //   java.lang.Object methods
+  // java.lang.Object methods
-  
+
-    buffer.append('<')
-      .append("DLockService")
-      .append("@")
-      .append(Integer.toHexString(System.identityHashCode(this)))
-      .append(" named ")
-      .append(this.serviceName)
-      .append(" destroyed=")
-      .append(this.destroyed)
-      .append(" grantorId=")
-      .append(this.lockGrantorId)
-      .append(" grantor=")
-      .append(this.grantor)
-      .append('>');
+    buffer.append('<').append("DLockService").append("@")
+        .append(Integer.toHexString(System.identityHashCode(this))).append(" named ")
+        .append(this.serviceName).append(" destroyed=").append(this.destroyed).append(" grantorId=")
+        .append(this.lockGrantorId).append(" grantor=").append(this.grantor).append('>');
-  
+
-  //   Public instance methods
+  // Public instance methods
-  public void releaseTryLocks(DLockBatchId batchId, 
-                              boolean onlyIfSameGrantor) {
+  public void releaseTryLocks(DLockBatchId batchId, Callable<Boolean> untilCondition) {
-    
+
+        try {
+          boolean quit = untilCondition.call();
+          if (quit) {
+            return;
+          }
+        } catch (Exception e) {
+          throw new InternalGemFireException("unexpected exception", e);
+        }
-        
-        if (onlyIfSameGrantor) { // this was a fix for bug #38763, from r19555
-          theLockGrantorId = batchId.getLockGrantorId();
-          synchronized (this.lockGrantorIdLock) {
-            if (!checkLockGrantorId(theLockGrantorId)) {
-              // the grantor is different so break and skip DLockReleaseProcessor
-              break;
-            }
+
+        theLockGrantorId = batchId.getLockGrantorId();
+        synchronized (this.lockGrantorIdLock) {
+          if (!checkLockGrantorId(theLockGrantorId)) {
+            // the grantor is different so break and skip DLockReleaseProcessor
+            break;
-        else {
-          theLockGrantorId = getLockGrantorId();
-        }
-        released = callReleaseProcessor(
-            theLockGrantorId.getLockGrantorMember(), batchId, lockBatch, -1);
+        released =
+            callReleaseProcessor(theLockGrantorId.getLockGrantorMember(), batchId, lockBatch, -1);
-          final boolean waitForGrantor = onlyIfSameGrantor; // fix for bug #43708
-          notLockGrantorId(theLockGrantorId, waitForGrantor);
+          notLockGrantorId(theLockGrantorId, 100, TimeUnit.MILLISECONDS);
-    }
-    finally {
+    } finally {
-  
-  public boolean acquireTryLocks(final DLockBatch dlockBatch,
-                                 final long waitTimeMillis, 
-                                 final long leaseTimeMillis,
-                                 final Object[] keyIfFailed)
-  throws InterruptedException {
+
+  public boolean acquireTryLocks(final DLockBatch dlockBatch, final long waitTimeMillis,
+      final long leaseTimeMillis, final Object[] keyIfFailed) throws InterruptedException {
-    if (Thread.interrupted()) throw new InterruptedException();
+    if (Thread.interrupted())
+      throw new InterruptedException();
-      throw new IllegalArgumentException(LocalizedStrings.DLockService_KEYIFFAILED_MUST_HAVE_A_LENGTH_OF_ONE_OR_GREATER.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.DLockService_KEYIFFAILED_MUST_HAVE_A_LENGTH_OF_ONE_OR_GREATER
+              .toLocalizedString());
-    
+
-    
-    // -1 means "lease forever".  Long.MAX_VALUE is pretty close.
-    if (requestLeaseTime == -1) requestLeaseTime = Long.MAX_VALUE;
-    
-    // -1 means "wait forever".  Long.MAX_VALUE is pretty close.
-    if (requestWaitTime == -1) requestWaitTime = Long.MAX_VALUE;
+
+    // -1 means "lease forever". Long.MAX_VALUE is pretty close.
+    if (requestLeaseTime == -1)
+      requestLeaseTime = Long.MAX_VALUE;
+
+    // -1 means "wait forever". Long.MAX_VALUE is pretty close.
+    if (requestWaitTime == -1)
+      requestWaitTime = Long.MAX_VALUE;
-    if (waitLimit < 0) waitLimit = Long.MAX_VALUE;
-      
+    if (waitLimit < 0)
+      waitLimit = Long.MAX_VALUE;
+
-      
+
-      ThreadRequestState requestState = 
-          (ThreadRequestState) this.threadRequestState.get();
+      ThreadRequestState requestState = (ThreadRequestState) this.threadRequestState.get();
-      }
-      else {
+      } else {
-    
+
-        
+
-        DLockRequestProcessor processor = createRequestProcessor(
-            theLockGrantorId, dlockBatch, threadId, startTime,
-            requestLeaseTime, requestWaitTime, reentrant, tryLock, false);
+        DLockRequestProcessor processor = createRequestProcessor(theLockGrantorId, dlockBatch,
+            threadId, startTime, requestLeaseTime, requestWaitTime, reentrant, tryLock, false);
-        }
-        else if (processor.repliedDestroyed()) {
+        } else if (processor.repliedDestroyed()) {
-          Assert.assertTrue(isDestroyed(),
-              "Grantor reports service " + this + " is destroyed");
-        }
-        else if (processor.repliedNotGrantor() || processor.hadNoResponse()) {
-          notLockGrantorId(theLockGrantorId, true);
-        }
-        else {
+          Assert.assertTrue(isDestroyed(), "Grantor reports service " + this + " is destroyed");
+        } else if (processor.repliedNotGrantor() || processor.hadNoResponse()) {
+          notLockGrantorId(theLockGrantorId, 0, TimeUnit.MILLISECONDS);
+        } else {
-              logger.trace(LogMarker.DLS, "[acquireTryLocks] lock request failed but provided no conflict key; responseCode=", processor.getResponseCodeString());
+              logger.trace(LogMarker.DLS,
+                  "[acquireTryLocks] lock request failed but provided no conflict key; responseCode=",
+                  processor.getResponseCodeString());
-          }
-          else {
+          } else {
-        
+
-          }
-          catch (InterruptedException ignore) {
+          } catch (InterruptedException ignore) {
-        
+
-        logger.trace(LogMarker.DLS, "[acquireTryLocks] {} locks for {}", (gotLocks ? "acquired" : "failed to acquire"), dlockBatch);
+        logger.trace(LogMarker.DLS, "[acquireTryLocks] {} locks for {}",
+            (gotLocks ? "acquired" : "failed to acquire"), dlockBatch);
-//    catch (Error e) {
-//      gotLocks = false;
-//    }
-//    catch (RuntimeException e) {
-//      gotLocks = false;
-//    }
+    // catch (Error e) {
+    // gotLocks = false;
+    // }
+    // catch (RuntimeException e) {
+    // gotLocks = false;
+    // }
-  
+
-   * Called by {@link 
-   * org.apache.geode.internal.admin.remote.FetchDistLockInfoResponse}.
+   * Called by {@link org.apache.geode.internal.admin.remote.FetchDistLockInfoResponse}.
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  DLockRecoverGrantorProcessor.MessageProcessor recoverGrantorProcessor) {
+      DLockRecoverGrantorProcessor.MessageProcessor recoverGrantorProcessor) {
-  
-  public DLockRecoverGrantorProcessor.MessageProcessor 
-  getDLockRecoverGrantorMessageProcessor() {
+
+  public DLockRecoverGrantorProcessor.MessageProcessor getDLockRecoverGrantorMessageProcessor() {
-  /** 
-   * Returns true if any tokens in this service are currently held. 
-   * Synchronizes on tokens map and on each token to check the lease.
+  /**
+   * Returns true if any tokens in this service are currently held. Synchronizes on tokens map and
+   * on each token to check the lease.
-  boolean hasHeldLocks() {  
+  boolean hasHeldLocks() {
-  public static void destroyServiceNamed(String serviceName)
-  throws IllegalArgumentException {
+  public static void destroyServiceNamed(String serviceName) throws IllegalArgumentException {
-      throw new IllegalArgumentException(LocalizedStrings.DLockService_SERVICE_NAMED_0_NOT_CREATED.toLocalizedString(serviceName));
+      throw new IllegalArgumentException(
+          LocalizedStrings.DLockService_SERVICE_NAMED_0_NOT_CREATED.toLocalizedString(serviceName));
-  
+
-      DLockService svc = 
-        (DLockService) iter.next();
+      DLockService svc = (DLockService) iter.next();
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
-          logger.trace(LogMarker.DLS, "destroyAndRemove of {} terminated due to cancellation: ", svc, e);
+          logger.trace(LogMarker.DLS, "destroyAndRemove of {} terminated due to cancellation: ",
+              svc, e);
-      }
-      catch (RuntimeException e) {
+      } catch (RuntimeException e) {
-//      catch (VirtualMachineError err) {
-//        SystemFailure.initiateFailure(err);
-//        // If this ever returns, rethrow the error.  We're poisoned
-//        // now, so don't let this thread continue.
-//        throw err;
-//      }
-//      catch (Throwable t) {
-//        // Whenever you catch Error or Throwable, you must also
-//        // catch VirtualMachineError (see above).  However, there is
-//        // _still_ a possibility that you are dealing with a cascading
-//        // error condition, so you also need to check to see if the JVM
-//        // is still usable:
-//        SystemFailure.checkFailure();
-//        try {
-//          logger.warn(new LocalizedMessage(LocalizedStrings.DLockService_DESTROYANDREMOVE_OF_0_MAY_HAVE_FAILED,
-//              svc), t);
-//        }
-//        catch (VirtualMachineError err) {
-//          SystemFailure.initiateFailure(err);
-//          // If this ever returns, rethrow the error.  We're poisoned
-//          // now, so don't let this thread continue.
-//          throw err;
-//        }
-//        catch (Throwable t2) {
-//          // Whenever you catch Error or Throwable, you must also
-//          // catch VirtualMachineError (see above).  However, there is
-//          // _still_ a possibility that you are dealing with a cascading
-//          // error condition, so you also need to check to see if the JVM
-//          // is still usable:
-//          SystemFailure.checkFailure();
-//          t.printStackTrace();
-//          t2.printStackTrace();
-//        }
-//      }
+      // catch (VirtualMachineError err) {
+      // SystemFailure.initiateFailure(err);
+      // // If this ever returns, rethrow the error. We're poisoned
+      // // now, so don't let this thread continue.
+      // throw err;
+      // }
+      // catch (Throwable t) {
+      // // Whenever you catch Error or Throwable, you must also
+      // // catch VirtualMachineError (see above). However, there is
+      // // _still_ a possibility that you are dealing with a cascading
+      // // error condition, so you also need to check to see if the JVM
+      // // is still usable:
+      // SystemFailure.checkFailure();
+      // try {
+      // logger.warn(new
+      // LocalizedMessage(LocalizedStrings.DLockService_DESTROYANDREMOVE_OF_0_MAY_HAVE_FAILED,
+      // svc), t);
+      // }
+      // catch (VirtualMachineError err) {
+      // SystemFailure.initiateFailure(err);
+      // // If this ever returns, rethrow the error. We're poisoned
+      // // now, so don't let this thread continue.
+      // throw err;
+      // }
+      // catch (Throwable t2) {
+      // // Whenever you catch Error or Throwable, you must also
+      // // catch VirtualMachineError (see above). However, there is
+      // // _still_ a possibility that you are dealing with a cascading
+      // // error condition, so you also need to check to see if the JVM
+      // // is still usable:
+      // SystemFailure.checkFailure();
+      // t.printStackTrace();
+      // t2.printStackTrace();
+      // }
+      // }
-    
+
+   * 
-  
+
-  
+
-            if (isDestroyed()) return;
+            if (isDestroyed())
+              return;
-            }  
-          }
-          finally {
+            }
+          } finally {
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
-      }
-      finally {
+      } finally {
-          }
-          catch (CancelException e) {
+          } catch (CancelException e) {
-          }
-          finally {
+          } finally {
-  
+
-   * Unlock all locks currently held by this process, and mark it as
-   * destroyed. Returns true if caller performed actual destroy. Returns false
-   * if this lock service has already been destroyed.
+   * Unlock all locks currently held by this process, and mark it as destroyed. Returns true if
+   * caller performed actual destroy. Returns false if this lock service has already been destroyed.
-   * {@link #services} is held for the entire operation. {@link #destroyLock}
-   * is held only while setting {@link #destroyed} to true and just prior to
-   * performing any real work.
+   * {@link #services} is held for the entire operation. {@link #destroyLock} is held only while
+   * setting {@link #destroyed} to true and just prior to performing any real work.
-   * Caller must be synchronized on {@link 
-   * DLockService#services};
+   * Caller must be synchronized on {@link DLockService#services};
-  private void basicDestroy(boolean isCurrentlyLockGrantor, 
-                            boolean isMakingLockGrantor,
-                            boolean maybeHasActiveLocks) {
-    Assert.assertHoldsLock(services,false);
-    //synchronized (this.serviceLock) {
+  private void basicDestroy(boolean isCurrentlyLockGrantor, boolean isMakingLockGrantor,
+      boolean maybeHasActiveLocks) {
+    Assert.assertHoldsLock(services, false);
+    // synchronized (this.serviceLock) {
-      logger.trace(LogMarker.DLS, "[DLockService.basicDestroy] Destroying {}, isCurrentlyLockGrantor={}, isMakingLockGrantor={}", this, isCurrentlyLockGrantor, isMakingLockGrantor);
+      logger.trace(LogMarker.DLS,
+          "[DLockService.basicDestroy] Destroying {}, isCurrentlyLockGrantor={}, isMakingLockGrantor={}",
+          this, isCurrentlyLockGrantor, isMakingLockGrantor);
-      
-      // if hasActiveLocks, tell grantor we're destroying...
-      if (!isCurrentlyLockGrantor && maybeHasActiveLocks && 
-          !this.ds.isDisconnectListenerThread()) {
-        boolean retry;
-        int nonGrantorDestroyLoopCount = 0;
-        do {
-          retry = false;
-          LockGrantorId theLockGrantorId = peekLockGrantorId();
-          
-          if (theLockGrantorId != null && !theLockGrantorId.isLocal(getSerialNumber())) {
-            if (!NonGrantorDestroyedProcessor.send(this.serviceName, theLockGrantorId, dm)) {
-              // grantor responded NOT_GRANTOR
-              notLockGrantorId(theLockGrantorId, true); // nulls out grantor to force call to elder
-              retry = true;
-            }
-          }
-          
-          if (DEBUG_NONGRANTOR_DESTROY_LOOP) {
-            nonGrantorDestroyLoopCount++;
-            if (nonGrantorDestroyLoopCount >= DEBUG_NONGRANTOR_DESTROY_LOOP_COUNT) {
-              logger.fatal(LogMarker.DLS, LocalizedMessage.create(LocalizedStrings.DLockService_FAILED_TO_NOTIFY_GRANTOR_OF_DESTRUCTION_WITHIN_0_ATTEMPTS,
-                  Integer.valueOf(DEBUG_NONGRANTOR_DESTROY_LOOP_COUNT)));
-              Assert.assertTrue(false, 
-                  LocalizedStrings.DLockService_FAILED_TO_NOTIFY_GRANTOR_OF_DESTRUCTION_WITHIN_0_ATTEMPTS
-                  .toLocalizedString(
-                      new Object[] {Integer.valueOf(DEBUG_NONGRANTOR_DESTROY_LOOP_COUNT)}));
-            }
-          }
-          
-        } while (retry);
-      }
-    
-      // KIRK: probably don't need to do the following if isMakingLockGrantor
-      if (isCurrentlyLockGrantor || isMakingLockGrantor) {
-        // If forcedDisconnect is in progress, the membership view will not
-        // change and no-one else can contact this member, so don't wait for a grantor
-        if (this.ds.getCancelCriterion().isCancelInProgress()) {
-          // KIRK: probably don't need to waitForGrantor
-          try {
-            DLockGrantor.waitForGrantor(this);
-          }
-          catch (InterruptedException e) {
-            Thread.currentThread().interrupt();
-          } catch(DistributedSystemDisconnectedException e) {
-            if (isDebugEnabled_DLS) {
-              logger.trace(LogMarker.DLS, "No longer waiting for grantor because of disconnect.", e);
-            }
+
+    // if hasActiveLocks, tell grantor we're destroying...
+    if (!isCurrentlyLockGrantor && maybeHasActiveLocks && !this.ds.isDisconnectListenerThread()) {
+      boolean retry;
+      int nonGrantorDestroyLoopCount = 0;
+      do {
+        retry = false;
+        LockGrantorId theLockGrantorId = peekLockGrantorId();
+
+        if (theLockGrantorId != null && !theLockGrantorId.isLocal(getSerialNumber())) {
+          if (!NonGrantorDestroyedProcessor.send(this.serviceName, theLockGrantorId, dm)) {
+            // grantor responded NOT_GRANTOR
+            notLockGrantorId(theLockGrantorId, 0, TimeUnit.MILLISECONDS); // nulls out grantor to
+                                                                          // force call to elder
+            retry = true;
-        nullLockGrantorId(this.lockGrantorId);
+
+        if (DEBUG_NONGRANTOR_DESTROY_LOOP) {
+          nonGrantorDestroyLoopCount++;
+          if (nonGrantorDestroyLoopCount >= DEBUG_NONGRANTOR_DESTROY_LOOP_COUNT) {
+            logger.fatal(LogMarker.DLS,
+                LocalizedMessage.create(
+                    LocalizedStrings.DLockService_FAILED_TO_NOTIFY_GRANTOR_OF_DESTRUCTION_WITHIN_0_ATTEMPTS,
+                    Integer.valueOf(DEBUG_NONGRANTOR_DESTROY_LOOP_COUNT)));
+            Assert.assertTrue(false,
+                LocalizedStrings.DLockService_FAILED_TO_NOTIFY_GRANTOR_OF_DESTRUCTION_WITHIN_0_ATTEMPTS
+                    .toLocalizedString(
+                        new Object[] {Integer.valueOf(DEBUG_NONGRANTOR_DESTROY_LOOP_COUNT)}));
+          }
+        }
+
+      } while (retry);
+    }
+
+    // KIRK: probably don't need to do the following if isMakingLockGrantor
+    if (isCurrentlyLockGrantor || isMakingLockGrantor) {
+      // If forcedDisconnect is in progress, the membership view will not
+      // change and no-one else can contact this member, so don't wait for a grantor
+      if (this.ds.getCancelCriterion().isCancelInProgress()) {
+        // KIRK: probably don't need to waitForGrantor
+        try {
+          DLockGrantor.waitForGrantor(this);
+        } catch (InterruptedException e) {
+          Thread.currentThread().interrupt();
+        } catch (DistributedSystemDisconnectedException e) {
+          if (isDebugEnabled_DLS) {
+            logger.trace(LogMarker.DLS, "No longer waiting for grantor because of disconnect.", e);
+          }
+        }
-    //}
+      nullLockGrantorId(this.lockGrantorId);
+    }
+    // }
-    
+
-  //   Package instance methods
+  // Package instance methods
-  
-  /** 
-   * Called by grantor recovery to return set of locks held by this process.
-   * Synchronizes on lockGrantorIdLock, tokens map, and each lock token.
+
+  /**
+   * Called by grantor recovery to return set of locks held by this process. Synchronizes on
+   * lockGrantorIdLock, tokens map, and each lock token.
-    
+
-      
+
-    
+
-    // and grantorVersion is greater than currentGrantorVersion 
-    if (currentLockGrantorId != null &&
-        currentLockGrantorId.hasLockGrantorVersion() &&
-        newlockGrantorId.isNewerThan(currentLockGrantorId)) {
+    // and grantorVersion is greater than currentGrantorVersion
+    if (currentLockGrantorId != null && currentLockGrantorId.hasLockGrantorVersion()
+        && newlockGrantorId.isNewerThan(currentLockGrantorId)) {
-      
+
-              
+
-              
+
-      
+
-  
+
-   * Returns the named lock token or null if it doesn't exist. Synchronizes on 
-   * tokens map. 
+   * Returns the named lock token or null if it doesn't exist. Synchronizes on tokens map.
-  
+
-   * Returns the named lock token or null if it doesn't exist. Caller must 
-   * synchronize on tokens map. 
+   * Returns the named lock token or null if it doesn't exist. Caller must synchronize on tokens
+   * map.
-  
+
-   * Returns an unmodifiable collection backed by the values of the DLockToken 
-   * map for testing purposes only. Synchronizes on tokens map.
+   * Returns an unmodifiable collection backed by the values of the DLockToken map for testing
+   * purposes only. Synchronizes on tokens map.
-  
+
-   * Returns an existing or creates a new DLockToken. Synchronizes on tokens
-   * map and the lock token. 
+   * Returns an existing or creates a new DLockToken. Synchronizes on tokens map and the lock token.
-  
+
-  //   Private instance methods
+  // Private instance methods
-  
+
-   * Returns number of lock tokens currently leased by this member.
-   * Synchronizes on tokens map and each lock token.
+   * Returns number of lock tokens currently leased by this member. Synchronizes on tokens map and
+   * each lock token.
-        DLockToken token = (DLockToken)iter.next();
-        synchronized(token) {
+        DLockToken token = (DLockToken) iter.next();
+        synchronized (token) {
-   * TEST HOOK: Logs all lock tokens for this service at INFO level. 
-   * Synchronizes on tokens map and each lock token.
+   * TEST HOOK: Logs all lock tokens for this service at INFO level. Synchronizes on tokens map and
+   * each lock token.
-        Map.Entry entry = (Map.Entry)iter.next();
+        Map.Entry entry = (Map.Entry) iter.next();
-        DLockToken token = (DLockToken)entry.getValue();
+        DLockToken token = (DLockToken) entry.getValue();
+
+
+
-  
+
-  
-  /** Returns true if the calling thread has an active lock request that 
-   * is interruptible */
+
+  /**
+   * Returns true if the calling thread has an active lock request that is interruptible
+   */
-    final ThreadRequestState requestState = 
-        (ThreadRequestState) threadRequestState.get();
+    final ThreadRequestState requestState = (ThreadRequestState) threadRequestState.get();
+
+
-  //   System disconnect listener
+  // System disconnect listener
-  
+
-    new InternalDistributedSystem.DisconnectListener() {
-      @Override
-      public String toString() {
-        return LocalizedStrings.DLockService_DISCONNECT_LISTENER_FOR_DISTRIBUTEDLOCKSERVICE.toLocalizedString();
-      }
-      
-      public void onDisconnect(final InternalDistributedSystem sys) {
-        final boolean isDebugEnabled_DLS = logger.isTraceEnabled(LogMarker.DLS);
-        if (isDebugEnabled_DLS) {
-          logger.trace(LogMarker.DLS, "Shutting down Distributed Lock Services");
+      new InternalDistributedSystem.DisconnectListener() {
+        @Override
+        public String toString() {
+          return LocalizedStrings.DLockService_DISCONNECT_LISTENER_FOR_DISTRIBUTEDLOCKSERVICE
+              .toLocalizedString();
-        long start = System.currentTimeMillis();
-        try {
-          destroyAll();
-        }
-        finally {
-          closeStats();
-          long delta = System.currentTimeMillis() - start;
+
+        public void onDisconnect(final InternalDistributedSystem sys) {
+          final boolean isDebugEnabled_DLS = logger.isTraceEnabled(LogMarker.DLS);
-            logger.trace(LogMarker.DLS, "Distributed Lock Services stopped (took {} ms)", delta);
+            logger.trace(LogMarker.DLS, "Shutting down Distributed Lock Services");
+          }
+          long start = System.currentTimeMillis();
+          try {
+            destroyAll();
+          } finally {
+            closeStats();
+            long delta = System.currentTimeMillis() - start;
+            if (isDebugEnabled_DLS) {
+              logger.trace(LogMarker.DLS, "Distributed Lock Services stopped (took {} ms)", delta);
+            }
-      }
-    };
+      };
-    
+
-  
+
-  
+
-  //   Static fields
+  // Static fields
-  
+
-  
+
-  //   Reserved lock service names
+  // Reserved lock service names
-  
+
-  static final String[] reservedNames = new String[] { LTLS, DTLS };
-  
+  static final String[] reservedNames = new String[] {LTLS, DTLS};
+
-  //   DLS serial number (uniquely identifies local instance of DLS)
+  // DLS serial number (uniquely identifies local instance of DLS)
-  
+
-  public static final int START_SERIAL_NUMBER = Integer.getInteger(
-      DistributionConfig.GEMFIRE_PREFIX + "DistributedLockService.startSerialNumber", 1).intValue();
-  
+  public static final int START_SERIAL_NUMBER = Integer
+      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "DistributedLockService.startSerialNumber", 1)
+      .intValue();
+
+   * 
-  private static final AtomicInteger serialNumberSequencer = 
-      new AtomicInteger(START_SERIAL_NUMBER);
+  private static final AtomicInteger serialNumberSequencer = new AtomicInteger(START_SERIAL_NUMBER);
-  /** 
-   * Identifies the static order in which this DLS was created in relation 
-   * to other DLS or other instances of this DLS during the life of 
-   * this JVM. Rollover to negative is allowed.
+  /**
+   * Identifies the static order in which this DLS was created in relation to other DLS or other
+   * instances of this DLS during the life of this JVM. Rollover to negative is allowed.
-  
-  /** 
-   * Generates a serial number for identifying a DLS. Later instances of 
-   * the same named DLS will have a greater serial number than earlier 
-   * instances. This number increments statically throughout the life of this 
-   * JVM. Rollover to negative is allowed.
+
+  /**
+   * Generates a serial number for identifying a DLS. Later instances of the same named DLS will
+   * have a greater serial number than earlier instances. This number increments statically
+   * throughout the life of this JVM. Rollover to negative is allowed.
+   * 
-  
-  /** 
-   * Returns the serial number which identifies the static order in which this 
-   * DLS was created in relation to other DLS'es or other instances of 
-   * this named DLS during the life of this JVM.
+
+  /**
+   * Returns the serial number which identifies the static order in which this DLS was created in
+   * relation to other DLS'es or other instances of this named DLS during the life of this JVM.
-  
+
-  //   External API methods
+  // External API methods
-  
+
-  
-  public static DistributedLockService create(String serviceName, 
-                                              InternalDistributedSystem ds,
-                                              boolean distributed,
-                                              boolean destroyOnDisconnect) {
+
+  public static DistributedLockService create(String serviceName, InternalDistributedSystem ds,
+      boolean distributed, boolean destroyOnDisconnect) {
-  
+
-   * @param serviceName 
-   *        name of the service
-   * @param ds 
-   *        InternalDistributedSystem
-   * @param distributed 
-   *        true if lock service will be distributed; false will be local only
-   * @param destroyOnDisconnect
-   *        true if lock service should destroy itself using system disconnect 
+   * @param serviceName name of the service
+   * @param ds InternalDistributedSystem
+   * @param distributed true if lock service will be distributed; false will be local only
+   * @param destroyOnDisconnect true if lock service should destroy itself using system disconnect
-   * @param automateFreeResources
-   *        true if freeResources should be automatically called during unlock
+   * @param automateFreeResources true if freeResources should be automatically called during unlock
-   * @throws IllegalArgumentException if serviceName is invalid or this process 
-   * has already created named service
+   * @throws IllegalArgumentException if serviceName is invalid or this process has already created
+   *         named service
-  public static DistributedLockService create(String serviceName, 
-                                              InternalDistributedSystem ds,
-                                              boolean distributed,
-                                              boolean destroyOnDisconnect,
-                                              boolean automateFreeResources)
-  throws IllegalArgumentException, IllegalStateException {
+  public static DistributedLockService create(String serviceName, InternalDistributedSystem ds,
+      boolean distributed, boolean destroyOnDisconnect, boolean automateFreeResources)
+      throws IllegalArgumentException, IllegalStateException {
-        
+
-        
+
-          throw new IllegalArgumentException(LocalizedStrings.DLockService_SERVICE_NAMED_0_ALREADY_CREATED.toLocalizedString(serviceName));
+          throw new IllegalArgumentException(
+              LocalizedStrings.DLockService_SERVICE_NAMED_0_ALREADY_CREATED
+                  .toLocalizedString(serviceName));
-        return DLockService.basicCreate(
-            serviceName, ds, distributed, destroyOnDisconnect, automateFreeResources);
+        return DLockService.basicCreate(serviceName, ds, distributed, destroyOnDisconnect,
+            automateFreeResources);
-    
-  public static void becomeLockGrantor(String serviceName)
-  throws IllegalArgumentException {
+
+  public static void becomeLockGrantor(String serviceName) throws IllegalArgumentException {
-  
+
-  throws IllegalArgumentException {
+      throws IllegalArgumentException {
-      throw new IllegalArgumentException(LocalizedStrings.DLockService_SERVICE_NAMED_0_IS_NOT_VALID.toLocalizedString(serviceName));
+      throw new IllegalArgumentException(LocalizedStrings.DLockService_SERVICE_NAMED_0_IS_NOT_VALID
+          .toLocalizedString(serviceName));
-      throw new IllegalArgumentException(LocalizedStrings.DLockService_SERVICE_NAMED_0_NOT_CREATED.toLocalizedString(serviceName));
+      throw new IllegalArgumentException(
+          LocalizedStrings.DLockService_SERVICE_NAMED_0_NOT_CREATED.toLocalizedString(serviceName));
-  
-  public static boolean isLockGrantor(String serviceName)
-  throws IllegalArgumentException {
+
+  public static boolean isLockGrantor(String serviceName) throws IllegalArgumentException {
-      throw new IllegalArgumentException(LocalizedStrings.DLockService_SERVICE_NAMED_0_IS_NOT_VALID.toLocalizedString(serviceName));
+      throw new IllegalArgumentException(LocalizedStrings.DLockService_SERVICE_NAMED_0_IS_NOT_VALID
+          .toLocalizedString(serviceName));
-      throw new IllegalArgumentException(LocalizedStrings.DLockService_SERVICE_NAMED_0_NOT_CREATED.toLocalizedString(serviceName));
+      throw new IllegalArgumentException(
+          LocalizedStrings.DLockService_SERVICE_NAMED_0_NOT_CREATED.toLocalizedString(serviceName));
+   * 
-   * @param nonGrantors filled with service names of all services we have that we are not the grantor of.
+   * @param nonGrantors filled with service names of all services we have that we are not the
+   *        grantor of.
-  public static void recoverRmtElder(ArrayList grantors, 
-                                     ArrayList grantorVersions, 
-                                     ArrayList grantorSerialNumbers, 
-                                     ArrayList nonGrantors) {
+  public static void recoverRmtElder(ArrayList grantors, ArrayList grantorVersions,
+      ArrayList grantorSerialNumbers, ArrayList nonGrantors) {
-        Map.Entry entry = (Map.Entry)entries.next();
-        String serviceName = (String)entry.getKey();
-        DLockService service = (DLockService)entry.getValue();
+        Map.Entry entry = (Map.Entry) entries.next();
+        String serviceName = (String) entry.getKey();
+        DLockService service = (DLockService) entry.getValue();
-        if (grantor != null
-            && grantor.getVersionId() != -1
-            && !grantor.isDestroyed()) {
+        if (grantor != null && grantor.getVersionId() != -1 && !grantor.isDestroyed()) {
+
-   * Called when an elder is doing recovery.
-   * For every service that we are the grantor for add it to the grantorMap
-   * For every service we have that is not in the grantorMap add its name
-   * to needsRecovery set.
-   * @param dm our local DM 
+   * Called when an elder is doing recovery. For every service that we are the grantor for add it to
+   * the grantorMap For every service we have that is not in the grantorMap add its name to
+   * needsRecovery set.
+   * 
+   * @param dm our local DM
-        Map.Entry entry = (Map.Entry)entries.next();
-        String serviceName = (String)entry.getKey();
-        DLockService service = (DLockService)entry.getValue();
+        Map.Entry entry = (Map.Entry) entries.next();
+        String serviceName = (String) entry.getKey();
+        DLockService service = (DLockService) entry.getValue();
-        if (grantor != null
-            && grantor.getVersionId() != -1
-            && !grantor.isDestroyed()) {
+        if (grantor != null && grantor.getVersionId() != -1 && !grantor.isDestroyed()) {
-          GrantorInfo oldgi = (GrantorInfo)grantors.get(serviceName);
-          if (oldgi == null
-              || oldgi.getVersionId() < grantor.getVersionId()) {
-            grantors.put(serviceName, new GrantorInfo(dm.getId(), grantor.getVersionId(), service.getSerialNumber(), false));
+          GrantorInfo oldgi = (GrantorInfo) grantors.get(serviceName);
+          if (oldgi == null || oldgi.getVersionId() < grantor.getVersionId()) {
+            grantors.put(serviceName, new GrantorInfo(dm.getId(), grantor.getVersionId(),
+                service.getSerialNumber(), false));
-  //   Public static methods
+  // Public static methods
-  
+
-  
+
-      throw new IllegalArgumentException(LocalizedStrings.DLockService_LOCK_SERVICE_NAME_MUST_NOT_BE_NULL_OR_EMPTY.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.DLockService_LOCK_SERVICE_NAME_MUST_NOT_BE_NULL_OR_EMPTY
+              .toLocalizedString());
-      throw new IllegalArgumentException(LocalizedStrings.DLockService_SERVICE_NAMED_0_IS_RESERVED_FOR_INTERNAL_USE_ONLY.toLocalizedString(serviceName));
+        throw new IllegalArgumentException(
+            LocalizedStrings.DLockService_SERVICE_NAMED_0_IS_RESERVED_FOR_INTERNAL_USE_ONLY
+                .toLocalizedString(serviceName));
-      
+
-    synchronized(services) {
+    synchronized (services) {
-  
+
-   * TEST HOOK: Logs all lock tokens for every service at INFO level. 
-   * Synchronizes on services map, service tokens maps and each lock token.
+   * TEST HOOK: Logs all lock tokens for every service at INFO level. Synchronizes on services map,
+   * service tokens maps and each lock token.
-      logger.info(LogMarker.DLS, LocalizedMessage.create(LocalizedStrings.TESTING, "DLockService.dumpAllServices() - " + services.size() + " services:\n"));
+      logger.info(LogMarker.DLS, LocalizedMessage.create(LocalizedStrings.TESTING,
+          "DLockService.dumpAllServices() - " + services.size() + " services:\n"));
-        Map.Entry entry = (Map.Entry)entries.next();
+        Map.Entry entry = (Map.Entry) entries.next();
-        DLockService svc = (DLockService)entry.getValue();
+        DLockService svc = (DLockService) entry.getValue();
-        
+
-  
+
-  //   Package static methods
+  // Package static methods
-  
+
-  
+
+   * 
-  
+
-      Assert.assertTrue(ds != null, 
-          "Need an instance of InternalDistributedSystem");
+      Assert.assertTrue(ds != null, "Need an instance of InternalDistributedSystem");
-  
+
-  
+
-      DLockService removedService = (DLockService)  
-          services.remove(service.getName());
+      DLockService removedService = (DLockService) services.remove(service.getName());
-      ((DLockStats)stats).close();
+      ((DLockStats) stats).close();
+
-  static GrantorInfo checkLockGrantorInfo(String serviceName, 
-                                          InternalDistributedSystem system) {
-    GrantorInfo gi = GrantorRequestProcessor.peekGrantor(serviceName, 
-        system);
+  static GrantorInfo checkLockGrantorInfo(String serviceName, InternalDistributedSystem system) {
+    GrantorInfo gi = GrantorRequestProcessor.peekGrantor(serviceName, system);
-  //   Internal
+  // Internal
-  
+
-      Assert.assertTrue(ds != null, 
-          "Cannot find any instance of InternalDistributedSystem");
-      String threadGroupName = LocalizedStrings.DLockService_DISTRIBUTED_LOCKING_THREADS.toLocalizedString();
+      Assert.assertTrue(ds != null, "Cannot find any instance of InternalDistributedSystem");
+      String threadGroupName =
+          LocalizedStrings.DLockService_DISTRIBUTED_LOCKING_THREADS.toLocalizedString();
-  
+
-  //   SuspendLockingToken inner class
+  // SuspendLockingToken inner class
-  
+
-    
+
-      if (o == null) return false;
+      if (o == null)
+        return false;
-    
+
-    
+
+
+
-       return null;
+      return null;
-   * CancelCriterion which provides cancellation for DLS request and release
-   * messages. Cancellation may occur if shutdown or if DLS is destroyed.
+   * CancelCriterion which provides cancellation for DLS request and release messages. Cancellation
+   * may occur if shutdown or if DLS is destroyed.
-    
+
-    
+
-//    private boolean stoppedByDLS = false; // used by single thread
-    
+    // private boolean stoppedByDLS = false; // used by single thread
+
-    
+
-      String cancelInProgressString = 
-        this.dls.getDistributionManager().getCancelCriterion().cancelInProgress();
+      String cancelInProgressString =
+          this.dls.getDistributionManager().getCancelCriterion().cancelInProgress();
-      }
-      else if (this.dls.isDestroyed()) {
-//        this.stoppedByDLS = true;
+      } else if (this.dls.isDestroyed()) {
+        // this.stoppedByDLS = true;
-      }
-      else {
+      } else {
-//        if (this.stoppedByDLS) { // set and checked by same thread
-//        return this.dls.generateLockServiceDestroyedException(reason);
-//      }
-//      return new DistributedSystemDisconnectedException(reason, e);
+      // if (this.stoppedByDLS) { // set and checked by same thread
+      // return this.dls.generateLockServiceDestroyedException(reason);
+      // }
+      // return new DistributedSystemDisconnectedException(reason, e);
-  
+
-  
+

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS44 INS44 INS29 INS44 INS65 INS65 INS65 INS39 INS42 INS83 INS43 INS42 INS65 INS65 INS65 UPD39 UPD42 INS83 INS43 INS42 INS74 INS42 MOV65 INS65 MOV65 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV66 INS42 INS66 INS42 UPD66 MOV66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS43 INS43 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV66 UPD66 MOV66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 INS42 INS8 INS12 MOV21 INS25 INS44 INS8 INS54 MOV21 MOV51 INS27 MOV8 INS8 INS43 INS42 INS10 INS27 INS8 INS12 INS42 INS34 INS21 INS42 INS42 INS34 INS60 INS25 INS44 INS8 INS7 INS39 INS59 INS42 MOV8 INS43 INS42 INS53 INS42 INS11 INS42 INS42 INS34 INS40 INS42 INS32 INS41 INS42 INS14 INS34 INS40 INS34 INS40 INS43 INS32 INS42 INS42 INS43 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS40 INS42 INS34 INS40 INS34 INS40 INS34 INS40 INS34 INS40 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL9 DEL66 DEL9 DEL66 DEL66 DEL9 DEL66 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL83 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL9 DEL66 DEL9 DEL65 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
GEODE-7643: Gateway unprocessedTokensMap appears to grow without bounds with replicated regions and peer accessors (#4447)

* Allow LocalRegion.virtualPut to throw ConcurrentCacheModificationException

Added throwsConcurrentModifiaction boolean argument to LocalRegion.virtualPut() to determine if the exception should be thrown
Added invokeCallbacks boolean argument to LocalRegion.virtualPut() to determine if bridge clients and gateway senders should be notified of the event
Fixed issue with inheriting new virtualPut implementations
Added DUnit test to confirm fix

Co-authored-by: Benjamin Ross <bross@pivotal.io>
Co-authored-by: Donal Evans <doevans@pivotal.io>

+      boolean invokeCallbacks = true;
+
-          if (rgn.basicUpdate(ev, true /* ifNew */, false/* ifOld */, lastMod,
-              overwriteDestroyed)) {
-            rgn.getCachePerfStats().endPut(startPut, ev.isOriginRemote());
-            // we did a create, or replayed a create event
-            doUpdate = false;
-            updated = true;
-          } else { // already exists. If it was blocked by the DESTROYED token, then
-            // do no update.
+          try {
+            boolean firstBasicUpdateSuccess =
+                rgn.basicUpdate(ev, true, false, lastMod, overwriteDestroyed, true, true);
+            if (firstBasicUpdateSuccess) {
+              rgn.getCachePerfStats().endPut(startPut, ev.isOriginRemote());
+              // we did a create, or replayed a create event
+              doUpdate = false;
+              updated = true;
+            } else {
+              // already exists. If it was blocked by the DESTROYED token, then
+              // do no update.
+              doUpdate = checkIfToUpdateAfterCreateFailed(rgn, ev);
+            }
+          } catch (ConcurrentCacheModificationException ex) {
+            invokeCallbacks = false;
-            if (rgn.basicUpdate(ev, false/* ifNew */, true/* ifOld */, lastMod,
-                overwriteDestroyed)) {
+            boolean secondBasicUpdateSuccess;
+            try {
+              secondBasicUpdateSuccess =
+                  rgn.basicUpdate(ev, false, true, lastMod, overwriteDestroyed,
+                      invokeCallbacks, true);
+            } catch (ConcurrentCacheModificationException ex) {
+              secondBasicUpdateSuccess = false;
+              invokeCallbacks = false;
+            }
+            if (secondBasicUpdateSuccess) {
-            } else { // key not here or blocked by DESTROYED token
+            } else {
+              // key not here, blocked by DESTROYED token or ConcurrentCacheModificationException
+              // thrown during second update attempt
-                overwriteDestroyed = true;
-                rgn.basicUpdate(ev, false /* ifNew */, false/* ifOld */, lastMod,
-                    overwriteDestroyed);
-                rgn.getCachePerfStats().endPut(startPut, ev.isOriginRemote());
-                updated = true;
+                boolean thirdBasicUpdateSuccess =
+                    rgn.basicUpdate(ev, false, false, lastMod, true, invokeCallbacks, false);
+                if (thirdBasicUpdateSuccess) {
+                  rgn.getCachePerfStats().endPut(startPut, ev.isOriginRemote());
+                  updated = true;
+                }

INS60 INS39 INS59 INS42 INS9 INS54 INS8 INS12 INS60 MOV25 INS44 INS8 INS60 INS54 INS39 INS59 INS42 INS43 INS42 INS21 INS21 INS39 INS59 INS8 INS12 INS42 INS42 INS32 INS42 INS7 INS7 INS42 INS21 INS44 INS8 INS42 INS42 INS42 INS9 INS9 INS42 INS42 INS9 INS9 INS42 INS9 INS42 INS32 INS7 INS43 INS42 INS21 INS21 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS7 INS7 MOV21 INS60 INS25 INS42 INS42 INS42 INS9 INS9 INS42 INS42 INS42 INS9 INS42 INS9 INS42 INS9 INS39 INS59 INS42 MOV8 INS42 INS32 INS42 INS42 INS42 INS9 INS9 INS42 INS9 INS42 INS9 DEL42 DEL42 DEL42 DEL9 DEL9 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL9 DEL9 DEL42 DEL42 DEL32 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL42 DEL9 DEL9 DEL42 DEL42 DEL32 DEL21
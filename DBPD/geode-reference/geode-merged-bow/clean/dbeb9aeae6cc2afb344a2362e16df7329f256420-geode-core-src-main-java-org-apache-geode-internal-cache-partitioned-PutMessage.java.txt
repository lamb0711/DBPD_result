Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A Partitioned Region update message.  Meant to be sent only to
- * a bucket's primary owner.  In addition to updating an entry it is also used to
- * send Partitioned Region event information.
+ * A Partitioned Region update message. Meant to be sent only to a bucket's primary owner. In
+ * addition to updating an entry it is also used to send Partitioned Region event information.
-  /** Used on sender side only to defer serialization until toData is called.
+  /**
+   * Used on sender side only to defer serialization until toData is called.
-  @Unretained(ENTRY_EVENT_NEW_VALUE) 
+  @Unretained(ENTRY_EVENT_NEW_VALUE)
-  /** An additional object providing context for the operation, e.g., for BridgeServer notification */
+  /**
+   * An additional object providing context for the operation, e.g., for BridgeServer notification
+   */
-   * for relayed messages, this is the sender of the original message.  It should be used in constructing events
-   * for listener notification.
+   * for relayed messages, this is the sender of the original message. It should be used in
+   * constructing events for listener notification.
-  
+
-   * Indicates if and when the new value should be deserialized on the
-   * the receiver. Distinguishes between a non-byte[] value that was
-   * serialized (DESERIALIZATION_POLICY_LAZY) and a
-   * byte[] array value that didn't need to be serialized
-   * (DESERIALIZATION_POLICY_NONE). While this seems like an extra data, it
-   * isn't, because serializing a byte[] causes the type (a byte)
-   * to be written in the stream, AND what's better is
-   * that handling this distinction at this level reduces processing for values
-   * that are byte[].
+   * Indicates if and when the new value should be deserialized on the the receiver. Distinguishes
+   * between a non-byte[] value that was serialized (DESERIALIZATION_POLICY_LAZY) and a byte[] array
+   * value that didn't need to be serialized (DESERIALIZATION_POLICY_NONE). While this seems like an
+   * extra data, it isn't, because serializing a byte[] causes the type (a byte) to be written in
+   * the stream, AND what's better is that handling this distinction at this level reduces
+   * processing for values that are byte[].
-  protected byte deserializationPolicy =
-    DistributedCacheOperation.DESERIALIZATION_POLICY_NONE;
+  protected byte deserializationPolicy = DistributedCacheOperation.DESERIALIZATION_POLICY_NONE;
-   * For put to happen, the old value must be equal to this
-   * expectedOldValue.
+   * For put to happen, the old value must be equal to this expectedOldValue.
+   * 
-   * state from operateOnRegion that must be preserved for transmission
-   * from the waiting pool
+   * state from operateOnRegion that must be preserved for transmission from the waiting pool
-  
+
-  
+
- /** whether new value is formed by applying delta **/
+  /** whether new value is formed by applying delta **/
-  protected static final int HAS_ORIGINAL_SENDER =
-      getNextByteMask(HAS_BRIDGE_CONTEXT);
-  protected static final int HAS_DELTA_WITH_FULL_VALUE =
-      getNextByteMask(HAS_ORIGINAL_SENDER);
-  protected static final int HAS_CALLBACKARG =
-      getNextByteMask(HAS_DELTA_WITH_FULL_VALUE);
+  protected static final int HAS_ORIGINAL_SENDER = getNextByteMask(HAS_BRIDGE_CONTEXT);
+  protected static final int HAS_DELTA_WITH_FULL_VALUE = getNextByteMask(HAS_ORIGINAL_SENDER);
+  protected static final int HAS_CALLBACKARG = getNextByteMask(HAS_DELTA_WITH_FULL_VALUE);
-  private byte[] oldValBytes;
-  private transient Object oldValObj;
-  private boolean hasOldValue = false;
-  private boolean oldValueIsSerialized = false;*/
+   * private byte[] oldValBytes; private transient Object oldValObj; private boolean hasOldValue =
+   * false; private boolean oldValueIsSerialized = false;
+   */
-  public PutMessage() {
-  }
+  public PutMessage() {}
-  PutMessage(PutMessage original,EntryEventImpl event, Set members ) {
+  PutMessage(PutMessage original, EntryEventImpl event, Set members) {
-    if(original.valBytes != null){ 
+    if (original.valBytes != null) {
-    }
-    else{
-      if(original.valObj instanceof CachedDeserializable) {
+    } else {
+      if (original.valObj instanceof CachedDeserializable) {
-          if(val instanceof byte[]) {
-            this.valBytes = (byte[]) val; 
+          if (val instanceof byte[]) {
+            this.valBytes = (byte[]) val;
-  
+
-    /*this.oldValBytes = original.oldValBytes;
-    this.oldValObj = original.oldValObj;
-    this.oldValueIsSerialized = original.oldValueIsSerialized;*/
+    /*
+     * this.oldValBytes = original.oldValBytes; this.oldValObj = original.oldValObj;
+     * this.oldValueIsSerialized = original.oldValueIsSerialized;
+     */
-   * send a notification-only message to a set of listeners.  The processor
-   * id is passed with the message for reply message processing.  This method
-   * does not wait on the processor.
+   * send a notification-only message to a set of listeners. The processor id is passed with the
+   * message for reply message processing. This method does not wait on the processor.
-      FilterRoutingInfo filterInfo, 
-      PartitionedRegion r, EntryEventImpl event, boolean ifNew, boolean ifOld, 
-      DirectReplyProcessor processor, boolean sendDeltaWithFullValue) {
-    PutMessage msg = new PutMessage(Collections.EMPTY_SET, 
-        true, r.getPRId(), processor, event, 0, ifNew, ifOld, null, false);
+      FilterRoutingInfo filterInfo, PartitionedRegion r, EntryEventImpl event, boolean ifNew,
+      boolean ifOld, DirectReplyProcessor processor, boolean sendDeltaWithFullValue) {
+    PutMessage msg = new PutMessage(Collections.EMPTY_SET, true, r.getPRId(), processor, event, 0,
+        ifNew, ifOld, null, false);
-    return msg.relayToListeners(cacheOpReceivers, adjunctRecipients,
-        filterInfo, event, r, processor);
+    return msg.relayToListeners(cacheOpReceivers, adjunctRecipients, filterInfo, event, r,
+        processor);
-  private PutMessage(Set recipients,
-                     boolean notifyOnly,
-                     int regionId,
-                     DirectReplyProcessor processor,
-                     EntryEventImpl event,
-                     final long lastModified,
-                     boolean ifNew,
-                     boolean ifOld,
-                     Object expectedOldValue,
-                     boolean requireOldValue) {
+  private PutMessage(Set recipients, boolean notifyOnly, int regionId,
+      DirectReplyProcessor processor, EntryEventImpl event, final long lastModified, boolean ifNew,
+      boolean ifOld, Object expectedOldValue, boolean requireOldValue) {
-    }
-    else {
+    } else {
-      assert this.deserializationPolicy ==
-        DistributedCacheOperation.DESERIALIZATION_POLICY_NONE :
-        this.deserializationPolicy;
+      assert this.deserializationPolicy == DistributedCacheOperation.DESERIALIZATION_POLICY_NONE : this.deserializationPolicy;
-  
+
-   * Sends a PartitionedRegion
-   * {@link org.apache.geode.cache.Region#put(Object, Object)} message to
+   * Sends a PartitionedRegion {@link org.apache.geode.cache.Region#put(Object, Object)} message to
+   * 
-   * @param r  the PartitionedRegion for which the put was performed
+   * @param r the PartitionedRegion for which the put was performed
-   * @return the processor used to await acknowledgement that the update was
-   *         sent, or null to indicate that no acknowledgement will be sent
+   * @return the processor used to await acknowledgement that the update was sent, or null to
+   *         indicate that no acknowledgement will be sent
-  public static PartitionResponse send(DistributedMember recipient,
-                                       PartitionedRegion r,
-                                       EntryEventImpl event,
-                                       final long lastModified,
-                                       boolean ifNew,
-                                       boolean ifOld,
-                                       Object expectedOldValue,
-                                       boolean requireOldValue)
-  throws ForceReattemptException {
-    //Assert.assertTrue(recipient != null, "PutMessage NULL recipient");  recipient can be null for event notifications
+  public static PartitionResponse send(DistributedMember recipient, PartitionedRegion r,
+      EntryEventImpl event, final long lastModified, boolean ifNew, boolean ifOld,
+      Object expectedOldValue, boolean requireOldValue) throws ForceReattemptException {
+    // Assert.assertTrue(recipient != null, "PutMessage NULL recipient"); recipient can be null for
+    // event notifications
-    PutMessage m = new PutMessage(recipients,
-                                  false,
-                                  r.getPRId(),
-                                  processor,
-                                  event,
-                                  lastModified,
-                                  ifNew,
-                                  ifOld,
-                                  expectedOldValue,
-                                  requireOldValue);
+    PutMessage m = new PutMessage(recipients, false, r.getPRId(), processor, event, lastModified,
+        ifNew, ifOld, expectedOldValue, requireOldValue);
-    Set failures =r.getDistributionManager().putOutgoing(m);
+    Set failures = r.getDistributionManager().putOutgoing(m);
-      throw new ForceReattemptException(LocalizedStrings.PutMessage_FAILED_SENDING_0.toLocalizedString(m));
+      throw new ForceReattemptException(
+          LocalizedStrings.PutMessage_FAILED_SENDING_0.toLocalizedString(m));
-  //  public final boolean needsDirectAck()
-  //  {
-  //    return this.directAck;
-  //  }
+  // public final boolean needsDirectAck()
+  // {
+  // return this.directAck;
+  // }
-//  final public int getProcessorType() {
-//    return DistributionManager.PARTITIONED_REGION_EXECUTOR;
-//  }
+  // final public int getProcessorType() {
+  // return DistributionManager.PARTITIONED_REGION_EXECUTOR;
+  // }
-  /** create a new EntryEvent to be used in notifying listeners, bridge servers, etc.
-   * Caller must release result if it is != to sourceEvent
+  /**
+   * create a new EntryEvent to be used in notifying listeners, bridge servers, etc. Caller must
+   * release result if it is != to sourceEvent
-    }
-    else {
+    } else {
-    if(!sourceEvent.hasOldValue()) {
+    if (!sourceEvent.hasOldValue()) {
-    
+
-    
+
-  public final Object getKey()
-  {
+  public final Object getKey() {
-  public final void setKey(Object key)
-  {
+  public final void setKey(Object key) {
-  public final byte[] getValBytes()
-  {
+  public final byte[] getValBytes() {
-  private void setValBytes(byte[] valBytes)
-  {
+  private void setValBytes(byte[] valBytes) {
-   * @param o
-   *          Object of type Delta
+   * @param o Object of type Delta
-  protected final Operation getOperation()
-  {
+  protected final Operation getOperation() {
-  public void setFilterInfo(FilterRoutingInfo filterInfo){
-    if (filterInfo != null){
+  public void setFilterInfo(FilterRoutingInfo filterInfo) {
+    if (filterInfo != null) {
-  @Override
-  public void appendOldValueToMessage(EntryEventImpl event) {
-    if (event.hasOldValue()) {
-      this.hasOldValue = true;
-      CachedDeserializable cd = (CachedDeserializable) event.getSerializedOldValue();
-      if (cd != null) {
-        this.oldValueIsSerialized = true;
-        Object o = cd.getValue();
-        if (o instanceof byte[]) {
-          setOldValBytes((byte[])o);
-        } else {
-          // Defer serialization until toData is called.
-          setOldValObj(o);
-        }
-      } else {
-        Object old = event.getRawOldValue();
-        if (old instanceof byte[]) {
-          this.oldValueIsSerialized = false;
-          setOldValBytes((byte[]) old);
-        } else {
-          this.oldValueIsSerialized = true;
-          setOldValObj(old);
-        }
-      }
-    }   
-  }*/
+   * @Override public void appendOldValueToMessage(EntryEventImpl event) { if (event.hasOldValue())
+   * { this.hasOldValue = true; CachedDeserializable cd = (CachedDeserializable)
+   * event.getSerializedOldValue(); if (cd != null) { this.oldValueIsSerialized = true; Object o =
+   * cd.getValue(); if (o instanceof byte[]) { setOldValBytes((byte[])o); } else { // Defer
+   * serialization until toData is called. setOldValObj(o); } } else { Object old =
+   * event.getRawOldValue(); if (old instanceof byte[]) { this.oldValueIsSerialized = false;
+   * setOldValBytes((byte[]) old); } else { this.oldValueIsSerialized = true; setOldValObj(old); } }
+   * } }
+   */
-  private void setOldValBytes(byte[] valBytes){
-    this.oldValBytes = valBytes;
-  }
-  public final byte[] getOldValueBytes(){
-    return this.oldValBytes;
-  }
-  private Object getOldValObj(){
-    return this.oldValObj;
-  }
-  private void setOldValObj(Object o){
-    this.oldValObj = o;
-  }*/
+   * private void setOldValBytes(byte[] valBytes){ this.oldValBytes = valBytes; } public final
+   * byte[] getOldValueBytes(){ return this.oldValBytes; } private Object getOldValObj(){ return
+   * this.oldValObj; } private void setOldValObj(Object o){ this.oldValObj = o; }
+   */
-  public final void fromData(DataInput in) throws IOException,
-      ClassNotFoundException
-  {
+  public final void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      this.originalSender = (InternalDistributedMember)DataSerializer
-        .readObject(in);
+      this.originalSender = (InternalDistributedMember) DataSerializer.readObject(in);
-    
+
-    /*this.hasOldValue = in.readBoolean();
-    if (this.hasOldValue){
-      //out.writeBoolean(this.hasOldValue);
-      this.oldValueIsSerialized = in.readBoolean();
-      setOldValBytes(DataSerializer.readByteArray(in));
-    }*/
+    /*
+     * this.hasOldValue = in.readBoolean(); if (this.hasOldValue){
+     * //out.writeBoolean(this.hasOldValue); this.oldValueIsSerialized = in.readBoolean();
+     * setOldValBytes(DataSerializer.readByteArray(in)); }
+     */
-    this.deserializationPolicy = (byte)(extraFlags
-        & DistributedCacheOperation.DESERIALIZATION_POLICY_MASK);
+    this.deserializationPolicy =
+        (byte) (extraFlags & DistributedCacheOperation.DESERIALIZATION_POLICY_MASK);
-    }
-    else {
+    } else {
-      this.versionTag =  DataSerializer.readObject(in);
+      this.versionTag = DataSerializer.readObject(in);
-  
+
+   * @Override public String toString() { StringBuilder buff = new StringBuilder(super.toString());
+   * buff.append("; has old value="+this.hasOldValue);
+   * buff.append("; isOldValueSerialized ="+this.oldValueIsSerialized);
+   * buff.append("; oldvalue bytes="+this.oldValBytes);
+   * buff.append("; oldvalue object="+this.oldValObj); buff.toString(); return buff.toString(); }
+   */
-  public String toString() {
-    StringBuilder buff = new StringBuilder(super.toString());
-    buff.append("; has old value="+this.hasOldValue);
-    buff.append("; isOldValueSerialized ="+this.oldValueIsSerialized);
-    buff.append("; oldvalue bytes="+this.oldValBytes);
-    buff.append("; oldvalue object="+this.oldValObj);
-    buff.toString();
-    return buff.toString();
-  }*/
-  @Override
-  public final void toData(DataOutput out) throws IOException
-  {
+  public final void toData(DataOutput out) throws IOException {
-    }
-    catch (RuntimeException re) {
+    } catch (RuntimeException re) {
-    if (this.bridgeContext != null) extraFlags |= HAS_BRIDGE_CONTEXT;
+    if (this.bridgeContext != null)
+      extraFlags |= HAS_BRIDGE_CONTEXT;
-    if (this.originalSender != null) extraFlags |= HAS_ORIGINAL_SENDER;
+    if (this.originalSender != null)
+      extraFlags |= HAS_ORIGINAL_SENDER;
-      InternalDataSerializer.invokeToData(this.filterInfo,out);
+      InternalDataSerializer.invokeToData(this.filterInfo, out);
-      }
-      catch (PRLocallyDestroyedException e) {
-        throw new IOException(
-            "Delta can not be extracted as region is locally destroyed");
+      } catch (PRLocallyDestroyedException e) {
+        throw new IOException("Delta can not be extracted as region is locally destroyed");
-    }
-    else {
-      DistributedCacheOperation.writeValue(this.deserializationPolicy, this.valObj, getValBytes(), out);
+    } else {
+      DistributedCacheOperation.writeValue(this.deserializationPolicy, this.valObj, getValBytes(),
+          out);
-    if (this.ifNew) s |= IF_NEW;
-    if (this.ifOld) s |= IF_OLD;
-    if (this.requireOldValue) s |= REQUIRED_OLD_VAL;
-    if (this.expectedOldValue != null) s |= HAS_EXPECTED_OLD_VAL;
+    if (this.ifNew)
+      s |= IF_NEW;
+    if (this.ifOld)
+      s |= IF_OLD;
+    if (this.requireOldValue)
+      s |= REQUIRED_OLD_VAL;
+    if (this.expectedOldValue != null)
+      s |= HAS_EXPECTED_OLD_VAL;
-        this.deserializationPolicy =
-          DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY;
+        this.deserializationPolicy = DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY;
-    if (this.versionTag != null) s |= HAS_VERSION_TAG;
+    if (this.versionTag != null)
+      s |= HAS_VERSION_TAG;
-  protected void setBooleans(short s, DataInput in) throws IOException,
-      ClassNotFoundException {
+  protected void setBooleans(short s, DataInput in) throws IOException, ClassNotFoundException {
-   * This method is called upon receipt and make the desired changes to the
-   * PartitionedRegion Note: It is very important that this message does NOT
-   * cause any deadlocks as the sender will wait indefinitely for the
-   * acknowledgement
+   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:
+   * It is very important that this message does NOT cause any deadlocks as the sender will wait
+   * indefinitely for the acknowledgement
-  protected final boolean operateOnPartitionedRegion(DistributionManager dm,
-                                                     PartitionedRegion r,
-                                                     long startTime)
-  throws EntryExistsException, DataLocationException, IOException {
+  protected final boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion r,
+      long startTime) throws EntryExistsException, DataLocationException, IOException {
-       eventSender = getSender();
+      eventSender = getSender();
-    @Released final EntryEventImpl ev = EntryEventImpl.create(
-        r,
-        getOperation(),
-        getKey(),
-        null, /*newValue*/
-        getCallbackArg(),
-        false/*originRemote - false to force distribution in buckets*/,
-        eventSender,
-        true/*generateCallbacks*/,
-        false/*initializeId*/);
+    @Released
+    final EntryEventImpl ev =
+        EntryEventImpl.create(r, getOperation(), getKey(), null, /* newValue */
+            getCallbackArg(), false/* originRemote - false to force distribution in buckets */,
+            eventSender, true/* generateCallbacks */, false/* initializeId */);
-    if (this.versionTag != null) {
-      this.versionTag.replaceNullIDs(getSender());
-      ev.setVersionTag(this.versionTag);
-    }
-    if (this.bridgeContext != null) {
-      ev.setContext(this.bridgeContext);
-    }
-    Assert.assertTrue(eventId != null);
-    ev.setEventId(eventId);
-    ev.setCausedByMessage(this);
-    ev.setInvokePRCallbacks(!notificationOnly);
-    ev.setPossibleDuplicate(this.posDup);
-    /*if (this.hasOldValue) {
-      if (this.oldValueIsSerialized) {
-        ev.setSerializedOldValue(getOldValueBytes());
+      if (this.versionTag != null) {
+        this.versionTag.replaceNullIDs(getSender());
+        ev.setVersionTag(this.versionTag);
-      else {
-        ev.setOldValue(getOldValueBytes());
+      if (this.bridgeContext != null) {
+        ev.setContext(this.bridgeContext);
-    }*/
+      Assert.assertTrue(eventId != null);
+      ev.setEventId(eventId);
+      ev.setCausedByMessage(this);
+      ev.setInvokePRCallbacks(!notificationOnly);
+      ev.setPossibleDuplicate(this.posDup);
+      /*
+       * if (this.hasOldValue) { if (this.oldValueIsSerialized) {
+       * ev.setSerializedOldValue(getOldValueBytes()); } else { ev.setOldValue(getOldValueBytes());
+       * } }
+       */
-    ev.setDeltaBytes(this.deltaBytes);
-    if (this.hasDelta) {
-      this.valObj = null;
-      // New value will be set once it is generated with fromDelta() inside
-      // EntryEventImpl.processDeltaBytes()
-      ev.setNewValue(this.valObj);
-    }
-    else {
-      switch (this.deserializationPolicy) {
-        case DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY:
-          ev.setSerializedNewValue(getValBytes());
-          break;
-        case DistributedCacheOperation.DESERIALIZATION_POLICY_NONE:
-          ev.setNewValue(getValBytes());
-          break;
-        default:
-          throw new AssertionError("unknown deserialization policy: "
-              + deserializationPolicy);
-      }
-    }
-
-    if (!notificationOnly) {
-      if (ds == null) {
-        throw new AssertionError("This process should have storage" +
-                                 " for this operation: " +
-                                 this.toString());
-      }
-      try {
-        // the event must show it's true origin for cachewriter invocation
-//        event.setOriginRemote(true);
-//        this.op = r.doCacheWriteBeforePut(event, ifNew);  // TODO fix this for bug 37072
-        ev.setOriginRemote(false);
-        result = r.getDataView().putEntryOnRemote(ev,
-                               this.ifNew,
-                               this.ifOld,
-                               this.expectedOldValue,
-                               this.requireOldValue,
-                               this.lastModified,
-                               true/*overwriteDestroyed *not* used*/);
-
-        if (!this.result) { // make sure the region hasn't gone away
-          r.checkReadiness();
-//        sbawaska: I cannot see how ifOld and ifNew can both be false, hence removing
-//          if (!this.ifNew && !this.ifOld) {
-//            // no reason to be throwing an exception, so let's retry
-//            ForceReattemptException fre = new ForceReattemptException(
-//                LocalizedStrings.PutMessage_UNABLE_TO_PERFORM_PUT_BUT_OPERATION_SHOULD_NOT_FAIL_0.toLocalizedString());
-//            fre.setHash(key.hashCode());
-//            sendReply(getSender(), getProcessorId(), dm,
-//                new ReplyException(fre), r, startTime);
-//            sendReply = false;
-//          }
+      ev.setDeltaBytes(this.deltaBytes);
+      if (this.hasDelta) {
+        this.valObj = null;
+        // New value will be set once it is generated with fromDelta() inside
+        // EntryEventImpl.processDeltaBytes()
+        ev.setNewValue(this.valObj);
+      } else {
+        switch (this.deserializationPolicy) {
+          case DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY:
+            ev.setSerializedNewValue(getValBytes());
+            break;
+          case DistributedCacheOperation.DESERIALIZATION_POLICY_NONE:
+            ev.setNewValue(getValBytes());
+            break;
+          default:
+            throw new AssertionError("unknown deserialization policy: " + deserializationPolicy);
-      catch (CacheWriterException cwe) {
-        sendReply(getSender(), getProcessorId(), dm, new ReplyException(cwe), r, startTime);
-        return false;
-      }
-      catch (PrimaryBucketException pbe) {
-        sendReply(getSender(), getProcessorId(), dm, new ReplyException(pbe), r, startTime);
-        return false;
-      } catch (InvalidDeltaException ide) {
-        sendReply(getSender(), getProcessorId(), dm, new ReplyException(ide), r, startTime);
-        r.getCachePerfStats().incDeltaFullValuesRequested();
-        return false;
-      }
-      if (logger.isTraceEnabled(LogMarker.DM)) {
-        logger.trace(LogMarker.DM, "PutMessage {} with key: {} val: {}",
-            (result? "updated bucket" : "did not update bucket"), getKey(),
-            (getValBytes() == null ? "null" : "(" + getValBytes().length + " bytes)"));
-      }
-    }
-    else { // notificationOnly
-      @Released EntryEventImpl e2 = createListenerEvent(ev, r, dm.getDistributionManagerId());
-      final EnumListenerEvent le;
-      try {
-      if (e2.getOperation().isCreate()) {
-        le = EnumListenerEvent.AFTER_CREATE;
-      }
-      else {
-        le = EnumListenerEvent.AFTER_UPDATE;
-      }
-      r.invokePutCallbacks(le, e2, r.isInitialized(), true);
-      } finally {
-        // if e2 == ev then no need to free it here. The outer finally block will get it.
-        if (e2 != ev) {
-          e2.release();
+
+      if (!notificationOnly) {
+        if (ds == null) {
+          throw new AssertionError(
+              "This process should have storage" + " for this operation: " + this.toString());
+        try {
+          // the event must show it's true origin for cachewriter invocation
+          // event.setOriginRemote(true);
+          // this.op = r.doCacheWriteBeforePut(event, ifNew); // TODO fix this for bug 37072
+          ev.setOriginRemote(false);
+          result =
+              r.getDataView().putEntryOnRemote(ev, this.ifNew, this.ifOld, this.expectedOldValue,
+                  this.requireOldValue, this.lastModified, true/* overwriteDestroyed *not* used */);
+
+          if (!this.result) { // make sure the region hasn't gone away
+            r.checkReadiness();
+            // sbawaska: I cannot see how ifOld and ifNew can both be false, hence removing
+            // if (!this.ifNew && !this.ifOld) {
+            // // no reason to be throwing an exception, so let's retry
+            // ForceReattemptException fre = new ForceReattemptException(
+            // LocalizedStrings.PutMessage_UNABLE_TO_PERFORM_PUT_BUT_OPERATION_SHOULD_NOT_FAIL_0.toLocalizedString());
+            // fre.setHash(key.hashCode());
+            // sendReply(getSender(), getProcessorId(), dm,
+            // new ReplyException(fre), r, startTime);
+            // sendReply = false;
+            // }
+          }
+        } catch (CacheWriterException cwe) {
+          sendReply(getSender(), getProcessorId(), dm, new ReplyException(cwe), r, startTime);
+          return false;
+        } catch (PrimaryBucketException pbe) {
+          sendReply(getSender(), getProcessorId(), dm, new ReplyException(pbe), r, startTime);
+          return false;
+        } catch (InvalidDeltaException ide) {
+          sendReply(getSender(), getProcessorId(), dm, new ReplyException(ide), r, startTime);
+          r.getCachePerfStats().incDeltaFullValuesRequested();
+          return false;
+        }
+        if (logger.isTraceEnabled(LogMarker.DM)) {
+          logger.trace(LogMarker.DM, "PutMessage {} with key: {} val: {}",
+              (result ? "updated bucket" : "did not update bucket"), getKey(),
+              (getValBytes() == null ? "null" : "(" + getValBytes().length + " bytes)"));
+        }
+      } else { // notificationOnly
+        @Released
+        EntryEventImpl e2 = createListenerEvent(ev, r, dm.getDistributionManagerId());
+        final EnumListenerEvent le;
+        try {
+          if (e2.getOperation().isCreate()) {
+            le = EnumListenerEvent.AFTER_CREATE;
+          } else {
+            le = EnumListenerEvent.AFTER_UPDATE;
+          }
+          r.invokePutCallbacks(le, e2, r.isInitialized(), true);
+        } finally {
+          // if e2 == ev then no need to free it here. The outer finally block will get it.
+          if (e2 != ev) {
+            e2.release();
+          }
+        }
+        result = true;
-      result = true;
-    }
-    setOperation(ev.getOperation()); // set operation for reply message
+      setOperation(ev.getOperation()); // set operation for reply message
-    if (sendReply) {
-      sendReply(getSender(),
-                getProcessorId(),
-                dm,
-                null,
-                r,
-                startTime,
-                ev);
-    }
-    return false;
+      if (sendReply) {
+        sendReply(getSender(), getProcessorId(), dm, null, r, startTime, ev);
+      }
+      return false;
-  
-  protected void sendReply(InternalDistributedMember member,
-                           int procId,
-                           DM dm,
-                           ReplyException ex,
-                           PartitionedRegion pr,
-                           long startTime,
-                           EntryEventImpl ev) {
+
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+      PartitionedRegion pr, long startTime, EntryEventImpl ev) {
-      pr.getCancelCriterion().checkCancelInProgress(null); // bug 39014 - don't send a positive response if we may have failed
+      pr.getCancelCriterion().checkCancelInProgress(null); // bug 39014 - don't send a positive
+                                                           // response if we may have failed
-  protected final void appendFields(StringBuffer buff)
-  {
+  protected final void appendFields(StringBuffer buff) {
-    buff.append("; key=").append(getKey())
-        .append("; value=");
-//    buff.append(getValBytes());
+    buff.append("; key=").append(getKey()).append("; value=");
+    // buff.append(getValBytes());
-    buff.append("; callback=").append(this.cbArg)
-        .append("; op=").append(this.op);
+    buff.append("; callback=").append(this.cbArg).append("; op=").append(this.op);
-    buff.append("; ifOld=")
-        .append(this.ifOld)
-        .append("; ifNew=")
-        .append(this.ifNew)
-        .append("; op=")
+    buff.append("; ifOld=").append(this.ifOld).append("; ifNew=").append(this.ifNew).append("; op=")
-      DistributedCacheOperation
-        .deserializationPolicyToString(this.deserializationPolicy));
+        DistributedCacheOperation.deserializationPolicyToString(this.deserializationPolicy));
-  public final InternalDistributedSystem getInternalDs()
-  {
+  public final InternalDistributedSystem getInternalDs() {
-  public final void setInternalDs(InternalDistributedSystem internalDs)
-  {
+  public final void setInternalDs(InternalDistributedSystem internalDs) {
-  
+
-     * Old value in serialized form: either a byte[] or CachedDeserializable,
-     * or null if not set.
+     * Old value in serialized form: either a byte[] or CachedDeserializable, or null if not set.
-     * Set to true by the import methods if the oldValue
-     * is already serialized. In that case toData
-     * should just copy the bytes to the stream.
-     * In either case fromData just calls readObject.
+     * Set to true by the import methods if the oldValue is already serialized. In that case toData
+     * should just copy the bytes to the stream. In either case fromData just calls readObject.
-    public PutReplyMessage() {
-    }
-    
+    public PutReplyMessage() {}
+
-    PutReplyMessage(int processorId,
-                            boolean result,
-                            Operation op,
-                            ReplyException ex,
-                            Object oldValue,
-                            VersionTag version)
-    {
+    PutReplyMessage(int processorId, boolean result, Operation op, ReplyException ex,
+        Object oldValue, VersionTag version) {
-    public static void send(InternalDistributedMember recipient,
-                            int processorId,
-                            ReplySender dm,
-                            boolean result,
-                            Operation op,
-                            ReplyException ex,
-                            PutMessage sourceMessage,
-                            EntryEventImpl ev)
-    {
+    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm,
+        boolean result, Operation op, ReplyException ex, PutMessage sourceMessage,
+        EntryEventImpl ev) {
-      PutReplyMessage m = new PutReplyMessage(processorId, result, op, ex, null, ev.getVersionTag());
+      PutReplyMessage m =
+          new PutReplyMessage(processorId, result, op, ex, null, ev.getVersionTag());
-     * Processes this message.  This method is invoked by the receiver
-     * of the message.
+     * Processes this message. This method is invoked by the receiver of the message.
+     * 
-        logger.trace(LogMarker.DM, "PutReplyMessage process invoking reply processor with processorId: {}",  this.processorId);
+        logger.trace(LogMarker.DM,
+            "PutReplyMessage process invoking reply processor with processorId: {}",
+            this.processorId);
-        PutResponse processor = (PutResponse)rp;
+        PutResponse processor = (PutResponse) rp;
-      dm.getStats().incReplyMessageTime(NanoTimer.getTime()-startTime);
+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);
-      // to fix bug 42951 why not just return this.oldValue? 
+      // to fix bug 42951 why not just return this.oldValue?
-//      // oldValue field is in serialized form, either a CachedDeserializable,
-//      // a byte[], or null if not set
-//      if (this.oldValue instanceof CachedDeserializable) {
-//        return ((CachedDeserializable)this.oldValue).getDeserializedValue(null, null);
-//      }
-//      return this.oldValue;
+      // // oldValue field is in serialized form, either a CachedDeserializable,
+      // // a byte[], or null if not set
+      // if (this.oldValue instanceof CachedDeserializable) {
+      // return ((CachedDeserializable)this.oldValue).getDeserializedValue(null, null);
+      // }
+      // return this.oldValue;
-    public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      this.versionTag = (VersionTag)DataSerializer.readObject(in);
+      this.versionTag = (VersionTag) DataSerializer.readObject(in);
-   @Override
+    @Override
-      RemotePutMessage.PutReplyMessage.oldValueToData(out, getOldValue(), this.oldValueIsSerialized);
+      RemotePutMessage.PutReplyMessage.oldValueToData(out, getOldValue(),
+          this.oldValueIsSerialized);
-      sb.append("PutReplyMessage ")
-      .append("processorid=").append(this.processorId)
-      .append(" returning ").append(this.result)
-      .append(" op=").append(op)
-      .append(" exception=").append(getException())
-      .append(" oldValue=").append(this.oldValue==null? "null" : "not null")
-      .append(" version=").append(this.versionTag);
+      sb.append("PutReplyMessage ").append("processorid=").append(this.processorId)
+          .append(" returning ").append(this.result).append(" op=").append(op).append(" exception=")
+          .append(getException()).append(" oldValue=")
+          .append(this.oldValue == null ? "null" : "not null").append(" version=")
+          .append(this.versionTag);
-    
+
-    public void importOldObject(@Unretained(ENTRY_EVENT_OLD_VALUE) Object ov, boolean isSerialized) {
+    public void importOldObject(@Unretained(ENTRY_EVENT_OLD_VALUE) Object ov,
+        boolean isSerialized) {
+   * 
-  public static class PutResponse extends PartitionResponse  {
+  public static class PutResponse extends PartitionResponse {
-      //boolean response, Operation op, Object oldValue) {
+      // boolean response, Operation op, Object oldValue) {
-    public PutResult waitForResult() throws CacheException,
-        ForceReattemptException {
+    public PutResult waitForResult() throws CacheException, ForceReattemptException {
-      }
-      catch (ForceReattemptException e) {
+      } catch (ForceReattemptException e) {
-        throw new ForceReattemptException(LocalizedStrings.PutMessage_DID_NOT_RECEIVE_A_VALID_REPLY.toLocalizedString());
+        throw new ForceReattemptException(
+            LocalizedStrings.PutMessage_DID_NOT_RECEIVE_A_VALID_REPLY.toLocalizedString());
-//       try {
-//         waitForRepliesUninterruptibly();
-//       }
-//       catch (ReplyException e) {
-//         Throwable t = e.getCause();
-//         if (t instanceof CacheClosedException) {
-//           throw new PartitionedRegionCommunicationException("Put operation received an exception", t);
-//         }
-//         e.handleAsUnexpected();
-//       }
-          return new PutResult(this.returnValue,
-                               this.op,
-                               this.oldValue,
-                               this.versionTag);
+      // try {
+      // waitForRepliesUninterruptibly();
+      // }
+      // catch (ReplyException e) {
+      // Throwable t = e.getCause();
+      // if (t instanceof CacheClosedException) {
+      // throw new PartitionedRegionCommunicationException("Put operation received an exception",
+      // t);
+      // }
+      // e.handleAsUnexpected();
+      // }
+      return new PutResult(this.returnValue, this.op, this.oldValue, this.versionTag);
-        ReplyException ex = ((ReplyMessage)msg).getException();
+        ReplyException ex = ((ReplyMessage) msg).getException();
-         final PutMessage putMsg = new PutMessage(this.putMessage);
-         final DM dm = getDistributionManager();
-         Runnable sendFullObject = new Runnable() {
-           public void run() {
-             putMsg.resetRecipients();
-             putMsg.setRecipient(msg.getSender());
-             putMsg.setSendDelta(false);
-             if (logger.isDebugEnabled()) {
-               logger.debug("Sending full object({}) to {}", putMsg, Arrays.toString(putMsg.getRecipients()));
-             }
-             dm.putOutgoing(putMsg);
+          final PutMessage putMsg = new PutMessage(this.putMessage);
+          final DM dm = getDistributionManager();
+          Runnable sendFullObject = new Runnable() {
+            public void run() {
+              putMsg.resetRecipients();
+              putMsg.setRecipient(msg.getSender());
+              putMsg.setSendDelta(false);
+              if (logger.isDebugEnabled()) {
+                logger.debug("Sending full object({}) to {}", putMsg,
+                    Arrays.toString(putMsg.getRecipients()));
+              }
+              dm.putOutgoing(putMsg);
-             // Update stats
-             try {
-               PartitionedRegion.getPRFromId(putMsg.regionId)
-                   .getCachePerfStats().incDeltaFullValuesSent();
-             }
-             catch (Exception e) {
-             }
-           }
+              // Update stats
+              try {
+                PartitionedRegion.getPRFromId(putMsg.regionId).getCachePerfStats()
+                    .incDeltaFullValuesSent();
+              } catch (Exception e) {
+              }
+            }
-           @Override
-           public String toString() {
-             return "Sending full object {" + putMsg.toString() + "}";
-           }
-         };
-         if(isExpectingDirectReply()) {
-           sendFullObject.run();
-         } else {
-          getDistributionManager().getWaitingThreadPool().execute(sendFullObject);
-         }
+            @Override
+            public String toString() {
+              return "Sending full object {" + putMsg.toString() + "}";
+            }
+          };
+          if (isExpectingDirectReply()) {
+            sendFullObject.run();
+          } else {
+            getDistributionManager().getWaitingThreadPool().execute(sendFullObject);
+          }
-  public static class PutResult  {
+  public static class PutResult {
-    
+
-  
+
-  
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
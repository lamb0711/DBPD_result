GEODE-2535: added a boolean flag to track if the value of a RecoveredEntry is in memory or on disk

Update stat based on the boolean value.
Avoid negating keyId by using the boolean flag.

-        if (re.getRecoveredKeyId() < 0) {
+        if (!re.getValueRecovered()) {
-        // Now that oplog creates are immediately put in cache
-        // a later oplog modify will get us here
-        RecoveredEntry re = (RecoveredEntry) newValue;
-        long oldKeyId = did.getKeyId();
-        Object oldValueAsToken = entry.getValueAsToken();
-        long oldOplogId = did.getOplogId();
-        long newOplogId = re.getOplogId();
-        if (newOplogId != oldOplogId) {
-          did.setOplogId(newOplogId);
-          re.setOplogId(oldOplogId); // so caller knows oldoplog id
-        }
-        did.setOffsetInOplog(re.getOffsetInOplog());
-        // id already set
-        did.setUserBits(re.getUserBits());
-        oldValueLength = did.getValueLength();
-        did.setValueLength(re.getValueLength());
-
-        if (re.getRecoveredKeyId() < 0) {
-          if (!entry.isValueNull()) {
-            entry.handleValueOverflow(region);
-            entry.setValueWithContext(region, null); // fixes bug 41119
-          }
-        } else {
-          entry.setValueWithContext(region,
-              entry.prepareValueForCache(region, re.getValue(), false));
-        }
-
-        if (re.getRecoveredKeyId() < 0) { // recovering an entry whose new value is on disk
-          if (oldKeyId >= 0) { // the entry's old value is in vm
-            // TODO: oldKeyId == 0 is the ILLEGAL id; what does that indicate?
-            int inVM = -1;
-            if (Token.isInvalidOrRemoved(oldValueAsToken)) { // but tokens are never in vm
-              inVM = 0;
-            }
-            updateStats(dr, region, inVM, 1/* OnDisk */, did.getValueLength());
-          } else { // the entry's old value is also on disk
-            int valueLenDelta = -oldValueLength; // but it is no longer
-            valueLenDelta += did.getValueLength(); // new one is now on disk
-            updateStats(dr, region, 0, 0, valueLenDelta);
-          }
-        } else { // recovering an entry whose new value is in vm
-          int inVM = 1;
-          if (Token.isInvalidOrRemoved(re.getValue())) { // but tokens never in vm
-            inVM = 0;
-          }
-          if (oldKeyId < 0) { // the entry's old value is on disk
-            updateStats(dr, region, inVM, -1/* OnDisk */, -oldValueLength);
-          } else { // the entry's old value was in the vm
-            if (inVM == 1 && Token.isInvalidOrRemoved(oldValueAsToken)) {
-              // the old state was not in vm and not on disk. But now we are in vm.
-              updateStats(dr, region, 1, 0, 0);
-            } else if (inVM == 0 && !Token.isInvalidOrRemoved(oldValueAsToken)) {
-              // the old state was in vm and not on disk. But now we are not in vm.
-              updateStats(dr, region, -1, 0, 0);
-            }
-          }
-        }
+        ((RecoveredEntry) newValue).applyToDiskEntry(entry, region, dr, did);
-    public static void updateRecoveredEntry(PlaceHolderDiskRegion drv, DiskEntry entry,
-        RecoveredEntry newValue, RegionEntryContext context) {
-      if (newValue == null) {
-        throw new NullPointerException(
-            LocalizedStrings.DiskEntry_ENTRYS_VALUE_SHOULD_NOT_BE_NULL.toLocalizedString());
-      }
-      DiskId did = entry.getDiskId();
-      synchronized (did) {
-        Object oldValueAsToken = entry.getValueAsToken();
-        boolean oldValueWasNull = oldValueAsToken == null;
-        int oldValueLength = did.getValueLength();
-        // Now that oplog creates are immediately put in cache
-        // a later oplog modify will get us here
-        long oldOplogId = did.getOplogId();
-        long newOplogId = newValue.getOplogId();
-        if (newOplogId != oldOplogId) {
-          did.setOplogId(newOplogId);
-          newValue.setOplogId(oldOplogId); // so caller knows oldoplog id
-        }
-        did.setOffsetInOplog(newValue.getOffsetInOplog());
-        // id already set
-        did.setUserBits(newValue.getUserBits());
-        did.setValueLength(newValue.getValueLength());
-        if (newValue.getRecoveredKeyId() >= 0) {
-          entry.setValueWithContext(context,
-              entry.prepareValueForCache(drv, newValue.getValue(), false));
-          int inVM = 1;
-          if (Token.isInvalidOrRemoved(newValue.getValue())) { // but tokens never in vm
-            inVM = 0;
-          }
-          if (oldValueWasNull) { // the entry's old value is on disk
-            updateStats(drv, null, inVM, -1/* OnDisk */, -oldValueLength);
-          } else { // the entry's old value was in the vm
-            if (inVM == 1 && Token.isInvalidOrRemoved(oldValueAsToken)) {
-              // the old state was not in vm and not on disk. But now we are in vm.
-              updateStats(drv, null, 1, 0, 0);
-            } else if (inVM == 0 && !Token.isInvalidOrRemoved(oldValueAsToken)) {
-              // the old state was in vm and not on disk. But now we are not in vm.
-              updateStats(drv, null, -1, 0, 0);
-            }
-          }
-        } else {
-          if (!oldValueWasNull) {
-            entry.handleValueOverflow(context);
-            entry.setValueWithContext(context, null); // fixes bug 41119
-          }
-          if (!oldValueWasNull) { // the entry's old value is in vm
-            int inVM = -1;
-            if (Token.isInvalidOrRemoved(oldValueAsToken)) { // but tokens are never in vm
-              inVM = 0;
-            }
-            updateStats(drv, null, inVM, 1/* OnDisk */, did.getValueLength());
-          } else { // the entry's old value is also on disk
-            int valueLenDelta = -oldValueLength; // but it is no longer
-            valueLenDelta += did.getValueLength(); // new one is now on disk
-            updateStats(drv, null, 0, 0, valueLenDelta);
-          }
-        }
-      }
-    }
-
-        if (did.isKeyIdNegative()) {
-          did.setKeyId(-did.getKeyId());
-        }
-      // Asif: This will convert the -ve OplogKeyId to positive as part of fixing
-      // GEODE-2535 fix should address the original #39989 negative keyId issue.
+    /** whether the entry value has been faulted in after recovery. */
+    private final boolean valueRecovered;
+
-      this(-keyId, oplogId, offsetInOplog, userBits, valueLength, null);
+      this(keyId, oplogId, offsetInOplog, userBits, valueLength, null, false);
+      this(keyId, oplogId, offsetInOplog, userBits, valueLength, value, true);
+    }
+
+    public RecoveredEntry(long keyId, long oplogId, long offsetInOplog, byte userBits,
+        int valueLength, Object value, boolean valueRecovered) {
+      this.valueRecovered = valueRecovered;
+    public boolean getValueRecovered() {
+      return this.valueRecovered;
+    }
+
+
+    public void applyToDiskEntry(PlaceHolderDiskRegion drv, DiskEntry entry,
+        RegionEntryContext context) {
+      DiskId did = entry.getDiskId();
+      synchronized (did) {
+        applyToDiskEntry(entry, context, drv, did);
+      }
+    }
+
+    public void applyToDiskEntry(DiskEntry entry, RegionEntryContext region, AbstractDiskRegion dr,
+        DiskId did) {
+      int oldValueLength;
+      // Now that oplog creates are immediately put in cache
+      // a later oplog modify will get us here
+      Object oldValueAsToken = entry.getValueAsToken();
+      boolean oldValueWasNull = oldValueAsToken == null;
+      long oldOplogId = did.getOplogId();
+      long newOplogId = getOplogId();
+      if (newOplogId != oldOplogId) {
+        did.setOplogId(newOplogId);
+        setOplogId(oldOplogId); // so caller knows oldoplog id
+      }
+      did.setOffsetInOplog(getOffsetInOplog());
+      // id already set
+      did.setUserBits(getUserBits());
+      oldValueLength = did.getValueLength();
+      did.setValueLength(getValueLength());
+
+      if (!getValueRecovered()) {
+        if (!oldValueWasNull) {
+          entry.handleValueOverflow(region);
+          entry.setValueWithContext(region, null); // fixes bug 41119
+        }
+      } else {
+        entry.setValueWithContext(region, entry.prepareValueForCache(region, getValue(), false));
+      }
+
+      if (!getValueRecovered()) { // recovering an entry whose new value is on disk
+        if (!oldValueWasNull) { // the entry's old value is in vm
+          // TODO: oldKeyId == 0 is the ILLEGAL id; what does that indicate?
+          int inVM = -1;
+          if (Token.isInvalidOrRemoved(oldValueAsToken)) { // but tokens are never in vm
+            inVM = 0;
+          }
+          Helper.updateStats(dr, region, inVM, 1/* OnDisk */, did.getValueLength());
+        } else { // the entry's old value is also on disk
+          int valueLenDelta = -oldValueLength; // but it is no longer
+          valueLenDelta += did.getValueLength(); // new one is now on disk
+          Helper.updateStats(dr, region, 0, 0, valueLenDelta);
+        }
+      } else { // recovering an entry whose new value is in vm
+        int inVM = 1;
+        if (Token.isInvalidOrRemoved(getValue())) { // but tokens never in vm
+          inVM = 0;
+        }
+        if (oldValueWasNull) { // the entry's old value is on disk
+          Helper.updateStats(dr, region, inVM, -1/* OnDisk */, -oldValueLength);
+        } else { // the entry's old value was in the vm
+          if (inVM == 1 && Token.isInvalidOrRemoved(oldValueAsToken)) {
+            // the old state was not in vm and not on disk. But now we are in vm.
+            Helper.updateStats(dr, region, 1, 0, 0);
+          } else if (inVM == 0 && !Token.isInvalidOrRemoved(oldValueAsToken)) {
+            // the old state was in vm and not on disk. But now we are not in vm.
+            Helper.updateStats(dr, region, -1, 0, 0);
+          }
+        }
+      }
+    }

INS23 INS31 INS31 INS31 MOV31 INS29 INS83 INS83 INS39 INS59 INS83 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS8 INS44 INS83 INS39 INS42 INS8 INS83 INS39 INS42 MOV44 MOV44 MOV44 INS8 UPD42 INS44 INS44 INS44 MOV8 MOV60 INS65 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS17 INS39 INS42 INS21 INS41 MOV60 INS51 UPD43 UPD42 INS43 INS42 INS43 INS42 INS43 INS42 MOV60 MOV60 MOV21 INS25 MOV8 INS66 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS7 INS22 INS42 INS8 UPD42 INS42 UPD42 MOV42 INS42 INS38 MOV8 INS8 INS38 INS22 INS42 INS52 INS42 INS21 INS32 INS21 INS32 MOV60 INS38 INS21 INS52 INS42 INS32 INS42 MOV38 INS32 UPD42 MOV42 MOV38 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 MOV42 UPD42 MOV42 INS36 UPD42 MOV42 MOV42 MOV42 MOV42 MOV42 INS42 INS42 INS42 INS32 INS9 INS11 INS42 INS42 UPD42 INS42 INS42 UPD42 INS42 INS42 UPD42 INS42 MOV38 MOV43 MOV42 INS42 UPD42 INS42 INS42 UPD42 INS42 MOV38 DEL32 DEL34 DEL27 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL9 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL34 DEL27 DEL39 DEL42 DEL34 DEL38 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL34 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL34 DEL42 DEL32 DEL32 DEL21 DEL8 DEL39 DEL42 DEL42 DEL38 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL34 DEL34 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL34 DEL7 DEL21 DEL8 DEL25 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL38 DEL32 DEL21 DEL8 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL34 DEL34 DEL34 DEL32 DEL21 DEL8 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL32 DEL38 DEL27 DEL42 DEL42 DEL42 DEL34 DEL38 DEL34 DEL34 DEL32 DEL21 DEL8 DEL25 DEL25 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL38 DEL32 DEL21 DEL8 DEL25 DEL42 DEL38 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL33 DEL32 DEL21 DEL8 DEL25 DEL33 DEL33 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL9 DEL32 DEL32 DEL21 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL33 DEL33 DEL33 DEL34 DEL38 DEL42 DEL33 DEL27 DEL43 DEL40 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL42 DEL51 DEL8
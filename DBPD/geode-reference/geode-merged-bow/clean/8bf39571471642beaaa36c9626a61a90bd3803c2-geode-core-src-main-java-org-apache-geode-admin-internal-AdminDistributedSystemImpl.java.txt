Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * @since GemFire     3.5
+ * @since GemFire 3.5
-public class AdminDistributedSystemImpl
-implements org.apache.geode.admin.AdminDistributedSystem,
-           org.apache.geode.internal.admin.JoinLeaveListener,
-           org.apache.geode.internal.admin.AlertListener,
-           org.apache.geode.distributed.internal.InternalDistributedSystem.DisconnectListener {
+public class AdminDistributedSystemImpl implements org.apache.geode.admin.AdminDistributedSystem,
+    org.apache.geode.internal.admin.JoinLeaveListener,
+    org.apache.geode.internal.admin.AlertListener,
+    org.apache.geode.distributed.internal.InternalDistributedSystem.DisconnectListener {
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
-  /** The level above which alerts will be delivered to the alert
-   * listeners */
+
+  /**
+   * The level above which alerts will be delivered to the alert listeners
+   */
-  
+
-  
+
-  
+
-  
+
-  //for feature requests #32887
+  // for feature requests #32887
-  
-  /** 
-   * reference to AdminDistributedSystemImpl instance 
-   * for feature requests #32887. 
+
+  /**
+   * reference to AdminDistributedSystemImpl instance for feature requests #32887.
-   * TODO: reimplement this change and SystemMemberCacheEventProcessor to avoid
-   * using this static. SystemMemberCacheEvents should only be sent to Admin 
-   * VMs that express interest.
+   * TODO: reimplement this change and SystemMemberCacheEventProcessor to avoid using this static.
+   * SystemMemberCacheEvents should only be sent to Admin VMs that express interest.
-   * This is volatile to allow SystemFailure to deliver fatal poison-pill
-   * to thisAdminDS without waiting on synchronization.
+   * This is volatile to allow SystemFailure to deliver fatal poison-pill to thisAdminDS without
+   * waiting on synchronization.
-   * Provides synchronization for {@link #connect()} and {@link #disconnect()}.
-   * {@link #thisAdminDS} is also now protected by CONNECTION_SYNC and has its
-   * lifecycle properly tied to connect/disconnect.
+   * Provides synchronization for {@link #connect()} and {@link #disconnect()}. {@link #thisAdminDS}
+   * is also now protected by CONNECTION_SYNC and has its lifecycle properly tied to
+   * connect/disconnect.
-   
-  
+
+
-  //   Constructor(s)
+  // Constructor(s)
-  
-  /** 
+
+  /**
-   * @param config  configuration defining this distributed system
+   * @param config configuration defining this distributed system
-                          
+
-    } if (this.getLocators() != null && this.getLocators().length() > 0) {
+    }
+    if (this.getLocators() != null && this.getLocators().length() > 0) {
-      this.id = new StringBuffer(this.getMcastAddress()).append("[").append(
-          this.getMcastPort()).append("]").toString();
+      this.id = new StringBuffer(this.getMcastAddress()).append("[").append(this.getMcastPort())
+          .append("]").toString();
-    this.logWriterAppender = LogWriterAppenders.getOrCreateAppender(LogWriterAppenders.Identifier.MAIN, false, this.config.createLogConfig(), false);
-    
+    this.logWriterAppender = LogWriterAppenders.getOrCreateAppender(
+        LogWriterAppenders.Identifier.MAIN, false, this.config.createLogConfig(), false);
+
-    } else {      
+    } else {
-      this.logWriter = LogWriterFactory.createLogWriterLogger(false, false, this.config.createLogConfig(), false);
+      this.logWriter = LogWriterFactory.createLogWriterLogger(false, false,
+          this.config.createLogConfig(), false);
-    
+
-  
+
-  //   Initialization
+  // Initialization
-  
+
-    DistributionLocatorConfig[] configs =
-      this.config.getDistributionLocatorConfigs();
+    DistributionLocatorConfig[] configs = this.config.getDistributionLocatorConfigs();
-      DistributionLocator locator =
-        createDistributionLocatorImpl(conf);
+      DistributionLocator locator = createDistributionLocatorImpl(conf);
-  
+
-   * Creates <code>CacheServer</code> instances for every cache server
-   * entry in the {@link
-   * org.apache.geode.admin.DistributedSystemConfig}
+   * Creates <code>CacheServer</code> instances for every cache server entry in the
+   * {@link org.apache.geode.admin.DistributedSystemConfig}
-    CacheServerConfig[] cacheServerConfigs =
-      this.config.getCacheServerConfigs();
+    CacheServerConfig[] cacheServerConfigs = this.config.getCacheServerConfigs();
-        CacheServerConfigImpl copy =
-          new CacheServerConfigImpl(conf);
+        CacheServerConfigImpl copy = new CacheServerConfigImpl(conf);
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-   * @throws IllegalStateException
-   *         If {@link #connect()} has not been called.
+   * @throws IllegalStateException If {@link #connect()} has not been called.
-      throw new IllegalStateException(LocalizedStrings.AdminDistributedSystemImpl_CONNECT_HAS_NOT_BEEN_INVOKED_ON_THIS_ADMINDISTRIBUTEDSYSTEM.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.AdminDistributedSystemImpl_CONNECT_HAS_NOT_BEEN_INVOKED_ON_THIS_ADMINDISTRIBUTEDSYSTEM
+              .toLocalizedString());
-  //   Attributes of this DistributedSystem
+  // Attributes of this DistributedSystem
-  
+
-  
+
-  
+
-      return name;        
+      return name;
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-    if (this.gfManagerAgent == null) return false;
+    if (this.gfManagerAgent == null)
+      return false;
-    
-    if (isAnyMemberRunning()) return true;
+
+    if (isAnyMemberRunning())
+      return true;
-  
+
-    return this.getMcastPort() > 0 ;
+    return this.getMcastPort() > 0;
-  
+
-  
-  static private final String TIMEOUT_MS_NAME 
-      = "AdminDistributedSystemImpl.TIMEOUT_MS";
+
+  static private final String TIMEOUT_MS_NAME = "AdminDistributedSystemImpl.TIMEOUT_MS";
-  static private final int TIMEOUT_MS 
-      = Integer.getInteger(TIMEOUT_MS_NAME, TIMEOUT_MS_DEFAULT).intValue();
-  
+  static private final int TIMEOUT_MS =
+      Integer.getInteger(TIMEOUT_MS_NAME, TIMEOUT_MS_DEFAULT).intValue();
+
-  //   Operations of this DistributedSystem
+  // Operations of this DistributedSystem
-  
+
-          throw new AdminException(LocalizedStrings.AdminDistributedSystemImpl_0_DID_NOT_START_AFTER_1_MS.toLocalizedString(new Object[] {locs[i], Integer.valueOf(TIMEOUT_MS)}));
+          throw new AdminException(
+              LocalizedStrings.AdminDistributedSystemImpl_0_DID_NOT_START_AFTER_1_MS
+                  .toLocalizedString(new Object[] {locs[i], Integer.valueOf(TIMEOUT_MS)}));
-        throw new AdminException(LocalizedStrings.AdminDistributedSystemImpl_INTERRUPTED_WHILE_WAITING_FOR_0_TO_START.toLocalizedString(locs[i]), ex);
+        throw new AdminException(
+            LocalizedStrings.AdminDistributedSystemImpl_INTERRUPTED_WHILE_WAITING_FOR_0_TO_START
+                .toLocalizedString(locs[i]),
+            ex);
-          throw new AdminException(LocalizedStrings.AdminDistributedSystemImpl_0_DID_NOT_START_AFTER_1_MS.toLocalizedString(new Object[] {servers[i], Integer.valueOf(TIMEOUT_MS)}));
+          throw new AdminException(
+              LocalizedStrings.AdminDistributedSystemImpl_0_DID_NOT_START_AFTER_1_MS
+                  .toLocalizedString(new Object[] {servers[i], Integer.valueOf(TIMEOUT_MS)}));
-        throw new AdminException(LocalizedStrings.AdminDistributedSystemImpl_INTERRUPTED_WHILE_WAITING_FOR_0_TO_START.toLocalizedString(servers[i]), ex);
+        throw new AdminException(
+            LocalizedStrings.AdminDistributedSystemImpl_INTERRUPTED_WHILE_WAITING_FOR_0_TO_START
+                .toLocalizedString(servers[i]),
+            ex);
-  
+
-    // manager.  See bug 32569.
+    // manager. See bug 32569.
-          throw new AdminException(LocalizedStrings.AdminDistributedSystemImpl_0_DID_NOT_STOP_AFTER_1_SECONDS.toLocalizedString(new Object[] {servers[i], Long.valueOf(timeout)}));
+          throw new AdminException(
+              LocalizedStrings.AdminDistributedSystemImpl_0_DID_NOT_STOP_AFTER_1_SECONDS
+                  .toLocalizedString(new Object[] {servers[i], Long.valueOf(timeout)}));
-        throw new AdminException(LocalizedStrings.AdminDistributedSystemImpl_INTERRUPTED_WHILE_WAITING_FOR_0_TO_STOP.toLocalizedString(servers[i]), ex);
+        throw new AdminException(
+            LocalizedStrings.AdminDistributedSystemImpl_INTERRUPTED_WHILE_WAITING_FOR_0_TO_STOP
+                .toLocalizedString(servers[i]),
+            ex);
-          throw new AdminException(LocalizedStrings.AdminDistributedSystemImpl_0_DID_NOT_STOP_AFTER_1_SECONDS.toLocalizedString(new Object[] {locs[i], Long.valueOf(timeout)}));
+          throw new AdminException(
+              LocalizedStrings.AdminDistributedSystemImpl_0_DID_NOT_STOP_AFTER_1_SECONDS
+                  .toLocalizedString(new Object[] {locs[i], Long.valueOf(timeout)}));
-        throw new AdminException(LocalizedStrings.AdminDistributedSystemImpl_INTERRUPTED_WHILE_WAITING_FOR_0_TO_STOP.toLocalizedString(locs[i]), ex);
+        throw new AdminException(
+            LocalizedStrings.AdminDistributedSystemImpl_INTERRUPTED_WHILE_WAITING_FOR_0_TO_STOP
+                .toLocalizedString(locs[i]),
+            ex);
-  
+
-   /**
-   * Returns the license for this GemFire product; else null if unable to
-   * retrieve license information
+  /**
+   * Returns the license for this GemFire product; else null if unable to retrieve license
+   * information
-   * Sets the distribution-related portion of the given managed entity's
-   * configuration so that the entity is part of this distributed system.
+   * Sets the distribution-related portion of the given managed entity's configuration so that the
+   * entity is part of this distributed system.
-   * @throws AdminException
-   *                 TODO-javadocs
+   * @throws AdminException TODO-javadocs
-  private void setDistributionParameters(SystemMember member) 
-    throws AdminException {
+  private void setDistributionParameters(SystemMember member) throws AdminException {
-        new ConfigurationParameterImpl(
-            MCAST_PORT,
-            Integer.valueOf(this.config.getMcastPort())),
-        new ConfigurationParameterImpl(
-            LOCATORS,
-            this.config.getLocators()),
-        new ConfigurationParameterImpl(
-            MCAST_ADDRESS,
+        new ConfigurationParameterImpl(MCAST_PORT, Integer.valueOf(this.config.getMcastPort())),
+        new ConfigurationParameterImpl(LOCATORS, this.config.getLocators()),
+        new ConfigurationParameterImpl(MCAST_ADDRESS,
-        new ConfigurationParameterImpl(
-            DISABLE_TCP,
-            Boolean.valueOf(this.config.getDisableTcp()) ),
-      };
+        new ConfigurationParameterImpl(DISABLE_TCP, Boolean.valueOf(this.config.getDisableTcp())),};
-   * Handles an <code>ExecutionException</code> by examining its cause
-   * and throwing an appropriate runtime exception.
+   * Handles an <code>ExecutionException</code> by examining its cause and throwing an appropriate
+   * runtime exception.
-      throw new FutureCancelledException(LocalizedStrings.AdminDistributedSystemImpl_FUTURE_CANCELLED_DUE_TO_SHUTDOWN.toLocalizedString(), ex);
+      throw new FutureCancelledException(
+          LocalizedStrings.AdminDistributedSystemImpl_FUTURE_CANCELLED_DUE_TO_SHUTDOWN
+              .toLocalizedString(),
+          ex);
-    // misleading.  For instance, the cause might have occurred in a
-    // different thread.  In addition to the cause, we also want to
+    // misleading. For instance, the cause might have occurred in a
+    // different thread. In addition to the cause, we also want to
-    throw new RuntimeAdminException(LocalizedStrings.AdminDistributedSystemImpl_WHILE_WAITING_FOR_FUTURE.toLocalizedString(), ex);
+    throw new RuntimeAdminException(
+        LocalizedStrings.AdminDistributedSystemImpl_WHILE_WAITING_FOR_FUTURE.toLocalizedString(),
+        ex);
-  
+
+
-   * Returns a list of manageable SystemMember instances for each
-   * member of this distributed system.
+   * Returns a list of manageable SystemMember instances for each member of this distributed system.
-  public SystemMember[] getSystemMemberApplications()
-  throws org.apache.geode.admin.AdminException {
-    synchronized(this.applicationSet) {
+  public SystemMember[] getSystemMemberApplications() throws org.apache.geode.admin.AdminException {
+    synchronized (this.applicationSet) {
-      APPS: for (Iterator iter = this.applicationSet.iterator();
-           iter.hasNext(); ) {
+      APPS: for (Iterator iter = this.applicationSet.iterator(); iter.hasNext();) {
-//         this.logger.info("DEBUG: getSystemMemberApplications: " + future);
+        // this.logger.info("DEBUG: getSystemMemberApplications: " + future);
-          } 
-          catch (InterruptedException ex) {
+          } catch (InterruptedException ex) {
-          } 
-          catch (CancellationException ex) {
-//             this.logger.info("DEBUG: cancelled: " + future, ex);
+          } catch (CancellationException ex) {
+            // this.logger.info("DEBUG: cancelled: " + future, ex);
-          } 
-          catch (ExecutionException ex) {
-//             this.logger.info("DEBUG: executed: " + future);
+          } catch (ExecutionException ex) {
+            // this.logger.info("DEBUG: executed: " + future);
-          }
-          finally {
+          } finally {
-  
+
-   * Connects to the currently configured system.  This method is
-   * public for internal use only (testing, for example).
+   * Connects to the currently configured system. This method is public for internal use only
+   * (testing, for example).
-   * See {@link
-   * org.apache.geode.distributed.DistributedSystem#connect} for a
-   * list of exceptions that may be thrown.
+   * See {@link org.apache.geode.distributed.DistributedSystem#connect} for a list of exceptions
+   * that may be thrown.
-      //Check if the gfManagerAgent is NOT null. 
-      //If it is already listening, then just return since the connection is already established OR in process.
-      //Otherwise cleanup the state of AdminDistributedSystemImpl. This needs to happen automatically.
-      if(this.gfManagerAgent != null) {
-       if(this.gfManagerAgent.isListening()) {
-         if (logger.isDebugEnabled()) {
-           logger.debug("The RemoteGfManagerAgent is already listening for this AdminDistributedSystem.");
-         }
-         return;
-       }
-       this.disconnect();
+      // Check if the gfManagerAgent is NOT null.
+      // If it is already listening, then just return since the connection is already established OR
+      // in process.
+      // Otherwise cleanup the state of AdminDistributedSystemImpl. This needs to happen
+      // automatically.
+      if (this.gfManagerAgent != null) {
+        if (this.gfManagerAgent.isListening()) {
+          if (logger.isDebugEnabled()) {
+            logger.debug(
+                "The RemoteGfManagerAgent is already listening for this AdminDistributedSystem.");
+          }
+          return;
+        }
+        this.disconnect();
-      
+
-        throw new IllegalStateException(LocalizedStrings.AdminDistributedSystemImpl_ONLY_ONE_ADMINDISTRIBUTEDSYSTEM_CONNECTION_CAN_BE_MADE_AT_ONCE.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.AdminDistributedSystemImpl_ONLY_ONE_ADMINDISTRIBUTEDSYSTEM_CONNECTION_CAN_BE_MADE_AT_ONCE
+                .toLocalizedString());
-      
-      thisAdminDS = this; //added for feature requests #32887
-      
+
+      thisAdminDS = this; // added for feature requests #32887
+
-        this.id =
-          this.getMcastAddress() + "[" + this.getMcastPort() + "]";
-  
+        this.id = this.getMcastAddress() + "[" + this.getMcastPort() + "]";
+
-  
+
-  
-      // LOG: passes the AdminDistributedSystemImpl LogWriterLogger into GfManagerAgentConfig for RemoteGfManagerAgent
-      GfManagerAgent agent = 
-          GfManagerAgentFactory.getManagerAgent(buildAgentConfig(logWriter));         
+
+      // LOG: passes the AdminDistributedSystemImpl LogWriterLogger into GfManagerAgentConfig for
+      // RemoteGfManagerAgent
+      GfManagerAgent agent = GfManagerAgentFactory.getManagerAgent(buildAgentConfig(logWriter));
-  
+
-      synchronized(this.membershipListenerLock) {
-      // build the list of applications...
+      synchronized (this.membershipListenerLock) {
+        // build the list of applications...
-  NEXT:
-      while(st.hasMoreTokens()) {
+      NEXT: while (st.hasMoreTokens()) {
-        if (colidx > 0 && colidx < (host.length()-1)) {
+        if (colidx > 0 && colidx < (host.length() - 1)) {
-          bindAddr = host.substring(colidx+1, host.length());
+          bindAddr = host.substring(colidx + 1, host.length());
-              bindAddr = orig.substring(bindidx+1);
-            }
-            else {
+              bindAddr = orig.substring(bindidx + 1);
+            } else {
-        int port = Integer.parseInt(locator.substring(first+1, last));
+        int port = Integer.parseInt(locator.substring(first + 1, last));
-          LOCATORS:
-            for (Iterator iter = this.locatorSet.iterator();
-               iter.hasNext(); ) {
+          LOCATORS: for (Iterator iter = this.locatorSet.iterator(); iter.hasNext();) {
-              } 
-              catch (InterruptedException ex) {
+              } catch (InterruptedException ex) {
-              } 
-              catch (CancellationException ex) {
+              } catch (CancellationException ex) {
-              } 
-              catch (ExecutionException ex) {
+              } catch (ExecutionException ex) {
-              }
-              finally {
+              } finally {
-            InetAddress host2 =
-              InetAddressUtil.toInetAddress(conf.getHost());
+            InetAddress host2 = InetAddressUtil.toInetAddress(conf.getHost());
-        // string.  Contact the locator to get information and create
+        // string. Contact the locator to get information and create
-          DistributionLocatorConfigImpl.createConfigFor(host, port,
-                                                        bindAddress);
+            DistributionLocatorConfigImpl.createConfigFor(host, port, bindAddress);
-          DistributionLocator impl = 
-            createDistributionLocatorImpl(conf);
+          DistributionLocator impl = createDistributionLocatorImpl(conf);
-  
-  /**
-   * Polls to determine whether or not the connection to the
-   * distributed system has been made.
-   */
-  public boolean waitToBeConnected(long timeout) 
-    throws InterruptedException {
-    if (Thread.interrupted()) throw new InterruptedException();
-    
+  /**
+   * Polls to determine whether or not the connection to the distributed system has been made.
+   */
+  public boolean waitToBeConnected(long timeout) throws InterruptedException {
+
+    if (Thread.interrupted())
+      throw new InterruptedException();
+
-  /** 
+  /**
-//      if (!isConnected()) {
-//        throw new IllegalStateException(this + " is not connected");
-//      }
-//      Assert.assertTrue(thisAdminDS == this);
+      // if (!isConnected()) {
+      // throw new IllegalStateException(this + " is not connected");
+      // }
+      // Assert.assertTrue(thisAdminDS == this);
-      if (thisAdminDS == this) {
-        thisAdminDS = null;
-      }
-      if (this.gfManagerAgent != null && this.gfManagerAgent.isListening()){
-        synchronized (this) {
-          if (this.health != null) {
-            this.health.close();
-          }
+        if (thisAdminDS == this) {
+          thisAdminDS = null;
-        this.gfManagerAgent.removeJoinLeaveListener(this);
-        this.gfManagerAgent.disconnect();
-      }
-      this.gfManagerAgent = null;
-      if (this.config instanceof DistributedSystemConfigImpl) {
-        ((DistributedSystemConfigImpl) this.config).setDistributedSystem(null);
-      }
+        if (this.gfManagerAgent != null && this.gfManagerAgent.isListening()) {
+          synchronized (this) {
+            if (this.health != null) {
+              this.health.close();
+            }
+          }
+          this.gfManagerAgent.removeJoinLeaveListener(this);
+          this.gfManagerAgent.disconnect();
+        }
+        this.gfManagerAgent = null;
+        if (this.config instanceof DistributedSystemConfigImpl) {
+          ((DistributedSystemConfigImpl) this.config).setDistributedSystem(null);
+        }
-  
+
-   * Returns the DistributionManager this implementation is using to
-   * connect to the distributed system.
+   * Returns the DistributionManager this implementation is using to connect to the distributed
+   * system.
-    
+
-  
+
-   * Returns the internal admin API's agent used for administering
-   * this <code>AdminDistributedSystem</code>.
+   * Returns the internal admin API's agent used for administering this
+   * <code>AdminDistributedSystem</code>.
-  
+
-   * Adds a new, unstarted <code>DistributionLocator</code> to this
-   * distributed system.
+   * Adds a new, unstarted <code>DistributionLocator</code> to this distributed system.
-    DistributionLocatorConfig conf =
-      new DistributionLocatorConfigImpl();
-    DistributionLocator locator = 
-      createDistributionLocatorImpl(conf);
+    DistributionLocatorConfig conf = new DistributionLocatorConfigImpl();
+    DistributionLocator locator = createDistributionLocatorImpl(conf);
-  
+
-    synchronized(this.locatorSet) {
+    synchronized (this.locatorSet) {
-      LOCATORS: for (Iterator iter = this.locatorSet.iterator();
-           iter.hasNext();) {
+      LOCATORS: for (Iterator iter = this.locatorSet.iterator(); iter.hasNext();) {
-          } 
-          catch (InterruptedException ex) {
+          } catch (InterruptedException ex) {
-          } 
-          catch (CancellationException ex) {
+          } catch (CancellationException ex) {
-          } 
-          catch (ExecutionException ex) {
+          } catch (ExecutionException ex) {
-          }
-          finally {
+          } finally {
-      DistributionLocator[] array =
-        new DistributionLocator[coll.size()];
+      DistributionLocator[] array = new DistributionLocator[coll.size()];
-  
+
-   * Updates the locator string that is used to discover members of
-   * the distributed system.
+   * Updates the locator string that is used to discover members of the distributed system.
-        } 
-        catch (InterruptedException ex) {
+        } catch (InterruptedException ex) {
-        } 
-        catch (CancellationException ex) {
+        } catch (CancellationException ex) {
-        } 
-        catch (ExecutionException ex) {
+        } catch (ExecutionException ex) {
-        }
-        finally {
+        } finally {
-  
+
-  //   Listener callback methods
+  // Listener callback methods
-  
+
-  
+
-  /** 
+  /**
-   * React by adding the SystemMember to this system's
-   * internal lists, if they are not already there.  Notice that we
-   * add a {@link Future} into the list so that the admin object is
-   * not initialized while locks are held.
+   * React by adding the SystemMember to this system's internal lists, if they are not already
+   * there. Notice that we add a {@link Future} into the list so that the admin object is not
+   * initialized while locks are held.
-   * @param source  the distributed system that fired nodeJoined
-   * @param vm  the VM that joined
+   * @param source the distributed system that fired nodeJoined
+   * @param vm the VM that joined
-    synchronized(this.membershipListenerLock) {
-//     this.logger.info("DEBUG: nodeJoined: " + vm.getId(), new RuntimeException("STACK"));
+    synchronized (this.membershipListenerLock) {
+      // this.logger.info("DEBUG: nodeJoined: " + vm.getId(), new RuntimeException("STACK"));
-    // does it already exist?
-    SystemMember member = findSystemMember(vm);
-    
-    // if not then create it...
-    if (member == null) {
-//       this.logger.info("DEBUG: no existing member: " + vm.getId());
-      FutureTask future = null;
-      //try {
+      // does it already exist?
+      SystemMember member = findSystemMember(vm);
+
+      // if not then create it...
+      if (member == null) {
+        // this.logger.info("DEBUG: no existing member: " + vm.getId());
+        FutureTask future = null;
+        // try {
-                  public Object call() throws Exception {
-                    logger.info(LogMarker.DM, LocalizedMessage.create(LocalizedStrings.AdminDistributedSystemImpl_ADDING_NEW_CACHESERVER_FOR__0, vm));
-                    return createCacheServer(app);
-                  }
-                });
-                                      
+                public Object call() throws Exception {
+                  logger.info(LogMarker.DM,
+                      LocalizedMessage.create(
+                          LocalizedStrings.AdminDistributedSystemImpl_ADDING_NEW_CACHESERVER_FOR__0,
+                          vm));
+                  return createCacheServer(app);
+                }
+              });
+
-                  public Object call() throws Exception {
-                    logger.info(LogMarker.DM, LocalizedMessage.create(LocalizedStrings.AdminDistributedSystemImpl_ADDING_NEW_APPLICATION_FOR__0, vm));
-                    return createSystemMember(app); 
-                  }
-                });
+                public Object call() throws Exception {
+                  logger.info(LogMarker.DM,
+                      LocalizedMessage.create(
+                          LocalizedStrings.AdminDistributedSystemImpl_ADDING_NEW_APPLICATION_FOR__0,
+                          vm));
+                  return createSystemMember(app);
+                }
+              });
-          Assert.assertTrue(false, "Unknown GemFireVM type: " +
-                            vm.getClass().getName());
-        } 
-
-//      } catch (AdminException ex) {
-//        String s = "Could not create a SystemMember for " + vm;
-//        this.logger.warning(s, ex);
-//      }
-
-      // Wait for the SystemMember to be created.  We want to do this
-      // outside of the "set" locks.
-      future.run();
-      for (;;) {
-        checkCancellation();
-        boolean interrupted = Thread.interrupted();
-        try {
-          member = (SystemMember) future.get();
-          break; // success
-        } 
-        catch (InterruptedException ex) {
-          interrupted = true;
-          continue; // keep trying
-        } 
-        catch (CancellationException ex) {
-//           this.logger.info("DEBUG: run cancelled: " + future, ex);
-          return;
-        } 
-        catch (ExecutionException ex) {
-//           this.logger.info("DEBUG: run executed: " + future, ex);
-          handle(ex);
-          return;
+          Assert.assertTrue(false, "Unknown GemFireVM type: " + vm.getClass().getName());
-        finally {
-          if (interrupted) {
-            Thread.currentThread().interrupt();
+
+        // } catch (AdminException ex) {
+        // String s = "Could not create a SystemMember for " + vm;
+        // this.logger.warning(s, ex);
+        // }
+
+        // Wait for the SystemMember to be created. We want to do this
+        // outside of the "set" locks.
+        future.run();
+        for (;;) {
+          checkCancellation();
+          boolean interrupted = Thread.interrupted();
+          try {
+            member = (SystemMember) future.get();
+            break; // success
+          } catch (InterruptedException ex) {
+            interrupted = true;
+            continue; // keep trying
+          } catch (CancellationException ex) {
+            // this.logger.info("DEBUG: run cancelled: " + future, ex);
+            return;
+          } catch (ExecutionException ex) {
+            // this.logger.info("DEBUG: run executed: " + future, ex);
+            handle(ex);
+            return;
+          } finally {
+            if (interrupted) {
+              Thread.currentThread().interrupt();
+            }
+        } // for
+
+        Assert.assertTrue(member != null);
+
+        // moved this up into the if that creates a new member to fix bug 34517
+        SystemMembershipEvent event = new SystemMembershipEventImpl(member.getDistributedMember());
+        for (Iterator iter = this.membershipListeners.iterator(); iter.hasNext();) {
+          SystemMembershipListener listener = (SystemMembershipListener) iter.next();
+          listener.memberJoined(event);
-      } // for
-
-      Assert.assertTrue(member != null);
-
-      // moved this up into the if that creates a new member to fix bug 34517
-      SystemMembershipEvent event = new SystemMembershipEventImpl(member.getDistributedMember());
-      for (Iterator iter = this.membershipListeners.iterator();
-           iter.hasNext(); ) {
-        SystemMembershipListener listener =
-          (SystemMembershipListener) iter.next();
-        listener.memberJoined(event);
+        // } else {
+        // this.logger.info("DEBUG: found existing member: " + member);
-//     } else {
-//       this.logger.info("DEBUG: found existing member: " + member);
-    }
-  
-  /** 
+
+  /**
-   * @param source  the distributed system that fired nodeCrashed
-   * @param vm    the VM that left
+   * @param source the distributed system that fired nodeCrashed
+   * @param vm the VM that left
-    synchronized(this.membershipListenerLock) {
+    synchronized (this.membershipListenerLock) {
-      SystemMember member = 
-          AdminDistributedSystemImpl.this.removeSystemMember(vm.getId());
+      SystemMember member = AdminDistributedSystemImpl.this.removeSystemMember(vm.getId());
-  
+
-      for (Iterator iter = this.membershipListeners.iterator();
-           iter.hasNext(); ) {
-        SystemMembershipListener listener =
-          (SystemMembershipListener) iter.next();
+      for (Iterator iter = this.membershipListeners.iterator(); iter.hasNext();) {
+        SystemMembershipListener listener = (SystemMembershipListener) iter.next();
-  
-  /** 
+
+  /**
-   * @param source  the distributed system that fired nodeCrashed
+   * @param source the distributed system that fired nodeCrashed
-    synchronized(this.membershipListenerLock) {
+    synchronized (this.membershipListenerLock) {
-      SystemMember member = 
-        AdminDistributedSystemImpl.this.removeSystemMember(vm.getId());
+      SystemMember member = AdminDistributedSystemImpl.this.removeSystemMember(vm.getId());
-        // Unknown member crashed.  Hmm...
+        // Unknown member crashed. Hmm...
-      for (Iterator iter = this.membershipListeners.iterator();
-      iter.hasNext(); ) {
-        SystemMembershipListener listener =
-          (SystemMembershipListener) iter.next();
+      for (Iterator iter = this.membershipListeners.iterator(); iter.hasNext();) {
+        SystemMembershipListener listener = (SystemMembershipListener) iter.next();
-  /** 
-   * Listener callback for when a SystemMember of this DistributedSystem has 
-   * crashed. 
+  /**
+   * Listener callback for when a SystemMember of this DistributedSystem has crashed.
-   * @param alert   the latest alert from the system
+   * @param alert the latest alert from the system
-    for (Iterator<AlertListener> iter = this.alertListeners.iterator();
-         iter.hasNext(); ) {
+    for (Iterator<AlertListener> iter = this.alertListeners.iterator(); iter.hasNext();) {
-  
+
-   logger.debug("Calling AdminDistributedSystemImpl#onDisconnect");	 
-   disconnect();
-   logger.debug("Completed AdminDistributedSystemImpl#onDisconnect");
+    logger.debug("Calling AdminDistributedSystemImpl#onDisconnect");
+    disconnect();
+    logger.debug("Completed AdminDistributedSystemImpl#onDisconnect");
-  
+
-  //   Template methods overriden from superclass...
+  // Template methods overriden from superclass...
-  
-  protected CacheServer createCacheServer(ApplicationVM member) 
-    throws AdminException {
+
+  protected CacheServer createCacheServer(ApplicationVM member) throws AdminException {
-  protected CacheServer createCacheServer(CacheServerConfigImpl conf) 
-    throws AdminException {
+  protected CacheServer createCacheServer(CacheServerConfigImpl conf) throws AdminException {
-  /** Override createSystemMember by instantiating SystemMemberImpl
+  /**
+   * Override createSystemMember by instantiating SystemMemberImpl
-   *  @throws AdminException TODO-javadocs
+   * @throws AdminException TODO-javadocs
-  throws org.apache.geode.admin.AdminException {
+      throws org.apache.geode.admin.AdminException {
-   * Constructs & returns a SystemMember instance using the corresponding
-   * InternalDistributedMember object.
+   * Constructs & returns a SystemMember instance using the corresponding InternalDistributedMember
+   * object.
-   * @param member
-   *          InternalDistributedMember instance for which a SystemMember
-   *          instance is to be constructed.
+   * @param member InternalDistributedMember instance for which a SystemMember instance is to be
+   *        constructed.
-   * @throws org.apache.geode.admin.AdminException
-   *           if construction of SystemMember instance fails
+   * @throws org.apache.geode.admin.AdminException if construction of SystemMember instance fails
-    throws org.apache.geode.admin.AdminException {
+      throws org.apache.geode.admin.AdminException {
-  /** 
-   * Template-method for creating a new
-   * <code>DistributionLocatorImpl</code> instance.  
+  /**
+   * Template-method for creating a new <code>DistributionLocatorImpl</code> instance.
-  protected DistributionLocatorImpl
-    createDistributionLocatorImpl(DistributionLocatorConfig conf) {
+  protected DistributionLocatorImpl createDistributionLocatorImpl(DistributionLocatorConfig conf) {
-  
+
-  //   Non-public implementation methods... TODO: narrow access levels
+  // Non-public implementation methods... TODO: narrow access levels
-  
-  /** 
+
+  /**
-      String mcastId = new StringBuffer(
-          this.getMcastAddress()).append("[").append(
-          this.getMcastPort()).append("]").toString();
+      String mcastId = new StringBuffer(this.getMcastAddress()).append("[")
+          .append(this.getMcastPort()).append("]").toString();
-      for (Iterator iter = locatorIds.iterator(); iter.hasNext(); ) {
+      for (Iterator iter = locatorIds.iterator(); iter.hasNext();) {
-  
+
-   * Returns whether or not a <code>SystemMember</code> corresponds
-   * to a <code>GemFireVM</code>.
+   * Returns whether or not a <code>SystemMember</code> corresponds to a <code>GemFireVM</code>.
-   * @param examineConfig
-   *        Should we take the configuration of the member into
-   *        consideration?  In general, we want to consider the
-   *        configuration when a member starts up.  But when we are
-   *        notified that it has shut down, we do not want to examine
-   *        the configuration because that might involve contacting
-   *        the member.  Which, of course, cannot be done because it
-   *        has shut down.
+   * @param examineConfig Should we take the configuration of the member into consideration? In
+   *        general, we want to consider the configuration when a member starts up. But when we are
+   *        notified that it has shut down, we do not want to examine the configuration because that
+   *        might involve contacting the member. Which, of course, cannot be done because it has
+   *        shut down.
-  private boolean isSame(SystemMemberImpl member, GemFireVM vm,
-                         boolean examineConfig) {
+  private boolean isSame(SystemMemberImpl member, GemFireVM vm, boolean examineConfig) {
-    if ((member instanceof ManagedSystemMemberImpl) &&
-        examineConfig) {
+    if ((member instanceof ManagedSystemMemberImpl) && examineConfig) {
-      // member might have already gone away.  Attempts to send it
+      // member might have already gone away. Attempts to send it
-      ManagedSystemMemberImpl entity =
-        (ManagedSystemMemberImpl) member;
+      ManagedSystemMemberImpl entity = (ManagedSystemMemberImpl) member;
-      InetAddress managedHost =
-        InetAddressUtil.toInetAddress(conf.getHost());
+      InetAddress managedHost = InetAddressUtil.toInetAddress(conf.getHost());
-      
+
-      if (vmHost.equals(managedHost) && 
-          isSameFile(vmWorkingDir, managedWorkingDir) &&
-          isSameFile(vmProdDir, managedProdDir)) {
+      if (vmHost.equals(managedHost) && isSameFile(vmWorkingDir, managedWorkingDir)
+          && isSameFile(vmProdDir, managedProdDir)) {
-   * Returns whether or not the names of the two files represent the
-   * same file.
+   * Returns whether or not the names of the two files represent the same file.
-//       StringBuffer sb = new StringBuffer();
-//       sb.append("File 1: ");
-//       sb.append(file1);
-//       sb.append("\nFile 2: ");
-//       sb.append(file2);
-//       sb.append("\n  Absolute 1: ");
-//       sb.append(file1.getAbsoluteFile());
-//       sb.append("\n  Absolute 2: ");
-//       sb.append(file2.getAbsoluteFile());
-//       sb.append("\n  Canonical 1: ");
-//       sb.append(file1.getCanonicalFile());
-//       sb.append("\n  Canonical 2: ");
-//       sb.append(file2.getCanonicalFile());
-//       logger.info(sb.toString());
+      // StringBuffer sb = new StringBuffer();
+      // sb.append("File 1: ");
+      // sb.append(file1);
+      // sb.append("\nFile 2: ");
+      // sb.append(file2);
+      // sb.append("\n Absolute 1: ");
+      // sb.append(file1.getAbsoluteFile());
+      // sb.append("\n Absolute 2: ");
+      // sb.append(file2.getAbsoluteFile());
+      // sb.append("\n Canonical 1: ");
+      // sb.append(file1.getCanonicalFile());
+      // sb.append("\n Canonical 2: ");
+      // sb.append(file2.getCanonicalFile());
+      // logger.info(sb.toString());
-      logger.info(LocalizedMessage.create(LocalizedStrings.AdminDistributedSystemImpl_WHILE_GETTING_CANONICAL_FILE), ex);
+      logger.info(LocalizedMessage
+          .create(LocalizedStrings.AdminDistributedSystemImpl_WHILE_GETTING_CANONICAL_FILE), ex);
-   * Finds and returns the <code>SystemMember</code> that corresponds
-   * to the given <code>GemFireVM</code> or <code>null</code> if no
-   * <code>SystemMember</code> corresponds.
+   * Finds and returns the <code>SystemMember</code> that corresponds to the given
+   * <code>GemFireVM</code> or <code>null</code> if no <code>SystemMember</code> corresponds.
-   * Finds and returns the <code>SystemMember</code> that corresponds to the
-   * given <code>GemFireVM</code> or <code>null</code> if no Finds and returns
-   * the <code>SystemMember</code> that corresponds to the given
-   * <code>GemFireVM</code> or <code>null</code> if no <code>SystemMember</code>
-   * corresponds.
+   * Finds and returns the <code>SystemMember</code> that corresponds to the given
+   * <code>GemFireVM</code> or <code>null</code> if no Finds and returns the
+   * <code>SystemMember</code> that corresponds to the given <code>GemFireVM</code> or
+   * <code>null</code> if no <code>SystemMember</code> corresponds.
-   * @param vm
-   *          GemFireVM instance
-   * @param compareConfig
-   *          Should the members' configurations be compared? <code>true</code>
-   *          when the member has joined, <code>false</code> when the member has
-   *          left Should the members' configurations be compared?
-   *          <code>true</code> when the member has joined, <code>false</code>
-   *          when the member has left. Additionally also used to check if system 
-   *          member config is to be synchronized with the VM.
+   * @param vm GemFireVM instance
+   * @param compareConfig Should the members' configurations be compared? <code>true</code> when the
+   *        member has joined, <code>false</code> when the member has left Should the members'
+   *        configurations be compared? <code>true</code> when the member has joined,
+   *        <code>false</code> when the member has left. Additionally also used to check if system
+   *        member config is to be synchronized with the VM.
-   protected SystemMember findSystemMember(GemFireVM vm,
-                                           boolean compareConfig) {
+  protected SystemMember findSystemMember(GemFireVM vm, boolean compareConfig) {
-      synchronized (this.cacheServerSet) {
-        SERVERS: for (Iterator iter = this.cacheServerSet.iterator();
-             iter.hasNext(); ) {
-          Future future = (Future) iter.next();
-          CacheServerImpl cacheServer = null;
-          for (;;) {
-            checkCancellation();
-            boolean interrupted = Thread.interrupted();
-            try {
-              cacheServer = (CacheServerImpl) future.get();
-              break; // success
-            } 
-            catch (InterruptedException ex) {
-              interrupted = true;
-              continue; // keep trying
-            } 
-            catch (CancellationException ex) {
-              continue SERVERS;
-            } 
-            catch (ExecutionException ex) {
-              handle(ex);
-              continue SERVERS;
+    synchronized (this.cacheServerSet) {
+      SERVERS: for (Iterator iter = this.cacheServerSet.iterator(); iter.hasNext();) {
+        Future future = (Future) iter.next();
+        CacheServerImpl cacheServer = null;
+        for (;;) {
+          checkCancellation();
+          boolean interrupted = Thread.interrupted();
+          try {
+            cacheServer = (CacheServerImpl) future.get();
+            break; // success
+          } catch (InterruptedException ex) {
+            interrupted = true;
+            continue; // keep trying
+          } catch (CancellationException ex) {
+            continue SERVERS;
+          } catch (ExecutionException ex) {
+            handle(ex);
+            continue SERVERS;
+          } finally {
+            if (interrupted) {
+              Thread.currentThread().interrupt();
-            finally {
-              if (interrupted) {
-                Thread.currentThread().interrupt();
-              }
-            }
-          } // for
-
-          if (isSame(cacheServer, vm, compareConfig)) {
-            member = cacheServer;
-            break;
-        }      
+        } // for
+
+        if (isSame(cacheServer, vm, compareConfig)) {
+          member = cacheServer;
+          break;
+        }
+    }
-        APPS: for (Iterator iter = this.applicationSet.iterator();
-             iter.hasNext(); ) {
+        APPS: for (Iterator iter = this.applicationSet.iterator(); iter.hasNext();) {
-            } 
-            catch (InterruptedException ex) {
+            } catch (InterruptedException ex) {
-            } 
-            catch (CancellationException ex) {
+            } catch (CancellationException ex) {
-            } 
-            catch (ExecutionException ex) {
+            } catch (ExecutionException ex) {
-            }
-            finally {
+            } finally {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.AdminDistributedSystem_COULD_NOT_SET_THE_GEMFIRE_VM), ex);
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.AdminDistributedSystem_COULD_NOT_SET_THE_GEMFIRE_VM), ex);
-  
-  /** 
+
+  /**
-   * @param systemMember  the member to remove
+   * @param systemMember the member to remove
-    return removeSystemMember(
-        ((SystemMemberImpl) systemMember).getInternalId());
+    return removeSystemMember(((SystemMemberImpl) systemMember).getInternalId());
-  
-  /** 
-   * Removes a SystemMember from this system's list of known members.  This 
-   * method is called in response to a member leaving the system.
-   * TODO: this method is a mess of defns
+
+  /**
+   * Removes a SystemMember from this system's list of known members. This method is called in
+   * response to a member leaving the system. TODO: this method is a mess of defns
-   * @param internalId  the unique id that specifies which member to remove
+   * @param internalId the unique id that specifies which member to remove
-    if (internalId == null) return null;
+    if (internalId == null)
+      return null;
-//     this.logger.info("DEBUG: removeSystemMember: " + internalId, new RuntimeException("STACK"));
+    // this.logger.info("DEBUG: removeSystemMember: " + internalId, new RuntimeException("STACK"));
-    synchronized(this.cacheServerSet) {
-      SERVERS: for (Iterator iter = this.cacheServerSet.iterator();
-           iter.hasNext() && !found; ) {
+    synchronized (this.cacheServerSet) {
+      SERVERS: for (Iterator iter = this.cacheServerSet.iterator(); iter.hasNext() && !found;) {
-//             this.logger.info("DEBUG: removeSystemMember cs cancelling: " + future);
+            // this.logger.info("DEBUG: removeSystemMember cs cancelling: " + future);
-            return null;          // Dead code
+            return null; // Dead code
-    }    
+    }
-    synchronized(this.applicationSet) {
-      for (Iterator iter = this.applicationSet.iterator();
-           iter.hasNext() && !found; ) {
+    synchronized (this.applicationSet) {
+      for (Iterator iter = this.applicationSet.iterator(); iter.hasNext() && !found;) {
-              iter.remove();        // Only remove applications
+              iter.remove(); // Only remove applications
-            } 
+            }
-//             this.logger.info("DEBUG: removeSystemMember as cancelling: " + future);
+            // this.logger.info("DEBUG: removeSystemMember as cancelling: " + future);
-          throw new RuntimeException(LocalizedStrings.AdminDistributedSystemImpl_INTERRUPTED.toLocalizedString(), ex);
-          
+          throw new RuntimeException(
+              LocalizedStrings.AdminDistributedSystemImpl_INTERRUPTED.toLocalizedString(), ex);
+
-          return null;          // Dead code
+          return null; // Dead code
-          iter.remove();        // Only remove applications
+          iter.remove(); // Only remove applications
-    }    
+    }
-        
+
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.AdminDistributedSystem_UNEXPECTED_ADMINEXCEPTION), ex);
+        logger.fatal(LocalizedMessage
+            .create(LocalizedStrings.AdminDistributedSystem_UNEXPECTED_ADMINEXCEPTION), ex);
-      
+
-  
-  /**  
-   * Builds the configuration needed to connect to a GfManagerAgent which is the
-   * main gateway into the internal.admin api.  GfManagerAgent is used to 
-   * actually connect to the distributed gemfire system.
+
+  /**
+   * Builds the configuration needed to connect to a GfManagerAgent which is the main gateway into
+   * the internal.admin api. GfManagerAgent is used to actually connect to the distributed gemfire
+   * system.
-    RemoteTransportConfig conf = new RemoteTransportConfig(
-        isMcastEnabled(), getDisableTcp(),
-        getDisableAutoReconnect(),
-        getBindAddress(), buildSSLConfig(), parseLocators(), 
+    RemoteTransportConfig conf = new RemoteTransportConfig(isMcastEnabled(), getDisableTcp(),
+        getDisableAutoReconnect(), getBindAddress(), buildSSLConfig(), parseLocators(),
-    return new GfManagerAgentConfig(
-        getSystemName(), conf, logWriter, this.alertLevel.getSeverity(), this, this);
+    return new GfManagerAgentConfig(getSystemName(), conf, logWriter, this.alertLevel.getSeverity(),
+        this, this);
-  
+
-  
+
-   * Returns the currently configured address to bind to when administering
-   * this system.
+   * Returns the currently configured address to bind to when administering this system.
-      // member must be an application VM.  It is running
+      // member must be an application VM. It is running
-    synchronized(this.cacheServerSet) {
-      SERVERS: for (Iterator iter = this.cacheServerSet.iterator();
-           iter.hasNext();){
+    synchronized (this.cacheServerSet) {
+      SERVERS: for (Iterator iter = this.cacheServerSet.iterator(); iter.hasNext();) {
-          } 
-          catch (InterruptedException ex) {
+          } catch (InterruptedException ex) {
-          } 
-          catch (CancellationException ex) {
+          } catch (CancellationException ex) {
-          } 
-          catch (ExecutionException ex) {
+          } catch (ExecutionException ex) {
-            return null;          // Dead code
-          }
-          finally {
+            return null; // Dead code
+          } finally {
-    synchronized(this.applicationSet) {
-      APPS: for (Iterator iter = this.applicationSet.iterator();
-           iter.hasNext();) {
+    synchronized (this.applicationSet) {
+      APPS: for (Iterator iter = this.applicationSet.iterator(); iter.hasNext();) {
-          } 
-          catch (InterruptedException ex) {
+          } catch (InterruptedException ex) {
-          } 
-          catch (CancellationException ex) {
+          } catch (CancellationException ex) {
-          } 
-          catch (ExecutionException ex) {
+          } catch (ExecutionException ex) {
-            return null;          // Dead code
-          }
-          finally {
+            return null; // Dead code
+          } finally {
-        } //  for
+        } // for
-   * Returns the instance of system member that is running either as a CacheVm
-   * or only ApplicationVm for the given string representation of the id.
+   * Returns the instance of system member that is running either as a CacheVm or only ApplicationVm
+   * for the given string representation of the id.
-   * @param memberId
-   *          string representation of the member identifier
-   * @return instance of system member which could be either as a CacheVm or
-   *         Application VM
+   * @param memberId string representation of the member identifier
+   * @return instance of system member which could be either as a CacheVm or Application VM
-    
+
-        
-        /* cacheVms could be null. See 
-         * AdminDistributedSystemImpl.getCacheVmsCollection() for 
-         * ExecutionException */
+
+        /*
+         * cacheVms could be null. See AdminDistributedSystemImpl.getCacheVmsCollection() for
+         * ExecutionException
+         */
-            if (cacheVm.getId().equals(memberId) && 
-                cacheVm instanceof CacheVm) {
-              found = (SystemMember) cacheVm;    
+            if (cacheVm.getId().equals(memberId) && cacheVm instanceof CacheVm) {
+              found = (SystemMember) cacheVm;
-        
+
-          
+
-            if (appVm.getId().equals(memberId) && 
-                appVm instanceof SystemMember) {
+            if (appVm.getId().equals(memberId) && appVm instanceof SystemMember) {
-          
+
-    
+
-  }  
-  
+  }
+
-  
+
-  //   Health methods
+  // Health methods
-  
+
-   * Lazily initializes the GemFire health monitor 
+   * Lazily initializes the GemFire health monitor
-          throw new RuntimeAdminException(LocalizedStrings.AdminDistributedSystemImpl_AN_ADMINEXCEPTION_WAS_THROWN_WHILE_GETTING_THE_GEMFIRE_HEALTH.toLocalizedString(), ex);
+          throw new RuntimeAdminException(
+              LocalizedStrings.AdminDistributedSystemImpl_AN_ADMINEXCEPTION_WAS_THROWN_WHILE_GETTING_THE_GEMFIRE_HEALTH
+                  .toLocalizedString(),
+              ex);
-   * A "template factory" method for creating an instance of
-   * <code>GemFireHealth</code>.  It can be overridden by subclasses
-   * to produce instances of different <code>GemFireHealth</code>
+   * A "template factory" method for creating an instance of <code>GemFireHealth</code>. It can be
+   * overridden by subclasses to produce instances of different <code>GemFireHealth</code>
-  protected GemFireHealth createGemFireHealth(GfManagerAgent agent) 
-    throws AdminException {
+  protected GemFireHealth createGemFireHealth(GfManagerAgent agent) throws AdminException {
-      throw new IllegalStateException(LocalizedStrings.AdminDistributedSystemImpl_GFMANAGERAGENT_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.AdminDistributedSystemImpl_GFMANAGERAGENT_MUST_NOT_BE_NULL
+              .toLocalizedString());
-    
+
-    return (CacheVm)addCacheServer();
+    return (CacheVm) addCacheServer();
-  
+
-    CacheServer server  = createCacheServer(conf);
+    CacheServer server = createCacheServer(conf);
-    synchronized(this.cacheServerSet) {
+    synchronized (this.cacheServerSet) {
-      SERVERS: for (Iterator iter = this.cacheServerSet.iterator();
-           iter.hasNext(); ) {
+      SERVERS: for (Iterator iter = this.cacheServerSet.iterator(); iter.hasNext();) {
-          } 
-          catch (InterruptedException ex) {
+          } catch (InterruptedException ex) {
-          } 
-          catch (CancellationException ex) {
+          } catch (CancellationException ex) {
-          } 
-          catch (ExecutionException ex) {
+          } catch (ExecutionException ex) {
-            return null;          // Dead code
-          }
-          finally {
+            return null; // Dead code
+          } finally {
-   * Returns all the cache server members of the distributed system which are
-   * hosting a client queue for the particular durable-client having the given
-   * durableClientId
+   * Returns all the cache server members of the distributed system which are hosting a client queue
+   * for the particular durable-client having the given durableClientId
-   * @param durableClientId -
-   *                durable-id of the client
+   * @param durableClientId - durable-id of the client
-  public CacheServer[] getCacheServers(String durableClientId)
-      throws AdminException
-  {
+  public CacheServer[] getCacheServers(String durableClientId) throws AdminException {
-      RemoteApplicationVM vm = (RemoteApplicationVM)((CacheServerImpl)servers[i])
-          .getGemFireVM();
+      RemoteApplicationVM vm = (RemoteApplicationVM) ((CacheServerImpl) servers[i]).getGemFireVM();
-  
+
-    if (coll == null) return null;
+    if (coll == null)
+      return null;
+
-    if (coll == null) return null;
+    if (coll == null)
+      return null;
-  //   Overriden java.lang.Object methods
+  // Overriden java.lang.Object methods
-  
+
-   * TODO: remove this static method during reimplementation of 
+   * TODO: remove this static method during reimplementation of
-  
+
-  public SystemMember lookupSystemMember(DistributedMember distributedMember) 
-  throws AdminException {
-    if (distributedMember == null) return null;
+  public SystemMember lookupSystemMember(DistributedMember distributedMember)
+      throws AdminException {
+    if (distributedMember == null)
+      return null;
-  
-  ////////////////////////  Inner Classes  ////////////////////////
+
+  //////////////////////// Inner Classes ////////////////////////
-   * Object that converts an <code>internal.admin.Alert</code> into an
-   * external <code>admin.Alert</code>.
+   * Object that converts an <code>internal.admin.Alert</code> into an external
+   * <code>admin.Alert</code>.
-    ///////////////////////  Constructors  ///////////////////////
+    /////////////////////// Constructors ///////////////////////
-     * Creates a new <code>Alert</code> that delegates to the given
-     * object. 
+     * Creates a new <code>Alert</code> that delegates to the given object.
-      this.alert   = alert;
+      this.alert = alert;
-       * Related to #39657.
-       * Avoid setting GemFireVM again in the system member.
-       * Eager initialization of member variable - systemMember.
+       * Related to #39657. Avoid setting GemFireVM again in the system member. Eager initialization
+       * of member variable - systemMember.
-         * try to use sender information to construct the SystemMember that can
-         * be used for disply purpose at least
+         * try to use sender information to construct the SystemMember that can be used for disply
+         * purpose at least
-            this.systemMember = 
-              AdminDistributedSystemImpl.this.createSystemMember(sender);
+            this.systemMember = AdminDistributedSystemImpl.this.createSystemMember(sender);
-             * AdminException might be thrown if creation of System Member
-             * instance fails.
+             * AdminException might be thrown if creation of System Member instance fails.
-        } //else this.systemMember will be null
+        } // else this.systemMember will be null
-    
-    //////////////////////  Instance Methods  //////////////////////
+
+    ////////////////////// Instance Methods //////////////////////
-     * Eager initialization of system member is done while creating this alert 
-     * only.
+     * Eager initialization of system member is done while creating this alert only.
-  
+
-   * A JSR-166 <code>FutureTask</code> whose {@link #get} method
-   * properly handles an <code>ExecutionException</code> that wraps an
-   * <code>InterruptedException</code>.  This is necessary because
-   * there are places in the admin API that wrap
-   * <code>InterruptedException</code>s.  See bug 32634.
+   * A JSR-166 <code>FutureTask</code> whose {@link #get} method properly handles an
+   * <code>ExecutionException</code> that wraps an <code>InterruptedException</code>. This is
+   * necessary because there are places in the admin API that wrap
+   * <code>InterruptedException</code>s. See bug 32634.
-   * This is by no means an ideal solution to this problem.  It would
-   * be better to modify the code invoked by the <code>Callable</code>
-   * to explicitly throw <code>InterruptedException</code>.
+   * This is by no means an ideal solution to this problem. It would be better to modify the code
+   * invoked by the <code>Callable</code> to explicitly throw <code>InterruptedException</code>.
-  static class AdminFutureTask extends FutureTask  {
+  static class AdminFutureTask extends FutureTask {
-    /** The id of the member whose admin object we are creating.
-     * Keeping track of this allows us to cancel a FutureTask for a
-     * member that has gone away. */
+    /**
+     * The id of the member whose admin object we are creating. Keeping track of this allows us to
+     * cancel a FutureTask for a member that has gone away.
+     */
-    public AdminFutureTask(InternalDistributedMember memberId,
-                           Callable callable) {
+    public AdminFutureTask(InternalDistributedMember memberId, Callable callable) {
-     * Returns the id of the member of the distributed system for
-     * which this <code>FutureTask</code> is doing work.
+     * Returns the id of the member of the distributed system for which this <code>FutureTask</code>
+     * is doing work.
-     * If the <code>ExecutionException</code> is caused by an
-     * <code>InterruptedException</code>, throw the
-     * <code>CancellationException</code> instead.
+     * If the <code>ExecutionException</code> is caused by an <code>InterruptedException</code>,
+     * throw the <code>CancellationException</code> instead.
-    public Object get()
-      throws InterruptedException, ExecutionException {
+    public Object get() throws InterruptedException, ExecutionException {
-      if (Thread.interrupted()) throw new InterruptedException();
+      if (Thread.interrupted())
+        throw new InterruptedException();
-        for (Throwable cause = ex.getCause(); cause != null;
-             cause = cause.getCause()) {
+        for (Throwable cause = ex.getCause(); cause != null; cause = cause.getCause()) {
-            CancellationException ex2 = new CancellationException(LocalizedStrings.AdminDistributedSystemImpl_BY_INTERRUPT.toLocalizedString());
+            CancellationException ex2 = new CancellationException(
+                LocalizedStrings.AdminDistributedSystemImpl_BY_INTERRUPT.toLocalizedString());
-  
+
-    connect((InternalLogWriter)this.logWriter);
+    connect((InternalLogWriter) this.logWriter);
-  
-  public Set<PersistentID> getMissingPersistentMembers()
-      throws AdminException {
+
+  public Set<PersistentID> getMissingPersistentMembers() throws AdminException {
-    if(dm == null) {
-      throw new IllegalStateException(LocalizedStrings.AdminDistributedSystemImpl_CONNECT_HAS_NOT_BEEN_INVOKED_ON_THIS_ADMINDISTRIBUTEDSYSTEM.toLocalizedString());
+    if (dm == null) {
+      throw new IllegalStateException(
+          LocalizedStrings.AdminDistributedSystemImpl_CONNECT_HAS_NOT_BEEN_INVOKED_ON_THIS_ADMINDISTRIBUTEDSYSTEM
+              .toLocalizedString());
-  public void revokePersistentMember(InetAddress host,
-      String directory) throws AdminException {
+  public void revokePersistentMember(InetAddress host, String directory) throws AdminException {
-    if(dm == null) {
-      throw new IllegalStateException(LocalizedStrings.AdminDistributedSystemImpl_CONNECT_HAS_NOT_BEEN_INVOKED_ON_THIS_ADMINDISTRIBUTEDSYSTEM.toLocalizedString());
+    if (dm == null) {
+      throw new IllegalStateException(
+          LocalizedStrings.AdminDistributedSystemImpl_CONNECT_HAS_NOT_BEEN_INVOKED_ON_THIS_ADMINDISTRIBUTEDSYSTEM
+              .toLocalizedString());
-    
+
-  
+
-    if(dm == null) {
-      throw new IllegalStateException(LocalizedStrings.AdminDistributedSystemImpl_CONNECT_HAS_NOT_BEEN_INVOKED_ON_THIS_ADMINDISTRIBUTEDSYSTEM.toLocalizedString());
+    if (dm == null) {
+      throw new IllegalStateException(
+          LocalizedStrings.AdminDistributedSystemImpl_CONNECT_HAS_NOT_BEEN_INVOKED_ON_THIS_ADMINDISTRIBUTEDSYSTEM
+              .toLocalizedString());
-    
+
-  
+
-      
-      //Fix for 42607 - verify that the persistent id is not already
-      //running before revoking it.
+
+      // Fix for 42607 - verify that the persistent id is not already
+      // running before revoking it.
-      if(success) {
-        //revoke the persistent member if were able to prepare the revoke
+      if (success) {
+        // revoke the persistent member if were able to prepare the revoke
-        //otherwise, cancel the revoke.
+        // otherwise, cancel the revoke.
-    
-    PersistentMemberPattern pattern = new PersistentMemberPattern(host, directory, System.currentTimeMillis());
+
+    PersistentMemberPattern pattern =
+        new PersistentMemberPattern(host, directory, System.currentTimeMillis());
-      //Fix for 42607 - verify that the persistent id is not already
-      //running before revoking it.
+      // Fix for 42607 - verify that the persistent id is not already
+      // running before revoking it.
-      if(success) {
-        //revoke the persistent member if were able to prepare the revoke
+      if (success) {
+        // revoke the persistent member if were able to prepare the revoke
-        //otherwise, cancel the revoke.
+        // otherwise, cancel the revoke.
-  
+
-  
+
-    if(dm == null) {
-      throw new IllegalStateException(LocalizedStrings.AdminDistributedSystemImpl_CONNECT_HAS_NOT_BEEN_INVOKED_ON_THIS_ADMINDISTRIBUTEDSYSTEM.toLocalizedString());
+    if (dm == null) {
+      throw new IllegalStateException(
+          LocalizedStrings.AdminDistributedSystemImpl_CONNECT_HAS_NOT_BEEN_INVOKED_ON_THIS_ADMINDISTRIBUTEDSYSTEM
+              .toLocalizedString());
+   * 
-   * gracefully. After this time period, the members will be forceable shut down. If the
-   * timeout is exceeded, persistent recovery after the shutdown may need to do a GII. -1
-   *  indicates that the shutdown should wait forever. 
+   *        gracefully. After this time period, the members will be forceable shut down. If the
+   *        timeout is exceeded, persistent recovery after the shutdown may need to do a GII. -1
+   *        indicates that the shutdown should wait forever.
-  
+
-  
+
-    if(dm == null) {
-      throw new IllegalStateException(LocalizedStrings.AdminDistributedSystemImpl_CONNECT_HAS_NOT_BEEN_INVOKED_ON_THIS_ADMINDISTRIBUTEDSYSTEM.toLocalizedString());
+    if (dm == null) {
+      throw new IllegalStateException(
+          LocalizedStrings.AdminDistributedSystemImpl_CONNECT_HAS_NOT_BEEN_INVOKED_ON_THIS_ADMINDISTRIBUTEDSYSTEM
+              .toLocalizedString());
-    try {
-    Set<PersistentID> missingMembers = getMissingPersistentMembers(dm);
-    Set recipients = dm.getOtherDistributionManagerIds();
-    
-    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss");
-    targetDir = new File(targetDir, format.format(new Date()));
-    BackupDataStoreResult result = BackupDataStoreHelper.backupAllMembers(
-        dm, recipients, targetDir, baselineDir);
-    
-    // It's possible that when calling getMissingPersistentMembers, some members are 
-    // still creating/recovering regions, and at FinishBackupRequest.send, the 
-    // regions at the members are ready. Logically, since the members in successfulMembers
-    // should override the previous missingMembers
-    for(Set<PersistentID> onlineMembersIds : result.getSuccessfulMembers().values()) {
-      missingMembers.removeAll(onlineMembersIds);
-    }
-    
-    result.getExistingDataStores().keySet().removeAll(result.getSuccessfulMembers().keySet());
-    for(Set<PersistentID> lostMembersIds : result.getExistingDataStores().values()) {
-      missingMembers.addAll(lostMembersIds);
-    }
-    
-    status = new BackupStatusImpl(result.getSuccessfulMembers(), missingMembers);
-    } finally {
-      BackupDataStoreHelper.releaseLock(dm);
-    }
+      try {
+        Set<PersistentID> missingMembers = getMissingPersistentMembers(dm);
+        Set recipients = dm.getOtherDistributionManagerIds();
+
+        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss");
+        targetDir = new File(targetDir, format.format(new Date()));
+        BackupDataStoreResult result =
+            BackupDataStoreHelper.backupAllMembers(dm, recipients, targetDir, baselineDir);
+
+        // It's possible that when calling getMissingPersistentMembers, some members are
+        // still creating/recovering regions, and at FinishBackupRequest.send, the
+        // regions at the members are ready. Logically, since the members in successfulMembers
+        // should override the previous missingMembers
+        for (Set<PersistentID> onlineMembersIds : result.getSuccessfulMembers().values()) {
+          missingMembers.removeAll(onlineMembersIds);
+        }
+
+        result.getExistingDataStores().keySet().removeAll(result.getSuccessfulMembers().keySet());
+        for (Set<PersistentID> lostMembersIds : result.getExistingDataStores().values()) {
+          missingMembers.addAll(lostMembersIds);
+        }
+
+        status = new BackupStatusImpl(result.getSuccessfulMembers(), missingMembers);
+      } finally {
+        BackupDataStoreHelper.releaseLock(dm);
+      }
-      throw new AdminException(LocalizedStrings.DistributedSystem_BACKUP_ALREADY_IN_PROGRESS.toLocalizedString());
+      throw new AdminException(
+          LocalizedStrings.DistributedSystem_BACKUP_ALREADY_IN_PROGRESS.toLocalizedString());
-  
+
-    if(dm == null) {
-      throw new IllegalStateException(LocalizedStrings.AdminDistributedSystemImpl_CONNECT_HAS_NOT_BEEN_INVOKED_ON_THIS_ADMINDISTRIBUTEDSYSTEM.toLocalizedString());
+    if (dm == null) {
+      throw new IllegalStateException(
+          LocalizedStrings.AdminDistributedSystemImpl_CONNECT_HAS_NOT_BEEN_INVOKED_ON_THIS_ADMINDISTRIBUTEDSYSTEM
+              .toLocalizedString());
-  
-  /**
-   * This method can be used to process ClientMembership events sent for
-   * BridgeMembership by bridge servers to all admin members.
-   * 
-   * NOTE: Not implemented currently. JMX implementation which is a subclass of 
-   * this class i.e. AdminDistributedSystemJmxImpl implements it.
-   * 
-   * @param senderId
-   *          id of the member that sent the ClientMembership changes for
-   *          processing (could be null)
-   * @param clientId
-   *          id of a client for which the notification was sent
-   * @param clientHost
-   *          host on which the client is/was running
-   * @param eventType
-   *          denotes whether the client Joined/Left/Crashed should be one of
-   *          ClientMembershipMessage#JOINED, ClientMembershipMessage#LEFT,
-   *          ClientMembershipMessage#CRASHED
-   */
-  public void processClientMembership(String senderId, String clientId,
-      String clientHost, int eventType) {
-  }
-  public void setAlertLevelAsString(String level)  {
+  /**
+   * This method can be used to process ClientMembership events sent for BridgeMembership by bridge
+   * servers to all admin members.
+   * 
+   * NOTE: Not implemented currently. JMX implementation which is a subclass of this class i.e.
+   * AdminDistributedSystemJmxImpl implements it.
+   * 
+   * @param senderId id of the member that sent the ClientMembership changes for processing (could
+   *        be null)
+   * @param clientId id of a client for which the notification was sent
+   * @param clientHost host on which the client is/was running
+   * @param eventType denotes whether the client Joined/Left/Crashed should be one of
+   *        ClientMembershipMessage#JOINED, ClientMembershipMessage#LEFT,
+   *        ClientMembershipMessage#CRASHED
+   */
+  public void processClientMembership(String senderId, String clientId, String clientHost,
+      int eventType) {}
+
+  public void setAlertLevelAsString(String level) {
-    
-    if (newAlertLevel != null) {    
+
+    if (newAlertLevel != null) {
-      System.out.println("ERROR:: "+level+" is invalid. Allowed alert levels are: WARNING, ERROR, SEVERE, OFF");
-      throw new IllegalArgumentException(LocalizedStrings.DEBUG.toLocalizedString(level+" is invalid. Allowed alert levels are: WARNING, ERROR, SEVERE, OFF"));
+      System.out.println("ERROR:: " + level
+          + " is invalid. Allowed alert levels are: WARNING, ERROR, SEVERE, OFF");
+      throw new IllegalArgumentException(LocalizedStrings.DEBUG.toLocalizedString(
+          level + " is invalid. Allowed alert levels are: WARNING, ERROR, SEVERE, OFF"));

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
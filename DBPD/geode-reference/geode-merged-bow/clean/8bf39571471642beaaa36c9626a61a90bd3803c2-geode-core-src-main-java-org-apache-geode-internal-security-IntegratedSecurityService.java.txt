Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class IntegratedSecurityService implements SecurityService{
+public class IntegratedSecurityService implements SecurityService {
-  private IntegratedSecurityService() {
-  }
+  private IntegratedSecurityService() {}
-   * It first looks the shiro subject in AccessControlContext since JMX will
-   * use multiple threads to process operations from the same client, then it
-   * looks into Shiro's thead context.
+   * It first looks the shiro subject in AccessControlContext since JMX will use multiple threads to
+   * process operations from the same client, then it looks into Shiro's thead context.
-      javax.security.auth.Subject.getSubject(AccessController.getContext());
+        javax.security.auth.Subject.getSubject(AccessController.getContext());
-  public Subject login(String username, String password){
-    if(StringUtils.isBlank(username) || StringUtils.isBlank(password))
+  public Subject login(String username, String password) {
+    if (StringUtils.isBlank(username) || StringUtils.isBlank(password))
-    if(credentials == null)
+    if (credentials == null)
-    }
-    catch (ShiroException e) {
+    } catch (ShiroException e) {
-      throw new AuthenticationFailedException("Authentication error. Please check your credentials.", e);
+      throw new AuthenticationFailedException(
+          "Authentication error. Please check your credentials.", e);
-    }
-    catch (ShiroException e) {
+    } catch (ShiroException e) {
-   * this binds the passed-in subject to the executing thread, normally, you
-   * would do this:
+   * this binds the passed-in subject to the executing thread, normally, you would do this:
-   * ThreadState state = null;
-   * try{
-   *   state = IntegratedSecurityService.bindSubject(subject);
-   *   //do the rest of the work as this subject
-   * }
-   * finally{
-   *   if(state!=null)
-   *      state.clear();
-   * }
+   * ThreadState state = null; try{ state = IntegratedSecurityService.bindSubject(subject); //do the
+   * rest of the work as this subject } finally{ if(state!=null) state.clear(); }
-  public ThreadState bindSubject(Subject subject){
+  public ThreadState bindSubject(Subject subject) {
-    authorize(resourceOperation.resource().name(),
-      resourceOperation.operation().name(),
-      null);
+    authorize(resourceOperation.resource().name(), resourceOperation.operation().name(), null);
-  public void authorize(String resource, String operation, String regionName){
+  public void authorize(String resource, String operation, String regionName) {
-    }
-    catch (ShiroException e) {
+    } catch (ShiroException e) {
-      main.put("geodePermissionResolver", "org.apache.geode.internal.security.shiro.GeodePermissionResolver");
+      main.put("geodePermissionResolver",
+          "org.apache.geode.internal.security.shiro.GeodePermissionResolver");
-      securityManager = SecurityService.getObjectOfTypeFromClassName(securityConfig, SecurityManager.class);
+      securityManager =
+          SecurityService.getObjectOfTypeFromClassName(securityConfig, SecurityManager.class);
-    }
-    else if( !StringUtils.isBlank(clientAuthenticatorConfig)) {
+    } else if (!StringUtils.isBlank(clientAuthenticatorConfig)) {
-    }
-    else if (!StringUtils.isBlank(peerAuthenticatorConfig)) {
+    } else if (!StringUtils.isBlank(peerAuthenticatorConfig)) {
-    }
-    else {
+    } else {
-    if( !StringUtils.isBlank(customPostProcessor)) {
-      postProcessor = SecurityService.getObjectOfTypeFromClassName(customPostProcessor, PostProcessor.class);
+    if (!StringUtils.isBlank(customPostProcessor)) {
+      postProcessor =
+          SecurityService.getObjectOfTypeFromClassName(customPostProcessor, PostProcessor.class);
-    }
-    else{
+    } else {
-   * postProcess call already has this logic built in, you don't need to call
-   * this everytime you call postProcess. But if your postProcess is pretty
-   * involved with preparations and you need to bypass it entirely, call this
-   * first.
+   * postProcess call already has this logic built in, you don't need to call this everytime you
+   * call postProcess. But if your postProcess is pretty involved with preparations and you need to
+   * bypass it entirely, call this first.
-  public boolean needPostProcess(){
+  public boolean needPostProcess() {
-  public Object postProcess(String regionPath, Object key, Object value, boolean valueIsSerialized){
+  public Object postProcess(String regionPath, Object key, Object value,
+      boolean valueIsSerialized) {
-  public Object postProcess(Object principal, String regionPath, Object key, Object value, boolean valueIsSerialized) {
+  public Object postProcess(Object principal, String regionPath, Object key, Object value,
+      boolean valueIsSerialized) {
-    // if the data is a byte array, but the data itself is supposed to be an object, we need to desearized it before we pass
+    // if the data is a byte array, but the data itself is supposed to be an object, we need to
+    // desearized it before we pass
-        Object newObj = postProcessor.processRegionValue(principal, regionName, key,  oldObj);
+        Object newObj = postProcessor.processRegionValue(principal, regionName, key, oldObj);
-      } catch (IOException|SerializationException e) {
+      } catch (IOException | SerializationException e) {
-    }
-    else {
+    } else {
-  public SecurityManager getSecurityManager(){
+  public SecurityManager getSecurityManager() {
-  public boolean isIntegratedSecurity(){
+  public boolean isIntegratedSecurity() {

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
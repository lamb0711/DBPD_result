Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Implementation of ResourceManager with additional internal-only methods.
- * TODO: cleanup raw and typed collections
+ * Implementation of ResourceManager with additional internal-only methods. TODO: cleanup raw and
+ * typed collections
-  final int MAX_RESOURCE_MANAGER_EXE_THREADS = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "resource.manager.threads", 1);
-  
+  final int MAX_RESOURCE_MANAGER_EXE_THREADS =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "resource.manager.threads", 1);
+
-    
+
+
-  
-  private Map<ResourceType, Set<ResourceListener>> listeners = new HashMap<ResourceType, Set<ResourceListener>>();
-  
+
+  private Map<ResourceType, Set<ResourceListener>> listeners =
+      new HashMap<ResourceType, Set<ResourceListener>>();
+
-  
-  //The set of in progress rebalance operations.
-  private final Set<RebalanceOperation> inProgressOperations = new HashSet<RebalanceOperation>(); 
+
+  // The set of in progress rebalance operations.
+  private final Set<RebalanceOperation> inProgressOperations = new HashSet<RebalanceOperation>();
-  
+
-  
+
-  
+
-  
+
-  
-  private static String PR_LOAD_PROBE_CLASS = System.getProperty(
-      DistributionConfig.GEMFIRE_PREFIX + "ResourceManager.PR_LOAD_PROBE_CLASS", SizedBasedLoadProbe.class
-          .getName());
-  
+
+  private static String PR_LOAD_PROBE_CLASS =
+      System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "ResourceManager.PR_LOAD_PROBE_CLASS",
+          SizedBasedLoadProbe.class.getName());
+
-  
+
-    
+
-    final ThreadGroup threadGroup = LoggingThreadGroup.createThreadGroup(
-        "ResourceManagerThreadGroup", logger);
+    final ThreadGroup threadGroup =
+        LoggingThreadGroup.createThreadGroup("ResourceManagerThreadGroup", logger);
+
-        Thread thread = new Thread(threadGroup, r,
-        "ResourceManagerRecoveryThread " + tId);
+        Thread thread = new Thread(threadGroup, r, "ResourceManagerRecoveryThread " + tId);
-    final ThreadGroup listenerInvokerthrdGrp = LoggingThreadGroup.createThreadGroup(
-        "ResourceListenerInvokerThreadGroup", logger);
+    final ThreadGroup listenerInvokerthrdGrp =
+        LoggingThreadGroup.createThreadGroup("ResourceListenerInvokerThreadGroup", logger);
-    BlockingQueue<Runnable> threadQ = new OverflowQueueWithDMStats(this.stats.getResourceEventQueueStatHelper());
-    this.notifyExecutor = new SerialQueuedExecutorWithDMStats(threadQ, this.stats.getResourceEventPoolStatHelper(),
-        eventProcessorFactory);
-    
+    BlockingQueue<Runnable> threadQ =
+        new OverflowQueueWithDMStats(this.stats.getResourceEventQueueStatHelper());
+    this.notifyExecutor = new SerialQueuedExecutorWithDMStats(threadQ,
+        this.stats.getResourceEventPoolStatHelper(), eventProcessorFactory);
+
-    tempMonitors.put(ResourceType.OFFHEAP_MEMORY, new OffHeapMemoryMonitor(this, cache, cache.getOffHeapStore(), this.stats));
+    tempMonitors.put(ResourceType.OFFHEAP_MEMORY,
+        new OffHeapMemoryMonitor(this, cache, cache.getOffHeapStore(), this.stats));
-    
+
-    for (ResourceType resourceType : new ResourceType[] { ResourceType.HEAP_MEMORY, ResourceType.OFFHEAP_MEMORY }) {
+    for (ResourceType resourceType : new ResourceType[] {ResourceType.HEAP_MEMORY,
+        ResourceType.OFFHEAP_MEMORY}) {
-    
+
-    
+
-  
+
-    
+
-  
+
-  
-  public void addResourceListener(final ResourceType resourceType, final ResourceListener listener) {
+
+  public void addResourceListener(final ResourceType resourceType,
+      final ResourceListener listener) {
-  
+
-  
-  public void removeResourceListener(final ResourceType resourceType, final ResourceListener listener) {
+
+  public void removeResourceListener(final ResourceType resourceType,
+      final ResourceListener listener) {
-  
+
-  
+
-   * Deliver an event received from remote resource managers to the local
-   * listeners.
+   * Deliver an event received from remote resource managers to the local listeners.
-   * @param event
-   *          Event to deliver.
+   * @param event Event to deliver.
-      this.cache.getLoggerI18n().fine("New remote event to deliver for member " + event.getMember() + ": event=" + event);
+      this.cache.getLoggerI18n()
+          .fine("New remote event to deliver for member " + event.getMember() + ": event=" + event);
-      this.cache.getLoggerI18n().fine("Remote event to deliver for member " + event.getMember() + ":" + event);
+      this.cache.getLoggerI18n()
+          .fine("Remote event to deliver for member " + event.getMember() + ":" + event);
-  
+
-      this.resourceMonitors.get(event.getType()).notifyListeners(this.listeners.get(event.getType()), event);
+      this.resourceMonitors.get(event.getType())
+          .notifyListeners(this.listeners.get(event.getType()), event);
-    
+
- 
+
-  
+
-  
+
-   * Use threshold event processor to execute the event embedded in the
-   * runnable.
+   * Use threshold event processor to execute the event embedded in the runnable.
-   * @param runnable
-   *          Runnable to execute.
+   * @param runnable Runnable to execute.
-        this.cache.getLoggerI18n().warning(LocalizedStrings.ResourceManager_REJECTED_EXECUTION_CAUSE_NOHEAP_EVENTS);
+        this.cache.getLoggerI18n()
+            .warning(LocalizedStrings.ResourceManager_REJECTED_EXECUTION_CAUSE_NOHEAP_EVENTS);
-  
+
-    
+
-    synchronized(this.inProgressOperationsLock) {
+    synchronized (this.inProgressOperationsLock) {
-  
+
-    synchronized(this.inProgressOperationsLock) {
+    synchronized (this.inProgressOperationsLock) {
-  
+
-    synchronized(this.inProgressOperationsLock) {
+    synchronized (this.inProgressOperationsLock) {
-  
+
-    private Set<String> includedRegions; 
+    private Set<String> includedRegions;
-    
+
-      RebalanceOperationImpl op = new RebalanceOperationImpl(InternalResourceManager.this.cache, true, filter);
+      RebalanceOperationImpl op =
+          new RebalanceOperationImpl(InternalResourceManager.this.cache, true, filter);
-      RebalanceOperationImpl op = new RebalanceOperationImpl(InternalResourceManager.this.cache, false,filter);
+      RebalanceOperationImpl op =
+          new RebalanceOperationImpl(InternalResourceManager.this.cache, false, filter);
-  
+
-    final int secToWait = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "prrecovery-close-timeout", 120).intValue();
+    final int secToWait = Integer
+        .getInteger(DistributionConfig.GEMFIRE_PREFIX + "prrecovery-close-timeout", 120).intValue();
-    }
-    catch (InterruptedException x) {
+    } catch (InterruptedException x) {
-    if (! executor.isTerminated()) {
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.ResourceManager_FAILED_TO_STOP_RESOURCE_MANAGER_THREADS,
-            new Object[]{secToWait}));
+    if (!executor.isTerminated()) {
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.ResourceManager_FAILED_TO_STOP_RESOURCE_MANAGER_THREADS,
+          new Object[] {secToWait}));
-  
+
-  
+
-   * For testing only, an observer which is called when
-   * rebalancing is started and finished for a particular region.
-   * This observer is called even the "rebalancing" is actually
-   * redundancy recovery for a particular region.
+   * For testing only, an observer which is called when rebalancing is started and finished for a
+   * particular region. This observer is called even the "rebalancing" is actually redundancy
+   * recovery for a particular region.
+   * 
-    if(observer == null) {
+    if (observer == null) {
-  
+
-  
+
+     * 
-    
+
+     * 
-    
+
+     * 
-    
+
+     * 
-     * Indicated that a membership event triggered a recovery
-     * operation, but the recovery operation will not be executed
-     * because there is already an existing recovery operation
-     * waiting to happen on this region.
+     * Indicated that a membership event triggered a recovery operation, but the recovery operation
+     * will not be executed because there is already an existing recovery operation waiting to
+     * happen on this region.
+     * 
-   
+
-     * Indicates that a bucket is being moved from the source member to the
-     * target member.
+     * Indicates that a bucket is being moved from the source member to the target member.
+     * 
-    public void movingBucket(Region region,
-                             int bucketId, 
-                             DistributedMember source, 
-                             DistributedMember target);
-    
+    public void movingBucket(Region region, int bucketId, DistributedMember source,
+        DistributedMember target);
+
-     * Indicates that a bucket primary is being moved from the source member 
-     * to the target member.
+     * Indicates that a bucket primary is being moved from the source member to the target member.
+     * 
-    public void movingPrimary(Region region,
-                              int bucketId, 
-                              DistributedMember source, 
-                              DistributedMember target);
+    public void movingPrimary(Region region, int bucketId, DistributedMember source,
+        DistributedMember target);
-  
+
-    
-    
+
+
-      
+
+
-      
+
+
-      
+
+
+
-      //do nothing
+      // do nothing
+
-      //do nothing
+      // do nothing
+
-      //do nothing
+      // do nothing
+
-    public void movingBucket(Region region,
-                             int bucketId, 
-                             DistributedMember source, 
-                             DistributedMember target) {
-      //do nothing
+    public void movingBucket(Region region, int bucketId, DistributedMember source,
+        DistributedMember target) {
+      // do nothing
+
-    public void movingPrimary(Region region,
-                              int bucketId, 
-                              DistributedMember source, 
-                              DistributedMember target) {
-      //do nothing
+    public void movingPrimary(Region region, int bucketId, DistributedMember source,
+        DistributedMember target) {
+      // do nothing
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-    return getOffHeapMonitor().getCriticalThreshold(); 
+    return getOffHeapMonitor().getCriticalThreshold();
-    return getHeapMonitor().getCriticalThreshold(); 
+    return getHeapMonitor().getCriticalThreshold();
-    return getHeapMonitor().getEvictionThreshold(); 
+    return getHeapMonitor().getEvictionThreshold();

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
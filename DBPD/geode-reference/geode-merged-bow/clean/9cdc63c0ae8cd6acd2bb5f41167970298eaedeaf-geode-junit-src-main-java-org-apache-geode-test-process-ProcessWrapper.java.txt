 GEODE-4240: Fix testCreateBuckets on windows (#3660)

* Move gemfire config to properties file
* Reformat code to improve readability
* Add directory option to ProcessWrapper to inject TemporaryFolder

The -J-Dgemfire.locator="" with quotes was breaking the next argument
on windows. Moving the config to properties file works around this.

+import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import java.io.OutputStream;
-import java.util.concurrent.TimeUnit;
- * Wraps spawned {@link java.lang.Process} to capture output and provide interaction with the
- * process.
+ * Wraps spawned {@link Process} to capture output and provide interaction with the process.
+  private final File directory;
-  private boolean starting = false;
-  private boolean started = false;
-  private boolean stopped = false;
-  private boolean interrupted = false;
+  private boolean starting;
+  private boolean started;
+  private boolean stopped;
+  private boolean interrupted;
-      final long timeoutMillis) {
+      final long timeoutMillis, final File directory) {
+    this.directory = directory;
-    this.lineBuffer = new LinkedBlockingQueue<>();
-    this.allLines = Collections.synchronizedList(new ArrayList<>());
+    lineBuffer = new LinkedBlockingQueue<>();
+    allLines = Collections.synchronizedList(new ArrayList<>());
-    this.lineBuffer.offer(line);
-    this.allLines.add(line);
+    allLines.add(line);
+    lineBuffer.offer(line);
-    synchronized (this.exitValue) {
+    synchronized (exitValue) {
-    synchronized (this.exitValue) {
+    synchronized (exitValue) {
-      synchronized (this.exitValue) {
-        done = (this.process != null || this.processException != null)
-            && (this.started || this.exitValue.get() > -1 || this.interrupted);
+      synchronized (exitValue) {
+        done = (process != null || processException != null)
+            && (started || exitValue.get() > -1 || interrupted);
-    synchronized (this.exitValue) {
-      if (this.interrupted) { // TODO: do we want to do this?
+    synchronized (exitValue) {
+      if (interrupted) {
-      return this.exitValue.get() == -1 && this.started && !this.stopped && !this.interrupted
-          && this.processThread.isAlive();
+      return exitValue.get() == -1 && started && !stopped && !interrupted
+          && processThread.isAlive();
-    if (this.process != null) {
-      this.process.destroy();
+    if (process != null) {
+      process.destroy();
-    synchronized (this.exitValue) {
+    synchronized (exitValue) {
-      return this.exitValue.get();
+      return exitValue.get();
-    final Iterator<String> iterator = this.allLines.iterator();
+    final Iterator<String> iterator = allLines.iterator();
-      sb.append(iterator.next() + "\n");
+      sb.append(iterator.next() + System.lineSeparator());
-    final PrintStream ps = new PrintStream(this.process.getOutputStream());
+    final PrintStream ps = new PrintStream(process.getOutputStream());
-      final String line = lineBuffer.poll(timeoutMillis, TimeUnit.MILLISECONDS);
+      final String line = lineBuffer.poll(timeoutMillis, MILLISECONDS);
-            + line + "\". Output: " + this.allLines);
+            + line + "\". Output: " + allLines);
-    final Pattern pattern = Pattern.compile(patternString);
+    final Pattern pattern = Pattern.compile(patternString);
-      final String line = this.lineBuffer.poll(timeoutMillis, TimeUnit.MILLISECONDS);
+      final String line = lineBuffer.poll(timeoutMillis, MILLISECONDS);
-      } else {
-        logger.debug(
-            "ProcessWrapper:waitForOutputToMatch Did not match pattern \"{}\" against output \"{}\"",
-            patternString, line);
+      logger.debug(
+          "ProcessWrapper:waitForOutputToMatch Did not match pattern \"{}\" against output \"{}\"",
+          patternString, line);
-    return execute(null, new File(System.getProperty("user.dir")));
+    return execute(null, directory);
-    return execute(properties, new File(System.getProperty("user.dir")));
+    return execute(properties, directory);
-    synchronized (this.exitValue) {
-      if (this.starting) {
+    synchronized (exitValue) {
+      if (starting) {
-      this.starting = true;
-      this.processThread = new Thread(new Runnable() {
-        @Override
-        public void run() {
-          start(properties, workingDirectory);
-        }
-      }, "ProcessWrapper Process Thread");
+      starting = true;
+      processThread =
+          new Thread(() -> start(properties, workingDirectory), "ProcessWrapper Process Thread");
-    this.processThread.start();
+    processThread.start();
-    synchronized (this.exitValue) {
-      if (this.processException != null) {
-        logger.error("ProcessWrapper:execute failed with " + this.processException);
-        this.processException.printStackTrace();
+    synchronized (exitValue) {
+      if (processException != null) {
+        logger.error("ProcessWrapper:execute failed with " + processException);
+        processException.printStackTrace();
-    if (this.useMainLauncher) {
-      sendInput(); // to trigger MainLauncher delegation to inner main
+    if (useMainLauncher) {
+      // to trigger MainLauncher delegation to inner main
+      sendInput();
-    final List<String> jvmArgumentsList = new ArrayList<String>();
+    final List<String> jvmArgumentsList = new ArrayList<>();
-    if (this.headless) {
+    if (headless) {
-    if (this.jvmArguments != null) {
-      for (String jvmArgument : this.jvmArguments) {
-        jvmArgumentsList.add(jvmArgument);
-      }
+    if (jvmArguments != null) {
+      Collections.addAll(jvmArgumentsList, jvmArguments);
-      synchronized (this.exitValue) {
+      synchronized (exitValue) {
-        this.process = new ProcessBuilder(command).directory(workingDirectory).start();
+        process = new ProcessBuilder(command).directory(workingDirectory).start();
-            this.process.getInputStream(), this);
+            process.getInputStream(), this);
-            this.process.getErrorStream(), this);
+            process.getErrorStream(), this);
-        this.stdout = stdOut;
-        this.stderr = stdErr;
-        this.outputReader = new ProcessOutputReader(this.process, stdOut, stdErr);
-        this.started = true;
+        stdout = stdOut;
+        stderr = stdErr;
+        outputReader = new ProcessOutputReader(process, stdOut, stdErr);
+        started = true;
-      this.outputReader.start();
-      this.outputReader.waitFor(PROCESS_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
-      boolean exited = process.waitFor(PROCESS_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
+      outputReader.start();
+      outputReader.waitFor(PROCESS_TIMEOUT_MILLIS, MILLISECONDS);
+      boolean exited = process.waitFor(PROCESS_TIMEOUT_MILLIS, MILLISECONDS);
-      synchronized (this.exitValue) {
-        this.exitValue.set(exited ? process.exitValue() : 0);
-        this.stopped = exited;
+      synchronized (exitValue) {
+        exitValue.set(exited ? process.exitValue() : 0);
+        stopped = exited;
-      synchronized (this.exitValue) {
-        this.interrupted = true;
-        this.processException = e;
+      synchronized (exitValue) {
+        interrupted = true;
+        processException = e;
-      synchronized (this.exitValue) {
-        this.processException = t;
+      synchronized (exitValue) {
+        processException = t;
-    final int bits = Integer.getInteger("sun.arch.data.model", 0).intValue();
-    if (bits == 64 && !(System.getProperty("os.name").toLowerCase().contains("windows"))
+    final int bits = Integer.getInteger("sun.arch.data.model", 0);
+    if (bits == 64 && !System.getProperty("os.name").toLowerCase().contains("windows")
-    if (this.useMainLauncher) {
+    if (useMainLauncher) {
-    final String[] command = argumentList.toArray(new String[argumentList.size()]);
-    return command;
+    return argumentList.toArray(new String[0]);
-    synchronized (this.exitValue) {
-      if (!this.starting) {
+    synchronized (exitValue) {
+      if (!starting) {
-    synchronized (this.exitValue) {
-      if (!this.stopped) {
+    synchronized (exitValue) {
+      if (!stopped) {
-    if (this.processException != null) {
-      throw new RuntimeException("Failed to launch process", this.processException);
+    if (processException != null) {
+      throw new RuntimeException("Failed to launch process", processException);
-    synchronized (this.exitValue) {
-      return this.processThread;
+    synchronized (exitValue) {
+      return processThread;
-    return this.process;
+    return process;
-    for (String jar : entries) {
-      Path absPath = Paths.get(jar).toAbsolutePath();
-      Path relPath = locationPath.relativize(absPath);
-      if (absPath.toFile().isDirectory()) {
-        manifestEntries.add(relPath.toString() + "/");
+    for (String jarEntry : entries) {
+      Path jarEntryAbsolutePath = Paths.get(jarEntry).toAbsolutePath();
+      Path jarEntryRelativizedPath = locationPath.relativize(jarEntryAbsolutePath);
+      if (jarEntryAbsolutePath.toFile().isDirectory()) {
+        manifestEntries.add(jarEntryRelativizedPath + File.separator);
-        manifestEntries.add(relPath.toString());
+        manifestEntries.add(jarEntryRelativizedPath.toString());
-    Attributes global = manifest.getMainAttributes();
-    global.put(Attributes.Name.MANIFEST_VERSION, "1.0.0");
-    global.put(new Attributes.Name("Class-Path"), String.join(" ", manifestEntries));
+    Attributes attributes = manifest.getMainAttributes();
+    attributes.put(Attributes.Name.MANIFEST_VERSION, "1.0.0");
+    attributes.put(new Attributes.Name("Class-Path"), String.join(" ", manifestEntries));
-    Path manifestJar = Paths.get(location, "manifest-" + uuid + ".jar");
-    JarOutputStream jos = null;
-    try {
-      File jarFile = manifestJar.toFile();
-      jarFile.deleteOnExit();
-      OutputStream os = new FileOutputStream(jarFile);
-      jos = new JarOutputStream(os, manifest);
-    } catch (IOException e) {
-      e.printStackTrace();
-    } finally {
-      if (jos != null) {
-        jos.close();
-      }
+    Path manifestJarPath = Paths.get(location, "manifest-" + uuid + ".jar");
+    File manifestJarFile = manifestJarPath.toFile();
+    manifestJarFile.deleteOnExit();
+
+    try (JarOutputStream jos =
+        new JarOutputStream(new FileOutputStream(manifestJarFile), manifest)) {
+      // the above try-with-resource writes the manifest to the manifestJarFile
-    return manifestJar.toString();
+    return manifestJarPath.toFile().getAbsolutePath();
-    private String[] jvmArguments = null;
+
+    private String[] jvmArguments;
-    private String[] mainArguments = null;
+    private String[] mainArguments;
-    private boolean inline = false;
-
-    public Builder() {
-      // nothing
-    }
+    private boolean inline;
+    private File directory = new File(System.getProperty("user.dir"));
+    public Builder directory(final File directory) {
+      this.directory = directory;
+      return this;
+    }
+
-          timeoutMillis);
+          timeoutMillis, directory);

MOV26 UPD40 INS23 MOV23 MOV23 MOV31 INS83 INS83 INS43 INS59 INS44 MOV60 MOV43 MOV43 INS23 UPD66 INS42 INS42 INS83 INS43 INS42 INS21 MOV60 MOV21 INS54 INS83 INS43 INS59 INS43 INS42 INS44 INS42 INS42 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS8 INS42 MOV32 INS42 INS42 INS42 INS42 INS58 INS8 INS32 UPD42 UPD42 INS42 INS42 MOV14 INS42 INS83 INS43 INS42 INS21 INS41 INS22 INS42 INS42 INS42 INS42 UPD42 INS42 UPD42 INS42 MOV21 UPD42 MOV42 INS42 MOV21 INS42 INS42 MOV21 MOV32 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 MOV59 INS32 INS42 INS42 INS7 INS52 INS52 INS42 INS42 INS42 INS42 INS42 INS7 UPD74 INS42 INS42 INS34 INS42 MOV43 MOV43 UPD42 UPD42 INS14 UPD42 MOV42 UPD42 MOV42 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 UPD42 UPD42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 UPD42 UPD42 MOV43 MOV14 INS42 INS52 INS42 INS42 INS32 INS42 INS42 INS42 MOV43 INS86 INS45 MOV43 MOV43 INS42 UPD42 UPD42 UPD42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 MOV43 MOV43 INS42 INS42 INS42 INS42 INS42 INS40 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL66 DEL9 DEL9 DEL9 DEL9 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL45 DEL52 DEL42 DEL22 DEL40 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL40 DEL8 DEL42 DEL43 DEL42 DEL45 DEL32 DEL14 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL78 DEL83 DEL39 DEL42 DEL8 DEL31 DEL1 DEL14 DEL45 DEL14 DEL7 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL8 DEL70 DEL8 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL40 DEL40 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL36 DEL52 DEL42 DEL22 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL45 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL60 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL8 DEL12 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL32 DEL33 DEL33 DEL9 DEL42
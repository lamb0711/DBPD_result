Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Note: The reason for different classes for Destroy and Invalidate is to
- * prevent sending an extra bit for every DestroyMessage to differentiate an
- * invalidate versus a destroy. The assumption is that these operations are used
- * frequently, if they are not then it makes sense to fold the destroy and the
- * invalidate into the same message and use an extra bit to differentiate
+ * Note: The reason for different classes for Destroy and Invalidate is to prevent sending an extra
+ * bit for every DestroyMessage to differentiate an invalidate versus a destroy. The assumption is
+ * that these operations are used frequently, if they are not then it makes sense to fold the
+ * destroy and the invalidate into the same message and use an extra bit to differentiate
- *  
+ * 
-  
+
-  
+
-  /** An additional object providing context for the operation, e.g., for BridgeServer notification */
+  /**
+   * An additional object providing context for the operation, e.g., for BridgeServer notification
+   */
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  public DestroyMessage() {
-  }
+  public DestroyMessage() {}
-  protected DestroyMessage(Set recipients,
-                           boolean notifyOnly,
-                           int regionId,
-                           DirectReplyProcessor processor,
-                           EntryEventImpl event,
-                           Object expectedOldValue) {
+  protected DestroyMessage(Set recipients, boolean notifyOnly, int regionId,
+      DirectReplyProcessor processor, EntryEventImpl event, Object expectedOldValue) {
-//    Assert.assertTrue(original.eventId != null); bug #47235 - region invalidation has no event id, so this fails
+    // Assert.assertTrue(original.eventId != null); bug #47235 - region invalidation has no event
+    // id, so this fails
-  
+
-   * send a notification-only message to a set of listeners.  The processor
-   * id is passed with the message for reply message processing.  This method
-   * does not wait on the processor.
+   * send a notification-only message to a set of listeners. The processor id is passed with the
+   * message for reply message processing. This method does not wait on the processor.
-      FilterRoutingInfo filterRoutingInfo, 
-      PartitionedRegion r, EntryEventImpl event, 
+      FilterRoutingInfo filterRoutingInfo, PartitionedRegion r, EntryEventImpl event,
-    DestroyMessage msg = new DestroyMessage(Collections.EMPTY_SET, 
-        true, r.getPRId(), processor, event, null);
+    DestroyMessage msg =
+        new DestroyMessage(Collections.EMPTY_SET, true, r.getPRId(), processor, event, null);
-    return msg.relayToListeners(cacheOpReceivers, adjunctRecipients,
-        filterRoutingInfo, event, r, processor);
+    return msg.relayToListeners(cacheOpReceivers, adjunctRecipients, filterRoutingInfo, event, r,
+        processor);
-  
+
-   * Sends a DestroyMessage
-   * {@link org.apache.geode.cache.Region#destroy(Object)}message to the
+   * Sends a DestroyMessage {@link org.apache.geode.cache.Region#destroy(Object)}message to the
-   * @param r
-   *          the PartitionedRegion for which the destroy was performed
+   * @param r the PartitionedRegion for which the destroy was performed
-   * @return the processor used to await the potential
-   *         {@link org.apache.geode.cache.CacheException}
+   * @return the processor used to await the potential {@link org.apache.geode.cache.CacheException}
-  public static DestroyResponse send(DistributedMember recipient,
-                                       PartitionedRegion r,
-                                       EntryEventImpl event,
-                                       Object expectedOldValue) 
-  throws ForceReattemptException {
-    //Assert.assertTrue(recipient != null, "DestroyMessage NULL recipient"); recipient may be null for event notification
+  public static DestroyResponse send(DistributedMember recipient, PartitionedRegion r,
+      EntryEventImpl event, Object expectedOldValue) throws ForceReattemptException {
+    // Assert.assertTrue(recipient != null, "DestroyMessage NULL recipient"); recipient may be null
+    // for event notification
-    DestroyMessage m = new DestroyMessage(recipients,
-                                          false,
-                                          r.getPRId(),
-                                          p,
-                                          event,
-                                          expectedOldValue);
+    DestroyMessage m =
+        new DestroyMessage(recipients, false, r.getPRId(), p, event, expectedOldValue);
-    Set failures =r.getDistributionManager().putOutgoing(m); 
-    if (failures != null && failures.size() > 0 ) {
-      throw new ForceReattemptException(LocalizedStrings.DestroyMessage_FAILED_SENDING_0.toLocalizedString(m));
+    Set failures = r.getDistributionManager().putOutgoing(m);
+    if (failures != null && failures.size() > 0) {
+      throw new ForceReattemptException(
+          LocalizedStrings.DestroyMessage_FAILED_SENDING_0.toLocalizedString(m));
-    DestroyMessage msg = new DestroyMessage(this, event, members );
-    //Fix for 43000 - don't send the expected old value to listeners.
+    DestroyMessage msg = new DestroyMessage(this, event, members);
+    // Fix for 43000 - don't send the expected old value to listeners.
-  
+
-   * This method is called upon receipt and make the desired changes to the
-   * PartitionedRegion Note: It is very important that this message does NOT
-   * cause any deadlocks as the sender will wait indefinitely for the
-   * acknowledgement
+   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:
+   * It is very important that this message does NOT cause any deadlocks as the sender will wait
+   * indefinitely for the acknowledgement
-  protected boolean operateOnPartitionedRegion(DistributionManager dm,
-      PartitionedRegion r, long startTime)
-      throws EntryExistsException, DataLocationException
-  {
+  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion r,
+      long startTime) throws EntryExistsException, DataLocationException {
-       eventSender = getSender();
+      eventSender = getSender();
-    @Released EntryEventImpl event = null;
+    @Released
+    EntryEventImpl event = null;
-    if (this.bridgeContext != null) {
-      event = EntryEventImpl.create(r, getOperation(), this.key, null/*newValue*/,
-          getCallbackArg(), false/*originRemote*/, eventSender, 
-          true/*generateCallbacks*/);
-      event.setContext(this.bridgeContext);
-    } // bridgeContext != null
-    else {
-      event = EntryEventImpl.create(
-        r,
-        getOperation(),
-        this.key,
-        null, /*newValue*/
-        getCallbackArg(),
-        false/*originRemote - false to force distribution in buckets*/,
-        eventSender,
-        true/*generateCallbacks*/,
-        false/*initializeId*/);
-    }
-    if (this.versionTag != null) {
-      this.versionTag.replaceNullIDs(getSender());
-      event.setVersionTag(this.versionTag);
-    }
-    event.setInvokePRCallbacks(!notificationOnly);
-    Assert.assertTrue(eventId != null);
-    event.setEventId(eventId);
-    event.setPossibleDuplicate(this.posDup);
+      if (this.bridgeContext != null) {
+        event = EntryEventImpl.create(r, getOperation(), this.key, null/* newValue */,
+            getCallbackArg(), false/* originRemote */, eventSender, true/* generateCallbacks */);
+        event.setContext(this.bridgeContext);
+      } // bridgeContext != null
+      else {
+        event = EntryEventImpl.create(r, getOperation(), this.key, null, /* newValue */
+            getCallbackArg(), false/* originRemote - false to force distribution in buckets */,
+            eventSender, true/* generateCallbacks */, false/* initializeId */);
+      }
+      if (this.versionTag != null) {
+        this.versionTag.replaceNullIDs(getSender());
+        event.setVersionTag(this.versionTag);
+      }
+      event.setInvokePRCallbacks(!notificationOnly);
+      Assert.assertTrue(eventId != null);
+      event.setEventId(eventId);
+      event.setPossibleDuplicate(this.posDup);
-    PartitionedRegionDataStore ds = r.getDataStore();
-    boolean sendReply = true;
-    
-    if (!notificationOnly) {
-      Assert.assertTrue(ds!=null, "This process should have storage for an item in " + this.toString());
-      try {
-        Integer bucket = Integer.valueOf(PartitionedRegionHelper.getHashKey(r,
-            null, this.key, null, this.cbArg));
-//        try {
-//          // the event must show its true origin for cachewriter invocation
-//          event.setOriginRemote(true);
-//          event.setPartitionMessage(this);
-//          r.doCacheWriteBeforeDestroy(event);
-//        }
-//        finally {
-//          event.setOriginRemote(false);
-//        }
-        event.setCausedByMessage(this);
-        r.getDataView().destroyOnRemote(event, true/*cacheWrite*/, this.expectedOldValue);
-        if (logger.isTraceEnabled(LogMarker.DM)) {
-          logger.trace(LogMarker.DM, "{} updated bucket: {} with key: {}", getClass().getName(), bucket, this.key);
+      PartitionedRegionDataStore ds = r.getDataStore();
+      boolean sendReply = true;
+
+      if (!notificationOnly) {
+        Assert.assertTrue(ds != null,
+            "This process should have storage for an item in " + this.toString());
+        try {
+          Integer bucket = Integer
+              .valueOf(PartitionedRegionHelper.getHashKey(r, null, this.key, null, this.cbArg));
+          // try {
+          // // the event must show its true origin for cachewriter invocation
+          // event.setOriginRemote(true);
+          // event.setPartitionMessage(this);
+          // r.doCacheWriteBeforeDestroy(event);
+          // }
+          // finally {
+          // event.setOriginRemote(false);
+          // }
+          event.setCausedByMessage(this);
+          r.getDataView().destroyOnRemote(event, true/* cacheWrite */, this.expectedOldValue);
+          if (logger.isTraceEnabled(LogMarker.DM)) {
+            logger.trace(LogMarker.DM, "{} updated bucket: {} with key: {}", getClass().getName(),
+                bucket, this.key);
+          }
+        } catch (CacheWriterException cwe) {
+          sendReply(getSender(), this.processorId, dm, new ReplyException(cwe), r, startTime);
+          return false;
+        } catch (EntryNotFoundException eee) {
+          logger.trace(LogMarker.DM, "{}: operateOnRegion caught EntryNotFoundException",
+              getClass().getName());
+          ReplyMessage.send(getSender(), getProcessorId(), new ReplyException(eee),
+              getReplySender(dm), r.isInternalRegion());
+          sendReply = false; // this prevents us from acking later
+        } catch (PrimaryBucketException pbe) {
+          sendReply(getSender(), getProcessorId(), dm, new ReplyException(pbe), r, startTime);
+          sendReply = false;
+
+        } finally {
+          this.versionTag = event.getVersionTag();
+        }
+      } else {
+        @Released
+        EntryEventImpl e2 = createListenerEvent(event, r, dm.getDistributionManagerId());
+        try {
+          r.invokeDestroyCallbacks(EnumListenerEvent.AFTER_DESTROY, e2, r.isInitialized(), true);
+        } finally {
+          // if e2 == ev then no need to free it here. The outer finally block will get it.
+          if (e2 != event) {
+            e2.release();
+          }
-      catch (CacheWriterException cwe) {
-        sendReply(getSender(), this.processorId, dm, new ReplyException(cwe), r, startTime);
-        return false;
-      }
-      catch (EntryNotFoundException eee) {
-        logger.trace(LogMarker.DM, "{}: operateOnRegion caught EntryNotFoundException", getClass().getName());
-        ReplyMessage.send(getSender(), getProcessorId(), 
-            new ReplyException(eee), getReplySender(dm), r.isInternalRegion());
-        sendReply = false; // this prevents us from acking later
-      }
-      catch (PrimaryBucketException pbe) {
-        sendReply(getSender(), getProcessorId(), dm, new ReplyException(pbe), r, startTime);
-        sendReply = false;
-      } finally {
-        this.versionTag = event.getVersionTag();
-      }
-    }
-    else {
-      @Released EntryEventImpl e2 = createListenerEvent(event, r, dm.getDistributionManagerId());
-      try {
-      r.invokeDestroyCallbacks(EnumListenerEvent.AFTER_DESTROY, e2, r.isInitialized(), true);
-      } finally {
-        // if e2 == ev then no need to free it here. The outer finally block will get it.
-        if (e2 != event) {
-          e2.release();
-        }
-      }
-    }
-
-    return sendReply;
+      return sendReply;
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex, PartitionedRegion pr, long startTime) {
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+      PartitionedRegion pr, long startTime) {
-      pr.getPrStats().endPartitionMessagesProcessing(startTime); 
+      pr.getPrStats().endPartitionMessagesProcessing(startTime);
-      DestroyReplyMessage.send(getSender(), getReplySender(dm), this.processorId, this.versionTag, pr != null && pr.isInternalRegion());
+      DestroyReplyMessage.send(getSender(), getReplySender(dm), this.processorId, this.versionTag,
+          pr != null && pr.isInternalRegion());
-      ReplyMessage.send(getSender(), this.processorId, ex, getReplySender(dm), pr != null && pr.isInternalRegion());
+      ReplyMessage.send(getSender(), this.processorId, ex, getReplySender(dm),
+          pr != null && pr.isInternalRegion());
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException
-  {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    this.originalSender = (InternalDistributedMember)DataSerializer.readObject(in);
-    this.eventId = (EventID)DataSerializer.readObject(in);
+    this.originalSender = (InternalDistributedMember) DataSerializer.readObject(in);
+    this.eventId = (EventID) DataSerializer.readObject(in);
-}
+  }
-  public void toData(DataOutput out) throws IOException
-  {
+  public void toData(DataOutput out) throws IOException {
-    DataSerializer.writeObject(this.eventId, out);    
+    DataSerializer.writeObject(this.eventId, out);
-    if (this.filterInfo != null) s |= HAS_FILTER_INFO;
+    if (this.filterInfo != null)
+      s |= HAS_FILTER_INFO;
-  /** create a new EntryEvent to be used in notifying listeners, bridge servers, etc.
-   * Caller must release result if it is != to sourceEvent
+  /**
+   * create a new EntryEvent to be used in notifying listeners, bridge servers, etc. Caller must
+   * release result if it is != to sourceEvent
-    }
-    else {
+    } else {
-  
+
-  protected void appendFields(StringBuffer buff)
-  {
+  protected void appendFields(StringBuffer buff) {
-  protected final Object getKey()
-  {
+  protected final Object getKey() {
-  private final void setKey(Object key)
-  {
+  private final void setKey(Object key) {
-  public final Operation getOperation()
-  {
+  public final Operation getOperation() {
-  protected final Object getCallbackArg()
-  {
+  protected final Object getCallbackArg() {
-  
+
-  public void setFilterInfo(FilterRoutingInfo filterInfo){
-    if (filterInfo != null){
+  public void setFilterInfo(FilterRoutingInfo filterInfo) {
+    if (filterInfo != null) {
-  
+
-    public DestroyReplyMessage() {
-    }
-    
-    static void send(InternalDistributedMember recipient, ReplySender dm, int procId, VersionTag versionTag, boolean internal) {
+    public DestroyReplyMessage() {}
+
+    static void send(InternalDistributedMember recipient, ReplySender dm, int procId,
+        VersionTag versionTag, boolean internal) {
-    
+
-        logger.trace(LogMarker.DM, "DestroyReplyMessage process invoking reply processor with processorId: {}", this.processorId);
+        logger.trace(LogMarker.DM,
+            "DestroyReplyMessage process invoking reply processor with processorId: {}",
+            this.processorId);
-      //dm.getLogger().warning("RemotePutResponse processor is " + ReplyProcessor21.getProcessor(this.processorId));
+      // dm.getLogger().warning("RemotePutResponse processor is " +
+      // ReplyProcessor21.getProcessor(this.processorId));
-        DestroyResponse processor = (DestroyResponse)rp;
+        DestroyResponse processor = (DestroyResponse) rp;
-      dm.getStats().incReplyMessageTime(NanoTimer.getTime()-startTime);
+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);
-      b |= this.versionTag instanceof DiskVersionTag ? PERSISTENT_TAG : 0; 
+      b |= this.versionTag instanceof DiskVersionTag ? PERSISTENT_TAG : 0;
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    /* (non-Javadoc)
+    /*
+     * (non-Javadoc)
+     * 
-    
+
-    
+
-    
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66
GEODE-3073: Renamed OrderByComparatorUnmapped to OrderByComparatorMapped and refactored the code a bit.

This closes #591

+import java.util.Arrays;
-      throws TypeMismatchException, AmbiguousNameException, NameResolutionException {
+      throws TypeMismatchException, NameResolutionException {
-      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+      throws TypeMismatchException, NameResolutionException {
-      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+      throws TypeMismatchException, NameResolutionException {
-      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+      throws TypeMismatchException, NameResolutionException {
-      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+      throws TypeMismatchException, NameResolutionException {
-      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+      throws TypeMismatchException, NameResolutionException {
-      if ((DefaultQuery) context.getQuery() != null) {
+      if (context.getQuery() != null) {
-            CompiledSortCriterion csc = (CompiledSortCriterion) orderByAttrs.get(0);
+            CompiledSortCriterion csc = orderByAttrs.get(0);
-                CompiledSortCriterion csc = (CompiledSortCriterion) this.orderByAttrs.get(0);
+                CompiledSortCriterion csc = this.orderByAttrs.get(0);
-        SelectResults sr = (SelectResults) result;
+        SelectResults sr = result;
-          SelectResults res = (SelectResults) result;
+          SelectResults res = result;
-      boolean evaluateWhereClause, int numElementsInResult) throws TypeMismatchException,
-      AmbiguousNameException, FunctionDomainException, NameResolutionException,
+      boolean evaluateWhereClause, int numElementsInResult)
+      throws TypeMismatchException, FunctionDomainException, NameResolutionException,
-        int occurence =
+        int occurrence =
-        // If the occurence is greater than 1, then only in case of
+        // If the occurrence is greater than 1, then only in case of
-        if (occurence == 1 || (occurence > 1 && !this.distinct)) {
-          // (Unique i.e first time occurence) or subsequent occurence
+        if (occurrence == 1 || (occurrence > 1 && !this.distinct)) {
+          // (Unique i.e first time occurrence) or subsequent occurrence
-      if ((DefaultQuery) context.getQuery() != null
-          && ((DefaultQuery) context.getQuery()).isKeepSerialized() && sr instanceof QRegion) {
+      if (context.getQuery() != null && ((DefaultQuery) context.getQuery()).isKeepSerialized()
+          && sr instanceof QRegion) {
-      Iterator cIter = sr.iterator();
-      while (cIter.hasNext()) {
+      for (Object aSr : sr) {
-        Object currObj = cIter.next();
+        Object currObj = aSr;
-      ExecutionContext context, boolean ignoreOrderBy)
-      throws TypeMismatchException, AmbiguousNameException, FunctionDomainException,
-      NameResolutionException, QueryInvocationTargetException {
+      ExecutionContext context, boolean ignoreOrderBy) throws TypeMismatchException,
+      FunctionDomainException, NameResolutionException, QueryInvocationTargetException {
-      // If the projection attribute is null( ie.e specified as *) &
-      // there is only one
-      // Runtime Iteratir we can return the set as it is.But if the proejction
-      // attribute is null & multiple Iterators are defined we need to rectify
-      // the
-      // the StructBag that is returned. It is to be noted that in case of
-      // single from clause
-      // where the from clause itself is defined as nested select query with
-      // multiple
-      // from clauses , the resultset returned will be a StructBag which we
-      // have to return
-      // as it is.
+      // If the projection attribute is null (ie specified as *) & there is only one Runtime
+      // Iterator we can return the set as it is. But if the projection attribute is null & multiple
+      // Iterators are defined we need to rectify the StructBag that is returned. It is to be noted
+      // that in case of single from clause where the from clause itself is defined as nested select
+      // query with multiple from clauses, the result set returned will be a StructBag which we have
+      // to return as it is.
-        ((SelectResults) resultSet).setElementType(type);
+        resultSet.setElementType(type);
-        // Apply limit if there is no order by.
+        // Apply limit if there is no order by
-          // Check if query execution on this thread is canceled.
+          // Check if query execution on this thread is canceled
-            // (Unique i.e first time occurence) or subsequent occurence
+            // (Unique i.e first time occurrence) or subsequent occurrence
-        Iterator resultsIter = ((SelectResults) resultSet).iterator();
+        Iterator resultsIter = resultSet.iterator();
-          int occurence = applyProjectionAndAddToResultSet(context, pResultSet, ignoreOrderBy);
-          if (occurence == 1 || (occurence > 1 && !this.distinct)) {
-            // (Unique i.e first time occurence) or subsequent occurence
+          int occurrence = applyProjectionAndAddToResultSet(context, pResultSet, ignoreOrderBy);
+          if (occurrence == 1 || (occurrence > 1 && !this.distinct)) {
+            // (Unique i.e first time occurrence) or subsequent occurrence
+  public enum DataContainerType {
+    // isOrdered, distinct, elementType.isStructType(), ignoreOrderBy
+    UNORDERED_DISTINCT_STRUCT(false, true, true, true),
+    UNORDERED_DISTINCT_RESULTS(false, true, false, true),
+    UNORDERED_INDISTINCT_STRUCT(false, false, true, true),
+    UNORDERED_INDISTINCT_RESULTS(false, false, false, true),
+
+    ORDERED_DISTINCT_STRUCT_IGNORED(true, true, true, true),
+    ORDERED_INDISTINCT_STRUCT_IGNORED(true, false, true, true),
+    ORDERED_DISTINCT_STRUCT_UNIGNORED(true, true, true, false),
+    ORDERED_INDISTINCT_STRUCT_UNIGNORED(true, false, true, false),
+    ORDERED_DISTINCT_RESULTS_IGNORED(true, true, false, true),
+    ORDERED_INDISTINCT_RESULTS_IGNORED(true, false, false, true),
+    ORDERED_DISTINCT_RESULTS_UNIGNORED(true, true, false, false),
+    ORDERED_INDISTINCT_RESULTS_UNIGNORED(true, false, false, false);
+
+    public static DataContainerType determineDataContainerType(boolean getOrdered,
+        boolean getDistinct, boolean getStructType, boolean getIgnoreOrderBy)
+        throws TypeMismatchException {
+      // if not isOrdered, then isIgnoreOrderBy is irrelevant
+      return Arrays.stream(DataContainerType.values()).filter(type -> type.isOrdered == getOrdered)
+          .filter(type -> type.isDistinct == getDistinct)
+          .filter(type -> type.isStructType == getStructType)
+          .filter(type -> type.isIgnoreOrderBy == getIgnoreOrderBy || !type.isOrdered).findFirst()
+          .orElseThrow(() -> new TypeMismatchException("Logical inconsistency in CompiledSelect"));
+    }
+
+    DataContainerType(boolean isOrdered, boolean isDistinct, boolean isStructType,
+        boolean isIgnoreOrderBy) {
+      this.isOrdered = isOrdered;
+      this.isDistinct = isDistinct;
+      this.isStructType = isStructType;
+      this.isIgnoreOrderBy = isIgnoreOrderBy;
+    }
+
+    private final boolean isOrdered, isDistinct, isStructType, isIgnoreOrderBy;
+  }
+
-    // if no projection attributes or '*'as projection attribute
-    // & more than one/RunTimeIterator then create a StrcutSet.
-    // If attribute is null or '*' & only one RuntimeIterator then create a
-    // ResultSet.
-    // If single attribute is present without alias name , then create
-    // ResultSet
-    // Else if more than on attribute or single attribute with alias is
-    // present then return a StrcutSet
-    // create StructSet which will contain root objects of all iterators in
-    // from clause
-
+    // If no projection attributes or '*' as projection attribute & more than one/RunTimeIterator
+    // then create a StructSet.
+    // If attribute is null or '*' & only one RuntimeIterator then create a ResultSet.
+    // If single attribute is present without alias name, then create ResultSet.
+    // Else if more than on attribute or single attribute with alias is present then return a
+    // StructSet.
+    // Create StructSet which will contain root objects of all iterators in from clause.
-    if (this.distinct || !this.count) {
-      if (this.orderByAttrs != null) {
-        boolean nullValuesAtStart = !((CompiledSortCriterion) orderByAttrs.get(0)).getCriterion();
-        if (elementType.isStructType()) {
-          if (ignoreOrderBy) {
-            results = this.distinct ? new LinkedStructSet((StructTypeImpl) elementType)
-                : new SortedResultsBag(elementType, nullValuesAtStart);
-          } else {
-            OrderByComparator comparator = this.hasUnmappedOrderByCols
-                ? new OrderByComparatorUnmapped(this.orderByAttrs, (StructTypeImpl) elementType,
-                    context)
-                : new OrderByComparator(this.orderByAttrs, (StructTypeImpl) elementType, context);
-            results = this.distinct ? new SortedStructSet(comparator, (StructTypeImpl) elementType)
-                : new SortedStructBag(comparator, (StructType) elementType, nullValuesAtStart);
-
-          }
-        } else {
-          if (ignoreOrderBy) {
-            results =
-                this.distinct ? new LinkedResultSet() : new SortedResultsBag(nullValuesAtStart);
-
-          } else {
-            OrderByComparator comparator = this.hasUnmappedOrderByCols
-                ? new OrderByComparatorUnmapped(this.orderByAttrs, elementType, context)
-                : new OrderByComparator(this.orderByAttrs, elementType, context);
-            results = this.distinct ? new SortedResultSet(comparator)
-                : new SortedResultsBag(comparator, nullValuesAtStart);
-          }
-          results.setElementType(elementType);
-        }
-      } else {
-        if (this.distinct) {
-          if (elementType.isStructType()) {
-            results = new StructSet((StructType) elementType);
-          } else {
-            results = new ResultsSet(elementType);
-          }
-        } else {
-          if (elementType.isStructType()) {
-            results = new StructBag((StructType) elementType, context.getCachePerfStats());
-          } else {
-            results = new ResultsBag(elementType, context.getCachePerfStats());
-          }
-        }
-      }
-    } else {
-      // Shobhit: If its a 'COUNT' query and no End processing required Like for
-      // 'DISTINCT'
-      // we can directly keep count in ResultSet and ResultBag is good enough
-      // for that.
-      results =
-          new ResultsBag(new ObjectTypeImpl(Integer.class), 1 /*
-                                                               * initial capacity for count value
-                                                               */, context.getCachePerfStats());
+    if (!this.distinct && this.count) {
+      // Shobhit: If it's a 'COUNT' query and no End processing required Like for 'DISTINCT'
+      // we can directly keep count in ResultSet and ResultBag is good enough for that.
+      results = new ResultsBag(new ObjectTypeImpl(Integer.class), 1, context.getCachePerfStats());
-
+      return results;
-    return results;
+
+    // Potential edge-case: Could this be non-null but empty?
+    boolean nullValuesAtStart = orderByAttrs != null && !orderByAttrs.get(0).getCriterion();
+    OrderByComparator comparator;
+    boolean isOrdered = this.orderByAttrs != null;
+
+    switch (DataContainerType.determineDataContainerType(isOrdered, distinct,
+        elementType.isStructType(), ignoreOrderBy)) {
+      case UNORDERED_DISTINCT_STRUCT:
+        return new StructSet((StructType) elementType);
+      case UNORDERED_DISTINCT_RESULTS:
+        return new ResultsSet(elementType);
+      case UNORDERED_INDISTINCT_STRUCT:
+        return new StructBag((StructType) elementType, context.getCachePerfStats());
+      case UNORDERED_INDISTINCT_RESULTS:
+        return new ResultsBag(elementType, context.getCachePerfStats());
+
+      case ORDERED_DISTINCT_STRUCT_IGNORED:
+        return new LinkedStructSet((StructTypeImpl) elementType);
+      case ORDERED_INDISTINCT_STRUCT_IGNORED:
+        return new SortedResultsBag(elementType, nullValuesAtStart);
+      case ORDERED_DISTINCT_STRUCT_UNIGNORED:
+        comparator = this.hasUnmappedOrderByCols
+            ? new OrderByComparatorMapped(this.orderByAttrs, elementType, context)
+            : new OrderByComparator(this.orderByAttrs, elementType, context);
+        return new SortedStructSet(comparator, (StructTypeImpl) elementType);
+      case ORDERED_INDISTINCT_STRUCT_UNIGNORED:
+        comparator = this.hasUnmappedOrderByCols
+            ? new OrderByComparatorMapped(this.orderByAttrs, elementType, context)
+            : new OrderByComparator(this.orderByAttrs, elementType, context);
+        return new SortedStructBag(comparator, (StructType) elementType, nullValuesAtStart);
+      case ORDERED_DISTINCT_RESULTS_IGNORED:
+        results = new LinkedResultSet();
+        results.setElementType(elementType);
+        return results;
+      case ORDERED_INDISTINCT_RESULTS_IGNORED:
+        results = new SortedResultsBag(nullValuesAtStart);
+        results.setElementType(elementType);
+        return results;
+      case ORDERED_DISTINCT_RESULTS_UNIGNORED:
+        comparator = this.hasUnmappedOrderByCols
+            ? new OrderByComparatorMapped(this.orderByAttrs, elementType, context)
+            : new OrderByComparator(this.orderByAttrs, elementType, context);
+        results = new SortedResultSet(comparator);
+        results.setElementType(elementType);
+        return results;
+      case ORDERED_INDISTINCT_RESULTS_UNIGNORED:
+        comparator = this.hasUnmappedOrderByCols
+            ? new OrderByComparatorMapped(this.orderByAttrs, elementType, context)
+            : new OrderByComparator(this.orderByAttrs, elementType, context);
+        results = new SortedResultsBag(comparator, nullValuesAtStart);
+        results.setElementType(elementType);
+        return results;
+    }
+    throw new TypeMismatchException("Logical inconsistency in CompiledSelect");
-            values[i] = ((PdxString) values[i]).toString();
+            values[i] = values[i].toString();
-          if ((operator != TOK_NE && operator != TOK_NE_ALT)) {
-            return false;
-          } else {
-            return true;
-          }
+          return operator == TOK_NE || operator == TOK_NE_ALT;

INS26 INS40 INS71 INS83 INS42 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS31 INS31 INS23 MOV8 INS42 INS9 INS9 INS9 INS9 INS42 INS9 INS9 INS9 INS9 INS42 INS9 INS9 INS9 INS9 INS42 INS9 INS9 INS9 INS9 INS42 INS9 INS9 INS9 INS9 INS42 INS9 INS9 INS9 INS9 INS42 INS9 INS9 INS9 INS9 INS42 INS9 INS9 INS9 INS9 INS42 INS9 INS9 INS9 INS9 INS42 INS9 INS9 INS9 INS9 INS42 INS9 INS9 INS9 INS9 INS42 INS9 INS9 INS9 INS9 INS83 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS43 INS8 INS42 INS44 INS44 INS44 INS44 INS8 INS83 INS83 INS39 INS59 INS59 INS59 INS59 MOV60 MOV60 INS25 MOV60 INS60 INS60 INS50 INS53 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS42 INS41 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS21 INS21 INS21 INS21 INS42 INS42 INS42 INS42 INS27 INS8 MOV43 INS59 INS39 INS59 INS32 INS49 INS41 INS49 INS41 INS49 INS41 INS49 INS41 INS49 INS41 INS49 INS41 INS49 INS21 INS41 INS49 INS21 INS41 INS49 INS21 MOV21 MOV41 INS49 MOV21 INS21 INS41 INS49 INS21 INS21 INS21 INS41 INS49 INS21 MOV21 INS21 INS41 INS14 INS70 INS32 INS7 INS7 INS7 INS7 INS38 MOV22 MOV21 MOV21 INS41 INS27 INS42 INS42 MOV27 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 MOV14 INS42 MOV14 INS42 MOV14 INS42 MOV14 INS42 MOV14 INS42 MOV14 INS42 MOV7 MOV14 INS42 INS7 MOV14 INS42 MOV7 INS42 INS32 INS42 INS42 INS7 MOV7 INS32 INS42 INS42 MOV7 INS32 INS42 INS43 INS45 INS44 INS42 MOV8 INS32 INS42 INS86 INS22 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS27 MOV38 UPD42 MOV16 INS42 INS16 MOV14 MOV14 INS42 INS42 INS42 INS42 INS16 MOV14 INS42 INS42 INS42 INS42 INS16 MOV14 INS42 INS42 INS42 INS42 MOV32 INS43 INS42 INS32 INS42 INS14 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS33 MOV22 MOV14 MOV14 INS22 INS14 INS14 INS22 INS14 INS14 UPD42 MOV42 INS32 INS42 INS86 INS43 INS45 MOV32 UPD43 UPD43 MOV22 INS42 INS22 INS42 MOV52 UPD42 MOV42 INS43 MOV22 INS42 INS42 INS43 INS22 INS42 INS42 INS52 INS42 INS43 INS22 INS42 INS42 INS43 INS22 INS42 INS42 INS42 UPD42 MOV32 INS42 INS42 INS32 INS42 INS86 INS59 INS27 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS52 INS42 INS42 INS52 INS42 UPD42 INS32 INS42 INS86 INS59 INS27 INS42 INS27 INS38 INS41 INS42 INS42 INS32 INS42 INS86 INS59 INS27 INS42 INS40 INS42 INS40 INS42 INS40 INS27 UPD42 UPD42 INS42 INS42 INS32 INS59 INS27 INS42 INS40 INS42 UPD27 MOV27 UPD27 MOV27 MOV32 UPD42 INS42 INS42 INS42 INS40 INS42 UPD42 MOV2 MOV43 MOV32 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL11 DEL42 DEL43 DEL11 DEL42 DEL43 DEL11 DEL42 DEL43 DEL42 DEL11 DEL42 DEL43 DEL42 DEL11 DEL42 DEL43 DEL42 DEL43 DEL11 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL43 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL43 DEL11 DEL36 DEL52 DEL42 DEL22 DEL16 DEL42 DEL43 DEL42 DEL11 DEL42 DEL43 DEL42 DEL11 DEL52 DEL42 DEL22 DEL16 DEL52 DEL42 DEL22 DEL16 DEL42 DEL52 DEL42 DEL22 DEL16 DEL32 DEL42 DEL21 DEL8 DEL42 DEL43 DEL42 DEL16 DEL59 DEL60 DEL21 DEL8 DEL25 DEL8 DEL42 DEL8 DEL42 DEL59 DEL60 DEL8 DEL25 DEL8 DEL25 DEL8 DEL22 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL21 DEL8 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL52 DEL42 DEL22 DEL38 DEL27 DEL8 DEL25 DEL8 DEL42 DEL43 DEL11 DEL36 DEL27 DEL36 DEL9 DEL41 DEL8 DEL9 DEL41 DEL8 DEL25
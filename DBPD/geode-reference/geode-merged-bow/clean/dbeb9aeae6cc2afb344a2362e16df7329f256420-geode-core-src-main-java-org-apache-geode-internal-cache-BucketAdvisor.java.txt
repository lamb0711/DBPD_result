Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Specialized {@link CacheDistributionAdvisor} for {@link BucketRegion 
- * BucketRegions}. The <code>BucketAdvisor</code> is owned by a {@link 
- * ProxyBucketRegion} and may outlive a <code>BucketRegion</code>.
+ * Specialized {@link CacheDistributionAdvisor} for {@link BucketRegion BucketRegions}. The
+ * <code>BucketAdvisor</code> is owned by a {@link ProxyBucketRegion} and may outlive a
+ * <code>BucketRegion</code>.
-public class BucketAdvisor extends CacheDistributionAdvisor  {
+public class BucketAdvisor extends CacheDistributionAdvisor {
-    //TODO: Boolean.getBoolean("gemfire.BucketAdvisor.debug.enforceSafeClose");
-  
+  // TODO: Boolean.getBoolean("gemfire.BucketAdvisor.debug.enforceSafeClose");
+
-  
-  /** 
-   * Advice requests for {@link #adviseProfileUpdate()} delegate to the 
-   * partitioned region's <code>RegionAdvisor</code> to include members with 
-   * {@link ProxyBucketRegion}s as well as real {@link BucketRegion}s. 
+
+  /**
+   * Advice requests for {@link #adviseProfileUpdate()} delegate to the partitioned region's
+   * <code>RegionAdvisor</code> to include members with {@link ProxyBucketRegion}s as well as real
+   * {@link BucketRegion}s.
-  /** 
-   * The bucket primary will be holding this distributed lock. Protected by
-   * synchronized(this). 
+  /**
+   * The bucket primary will be holding this distributed lock. Protected by synchronized(this).
-  //private static final byte MASK_HOSTING       = 1; // 0001 
-  //private static final byte MASK_VOLUNTEERING  = 2; // 0010
-  //private static final byte MASK_OTHER_PRIMARY = 4; // 0100
-  //private static final byte MASK_IS_PRIMARY    = 8; // 1000
-  
-  private static final byte NO_PRIMARY_NOT_HOSTING    = 0;  // 0000_0000
-  private static final byte NO_PRIMARY_HOSTING        = 1;  // 0000_0001
-  private static final byte OTHER_PRIMARY_NOT_HOSTING = 4;  // 0000_0100
-  private static final byte OTHER_PRIMARY_HOSTING     = 5;  // 0000_0101
-  private static final byte VOLUNTEERING_HOSTING      = 3;  // 0000_0011
-  private static final byte BECOMING_HOSTING          = 15; // 0000_1111
-  private static final byte IS_PRIMARY_HOSTING        = 9;  // 0000_1001
-  private static final byte CLOSED                    = 16; // 0001_0000
-  
-  /** 
-   * The current state of this BucketAdvisor which tracks which member is
-   * primary and whether or not this member is hosting a real Bucket.
+  // private static final byte MASK_HOSTING = 1; // 0001
+  // private static final byte MASK_VOLUNTEERING = 2; // 0010
+  // private static final byte MASK_OTHER_PRIMARY = 4; // 0100
+  // private static final byte MASK_IS_PRIMARY = 8; // 1000
+
+  private static final byte NO_PRIMARY_NOT_HOSTING = 0; // 0000_0000
+  private static final byte NO_PRIMARY_HOSTING = 1; // 0000_0001
+  private static final byte OTHER_PRIMARY_NOT_HOSTING = 4; // 0000_0100
+  private static final byte OTHER_PRIMARY_HOSTING = 5; // 0000_0101
+  private static final byte VOLUNTEERING_HOSTING = 3; // 0000_0011
+  private static final byte BECOMING_HOSTING = 15; // 0000_1111
+  private static final byte IS_PRIMARY_HOSTING = 9; // 0000_1001
+  private static final byte CLOSED = 16; // 0001_0000
+
+  /**
+   * The current state of this BucketAdvisor which tracks which member is primary and whether or not
+   * this member is hosting a real Bucket.
-  
+
-   * This delegate handles all volunteering for primary status. Lazily created.
-   * Protected by synchronization(this).
+   * This delegate handles all volunteering for primary status. Lazily created. Protected by
+   * synchronization(this).
-  
-  /** 
-   * Used by {@link #updateRedundancy()} to determine if stat change is
-   * required. Access and mutation are done while synchronized on this
-   * advisor.
+
+  /**
+   * Used by {@link #updateRedundancy()} to determine if stat change is required. Access and
+   * mutation are done while synchronized on this advisor.
-  
-  /** 
-   * Used by {@link #incLowRedundancyBucketCount(int)} to determine if 
-   * redundancy for this bucket has ever been satisfied. Only buckets which 
-   * lose redundancy after having redundancy will generate a redundancy loss 
-   * alert. 
+
+  /**
+   * Used by {@link #incLowRedundancyBucketCount(int)} to determine if redundancy for this bucket
+   * has ever been satisfied. Only buckets which lose redundancy after having redundancy will
+   * generate a redundancy loss alert.
-  private boolean redundancyEverSatisfied = false; 
-  
+  private boolean redundancyEverSatisfied = false;
+
-   * A read/write lock to prevent making this bucket not primary while a write
-   * is in progress on the bucket.
+   * A read/write lock to prevent making this bucket not primary while a write is in progress on the
+   * bucket.
-  
+
-   * The advisor for the bucket region that we are colocated with, if this region
-   * is a colocated region.
+   * The advisor for the bucket region that we are colocated with, if this region is a colocated
+   * region.
-  
+
-   * The member that is responsible for choosing the primary
-   * for this bucket. While this field is set and this member
-   * exists, this bucket won't try to become primary.
+   * The member that is responsible for choosing the primary for this bucket. While this field is
+   * set and this member exists, this bucket won't try to become primary.
-  
+
-  
+
-  
+
-  /** 
+  /**
-  private BucketAdvisor(Bucket bucket, 
-                       RegionAdvisor regionAdvisor) {
+  private BucketAdvisor(Bucket bucket, RegionAdvisor regionAdvisor) {
-  
+
-    PartitionedRegion colocatedRegion = ColocationHelper
-        .getColocatedRegion(this.pRegion);
+    PartitionedRegion colocatedRegion = ColocationHelper.getColocatedRegion(this.pRegion);
-        List<FixedPartitionAttributesImpl> fpas = colocatedRegion
-            .getFixedPartitionAttributesImpl();
+        List<FixedPartitionAttributesImpl> fpas = colocatedRegion.getFixedPartitionAttributesImpl();
-              this.parentAdvisor = colocatedRegion.getRegionAdvisor()
-                  .getBucketAdvisor(fpa.getStartingBucketID());
+              this.parentAdvisor =
+                  colocatedRegion.getRegionAdvisor().getBucketAdvisor(fpa.getStartingBucketID());
+      } else {
+        this.parentAdvisor = colocatedRegion.getRegionAdvisor().getBucketAdvisor(bucketId);
-      else {
-        this.parentAdvisor = colocatedRegion.getRegionAdvisor()
-            .getBucketAdvisor(bucketId);
-      }
-    }
-    else {
+    } else {
-      List<FixedPartitionAttributesImpl> fpas = this.pRegion
-          .getFixedPartitionAttributesImpl();
+      List<FixedPartitionAttributesImpl> fpas = this.pRegion.getFixedPartitionAttributesImpl();
-            startingBucketAdvisor = this.regionAdvisor.getBucketAdvisor(
-                fpa.getStartingBucketID());
+            startingBucketAdvisor = this.regionAdvisor.getBucketAdvisor(fpa.getStartingBucketID());
-   * Returns the lock that prevents the primary from moving while active writes
-   * are in progress. This should be locked before checking if the local bucket
-   * is primary.
-   *  
+   * Returns the lock that prevents the primary from moving while active writes are in progress.
+   * This should be locked before checking if the local bucket is primary.
+   * 
-  
+
-   * Returns the lock that prevents the parent's primary from moving while
-   * active writes are in progress. This should be locked before checking if the
-   * local bucket is primary.
+   * Returns the lock that prevents the parent's primary from moving while active writes are in
+   * progress. This should be locked before checking if the local bucket is primary.
-   */  
+   */
-   * Try to lock the primary bucket to make sure no operation is on-going at
-   * current bucket.  
+   * Try to lock the primary bucket to make sure no operation is on-going at current bucket.
-  
+
-   * Makes this <code>BucketAdvisor</code> give up being a primary and become
-   * a secondary. Does nothing if not currently the primary.
+   * Makes this <code>BucketAdvisor</code> give up being a primary and become a secondary. Does
+   * nothing if not currently the primary.
-        synchronized(this) {
+        synchronized (this) {
-            //releasePrimaryLock();
+            // releasePrimaryLock();
-            BucketRegionQueue brq = (BucketRegionQueue)this.getBucket();
+            BucketRegionQueue brq = (BucketRegionQueue) this.getBucket();
-  
+
-   * This calls deposePrimary on every colocated child that is directly
-   * colocated to this bucket's PR. Those each in turn do the same to their
-   * child buckets and so on before returning. Each depose will send a dlock
-   * release message to the grantor, wait for reply, and then also send a
+   * This calls deposePrimary on every colocated child that is directly colocated to this bucket's
+   * PR. Those each in turn do the same to their child buckets and so on before returning. Each
+   * depose will send a dlock release message to the grantor, wait for reply, and then also send a
-
+   * 
-    
+
-    List<PartitionedRegion> colocatedChildPRs = 
+    List<PartitionedRegion> colocatedChildPRs =
-    }    
+    }
-    List<FixedPartitionAttributesImpl> fpas = this.pRegion
-        .getFixedPartitionAttributesImpl();
+    List<FixedPartitionAttributesImpl> fpas = this.pRegion.getFixedPartitionAttributesImpl();
-          for (int i = (bucketId+1); i <= fpa.getLastBucketID(); i++) {
+          for (int i = (bucketId + 1); i <= fpa.getLastBucketID(); i++) {
-              deposedOtherPrimaries = ba.deposePrimary()
-                  && deposedOtherPrimaries;
+              deposedOtherPrimaries = ba.deposePrimary() && deposedOtherPrimaries;
-        }
-        else {
+        } else {
-  
+
-  
+
-   * Increment or decrement lowRedundancyBucketCount stat and generate 
-   * alert only once per loss of redundancy for PR but only if redundancy
-   * has ever been satisfied.
+   * Increment or decrement lowRedundancyBucketCount stat and generate alert only once per loss of
+   * redundancy for PR but only if redundancy has ever been satisfied.
-    
+
-    final boolean[] lowRedundancyFlags = 
-        this.regionAdvisor.getLowRedundancyFlags();
-    final int configuredRedundancy =
-        this.pRegion.getRedundantCopies();
-    
+    final boolean[] lowRedundancyFlags = this.regionAdvisor.getLowRedundancyFlags();
+    final int configuredRedundancy = this.pRegion.getRedundantCopies();
+
-      
+
-      
+
-        
+
-        
-        if (!lowRedundancyFlags[HAS_LOW_REDUNDANCY] || 
-            !lowRedundancyFlags[ALREADY_GENERATED_WARNING]) {
+
+        if (!lowRedundancyFlags[HAS_LOW_REDUNDANCY]
+            || !lowRedundancyFlags[ALREADY_GENERATED_WARNING]) {
-          
+
-          
+
-          if (!lowRedundancyFlags[ALREADY_GENERATED_WARNING] && 
-              this.redundancyEverSatisfied) {
-            
+          if (!lowRedundancyFlags[ALREADY_GENERATED_WARNING] && this.redundancyEverSatisfied) {
+
-                new Object[] { Integer.valueOf(configuredRedundancy), Integer.valueOf(actualRedundancy), this.pRegion.getFullPath()}));
+                new Object[] {Integer.valueOf(configuredRedundancy),
+                    Integer.valueOf(actualRedundancy), this.pRegion.getFullPath()}));
-   * Return (and possibly choose) a thread-sticky member from whose data store
-   * this bucket's values should be read
+   * Return (and possibly choose) a thread-sticky member from whose data store this bucket's values
+   * should be read
+   * 
-      return getDistributionManager().getId();      
+      return getDistributionManager().getId();
-    
+
-  
+
-      return locProfiles[0].peerMemberId; 
+      return locProfiles[0].peerMemberId;
-    
+
-    }
-  
+  }
+
-   * Returns the thread-safe queue of primary volunteering tasks for the
-   * parent Partitioned Region.
+   * Returns the thread-safe queue of primary volunteering tasks for the parent Partitioned Region.
-  
+
-   * Returns the semaphore which controls the number of threads allowed to
-   * consume from the {@link #getVolunteeringQueue volunteering queue}.
+   * Returns the semaphore which controls the number of threads allowed to consume from the
+   * {@link #getVolunteeringQueue volunteering queue}.
-  
-  /** 
+
+  /**
-   */ 
+   */
-  
+
-      this.notifyAll(); 
+      this.notifyAll();
-    this.regionAdvisor.updateBucketStatus(this.getBucket().getId(),
-        profile.peerMemberId, false);
+    this.regionAdvisor.updateBucketStatus(this.getBucket().getId(), profile.peerMemberId, false);
-    synchronized (this){
+    synchronized (this) {
-      this.notifyAll(); 
+      this.notifyAll();
-    this.regionAdvisor.updateBucketStatus(this.getBucket().getId(), 
-        profile.peerMemberId, false);
-    
+    this.regionAdvisor.updateBucketStatus(this.getBucket().getId(), profile.peerMemberId, false);
+
-      this.regionAdvisor.updateBucketStatus(this.getBucket().getId(), 
+      this.regionAdvisor.updateBucketStatus(this.getBucket().getId(),
-    
+
-    BucketProfile profile = (BucketProfile)getProfile(id);
+    BucketProfile profile = (BucketProfile) getProfile(id);
-  
+
-      result = ((ProxyBucketRegion)getAdvisee()).getHostedBucketRegion();
+      result = ((ProxyBucketRegion) getAdvisee()).getHostedBucketRegion();
-  
-   * Called by the RegionAdvisor.profileRemoved, this method
-   * tests to see if the missing member is the primary elector
-   * for this bucket.
+   * Called by the RegionAdvisor.profileRemoved, this method tests to see if the missing member is
+   * the primary elector for this bucket.
-   * We can't call this method from BucketAdvisor.profileRemoved,
-   * because the primaryElector may not actually host the bucket.
+   * We can't call this method from BucketAdvisor.profileRemoved, because the primaryElector may not
+   * actually host the bucket.
+   * 
-    //If the member that went away was in the middle of creating
-    //the bucket, finish the bucket creation.
-    if(this.primaryElector != null && this.primaryElector.equals(profile.getDistributedMember())) {
+    // If the member that went away was in the middle of creating
+    // the bucket, finish the bucket creation.
+    if (this.primaryElector != null && this.primaryElector.equals(profile.getDistributedMember())) {
-        logger.debug("Bucket {} lost the member responsible for electing the primary. Finishing bucket creation", getBucket().getFullPath());
+        logger.debug(
+            "Bucket {} lost the member responsible for electing the primary. Finishing bucket creation",
+            getBucket().getFullPath());
-          getBucket().getPartitionedRegion().getRedundancyProvider().finishIncompleteBucketCreation(getBucket().getId());
+          getBucket().getPartitionedRegion().getRedundancyProvider()
+              .finishIncompleteBucketCreation(getBucket().getId());
-   * Only allows profiles that actually hosting this bucket. If the profile is
-   * primary, then primaryMember will be set to that member but only
-   * if we are not already the primary.
+   * Only allows profiles that actually hosting this bucket. If the profile is primary, then
+   * primaryMember will be set to that member but only if we are not already the primary.
-   * @param forceProfile true will force profile to be added even if member is
-   * not in distributed view
+   * @param forceProfile true will force profile to be added even if member is not in distributed
+   *        view
-   * @see #adviseProfileUpdate() 
+   * @see #adviseProfileUpdate()
-    if ( ! bp.isHosting && ! bp.isInitializing) {
+    if (!bp.isHosting && !bp.isInitializing) {
-      return false;  // Do not allow introduction of proxy profiles, they don't provide anything useful
+      return false; // Do not allow introduction of proxy profiles, they don't provide anything
+                    // useful
-      logger.trace(LogMarker.DA, "BucketAdvisor#putProfile profile=<{}> force={}; profile = {}", profile, forceProfile, bp);
+      logger.trace(LogMarker.DA, "BucketAdvisor#putProfile profile=<{}> force={}; profile = {}",
+          profile, forceProfile, bp);
-    // isHosting = true,  isInitializing = false
-    // isHosting = true,  isInitializing = true... (false state)
-    
+    // isHosting = true, isInitializing = false
+    // isHosting = true, isInitializing = true... (false state)
+
-    synchronized(this) {
+    synchronized (this) {
-      if (applied && !isPrimary()) {  // TODO is it safe to change the bucket state if the profile was not applied?  -- mthomas 2/13/08
+      if (applied && !isPrimary()) { // TODO is it safe to change the bucket state if the profile
+                                     // was not applied? -- mthomas 2/13/08
-      
+
-  private static class SetFromMap<E> extends AbstractSet<E> implements
-      Serializable {
+  private static class SetFromMap<E> extends AbstractSet<E> implements Serializable {
-    private void readObject(ObjectInputStream stream) throws IOException,
-        ClassNotFoundException {
+    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
-   * repopulates the RegionAdvisor's location information
-   * for this bucket
+   * repopulates the RegionAdvisor's location information for this bucket
-    Set<ServerBucketProfile> serverProfiles = newSetFromMap(new HashMap<ServerBucketProfile, Boolean>());
+    Set<ServerBucketProfile> serverProfiles =
+        newSetFromMap(new HashMap<ServerBucketProfile, Boolean>());
-        serverProfiles.add((ServerBucketProfile)p);
+        serverProfiles.add((ServerBucketProfile) p);
+   * 
-  
+
-  public boolean removeId(ProfileId memberId, 
-                          boolean crashed,
-                          boolean destroyed,
-                          boolean fromMembershipListener) {
+  public boolean removeId(ProfileId memberId, boolean crashed, boolean destroyed,
+      boolean fromMembershipListener) {
-        notPrimary((InternalDistributedMember)memberId);
+        notPrimary((InternalDistributedMember) memberId);
-   * Removes the profile for the specified member. If that profile is marked
-   * as primary, this will call {@link #notPrimary(InternalDistributedMember)}.
+   * Removes the profile for the specified member. If that profile is marked as primary, this will
+   * call {@link #notPrimary(InternalDistributedMember)}.
-  public boolean removeIdWithSerial(InternalDistributedMember memberId,
-                                    int serialNum, boolean regionDestroyed) {
+  public boolean removeIdWithSerial(InternalDistributedMember memberId, int serialNum,
+      boolean regionDestroyed) {
-    // delegate up to RegionAdvisor to include members that might have 
+    // delegate up to RegionAdvisor to include members that might have
-    // delegate up to RegionAdvisor to include members that might have 
+    // delegate up to RegionAdvisor to include members that might have
-  
+
-   * Sets hosting to false and returns without closing. Calling closeAdvisor
-   * will actually close this advisor.
+   * Sets hosting to false and returns without closing. Calling closeAdvisor will actually close
+   * this advisor.
-  
-  /** 
-   * Blocks until there is a known primary and return that member, but only
-   * if there are real bucket regions that exist. If there are no real
-   * bucket regions within the distribution config's member-timeout setting
-   * * 3 (time required to eject a member) + 15000, then 
-   * this returns null.
+
+  /**
+   * Blocks until there is a known primary and return that member, but only if there are real bucket
+   * regions that exist. If there are no real bucket regions within the distribution config's
+   * member-timeout setting * 3 (time required to eject a member) + 15000, then this returns null.
-   * kbanks: reworked this method to avoid JIT issue #40639 
+   * kbanks: reworked this method to avoid JIT issue #40639
-    if(primary == null){
-        primary = waitForNewPrimary();
+    if (primary == null) {
+      primary = waitForNewPrimary();
-  /** 
-   * This method was split out from getPrimary() due to bug #40639
-   * and is only intended to be called from within that method.
+  /**
+   * This method was split out from getPrimary() due to bug #40639 and is only intended to be called
+   * from within that method.
+   * 
-  
+
-   * If the current member is primary for this bucket return true, otherwise, 
-   * give some time for the current member to become primary and
-   * then return whether it is a primary (true/false).
+   * If the current member is primary for this bucket return true, otherwise, give some time for the
+   * current member to become primary and then return whether it is a primary (true/false).
-    InternalDistributedMember primary = waitForNewPrimary(); 
-    if(primary != null) {
-        return true;
+    InternalDistributedMember primary = waitForNewPrimary();
+    if (primary != null) {
+      return true;
-  /** 
-   * This method was split out from getPrimary() due to bug #40639
-   * and is only intended to be called from within that method.
+  /**
+   * This method was split out from getPrimary() due to bug #40639 and is only intended to be called
+   * from within that method.
+   * 
-                            15 * 1000);
+        15 * 1000);
-  
-   /** 
-   * Marks member as not primary. Initiates volunteerForPrimary if this
-   * member is hosting a real bucket. This method does nothing
-   * if the member parameter is the current member.
+
+  /**
+   * Marks member as not primary. Initiates volunteerForPrimary if this member is hosting a real
+   * bucket. This method does nothing if the member parameter is the current member.
-    //Fix for 43569. Only the deposePrimary call should
-    //make the local member drop the primary lock.
-    if(!member.equals(getDistributionManager().getId())) {
+    // Fix for 43569. Only the deposePrimary call should
+    // make the local member drop the primary lock.
+    if (!member.equals(getDistributionManager().getId())) {
- 
-  /** 
-   * Marks member as not primary. Initiates volunteerForPrimary if this
-   * member is hosting a real bucket.
+
+  /**
+   * Marks member as not primary. Initiates volunteerForPrimary if this member is hosting a real
+   * bucket.
-      synchronized(this) {
+      synchronized (this) {
-        final InternalDistributedMember currentPrimary = (InternalDistributedMember) this.primaryMember.get();
+        final InternalDistributedMember currentPrimary =
+            (InternalDistributedMember) this.primaryMember.get();
-        } 
-        else {
+        } else {
-        
-        if (isClosed()) { 
+
+        if (isClosed()) {
-            InternalDistributedMember primaryMember = this.regionAdvisor
-                .adviseFixedPrimaryPartitionDataStore(this.getBucket().getId());
+            InternalDistributedMember primaryMember =
+                this.regionAdvisor.adviseFixedPrimaryPartitionDataStore(this.getBucket().getId());
-            }
-            else {
+            } else {
-          }
-          else {
+          } else {
-        }
-        else {
+        } else {
-        if(wasPrimary) {
+        if (wasPrimary) {
-        if( br != null && br instanceof BucketRegion) {
-          ((BucketRegion)br).beforeReleasingPrimaryLockDuringDemotion();
+        if (br != null && br instanceof BucketRegion) {
+          ((BucketRegion) br).beforeReleasingPrimaryLockDuringDemotion();
-    
+
-  
-  /** 
+
+  /**
-    return (ProxyBucketRegion)getAdvisee();
+    return (ProxyBucketRegion) getAdvisee();
-  /** 
-   * Actually close this advisor for real. Called by ProxyBucketRegion only. 
-   * Calling this method actually closes this advisor whereas {@link #close()}
-   * only sets hosting to false.
+  /**
+   * Actually close this advisor for real. Called by ProxyBucketRegion only. Calling this method
+   * actually closes this advisor whereas {@link #close()} only sets hosting to false.
-    synchronized(this) {
+    synchronized (this) {
-      if (!this.redundancySatisfied){
+      if (!this.redundancySatisfied) {
-    if(wasPrimary) {
+    if (wasPrimary) {
-  
-  /** 
+
+  /**
-    synchronized(this) {
+    synchronized (this) {
-  /** 
+  /**
-    synchronized(this) {
+    synchronized (this) {
-  
-  /** 
-   * Returns true if this member is currently volunteering for primary. 
+
+  /**
+   * Returns true if this member is currently volunteering for primary.
-    synchronized(this) {
+    synchronized (this) {
-  /** 
-   * Returns true if this member is currently attempting to become primary. 
+  /**
+   * Returns true if this member is currently attempting to become primary.
-    synchronized(this) {
-      return this.primaryState == BECOMING_HOSTING && 
-             this.volunteeringDelegate != null &&
-             this.volunteeringDelegate.isAggressive();
+    synchronized (this) {
+      return this.primaryState == BECOMING_HOSTING && this.volunteeringDelegate != null
+          && this.volunteeringDelegate.isAggressive();
-  /** 
+  /**
-    synchronized(this) {
-      return this.primaryState == NO_PRIMARY_HOSTING ||
-             this.primaryState == OTHER_PRIMARY_HOSTING ||
-             this.primaryState == VOLUNTEERING_HOSTING ||
-             this.primaryState == BECOMING_HOSTING ||
-             this.primaryState == IS_PRIMARY_HOSTING;
+    synchronized (this) {
+      return this.primaryState == NO_PRIMARY_HOSTING || this.primaryState == OTHER_PRIMARY_HOSTING
+          || this.primaryState == VOLUNTEERING_HOSTING || this.primaryState == BECOMING_HOSTING
+          || this.primaryState == IS_PRIMARY_HOSTING;
-  
+
-   * Attempt to acquire lock for primary until a primary exists. Caller hands
-   * off responsibility to an executor (waiting pool) and returns early.
+   * Attempt to acquire lock for primary until a primary exists. Caller hands off responsibility to
+   * an executor (waiting pool) and returns early.
-   * Makes this <code>BucketAdvisor</code> become the primary if it is already
-   * a secondary.
+   * Makes this <code>BucketAdvisor</code> become the primary if it is already a secondary.
-    long startTime 
-        = getPartitionedRegionStats().startPrimaryTransfer(isRebalance);
+    long startTime = getPartitionedRegionStats().startPrimaryTransfer(isRebalance);
-        
+
-            logger.debug("Breaking from becomePrimary loop because {} is closed or not hosting", this);
+            logger.debug("Breaking from becomePrimary loop because {} is closed or not hosting",
+                this);
-        
+
-            
+
-            
+
-              // invoke becomePrimary AFTER sync is released in this thread...
-              vDelegate = this.volunteeringDelegate;
-              if (vDelegate == null) {
-                vDelegate = new VolunteeringDelegate();
-                this.volunteeringDelegate = vDelegate;
-              }
+            // invoke becomePrimary AFTER sync is released in this thread...
+            vDelegate = this.volunteeringDelegate;
+            if (vDelegate == null) {
+              vDelegate = new VolunteeringDelegate();
+              this.volunteeringDelegate = vDelegate;
+            }
-        
+
-          // Use the snapshot 'vDelegate' instead of 'this.volunteeringDelegate' since we are not synced here.
-          attemptToBecomePrimary = vDelegate.reserveForBecomePrimary(); // no sync! 
+          // Use the snapshot 'vDelegate' instead of 'this.volunteeringDelegate' since we are not
+          // synced here.
+          attemptToBecomePrimary = vDelegate.reserveForBecomePrimary(); // no sync!
-          
+
-          
+
-          if (otherPrimary != null && 
-              !getDistributionManager().getId().equals(otherPrimary)) {
+          if (otherPrimary != null && !getDistributionManager().getId().equals(otherPrimary)) {
-            DeposePrimaryBucketResponse response = 
-                DeposePrimaryBucketMessage.send(
-                    otherPrimary, 
-                    this.pRegion, 
-                    getBucket().getId());
+            DeposePrimaryBucketResponse response =
+                DeposePrimaryBucketMessage.send(otherPrimary, this.pRegion, getBucket().getId());
-        
+
-      
+
-      
+
-      getPartitionedRegionStats().endPrimaryTransfer(
-          startTime, isPrimary(), isRebalance);
+      getPartitionedRegionStats().endPrimaryTransfer(startTime, isPrimary(), isRebalance);
-    
+
-  
+
-   * Check the primary member shortcut.  Does not query the advisor.  Should
-   * only be used when the advisor should not be consulted directly.
-   *  
+   * Check the primary member shortcut. Does not query the advisor. Should only be used when the
+   * advisor should not be consulted directly.
+   * 
-  
-  /** 
+
+  /**
-      logger.debug("Acquired primary lock for BucketID {} PR : {}", getBucket().getId(), regionAdvisor.getPartitionedRegion().getFullPath());
+      logger.debug("Acquired primary lock for BucketID {} PR : {}", getBucket().getId(),
+          regionAdvisor.getPartitionedRegion().getFullPath());
-    //Hold the primary move lock until we send a 
-    //profile update. This will prevent writes
-    //from occurring until all members know that
-    //this member is now the primary.
+    // Hold the primary move lock until we send a
+    // profile update. This will prevent writes
+    // from occurring until all members know that
+    // this member is now the primary.
-            ((BucketRegion)br).beforeAcquiringPrimaryState();
+            ((BucketRegion) br).beforeAcquiringPrimaryState();
-      if(shouldInvokeListeners) {
+      if (shouldInvokeListeners) {
-    }
-    finally {
+    } finally {
-          if( br != null && br instanceof BucketRegion) {
-            ((BucketRegion)br).processPendingSecondaryExpires();
+          if (br != null && br instanceof BucketRegion) {
+            ((BucketRegion) br).processPendingSecondaryExpires();
-            BucketRegionQueue brq = (BucketRegionQueue)br;
+            BucketRegionQueue brq = (BucketRegionQueue) br;
-          if( br != null && br instanceof BucketRegion) {
-            ((BucketRegion)br).afterAcquiringPrimaryState();
+          if (br != null && br instanceof BucketRegion) {
+            ((BucketRegion) br).afterAcquiringPrimaryState();
-        }
-        else {
+        } else {
-    PartitionListener[] listeners = this.pRegion
-        .getPartitionListeners();
+    PartitionListener[] listeners = this.pRegion.getPartitionListeners();
-  
+
-   * Lazily gets the lock for acquiring primary lock. Caller must handle null.
-   * If DLS, Cache, or DistributedSystem are shutting down then null will be
-   * returned. If DLS does not yet exist and createDLS is false then null will
-   * be returned.
+   * Lazily gets the lock for acquiring primary lock. Caller must handle null. If DLS, Cache, or
+   * DistributedSystem are shutting down then null will be returned. If DLS does not yet exist and
+   * createDLS is false then null will be returned.
-    synchronized(this) {
+    synchronized (this) {
-        DistributedLockService dls = DistributedLockService.getServiceNamed(
-            PartitionedRegionHelper.PARTITION_LOCK_SERVICE_NAME);
+        DistributedLockService dls = DistributedLockService
+            .getServiceNamed(PartitionedRegionHelper.PARTITION_LOCK_SERVICE_NAME);
-            return null;  // cache closure has destroyed the DLS
+            return null; // cache closure has destroyed the DLS
-            dls = DLockService.create(
-                PartitionedRegionHelper.PARTITION_LOCK_SERVICE_NAME, 
-                getAdvisee().getSystem(), 
-                true /*distributed*/, 
-                true /*destroyOnDisconnect*/,
-                true /*automateFreeResources*/);
-          }
-          catch (IllegalArgumentException e) {
+            dls = DLockService.create(PartitionedRegionHelper.PARTITION_LOCK_SERVICE_NAME,
+                getAdvisee().getSystem(), true /* distributed */, true /* destroyOnDisconnect */,
+                true /* automateFreeResources */);
+          } catch (IllegalArgumentException e) {
-            dls = DistributedLockService.getServiceNamed(
-                PartitionedRegionHelper.PARTITION_LOCK_SERVICE_NAME);
+            dls = DistributedLockService
+                .getServiceNamed(PartitionedRegionHelper.PARTITION_LOCK_SERVICE_NAME);
-          // TODO: we need a good NotConnectedException to replace 
-          //       IllegalStateException and ShutdownException
-          //       perhaps: DistributedSystemUnavailableException
+          // TODO: we need a good NotConnectedException to replace
+          // IllegalStateException and ShutdownException
+          // perhaps: DistributedSystemUnavailableException
-          }
-          catch (DistributedSystemDisconnectedException e) {
+          } catch (DistributedSystemDisconnectedException e) {
-        this.primaryLock = new DistributedMemberLock(
-            dls, 
-            getAdvisee().getName(), DistributedMemberLock.NON_EXPIRING_LEASE,
+        this.primaryLock = new DistributedMemberLock(dls, getAdvisee().getName(),
+            DistributedMemberLock.NON_EXPIRING_LEASE,
-    final List<PartitionedRegion> colocatedWithList = ColocationHelper
-        .getColocatedChildRegions(regionAdvisor.getPartitionedRegion());
+    final List<PartitionedRegion> colocatedWithList =
+        ColocationHelper.getColocatedChildRegions(regionAdvisor.getPartitionedRegion());
-          logger.debug("BucketAdvisor.acquirePrimaryRecursivelyForColocated: about to take lock for bucket: {} of PR: {} with isHosting={}",
+          logger.debug(
+              "BucketAdvisor.acquirePrimaryRecursivelyForColocated: about to take lock for bucket: {} of PR: {} with isHosting={}",
-              }else {
+              } else {
-        }
-        finally {
+        } finally {
-    List<FixedPartitionAttributesImpl> fpas = this.pRegion
-        .getFixedPartitionAttributesImpl();
+    List<FixedPartitionAttributesImpl> fpas = this.pRegion.getFixedPartitionAttributesImpl();
-        }
-        else {
+        } else {
-  
+
-   * Sets volunteering to true. Returns true if the state of volunteering was
-   * changed. Returns false if voluntering was already equal to true. Caller
-   * should do nothing if false is returned.
+   * Sets volunteering to true. Returns true if the state of volunteering was changed. Returns false
+   * if voluntering was already equal to true. Caller should do nothing if false is returned.
-    synchronized(this) {
+    synchronized (this) {
-   * Sets becoming primary to true. Returns true if the state of becoming was
-   * changed. Returns false if becoming was already equal to true. Caller
-   * should do nothing if false is returned.
+   * Sets becoming primary to true. Returns true if the state of becoming was changed. Returns false
+   * if becoming was already equal to true. Caller should do nothing if false is returned.
-    synchronized(this) {
+    synchronized (this) {
-  
-  /** 
+
+  /**
-          final GemFireCacheImpl cache = (GemFireCacheImpl)getBucket().getCache();
+          final GemFireCacheImpl cache = (GemFireCacheImpl) getBucket().getCache();
-          if (getBucketRedundancy() == -1 ) {
+          if (getBucketRedundancy() == -1) {
-          if (getBucketRedundancy() == -1 || isClosed() ) {
+          if (getBucketRedundancy() == -1 || isClosed()) {
-  
+
-          
-          //Log a warning if we have waited for the ack wait threshold time.
-          if(!loggedWarning) {
+
+          // Log a warning if we have waited for the ack wait threshold time.
+          if (!loggedWarning) {
-            if(timeUntilWarning <= 0 ) {
-              logger.warn(LocalizedMessage.create(LocalizedStrings.BucketAdvisor_WAITING_FOR_PRIMARY,
-                  new Object[] {warnTime / 1000L, this, this.adviseInitialized()}));
-              //log a warning;
-              loggedWarning=true;
+            if (timeUntilWarning <= 0) {
+              logger
+                  .warn(LocalizedMessage.create(LocalizedStrings.BucketAdvisor_WAITING_FOR_PRIMARY,
+                      new Object[] {warnTime / 1000L, this, this.adviseInitialized()}));
+              // log a warning;
+              loggedWarning = true;
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {
-        if(loggedWarning) {
-          logger.info(LocalizedMessage.create(LocalizedStrings.BucketAdvisor_WAITING_FOR_PRIMARY_DONE));
+        if (loggedWarning) {
+          logger.info(
+              LocalizedMessage.create(LocalizedStrings.BucketAdvisor_WAITING_FOR_PRIMARY_DONE));
-  /** 
+  /**
+   * 
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {
-  private final static long BUCKET_STORAGE_WAIT = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "BUCKET_STORAGE_WAIT", 15000).longValue(); // 15 seconds
-  
+  private final static long BUCKET_STORAGE_WAIT =
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "BUCKET_STORAGE_WAIT", 15000).longValue(); // 15
+                                                                                                  // seconds
+
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {
+
-    synchronized(this) {
+    synchronized (this) {
-  
+
-    synchronized(this) {
-      //Only set the new primary elector if we have not yet seen
-      //a primary for this bucket.
-      if(primaryElector != null) {
+    synchronized (this) {
+      // Only set the new primary elector if we have not yet seen
+      // a primary for this bucket.
+      if (primaryElector != null) {
-  
-  
+
+
-    //For child buckets, we want the parent bucket to take care'
-    //of finishing an incomplete bucket creation, so only set the elector for
-    //the leader region.
-    if(parentAdvisor == null) {
+    // For child buckets, we want the parent bucket to take care'
+    // of finishing an incomplete bucket creation, so only set the elector for
+    // the leader region.
+    if (parentAdvisor == null) {
-  
-  /** 
+
+  /**
-    //boolean needToNotPrimarySelf = false;
+    // boolean needToNotPrimarySelf = false;
-    synchronized(this) {
+    synchronized (this) {
-      }     
+      }
-        }
-        else {
+        } else {
-          }
-          else {
+          } else {
-        }
-        else { // no primary...
+        } else { // no primary...
-      //Note - checkRedundancy has the side effect that it updates the stats.
-      //We need to invoke checkRedundancy here, regardless of whether we
-      //need this notify.
+      // Note - checkRedundancy has the side effect that it updates the stats.
+      // We need to invoke checkRedundancy here, regardless of whether we
+      // need this notify.
-        this.notifyAll(); 
+        this.notifyAll();
-    if(wasPrimary) {
+    if (wasPrimary) {
-      logger.trace("setHosting: {} needToVolunteerForPrimary={} primaryElector: {}", this, needToVolunteerForPrimary, primaryElector);
+      logger.trace("setHosting: {} needToVolunteerForPrimary={} primaryElector: {}", this,
+          needToVolunteerForPrimary, primaryElector);
-    /*if (needToNotPrimarySelf) {
-      notPrimary(getAdvisee().getDistributionManager().getId());
-    }*/
+    /*
+     * if (needToNotPrimarySelf) { notPrimary(getAdvisee().getDistributionManager().getId()); }
+     */
-      if(this.primaryElector == null) {
+      if (this.primaryElector == null) {
-    
+
-  
+
-   * Sends updated profile for this member to every member with the 
-   * <code>PartitionedRegion</code>.
+   * Sends updated profile for this member to every member with the <code>PartitionedRegion</code>.
-   * Never call this method while synchronized on this BucketAdvisor. This will
-   * result in distributed deadlocks.
+   * Never call this method while synchronized on this BucketAdvisor. This will result in
+   * distributed deadlocks.
-    if (this.getDistributionManager().getSystem().isLoner()) { 
-      // no one to send the profile update... return to prevent bug 39760 
-      return; 
-    } 
+    if (this.getDistributionManager().getSystem().isLoner()) {
+      // no one to send the profile update... return to prevent bug 39760
+      return;
+    }
-    Assert.assertTrue( ! Thread.holdsLock(this), 
+    Assert.assertTrue(!Thread.holdsLock(this),
-    
+
-    hostsAndProxyMembers.addAll(adviseProfileUpdate()); // Add all proxy instances that could use the bucket
-    ReplyProcessor21 reply = BucketProfileUpdateMessage.send(hostsAndProxyMembers, getDistributionManager(),
-        partitionedRegionId, bucketId, bp, true);
-    if(reply != null) {
+    hostsAndProxyMembers.addAll(adviseProfileUpdate()); // Add all proxy instances that could use
+                                                        // the bucket
+    ReplyProcessor21 reply = BucketProfileUpdateMessage.send(hostsAndProxyMembers,
+        getDistributionManager(), partitionedRegionId, bucketId, bp, true);
+    if (reply != null) {
-  
-  /** 
-   * Returns true if the a primary is known. 
+
+  /**
+   * Returns true if the a primary is known.
-    synchronized(this) {
-      return this.primaryState == OTHER_PRIMARY_NOT_HOSTING || 
-      this.primaryState == OTHER_PRIMARY_HOSTING ||
-      this.primaryState ==IS_PRIMARY_HOSTING;
+    synchronized (this) {
+      return this.primaryState == OTHER_PRIMARY_NOT_HOSTING
+          || this.primaryState == OTHER_PRIMARY_HOSTING || this.primaryState == IS_PRIMARY_HOSTING;
-  protected Profile instantiateProfile(InternalDistributedMember memberId,
-      int version) {
+  protected Profile instantiateProfile(InternalDistributedMember memberId, int version) {
-        CacheServerImpl server = (CacheServerImpl)object;
+        CacheServerImpl server = (CacheServerImpl) object;
-          BucketServerLocation66 location = new BucketServerLocation66(
-              getBucket().getId(), server.getPort(), server
-                  .getExternalAddress()
-              /* .getExternalAddress(false/ checkServerRunning ) */,
-              getBucket().isPrimary(), Integer.valueOf(version).byteValue(),
-              server.getCombinedGroups());
+          BucketServerLocation66 location = new BucketServerLocation66(getBucket().getId(),
+              server.getPort(), server.getExternalAddress()
+              /* .getExternalAddress(false/ checkServerRunning ) */, getBucket().isPrimary(), Integer.valueOf(version).byteValue(), server.getCombinedGroups());
-        return new ServerBucketProfile(memberId, version, getBucket(),
-            serverLocations);
+        return new ServerBucketProfile(memberId, version, getBucket(), serverLocations);
-  
-  /** 
+
+  /**
-      }
-      else {
+      } else {
-    
-    if(id != null && id.equals(primaryElector)) {
+
+    if (id != null && id.equals(primaryElector)) {
-  
+
-  
+
-  
+
-   * Determine if there has been a change in redundancy and alter the
-   * lowRedundancyBucketCount stat as needed.
+   * Determine if there has been a change in redundancy and alter the lowRedundancyBucketCount stat
+   * as needed.
-   * @return current number of hosts for this bucket 
+   * @return current number of hosts for this bucket
-    int desiredRedundancy = 
-        this.pRegion.getRedundantCopies();
+    int desiredRedundancy = this.pRegion.getRedundantCopies();
-    if (this.redundancySatisfied && 
-        numBucketHosts > 0 &&
-        actualRedundancy < desiredRedundancy) {
+    if (this.redundancySatisfied && numBucketHosts > 0 && actualRedundancy < desiredRedundancy) {
-    }
-    else if (!this.redundancySatisfied &&
-             numBucketHosts > 0 &&
-             actualRedundancy >= desiredRedundancy){
+    } else if (!this.redundancySatisfied && numBucketHosts > 0
+        && actualRedundancy >= desiredRedundancy) {
-  
+
-   * Returns all {@link InternalDistributedMember}s currently
-   * flagged as primary.
+   * Returns all {@link InternalDistributedMember}s currently flagged as primary.
-   * Since profile messages may arrive out of order from different members,
-   * more than one member may temporarily be flagged as primary.
+   * Since profile messages may arrive out of order from different members, more than one member may
+   * temporarily be flagged as primary.
-   * The user of this BucketAdvisor should simply assume that the first
-   * profile is primary until the dust settles, leaving only one primary
-   * profile.
+   * The user of this BucketAdvisor should simply assume that the first profile is primary until the
+   * dust settles, leaving only one primary profile.
-      logger.debug("[findPrimaryProfiles] found the following primary members for {}: {}", getAdvisee().getName(), primaryMembers);
+      logger.debug("[findPrimaryProfiles] found the following primary members for {}: {}",
+          getAdvisee().getName(), primaryMembers);
-    return (InternalDistributedMember[]) primaryMembers.toArray(
-        new InternalDistributedMember[primaryMembers.size()]);
+    return (InternalDistributedMember[]) primaryMembers
+        .toArray(new InternalDistributedMember[primaryMembers.size()]);
-   * Searches through profiles to find first profile that is flagged as 
-   * primary and sets {@link #primaryMember} to it. Caller must synchronize
-   * on this BucketAdvisor.
+   * Searches through profiles to find first profile that is flagged as primary and sets
+   * {@link #primaryMember} to it. Caller must synchronize on this BucketAdvisor.
-    if(isPrimary()) {
+    if (isPrimary()) {
-    }
-    else {
+    } else {
-  
+
-   * Returns the current redundancy of the this bucket, including the locally
-   * hosted bucket if it exists.
+   * Returns the current redundancy of the this bucket, including the locally hosted bucket if it
+   * exists.
-  
+
-    
+
-  
+
-  
+
-   * Get the number of members that are hosting the bucket, and have
-   * finished initialization.
+   * Get the number of members that are hosting the bucket, and have finished initialization.
-   * This method is currently only used to check the bucket
-   * redundancy just before creating the bucket. If it is used
-   * more frequently, it might be better to cache this count.
+   * This method is currently only used to check the bucket redundancy just before creating the
+   * bucket. If it is used more frequently, it might be better to cache this count.
-    for(Profile profile: locProfiles) {
+    for (Profile profile : locProfiles) {
-      if(bucketProfile.isHosting) {
+      if (bucketProfile.isHosting) {
-    if(isHosting()) {
+    if (isHosting()) {
-  
+
-    return (Bucket)getAdvisee();
+    return (Bucket) getAdvisee();
-  
+
-    //We don't have a lock if we have a parent advisor
-    if(parentAdvisor != null) {
+    // We don't have a lock if we have a parent advisor
+    if (parentAdvisor != null) {
-    // TODO fix this method to not release any locks if the  
-    // redundancy is zero, since no locks are grabbed. 
+    // TODO fix this method to not release any locks if the
+    // redundancy is zero, since no locks are grabbed.
-      }
-      else {
+      } else {
-    } 
-    catch (LockNotHeldException e) {      
-      Assert.assertTrue(!isHosting(), 
-          "Got LockNotHeldException for Bucket = " + this);
-    }
-    catch (LockServiceDestroyedException e) {
-      Assert.assertTrue(isClosed(), 
+    } catch (LockNotHeldException e) {
+      Assert.assertTrue(!isHosting(), "Got LockNotHeldException for Bucket = " + this);
+    } catch (LockServiceDestroyedException e) {
+      Assert.assertTrue(isClosed(),
-  
+
+   * 
-  
+
-   * Requests change to the requested primary state. Controls all state
-   * changes pertaining to primary state. Caller must be synchronized on this.
+   * Requests change to the requested primary state. Controls all state changes pertaining to
+   * primary state. Caller must be synchronized on this.
-            throw new IllegalStateException(LocalizedStrings.BucketAdvisor_CANNOT_CHANGE_FROM_0_TO_1.toLocalizedString(new Object[] {this.primaryStateToString(), this.primaryStateToString(requestedState)}));
+            throw new IllegalStateException(LocalizedStrings.BucketAdvisor_CANNOT_CHANGE_FROM_0_TO_1
+                .toLocalizedString(new Object[] {this.primaryStateToString(),
+                    this.primaryStateToString(requestedState)}));
-//          case OTHER_PRIMARY_NOT_HOSTING: -- enable for bucket migration
-//            this.primaryState = requestedState;
-//            break;
+          // case OTHER_PRIMARY_NOT_HOSTING: -- enable for bucket migration
+          // this.primaryState = requestedState;
+          // break;
-            this.primaryState = requestedState;
-            {
-              PartitionedRegionStats stats = getPartitionedRegionStats();
-              stats.putStartTime(this, stats.startVolunteering());
-            }
+            this.primaryState = requestedState; {
+            PartitionedRegionStats stats = getPartitionedRegionStats();
+            stats.putStartTime(this, stats.startVolunteering());
+          }
-            this.primaryState = requestedState;
-            {
-              PartitionedRegionStats stats = getPartitionedRegionStats();
-              stats.putStartTime(this, stats.startVolunteering());
-            }
+            this.primaryState = requestedState; {
+            PartitionedRegionStats stats = getPartitionedRegionStats();
+            stats.putStartTime(this, stats.startVolunteering());
+          }
-            throw new IllegalStateException(LocalizedStrings.BucketAdvisor_CANNOT_CHANGE_FROM_0_TO_1.toLocalizedString(new Object[] {this.primaryStateToString(), this.primaryStateToString(requestedState)}));
+            throw new IllegalStateException(LocalizedStrings.BucketAdvisor_CANNOT_CHANGE_FROM_0_TO_1
+                .toLocalizedString(new Object[] {this.primaryStateToString(),
+                    this.primaryStateToString(requestedState)}));
-            throw new IllegalStateException(LocalizedStrings.BucketAdvisor_CANNOT_CHANGE_FROM_0_TO_1.toLocalizedString(new Object[] {this.primaryStateToString(), this.primaryStateToString(requestedState)}));
+            throw new IllegalStateException(LocalizedStrings.BucketAdvisor_CANNOT_CHANGE_FROM_0_TO_1
+                .toLocalizedString(new Object[] {this.primaryStateToString(),
+                    this.primaryStateToString(requestedState)}));
-//          case NO_PRIMARY_NOT_HOSTING: -- enable for bucket migration
-//            this.primaryState = requestedState;
-//            break;
+          // case NO_PRIMARY_NOT_HOSTING: -- enable for bucket migration
+          // this.primaryState = requestedState;
+          // break;
-            this.primaryState = requestedState;
-            {
-              PartitionedRegionStats stats = getPartitionedRegionStats();
-              stats.putStartTime(this, stats.startVolunteering());
-            }
+            this.primaryState = requestedState; {
+            PartitionedRegionStats stats = getPartitionedRegionStats();
+            stats.putStartTime(this, stats.startVolunteering());
+          }
-            // race condition ok, probably race in HA where other becomes 
+            // race condition ok, probably race in HA where other becomes
-            throw new IllegalStateException(LocalizedStrings.BucketAdvisor_CANNOT_CHANGE_FROM_0_TO_1.toLocalizedString(new Object[] {this.primaryStateToString(), this.primaryStateToString(requestedState)}));
+            throw new IllegalStateException(LocalizedStrings.BucketAdvisor_CANNOT_CHANGE_FROM_0_TO_1
+                .toLocalizedString(new Object[] {this.primaryStateToString(),
+                    this.primaryStateToString(requestedState)}));
-            this.primaryState = requestedState;
-            {
-              PartitionedRegionStats stats = getPartitionedRegionStats();
-              stats.endVolunteeringClosed(stats.removeStartTime(this));
-            }
+            this.primaryState = requestedState; {
+            PartitionedRegionStats stats = getPartitionedRegionStats();
+            stats.endVolunteeringClosed(stats.removeStartTime(this));
+          }
-            this.primaryState = requestedState;
-            {
-              PartitionedRegionStats stats = getPartitionedRegionStats();
-              stats.endVolunteeringClosed(stats.removeStartTime(this));
-            }
+            this.primaryState = requestedState; {
+            PartitionedRegionStats stats = getPartitionedRegionStats();
+            stats.endVolunteeringClosed(stats.removeStartTime(this));
+          }
-            this.primaryState = requestedState;
-            {
-              PartitionedRegionStats stats = getPartitionedRegionStats();
-              stats.incPrimaryBucketCount(1);
-              stats.endVolunteeringBecamePrimary(stats.removeStartTime(this));
-            }
+            this.primaryState = requestedState; {
+            PartitionedRegionStats stats = getPartitionedRegionStats();
+            stats.incPrimaryBucketCount(1);
+            stats.endVolunteeringBecamePrimary(stats.removeStartTime(this));
+          }
-            this.primaryState = requestedState;
-            {
-              PartitionedRegionStats stats = getPartitionedRegionStats();
-              stats.endVolunteeringOtherPrimary(stats.removeStartTime(this));
-            }
+            this.primaryState = requestedState; {
+            PartitionedRegionStats stats = getPartitionedRegionStats();
+            stats.endVolunteeringOtherPrimary(stats.removeStartTime(this));
+          }
-            this.primaryState = requestedState;
-            {
-              PartitionedRegionStats stats = getPartitionedRegionStats();
-              stats.endVolunteeringClosed(stats.removeStartTime(this));
-            }
+            this.primaryState = requestedState; {
+            PartitionedRegionStats stats = getPartitionedRegionStats();
+            stats.endVolunteeringClosed(stats.removeStartTime(this));
+          }
-            throw new IllegalStateException(LocalizedStrings.BucketAdvisor_CANNOT_CHANGE_FROM_0_TO_1.toLocalizedString(new Object[] {this.primaryStateToString(), this.primaryStateToString(requestedState)}));
+            throw new IllegalStateException(LocalizedStrings.BucketAdvisor_CANNOT_CHANGE_FROM_0_TO_1
+                .toLocalizedString(new Object[] {this.primaryStateToString(),
+                    this.primaryStateToString(requestedState)}));
-            this.primaryState = requestedState;
-            {
-              PartitionedRegionStats stats = getPartitionedRegionStats();
-              stats.endVolunteeringClosed(stats.removeStartTime(this));
-            }
+            this.primaryState = requestedState; {
+            PartitionedRegionStats stats = getPartitionedRegionStats();
+            stats.endVolunteeringClosed(stats.removeStartTime(this));
+          }
-            this.primaryState = requestedState;
-            {
-              PartitionedRegionStats stats = getPartitionedRegionStats();
-              stats.endVolunteeringClosed(stats.removeStartTime(this));
-            }
+            this.primaryState = requestedState; {
+            PartitionedRegionStats stats = getPartitionedRegionStats();
+            stats.endVolunteeringClosed(stats.removeStartTime(this));
+          }
-            this.primaryState = requestedState;
-            {
-              PartitionedRegionStats stats = getPartitionedRegionStats();
-              stats.incPrimaryBucketCount(1);
-              stats.endVolunteeringBecamePrimary(stats.removeStartTime(this));
-            }
+            this.primaryState = requestedState; {
+            PartitionedRegionStats stats = getPartitionedRegionStats();
+            stats.incPrimaryBucketCount(1);
+            stats.endVolunteeringBecamePrimary(stats.removeStartTime(this));
+          }
-            this.primaryState = requestedState;
-            {
-              PartitionedRegionStats stats = getPartitionedRegionStats();
-              stats.endVolunteeringClosed(stats.removeStartTime(this));
-            }
+            this.primaryState = requestedState; {
+            PartitionedRegionStats stats = getPartitionedRegionStats();
+            stats.endVolunteeringClosed(stats.removeStartTime(this));
+          }
-            throw new IllegalStateException(LocalizedStrings.BucketAdvisor_CANNOT_CHANGE_FROM_0_TO_1.toLocalizedString(new Object[] {this.primaryStateToString(), this.primaryStateToString(requestedState)}));
+            throw new IllegalStateException(LocalizedStrings.BucketAdvisor_CANNOT_CHANGE_FROM_0_TO_1
+                .toLocalizedString(new Object[] {this.primaryStateToString(),
+                    this.primaryStateToString(requestedState)}));
-//          case OTHER_PRIMARY_HOSTING: -- enable for bucket migration
-//            // rebalancing must have moved the primary
-//            changeFromPrimaryTo(requestedState);
-//            break;
+          // case OTHER_PRIMARY_HOSTING: -- enable for bucket migration
+          // // rebalancing must have moved the primary
+          // changeFromPrimaryTo(requestedState);
+          // break;
-            throw new IllegalStateException(
-                "Cannot change from " + this.primaryStateToString() + 
-                " to " + this.primaryStateToString(requestedState));
+            throw new IllegalStateException("Cannot change from " + this.primaryStateToString()
+                + " to " + this.primaryStateToString(requestedState));
-            Exception e = new Exception(LocalizedStrings.BucketAdvisor_ATTEMPTED_TO_CLOSE_BUCKETADVISOR_THAT_IS_ALREADY_CLOSED.toLocalizedString());
-            logger.warn(LocalizedMessage.create(LocalizedStrings.BucketAdvisor_ATTEMPTED_TO_CLOSE_BUCKETADVISOR_THAT_IS_ALREADY_CLOSED), e);
+            Exception e = new Exception(
+                LocalizedStrings.BucketAdvisor_ATTEMPTED_TO_CLOSE_BUCKETADVISOR_THAT_IS_ALREADY_CLOSED
+                    .toLocalizedString());
+            logger.warn(
+                LocalizedMessage.create(
+                    LocalizedStrings.BucketAdvisor_ATTEMPTED_TO_CLOSE_BUCKETADVISOR_THAT_IS_ALREADY_CLOSED),
+                e);
-            throw new IllegalStateException(LocalizedStrings.BucketAdvisor_CANNOT_CHANGE_FROM_0_TO_1_FOR_BUCKET_2.toLocalizedString(new Object[] {this.primaryStateToString(), this.primaryStateToString(requestedState), getAdvisee().getName()}));
+            throw new IllegalStateException(
+                LocalizedStrings.BucketAdvisor_CANNOT_CHANGE_FROM_0_TO_1_FOR_BUCKET_2
+                    .toLocalizedString(new Object[] {this.primaryStateToString(),
+                        this.primaryStateToString(requestedState), getAdvisee().getName()}));
-    }
-    finally {
+    } finally {
-  
+
-    // destroyed.  This is needed when bucket cleanup is performed
+    // destroyed. This is needed when bucket cleanup is performed
-  
+
-   * returns the set of all the members in the system which require both
-   * DistributedCacheOperation messages and notification-only partition
-   * messages
+   * returns the set of all the members in the system which require both DistributedCacheOperation
+   * messages and notification-only partition messages
+   * 
-  
+
-        CacheProfile cp = (CacheProfile)profile;
+        CacheProfile cp = (CacheProfile) profile;
-	return this.regionAdvisor.adviseNetWrite();
+    return this.regionAdvisor.adviseNetWrite();
-    //String identity = super.toString();
-    //String identity = "BucketAdvisor " + getAdvisee().getFullPath() + 
-    //    ":" + getAdvisee().getSerialNumber();
-    //identity = identity.substring(identity.lastIndexOf(".")+1);
-    //final StringBuffer sb = new StringBuffer("[" + identity + ": ");
-    final StringBuilder sb = new StringBuilder("[BucketAdvisor ")
-        .append(getAdvisee().getFullPath()).append(':')
-        .append(getAdvisee().getSerialNumber()).append(": ");
+    // String identity = super.toString();
+    // String identity = "BucketAdvisor " + getAdvisee().getFullPath() +
+    // ":" + getAdvisee().getSerialNumber();
+    // identity = identity.substring(identity.lastIndexOf(".")+1);
+    // final StringBuffer sb = new StringBuffer("[" + identity + ": ");
+    final StringBuilder sb = new StringBuilder("[BucketAdvisor ").append(getAdvisee().getFullPath())
+        .append(':').append(getAdvisee().getSerialNumber()).append(": ");
-  //A listener for events on this bucket, and also for the entire PR
+  // A listener for events on this bucket, and also for the entire PR
-  
+
-  
+
-   * Called from endBucket creation. We send
-   * out a profile to notify others that the 
-   * persistence is initialized.
+   * Called from endBucket creation. We send out a profile to notify others that the persistence is
+   * initialized.
-  
+
-    /** True if the profile is coming from a real BucketRegion 
-     * acceptible states
-     *  hosting = false, init = true
-     *  hosting = true, init = false
-     *  hosting = false, init = false
-     * unacceptible states
-     *  hosting = true, init = true
+    /**
+     * True if the profile is coming from a real BucketRegion acceptible states hosting = false,
+     * init = true hosting = true, init = false hosting = false, init = false unacceptible states
+     * hosting = true, init = true
-    
-    
+
+
-  
-    public BucketProfile() {
-    }
-    public BucketProfile(InternalDistributedMember memberId, int version, 
-        Bucket bucket) {
+    public BucketProfile() {}
+
+    public BucketProfile(InternalDistributedMember memberId, int version, Bucket bucket) {
-    
+
-    
+
-    
+
-    public ServerBucketProfile() {
-    }
+    public ServerBucketProfile() {}
-    public ServerBucketProfile(InternalDistributedMember memberId, int version,
-        Bucket bucket, HashSet<BucketServerLocation66> serverLocations) {
+    public ServerBucketProfile(InternalDistributedMember memberId, int version, Bucket bucket,
+        HashSet<BucketServerLocation66> serverLocations) {
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      this.bucketId=DataSerializer.readPrimitiveInt(in);
+      this.bucketId = DataSerializer.readPrimitiveInt(in);
-      DataSerializer.writePrimitiveInt(this.bucketId,out);
+      DataSerializer.writePrimitiveInt(this.bucketId, out);
-      BucketServerLocation66 sl = (BucketServerLocation66)bucketServerLocations.toArray()[0];
+      BucketServerLocation66 sl = (BucketServerLocation66) bucketServerLocations.toArray()[0];
-      final ServerBucketProfile other = (ServerBucketProfile)obj;
+      final ServerBucketProfile other = (ServerBucketProfile) obj;
-  
+
-   * Handles the actual volunteering to become primary bucket. Ensures that
-   * only one thread is ever volunteering at one time.
+   * Handles the actual volunteering to become primary bucket. Ensures that only one thread is ever
+   * volunteering at one time.
-  class VolunteeringDelegate  {
-    /** 
+  class VolunteeringDelegate {
+    /**
-     * synchronized(volunteeringLock). 
+     * synchronized(volunteeringLock).
-    
+
-    
+
-     * Returns true if this delegate is aggressively trying to become the
-     * primary even if another member is already the primary.
+     * Returns true if this delegate is aggressively trying to become the primary even if another
+     * member is already the primary.
-      synchronized(BucketAdvisor.this) {
+      synchronized (BucketAdvisor.this) {
-    
+
-     * Initiates volunteering for primary. Repeated calls are harmless. Invoked
-     * by the BucketAdvisor. Caller must be synchronized on BucketAdvisor.
+     * Initiates volunteering for primary. Repeated calls are harmless. Invoked by the
+     * BucketAdvisor. Caller must be synchronized on BucketAdvisor.
-	getAdvisee().getCancelCriterion().checkCancelInProgress(null);
+        getAdvisee().getCancelCriterion().checkCancelInProgress(null);
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-        }
-        finally {
+        } finally {
-    
+
-     * Reserves this delegate for the current thread to call becomePrimary.
-     * Necessary because caller of doVolunteerForPrimary must not be 
-     * synchronized on BucketAdvisor.
+     * Reserves this delegate for the current thread to call becomePrimary. Necessary because caller
+     * of doVolunteerForPrimary must not be synchronized on BucketAdvisor.
-          //Fix  for 41865 - We can't send out profiles while holding the
-          //sync on this advisor, because that will cause a deadlock.
-          //Holding the activePrimaryMoveLock here instead prevents any
-          //operations from being performed on this primary until the child regions
-          //are synced up. It also prevents a depose from happening until then.
+          // Fix for 41865 - We can't send out profiles while holding the
+          // sync on this advisor, because that will cause a deadlock.
+          // Holding the activePrimaryMoveLock here instead prevents any
+          // operations from being performed on this primary until the child regions
+          // are synced up. It also prevents a depose from happening until then.
-            //Check our parent advisor and set our state
-            //accordingly
+            // Check our parent advisor and set our state
+            // accordingly
-              //Fix for 44350 - we don't want to get a primary move lock on
-              //the advisor, becuase that might deadlock with a user thread.
-              //However, since all depose/elect operations on the parent bucket
-              //cascade to the child bucket and get the child bucket move lock,
-              //if should be safe to check this without the lock here.
+              // Fix for 44350 - we don't want to get a primary move lock on
+              // the advisor, becuase that might deadlock with a user thread.
+              // However, since all depose/elect operations on the parent bucket
+              // cascade to the child bucket and get the child bucket move lock,
+              // if should be safe to check this without the lock here.
-            }
-            else { 
+            } else {
-                  }
-                  else {
+                  } else {
-              }
-              else {
+              } else {
-                  acquiredLock = thePrimaryLock.tryLock(Long.MAX_VALUE,
-                      TimeUnit.MILLISECONDS);
-                }
-                else {
+                  acquiredLock = thePrimaryLock.tryLock(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
+                } else {
-              // Here if somehow a bucket can't acquire a lock 
-              // we assume that it is in the process of becoming primary through 
+              // Here if somehow a bucket can't acquire a lock
+              // we assume that it is in the process of becoming primary through
-              // Either way we have to guarantee that the bucket becomes primary for sure.(How to guarantee?)
+              // Either way we have to guarantee that the bucket becomes primary for sure.(How to
+              // guarantee?)
-          
+
-          
+
-      }
-      catch (LockServiceDestroyedException e) {
+      } catch (LockServiceDestroyedException e) {
-      }
-      catch (RegionDestroyedException e) {
+      } catch (RegionDestroyedException e) {
-      }
-      catch (CancelException e) {
+      } catch (CancelException e) {
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {
-      }
-      finally {
+      } finally {
-          logger.debug("Exit volunteerForPrimary for {}; dlsDestroyed={}", BucketAdvisor.this, dlsDestroyed);
+          logger.debug("Exit volunteerForPrimary for {}; dlsDestroyed={}", BucketAdvisor.this,
+              dlsDestroyed);
-//        if (isPrimary()) {
-//          Bucket bucket = getBucket();
-//          if (bucket instanceof ProxyBucketRegion) {
-//            bucket = ((ProxyBucketRegion)bucket).getHostedBucketRegion();
-//          }
-//        }
+        // if (isPrimary()) {
+        // Bucket bucket = getBucket();
+        // if (bucket instanceof ProxyBucketRegion) {
+        // bucket = ((ProxyBucketRegion)bucket).getHostedBucketRegion();
+        // }
+        // }
-    
+
-     * Called from catch blocks in {@link #doVolunteerForPrimary()}. Handles
-     * the exception properly based on advisor settings and shutdown condition.
+     * Called from catch blocks in {@link #doVolunteerForPrimary()}. Handles the exception properly
+     * based on advisor settings and shutdown condition.
-     * @param loggit true if message should be logged if shutdown condition 
-     * is not met
+     * @param loggit true if message should be logged if shutdown condition is not met
-          Assert.assertTrue(safe, LocalizedStrings.BucketAdvisor_BUCKETADVISOR_WAS_NOT_CLOSED_PROPERLY.toLocalizedString());
-        }
-        else if (loggit) {
-          logger.warn(LocalizedMessage.create(LocalizedStrings.BucketAdvisor_BUCKETADVISOR_WAS_NOT_CLOSED_PROPERLY), e);
+          Assert.assertTrue(safe,
+              LocalizedStrings.BucketAdvisor_BUCKETADVISOR_WAS_NOT_CLOSED_PROPERLY
+                  .toLocalizedString());
+        } else if (loggit) {
+          logger.warn(LocalizedMessage
+              .create(LocalizedStrings.BucketAdvisor_BUCKETADVISOR_WAS_NOT_CLOSED_PROPERLY), e);
-    
+
-        }
-        finally {
+        } finally {
-    
+
-        
+
-    
+
-    
+
-          if (basicGetPrimaryMember() == null ) {
-            findAndSetPrimaryMember(); 
+          if (basicGetPrimaryMember() == null) {
+            findAndSetPrimaryMember();
-        }               
+        }
-    
+
-     * {@link BucketAdvisor#getVolunteeringQueue()}. A number of threads
-     * equal to {@link RegionAdvisor#VOLUNTEERING_THREAD_COUNT} are permitted
-     * to consume from the queue by acquiring permits from {@link 
-     * BucketAdvisor#getVolunteeringSemaphore()}.
+     * {@link BucketAdvisor#getVolunteeringQueue()}. A number of threads equal to
+     * {@link RegionAdvisor#VOLUNTEERING_THREAD_COUNT} are permitted to consume from the queue by
+     * acquiring permits from {@link BucketAdvisor#getVolunteeringSemaphore()}.
-     * @param volunteeringTask the task to queue and then execute in waiting 
-     * thread pool
+     * @param volunteeringTask the task to queue and then execute in waiting thread pool
-      // VOLUNTEERING_THREAD_COUNT. 
-      if (Thread.interrupted()) throw new InterruptedException();
+      // VOLUNTEERING_THREAD_COUNT.
+      if (Thread.interrupted())
+        throw new InterruptedException();
-        // add the volunteering task 
+        // add the volunteering task
-          }
-          finally {
+          } finally {
-    
+
-     * Returns the runnable used to consume the volunteering queue. The
-     * executing thread(s) will consume from the queue until it is empty.
+     * Returns the runnable used to consume the volunteering queue. The executing thread(s) will
+     * consume from the queue until it is empty.
-//              SystemFailure.checkFailure(); 
+              // SystemFailure.checkFailure();
-                // synchronized volunteeringQueue for coordination between threads adding 
+                // synchronized volunteeringQueue for coordination between threads adding
-                  //  we could just let the finally block do it.
+                  // we could just let the finally block do it.
-              }
-              catch (CancelException e) {
+              } catch (CancelException e) {
-              }
-              catch (RuntimeException e) {
+              } catch (RuntimeException e) {
-          }
-          finally {
+          } finally {
-  
+

INS29 MOV29 INS66 UPD66 INS66 UPD66 INS65 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
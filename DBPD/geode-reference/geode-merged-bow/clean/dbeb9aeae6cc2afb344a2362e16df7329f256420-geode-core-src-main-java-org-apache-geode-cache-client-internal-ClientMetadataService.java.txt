Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import org.apache.geode.cache.*;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.EntryOperation;
+import org.apache.geode.cache.FixedPartitionResolver;
+import org.apache.geode.cache.Operation;
+import org.apache.geode.cache.PartitionResolver;
+import org.apache.geode.cache.Region;
-import org.apache.geode.internal.cache.*;
+import org.apache.geode.internal.cache.BucketServerLocation66;
+import org.apache.geode.internal.cache.EntryOperationImpl;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.PartitionedRegion;
+import org.apache.geode.internal.cache.PartitionedRegionHelper;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Set;
- * Maintains {@link ClientPartitionAdvisor} for Partitioned Regions on servers
- * Client operations will consult this service to identify the server locations
- * on which the data for the client operation is residing
- * 
+ * Maintains {@link ClientPartitionAdvisor} for Partitioned Regions on servers Client operations
+ * will consult this service to identify the server locations on which the data for the client
+ * operation is residing
- * 
-  
+
-  
+
-  private boolean HONOUR_SERVER_GROUP_IN_PR_SINGLE_HOP = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.honourServerGroupsInPRSingleHop");
+  private boolean HONOUR_SERVER_GROUP_IN_PR_SINGLE_HOP = Boolean
+      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.honourServerGroupsInPRSingleHop");
-  
+
-  
-  /** random number generator used in pruning */
+
+  /**
+   * random number generator used in pruning
+   */
-  
+
-  
+
-  
+
-  
+
-  
+
-  private final Map<String, ClientPartitionAdvisor> clientPRAdvisors = new ConcurrentHashMap<String, ClientPartitionAdvisor>();
-  private final Map<String, Set<ClientPartitionAdvisor>> colocatedPRAdvisors = new ConcurrentHashMap<String, Set<ClientPartitionAdvisor>>();
-  
-  private PartitionResolver getResolver(Region r, Object key,
-      Object callbackArgument) {
+  private final Map<String, ClientPartitionAdvisor> clientPRAdvisors =
+      new ConcurrentHashMap<String, ClientPartitionAdvisor>();
+  private final Map<String, Set<ClientPartitionAdvisor>> colocatedPRAdvisors =
+      new ConcurrentHashMap<String, Set<ClientPartitionAdvisor>>();
+
+  private PartitionResolver getResolver(Region r, Object key, Object callbackArgument) {
-    ClientPartitionAdvisor advisor = this
-        .getClientPartitionAdvisor(regionFullPath);
+    ClientPartitionAdvisor advisor = this.getClientPartitionAdvisor(regionFullPath);
-    
+
-      return (PartitionResolver)key;
+      return (PartitionResolver) key;
-    if (callbackArgument != null
-        && callbackArgument instanceof PartitionResolver) {
-      return (PartitionResolver)callbackArgument;
+    if (callbackArgument != null && callbackArgument instanceof PartitionResolver) {
+      return (PartitionResolver) callbackArgument;
-  public ServerLocation getBucketServerLocation(Region region,
-      Operation operation, Object key, Object value, Object callbackArg) {
-    ClientPartitionAdvisor prAdvisor  = this.getClientPartitionAdvisor(region.getFullPath());
+  public ServerLocation getBucketServerLocation(Region region, Operation operation, Object key,
+      Object value, Object callbackArg) {
+    ClientPartitionAdvisor prAdvisor = this.getClientPartitionAdvisor(region.getFullPath());
-    }
-    else {
-      entryOp = new EntryOperationImpl(region, operation, key,
-          value, callbackArg);
+    } else {
+      entryOp = new EntryOperationImpl(region, operation, key, value, callbackArg);
-        entryOp = new EntryOperationImpl(region,
-            Operation.FUNCTION_EXECUTION, key, null, null);
+        entryOp = new EntryOperationImpl(region, Operation.FUNCTION_EXECUTION, key, null, null);
-      String partition = ((FixedPartitionResolver)resolver).getPartitionName(
-          entryOp, prAdvisor.getFixedPartitionNames());
+      String partition = ((FixedPartitionResolver) resolver).getPartitionName(entryOp,
+          prAdvisor.getFixedPartitionNames());
-        Object[] prms = new Object[] { region.getName(), resolver };
+        Object[] prms = new Object[] {region.getName(), resolver};
-      }
-      else {
+      } else {
-    }else {
+    } else {
-    
-    ServerLocation bucketServerLocation = getServerLocation(region, operation,
-        bucketId);
+
+    ServerLocation bucketServerLocation = getServerLocation(region, operation, bucketId);
-    if (bucketServerLocation != null)
-      location = new ServerLocation(bucketServerLocation.getHostName(),
-          bucketServerLocation.getPort());
+    if (bucketServerLocation != null) {
+      location =
+          new ServerLocation(bucketServerLocation.getHostName(), bucketServerLocation.getPort());
+    }
-  private ServerLocation getServerLocation(Region region, Operation operation,
-      int bucketId) {
+  private ServerLocation getServerLocation(Region region, Operation operation, int bucketId) {
-        logger.debug("ClientMetadataService#getServerLocation : Region {} prAdvisor does not exist.", regionFullPath);
+        logger.debug(
+            "ClientMetadataService#getServerLocation : Region {} prAdvisor does not exist.",
+            regionFullPath);
-    
-//    if (prAdvisor.getColocatedWith() != null) {
-//      prAdvisor = this.getClientPartitionAdvisor(prAdvisor.getColocatedWith());
-//      if (prAdvisor == null) {
-//        if (this.logger.fineEnabled()) {
-//          this.logger.fine(
-//              "ClientMetadataService#getServerLocation : Region "
-//                  + regionFullPath + "prAdvisor does not exist.");
-//        }
-//        return null;
-//      }
-//    }
-    
+
-    }
-    else {
+    } else {
-  public Map<ServerLocation, HashSet> getServerToFilterMap(
-	      final Collection routingKeys, final Region region, boolean primaryMembersNeeded
-	     ) {
-	  return getServerToFilterMap(routingKeys, region, primaryMembersNeeded, false);
+  public Map<ServerLocation, HashSet> getServerToFilterMap(final Collection routingKeys,
+      final Region region, boolean primaryMembersNeeded) {
+    return getServerToFilterMap(routingKeys, region, primaryMembersNeeded, false);
-  
-  public Map<ServerLocation, HashSet> getServerToFilterMap(
-      final Collection routingKeys, final Region region, boolean primaryMembersNeeded,
-      boolean bucketsAsFilter) {
+
+  public Map<ServerLocation, HashSet> getServerToFilterMap(final Collection routingKeys,
+      final Region region, boolean primaryMembersNeeded, boolean bucketsAsFilter) {
-      scheduleGetPRMetaData((LocalRegion)region, false);
+      scheduleGetPRMetaData((LocalRegion) region, false);
-    HashMap<Integer, HashSet> bucketToKeysMap = groupByBucketOnClientSide(
-        region, prAdvisor, routingKeys, bucketsAsFilter);
+    HashMap<Integer, HashSet> bucketToKeysMap =
+        groupByBucketOnClientSide(region, prAdvisor, routingKeys, bucketsAsFilter);
-    HashMap<ServerLocation, HashSet<Integer>> serverToBuckets = groupByServerToBuckets(
-        prAdvisor, bucketToKeysMap.keySet(), primaryMembersNeeded);
-    
-    if(serverToBuckets == null){
+    HashMap<ServerLocation, HashSet<Integer>> serverToBuckets =
+        groupByServerToBuckets(prAdvisor, bucketToKeysMap.keySet(), primaryMembersNeeded);
+
+    if (serverToBuckets == null) {
-    
+
-      ServerLocation server = (ServerLocation)entry.getKey();
-      HashSet<Integer> buckets = (HashSet)entry.getValue();
+      ServerLocation server = (ServerLocation) entry.getKey();
+      HashSet<Integer> buckets = (HashSet) entry.getValue();
-        LinkedHashSet keys = (LinkedHashSet)serverToKeysMap.get(server);
+        LinkedHashSet keys = (LinkedHashSet) serverToKeysMap.get(server);
-  
-  public HashMap<ServerLocation, HashSet<Integer>> groupByServerToAllBuckets(Region region, boolean primaryOnly){
+
+  public HashMap<ServerLocation, HashSet<Integer>> groupByServerToAllBuckets(Region region,
+      boolean primaryOnly) {
-      scheduleGetPRMetaData((LocalRegion)region, false);
+      scheduleGetPRMetaData((LocalRegion) region, false);
-    for(int i =0; i < totalNumberOfBuckets; i++){
+    for (int i = 0; i < totalNumberOfBuckets; i++) {
+
-   * This function should make a map of server to buckets it is hosting.
-   * If for some bucket servers are not available due to mismatch in metadata
-   * it should fill up a random server for it.
+   * This function should make a map of server to buckets it is hosting. If for some bucket servers
+   * are not available due to mismatch in metadata it should fill up a random server for it.
-      ClientPartitionAdvisor prAdvisor, Set<Integer> bucketSet,
-      boolean primaryOnly) {
+      ClientPartitionAdvisor prAdvisor, Set<Integer> bucketSet, boolean primaryOnly) {
-      HashMap<ServerLocation, HashSet<Integer>> serverToBucketsMap = new HashMap<ServerLocation, HashSet<Integer>>();
+      HashMap<ServerLocation, HashSet<Integer>> serverToBucketsMap =
+          new HashMap<ServerLocation, HashSet<Integer>>();
-          //If we don't have the metadata for some buckets, return
-          //null, indicating that we don't have any metadata. This
-          //will cause us to use the non-single hop path.
+          // If we don't have the metadata for some buckets, return
+          // null, indicating that we don't have any metadata. This
+          // will cause us to use the non-single hop path.
-    }
-    else {
+    } else {
-  
-  
-  private HashMap<ServerLocation, HashSet<Integer>> pruneNodes(
-      ClientPartitionAdvisor prAdvisor, Set<Integer> buckets) {
-    
+
+
+  private HashMap<ServerLocation, HashSet<Integer>> pruneNodes(ClientPartitionAdvisor prAdvisor,
+      Set<Integer> buckets) {
+
-    HashMap<ServerLocation, HashSet<Integer>> serverToBucketsMap = new HashMap<ServerLocation, HashSet<Integer>>();
-    HashMap<ServerLocation, HashSet<Integer>> prunedServerToBucketsMap = new HashMap<ServerLocation, HashSet<Integer>>();
+    HashMap<ServerLocation, HashSet<Integer>> serverToBucketsMap =
+        new HashMap<ServerLocation, HashSet<Integer>>();
+    HashMap<ServerLocation, HashSet<Integer>> prunedServerToBucketsMap =
+        new HashMap<ServerLocation, HashSet<Integer>>();
-      List<BucketServerLocation66> serversList = prAdvisor
-          .adviseServerLocations(bucketId);
+      List<BucketServerLocation66> serversList = prAdvisor.adviseServerLocations(bucketId);
-        logger.debug("ClientMetadataService: For bucketId {} the server list is {}", bucketId, serversList);
+        logger.debug("ClientMetadataService: For bucketId {} the server list is {}", bucketId,
+            serversList);
-        //If we don't have the metadata for some buckets, return
-        //null, indicating that we don't have any metadata. This
-        //will cause us to use the non-single hop path.
+        // If we don't have the metadata for some buckets, return
+        // null, indicating that we don't have any metadata. This
+        // will cause us to use the non-single hop path.
-      
+
-        logger.debug("ClientMetadataService: The buckets owners of the bucket: {} are: {}", bucketId, serversList);
+        logger.debug("ClientMetadataService: The buckets owners of the bucket: {} are: {}",
+            bucketId, serversList);
-      
+
-        }
-        else {
+        } else {
-    }
-    else {
+    } else {
-      randomFirstServer = (ServerLocation)serverToBucketsMap.keySet().toArray()[rand.nextInt(size)];
+      randomFirstServer =
+          (ServerLocation) serverToBucketsMap.keySet().toArray()[rand.nextInt(size)];
-      logger.debug("ClientMetadataService: Adding the server : {} which is random and buckets {} to prunedMap", randomFirstServer, bucketSet);
+      logger.debug(
+          "ClientMetadataService: Adding the server : {} which is random and buckets {} to prunedMap",
+          randomFirstServer, bucketSet);
-      ServerLocation server = findNextServer(serverToBucketsMap.entrySet(),
-          currentBucketSet);
+      ServerLocation server = findNextServer(serverToBucketsMap.entrySet(), currentBucketSet);
-//        HashSet<Integer> rBuckets = prunedServerToBucketsMap
-//            .get(randomFirstServer);
-//        HashSet<Integer> remainingBuckets = new HashSet<Integer>(buckets);
-//        remainingBuckets.removeAll(currentBucketSet);
-//        rBuckets.addAll(remainingBuckets);
-//        prunedServerToBucketsMap.put(randomFirstServer, rBuckets);
+        // HashSet<Integer> rBuckets = prunedServerToBucketsMap
+        // .get(randomFirstServer);
+        // HashSet<Integer> remainingBuckets = new HashSet<Integer>(buckets);
+        // remainingBuckets.removeAll(currentBucketSet);
+        // rBuckets.addAll(remainingBuckets);
+        // prunedServerToBucketsMap.put(randomFirstServer, rBuckets);
-      
+
-      if(bucketSet2.isEmpty()) {
+      if (bucketSet2.isEmpty()) {
-        logger.debug("ClientMetadataService: Adding the server : {} and buckets {} to prunedServer.", server, bucketSet2);
+        logger.debug(
+            "ClientMetadataService: Adding the server : {} and buckets {} to prunedServer.", server,
+            bucketSet2);
-    
+
-      logger.debug("ClientMetadataService: The final prunedServerToBucket calculated is : {}", prunedServerToBucketsMap);
+      logger.debug("ClientMetadataService: The final prunedServerToBucket calculated is : {}",
+          prunedServerToBucketsMap);
-    
+
-  
-  
-  private ServerLocation findNextServer(
-      Set<Map.Entry<ServerLocation, HashSet<Integer>>> entrySet,
+
+
+  private ServerLocation findNextServer(Set<Map.Entry<ServerLocation, HashSet<Integer>>> entrySet,
-   
+
-    ArrayList<ServerLocation> nodesOfEqualSize = new ArrayList<ServerLocation>(); 
+    ArrayList<ServerLocation> nodesOfEqualSize = new ArrayList<ServerLocation>();
-      }
-      else if (max == buckets.size()){
+      } else if (max == buckets.size()) {
-    
-    //return node;
+
+    // return node;
-    if(nodesOfEqualSize.size() > 0)
+    if (nodesOfEqualSize.size() > 0) {
-    
-    return null; 
+    }
+
+    return null;
-  
+
-    
+
-      Object key = i.next();      
-      int bucketId = bucketsAsFilter ? ((Integer)key).intValue() :
-        extractBucketID(region, prAdvisor, totalNumberOfBuckets, key);
+      Object key = i.next();
+      int bucketId = bucketsAsFilter ? ((Integer) key).intValue()
+          : extractBucketID(region, prAdvisor, totalNumberOfBuckets, key);
-    }
-    else {
-      entryOp = new EntryOperationImpl(region,
-          Operation.FUNCTION_EXECUTION, key, null, null);
+    } else {
+      entryOp = new EntryOperationImpl(region, Operation.FUNCTION_EXECUTION, key, null, null);
-   
+
-        entryOp = new EntryOperationImpl(region,
-            Operation.FUNCTION_EXECUTION, key, null, null);
+        entryOp = new EntryOperationImpl(region, Operation.FUNCTION_EXECUTION, key, null, null);
-      String partition = ((FixedPartitionResolver)resolver).getPartitionName(
-          entryOp, prAdvisor.getFixedPartitionNames());
+      String partition = ((FixedPartitionResolver) resolver).getPartitionName(entryOp,
+          prAdvisor.getFixedPartitionNames());
-        Object[] prms = new Object[] { region.getName(), resolver };
+        Object[] prms = new Object[] {region.getName(), resolver};
-      }
-      else {
-        bucketId =  prAdvisor.assignFixedBucketId(region, partition, resolveKey);
-        // This bucketid can be -1 in some circumstances where we don't have information about 
+      } else {
+        bucketId = prAdvisor.assignFixedBucketId(region, partition, resolveKey);
+        // This bucketid can be -1 in some circumstances where we don't have information about
-        if(bucketId == -1) {
-          scheduleGetPRMetaData((LocalRegion)region, true);
+        if (bucketId == -1) {
+          scheduleGetPRMetaData((LocalRegion) region, true);
-    }else{
+    } else {
-  
-  
-  public void scheduleGetPRMetaData(final LocalRegion region,
-      final boolean isRecursive) {
-    if(this.nonPRs.contains(region.getFullPath())){
+
+  public void scheduleGetPRMetaData(final LocalRegion region, final boolean isRecursive) {
+    if (this.nonPRs.contains(region.getFullPath())) {
-    region.getCachePerfStats().incNonSingleHopsCount();
-      }
-      catch (VirtualMachineError e) {
+      } catch (VirtualMachineError e) {
-      }
-      catch (Throwable e) {
+      } catch (Throwable e) {
-    }
-    else {
-      synchronized (fetchTaskCountLock){
+    } else {
+      synchronized (fetchTaskCountLock) {
-          }
-          catch (VirtualMachineError e) {
+          } catch (VirtualMachineError e) {
-          }
-          catch (Throwable e) {
+          } catch (Throwable e) {
-          }
-          finally {
-            synchronized (fetchTaskCountLock){
+          } finally {
+            synchronized (fetchTaskCountLock) {
-  
+
-    // progress, so just return 
+    // progress, so just return
-        if (advisor==null) {
-          advisor = GetClientPartitionAttributesOp
-              .execute(pool, regionFullPath);
-          if(advisor == null){
+        if (advisor == null) {
+          advisor = GetClientPartitionAttributesOp.execute(pool, regionFullPath);
+          if (advisor == null) {
-        }
-        else {
-          if(advisor.getFixedPAMap() != null && !advisor.isFPAAttrsComplete()) {
-            ClientPartitionAdvisor newAdvisor = GetClientPartitionAttributesOp
-            .execute(pool, regionFullPath);
+        } else {
+          if (advisor.getFixedPAMap() != null && !advisor.isFPAAttrsComplete()) {
+            ClientPartitionAdvisor newAdvisor =
+                GetClientPartitionAttributesOp.execute(pool, regionFullPath);
-        }
-        else {
+        } else {
-          LocalRegion leaderRegion = (LocalRegion)region.getCache()
-          .getRegion(colocatedWith);
+          LocalRegion leaderRegion = (LocalRegion) region.getCache().getRegion(colocatedWith);
-          }
-          else {
+          } else {
-      }
-      finally {
+      } finally {
-  
-  public void scheduleGetPRMetaData(final LocalRegion region,
-      final boolean isRecursive, byte nwHopType) {
-    if(this.nonPRs.contains(region.getFullPath())){
+
+  public void scheduleGetPRMetaData(final LocalRegion region, final boolean isRecursive,
+      byte nwHopType) {
+    if (this.nonPRs.contains(region.getFullPath())) {
-    if(advisor!= null && advisor.getServerGroup().length()!= 0 && HONOUR_SERVER_GROUP_IN_PR_SINGLE_HOP){
+    if (advisor != null && advisor.getServerGroup().length() != 0
+        && HONOUR_SERVER_GROUP_IN_PR_SINGLE_HOP) {
-      if( nwHopType == PartitionedRegion.NETWORK_HOP_TO_DIFFERENT_GROUP){
+      if (nwHopType == PartitionedRegion.NETWORK_HOP_TO_DIFFERENT_GROUP) {
-      region.getCachePerfStats().incNonSingleHopsCount();
-        region.getCachePerfStats().incNonSingleHopsCount();
-          }
-          finally {
-            synchronized (fetchTaskCountLock){
+          } finally {
+            synchronized (fetchTaskCountLock) {
-        ClientPartitionAdvisor prAdvisor = this
-            .getClientPartitionAdvisor(regionPath);
+        ClientPartitionAdvisor prAdvisor = this.getClientPartitionAdvisor(regionPath);
-  
-  public byte getMetaDataVersion(Region region, Operation operation,
-      Object key, Object value, Object callbackArg) {
-    ClientPartitionAdvisor prAdvisor = this.getClientPartitionAdvisor(region
-        .getFullPath());
+
+  public byte getMetaDataVersion(Region region, Operation operation, Object key, Object value,
+      Object callbackArg) {
+    ClientPartitionAdvisor prAdvisor = this.getClientPartitionAdvisor(region.getFullPath());
-    }
-    else {
-      entryOp = new EntryOperationImpl(region, operation, key,
-          value, callbackArg);
+    } else {
+      entryOp = new EntryOperationImpl(region, operation, key, value, callbackArg);
-    
+
-        entryOp = new EntryOperationImpl(region,
-            Operation.FUNCTION_EXECUTION, key, null, null);
+        entryOp = new EntryOperationImpl(region, Operation.FUNCTION_EXECUTION, key, null, null);
-      String partition = ((FixedPartitionResolver)resolver).getPartitionName(
-          entryOp, prAdvisor.getFixedPartitionNames());
+      String partition = ((FixedPartitionResolver) resolver).getPartitionName(entryOp,
+          prAdvisor.getFixedPartitionNames());
-        Object[] prms = new Object[] { region.getName(), resolver };
+        Object[] prms = new Object[] {region.getName(), resolver};
+      } else {
+        bucketId = prAdvisor.assignFixedBucketId(region, partition, resolveKey);
-      else {
-        bucketId =  prAdvisor.assignFixedBucketId(region, partition, resolveKey);
-      }
-    }else {
+    } else {
-    
-    BucketServerLocation66 bsl = (BucketServerLocation66)getPrimaryServerLocation(
-        region, bucketId);
+
+    BucketServerLocation66 bsl =
+        (BucketServerLocation66) getPrimaryServerLocation(region, bucketId);
-        logger.debug("ClientMetadataService#getServerLocation : Region {} prAdvisor does not exist.", regionFullPath);
+        logger.debug(
+            "ClientMetadataService#getServerLocation : Region {} prAdvisor does not exist.",
+            regionFullPath);
-          logger.debug("ClientMetadataService#getServerLocation : Region {} prAdvisor does not exist.", regionFullPath);
+          logger.debug(
+              "ClientMetadataService#getServerLocation : Region {} prAdvisor does not exist.",
+              regionFullPath);
-  
-  private void addClientPartitionAdvisor(String regionFullPath,
-      ClientPartitionAdvisor advisor) {
+
+  private void addClientPartitionAdvisor(String regionFullPath, ClientPartitionAdvisor advisor) {
-        Set<ClientPartitionAdvisor> colocatedAdvisors = this.colocatedPRAdvisors.get(parentRegionPath);
-        if(colocatedAdvisors == null){
+        Set<ClientPartitionAdvisor> colocatedAdvisors =
+            this.colocatedPRAdvisors.get(parentRegionPath);
+        if (colocatedAdvisors == null) {
-    }
-    catch (Exception npe) {
+    } catch (Exception npe) {
-    
+
-    }
-    catch (Exception npe) {
+    } catch (Exception npe) {
-  
+
-    if (this.cache.isClosed() || this.clientPRAdvisors == null || this.colocatedPRAdvisors == null) {
+    if (this.cache.isClosed() || this.clientPRAdvisors == null
+        || this.colocatedPRAdvisors == null) {
-  
+
-    Set<String> keys  = null;
+    Set<String> keys = null;
-    }
-    catch (Exception npe) {
+    } catch (Exception npe) {
-  
+
-  public boolean honourServerGroup(){
+  public boolean honourServerGroup() {
-  
+
-    synchronized(fetchTaskCountLock) {
+    synchronized (fetchTaskCountLock) {

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 UPD66 UPD66 UPD66 UPD66 INS8 UPD66 UPD66 INS8 MOV21 MOV41 DEL66 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21
GEODE-1994: Overhaul of internal.lang.StringUtils to extend and heavily use commons.lang.StringUtils

*   geode.internal.lang.StringUtils has been deprecated.  In the interim, it has been heavily refactored and extends commons.lang.StringUtils.
*
*   Renamed:
*   --  EMPTY_STRING -> EMPTY (inherited)
*   --  toUpperCase  -> upperCase (inherited)
*   --  toLowerCase  -> lowerCase (inherited)
*   --  padEnding    -> rightPad (inherited)
*
*   Removed:
*   --  EMPTY_STRING_ARRAY; usage replaced with commons.lang.ArrayUtils.EMPTY_STRING_ARRAY
*   --  SPACES
*   --  UTF_8; rare usage replaced with raw string
*   --  concat; usage replaced with commons.lang.join, refactoring as necessary.
*   --  getLettersOnly
*   --  getSpaces
*   --  truncate
*   --  valueOf; usage refactored to use defaultString
*
*   Refactored
*   --  defaultIfBlank: previously relied on varargs and could return null.  Usage refactored to allow inheritance from commons.
*   --  defaultString(s, EMPTY) refactored to use standard signature defaultString(s) for consistency throughout codebase.
*   --  isBlank: usage refactored to resolve discrepancies with commons.lang.isBlank, which is now inherited.
*   --  isEmpty: usage refactored to resolve discrepancies with commons.lang.isEmpty, which is now inherited.
*
*   Code Cleanup:
*   --  Many uses of !isBlank -> isNotBlank
*   --  Changes suggested by Inspections on most touched files.
*   --     Explicit <T> -> <> when type is inferable
*   --     while loops operating on iterators converted to for each loops
*   --     for loops operating on array indices converted to for each loops
*   --  Various string typos corrected.
*   --  isEmpty(s.trim()) -> isBlank(s)
*   --  s.trim().isEmpty() -> isEmpty(s)
*   --  Removed some instances of 'dead' code
*   --  Optimized imports in every touched file
*
*   Qualitative Changes:
*   --  The following functions now throw an error when called with a null string input:
*   --  *  LocatorLauncher.Builder.setMemberName
*   --  *  ServerLauncher.Builder.setMemberName
*   --  *  ServerLauncher.Builder.setHostnameForClients
*   --  (Unit tests added to capture these changes)
*
*   Notes:
*   --  StringUtils.wraps may be inherited from Apache Commons when the dependency is updated.
*   --  AbstractLauncher.getMember has the documented behavior of returning null when both MemberName and ID are blank.  Is this the best behavior for this method?

* this closes #521

-import java.io.DataInput;
-import java.io.DataOutput;
-import java.io.EOFException;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.NotSerializableException;
-import java.io.ObjectInput;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutput;
-import java.io.ObjectOutputStream;
-import java.io.ObjectStreamClass;
-import java.io.OutputStream;
-import java.io.Serializable;
-import java.io.UTFDataFormatException;
-import java.lang.ref.WeakReference;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.Proxy;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.net.InetAddress;
-import java.sql.Timestamp;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Hashtable;
-import java.util.IdentityHashMap;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Properties;
-import java.util.Set;
-import java.util.Stack;
-import java.util.TreeMap;
-import java.util.TreeSet;
-import java.util.UUID;
-import java.util.Vector;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.TimeUnit;
-
-import org.apache.logging.log4j.Logger;
-
+import org.apache.commons.lang.StringUtils;
+import org.apache.logging.log4j.Logger;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.EOFException;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.NotSerializableException;
+import java.io.ObjectInput;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutput;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamClass;
+import java.io.OutputStream;
+import java.io.Serializable;
+import java.io.UTFDataFormatException;
+import java.lang.ref.WeakReference;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.Proxy;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.net.InetAddress;
+import java.sql.Timestamp;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Hashtable;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Properties;
+import java.util.Set;
+import java.util.Stack;
+import java.util.TreeMap;
+import java.util.TreeSet;
+import java.util.UUID;
+import java.util.Vector;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.TimeUnit;
-    // send it to all cache clients irelevent of distribute
-    // bridge servers send it all the clients irelevent of
+    // send it to all cache clients irrelevant of distribute
+    // bridge servers send it all the clients irrelevant of
-    if (className == null || className.trim().isEmpty()) {
+    if (StringUtils.isBlank(className)) {
-      for (int i = 0; i < classes.length; i++) {
-        classesToSerializers.remove(classes[i].getName(), s);
-        supportedClassesToHolders.remove(classes[i].getName());
+      for (Class aClass : classes) {
+        classesToSerializers.remove(aClass.getName(), s);
+        supportedClassesToHolders.remove(aClass.getName());
-        DataSerializer ds = null;
+        DataSerializer ds;
-    } catch (IOException io) {
+    } catch (IOException | CancelException | ToDataException | GemFireRethrowable io) {
-      throw io;
-    } catch (CancelException | ToDataException | GemFireRethrowable ex) {
+
-      throw ex;
+
+      throw io;
-        E element = DataSerializer.<E>readObject(in);
+        E element = DataSerializer.readObject(in);
-  public static int readDSFIDHeader(final DataInput in) throws IOException, ClassNotFoundException {
+  public static int readDSFIDHeader(final DataInput in) throws IOException {
-      return DataSerializer.<T>readObject(in);
+      return DataSerializer.readObject(in);
-        return DataSerializer.<T>readObject(in);
+        return DataSerializer.readObject(in);
-      throws IOException, ClassNotFoundException {
+      throws IOException {
-            classCache.put(className, new WeakReference<Class<?>>(result));
+            classCache.put(className, new WeakReference<>(result));

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS40 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS70 INS44 INS42 INS8 INS84 INS43 INS42 MOV21 MOV21 MOV43 MOV43 MOV43 MOV43 INS42 INS42 INS42 UPD74 DEL42 DEL33 DEL27 DEL32 DEL32 DEL27 DEL42 DEL42 DEL2 DEL42 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL8 DEL24 DEL33 DEL84 DEL42 DEL44 DEL42 DEL53 DEL8 DEL12 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL76 DEL74
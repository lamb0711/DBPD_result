Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * <P>A <code>DistributionMessage</code> carries some piece of
- * information to a distribution manager.  </P>
+ * <P>
+ * A <code>DistributionMessage</code> carries some piece of information to a distribution manager.
+ * </P>
- * <P>Messages that don't have strict ordering requirements should extend
- * {@link org.apache.geode.distributed.internal.PooledDistributionMessage}.
- * Messages that must be processed serially in the order they were received
- * can extend
- * {@link org.apache.geode.distributed.internal.SerialDistributionMessage}.
- * To customize the sequentialness/thread requirements of a message, extend
- * DistributionMessage and implement getExecutor().</P>
+ * <P>
+ * Messages that don't have strict ordering requirements should extend
+ * {@link org.apache.geode.distributed.internal.PooledDistributionMessage}. Messages that must be
+ * processed serially in the order they were received can extend
+ * {@link org.apache.geode.distributed.internal.SerialDistributionMessage}. To customize the
+ * sequentialness/thread requirements of a message, extend DistributionMessage and implement
+ * getExecutor().
+ * </P>
-public abstract class DistributionMessage
-  implements DataSerializableFixedID, Cloneable {
-  
+public abstract class DistributionMessage implements DataSerializableFixedID, Cloneable {
+
-  
-  /** Indicates that a distribution message should be sent to all
-   * other distribution managers. */
+
+  /**
+   * Indicates that a distribution message should be sent to all other distribution managers.
+   */
-  protected static final short UNRESERVED_FLAGS_START =
-    (HAS_PROCESSOR_TYPE << 1);
+  protected static final short UNRESERVED_FLAGS_START = (HAS_PROCESSOR_TYPE << 1);
-  ////////////////////  Instance Fields  ////////////////////
+  //////////////////// Instance Fields ////////////////////
-  /** A set of recipients for this message, not serialized*/
+  /** A set of recipients for this message, not serialized */
-  /** The number of bytes used to read this message,  for statistics only */
+  /** The number of bytes used to read this message, for statistics only */
-  
+
-   * This field will be set if we can send a direct ack for
-   * this message.
+   * This field will be set if we can send a direct ack for this message.
-  
+
-  
-  //////////////////////  Constructors  //////////////////////
+
+  ////////////////////// Constructors //////////////////////
-  //////////////////////  Static Helper Methods  //////////////////////
+  ////////////////////// Static Helper Methods //////////////////////
-   * Get the next bit mask position while checking that the value should not
-   * exceed maximum byte value.
+   * Get the next bit mask position while checking that the value should not exceed maximum byte
+   * value.
-   * Get the next bit mask position while checking that the value should not
-   * exceed given maximum value.
+   * Get the next bit mask position while checking that the value should not exceed given maximum
+   * value.
-      Assert.fail("exhausted bit flags with all available bits: 0x"
-          + Integer.toHexString(mask) + ", max: 0x"
-          + Integer.toHexString(maxValue));
+      Assert.fail("exhausted bit flags with all available bits: 0x" + Integer.toHexString(mask)
+          + ", max: 0x" + Integer.toHexString(maxValue));
-  //////////////////////  Instance Methods  //////////////////////
+  ////////////////////// Instance Methods //////////////////////
-  
+
-  
+
-    if(acker != null) {
+    if (acker != null) {
-  } 
-  
+  }
+
-   * If true then this message most be sent on an ordered channel.
-   * If false then it can be unordered.
+   * If true then this message most be sent on an ordered channel. If false then it can be
+   * unordered.
+   * 
-      // no need to use orderedDelivery for PR ops particularly when thread
-      // does not own resources
-      //case DistributionManager.PARTITIONED_REGION_EXECUTOR:
+        // no need to use orderedDelivery for PR ops particularly when thread
+        // does not own resources
+        // case DistributionManager.PARTITIONED_REGION_EXECUTOR:
-        InternalDistributedSystem ids = InternalDistributedSystem
-            .getAnyInstance();
+        InternalDistributedSystem ids = InternalDistributedSystem.getAnyInstance();
-   * Sets the intended recipient of the message.  If recipient is
-   * {@link #ALL_RECIPIENTS} then the message will be sent to all
-   * distribution managers.
+   * Sets the intended recipient of the message. If recipient is {@link #ALL_RECIPIENTS} then the
+   * message will be sent to all distribution managers.
-       throw new IllegalStateException(LocalizedStrings.DistributionMessage_RECIPIENTS_CAN_ONLY_BE_SET_ONCE.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.DistributionMessage_RECIPIENTS_CAN_ONLY_BE_SET_ONCE.toLocalizedString());
+   * 
+
+   * 
+
-   * Return true of this message should be sent via UDP instead of the
-   * direct-channel.  This is typically only done for messages that are
-   * broadcast to the full membership set.
+   * Return true of this message should be sent via UDP instead of the direct-channel. This is
+   * typically only done for messages that are broadcast to the full membership set.
+
-   * Sets the intended recipient of the message.  If recipient set contains
-   * {@link #ALL_RECIPIENTS} then the message will be sent to all
-   * distribution managers.
+   * Sets the intended recipient of the message. If recipient set contains {@link #ALL_RECIPIENTS}
+   * then the message will be sent to all distribution managers.
-       throw new IllegalStateException(LocalizedStrings.DistributionMessage_RECIPIENTS_CAN_ONLY_BE_SET_ONCE.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.DistributionMessage_RECIPIENTS_CAN_ONLY_BE_SET_ONCE.toLocalizedString());
-    this.recipients = (InternalDistributedMember[])recipients.toArray(new InternalDistributedMember[recipients.size()]);
+    this.recipients = (InternalDistributedMember[]) recipients
+        .toArray(new InternalDistributedMember[recipients.size()]);
-  
+
-   * Returns the intended recipient(s) of this message.  If the message
-   * is intended to delivered to all distribution managers, then
-   * the array will contain ALL_RECIPIENTS.
-   * If the recipients have not been set null is returned.
+   * Returns the intended recipient(s) of this message. If the message is intended to delivered to
+   * all distribution managers, then the array will contain ALL_RECIPIENTS. If the recipients have
+   * not been set null is returned.
-    }else if (this.recipients != null) {
+    } else if (this.recipients != null) {
+
-    return (this.recipients == null)
-      || (this.multicast)
-      || ((this.recipients.length > 0)
-          && (this.recipients[0] == ALL_RECIPIENTS));
+    return (this.recipients == null) || (this.multicast)
+        || ((this.recipients.length > 0) && (this.recipients[0] == ALL_RECIPIENTS));
-    }
-    else if (this.multicast) {
+    } else if (this.multicast) {
-      for (int i=0; i < this.recipients.length; i++) {
+      for (int i = 0; i < this.recipients.length; i++) {
+
-   * Returns the sender of this message.  Note that this value is not
-   * set until this message is received by a distribution manager.
+   * Returns the sender of this message. Note that this value is not set until this message is
+   * received by a distribution manager.
-   * Sets the sender of this message.  This method is only invoked
-   * when the message is <B>received</B> by a
-   * <code>DistributionManager</code>.
+   * Sets the sender of this message. This method is only invoked when the message is
+   * <B>received</B> by a <code>DistributionManager</code>.
-  
-//  private Executor getExecutor(DistributionManager dm, Class clazz) {
-//    return dm.getExecutor(getProcessorType());
-//  }
+
+  // private Executor getExecutor(DistributionManager dm, Class clazz) {
+  // return dm.getExecutor(getProcessorType());
+  // }
-   * Processes this message.  This method is invoked by the receiver
-   * of the message.
+   * Processes this message. This method is invoked by the receiver of the message.
+   * 
-  
+
-   * Scheduled action to take when on this message when we are ready
-   * to process it.
+   * Scheduled action to take when on this message when we are ready to process it.
-    if(MessageLogger.isEnabled()) {
-      MessageLogger.logMessage(this, getSender(),  dm.getDistributionManagerId());
+    if (MessageLogger.isEnabled()) {
+      MessageLogger.logMessage(this, getSender(), dm.getDistributionManagerId());
-      dm.getStats().incMessageProcessingScheduleTime(time-getTimestamp());
+      dm.getStats().incMessageProcessingScheduleTime(time - getTimestamp());
-      
+
-      if(observer != null) {
+      if (observer != null) {
-      if(observer != null) { 
+      if (observer != null) {
-    }
-    catch (CancelException e) {
+    } catch (CancelException e) {
-    }
-    catch (VirtualMachineError err) {
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Throwable t) {
+    } catch (Throwable t) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributionMessage_UNCAUGHT_EXCEPTION_PROCESSING__0, this), t);
-    }
-    finally {
+      logger.fatal(LocalizedMessage
+          .create(LocalizedStrings.DistributionMessage_UNCAUGHT_EXCEPTION_PROCESSING__0, this), t);
+    } finally {
-   * Schedule this message's process() method in a thread determined
-   * by getExecutor()
+   * Schedule this message's process() method in a thread determined by getExecutor()
-      && getProcessorType() == DistributionManager.SERIAL_EXECUTOR
-      && !isPreciousThread();
-    
+        && getProcessorType() == DistributionManager.SERIAL_EXECUTOR && !isPreciousThread();
+
-    
+
-    
+
-    
+
-      }
-      catch (RejectedExecutionException ex) {
+      } catch (RejectedExecutionException ex) {
-          logger.warn(LocalizedMessage.create(LocalizedStrings.DistributionMessage_0__SCHEDULE_REJECTED, this.toString()), ex);
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.DistributionMessage_0__SCHEDULE_REJECTED, this.toString()), ex);
-      }
-      catch (VirtualMachineError err) {
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributionMessage_UNCAUGHT_EXCEPTION_PROCESSING__0, this), t);
+        logger.fatal(LocalizedMessage.create(
+            LocalizedStrings.DistributionMessage_UNCAUGHT_EXCEPTION_PROCESSING__0, this), t);
-        throw new InternalGemFireException(LocalizedStrings.DistributionMessage_UNEXPECTED_ERROR_SCHEDULING_MESSAGE.toLocalizedString(), t);
+        throw new InternalGemFireException(
+            LocalizedStrings.DistributionMessage_UNEXPECTED_ERROR_SCHEDULING_MESSAGE
+                .toLocalizedString(),
+            t);
-   * returns true if the current thread should not be used for inline
-   * processing.  i.e., it is a "precious" resource
+   * returns true if the current thread should not be used for inline processing. i.e., it is a
+   * "precious" resource
-    //return thrname.startsWith("Geode UDP");
+    // return thrname.startsWith("Geode UDP");
-  
+
-    if (Breadcrumbs.ENABLED) { 
+    if (Breadcrumbs.ENABLED) {
-      }
-      else {
+      } else {
-  
+
-        Breadcrumbs.setSendSide(procId 
-            + " recipients="+Arrays.toString(this.recipients));
-      }
-      else {
+        Breadcrumbs.setSendSide(procId + " recipients=" + Arrays.toString(this.recipients));
+      } else {
-  
+
-  
+
-   * This method resets the state of this message, usually releasing
-   * objects and resources it was using.  It is invoked after the
-   * message has been sent.  Note that classes that override this
-   * method should always invoke the inherited method
-   * (<code>super.reset()</code>).
+   * This method resets the state of this message, usually releasing objects and resources it was
+   * using. It is invoked after the message has been sent. Note that classes that override this
+   * method should always invoke the inherited method (<code>super.reset()</code>).
-   * Writes the contents of this <code>DistributionMessage</code> to
-   * the given output.
-   * Note that classes that
-   * override this method should always invoke the inherited method
+   * Writes the contents of this <code>DistributionMessage</code> to the given output. Note that
+   * classes that override this method should always invoke the inherited method
-//     DataSerializer.writeObject(this.recipients, out); // no need to serialize; filled in later
-    //((IpAddress)this.sender).toData(out); // no need to serialize; filled in later
-    //out.writeLong(this.timeStamp);
+    // DataSerializer.writeObject(this.recipients, out); // no need to serialize; filled in later
+    // ((IpAddress)this.sender).toData(out); // no need to serialize; filled in later
+    // out.writeLong(this.timeStamp);
-   * Reads the contents of this <code>DistributionMessage</code> from
-   * the given input.
-   * Note that classes that override this
-   * method should always invoke the inherited method
+   * Reads the contents of this <code>DistributionMessage</code> from the given input. Note that
+   * classes that override this method should always invoke the inherited method
-  public void fromData(DataInput in)
-    throws IOException, ClassNotFoundException {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-//     this.recipients = (Set)DataSerializer.readObject(in); // no to deserialize; filled in later
+    // this.recipients = (Set)DataSerializer.readObject(in); // no to deserialize; filled in later
+   * 
-  public void setBytesRead(int bytesRead)
-  {
+  public void setBytesRead(int bytesRead) {
-  public int getBytesRead()
-  {
+  public int getBytesRead() {
-  
+
+
-   * @return null if message is not conflatable. Otherwise return
-   * a key that can be used to identify the entry to conflate.
+   * @return null if message is not conflatable. Otherwise return a key that can be used to identify
+   *         the entry to conflate.
-  
+
-   * Severe alert processing enables suspect processing at the ack-wait-threshold
-   * and issuing of a severe alert at the end of the ack-severe-alert-threshold.
-   * Some messages should not support this type of processing
-   * (e.g., GII, or DLockRequests)
-   * @return whether severe-alert processing may be performed on behalf
-   * of this message
+   * Severe alert processing enables suspect processing at the ack-wait-threshold and issuing of a
+   * severe alert at the end of the ack-severe-alert-threshold. Some messages should not support
+   * this type of processing (e.g., GII, or DLockRequests)
+   * 
+   * @return whether severe-alert processing may be performed on behalf of this message
-  
+
-  
+
-   * does this message carry state that will alter the content of
-   * one or more cache regions?  This is used to track the
-   * flight of content changes through communication channels
+   * does this message carry state that will alter the content of one or more cache regions? This is
+   * used to track the flight of content changes through communication channels
-  /** returns the class name w/o package information.  useful in logging */
+  /** returns the class name w/o package information. useful in logging */
-    return cname.substring(getClass().getPackage().getName().length()+1);
+    return cname.substring(getClass().getPackage().getName().length() + 1);

MOV66 MOV8 MOV8 INS66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
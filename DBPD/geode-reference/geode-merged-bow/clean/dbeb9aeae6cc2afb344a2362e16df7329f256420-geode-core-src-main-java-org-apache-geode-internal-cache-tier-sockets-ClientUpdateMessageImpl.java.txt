Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Class <code>ClientUpdateMessageImpl</code> is a message representing a cache
- * operation that is sent from a server to an interested client.
+ * Class <code>ClientUpdateMessageImpl</code> is a message representing a cache operation that is
+ * sent from a server to an interested client.
-public class ClientUpdateMessageImpl implements ClientUpdateMessage, Sizeable, NewValueImporter
-{
+public class ClientUpdateMessageImpl implements ClientUpdateMessage, Sizeable, NewValueImporter {
-   * The operation performed (e.g. AFTER_CREATE, AFTER_UPDATE, AFTER_DESTROY,
-   * AFTER_INVALIDATE, AFTER_REGION_DESTROY)
+   * The operation performed (e.g. AFTER_CREATE, AFTER_UPDATE, AFTER_DESTROY, AFTER_INVALIDATE,
+   * AFTER_REGION_DESTROY)
-  
+
-  
+
-  
+
-   * To determine if the message is result of netLoad. 
-   * If its net load the message is not delivered to the client that has 
-   * requested the load.
+   * To determine if the message is result of netLoad. If its net load the message is not delivered
+   * to the client that has requested the load.
-  
+
-   * @param operation
-   *          The operation performed (e.g. AFTER_CREATE, AFTER_UPDATE,
-   *          AFTER_DESTROY, AFTER_INVALIDATE, AFTER_REGION_DESTROY)
-   * @param region
-   *          The <code>Region</code> that was updated
-   * @param keyOfInterest
-   *          The key that was updated
-   * @param value
-   *          The new value
+   * @param operation The operation performed (e.g. AFTER_CREATE, AFTER_UPDATE, AFTER_DESTROY,
+   *        AFTER_INVALIDATE, AFTER_REGION_DESTROY)
+   * @param region The <code>Region</code> that was updated
+   * @param keyOfInterest The key that was updated
+   * @param value The new value
-   * @param callbackArgument
-   *          The callback argument
-   * @param memberId
-   *          membership id of the originator of the event
+   * @param callbackArgument The callback argument
+   * @param memberId membership id of the originator of the event
-  public ClientUpdateMessageImpl(EnumListenerEvent operation,
-      LocalRegion region, Object keyOfInterest, Object value,
-      byte valueIsObject, Object callbackArgument,
+  public ClientUpdateMessageImpl(EnumListenerEvent operation, LocalRegion region,
+      Object keyOfInterest, Object value, byte valueIsObject, Object callbackArgument,
-    this(operation, region, keyOfInterest, value, null, valueIsObject,
-        callbackArgument, memberId, eventIdentifier, null);
+    this(operation, region, keyOfInterest, value, null, valueIsObject, callbackArgument, memberId,
+        eventIdentifier, null);
-  public ClientUpdateMessageImpl(EnumListenerEvent operation,
-      LocalRegion region, Object keyOfInterest, Object value,
-      byte[] delta, byte valueIsObject, Object callbackArgument,
-      ClientProxyMembershipID memberId, EventID eventIdentifier,
-      VersionTag versionTag) {
-//    this._clientInterestList = new HashSet();
-//    this._clientInterestListInv = new HashSet();
+  public ClientUpdateMessageImpl(EnumListenerEvent operation, LocalRegion region,
+      Object keyOfInterest, Object value, byte[] delta, byte valueIsObject, Object callbackArgument,
+      ClientProxyMembershipID memberId, EventID eventIdentifier, VersionTag versionTag) {
+    // this._clientInterestList = new HashSet();
+    // this._clientInterestListInv = new HashSet();
-   * @param operation
-   *          The operation performed (e.g. AFTER_CREATE, AFTER_UPDATE,
-   *          AFTER_DESTROY, AFTER_INVALIDATE, AFTER_REGION_DESTROY)
-   * @param memberId
-   *          membership id of the originator of the event
-   * @param eventIdentifier
-   *          EventID of this message
+   * @param operation The operation performed (e.g. AFTER_CREATE, AFTER_UPDATE, AFTER_DESTROY,
+   *        AFTER_INVALIDATE, AFTER_REGION_DESTROY)
+   * @param memberId membership id of the originator of the event
+   * @param eventIdentifier EventID of this message
-  protected ClientUpdateMessageImpl(EnumListenerEvent operation,
-      ClientProxyMembershipID memberId, EventID eventIdentifier) {
-//    this._clientInterestList = new HashSet();
-//    this._clientInterestListInv = new HashSet();
+  protected ClientUpdateMessageImpl(EnumListenerEvent operation, ClientProxyMembershipID memberId,
+      EventID eventIdentifier) {
+    // this._clientInterestList = new HashSet();
+    // this._clientInterestListInv = new HashSet();
-  
+
-   * Determines whether or not to conflate this message. This method will answer
-   * true IFF the message's operation is AFTER_UPDATE and its region has enabled
-   * are conflation. Otherwise, this method will answer false. Messages whose
-   * operation is AFTER_CREATE, AFTER_DESTROY, AFTER_INVALIDATE or
-   * AFTER_REGION_DESTROY are not conflated.
+   * Determines whether or not to conflate this message. This method will answer true IFF the
+   * message's operation is AFTER_UPDATE and its region has enabled are conflation. Otherwise, this
+   * method will answer false. Messages whose operation is AFTER_CREATE, AFTER_DESTROY,
+   * AFTER_INVALIDATE or AFTER_REGION_DESTROY are not conflated.
-  public boolean shouldBeConflated()
-  {
+  public boolean shouldBeConflated() {
-  public String getRegionToConflate()
-  {
+  public String getRegionToConflate() {
-  public Object getKeyToConflate()
-  {
+  public Object getKeyToConflate() {
-  public Object getValueToConflate()
-  {
+  public Object getValueToConflate() {
-  public void setLatestValue(Object value)
-  {
+  public void setLatestValue(Object value) {
-  public ClientProxyMembershipID getMembershipId()
-  {
+  public ClientProxyMembershipID getMembershipId() {
-   * Returns the unqiue event eventifier for event corresponding to this
-   * message.
+   * Returns the unqiue event eventifier for event corresponding to this message.
-   * @return the unqiue event eventifier for event corresponding to this
-   *         message.
+   * @return the unqiue event eventifier for event corresponding to this message.
-  public EventID getEventId()
-  {
+  public EventID getEventId() {
-  
+
-  public boolean isCreate()
-  {
+  public boolean isCreate() {
-  public boolean isUpdate()
-  {
+  public boolean isUpdate() {
-  public boolean isDestroy()
-  {
+  public boolean isDestroy() {
-  public boolean isInvalidate()
-  {
+  public boolean isInvalidate() {
-  public boolean isDestroyRegion()
-  {
+  public boolean isDestroyRegion() {
-  public boolean isClearRegion()
-  {
+  public boolean isClearRegion() {
-  public boolean isInvalidateRegion()
-  {
+  public boolean isInvalidateRegion() {
-  public boolean isClientCompatible()
-  {
+  public boolean isClientCompatible() {
-  public Message getMessage(CacheClientProxy proxy, boolean notify) throws IOException
-  {
+  public Message getMessage(CacheClientProxy proxy, boolean notify) throws IOException {
-  
+
-   * @param latestValue
-   *          Object containing the latest value to use. This could be the
-   *          original value if conflation is not enabled, or it could be a
-   *          conflated value if conflation is enabled.
+   * @param latestValue Object containing the latest value to use. This could be the original value
+   *        if conflation is not enabled, or it could be a conflated value if conflation is enabled.
-  
-  protected Message getMessage(CacheClientProxy proxy, byte[] latestValue) throws IOException
-  {
+
+  protected Message getMessage(CacheClientProxy proxy, byte[] latestValue) throws IOException {
-        || (proxy.clientConflation == HandShake.CONFLATION_DEFAULT && this
-            .shouldBeConflated());
+        || (proxy.clientConflation == HandShake.CONFLATION_DEFAULT && this.shouldBeConflated());
-    if(latestValue != null) {
+    if (latestValue != null) {
-    }
-    else {
+    } else {
-       * This means latestValue is instance of Delta, and its delta has already
-       * been extracted and put into deltaBytes. We serialize the value.
+       * This means latestValue is instance of Delta, and its delta has already been extracted and
+       * put into deltaBytes. We serialize the value.
-        this._value = serializedValue = CacheServerHelper
-            .serialize(latestValue);
+        this._value = serializedValue = CacheServerHelper.serialize(latestValue);
-          "Unsupported client version for server-to-client message creation: "
-              + clientVersion);
+          "Unsupported client version for server-to-client message creation: " + clientVersion);
-      
+
-  protected Message getGFEMessage(ClientProxyMembershipID proxyId,
-      byte[] latestValue, Version clientVersion) throws IOException {
+  protected Message getGFEMessage(ClientProxyMembershipID proxyId, byte[] latestValue,
+      Version clientVersion) throws IOException {
-    
+
-      cqMsgParts = (this.getCqs(proxyId).length * 2) + 1; 
+      cqMsgParts = (this.getCqs(proxyId).length * 2) + 1;
-    
+
-        
+
-        }
-        else {
+        } else {
-        
+
-    }
-    else if (isDestroy() || isInvalidate()) {
+    } else if (isDestroy() || isInvalidate()) {
-      }
-      else {
+      } else {
-      
+
-      
+
-    }
-    else if (isClearRegion()) {
+    } else if (isClearRegion()) {
-      
+
-    }
-    else if (isInvalidateRegion()) {
+    } else if (isInvalidateRegion()) {
-      
+
-    }
-    else {
+    } else {
-  
-  protected Message getGFE61Message(CacheClientProxy proxy, byte[] latestValue,
-      boolean conflation, Version clientVersion) throws IOException {
+
+  protected Message getGFE61Message(CacheClientProxy proxy, byte[] latestValue, boolean conflation,
+      Version clientVersion) throws IOException {
-      }
-      else {
+      } else {
-        }
-        else {
+        } else {
-          if (this.deltaBytes != null
-              && !conflation
-              && !proxy.isMarkerEnqueued()
-              && !proxy.getRegionsWithEmptyDataPolicy()
-                  .containsKey(_regionName)) {
+          if (this.deltaBytes != null && !conflation && !proxy.isMarkerEnqueued()
+              && !proxy.getRegionsWithEmptyDataPolicy().containsKey(_regionName)) {
-          }
-          else {
+          } else {
-              l = (byte[])this._value;
+              l = (byte[]) this._value;
-    }
-    else if (isDestroy() || isInvalidate()) {
+    } else if (isDestroy() || isInvalidate()) {
-      }
-      else {
+      } else {
-    }
-    else if (isDestroyRegion()) {
+    } else if (isDestroyRegion()) {
-    }
-    else if (isClearRegion()) {
+    } else if (isClearRegion()) {
-    }
-    else if (isInvalidateRegion()) {
+    } else if (isInvalidateRegion()) {
-    }
-    else {
+    } else {
-  protected Message getGFE65Message(CacheClientProxy proxy, 
-    byte[] p_latestValue, boolean conflation, Version clientVersion) throws IOException {
+  protected Message getGFE65Message(CacheClientProxy proxy, byte[] p_latestValue,
+      boolean conflation, Version clientVersion) throws IOException {
-    
+
-    
+
-      }
-      else {
+      } else {
-        }
-        else {
+        } else {
-          if (this.deltaBytes != null
-              && !conflation
-              && !proxy.isMarkerEnqueued()
-              && !proxy.getRegionsWithEmptyDataPolicy()
-                  .containsKey(_regionName)) {
+          if (this.deltaBytes != null && !conflation && !proxy.isMarkerEnqueued()
+              && !proxy.getRegionsWithEmptyDataPolicy().containsKey(_regionName)) {
-          }
-          else {
+          } else {
-              latestValue = (byte[])this._value;
+              latestValue = (byte[]) this._value;
-      
+
-          //in case of invalidate, set the region operation type.
-          message.addIntPart(isCreate() ? MessageType.LOCAL_CREATE:MessageType.LOCAL_UPDATE); 
+          // in case of invalidate, set the region operation type.
+          message.addIntPart(isCreate() ? MessageType.LOCAL_CREATE : MessageType.LOCAL_UPDATE);
-    }
-    else if (isDestroy() || isInvalidate()) {
+    } else if (isDestroy() || isInvalidate()) {
-      }
-      else {
-        if (clientHasCq){
+      } else {
+        if (clientHasCq) {
-        if (isInvalidate()){
+        if (isInvalidate()) {
-          message.addIntPart(MessageType.LOCAL_INVALIDATE); 
+          message.addIntPart(MessageType.LOCAL_INVALIDATE);
-    }
-    else if (isDestroyRegion()) {
+    } else if (isDestroyRegion()) {
-    }
-    else if (isClearRegion()) {
+    } else if (isClearRegion()) {
-    }
-    else if (isInvalidateRegion()) {
+    } else if (isInvalidateRegion()) {
-    }
-    else {
+    } else {
-  protected Message getGFE70Message(CacheClientProxy proxy, 
-      byte[] p_latestValue, boolean conflation, Version clientVersion) throws IOException {
-      byte[] latestValue = p_latestValue;
-      Message message = null;
-      ClientProxyMembershipID proxyId = proxy.getProxyID();
-      // Add CQ info.
-      int cqMsgParts = 0;
-      boolean clientHasCq = this._hasCqs && (this.getCqs(proxyId) != null);
-      
-      if (clientHasCq) {
-        cqMsgParts = (this.getCqs(proxyId).length * 2) + 1;
-      }
-      
-      if (isCreate() || isUpdate()) {
-        // Create or update event
-        if (this._clientInterestListInv != null && this._clientInterestListInv.contains(proxyId)) {
-          // Client is registered for invalidates.
-          if (cqMsgParts > 0) {
-            cqMsgParts++; // To store base operation type for CQ.
-          }
+  protected Message getGFE70Message(CacheClientProxy proxy, byte[] p_latestValue,
+      boolean conflation, Version clientVersion) throws IOException {
+    byte[] latestValue = p_latestValue;
+    Message message = null;
+    ClientProxyMembershipID proxyId = proxy.getProxyID();
+    // Add CQ info.
+    int cqMsgParts = 0;
+    boolean clientHasCq = this._hasCqs && (this.getCqs(proxyId) != null);
-          message = getMessage(7 + cqMsgParts, clientVersion);
-          message.setMessageType(MessageType.LOCAL_INVALIDATE);
+    if (clientHasCq) {
+      cqMsgParts = (this.getCqs(proxyId).length * 2) + 1;
+    }
+
+    if (isCreate() || isUpdate()) {
+      // Create or update event
+      if (this._clientInterestListInv != null && this._clientInterestListInv.contains(proxyId)) {
+        // Client is registered for invalidates.
+        if (cqMsgParts > 0) {
+          cqMsgParts++; // To store base operation type for CQ.
+        }
+
+        message = getMessage(7 + cqMsgParts, clientVersion);
+        message.setMessageType(MessageType.LOCAL_INVALIDATE);
+        message.addStringPart(this._regionName, true);
+        message.addStringOrObjPart(this._keyOfInterest);
+      } else {
+        // Notify by subscription - send the value
+        message = getMessage(9 + cqMsgParts, clientVersion);
+        if (isCreate()) {
+          message.setMessageType(MessageType.LOCAL_CREATE);
-        }
-        else {
-          // Notify by subscription - send the value
-          message = getMessage(9 + cqMsgParts, clientVersion);
-          if (isCreate()) {
-            message.setMessageType(MessageType.LOCAL_CREATE);
-            message.addStringPart(this._regionName, true);
-            message.addStringOrObjPart(this._keyOfInterest);
-            message.addObjPart(Boolean.FALSE); // NO delta
+          message.addObjPart(Boolean.FALSE); // NO delta
+          // Add the value (which has already been serialized)
+          message.addRawPart(latestValue, (this._valueIsObject == 0x01));
+        } else {
+          message.setMessageType(MessageType.LOCAL_UPDATE);
+          message.addStringPart(this._regionName, true);
+          message.addStringOrObjPart(this._keyOfInterest);
+
+          if (this.deltaBytes != null && !conflation && !proxy.isMarkerEnqueued()
+              && !proxy.getRegionsWithEmptyDataPolicy().containsKey(_regionName)) {
+            message.addObjPart(Boolean.TRUE);
+            message.addBytesPart(this.deltaBytes);
+            proxy.getStatistics().incDeltaMessagesSent();
+          } else {
+            message.addObjPart(Boolean.FALSE);
+            if (latestValue == null) {
+              if (!(this._value instanceof byte[])) {
+                this._value = CacheServerHelper.serialize(this._value);
+              }
+              latestValue = (byte[]) this._value;
+            }
-          else {
-            message.setMessageType(MessageType.LOCAL_UPDATE);
-            message.addStringPart(this._regionName, true);
-            message.addStringOrObjPart(this._keyOfInterest);
-
-            if (this.deltaBytes != null
-                && !conflation
-                && !proxy.isMarkerEnqueued()
-                && !proxy.getRegionsWithEmptyDataPolicy()
-                    .containsKey(_regionName)) {
-              message.addObjPart(Boolean.TRUE);
-              message.addBytesPart(this.deltaBytes);
-              proxy.getStatistics().incDeltaMessagesSent();
-            }
-            else {
-              message.addObjPart(Boolean.FALSE);
-              if (latestValue == null) {
-                if (!(this._value instanceof byte[])) {
-                  this._value = CacheServerHelper.serialize(this._value);
-                }
-                latestValue = (byte[])this._value;
-              }
-              // Add the value (which has already been serialized)
-              message.addRawPart(latestValue, (this._valueIsObject == 0x01));
-            }
-          }
-        }
-        
-        message.addObjPart(this._callbackArgument);
-        if (this.versionTag != null) {
-          this.versionTag.setCanonicalIDs(proxy.getCache().getDistributionManager());
-        }
-        message.addObjPart(this.versionTag);
-        message.addObjPart(Boolean.valueOf(isClientInterested(proxyId)));
-        message.addObjPart(Boolean.valueOf(clientHasCq));
-
-        if (clientHasCq) {
-          if (message.getMessageType() == MessageType.LOCAL_INVALIDATE) {
-            //in case of invalidate, set the region operation type.
-            message.addIntPart(isCreate() ? MessageType.LOCAL_CREATE:MessageType.LOCAL_UPDATE); 
-          }
-          this.addCqsToMessage(proxyId, message);
-      else if (isDestroy() || isInvalidate()) {
-        if (isDestroy()) {
-          message = getMessage(7 + cqMsgParts, clientVersion);
-          message.setMessageType(MessageType.LOCAL_DESTROY);
-        }
-        else {
-          if (clientHasCq){
-            cqMsgParts++;/* To store the region operation for CQ */
-          }
-          message = getMessage(7 + cqMsgParts, clientVersion);
-          message.setMessageType(MessageType.LOCAL_INVALIDATE);
-        }
-        message.addStringPart(this._regionName, true);
-        message.addStringOrObjPart(this._keyOfInterest);
-        message.addObjPart(this._callbackArgument);
-        message.addObjPart(this.versionTag);
-        message.addObjPart(Boolean.valueOf(isClientInterested(proxyId)));
+
+      message.addObjPart(this._callbackArgument);
+      if (this.versionTag != null) {
+        this.versionTag.setCanonicalIDs(proxy.getCache().getDistributionManager());
+      }
+      message.addObjPart(this.versionTag);
+      message.addObjPart(Boolean.valueOf(isClientInterested(proxyId)));
-          if (isInvalidate()){
-            // This is to take care when invalidate message is getting sent
-            // to the Client. See the code for create/update operation.
-            message.addIntPart(MessageType.LOCAL_INVALIDATE); 
-          }
+        if (message.getMessageType() == MessageType.LOCAL_INVALIDATE) {
+          // in case of invalidate, set the region operation type.
+          message.addIntPart(isCreate() ? MessageType.LOCAL_CREATE : MessageType.LOCAL_UPDATE);
+        }
-    }
-      else if (isDestroyRegion()) {
-        message = getMessage(4 + cqMsgParts, clientVersion);
-        message.setMessageType(MessageType.LOCAL_DESTROY_REGION);
-        message.addStringPart(this._regionName, true);
-        message.addObjPart(this._callbackArgument);
-        message.addObjPart(Boolean.valueOf(clientHasCq));
-
+    } else if (isDestroy() || isInvalidate()) {
+      if (isDestroy()) {
+        message = getMessage(7 + cqMsgParts, clientVersion);
+        message.setMessageType(MessageType.LOCAL_DESTROY);
+      } else {
-          this.addCqsToMessage(proxyId, message);
+          cqMsgParts++;/* To store the region operation for CQ */
+        message = getMessage(7 + cqMsgParts, clientVersion);
+        message.setMessageType(MessageType.LOCAL_INVALIDATE);
-      else if (isClearRegion()) {
-        message = getMessage(4 + cqMsgParts, clientVersion);
-        message.setMessageType(MessageType.CLEAR_REGION);
-        message.addStringPart(this._regionName, true);
-        message.addObjPart(this._callbackArgument);
-        message.addObjPart(Boolean.valueOf(clientHasCq));
+      message.addStringPart(this._regionName, true);
+      message.addStringOrObjPart(this._keyOfInterest);
+      message.addObjPart(this._callbackArgument);
+      message.addObjPart(this.versionTag);
+      message.addObjPart(Boolean.valueOf(isClientInterested(proxyId)));
+      message.addObjPart(Boolean.valueOf(clientHasCq));
-        if (clientHasCq) {
-          this.addCqsToMessage(proxyId, message);
+      if (clientHasCq) {
+        if (isInvalidate()) {
+          // This is to take care when invalidate message is getting sent
+          // to the Client. See the code for create/update operation.
+          message.addIntPart(MessageType.LOCAL_INVALIDATE);
+        this.addCqsToMessage(proxyId, message);
-    else if (isInvalidateRegion()) {
+    } else if (isDestroyRegion()) {
+      message = getMessage(4 + cqMsgParts, clientVersion);
+      message.setMessageType(MessageType.LOCAL_DESTROY_REGION);
+      message.addStringPart(this._regionName, true);
+      message.addObjPart(this._callbackArgument);
+      message.addObjPart(Boolean.valueOf(clientHasCq));
+
+      if (clientHasCq) {
+        this.addCqsToMessage(proxyId, message);
+      }
+    } else if (isClearRegion()) {
+      message = getMessage(4 + cqMsgParts, clientVersion);
+      message.setMessageType(MessageType.CLEAR_REGION);
+      message.addStringPart(this._regionName, true);
+      message.addObjPart(this._callbackArgument);
+      message.addObjPart(Boolean.valueOf(clientHasCq));
+
+      if (clientHasCq) {
+        this.addCqsToMessage(proxyId, message);
+      }
+    } else if (isInvalidateRegion()) {
-    }
-    else {
+    } else {
-  private static final ThreadLocal<Map<Integer,Message>> CACHED_MESSAGES = new ThreadLocal<Map<Integer,Message>>() {
-    protected Map<Integer,Message> initialValue() {
-      return new HashMap<Integer,Message>();
-    };
-  };
+  private static final ThreadLocal<Map<Integer, Message>> CACHED_MESSAGES =
+      new ThreadLocal<Map<Integer, Message>>() {
+        protected Map<Integer, Message> initialValue() {
+          return new HashMap<Integer, Message>();
+        };
+      };
-      m =  new Message(numParts, Version.CURRENT);
+      m = new Message(numParts, Version.CURRENT);
-      CqNameToOp cqs = this._clientCqs.get(clientId); 
+      CqNameToOp cqs = this._clientCqs.get(clientId);
-  
+
+   * 
-    String[] cqNames = null;  
+    String[] cqNames = null;
-      
+
-  
-  public ClientCqConcurrentMap getClientCqs(){
-    return this._clientCqs;  
+
+  public ClientCqConcurrentMap getClientCqs() {
+    return this._clientCqs;
-  
+
+   * 
-  
-  public void addClientCq(ClientProxyMembershipID clientId, String cqName, Integer cqEvent){
+
+  public void addClientCq(ClientProxyMembershipID clientId, String cqName, Integer cqEvent) {
-      cqInfo = new CqNameToOpHashMap((CqNameToOpSingleEntry)cqInfo);
+      cqInfo = new CqNameToOpHashMap((CqNameToOpSingleEntry) cqInfo);
-  
+
-  
+
-      //remove clientId key if no more cqs exist for this clientId
+      // remove clientId key if no more cqs exist for this clientId
-  
+
-  public void setRegionName(String regionName)
-  {
+  public void setRegionName(String regionName) {
-  private void writeCqInfo(ObjectOutput out) throws IOException {
-    // Write Client CQ Size
-    out.writeInt(this._clientCqs.size());
-    // For each client.
-    Iterator entries = this._clientCqs.entrySet().iterator();
-    while (entries.hasNext()) {
-      Map.Entry entry = (Map.Entry)entries.next();
-
-      // Write ProxyId.
-      ClientProxyMembershipID proxyId = (ClientProxyMembershipID)entry.getKey();
-      proxyId.toData(out);
-
-      HashMap cqs = (HashMap)entry.getValue();
-      // Write CQ size for each Client.
-      out.writeInt(cqs.size());
-      Iterator clients = cqs.entrySet().iterator();
-      while (clients.hasNext()) {
-        Map.Entry client = (Map.Entry)clients.next();
-        // Write CQ Name.
-        String cq = (String)client.getKey();
-        out.writeObject(cq);
-        // Write CQ OP.
-        int cqOp = ((Integer)client.getValue()).intValue();
-        out.writeInt(cqOp);
-      }
-    } // while
-  }
-  */
+   * private void writeCqInfo(ObjectOutput out) throws IOException { // Write Client CQ Size
+   * out.writeInt(this._clientCqs.size()); // For each client. Iterator entries =
+   * this._clientCqs.entrySet().iterator(); while (entries.hasNext()) { Map.Entry entry =
+   * (Map.Entry)entries.next();
+   * 
+   * // Write ProxyId. ClientProxyMembershipID proxyId = (ClientProxyMembershipID)entry.getKey();
+   * proxyId.toData(out);
+   * 
+   * HashMap cqs = (HashMap)entry.getValue(); // Write CQ size for each Client.
+   * out.writeInt(cqs.size()); Iterator clients = cqs.entrySet().iterator(); while
+   * (clients.hasNext()) { Map.Entry client = (Map.Entry)clients.next(); // Write CQ Name. String cq
+   * = (String)client.getKey(); out.writeObject(cq); // Write CQ OP. int cqOp =
+   * ((Integer)client.getValue()).intValue(); out.writeInt(cqOp); } } // while }
+   */
-  private void readCqInfo(ObjectInput in) throws IOException, 
-	    ClassNotFoundException {
-    // Read Client CQ Size    
-	int numClientIds = in.readInt();
-	this._clientCqs = new HashMap();
-	    
-	// For each Client.
-	for (int cCnt=0; cCnt < numClientIds; cCnt++){
-	  ClientProxyMembershipID proxyId = new ClientProxyMembershipID();
-	      
-	  // Read Proxy id.
-	  proxyId.fromData(in);
-	  // read CQ size for each Client.
-	  int numCqs = in.readInt();
-	  HashMap cqs = new HashMap();
-	      
-	  for (int cqCnt=0; cqCnt < numCqs; cqCnt++){
-	    // Get CQ Name and CQ Op.
-	    // Read CQ Name.
-	    String cqName = (String)in.readObject();
-	    int cqOp = in.readInt();
-	        
-	    // Read CQ Op.
-	    cqs.put(cqName, Integer.valueOf(cqOp));
-	  }
-	  this._clientCqs.put(proxyId, cqs);
-	}    
-  }
-  */
-  
+   * private void readCqInfo(ObjectInput in) throws IOException, ClassNotFoundException { // Read
+   * Client CQ Size int numClientIds = in.readInt(); this._clientCqs = new HashMap();
+   * 
+   * // For each Client. for (int cCnt=0; cCnt < numClientIds; cCnt++){ ClientProxyMembershipID
+   * proxyId = new ClientProxyMembershipID();
+   * 
+   * // Read Proxy id. proxyId.fromData(in); // read CQ size for each Client. int numCqs =
+   * in.readInt(); HashMap cqs = new HashMap();
+   * 
+   * for (int cqCnt=0; cqCnt < numCqs; cqCnt++){ // Get CQ Name and CQ Op. // Read CQ Name. String
+   * cqName = (String)in.readObject(); int cqOp = in.readInt();
+   * 
+   * // Read CQ Op. cqs.put(cqName, Integer.valueOf(cqOp)); } this._clientCqs.put(proxyId, cqs); } }
+   */
+
-  
+
-    HashSet <ClientProxyMembershipID>newInterests;
+    HashSet<ClientProxyMembershipID> newInterests;
-    || (this._clientInterestListInv != null && this._clientInterestListInv.contains(clientId));
+        || (this._clientInterestListInv != null && this._clientInterestListInv.contains(clientId));
-  protected Object deserialize(byte[] serializedBytes)
-  {
+  protected Object deserialize(byte[] serializedBytes) {
-      DataInputStream dis = new DataInputStream(new ByteArrayInputStream(
-          serializedBytes));
+      DataInputStream dis = new DataInputStream(new ByteArrayInputStream(serializedBytes));
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-  public String toString()
-  {
+  public String toString() {
-    buffer.append("ClientUpdateMessageImpl[")
-        .append("op=").append(this._operation)
-        .append(";region=").append(this._regionName)
-        .append(";key=").append(this._keyOfInterest);
+    buffer.append("ClientUpdateMessageImpl[").append("op=").append(this._operation)
+        .append(";region=").append(this._regionName).append(";key=").append(this._keyOfInterest);
-          (this._value instanceof byte[]) ? deserialize((byte[])this._value)
-              : this._value);
+          (this._value instanceof byte[]) ? deserialize((byte[]) this._value) : this._value);
-    buffer
-        .append(";isObject=").append(_valueIsObject)
-        .append(";cbArg=").append(this._callbackArgument)
-        .append(";memberId=").append(this._membershipId)
-        .append(";eventId=").append(_eventIdentifier)
-        .append(";shouldConflate=").append(_shouldConflate)
-        .append(";versionTag=").append(this.versionTag)
-        .append(";hasCqs=").append(this._hasCqs)
+    buffer.append(";isObject=").append(_valueIsObject).append(";cbArg=")
+        .append(this._callbackArgument).append(";memberId=").append(this._membershipId)
+        .append(";eventId=").append(_eventIdentifier).append(";shouldConflate=")
+        .append(_shouldConflate).append(";versionTag=").append(this.versionTag).append(";hasCqs=")
+        .append(this._hasCqs)
-  
-  public void toData(DataOutput out) throws IOException
-  {
+
+  public void toData(DataOutput out) throws IOException {
-    DataSerializer.writeString(_regionName,out);
-    DataSerializer.writeObject(_keyOfInterest,out);
+    DataSerializer.writeString(_regionName, out);
+    DataSerializer.writeObject(_keyOfInterest, out);
-      DataSerializer.writeByteArray((byte[])_value, out);
-    }
-    else {
+      DataSerializer.writeByteArray((byte[]) _value, out);
+    } else {
-    DataSerializer.writeObject(_membershipId,out);
-    //DataSerializer.writeObject(_eventIdentifier,out);
+    DataSerializer.writeObject(_membershipId, out);
+    // DataSerializer.writeObject(_eventIdentifier,out);
-    //if (_hasCqs) {
-    //  DataSerializer.writeHashMap(this._clientCqs, out);
-    //}
-    DataSerializer.writeObject(_callbackArgument ,out);
-    DataSerializer.writeHashSet((HashSet)this._clientInterestList, out);
-    DataSerializer.writeHashSet((HashSet)this._clientInterestListInv, out);
+    // if (_hasCqs) {
+    // DataSerializer.writeHashMap(this._clientCqs, out);
+    // }
+    DataSerializer.writeObject(_callbackArgument, out);
+    DataSerializer.writeHashSet((HashSet) this._clientInterestList, out);
+    DataSerializer.writeHashSet((HashSet) this._clientInterestListInv, out);
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException
-  {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    this._regionName =DataSerializer.readString(in);
+    this._regionName = DataSerializer.readString(in);
-    //this._eventIdentifier = (EventID)DataSerializer.readObject(in);;
+    // this._eventIdentifier = (EventID)DataSerializer.readObject(in);;
-    
-    //if (this._hasCqs) {
-    //  this._clientCqs = DataSerializer.readHashMap(in);
-    //}
+
+    // if (this._hasCqs) {
+    // this._clientCqs = DataSerializer.readHashMap(in);
+    // }
-      ids = (HashSet)ccn.getProxyIDs(ids);
+      ids = (HashSet) ccn.getProxyIDs(ids);
-      ids = (HashSet)ccn.getProxyIDs(ids);
+      ids = (HashSet) ccn.getProxyIDs(ids);
-    
-    this.versionTag = (VersionTag)DataSerializer.readObject(in);
+
+    this.versionTag = (VersionTag) DataSerializer.readObject(in);
-      WrappedCallbackArgument wca = (WrappedCallbackArgument)result;
+      WrappedCallbackArgument wca = (WrappedCallbackArgument) result;
-   * Statically calculate constant overhead for ClientUpdateMessageImpl
-   * instance.
+   * Statically calculate constant overhead for ClientUpdateMessageImpl instance.
-    
+
-    
+
-    //_operation reference = 4 bytes 
-    //_regionName reference = 4 bytes  
-    //_keyOfInterest reference = 4 bytes
-    //_value reference = 4 bytes
-    //_callbackArgument reference = 4 bytes
-    //_membershipId reference = 4 bytes 
-    //_eventIdentifier reference = 4 bytes 
-    //_logger reference = 4 bytes 
-    //_clientCqs reference = 4 bytes 
-    //_clientInterestList reference = 4 bytes 
+    // _operation reference = 4 bytes
+    // _regionName reference = 4 bytes
+    // _keyOfInterest reference = 4 bytes
+    // _value reference = 4 bytes
+    // _callbackArgument reference = 4 bytes
+    // _membershipId reference = 4 bytes
+    // _eventIdentifier reference = 4 bytes
+    // _logger reference = 4 bytes
+    // _clientCqs reference = 4 bytes
+    // _clientInterestList reference = 4 bytes
-    
+
-    // byte _valueIsObject = 1 byte 
-    // boolean _shouldConflate = 1 byte 
-    // boolean _isInterestListPassed = 1 byte 
-    // boolean _hasCqs = 1 byte 
-    // boolean _isNetLoad = 1 byte 
+    // byte _valueIsObject = 1 byte
+    // boolean _shouldConflate = 1 byte
+    // boolean _isInterestListPassed = 1 byte
+    // boolean _hasCqs = 1 byte
+    // boolean _isNetLoad = 1 byte
-    // The hardcoded value below represents the GatewayEventCallbackArgument 
-    // and was estimated using a NullDataOutputStream 
-    size += Sizeable.PER_OBJECT_OVERHEAD + 194; // do we need it 
+    // The hardcoded value below represents the GatewayEventCallbackArgument
+    // and was estimated using a NullDataOutputStream
+    size += Sizeable.PER_OBJECT_OVERHEAD + 194; // do we need it
-  
+
-    
+
-    }
-    else if (obj instanceof Integer) {
+    } else if (obj instanceof Integer) {
-    }
-    else if (obj instanceof Long) {
+    } else if (obj instanceof Long) {
-    }
-    else {
-      size = CachedDeserializableFactory.calcMemSize(obj)
-          - Sizeable.PER_OBJECT_OVERHEAD;
+    } else {
+      size = CachedDeserializableFactory.calcMemSize(obj) - Sizeable.PER_OBJECT_OVERHEAD;
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.tier.sockets.ClientUpdateMessage#needsNoAuthorizationCheck()
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.tier.sockets.ClientUpdateMessage#needsNoAuthorizationCheck()
-  public CqNameToOp getClientCq(ClientProxyMembershipID clientId) {   
-  	if(this._clientCqs!=null){ 
-    	return this._clientCqs.get(clientId);
-    }else{
-    	return null;
+  public CqNameToOp getClientCq(ClientProxyMembershipID clientId) {
+    if (this._clientCqs != null) {
+      return this._clientCqs.get(clientId);
+    } else {
+      return null;
-  
+
-   * Even though this class is just a ConcurrentHashMap I wanted it to be
-   * its own class so it could be easily identified in heap dumps.
-   * The concurrency level on these should be 1 to keep their memory footprint down.
+   * Even though this class is just a ConcurrentHashMap I wanted it to be its own class so it could
+   * be easily identified in heap dumps. The concurrency level on these should be 1 to keep their
+   * memory footprint down.
-  public static class ClientCqConcurrentMap extends ConcurrentHashMap<ClientProxyMembershipID, CqNameToOp> {
+  public static class ClientCqConcurrentMap
+      extends ConcurrentHashMap<ClientProxyMembershipID, CqNameToOp> {
+
+
+
+
+
+
+
-   * Contains either zero or one String to int tuples.
-   * This is a common case and this impl has a much smaller
-   * memory footprint than a HashMap with one entry.
+   * Contains either zero or one String to int tuples. This is a common case and this impl has a
+   * much smaller memory footprint than a HashMap with one entry.
-    private String name;
+    private String[] name;
-  
+
-    
-    private static Map<String,String[]> NAMES_ARRAY = new ConcurrentHashMap<String,String[]>();
-    
+
+
-    
+
-      this.name = name;
-      if (!NAMES_ARRAY.containsKey(name)) {
-        NAMES_ARRAY.put(name, new String[]{name});
-      }
+      this.name = new String[] {name};
-    
+
-        DataSerializer.writeObject(this.name, out);
+        DataSerializer.writeObject(this.name[0], out);
-        message.addStringPart(this.name, true);
+        message.addStringPart(this.name[0], true);
-      return (isEmpty()) ? EMPTY_NAMES_ARRAY : NAMES_ARRAY.get(this.name);
+      return (isEmpty()) ? EMPTY_NAMES_ARRAY : this.name;
-        this.name = name;
+        this.name = new String[] {name};
-      } else if (this.name.equals(name)) {
+      } else if (this.name[0].equals(name)) {
-      if (name.equals(this.name)) {
+      if (name.equals(this.name[0])) {
-   * Basically just a HashMap<String, Integer> but limits itself to the
-   * CqNameToOp interface.
+   * Basically just a HashMap<String, Integer> but limits itself to the CqNameToOp interface.
+
-      add(se.name, se.op);
+      add(se.name[0], se.op);
+
+
+
+
+
+
-  
+

UPD66 UPD66 MOV5 MOV8 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS7 MOV32 MOV22 MOV3 MOV22 INS32 INS42 INS2 INS2 INS2 INS42 INS42 MOV22 INS34 INS40 INS34 INS2 INS2 MOV22 INS3 MOV22 INS34 MOV22 INS34 MOV22 INS34 INS5 INS4 INS43 INS85 INS42 INS42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL43 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL85 DEL5 DEL74 DEL14 DEL59 DEL23 DEL42 DEL42 DEL42 DEL32 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL38 DEL25 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL66 DEL40
Revert " GEODE-6580: Cleanup static analyzer warnings. (#3415)"

This reverts commit 80a32b19c3cdbfe75c37d7b70104ea708739d2cd.

-
+import java.util.Iterator;
-  private static final RawValue NULLVALUE = new RawValue(null);
+  public static final RawValue NULLVALUE = new RawValue(null);
-      rawValue = rawVal;
+      this.rawValue = rawVal;
-      return rawValue instanceof byte[];
+      return this.rawValue instanceof byte[];
-      return rawValue;
+      return this.rawValue;
-        DataSerializer.writeByteArray((byte[]) rawValue, out);
-      } else if (rawValue instanceof CachedDeserializable) {
-        ((CachedDeserializable) rawValue).writeValueAsByteArray(out);
-      } else if (Token.isInvalid(rawValue)) {
+        DataSerializer.writeByteArray((byte[]) this.rawValue, out);
+      } else if (this.rawValue instanceof CachedDeserializable) {
+        ((CachedDeserializable) this.rawValue).writeValueAsByteArray(out);
+      } else if (Token.isInvalid(this.rawValue)) {
-      } else if (rawValue == Token.TOMBSTONE) {
+      } else if (this.rawValue == Token.TOMBSTONE) {
-        DataSerializer.writeObjectAsByteArray(rawValue, out);
+        DataSerializer.writeObjectAsByteArray(this.rawValue, out);
-      return "RawValue(" + rawValue + ")";
+      return "RawValue(" + this.rawValue + ")";
-          byte[] src = (byte[]) rawValue;
+          byte[] src = (byte[]) this.rawValue;
-          System.arraycopy(rawValue, 0, dest, 0, dest.length);
+          System.arraycopy(this.rawValue, 0, dest, 0, dest.length);
-          return rawValue;
+          return this.rawValue;
-      } else if (rawValue instanceof CachedDeserializable) {
+      } else if (this.rawValue instanceof CachedDeserializable) {
-          return ((CachedDeserializable) rawValue).getDeserializedWritableCopy(null, null);
+          return ((CachedDeserializable) this.rawValue).getDeserializedWritableCopy(null, null);
-          return ((CachedDeserializable) rawValue).getDeserializedForReading();
+          return ((CachedDeserializable) this.rawValue).getDeserializedForReading();
-      } else if (Token.isInvalid(rawValue)) {
+      } else if (Token.isInvalid(this.rawValue)) {
-          return CopyHelper.copy(rawValue);
+          return CopyHelper.copy(this.rawValue);
-          return rawValue;
+          return this.rawValue;
+  private static final long serialVersionUID = 1L;
+
-  private final Map<Object, ExpiryTask> pendingSecondaryExpires = new HashMap<>();
+  private final Map<Object, ExpiryTask> pendingSecondaryExpires = new HashMap<Object, ExpiryTask>();
-  private final HashMap<Object, LockObject> allKeysMap = new HashMap<>();
+  public HashMap allKeysMap = new HashMap();
-  AtomicLong5 getEventSeqNum() {
+  public AtomicLong5 getEventSeqNum() {
-    redundancy = internalRegionArgs.getPartitionedRegionBucketRedundancy();
-    partitionedRegion = internalRegionArgs.getPartitionedRegion();
+    this.redundancy = internalRegionArgs.getPartitionedRegionBucketRedundancy();
+    this.partitionedRegion = internalRegionArgs.getPartitionedRegion();
-    if (partitionedRegion.isShadowPR() && partitionedRegion.getColocatedWith() != null) {
-      PartitionedRegion parentPR = ColocationHelper.getLeaderRegion(partitionedRegion);
+    if (this.partitionedRegion.isShadowPR() && this.partitionedRegion.getColocatedWith() != null) {
+      PartitionedRegion parentPR = ColocationHelper.getLeaderRegion(this.partitionedRegion);
-    if (partitionedRegion.getColocatedWith() == null) {
-      eventSeqNum = new AtomicLong5(getId());
+    if (this.partitionedRegion.getColocatedWith() == null) {
+      this.eventSeqNum = new AtomicLong5(getId());
-      PartitionedRegion parentPR = ColocationHelper.getLeaderRegion(partitionedRegion);
+      PartitionedRegion parentPR = ColocationHelper.getLeaderRegion(this.partitionedRegion);
-            partitionedRegion.getFullPath(), getId());
+            this.partitionedRegion.getFullPath(), getId());
-      eventSeqNum = parentBucket.eventSeqNum;
+      this.eventSeqNum = parentBucket.eventSeqNum;
-    createRegionReplyProcessor = processor;
+    this.createRegionReplyProcessor = processor;
-    if (createRegionReplyProcessor != null) {
+    if (this.createRegionReplyProcessor != null) {
-          createRegionReplyProcessor.getEventState(provider);
+          this.createRegionReplyProcessor.getEventState(provider);
-      createRegionReplyProcessor = null;
+      this.createRegionReplyProcessor = null;
-    return getFilterProfile() != null;
+    if (getFilterProfile() != null) {
+      return true;
+    }
+    return false;
-  LockObject searchAndLock(Object[] keys) {
+  LockObject searchAndLock(Object keys[]) {
-      for (Object key : keys) {
-        if (allKeysMap.containsKey(key)) {
-          foundLock = allKeysMap.get(key);
+      for (int i = 0; i < keys.length; i++) {
+        if (allKeysMap.containsKey(keys[i])) {
+          foundLock = (LockObject) allKeysMap.get(keys[i]);
-            logger.debug("LockKeys: found key: {}:{}", key, foundLock.lockedTimeStamp);
+            logger.debug("LockKeys: found key: {}:{}", keys[i], foundLock.lockedTimeStamp);
-        for (Object key : keys) {
+        for (int i = 0; i < keys.length; i++) {
-              new LockObject(key, isDebugEnabled ? System.currentTimeMillis() : 0);
-          allKeysMap.put(key, lockValue);
+              new LockObject(keys[i], isDebugEnabled ? System.currentTimeMillis() : 0);
+          allKeysMap.put(keys[i], lockValue);
-            logger.debug("LockKeys: add key: {}:{}", key, lockValue.lockedTimeStamp);
+            logger.debug("LockKeys: add key: {}:{}", keys[i], lockValue.lockedTimeStamp);
-  public void removeAndNotifyKeys(Object[] keys) {
+  public void removeAndNotifyKeys(Object keys[]) {
-      for (Object key : keys) {
-        LockObject lockValue = allKeysMap.remove(key);
+      for (int i = 0; i < keys.length; i++) {
+        LockObject lockValue = (LockObject) allKeysMap.remove(keys[i]);
-              logger.trace("LockKeys: remove key {}, notifyAll for {}. It waited {}", key,
+              logger.trace("LockKeys: remove key {}, notifyAll for {}. It waited {}", keys[i],
-  public boolean waitUntilLocked(Object[] keys) {
+  public boolean waitUntilLocked(Object keys[]) {
-      if (partitionedRegion.isParallelWanEnabled()) {
+      if (this.partitionedRegion.isParallelWanEnabled()) {
-        RegionEntry oldEntry = entries.basicPut(event, lastModified, ifNew, ifOld,
+        RegionEntry oldEntry = this.entries.basicPut(event, lastModified, ifNew, ifOld,
-  long generateTailKey() {
-    long key = eventSeqNum.addAndGet(partitionedRegion.getTotalNumberOfBuckets());
+  public long generateTailKey() {
+    long key = this.eventSeqNum.addAndGet(this.partitionedRegion.getTotalNumberOfBuckets());
-          eventSeqNum.get());
+          this.eventSeqNum.get());
-    if (eventSeqNum == null) {
+    if (this.eventSeqNum == null) {
-        long key = eventSeqNum.addAndGet(partitionedRegion.getTotalNumberOfBuckets());
+        long key = this.eventSeqNum.addAndGet(this.partitionedRegion.getTotalNumberOfBuckets());
-              eventSeqNum.get());
+              this.eventSeqNum.get());
-        Atomics.setIfGreater(eventSeqNum, event.getTailKey());
+        Atomics.setIfGreater(this.eventSeqNum, event.getTailKey());
-  void updateEventSeqNum(long l) {
-    Atomics.setIfGreater(eventSeqNum, l);
+  public void updateEventSeqNum(long l) {
+    Atomics.setIfGreater(this.eventSeqNum, l);
-          event.getPutAllOperation().addEntry(event, getId());
+          event.getPutAllOperation().addEntry(event, this.getId());
-            logger.debug("sent update operation : for region  : {}: with event: {}", getName(),
+            logger.debug("sent update operation : for region  : {}: with event: {}", this.getName(),
-      if (partitionedRegion.getDataStore().hasClientInterest(event)) {
+      if (this.partitionedRegion.getDataStore().hasClientInterest(event)) {
-              logger.debug("generated version tag {} in region {}", v, getName());
+              logger.debug("generated version tag {} in region {}", v, this.getName());
-          long start = partitionedRegion.getPrStats().startSendReplication();
+          long start = this.partitionedRegion.getPrStats().startSendReplication();
-            partitionedRegion.getPrStats().endSendReplication(start);
+            this.partitionedRegion.getPrStats().endSendReplication(start);
-      return super.basicPutPart2(event, entry, isInitialized, lastModified, clearConflict);
+      long lastModifiedTime =
+          super.basicPutPart2(event, entry, isInitialized, lastModified, clearConflict);
+      return lastModifiedTime;
-      event.setRegion(partitionedRegion);
-      partitionedRegion.notifyGatewaySender(operation, event);
+      event.setRegion(this.partitionedRegion);
+      this.partitionedRegion.notifyGatewaySender(operation, event);
-      partitionedRegion.checkReadiness();
+      this.partitionedRegion.checkReadiness();
-    Object[] keys = new Object[1];
+    Object keys[] = new Object[1];
-            entries.invalidate(event, invokeCallbacks, forceNewEntry, forceCallbacks);
+            this.entries.invalidate(event, invokeCallbacks, forceNewEntry, forceCallbacks);
+        return;
+        return;
-            logger.debug("generated version tag {} in region {}", v, getName());
+            logger.debug("generated version tag {} in region {}", v, this.getName());
-    event.region = partitionedRegion;
+    event.region = this.partitionedRegion;
-    return getConcurrencyChecksEnabled()
+    return this.getConcurrencyChecksEnabled()
-    } catch (PrimaryBucketException ignored) {
+      return;
+    } catch (PrimaryBucketException e) {
+      return;
+    ExpiryTask task = expiryTask;
-        synchronized (pendingSecondaryExpires) {
-          if (expiryTask.isPending()) {
-            Object key = expiryTask.getKey();
+        synchronized (this.pendingSecondaryExpires) {
+          if (task.isPending()) {
+            Object key = task.getKey();
-              pendingSecondaryExpires.put(key, expiryTask);
+              this.pendingSecondaryExpires.put(key, task);
-        super.performExpiryTimeout(expiryTask);
+        super.performExpiryTimeout(task);
-  private boolean isEntryEvictDestroyEnabled() {
+  protected boolean isEntryEvictDestroyEnabled() {
-  void processPendingSecondaryExpires() {
+  protected void processPendingSecondaryExpires() {
-      synchronized (pendingSecondaryExpires) {
-        if (pendingSecondaryExpires.isEmpty()) {
+      synchronized (this.pendingSecondaryExpires) {
+        if (this.pendingSecondaryExpires.isEmpty()) {
-        tasks = new ExpiryTask[pendingSecondaryExpires.size()];
-        tasks = pendingSecondaryExpires.values().toArray(tasks);
-        pendingSecondaryExpires.clear();
+        tasks = new ExpiryTask[this.pendingSecondaryExpires.size()];
+        tasks = this.pendingSecondaryExpires.values().toArray(tasks);
+        this.pendingSecondaryExpires.clear();
-        if (isCacheClosing() || isClosed() || isDestroyed) {
+        if (isCacheClosing() || isClosed() || this.isDestroyed) {
-        for (ExpiryTask task : tasks) {
+        for (int i = 0; i < tasks.length; i++) {
-              logger.debug("{} fired at {}", task, System.currentTimeMillis());
+              logger.debug("{} fired at {}", tasks[i], System.currentTimeMillis());
-            task.basicPerformTimeout(true);
+            tasks[i].basicPerformTimeout(true);
-      } catch (RegionDestroyedException ignored) {
+      } catch (RegionDestroyedException re) {
-      } catch (CancelException ignored) {
+      } catch (CancelException ex) {
-      if (partitionedRegion.isParallelWanEnabled()) {
+      if (this.partitionedRegion.isParallelWanEnabled()) {
+        return;
+        return;
-          event.getRemoveAllOperation().addEntry(event, getId());
+          event.getRemoveAllOperation().addEntry(event, this.getId());
-            logger.debug("generated version tag {} in region {}", v, getName());
+            logger.debug("generated version tag {} in region {}", v, this.getName());
-          entries.updateEntryVersion(event);
+          this.entries.updateEntryVersion(event);
+        return;
-    return redundancy;
+    return this.redundancy;
-        String.format("This should never be called on %s", getClass()));
+        String.format("This should never be called on %s",
+            getClass()));
-    return isBucketDestroyed() || (partitionedRegion != null
-        && partitionedRegion.isLocallyDestroyed && !isInDestroyingThread());
+    return isBucketDestroyed() || (this.partitionedRegion != null
+        && this.partitionedRegion.isLocallyDestroyed && !isInDestroyingThread());
-    return partitionedRegion;
+    return this.partitionedRegion;
-    return partitionedRegion.locallyDestroyingThread == Thread.currentThread();
+    return this.partitionedRegion.locallyDestroyingThread == Thread.currentThread();
-    bp.isInitializing = getInitializationLatchAfterGetInitialImage().getCount() > 0;
+    bp.isInitializing = this.getInitializationLatchAfterGetInitialImage().getCount() > 0;
-  boolean isPartitionedRegionOpen() {
-    return !partitionedRegion.isLocallyDestroyed && !partitionedRegion.isClosed
-        && !partitionedRegion.isDestroyed();
+  public boolean isPartitionedRegionOpen() {
+    return !this.partitionedRegion.isLocallyDestroyed && !this.partitionedRegion.isClosed
+        && !this.partitionedRegion.isDestroyed();
+   * @throws IOException if there is a serialization problem see
+   *         LocalRegion#getDeserializedValue(RegionEntry, KeyInfo, boolean, boolean, boolean,
+   *         EntryEventImpl, boolean, boolean, boolean)
-      throws EntryNotFoundException {
-    RegionEntry re;
-    re = entries.getEntry(key);
+      throws EntryNotFoundException, IOException {
+    RegionEntry re = null;
+    re = this.entries.getEntry(key);
-    Object v;
+    Object v = null;
-      handleDiskAccessException(dae);
+      this.handleDiskAccessException(dae);
-      boolean isCreate;
+      RawValue valueBytes = NULLVALUE;
+      boolean isCreate = false;
-    return "BucketRegion" + "[path='" + getFullPath()
-        + ";serial=" + getSerialNumber() + ";primary="
-        + getBucketAdvisor().getProxyBucketRegion().isPrimary() + "]";
+    return new StringBuilder().append("BucketRegion").append("[path='").append(getFullPath())
+        .append(";serial=").append(getSerialNumber()).append(";primary=")
+        .append(getBucketAdvisor().getProxyBucketRegion().isPrimary()).append("]").toString();
-    distAdvisor.removeMembershipListener(advisorListener);
+    this.distAdvisor.removeMembershipListener(this.advisorListener);
-  void removeFromPeersAdvisors(boolean rebalance) {
+  public void removeFromPeersAdvisors(boolean rebalance) {
-  private EntryEventImpl createEventForPR(EntryEventImpl sourceEvent) {
+  EntryEventImpl createEventForPR(EntryEventImpl sourceEvent) {
-      e2.setRegion(partitionedRegion);
+      e2.setRegion(this.partitionedRegion);
-      DistributedMember dm = getDistributionManager().getDistributionManagerId();
+      DistributedMember dm = this.getDistributionManager().getDistributionManagerId();
-    if (isInitialized()) {
+    if (this.isInitialized()) {
-      partitionedRegion.invokeTXCallbacks(eventType, prevent,
-          partitionedRegion.isInitialized() && callDispatchListenerEvent);
+      this.partitionedRegion.invokeTXCallbacks(eventType, prevent,
+          this.partitionedRegion.isInitialized() ? callDispatchListenerEvent : false);
-    if (isInitialized()) {
+    if (this.isInitialized()) {
-          && getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
+          && this.getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
-      partitionedRegion.invokeDestroyCallbacks(eventType, prevent,
-          partitionedRegion.isInitialized() && callDispatchListenerEvent, false);
+      this.partitionedRegion.invokeDestroyCallbacks(eventType, prevent,
+          this.partitionedRegion.isInitialized() ? callDispatchListenerEvent : false, false);
-    if (isInitialized()) {
+    if (this.isInitialized()) {
-          && getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
+          && this.getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
-      partitionedRegion.invokeInvalidateCallbacks(eventType, prevent,
-          partitionedRegion.isInitialized() && callDispatchListenerEvent);
+      this.partitionedRegion.invokeInvalidateCallbacks(eventType, prevent,
+          this.partitionedRegion.isInitialized() ? callDispatchListenerEvent : false);
-    if (isInitialized()) {
+    if (this.isInitialized()) {
-          && getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
+          && this.getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
-      partitionedRegion.invokePutCallbacks(eventType, prevent,
-          partitionedRegion.isInitialized() && callDispatchListenerEvent, false);
+      this.partitionedRegion.invokePutCallbacks(eventType, prevent,
+          this.partitionedRegion.isInitialized() ? callDispatchListenerEvent : false, false);
-   * perform adjunct messaging for the given operation
+   * perform adjunct messaging for the given operation and return a set of members that should be
+   * attached to the operation's reply processor (if any)
+   * @return the set of failed recipients
-  void performAdjunctMessaging(EntryEventImpl event, Set cacheOpRecipients,
-      Set adjunctRecipients, FilterRoutingInfo filterRoutingInfo,
-      DirectReplyProcessor processor,
+  protected Set performAdjunctMessaging(EntryEventImpl event, Set cacheOpRecipients,
+      Set adjunctRecipients, FilterRoutingInfo filterRoutingInfo, DirectReplyProcessor processor,
+    Set failures = Collections.emptySet();
-      msg.setSender(partitionedRegion.getDistributionManager().getDistributionManagerId());
+      msg.setSender(this.partitionedRegion.getDistributionManager().getDistributionManagerId());
-      msg.relayToListeners(cacheOpRecipients, adjunctRecipients, filterRoutingInfo,
-          event, partitionedRegion, processor);
+      failures = msg.relayToListeners(cacheOpRecipients, adjunctRecipients, filterRoutingInfo,
+          event, this.partitionedRegion, processor);
-        PutMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
-            filterRoutingInfo, partitionedRegion, event, op.isCreate(), !op.isCreate(),
+        failures = PutMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
+            filterRoutingInfo, this.partitionedRegion, event, op.isCreate(), !op.isCreate(),
-        DestroyMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
-            filterRoutingInfo, partitionedRegion, event, processor);
+        failures = DestroyMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
+            filterRoutingInfo, this.partitionedRegion, event, processor);
-        InvalidateMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
-            filterRoutingInfo, partitionedRegion, event, processor);
+        failures = InvalidateMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
+            filterRoutingInfo, this.partitionedRegion, event, processor);
+      } else {
+        failures = adjunctRecipients;
+    return failures;
-    if (partitionedRegion.getSystem().getConfig().getDeltaPropagation()
+    if (this.partitionedRegion.getSystem().getConfig().getDeltaPropagation()
-          partitionedRegion.getCachePerfStats().endDeltaPrepared(start);
+          this.partitionedRegion.getCachePerfStats().endDeltaPrepared(start);
+   * @return the set of failed recipients
-  void performPutAllAdjunctMessaging(DistributedPutAllOperation dpao, Set cacheOpRecipients,
-      Set<InternalDistributedMember> adjunctRecipients, FilterRoutingInfo filterRoutingInfo,
-      DirectReplyProcessor processor) {
+  public Set performPutAllAdjunctMessaging(DistributedPutAllOperation dpao, Set cacheOpRecipients,
+      Set adjunctRecipients, FilterRoutingInfo filterRoutingInfo, DirectReplyProcessor processor) {
+    // create a PutAllPRMessage out of PutAllMessage to send to adjunct nodes
-    prMsg.initMessage(partitionedRegion, adjunctRecipients, true, processor);
-    prMsg.setSender(partitionedRegion.getDistributionManager().getDistributionManagerId());
-    partitionedRegion.getDistributionManager().putOutgoing(prMsg);
+    prMsg.initMessage(this.partitionedRegion, adjunctRecipients, true, processor);
+    prMsg.setSender(this.partitionedRegion.getDistributionManager().getDistributionManagerId());
+
+    // find members who have clients subscribed to this event and add them
+    // to the recipients list. Also determine if there are any FilterInfo
+    // routing tables for any of the receivers
+    // boolean anyWithRouting = false;
+    Set recipients = null;
+    Set membersWithRouting = filterRoutingInfo.getMembers();
+    for (Iterator it = membersWithRouting.iterator(); it.hasNext();) {
+      Object mbr = it.next();
+      if (!cacheOpRecipients.contains(mbr)) {
+        // anyWithRouting = true;
+        if (!adjunctRecipients.contains(mbr)) {
+          if (recipients == null) {
+            recipients = new HashSet();
+            recipients.add(mbr);
+          }
+        }
+      }
+    }
+    if (recipients == null) {
+      recipients = adjunctRecipients;
+    } else {
+      recipients.addAll(adjunctRecipients);
+    }
+
+    // Set failures = Collections.EMPTY_SET;
+
+    // if (!anyWithRouting) {
+    Set failures = this.partitionedRegion.getDistributionManager().putOutgoing(prMsg);
+
+    return failures;
-  void performRemoveAllAdjunctMessaging(DistributedRemoveAllOperation op,
-      Set cacheOpRecipients, Set<InternalDistributedMember> adjunctRecipients,
-      FilterRoutingInfo filterRoutingInfo,
+  public Set performRemoveAllAdjunctMessaging(DistributedRemoveAllOperation op,
+      Set cacheOpRecipients, Set adjunctRecipients, FilterRoutingInfo filterRoutingInfo,
-    prMsg.initMessage(partitionedRegion, adjunctRecipients, true, processor);
-    prMsg.setSender(partitionedRegion.getDistributionManager().getDistributionManagerId());
-    partitionedRegion.getDistributionManager().putOutgoing(prMsg);
+    prMsg.initMessage(this.partitionedRegion, adjunctRecipients, true, processor);
+    prMsg.setSender(this.partitionedRegion.getDistributionManager().getDistributionManagerId());
+
+    // find members who have clients subscribed to this event and add them
+    // to the recipients list. Also determine if there are any FilterInfo
+    // routing tables for any of the receivers
+    Set recipients = null;
+    Set membersWithRouting = filterRoutingInfo.getMembers();
+    for (Iterator it = membersWithRouting.iterator(); it.hasNext();) {
+      Object mbr = it.next();
+      if (!cacheOpRecipients.contains(mbr)) {
+        // anyWithRouting = true;
+        if (!adjunctRecipients.contains(mbr)) {
+          if (recipients == null) {
+            recipients = new HashSet();
+            recipients.add(mbr);
+          }
+        }
+      }
+    }
+    if (recipients == null) {
+      recipients = adjunctRecipients;
+    } else {
+      recipients.addAll(adjunctRecipients);
+    }
+
+    Set failures = this.partitionedRegion.getDistributionManager().putOutgoing(prMsg);
+    return failures;
-  protected Set<InternalDistributedMember> getAdjunctReceivers(EntryEventImpl event,
-      Set<InternalDistributedMember> cacheOpReceivers, Set<InternalDistributedMember> twoMessages,
+  protected Set getAdjunctReceivers(EntryEventImpl event, Set cacheOpReceivers, Set twoMessages,
-      Set<InternalDistributedMember> r =
-          partitionedRegion.getRegionAdvisor().adviseRequiresNotification();
-      r.removeAll(cacheOpReceivers);
+      Set r = this.partitionedRegion.getRegionAdvisor().adviseRequiresNotification(event);
+
+      if (r.size() > 0) {
+        r.removeAll(cacheOpReceivers);
+      }
-              r = new HashSet<>();
+              r = new HashSet();
-      event.setRegion(partitionedRegion);
-      partitionedRegion.cacheWriteBeforePut(event, netWriteRecipients, localWriter,
+      event.setRegion(this.partitionedRegion);
+      this.partitionedRegion.cacheWriteBeforePut(event, netWriteRecipients, localWriter,
+    boolean ret = false;
-      event.setRegion(partitionedRegion);
-      return partitionedRegion.cacheWriteBeforeDestroy(event, expectedOldValue);
+      event.setRegion(this.partitionedRegion);
+      ret = this.partitionedRegion.cacheWriteBeforeDestroy(event, expectedOldValue);
+    return ret;
+    // return super.cacheWriteBeforeDestroy(event);
-    return partitionedRegion.basicGetWriter();
+    return this.partitionedRegion.basicGetWriter();
-  public Set<InternalDistributedMember> getBucketOwners() {
+  public Set getBucketOwners() {
-  void updateCounter(long delta) {
+  public void updateCounter(long delta) {
-      counter.getAndAdd(delta);
+      this.counter.getAndAdd(delta);
-    if (counter.get() != 0) {
-      counter.set(0);
+    if (this.counter.get() != 0) {
+      this.counter.set(0);
-    if (limit == null) {
+    if (this.limit == null) {
-  private static int calcMemSize(Object value) {
+  static int calcMemSize(Object value) {
-    final PartitionedRegionDataStore prDs = partitionedRegion.getDataStore();
+    final PartitionedRegionDataStore prDs = this.partitionedRegion.getDataStore();
-    if (isDestroyed || isDestroyingDiskRegion) {
+    if (this.isDestroyed || this.isDestroyingDiskRegion) {
-      oldMemValue = bytesInMemory.getAndSet(BUCKET_DESTROYED);
+      oldMemValue = this.bytesInMemory.getAndSet(BUCKET_DESTROYED);
-    } else if (!isInitialized()) {
+    } else if (!this.isInitialized()) {
-      oldMemValue = bytesInMemory.getAndSet(0);
+      oldMemValue = this.bytesInMemory.getAndSet(0);
-      partitionedRegion.getPrStats().incDataStoreEntryCount(-sizeBeforeClear);
+      this.partitionedRegion.getPrStats().incDataStoreEntryCount(-sizeBeforeClear);
-    partitionedRegion.getPrStats().incDataStoreEntryCount(1);
+    this.partitionedRegion.getPrStats().incDataStoreEntryCount(1);
-    partitionedRegion.getPrStats().incDataStoreEntryCount(-1);
+    this.partitionedRegion.getPrStats().incDataStoreEntryCount(-1);
-    updateBucket2Size(oldSize, oldSize, SizeOp.EVICT);
-    return oldSize;
+    int newDiskSize = oldSize;
+    updateBucket2Size(oldSize, newDiskSize, SizeOp.EVICT);
+    return newDiskSize;
-    long result = bytesInMemory.get();
+    long result = this.bytesInMemory.get();
-    long result = bytesInMemory.get();
+    long result = this.bytesInMemory.get();
-  void preDestroyBucket(int bucketId) {}
+  public void preDestroyBucket(int bucketId) {}
-    preDestroyBucket(getId());
+    this.preDestroyBucket(this.getId());
-  void invokePartitionListenerAfterBucketRemoved() {
+  protected void invokePartitionListenerAfterBucketRemoved() {
-    for (PartitionListener listener : partitionListeners) {
+    for (int i = 0; i < partitionListeners.length; i++) {
+      PartitionListener listener = partitionListeners[i];
-  void invokePartitionListenerAfterBucketCreated() {
+  protected void invokePartitionListenerAfterBucketCreated() {
-    for (PartitionListener listener : partitionListeners) {
+    for (int i = 0; i < partitionListeners.length; i++) {
+      PartitionListener listener = partitionListeners[i];
-  private void updateBucket2Size(int oldSize, int newSize, SizeOp op) {
+  void updateBucket2Size(int oldSize, int newSize, SizeOp op) {
-  private void updateBucketMemoryStats(final int memoryDelta) {
+  void updateBucketMemoryStats(final int memoryDelta) {
-    final PartitionedRegionDataStore prDS = partitionedRegion.getDataStore();
+    final PartitionedRegionDataStore prDS = this.partitionedRegion.getDataStore();
-    return numOverflowOnDisk.get();
+    return this.numOverflowOnDisk.get();
-    return numOverflowBytesOnDisk.get();
+    return this.numOverflowBytesOnDisk.get();
-    return numEntriesInVM.get();
+    return this.numEntriesInVM.get();
-    numOverflowOnDisk.addAndGet(delta);
+    this.numOverflowOnDisk.addAndGet(delta);
-    numOverflowBytesOnDisk.addAndGet(delta);
+    this.numOverflowBytesOnDisk.addAndGet(delta);
-    numEntriesInVM.addAndGet(delta);
+    this.numEntriesInVM.addAndGet(delta);
-    evictions.getAndAdd(1);
+    this.evictions.getAndAdd(1);
-    return evictions.get();
+    return this.evictions.get();
-    EvictionAttributes ea = getAttributes().getEvictionAttributes();
+    EvictionAttributes ea = this.getAttributes().getEvictionAttributes();
-    return action.isLocalDestroy() ? getRegionMap().sizeInVM() : (int) getNumEntriesInVM();
+    int size =
+        action.isLocalDestroy() ? this.getRegionMap().sizeInVM() : (int) this.getNumEntriesInVM();
+    return size;
-    return partitionedRegion.getFilterProfile();
+    return this.partitionedRegion.getFilterProfile();
-    partitionedRegion.setCloningEnabled(isCloningEnabled);
+    this.partitionedRegion.setCloningEnabled(isCloningEnabled);
-    return partitionedRegion.getCloningEnabled();
+    return this.partitionedRegion.getCloningEnabled();
-  void beforeReleasingPrimaryLockDuringDemotion() {}
+  public void beforeReleasingPrimaryLockDuringDemotion() {}
+  public boolean areSecondariesPingable() {
+
+    Set<InternalDistributedMember> hostingservers =
+        this.partitionedRegion.getRegionAdvisor().getBucketOwners(this.getId());
+    hostingservers.remove(cache.getDistributedSystem().getDistributedMember());
+
+    if (cache.getLogger().fineEnabled())
+      cache.getLogger()
+          .fine("Pinging secondaries of bucket " + this.getId() + " on servers " + hostingservers);
+
+    if (hostingservers.size() == 0)
+      return true;
+
+    return ServerPingMessage.send(cache, hostingservers);
+
+  }
+
-    DiskRegion dr = getDiskRegion();
+    DiskRegion dr = this.getDiskRegion();
-    return getPartitionedRegion().getFullPath();
+    return this.getPartitionedRegion().getFullPath();
-    entries.close(this);
+    this.entries.close(this);
-    return entries.clear(rvv, this);
+    return this.entries.clear(rvv, this);

INS26 MOV31 INS40 INS23 INS23 INS31 UPD83 MOV83 INS83 MOV83 INS39 INS59 MOV74 INS83 MOV43 MOV59 INS83 INS83 INS83 UPD83 INS83 INS83 INS43 INS83 INS83 INS43 INS83 INS43 INS83 INS43 INS43 MOV78 UPD39 UPD42 MOV44 MOV44 MOV44 MOV44 MOV44 MOV43 MOV43 MOV78 UPD39 UPD42 MOV44 MOV44 MOV43 MOV43 MOV43 INS43 INS83 MOV78 INS83 INS83 INS83 MOV78 MOV78 INS83 INS83 INS39 INS42 INS8 MOV78 MOV78 INS42 INS34 UPD42 UPD42 INS25 INS41 INS43 INS85 INS43 INS85 INS43 INS85 INS60 INS65 INS42 INS65 INS42 INS60 INS41 INS65 INS42 INS43 INS60 INS60 INS24 INS25 INS60 INS41 INS42 INS43 INS60 INS60 INS24 INS25 INS60 INS41 MOV42 INS43 INS43 INS60 INS41 MOV42 INS60 INS24 INS24 INS60 INS41 INS60 INS21 INS25 INS25 INS41 UPD74 MOV43 MOV27 INS8 INS9 MOV42 MOV42 MOV42 INS32 INS43 MOV43 INS59 INS22 INS22 INS42 INS66 INS66 INS66 INS32 MOV8 INS8 MOV8 MOV8 MOV8 MOV8 UPD66 INS66 INS66 INS43 INS59 INS42 INS66 MOV42 INS43 INS59 INS43 INS59 INS58 INS32 INS8 INS27 INS8 INS8 INS43 INS59 INS42 MOV42 INS43 INS59 INS43 INS59 INS58 INS32 INS8 INS27 INS8 INS8 INS43 INS59 INS42 MOV42 MOV42 INS39 INS59 INS42 MOV43 INS39 INS59 UPD42 INS58 INS27 INS37 MOV8 INS58 INS27 INS37 MOV8 MOV43 INS39 INS59 INS42 MOV74 INS59 INS32 INS32 INS21 INS27 INS41 INS32 INS22 MOV43 INS43 INS22 INS22 INS22 INS22 MOV41 INS24 INS24 INS42 INS42 INS22 INS22 INS60 MOV42 INS85 INS22 INS41 INS42 INS42 INS52 INS42 INS52 INS42 INS22 INS33 INS33 INS60 INS32 INS42 INS22 INS22 INS52 INS52 MOV60 INS25 MOV21 INS52 INS52 MOV60 MOV21 INS42 INS42 INS32 INS22 INS42 INS42 INS33 INS42 INS42 INS32 INS43 INS59 INS42 INS42 INS60 INS25 INS42 INS33 INS21 INS21 INS42 INS42 INS32 INS22 INS42 INS42 INS33 INS42 INS42 INS32 INS43 INS59 INS42 INS42 INS60 INS25 INS42 INS33 INS21 INS21 INS42 INS42 INS32 INS25 INS21 INS42 INS9 INS22 INS22 INS22 INS22 INS42 INS42 UPD42 INS52 INS39 INS59 INS42 INS40 INS42 INS60 INS39 INS59 INS42 INS40 INS42 INS60 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS42 INS16 INS22 INS22 INS22 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS32 INS32 INS34 INS9 INS42 INS42 INS42 INS42 INS22 INS22 INS22 INS22 INS52 INS42 INS22 INS42 INS52 INS42 INS52 INS42 INS22 MOV43 INS22 MOV43 INS52 INS42 INS52 INS42 INS9 INS58 INS27 INS37 INS8 INS58 INS27 INS37 MOV8 INS22 INS52 INS42 INS52 INS42 INS39 INS59 INS42 INS52 INS42 INS52 UPD42 INS41 INS22 INS22 INS42 INS22 INS22 INS22 INS43 INS59 INS32 INS42 INS45 INS52 INS42 INS52 INS42 INS27 MOV8 INS42 INS42 INS7 INS52 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS59 INS38 INS8 INS7 INS32 MOV32 MOV42 MOV42 INS52 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS59 INS38 INS8 INS7 INS32 MOV32 MOV42 MOV42 INS43 INS27 INS8 INS32 INS7 INS52 INS42 INS22 INS52 INS42 INS22 INS52 INS42 INS52 INS42 INS22 INS22 INS22 INS22 INS52 INS42 INS34 MOV43 INS59 INS42 INS34 MOV43 INS59 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 MOV32 MOV32 MOV11 INS52 INS42 INS52 INS42 INS52 INS42 INS32 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS42 INS27 INS42 INS42 INS52 INS52 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 MOV8 INS52 INS42 INS22 MOV8 INS52 INS42 INS22 INS52 INS42 INS22 INS22 INS22 INS39 INS59 INS42 INS40 INS42 MOV25 INS24 INS39 INS59 INS42 INS40 INS42 INS22 INS52 INS42 INS22 INS42 MOV48 INS22 INS22 INS22 INS41 INS41 INS52 INS42 INS24 INS22 INS41 INS41 INS41 INS52 INS42 INS22 INS42 INS22 INS42 INS22 INS52 INS42 INS42 INS42 INS42 INS9 INS32 INS42 MOV32 INS22 INS22 INS16 MOV32 INS32 INS22 INS16 INS9 MOV32 INS22 INS16 INS42 MOV32 INS22 INS16 INS9 INS42 INS32 INS22 INS42 INS42 INS42 INS42 INS32 INS32 INS25 INS42 INS42 INS42 INS42 INS42 INS22 INS22 INS42 INS42 INS42 INS42 INS32 INS32 INS25 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS32 INS34 MOV21 INS22 INS22 UPD42 MOV42 MOV42 INS42 INS42 INS42 MOV42 INS22 INS42 INS32 INS22 INS52 INS42 INS22 INS52 INS42 INS52 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS2 INS42 INS2 INS52 INS42 INS52 INS22 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS45 INS42 INS52 INS42 INS22 MOV8 INS52 INS42 INS22 INS52 INS42 INS22 INS52 INS42 INS22 INS52 INS42 INS22 INS52 INS42 INS42 INS34 INS58 INS27 INS37 INS8 INS42 INS34 MOV43 INS52 INS42 INS52 INS42 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS58 INS27 INS37 MOV8 UPD42 UPD42 INS52 INS42 INS22 INS52 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS32 INS42 INS45 INS52 INS42 INS52 INS42 INS32 INS42 INS9 INS32 INS42 MOV32 INS52 INS42 INS32 INS42 INS9 INS52 INS42 INS32 INS42 INS9 INS52 INS42 INS32 INS42 INS9 MOV42 MOV42 MOV42 MOV42 MOV42 MOV42 INS22 MOV42 INS7 INS8 INS22 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS38 MOV8 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS38 INS8 INS52 INS42 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 UPD42 MOV42 MOV42 MOV42 INS52 INS42 INS52 INS42 INS22 INS22 INS42 INS42 INS42 INS42 INS52 INS52 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS22 MOV5 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS2 INS39 INS59 INS42 INS40 INS42 MOV60 MOV21 MOV25 INS11 INS52 INS42 INS22 INS52 INS42 INS52 INS42 UPD42 INS22 INS22 INS22 INS39 INS59 INS42 INS40 INS42 INS22 INS22 INS42 INS32 INS42 MOV32 INS52 INS22 MOV42 INS52 INS42 INS22 MOV42 INS52 INS22 MOV42 INS52 INS22 MOV42 INS22 INS52 INS42 INS42 INS32 INS7 INS21 INS52 INS42 INS32 INS32 INS25 INS22 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS22 INS42 INS42 INS42 INS34 INS43 INS32 INS22 INS22 INS52 INS42 MOV32 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS34 INS52 INS42 INS52 INS42 INS32 INS42 INS45 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 MOV42 MOV42 MOV42 MOV42 MOV42 INS22 MOV42 MOV32 MOV38 MOV42 MOV42 INS42 INS32 INS7 INS7 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS27 INS8 INS52 INS42 INS8 INS52 INS42 INS22 INS22 MOV5 INS22 INS52 INS42 UPD42 INS33 INS33 UPD42 INS22 INS52 INS42 INS11 INS2 INS42 MOV42 MOV42 INS2 INS52 INS42 INS52 INS42 INS22 INS52 INS42 UPD42 INS22 INS22 INS22 INS32 INS42 MOV32 INS52 INS42 MOV42 MOV42 MOV42 MOV42 MOV42 INS22 MOV42 MOV42 INS42 INS32 INS42 INS42 INS42 INS33 INS21 INS42 INS33 INS21 INS21 INS25 MOV21 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 MOV43 INS32 INS2 INS42 INS42 INS42 INS42 INS52 INS42 INS22 INS52 MOV32 INS52 INS42 INS52 INS42 INS52 INS52 INS42 INS32 INS42 INS45 INS52 INS42 MOV42 MOV42 MOV42 MOV42 MOV42 INS22 MOV42 MOV42 INS22 INS32 INS7 INS32 MOV32 INS8 INS22 INS22 INS52 INS42 MOV42 MOV42 INS2 INS2 INS42 INS42 INS2 INS52 INS42 INS22 INS2 INS14 INS42 INS45 INS52 INS42 INS52 INS42 UPD42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS21 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS52 INS42 INS22 INS52 UPD42 INS42 INS42 INS52 INS43 MOV43 INS43 INS7 INS2 INS52 INS42 INS22 UPD42 INS2 INS42 INS42 INS42 INS14 INS42 INS42 INS52 INS52 INS42 INS42 INS42 INS43 INS42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL33 DEL42 DEL42 DEL42 DEL23 DEL74 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL8 DEL70 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL8 DEL70 DEL43 DEL85 DEL5 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL70 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL44 DEL42 DEL70 DEL42 DEL42 DEL42 DEL42 DEL40 DEL42 DEL40 DEL40 DEL40 DEL42 DEL42 DEL45 DEL45 DEL27 DEL45 DEL45 DEL45 DEL27 DEL42 DEL42 DEL83 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL42 DEL32 DEL42 DEL27 DEL9 DEL42 DEL42 DEL32 DEL42 DEL27 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL25 DEL8 DEL42 DEL42 DEL32 DEL42 DEL27 DEL9 DEL39 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL39 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL74 DEL42 DEL32 DEL21 DEL39 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL21 DEL43 DEL42 DEL43 DEL74 DEL43 DEL42 DEL43 DEL74 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL41 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL44 DEL42 DEL70 DEL42 DEL44 DEL42 DEL70 DEL83 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL16 DEL41 DEL42 DEL42 DEL42 DEL42 DEL42
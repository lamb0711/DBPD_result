Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  private final Map/* <ServerLocation, String[]> */serverGroupMap = new HashMap();
+  private final Map/* <ServerLocation, String[]> */ serverGroupMap = new HashMap();
-  private final ScheduledThreadPoolExecutor estimateTimeoutProcessor = new ScheduledThreadPoolExecutor(
-      1, new ThreadFactory() {
+  private final ScheduledThreadPoolExecutor estimateTimeoutProcessor =
+      new ScheduledThreadPoolExecutor(1, new ThreadFactory() {
-    this.estimateTimeoutProcessor
-        .setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
+    this.estimateTimeoutProcessor.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
-  public void addServer(ServerLocation location, String[] groups,
-      ServerLoad initialLoad) {
+  public void addServer(ServerLocation location, String[] groups, ServerLoad initialLoad) {
-    LoadHolder connectionLoad = new LoadHolder(location,
-        initialLoad.getConnectionLoad(), initialLoad.getLoadPerConnection(),
-        loadPollInterval);
+    LoadHolder connectionLoad = new LoadHolder(location, initialLoad.getConnectionLoad(),
+        initialLoad.getLoadPerConnection(), loadPollInterval);
-    LoadHolder queueLoad = new LoadHolder(location,
-        initialLoad.getSubscriptionConnectionLoad(),
+    LoadHolder queueLoad = new LoadHolder(location, initialLoad.getSubscriptionConnectionLoad(),
-    String[] groups = (String[])serverGroupMap.remove(location);
+    String[] groups = (String[]) serverGroupMap.remove(location);
-     * Adding null check for #41522 - we were getting a remove from a
-     * BridgeServer that was shutting down and the ServerLocation wasn't in this
-     * map. The root cause isn't 100% clear but it might be a race from profile
-     * add / remove from different channels.
+     * Adding null check for #41522 - we were getting a remove from a BridgeServer that was shutting
+     * down and the ServerLocation wasn't in this map. The root cause isn't 100% clear but it might
+     * be a race from profile add / remove from different channels.
-  public synchronized void updateLoad(ServerLocation location,
-      ServerLoad newLoad, List/* <ClientProxyMembershipID> */clientIds) {
-    String[] groups = (String[])serverGroupMap.get(location);
+  public synchronized void updateLoad(ServerLocation location, ServerLoad newLoad,
+      List/* <ClientProxyMembershipID> */ clientIds) {
+    String[] groups = (String[]) serverGroupMap.get(location);
-        cancelClientEstimate((ClientProxyMembershipID)itr.next(), location);
+        cancelClientEstimate((ClientProxyMembershipID) itr.next(), location);
-    Map groupServers = (Map)connectionLoadMap.get(group);
+    Map groupServers = (Map) connectionLoadMap.get(group);
-      Map.Entry next = (Entry)itr.next();
-      LoadHolder nextLoadReference = (LoadHolder)next.getValue();
+      Map.Entry next = (Entry) itr.next();
+      LoadHolder nextLoadReference = (LoadHolder) next.getValue();
-   * @param group
-   *          the group, or null or "" if the client has no server group.
-   * @param excludedServers
-   *          a list of servers to exclude as choices
-   * @return the least loaded server, or null if there are no servers that
-   *         aren't excluded.
+   * @param group the group, or null or "" if the client has no server group.
+   * @param excludedServers a list of servers to exclude as choices
+   * @return the least loaded server, or null if there are no servers that aren't excluded.
-  public synchronized ServerLocation getServerForConnection(String group,
-      Set excludedServers) {
+  public synchronized ServerLocation getServerForConnection(String group, Set excludedServers) {
-    Map groupServers = (Map)connectionLoadMap.get(group);
+    Map groupServers = (Map) connectionLoadMap.get(group);
-      LoadHolder lh = (LoadHolder)bestLHs.get(0);
+      LoadHolder lh = (LoadHolder) bestLHs.get(0);
-   * Get the least loaded servers for the given groups as a map. If the given
-   * array of groups is null then returns the least loaded servers for all the
-   * known groups.
+   * Get the least loaded servers for the given groups as a map. If the given array of groups is
+   * null then returns the least loaded servers for all the known groups.
-  public synchronized Map<String, ServerLocation> getServersForConnection(
-      Collection<String> groups, Set excludedServers) {
+  public synchronized Map<String, ServerLocation> getServersForConnection(Collection<String> groups,
+      Set excludedServers) {
-    Map groupServers = (Map)connectionLoadMap.get(group);
+    Map groupServers = (Map) connectionLoadMap.get(group);
-   * Pick the least loaded server in the given group if currentServer is the
-   * most loaded server. n
+   * Pick the least loaded server in the given group if currentServer is the most loaded server. n
-   * @param group
-   *          the group, or null or "" if the client has no server group.
-   * @param excludedServers
-   *          a list of servers to exclude as choices
-   * @return currentServer if it is not the most loaded, null if there are no
-   *         servers that aren't excluded, otherwise the least loaded server in
-   *         the group.
+   * @param group the group, or null or "" if the client has no server group.
+   * @param excludedServers a list of servers to exclude as choices
+   * @return currentServer if it is not the most loaded, null if there are no servers that aren't
+   *         excluded, otherwise the least loaded server in the group.
-  public synchronized ServerLocation getReplacementServerForConnection(
-      ServerLocation currentServer, String group, Set excludedServers) {
+  public synchronized ServerLocation getReplacementServerForConnection(ServerLocation currentServer,
+      String group, Set excludedServers) {
-    Map groupServers = (Map)connectionLoadMap.get(group);
+    Map groupServers = (Map) connectionLoadMap.get(group);
-    LoadHolder currentServerLH = isCurrentServerMostLoaded(currentServer,
-        groupServers);
+    LoadHolder currentServerLH = isCurrentServerMostLoaded(currentServer, groupServers);
-      LoadHolder bestLH = (LoadHolder)bestLHs.get(0);
+      LoadHolder bestLH = (LoadHolder) bestLHs.get(0);
-   * @param group
-   *          the group, or null or "" if the client has no server group.
-   * @param excludedServers
-   *          a list of servers to exclude as choices
-   * @param count
-   *          how many distinct servers to pick.
-   * @return a list containing the best servers. The size of the list will be
-   *         less than or equal to count, depending on if there are enough
-   *         servers available.
+   * @param group the group, or null or "" if the client has no server group.
+   * @param excludedServers a list of servers to exclude as choices
+   * @param count how many distinct servers to pick.
+   * @return a list containing the best servers. The size of the list will be less than or equal to
+   *         count, depending on if there are enough servers available.
-   * @param id
-   *          the id of the client creating the queue
-   * @param group
-   *          the group, or null or "" if the client has no server group.
-   * @param excludedServers
-   *          a list of servers to exclude as choices
-   * @param count
-   *          how many distinct servers to pick.
-   * @return a list containing the best servers. The size of the list will be
-   *         less than or equal to count, depending on if there are enough
-   *         servers available.
+   * @param id the id of the client creating the queue
+   * @param group the group, or null or "" if the client has no server group.
+   * @param excludedServers a list of servers to exclude as choices
+   * @param count how many distinct servers to pick.
+   * @return a list containing the best servers. The size of the list will be less than or equal to
+   *         count, depending on if there are enough servers available.
-  public synchronized List getServersForQueue(ClientProxyMembershipID id,
-      String group, Set excludedServers, int count) {
+  public synchronized List getServersForQueue(ClientProxyMembershipID id, String group,
+      Set excludedServers, int count) {
-    Map groupServers = (Map)queueLoadMap.get(group);
-    
+    Map groupServers = (Map) queueLoadMap.get(group);
+
-      List/* <LoadHolder> */bestLHs = findBestServers(groupServers,
-          excludedServers, count);
-      ArrayList/* <ServerLocation> */result = new ArrayList(bestLHs.size());
+      List/* <LoadHolder> */ bestLHs = findBestServers(groupServers, excludedServers, count);
+      ArrayList/* <ServerLocation> */ result = new ArrayList(bestLHs.size());
-          LoadHolder load = (LoadHolder)itr.next();
+          LoadHolder load = (LoadHolder) itr.next();
-            task.setFuture(this.estimateTimeoutProcessor.schedule(task,
-                timeout, TimeUnit.MILLISECONDS));
+            task.setFuture(
+                this.estimateTimeoutProcessor.schedule(task, timeout, TimeUnit.MILLISECONDS));
-          LoadHolder load = (LoadHolder)itr.next();
+          LoadHolder load = (LoadHolder) itr.next();
-   * Test hook to get the current load for all servers Returns a map of
-   * ServerLocation->Load for each server.
+   * Test hook to get the current load for all servers Returns a map of ServerLocation->Load for
+   * each server.
-    Map connectionMap = (Map)connectionLoadMap.get(null);
-    Map queueMap = (Map)queueLoadMap.get(null);
+    Map connectionMap = (Map) connectionLoadMap.get(null);
+    Map queueMap = (Map) queueLoadMap.get(null);
-      Map.Entry next = (Entry)itr.next();
-      ServerLocation location = (ServerLocation)next.getKey();
-      LoadHolder connectionLoad = (LoadHolder)next.getValue();
-      LoadHolder queueLoad = (LoadHolder)queueMap.get(location);
+      Map.Entry next = (Entry) itr.next();
+      ServerLocation location = (ServerLocation) next.getKey();
+      LoadHolder connectionLoad = (LoadHolder) next.getValue();
+      LoadHolder queueLoad = (LoadHolder) queueMap.get(location);
-      result.put(
-          location,
-          new ServerLoad(connectionLoad.getLoad(), connectionLoad
-              .getLoadPerConnection(), queueLoad.getLoad(), queueLoad
-              .getLoadPerConnection()));
+      result.put(location,
+          new ServerLoad(connectionLoad.getLoad(), connectionLoad.getLoadPerConnection(),
+              queueLoad.getLoad(), queueLoad.getLoadPerConnection()));
-      Map groupMap = (Map)map.get(groups[i]);
+      Map groupMap = (Map) map.get(groups[i]);
-      Map groupMap = (Map)map.get(null);
+      Map groupMap = (Map) map.get(null);
-      Map groupMap = (Map)map.get(groups[i]);
+      Map groupMap = (Map) map.get(groups[i]);
-    Map groupMap = (Map)map.get(null);
+    Map groupMap = (Map) map.get(null);
-  private void updateMap(Map map, ServerLocation location, float load,
-      float loadPerConnection) {
-    Map groupMap = (Map)map.get(null);
-    LoadHolder holder = (LoadHolder)groupMap.get(location);
-    if(holder!=null) {
+  private void updateMap(Map map, ServerLocation location, float load, float loadPerConnection) {
+    Map groupMap = (Map) map.get(null);
+    LoadHolder holder = (LoadHolder) groupMap.get(location);
+    if (holder != null) {
-  private List/* <LoadHolder> */findBestServers(Map groupServers,
-      Set excludedServers, int count) {
+  private List/* <LoadHolder> */ findBestServers(Map groupServers, Set excludedServers, int count) {
-        LoadHolder l1 = (LoadHolder)o1;
-        LoadHolder l2 = (LoadHolder)o2;
+        LoadHolder l1 = (LoadHolder) o1;
+        LoadHolder l2 = (LoadHolder) o2;
-      Map.Entry next = (Entry)itr.next();
-      ServerLocation location = (ServerLocation)next.getKey();
+      Map.Entry next = (Entry) itr.next();
+      ServerLocation location = (ServerLocation) next.getKey();
-      LoadHolder nextLoadReference = (LoadHolder)next.getValue();
+      LoadHolder nextLoadReference = (LoadHolder) next.getValue();
-        LoadHolder lastBestHolder = (LoadHolder)bestEntries.last();
+        LoadHolder lastBestHolder = (LoadHolder) bestEntries.last();
-  private LoadHolder isCurrentServerMostLoaded(ServerLocation currentServer,
-      Map groupServers) {
-    final LoadHolder currentLH = (LoadHolder)groupServers.get(currentServer);
+  private LoadHolder isCurrentServerMostLoaded(ServerLocation currentServer, Map groupServers) {
+    final LoadHolder currentLH = (LoadHolder) groupServers.get(currentServer);
-      Map.Entry next = (Entry)itr.next();
-      ServerLocation location = (ServerLocation)next.getKey();
+      Map.Entry next = (Entry) itr.next();
+      ServerLocation location = (ServerLocation) next.getKey();
-      LoadHolder nextLoadReference = (LoadHolder)next.getValue();
+      LoadHolder nextLoadReference = (LoadHolder) next.getValue();
-  private void cancelClientEstimate(ClientProxyMembershipID id,
-      ServerLocation location) {
+  private void cancelClientEstimate(ClientProxyMembershipID id, ServerLocation location) {
-   * Add the task to the estimate map at the given key and cancel any old task
-   * found
+   * Add the task to the estimate map at the given key and cancel any old task found
-    oldTask = (LoadEstimateTask)this.estimateMap.put(key, task);
+    oldTask = (LoadEstimateTask) this.estimateMap.put(key, task);
-   * @return true it task was removed; false if it was not the task mapped to
-   *         key
+   * @return true it task was removed; false if it was not the task mapped to key
-  protected boolean removeIfPresentEstimate(EstimateMapKey key,
-      LoadEstimateTask task) {
+  protected boolean removeIfPresentEstimate(EstimateMapKey key, LoadEstimateTask task) {
-    oldTask = (LoadEstimateTask)this.estimateMap.remove(key);
+    oldTask = (LoadEstimateTask) this.estimateMap.remove(key);
-   * Used as a key on the estimateMap. These keys are made up of the identity of
-   * the client and server that will be connected by the resource (e.g. queue)
-   * that we are trying to create.
+   * Used as a key on the estimateMap. These keys are made up of the identity of the client and
+   * server that will be connected by the resource (e.g. queue) that we are trying to create.
-    public EstimateMapKey(ClientProxyMembershipID.Identity clientId,
-        ServerLocation serverId) {
+    public EstimateMapKey(ClientProxyMembershipID.Identity clientId, ServerLocation serverId) {
-      EstimateMapKey that = (EstimateMapKey)obj;
-      return this.clientId.equals(that.clientId)
-          && this.serverId.equals(that.serverId);
+      EstimateMapKey that = (EstimateMapKey) obj;
+      return this.clientId.equals(that.clientId) && this.serverId.equals(that.serverId);
-    public LoadHolder(ServerLocation location, float load,
-        float loadPerConnection, long loadPollInterval) {
+    public LoadHolder(ServerLocation location, float load, float loadPerConnection,
+        long loadPollInterval) {
-      return "LoadHolder["
-          + getLoad()
-          + ", "
-          + getLocation()
-          + ", loadPollInterval="
+      return "LoadHolder[" + getLoad() + ", " + getLocation() + ", loadPollInterval="
-          + ((this.estimateCount != 0) ? (", estimates=" + this.estimateCount)
-              : "") + ", " + loadPerConnection + "]";
+          + ((this.estimateCount != 0) ? (", estimates=" + this.estimateCount) : "") + ", "
+          + loadPerConnection + "]";

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import java.util.Properties;
- * Provides access to a remote gemfire VM for purposes of gathering statistics
- * and other info specific to that VM.
+ * Provides access to a remote gemfire VM for purposes of gathering statistics and other info
+ * specific to that VM.
-  
+
-  /** Keeps track of the <code>StatListener</code>s registered on
-   * statistics sampled in the remote VM.  key is listenerId; value is
-   * StatListener. */
-  protected ListenerIdMap statListeners = new ListenerIdMap(); 
+  /**
+   * Keeps track of the <code>StatListener</code>s registered on statistics sampled in the remote
+   * VM. key is listenerId; value is StatListener.
+   */
+  protected ListenerIdMap statListeners = new ListenerIdMap();
-  /** A thread that asynchronously dispatches callbacks to
-   * <code>StatListener</code>s. */
+  /**
+   * A thread that asynchronously dispatches callbacks to <code>StatListener</code>s.
+   */
-  /** The classpath from which to load the classes of objects
-   * inspected from this remote VM. */
+  /**
+   * The classpath from which to load the classes of objects inspected from this remote VM.
+   */
-  /** Has the distributed system member represented by this
-   * <code>GemFireVM</code> become unreachable?  If so, we should not
-   * try to communicate with it. */
+  /**
+   * Has the distributed system member represented by this <code>GemFireVM</code> become
+   * unreachable? If so, we should not try to communicate with it.
+   */
-   * Creates a <code>RemoteApplicationVM</code> in a given distributed
-   * system (<code>agent</code>) with the given <code>id</code>.
+   * Creates a <code>RemoteApplicationVM</code> in a given distributed system (<code>agent</code>)
+   * with the given <code>id</code>.
-   * You MUST invoke {@link #startStatDispatcher()} immediately after
-   * constructing an instance.
+   * You MUST invoke {@link #startStatDispatcher()} immediately after constructing an instance.
-   * @param alertLevel
-   *        The level of {@link Alert}s that this administration
-   *        console should receive from this member of the distributed
-   *        system. 
+   * @param alertLevel The level of {@link Alert}s that this administration console should receive
+   *        from this member of the distributed system.
-  public RemoteGemFireVM(RemoteGfManagerAgent agent, InternalDistributedMember id,
-                         int alertLevel) {
+  public RemoteGemFireVM(RemoteGfManagerAgent agent, InternalDistributedMember id, int alertLevel) {
-      throw new NullPointerException(LocalizedStrings.RemoteGemFireVM_CANNOT_CREATE_A_REMOTEGEMFIREVM_WITH_A_NULL_ID.toLocalizedString());
+      throw new NullPointerException(
+          LocalizedStrings.RemoteGemFireVM_CANNOT_CREATE_A_REMOTEGEMFIREVM_WITH_A_NULL_ID
+              .toLocalizedString());
-  
+
-  
+
-    }
-    catch (OperationCancelledException e) {
+    } catch (OperationCancelledException e) {
+
-  
+
-  
+
-  
-  public File getGemFireDir() {
+
+  public File getGeodeHomeDir() {
-  
+
-  
+
-  
+
-    FetchHostResponse response =
-        (FetchHostResponse) sendAndWait(FetchHostRequest.create());
+    FetchHostResponse response = (FetchHostResponse) sendAndWait(FetchHostRequest.create());
-    this.gemfireDir = response.getGemFireDir();
+    this.gemfireDir = response.getGeodeHomeDir();
-    this.isDedicatedCacheServer = 
-        Boolean.valueOf(response.isDedicatedCacheServer());
+    this.isDedicatedCacheServer = Boolean.valueOf(response.isDedicatedCacheServer());
-   * @return    array of all statistic resources
+   * @return array of all statistic resources
-    FetchStatsResponse resp = (FetchStatsResponse)sendAndWait(FetchStatsRequest.create(null));
+    FetchStatsResponse resp = (FetchStatsResponse) sendAndWait(FetchStatsRequest.create(null));
-   * Retrieves all statistic resources from the remote VM except for those
-   * involving SharedClass.
+   * Retrieves all statistic resources from the remote VM except for those involving SharedClass.
-   * @return    array of non-SharedClass statistic resources
+   * @return array of non-SharedClass statistic resources
-    FetchStatsResponse resp = (FetchStatsResponse)sendAndWait(FetchStatsRequest.create(statisticsTypeName));
+    FetchStatsResponse resp =
+        (FetchStatsResponse) sendAndWait(FetchStatsRequest.create(statisticsTypeName));
-   * Returns information about distributed locks held by the remote
-   * VM. 
+   * Returns information about distributed locks held by the remote VM.
-    FetchDistLockInfoResponse resp = (FetchDistLockInfoResponse)
-      sendAndWait(FetchDistLockInfoRequest.create());
+    FetchDistLockInfoResponse resp =
+        (FetchDistLockInfoResponse) sendAndWait(FetchDistLockInfoRequest.create());
-    
+
-   * Adds a <code>StatListener</code> that is notified when a
-   * statistic in a given statistics instance changes value.
+   * Adds a <code>StatListener</code> that is notified when a statistic in a given statistics
+   * instance changes value.
-   * @param observer
-   *        The listener to be notified
-   * @param observedResource
-   *        The statistics instance to be observed
-   * @param observedStat
-   *        The statistic to be observed
+   * @param observer The listener to be notified
+   * @param observedResource The statistics instance to be observed
+   * @param observedStat The statistic to be observed
-  public void addStatListener(StatListener observer,
-                              StatResource observedResource,
-                              Stat observedStat) {
-    AddStatListenerResponse resp =
-      (AddStatListenerResponse)sendAndWait(AddStatListenerRequest.create(observedResource, observedStat));
+  public void addStatListener(StatListener observer, StatResource observedResource,
+      Stat observedStat) {
+    AddStatListenerResponse resp = (AddStatListenerResponse) sendAndWait(
+        AddStatListenerRequest.create(observedResource, observedStat));
-  
+
-   * Notes that several statistics values have been updated in the
-   * distributed system member modeled by this
-   * <code>RemoteGemFireVM</code> and invokes the {@link
-   * StatListener}s accordingly.  Note that the listener notification
-   * happens asynchronously.
+   * Notes that several statistics values have been updated in the distributed system member modeled
+   * by this <code>RemoteGemFireVM</code> and invokes the {@link StatListener}s accordingly. Note
+   * that the listener notification happens asynchronously.
-   * @param timestamp
-   *        The time at which the statistics were sampled
-   * @param listenerIds
-   *        The <code>id</code>s of the <code>StatListener</code>s to
-   *        be notified.
-   * @param values
-   *        The new values of the statistics
+   * @param timestamp The time at which the statistics were sampled
+   * @param listenerIds The <code>id</code>s of the <code>StatListener</code>s to be notified.
+   * @param values The new values of the statistics
-  
+
-   * Invokes the callback methods on a bunch of
-   * <code>StatListener</code>s in response to a statistics update
-   * message being received.  This method is invoked in its own thread.
+   * Invokes the callback methods on a bunch of <code>StatListener</code>s in response to a
+   * statistics update message being received. This method is invoked in its own thread.
-   * for each listener in statListeners
-   *   call stat value changed if its id is in listenerIds
-   *   call stat value unchanged if its id is not in listenerIds
-   *   call cancelStatListener and statListeners.remove if its id is negative in listenerIds
+   * for each listener in statListeners call stat value changed if its id is in listenerIds call
+   * stat value unchanged if its id is not in listenerIds call cancelStatListener and
+   * statListeners.remove if its id is negative in listenerIds
-  protected void internalCallStatListeners(long timestamp,
-                                         int[] listenerIds,
-                                         double[] values) {
+  protected void internalCallStatListeners(long timestamp, int[] listenerIds, double[] values) {
-    for (int j=0; j<entries.length; j++) {      
+    for (int j = 0; j < entries.length; j++) {
-      StatListener sl = (StatListener)entries[j].getValue();
+      StatListener sl = (StatListener) entries[j].getValue();
-      for (i=0; i<listenerIds.length; i++) {
-        if (listenerIds[i]==listenerId || listenerIds[i]==-listenerId) {
+      for (i = 0; i < listenerIds.length; i++) {
+        if (listenerIds[i] == listenerId || listenerIds[i] == -listenerId) {
-      } else if (listenerIds[i] < 0) { //Stat resource went away
+      } else if (listenerIds[i] < 0) { // Stat resource went away
-    synchronized(this.statListenersLock) {
-      for (Iterator iter=listenersToRemove.iterator(); iter.hasNext(); ) {
-        int i = ((Integer)iter.next()).intValue();
+    synchronized (this.statListenersLock) {
+      for (Iterator iter = listenersToRemove.iterator(); iter.hasNext();) {
+        int i = ((Integer) iter.next()).intValue();
-        cancelStatListener(i);        
+        cancelStatListener(i);
-  
+
-   * Sends a message to the remote VM letting it know that the
-   * listener with the given id no longer needs events set to it.
+   * Sends a message to the remote VM letting it know that the listener with the given id no longer
+   * needs events set to it.
-  
+
-   * Removes a <code>StatListener</code> that receives updates from
-   * the remote member VM.
+   * Removes a <code>StatListener</code> that receives updates from the remote member VM.
-  public void removeStatListener( StatListener observer ) {
+  public void removeStatListener(StatListener observer) {
-  
+
-   * @see FetchSysCfgRequest 
+   * @see FetchSysCfgRequest
-  public void addHealthListener(HealthListener observer,
-                                GemFireHealthConfig cfg) {
+  public void addHealthListener(HealthListener observer, GemFireHealthConfig cfg) {
-      AddHealthListenerResponse response = (AddHealthListenerResponse)
-        sendAndWait(AddHealthListenerRequest.create(cfg));
+      AddHealthListenerResponse response =
+          (AddHealthListenerResponse) sendAndWait(AddHealthListenerRequest.create(cfg));
-  
+
-  
+
-        FetchHealthDiagnosisResponse response = (FetchHealthDiagnosisResponse)
-          sendAndWait(FetchHealthDiagnosisRequest.create(this.healthListenerId, healthCode));
+        FetchHealthDiagnosisResponse response = (FetchHealthDiagnosisResponse) sendAndWait(
+            FetchHealthDiagnosisRequest.create(this.healthListenerId, healthCode));
-        return new String[]{};
+        return new String[] {};
-    FetchSysCfgResponse response = (FetchSysCfgResponse)sendAndWait(FetchSysCfgRequest.create());
+    FetchSysCfgResponse response = (FetchSysCfgResponse) sendAndWait(FetchSysCfgRequest.create());
-  
-  /**
-   * Returns the runtime {@link org.apache.geode.admin.GemFireMemberStatus} from the vm
-   * The idea is this snapshot is similar to stats that represent the current state of a 
-   * running VM. However, this is a bit higher level than a stat 
-   */
-  public GemFireMemberStatus getSnapshot(){
-	    RefreshMemberSnapshotResponse response = 
-	    	(RefreshMemberSnapshotResponse)sendAndWait(RefreshMemberSnapshotRequest.create());
-	    return response.getSnapshot();
-  }
-   * Returns the runtime {@link org.apache.geode.admin.RegionSubRegionSnapshot} from the vm
-   * The idea is this snapshot is quickly salvageable to present a cache's region's info 
+   * Returns the runtime {@link org.apache.geode.admin.GemFireMemberStatus} from the vm The idea is
+   * this snapshot is similar to stats that represent the current state of a running VM. However,
+   * this is a bit higher level than a stat
-  public RegionSubRegionSnapshot getRegionSnapshot(){
-	    RegionSubRegionsSizeResponse response = 
-	    	(RegionSubRegionsSizeResponse)sendAndWait(RegionSubRegionSizeRequest.create());
-	    return response.getSnapshot();
+  public GemFireMemberStatus getSnapshot() {
+    RefreshMemberSnapshotResponse response =
+        (RefreshMemberSnapshotResponse) sendAndWait(RefreshMemberSnapshotRequest.create());
+    return response.getSnapshot();
-  
+
+  /**
+   * Returns the runtime {@link org.apache.geode.admin.RegionSubRegionSnapshot} from the vm The idea
+   * is this snapshot is quickly salvageable to present a cache's region's info
+   */
+  public RegionSubRegionSnapshot getRegionSnapshot() {
+    RegionSubRegionsSizeResponse response =
+        (RegionSubRegionsSizeResponse) sendAndWait(RegionSubRegionSizeRequest.create());
+    return response.getSnapshot();
+  }
+
-    /*StoreSysCfgResponse response = (StoreSysCfgResponse)*/
-        sendAndWait(StoreSysCfgRequest.create(cfg));
+    /* StoreSysCfgResponse response = (StoreSysCfgResponse) */
+    sendAndWait(StoreSysCfgRequest.create(cfg));
-    
+
-   * Returns the agent for the distributed system to which this remote
-   * VM belongs.
+   * Returns the agent for the distributed system to which this remote VM belongs.
-    
-  
-//   public String tailSystemLog(){
-//     TailLogResponse resp = (TailLogResponse)sendAndWait(TailLogRequest.create());
-//     return resp.getTail();
-//   }
+
+
+  // public String tailSystemLog(){
+  // TailLogResponse resp = (TailLogResponse)sendAndWait(TailLogRequest.create());
+  // return resp.getTail();
+  // }
-    TailLogResponse resp = (TailLogResponse)sendAndWait(TailLogRequest.create());
+    TailLogResponse resp = (TailLogResponse) sendAndWait(TailLogRequest.create());
-        retVal = new String[]{main, child};
+        retVal = new String[] {main, child};
-        retVal = new String[]{main};
+        retVal = new String[] {main};
-    VersionInfoResponse resp = (VersionInfoResponse)sendAndWait(VersionInfoRequest.create());
+    VersionInfoResponse resp = (VersionInfoResponse) sendAndWait(VersionInfoRequest.create());
+
-   * Returns information about the root <code>Region</code>s hosted in
-   * the remote VM.
+   * Returns information about the root <code>Region</code>s hosted in the remote VM.
-   * @see RootRegionRequest 
+   * @see RootRegionRequest
-    RootRegionResponse resp = (RootRegionResponse)sendAndWait(RootRegionRequest.create());
+    RootRegionResponse resp = (RootRegionResponse) sendAndWait(RootRegionRequest.create());
+
-    RegionResponse resp =
-      (RegionResponse) sendAndWait(RegionRequest.createForGet(c, path));
+    RegionResponse resp = (RegionResponse) sendAndWait(RegionRequest.createForGet(c, path));
-  public Region createVMRootRegion(CacheInfo c, String regionPath,
-                                   RegionAttributes attrs) 
-    throws AdminException {
+  public Region createVMRootRegion(CacheInfo c, String regionPath, RegionAttributes attrs)
+      throws AdminException {
-    RegionResponse resp = (RegionResponse)
-      sendAndWait(RegionRequest.createForCreateRoot(c, regionPath, attrs));
+    RegionResponse resp =
+        (RegionResponse) sendAndWait(RegionRequest.createForCreateRoot(c, regionPath, attrs));
-      throw new AdminException(LocalizedStrings.RemoteGemFireVM_AN_EXCEPTION_WAS_THROWN_WHILE_CREATING_VM_ROOT_REGION_0.toLocalizedString(regionPath), ex);
+      throw new AdminException(
+          LocalizedStrings.RemoteGemFireVM_AN_EXCEPTION_WAS_THROWN_WHILE_CREATING_VM_ROOT_REGION_0
+              .toLocalizedString(regionPath),
+          ex);
-  public Region createSubregion(CacheInfo c, String parentPath,
-                                String regionPath, RegionAttributes attrs) 
-    throws AdminException {
+  public Region createSubregion(CacheInfo c, String parentPath, String regionPath,
+      RegionAttributes attrs) throws AdminException {
-    RegionResponse resp = (RegionResponse)
-      sendAndWait(RegionRequest.createForCreateSubregion(c, parentPath, regionPath, attrs));
+    RegionResponse resp = (RegionResponse) sendAndWait(
+        RegionRequest.createForCreateSubregion(c, parentPath, regionPath, attrs));
-      throw new AdminException(LocalizedStrings.RemoteGemFireVM_WHILE_CREATING_SUBREGION_0_OF_1.toLocalizedString(new Object[] {regionPath, parentPath}), ex);
+      throw new AdminException(LocalizedStrings.RemoteGemFireVM_WHILE_CREATING_SUBREGION_0_OF_1
+          .toLocalizedString(new Object[] {regionPath, parentPath}), ex);
-   * Takes a snapshot of a <code>Region</code> hosted in the remote
-   * VM.
+   * Takes a snapshot of a <code>Region</code> hosted in the remote VM.
-   * @param regionName
-   *        The name of the <Code>Region</code>
-   * @param snapshotId
-   *        The sequence number of the snapshot
+   * @param regionName The name of the <Code>Region</code>
+   * @param snapshotId The sequence number of the snapshot
-  
-//   public void flushSnapshots() {
-//     sendAsync(FlushAppCacheSnapshotMessage.create());
-//   }
+
+  // public void flushSnapshots() {
+  // sendAsync(FlushAppCacheSnapshotMessage.create());
+  // }
-//   public boolean hasCache() {
-//     throw new UnsupportedOperationException("Not yet implemented");
-//   }
+  // public boolean hasCache() {
+  // throw new UnsupportedOperationException("Not yet implemented");
+  // }
-  RemoteStat[] getResourceStatsByID(long rsrcId){
-    FetchResourceAttributesResponse response = (FetchResourceAttributesResponse)
-      sendAndWait(FetchResourceAttributesRequest.create(rsrcId));
-    return response.getStats();    
+  RemoteStat[] getResourceStatsByID(long rsrcId) {
+    FetchResourceAttributesResponse response = (FetchResourceAttributesResponse) sendAndWait(
+        FetchResourceAttributesRequest.create(rsrcId));
+    return response.getStats();
-  
-  // void fireCacheCreated(RemoteApplicationProcess app) {
-//     app.setSystemManager(this);
-//     synchronized(this.connectionListeners) {
-//       Iterator iter = this.connectionListeners.iterator();
-//       while (iter.hasNext()) {
-//         ((ConnectionListener)iter.next()).cacheCreated(this, app);
-//       }
-//     }
-//   }
-//   void fireCacheClosed(RemoteApplicationProcess app) {
-//     app.setSystemManager(this);
-//     synchronized(this.connectionListeners) {
-//       Iterator iter = this.connectionListeners.iterator();
-//       while (iter.hasNext()) {
-//         ((ConnectionListener)iter.next()).cacheClosed(this, app);
-//       }
-//     }
-//   }
-  
-  public InternalDistributedMember getId(){
-    return this.id;    
+  // void fireCacheCreated(RemoteApplicationProcess app) {
+  // app.setSystemManager(this);
+  // synchronized(this.connectionListeners) {
+  // Iterator iter = this.connectionListeners.iterator();
+  // while (iter.hasNext()) {
+  // ((ConnectionListener)iter.next()).cacheCreated(this, app);
+  // }
+  // }
+  // }
+
+  // void fireCacheClosed(RemoteApplicationProcess app) {
+  // app.setSystemManager(this);
+  // synchronized(this.connectionListeners) {
+  // Iterator iter = this.connectionListeners.iterator();
+  // while (iter.hasNext()) {
+  // ((ConnectionListener)iter.next()).cacheClosed(this, app);
+  // }
+  // }
+  // }
+
+  public InternalDistributedMember getId() {
+    return this.id;
-    CacheInfoResponse resp = (CacheInfoResponse)sendAndWait(CacheInfoRequest.create());
+    CacheInfoResponse resp = (CacheInfoResponse) sendAndWait(CacheInfoRequest.create());
-   * Checks whether a durable-queue for a given client is present on the system
-   * member represented by this RemoteGemFireVM
+   * Checks whether a durable-queue for a given client is present on the system member represented
+   * by this RemoteGemFireVM
-   * @param durableClientId -
-   *                the 'durable-client-id' for the client
+   * @param durableClientId - the 'durable-client-id' for the client
-  public boolean hasDurableClient(String durableClientId)
-  {
-    DurableClientInfoResponse resp = (DurableClientInfoResponse)sendAndWait(DurableClientInfoRequest
-        .create(durableClientId,
+  public boolean hasDurableClient(String durableClientId) {
+    DurableClientInfoResponse resp =
+        (DurableClientInfoResponse) sendAndWait(DurableClientInfoRequest.create(durableClientId,
-   * Checks whether the system member represented by this RemoteGemFireVM is
-   * hosting a primary durable-queue for the client
+   * Checks whether the system member represented by this RemoteGemFireVM is hosting a primary
+   * durable-queue for the client
-   * @param durableClientId -
-   *                the 'durable-client-id' for the client
-   * @return - true if the member contains a primary durable-queue for the given
-   *         client
+   * @param durableClientId - the 'durable-client-id' for the client
+   * @return - true if the member contains a primary durable-queue for the given client
-  public boolean isPrimaryForDurableClient(String durableClientId)
-  {
-    DurableClientInfoResponse resp = (DurableClientInfoResponse)sendAndWait(DurableClientInfoRequest
-        .create(durableClientId,
+  public boolean isPrimaryForDurableClient(String durableClientId) {
+    DurableClientInfoResponse resp =
+        (DurableClientInfoResponse) sendAndWait(DurableClientInfoRequest.create(durableClientId,
-  
-  public CacheInfo setCacheLockTimeout(CacheInfo c, int v) 
-    throws AdminException {
+
+  public CacheInfo setCacheLockTimeout(CacheInfo c, int v) throws AdminException {
-  public CacheInfo setCacheLockLease(CacheInfo c, int v) 
-    throws AdminException {
+
+  public CacheInfo setCacheLockLease(CacheInfo c, int v) throws AdminException {
-  public CacheInfo setCacheSearchTimeout(CacheInfo c, int v) 
-    throws AdminException {
+
+  public CacheInfo setCacheSearchTimeout(CacheInfo c, int v) throws AdminException {
-  public AdminBridgeServer addCacheServer(CacheInfo cache) 
-    throws AdminException {
+  public AdminBridgeServer addCacheServer(CacheInfo cache) throws AdminException {
-    BridgeServerRequest request =
-      BridgeServerRequest.createForAdd(cache);
-    BridgeServerResponse response =
-      (BridgeServerResponse) sendAndWait(request);
+    BridgeServerRequest request = BridgeServerRequest.createForAdd(cache);
+    BridgeServerResponse response = (BridgeServerResponse) sendAndWait(request);
-  public AdminBridgeServer getBridgeInfo(CacheInfo cache, int bridgeRef) 
-    throws AdminException {
+  public AdminBridgeServer getBridgeInfo(CacheInfo cache, int bridgeRef) throws AdminException {
-    BridgeServerRequest request =
-      BridgeServerRequest.createForInfo(cache, bridgeRef);
-    BridgeServerResponse response =
-      (BridgeServerResponse) sendAndWait(request);
+    BridgeServerRequest request = BridgeServerRequest.createForInfo(cache, bridgeRef);
+    BridgeServerResponse response = (BridgeServerResponse) sendAndWait(request);
-  public AdminBridgeServer startBridgeServer(CacheInfo cache,
-                                             AdminBridgeServer bridge)
-    throws AdminException {
+  public AdminBridgeServer startBridgeServer(CacheInfo cache, AdminBridgeServer bridge)
+      throws AdminException {
-      BridgeServerRequest.createForStart(cache, 
-                                         (RemoteBridgeServer) bridge);
-    BridgeServerResponse response =
-      (BridgeServerResponse) sendAndWait(request);
+        BridgeServerRequest.createForStart(cache, (RemoteBridgeServer) bridge);
+    BridgeServerResponse response = (BridgeServerResponse) sendAndWait(request);
-  public AdminBridgeServer stopBridgeServer(CacheInfo cache,
-                                            AdminBridgeServer bridge) 
-    throws AdminException {
+  public AdminBridgeServer stopBridgeServer(CacheInfo cache, AdminBridgeServer bridge)
+      throws AdminException {
-      BridgeServerRequest.createForStop(cache,
-                                        (RemoteBridgeServer) bridge);
-    BridgeServerResponse response =
-      (BridgeServerResponse) sendAndWait(request);
+        BridgeServerRequest.createForStop(cache, (RemoteBridgeServer) bridge);
+    BridgeServerResponse response = (BridgeServerResponse) sendAndWait(request);
-   * Changes a Cache configuration value in a remote cache by sending
-   * the remote member a {@link CacheConfigRequest}.
+   * Changes a Cache configuration value in a remote cache by sending the remote member a
+   * {@link CacheConfigRequest}.
-   * @param c
-   *        The remote cache to be changed
-   * @param opCode
-   *        The code of the operation to perform
-   * @param value
-   *        A value that is an argument to the operation
+   * @param c The remote cache to be changed
+   * @param opCode The code of the operation to perform
+   * @param value A value that is an argument to the operation
-   * @throws AdminException
-   *         If a problem is encountered in the remote VM while
-   *         changing the configuration.
+   * @throws AdminException If a problem is encountered in the remote VM while changing the
+   *         configuration.
-  private CacheInfo setCacheConfigValue(CacheInfo c, int opCode, int value)
-    throws AdminException {
+  private CacheInfo setCacheConfigValue(CacheInfo c, int opCode, int value) throws AdminException {
-    CacheConfigResponse resp = (CacheConfigResponse)sendAndWait(CacheConfigRequest.create(c, opCode, value));
+    CacheConfigResponse resp =
+        (CacheConfigResponse) sendAndWait(CacheConfigRequest.create(c, opCode, value));
-   * Stops listening for statistics updates.  Invoked when this
-   * <code>GemFireVM</code> disconnects or when this member leaves the
-   * distributed system. 
+   * Stops listening for statistics updates. Invoked when this <code>GemFireVM</code> disconnects or
+   * when this member leaves the distributed system.
-   * Invoked by the {@link RemoteGfManagerAgent} when the member that
-   * this <code>GemFireVM</code> represents has left the distributed
-   * system. 
+   * Invoked by the {@link RemoteGfManagerAgent} when the member that this <code>GemFireVM</code>
+   * represents has left the distributed system.
-   * @param alertListenerRegistered
-   *        Was there an alert listener registered for this
-   *        <code>GemFireVM</code>'s agent?  If so, the alert
-   *        listeners should be removed in the member VMs.
+   * @param alertListenerRegistered Was there an alert listener registered for this
+   *        <code>GemFireVM</code>'s agent? If so, the alert listeners should be removed in the
+   *        member VMs.
-    //Thread.dumpStack();
+    // Thread.dumpStack();
-  
+
-  //inner classes
+  // inner classes
-   * A daemon thread that reads  
-   * org.apache.geode.internal.admin.remote.RemoteGemFireVM.DispatchArgs 
-   * off of a queue
-   * and delivers callbacks to the appropriate {@link 
-   * org.apache.geode.internal.admin.StatListener}.
+   * A daemon thread that reads org.apache.geode.internal.admin.remote.RemoteGemFireVM.DispatchArgs
+   * off of a queue and delivers callbacks to the appropriate
+   * {@link org.apache.geode.internal.admin.StatListener}.
-    protected StatDispatcher(){
-      super(RemoteGemFireVM.this.agent.getThreadGroup(),
-            "StatDispatcher");
+    protected StatDispatcher() {
+      super(RemoteGemFireVM.this.agent.getThreadGroup(), "StatDispatcher");
-    
+
-    public void run(){
-      while(!stopped){  
+    public void run() {
+      while (!stopped) {
-          DispatchArgs args = (DispatchArgs)queue.take();
+          DispatchArgs args = (DispatchArgs) queue.take();
-        } catch (Exception ignore){
+        } catch (Exception ignore) {
-    protected void put(DispatchArgs args){
+    protected void put(DispatchArgs args) {
-        } 
-        catch (InterruptedException ignore) {
+        } catch (InterruptedException ignore) {
-        }
-        finally {
+        } finally {
-    
+
-     * @param timestamp
-     *        The time at which the statistics were sampled
-     * @param listenerIds
-     *        The ids of the <code>StatListener</code>s on which
-     *        callbacks should be invoked.
-     * @param values
-     *        The new values of the statistics
+     * @param timestamp The time at which the statistics were sampled
+     * @param listenerIds The ids of the <code>StatListener</code>s on which callbacks should be
+     *        invoked.
+     * @param values The new values of the statistics
-    protected DispatchArgs(long timestamp, int[] listenerIds, double[] values){
+    protected DispatchArgs(long timestamp, int[] listenerIds, double[] values) {
-  
+
-   * Sends an AdminRequest to this dm (that is, to member of the
-   * distributed system represented by this
-   * <code>RemoteGemFireVM</code>) and waits for the AdminReponse.
+   * Sends an AdminRequest to this dm (that is, to member of the distributed system represented by
+   * this <code>RemoteGemFireVM</code>) and waits for the AdminReponse.
-      throw new OperationCancelledException(LocalizedStrings.RemoteGemFireVM_0_IS_UNREACHABLE_IT_HAS_EITHER_LEFT_OR_CRASHED.toLocalizedString(this.name));
+      throw new OperationCancelledException(
+          LocalizedStrings.RemoteGemFireVM_0_IS_UNREACHABLE_IT_HAS_EITHER_LEFT_OR_CRASHED
+              .toLocalizedString(this.name));
-      throw new NullPointerException(LocalizedStrings.RemoteGemFireVM_THE_ID_IF_THIS_REMOTEGEMFIREVM_IS_NULL.toLocalizedString());
+      throw new NullPointerException(
+          LocalizedStrings.RemoteGemFireVM_THE_ID_IF_THIS_REMOTEGEMFIREVM_IS_NULL
+              .toLocalizedString());
-   * Sends a message to this dm (that is, to member of the distributed
-   * system represented by this <code>RemoteGemFireVM</code>) and does
-   * not wait for a response
+   * Sends a message to this dm (that is, to member of the distributed system represented by this
+   * <code>RemoteGemFireVM</code>) and does not wait for a response
-      ((AdminRequest)msg).setModifiedClasspath(inspectionClasspath);
+      ((AdminRequest) msg).setModifiedClasspath(inspectionClasspath);
-  
+
-   * This method should be used to set the Alerts Manager for the member agent. 
-   * Stat Alerts Aggregator would use this method to set stat Alerts Manager 
-   * with the available alert definitions and the refresh interval set for 
-   * each member joining the distributed system. 
+   * This method should be used to set the Alerts Manager for the member agent. Stat Alerts
+   * Aggregator would use this method to set stat Alerts Manager with the available alert
+   * definitions and the refresh interval set for each member joining the distributed system.
-  public void setAlertsManager(StatAlertDefinition[] alertDefs, long refreshInterval, boolean setRemotely) {    
+  public void setAlertsManager(StatAlertDefinition[] alertDefs, long refreshInterval,
+      boolean setRemotely) {
-      //TODO: is the check for valid AdminResponse required
+      // TODO: is the check for valid AdminResponse required
-   * This method would be used to set refresh interval for the GemFireVM. This 
-   * method would mostly be called on each member after initial set up whenever 
-   * the refresh interval is changed.
+   * This method would be used to set refresh interval for the GemFireVM. This method would mostly
+   * be called on each member after initial set up whenever the refresh interval is changed.
-   */  
+   */
-   * This method would be used to set Sta Alert Definitions for the GemFireVM. 
-   * This method would mostly be called on each member after initial set up 
-   * whenever one or more Stat Alert Definitions get added/updated/removed.
+   * This method would be used to set Sta Alert Definitions for the GemFireVM. This method would
+   * mostly be called on each member after initial set up whenever one or more Stat Alert
+   * Definitions get added/updated/removed.
-   * @param actionCode one of UpdateAlertDefinitionRequest.ADD_ALERT_DEFINITION, 
-   *                   UpdateAlertDefinitionRequestUPDATE_ALERT_DEFINITION, 
-   *                   UpdateAlertDefinitionRequest.REMOVE_ALERT_DEFINITION
+   * @param actionCode one of UpdateAlertDefinitionRequest.ADD_ALERT_DEFINITION,
+   *        UpdateAlertDefinitionRequestUPDATE_ALERT_DEFINITION,
+   *        UpdateAlertDefinitionRequest.REMOVE_ALERT_DEFINITION
-    //TODO: is the check for valid AdminResponse required
+    // TODO: is the check for valid AdminResponse required

UPD42 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 DEL40 DEL26 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
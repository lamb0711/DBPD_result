Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ * 
-  public static boolean PREFER_DESERIALIZED = !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "PREFER_SERIALIZED");
-  public static boolean STORE_ALL_VALUE_FORMS = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "STORE_ALL_VALUE_FORMS");
+  public static boolean PREFER_DESERIALIZED =
+      !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "PREFER_SERIALIZED");
+  public static boolean STORE_ALL_VALUE_FORMS =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "STORE_ALL_VALUE_FORMS");
-   * Creates and returns an instance of CachedDeserializable that contains the
-   * specified byte array.
+   * Creates and returns an instance of CachedDeserializable that contains the specified byte array.
-    }
-    else if (PREFER_DESERIALIZED) {
+    } else if (PREFER_DESERIALIZED) {
-  
+
-   * Creates and returns an instance of CachedDeserializable that contains the
-   * specified object (that is not a byte[]).
+   * Creates and returns an instance of CachedDeserializable that contains the specified object
+   * (that is not a byte[]).
-    }
-    else if (PREFER_DESERIALIZED) {
+    } else if (PREFER_DESERIALIZED) {
-    }
-    else if (PREFER_DESERIALIZED) {
+    } else if (PREFER_DESERIALIZED) {
-    // TODO: This method also does not work well with the way off heap is determined using the cache.
-    
+    // TODO: This method also does not work well with the way off heap is determined using the
+    // cache.
+
-    }
-    else if (PREFER_DESERIALIZED) {
+    } else if (PREFER_DESERIALIZED) {
-    
+
+
-   * Return the number of bytes the specified byte array will consume
-   * of heap memory.
+   * Return the number of bytes the specified byte array will consume of heap memory.
-  public static int getArrayOfBytesSize(final byte[][] value,
-      final boolean addObjectOverhead) {
+  public static int getArrayOfBytesSize(final byte[][] value, final boolean addObjectOverhead) {
-   * Return an estimate of the amount of heap memory used for the object.
-   * If it is not a byte[] then account for CachedDeserializable overhead.
-   * when it is wrapped by a CachedDeserializable.
+   * Return an estimate of the amount of heap memory used for the object. If it is not a byte[] then
+   * account for CachedDeserializable overhead. when it is wrapped by a CachedDeserializable.
+
+
-  public static int calcMemSize(Object o, ObjectSizer os, boolean addOverhead, boolean calcSerializedSize) {
+  public static int calcMemSize(Object o, ObjectSizer os, boolean addOverhead,
+      boolean calcSerializedSize) {
-      result = getByteSize((byte[])o);
+      result = getByteSize((byte[]) o);
-      result = (((String)o).length() * 2)
-        + 4 // for the length of the char[]
-        + (Sizeable.PER_OBJECT_OVERHEAD * 2) // for String obj and Char[] obj
-        + 4 // for obj ref to char[] on String; note should be 8 on 64-bit vm
-        + 4 // for offset int field on String
-        + 4 // for count int field on String
-        + 4 // for hash int field on String
-        ;
+      result = (((String) o).length() * 2) + 4 // for the length of the char[]
+          + (Sizeable.PER_OBJECT_OVERHEAD * 2) // for String obj and Char[] obj
+          + 4 // for obj ref to char[] on String; note should be 8 on 64-bit vm
+          + 4 // for offset int field on String
+          + 4 // for count int field on String
+          + 4 // for hash int field on String
+      ;
-      result = getArrayOfBytesSize((byte[][])o, true);
+      result = getArrayOfBytesSize((byte[][]) o, true);
-      result = ((CachedDeserializable)o).getSizeInBytes();
+      result = ((CachedDeserializable) o).getSizeInBytes();
-      result = ((Sizeable)o).getSizeInBytes();
+      result = ((Sizeable) o).getSizeInBytes();
-        RuntimeException ex2 = new IllegalArgumentException(LocalizedStrings.CachedDeserializableFactory_COULD_NOT_CALCULATE_SIZE_OF_OBJECT.toLocalizedString());
+        RuntimeException ex2 = new IllegalArgumentException(
+            LocalizedStrings.CachedDeserializableFactory_COULD_NOT_CALCULATE_SIZE_OF_OBJECT
+                .toLocalizedString());
-//     GemFireCache.getInstance().getLogger().info("DEBUG calcMemSize: o=<" + o + "> o.class=" + (o != null ? o.getClass() : "<null>") + " os=" + os + " result=" + result, new RuntimeException("STACK"));
+    // GemFireCache.getInstance().getLogger().info("DEBUG calcMemSize: o=<" + o + "> o.class=" + (o
+    // != null ? o.getClass() : "<null>") + " os=" + os + " result=" + result, new
+    // RuntimeException("STACK"));
+
-   * Return an estimate of the number of bytes this object will consume
-   * when serialized. This is the number of bytes that will be written
-   * on the wire including the 4 bytes needed to encode the length.
+   * Return an estimate of the number of bytes this object will consume when serialized. This is the
+   * number of bytes that will be written on the wire including the 4 bytes needed to encode the
+   * length.
-      result = getByteSize((byte[])o) - Sizeable.PER_OBJECT_OVERHEAD;
+      result = getByteSize((byte[]) o) - Sizeable.PER_OBJECT_OVERHEAD;
-      result = getArrayOfBytesSize((byte[][])o, false);
+      result = getArrayOfBytesSize((byte[][]) o, false);
-      result = ((CachedDeserializable)o).getSizeInBytes() + 4 - overhead();
+      result = ((CachedDeserializable) o).getSizeInBytes() + 4 - overhead();
-      result = ((Sizeable)o).getSizeInBytes() + 4;
+      result = ((Sizeable) o).getSizeInBytes() + 4;
-      result = ((HeapDataOutputStream)o).size() + 4;
+      result = ((HeapDataOutputStream) o).size() + 4;
-        RuntimeException ex2 = new IllegalArgumentException(LocalizedStrings.CachedDeserializableFactory_COULD_NOT_CALCULATE_SIZE_OF_OBJECT.toLocalizedString());
+        RuntimeException ex2 = new IllegalArgumentException(
+            LocalizedStrings.CachedDeserializableFactory_COULD_NOT_CALCULATE_SIZE_OF_OBJECT
+                .toLocalizedString());
-//     GemFireCache.getInstance().getLogger().info("DEBUG calcSerializedSize: o=<" + o + "> o.class=" + (o != null ? o.getClass() : "<null>") + " result=" + result, new RuntimeException("STACK"));
+    // GemFireCache.getInstance().getLogger().info("DEBUG calcSerializedSize: o=<" + o + ">
+    // o.class=" + (o != null ? o.getClass() : "<null>") + " result=" + result, new
+    // RuntimeException("STACK"));
+
-   * Return how much memory this object will consume
-   * if it is in serialized form
+   * Return how much memory this object will consume if it is in serialized form
+   * 

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66
Revert "Removing TCPConduit's Stub ID class"

This reverts commit 5b35e43f93bfbf6d62eadf7979eb3a8b7f59b77e.

This commit was causing compilation failures.

-import com.gemstone.gemfire.distributed.DistributedMember;
+import com.gemstone.gemfire.internal.tcp.Stub;
+     * Returns the endpoint ID for the direct channel
+     */
+    public Stub getLocalStub() {
+      return conduit.getId();
+    }
+    
+    /**
-            LocalizedStrings.DirectChannel_GEMFIRE_P2P_LISTENER_STARTED_ON__0, conduit.getLocalAddr()));
+            LocalizedStrings.DirectChannel_GEMFIRE_P2P_LISTENER_STARTED_ON__0, conduit.getId()));
+//   /**
+//    * 
+//    * @param addr destination for the message
+//    * @param stubMap map containing all the stubs
+//    * @param msg the original message
+//    * @param msgBuf the serialized message
+//    * @param directAck true if we need an ack
+//    * @param processorType the type (serialized, etc.)
+//    * @return if directAck, the Connection that needs the acknowledgment
+//    * @throws MissingStubException if we do not have a Stub for the recipient
+//    * @throws IOException if the message could not be sent
+//    */
+//   private Connection attemptSingleSend(MembershipManager mgr,
+//       InternalDistributedMember addr,
+//       DistributionMessage msg, ByteBuffer msgBuf,
+//       boolean directAck, int processorType)
+//       throws MissingStubException, IOException
+//   {
+//     if (!msg.deliverToSender() && localAddr.equals(addr))
+//       return null;
+
+//     if (addr == null)
+//       return null;
+//     Stub dest = mgr.getStubForMember(addr);
+//     if (dest == null) {
+//       // This should only happen if the member is no longer in the view.
+//       Assert.assertTrue(!mgr.memberExists(addr));
+//       throw new MissingStubException("No stub");
+//     }
+//     try {
+//       msgBuf.position(0); // fix for bug#30680
+//       Connection con = conduit.sendSync(dest, msgBuf, processorType, msg);
+//       if (directAck)
+//         return con;
+//       else
+//         return null;
+//     }
+//     catch(IOException t) {
+//       throw t;
+//       }
+//   }
+
-      if (!mgr.memberExists(destination) || mgr.shutdownInProgress() || mgr.isShunned(destination)) {
+      Stub stub = mgr.getStubForMember(destination);
+      if (stub == null) {
-          logger.trace(LogMarker.DM, "Not a member: {}", destination);
+          logger.trace(LogMarker.DM, "No Stub for {}", destination);
+        // The only time getStubForMember returns null is if we are
+        // shunning that member or we are shutting down.
+        // So the following assertion is wrong:
+        //Assert.assertTrue(!mgr.memberExists(destination));
+        // instead we should:
+        // Assert.assertTrue(mgr.shutdownInProgress() || mgr.isShunned(destination));
+        //but this is not worth doing and isShunned is not public.
+        // SO the assert has been deadcoded.
-        ce.addFailure(destination, new ShunnedMemberException(LocalizedStrings.DirectChannel_SHUNNING_0.toLocalizedString()));
+        ce.addFailure(destination, new MissingStubException(LocalizedStrings.DirectChannel_NO_STUB_0.toLocalizedString()));
-          Connection con = conduit.getConnection(destination, preserveOrder,
-              retry, startTime, ackTimeout, ackSDTimeout);
+          Connection con = conduit.getConnection(destination, stub,
+              preserveOrder, retry, startTime, ackTimeout, ackSDTimeout);
-  public void receive(DistributionMessage msg, int bytesRead) {
+  public void receive(DistributionMessage msg, int bytesRead, Stub connId) {
+//  public void newMemberConnected(InternalDistributedMember member, Stub id) {
+//    receiver.newMemberConnected(member, id);
+//  }
+
+  /** Create a TCPConduit stub from a JGroups InternalDistributedMember */
+  public Stub createConduitStub(InternalDistributedMember addr) {
+    int port = addr.getDirectChannelPort();
+    Stub stub = new Stub(addr.getInetAddress(), port, addr.getVmViewId());
+    return stub;
+  }
+  
-      tc.removeEndpoint(member, reason, notifyDisconnect);
+      tc.removeEndpoint(createConduitStub(member), reason, notifyDisconnect);
-  public void getChannelStates(DistributedMember member, Map result)
+  public void getChannelStates(Stub member, Map result)
-  public void waitForChannelState(DistributedMember member, Map channelState)
+  public void waitForChannelState(Stub member, Map channelState)
-  public boolean hasReceiversFor(DistributedMember mbr) {
+  public boolean hasReceiversFor(Stub mbr) {

MOV26 UPD40 INS31 INS31 INS29 INS83 INS43 INS42 INS8 INS44 INS29 INS83 INS43 INS42 INS44 INS8 INS65 INS42 INS41 INS43 INS42 INS65 INS42 INS43 INS42 INS60 INS60 INS41 UPD43 UPD43 UPD43 INS66 INS32 INS42 INS66 INS42 INS39 INS59 INS43 INS59 INS42 UPD42 UPD42 UPD42 INS42 INS42 INS60 INS42 INS32 INS42 INS42 INS14 INS43 INS59 UPD27 INS42 INS42 INS43 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 MOV42 UPD42 UPD43 UPD45 UPD42 UPD40 INS42 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32
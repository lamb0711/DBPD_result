GEODE-7090 Remove dependency on DataSerializer from membership classes

DataSerializableFixedID is used by most internal classes for
serialization.  Membership, in particular, was constrained in its
implementation to use only "fixed" serialization identifiers because our
other serialization mechanisms (DataSerialiable, PDX) are dependent on
membership and messaging.

This PR moves serialization of DataSerializableFixedID to a new
sub-project, geode-serialization in support of also separating
membership into its own sub-project.

Many files are touched by this PR.  The vast majority are due to a
change in the serialization interface that introduces a new parameter in
DataSerializableFixedID's toData and fromData methods.  This parameter
gives access to the serializer and to the Version of the
source/destination.  This parameter was added to begin moving from a
"static" based serialization service to an instance based service.

Serialization code concerning "DSFID"s has been moved from
InternalDataSerializer to the new class DSFIDSerialzerImpl.
InternalDataSerializer holds on to an instance of this class and
delegates DSFID serialization to it.

InternalDataSerializer also effects registration of Geode's DSFID
classes with this serializer.  Membership "Services" handles
registration of its own DSFID classes with the service, as do other
sub-projects like geode-web.

HeapDataOutputStream has been used by most of our serialization code to
provide a DataOutput for our toData methods.  Over the years this class
has accumulated a lot of adornments for PDX serialization that aren't
appropriate for a geode-serialization sub-project.  Consequently I've
moved much of its code into a superclass, BufferDataOutputStream, that
provides most of its functionality w/o needing to reference other geode-
core classes.

Version.java has been repackaged in this PR, moving it into a
"serialization" package.  This affected some rolling-upgrade and
backward-compatibility tests that were referring to
Version.CURRENT_ORDINAL.  These have been modified to get the "current
version ordinal" from VersionManager.

Finally, InternalDataSerializer injects a serializer into the new
sub-project that provideds an API for handling other types of
serializable objects like PDX.  This serializer is available in the
DataSerializableFixedID toData/fromData context parameter and is used by
membership services when serializing Geode DistributionMessages.

-import java.net.UnknownHostException;
-import org.apache.geode.internal.DSCODE;
-import org.apache.geode.internal.Version;
+import org.apache.geode.internal.serialization.DSCODE;
+import org.apache.geode.internal.serialization.StaticSerialization;
+import org.apache.geode.internal.serialization.Version;
-    writeByteArray((address != null) ? address.getAddress() : null, out);
+    StaticSerialization.writeInetAddress(address, out);
+    InetAddress address = StaticSerialization.readInetAddress(in);
-    byte[] address = readByteArray(in);
-    if (address == null) {
-      return null;
+    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
+      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read InetAddress {}", address);
-    try {
-      InetAddress addr = InetAddress.getByAddress(address);
-      if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
-        logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read InetAddress {}", addr);
-      }
-      return addr;
-    } catch (UnknownHostException ex) {
-      throw new IOException("While reading an InetAddress", ex);
-    }
-
+    return address;
-    if (value == null) {
-      if (isTraceSerialzerVerbose) {
-        logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing NULL_STRING");
-      }
-      out.writeByte(DSCODE.NULL_STRING.toByte());
-
-    } else {
-      // writeUTF is expensive - it creates a char[] to fetch
-      // the string's contents, iterates over the array to compute the
-      // encoded length, creates a byte[] to hold the encoded bytes,
-      // iterates over the char[] again to create the encode bytes,
-      // then writes the bytes. Since we usually deal with ISO-8859-1
-      // strings, we can accelerate this by accessing chars directly
-      // with charAt and fill a single-byte buffer. If we run into
-      // a multibyte char, we revert to using writeUTF()
-      int len = value.length();
-      int utfLen = len; // added for bug 40932
-      for (int i = 0; i < len; i++) {
-        char c = value.charAt(i);
-        if ((c <= 0x007F) && (c >= 0x0001)) {
-          // nothing needed
-        } else if (c > 0x07FF) {
-          utfLen += 2;
-        } else {
-          utfLen += 1;
-        }
-        // Note we no longer have an early out when we detect the first
-        // non-ascii char because we need to compute the utfLen for bug 40932.
-        // This is not a performance problem because most strings are ascii
-        // and they never did the early out.
-      }
-      boolean writeUTF = utfLen > len;
-      if (writeUTF) {
-        if (utfLen > 0xFFFF) {
-          if (isTraceSerialzerVerbose) {
-            logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing utf HUGE_STRING of len={}", len);
-          }
-          out.writeByte(DSCODE.HUGE_STRING.toByte());
-          out.writeInt(len);
-          out.writeChars(value);
-        } else {
-          if (isTraceSerialzerVerbose) {
-            logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing utf STRING of len={}", len);
-          }
-          out.writeByte(DSCODE.STRING.toByte());
-          out.writeUTF(value);
-        }
-      } else {
-        if (len > 0xFFFF) {
-          if (isTraceSerialzerVerbose) {
-            logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing HUGE_STRING_BYTES of len={}", len);
-          }
-          out.writeByte(DSCODE.HUGE_STRING_BYTES.toByte());
-          out.writeInt(len);
-          out.writeBytes(value);
-        } else {
-          if (isTraceSerialzerVerbose) {
-            logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing STRING_BYTES of len={}", len);
-          }
-          out.writeByte(DSCODE.STRING_BYTES.toByte());
-          out.writeShort(len);
-          out.writeBytes(value);
-        }
-      }
-    }
+    StaticSerialization.writeString(value, out);
-    return InternalDataSerializer.readString(in, in.readByte());
+    return StaticSerialization.readString(in);
-    int length = InternalDataSerializer.readArrayLength(in);
-    if (length == -1) {
-      return null;
-    } else {
-      byte[] array = new byte[length];
-      in.readFully(array, 0, length);
+    byte[] result = StaticSerialization.readByteArray(in);
-      if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
-        logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read byte array of length {}", length);
-      }
-
-      return array;
+    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
+      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read byte array of length {}",
+          result == null ? "null" : result.length);
+
+    return result;
-    int length;
-    if (array == null) {
-      length = -1;
-    } else {
-      length = array.length;
-    }
-    InternalDataSerializer.writeArrayLength(length, out);
+
+    StaticSerialization.writeStringArray(array, out);
+
-      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing String array of length {}", length);
-    }
-    if (length > 0) {
-      for (int i = 0; i < length; i++) {
-        writeString(array[i], out);
+      int length;
+      if (array == null) {
+        length = -1;
+      } else {
+        length = array.length;
+
+      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing String array of length {}", length);
-    int length = InternalDataSerializer.readArrayLength(in);
-    if (length == -1) {
-      return null;
-    } else {
-      String[] array = new String[length];
-      for (int i = 0; i < length; i++) {
-        array[i] = readString(in);
-      }
+    String array[] = StaticSerialization.readStringArray(in);
-      if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
-        logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read String array of length {}", length);
-      }
-
-      return array;
+    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
+      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read String array of length {}",
+          array == null ? "null" : array.length);
+
+    return array;
-    int length;
-    if (array == null) {
-      length = -1;
-    } else {
-      length = array.length;
-    }
-    InternalDataSerializer.writeArrayLength(length, out);
+    StaticSerialization.writeIntArray(array, out);
-      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing int array of length {}", length);
-    }
-    if (length > 0) {
-      for (int i = 0; i < length; i++) {
-        out.writeInt(array[i]);
-      }
+      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Writing int array of length {}",
+          array == null ? "null" : array.length);
-    int length = InternalDataSerializer.readArrayLength(in);
-    if (length == -1) {
-      return null;
-    } else {
-      int[] array = new int[length];
-      for (int i = 0; i < length; i++) {
-        array[i] = in.readInt();
-      }
+    int[] result = StaticSerialization.readIntArray(in);
-      if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
-        logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read int array of length {}", length);
-      }
-
-      return array;
+    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
+      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read int array of length {}",
+          result == null ? "null" : result.length);
+
+    return result;

MOV26 MOV26 MOV26 UPD40 UPD40 UPD40 INS8 INS8 MOV25 MOV41 MOV21 MOV60 MOV25 INS21 MOV21 MOV25 INS41 MOV21 INS60 MOV25 MOV41 MOV21 MOV25 MOV41 MOV43 UPD42 INS32 MOV5 MOV32 INS42 INS43 INS59 MOV32 MOV32 MOV5 MOV32 UPD42 UPD42 INS42 MOV42 INS42 UPD42 MOV42 MOV42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV60 MOV25 MOV42 MOV42 INS85 INS32 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 INS42 UPD42 MOV42 MOV42 UPD42 UPD42 UPD42 INS16 INS16 INS16 INS16 INS27 INS45 INS40 INS27 INS45 INS40 INS27 INS45 INS40 INS27 INS45 INS40 INS42 INS33 INS42 INS33 INS42 INS33 INS42 INS33 DEL42 DEL33 DEL27 DEL36 DEL42 DEL32 DEL33 DEL16 DEL39 DEL85 DEL5 DEL42 DEL33 DEL27 DEL33 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL40 DEL45 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL40 DEL42 DEL32 DEL32 DEL21 DEL8 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL36 DEL42 DEL34 DEL27 DEL36 DEL27 DEL8 DEL42 DEL34 DEL27 DEL42 DEL34 DEL7 DEL21 DEL8 DEL42 DEL34 DEL7 DEL21 DEL8 DEL25 DEL25 DEL8 DEL24 DEL39 DEL42 DEL42 DEL42 DEL27 DEL59 DEL60 DEL42 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL40 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL40 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL40 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL40 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL40 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL40 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL40 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL40 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL39 DEL42 DEL42 DEL34 DEL38 DEL27 DEL33 DEL41 DEL8 DEL42 DEL39 DEL85 DEL5 DEL42 DEL3 DEL59 DEL60 DEL42 DEL42 DEL42 DEL34 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL34 DEL27 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL21 DEL8 DEL24 DEL8 DEL25 DEL42 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL38 DEL27 DEL33 DEL41 DEL8 DEL43 DEL85 DEL5 DEL42 DEL43 DEL85 DEL5 DEL42 DEL3 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL32 DEL7 DEL21 DEL8 DEL24 DEL42 DEL41 DEL8 DEL25 DEL8 DEL39 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL34 DEL38 DEL7 DEL21 DEL8 DEL42 DEL40 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL34 DEL27 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL42 DEL2 DEL32 DEL21 DEL8 DEL24 DEL8 DEL25 DEL39 DEL42 DEL42 DEL34 DEL38 DEL27 DEL33 DEL41 DEL8 DEL42 DEL39 DEL85 DEL5 DEL42 DEL3 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL24 DEL8 DEL25
GEODE-6442: Fixup StatisticsImpl and StatisticsImplTest

Fixup StatisticsImpl:
* Fix IDE warnings in StatisticsImpl
* Make closed volatile
* Fixup field and method ordering

Fixup StatisticsImplTest:
* Replace mutable static logger with testable interface
* Use AssertJ in test
* Use simple implementation of StatisticsImpl instead of
LocalStatisticsImpl

-import org.apache.geode.annotations.internal.MutableForTesting;
-// @todo darrel Add statistics instances to archive when they are created.
- * <P>
- *
+ * <p>
- * <P>
- *
- * @see <A href="package-summary.html#statistics">Package introduction</A>
- *
- *
-  /** logger - not private for tests */
-  @MutableForTesting
-  static Logger logger = LogService.getLogger();
+
+  private static final Logger logger = LogService.getLogger();
-  /** Are these statistics closed? */
-  private boolean closed;
-
-  private long uniqueId;
+  private final long uniqueId;
-  private final Set<Object> flakySuppliers = new HashSet<Object>();
+  private final Set<Object> flakySuppliers = new HashSet<>();
-  /////////////////////// Constructors ///////////////////////
+  private final StatisticsLogger statisticsLogger;
+
+  /** Are these statistics closed? */
+  private volatile boolean closed;
-  public static Statistics createAtomicNoOS(StatisticsType type, String textId, long numericId,
-      long uniqueId, StatisticsManager mgr) {
-    return new StripedStatisticsImpl(type, textId, numericId, uniqueId, mgr);
+  static Statistics createAtomicNoOS(StatisticsType type, String textId, long numericId,
+      long uniqueId, StatisticsManager statisticsManager) {
+    return new StripedStatisticsImpl(type, textId, numericId, uniqueId, statisticsManager);
+   * @param statisticsManager The StatisticsManager responsible for creating this instance
-  public StatisticsImpl(StatisticsType type, String textId, long numericId, long uniqueId,
+  StatisticsImpl(StatisticsType type, String textId, long numericId, long uniqueId,
+    this(type, textId, numericId, uniqueId, osStatFlags, statisticsManager,
+        (message, textId1, statId, throwable) -> logger.warn(message, textId1, statId, throwable));
+  }
+
+  /**
+   * Creates a new statistics instance of the given type and unique id
+   *
+   * @param type A description of the statistics
+   * @param textId Text that helps identifies this instance
+   * @param numericId A number that helps identify this instance
+   * @param uniqueId A number that uniquely identifies this instance
+   * @param osStatFlags Non-zero if stats require system calls to collect them; for internal use
+   *        only
+   * @param statisticsManager The StatisticsManager responsible for creating this instance
+   * @param statisticsLogger The StatisticsLogger to log warning about flaky suppliers
+   */
+  StatisticsImpl(StatisticsType type, String textId, long numericId, long uniqueId,
+      int osStatFlags, StatisticsManager statisticsManager, StatisticsLogger statisticsLogger) {
+    this.statisticsLogger = statisticsLogger;
-  ////////////////////// Instance Methods //////////////////////
-
-  public boolean usesSystemCalls() {
-    return this.osStatFlags != 0;
-  }
-
-  public int getOsStatFlags() {
-    return this.osStatFlags;
-  }
-
-    return this.type.nameToId(name);
+    return type.nameToId(name);
-    return this.type.nameToDescriptor(name);
+    return type.nameToDescriptor(name);
-    if (this.statisticsManager != null) {
+    if (statisticsManager != null) {
-    this.closed = true;
+    closed = true;
-    return this.closed;
+    return closed;
-  public abstract boolean isAtomic();
-
-  private boolean isOpen() { // fix for bug 29973
-    return !this.closed;
-  }
-
-  //////////////////////// attribute Methods ///////////////////////
-
-  @Override
-    return this.type;
+    return type;
-    return this.textId;
+    return textId;
-    return this.numericId;
+    return numericId;
-    return this.uniqueId;
+    return uniqueId;
-  /**
-   * Sets a unique id for this resource.
-   */
-  public void setUniqueId(long uid) {
-    this.uniqueId = uid;
-  }
-
-  //////////////////////// set() Methods ///////////////////////
-
-  /**
-   * Sets the value of a statistic of type <code>int</code> at the given offset, but performs no
-   * type checking.
-   */
-  protected abstract void _setInt(int offset, int value);
-
-  /**
-   * Sets the value of a statistic of type <code>long</code> at the given offset, but performs no
-   * type checking.
-   */
-  protected abstract void _setLong(int offset, long value);
-
-  /**
-   * Sets the value of a statistic of type <code>double</code> at the given offset, but performs no
-   * type checking.
-   */
-  protected abstract void _setDouble(int offset, double value);
-
-  /////////////////////// get() Methods ///////////////////////
-
-  /**
-   * Returns the value of the statistic of type <code>int</code> at the given offset, but performs
-   * no type checking.
-   */
-  protected abstract int _getInt(int offset);
-
-
-
-  /**
-   * Returns the value of the statistic of type <code>long</code> at the given offset, but performs
-   * no type checking.
-   */
-  protected abstract long _getLong(int offset);
-
-  /**
-   * Returns the value of the statistic of type <code>double</code> at the given offset, but
-   * performs no type checking.
-   */
-  protected abstract double _getDouble(int offset);
-
-      return Integer.valueOf(0);
+      return 0;
-  //////////////////////// inc() Methods ////////////////////////
-
-  /**
-   * Increments the value of the statistic of type <code>int</code> at the given offset by a given
-   * amount, but performs no type checking.
-   */
-  protected abstract void _incInt(int offset, int delta);
-
-  /**
-   * Increments the value of the statistic of type <code>long</code> at the given offset by a given
-   * amount, but performs no type checking.
-   */
-  protected abstract void _incLong(int offset, long delta);
-
-  /**
-   * Increments the value of the statistic of type <code>double</code> at the given offset by a
-   * given amount, but performs no type checking.
-   */
-  protected abstract void _incDouble(int offset, double delta);
-
-  /**
-   * For internal use only. Tells the implementation to prepare the data in this instance for
-   * sampling.
-   *
-   * @since GemFire 5.1
-   */
-  public void prepareForSample() {
-    // nothing needed in this impl.
-  }
-
-  /**
-   * Invoke sample suppliers to retrieve the current value for the suppler controlled sets and
-   * update the stats to reflect the supplied values.
-   *
-   * @return the number of callback errors that occurred while sampling stats
-   */
-  public int invokeSuppliers() {
-    int errors = 0;
-    for (Map.Entry<Integer, IntSupplier> entry : intSuppliers.entrySet()) {
-      try {
-        _setInt(entry.getKey(), entry.getValue().getAsInt());
-      } catch (Throwable t) {
-        logSupplierError(t, entry.getKey(), entry.getValue());
-        errors++;
-      }
-    }
-    for (Map.Entry<Integer, LongSupplier> entry : longSuppliers.entrySet()) {
-      try {
-        _setLong(entry.getKey(), entry.getValue().getAsLong());
-      } catch (Throwable t) {
-        logSupplierError(t, entry.getKey(), entry.getValue());
-        errors++;
-      }
-    }
-    for (Map.Entry<Integer, DoubleSupplier> entry : doubleSuppliers.entrySet()) {
-      try {
-        _setDouble(entry.getKey(), entry.getValue().getAsDouble());
-      } catch (Throwable t) {
-        logSupplierError(t, entry.getKey(), entry.getValue());
-        errors++;
-      }
-    }
-
-    return errors;
-  }
-
-  private void logSupplierError(final Throwable t, int statId, Object supplier) {
-    if (flakySuppliers.add(supplier)) {
-      logger.warn("Error invoking supplier for stat {}, id {}", this.getTextId(), statId, t);
-    }
-  }
-
-  /**
-   * @return the number of statistics that are measured using supplier callbacks
-   */
-  public int getSupplierCount() {
-    return intSuppliers.size() + doubleSuppliers.size() + longSuppliers.size();
-  }
-
-    return (int) this.uniqueId;
+    return (int) uniqueId;
-  public boolean equals(Object o) {
-    if (o == null) {
+  public boolean equals(Object obj) {
+    if (obj == null) {
-    if (!(o instanceof StatisticsImpl)) {
+    if (!(obj instanceof StatisticsImpl)) {
-    StatisticsImpl other = (StatisticsImpl) o;
-    return this.uniqueId == other.getUniqueId();
+    StatisticsImpl other = (StatisticsImpl) obj;
+    return uniqueId == other.getUniqueId();
+  }
+
+  @Override
+  public String toString() {
+    final StringBuilder sb = new StringBuilder(getClass().getName());
+    sb.append("@").append(System.identityHashCode(this)).append("{");
+    sb.append("uniqueId=").append(uniqueId);
+    sb.append(", numericId=").append(numericId);
+    sb.append(", textId=").append(textId);
+    sb.append(", type=").append(type.getName());
+    sb.append(", closed=").append(closed);
+    sb.append("}");
+    return sb.toString();
+  }
+
+  @Override
+  public abstract boolean isAtomic();
+
+  /**
+   * Sets the value of a statistic of type {@code int} at the given offset, but performs no
+   * type checking.
+   */
+  protected abstract void _setInt(int offset, int value);
+
+  /**
+   * Sets the value of a statistic of type {@code long} at the given offset, but performs no
+   * type checking.
+   */
+  protected abstract void _setLong(int offset, long value);
+
+  /**
+   * Sets the value of a statistic of type {@code double} at the given offset, but performs no
+   * type checking.
+   */
+  protected abstract void _setDouble(int offset, double value);
+
+  /**
+   * Returns the value of the statistic of type {@code int} at the given offset, but performs
+   * no type checking.
+   */
+  protected abstract int _getInt(int offset);
+
+  /**
+   * Returns the value of the statistic of type {@code long} at the given offset, but performs
+   * no type checking.
+   */
+  protected abstract long _getLong(int offset);
+
+  /**
+   * Returns the value of the statistic of type {@code double} at the given offset, but
+   * performs no type checking.
+   */
+  protected abstract double _getDouble(int offset);
+
+  /**
+   * Increments the value of the statistic of type {@code int} at the given offset by a given
+   * amount, but performs no type checking.
+   */
+  protected abstract void _incInt(int offset, int delta);
+
+  /**
+   * Increments the value of the statistic of type {@code long} at the given offset by a given
+   * amount, but performs no type checking.
+   */
+  protected abstract void _incLong(int offset, long delta);
+
+  /**
+   * Increments the value of the statistic of type {@code double} at the given offset by a
+   * given amount, but performs no type checking.
+   */
+  protected abstract void _incDouble(int offset, double delta);
+
+  /**
+   * For internal use only. Tells the implementation to prepare the data in this instance for
+   * sampling.
+   *
+   * @since GemFire 5.1
+   */
+  void prepareForSample() {
+    // nothing needed in this impl.
+  }
+
+  /**
+   * Invoke sample suppliers to retrieve the current value for the suppler controlled sets and
+   * update the stats to reflect the supplied values.
+   *
+   * @return the number of callback errors that occurred while sampling stats
+   */
+  int invokeSuppliers() {
+    int errors = 0;
+    for (Map.Entry<Integer, IntSupplier> entry : intSuppliers.entrySet()) {
+      try {
+        _setInt(entry.getKey(), entry.getValue().getAsInt());
+      } catch (Throwable t) {
+        logSupplierError(t, entry.getKey(), entry.getValue());
+        errors++;
+      }
+    }
+    for (Map.Entry<Integer, LongSupplier> entry : longSuppliers.entrySet()) {
+      try {
+        _setLong(entry.getKey(), entry.getValue().getAsLong());
+      } catch (Throwable t) {
+        logSupplierError(t, entry.getKey(), entry.getValue());
+        errors++;
+      }
+    }
+    for (Map.Entry<Integer, DoubleSupplier> entry : doubleSuppliers.entrySet()) {
+      try {
+        _setDouble(entry.getKey(), entry.getValue().getAsDouble());
+      } catch (Throwable t) {
+        logSupplierError(t, entry.getKey(), entry.getValue());
+        errors++;
+      }
+    }
+
+    return errors;
+  }
+
+  /**
+   * @return the number of statistics that are measured using supplier callbacks
+   */
+  int getSupplierCount() {
+    return intSuppliers.size() + doubleSuppliers.size() + longSuppliers.size();
+  }
+
+  boolean usesSystemCalls() {
+    return osStatFlags != 0;
+  }
+
+  int getOsStatFlags() {
+    return osStatFlags;
+  }
+
+  private void logSupplierError(final Throwable throwable, int statId, Object supplier) {
+    if (flakySuppliers.add(supplier)) {
+      statisticsLogger.logWarning("Error invoking supplier for stat {}, id {}", getTextId(), statId,
+          throwable);
+    }
+  }
+
+  private boolean isOpen() {
+    return !closed;
+  }
+
+  /**
+   * Returns the value of the specified statistic descriptor.
+   */
+  private Number _get(StatisticDescriptorImpl descriptor) {
+    switch (descriptor.getTypeCode()) {
+      case StatisticDescriptorImpl.INT:
+        return _getInt(descriptor.getId());
+      case StatisticDescriptorImpl.LONG:
+        return _getLong(descriptor.getId());
+      case StatisticDescriptorImpl.DOUBLE:
+        return _getDouble(descriptor.getId());
+      default:
+        throw new RuntimeException(
+            String.format("unexpected stat descriptor type code: %s",
+                descriptor.getTypeCode()));
+    }
+  }
+
+  /**
+   * Returns the bits that represent the raw value of the specified statistic descriptor.
+   */
+  private long _getRawBits(StatisticDescriptorImpl descriptor) {
+    switch (descriptor.getTypeCode()) {
+      case StatisticDescriptorImpl.INT:
+        return _getInt(descriptor.getId());
+      case StatisticDescriptorImpl.LONG:
+        return _getLong(descriptor.getId());
+      case StatisticDescriptorImpl.DOUBLE:
+        return Double.doubleToRawLongBits(_getDouble(descriptor.getId()));
+      default:
+        throw new RuntimeException(
+            String.format("unexpected stat descriptor type code: %s",
+                descriptor.getTypeCode()));
+    }
-  /**
-   * Returns the value of the specified statistic descriptor.
-   */
-  private Number _get(StatisticDescriptorImpl stat) {
-    switch (stat.getTypeCode()) {
-      case StatisticDescriptorImpl.INT:
-        return Integer.valueOf(_getInt(stat.getId()));
-      case StatisticDescriptorImpl.LONG:
-        return Long.valueOf(_getLong(stat.getId()));
-      case StatisticDescriptorImpl.DOUBLE:
-        return Double.valueOf(_getDouble(stat.getId()));
-      default:
-        throw new RuntimeException(
-            String.format("unexpected stat descriptor type code: %s",
-                Byte.valueOf(stat.getTypeCode())));
-    }
-  }
-
-  /**
-   * Returns the bits that represent the raw value of the specified statistic descriptor.
-   */
-  private long _getRawBits(StatisticDescriptorImpl stat) {
-    switch (stat.getTypeCode()) {
-      case StatisticDescriptorImpl.INT:
-        return _getInt(stat.getId());
-      case StatisticDescriptorImpl.LONG:
-        return _getLong(stat.getId());
-      case StatisticDescriptorImpl.DOUBLE:
-        return Double.doubleToRawLongBits(_getDouble(stat.getId()));
-      default:
-        throw new RuntimeException(
-            String.format("unexpected stat descriptor type code: %s",
-                Byte.valueOf(stat.getTypeCode())));
-    }
-  }
-
-  @Override
-  public String toString() {
-    final StringBuilder sb = new StringBuilder(getClass().getName());
-    sb.append("@").append(System.identityHashCode(this)).append("{");
-    sb.append("uniqueId=").append(this.uniqueId);
-    sb.append(", numericId=").append(this.numericId);
-    sb.append(", textId=").append(this.textId);
-    sb.append(", type=").append(this.type.getName());
-    sb.append(", closed=").append(this.closed);
-    sb.append("}");
-    return sb.toString();
+  interface StatisticsLogger {
+    void logWarning(String message, String textId, int statId, Throwable throwable);

MOV23 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 INS23 INS31 INS31 INS55 INS83 INS83 INS83 INS83 INS83 INS43 INS59 INS83 MOV29 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS29 INS44 MOV78 MOV78 MOV78 MOV78 UPD39 UPD42 INS8 MOV44 MOV44 INS39 INS42 INS8 INS39 INS42 INS8 UPD83 UPD39 UPD42 MOV44 MOV44 INS42 INS31 UPD66 INS42 INS42 UPD42 INS65 INS43 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS17 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS43 INS42 INS21 INS41 UPD42 INS41 INS41 UPD42 UPD42 UPD42 INS39 INS42 INS44 INS44 INS44 INS44 UPD74 INS42 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS86 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS7 INS42 INS42 INS42 INS42 INS42 INS11 MOV8 MOV8 MOV43 UPD66 INS65 INS66 UPD66 INS65 INS66 UPD66 INS65 INS66 UPD66 INS65 INS66 UPD66 INS65 INS66 UPD66 INS65 INS66 UPD66 INS65 INS66 UPD66 INS65 INS66 UPD66 INS65 INS66 INS27 INS42 INS38 MOV49 MOV49 MOV49 MOV49 MOV49 MOV49 INS43 INS42 INS43 INS42 INS39 INS42 INS43 INS42 UPD42 INS59 INS59 INS59 INS59 INS32 INS22 INS42 INS42 INS42 INS42 INS42 INS39 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS34 INS42 UPD42 INS32 INS32 INS32 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS34 MOV43 UPD42 INS42 MOV42 MOV32 MOV42 MOV32 MOV42 MOV32 MOV43 MOV43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 UPD42 UPD42 MOV32 UPD42 UPD42 UPD42 DEL40 DEL26 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL78 DEL42 DEL43 DEL83 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL34 DEL27 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL41 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL38 DEL41 DEL8 DEL31 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL34 DEL32 DEL66 DEL65 DEL29 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL83 DEL83 DEL52 DEL39 DEL52 DEL42 DEL22 DEL11 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32
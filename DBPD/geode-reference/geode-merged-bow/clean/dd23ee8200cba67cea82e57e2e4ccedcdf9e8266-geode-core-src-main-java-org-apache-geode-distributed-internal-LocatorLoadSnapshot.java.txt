GEODE-7565: Allow gateway receivers with same host and port (#4824)

There was a problem with Geode WAN replication when GW receivers are configured with the same hostname-for-senders and port on all servers. The reason for such a setup is deploying Geode cluster on a Kubernetes cluster where all GW receivers are reachable from the outside world on the same VIP and port.

The problem experienced is that shutting down one server is stopping replication to this cluster until the server is up again. This is because Geode incorrectly assumes there are no more alive servers when just one of them is down, because since they share hostname-for-senders and port, they are treated as one same server.

With these changes locator is able to distinguish the different receivers using the same hostname and port so replication is not impacted when one server is stopped. 
-  private final Map<String, Map<ServerLocation, LoadHolder>> connectionLoadMap = new HashMap<>();
+  private final Map<String, Map<ServerLocationAndMemberId, LoadHolder>> connectionLoadMap =
+      new HashMap<>();
-  public void addServer(ServerLocation location, String[] groups, ServerLoad initialLoad) {
-    addServer(location, groups, initialLoad, 30000);
-  }
-
-  public synchronized void addServer(ServerLocation location, String[] groups,
+  public synchronized void addServer(ServerLocation location, String memberId, String[] groups,
-    LoadHolder connectionLoad = new LoadHolder(location, initialLoad.getConnectionLoad(),
-        initialLoad.getLoadPerConnection(), loadPollInterval);
-    addGroups(connectionLoadMap, groups, connectionLoad);
-    LoadHolder queueLoad = new LoadHolder(location, initialLoad.getSubscriptionConnectionLoad(),
+    LoadHolder connectionLoad =
+        new LoadHolder(location, initialLoad.getConnectionLoad(),
+            initialLoad.getLoadPerConnection(), loadPollInterval);
+    addGroups(connectionLoadMap, groups, connectionLoad, memberId);
+    LoadHolder queueLoad = new LoadHolder(location,
+        initialLoad.getSubscriptionConnectionLoad(),
-    updateLoad(location, initialLoad);
+    updateLoad(location, memberId, initialLoad);
-  public synchronized void removeServer(ServerLocation location) {
+  public synchronized void removeServer(ServerLocation location, String memberId) {
-      removeFromMap(connectionLoadMap, groups, location);
+      removeFromMap(connectionLoadMap, groups, location, memberId);
-  public void updateLoad(ServerLocation location, ServerLoad newLoad) {
-    updateLoad(location, newLoad, null);
+  public void updateLoad(ServerLocation location, String memberId, ServerLoad newLoad) {
+    updateLoad(location, memberId, newLoad, null);
-  synchronized void updateLoad(ServerLocation location, ServerLoad newLoad,
+  synchronized void updateLoad(ServerLocation location, String memberId, ServerLoad newLoad,
+
-    updateMap(connectionLoadMap, location, newLoad.getConnectionLoad(),
+    updateMap(connectionLoadMap, location, memberId, newLoad.getConnectionLoad(),
-    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
+    Map<ServerLocationAndMemberId, LoadHolder> groupServers = connectionLoadMap.get(group);
-  private synchronized boolean isBalanced(Map<ServerLocation, LoadHolder> groupServers) {
+  private synchronized boolean isBalanced(Map<ServerLocationAndMemberId, LoadHolder> groupServers) {
-  private synchronized boolean isBalanced(Map<ServerLocation, LoadHolder> groupServers,
+  private synchronized boolean isBalanced(Map<ServerLocationAndMemberId, LoadHolder> groupServers,
-    for (Entry<ServerLocation, LoadHolder> loadHolderEntry : groupServers.entrySet()) {
+    for (Entry<ServerLocationAndMemberId, LoadHolder> loadHolderEntry : groupServers.entrySet()) {
-    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
+    Map<ServerLocationAndMemberId, LoadHolder> groupServers = connectionLoadMap.get(group);
-      List bestLHs = findBestServers(groupServers, excludedServers, 1);
+      List bestLHs = findBestServersUsingMemberId(groupServers, excludedServers, 1);
-    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
+    Map<ServerLocationAndMemberId, LoadHolder> groupServers = connectionLoadMap.get(group);
-
-    return new ArrayList<>(groupServers.keySet());
+    ArrayList result = new ArrayList<>();
+    for (ServerLocationAndMemberId locationAndMemberId : groupServers.keySet()) {
+      result.add(locationAndMemberId.getServerLocation());
+    }
+    return result;
-   * Pick the least loaded server in the given group if currentServer is the most loaded server. n
+   * Pick the least loaded server in the given group if currentServer is the most loaded server.
-    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
+    Map<ServerLocationAndMemberId, LoadHolder> groupServers = connectionLoadMap.get(group);
-      List<LoadHolder> bestLHs = findBestServers(groupServers, excludedServers, 1);
+      List<LoadHolder> bestLHs = findBestServersUsingMemberId(groupServers, excludedServers, 1);
-    Map<ServerLocation, LoadHolder> connectionMap = connectionLoadMap.get(null);
+    Map<ServerLocationAndMemberId, LoadHolder> connectionMap = connectionLoadMap.get(null);
-    for (Entry<ServerLocation, LoadHolder> entry : connectionMap
+    for (Entry<ServerLocationAndMemberId, LoadHolder> entry : connectionMap
-      ServerLocation location = entry.getKey();
+      ServerLocation location = entry.getKey().getServerLocation();
+  private void addGroups(Map<String, Map<ServerLocationAndMemberId, LoadHolder>> map,
+      String[] groups,
+      LoadHolder holder, String memberId) {
+    for (String group : groups) {
+      Map<ServerLocationAndMemberId, LoadHolder> groupMap =
+          map.computeIfAbsent(group, k -> new HashMap<>());
+      groupMap.put(new ServerLocationAndMemberId(holder.getLocation(), memberId), holder);
+    }
+    // Special case for GatewayReceiver where we don't put those serverlocation against holder
+    if (!(groups.length > 0 && groups[0].equals(GatewayReceiver.RECEIVER_GROUP))) {
+      Map<ServerLocationAndMemberId, LoadHolder> groupMap =
+          map.computeIfAbsent(null, k -> new HashMap<>());
+      groupMap.put(new ServerLocationAndMemberId(holder.getLocation(), memberId), holder);
+    }
+  }
+
+  private void removeFromMap(Map<String, Map<ServerLocationAndMemberId, LoadHolder>> map,
+      String[] groups,
+      ServerLocation location, String memberId) {
+    ServerLocationAndMemberId locationAndMemberId =
+        new ServerLocationAndMemberId(location, memberId);
+    for (String group : groups) {
+      Map<ServerLocationAndMemberId, LoadHolder> groupMap = map.get(group);
+      if (groupMap != null) {
+        groupMap.remove(locationAndMemberId);
+        if (groupMap.size() == 0) {
+          map.remove(group);
+        }
+      }
+    }
+    Map groupMap = map.get(null);
+    groupMap.remove(locationAndMemberId);
+  }
+
+  private void updateMap(Map map, ServerLocation location, String memberId, float load,
+      float loadPerConnection) {
+    Map groupMap = (Map) map.get(null);
+    ServerLocationAndMemberId locationAndMemberId =
+        new ServerLocationAndMemberId(location, memberId);
+    LoadHolder holder =
+        (LoadHolder) groupMap.get(locationAndMemberId);
+
+    if (holder != null) {
+      holder.setLoad(load, loadPerConnection);
+    }
+  }
+
+  /**
+   *
+   * @param groupServers the servers to consider
+   * @param excludedServers servers to exclude
+   * @param count how many you want. a negative number means all of them in order of best to worst
+   * @return a list of best...worst server LoadHolders
+   */
+  private List<LoadHolder> findBestServersUsingMemberId(
+      Map<ServerLocationAndMemberId, LoadHolder> groupServers,
+      Set<ServerLocation> excludedServers, int count) {
+
+    TreeSet<LoadHolder> bestEntries = new TreeSet<>((l1, l2) -> {
+      int difference = Float.compare(l1.getLoad(), l2.getLoad());
+      if (difference != 0) {
+        return difference;
+      }
+      ServerLocation sl1 = l1.getLocation();
+      ServerLocation sl2 = l2.getLocation();
+      return sl1.compareTo(sl2);
+    });
+
+    boolean retainAll = (count < 0);
+    float lastBestLoad = Float.MAX_VALUE;
+
+    for (Map.Entry<ServerLocationAndMemberId, LoadHolder> loadEntry : groupServers.entrySet()) {
+      ServerLocation location = loadEntry.getKey().getServerLocation();
+      if (excludedServers.contains(location)) {
+        continue;
+      }
+
+      LoadHolder nextLoadReference = loadEntry.getValue();
+      float nextLoad = nextLoadReference.getLoad();
+
+      if ((bestEntries.size() < count) || retainAll || (nextLoad < lastBestLoad)) {
+        bestEntries.add(nextLoadReference);
+        if (!retainAll && (bestEntries.size() > count)) {
+          bestEntries.remove(bestEntries.last());
+        }
+        LoadHolder lastBestHolder = bestEntries.last();
+        lastBestLoad = lastBestHolder.getLoad();
+      }
+    }
+
+    return new ArrayList<>(bestEntries);
+  }
+
+
-      Map<ServerLocation, LoadHolder> groupServers) {
-    final LoadHolder currentLH = groupServers.get(currentServer);
+      Map<ServerLocationAndMemberId, LoadHolder> groupServers) {
+
+    // Check if there are keys in the map that contains currentServer.
+    LoadHolder currentLH = null;
+    for (ServerLocationAndMemberId locationAndMemberId : groupServers.keySet()) {
+      if (currentServer.equals(locationAndMemberId.getServerLocation())) {
+        currentLH = groupServers.get(locationAndMemberId);
+        break;
+      }
+    }
-    for (Map.Entry<ServerLocation, LoadHolder> loadEntry : groupServers.entrySet()) {
-      ServerLocation location = loadEntry.getKey();
+    for (Map.Entry<ServerLocationAndMemberId, LoadHolder> loadEntry : groupServers.entrySet()) {
+      ServerLocation location = loadEntry.getKey().getServerLocation();

MOV31 MOV31 INS31 INS31 INS31 UPD74 INS44 INS44 INS83 INS39 INS42 MOV44 INS44 MOV44 INS8 INS44 INS83 INS39 INS42 INS44 MOV44 INS44 INS44 INS8 UPD83 INS42 INS44 INS44 INS44 UPD83 UPD42 INS44 MOV44 INS44 INS44 INS44 INS8 INS29 INS83 INS74 INS42 INS44 INS44 INS44 INS8 UPD74 INS43 INS42 INS43 INS42 INS43 INS42 INS21 INS43 INS42 UPD74 UPD74 INS60 INS70 INS74 INS42 INS43 INS42 INS43 INS42 INS70 INS25 INS74 INS42 INS5 INS42 UPD43 UPD42 INS43 INS42 INS60 INS70 INS60 INS21 MOV43 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS60 INS60 INS60 INS25 INS65 INS65 INS65 INS65 INS43 INS43 INS74 INS42 INS74 INS42 INS39 INS42 INS60 INS60 INS60 INS70 INS41 UPD74 INS60 INS70 UPD43 INS42 INS42 INS42 INS32 INS42 UPD74 UPD43 UPD43 UPD74 UPD74 INS43 INS59 INS44 MOV32 INS8 INS42 UPD66 UPD74 UPD74 INS43 INS43 INS74 INS42 INS42 INS44 INS42 INS8 INS38 INS8 INS43 INS43 INS74 INS43 INS85 UPD42 INS42 INS43 INS59 INS44 INS42 INS8 INS43 INS59 INS32 INS42 INS43 INS59 INS43 INS59 INS43 INS59 INS27 INS8 INS42 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS42 INS43 INS43 MOV43 INS43 INS43 INS74 INS59 INS39 INS59 INS39 INS59 INS44 INS32 INS8 INS14 INS43 INS43 INS43 INS43 INS59 INS44 INS32 INS8 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 UPD43 UPD42 UPD42 UPD74 UPD43 UPD43 INS42 INS42 MOV14 INS43 INS42 INS21 UPD43 UPD43 UPD74 INS42 INS42 INS43 INS43 INS43 INS43 INS42 INS60 INS21 INS36 INS60 INS21 INS42 INS42 INS43 INS43 INS43 INS42 INS42 INS42 INS14 INS43 INS42 INS60 INS25 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS14 INS42 INS42 INS11 INS42 INS33 MOV21 INS42 INS42 INS42 INS42 INS43 MOV43 INS42 INS14 INS42 INS36 INS42 INS40 INS74 INS42 INS42 INS42 MOV60 INS25 INS60 INS60 INS25 INS74 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS43 INS42 INS42 INS42 INS25 UPD74 INS60 UPD42 UPD43 UPD42 UPD42 INS42 INS32 UPD42 UPD42 INS43 INS42 INS42 INS42 INS42 INS74 INS59 INS32 INS27 INS74 INS59 INS32 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS74 INS59 INS27 INS8 INS42 INS42 INS33 INS43 INS32 INS43 INS42 INS42 INS43 INS32 INS42 INS74 INS86 INS27 MOV43 INS43 INS43 MOV43 INS32 INS8 INS43 INS59 INS39 INS59 INS27 INS8 INS43 INS42 INS32 INS8 INS43 INS43 INS43 MOV43 INS59 INS42 UPD42 UPD42 INS42 INS42 INS32 UPD42 INS42 INS32 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS14 INS42 INS27 INS32 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS43 INS43 MOV43 INS42 INS32 INS42 INS33 INS21 INS25 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 INS43 INS59 INS59 INS8 INS42 INS34 INS42 INS42 INS32 INS42 INS42 INS42 INS18 INS42 INS42 INS32 INS42 INS32 INS36 INS42 INS36 INS21 INS25 INS60 INS21 INS42 INS42 INS42 INS32 INS21 INS10 INS40 INS42 INS42 INS42 INS32 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS86 INS43 INS32 INS42 INS40 INS34 INS2 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS33 INS86 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS8 INS42 INS42 INS42 INS60 INS25 INS60 INS60 INS41 MOV32 INS42 INS42 INS42 INS42 INS42 INS27 INS27 INS32 INS27 INS8 INS43 INS59 INS7 INS42 INS42 INS7 INS32 INS42 INS59 INS14 INS42 INS42 INS42 INS42 INS34 INS59 INS14 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS32 INS34 INS21 INS39 INS59 INS27 INS8 MOV43 INS59 MOV43 INS59 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS38 INS36 INS21 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS74 INS42 INS74 INS42 INS42 INS32 INS42 INS32 INS42 INS34 INS41 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS32 INS42 INS42 INS42 INS42 MOV42 MOV42 UPD42 MOV42 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL21 DEL33 DEL8 DEL83 DEL42 DEL32 DEL59 DEL60
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A processor for sending a message to the elder asking it for the
- * grantor of a dlock service.
+ * A processor for sending a message to the elder asking it for the grantor of a dlock service.
-  
+
-  
+
-  /** 
-   * The number of milliseconds to sleep for elder change if current elder
-   * is departing (and already sent shutdown msg) but is still in the View.
+  /**
+   * The number of milliseconds to sleep for elder change if current elder is departing (and already
+   * sent shutdown msg) but is still in the View.
-    Long.getLong("GrantorRequestProcessor.ELDER_CHANGE_SLEEP", 100).longValue();
-  
+      Long.getLong("GrantorRequestProcessor.ELDER_CHANGE_SLEEP", 100).longValue();
+
-   * Encapsulates the context necessary for processing a given grantor request
-   * for a given InternalDistributedSystem
+   * Encapsulates the context necessary for processing a given grantor request for a given
+   * InternalDistributedSystem
-    
+
-    
+
-    
+
-    
+
-     * If true, we're cooling our heels waiting for the elders to pass
-     * the baton
+     * If true, we're cooling our heels waiting for the elders to pass the baton
-    
+
-      elderLock = new StoppableReentrantLock(cancelCriterion);    
+      elderLock = new StoppableReentrantLock(cancelCriterion);
-  
-  private final static boolean basicStartElderCall(
-      InternalDistributedSystem sys, ElderState es, 
+
+  private final static boolean basicStartElderCall(InternalDistributedSystem sys, ElderState es,
-        // elder is in our vm 
+        // elder is in our vm
-    }
-    finally {
+    } finally {
-  
+
-   * Waits until elder recovery can proceed safely.
-   * Currently this is done by waiting until any in progress
-   * calls to an old elder are complete
+   * Waits until elder recovery can proceed safely. Currently this is done by waiting until any in
+   * progress calls to an old elder are complete
+   * 
-  static void readyForElderRecovery(
-      InternalDistributedSystem sys, InternalDistributedMember elderId,
-      DLockService dls) {
+  static void readyForElderRecovery(InternalDistributedSystem sys,
+      InternalDistributedMember elderId, DLockService dls) {
-      }
-      finally {
+      } finally {
-          elderSyncWait(sys, /*elderId*/ null, dls);
+          elderSyncWait(sys, /* elderId */ null, dls);
-      }
-      finally {
+      } finally {
-  
+
+   * 
-  private static void elderSyncWait(
-      InternalDistributedSystem sys,
-      InternalDistributedMember newElder,
-      DLockService dls) {
+  private static void elderSyncWait(InternalDistributedSystem sys,
+      InternalDistributedMember newElder, DLockService dls) {
-        new Object[] { grc.currentElder, newElder });
+        new Object[] {grc.currentElder, newElder});
-      }
-      finally {
-        if (interrupted) Thread.currentThread().interrupt();
+      } finally {
+        if (interrupted)
+          Thread.currentThread().interrupt();
+
-   * Sets currentElder to the memberId of the current elder if elder is remote;
-   * null if elder is in our vm. TODO: collaboration lock was removed
+   * Sets currentElder to the memberId of the current elder if elder is remote; null if elder is in
+   * our vm. TODO: collaboration lock was removed
-  private final static ElderState startElderCall(
-      InternalDistributedSystem sys,
-      DLockService dls,
+  private final static ElderState startElderCall(InternalDistributedSystem sys, DLockService dls,
-      Assert.assertTrue(elder != null, 
-          "starting an elder call with no valid elder");
+      Assert.assertTrue(elder != null, "starting an elder call with no valid elder");
-          }
-          catch (IllegalStateException e) {
+          } catch (IllegalStateException e) {
-            continue; 
+            continue;
-        }
-        else {
+        } else {
-    
+
-  private final static void finishElderCall(GrantorRequestContext grc,
-      ElderState es) {
+
+  private final static void finishElderCall(GrantorRequestContext grc, ElderState es) {
-      }
-      finally {
+      } finally {
-  
+
-   * Asks the elder who the grantor is for the specified service.
-   * If no grantor exists then makes us the grantor.
+   * Asks the elder who the grantor is for the specified service. If no grantor exists then makes us
+   * the grantor.
+   * 
-   * @return information describing the current grantor of this service
-   * and if it needs recovery.
+   * @return information describing the current grantor of this service and if it needs recovery.
-  public static GrantorInfo getGrantor(DLockService service,
-                                       int dlsSerialNumber,
-                                       InternalDistributedSystem sys) {
+  public static GrantorInfo getGrantor(DLockService service, int dlsSerialNumber,
+      InternalDistributedSystem sys) {
+   * 
-   * @return information describing the current grantor of this service
-   * and if recovery is needed
+   * @return information describing the current grantor of this service and if recovery is needed
-  public static GrantorInfo peekGrantor(DLockService service,
-                                        InternalDistributedSystem sys) {
+  public static GrantorInfo peekGrantor(DLockService service, InternalDistributedSystem sys) {
-  public static GrantorInfo peekGrantor(String serviceName,
-                                        InternalDistributedSystem sys) {
+
+  public static GrantorInfo peekGrantor(String serviceName, InternalDistributedSystem sys) {
-                                           
+
+   * 
-   * @return information describing the previous grantor, if any, and
-   *  if we need to do a grantor recovery
+   * @return information describing the previous grantor, if any, and if we need to do a grantor
+   *         recovery
-  public static GrantorInfo becomeGrantor(DLockService service,
-                                          int dlsSerialNumber,
-                                          InternalDistributedMember oldTurk,
-                                          InternalDistributedSystem sys) {
+  public static GrantorInfo becomeGrantor(DLockService service, int dlsSerialNumber,
+      InternalDistributedMember oldTurk, InternalDistributedSystem sys) {
+   * 
-  public static void clearGrantor(long grantorVersion,
-                                  DLockService service,
-                                  int dlsSerialNumber,
-                                  InternalDistributedSystem sys, 
-                                  boolean withLocks) {
-    basicOp(grantorVersion, service, dlsSerialNumber, sys, null, 
+  public static void clearGrantor(long grantorVersion, DLockService service, int dlsSerialNumber,
+      InternalDistributedSystem sys, boolean withLocks) {
+    basicOp(grantorVersion, service, dlsSerialNumber, sys, null,
+
-  private static GrantorInfo basicOp(long grantorVersion,
-                                     DLockService service,
-                                     int dlsSerialNumber,
-                                     InternalDistributedSystem sys,
-                                     InternalDistributedMember oldTurk,
-                                     byte opCode) {
-    return basicOp(grantorVersion, service.getName(), service, dlsSerialNumber,
-        sys, oldTurk, opCode);
+  private static GrantorInfo basicOp(long grantorVersion, DLockService service, int dlsSerialNumber,
+      InternalDistributedSystem sys, InternalDistributedMember oldTurk, byte opCode) {
+    return basicOp(grantorVersion, service.getName(), service, dlsSerialNumber, sys, oldTurk,
+        opCode);
-  private static GrantorInfo basicOp(long grantorVersion,
-                                     String serviceName,
-                                     DLockService service,
-                                     int dlsSerialNumber,
-                                     InternalDistributedSystem system,
-                                     InternalDistributedMember oldTurk,
-                                     byte opCode) {
+  private static GrantorInfo basicOp(long grantorVersion, String serviceName, DLockService service,
+      int dlsSerialNumber, InternalDistributedSystem system, InternalDistributedMember oldTurk,
+      byte opCode) {
-        final boolean usesElderCollaborationLock = 
-            opCode==GET_OP || opCode==BECOME_OP;
+        final boolean usesElderCollaborationLock = opCode == GET_OP || opCode == BECOME_OP;
-          Assert.assertTrue(service != null, 
-            "Attempting GrantorRequest without instance of DistributedLockService");
+          Assert.assertTrue(service != null,
+              "Attempting GrantorRequest without instance of DistributedLockService");
-        final ElderState es = startElderCall(
-            system, service, usesElderCollaborationLock);
+        final ElderState es = startElderCall(system, service, usesElderCollaborationLock);
-            case GET_OP:
-              result = es.getGrantor(serviceName, dm.getId(), dlsSerialNumber);
-              break;
-            case PEEK_OP:
-              result = es.peekGrantor(serviceName);
-              break;
-            case BECOME_OP:
-              result = es.becomeGrantor(serviceName, dm.getId(), dlsSerialNumber, oldTurk);
-              break;
-            case CLEAR_OP:
-              es.clearGrantor(grantorVersion, serviceName, dlsSerialNumber, 
-                  dm.getId(), false);
-              result = CLEAR_COMPLETE;
-              break;
-            case CLEAR_WITH_LOCKS_OP:
-              es.clearGrantor(grantorVersion, serviceName, dlsSerialNumber, 
-                  dm.getId(), true);
-              result = CLEAR_COMPLETE;
-              break;
-            default:
-              throw new IllegalStateException("Unknown opCode " + opCode);
+              case GET_OP:
+                result = es.getGrantor(serviceName, dm.getId(), dlsSerialNumber);
+                break;
+              case PEEK_OP:
+                result = es.peekGrantor(serviceName);
+                break;
+              case BECOME_OP:
+                result = es.becomeGrantor(serviceName, dm.getId(), dlsSerialNumber, oldTurk);
+                break;
+              case CLEAR_OP:
+                es.clearGrantor(grantorVersion, serviceName, dlsSerialNumber, dm.getId(), false);
+                result = CLEAR_COMPLETE;
+                break;
+              case CLEAR_WITH_LOCKS_OP:
+                es.clearGrantor(grantorVersion, serviceName, dlsSerialNumber, dm.getId(), true);
+                result = CLEAR_COMPLETE;
+                break;
+              default:
+                throw new IllegalStateException("Unknown opCode " + opCode);
-          } 
-          else {
+          } else {
-            GrantorRequestProcessor processor = new GrantorRequestProcessor(system, 
-                grc.currentElder);
-            boolean sent = GrantorRequestMessage.send(grantorVersion, 
-                dlsSerialNumber, serviceName, 
+            GrantorRequestProcessor processor =
+                new GrantorRequestProcessor(system, grc.currentElder);
+            boolean sent = GrantorRequestMessage.send(grantorVersion, dlsSerialNumber, serviceName,
-                logger.trace(LogMarker.DLS, "Unable to communicate with elder {}", grc.currentElder);
+                logger.trace(LogMarker.DLS, "Unable to communicate with elder {}",
+                    grc.currentElder);
-            } 
-            else {
+            } else {
-              
+
-              if (!dm.getDistributionManagerIds().contains(grc.currentElder) &&
-                  dm.getViewMembers().contains(grc.currentElder)) {
+              if (!dm.getDistributionManagerIds().contains(grc.currentElder)
+                  && dm.getViewMembers().contains(grc.currentElder)) {
-                }
-                catch (InterruptedException e) {
+                } catch (InterruptedException e) {
-              
+
-        } 
-        finally {
+        } finally {
-    }
-    finally {
+    } finally {
-  ////////////  Instance methods //////////////
-  
-  /** Creates a new instance of GrantorRequestProcessor
+  //////////// Instance methods //////////////
+
+  /**
+   * Creates a new instance of GrantorRequestProcessor
-  private GrantorRequestProcessor(InternalDistributedSystem system, 
-                                  InternalDistributedMember elder) {
+  private GrantorRequestProcessor(InternalDistributedSystem system,
+      InternalDistributedMember elder) {
-  
-  @Override  
+
+  @Override
-      GrantorInfoReplyMessage giMsg = (GrantorInfoReplyMessage)msg;
+      GrantorInfoReplyMessage giMsg = (GrantorInfoReplyMessage) msg;
-      if (((ReplyMessage)msg).getException() == null) {
+      if (((ReplyMessage) msg).getException() == null) {
-      Assert.assertTrue(false, 
-          "Expected instance of GrantorInfoReplyMessage or CReplyMessage but got " 
-          + msg.getClass());
+      Assert.assertTrue(false,
+          "Expected instance of GrantorInfoReplyMessage or CReplyMessage but got "
+              + msg.getClass());
-  
-  ///////////////   Inner message classes  //////////////////
-  
-  public static final class GrantorRequestMessage
-    extends PooledDistributionMessage implements MessageWithReply
-  {
+
+  /////////////// Inner message classes //////////////////
+
+  public static final class GrantorRequestMessage extends PooledDistributionMessage
+      implements MessageWithReply {
-    
+
-    protected static boolean send(long grantorVersion,
-                             int dlsSerialNumber,
-                             String serviceName,
-                             InternalDistributedMember elder,
-                             DM dm, 
-                             ReplyProcessor21 proc,
-                             InternalDistributedMember oldTurk,
-                             byte opCode)
-    {
+    protected static boolean send(long grantorVersion, int dlsSerialNumber, String serviceName,
+        InternalDistributedMember elder, DM dm, ReplyProcessor21 proc,
+        InternalDistributedMember oldTurk, byte opCode) {
-//      InternalDistributedMember moi = dm.getDistributionManagerId();
-//      Assert.assertTrue(!(
-//        // Sending a message to ourself is REALLY WEIRD, so
-//        // we make that the first test...
-//        moi.equals(dm.getElderId())
-//        && !moi.equals(elder)
-//        && dm.getDistributionManagerIds().contains(elder)
-//        ));
+      // InternalDistributedMember moi = dm.getDistributionManagerId();
+      // Assert.assertTrue(!(
+      // // Sending a message to ourself is REALLY WEIRD, so
+      // // we make that the first test...
+      // moi.equals(dm.getElderId())
+      // && !moi.equals(elder)
+      // && dm.getDistributionManagerIds().contains(elder)
+      // ));
-  
-    @Override  
+
+    @Override
-    
+
-      ReplyMessage.send(this.getSender(), this.getProcessorId(),
-                        null, dm);
+      ReplyMessage.send(this.getSender(), this.getProcessorId(), null, dm);
-    
-    @Override  
+
+    @Override
-      //executeBasicProcess(dm); // TODO change to this after things are stable
+      // executeBasicProcess(dm); // TODO change to this after things are stable
-    
-//    private void executeBasicProcess(final DM dm) {
-//      final GrantorRequestMessage msg = this;
-//      try {
-//        dm.getWaitingThreadPool().execute(new Runnable() {
-//          public void run() {
-//            basicProcess(dm);
-//          }
-//        });
-//      }
-//      catch (RejectedExecutionException e) { {
-//        logger.debug("Rejected processing of <{}>", this, e);
-//      }
-//    }
-    
+
+    // private void executeBasicProcess(final DM dm) {
+    // final GrantorRequestMessage msg = this;
+    // try {
+    // dm.getWaitingThreadPool().execute(new Runnable() {
+    // public void run() {
+    // basicProcess(dm);
+    // }
+    // });
+    // }
+    // catch (RejectedExecutionException e) { {
+    // logger.debug("Rejected processing of <{}>", this, e);
+    // }
+    // }
+
-      case GET_OP:
-        replyGrantorInfo(dm, es.getGrantor(this.serviceName, getSender(), 
-            this.dlsSerialNumber));
-        break;
-      case PEEK_OP:
-        replyGrantorInfo(dm, es.peekGrantor(this.serviceName));
-        break;
-      case BECOME_OP:
-        replyGrantorInfo(dm, es.becomeGrantor(this.serviceName, getSender(), 
-            this.dlsSerialNumber, this.oldTurk));
-        break;
-      case CLEAR_OP:
-        es.clearGrantor(this.grantorVersion, this.serviceName, 
-            this.dlsSerialNumber, getSender(), false);
-        replyClear(dm);
-        break;
-      case CLEAR_WITH_LOCKS_OP:
-        es.clearGrantor(this.grantorVersion, this.serviceName, 
-            this.dlsSerialNumber, getSender(), true);
-        replyClear(dm);
-        break;
-      default:
-        throw new IllegalStateException("Unknown opCode " + this.opCode);
+        case GET_OP:
+          replyGrantorInfo(dm, es.getGrantor(this.serviceName, getSender(), this.dlsSerialNumber));
+          break;
+        case PEEK_OP:
+          replyGrantorInfo(dm, es.peekGrantor(this.serviceName));
+          break;
+        case BECOME_OP:
+          replyGrantorInfo(dm,
+              es.becomeGrantor(this.serviceName, getSender(), this.dlsSerialNumber, this.oldTurk));
+          break;
+        case CLEAR_OP:
+          es.clearGrantor(this.grantorVersion, this.serviceName, this.dlsSerialNumber, getSender(),
+              false);
+          replyClear(dm);
+          break;
+        case CLEAR_WITH_LOCKS_OP:
+          es.clearGrantor(this.grantorVersion, this.serviceName, this.dlsSerialNumber, getSender(),
+              true);
+          replyClear(dm);
+          break;
+        default:
+          throw new IllegalStateException("Unknown opCode " + this.opCode);
-    
+
-    
-    @Override  
-    public void fromData(DataInput in)
-    throws IOException, ClassNotFoundException {
+
+    @Override
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-        this.oldTurk = (InternalDistributedMember)DataSerializer.readObject(in);
+        this.oldTurk = (InternalDistributedMember) DataSerializer.readObject(in);
-    
-    @Override  
+
+    @Override
-    
+
-        case GET_OP:    string = "GET_OP"; break;
-        case BECOME_OP: string = "BECOME_OP"; break;
-        case CLEAR_OP:  string = "CLEAR_OP"; break;
-        case PEEK_OP:   string = "PEEK_OP"; break;
-        case CLEAR_WITH_LOCKS_OP: string = "CLEAR_WITH_LOCKS_OP"; break;
-        default: string = "UNKNOWN:" + String.valueOf(opCode); break;
+        case GET_OP:
+          string = "GET_OP";
+          break;
+        case BECOME_OP:
+          string = "BECOME_OP";
+          break;
+        case CLEAR_OP:
+          string = "CLEAR_OP";
+          break;
+        case PEEK_OP:
+          string = "PEEK_OP";
+          break;
+        case CLEAR_WITH_LOCKS_OP:
+          string = "CLEAR_WITH_LOCKS_OP";
+          break;
+        default:
+          string = "UNKNOWN:" + String.valueOf(opCode);
+          break;
-    
-    @Override  
+
+    @Override
-      buff.append("GrantorRequestMessage (service='")
-        .append(this.serviceName)
-        .append("'; grantorVersion=")
-        .append(this.grantorVersion)
-        .append("'; dlsSerialNumber=")
-        .append(this.dlsSerialNumber)
-        .append("'; processorId=")
-        .append(this.processorId)
-        .append("'; opCode=")
-        .append(opCodeString)
-        .append("'; oldT=")
-        .append(this.oldTurk)
-        .append(")");
+      buff.append("GrantorRequestMessage (service='").append(this.serviceName)
+          .append("'; grantorVersion=").append(this.grantorVersion).append("'; dlsSerialNumber=")
+          .append(this.dlsSerialNumber).append("'; processorId=").append(this.processorId)
+          .append("'; opCode=").append(opCodeString).append("'; oldT=").append(this.oldTurk)
+          .append(")");
-  
+
-    public static void send(MessageWithReply reqMsg, DM dm,
-                            GrantorInfo gi)
-    {
+    public static void send(MessageWithReply reqMsg, DM dm, GrantorInfo gi) {
-    
+
-      return new GrantorInfo(this.grantor, this.elderVersionId, 
-          this.grantorSerialNumber, this.needsRecovery);
+      return new GrantorInfo(this.grantor, this.elderVersionId, this.grantorSerialNumber,
+          this.needsRecovery);
-    
-    @Override  
+
+    @Override
-    
-    @Override  
-    public void fromData(DataInput in)
-    throws IOException, ClassNotFoundException {
+
+    @Override
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      this.grantor = (InternalDistributedMember)DataSerializer.readObject(in);
+      this.grantor = (InternalDistributedMember) DataSerializer.readObject(in);
-    
-    @Override  
+
+    @Override
-    @Override  
+    @Override
-      buff.append("GrantorInfoReplyMessage")
-        .append("; sender=")
-        .append(getSender())
-        .append("; processorId=")
-        .append(super.processorId)
-        .append("; grantor=")
-        .append(this.grantor)
-        .append("; elderVersionId=")
-        .append(this.elderVersionId)
-        .append("; grantorSerialNumber=")
-        .append(this.grantorSerialNumber)
-        .append("; needsRecovery=")
-        .append(this.needsRecovery)
-        .append(")");
+      buff.append("GrantorInfoReplyMessage").append("; sender=").append(getSender())
+          .append("; processorId=").append(super.processorId).append("; grantor=")
+          .append(this.grantor).append("; elderVersionId=").append(this.elderVersionId)
+          .append("; grantorSerialNumber=").append(this.grantorSerialNumber)
+          .append("; needsRecovery=").append(this.needsRecovery).append(")");

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66
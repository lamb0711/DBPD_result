Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- *  
+ * 
-  
+
-  
+
-  
+
-  
+
-  
+
-   * yjing The following code is added to get a set of function executing nodes
-   * by the data aware procedure
+   * yjing The following code is added to get a set of function executing nodes by the data aware
+   * procedure
-  
+
-  
-  private final static ConcurrentHashMap<String , byte[]> idToFunctionAttributes = new ConcurrentHashMap<String, byte[]>();
-  
+
+  private final static ConcurrentHashMap<String, byte[]> idToFunctionAttributes =
+      new ConcurrentHashMap<String, byte[]>();
+
-  
+
-  
+
-        }
-        else {
+        } else {
-      return (byte)1; // ERROR scenario
-    }
-    else {
+      return (byte) 1; // ERROR scenario
+    } else {
-        }
-        else {
+        } else {
-      }
-      else {
+      } else {
-        }
-        else {
+        } else {
-  
+
-  
-  protected AbstractExecution() {
-  }
+
+  protected AbstractExecution() {}
-  
+
-    }
-    else {
+    } else {
-  }  
+  }
+
-  }  
+  }
-  public final void executeFunctionOnLocalPRNode(final Function fn,
-      final FunctionContext cx,
+  public final void executeFunctionOnLocalPRNode(final Function fn, final FunctionContext cx,
-      if(ServerConnection.isExecuteFunctionOnLocalNodeOnly().byteValue() == 1) {
-        ServerConnection.executeFunctionOnLocalNodeOnly((byte)3);//executed locally
+      if (ServerConnection.isExecuteFunctionOnLocalNodeOnly().byteValue() == 1) {
+        ServerConnection.executeFunctionOnLocalNodeOnly((byte) 3);// executed locally
-          ((InternalResultSender)sender)
-          .setException(new FunctionException(
-                  LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT
-                      .toString(fn.getId())));
+          ((InternalResultSender) sender).setException(new FunctionException(
+              LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT
+                  .toString(fn.getId())));
-        
-        final DistributionManager newDM = (DistributionManager)dm;
+
+        final DistributionManager newDM = (DistributionManager) dm;
-              ((InternalResultSender)sender)
-              .setException(new FunctionException(
-                      LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT
-                          .toString(fn.getId())));
+              ((InternalResultSender) sender).setException(new FunctionException(
+                  LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT
+                      .toString(fn.getId())));
-        ((InternalResultSender)sender)
-            .setException(new FunctionException(
-                LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT
-                    .toString(fn.getId())));
+        ((InternalResultSender) sender).setException(new FunctionException(
+            LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT
+                .toString(fn.getId())));
-  public final void executeFunctionOnLocalNode(final Function fn,
-      final FunctionContext cx, final ResultSender sender,
-      DM dm, final boolean isTx) {
+  public final void executeFunctionOnLocalNode(final Function fn, final FunctionContext cx,
+      final ResultSender sender, DM dm, final boolean isTx) {
-      final DistributionManager newDM = (DistributionManager)dm;
+      final DistributionManager newDM = (DistributionManager) dm;
-          if (!((InternalResultSender)sender).isLastResultReceived() && fn.hasResult()) {
-            ((InternalResultSender)sender)
-                .setException(new FunctionException(
-                    LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT
-                        .toString(fn.getId())));
+          if (!((InternalResultSender) sender).isLastResultReceived() && fn.hasResult()) {
+            ((InternalResultSender) sender).setException(new FunctionException(
+                LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT
+                    .toString(fn.getId())));
-    }
-    else {
+    } else {
-      if (!((InternalResultSender)sender).isLastResultReceived() && fn.hasResult()) {
-        ((InternalResultSender)sender)
-            .setException(new FunctionException(
-                LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT
-                    .toString(fn.getId())));
+      if (!((InternalResultSender) sender).isLastResultReceived() && fn.hasResult()) {
+        ((InternalResultSender) sender).setException(new FunctionException(
+            LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT
+                .toString(fn.getId())));
-  public final void executeFunctionLocally(final Function fn,
-      final FunctionContext cx, final ResultSender sender,
-      DM dm) {
+  public final void executeFunctionLocally(final Function fn, final FunctionContext cx,
+      final ResultSender sender, DM dm) {
-    FunctionStats stats = FunctionStats.getFunctionStats(fn.getId(), dm
-        .getSystem());
+    FunctionStats stats = FunctionStats.getFunctionStats(fn.getId(), dm.getSystem());
-        logger.debug("Executing Function: {} on local node with context: {}", fn.getId(), cx.toString());
+        logger.debug("Executing Function: {} on local node with context: {}", fn.getId(),
+            cx.toString());
-    }
-    catch (FunctionInvocationTargetException fite) {
+    } catch (FunctionInvocationTargetException fite) {
-        functionException = new FunctionException(
-            new InternalFunctionInvocationTargetException(fite.getMessage()));
-      }
-      else {
+        functionException =
+            new FunctionException(new InternalFunctionInvocationTargetException(fite.getMessage()));
+      } else {
-    }
-    catch (BucketMovedException bme) {
+    } catch (BucketMovedException bme) {
-        functionException = new FunctionException(
-            new InternalFunctionInvocationTargetException(bme));
-      }
-      else {
+        functionException =
+            new FunctionException(new InternalFunctionInvocationTargetException(bme));
+      } else {
-    }
-    catch (VirtualMachineError e) {
+    } catch (VirtualMachineError e) {
-    }
-    catch (Throwable t) {
+    } catch (Throwable t) {
-    
+
-          LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH
-              .toLocalizedString());
+          LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH.toLocalizedString());
-          LocalizedStrings.ExecuteFunction_THE_FUNCTION_GET_ID_RETURNED_NULL
-              .toLocalizedString());
+          LocalizedStrings.ExecuteFunction_THE_FUNCTION_GET_ID_RETURNED_NULL.toLocalizedString());
-  
+
-   * validates whether a function should execute in presence of transaction
-   * and HeapCritical members. If the function is the first operation in a
-   * transaction, bootstraps the function.
+   * validates whether a function should execute in presence of transaction and HeapCritical
+   * members. If the function is the first operation in a transaction, bootstraps the function.
+   * 
-  public final LocalResultCollector<?, ?> getLocalResultCollector(
-      Function function, final ResultCollector<?, ?> rc) {
+  public final LocalResultCollector<?, ?> getLocalResultCollector(Function function,
+      final ResultCollector<?, ?> rc) {
-      return (LocalResultCollector)rc;
-    }
-    else {
+      return (LocalResultCollector) rc;
+    } else {
-  
+
-   * Returns the function attributes defined by the functionId, returns null if no
-   * function is found for the specified functionId
+   * Returns the function attributes defined by the functionId, returns null if no function is found
+   * for the specified functionId
-   * @throws FunctionException
-   *                 if functionID passed is null
+   * @throws FunctionException if functionID passed is null
-      throw new FunctionException(
-          LocalizedStrings.FunctionService_0_PASSED_IS_NULL
-              .toLocalizedString("functionId instance "));
+      throw new FunctionException(LocalizedStrings.FunctionService_0_PASSED_IS_NULL
+          .toLocalizedString("functionId instance "));
-  
+
-  
-  public ResultCollector execute(String functionName, boolean hasResult)
-      throws FunctionException {
+
+  public ResultCollector execute(String functionName, boolean hasResult) throws FunctionException {
-    
-    byte registeredFunctionState = AbstractExecution.getFunctionState(
-        functionObject.isHA(), functionObject.hasResult(), functionObject
-            .optimizeForWrite());
+
+    byte registeredFunctionState = AbstractExecution.getFunctionState(functionObject.isHA(),
+        functionObject.hasResult(), functionObject.optimizeForWrite());
-    
+
-  
-  public ResultCollector execute(String functionName, boolean hasResult, boolean isHA) throws FunctionException {
+
+  public ResultCollector execute(String functionName, boolean hasResult, boolean isHA)
+      throws FunctionException {
-          LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH
-              .toLocalizedString());
+          LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH.toLocalizedString());
-    byte registeredFunctionState = AbstractExecution.getFunctionState(
-        functionObject.isHA(), functionObject.hasResult(), functionObject
-            .optimizeForWrite());
+    byte registeredFunctionState = AbstractExecution.getFunctionState(functionObject.isHA(),
+        functionObject.hasResult(), functionObject.optimizeForWrite());
-    
+
-  
-  public ResultCollector execute(String functionName, boolean hasResult, boolean isHA, boolean isOptimizeForWrite) throws FunctionException {
+
+  public ResultCollector execute(String functionName, boolean hasResult, boolean isHA,
+      boolean isOptimizeForWrite) throws FunctionException {
-          LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH
-              .toLocalizedString());
+          LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH.toLocalizedString());
-    byte registeredFunctionState = AbstractExecution.getFunctionState(
-        functionObject.isHA(), functionObject.hasResult(), functionObject
-            .optimizeForWrite());
+    byte registeredFunctionState = AbstractExecution.getFunctionState(functionObject.isHA(),
+        functionObject.hasResult(), functionObject.optimizeForWrite());
-    
+
-  
+
-      final FunctionContext cx, final ResultSender sender,
-      DM dm){
-    FunctionStats stats = FunctionStats.getFunctionStats(fn.getId(), dm
-        .getSystem());
-    
+      final FunctionContext cx, final ResultSender sender, DM dm) {
+    FunctionStats stats = FunctionStats.getFunctionStats(fn.getId(), dm.getSystem());
+
-      logger.debug("Exception occured on local node while executing Function: {}", fn.getId(), functionException);
+      logger.debug("Exception occured on local node while executing Function: {}", fn.getId(),
+          functionException);
-        if(functionException instanceof FunctionException
+        if (functionException instanceof FunctionException
-        ((InternalResultSender)sender).setException(functionException);
+        ((InternalResultSender) sender).setException(functionException);
-      logger.warn(LocalizedMessage.create(
-            LocalizedStrings.FunctionService_EXCEPTION_ON_LOCAL_NODE), functionException);
+      logger.warn(LocalizedMessage.create(LocalizedStrings.FunctionService_EXCEPTION_ON_LOCAL_NODE),
+          functionException);

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * An implementation of <code>GfManagerAgent</code> that uses a {@link
- * DistributionManager} to communicate with other members of the
- * distributed system.  Because it is a
- * <code>MembershipListener</code> it is alerted when members join and
- * leave the distributed system.  It also implements support for
- * {@link JoinLeaveListener}s as well suport for collecting and
- * collating the pieces of a {@linkplain CacheCollector cache
- * snapshot}.
+ * An implementation of <code>GfManagerAgent</code> that uses a {@link DistributionManager} to
+ * communicate with other members of the distributed system. Because it is a
+ * <code>MembershipListener</code> it is alerted when members join and leave the distributed system.
+ * It also implements support for {@link JoinLeaveListener}s as well suport for collecting and
+ * collating the pieces of a {@linkplain CacheCollector cache snapshot}.
-  // Note that since we export the instances in a public list,
-  // I'm not permitting subclasses
-  final 
-  class RemoteGfManagerAgent implements GfManagerAgent {
+// Note that since we export the instances in a public list,
+// I'm not permitting subclasses
+final class RemoteGfManagerAgent implements GfManagerAgent {
-  
+
-  /** The connection to the distributed system through which this
-   * admin agent communicates
+  /**
+   * The connection to the distributed system through which this admin agent communicates
-   * @since GemFire 4.0 */
+   * @since GemFire 4.0
+   */
-  /** A daemon thread that continuously attempts to connect to the
-   * distributed system. */
+  /**
+   * A daemon thread that continuously attempts to connect to the distributed system.
+   */
-  protected /*final*/ int alertLevel;
+  protected /* final */ int alertLevel;
-  
-  /** 
-   * Optional display name used for {@link 
-   * org.apache.geode.distributed.DistributedSystem#getName()}.
+
+  /**
+   * Optional display name used for
+   * {@link org.apache.geode.distributed.DistributedSystem#getName()}.
-  /** The known application VMs.  Maps member id to
-   * RemoteApplicationVM instances */
+  /**
+   * The known application VMs. Maps member id to RemoteApplicationVM instances
+   */
-  /** A queue of <code>SnapshotResultMessage</code>s the are processed
-   * by a SnapshotResultDispatcher */
+  /**
+   * A queue of <code>SnapshotResultMessage</code>s the are processed by a SnapshotResultDispatcher
+   */
-  /** True if the currentJoin needs to be aborted because the member
-   * has left */
+  /**
+   * True if the currentJoin needs to be aborted because the member has left
+   */
-  /** Has this <code>RemoteGfManagerAgent</code> been initialized?
-   * That is, after it has been connected has this agent created admin
-   * objects for the initial members of the distributed system? */
+  /**
+   * Has this <code>RemoteGfManagerAgent</code> been initialized? That is, after it has been
+   * connected has this agent created admin objects for the initial members of the distributed
+   * system?
+   */
-  /** Has this agent manager been disconnected?
+  /**
+   * Has this agent manager been disconnected?
-  
-  private DisconnectListener  disconnectListener;
-  
+
+  private DisconnectListener disconnectListener;
+
-  
+
-  
+
-  
+
-  
+
-  
+
-    if (emergencyClassesLoaded) return;
+    if (emergencyClassesLoaded)
+      return;
-  
+
-    for (int i = 0; i < members.size(); i ++) {
-      RemoteGfManagerAgent each = (RemoteGfManagerAgent)members.get(i);
+    for (int i = 0; i < members.size(); i++) {
+      RemoteGfManagerAgent each = (RemoteGfManagerAgent) members.get(i);
-  
+
-   * Return a recent (though possibly incomplete) list of
-   * all existing agents
+   * Return a recent (though possibly incomplete) list of all existing agents
-  
+
-   * Creates a new <code>RemoteGfManagerAgent</code> accord to the
-   * given config.  Along the way it (attempts to) connects to the
-   * distributed system.
+   * Creates a new <code>RemoteGfManagerAgent</code> accord to the given config. Along the way it
+   * (attempts to) connects to the distributed system.
-      throw new IllegalArgumentException(LocalizedStrings.RemoteGfManagerAgent_EXPECTED_0_TO_BE_A_REMOTETRANSPORTCONFIG.toLocalizedString(cfg.getTransport()));
+      throw new IllegalArgumentException(
+          LocalizedStrings.RemoteGfManagerAgent_EXPECTED_0_TO_BE_A_REMOTETRANSPORTCONFIG
+              .toLocalizedString(cfg.getTransport()));
-    this.transport = (RemoteTransportConfig)cfg.getTransport();
+    this.transport = (RemoteTransportConfig) cfg.getTransport();
-        addJoinLeaveListener((JoinLeaveListener)this.alertListener);
+        addJoinLeaveListener((JoinLeaveListener) this.alertListener);
-    
-    // LOG: get LogWriter from the AdminDistributedSystemImpl -- used for AuthenticationFailedException
+
+    // LOG: get LogWriter from the AdminDistributedSystemImpl -- used for
+    // AuthenticationFailedException
-    
+
-    this.threadGroup =
-      LoggingThreadGroup.createThreadGroup("ConsoleDMDaemon", logger);
+    this.threadGroup = LoggingThreadGroup.createThreadGroup("ConsoleDMDaemon", logger);
-    
+
-  
+
-    } 
-    catch (InterruptedException ignore) {
+    } catch (InterruptedException ignore) {
-   * Handles an <code>ExecutionException</code> by examining its cause
-   * and throwing an appropriate runtime exception.
+   * Handles an <code>ExecutionException</code> by examining its cause and throwing an appropriate
+   * runtime exception.
-    // misleading.  For instance, the cause might have occurred in a
-    // different thread.  In addition to the cause, we also want to
+    // misleading. For instance, the cause might have occurred in a
+    // different thread. In addition to the cause, we also want to
-    throw new RuntimeAdminException(LocalizedStrings.RemoteGfManagerAgent_AN_EXCEPUTIONEXCEPTION_WAS_THROWN_WHILE_WAITING_FOR_FUTURE.toLocalizedString(), ex);
+    throw new RuntimeAdminException(
+        LocalizedStrings.RemoteGfManagerAgent_AN_EXCEPUTIONEXCEPTION_WAS_THROWN_WHILE_WAITING_FOR_FUTURE
+            .toLocalizedString(),
+        ex);
-  public String toString(){
+  public String toString() {
-   * Disconnects this agent from the distributed system.  If this is a
-   * dedicated administration VM, then the underlying connection to the
-   * distributed system is also closed.
+   * Disconnects this agent from the distributed system. If this is a dedicated administration VM,
+   * then the underlying connection to the distributed system is also closed.
-    synchronized(this) {
+    synchronized (this) {
-      //joinProcessor.interrupt();
+      // joinProcessor.interrupt();
-      if (this.isConnected() ||(this.membersMap.size()>0)) { //Hot fix from 6.6.3
-        RemoteApplicationVM[] apps = (RemoteApplicationVM[])listApplications(disconnectedTrue);
-        for (int i=0; i < apps.length; i++) {
+      if (this.isConnected() || (this.membersMap.size() > 0)) { // Hot fix from 6.6.3
+        RemoteApplicationVM[] apps = (RemoteApplicationVM[]) listApplications(disconnectedTrue);
+        for (int i = 0; i < apps.length; i++) {
-            apps[i].disconnect(removeListener); // hit NPE here in ConsoleDistributionManagerTest so fixed listApplications to exclude nulls returned from future
+            apps[i].disconnect(removeListener); // hit NPE here in ConsoleDistributionManagerTest so
+                                                // fixed listApplications to exclude nulls returned
+                                                // from future
-        if (system != null && DistributionManager.isDedicatedAdminVM &&
-            system.isConnected()) {
+        if (system != null && DistributionManager.isDedicatedAdminVM && system.isConnected()) {
-      
+
-    }
-    finally {
+    } finally {
-   * Returns whether or not this manager agent has created admin
-   * objects for the initial members of the distributed system.
+   * Returns whether or not this manager agent has created admin objects for the initial members of
+   * the distributed system.
-  
+
-  public ApplicationVM[] listApplications(boolean disconnected) {//Hot fix from 6.6.3
-    if (isConnected() ||(this.membersMap.size()>0 && disconnected)) {
+  public ApplicationVM[] listApplications(boolean disconnected) {// Hot fix from 6.6.3
+    if (isConnected() || (this.membersMap.size() > 0 && disconnected)) {
-      VMS: for (Iterator iter = this.membersMap.values().iterator();
-           iter.hasNext(); ) {
+      VMS: for (Iterator iter = this.membersMap.values().iterator(); iter.hasNext();) {
-          } 
-          catch (InterruptedException ex) {
+          } catch (InterruptedException ex) {
-          } 
-          catch (CancellationException ex) {
+          } catch (CancellationException ex) {
-          } 
-          catch (ExecutionException ex) {
+          } catch (ExecutionException ex) {
-          }
-          finally {
+          } finally {
-      RemoteApplicationVM[] array =
-        new RemoteApplicationVM[remoteApplicationVMs.size()];
+      RemoteApplicationVM[] array = new RemoteApplicationVM[remoteApplicationVMs.size()];
-   * Registers a <code>JoinLeaveListener</code>. on this agent that is
-   * notified when membership in the distributed system changes.
+   * Registers a <code>JoinLeaveListener</code>. on this agent that is notified when membership in
+   * the distributed system changes.
-  public void addJoinLeaveListener( JoinLeaveListener observer ) {
+  public void addJoinLeaveListener(JoinLeaveListener observer) {
-  public void removeJoinLeaveListener( JoinLeaveListener observer ) {
+  public void removeJoinLeaveListener(JoinLeaveListener observer) {
-   * Sets the <code>CacheCollector</code> that
-   * <code>CacheSnapshot</code>s are delivered to.
+   * Sets the <code>CacheCollector</code> that <code>CacheSnapshot</code>s are delivered to.
-      protected Object initialValue() {
-        return Boolean.FALSE;
-      }
-    };
+    protected Object initialValue() {
+      return Boolean.FALSE;
+    }
+  };
-        throw new OperationCancelledException(LocalizedStrings.RemoteGfManagerAgent_RECURSION_DETECTED_WHILE_SENDING_0.toLocalizedString(msg));
+        throw new OperationCancelledException(
+            LocalizedStrings.RemoteGfManagerAgent_RECURSION_DETECTED_WHILE_SENDING_0
+                .toLocalizedString(msg));
-      DistributionManager dm =
-        (DistributionManager) this.system.getDistributionManager();
+      DistributionManager dm = (DistributionManager) this.system.getDistributionManager();
-      } 
-      else {
+      } else {
-        throw new RuntimeAdminException(LocalizedStrings.RemoteGfManagerAgent_0_IS_NOT_CURRENTLY_CONNECTED.toLocalizedString(this));
+        throw new RuntimeAdminException(
+            LocalizedStrings.RemoteGfManagerAgent_0_IS_NOT_CURRENTLY_CONNECTED
+                .toLocalizedString(this));
+
-   * Returns the distributed system member (application VM or system
-   * VM) with the given <code>id</code>.
+   * Returns the distributed system member (application VM or system VM) with the given
+   * <code>id</code>.
-        } 
-        catch (InterruptedException ex) {
+        } catch (InterruptedException ex) {
-        } 
-        catch (CancellationException ex) {
+        } catch (CancellationException ex) {
-        } 
-        catch (ExecutionException ex) {
+        } catch (ExecutionException ex) {
-        }
-        finally {
+        } finally {
-    } 
-    else {
+    } else {
-   * Returns a representation of the application VM with the given
-   * distributed system id.  If there does not already exist a
-   * representation for that member, a new one is created.
+   * Returns a representation of the application VM with the given distributed system id. If there
+   * does not already exist a representation for that member, a new one is created.
-        if (this.abortCurrentJoin) return null;
+        if (this.abortCurrentJoin)
+          return null;
-            public Object call() throws Exception {
-              // Do this work in a Future to avoid deadlock seen in
-              // bug 31562.
-              RemoteGfManagerAgent agent = RemoteGfManagerAgent.this;
-              RemoteApplicationVM result =
-                new RemoteApplicationVM(agent, id, alertLevel);
-              result.startStatDispatcher();
-              if (agent.abortCurrentJoin) {
-                result.stopStatListening();
-                return null;
-              }
-              return result;
+          public Object call() throws Exception {
+            // Do this work in a Future to avoid deadlock seen in
+            // bug 31562.
+            RemoteGfManagerAgent agent = RemoteGfManagerAgent.this;
+            RemoteApplicationVM result = new RemoteApplicationVM(agent, id, alertLevel);
+            result.startStatDispatcher();
+            if (agent.abortCurrentJoin) {
+              result.stopStatListening();
+              return null;
-          });
+            return result;
+          }
+        });
-        if (this.abortCurrentJoin) return null;
+        if (this.abortCurrentJoin)
+          return null;
-      } 
-      catch (InterruptedException ex) {
+      } catch (InterruptedException ex) {
-      } 
-      catch (CancellationException ex) {
+      } catch (CancellationException ex) {
-      } 
-      catch (ExecutionException ex) {
+      } catch (ExecutionException ex) {
-      }
-      finally {
+      } finally {
-   * Removes and returns the representation of the application VM
-   * member of the distributed system with the given <code>id</code>.
+   * Removes and returns the representation of the application VM member of the distributed system
+   * with the given <code>id</code>.
-        if ( future != null) {
+        if (future != null) {
-        } 
-        catch (InterruptedException ex) {
+        } catch (InterruptedException ex) {
-        } 
-        catch (CancellationException ex) {
+        } catch (CancellationException ex) {
-        } 
-        catch (ExecutionException ex) {
+        } catch (ExecutionException ex) {
-        }
-        finally {
+        } finally {
-   * Places a <code>SnapshotResultMessage</code> on a queue to be
-   * processed asynchronously.
+   * Places a <code>SnapshotResultMessage</code> on a queue to be processed asynchronously.
-      } 
-      catch (InterruptedException ignore) {
+      } catch (InterruptedException ignore) {
-      }
-      finally {
+      } finally {
-   * Sends the given <code>alert</code> to this agent's {@link
-   * AlertListener}.
+   * Sends the given <code>alert</code> to this agent's {@link AlertListener}.
-   * Invokes the {@link CacheCollector#resultsReturned} method of this
-   * agent's cache collector.
+   * Invokes the {@link CacheCollector#resultsReturned} method of this agent's cache collector.
-                                  int snapshotId) {
+      int snapshotId) {
-    if (collector != null ) {
+    if (collector != null) {
-  
+
-  
+
-   * Creates a new {@link InternalDistributedSystem} connection for
-   * this agent.  If one alread exists, it is
-   * <code>disconnected</code> and a new one is created.
+   * Creates a new {@link InternalDistributedSystem} connection for this agent. If one alread
+   * exists, it is <code>disconnected</code> and a new one is created.
-    this.system = (InternalDistributedSystem)
-      InternalDistributedSystem.connectForAdmin(props);
+    this.system = (InternalDistributedSystem) InternalDistributedSystem.connectForAdmin(props);
-    
-    synchronized(this) {
+
+    synchronized (this) {
-    this.system.addDisconnectListener(new
-      InternalDistributedSystem.DisconnectListener() {
+    this.system.addDisconnectListener(new InternalDistributedSystem.DisconnectListener() {
-        public String toString() {
-          return LocalizedStrings.RemoteGfManagerAgent_DISCONNECT_LISTENER_FOR_0.toLocalizedString(RemoteGfManagerAgent.this);
-        }
-        
-        public void onDisconnect(InternalDistributedSystem sys) {
-         //Before the disconnect handler is called, the InternalDistributedSystem has already marked itself for 
-         //the disconnection. Hence the check for RemoteGfManagerAgent.this.isConnected() always returns false.
-         //Hence commenting the same.	
-         //if(RemoteGfManagerAgent.this.isConnected()) {
-          boolean reconnect = sys.isReconnecting();
-          if (!reconnect) {
-            final DisconnectListener listener = RemoteGfManagerAgent.this.getDisconnectListener();
-            if (RemoteGfManagerAgent.this.disconnect()) { // returns true if disconnected during this call
-              if (listener != null) {
-                listener.onDisconnect(sys); 
-              }
+      public String toString() {
+        return LocalizedStrings.RemoteGfManagerAgent_DISCONNECT_LISTENER_FOR_0
+            .toLocalizedString(RemoteGfManagerAgent.this);
+      }
+
+      public void onDisconnect(InternalDistributedSystem sys) {
+        // Before the disconnect handler is called, the InternalDistributedSystem has already marked
+        // itself for
+        // the disconnection. Hence the check for RemoteGfManagerAgent.this.isConnected() always
+        // returns false.
+        // Hence commenting the same.
+        // if(RemoteGfManagerAgent.this.isConnected()) {
+        boolean reconnect = sys.isReconnecting();
+        if (!reconnect) {
+          final DisconnectListener listener = RemoteGfManagerAgent.this.getDisconnectListener();
+          if (RemoteGfManagerAgent.this.disconnect()) { // returns true if disconnected during this
+                                                        // call
+            if (listener != null) {
+              listener.onDisconnect(sys);
-      });
-    InternalDistributedSystem.addReconnectListener(new ReconnectListener() {
-      public void reconnecting(InternalDistributedSystem oldsys) {
+    });
+    InternalDistributedSystem.addReconnectListener(new ReconnectListener() {
+      public void reconnecting(InternalDistributedSystem oldsys) {}
+
-          logger.debug("RemoteGfManagerAgent.onReconnect attempting to join new distributed system");
+          logger
+              .debug("RemoteGfManagerAgent.onReconnect attempting to join new distributed system");
-    synchronized(this.myMembershipListenerLock) {
+    synchronized (this.myMembershipListenerLock) {
-        
-        for (Iterator it = initialMembers.iterator(); it.hasNext(); ) {
+
+        for (Iterator it = initialMembers.iterator(); it.hasNext();) {
-  
+
-  
+
-  
-      for (Iterator it = initialMembers.iterator(); it.hasNext(); ) {
+
+      for (Iterator it = initialMembers.iterator(); it.hasNext();) {
-  
-        // Create the admin objects synchronously.  We don't need to use
+
+        // Create the admin objects synchronously. We don't need to use
-  
+
-    } //sync
+    } // sync
-//  /**
-//   * Returns whether or not there are any members of the distributed
-//   * system. 
-//   */
-//  private boolean membersExist() {
-//    // removed synchronized(members) {
-//    // removed synchronized (managers) {
-//    return this.members.size() > 0 || this.managers.size() > 0;
-//  }
+  // /**
+  // * Returns whether or not there are any members of the distributed
+  // * system.
+  // */
+  // private boolean membersExist() {
+  // // removed synchronized(members) {
+  // // removed synchronized (managers) {
+  // return this.members.size() > 0 || this.managers.size() > 0;
+  // }
-   * Returns the thread group in which admin threads should run.  This
-   * thread group handles uncaught exceptions nicely.
+   * Returns the thread group in which admin threads should run. This thread group handles uncaught
+   * exceptions nicely.
-   * A Daemon thread that asynchronously connects to the distributed
-   * system.  It is necessary to nicely handle the situation when the
-   * user accidentally connects to a distributed system with no
-   * members or attempts to connect to a distributed system whose
-   * member run a different version of GemFire.
+   * A Daemon thread that asynchronously connects to the distributed system. It is necessary to
+   * nicely handle the situation when the user accidentally connects to a distributed system with no
+   * members or attempts to connect to a distributed system whose member run a different version of
+   * GemFire.
-  private class DSConnectionDaemon extends Thread  {
+  private class DSConnectionDaemon extends Thread {
-      super(RemoteGfManagerAgent.this.threadGroup,
-            "DSConnectionDaemon");
+      super(RemoteGfManagerAgent.this.threadGroup, "DSConnectionDaemon");
-     * Keep trying to connect to the distributed system.  If we have
-     * problems connecting, the agent will not be marked as
-     * "connected".
+     * Keep trying to connect to the distributed system. If we have problems connecting, the agent
+     * will not be marked as "connected".
-    TOP:
-      while(!shutDown) {
+      TOP: while (!shutDown) {
-            if (isListening()){
+            if (isListening()) {
-        } catch(IncompatibleSystemException ise) {
+        } catch (IncompatibleSystemException ise) {
-          for (Throwable cause = e; cause != null;
-               cause = cause.getCause()) {
+          for (Throwable cause = e; cause != null; cause = cause.getCause()) {
-              // We were interrupted while connecting.  Most likely we
+              // We were interrupted while connecting. Most likely we
-                LocalizedStrings.RemoteGFManagerAgent_AN_AUTHENTICATIONFAILEDEXCEPTION_WAS_CAUGHT_WHILE_CONNECTING_TO_DS, e);
+                  LocalizedStrings.RemoteGFManagerAgent_AN_AUTHENTICATIONFAILEDEXCEPTION_WAS_CAUGHT_WHILE_CONNECTING_TO_DS,
+                  e);
-        } catch (InterruptedException ignore){
+        } catch (InterruptedException ignore) {
-   * A daemon thread that reads {@link SnapshotResultMessage}s from a
-   * queue and invokes the <code>CacheCollector</code> accordingly.
+   * A daemon thread that reads {@link SnapshotResultMessage}s from a queue and invokes the
+   * <code>CacheCollector</code> accordingly.
-  private class SnapshotResultDispatcher extends Thread  {
+  private class SnapshotResultDispatcher extends Thread {
-      super(RemoteGfManagerAgent.this.threadGroup,
-            "SnapshotResultDispatcher");
+      super(RemoteGfManagerAgent.this.threadGroup, "SnapshotResultDispatcher");
-          SnapshotResultMessage msg = (SnapshotResultMessage)snapshotResults.take();
-          callCacheCollector(msg.getSnapshot(), msg.getSender(),
-                             msg.getSnapshotId());
+          SnapshotResultMessage msg = (SnapshotResultMessage) snapshotResults.take();
+          callCacheCollector(msg.getSnapshot(), msg.getSender(), msg.getSnapshotId());
-          logger.warn(LocalizedMessage.create(LocalizedStrings.RemoteGfManagerAgent_IGNORING_STRANGE_INTERRUPT), ignore);
-        } catch (Exception ex) {          
+          logger.warn(LocalizedMessage
+              .create(LocalizedStrings.RemoteGfManagerAgent_IGNORING_STRANGE_INTERRUPT), ignore);
+        } catch (Exception ex) {
-    if (getBindAddress() == null) return false;
+    if (getBindAddress() == null)
+      return false;
-   * Sets the alert level for this manager agent.  Sends a {@link
-   * AlertLevelChangeMessage} to each member of the distributed system.
+   * Sets the alert level for this manager agent. Sends a {@link AlertLevelChangeMessage} to each
+   * member of the distributed system.
-   * Handles a membership join asynchronously from the memberJoined
-   * notification.  Sets and clears current join.  Also makes several checks
-   * to support aborting of the current join.
+   * Handles a membership join asynchronously from the memberJoined notification. Sets and clears
+   * current join. Also makes several checks to support aborting of the current join.
-        GemFireVM member = null;
-        switch (id.getVmKind()) {
+      GemFireVM member = null;
+      switch (id.getVmKind()) {
-          break;  // should this ever happen? :-)
+          break; // should this ever happen? :-)
-          throw new IllegalArgumentException(LocalizedStrings.RemoteGfManagerAgent_UNKNOWN_VM_KIND_0.toLocalizedString(Integer.valueOf(id.getVmKind())));
-        }
+          throw new IllegalArgumentException(LocalizedStrings.RemoteGfManagerAgent_UNKNOWN_VM_KIND_0
+              .toLocalizedString(Integer.valueOf(id.getVmKind())));
+      }
-        // if we have a valid member process it...
+      // if we have a valid member process it...
+      if (this.abortCurrentJoin) {
+        return;
+      }
+      if (member != null) {
-        if (member != null) {
+        for (Iterator it = this.listeners.iterator(); it.hasNext();) {
-          for (Iterator it = this.listeners.iterator(); it.hasNext();) {
-            if (this.abortCurrentJoin) {
-              return;
-            }
-            JoinLeaveListener l = (JoinLeaveListener)it.next();
-            try {
-              l.nodeJoined(RemoteGfManagerAgent.this, member);
-            }
-            catch (VirtualMachineError e) {
-              SystemFailure.initiateFailure(e);
-              throw e;
-            }
-            catch (Throwable e) {
-              SystemFailure.checkFailure();
-              logger.warn(LocalizedMessage.create(
-                LocalizedStrings.RemoteGfManagerAgent_LISTENER_THREW_AN_EXCEPTION), e);
-            }
+          JoinLeaveListener l = (JoinLeaveListener) it.next();
+          try {
+            l.nodeJoined(RemoteGfManagerAgent.this, member);
+          } catch (VirtualMachineError e) {
+            SystemFailure.initiateFailure(e);
+            throw e;
+          } catch (Throwable e) {
+            SystemFailure.checkFailure();
+            logger.warn(LocalizedMessage
+                .create(LocalizedStrings.RemoteGfManagerAgent_LISTENER_THREW_AN_EXCEPTION), e);
+      }
-    }
-    finally {
+    } finally {
-   * Adds a pending join entry. Note: attempting to reuse the same ArrayList
-   * instance results in some interesting deadlocks.
+   * Adds a pending join entry. Note: attempting to reuse the same ArrayList instance results in
+   * some interesting deadlocks.
-   * Removes any pending joins that match the member id. Note: attempting to
-   * reuse the same ArrayList instance results in some interesting deadlocks.
+   * Removes any pending joins that match the member id. Note: attempting to reuse the same
+   * ArrayList instance results in some interesting deadlocks.
-    }
-    finally {
+    } finally {
-   * Processes pending membership joins in a dedicated thread.  If we
-   * processed the joins in the same thread as the membership handler,
-   * then we run the risk of getting deadlocks and such.
+   * Processes pending membership joins in a dedicated thread. If we processed the joins in the same
+   * thread as the membership handler, then we run the risk of getting deadlocks and such.
-  //FIXME: Revisit/redesign this code
-  private class JoinProcessor extends Thread  {
+  // FIXME: Revisit/redesign this code
+  private class JoinProcessor extends Thread {
-      super(RemoteGfManagerAgent.this.threadGroup,
-            "JoinProcessor");
+      super(RemoteGfManagerAgent.this.threadGroup, "JoinProcessor");
+
+
+
-//       if (this.shutDown) {
-//         return;
-//       }
+      // if (this.shutDown) {
+      // return;
+      // }
-//       Assert.assertTrue(this.isAlive());
+      // Assert.assertTrue(this.isAlive());
-      synchronized(this.lock) {
+      synchronized (this.lock) {
-    OUTER:
-      while (!this.shutDown) {
+      OUTER: while (!this.shutDown) {
-//        Thread.interrupted(); // clear the interrupted flag
+        // Thread.interrupted(); // clear the interrupted flag
-//            Thread.interrupted(); // clear the interrupted flag
-            synchronized(this.lock) {
+            // Thread.interrupted(); // clear the interrupted flag
+            synchronized (this.lock) {
-          if (this.paused) continue;
+          if (this.paused)
+            continue;
-          if (this.paused) continue;
+          if (this.paused)
+            continue;
-            }
-            finally {
+            } finally {
-        }
-        catch (CancelException e) {
+        } catch (CancelException e) {
-        }
-        catch (InterruptedException ignore) {
+        } catch (InterruptedException ignore) {
-          if (this.paused || noPendingJoins) {//fix for #39893
+          if (this.paused || noPendingJoins) {// fix for #39893
-             * JoinProcessor waits when:
-             * 1. this.paused is set to true
-             * 2. There are no pending joins
+             * JoinProcessor waits when: 1. this.paused is set to true 2. There are no pending joins
-             * If the JoinProcessor is interrupted when it was waiting due to 
-             * second reason, it should still continue after catching 
-             * InterruptedException. From code, currently, JoinProcessor is 
-             * interrupted through JoinProcessor.abort() method which is called 
+             * If the JoinProcessor is interrupted when it was waiting due to second reason, it
+             * should still continue after catching InterruptedException. From code, currently,
+             * JoinProcessor is interrupted through JoinProcessor.abort() method which is called
-              logger.debug("JoinProcessor was interrupted when it was paused, now resuming ...", ignore);
+              logger.debug("JoinProcessor was interrupted when it was paused, now resuming ...",
+                  ignore);
-//          logger.warning("Unexpected thread interrupt", ignore);
+          // logger.warning("Unexpected thread interrupt", ignore);
-        } 
-        catch (VirtualMachineError err) {
+        } catch (VirtualMachineError err) {
-          // If this ever returns, rethrow the error.  We're poisoned
+          // If this ever returns, rethrow the error. We're poisoned
-        }
-        catch (Throwable e) {
+        } catch (Throwable e) {
-          // catch VirtualMachineError (see above).  However, there is
+          // catch VirtualMachineError (see above). However, there is
-          for (Throwable cause = e.getCause(); cause != null;
-               cause = cause.getCause()) {
+          for (Throwable cause = e.getCause(); cause != null; cause = cause.getCause()) {
-          logger.error(LocalizedMessage.create(LocalizedStrings.RemoteGfManagerAgent_JOINPROCESSOR_CAUGHT_EXCEPTION), e);
+          logger.error(LocalizedMessage
+              .create(LocalizedStrings.RemoteGfManagerAgent_JOINPROCESSOR_CAUGHT_EXCEPTION), e);
-    
+
-  
+
-    
+
-    
+
-     * This method is invoked when a new member joins the system.  If
-     * the member is an application VM or a GemFire system manager, we
-     * note it.
+     * This method is invoked when a new member joins the system. If the member is an application VM
+     * or a GemFire system manager, we note it.
-      synchronized(this) {
+      synchronized (this) {
-    
-    public void memberSuspect(InternalDistributedMember id,
-        InternalDistributedMember whoSuspected, String reason) {
-    }
-    
-    public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
-    }
+
+    public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected,
+        String reason) {}
+
+    public void quorumLost(Set<InternalDistributedMember> failures,
+        List<InternalDistributedMember> remaining) {}
-     * This method is invoked after a member has explicitly left
-     * the system.  It may not get invoked if a member becomes unreachable
-     * due to crash or network problems.
+     * This method is invoked after a member has explicitly left the system. It may not get invoked
+     * if a member becomes unreachable due to crash or network problems.
-      synchronized(this) {
+      synchronized (this) {
-      
+
-  
+
-      case DistributionManager.NORMAL_DM_TYPE:
-        member = removeMember(id);
-        break;
-      case DistributionManager.ADMIN_ONLY_DM_TYPE:
-        break;
-      case DistributionManager.LOCATOR_DM_TYPE:
-        break;
-      case DistributionManager.LONER_DM_TYPE:
-        break;  // should this ever happen?
-      default:
-        throw new IllegalArgumentException(LocalizedStrings.RemoteGfManagerAgent_UNKNOWN_VM_KIND.toLocalizedString());
+        case DistributionManager.NORMAL_DM_TYPE:
+          member = removeMember(id);
+          break;
+        case DistributionManager.ADMIN_ONLY_DM_TYPE:
+          break;
+        case DistributionManager.LOCATOR_DM_TYPE:
+          break;
+        case DistributionManager.LONER_DM_TYPE:
+          break; // should this ever happen?
+        default:
+          throw new IllegalArgumentException(
+              LocalizedStrings.RemoteGfManagerAgent_UNKNOWN_VM_KIND.toLocalizedString());
-      
+
-          JoinLeaveListener l = (JoinLeaveListener)it.next();
+          JoinLeaveListener l = (JoinLeaveListener) it.next();
-  
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class RegionAdvisor extends CacheDistributionAdvisor
-{
+public class RegionAdvisor extends CacheDistributionAdvisor {
-  
+
-  public static final short VOLUNTEERING_THREAD_COUNT = Integer.getInteger(
-      DistributionConfig.GEMFIRE_PREFIX + "RegionAdvisor.volunteeringThreadCount", 1).shortValue();
-  
+  public static final short VOLUNTEERING_THREAD_COUNT = Integer
+      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "RegionAdvisor.volunteeringThreadCount", 1)
+      .shortValue();
+
-   * Non-thread safe queue for volunteering for primary bucket. Each
-   * BucketAdvisor for this PR uses this queue. The thread that uses this 
-   * queue is a waiting pool thread.  Any thread using this queue must 
-   * synchronize on this queue.
+   * Non-thread safe queue for volunteering for primary bucket. Each BucketAdvisor for this PR uses
+   * this queue. The thread that uses this queue is a waiting pool thread. Any thread using this
+   * queue must synchronize on this queue.
-  
+
-   * Semaphore with {@link #VOLUNTEERING_THREAD_COUNT} number of permits to
-   * control number of threads volunteering for bucket primaries.
+   * Semaphore with {@link #VOLUNTEERING_THREAD_COUNT} number of permits to control number of
+   * threads volunteering for bucket primaries.
-  
+
-   * Used by to generate redundancy loss alert only once even if more than one 
-   * bucket or PR has lost redundancy. lowRedundancyFlags[0] is true if any
-   * bucket in this partitioned region has lower than configured redundancy.
-   * lowRedundancyFlags[1] is true if a warning has been generated for the
-   * current actual redundancy of this partitioned region. The caller must 
-   * synchronize on lowRedundancyFlags in order to maintain atomicity of 
-   * overall redundancy status and alert.
+   * Used by to generate redundancy loss alert only once even if more than one bucket or PR has lost
+   * redundancy. lowRedundancyFlags[0] is true if any bucket in this partitioned region has lower
+   * than configured redundancy. lowRedundancyFlags[1] is true if a warning has been generated for
+   * the current actual redundancy of this partitioned region. The caller must synchronize on
+   * lowRedundancyFlags in order to maintain atomicity of overall redundancy status and alert.
-  
+
-  
+
-  
+
-  
+
-  
+
-   * Process those profiles which were received during the initialization period.
-   * It is safe to process these profiles potentially out of order due to the profiles
-   * version which is established on the sender. 
+   * Process those profiles which were received during the initialization period. It is safe to
+   * process these profiles potentially out of order due to the profiles version which is
+   * established on the sender.
-    synchronized(this.preInitQueueMonitor) {
+    synchronized (this.preInitQueueMonitor) {
-        while(pi.hasNext()) {
+        while (pi.hasNext()) {
-              logger.trace(LogMarker.DA, "applying queued profile addition for bucket {}", qbp.bucketId);
+              logger.trace(LogMarker.DA, "applying queued profile addition for bucket {}",
+                  qbp.bucketId);
-            getBucket(qbp.bucketId).getBucketAdvisor().putProfile(
-                qbp.bucketProfile);
-          }
-          else
-          if (qbp.memberDeparted || 
-              !getDistributionManager().isCurrentMember(qbp.memberId)) {
+            getBucket(qbp.bucketId).getBucketAdvisor().putProfile(qbp.bucketProfile);
+          } else if (qbp.memberDeparted
+              || !getDistributionManager().isCurrentMember(qbp.memberId)) {
-            }
-            else {
+            } else {
-              logger.trace(LogMarker.DA, "applying queued member departure for all buckets for {}", qbp.memberId);
+              logger.trace(LogMarker.DA, "applying queued member departure for all buckets for {}",
+                  qbp.memberId);
-          }
-          else {  // apply removal for member still in the view
+          } else { // apply removal for member still in the view
-              logger.trace(LogMarker.DA, "applying queued profile removal for all buckets for {}", qbp.memberId);
+              logger.trace(LogMarker.DA, "applying queued profile removal for all buckets for {}",
+                  qbp.memberId);
-          }  // apply removal for member still in the view
+          } // apply removal for member still in the view
-      }
-      finally {
-        this.preInitQueue = null;  // prevent further additions to the queue
+      } finally {
+        this.preInitQueue = null; // prevent further additions to the queue
-        if (!finishedInitQueue && 
-            !getAdvisee().getCancelCriterion().isCancelInProgress()) {
-          logger.error(LocalizedMessage.create(LocalizedStrings.RegionAdvisor_FAILED_TO_PROCESS_ALL_QUEUED_BUCKETPROFILES_FOR_0, getAdvisee()));
+        if (!finishedInitQueue && !getAdvisee().getCancelCriterion().isCancelInProgress()) {
+          logger.error(LocalizedMessage.create(
+              LocalizedStrings.RegionAdvisor_FAILED_TO_PROCESS_ALL_QUEUED_BUCKETPROFILES_FOR_0,
+              getAdvisee()));
-    
+
-  protected Profile instantiateProfile(
-      InternalDistributedMember memberId, int version) {
+  protected Profile instantiateProfile(InternalDistributedMember memberId, int version) {
-  
+
-   * Returns the {@link #volunteeringQueue} used to queue primary volunteering
-   * tasks by this PR's BucketAdvisors.
+   * Returns the {@link #volunteeringQueue} used to queue primary volunteering tasks by this PR's
+   * BucketAdvisors.
-  
+
-   * Returns the {@link #volunteeringSemaphore} for controlling the number
-   * of threads that this PR's BucketAdvisors are allowed to use for
-   * volunteering to be primary.
+   * Returns the {@link #volunteeringSemaphore} for controlling the number of threads that this PR's
+   * BucketAdvisors are allowed to use for volunteering to be primary.
-   * Returns an unmodifiable map of bucket IDs to locations hosting
-   * the bucket.
+   * Returns an unmodifiable map of bucket IDs to locations hosting the bucket.
-    Map<Integer, List<BucketServerLocation66>> bucketToServerLocations = new HashMap<Integer, List<BucketServerLocation66>>();
+    Map<Integer, List<BucketServerLocation66>> bucketToServerLocations =
+        new HashMap<Integer, List<BucketServerLocation66>>();
-      ArrayList<BucketServerLocation66> clientBucketProfiles = new ArrayList<BucketServerLocation66>();
+      ArrayList<BucketServerLocation66> clientBucketProfiles =
+          new ArrayList<BucketServerLocation66>();
-          ServerBucketProfile cProfile = (ServerBucketProfile)profile;
+          ServerBucketProfile cProfile = (ServerBucketProfile) profile;
-    
+
-        
+
-          List<BucketServerLocation66> clientBucketProfiles = bucketToServerLocations
-              .get(bucketId);
+          List<BucketServerLocation66> clientBucketProfiles = bucketToServerLocations.get(bucketId);
-            ServerBucketProfile cProfile = (ServerBucketProfile)profile;
-            Set<BucketServerLocation66> bucketServerLocations = cProfile
-                .getBucketServerLocations();
+            ServerBucketProfile cProfile = (ServerBucketProfile) profile;
+            Set<BucketServerLocation66> bucketServerLocations = cProfile.getBucketServerLocations();
-  
+
-    ConcurrentHashMap<Integer, Set<ServerBucketProfile>> map = new ConcurrentHashMap<Integer, Set<ServerBucketProfile>>();
-    Map<Integer, List<BucketServerLocation66>> testMap = new HashMap<>(this.getAllClientBucketProfiles());
+    ConcurrentHashMap<Integer, Set<ServerBucketProfile>> map =
+        new ConcurrentHashMap<Integer, Set<ServerBucketProfile>>();
+    Map<Integer, List<BucketServerLocation66>> testMap =
+        new HashMap<>(this.getAllClientBucketProfiles());
-    
+
-          if ((profile instanceof ServerBucketProfile) && profile.isHosting) {
-            map.get(bucketId).add((ServerBucketProfile)profile);
-          }
+        if ((profile instanceof ServerBucketProfile) && profile.isHosting) {
+          map.get(bucketId).add((ServerBucketProfile) profile);
+        }
-  public void setClientBucketProfiles(Integer bucketId,
-      Set<ServerBucketProfile> profiles) {
+  public void setClientBucketProfiles(Integer bucketId, Set<ServerBucketProfile> profiles) {
-  } 
-  
+  }
+
+   * 
-   */ 
+   */
-        this.buckets[i].close();  
+        this.buckets[i].close();
-  
+
-  public boolean removeId(ProfileId memberId, boolean crashed,
-      boolean regionDestroyed, boolean fromMembershipListener) {
-    //It's important that we remove member from the bucket advisors first
-    //Calling super.removeId triggers redundancy satisfaction, so the bucket
-    //advisors must have up to data information at that point.
+  public boolean removeId(ProfileId memberId, boolean crashed, boolean regionDestroyed,
+      boolean fromMembershipListener) {
+    // It's important that we remove member from the bucket advisors first
+    // Calling super.removeId triggers redundancy satisfaction, so the bucket
+    // advisors must have up to data information at that point.
-        QueuedBucketProfile qbf = new QueuedBucketProfile(
-            (InternalDistributedMember)memberId, crashed, regionDestroyed,
-            fromMembershipListener);
+        QueuedBucketProfile qbf = new QueuedBucketProfile((InternalDistributedMember) memberId,
+            crashed, regionDestroyed, fromMembershipListener);
-          mbr = (InternalDistributedMember)memberId;
+          mbr = (InternalDistributedMember) memberId;
-        boolean removed = pbr.getBucketAdvisor().removeId(memberId, crashed, regionDestroyed, fromMembershipListener);
+        boolean removed = pbr.getBucketAdvisor().removeId(memberId, crashed, regionDestroyed,
+            fromMembershipListener);
-    
+
-      logger.trace(LogMarker.DA, "RegionAdvisor#removeId: removing member from region {}: {}; removed = {}; crashed = {}",
+      logger.trace(LogMarker.DA,
+          "RegionAdvisor#removeId: removing member from region {}: {}; removed = {}; crashed = {}",
-    
+
-  
-  /** 
-   * Clear the knowledge of given member from this advisor.
-   * In particular, clear the knowledge of remote Bucket locations so that 
-   * we avoid sending partition messages to buckets that will soon be destroyed. 
+
+  /**
+   * Clear the knowledge of given member from this advisor. In particular, clear the knowledge of
+   * remote Bucket locations so that we avoid sending partition messages to buckets that will soon
+   * be destroyed.
-   *  @param memberId member that has closed the region
-   *  @param prSerial serial number of this partitioned region
-   *  @param serials serial numbers of buckets that need to be removed
+   * @param memberId member that has closed the region
+   * @param prSerial serial number of this partitioned region
+   * @param serials serial numbers of buckets that need to be removed
-  public void removeIdAndBuckets(InternalDistributedMember memberId,
-      int prSerial, int serials[], boolean regionDestroyed)
-  {
+  public void removeIdAndBuckets(InternalDistributedMember memberId, int prSerial, int serials[],
+      boolean regionDestroyed) {
-      logger.trace(LogMarker.DA, "RegionAdvisor#removeIdAndBuckets: removing member from region {}: {}; buckets = ({}) serials",
-          this.getPartitionedRegion().getName(), memberId, (serials == null ? "null" : serials.length));
+      logger.trace(LogMarker.DA,
+          "RegionAdvisor#removeIdAndBuckets: removing member from region {}: {}; buckets = ({}) serials",
+          this.getPartitionedRegion().getName(), memberId,
+          (serials == null ? "null" : serials.length));
-    
+
-    
+
-        logger.trace(LogMarker.DA, "RegionAdvisor#removeIdAndBuckets: removing buckets for member{};{}", memberId, this);
+        logger.trace(LogMarker.DA,
+            "RegionAdvisor#removeIdAndBuckets: removing buckets for member{};{}", memberId, this);
-            logger.trace(LogMarker.DA, "RegionAdvisor#removeIdAndBuckets: removing bucket #{} serial {}", i, s); 
+            logger.trace(LogMarker.DA,
+                "RegionAdvisor#removeIdAndBuckets: removing bucket #{} serial {}", i, s);
-      
+
-//      super.removeId(memberId);
+      // super.removeId(memberId);
-  
+
-   * Iterates over all buckets and marks them sick if the given member hosts the
-   * bucket.
+   * Iterates over all buckets and marks them sick if the given member hosts the bucket.
+   * 
-  public void markBucketsOnMember(DistributedMember member, boolean sick){
-    //The health profile exchange at cache level should take care of preInitQueue
-    if (buckets==null) {
+  public void markBucketsOnMember(DistributedMember member, boolean sick) {
+    // The health profile exchange at cache level should take care of preInitQueue
+    if (buckets == null) {
-    for(int i=0; i<buckets.length; i++){
+    for (int i = 0; i < buckets.length; i++) {
-  public void updateBucketStatus(int bucketId, DistributedMember member, 
-      boolean profileRemoved) {
+  public void updateBucketStatus(int bucketId, DistributedMember member, boolean profileRemoved) {
-      
-      //getClientBucketProfiles(bucketId).remove();
+
+      // getClientBucketProfiles(bucketId).remove();
-      ResourceAdvisor advisor = getPartitionedRegion().
-                                getCache().getResourceAdvisor();
+      ResourceAdvisor advisor = getPartitionedRegion().getCache().getResourceAdvisor();
-    }    
+    }
-   * throws LowMemoryException if the given bucket is hosted on a member 
-   * which has crossed the ResourceManager threshold.
+   * throws LowMemoryException if the given bucket is hosted on a member which has crossed the
+   * ResourceManager threshold.
+   * 
-  public void checkIfBucketSick(final int bucketId, final Object key) throws LowMemoryException{
+  public void checkIfBucketSick(final int bucketId, final Object key) throws LowMemoryException {
-        logger.debug("For bucket {} sick members are ", getPartitionedRegion().bucketStringForLogs(bucketId), sm);
+        logger.debug("For bucket {} sick members are ",
+            getPartitionedRegion().bucketStringForLogs(bucketId), sm);
-      throw new LowMemoryException(LocalizedStrings.ResourceManager_LOW_MEMORY_PR_0_KEY_1_MEMBERS_2.toLocalizedString(
-              new Object[] {getPartitionedRegion().getFullPath(), key, sm}), sm);
+      throw new LowMemoryException(LocalizedStrings.ResourceManager_LOW_MEMORY_PR_0_KEY_1_MEMBERS_2
+          .toLocalizedString(new Object[] {getPartitionedRegion().getFullPath(), key, sm}), sm);
-  
+
-    
+
-     * A data store is a VM that has a non-zero local max memory, 
-     * Since the localMaxMemory is already sent, there is no need
-     * to send this state as it's implied in localMaxMemory 
+     * A data store is a VM that has a non-zero local max memory, Since the localMaxMemory is
+     * already sent, there is no need to send this state as it's implied in localMaxMemory
-     * requiresNotification determines whether a member needs to be notified of cache
-     * operations so that cache listeners and other hooks can be engaged
+     * requiresNotification determines whether a member needs to be notified of cache operations so
+     * that cache listeners and other hooks can be engaged
+     * 
-     * A lock used to order operations that need to know about the imminent closure/destruction
-     * of a Region
+     * A lock used to order operations that need to know about the imminent closure/destruction of a
+     * Region
-//    private StoppableReentrantReadWriteLock isClosingLock = null;
+    // private StoppableReentrantReadWriteLock isClosingLock = null;
-     * Track the number of buckets this data store may have, implies isDataStore == true
-     * This value is NOT sent directly but updated when 
-     * {@link org.apache.geode.internal.cache.BucketAdvisor}s recieve updates
+     * Track the number of buckets this data store may have, implies isDataStore == true This value
+     * is NOT sent directly but updated when {@link org.apache.geode.internal.cache.BucketAdvisor}s
+     * recieve updates
-    
+
-        
-    
+
+
-    public PartitionProfile() {
-    }
-      
+    public PartitionProfile() {}
+
-    
+
-      if (this.requiresNotification) s |= REQUIRES_NOTIFICATION_MASK;
+      if (this.requiresNotification)
+        s |= REQUIRES_NOTIFICATION_MASK;
-    protected final void setIntInfo(int s)
-    {
+    protected final void setIntInfo(int s) {
-    
+
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-//    public final StoppableReentrantReadWriteLock.StoppableReadLock getIsClosingReadLock(CancelCriterion stopper) {
-//      synchronized (this) {
-//        if (isClosingLock == null) {
-//          this.isClosingLock = new StoppableReentrantReadWriteLock(stopper);
-//        }
-//      }
-//      return this.isClosingLock.readLock();
-//    }
+    // public final StoppableReentrantReadWriteLock.StoppableReadLock
+    // getIsClosingReadLock(CancelCriterion stopper) {
+    // synchronized (this) {
+    // if (isClosingLock == null) {
+    // this.isClosingLock = new StoppableReentrantReadWriteLock(stopper);
+    // }
+    // }
+    // return this.isClosingLock.readLock();
+    // }
-//    public final Lock getIsClosingWriteLock() {
-//      return this.isClosingLock.writeLock();
-//    }
+    // public final Lock getIsClosingWriteLock() {
+    // return this.isClosingLock.writeLock();
+    // }
-      sb.append("; isDataStore=").append(this.isDataStore)
-       .append("; requiresNotification=").append(this.requiresNotification)
-       .append("; localMaxMemory=").append(this.localMaxMemory)
-       .append("; numBuckets=").append(this.numBuckets);
-      if(this.fixedPAttrs != null){
+      sb.append("; isDataStore=").append(this.isDataStore).append("; requiresNotification=")
+          .append(this.requiresNotification).append("; localMaxMemory=").append(this.localMaxMemory)
+          .append("; numBuckets=").append(this.numBuckets);
+      if (this.fixedPAttrs != null) {
+
-    
+
-  
+
-    final int numProfs =  getNumProfiles();
+    final int numProfs = getNumProfiles();
-  
-  public Set<InternalDistributedMember> adviseDataStore()
-  {
+
+  public Set<InternalDistributedMember> adviseDataStore() {
-  
+
-  public Set<InternalDistributedMember> adviseInitializedDataStore()
-  {
+  public Set<InternalDistributedMember> adviseInitializedDataStore() {
-      // probably not needed as all profiles for a partitioned region are Partition profiles
-        if (profile instanceof PartitionProfile) {  
-          PartitionProfile p = (PartitionProfile)profile;
+        // probably not needed as all profiles for a partitioned region are Partition profiles
+        if (profile instanceof PartitionProfile) {
+          PartitionProfile p = (PartitionProfile) profile;
-  
+
-  public Set<InternalDistributedMember> adviseNotAtShutDownAllStatus(final int status)
-  {
+  public Set<InternalDistributedMember> adviseNotAtShutDownAllStatus(final int status) {
-      // probably not needed as all profiles for a partitioned region are Partition profiles
-        if (profile instanceof PartitionProfile) {  
-          PartitionProfile p = (PartitionProfile)profile;
+        // probably not needed as all profiles for a partitioned region are Partition profiles
+        if (profile instanceof PartitionProfile) {
+          PartitionProfile p = (PartitionProfile) profile;
-        if (pr == null || pr.isDestroyed()) break;
+        if (pr == null || pr.isDestroyed())
+          break;
-        if (memberNum >0) {
+        if (memberNum > 0) {
-            logger.debug("waitForProfileStatus {} at PR:{}, expecting {} members: {}",
-                status, getPartitionedRegion().getFullPath(), memberNum, members);
+            logger.debug("waitForProfileStatus {} at PR:{}, expecting {} members: {}", status,
+                getPartitionedRegion().getFullPath(), memberNum, members);
-  
+
+   * 
-      // probably not needed as all profiles for a partitioned region are Partition profiles
-        if (profile instanceof PartitionProfile) {  
-          PartitionProfile p = (PartitionProfile)profile;
+        // probably not needed as all profiles for a partitioned region are Partition profiles
+        if (profile instanceof PartitionProfile) {
+          PartitionProfile p = (PartitionProfile) profile;
-      } 
-    } 
+      }
+    }
-    return s; 
+    return s;
-  
+
-   * return the set of the distributed members on which the given
-   * partition name is defined. 
+   * return the set of the distributed members on which the given partition name is defined.
-  public Set<InternalDistributedMember> adviseFixedPartitionDataStores(
-      final String partitionName) {
+  public Set<InternalDistributedMember> adviseFixedPartitionDataStores(final String partitionName) {
-          PartitionProfile p = (PartitionProfile)profile;
+          PartitionProfile p = (PartitionProfile) profile;
-      logger.trace(LogMarker.DA, "adviseFixedPartitionDataStore returning {} from {}", s, toStringWithProfiles());
+      logger.trace(LogMarker.DA, "adviseFixedPartitionDataStore returning {} from {}", s,
+          toStringWithProfiles());
-    return s; 
+    return s;
-   * return a distributed members on which the primary partition for given
-   * bucket is defined
+   * return a distributed members on which the primary partition for given bucket is defined
-  public InternalDistributedMember adviseFixedPrimaryPartitionDataStore(
-      final int bucketId) {
-    final List<InternalDistributedMember> fixedPartitionDataStore = new ArrayList<InternalDistributedMember>(
-        1);
+  public InternalDistributedMember adviseFixedPrimaryPartitionDataStore(final int bucketId) {
+    final List<InternalDistributedMember> fixedPartitionDataStore =
+        new ArrayList<InternalDistributedMember>(1);
-          PartitionProfile p = (PartitionProfile)profile;
+          PartitionProfile p = (PartitionProfile) profile;
-      logger.trace(LogMarker.DA, "adviseFixedPartitionDataStore returning {} from {}", fixedPartitionDataStore, toStringWithProfiles());
+      logger.trace(LogMarker.DA, "adviseFixedPartitionDataStore returning {} from {}",
+          fixedPartitionDataStore, toStringWithProfiles());
-    if(fixedPartitionDataStore.isEmpty()){
+    if (fixedPartitionDataStore.isEmpty()) {
-  
+
-   * Returns the list of all remote FixedPartitionAttributes defined across all
-   * members for the given partitioned region
+   * Returns the list of all remote FixedPartitionAttributes defined across all members for the
+   * given partitioned region
-   * @return list of all partitions(primary as well as secondary) defined on
-   *         remote nodes
+   * @return list of all partitions(primary as well as secondary) defined on remote nodes
-    final List<FixedPartitionAttributesImpl> allFPAs = new ArrayList<FixedPartitionAttributesImpl>();
+    final List<FixedPartitionAttributesImpl> allFPAs =
+        new ArrayList<FixedPartitionAttributesImpl>();
-          final PartitionProfile pp = (PartitionProfile)profile;
+          final PartitionProfile pp = (PartitionProfile) profile;
-  
+
-   * Returns the list of all FixedPartitionAttributes defined across all members
-   * of given partitioned region for a given FixedPartitionAttributes
+   * Returns the list of all FixedPartitionAttributes defined across all members of given
+   * partitioned region for a given FixedPartitionAttributes
-   * @return the list of same partitions defined on other nodes(can be primary
-   *         or secondary)
+   * @return the list of same partitions defined on other nodes(can be primary or secondary)
-  public List<FixedPartitionAttributesImpl> adviseSameFPAs(final FixedPartitionAttributesImpl fpa){
-    final List<FixedPartitionAttributesImpl> sameFPAs = new ArrayList<FixedPartitionAttributesImpl>();
-    
+  public List<FixedPartitionAttributesImpl> adviseSameFPAs(final FixedPartitionAttributesImpl fpa) {
+    final List<FixedPartitionAttributesImpl> sameFPAs =
+        new ArrayList<FixedPartitionAttributesImpl>();
+
-          final PartitionProfile pp = (PartitionProfile)profile;
+          final PartitionProfile pp = (PartitionProfile) profile;
-  
+
-   * Returns the list of all remote primary FixedPartitionAttributes defined
-   * across members for the given partitioned region
+   * Returns the list of all remote primary FixedPartitionAttributes defined across members for the
+   * given partitioned region
-    final List<FixedPartitionAttributesImpl> remotePrimaryFPAs = new ArrayList<FixedPartitionAttributesImpl>();
+    final List<FixedPartitionAttributesImpl> remotePrimaryFPAs =
+        new ArrayList<FixedPartitionAttributesImpl>();
-          final PartitionProfile pp = (PartitionProfile)profile;
+          final PartitionProfile pp = (PartitionProfile) profile;
-            for(FixedPartitionAttributesImpl fpa: fpaList){
-              if(fpa.isPrimary()){
+            for (FixedPartitionAttributesImpl fpa : fpaList) {
+              if (fpa.isPrimary()) {
-  
+
+   * 
-    for(Iterator filtI = limitNodeList.iterator(); filtI.hasNext(); ) {
+    for (Iterator filtI = limitNodeList.iterator(); filtI.hasNext();) {
+
-        if (profile instanceof PartitionProfile) {  
-          PartitionProfile p = (PartitionProfile)profile;
+        if (profile instanceof PartitionProfile) {
+          PartitionProfile p = (PartitionProfile) profile;
-    return (Node) filtSet.get(smallest[0]);      
+    return (Node) filtSet.get(smallest[0]);
-  
-  
+
+
-        if (profile instanceof PartitionProfile
-            && nodes.contains(profile.getDistributedMember())) {
-          PartitionProfile p = (PartitionProfile)profile;
-          orderedSet.add(new NodeBucketSize(p.numBuckets, p
-              .getDistributedMember()));
+        if (profile instanceof PartitionProfile && nodes.contains(profile.getDistributedMember())) {
+          PartitionProfile p = (PartitionProfile) profile;
+          orderedSet.add(new NodeBucketSize(p.numBuckets, p.getDistributedMember()));
-        }
-        else if (profile instanceof PartitionProfile && nodes.contains(self)) {
+        } else if (profile instanceof PartitionProfile && nodes.contains(self)) {
-        }       
+        }
-    
-    if (nodes.contains(self) && !orderedSet.contains(new NodeBucketSize(getBucketSet().size(), self))){
-      orderedSet.add(new NodeBucketSize(getBucketSet().size(),self));
+
+    if (nodes.contains(self)
+        && !orderedSet.contains(new NodeBucketSize(getBucketSet().size(), self))) {
+      orderedSet.add(new NodeBucketSize(getBucketSet().size(), self));
-      NodeBucketSize node = (NodeBucketSize)o;
+      NodeBucketSize node = (NodeBucketSize) o;
-      return "NodeBucketSize [ member =" + member + " numBuckets = "
-          + numBuckets + "]";
+      return "NodeBucketSize [ member =" + member + " numBuckets = " + numBuckets + "]";
-    
+
-      NodeBucketSize node = (NodeBucketSize)obj;
+      NodeBucketSize node = (NodeBucketSize) obj;
-  public Set adviseAllPRNodes()
-  {
+
+  public Set adviseAllPRNodes() {
-        CacheProfile prof = (CacheProfile)profile;
+        CacheProfile prof = (CacheProfile) profile;
-  
+
+   * 
-   * */
+   */
-          PartitionProfile prof = (PartitionProfile)profile;
-          if (prof.isPartitioned) {            
+          PartitionProfile prof = (PartitionProfile) profile;
+          if (prof.isPartitioned) {
-  
+
-  final synchronized public boolean putProfile(Profile p) 
-  {
+  final synchronized public boolean putProfile(Profile p) {
-    CacheProfile profile = (CacheProfile)p;
+    CacheProfile profile = (CacheProfile) p;
-    // don't keep FilterProfiles around in accessors.  They're needed only for
+    // don't keep FilterProfiles around in accessors. They're needed only for
-  
+
-  
+
-  
+
-   * Returns true if the bucket is currently being hosted locally. Note that
-   * as soon as this call returns, this datastore may begin to host the
-   * bucket, thus two calls in a row may be different.
+   * Returns true if the bucket is currently being hosted locally. Note that as soon as this call
+   * returns, this datastore may begin to host the bucket, thus two calls in a row may be different.
-  
+
-    return this.buckets != null; 
+    return this.buckets != null;
-  
+
-   * Returns the real BucketRegion if it's currently locally hosted. Otherwise 
-   * the ProxyBucketRegion is returned. Note that this member may be in the
-   * process of hosting the real bucket. Until that has completed, getBucket 
-   * will continue to return the ProxyBucketRegion.
+   * Returns the real BucketRegion if it's currently locally hosted. Otherwise the ProxyBucketRegion
+   * is returned. Note that this member may be in the process of hosting the real bucket. Until that
+   * has completed, getBucket will continue to return the ProxyBucketRegion.
-    ProxyBucketRegion pbr = this.buckets[bucketId]; 
+    ProxyBucketRegion pbr = this.buckets[bucketId];
-    if (ret != null) { 
+    if (ret != null) {
-  
+
-    ProxyBucketRegion pbr = this.buckets[bucketId]; 
+    ProxyBucketRegion pbr = this.buckets[bucketId];
-    if (ret != null) { 
+    if (ret != null) {
-  
-  public Map<Integer,BucketAdvisor> getAllBucketAdvisors() {
+
+  public Map<Integer, BucketAdvisor> getAllBucketAdvisors() {
-    Map<Integer,BucketAdvisor> map = new HashMap<Integer,BucketAdvisor>();
-    for(int i=0; i<buckets.length; i++){
+    Map<Integer, BucketAdvisor> map = new HashMap<Integer, BucketAdvisor>();
+    for (int i = 0; i < buckets.length; i++) {
-        map.put(ret.getId(),ret.getBucketAdvisor());
+        map.put(ret.getId(), ret.getBucketAdvisor());
-  
+
-   * @return array of serial numbers for buckets created locally 
+   * @return array of serial numbers for buckets created locally
-    for (int i = 0; i < result.length; i ++) {
-      ProxyBucketRegion pbr = this.buckets[i]; 
+    for (int i = 0; i < result.length; i++) {
+      ProxyBucketRegion pbr = this.buckets[i];
-      }
-      else {
+      } else {
-   * Returns the bucket identified by bucketId after waiting for initialization
-   * to finish processing queued profiles. Call synchronizes and waits on 
-   * {@link #preInitQueueMonitor}.
+   * Returns the bucket identified by bucketId after waiting for initialization to finish processing
+   * queued profiles. Call synchronizes and waits on {@link #preInitQueueMonitor}.
-   * @throws org.apache.geode.distributed.DistributedSystemDisconnectedException if interrupted 
-   *         for shutdown cancellation
+   * @throws org.apache.geode.distributed.DistributedSystemDisconnectedException if interrupted for
+   *         shutdown cancellation
-          }
-          catch (InterruptedException e) {
+          } catch (InterruptedException e) {
-      }
-      finally {
+      } finally {
-   * Get the most recent primary node for the bucketId. Returns null if no 
-   * primary can be found within {@link DistributionConfig#getMemberTimeout}.
+   * Get the most recent primary node for the bucketId. Returns null if no primary can be found
+   * within {@link DistributionConfig#getMemberTimeout}.
+   * 
-   * @return the Node managing the primary copy of the bucket 
+   * @return the Node managing the primary copy of the bucket
+   * 
-  
-  public boolean isStorageAssignedForBucket(int bucketId)
-  {
+
+  public boolean isStorageAssignedForBucket(int bucketId) {
-  public boolean isStorageAssignedForBucket(int bucketId,
-                                            int minRedundancy,
-                                            boolean wait)
-  {
+  public boolean isStorageAssignedForBucket(int bucketId, int minRedundancy, boolean wait) {
-      return this.buckets[bucketId].getBucketAdvisor()
-        .waitForRedundancy(minRedundancy);
+      return this.buckets[bucketId].getBucketAdvisor().waitForRedundancy(minRedundancy);
-  
-  public boolean waitForLocalBucketStorage(int bucketId)
-  {
+
+  public boolean waitForLocalBucketStorage(int bucketId) {
-    return this.buckets[bucketId].getBucketAdvisor()
-         .waitForStorage();
+    return this.buckets[bucketId].getBucketAdvisor().waitForStorage();
-  
+
-   * Get the redundancy of the this bucket, taking into  
-   * account the local bucket, if any.
-   * @return number of redundant copies for a given bucket, or -1 if
-   * there are no instances of the bucket.
+   * Get the redundancy of the this bucket, taking into account the local bucket, if any.
+   * 
+   * @return number of redundant copies for a given bucket, or -1 if there are no instances of the
+   *         bucket.
-  public int getBucketRedundancy(int bucketId)
-  {
+  public int getBucketRedundancy(int bucketId) {
-   * Return the set of all members who currently own the bucket, including the local 
-   * owner, if applicable
+   * Return the set of all members who currently own the bucket, including the local owner, if
+   * applicable
+   * 
-  
+
-  public Set<Integer> getBucketSet()
-  {
+  public Set<Integer> getBucketSet() {
-  
-  
-  public ProxyBucketRegion[] getProxyBucketArray()
-  {
+
+
+  public ProxyBucketRegion[] getProxyBucketArray() {
-  
+
-    
+
-    
+
-      // A somewhat wasteful impl. but required because the size is not fixed 
+      // A somewhat wasteful impl. but required because the size is not fixed
-        for (Iterator e = iterator(); e.hasNext(); ) {
+        for (Iterator e = iterator(); e.hasNext();) {
-    
+
-      // Some what wasteful, but needed because size is not fixed  
+      // Some what wasteful, but needed because size is not fixed
-      
+
-        a = (Object[])java.lang.reflect.Array.newInstance(
-            a.getClass().getComponentType(), oa.length);
-        System.arraycopy(oa, 0, a, 0, oa.length);        
+        a = (Object[]) java.lang.reflect.Array.newInstance(a.getClass().getComponentType(),
+            oa.length);
+        System.arraycopy(oa, 0, a, 0, oa.length);
-      
-      for (int i=0; i<oa.length; i++)
+
+      for (int i = 0; i < oa.length; i++)
-      
+
-      
+
-    
+
-     * Note: The consistency between size(), hasNext() and next() is weak, meaning
-     * that the state of the backing Set may change causing more or less elements
-     * to be available after calling size()
+     * Note: The consistency between size(), hasNext() and next() is weak, meaning that the state of
+     * the backing Set may change causing more or less elements to be available after calling size()
-    public int size()
-    {
+    public int size() {
-    public Iterator iterator()
-    {
+    public Iterator iterator() {
-    
+
-      public void remove()
-      {
+      public void remove() {
-       * Note: The consistency guarantee between hasNext() and next() is
-       * weak.   It's possible hasNext() will return true
-       * and a following call to next() may throw NoSuchElementException (due to loss
-       * of bucket storage).  Its also
-       * equally possible for hasNext() to return false and a subsequent call to next() will return
-       * a valid bucketid.
+       * Note: The consistency guarantee between hasNext() and next() is weak. It's possible
+       * hasNext() will return true and a following call to next() may throw NoSuchElementException
+       * (due to loss of bucket storage). Its also equally possible for hasNext() to return false
+       * and a subsequent call to next() will return a valid bucketid.
-      public boolean hasNext()
-      {
+      public boolean hasNext() {
-            List<FixedPartitionAttributesImpl> localFpas = getPartitionedRegion().getFixedPartitionAttributesImpl();
-            if(localFpas != null){
-              fpaList.addAll(localFpas);  
+            List<FixedPartitionAttributesImpl> localFpas =
+                getPartitionedRegion().getFixedPartitionAttributesImpl();
+            if (localFpas != null) {
+              fpaList.addAll(localFpas);
-            while (++possibleBucketId < BucketSet.this.pbrs.length
-                && !bucketExists) {
+            while (++possibleBucketId < BucketSet.this.pbrs.length && !bucketExists) {
-          }
-          else {
+          } else {
-        }
-        else {
+        } else {
-          }
-          else {
+          } else {
-              List<FixedPartitionAttributesImpl> localFpas = getPartitionedRegion().getFixedPartitionAttributesImpl();
-              if(localFpas != null){
-                fpaList.addAll(localFpas);  
+              List<FixedPartitionAttributesImpl> localFpas =
+                  getPartitionedRegion().getFixedPartitionAttributesImpl();
+              if (localFpas != null) {
+                fpaList.addAll(localFpas);
-            
+
-    
+
-   * Obtain the ordered {@link ArrayList} of data stores limited to those specified 
-   * in the provided memberFilter.  
-
+   * Obtain the ordered {@link ArrayList} of data stores limited to those specified in the provided
+   * memberFilter.
+   * 
-  public ArrayList<DataStoreBuckets> adviseFilteredDataStores(final Set<InternalDistributedMember> memberFilter)
-  {
-    final HashMap<InternalDistributedMember, Integer> memberToPrimaryCount = new HashMap<InternalDistributedMember, Integer>();
-    for(int i=0; i<this.buckets.length; i++) {
+  public ArrayList<DataStoreBuckets> adviseFilteredDataStores(
+      final Set<InternalDistributedMember> memberFilter) {
+    final HashMap<InternalDistributedMember, Integer> memberToPrimaryCount =
+        new HashMap<InternalDistributedMember, Integer>();
+    for (int i = 0; i < this.buckets.length; i++) {
-      InternalDistributedMember p=pbr.getBucketAdvisor().basicGetPrimaryMember(); 
-      if (p!=null) {
+      InternalDistributedMember p = pbr.getBucketAdvisor().basicGetPrimaryMember();
+      if (p != null) {
-        if (count != null) { 
+        if (count != null) {
-    
+
-          PartitionProfile p = (PartitionProfile)profile;
-          if(memberFilter.contains(p.getDistributedMember())) {
+          PartitionProfile p = (PartitionProfile) profile;
+          if (memberFilter.contains(p.getDistributedMember())) {
-            ds.add(new DataStoreBuckets(p.getDistributedMember(), p.numBuckets, primaryCount, p.localMaxMemory));
+            ds.add(new DataStoreBuckets(p.getDistributedMember(), p.numBuckets, primaryCount,
+                p.localMaxMemory));
-    
-    
+
+
-  public void incrementBucketCount(Profile p)
-  {
+  public void incrementBucketCount(Profile p) {
-  public void decrementsBucketCount(Profile p)
-  {
+  public void decrementsBucketCount(Profile p) {
-  /** 
-   * Dumps out all profiles in this advisor AND all buckets.  Callers should check 
-   * for debug enabled.
+  /**
+   * Dumps out all profiles in this advisor AND all buckets. Callers should check for debug enabled.
+   * 
-    
+
-    
+
-      if(persistentAdvisor != null) {
+      if (persistentAdvisor != null) {
-  
-  public void notPrimary(int bucketId, InternalDistributedMember wasPrimary)
-  {
+
+  public void notPrimary(int bucketId, InternalDistributedMember wasPrimary) {
+   * 
-  public Set advisePrimaryOwners()
-  {
+  public Set advisePrimaryOwners() {
-    HashSet hs = new HashSet(); 
+    HashSet hs = new HashSet();
-     * Visit a given {@link ProxyBucketRegion} accumulating the results in the
-     * given aggregate. Returns false when the visit has to be terminated.
+     * Visit a given {@link ProxyBucketRegion} accumulating the results in the given aggregate.
+     * Returns false when the visit has to be terminated.
-   * Invoke the given {@link BucketVisitor} on all the {@link ProxyBucketRegion}
-   * s exiting when the {@link BucketVisitor#visit} method returns false.
+   * Invoke the given {@link BucketVisitor} on all the {@link ProxyBucketRegion} s exiting when the
+   * {@link BucketVisitor#visit} method returns false.
-   * @param <T>
-   *          the type of object used for aggregation of results
-   * @param visitor
-   *          the {@link BucketVisitor} to use for the visit
-   * @param aggregate
-   *          an aggregate object that will be used to for aggregation of
-   *          results by the {@link BucketVisitor#visit} method; this allows the
-   *          {@link BucketVisitor} to not maintain any state so that in most
-   *          situations a global static object encapsulating the required
-   *          behaviour will work
+   * @param <T> the type of object used for aggregation of results
+   * @param visitor the {@link BucketVisitor} to use for the visit
+   * @param aggregate an aggregate object that will be used to for aggregation of results by the
+   *        {@link BucketVisitor#visit} method; this allows the {@link BucketVisitor} to not
+   *        maintain any state so that in most situations a global static object encapsulating the
+   *        required behaviour will work
-   * @return true when the full visit completed, and false if it was terminated
-   *         due to {@link BucketVisitor#visit} returning false
+   * @return true when the full visit completed, and false if it was terminated due to
+   *         {@link BucketVisitor#visit} returning false
-  /** 
-   * Update or create a bucket's meta-data
-   * If this advisor has not completed initialization, upon return the profile will be enqueued for
-   * processing during initialization, otherwise the profile will be immediately processed.
-   * This architecture limits the blockage of threads during initialization.
+  /**
+   * Update or create a bucket's meta-data If this advisor has not completed initialization, upon
+   * return the profile will be enqueued for processing during initialization, otherwise the profile
+   * will be immediately processed. This architecture limits the blockage of threads during
+   * initialization.
+   * 
-    
+
-    
+
-    
+
-    
+
-    
-    /** true means that this QueuedBucketProfile was created
-     * because of MembershipListener invocation
+
+    /**
+     * true means that this QueuedBucketProfile was created because of MembershipListener invocation
-    
+
-    
+
-    
+
+     * 
-    
+
+     * 
-    public QueuedBucketProfile(InternalDistributedMember mbr, boolean crashed,
-        boolean destroyed, boolean fromMembershipListener) {
+    public QueuedBucketProfile(InternalDistributedMember mbr, boolean crashed, boolean destroyed,
+        boolean fromMembershipListener) {
-    
+
+     * 
-      return adviseDataStore();
+    return adviseDataStore();
-    final AtomicLong total = new AtomicLong(); 
+    final AtomicLong total = new AtomicLong();
-        if (profile instanceof PartitionProfile) {  
-          PartitionProfile p = (PartitionProfile)profile;
+        if (profile instanceof PartitionProfile) {
+          PartitionProfile p = (PartitionProfile) profile;
-    });    
+    });
-    final AtomicLong total = new AtomicLong(); 
+    final AtomicLong total = new AtomicLong();
-        if (profile instanceof PartitionProfile) {  
-          PartitionProfile p = (PartitionProfile)profile;
+        if (profile instanceof PartitionProfile) {
+          PartitionProfile p = (PartitionProfile) profile;
-    });    
+    });
-  
+
-   * Returns true if there are any buckets created anywhere in the distributed
-   * system for this partitioned region.
+   * Returns true if there are any buckets created anywhere in the distributed system for this
+   * partitioned region.
-   * Returns the total number of buckets created anywhere in the distributed
-   * system for this partitioned region.
+   * Returns the total number of buckets created anywhere in the distributed system for this
+   * partitioned region.
-  
+
-   * Returns a possibly null list of this advisor's real bucket profiles.
-   * A real bucket profile is one that for a bucket that actually has storage
-   * in this vm.
+   * Returns a possibly null list of this advisor's real bucket profiles. A real bucket profile is
+   * one that for a bucket that actually has storage in this vm.
+   * 
-      //Fix for 41436 - we need to include buckets that are still initializing here
-      //we must start including buckets in this list *before* those buckets exchange
-      //profiles.
+      // Fix for 41436 - we need to include buckets that are still initializing here
+      // we must start including buckets in this list *before* those buckets exchange
+      // profiles.
-   * Takes a list of BucketProfileAndId and adds them to thsi advisors
-   * proxy buckets.
+   * Takes a list of BucketProfileAndId and adds them to thsi advisors proxy buckets.
+   * 
-    for (int i=0; i < size; i++) {
-      BucketProfileAndId bp = (BucketProfileAndId)l.get(i);
+    for (int i = 0; i < size; i++) {
+      BucketProfileAndId bp = (BucketProfileAndId) l.get(i);
+
-      ((PartitionedRegion)getAdvisee()).removeMemberFromCriticalList(profile.peerMemberId);
+      ((PartitionedRegion) getAdvisee()).removeMemberFromCriticalList(profile.peerMemberId);
-    
+
-  
+
-    for(int i = 0; i < buckets.length; i++) {
+    for (int i = 0; i < buckets.length; i++) {
-      if(advisor != null) {
+      if (advisor != null) {
-  
+
-    /*final*/ private int id; // bid = bucket id
-    /*final*/ private BucketProfile bp;
+    /* final */ private int id;
+    // bid = bucket id
+    /* final */ private BucketProfile bp;
-      this.bp = (BucketProfile)bp;
-      if(bp instanceof ServerBucketProfile)
-    	  isServerBucketProfile = true;
+      this.bp = (BucketProfile) bp;
+      if (bp instanceof ServerBucketProfile)
+        isServerBucketProfile = true;
-    public BucketProfileAndId() {
-    }
+
+    public BucketProfileAndId() {}
+
+
+
-      if(this.isServerBucketProfile)
-    	  this.bp = new ServerBucketProfile();
-      else 
-    	  this.bp = new BucketProfile();
-      
+      if (this.isServerBucketProfile)
+        this.bp = new ServerBucketProfile();
+      else
+        this.bp = new BucketProfile();
+
-    
+
-  
+
-    
+
-      
+
-    
+
+
-      synchronized(this) {
+      synchronized (this) {
+
-      synchronized(this) {
+      synchronized (this) {
-      synchronized(this) {
+      synchronized (this) {

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
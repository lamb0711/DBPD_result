GEODE-4372: clean up RemoteOperationMessage classes (#1338)


* throw RemoteOperationException instead of ForceReattemptException when cache is closing. All ForceReattemptException throwing by RemoteOperationMessage has been removed.

* now uses SERIAL_EXECUTOR for all RemoteOperationMessages.
Previously most of these messages where processed in the partitioned message
thread pool even though most all of these messages where not partitioned.
It is possible that RemotePutAll and RemoteRemoveAll will have some trouble
being SERIAL_EXECUTOR.

* added comments for all RemoteOperationMessages describing what
they are used for

* Improved RemoteOperationMessageTest

* added a BucketTXRegionStub to calculate bucket region size on a stub.

* removed GemFireCacheImpl.getInstance call

* added RemoteOperationResponse unit test

* renamed handleAsUnexpected to handleCause

* renamed waitForCacheException to waitForRemoteResponse

* moved RemoteOperation classes to tx package


-package org.apache.geode.internal.cache;
+package org.apache.geode.internal.cache.tx;
-import java.util.Iterator;
+import org.apache.geode.cache.RegionDestroyedException;
+import org.apache.geode.internal.cache.AbstractRegion;
+import org.apache.geode.internal.cache.CachedDeserializable;
+import org.apache.geode.internal.cache.DataLocationException;
+import org.apache.geode.internal.cache.DistributedCacheOperation;
+import org.apache.geode.internal.cache.DistributedRegion;
+import org.apache.geode.internal.cache.EntryEventImpl;
+import org.apache.geode.internal.cache.EventID;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.RemoteOperationException;
- * the invalidate into the same message and use an extra bit to differentiate
+ * the invalidate into the same message and use an extra bit to differentiate.
+ *
+ * This message is used by transactions to destroy an entry on a transaction hosted on a remote
+ * member. It is also used by non-transactional region destroys that need to generate a VersionTag
+ * on a remote member.
-  private static final short FLAG_USEORIGINREMOTE = 0x01;
-
-  private static final short FLAG_HASOLDVALUE = 0x02;
-
-  private static final short FLAG_OLDVALUEISSERIALIZED = 0x04;
-
-  private static final short FLAG_POSSIBLEDUPLICATE = 0x08;
-
-  /** expectedOldValue used for PartitionedRegion#remove(key, value) */
-  protected RemoteDestroyMessage(Set recipients, String regionPath, DirectReplyProcessor processor,
-      EntryEventImpl event, Object expectedOldValue, int processorType, boolean useOriginRemote,
-      boolean possibleDuplicate) {
-    super(recipients, regionPath, processor);
+  protected RemoteDestroyMessage(DistributedMember recipient, String regionPath,
+      DirectReplyProcessor processor, EntryEventImpl event, Object expectedOldValue,
+      boolean useOriginRemote, boolean possibleDuplicate) {
+    super((InternalDistributedMember) recipient, regionPath, processor);
-    this.processorType = processorType;
-
-  }
-
-  @Override
-  public boolean isSevereAlertCompatible() {
-    // allow forced-disconnect processing for all cache op messages
-    return true;
+  @SuppressWarnings("unchecked")
-    Collection replicates = onlyPersistent
+    Collection<InternalDistributedMember> replicates = onlyPersistent
-      ArrayList l = new ArrayList(replicates);
+      ArrayList<InternalDistributedMember> l = new ArrayList<>(replicates);
-    for (Iterator<InternalDistributedMember> it = replicates.iterator(); it.hasNext();) {
-      InternalDistributedMember replicate = it.next();
+    for (InternalDistributedMember replicate : replicates) {
-        RemoteDestroyReplyProcessor processor = send(replicate, event.getRegion(), event,
-            expectedOldValue, ClusterDistributionManager.SERIAL_EXECUTOR, false, posDup);
-        processor.waitForCacheException();
-        VersionTag versionTag = processor.getVersionTag();
+        RemoteDestroyReplyProcessor processor =
+            send(replicate, event.getRegion(), event, expectedOldValue, false, posDup);
+        processor.waitForRemoteResponse();
+        VersionTag<?> versionTag = processor.getVersionTag();
-      } catch (RemoteOperationException e) {
+      } catch (RegionDestroyedException | RemoteOperationException e) {
-              "RemoteDestroyMessage caught an unexpected exception during distribution", e);
+              "RemoteDestroyMessage caught an exception during distribution; retrying to another member",
+              e);
-   * @param processorType the type of executor to use in processing the message
-   * @param useOriginRemote TODO
-      EntryEventImpl event, Object expectedOldValue, int processorType, boolean useOriginRemote,
+      EntryEventImpl event, Object expectedOldValue, boolean useOriginRemote,
-    // Assert.assertTrue(recipient != null, "RemoteDestroyMessage NULL recipient"); recipient may be
-    // null for event notification
-    Set recipients = Collections.singleton(recipient);
-        new RemoteDestroyReplyProcessor(r.getSystem(), recipients, false);
+        new RemoteDestroyReplyProcessor(r.getSystem(), recipient, false);
-    RemoteDestroyMessage m = new RemoteDestroyMessage(recipients, r.getFullPath(), p, event,
-        expectedOldValue, processorType, useOriginRemote, possibleDuplicate);
-    m.setTransactionDistributed(r.getCache().getTxManager().isDistributed());
-    Set failures = r.getDistributionManager().putOutgoing(m);
+    RemoteDestroyMessage m = new RemoteDestroyMessage(recipient, r.getFullPath(), p, event,
+        expectedOldValue, useOriginRemote, possibleDuplicate);
+    Set<?> failures = r.getDistributionManager().putOutgoing(m);
-
-  @Override
-  public int getProcessorType() {
-    return this.processorType;
-  }
-
-   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:
-   * It is very important that this message does NOT cause any deadlocks as the sender will wait
-   * indefinitely for the acknowledgement
+   * This method is called upon receipt and make the desired changes to the region. Note: It is very
+   * important that this message does NOT cause any deadlocks as the sender will wait indefinitely
+   * for the acknowledgement
-  private void sendReply(DistributionManager dm, VersionTag versionTag) {
+  private void sendReply(DistributionManager dm, VersionTag<?> versionTag) {
-    private VersionTag versionTag;
+    private VersionTag<?> versionTag;
-        VersionTag versionTag) {
+        VersionTag<?> versionTag) {
-    DestroyReplyMessage(InternalDistributedMember recipient, int procId, VersionTag versionTag) {
+    DestroyReplyMessage(InternalDistributedMember recipient, int procId, VersionTag<?> versionTag) {
-      // TODO Auto-generated method stub
-    VersionTag versionTag;
+    VersionTag<?> versionTag;
-    RemoteDestroyReplyProcessor(InternalDistributedSystem ds, Set recipients, Object key) {
-      super(ds, recipients, false);
+    RemoteDestroyReplyProcessor(InternalDistributedSystem ds, DistributedMember recipient,
+        Object key) {
+      super(ds, (InternalDistributedMember) recipient, false);
-    void setResponse(VersionTag versionTag) {
+    void setResponse(VersionTag<?> versionTag) {
-    VersionTag getVersionTag() {
+    VersionTag<?> getVersionTag() {

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS79 UPD66 INS66 INS66 INS66 UPD43 UPD42 INS42 INS45 INS70 INS74 INS74 INS44 MOV44 INS74 INS74 UPD42 INS11 INS74 INS44 INS42 MOV8 INS74 UPD66 UPD66 UPD66 MOV43 INS76 MOV43 INS76 INS74 INS42 INS74 INS43 INS76 UPD43 UPD42 INS74 MOV43 INS76 INS43 INS42 MOV43 INS43 MOV43 INS42 MOV43 INS76 MOV43 INS76 MOV43 INS76 INS42 UPD42 INS11 MOV43 INS76 INS42 INS42 INS74 UPD42 UPD42 INS43 INS42 MOV43 MOV43 INS42 INS74 INS74 INS84 MOV43 UPD42 MOV43 INS76 INS43 MOV43 INS42 UPD45 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL66 DEL65 DEL29 DEL39 DEL42 DEL44 DEL42 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL78 DEL83 DEL39 DEL42 DEL9 DEL41 DEL8 DEL31 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21 DEL42 DEL43 DEL42 DEL78 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL43 DEL42 DEL44 DEL42
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-   * The key into the <code>Region</code> used when taking entries from the
-   * queue. This value is either set when the queue is instantiated or read from
-   * the <code>Region</code> in the case where this queue takes over where a
-   * previous one left off.
+   * The key into the <code>Region</code> used when taking entries from the queue. This value is
+   * either set when the queue is instantiated or read from the <code>Region</code> in the case
+   * where this queue takes over where a previous one left off.
-   * The key into the <code>Region</code> used when putting entries onto the
-   * queue. This value is either set when the queue is instantiated or read from
-   * the <code>Region</code> in the case where this queue takes over where a
-   * previous one left off.
+   * The key into the <code>Region</code> used when putting entries onto the queue. This value is
+   * either set when the queue is instantiated or read from the <code>Region</code> in the case
+   * where this queue takes over where a previous one left off.
-   * The current key used to do put into the region. Once put is complete, then
-   * the {@link #tailKey} is reconciled with this value.
+   * The current key used to do put into the region. Once put is complete, then the {@link #tailKey}
+   * is reconciled with this value.
-  
+
-   * The maximum amount of memory (MB) to allow in the queue before overflowing
-   * entries to disk
+   * The maximum amount of memory (MB) to allow in the queue before overflowing entries to disk
-  
+
-  
+
-  
+
-   * The <code>Map</code> mapping the regionName->key to the queue key. This
-   * index allows fast updating of entries in the queue for conflation.
+   * The <code>Map</code> mapping the regionName->key to the queue key. This index allows fast
+   * updating of entries in the queue for conflation.
-  
+
-  private static final boolean NO_ACK = Boolean
-      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "gateway-queue-no-ack");
-  
+  private static final boolean NO_ACK =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "gateway-queue-no-ack");
+
-  
+
-  
+
-  
+
-  
-  private AbstractGatewaySender sender  = null;
-  public SerialGatewaySenderQueue(AbstractGatewaySender abstractSender,
-      String regionName, CacheListener listener) {
+  private AbstractGatewaySender sender = null;
+
+  public SerialGatewaySenderQueue(AbstractGatewaySender abstractSender, String regionName,
+      CacheListener listener) {
-    }
-    else {
+    } else {
-    this.removalThread = new BatchRemovalThread((GemFireCacheImpl)abstractSender.getCache());
+    this.removalThread = new BatchRemovalThread((GemFireCacheImpl) abstractSender.getCache());
-    
-    
+
+
-    GatewaySenderEventImpl eventImpl = (GatewaySenderEventImpl)event;
+    GatewaySenderEventImpl eventImpl = (GatewaySenderEventImpl) event;
-    final boolean isPDXRegion = (r instanceof DistributedRegion && r.getName()
-        .equals(PeerTypeRegistration.REGION_NAME));
-    final boolean isWbcl = this.regionName
-        .startsWith(AsyncEventQueueImpl.ASYNC_EVENT_QUEUE_PREFIX);
+    final boolean isPDXRegion =
+        (r instanceof DistributedRegion && r.getName().equals(PeerTypeRegistration.REGION_NAME));
+    final boolean isWbcl = this.regionName.startsWith(AsyncEventQueueImpl.ASYNC_EVENT_QUEUE_PREFIX);
-//      if (this.keyPutNoSync) {
-//        putAndGetKeyNoSync(event);
-//      }
-//      else {
-//        synchronized (this) {
-          putAndGetKey(event);
-          return true;
-        //}
-      //}
+      // if (this.keyPutNoSync) {
+      // putAndGetKeyNoSync(event);
+      // }
+      // else {
+      // synchronized (this) {
+      putAndGetKey(event);
+      return true;
+      // }
+      // }
-    return false;    
+    return false;
-    this.region.put(key, (AsyncEvent)object);
+    this.region.put(key, (AsyncEvent) object);
-      logger.debug("{}: Inserted {} -> {}",this, key, object);
+      logger.debug("{}: Inserted {} -> {}", this, key, object);
-      removeOldEntry((Conflatable)object, key);
+      removeOldEntry((Conflatable) object, key);
-      this.region.put(key, (AsyncEvent)object);
+      this.region.put(key, (AsyncEvent) object);
-                    notifyWaiters =
-                        (this.pendingPuts.size() >= this.maxPendingPuts);
+                    notifyWaiters = (this.pendingPuts.size() >= this.maxPendingPuts);
-                }
-                else {
+                } else {
-          }
-          else if (this.pendingPuts.size() < this.maxPendingPuts) {
+          } else if (this.pendingPuts.size() < this.maxPendingPuts) {
-          }
-          else {
+          } else {
-              ((LocalRegion)this.region).getCancelCriterion()
-                  .checkCancelInProgress(t);
+              ((LocalRegion) this.region).getCancelCriterion().checkCancelInProgress(t);
-      removeOldEntry((Conflatable)object, key);
+      removeOldEntry((Conflatable) object, key);
-  
+
-//     resetLastPeeked();
-//     AsyncEvent object = peekAhead();
-//     // If it is not null, destroy it and increment the head key
-//     if (object != null) {
-//       Long key = this.peekedIds.remove();
-//       if (logger.isTraceEnabled()) {
-//         logger.trace("{}: Retrieved {} -> {}",this, key, object);
-//       }
-//       // Remove the entry at that key with a callback arg signifying it is
-//       // a WAN queue so that AbstractRegionEntry.destroy can get the value
-//       // even if it has been evicted to disk. In the normal case, the
-//       // AbstractRegionEntry.destroy only gets the value in the VM.
-//       this.region.destroy(key, RegionQueue.WAN_QUEUE_TOKEN);
-//       updateHeadKey(key.longValue());
+    // resetLastPeeked();
+    // AsyncEvent object = peekAhead();
+    // // If it is not null, destroy it and increment the head key
+    // if (object != null) {
+    // Long key = this.peekedIds.remove();
+    // if (logger.isTraceEnabled()) {
+    // logger.trace("{}: Retrieved {} -> {}",this, key, object);
+    // }
+    // // Remove the entry at that key with a callback arg signifying it is
+    // // a WAN queue so that AbstractRegionEntry.destroy can get the value
+    // // even if it has been evicted to disk. In the normal case, the
+    // // AbstractRegionEntry.destroy only gets the value in the VM.
+    // this.region.destroy(key, RegionQueue.WAN_QUEUE_TOKEN);
+    // updateHeadKey(key.longValue());
-//       if (logger.isTraceEnabled()) {
-//         logger.trace("{}: Destroyed {} -> {}", this, key, object);
-//       }
-//     }
-//     return object;
+    // if (logger.isTraceEnabled()) {
+    // logger.trace("{}: Destroyed {} -> {}", this, key, object);
+    // }
+    // }
+    // return object;
-//     List<AsyncEvent> batch = new ArrayList<AsyncEvent>(
-//         batchSize * 2);
-//     for (int i = 0; i < batchSize; i++) {
-//       AsyncEvent obj = take();
-//       if (obj != null) {
-//         batch.add(obj);
-//       } else {
-//         break;
-//       }
-//     }
-//     if (logger.isTraceEnabled()) {
-//       logger.trace("{}: Took a batch of {} entries", this, batch.size());
-//     }
-//     return batch;
+    // List<AsyncEvent> batch = new ArrayList<AsyncEvent>(
+    // batchSize * 2);
+    // for (int i = 0; i < batchSize; i++) {
+    // AsyncEvent obj = take();
+    // if (obj != null) {
+    // batch.add(obj);
+    // } else {
+    // break;
+    // }
+    // }
+    // if (logger.isTraceEnabled()) {
+    // logger.trace("{}: Took a batch of {} entries", this, batch.size());
+    // }
+    // return batch;
-   * This method removes the last entry. However, it will only let the user
-   * remove entries that they have peeked. If the entry was not peeked, this
-   * method will silently return.
+   * This method removes the last entry. However, it will only let the user remove entries that they
+   * have peeked. If the entry was not peeked, this method will silently return.
-      
+
-        logger.debug("{}: Did not destroy entry at {} it was not there. It should have been removed by conflation.", this, key);
+        logger.debug(
+            "{}: Did not destroy entry at {} it was not there. It should have been removed by conflation.",
+            this, key);
-    
+
-      logger.debug("{}: Destroyed entry at key {} setting the lastDispatched Key to {}. The last destroyed entry was {}",
+      logger.debug(
+          "{}: Destroyed entry at key {} setting the lastDispatched Key to {}. The last destroyed entry was {}",
-   * This method removes batchSize entries from the queue. It will only remove
-   * entries that were previously peeked.
+   * This method removes batchSize entries from the queue. It will only remove entries that were
+   * previously peeked.
-   * @param size
-   *          the number of entries to remove
+   * @param size the number of entries to remove
-  
-  public void remove(Object object)
-  {
-    remove();
-  }
-    //resetLastPeeked();
+    // resetLastPeeked();
-  public List<AsyncEvent> peek(int size, int timeToWait)
-      throws CacheException {
+  public List<AsyncEvent> peek(int size, int timeToWait) throws CacheException {
-    
+
-      logger.trace("{}: Peek start time={} end time={} time to wait={}", this, start, end, timeToWait);
+      logger.trace("{}: Peek start time={} end time={} time to wait={}", this, start, end,
+          timeToWait);
-                                                                                // *2?
-    //resetLastPeeked();
+                                                                  // *2?
+    // resetLastPeeked();
-      if (object != null && object instanceof GatewaySenderEventImpl) {
-        GatewaySenderEventImpl copy = ((GatewaySenderEventImpl)object).makeHeapCopyIfOffHeap();
-        if (copy == null) {
-          continue;
-        }
-        object = copy;
-      }
-  
+
-    for(int i=0; i < listeners.length; i++){
-      if(listeners[i] instanceof SerialSecondaryGatewayListener){
+    for (int i = 0; i < listeners.length; i++) {
+      if (listeners[i] instanceof SerialSecondaryGatewayListener) {
-  private boolean removeOldEntry(Conflatable object, Long tailKey)
-      throws CacheException {
+  private boolean removeOldEntry(Conflatable object, Long tailKey) throws CacheException {
-    
+
-        logger.debug("{}: Conflating {} at queue index={} queue size={} head={} tail={}",
-            this, object, tailKey, size(), this.headKey, tailKey);
+        logger.debug("{}: Conflating {} at queue index={} queue size={} head={} tail={}", this,
+            object, tailKey, size(), this.headKey, tailKey);
-    	Map<Object, Long> latestIndexesForRegion = this.indexes.get(rName);
-    	if (latestIndexesForRegion == null) {
-    	  latestIndexesForRegion = new HashMap<Object, Long>();
-    	  this.indexes.put(rName, latestIndexesForRegion);
-    	}
+        Map<Object, Long> latestIndexesForRegion = this.indexes.get(rName);
+        if (latestIndexesForRegion == null) {
+          latestIndexesForRegion = new HashMap<Object, Long>();
+          this.indexes.put(rName, latestIndexesForRegion);
+        }
-    	previousIndex = latestIndexesForRegion.put(key, tailKey);
+        previousIndex = latestIndexesForRegion.put(key, tailKey);
-      
+
-        logger.debug("{}: Adding index key={}->index={} for {} head={} tail={}",
-            this, key, tailKey, object, this.headKey, tailKey);
+        logger.debug("{}: Adding index key={}->index={} for {} head={} tail={}", this, key, tailKey,
+            object, this.headKey, tailKey);
-          logger.debug("{}: Indexes contains index={} for key={} head={} tail={} and it can be used.",
-              this, previousIndex, key, this.headKey, tailKey);
+          logger.debug(
+              "{}: Indexes contains index={} for key={} head={} tail={} and it can be used.", this,
+              previousIndex, key, this.headKey, tailKey);
-          logger.debug("{}: No old entry for key={} head={} tail={} not removing old entry.",
-              this, key, this.headKey, tailKey);
+          logger.debug("{}: No old entry for key={} head={} tail={} not removing old entry.", this,
+              key, this.headKey, tailKey);
-        Conflatable previous = (Conflatable)this.region.remove(previousIndex);
-        this.stats.decQueueSize(1); 
+        Conflatable previous = (Conflatable) this.region.remove(previousIndex);
+        this.stats.decQueueSize(1);
-          logger.debug("{}: Previous conflatable at key={} head={} tail={}: {}",
-              this, previousIndex, this.headKey, tailKey, previous);
-          logger.debug("{}: Current conflatable at key={} head={} tail={}: {}",
-              this, tailKey, this.headKey, tailKey, object);
+          logger.debug("{}: Previous conflatable at key={} head={} tail={}: {}", this,
+              previousIndex, this.headKey, tailKey, previous);
+          logger.debug("{}: Current conflatable at key={} head={} tail={}: {}", this, tailKey,
+              this.headKey, tailKey, object);
-            logger.debug("{}: Removed {} and added {} for key={} head={} tail={} in queue for region={} old event={}",
-                this, previous.getValueToConflate(), object.getValueToConflate(),
-                key, this.headKey, tailKey, rName, previous);
+            logger.debug(
+                "{}: Removed {} and added {} for key={} head={} tail={} in queue for region={} old event={}",
+                this, previous.getValueToConflate(), object.getValueToConflate(), key, this.headKey,
+                tailKey, rName, previous);
-        logger.debug("{}: Not conflating {} queue size: {} head={} tail={}", this, object, size(), this.headKey, tailKey);
+        logger.debug("{}: Not conflating {} queue size: {} head={} tail={}", this, object, size(),
+            this.headKey, tailKey);
-	// Get the object at that key (to remove the index).
-	LocalRegion lr = (LocalRegion)this.region;
-	Object o = null;
-	try {
-		o = lr.getValueInVMOrDiskWithoutFaultIn(k); 
-		if (o != null && o instanceof CachedDeserializable) { 
-			o = ((CachedDeserializable)o).getDeserializedValue(lr, lr.getRegionEntry(k));
-		}	
-	} catch (EntryNotFoundException ok) {
-		// just return null;
-	}
-	// bug #46023 do not return a destroyed entry marker
-	if (o == Token.TOMBSTONE) {
-		o = null;
-	}
-	return (AsyncEvent)o;
+    // Get the object at that key (to remove the index).
+    LocalRegion lr = (LocalRegion) this.region;
+    Object o = null;
+    try {
+      o = lr.getValueInVMOrDiskWithoutFaultIn(k);
+      if (o != null && o instanceof CachedDeserializable) {
+        o = ((CachedDeserializable) o).getDeserializedValue(lr, lr.getRegionEntry(k));
+      }
+    } catch (EntryNotFoundException ok) {
+      // just return null;
+    }
+    // bug #46023 do not return a destroyed entry marker
+    if (o == Token.TOMBSTONE) {
+      o = null;
+    }
+    return (AsyncEvent) o;
-        Conflatable object = (Conflatable)o;
+        Conflatable object = (Conflatable) o;
-   * returns true if key a is before key b. This test handles keys that have
-   * wrapped around
+   * returns true if key a is before key b. This test handles keys that have wrapped around
-   * Clear the list of peeked keys. The next peek will start again at the head
-   * key.
+   * Clear the list of peeked keys. The next peek will start again at the head key.
+
+  private Long getCurrentKey() {
+    long currentKey;
+    if (this.peekedIds.isEmpty()) {
+      currentKey = getHeadKey();
+    } else {
+      Long lastPeek = this.peekedIds.peekLast();
+      if (lastPeek == null) {
+        return null;
+      }
+      currentKey = lastPeek.longValue() + 1;
+    }
+    return currentKey;
+  }
+
+  private AsyncEvent getObjectInSerialSenderQueue(Long currentKey) {
+    AsyncEvent object = optimalGet(currentKey);
+    if ((null != object) && logger.isDebugEnabled()) {
+      logger.debug("{}: Peeked {}->{}", this, currentKey, object);
+    }
+    if (object != null && object instanceof GatewaySenderEventImpl) {
+      GatewaySenderEventImpl copy = ((GatewaySenderEventImpl) object).makeHeapCopyIfOffHeap();
+      if (copy == null) {
+        logger.debug(
+            "Unable to make heap copy and will not be added to peekedIds for object" + " : {} ",
+            object.toString());
+      }
+      object = copy;
+    }
+    return object;
+  }
+
-    long currentKey = -1;
-    if (this.peekedIds.isEmpty()) {
-    	currentKey = getHeadKey(); 
-    } else {
-    	Long lastPeek = this.peekedIds.peekLast();
-    	if (lastPeek == null) {
-    		return null;
-    	}
-    	currentKey = lastPeek.longValue() + 1;
+    Long currentKey = getCurrentKey();
+    if (currentKey == null) {
+      return null;
-    
-    
+
+
-    // use optimalGet here to fix bug 40654
-        && (object = optimalGet(Long.valueOf(currentKey))) == null) {
+        && (null == (object = getObjectInSerialSenderQueue(currentKey)))) {
-      this.peekedIds.add(Long.valueOf(currentKey));
+      this.peekedIds.add(currentKey);
-   * Returns the value of the tail key. The tail key points to an empty where
-   * the next queue entry will be stored.
+   * Returns the value of the tail key. The tail key points to an empty where the next queue entry
+   * will be stored.
-      logger.trace("{}: Incremented TAIL_KEY for region {} to {}", this, this.region.getName(), this.tailKey);
+      logger.trace("{}: Incremented TAIL_KEY for region {} to {}", this, this.region.getName(),
+          this.tailKey);
-   * TODO - We could initialize the indexes maps at the time here. However, that
-   * would require iterating over the values of the region rather than the keys,
-   * which could be much more expensive if the region has overflowed to disk.
+   * TODO - We could initialize the indexes maps at the time here. However, that would require
+   * iterating over the values of the region rather than the keys, which could be much more
+   * expensive if the region has overflowed to disk.
-   * We do iterate over the values of the region in SerialGatewaySender at the
-   * time of failover. see SerialGatewaySender.handleFailover. So there's a
-   * possibility we can consolidate that code with this method and iterate over
-   * the region once.
+   * We do iterate over the values of the region in SerialGatewaySender at the time of failover. see
+   * SerialGatewaySender.handleFailover. So there's a possibility we can consolidate that code with
+   * this method and iterate over the region once.
-      if (smallestKeyGreaterThanHalfMax != -1
-          && largestKeyLessThanHalfMax != -1
+      if (smallestKeyGreaterThanHalfMax != -1 && largestKeyLessThanHalfMax != -1
-        logger.info(LocalizedMessage.create(LocalizedStrings.SingleWriteSingleReadRegionQueue_0_DURING_FAILOVER_DETECTED_THAT_KEYS_HAVE_WRAPPED,
-                  new Object[] { this, this.tailKey, Long.valueOf(this.headKey) }));
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.SingleWriteSingleReadRegionQueue_0_DURING_FAILOVER_DETECTED_THAT_KEYS_HAVE_WRAPPED,
+            new Object[] {this, this.tailKey, Long.valueOf(this.headKey)}));
-        logger.debug("{}: Initialized tail key to: {}, head key to: {}", this, this.tailKey, this.headKey);
+        logger.debug("{}: Initialized tail key to: {}, head key to: {}", this, this.tailKey,
+            this.headKey);
-   * Returns the value of the head key. The head key points to the next entry to
-   * be removed from the queue.
+   * Returns the value of the head key. The head key points to the next entry to be removed from the
+   * queue.
-      logger.trace("{}: Incremented HEAD_KEY for region {} to {}", this, this.region.getName(), this.headKey);
+      logger.trace("{}: Incremented HEAD_KEY for region {} to {}", this, this.region.getName(),
+          this.headKey);
-   * Initializes the <code>Region</code> backing this queue. The
-   * <code>Region</code>'s scope is DISTRIBUTED_NO_ACK and mirror type is
-   * KEYS_VALUES and is set to overflow to disk based on the
+   * Initializes the <code>Region</code> backing this queue. The <code>Region</code>'s scope is
+   * DISTRIBUTED_NO_ACK and mirror type is KEYS_VALUES and is set to overflow to disk based on the
-   * @param sender
-   *          The GatewaySender <code>SerialGatewaySenderImpl</code>
-   * @param listener
-   *          The GemFire <code>CacheListener</code>. The
-   *          <code>CacheListener</code> can be null.
+   * @param sender The GatewaySender <code>SerialGatewaySenderImpl</code>
+   * @param listener The GemFire <code>CacheListener</code>. The <code>CacheListener</code> can be
+   *        null.
-  @SuppressWarnings({ "unchecked", "rawtypes" })
-  private void initializeRegion(AbstractGatewaySender sender,
-      CacheListener listener) {
-    final GemFireCacheImpl gemCache = (GemFireCacheImpl)sender.getCache();
+  @SuppressWarnings({"unchecked", "rawtypes"})
+  private void initializeRegion(AbstractGatewaySender sender, CacheListener listener) {
+    final GemFireCacheImpl gemCache = (GemFireCacheImpl) sender.getCache();
-      factory.setScope(NO_ACK ? Scope.DISTRIBUTED_NO_ACK
-          : Scope.DISTRIBUTED_ACK);
-      factory
-          .setDataPolicy(this.enablePersistence ? DataPolicy.PERSISTENT_REPLICATE
-              : DataPolicy.REPLICATE);
+      factory.setScope(NO_ACK ? Scope.DISTRIBUTED_NO_ACK : Scope.DISTRIBUTED_ACK);
+      factory.setDataPolicy(
+          this.enablePersistence ? DataPolicy.PERSISTENT_REPLICATE : DataPolicy.REPLICATE);
-            (this.enablePersistence ? DataPolicy.PERSISTENT_REPLICATE: DataPolicy.REPLICATE));
+            (this.enablePersistence ? DataPolicy.PERSISTENT_REPLICATE : DataPolicy.REPLICATE));
-      EvictionAttributes ea = EvictionAttributes
-          .createLIFOMemoryAttributes(this.maximumQueueMemory,
-              EvictionAction.OVERFLOW_TO_DISK);
-      
+      EvictionAttributes ea = EvictionAttributes.createLIFOMemoryAttributes(this.maximumQueueMemory,
+          EvictionAction.OVERFLOW_TO_DISK);
+
-      
+
-      
+
-        SerialGatewaySenderQueueMetaRegion meta = new SerialGatewaySenderQueueMetaRegion(
-            this.regionName, ra, null, gemCache, sender);
+        SerialGatewaySenderQueueMetaRegion meta =
+            new SerialGatewaySenderQueueMetaRegion(this.regionName, ra, null, gemCache, sender);
-          this.region = gemCache.createVMRegion(this.regionName, ra, new InternalRegionArguments().setInternalMetaRegion(meta)
-                                                                                                  .setDestroyLockFlag(true)
-                                                                                                  .setSnapshotInputStream(null)
-                                                                                                  .setImageTarget(null)
-                                                                                                  .setIsUsedForSerialGatewaySenderQueue(true)
-                                                                                                  .setInternalRegion(true)
-                                                                                                  .setSerialGatewaySender(sender));
+          this.region = gemCache.createVMRegion(this.regionName, ra,
+              new InternalRegionArguments().setInternalMetaRegion(meta).setDestroyLockFlag(true)
+                  .setSnapshotInputStream(null).setImageTarget(null)
+                  .setIsUsedForSerialGatewaySenderQueue(true).setInternalRegion(true)
+                  .setSerialGatewaySender(sender));
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.SingleWriteSingleReadRegionQueue_UNEXPECTED_EXCEPTION_DURING_INIT_OF_0,
-                  this.getClass()), veryUnLikely);
+          logger.fatal(LocalizedMessage.create(
+              LocalizedStrings.SingleWriteSingleReadRegionQueue_UNEXPECTED_EXCEPTION_DURING_INIT_OF_0,
+              this.getClass()), veryUnLikely);
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.SingleWriteSingleReadRegionQueue_UNEXPECTED_EXCEPTION_DURING_INIT_OF_0,
-                  this.getClass()), alsoUnlikely);
+          logger.fatal(LocalizedMessage.create(
+              LocalizedStrings.SingleWriteSingleReadRegionQueue_UNEXPECTED_EXCEPTION_DURING_INIT_OF_0,
+              this.getClass()), alsoUnlikely);
-          logger.debug("{}: Created queue region: {}",this, this.region);
+          logger.debug("{}: Created queue region: {}", this, this.region);
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.SingleWriteSingleReadRegionQueue_0_THE_QUEUE_REGION_NAMED_1_COULD_NOT_BE_CREATED,
-                new Object[] { this, this.regionName }), e);
+        logger.fatal(LocalizedMessage.create(
+            LocalizedStrings.SingleWriteSingleReadRegionQueue_0_THE_QUEUE_REGION_NAMED_1_COULD_NOT_BE_CREATED,
+            new Object[] {this, this.regionName}), e);
-      throw new IllegalStateException("Queue region " + this.region.getFullPath() + " already exists.");
+      throw new IllegalStateException(
+          "Queue region " + this.region.getFullPath() + " already exists.");
-  
+
-  
+
-  
+
-              logger.debug("BatchRemovalThread about to send the last Dispatched key {}", lastDispatchedKey);
+              logger.debug("BatchRemovalThread about to send the last Dispatched key {}",
+                  lastDispatchedKey);
-            
+
-              if (wasEmpty) continue;
+              if (wasEmpty)
+                continue;
-            EntryEventImpl event = EntryEventImpl.create((LocalRegion)region,
-                Operation.DESTROY, (lastDestroyedKey + 1) , null/* newValue */, null, false,
-                cache.getMyId());
+            EntryEventImpl event = EntryEventImpl.create((LocalRegion) region, Operation.DESTROY,
+                (lastDestroyedKey + 1), null/* newValue */, null, false, cache.getMyId());
-            
-            BatchDestroyOperation op =  new BatchDestroyOperation(event);
+
+            BatchDestroyOperation op = new BatchDestroyOperation(event);
-              logger.debug("BatchRemovalThread completed destroy of keys from {} to {}", lastDestroyedKey, temp);
+              logger.debug("BatchRemovalThread completed destroy of keys from {} to {}",
+                  lastDestroyedKey, temp);
-            
+
-        logger.info(LocalizedMessage.create(LocalizedStrings.HARegionQueue_THE_QUEUEREMOVALTHREAD_IS_DONE));
+        logger.info(
+            LocalizedMessage.create(LocalizedStrings.HARegionQueue_THE_QUEUEREMOVALTHREAD_IS_DONE));
-        logger.warn(LocalizedMessage.create(LocalizedStrings.HARegionQueue_QUEUEREMOVALTHREAD_IGNORED_CANCELLATION));
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.HARegionQueue_QUEUEREMOVALTHREAD_IGNORED_CANCELLATION));
-  
-  public static class SerialGatewaySenderQueueMetaRegion extends
-      DistributedRegion {
+
+  public static class SerialGatewaySenderQueueMetaRegion extends DistributedRegion {
-    protected SerialGatewaySenderQueueMetaRegion(String regionName,
-        RegionAttributes attrs, LocalRegion parentRegion,
-        GemFireCacheImpl cache, AbstractGatewaySender sender) {
+
+    protected SerialGatewaySenderQueueMetaRegion(String regionName, RegionAttributes attrs,
+        LocalRegion parentRegion, GemFireCacheImpl cache, AbstractGatewaySender sender) {
-          new InternalRegionArguments().setDestroyLockFlag(true)
-              .setRecreateFlag(false).setSnapshotInputStream(null)
-              .setImageTarget(null).setIsUsedForSerialGatewaySenderQueue(true).setSerialGatewaySender(sender));
+          new InternalRegionArguments().setDestroyLockFlag(true).setRecreateFlag(false)
+              .setSnapshotInputStream(null).setImageTarget(null)
+              .setIsUsedForSerialGatewaySenderQueue(true).setSerialGatewaySender(sender));
-    //Prevent this region from using concurrency checks
+    // Prevent this region from using concurrency checks
-    public void createEventTracker() {
-    }
+    public void createEventTracker() {}
-    
+
+
+
+
-    protected void basicDestroy(final EntryEventImpl event,
-        final boolean cacheWrite, Object expectedOldValue)
+    protected void basicDestroy(final EntryEventImpl event, final boolean cacheWrite,
+        Object expectedOldValue)
-
-      super.basicDestroy(event, cacheWrite, expectedOldValue);
-      GatewaySenderEventImpl.release(event.getRawOldValue());
-    }
-    @Override
-    protected boolean virtualPut(EntryEventImpl event, boolean ifNew,
-        boolean ifOld, Object expectedOldValue, boolean requireOldValue,
-        long lastModified, boolean overwriteDestroyed) throws TimeoutException,
-        CacheWriterException {
-      boolean success = super.virtualPut(event, ifNew, ifOld, expectedOldValue,
-          requireOldValue, lastModified, overwriteDestroyed);
-
-      if (success) {
+      try {
+        super.basicDestroy(event, cacheWrite, expectedOldValue);
+      } finally {
-      return success;
+    }
+
+    @Override
+    protected boolean virtualPut(EntryEventImpl event, boolean ifNew, boolean ifOld,
+        Object expectedOldValue, boolean requireOldValue, long lastModified,
+        boolean overwriteDestroyed) throws TimeoutException, CacheWriterException {
+      try {
+        boolean success = super.virtualPut(event, ifNew, ifOld, expectedOldValue, requireOldValue,
+            lastModified, overwriteDestroyed);
+        if (!success) {
+          // release offheap reference if GatewaySenderEventImpl is not put into
+          // the region queue
+          GatewaySenderEventImpl.release(event.getRawNewValue());
+        }
+        return success;
+      } finally {
+        // GatewaySenderQueue probably only adding new events into the queue.
+        // Add the finally block just in case if there actually is an update
+        // in the sender queue or occurs in the the future.
+        GatewaySenderEventImpl.release(event.getRawOldValue());
+      }

INS31 INS31 MOV29 UPD83 MOV83 INS43 INS42 INS8 INS83 INS43 UPD42 MOV42 INS44 INS8 INS42 INS60 MOV25 INS41 INS42 INS43 INS42 INS60 INS25 MOV25 INS41 INS25 INS8 INS8 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS39 INS59 INS42 INS42 INS43 INS59 INS27 INS8 INS42 INS43 INS27 INS8 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS54 INS54 INS42 UPD42 MOV42 INS42 INS32 INS36 INS32 MOV21 INS42 INS32 INS42 INS33 INS41 INS36 MOV8 INS8 MOV8 INS8 INS42 INS42 INS27 INS42 INS42 INS42 INS33 INS27 INS21 INS21 INS33 INS42 UPD42 INS42 INS45 INS52 INS42 INS42 INS21 INS33 MOV36 MOV42 INS32 INS38 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS32 INS32 INS42 INS42 INS42 INS42 INS45 INS45 INS42 INS42 UPD42 MOV42 MOV42 UPD42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL39 DEL43 DEL42 DEL44 DEL8 DEL31 DEL66 DEL66 DEL18 DEL39 DEL34 DEL38 DEL42 DEL42 DEL32 DEL32 DEL33 DEL27 DEL42 DEL42 DEL32 DEL66 DEL66 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42
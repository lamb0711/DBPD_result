Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-  
+
-   * Send a list of gateway events to a server to execute
-   * using connections from the given pool
-   * to communicate with the server.
+   * Send a list of gateway events to a server to execute using connections from the given pool to
+   * communicate with the server.
+   * 
-  public static void executeOn(Connection con, ExecutablePool pool, List events, int batchId, boolean isRetry)
-  {
+  public static void executeOn(Connection con, ExecutablePool pool, List events, int batchId,
+      boolean isRetry) {
-    //System.out.println("Version: "+con.getWanSiteVersion());
-    //Is this check even needed anymore?  It looks like we just create the same exact op impl with the same parameters...
+    // System.out.println("Version: "+con.getWanSiteVersion());
+    // Is this check even needed anymore? It looks like we just create the same exact op impl with
+    // the same parameters...
-    pool.executeOn(con, op, true/*timeoutFatal*/);
+    pool.executeOn(con, op, true/* timeoutFatal */);
-  
-  
-  public static Object executeOn(Connection con, ExecutablePool pool)
-  {
+
+
+  public static Object executeOn(Connection con, ExecutablePool pool) {
-    return pool.executeOn(con, op, true/*timeoutFatal*/);
+    return pool.executeOn(con, op, true/* timeoutFatal */);
-                                                               
+
-  
+
-    
+
-    public GatewaySenderGFEBatchOpImpl(List events, int batchId, int dsId, boolean isRetry)  {
+    public GatewaySenderGFEBatchOpImpl(List events, int batchId, int dsId, boolean isRetry) {
-      getMessage().addBytesPart(
-          new byte[] { removeFromQueueOnException ? (byte)1 : (byte)0 });
+      getMessage().addBytesPart(new byte[] {removeFromQueueOnException ? (byte) 1 : (byte) 0});
-        GatewaySenderEventImpl event = (GatewaySenderEventImpl)i.next();
+        GatewaySenderEventImpl event = (GatewaySenderEventImpl) i.next();
-          byte posDupByte = (byte)(event.getPossibleDuplicate()?0x01:0x00);
+          byte posDupByte = (byte) (event.getPossibleDuplicate() ? 0x01 : 0x00);
-    
+
-    
-    
+
+
-     * Attempts to read a response to this operation by reading it from the
-     * given connection, and returning it.
+     * Attempts to read a response to this operation by reading it from the given connection, and
+     * returning it.
+     * 
-     * @return the result of the operation
-     *         or <code>null</code> if the operation has no result.
+     * @return the result of the operation or <code>null</code> if the operation has no result.
-        msg.setComms(cnx.getSocket(), cnx.getInputStream(),
-            cnx.getOutputStream(),
-            ((ConnectionImpl)cnx).getCommBufferForAsyncRead(), cnx.getStats());
+        msg.setComms(cnx.getSocket(), cnx.getInputStream(), cnx.getOutputStream(),
+            ((ConnectionImpl) cnx).getCommBufferForAsyncRead(), cnx.getStats());
-      
+
-    
-    
+
+
-        GatewaySenderEventImpl event = (GatewaySenderEventImpl)i.next();
+        GatewaySenderEventImpl event = (GatewaySenderEventImpl) i.next();
-    protected void processSecureBytes(Connection cnx, Message message)
-        throws Exception {
-    }
+    protected void processSecureBytes(Connection cnx, Message message) throws Exception {}
-        case MessageType.REPLY:
-          // Read the chunk
-          Part part0 = msg.getPart(0);
-          if (part0.isBytes() && part0.getLength() == 1 && part0.getSerializedForm()[0] == 0) {
-            // REPLY_OKAY from a CloseConnection
+          case MessageType.REPLY:
+            // Read the chunk
+            Part part0 = msg.getPart(0);
+            if (part0.isBytes() && part0.getLength() == 1 && part0.getSerializedForm()[0] == 0) {
+              // REPLY_OKAY from a CloseConnection
+              break;
+            }
+            int batchId = part0.getInt();
+            int numEvents = msg.getPart(1).getInt();
+            ack = new GatewayAck(batchId, numEvents);
-          }
-          int batchId = part0.getInt();
-          int numEvents = msg.getPart(1).getInt();
-          ack = new GatewayAck(batchId, numEvents);
-          break;
-        case MessageType.EXCEPTION:
-          part0 = msg.getPart(0);
+          case MessageType.EXCEPTION:
+            part0 = msg.getPart(0);
-          Object obj = part0.getObject();
-          if (obj instanceof List) {
-            List<BatchException70> l = (List<BatchException70>)part0.getObject();
+            Object obj = part0.getObject();
+            if (obj instanceof List) {
+              List<BatchException70> l = (List<BatchException70>) part0.getObject();
-           // if (logger.isDebugEnabled()) {
-              logger.info("We got an exception from the GatewayReceiver. MessageType : {} obj :{}", msg.getMessageType(), obj);
-            //}
-            // don't throw Exception but set it in the Ack
-            BatchException70 be = new BatchException70(l);
-            ack = new GatewayAck(be, l.get(0).getBatchId());
+              if (logger.isDebugEnabled()) {
+                logger.info(
+                    "We got an exception from the GatewayReceiver. MessageType : {} obj :{}",
+                    msg.getMessageType(), obj);
+              }
+              // don't throw Exception but set it in the Ack
+              BatchException70 be = new BatchException70(l);
+              ack = new GatewayAck(be, l.get(0).getBatchId());
-          } else if (obj instanceof Throwable) {
-            String s = ": While reading Ack from receiver "
-                + ((Throwable)obj).getMessage();
-            throw new ServerOperationException(s, (Throwable)obj);
-          }
-          break;
-        default:
-          throw new InternalGemFireError(
-              LocalizedStrings.Op_UNKNOWN_MESSAGE_TYPE_0
-                  .toLocalizedString(Integer.valueOf(msg.getMessageType())));
+            } else if (obj instanceof Throwable) {
+              String s = ": While reading Ack from receiver " + ((Throwable) obj).getMessage();
+              throw new ServerOperationException(s, (Throwable) obj);
+            }
+            break;
+          default:
+            throw new InternalGemFireError(LocalizedStrings.Op_UNKNOWN_MESSAGE_TYPE_0
+                .toLocalizedString(Integer.valueOf(msg.getMessageType())));
-    
+
+
+
+
-    
+

UPD66 UPD66 UPD66 UPD66 UPD66 INS25 INS32 INS8 INS42 INS42 MOV21 DEL66 DEL66
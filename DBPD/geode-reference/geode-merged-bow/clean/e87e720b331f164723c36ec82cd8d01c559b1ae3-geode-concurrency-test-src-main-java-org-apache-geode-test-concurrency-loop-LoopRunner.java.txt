GEODE-6515: refactor ConnectionManagerImpl (#3304)

Refactors the ConnectionManagerImpl to a non-locking implementation to allow gets to scale with more threads. The previous implementation locked around all logic for getting, creating, or returning a connection to the pool, which resulted in a high degree of contention for that lock.

Additionally, much of the logic for accounting for the number of total connections, and the dequeue of available connections have been extracted to ConnectionAccounting and AvailableConnectionManager respectively. This was done in order to add unit and concurrent tests for that logic.

* Refactor ConnectionManagerImpl to a non-locking implementation
* add unit tests for ConnectionManagerImpl
* update ConnectionManagerImpl Javadocs
* extract ConnectionAccounting from ConnectionManagerImpl
* add unit test for ConnectionAccounting
* add concurrency tests for ConnectionAccounting
* extract AvailableConnectionManager from ConnectionManagerImpl
* add unit tests for AvailableConnectionManager
* add concurrency tests for AvailableConnectionManager
* add unit test for ConcurrentTestRunner
* add javadocs to AvailableConnectionManager and improved the method names
* activate returns false if the connection has been destroyed instead of throwing ConnectionDestroyedException
* start background prefill if under the minimum number of connections in ConnectionManagerImpl#borrowConnection when create fails
* add generic <ServerLocation> to Set in ConnectionManagerImpl
* Correct invalidateServer logic in ConnectionManagerImpl
* make NOT_WAITING private in ConnectionManagerImpl
* made createLifetimeReplacementConnection private since it is only
used by ConnectionMap

Signed-off-by: Helena Bales <hbales@pivotal.io>
Signed-off-by: Jacob Barrett <jbarrett@pivotal.io>
Signed-off-by: Darrel Schneider <dschneider@pivotal.io>

+
+import java.lang.reflect.InvocationTargetException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicInteger;
+        } catch (InvocationTargetException ex) {
+          Throwable exceptionToReturn = ex.getCause();
+          if (exceptionToReturn == null) {
+            exceptionToReturn = ex;
+          }
+          return Collections.singletonList(ex.getCause());
-    List<Future<?>> futures;
+    private List<Future<?>> futures;
+    private final AtomicInteger callablesStarting = new AtomicInteger(0);
+    private final CountDownLatch start = new CountDownLatch(1);
-      futures = new ArrayList<Future<?>>();
+      futures = new ArrayList<>();
-      Future<T> future = executorService.submit(callable);
+      callablesStarting.getAndIncrement();
+      Future<T> future = executorService.submit(() -> {
+        callablesStarting.getAndDecrement();
+        start.await();
+        return callable.call();
+      });
+      while (callablesStarting.get() > 0);
+
+      start.countDown();
+      futures.clear();
+

INS26 INS26 INS26 INS40 INS40 INS40 INS23 INS23 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS42 INS42 INS14 INS42 INS42 INS14 INS21 INS61 INS21 INS21 INS43 INS34 INS43 INS34 INS32 INS27 INS20 INS32 INS32 INS42 INS42 INS42 INS42 INS32 INS34 INS42 INS42 INS42 INS42 UPD74 INS86 INS42 INS42 INS12 INS8 INS44 INS8 INS21 INS21 INS41 INS43 INS42 INS60 INS25 INS41 INS32 INS32 INS32 INS42 INS43 INS59 INS27 INS8 INS32 INS42 INS42 INS42 INS42 MOV42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS32 INS42 INS42 INS7 INS42 INS42 INS42 INS42 DEL42 DEL43 DEL76 DEL74
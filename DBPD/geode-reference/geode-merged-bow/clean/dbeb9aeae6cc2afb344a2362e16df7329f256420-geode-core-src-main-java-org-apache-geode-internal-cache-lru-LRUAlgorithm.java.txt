Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Eviction controllers that extend this class evict the least
- * recently used (LRU) entry in the region whose capacity they
- * controller.  In order to provide an efficient computation of the
- * LRU entry, GemFire uses special internal data structures for
- * managing the contents of a region.  As a result, there are several
- * restrictions that are placed on regions whose capacity is governed
- * by an LRU algorithm.
+ * Eviction controllers that extend this class evict the least recently used (LRU) entry in the
+ * region whose capacity they controller. In order to provide an efficient computation of the LRU
+ * entry, GemFire uses special internal data structures for managing the contents of a region. As a
+ * result, there are several restrictions that are placed on regions whose capacity is governed by
+ * an LRU algorithm.
- * <LI>If the capacity of a region is to be controlled by an LRU
- * algorithm, then the region must be <b>created</b> with 
- * {@link org.apache.geode.cache.EvictionAttributes}
+ * <LI>If the capacity of a region is to be controlled by an LRU algorithm, then the region must be
+ * <b>created</b> with {@link org.apache.geode.cache.EvictionAttributes}
- * <LI>The eviction controller of a region governed by an LRU
- * algorithm cannot be changed.</LI>
+ * <LI>The eviction controller of a region governed by an LRU algorithm cannot be changed.</LI>
- * <LI>An LRU algorithm cannot be applied to a region after the region
- * has been created.</LI>
+ * <LI>An LRU algorithm cannot be applied to a region after the region has been created.</LI>
- * </UL> 
+ * </UL>
- * LRU algorithms also specify what {@linkplain 
- * org.apache.geode.cache.EvictionAction
- * action} should be performed upon the least recently used entry when
- * the capacity is reached.  Currently, there are two supported
- * actions: {@linkplain org.apache.geode.cache.EvictionAction#LOCAL_DESTROY locally destroying} the entry
- * (which is the {@linkplain org.apache.geode.cache.EvictionAction#DEFAULT_EVICTION_ACTION default}), thus
- * freeing up space in the VM, and {@linkplain org.apache.geode.cache.EvictionAction#OVERFLOW_TO_DISK
+ * LRU algorithms also specify what {@linkplain org.apache.geode.cache.EvictionAction action} should
+ * be performed upon the least recently used entry when the capacity is reached. Currently, there
+ * are two supported actions: {@linkplain org.apache.geode.cache.EvictionAction#LOCAL_DESTROY
+ * locally destroying} the entry (which is the
+ * {@linkplain org.apache.geode.cache.EvictionAction#DEFAULT_EVICTION_ACTION default}), thus freeing
+ * up space in the VM, and {@linkplain org.apache.geode.cache.EvictionAction#OVERFLOW_TO_DISK
- * {@link org.apache.geode.cache.EvictionAttributes Eviction controllers} that use an LRU
- * algorithm maintain certain region-dependent state (such as the
- * maximum number of entries allowed in the region).  As a result, an
- * instance of <code>LRUAlgorithm</code> cannot be shared among
- * multiple regions.  Attempts to create a region with a LRU-based
- * capacity controller that has already been used to create another
- * region will result in an {@link IllegalStateException} being
- * thrown.
+ * {@link org.apache.geode.cache.EvictionAttributes Eviction controllers} that use an LRU algorithm
+ * maintain certain region-dependent state (such as the maximum number of entries allowed in the
+ * region). As a result, an instance of <code>LRUAlgorithm</code> cannot be shared among multiple
+ * regions. Attempts to create a region with a LRU-based capacity controller that has already been
+ * used to create another region will result in an {@link IllegalStateException} being thrown.
-public abstract class LRUAlgorithm
-  implements CacheCallback, Serializable, Cloneable
-{
+public abstract class LRUAlgorithm implements CacheCallback, Serializable, Cloneable {
-  /** The key for setting the <code>eviction-action</code> property
-   * of an <code>LRUAlgorithm</code> */
+  /**
+   * The key for setting the <code>eviction-action</code> property of an <code>LRUAlgorithm</code>
+   */
-  ////////////////////////  Instance Fields  ///////////////////////
+  //////////////////////// Instance Fields ///////////////////////
-  /////////////////////////  Constructors  /////////////////////////
+  ///////////////////////// Constructors /////////////////////////
-   * Creates a new <code>LRUAlgorithm</code> with the given
-   * {@linkplain EvictionAction eviction action}.
+   * Creates a new <code>LRUAlgorithm</code> with the given {@linkplain EvictionAction eviction
+   * action}.
-  protected LRUAlgorithm(EvictionAction evictionAction,Region region) {
-    bucketRegion=(BucketRegion)(region instanceof BucketRegion ? region :null);
+  protected LRUAlgorithm(EvictionAction evictionAction, Region region) {
+    bucketRegion = (BucketRegion) (region instanceof BucketRegion ? region : null);
-  ///////////////////////  Instance Methods  ///////////////////////
+  /////////////////////// Instance Methods ///////////////////////
-      this.bucketRegion = (BucketRegion)r;
+      this.bucketRegion = (BucketRegion) r;
+
-   * Sets the action that is performed on the least recently used
-   * entry when it is evicted from the VM.
+   * Sets the action that is performed on the least recently used entry when it is evicted from the
+   * VM.
-   * @throws IllegalArgumentException
-   *         If <code>evictionAction</code> specifies an unknown
-   *         eviction action.
+   * @throws IllegalArgumentException If <code>evictionAction</code> specifies an unknown eviction
+   *         action.
-  protected void setEvictionAction(EvictionAction  evictionAction) {
-      this.evictionAction = evictionAction;
+  protected void setEvictionAction(EvictionAction evictionAction) {
+    this.evictionAction = evictionAction;
-   * Gets the action that is performed on the least recently used
-   * entry when it is evicted from the VM.
+   * Gets the action that is performed on the least recently used entry when it is evicted from the
+   * VM.
-   * {@link EvictionAction#OVERFLOW_TO_DISK}
+   *         {@link EvictionAction#OVERFLOW_TO_DISK}
-   * For internal use only.  Returns a helper object used internally
-   * by the GemFire cache implementation.
+   * For internal use only. Returns a helper object used internally by the GemFire cache
+   * implementation.
-      // conditions with copy sharing.  See bug 31047.
+      // conditions with copy sharing. See bug 31047.
-  private void writeObject(java.io.ObjectOutputStream out)
-    throws IOException {
+  private void writeObject(java.io.ObjectOutputStream out) throws IOException {
-    synchronized (this) {        // See bug 31047
+    synchronized (this) { // See bug 31047
-  private void readObject(java.io.ObjectInputStream in)
-    throws IOException, ClassNotFoundException {
+  private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {
-    synchronized (this) {        // See bug 31047
+    synchronized (this) { // See bug 31047
-//   public void writeExternal(ObjectOutput out)
-//     throws IOException {
-//     out.writeObject(this.evictionAction);
-//   }
+  // public void writeExternal(ObjectOutput out)
+  // throws IOException {
+  // out.writeObject(this.evictionAction);
+  // }
-//   public void readExternal(ObjectInput in)
-//     throws IOException, ClassNotFoundException {
-//     String evictionAction = (String) in.readObject();
-//     this.setEvictionAction(evictionAction);
-//   }
+  // public void readExternal(ObjectInput in)
+  // throws IOException, ClassNotFoundException {
+  // String evictionAction = (String) in.readObject();
+  // this.setEvictionAction(evictionAction);
+  // }
-//   protected Object readResolve() throws ObjectStreamException {
-//     if (this.helper == null) {
-//       this.helper = createLRUHelper();
-//     }
-//     return this;
-//   }
+  // protected Object readResolve() throws ObjectStreamException {
+  // if (this.helper == null) {
+  // this.helper = createLRUHelper();
+  // }
+  // return this;
+  // }
-   * Creates a new <code>LRUHelper</code> tailed for this LRU
-   * algorithm implementation.
+   * Creates a new <code>LRUHelper</code> tailed for this LRU algorithm implementation.
-   * Set the limiting parameter used to determine when eviction is 
-   * needed. 
+   * Set the limiting parameter used to determine when eviction is needed.
-   * This method is an artifact when eviction controllers used to 
-   * called capacity controllers and were configured in the cache.xml 
-   * file as <code>Declarable</code>
+   * This method is an artifact when eviction controllers used to called capacity controllers and
+   * were configured in the cache.xml file as <code>Declarable</code>
+   * 
-      }
-      else {
+      } else {
-   * Returns a copy of this LRU-based eviction controller.  
-   * This method is a artifact when capacity controllers
-   * were used on a <code>Region</code>
+   * Returns a copy of this LRU-based eviction controller. This method is a artifact when capacity
+   * controllers were used on a <code>Region</code>
-  
-  /** Return true if the specified capacity controller is
-   *  compatible with this
+
+  /**
+   * Return true if the specified capacity controller is compatible with this
-    if (cc == null) return false;
-    if (!getClass().isAssignableFrom(cc.getClass())) return false;
-    LRUAlgorithm other = (LRUAlgorithm)cc;
-    if (!other.evictionAction.equals(this.evictionAction)) return false;
+    if (cc == null)
+      return false;
+    if (!getClass().isAssignableFrom(cc.getClass()))
+      return false;
+    LRUAlgorithm other = (LRUAlgorithm) cc;
+    if (!other.evictionAction.equals(this.evictionAction))
+      return false;
+   * 
-   * Note that we just need to make sure that equal objects return equal
-   * hashcodes; nothing really elaborate is done here.
+   * Note that we just need to make sure that equal objects return equal hashcodes; nothing really
+   * elaborate is done here.
-  //////////////////////  Inner Classes  //////////////////////
+  ////////////////////// Inner Classes //////////////////////
-   * A partial implementation of the <code>EnableLRU</code> interface
-   * that contains code common to all <code>LRUAlgorithm</code>s. 
+   * A partial implementation of the <code>EnableLRU</code> interface that contains code common to
+   * all <code>LRUAlgorithm</code>s.
-    
+
-      if ( stats == null ) {
-        throw new InternalGemFireException(LocalizedStrings.LRUAlgorithm_LRU_STATS_IN_EVICTION_CONTROLLER_INSTANCE_SHOULD_NOT_BE_NULL.toLocalizedString());
+      if (stats == null) {
+        throw new InternalGemFireException(
+            LocalizedStrings.LRUAlgorithm_LRU_STATS_IN_EVICTION_CONTROLLER_INSTANCE_SHOULD_NOT_BE_NULL
+                .toLocalizedString());
+
-        fullPathName = ((Region)region).getFullPath();
+        fullPathName = ((Region) region).getFullPath();
-        PlaceHolderDiskRegion phdr = (PlaceHolderDiskRegion)region;
+        PlaceHolderDiskRegion phdr = (PlaceHolderDiskRegion) region;
-        throw new IllegalArgumentException(LocalizedStrings.LRUAlgorithm_LRU_EVICTION_CONTROLLER_0_ALREADY_CONTROLS_THE_CAPACITY_OF_1_IT_CANNOT_ALSO_CONTROL_THE_CAPACITY_OF_REGION_2.toLocalizedString(new Object[] {LRUAlgorithm.this, this.regionName, fullPathName}));
+        throw new IllegalArgumentException(
+            LocalizedStrings.LRUAlgorithm_LRU_EVICTION_CONTROLLER_0_ALREADY_CONTROLS_THE_CAPACITY_OF_1_IT_CANNOT_ALSO_CONTROL_THE_CAPACITY_OF_REGION_2
+                .toLocalizedString(
+                    new Object[] {LRUAlgorithm.this, this.regionName, fullPathName}));
-    
+
-      LRUAlgorithm.this.stats = stats;      
+      LRUAlgorithm.this.stats = stats;
-      stats.setLimit( LRUAlgorithm.this.getLimit() );
-      stats.setDestroysLimit( 1000 );
+      stats.setLimit(LRUAlgorithm.this.getLimit());
+      stats.setDestroysLimit(1000);

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
GEODE-7330: Prevent RegionDestroyedException in FederatingManager (#4193)

* GEODE-7330: Prevent RegionDestroyedException in FederatingManager

Cleanup management classes:
* Reduce method and field visibility as much as possible
* Remove unnecessary uses of this
* Reorder fields and methods based on visibility and other modifiers
* Use @VisibleForTesting annotation
* Fixup formatting and variable names

Make all FederatingManager fields final:
* Remove field setters for tests
* Introduce FederatingManagerFactory
* Add FederatingManagerFactory system property for tests to
  SystemManagementService
* Inject all FederatingManager fields via constructor
* Use Geode APIs in MBeanFederationErrorPathDUnitTest

Rename MBeanFederationErrorHandlingDistributedTest:
* Rename MBeanFederationErrorPathDUnitTest as
  MBeanFederationErrorHandlingDistributedTest
+import static java.util.Arrays.asList;
+import static java.util.Collections.unmodifiableList;
+import static org.apache.commons.lang3.StringUtils.isNotBlank;
+import static org.apache.geode.management.JMXNotificationType.ASYNC_EVENT_QUEUE_CLOSED;
+import static org.apache.geode.management.JMXNotificationType.ASYNC_EVENT_QUEUE_CREATED;
+import static org.apache.geode.management.JMXNotificationType.CACHE_SERVER_STARTED;
+import static org.apache.geode.management.JMXNotificationType.CACHE_SERVER_STOPPED;
+import static org.apache.geode.management.JMXNotificationType.CACHE_SERVICE_CREATED;
+import static org.apache.geode.management.JMXNotificationType.CLIENT_CRASHED;
+import static org.apache.geode.management.JMXNotificationType.CLIENT_JOINED;
+import static org.apache.geode.management.JMXNotificationType.CLIENT_LEFT;
+import static org.apache.geode.management.JMXNotificationType.DISK_STORE_CLOSED;
+import static org.apache.geode.management.JMXNotificationType.DISK_STORE_CREATED;
+import static org.apache.geode.management.JMXNotificationType.GATEWAY_RECEIVER_CREATED;
+import static org.apache.geode.management.JMXNotificationType.GATEWAY_RECEIVER_DESTROYED;
+import static org.apache.geode.management.JMXNotificationType.GATEWAY_RECEIVER_STARTED;
+import static org.apache.geode.management.JMXNotificationType.GATEWAY_RECEIVER_STOPPED;
+import static org.apache.geode.management.JMXNotificationType.GATEWAY_SENDER_CREATED;
+import static org.apache.geode.management.JMXNotificationType.GATEWAY_SENDER_PAUSED;
+import static org.apache.geode.management.JMXNotificationType.GATEWAY_SENDER_REMOVED;
+import static org.apache.geode.management.JMXNotificationType.GATEWAY_SENDER_RESUMED;
+import static org.apache.geode.management.JMXNotificationType.GATEWAY_SENDER_STARTED;
+import static org.apache.geode.management.JMXNotificationType.GATEWAY_SENDER_STOPPED;
+import static org.apache.geode.management.JMXNotificationType.LOCATOR_STARTED;
+import static org.apache.geode.management.JMXNotificationType.LOCK_SERVICE_CLOSED;
+import static org.apache.geode.management.JMXNotificationType.LOCK_SERVICE_CREATED;
+import static org.apache.geode.management.JMXNotificationType.REGION_CLOSED;
+import static org.apache.geode.management.JMXNotificationType.REGION_CREATED;
+import static org.apache.geode.management.JMXNotificationType.SYSTEM_ALERT;
+import static org.apache.geode.management.JMXNotificationUserData.ALERT_LEVEL;
+import static org.apache.geode.management.JMXNotificationUserData.MEMBER;
+import static org.apache.geode.management.JMXNotificationUserData.THREAD;
+import static org.apache.geode.management.internal.AlertDetails.getAlertLevelAsString;
+import static org.apache.geode.management.internal.ManagementConstants.AGGREGATE_MBEAN_PATTERN;
+import static org.apache.geode.management.internal.ManagementConstants.ASYNC_EVENT_QUEUE_CLOSED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.ASYNC_EVENT_QUEUE_CREATED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.CACHE_SERVER_STARTED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.CACHE_SERVER_STOPPED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.CACHE_SERVICE_CREATED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.CLIENT_CRASHED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.CLIENT_JOINED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.CLIENT_LEFT_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.DISK_STORE_CLOSED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.DISK_STORE_CREATED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.GATEWAY_RECEIVER_CREATED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.GATEWAY_RECEIVER_DESTROYED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.GATEWAY_RECEIVER_STARTED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.GATEWAY_RECEIVER_STOPPED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.GATEWAY_SENDER_CREATED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.GATEWAY_SENDER_PAUSED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.GATEWAY_SENDER_REMOVED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.GATEWAY_SENDER_RESUMED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.GATEWAY_SENDER_STARTED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.GATEWAY_SENDER_STOPPED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.LOCATOR_STARTED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.LOCK_SERVICE_CLOSED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.LOCK_SERVICE_CREATED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.REGION_CLOSED_PREFIX;
+import static org.apache.geode.management.internal.ManagementConstants.REGION_CREATED_PREFIX;
+
+import java.lang.management.ManagementFactory;
-import java.util.Arrays;
-import java.util.Collections;
-import org.apache.commons.lang3.StringUtils;
-import org.apache.geode.annotations.internal.MakeNotStatic;
-import org.apache.geode.cache.Cache;
+import org.apache.geode.distributed.DistributedMember;
-import org.apache.geode.internal.cache.LocalRegion;
-import org.apache.geode.management.JMXNotificationType;
-import org.apache.geode.management.JMXNotificationUserData;
-import org.apache.geode.management.internal.ManagementConstants;
+ * <p>
-  /** Internal ManagementService Instance **/
-  private SystemManagementService service;
-
-  /** GemFire Cache impl **/
-  private InternalCache internalCache;
-
-  /** Member Name **/
-  private String memberSource;
-
-  /**
-   * emitter is a helper class for sending notifications on behalf of the MemberMBean
-   **/
-  private NotificationBroadcasterSupport memberLevelNotifEmitter;
-
-  /** The <code>MBeanServer</code> for this application */
-  @MakeNotStatic
-  public static final MBeanServer mbeanServer = MBeanJMXAdapter.mbeanServer;
-
-  /** MemberMBean instance **/
-  private MemberMBean memberBean;
-
-  private volatile boolean serviceInitialised = false;
-
-  @MakeNotStatic
-  private MBeanAggregator aggregator;
-
-  public static final List<Class> refreshOnInit;
+  private static final List<String> INTERNAL_LOCK_SERVICES =
+      unmodifiableList(asList(DLockService.DTLS, DLockService.LTLS,
+          PartitionedRegionHelper.PARTITION_LOCK_SERVICE_NAME,
+          PeerTypeRegistration.LOCK_SERVICE_NAME));
-  @Immutable
-  public static final List<String> internalLocks;
-
-  static {
-    refreshOnInit =
-        Collections.unmodifiableList(Arrays.asList(RegionMXBean.class, MemberMXBean.class));
-
-    internalLocks = Collections.unmodifiableList(Arrays.asList(
-        DLockService.DTLS, // From reserved lock service name
-        DLockService.LTLS, // From reserved lock service name
-        PartitionedRegionHelper.PARTITION_LOCK_SERVICE_NAME,
-        PeerTypeRegistration.LOCK_SERVICE_NAME));
-  }
-
-  protected MemberMBeanBridge memberMBeanBridge;
-
+  private final MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
+  private SystemManagementService service;
+  private InternalCache internalCache;
+  private String memberSource;
+  private NotificationBroadcasterSupport memberLevelNotificationEmitter;
+  private MemberMBean memberBean;
+  private MBeanAggregator aggregator;
+  private MemberMBeanBridge memberMBeanBridge;
+
+  private volatile boolean serviceInitialised;
+
-   * Adapter life cycle is tied with the Cache . So its better to make all cache level artifacts as
+   * Adapter life cycle is tied with the Cache. So its better to make all cache level artifacts as
-   *
-   * @param cache gemfire cache
-  protected void handleCacheCreation(InternalCache cache) throws ManagementException {
+  void handleCacheCreation(InternalCache cache) throws ManagementException {
-      this.internalCache = cache;
-      this.service =
-          (SystemManagementService) ManagementService.getManagementService(internalCache);
+      internalCache = cache;
+      service = (SystemManagementService) ManagementService.getManagementService(internalCache);
-      this.memberMBeanBridge = new MemberMBeanBridge(internalCache, service).init();
-      this.memberBean = new MemberMBean(memberMBeanBridge);
-      this.memberLevelNotifEmitter = memberBean;
+      memberMBeanBridge = new MemberMBeanBridge(internalCache, service).init();
+      memberBean = new MemberMBean(memberMBeanBridge);
+      memberLevelNotificationEmitter = memberBean;
+      memberSource = MBeanJMXAdapter.getMemberNameOrUniqueId(cache.getMyId());
-      ObjectName memberMBeanName = MBeanJMXAdapter.getMemberMBeanName(
-          InternalDistributedSystem.getConnectedInstance().getDistributedMember());
+      // Type casting to MemberMXBean to expose only those methods described in interface
+      ObjectName objectName = MBeanJMXAdapter.getMemberMBeanName(cache.getMyId());
+      ObjectName federatedName = service.registerInternalMBean(memberBean, objectName);
+      service.federate(federatedName, MemberMXBean.class, true);
-      memberSource = MBeanJMXAdapter
-          .getMemberNameOrUniqueId(internalCache.getDistributedSystem().getDistributedMember());
+      serviceInitialised = true;
-      // Type casting to MemberMXBean to expose only those methods described in
-      // the interface;
-      ObjectName changedMBeanName = service.registerInternalMBean(memberBean, memberMBeanName);
-      service.federate(changedMBeanName, MemberMXBean.class, true);
-
-      this.serviceInitialised = true;
-
-      // Service initialised is only for ManagementService and not necessarily
-      // Manager service.
+      // Service initialised is only for ManagementService and not necessarily Manager service.
-        Locator loc = InternalLocator.getLocator();
-        handleLocatorStart(loc);
+        handleLocatorStart(InternalLocator.getLocator());
-        this.service.createManager();
+        service.createManager();
-          this.service.startManager();
+          service.startManager();
-  protected void handleManagerStart() throws ManagementException {
+  void handleManagerStart() throws ManagementException {
-    MBeanJMXAdapter jmxAdapter = service.getJMXAdapter();
-    Map<ObjectName, Object> registeredMBeans = jmxAdapter.getLocalGemFireMBean();
-    DistributedSystemBridge dsBridge = new DistributedSystemBridge(service, internalCache);
-    this.aggregator = new MBeanAggregator(dsBridge);
+    DistributedSystemBridge distributedSystemBridge =
+        new DistributedSystemBridge(service, internalCache);
+    aggregator = new MBeanAggregator(distributedSystemBridge);
+
-    /*
-     * get the local member mbean as it need to be provided to aggregator first
-     */
+    // get the local member mbean as it need to be provided to aggregator first
+    MemberMXBean localMemberMXBean = service.getMemberMXBean();
-    MemberMXBean localMember = service.getMemberMXBean();
-    FederationComponent addedComp =
+    FederationComponent memberFederation =
-    service.afterCreateProxy(memberObjectName, MemberMXBean.class, localMember, addedComp);
+    service.afterCreateProxy(memberObjectName, MemberMXBean.class, localMemberMXBean,
+        memberFederation);
+
+    MBeanJMXAdapter jmxAdapter = service.getJMXAdapter();
+    Map<ObjectName, Object> registeredMBeans = jmxAdapter.getLocalGemFireMBean();
-      ObjectInstance instance;
-        instance = mbeanServer.getObjectInstance(objectName);
+        ObjectInstance instance = mbeanServer.getObjectInstance(objectName);
-        Class cls = ClassLoadUtil.classFromName(className);
-        Type[] intfTyps = cls.getGenericInterfaces();
+        Class clazz = ClassLoadUtil.classFromName(className);
+        Type[] interfaceTypes = clazz.getGenericInterfaces();
-        FederationComponent newObj = service.getLocalManager().getFedComponents().get(objectName);
+        FederationComponent federation =
+            service.getLocalManager().getFedComponents().get(objectName);
-        for (Type intfTyp1 : intfTyps) {
-          Class intfTyp = (Class) intfTyp1;
-          service.afterCreateProxy(objectName, intfTyp, object, newObj);
+        for (Type interfaceType : interfaceTypes) {
+          Class interfaceTypeAsClass = (Class) interfaceType;
+          service.afterCreateProxy(objectName, interfaceTypeAsClass, object, federation);
-  protected void handleManagerStop() throws ManagementException {
+  void handleManagerStop() throws ManagementException {
-    MBeanJMXAdapter jmxAdapter = service.getJMXAdapter();
-    Map<ObjectName, Object> registeredMBeans = jmxAdapter.getLocalGemFireMBean();
-    ObjectName aggregatemMBeanPattern;
-    try {
-      aggregatemMBeanPattern = new ObjectName(ManagementConstants.AGGREGATE_MBEAN_PATTERN);
-    } catch (MalformedObjectNameException | NullPointerException e1) {
-      throw new ManagementException(e1);
-    }
-
-    MemberMXBean localMember = service.getMemberMXBean();
+    MemberMXBean localMemberMXBean = service.getMemberMXBean();
-    FederationComponent removedComp =
+    FederationComponent memberFederation =
-    service.afterRemoveProxy(memberObjectName, MemberMXBean.class, localMember, removedComp);
+    service.afterRemoveProxy(memberObjectName, MemberMXBean.class, localMemberMXBean,
+        memberFederation);
+    ObjectName aggregateMBeanPattern = aggregateMBeanPattern();
+    MBeanJMXAdapter jmxAdapter = service.getJMXAdapter();
+    Map<ObjectName, Object> registeredMBeans = jmxAdapter.getLocalGemFireMBean();
-      if (aggregatemMBeanPattern.apply(objectName)) {
+      if (aggregateMBeanPattern.apply(objectName)) {
-      ObjectInstance instance;
-        instance = mbeanServer.getObjectInstance(objectName);
+        ObjectInstance instance = mbeanServer.getObjectInstance(objectName);
-        Class cls = ClassLoadUtil.classFromName(className);
-        Type[] intfTyps = cls.getGenericInterfaces();
+        Class clazz = ClassLoadUtil.classFromName(className);
+        Type[] interfaceTypes = clazz.getGenericInterfaces();
-        FederationComponent oldObj = service.getLocalManager().getFedComponents().get(objectName);
+        FederationComponent federation =
+            service.getLocalManager().getFedComponents().get(objectName);
-        for (Type intfTyp1 : intfTyps) {
-          Class intfTyp = (Class) intfTyp1;
-          service.afterRemoveProxy(objectName, intfTyp, object, oldObj);
+        for (Type interfaceType : interfaceTypes) {
+          Class interfaceTypeClass = (Class) interfaceType;
+          service.afterRemoveProxy(objectName, interfaceTypeClass, object, federation);
-    service.removeProxyListener(this.aggregator);
-    this.aggregator = null;
+
+    service.removeProxyListener(aggregator);
+    aggregator = null;
-  protected void handleManagerCreation() throws ManagementException {
+  void handleManagerCreation() throws ManagementException {
-    ObjectName managerMBeanName = MBeanJMXAdapter.getManagerName();
+    ObjectName objectName = MBeanJMXAdapter.getManagerName();
+    ManagerMBeanBridge managerMBeanBridge = new ManagerMBeanBridge(service);
+    ManagerMXBean managerMXBean = new ManagerMBean(managerMBeanBridge);
-    ManagerMBeanBridge bridge = new ManagerMBeanBridge(service);
-
-    ManagerMXBean bean = new ManagerMBean(bridge);
-
-    service.registerInternalMBean(bean, managerMBeanName);
+    service.registerInternalMBean(managerMXBean, objectName);
-  public <K, V> void handleRegionCreation(Region<K, V> region) throws ManagementException {
+  <K, V> void handleRegionCreation(Region<K, V> region) throws ManagementException {
+
-      LocalRegion localRegion = (LocalRegion) region;
-      if (localRegion.isDestroyed()) {
+      if (region.isDestroyed()) {
+
-      RegionMBeanBridge<K, V> bridge = RegionMBeanBridge.getInstance(region);
-
-      RegionMXBean regionMBean = new RegionMBean<>(bridge);
-      ObjectName regionMBeanName = MBeanJMXAdapter.getRegionMBeanName(
+      RegionMBeanBridge<K, V> regionMBeanBridge = RegionMBeanBridge.getInstance(region);
+      RegionMXBean regionMXBean = new RegionMBean<>(regionMBeanBridge);
+      ObjectName objectName = MBeanJMXAdapter.getRegionMBeanName(
-      ObjectName changedMBeanName = service.registerInternalMBean(regionMBean, regionMBeanName);
-      service.federate(changedMBeanName, RegionMXBean.class, true);
+      ObjectName federatedName = service.registerInternalMBean(regionMXBean, objectName);
+      service.federate(federatedName, RegionMXBean.class, true);
-      Notification notification = new Notification(JMXNotificationType.REGION_CREATED, memberSource,
+      Notification notification = new Notification(REGION_CREATED, memberSource,
-          ManagementConstants.REGION_CREATED_PREFIX + region.getFullPath());
-      memberLevelNotifEmitter.sendNotification(notification);
+          REGION_CREATED_PREFIX + region.getFullPath());
+      memberLevelNotificationEmitter.sendNotification(notification);
+
-   *
-   * @param disk the disk store for which the call back is invoked
-  protected void handleDiskCreation(DiskStore disk) throws ManagementException {
+  void handleDiskCreation(DiskStore diskStore) throws ManagementException {
-    DiskStoreMBeanBridge bridge = new DiskStoreMBeanBridge(disk);
-    DiskStoreMXBean diskStoreMBean = new DiskStoreMBean(bridge);
-    ObjectName diskStoreMBeanName = MBeanJMXAdapter.getDiskStoreMBeanName(
-        internalCache.getDistributedSystem().getDistributedMember(), disk.getName());
-    ObjectName changedMBeanName = service.registerInternalMBean(diskStoreMBean, diskStoreMBeanName);
-    service.federate(changedMBeanName, DiskStoreMXBean.class, true);
+    DiskStoreMBeanBridge diskStoreMBeanBridge = new DiskStoreMBeanBridge(diskStore);
+    DiskStoreMXBean diskStoreMXBean = new DiskStoreMBean(diskStoreMBeanBridge);
+    ObjectName objectName = MBeanJMXAdapter.getDiskStoreMBeanName(
+        internalCache.getDistributedSystem().getDistributedMember(), diskStore.getName());
+    ObjectName federatedName = service.registerInternalMBean(diskStoreMXBean, objectName);
+    service.federate(federatedName, DiskStoreMXBean.class, true);
-    Notification notification = new Notification(JMXNotificationType.DISK_STORE_CREATED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.DISK_STORE_CREATED_PREFIX + disk.getName());
-    memberLevelNotifEmitter.sendNotification(notification);
-    memberMBeanBridge.addDiskStore(disk);
+    Notification notification = new Notification(DISK_STORE_CREATED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(),
+        DISK_STORE_CREATED_PREFIX + diskStore.getName());
+    memberLevelNotificationEmitter.sendNotification(notification);
+
+    memberMBeanBridge.addDiskStore(diskStore);
-  protected void handleLockServiceCreation(DLockService lockService) throws ManagementException {
+  void handleLockServiceCreation(DLockService lockService) throws ManagementException {
-    if (internalLocks.contains(lockService.getName())) {
+    if (INTERNAL_LOCK_SERVICES.contains(lockService.getName())) {
-    LockServiceMBeanBridge bridge = new LockServiceMBeanBridge(lockService);
-    LockServiceMXBean lockServiceMBean = new LockServiceMBean(bridge);
-    ObjectName lockServiceMBeanName = MBeanJMXAdapter.getLockServiceMBeanName(
+    LockServiceMBeanBridge lockServiceMBeanBridge = new LockServiceMBeanBridge(lockService);
+    LockServiceMXBean lockServiceMXBean = new LockServiceMBean(lockServiceMBeanBridge);
+    ObjectName objectName = MBeanJMXAdapter.getLockServiceMBeanName(
+    ObjectName federatedName =
+        service.registerInternalMBean(lockServiceMXBean, objectName);
+    service.federate(federatedName, LockServiceMXBean.class, true);
-    ObjectName changedMBeanName =
-        service.registerInternalMBean(lockServiceMBean, lockServiceMBeanName);
-
-    service.federate(changedMBeanName, LockServiceMXBean.class, true);
-
-    Notification notification = new Notification(JMXNotificationType.LOCK_SERVICE_CREATED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.LOCK_SERVICE_CREATED_PREFIX + lockService.getName());
-    memberLevelNotifEmitter.sendNotification(notification);
+    Notification notification = new Notification(LOCK_SERVICE_CREATED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(),
+        LOCK_SERVICE_CREATED_PREFIX + lockService.getName());
+    memberLevelNotificationEmitter.sendNotification(notification);
-  protected void handleGatewaySenderCreation(GatewaySender sender) throws ManagementException {
+  void handleGatewaySenderCreation(GatewaySender sender) throws ManagementException {
-    GatewaySenderMBeanBridge bridge = new GatewaySenderMBeanBridge(sender);
-    GatewaySenderMXBean senderMBean = new GatewaySenderMBean(bridge);
-    ObjectName senderObjectName = MBeanJMXAdapter.getGatewaySenderMBeanName(
+    GatewaySenderMBeanBridge gatewaySenderMBeanBridge = new GatewaySenderMBeanBridge(sender);
+    GatewaySenderMXBean gatewaySenderMXBean = new GatewaySenderMBean(gatewaySenderMBeanBridge);
+    ObjectName objectName = MBeanJMXAdapter.getGatewaySenderMBeanName(
+    ObjectName federatedName = service.registerInternalMBean(gatewaySenderMXBean, objectName);
+    service.federate(federatedName, GatewaySenderMXBean.class, true);
-    ObjectName changedMBeanName = service.registerInternalMBean(senderMBean, senderObjectName);
-
-    service.federate(changedMBeanName, GatewaySenderMXBean.class, true);
-
-    Notification notification = new Notification(JMXNotificationType.GATEWAY_SENDER_CREATED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.GATEWAY_SENDER_CREATED_PREFIX);
-    memberLevelNotifEmitter.sendNotification(notification);
+    Notification notification = new Notification(GATEWAY_SENDER_CREATED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(), GATEWAY_SENDER_CREATED_PREFIX);
+    memberLevelNotificationEmitter.sendNotification(notification);
-   * @param recv specific gateway receiver
+   * @param gatewayReceiver specific gateway receiver
-  protected void handleGatewayReceiverCreate(GatewayReceiver recv) throws ManagementException {
+  void handleGatewayReceiverCreate(GatewayReceiver gatewayReceiver) throws ManagementException {
-    if (!recv.isManualStart()) {
+    if (!gatewayReceiver.isManualStart()) {
-    createGatewayReceiverMBean(recv);
+    createGatewayReceiverMBean(gatewayReceiver);
-  private void createGatewayReceiverMBean(GatewayReceiver recv) {
-    GatewayReceiverMBeanBridge bridge = new GatewayReceiverMBeanBridge(recv);
-
-    GatewayReceiverMXBean receiverMBean = new GatewayReceiverMBean(bridge);
-    ObjectName recvObjectName = MBeanJMXAdapter
+  private void createGatewayReceiverMBean(GatewayReceiver gatewayReceiver) {
+    GatewayReceiverMBeanBridge gatewayReceiverMBeanBridge =
+        new GatewayReceiverMBeanBridge(gatewayReceiver);
+    GatewayReceiverMXBean gatewayReceiverMXBean =
+        new GatewayReceiverMBean(gatewayReceiverMBeanBridge);
+    ObjectName objectName = MBeanJMXAdapter
+    ObjectName federatedName = service.registerInternalMBean(gatewayReceiverMXBean, objectName);
+    service.federate(federatedName, GatewayReceiverMXBean.class, true);
-    ObjectName changedMBeanName = service.registerInternalMBean(receiverMBean, recvObjectName);
-
-    service.federate(changedMBeanName, GatewayReceiverMXBean.class, true);
-
-    Notification notification = new Notification(JMXNotificationType.GATEWAY_RECEIVER_CREATED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.GATEWAY_RECEIVER_CREATED_PREFIX);
-    memberLevelNotifEmitter.sendNotification(notification);
+    Notification notification = new Notification(GATEWAY_RECEIVER_CREATED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(), GATEWAY_RECEIVER_CREATED_PREFIX);
+    memberLevelNotificationEmitter.sendNotification(notification);
-  /**
-   * Handles Gateway receiver destroy
-   *
-   * @param recv specific gateway receiver
-   */
-  protected void handleGatewayReceiverDestroy(GatewayReceiver recv) throws ManagementException {
+  void handleGatewayReceiverDestroy() throws ManagementException {
-    GatewayReceiverMBean mbean = (GatewayReceiverMBean) service.getLocalGatewayReceiverMXBean();
-    GatewayReceiverMBeanBridge bridge = mbean.getBridge();
+    GatewayReceiverMBean gatewayReceiverMBean =
+        (GatewayReceiverMBean) service.getLocalGatewayReceiverMXBean();
+    GatewayReceiverMBeanBridge gatewayReceiverMBeanBridge = gatewayReceiverMBean.getBridge();
-    bridge.destroyServer();
-    ObjectName objectName = (MBeanJMXAdapter
-        .getGatewayReceiverMBeanName(internalCache.getDistributedSystem().getDistributedMember()));
+    gatewayReceiverMBeanBridge.destroyServer();
+    ObjectName objectName = MBeanJMXAdapter
+        .getGatewayReceiverMBeanName(internalCache.getDistributedSystem().getDistributedMember());
-    Notification notification = new Notification(JMXNotificationType.GATEWAY_RECEIVER_DESTROYED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.GATEWAY_RECEIVER_DESTROYED_PREFIX);
-    memberLevelNotifEmitter.sendNotification(notification);
+
+    Notification notification = new Notification(GATEWAY_RECEIVER_DESTROYED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(), GATEWAY_RECEIVER_DESTROYED_PREFIX);
+    memberLevelNotificationEmitter.sendNotification(notification);
-   * @param recv specific gateway receiver
+   * @param gatewayReceiver specific gateway receiver
-  protected void handleGatewayReceiverStart(GatewayReceiver recv) throws ManagementException {
+  void handleGatewayReceiverStart(GatewayReceiver gatewayReceiver) throws ManagementException {
-    if (!recv.isManualStart()) {
-      createGatewayReceiverMBean(recv);
+    if (!gatewayReceiver.isManualStart()) {
+      createGatewayReceiverMBean(gatewayReceiver);
-    GatewayReceiverMBean mbean = (GatewayReceiverMBean) service.getLocalGatewayReceiverMXBean();
-    GatewayReceiverMBeanBridge bridge = mbean.getBridge();
+    GatewayReceiverMBean gatewayReceiverMBean =
+        (GatewayReceiverMBean) service.getLocalGatewayReceiverMXBean();
+    GatewayReceiverMBeanBridge gatewayReceiverMBeanBridge = gatewayReceiverMBean.getBridge();
-    bridge.startServer();
+    gatewayReceiverMBeanBridge.startServer();
-    Notification notification = new Notification(JMXNotificationType.GATEWAY_RECEIVER_STARTED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.GATEWAY_RECEIVER_STARTED_PREFIX);
-    memberLevelNotifEmitter.sendNotification(notification);
+    Notification notification = new Notification(GATEWAY_RECEIVER_STARTED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(), GATEWAY_RECEIVER_STARTED_PREFIX);
+    memberLevelNotificationEmitter.sendNotification(notification);
-  /**
-   * Handles Gateway receiver creation
-   *
-   * @param recv specific gateway receiver
-   */
-  protected void handleGatewayReceiverStop(GatewayReceiver recv) throws ManagementException {
+  void handleGatewayReceiverStop() throws ManagementException {
-    GatewayReceiverMBean mbean = (GatewayReceiverMBean) service.getLocalGatewayReceiverMXBean();
-    GatewayReceiverMBeanBridge bridge = mbean.getBridge();
-    bridge.stopServer();
+    GatewayReceiverMBean gatewayReceiverMBean =
+        (GatewayReceiverMBean) service.getLocalGatewayReceiverMXBean();
+    GatewayReceiverMBeanBridge gatewayReceiverMBeanBridge = gatewayReceiverMBean.getBridge();
-    Notification notification = new Notification(JMXNotificationType.GATEWAY_RECEIVER_STOPPED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.GATEWAY_RECEIVER_STOPPED_PREFIX);
-    memberLevelNotifEmitter.sendNotification(notification);
+    gatewayReceiverMBeanBridge.stopServer();
+
+    Notification notification = new Notification(GATEWAY_RECEIVER_STOPPED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(), GATEWAY_RECEIVER_STOPPED_PREFIX);
+    memberLevelNotificationEmitter.sendNotification(notification);
-  protected void handleAsyncEventQueueCreation(AsyncEventQueue queue) throws ManagementException {
+  void handleAsyncEventQueueCreation(AsyncEventQueue asyncEventQueue) throws ManagementException {
-    AsyncEventQueueMBeanBridge bridge = new AsyncEventQueueMBeanBridge(queue);
-    AsyncEventQueueMXBean queueMBean = new AsyncEventQueueMBean(bridge);
-    ObjectName senderObjectName = MBeanJMXAdapter.getAsyncEventQueueMBeanName(
-        internalCache.getDistributedSystem().getDistributedMember(), queue.getId());
-    ObjectName changedMBeanName = service.registerInternalMBean(queueMBean, senderObjectName);
+    AsyncEventQueueMBeanBridge asyncEventQueueMBeanBridge =
+        new AsyncEventQueueMBeanBridge(asyncEventQueue);
+    AsyncEventQueueMXBean asyncEventQueueMXBean =
+        new AsyncEventQueueMBean(asyncEventQueueMBeanBridge);
+    ObjectName objectName = MBeanJMXAdapter.getAsyncEventQueueMBeanName(
+        internalCache.getDistributedSystem().getDistributedMember(), asyncEventQueue.getId());
+    ObjectName federatedName = service.registerInternalMBean(asyncEventQueueMXBean, objectName);
+    service.federate(federatedName, AsyncEventQueueMXBean.class, true);
-    service.federate(changedMBeanName, AsyncEventQueueMXBean.class, true);
-
-    Notification notification = new Notification(JMXNotificationType.ASYNC_EVENT_QUEUE_CREATED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.ASYNC_EVENT_QUEUE_CREATED_PREFIX);
-    memberLevelNotifEmitter.sendNotification(notification);
+    Notification notification = new Notification(ASYNC_EVENT_QUEUE_CREATED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(), ASYNC_EVENT_QUEUE_CREATED_PREFIX);
+    memberLevelNotificationEmitter.sendNotification(notification);
-  /**
-   * Handles AsyncEventQueue Removal
-   *
-   * @param queue The AsyncEventQueue being removed
-   */
-  protected void handleAsyncEventQueueRemoval(AsyncEventQueue queue) throws ManagementException {
+  void handleAsyncEventQueueRemoval(AsyncEventQueue asyncEventQueue) throws ManagementException {
-    ObjectName asycnEventQueueMBeanName = MBeanJMXAdapter.getAsyncEventQueueMBeanName(
-        internalCache.getDistributedSystem().getDistributedMember(), queue.getId());
-    AsyncEventQueueMBean bean;
+    ObjectName objectName = MBeanJMXAdapter.getAsyncEventQueueMBeanName(
+        internalCache.getDistributedSystem().getDistributedMember(), asyncEventQueue.getId());
+
-      bean = (AsyncEventQueueMBean) service.getLocalAsyncEventQueueMXBean(queue.getId());
-      if (bean == null) {
+      AsyncEventQueueMBean asyncEventQueueMBean =
+          (AsyncEventQueueMBean) service.getLocalAsyncEventQueueMXBean(asyncEventQueue.getId());
+      if (asyncEventQueueMBean == null) {
+
+      asyncEventQueueMBean.stopMonitor();
+
-    bean.stopMonitor();
+    service.unregisterMBean(objectName);
-    service.unregisterMBean(asycnEventQueueMBeanName);
-
-    Notification notification = new Notification(JMXNotificationType.ASYNC_EVENT_QUEUE_CLOSED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.ASYNC_EVENT_QUEUE_CLOSED_PREFIX + queue.getId());
-    memberLevelNotifEmitter.sendNotification(notification);
+    Notification notification = new Notification(ASYNC_EVENT_QUEUE_CLOSED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(),
+        ASYNC_EVENT_QUEUE_CLOSED_PREFIX + asyncEventQueue.getId());
+    memberLevelNotificationEmitter.sendNotification(notification);
-   *
-  protected void handleSystemNotification(AlertDetails details) {
+  void handleSystemNotification(AlertDetails alertDetails) {
+
-      Map<String, String> userData = prepareUserData(details);
-
-
-      Notification notification = new Notification(JMXNotificationType.SYSTEM_ALERT, systemSource,
-          SequenceNumber.next(), details.getMsgTime().getTime(), details.getMsg());
-
-      notification.setUserData(userData);
+      Notification notification = new Notification(SYSTEM_ALERT, systemSource,
+          SequenceNumber.next(), alertDetails.getMsgTime().getTime(), alertDetails.getMsg());
+      notification.setUserData(prepareUserData(alertDetails));
-  private Map<String, String> prepareUserData(AlertDetails details) {
+  private Map<String, String> prepareUserData(AlertDetails alertDetails) {
-    userData.put(JMXNotificationUserData.ALERT_LEVEL,
-        AlertDetails.getAlertLevelAsString(details.getAlertLevel()));
-    String source = details.getSource();
-    userData.put(JMXNotificationUserData.THREAD, source);
-
-    InternalDistributedMember sender = details.getSender();
-    String nameOrId = memberSource;
-    if (sender != null) {
-      nameOrId = sender.getName();
-      nameOrId = StringUtils.isNotBlank(nameOrId) ? nameOrId : sender.getId();
-    }
-
-    userData.put(JMXNotificationUserData.MEMBER, nameOrId);
+    userData.put(ALERT_LEVEL, getAlertLevelAsString(alertDetails.getAlertLevel()));
+    userData.put(THREAD, alertDetails.getSource());
+    userData.put(MEMBER, getNameOrId(alertDetails.getSender()));
-  protected void handleCacheServerStart(CacheServer cacheServer) {
+  void handleCacheServerStart(CacheServer cacheServer) {
-
-
-    ObjectName cacheServerMBeanName = MBeanJMXAdapter.getClientServiceMBeanName(
+    ObjectName objectName = MBeanJMXAdapter.getClientServiceMBeanName(
-
-    ObjectName changedMBeanName =
-        service.registerInternalMBean(cacheServerMBean, cacheServerMBeanName);
+    ObjectName federatedName = service.registerInternalMBean(cacheServerMBean, objectName);
-        cacheServerMBean, memberLevelNotifEmitter, changedMBeanName);
+        cacheServerMBean, memberLevelNotificationEmitter, federatedName);
-
-    service.federate(changedMBeanName, CacheServerMXBean.class, true);
+    service.federate(federatedName, CacheServerMXBean.class, true);
-    Notification notification = new Notification(JMXNotificationType.CACHE_SERVER_STARTED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.CACHE_SERVER_STARTED_PREFIX);
-
-    memberLevelNotifEmitter.sendNotification(notification);
+    Notification notification = new Notification(CACHE_SERVER_STARTED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(), CACHE_SERVER_STARTED_PREFIX);
+    memberLevelNotificationEmitter.sendNotification(notification);
-   *
-   * @param server cache server instance
-  protected void handleCacheServerStop(CacheServer server) {
+  void handleCacheServerStop(CacheServer server) {
-    CacheServerMBean mbean = (CacheServerMBean) service.getLocalCacheServerMXBean(server.getPort());
+    CacheServerMBean cacheServerMBean =
+        (CacheServerMBean) service.getLocalCacheServerMXBean(server.getPort());
-    ClientMembershipListener listener = mbean.getBridge().getClientMembershipListener();
-
-    if (listener != null) {
-      ClientMembership.unregisterClientMembershipListener(listener);
+    ClientMembershipListener clientMembershipListener =
+        cacheServerMBean.getBridge().getClientMembershipListener();
+    if (clientMembershipListener != null) {
+      ClientMembership.unregisterClientMembershipListener(clientMembershipListener);
-    mbean.stopMonitor();
+    cacheServerMBean.stopMonitor();
-    ObjectName cacheServerMBeanName = MBeanJMXAdapter.getClientServiceMBeanName(server.getPort(),
+    ObjectName objectName = MBeanJMXAdapter.getClientServiceMBeanName(server.getPort(),
-    service.unregisterMBean(cacheServerMBeanName);
+    service.unregisterMBean(objectName);
-    Notification notification = new Notification(JMXNotificationType.CACHE_SERVER_STOPPED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.CACHE_SERVER_STOPPED_PREFIX);
-
-    memberLevelNotifEmitter.sendNotification(notification);
+    Notification notification = new Notification(CACHE_SERVER_STOPPED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(), CACHE_SERVER_STOPPED_PREFIX);
+    memberLevelNotificationEmitter.sendNotification(notification);
-  /**
-   * Handles Cache removal. It will automatically remove all MBeans from GemFire Domain
-   *
-   * @param cache GemFire Cache instance. For now client cache is not supported
-   */
-  protected void handleCacheRemoval(Cache cache) throws ManagementException {
+  void handleCacheRemoval() throws ManagementException {
-    this.serviceInitialised = false;
+    serviceInitialised = false;
-      this.internalCache = null;
-      this.service = null;
-      this.memberMBeanBridge = null;
-      this.memberBean = null;
-      this.memberLevelNotifEmitter = null;
+      internalCache = null;
+      service = null;
+      memberMBeanBridge = null;
+      memberBean = null;
+      memberLevelNotificationEmitter = null;
+  private String getNameOrId(DistributedMember member) {
+    if (member == null) {
+      return memberSource;
+    }
+    return isNotBlank(member.getName()) ? member.getName() : member.getId();
+  }
+
-    MemberMBean bean = (MemberMBean) service.getMemberMXBean();
-    if (bean != null) {
-      bean.stopMonitor();
+    MemberMBean memberMBean = (MemberMBean) service.getMemberMXBean();
+    if (memberMBean != null) {
+      memberMBean.stopMonitor();
-    Set<GatewaySender> senders = internalCache.getGatewaySenders();
+    Set<GatewaySender> gatewaySenders = internalCache.getGatewaySenders();
-    if (senders != null && senders.size() > 0) {
-      for (GatewaySender sender : senders) {
-        GatewaySenderMBean senderMBean =
-            (GatewaySenderMBean) service.getLocalGatewaySenderMXBean(sender.getId());
-        if (senderMBean != null) {
-          senderMBean.stopMonitor();
+    if (gatewaySenders != null && !gatewaySenders.isEmpty()) {
+      for (GatewaySender gatewaySender : gatewaySenders) {
+        GatewaySenderMBean gatewaySenderMBean =
+            (GatewaySenderMBean) service.getLocalGatewaySenderMXBean(gatewaySender.getId());
+        if (gatewaySenderMBean != null) {
+          gatewaySenderMBean.stopMonitor();
-    GatewayReceiverMBean receiver = (GatewayReceiverMBean) service.getLocalGatewayReceiverMXBean();
-    if (receiver != null) {
-      receiver.stopMonitor();
+    GatewayReceiverMBean gatewayReceiverMBean =
+        (GatewayReceiverMBean) service.getLocalGatewayReceiverMXBean();
+    if (gatewayReceiverMBean != null) {
+      gatewayReceiverMBean.stopMonitor();
-    List<CacheServer> servers = internalCache.getCacheServers();
+    List<CacheServer> cacheServers = internalCache.getCacheServers();
-    if (servers != null && servers.size() > 0) {
-      for (CacheServer server : servers) {
-        CacheServerMBean mbean =
-            (CacheServerMBean) service.getLocalCacheServerMXBean(server.getPort());
+    if (cacheServers != null && !cacheServers.isEmpty()) {
+      for (CacheServer cacheServer : cacheServers) {
+        CacheServerMBean cacheServerMBean =
+            (CacheServerMBean) service.getLocalCacheServerMXBean(cacheServer.getPort());
-        if (mbean != null) {
-          ClientMembershipListener listener = mbean.getBridge().getClientMembershipListener();
+        if (cacheServerMBean != null) {
+          ClientMembershipListener listener =
+              cacheServerMBean.getBridge().getClientMembershipListener();
-   *
-  protected void handleRegionRemoval(Region region) throws ManagementException {
+  void handleRegionRemoval(Region region) throws ManagementException {
-    /*
-     * Moved region remove operation to a guarded block. If a region is getting created it wont
-     * allow it to destroy any region.
-     */
+
+    // Moved region remove operation to a guarded block. If a region is getting created it won't
+    // allow it to destroy any region.
-      ObjectName regionMBeanName = MBeanJMXAdapter.getRegionMBeanName(
+      ObjectName objectName = MBeanJMXAdapter.getRegionMBeanName(
-      RegionMBean bean;
+
-        bean = (RegionMBean) service.getLocalRegionMBean(region.getFullPath());
+        RegionMBean regionMBean = (RegionMBean) service.getLocalRegionMBean(region.getFullPath());
+        if (regionMBean != null) {
+          regionMBean.stopMonitor();
+        }
-      if (bean != null) {
-        bean.stopMonitor();
-      }
-      service.unregisterMBean(regionMBeanName);
+      service.unregisterMBean(objectName);
-      Notification notification = new Notification(JMXNotificationType.REGION_CLOSED, memberSource,
+      Notification notification = new Notification(REGION_CLOSED, memberSource,
-          ManagementConstants.REGION_CLOSED_PREFIX + region.getFullPath());
-      memberLevelNotifEmitter.sendNotification(notification);
+          REGION_CLOSED_PREFIX + region.getFullPath());
+      memberLevelNotificationEmitter.sendNotification(notification);
+
-  /**
-   * Handles DiskStore Removal
-   *
-   */
-  protected void handleDiskRemoval(DiskStore disk) throws ManagementException {
+  void handleDiskRemoval(DiskStore diskStore) throws ManagementException {
-    ObjectName diskStoreMBeanName = MBeanJMXAdapter.getDiskStoreMBeanName(
-        internalCache.getDistributedSystem().getDistributedMember(), disk.getName());
+    ObjectName objectName = MBeanJMXAdapter.getDiskStoreMBeanName(
+        internalCache.getDistributedSystem().getDistributedMember(), diskStore.getName());
-    DiskStoreMBean bean;
-      bean = (DiskStoreMBean) service.getLocalDiskStoreMBean(disk.getName());
-      if (bean == null) {
+      DiskStoreMBean diskStoreMBean =
+          (DiskStoreMBean) service.getLocalDiskStoreMBean(diskStore.getName());
+      if (diskStoreMBean == null) {
+      diskStoreMBean.stopMonitor();
-    bean.stopMonitor();
+    service.unregisterMBean(objectName);
-    service.unregisterMBean(diskStoreMBeanName);
+    Notification notification = new Notification(DISK_STORE_CLOSED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(),
+        DISK_STORE_CLOSED_PREFIX + diskStore.getName());
+    memberLevelNotificationEmitter.sendNotification(notification);
-    Notification notification = new Notification(JMXNotificationType.DISK_STORE_CLOSED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.DISK_STORE_CLOSED_PREFIX + disk.getName());
-    memberLevelNotifEmitter.sendNotification(notification);
-    memberMBeanBridge.removeDiskStore(disk);
+    memberMBeanBridge.removeDiskStore(diskStore);
-  /**
-   * Handles Lock Service Removal
-   *
-   * @param lockService lock service instance
-   */
-  protected void handleLockServiceRemoval(DLockService lockService) throws ManagementException {
+  void handleLockServiceRemoval(DLockService lockService) throws ManagementException {
-    ObjectName lockServiceMBeanName = MBeanJMXAdapter.getLockServiceMBeanName(
+    ObjectName objectName = MBeanJMXAdapter.getLockServiceMBeanName(
-    LockServiceMXBean bean = service.getLocalLockServiceMBean(lockService.getName());
+    service.unregisterMBean(objectName);
-    service.unregisterMBean(lockServiceMBeanName);
-
-    Notification notification = new Notification(JMXNotificationType.LOCK_SERVICE_CLOSED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.LOCK_SERVICE_CLOSED_PREFIX + lockService.getName());
-    memberLevelNotifEmitter.sendNotification(notification);
+    Notification notification = new Notification(LOCK_SERVICE_CLOSED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(),
+        LOCK_SERVICE_CLOSED_PREFIX + lockService.getName());
+    memberLevelNotificationEmitter.sendNotification(notification);
+   * <p>
-  protected void handleLocatorStart(Locator locator) throws ManagementException {
+  void handleLocatorStart(Locator locator) throws ManagementException {
-    ObjectName locatorMBeanName = MBeanJMXAdapter
+    ObjectName objectName = MBeanJMXAdapter
+    LocatorMBeanBridge locatorMBeanBridge = new LocatorMBeanBridge(locator);
+    LocatorMBean locatorMBean = new LocatorMBean(locatorMBeanBridge);
+    ObjectName federatedName = service.registerInternalMBean(locatorMBean, objectName);
+    service.federate(federatedName, LocatorMXBean.class, true);
-    LocatorMBeanBridge bridge = new LocatorMBeanBridge(locator);
-    LocatorMBean locatorMBean = new LocatorMBean(bridge);
-
-    ObjectName changedMBeanName = service.registerInternalMBean(locatorMBean, locatorMBeanName);
-
-    service.federate(changedMBeanName, LocatorMXBean.class, true);
-
-    Notification notification =
-        new Notification(JMXNotificationType.LOCATOR_STARTED, memberSource, SequenceNumber.next(),
-            System.currentTimeMillis(), ManagementConstants.LOCATOR_STARTED_PREFIX);
-
-    memberLevelNotifEmitter.sendNotification(notification);
-
+    Notification notification = new Notification(LOCATOR_STARTED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(), LOCATOR_STARTED_PREFIX);
+    memberLevelNotificationEmitter.sendNotification(notification);
-  protected void handleGatewaySenderStart(GatewaySender sender) throws ManagementException {
+  void handleGatewaySenderStart(GatewaySender gatewaySender) throws ManagementException {
-    if ((sender.getRemoteDSId() < 0)) {
+    if (gatewaySender.getRemoteDSId() < 0) {
-    GatewaySenderMBean bean =
-        (GatewaySenderMBean) service.getLocalGatewaySenderMXBean(sender.getId());
-    bean.getBridge().setDispatcher();
+    GatewaySenderMBean gatewaySenderMBean =
+        (GatewaySenderMBean) service.getLocalGatewaySenderMXBean(gatewaySender.getId());
-    Notification notification = new Notification(JMXNotificationType.GATEWAY_SENDER_STARTED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.GATEWAY_SENDER_STARTED_PREFIX + sender.getId());
+    gatewaySenderMBean.getBridge().setDispatcher();
-    memberLevelNotifEmitter.sendNotification(notification);
+    Notification notification = new Notification(GATEWAY_SENDER_STARTED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(),
+        GATEWAY_SENDER_STARTED_PREFIX + gatewaySender.getId());
+    memberLevelNotificationEmitter.sendNotification(notification);
-  protected void handleGatewaySenderStop(GatewaySender sender) throws ManagementException {
+  void handleGatewaySenderStop(GatewaySender gatewaySender) throws ManagementException {
-    Notification notification = new Notification(JMXNotificationType.GATEWAY_SENDER_STOPPED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.GATEWAY_SENDER_STOPPED_PREFIX + sender.getId());
-
-    memberLevelNotifEmitter.sendNotification(notification);
+    Notification notification = new Notification(GATEWAY_SENDER_STOPPED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(),
+        GATEWAY_SENDER_STOPPED_PREFIX + gatewaySender.getId());
+    memberLevelNotificationEmitter.sendNotification(notification);
-  protected void handleGatewaySenderPaused(GatewaySender sender) throws ManagementException {
+  void handleGatewaySenderPaused(GatewaySender gatewaySender) throws ManagementException {
-    Notification notification = new Notification(JMXNotificationType.GATEWAY_SENDER_PAUSED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.GATEWAY_SENDER_PAUSED_PREFIX + sender.getId());
-
-    memberLevelNotifEmitter.sendNotification(notification);
+    Notification notification = new Notification(GATEWAY_SENDER_PAUSED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(),
+        GATEWAY_SENDER_PAUSED_PREFIX + gatewaySender.getId());
+    memberLevelNotificationEmitter.sendNotification(notification);
-  protected void handleGatewaySenderResumed(GatewaySender sender) throws ManagementException {
+  void handleGatewaySenderResumed(GatewaySender gatewaySender) throws ManagementException {
-    Notification notification = new Notification(JMXNotificationType.GATEWAY_SENDER_RESUMED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.GATEWAY_SENDER_RESUMED_PREFIX + sender.getId());
-
-    memberLevelNotifEmitter.sendNotification(notification);
+    Notification notification = new Notification(GATEWAY_SENDER_RESUMED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(),
+        GATEWAY_SENDER_RESUMED_PREFIX + gatewaySender.getId());
+    memberLevelNotificationEmitter.sendNotification(notification);
-  protected void handleGatewaySenderRemoved(GatewaySender sender) throws ManagementException {
+  void handleGatewaySenderRemoved(GatewaySender gatewaySender) throws ManagementException {
-    if ((sender.getRemoteDSId() < 0)) {
+    if (gatewaySender.getRemoteDSId() < 0) {
-    GatewaySenderMBean bean =
-        (GatewaySenderMBean) service.getLocalGatewaySenderMXBean(sender.getId());
-    bean.stopMonitor();
+    GatewaySenderMBean gatewaySenderMBean =
+        (GatewaySenderMBean) service.getLocalGatewaySenderMXBean(gatewaySender.getId());
+    gatewaySenderMBean.stopMonitor();
-    ObjectName gatewaySenderName = MBeanJMXAdapter.getGatewaySenderMBeanName(
-        internalCache.getDistributedSystem().getDistributedMember(), sender.getId());
-    service.unregisterMBean(gatewaySenderName);
+    ObjectName objectName = MBeanJMXAdapter.getGatewaySenderMBeanName(
+        internalCache.getDistributedSystem().getDistributedMember(), gatewaySender.getId());
+    service.unregisterMBean(objectName);
-    Notification notification = new Notification(JMXNotificationType.GATEWAY_SENDER_REMOVED,
-        memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-        ManagementConstants.GATEWAY_SENDER_REMOVED_PREFIX + sender.getId());
-    memberLevelNotifEmitter.sendNotification(notification);
+    Notification notification = new Notification(GATEWAY_SENDER_REMOVED, memberSource,
+        SequenceNumber.next(), System.currentTimeMillis(),
+        GATEWAY_SENDER_REMOVED_PREFIX + gatewaySender.getId());
+    memberLevelNotificationEmitter.sendNotification(notification);
-  protected void handleCacheServiceCreation(CacheService cacheService) throws ManagementException {
+  void handleCacheServiceCreation(CacheService cacheService) throws ManagementException {
+
-    CacheServiceMBeanBase mbean = cacheService.getMBean();
-    if (mbean != null) {
-      String id = mbean.getId();
-      ObjectName cacheServiceObjectName = MBeanJMXAdapter.getCacheServiceMBeanName(member, id);
-      ObjectName changedMBeanName = service.registerInternalMBean(mbean, cacheServiceObjectName);
+    CacheServiceMBeanBase cacheServiceMBean = cacheService.getMBean();
+    if (cacheServiceMBean != null) {
+      String id = cacheServiceMBean.getId();
+      ObjectName objectName = MBeanJMXAdapter.getCacheServiceMBeanName(member, id);
+      ObjectName federatedName = service.registerInternalMBean(cacheServiceMBean, objectName);
+      service.federate(federatedName, cacheServiceMBean.getInterfaceClass(), true);
-      service.federate(changedMBeanName, mbean.getInterfaceClass(), true);
-
-      Notification notification = new Notification(JMXNotificationType.CACHE_SERVICE_CREATED,
-          memberSource, SequenceNumber.next(), System.currentTimeMillis(),
-          ManagementConstants.CACHE_SERVICE_CREATED_PREFIX + id);
-      memberLevelNotifEmitter.sendNotification(notification);
+      Notification notification = new Notification(CACHE_SERVICE_CREATED, memberSource,
+          SequenceNumber.next(), System.currentTimeMillis(),
+          CACHE_SERVICE_CREATED_PREFIX + id);
+      memberLevelNotificationEmitter.sendNotification(notification);
+  private ObjectName aggregateMBeanPattern() {
+    try {
+      return new ObjectName(AGGREGATE_MBEAN_PATTERN);
+    } catch (MalformedObjectNameException | NullPointerException e) {
+      throw new ManagementException(e);
+    }
+  }
+
+  private boolean isServiceInitialised(String method) {
+    if (!serviceInitialised) {
+      if (logger.isDebugEnabled()) {
+        logger.debug("Management Service is not initialised hence returning from {}", method);
+      }
+    }
+
+    return serviceInitialised;
+  }
+
-   * Private class which acts as a ClientMembershipListener to propagate client joined/left
-   * notifications
+   * Propagates client joined/left notifications
-    private NotificationBroadcasterSupport serverLevelNotifEmitter;
-    private NotificationBroadcasterSupport memberLevelNotifEmitter;
+    private final NotificationBroadcasterSupport serverLevelNotificationEmitter;
+    private final NotificationBroadcasterSupport memberLevelNotificationEmitter;
+    private final String serverSource;
-    private String serverSource;
-
-    public CacheServerMembershipListenerAdapter(
-        NotificationBroadcasterSupport serverLevelNotifEmitter,
-        NotificationBroadcasterSupport memberLevelNotifEmitter, ObjectName serverSource) {
-      this.serverLevelNotifEmitter = serverLevelNotifEmitter;
-      this.memberLevelNotifEmitter = memberLevelNotifEmitter;
+    private CacheServerMembershipListenerAdapter(
+        NotificationBroadcasterSupport serverLevelNotificationEmitter,
+        NotificationBroadcasterSupport memberLevelNotificationEmitter,
+        ObjectName serverSource) {
+      this.serverLevelNotificationEmitter = serverLevelNotificationEmitter;
+      this.memberLevelNotificationEmitter = memberLevelNotificationEmitter;
-      Notification notification = new Notification(JMXNotificationType.CLIENT_JOINED, serverSource,
+      Notification notification = new Notification(CLIENT_JOINED, serverSource,
-          ManagementConstants.CLIENT_JOINED_PREFIX + event.getMemberId());
-      serverLevelNotifEmitter.sendNotification(notification);
-      memberLevelNotifEmitter.sendNotification(notification);
+          CLIENT_JOINED_PREFIX + event.getMemberId());
+
+      serverLevelNotificationEmitter.sendNotification(notification);
+      memberLevelNotificationEmitter.sendNotification(notification);
-      Notification notification = new Notification(JMXNotificationType.CLIENT_LEFT, serverSource,
+      Notification notification = new Notification(CLIENT_LEFT, serverSource,
-          ManagementConstants.CLIENT_LEFT_PREFIX + event.getMemberId());
-      serverLevelNotifEmitter.sendNotification(notification);
-      memberLevelNotifEmitter.sendNotification(notification);
+          CLIENT_LEFT_PREFIX + event.getMemberId());
+
+      serverLevelNotificationEmitter.sendNotification(notification);
+      memberLevelNotificationEmitter.sendNotification(notification);
-      Notification notification = new Notification(JMXNotificationType.CLIENT_CRASHED, serverSource,
+      Notification notification = new Notification(CLIENT_CRASHED, serverSource,
-          ManagementConstants.CLIENT_CRASHED_PREFIX + event.getMemberId());
-      serverLevelNotifEmitter.sendNotification(notification);
-      memberLevelNotifEmitter.sendNotification(notification);
+          CLIENT_CRASHED_PREFIX + event.getMemberId());
+
+      serverLevelNotificationEmitter.sendNotification(notification);
+      memberLevelNotificationEmitter.sendNotification(notification);
-
-
-  private boolean isServiceInitialised(String method) {
-    if (!serviceInitialised) {
-      if (logger.isDebugEnabled()) {
-        logger.debug("Management Service is not initialised hence returning from {}", method);
-      }
-      return false;
-    }
-
-    return true;
-  }
-

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV23 MOV23 MOV23 MOV23 MOV23 MOV31 MOV55 UPD40 UPD40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 UPD40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS31 INS31 INS31 MOV31 MOV31 MOV78 UPD83 MOV74 UPD83 MOV43 UPD83 MOV43 UPD83 UPD83 UPD83 INS39 MOV60 MOV60 MOV60 MOV60 INS44 MOV44 UPD42 MOV44 MOV43 UPD42 MOV43 MOV44 MOV44 MOV44 MOV83 MOV74 MOV42 MOV44 INS8 INS83 MOV43 INS42 INS44 INS8 INS83 INS43 INS42 INS8 MOV44 INS66 UPD42 INS32 UPD42 INS32 UPD42 UPD42 INS60 UPD42 MOV43 INS42 UPD42 INS60 MOV65 UPD42 MOV25 MOV60 UPD42 MOV60 MOV60 UPD42 MOV60 MOV60 UPD42 UPD42 MOV60 MOV21 INS21 INS21 MOV41 INS60 MOV60 INS43 INS42 INS25 INS41 UPD42 MOV60 MOV60 MOV60 UPD42 MOV60 UPD42 UPD42 MOV60 UPD42 MOV60 UPD42 INS60 INS21 INS60 INS42 MOV54 INS83 MOV43 INS83 INS83 UPD83 MOV29 MOV78 UPD42 MOV44 MOV29 MOV78 UPD42 MOV44 INS42 INS32 INS42 INS42 UPD66 MOV43 INS59 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 UPD42 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 INS59 UPD42 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 INS32 INS32 MOV43 INS59 MOV43 INS42 UPD27 MOV27 INS8 INS16 MOV43 MOV43 MOV43 MOV43 INS66 MOV43 MOV43 MOV43 INS27 MOV8 MOV43 MOV43 MOV43 MOV43 INS27 MOV8 MOV43 MOV43 INS59 INS32 MOV43 INS59 INS42 UPD66 UPD42 UPD42 UPD42 UPD42 MOV60 INS42 INS40 INS40 INS40 INS40 INS21 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS32 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 INS42 INS14 UPD42 INS21 UPD42 UPD42 UPD42 UPD42 UPD42 MOV41 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS60 INS21 UPD42 UPD42 UPD42 MOV42 INS32 INS42 INS42 INS42 INS32 MOV42 MOV42 UPD42 MOV42 INS32 UPD42 UPD42 UPD42 INS42 INS14 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 INS41 INS32 MOV32 MOV32 UPD42 UPD42 UPD42 INS38 UPD42 UPD42 UPD42 INS38 MOV60 UPD42 INS60 INS21 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 MOV34 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 MOV34 UPD42 UPD42 INS42 MOV32 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS14 UPD42 UPD42 UPD42 MOV60 INS41 MOV43 MOV43 INS7 MOV43 MOV43 UPD42 INS42 UPD42 MOV43 MOV43 MOV43 MOV43 UPD42 UPD42 UPD42 UPD42 MOV43 INS42 UPD42 UPD42 UPD42 MOV43 INS42 UPD42 UPD42 UPD42 MOV43 INS42 INS42 UPD42 MOV43 UPD42 UPD42 UPD42 UPD42 MOV43 INS42 INS42 UPD42 MOV43 INS42 INS42 MOV32 MOV32 INS42 INS42 UPD42 INS32 UPD42 MOV43 INS42 INS42 UPD42 MOV45 UPD42 MOV43 INS42 INS42 MOV43 UPD42 MOV43 UPD42 UPD42 UPD42 MOV43 INS42 INS42 MOV43 INS59 INS32 MOV43 INS42 INS27 MOV43 MOV42 MOV32 UPD42 MOV42 MOV42 INS42 INS32 UPD42 UPD42 UPD42 MOV43 INS42 INS42 MOV32 MOV32 INS42 MOV43 INS42 INS42 INS42 INS42 INS32 UPD42 UPD42 UPD42 UPD42 INS32 UPD42 UPD42 INS32 UPD42 MOV43 MOV43 MOV43 INS59 MOV8 INS32 MOV43 INS42 MOV43 INS42 MOV27 MOV43 UPD42 UPD42 MOV43 INS42 INS42 UPD42 MOV43 UPD42 MOV43 INS42 INS27 MOV43 INS42 MOV32 MOV32 INS42 INS27 MOV43 INS42 UPD42 MOV43 INS42 INS32 MOV43 INS42 INS42 MOV32 MOV32 INS27 MOV43 INS14 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 UPD42 UPD42 UPD42 INS42 INS60 UPD42 INS60 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 INS11 UPD42 INS42 INS42 INS42 INS32 INS32 UPD42 UPD42 MOV42 MOV42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 MOV42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS60 INS25 UPD42 UPD42 UPD42 INS42 INS11 UPD42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 UPD42 MOV42 INS42 INS32 UPD42 UPD42 UPD42 UPD42 MOV43 INS42 UPD42 UPD42 INS42 UPD42 MOV43 INS42 MOV43 INS42 INS42 INS42 INS32 UPD42 MOV43 INS59 UPD42 MOV43 INS59 UPD42 UPD42 UPD42 UPD42 MOV43 INS42 UPD42 MOV43 MOV32 INS42 INS42 MOV43 INS42 MOV32 UPD42 MOV42 INS42 MOV43 INS43 INS59 MOV43 INS59 INS27 INS8 MOV43 INS42 INS27 MOV43 MOV32 UPD42 UPD42 UPD42 INS42 INS42 UPD42 INS42 INS42 UPD42 UPD42 UPD42 MOV42 MOV42 UPD42 UPD42 UPD42 UPD42 MOV43 INS42 UPD42 INS42 MOV32 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV32 INS42 INS42 MOV32 UPD42 UPD42 UPD42 UPD42 INS42 MOV32 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 MOV42 INS42 INS11 UPD42 INS42 MOV11 INS42 INS33 MOV21 INS42 INS32 INS42 INS42 UPD42 MOV43 UPD42 MOV43 UPD42 UPD42 MOV43 MOV43 MOV32 INS32 INS42 INS42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 MOV43 UPD42 MOV43 UPD42 UPD42 UPD42 UPD42 DEL66 DEL65 DEL29 DEL42 DEL78 DEL40 DEL39 DEL9 DEL66 DEL65 DEL29 DEL66 DEL65 DEL29 DEL66 DEL65 DEL29 DEL42 DEL78 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL66 DEL65 DEL29 DEL83 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL42 DEL78 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL32 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL40 DEL40 DEL40 DEL40 DEL32 DEL32 DEL7 DEL21 DEL8 DEL28 DEL83 DEL42 DEL66 DEL65 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL42 DEL59 DEL60 DEL42 DEL7 DEL21 DEL83 DEL42 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL40 DEL40 DEL42 DEL66 DEL65 DEL83 DEL40 DEL40 DEL83 DEL40 DEL40 DEL83 DEL40 DEL40 DEL83 DEL42 DEL44 DEL40 DEL40 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL36 DEL66 DEL65 DEL83 DEL42 DEL43 DEL42 DEL44 DEL40 DEL40 DEL42 DEL66 DEL65 DEL29 DEL83 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL40 DEL40 DEL83 DEL40 DEL40 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL59 DEL60 DEL42 DEL11 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL40 DEL40 DEL42 DEL40 DEL42 DEL40 DEL42 DEL42 DEL32 DEL27 DEL14 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL40 DEL32 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL40 DEL32 DEL21 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL59 DEL60 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL16 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL40 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL42 DEL66 DEL65 DEL83 DEL40 DEL40 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL34 DEL27 DEL32 DEL34 DEL27 DEL42 DEL43 DEL11 DEL59 DEL83 DEL42 DEL59 DEL60 DEL42 DEL7 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL40 DEL40 DEL66 DEL65 DEL29 DEL83 DEL42 DEL59 DEL60 DEL42 DEL11 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL40 DEL40 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL40 DEL40 DEL40 DEL42 DEL42 DEL32 DEL27 DEL83 DEL40 DEL40 DEL42 DEL42 DEL32 DEL27 DEL83 DEL27 DEL36 DEL40 DEL83 DEL40 DEL40 DEL83 DEL40 DEL40 DEL42 DEL40 DEL42 DEL40 DEL42 DEL42 DEL32 DEL27 DEL14 DEL59 DEL60 DEL83 DEL40 DEL40 DEL83 DEL27 DEL36 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL83 DEL40 DEL40 DEL42 DEL42 DEL32 DEL42 DEL40 DEL14 DEL7 DEL21 DEL9 DEL41 DEL9 DEL66 DEL40 DEL40 DEL42 DEL42 DEL40 DEL42 DEL40 DEL27 DEL14 DEL59 DEL60 DEL40 DEL40 DEL40 DEL40
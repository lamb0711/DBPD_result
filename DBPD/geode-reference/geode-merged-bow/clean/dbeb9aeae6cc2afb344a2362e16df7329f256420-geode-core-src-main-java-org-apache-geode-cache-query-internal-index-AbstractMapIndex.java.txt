Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public abstract class AbstractMapIndex extends AbstractIndex
-{
+public abstract class AbstractMapIndex extends AbstractIndex {
-    
-  AbstractMapIndex(String indexName, Region region, String fromClause,
-      String indexedExpression, String projectionAttributes,
-      String origFromClause, String origIndxExpr, String[] defintions,
-      boolean isAllKeys, String[] multiIndexingKeysPattern, Object[] mapKeys, IndexStatistics stats) {
-    super(indexName, region, fromClause, indexedExpression,
-        projectionAttributes, origFromClause, origIndxExpr, defintions, stats);
+
+  AbstractMapIndex(String indexName, Region region, String fromClause, String indexedExpression,
+      String projectionAttributes, String origFromClause, String origIndxExpr, String[] defintions,
+      boolean isAllKeys, String[] multiIndexingKeysPattern, Object[] mapKeys,
+      IndexStatistics stats) {
+    super(indexName, region, fromClause, indexedExpression, projectionAttributes, origFromClause,
+        origIndxExpr, defintions, stats);
-      this.patternStr = new String[] { new StringBuilder(indexedExpression)
-          .deleteCharAt(indexedExpression.length() - 2).toString() };
+      this.patternStr = new String[] {new StringBuilder(indexedExpression)
+          .deleteCharAt(indexedExpression.length() - 2).toString()};
-    }
-    else {
+    } else {
-  void addMapping(RegionEntry entry) throws IMQException
-  {
+  void addMapping(RegionEntry entry) throws IMQException {
-      return new InternalIndexStatistics() {
-      };
+      return new InternalIndexStatistics() {};
-      this.vsdStats = new IndexStats(getRegion().getCache()
-          .getDistributedSystem(), indexName);
+      this.vsdStats = new IndexStats(getRegion().getCache().getDistributedSystem(), indexName);
-     * Returns the total amount of time (in nanoseconds) spent updating this
-     * index.
+     * Returns the total amount of time (in nanoseconds) spent updating this index.
-     * Returns the total number of times this index has been accessed by a
-     * query.
+     * Returns the total number of times this index has been accessed by a query.
-     * Returns the number of keys in this index
-     * at the highest level
+     * Returns the number of keys in this index at the highest level
-      for (Object ind : mapKeyToValueIndex.values()) { 
-        numValues += ((AbstractIndex)ind).getStatistics().getNumberOfValues(key);
+      for (Object ind : mapKeyToValueIndex.values()) {
+        numValues += ((AbstractIndex) ind).getStatistics().getNumberOfValues(key);
-    
+
-      sb.append("Total Update time = ").append(getTotalUpdateTime())
-          .append("\n");
+      sb.append("Total Update time = ").append(getTotalUpdateTime()).append("\n");
-  } 
+  }
-  public ObjectType getResultSetType()
-  {
+  public ObjectType getResultSetType() {
-  void instantiateEvaluator(IndexCreationHelper ich)
-  {
+  void instantiateEvaluator(IndexCreationHelper ich) {
-  public void initializeIndex(boolean loadEntries) throws IMQException
-  {
+  public void initializeIndex(boolean loadEntries) throws IMQException {
-  void lockedQuery(Object key, int operator, Collection results,
-      CompiledValue iterOps, RuntimeIterator runtimeItr,
-      ExecutionContext context, List projAttrib,
-      SelectResults intermediateResults, boolean isIntersection)
-      throws TypeMismatchException, FunctionDomainException,
-      NameResolutionException, QueryInvocationTargetException
-  {
-    Object[] mapKeyAndVal = (Object[])key;
+  void lockedQuery(Object key, int operator, Collection results, CompiledValue iterOps,
+      RuntimeIterator runtimeItr, ExecutionContext context, List projAttrib,
+      SelectResults intermediateResults, boolean isIntersection) throws TypeMismatchException,
+      FunctionDomainException, NameResolutionException, QueryInvocationTargetException {
+    Object[] mapKeyAndVal = (Object[]) key;
-      ri.lockedQuery(mapKeyAndVal[0], operator, results, iterOps, runtimeItr,
-          context, projAttrib, intermediateResults, isIntersection);
+      ri.lockedQuery(mapKeyAndVal[0], operator, results, iterOps, runtimeItr, context, projAttrib,
+          intermediateResults, isIntersection);
-  void lockedQuery(Object lowerBoundKey, int lowerBoundOperator,
-      Object upperBoundKey, int upperBoundOperator, Collection results,
-      Set keysToRemove, ExecutionContext context) throws TypeMismatchException, FunctionDomainException,
-      NameResolutionException, QueryInvocationTargetException
-  {
+  void lockedQuery(Object lowerBoundKey, int lowerBoundOperator, Object upperBoundKey,
+      int upperBoundOperator, Collection results, Set keysToRemove, ExecutionContext context)
+      throws TypeMismatchException, FunctionDomainException, NameResolutionException,
+      QueryInvocationTargetException {
-  void lockedQuery(Object key, int operator, Collection results,
-      Set keysToRemove, ExecutionContext context) throws TypeMismatchException, FunctionDomainException,
-      NameResolutionException, QueryInvocationTargetException
-  {
-    Object[] mapKeyAndVal = (Object[])key;
+  void lockedQuery(Object key, int operator, Collection results, Set keysToRemove,
+      ExecutionContext context) throws TypeMismatchException, FunctionDomainException,
+      NameResolutionException, QueryInvocationTargetException {
+    Object[] mapKeyAndVal = (Object[]) key;
-  public boolean clear() throws QueryException
-  {
-    throw new UnsupportedOperationException(
-        "MapType Index method not supported");
+  public boolean clear() throws QueryException {
+    throw new UnsupportedOperationException("MapType Index method not supported");
-  public int getSizeEstimate(Object key, int op, int matchLevel)
-      throws TypeMismatchException
-  {
-    Object[] mapKeyAndVal = (Object[])key;
+  public int getSizeEstimate(Object key, int op, int matchLevel) throws TypeMismatchException {
+    Object[] mapKeyAndVal = (Object[]) key;
-    }
-    else {
+    } else {
-  
-  public IndexType getType()
-  {
+
+  public IndexType getType() {
-  public boolean isMapType()
-  {
+  public boolean isMapType() {
-  void addMapping(Object key, Object value, RegionEntry entry)
-      throws IMQException
-  {
-    if(key == QueryService.UNDEFINED || !(key instanceof Map)) {
+  void addMapping(Object key, Object value, RegionEntry entry) throws IMQException {
+    if (key == QueryService.UNDEFINED || !(key instanceof Map)) {
-      Iterator<Map.Entry<?, ?>> entries = ((Map)key).entrySet().iterator();
+      Iterator<Map.Entry<?, ?>> entries = ((Map) key).entrySet().iterator();
-    }
-    else {
+    } else {
-        Object indexKey = ((Map)key).get(mapKey);
+        Object indexKey = ((Map) key).get(mapKey);
-  void saveMapping(Object key, Object value, RegionEntry entry)
-      throws IMQException
-  {
-    if(key == QueryService.UNDEFINED || !(key instanceof Map)) {
+  void saveMapping(Object key, Object value, RegionEntry entry) throws IMQException {
+    if (key == QueryService.UNDEFINED || !(key instanceof Map)) {
-      Iterator<Map.Entry<?, ?>> entries = ((Map)key).entrySet().iterator();
+      Iterator<Map.Entry<?, ?>> entries = ((Map) key).entrySet().iterator();
-    }
-    else {
+    } else {
-        Object indexKey = ((Map)key).get(mapKey);
+        Object indexKey = ((Map) key).get(mapKey);
-  public Map<Object, AbstractIndex> getRangeIndexHolderForTesting()
-  {
+  public Map<Object, AbstractIndex> getRangeIndexHolderForTesting() {
-  public String[] getPatternsForTesting()
-  {
+  public String[] getPatternsForTesting() {
-  public Object[] getMapKeysForTesting()
-  {
+  public Object[] getMapKeysForTesting() {
-  public boolean isMatchingWithIndexExpression(CompiledValue condnExpr,
-      String conditionExprStr, ExecutionContext context)
-      throws AmbiguousNameException, TypeMismatchException,
-      NameResolutionException
-  {
+  public boolean isMatchingWithIndexExpression(CompiledValue condnExpr, String conditionExprStr,
+      ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-        MapIndexable mi = (MapIndexable)condnExpr;
+        MapIndexable mi = (MapIndexable) condnExpr;
-      }
-      else {
+      } else {
-    }
-    else {
+    } else {
-  
+

UPD66 UPD66 UPD66 DEL66 DEL66 DEL66
Feature/geode 6661 (#4284)

* GEODE-6661 NioSslEngine has some problems in its ByteBuffer management

Reverting the change to use a temporary byte buffer for SSL handshakes.
At the end of a handshake the buffer may contain application data that
must be available for subsequent decryption.  In the case of TCPConduit
this is usually the "handshake" bytes transmitted for that package's
communications protocol.

Since we really need those bytes I've removed the option of expanding
the handshake buffer if it's smaller than the SSL session's required
packet size.  TCPConduit uses that figure to allocate the buffer so this
should be safe.  I've added a test for this.

* reverting investigative changes to test

* fix failing unit tests - adjusted buffer sizes

* reverted another set of investigative test changes

-    if (logger.isDebugEnabled()) {
-      logger.debug("Allocating new buffer for SSL handshake");
+    if (peerNetData.capacity() < engine.getSession().getPacketBufferSize()) {
+      throw new IllegalArgumentException(String.format("Provided buffer is too small to perform "
+          + "SSL handshake.  Buffer capacity is %s but need %s",
+          peerNetData.capacity(), engine.getSession().getPacketBufferSize()));
-    ByteBuffer handshakeBuffer =
-        bufferPool.acquireDirectReceiveBuffer(engine.getSession().getPacketBufferSize());
+
+    ByteBuffer handshakeBuffer = peerNetData;
+    handshakeBuffer.clear();
-    try {
-      // Process handshaking message
-      while (status != FINISHED &&
-          status != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
-        if (socketChannel.socket().isClosed()) {
-          logger.info("Handshake terminated because socket is closed");
-          throw new SocketException("handshake terminated - socket is closed");
-        }
-
-        if (timeoutNanos > 0) {
-          if (timeoutNanos < System.nanoTime()) {
-            logger.info("TLS handshake is timing out");
-            throw new SocketTimeoutException("handshake timed out");
-          }
-        }
-
-        switch (status) {
-          case NEED_UNWRAP:
-            // Receive handshaking data from peer
-            int dataRead = socketChannel.read(handshakeBuffer);
-
-            // Process incoming handshaking data
-            handshakeBuffer.flip();
-            engineResult = engine.unwrap(handshakeBuffer, peerAppData);
-            handshakeBuffer.compact();
-            status = engineResult.getHandshakeStatus();
-
-            // if we're not finished, there's nothing to process and no data was read let's hang out
-            // for a little
-            if (peerAppData.remaining() == 0 && dataRead == 0 && status == NEED_UNWRAP) {
-              Thread.sleep(10);
-            }
-
-            if (engineResult.getStatus() == BUFFER_OVERFLOW) {
-              peerAppData =
-                  expandWriteBuffer(TRACKED_RECEIVER, peerAppData, peerAppData.capacity() * 2);
-            }
-            break;
-
-          case NEED_WRAP:
-            // Empty the local network packet buffer.
-            myNetData.clear();
-
-            // Generate handshaking data
-            engineResult = engine.wrap(myAppData, myNetData);
-            status = engineResult.getHandshakeStatus();
-
-            // Check status
-            switch (engineResult.getStatus()) {
-              case BUFFER_OVERFLOW:
-                myNetData =
-                    expandWriteBuffer(TRACKED_SENDER, myNetData,
-                        myNetData.capacity() * 2);
-                break;
-              case OK:
-                myNetData.flip();
-                // Send the handshaking data to peer
-                while (myNetData.hasRemaining()) {
-                  socketChannel.write(myNetData);
-                }
-                break;
-              case CLOSED:
-                break;
-              default:
-                logger.info("handshake terminated with illegal state due to {}", status);
-                throw new IllegalStateException(
-                    "Unknown SSLEngineResult status: " + engineResult.getStatus());
-            }
-            break;
-          case NEED_TASK:
-            // Handle blocking tasks
-            handleBlockingTasks();
-            status = engine.getHandshakeStatus();
-            break;
-          default:
-            logger.info("handshake terminated with illegal state due to {}", status);
-            throw new IllegalStateException("Unknown SSL Handshake state: " + status);
-        }
-        Thread.sleep(10);
+    // Process handshaking message
+    while (status != FINISHED &&
+        status != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {
+      if (socketChannel.socket().isClosed()) {
+        logger.info("Handshake terminated because socket is closed");
+        throw new SocketException("handshake terminated - socket is closed");
-    } finally {
-      bufferPool.releaseReceiveBuffer(handshakeBuffer);
+
+      if (timeoutNanos > 0) {
+        if (timeoutNanos < System.nanoTime()) {
+          logger.info("TLS handshake is timing out");
+          throw new SocketTimeoutException("handshake timed out");
+        }
+      }
+
+      switch (status) {
+        case NEED_UNWRAP:
+          // Receive handshaking data from peer
+          int dataRead = socketChannel.read(handshakeBuffer);
+
+          // Process incoming handshaking data
+          handshakeBuffer.flip();
+          engineResult = engine.unwrap(handshakeBuffer, peerAppData);
+          handshakeBuffer.compact();
+          status = engineResult.getHandshakeStatus();
+
+          // if we're not finished, there's nothing to process and no data was read let's hang out
+          // for a little
+          if (peerAppData.remaining() == 0 && dataRead == 0 && status == NEED_UNWRAP) {
+            Thread.sleep(10);
+          }
+
+          if (engineResult.getStatus() == BUFFER_OVERFLOW) {
+            peerAppData =
+                expandWriteBuffer(TRACKED_RECEIVER, peerAppData, peerAppData.capacity() * 2);
+          }
+          break;
+
+        case NEED_WRAP:
+          // Empty the local network packet buffer.
+          myNetData.clear();
+
+          // Generate handshaking data
+          engineResult = engine.wrap(myAppData, myNetData);
+          status = engineResult.getHandshakeStatus();
+
+          // Check status
+          switch (engineResult.getStatus()) {
+            case BUFFER_OVERFLOW:
+              myNetData =
+                  expandWriteBuffer(TRACKED_SENDER, myNetData,
+                      myNetData.capacity() * 2);
+              break;
+            case OK:
+              myNetData.flip();
+              // Send the handshaking data to peer
+              while (myNetData.hasRemaining()) {
+                socketChannel.write(myNetData);
+              }
+              break;
+            case CLOSED:
+              break;
+            default:
+              logger.info("handshake terminated with illegal state due to {}", status);
+              throw new IllegalStateException(
+                  "Unknown SSLEngineResult status: " + engineResult.getStatus());
+          }
+          break;
+        case NEED_TASK:
+          // Handle blocking tasks
+          handleBlockingTasks();
+          status = engine.getHandshakeStatus();
+          break;
+        default:
+          logger.info("handshake terminated with illegal state due to {}", status);
+          throw new IllegalStateException("Unknown SSL Handshake state: " + status);
+      }
+      Thread.sleep(10);

MOV8 INS25 INS60 INS21 MOV60 MOV25 MOV60 MOV25 MOV21 MOV60 MOV60 MOV25 MOV25 MOV41 INS27 INS8 MOV43 INS59 INS32 INS32 MOV32 INS53 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS43 INS32 INS42 INS42 INS42 INS27 INS32 INS32 INS45 INS45 INS42 INS42 INS32 INS42 INS42 INS42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8
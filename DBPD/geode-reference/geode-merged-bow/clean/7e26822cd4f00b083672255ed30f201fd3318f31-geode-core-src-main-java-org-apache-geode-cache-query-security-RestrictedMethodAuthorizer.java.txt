GEODE-6985: Implement RestrictedMethodAuthorizer (#4077)

- Fixed minor warnings.
- Made the class final, immutable and thread safe.
- Added comprehensive javadocs to all public methods.
- Added several unit tests for the class and all public methods.
- Added methods 'isAllowedGeodeMethod' and 'isKnownDangerousMethod'.
-import java.util.Collection;
+import java.sql.Timestamp;
+import java.util.Objects;
+import java.util.Properties;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.Declarable;
+import org.apache.geode.cache.query.internal.QRegion;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.security.SecurityServiceFactory;
-public class RestrictedMethodAuthorizer implements MethodInvocationAuthorizer {
+/**
+ * The default, immutable and thread-safe method invocation authorizer used by Geode to determine
+ * whether a {@link java.lang.reflect.Method} is allowed to be executed on a specific
+ * {@link java.lang.Object} instance.
+ * <p/>
+ *
+ * Custom applications can delegate to this class and use it as the starting point for providing
+ * use case specific authorizers.
+ *
+ * @see org.apache.geode.cache.Cache
+ * @see org.apache.geode.cache.query.security.MethodInvocationAuthorizer
+ */
+public final class RestrictedMethodAuthorizer implements MethodInvocationAuthorizer {
-
-  protected static final Map<String, Set> DEFAULT_ACCEPTLIST =
-      Collections.unmodifiableMap(createAcceptList());
+  static final Set<String> FORBIDDEN_METHODS =
+      Collections.unmodifiableSet(createForbiddenList());
+  @Immutable
+  static final Map<String, Set<Class>> GEODE_ALLOWED_METHODS =
+      Collections.unmodifiableMap(createGeodeAcceptanceList());
+  @Immutable
+  static final Map<String, Set<Class>> DEFAULT_ALLOWED_METHODS =
+      Collections.unmodifiableMap(createDefaultAcceptanceList());
+  final SecurityService securityService;
+  private final Set<String> forbiddenMethods;
+  private final Map<String, Set<Class>> allowedMethodsPerClass;
+  private final Map<String, Set<Class>> allowedGeodeMethodsPerClass;
-  private SecurityService securityService;
+  private static Set<String> createForbiddenList() {
+    Set<String> forbiddenList = new HashSet<>();
-  // List of methods that can be invoked by
-  private final Map<String, Set> acceptListedMethodsToClass;
+    // Reflection Calls
+    forbiddenList.add("getClass");
+    // Serialization Calls
+    forbiddenList.add("readObject");
+    forbiddenList.add("readResolve");
+    forbiddenList.add("readObjectNoData");
+    forbiddenList.add("writeObject");
+    forbiddenList.add("writeReplace");
-  public RestrictedMethodAuthorizer(SecurityService securityService) {
-    this.securityService = securityService;
-    acceptListedMethodsToClass = DEFAULT_ACCEPTLIST;
+    return forbiddenList;
-  private static HashMap<String, Set> createAcceptList() {
-    HashMap<String, Set> acceptListMap = new HashMap<>();
+  private static Map<String, Set<Class>> createGeodeAcceptanceList() {
+    Map<String, Set<Class>> acceptanceListMap = new HashMap<>();
+
+    Set<Class> entryCallers = new HashSet<>();
+    entryCallers.add(Region.Entry.class);
+    entryCallers = Collections.unmodifiableSet(entryCallers);
+    acceptanceListMap.put("getKey", entryCallers);
+    acceptanceListMap.put("getValue", entryCallers);
+
+    Set<Class> regionCallers = new HashSet<>();
+    regionCallers.add(Region.class);
+    regionCallers.add(QRegion.class);
+    regionCallers = Collections.unmodifiableSet(regionCallers);
+    acceptanceListMap.put("containsKey", regionCallers);
+    acceptanceListMap.put("entrySet", regionCallers);
+    acceptanceListMap.put("get", regionCallers);
+    acceptanceListMap.put("keySet", regionCallers);
+    acceptanceListMap.put("values", regionCallers);
+    acceptanceListMap.put("getEntries", regionCallers);
+    acceptanceListMap.put("getValues", regionCallers);
+
+    return acceptanceListMap;
+  }
+
+  private static Map<String, Set<Class>> createDefaultAcceptanceList() {
+    Map<String, Set<Class>> acceptanceListMap = new HashMap<>();
+
-    acceptListMap.put("toString", objectCallers);
-    acceptListMap.put("equals", objectCallers);
-    acceptListMap.put("compareTo", objectCallers);
+    acceptanceListMap.put("compareTo", objectCallers);
+    acceptanceListMap.put("equals", objectCallers);
+    acceptanceListMap.put("toString", objectCallers);
-    acceptListMap.put("booleanValue", booleanCallers);
+    acceptanceListMap.put("booleanValue", booleanCallers);
-    acceptListMap.put("byteValue", numericCallers);
-    acceptListMap.put("intValue", numericCallers);
-    acceptListMap.put("doubleValue", numericCallers);
-    acceptListMap.put("floatValue", numericCallers);
-    acceptListMap.put("longValue", numericCallers);
-    acceptListMap.put("shortValue", numericCallers);
-
-    Set<Class> mapCallers = new HashSet<>();
-    mapCallers.add(Collection.class);
-    mapCallers.add(Map.class);
-    mapCallers = Collections.unmodifiableSet(mapCallers);
-    acceptListMap.put("get", mapCallers);
-    acceptListMap.put("entrySet", mapCallers);
-    acceptListMap.put("keySet", mapCallers);
-    acceptListMap.put("values", mapCallers);
-    acceptListMap.put("getEntries", mapCallers);
-    acceptListMap.put("getValues", mapCallers);
-    acceptListMap.put("containsKey", mapCallers);
-
-    Set<Class> mapEntryCallers = new HashSet<>();
-    mapEntryCallers.add(Map.Entry.class);
-    mapEntryCallers = Collections.unmodifiableSet(mapEntryCallers);
-    acceptListMap.put("getKey", mapEntryCallers);
-    acceptListMap.put("getValue", mapEntryCallers);
+    acceptanceListMap.put("byteValue", numericCallers);
+    acceptanceListMap.put("doubleValue", numericCallers);
+    acceptanceListMap.put("floatValue", numericCallers);
+    acceptanceListMap.put("intValue", numericCallers);
+    acceptanceListMap.put("longValue", numericCallers);
+    acceptanceListMap.put("shortValue", numericCallers);
-    acceptListMap.put("after", dateCallers);
-    acceptListMap.put("before", dateCallers);
-    acceptListMap.put("getNanos", dateCallers);
-    acceptListMap.put("getTime", dateCallers);
+    acceptanceListMap.put("after", dateCallers);
+    acceptanceListMap.put("before", dateCallers);
+    acceptanceListMap.put("getNanos", dateCallers);
+    acceptanceListMap.put("getTime", dateCallers);
+
+    Set<Class> timestampCallers = new HashSet<>();
+    timestampCallers.add(Timestamp.class);
+    timestampCallers = Collections.unmodifiableSet(timestampCallers);
+    acceptanceListMap.put("getNanos", timestampCallers);
-    acceptListMap.put("charAt", stringCallers);
-    acceptListMap.put("codePointAt", stringCallers);
-    acceptListMap.put("codePointBefore", stringCallers);
-    acceptListMap.put("codePointCount", stringCallers);
-    acceptListMap.put("compareToIgnoreCase", stringCallers);
-    acceptListMap.put("concat", stringCallers);
-    acceptListMap.put("contains", stringCallers);
-    acceptListMap.put("contentEquals", stringCallers);
-    acceptListMap.put("endsWith", stringCallers);
-    acceptListMap.put("equalsIgnoreCase", stringCallers);
-    acceptListMap.put("getBytes", stringCallers);
-    acceptListMap.put("hashCode", stringCallers);
-    acceptListMap.put("indexOf", stringCallers);
-    acceptListMap.put("intern", stringCallers);
-    acceptListMap.put("isEmpty", stringCallers);
-    acceptListMap.put("lastIndexOf", stringCallers);
-    acceptListMap.put("length", stringCallers);
-    acceptListMap.put("matches", stringCallers);
-    acceptListMap.put("offsetByCodePoints", stringCallers);
-    acceptListMap.put("regionMatches", stringCallers);
-    acceptListMap.put("replace", stringCallers);
-    acceptListMap.put("replaceAll", stringCallers);
-    acceptListMap.put("replaceFirst", stringCallers);
-    acceptListMap.put("split", stringCallers);
-    acceptListMap.put("startsWith", stringCallers);
-    acceptListMap.put("substring", stringCallers);
-    acceptListMap.put("toCharArray", stringCallers);
-    acceptListMap.put("toLowerCase", stringCallers);
-    acceptListMap.put("toUpperCase", stringCallers);
-    acceptListMap.put("trim", stringCallers);
+    acceptanceListMap.put("charAt", stringCallers);
+    acceptanceListMap.put("codePointAt", stringCallers);
+    acceptanceListMap.put("codePointBefore", stringCallers);
+    acceptanceListMap.put("codePointCount", stringCallers);
+    acceptanceListMap.put("compareToIgnoreCase", stringCallers);
+    acceptanceListMap.put("concat", stringCallers);
+    acceptanceListMap.put("contains", stringCallers);
+    acceptanceListMap.put("contentEquals", stringCallers);
+    acceptanceListMap.put("endsWith", stringCallers);
+    acceptanceListMap.put("equalsIgnoreCase", stringCallers);
+    acceptanceListMap.put("getBytes", stringCallers);
+    acceptanceListMap.put("hashCode", stringCallers);
+    acceptanceListMap.put("indexOf", stringCallers);
+    acceptanceListMap.put("intern", stringCallers);
+    acceptanceListMap.put("isEmpty", stringCallers);
+    acceptanceListMap.put("lastIndexOf", stringCallers);
+    acceptanceListMap.put("length", stringCallers);
+    acceptanceListMap.put("matches", stringCallers);
+    acceptanceListMap.put("offsetByCodePoints", stringCallers);
+    acceptanceListMap.put("regionMatches", stringCallers);
+    acceptanceListMap.put("replace", stringCallers);
+    acceptanceListMap.put("replaceAll", stringCallers);
+    acceptanceListMap.put("replaceFirst", stringCallers);
+    acceptanceListMap.put("split", stringCallers);
+    acceptanceListMap.put("startsWith", stringCallers);
+    acceptanceListMap.put("substring", stringCallers);
+    acceptanceListMap.put("toCharArray", stringCallers);
+    acceptanceListMap.put("toLowerCase", stringCallers);
+    acceptanceListMap.put("toUpperCase", stringCallers);
+    acceptanceListMap.put("trim", stringCallers);
-    return acceptListMap;
+    Set<Class> mapEntryCallers = new HashSet<>();
+    mapEntryCallers.add(Map.Entry.class);
+    mapEntryCallers = Collections.unmodifiableSet(mapEntryCallers);
+    acceptanceListMap.put("getKey", mapEntryCallers);
+    acceptanceListMap.put("getValue", mapEntryCallers);
+
+    Set<Class> regionCallers = new HashSet<>();
+    regionCallers.add(Map.class);
+    regionCallers.add(QRegion.class);
+    regionCallers = Collections.unmodifiableSet(regionCallers);
+    acceptanceListMap.put("containsKey", regionCallers);
+    acceptanceListMap.put("entrySet", regionCallers);
+    acceptanceListMap.put("get", regionCallers);
+    acceptanceListMap.put("keySet", regionCallers);
+    acceptanceListMap.put("values", regionCallers);
+    acceptanceListMap.put("getEntries", regionCallers);
+    acceptanceListMap.put("getValues", regionCallers);
+
+    return acceptanceListMap;
-  protected Map<String, Set> getAcceptList() {
-    return acceptListedMethodsToClass;
+  /**
+   * Returns an unmodifiable view of the methods disallowed by default.
+   * This method can be used to get "read-only" access to the set containing the methods that
+   * are considered non safe by default.
+   *
+   * @return an unmodifiable view of the default disallowed methods.
+   */
+  Set<String> getForbiddenMethods() {
+    return forbiddenMethods;
-  boolean isAcceptlisted(Method method) {
+  /**
+   * Returns an unmodifiable view of the default allowed methods.
+   * This method can be used to get "read-only" access to the map containing the default set
+   * of allowed methods per class.
+   *
+   * @return an unmodifiable view of the default allowed methods per class map.
+   */
+  Map<String, Set<Class>> getAllowedMethodsPerClass() {
+    return allowedMethodsPerClass;
+  }
+
+  /**
+   * Returns an unmodifiable view of the default Geode allowed methods.
+   * This method can be used to get "read-only" access to the map containing the default set
+   * of allowed geode methods per class.
+   *
+   * @return an unmodifiable view of the default allowed geode methods per class map.
+   */
+  Map<String, Set<Class>> getAllowedGeodeMethodsPerClass() {
+    return allowedGeodeMethodsPerClass;
+  }
+
+  /**
+   * Creates a {@code RestrictedMethodAuthorizer} object and initializes it so it can be safely
+   * used in a multi-threaded environment.
+   * <p/>
+   *
+   * If the {@link Cache} instance passed as parameter was previously created by Geode, the
+   * authorizer will use the security service already configured in order to determine whether a
+   * specific user has read privileges upon a particular region.
+   * If the {@link Cache} instance passed as parameter is a wrapper created by external frameworks,
+   * the authorizer will create a new instance of the security service using the configuration
+   * properties used to initialize the cache.
+   * <p/>
+   *
+   * Applications can also use this constructor as part of the initialization for custom authorizers
+   * (see {@link Declarable#initialize(Cache, Properties)}), when using a declarative approach.
+   *
+   * @param cache the {@code Cache} instance that owns this authorizer, required in order to
+   *        configure the security rules used.
+   */
+  public RestrictedMethodAuthorizer(Cache cache) {
+    Objects.requireNonNull(cache, "Cache should be provided to configure the authorizer.");
+
+    // Set the correct SecurityService.
+    if (cache instanceof InternalCache) {
+      // Use the already created SecurityService.
+      this.securityService = ((InternalCache) cache).getSecurityService();
+    } else {
+      // Create the SecurityService using the distributed system properties.
+      Objects.requireNonNull(cache.getDistributedSystem(),
+          "Distributed system properties should be provided to configure the authorizer.");
+      this.securityService =
+          SecurityServiceFactory.create(cache.getDistributedSystem().getSecurityProperties());
+    }
+
+    this.forbiddenMethods = FORBIDDEN_METHODS;
+    this.allowedMethodsPerClass = DEFAULT_ALLOWED_METHODS;
+    this.allowedGeodeMethodsPerClass = GEODE_ALLOWED_METHODS;
+  }
+
+  private boolean isAllowedByDefault(Method method, Object target) {
+    Set<Class> allowedClasses = allowedMethodsPerClass.get(methodName);
-    Set<Class> allowedClasses = acceptListedMethodsToClass.get(methodName);
-    for (Class clazz : allowedClasses) {
-      if (clazz.isAssignableFrom(method.getDeclaringClass())) {
+
+    for (Class<?> clazz : allowedClasses) {
+      if (clazz.isAssignableFrom(target.getClass())) {
+
+  private void authorizeRegionAccess(SecurityService securityService, Object target) {
+    if (target instanceof Region) {
+      String regionName = ((Region) target).getName();
+      securityService.authorize(ResourcePermission.Resource.DATA, ResourcePermission.Operation.READ,
+          regionName);
+    }
+  }
+
+  /**
+   * Executes the verification logic to determine whether the {@code target} object instance belongs
+   * to Geode and whether the {@code method} on the {@code target} object instance is considered
+   * to be safe according to Geode security rules.
+   * If the {@code target} object is an instance of {@link Region}, this methods also ensures that
+   * the user has the {@code DATA:READ} permission granted for the target {@link Region}.
+   * <p/>
+   *
+   * @param method the {@link Method} that should be verified.
+   * @param target the {@link Object} on which the {@link Method} will be executed.
+   * @return {@code true} if and only if the {@code target} object instance belongs to Geode and
+   *         the {@code method} is considered safe to be executed on the {@code target} object
+   *         instance according to the Geode security rules, {@code false} otherwise.
+   */
+  public boolean isAllowedGeodeMethod(Method method, Object target) {
+    String methodName = method.getName();
+    Set<Class> allowedGeodeClassesForMethod = allowedGeodeMethodsPerClass.get(methodName);
+
+    if (allowedGeodeClassesForMethod == null) {
+      return false;
+    }
+
+    for (Class<?> clazz : allowedGeodeClassesForMethod) {
+      if (clazz.isAssignableFrom(target.getClass())) {
+        try {
+          authorizeRegionAccess(securityService, target);
+          return true;
+        } catch (NotAuthorizedException noAuthorizedException) {
+          return false;
+        }
+      }
+    }
+
+    return false;
+  }
+
+  /**
+   * Executes the verification logic to determine whether the {@code method} on the {@code target}
+   * object instance is considered to be non safe according to Geode security rules.
+   * <p/>
+   *
+   * The following methods are currently considered non safe, no matter what the {@code target}
+   * object is:
+   * <p>
+   * <ul>
+   * <li>{@code getClass}
+   * <li>{@code readObject}
+   * <li>{@code readResolve}
+   * <li>{@code readObjectNoData}
+   * <li>{@code writeObject}
+   * <li>{@code writeReplace}
+   * </ul>
+   * <p>
+   *
+   * @param method the {@link Method} that should be verified.
+   * @param target the {@link Object} on which the {@link Method} will be executed.
+   * @return {@code true} if the {@code method} is considered non safe to be executed on the
+   *         {@code target} instance according to the Geode security rules, {@code false} otherwise.
+   */
+  public boolean isKnownDangerousMethod(Method method, @SuppressWarnings("unused") Object target) {
+    return forbiddenMethods.contains(method.getName());
+  }
+
+  /**
+   * Executes the authorization logic to determine whether the {@code method} is allowed to be
+   * executed on the {@code target} object instance.
+   * If the {@code target} object is an instance of {@link Region}, this methods also ensures that
+   * the user has the {@code DATA:READ} permission granted for the target {@link Region}.
+   * <p/>
+   *
+   * @param method the {@link Method} that should be authorized.
+   * @param target the {@link Object} on which the {@link Method} will be executed.
+   * @return {@code true} if the {@code method} can be executed on on the {@code target} instance,
+   *         {@code false} otherwise.
+   *
+   * @see org.apache.geode.cache.query.security.MethodInvocationAuthorizer
+   */
-    if (!isAcceptlisted(method)) {
+    if (!isAllowedByDefault(method, target)) {
-
-  private void authorizeRegionAccess(SecurityService securityService, Object target) {
-    if (target instanceof Region) {
-      String regionName = ((Region) target).getName();
-      securityService.authorize(ResourcePermission.Resource.DATA, ResourcePermission.Operation.READ,
-          regionName);
-    }
-  }

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV31 MOV31 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS29 INS83 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS65 INS65 INS65 MOV78 UPD83 MOV83 INS83 UPD74 MOV74 MOV43 INS59 INS78 MOV83 MOV83 UPD74 MOV74 INS59 INS78 INS83 INS83 INS74 MOV59 UPD83 INS83 INS83 INS74 INS59 INS74 INS83 INS83 INS74 INS59 INS83 INS83 INS74 INS42 MOV8 MOV83 MOV83 UPD74 MOV74 UPD42 MOV42 INS8 INS83 INS83 INS74 INS42 INS8 INS29 INS74 INS42 INS8 INS29 INS74 INS42 INS8 INS29 INS74 INS42 INS8 INS29 INS83 INS42 INS44 INS8 INS83 UPD42 INS44 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS29 UPD83 INS39 INS42 INS44 INS44 INS29 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS66 INS40 INS40 INS42 INS32 INS42 MOV43 MOV43 INS74 INS42 INS32 INS42 MOV43 MOV43 INS74 UPD42 MOV43 MOV43 INS42 INS43 INS43 INS74 UPD42 INS43 INS43 INS74 INS42 MOV43 INS43 INS60 INS21 INS21 INS21 INS21 INS41 UPD43 INS43 INS74 MOV60 MOV60 INS21 MOV21 MOV21 MOV21 INS60 INS21 INS21 INS21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 INS41 INS43 INS43 INS74 INS60 MOV60 MOV21 MOV21 INS21 MOV21 MOV21 MOV60 MOV21 MOV21 MOV21 MOV60 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV60 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 INS60 INS21 INS21 INS21 MOV60 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV60 MOV21 MOV21 INS21 INS21 INS60 MOV21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 MOV41 INS65 INS65 MOV43 INS43 INS41 INS65 INS65 INS43 INS43 INS74 INS41 INS65 INS65 INS43 INS43 INS74 INS41 INS65 INS65 INS43 INS42 INS21 INS25 INS21 INS21 INS21 INS43 INS42 INS65 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS60 INS60 MOV25 INS70 INS41 INS65 INS65 INS65 INS65 INS43 INS42 INS79 INS43 INS42 INS65 INS65 INS65 INS65 INS65 INS25 INS40 INS40 INS42 INS42 INS32 INS43 INS43 INS42 INS42 INS32 INS43 INS43 INS42 INS42 INS43 INS43 INS42 INS42 INS43 INS43 INS42 INS74 INS59 INS32 INS32 INS32 INS32 INS32 INS32 INS42 UPD42 INS42 INS43 INS43 UPD74 INS32 INS7 INS74 INS59 INS32 INS32 INS7 INS42 INS42 INS42 INS43 INS43 UPD74 MOV74 INS59 INS32 MOV74 INS59 INS32 INS7 INS32 INS32 INS32 INS74 INS59 INS32 INS7 INS32 INS32 INS32 INS32 INS32 INS32 INS32 UPD42 INS66 INS66 INS66 INS66 INS42 INS42 INS66 INS66 INS66 INS66 INS42 INS42 INS43 INS43 INS42 INS66 INS66 INS66 INS66 INS42 INS42 INS43 INS43 INS42 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS42 INS66 INS65 INS66 INS66 INS42 INS32 INS62 INS8 INS8 INS7 INS7 INS7 INS42 INS74 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS42 INS66 INS65 INS66 INS42 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS42 INS42 INS43 INS59 INS74 INS59 INS27 INS44 INS42 INS8 INS9 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS66 INS42 INS66 INS65 INS66 INS42 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS42 INS42 INS45 INS42 INS32 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS42 INS66 INS65 INS66 INS42 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS40 INS38 INS8 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 UPD42 MOV42 INS42 MOV43 INS43 INS42 INS14 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 UPD43 INS43 INS74 UPD42 UPD42 INS42 INS42 INS57 INS42 INS32 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 INS43 INS43 INS42 INS14 INS42 INS42 INS57 INS42 INS42 INS57 INS42 INS32 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 INS42 UPD42 MOV42 INS74 INS42 INS14 UPD42 MOV42 UPD42 MOV42 INS45 UPD42 MOV42 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD42 UPD45 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS14 INS42 INS42 INS57 INS42 INS32 INS42 INS42 INS45 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS43 INS43 INS42 INS14 UPD42 INS42 INS42 INS57 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS66 INS42 INS42 INS68 INS66 INS42 INS42 INS42 INS45 INS42 INS43 INS21 INS21 INS21 INS22 INS42 INS22 INS42 INS22 INS42 INS43 INS43 INS74 INS66 INS66 INS66 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS32 INS43 INS43 INS42 INS32 INS42 INS33 INS74 INS42 INS25 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS66 INS66 INS66 INS66 INS42 INS42 INS32 INS66 INS66 INS66 INS42 INS66 INS42 INS42 INS42 INS42 INS66 INS66 INS66 INS66 INS32 INS41 INS42 INS74 UPD42 INS42 INS43 INS43 INS43 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS74 INS43 INS43 INS42 INS42 INS42 INS43 INS43 INS74 INS74 INS43 INS42 INS42 INS42 INS42 INS42 INS74 INS43 INS42 INS42 INS42 INS42 INS42 INS69 INS69 INS42 INS7 INS32 INS7 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 UPD42 MOV43 INS76 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS76 INS32 INS8 INS42 INS42 INS42 INS42 INS42 INS9 INS43 INS42 INS42 INS40 INS43 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS43 INS42 INS43 INS43 MOV22 INS32 INS42 INS42 INS32 INS45 INS22 INS32 INS42 INS42 INS42 INS32 INS54 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS36 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS32 UPD42 UPD42 INS42 INS42 INS8 INS12 INS11 INS32 INS42 INS21 INS41 INS44 INS8 INS43 INS42 INS42 INS42 INS32 INS9 INS43 INS42 INS41 INS42 INS42 INS42 INS42 INS42 INS9 DEL23 DEL42 DEL7 DEL42 DEL42 DEL7 DEL45 DEL32 DEL83 DEL42 DEL43 DEL42 DEL44 DEL31 DEL42 DEL42 DEL43 DEL57 DEL32 DEL21 DEL42 DEL32 DEL7 DEL21 DEL8 DEL31 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42
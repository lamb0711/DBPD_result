Merge branch 'develop' into feature/GEODE-420

# Conflicts:
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/AbstractDistributionConfig.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/DistributionConfig.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/DistributionConfigImpl.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/InternalLocator.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/StartupMessage.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/SystemAdmin.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/AcceptorImpl.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/CacheServerStats.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/i18n/LocalizedStrings.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/statistics/HostStatHelper.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/statistics/HostStatSampler.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/statistics/StatArchiveWriter.java
#	geode-core/src/main/java/com/gemstone/gemfire/management/internal/ManagementAgent.java
#	geode-core/src/test/java/com/gemstone/gemfire/distributed/internal/DistributionConfigJUnitTest.java
#	geode-core/src/test/java/com/gemstone/gemfire/internal/statistics/GemFireStatSamplerIntegrationTest.java
#	geode-core/src/test/java/com/gemstone/gemfire/internal/statistics/SimpleStatSamplerIntegrationTest.java

+import com.gemstone.gemfire.internal.cache.AbstractRegionMap.ARMLockTestHook;
-        result = getSharedDataView().findObject(keyInfo, this, true/*isCreate*/, generateCallbacks,
-            localValue, disableCopyOnRead, preferCD, null, null, false);
-        // TODO why are we not passing the client event or returnTombstones in the above invokation?
+        result = getSharedDataView().findObject(keyInfo, this, isCreate, generateCallbacks,
+            localValue, disableCopyOnRead, preferCD, requestingClient, clientEvent, returnTombstones);
+      try {
-      final DistributedPutAllOperation dpao = putAllOp;
-      int size = (proxyResult == null)? map.size() : proxyResult.size();
-      
-      if (isDebugEnabled) {
-        logger.debug( "size of put result is {} maps is {} proxyResult is {}", size, map, proxyResult);
-      }
+        final DistributedPutAllOperation dpao = putAllOp;
+        int size = (proxyResult == null)? map.size() : proxyResult.size();
-      final PutAllPartialResult partialKeys = new PutAllPartialResult(size);
-      final Iterator iterator;
-      final boolean isVersionedResults;
-      if (proxyResult != null) {
-        iterator = proxyResult.iterator();
-        isVersionedResults = true;
-      } else {
-        iterator = map.entrySet().iterator();
-        isVersionedResults = false;
-      }
-      Runnable r = new Runnable() {
-        public void run() {
-          int offset = 0;
-          VersionTagHolder tagHolder = new VersionTagHolder();
-          while (iterator.hasNext()) {
-            stopper.checkCancelInProgress(null);
-            Map.Entry mapEntry = (Map.Entry)iterator.next();
-            Object key = mapEntry.getKey();
-            VersionTag versionTag = null;
-            tagHolder.setVersionTag(null);
-            final Object value;
-            boolean overwritten = false;
-            if (isVersionedResults) {
-              versionTag = ((VersionedObjectList.Entry)mapEntry).getVersionTag();
-              value = map.get(key);
-              if (isDebugEnabled) {
-                logger.debug("putAll key {} -> {} version={}", key, value, versionTag);
-              }
-              if (versionTag == null && serverIsVersioned && concurrencyChecksEnabled && dataPolicy.withStorage()) {
-                // server was unable to determine the version for this operation.
-                // I'm not sure this can still happen as described below on a pr.
-                // But it can happen on the server if NORMAL or PRELOADED. See bug 51644.
-                // This can happen in a PR with redundancy if there is a bucket
-                // failure or migration during the operation.  We destroy the
-                // entry since we don't know what its state should be (but the server should)
-                if (isDebugEnabled) {
-                  logger.debug("server returned no version information for {}", key);
-                }
-                localDestroyNoCallbacks(key);
-                // to be consistent we need to fetch the current entry
-                get(key, event.getCallbackArgument(), false, null);
-                overwritten = true;
-              }
-            } else {
-              value = mapEntry.getValue();
-              if (isDebugEnabled) {
-                logger.debug("putAll {} -> {}", key, value);
-              }
-            }
-            try {
-              if (serverIsVersioned) {
-                if (isDebugEnabled) {
-                  logger.debug("associating version tag with {} version={}", key, versionTag);
-                }
-                //If we have received a version tag from a server, add it to the event
-                tagHolder.setVersionTag(versionTag);
-                tagHolder.setFromServer(true);
-              } else if (retryVersions != null && retryVersions.containsKey(key)) {
-                //If this is a retried event, and we have a version tag for the retry,
-                //add it to the event.
-                tagHolder.setVersionTag(retryVersions.get(key));
-              }
-              
-              if (!overwritten) {
-                basicEntryPutAll(key, value, dpao, offset, tagHolder);
-              }
-              // now we must check again since the cache may have closed during
-              // distribution (causing this process to not receive and queue the
-              // event for clients
-              stopper.checkCancelInProgress(null);
-              succeeded.addKeyAndVersion(key, tagHolder.getVersionTag());
-            } 
-            catch (Exception ex) {
-              // TODO ask Gester if this debug logging can be removed
-              if (isDebugEnabled) {
-                logger.debug("PutAll operation encountered exception for key {}", key, ex);
-              }
-              partialKeys.saveFailedKey(key, ex);
-            }
-            offset++;
-          }
-        }
-      };
-      this.syncBulkOp(r, eventId);
-      if (partialKeys.hasFailure()) {
-        // Bug 51725: Now succeeded contains an order key list, may be missing the version tags. 
-        // Save reference of succeeded into partialKeys. The succeeded may be modified by
-        // postPutAll() to fill in the version tags. 
-        partialKeys.setSucceededKeysAndVersions(succeeded);
-        logger.info(LocalizedMessage.create(LocalizedStrings.Region_PutAll_Applied_PartialKeys_0_1,
-                new Object[] {getFullPath(), partialKeys}));
-          logger.debug(partialKeys.detailString());
+          logger.debug( "size of put result is {} maps is {} proxyResult is {}", size, map, proxyResult);
-        if (e == null) {
-          // if received exception from server first, ignore local exception
-          if (dpao.isBridgeOperation()) {
-            if (partialKeys.getFailure() instanceof CancelException) {
-              e = (CancelException)partialKeys.getFailure(); 
-            } else if (partialKeys.getFailure() instanceof LowMemoryException) {
-              throw partialKeys.getFailure();  // fix for #43589
-            } else {
-              e = new PutAllPartialResultException(partialKeys);
-              if (isDebugEnabled) {
-                logger.debug("basicPutAll:"+partialKeys.detailString());
+
+        final PutAllPartialResult partialKeys = new PutAllPartialResult(size);
+        final Iterator iterator;
+        final boolean isVersionedResults;
+        if (proxyResult != null) {
+          iterator = proxyResult.iterator();
+          isVersionedResults = true;
+        } else {
+          iterator = map.entrySet().iterator();
+          isVersionedResults = false;
+        }
+        Runnable r = new Runnable() {
+          public void run() {
+            int offset = 0;
+            VersionTagHolder tagHolder = new VersionTagHolder();
+            while (iterator.hasNext()) {
+              stopper.checkCancelInProgress(null);
+              Map.Entry mapEntry = (Map.Entry)iterator.next();
+              Object key = mapEntry.getKey();
+              VersionTag versionTag = null;
+              tagHolder.setVersionTag(null);
+              final Object value;
+              boolean overwritten = false;
+              if (isVersionedResults) {
+                versionTag = ((VersionedObjectList.Entry)mapEntry).getVersionTag();
+                value = map.get(key);
+                if (isDebugEnabled) {
+                  logger.debug("putAll key {} -> {} version={}", key, value, versionTag);
+                }
+                if (versionTag == null && serverIsVersioned && concurrencyChecksEnabled && dataPolicy.withStorage()) {
+                  // server was unable to determine the version for this operation.
+                  // I'm not sure this can still happen as described below on a pr.
+                  // But it can happen on the server if NORMAL or PRELOADED. See bug 51644.
+                  // This can happen in a PR with redundancy if there is a bucket
+                  // failure or migration during the operation.  We destroy the
+                  // entry since we don't know what its state should be (but the server should)
+                  if (isDebugEnabled) {
+                    logger.debug("server returned no version information for {}", key);
+                  }
+                  localDestroyNoCallbacks(key);
+                  // to be consistent we need to fetch the current entry
+                  get(key, event.getCallbackArgument(), false, null);
+                  overwritten = true;
+                }
+              } else {
+                value = mapEntry.getValue();
+                if (isDebugEnabled) {
+                  logger.debug("putAll {} -> {}", key, value);
+                }
+              try {
+                if (serverIsVersioned) {
+                  if (isDebugEnabled) {
+                    logger.debug("associating version tag with {} version={}", key, versionTag);
+                  }
+                  //If we have received a version tag from a server, add it to the event
+                  tagHolder.setVersionTag(versionTag);
+                  tagHolder.setFromServer(true);
+                } else if (retryVersions != null && retryVersions.containsKey(key)) {
+                  //If this is a retried event, and we have a version tag for the retry,
+                  //add it to the event.
+                  tagHolder.setVersionTag(retryVersions.get(key));
+                }
+
+                if (!overwritten) {
+                  basicEntryPutAll(key, value, dpao, offset, tagHolder);
+                }
+                // now we must check again since the cache may have closed during
+                // distribution (causing this process to not receive and queue the
+                // event for clients
+                stopper.checkCancelInProgress(null);
+                succeeded.addKeyAndVersion(key, tagHolder.getVersionTag());
+              } 
+              catch (Exception ex) {
+                // TODO ask Gester if this debug logging can be removed
+                if (isDebugEnabled) {
+                  logger.debug("PutAll operation encountered exception for key {}", key, ex);
+                }
+                partialKeys.saveFailedKey(key, ex);
+              }
+              offset++;
-          } else {
-            throw partialKeys.getFailure();
+          }
+        };
+        this.syncBulkOp(r, eventId);
+        if (partialKeys.hasFailure()) {
+          // Bug 51725: Now succeeded contains an order key list, may be missing the version tags. 
+          // Save reference of succeeded into partialKeys. The succeeded may be modified by
+          // postPutAll() to fill in the version tags. 
+          partialKeys.setSucceededKeysAndVersions(succeeded);
+          logger.info(LocalizedMessage.create(LocalizedStrings.Region_PutAll_Applied_PartialKeys_0_1,
+              new Object[] {getFullPath(), partialKeys}));
+          if (isDebugEnabled) {
+            logger.debug(partialKeys.detailString());
+          }
+          if (e == null) {
+            // if received exception from server first, ignore local exception
+            if (dpao.isBridgeOperation()) {
+              if (partialKeys.getFailure() instanceof CancelException) {
+                e = (CancelException)partialKeys.getFailure(); 
+              } else if (partialKeys.getFailure() instanceof LowMemoryException) {
+                throw partialKeys.getFailure();  // fix for #43589
+              } else {
+                e = new PutAllPartialResultException(partialKeys);
+                if (isDebugEnabled) {
+                  logger.debug("basicPutAll:"+partialKeys.detailString());
+                }
+              }
+            } else {
+              throw partialKeys.getFailure();
+            }
-    }
-    catch (LowMemoryException lme) {
-      throw lme;
-    }
-    catch (RuntimeException ex) {
-      e = ex;
-    }
-    catch (Exception ex) {
-      e = new RuntimeException(ex);
+      catch (LowMemoryException lme) {
+        throw lme;
+      }
+      catch (RuntimeException ex) {
+        e = ex;
+      }
+      catch (Exception ex) {
+        e = new RuntimeException(ex);
+      } finally {
+        putAllOp.getBaseEvent().release();
+        putAllOp.freeOffHeapResources();
+      }
+      getDataView().postPutAll(putAllOp, succeeded, this);
-      putAllOp.getBaseEvent().release();
-      putAllOp.freeOffHeapResources();
-    getDataView().postPutAll(putAllOp, succeeded, this);
+      try {
-      final DistributedRemoveAllOperation op = removeAllOp;
-      int size = (proxyResult == null)? keys.size() : proxyResult.size();
-      
-      if (isInternalRegion()) {
-        if (isTraceEnabled) {
-          logger.trace(
-              "size of removeAll result is {} keys are {} proxyResult is {}", size, keys, proxyResult);
+        final DistributedRemoveAllOperation op = removeAllOp;
+        int size = (proxyResult == null)? keys.size() : proxyResult.size();
+
+        if (isInternalRegion()) {
+          if (isTraceEnabled) {
+            logger.trace(
+                "size of removeAll result is {} keys are {} proxyResult is {}", size, keys, proxyResult);
+          } else {
+            if (isTraceEnabled) {
+              logger.trace(
+                  "size of removeAll result is {} keys are {} proxyResult is {}", size, keys, proxyResult);
+            }
+          }
-      } else {
-        if (isTraceEnabled) {
-          logger.trace(
-              "size of removeAll result is {} keys are {} proxyResult is {}", size, keys, proxyResult);
+
+        final PutAllPartialResult partialKeys = new PutAllPartialResult(size);
+        final Iterator iterator;
+        final boolean isVersionedResults;
+        if (proxyResult != null) {
+          iterator = proxyResult.iterator();
+          isVersionedResults = true;
+        } else {
+          iterator = keys.iterator();
+          isVersionedResults = false;
-      }
-
-      final PutAllPartialResult partialKeys = new PutAllPartialResult(size);
-      final Iterator iterator;
-      final boolean isVersionedResults;
-      if (proxyResult != null) {
-        iterator = proxyResult.iterator();
-        isVersionedResults = true;
-      } else {
-        iterator = keys.iterator();
-        isVersionedResults = false;
-      }
-      Runnable r = new Runnable() {
-        public void run() {
-          int offset = 0;
-          VersionTagHolder tagHolder = new VersionTagHolder();
-          while (iterator.hasNext()) {
-            stopper.checkCancelInProgress(null);
-            Object key;
-            VersionTag versionTag = null;
-            tagHolder.setVersionTag(null);
-            if (isVersionedResults) {
-              Map.Entry mapEntry = (Map.Entry)iterator.next();
-              key = mapEntry.getKey();
-              versionTag = ((VersionedObjectList.Entry)mapEntry).getVersionTag();
-              if (isDebugEnabled) {
-                logger.debug("removeAll key {} version={}",key, versionTag);
-              }
-              if (versionTag == null) {
-                if (isDebugEnabled) {
-                  logger.debug("removeAll found invalid version tag, which means the entry is not found at server for key={}.", key);
-                }
-                succeeded.addKeyAndVersion(key, null);
-                continue;
-              }
-              // No need for special handling here in removeAll.
-              // We can just remove this key from the client with versionTag set to null.
-            } else {
-              key = iterator.next();
-              if (isInternalRegion()) {
-                if (isTraceEnabled) {
-                  logger.trace("removeAll {}", key);
-                }
-              } else {
-                if (isTraceEnabled) {
-                  logger.trace("removeAll {}", key);
-                }
-              }
-
-            }
-            try {
-              if (serverIsVersioned) {
-                if (isDebugEnabled) {
-                  logger.debug("associating version tag with {} version={}", key, versionTag);
-                }
-                //If we have received a version tag from a server, add it to the event
-                tagHolder.setVersionTag(versionTag);
-                tagHolder.setFromServer(true);
-              } else if (retryVersions != null) {
-                VersionTag vt = retryVersions.get(offset);
-                if (vt != null) {
-                  //If this is a retried event, and we have a version tag for the retry,
-                  //add it to the event.
-                  tagHolder.setVersionTag(vt);
-                }
-              }
-              
-              basicEntryRemoveAll(key, op, offset, tagHolder);
-              // now we must check again since the cache may have closed during
-              // distribution causing this process to not receive and queue the
-              // event for clients
+        Runnable r = new Runnable() {
+          public void run() {
+            int offset = 0;
+            VersionTagHolder tagHolder = new VersionTagHolder();
+            while (iterator.hasNext()) {
-              succeeded.addKeyAndVersion(key, tagHolder.getVersionTag());
-            } 
-            catch (Exception ex) {
-              partialKeys.saveFailedKey(key, ex);
-            }
-            offset++;
-          }
-        }
-      };
-      syncBulkOp(r, eventId);
-      if (partialKeys.hasFailure()) {
-        // Bug 51725: Now succeeded contains an order key list, may be missing the version tags. 
-        // Save reference of succeeded into partialKeys. The succeeded may be modified by
-        // postRemoveAll() to fill in the version tags.
-        partialKeys.setSucceededKeysAndVersions(succeeded);
-        logger.info(LocalizedMessage.create(LocalizedStrings.Region_RemoveAll_Applied_PartialKeys_0_1,
-                new Object[] {getFullPath(), partialKeys}));
-        if (isDebugEnabled) {
-          logger.debug(partialKeys.detailString());
-        }
-        if (e == null) {
-          // if received exception from server first, ignore local exception
-          if (op.isBridgeOperation()) {
-            if (partialKeys.getFailure() instanceof CancelException) {
-              e = (CancelException)partialKeys.getFailure(); 
-            } else if (partialKeys.getFailure() instanceof LowMemoryException) {
-              throw partialKeys.getFailure();  // fix for #43589
-            } else {
-              e = new PutAllPartialResultException(partialKeys);
-              if (isDebugEnabled) {
-                logger.debug("basicRemoveAll:"+partialKeys.detailString());
+              Object key;
+              VersionTag versionTag = null;
+              tagHolder.setVersionTag(null);
+              if (isVersionedResults) {
+                Map.Entry mapEntry = (Map.Entry)iterator.next();
+                key = mapEntry.getKey();
+                versionTag = ((VersionedObjectList.Entry)mapEntry).getVersionTag();
+                if (isDebugEnabled) {
+                  logger.debug("removeAll key {} version={}",key, versionTag);
+                }
+                if (versionTag == null) {
+                  if (isDebugEnabled) {
+                    logger.debug("removeAll found invalid version tag, which means the entry is not found at server for key={}.", key);
+                  }
+                  succeeded.addKeyAndVersion(key, null);
+                  continue;
+                }
+                // No need for special handling here in removeAll.
+                // We can just remove this key from the client with versionTag set to null.
+              } else {
+                key = iterator.next();
+                if (isInternalRegion()) {
+                  if (isTraceEnabled) {
+                    logger.trace("removeAll {}", key);
+                  }
+                } else {
+                  if (isTraceEnabled) {
+                    logger.trace("removeAll {}", key);
+                  }
+                }
+
+              try {
+                if (serverIsVersioned) {
+                  if (isDebugEnabled) {
+                    logger.debug("associating version tag with {} version={}", key, versionTag);
+                  }
+                  //If we have received a version tag from a server, add it to the event
+                  tagHolder.setVersionTag(versionTag);
+                  tagHolder.setFromServer(true);
+                } else if (retryVersions != null) {
+                  VersionTag vt = retryVersions.get(offset);
+                  if (vt != null) {
+                    //If this is a retried event, and we have a version tag for the retry,
+                    //add it to the event.
+                    tagHolder.setVersionTag(vt);
+                  }
+                }
+
+                basicEntryRemoveAll(key, op, offset, tagHolder);
+                // now we must check again since the cache may have closed during
+                // distribution causing this process to not receive and queue the
+                // event for clients
+                stopper.checkCancelInProgress(null);
+                succeeded.addKeyAndVersion(key, tagHolder.getVersionTag());
+              } 
+              catch (Exception ex) {
+                partialKeys.saveFailedKey(key, ex);
+              }
+              offset++;
-          } else {
-            throw partialKeys.getFailure();
+          }
+        };
+        syncBulkOp(r, eventId);
+        if (partialKeys.hasFailure()) {
+          // Bug 51725: Now succeeded contains an order key list, may be missing the version tags. 
+          // Save reference of succeeded into partialKeys. The succeeded may be modified by
+          // postRemoveAll() to fill in the version tags.
+          partialKeys.setSucceededKeysAndVersions(succeeded);
+          logger.info(LocalizedMessage.create(LocalizedStrings.Region_RemoveAll_Applied_PartialKeys_0_1,
+              new Object[] {getFullPath(), partialKeys}));
+          if (isDebugEnabled) {
+            logger.debug(partialKeys.detailString());
+          }
+          if (e == null) {
+            // if received exception from server first, ignore local exception
+            if (op.isBridgeOperation()) {
+              if (partialKeys.getFailure() instanceof CancelException) {
+                e = (CancelException)partialKeys.getFailure(); 
+              } else if (partialKeys.getFailure() instanceof LowMemoryException) {
+                throw partialKeys.getFailure();  // fix for #43589
+              } else {
+                e = new PutAllPartialResultException(partialKeys);
+                if (isDebugEnabled) {
+                  logger.debug("basicRemoveAll:"+partialKeys.detailString());
+                }
+              }
+            } else {
+              throw partialKeys.getFailure();
+            }
-    }
-    catch (LowMemoryException lme) {
-      throw lme;
-    }
-    catch (RuntimeException ex) {
-      e = ex;
-    }
-    catch (Exception ex) {
-      e = new RuntimeException(ex);
+      catch (LowMemoryException lme) {
+        throw lme;
+      }
+      catch (RuntimeException ex) {
+        e = ex;
+      }
+      catch (Exception ex) {
+        e = new RuntimeException(ex);
+      } finally {
+        removeAllOp.getBaseEvent().release();
+        removeAllOp.freeOffHeapResources();
+      }
+      getDataView().postRemoveAll(removeAllOp, succeeded, this);
-      removeAllOp.getBaseEvent().release();
-      removeAllOp.freeOffHeapResources();
-    getDataView().postRemoveAll(removeAllOp, succeeded, this);
+    ARMLockTestHook alth = getRegionMap().getARMLockTestHook();
+    if(alth!=null) { 
+      alth.beforeBulkLock(this); 
+    }
+    
+    
+    if(alth!=null) {
+      alth.afterBulkLock(this);
+    }
+    ARMLockTestHook alth = getRegionMap().getARMLockTestHook();
+    if(alth!=null) {
+      alth.beforeBulkRelease(this);
+    }
+    
+    
+    if(alth!=null) {
+      alth.afterBulkRelease(this);
+    }
+  public int testHookGetValuesInVM() {
+    int result = 0;
+    for (RegionEntry re: getRegionMap().regionEntries()) {
+      if (re.getValueAsToken() == Token.NOT_A_TOKEN) {
+        result++;
+      }
+    }
+    return result;
+  }
+  
+  public int testHookGetValuesOnDisk() {
+    int result = 0;
+    for (RegionEntry re: getRegionMap().regionEntries()) {
+      if (re.getValueAsToken() == null) {
+        result++;
+      }
+    }
+    return result;
+  }
+  

INS26 INS40 INS31 INS31 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS54 INS54 INS60 INS25 INS25 INS60 INS25 INS25 INS60 INS70 INS41 INS60 INS70 INS41 INS8 INS8 INS8 INS8 INS43 INS59 INS27 INS8 INS27 INS8 INS43 INS59 INS27 INS8 INS27 INS8 INS39 INS59 INS44 INS32 INS8 INS42 INS39 INS59 INS44 INS32 INS8 INS42 MOV54 MOV21 MOV21 MOV54 MOV21 MOV21 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS33 INS21 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS33 INS21 INS42 INS34 INS43 INS42 INS32 INS42 INS25 INS42 INS34 INS43 INS42 INS32 INS42 INS25 INS32 INS42 INS32 INS32 INS32 INS42 INS32 INS32 INS42 INS42 INS27 INS8 INS42 INS42 INS27 INS8 INS42 INS42 INS42 INS52 INS42 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS52 INS32 INS40 INS21 INS32 INS33 INS21 INS42 INS42 INS37 INS42 INS42 INS37 INS42 INS42 INS42 INS42 INS42 INS42 DEL9 DEL33 DEL33 DEL9
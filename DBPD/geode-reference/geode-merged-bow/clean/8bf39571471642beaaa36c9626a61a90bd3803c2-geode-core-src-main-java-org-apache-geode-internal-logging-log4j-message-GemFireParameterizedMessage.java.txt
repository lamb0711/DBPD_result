Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache license, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache license, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the license for the specific language governing permissions and
- * limitations under the license.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the license for the specific language governing permissions and limitations under
+ * the license.
- * Handles messages that consist of a format string containing '{}' to represent each replaceable token, and
- * the parameters.
+ * Handles messages that consist of a format string containing '{}' to represent each replaceable
+ * token, and the parameters.
- * This class was originally written for <a href="http://lilithapp.com/">Lilith</a> by Joern Huxhorn where it is
- * licensed under the LGPL. It has been relicensed here with his permission providing that this attribution remain.
+ * This class was originally written for <a href="http://lilithapp.com/">Lilith</a> by Joern Huxhorn
+ * where it is licensed under the LGPL. It has been relicensed here with his permission providing
+ * that this attribution remain.
- * Copied into Geode from org.apache.logging.log4j.message.ParameterizedMessage (http://logging.apache.org/log4j/2.x/license.html)
+ * Copied into Geode from org.apache.logging.log4j.message.ParameterizedMessage
+ * (http://logging.apache.org/log4j/2.x/license.html)
- * Geode changes include changing class name and package. Additional changes are commented with "// GEODE: note"
+ * Geode changes include changing class name and package. Additional changes are commented with "//
+ * GEODE: note"
-   * @param messagePattern The message "format" string. This will be a String containing "{}" placeholders
-   * where parameters should be substituted.
+   * 
+   * @param messagePattern The message "format" string. This will be a String containing "{}"
+   *        placeholders where parameters should be substituted.
-  public GemFireParameterizedMessage(final String messagePattern, final String[] stringArgs, final Throwable throwable) {
-      this.messagePattern = messagePattern;
-      this.stringArgs = stringArgs;
-      this.throwable = throwable;
+  public GemFireParameterizedMessage(final String messagePattern, final String[] stringArgs,
+      final Throwable throwable) {
+    this.messagePattern = messagePattern;
+    this.stringArgs = stringArgs;
+    this.throwable = throwable;
-   * @param messagePattern The message "format" string. This will be a String containing "{}" placeholders
-   * where parameters should be substituted.
+   * 
+   * @param messagePattern The message "format" string. This will be a String containing "{}"
+   *        placeholders where parameters should be substituted.
-  public GemFireParameterizedMessage(final String messagePattern, final Object[] objectArgs, final Throwable throwable) {
-      this.messagePattern = messagePattern;
-      this.throwable = throwable;
-      this.stringArgs = parseArguments(objectArgs);
+  public GemFireParameterizedMessage(final String messagePattern, final Object[] objectArgs,
+      final Throwable throwable) {
+    this.messagePattern = messagePattern;
+    this.throwable = throwable;
+    this.stringArgs = parseArguments(objectArgs);
-   * Constructs a ParameterizedMessage which contains the arguments converted to String as well as an optional
-   * Throwable.
+   * Constructs a ParameterizedMessage which contains the arguments converted to String as well as
+   * an optional Throwable.
-   * <p>If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern it is returned
-   * in {@link #getThrowable()} and won't be contained in the created String[].
-   * If it is used up {@link #getThrowable()} will return null even if the last argument was a Throwable!</p>
+   * <p>
+   * If the last argument is a Throwable and is NOT used up by a placeholder in the message pattern
+   * it is returned in {@link #getThrowable()} and won't be contained in the created String[]. If it
+   * is used up {@link #getThrowable()} will return null even if the last argument was a Throwable!
+   * </p>
-   * @param arguments      the argument array to be converted.
+   * @param arguments the argument array to be converted.
-      this.messagePattern = messagePattern;
-      this.stringArgs = parseArguments(arguments);
+    this.messagePattern = messagePattern;
+    this.stringArgs = parseArguments(arguments);
+   * 
-      this(messagePattern, new Object[]{arg});
+    this(messagePattern, new Object[] {arg});
+   * 
-  public GemFireParameterizedMessage(final String messagePattern, final Object arg1, final Object arg2) {
-      this(messagePattern, new Object[]{arg1, arg2});
+  public GemFireParameterizedMessage(final String messagePattern, final Object arg1,
+      final Object arg2) {
+    this(messagePattern, new Object[] {arg1, arg2});
-      if (arguments == null) {
-          return null;
-      }
-      final int argsCount = countArgumentPlaceholders(messagePattern);
-      int resultArgCount = arguments.length;
-      if (argsCount < arguments.length && throwable == null && arguments[arguments.length - 1] instanceof Throwable) {
-          throwable = (Throwable) arguments[arguments.length - 1];
-          resultArgCount--;
-      }
-      argArray = new Object[resultArgCount];
-      System.arraycopy(arguments, 0, argArray, 0, resultArgCount);
+    if (arguments == null) {
+      return null;
+    }
+    final int argsCount = countArgumentPlaceholders(messagePattern);
+    int resultArgCount = arguments.length;
+    if (argsCount < arguments.length && throwable == null
+        && arguments[arguments.length - 1] instanceof Throwable) {
+      throwable = (Throwable) arguments[arguments.length - 1];
+      resultArgCount--;
+    }
+    argArray = new Object[resultArgCount];
+    System.arraycopy(arguments, 0, argArray, 0, resultArgCount);
-      String[] strArgs;
-      if (argsCount == 1 && throwable == null && arguments.length > 1) {
-          // special case
-          strArgs = new String[1];
-          strArgs[0] = deepToString(arguments);
-      } else {
-          strArgs = new String[resultArgCount];
-          for (int i = 0; i < strArgs.length; i++) {
-              strArgs[i] = deepToString(arguments[i]);
-          }
+    String[] strArgs;
+    if (argsCount == 1 && throwable == null && arguments.length > 1) {
+      // special case
+      strArgs = new String[1];
+      strArgs[0] = deepToString(arguments);
+    } else {
+      strArgs = new String[resultArgCount];
+      for (int i = 0; i < strArgs.length; i++) {
+        strArgs[i] = deepToString(arguments[i]);
-      return strArgs;
+    }
+    return strArgs;
+   * 
-      if (formattedMessage == null) {
-          formattedMessage = formatMessage(messagePattern, stringArgs);
-      }
-      return formattedMessage;
+    if (formattedMessage == null) {
+      formattedMessage = formatMessage(messagePattern, stringArgs);
+    }
+    return formattedMessage;
+   * 
-      return messagePattern;
+    return messagePattern;
+   * 
-      if (argArray != null) {
-          return argArray;
-      }
-      return stringArgs;
+    if (argArray != null) {
+      return argArray;
+    }
+    return stringArgs;
-   * Returns the Throwable that was given as the last argument, if any.
-   * It will not survive serialization. The Throwable exists as part of the message
-   * primarily so that it can be extracted from the end of the list of parameters
-   * and then be added to the LogEvent. As such, the Throwable in the event should
-   * not be used once the LogEvent has been constructed.
+   * Returns the Throwable that was given as the last argument, if any. It will not survive
+   * serialization. The Throwable exists as part of the message primarily so that it can be
+   * extracted from the end of the list of parameters and then be added to the LogEvent. As such,
+   * the Throwable in the event should not be used once the LogEvent has been constructed.
-      return throwable;
+    return throwable;
-      return format(msgPattern, sArgs);
+    return format(msgPattern, sArgs);
-      if (this == o) {
-          return true;
-      }
-      if (o == null || getClass() != o.getClass()) {
-          return false;
-      }
-
-      final GemFireParameterizedMessage that = (GemFireParameterizedMessage) o;
-
-      if (messagePattern != null ? !messagePattern.equals(that.messagePattern) : that.messagePattern != null) {
-          return false;
-      }
-      if (!Arrays.equals(stringArgs, that.stringArgs)) {
-          return false;
-      }
-      //if (throwable != null ? !throwable.equals(that.throwable) : that.throwable != null) return false;
-
+    if (this == o) {
+    }
+    if (o == null || getClass() != o.getClass()) {
+      return false;
+    }
+
+    final GemFireParameterizedMessage that = (GemFireParameterizedMessage) o;
+
+    if (messagePattern != null ? !messagePattern.equals(that.messagePattern)
+        : that.messagePattern != null) {
+      return false;
+    }
+    if (!Arrays.equals(stringArgs, that.stringArgs)) {
+      return false;
+    }
+    // if (throwable != null ? !throwable.equals(that.throwable) : that.throwable != null) return
+    // false;
+
+    return true;
-      int result = messagePattern != null ? messagePattern.hashCode() : 0;
-      result = HASHVAL * result + (stringArgs != null ? Arrays.hashCode(stringArgs) : 0);
-      return result;
+    int result = messagePattern != null ? messagePattern.hashCode() : 0;
+    result = HASHVAL * result + (stringArgs != null ? Arrays.hashCode(stringArgs) : 0);
+    return result;
-   * @param arguments      the arguments to be used to replace placeholders.
+   * @param arguments the arguments to be used to replace placeholders.
-      if (messagePattern == null || arguments == null || arguments.length == 0) {
-          return messagePattern;
-      }
+    if (messagePattern == null || arguments == null || arguments.length == 0) {
+      return messagePattern;
+    }
-      final StringBuilder result = new StringBuilder();
-      int escapeCounter = 0;
-      int currentArgument = 0;
-      for (int i = 0; i < messagePattern.length(); i++) {
-          final char curChar = messagePattern.charAt(i);
-          if (curChar == ESCAPE_CHAR) {
-              escapeCounter++;
-          } else {
-              if (curChar == DELIM_START && i < messagePattern.length() - 1
-                      && messagePattern.charAt(i + 1) == DELIM_STOP) {
-                  // write escaped escape chars
-                  final int escapedEscapes = escapeCounter / 2;
-                  for (int j = 0; j < escapedEscapes; j++) {
-                      result.append(ESCAPE_CHAR);
-                  }
-
-                  if (escapeCounter % 2 == 1) {
-                      // i.e. escaped
-                      // write escaped escape chars
-                      result.append(DELIM_START);
-                      result.append(DELIM_STOP);
-                  } else {
-                      // unescaped
-                      if (currentArgument < arguments.length) {
-                          result.append(arguments[currentArgument]);
-                      } else {
-                          result.append(DELIM_START).append(DELIM_STOP);
-                      }
-                      currentArgument++;
-                  }
-                  i++;
-                  escapeCounter = 0;
-                  continue;
-              }
-              // any other char beside ESCAPE or DELIM_START/STOP-combo
-              // write unescaped escape chars
-              if (escapeCounter > 0) {
-                  for (int j = 0; j < escapeCounter; j++) {
-                      result.append(ESCAPE_CHAR);
-                  }
-                  escapeCounter = 0;
-              }
-              result.append(curChar);
+    final StringBuilder result = new StringBuilder();
+    int escapeCounter = 0;
+    int currentArgument = 0;
+    for (int i = 0; i < messagePattern.length(); i++) {
+      final char curChar = messagePattern.charAt(i);
+      if (curChar == ESCAPE_CHAR) {
+        escapeCounter++;
+      } else {
+        if (curChar == DELIM_START && i < messagePattern.length() - 1
+            && messagePattern.charAt(i + 1) == DELIM_STOP) {
+          // write escaped escape chars
+          final int escapedEscapes = escapeCounter / 2;
+          for (int j = 0; j < escapedEscapes; j++) {
+            result.append(ESCAPE_CHAR);
+
+          if (escapeCounter % 2 == 1) {
+            // i.e. escaped
+            // write escaped escape chars
+            result.append(DELIM_START);
+            result.append(DELIM_STOP);
+          } else {
+            // unescaped
+            if (currentArgument < arguments.length) {
+              result.append(arguments[currentArgument]);
+            } else {
+              result.append(DELIM_START).append(DELIM_STOP);
+            }
+            currentArgument++;
+          }
+          i++;
+          escapeCounter = 0;
+          continue;
+        }
+        // any other char beside ESCAPE or DELIM_START/STOP-combo
+        // write unescaped escape chars
+        if (escapeCounter > 0) {
+          for (int j = 0; j < escapeCounter; j++) {
+            result.append(ESCAPE_CHAR);
+          }
+          escapeCounter = 0;
+        }
+        result.append(curChar);
-      return result.toString();
+    }
+    return result.toString();
-      if (messagePattern == null) {
-          return 0;
-      }
+    if (messagePattern == null) {
+      return 0;
+    }
-      final int delim = messagePattern.indexOf(DELIM_START);
+    final int delim = messagePattern.indexOf(DELIM_START);
-      if (delim == -1) {
-          // special case, no placeholders at all.
-          return 0;
+    if (delim == -1) {
+      // special case, no placeholders at all.
+      return 0;
+    }
+    int result = 0;
+    boolean isEscaped = false;
+    for (int i = 0; i < messagePattern.length(); i++) {
+      final char curChar = messagePattern.charAt(i);
+      if (curChar == ESCAPE_CHAR) {
+        isEscaped = !isEscaped;
+      } else if (curChar == DELIM_START) {
+        if (!isEscaped && i < messagePattern.length() - 1
+            && messagePattern.charAt(i + 1) == DELIM_STOP) {
+          result++;
+          i++;
+        }
+        isEscaped = false;
+      } else {
+        isEscaped = false;
-      int result = 0;
-      boolean isEscaped = false;
-      for (int i = 0; i < messagePattern.length(); i++) {
-          final char curChar = messagePattern.charAt(i);
-          if (curChar == ESCAPE_CHAR) {
-              isEscaped = !isEscaped;
-          } else if (curChar == DELIM_START) {
-              if (!isEscaped && i < messagePattern.length() - 1 && messagePattern.charAt(i + 1) == DELIM_STOP) {
-                  result++;
-                  i++;
-              }
-              isEscaped = false;
-          } else {
-              isEscaped = false;
-          }
-      }
-      return result;
+    }
+    return result;
-   * This method performs a deep toString of the given Object.
-   * Primitive arrays are converted using their respective Arrays.toString methods while
-   * special handling is implemented for "container types", i.e. Object[], Map and Collection because those could
-   * contain themselves.
+   * This method performs a deep toString of the given Object. Primitive arrays are converted using
+   * their respective Arrays.toString methods while special handling is implemented for "container
+   * types", i.e. Object[], Map and Collection because those could contain themselves.
-   * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a
-   * behavior. They only check if the container is directly contained in itself, but not if a contained container
-   * contains the original one. Because of that, Arrays.toString(Object[]) isn't safe either.
-   * Confusing? Just read the last paragraph again and check the respective toString() implementation.
+   * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString()
+   * implement such a behavior. They only check if the container is directly contained in itself,
+   * but not if a contained container contains the original one. Because of that,
+   * Arrays.toString(Object[]) isn't safe either. Confusing? Just read the last paragraph again and
+   * check the respective toString() implementation.
-   * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)
-   * would produce a relatively hard-to-debug StackOverflowError.
+   * This means, in effect, that logging would produce a usable output even if an ordinary
+   * System.out.println(o) would produce a relatively hard-to-debug StackOverflowError.
+   * 
-      if (o == null) {
-          return null;
-      }
-      if (o instanceof String) {
-          return (String) o;
-      }
-      final StringBuilder str = new StringBuilder();
-      final Set<String> dejaVu = new HashSet<String>(); // that's actually a neat name ;)
-      recursiveDeepToString(o, str, dejaVu);
-      return str.toString();
+    if (o == null) {
+      return null;
+    }
+    if (o instanceof String) {
+      return (String) o;
+    }
+    final StringBuilder str = new StringBuilder();
+    final Set<String> dejaVu = new HashSet<String>(); // that's actually a neat name ;)
+    recursiveDeepToString(o, str, dejaVu);
+    return str.toString();
-   * This method performs a deep toString of the given Object.
-   * Primitive arrays are converted using their respective Arrays.toString methods while
-   * special handling is implemented for "container types", i.e. Object[], Map and Collection because those could
-   * contain themselves.
+   * This method performs a deep toString of the given Object. Primitive arrays are converted using
+   * their respective Arrays.toString methods while special handling is implemented for "container
+   * types", i.e. Object[], Map and Collection because those could contain themselves.
-   * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString() implement such a
-   * behavior.
-   * They only check if the container is directly contained in itself, but not if a contained container contains the
-   * original one. Because of that, Arrays.toString(Object[]) isn't safe either.
-   * Confusing? Just read the last paragraph again and check the respective toString() implementation.
+   * It should be noted that neither AbstractMap.toString() nor AbstractCollection.toString()
+   * implement such a behavior. They only check if the container is directly contained in itself,
+   * but not if a contained container contains the original one. Because of that,
+   * Arrays.toString(Object[]) isn't safe either. Confusing? Just read the last paragraph again and
+   * check the respective toString() implementation.
-   * This means, in effect, that logging would produce a usable output even if an ordinary System.out.println(o)
-   * would produce a relatively hard-to-debug StackOverflowError.
+   * This means, in effect, that logging would produce a usable output even if an ordinary
+   * System.out.println(o) would produce a relatively hard-to-debug StackOverflowError.
-   * @param o      the Object to convert into a String
-   * @param str    the StringBuilder that o will be appended to
+   * @param o the Object to convert into a String
+   * @param str the StringBuilder that o will be appended to
-  private static void recursiveDeepToString(final Object o, final StringBuilder str, final Set<String> dejaVu) {
-      if (o == null) {
-          str.append("null");
-          return;
-      }
-      if (o instanceof String) {
-          str.append(o);
-          return;
-      }
+  private static void recursiveDeepToString(final Object o, final StringBuilder str,
+      final Set<String> dejaVu) {
+    if (o == null) {
+      str.append("null");
+      return;
+    }
+    if (o instanceof String) {
+      str.append(o);
+      return;
+    }
-      final Class<?> oClass = o.getClass();
-      if (oClass.isArray()) {
-          if (oClass == byte[].class) {
-              str.append(Arrays.toString((byte[]) o));
-          } else if (oClass == short[].class) {
-              str.append(Arrays.toString((short[]) o));
-          } else if (oClass == int[].class) {
-              str.append(Arrays.toString((int[]) o));
-          } else if (oClass == long[].class) {
-              str.append(Arrays.toString((long[]) o));
-          } else if (oClass == float[].class) {
-              str.append(Arrays.toString((float[]) o));
-          } else if (oClass == double[].class) {
-              str.append(Arrays.toString((double[]) o));
-          } else if (oClass == boolean[].class) {
-              str.append(Arrays.toString((boolean[]) o));
-          } else if (oClass == char[].class) {
-              str.append(Arrays.toString((char[]) o));
-          } else {
-              // special handling of container Object[]
-              final String id = identityToString(o);
-              if (dejaVu.contains(id)) {
-                  str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);
-              } else {
-                  dejaVu.add(id);
-                  final Object[] oArray = (Object[]) o;
-                  str.append('[');
-                  boolean first = true;
-                  for (final Object current : oArray) {
-                      if (first) {
-                          first = false;
-                      } else {
-                          str.append(", ");
-                      }
-                      recursiveDeepToString(current, str, new HashSet<String>(dejaVu));
-                  }
-                  str.append(']');
-              }
-              //str.append(Arrays.deepToString((Object[]) o));
-          }
-      } else if (o instanceof Map && !(o instanceof Region)) { // GEODE: do NOT use Map handling if instanceof Geode Region
-          // special handling of container Map
-          final String id = identityToString(o);
-          if (dejaVu.contains(id)) {
-              str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);
-          } else {
-              dejaVu.add(id);
-              final Map<?, ?> oMap = (Map<?, ?>) o;
-              str.append('{');
-              boolean isFirst = true;
-              for (final Object o1 : oMap.entrySet()) {
-                  final Map.Entry<?, ?> current = (Map.Entry<?, ?>) o1;
-                  if (isFirst) {
-                      isFirst = false;
-                  } else {
-                      str.append(", ");
-                  }
-                  final Object key = current.getKey();
-                  final Object value = current.getValue();
-                  recursiveDeepToString(key, str, new HashSet<String>(dejaVu));
-                  str.append('=');
-                  recursiveDeepToString(value, str, new HashSet<String>(dejaVu));
-              }
-              str.append('}');
-          }
-      } else if (o instanceof Collection && !(o instanceof EntriesSet)) { // GEODE: do NOT use Colleciton handling if instanceof Geode EntriesSet
-          // special handling of container Collection
-          final String id = identityToString(o);
-          if (dejaVu.contains(id)) {
-              str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);
-          } else {
-              dejaVu.add(id);
-              final Collection<?> oCol = (Collection<?>) o;
-              str.append('[');
-              boolean isFirst = true;
-              for (final Object anOCol : oCol) {
-                  if (isFirst) {
-                      isFirst = false;
-                  } else {
-                      str.append(", ");
-                  }
-                  recursiveDeepToString(anOCol, str, new HashSet<String>(dejaVu));
-              }
-              str.append(']');
-          }
-      } else if (o instanceof Date) {
-          final Date date = (Date) o;
-          final SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
-          // I'll leave it like this for the moment... this could probably be optimized using ThreadLocal...
-          str.append(format.format(date));
+    final Class<?> oClass = o.getClass();
+    if (oClass.isArray()) {
+      if (oClass == byte[].class) {
+        str.append(Arrays.toString((byte[]) o));
+      } else if (oClass == short[].class) {
+        str.append(Arrays.toString((short[]) o));
+      } else if (oClass == int[].class) {
+        str.append(Arrays.toString((int[]) o));
+      } else if (oClass == long[].class) {
+        str.append(Arrays.toString((long[]) o));
+      } else if (oClass == float[].class) {
+        str.append(Arrays.toString((float[]) o));
+      } else if (oClass == double[].class) {
+        str.append(Arrays.toString((double[]) o));
+      } else if (oClass == boolean[].class) {
+        str.append(Arrays.toString((boolean[]) o));
+      } else if (oClass == char[].class) {
+        str.append(Arrays.toString((char[]) o));
-          // it's just some other Object, we can only use toString().
-          try {
-              str.append(o.toString());
-          } catch (final Throwable t) {
-              str.append(ERROR_PREFIX);
-              str.append(identityToString(o));
-              str.append(ERROR_SEPARATOR);
-              final String msg = t.getMessage();
-              final String className = t.getClass().getName();
-              str.append(className);
-              if (!className.equals(msg)) {
-                  str.append(ERROR_MSG_SEPARATOR);
-                  str.append(msg);
-              }
-              str.append(ERROR_SUFFIX);
+        // special handling of container Object[]
+        final String id = identityToString(o);
+        if (dejaVu.contains(id)) {
+          str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);
+        } else {
+          dejaVu.add(id);
+          final Object[] oArray = (Object[]) o;
+          str.append('[');
+          boolean first = true;
+          for (final Object current : oArray) {
+            if (first) {
+              first = false;
+            } else {
+              str.append(", ");
+            }
+            recursiveDeepToString(current, str, new HashSet<String>(dejaVu));
+          str.append(']');
+        }
+        // str.append(Arrays.deepToString((Object[]) o));
+    } else if (o instanceof Map && !(o instanceof Region)) { // GEODE: do NOT use Map handling if
+                                                             // instanceof Geode Region
+      // special handling of container Map
+      final String id = identityToString(o);
+      if (dejaVu.contains(id)) {
+        str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);
+      } else {
+        dejaVu.add(id);
+        final Map<?, ?> oMap = (Map<?, ?>) o;
+        str.append('{');
+        boolean isFirst = true;
+        for (final Object o1 : oMap.entrySet()) {
+          final Map.Entry<?, ?> current = (Map.Entry<?, ?>) o1;
+          if (isFirst) {
+            isFirst = false;
+          } else {
+            str.append(", ");
+          }
+          final Object key = current.getKey();
+          final Object value = current.getValue();
+          recursiveDeepToString(key, str, new HashSet<String>(dejaVu));
+          str.append('=');
+          recursiveDeepToString(value, str, new HashSet<String>(dejaVu));
+        }
+        str.append('}');
+      }
+    } else if (o instanceof Collection && !(o instanceof EntriesSet)) { // GEODE: do NOT use
+                                                                        // Colleciton handling if
+                                                                        // instanceof Geode
+                                                                        // EntriesSet
+      // special handling of container Collection
+      final String id = identityToString(o);
+      if (dejaVu.contains(id)) {
+        str.append(RECURSION_PREFIX).append(id).append(RECURSION_SUFFIX);
+      } else {
+        dejaVu.add(id);
+        final Collection<?> oCol = (Collection<?>) o;
+        str.append('[');
+        boolean isFirst = true;
+        for (final Object anOCol : oCol) {
+          if (isFirst) {
+            isFirst = false;
+          } else {
+            str.append(", ");
+          }
+          recursiveDeepToString(anOCol, str, new HashSet<String>(dejaVu));
+        }
+        str.append(']');
+      }
+    } else if (o instanceof Date) {
+      final Date date = (Date) o;
+      final SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
+      // I'll leave it like this for the moment... this could probably be optimized using
+      // ThreadLocal...
+      str.append(format.format(date));
+    } else {
+      // it's just some other Object, we can only use toString().
+      try {
+        str.append(o.toString());
+      } catch (final Throwable t) {
+        str.append(ERROR_PREFIX);
+        str.append(identityToString(o));
+        str.append(ERROR_SEPARATOR);
+        final String msg = t.getMessage();
+        final String className = t.getClass().getName();
+        str.append(className);
+        if (!className.equals(msg)) {
+          str.append(ERROR_MSG_SEPARATOR);
+          str.append(msg);
+        }
+        str.append(ERROR_SUFFIX);
+      }
+    }
-   * This method returns the same as if Object.toString() would not have been
-   * overridden in obj.
+   * This method returns the same as if Object.toString() would not have been overridden in obj.
-   * <blockquote>
-   * As much as is reasonably practical, the hashCode method defined by
-   * class {@code Object} does return distinct integers for distinct
-   * objects. (This is typically implemented by converting the internal
-   * address of the object into an integer, but this implementation
-   * technique is not required by the Java&#8482; programming language.)
+   * <blockquote> As much as is reasonably practical, the hashCode method defined by class
+   * {@code Object} does return distinct integers for distinct objects. (This is typically
+   * implemented by converting the internal address of the object into an integer, but this
+   * implementation technique is not required by the Java&#8482; programming language.)
-      if (obj == null) {
-          return null;
-      }
-      return obj.getClass().getName() + '@' + Integer.toHexString(System.identityHashCode(obj));
+    if (obj == null) {
+      return null;
+    }
+    return obj.getClass().getName() + '@' + Integer.toHexString(System.identityHashCode(obj));
-      return "GemFireParameterizedMessage[messagePattern=" + messagePattern + ", stringArgs=" +
-          Arrays.toString(stringArgs) + ", throwable=" + throwable + ']'; // GEODE: adjust toString to GemFireParameterizedMessage
+    return "GemFireParameterizedMessage[messagePattern=" + messagePattern + ", stringArgs="
+        + Arrays.toString(stringArgs) + ", throwable=" + throwable + ']'; // GEODE: adjust toString
+                                                                          // to
+                                                                          // GemFireParameterizedMessage

UPD66 UPD66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
ByteArrayWrapper now implementes DataSerializableFixedID which should save us 40 bytes each time it is serialized. (#5180)

- It no longer caches its "hash" and "string" form which will cut down its memory overhead by over 70%.
- When we convert a sequence of bytes to a String, the Coder no longer calls intern which will also save some memory and time.
-import org.apache.geode.DataSerializable;
+import org.apache.geode.internal.serialization.DataSerializableFixedID;
+import org.apache.geode.internal.serialization.DeserializationContext;
+import org.apache.geode.internal.serialization.SerializationContext;
+import org.apache.geode.internal.serialization.Version;
-public class ByteArrayWrapper implements DataSerializable, Comparable<ByteArrayWrapper> {
-  /**
-   * Generated serialVerionUID
-   */
-  private static final long serialVersionUID = 9066391742266642992L;
-
+public class ByteArrayWrapper implements DataSerializableFixedID, Comparable<ByteArrayWrapper> {
-   * Hash of {@link #value}, this value is cached for performance
-   */
-  private transient int hashCode;
-
-  private transient String toString;
-
-  /**
-    this.hashCode = Arrays.hashCode(value);
-  }
-
-  @Override
-  public void toData(DataOutput out) throws IOException {
-    DataSerializer.writeByteArray(value, out);
-  }
-
-  @Override
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    this.value = DataSerializer.readByteArray(in);
-    this.hashCode = Arrays.hashCode(this.value);
-    if (toString == null) {
-      toString = Coder.bytesToString(this.value);
-    }
-    return toString;
+    return Coder.bytesToString(value);
-    this.toString = null;
-    this.hashCode = Arrays.hashCode(bytes);
-   * Hash code for byte[] wrapped by this object, the actual hashcode is determined by
-   * Arrays.hashCode(byte[])
+   * Hash code for byte[] wrapped by this object
-    return this.hashCode;
+    return Arrays.hashCode(value);
+
+  @Override
+  public int getDSFID() {
+    return DataSerializableFixedID.REDIS_BYTE_ARRAY_WRAPPER;
+  }
+
+  @Override
+  public void toData(DataOutput out, SerializationContext context) throws IOException {
+    DataSerializer.writeByteArray(value, out);
+  }
+
+  @Override
+  public void fromData(DataInput in, DeserializationContext context)
+      throws IOException, ClassNotFoundException {
+    value = DataSerializer.readByteArray(in);
+  }
+
+  @Override
+  public Version[] getSerializationVersions() {
+    return null;
+  }

MOV26 INS26 INS26 INS26 MOV31 MOV31 UPD40 INS40 INS40 INS40 UPD43 INS31 INS31 UPD42 MOV43 INS8 INS78 INS83 INS39 INS42 INS8 INS44 INS44 INS8 INS78 INS83 INS5 INS42 INS8 INS41 INS42 INS41 INS43 INS42 INS43 INS42 MOV21 INS42 INS43 INS85 INS41 INS32 UPD66 MOV32 INS40 INS42 INS42 INS42 INS33 MOV42 MOV42 INS42 INS42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL66 DEL42 DEL67 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL59 DEL23 DEL52 DEL42 DEL22 DEL7 DEL21 DEL42 DEL43 DEL42 DEL33 DEL27 DEL42 DEL52 DEL42 DEL22 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL66 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL52 DEL42 DEL22 DEL32 DEL7 DEL21 DEL8
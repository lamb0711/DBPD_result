Merge branch 'release/1.0.0-incubating.M3'

-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.EOFException;
-import java.io.File;
-import java.io.IOException;
-import java.io.StreamCorruptedException;
-import java.net.InetAddress;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.net.URL;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Properties;
+import com.gemstone.gemfire.CancelException;
+import com.gemstone.gemfire.DataSerializer;
+import com.gemstone.gemfire.SystemFailure;
+import com.gemstone.gemfire.distributed.internal.*;
+import com.gemstone.gemfire.internal.*;
+import com.gemstone.gemfire.internal.cache.GemFireCacheImpl;
+import com.gemstone.gemfire.internal.logging.LogService;
+import org.apache.logging.log4j.Logger;
+
+import javax.net.ssl.SSLException;
+import java.io.*;
+import java.net.*;
+import java.util.*;
-import javax.net.ssl.SSLException;
-
-import org.apache.logging.log4j.Logger;
-
-import com.gemstone.gemfire.CancelException;
-import com.gemstone.gemfire.DataSerializer;
-import com.gemstone.gemfire.SystemFailure;
-import com.gemstone.gemfire.distributed.internal.DistributionConfigImpl;
-import com.gemstone.gemfire.distributed.internal.DistributionStats;
-import com.gemstone.gemfire.distributed.internal.InternalDistributedSystem;
-import com.gemstone.gemfire.distributed.internal.PoolStatHelper;
-import com.gemstone.gemfire.distributed.internal.PooledExecutorWithDMStats;
-import com.gemstone.gemfire.distributed.internal.SharedConfiguration;
-import com.gemstone.gemfire.internal.DSFIDFactory;
-import com.gemstone.gemfire.internal.GemFireVersion;
-import com.gemstone.gemfire.internal.SocketCreator;
-import com.gemstone.gemfire.internal.Version;
-import com.gemstone.gemfire.internal.VersionedDataInputStream;
-import com.gemstone.gemfire.internal.VersionedDataOutputStream;
-import com.gemstone.gemfire.internal.cache.GemFireCacheImpl;
-import com.gemstone.gemfire.internal.i18n.LocalizedStrings;
-import com.gemstone.gemfire.internal.logging.LogService;
-
- * @since 5.7
- * 
+ * @since GemFire 5.7
-  private static int MAX_POOL_SIZE = Integer.getInteger("gemfire.TcpServer.MAX_POOL_SIZE", 100).intValue();
+  private static int MAX_POOL_SIZE = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "TcpServer.MAX_POOL_SIZE", 100).intValue();
-  
-  protected/*GemStoneAddition*/ final/*GemStoneAddition*/ static int READ_TIMEOUT = Integer.getInteger("gemfire.TcpServer.READ_TIMEOUT", 60 * 1000).intValue();
+
+  protected/*GemStoneAddition*/ final/*GemStoneAddition*/ static int READ_TIMEOUT = Integer
+      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "TcpServer.READ_TIMEOUT", 60 * 1000).intValue();
-  private static final int BACKLOG = Integer.getInteger("gemfire.TcpServer.BACKLOG", P2P_BACKLOG).intValue();
+  private static final int BACKLOG = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "TcpServer.BACKLOG", P2P_BACKLOG).intValue();
-   * @since 7.1
+   * @since GemFire 7.1
-    handler.init(this);
+    handler.init(this);
-        srv_sock = SocketCreator.getDefaultInstance().createServerSocket(port,
-            BACKLOG);
-        // srv_sock=new ServerSocket(port, 20); // backlog of 20 connections
+        srv_sock = SocketCreator.getDefaultInstance().createServerSocket(port, BACKLOG);
-      } else
-        srv_sock = SocketCreator.getDefaultInstance().createServerSocket(port,
-            BACKLOG, bind_address);
-      // srv_sock=new ServerSocket(port, 20, bind_address); // backlog of 20
-      // connections
-      {
-        if (log.isInfoEnabled())
-          log.info("Locator was created at " + new Date());
-        if (log.isInfoEnabled())
-          log.info("Listening on port " + port + " bound on address "
-              + bind_address);
+      } else {
+        srv_sock = SocketCreator.getDefaultInstance().createServerSocket(port, BACKLOG, bind_address);
+      }
+
+      if (log.isInfoEnabled()) {
+        log.info("Locator was created at " + new Date());
+        log.info("Listening on port " + getPort() + " bound on address " + bind_address);
+  /**
+   * Returns the value of the bound port. If the server was initialized with a port of 0 indicating that any
+   * ephemeral port should be used, this method will return the actual bound port.
+   *
+   * @return the port bound to this socket or 0 if the socket is closed or otherwise not connected
+   */
+  public int getPort() {
+    if (srv_sock != null && !srv_sock.isClosed()) {
+      return srv_sock.getLocalPort();
+    }
+
+    return 0;
+  }
+

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 UPD40 UPD40 UPD40 UPD40 UPD40 INS31 MOV21 INS29 INS83 INS39 INS42 INS8 UPD66 INS65 INS65 INS25 INS41 UPD66 INS66 INS66 INS66 INS27 INS8 INS34 INS27 INS27 INS27 MOV25 INS27 INS38 INS41 INS40 INS45 INS40 INS45 INS40 INS45 INS8 INS8 INS42 INS33 INS32 INS32 MOV21 MOV21 INS21 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS27 INS45 INS32 INS45 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL45 DEL45 DEL45 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL25 DEL8
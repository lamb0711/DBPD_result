Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Provides implementation of javax.naming.Context interface. A name in the
- * ContextImpl namespace is a sequence of one or more atomic names, relative to
- * a root initial context. When a name consist of more than one atomic names it
- * is a CompoundName where atomic names are separated with separator character -
- * '/' or '.'. It is possible to use both separator characters in the same name.
- * In such cases any occurrences of '.' are replaced with '/' before parsing.
- * This rule can be altered/modified by making changes in NameParserImpl class.
+ * Provides implementation of javax.naming.Context interface. A name in the ContextImpl namespace is
+ * a sequence of one or more atomic names, relative to a root initial context. When a name consist
+ * of more than one atomic names it is a CompoundName where atomic names are separated with
+ * separator character - '/' or '.'. It is possible to use both separator characters in the same
+ * name. In such cases any occurrences of '.' are replaced with '/' before parsing. This rule can be
+ * altered/modified by making changes in NameParserImpl class.
-  //  Name of this Context
+  // Name of this Context
-   * Creates new instance of ContextImpl. @param parentCtx parent context of
-   * this context. null if this is the root context. @param name atomic name for
-   * this context
+   * Creates new instance of ContextImpl. @param parentCtx parent context of this context. null if
+   * this is the root context. @param name atomic name for this context
-   *  
+   * 
-  public Object addToEnvironment(String key, Object value)
-      throws NamingException {
-    throw new NamingException(LocalizedStrings.ContextImpl_ADDTOENVIRONMENTSTRING_KEY_OBJECT_VALUE_IS_NOT_IMPLEMENTED.toLocalizedString());
+  public Object addToEnvironment(String key, Object value) throws NamingException {
+    throw new NamingException(
+        LocalizedStrings.ContextImpl_ADDTOENVIRONMENTSTRING_KEY_OBJECT_VALUE_IS_NOT_IMPLEMENTED
+            .toLocalizedString());
-   * Binds object to a name in this context. Intermediate contexts that do not
-   * exist will be created.
+   * Binds object to a name in this context. Intermediate contexts that do not exist will be
+   * created.
-   * @throws InvalidNameException if name is empty or is CompositeName that
-   *           spans more than one naming system.
-   * @throws NotContextException if name has more than one atomic name and
-   *           intermediate atomic name is bound to object that is not context.
+   * @throws InvalidNameException if name is empty or is CompositeName that spans more than one
+   *         naming system.
+   * @throws NotContextException if name has more than one atomic name and intermediate atomic name
+   *         is bound to object that is not context.
-   *  
+   * 
-  public void close() throws NamingException {
-  }
+  public void close() throws NamingException {}
-   * @param prefix name of this context Example: composeName("a","b") : b/a
-   *          composeName("a","") : a
-   *  
+   * @param prefix name of this context Example: composeName("a","b") : b/a composeName("a","") : a
+   * 
-   * @param prefix name of this context Example: composeName("a","b") : b/a
-   *          composeName("a","") : a
-   *  
+   * @param prefix name of this context Example: composeName("a","b") : b/a composeName("a","") : a
+   * 
-    return composeName(nameParser.parse(name), nameParser.parse(prefix))
-        .toString();
+    return composeName(nameParser.parse(name), nameParser.parse(prefix)).toString();
-   * @throws InvalidNameException if name is empty or is CompositeName that
-   *           spans more than one naming system.
+   * @throws InvalidNameException if name is empty or is CompositeName that spans more than one
+   *         naming system.
-   * @throws NotContextException if any intermediate name from name is not bound
-   *           to instance of javax.naming.Context.
-   *  
+   * @throws NotContextException if any intermediate name from name is not bound to instance of
+   *         javax.naming.Context.
+   * 
-    if (parsedName.size() == 0 || parsedName.get(0).length() == 0) { throw new InvalidNameException(LocalizedStrings.ContextImpl_NAME_CAN_NOT_BE_EMPTY.toLocalizedString()); }
+    if (parsedName.size() == 0 || parsedName.get(0).length() == 0) {
+      throw new InvalidNameException(
+          LocalizedStrings.ContextImpl_NAME_CAN_NOT_BE_EMPTY.toLocalizedString());
+    }
+      } else {
+        throw new NameAlreadyBoundException(
+            LocalizedStrings.ContextImpl_NAME_0_IS_ALREADY_BOUND.toLocalizedString(subContextName));
-      else {
-        throw new NameAlreadyBoundException(LocalizedStrings.ContextImpl_NAME_0_IS_ALREADY_BOUND.toLocalizedString(subContextName));
-      }
-    }
-    else {
+    } else {
-        return ((Context) boundObject)
-            .createSubcontext(parsedName.getSuffix(1));
-      }
-      else {
-        throw new NotContextException(LocalizedStrings.ContextImpl_EXPECTED_CONTEXT_BUT_FOUND_0.toLocalizedString(boundObject));
+        return ((Context) boundObject).createSubcontext(parsedName.getSuffix(1));
+      } else {
+        throw new NotContextException(LocalizedStrings.ContextImpl_EXPECTED_CONTEXT_BUT_FOUND_0
+            .toLocalizedString(boundObject));
-   *  
+   * 
-   * ContextNotEmptyException is thrown. Once a context is destroyed, the
-   * instance should not be used.
+   * ContextNotEmptyException is thrown. Once a context is destroyed, the instance should not be
+   * used.
-   * @throws InvalidNameException if name is empty or is CompositeName that
-   *           spans more than one naming system.
+   * @throws InvalidNameException if name is empty or is CompositeName that spans more than one
+   *         naming system.
-   * @throws NameNotFoundException if subcontext with name name can not be
-   *           found.
-   * @throws NotContextException if name is not bound to instance of
-   *           ContextImpl.
-   *  
+   * @throws NameNotFoundException if subcontext with name name can not be found.
+   * @throws NotContextException if name is not bound to instance of ContextImpl.
+   * 
-    if (parsedName.size() == 0 || parsedName.get(0).length() == 0) { throw new InvalidNameException(LocalizedStrings.ContextImpl_NAME_CAN_NOT_BE_EMPTY.toLocalizedString()); }
+    if (parsedName.size() == 0 || parsedName.get(0).length() == 0) {
+      throw new InvalidNameException(
+          LocalizedStrings.ContextImpl_NAME_CAN_NOT_BE_EMPTY.toLocalizedString());
+    }
-    if (boundObject == null) { throw new NameNotFoundException(LocalizedStrings.ContextImpl_NAME_0_NOT_FOUND_IN_THE_CONTEXT.toLocalizedString(subContextName)); }
-    if (!(boundObject instanceof ContextImpl)) { throw new NotContextException(); }
+    if (boundObject == null) {
+      throw new NameNotFoundException(LocalizedStrings.ContextImpl_NAME_0_NOT_FOUND_IN_THE_CONTEXT
+          .toLocalizedString(subContextName));
+    }
+    if (!(boundObject instanceof ContextImpl)) {
+      throw new NotContextException();
+    }
+      } else {
+        throw new ContextNotEmptyException(
+            LocalizedStrings.ContextImpl_CAN_NOT_DESTROY_NONEMPTY_CONTEXT.toLocalizedString());
-      else {
-        throw new ContextNotEmptyException(LocalizedStrings.ContextImpl_CAN_NOT_DESTROY_NONEMPTY_CONTEXT.toLocalizedString());
-      }
-    }
-    else {
+    } else {
-   *  
+   * 
-    throw new NamingException(LocalizedStrings.ContextImpl_GETENVIRONMENT_IS_NOT_IMPLEMENTED.toLocalizedString());
+    throw new NamingException(
+        LocalizedStrings.ContextImpl_GETENVIRONMENT_IS_NOT_IMPLEMENTED.toLocalizedString());
-   *  
+   * 
-    throw new NamingException(LocalizedStrings.ContextImpl_GETNAMEINNAMESPACE_IS_NOT_IMPLEMENTED.toLocalizedString());
+    throw new NamingException(
+        LocalizedStrings.ContextImpl_GETNAMEINNAMESPACE_IS_NOT_IMPLEMENTED.toLocalizedString());
-   *  
+   * 
-   *  
+   * 
-   * @return NamingEnumeration of all name-class pairs. Each element from the
-   *         enumeration is instance of NameClassPair
+   * @return NamingEnumeration of all name-class pairs. Each element from the enumeration is
+   *         instance of NameClassPair
-   *  
+   * 
-   * @return NamingEnumeration of all name-class pairs. Each element from the
-   *         enumeration is instance of NameClassPair
+   * @return NamingEnumeration of all name-class pairs. Each element from the enumeration is
+   *         instance of NameClassPair
-   *  
+   * 
-   * Lists all bindings for Context with name name. If name is empty then this
-   * Context is assumed.
+   * Lists all bindings for Context with name name. If name is empty then this Context is assumed.
-   * @return NamingEnumeration of all name-object pairs. Each element from the
-   *         enumeration is instance of Binding.
+   * @return NamingEnumeration of all name-object pairs. Each element from the enumeration is
+   *         instance of Binding.
-   * @throws InvalidNameException if name is CompositeName that spans more than
-   *           one naming system
+   * @throws InvalidNameException if name is CompositeName that spans more than one naming system
-   * @throws NotContextException component of name is not bound to instance of
-   *           ContextImpl, when name is not an atomic name
+   * @throws NotContextException component of name is not bound to instance of ContextImpl, when
+   *         name is not an atomic name
-   *  
+   * 
-    }
-    else {
+    } else {
-    	Name nextLayer = nameParser.parse("");
+        Name nextLayer = nameParser.parse("");
-    	if (parsedName.size() > 1) {
-    	  nextLayer = parsedName.getSuffix(1);
-    	}
-    	return ((Context) subContext).list(nextLayer);
+        if (parsedName.size() > 1) {
+          nextLayer = parsedName.getSuffix(1);
+        }
+        return ((Context) subContext).list(nextLayer);
-        throw new NameNotFoundException(LocalizedStrings.ContextImpl_NAME_0_NOT_FOUND.toLocalizedString(name));
-      }
-      else {
-        throw new NotContextException(LocalizedStrings.ContextImpl_EXPECTED_CONTEXT_BUT_FOUND_0.toLocalizedString(subContext));
+        throw new NameNotFoundException(
+            LocalizedStrings.ContextImpl_NAME_0_NOT_FOUND.toLocalizedString(name));
+      } else {
+        throw new NotContextException(LocalizedStrings.ContextImpl_EXPECTED_CONTEXT_BUT_FOUND_0
+            .toLocalizedString(subContext));
-   * Lists all bindings for Context with name name. If name is empty then this
-   * Context is assumed.
+   * Lists all bindings for Context with name name. If name is empty then this Context is assumed.
-   * @return NamingEnumeration of all name-object pairs. Each element from the
-   *         enumeration is instance of Binding.
+   * @return NamingEnumeration of all name-object pairs. Each element from the enumeration is
+   *         instance of Binding.
-   * @throws InvalidNameException if name is CompositeName that spans more than
-   *           one naming system
+   * @throws InvalidNameException if name is CompositeName that spans more than one naming system
-   * @throws NotContextException component of name is not bound to instance of
-   *           ContextImpl, when name is not an atomic name
+   * @throws NotContextException component of name is not bound to instance of ContextImpl, when
+   *         name is not an atomic name
-   *  
+   * 
-   * @throws InvalidNameException if name is CompositeName that spans more than
-   *           one naming system
+   * @throws InvalidNameException if name is CompositeName that spans more than one naming system
-   * @throws NotContextException component of name is not bound to instance of
-   *           ContextImpl, when name is not atomic name.
+   * @throws NotContextException component of name is not bound to instance of ContextImpl, when
+   *         name is not atomic name.
-   *  
+   * 
-        throw new NameNotFoundException(LocalizedStrings.ContextImpl_NAME_0_NOT_FOUND.toLocalizedString(name));
+        throw new NameNotFoundException(
+            LocalizedStrings.ContextImpl_NAME_0_NOT_FOUND.toLocalizedString(name));
-        }
-        else {
-          throw new NotContextException(LocalizedStrings.ContextImpl_EXPECTED_CONTEXTIMPL_BUT_FOUND_0.toLocalizedString(res));
+        } else {
+          throw new NotContextException(
+              LocalizedStrings.ContextImpl_EXPECTED_CONTEXTIMPL_BUT_FOUND_0.toLocalizedString(res));
-    }
-    catch (NameNotFoundException e) {
+    } catch (NameNotFoundException e) {
-      if (writer.infoEnabled()) writer.info(LocalizedStrings.ContextImpl_CONTEXTIMPL_LOOKUP_ERROR_WHILE_LOOKING_UP_0, name, e); 
-      throw new NameNotFoundException(LocalizedStrings.ContextImpl_NAME_0_NOT_FOUND.toLocalizedString(new Object[] {name}));
-    }
-    catch (SystemException se) {
+      if (writer.infoEnabled())
+        writer.info(LocalizedStrings.ContextImpl_CONTEXTIMPL_LOOKUP_ERROR_WHILE_LOOKING_UP_0, name,
+            e);
+      throw new NameNotFoundException(
+          LocalizedStrings.ContextImpl_NAME_0_NOT_FOUND.toLocalizedString(new Object[] {name}));
+    } catch (SystemException se) {
-      if (writer.severeEnabled()) writer.info(LocalizedStrings.ContextImpl_CONTEXTIMPL_LOOKUP_ERROR_WHILE_CREATING_USERTRANSACTION_OBJECT, se);
-      throw new NameNotFoundException(LocalizedStrings.ContextImpl_CONTEXTIMPL_LOOKUP_ERROR_WHILE_CREATING_USERTRANSACTION_OBJECT.toLocalizedString());
+      if (writer.severeEnabled())
+        writer.info(
+            LocalizedStrings.ContextImpl_CONTEXTIMPL_LOOKUP_ERROR_WHILE_CREATING_USERTRANSACTION_OBJECT,
+            se);
+      throw new NameNotFoundException(
+          LocalizedStrings.ContextImpl_CONTEXTIMPL_LOOKUP_ERROR_WHILE_CREATING_USERTRANSACTION_OBJECT
+              .toLocalizedString());
-   * Looks up the object in this context. If the object is not found and the
-   * remote context was provided, calls the remote context to lookup the object.
+   * Looks up the object in this context. If the object is not found and the remote context was
+   * provided, calls the remote context to lookup the object.
-   *  
+   * 
-    }
-    catch (NameNotFoundException e) {
+    } catch (NameNotFoundException e) {
-      if (writer.infoEnabled()) writer.info(LocalizedStrings.ContextImpl_CONTEXTIMPL_LOOKUP_ERROR_WHILE_LOOKING_UP_0, name, e);
-      throw new NameNotFoundException(LocalizedStrings.ContextImpl_NAME_0_NOT_FOUND.toLocalizedString(new Object[] {name}));
+      if (writer.infoEnabled())
+        writer.info(LocalizedStrings.ContextImpl_CONTEXTIMPL_LOOKUP_ERROR_WHILE_LOOKING_UP_0, name,
+            e);
+      throw new NameNotFoundException(
+          LocalizedStrings.ContextImpl_NAME_0_NOT_FOUND.toLocalizedString(new Object[] {name}));
-   *  
+   * 
-    throw new NamingException(LocalizedStrings.ContextImpl_LOOKUPLINKNAME_NAME_IS_NOT_IMPLEMENTED.toLocalizedString());
+    throw new NamingException(
+        LocalizedStrings.ContextImpl_LOOKUPLINKNAME_NAME_IS_NOT_IMPLEMENTED.toLocalizedString());
-   *  
+   * 
-    throw new NamingException(LocalizedStrings.ContextImpl_LOOKUPLINKSTRING_NAME_IS_NOT_IMPLEMENTED.toLocalizedString());
+    throw new NamingException(
+        LocalizedStrings.ContextImpl_LOOKUPLINKSTRING_NAME_IS_NOT_IMPLEMENTED.toLocalizedString());
-   * Rebinds object obj to name name . If there is existing binding it will be
-   * overwritten.
+   * Rebinds object obj to name name . If there is existing binding it will be overwritten.
-   * @throws InvalidNameException if name is empty or is CompositeName that
-   *           spans more than one naming system
-   * @throws NotContextException if name has more than one atomic name and
-   *           intermediate context is not found
+   * @throws InvalidNameException if name is empty or is CompositeName that spans more than one
+   *         naming system
+   * @throws NotContextException if name has more than one atomic name and intermediate context is
+   *         not found
-   *  
+   * 
-    if (parsedName.size() == 0 || parsedName.get(0).length() == 0) { throw new InvalidNameException(LocalizedStrings.ContextImpl_NAME_CAN_NOT_BE_EMPTY.toLocalizedString()); }
+    if (parsedName.size() == 0 || parsedName.get(0).length() == 0) {
+      throw new InvalidNameException(
+          LocalizedStrings.ContextImpl_NAME_CAN_NOT_BE_EMPTY.toLocalizedString());
+    }
-    }
-    else {
+    } else {
-      }
-      else {
+      } else {
-        }
-        else {
-          throw new NotContextException(LocalizedStrings.ContextImpl_EXPECTED_CONTEXT_BUT_FOUND_0.toLocalizedString(boundObject));
+        } else {
+          throw new NotContextException(LocalizedStrings.ContextImpl_EXPECTED_CONTEXT_BUT_FOUND_0
+              .toLocalizedString(boundObject));
-   * Rebinds object obj to String name. If there is existing binding it will be
-   * overwritten.
+   * Rebinds object obj to String name. If there is existing binding it will be overwritten.
-   * @throws InvalidNameException if name is empty or is CompositeName that
-   *           spans more than one naming system
-   * @throws NotContextException if name has more than one atomic name and
-   *           intermediate context is not found
+   * @throws InvalidNameException if name is empty or is CompositeName that spans more than one
+   *         naming system
+   * @throws NotContextException if name has more than one atomic name and intermediate context is
+   *         not found
-   *  
+   * 
-   *  
+   * 
-    throw new NamingException(LocalizedStrings.ContextImpl_REMOVEFROMENVIRONMENTSTRING_KEY_IS_NOT_IMPLEMENTED.toLocalizedString());
+    throw new NamingException(
+        LocalizedStrings.ContextImpl_REMOVEFROMENVIRONMENTSTRING_KEY_IS_NOT_IMPLEMENTED
+            .toLocalizedString());
-   *  
+   * 
-    throw new NamingException(LocalizedStrings.ContextImpl_RENAMENAME_NAME1_NAME_NAME2_IS_NOT_IMPLEMENTED.toLocalizedString());
+    throw new NamingException(
+        LocalizedStrings.ContextImpl_RENAMENAME_NAME1_NAME_NAME2_IS_NOT_IMPLEMENTED
+            .toLocalizedString());
-   *  
+   * 
-    throw new NamingException(LocalizedStrings.ContextImpl_RENAMESTRING_NAME1_STRING_NAME2_IS_NOT_IMPLEMENTED.toLocalizedString());
+    throw new NamingException(
+        LocalizedStrings.ContextImpl_RENAMESTRING_NAME1_STRING_NAME2_IS_NOT_IMPLEMENTED
+            .toLocalizedString());
-   * @throws InvalidNameException if name is empty or is CompositeName that
-   *           spans more than one naming system
+   * @throws InvalidNameException if name is empty or is CompositeName that spans more than one
+   *         naming system
-   * @throws NotContextException if name has more than one atomic name and
-   *           intermediate context is not found.
+   * @throws NotContextException if name has more than one atomic name and intermediate context is
+   *         not found.
-   *  
+   * 
-    if (parsedName.size() == 0 || parsedName.get(0).length() == 0) { throw new InvalidNameException(LocalizedStrings.ContextImpl_NAME_CAN_NOT_BE_EMPTY.toLocalizedString()); }
+    if (parsedName.size() == 0 || parsedName.get(0).length() == 0) {
+      throw new InvalidNameException(
+          LocalizedStrings.ContextImpl_NAME_CAN_NOT_BE_EMPTY.toLocalizedString());
+    }
-    }
-    else {
-      //        	 scenerio unbind a/b or a/b/c
-      //        	 remove b and its associated object
+    } else {
+      // scenerio unbind a/b or a/b/c
+      // remove b and its associated object
-        //                remove b and its associated object
+        // remove b and its associated object
-      }
-      else {
-        // 			if the name is not found then throw exception
-        if (!ctxMaps.containsKey(nameToRemove)) { throw new NameNotFoundException(LocalizedStrings.ContextImpl_CAN_NOT_FIND_0.toLocalizedString(name)); }
-        throw new NotContextException(LocalizedStrings.ContextImpl_EXPECTED_CONTEXT_BUT_FOUND_0.toLocalizedString(boundObject));
+      } else {
+        // if the name is not found then throw exception
+        if (!ctxMaps.containsKey(nameToRemove)) {
+          throw new NameNotFoundException(
+              LocalizedStrings.ContextImpl_CAN_NOT_FIND_0.toLocalizedString(name));
+        }
+        throw new NotContextException(LocalizedStrings.ContextImpl_EXPECTED_CONTEXT_BUT_FOUND_0
+            .toLocalizedString(boundObject));
-   * @throws InvalidNameException if name is empty or is CompositeName that
-   *           spans more than one naming system
+   * @throws InvalidNameException if name is empty or is CompositeName that spans more than one
+   *         naming system
-   * @throws NotContextException if name has more than one atomic name and
-   *           intermediate context is not found.
+   * @throws NotContextException if name has more than one atomic name and intermediate context is
+   *         not found.
-   *  
+   * 
-   * Checks if this context has been destroyed. isDestroyed is set to true when
-   * a context is destroyed by calling destroySubcontext method.
+   * Checks if this context has been destroyed. isDestroyed is set to true when a context is
+   * destroyed by calling destroySubcontext method.
-    if (isDestroyed) { throw new NoPermissionException(LocalizedStrings.ContextImpl_CAN_NOT_INVOKE_OPERATIONS_ON_DESTROYED_CONTEXT.toLocalizedString()); }
+    if (isDestroyed) {
+      throw new NoPermissionException(
+          LocalizedStrings.ContextImpl_CAN_NOT_INVOKE_OPERATIONS_ON_DESTROYED_CONTEXT
+              .toLocalizedString());
+    }
-   * Parses name which is CompositeName or CompoundName . If name is not
-   * CompositeName then it is assumed to be CompoundName. If the name contains
-   * leading and/or terminal empty components, they will not be included in the
-   * result.
+   * Parses name which is CompositeName or CompoundName . If name is not CompositeName then it is
+   * assumed to be CompoundName. If the name contains leading and/or terminal empty components, they
+   * will not be included in the result.
-   * @throws InvalidNameException if name is CompositeName and spans more than
-   *           one name space.
+   * @throws InvalidNameException if name is CompositeName and spans more than one name space.
+      } else if (name.size() > 1) {
+        throw new InvalidNameException(
+            LocalizedStrings.ContextImpl_MULTIPLE_NAME_SYSTEMS_ARE_NOT_SUPPORTED
+                .toLocalizedString());
-      else if (name.size() > 1) { throw new InvalidNameException(LocalizedStrings.ContextImpl_MULTIPLE_NAME_SYSTEMS_ARE_NOT_SUPPORTED.toLocalizedString()); }
-    }
-    else {
+    } else {
-      if (result.get(i).length() == 0) { throw new InvalidNameException(LocalizedStrings.ContextImpl_EMPTY_INTERMEDIATE_COMPONENTS_ARE_NOT_SUPPORTED.toLocalizedString()); }
+      if (result.get(i).length() == 0) {
+        throw new InvalidNameException(
+            LocalizedStrings.ContextImpl_EMPTY_INTERMEDIATE_COMPONENTS_ARE_NOT_SUPPORTED
+                .toLocalizedString());
+      }
-   * Returns the compound string name of this context. Suppose a/b/c/d is the
-   * full name and this context is "c". It's compound string name is a/b/c
+   * Returns the compound string name of this context. Suppose a/b/c/d is the full name and this
+   * context is "c". It's compound string name is a/b/c
-    //StringBuffer compositeName = new StringBuffer();
+    // StringBuffer compositeName = new StringBuffer();
+   * 
-   * Returns true if this context is the root context @return true if the
-   * context is the root context
+   * Returns true if this context is the root context @return true if the context is the root
+   * context
-      if (currentElement < elements.size()) { return true; }
+      if (currentElement < elements.size()) {
+        return true;
+      }
-      if (hasMoreElements()) { return elements.get(currentElement++); }
+      if (hasMoreElements()) {
+        return elements.get(currentElement++);
+      }

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
GEODE-2420: Resolve conflicts with recent checkin

Use InternalCache instead of GemnFireCachImpl.

Refactored product and tests
- Combined LogExporter and LogSizer.
- Remove classes no longer needed

-import org.apache.geode.management.internal.cli.functions.ExportedLogsSizeInfo;
-  private InternalCache getCache() {
+  InternalCache getCache() {
-          long diskAvailable = 0;
-          long diskSize = 0;
-            if (res.get(0) instanceof ExportedLogsSizeInfo) {
-              ExportedLogsSizeInfo sizeInfo = (ExportedLogsSizeInfo) res.get(0);
-              estimatedSize = sizeInfo.getLogsSize();
-              diskAvailable = sizeInfo.getDiskAvailable();
-              diskSize = sizeInfo.getDiskSize();
+            if (res.get(0) instanceof Long) {
+              estimatedSize = (Long) res.get(0);
-
-          // If export size checking is enabled, then estimated size on each member shouldn't exceed
-          // the available disk on that member
-          try {
-            isSizeCheckEnabledAndWithinDiskSpaceOfMember(server.getName(),
-                parseFileSizeLimit(fileSizeLimit), estimatedSize, diskAvailable, diskSize);
-          } catch (ManagementException e) {
-            return ResultBuilder.createUserErrorResult(e.getMessage());
-          }
-        // disk availble on the locator
+        // disk available on the locator
-          isSizeCheckEnabledAndWithinDiskSpaceOfMember("locator", parseFileSizeLimit(fileSizeLimit),
-              totalEstimatedExportSize, getLocalDiskAvailable(), getLocalDiskSize());
+          sizeCheckIsEnabledAndWithinDiskSpaceOfMember("locator", parseFileSizeLimit(fileSizeLimit),
+              totalEstimatedExportSize, getLocalDiskAvailable());
-      if (testhookSkipExports()) {
-        result = ResultBuilder.createInfoResult("Estimated size of exported logs is "
-            + new BytesToString().of(totalEstimatedExportSize));
+      // get zipped files from all servers next
+      Map<String, Path> zipFilesFromMembers = new HashMap<>();
+      for (DistributedMember server : targetMembers) {
+        Region region = ExportLogsFunction.createOrGetExistingExportLogsRegion(true, cache);
+
+        ExportLogsCacheWriter cacheWriter =
+            (ExportLogsCacheWriter) region.getAttributes().getCacheWriter();
+
+        cacheWriter.startFile(server.getName());
+
+        CliUtil.executeFunction(new ExportLogsFunction(),
+            new ExportLogsFunction.Args(start, end, logLevel, onlyLogLevel, logsOnly, statsOnly),
+            server).getResult();
+        Path zipFile = cacheWriter.endFile();
+        ExportLogsFunction.destroyExportLogsRegion(cache);
+
+        // only put the zipfile in the map if it is not null
+        if (zipFile != null) {
+          logger.info("Received zip file from member {}: {}", server.getId(), zipFile);
+          zipFilesFromMembers.put(server.getId(), zipFile);
+        }
+      }
+
+      if (zipFilesFromMembers.isEmpty()) {
+        return ResultBuilder.createUserErrorResult("No files to be exported.");
+      }
+
+      Path tempDir = Files.createTempDirectory("exportedLogs");
+      // make sure the directory is created, so that even if there is no files unzipped to this
+      // dir, we can still zip it and send an empty zip file back to the client
+      Path exportedLogsDir = tempDir.resolve("exportedLogs");
+      FileUtils.forceMkdir(exportedLogsDir.toFile());
+
+      for (Path zipFile : zipFilesFromMembers.values()) {
+        Path unzippedMemberDir =
+            exportedLogsDir.resolve(zipFile.getFileName().toString().replace(".zip", ""));
+        ZipUtils.unzip(zipFile.toAbsolutePath().toString(), unzippedMemberDir.toString());
+        FileUtils.deleteQuietly(zipFile.toFile());
+      }
+
+      Path dirPath;
+      if (StringUtils.isBlank(dirName)) {
+        dirPath = Paths.get(System.getProperty("user.dir"));
-        // get zipped files from all servers next
-        Map<String, Path> zipFilesFromMembers = new HashMap<>();
-        for (DistributedMember server : targetMembers) {
-          Region region = ExportLogsFunction.createOrGetExistingExportLogsRegion(true, cache);
-
-          ExportLogsCacheWriter cacheWriter =
-              (ExportLogsCacheWriter) region.getAttributes().getCacheWriter();
-
-          cacheWriter.startFile(server.getName());
-
-          CliUtil.executeFunction(new ExportLogsFunction(),
-              new ExportLogsFunction.Args(start, end, logLevel, onlyLogLevel, logsOnly, statsOnly),
-              server).getResult();
-          Path zipFile = cacheWriter.endFile();
-          ExportLogsFunction.destroyExportLogsRegion(cache);
-
-          // only put the zipfile in the map if it is not null
-          if (zipFile != null) {
-            logger.info("Received zip file from member {}: {}", server.getId(), zipFile);
-            zipFilesFromMembers.put(server.getId(), zipFile);
-          }
-        }
-
-        if (zipFilesFromMembers.isEmpty()) {
-          return ResultBuilder.createUserErrorResult("No files to be exported.");
-        }
-
-        Path tempDir = Files.createTempDirectory("exportedLogs");
-        // make sure the directory is created, so that even if there is no files unzipped to this
-        // dir, we can still zip it and send an empty zip file back to the client
-        Path exportedLogsDir = tempDir.resolve("exportedLogs");
-        FileUtils.forceMkdir(exportedLogsDir.toFile());
-
-        for (Path zipFile : zipFilesFromMembers.values()) {
-          Path unzippedMemberDir =
-              exportedLogsDir.resolve(zipFile.getFileName().toString().replace(".zip", ""));
-          ZipUtils.unzip(zipFile.toAbsolutePath().toString(), unzippedMemberDir.toString());
-          FileUtils.deleteQuietly(zipFile.toFile());
-        }
-
-        Path dirPath;
-        if (StringUtils.isBlank(dirName)) {
-          dirPath = Paths.get(System.getProperty("user.dir"));
-        } else {
-          dirPath = Paths.get(dirName);
-        }
-        Path exportedLogsZipFile =
-            dirPath.resolve("exportedLogs_" + System.currentTimeMillis() + ".zip").toAbsolutePath();
-
-        logger.info("Zipping into: " + exportedLogsZipFile.toString());
-        ZipUtils.zipDirectory(exportedLogsDir, exportedLogsZipFile);
-        try {
-          isFileSizeCheckEnabledAndWithinLimit(parseFileSizeLimit(fileSizeLimit),
-              exportedLogsZipFile.toFile());
-        } catch (ManagementException e) {
-          return ResultBuilder.createUserErrorResult(e.getMessage());
-        } finally {
-          FileUtils.deleteDirectory(tempDir.toFile());
-        }
-        result = ResultBuilder.createInfoResult(exportedLogsZipFile.toString());
+        dirPath = Paths.get(dirName);
+      Path exportedLogsZipFile =
+          dirPath.resolve("exportedLogs_" + System.currentTimeMillis() + ".zip").toAbsolutePath();
+
+      logger.info("Zipping into: " + exportedLogsZipFile.toString());
+      ZipUtils.zipDirectory(exportedLogsDir, exportedLogsZipFile);
+      try {
+        isFileSizeCheckEnabledAndWithinLimit(parseFileSizeLimit(fileSizeLimit),
+            exportedLogsZipFile.toFile());
+      } catch (ManagementException e) {
+        FileUtils.deleteQuietly(exportedLogsZipFile.toFile());
+        return ResultBuilder.createUserErrorResult(e.getMessage());
+      } finally {
+        FileUtils.deleteDirectory(tempDir.toFile());
+      }
+      result = ResultBuilder.createInfoResult(exportedLogsZipFile.toString());
-   * Test hook for unit testing. To limit scope of test to only estimate size of exports (i.e. skip
-   * the filtering and exporting logs & stats from cluster members), stub this method to return true
-   * to skip exporting.
-   */
-  boolean testhookSkipExports() {
-    return false;
-  }
-
-  /**
-   *
-   * @return false == limit is zero (checking disabled)<br>
-   *         true == file size is less than limit<br>
-   *         exception == file size is over limit
-  boolean isFileSizeCheckEnabledAndWithinLimit(long fileSizeLimitBytes, File file) {
-    if (fileSizeLimitBytes < 1) {
-      // size checks disabled
-      return false;
+  void isFileSizeCheckEnabledAndWithinLimit(long fileSizeLimitBytes, File file) {
+    if (fileSizeLimitBytes > 0) {
+      if (FileUtils.sizeOf(file) > fileSizeLimitBytes) {
+        StringBuilder sb = new StringBuilder();
+        sb.append("Exported logs zip file size = ").append(FileUtils.sizeOf(file)).append(", ")
+            .append(CliStrings.EXPORT_LOGS__FILESIZELIMIT).append(" = ").append(fileSizeLimitBytes)
+            .append(
+                ". To disable exported logs file size check use option \"--file-size-limit=0\".");
+        throw new ManagementException(sb.toString()); // FileTooBigException
+      }
-    if (FileUtils.sizeOf(file) < fileSizeLimitBytes) {
-      return true;
-    }
-    StringBuilder sb = new StringBuilder();
-    sb.append("Exported logs zip file size = ").append(FileUtils.sizeOf(file)).append(", ")
-        .append(CliStrings.EXPORT_LOGS__FILESIZELIMIT).append(" = ").append(fileSizeLimitBytes)
-        .append(". To disable exported logs file size check use option \"--file-size-limit=0\".");
-    throw new ManagementException(sb.toString()); // FileTooBigException
+
-  boolean isSizeCheckEnabledAndWithinDiskSpaceOfMember(String memberName, long fileSizeLimitBytes,
-      long estimatedSize, long diskAvailable, long diskSize) {
-    // TODO:GEODE-2420: warn user if exportedLogs filtering will exceed disk available
-    if (fileSizeLimitBytes < 1) {
-      // size checks disabled
-      return false;
+  void sizeCheckIsEnabledAndWithinDiskSpaceOfMember(String memberName, long fileSizeLimitBytes,
+      long estimatedSize, long diskAvailable) {
+    if (fileSizeLimitBytes > 0) {
+      StringBuilder sb = new StringBuilder();
+      BytesToString bytesToString = new BytesToString();
+      if (estimatedSize > diskAvailable) {
+        sb.append("Estimated disk space required (").append(bytesToString.of(estimatedSize))
+            .append(") to consolidate logs on member ").append(memberName)
+            .append(" will exceed available disk space (").append(bytesToString.of(diskAvailable))
+            .append(")");
+        throw new ManagementException(sb.toString()); // FileTooBigException
+      }
-    StringBuilder sb = new StringBuilder();
-    BytesToString bytesToString = new BytesToString();
-    if (estimatedSize > diskAvailable) {
-      sb.append("Estimated disk space required (").append(bytesToString.of(estimatedSize))
-          .append(") to consolidate logs on member ").append(memberName)
-          .append(" will exceed available disk space (").append(bytesToString.of(diskAvailable))
-          .append(")");
-      throw new ManagementException(sb.toString()); // FileTooBigException
-    }
-    return true;

MOV8 UPD39 INS8 UPD39 UPD42 INS8 MOV60 MOV60 MOV60 INS54 MOV21 MOV41 INS25 INS25 MOV8 MOV12 MOV8 INS27 MOV8 INS27 MOV8 MOV60 MOV25 MOV25 INS42 INS34 INS42 INS34 MOV21 UPD27 MOV27 MOV7 MOV60 MOV21 MOV53 INS21 INS32 MOV42 UPD42 MOV42 INS42 INS42 INS32 UPD42 MOV42 UPD42 INS42 INS42 UPD43 UPD42 MOV11 UPD43 UPD42 DEL40 DEL26 DEL83 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8 DEL12 DEL54 DEL42 DEL32 DEL45 DEL42 DEL43 DEL14 DEL42 DEL32 DEL27 DEL32 DEL8 DEL25 DEL54 DEL8 DEL66 DEL66 DEL66 DEL65 DEL29 DEL39 DEL42 DEL9 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL34 DEL27 DEL9 DEL41 DEL9 DEL41 DEL8 DEL25 DEL42 DEL34 DEL27 DEL9 DEL41 DEL8 DEL25 DEL9 DEL41 DEL39 DEL42 DEL44
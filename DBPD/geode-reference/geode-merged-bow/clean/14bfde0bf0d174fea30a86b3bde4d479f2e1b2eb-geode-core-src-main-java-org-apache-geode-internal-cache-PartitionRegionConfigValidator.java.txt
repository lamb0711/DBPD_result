Merge branch 'release/1.8.0'

-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
-          LocalizedStrings.PartitionedRegion_TOTAL_SIZE_IN_PARTITIONATTRIBUTES_IS_INCOMPATIBLE_WITH_GLOBALLY_SET_TOTAL_SIZE_SET_THE_TOTAL_SIZE_TO_0MB
-              .toLocalizedString(Long.valueOf(prconfPA.getTotalSize())));
+          String.format(
+              "Total size in PartitionAttributes is incompatible with globally set total size. Set the total size to %sMB.",
+              Long.valueOf(prconfPA.getTotalSize())));
-          LocalizedStrings.PartitionedRegion_REQUESTED_REDUNDANCY_0_IS_INCOMPATIBLE_WITH_EXISTING_REDUNDANCY_1
-              .toLocalizedString(new Object[] {Integer.valueOf(userPA.getRedundantCopies()),
+          String.format("Requested redundancy %s is incompatible with existing redundancy %s",
+              new Object[] {Integer.valueOf(userPA.getRedundantCopies()),
-          LocalizedStrings.PartitionedRegion_SCOPE_IN_PARTITIONATTRIBUTES_IS_INCOMPATIBLE_WITH_ALREADY_SET_SCOPESET_THE_SCOPE_TO_0
-              .toLocalizedString(prconfScope));
+          String.format(
+              "Scope in PartitionAttributes is incompatible with already set scope.Set the scope to %s .",
+              prconfScope));
-          LocalizedStrings.PartitionedRegion_THE_TOTAL_NUMBER_OF_BUCKETS_FOUND_IN_PARTITIONATTRIBUTES_0_IS_INCOMPATIBLE_WITH_THE_TOTAL_NUMBER_OF_BUCKETS_USED_BY_OTHER_DISTRIBUTED_MEMBERS_SET_THE_NUMBER_OF_BUCKETS_TO_1
-              .toLocalizedString(new Object[] {Integer.valueOf(userPA.getTotalNumBuckets()),
+          String.format(
+              "The total number of buckets found in PartitionAttributes ( %s ) is incompatible with the total number of buckets used by other distributed members. Set the number of buckets to %s",
+              new Object[] {Integer.valueOf(userPA.getTotalNumBuckets()),
-          LocalizedStrings.PartitionRegionConfigValidator_INCOMPATIBLE_PARTITION_LISTENER
-              .toLocalizedString(new Object[] {null, prconfList}));
+          String.format(
+              "The PartitionListeners=%s are incompatible with the PartitionListeners=%s used by other distributed members.",
+              new Object[] {null, prconfList}));
-            LocalizedStrings.PartitionRegionConfigValidator_INCOMPATIBLE_PARTITION_LISTENER
-                .toLocalizedString(new Object[] {userPRList, prconfList}));
+            String.format(
+                "The PartitionListeners=%s are incompatible with the PartitionListeners=%s used by other distributed members.",
+                new Object[] {userPRList, prconfList}));
-              LocalizedStrings.PartitionRegionConfigValidator_INCOMPATIBLE_PARTITION_LISTENER
-                  .toLocalizedString(new Object[] {userPRList, prconfList}));
+              String.format(
+                  "The PartitionListeners=%s are incompatible with the PartitionListeners=%s used by other distributed members.",
+                  new Object[] {userPRList, prconfList}));
-     * LocalizedStrings.PartitionRegionConfigValidator_INCOMPATIBLE_PARTITION_RESOLVER
-     * .toLocalizedString(new Object[] { "null", prconf.getPartitionResolverClassName() })); }
+     * String.
+     * format("The PartitionResolver=%s is incompatible with the PartitionResolver=%s used by other distributed members."
+     * ,
+     * new Object[] { "null", prconf.getPartitionResolverClassName() })); }
-            LocalizedStrings.PartitionRegionConfigValidator_INCOMPATIBLE_PARTITION_RESOLVER
-                .toLocalizedString(new Object[] {userPA.getPartitionResolver().getClass().getName(),
+            String.format(
+                "The PartitionResolver=%s is incompatible with the PartitionResolver=%s used by other distributed members.",
+                new Object[] {userPA.getPartitionResolver().getClass().getName(),
-          LocalizedStrings.PartitionRegionConfigValidator_INCOMPATIBLE_COLOCATED_WITH
-              .toLocalizedString(new Object[] {"null", prconf.getColocatedWith()}));
+          String.format(
+              "The colocatedWith=%s found in PartitionAttributes is incompatible with the colocatedWith=%s used by other distributed members.",
+              new Object[] {"null", prconf.getColocatedWith()}));
-            LocalizedStrings.PartitionRegionConfigValidator_INCOMPATIBLE_COLOCATED_WITH
-                .toLocalizedString(
-                    new Object[] {userPA.getColocatedWith(), prconf.getColocatedWith()}));
+            String.format(
+                "The colocatedWith=%s found in PartitionAttributes is incompatible with the colocatedWith=%s used by other distributed members.",
+
+                new Object[] {userPA.getColocatedWith(), prconf.getColocatedWith()}));
-          LocalizedStrings.PartitionRegionConfigValidator_INCOMPATIBLE_EXPIRATION_ATTRIBUETS
-              .toLocalizedString(new Object[] {" region idle timout "}));
+          String.format(
+              "The %1$s set in RegionAttributes is incompatible with %1$s used by other distributed members.",
+              new Object[] {" region idle timout "}));
-          LocalizedStrings.PartitionRegionConfigValidator_INCOMPATIBLE_EXPIRATION_ATTRIBUETS
-              .toLocalizedString(new Object[] {" region time to live "}));
+          String.format(
+              "The %1$s set in RegionAttributes is incompatible with %1$s used by other distributed members.",
+              new Object[] {" region time to live "}));
-          LocalizedStrings.PartitionRegionConfigValidator_INCOMPATIBLE_EXPIRATION_ATTRIBUETS
-              .toLocalizedString(new Object[] {" entry idle timout "}));
+          String.format(
+              "The %1$s set in RegionAttributes is incompatible with %1$s used by other distributed members.",
+              new Object[] {" entry idle timout "}));
-          LocalizedStrings.PartitionRegionConfigValidator_INCOMPATIBLE_EXPIRATION_ATTRIBUETS
-              .toLocalizedString(new Object[] {" entry time to live "}));
+          String.format(
+              "The %1$s set in RegionAttributes is incompatible with %1$s used by other distributed members.",
+              new Object[] {" entry time to live "}));
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.PartitionedRegion_0_EVICTIONATTRIBUTES_1_DO_NOT_MATCH_WITH_OTHER_2,
-              new Object[] {pr.getFullPath(), ea, prconfEa}));
+          logger.warn(
+              "For Partitioned Region {} the locally configured EvictionAttributes {} do not match with other EvictionAttributes {} and may cause misses during reads from VMs with smaller maximums.",
+              new Object[] {pr.getFullPath(), ea, prconfEa});
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.PartitionedRegion_EVICTIONATTRIBUTES_0_WILL_HAVE_NO_EFFECT_1_2,
-          new Object[] {ea, pr.getFullPath(), Integer.valueOf(pr.localMaxMemory)}));
+      logger.info(
+          "EvictionAttributes {} will have no effect for Partitioned Region {} on this VM because localMaxMemory is {}.",
+          new Object[] {ea, pr.getFullPath(), Integer.valueOf(pr.localMaxMemory)});
-              LocalizedStrings.PartitionRegionConfigValidator_CACHE_LOADER_IS_NOTNULL_IN_PARTITIONED_REGION_0_ON_OTHER_DATASTORE
-                  .toLocalizedString(new Object[] {this.pr.getName()}));
+              String.format(
+                  "Incompatible CacheLoader. CacheLoader is not null in partitionedRegion %s on another datastore.",
+                  new Object[] {this.pr.getName()}));
-              LocalizedStrings.PartitionRegionConfigValidator_CACHE_LOADER_IS_NULL_IN_PARTITIONED_REGION_0_ON_OTHER_DATASTORE
-                  .toLocalizedString(new Object[] {this.pr.getName()}));
+              String.format(
+                  "Incompatible CacheLoader. CacheLoader is null in partitionedRegion %s on another datastore.",
+                  new Object[] {this.pr.getName()}));
-              LocalizedStrings.PartitionRegionConfigValidator_CACHE_WRITER_IS_NOTNULL_IN_PARTITIONED_REGION_0_ON_OTHER_DATASTORE
-                  .toLocalizedString(new Object[] {this.pr.getName()}));
+              String.format(
+                  "Incompatible CacheWriter. CacheWriter is not null in partitionedRegion %s on another datastore.",
+                  new Object[] {this.pr.getName()}));
-              LocalizedStrings.PartitionRegionConfigValidator_CACHE_WRITER_IS_NULL_IN_PARTITIONED_REGION_0_ON_OTHER_DATASTORE
-                  .toLocalizedString(new Object[] {this.pr.getName()}));
+              String.format(
+                  "Incompatible CacheWriter. CacheWriter is null in partitionedRegion %s on another datastore.",
+                  new Object[] {this.pr.getName()}));
-        Object[] prms =
-            new Object[] {this.pr.getName(), numBuckets, this.pr.getTotalNumberOfBuckets()};
-            LocalizedStrings.PartitionedRegionConfigValidator_FOR_REGION_0_SUM_OF_NUM_BUCKETS_1_FOR_DIFFERENT_PRIMARY_PARTITIONS_SHOULD_NOT_BE_GREATER_THAN_TOTAL_NUM_BUCKETS_2
-                .toString(prms));
+            String.format(
+                "For region %s,sum of num-buckets %s for different primary partitions should not be greater than total-num-buckets %s.",
+                this.pr.getName(), numBuckets, this.pr.getTotalNumberOfBuckets()));
-            Object[] prms = new Object[] {this.pr.getName(), fpa.getPartitionName(),
-                fpa.getNumBuckets(), otherfpa.getNumBuckets()};
-                LocalizedStrings.PartitionedRegionConfigValidator_FOR_REGION_0_FOR_PARTITION_1_NUM_BUCKETS_ARE_NOT_SAME_ACROSS_NODES
-                    .toString(prms));
+                String.format(
+                    "For region %s,for partition %s, num-buckets are not same (%s, %s)across nodes.",
+                    this.pr.getName(), fpa.getPartitionName(),
+                    fpa.getNumBuckets(), otherfpa.getNumBuckets()));
-              Object[] prms = new Object[] {this.pr.getName(), numSecondaries,
-                  fpa.getPartitionName(), this.pr.getRedundantCopies()};
-                  LocalizedStrings.PartitionedRegionConfigValidator_FOR_REGION_0_NUMBER_OF_SECONDARY_PARTITIONS_1_OF_A_PARTITION_2_SHOULD_NEVER_EXCEED_NUMBER_OF_REDUNDANT_COPIES_3
-                      .toString(prms));
+                  String.format(
+                      "For region %s, number of secondary partitions %s of a partition %s should never exceed number of redundant copies %s.",
+                      this.pr.getName(), numSecondaries,
+                      fpa.getPartitionName(), this.pr.getRedundantCopies()));
-        Object[] prms = new Object[] {this.pr.getName(), fpa.getPartitionName()};
-            LocalizedStrings.PartitionedRegionConfigValidator_FOR_REGION_0_SAME_PARTITION_NAME_1_CANNOT_BE_DEFINED_AS_PRIMARY_ON_MORE_THAN_ONE_NODE
-                .toString(prms));
+            String.format(
+                "For region %s, same partition name %s can not be defined as primary on more than one node.",
+                this.pr.getName(), fpa.getPartitionName()));
-              LocalizedStrings.PartitionedRegionConfigValidator_FIXED_PARTITION_REGION_ONE_DATASTORE_IS_WITHOUTFPA
-                  .toLocalizedString(prms));
+              String.format(
+                  "Region %s uses fixed partitioning but at least one datastore node (localMaxMemory > 0) has no fixed partitions. Please make sure that each datastore creating this region is configured with at least one fixed partition.",
+                  prms));
-                LocalizedStrings.PartitionedRegionConfigValidator_FIXED_PARTITION_REGION_ONE_DATASTORE_IS_WITHOUTFPA
-                    .toLocalizedString(prms));
+                String.format(
+                    "Region %s uses fixed partitioning but at least one datastore node (localMaxMemory > 0) has no fixed partitions. Please make sure that each datastore creating this region is configured with at least one fixed partition.",
+                    prms));

MOV8 MOV60 MOV60 MOV60 MOV60 INS61 MOV32 MOV8 MOV60 MOV32 INS42 INS8 UPD42 UPD42 INS45 INS25 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 MOV27 MOV42 MOV8 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 MOV32 UPD42 INS42 INS45 MOV32 UPD42 MOV32 UPD42 UPD42 INS45 MOV32 MOV32 MOV27 UPD42 UPD42 INS45 INS53 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD42 INS42 INS45 INS14 UPD42 INS42 INS45 MOV43 MOV32 UPD42 MOV42 UPD42 UPD42 INS45 MOV32 MOV32 MOV32 MOV32 UPD42 INS42 INS45 MOV43 UPD42 INS42 INS45 MOV32 UPD42 MOV32 MOV32 DEL40 DEL26 DEL40 DEL26 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL59 DEL60 DEL40 DEL40 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL4 DEL3 DEL59 DEL60 DEL14 DEL53 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL59 DEL60 DEL40 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL4 DEL3 DEL59 DEL60 DEL40 DEL40 DEL40 DEL42 DEL25 DEL61 DEL8
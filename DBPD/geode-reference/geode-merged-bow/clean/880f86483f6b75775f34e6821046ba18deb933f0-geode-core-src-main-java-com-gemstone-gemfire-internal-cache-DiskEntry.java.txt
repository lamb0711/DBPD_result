GEODE-1464: remove sqlf code

-  
-  /**
-   * In some cases we need to do something just after we unset the value
-   * from a DiskEntry that has been moved (i.e. overflowed) to disk.
-   * @param context
-   */
-  public void afterValueOverflow(RegionEntryContext context);
-      
-    /**
-     * Returns false if the entry is INVALID (or LOCAL_INVALID). Determines this
-     * without faulting in the value from disk.
-     * 
-     * @since GemFire 3.2.1
-     */
-    /* TODO prpersist - Do we need this method? It was added by the sqlf merge
-    static boolean isValid(DiskEntry entry, DiskRegion dr) {
-      synchronized (entry) {
-        if (entry.isRecovered()) {
-          // We have a recovered entry whose value is still on disk.
-          // So take a peek at it without faulting it in.
-          //long id = entry.getDiskId().getKeyId();
-          //entry.getDiskId().setKeyId(-id);
-          byte bits = dr.getBits(entry.getDiskId());
-          //TODO Asif:Check if resetting is needed
-          return !EntryBits.isInvalid(bits) && !EntryBits.isLocalInvalid(bits);
-        }
-      }
-    }*/
-      final boolean isEagerDeserialize = entry.isEagerDeserialize();
-      if (isEagerDeserialize) {
-        entry.clearEagerDeserialize();
-      }
-            //For SQLFire we prefer eager deserialized
-//            if(v instanceof ByteSource) {
-//              entry.setEagerDeserialize();
-//            }
-          //For SQLFire we prefer eager deserialized
-//            if(v instanceof ByteSource) {
-//              entry.setEagerDeserialize();
-//            }
-            else if (isEagerDeserialize && tmp instanceof byte[][]) {
-              // optimize for byte[][] since it will need to be eagerly deserialized
-              // for SQLFabric
-              entry.value = tmp;
-              entry.setEagerDeserialize();
-              entry.setSerialized(true);
-            }
-      else if (isEagerDeserialize && v instanceof byte[][]) {
-        // optimize for byte[][] since it will need to be eagerly deserialized
-        // for SQLFabric
-        entry.value = v;
-        entry.setEagerDeserialize();
-      }
-      if (CachedDeserializableFactory.preferObject()) {
-        entry.value = preparedValue;
-        entry.setEagerDeserialize();
-      }
-      else {
+      {
-        if (!event.hasDelta()) {
-          // We don't do this for the delta case because getRawNewValue returns delta
-          // and we want to write the entire new value to disk.
+        {
-              try {
-                entry.handleValueOverflow(region);
-                entry.setValueWithContext(region, null); // fixes bug 41119
-              }finally {
-                entry.afterValueOverflow(region);
-              }
-              
+              entry.handleValueOverflow(region);
+              entry.setValueWithContext(region, null); // fixes bug 41119
-          // has succeeded. If not , for GemFireXD , it is possible that other thread
-          // may pick this transient value from region entry ( which for 
-          //offheap will eventually be released ) as index key, 
-          //given that this operation is bound to fail in case of
-          //disk access exception.
+          // has succeeded.
-              //In case of compression the value is being set first 
-              // because atleast for now , GemFireXD does not support compression
-              // if and when it does support, this needs to be taken care of else
-              // we risk Bug 48965
+              //In case of compression the value is being set first
-            try {
-              entry.handleValueOverflow(context);
-              entry.setValueWithContext(context,null); // fixes bug 41119
-            }finally {
-              entry.afterValueOverflow(context);
-            }
+            entry.handleValueOverflow(context);
+            entry.setValueWithContext(context,null); // fixes bug 41119
-      //Asif: If the entry is instance of LRU then DidkRegion cannot be null.
-      //Since SqlFabric is accessing this method direcly & it passes the owning region,
-      //if the region happens to be persistent PR type, the owning region passed is PR,
-      // but it will have DiskRegion as null. SqlFabric takes care of passing owning region
-      // as BucketRegion in case of Overflow type entry. This is fix for Bug # 41804
-     * return the result will only be off-heap if the value is a sqlf ByteSource. Otherwise result will be on-heap.
-    @Retained
-        @Unretained Object preparedValue = setValueOnFaultIn(value, did, entry, dr, region);
-        // For Sqlfire we want to return the offheap representation.
-        // So we need to retain it for the caller to release.
-        /*if (preparedValue instanceof ByteSource) {
-          // This is the only case in which we return a retained off-heap ref.
-          ((ByteSource)preparedValue).retain();
-          return preparedValue;
-        } else */{
-          return value;
-        }
+        setValueOnFaultIn(value, did, entry, dr, region);
+        return value;
-      /*
-      final StaticSystemCallbacks sysCb;
-      if (version != null && (sysCb = GemFireCacheImpl.FactoryStatics
-          .systemCallbacks) != null) {
-        // may need to change serialized shape for SQLFire
-        return sysCb.fromVersion(valueBytes, false, version, in);
-      }
-      else */ {
-        return valueBytes;
-      }
+      return valueBytes;
-      // Notify the SQLFire IndexManager if present
-     /* final IndexUpdater indexUpdater = region.getIndexUpdater();
-      if(indexUpdater != null && dr.isSync()) {
-        indexUpdater.onOverflowToDisk(entry);
-      }*/
-      
-          //did.setValueSerializedSize(byteSizeOnDisk);
-          try {
-            entry.handleValueOverflow(region);
-            entry.setValueWithContext(region,null);
-          }finally {
-            entry.afterValueOverflow(region);
-          }
+          entry.handleValueOverflow(region);
+          entry.setValueWithContext(region,null);
-                try {
-                  entry.handleValueOverflow(region);
-                  entry.setValueWithContext(region,null);
-                }finally {
-                  entry.afterValueOverflow(region);
-                }
+                entry.handleValueOverflow(region);
+                entry.setValueWithContext(region,null);
-                try {
-                 entry.handleValueOverflow(region);
-                 entry.setValueWithContext(region,null);
-                }finally {
-                  entry.afterValueOverflow(region);
-                }
+                entry.handleValueOverflow(region);
+                entry.setValueWithContext(region,null);

MOV8 MOV8 MOV25 MOV60 MOV54 MOV32 MOV8 MOV25 MOV27 INS8 MOV62 INS8 INS25 MOV60 MOV8 MOV25 MOV25 MOV25 MOV60 INS54 MOV62 MOV8 INS25 UPD42 MOV42 UPD42 MOV42 MOV27 MOV8 MOV8 MOV8 MOV27 MOV8 INS25 INS41 INS25 INS21 MOV41 MOV27 MOV8 INS25 MOV42 INS32 MOV38 MOV8 MOV32 MOV38 MOV8 INS8 MOV27 MOV8 INS8 INS42 INS42 INS42 MOV21 MOV21 MOV60 MOV25 MOV60 MOV25 MOV8 INS42 INS42 MOV62 MOV8 MOV8 MOV21 MOV21 MOV21 MOV21 DEL66 DEL66 DEL65 DEL42 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL31 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL42 DEL39 DEL85 DEL85 DEL5 DEL62 DEL27 DEL40 DEL42 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL40 DEL42 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL42 DEL42 DEL39 DEL85 DEL85 DEL5 DEL62 DEL27 DEL40 DEL42 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL25 DEL25 DEL25 DEL25 DEL25 DEL32 DEL38 DEL25 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL25 DEL66 DEL42 DEL78 DEL42 DEL78 DEL42 DEL43 DEL42 DEL59 DEL60 DEL8 DEL8 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54
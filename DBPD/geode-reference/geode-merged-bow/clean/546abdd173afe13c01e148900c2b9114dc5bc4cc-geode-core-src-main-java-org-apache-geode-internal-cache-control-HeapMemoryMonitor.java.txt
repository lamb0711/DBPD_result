GEODE-6304: Refactor memory monitor to properly reset tolerance counter (#3102)

The tolerance counter was not properly being reset between
non-consecutive EVICTION and CRITICAL events.  To fix this and make it
more understandable, the threshold logic was combined with the logic to
compute the next state in the MemoryThreshold state machine.  The
counter is now reset between non-consecutive EVICTION and CRITICAL
events.

-  /*
-   * Number of eviction or critical state changes that have to occur before the event is delivered.
-   * This was introduced because we saw sudden memory usage spikes in jrockit VM.
-   */
-  private static final int memoryStateChangeTolerance;
-  static {
-    String vendor = System.getProperty("java.vendor");
-    if (vendor.contains("Sun") || vendor.contains("Oracle")) {
-      memoryStateChangeTolerance =
-          Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "memoryEventTolerance", 1);
-    } else {
-      memoryStateChangeTolerance =
-          Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "memoryEventTolerance", 5);
-    }
-  }
-
-  private Boolean started = false;
+  boolean started = false;
-  // Only change state when these counters exceed {@link
-  // HeapMemoryMonitor#memoryStateChangeTolerance}
-  private int criticalToleranceCounter;
-  private int evictionToleranceCounter;
-
+  public void setMemoryStateChangeTolerance(int memoryStateChangeTolerance) {
+    thresholds.setMemoryStateChangeTolerance(memoryStateChangeTolerance);
+  }
+
+  public int getMemoryStateChangeTolerance() {
+    return thresholds.getMemoryStateChangeTolerance();
+  }
+
-        testBytesUsedForThresholdSet != -1 ? testBytesUsedForThresholdSet : getBytesUsed());
+        testBytesUsedForThresholdSet != -1 ? testBytesUsedForThresholdSet : getBytesUsed(),
+        "notification");
-   * Public for testing.
-   *
+   * @param eventOrigin Indicates where the event originated e.g. notification vs polling
-  public void updateStateAndSendEvent(long bytesUsed) {
+  public void updateStateAndSendEvent(long bytesUsed, String eventOrigin) {
-        if (!skipEventDueToToleranceLimits(oldState, newState)) {
-          this.currentState = newState;
+        this.currentState = newState;
-          MemoryEvent event = new MemoryEvent(ResourceType.HEAP_MEMORY, oldState, newState,
-              this.cache.getMyId(), bytesUsed, true, this.thresholds);
+        MemoryEvent event = new MemoryEvent(ResourceType.HEAP_MEMORY, oldState, newState,
+            this.cache.getMyId(), bytesUsed, true, this.thresholds);
-          this.upcomingEvent.set(event);
-          processLocalEvent(event);
-          updateStatsFromEvent(event);
-        }
+        this.upcomingEvent.set(event);
+        processLocalEvent(event, eventOrigin);
+        updateStatsFromEvent(event);
-        processLocalEvent(event);
+        processLocalEvent(event, eventOrigin);
-   * To avoid memory spikes in jrockit, we only deliver events if we receive more than
-   * {@link HeapMemoryMonitor#memoryStateChangeTolerance} of the same state change.
-   *
-   * @return True if an event should be skipped, false otherwise.
-   */
-  private boolean skipEventDueToToleranceLimits(MemoryState oldState, MemoryState newState) {
-    if (testDisableMemoryUpdates) {
-      return false;
-    }
-
-    if (newState.isEviction() && !oldState.isEviction()) {
-      this.evictionToleranceCounter++;
-      this.criticalToleranceCounter = 0;
-      if (this.evictionToleranceCounter <= memoryStateChangeTolerance) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("State " + newState + " ignored. toleranceCounter:"
-              + this.evictionToleranceCounter + " MEMORY_EVENT_TOLERANCE:"
-              + memoryStateChangeTolerance);
-        }
-        return true;
-      }
-    } else if (newState.isCritical()) {
-      this.criticalToleranceCounter++;
-      this.evictionToleranceCounter = 0;
-      if (this.criticalToleranceCounter <= memoryStateChangeTolerance) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("State " + newState + " ignored. toleranceCounter:"
-              + this.criticalToleranceCounter + " MEMORY_EVENT_TOLERANCE:"
-              + memoryStateChangeTolerance);
-        }
-        return true;
-      }
-    } else {
-      this.criticalToleranceCounter = 0;
-      this.evictionToleranceCounter = 0;
-      if (logger.isDebugEnabled()) {
-        logger.debug("TOLERANCE counters reset");
-      }
-    }
-    return false;
-  }
-
-  /**
+   * @param eventOrigin Indicates where the event originated e.g. notification vs polling
-  synchronized void processLocalEvent(MemoryEvent event) {
+  synchronized void processLocalEvent(MemoryEvent event, String eventOrigin) {
-          String.format("Member: %s above %s critical threshold",
-              new Object[] {event.getMember(), "heap"}));
+          String.format("Member: %s above %s critical threshold. Event generated via %s.",
+              event.getMember(), "heap", eventOrigin));
-          String.format("Member: %s below %s critical threshold",
-              new Object[] {event.getMember(), "heap"}));
+          String.format("Member: %s below %s critical threshold. Event generated via %s.",
+              event.getMember(), "heap", eventOrigin));
-          new Object[] {event.getMember(), "heap"}));
+          event.getMember(), "heap"));
-          new Object[] {event.getMember(), "heap"}));
+          event.getMember(), "heap"));
-              updateStateAndSendEvent(usedBytes);
+              updateStateAndSendEvent(usedBytes, "polling");
-        + this.mostRecentEvent + ", criticalToleranceCounter=" + this.criticalToleranceCounter
-        + ", evictionToleranceCounter=" + this.evictionToleranceCounter + "]";
+        + this.mostRecentEvent + "]";
-        updateStateAndSendEvent(getBytesUsed());
+        updateStateAndSendEvent(getBytesUsed(), "polling");

INS31 INS31 INS39 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS8 INS44 MOV8 INS44 INS39 INS42 MOV21 INS41 INS65 INS65 MOV43 INS42 MOV21 INS51 INS65 INS43 INS42 INS32 MOV66 MOV66 INS42 UPD66 MOV66 INS52 MOV8 INS42 INS66 INS42 UPD42 INS42 INS42 UPD42 MOV42 INS42 INS45 MOV60 MOV60 MOV27 INS25 MOV21 MOV27 INS8 MOV32 MOV32 MOV60 MOV21 INS21 UPD45 MOV32 INS45 INS42 MOV32 MOV32 INS45 MOV32 INS45 INS42 MOV32 INS32 UPD45 MOV32 INS45 INS42 MOV32 INS45 UPD42 INS42 INS42 INS42 INS45 DEL83 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL42 DEL42 DEL42 DEL45 DEL32 DEL59 DEL60 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL45 DEL32 DEL27 DEL42 DEL42 DEL42 DEL40 DEL45 DEL27 DEL34 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL40 DEL45 DEL27 DEL34 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL28 DEL83 DEL42 DEL43 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL45 DEL42 DEL45 DEL52 DEL42 DEL22 DEL45 DEL42 DEL27 DEL65 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL25 DEL52 DEL51 DEL8 DEL66 DEL42 DEL42 DEL67 DEL65 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL9 DEL41 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL27 DEL52 DEL42 DEL22 DEL37 DEL21 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL27 DEL42 DEL42 DEL32 DEL8 DEL25 DEL9 DEL41 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL37 DEL21 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL27 DEL42 DEL42 DEL32 DEL42 DEL45 DEL42 DEL45 DEL52 DEL42 DEL22 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL9 DEL41 DEL8 DEL25 DEL8 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL25 DEL9 DEL41 DEL8 DEL31 DEL42 DEL43 DEL85 DEL5 DEL45 DEL4 DEL3 DEL42 DEL43 DEL85 DEL5 DEL45 DEL4 DEL3 DEL42 DEL43 DEL85 DEL5 DEL45 DEL4 DEL3 DEL42 DEL43 DEL85 DEL5 DEL45 DEL4 DEL3 DEL45 DEL52 DEL42 DEL22 DEL45 DEL52 DEL42 DEL22
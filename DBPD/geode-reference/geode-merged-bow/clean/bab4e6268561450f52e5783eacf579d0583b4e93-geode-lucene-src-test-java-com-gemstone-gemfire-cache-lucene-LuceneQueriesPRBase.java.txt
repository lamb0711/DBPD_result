Merge branch 'develop' into feature/GEODE-1571

+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.*;
-import java.io.Serializable;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
+import java.io.IOException;
+import java.util.concurrent.Callable;
+import java.util.stream.IntStream;
+import org.apache.lucene.analysis.Analyzer;
+import org.junit.After;
+import org.junit.Ignore;
-import org.junit.experimental.categories.Category;
+import org.mockito.Mockito;
+import org.mockito.stubbing.Answer;
-import com.gemstone.gemfire.test.dunit.Host;
+import com.gemstone.gemfire.cache.lucene.internal.IndexRepositoryFactory;
+import com.gemstone.gemfire.cache.lucene.internal.LuceneIndexStats;
+import com.gemstone.gemfire.cache.lucene.internal.PartitionedRepositoryManager;
+import com.gemstone.gemfire.cache.lucene.internal.filesystem.FileSystemStats;
+import com.gemstone.gemfire.cache.lucene.internal.repository.IndexRepository;
+import com.gemstone.gemfire.cache.lucene.internal.repository.serializer.LuceneSerializer;
+import com.gemstone.gemfire.cache.lucene.test.LuceneTestUtilities;
+import com.gemstone.gemfire.cache.partition.PartitionRegionHelper;
+import com.gemstone.gemfire.distributed.DistributedMember;
+import com.gemstone.gemfire.internal.cache.BucketNotFoundException;
+import com.gemstone.gemfire.internal.cache.PartitionedRegion;
-import com.gemstone.gemfire.test.dunit.cache.internal.JUnit4CacheTestCase;
-import com.gemstone.gemfire.test.junit.categories.DistributedTest;
+  @After
+  public void cleanupRebalanceCallback() {
+    removeCallback(dataStore1);
+    removeCallback(dataStore2);
+  }
+
+
+
-  public void returnCorrectResultsAfterRebalance() {
+  public void returnCorrectResultsWhenRebalanceHappensOnIndexUpdate() throws InterruptedException {
+    addCallbackToTriggerRebalance(dataStore1);
+
+    putEntriesAndValidateQueryResults();
+  }
+
+  @Test
+  public void returnCorrectResultsWhenMoveBucketHappensOnIndexUpdate() throws InterruptedException {
+    final DistributedMember member2 = dataStore2.invoke(() -> getCache().getDistributedSystem().getDistributedMember());
+    addCallbackToMoveBucket(dataStore1, member2);
+
+    putEntriesAndValidateQueryResults();
+  }
+
+  @Test
+  public void returnCorrectResultsWhenBucketIsMovedAndMovedBackOnIndexUpdate() throws InterruptedException {
+    final DistributedMember member1 = dataStore1.invoke(() -> getCache().getDistributedSystem().getDistributedMember());
+    final DistributedMember member2 = dataStore2.invoke(() -> getCache().getDistributedSystem().getDistributedMember());
+    addCallbackToMoveBucket(dataStore1, member2);
+    addCallbackToMoveBucket(dataStore2, member1);
+
+    putEntriesAndValidateQueryResults();
+  }
+
+  protected void putEntriesAndValidateQueryResults() {
-    putDataInRegion(accessor);
-    dataStore2.invoke(() -> initDataStore(createIndex));
+    dataStore1.invoke(() -> LuceneTestUtilities.pauseSender(getCache()));
-    rebalanceRegion(dataStore1);
+    put113Entries();
+
+    dataStore2.invoke(() -> initDataStore(createIndex));
+    dataStore1.invoke(() -> LuceneTestUtilities.resumeSender(getCache()));
+
+    assertTrue(waitForFlushBeforeExecuteTextSearch(dataStore1, 60000));
+
+    executeTextSearch(accessor, "world", "text", 113);
+  }
+
+  @Test
+  public void returnCorrectResultsWhenRebalanceHappensAfterUpdates() throws InterruptedException {
+    SerializableRunnableIF createIndex = () -> {
+      LuceneService luceneService = LuceneServiceProvider.get(getCache());
+      luceneService.createIndex(INDEX_NAME, REGION_NAME, "text");
+    };
+    dataStore1.invoke(() -> initDataStore(createIndex));
+    accessor.invoke(() -> initAccessor(createIndex));
+
+    put113Entries();
+
+    dataStore2.invoke(() -> initDataStore(createIndex));
-    executeTextSearch(accessor);
+
+    rebalanceRegion(dataStore2);
+
+    executeTextSearch(accessor, "world", "text", 113);
+  }
+
+  @Test
+  public void returnCorrectResultsWhenRebalanceHappensWhileSenderIsPaused() throws InterruptedException {
+    SerializableRunnableIF createIndex = () -> {
+      LuceneService luceneService = LuceneServiceProvider.get(getCache());
+      luceneService.createIndex(INDEX_NAME, REGION_NAME, "text");
+    };
+    dataStore1.invoke(() -> initDataStore(createIndex));
+    accessor.invoke(() -> initAccessor(createIndex));
+    dataStore1.invoke(() -> LuceneTestUtilities.pauseSender(getCache()));
+
+    put113Entries();
+
+    dataStore2.invoke(() -> initDataStore(createIndex));
+    rebalanceRegion(dataStore2);
+    dataStore1.invoke(() -> LuceneTestUtilities.resumeSender(getCache()));
+
+    assertTrue(waitForFlushBeforeExecuteTextSearch(accessor, 60000));
+
+    executeTextSearch(accessor, "world", "text", 113);
+  }
+
+  protected void put113Entries() {
+    accessor.invoke(() -> {
+      final Cache cache = getCache();
+      Region<Object, Object> region = cache.getRegion(REGION_NAME);
+      IntStream.range(0,113).forEach(i -> region.put(i, new TestObject("hello world")));
+    });
+  }
+
+  private void addCallbackToTriggerRebalance(VM vm) {
+    vm.invoke(() -> {
+      IndexRepositorySpy spy = IndexRepositorySpy.injectSpy();
+
+      spy.beforeWrite(doOnce(key -> rebalanceRegion(vm)));
+    });
+  }
+
+  protected void addCallbackToMoveBucket(VM vm, final DistributedMember destination) {
+    vm.invoke(() -> {
+      IndexRepositorySpy spy = IndexRepositorySpy.injectSpy();
+
+      spy.beforeWrite(doOnce(key -> moveBucket(destination, key)));
+    });
+  }
+
+  private void moveBucket(final DistributedMember destination, final Object key) {
+    Region<Object, Object> region = getCache().getRegion(REGION_NAME);
+    DistributedMember source = getCache().getDistributedSystem().getDistributedMember();
+    PartitionRegionHelper.moveBucketByKey(region, source, destination, key);
+  }
+
+  private void removeCallback(VM vm) {
+    vm.invoke(IndexRepositorySpy::remove);
-        assertTrue("Transferred " + results.getTotalBucketTransfersCompleted(), 1 < results.getTotalBucketTransfersCompleted());
+  protected static class IndexRepositorySpy extends IndexRepositoryFactory {
+
+    private Consumer<Object> beforeWrite = key -> {};
+
+    public static IndexRepositorySpy injectSpy() {
+      IndexRepositorySpy factory = new IndexRepositorySpy();
+      PartitionedRepositoryManager.indexRepositoryFactory = factory;
+      return factory;
+    }
+
+    public static void remove() {
+      PartitionedRepositoryManager.indexRepositoryFactory = new IndexRepositoryFactory();
+    }
+
+    private IndexRepositorySpy() {
+    }
+
+    @Override
+    public IndexRepository createIndexRepository(final Integer bucketId,
+                                                 final PartitionedRegion userRegion,
+                                                 final PartitionedRegion fileRegion,
+                                                 final PartitionedRegion chunkRegion,
+                                                 final LuceneSerializer serializer,
+                                                 final Analyzer analyzer,
+                                                 final LuceneIndexStats indexStats,
+                                                 final FileSystemStats fileSystemStats)
+      throws IOException
+    {
+      final IndexRepository indexRepo = super.createIndexRepository(bucketId, userRegion, fileRegion, chunkRegion,
+        serializer, analyzer,
+        indexStats,
+        fileSystemStats);
+      final IndexRepository spy = Mockito.spy(indexRepo);
+
+      Answer invokeBeforeWrite = invocation -> {
+        beforeWrite.accept(invocation.getArgumentAt(0, Object.class));
+        invocation.callRealMethod();
+        return null;
+      };
+      doAnswer(invokeBeforeWrite).when(spy).update(any(), any());
+      doAnswer(invokeBeforeWrite).when(spy).create(any(), any());
+      doAnswer(invokeBeforeWrite).when(spy).delete(any());
+
+      return spy;
+    }
+
+    /**
+     * Add a callback that runs before a call to
+     * {@link IndexRepository#create(Object, Object)}
+     */
+    public void beforeWrite(Consumer<Object> action) {
+      this.beforeWrite = action;
+    }
+  }
+
+  protected static <T> Consumer<T> doOnce(Consumer<T> consumer) {
+    return new Consumer<T>() {
+      boolean done;
+
+      @Override
+      public void accept(final T t) {
+        if (!done) {
+          done = true;
+          consumer.accept(t);
+        }
+      }
+    };
+  };

MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 UPD40 UPD40 UPD40 UPD40 UPD40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 UPD40 INS40 UPD40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS55 INS31 INS78 INS83 INS39 INS42 INS8 MOV78 INS83 INS39 INS42 INS43 INS8 INS78 INS83 INS39 INS42 INS43 INS8 INS78 INS83 INS39 INS42 INS43 INS8 UPD83 UPD42 INS78 INS83 INS39 INS42 INS43 INS8 INS78 INS83 INS39 INS42 INS43 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS42 INS43 INS23 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS73 INS74 INS42 INS44 INS8 INS42 INS21 INS21 INS42 INS21 INS21 INS42 INS42 INS60 INS21 INS21 INS42 INS42 INS60 INS60 INS21 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS60 INS21 INS21 INS21 MOV21 MOV21 INS21 INS21 INS42 INS42 INS60 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS43 INS42 INS21 INS43 INS42 INS83 INS43 INS42 INS21 INS83 INS43 INS42 INS83 INS43 INS42 INS60 INS60 INS21 INS43 INS42 INS21 INS42 INS83 INS74 INS59 INS83 INS83 INS43 INS42 INS8 INS83 INS83 INS39 INS42 INS8 INS83 INS42 INS8 INS78 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS43 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS42 INS43 INS43 INS74 INS42 INS41 INS32 INS32 INS32 INS32 INS83 INS43 INS59 INS32 INS32 INS83 INS43 INS59 INS83 INS43 INS59 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS43 INS59 INS32 INS32 INS32 INS32 INS32 INS43 INS59 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS74 INS59 INS43 INS59 INS32 INS42 INS32 INS43 INS43 INS42 INS86 INS42 INS60 INS21 INS41 INS21 INS42 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS42 INS60 INS60 INS60 INS21 INS21 INS21 INS41 INS65 INS74 INS42 INS21 INS42 INS42 INS43 INS43 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS86 INS42 INS42 INS42 INS86 INS42 INS42 INS86 INS42 INS32 INS45 INS45 INS34 INS42 INS42 INS86 INS42 INS42 INS86 INS42 INS42 INS86 INS42 INS42 INS42 INS42 INS42 INS45 INS45 INS34 INS42 INS42 INS86 INS42 INS42 INS86 INS42 INS42 INS86 INS42 INS42 INS86 INS42 INS42 INS42 INS86 INS42 INS42 INS42 INS42 INS86 INS42 INS32 INS42 INS42 INS45 INS45 INS34 INS42 INS42 INS86 INS42 INS42 INS86 INS42 INS42 INS86 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS90 INS42 INS42 INS59 INS8 INS43 INS59 INS7 INS42 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS83 INS43 INS59 INS83 INS43 INS59 INS43 INS59 INS32 INS32 INS32 INS42 INS66 INS65 INS43 INS43 INS7 INS42 INS42 INS74 INS1 INS42 INS42 INS86 INS42 INS42 INS86 INS42 INS42 INS86 INS32 INS32 INS32 UPD42 MOV42 MOV42 INS34 INS8 INS32 INS32 INS8 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS34 INS8 INS8 INS8 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS40 INS42 INS40 INS14 INS42 INS42 INS48 INS42 INS42 INS32 INS42 INS42 INS86 INS32 INS42 INS32 INS32 INS32 INS42 INS32 INS32 INS32 INS42 INS32 INS68 INS42 INS42 INS22 INS42 INS43 INS43 INS23 INS31 INS32 INS32 INS32 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS60 INS21 INS42 INS42 INS42 INS42 INS60 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS60 INS60 INS21 INS60 INS21 INS60 INS21 INS42 INS32 INS42 INS43 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS59 INS8 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS69 INS69 INS52 INS42 INS42 INS42 INS39 INS59 INS78 INS83 INS39 INS42 INS44 INS8 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS43 INS59 INS32 INS43 INS59 INS32 INS42 INS42 INS83 INS43 INS59 INS74 INS59 INS32 INS43 INS59 INS32 INS43 INS59 INS32 INS42 INS42 INS42 INS42 INS21 INS21 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS42 INS83 INS43 INS42 INS25 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS32 INS43 INS43 INS43 INS42 INS32 INS32 INS42 INS86 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS32 INS33 INS42 INS42 INS42 INS38 INS8 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS34 INS59 INS32 INS42 INS42 INS42 INS86 INS42 INS42 INS42 INS86 INS42 INS42 INS32 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS59 INS32 INS59 INS32 INS42 INS42 INS34 INS57 INS7 INS32 INS43 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS9 INS42 INS42 INS42 INS42 INS42 DEL32 DEL32 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL34 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * The GemFire JMX Agent provides the ability to administrate one GemFire
- * distributed system via JMX.
+ * The GemFire JMX Agent provides the ability to administrate one GemFire distributed system via
+ * JMX.
- * @since GemFire     3.5
+ * @since GemFire 3.5
-public class AgentImpl
-implements org.apache.geode.admin.jmx.Agent,
-           org.apache.geode.admin.jmx.internal.ManagedResource {
+public class AgentImpl implements org.apache.geode.admin.jmx.Agent,
+    org.apache.geode.admin.jmx.internal.ManagedResource {
-  
+
-   * MX4J HttpAdaptor only supports "basic" as an authentication method.
-   * Enabling HttpAdaptor authentication ({@link
-   * AgentConfig#HTTP_AUTHENTICATION_ENABLED_NAME}) causes the browser to
-   * require a login with username ({@link
-   * AgentConfig#HTTP_AUTHENTICATION_USER_NAME}) and password ({@link
-   * AgentConfig#HTTP_AUTHENTICATION_PASSWORD_NAME}).
+   * MX4J HttpAdaptor only supports "basic" as an authentication method. Enabling HttpAdaptor
+   * authentication ({@link AgentConfig#HTTP_AUTHENTICATION_ENABLED_NAME}) causes the browser to
+   * require a login with username ({@link AgentConfig#HTTP_AUTHENTICATION_USER_NAME}) and password
+   * ({@link AgentConfig#HTTP_AUTHENTICATION_PASSWORD_NAME}).
-  private static final String JMX_SERVICE_URL =
-                              "service:jmx:rmi://{0}:{1}/jndi/rmi://{2}:{3}{4}";
+  private static final String JMX_SERVICE_URL = "service:jmx:rmi://{0}:{1}/jndi/rmi://{2}:{3}{4}";
-                         "org.apache.commons.logging.impl.SimpleLog");
+          "org.apache.commons.logging.impl.SimpleLog");
-    }
-    catch (VirtualMachineError err) {
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Throwable t) {
+    } catch (Throwable t) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      /*ignore*/
-      }
+      /* ignore */
+    }
-  //   Member variables
+  // Member variables
-  /** The <code>AdminDistributedSystem</code> this Agent is currently
-   * connected to or <code>null</code> */
+  /**
+   * The <code>AdminDistributedSystem</code> this Agent is currently connected to or
+   * <code>null</code>
+   */
-  /** A lock object to guard the Connect and Disconnect calls being
-    * made on the agent for connections to the DS **/
+  /**
+   * A lock object to guard the Connect and Disconnect calls being made on the agent for connections
+   * to the DS
+   **/
-  //   Constructor(s)
+  // Constructor(s)
-  public AgentImpl(AgentConfigImpl agentConfig)
-    throws AdminException, IllegalArgumentException {
+  public AgentImpl(AgentConfigImpl agentConfig) throws AdminException, IllegalArgumentException {
-      throw new IllegalArgumentException(LocalizedStrings.AgentImpl_AGENTCONFIG_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AgentImpl_AGENTCONFIG_MUST_NOT_BE_NULL.toLocalizedString());
-    this.agentConfig = (AgentConfigImpl)agentConfig;
-    this.mbeanName   = MBEAN_NAME_PREFIX + MBeanUtil.makeCompliantMBeanNameProperty("Agent");
+    this.agentConfig = (AgentConfigImpl) agentConfig;
+    this.mbeanName = MBEAN_NAME_PREFIX + MBeanUtil.makeCompliantMBeanNameProperty("Agent");
-      String s = LocalizedStrings.AgentImpl_WHILE_CREATING_OBJECTNAME_0.toLocalizedString(new Object[] { this.mbeanName });
+      String s = LocalizedStrings.AgentImpl_WHILE_CREATING_OBJECTNAME_0
+          .toLocalizedString(new Object[] {this.mbeanName});
-       * We are not re-throwing these exceptions as failure create/register the
-       * GemFireTypesWrapper will not stop the Agent from working. But we are
-       * logging it as it could be an indication of some problem.
-       * Also not creating Localized String for the exception.
+       * We are not re-throwing these exceptions as failure create/register the GemFireTypesWrapper
+       * will not stop the Agent from working. But we are logging it as it could be an indication of
+       * some problem. Also not creating Localized String for the exception.
-      logger.info(LocalizedMessage.create(LocalizedStrings.AgentImpl_FAILED_TO_INITIALIZE_MEMBERINFOWITHSTATSMBEAN), e);
+      logger.info(LocalizedMessage
+          .create(LocalizedStrings.AgentImpl_FAILED_TO_INITIALIZE_MEMBERINFOWITHSTATSMBEAN), e);
-      logger.info(LocalizedMessage.create(LocalizedStrings.AgentImpl_FAILED_TO_INITIALIZE_MEMBERINFOWITHSTATSMBEAN), e);
+      logger.info(LocalizedMessage
+          .create(LocalizedStrings.AgentImpl_FAILED_TO_INITIALIZE_MEMBERINFOWITHSTATSMBEAN), e);
-      logger.info(LocalizedMessage.create(LocalizedStrings.AgentImpl_FAILED_TO_INITIALIZE_MEMBERINFOWITHSTATSMBEAN), e);
+      logger.info(LocalizedMessage
+          .create(LocalizedStrings.AgentImpl_FAILED_TO_INITIALIZE_MEMBERINFOWITHSTATSMBEAN), e);
-  //   Public operations
+  // Public operations
-         * Call Agent.stop() if connectToSystem() fails. This should clean up
-         * agent-DS connection & stop all the HTTP/RMI/SNMP adapters started
-         * earlier.
+         * Call Agent.stop() if connectToSystem() fails. This should clean up agent-DS connection &
+         * stop all the HTTP/RMI/SNMP adapters started earlier.
-        logger.error(LocalizedMessage.create(LocalizedStrings.AgentImpl_AUTO_CONNECT_FAILED__0, ex.getMessage()));
+        logger.error(LocalizedMessage.create(LocalizedStrings.AgentImpl_AUTO_CONNECT_FAILED__0,
+            ex.getMessage()));
-        throw new StartupException(new AdminException(autoConnectFailed.toLocalizedString(new Object[] { ex.getMessage() }), ex));
+        throw new StartupException(new AdminException(
+            autoConnectFailed.toLocalizedString(new Object[] {ex.getMessage()}), ex));
-      // remove the register shutdown hook which disconnects the Agent from the Distributed System upon JVM shutdown
+      // remove the register shutdown hook which disconnects the Agent from the Distributed System
+      // upon JVM shutdown
-    }
-    finally {
+    } finally {
-      LoggingThreadGroup.cleanUpThreadGroups(); // bug35388 - logwriters accumulate, causing mem leak
+      LoggingThreadGroup.cleanUpThreadGroups(); // bug35388 - logwriters accumulate, causing mem
+                                                // leak
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-    }
-    catch (VirtualMachineError err) {
+    } catch (VirtualMachineError err) {
-    }
-    catch (Error e) {
+    } catch (Error e) {
-      // However, there is _still_ a possibility that you are dealing with a cascading error condition,
+      // However, there is _still_ a possibility that you are dealing with a cascading error
+      // condition,
-  public ObjectName manageDistributedSystem()
-  throws MalformedObjectNameException {
+  public ObjectName manageDistributedSystem() throws MalformedObjectNameException {
-   * Connects to the DistributedSystem currently described by this Agent's
-   * attributes for administration and monitoring.
+   * Connects to the DistributedSystem currently described by this Agent's attributes for
+   * administration and monitoring.
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD", justification="This is only a style warning.") 
-  public ObjectName connectToSystem()
-  throws AdminException, MalformedObjectNameException {
-    synchronized(CONN_SYNC) {
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(
+      value = "ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD",
+      justification = "This is only a style warning.")
+  public ObjectName connectToSystem() throws AdminException, MalformedObjectNameException {
+    synchronized (CONN_SYNC) {
-        AdminDistributedSystemJmxImpl systemJmx =
-          (AdminDistributedSystemJmxImpl) this.system;
+        AdminDistributedSystemJmxImpl systemJmx = (AdminDistributedSystemJmxImpl) this.system;
-          systemJmx = (AdminDistributedSystemJmxImpl)
-            createDistributedSystem(this.agentConfig);
+          systemJmx = (AdminDistributedSystemJmxImpl) createDistributedSystem(this.agentConfig);
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD", justification="This is only a style warning.") 
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(
+      value = "ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD",
+      justification = "This is only a style warning.")
-    synchronized(CONN_SYNC) {
+    synchronized (CONN_SYNC) {
-        ((AdminDistributedSystemJmxImpl)this.system).disconnect();
-//         this.system = null;
+        ((AdminDistributedSystemJmxImpl) this.system).disconnect();
+        // this.system = null;
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-      return LocalizedStrings.AgentImpl_NO_LOG_FILE_CONFIGURED_LOG_MESSAGES_WILL_BE_DIRECTED_TO_STDOUT.toLocalizedString();
+      return LocalizedStrings.AgentImpl_NO_LOG_FILE_CONFIGURED_LOG_MESSAGES_WILL_BE_DIRECTED_TO_STDOUT
+          .toLocalizedString();
-        result.append("\n" + LocalizedStrings.AgentImpl_TAIL_OF_CHILD_LOG.toLocalizedString() + "\n");
+        result
+            .append("\n" + LocalizedStrings.AgentImpl_TAIL_OF_CHILD_LOG.toLocalizedString() + "\n");
-  //   Public attribute accessors/mutators
+  // Public attribute accessors/mutators
-     result = ((this.system != null) && this.system.isConnected());
+      result = ((this.system != null) && this.system.isConnected());
-   * Gets the agent's property file. This is the file it will use
-   * when saving its configuration. It was also used when the agent
-   * started to initialize its configuration.
+   * Gets the agent's property file. This is the file it will use when saving its configuration. It
+   * was also used when the agent started to initialize its configuration.
+   * 
-        throw new IllegalArgumentException(LocalizedStrings.AgentImpl_THE_FILE_0_IS_A_DIRECTORY.toLocalizedString(f));
+      throw new IllegalArgumentException(
+          LocalizedStrings.AgentImpl_THE_FILE_0_IS_A_DIRECTORY.toLocalizedString(f));
-        throw new IllegalArgumentException(LocalizedStrings.AgentImpl_THE_DIRECTORY_0_DOES_NOT_EXIST.toLocalizedString(parent));
+        throw new IllegalArgumentException(
+            LocalizedStrings.AgentImpl_THE_DIRECTORY_0_DOES_NOT_EXIST.toLocalizedString(parent));
-   * Gets the mcastAddress of the distributed system that this Agent is
-   * managing.
+   * Gets the mcastAddress of the distributed system that this Agent is managing.
-   * @return   The mcastAddress value
+   * @return The mcastAddress value
-   * Sets the mcastAddress of the distributed system that this Agent is
-   * managing.
+   * Sets the mcastAddress of the distributed system that this Agent is managing.
-   * @param mcastAddress  The new mcastAddress value
+   * @param mcastAddress The new mcastAddress value
-   * @return   The mcastPort value
+   * @return The mcastPort value
-   * @param mcastPort  The new mcastPort value
+   * @param mcastPort The new mcastPort value
-   * @return   The locators value
+   * @return The locators value
-   * @param locators  The new locators value
+   * @param locators The new locators value
-   * Gets the membership UDP port range in the distributed system that this
-   * Agent is monitoring.
+   * Gets the membership UDP port range in the distributed system that this Agent is monitoring.
-   * Sets the membership UDP port range in the distributed system that this
-   * Agent is monitoring.
+   * Sets the membership UDP port range in the distributed system that this Agent is monitoring.
-   * @return   The bindAddress value
+   * @return The bindAddress value
-     return this.agentConfig.getBindAddress();
+    return this.agentConfig.getBindAddress();
-   * @param bindAddress  The new bindAddress value
+   * @param bindAddress The new bindAddress value
-   * Retrieves the command that the DistributedSystem will use to perform remote
-   * manipulation of config files and log files.
+   * Retrieves the command that the DistributedSystem will use to perform remote manipulation of
+   * config files and log files.
-   * @return   the remote command for DistributedSystem
+   * @return the remote command for DistributedSystem
-	public String getRemoteCommand() {
-		return this.agentConfig.getRemoteCommand();
-	}
+  public String getRemoteCommand() {
+    return this.agentConfig.getRemoteCommand();
+  }
-   * Sets the command that the DistributedSystem will use to perform remote
-   * manipulation of config files and log files.
+   * Sets the command that the DistributedSystem will use to perform remote manipulation of config
+   * files and log files.
-	public void setRemoteCommand(String remoteCommand) {
-		this.agentConfig.setRemoteCommand(remoteCommand);
-	}
+  public void setRemoteCommand(String remoteCommand) {
+    this.agentConfig.setRemoteCommand(remoteCommand);
+  }
-   * Gets the logFileSizeLimit in megabytes of this Agent. Zero indicates no
-   * limit.
+   * Gets the logFileSizeLimit in megabytes of this Agent. Zero indicates no limit.
-   * @return   The logFileSizeLimit value
+   * @return The logFileSizeLimit value
-   * Sets the logFileSizeLimit in megabytes of this Agent. Zero indicates no
-   * limit.
+   * Sets the logFileSizeLimit in megabytes of this Agent. Zero indicates no limit.
-   * @param logFileSizeLimit  The new logFileSizeLimit value
+   * @param logFileSizeLimit The new logFileSizeLimit value
-   * Gets the logDiskSpaceLimit in megabytes of this Agent. Zero indicates no
-   * limit.
+   * Gets the logDiskSpaceLimit in megabytes of this Agent. Zero indicates no limit.
-   * @return   The logDiskSpaceLimit value
+   * @return The logDiskSpaceLimit value
-   * Sets the logDiskSpaceLimit in megabytes of this Agent. Zero indicates no
-   * limit.
+   * Sets the logDiskSpaceLimit in megabytes of this Agent. Zero indicates no limit.
-   * @param logDiskSpaceLimit  The new logDiskSpaceLimit value
+   * @param logDiskSpaceLimit The new logDiskSpaceLimit value
-   * @return   The logFile value
+   * @return The logFile value
-   * @param logFile  The new logFile value
+   * @param logFile The new logFile value
-   * @return   The logLevel value
+   * @return The logLevel value
-   * @param logLevel  The new logLevel value
+   * @param logLevel The new logLevel value
+
+
-   * Returns the address (URL) on which the RMI connector server runs
-   * or <code>null</code> if the RMI connector server has not been
-   * started.  This method is used primarily for testing purposes.
+   * Returns the address (URL) on which the RMI connector server runs or <code>null</code> if the
+   * RMI connector server has not been started. This method is used primarily for testing purposes.
-  //   Internal implementation methods
+  // Internal implementation methods
-    }
-    catch (IOException ex) {
-      return LocalizedStrings.AgentImpl_COULD_NOT_TAIL_0_BECAUSE_1.toLocalizedString(new Object[] {f, ex});
+    } catch (IOException ex) {
+      return LocalizedStrings.AgentImpl_COULD_NOT_TAIL_0_BECAUSE_1
+          .toLocalizedString(new Object[] {f, ex});
-   * @return   the GemFire mbeanServer
+   * @return the GemFire mbeanServer
-//  /**
-//   * Returns the active modeler Registry which has been initialized with all
-//   * the ModelMBean descriptors needed for GemFire MBeans.
-//   *
-//   * @return   the modeler registry
-//  */
-//  private Registry getRegistry() {
-//    return MBeanUtil.getRegistry();
-//  }
+  // /**
+  // * Returns the active modeler Registry which has been initialized with all
+  // * the ModelMBean descriptors needed for GemFire MBeans.
+  // *
+  // * @return the modeler registry
+  // */
+  // private Registry getRegistry() {
+  // return MBeanUtil.getRegistry();
+  // }
-    new Thread(LoggingThreadGroup.createThreadGroup("Shutdown"), "Shutdown") {
-      @Override
-      public void run() {
+      new Thread(LoggingThreadGroup.createThreadGroup("Shutdown"), "Shutdown") {
+        @Override
+        public void run() {
-      }
-    };
-    
+        }
+      };
+
-    if( ! Boolean.getBoolean( org.apache.geode.distributed.internal.InternalDistributedSystem.DISABLE_SHUTDOWN_HOOK_PROPERTY)) {
+    if (!Boolean.getBoolean(
+        org.apache.geode.distributed.internal.InternalDistributedSystem.DISABLE_SHUTDOWN_HOOK_PROPERTY)) {
-    if( ! Boolean.getBoolean( org.apache.geode.distributed.internal.InternalDistributedSystem.DISABLE_SHUTDOWN_HOOK_PROPERTY)) {
+    if (!Boolean.getBoolean(
+        org.apache.geode.distributed.internal.InternalDistributedSystem.DISABLE_SHUTDOWN_HOOK_PROPERTY)) {
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="RV_RETURN_VALUE_IGNORED_BAD_PRACTICE", justification="Return value for file delete is not important here.") 
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "RV_RETURN_VALUE_IGNORED_BAD_PRACTICE",
+      justification = "Return value for file delete is not important here.")
-    
+
-    this.logWriterAppender = LogWriterAppenders.getOrCreateAppender(LogWriterAppenders.Identifier.MAIN, false, logConfig, false);
+    this.logWriterAppender = LogWriterAppenders
+        .getOrCreateAppender(LogWriterAppenders.Identifier.MAIN, false, logConfig, false);
-    } else {      
+    } else {
-    
+
-    logger.info(LogMarker.CONFIG, LocalizedStrings.AgentImpl_AGENT_CONFIG_PROPERTY_FILE_NAME_0.toLocalizedString(AgentConfigImpl.retrievePropertyFile()));
+    logger.info(LogMarker.CONFIG, LocalizedStrings.AgentImpl_AGENT_CONFIG_PROPERTY_FILE_NAME_0
+        .toLocalizedString(AgentConfigImpl.retrievePropertyFile()));
-   * Stops the HttpAdaptor and its XsltProcessor.  Unregisters the associated
-   * MBeans.
+   * Stops the HttpAdaptor and its XsltProcessor. Unregisters the associated MBeans.
-    if (!this.agentConfig.isHttpEnabled()) return;
+    if (!this.agentConfig.isHttpEnabled())
+      return;
-    if (!this.agentConfig.isRmiEnabled()) return;
+    if (!this.agentConfig.isRmiEnabled())
+      return;
-      if (this.agentConfig.isRmiRegistryEnabled() &&
-          mBeanServer.isRegistered(rmiRegistryNamingName)) {
+      if (this.agentConfig.isRmiRegistryEnabled()
+          && mBeanServer.isRegistered(rmiRegistryNamingName)) {
-    if (!this.agentConfig.isSnmpEnabled()) return;
+    if (!this.agentConfig.isSnmpEnabled())
+      return;
-      getMBeanServer().invoke(getSnmpAdaptorName(), "unbind",
-                              new Object[0],
-                              new String[0]);
+      getMBeanServer().invoke(getSnmpAdaptorName(), "unbind", new Object[0], new String[0]);
-  throws javax.management.MalformedObjectNameException {
+      throws javax.management.MalformedObjectNameException {
-  private ObjectName getHttpAdaptorName()
-  throws javax.management.MalformedObjectNameException {
+  private ObjectName getHttpAdaptorName() throws javax.management.MalformedObjectNameException {
-  throws javax.management.MalformedObjectNameException {
+      throws javax.management.MalformedObjectNameException {
-  private ObjectName getSnmpAdaptorName()
-  throws javax.management.MalformedObjectNameException {
+  private ObjectName getSnmpAdaptorName() throws javax.management.MalformedObjectNameException {
-  private ObjectName getXsltProcessorName()
-  throws javax.management.MalformedObjectNameException {
+  private ObjectName getXsltProcessorName() throws javax.management.MalformedObjectNameException {
-  //   Factory method for creating DistributedSystem
+  // Factory method for creating DistributedSystem
-  throws org.apache.geode.admin.AdminException {
+      throws org.apache.geode.admin.AdminException {
-  //   Agent main
+  // Agent main
-   * Accepts command-line arguments matching the options in {@link AgentConfig}
-   * and {@link org.apache.geode.admin.DistributedSystemConfig}.
+   * Accepts command-line arguments matching the options in {@link AgentConfig} and
+   * {@link org.apache.geode.admin.DistributedSystemConfig}.
-    }
-    catch (RuntimeException ex) {
-      System.err.println(LocalizedStrings.AgentImpl_FAILED_READING_CONFIGURATION_0.toLocalizedString(ex));
+    } catch (RuntimeException ex) {
+      System.err
+          .println(LocalizedStrings.AgentImpl_FAILED_READING_CONFIGURATION_0.toLocalizedString(ex));
-    }
-    catch (VirtualMachineError err) {
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Throwable t) {
+    } catch (Throwable t) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-  //   MX4J Connectors/Adaptors
+  // MX4J Connectors/Adaptors
-    int    port = this.agentConfig.getRmiPort();
+    int port = this.agentConfig.getRmiPort();
-    /* Register and start the rmi-registry naming MBean, which is
-     * needed by JSR 160 RMIConnectorServer */
+    /*
+     * Register and start the rmi-registry naming MBean, which is needed by JSR 160
+     * RMIConnectorServer
+     */
-                          registryName));
+          registryName));
-   * If {@link AgentConfig#isRmiEnabled} returns false, then this adaptor will
-   * not be started.
+   * If {@link AgentConfig#isRmiEnabled} returns false, then this adaptor will not be started.
-    if (!this.agentConfig.isRmiEnabled()) return;
+    if (!this.agentConfig.isRmiEnabled())
+      return;
-    String rmiBindAddress  = this.agentConfig.getRmiBindAddress();
+    String rmiBindAddress = this.agentConfig.getRmiBindAddress();
-    String overrideHostName     = System.getProperty(rmiStubServerNameKey);
-    if ((overrideHostName == null || overrideHostName.trim().length()==0) &&
-        (rmiBindAddress != null && rmiBindAddress.trim().length()!=0)
-       ) {
+    String overrideHostName = System.getProperty(rmiStubServerNameKey);
+    if ((overrideHostName == null || overrideHostName.trim().length() == 0)
+        && (rmiBindAddress != null && rmiBindAddress.trim().length() != 0)) {
-        logger.info(LocalizedMessage.create(LocalizedStrings.AgentImpl_RMICONNECTORSERVER_ALREADY_REGISTERED_AS__0, objName));
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.AgentImpl_RMICONNECTORSERVER_ALREADY_REGISTERED_AS__0, objName));
-       * url defined as: service:jmx:protocol:sap
-       * where
-       * 1. protocol: rmi
-       * 2. sap is: [host[:port]][url-path]
-       *    where
-       *      host: rmi-binding-address
-       *      port: rmi-server-port
-       *      url-path: /jndi/rmi://<rmi-binding-address>:<rmi-port><JNDI_NAME>
+       * url defined as: service:jmx:protocol:sap where 1. protocol: rmi 2. sap is:
+       * [host[:port]][url-path] where host: rmi-binding-address port: rmi-server-port url-path:
+       * /jndi/rmi://<rmi-binding-address>:<rmi-port><JNDI_NAME>
-      String urlString           = null;
+      String urlString = null;
-      int    connectorServerPort = this.agentConfig.getRmiServerPort();
-      String rmiRegistryHost     = "";
-      int    rmiRegistryPort     = this.agentConfig.getRmiPort();
+      int connectorServerPort = this.agentConfig.getRmiServerPort();
+      String rmiRegistryHost = "";
+      int rmiRegistryPort = this.agentConfig.getRmiPort();
-      if (rmiBindAddress == null || rmiBindAddress.trim().length()==0) {
+      if (rmiBindAddress == null || rmiBindAddress.trim().length() == 0) {
-        rmiRegistryHost   = "";
+        rmiRegistryHost = "";
-        rmiRegistryHost     = connectorServerHost;
+        rmiRegistryHost = connectorServerHost;
-      urlString = MessageFormat.format(AgentImpl.JMX_SERVICE_URL,
-                                           connectorServerHost,
-                                           String.valueOf(connectorServerPort),
-                                           rmiRegistryHost,
-                                           String.valueOf(rmiRegistryPort),
-                                           JNDI_NAME);
+      urlString = MessageFormat.format(AgentImpl.JMX_SERVICE_URL, connectorServerHost,
+          String.valueOf(connectorServerPort), rmiRegistryHost, String.valueOf(rmiRegistryPort),
+          JNDI_NAME);
-//      env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.rmi.registry.RegistryContextFactory");
-//      env.put(Context.PROVIDER_URL, "rmi://localhost:1099");
+      // env.put(Context.INITIAL_CONTEXT_FACTORY,
+      // "com.sun.jndi.rmi.registry.RegistryContextFactory");
+      // env.put(Context.PROVIDER_URL, "rmi://localhost:1099");
-      RMIServerSocketFactory ssf = new MX4JServerSocketFactory(
-            this.agentConfig.isAgentSSLEnabled(),     // true,
-            this.agentConfig.isAgentSSLRequireAuth(), // true,
-            this.agentConfig.getAgentSSLProtocols(),  // "any",
-            this.agentConfig.getAgentSSLCiphers(),    // "any",
-            this.agentConfig.getRmiBindAddress(),
-            10,  // backlog
-            this.agentConfig.getGfSecurityProperties());
+      RMIServerSocketFactory ssf = new MX4JServerSocketFactory(this.agentConfig.isAgentSSLEnabled(), // true,
+          this.agentConfig.isAgentSSLRequireAuth(), // true,
+          this.agentConfig.getAgentSSLProtocols(), // "any",
+          this.agentConfig.getAgentSSLCiphers(), // "any",
+          this.agentConfig.getRmiBindAddress(), 10, // backlog
+          this.agentConfig.getGfSecurityProperties());
-      this.rmiConnector =
-                JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);
+      this.rmiConnector = JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);
-      this.rmiConnector.addNotificationListener(
-          new ConnectionNotificationAdapter(),
-          new ConnectionNotificationFilterImpl(),
-          this);
+      this.rmiConnector.addNotificationListener(new ConnectionNotificationAdapter(),
+          new ConnectionNotificationFilterImpl(), this);
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      throw new StartupException(LocalizedStrings.AgentImpl_FAILED_TO_START_RMI_SERVICE.toLocalizedString(), t);
+      throw new StartupException(
+          LocalizedStrings.AgentImpl_FAILED_TO_START_RMI_SERVICE.toLocalizedString(), t);
-   * If {@link AgentConfig#isSnmpEnabled} returns false, then this adaptor will
-   * not be started.
+   * If {@link AgentConfig#isSnmpEnabled} returns false, then this adaptor will not be started.
-    if (!this.agentConfig.isSnmpEnabled()) return;
+    if (!this.agentConfig.isSnmpEnabled())
+      return;
-        logger.info(LocalizedMessage.create(LocalizedStrings.AgentImpl_SNMPADAPTOR_ALREADY_REGISTERED_AS__0, objName));
+        logger.info(LocalizedMessage
+            .create(LocalizedStrings.AgentImpl_SNMPADAPTOR_ALREADY_REGISTERED_AS__0, objName));
-        throw new IllegalArgumentException(LocalizedStrings.AgentImpl_SNMPDIRECTORY_MUST_BE_SPECIFIED_BECAUSE_SNMP_IS_ENABLED.toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.AgentImpl_SNMPDIRECTORY_MUST_BE_SPECIFIED_BECAUSE_SNMP_IS_ENABLED
+                .toLocalizedString());
-        throw new IllegalArgumentException(LocalizedStrings.AgentImpl_SNMPDIRECTORY_DOES_NOT_EXIST.toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.AgentImpl_SNMPDIRECTORY_DOES_NOT_EXIST.toLocalizedString());
-      String[] sigs = new String[] { "java.lang.String" };
-      Object[] args = new Object[] { snmpDir };
+      String[] sigs = new String[] {"java.lang.String"};
+      Object[] args = new Object[] {snmpDir};
-        sigs = new String[] { "java.lang.String", sigs[0] };
-        args = new Object[] { bindAddress, args[0] };
+        sigs = new String[] {"java.lang.String", sigs[0]};
+        args = new Object[] {bindAddress, args[0]};
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch(Throwable t) {
+    } catch (Throwable t) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      logger.error(LocalizedMessage.create(LocalizedStrings.AgentImpl_FAILED_TO_START_SNMPADAPTOR__0, t.getMessage()));
-      throw new StartupException(LocalizedStrings.AgentImpl_FAILED_TO_START_SNMPADAPTOR__0.toLocalizedString(t.getMessage()), t);
+      logger.error(LocalizedMessage
+          .create(LocalizedStrings.AgentImpl_FAILED_TO_START_SNMPADAPTOR__0, t.getMessage()));
+      throw new StartupException(LocalizedStrings.AgentImpl_FAILED_TO_START_SNMPADAPTOR__0
+          .toLocalizedString(t.getMessage()), t);
-   * If {@link AgentConfig#isHttpEnabled} returns false, then this adaptor will
-   * not be started.
+   * If {@link AgentConfig#isHttpEnabled} returns false, then this adaptor will not be started.
-    if (!this.agentConfig.isHttpEnabled()) return;
+    if (!this.agentConfig.isHttpEnabled())
+      return;
-        logger.info(LocalizedMessage.create(LocalizedStrings.AgentImpl_HTTPADAPTOR_ALREADY_REGISTERED_AS__0, objName));
+        logger.info(LocalizedMessage
+            .create(LocalizedStrings.AgentImpl_HTTPADAPTOR_ALREADY_REGISTERED_AS__0, objName));
-        logger.info(LogMarker.CONFIG, LocalizedMessage.create(LocalizedStrings.AgentImpl_HTTP_ADAPTOR_LISTENING_ON_PORT__0, this.agentConfig.getHttpPort()));
-      }
-      else {
-        logger.error(LocalizedMessage.create(LocalizedStrings.AgentImpl_INCORRECT_PORT_VALUE__0, this.agentConfig.getHttpPort()));
+        logger.info(LogMarker.CONFIG,
+            LocalizedMessage.create(LocalizedStrings.AgentImpl_HTTP_ADAPTOR_LISTENING_ON_PORT__0,
+                this.agentConfig.getHttpPort()));
+      } else {
+        logger.error(LocalizedMessage.create(LocalizedStrings.AgentImpl_INCORRECT_PORT_VALUE__0,
+            this.agentConfig.getHttpPort()));
-        logger.info(LogMarker.CONFIG, LocalizedMessage.create(LocalizedStrings.AgentImpl_HTTP_ADAPTOR_LISTENING_ON_ADDRESS__0, host));
+        logger.info(LogMarker.CONFIG, LocalizedMessage
+            .create(LocalizedStrings.AgentImpl_HTTP_ADAPTOR_LISTENING_ON_ADDRESS__0, host));
-      }
-      else {
+      } else {
-        new MX4JServerSocketFactory(
-            this.agentConfig.isAgentSSLEnabled(),
-            this.agentConfig.isHttpSSLRequireAuth(),
-            this.agentConfig.getAgentSSLProtocols(),
-            this.agentConfig.getAgentSSLCiphers(),
-            this.agentConfig.getGfSecurityProperties());
+          new MX4JServerSocketFactory(this.agentConfig.isAgentSSLEnabled(),
+              this.agentConfig.isHttpSSLRequireAuth(), this.agentConfig.getAgentSSLProtocols(),
+              this.agentConfig.getAgentSSLCiphers(), this.agentConfig.getGfSecurityProperties());
-        this.httpAdaptor.setAuthenticationMethod(
-            MX4J_HTTPADAPTOR_BASIC_AUTHENTICATION); // only basic works
+        this.httpAdaptor.setAuthenticationMethod(MX4J_HTTPADAPTOR_BASIC_AUTHENTICATION); // only
+                                                                                         // basic
+                                                                                         // works
-        this.httpAdaptor.addAuthorization(
-            this.agentConfig.getHttpAuthUser(),
+        this.httpAdaptor.addAuthorization(this.agentConfig.getHttpAuthUser(),
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      logger.error(LocalizedMessage.create(LocalizedStrings.AgentImpl_FAILED_TO_START_HTTPADAPTOR__0, t.getMessage()));
-      throw new StartupException(LocalizedStrings.AgentImpl_FAILED_TO_START_HTTPADAPTOR__0.toLocalizedString(t.getMessage()), t);
+      logger.error(LocalizedMessage
+          .create(LocalizedStrings.AgentImpl_FAILED_TO_START_HTTPADAPTOR__0, t.getMessage()));
+      throw new StartupException(LocalizedStrings.AgentImpl_FAILED_TO_START_HTTPADAPTOR__0
+          .toLocalizedString(t.getMessage()), t);
-  private ObjectName createXsltProcessor()
-  throws javax.management.JMException {
+  private ObjectName createXsltProcessor() throws javax.management.JMException {
-      logger.info(LocalizedMessage.create(LocalizedStrings.AgentImpl_XSLTPROCESSOR_ALREADY_REGISTERED_AS__0, objName));
+      logger.info(LocalizedMessage
+          .create(LocalizedStrings.AgentImpl_XSLTPROCESSOR_ALREADY_REGISTERED_AS__0, objName));
-    getMBeanServer().registerMBean(
-      new mx4j.tools.adaptor.http.XSLTProcessor(), objName);
+    getMBeanServer().registerMBean(new mx4j.tools.adaptor.http.XSLTProcessor(), objName);
-  //   Private support methods...
+  // Private support methods...
-//  /** Not used anymore but seems moderately useful... */
-//  private String[] parseSSLCiphers(String ciphers) {
-//    List list = new ArrayList();
-//    StringTokenizer st = new StringTokenizer(ciphers);
-//    while (st.hasMoreTokens()) {
-//      list.add(st.nextToken());
-//    }
-//    return (String[]) list.toArray(new String[list.size()]);
-//  }
+  // /** Not used anymore but seems moderately useful... */
+  // private String[] parseSSLCiphers(String ciphers) {
+  // List list = new ArrayList();
+  // StringTokenizer st = new StringTokenizer(ciphers);
+  // while (st.hasMoreTokens()) {
+  // list.add(st.nextToken());
+  // }
+  // return (String[]) list.toArray(new String[list.size()]);
+  // }
-  //   SSL configuration for GemFire
+  // SSL configuration for GemFire
+
+
+
+
+
+
+
+
+
+
+
-  //   ManagedResource implementation
+  // ManagedResource implementation
-	public String getMBeanName() {
-		return this.mbeanName;
-	}
+  public String getMBeanName() {
+    return this.mbeanName;
+  }
-	public ModelMBean getModelMBean() {
-		return this.modelMBean;
-	}
-	public void setModelMBean(ModelMBean modelMBean) {
-		this.modelMBean = modelMBean;
-	}
+  public ModelMBean getModelMBean() {
+    return this.modelMBean;
+  }
+
+  public void setModelMBean(ModelMBean modelMBean) {
+    this.modelMBean = modelMBean;
+  }
+
+
-  //   Other Support methods
+  // Other Support methods
-   * Checks the no. of active RMI clients and updates a flag in the Admin
-   * Distributed System.
+   * Checks the no. of active RMI clients and updates a flag in the Admin Distributed System.
-    AdminDistributedSystemJmxImpl adminDSJmx =
-                                (AdminDistributedSystemJmxImpl) this.system;
+    AdminDistributedSystemJmxImpl adminDSJmx = (AdminDistributedSystemJmxImpl) this.system;
-//    sb.append("; adaptor=" + httpAdaptor.toString());
+    // sb.append("; adaptor=" + httpAdaptor.toString());
-//    sb.append("; system=" + system);)
+    // sb.append("; system=" + system);)
-  /** Process the String form of a hostname to make it comply with Jmx URL
-   * restrictions. Namely wrap IPv6 literal address with "[", "]"
+  /**
+   * Process the String form of a hostname to make it comply with Jmx URL restrictions. Namely wrap
+   * IPv6 literal address with "[", "]"
+   * 
-    if(hostname.indexOf(":") != -1) {
-      //Assuming an IPv6 literal because of the ':'
+    if (hostname.indexOf(":") != -1) {
+      // Assuming an IPv6 literal because of the ':'
+
-   * @param notification
-   *          JMXConnectionNotification for change in client connection status
-   * @param handback
-   *          An opaque object which helps the listener to associate information
-   *          regarding the MBean emitter. This object is passed to the MBean
-   *          during the addListener call and resent, without modification, to
-   *          the listener. The MBean object should not use or modify the
-   *          object. (NOTE: copied from javax.management.NotificationListener)
+   * @param notification JMXConnectionNotification for change in client connection status
+   * @param handback An opaque object which helps the listener to associate information regarding
+   *        the MBean emitter. This object is passed to the MBean during the addListener call and
+   *        resent, without modification, to the listener. The MBean object should not use or modify
+   *        the object. (NOTE: copied from javax.management.NotificationListener)
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="BC_UNCONFIRMED_CAST", justification="Only JMXConnectionNotification instances are used.") 
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "BC_UNCONFIRMED_CAST",
+      justification = "Only JMXConnectionNotification instances are used.")
-      JMXConnectionNotification jmxNotifn =
-        (JMXConnectionNotification) notification;
+      JMXConnectionNotification jmxNotifn = (JMXConnectionNotification) notification;
-        logger.debug("Connection notification for connection id : '{}'", jmxNotifn.getConnectionId());
+        logger.debug("Connection notification for connection id : '{}'",
+            jmxNotifn.getConnectionId());
+
-   * Invoked before sending the specified notification to the listener.
-   * Returns whether the given notification is to be sent to the listener.
+   * Invoked before sending the specified notification to the listener. Returns whether the given
+   * notification is to be sent to the listener.
-   * @param notification
-   *          The notification to be sent.
-   * @return true if the notification has to be sent to the listener, false
-   *         otherwise.
+   * @param notification The notification to be sent.
+   * @return true if the notification has to be sent to the listener, false otherwise.
-    if (notification.getType().equals(JMXConnectionNotification.OPENED) ||
-        notification.getType().equals(JMXConnectionNotification.CLOSED) ||
-        notification.getType().equals(JMXConnectionNotification.FAILED) ) {
+    if (notification.getType().equals(JMXConnectionNotification.OPENED)
+        || notification.getType().equals(JMXConnectionNotification.CLOSED)
+        || notification.getType().equals(JMXConnectionNotification.FAILED)) {

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Empty shell for {@link BucketRegion} which exists only to maintain metadata
- * in the form of a {@link BucketAdvisor}
+ * Empty shell for {@link BucketRegion} which exists only to maintain metadata in the form of a
+ * {@link BucketAdvisor}
-  
+
-   * Note that LocalRegion has a version of this name spelled "NO_PARTITITON".
-   * So if code is written that compares to this constant make sure to also
-   * compare to the other one from LocalRegion.
-   * The one in LocalRegion is a typo but has already been persisted in older versions.
+   * Note that LocalRegion has a version of this name spelled "NO_PARTITITON". So if code is written
+   * that compares to this constant make sure to also compare to the other one from LocalRegion. The
+   * one in LocalRegion is a typo but has already been persisted in older versions.
+
+   * 
-  public ProxyBucketRegion(int bid, 
-      PartitionedRegion partitionedRegion, 
+  public ProxyBucketRegion(int bid, PartitionedRegion partitionedRegion,
-    this.advisor = BucketAdvisor.createBucketAdvisor(this, internalRegionArgs.getPartitionedRegionAdvisor());
-    
+    this.advisor =
+        BucketAdvisor.createBucketAdvisor(this, internalRegionArgs.getPartitionedRegionAdvisor());
+
-    
-    if(this.partitionedRegion.getDataPolicy().withPersistence() ) {
-      
+
+    if (this.partitionedRegion.getDataPolicy().withPersistence()) {
+
-      PersistentMemberManager memberManager = partitionedRegion.getGemFireCache().getPersistentMemberManager();
+      PersistentMemberManager memberManager =
+          partitionedRegion.getGemFireCache().getPersistentMemberManager();
-      DistributedLockService dl = partitionedRegion.getGemFireCache().getPartitionedRegionLockService();
+      DistributedLockService dl =
+          partitionedRegion.getGemFireCache().getPartitionedRegionLockService();
-      if(partitionedRegion.getConcurrencyChecksEnabled()) {
+      if (partitionedRegion.getConcurrencyChecksEnabled()) {
-      List<FixedPartitionAttributesImpl> fpaList = partitionedRegion.getFixedPartitionAttributesImpl(); 
+      List<FixedPartitionAttributesImpl> fpaList =
+          partitionedRegion.getFixedPartitionAttributesImpl();
-      this.diskRegion = DiskRegion.create(ds,
-                                          regionPath, true, partitionedRegion.getPersistBackup(),
-                                          overflowEnabled, partitionedRegion.isDiskSynchronous(),
-                                          partitionedRegion.getDiskRegionStats(),
-                                          partitionedRegion.getCancelCriterion(),
-                                          partitionedRegion,
-                                          partitionedRegion.getAttributes(),
-                                          diskFlags, partitionName, startingBucketID,
-                                          partitionedRegion.getCompressor(),
-                                          partitionedRegion.getOffHeap());
-      
+      this.diskRegion =
+          DiskRegion.create(ds, regionPath, true, partitionedRegion.getPersistBackup(),
+              overflowEnabled, partitionedRegion.isDiskSynchronous(),
+              partitionedRegion.getDiskRegionStats(), partitionedRegion.getCancelCriterion(),
+              partitionedRegion, partitionedRegion.getAttributes(), diskFlags, partitionName,
+              startingBucketID, partitionedRegion.getCompressor(), partitionedRegion.getOffHeap());
+
-            partitionedRegion.getPartitionsMap()
-                .put(
-                    fpa.getPartitionName(),
-                    new Integer[] { fpa.getStartingBucketID(),
-                        fpa.getNumBuckets() });
+            partitionedRegion.getPartitionsMap().put(fpa.getPartitionName(),
+                new Integer[] {fpa.getStartingBucketID(), fpa.getNumBuckets()});
-      
-      this.persistenceAdvisor = new BucketPersistenceAdvisor(advisor, dl,
-          diskRegion, regionPath, diskStats, memberManager, bucketLock, this);
+
+      this.persistenceAdvisor = new BucketPersistenceAdvisor(advisor, dl, diskRegion, regionPath,
+          diskStats, memberManager, bucketLock, this);
-  
+
-    if(this.persistenceAdvisor != null) {
+    if (this.persistenceAdvisor != null) {
-    if(this.diskRegion != null) {
+    if (this.diskRegion != null) {
-    
+
-    return Region.SEPARATOR + PartitionedRegionHelper.PR_ROOT_REGION_NAME + Region.SEPARATOR + 
-    getPartitionedRegion().getBucketName(this.bid);
+    return Region.SEPARATOR + PartitionedRegionHelper.PR_ROOT_REGION_NAME + Region.SEPARATOR
+        + getPartitionedRegion().getBucketName(this.bid);
-   * Notify this proxy of the real bucket as its target.  Future calls to this instance will then proxy  
-   * them back to the real bucket.
-   * @param br the real bucket which will be the target for this proxy 
+   * Notify this proxy of the real bucket as its target. Future calls to this instance will then
+   * proxy them back to the real bucket.
+   * 
+   * @param br the real bucket which will be the target for this proxy
-  public void setBucketRegion(BucketRegion br)
-  {
+  public void setBucketRegion(BucketRegion br) {
-    Assert.assertTrue( ! this.advisor.isHosting());
+    Assert.assertTrue(!this.advisor.isHosting());
-  
-  public void clearBucketRegion(BucketRegion br)  {
+
+  public void clearBucketRegion(BucketRegion br) {
-  
+
-      Assert.assertTrue( ! this.advisor.isHosting());
+      Assert.assertTrue(!this.advisor.isHosting());
-        List<FixedPartitionAttributesImpl> list = region
-            .getFixedPartitionAttributesImpl();
+        List<FixedPartitionAttributesImpl> list = region.getFixedPartitionAttributesImpl();
-      }
-      else { // normal PR 
+      } else { // normal PR
-    }
-    else {      
-     // Assert.assertTrue(!getPartitionedRegion().getDataStore().isManagingBucket(this.bid));
-      this.advisor.setHosting(false);            
+    } else {
+      // Assert.assertTrue(!getPartitionedRegion().getDataStore().isManagingBucket(this.bid));
+      this.advisor.setHosting(false);
-  
+
-   * Get the redundancy of the this bucket, taking into  
-   * account the local bucket, if any.
-   * @return number of redundant copies for a given bucket, or -1 if
-   * there are no instances of the bucket.
+   * Get the redundancy of the this bucket, taking into account the local bucket, if any.
+   * 
+   * @return number of redundant copies for a given bucket, or -1 if there are no instances of the
+   *         bucket.
-  
-  public boolean isPrimary()
-  {
+
+  public boolean isPrimary() {
-   * Returns the real BucketRegion if one has been created. This call will 
-   * return the bucket even if it is still being initialized. Returns null
-   * if the bucket has not been created locally.
+   * Returns the real BucketRegion if one has been created. This call will return the bucket even if
+   * it is still being initialized. Returns null if the bucket has not been created locally.
-  
+
-   * Returns the real BucketRegion that is currently being locally hosted. 
-   * Returns null if the real bucket is null or if it is still being 
-   * initialized. After the bucket is intialized isHosting will be flagged 
-   * true and future calls to this method will return the bucket.
+   * Returns the real BucketRegion that is currently being locally hosted. Returns null if the real
+   * bucket is null or if it is still being initialized. After the bucket is intialized isHosting
+   * will be flagged true and future calls to this method will return the bucket.
-    } 
-    else {
+    } else {
-  
+
-  public ProxyBucketRegion initialize()
-  {
+  public ProxyBucketRegion initialize() {
-    //this.advisor.initializationGate();
+    // this.advisor.initializationGate();
-  public Set<InternalDistributedMember> getBucketOwners()
-  {
+  public Set<InternalDistributedMember> getBucketOwners() {
-  
+
-  
+
-  
+
-  
+
-    synchronized(this.sickHosts) {
+    synchronized (this.sickHosts) {
-  
+
-    synchronized(this.sickHosts) {
+    synchronized (this.sickHosts) {
-  
+
-    
-    List<PartitionedRegion> colocatedWithList = ColocationHelper.getColocatedChildRegions(partitionedRegion);
-    for(PartitionedRegion childPR : colocatedWithList) {
-      if(childPR.getDataPolicy().withPersistence()) {
+
+    List<PartitionedRegion> colocatedWithList =
+        ColocationHelper.getColocatedChildRegions(partitionedRegion);
+    for (PartitionedRegion childPR : colocatedWithList) {
+      if (childPR.getDataPolicy().withPersistence()) {
-        if(childBucketArray != null) {
+        if (childBucketArray != null) {
-    
+
-      logger.debug("{} coming to recover from disk. wasHosting {}", getFullPath(), persistenceAdvisor.wasHosting());
+      logger.debug("{} coming to recover from disk. wasHosting {}", getFullPath(),
+          persistenceAdvisor.wasHosting());
-      if(persistenceAdvisor.wasHosting()) {
+      if (persistenceAdvisor.wasHosting()) {
-        if(hasPersistentChildRegion()) {
+        if (hasPersistentChildRegion()) {
-           result = partitionedRegion.getDataStore()
-          .grabBucket(bid, getDistributionManager().getDistributionManagerId(), 
-              true, true, false, null, true);
+          result = partitionedRegion.getDataStore().grabBucket(bid,
+              getDistributionManager().getDistributionManagerId(), true, true, false, null, true);
-            PartitionedRegion colocatedRegion = 
-              ColocationHelper.getColocatedRegion(this.partitionedRegion);
-            
-            if(this.partitionedRegion.getDataPolicy().withPersistence() && !colocatedRegion.getDataPolicy().withPersistence()) {
-              result = colocatedRegion.getDataStore()
-              .grabBucket(bid, getDistributionManager().getDistributionManagerId(), 
-                  true, true, false, null, true);
-              
-              if(result.nowExists()) {
-                result = partitionedRegion.getDataStore()
-                .grabBucket(bid, null, true, false, false, null, true);
+            PartitionedRegion colocatedRegion =
+                ColocationHelper.getColocatedRegion(this.partitionedRegion);
+
+            if (this.partitionedRegion.getDataPolicy().withPersistence()
+                && !colocatedRegion.getDataPolicy().withPersistence()) {
+              result = colocatedRegion.getDataStore().grabBucket(bid,
+                  getDistributionManager().getDistributionManagerId(), true, true, false, null,
+                  true);
+
+              if (result.nowExists()) {
+                result = partitionedRegion.getDataStore().grabBucket(bid, null, true, false, false,
+                    null, true);
+            } else {
+              result = partitionedRegion.getDataStore().grabBucket(bid, null, true, false, false,
+                  null, true);
-            else{
-              result = partitionedRegion.getDataStore()
-              .grabBucket(bid, null, true, false, false, null, true);  
-            }
-          } else{
-            result = partitionedRegion.getDataStore()
-            .grabBucket(bid, null, true, false, false, null, true);  
+          } else {
+            result = partitionedRegion.getDataStore().grabBucket(bid, null, true, false, false,
+                null, true);
-          
+
-        if(result.nowExists()) {
+        if (result.nowExists()) {
-          //TODO prpersist - check cache closure, create new error message
+          // TODO prpersist - check cache closure, create new error message
-          throw new InternalGemFireError("Unable to restore the persistent bucket " + this.getName());
+          throw new InternalGemFireError(
+              "Unable to restore the persistent bucket " + this.getName());
-          logger.debug("{} redundancy is already satisfied, so discarding persisted data. Current hosts {}",
+          logger.debug(
+              "{} redundancy is already satisfied, so discarding persisted data. Current hosts {}",
-        //Destroy the data if we can't create the bucket, or if the redundancy is already satisfied
+        // Destroy the data if we can't create the bucket, or if the redundancy is already satisfied
-      
+
-    } catch(RuntimeException e) {
-      exception=e;
+    } catch (RuntimeException e) {
+      exception = e;
-    boolean hasPersistentChildRegion = 
-      ColocationHelper.hasPersistentChildRegion(partitionedRegion);
+    boolean hasPersistentChildRegion = ColocationHelper.hasPersistentChildRegion(partitionedRegion);
-    Map<InternalDistributedMember, PersistentMemberID> onlineMembers = advisor.adviseInitializedPersistentMembers();
+    Map<InternalDistributedMember, PersistentMemberID> onlineMembers =
+        advisor.adviseInitializedPersistentMembers();
-    if(this.persistenceAdvisor != null) {
+    if (this.persistenceAdvisor != null) {
-    
-    List<PartitionedRegion> colocatedWithList 
-      = ColocationHelper.getColocatedChildRegions(partitionedRegion);
-    for(PartitionedRegion childPR : colocatedWithList) {
+
+    List<PartitionedRegion> colocatedWithList =
+        ColocationHelper.getColocatedChildRegions(partitionedRegion);
+    for (PartitionedRegion childPR : colocatedWithList) {
-      if(childBucketArray != null) {
+      if (childBucketArray != null) {
-        if(childBucket.persistenceAdvisor != null) {
+        if (childBucket.persistenceAdvisor != null) {
-  
-  public boolean checkBucketRedundancyBeforeGrab(InternalDistributedMember moveSource, boolean replaceOfflineData) {
+
+  public boolean checkBucketRedundancyBeforeGrab(InternalDistributedMember moveSource,
+      boolean replaceOfflineData) {
-    //Skip any checks if this is a colocated bucket. We need to create
-    //the colocated bucket if we managed to create the parent bucket. There are 
-    //race conditions where the parent region may know that a member is no longer
-    //hosting the bucket, but the child region doesn't know that yet.
-    PartitionedRegion colocatedRegion = 
-      ColocationHelper.getColocatedRegion(this.partitionedRegion);
-    if(colocatedRegion != null) {
+    // Skip any checks if this is a colocated bucket. We need to create
+    // the colocated bucket if we managed to create the parent bucket. There are
+    // race conditions where the parent region may know that a member is no longer
+    // hosting the bucket, but the child region doesn't know that yet.
+    PartitionedRegion colocatedRegion = ColocationHelper.getColocatedRegion(this.partitionedRegion);
+    if (colocatedRegion != null) {
-    //Check for offline members, if the region has persistence
-    //Even if we intend to replace offline data, we still need to make
-    //sure the bucket isn't completely offline
-    if(!replaceOfflineData || redundancy == -1) {
+    // Check for offline members, if the region has persistence
+    // Even if we intend to replace offline data, we still need to make
+    // sure the bucket isn't completely offline
+    if (!replaceOfflineData || redundancy == -1) {
-      if(persistAdvisor != null) {
-        //If we haven't finished recovering from disk, don't allow the bucket creation.
-//        if(persistAdvisor.isRecovering()) {
-//          return false;
-//        }
-        //If we previously hosted this bucket, go ahead and initialize
-        //If this bucket never had a primary, go ahead and initialize,
-        //any offline buckets should be empty
-        if(!persistAdvisor.wasHosting() && advisor.getHadPrimary()) {
+      if (persistAdvisor != null) {
+        // If we haven't finished recovering from disk, don't allow the bucket creation.
+        // if(persistAdvisor.isRecovering()) {
+        // return false;
+        // }
+        // If we previously hosted this bucket, go ahead and initialize
+        // If this bucket never had a primary, go ahead and initialize,
+        // any offline buckets should be empty
+        if (!persistAdvisor.wasHosting() && advisor.getHadPrimary()) {
-          if(membershipView == null) {
-            //Fix for 42327 - There must be a race where we are being told to create a bucket
-            //before we recover from disk. In that case, the membership view can be null.
-            //Refuse to create the bucket if that is the case.
+          if (membershipView == null) {
+            // Fix for 42327 - There must be a race where we are being told to create a bucket
+            // before we recover from disk. In that case, the membership view can be null.
+            // Refuse to create the bucket if that is the case.
-              logger.debug("grabFreeBucket: Can't create bucket because persistence is not yet initialized {}{}{}",
+              logger.debug(
+                  "grabFreeBucket: Can't create bucket because persistence is not yet initialized {}{}{}",
-            logger.debug("We didn't host the bucket. Checking redundancy level before creating the bucket. Redundancy={} offline members={}",
+            logger.debug(
+                "We didn't host the bucket. Checking redundancy level before creating the bucket. Redundancy={} offline members={}",
-          
-          if(offlineMembers != null && !offlineMembers.isEmpty() && redundancy == -1) {
-            //If there are offline members, and no online members, throw
-            //an exception indicating that we can't create the bucket.
-            String message = LocalizedStrings.PartitionedRegionDataStore_DATA_OFFLINE_MESSAGE.toLocalizedString(partitionedRegion.getFullPath(), bid, offlineMembers);
-            throw new PartitionOfflineException((Set)offlineMembers, message);
+
+          if (offlineMembers != null && !offlineMembers.isEmpty() && redundancy == -1) {
+            // If there are offline members, and no online members, throw
+            // an exception indicating that we can't create the bucket.
+            String message = LocalizedStrings.PartitionedRegionDataStore_DATA_OFFLINE_MESSAGE
+                .toLocalizedString(partitionedRegion.getFullPath(), bid, offlineMembers);
+            throw new PartitionOfflineException((Set) offlineMembers, message);
-            //If there are online and offline members, add the offline
-            //members to the redundancy level. This way we won't create
-            //an extra copy of the bucket.
-            if(offlineMembers != null) {
+            // If there are online and offline members, add the offline
+            // members to the redundancy level. This way we won't create
+            // an extra copy of the bucket.
+            if (offlineMembers != null) {
-    
+
-      if (redundancy
-          >= this.partitionedRegion.getRedundantCopies()) {
+      if (redundancy >= this.partitionedRegion.getRedundantCopies()) {
-        
+
-    //Check to see if this bucket is allowed on this source. If this
-    //is a bucket move, we allow the source to be on the same host.
-    if (! PartitionedRegionBucketMgmtHelper.bucketIsAllowedOnThisHost(this, moveSource)) {
+    // Check to see if this bucket is allowed on this source. If this
+    // is a bucket move, we allow the source to be on the same host.
+    if (!PartitionedRegionBucketMgmtHelper.bucketIsAllowedOnThisHost(this, moveSource)) {
-        logger.debug("grabFreeBucket: Bucket can't be recovered because we're enforcing that the bucket host must be unique {}{}{}",
+        logger.debug(
+            "grabFreeBucket: Bucket can't be recovered because we're enforcing that the bucket host must be unique {}{}{}",
-    
+
-  public void initializePrimaryElector(
-      InternalDistributedMember creationRequestor) {
+  public void initializePrimaryElector(InternalDistributedMember creationRequestor) {
-    
-    if(persistenceAdvisor != null) {
+
+    if (persistenceAdvisor != null) {
-    if(persistenceAdvisor != null) {
+    if (persistenceAdvisor != null) {
-    
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66
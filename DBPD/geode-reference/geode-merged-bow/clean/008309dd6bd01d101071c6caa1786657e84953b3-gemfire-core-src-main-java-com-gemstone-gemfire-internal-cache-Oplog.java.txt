Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2010-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * one or more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
-import com.gemstone.gemfire.internal.InternalDataSerializer.Sendable;
+import com.gemstone.gemfire.internal.Sendable;
+import com.gemstone.gemfire.internal.cache.DiskEntry.Helper.Flushable;
+import com.gemstone.gemfire.internal.cache.DiskEntry.Helper.ValueWrapper;
+import com.gemstone.gemfire.internal.offheap.OffHeapHelper;
+import com.gemstone.gemfire.internal.offheap.ReferenceCountHelper;
+import com.gemstone.gemfire.internal.offheap.StoredObject;
+import com.gemstone.gemfire.internal.offheap.annotations.Released;
+import com.gemstone.gemfire.internal.offheap.annotations.Retained;
-public final class Oplog implements CompactableOplog {
+public final class Oplog implements CompactableOplog, Flushable {
+  final ByteBuffer[] bbArray = new ByteBuffer[2];
-  private void initOpState(byte opCode, DiskRegionView dr, DiskEntry entry, byte[] value, byte userBits, boolean notToUseUserBits)
-      throws IOException {
-    int len = value != null ? value.length : 0;
-    initOpState(opCode, dr, entry, value, len, userBits, notToUseUserBits);
-  }
-
-  private void initOpState(byte opCode, DiskRegionView dr, DiskEntry entry, byte[] value, int valueLength, byte userBits,
+  private void initOpState(byte opCode, DiskRegionView dr, DiskEntry entry, ValueWrapper value, byte userBits,
-    this.opState.initialize(opCode, dr, entry, value, valueLength, userBits, notToUseUserBits);
+    this.opState.initialize(opCode, dr, entry, value, userBits, notToUseUserBits);
-  private byte calcUserBits(byte[] value, boolean isSerializedObject) {
-    byte userBits = 0x0;
-
-    if (isSerializedObject) {
-      if (value == DiskEntry.INVALID_BYTES) {
-        // its the invalid token
-        userBits = EntryBits.setInvalid(userBits, true);
-      } else if (value == DiskEntry.LOCAL_INVALID_BYTES) {
-        // its the local-invalid token
-        userBits = EntryBits.setLocalInvalid(userBits, true);
-      } else if (value == DiskEntry.TOMBSTONE_BYTES) {
-        // its the tombstone token
-        userBits = EntryBits.setTombstone(userBits, true);
-      } else {
-        if (value == null) {
-          throw new IllegalStateException("userBits==1 and value is null");
-        } else if (value.length == 0) {
-          throw new IllegalStateException("userBits==1 and value is zero length");
-        }
-        userBits = EntryBits.setSerialized(userBits, true);
-      }
-    }
-    return userBits;
+  private byte calcUserBits(ValueWrapper vw) {
+    return vw.getUserBits();
-   * @param isSerializedObject
-   *          boolean indicating whether the byte array is a serialized value or
-   *          not Do the bytes in <code>value</code> contain a serialized object
-   *          (or an actually <code>byte</code> array)?
-  public final void create(LocalRegion region, DiskEntry entry, byte[] value, boolean isSerializedObject, boolean async) {
+  public final void create(LocalRegion region, DiskEntry entry, ValueWrapper value, boolean async) {
-      getOplogSet().getChild().create(region, entry, value, isSerializedObject, async);
+      getOplogSet().getChild().create(region, entry, value, async);
-        byte userBits = calcUserBits(value, isSerializedObject);
+        byte userBits = calcUserBits(value);
-  private void basicCreate(DiskRegion dr, DiskEntry entry, byte[] value, byte userBits, boolean async) throws IOException,
+  private void basicCreate(DiskRegion dr, DiskEntry entry, ValueWrapper value, byte userBits, boolean async) throws IOException,
-          id.setValueLength(value.length);
+          id.setValueLength(value.getLength());
-              abs(id.getKeyId()), entry.getKey(), startPosForSynchOp, userBits, (value != null ? value.length : 0),
-              baToString(value), dr.getId(), tag, getOplogId());
+              abs(id.getKeyId()), entry.getKey(), startPosForSynchOp, userBits, (value != null ? value.getLength() : 0),
+              value.getBytesAsString(), dr.getId(), tag, getOplogId());
+      this.krf.dos.flush();
+      this.krf.fos.getChannel().force(true);
+
-      throw new DiskAccessException("Fail to close krf file " + this.krf.f, e, getParent());
+      if (getParent().getDiskAccessException() == null) {
+        throw new DiskAccessException("Fail to close krf file " + this.krf.f, e, getParent());
+      } else {
+        logger.info("Fail to close krf file " + this.krf.f+", but a DiskAccessException happened ealier", getParent().getDiskAccessException());
+      }
-    Object value = entry._getValueUse(dr, true); // OFFHEAP for now copy into
-                                                 // heap CD; todo optimize by
-                                                 // keeping offheap for life of
-                                                 // wrapper
+    ReferenceCountHelper.skipRefCountTracking();
+    // TODO OFFHEAP: no need to retain. We just use it while we have the RegionEntry synced.
+    @Retained @Released Object value = entry._getValueRetain(dr, true);
+    ReferenceCountHelper.unskipRefCountTracking();
-        userBits = EntryBits.setSerialized(userBits, true);
-        proxy.fillSerializedValue(wrapper, userBits);
+        if (proxy instanceof StoredObject) {
+          @Released StoredObject ohproxy = (StoredObject) proxy;
+          try {
+            ohproxy.fillSerializedValue(wrapper, userBits);
+          } finally {
+            OffHeapHelper.releaseWithNoTracking(ohproxy);
+          }
+        } else {
+          userBits = EntryBits.setSerialized(userBits, true);
+          proxy.fillSerializedValue(wrapper, userBits);
+        }
-   * @param isSerializedObject
-   *          Do the bytes in <code>value</code> contain a serialized object (or
-   *          an actually <code>byte</code> array)?
-  public final void modify(LocalRegion region, DiskEntry entry, byte[] value, boolean isSerializedObject, boolean async) {
+  public final void modify(LocalRegion region, DiskEntry entry, ValueWrapper value, boolean async) {
-      getOplogSet().getChild().modify(region, entry, value, isSerializedObject, async);
+      getOplogSet().getChild().modify(region, entry, value, async);
-        byte userBits = calcUserBits(value, isSerializedObject);
+        byte userBits = calcUserBits(value);
-        int valueLen = value != null ? value.length : 0;
-        basicModify(region.getDiskRegion(), entry, value, valueLen, userBits, async, false);
+        basicModify(region.getDiskRegion(), entry, value, userBits, async, false);
-      byte userBits = calcUserBits(value, isSerializedObject);
+      ValueWrapper vw = new DiskEntry.Helper.ByteArrayValueWrapper(isSerializedObject, value);
+      byte userBits = calcUserBits(vw);
-      int valueLen = value != null ? value.length : 0;
-      basicModify(drv, entry, value, valueLen, userBits, false, false);
+      basicModify(drv, entry, vw, userBits, false, false);
-  private final void copyForwardModifyForCompact(DiskRegionView dr, DiskEntry entry, byte[] value, int valueLength, byte userBits) {
+  private final void copyForwardModifyForCompact(DiskRegionView dr, DiskEntry entry, BytesAndBitsForCompactor wrapper) {
-      getOplogSet().getChild().copyForwardModifyForCompact(dr, entry, value, valueLength, userBits);
+      getOplogSet().getChild().copyForwardModifyForCompact(dr, entry, wrapper);
+        // TODO: compaction needs to get version?
+        byte userBits = wrapper.getBits();
+        ValueWrapper vw;
+        if (wrapper.getDataChunk() != null) {
+          vw = new DiskEntry.Helper.ChunkValueWrapper(wrapper.getDataChunk());
+        } else {
+          vw = new DiskEntry.Helper.CompactorValueWrapper(wrapper.getBytes(), wrapper.getValidLength());
+        }
-        basicModify(dr, entry, value, valueLength, userBits, true, true);
+        basicModify(dr, entry, vw, userBits, true, true);
+        if (wrapper.getDataChunk() != null) {
+          wrapper.setChunkData(null, (byte) 0);
+        }
-  private void basicModify(DiskRegionView dr, DiskEntry entry, byte[] value, int valueLength, byte userBits, boolean async,
+  private void basicModify(DiskRegionView dr, DiskEntry entry, ValueWrapper value, byte userBits, boolean async,
-        initOpState(OPLOG_MOD_ENTRY_1ID, dr, entry, value, valueLength, userBits, false);
+        initOpState(OPLOG_MOD_ENTRY_1ID, dr, entry, value, userBits, false);
-              abs(id.getKeyId()), entry.getKey(), startPosForSynchOp, userBits, valueLength, baToString(value, valueLength),
+              abs(id.getKeyId()), entry.getKey(), startPosForSynchOp, userBits, value.getLength(), value.getBytesAsString(),
-            id.setValueLength(valueLength);
+            id.setValueLength(value.getLength());
-      getOplogSet().getChild().basicModify(dr, entry, value, valueLength, userBits, async, calledByCompactor);
+      getOplogSet().getChild().basicModify(dr, entry, value, userBits, async, calledByCompactor);
+  
+  @Override
+  public void flush() throws IOException {
+    flushAllNoSync(false);
+  }
+
+  @Override
+  public void flush(ByteBuffer b1, ByteBuffer b2) throws IOException {
+    if (b1 == this.drf.writeBuf) {
+      flush(this.drf, b1, b2);
+      flush(this.crf, false);
+    } else {
+      flush(this.drf, false);
+      flush(this.crf, b1, b2);
+    }
+  }
+  private final void flush(OplogFile olf, ByteBuffer b1, ByteBuffer b2) throws IOException {
+    try {
+      synchronized (this.lock/* olf */) {
+        if (olf.RAFClosed) {
+          return;
+        }
+        this.bbArray[0] = b1;
+        this.bbArray[1] = b2;
+        b1.flip();
+        long flushed = olf.channel.write(this.bbArray);
+        this.bbArray[0] = null;
+        this.bbArray[1] = null;
+        // update bytesFlushed after entire writeBuffer is flushed to fix bug 41201
+        olf.bytesFlushed += flushed;
+        b1.clear();
+      }
+    } catch (ClosedChannelException ignore) {
+      // It is possible for a channel to be closed when our code does not
+      // explicitly call channel.close (when we will set RAFclosed).
+      // This can happen when a thread is doing an io op and is interrupted.
+      // That thread will see ClosedByInterruptException but it will also
+      // close the channel and then we will see ClosedChannelException.
+    }
+  }
+  
-                  byte[] valueBytes = wrapper.getBytes();
-                  int length = wrapper.getValidLength();
-                  byte userBits = wrapper.getBits();
-                  // TODO: compaction needs to get version?
-                    // @todo: Is this even possible? Perhaps I should just
-                    // assert here
+                    // @todo: Is this even possible? Perhaps I should just assert here
+                    } else if (wrapper.getDataChunk() != null) {
+                      wrapper.setChunkData(null, (byte) 0);
-                  getOplogSet().getChild().copyForwardModifyForCompact(dr, de, valueBytes, length, userBits);
-                  // the did's oplogId will now be set to the current active
-                  // oplog
+                  getOplogSet().getChild().copyForwardModifyForCompact(dr, de, wrapper);
+                  // the did's oplogId will now be set to the current active oplog
-    private byte[] value;
-    private int valueLength;
+    private ValueWrapper value;
-      sb.append(" opcode=").append(this.opCode).append(" len=").append(this.valueLength).append(" vb=").append(
-          baToString(this.value, this.valueLength));
+      sb.append(" opcode=").append(this.opCode).append(" len=").append(this.value.getLength()).append(" vb=").append(this.value.getBytesAsString());
+    
+    private final void write(OplogFile olf, ValueWrapper vw) throws IOException {
+      vw.sendTo(olf.writeBuf, Oplog.this);
+    }
-      this.value = rvvBytes;
+      this.value = new DiskEntry.Helper.ByteArrayValueWrapper(true, rvvBytes);
-      this.valueLength = rvvBytes.length;
-      this.value = valueBytes;
-      this.valueLength = this.value.length;
-      if (this.userBits == 1 && this.valueLength == 0) {
+      this.value = new DiskEntry.Helper.CompactorValueWrapper(valueBytes, valueBytes.length);
+      if (this.userBits == 1 && this.value.getLength() == 0) {
-        this.size += 4 + this.valueLength;
+        this.size += 4 + this.value.getLength();
-    public void initialize(byte opCode, DiskRegionView dr, DiskEntry entry, byte[] value, int valueLength, byte userBits,
+    public void initialize(byte opCode, DiskRegionView dr, DiskEntry entry, ValueWrapper value, byte userBits,
-      this.valueLength = valueLength;
-      if (this.userBits == 1 && this.valueLength == 0) {
+      if (this.userBits == 1 && this.value.getLength() == 0) {
-        this.size += 4 + this.valueLength;
+        this.size += 4 + this.value.getLength();
-        write(olf, this.value, this.valueLength);
-        bytesWritten += this.valueLength;
+        write(olf, this.value);
+        bytesWritten += this.value.getLength();
-          writeInt(olf, this.valueLength);
+          int len = this.value.getLength();
+          writeInt(olf, len);
-          if (this.valueLength > 0) {
-            write(olf, this.value, this.valueLength);
-            bytesWritten += this.valueLength;
+          if (len > 0) {
+            write(olf, this.value);
+            bytesWritten += len;
-    public Object _getValueUse(RegionEntryContext context, boolean decompress) {
+    public void handleValueOverflow(RegionEntryContext context) {throw new IllegalStateException();}
+
+    @Override
+    public void afterValueOverflow(RegionEntryContext context) {throw new IllegalStateException();}
+    @Override
+    public Object prepareValueForCache(RegionEntryContext r, Object val, boolean isEntryUpdate) { throw new IllegalStateException("Should never be called");  }
+
+    @Override
+    public Object _getValueRetain(RegionEntryContext context, boolean decompress) {
+    @Override
+    public Object getValueRetain(RegionEntryContext context) {
+      return null;
+    }
+
+    @Override
-
+    @Override
+    public boolean isMarkedForEviction() {
+      // TODO Auto-generated method stub
+      return false;
+    }
+    @Override
+    public void setMarkedForEviction() {
+      // TODO Auto-generated method stub
+    }
+    @Override
+    public void clearMarkedForEviction() {
+      // TODO Auto-generated method stub
+    }
+
+    @Override
+    public Object prepareValueForCache(RegionEntryContext r, Object val,
+        EntryEventImpl event, boolean isEntryUpdate) {
+      throw new IllegalStateException("Should never be called");
+    }
+    

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV31 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS43 INS23 INS31 INS31 INS31 INS42 INS83 INS5 INS59 MOV83 INS39 INS42 MOV44 INS8 INS78 INS83 INS39 INS42 INS43 INS8 INS78 INS83 INS39 INS42 MOV44 MOV44 INS43 MOV8 INS83 UPD39 UPD42 INS44 MOV43 INS8 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS43 INS85 INS42 INS3 INS43 UPD43 UPD42 INS41 INS43 INS43 INS21 INS21 INS43 INS43 INS42 INS43 INS42 UPD42 MOV42 INS21 INS42 INS43 INS42 INS43 INS42 INS42 INS25 INS43 INS42 INS43 INS42 INS43 INS42 INS54 INS43 INS83 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS43 INS42 INS44 INS44 INS44 MOV8 UPD42 INS78 INS78 INS83 INS43 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS43 INS42 INS44 INS44 INS44 INS44 MOV8 INS42 INS5 INS34 INS42 UPD42 INS32 INS42 INS42 INS32 INS78 INS78 INS43 INS32 INS42 MOV60 INS42 INS42 INS32 INS42 INS42 INS27 INS8 INS8 INS42 INS42 INS42 INS8 INS12 INS42 INS43 INS42 INS43 INS42 INS42 INS21 INS25 INS43 MOV25 INS42 INS43 INS42 INS53 INS42 INS43 INS42 INS53 INS42 INS42 INS43 INS42 MOV43 INS42 INS39 INS42 INS42 INS42 INS42 INS43 INS42 INS41 INS42 INS41 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS43 INS85 MOV22 INS42 INS42 INS42 INS21 INS21 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS22 INS21 INS21 INS21 INS21 INS51 INS44 INS8 INS42 INS42 INS32 INS27 MOV8 INS42 INS42 INS14 INS42 INS14 INS42 INS42 INS33 INS9 INS42 INS42 INS42 INS42 INS52 INS42 INS32 INS32 INS25 UPD42 INS43 UPD39 INS22 INS42 INS32 INS32 INS32 INS32 INS22 INS8 INS43 INS42 INS42 INS42 INS40 INS52 MOV22 INS14 INS14 MOV27 INS27 INS43 INS43 UPD45 UPD45 INS22 INS42 INS32 INS42 INS9 INS27 MOV8 INS8 INS42 UPD42 INS14 UPD42 INS32 UPD42 UPD42 MOV60 INS60 INS25 INS25 MOV52 UPD42 MOV42 UPD42 MOV42 INS22 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS22 INS9 UPD42 MOV42 INS22 INS9 INS42 INS22 INS42 INS42 INS52 INS42 INS25 MOV21 MOV21 INS21 INS60 MOV21 INS21 INS21 INS21 INS42 INS42 INS42 MOV52 MOV42 INS43 INS9 INS42 INS43 INS42 INS40 INS32 INS34 INS32 INS42 INS42 INS22 INS42 INS22 INS42 INS32 INS33 INS21 INS43 INS42 INS42 INS42 INS42 INS43 INS59 INS27 INS8 INS8 INS27 INS8 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS40 INS8 INS32 INS39 INS59 INS7 INS7 INS32 INS32 INS40 INS40 INS22 INS42 INS22 INS42 INS8 INS52 INS42 INS22 INS42 INS32 INS42 INS32 INS8 INS40 INS42 INS42 INS32 INS33 INS21 INS21 UPD42 INS32 INS33 INS21 INS41 INS2 INS42 INS2 INS42 INS42 INS42 INS42 INS32 INS2 INS33 INS2 INS33 INS40 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV22 INS42 MOV52 MOV42 INS32 MOV52 UPD42 MOV42 INS32 MOV21 INS21 INS52 INS42 INS42 INS42 INS42 INS27 INS32 MOV60 INS25 INS42 INS42 INS7 INS7 INS42 INS42 INS32 INS22 INS34 INS22 INS34 INS40 INS42 INS22 INS22 INS34 INS22 INS34 UPD42 INS22 INS42 INS22 INS42 INS7 INS45 INS22 INS45 INS32 INS42 INS62 INS8 MOV8 INS42 INS14 INS42 INS14 INS42 INS42 INS33 INS11 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 MOV52 UPD42 MOV42 MOV52 UPD42 MOV42 INS42 INS32 INS32 INS22 INS42 INS42 INS42 INS43 INS60 INS54 INS43 INS32 INS43 MOV32 MOV32 INS39 INS34 INS22 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS78 INS43 INS59 INS8 INS8 INS40 INS42 INS42 INS40 INS32 INS32 INS32 INS52 INS42 INS60 INS32 INS42 INS42 INS42 INS11 INS21 INS21 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS39 INS59 MOV8 INS42 INS42 INS43 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS52 INS42 INS42 UPD42 INS25 INS27 INS8 INS32 INS33 INS21 INS42 INS42 INS32 INS42 INS42 INS33 INS11 INS39 INS34 DEL39 DEL85 DEL5 DEL39 DEL42 DEL42 DEL33 DEL27 DEL40 DEL34 DEL16 DEL59 DEL60 DEL42 DEL42 DEL39 DEL42 DEL39 DEL42 DEL44 DEL43 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL42 DEL44 DEL31 DEL42 DEL66 DEL66 DEL66 DEL65 DEL39 DEL85 DEL5 DEL39 DEL42 DEL44 DEL42 DEL42 DEL39 DEL85 DEL5 DEL40 DEL40 DEL42 DEL42 DEL66 DEL66 DEL65 DEL39 DEL85 DEL5 DEL39 DEL42 DEL44 DEL42 DEL42 DEL39 DEL42 DEL42 DEL33 DEL27 DEL40 DEL34 DEL16 DEL59 DEL60 DEL42 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL40 DEL34 DEL16 DEL42 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL42 DEL42 DEL42 DEL39 DEL85 DEL5 DEL39 DEL42 DEL44 DEL42 DEL32 DEL42 DEL39 DEL42 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL39 DEL85 DEL5 DEL42 DEL39 DEL42 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL42 DEL40 DEL27 DEL8 DEL42 DEL40 DEL27 DEL8 DEL42 DEL40 DEL27 DEL8 DEL42 DEL33 DEL27 DEL40 DEL34 DEL27 DEL25 DEL25 DEL42 DEL9 DEL32 DEL7 DEL21 DEL8 DEL25 DEL25 DEL25 DEL8 DEL25 DEL42 DEL41 DEL8 DEL39 DEL85 DEL5 DEL42 DEL59 DEL60 DEL39 DEL42 DEL59 DEL60 DEL42 DEL42 DEL39 DEL85 DEL5 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL40 DEL7 DEL21 DEL42 DEL22 DEL42 DEL22 DEL7 DEL21 DEL22 DEL39 DEL85 DEL5 DEL39 DEL42 DEL44 DEL22 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL34 DEL27 DEL27 DEL25 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL7 DEL21 DEL8
Merge branch 'release/1.8.0'

+import java.util.concurrent.TimeUnit;
+import org.apache.geode.distributed.ConfigurationProperties;
+ * <p>
+ * There's only one dedicated thread that wakes up at the
+ * {@link ConfigurationProperties#STATISTIC_SAMPLE_RATE} configured, samples all the statistics,
+ * writes them to the {@link ConfigurationProperties#STATISTIC_ARCHIVE_FILE} configured (if any) and
+ * notifies listeners of changes. The mutable fields are declared as {@code volatile} to make sure
+ * readers of the statistics get the latest recorded value.
+ * <p>
+ * This class is conditionally thread-safe, there can be multiple concurrent readers accessing a
+ * instance, but concurrent writers need to be synchronized externally.
- *
+ * @see org.apache.geode.internal.statistics.HostStatSampler
+ * @see org.apache.geode.distributed.ConfigurationProperties
+ * @see org.apache.geode.management.internal.beans.stats.MBeanStatsMonitor
-
-  private static final int VALUE_NOT_AVAILABLE = -1;
-
-  private volatile float cpuUsage = 0;
-
-  private static String processCPUTimeAttr = "ProcessCpuTime";
-
+  static final int VALUE_NOT_AVAILABLE = -1;
+  private static final String PROCESS_CPU_TIME_ATTRIBUTE = "ProcessCpuTime";
-
+  private volatile float cpuUsage = 0;
+  private final boolean processCPUTimeAvailable;
-  private boolean processCPUTimeAvailable;
+  public float getCpuUsage() {
+    return cpuUsage;
+  }
+
+  long getLastSystemTime() {
+    return lastSystemTime;
+  }
+
+  long getLastProcessCpuTime() {
+    return lastProcessCpuTime;
+  }
-    processCPUTimeAvailable = MBeanJMXAdapter.isAttributeAvailable(processCPUTimeAttr,
+    processCPUTimeAvailable = MBeanJMXAdapter.isAttributeAvailable(PROCESS_CPU_TIME_ATTRIBUTE,
-
-
-  @Override
-  public void handleNotification(StatisticsNotification notification) {
-
-    for (StatisticId statId : notification) {
-      StatisticDescriptor descriptor = statId.getStatisticDescriptor();
-      String name = descriptor.getName();
-      Number value;
-      try {
-        value = notification.getValue(statId);
-      } catch (StatisticNotFoundException e) {
-        value = 0;
-      }
-      log(name, value);
-      statsMap.put(name, value);
-    }
-    refreshStats();
+  long currentTimeMillis() {
+    return TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
+  /**
+   *
+   * @param systemTime Current system time.
+   * @param cpuTime Last gathered cpu time.
+   * @return The time (as a percentage) that this member's process time with respect to Statistics
+   *         sample time interval. If process time between two sample time t1 & t2 is p1 and p2
+   *         cpuUsage = ((p2-p1) * 100) / ((t2-t1).
+   */
+  float calculateCpuUsage(long systemTime, long cpuTime) {
+    // 10000 = (Nano conversion factor / 100 for percentage)
+    long denom = (systemTime - getLastSystemTime()) * 10000;
+    return (float) (cpuTime - getLastProcessCpuTime()) / denom;
+  }
-   *
-   * Returns the time (as a percentage) that this member's process time with respect to Statistics
-   * sample time interval. If process time between two sample time t1 & t2 is p1 and p2 cpuUsage =
-   * ((p2-p1) * 100) / ((t2-t1)
-   *
-  private void refreshStats() {
-
+  synchronized void refreshStats() {
-      Number processCpuTime = statsMap.get(StatsKey.VM_PROCESS_CPU_TIME);
+      Number processCpuTime = statsMap.getOrDefault(StatsKey.VM_PROCESS_CPU_TIME, 0);
-
-        lastSystemTime = System.currentTimeMillis();
+        lastSystemTime = currentTimeMillis();
-      long systemTime = System.currentTimeMillis();
-      // 10000 = (Nano conversion factor / 100 for percentage)
-      long denom = (systemTime - lastSystemTime) * 10000;
-
-      float processCpuUsage = (float) (cpuTime - lastProcessCpuTime) / denom;
-
+      long systemTime = currentTimeMillis();
+      cpuUsage = calculateCpuUsage(systemTime, cpuTime);
-      cpuUsage = processCpuUsage;
+    }
+  }
+
+  @Override
+  public void handleNotification(StatisticsNotification notification) {
+    for (StatisticId statId : notification) {
+      StatisticDescriptor descriptor = statId.getStatisticDescriptor();
+      String name = descriptor.getName();
+      Number value;
+
+      try {
+        value = notification.getValue(statId);
+      } catch (StatisticNotFoundException e) {
+        value = 0;
+      }
+
+      log(name, value);
+      statsMap.put(name, value);
+    refreshStats();
-
-  public float getCpuUsage() {
-    return cpuUsage;
-  }
-

INS26 INS26 MOV23 MOV31 MOV31 INS40 INS40 INS31 INS31 INS31 INS31 INS65 INS65 INS65 INS83 INS83 INS39 INS42 INS8 INS39 INS42 INS8 INS39 INS42 INS8 INS29 INS39 INS42 INS44 INS44 INS8 UPD83 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS40 INS40 INS40 UPD42 INS41 INS41 INS41 INS65 INS65 INS65 INS39 INS42 INS39 INS42 INS60 INS41 INS67 INS67 INS66 INS42 INS42 INS32 INS42 INS66 INS42 INS66 INS66 INS66 INS66 INS39 INS59 INS27 MOV21 INS42 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS27 INS11 INS42 UPD42 INS42 INS42 INS36 INS34 INS39 INS36 INS27 INS27 INS32 INS42 INS32 INS42 INS32 UPD42 INS34 INS42 INS42 INS42 INS42 INS42 DEL83 DEL66 DEL66 DEL66 DEL42 DEL42 DEL42 DEL39 DEL42 DEL42 DEL42 DEL27 DEL36 DEL34 DEL27 DEL59 DEL60 DEL39 DEL42 DEL39 DEL42 DEL42 DEL27 DEL36 DEL11 DEL42 DEL27 DEL59 DEL60
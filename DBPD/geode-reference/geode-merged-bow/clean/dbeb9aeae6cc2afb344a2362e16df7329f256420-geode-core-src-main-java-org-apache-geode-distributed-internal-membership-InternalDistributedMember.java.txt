Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import org.apache.geode.GemFireConfigException;
+import org.apache.geode.distributed.internal.ServerLocation;
- * This is the fundamental representation of a member of a GemFire distributed
- * system.
+ * This is the fundamental representation of a member of a GemFire distributed system.
-public class InternalDistributedMember
- implements DistributedMember,
-    Externalizable, DataSerializableFixedID, ProfileId,
-    VersionSource<DistributedMember>
-{
+public class InternalDistributedMember implements DistributedMember, Externalizable,
+    DataSerializableFixedID, ProfileId, VersionSource<DistributedMember> {
-  
+
-  private final boolean SHOW_NETMEMBER = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "show_netmembers");
-  
+  private final boolean SHOW_NETMEMBER =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "show_netmembers");
+
-   * This is the direct channel port. The underlying NetMember must be able to
-   * serialize and deliver this value.
-   */
-  private int dcPort = -1;
-
-  /**
-   * This is the process id of this member on its machine. The underlying
-   * NetMember must be able to serialize and deliver this value.
-   */
-  private int vmPid = -1;
-
-  /**
-   * This is a representation of the type of VM. The underlying NetMember must
-   * be able to serialize and deliver this value.
-   */
-  private int vmKind = DistributionManager.NORMAL_DM_TYPE;
-  
-  /**
-   * This is the view identifier where this ID was born, or zero if this is
-   * a loner member
-   */
-  private int vmViewId = -1;
-  
-  /**
-   * whether this is a partial member ID (without roles, durable attributes).
-   * We use partial IDs in EventID objects to reduce their size.  It would be
-   * better to use canonical IDs but there is currently no central mechanism
-   * that would allow that for both server and client identifiers
+   * whether this is a partial member ID (without roles, durable attributes). We use partial IDs in
+   * EventID objects to reduce their size. It would be better to use canonical IDs but there is
+   * currently no central mechanism that would allow that for both server and client identifiers
-  /** Internal list of group/role names for this member. */
-  private String[] groups;
-
-   * The roles, if any, of this member. Lazily created first time getRoles()
-   * is called.
+   * The roles, if any, of this member. Lazily created first time getRoles() is called.
-   * The name of this member's distributed system connection.
-   * @see org.apache.geode.distributed.DistributedSystem#getName
-   */
-  private String name = null;
-
-  /**
-   * Unique tag (such as randomly generated bytes) to help enforce uniqueness.
-   * Note: this should be displayable.
+   * Unique tag (such as randomly generated bytes) to help enforce uniqueness. Note: this should be
+   * displayable.
-  private transient short version = Version.CURRENT_ORDINAL;
-  /**
-   * User-defined attributes (id and timeout) used by durable clients.
-   */
-  private DurableClientAttributes durableClientAttributes = null;
-
-  private static final Version[] dsfidVersions = new Version[] {
-        Version.GFE_71, Version.GFE_90 };
+  private static final Version[] dsfidVersions = new Version[] {Version.GFE_71, Version.GFE_90};
-    this.vmPid = OSProcess.getId();
+    netMbr.setProcessId(OSProcess.getId());
-      }
-      else {
+      } else {
-    }
-    catch(UnknownHostException ee){
+    } catch (UnknownHostException ee) {
-    synchPayload();
-  public InternalDistributedMember() {
-    this.groups = new String[0];
-  }
+  public InternalDistributedMember() {}
-   * Construct a InternalDistributedMember.  All fields are specified.<p>
+   * Construct a InternalDistributedMember. All fields are specified.
+   * <p>
-   * This, and the following constructor are the only valid ways to create an ID
-   * for a distributed member for use
-   * in the P2P cache.  Use of other constructors can break network-partition-detection.
+   * This, and the following constructor are the only valid ways to create an ID for a distributed
+   * member for use in the P2P cache. Use of other constructors can break
+   * network-partition-detection.
-   * @param p
-   *        the membership port
+   * @param p the membership port
-   * @param attr
-   *        the member's attributes
+   * @param attr the member's attributes
-  public InternalDistributedMember(InetAddress i, int p, 
-      boolean splitBrainEnabled, boolean canBeCoordinator, MemberAttributes attr) {
-    this.dcPort = attr.getPort();
-    this.vmPid = attr.getVmPid();
-    this.vmKind = attr.getVmKind();
-    this.vmViewId = attr.getVmViewId();
-    this.name = attr.getName();
-    this.groups = attr.getGroups();
-    this.durableClientAttributes = attr.getDurableClientAttributes();
-    this.netMbr = MemberFactory.newNetMember(i, p, splitBrainEnabled, canBeCoordinator, Version.CURRENT_ORDINAL, attr);
-    this.hostName = SocketCreator.resolve_dns? SocketCreator.getHostName(i) : i.getHostAddress();
-    this.version = netMbr.getVersionOrdinal();
+  public InternalDistributedMember(InetAddress i, int p, boolean splitBrainEnabled,
+      boolean canBeCoordinator, MemberAttributes attr) {
+
+    this.netMbr = MemberFactory.newNetMember(i, p, splitBrainEnabled, canBeCoordinator,
+        Version.CURRENT_ORDINAL, attr);
+
+    this.hostName = SocketCreator.resolve_dns ? SocketCreator.getHostName(i) : i.getHostAddress();
+
+    short version = netMbr.getVersionOrdinal();
-//    checkHostName();
+    // checkHostName();
-  
+
-   * Construct a InternalDistributedMember based on the given NetMember.<p>
-   * This is not the preferred way of creating an instance since the NetMember
-   * may not have all required information (e.g., a JGroups address without
-   * direct-port and other information).
+   * Construct a InternalDistributedMember based on the given NetMember.
+   * <p>
+   * This is not the preferred way of creating an instance since the NetMember may not have all
+   * required information (e.g., a JGroups address without direct-port and other information).
+   * 
-    MemberAttributes attr = m.getAttributes();
-    this.hostName = SocketCreator.resolve_dns? SocketCreator.getHostName(m.getInetAddress()) :
-      m.getInetAddress().getHostAddress();
-//    checkHostName();
-    if (attr == null) {
-      // no extended information available, so this address is crippled
-    }
-    else {
-      this.dcPort = attr.getPort();
-      this.vmPid = attr.getVmPid();
-      this.vmKind = attr.getVmKind();
-      this.vmViewId = attr.getVmViewId();
-      this.name = attr.getName();
-      this.groups = attr.getGroups();
-      this.durableClientAttributes = attr.getDurableClientAttributes();
-    }
-    this.version = m.getVersionOrdinal();
+    this.hostName = SocketCreator.resolve_dns ? SocketCreator.getHostName(m.getInetAddress())
+        : m.getInetAddress().getHostAddress();
+    // checkHostName();
+
+    short version = m.getVersionOrdinal();
-  //  private void checkHostName() {
-//    // bug #44858: debug method to find who is putting a host name instead of addr into an ID
-//    if (!SocketCreator.resolve_dns
-//        && this.hostName != null && this.hostName.length() > 0
-//        && !Character.isDigit(this.hostName.charAt(0))) {
-//      throw new RuntimeException("found hostname that doesn't start with a digit: " + this.hostName);
-//    }
-//  }
+  // private void checkHostName() {
+  // // bug #44858: debug method to find who is putting a host name instead of addr into an ID
+  // if (!SocketCreator.resolve_dns
+  // && this.hostName != null && this.hostName.length() > 0
+  // && !Character.isDigit(this.hostName.charAt(0))) {
+  // throw new RuntimeException("found hostname that doesn't start with a digit: " + this.hostName);
+  // }
+  // }
-   * string).<p>
+   * string).
+   * <p>
-   * <b>
-   * [bruce]THIS METHOD IS FOR TESTING ONLY.  DO NOT USE IT TO CREATE IDs FOR
-   * USE IN THE PRODUCT.  IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED
-   * FOR P2P FUNCTIONALITY.
-   * </b>
+   * <b> [bruce]THIS METHOD IS FOR TESTING ONLY. DO NOT USE IT TO CREATE IDs FOR USE IN THE PRODUCT.
+   * IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED FOR P2P FUNCTIONALITY. </b>
-   * @param i
-   *          the hostname, must be for the current host
-   * @param p
-   *          the membership listening port
+   * @param i the hostname, must be for the current host
+   * @param p the membership listening port
-  public InternalDistributedMember(String i, int p) throws UnknownHostException {
+  public InternalDistributedMember(String i, int p) {
-  
+
-   * Create a InternalDistributedMember referring to the current host (as defined by the given
-   * string).<p>
-   *
-   * <b>
-   * [bruce]THIS METHOD IS FOR TESTING ONLY.  DO NOT USE IT TO CREATE IDs FOR
-   * USE IN THE PRODUCT.  IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED
-   * FOR P2P FUNCTIONALITY.
-   * </b>
-   *
+   * Creates a new InternalDistributedMember for use in notifying membership listeners. The version
+   * information in the ID is set to Version.CURRENT.
-   * @param i
-   *          the hostname, must be for the current host
-   * @param p
-   *          the membership listening port
-   * @param version
-   *          the version of this member
-   * @throws UnknownHostException if the given hostname cannot be resolved
+   * @param location the coordinates of the server
-  public InternalDistributedMember(String i, int p, Version version) throws UnknownHostException {
-    this (i, p, version, MemberFactory.newNetMember(i, p));
-  }
-  
-  /**
-   * Create a InternalDistributedMember referring to the current host (as defined by the given
-   * string).<p>
-   *
-   * <b>
-   * THIS METHOD IS FOR TESTING ONLY.  DO NOT USE IT TO CREATE IDs FOR
-   * USE IN THE PRODUCT.  IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED
-   * FOR P2P FUNCTIONALITY.
-   * </b>
-   **/
-  public InternalDistributedMember(String i, int p, Version version, NetMember netMember) throws UnknownHostException {
-    netMbr = netMember;
-    defaultToCurrentHost();
-    this.vmKind = DistributionManager.NORMAL_DM_TYPE;
-    this.versionObj = version;
+
+  public InternalDistributedMember(ServerLocation location) {
+    this.hostName = location.getHostName();
+    InetAddress addr = null;
+    try {
+      addr = InetAddress.getByName(this.hostName);
+    } catch (UnknownHostException e) {
+      throw new GemFireConfigException("Unable to resolve server location " + location, e);
+    }
+    netMbr = MemberFactory.newNetMember(addr, location.getPort());
+    netMbr.setVmKind(DistributionManager.NORMAL_DM_TYPE);
+    versionObj = Version.CURRENT;
+    netMbr.setVersion(versionObj);
-   * Create a InternalDistributedMember referring to the current host
-   * (as defined by the given string) with additional info including optional
-   * connection name and an optional unique string. Currently these two
-   * optional fields (and this constructor) are only used by the
-   * LonerDistributionManager.<p>
+   * Create a InternalDistributedMember referring to the current host (as defined by the given
+   * string).
+   * <p>
-   * < b>
-   * [bruce]DO NOT USE THIS METHOD TO CREATE ANYTHING OTHER THAN A LONER ID
-   * WITHOUT TALKING TO ME FIRST.  IT DOES NOT PROPERLY INITIALIZE THE ID.
-   * </b>
+   * <b> [bruce]THIS METHOD IS FOR TESTING ONLY. DO NOT USE IT TO CREATE IDs FOR USE IN THE PRODUCT.
+   * IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED FOR P2P FUNCTIONALITY. </b>
-   * @param host
-   *          the hostname, must be for the current host
-   * @param p
-   *          the membership listening port
-   * @param n
-   *          gemfire properties connection name
-   * @param u
-   *          unique string used make the member more unique
+   * 
+   * @param i the hostname, must be for the current host
+   * @param p the membership listening port
+   * @param version the version of this member
+   * @throws UnknownHostException if the given hostname cannot be resolved
+   */
+  public InternalDistributedMember(String i, int p, Version version) {
+    this(i, p, version, MemberFactory.newNetMember(i, p));
+  }
+
+  /**
+   * Create a InternalDistributedMember referring to the current host (as defined by the given
+   * string).
+   * <p>
+   *
+   * <b> THIS METHOD IS FOR TESTING ONLY. DO NOT USE IT TO CREATE IDs FOR USE IN THE PRODUCT. IT
+   * DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED FOR P2P FUNCTIONALITY. </b>
+   **/
+  public InternalDistributedMember(String i, int p, Version version, NetMember netMember) {
+    netMbr = netMember;
+    defaultToCurrentHost();
+    netMember.setVmKind(DistributionManager.NORMAL_DM_TYPE);
+    this.versionObj = version;
+    netMember.setVersion(version);
+  }
+
+  /**
+   * Create a InternalDistributedMember referring to the current host (as defined by the given
+   * string) with additional info including optional connection name and an optional unique string.
+   * Currently these two optional fields (and this constructor) are only used by the
+   * LonerDistributionManager.
+   * <p>
+   *
+   * < b> [bruce]DO NOT USE THIS METHOD TO CREATE ANYTHING OTHER THAN A LONER ID WITHOUT TALKING TO
+   * ME FIRST. IT DOES NOT PROPERLY INITIALIZE THE ID. </b>
+   *
+   * @param host the hostname, must be for the current host
+   * @param p the membership listening port
+   * @param n gemfire properties connection name
+   * @param u unique string used make the member more unique
-  public InternalDistributedMember(String host, int p, String n, String u,
-      int vmKind, String[] groups, DurableClientAttributes attr) throws UnknownHostException {
-    MemberAttributes mattr = new MemberAttributes(p,
-        org.apache.geode.internal.OSProcess.getId(),
-        vmKind, -1,
-        n,
-        groups, attr);
+  public InternalDistributedMember(String host, int p, String n, String u, int vmKind,
+      String[] groups, DurableClientAttributes attr) throws UnknownHostException {
+    MemberAttributes mattr = new MemberAttributes(p, org.apache.geode.internal.OSProcess.getId(),
+        vmKind, -1, n, groups, attr);
-    this.name = n;
+    netMbr.setName(n);
-    this.vmKind = vmKind;
-    this.dcPort = p;
-    this.durableClientAttributes = attr;
+    netMbr.setVmKind(vmKind);
+    netMbr.setDirectPort(p);
+    netMbr.setDurableClientAttributes(attr);
-    this.vmPid = OSProcess.getId();
-    this.groups = groups;
+    netMbr.setGroups(groups);
-   * Create a InternalDistributedMember  referring to the current host (as defined by the given
-   * address).<p>
+   * Create a InternalDistributedMember referring to the current host (as defined by the given
+   * address).
+   * <p>
-   * <b>
-   * [bruce]THIS METHOD IS FOR TESTING ONLY.  DO NOT USE IT TO CREATE IDs FOR
-   * USE IN THE PRODUCT.  IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED
-   * FOR P2P FUNCTIONALITY.
-   * </b>
+   * <b> [bruce]THIS METHOD IS FOR TESTING ONLY. DO NOT USE IT TO CREATE IDs FOR USE IN THE PRODUCT.
+   * IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED FOR P2P FUNCTIONALITY. </b>
-   * @param i
-   *          the hostname, must be for the current host
-   * @param p
-   *          the membership listening port
+   * @param i the hostname, must be for the current host
+   * @param p the membership listening port
-   * <b>
-   * [bruce]THIS METHOD IS FOR TESTING ONLY.  DO NOT USE IT TO CREATE IDs FOR
-   * USE IN THE PRODUCT.  IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED
-   * FOR P2P FUNCTIONALITY.
-   * </b>
+   * <b> [bruce]THIS METHOD IS FOR TESTING ONLY. DO NOT USE IT TO CREATE IDs FOR USE IN THE PRODUCT.
+   * IT DOES NOT PROPERLY INITIALIZE ATTRIBUTES NEEDED FOR P2P FUNCTIONALITY. </b>
-   * @param addr 
-   *        address of the server
-   * @param p
-   *        the listening port of the server
-   * @param isCurrentHost
-   *        true if the given host refers to the current host (bridge and
-   *        gateway use false to create a temporary id for the OTHER side of a
-   *        connection)
+   * @param addr address of the server
+   * @param p the listening port of the server
+   * @param isCurrentHost true if the given host refers to the current host (bridge and gateway use
+   *        false to create a temporary id for the OTHER side of a connection)
-  public InternalDistributedMember(InetAddress addr,
-                                   int p,
-                                   boolean isCurrentHost) {
+  public InternalDistributedMember(InetAddress addr, int p, boolean isCurrentHost) {
-  public InetAddress getInetAddress()
-  {
+  public InetAddress getInetAddress() {
+   * 
-  public int getPort()
-  {
+  public int getPort() {
-  public int getDirectChannelPort()
-  {
+  public int getDirectChannelPort() {
-    return dcPort;
+    return netMbr.getDirectPort();
-   * [GemStone] Returns the kind of VM that hosts the distribution manager with
-   * this address.
+   * [GemStone] Returns the kind of VM that hosts the distribution manager with this address.
-  public int getVmKind()
-  {
-    return vmKind;
+  public int getVmKind() {
+    return netMbr.getVmKind();
-  
+
-   * Returns the membership view ID that this member was born in. For
-   * backward compatibility reasons this is limited to 16 bits.
+   * Returns the membership view ID that this member was born in. For backward compatibility reasons
+   * this is limited to 16 bits.
-    return this.vmViewId;
+    return netMbr.getVmViewId();
-        final String[] tmpRoles = this.groups;
+        final String[] tmpRoles = netMbr.getGroups();
-        if (tmpRoles == null  ||  tmpRoles.length == 0) {
+        if (tmpRoles == null || tmpRoles.length == 0) {
-        }
-        else {
+        } else {
+
-    return Collections.unmodifiableList(Arrays.asList(this.groups));
+    return Collections.unmodifiableList(Arrays.asList(netMbr.getGroups()));
-      this.groups = newGroups;
-      synchPayload();
+      netMbr.setGroups(newGroups);
-  private void synchPayload() {
-    netMbr.setAttributes(new MemberAttributes(dcPort, vmPid, vmKind, 
-        vmViewId, name, groups, durableClientAttributes));
-  }
-
-  public void setVmKind(int p)
-  {
-    vmKind = p;
-    synchPayload();
+  public void setVmKind(int p) {
+    netMbr.setVmKind(p);
-  
+
-    this.vmViewId = p;
-    synchPayload();
+    netMbr.setVmViewId(p);
-   * [GemStone] Returns the process id of the VM that hosts the distribution
-   * manager with this address.
+   * [GemStone] Returns the process id of the VM that hosts the distribution manager with this
+   * address.
-  public int getVmPid()
-  {
-    return vmPid;
+  public int getVmPid() {
+    return netMbr.getProcessId();
-   * [GemStone] Sets the process id of the VM that hosts the distribution
-   * manager with this address.
+   * [GemStone] Sets the process id of the VM that hosts the distribution manager with this address.
-  public void setVmPid(int p)
-  {
-    this.vmPid = p;
-    synchPayload();
+  public void setVmPid(int p) {
+    netMbr.setProcessId(p);
-   * Returns the name of this member's distributed system connection or null
-   * if no name was specified.
+   * Returns the name of this member's distributed system connection or null if no name was
+   * specified.
+   * 
-    String result = this.name;
+    String result = netMbr.getName();
-   * Returns this member's unique tag (such as randomly generated bytes) or
-   * null if no unique tag was created.
+   * Returns this member's unique tag (such as randomly generated bytes) or null if no unique tag
+   * was created.
-   * Returns this client member's durable attributes or null if no durable
-   * attributes were created.
+   * Returns this client member's durable attributes or null if no durable attributes were created.
-    return this.durableClientAttributes;
+    DurableClientAttributes attributes = netMbr.getDurableClientAttributes();
+    if (attributes == null) {
+      attributes = new DurableClientAttributes("", 300);
+      netMbr.setDurableClientAttributes(attributes);
+    }
+    return netMbr.getDurableClientAttributes();
-   * @param o -
-   *          the Object to be compared
-   * @return a negative integer, zero, or a positive integer as this object is
-   *         less than, equal to, or greater than the specified object.
-   * @exception java.lang.ClassCastException -
-   *              if the specified object's type prevents it from being compared
-   *              to this Object.
+   * @param o - the Object to be compared
+   * @return a negative integer, zero, or a positive integer as this object is less than, equal to,
+   *         or greater than the specified object.
+   * @exception java.lang.ClassCastException - if the specified object's type prevents it from being
+   *            compared to this Object.
-  
+
-  
+
-      throw new ClassCastException(LocalizedStrings.InternalDistributedMember_INTERNALDISTRIBUTEDMEMBERCOMPARETO_COMPARISON_BETWEEN_DIFFERENT_CLASSES.toLocalizedString());
-    InternalDistributedMember other = (InternalDistributedMember)o;
+      throw new ClassCastException(
+          LocalizedStrings.InternalDistributedMember_INTERNALDISTRIBUTEDMEMBERCOMPARETO_COMPARISON_BETWEEN_DIFFERENT_CLASSES
+              .toLocalizedString());
+    InternalDistributedMember other = (InternalDistributedMember) o;
-    }
-    else if (myAddr == null) {
+    } else if (myAddr == null) {
-    }
-    else if (otherAddr == null)
+    } else if (otherAddr == null)
-    if (this.name == null && other.name == null) {
+    String myName = getName();
+    String otherName = other.getName();
+    if (myName == null && otherName == null) {
-    } else if (this.name == null) {
+    } else if (myName == null) {
-    }
-    else if (other.name == null) {
+    } else if (otherName == null) {
-    }
-    else {
-      int i = this.name.compareTo(other.name);
+    } else {
+      int i = myName.compareTo(otherName);
-        if (this.vmViewId >= 0 && other.vmViewId >= 0) {
-          if (this.vmViewId < other.vmViewId) {
+        int thisViewId = getVmViewId();
+        int otherViewId = other.getVmViewId();
+        if (thisViewId >= 0 && otherViewId >= 0) {
+          if (thisViewId < otherViewId) {
-          } else if (this.vmViewId > other.vmViewId) {
+          } else if (thisViewId > otherViewId) {
-    }
-    else if (other.uniqueTag == null) {
+    } else if (other.uniqueTag == null) {
-    }
-    else {
+    } else {
-    
-    if (checkNetMembersIfEqual
-        && this.netMbr != null && other.netMbr != null) {
-      return this.netMbr.compareTo(other.netMbr);
+
+    if (checkNetMembersIfEqual && this.netMbr != null && other.netMbr != null) {
+      return this.netMbr.compareAdditionalData(other.netMbr);
-    
+
-  public boolean equals(Object obj)
-  {
+  public boolean equals(Object obj) {
-    return compareTo((InternalDistributedMember)obj) == 0;
+    return compareTo((InternalDistributedMember) obj) == 0;
-  public int hashCode()
-  {
+  public int hashCode() {
-     result = result + netMbr.getInetAddress().hashCode();
+    result = result + netMbr.getInetAddress().hashCode();
-  private String shortName(String hostname)
-  {
+  private String shortName(String hostname) {
-  public String toString()
-  {
+  public String toString() {
-        if (add.isMulticastAddress())
-          host = add.getHostAddress();
-        else {
-         // host = shortName(add.getHostName());
-          host = SocketCreator.resolve_dns? shortName(this.hostName) : this.hostName;
-        }
+      if (add.isMulticastAddress())
+        host = add.getHostAddress();
+      else {
+        // host = shortName(add.getHostName());
+        host = SocketCreator.resolve_dns ? shortName(this.hostName) : this.hostName;
+      }
+      int vmPid = netMbr.getProcessId();
+      int vmKind = netMbr.getVmKind();
-        case DistributionManager.NORMAL_DM_TYPE:
-  //        vmStr = ":local"; // let this be silent
-          break;
-        case DistributionManager.LOCATOR_DM_TYPE:
-          vmStr = ":locator";
-          break;
-        case DistributionManager.ADMIN_ONLY_DM_TYPE:
-          vmStr = ":admin";
-          break;
-        case DistributionManager.LONER_DM_TYPE:
-          vmStr = ":loner";
-          break;
-        default:
-          vmStr = ":<unknown:" + vmKind + ">";
-          break;
+          case DistributionManager.NORMAL_DM_TYPE:
+            // vmStr = ":local"; // let this be silent
+            break;
+          case DistributionManager.LOCATOR_DM_TYPE:
+            vmStr = ":locator";
+            break;
+          case DistributionManager.ADMIN_ONLY_DM_TYPE:
+            vmStr = ":admin";
+            break;
+          case DistributionManager.LONER_DM_TYPE:
+            vmStr = ":loner";
+            break;
+          default:
+            vmStr = ":<unknown:" + vmKind + ">";
+            break;
-      if (this.vmViewId >= 0) {
-        sb.append("<v" + this.vmViewId + ">");
+      int vmViewId = getVmViewId();
+      if (vmViewId >= 0) {
+        sb.append("<v" + vmViewId + ">");
-//      if (dcPort > 0 && vmKind != DistributionManager.LONER_DM_TYPE) {
-//        sb.append("/");
-//        sb.append(Integer.toString(dcPort));
-//      }
+      // if (dcPort > 0 && vmKind != DistributionManager.LONER_DM_TYPE) {
+      // sb.append("/");
+      // sb.append(Integer.toString(dcPort));
+      // }
-        if (this.name != null && this.name.length() != 0) {
-          sb.append(":").append(this.name);
+        String name = getName();
+        if (name.length() != 0) {
+          sb.append(":").append(name);
-      if (this.version != Version.CURRENT.ordinal()) {
-        sb.append("(version:").append(Version.toString(this.version))
-            .append(')');
+      short version = netMbr.getVersionOrdinal();
+      if (version != Version.CURRENT.ordinal()) {
+        sb.append("(version:").append(Version.toString(version)).append(')');
-      
-//      if (netMbr instanceof GMSMember) {
-//        sb.append("(UUID=").append(((GMSMember)netMbr).getUUID()).append(")");
-//      }
+
+      // if (netMbr instanceof GMSMember) {
+      // sb.append("(UUID=").append(((GMSMember)netMbr).getUUID()).append(")");
+      // }
-  private void readVersion(int flags, DataInput in) throws IOException {
+  private short readVersion(int flags, DataInput in) throws IOException {
-      this.version = Version.readOrdinal(in);
-      this.versionObj = Version.fromOrdinalNoThrow(this.version, false);
+      short version = Version.readOrdinal(in);
+      this.versionObj = Version.fromOrdinalNoThrow(version, false);
+      return version;
-        this.version = v.ordinal();
+        return v.ordinal();
+      return Version.CURRENT_ORDINAL;
-    Assert.assertTrue(vmKind > 0);
+    Assert.assertTrue(netMbr.getVmKind() > 0);
-    
+
-    if (netMbr.isNetworkPartitionDetectionEnabled()) flags |= NPD_ENABLED_BIT;
-    if (netMbr.preferredForCoordinator()) flags |= COORD_ENABLED_BIT;
-    if (this.isPartial) flags |= PARTIAL_ID_BIT;
+    if (netMbr.isNetworkPartitionDetectionEnabled())
+      flags |= NPD_ENABLED_BIT;
+    if (netMbr.preferredForCoordinator())
+      flags |= COORD_ENABLED_BIT;
+    if (this.isPartial)
+      flags |= PARTIAL_ID_BIT;
-    out.writeByte((byte)(flags & 0xff));
+    out.writeByte((byte) (flags & 0xff));
-    out.writeInt(dcPort);
-    out.writeInt(vmPid);
-    out.writeInt(vmKind);
-    out.writeInt(vmViewId);
-    DataSerializer.writeStringArray(this.groups, out);
+    out.writeInt(netMbr.getDirectPort());
+    out.writeInt(netMbr.getProcessId());
+    out.writeInt(netMbr.getVmKind());
+    out.writeInt(netMbr.getVmViewId());
+    DataSerializer.writeStringArray(netMbr.getGroups(), out);
-    DataSerializer.writeString(this.name, out);
+    DataSerializer.writeString(netMbr.getName(), out);
-    DataSerializer.writeString(this.durableClientAttributes==null ? "" : this.durableClientAttributes.getId(), out);
-    DataSerializer.writeInteger(Integer.valueOf(this.durableClientAttributes==null ? 300 : this.durableClientAttributes.getTimeout()), out);
-    Version.writeOrdinal(out, this.version, true);
+    DurableClientAttributes attributes = netMbr.getDurableClientAttributes();
+    DataSerializer.writeString(attributes == null ? "" : attributes.getId(), out);
+    DataSerializer.writeInteger(Integer.valueOf(attributes == null ? 300 : attributes.getTimeout()),
+        out);
+    Version.writeOrdinal(out, netMbr.getVersionOrdinal(), true);
-    * For Externalizable
-    *
-    * @see Externalizable
-    */
-   public void readExternal(ObjectInput in)
-   throws IOException, ClassNotFoundException {
-     int len = in.readInt(); // IPv6 compatible
-     byte addr[] = new byte[len];
-     in.readFully(addr);
-     InetAddress inetAddr = InetAddress.getByAddress(addr);
-     int port = in.readInt();
-     
-     this.hostName = DataSerializer.readString(in);
+   * For Externalizable
+   *
+   * @see Externalizable
+   */
+  public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
+    int len = in.readInt(); // IPv6 compatible
+    byte addr[] = new byte[len];
+    in.readFully(addr);
+    InetAddress inetAddr = InetAddress.getByAddress(addr);
+    int port = in.readInt();
-     int flags = in.readUnsignedByte();
-     boolean sbEnabled = (flags & NPD_ENABLED_BIT) != 0;
-     boolean elCoord = (flags & COORD_ENABLED_BIT) != 0;
-     this.isPartial = (flags & PARTIAL_ID_BIT) != 0;
-     
-     this.dcPort = in.readInt();
-     this.vmPid = in.readInt();
-     this.vmKind = in.readInt();
-     this.vmViewId = in.readInt();
-     this.groups = DataSerializer.readStringArray(in);
+    this.hostName = DataSerializer.readString(in);
-     this.name = DataSerializer.readString(in);
-     this.uniqueTag = DataSerializer.readString(in);
-     String durableId = DataSerializer.readString(in);
-     int durableTimeout = DataSerializer.readInteger(in).intValue();
-     this.durableClientAttributes = new DurableClientAttributes(durableId, durableTimeout);
+    int flags = in.readUnsignedByte();
+    boolean sbEnabled = (flags & NPD_ENABLED_BIT) != 0;
+    boolean elCoord = (flags & COORD_ENABLED_BIT) != 0;
+    this.isPartial = (flags & PARTIAL_ID_BIT) != 0;
-     readVersion(flags, in);
+    int dcPort = in.readInt();
+    int vmPid = in.readInt();
+    int vmKind = in.readInt();
+    int vmViewId = in.readInt();
+    String[] groups = DataSerializer.readStringArray(in);
-     netMbr = MemberFactory.newNetMember(inetAddr, port, sbEnabled, elCoord, version,
-         new MemberAttributes(dcPort, vmPid, vmKind, vmViewId, name, groups, durableClientAttributes));
-     if (this.version >= Version.GFE_90.ordinal()) {
-       try {
-         netMbr.readAdditionalData(in);
-       } catch (java.io.EOFException e) {
-         // old version quand-meme
-       }
-     }
+    String name = DataSerializer.readString(in);
+    this.uniqueTag = DataSerializer.readString(in);
+    String durableId = DataSerializer.readString(in);
+    int durableTimeout = DataSerializer.readInteger(in).intValue();
+    DurableClientAttributes durableClientAttributes =
+        new DurableClientAttributes(durableId, durableTimeout);
-     Assert.assertTrue(this.vmKind > 0);
-   }
+    short version = readVersion(flags, in);
+
+    netMbr = MemberFactory.newNetMember(inetAddr, port, sbEnabled, elCoord, version,
+        new MemberAttributes(dcPort, vmPid, vmKind, vmViewId, name, groups,
+            durableClientAttributes));
+    if (version >= Version.GFE_90.ordinal()) {
+      try {
+        netMbr.readAdditionalData(in);
+      } catch (java.io.EOFException e) {
+        // old version
+      }
+    }
+
+    Assert.assertTrue(netMbr.getVmKind() > 0);
+  }
-    if (this.version >= Version.GFE_90.ordinal()) {
+    if (netMbr.getVersionOrdinal() >= Version.GFE_90.ordinal()) {
-  
-  
+
+
-    //Assert.assertTrue(vmKind > 0);
+    // Assert.assertTrue(vmKind > 0);
-    //       then bump Connection.HANDSHAKE_VERSION since an
-    //       instance of this class is sent during Connection handshake.
+    // then bump Connection.HANDSHAKE_VERSION since an
+    // instance of this class is sent during Connection handshake.
-    if (netMbr.isNetworkPartitionDetectionEnabled()) flags |= NPD_ENABLED_BIT;
-    if (netMbr.preferredForCoordinator()) flags |= COORD_ENABLED_BIT;
-    if (this.isPartial) flags |= PARTIAL_ID_BIT;
+    if (netMbr.isNetworkPartitionDetectionEnabled())
+      flags |= NPD_ENABLED_BIT;
+    if (netMbr.preferredForCoordinator())
+      flags |= COORD_ENABLED_BIT;
+    if (this.isPartial)
+      flags |= PARTIAL_ID_BIT;
-    out.writeByte((byte)(flags & 0xff));
-    
-    out.writeInt(dcPort);
-    out.writeInt(vmPid);
-    out.writeByte(vmKind);
-    DataSerializer.writeStringArray(this.groups, out);
-    DataSerializer.writeString(this.name, out);
-    if (this.vmKind == DistributionManager.LONER_DM_TYPE) {
+    out.writeByte((byte) (flags & 0xff));
+
+    out.writeInt(netMbr.getDirectPort());
+    out.writeInt(netMbr.getProcessId());
+    int vmKind = netMbr.getVmKind();
+    out.writeByte(vmKind);
+    DataSerializer.writeStringArray(netMbr.getGroups(), out);
+
+    DataSerializer.writeString(netMbr.getName(), out);
+    if (vmKind == DistributionManager.LONER_DM_TYPE) {
-    } else {  // added in 6.5 for unique identifiers in P2P
-      DataSerializer.writeString(String.valueOf(this.vmViewId), out);
+    } else { // added in 6.5 for unique identifiers in P2P
+      DataSerializer.writeString(String.valueOf(netMbr.getVmViewId()), out);
-    DataSerializer.writeString(this.durableClientAttributes==null ? "" : this.durableClientAttributes.getId(), out);
-    DataSerializer.writeInteger(Integer.valueOf(this.durableClientAttributes==null ? 300 : this.durableClientAttributes.getTimeout()), out);
-    Version.writeOrdinal(out, this.version, true);
+    DurableClientAttributes durableClientAttributes = netMbr.getDurableClientAttributes();
+    DataSerializer
+        .writeString(durableClientAttributes == null ? "" : durableClientAttributes.getId(), out);
+    DataSerializer.writeInteger(Integer.valueOf(
+        durableClientAttributes == null ? 300 : durableClientAttributes.getTimeout()), out);
+
+    short version = netMbr.getVersionOrdinal();
+    Version.writeOrdinal(out, version, true);
-      Assert.assertTrue(vmKind > 0);
+    Assert.assertTrue(netMbr.getVmKind() > 0);
-//    Assert.assertTrue(getPort() > 0);
-//    if (this.getPort() == 0) {
-//      InternalDistributedSystem.getLoggerI18n().warning(LocalizedStrings.DEBUG,
-//          "Serializing ID with zero port", new Exception("Stack trace"));
-//    }
+    // Assert.assertTrue(getPort() > 0);
+    // if (this.getPort() == 0) {
+    // InternalDistributedSystem.getLoggerI18n().warning(LocalizedStrings.DEBUG,
+    // "Serializing ID with zero port", new Exception("Stack trace"));
+    // }
-    //       then bump Connection.HANDSHAKE_VERSION since an
-    //       instance of this class is sent during Connection handshake.
+    // then bump Connection.HANDSHAKE_VERSION since an
+    // instance of this class is sent during Connection handshake.
-    if (netMbr.isNetworkPartitionDetectionEnabled()) flags |= NPD_ENABLED_BIT;
-    if (netMbr.preferredForCoordinator()) flags |= COORD_ENABLED_BIT;
-    if (this.isPartial) flags |= PARTIAL_ID_BIT;
-    out.writeByte((byte)(flags & 0xff));
-    
-    out.writeInt(dcPort);
-    out.writeInt(vmPid);
-    out.writeByte(vmKind);
-    DataSerializer.writeStringArray(this.groups, out);
+    if (netMbr.isNetworkPartitionDetectionEnabled())
+      flags |= NPD_ENABLED_BIT;
+    if (netMbr.preferredForCoordinator())
+      flags |= COORD_ENABLED_BIT;
+    if (this.isPartial)
+      flags |= PARTIAL_ID_BIT;
+    out.writeByte((byte) (flags & 0xff));
-    DataSerializer.writeString(this.name, out);
-    if (this.vmKind == DistributionManager.LONER_DM_TYPE) {
+    out.writeInt(netMbr.getDirectPort());
+    out.writeInt(netMbr.getProcessId());
+    out.writeByte(netMbr.getVmKind());
+    DataSerializer.writeStringArray(netMbr.getGroups(), out);
+
+    DataSerializer.writeString(netMbr.getName(), out);
+    int vmKind = netMbr.getVmKind();
+    if (vmKind == DistributionManager.LONER_DM_TYPE) {
-    } else {  // added in 6.5 for unique identifiers in P2P
-      DataSerializer.writeString(String.valueOf(this.vmViewId), out);
+    } else { // added in 6.5 for unique identifiers in P2P
+      DataSerializer.writeString(String.valueOf(netMbr.getVmViewId()), out);
-    DataSerializer.writeString(this.durableClientAttributes==null ? "" : this.durableClientAttributes.getId(), out);
-    DataSerializer.writeInteger(Integer.valueOf(this.durableClientAttributes==null ? 300 : this.durableClientAttributes.getTimeout()), out);
- 
+    DurableClientAttributes durableClientAttributes = netMbr.getDurableClientAttributes();
+    DataSerializer
+        .writeString(durableClientAttributes == null ? "" : durableClientAttributes.getId(), out);
+    DataSerializer.writeInteger(Integer.valueOf(
+        durableClientAttributes == null ? 300 : durableClientAttributes.getTimeout()), out);
-  
-  public void fromData(DataInput in)
-  throws IOException, ClassNotFoundException {
+
+
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    if (this.version >= Version.GFE_90.ordinal()) {
+    if (getNetMember().getVersionOrdinal() >= Version.GFE_90.ordinal()) {
-  
-  public void fromDataPre_GFE_9_0_0_0(DataInput in)
-  throws IOException, ClassNotFoundException {
+
+  public void fromDataPre_GFE_9_0_0_0(DataInput in) throws IOException, ClassNotFoundException {
-    this.hostName = SocketCreator.resolve_dns? SocketCreator.getCanonicalHostName(inetAddr, hostName) : inetAddr.getHostAddress();
+
+    this.hostName = SocketCreator.resolve_dns
+        ? SocketCreator.getCanonicalHostName(inetAddr, hostName) : inetAddr.getHostAddress();
-    this.dcPort = in.readInt();
-    this.vmPid = in.readInt();
-    this.vmKind = in.readUnsignedByte();
-    this.groups = DataSerializer.readStringArray(in);
+    int dcPort = in.readInt();
+    int vmPid = in.readInt();
+    int vmKind = in.readUnsignedByte();
+    String[] groups = DataSerializer.readStringArray(in);
+    int vmViewId = -1;
-    this.name = DataSerializer.readString(in);
-    if (this.vmKind == DistributionManager.LONER_DM_TYPE) {
+    String name = DataSerializer.readString(in);
+    if (vmKind == DistributionManager.LONER_DM_TYPE) {
-        this.vmViewId = Integer.parseInt(str);
+        vmViewId = Integer.parseInt(str);
-    this.durableClientAttributes = new DurableClientAttributes(durableId, durableTimeout);
+    DurableClientAttributes durableClientAttributes =
+        durableId.length() > 0 ? new DurableClientAttributes(durableId, durableTimeout) : null;
-    readVersion(flags, in);
+    short version = readVersion(flags, in);
-    MemberAttributes attr = new MemberAttributes(this.dcPort, this.vmPid,
-        this.vmKind, this.vmViewId, this.name, this.groups, this.durableClientAttributes);
+    MemberAttributes attr = new MemberAttributes(dcPort, vmPid, vmKind, vmViewId, name, groups,
+        durableClientAttributes);
-    synchPayload();
-
-    Assert.assertTrue(this.vmKind > 0);
-//    Assert.assertTrue(getPort() > 0);
+    Assert.assertTrue(netMbr.getVmKind() > 0);
+    // Assert.assertTrue(getPort() > 0);
-  public void fromDataPre_GFE_7_1_0_0(DataInput in)  throws IOException, ClassNotFoundException {
+  public void fromDataPre_GFE_7_1_0_0(DataInput in) throws IOException, ClassNotFoundException {
-    this.hostName = SocketCreator.resolve_dns? SocketCreator.getCanonicalHostName(inetAddr, hostName) : inetAddr.getHostAddress();
+
+    this.hostName = SocketCreator.resolve_dns
+        ? SocketCreator.getCanonicalHostName(inetAddr, hostName) : inetAddr.getHostAddress();
-    this.dcPort = in.readInt();
-    this.vmPid = in.readInt();
-    this.vmKind = in.readUnsignedByte();
-    this.groups = DataSerializer.readStringArray(in);
+    int dcPort = in.readInt();
+    int vmPid = in.readInt();
+    int vmKind = in.readUnsignedByte();
+    String[] groups = DataSerializer.readStringArray(in);
+    int vmViewId = -1;
-    this.name = DataSerializer.readString(in);
-    if (this.vmKind == DistributionManager.LONER_DM_TYPE) {
+    String name = DataSerializer.readString(in);
+    if (vmKind == DistributionManager.LONER_DM_TYPE) {
-        this.vmViewId = Integer.parseInt(str);
+        vmViewId = Integer.parseInt(str);
-    this.durableClientAttributes = new DurableClientAttributes(durableId, durableTimeout);
+    DurableClientAttributes durableClientAttributes =
+        durableId.length() > 0 ? new DurableClientAttributes(durableId, durableTimeout) : null;
-    MemberAttributes attr = new MemberAttributes(this.dcPort, this.vmPid,
-        this.vmKind, this.vmViewId, this.name, this.groups, this.durableClientAttributes);
-    netMbr = MemberFactory.newNetMember(inetAddr, port, sbEnabled, elCoord, 
-        InternalDataSerializer.getVersionForDataStream(in).ordinal(), attr);
+    short version = readVersion(flags, in);
-    synchPayload();
+    MemberAttributes attr = new MemberAttributes(dcPort, vmPid, vmKind, vmViewId, name, groups,
+        durableClientAttributes);
+    netMbr = MemberFactory.newNetMember(inetAddr, port, sbEnabled, elCoord, version, attr);
-    Assert.assertTrue(this.vmKind > 0);
+    Assert.assertTrue(netMbr.getVmKind() > 0);
-  /** this writes just the parts of the ID that are needed for comparisons and communications */
-   public static InternalDistributedMember readEssentialData(DataInput in)
-     throws IOException, ClassNotFoundException {
-     final InternalDistributedMember mbr = new InternalDistributedMember();
-     mbr._readEssentialData(in);
-     return mbr;
-   }
-   
-   private void _readEssentialData(DataInput in)
-     throws IOException, ClassNotFoundException {
-     this.isPartial = true;
-     InetAddress inetAddr = DataSerializer.readInetAddress(in);
-     int port = in.readInt();
+  /** this reads an ID written with writeEssentialData */
+  public static InternalDistributedMember readEssentialData(DataInput in)
+      throws IOException, ClassNotFoundException {
+    final InternalDistributedMember mbr = new InternalDistributedMember();
+    mbr._readEssentialData(in);
+    return mbr;
+  }
-     this.hostName = SocketCreator.resolve_dns? SocketCreator.getHostName(inetAddr) : inetAddr.getHostAddress();
+  private void _readEssentialData(DataInput in) throws IOException, ClassNotFoundException {
+    this.isPartial = true;
+    InetAddress inetAddr = DataSerializer.readInetAddress(in);
+    int port = in.readInt();
-     int flags = in.readUnsignedByte();
-     boolean sbEnabled = (flags & NPD_ENABLED_BIT) != 0;
-     boolean elCoord = (flags & COORD_ENABLED_BIT) != 0;
+    this.hostName =
+        SocketCreator.resolve_dns ? SocketCreator.getHostName(inetAddr) : inetAddr.getHostAddress();
-     this.vmKind = in.readUnsignedByte();
-     
+    int flags = in.readUnsignedByte();
+    boolean sbEnabled = (flags & NPD_ENABLED_BIT) != 0;
+    boolean elCoord = (flags & COORD_ENABLED_BIT) != 0;
-     if (this.vmKind == DistributionManager.LONER_DM_TYPE) {
-       this.uniqueTag = DataSerializer.readString(in);
-     } else {
-       String str = DataSerializer.readString(in);
-       if (str != null) { // backward compatibility from earlier than 6.5
-         this.vmViewId = Integer.parseInt(str);
-       }
-     }
+    int vmKind = in.readUnsignedByte();
+    int vmViewId = -1;
-     this.name = DataSerializer.readString(in);
+    if (vmKind == DistributionManager.LONER_DM_TYPE) {
+      this.uniqueTag = DataSerializer.readString(in);
+    } else {
+      String str = DataSerializer.readString(in);
+      if (str != null) { // backward compatibility from earlier than 6.5
+        vmViewId = Integer.parseInt(str);
+      }
+    }
-     MemberAttributes attr = new MemberAttributes(this.dcPort, this.vmPid,
-         this.vmKind, this.vmViewId, this.name, this.groups, this.durableClientAttributes);
-     netMbr = MemberFactory.newNetMember(inetAddr, port, sbEnabled, elCoord, 
-         InternalDataSerializer.getVersionForDataStream(in).ordinal(), attr);
+    String name = DataSerializer.readString(in);
-     synchPayload();
+    MemberAttributes attr = new MemberAttributes(-1, -1, vmKind, vmViewId, name, null, null);
+    netMbr = MemberFactory.newNetMember(inetAddr, port, sbEnabled, elCoord,
+        InternalDataSerializer.getVersionForDataStream(in).ordinal(), attr);
-     if (InternalDataSerializer.getVersionForDataStream(in).compareTo(Version.GFE_90)>=0) {
-       netMbr.readAdditionalData(in);
-     }
-   }
+    if (InternalDataSerializer.getVersionForDataStream(in).compareTo(Version.GFE_90) == 0) {
+      netMbr.readAdditionalData(in);
+    }
+  }
-   public void writeEssentialData(DataOutput out) throws IOException {
-     Assert.assertTrue(vmKind > 0);
-     DataSerializer.writeInetAddress(getInetAddress(), out);
-     out.writeInt(getPort());
+  public void writeEssentialData(DataOutput out) throws IOException {
+    Assert.assertTrue(netMbr.getVmKind() > 0);
+    DataSerializer.writeInetAddress(getInetAddress(), out);
+    out.writeInt(getPort());
-     int flags = 0;
-     if (netMbr.isNetworkPartitionDetectionEnabled()) flags |= NPD_ENABLED_BIT;
-     if (netMbr.preferredForCoordinator()) flags |= COORD_ENABLED_BIT;
-     flags |= PARTIAL_ID_BIT;
-     out.writeByte((byte)(flags & 0xff));
-     
-//     out.writeInt(dcPort);
-     out.writeByte(vmKind);
+    int flags = 0;
+    if (netMbr.isNetworkPartitionDetectionEnabled())
+      flags |= NPD_ENABLED_BIT;
+    if (netMbr.preferredForCoordinator())
+      flags |= COORD_ENABLED_BIT;
+    flags |= PARTIAL_ID_BIT;
+    out.writeByte((byte) (flags & 0xff));
-     if (this.vmKind == DistributionManager.LONER_DM_TYPE) {
-       DataSerializer.writeString(this.uniqueTag, out);
-     } else {  // added in 6.5 for unique identifiers in P2P
-       DataSerializer.writeString(String.valueOf(this.vmViewId), out);
-     }
-     // write name last to fix bug 45160
-     DataSerializer.writeString(this.name, out);
+    // out.writeInt(dcPort);
+    byte vmKind = netMbr.getVmKind();
+    out.writeByte(vmKind);
-     if (InternalDataSerializer.getVersionForDataStream(out).compareTo(Version.GFE_90)>=0) {
-       netMbr.writeAdditionalData(out);
-     }
-   }
+    if (vmKind == DistributionManager.LONER_DM_TYPE) {
+      DataSerializer.writeString(this.uniqueTag, out);
+    } else { // added in 6.5 for unique identifiers in P2P
+      DataSerializer.writeString(String.valueOf(netMbr.getVmViewId()), out);
+    }
+    // write name last to fix bug 45160
+    DataSerializer.writeString(netMbr.getName(), out);
+
+    if (InternalDataSerializer.getVersionForDataStream(out).compareTo(Version.GFE_90) == 0) {
+      netMbr.writeAdditionalData(out);
+    }
+  }
-  public void setDirectChannelPort(int p)
-  {
-    dcPort = p;
-    synchPayload();
+  public void setDirectChannelPort(int p) {
+    netMbr.setDirectPort(p);
-  
+
-   * Set the membership port.  This is done in loner systems using
-   * client/server connection information to help form a unique ID
+   * Set the membership port. This is done in loner systems using client/server connection
+   * information to help form a unique ID
-    assert this.vmKind == DistributionManager.LONER_DM_TYPE;
+    assert netMbr.getVmKind() == DistributionManager.LONER_DM_TYPE;
-    synchPayload();
-  
+
-    return this.vmPid;
+    return netMbr.getProcessId();
-    /*if (this.ipAddr == null) {
-      return "<null>";
-    }
-    else {
-      StringBuffer sb = new StringBuffer();
-      InetAddress addr = this.ipAddr.getIpAddress();
-      if(addr.isMulticastAddress()) {
-        sb.append(addr.getHostAddress());
-      } else {
-        appendShortName(addr.getHostName(), sb);
-      }
-      if (this.vmPid != 0) {
-        sb.append("(");
-        sb.append(this.vmPid);
-        sb.append(")");
-      }
-      sb.append(":");
-      sb.append(this.ipAddr.getPort());
-      return sb.toString();
-    }
-  }
+  /*
+   * if (this.ipAddr == null) { return "<null>"; } else { StringBuffer sb = new StringBuffer();
+   * InetAddress addr = this.ipAddr.getIpAddress(); if(addr.isMulticastAddress()) {
+   * sb.append(addr.getHostAddress()); } else { appendShortName(addr.getHostName(), sb); } if
+   * (this.vmPid != 0) { sb.append("("); sb.append(this.vmPid); sb.append(")"); } sb.append(":");
+   * sb.append(this.ipAddr.getPort()); return sb.toString(); } }
+   * 
+   * // Helper method for getId()... copied from IpAddress. private void appendShortName(String
+   * hostname, StringBuffer sb) { if (hostname == null) return; int index = hostname.indexOf('.');
+   * if(index > 0 && !Character.isDigit(hostname.charAt(0))) { sb.append(hostname.substring(0,
+   * index)); } else { sb.append(hostname); } }
+   */
-  // Helper method for getId()... copied from IpAddress.
-  private void appendShortName(String hostname, StringBuffer sb) {
-    if (hostname == null) return;
-    int index = hostname.indexOf('.');
-    if(index > 0 && !Character.isDigit(hostname.charAt(0))) {
-      sb.append(hostname.substring(0, index));
-    } else {
-      sb.append(hostname);
-    }
-  }*/
-  
-    this.version = v.ordinal();
-  
+
-  @Override
-  public int getSizeInBytes() {
-  
-    int size = 0;
-  
-    // ipaddr:  1 byte length + 4 bytes (IPv4) or 16 bytes (IPv6)
-    if (netMbr.getInetAddress() instanceof Inet4Address){
-      size += 5;
-    } else {
-      size += 17;
-    }
-    
-    // port:  4 bytes
-    // flags: 1 byte
-    //vmKind: 1 byte
-    size += 6;
-    
-    // viewID:  String(1+1+numchars)
-    size += (2+ String.valueOf(this.vmViewId).length());
-    
-    // empty name: String(1+1)
-    size += 2;
-    
-    return size;
-  }
-  
-    
+
-      InternalDistributedMember other = ((InternalDistributedMemberWrapper)obj).mbr;
+      InternalDistributedMember other = ((InternalDistributedMemberWrapper) obj).mbr;
-    }        
+    }

INS26 INS26 MOV31 INS40 INS40 INS31 INS31 INS83 INS42 INS8 MOV60 INS29 INS83 INS42 INS44 INS8 MOV44 MOV44 UPD39 MOV44 MOV43 MOV44 MOV43 MOV43 UPD42 UPD66 INS60 MOV65 UPD65 MOV65 INS43 INS42 INS21 INS60 INS54 INS21 INS21 INS21 INS21 INS21 INS21 MOV21 MOV65 MOV65 MOV21 INS60 INS25 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 MOV21 INS60 INS60 INS60 MOV21 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS25 INS60 INS60 INS60 INS60 MOV25 MOV60 INS60 INS41 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS32 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS39 INS59 UPD66 UPD66 UPD66 UPD66 INS39 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS42 INS66 INS42 INS7 INS43 INS59 INS8 INS12 INS7 INS32 INS7 INS32 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS32 INS32 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS32 INS32 INS32 INS32 INS32 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS32 UPD66 INS32 UPD66 UPD66 INS32 INS32 INS32 UPD66 UPD66 INS32 UPD66 INS32 UPD66 UPD66 MOV43 UPD66 UPD66 UPD66 MOV43 INS59 INS27 INS8 INS32 UPD66 UPD66 UPD66 UPD66 UPD66 INS43 INS59 MOV43 INS59 INS43 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 MOV5 INS59 INS43 INS59 INS43 INS59 INS39 INS59 INS27 MOV27 INS39 INS59 MOV8 INS43 INS59 INS39 INS59 INS39 INS59 MOV8 INS43 INS59 INS39 INS59 INS39 INS59 INS39 INS59 MOV5 INS59 INS39 MOV59 INS43 INS59 INS43 INS59 INS39 INS59 MOV43 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS5 INS59 INS39 INS59 INS43 INS59 INS27 MOV8 INS8 INS43 INS59 INS39 INS59 MOV43 UPD66 INS39 INS59 INS39 INS59 MOV43 UPD27 INS39 INS59 UPD27 INS32 UPD66 UPD66 INS32 INS42 INS42 MOV32 INS42 MOV32 UPD42 MOV32 INS22 INS32 INS42 UPD42 MOV42 MOV33 MOV21 INS44 INS8 INS42 INS32 INS42 INS42 INS40 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS60 INS60 INS60 INS60 INS60 INS41 INS41 INS32 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS32 INS32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 INS42 MOV32 INS42 INS42 MOV14 INS42 MOV32 INS42 MOV32 INS32 INS32 INS32 INS42 INS32 INS32 INS32 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS32 INS32 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS32 INS32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 INS42 MOV32 INS42 INS42 UPD42 MOV42 INS16 INS42 MOV32 INS42 MOV14 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS43 INS85 INS42 MOV32 INS42 INS38 INS42 INS42 MOV32 INS42 INS40 INS60 INS25 INS42 INS42 INS16 INS42 INS32 INS42 MOV32 INS42 INS38 INS42 UPD42 MOV32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS32 MOV42 UPD42 MOV42 INS52 INS42 INS42 INS42 MOV43 INS42 INS53 INS42 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS7 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS42 INS40 INS32 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS27 MOV14 INS33 INS32 INS42 INS34 INS43 INS59 MOV27 INS8 INS27 MOV14 INS33 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS32 INS34 MOV43 MOV38 MOV38 INS42 INS42 INS42 INS33 INS33 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS60 INS60 UPD42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS60 INS25 INS42 INS32 INS42 INS42 MOV32 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS34 INS42 INS42 MOV22 INS42 INS42 MOV32 MOV21 INS32 INS34 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS22 INS43 INS27 INS42 INS43 INS45 INS34 INS39 INS59 INS39 INS59 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS27 MOV8 INS42 INS42 INS42 MOV32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 MOV42 INS42 INS42 INS32 MOV52 UPD42 MOV42 INS42 INS45 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 MOV32 MOV34 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL40 DEL59 DEL23 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL23 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL59 DEL23 DEL66 DEL29 DEL83 DEL42 DEL33 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL40 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL59 DEL23 DEL52 DEL42 DEL22 DEL7 DEL42 DEL32 DEL21 DEL83 DEL42 DEL8 DEL31 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL8 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL52 DEL42 DEL22 DEL7 DEL21 DEL66 DEL66 DEL40 DEL42 DEL67 DEL22 DEL34 DEL3 DEL66 DEL66 DEL42 DEL43 DEL66 DEL66 DEL42 DEL43 DEL52 DEL42 DEL22 DEL40 DEL7 DEL66 DEL66 DEL52 DEL42 DEL22 DEL42 DEL7 DEL52 DEL42 DEL22 DEL42 DEL7 DEL52 DEL42 DEL22 DEL42 DEL7 DEL52 DEL42 DEL22 DEL42 DEL7 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL66 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL7 DEL42 DEL32 DEL21 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL42 DEL42 DEL7 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL42 DEL32 DEL21 DEL42 DEL66 DEL52 DEL42 DEL22 DEL42 DEL7 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL66 DEL52 DEL42 DEL22 DEL66 DEL66 DEL52 DEL42 DEL22 DEL40 DEL52 DEL42 DEL22 DEL40 DEL52 DEL42 DEL22 DEL40 DEL52 DEL42 DEL22 DEL40 DEL52 DEL42 DEL22 DEL40 DEL52 DEL42 DEL22 DEL40 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL33 DEL27 DEL27 DEL27 DEL25 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL7 DEL21 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL27 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL7 DEL21 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL14 DEL59 DEL60 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL40 DEL27 DEL52 DEL42 DEL22 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL52 DEL42 DEL22 DEL7 DEL21 DEL42 DEL43 DEL42 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL7 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL42 DEL78 DEL39 DEL42 DEL34 DEL59 DEL60 DEL32 DEL42 DEL43 DEL62 DEL42 DEL34 DEL7 DEL21 DEL8 DEL42 DEL34 DEL7 DEL21 DEL8 DEL25 DEL42 DEL34 DEL7 DEL21 DEL42 DEL34 DEL42 DEL42 DEL52 DEL42 DEL22 DEL32 DEL42 DEL32 DEL27 DEL36 DEL7 DEL21 DEL42 DEL34 DEL7 DEL21 DEL42 DEL41 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21
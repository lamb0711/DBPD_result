GEODE-6588: Cleanup generics and other static analyzer issues. (#3391)


+
-import org.apache.geode.cache.query.AmbiguousNameException;
-  private String name;
+  private final String name;
-  private CompiledIteratorDef cmpIteratorDefn;
-  private ObjectType elementType; // may be more specific than that in
-  // cmpIteratorDefn
-  // for canonicalization
+  private final CompiledIteratorDef cmpIteratorDefn;
+  /** may be more specific than that in cmpIteratorDefn */
+  private ObjectType elementType;
+  /** for canonicalization */
-    return this.elementType;
+    return elementType;
-  // public RuntimeIterator(String name, SelectResults collection) {
-  // if (collection == null)
-  // throw new IllegalArgumentException("base collection must not be null");
-  //
-  // this.name = name; // may be null
-  // this.collection = collection;
-  // this.cmpIteratorDefn = null;
-  // this.elementType = collection.getCollectionType().getElementType();
-  // }
-  // /** Return true if this is an iterator that is dependent on other
-  // iterator(s)
-  // * in this scope (a cached result from isDependentOn(context))
-  // */
-  // public boolean isDependent() {
-  // return this.isDependent;
-  // }
-    return this.cmpIteratorDefn;
+    return cmpIteratorDefn;
-    return this.name;
+    return name;
-    if (this.collection != UNINITIALIZED
-        && !this.cmpIteratorDefn.isDependentOnAnyIteratorOfScopeLessThanItsOwn(context)
-        && this.scopeID != IndexCreationHelper.INDEX_QUERY_SCOPE_ID) {
-      return this.collection;
+    if (collection != UNINITIALIZED
+        && !cmpIteratorDefn.isDependentOnAnyIteratorOfScopeLessThanItsOwn(context)
+        && scopeID != IndexCreationHelper.INDEX_QUERY_SCOPE_ID) {
+      return collection;
-    this.collection = this.cmpIteratorDefn.evaluateCollection(context, this);
-    if (this.collection == null) {
+    collection = cmpIteratorDefn.evaluateCollection(context, this);
+    if (collection == null) {
-    if (!this.elementType.equals(TypeUtils.OBJECT_TYPE)) {
-      this.collection.setElementType(elementType);
+    if (!elementType.equals(TypeUtils.OBJECT_TYPE)) {
+      collection.setElementType(elementType);
-      // Asif : The elementType in the Collection obtained is more
-      // specific . So use that type.
-      this.elementType = collection.getCollectionType().getElementType();
+      // The elementType in the Collection obtained is more specific . So use that type.
+      elementType = collection.getCollectionType().getElementType();
-    return this.collection;
+    return collection;
-    return this.cmpIteratorDefn.isDependentOnIterator(itr, context);
+    return cmpIteratorDefn.isDependentOnIterator(itr, context);
-    return this.cmpIteratorDefn.isDependentOnCurrentScope(context);
+    return cmpIteratorDefn.isDependentOnCurrentScope(context);
-    return this.current;
+    return current;
-  boolean containsProperty(ExecutionContext context, String name, int numArgs, boolean mustBeMethod)
-      throws AmbiguousNameException {
+  boolean containsProperty(ExecutionContext context, String name, int numArgs,
+      boolean mustBeMethod) {
-    if ((this.elementType instanceof StructType) && !mustBeMethod) {
+    if ((elementType instanceof StructType) && !mustBeMethod) {
-      String fieldName[] = ((StructType) this.elementType).getFieldNames();
-      for (int i = 0; i < fieldName.length; i++) {
-        if (name.equals(fieldName[i])) {
+      String[] fieldName = ((StructType) elementType).getFieldNames();
+      for (String s : fieldName) {
+        if (name.equals(s)) {
-    Class clazz = this.elementType.resolveClass();
+    Class<?> clazz = elementType.resolveClass();
-      for (int i = 0; i < methods.length; i++) {
-        Method m = methods[i];
-        if (m.getName().equals(name) && m.getParameterTypes().length == numArgs)
+      for (Method m : methods) {
+        if (m.getName().equals(name) && m.getParameterTypes().length == numArgs) {
+        }
-  // private SelectResults prepareIteratorDef(Object obj)
-  // throws TypeMismatchException {
-  // if (obj == null) {
-  // return null;
-  // }
-  //
-  // if (obj == QueryService.UNDEFINED) {
-  // return null;
-  // }
-  //
-  // if (obj instanceof SelectResults) {
-  // // probably came from nested query or is a QRegion already from region
-  // path
-  // return (SelectResults)obj;
-  // }
-  //
-  // if (obj instanceof Region) {
-  // return new QRegion((Region)obj); // this can happen if region passed in as
-  // parameter
-  // }
-  //
-  // // if this is a domain collection, it should be unmodifiable
-  // // if obj is a Collection but not a SelectResults, it must be from the
-  // // domain, otherwise it would be a SelectResults.
-  // if (obj instanceof Collection) {
-  // // do not lose ordering and duplicate information,
-  // ResultsCollectionWrapper res =
-  // new ResultsCollectionWrapper(this.elementType, (Collection)obj);
-  // res.setModifiable(false);
-  // return res;
-  // }
-  //
-  // // Object[] is wrapped and considered a domain object so unmodifiable
-  // if (obj instanceof Object[]) {
-  // // the element type is specified in the array itself, unless we have
-  // // something more specific
-  // if (this.elementType.equals(TypeUtils.OBJECT_TYPE)) { // if we don't have
-  // constraint info
-  // this.elementType =
-  // TypeUtils.getObjectType(obj.getClass().getComponentType());
-  // }
-  //
-  // // do not lose ordering and duplicate information,
-  // ResultsCollectionWrapper res =
-  // new ResultsCollectionWrapper(this.elementType,
-  // Arrays.asList((Object[])obj));
-  // res.setModifiable(false);
-  // return res;
-  // }
-  //
-  // if (obj instanceof Map) {
-  // if (this.elementType.equals(TypeUtils.OBJECT_TYPE)) { // if we don't have
-  // more specific type info, use Map.Entry
-  // elementType = TypeUtils.getObjectType(Map.Entry.class);
-  // }
-  // ResultsCollectionWrapper res =
-  // new ResultsCollectionWrapper(elementType, ((Map)obj).entrySet());
-  // res.setModifiable(false);
-  // return res;
-  // } else {
-  // throw new TypeMismatchException(
-  // "The expression in the FROM clause of a SELECT statement was type '"
-  // + obj.getClass().getName()
-  // + "', which cannot be interpreted as a collection");
-  // }
-  // }
-    StringBuffer sb = new StringBuffer();
-    sb.append(this.getClass().getName());
-    sb.append(" (name=" + this.name);
-    // if(isDependent)
-    sb.append(" collection expr=" + cmpIteratorDefn);
-    // else {
-    // sb.append("; collection=" +this.collection + ")");
-    // sb.append("; collectionType=" +this.collection.getCollectionType() +
-    // ")");
-    // sb.append("; elementType="
-    // +this.collection.getCollectionType().getElementType() + ")");
-    // }
-    return sb.toString();
+    return getClass().getName() + " (name=" + name + " collection expr=" + cmpIteratorDefn + ")";
-  public void setInternalId(String id) {
+  void setInternalId(String id) {
-    return this.index_internal_id;
+    return index_internal_id;
-  public void generateCanonicalizedExpression(StringBuilder clauseBuffer, ExecutionContext context)
-      throws AmbiguousNameException, TypeMismatchException {
-    // Asif: prepend the internal iterator variable name for this
-    // RunTimeIterator
-    //
+  public void generateCanonicalizedExpression(StringBuilder clauseBuffer,
+      ExecutionContext context) {
+    // prepend the internal iterator variable name for this RunTimeIterator
-    if (currScopeID == this.scopeID) {
-      // Support.Assert(this.index_internal_id != null, "Index_Internal_ID
-      // should have been set at this point");
-      clauseBuffer.insert(0,
-          this.index_internal_id == null ? this.internalId : this.index_internal_id);
+    if (currScopeID == scopeID) {
+      // should have been set at this point
+      clauseBuffer.insert(0, index_internal_id == null ? internalId : index_internal_id);
-      clauseBuffer.insert(0, internalId).insert(0, '_').insert(0, this.scopeID).insert(0, "scope");
+      clauseBuffer.insert(0, internalId).insert(0, '_').insert(0, scopeID).insert(0, "scope");
-    return this.scopeID;
+    return scopeID;

INS83 INS83 INS29 INS29 INS65 INS65 INS41 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS74 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS70 MOV43 INS76 INS70 INS32 MOV45 INS42 MOV45 MOV42 INS45 INS42 INS42 INS42 INS42 INS42 INS5 INS44 INS42 INS8 INS42 INS44 INS42 MOV8 MOV32 MOV42 INS42 INS42 INS42 INS42 INS43 INS85 MOV43 INS42 MOV25 MOV43 INS42 INS42 INS42 INS8 INS42 INS42 INS42 INS42 INS41 INS42 INS42 MOV9 DEL40 DEL26 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL52 DEL42 DEL22 DEL85 DEL52 DEL42 DEL22 DEL42 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL8 DEL24 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL41 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL24 DEL52 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL52 DEL42 DEL22 DEL27 DEL32 DEL21 DEL42 DEL42 DEL27 DEL32 DEL21 DEL42 DEL42 DEL32 DEL41 DEL83 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22
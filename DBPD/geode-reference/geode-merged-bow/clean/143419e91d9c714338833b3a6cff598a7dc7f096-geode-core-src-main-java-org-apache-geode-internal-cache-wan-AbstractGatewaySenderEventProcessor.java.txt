GEODE-5142 new Thread Monitoring Mechanism

One of the most severe issues hitting our real time application is thread
stuck for multiple reasons, such as long lasting locks, deadlocks, threads
which wait for reply forever in case of packet drop issue etc...

Such kind of stuck are under Radar of the existing system health check
methods. In mission critical applications, this will be resulted as an
immediate outage.

Here we introduce thread monitoring mechanism, to detect threads which are
stuck for any reason.

If a thread is deemed stuck you will see a message like this in the
Geode log file at "warn" level:

  Thread <thread name> is stuck , initiating handleExpiry

There is also a new ResourceManager statistic keep track of the number
of stuck threads in a JVM.

Thread monitoring is enabled by default.  To disable it, set this
distributed system property:

thread-monitor-enabled=false

To adjust the monitoring interval from the default 60,000ms set this
distributed system property:

thread-monitor-interval-ms

To adjust how long a thread is unchanging before it is considered stuck
set this distributed system property, which defaults to 30,000ms:

thread-monitor-time-limit-ms

This closes #1868

commit 70b0e0889695ea3efc1ea7e095a90e6feb6a2b7f
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Sat Jul 21 23:23:33 2018 +0300

    Thread Monitoring - fixing integrated and distributed tests

commit 7fe285f03a20a57a1d80341e6381a8f6c4e50fd9
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Wed Jul 18 19:16:09 2018 +0300

    retrigger concourse-ci/UITests after timeout failure - org.openqa.selenium.TimeoutException

commit 1c791d3a722c7651f41dd5f54e2f3818787e04f8
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Wed Jul 18 16:52:19 2018 +0300

    Thread Monitor - fixing build error

commit 74aaceec67308791f8c831d9e1650a21a9a7762e
Merge: c076dcb25 897549530
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Wed Jul 18 14:57:38 2018 +0300

    Merge remote-tracking branch 'upstream/develop' into develop

commit c076dcb25bf5cf39859a46f9132c8d185cdf7c0e
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Wed Jul 18 12:48:52 2018 +0300

    ThreadMonitor - resolve complex conflict

commit a0b22cbb0d8664d110ac3b0d8b869969a3923d2e
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Wed Jul 18 10:53:21 2018 +0300

    Thread Monitoring changes - as per Bruce request

commit 9b03e0258ea47c68ea02d719f615e1d4473948d9
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Sun Jul 1 16:41:56 2018 +0300

    ThreadsMonitoring changes - as per Galen's request

commit 84040cdb3c8f3d5194afd727d5b58f503d7b92d8
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Sun Jun 3 14:30:12 2018 +0300

    Thread Monitoring - fixing merge spotlessApply

commit 42b4d2621269caf0450201f59ceca10f7bf84207
Merge: 5225d2910 62665a47a
Author: yossireg <38718655+yossireg@users.noreply.github.com>
Date:   Sun Jun 3 09:08:59 2018 +0300

    Merge branch 'develop' into develop

commit 5225d2910ad5405d891df6dc0fc4a32756305fe2
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Tue May 29 21:01:04 2018 +0300

    Thread Monitor

commit 95b7fc9b43872794a953d6599c2a5ca5d28b985f
Merge: 17a631059 83d7f6aae
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Tue May 29 18:33:56 2018 +0300

    Merge branch 'develop' of https://github.com/yossireg/geode into develop

commit 17a6310599f0fd1b4ba7afe23b6a7d2eb2dbdb66
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Tue May 29 18:30:12 2018 +0300

    Thread Monitoring - fixing geode-wan error

commit 83d7f6aae7e7fc68edf995d3f2c2e567967b09c2
Merge: a6d4acaf7 4e7c6f1f3
Author: yossireg <38718655+yossireg@users.noreply.github.com>
Date:   Tue May 29 17:12:19 2018 +0300

    Merge branch 'develop' into develop

commit a6d4acaf7be35cf87d01acbf61cf4242b4f0bf98
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Tue May 29 16:57:40 2018 +0300

    Thread Monitoring - removing singleton pattern

commit a622b21627c61723d35a127d23dd1c5d2ae2289e
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Wed May 23 10:25:25 2018 +0300

    ThreadMonitoring - changing object of TM to be final

commit dc4989c85a0aa9f6c46466e9665f7915edc9374f
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Tue May 15 16:05:38 2018 +0300

    Thread Monitoring - changing param to static final

commit 46fe08c08ede2afc3d535c516e63b35bf073fd61
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Thu May 10 12:27:44 2018 +0300

    ThreadMonitoring Sync to last changes in develop branch

commit 18cd7bc95e8b0dd734a03e34cedd4597896e5279
Merge: 1f3f0e3eb de8800047
Author: yossireg <38718655+yossireg@users.noreply.github.com>
Date:   Thu May 10 10:50:09 2018 +0300

    Merge branch 'develop' into develop

commit 1f3f0e3eb3df7a5dd965829bb59552cf6a8935bb
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Thu May 10 08:08:57 2018 +0300

    ThreadMonitoring

    retriggering the CI after it failed while it shouldnt have - locally it is working fine and the error mentioned there that Symbol does not exists should not occure

commit ae0b7639f4bff65c4613fac670043053910b7920
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Wed May 9 14:35:30 2018 +0300

    ThreadMonitoring

    Code changes as per community request

commit a5eeeb97190cc8a3dda9d5a228166a839212602c
Author: yossireg <yossi.reginiano@amdocs.com>
Date:   Thu Apr 26 11:04:40 2018 +0300

    Thread Monitoring Mechanism

+import org.apache.geode.internal.monitoring.ThreadsMonitoring;
+  private final ThreadsMonitoring threadMonitoring;
+
-      GatewaySender sender) {
+      GatewaySender sender, ThreadsMonitoring tMonitoring) {
+    this.threadMonitoring = tMonitoring;
-          // this list is access by ack reader thread so create new every time. #50220
-          filteredList = new ArrayList<GatewaySenderEventImpl>();
+          beforeExecute();
+          try {
+            // this list is access by ack reader thread so create new every time. #50220
+            filteredList = new ArrayList<GatewaySenderEventImpl>();
-          filteredList.addAll(events);
+            filteredList.addAll(events);
-          // If the exception has been set and its cause is an IllegalStateExcetption,
-          // remove all events whose serialized value is no longer available
-          if (this.exception != null && this.exception.getCause() != null
-              && this.exception.getCause() instanceof IllegalStateException) {
-            for (Iterator<GatewaySenderEventImpl> i = filteredList.iterator(); i.hasNext();) {
-              GatewaySenderEventImpl event = i.next();
-              if (event.isSerializedValueNotAvailable()) {
-                i.remove();
+            // If the exception has been set and its cause is an IllegalStateExcetption,
+            // remove all events whose serialized value is no longer available
+            if (this.exception != null && this.exception.getCause() != null
+                && this.exception.getCause() instanceof IllegalStateException) {
+              for (Iterator<GatewaySenderEventImpl> i = filteredList.iterator(); i.hasNext();) {
+                GatewaySenderEventImpl event = i.next();
+                if (event.isSerializedValueNotAvailable()) {
+                  i.remove();
+                }
+              this.exception = null;
-            this.exception = null;
-          }
-          // Filter the events
-          for (GatewayEventFilter filter : sender.getGatewayEventFilters()) {
-            Iterator<GatewaySenderEventImpl> itr = filteredList.iterator();
-            while (itr.hasNext()) {
-              GatewayQueueEvent event = itr.next();
+            // Filter the events
+            for (GatewayEventFilter filter : sender.getGatewayEventFilters()) {
+              Iterator<GatewaySenderEventImpl> itr = filteredList.iterator();
+              while (itr.hasNext()) {
+                GatewayQueueEvent event = itr.next();
-              // This seems right place to prevent transmission of UPDATE_VERSION events if
-              // receiver's
-              // version is < 7.0.1, especially to prevent another loop over events.
-              if (!sendUpdateVersionEvents
-                  && event.getOperation() == Operation.UPDATE_VERSION_STAMP) {
-                if (isTraceEnabled) {
-                  logger.trace(
-                      "Update Event Version event: {} removed from Gateway Sender queue: {}", event,
-                      sender);
+                // This seems right place to prevent transmission of UPDATE_VERSION events if
+                // receiver's
+                // version is < 7.0.1, especially to prevent another loop over events.
+                if (!sendUpdateVersionEvents
+                    && event.getOperation() == Operation.UPDATE_VERSION_STAMP) {
+                  if (isTraceEnabled) {
+                    logger.trace(
+                        "Update Event Version event: {} removed from Gateway Sender queue: {}",
+                        event, sender);
+                  }
+
+                  itr.remove();
+                  statistics.incEventsNotQueued();
+                  continue;
-                itr.remove();
-                statistics.incEventsNotQueued();
-                continue;
-              }
-
-              boolean transmit = filter.beforeTransmit(event);
-              if (!transmit) {
-                if (isDebugEnabled) {
-                  logger.debug("{}: Did not transmit event due to filtering: {}", sender.getId(),
-                      event);
-                }
-                itr.remove();
-                statistics.incEventsFiltered();
-              }
-            }
-          }
-          /*
-           * if (filteredList.isEmpty()) { eventQueueRemove(events.size()); continue; }
-           */
-
-          // if the bucket becomes secondary after the event is picked from it,
-          // check again before dispatching the event. Do this only for
-          // AsyncEventQueue since possibleDuplicate flag is not used in WAN.
-          if (this.getSender().isParallel()
-              && (this.getDispatcher() instanceof GatewaySenderEventCallbackDispatcher)) {
-            Iterator<GatewaySenderEventImpl> itr = filteredList.iterator();
-            while (itr.hasNext()) {
-              GatewaySenderEventImpl event = (GatewaySenderEventImpl) itr.next();
-              PartitionedRegion qpr = null;
-              if (this.getQueue() instanceof ConcurrentParallelGatewaySenderQueue) {
-                qpr = ((ConcurrentParallelGatewaySenderQueue) this.getQueue())
-                    .getRegion(event.getRegionPath());
-              } else {
-                qpr =
-                    ((ParallelGatewaySenderQueue) this.getQueue()).getRegion(event.getRegionPath());
-              }
-              int bucketId = event.getBucketId();
-              // if the bucket from which the event has been picked is no longer
-              // primary, then set possibleDuplicate to true on the event
-              if (qpr != null) {
-                BucketRegion bucket = qpr.getDataStore().getLocalBucketById(bucketId);
-                if (bucket == null || !bucket.getBucketAdvisor().isPrimary()) {
-                  event.setPossibleDuplicate(true);
+                boolean transmit = filter.beforeTransmit(event);
+                if (!transmit) {
-                    logger.debug(
-                        "Bucket id: {} is no longer primary on this node. The event: {} will be dispatched from this node with possibleDuplicate set to true.",
-                        bucketId, event);
+                    logger.debug("{}: Did not transmit event due to filtering: {}", sender.getId(),
+                        event);
+                  }
+                  itr.remove();
+                  statistics.incEventsFiltered();
+                }
+              }
+            }
+            /*
+             * if (filteredList.isEmpty()) { eventQueueRemove(events.size()); continue; }
+             */
+
+            // if the bucket becomes secondary after the event is picked from it,
+            // check again before dispatching the event. Do this only for
+            // AsyncEventQueue since possibleDuplicate flag is not used in WAN.
+            if (this.getSender().isParallel()
+                && (this.getDispatcher() instanceof GatewaySenderEventCallbackDispatcher)) {
+              Iterator<GatewaySenderEventImpl> itr = filteredList.iterator();
+              while (itr.hasNext()) {
+                GatewaySenderEventImpl event = (GatewaySenderEventImpl) itr.next();
+                PartitionedRegion qpr = null;
+                if (this.getQueue() instanceof ConcurrentParallelGatewaySenderQueue) {
+                  qpr = ((ConcurrentParallelGatewaySenderQueue) this.getQueue())
+                      .getRegion(event.getRegionPath());
+                } else {
+                  qpr = ((ParallelGatewaySenderQueue) this.getQueue())
+                      .getRegion(event.getRegionPath());
+                }
+                int bucketId = event.getBucketId();
+                // if the bucket from which the event has been picked is no longer
+                // primary, then set possibleDuplicate to true on the event
+                if (qpr != null) {
+                  BucketRegion bucket = qpr.getDataStore().getLocalBucketById(bucketId);
+                  if (bucket == null || !bucket.getBucketAdvisor().isPrimary()) {
+                    event.setPossibleDuplicate(true);
+                    if (isDebugEnabled) {
+                      logger.debug(
+                          "Bucket id: {} is no longer primary on this node. The event: {} will be dispatched from this node with possibleDuplicate set to true.",
+                          bucketId, event);
+                    }
-          }
-          eventsToBeDispatched.clear();
-          if (!(this.dispatcher instanceof GatewaySenderEventCallbackDispatcher)) {
-            // store the batch before dispatching so it can be retrieved by the ack thread.
-            List<GatewaySenderEventImpl>[] eventsArr = (List<GatewaySenderEventImpl>[]) new List[2];
-            eventsArr[0] = events;
-            eventsArr[1] = filteredList;
-            this.batchIdToEventsMap.put(getBatchId(), eventsArr);
-            // find out PDX event and append it in front of the list
-            pdxEventsToBeDispatched = addPDXEvent();
-            eventsToBeDispatched.addAll(pdxEventsToBeDispatched);
-            if (!pdxEventsToBeDispatched.isEmpty()) {
-              this.batchIdToPDXEventsMap.put(getBatchId(), pdxEventsToBeDispatched);
+            eventsToBeDispatched.clear();
+            if (!(this.dispatcher instanceof GatewaySenderEventCallbackDispatcher)) {
+              // store the batch before dispatching so it can be retrieved by the ack thread.
+              List<GatewaySenderEventImpl>[] eventsArr =
+                  (List<GatewaySenderEventImpl>[]) new List[2];
+              eventsArr[0] = events;
+              eventsArr[1] = filteredList;
+              this.batchIdToEventsMap.put(getBatchId(), eventsArr);
+              // find out PDX event and append it in front of the list
+              pdxEventsToBeDispatched = addPDXEvent();
+              eventsToBeDispatched.addAll(pdxEventsToBeDispatched);
+              if (!pdxEventsToBeDispatched.isEmpty()) {
+                this.batchIdToPDXEventsMap.put(getBatchId(), pdxEventsToBeDispatched);
+              }
-          }
-          eventsToBeDispatched.addAll(filteredList);
+            eventsToBeDispatched.addAll(filteredList);
-          // Conflate the batch. Event conflation only occurs on the queue.
-          // Once an event has been peeked into a batch, it won't be
-          // conflated. So if events go through the queue quickly (as in the
-          // no-ack case), then multiple events for the same key may end up in
-          // the batch.
-          List conflatedEventsToBeDispatched = conflate(eventsToBeDispatched);
+            // Conflate the batch. Event conflation only occurs on the queue.
+            // Once an event has been peeked into a batch, it won't be
+            // conflated. So if events go through the queue quickly (as in the
+            // no-ack case), then multiple events for the same key may end up in
+            // the batch.
+            List conflatedEventsToBeDispatched = conflate(eventsToBeDispatched);
-          if (isDebugEnabled) {
-            logBatchFine("During normal processing, dispatching the following ",
-                conflatedEventsToBeDispatched);
-          }
-
-          boolean success = this.dispatcher.dispatchBatch(conflatedEventsToBeDispatched,
-              sender.isRemoveFromQueueOnException(), false);
-          if (success) {
-              logger.debug(
-                  "During normal processing, successfully dispatched {} events (batch #{})",
-                  conflatedEventsToBeDispatched.size(), getBatchId());
+              logBatchFine("During normal processing, dispatching the following ",
+                  conflatedEventsToBeDispatched);
-            removeEventFromFailureMap(getBatchId());
-          } else {
-            if (!skipFailureLogging(getBatchId())) {
-              logger.warn(
-                  LocalizedMessage.create(LocalizedStrings.GatewayImpl_EVENT_QUEUE_DISPATCH_FAILED,
-                      new Object[] {filteredList.size(), getBatchId()}));
-            }
-          }
-          // check again, don't do post-processing if we're stopped.
-          if (stopped()) {
-            break;
-          }
-          // If the batch is successfully processed, remove it from the queue.
-          if (success) {
-            if (this.dispatcher instanceof GatewaySenderEventCallbackDispatcher) {
-              handleSuccessfulBatchDispatch(conflatedEventsToBeDispatched, events);
+            boolean success = this.dispatcher.dispatchBatch(conflatedEventsToBeDispatched,
+                sender.isRemoveFromQueueOnException(), false);
+            if (success) {
+              if (isDebugEnabled) {
+                logger.debug(
+                    "During normal processing, successfully dispatched {} events (batch #{})",
+                    conflatedEventsToBeDispatched.size(), getBatchId());
+              }
+              removeEventFromFailureMap(getBatchId());
-              incrementBatchId();
+              if (!skipFailureLogging(getBatchId())) {
+                logger.warn(LocalizedMessage.create(
+                    LocalizedStrings.GatewayImpl_EVENT_QUEUE_DISPATCH_FAILED,
+                    new Object[] {filteredList.size(), getBatchId()}));
+              }
+            }
+            // check again, don't do post-processing if we're stopped.
+            if (stopped()) {
+              break;
-            // pdx related gateway sender events needs to be updated for
-            // isDispatched
-            for (GatewaySenderEventImpl pdxGatewaySenderEvent : pdxEventsToBeDispatched) {
-              pdxGatewaySenderEvent.isDispatched = true;
-            }
-
-            increaseNumEventsDispatched(conflatedEventsToBeDispatched.size());
-          } // successful batch
-          else { // The batch was unsuccessful.
-            if (this.dispatcher instanceof GatewaySenderEventCallbackDispatcher) {
-              handleUnSuccessfulBatchDispatch(events);
-              this.resetLastPeekedEvents = true;
-            } else {
-              handleUnSuccessfulBatchDispatch(events);
-              if (!resetLastPeekedEvents) {
-                while (!this.dispatcher.dispatchBatch(conflatedEventsToBeDispatched,
-                    sender.isRemoveFromQueueOnException(), true)) {
-                  if (isDebugEnabled) {
-                    logger.debug(
-                        "During normal processing, unsuccessfully dispatched {} events (batch #{})",
-                        conflatedEventsToBeDispatched.size(), getBatchId());
-                  }
-                  if (stopped() || resetLastPeekedEvents) {
-                    break;
-                  }
-                  try {
-                    Thread.sleep(100);
-                  } catch (InterruptedException ie) {
-                    Thread.currentThread().interrupt();
-                  }
-                }
+            // If the batch is successfully processed, remove it from the queue.
+            if (success) {
+              if (this.dispatcher instanceof GatewaySenderEventCallbackDispatcher) {
+                handleSuccessfulBatchDispatch(conflatedEventsToBeDispatched, events);
+              } else {
+
+              // pdx related gateway sender events needs to be updated for
+              // isDispatched
+              for (GatewaySenderEventImpl pdxGatewaySenderEvent : pdxEventsToBeDispatched) {
+                pdxGatewaySenderEvent.isDispatched = true;
+              }
+
+              increaseNumEventsDispatched(conflatedEventsToBeDispatched.size());
+            } // successful batch
+            else { // The batch was unsuccessful.
+              if (this.dispatcher instanceof GatewaySenderEventCallbackDispatcher) {
+                handleUnSuccessfulBatchDispatch(events);
+                this.resetLastPeekedEvents = true;
+              } else {
+                handleUnSuccessfulBatchDispatch(events);
+                if (!resetLastPeekedEvents) {
+                  while (!this.dispatcher.dispatchBatch(conflatedEventsToBeDispatched,
+                      sender.isRemoveFromQueueOnException(), true)) {
+                    if (isDebugEnabled) {
+                      logger.debug(
+                          "During normal processing, unsuccessfully dispatched {} events (batch #{})",
+                          conflatedEventsToBeDispatched.size(), getBatchId());
+                    }
+                    if (stopped() || resetLastPeekedEvents) {
+                      break;
+                    }
+                    try {
+                      Thread.sleep(100);
+                    } catch (InterruptedException ie) {
+                      Thread.currentThread().interrupt();
+                    }
+                  }
+                  incrementBatchId();
+                }
+              }
+            } // unsuccessful batch
+            if (logger.isDebugEnabled()) {
+              logger.debug("Finished processing events (batch #{})", (getBatchId() - 1));
-          } // unsuccessful batch
-          if (logger.isDebugEnabled()) {
-            logger.debug("Finished processing events (batch #{})", (getBatchId() - 1));
+          } finally {
+            afterExecute();
+  protected void beforeExecute() {
+    if (this.threadMonitoring != null) {
+      threadMonitoring.startMonitor(ThreadsMonitoring.Mode.AGSExecutor);
+    }
+  }
+
+  protected void afterExecute() {
+    if (this.threadMonitoring != null) {
+      threadMonitoring.endMonitor();
+    }
+  }
+

INS26 INS40 INS23 INS31 INS31 INS83 INS83 INS43 INS59 INS44 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS42 INS42 INS43 INS42 INS21 INS25 INS25 INS42 INS7 INS27 INS8 INS27 INS8 INS22 INS42 INS22 INS33 INS21 INS22 INS33 INS21 INS52 INS42 INS52 INS42 INS32 INS52 INS42 INS32 INS42 INS42 INS40 INS42 INS42 INS21 INS54 INS32 INS8 INS8 INS42 MOV21 MOV21 MOV25 MOV70 MOV25 MOV21 MOV25 MOV21 MOV60 MOV25 MOV60 MOV25 MOV25 MOV25 MOV25 INS21 INS32 INS42
GEODE-6918: Cleanup PRHARedundancyProvider and PRHARedundancyProviderTest (#3779)

* Cleanup recommendations found in review
* Use constructor injection
* Use MockitoRule and STRICT_STUBS
* Improve field and variable names
* Improve overall consistency, formatting, and comments

Co-authored-by: Aaron Lindsey <alindsey@pivotal.io>

+import static java.lang.String.format;
+import static java.util.Collections.emptyList;
+import static org.apache.geode.internal.cache.ColocationHelper.checkMembersColocation;
+import static org.apache.geode.internal.cache.PartitionedRegionHelper.printCollection;
+import java.util.function.BiFunction;
+import org.apache.geode.annotations.VisibleForTesting;
- * <pre>
- * (1) Redundancy Management at the time of bucket creation.
- * (2) Redundancy management at the new node arrival.
- * (3) Redundancy management when the node leaves the partitioned region distributed system
+ * <ol>
+ * <li>Redundancy management at the time of bucket creation.
+ * <li>Redundancy management at the new node arrival.
+ * <li>Redundancy management when the node leaves the partitioned region distributed system
- * (4) Redundancy management at random node failure.
- * </pre>
+ * <li>Redundancy management at random node failure.
+ * </ol>
-  private final PartitionedRegion prRegion;
+  private final PartitionedRegion partitionedRegion;
+  private final BiFunction<PRHARedundancyProvider, Integer, PersistentBucketRecoverer> persistentBucketRecovererFunction;
+
+
-   * @param region The PartitionedRegion for which the HA redundancy is required to be managed.
+   * @param partitionedRegion The PartitionedRegion for which the HA redundancy is required to be
+   *        managed.
-  public PRHARedundancyProvider(final PartitionedRegion region) {
-    prRegion = region;
-    final InternalResourceManager resourceManager =
-        region.getGemFireCache().getInternalResourceManager();
+  public PRHARedundancyProvider(PartitionedRegion partitionedRegion,
+      InternalResourceManager resourceManager) {
+    this(partitionedRegion, resourceManager, PersistentBucketRecoverer::new);
+  }
+
+  @VisibleForTesting
+  PRHARedundancyProvider(PartitionedRegion partitionedRegion,
+      InternalResourceManager resourceManager,
+      BiFunction<PRHARedundancyProvider, Integer, PersistentBucketRecoverer> persistentBucketRecovererFunction) {
+    this.partitionedRegion = partitionedRegion;
-        () -> InternalResourceManager.getResourceObserver().recoveryConflated(region),
+        () -> InternalResourceManager.getResourceObserver().recoveryConflated(partitionedRegion),
+    this.persistentBucketRecovererFunction = persistentBucketRecovererFunction;
-   * @param prRegion the given region
+   * @param partitionedRegion the given region
-  private static String regionStatus(PartitionedRegion prRegion,
+  private static String regionStatus(PartitionedRegion partitionedRegion,
+    String newLine = forLog ? " " : lineSeparator();
+    String spaces = forLog ? "" : "   ";
+
-    sb.append("Partitioned Region name = ").append(prRegion.getFullPath());
-    final String newLine;
-    final String spaces;
-    if (forLog) {
-      newLine = " ";
-      spaces = "";
-    } else {
-      newLine = lineSeparator();
-      spaces = "   ";
-    }
+    sb.append("Partitioned Region name = ");
+    sb.append(partitionedRegion.getFullPath());
+
-      sb.append(newLine).append(spaces).append("Redundancy level set to ")
-          .append(prRegion.getRedundantCopies());
-      sb.append(newLine).append(". Number of available data stores: ").append(allStores.size());
-      sb.append(newLine).append(spaces).append(". Number successfully allocated = ")
-          .append(alreadyUsed.size());
-      sb.append(newLine).append(". Data stores: ")
-          .append(PartitionedRegionHelper.printCollection(allStores));
-      sb.append(newLine).append(". Data stores successfully allocated: ")
-          .append(PartitionedRegionHelper.printCollection(alreadyUsed));
-      sb.append(newLine).append(". Equivalent members: ").append(PartitionedRegionHelper
-          .printCollection(prRegion
-              .getDistributionManager()
-              .getMembersInThisZone()));
+      sb.append(newLine).append(spaces);
+      sb.append("Redundancy level set to ");
+      sb.append(partitionedRegion.getRedundantCopies());
+      sb.append(newLine);
+      sb.append(". Number of available data stores: ");
+      sb.append(allStores.size());
+      sb.append(newLine).append(spaces);
+      sb.append(". Number successfully allocated = ");
+      sb.append(alreadyUsed.size());
+      sb.append(newLine);
+      sb.append(". Data stores: ");
+      sb.append(printCollection(allStores));
+      sb.append(newLine);
+      sb.append(". Data stores successfully allocated: ");
+      sb.append(printCollection(alreadyUsed));
+      sb.append(newLine);
+      sb.append(". Equivalent members: ");
+      sb.append(printCollection(partitionedRegion.getDistributionManager().getMembersInThisZone()));
+
-  public static void timedOut(PartitionedRegion prRegion, Set<InternalDistributedMember> allStores,
-      Collection<InternalDistributedMember> alreadyUsed,
-      String opString, long timeOut) {
-    final String tooManyRetries =
-        String.format("Timed out attempting to %s in the partitioned region.%sWaited for: %s ms.",
-            opString,
-            regionStatus(prRegion, allStores, alreadyUsed, true), timeOut)
-            + TIMEOUT_MSG;
-    throw new PartitionedRegionStorageException(tooManyRetries);
+  public static void timedOut(PartitionedRegion partitionedRegion,
+      Set<InternalDistributedMember> allStores,
+      Collection<InternalDistributedMember> alreadyUsed, String opString, long timeOut) {
+    throw new PartitionedRegionStorageException(
+        format("Timed out attempting to %s in the partitioned region.%sWaited for: %s ms.",
+            opString, regionStatus(partitionedRegion, allStores, alreadyUsed, true), timeOut)
+            + TIMEOUT_MSG);
-    return prRegion;
+    return partitionedRegion;
-
-        prRegion.getRegionAdvisor().adviseDataStore(true);
-    PartitionedRegionDataStore myDS = prRegion.getDataStore();
-    if (myDS != null) {
-      allStores.add(prRegion.getDistributionManager().getId());
+        partitionedRegion.getRegionAdvisor().adviseDataStore(true);
+    PartitionedRegionDataStore localDataStore = partitionedRegion.getDataStore();
+    if (localDataStore != null) {
+      allStores.add(partitionedRegion.getDistributionManager().getId());
-        prRegion.getRegionAdvisor().adviseFixedPartitionDataStores(partitionName);
+        partitionedRegion.getRegionAdvisor().adviseFixedPartitionDataStores(partitionName);
-    List<FixedPartitionAttributesImpl> FPAs = prRegion.getFixedPartitionAttributesImpl();
+    List<FixedPartitionAttributesImpl> allFixedPartitionAttributes =
+        partitionedRegion.getFixedPartitionAttributesImpl();
-    if (FPAs != null) {
-      for (FixedPartitionAttributesImpl fpa : FPAs) {
-        if (fpa.getPartitionName().equals(partitionName)) {
-          members.add(prRegion.getMyId());
+    if (allFixedPartitionAttributes != null) {
+      for (FixedPartitionAttributesImpl fixedPartitionAttributes : allFixedPartitionAttributes) {
+        if (fixedPartitionAttributes.getPartitionName().equals(partitionName)) {
+          members.add(partitionedRegion.getMyId());
-    final String regionStat = regionStatus(prRegion, allStores, alreadyUsed, onlyLog);
-    final String newLine;
+    String regionStat = regionStatus(partitionedRegion, allStores, alreadyUsed, onlyLog);
+    String newLine = onlyLog ? " " : lineSeparator();
+    String notEnoughValidNodes = alreadyUsed.isEmpty()
+        ? "Unable to find any members to host a bucket in the partitioned region. %s.%s"
+        : "Configured redundancy level could not be satisfied. %s to satisfy redundancy for the region.%s";
-      newLine = " ";
-    } else {
-      newLine = lineSeparator();
-    }
-    final String notEnoughValidNodes;
-    if (alreadyUsed.isEmpty()) {
-      notEnoughValidNodes =
-          "Unable to find any members to host a bucket in the partitioned region. %s.%s";
-    } else {
-      notEnoughValidNodes =
-          "Configured redundancy level could not be satisfied. %s to satisfy redundancy for the region.%s";
-    }
-    final Object[] notEnoughValidNodesArgs = new Object[] {
-        INSUFFICIENT_STORES_MSG, newLine + regionStat + newLine};
-    if (onlyLog) {
-      logger.warn(String.format(notEnoughValidNodes, notEnoughValidNodesArgs));
+      logger.warn(format(notEnoughValidNodes, INSUFFICIENT_STORES_MSG,
+          newLine + regionStat + newLine));
-          String.format(notEnoughValidNodes, notEnoughValidNodesArgs));
+          format(notEnoughValidNodes, INSUFFICIENT_STORES_MSG, newLine + regionStat + newLine));
-  private InternalDistributedMember createBucketInstance(int bucketId, final int newBucketSize,
-      final Collection<InternalDistributedMember> excludedMembers,
+  private InternalDistributedMember createBucketInstance(int bucketId, int newBucketSize,
+      Collection<InternalDistributedMember> excludedMembers,
-      ArrayListWithClearState<InternalDistributedMember> failedMembers, final long timeOut,
-      final Set<InternalDistributedMember> allStores) {
+      ArrayListWithClearState<InternalDistributedMember> failedMembers, long timeOut,
+      Set<InternalDistributedMember> allStores) {
-    final boolean isDebugEnabled = logger.isDebugEnabled();
+    boolean isDebugEnabled = logger.isDebugEnabled();
+
-      prRegion.checkReadiness();
+      partitionedRegion.checkReadiness();
-    // In case of FPR, candidateMembers is the set of members on which
+    // In case of FixedPartitionedRegion, candidateMembers is the set of members on which
-    if (prRegion.isFixedPartitionedRegion()) {
+    if (partitionedRegion.isFixedPartitionedRegion()) {
-      String prName = prRegion.getAttributes().getPartitionAttributes().getColocatedWith();
-      if (prName != null) {
-        candidate = getColocatedDataStore(candidateMembers, alreadyUsed, bucketId, prName);
+      String colocatedWith =
+          partitionedRegion.getAttributes().getPartitionAttributes().getColocatedWith();
+      if (colocatedWith != null) {
+        candidate = getColocatedDataStore(candidateMembers, alreadyUsed, bucketId, colocatedWith);
-        final Collection<InternalDistributedMember> orderedCandidates =
-            new ArrayList<>(candidateMembers);
+        Collection<InternalDistributedMember> orderedCandidates = new ArrayList<>(candidateMembers);
-    if (!prRegion.isShadowPR()
-        && !ColocationHelper.checkMembersColocation(prRegion, candidate)) {
+    if (!partitionedRegion.isShadowPR() && !checkMembersColocation(partitionedRegion, candidate)) {
-            "createBucketInstances - Member does not have all of the regions colocated with prRegion {}",
+            "createBucketInstances - Member does not have all of the regions colocated with partitionedRegion {}",
-    if (!candidate.equals(prRegion.getMyId())) {
-      PartitionProfile pp = prRegion.getRegionAdvisor().getPartitionProfile(candidate);
-      if (pp == null) {
+    if (!candidate.equals(partitionedRegion.getMyId())) {
+      PartitionProfile profile =
+          partitionedRegion.getRegionAdvisor().getPartitionProfile(candidate);
+      if (profile == null) {
-              prRegion.getFullPath(), candidate);
+              partitionedRegion.getFullPath(), candidate);
-    final ManageBucketRsp response =
+    ManageBucketRsp response =
-          prRegion.getFullPath(), candidate, prRegion.bucketStringForLogs(bucketId),
+          partitionedRegion.getFullPath(), candidate,
+          partitionedRegion.bucketStringForLogs(bucketId),
-      RetryTimeKeeper snoozer) {
-    InternalDistributedMember primaryForFixedPartition = null;
-    if (prRegion.isFixedPartitionedRegion()) {
-      primaryForFixedPartition =
-          prRegion.getRegionAdvisor().adviseFixedPrimaryPartitionDataStore(bucketId);
-    }
-    final boolean isDebugEnabled = logger.isDebugEnabled();
+      RetryTimeKeeper retryTimeKeeper) {
+    boolean isDebugEnabled = logger.isDebugEnabled();
-    InternalDistributedMember ret;
+    InternalDistributedMember primaryForFixedPartition = null;
+    if (partitionedRegion.isFixedPartitionedRegion()) {
+      primaryForFixedPartition =
+          partitionedRegion.getRegionAdvisor().adviseFixedPrimaryPartitionDataStore(bucketId);
+    }
+
+    InternalDistributedMember memberHostingBucket;
-      prRegion.checkReadiness();
+      partitionedRegion.checkReadiness();
-          prRegion.getRegionAdvisor().adviseInitializedDataStore();
+          partitionedRegion.getRegionAdvisor().adviseInitializedDataStore();
-      InternalDistributedMember target = null;
+      InternalDistributedMember targetMember = null;
-          target = primaryForFixedPartition;
+          targetMember = primaryForFixedPartition;
-          target = member;
+          targetMember = member;
-      if (target == null) {
+      if (targetMember == null) {
-          logger.debug("Attempting to get data store {} to create the bucket {} for us", target,
-              prRegion.bucketStringForLogs(bucketId));
+          logger.debug("Attempting to get data store {} to create the bucket {} for us",
+              targetMember,
+              partitionedRegion.bucketStringForLogs(bucketId));
-            CreateBucketMessage.send(target, prRegion, bucketId, size);
-        ret = response.waitForResponse();
-        if (ret != null) {
-          return ret;
+            CreateBucketMessage.send(targetMember, partitionedRegion, bucketId, size);
+        memberHostingBucket = response.waitForResponse();
+        if (memberHostingBucket != null) {
+          return memberHostingBucket;
-      attempted.add(target);
-    } while ((ret = prRegion.getNodeForBucketWrite(bucketId, snoozer)) == null);
-    return ret;
+      attempted.add(targetMember);
+    } while ((memberHostingBucket =
+        partitionedRegion.getNodeForBucketWrite(bucketId, retryTimeKeeper)) == null);
+    return memberHostingBucket;
-  public InternalDistributedMember createBucketAtomically(final int bucketId,
-      final int newBucketSize, final boolean finishIncompleteCreation, String partitionName)
+  public InternalDistributedMember createBucketAtomically(int bucketId, int newBucketSize,
+      boolean finishIncompleteCreation, String partitionName)
-    final boolean isDebugEnabled = logger.isDebugEnabled();
+    boolean isDebugEnabled = logger.isDebugEnabled();
-    prRegion.checkPROffline();
+    partitionedRegion.checkPROffline();
-      if (prRegion.getCache().isCacheAtShutdownAll()) {
-        throw prRegion.getCache().getCacheClosedException("Cache is shutting down");
+      if (partitionedRegion.getCache().isCacheAtShutdownAll()) {
+        throw partitionedRegion.getCache().getCacheClosedException("Cache is shutting down");
-            prRegion.bucketStringForLogs(bucketId));
+            partitionedRegion.bucketStringForLogs(bucketId));
-      final long timeOut = System.currentTimeMillis() + computeTimeout();
+
+      long timeOut = System.currentTimeMillis() + computeTimeout();
-      try {
-        prRegion.checkReadiness();
-        Bucket toCreate = prRegion.getRegionAdvisor().getBucket(bucketId);
+      try {
+        partitionedRegion.checkReadiness();
+
+        Bucket toCreate = partitionedRegion.getRegionAdvisor().getBucket(bucketId);
-          bucketPrimary = prRegion.getBucketPrimary(bucketId);
+          bucketPrimary = partitionedRegion.getBucketPrimary(bucketId);
-        // detected
+
-          prRegion.checkReadiness();
-          if (prRegion.getCache().isCacheAtShutdownAll()) {
+          partitionedRegion.checkReadiness();
+          if (partitionedRegion.getCache().isCacheAtShutdownAll()) {
-            throw prRegion.getCache().getCacheClosedException("Cache is shutting down");
+            throw partitionedRegion.getCache().getCacheClosedException("Cache is shutting down");
-            timedOut(prRegion, getAllStores(partitionName), acceptedMembers,
+            timedOut(partitionedRegion, getAllStores(partitionName), acceptedMembers,
+
-            if (prRegion.getDistributionManager().enforceUniqueZone()) {
+            if (partitionedRegion.getDistributionManager().enforceUniqueZone()) {
-              if (!(prRegion.getDistributionManager() instanceof LonerDistributionManager)) {
+              if (!(partitionedRegion
+                  .getDistributionManager() instanceof LonerDistributionManager)) {
-          acceptedMembers = prRegion.getRegionAdvisor().getBucketOwners(bucketId);
+          acceptedMembers = partitionedRegion.getRegionAdvisor().getBucketOwners(bucketId);
-          final int potentialCandidateCount = allStores.size()
+          int potentialCandidateCount = allStores.size()
+
-          final boolean exhaustedPotentialCandidates =
+          boolean exhaustedPotentialCandidates =
-          final boolean redundancySatisfied =
-              acceptedMembers.size() > prRegion.getRedundantCopies();
-          final boolean bucketNotCreated = acceptedMembers.isEmpty();
+          boolean redundancySatisfied =
+              acceptedMembers.size() > partitionedRegion.getRedundantCopies();
+          boolean bucketNotCreated = acceptedMembers.isEmpty();
-            final int expectedRemoteHosts = acceptedMembers.size()
-                - (acceptedMembers.contains(prRegion.getMyId()) ? 1 : 0);
+            int expectedRemoteHosts = acceptedMembers.size()
+                - (acceptedMembers.contains(partitionedRegion.getMyId()) ? 1 : 0);
+
-              prRegion.getCancelCriterion().checkCancelInProgress(e);
+              partitionedRegion.getCancelCriterion().checkCancelInProgress(e);
+
+
+
-            endBucketCreation(bucketId, prRegion.getRegionAdvisor().getBucketOwners(bucketId),
+            endBucketCreation(bucketId,
+                partitionedRegion.getRegionAdvisor().getBucketOwners(bucketId),
-                || prRegion.getCancelCriterion().isCancelInProgress()) {
+                || partitionedRegion.getCancelCriterion().isCancelInProgress()) {
-        targetPrimary = prRegion.getMyId();
+        targetPrimary = partitionedRegion.getMyId();
-            prRegion.getRegionAdvisor().adviseFixedPrimaryPartitionDataStore(bucketId);
+            partitionedRegion.getRegionAdvisor().adviseFixedPrimaryPartitionDataStore(bucketId);
+
-    boolean isHosting = acceptedMembers.remove(prRegion.getDistributionManager().getId());
-    EndBucketCreationMessage.send(acceptedMembers, targetPrimary, prRegion, bucketId);
+
+    boolean isHosting = acceptedMembers.remove(partitionedRegion.getDistributionManager().getId());
+
+    EndBucketCreationMessage.send(acceptedMembers, targetPrimary, partitionedRegion, bucketId);
-    List<FixedPartitionAttributesImpl> FPAs = prRegion.getFixedPartitionAttributesImpl();
-    if (FPAs != null) {
-      for (FixedPartitionAttributesImpl fpa : FPAs) {
-        if (fpa.getPartitionName().equals(partitionName) && fpa.isPrimary()) {
+    List<FixedPartitionAttributesImpl> allFixedPartitionAttributes =
+        partitionedRegion.getFixedPartitionAttributesImpl();
+    if (allFixedPartitionAttributes != null) {
+      for (FixedPartitionAttributesImpl fixedPartitionAttributes : allFixedPartitionAttributes) {
+        if (fixedPartitionAttributes.getPartitionName().equals(partitionName)
+            && fixedPartitionAttributes.isPrimary()) {
-    if (prRegion.getCancelCriterion().isCancelInProgress() || prRegion.isDestroyed()) {
+    if (partitionedRegion.getCancelCriterion().isCancelInProgress()
+        || partitionedRegion.isDestroyed()) {
-          prRegion.getFullPath(), bucketId, newPrimary);
+          partitionedRegion.getFullPath(), bucketId, newPrimary);
-    BucketAdvisor bucketAdvisor = prRegion.getRegionAdvisor().getBucketAdvisor(bucketId);
-    final ProxyBucketRegion proxyBucketRegion = bucketAdvisor.getProxyBucketRegion();
+    BucketAdvisor bucketAdvisor = partitionedRegion.getRegionAdvisor().getBucketAdvisor(bucketId);
+    ProxyBucketRegion proxyBucketRegion = bucketAdvisor.getProxyBucketRegion();
-          PersistentMemberID persistentID = realBucket.getPersistentID();
-          persistentAdvisor.endBucketCreation(persistentID);
+          PersistentMemberID persistentId = realBucket.getPersistentID();
+          persistentAdvisor.endBucketCreation(persistentId);
-      if (prRegion.getGemFireCache().getMyId().equals(newPrimary)) {
+      if (partitionedRegion.getGemFireCache().getMyId().equals(newPrimary)) {
-    List<PartitionedRegion> colocatedWithList = ColocationHelper.getColocatedChildRegions(prRegion);
+    List<PartitionedRegion> colocatedWithList = ColocationHelper.getColocatedChildRegions(
+        partitionedRegion);
-      final InternalDistributedMember acceptedMember,
-      final Collection<InternalDistributedMember> allStores) {
-
-    DistributionManager dm = prRegion.getDistributionManager();
+      InternalDistributedMember acceptedMember, Collection<InternalDistributedMember> allStores) {
+    DistributionManager dm = partitionedRegion.getDistributionManager();
-        insufficientStores(currentStores, Collections.emptyList(), true);
+        insufficientStores(currentStores, emptyList(), true);
-      insufficientStores(currentStores, Collections.emptyList(), false);
+      insufficientStores(currentStores, emptyList(), false);
-    return prRegion.getRetryTimeout();
+    return partitionedRegion.getRetryTimeout();
-  private boolean checkSufficientStores(final Set<InternalDistributedMember> allStores,
-      final boolean loggedInsufficientStores) {
+  private boolean checkSufficientStores(Set<InternalDistributedMember> allStores,
+      boolean loggedInsufficientStores) {
-        insufficientStores(allStores, Collections.emptyList(), true);
+        insufficientStores(allStores, emptyList(), true);
-        final String logStr = "{} Region name, {}";
-        logger.info(logStr, SUFFICIENT_STORES_MSG, prRegion.getFullPath());
+        logger.info("{} Region name, {}", SUFFICIENT_STORES_MSG, partitionedRegion.getFullPath());
-      insufficientStores(allStores, Collections.emptyList(), false);
+      insufficientStores(allStores, emptyList(), false);
-   * @param buck the bucket identifier
+   * @param bucketId the bucket identifier
-  private void cleanUpBucket(int buck) {
-    Set<InternalDistributedMember> dataStores = prRegion.getRegionAdvisor().adviseDataStore();
-    BucketBackupMessage.send(dataStores, prRegion, buck);
+  private void cleanUpBucket(int bucketId) {
+    Set<InternalDistributedMember> dataStores =
+        partitionedRegion.getRegionAdvisor().adviseDataStore();
+    BucketBackupMessage.send(dataStores, partitionedRegion, bucketId);
-    if (prRegion.isFixedPartitionedRegion()) {
+    if (partitionedRegion.isFixedPartitionedRegion()) {
-          PartitionedRegionHelper.getFixedPartitionAttributesForBucket(prRegion, bucketId);
+          PartitionedRegionHelper.getFixedPartitionAttributesForBucket(partitionedRegion, bucketId);
-  public boolean createBackupBucketOnMember(final int bucketId,
-      final InternalDistributedMember targetNMember, final boolean isRebalance,
-      boolean replaceOfflineData, InternalDistributedMember moveSource, boolean forceCreation) {
+  public boolean createBackupBucketOnMember(int bucketId, InternalDistributedMember targetMember,
+      boolean isRebalance, boolean replaceOfflineData, InternalDistributedMember fromMember,
+      boolean forceCreation) {
-          prRegion.bucketStringForLogs(bucketId), targetNMember);
+          partitionedRegion.bucketStringForLogs(bucketId), targetMember);
-    if (!targetNMember.equals(prRegion.getMyId())) {
-      PartitionProfile pp = prRegion.getRegionAdvisor().getPartitionProfile(targetNMember);
-      if (pp == null) {
+    if (!targetMember.equals(partitionedRegion.getMyId())) {
+      PartitionProfile profile =
+          partitionedRegion.getRegionAdvisor().getPartitionProfile(targetMember);
+      if (profile == null) {
-            ManageBackupBucketMessage.send(targetNMember, prRegion, bucketId, isRebalance,
-                replaceOfflineData, moveSource, forceCreation);
+            ManageBackupBucketMessage.send(targetMember, partitionedRegion, bucketId, isRebalance,
+                replaceOfflineData, fromMember, forceCreation);
-                prRegion.bucketStringForLogs(bucketId), targetNMember);
+                partitionedRegion.bucketStringForLogs(bucketId), targetMember);
+
-              prRegion.bucketStringForLogs(bucketId), targetNMember);
+              partitionedRegion.bucketStringForLogs(bucketId), targetMember);
+
-          logger.warn("Exception creating partition on {}", targetNMember, e);
+          logger.warn("Exception creating partition on {}", targetMember, e);
-    final PartitionedRegionDataStore prDS = prRegion.getDataStore();
-    boolean bucketManaged = prDS != null && prDS.grabBucket(bucketId, moveSource, forceCreation,
-        replaceOfflineData, isRebalance, null, false).equals(CreateBucketResult.CREATED);
+
+    PartitionedRegionDataStore dataStore = partitionedRegion.getDataStore();
+    boolean bucketManaged =
+        dataStore != null && dataStore.grabBucket(bucketId, fromMember, forceCreation,
+            replaceOfflineData, isRebalance, null, false).equals(CreateBucketResult.CREATED);
-            "createBackupBucketOnMember: Local data store refused to accommodate the data for bucketId={} prDS={}",
-            prRegion.bucketStringForLogs(bucketId), prDS);
+            "createBackupBucketOnMember: Local data store refused to accommodate the data for bucketId={} dataStore={}",
+            partitionedRegion.bucketStringForLogs(bucketId), dataStore);
-    Boolean v = forceLocalPrimaries.get();
-    if (v != null) {
-      result = v;
+    Boolean forceLocalPrimariesValue = forceLocalPrimaries.get();
+    if (forceLocalPrimariesValue != null) {
+      result = forceLocalPrimariesValue;
-  private ManageBucketRsp createBucketOnMember(final int bucketId,
-      final InternalDistributedMember targetNMember, final int newBucketSize,
-      boolean forceCreation) {
+  private ManageBucketRsp createBucketOnMember(int bucketId, InternalDistributedMember targetMember,
+      int newBucketSize, boolean forceCreation) {
-          prRegion.bucketStringForLogs(bucketId), targetNMember,
+          partitionedRegion.bucketStringForLogs(bucketId), targetMember,
-    if (!targetNMember.equals(prRegion.getMyId())) {
-      PartitionProfile pp = prRegion.getRegionAdvisor().getPartitionProfile(targetNMember);
-      if (pp == null) {
+    if (!targetMember.equals(partitionedRegion.getMyId())) {
+      PartitionProfile profile =
+          partitionedRegion.getRegionAdvisor().getPartitionProfile(targetMember);
+      if (profile == null) {
-        NodeResponse response = ManageBucketMessage.send(targetNMember, prRegion, bucketId,
+        NodeResponse response = ManageBucketMessage.send(targetMember, partitionedRegion, bucketId,
-                prRegion.bucketStringForLogs(bucketId), targetNMember);
+                partitionedRegion.bucketStringForLogs(bucketId), targetMember);
+
-              prRegion.bucketStringForLogs(bucketId), targetNMember);
+              partitionedRegion.bucketStringForLogs(bucketId), targetMember);
+
-          logger.warn("Exception creating partition on " +
-              targetNMember,
-              e);
+          logger.warn("Exception creating partition on {}", targetMember, e);
-    final PartitionedRegionDataStore prDS = prRegion.getDataStore();
-    boolean bucketManaged = prDS != null && prDS.handleManageBucketRequest(bucketId,
-        newBucketSize, prRegion.getMyId(), forceCreation);
+
+    PartitionedRegionDataStore dataStore = partitionedRegion.getDataStore();
+    boolean bucketManaged = dataStore != null && dataStore.handleManageBucketRequest(bucketId,
+        newBucketSize, partitionedRegion.getMyId(), forceCreation);
-            prRegion.bucketStringForLogs(bucketId));
+            partitionedRegion.bucketStringForLogs(bucketId));
-    PartitionedRegion colocatedRegion = ColocationHelper.getColocatedRegion(prRegion);
-    Region<?, ?> prRoot = PartitionedRegionHelper.getPRRoot(prRegion.getCache());
+    PartitionedRegion colocatedRegion = ColocationHelper.getColocatedRegion(partitionedRegion);
+    Region<?, ?> prRoot = PartitionedRegionHelper.getPRRoot(partitionedRegion.getCache());
-        (PartitionRegionConfig) prRoot.get(prRegion.getRegionIdentifier());
+        (PartitionRegionConfig) prRoot.get(partitionedRegion.getRegionIdentifier());
+
+
+
-   * @param candidates ArrayList of InternalDistributedMember, potential datastores
+   * @param candidates collection of InternalDistributedMember, potential datastores
-      final Collection<InternalDistributedMember> alreadyUsed) {
+      Collection<InternalDistributedMember> alreadyUsed) {
-    final boolean forPrimary = alreadyUsed.isEmpty();
+    boolean forPrimary = alreadyUsed.isEmpty();
-      PartitionedRegionDataStore myDS = prRegion.getDataStore();
-      if (myDS != null) {
-        return prRegion.getMyId();
+      PartitionedRegionDataStore localDataStore = partitionedRegion.getDataStore();
+      if (localDataStore != null) {
+        return partitionedRegion.getMyId();
-    ArrayList<DataStoreBuckets> stores = prRegion.getRegionAdvisor()
+    List<DataStoreBuckets> stores = partitionedRegion.getRegionAdvisor()
-    final DistributionManager dm = prRegion.getDistributionManager();
+    DistributionManager dm = partitionedRegion.getDistributionManager();
+
-    InternalDistributedMember moi = dm.getId();
-    PartitionedRegionDataStore myDS = prRegion.getDataStore();
-    if (myDS != null && candidates.contains(moi)) {
-      int bucketCount = myDS.getBucketsManaged();
-      int priCount = myDS.getNumberOfPrimaryBucketsManaged();
-      int localMaxMemory = prRegion.getLocalMaxMemory();
-      stores.add(new DataStoreBuckets(moi, bucketCount, priCount, localMaxMemory));
+    InternalDistributedMember localMember = dm.getId();
+    PartitionedRegionDataStore localDataStore = partitionedRegion.getDataStore();
+    if (localDataStore != null && candidates.contains(localMember)) {
+      int bucketCount = localDataStore.getBucketsManaged();
+      int priCount = localDataStore.getNumberOfPrimaryBucketsManaged();
+      int localMaxMemory = partitionedRegion.getLocalMaxMemory();
+      stores.add(new DataStoreBuckets(localMember, bucketCount, priCount, localMaxMemory));
+
-    final Set<InternalDistributedMember> existingHosts = new HashSet<>();
+    Collection<InternalDistributedMember> existingHosts = new HashSet<>();
-      float metric1;
-      float metric2;
+      float load1;
+      float load2;
-        metric1 = d1.numPrimaries() / (float) d1.localMaxMemoryMB();
-        metric2 = d2.numPrimaries() / (float) d2.localMaxMemoryMB();
+        load1 = d1.numPrimaries() / (float) d1.localMaxMemoryMB();
+        load2 = d2.numPrimaries() / (float) d2.localMaxMemoryMB();
-        metric1 = d1.numBuckets() / (float) d1.localMaxMemoryMB();
-        metric2 = d2.numBuckets() / (float) d2.localMaxMemoryMB();
+        load1 = d1.numBuckets() / (float) d1.localMaxMemoryMB();
+        load2 = d2.numBuckets() / (float) d2.localMaxMemoryMB();
-      int result = Float.compare(metric1, metric2);
+
+      int result = Float.compare(load1, load2);
+
-    final boolean allStoresInUse = alreadyUsed.contains(bestDataStore.memberId());
+    boolean allStoresInUse = alreadyUsed.contains(bestDataStore.memberId());
+
-    DataStoreBuckets aDataStore = bestStores.get(chosen);
-    return aDataStore.memberId();
+
+    return bestStores.get(chosen).memberId();
-    prRegion.getRegionAdvisor().addMembershipListener(new PRMembershipListener());
+    partitionedRegion.getRegionAdvisor().addMembershipListener(new PRMembershipListener());
-    logStr.append("Bucket Allocation for prId=").append(prRegion.getPRId()).append(":").append(
-        lineSeparator());
+    logStr.append("Bucket Allocation for prId=").append(partitionedRegion.getPRId()).append(":");
+    logStr.append(lineSeparator());
+
-      DataStoreBuckets dsb = (DataStoreBuckets) dataStore;
-      logStr.append(dsb.memberId()).append(": ");
-      if (existingStores.contains(dsb.memberId())) {
+      DataStoreBuckets buckets = (DataStoreBuckets) dataStore;
+      logStr.append(buckets.memberId()).append(": ");
+      if (existingStores.contains(buckets.memberId())) {
-      logStr.append(dsb.numPrimaries());
+      logStr.append(buckets.numPrimaries());
-      logStr.append(dsb.numBuckets() - dsb.numPrimaries());
+      logStr.append(buckets.numBuckets() - buckets.numPrimaries());
-    final Set<InternalDistributedMember> availableMembers = getAllStores(partitionName);
+    Set<InternalDistributedMember> availableMembers = getAllStores(partitionName);
-    for (Iterator<InternalDistributedMember> itr = members.iterator(); itr.hasNext();) {
-      InternalDistributedMember node = itr.next();
+    for (Iterator<InternalDistributedMember> iterator = members.iterator(); iterator.hasNext();) {
+      InternalDistributedMember node = iterator.next();
-        itr.remove();
+        iterator.remove();
-    final boolean isStartup = failedMemberId == null;
-    final long delay;
-    final boolean movePrimaries;
+    boolean isStartup = failedMemberId == null;
+    long delay;
+    boolean movePrimaries;
-      delay = prRegion.getPartitionAttributes().getStartupRecoveryDelay();
+      delay = partitionedRegion.getPartitionAttributes().getStartupRecoveryDelay();
-      delay = prRegion.getPartitionAttributes().getRecoveryDelay();
+      delay = partitionedRegion.getPartitionAttributes().getRecoveryDelay();
+
-    if (!prRegion.isDataStore()) {
+    if (!partitionedRegion.isDataStore()) {
+
-          final boolean isFixedPartitionedRegion =
-              prRegion.isFixedPartitionedRegion();
+          boolean isFixedPartitionedRegion = partitionedRegion.isFixedPartitionedRegion();
-          final PartitionedRegionRebalanceOp rebalance = new PartitionedRegionRebalanceOp(
-              prRegion, false, director, replaceOfflineData, false);
+          PartitionedRegionRebalanceOp rebalance = new PartitionedRegionRebalanceOp(
+              partitionedRegion, false, director, replaceOfflineData, false);
-          long start = prRegion.getPrStats().startRecovery();
+          long start = partitionedRegion.getPrStats().startRecovery();
-          prRegion.getPrStats().endRecovery(start);
+          partitionedRegion.getPrStats().endRecovery(start);
-              logger.debug(prRegion + " scheduling redundancy recovery in {} ms", delay);
+              logger.debug("{} scheduling redundancy recovery in {} ms", partitionedRegion, delay);
-                  "prRegion scheduling redundancy recovery after departure/crash/error in {} in {} ms",
+                  "partitionedRegion scheduling redundancy recovery after departure/crash/error in {} in {} ms",
-    int numBuckets = prRegion.getPartitionAttributes().getTotalNumBuckets();
-    int targetRedundancy = prRegion.getPartitionAttributes().getRedundantCopies();
+    int numBuckets = partitionedRegion.getPartitionAttributes().getTotalNumBuckets();
+    int targetRedundancy = partitionedRegion.getPartitionAttributes().getRedundantCopies();
-      int redundancy = prRegion.getRegionAdvisor().getBucketRedundancy(i);
+      int redundancy = partitionedRegion.getRegionAdvisor().getBucketRedundancy(i);
-    PartitionedRegion leaderRegion = ColocationHelper.getLeaderRegion(prRegion);
+    PartitionedRegion leaderRegion = ColocationHelper.getLeaderRegion(partitionedRegion);
-    if (!ColocationHelper.checkMembersColocation(leaderRegion,
-        leaderRegion.getDistributionManager().getDistributionManagerId())) {
+    if (!checkMembersColocation(leaderRegion, leaderRegion.getDistributionManager().getId())) {
-            prRegion, leaderRegion);
+            partitionedRegion, leaderRegion);
-    final ProxyBucketRegion[] proxyBucketArray =
+    ProxyBucketRegion[] proxyBucketArray =
-
-
-    Set<InternalDistributedMember> peers = prRegion.getRegionAdvisor().adviseGeneric();
+
+    Set<InternalDistributedMember> peers = partitionedRegion.getRegionAdvisor().adviseGeneric();
-    MembershipFlushRequest.send(peers, prRegion.getDistributionManager(),
-        prRegion.getFullPath());
+    MembershipFlushRequest.send(peers, partitionedRegion.getDistributionManager(),
+        partitionedRegion.getFullPath());
-    for (final ProxyBucketRegion proxyBucket : proxyBucketArray) {
+    for (ProxyBucketRegion proxyBucket : proxyBucketArray) {
-        final RecoveryRunnable recoveryRunnable = new RecoveryRunnable(this) {
+        RecoveryRunnable recoveryRunnable = new RecoveryRunnable(this) {
+
-      // try to recover the local buckets before the proxy buckets. This will allow us to detect any
-      // ConflictingDataException before the proxy buckets update their membership view.
-      for (final ProxyBucketRegion proxyBucket : bucketsHostedLocally) {
+      // try to recover the local buckets before the proxy buckets. This will allow us to detect
+      // any ConflictingDataException before the proxy buckets update their membership view.
+      for (ProxyBucketRegion proxyBucket : bucketsHostedLocally) {
-      for (final ProxyBucketRegion proxyBucket : bucketsNotHostedLocally) {
+      for (ProxyBucketRegion proxyBucket : bucketsNotHostedLocally) {
-  private void createPersistentBucketRecoverer(int proxyBuckets) {
-    persistentBucketRecoverer = new PersistentBucketRecoverer(this, proxyBuckets);
+  @VisibleForTesting
+  void createPersistentBucketRecoverer(int proxyBuckets) {
+    persistentBucketRecoverer = persistentBucketRecovererFunction.apply(this, proxyBuckets);
+  @VisibleForTesting
-    PartitionedRegion leader = ColocationHelper.getLeaderRegion(prRegion);
+    PartitionedRegion leader = ColocationHelper.getLeaderRegion(partitionedRegion);
-  private PartitionedRegion findPersistentRegionRecursively(PartitionedRegion pr) {
-    if (pr.getDataPolicy().withPersistence()) {
-      return pr;
+  private PartitionedRegion findPersistentRegionRecursively(PartitionedRegion partitionedRegion) {
+    if (partitionedRegion.getDataPolicy().withPersistence()) {
+      return partitionedRegion;
-    for (PartitionedRegion child : ColocationHelper.getColocatedChildRegions(pr)) {
+    for (PartitionedRegion child : ColocationHelper.getColocatedChildRegions(partitionedRegion)) {
-    if (prRegion.getColocatedWith() != null
-        && ColocationHelper.isColocationComplete(prRegion)) {
+    if (partitionedRegion.getColocatedWith() != null
+        && ColocationHelper.isColocationComplete(partitionedRegion)) {
-          prRegion.getGemFireCache().getInternalResourceManager();
+          partitionedRegion.getGemFireCache().getInternalResourceManager();
-  public InternalPRInfo buildPartitionedRegionInfo(final boolean internal,
-      final LoadProbe loadProbe) {
-    final PartitionedRegion pr = prRegion;
+  public InternalPRInfo buildPartitionedRegionInfo(boolean internal, LoadProbe loadProbe) {
+    PartitionedRegion pr = partitionedRegion;
-    final PartitionedRegionDataStore ds = pr.getDataStore();
+    PartitionedRegionDataStore dataStore = pr.getDataStore();
-    if (ds != null) {
+    if (dataStore != null) {
-    ProxyBucketRegion[] proxyBuckets = prRegion.getRegionAdvisor().getProxyBucketArray();
+    ProxyBucketRegion[] proxyBuckets = partitionedRegion.getRegionAdvisor().getProxyBucketArray();
-      ProxyBucketRegion proxy = proxyBuckets[i];
-      if (prRegion.getDataPolicy().withPersistence()) {
+      ProxyBucketRegion proxyBucket = proxyBuckets[i];
+      if (partitionedRegion.getDataPolicy().withPersistence()) {
-            proxy.getPersistenceAdvisor().getMissingMembers();
+            proxyBucket.getPersistenceAdvisor().getMissingMembers();
-  public InternalPartitionDetails buildPartitionMemberDetails(final boolean internal,
-      final LoadProbe loadProbe) {
-    final PartitionedRegion pr = prRegion;
+  public InternalPartitionDetails buildPartitionMemberDetails(boolean internal,
+      LoadProbe loadProbe) {
+    final PartitionedRegion pr = partitionedRegion;
-    PartitionedRegionDataStore ds = pr.getDataStore();
-    if (ds == null) {
+    PartitionedRegionDataStore dataStore = pr.getDataStore();
+    if (dataStore == null) {
+
-    Map<Integer, Integer> bucketSizeMap = ds.getSizeLocally();
+    Map<Integer, Integer> bucketSizeMap = dataStore.getSizeLocally();
+
-      long bucketSize = ds.getBucketSize(bid);
+      long bucketSize = dataStore.getBucketSize(bid);
-              ds.getBucketsManaged(), ds.getNumberOfPrimaryBucketsManaged(), prLoad, bucketSizes);
+              dataStore.getBucketsManaged(), dataStore.getNumberOfPrimaryBucketsManaged(), prLoad,
+              bucketSizes);
-              ds.getBucketsManaged(), ds.getNumberOfPrimaryBucketsManaged());
+              dataStore.getBucketsManaged(), dataStore.getNumberOfPrimaryBucketsManaged());
-        ColocationHelper.getColocatedChildRegions(prRegion);
+        ColocationHelper.getColocatedChildRegions(partitionedRegion);
-    if (!ColocationHelper.checkMembersColocation(prRegion, prRegion.getMyId())) {
+    if (!checkMembersColocation(partitionedRegion, partitionedRegion.getMyId())) {
-        ColocationHelper.getAllColocationRegions(prRegion);
+        ColocationHelper.getAllColocationRegions(partitionedRegion);
-    DistributionManager distributionManager = prRegion.getDistributionManager();
+    DistributionManager distributionManager = partitionedRegion.getDistributionManager();
+
-    private BucketMembershipObserver(Bucket b) {
-      bucketToMonitor = b;
+    private BucketMembershipObserver(Bucket bucketToMonitor) {
+      this.bucketToMonitor = bucketToMonitor;
-    private BucketMembershipObserverResults waitForOwnersGetPrimary(final int expectedCount,
-        final Collection<InternalDistributedMember> expectedOwners, String partitionName)
+    private BucketMembershipObserverResults waitForOwnersGetPrimary(int expectedCount,
+        Collection<InternalDistributedMember> expectedOwners, String partitionName)
+
+
+
-                prRegion.bucketStringForLogs(bucketToMonitor.getId()));
+                partitionedRegion.bucketStringForLogs(bucketToMonitor.getId()));
-          prRegion.checkReadiness();
-          final int creationWaitMillis = 5 * 1000;
+          partitionedRegion.checkReadiness();
+
+          int creationWaitMillis = 5 * 1000;
-                new Object[] {creationWaitMillis, prRegion.getFullPath(),
-                    expectedOwners});
+                creationWaitMillis, partitionedRegion.getFullPath(), expectedOwners);
+
+
+
-        final InternalDistributedMember id, final boolean crashed) {
+        InternalDistributedMember id, boolean crashed) {
-        DistributedMember member = prRegion.getSystem().getDistributedMember();
+        DistributedMember member = partitionedRegion.getSystem().getDistributedMember();
-        if (!prRegion.isCacheClosing() && !prRegion.isDestroyed() && !member.equals(id)) {
+        if (!partitionedRegion.isCacheClosing() && !partitionedRegion.isDestroyed()
+            && !member.equals(id)) {
-          if (!prRegion.isFixedPartitionedRegion()) {
+          if (!partitionedRegion.isFixedPartitionedRegion()) {
-          PartitionedRegionHelper.cleanUpMetaDataForRegion(prRegion.getCache(),
-              prRegion.getRegionIdentifier(), id, postRecoveryTask);
+          PartitionedRegionHelper.cleanUpMetaDataForRegion(partitionedRegion.getCache(),
+              partitionedRegion.getRegionIdentifier(), id, postRecoveryTask);
-      } catch (CancelException e) {
+      } catch (CancelException ignore) {
+
+

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS83 INS83 INS74 INS59 INS44 INS8 INS78 INS42 MOV44 INS44 INS44 MOV8 INS44 MOV60 MOV21 MOV60 INS78 INS78 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 INS43 INS43 INS43 INS43 INS42 UPD42 MOV43 INS42 INS17 INS42 UPD42 INS43 INS42 INS74 INS42 INS21 INS43 INS42 INS21 INS25 UPD42 INS53 INS60 INS60 UPD42 UPD42 UPD42 UPD42 UPD42 INS74 INS21 INS42 INS42 MOV43 INS42 MOV8 INS42 INS42 INS42 INS42 UPD42 UPD66 INS66 INS42 INS42 INS89 INS42 INS43 INS43 INS43 INS43 INS7 UPD42 INS42 MOV43 MOV43 MOV32 INS32 MOV27 INS8 INS14 UPD42 MOV43 MOV43 INS59 MOV43 INS59 UPD42 UPD42 MOV43 UPD66 INS43 INS43 UPD74 MOV74 MOV32 INS32 MOV43 UPD42 MOV43 INS42 INS42 INS42 INS42 INS22 UPD42 INS22 INS42 INS16 INS16 INS42 INS42 INS32 MOV21 MOV21 INS21 MOV21 MOV21 MOV21 MOV21 MOV21 INS21 INS21 INS21 INS21 MOV21 INS21 INS21 MOV21 INS21 INS21 MOV43 INS27 UPD42 UPD42 UPD42 UPD42 MOV42 INS16 MOV42 INS16 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD43 UPD42 UPD42 MOV32 INS42 INS42 INS32 UPD42 INS32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV21 MOV60 INS52 INS42 INS52 INS42 INS42 INS45 MOV32 INS42 INS45 INS45 INS42 INS42 MOV32 INS32 INS32 MOV32 INS32 INS32 MOV32 INS32 INS32 MOV32 INS32 INS32 MOV32 INS32 INS32 MOV32 INS32 INS32 MOV32 MOV42 UPD42 UPD42 UPD42 UPD42 INS42 INS45 MOV32 MOV32 INS45 INS45 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS44 MOV44 INS42 INS42 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS22 UPD42 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 MOV32 INS42 INS42 INS45 INS42 INS42 MOV32 INS42 MOV42 UPD45 MOV45 INS42 MOV42 INS32 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS45 UPD42 MOV42 INS42 INS32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 INS42 UPD42 UPD42 UPD42 UPD42 INS52 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 MOV32 UPD42 UPD42 MOV27 INS42 INS27 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 UPD42 UPD42 UPD42 UPD42 MOV32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 INS42 INS42 INS42 UPD45 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS45 UPD42 UPD45 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 UPD42 UPD42 UPD42 MOV32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS45 INS42 INS42 INS32 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS45 INS42 UPD45 UPD42 UPD42 UPD42 UPD42 DEL83 DEL42 DEL83 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL83 DEL83 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL45 DEL32 DEL42 DEL32 DEL42 DEL45 DEL7 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL45 DEL7 DEL42 DEL7 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL45 DEL7 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL45 DEL32 DEL42 DEL32 DEL42 DEL8 DEL8 DEL25 DEL32 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL83 DEL42 DEL43 DEL42 DEL27 DEL59 DEL60 DEL42 DEL14 DEL53 DEL83 DEL83 DEL59 DEL60 DEL42 DEL42 DEL45 DEL7 DEL21 DEL8 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL83 DEL59 DEL60 DEL42 DEL45 DEL7 DEL21 DEL8 DEL42 DEL45 DEL7 DEL21 DEL8 DEL25 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL59 DEL60 DEL42 DEL42 DEL42 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL42 DEL83 DEL83 DEL42 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL45 DEL42 DEL27 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL83 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL45 DEL27 DEL42 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL44 DEL83 DEL52 DEL42 DEL14 DEL42 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL42 DEL42 DEL42 DEL83 DEL83 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL32 DEL42 DEL4 DEL3 DEL83 DEL83
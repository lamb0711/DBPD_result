Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * The advisor associated with a {@link ResourceManager}.  Allows knowledge of
- * remote {@link ResourceManager} state and distribution of local {@link ResourceManager} state.
+ * The advisor associated with a {@link ResourceManager}. Allows knowledge of remote
+ * {@link ResourceManager} state and distribution of local {@link ResourceManager} state.
-  public static class ResourceProfileMessage extends
-      HighPriorityDistributionMessage {
+  public static class ResourceProfileMessage extends HighPriorityDistributionMessage {
-      this.profiles = new ResourceManagerProfile[]{profile};
+      this.profiles = new ResourceManagerProfile[] {profile};
-    /* (non-Javadoc)
-     * @see org.apache.geode.distributed.internal.DistributionMessage#process(org.apache.geode.distributed.internal.DistributionManager)
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.geode.distributed.internal.DistributionMessage#process(org.apache.geode.
+     * distributed.internal.DistributionManager)
-            for (int i=0; i<this.profiles.length; i++) {
+            for (int i = 0; i < this.profiles.length; i++) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-    /* (non-Javadoc)
+    /*
+     * (non-Javadoc)
+     * 
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-        for (int i=0; i<this.profiles.length; i++) {
+        for (int i = 0; i < this.profiles.length; i++) {
-        for (int i=0; i<this.profiles.length; i++) {
+        for (int i = 0; i < this.profiles.length; i++) {
+     * 
-    public static void send(final InternalResourceManager irm, Set<InternalDistributedMember> recips,
-        ResourceManagerProfile profile) {
+    public static void send(final InternalResourceManager irm,
+        Set<InternalDistributedMember> recips, ResourceManagerProfile profile) {
-      sb.append(getShortClassName())
-      .append(" (processorId=").append(this.processorId)
-      .append("; profiles=[");
-      for (int i=0; i<this.profiles.length; i++) {
+      sb.append(getShortClassName()).append(" (processorId=").append(this.processorId)
+          .append("; profiles=[");
+      for (int i = 0; i < this.profiles.length; i++) {
-        if (i < this.profiles.length-1) {
+        if (i < this.profiles.length - 1) {
-   * @param advisee The owner of this advisor 
+   * @param advisee The owner of this advisor
-  
+
-  
+
-  protected Profile instantiateProfile(InternalDistributedMember memberId,
-      int version) {
+  protected Profile instantiateProfile(InternalDistributedMember memberId, int version) {
-  
+
-  protected boolean evaluateProfiles(final Profile newProfile,
-      final Profile oldProfile) {
+  protected boolean evaluateProfiles(final Profile newProfile, final Profile oldProfile) {
-    
+
-    
+
-      eventsToDeliver.add(new MemoryEvent(ResourceType.HEAP_MEMORY, MemoryState.DISABLED, newRMProfile.heapState, newRMProfile.getDistributedMember(),
-          newRMProfile.heapBytesUsed, false, newRMProfile.heapThresholds));
-      eventsToDeliver.add(new MemoryEvent(ResourceType.OFFHEAP_MEMORY, MemoryState.DISABLED, newRMProfile.offHeapState, newRMProfile.getDistributedMember(),
+      eventsToDeliver.add(new MemoryEvent(ResourceType.HEAP_MEMORY, MemoryState.DISABLED,
+          newRMProfile.heapState, newRMProfile.getDistributedMember(), newRMProfile.heapBytesUsed,
+          false, newRMProfile.heapThresholds));
+      eventsToDeliver.add(new MemoryEvent(ResourceType.OFFHEAP_MEMORY, MemoryState.DISABLED,
+          newRMProfile.offHeapState, newRMProfile.getDistributedMember(),
-      
+
-        eventsToDeliver.add(new MemoryEvent(ResourceType.HEAP_MEMORY, oldRMProfile.heapState, newRMProfile.heapState, newRMProfile.getDistributedMember(),
-            newRMProfile.heapBytesUsed, false, newRMProfile.heapThresholds));
+        eventsToDeliver.add(new MemoryEvent(ResourceType.HEAP_MEMORY, oldRMProfile.heapState,
+            newRMProfile.heapState, newRMProfile.getDistributedMember(), newRMProfile.heapBytesUsed,
+            false, newRMProfile.heapThresholds));
-  
+
-        newRMProfile.setHeapData(oldRMProfile.heapBytesUsed, oldRMProfile.heapState, oldRMProfile.heapThresholds);
+        newRMProfile.setHeapData(oldRMProfile.heapBytesUsed, oldRMProfile.heapState,
+            oldRMProfile.heapThresholds);
-      
+
-        eventsToDeliver.add(new MemoryEvent(ResourceType.OFFHEAP_MEMORY, oldRMProfile.offHeapState, newRMProfile.offHeapState, newRMProfile.getDistributedMember(),
+        eventsToDeliver.add(new MemoryEvent(ResourceType.OFFHEAP_MEMORY, oldRMProfile.offHeapState,
+            newRMProfile.offHeapState, newRMProfile.getDistributedMember(),
-      
+
-        newRMProfile.setOffHeapData(oldRMProfile.offHeapBytesUsed, oldRMProfile.offHeapState, oldRMProfile.offHeapThresholds);
+        newRMProfile.setOffHeapData(oldRMProfile.offHeapBytesUsed, oldRMProfile.offHeapState,
+            oldRMProfile.offHeapThresholds);
-    
+
-    return new StringBuilder().append("ResourceAdvisor for ResourceManager " 
-        + getAdvisee()).toString();
+    return new StringBuilder().append("ResourceAdvisor for ResourceManager " + getAdvisee())
+        .toString();
-  
+
-   * Profile which shares state with other ResourceManagers.
-   * The data available in this profile should be enough to 
-   * deliver a {@link MemoryEvent} for any of the CRITICAL {@link MemoryState}s 
+   * Profile which shares state with other ResourceManagers. The data available in this profile
+   * should be enough to deliver a {@link MemoryEvent} for any of the CRITICAL {@link MemoryState}s
+   * 
-    //Resource manager related fields
+    // Resource manager related fields
-    
+
-    
+
-    
+
-    public ResourceManagerProfile(InternalDistributedMember memberId,
-        int version) {
+    public ResourceManagerProfile(InternalDistributedMember memberId, int version) {
-    
-    public synchronized ResourceManagerProfile setHeapData(final long heapBytesUsed, final MemoryState heapState,
-        final MemoryThresholds heapThresholds) {
+
+    public synchronized ResourceManagerProfile setHeapData(final long heapBytesUsed,
+        final MemoryState heapState, final MemoryThresholds heapThresholds) {
-    public synchronized ResourceManagerProfile setOffHeapData(final long offHeapBytesUsed, final MemoryState offHeapState,
-        final MemoryThresholds offHeapThresholds) {
+    public synchronized ResourceManagerProfile setOffHeapData(final long offHeapBytesUsed,
+        final MemoryState offHeapState, final MemoryThresholds offHeapThresholds) {
-    
+
-        return new MemoryEvent(ResourceType.HEAP_MEMORY, this.heapState, MemoryState.DISABLED, getDistributedMember(), this.heapBytesUsed,
-            false, this.heapThresholds);
+        return new MemoryEvent(ResourceType.HEAP_MEMORY, this.heapState, MemoryState.DISABLED,
+            getDistributedMember(), this.heapBytesUsed, false, this.heapThresholds);
-      
-      return new MemoryEvent(ResourceType.OFFHEAP_MEMORY, this.offHeapState, MemoryState.DISABLED, getDistributedMember(), this.offHeapBytesUsed,
-          false, this.offHeapThresholds);
+
+      return new MemoryEvent(ResourceType.OFFHEAP_MEMORY, this.offHeapState, MemoryState.DISABLED,
+          getDistributedMember(), this.offHeapBytesUsed, false, this.offHeapThresholds);
-    
+
-     * Used to process incoming Resource Manager profiles. A reply is expected
-     * to contain a profile with state of the local Resource Manager.
+     * Used to process incoming Resource Manager profiles. A reply is expected to contain a profile
+     * with state of the local Resource Manager.
-    public void processIncoming(DistributionManager dm, String adviseePath,
-        boolean removeProfile, boolean exchangeProfiles,
-        final List<Profile> replyProfiles) {
+    public void processIncoming(DistributionManager dm, String adviseePath, boolean removeProfile,
+        boolean exchangeProfiles, final List<Profile> replyProfiles) {
-        handleDistributionAdvisee(cache, removeProfile,
-            exchangeProfiles, replyProfiles);
+        handleDistributionAdvisee(cache, removeProfile, exchangeProfiles, replyProfiles);
-        sb.append("; heapState=").append(this.heapState)
-        .append("; heapBytesUsed=").append(this.heapBytesUsed)
-        .append("; heapThresholds=").append(this.heapThresholds)
-        .append("; offHeapState=").append(this.offHeapState)
-        .append("; offHeapBytesUsed=").append(this.offHeapBytesUsed)
-        .append("; offHeapThresholds=").append(this.offHeapThresholds);
+        sb.append("; heapState=").append(this.heapState).append("; heapBytesUsed=")
+            .append(this.heapBytesUsed).append("; heapThresholds=").append(this.heapThresholds)
+            .append("; offHeapState=").append(this.offHeapState).append("; offHeapBytesUsed=")
+            .append(this.offHeapBytesUsed).append("; offHeapThresholds=")
+            .append(this.offHeapThresholds);
-    
+
-      
+
-      final long heapBytesUsed; final MemoryState heapState; final MemoryThresholds heapThresholds;
-      final long offHeapBytesUsed; final MemoryState offHeapState; final MemoryThresholds offHeapThresholds;
-      synchronized(this) {
+      final long heapBytesUsed;
+      final MemoryState heapState;
+      final MemoryThresholds heapThresholds;
+      final long offHeapBytesUsed;
+      final MemoryState offHeapState;
+      final MemoryThresholds offHeapThresholds;
+      synchronized (this) {
-        
+
-      
+
-    
+
-      return RESOURCE_MANAGER_PROFILE; 
+      return RESOURCE_MANAGER_PROFILE;
-    
+
-    
+
-   * Get set of members whose {@linkplain ResourceManager#setCriticalHeapPercentage(float)
-   * critical heap threshold} has been met or exceeded.  The set does not include the local VM.
-   * The mutability of this set only effects the elements in the set, not the state
-   * of the members.
+   * Get set of members whose {@linkplain ResourceManager#setCriticalHeapPercentage(float) critical
+   * heap threshold} has been met or exceeded. The set does not include the local VM. The mutability
+   * of this set only effects the elements in the set, not the state of the members.
+   * 
-        ResourceManagerProfile rmp = (ResourceManagerProfile)profile;
+        ResourceManagerProfile rmp = (ResourceManagerProfile) profile;
-      }});
+      }
+    });
-    ResourceManagerProfile rmp = (ResourceManagerProfile)getProfile(member);
+    ResourceManagerProfile rmp = (ResourceManagerProfile) getProfile(member);
-    ResourceManagerProfile profile = new ResourceManagerProfile(getDistributionManager().getId(), incrementAndGetVersion());
+    ResourceManagerProfile profile =
+        new ResourceManagerProfile(getDistributionManager().getId(), incrementAndGetVersion());
-    getResourceManager().deliverEventFromRemote(oldp.createDisabledMemoryEvent(ResourceType.HEAP_MEMORY));
-    getResourceManager().deliverEventFromRemote(oldp.createDisabledMemoryEvent(ResourceType.OFFHEAP_MEMORY));
+    getResourceManager()
+        .deliverEventFromRemote(oldp.createDisabledMemoryEvent(ResourceType.HEAP_MEMORY));
+    getResourceManager()
+        .deliverEventFromRemote(oldp.createDisabledMemoryEvent(ResourceType.OFFHEAP_MEMORY));

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 DEL66 DEL66 DEL66
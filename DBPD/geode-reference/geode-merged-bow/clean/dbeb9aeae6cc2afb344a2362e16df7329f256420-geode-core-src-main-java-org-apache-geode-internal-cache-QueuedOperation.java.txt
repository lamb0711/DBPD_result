Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Represents a single operation that can be queued for reliable delivery.
- * Instances are owned in the context of a region.
+ * Represents a single operation that can be queued for reliable delivery. Instances are owned in
+ * the context of a region.
-public class QueuedOperation
-  {
+public class QueuedOperation {
+   * 
-  public QueuedOperation(Operation op, Object key, byte[] value,
-      Object valueObj, byte deserializationPolicy, Object cbArg) {
+  public QueuedOperation(Operation op, Object key, byte[] value, Object valueObj,
+      byte deserializationPolicy, Object cbArg) {
-  public void process(LocalRegion lr, DistributedMember src, long lastMod)
-  {
+  public void process(LocalRegion lr, DistributedMember src, long lastMod) {
-      RegionEventImpl re = new RegionEventImpl(lr, this.op, this.cbArg, true,
-          src);
-      //re.setQueued(true);
+      RegionEventImpl re = new RegionEventImpl(lr, this.op, this.cbArg, true, src);
+      // re.setQueued(true);
+      } else if (this.op == Operation.REGION_CLEAR) {
+        lr.cmnClearRegion(re, false/* cacheWrite */, false/* useRVV */);
+      } else {
+        throw new IllegalStateException(
+            LocalizedStrings.QueuedOperation_THE_0_SHOULD_NOT_HAVE_BEEN_QUEUED
+                .toLocalizedString(this.op));
-      else if (this.op == Operation.REGION_CLEAR) {
-        lr.cmnClearRegion(re, false/* cacheWrite */, false/*useRVV*/);
-      }
-      else {
-        throw new IllegalStateException(LocalizedStrings.QueuedOperation_THE_0_SHOULD_NOT_HAVE_BEEN_QUEUED.toLocalizedString(this.op));
-      }
-    }
-    else {
+    } else {
-      //TODO :EventID should be passed from the sender & should be reused here
-      @Released EntryEventImpl ee = EntryEventImpl.create(
-          lr, this.op, this.key, null,
-          this.cbArg, true, src);
+      // TODO :EventID should be passed from the sender & should be reused here
+      @Released
+      EntryEventImpl ee = EntryEventImpl.create(lr, this.op, this.key, null, this.cbArg, true, src);
-      //ee.setQueued(true);
-      if (this.op.isCreate() || this.op.isUpdate()) {
-        UpdateOperation.UpdateMessage.setNewValueInEvent(this.value,
-                                                         this.valueObj,
-                                                         ee,
-                                                         this.deserializationPolicy);
-        try {
-          long time = lastMod;
-          if (ee.getVersionTag() != null) {
-            time = ee.getVersionTag().getVersionTimeStamp();
+        // ee.setQueued(true);
+        if (this.op.isCreate() || this.op.isUpdate()) {
+          UpdateOperation.UpdateMessage.setNewValueInEvent(this.value, this.valueObj, ee,
+              this.deserializationPolicy);
+          try {
+            long time = lastMod;
+            if (ee.getVersionTag() != null) {
+              time = ee.getVersionTag().getVersionTimeStamp();
+            }
+            if (AbstractUpdateOperation.doPutOrCreate(lr, ee, time)) {
+              // am I done?
+            }
+          } catch (ConcurrentCacheModificationException e) {
+            // operation was rejected by the cache's concurrency control mechanism as being old
-          if (AbstractUpdateOperation.doPutOrCreate(lr, ee, time)) {
-            // am I done?
+        } else if (this.op.isDestroy()) {
+          ee.setOldValueFromRegion();
+          try {
+            lr.basicDestroy(ee, false, null); // expectedOldValue
+                                              // ???:ezoerner:20080815
+                                              // can a remove(key, value) operation be
+                                              // queued?
+          } catch (ConcurrentCacheModificationException e) {
+            // operation was rejected by the cache's concurrency control mechanism as being old
+          } catch (EntryNotFoundException ignore) {
+          } catch (CacheWriterException e) {
+            throw new Error(LocalizedStrings.QueuedOperation_CACHEWRITER_SHOULD_NOT_BE_CALLED
+                .toLocalizedString(), e);
+          } catch (TimeoutException e) {
+            throw new Error(LocalizedStrings.QueuedOperation_DISTRIBUTEDLOCK_SHOULD_NOT_BE_ACQUIRED
+                .toLocalizedString(), e);
-        } catch (ConcurrentCacheModificationException e) {
-          // operation was rejected by the cache's concurrency control mechanism as being old
+        } else if (this.op.isInvalidate()) {
+          ee.setOldValueFromRegion();
+          boolean forceNewEntry = lr.dataPolicy.withReplication() && !lr.isInitialized();
+          boolean invokeCallbacks = lr.isInitialized();
+          try {
+            lr.basicInvalidate(ee, invokeCallbacks, forceNewEntry);
+          } catch (ConcurrentCacheModificationException e) {
+            // operation was rejected by the cache's concurrency control mechanism as being old
+          } catch (EntryNotFoundException ignore) {
+          }
+        } else {
+          throw new IllegalStateException(
+              LocalizedStrings.QueuedOperation_THE_0_SHOULD_NOT_HAVE_BEEN_QUEUED
+                  .toLocalizedString(this.op));
-      }
-      else if (this.op.isDestroy()) {
-        ee.setOldValueFromRegion();
-        try {
-          lr.basicDestroy(ee,
-                          false,
-                          null); // expectedOldValue
-                                 // ???:ezoerner:20080815
-                                 // can a remove(key, value) operation be
-                                 // queued?
-        }
-        catch (ConcurrentCacheModificationException e) {
-          // operation was rejected by the cache's concurrency control mechanism as being old
-        }
-        catch (EntryNotFoundException ignore) {
-        }
-        catch (CacheWriterException e) {
-          throw new Error(LocalizedStrings.QueuedOperation_CACHEWRITER_SHOULD_NOT_BE_CALLED.toLocalizedString(), e);
-        }
-        catch (TimeoutException e) {
-          throw new Error(LocalizedStrings.QueuedOperation_DISTRIBUTEDLOCK_SHOULD_NOT_BE_ACQUIRED.toLocalizedString(), e);
-        }
-      }
-      else if (this.op.isInvalidate()) {
-        ee.setOldValueFromRegion();
-        boolean forceNewEntry = lr.dataPolicy.withReplication()
-            && !lr.isInitialized();
-        boolean invokeCallbacks = lr.isInitialized();
-        try {
-          lr.basicInvalidate(ee, invokeCallbacks, forceNewEntry);
-        }
-        catch (ConcurrentCacheModificationException e) {
-          // operation was rejected by the cache's concurrency control mechanism as being old
-        }
-        catch (EntryNotFoundException ignore) {
-        }
-      }
-      else {
-        throw new IllegalStateException(LocalizedStrings.QueuedOperation_THE_0_SHOULD_NOT_HAVE_BEEN_QUEUED.toLocalizedString(this.op));
-      }
-      throws IOException, ClassNotFoundException
-  {
+      throws IOException, ClassNotFoundException {
-    return new QueuedOperation(op, key, value, valueObj, deserializationPolicy,
-        cbArg);
+    return new QueuedOperation(op, key, value, valueObj, deserializationPolicy, cbArg);
-  public void toData(DataOutput out) throws IOException
-  {
+  public void toData(DataOutput out) throws IOException {

UPD66 UPD66
Merge branch 'release/1.3.0'

+import java.util.concurrent.atomic.AtomicInteger;
-  /** The process id of this VM */
-  private int pid;
+  /** The sequential id of this VM */
+  private int id;
+   * restart an unavailable VM
+   */
+  public synchronized void makeAvailable() {
+    if (!this.available) {
+      this.available = true;
+      bounce();
+    }
+  }
+
+  /**
-   *
-   * TODO: change pid to reflect value from {@link ProcessUtils#identifyPid()}
-  public VM(final Host host, final int pid, final RemoteDUnitVMIF client) {
-    this(host, VersionManager.CURRENT_VERSION, pid, client);
+  public VM(final Host host, int id, final RemoteDUnitVMIF client) {
+    this(host, VersionManager.CURRENT_VERSION, id, client);
-  public VM(final Host host, final String version, final int pid, final RemoteDUnitVMIF client) {
+  public VM(final Host host, final String version, final int id, final RemoteDUnitVMIF client) {
-    this.pid = pid;
+    this.id = id;
+   * Returns the VM id of this {@code VM}.
+   */
+  public int getId() {
+    return this.id;
+  }
+
+  /**
-    return this.pid;
+    return invoke(() -> ProcessUtils.identifyPid());
-      BounceResult result = DUnitEnv.get().bounce(targetVersion, this.pid);
-      this.pid = result.getNewPid();
+      BounceResult result = DUnitEnv.get().bounce(targetVersion, this.id);
+      this.id = result.getNewId();
-    return "VM " + getPid() + " running on " + getHost()
+    return "VM " + getId() + " running on " + getHost()
-    return DUnitEnv.get().getWorkingDirectory(getVersion(), getPid());
+    return DUnitEnv.get().getWorkingDirectory(getVersion(), getId());

INS26 INS40 INS31 INS31 INS29 INS83 INS83 INS39 INS42 INS8 INS29 UPD42 MOV29 INS83 INS39 INS42 INS8 UPD42 INS65 INS25 UPD42 UPD42 INS65 INS41 UPD66 INS66 INS38 INS8 UPD42 INS66 INS65 INS66 INS32 INS22 INS21 INS21 UPD42 INS66 UPD42 INS42 INS86 INS52 INS42 INS7 INS32 UPD42 INS32 UPD42 UPD42 INS22 INS9 INS42 INS42 INS42 INS52 INS42 UPD42 UPD42 UPD42 DEL66 DEL42 DEL42 DEL68 DEL65 DEL83
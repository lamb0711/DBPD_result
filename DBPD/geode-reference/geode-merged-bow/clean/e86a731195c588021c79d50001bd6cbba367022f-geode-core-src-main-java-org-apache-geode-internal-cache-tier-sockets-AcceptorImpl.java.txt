Merge branch 'release/1.3.0'

-import static org.apache.geode.distributed.ConfigurationProperties.*;
+import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_CLIENT_ACCESSOR_PP;
+import static org.apache.geode.internal.cache.tier.CommunicationMode.ClientToServerForQueue;
+
+import org.apache.geode.CancelException;
+import org.apache.geode.SystemFailure;
+import org.apache.geode.ToDataException;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.RegionDestroyedException;
+import org.apache.geode.cache.client.internal.PoolImpl;
+import org.apache.geode.cache.server.CacheServer;
+import org.apache.geode.cache.wan.GatewayTransportFilter;
+import org.apache.geode.distributed.internal.DM;
+import org.apache.geode.distributed.internal.DistributionConfig;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.distributed.internal.LonerDistributionManager;
+import org.apache.geode.distributed.internal.PooledExecutorWithDMStats;
+import org.apache.geode.distributed.internal.ReplyProcessor21;
+import org.apache.geode.internal.SystemTimer;
+import org.apache.geode.internal.cache.BucketAdvisor;
+import org.apache.geode.internal.cache.BucketAdvisor.BucketProfile;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.PartitionedRegion;
+import org.apache.geode.internal.cache.partitioned.AllBucketProfilesUpdateMessage;
+import org.apache.geode.internal.cache.tier.Acceptor;
+import org.apache.geode.internal.cache.tier.CachedRegionHelper;
+import org.apache.geode.internal.cache.tier.CommunicationMode;
+import org.apache.geode.internal.cache.wan.GatewayReceiverStats;
+import org.apache.geode.internal.i18n.LocalizedStrings;
+import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.internal.logging.LoggingThreadGroup;
+import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+import org.apache.geode.internal.net.SocketCreator;
+import org.apache.geode.internal.net.SocketCreatorFactory;
+import org.apache.geode.internal.security.SecurableCommunicationChannel;
+import org.apache.geode.internal.security.SecurityService;
+import org.apache.geode.internal.tcp.ConnectionTable;
+import org.apache.geode.internal.util.ArrayUtils;
+import org.apache.logging.log4j.Logger;
-import javax.net.ssl.SSLException;
-
-import org.apache.logging.log4j.Logger;
-
-import org.apache.geode.CancelException;
-import org.apache.geode.SystemFailure;
-import org.apache.geode.ToDataException;
-import org.apache.geode.cache.Cache;
-import org.apache.geode.cache.RegionDestroyedException;
-import org.apache.geode.cache.client.internal.PoolImpl;
-import org.apache.geode.cache.server.CacheServer;
-import org.apache.geode.cache.wan.GatewayTransportFilter;
-import org.apache.geode.distributed.internal.DM;
-import org.apache.geode.distributed.internal.DistributionConfig;
-import org.apache.geode.distributed.internal.InternalDistributedSystem;
-import org.apache.geode.distributed.internal.LonerDistributionManager;
-import org.apache.geode.distributed.internal.PooledExecutorWithDMStats;
-import org.apache.geode.distributed.internal.ReplyProcessor21;
-import org.apache.geode.internal.SystemTimer;
-import org.apache.geode.internal.cache.BucketAdvisor;
-import org.apache.geode.internal.cache.BucketAdvisor.BucketProfile;
-import org.apache.geode.internal.cache.InternalCache;
-import org.apache.geode.internal.cache.PartitionedRegion;
-import org.apache.geode.internal.cache.partitioned.AllBucketProfilesUpdateMessage;
-import org.apache.geode.internal.cache.tier.Acceptor;
-import org.apache.geode.internal.cache.tier.CachedRegionHelper;
-import org.apache.geode.internal.cache.wan.GatewayReceiverStats;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.LogService;
-import org.apache.geode.internal.logging.LoggingThreadGroup;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
-import org.apache.geode.internal.net.SocketCreator;
-import org.apache.geode.internal.net.SocketCreatorFactory;
-import org.apache.geode.internal.security.IntegratedSecurityService;
-import org.apache.geode.internal.security.SecurableCommunicationChannel;
-import org.apache.geode.internal.security.SecurityService;
-import org.apache.geode.internal.tcp.ConnectionTable;
-import org.apache.geode.internal.util.ArrayUtils;
-
- * 
+ *
-public class AcceptorImpl extends Acceptor implements Runnable {
+public class AcceptorImpl extends Acceptor implements Runnable, CommBufferPool {
-  /** The port on which this acceptor listens for client connections */
+  /**
+   * The port on which this acceptor listens for client connections
+   */
-  /** The server socket that handles requests for connections */
+  /**
+   * The server socket that handles requests for connections
+   */
-  /** The GemFire cache served up by this acceptor */
+  /**
+   * The GemFire cache served up by this acceptor
+   */
-  /** Caches region information */
+  /**
+   * Caches region information
+   */
-  /** A lock to prevent close from occurring while creating a ServerConnection */
+  /**
+   * A lock to prevent close from occurring while creating a ServerConnection
+   */
-  /** Test value for handshake timeout */
+  /**
+   * Test value for handshake timeout
+   */
-  /** Test value for accept timeout */
+  /**
+   * Test value for accept timeout
+   */
-  /** The mininum value of max-connections */
+  /**
+   * The mininum value of max-connections
+   */
-  /** The buffer size for server-side sockets. */
+  /**
+   * The buffer size for server-side sockets.
+   */
-  /** Notifies clients of updates */
+  /**
+   * Notifies clients of updates
+   */
-  /** The system property name for setting the {@link ServerSocket}backlog */
+  /**
+   * The system property name for setting the {@link ServerSocket}backlog
+   */
-  /** Has this acceptor been shut down */
+  /**
+   * Has this acceptor been shut down
+   */
-  /** The thread that runs the acceptor */
+  /**
+   * The thread that runs the acceptor
+   */
-  /** The thread that runs the selector loop if any */
+  /**
+   * The thread that runs the selector loop if any
+   */
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-  /** The client health monitor tracking connections for this acceptor */
-  private ClientHealthMonitor healthMonitor;
+  /**
+   * The client health monitor tracking connections for this acceptor
+   */
+  private final ClientHealthMonitor healthMonitor;
-  /** bridge's setting of notifyBySubscription */
+  /**
+   * bridge's setting of notifyBySubscription
+   */
-  private SecurityService securityService = IntegratedSecurityService.getSecurityService();
+  private final SecurityService securityService;
+
+  private final ServerConnectionFactory serverConnectionFactory;
-   * 
+   *
-   * 
-      List<GatewayTransportFilter> transportFilter, boolean tcpNoDelay) throws IOException {
+      List<GatewayTransportFilter> transportFilter, boolean tcpNoDelay,
+      ServerConnectionFactory serverConnectionFactory) throws IOException {
+    this.securityService = internalCache.getSecurityService();
+    this.serverConnectionFactory = serverConnectionFactory;
-      String sockName = this.serverSock.getLocalSocketAddress().toString();
+      String sockName = getServerName();
-   * 
+   *
-   * 
+   *
-  /** wake up the selector thread */
+  /**
+   * wake up the selector thread
+   */
-   * 
+   *
+  @Override
+  public String getServerName() {
+    String name = this.serverSock.getLocalSocketAddress().toString();
+    try {
+      name = SocketCreator.getLocalHost().getCanonicalHostName() + "-" + name;
+    } catch (Exception e) {
+    }
+    return name;
+  }
+
+
-   * 
+   *
-      Socket s = null;
+      Socket socket = null;
-        s = serverSock.accept();
+        socket = serverSock.accept();
-        s.setKeepAlive(SocketCreator.ENABLE_TCP_KEEP_ALIVE);
+        socket.setKeepAlive(SocketCreator.ENABLE_TCP_KEEP_ALIVE);
-            closeSocket(s);
+            closeSocket(socket);
-        handOffNewClientConnection(s);
+        handOffNewClientConnection(socket, serverConnectionFactory);
-        closeSocket(s);
+        closeSocket(socket);
-        if (isRunning()) {
-          if (e instanceof SSLException) {
-            try {
-              // Try to send a proper rejection message
-              ServerHandShakeProcessor.refuse(s.getOutputStream(), e.toString(),
-                  HandShake.REPLY_EXCEPTION_AUTHENTICATION_FAILED);
-            } catch (IOException ex) {
-              if (logger.isDebugEnabled()) {
-                logger.debug("Bridge server: Unable to write SSL error");
-              }
-            }
-          }
-        }
-        closeSocket(s);
+        closeSocket(socket);
-        closeSocket(s);
+        closeSocket(socket);
-        closeSocket(s);
+        closeSocket(socket);
-
-  private void handOffNewClientConnection(final Socket s) {
+  private void handOffNewClientConnection(final Socket socket,
+      final ServerConnectionFactory serverConnectionFactory) {
-            handleNewClientConnection(s);
+            handleNewClientConnection(socket, serverConnectionFactory);
-              closeSocket(s);
+              closeSocket(socket);
-      closeSocket(s);
+      closeSocket(socket);
-  public ByteBuffer takeCommBuffer() {
+  private ByteBuffer takeCommBuffer() {
-  public void releaseCommBuffer(ByteBuffer bb) {
+  private void releaseCommBuffer(ByteBuffer bb) {
-  protected void handleNewClientConnection(final Socket s) throws IOException {
+  protected void handleNewClientConnection(final Socket socket,
+      final ServerConnectionFactory serverConnectionFactory) throws IOException {
-    byte communicationMode;
-    if (isSelector()) {
-      ByteBuffer bb = ByteBuffer.allocateDirect(1);
-      final SocketChannel sc = s.getChannel();
-      sc.configureBlocking(false);
-      // try to read the byte first in non-blocking mode
-      int res = sc.read(bb);
-      sc.configureBlocking(true);
-      if (res < 0) {
-        throw new EOFException();
-      } else if (res == 0) {
-        // now do a blocking read so setup a timer to close the socket if the
-        // the read takes too long
-        SystemTimer.SystemTimerTask st = new SystemTimer.SystemTimerTask() {
-          @Override
-          public void run2() {
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.AcceptorImpl_CACHE_SERVER_TIMED_OUT_WAITING_FOR_HANDSHAKE_FROM__0,
-                s.getRemoteSocketAddress()));
-            closeSocket(s);
-          }
-        };
-        this.hsTimer.schedule(st, this.acceptTimeout);
-        res = sc.read(bb);
-        if ((!st.cancel()) || res <= 0) {
-          throw new EOFException();
-        }
+    final CommunicationMode communicationMode;
+    try {
+      if (isSelector()) {
+        communicationMode = getCommunicationModeForSelector(socket);
+      } else {
+        communicationMode = getCommunicationModeForNonSelector(socket);
-      communicationMode = bb.get(0);
-      if (logger.isTraceEnabled()) {
-        logger.trace("read communications mode(1) ", communicationMode);
-      }
-    } else {
-      s.setSoTimeout(this.acceptTimeout);
-      this.socketCreator.configureServerSSLSocket(s);
-      communicationMode = (byte) s.getInputStream().read();
-      if (logger.isTraceEnabled()) {
-        logger.trace("read communications mode(2) ", communicationMode);
-      }
-      if (communicationMode == -1) {
-        throw new EOFException();
-      }
-      s.setSoTimeout(0);
+      socket.setTcpNoDelay(this.tcpNoDelay);
+
+    } catch (IllegalArgumentException e) {
+      // possible if a client uses SSL & the server isn't configured to use SSL,
+      // or if an invalid communication communication mode byte is sent.
+      logger.warn("Error processing client connection", e);
+      throw new EOFException();
-    s.setTcpNoDelay(this.tcpNoDelay);
+    if (communicationMode.isSubscriptionFeed()) {
+      boolean primary = communicationMode == CommunicationMode.PrimaryServerToClient;
+      logger.debug(":Bridge server: Initializing {} server-to-client communication socket: {}",
+          primary ? "primary" : "secondary", socket);
+      AcceptorImpl.this.clientNotifier.registerClient(socket, primary, this.acceptorId,
+          this.notifyBySubscription);
+      return;
+    }
-    if (communicationMode == CLIENT_TO_SERVER || communicationMode == GATEWAY_TO_GATEWAY
-        || communicationMode == MONITOR_TO_SERVER
-        || communicationMode == CLIENT_TO_SERVER_FOR_QUEUE) {
-      String communicationModeStr = "";
-      switch (communicationMode) {
-        case CLIENT_TO_SERVER:
-          communicationModeStr = "client";
-          break;
-        case GATEWAY_TO_GATEWAY:
-          communicationModeStr = "gateway";
-          break;
-        case MONITOR_TO_SERVER:
-          communicationModeStr = "monitor";
-          break;
-        case CLIENT_TO_SERVER_FOR_QUEUE:
-          communicationModeStr = "clientToServerForQueue";
-          break;
-      }
-      if (logger.isDebugEnabled()) {
-        logger.debug("Bridge server: Initializing {} communication socket: {}",
-            communicationModeStr, s);
-      }
-      if (communicationMode != CLIENT_TO_SERVER_FOR_QUEUE) {
-        int curCnt = this.getClientServerCnxCount();
-        if (curCnt >= this.maxConnections) {
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.AcceptorImpl_REJECTED_CONNECTION_FROM_0_BECAUSE_CURRENT_CONNECTION_COUNT_OF_1_IS_GREATER_THAN_OR_EQUAL_TO_THE_CONFIGURED_MAX_OF_2,
-              new Object[] {s.getInetAddress(), Integer.valueOf(curCnt),
-                  Integer.valueOf(this.maxConnections)}));
-          // if (s != null) (cannot be null)
-          {
-            try {
-              ServerHandShakeProcessor.refuse(s.getOutputStream(),
-                  LocalizedStrings.AcceptorImpl_EXCEEDED_MAX_CONNECTIONS_0
-                      .toLocalizedString(Integer.valueOf(this.maxConnections)));
-            } catch (Exception ex) {
-              if (logger.isDebugEnabled()) {
-                logger.debug("rejection message failed", ex);
-              }
-            }
-            closeSocket(s);
-          }
-          return;
-        }
-      }
-      ServerConnection serverConn = new ServerConnection(s, this.cache, this.crHelper, this.stats,
-          AcceptorImpl.handShakeTimeout, this.socketBufferSize, communicationModeStr,
-          communicationMode, this);
-      synchronized (this.allSCsLock) {
-        this.allSCs.add(serverConn);
-        ServerConnection snap[] = this.allSCList; // avoid volatile read
-        this.allSCList = (ServerConnection[]) ArrayUtils.insert(snap, snap.length, serverConn);
-      }
-      if (communicationMode != CLIENT_TO_SERVER_FOR_QUEUE) {
-        incClientServerCnxCount();
-      }
-      if (isSelector()) {
-        serverConn.registerWithSelector();
-      } else {
-        try {
-          pool.execute(serverConn);
-        } catch (RejectedExecutionException rejected) {
-          if (!isRunning()) {
-            return;
-          }
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.AcceptorImpl_REJECTED_CONNECTION_FROM_0_BECAUSE_REQUEST_REJECTED_BY_POOL,
-              new Object[] {serverConn}));
+    logger.debug("Bridge server: Initializing {} communication socket: {}", communicationMode,
+        socket);
+    boolean notForQueue = (communicationMode != ClientToServerForQueue);
+    if (notForQueue) {
+      int curCnt = this.getClientServerCnxCount();
+      if (curCnt >= this.maxConnections) {
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.AcceptorImpl_REJECTED_CONNECTION_FROM_0_BECAUSE_CURRENT_CONNECTION_COUNT_OF_1_IS_GREATER_THAN_OR_EQUAL_TO_THE_CONFIGURED_MAX_OF_2,
+            new Object[] {socket.getInetAddress(), Integer.valueOf(curCnt),
+                Integer.valueOf(this.maxConnections)}));
+        if (communicationMode.expectsConnectionRefusalMessage()) {
-            ServerHandShakeProcessor.refuse(s.getOutputStream(),
+            ServerHandShakeProcessor.refuse(socket.getOutputStream(),
-
-            if (logger.isDebugEnabled()) {
-              logger.debug("rejection message failed", ex);
-            }
+            logger.debug("rejection message failed", ex);
-          serverConn.cleanup();
+        closeSocket(socket);
+        return;
-    } else if (communicationMode == PRIMARY_SERVER_TO_CLIENT) {
-      if (logger.isDebugEnabled()) {
-        logger.debug(
-            ":Bridge server: Initializing primary server-to-client communication socket: {}", s);
-      }
-      // try {
-      AcceptorImpl.this.clientNotifier.registerClient(s, true, this.acceptorId,
-          this.notifyBySubscription);
-    } else if (communicationMode == SECONDARY_SERVER_TO_CLIENT) {
-      if (logger.isDebugEnabled()) {
-        logger.debug(
-            ":Bridge server: Initializing secondary server-to-client communication socket: {}", s);
-      }
-      AcceptorImpl.this.clientNotifier.registerClient(s, false, this.acceptorId,
-          this.notifyBySubscription);
-    } else {
-      throw new IOException("Acceptor received unknown communication mode: " + communicationMode);
+
+    ServerConnection serverConn =
+        serverConnectionFactory.makeServerConnection(socket, this.cache, this.crHelper, this.stats,
+            AcceptorImpl.handShakeTimeout, this.socketBufferSize, communicationMode.toString(),
+            communicationMode.getModeNumber(), this, this.securityService);
+
+    synchronized (this.allSCsLock) {
+      this.allSCs.add(serverConn);
+      ServerConnection snap[] = this.allSCList; // avoid volatile read
+      this.allSCList = (ServerConnection[]) ArrayUtils.insert(snap, snap.length, serverConn);
+    }
+    if (notForQueue) {
+      incClientServerCnxCount();
+    }
+    if (isSelector()) {
+      serverConn.registerWithSelector();
+    } else {
+      try {
+        pool.execute(serverConn);
+      } catch (RejectedExecutionException rejected) {
+        if (!isRunning()) {
+          return;
+        }
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.AcceptorImpl_REJECTED_CONNECTION_FROM_0_BECAUSE_REQUEST_REJECTED_BY_POOL,
+            new Object[] {serverConn}));
+        try {
+          ServerHandShakeProcessor.refuse(socket.getOutputStream(),
+              LocalizedStrings.AcceptorImpl_EXCEEDED_MAX_CONNECTIONS_0
+                  .toLocalizedString(Integer.valueOf(this.maxConnections)));
+
+        } catch (Exception ex) {
+          logger.debug("rejection message failed", ex);
+        }
+        serverConn.cleanup();
+      }
+    }
+  }
+
+  private CommunicationMode getCommunicationModeForNonSelector(Socket socket) throws IOException {
+    socket.setSoTimeout(this.acceptTimeout);
+    this.socketCreator.configureServerSSLSocket(socket);
+    byte communicationModeByte = (byte) socket.getInputStream().read();
+    if (communicationModeByte == -1) {
+      throw new EOFException();
+    }
+    socket.setSoTimeout(0);
+    return CommunicationMode.fromModeNumber(communicationModeByte);
+  }
+
+  private CommunicationMode getCommunicationModeForSelector(Socket socket) throws IOException {
+    ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1);
+    final SocketChannel socketChannel = socket.getChannel();
+    socketChannel.configureBlocking(false);
+    // try to read the byte first in non-blocking mode
+    int res = socketChannel.read(byteBuffer);
+    socketChannel.configureBlocking(true);
+    if (res < 0) {
+      throw new EOFException();
+    } else if (res == 0) {
+      // now do a blocking read so setup a timer to close the socket if the
+      // the read takes too long
+      SystemTimer.SystemTimerTask timerTask = new SystemTimer.SystemTimerTask() {
+        @Override
+        public void run2() {
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.AcceptorImpl_CACHE_SERVER_TIMED_OUT_WAITING_FOR_HANDSHAKE_FROM__0,
+              socket.getRemoteSocketAddress()));
+          closeSocket(socket);
+        }
+      };
+      this.hsTimer.schedule(timerTask, this.acceptTimeout);
+      res = socketChannel.read(byteBuffer);
+      if ((!timerTask.cancel()) || res <= 0) {
+        throw new EOFException();
+      }
+    }
+    return CommunicationMode.fromModeNumber(byteBuffer.get(0));
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
+
+  @Override
+  public void setTLCommBuffer() {
+    // The thread local will only be set if maxThreads has been set.
+    if (!isSelector()) {
+      return;
+    }
+
+    Message.setTLCommBuffer(takeCommBuffer());
+  }
+
+  @Override
+  public void releaseTLCommBuffer() {
+    if (!isSelector()) {
+      return;
+    }
+
+    releaseCommBuffer(Message.setTLCommBuffer(null));
+  }

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 UPD40 UPD40 UPD40 INS43 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS42 INS83 MOV83 INS83 MOV43 INS59 INS83 INS83 INS43 INS59 INS44 INS78 INS83 INS43 INS42 INS8 INS44 UPD83 UPD83 INS44 MOV8 INS83 INS43 INS42 INS44 MOV43 MOV8 INS83 INS43 INS42 INS44 MOV43 MOV8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS8 MOV42 INS42 INS42 INS43 INS42 INS21 INS21 INS42 INS42 MOV60 INS54 INS41 UPD42 INS83 INS43 INS42 UPD42 INS83 INS43 INS42 MOV60 INS54 INS25 MOV21 INS60 INS42 INS43 INS42 INS60 INS21 INS41 INS42 INS43 INS42 INS41 INS42 INS25 INS21 INS42 INS25 INS21 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 INS7 INS7 INS60 UPD66 INS8 INS12 INS42 INS42 INS42 INS83 INS43 INS8 INS12 INS32 INS8 INS39 INS59 INS42 MOV43 INS42 MOV8 INS42 INS39 INS59 INS32 INS32 INS42 INS32 INS38 INS8 INS32 INS38 INS8 INS32 INS22 INS32 INS22 INS42 MOV43 INS59 UPD42 INS21 INS44 INS8 INS42 INS25 MOV21 INS44 INS8 INS42 INS42 INS60 INS21 INS21 INS41 UPD42 UPD42 INS42 INS36 INS25 INS32 INS54 UPD42 UPD42 INS42 INS11 UPD42 UPD42 MOV42 UPD42 MOV42 INS34 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS32 INS32 INS41 INS42 INS42 INS32 INS32 INS41 INS42 INS32 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS32 INS7 INS43 INS42 MOV32 INS8 INS8 INS43 INS42 INS21 INS53 INS39 INS59 INS32 INS32 INS27 MOV27 INS8 INS42 INS42 INS42 MOV22 MOV22 MOV22 INS40 MOV22 INS32 INS32 INS52 INS22 MOV8 INS12 MOV39 MOV32 UPD42 UPD42 UPD42 UPD42 MOV42 MOV42 MOV34 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS27 INS42 UPD42 INS21 INS21 UPD42 INS42 INS32 INS14 INS42 INS27 INS42 INS42 INS45 INS16 INS42 MOV22 INS42 INS42 INS42 MOV22 MOV22 INS42 INS42 MOV21 MOV25 INS21 INS41 INS42 INS42 INS42 INS42 INS52 INS42 MOV44 MOV8 MOV43 INS32 INS45 INS42 UPD42 INS7 MOV7 INS42 INS42 INS45 INS42 INS43 INS42 INS40 INS42 INS45 INS45 INS32 INS8 INS32 MOV25 MOV21 MOV21 UPD42 UPD42 UPD42 INS32 UPD42 MOV42 UPD42 UPD42 UPD42 INS42 INS42 INS32 UPD42 INS32 INS42 INS42 INS42 INS54 INS42 INS42 MOV43 UPD42 UPD42 UPD42 MOV42 INS42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS8 INS12 MOV8 INS21 MOV44 MOV8 UPD42 INS32 UPD42 UPD42 INS42 INS42 INS32 MOV32 UPD42 INS42 INS42 UPD42 UPD42 INS42 UPD42 UPD42 DEL32 DEL59 DEL23 DEL42 DEL32 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL40 DEL32 DEL21 DEL8 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL25 DEL39 DEL45 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL49 DEL21 DEL10 DEL42 DEL49 DEL42 DEL45 DEL7 DEL21 DEL10 DEL42 DEL49 DEL42 DEL45 DEL7 DEL21 DEL10 DEL42 DEL49 DEL42 DEL45 DEL7 DEL21 DEL10 DEL50 DEL42 DEL42 DEL32 DEL8 DEL25 DEL42 DEL42 DEL27 DEL42 DEL43 DEL42 DEL40 DEL42 DEL42 DEL52 DEL14 DEL42 DEL42 DEL27 DEL42 DEL42 DEL32 DEL25 DEL8 DEL42 DEL32 DEL41 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL25 DEL8 DEL12 DEL54 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL42 DEL27 DEL42 DEL42 DEL27 DEL27 DEL42 DEL42 DEL27 DEL27 DEL42 DEL42 DEL27 DEL27 DEL42 DEL42 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL42 DEL42 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL9 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL32 DEL21 DEL8 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL25 DEL25 DEL8 DEL42 DEL11 DEL7 DEL21 DEL32 DEL45 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL34 DEL32 DEL21 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25
Merge branch 'release/1.4.0'

-
-import org.apache.geode.internal.cache.lru.NewLRUClockHand;
+import org.apache.geode.internal.cache.eviction.EvictionList;
+ * <p>
+ * Our RegionEntry does not need to keep a reference to the key. It is being referenced by the
+ * Map.Entry whose value field references this RegionEntry.
+ *
- *
- * 
- *        Implementations: (unshared) ThinEntry protected volatile long lastModified; StatsEntry
- *        extends ThinEntry private volatile long lastAccessed; private volatile int hitCount;
- *        private volatile int missCount; DiskThinEntry extends ThinEntry private volatile long id;
- *        DiskStatsEntry extends StatsEntry private volatile long id; ThinLRUEntry extends ThinEntry
- *        int bitField1; LRUClockNode nextLRU; int size; StatsLRUEntry extends StatsEntry int
- *        bitField1; LRUClockNode nextLRU; int size; DiskThinLRUEntry extends ThinLRUEntry private
- *        volatile long id; DiskStatsLRUEntry extends StatsLRUEntry private volatile long id;
- *
-  // Our RegionEntry does not need to keep a reference to the key.
-  // It is being referenced by the Map.Entry whose value field
-  // references this RegionEntry.
-  // Object getKey();
-  public long getLastModified();
+  long getLastModified();
-   * 
+   *
-  public boolean hasStats();
+  boolean hasStats();
-  public long getLastAccessed() throws InternalStatisticsDisabledException;
+  long getLastAccessed() throws InternalStatisticsDisabledException;
-  public long getHitCount() throws InternalStatisticsDisabledException;
+  /**
+   * Sets the entry's last accessed time if it has one.
+   */
+  default void setLastAccessed(long lastAccessed) {
+    // do nothing by default
+  }
-  public long getMissCount() throws InternalStatisticsDisabledException;
+  long getHitCount() throws InternalStatisticsDisabledException;
-  public void updateStatsForPut(long lastModifiedTime, long lastAccessedTime);
+  long getMissCount() throws InternalStatisticsDisabledException;
+
+  void updateStatsForPut(long lastModifiedTime, long lastAccessedTime);
-  public VersionStamp getVersionStamp();
+  VersionStamp getVersionStamp();
-  public VersionTag generateVersionTag(VersionSource member, boolean withDelta, LocalRegion region,
+  VersionTag generateVersionTag(VersionSource member, boolean withDelta, InternalRegion region,
-   * 
+   *
-  public boolean dispatchListenerEvents(EntryEventImpl event) throws InterruptedException;
+  boolean dispatchListenerEvents(EntryEventImpl event) throws InterruptedException;
-  public void setRecentlyUsed();
+  void setRecentlyUsed(RegionEntryContext context); // same method as on EvictionNode interface
-  public void updateStatsForGet(boolean hit, long time);
+  void updateStatsForGet(boolean hit, long time);
-   * 
-   * @param currTime Current Cache Time.
+   *
+   * @param currentTime Current Cache Time.
-  public void txDidDestroy(long currTime);
+  void txDidDestroy(long currentTime);
-  public void resetCounts() throws InternalStatisticsDisabledException;
+  void resetCounts() throws InternalStatisticsDisabledException;
-   * 
-   * @param r the region holding the entry
+   *
+   * @param region the region holding the entry
-   * @throws RegionClearedException
-  public void makeTombstone(LocalRegion r, VersionTag version) throws RegionClearedException;
+  void makeTombstone(InternalRegion region, VersionTag version) throws RegionClearedException;
-   * 
-   * @param r LocalRegion
+   *
+   * @param region the region
-   * 
+   *
-  public void removePhase1(LocalRegion r, boolean clear) throws RegionClearedException;
+  void removePhase1(InternalRegion region, boolean clear) throws RegionClearedException;
-  public void removePhase2();
+  void removePhase2();
-  public boolean isRemoved();
+  boolean isRemoved();
-  public boolean isRemovedPhase2();
+  boolean isRemovedPhase2();
-  public boolean isTombstone();
+  boolean isTombstone();
+   *
-   * 
+   * @return false if map entry not found
+   *
-   * @return false if map entry not found
-  public boolean fillInValue(LocalRegion r,
-      @Retained(ABSTRACT_REGION_ENTRY_FILL_IN_VALUE) Entry entry, ByteArrayDataInput in, DM mgr,
-      final Version version);
+  boolean fillInValue(InternalRegion region,
+      @Retained(ABSTRACT_REGION_ENTRY_FILL_IN_VALUE) Entry entry, ByteArrayDataInput in,
+      DM distributionManager, final Version version);
-   * 
-   * @param dp if overflowed then the position of the value is set in dp
+   *
+   * @param diskPosition if overflowed then the position of the value is set in dp
-  public boolean isOverflowedToDisk(LocalRegion r, DistributedRegion.DiskPosition dp);
+  boolean isOverflowedToDisk(InternalRegion region, DistributedRegion.DiskPosition diskPosition);
-  public Object getKey();
+  Object getKey();
-  public Object getValue(RegionEntryContext context);
+  Object getValue(RegionEntryContext context);
-  public Object getValueRetain(RegionEntryContext context);
+  Object getValueRetain(RegionEntryContext context);
-  public void setValue(RegionEntryContext context, @Unretained Object value)
-      throws RegionClearedException;
+  void setValue(RegionEntryContext context, @Unretained Object value) throws RegionClearedException;
-  public void setValue(RegionEntryContext context, Object value, EntryEventImpl event)
+  void setValue(RegionEntryContext context, Object value, EntryEventImpl event)
-   * 
+   *
-   * 
+   *
-  public Object _getValueRetain(RegionEntryContext context, boolean decompress);
+  Object getValueRetain(RegionEntryContext context, boolean decompress);
-  /** Gets the value field of this entry. */
-
+  /**
+   * Gets the value field of this entry.
+   */
-  public Object _getValue();
+  Object getValue();
-  public Token getValueAsToken();
+  Token getValueAsToken();
-   * 
+   *
-  public void setValueWithTombstoneCheck(@Unretained Object value, EntryEvent event)
+  void setValueWithTombstoneCheck(@Unretained Object value, EntryEvent event)
-   * 
+   *
-  public Object getTransformedValue();
+  Object getTransformedValue();
-   * 
+   *
-   * @see LocalRegion#getValueInVM
+   * @see InternalRegion#getValueInVM
-  public Object getValueInVM(RegionEntryContext context);
+  Object getValueInVM(RegionEntryContext context);
-   * @see LocalRegion#getValueOnDisk
+   * @see InternalRegion#getValueOnDisk
-  public Object getValueOnDisk(LocalRegion r) throws EntryNotFoundException;
+  Object getValueOnDisk(InternalRegion region) throws EntryNotFoundException;
-   * @see LocalRegion#getValueOnDisk
+   * @see InternalRegion#getValueOnDisk
-  public Object getValueOnDiskOrBuffer(LocalRegion r) throws EntryNotFoundException;
-
+  Object getValueOnDiskOrBuffer(InternalRegion region) throws EntryNotFoundException;
-  public boolean initialImagePut(LocalRegion region, long lastModified, Object newValue,
+  boolean initialImagePut(InternalRegion region, long lastModified, Object newValue,
-   * getInitialImage. // put if LOCAL_INVALID and nonexistant // put if INVALID and nonexistant,
-   * recovered, or LOCAL_INVALID // put if valid and nonexistant, recovered, or LOCAL_INVALID // //
-   * REGION_INVALIDATED: (special case) // If the region itself has been invalidated since
-   * getInitialImage // started, and newValue is LOCAL_INVALID or valid, // then force creation of
-   * INVALID key if currently nonexistant // or invalidate if current recovered. // // must
-   * write-synchronize to protect agains puts from other // threads running this method
+   * getInitialImage.
+   *
+   * <p>
+   * put if LOCAL_INVALID and nonexistant<br>
+   * put if INVALID and nonexistant, recovered, or LOCAL_INVALID<br>
+   * put if valid and nonexistant, recovered, or LOCAL_INVALID
+   *
+   * <p>
+   * REGION_INVALIDATED: (special case)<br>
+   * If the region itself has been invalidated since getInitialImage<br>
+   * started, and newValue is LOCAL_INVALID or valid,<br>
+   * then force creation of INVALID key if currently nonexistent<br>
+   * or invalidate if current recovered.<br>
+   *
+   * <p>
+   * must write-synchronize to protect against puts from other<br>
+   * threads running this method
-  public boolean initialImageInit(LocalRegion region, long lastModified, Object newValue,
+  boolean initialImageInit(InternalRegion region, long lastModified, Object newValue,
-  public boolean destroy(LocalRegion region, EntryEventImpl event, boolean inTokenMode,
+  boolean destroy(InternalRegion region, EntryEventImpl event, boolean inTokenMode,
-  public boolean getValueWasResultOfSearch();
+  boolean getValueWasResultOfSearch();
-   * @param v true if entry's value should be marked as having been the result of a netsearch.
+   * @param value true if entry's value should be marked as having been the result of a netsearch.
-  public void setValueResultOfSearch(boolean v);
+  void setValueResultOfSearch(boolean value);
-   * 
-   * @param localRegion the persistent region
+   *
+   * @param region the persistent region
-  public Object getSerializedValueOnDisk(LocalRegion localRegion);
+  Object getSerializedValueOnDisk(InternalRegion region);
-  public Object getValueInVMOrDiskWithoutFaultIn(LocalRegion owner);
+  Object getValueInVMOrDiskWithoutFaultIn(InternalRegion region);
-  public Object getValueOffHeapOrDiskWithoutFaultIn(LocalRegion owner);
+  Object getValueOffHeapOrDiskWithoutFaultIn(InternalRegion region);
-  public boolean isUpdateInProgress();
+  boolean isUpdateInProgress();
-   *
-   * @param underUpdate
-  public void setUpdateInProgress(final boolean underUpdate);
+  void setUpdateInProgress(final boolean underUpdate);
-   * 
+   *
-  public boolean isCacheListenerInvocationInProgress();
+  boolean isCacheListenerInvocationInProgress();
-   * ONLY in {@link LocalRegion#dispatchListenerEvent}.
-   * 
-   * @param isListenerInvoked
+   * ONLY in {@link InternalRegion#dispatchListenerEvent}.
-  public void setCacheListenerInvocationInProgress(final boolean isListenerInvoked);
+  void setCacheListenerInvocationInProgress(final boolean isListenerInvoked);
-  public boolean isValueNull();
+  boolean isValueNull();
-  public boolean isInvalid();
+  boolean isInvalid();
-  public boolean isDestroyed();
+  boolean isDestroyed();
-  public boolean isDestroyedOrRemoved();
+  boolean isDestroyedOrRemoved();
-  public boolean isDestroyedOrRemovedButNotTombstone();
+  boolean isDestroyedOrRemovedButNotTombstone();
-  public boolean isInvalidOrRemoved();
+  boolean isInvalidOrRemoved();
-  public void setValueToNull();
+  void setValueToNull();
-  public void returnToPool();
+  void returnToPool();
-  public boolean isInUseByTransaction();
-
-  public void setInUseByTransaction(final boolean v);
+  boolean isInUseByTransaction();
-  public void incRefCount();
+  void incRefCount();
-   * 
-   * @param lr the local region that owns this region entry; null if no local region owner
+   *
+   * @param region the local region that owns this region entry; null if no local region owner
-  public void decRefCount(NewLRUClockHand lruList, LocalRegion lr);
+  void decRefCount(EvictionList lruList, InternalRegion region);
-  public void resetRefCount(NewLRUClockHand lruList);
+  void resetRefCount(EvictionList lruList);
-  public Object prepareValueForCache(RegionEntryContext r, Object val, boolean isEntryUpdate);
+  Object prepareValueForCache(RegionEntryContext context, Object value, boolean isEntryUpdate);
-  public Object prepareValueForCache(RegionEntryContext r, Object val, EntryEventImpl event,
+  Object prepareValueForCache(RegionEntryContext context, Object value, EntryEventImpl event,

UPD40 INS31 INS39 INS42 MOV43 INS29 UPD83 INS39 INS42 INS44 INS8 INS44 MOV65 UPD42 UPD42 MOV79 MOV44 MOV79 MOV44 INS66 INS66 INS66 INS65 INS39 INS42 UPD43 INS43 INS42 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD42 UPD43 UPD42 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD43 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD43 UPD42 UPD43 UPD42 UPD42 UPD42 UPD42 INS66 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD66 UPD42 UPD42 UPD42 UPD42 UPD66 UPD42 UPD42 UPD42 INS66 INS66 INS66 UPD66 UPD66 INS66 INS66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 INS66 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL83 DEL83 DEL39 DEL42 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL65 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL65 DEL83 DEL83 DEL42 DEL65 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL39 DEL42 DEL83 DEL39 DEL42 DEL44 DEL31 DEL83 DEL83 DEL83 DEL83 DEL83
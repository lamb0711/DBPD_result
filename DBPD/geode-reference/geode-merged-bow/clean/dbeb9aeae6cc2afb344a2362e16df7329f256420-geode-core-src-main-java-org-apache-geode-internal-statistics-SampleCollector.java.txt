Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import edu.umd.cs.findbugs.annotations.SuppressWarnings;
+
+import org.apache.geode.internal.io.RollingFileHandler;
- * Captures sample of statistics. The SampleCollector contains maps of 
- * StatisticsTypes to ResourceTypes and Statistics instances to 
- * ResourceInstances, each of which contains the actual stat values of the 
- * sample. The {@link #sample(long)} operation determines what stats have 
- * changed, adds in new types and instances, and updates the sampled stat 
- * values.
+ * Captures sample of statistics. The SampleCollector contains maps of StatisticsTypes to
+ * ResourceTypes and Statistics instances to ResourceInstances, each of which contains the actual
+ * stat values of the sample. The {@link #sample(long)} operation determines what stats have
+ * changed, adds in new types and instances, and updates the sampled stat values.
- * SampleHandlers are registered with the SampleCollector. The handlers are
- * notified of any changes to statistics.
+ * SampleHandlers are registered with the SampleCollector. The handlers are notified of any changes
+ * to statistics.
-  
-  /** 
-   * Singleton instance of SampleCollector set during initialization. This
-   * field simply points to the latest initialized instance. 
+
+  /**
+   * Singleton instance of SampleCollector set during initialization. This field simply points to
+   * the latest initialized instance.
-  
+
-  
+
-  
-  /** 
-   * Map of StatisticsType to ResourceType. Contains all currently known 
-   * statistics types.
+
+  /**
+   * Map of StatisticsType to ResourceType. Contains all currently known statistics types.
-  private final Map<StatisticsType, ResourceType> resourceTypeMap = 
+  private final Map<StatisticsType, ResourceType> resourceTypeMap =
-  
-  /** 
-   * Map of Statistics to ResourceInstance. Contains all currently known 
-   * statistics resources. 
+
+  /**
+   * Map of Statistics to ResourceInstance. Contains all currently known statistics resources.
-  private final Map<Statistics, ResourceInstance> resourceInstMap = 
+  private final Map<Statistics, ResourceInstance> resourceInstMap =
-  
+
-  
+
-  
+
-  
+
-   * Returns the {@link StatMonitorHandler}. If one does not currently exist
-   * it will be created.
+   * Returns the {@link StatMonitorHandler}. If one does not currently exist it will be created.
-   * @throws IllegalStateException if no SampleCollector has been created and
-   * initialized yet
+   * @throws IllegalStateException if no SampleCollector has been created and initialized yet
-  public static StatMonitorHandler getStatMonitorHandler() {
+  static StatMonitorHandler getStatMonitorHandler() {
-  
+
-   * Initializes this collector by creating a {@link StatArchiveHandler} and
-   * registering it as a handler.
+   * Initializes this collector by creating a {@link StatArchiveHandler} and registering it as a
+   * handler.
+   * @param rollingFileHandler provides file rolling behavior
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD", justification="There is never more than one SampleCollector instance.") 
-  public void initialize(StatArchiveHandlerConfig config, long nanosTimeStamp) {
+  @SuppressWarnings(value = "ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD",
+      justification = "There is never more than one SampleCollector instance.")
+  public void initialize(final StatArchiveHandlerConfig config, final long nanosTimeStamp,
+      final RollingFileHandler rollingFileHandler) {
-        StatArchiveHandler newStatArchiveHandler = new StatArchiveHandler(config, this);
+        StatArchiveHandler newStatArchiveHandler =
+            new StatArchiveHandler(config, this, rollingFileHandler);
-  
+
-  
+
-  
+
-  
+
-  
+
-   * Collect a sample of all statistics. Adds new statistics resources,
-   * removes destroyed statistics resources, collects the latest stat values,
-   * and notifies SamplerHandlers of the sample.
+   * Collect a sample of all statistics. Adds new statistics resources, removes destroyed statistics
+   * resources, collects the latest stat values, and notifies SamplerHandlers of the sample.
-   * The timeStamp is an arbitrary nanoseconds time stamp only used for
-   * archiving to stats files. The initial time in system milliseconds and the
-   * first NanoTimer timeStamp are both written to the archive file. Thereafter
-   * only the NanoTimer timeStamp is written to the archive file for each
-   * sample. The delta in nanos can be determined by comparing any nano 
-   * timeStamp to the first nano timeStamp written to the archive file. Adding 
-   * this delta to the recorded initial time in milliseconds provides the 
-   * actual (non-arbitrary) time for each sample.
+   * The timeStamp is an arbitrary nanoseconds time stamp only used for archiving to stats files.
+   * The initial time in system milliseconds and the first NanoTimer timeStamp are both written to
+   * the archive file. Thereafter only the NanoTimer timeStamp is written to the archive file for
+   * each sample. The delta in nanos can be determined by comparing any nano timeStamp to the first
+   * nano timeStamp written to the archive file. Adding this delta to the recorded initial time in
+   * milliseconds provides the actual (non-arbitrary) time for each sample.
-   * @param nanosTimeStamp an arbitrary time stamp in nanoseconds for this 
-   * sample
+   * @param nanosTimeStamp an arbitrary time stamp in nanoseconds for this sample
-      logger.trace(LogMarker.STATISTICS, "SampleCollector#sample nanosTimeStamp={}", nanosTimeStamp);
+      logger.trace(LogMarker.STATISTICS, "SampleCollector#sample nanosTimeStamp={}",
+          nanosTimeStamp);
-    
+
-      
+
-      
+
-        
+
-            updatedStats[updatedStatsIdx] = i; 
+            updatedStats[updatedStatsIdx] = i;
-      
+
-      logger.warn(LogMarker.STATISTICS, "Use of java.lang.System.nanoTime() resulted in a non-positive timestamp delta. Skipping notification of statistics sample.", e);
+      logger.warn(LogMarker.STATISTICS,
+          "Use of java.lang.System.nanoTime() resulted in a non-positive timestamp delta. Skipping notification of statistics sample.",
+          e);
-    
+
-  
+
-          StatArchiveHandler handler = this.statArchiveHandler; 
+          StatArchiveHandler handler = this.statArchiveHandler;
-          logger.warn(LogMarker.STATISTICS, LocalizedMessage.create(LocalizedStrings.HostStatSampler_STATISTIC_ARCHIVER_SHUTDOWN_FAILED_BECAUSE__0, ignore.getMessage()));
+          logger.warn(LogMarker.STATISTICS,
+              LocalizedMessage.create(
+                  LocalizedStrings.HostStatSampler_STATISTIC_ARCHIVER_SHUTDOWN_FAILED_BECAUSE__0,
+                  ignore.getMessage()));
-      if(instance == this) {
+      if (instance == this) {
-  
+
-        logger.trace(LogMarker.STATISTICS, "SampleCollector#changeArchive newFile={}, nanosTimeStamp={}", newFile, nanosTimeStamp);
+        logger.trace(LogMarker.STATISTICS,
+            "SampleCollector#changeArchive newFile={}, nanosTimeStamp={}", newFile, nanosTimeStamp);
-      StatArchiveHandler handler = this.statArchiveHandler; 
+      StatArchiveHandler handler = this.statArchiveHandler;
-  
+
-  
+
-  public StatArchiveHandler getStatArchiveHandler() {
+  StatArchiveHandler getStatArchiveHandler() {
-  
+
-    if (this.statResourcesModCount != newModCount) { // TODO: what if one is deleted and one is added?
+    if (this.statResourcesModCount != newModCount) { // TODO: what if one is deleted and one is
+                                                     // added?
-      
+
-      for (int i=0; i < resources.length; i++) {
+      for (int i = 0; i < resources.length; i++) {
-        
+
-      
+
-        logger.trace(LogMarker.STATISTICS, "SampleCollector#sampleResources resources.length={}, ignoreCount={}", resources.length, ignoreCount);
+        logger.trace(LogMarker.STATISTICS,
+            "SampleCollector#sampleResources resources.length={}, ignoreCount={}", resources.length,
+            ignoreCount);
-      
+
-    notifyNewHandlersOfResources(handlers, this.resourceInstMap.values());
+    notifyNewHandlersOfResources(handlers, this.resourceTypeMap.values(),
+        this.resourceInstMap.values());
-  
-  private ResourceType getResourceType(List<MarkableSampleHandler> handlers, 
-      Statistics statistics) throws IgnoreResourceException {
+
+  private ResourceType getResourceType(List<MarkableSampleHandler> handlers, Statistics statistics)
+      throws IgnoreResourceException {
-      logger.trace(LogMarker.STATISTICS, "SampleCollector#getResourceType statistics={}", statistics);
+      logger.trace(LogMarker.STATISTICS, "SampleCollector#getResourceType statistics={}",
+          statistics);
-        logger.trace(LogMarker.STATISTICS, "SampleCollector#getResourceType type={}, throwing IgnoreResourceException", type);
+        logger.trace(LogMarker.STATISTICS,
+            "SampleCollector#getResourceType type={}, throwing IgnoreResourceException", type);
-      resourceType = (ResourceType)this.resourceTypeMap.get(type);
+      resourceType = (ResourceType) this.resourceTypeMap.get(type);
-        logger.trace(LogMarker.STATISTICS, "SampleCollector#getResourceType resourceTypeMap.get threw NPE, throwing NullPointerException");
+        logger.trace(LogMarker.STATISTICS,
+            "SampleCollector#getResourceType resourceTypeMap.get threw NPE, throwing NullPointerException");
-  private ResourceType allocateResourceType(List<MarkableSampleHandler> handlers, 
+  private ResourceType allocateResourceType(List<MarkableSampleHandler> handlers,
-  
+
-      logger.trace(LogMarker.STATISTICS, "SampleCollector#allocateResourceInstance type={}, s={}", type, s);
+      logger.trace(LogMarker.STATISTICS, "SampleCollector#allocateResourceInstance type={}, s={}",
+          type, s);
-      logger.trace(LogMarker.STATISTICS, "SampleCollector#cleanupResources resources.length={}, ignoreCount={}", resources.length, ignoreCount);
+      logger.trace(LogMarker.STATISTICS,
+          "SampleCollector#cleanupResources resources.length={}, ignoreCount={}", resources.length,
+          ignoreCount);
-      logger.trace(LogMarker.STATISTICS, "SampleCollector#cleanupResources resourcesToDelete={}", resourcesToDelete);
+      logger.trace(LogMarker.STATISTICS, "SampleCollector#cleanupResources resourcesToDelete={}",
+          resourcesToDelete);
-    
+
-    Iterator<Map.Entry<Statistics, ResourceInstance>> it = 
+    Iterator<Map.Entry<Statistics, ResourceInstance>> it =
-    
+
-      Statistics key = (Statistics)e.getKey();
+      Statistics key = (Statistics) e.getKey();
-        ResourceInstance inst = (ResourceInstance)e.getValue();
+        ResourceInstance inst = (ResourceInstance) e.getValue();
-      logger.trace(LogMarker.STATISTICS, "SampleCollector#cleanupResources resourcesRemoved={}", resourcesRemoved);
+      logger.trace(LogMarker.STATISTICS, "SampleCollector#cleanupResources resourcesRemoved={}",
+          resourcesRemoved);
-  
-  private void notifyAllHandlersOfSample(List<MarkableSampleHandler> handlers, 
-                                         List<ResourceInstance> updatedResources, 
-                                         long nanosTimeStamp) {
+
+  private void notifyAllHandlersOfSample(List<MarkableSampleHandler> handlers,
+      List<ResourceInstance> updatedResources, long nanosTimeStamp) {
-      logger.trace(LogMarker.STATISTICS, "SampleCollector#notifyAllHandlersOfSample timeStamp={}", nanosTimeStamp);
+      logger.trace(LogMarker.STATISTICS, "SampleCollector#notifyAllHandlersOfSample timeStamp={}",
+          nanosTimeStamp);
-//    List<ResourceInstance> ri = new ArrayList<ResourceInstance>();
-//    for (ResourceInstance resource : this.resourceInstMap.values()) {
-//      if (!ri.contains(resource)) {
-//        ri.add(resource);
-//      }
-//    }
+    // List<ResourceInstance> ri = new ArrayList<ResourceInstance>();
+    // for (ResourceInstance resource : this.resourceInstMap.values()) {
+    // if (!ri.contains(resource)) {
+    // ri.add(resource);
+    // }
+    // }
-      logger.trace(LogMarker.STATISTICS, "SampleCollector#notifyAllHandlersOfSample updatedResources.size()={}, handlers={}", updatedResources.size(), handlers);
+      logger.trace(LogMarker.STATISTICS,
+          "SampleCollector#notifyAllHandlersOfSample updatedResources.size()={}, handlers={}",
+          updatedResources.size(), handlers);
-  
-  private void notifyNewHandlersOfResources(List<MarkableSampleHandler> handlers, 
-      Collection<ResourceInstance> resources) {
+
+  private void notifyNewHandlersOfResources(List<MarkableSampleHandler> handlers,
+      Collection<ResourceType> types, Collection<ResourceInstance> resources) {
-      logger.trace(LogMarker.STATISTICS, "SampleCollector#notifyNewHandlersOfResources ri.size()={}", resources.size());
+      logger.trace(LogMarker.STATISTICS,
+          "SampleCollector#notifyNewHandlersOfResources ri.size()={}", resources.size());
+        for (ResourceType resourceType : types) {
+          if (!allocatedResourceTypes.contains(resourceType)) {
+            handler.allocatedResourceType(resourceType);
+          }
+        }
-      logger.trace(LogMarker.STATISTICS, "SampleCollector#notifyNewHandlersOfResources notified {} new handlers", count);
+      logger.trace(LogMarker.STATISTICS,
+          "SampleCollector#notifyNewHandlersOfResources notified {} new handlers", count);
-  private void notifyOldHandlersOfResource(List<MarkableSampleHandler> handlers, 
-        ResourceInstance resource) {
+  private void notifyOldHandlersOfResource(List<MarkableSampleHandler> handlers,
+      ResourceInstance resource) {
-      logger.trace(LogMarker.STATISTICS, "SampleCollector#notifyOldHandlersOfResource resource={}", resource);
+      logger.trace(LogMarker.STATISTICS, "SampleCollector#notifyOldHandlersOfResource resource={}",
+          resource);
-      logger.trace(LogMarker.STATISTICS, "SampleCollector#notifyOldHandlersOfResource notified {} old handlers", count);
+      logger.trace(LogMarker.STATISTICS,
+          "SampleCollector#notifyOldHandlersOfResource notified {} old handlers", count);
-        ResourceType type) {
+      ResourceType type) {
-      logger.trace(LogMarker.STATISTICS, "SampleCollector#notifyOldHandlersOfResourceType type={}", type);
+      logger.trace(LogMarker.STATISTICS, "SampleCollector#notifyOldHandlersOfResourceType type={}",
+          type);
-      logger.trace(LogMarker.STATISTICS, "SampleCollector#notifyOldHandlersOfResourceType notified {} old handlers", count);
+      logger.trace(LogMarker.STATISTICS,
+          "SampleCollector#notifyOldHandlersOfResourceType notified {} old handlers", count);
-  private void notifyOldHandlers(List<MarkableSampleHandler> handlers, 
-        List<ResourceInstance> ri) {
+  private void notifyOldHandlers(List<MarkableSampleHandler> handlers, List<ResourceInstance> ri) {
-      logger.trace(LogMarker.STATISTICS, "SampleCollector#notifyOldHandlers notified {} old handlers", count);
+      logger.trace(LogMarker.STATISTICS,
+          "SampleCollector#notifyOldHandlers notified {} old handlers", count);
-  
+
-    
+
-    
+
-        logger.trace(LogMarker.STATISTICS, "MarkableSampleHandler#isMarked returning {} for {}", this.mark, this);
+        logger.trace(LogMarker.STATISTICS, "MarkableSampleHandler#isMarked returning {} for {}",
+            this.mark, this);
-    
+
-    
+
-    
+
-    
+
-      if (this == obj) return true;
-      if (obj == null) return false;
-      if (getClass() != obj.getClass()) return false;
+      if (this == obj)
+        return true;
+      if (obj == null)
+        return false;
+      if (getClass() != obj.getClass())
+        return false;
-    
+
-  
+
-    private volatile List<MarkableSampleHandler> currentHandlers = 
+    private volatile List<MarkableSampleHandler> currentHandlers =
-    public SampleHandlers() {
-    }
-    
+    public SampleHandlers() {}
+
-    
+
-    
+
-    
-    @Override   
+
+    @Override
-    
+
-          logger.trace(LogMarker.STATISTICS, "SampleHandlers#addSampleHandler adding markableHandler to {}", this);
-          List<MarkableSampleHandler> newHandlers = 
+          logger.trace(LogMarker.STATISTICS,
+              "SampleHandlers#addSampleHandler adding markableHandler to {}", this);
+          List<MarkableSampleHandler> newHandlers =
-    
+
-            logger.trace(LogMarker.STATISTICS, "SampleHandlers#removeSampleHandler removing markableHandler from {}", this);
+            logger.trace(LogMarker.STATISTICS,
+                "SampleHandlers#removeSampleHandler removing markableHandler from {}", this);
-          List<MarkableSampleHandler> newHandlers = 
+          List<MarkableSampleHandler> newHandlers =
-    
+
-    
+
-      
+
-      
+
-        List<MarkableSampleHandler> matchingHandlers =
-            new ArrayList<MarkableSampleHandler>();
+        List<MarkableSampleHandler> matchingHandlers = new ArrayList<MarkableSampleHandler>();
-      
+
-      
+
-      
+

INS26 INS26 INS40 INS40 INS44 INS44 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS65 INS42 INS83 INS83 INS83 INS43 INS42 INS74 INS42 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 INS66 INS42 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS43 INS43 INS32 INS42 INS42 INS22 INS42 INS52 INS42 INS70 MOV43 INS44 INS42 INS8 INS43 INS42 INS25 MOV43 INS42 INS42 INS38 INS8 INS32 INS21 INS42 INS42 INS42 INS32 INS42 INS42 INS42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL83 DEL40 DEL66 DEL66 DEL66 DEL66 DEL83
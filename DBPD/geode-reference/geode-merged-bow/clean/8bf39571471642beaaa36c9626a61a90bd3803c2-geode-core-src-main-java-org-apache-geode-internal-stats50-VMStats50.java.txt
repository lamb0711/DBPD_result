Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Statistics related to a Java VM.
- * This version is hardcoded to use 1.5 MXBean stats from java.lang.management.
+ * Statistics related to a Java VM. This version is hardcoded to use 1.5 MXBean stats from
+ * java.lang.management.
-   * This is actually an instance of UnixOperatingSystemMXBean but this class
-   * is not available on Windows so needed to make this a runtime check.
+   * This is actually an instance of UnixOperatingSystemMXBean but this class is not available on
+   * Windows so needed to make this a runtime check.
-  private final static Method getProcessCpuTime;  
+  private final static Method getProcessCpuTime;
-  
+
-  private final Map<GarbageCollectorMXBean,Statistics> gcMap = new HashMap<GarbageCollectorMXBean,Statistics>();
+  private final Map<GarbageCollectorMXBean, Statistics> gcMap =
+      new HashMap<GarbageCollectorMXBean, Statistics>();
-//   private final static int mp_gc_initMemoryId;
-//   private final static int mp_gc_maxMemoryId;
+  // private final static int mp_gc_initMemoryId;
+  // private final static int mp_gc_maxMemoryId;
-//   private final static int mp_gc_committedMemoryId;
+  // private final static int mp_gc_committedMemoryId;
-  private final Map<MemoryPoolMXBean,Statistics> mpMap = new HashMap<MemoryPoolMXBean,Statistics>();
+  private final Map<MemoryPoolMXBean, Statistics> mpMap =
+      new HashMap<MemoryPoolMXBean, Statistics>();
-  private final static boolean THREAD_STATS_ENABLED = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "enableThreadStats");
-  private final Map<Long,ThreadStatInfo> threadMap = THREAD_STATS_ENABLED ? new HashMap<Long,ThreadStatInfo>() : null;
+  private final static boolean THREAD_STATS_ENABLED =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "enableThreadStats");
+  private final Map<Long, ThreadStatInfo> threadMap =
+      THREAD_STATS_ENABLED ? new HashMap<Long, ThreadStatInfo>() : null;
-        Class c = ClassPathLoader.getLatest().forName("com.sun.management.UnixOperatingSystemMXBean");
+        Class c =
+            ClassPathLoader.getLatest().forName("com.sun.management.UnixOperatingSystemMXBean");
-          m1 = c.getMethod("getMaxFileDescriptorCount", new Class[]{});
-          m2 = c.getMethod("getOpenFileDescriptorCount", new Class[]{});
+          m1 = c.getMethod("getMaxFileDescriptorCount", new Class[] {});
+          m2 = c.getMethod("getOpenFileDescriptorCount", new Class[] {});
-        m3 = osBean.getClass().getMethod("getProcessCpuTime", new Class[]{});
-        if (m3!=null) {
-          m3.setAccessible( true );
+        m3 = osBean.getClass().getMethod("getProcessCpuTime", new Class[] {});
+        if (m3 != null) {
+          m3.setAccessible(true);
-      }
-      catch (VirtualMachineError err) {
-	SystemFailure.initiateFailure(err);
-	// If this ever returns, rethrow the error.  We're poisoned
-	// now, so don't let this thread continue.
-	throw err;
-      }
-     catch (Throwable ex) {
-          // Whenever you catch Error or Throwable, you must also
-          // catch VirtualMachineError (see above).  However, there is
-          // _still_ a possibility that you are dealing with a cascading
-          // error condition, so you also need to check to see if the JVM
-          // is still usable:
-          SystemFailure.checkFailure();
+      } catch (VirtualMachineError err) {
+        SystemFailure.initiateFailure(err);
+        // If this ever returns, rethrow the error. We're poisoned
+        // now, so don't let this thread continue.
+        throw err;
+      } catch (Throwable ex) {
+        // Whenever you catch Error or Throwable, you must also
+        // catch VirtualMachineError (see above). However, there is
+        // _still_ a possibility that you are dealing with a cascading
+        // error condition, so you also need to check to see if the JVM
+        // is still usable:
+        SystemFailure.checkFailure();
-                             "Number of objects that are pending finalization in the java VM.",
-                             "objects"));
-    sds.add(f.createIntGauge("daemonThreads",
-                             "Current number of live daemon threads in this VM.",
-                             "threads"));
+        "Number of objects that are pending finalization in the java VM.", "objects"));
+    sds.add(f.createIntGauge("daemonThreads", "Current number of live daemon threads in this VM.",
+        "threads"));
-                             "Current number of live threads (both daemon and non-daemon) in this VM.",
-                             "threads"));
-    sds.add(f.createIntGauge("peakThreads",
-                             "High water mark of live threads in this VM.",
-                             "threads"));
+        "Current number of live threads (both daemon and non-daemon) in this VM.", "threads"));
+    sds.add(
+        f.createIntGauge("peakThreads", "High water mark of live threads in this VM.", "threads"));
-                                "Total number of times a thread has been started since this vm started.",
-                                "threads"));
-    sds.add(f.createIntGauge("cpus",
-                             "Number of cpus available to the java VM on its machine.",
-                             "cpus", true));
-    sds.add(f.createLongCounter("loadedClasses",
-                                "Total number of classes loaded since vm started.",
-                                "classes"));
+        "Total number of times a thread has been started since this vm started.", "threads"));
+    sds.add(f.createIntGauge("cpus", "Number of cpus available to the java VM on its machine.",
+        "cpus", true));
+    sds.add(f.createLongCounter("loadedClasses", "Total number of classes loaded since vm started.",
+        "classes"));
-                                "Total number of classes unloaded since vm started.",
-                                "classes", true));
+        "Total number of classes unloaded since vm started.", "classes", true));
-                              "An approximation fo the total amount of memory currently available for future allocated objects, measured in bytes.",
-                              "bytes", true));
+        "An approximation fo the total amount of memory currently available for future allocated objects, measured in bytes.",
+        "bytes", true));
-                              "The total amount of memory currently available for current and future objects, measured in bytes.",
-                              "bytes"));
+        "The total amount of memory currently available for current and future objects, measured in bytes.",
+        "bytes"));
-                              "The maximum amount of memory that the VM will attempt to use, measured in bytes.",
-                              "bytes", true));
-   sds.add(f.createLongCounter("processCpuTime",
-                              "CPU timed used by the process in nanoseconds.",
-                              "nanoseconds"));
+        "The maximum amount of memory that the VM will attempt to use, measured in bytes.", "bytes",
+        true));
+    sds.add(f.createLongCounter("processCpuTime", "CPU timed used by the process in nanoseconds.",
+        "nanoseconds"));
-      sds.add(f.createLongGauge("fdLimit",
-                                "Maximum number of file descriptors",
-                                "fds", true));
-      sds.add(f.createLongGauge("fdsOpen",
-                                "Current number of open file descriptors",
-                                "fds"));
+      sds.add(f.createLongGauge("fdLimit", "Maximum number of file descriptors", "fds", true));
+      sds.add(f.createLongGauge("fdsOpen", "Current number of open file descriptors", "fds"));
-    vmType = f.createType("VMStats",
-                          "Stats available on a 1.5 java virtual machine.",
-                          sds.toArray(new StatisticDescriptor[sds.size()]));
+    vmType = f.createType("VMStats", "Stats available on a 1.5 java virtual machine.",
+        sds.toArray(new StatisticDescriptor[sds.size()]));
-    memoryUsageType = f.createType("VMMemoryUsageStats",
-                          "Stats available on a 1.5 memory usage area",
-                          new StatisticDescriptor[] {
-                            f.createLongGauge("initMemory",
-                                              "Initial memory the vm requested from the operating system for this area",
-                                              "bytes"),
-                            f.createLongGauge("maxMemory",
-                                              "The maximum amount of memory this area can have in bytes.",
-                                              "bytes"),
-                            f.createLongGauge("usedMemory",
-                                              "The amount of used memory for this area, measured in bytes.",
-                                              "bytes"),
-                            f.createLongGauge("committedMemory",
-                                              "The amount of committed memory for this area, measured in bytes.",
-                                              "bytes")
-                          });
+    memoryUsageType =
+        f.createType("VMMemoryUsageStats", "Stats available on a 1.5 memory usage area",
+            new StatisticDescriptor[] {f.createLongGauge("initMemory",
+                "Initial memory the vm requested from the operating system for this area", "bytes"),
+                f.createLongGauge("maxMemory",
+                    "The maximum amount of memory this area can have in bytes.", "bytes"),
+                f.createLongGauge("usedMemory",
+                    "The amount of used memory for this area, measured in bytes.", "bytes"),
+                f.createLongGauge("committedMemory",
+                    "The amount of committed memory for this area, measured in bytes.", "bytes")});
-    gcType = f.createType("VMGCStats",
-                          "Stats available on a 1.5 garbage collector",
-                          new StatisticDescriptor[] {
-                            f.createLongCounter("collections",
-                                              "Total number of collections this garbage collector has done.",
-                                              "operations"),
-                            f.createLongCounter("collectionTime",
-                                              "Approximate elapsed time spent doing collections by this garbage collector.",
-                                              "milliseconds"),
-                          });
+    gcType = f.createType("VMGCStats", "Stats available on a 1.5 garbage collector",
+        new StatisticDescriptor[] {
+            f.createLongCounter("collections",
+                "Total number of collections this garbage collector has done.", "operations"),
+            f.createLongCounter("collectionTime",
+                "Approximate elapsed time spent doing collections by this garbage collector.",
+                "milliseconds"),});
-    mpType = f.createType("VMMemoryPoolStats",
-                          "Stats available on a 1.5 memory pool",
-                          new StatisticDescriptor[] {
-                            f.createLongGauge("currentInitMemory",
-                                              "Initial memory the vm requested from the operating system for this pool",
-                                              "bytes"),
-                            f.createLongGauge("currentMaxMemory",
-                                              "The maximum amount of memory this pool can have in bytes.",
-                                              "bytes"),
-                            f.createLongGauge("currentUsedMemory",
-                                              "The estimated amount of used memory currently in use for this pool, measured in bytes.",
-                                              "bytes"),
-                            f.createLongGauge("currentCommittedMemory",
-                                              "The amount of committed memory for this pool, measured in bytes.",
-                                              "bytes"),
-//                             f.createLongGauge("collectionInitMemory",
-//                                               "Initial memory the vm requested from the operating system for this pool",
-//                                               "bytes"),
-//                             f.createLongGauge("collectionMaxMemory",
-//                                               "The maximum amount of memory this pool can have in bytes.",
-//                                               "bytes"),
-                            f.createLongGauge("collectionUsedMemory",
-                                              "The estimated amount of used memory after that last garbage collection of this pool, measured in bytes.",
-                                              "bytes"),
-//                             f.createLongGauge("collectionCommittedMemory",
-//                                               "The amount of committed memory for this pool, measured in bytes.",
-//                                               "bytes"),
-                            f.createLongGauge("collectionUsageThreshold",
-                                              "The collection usage threshold for this pool in bytes",
-                                              "bytes"),
-                            f.createLongCounter("collectionUsageExceeded",
-                                                "Total number of times the garbage collector detected that memory usage in this pool exceeded the collectionUsageThreshold",
-                                                "exceptions"),
-                            f.createLongGauge("usageThreshold",
-                                              "The usage threshold for this pool in bytes",
-                                              "bytes"),
-                            f.createLongCounter("usageExceeded",
-                                                "Total number of times that memory usage in this pool exceeded the usageThreshold",
-                                                "exceptions")
-                          });
+    mpType =
+        f.createType("VMMemoryPoolStats", "Stats available on a 1.5 memory pool",
+            new StatisticDescriptor[] {f.createLongGauge("currentInitMemory",
+                "Initial memory the vm requested from the operating system for this pool", "bytes"),
+                f.createLongGauge("currentMaxMemory",
+                    "The maximum amount of memory this pool can have in bytes.", "bytes"),
+                f.createLongGauge("currentUsedMemory",
+                    "The estimated amount of used memory currently in use for this pool, measured in bytes.",
+                    "bytes"),
+                f.createLongGauge("currentCommittedMemory",
+                    "The amount of committed memory for this pool, measured in bytes.", "bytes"),
+                // f.createLongGauge("collectionInitMemory",
+                // "Initial memory the vm requested from the operating system for this pool",
+                // "bytes"),
+                // f.createLongGauge("collectionMaxMemory",
+                // "The maximum amount of memory this pool can have in bytes.",
+                // "bytes"),
+                f.createLongGauge("collectionUsedMemory",
+                    "The estimated amount of used memory after that last garbage collection of this pool, measured in bytes.",
+                    "bytes"),
+                // f.createLongGauge("collectionCommittedMemory",
+                // "The amount of committed memory for this pool, measured in bytes.",
+                // "bytes"),
+                f.createLongGauge("collectionUsageThreshold",
+                    "The collection usage threshold for this pool in bytes", "bytes"),
+                f.createLongCounter("collectionUsageExceeded",
+                    "Total number of times the garbage collector detected that memory usage in this pool exceeded the collectionUsageThreshold",
+                    "exceptions"),
+                f.createLongGauge("usageThreshold", "The usage threshold for this pool in bytes",
+                    "bytes"),
+                f.createLongCounter("usageExceeded",
+                    "Total number of times that memory usage in this pool exceeded the usageThreshold",
+                    "exceptions")});
-    //mp_gc_initMemoryId = mpType.nameToId("collectionInitMemory");
-    //mp_gc_maxMemoryId = mpType.nameToId("collectionMaxMemory");
+    // mp_gc_initMemoryId = mpType.nameToId("collectionInitMemory");
+    // mp_gc_maxMemoryId = mpType.nameToId("collectionMaxMemory");
-    //mp_gc_committedMemoryId = mpType.nameToId("collectionCommittedMemory");
+    // mp_gc_committedMemoryId = mpType.nameToId("collectionCommittedMemory");
-      threadType = f.createType("VMThreadStats",
-                                "Stats available on a 1.5 thread",
-                                new StatisticDescriptor[] {
-                                  f.createLongCounter("blocked",
-                                                      "Total number of times this thread blocked to enter or reenter a monitor",
-                                                      "operations"),
-                                  f.createLongCounter("blockedTime",
-                                                      "Total amount of elapsed time, approximately, that this thread has spent blocked to enter or reenter a monitor. May need to be enabled by setting -Dgemfire.enableContentionTime=true",
-                                                      "milliseconds"),
-                                  f.createLongGauge("lockOwner",
-                                                    "The thread id that owns the lock that this thread is blocking on.",
-                                                    "threadId"),
-                                  f.createIntGauge("inNative",
-                                                   "1 if the thread is in native code.",
-                                                   "boolean"),
-                                  f.createIntGauge("suspended",
-                                                   "1 if this thread is suspended",
-                                                   "boolean"),
-                                  f.createLongCounter("waited",
-                                                      "Total number of times this thread waited for notification.",
-                                                      "operations"),
-                                  f.createLongCounter("waitedTime",
-                                                      "Total amount of elapsed time, approximately, that this thread has spent waiting for notification. May need to be enabled by setting -Dgemfire.enableContentionTime=true",
-                                                      "milliseconds"),
-                                  f.createLongCounter("cpuTime",
-                                                      "Total cpu time for this thread.  May need to be enabled by setting -Dgemfire.enableCpuTime=true.",
-                                                      "nanoseconds"),
-                                  f.createLongCounter("userTime",
-                                                      "Total user time for this thread. May need to be enabled by setting -Dgemfire.enableCpuTime=true.",
-                                                      "nanoseconds"),
-                                });
+      threadType = f.createType("VMThreadStats", "Stats available on a 1.5 thread",
+          new StatisticDescriptor[] {
+              f.createLongCounter("blocked",
+                  "Total number of times this thread blocked to enter or reenter a monitor",
+                  "operations"),
+              f.createLongCounter("blockedTime",
+                  "Total amount of elapsed time, approximately, that this thread has spent blocked to enter or reenter a monitor. May need to be enabled by setting -Dgemfire.enableContentionTime=true",
+                  "milliseconds"),
+              f.createLongGauge("lockOwner",
+                  "The thread id that owns the lock that this thread is blocking on.", "threadId"),
+              f.createIntGauge("inNative", "1 if the thread is in native code.", "boolean"),
+              f.createIntGauge("suspended", "1 if this thread is suspended", "boolean"),
+              f.createLongCounter("waited",
+                  "Total number of times this thread waited for notification.", "operations"),
+              f.createLongCounter("waitedTime",
+                  "Total amount of elapsed time, approximately, that this thread has spent waiting for notification. May need to be enabled by setting -Dgemfire.enableContentionTime=true",
+                  "milliseconds"),
+              f.createLongCounter("cpuTime",
+                  "Total cpu time for this thread.  May need to be enabled by setting -Dgemfire.enableCpuTime=true.",
+                  "nanoseconds"),
+              f.createLongCounter("userTime",
+                  "Total user time for this thread. May need to be enabled by setting -Dgemfire.enableCpuTime=true.",
+                  "nanoseconds"),});
-  
+
-    initMemoryPools();  //Fix for #40424
+    initMemoryPools(); // Fix for #40424
+
-    for (int i=0; i < threadInfos.length; i++) {
+    for (int i = 0; i < threadInfos.length; i++) {
-          threadMap.put(id, new ThreadStatInfo(item, this.f.createStatistics(threadType, item.getThreadName()+'-'+ item.getThreadId(), this.id)));
+          threadMap.put(id, new ThreadStatInfo(item, this.f.createStatistics(threadType,
+              item.getThreadName() + '-' + item.getThreadId(), this.id)));
-    Iterator<Map.Entry<Long,ThreadStatInfo>> it = threadMap.entrySet().iterator();
+    Iterator<Map.Entry<Long, ThreadStatInfo>> it = threadMap.entrySet().iterator();
-      Map.Entry<Long,ThreadStatInfo> me = it.next();
+      Map.Entry<Long, ThreadStatInfo> me = it.next();
-      s.setInt(thread_inNativeId, ti.isInNative()?1:0);
-      s.setInt(thread_suspendedId, ti.isSuspended()?1:0);
+      s.setInt(thread_inNativeId, ti.isInNative() ? 1 : 0);
+      s.setInt(thread_suspendedId, ti.isSuspended() ? 1 : 0);
+
-   * This set is used to workaround a JRockit bug 36348 in which getCollectionUsage
-   * throws OperationUnsupportedException instead of returning null.
+   * This set is used to workaround a JRockit bug 36348 in which getCollectionUsage throws
+   * OperationUnsupportedException instead of returning null.
+
+
-        mpMap.put(item, this.f.createStatistics(mpType, item.getName()+'-'+item.getType(), this.id));
+        mpMap.put(item,
+            this.f.createStatistics(mpType, item.getName() + '-' + item.getType(), this.id));
-    Iterator<Map.Entry<MemoryPoolMXBean,Statistics>> it = mpMap.entrySet().iterator();
+    Iterator<Map.Entry<MemoryPoolMXBean, Statistics>> it = mpMap.entrySet().iterator();
-      Map.Entry<MemoryPoolMXBean,Statistics> me = it.next();
+      Map.Entry<MemoryPoolMXBean, Statistics> me = it.next();
-          // Somebody saw an InternalError once but I have no idea how to reproduce it. Was this a race between
+          // Somebody saw an InternalError once but I have no idea how to reproduce it. Was this a
+          // race between
-          logger.warn("Accessing MemoryPool '{}' threw an Internal Error: {}", mp.getName(), ie.getMessage());
+          logger.warn("Accessing MemoryPool '{}' threw an Internal Error: {}", mp.getName(),
+              ie.getMessage());
-            //  See bug 36348.
+            // See bug 36348.
-          //s.setLong(mp_gc_initMemoryId, mu.getInit());
+          // s.setLong(mp_gc_initMemoryId, mu.getInit());
-          //s.setLong(mp_gc_committedMemoryId, mu.getCommitted());
-          //s.setLong(mp_gc_maxMemoryId, mu.getMax());
+          // s.setLong(mp_gc_committedMemoryId, mu.getCommitted());
+          // s.setLong(mp_gc_maxMemoryId, mu.getMax());
-    Iterator<Map.Entry<GarbageCollectorMXBean,Statistics>> it = gcMap.entrySet().iterator();
+    Iterator<Map.Entry<GarbageCollectorMXBean, Statistics>> it = gcMap.entrySet().iterator();
-      Map.Entry<GarbageCollectorMXBean,Statistics> me = it.next();
+      Map.Entry<GarbageCollectorMXBean, Statistics> me = it.next();
-  
+
-      if (getProcessCpuTime!=null) {
-        Object v = getProcessCpuTime.invoke(osBean, new Object[]{});
-        this.vmStats.setLong(processCpuTimeId, ((Long)v).longValue());
+      if (getProcessCpuTime != null) {
+        Object v = getProcessCpuTime.invoke(osBean, new Object[] {});
+        this.vmStats.setLong(processCpuTimeId, ((Long) v).longValue());
-    }
-    catch (VirtualMachineError err) {
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Throwable ex) {
+    } catch (Throwable ex) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-        Object v = getMaxFileDescriptorCount.invoke(unixBean, new Object[]{});
-        this.vmStats.setLong(unix_fdLimitId, ((Long)v).longValue());
-        v = getOpenFileDescriptorCount.invoke(unixBean, new Object[]{});
-        this.vmStats.setLong(unix_fdsOpenId, ((Long)v).longValue());
-      }
-      catch (VirtualMachineError err) {
-	SystemFailure.initiateFailure(err);
-	// If this ever returns, rethrow the error.  We're poisoned
-	// now, so don't let this thread continue.
-	throw err;
-      }
-     catch (Throwable ex) {
-	// Whenever you catch Error or Throwable, you must also
-	// catch VirtualMachineError (see above).  However, there is
-	// _still_ a possibility that you are dealing with a cascading
-	// error condition, so you also need to check to see if the JVM
-	// is still usable:
-	SystemFailure.checkFailure();
+        Object v = getMaxFileDescriptorCount.invoke(unixBean, new Object[] {});
+        this.vmStats.setLong(unix_fdLimitId, ((Long) v).longValue());
+        v = getOpenFileDescriptorCount.invoke(unixBean, new Object[] {});
+        this.vmStats.setLong(unix_fdsOpenId, ((Long) v).longValue());
+      } catch (VirtualMachineError err) {
+        SystemFailure.initiateFailure(err);
+        // If this ever returns, rethrow the error. We're poisoned
+        // now, so don't let this thread continue.
+        throw err;
+      } catch (Throwable ex) {
+        // Whenever you catch Error or Throwable, you must also
+        // catch VirtualMachineError (see above). However, there is
+        // _still_ a possibility that you are dealing with a cascading
+        // error condition, so you also need to check to see if the JVM
+        // is still usable:
+        SystemFailure.checkFailure();
+
-  
+
-  
+
+
+
-  
+
-  
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66
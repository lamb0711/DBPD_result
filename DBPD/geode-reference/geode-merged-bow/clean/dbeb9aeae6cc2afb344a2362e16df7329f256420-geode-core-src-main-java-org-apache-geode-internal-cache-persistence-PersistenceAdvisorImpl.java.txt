Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-  
+
-  
+
-  private static final int PERSISTENT_VIEW_RETRY = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "PERSISTENT_VIEW_RETRY", 5);
-  
-  public PersistenceAdvisorImpl(CacheDistributionAdvisor advisor, DistributedLockService dl, PersistentMemberView storage, String regionPath, DiskRegionStats diskStats, PersistentMemberManager memberManager) {
+  private static final int PERSISTENT_VIEW_RETRY =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "PERSISTENT_VIEW_RETRY", 5);
+
+  public PersistenceAdvisorImpl(CacheDistributionAdvisor advisor, DistributedLockService dl,
+      PersistentMemberView storage, String regionPath, DiskRegionStats diskStats,
+      PersistentMemberManager memberManager) {
-    
-    //Prevent membership changes while we are persisting the membership view
-    //online. TODO prpersist is this the best thing to sync on?
-    //If we synchronize on something else, we need to be careful about
-    //lock ordering because the membership notifications are called
-    //with the advisor lock held.
+
+    // Prevent membership changes while we are persisting the membership view
+    // online. TODO prpersist is this the best thing to sync on?
+    // If we synchronize on something else, we need to be careful about
+    // lock ordering because the membership notifications are called
+    // with the advisor lock held.
-    
-    //Remember which members we know about because of what
-    //we have persisted
-    //We will later use this to handle updates from peers.
+
+    // Remember which members we know about because of what
+    // we have persisted
+    // We will later use this to handle updates from peers.
-    
-    //To prevent races if we crash during initialization,
-    //mark equal members as online before we initialize. We will
-    //still report these members as equal, but if we crash and recover
-    //they will no longer be considered equal.
+
+    // To prevent races if we crash during initialization,
+    // mark equal members as online before we initialize. We will
+    // still report these members as equal, but if we crash and recover
+    // they will no longer be considered equal.
-    for(PersistentMemberID id : equalMembers) {
+    for (PersistentMemberID id : equalMembers) {
-    }    
+    }
-  
+
-    if(initialized) {
+    if (initialized) {
-    
-    if(wasAboutToDestroy()) {
-      logger.info(LocalizedMessage.create(LocalizedStrings.PersistenceAdvisorImpl_FINISHING_INCOMPLETE_DESTROY, regionPath));
+
+    if (wasAboutToDestroy()) {
+      logger.info(LocalizedMessage.create(
+          LocalizedStrings.PersistenceAdvisorImpl_FINISHING_INCOMPLETE_DESTROY, regionPath));
-    
+
-    
-    Set<PersistentMemberPattern> revokedMembers = this.memberManager.addRevocationListener(listener, storage.getRevokedMembers());
-    
-    for(PersistentMemberPattern pattern : revokedMembers) {
+
+    Set<PersistentMemberPattern> revokedMembers =
+        this.memberManager.addRevocationListener(listener, storage.getRevokedMembers());
+
+    for (PersistentMemberPattern pattern : revokedMembers) {
-    
+
-  }  
- 
+  }
+
-       * A persistent member has gone offline.  Log the offline member and log which persistent members
-       * are still online (the current persistent view).
+       * A persistent member has gone offline. Log the offline member and log which persistent
+       * members are still online (the current persistent view).
-      public void memberOffline(InternalDistributedMember member,
-          PersistentMemberID persistentID) {
-        if(logger.isDebugEnabled()) {
+      public void memberOffline(InternalDistributedMember member, PersistentMemberID persistentID) {
+        if (logger.isDebugEnabled()) {
-          
+
-          members.addAll(PersistenceAdvisorImpl.this.advisor.adviseInitializedPersistentMembers().values());
+          members.addAll(
+              PersistenceAdvisorImpl.this.advisor.adviseInitializedPersistentMembers().values());
-          
-          TransformUtils.transform(members, onlineMembers, TransformUtils.persistentMemberIdToLogEntryTransformer);
-          
-          logger.info(LocalizedMessage.create(LocalizedStrings.PersistenceAdvisorImpl_PERSISTENT_VIEW,
-              new Object[] {PersistenceAdvisorImpl.this.regionPath,TransformUtils.persistentMemberIdToLogEntryTransformer.transform(persistentID),onlineMembers}));          
+
+          TransformUtils.transform(members, onlineMembers,
+              TransformUtils.persistentMemberIdToLogEntryTransformer);
+
+          logger.info(LocalizedMessage.create(
+              LocalizedStrings.PersistenceAdvisorImpl_PERSISTENT_VIEW,
+              new Object[] {PersistenceAdvisorImpl.this.regionPath,
+                  TransformUtils.persistentMemberIdToLogEntryTransformer.transform(persistentID),
+                  onlineMembers}));
-    });    
+    });
-  
+
-  
+
-    if(holdingTieLock) {
+    if (holdingTieLock) {
-  public PersistentStateQueryResults getMyStateOnMembers(
-      Set<InternalDistributedMember> members) throws ReplyException {
+  public PersistentStateQueryResults getMyStateOnMembers(Set<InternalDistributedMember> members)
+      throws ReplyException {
-    PersistentStateQueryResults results = PersistentStateQueryMessage
-    .send(members, advisor.getDistributionManager(), regionPath, storage
-        .getMyPersistentID(), storage.getMyInitializingID());
-    
+    PersistentStateQueryResults results =
+        PersistentStateQueryMessage.send(members, advisor.getDistributionManager(), regionPath,
+            storage.getMyPersistentID(), storage.getMyInitializingID());
+
-    if(isRevoked(id)) {
+    if (isRevoked(id)) {
-    
-    //If the peer is marked as equal, indicate they are equal
-    if(equalMembers != null && equalMembers.contains(id)) {
+
+    // If the peer is marked as equal, indicate they are equal
+    if (equalMembers != null && equalMembers.contains(id)) {
-    
-    //If we have a member that is marked as online that
-    //is an older version of the peers id, tell them they are online
-    for(PersistentMemberID online : storage.getOnlineMembers()) {
-      if(online.isOlderOrEqualVersionOf(id)) {
-        return PersistentMemberState.ONLINE; 
+
+    // If we have a member that is marked as online that
+    // is an older version of the peers id, tell them they are online
+    for (PersistentMemberID online : storage.getOnlineMembers()) {
+      if (online.isOlderOrEqualVersionOf(id)) {
+        return PersistentMemberState.ONLINE;
-    
-    //If we have a member that is marked as offline that
-    //is a newer version of the peers id, tell them they are online
-    for(PersistentMemberID offline : storage.getOfflineMembers()) {
-      if(id.isOlderOrEqualVersionOf(offline)) {
-        return PersistentMemberState.OFFLINE; 
+
+    // If we have a member that is marked as offline that
+    // is a newer version of the peers id, tell them they are online
+    for (PersistentMemberID offline : storage.getOfflineMembers()) {
+      if (id.isOlderOrEqualVersionOf(offline)) {
+        return PersistentMemberState.OFFLINE;
-  
-  public void updateMembershipView(InternalDistributedMember replicate, boolean targetReinitializing) {
+
+  public void updateMembershipView(InternalDistributedMember replicate,
+      boolean targetReinitializing) {
-    PersistentMembershipView view = MembershipViewRequest.send(replicate, dm, regionPath, targetReinitializing);
+    PersistentMembershipView view =
+        MembershipViewRequest.send(replicate, dm, regionPath, targetReinitializing);
-      logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Updating persistent view from {}", shortDiskStoreId(), regionPath, replicate);
+      logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Updating persistent view from {}",
+          shortDiskStoreId(), regionPath, replicate);
-    
-    synchronized(lock) {
+
+    synchronized (lock) {
-      Map<InternalDistributedMember, PersistentMemberID> peersOnlineMembers = view.getOnlineMembers();
+      Map<InternalDistributedMember, PersistentMemberID> peersOnlineMembers =
+          view.getOnlineMembers();
-      for(PersistentMemberID id : peersOnlineMembers.values()) {
-        if(!isRevoked(id) && !removedMembers.contains(id)) {
-          if(!id.equals(myId) && !recoveredMembers.remove(id) && !id.diskStoreId.equals(getDiskStoreID())) {
+      for (PersistentMemberID id : peersOnlineMembers.values()) {
+        if (!isRevoked(id) && !removedMembers.contains(id)) {
+          if (!id.equals(myId) && !recoveredMembers.remove(id)
+              && !id.diskStoreId.equals(getDiskStoreID())) {
-              logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Processing membership view from peer. Marking {} as online because {} says its online",
+              logger.debug(LogMarker.PERSIST_ADVISOR,
+                  "{}-{}: Processing membership view from peer. Marking {} as online because {} says its online",
-      for(PersistentMemberID id : peersOfflineMembers) {
-        if(!isRevoked(id) && !removedMembers.contains(id)) {
-          //This method is called before the current member is online.
-          //if the peer knows about a member that the current member doesn't know
-          //about, that means that member must have been added to the DS after
-          //the current member went offline. Therefore, that member is *newer* than
-          //the current member. So mark that member as online (meaning, online later
-          //than the current member).
-          if(!id.equals(myId) && !recoveredMembers.remove(id) && !id.diskStoreId.equals(getDiskStoreID())) {
+      for (PersistentMemberID id : peersOfflineMembers) {
+        if (!isRevoked(id) && !removedMembers.contains(id)) {
+          // This method is called before the current member is online.
+          // if the peer knows about a member that the current member doesn't know
+          // about, that means that member must have been added to the DS after
+          // the current member went offline. Therefore, that member is *newer* than
+          // the current member. So mark that member as online (meaning, online later
+          // than the current member).
+          if (!id.equals(myId) && !recoveredMembers.remove(id)
+              && !id.diskStoreId.equals(getDiskStoreID())) {
-              logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Processing membership view from peer. Marking {} as online because {} says its offline, but we have never seen it",
+              logger.debug(LogMarker.PERSIST_ADVISOR,
+                  "{}-{}: Processing membership view from peer. Marking {} as online because {} says its offline, but we have never seen it",
-      for(PersistentMemberID id  : recoveredMembers) {
+      for (PersistentMemberID id : recoveredMembers) {
-          logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Processing membership view from peer. Removing {} because {} doesn't have it",
+          logger.debug(LogMarker.PERSIST_ADVISOR,
+              "{}-{}: Processing membership view from peer. Removing {} because {} doesn't have it",
-    
-    //Update the set of revoked members from the peer
-    //This should be called without holding the lock to
-    //avoid deadlocks
+
+    // Update the set of revoked members from the peer
+    // This should be called without holding the lock to
+    // avoid deadlocks
-    for(PersistentMemberPattern revoked : revokedMembers) {
+    for (PersistentMemberPattern revoked : revokedMembers) {
-  
+
-  public void setOnline(boolean didGII, boolean atomicCreation,
-      PersistentMemberID newId) throws ReplyException {
-    if(online) {
+  public void setOnline(boolean didGII, boolean atomicCreation, PersistentMemberID newId)
+      throws ReplyException {
+    if (online) {
-    if(!didGII) {
+    if (!didGII) {
-    
-    synchronized(lock) {
-      
-      //Transition any members that are marked as online, but not actually
-      //currently running, to offline.
-      Set<PersistentMemberID> membersToMarkOffline = new HashSet<PersistentMemberID>(storage.getOnlineMembers());
+
+    synchronized (lock) {
+
+      // Transition any members that are marked as online, but not actually
+      // currently running, to offline.
+      Set<PersistentMemberID> membersToMarkOffline =
+          new HashSet<PersistentMemberID>(storage.getOnlineMembers());
-      if(!atomicCreation) {
+      if (!atomicCreation) {
-        //Fix for 41100 - If this is an atomic bucket creation, don't
-        //mark our peers, which are concurrently intitializing, as offline
-        //they have the exact same data as we do (none), so we are not
-        //technically "newer," and this avoids a race where both members
-        //can think the other is offline ("older").
+        // Fix for 41100 - If this is an atomic bucket creation, don't
+        // mark our peers, which are concurrently intitializing, as offline
+        // they have the exact same data as we do (none), so we are not
+        // technically "newer," and this avoids a race where both members
+        // can think the other is offline ("older").
-      
-      //Another fix for 41100
-      //Don't mark equal members as offline if that are currently running.
-      //We don't have newer data than these members
-      //so this is safe, and it it avoids a race where we mark them offline
-      //at this point, and then later they mark us as offline.
-      if(equalMembers != null && !equalMembers.isEmpty()) {
-        
-        //This is slightly hacky. We're looking for a running member that has 
-        //the same disk store as our equal members, because all have is a persistent
-        //id of the equal members. The persistent id of the running member may be
-        //different than what we have marked as equal, because the id in the profile
-        //is the new id for the member.
+
+      // Another fix for 41100
+      // Don't mark equal members as offline if that are currently running.
+      // We don't have newer data than these members
+      // so this is safe, and it it avoids a race where we mark them offline
+      // at this point, and then later they mark us as offline.
+      if (equalMembers != null && !equalMembers.isEmpty()) {
+
+        // This is slightly hacky. We're looking for a running member that has
+        // the same disk store as our equal members, because all have is a persistent
+        // id of the equal members. The persistent id of the running member may be
+        // different than what we have marked as equal, because the id in the profile
+        // is the new id for the member.
-        for(PersistentMemberID mem : allMembers) {
+        for (PersistentMemberID mem : allMembers) {
-        //Remove any equal members which are not actually running right now.
-        for(Iterator<PersistentMemberID> itr = equalMembers.iterator(); itr.hasNext(); ) {
+        // Remove any equal members which are not actually running right now.
+        for (Iterator<PersistentMemberID> itr = equalMembers.iterator(); itr.hasNext();) {
-          if(!runningDiskStores.contains(id.diskStoreId)) {
+          if (!runningDiskStores.contains(id.diskStoreId)) {
-      for(PersistentMemberID id : membersToMarkOffline) {
+      for (PersistentMemberID id : membersToMarkOffline) {
-      if(logger.isDebugEnabled(LogMarker.PERSIST_ADVISOR)) {
-        logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Persisting the new membership view and ID as online. Online members {}. Offline members {}. Equal memebers {}.",
-            shortDiskStoreId(), regionPath, storage.getOnlineMembers(), storage.getOfflineMembers(), equalMembers);
+      if (logger.isDebugEnabled(LogMarker.PERSIST_ADVISOR)) {
+        logger.debug(LogMarker.PERSIST_ADVISOR,
+            "{}-{}: Persisting the new membership view and ID as online. Online members {}. Offline members {}. Equal memebers {}.",
+            shortDiskStoreId(), regionPath, storage.getOnlineMembers(), storage.getOfflineMembers(),
+            equalMembers);
-      
+
-    if(stats != null) {
+    if (stats != null) {
-  
+
-   * Start listening for persistent view updates and apply any
-   * updates that have already happened.
+   * Start listening for persistent view updates and apply any updates that have already happened.
-   * This method should be called after we have decided that there is
-   * no conflicting persistent exception.
+   * This method should be called after we have decided that there is no conflicting persistent
+   * exception.
-    synchronized(lock) {
-      //Only update the view if it is has not already happened.
-      if(!shouldUpdatePersistentView) {
+    synchronized (lock) {
+      // Only update the view if it is has not already happened.
+      if (!shouldUpdatePersistentView) {
-        Map<InternalDistributedMember, PersistentMemberID> onlineMembers 
-          = advisor.adviseInitializedPersistentMembers();
-        for(Map.Entry<InternalDistributedMember, PersistentMemberID>entry 
-            : onlineMembers.entrySet()) {
+        Map<InternalDistributedMember, PersistentMemberID> onlineMembers =
+            advisor.adviseInitializedPersistentMembers();
+        for (Map.Entry<InternalDistributedMember, PersistentMemberID> entry : onlineMembers
+            .entrySet()) {
-  
+
-    
+
-    
+
-    
+
-    
+
-    if(newId == null || 
-        (!newId.equals(oldId) && !newId.equals(initializingId))) {
-      //If we have not yet prepared the old id, prepare it now.
+    if (newId == null || (!newId.equals(oldId) && !newId.equals(initializingId))) {
+      // If we have not yet prepared the old id, prepare it now.
-      //This will only be the case if we crashed
-      //while initializing previously. In the case, we are essentially
-      //finishing what we started by preparing that ID first. This
-      //will remove that ID from the peers.
-      if(initializingId != null) {
+      // This will only be the case if we crashed
+      // while initializing previously. In the case, we are essentially
+      // finishing what we started by preparing that ID first. This
+      // will remove that ID from the peers.
+      if (initializingId != null) {
-          logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: We still have an initializing id: {}. Telling peers to remove the old id {} and transitioning this initializing id to old id. recipients {}",
+          logger.debug(LogMarker.PERSIST_ADVISOR,
+              "{}-{}: We still have an initializing id: {}. Telling peers to remove the old id {} and transitioning this initializing id to old id. recipients {}",
-        //TODO prpersist - clean this up
+        // TODO prpersist - clean this up
-          PrepareNewPersistentMemberMessage.send(profileUpdateRecipients,
-              dm, regionPath, oldId, initializingId);
+          PrepareNewPersistentMemberMessage.send(profileUpdateRecipients, dm, regionPath, oldId,
+              initializingId);
-      if(logger.isDebugEnabled()) {
+      if (logger.isDebugEnabled()) {
-    
+
-      logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Sending the new ID to peers. They should remove the old id {}. Recipients: {}",
+      logger.debug(LogMarker.PERSIST_ADVISOR,
+          "{}-{}: Sending the new ID to peers. They should remove the old id {}. Recipients: {}",
-    if(newId != null) {
-      PrepareNewPersistentMemberMessage.send(profileUpdateRecipients,
-          dm, regionPath, oldId,
-          newId);
+    if (newId != null) {
+      PrepareNewPersistentMemberMessage.send(profileUpdateRecipients, dm, regionPath, oldId, newId);
-    return storage.generatePersistentID(); 
+    return storage.generatePersistentID();
-    if(!initialized) { 
+    if (!initialized) {
-    Map<InternalDistributedMember, PersistentMemberID> onlineMembers = advisor
-        .adviseInitializedPersistentMembers();
+    Map<InternalDistributedMember, PersistentMemberID> onlineMembers =
+        advisor.adviseInitializedPersistentMembers();
-    
+
-    if(myId != null) {
+    if (myId != null) {
-    
-    PersistentMembershipView view = new PersistentMembershipView(
-        offlineMembers, onlineMembers, memberManager.getRevokedMembers());
+
+    PersistentMembershipView view = new PersistentMembershipView(offlineMembers, onlineMembers,
+        memberManager.getRevokedMembers());
-  
+
-  
+
-    if(online) {
+    if (online) {
-  
+
-    synchronized(lock) {
+    synchronized (lock) {
-      //Don't persist members as offline until we are online. Otherwise, we may
-      //think we have later data than them during recovery.
-      if(shouldUpdatePersistentView && online) {
+      // Don't persist members as offline until we are online. Otherwise, we may
+      // think we have later data than them during recovery.
+      if (shouldUpdatePersistentView && online) {
-          //Don't persistent members as offline if we have already persisted them as equal.
-          if(storage.getOfflineAndEqualMembers().contains(persistentID)) {
+          // Don't persistent members as offline if we have already persisted them as equal.
+          if (storage.getOfflineAndEqualMembers().contains(persistentID)) {
-          //Don't mark the member as offline if we have never seen it. If we haven't seen it
-          //that means it's not done initializing yet.
-          if(foundMember) {
-            if(PersistenceObserverHolder.getInstance().memberOffline(regionPath, persistentID)) {
+          // Don't mark the member as offline if we have never seen it. If we haven't seen it
+          // that means it's not done initializing yet.
+          if (foundMember) {
+            if (PersistenceObserverHolder.getInstance().memberOffline(regionPath, persistentID)) {
-          logger.warn(LocalizedMessage.create(LocalizedStrings.PersistenceAdvisorImpl_UNABLE_TO_PERSIST_MEMBERSHIP_CHANGE), e);
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.PersistenceAdvisorImpl_UNABLE_TO_PERSIST_MEMBERSHIP_CHANGE), e);
-    
+
-      logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Sending the new ID to peers.  Member online. id={}, persistentID={}",
+      logger.debug(LogMarker.PERSIST_ADVISOR,
+          "{}-{}: Sending the new ID to peers.  Member online. id={}, persistentID={}",
-    synchronized(lock) {
-      if(shouldUpdatePersistentView) {
+    synchronized (lock) {
+      if (shouldUpdatePersistentView) {
-          if(PersistenceObserverHolder.getInstance().memberOnline(regionPath, persistentID)) {
+          if (PersistenceObserverHolder.getInstance().memberOnline(regionPath, persistentID)) {
-          logger.warn(LocalizedMessage.create(LocalizedStrings.PersistenceAdvisorImpl_UNABLE_TO_PERSIST_MEMBERSHIP_CHANGE), e);
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.PersistenceAdvisorImpl_UNABLE_TO_PERSIST_MEMBERSHIP_CHANGE), e);
-          logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Not marking member online in persistent view because we're still in initialization",
+          logger.debug(LogMarker.PERSIST_ADVISOR,
+              "{}-{}: Not marking member online in persistent view because we're still in initialization",
-  
+
-    //Persist the revoked member, so if we recover later we will 
-    //remember that they were revoked.
+    // Persist the revoked member, so if we recover later we will
+    // remember that they were revoked.
-    
-    //Remove the revoked member from our view.
-    for(PersistentMemberID id : storage.getOfflineMembers()) {
-      if(pattern.matches(id)) {
+
+    // Remove the revoked member from our view.
+    for (PersistentMemberID id : storage.getOfflineMembers()) {
+      if (pattern.matches(id)) {
-    for(PersistentMemberID id : storage.getOnlineMembers()) {
-      if(pattern.matches(id)) {
+    for (PersistentMemberID id : storage.getOnlineMembers()) {
+      if (pattern.matches(id)) {
-    for(PersistentMemberID id : storage.getOfflineAndEqualMembers()) {
-      if(pattern.matches(id)) {
+    for (PersistentMemberID id : storage.getOfflineAndEqualMembers()) {
+      if (pattern.matches(id)) {
-  
+
-    
-    synchronized(lock) {
+
+    synchronized (lock) {
-      if(!online) {
+      if (!online) {
-        if(PersistenceObserverHolder.getInstance().memberRemoved(regionPath, id)) {
+        if (PersistenceObserverHolder.getInstance().memberRemoved(regionPath, id)) {
-        
-        //Purge any IDs that are old versions of the the id that
-        //we just removed
-        for(PersistentMemberID persistedId : getPersistedMembers()) {
-          if(persistedId.isOlderOrEqualVersionOf(id)) {
+
+        // Purge any IDs that are old versions of the the id that
+        // we just removed
+        for (PersistentMemberID persistedId : getPersistedMembers()) {
+          if (persistedId.isOlderOrEqualVersionOf(id)) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.PersistenceAdvisorImpl_UNABLE_TO_PERSIST_MEMBERSHIP_CHANGE), e);
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.PersistenceAdvisorImpl_UNABLE_TO_PERSIST_MEMBERSHIP_CHANGE), e);
-  
+
-  
+
-    synchronized(this) {
-      HashSet<PersistentStateListener> tmpListeners = new HashSet<PersistentStateListener>(listeners);
+    synchronized (this) {
+      HashSet<PersistentStateListener> tmpListeners =
+          new HashSet<PersistentStateListener>(listeners);
-    
+
-  
+
-    synchronized(this) {
-      HashSet<PersistentStateListener> tmpListeners = new HashSet<PersistentStateListener>(listeners);
+    synchronized (this) {
+      HashSet<PersistentStateListener> tmpListeners =
+          new HashSet<PersistentStateListener>(listeners);
-  
+
-    for(PersistentStateListener listener : listeners) {
+    for (PersistentStateListener listener : listeners) {
+
-    for(PersistentStateListener listener : listeners) {
+    for (PersistentStateListener listener : listeners) {
-  
+
-    for(PersistentStateListener listener : listeners) {
+    for (PersistentStateListener listener : listeners) {
-    
+
-  
+
-    HashSet<PersistentMemberID> members  = new HashSet<PersistentMemberID>(storage.getOnlineMembers());
+    HashSet<PersistentMemberID> members =
+        new HashSet<PersistentMemberID>(storage.getOnlineMembers());
-    synchronized(lock) {
-      //Don't prepare the ID if the advisor doesn't have a profile. This prevents
-      //A race with the advisor remove
-      if(!advisor.containsId(sender)) {
+    synchronized (lock) {
+      // Don't prepare the ID if the advisor doesn't have a profile. This prevents
+      // A race with the advisor remove
+      if (!advisor.containsId(sender)) {
-          logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Refusing to prepare id because {} is not in our advisor",
-              shortDiskStoreId(), regionPath, sender);
+          logger.debug(LogMarker.PERSIST_ADVISOR,
+              "{}-{}: Refusing to prepare id because {} is not in our advisor", shortDiskStoreId(),
+              regionPath, sender);
-      //Persist new members even if we are not online yet
-      //Two members can become online at once. This way,
-      //they will know about each other.
+      // Persist new members even if we are not online yet
+      // Two members can become online at once. This way,
+      // they will know about each other.
-      
-      //The oldId and newId could be the same if the member
-      //is retrying a GII. See bug #42051
-      if(oldId != null && !oldId.equals(newId)) {
-        if(initialized) {
+
+      // The oldId and newId could be the same if the member
+      // is retrying a GII. See bug #42051
+      if (oldId != null && !oldId.equals(newId)) {
+        if (initialized) {
-  
+
-  public void setWaitingOnMembers(Set<PersistentMemberID> allMembersToWaitFor, Set<PersistentMemberID> offlineMembersToWaitFor) {
+  public void setWaitingOnMembers(Set<PersistentMemberID> allMembersToWaitFor,
+      Set<PersistentMemberID> offlineMembersToWaitFor) {
-  
-  public boolean checkMyStateOnMembers(Set<InternalDistributedMember> replicates) throws ReplyException {
+
+  public boolean checkMyStateOnMembers(Set<InternalDistributedMember> replicates)
+      throws ReplyException {
-    for(Map.Entry<InternalDistributedMember, PersistentMemberState> entry: remoteStates.stateOnPeers.entrySet()) {
+    for (Map.Entry<InternalDistributedMember, PersistentMemberState> entry : remoteStates.stateOnPeers
+        .entrySet()) {
-      
+
-      
-      if(PersistentMemberState.REVOKED.equals(stateOnPeer)) {
+
+      if (PersistentMemberState.REVOKED.equals(stateOnPeer)) {
-      
-      
-      if(myId != null && stateOnPeer == null) {
+
+
+      if (myId != null && stateOnPeer == null) {
-      if(myId != null && stateOnPeer == PersistentMemberState.EQUAL) {
-          equal = true;
-        }
-      
-      //TODO prpersist - This check might not help much. The other member changes it's ID when it
-      //comes back online.
-      if(remoteId != null) {
+      if (myId != null && stateOnPeer == PersistentMemberState.EQUAL) {
+        equal = true;
+      }
+
+      // TODO prpersist - This check might not help much. The other member changes it's ID when it
+      // comes back online.
+      if (remoteId != null) {
-        if(remoteState == PersistentMemberState.OFFLINE) {
-          String message = LocalizedStrings.CreatePersistentRegionProcessor_INITIALIZING_FROM_OLD_DATA
-              .toLocalizedString(regionPath, member, remoteId, myId);
+        if (remoteState == PersistentMemberState.OFFLINE) {
+          String message =
+              LocalizedStrings.CreatePersistentRegionProcessor_INITIALIZING_FROM_OLD_DATA
+                  .toLocalizedString(regionPath, member, remoteId, myId);
-  
+
-  //send a message to peers indicating that they should remove this profile
+    // send a message to peers indicating that they should remove this profile
-      
+
-      } 
+      }
-    synchronized(lock) {
+    synchronized (lock) {
-  
+
-   * Returns the member id of the member who has the latest
-   * copy of the persistent region. This may be the local member ID
-   * if this member has the latest known copy.
+   * Returns the member id of the member who has the latest copy of the persistent region. This may
+   * be the local member ID if this member has the latest known copy.
-   * @throws ConflictingPersistentDataException if there are active members
-   * which are not based on the state that is persisted in this member.
+   * 
+   * @throws ConflictingPersistentDataException if there are active members which are not based on
+   *         the state that is persisted in this member.
-    
+
-      while(true) {
+      while (true) {
-          if(!advice.getReplicates().isEmpty()) {
+          if (!advice.getReplicates().isEmpty()) {
-              logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: There are members currently online. Checking for our state on those members and then initializing",
+              logger.debug(LogMarker.PERSIST_ADVISOR,
+                  "{}-{}: There are members currently online. Checking for our state on those members and then initializing",
-            //We will go ahead and take the other members contents if we ourselves didn't recover from disk.
-            if(recoverFromDisk) {
-              //Check with these members to make sure that they
-              //have heard of us
-              //If any of them say we have the same data on disk, we don't need to do a GII
-              if(checkMyStateOnMembers(advice.getReplicates())) {
+            // We will go ahead and take the other members contents if we ourselves didn't recover
+            // from disk.
+            if (recoverFromDisk) {
+              // Check with these members to make sure that they
+              // have heard of us
+              // If any of them say we have the same data on disk, we don't need to do a GII
+              if (checkMyStateOnMembers(advice.getReplicates())) {
-                  logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: We have the same data on disk as one of {} recovering gracefully",
+                  logger.debug(LogMarker.PERSIST_ADVISOR,
+                      "{}-{}: We have the same data on disk as one of {} recovering gracefully",
-                //If we have to do a GII, we have not equal members anymore.
-                synchronized(lock) {
+                // If we have to do a GII, we have not equal members anymore.
+                synchronized (lock) {
-          } else if(!advice.getNonPersistent().isEmpty()) {
-            //We support a persistent member getting a membership view
-            //from a non persistent member and using that information to wait
-            //for the other known persistent members. See 
-            //PersistentRecoveryOrderDUnitTest.testTransmitCrashedMembersWithNonPeristentRegion
+          } else if (!advice.getNonPersistent().isEmpty()) {
+            // We support a persistent member getting a membership view
+            // from a non persistent member and using that information to wait
+            // for the other known persistent members. See
+            // PersistentRecoveryOrderDUnitTest.testTransmitCrashedMembersWithNonPeristentRegion
-          
-          //Fix for 51698 - If there are online members that we previously
-          //failed to get a GII from, retry those members rather than wait
-          //for new persistent members to recover.
-          if(previousAdvice != null && !previousAdvice.getReplicates().isEmpty()) {
-            logger.info(LocalizedMessage.create(LocalizedStrings.PersistenceAdvisorImpl_RETRYING_GII));
+
+          // Fix for 51698 - If there are online members that we previously
+          // failed to get a GII from, retry those members rather than wait
+          // for new persistent members to recover.
+          if (previousAdvice != null && !previousAdvice.getReplicates().isEmpty()) {
+            logger.info(
+                LocalizedMessage.create(LocalizedStrings.PersistenceAdvisorImpl_RETRYING_GII));
-          //If there are no currently online members, and no
-          //previously online members, this member should just go with what's
-          //on it's own disk
-          if(previouslyOnlineMembers.isEmpty()) {
+          // If there are no currently online members, and no
+          // previously online members, this member should just go with what's
+          // on it's own disk
+          if (previouslyOnlineMembers.isEmpty()) {
-              logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: No previously online members. Recovering with the data from the local disk",
+              logger.debug(LogMarker.PERSIST_ADVISOR,
+                  "{}-{}: No previously online members. Recovering with the data from the local disk",
-          Set<PersistentMemberID> membersToWaitFor = getMembersToWaitFor(previouslyOnlineMembers, offlineMembers);
+          Set<PersistentMemberID> membersToWaitFor =
+              getMembersToWaitFor(previouslyOnlineMembers, offlineMembers);
-          if(membersToWaitFor.isEmpty()) {
+          if (membersToWaitFor.isEmpty()) {
-              logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: All of the previously online members are now online and waiting for us. Acquiring tie lock. Previously online members {}",
+              logger.debug(LogMarker.PERSIST_ADVISOR,
+                  "{}-{}: All of the previously online members are now online and waiting for us. Acquiring tie lock. Previously online members {}",
-            //We're tied for the latest copy of the data. try to get the distributed lock.
-            if(acquireTieLock()) {
+            // We're tied for the latest copy of the data. try to get the distributed lock.
+            if (acquireTieLock()) {
-                logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Acquired the lock. This member will initialize", shortDiskStoreId(), regionPath);
+                logger.debug(LogMarker.PERSIST_ADVISOR,
+                    "{}-{}: Acquired the lock. This member will initialize", shortDiskStoreId(),
+                    regionPath);
-              if(!advice.getReplicates().isEmpty()) {
+              if (!advice.getReplicates().isEmpty()) {
-                  logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Another member has initialized while we were getting the lock. We will initialize from that member",
+                  logger.debug(LogMarker.PERSIST_ADVISOR,
+                      "{}-{}: Another member has initialized while we were getting the lock. We will initialize from that member",
-                logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Failed to acquire the lock.", shortDiskStoreId(), regionPath);
+                logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Failed to acquire the lock.",
+                    shortDiskStoreId(), regionPath);
-              logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Going to wait for these member ids: {}",
-                  shortDiskStoreId(), regionPath,  membersToWaitFor);
+              logger.debug(LogMarker.PERSIST_ADVISOR,
+                  "{}-{}: Going to wait for these member ids: {}", shortDiskStoreId(), regionPath,
+                  membersToWaitFor);
-          //The persistence advisor needs to know which members are really not available
-            //because the user uses this information to decide which members they
-            //haven't started yet. membersToWaitFor includes members that
-            //are still waiting to start up, but are waiting for members other than
-            //the current member. So we pass the set of offline members here
+            // The persistence advisor needs to know which members are really not available
+            // because the user uses this information to decide which members they
+            // haven't started yet. membersToWaitFor includes members that
+            // are still waiting to start up, but are waiting for members other than
+            // the current member. So we pass the set of offline members here
-        } catch(InterruptedException e) {
-          logger.debug("Interrupted while trying to determine latest persisted copy: {}", e.getMessage(), e);
+        } catch (InterruptedException e) {
+          logger.debug("Interrupted while trying to determine latest persisted copy: {}",
+              e.getMessage(), e);
-  public void updateViewFromNonPersistent(boolean recoverFromDisk,
-      InitialImageAdvice advice) {
-    for(InternalDistributedMember replicate : advice.getNonPersistent()) {
+  public void updateViewFromNonPersistent(boolean recoverFromDisk, InitialImageAdvice advice) {
+    for (InternalDistributedMember replicate : advice.getNonPersistent()) {
-        updateMembershipView(replicate,recoverFromDisk);
+        updateMembershipView(replicate, recoverFromDisk);
-      } catch(ReplyException e) {
-        if(logger.isDebugEnabled(LogMarker.PERSIST_ADVISOR)) {
+      } catch (ReplyException e) {
+        if (logger.isDebugEnabled(LogMarker.PERSIST_ADVISOR)) {
-   * @param previouslyOnlineMembers the members we have persisted online
-   *   in our persistence files
-   * @param offlineMembers This method will populate this set with
-   * any members that we are waiting for an are actually not running right now.
-   * This is different that the set of members we need to wait for - this member
-   * may end up waiting on member that is actually running.
-   * @return the list of members that this member needs to wait for before
-   * it can initialize.
+   * @param previouslyOnlineMembers the members we have persisted online in our persistence files
+   * @param offlineMembers This method will populate this set with any members that we are waiting
+   *        for an are actually not running right now. This is different that the set of members we
+   *        need to wait for - this member may end up waiting on member that is actually running.
+   * @return the list of members that this member needs to wait for before it can initialize.
-      Set<PersistentMemberID> previouslyOnlineMembers, 
-      Set<PersistentMemberID> offlineMembers) throws ReplyException, InterruptedException {
+      Set<PersistentMemberID> previouslyOnlineMembers, Set<PersistentMemberID> offlineMembers)
+      throws ReplyException, InterruptedException {
-    
-    //This is the set of members that are currently waiting for this member
-    //to come online.
-    Set<PersistentMemberID> membersToWaitFor = new HashSet<PersistentMemberID>(previouslyOnlineMembers);
+
+    // This is the set of members that are currently waiting for this member
+    // to come online.
+    Set<PersistentMemberID> membersToWaitFor =
+        new HashSet<PersistentMemberID>(previouslyOnlineMembers);
-    //If our persistent ID is null, we need to wait for all of the previously online members.
-    if(myPersistentID != null || myInitializingId != null) {
+    // If our persistent ID is null, we need to wait for all of the previously online members.
+    if (myPersistentID != null || myInitializingId != null) {
-      //Fetch the persistent view from all of our peers.
-      PersistentStateQueryResults results = PersistentStateQueryMessage
-      .send(members, advisor.getDistributionManager(), regionPath, myPersistentID, myInitializingId);
+      // Fetch the persistent view from all of our peers.
+      PersistentStateQueryResults results = PersistentStateQueryMessage.send(members,
+          advisor.getDistributionManager(), regionPath, myPersistentID, myInitializingId);
-      while(addedMembers) {
+      while (addedMembers) {
-        for(Entry<InternalDistributedMember, Set<PersistentMemberID>> entry : results.onlineMemberMap.entrySet()) {
+        for (Entry<InternalDistributedMember, Set<PersistentMemberID>> entry : results.onlineMemberMap
+            .entrySet()) {
-          if(membersToWaitFor.contains(persistentID) || membersToWaitFor.contains(initializingID)) {
-            for(PersistentMemberID peerOnlineMember : peersOnlineMembers) {
-              if(!isRevoked(peerOnlineMember) && !peerOnlineMember.diskStoreId.equals(getDiskStoreID())
+          if (membersToWaitFor.contains(persistentID)
+              || membersToWaitFor.contains(initializingID)) {
+            for (PersistentMemberID peerOnlineMember : peersOnlineMembers) {
+              if (!isRevoked(peerOnlineMember)
+                  && !peerOnlineMember.diskStoreId.equals(getDiskStoreID())
-                if(membersToWaitFor.add(peerOnlineMember)) {
+                if (membersToWaitFor.add(peerOnlineMember)) {
-                  //Make sure we also persist that this member is online.
+                  // Make sure we also persist that this member is online.
-                    logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Adding {} to the list of members we're wait for, because {} has newer or equal data than is and is waiting for that member",
+                    logger.debug(LogMarker.PERSIST_ADVISOR,
+                        "{}-{}: Adding {} to the list of members we're wait for, because {} has newer or equal data than is and is waiting for that member",
-        logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Initial state of membersToWaitFor, before pruning {}",
-            shortDiskStoreId(), regionPath, membersToWaitFor);
+        logger.debug(LogMarker.PERSIST_ADVISOR,
+            "{}-{}: Initial state of membersToWaitFor, before pruning {}", shortDiskStoreId(),
+            regionPath, membersToWaitFor);
-      
-      //For each of our peers, see what our state is according to their view.
-      for(Map.Entry<InternalDistributedMember, PersistentMemberState> entry : results.stateOnPeers.entrySet()) {
+
+      // For each of our peers, see what our state is according to their view.
+      for (Map.Entry<InternalDistributedMember, PersistentMemberState> entry : results.stateOnPeers
+          .entrySet()) {
-        
-        if(PersistentMemberState.REVOKED.equals(state)) {
+
+        if (PersistentMemberState.REVOKED.equals(state)) {
-        //If the peer thinks we are newer or equal to them, we don't
-        //need to wait for this peer.
-        if(membersHostingThisRegion.contains(memberId) &&
-            persistentID != null && state != null && myInitializingId == null 
-            && (state.equals(PersistentMemberState.ONLINE) || state.equals(PersistentMemberState.EQUAL))) {
+        // If the peer thinks we are newer or equal to them, we don't
+        // need to wait for this peer.
+        if (membersHostingThisRegion.contains(memberId) && persistentID != null && state != null
+            && myInitializingId == null && (state.equals(PersistentMemberState.ONLINE)
+                || state.equals(PersistentMemberState.EQUAL))) {
-            logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Not waiting for {} because it thinks our state was {}",
-                shortDiskStoreId(), regionPath, persistentID, state);
+            logger.debug(LogMarker.PERSIST_ADVISOR,
+                "{}-{}: Not waiting for {} because it thinks our state was {}", shortDiskStoreId(),
+                regionPath, persistentID, state);
-        
-        //If the peer has an initialized ID, they are no longer offline.
-        if(persistentID != null) {
+
+        // If the peer has an initialized ID, they are no longer offline.
+        if (persistentID != null) {
-        
-        //If the peer thinks we are newer or equal to them, we don't
-        //need to wait for this peer.
-        if(membersHostingThisRegion.contains(memberId) &&
-            initializingID != null && state != null 
-            && (state.equals(PersistentMemberState.ONLINE) || state.equals(PersistentMemberState.EQUAL))) {
+
+        // If the peer thinks we are newer or equal to them, we don't
+        // need to wait for this peer.
+        if (membersHostingThisRegion.contains(memberId) && initializingID != null && state != null
+            && (state.equals(PersistentMemberState.ONLINE)
+                || state.equals(PersistentMemberState.EQUAL))) {
-            logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Not waiting for {} because it thinks our state was {}",
-                shortDiskStoreId(), regionPath, initializingID, state);
+            logger.debug(LogMarker.PERSIST_ADVISOR,
+                "{}-{}: Not waiting for {} because it thinks our state was {}", shortDiskStoreId(),
+                regionPath, initializingID, state);
-        
-        //If the peer has an initializing id, they are also not online.
-        if(initializingID != null) {
+
+        // If the peer has an initializing id, they are also not online.
+        if (initializingID != null) {
-        
-        //If we were able to determine what disk store this member
-        //is in, and it doesn't have a persistent ID, but we think
-        //we should be waiting for it, stop waiting for it.
-        if(initializingID == null && persistentID == null & diskStoreID != null) {
+
+        // If we were able to determine what disk store this member
+        // is in, and it doesn't have a persistent ID, but we think
+        // we should be waiting for it, stop waiting for it.
+        if (initializingID == null && persistentID == null & diskStoreID != null) {
-  
+
-   * Remove all members with a given disk store id from the set of members to
-   * wait for, who is newer than the real one.
-   * The reason is: A is waiting for B2, but B sends B1<=A to A. That means A
-   * knows more than B in both B1 and B2. B itself knows nothing about B2.
-   * So we don't need to wait for B2 (since we don't need to wait for B1).
+   * Remove all members with a given disk store id from the set of members to wait for, who is newer
+   * than the real one. The reason is: A is waiting for B2, but B sends B1<=A to A. That means A
+   * knows more than B in both B1 and B2. B itself knows nothing about B2. So we don't need to wait
+   * for B2 (since we don't need to wait for B1).
-  private void removeNewerPersistentID(Set<PersistentMemberID> membersToWaitFor, PersistentMemberID persistentID) {
-    for(Iterator<PersistentMemberID> itr  = membersToWaitFor.iterator(); itr.hasNext(); ) {
+  private void removeNewerPersistentID(Set<PersistentMemberID> membersToWaitFor,
+      PersistentMemberID persistentID) {
+    for (Iterator<PersistentMemberID> itr = membersToWaitFor.iterator(); itr.hasNext();) {
-          logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Not waiting for {} because local member knows more about it",
+          logger.debug(LogMarker.PERSIST_ADVISOR,
+              "{}-{}: Not waiting for {} because local member knows more about it",
-   * Remove all members with a given disk store id from the set of members
-   * to wait for.
+   * Remove all members with a given disk store id from the set of members to wait for.
-    for(Iterator<PersistentMemberID> itr  = membersToWaitFor.iterator(); itr.hasNext(); ) {
+    for (Iterator<PersistentMemberID> itr = membersToWaitFor.iterator(); itr.hasNext();) {
-      if(id.diskStoreId.equals(diskStoreID)) {
+      if (id.diskStoreId.equals(diskStoreID)) {
-          logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: Not waiting for {} because it no longer has this region in it's disk store",
+          logger.debug(LogMarker.PERSIST_ADVISOR,
+              "{}-{}: Not waiting for {} because it no longer has this region in it's disk store",
-    //do nothing
+    // do nothing
-  
+
-    //do nothing
+    // do nothing
-  
+
-  
+
-  
+
-   * Returns the set of missing members that we report back to the
-   * any admin DS looking for missing members.
+   * Returns the set of missing members that we report back to the any admin DS looking for missing
+   * members.
-  
+
-   * Returns the set of missing members that we report back to the
-   * any admin DS looking for missing members.
+   * Returns the set of missing members that we report back to the any admin DS looking for missing
+   * members.
-  
-  protected void logWaitingForMember(Set<PersistentMemberID> allMembersToWaitFor, Set<PersistentMemberID> offlineMembersToWaitFor) {
+
+  protected void logWaitingForMember(Set<PersistentMemberID> allMembersToWaitFor,
+      Set<PersistentMemberID> offlineMembersToWaitFor) {
-    
-    if(offlineMembersToWaitFor != null && !offlineMembersToWaitFor.isEmpty()) {
-      TransformUtils.transform(offlineMembersToWaitFor, membersToWaitForLogEntries, TransformUtils.persistentMemberIdToLogEntryTransformer);
-      StartupStatus
-      .startup(LocalizedStrings.CreatePersistentRegionProcessor_WAITING_FOR_LATEST_MEMBER, 
-          new Object[] {regionPath, TransformUtils.persistentMemberIdToLogEntryTransformer.transform(getPersistentID()),
-          membersToWaitForLogEntries});
+    if (offlineMembersToWaitFor != null && !offlineMembersToWaitFor.isEmpty()) {
+      TransformUtils.transform(offlineMembersToWaitFor, membersToWaitForLogEntries,
+          TransformUtils.persistentMemberIdToLogEntryTransformer);
+
+      StartupStatus.startup(
+          LocalizedStrings.CreatePersistentRegionProcessor_WAITING_FOR_LATEST_MEMBER,
+          new Object[] {regionPath,
+              TransformUtils.persistentMemberIdToLogEntryTransformer.transform(getPersistentID()),
+              membersToWaitForLogEntries});
-      TransformUtils.transform(allMembersToWaitFor, membersToWaitForLogEntries, TransformUtils.persistentMemberIdToLogEntryTransformer);
+      TransformUtils.transform(allMembersToWaitFor, membersToWaitForLogEntries,
+          TransformUtils.persistentMemberIdToLogEntryTransformer);
-      StartupStatus
-      .startup(LocalizedStrings.CreatePersistentRegionProcessor_WAITING_FOR_ONLINE_LATEST_MEMBER, 
-          new Object[] {regionPath, TransformUtils.persistentMemberIdToLogEntryTransformer.transform(getPersistentID()),
-          membersToWaitForLogEntries});
+      StartupStatus.startup(
+          LocalizedStrings.CreatePersistentRegionProcessor_WAITING_FOR_ONLINE_LATEST_MEMBER,
+          new Object[] {regionPath,
+              TransformUtils.persistentMemberIdToLogEntryTransformer.transform(getPersistentID()),
+              membersToWaitForLogEntries});
-  protected void checkInterruptedByShutdownAll() {
-  }
+  protected void checkInterruptedByShutdownAll() {}
-    
+
-    
+
-    
+
-    public void waitForChange(Set<PersistentMemberID> allMembersToWaitFor, Set<PersistentMemberID> offlineMembersToWaitFor) throws InterruptedException {
-      synchronized(this) {
+
+    public void waitForChange(Set<PersistentMemberID> allMembersToWaitFor,
+        Set<PersistentMemberID> offlineMembersToWaitFor) throws InterruptedException {
+      synchronized (this) {
-          while(!membershipChanged && !isClosed) {
+          while (!membershipChanged && !isClosed) {
-            
-            //Fix for #50415 go out and message other members to see if there
-            //status has changed. This handles any case where we might have
-            //missed a notification due to concurrent startup.
-            if(time > exitTime) {
+
+            // Fix for #50415 go out and message other members to see if there
+            // status has changed. This handles any case where we might have
+            // missed a notification due to concurrent startup.
+            if (time > exitTime) {
-            
-            if(!warned && time > warningTime) {
-              
+
+            if (!warned && time > warningTime) {
+
-              
-              warned=true;
+
+              warned = true;
-      synchronized(this) {
+      synchronized (this) {
-    public void memberSuspect(InternalDistributedMember id,
-        InternalDistributedMember whoSuspected, String reason) {
-    }
+    public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected,
+        String reason) {}
-    public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
-    }
+    public void quorumLost(Set<InternalDistributedMember> failures,
+        List<InternalDistributedMember> remaining) {}
-    public void memberOffline(InternalDistributedMember member,
-        PersistentMemberID persistentID) {
+    public void memberOffline(InternalDistributedMember member, PersistentMemberID persistentID) {
-    public void memberOnline(InternalDistributedMember member,
-        PersistentMemberID persistentID) {
+    public void memberOnline(InternalDistributedMember member, PersistentMemberID persistentID) {
-      if(cp.persistentID != null) {
-        if(regionDestroyed) {
+      if (cp.persistentID != null) {
+        if (regionDestroyed) {
-      if(cp.persistentID != null && cp.persistenceInitialized) {
+      if (cp.persistentID != null && cp.persistenceInitialized) {
-      return pattern.matches(getPersistentID()) || pattern.matches(getInitializingID()); 
-     }
+      return pattern.matches(getPersistentID()) || pattern.matches(getInitializingID());
+    }
-      if(id != null) {
+      if (id != null) {
-      if(id != null) {
+      if (id != null) {
-    this.online= false;
+    this.online = false;
-    
+
-    for (PersistentMemberID persistentID: map.values()) {
+    for (PersistentMemberID persistentID : map.values()) {
-  
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
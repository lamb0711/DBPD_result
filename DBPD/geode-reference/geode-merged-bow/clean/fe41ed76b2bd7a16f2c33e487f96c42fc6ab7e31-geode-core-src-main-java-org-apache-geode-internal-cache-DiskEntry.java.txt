GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-import org.apache.geode.internal.cache.Token.Tombstone;
- *
- * <P>
- *
- * Each <code>DiskEntry</code> has a unique <code>id</code> that is used by the {@link DiskRegion}
- * to identify the key/value pair. Before the disk entry is written to disk, the value of the
- * <code>id</code> is {@link DiskRegion#INVALID_ID invalid}. Once the object has been written to
- * disk, the <code>id</code> is a positive number. If the value is {@linkplain Helper#update
- * updated}, then the <code>id</code> is negated to signify that the value on disk is dirty.
+ * <p>
+ * Each {@code DiskEntry} has a unique {@code id} that is used by the {@link DiskRegion} to identify
+ * the key/value pair. Before the disk entry is written to disk, the value of the {@code id} is
+ * {@link DiskRegion#INVALID_ID invalid}. Once the object has been written to disk, the {@code id}
+ * is a positive number. If the value is {@linkplain Helper#update updated}, then the {@code id} is
+ * negated to signify that the value on disk is dirty.
- *
- *
-   * 
-   * @param context
-   * Returns the id of this <code>DiskEntry</code>
+   * Returns the id of this {@code DiskEntry}
-  public void _removePhase1();
-
-  /////////////////////// Inner Classes //////////////////////
-
-   * A Helper class for performing functions common to all <code>DiskEntry</code>s.
+   * A Helper class for performing functions common to all {@code DiskEntry}s.
-
-     * @throws DiskAccessException
-            Object v = entry._getValueRetain(context, true); // TODO:KIRK:OK Rusty had Object v =
-                                                             // entry.getValueWithContext(context);
+            Object v = entry._getValueRetain(context, true);
+
-          v = de._getValueRetain(context, true); // OFFHEAP copied to heap entry; todo allow entry
-                                                 // to refer to offheap since it will be copied to
-                                                 // network.
+
+          // OFFHEAP copied to heap entry;
+          // TODO: allow entry to refer to offheap since it will be copied to network.
+          v = de._getValueRetain(context, true);
+
-            } catch (DiskAccessException dae) {
+            } catch (DiskAccessException ignore) {
-              byte[] bb = (byte[]) tmp;
-              entry.value = bb;
+              entry.value = (byte[]) tmp;
-                RuntimeException e2 = new IllegalArgumentException(
+                throw new IllegalArgumentException(
-                        .toLocalizedString());
-                e2.initCause(e);
-                throw e2;
+                        .toLocalizedString(),
+                    e);
-          if (!Tombstone.isInvalidOrRemoved(re.getValue())) {
+          if (!Token.isInvalidOrRemoved(re.getValue())) {
-        StringBuffer sb = new StringBuffer();
+        StringBuilder sb = new StringBuilder();
-     * @throws RegionClearedException
-     * 
-     * 
-     * @throws RegionClearedException
-            // Asif Ensure that the value is rightly set despite clear so
+            // Ensure that the value is rightly set despite clear so
-      Object v = entry._getValueRetain(region, true); // TODO:KIRK:OK Object v =
-                                                      // entry.getValueWithContext(region);
+      Object v = entry._getValueRetain(region, true);
+
-          v = entry._getValueRetain(region, true); // TODO:KIRK:OK v =
-                                                   // entry.getValueWithContext(region);
+          v = entry._getValueRetain(region, true);
+
-        // } else if (v instanceof ByteSource) {
-        // // If the ByteSource contains a Delta or ListOfDelta then we want to deserialize it
-        // Object deserVal = ((CachedDeserializable)v).getDeserializedForReading();
-        // if (deserVal != v) {
-        // OffHeapHelper.release(v);
-        // v = deserVal;
-        // }
-    /**
-     * 
-     * @param entry
-     * @param region
-     * @return Value
-     * @throws DiskAccessException
-     */
-      Object v = entry._getValueRetain(region, true); // TODO:KIRK:OK Object v =
-                                                      // entry.getValueWithContext(region);
+      Object v = entry._getValueRetain(region, true);
+
-              boolean evicted = ((LRUEntry) entry).testEvicted();
+              boolean evicted = ((LRUClockNode) entry).testEvicted();
-            v = entry._getValueRetain(region, true); // TODO:KIRK:OK v =
-                                                     // entry.getValueWithContext(region);
+            v = entry._getValueRetain(region, true);
+
-            DiskRecoveryStore region = recoveryStore;
-            DiskRegionView dr = region.getDiskRegionView();
+            DiskRegionView dr = recoveryStore.getDiskRegionView();
-                    setValueOnFaultIn(value, did, entry, dr, region);
+                    setValueOnFaultIn(value, did, entry, dr, recoveryStore);
-          ((VMLRURegionMap) recoveryStore.getRegionMap()).updateStats();
+          ((AbstractLRURegionMap) recoveryStore.getRegionMap()).updateStats();
-     * Writes the value of this <code>DiskEntry</code> to disk and <code>null</code> s out the
-     * reference to the value to free up VM space.
+     * Writes the value of this {@code DiskEntry} to disk and {@code null} s out the reference to
+     * the value to free up VM space.
-     * 
-     * see #writeToDisk
-     * 
-     * @throws RegionClearedException
-      final int oldSize = region.calculateRegionEntryValueSize(entry);;
-      // Asif:Get diskID . If it is null, it implies it is
-      // overflow only mode.
-      // long id = entry.getDiskId().getKeyId();
+      final int oldSize = region.calculateRegionEntryValueSize(entry);
+      // Get diskID . If it is null, it implies it is overflow only mode.
-          // TODO:Asif: Check if we need to overflow even when id is = 0
+          // TODO: Check if we need to overflow even when id is = 0
-                        && entry instanceof LRUEntry && ((LRUEntry) entry).testEvicted()) {
+                        && entry instanceof LRUEntry && ((LRUClockNode) entry).testEvicted()) {
-    /**
-     * @param entry
-     * @param region
-     * @param tag
-     */
-     * 

UPD66 INS66 INS65 INS66 INS65 UPD66 INS66 UPD66 INS65 UPD66 UPD66 INS65 UPD66 INS66 INS65 INS66 UPD66 INS66 INS66 INS66 INS66 UPD66 INS66 UPD66 INS65 UPD66 INS65 INS66 INS66 INS66 UPD66 INS65 INS66 INS65 INS66 UPD66 UPD43 INS66 INS66 UPD42 UPD43 UPD42 UPD42 UPD43 UPD42 UPD42 UPD42 MOV11 MOV14 UPD43 INS42 UPD42 UPD42 UPD43 UPD42 DEL40 DEL26 DEL42 DEL65 DEL83 DEL39 DEL42 DEL31 DEL42 DEL65 DEL39 DEL85 DEL5 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL66 DEL65 DEL42 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL66 DEL42 DEL65 DEL20 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL29
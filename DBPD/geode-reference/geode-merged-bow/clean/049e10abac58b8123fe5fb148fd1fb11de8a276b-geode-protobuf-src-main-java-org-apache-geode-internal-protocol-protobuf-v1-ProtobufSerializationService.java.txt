GEODE-4961: Allowing custom serialization formats with the protobuf protocol

Adding a new ValueSerializer interface that users can implement to
control the serialization format of data sent using the protobuf
protocol.

ValueSerializers are registered on the server side using the java
ServiceLoader mechanism. They are selected by the client using a new
valueFormat field in the handshake.

Renamed AuthenticationRequest to HandshakeRequest. Credentials
and valueFormat are all sent as part of a single HandshakeRequest.

Renamed the connection states to make them a little easier to
understand, and removed some duplicate states.

The new states are RequireVersion, RequireAuthentication,
AcceptMessages, InvalidSecurity, and TerminateConnection



+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import org.apache.geode.internal.protocol.serialization.NoOpCustomValueSerializer;
+import org.apache.geode.protocol.serialization.ValueSerializer;
+  private final ValueSerializer serializer;
-  public ProtobufSerializationService() {}
+  public ProtobufSerializationService() {
+    this(new NoOpCustomValueSerializer());
+  }
+
+  public ProtobufSerializationService(ValueSerializer valueSerializer) {
+    this.serializer = valueSerializer;
+  }
-    if (value == null) {
-      return BasicTypes.EncodedValue.newBuilder().setNullResult(NullValue.NULL_VALUE).build();
-    }
-
+      if (serializer.supportsPrimitives()) {
+        ByteString encoded = serializer.serialize(value);
+        return builder.setCustomObjectResult(encoded).build();
+      }
+
+      if (value == null) {
+        return builder.setNullResult(NullValue.NULL_VALUE).build();
+      }
+
-        case PDX_OBJECT: {
-          builder.setJsonObjectResult(jsonPdxConverter.encode((PdxInstance) value));
+        default: {
+          ByteString customResult = customSerialize(value);
+          if (customResult != null) {
+            builder.setCustomObjectResult(customResult);
+          } else if (value instanceof PdxInstance) {
+            builder.setJsonObjectResult(jsonPdxConverter.encode((PdxInstance) value));
+          } else {
+            throw new EncodingException("No handler for object type " + value.getClass());
+          }
-        default:
-          throw new EncodingException("No handler for protobuf type "
-              + ProtobufEncodingTypes.valueOf(value.getClass()).toString());
-    } catch (UnknownProtobufEncodingType unknownProtobufEncodingType) {
-      throw new EncodingException("No protobuf encoding for type " + value.getClass().getName());
+    } catch (UnknownProtobufEncodingType e) {
+      throw new EncodingException("No protobuf encoding for type " + value.getClass().getName(), e);
+    } catch (IOException e) {
+      throw new EncodingException("Error encoding type " + value.getClass().getName(), e);
+  private ByteString customSerialize(Object value) throws IOException {
+    return serializer instanceof NoOpCustomValueSerializer ? null : serializer.serialize(value);
+  }
+
-    switch (encodedValue.getValueCase()) {
-      case BINARYRESULT:
-        return encodedValue.getBinaryResult().toByteArray();
-      case BOOLEANRESULT:
-        return encodedValue.getBooleanResult();
-      case BYTERESULT:
-        return (byte) encodedValue.getByteResult();
-      case DOUBLERESULT:
-        return encodedValue.getDoubleResult();
-      case FLOATRESULT:
-        return encodedValue.getFloatResult();
-      case INTRESULT:
-        return encodedValue.getIntResult();
-      case LONGRESULT:
-        return encodedValue.getLongResult();
-      case SHORTRESULT:
-        return (short) encodedValue.getShortResult();
-      case STRINGRESULT:
-        return encodedValue.getStringResult();
-      case JSONOBJECTRESULT:
-        return jsonPdxConverter.decode(encodedValue.getJsonObjectResult());
-      case NULLRESULT:
-        return null;
-      default:
-        throw new DecodingException(
-            "Unknown Protobuf encoding type: " + encodedValue.getValueCase());
+
+    try {
+      switch (encodedValue.getValueCase()) {
+        case BINARYRESULT:
+          return encodedValue.getBinaryResult().toByteArray();
+        case BOOLEANRESULT:
+          return encodedValue.getBooleanResult();
+        case BYTERESULT:
+          return (byte) encodedValue.getByteResult();
+        case DOUBLERESULT:
+          return encodedValue.getDoubleResult();
+        case FLOATRESULT:
+          return encodedValue.getFloatResult();
+        case INTRESULT:
+          return encodedValue.getIntResult();
+        case LONGRESULT:
+          return encodedValue.getLongResult();
+        case SHORTRESULT:
+          return (short) encodedValue.getShortResult();
+        case STRINGRESULT:
+          return encodedValue.getStringResult();
+        case JSONOBJECTRESULT:
+          return jsonPdxConverter.decode(encodedValue.getJsonObjectResult());
+        case NULLRESULT:
+          return null;
+        case CUSTOMOBJECTRESULT:
+          return serializer.deserialize(encodedValue.getCustomObjectResult());
+        default:
+          throw new DecodingException(
+              "Unknown Protobuf encoding type: " + encodedValue.getValueCase());
+      }
+    } catch (IOException | ClassNotFoundException e) {
+      throw new DecodingException("Error decoding value", e);
+    // If any classes are added to this list that are not final, the logic
+    // in valueOf must change. It currently works only if the user's class
+    // is exactly the same as the class listed here.
-
-    // This will probably have to change once the protocol supports multiple object encodings.
-    PDX_OBJECT(PdxInstance.class);
+    OTHER(Object.class);
+    private static Map<Class, ProtobufEncodingTypes> classToType = new HashMap<>();
+
+    static {
+      for (ProtobufEncodingTypes type : values()) {
+        classToType.put(type.clazz, type);
+      }
+    }
+
-      for (ProtobufEncodingTypes protobufEncodingTypes : values()) {
-        if (protobufEncodingTypes.clazz.isAssignableFrom(unencodedValueClass)) {
-          return protobufEncodingTypes;
-        }
+      ProtobufEncodingTypes type = classToType.get(unencodedValueClass);
+      if (type != null) {
+        return type;
+      } else {
+        return OTHER;
-      throw new UnknownProtobufEncodingType(
-          "There is no primitive protobuf type mapping for class:" + unencodedValueClass);

INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS83 INS83 INS43 INS59 INS83 INS42 INS44 INS8 INS83 INS43 INS42 INS44 INS43 INS8 INS8 INS23 INS28 INS42 INS42 INS17 INS43 INS42 INS21 INS42 INS43 INS42 INS42 INS41 INS54 UPD42 INS83 INS83 INS74 INS59 INS83 INS8 INS14 INS42 INS7 INS12 INS42 INS16 MOV8 INS12 UPD43 INS43 INS43 INS43 INS42 INS14 INS70 INS60 INS25 INS43 INS22 INS42 INS25 INS25 INS44 INS8 INS62 INS33 INS32 INS44 INS8 UPD42 INS42 INS42 INS42 INS74 MOV44 MOV32 INS8 INS43 INS59 INS27 MOV8 INS8 INS42 INS52 INS42 INS32 INS8 MOV27 INS8 INS49 INS8 UPD42 INS43 INS42 INS53 INS42 INS43 INS42 INS42 INS42 INS41 INS49 INS84 INS42 INS53 INS43 UPD42 INS21 INS42 INS42 INS32 INS42 INS33 INS41 INS42 INS42 INS60 INS41 INS41 INS60 INS25 INS10 INS42 INS14 INS42 INS42 INS32 INS43 INS43 INS14 INS42 INS32 UPD42 MOV42 INS42 MOV42 UPD42 INS42 INS43 INS59 INS32 INS32 INS43 INS59 INS27 INS8 INS25 INS42 INS43 INS27 INS42 INS42 INS42 INS32 INS42 INS42 INS43 INS45 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS62 MOV8 INS8 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS32 INS42 INS43 MOV53 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD45 MOV32 DEL40 DEL42 DEL32 DEL42 DEL40 DEL32 DEL42 DEL32 DEL41 DEL8 DEL25 DEL10 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL49 DEL49 DEL40 DEL32 DEL25 DEL8 DEL70 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
-  /**This should be called before performing a profile exchange for the region,
-   * but after the persistent data has been read.
+
+  /**
+   * This should be called before performing a profile exchange for the region, but after the
+   * persistent data has been read.
-  
+
-   * Try to acquire the distributed lock which members must grab for
-   * in the case of a tie. Whoever gets the lock initializes first.
+   * Try to acquire the distributed lock which members must grab for in the case of a tie. Whoever
+   * gets the lock initializes first.
-   * Determine the state of this member on it's peers, along with
-   * the PersistentMemberID of those peers.
-   * @return a map from the peers persistentId to the state of this
-   * member according to that peer.
+   * Determine the state of this member on it's peers, along with the PersistentMemberID of those
+   * peers.
+   * 
+   * @return a map from the peers persistentId to the state of this member according to that peer.
-  PersistentStateQueryResults getMyStateOnMembers(
-      Set<InternalDistributedMember> members) throws ReplyException, InterruptedException;
+  PersistentStateQueryResults getMyStateOnMembers(Set<InternalDistributedMember> members)
+      throws ReplyException, InterruptedException;
-   * Add a listener for changes to the persistent state of peers 
+   * Add a listener for changes to the persistent state of peers
-   * Remove a listener for changes to the persistent state of peers 
+   * Remove a listener for changes to the persistent state of peers
-   * Get the set of peers that are online 
+   * Get the set of peers that are online
-  
-  
-  /**Update the membership on this member to reflect changes
-   * that have happened since the member was last online. This method
-   * should be called before the member is online.
+
+
+  /**
+   * Update the membership on this member to reflect changes that have happened since the member was
+   * last online. This method should be called before the member is online.
+   * 
-  public void updateMembershipView(InternalDistributedMember replicate, boolean targetReinitializing);
-  
+  public void updateMembershipView(InternalDistributedMember replicate,
+      boolean targetReinitializing);
+
+   * 
-   * @param atomicCreation - indicates that we are coming online as part of
-   * an atomic bucket creation.
+   * @param atomicCreation - indicates that we are coming online as part of an atomic bucket
+   *        creation.
-  public void setOnline(boolean didGII, boolean atomicCreation,
-      PersistentMemberID newId);
-  
+  public void setOnline(boolean didGII, boolean atomicCreation, PersistentMemberID newId);
+
-   * Indicate that the current member has started the initialization process.
-   * This creates a new persistent ID for this member and notifies other members
-   * about it.
+   * Indicate that the current member has started the initialization process. This creates a new
+   * persistent ID for this member and notifies other members about it.
-  void prepareNewMember(InternalDistributedMember sender, PersistentMemberID oldId, PersistentMemberID newId);
-  
+  void prepareNewMember(InternalDistributedMember sender, PersistentMemberID oldId,
+      PersistentMemberID newId);
+
-   * Called when a peer has destroyed the region. This is usually
-   * handled by the destroy region code, but if a member crashes
-   * during a destroy, it may trigger this removal during recovery.
+   * Called when a peer has destroyed the region. This is usually handled by the destroy region
+   * code, but if a member crashes during a destroy, it may trigger this removal during recovery.
-  
+
-   * Called when a peer returns that it has closed the cache or region when
-   * a region operation was in flight.
+   * Called when a peer returns that it has closed the cache or region when a region operation was
+   * in flight.
-   * If this member was initializing when it crashed or is currently in the
-   * process of becoming online, this return the new ID of the member
+   * If this member was initializing when it crashed or is currently in the process of becoming
+   * online, this return the new ID of the member
-  
+
-  
+
-   * Check to see if the other members know about the current member
-   * .
+   * Check to see if the other members know about the current member .
+   * 
-   * @throws ConflictingPersistentDataException if the other members were not part of
-   * the same distributed system as the persistent data on in this VM.
-   * @return true if we detected that we actually have the same data
-   * on disk as another member.
+   * @throws ConflictingPersistentDataException if the other members were not part of the same
+   *         distributed system as the persistent data on in this VM.
+   * @return true if we detected that we actually have the same data on disk as another member.
-  public boolean checkMyStateOnMembers(Set<InternalDistributedMember> replicates) throws ReplyException, InterruptedException, ConflictingPersistentDataException;
+  public boolean checkMyStateOnMembers(Set<InternalDistributedMember> replicates)
+      throws ReplyException, InterruptedException, ConflictingPersistentDataException;
-  
+
-   * Returns the member id of the member who has the latest
-   * copy of the persistent region. This may be the local member ID
-   * if this member has the latest known copy.
+   * Returns the member id of the member who has the latest copy of the persistent region. This may
+   * be the local member ID if this member has the latest known copy.
-   * @param recoverFromDisk 
-   * @throws ConflictingPersistentDataException if there are active members
-   * which are not based on the state that is persisted in this member.
+   * 
+   * @param recoverFromDisk
+   * @throws ConflictingPersistentDataException if there are active members which are not based on
+   *         the state that is persisted in this member.
-  
+
-  
-  /* 
+
+  /*
-   * @param Map<InternalDistributedMember, PersistentMemberID>
-   *   map of current online members
+   * 
+   * @param Map<InternalDistributedMember, PersistentMemberID> map of current online members
-  
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
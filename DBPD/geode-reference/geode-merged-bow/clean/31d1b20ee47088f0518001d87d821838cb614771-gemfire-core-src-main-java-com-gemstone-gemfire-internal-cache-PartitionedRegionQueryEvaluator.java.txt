Initial import of geode-1.0.0.0-SNAPSHOT-2.
All the new sub-project directories (like jvsd) were not imported.
A diff was done to confirm that this commit is exactly the same as
the open directory the snapshot was made from.

+import java.util.Comparator;
+import com.gemstone.gemfire.cache.query.Struct;
+import com.gemstone.gemfire.cache.query.internal.CompiledGroupBySelect;
+import com.gemstone.gemfire.cache.query.internal.CumulativeNonDistinctResults;
+import com.gemstone.gemfire.cache.query.internal.CumulativeNonDistinctResults.Metadata;
+import com.gemstone.gemfire.cache.query.internal.NWayMergeResults;
+import com.gemstone.gemfire.cache.query.internal.OrderByComparator;
+import com.gemstone.gemfire.cache.query.internal.ResultsSet;
+import com.gemstone.gemfire.cache.query.internal.SortedResultsBag;
+import com.gemstone.gemfire.cache.query.internal.SortedStructBag;
+import com.gemstone.gemfire.cache.query.internal.StructSet;
+import com.gemstone.gemfire.cache.query.internal.parse.OQLLexerTokenTypes;
+import com.gemstone.gemfire.cache.query.internal.types.StructTypeImpl;
+import com.gemstone.gemfire.cache.query.internal.utils.PDXUtils;
+import com.gemstone.gemfire.internal.Version;
-  private volatile Map node2bucketIds;
+  private volatile Map<InternalDistributedMember,List<Integer>> node2bucketIds;
-    this.node2bucketIds = Collections.EMPTY_MAP;
+    this.node2bucketIds = Collections.emptyMap();
+    //check if sender is pre gfe_90. In that case the results coming from them are not sorted
+    // we will have to sort it
+    boolean sortNeeded = false;
+    List<CompiledSortCriterion> orderByAttribs = null;
+    if(sender.getVersionObject().compareTo(Version.GFE_90) < 0 ) {
+      CompiledSelect cs = this.query.getSimpleSelect();
+      if(cs != null && cs.isOrderBy()) {
+        sortNeeded = true;
+        orderByAttribs = cs.getOrderByAttrs();
+      }
+      
+      
+    }
+    if(sortNeeded) {
+      objects = sortIncomingData(objects, orderByAttribs);
+    }
-      if (!QueryMonitor.isLowMemory()) {
-        results.add(objects);
+      if (!QueryMonitor.isLowMemory()) {        
+          results.add(objects);        
+
+  //TODO Asif: optimize it by creating a Sorted SelectResults Object at the time of fromData , so 
+  // that processData already recieves ordered data.
+  private List sortIncomingData(List objects,
+      List<CompiledSortCriterion> orderByAttribs) {
+    ObjectType resultType = cumulativeResults.getCollectionType().getElementType();
+    ExecutionContext local = new ExecutionContext(null, this.pr.cache);
+    Comparator comparator = new OrderByComparator(orderByAttribs, resultType, local);
+    boolean nullAtStart = !orderByAttribs.get(0).getCriterion();
+    final SelectResults newResults; 
+    //Asif: There is a bug in the versions < 9.0, such that the struct results coming from the 
+    // bucket nodes , do not contain approrpiate ObjectTypes. All the projection fields have 
+    // have the types as ObjectType. The resultset being created here has the right more selective type.
+    // so the addition of objects throw exception due to type mismatch. To handle this problem, instead
+    // of adding the struct objects as is, add fieldValues.
+    if(resultType != null && resultType.isStructType() )  {
+      SortedStructBag sortedStructBag = new SortedStructBag(comparator, (StructType) resultType, 
+          nullAtStart);
+      for(Object o : objects) {
+        Struct s = (Struct)o;
+        sortedStructBag.addFieldValues(s.getFieldValues());
+      }
+      newResults = sortedStructBag;
+    }else {
+      newResults = new SortedResultsBag(comparator,resultType, nullAtStart);
+      newResults.addAll(objects) ;
+    }
+        
+   
+    objects = newResults.asList();
+    return objects;
+  }
+  
-    HashMap n2b = new HashMap(this.node2bucketIds);
+    HashMap<InternalDistributedMember,List<Integer>> n2b = new HashMap<InternalDistributedMember,List<Integer>>(this.node2bucketIds);
-        for (Iterator itr = n2b.entrySet().iterator(); itr.hasNext();) {
-          Map.Entry me = (Map.Entry) itr.next();
-          final InternalDistributedMember rcp = (InternalDistributedMember) me.getKey();
-          final List bucketIds = (List) me.getValue();
+        for (Iterator<Map.Entry<InternalDistributedMember,List<Integer>>> itr = n2b.entrySet().iterator(); itr.hasNext();) {
+          Map.Entry<InternalDistributedMember , List<Integer>> me =  itr.next();
+          final InternalDistributedMember rcp =  me.getKey();
+          final List<Integer> bucketIds =  me.getValue();
-  public void queryBuckets(final TestHook th) throws QueryException, InterruptedException {
+  public SelectResults queryBuckets(final TestHook th) throws QueryException, InterruptedException {
-    addResultsToResultSet();
+    return addResultsToResultSet();
-    Iterator memberToBucketList = node2bucketIds.entrySet().iterator();
+    Iterator<Map.Entry<InternalDistributedMember,List<Integer>>> memberToBucketList = node2bucketIds.entrySet().iterator();
-      Map.Entry<InternalDistributedMember, ArrayList<Integer>> e = (Map.Entry)memberToBucketList.next();
+      Map.Entry<InternalDistributedMember, List<Integer>> e = memberToBucketList.next();
-  private void addResultsToResultSet() throws QueryException {
+  private SelectResults addResultsToResultSet() throws QueryException {
-    boolean isStructBag = false;
-    boolean isResultBag = false;
-
+    
+
+    int limit = -1; // -1 indicates no limit wsa specified in the query
+    // passed as null. Not sure if it can happen in real life situation.
+    // So instead of modifying test , using a null check in constructor
+    CompiledSelect cs = null;
+
-    int limit = -1; //-1 indicates no limit wsa specified in the query
-    //passed as null. Not sure if it can happen in real life situation.
-    //So instead of modifying test , using a null check in constructor
-    CompiledSelect cs =null;
-    
-    // Indicates whether to check for PdxInstance and convert them to 
-    // domain object. 
-    // In case of local queries the domain objects are stored in the result set
-    // for client/server queries PdxInstance are stored in result set. 
-    boolean getDomainObjectForPdx;
-    //indicated results from remote nodes need to be deserialized
-    //for local queries
-    boolean getDeserializedObject = false;
-    
-    if(this.query != null) {
-      cs =  this.query.getSimpleSelect();
+
+    if (this.query != null) {
+      cs = this.query.getSimpleSelect();
-      isDistinct = (cs != null)? cs.isDistinct():true;
-      isCount = (cs != null)? cs.isCount():false;
-    }
-    
-    if (isCount && !isDistinct) {
-      addTotalCountForMemberToResults(limit);
-      return;
-    } 
-    
-    if (this.cumulativeResults instanceof StructBag) {
-    	isStructBag = true;
-    } else if (this.cumulativeResults instanceof ResultsBag) {
-    	isResultBag = true;
-    	//TODO:Asif: Idealy the isOrdered should  be the sufficient condtion. Remove the orderbyAttribs null check
-    } else if (this.cumulativeResults.getCollectionType().isOrdered() && cs.getOrderByAttrs() != null) {
-      // If its a sorted result set, sort local and remote results using query.
-      buildSortedResult(cs, limit);
-      return;
+      isDistinct = (cs != null) ? cs.isDistinct() : true;
+      isCount = (cs != null) ? cs.isCount() : false;
+    if (isCount && !isDistinct) {
+      addTotalCountForMemberToResults(limit);
+      return this.cumulativeResults;
+    }
+
+    boolean isGroupByResults = cs.getType() == CompiledValue.GROUP_BY_SELECT;
+    if(isGroupByResults) {
+      SelectResults baseResults = null;
+      CompiledGroupBySelect cgs = (CompiledGroupBySelect) cs;
+      if(cgs.getOrderByAttrs() != null && !cgs.getOrderByAttrs().isEmpty()) {
+        baseResults = this.buildSortedResult(cs, limit);        
+      }else {
+        baseResults = this.buildCumulativeResults(isDistinct, limit);
+      }
+      ExecutionContext context = new ExecutionContext(null, pr.cache);
+      context.setIsPRQueryNode(true);
+      return cgs.applyAggregateAndGroupBy(baseResults, context);
+    }else {
+
+      if (this.cumulativeResults.getCollectionType().isOrdered()
+        && cs.getOrderByAttrs() != null) {
+      // If its a sorted result set, sort local and remote results using query.
+        return buildSortedResult(cs, limit);        
+      }else {  
+        return buildCumulativeResults(isDistinct, limit);
+      }
+    }
+  }
+
+  private SelectResults buildCumulativeResults(boolean isDistinct, int limit) {
+    // Indicates whether to check for PdxInstance and convert them to
+    // domain object.
+    // In case of local queries the domain objects are stored in the result set
+    // for client/server queries PdxInstance are stored in result set.
+    boolean getDomainObjectForPdx;
+    // indicated results from remote nodes need to be deserialized
+    // for local queries
+    boolean getDeserializedObject = false;
+    int numElementsInResult = 0;
+    
+    ObjectType elementType = this.cumulativeResults.getCollectionType().getElementType();
+    boolean isStruct = elementType != null && elementType.isStructType();
+  
-    for (Map.Entry<InternalDistributedMember, Collection<Collection>> e : this.resultsPerMember.entrySet()) {
+    
+    List<CumulativeNonDistinctResults.Metadata> collectionsMetadata =null;
+    List<Collection> results = null;
+    
+    if(isDistinct) {
+      if(isStruct) {
+        StructType stype = (StructType)elementType;
+        this.cumulativeResults = new StructSet(stype);
+      }else {
+        this.cumulativeResults = new ResultsSet(elementType);
+      }
+    }else {
+      collectionsMetadata = new ArrayList<CumulativeNonDistinctResults.Metadata>();
+      results =  new ArrayList<Collection>();
+    }
+    
+    for (Map.Entry<InternalDistributedMember, Collection<Collection>> e : this.resultsPerMember
+        .entrySet()) {
-        getDomainObjectForPdx = !(this.pr.getCache().getPdxReadSerializedByAnyGemFireServices());
+        getDomainObjectForPdx = !(this.pr.getCache()
+            .getPdxReadSerializedByAnyGemFireServices());
-        if(!getDeserializedObject && !((DefaultQuery)this.query).isKeepSerialized()){
+        if (!getDeserializedObject
+            && !((DefaultQuery) this.query).isKeepSerialized()) {
-      
-      for (Collection res : e.getValue()) {
-        checkLowMemory();
-        //final TaintableArrayList res = (TaintableArrayList) e.getValue();      
-        if (res != null) {
-          if (isDebugEnabled) {
-            logger.debug("Query Result from member :{}: {}", e.getKey(), res.size());
-          }
-          if (limit == -1 && !getDomainObjectForPdx && !getDeserializedObject && 
-              (!isDistinct && localResults /* This check is to convert PdxString in projection lists to String */)) {
-            this.cumulativeResults.addAll(res);
-          } else {
+      if (!isDistinct) {
+        CumulativeNonDistinctResults.Metadata wrapper = CumulativeNonDistinctResults
+            .getCollectionMetadata(getDomainObjectForPdx,
+                getDeserializedObject, localResults);
+       
+          for (Collection res : e.getValue()) {
+            results.add(res);
+            collectionsMetadata.add(wrapper);    
+          }        
+      } else {
+        for (Collection res : e.getValue()) {
+          checkLowMemory();
+          // final TaintableArrayList res = (TaintableArrayList) e.getValue();
+          if (res != null) {
+            if (isDebugEnabled) {
+              logger.debug("Query Result from member :{}: {}", e.getKey(),
+                  res.size());
+            }
+
+            boolean[] objectChangedMarker = new boolean[1];
+            
-              if (isStructBag) {
-                StructImpl simpl = (StructImpl) obj;
-                if (getDomainObjectForPdx) {
-                  try {
-                    if (simpl.isHasPdx()) {
-                      occurence = ((ResultsBag) this.cumulativeResults).addAndGetOccurence(simpl.getPdxFieldValues());
-                    } else {
-                      occurence = ((ResultsBag) this.cumulativeResults).addAndGetOccurence(simpl.getFieldValues());
-                    }
-                  } catch (Exception ex) {
-                    throw new QueryException(
-                        "Unable to retrieve domain object from PdxInstance while building the ResultSet. "
-                        + ex.getMessage());
-                  }
-                } else {
-                  Object[] values = simpl.getFieldValues();
-                  if(getDeserializedObject){
-                    for (int i = 0; i < values.length; i++) {
-                      if(values[i] instanceof VMCachedDeserializable){
-                        values[i] = ((VMCachedDeserializable)values[i]).getDeserializedForReading();
-                      }
-                    }
-                  }
-                  /* This is to convert PdxString to String */                
-                  if (simpl.isHasPdx() && isDistinct && localResults) {
-                    for (int i = 0; i < values.length; i++) {
-                      if(values[i] instanceof PdxString){
-                        values[i] = ((PdxString)values[i]).toString();
-                      }
-                    }
-                  }
-                  occurence = ((ResultsBag) this.cumulativeResults).addAndGetOccurence(values);
-                }
-              } else {
-                if (getDomainObjectForPdx) {
-                  if(obj instanceof PdxInstance){
-                    try {
-                      obj = ((PdxInstance) obj).getObject();
-                    } catch (Exception ex) {
-                      throw new QueryException(
-                          "Unable to retrieve domain object from PdxInstance while building the ResultSet. "
-                          + ex.getMessage());
-                    }
-                  }
-                  else if (obj instanceof PdxString){
-                    obj = ((PdxString)obj).toString();
-                  }
-                } else if (isDistinct && localResults && obj instanceof PdxString) {
-                  /* This is to convert PdxString to String */
-                  obj = ((PdxString)obj).toString();
-                }
-                
-                if (isResultBag) {
-                  if(getDeserializedObject && obj instanceof VMCachedDeserializable) {
-                    obj = ((VMCachedDeserializable)obj).getDeserializedForReading();
-                  }
-                    occurence = ((ResultsBag) this.cumulativeResults)
-                  .addAndGetOccurence(obj);
-                } else {
-                  if(getDeserializedObject && obj instanceof VMCachedDeserializable) {
-                      obj = ((VMCachedDeserializable)obj).getDeserializedForReading();
-                  } 
-                  
-                  // Resultset or StructSet, SortedResultSet, SortedStructSet.
-                  // Once we start passing Object[] in the List , the below should
-                  // change for StructSet and possibly SortedStructSet
-                  occurence = this.cumulativeResults.add(obj) ? 1 : 0;
-                }
-              }
-
+              obj = PDXUtils.convertPDX(obj, isStruct,
+                  getDomainObjectForPdx, getDeserializedObject, localResults, objectChangedMarker, true);
+              boolean elementGotAdded = isStruct? ((StructSet)this.cumulativeResults).addFieldValues((Object[])obj):
+                this.cumulativeResults.add(obj);
+              occurence = elementGotAdded ? 1 : 0;
-              if (occurence == 1 || (occurence > 1 && !isDistinct)) {
+              if (occurence == 1) {
-    
-    if (prQueryTraceInfoList != null && this.query.isTraced() && logger.isInfoEnabled()) {
+
+    if (prQueryTraceInfoList != null && this.query.isTraced()
+        && logger.isInfoEnabled()) {
-      sb.append(LocalizedStrings.PartitionedRegion_QUERY_TRACE_LOG.toLocalizedString(this.query.getQueryString())).append("\n");
-      for (PRQueryTraceInfo queryTraceInfo: prQueryTraceInfoList) {
+      sb.append(
+          LocalizedStrings.PartitionedRegion_QUERY_TRACE_LOG
+              .toLocalizedString(this.query.getQueryString())).append("\n");
+      for (PRQueryTraceInfo queryTraceInfo : prQueryTraceInfoList) {
-      logger.info(sb.toString());;
+      logger.info(sb.toString());
+      ;
+    if (!isDistinct) {
+      this.cumulativeResults =  new CumulativeNonDistinctResults(results, limit,
+          this.cumulativeResults.getCollectionType().getElementType(),
+          collectionsMetadata);
+
+    } 
+    return this.cumulativeResults;
+  
-  private void buildSortedResult(CompiledSelect cs, int limit) throws QueryException {
-    List projAttrs = cs.getProjectionAttributes();
-    List orderByAttrs = cs.getOrderByAttrs();
-    //boolean isCount = cs.isCount();
-    //List pIterators = cs.getIterators();
-    
-    String eMsg = "Unable to apply order-by on the partition region cumulative results.";
-    Assert.assertTrue(!(orderByAttrs == null), eMsg + " Null order-by attributes.");
-    List iterators = cs.getIterators();
-   
-    String projFields = null;
-    //Map<String, Boolean> orderByFields = new LinkedHashMap<String,Boolean>();
-    List<String> projectionFields = new LinkedList<String>();
+  private SelectResults buildSortedResult(CompiledSelect cs, int limit) throws QueryException {
-      // Evaluate projection attributes.
-      //Create local execution context
-    //If order by clause is present , then compute dependency locally
-      
-      ExecutionContext localContext = new QueryExecutionContext(this.parameters,
+     ExecutionContext localContext = new QueryExecutionContext(this.parameters,
-      localContext.newScope(0);
-
-      Iterator iter = iterators.iterator();
-      while (iter.hasNext()) {
-
-        CompiledIteratorDef iterDef = (CompiledIteratorDef)iter.next();
-        // compute dependencies on this iter first before adding its
-        // RuntimeIterator to the current scope.
-        // this makes sure it doesn't bind attributes to itself
-        localContext.addDependencies(cs, iterDef
-            .computeDependencies(localContext));
-        RuntimeIterator rIter = iterDef.getRuntimeIterator(localContext);
-        localContext.addToIndependentRuntimeItrMap(iterDef);
-        localContext.bindIterator(rIter);
-
-      }
-
-      ObjectType type = cs.prepareResultType(localContext);
-      StringBuffer tempQueryBuffer = new StringBuffer(" order by ");
-      if (type.isStructType()) {
-        StructType structType = (StructType)type;
-        String[] fieldNames = structType.getFieldNames();
-        if (projAttrs == null) {
-          // Evaluate path iterators, in case of multiple paths appropriate
-          // alias needs to be added.
-          // E.g.: select distinct * from /r p, p.positions.values pos order by
-          // p.ID =>
-          // select distinct * from $1 m order by r.p.ID
-          List<RuntimeIterator> runTimeItrs = localContext
-              .getCurrentIterators();
-          Iterator<RuntimeIterator> itr = runTimeItrs.iterator();
-          while (itr.hasNext()) {
-            StringBuffer temp = new StringBuffer();
-            RuntimeIterator rIter = itr.next();
-            rIter.setIndexInternalID(null);
-            rIter.generateCanonicalizedExpression(temp, localContext);
-            projectionFields.add(temp.toString());
-          }
-
-        }
-        else {
-          Iterator<Object[]> itr = projAttrs.iterator();
-          while (itr.hasNext()) {
-            StringBuffer temp = new StringBuffer();
-            Object[] values = itr.next();
-            ((CompiledValue)values[1]).generateCanonicalizedExpression(temp,
-                localContext);
-            projectionFields.add(temp.toString());
-          }
-        }
-        // Evaluate order by attributes.
-        for (int i = 0; i < orderByAttrs.size(); i++) {
-          Object o = orderByAttrs.get(i);
-          if (o instanceof CompiledSortCriterion) {
-            CompiledSortCriterion csc = (CompiledSortCriterion)o;
-            CompiledValue cv = csc.getExpr();
-            StringBuffer temp = new StringBuffer();
-            cv.generateCanonicalizedExpression(temp, localContext);
-            Iterator<String> projFieldItr = projectionFields.iterator();
-            int index = 0;
-            boolean foundMatch = false;
-            String orderBy = temp.toString();
-            while (projFieldItr.hasNext() && !foundMatch) {
-              String projStr = projFieldItr.next();
-              // int indexOfDot = orderBy.indexOf('.');
-              if (orderBy.equals(projStr)) {
-                // exact match , just append the field name
-                tempQueryBuffer.append(' ');
-                tempQueryBuffer.append(fieldNames[index]);
-                tempQueryBuffer.append(' ');
-                tempQueryBuffer.append(csc.getCriterion() ? " desc " : " asc ");
-                tempQueryBuffer.append(',');
-                foundMatch = true;
-              }
-              else if (orderBy.startsWith(projStr)) {
-                tempQueryBuffer.append(fieldNames[index]);
-                tempQueryBuffer.append(temp.substring(projStr.length()));
-
-                tempQueryBuffer.append(' ');
-                tempQueryBuffer.append(csc.getCriterion() ? " desc " : " asc ");
-                tempQueryBuffer.append(',');
-                foundMatch = true;
-              }
-              ++index;
-            }
-            if (!foundMatch) {
-              throw new QueryException("Order by clause " + orderBy
-                  + " not derivable from any projection attribute");
-            }
-
-            // orderByFields.put(temp.toString(), !csc.getCriterion());
-          }
-        }
-        tempQueryBuffer.deleteCharAt(tempQueryBuffer.length() - 1);
-
-      }
-      else {
-        String projStr = null;
-        if (projAttrs == null) {
-          List<RuntimeIterator> runTimeItrs = localContext
-              .getCurrentIterators();
-          Iterator<RuntimeIterator> itr = runTimeItrs.iterator();
-
-          StringBuffer temp = new StringBuffer();
-          RuntimeIterator rIter = itr.next();
-          rIter.setIndexInternalID(null);
-          rIter.generateCanonicalizedExpression(temp, localContext);
-          projStr = temp.toString();
-        }
-
-        else {
-          Iterator<Object[]> itr = projAttrs.iterator();
-          StringBuffer temp = new StringBuffer();
-          Object[] values = itr.next();
-          ((CompiledValue)values[1]).generateCanonicalizedExpression(temp,
-              localContext);
-          projStr = temp.toString();
-
-        }
-        // Evaluate order by attributes.
-        for (int i = 0; i < orderByAttrs.size(); i++) {
-          Object o = orderByAttrs.get(i);
-
-          if (o instanceof CompiledSortCriterion) {
-            CompiledSortCriterion csc = (CompiledSortCriterion)o;
-            CompiledValue cv = csc.getExpr();
-            StringBuffer temp = new StringBuffer();
-            cv.generateCanonicalizedExpression(temp, localContext);
-
-            String orderBy = temp.toString();
-            // int indexOfDot = temp.indexOf(".");
-
-            if (orderBy.equals(projStr)) {
-              // exact match , just append the field name
-              tempQueryBuffer.append(' ');
-              tempQueryBuffer.append("iter");
-              tempQueryBuffer.append(' ');
-
-            }
-            else if (orderBy.startsWith(projStr)) {
-              tempQueryBuffer.append(' ');
-              String attr = temp.substring(projStr.length() + 1);
-              // escape reserved keywords
-              attr = checkReservedKeyword(attr);
-              tempQueryBuffer.append(attr);
-            }
-            else {
-              throw new QueryException("Order by clause " + orderBy
-                  + " not derivable from projection attribute " + projStr);
-            }
-
-            tempQueryBuffer.append(' ');
-            tempQueryBuffer.append(csc.getCriterion() ? " desc " : " asc ");
-            tempQueryBuffer.append(',');
-          }
-        }
-        tempQueryBuffer.deleteCharAt(tempQueryBuffer.length() - 1);
-      }
-
-      tempQueryBuffer.insert(0, " SELECT DISTINCT * FROM $1 iter ");
-      if (logger.isDebugEnabled()) {
-        logger.debug("The temp query generated to evaluate order-by on PR commulative results: {}", tempQueryBuffer.toString());
-      }
-
-      DefaultQuery q = (DefaultQuery)this.pr.getCache().getQueryService()
-          .newQuery(tempQueryBuffer.toString());
-      ExecutionContext context;
-      
-      final DistributedMember me = this.pr.getMyId();
-
+      List<Collection> allResults = new ArrayList<Collection>();
-            context = new QueryExecutionContext((new Object[] { res }), this.pr
-                .getCache(), this.cumulativeResults, q);
-            q.executeUsingContext(context);
+            allResults.add(res);
+      
+      this.cumulativeResults = new NWayMergeResults(allResults, cs.isDistinct(), limit, cs.getOrderByAttrs(), 
+          localContext, cs.getElementTypeForOrderByQueries());
+      return this.cumulativeResults;
+    
-    if (cv instanceof CompiledID)  {
+    if (cv.getType() == OQLLexerTokenTypes.Identifier)  {
-        if (cv instanceof CompiledPath || cv instanceof CompiledIndexOperation) {
-          if (cv instanceof CompiledIndexOperation) {
+        if (cv.getType() == CompiledPath.PATH || cv.getType() == OQLLexerTokenTypes.TOK_LBRACK) {
+          if (cv.getType() == OQLLexerTokenTypes.TOK_LBRACK) {
-        } else if (cv instanceof CompiledOperation) {
+        } else if (cv.getType() == OQLLexerTokenTypes.METHOD_INV) {
-      } while (!(cv instanceof CompiledID));
+      } while (!(cv.getType() == OQLLexerTokenTypes.Identifier));
-      if (cv instanceof CompiledID) {
+      if (cv.getType() == OQLLexerTokenTypes.Identifier) {
-  private void buildSortedResultBackup(CompiledSelect cs, int limit) throws QueryException {
-    List projAttrs = cs.getProjectionAttributes();
-    List orderByAttrs = cs.getOrderByAttrs();
-    List pIterators = cs.getIterators();
-    //boolean isDistinct = (cs != null)? cs.isDistinct():true;
-    
-    String eMsg = "Unable to apply order-by on the partition region cumulative results.";
-    Assert.assertTrue(!(orderByAttrs == null), eMsg + " Null order-by attributes.");
-    
-    StringBuffer fromPath =  new StringBuffer();
-    String projFields = null;
-    HashMap<String, String> orderByFields = new HashMap<String, String>();
-    
-    try {
-      // Evaluate projection attributes.
-      String fromIter = "";
-      if (projAttrs == null) {
-        // Evaluate path iterators, in case of multiple paths appropriate alias needs to be added.
-        // E.g.: select distinct * from /r p, p.positions.values pos order by p.ID =>
-        //         select distinct * from $1 m order by r.p.ID
-        for (int i = 1; i < pIterators.size(); i++) {
-          CompiledIteratorDef iterDef = (CompiledIteratorDef) pIterators.get(i-1);   
-          fromIter += (iterDef.getName() + ("."));
-        }
-      } else if (projAttrs.size() == 1) {
-        // In case single projections, it should be treated as the ordered field.
-        // E.g: select distinct status from /r order by status => select distinct * from $1 p order by p 
-        Object projDef[] = (Object[])projAttrs.get(0);
-        if (projDef[1] instanceof CompiledID) {
-          projFields = ((CompiledID)projDef[1]).getId();
-        } else if (projDef[1] instanceof CompiledPath) {
-          CompiledPath cp = (CompiledPath)projDef[1];
-          projFields = ((CompiledID)cp.getReceiver()).getId() + "." + cp.getTailID();
-        } else if (projDef[1] instanceof CompiledOperation) {
-          // Function call.
-          CompiledOperation cp = (CompiledOperation)projDef[1];
-          projFields = ((CompiledID)cp.getReceiver(null)).getId() + "." + cp.getMethodName() + "()";
-        } else {
-          throw new QueryException("Failed to evaluate projection attributes. " + eMsg);
-        }
-      }
-     
-      // Evaluate order by attributes.
-      for (int i = 0; i < orderByAttrs.size(); i++) {
-        Object o = orderByAttrs.get(i);
-        String orderByClause = "";
-        if (o instanceof CompiledSortCriterion) {
-          CompiledSortCriterion csc = (CompiledSortCriterion)o;
-          CompiledValue cv = csc.getExpr();  
-          
-          // field with multiple level like p.pos.secId
-          if (cv instanceof CompiledID)  {
-            // It will be p.pos.secId
-            orderByClause = ((CompiledID)cv).getId() + orderByClause;
-          } else {
-            do {
-            if (cv instanceof CompiledPath || cv instanceof CompiledIndexOperation) {
-              if (cv instanceof CompiledIndexOperation) {
-                CompiledIndexOperation cio = (CompiledIndexOperation)cv;
-                CompiledLiteral cl = (CompiledLiteral)cio.getExpression();
-                StringBuffer sb = new StringBuffer();
-                cl.generateCanonicalizedExpression(sb, null);
-                cv = ((CompiledIndexOperation)cv).getReceiver();
-                if (sb.length() > 0) {
-                  orderByClause = "[" + sb.toString() + "]" + orderByClause;
-                }
-              }
-              orderByClause = ("." + ((CompiledPath)cv).getTailID() + orderByClause);
-            } else if (cv instanceof CompiledOperation) {
-              // Function call.
-              orderByClause = "." + ((CompiledOperation)cv).getMethodName() + "()" + orderByClause;
-            } else if (cv instanceof CompiledIndexOperation) {
-              StringBuffer sb = new StringBuffer();
-              
-              //((CompiledIndexOperation)cv).generateCanonicalizedExpression(sb, null);
-              //if (cv2 instanceof CompiledPath) {
-              
-              //orderByClause = "." + ((CompiledIndexOperation)cv).+ "()";
-              //}
-            } else {
-              throw new QueryException("Failed to evaluate order by attributes, found unsupported type  " + cv.getType() + " " + eMsg);
-            }
-            // Ignore subsequent paths.
-            //do {
-                cv = cv.getReceiver();
-            } while (!(cv instanceof CompiledID));
-            
-            if (cv instanceof CompiledID) {
-              orderByClause = ((CompiledID)cv).getId() + orderByClause;
-              // Append region iterator alias. p
-              if (i == 0) {
-                fromPath.append(((CompiledID)cv).getId());
-                //if ((i+1) < orderByAttrs.size()) {
-                //  fromPath.append(", ");
-                //}
-              }
-            }
-            
-          } 
-          /*
-          else if (cv instanceof CompiledOperation) {
-            orderByClause = ((CompiledID)cv).getId() + orderByClause;
-          } else {
-            throw new QueryException("Failed to evaluate order-by attributes. " + eMsg);              
-          }
-          */
-          orderByFields.put(fromIter + orderByClause, (csc.getCriterion()? " desc " : " asc "));
-        }
-      }
-
-      StringBuffer tmpSortQuery =  new StringBuffer("SELECT DISTINCT * FROM $1 ");    
-      if (projFields != null && orderByFields.containsKey(projFields)) {
-        // Select distinct p.status from /region p order by p.status asc
-        // => Select distinct * from $1 p order by p asc
-        if (fromPath.length() > 0) {
-          tmpSortQuery.append(fromPath).append(" ORDER BY ").append(fromPath).append(" ").append(orderByFields.get(projFields));
-        } else {
-          tmpSortQuery.append(fromPath).append("p ORDER BY p").append(orderByFields.get(projFields));
-        }
-      } else {
-        /*
-        if (fromPath.length() > 0) {
-          tmpSortQuery.append(fromPath).append(" ORDER BY ").append(fromPath).append(".");
-        } else {
-        */
-        tmpSortQuery.append(fromPath).append(" ORDER BY ");
-        //}
-        Iterator iter = orderByFields.entrySet().iterator();
-        while (iter.hasNext()) {
-          Map.Entry<String, String> e = (Map.Entry<String, String>)iter.next();
-          tmpSortQuery.append(e.getKey()).append(" ").append(e.getValue());
-          if (iter.hasNext()) {
-            tmpSortQuery.append(", ");
-          }
-        }
-      }
-
-      if (logger.isDebugEnabled()) {
-        logger.debug("The temp query generated to evaluate order-by on PR commulative results: {}", tmpSortQuery);
-      }
-      
-      DefaultQuery q = (DefaultQuery)this.pr.getCache().getQueryService().newQuery(tmpSortQuery.toString());
-      ExecutionContext context;
-      for (Iterator i=this.resultsPerMember.values().iterator(); i.hasNext(); ) {
-        final TaintableArrayList res = (TaintableArrayList)i.next();
-        if (res!=null && res.isConsumable()) {
-          context = new QueryExecutionContext((new Object[] {res}), this.pr.getCache(), this.cumulativeResults, q);
-          q.executeUsingContext(context);
-          res.clear();
-        }
-      }   
-    } catch (Exception ex) {
-      throw new QueryException("Unable to apply order-by on the partition region cumulative results.", ex);
-    }
-  }
-  Map buildNodeToBucketMap() throws QueryException
+  Map<InternalDistributedMember, List<Integer>> buildNodeToBucketMap() throws QueryException
-  private Map buildNodeToBucketMapForBuckets(final Set<Integer> bucketIdsToConsider) 
+  private Map<InternalDistributedMember, List<Integer>> buildNodeToBucketMapForBuckets(final Set<Integer> bucketIdsToConsider) 
-    final HashMap<InternalDistributedMember, ArrayList<Integer>> ret = new 
-    HashMap<InternalDistributedMember, ArrayList<Integer>>();
+    final HashMap<InternalDistributedMember, List<Integer>> ret = new 
+    HashMap<InternalDistributedMember,List<Integer>>();
-    final ArrayList<Integer> bucketIds = new ArrayList<Integer>();
+    final List<Integer> bucketIds = new ArrayList<Integer>();
-      final ArrayList<Integer> buckets = new ArrayList<Integer>();
+      final List<Integer> buckets = new ArrayList<Integer>();
-      List bucketList = (List)this.node2bucketIds.get(me);
+      List<Integer> bucketList = this.node2bucketIds.get(me);
-    for (Iterator itr = this.node2bucketIds.entrySet().iterator(); itr.hasNext(); ) {
-      Map.Entry entry = (Map.Entry)itr.next();
-      List blist = (List)entry.getValue();
-      for (Iterator itr2 = blist.iterator(); itr2.hasNext(); ) {
-        Integer bid = (Integer)itr2.next();
+    for (Iterator<Map.Entry<InternalDistributedMember,List<Integer>>> itr = this.node2bucketIds.entrySet().iterator(); itr.hasNext(); ) {
+      Map.Entry<InternalDistributedMember,List<Integer>> entry = itr.next();
+      List<Integer> blist = entry.getValue();
+      for (Iterator<Integer> itr2 = blist.iterator(); itr2.hasNext(); ) {
+        Integer bid = itr2.next();
+    public ObjectType getResultType() {
+      return PartitionedRegionQueryEvaluator.this.cumulativeResults.getCollectionType().getElementType();
+    }

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS31 MOV83 MOV83 INS74 MOV59 INS83 MOV43 INS42 INS44 INS44 INS8 INS43 INS83 INS43 INS42 MOV43 INS8 INS43 INS42 INS44 MOV44 MOV60 MOV60 MOV29 INS83 INS43 INS42 MOV44 MOV44 MOV43 INS8 INS74 INS74 INS31 MOV43 INS43 INS74 INS60 INS60 INS25 INS25 INS43 INS42 INS74 INS42 MOV60 MOV60 INS60 INS60 MOV60 INS25 MOV21 INS41 INS42 INS41 UPD42 MOV42 INS60 MOV60 MOV60 MOV60 MOV60 MOV25 MOV25 MOV60 MOV25 INS42 INS39 INS42 INS60 INS60 INS60 INS25 INS70 MOV25 INS41 INS42 INS54 MOV43 INS43 UPD74 MOV74 MOV43 INS43 UPD74 MOV74 INS83 INS43 INS42 INS8 UPD42 MOV42 INS43 INS43 INS39 INS59 INS74 INS59 INS27 INS8 INS42 INS8 UPD42 MOV42 MOV43 MOV43 UPD43 INS43 INS59 INS39 INS59 INS83 UPD43 INS27 INS8 MOV8 INS42 INS74 MOV32 INS74 INS39 INS59 INS39 INS42 INS8 INS43 MOV39 INS59 INS74 INS59 INS74 INS59 INS42 INS8 MOV8 MOV44 MOV32 INS8 MOV38 INS22 INS8 MOV12 INS27 INS42 INS42 UPD43 UPD42 MOV42 UPD43 UPD74 INS74 INS42 INS41 MOV42 UPD42 MOV42 INS32 INS42 INS9 INS43 MOV43 INS42 INS33 INS32 INS34 INS60 INS25 INS21 UPD42 UPD42 UPD42 INS14 UPD42 MOV42 INS42 INS14 UPD42 MOV42 INS38 UPD42 UPD42 INS27 INS32 INS60 INS70 MOV21 UPD42 MOV43 MOV43 INS74 MOV43 INS74 UPD42 MOV42 MOV34 UPD42 INS27 MOV60 MOV60 INS25 MOV60 MOV21 INS41 MOV25 INS42 UPD42 INS32 INS42 INS27 MOV43 INS43 INS42 INS33 MOV43 INS43 INS42 INS33 INS25 MOV21 MOV21 MOV21 MOV25 MOV60 INS25 INS52 INS42 MOV60 MOV60 INS70 INS21 INS41 INS32 INS40 UPD42 UPD42 MOV43 UPD43 INS74 MOV43 INS43 INS74 INS32 INS42 INS42 INS42 INS32 INS42 INS40 INS43 INS59 INS27 INS8 INS7 INS32 UPD42 INS43 INS33 INS22 INS43 INS42 INS42 INS42 INS32 UPD42 MOV42 MOV33 UPD42 MOV42 UPD42 MOV42 UPD43 MOV43 INS59 INS44 INS42 INS8 INS7 INS42 INS42 INS43 INS43 INS74 MOV43 INS43 INS74 UPD74 MOV22 INS32 INS40 UPD43 UPD43 INS27 INS8 MOV8 MOV43 INS32 INS32 INS8 INS32 INS42 UPD27 MOV27 INS32 INS42 INS40 INS42 INS42 UPD42 MOV42 INS8 MOV8 MOV38 MOV8 INS8 UPD74 MOV74 MOV44 MOV32 INS8 INS7 MOV22 INS42 INS42 INS27 UPD42 MOV43 INS43 UPD74 INS42 INS74 INS74 MOV43 INS74 INS74 MOV59 UPD74 MOV74 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS32 INS21 INS21 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV22 INS42 UPD42 MOV42 INS32 MOV42 UPD42 UPD42 MOV42 INS14 MOV43 INS42 MOV60 MOV21 INS42 INS42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 MOV43 INS43 INS74 INS74 INS42 INS43 INS43 INS74 MOV32 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS33 UPD42 UPD42 INS27 INS38 MOV21 UPD42 INS42 UPD42 MOV42 INS9 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS41 MOV22 INS42 UPD42 INS33 INS42 INS42 MOV60 MOV21 INS42 INS14 INS42 INS14 INS60 INS70 INS70 MOV22 INS14 UPD43 UPD42 INS70 MOV22 INS14 MOV32 INS40 INS42 MOV43 UPD43 INS74 MOV43 INS43 MOV43 MOV43 MOV32 MOV43 MOV43 UPD74 MOV74 MOV43 MOV43 UPD74 MOV74 UPD42 UPD43 MOV32 INS74 INS22 INS42 INS22 INS42 INS42 INS33 INS42 INS42 INS7 INS7 INS42 INS42 INS42 UPD42 MOV42 MOV42 INS34 UPD43 MOV43 INS42 INS11 INS42 UPD43 UPD43 INS42 INS42 INS42 INS42 INS43 INS43 MOV43 INS74 INS74 MOV43 INS74 INS42 MOV42 INS43 INS43 UPD43 INS42 MOV32 INS33 INS32 MOV43 INS33 INS40 MOV32 INS32 MOV43 UPD74 MOV74 INS74 INS43 INS59 INS44 MOV32 INS8 MOV44 MOV32 INS8 INS43 INS42 INS42 INS32 INS42 UPD42 UPD74 MOV74 MOV44 INS42 INS8 INS43 INS42 INS32 INS42 MOV32 INS42 INS32 INS27 UPD42 MOV43 INS43 INS42 UPD42 MOV42 MOV43 MOV43 UPD42 MOV43 MOV43 MOV43 INS52 INS42 INS52 INS42 INS42 INS9 INS42 MOV32 UPD42 UPD43 MOV43 INS42 UPD42 UPD42 UPD42 UPD42 INS32 UPD42 INS42 INS42 MOV43 INS43 INS74 MOV43 INS43 INS74 MOV32 MOV32 INS43 INS43 MOV32 INS42 INS42 UPD42 UPD42 UPD42 INS32 INS42 UPD42 INS32 UPD42 INS32 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV22 INS14 MOV22 INS14 UPD43 INS43 INS43 INS40 INS42 INS32 UPD43 MOV43 UPD42 MOV42 UPD42 MOV42 INS21 INS21 MOV21 INS25 INS42 INS32 UPD42 MOV42 INS43 MOV25 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS27 INS27 INS27 INS32 INS40 INS42 MOV32 INS42 UPD42 UPD43 UPD42 MOV42 UPD42 MOV42 INS42 INS43 INS43 INS42 INS43 INS43 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS52 INS42 INS42 UPD42 MOV42 INS52 INS42 INS42 UPD42 MOV42 UPD43 UPD42 INS43 INS42 INS43 INS42 INS40 INS42 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 INS42 UPD42 INS32 INS32 MOV27 INS8 MOV22 INS42 INS42 MOV27 INS32 INS40 INS32 INS40 INS27 INS32 INS40 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 MOV25 MOV25 INS60 INS70 INS42 INS42 INS42 INS42 INS32 INS40 INS42 INS42 INS5 INS59 MOV44 INS42 INS8 INS42 INS42 INS39 INS85 INS42 INS3 MOV21 MOV60 INS21 INS60 MOV21 MOV25 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS5 INS34 INS7 INS39 INS59 MOV27 INS39 INS85 INS42 INS32 INS42 INS16 INS16 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS9 INS42 MOV32 MOV32 INS42 INS34 INS34 UPD42 INS11 MOV5 INS42 UPD43 UPD42 DEL23 DEL40 DEL42 DEL11 DEL33 DEL32 DEL45 DEL45 DEL16 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL36 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL34 DEL2 DEL11 DEL36 DEL42 DEL11 DEL11 DEL11 DEL39 DEL21 DEL11 DEL42 DEL43 DEL32 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL42 DEL27 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL11 DEL42 DEL42 DEL32 DEL45 DEL42 DEL43 DEL42 DEL11 DEL36 DEL32 DEL42 DEL27 DEL36 DEL45 DEL42 DEL43 DEL42 DEL11 DEL36 DEL32 DEL45 DEL42 DEL27 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL32 DEL42 DEL27 DEL7 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL27 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL7 DEL21 DEL34 DEL27 DEL42 DEL45 DEL32 DEL45 DEL42 DEL27 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL8 DEL42 DEL43 DEL45 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL25 DEL25 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL62 DEL36 DEL38 DEL19 DEL42 DEL42 DEL43 DEL62 DEL42 DEL34 DEL27 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL21 DEL39 DEL42 DEL42 DEL9 DEL59 DEL60 DEL39 DEL9 DEL34 DEL38 DEL42 DEL43 DEL62 DEL42 DEL9 DEL7 DEL21 DEL8 DEL42 DEL43 DEL62 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL25 DEL42 DEL43 DEL11 DEL36 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL43 DEL11 DEL36 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL2 DEL42 DEL43 DEL42 DEL42 DEL2 DEL11 DEL36 DEL42 DEL32 DEL42 DEL42 DEL2 DEL43 DEL42 DEL42 DEL2 DEL11 DEL36 DEL42 DEL32 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL43 DEL62 DEL8 DEL25 DEL8 DEL24 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL27 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL43 DEL62 DEL8 DEL25 DEL8 DEL24 DEL8 DEL25 DEL42 DEL42 DEL43 DEL11 DEL36 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL32 DEL7 DEL21 DEL8 DEL44 DEL42 DEL43 DEL45 DEL32 DEL27 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL32 DEL7 DEL21 DEL8 DEL25 DEL25 DEL42 DEL42 DEL34 DEL27 DEL27 DEL36 DEL27 DEL42 DEL38 DEL27 DEL42 DEL38 DEL27 DEL42 DEL27 DEL36 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL42 DEL42 DEL32 DEL27 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL62 DEL27 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL32 DEL7 DEL21 DEL8 DEL25 DEL25 DEL42 DEL42 DEL42 DEL42 DEL43 DEL62 DEL27 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL34 DEL34 DEL16 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL70 DEL8 DEL25 DEL8 DEL25 DEL8 DEL70 DEL8 DEL70 DEL42 DEL42 DEL42 DEL43 DEL62 DEL27 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL32 DEL42 DEL43 DEL42 DEL43 DEL45 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL42 DEL32 DEL45 DEL32 DEL42 DEL42 DEL32 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL59 DEL60 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL33 DEL27 DEL36 DEL38 DEL42 DEL45 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL42 DEL34 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL61 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL61 DEL8 DEL43 DEL42 DEL43 DEL85 DEL5 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL34 DEL2 DEL11 DEL36 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL61 DEL8 DEL25 DEL39 DEL34 DEL59 DEL58 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL62 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL38 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL13 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL2 DEL32 DEL21 DEL42 DEL42 DEL13 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL45 DEL45 DEL16 DEL32 DEL21 DEL42 DEL42 DEL13 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL2 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL21 DEL42 DEL42 DEL13 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL45 DEL45 DEL16 DEL32 DEL21 DEL42 DEL42 DEL13 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL25 DEL42 DEL38 DEL21 DEL8 DEL61 DEL42 DEL38 DEL42 DEL43 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL25 DEL8 DEL25 DEL8 DEL24 DEL42 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL32 DEL21 DEL8 DEL27 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL32 DEL59 DEL60 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL33 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL43 DEL85 DEL5 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL60 DEL42 DEL34 DEL2 DEL11 DEL36 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL62 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL13 DEL32 DEL21 DEL42 DEL42 DEL45 DEL32 DEL21 DEL42 DEL42 DEL13 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL13 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL45 DEL42 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL25 DEL42 DEL42 DEL13 DEL32 DEL21 DEL42 DEL42 DEL13 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL42 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL34 DEL45 DEL32 DEL21 DEL42 DEL42 DEL32 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL11 DEL59 DEL60 DEL42 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL59 DEL60 DEL42 DEL25 DEL8 DEL70 DEL8 DEL70 DEL8 DEL54 DEL8 DEL31 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL33 DEL27 DEL36 DEL38 DEL42 DEL45 DEL27 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL33 DEL27 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL45 DEL36 DEL27 DEL36 DEL7 DEL21 DEL8 DEL24 DEL8 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL43 DEL42 DEL85 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL34 DEL32 DEL11 DEL59 DEL60 DEL42 DEL34 DEL2 DEL42 DEL43 DEL62 DEL8 DEL42 DEL34 DEL2 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL34 DEL2 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL36 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL27 DEL7 DEL21 DEL8 DEL42 DEL34 DEL2 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL34 DEL2 DEL11 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL42 DEL33 DEL32 DEL11 DEL36 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL45 DEL27 DEL7 DEL21 DEL8 DEL42 DEL43 DEL45 DEL42 DEL27 DEL14 DEL53 DEL8 DEL25 DEL25 DEL25 DEL8 DEL25 DEL25 DEL39 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL27 DEL42 DEL42 DEL32 DEL45 DEL45 DEL16 DEL36 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL8 DEL42 DEL42 DEL42 DEL32 DEL42 DEL45 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL45 DEL32 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL8 DEL61 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL43 DEL42 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL11 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL32 DEL27 DEL42 DEL42 DEL43 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL36 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL31 DEL11 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL40 DEL43 DEL42 DEL40 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL11 DEL42 DEL43 DEL11
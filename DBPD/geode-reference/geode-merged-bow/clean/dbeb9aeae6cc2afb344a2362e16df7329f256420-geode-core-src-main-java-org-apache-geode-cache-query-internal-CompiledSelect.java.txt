Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
-  protected List<CompiledSortCriterion> orderByAttrs; //order by attributes: list of CompiledValue
+
+  protected List<CompiledSortCriterion> orderByAttrs; // order by attributes: list of CompiledValue
-  protected List projAttrs; //projection attributes: list of Object[2]:
-     // 0 is projection name, 1 is the CompiledValue for the expression 
+  protected List projAttrs; // projection attributes: list of Object[2]:
+  // 0 is projection name, 1 is the CompiledValue for the expression
-  //Asif: limits the SelectResults by the number specified.
+  // Asif: limits the SelectResults by the number specified.
-  //Shobhit: counts the no of results satisfying where condition for
+  // Shobhit: counts the no of results satisfying where condition for
-  
+
-  //Are not serialized and are recreated when compiling the query
+  // Are not serialized and are recreated when compiling the query
-  private boolean hasUnmappedOrderByCols = false; 
+  private boolean hasUnmappedOrderByCols = false;
-  //used as a key in a context to identify the scope of this CompiledSelect 
-  private Object scopeID = new Object(); 
-  
+  // used as a key in a context to identify the scope of this CompiledSelect
+  private Object scopeID = new Object();
+
-   * Set in context for the where clause to signify that it has been evaluated at least one time
-   * for any other CompiledValue that may use precalculated indexes
-   * we want to mark this as Evaluated so that we don't unlock locks
-   * that don't belong to this iteration of evaluate.
-   * This is similar to how CompiledComparisons store their IndexInfo in the context
-   * but for example a CompiledJunction that uses 2 Comparisons
-   * would have unlocked the readlocks because we check to see if the clause has a mapped value
-   * in the context. Because CompiledJunctions did not, we unlocked the read locks.
-   * Now we set a value so that it will not do this. See where we use this value to see how unlock is determined
+   * Set in context for the where clause to signify that it has been evaluated at least one time for
+   * any other CompiledValue that may use precalculated indexes we want to mark this as Evaluated so
+   * that we don't unlock locks that don't belong to this iteration of evaluate. This is similar to
+   * how CompiledComparisons store their IndexInfo in the context but for example a CompiledJunction
+   * that uses 2 Comparisons would have unlocked the readlocks because we check to see if the clause
+   * has a mapped value in the context. Because CompiledJunctions did not, we unlocked the read
+   * locks. Now we set a value so that it will not do this. See where we use this value to see how
+   * unlock is determined
-  public CompiledSelect(boolean distinct, boolean count, CompiledValue whereClause,
-                        List iterators, List projAttrs,List<CompiledSortCriterion> orderByAttrs, CompiledValue limit,
-                        List<String> hints, List<CompiledValue> groupByClause) {
+  public CompiledSelect(boolean distinct, boolean count, CompiledValue whereClause, List iterators,
+      List projAttrs, List<CompiledSortCriterion> orderByAttrs, CompiledValue limit,
+      List<String> hints, List<CompiledValue> groupByClause) {
-     
+
-    
+
-    
+
-      for (Iterator itr = this.projAttrs.iterator(); itr.hasNext(); ) {
-        list.add(((Object[])itr.next())[1]);
+      for (Iterator itr = this.projAttrs.iterator(); itr.hasNext();) {
+        list.add(((Object[]) itr.next())[1]);
-    
+
-    
+
-  
-  public boolean isDistinct() { 
+
+  public boolean isDistinct() {
-  
-  public boolean isGroupBy() { 
+
+  public boolean isGroupBy() {
-  
-  public boolean isOrderBy() { 
+
+  public boolean isOrderBy() {
-    
+
-  public boolean isCount() { 
+  public boolean isCount() {
-    
+
+
-  
+
-  
+
-  
+
-  
+
-  throws TypeMismatchException,
-         AmbiguousNameException,
-         NameResolutionException {
+      throws TypeMismatchException, AmbiguousNameException, NameResolutionException {
-    context.newScope((Integer)context.cacheGet(scopeID));
-    context.pushExecCache((Integer)context.cacheGet(scopeID));
+    context.newScope((Integer) context.cacheGet(scopeID));
+    context.pushExecCache((Integer) context.cacheGet(scopeID));
-        
+
-        RuntimeIterator rIter = iterDef.getRuntimeIterator(context);    
+        RuntimeIterator rIter = iterDef.getRuntimeIterator(context);
-      
-      //    is the where clause dependent on itr?
+
+      // is the where clause dependent on itr?
-          totalDependencySet  = context.addDependencies(this, prjExpr.computeDependencies(context));
+          totalDependencySet = context.addDependencies(this, prjExpr.computeDependencies(context));
-        
+
-      }else {
+      } else {
-      if (this.whereClause != null) {
-        return context.addDependencies(this, this.whereClause.computeDependencies(context));
-      }
-      else {
-        return context.getDependencySet(this, true);
-      }*/
-    }
-    finally {
+       * if (this.whereClause != null) { return context.addDependencies(this,
+       * this.whereClause.computeDependencies(context)); } else { return
+       * context.getDependencySet(this, true); }
+       */
+    } finally {
-  
-  protected void doTreeTransformation(ExecutionContext context) throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-    if(!this.transformationDone) {
+
+  protected void doTreeTransformation(ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+    if (!this.transformationDone) {
-      this.transformGroupByIfPossible(context);         
+      this.transformGroupByIfPossible(context);
-  
+
+   * 
-  private void transformGroupByIfPossible(ExecutionContext context) 
-      throws AmbiguousNameException, TypeMismatchException, NameResolutionException  {
-    //for time being assume that the group by cols are explicitly mentioned in proj
-    if(this.groupBy != null) {
+  private void transformGroupByIfPossible(ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+    // for time being assume that the group by cols are explicitly mentioned in proj
+    if (this.groupBy != null) {
-      if(projAttribs == null) {
+      if (projAttribs == null) {
-        for(Object o: currentIters) {
-          RuntimeIterator rIter = (RuntimeIterator)o;
+        for (Object o : currentIters) {
+          RuntimeIterator rIter = (RuntimeIterator) o;
-          projAttribs.add(new Object[]{name, rIter});
+          projAttribs.add(new Object[] {name, rIter});
-      
-      if(projAttribs != null && projAttribs.size() != this.groupBy.size()) {
+
+      if (projAttribs != null && projAttribs.size() != this.groupBy.size()) {
-            LocalizedStrings.DefaultQuery_PROJ_COL_ABSENT_IN_GROUP_BY.toLocalizedString() +" or "
-            + LocalizedStrings.DefaultQuery_GROUP_BY_COL_ABSENT_IN_PROJ.toLocalizedString());
+            LocalizedStrings.DefaultQuery_PROJ_COL_ABSENT_IN_GROUP_BY.toLocalizedString() + " or "
+                + LocalizedStrings.DefaultQuery_GROUP_BY_COL_ABSENT_IN_PROJ.toLocalizedString());
-     
+
-      
-      outer :for(int i = 0; i < projAttribs.size() ; ++i) {
+
+      outer: for (int i = 0; i < projAttribs.size(); ++i) {
-        if(prj[0] != null) {
-          if( groupByAttr instanceof CompiledID ) {
-            if (prj[0].equals(((CompiledID)groupByAttr).getId())) {              
-              lhsBuffer.delete(0,lhsBuffer.length());
-              rhsBuffer.delete(0,rhsBuffer.length());
-              continue;  
+        if (prj[0] != null) {
+          if (groupByAttr instanceof CompiledID) {
+            if (prj[0].equals(((CompiledID) groupByAttr).getId())) {
+              lhsBuffer.delete(0, lhsBuffer.length());
+              rhsBuffer.delete(0, rhsBuffer.length());
+              continue;
-        if(lhsBuffer.length() == rhsBuffer.length()) {          
-          for(int indx = 0; indx < lhsBuffer.length() ; ++indx) {
-            if(lhsBuffer.charAt(indx) != rhsBuffer.charAt(indx)) {
+        if (lhsBuffer.length() == rhsBuffer.length()) {
+          for (int indx = 0; indx < lhsBuffer.length(); ++indx) {
+            if (lhsBuffer.charAt(indx) != rhsBuffer.charAt(indx)) {
-        }else {
+        } else {
-        }     
-       
-        lhsBuffer.delete(0,lhsBuffer.length());
-        rhsBuffer.delete(0,rhsBuffer.length());
-        
+        }
+
+        lhsBuffer.delete(0, lhsBuffer.length());
+        rhsBuffer.delete(0, rhsBuffer.length());
+
-      //check if the order by clause is null or order by clause is same as proj.
-      //for now check if order by is null
-      if(shouldTransform && this.orderByAttrs == null) {
+      // check if the order by clause is null or order by clause is same as proj.
+      // for now check if order by is null
+      if (shouldTransform && this.orderByAttrs == null) {
-      }else {
+      } else {
-            LocalizedStrings.DefaultQuery_PROJ_COL_ABSENT_IN_GROUP_BY.toLocalizedString() +" or "
-            + LocalizedStrings.DefaultQuery_GROUP_BY_COL_ABSENT_IN_PROJ.toLocalizedString());
+            LocalizedStrings.DefaultQuery_PROJ_COL_ABSENT_IN_GROUP_BY.toLocalizedString() + " or "
+                + LocalizedStrings.DefaultQuery_GROUP_BY_COL_ABSENT_IN_PROJ.toLocalizedString());
-  
-  protected void modifyGroupByToOrderBy(boolean setDistinct, ExecutionContext context) throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-    if(setDistinct) {
+
+  protected void modifyGroupByToOrderBy(boolean setDistinct, ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+    if (setDistinct) {
-    for(CompiledValue cv : this.groupBy) {      
-      CompiledSortCriterion csc = new CompiledSortCriterion(false, cv);      
-      csc.mapExpressionToProjectionField(projAttrs, context) ;       
+    for (CompiledValue cv : this.groupBy) {
+      CompiledSortCriterion csc = new CompiledSortCriterion(false, cv);
+      csc.mapExpressionToProjectionField(projAttrs, context);
-  
+
-      throws AmbiguousNameException, TypeMismatchException,
-      NameResolutionException {
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-        if (!csc.mapExpressionToProjectionField(this.projAttrs, context)) {          
+        if (!csc.mapExpressionToProjectionField(this.projAttrs, context)) {
-  
-  
-  private void evalCanonicalizedExpressionForCSC(CompiledSortCriterion csc, ExecutionContext context,
-      StringBuffer buffer) throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+
+
+  private void evalCanonicalizedExpressionForCSC(CompiledSortCriterion csc,
+      ExecutionContext context, StringBuffer buffer)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-  /* Gets the appropriate empty results set when outside of actual query evalutaion.
+  /*
+   * Gets the appropriate empty results set when outside of actual query evalutaion.
+   * 
+   * 
-  throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-    context.newScope((Integer)context.cacheGet(scopeID));
-    context.pushExecCache((Integer)context.cacheGet(scopeID));
+    context.newScope((Integer) context.cacheGet(scopeID));
+    context.pushExecCache((Integer) context.cacheGet(scopeID));
-        context.bindIterator(rIter);      
+        context.bindIterator(rIter);
-      results = prepareEmptyResultSet(context,false);
-    }
-    finally {
+      results = prepareEmptyResultSet(context, false);
+    } finally {
-  
+
-  
-  public SelectResults evaluate(ExecutionContext context) throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
-    context.newScope((Integer)context.cacheGet(scopeID));
-    context.pushExecCache((Integer)context.cacheGet(scopeID));
+
+  public SelectResults evaluate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+    context.newScope((Integer) context.cacheGet(scopeID));
+    context.pushExecCache((Integer) context.cacheGet(scopeID));
-    if(this.hasUnmappedOrderByCols && context.getBucketList() != null) {
-      throw new QueryInvalidException(LocalizedStrings.DefaultQuery_ORDER_BY_ATTRIBS_NOT_PRESENT_IN_PROJ.toLocalizedString()); 
+    if (this.hasUnmappedOrderByCols && context.getBucketList() != null) {
+      throw new QueryInvalidException(
+          LocalizedStrings.DefaultQuery_ORDER_BY_ATTRIBS_NOT_PRESENT_IN_PROJ.toLocalizedString());
-      //set flag to keep objects serialized for "select *" queries
-      if((DefaultQuery)context.getQuery() != null){
-        ((DefaultQuery)context.getQuery()).keepResultsSerialized(this, context);
+      // set flag to keep objects serialized for "select *" queries
+      if ((DefaultQuery) context.getQuery() != null) {
+        ((DefaultQuery) context.getQuery()).keepResultsSerialized(this, context);
-        //Asif . Ideally the function below should always be called after binding has occured
-        //So that the interal ID gets set during binding to the scope. If not so then chances
+        // Asif . Ideally the function below should always be called after binding has occured
+        // So that the interal ID gets set during binding to the scope. If not so then chances
-        //Though in our case it may not be an issue as the compute depedency phase must have
-        //already set the index id
+        // Though in our case it may not be an issue as the compute depedency phase must have
+        // already set the index id
-      }
-      else {
+      } else {
-            result = prepareEmptyResultSet(context,false);
-            //ResultsSet.emptyResultsSet(resultSet, 0);
-            //return result;
-          }
-          else if (!(b instanceof Boolean)) {
-            throw new TypeMismatchException(LocalizedStrings.CompiledSelect_THE_WHERE_CLAUSE_WAS_TYPE_0_INSTEAD_OF_BOOLEAN.toLocalizedString(b.getClass().getName()));
-          }
-          else if (((Boolean) b).booleanValue()) {
+            result = prepareEmptyResultSet(context, false);
+            // ResultsSet.emptyResultsSet(resultSet, 0);
+            // return result;
+          } else if (!(b instanceof Boolean)) {
+            throw new TypeMismatchException(
+                LocalizedStrings.CompiledSelect_THE_WHERE_CLAUSE_WAS_TYPE_0_INSTEAD_OF_BOOLEAN
+                    .toLocalizedString(b.getClass().getName()));
+          } else if (((Boolean) b).booleanValue()) {
+          } else {
+            result = prepareEmptyResultSet(context, false);
+            // ResultsSet.emptyResultsSet(resultSet, 0);
+            // return result;
-          else {
-            result = prepareEmptyResultSet(context,false);
-            //ResultsSet.emptyResultsSet(resultSet, 0);
-            //return result;
-          }
-        }
-        else {
-          //Check the numer of independent iterators
+        } else {
+          // Check the numer of independent iterators
-          //If order by clause is defined, then the first column should be the preferred index 
-          if(this.orderByAttrs != null && numInd == 1) {
-            CompiledSortCriterion csc = (CompiledSortCriterion)orderByAttrs.get(0);
+          // If order by clause is defined, then the first column should be the preferred index
+          if (this.orderByAttrs != null && numInd == 1) {
+            CompiledSortCriterion csc = (CompiledSortCriterion) orderByAttrs.get(0);
-            context.cachePut(PREF_INDEX_COND, preferredIndexCondn.toString());        
+            context.cachePut(PREF_INDEX_COND, preferredIndexCondn.toString());
-          if(obj != null && (obj instanceof IndexInfo[] || obj.equals(CLAUSE_EVALUATED))) {
-            // if indexinfo is cached means the read lock 
-            // is not being taken this time, so releasing 
+          if (obj != null && (obj instanceof IndexInfo[] || obj.equals(CLAUSE_EVALUATED))) {
+            // if indexinfo is cached means the read lock
+            // is not being taken this time, so releasing
-              ((QueryExecutionContext)context).setIndexUsed(true);
+              ((QueryExecutionContext) context).setIndexUsed(true);
-              if (limitValue >= 0
-                  && numInd == 1
-                  && ((Filter) this.whereClause)
-                      .isLimitApplicableAtIndexLevel(context)) {
+              if (limitValue >= 0 && numInd == 1
+                  && ((Filter) this.whereClause).isLimitApplicableAtIndexLevel(context)) {
-              if (temp != null
-                  && numInd == 1
-                  && ((Filter) this.whereClause)
-                      .isOrderByApplicableAtIndexLevel(context, temp.toString())) {
+              if (temp != null && numInd == 1 && ((Filter) this.whereClause)
+                  .isOrderByApplicableAtIndexLevel(context, temp.toString())) {
-                  //If there is a limit present and we are executing on a partitioned region
-                  //we should use a sorted set
+                  // If there is a limit present and we are executing on a partitioned region
+                  // we should use a sorted set
-                    //Currently check bucket list to determine if it's a pr query
+                    // Currently check bucket list to determine if it's a pr query
-                    } 
+                    }
-                  && ((Filter) this.whereClause)
-                      .isProjectionEvaluationAPossibility(context)
-                  && (this.orderByAttrs == null || (canApplyOrderByAtIndex && !needsTopLevelOrdering))
+                  && ((Filter) this.whereClause).isProjectionEvaluationAPossibility(context)
+                  && (this.orderByAttrs == null
+                      || (canApplyOrderByAtIndex && !needsTopLevelOrdering))
-                ObjectType resultType = this.cachedElementTypeForOrderBy != null? this.cachedElementTypeForOrderBy :this.prepareResultType(context);
+                ObjectType resultType = this.cachedElementTypeForOrderBy != null
+                    ? this.cachedElementTypeForOrderBy : this.prepareResultType(context);
-              
-              
-              result = ((Filter) this.whereClause)
-                  .filterEvaluate(context, null);
+
+
+              result = ((Filter) this.whereClause).filterEvaluate(context, null);
-                result = applyProjectionOnCollection( result, context,
-                    !needsTopLevelOrdering);
+                result = applyProjectionOnCollection(result, context, !needsTopLevelOrdering);
-            if(unlock) {
+            if (unlock) {
-      //TODO:Asif: It does not appear that results would be null ever. 
-      //if (result == null) { return QueryService.UNDEFINED; }
+      // TODO:Asif: It does not appear that results would be null ever.
+      // if (result == null) { return QueryService.UNDEFINED; }
-        //if (this.distinct && colnType.allowsDuplicates()) {
+        // if (this.distinct && colnType.allowsDuplicates()) {
-          //Set s = sr.asSet();
+          // Set s = sr.asSet();
-          // don't just convert to a ResultsSet (or StructSet), since
-          // the bags can convert themselves to a Set more efficiently
+            // don't just convert to a ResultsSet (or StructSet), since
+            // the bags can convert themselves to a Set more efficiently
-          }else {
+          } else {
-          
+
-            ((ResultsCollectionWrapper)result).setModifiable(false);
+            ((ResultsCollectionWrapper) result).setModifiable(false);
-        }
-        else {
+        } else {
-            ((Bag)sr).applyLimit(limitValue);
+            ((Bag) sr).applyLimit(limitValue);
-         * We still have to get size of SelectResults in some cases like,
-         * if index was used OR query is a distinct query.
+         * We still have to get size of SelectResults in some cases like, if index was used OR query
+         * is a distinct query.
-         * If SelectResult size is zero then we need to put Integer for 0
-         * count.
+         * If SelectResult size is zero then we need to put Integer for 0 count.
-          
+
-            //Take size and empty the results
+            // Take size and empty the results
-            
-            ResultsBag countResult = new ResultsBag(new ObjectTypeImpl(Integer.class), context.getCachePerfStats());
+
+            ResultsBag countResult =
+                new ResultsBag(new ObjectTypeImpl(Integer.class), context.getCachePerfStats());
-            ((ResultsBag)res).addAndGetOccurence(countStartQueryResult);
+            ((ResultsBag) res).addAndGetOccurence(countStartQueryResult);
-    }
-    finally {
+    } finally {
-  
+
-   * The index is locked during query to prevent it from being
-   * removed by another thread. So we have to release the lock only after
-   * whole query is finished as one query can use an index multiple times.
+   * The index is locked during query to prevent it from being removed by another thread. So we have
+   * to release the lock only after whole query is finished as one query can use an index multiple
+   * times.
-      } else {      
-         ((AbstractIndex) index).releaseIndexReadLockForRemove();
+      } else {
+        ((AbstractIndex) index).releaseIndexReadLockForRemove();
-   * Retruns the size of region iterator for count(*) on a region without
-   * whereclause.
-   * @param collExpr 
-   * @throws RegionNotFoundException 
+   * Retruns the size of region iterator for count(*) on a region without whereclause.
+   * 
+   * @param collExpr
+   * @throws RegionNotFoundException
-  private int getRegionIteratorSize(ExecutionContext context,
-      CompiledValue collExpr) throws RegionNotFoundException {
+  private int getRegionIteratorSize(ExecutionContext context, CompiledValue collExpr)
+      throws RegionNotFoundException {
-          LocalizedStrings.CompiledRegion_REGION_NOT_FOUND_0
-              .toLocalizedString(regionPath));
+          LocalizedStrings.CompiledRegion_REGION_NOT_FOUND_0.toLocalizedString(regionPath));
-  public int getLimitValue(Object[] bindArguments) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    //if evaluation of the limit fails, we default to no limit
+  public int getLimitValue(Object[] bindArguments) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+    // if evaluation of the limit fails, we default to no limit
-  
+
-    
-    SelectResults results = prepareEmptyResultSet(context,false);
-    
-    //TODO:Asif: SELF : Work on limit implementation on bulk get    
+
+    SelectResults results = prepareEmptyResultSet(context, false);
+
+    // TODO:Asif: SELF : Work on limit implementation on bulk get
-        RuntimeIterator rIter = (RuntimeIterator)context.getCurrentIterators().get(0); 
-        for (Iterator itr = tmpResults.iterator(); itr.hasNext(); ) {
+        RuntimeIterator rIter = (RuntimeIterator) context.getCurrentIterators().get(0);
+        for (Iterator itr = tmpResults.iterator(); itr.hasNext();) {
-          applyProjectionAndAddToResultSet(context, results, this.orderByAttrs ==null);
+          applyProjectionAndAddToResultSet(context, results, this.orderByAttrs == null);
-      doNestedIterations(0, results, context, evaluateWhereClause,numElementsInResult);
-    }catch(CompiledSelect.NullIteratorException cnie) {
+      doNestedIterations(0, results, context, evaluateWhereClause, numElementsInResult);
+    } catch (CompiledSelect.NullIteratorException cnie) {
-  
+
-   * Check for the bulk-get pattern and if it applies do an optimized execution.
-   * The pattern is: SELECT ?? FROM <Region>.entrySet e WHERE e.key IN <Collection>.
+   * Check for the bulk-get pattern and if it applies do an optimized execution. The pattern is:
+   * SELECT ?? FROM <Region>.entrySet e WHERE e.key IN <Collection>.
-   * @return a List of entries if optimization was executed,
-   * or null if it wasn't because the optimization pattern didn't match
+   * @return a List of entries if optimization was executed, or null if it wasn't because the
+   *         optimization pattern didn't match
-  private List optimizeBulkGet(ExecutionContext context)
-  throws TypeMismatchException, FunctionDomainException, NameResolutionException,
-  QueryInvocationTargetException {
+  private List optimizeBulkGet(ExecutionContext context) throws TypeMismatchException,
+      FunctionDomainException, NameResolutionException, QueryInvocationTargetException {
-    
+
-    
-    RuntimeIterator rIter = (RuntimeIterator)iterList.get(0);
+
+    RuntimeIterator rIter = (RuntimeIterator) iterList.get(0);
-    
+
-      CompiledPath cPath = (CompiledPath)colnExpr;
+      CompiledPath cPath = (CompiledPath) colnExpr;
-        rgn = (CompiledRegion)rcvr;
+        rgn = (CompiledRegion) rcvr;
-      CompiledOperation cOp = (CompiledOperation)colnExpr;
+      CompiledOperation cOp = (CompiledOperation) colnExpr;
-        rgn = (CompiledRegion)rcvr;
+        rgn = (CompiledRegion) rcvr;
-    
+
-    CompiledIn cIn = (CompiledIn)this.whereClause;
+    CompiledIn cIn = (CompiledIn) this.whereClause;
-      boolean evaluateWhereClause, int numElementsInResult) throws TypeMismatchException, AmbiguousNameException, FunctionDomainException,
-      NameResolutionException, QueryInvocationTargetException, CompiledSelect.NullIteratorException {
+      boolean evaluateWhereClause, int numElementsInResult) throws TypeMismatchException,
+      AmbiguousNameException, FunctionDomainException, NameResolutionException,
+      QueryInvocationTargetException, CompiledSelect.NullIteratorException {
-        }
-        else if (result instanceof Boolean) {
-          addToResults = ((Boolean)result).booleanValue();
-        }
-        else if (result == QueryService.UNDEFINED) {
+        } else if (result instanceof Boolean) {
+          addToResults = ((Boolean) result).booleanValue();
+        } else if (result == QueryService.UNDEFINED) {
-            } 
+            }
-        }
-        else {
-          throw new TypeMismatchException(LocalizedStrings.CompiledSelect_THE_WHERE_CLAUSE_WAS_TYPE_0_INSTEAD_OF_BOOLEAN.toLocalizedString(result.getClass().getName()));
+        } else {
+          throw new TypeMismatchException(
+              LocalizedStrings.CompiledSelect_THE_WHERE_CLAUSE_WAS_TYPE_0_INSTEAD_OF_BOOLEAN
+                  .toLocalizedString(result.getClass().getName()));
-        int occurence = applyProjectionAndAddToResultSet(context, results, this.orderByAttrs == null);
+        int occurence =
+            applyProjectionAndAddToResultSet(context, results, this.orderByAttrs == null);
-      }     
-    }
-    else {
+      }
+    } else {
-        return 0; //continue iteration if a collection evaluates to UNDEFINED
+        return 0; // continue iteration if a collection evaluates to UNDEFINED
-      
-      // Check if its a non-distinct count(*) query without where clause, in that case, 
+
+      // Check if its a non-distinct count(*) query without where clause, in that case,
-      if (this.whereClause == null && iterators.size() == 1 && isCount() && !isDistinct() && 
-          sr instanceof QRegion) {
-        QRegion qr = (QRegion)sr;
+      if (this.whereClause == null && iterators.size() == 1 && isCount() && !isDistinct()
+          && sr instanceof QRegion) {
+        QRegion qr = (QRegion) sr;
-          && ((DefaultQuery) context.getQuery()).isKeepSerialized()
-          && sr instanceof QRegion) {
+          && ((DefaultQuery) context.getQuery()).isKeepSerialized() && sr instanceof QRegion) {
-        numElementsInResult = doNestedIterations(level + 1, results, context,
-            evaluateWhereClause, numElementsInResult);
+        numElementsInResult = doNestedIterations(level + 1, results, context, evaluateWhereClause,
+            numElementsInResult);
-        }        
-      }     
+        }
+      }
-      ExecutionContext context, boolean ignoreOrderBy) throws TypeMismatchException,
-      AmbiguousNameException, FunctionDomainException, NameResolutionException,
-      QueryInvocationTargetException {
+      ExecutionContext context, boolean ignoreOrderBy)
+      throws TypeMismatchException, AmbiguousNameException, FunctionDomainException,
+      NameResolutionException, QueryInvocationTargetException {
-    if (projAttrs == null && (this.orderByAttrs == null || ignoreOrderBy )) {
+    if (projAttrs == null && (this.orderByAttrs == null || ignoreOrderBy)) {
-        ((SelectResults)resultSet).setElementType(type);
+        ((SelectResults) resultSet).setElementType(type);
-    }
-    else {      
+    } else {
-      SelectResults pResultSet = prepareEmptyResultSet(context,ignoreOrderBy);
-      boolean isStructType = resultSet.getCollectionType().getElementType() != null 
-          && resultSet.getCollectionType().getElementType().isStructType();  
+      SelectResults pResultSet = prepareEmptyResultSet(context, ignoreOrderBy);
+      boolean isStructType = resultSet.getCollectionType().getElementType() != null
+          && resultSet.getCollectionType().getElementType().isStructType();
-        while (( (this.orderByAttrs != null && !ignoreOrderBy)|| limitValue < 0 || (numElementsAdded < limitValue))
-            && resultsIter.hasNext()) {
+        while (((this.orderByAttrs != null && !ignoreOrderBy) || limitValue < 0
+            || (numElementsAdded < limitValue)) && resultsIter.hasNext()) {
-          Object values[] = ((Struct)resultsIter.next()).getFieldValues();
+          Object values[] = ((Struct) resultsIter.next()).getFieldValues();
-            ((RuntimeIterator)iterators.get(i)).setCurrent(values[i]);
+            ((RuntimeIterator) iterators.get(i)).setCurrent(values[i]);
-          int occurence = applyProjectionAndAddToResultSet(context, pResultSet,ignoreOrderBy);
+          int occurence = applyProjectionAndAddToResultSet(context, pResultSet, ignoreOrderBy);
-      }
-      else if (iterators.size() == 1) {
-        RuntimeIterator rIter = (RuntimeIterator)iterators.get(0);
-        Iterator resultsIter = ((SelectResults)resultSet).iterator();
+      } else if (iterators.size() == 1) {
+        RuntimeIterator rIter = (RuntimeIterator) iterators.get(0);
+        Iterator resultsIter = ((SelectResults) resultSet).iterator();
-        while (( (this.orderByAttrs != null && !ignoreOrderBy) || limitValue < 0 || (numElementsAdded < limitValue))
-            && resultsIter.hasNext()) {
+        while (((this.orderByAttrs != null && !ignoreOrderBy) || limitValue < 0
+            || (numElementsAdded < limitValue)) && resultsIter.hasNext()) {
-          int occurence = applyProjectionAndAddToResultSet(context, pResultSet,ignoreOrderBy);
+          int occurence = applyProjectionAndAddToResultSet(context, pResultSet, ignoreOrderBy);
-      }
-      else {
-        throw new RuntimeException(LocalizedStrings.CompiledSelect_RESULT_SET_DOES_NOT_MATCH_WITH_ITERATOR_DEFINITIONS_IN_FROM_CLAUSE.toLocalizedString());
+      } else {
+        throw new RuntimeException(
+            LocalizedStrings.CompiledSelect_RESULT_SET_DOES_NOT_MATCH_WITH_ITERATOR_DEFINITIONS_IN_FROM_CLAUSE
+                .toLocalizedString());
-      throws TypeMismatchException, AmbiguousNameException
- {
+      throws TypeMismatchException, AmbiguousNameException {
-    ObjectType elementType = this.cachedElementTypeForOrderBy != null ? this.cachedElementTypeForOrderBy
-        : prepareResultType(context);
+    ObjectType elementType = this.cachedElementTypeForOrderBy != null
+        ? this.cachedElementTypeForOrderBy : prepareResultType(context);
-        boolean nullValuesAtStart = !((CompiledSortCriterion)orderByAttrs.get(0)).getCriterion();
+        boolean nullValuesAtStart = !((CompiledSortCriterion) orderByAttrs.get(0)).getCriterion();
-            results = this.distinct ? new LinkedStructSet(
-                (StructTypeImpl) elementType) : new SortedResultsBag(
-                elementType, nullValuesAtStart);
+            results = this.distinct ? new LinkedStructSet((StructTypeImpl) elementType)
+                : new SortedResultsBag(elementType, nullValuesAtStart);
-            OrderByComparator comparator = this.hasUnmappedOrderByCols ? new OrderByComparatorUnmapped(
-                this.orderByAttrs, (StructTypeImpl) elementType, context)
-                : new OrderByComparator(this.orderByAttrs,
-                    (StructTypeImpl) elementType, context);
-            results = this.distinct ? new SortedStructSet(comparator,
-                (StructTypeImpl) elementType) : new SortedStructBag(comparator,
-                (StructTypeImpl) elementType, nullValuesAtStart);
+            OrderByComparator comparator = this.hasUnmappedOrderByCols
+                ? new OrderByComparatorUnmapped(this.orderByAttrs, (StructTypeImpl) elementType,
+                    context)
+                : new OrderByComparator(this.orderByAttrs, (StructTypeImpl) elementType, context);
+            results = this.distinct ? new SortedStructSet(comparator, (StructTypeImpl) elementType)
+                : new SortedStructBag(comparator, (StructTypeImpl) elementType, nullValuesAtStart);
-            results = this.distinct ? new LinkedResultSet()
-                : new SortedResultsBag(nullValuesAtStart);
+            results =
+                this.distinct ? new LinkedResultSet() : new SortedResultsBag(nullValuesAtStart);
-            OrderByComparator comparator = this.hasUnmappedOrderByCols ? new OrderByComparatorUnmapped(
-                this.orderByAttrs, elementType, context)
+            OrderByComparator comparator = this.hasUnmappedOrderByCols
+                ? new OrderByComparatorUnmapped(this.orderByAttrs, elementType, context)
-            results = new StructBag((StructType) elementType,
-                context.getCachePerfStats());
+            results = new StructBag((StructType) elementType, context.getCachePerfStats());
-      results = new ResultsBag(new ObjectTypeImpl(Integer.class), 1 /*
-                                                                     * initial
-                                                                     * capacity
-                                                                     * for count
-                                                                     * value
-                                                                     */,
-          context.getCachePerfStats());
+      results =
+          new ResultsBag(new ObjectTypeImpl(Integer.class), 1 /*
+                                                               * initial capacity for count value
+                                                               */, context.getCachePerfStats());
-   return results;   
+    return results;
-  
+
-      throws TypeMismatchException, AmbiguousNameException
-  {
+      throws TypeMismatchException, AmbiguousNameException {
-        RuntimeIterator iter = (RuntimeIterator)currentIterators.get(0);
+        RuntimeIterator iter = (RuntimeIterator) currentIterators.get(0);
+      } else {
+        elementType = createStructTypeForNullProjection(currentIterators, context);
-      else {
-        elementType = createStructTypeForNullProjection(currentIterators,
-            context);
-      }
-    }
-    else {
+    } else {
-        Object[] projDef = (Object[])projAttrs.get(i);
-        fldName = (String)projDef[0];
+        Object[] projDef = (Object[]) projAttrs.get(i);
+        fldName = (String) projDef[0];
-        fieldNames[i] = (fldName == null && createStructSet) ? generateProjectionName(
-            (CompiledValue)projDef[1], context)
-            : fldName;
-        fieldTypes[i] = getFieldTypeOfProjAttrib(context,
-            (CompiledValue)projDef[1]);
+        fieldNames[i] = (fldName == null && createStructSet)
+            ? generateProjectionName((CompiledValue) projDef[1], context) : fldName;
+        fieldTypes[i] = getFieldTypeOfProjAttrib(context, (CompiledValue) projDef[1]);
-      }
-      else {
+      } else {
-  private SelectResults prepareEmptySelectResults(ObjectType elementType,
-                                                  boolean isSorted,
-                                                  ExecutionContext context) {
-    if (elementType.isStructType()) {
-      if (isSorted) { // sorted struct
-        return prepareEmptySortedStructSet((StructTypeImpl)elementType);
-  }
-      else { // unsorted struct
-        return new StructBag((StructType)elementType,  context.getCachePerfStats());
-  }
-    }
-    else { // non-struct
-      if (isSorted) { // sorted non-struct
-          return prepareEmptySortedResultSet(elementType);
-      }
-      else { // unsorted non-struct
-        return new ResultsBag(elementType, context.getCachePerfStats());
-      }
-    }
-  }
-  */
- 
- 
-    
- /**
-   * Asif: This function should be used to create a StructType for those
-   * queries which have * as projection attribute (implying null projection
-   * attribute) & multiple from clauses
-   *  
+   * private SelectResults prepareEmptySelectResults(ObjectType elementType, boolean isSorted,
+   * ExecutionContext context) { if (elementType.isStructType()) { if (isSorted) { // sorted struct
+   * return prepareEmptySortedStructSet((StructTypeImpl)elementType); } else { // unsorted struct
+   * return new StructBag((StructType)elementType, context.getCachePerfStats()); } } else { //
+   * non-struct if (isSorted) { // sorted non-struct return
+   * prepareEmptySortedResultSet(elementType); } else { // unsorted non-struct return new
+   * ResultsBag(elementType, context.getCachePerfStats()); } } }
-  private StructTypeImpl createStructTypeForNullProjection(List currentIterators, ExecutionContext context) {
+
+
+
+  /**
+   * Asif: This function should be used to create a StructType for those queries which have * as
+   * projection attribute (implying null projection attribute) & multiple from clauses
+   * 
+   */
+  private StructTypeImpl createStructTypeForNullProjection(List currentIterators,
+      ExecutionContext context) {
-      //fieldNames[i] = iter.getName();
+      // fieldNames[i] = iter.getName();
-  private ObjectType getFieldTypeOfProjAttrib(ExecutionContext context, CompiledValue cv) throws TypeMismatchException,
-      AmbiguousNameException {
+  private ObjectType getFieldTypeOfProjAttrib(ExecutionContext context, CompiledValue cv)
+      throws TypeMismatchException, AmbiguousNameException {
-    }
-    catch (NameNotFoundException e) {
+    } catch (NameNotFoundException e) {
- 
+
-  // then 1 will indicate that data was added to the results & that was the 
+  // then 1 will indicate that data was added to the results & that was the
-  // If the SelectResults is an instance  ResultsBag or StructsBag , the number will
+  // If the SelectResults is an instance ResultsBag or StructsBag , the number will
-  
-  
-  
-  
-  private int applyProjectionAndAddToResultSet(ExecutionContext context,
-      SelectResults resultSet, boolean ignoreOrderBy) throws FunctionDomainException, TypeMismatchException,
+
+
+
+  private int applyProjectionAndAddToResultSet(ExecutionContext context, SelectResults resultSet,
+      boolean ignoreOrderBy) throws FunctionDomainException, TypeMismatchException,
-    //TODO : Asif : Optimize this condition in some clean way
-    boolean isLinkedStructure = resultSet instanceof Ordered && ((Ordered)resultSet).dataPreordered();
-   
+    // TODO : Asif : Optimize this condition in some clean way
+    boolean isLinkedStructure =
+        resultSet instanceof Ordered && ((Ordered) resultSet).dataPreordered();
+
-        if (this.distinct
-            && !((DefaultQuery) context.getQuery()).isRemoteQuery()
-            && !context.getCache().getPdxReadSerialized()
-            && (values[i] instanceof PdxInstance)) {
+        if (this.distinct && !((DefaultQuery) context.getQuery()).isRemoteQuery()
+            && !context.getCache().getPdxReadSerialized() && (values[i] instanceof PdxInstance)) {
-                comparator.addEvaluatedSortCriteria(
-                    structImpl.getFieldValues(), context);
-                occurence =  resultSet.add(structImpl) ? 1
-                    : 0;
+                comparator.addEvaluatedSortCriteria(structImpl.getFieldValues(), context);
+                occurence = resultSet.add(structImpl) ? 1 : 0;
-                occurence = ((StructFields) resultSet).addFieldValues(values) ? 1
-                    : 0;
+                occurence = ((StructFields) resultSet).addFieldValues(values) ? 1 : 0;
-              occurence =  resultSet.add(values[0]) ? 1 : 0;
+              occurence = resultSet.add(values[0]) ? 1 : 0;
-                comparator.addEvaluatedSortCriteria(
-                    structImpl.getFieldValues(), context);
+                comparator.addEvaluatedSortCriteria(structImpl.getFieldValues(), context);
-                occurence = ((Bag) resultSet).addAndGetOccurence(values) ;
-                    
+                occurence = ((Bag) resultSet).addAndGetOccurence(values);
+
-              occurence = ((Bag) resultSet)
-                  .addAndGetOccurence(values[0]);
+              occurence = ((Bag) resultSet).addAndGetOccurence(values[0]);
-          if(isLinkedStructure) {
-            if(isStruct) {
+          if (isLinkedStructure) {
+            if (isStruct) {
-                structImpl = new StructImpl(
-                    (StructTypeImpl)elementType, values);
+                structImpl = new StructImpl((StructTypeImpl) elementType, values);
-              if(this.distinct) {
+              if (this.distinct) {
-              }else {
-                occurence = ((Bag)resultSet).addAndGetOccurence(structImpl);
-              } 
-            }else {
-              if(this.distinct) {
-                occurence = resultSet.add(values[0]) ? 1 : 0;  
-              }else {
-                occurence = ((Bag)resultSet).addAndGetOccurence(values[0]);
+              } else {
+                occurence = ((Bag) resultSet).addAndGetOccurence(structImpl);
-              
+            } else {
+              if (this.distinct) {
+                occurence = resultSet.add(values[0]) ? 1 : 0;
+              } else {
+                occurence = ((Bag) resultSet).addAndGetOccurence(values[0]);
+              }
+
-          }
-          else {
+          } else {
-                occurence = ((StructFields) resultSet).addFieldValues(values) ? 1
-                    : 0;
+                occurence = ((StructFields) resultSet).addFieldValues(values) ? 1 : 0;
-                occurence =  resultSet.add(values[0]) ? 1 : 0;
+                occurence = resultSet.add(values[0]) ? 1 : 0;
-                occurence = ((Bag) resultSet)
-                    .addAndGetOccurence(values);
+                occurence = ((Bag) resultSet).addAndGetOccurence(values);
-                  occurence = ((Bag) resultSet)
-                      .addAndGetOccurence(values[0]);
+                  occurence = ((Bag) resultSet).addAndGetOccurence(values[0]);
-            occurence = ((StructFields) resultSet).addFieldValues(values) ? 1
-                : 0;
+            occurence = ((StructFields) resultSet).addFieldValues(values) ? 1 : 0;
-            occurence =  resultSet.add(values[0]) ? 1 : 0;
+            occurence = resultSet.add(values[0]) ? 1 : 0;
-            occurence = ((Bag) resultSet)
-                .addAndGetOccurence(values[0]);
+            occurence = ((Bag) resultSet).addAndGetOccurence(values[0]);
-        if(isLinkedStructure) {
-          if(isStruct) {
-            StructImpl structImpl = new StructImpl((StructTypeImpl)elementType, values);
-            if(this.distinct) {
+        if (isLinkedStructure) {
+          if (isStruct) {
+            StructImpl structImpl = new StructImpl((StructTypeImpl) elementType, values);
+            if (this.distinct) {
-            }else {
-              occurence = ((Bag)resultSet).addAndGetOccurence(structImpl);
+            } else {
+              occurence = ((Bag) resultSet).addAndGetOccurence(structImpl);
-   
-          }else {
-            if(this.distinct) {
-              occurence =  resultSet.add(values[0]) ? 1 : 0;
-            }else {
-              occurence = ((Bag)resultSet).addAndGetOccurence(values[0]);
+
+          } else {
+            if (this.distinct) {
+              occurence = resultSet.add(values[0]) ? 1 : 0;
+            } else {
+              occurence = ((Bag) resultSet).addAndGetOccurence(values[0]);
-        }else {
+        } else {
-              occurence = ((StructFields) resultSet).addFieldValues(values) ? 1
-                  : 0;
+              occurence = ((StructFields) resultSet).addFieldValues(values) ? 1 : 0;
-              occurence =  resultSet.add(values[0]) ? 1 : 0;
+              occurence = resultSet.add(values[0]) ? 1 : 0;
-              occurence = ((Bag) resultSet)
-                  .addAndGetOccurence(values);
+              occurence = ((Bag) resultSet).addAndGetOccurence(values);
-              occurence = ((Bag) resultSet)
-                  .addAndGetOccurence(values[0]);
+              occurence = ((Bag) resultSet).addAndGetOccurence(values[0]);
-      }
-      else if (name.charAt(0) == '/') {
+      } else if (name.charAt(0) == '/') {
-      }
-      else {
+      } else {
-    }
-    else {
+    } else {
-      }
-      else if (type == Identifier) {
+      } else if (type == Identifier) {
-      }
-      else if (type == LITERAL) {
+      } else if (type == LITERAL) {
-      }
-      else if (type == METHOD_INV) {
+      } else if (type == METHOD_INV) {
-      }
-      else {
+      } else {
- 
+
+   * 
-  public boolean evaluateCq(ExecutionContext context) throws FunctionDomainException, TypeMismatchException,
-  NameResolutionException, QueryInvocationTargetException {
+  public boolean evaluateCq(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    context.newScope((Integer)context.cacheGet(scopeID));
-    context.pushExecCache((Integer)context.cacheGet(scopeID));
+    context.newScope((Integer) context.cacheGet(scopeID));
+    context.pushExecCache((Integer) context.cacheGet(scopeID));
-        coll = (Collection)evalResult;
+        coll = (Collection) evalResult;
-      if (this.whereClause.isDependentOnCurrentScope(context)) { 
+      if (this.whereClause.isDependentOnCurrentScope(context)) {
-        return(((Boolean) b).booleanValue());
+        return (((Boolean) b).booleanValue());
-    }
-    finally {
+    } finally {
-  
+
-   * A special evaluation of limit for when limit needs to be evaluated before
-   * an execution context is created.
+   * A special evaluation of limit for when limit needs to be evaluated before an execution context
+   * is created.
+   * 
+   * 
+   * 
+   * 
+   * 
+   * 
-  private Integer evaluateLimitValue(Object[] bindArguments) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+  private Integer evaluateLimitValue(Object[] bindArguments) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-        limitValue = (Integer)((CompiledBindArgument)this.limit).evaluate(bindArguments);
-      }
-      else {
-        //Assume limit is a compiled literal which does not need a context
-        limitValue =  (Integer)this.limit.evaluate(null);
+        limitValue = (Integer) ((CompiledBindArgument) this.limit).evaluate(bindArguments);
+      } else {
+        // Assume limit is a compiled literal which does not need a context
+        limitValue = (Integer) this.limit.evaluate(null);
-  
-  protected static Integer evaluateLimitValue(ExecutionContext context, CompiledValue limit) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+
+  protected static Integer evaluateLimitValue(ExecutionContext context, CompiledValue limit)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-        limitValue =  (Integer)limit.evaluate(context);
-        if (limitValue == null) {
-          //This is incase an object array was passed in but no param was set for the limit 
-          limitValue = -1;
-        }
+      limitValue = (Integer) limit.evaluate(context);
+      if (limitValue == null) {
+        // This is incase an object array was passed in but no param was set for the limit
+        limitValue = -1;
+      }
-  
+
-    
-  }  
+
+  }
-
-

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66
Integrated client auth support for RegisterInterest, new dunit and refactoring of old dunit.

+import com.gemstone.gemfire.internal.cache.tier.InterestType;
+import com.gemstone.gemfire.internal.security.GeodeSecurityUtil;
-    else { // input key not null
-      LocalRegion region = (LocalRegion)crHelper.getRegion(regionName);
-      if (region == null) {
-        logger.info(LocalizedMessage.create(LocalizedStrings.RegisterInterest_0_REGION_NAMED_1_WAS_NOT_FOUND_DURING_REGISTER_INTEREST_REQUEST, new Object[] {servConn.getName(), regionName}));
-        // writeChunkedErrorResponse(msg,
-        // MessageType.REGISTER_INTEREST_DATA_ERROR, message);
-        // responded = true;
-      }
-      // Register interest
-      try {
-        AuthorizeRequest authzRequest = servConn.getAuthzRequest();
-        if (authzRequest != null) {
-          // TODO SW: This is a workaround for DynamicRegionFactory
-          // registerInterest calls. Remove this when the semantics of
-          // DynamicRegionFactory are cleaned up.
-          if (!DynamicRegionFactory.regionIsDynamicRegionList(regionName)) {
-            RegisterInterestOperationContext registerContext = authzRequest
-                .registerInterestAuthorize(regionName, key, interestType,
-                    policy);
-            key = registerContext.getKey();
-          }
+
+    if(interestType == InterestType.REGULAR_EXPRESSION)
+      GeodeSecurityUtil.authorizeRegionRead(regionName);
+    else
+      GeodeSecurityUtil.authorizeRegionRead(regionName, key.toString());
+
+    // input key not null
+    LocalRegion region = (LocalRegion)crHelper.getRegion(regionName);
+    if (region == null) {
+      logger.info(LocalizedMessage.create(LocalizedStrings.RegisterInterest_0_REGION_NAMED_1_WAS_NOT_FOUND_DURING_REGISTER_INTEREST_REQUEST, new Object[] {servConn.getName(), regionName}));
+      // writeChunkedErrorResponse(msg,
+      // MessageType.REGISTER_INTEREST_DATA_ERROR, message);
+      // responded = true;
+    }
+    // Register interest
+    try {
+      AuthorizeRequest authzRequest = servConn.getAuthzRequest();
+      if (authzRequest != null) {
+        // TODO SW: This is a workaround for DynamicRegionFactory
+        // registerInterest calls. Remove this when the semantics of
+        // DynamicRegionFactory are cleaned up.
+        if (!DynamicRegionFactory.regionIsDynamicRegionList(regionName)) {
+          RegisterInterestOperationContext registerContext = authzRequest
+              .registerInterestAuthorize(regionName, key, interestType,
+                  policy);
+          key = registerContext.getKey();
-        servConn.getAcceptor().getCacheClientNotifier()
-            .registerClientInterest(regionName, key, servConn.getProxyID(),
-                interestType, isDurable, sendUpdatesAsInvalidates, true,
-                regionDataPolicyPartBytes[0], true);
+      }
+      servConn.getAcceptor().getCacheClientNotifier()
+          .registerClientInterest(regionName, key, servConn.getProxyID(),
+              interestType, isDurable, sendUpdatesAsInvalidates, true,
+              regionDataPolicyPartBytes[0], true);
+    }
+    catch (Exception e) {
+      // If an interrupted exception is thrown , rethrow it
+      checkForInterrupt(servConn, e);
+      // Otherwise, write an exception message and continue
+      writeChunkedException(msg, e, false, servConn);
+      servConn.setAsTrue(RESPONDED);
+      return;
+    }
+
+    // System.out.println("Received register interest for " + regionName);
+
+    // Update the statistics and write the reply
+    // bserverStats.incLong(processDestroyTimeId,
+    // DistributionStats.getStatTime() - start);
+    // start = DistributionStats.getStatTime();
+
+    CacheClientProxy ccp = servConn.getAcceptor().getCacheClientNotifier()
+        .getClientProxy(servConn.getProxyID());
+    if (ccp == null) {
+      // fix for 37593
+      IOException ioex = new IOException(
+          LocalizedStrings.RegisterInterest_CACHECLIENTPROXY_FOR_THIS_CLIENT_IS_NO_LONGER_ON_THE_SERVER_SO_REGISTERINTEREST_OPERATION_IS_UNSUCCESSFUL
+              .toLocalizedString());
+      writeChunkedException(msg, ioex, false, servConn);
+      servConn.setAsTrue(RESPONDED);
+      return;
+    }
+    boolean isPrimary = ccp.isPrimary();
+    ChunkedMessage chunkedResponseMsg = servConn.getRegisterInterestResponseMessage();
+    if (!isPrimary) {
+      chunkedResponseMsg.setMessageType(MessageType.RESPONSE_FROM_SECONDARY);
+      chunkedResponseMsg.setTransactionId(msg.getTransactionId());
+      chunkedResponseMsg.sendHeader();
+      chunkedResponseMsg.setLastChunk(true);
+
+      if (logger.isDebugEnabled()) {
+        logger.debug("{}: Sending register interest response chunk from secondary for region: {} for key: {} chunk=<{}>", servConn.getName(), regionName, key, chunkedResponseMsg);
+      }
+      chunkedResponseMsg.sendChunk(servConn);
+    } // !isPrimary
+    else { // isPrimary
+
+      // Send header which describes how many chunks will follow
+      chunkedResponseMsg.setMessageType(MessageType.RESPONSE_FROM_PRIMARY);
+      chunkedResponseMsg.setTransactionId(msg.getTransactionId());
+      chunkedResponseMsg.sendHeader();
+
+      // Send chunk response
+      try {
+        fillAndSendRegisterInterestResponseChunks(region, key, interestType,
+            serializeValues, policy, servConn);
+        servConn.setAsTrue(RESPONDED);
-        // If an interrupted exception is thrown , rethrow it
-        checkForInterrupt(servConn, e);
-        // Otherwise, write an exception message and continue
-        writeChunkedException(msg, e, false, servConn);
+        writeChunkedException(msg, e, false, servConn, chunkedResponseMsg);
-      // System.out.println("Received register interest for " + regionName);
-
-      // Update the statistics and write the reply
-      // bserverStats.incLong(processDestroyTimeId,
+      if (logger.isDebugEnabled()) {
+        // logger.debug(getName() + ": Sent chunk (1 of 1) of register interest
+        // response (" + chunkedResponseMsg.getBufferLength() + " bytes) for
+        // region " + regionName + " key " + key);
+        logger.debug("{}: Sent register interest response for region {} key {}", servConn.getName(), regionName, key);
+      }
+      // bserverStats.incLong(writeDestroyResponseTimeId,
-      // start = DistributionStats.getStatTime();
+      // bserverStats.incInt(destroyResponsesId, 1);
+    } // isPrimary
-      CacheClientProxy ccp = servConn.getAcceptor().getCacheClientNotifier()
-          .getClientProxy(servConn.getProxyID());
-      if (ccp == null) {
-        // fix for 37593
-        IOException ioex = new IOException(
-            LocalizedStrings.RegisterInterest_CACHECLIENTPROXY_FOR_THIS_CLIENT_IS_NO_LONGER_ON_THE_SERVER_SO_REGISTERINTEREST_OPERATION_IS_UNSUCCESSFUL
-                .toLocalizedString());
-        writeChunkedException(msg, ioex, false, servConn);
-        servConn.setAsTrue(RESPONDED);
-        return;
-      }
-      boolean isPrimary = ccp.isPrimary();
-      ChunkedMessage chunkedResponseMsg = servConn.getRegisterInterestResponseMessage();
-      if (!isPrimary) {
-        chunkedResponseMsg.setMessageType(MessageType.RESPONSE_FROM_SECONDARY);
-        chunkedResponseMsg.setTransactionId(msg.getTransactionId());
-        chunkedResponseMsg.sendHeader();
-        chunkedResponseMsg.setLastChunk(true);
-
-        if (logger.isDebugEnabled()) {
-          logger.debug("{}: Sending register interest response chunk from secondary for region: {} for key: {} chunk=<{}>", servConn.getName(), regionName, key, chunkedResponseMsg);
-        }
-        chunkedResponseMsg.sendChunk(servConn);
-      } // !isPrimary
-      else { // isPrimary
-
-        // Send header which describes how many chunks will follow
-        chunkedResponseMsg.setMessageType(MessageType.RESPONSE_FROM_PRIMARY);
-        chunkedResponseMsg.setTransactionId(msg.getTransactionId());
-        chunkedResponseMsg.sendHeader();
-
-        // Send chunk response
-        try {
-          fillAndSendRegisterInterestResponseChunks(region, key, interestType,
-              serializeValues, policy, servConn);
-          servConn.setAsTrue(RESPONDED);
-        }
-        catch (Exception e) {
-          writeChunkedException(msg, e, false, servConn, chunkedResponseMsg);
-          servConn.setAsTrue(RESPONDED);
-          return;
-        }
-
-        if (logger.isDebugEnabled()) {
-          // logger.debug(getName() + ": Sent chunk (1 of 1) of register interest
-          // response (" + chunkedResponseMsg.getBufferLength() + " bytes) for
-          // region " + regionName + " key " + key);
-          logger.debug("{}: Sent register interest response for region {} key {}", servConn.getName(), regionName, key);
-        }
-        // bserverStats.incLong(writeDestroyResponseTimeId,
-        // DistributionStats.getStatTime() - start);
-        // bserverStats.incInt(destroyResponsesId, 1);
-      } // isPrimary
-    } // input key not null

INS26 INS26 INS40 INS40 MOV8 MOV60 MOV60 MOV60 MOV60 MOV21 MOV21 MOV21 MOV21 MOV60 MOV60 MOV54 MOV60 MOV54 MOV60 MOV60 MOV54 MOV21 MOV21 MOV54 MOV60 MOV25 MOV25 MOV25 INS25 INS25 MOV27 MOV8 INS27 INS21 INS21 INS42 INS40 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 DEL25 DEL8
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
-  /** 
-   * System property to allow query on region with heterogeneous objects. 
-   * By default its set to false.
+
+  /**
+   * System property to allow query on region with heterogeneous objects. By default its set to
+   * false.
-  public static final boolean QUERY_HETEROGENEOUS_OBJECTS =
-      Boolean.valueOf(System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "QueryService.QueryHeterogeneousObjects", "true")).booleanValue();
+  public static final boolean QUERY_HETEROGENEOUS_OBJECTS = Boolean
+      .valueOf(System.getProperty(
+          DistributionConfig.GEMFIRE_PREFIX + "QueryService.QueryHeterogeneousObjects", "true"))
+      .booleanValue();
-  public static boolean COPY_ON_READ_AT_ENTRY_LEVEL =
-      Boolean.valueOf(System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "QueryService.CopyOnReadAtEntryLevel", "false")).booleanValue();
+  public static boolean COPY_ON_READ_AT_ENTRY_LEVEL = Boolean
+      .valueOf(System.getProperty(
+          DistributionConfig.GEMFIRE_PREFIX + "QueryService.CopyOnReadAtEntryLevel", "false"))
+      .booleanValue();
-  
+
-  
-  private Map<Region, HashSet<IndexCreationData>> indexDefinitions = Collections.synchronizedMap(new HashMap<Region, HashSet<IndexCreationData>>());
-  
+
+  private Map<Region, HashSet<IndexCreationData>> indexDefinitions =
+      Collections.synchronizedMap(new HashMap<Region, HashSet<IndexCreationData>>());
+
-        throw new IllegalArgumentException(LocalizedStrings.DefaultQueryService_CACHE_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.DefaultQueryService_CACHE_MUST_NOT_BE_NULL.toLocalizedString());
-  
+
-   * Constructs a new <code>Query</code> object. Uses the default namespace,
-   * which is the Objects Context of the current application.
+   * Constructs a new <code>Query</code> object. Uses the default namespace, which is the Objects
+   * Context of the current application.
-      String reason = LocalizedStrings.QueryMonitor_LOW_MEMORY_CANCELED_QUERY.toLocalizedString(QueryMonitor.getMemoryUsedDuringLowMemory());
+      String reason = LocalizedStrings.QueryMonitor_LOW_MEMORY_CANCELED_QUERY
+          .toLocalizedString(QueryMonitor.getMemoryUsedDuringLowMemory());
-        throw new QueryInvalidException(LocalizedStrings.DefaultQueryService_THE_QUERY_STRING_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new QueryInvalidException(
+          LocalizedStrings.DefaultQueryService_THE_QUERY_STRING_MUST_NOT_BE_NULL
+              .toLocalizedString());
-        throw new QueryInvalidException(LocalizedStrings.DefaultQueryService_THE_QUERY_STRING_MUST_NOT_BE_EMPTY.toLocalizedString());
+      throw new QueryInvalidException(
+          LocalizedStrings.DefaultQueryService_THE_QUERY_STRING_MUST_NOT_BE_EMPTY
+              .toLocalizedString());
-  
-  public Query newQuery(String queryString,ProxyCache proxyCache){
+
+  public Query newQuery(String queryString, ProxyCache proxyCache) {
-  public Index createHashIndex(String indexName,
-      String indexedExpression, String fromClause)
-      throws IndexNameConflictException, IndexExistsException, 
-      RegionNotFoundException {
-    return createHashIndex(indexName, indexedExpression, fromClause,
-        null);
-    }
-  
-  public Index createHashIndex(String indexName,
-      String indexedExpression, String fromClause, String imports)
-      throws IndexNameConflictException, IndexExistsException, 
-      RegionNotFoundException {
-    return createIndex(indexName, IndexType.HASH, indexedExpression, fromClause,
-        imports);
+  public Index createHashIndex(String indexName, String indexedExpression, String fromClause)
+      throws IndexNameConflictException, IndexExistsException, RegionNotFoundException {
+    return createHashIndex(indexName, indexedExpression, fromClause, null);
-  
-  public Index createIndex(String indexName,
-      String indexedExpression, String fromClause)
-      throws IndexNameConflictException, IndexExistsException, 
-      RegionNotFoundException {
-    return createIndex(indexName, IndexType.FUNCTIONAL, indexedExpression, fromClause,
+
+  public Index createHashIndex(String indexName, String indexedExpression, String fromClause,
+      String imports)
+      throws IndexNameConflictException, IndexExistsException, RegionNotFoundException {
+    return createIndex(indexName, IndexType.HASH, indexedExpression, fromClause, imports);
+  }
+
+  public Index createIndex(String indexName, String indexedExpression, String fromClause)
+      throws IndexNameConflictException, IndexExistsException, RegionNotFoundException {
+    return createIndex(indexName, IndexType.FUNCTIONAL, indexedExpression, fromClause, null);
+  }
+
+  public Index createIndex(String indexName, String indexedExpression, String fromClause,
+      String imports)
+      throws IndexNameConflictException, IndexExistsException, RegionNotFoundException {
+    return createIndex(indexName, IndexType.FUNCTIONAL, indexedExpression, fromClause, imports);
+  }
+
+  public Index createKeyIndex(String indexName, String indexedExpression, String fromClause)
+      throws IndexNameConflictException, IndexExistsException, RegionNotFoundException {
+    return createIndex(indexName, IndexType.PRIMARY_KEY, indexedExpression, fromClause, null);
+  }
+
+  public Index createIndex(String indexName, IndexType indexType, String indexedExpression,
+      String fromClause)
+      throws IndexNameConflictException, IndexExistsException, RegionNotFoundException {
+    return createIndex(indexName, indexType, indexedExpression, fromClause, null);
+  }
+
+  public Index createIndex(String indexName, IndexType indexType, String indexedExpression,
+      String fromClause, String imports, boolean loadEntries)
+      throws IndexNameConflictException, IndexExistsException, RegionNotFoundException {
+    return createIndex(indexName, indexType, indexedExpression, fromClause, imports, loadEntries,
-  public Index createIndex(String indexName,
-      String indexedExpression, String fromClause, String imports)
-      throws IndexNameConflictException, IndexExistsException, 
-      RegionNotFoundException {
-    return createIndex(indexName, IndexType.FUNCTIONAL, indexedExpression, fromClause,
-        imports);
-  }
+  public Index createIndex(String indexName, IndexType indexType, String indexedExpression,
+      String fromClause, String imports, boolean loadEntries, Region region)
+      throws IndexNameConflictException, IndexExistsException, RegionNotFoundException {
-  public Index createKeyIndex(String indexName,
-      String indexedExpression, String fromClause)
-      throws IndexNameConflictException, IndexExistsException, 
-      RegionNotFoundException {
-    return createIndex(indexName, IndexType.PRIMARY_KEY, indexedExpression, fromClause,
-        null);
-  }
-  
-  public Index createIndex(String indexName, IndexType indexType,
-      String indexedExpression, String fromClause)
-      throws IndexNameConflictException, IndexExistsException, 
-      RegionNotFoundException {
-    return createIndex(indexName, indexType, indexedExpression, fromClause,
-        null);
-  }
-  public Index createIndex(String indexName, IndexType indexType,
-      String indexedExpression, String fromClause, String imports, boolean loadEntries)
-      throws IndexNameConflictException, IndexExistsException, 
-      RegionNotFoundException {
-    return createIndex(indexName, indexType, indexedExpression, fromClause, imports, loadEntries, null);
-  }
-  
-  public Index createIndex(String indexName, IndexType indexType,
-      String indexedExpression, String fromClause, String imports, boolean loadEntries, Region region)
-      throws IndexNameConflictException, IndexExistsException, 
-      RegionNotFoundException {
-
-    
-    if (pool != null){
-      throw new UnsupportedOperationException("Index creation on the server is not supported from the client.");  
+    if (pool != null) {
+      throw new UnsupportedOperationException(
+          "Index creation on the server is not supported from the client.");
-    if(region == null) {
+    if (region == null) {
-    
-    //Asif: If the evistion action is Overflow to disk then do not allow index creation
-    //It is Ok to have index creation if it is persist only mode as data will always
-    //exist in memory
-    //if(ra.getEvictionAttributes().getAction().isOverflowToDisk() ) {
-    //  throw new UnsupportedOperationException(LocalizedStrings.DefaultQueryService_INDEX_CREATION_IS_NOT_SUPPORTED_FOR_REGIONS_WHICH_OVERFLOW_TO_DISK_THE_REGION_INVOLVED_IS_0.toLocalizedString(regionPath));
-    //}
+
+    // Asif: If the evistion action is Overflow to disk then do not allow index creation
+    // It is Ok to have index creation if it is persist only mode as data will always
+    // exist in memory
+    // if(ra.getEvictionAttributes().getAction().isOverflowToDisk() ) {
+    // throw new
+    // UnsupportedOperationException(LocalizedStrings.DefaultQueryService_INDEX_CREATION_IS_NOT_SUPPORTED_FOR_REGIONS_WHICH_OVERFLOW_TO_DISK_THE_REGION_INVOLVED_IS_0.toLocalizedString(regionPath));
+    // }
-    if (((LocalRegion)region).memoryThresholdReached.get() &&
-        !MemoryThresholds.isLowMemoryExceptionDisabled()) {
-      LocalRegion lr = (LocalRegion)region;
-      throw new LowMemoryException(LocalizedStrings.ResourceManager_LOW_MEMORY_FOR_INDEX
-          .toLocalizedString(region.getName()), lr.getMemoryThresholdReachedMembers());
+    if (((LocalRegion) region).memoryThresholdReached.get()
+        && !MemoryThresholds.isLowMemoryExceptionDisabled()) {
+      LocalRegion lr = (LocalRegion) region;
+      throw new LowMemoryException(
+          LocalizedStrings.ResourceManager_LOW_MEMORY_FOR_INDEX.toLocalizedString(region.getName()),
+          lr.getMemoryThresholdReachedMembers());
-        parIndex = (PartitionedIndex)((PartitionedRegion)region).createIndex(
-            false, indexType, indexName, indexedExpression, fromClause,  imports, loadEntries);
-      }
-      catch (ForceReattemptException ex) {
+        parIndex = (PartitionedIndex) ((PartitionedRegion) region).createIndex(false, indexType,
+            indexName, indexedExpression, fromClause, imports, loadEntries);
+      } catch (ForceReattemptException ex) {
-          LocalizedStrings.DefaultQueryService_EXCEPTION_WHILE_CREATING_INDEX_ON_PR_DEFAULT_QUERY_PROCESSOR,
-          ex);
-      }
-      catch (IndexCreationException exx) {
+            LocalizedStrings.DefaultQueryService_EXCEPTION_WHILE_CREATING_INDEX_ON_PR_DEFAULT_QUERY_PROCESSOR,
+            ex);
+      } catch (IndexCreationException exx) {
-          LocalizedStrings.DefaultQueryService_EXCEPTION_WHILE_CREATING_INDEX_ON_PR_DEFAULT_QUERY_PROCESSOR,
-          exx);
+            LocalizedStrings.DefaultQueryService_EXCEPTION_WHILE_CREATING_INDEX_ON_PR_DEFAULT_QUERY_PROCESSOR,
+            exx);
-    }
-    else {
-        
+    } else {
+
-      Index index = indexManager.createIndex(indexName, indexType,
-        indexedExpression, fromClause , imports, null, null, loadEntries);
-      
+      Index index = indexManager.createIndex(indexName, indexType, indexedExpression, fromClause,
+          imports, null, null, loadEntries);
+
-  public Index createIndex(String indexName, IndexType indexType,
-      String indexedExpression, String fromClause, String imports)
-      throws IndexNameConflictException, IndexExistsException, 
-      RegionNotFoundException {
-    
+  public Index createIndex(String indexName, IndexType indexType, String indexedExpression,
+      String fromClause, String imports)
+      throws IndexNameConflictException, IndexExistsException, RegionNotFoundException {
+
-        .obtainTheBottomMostCompiledValue(((CompiledIteratorDef) list.get(0))
-            .getCollectionExpr());
+        .obtainTheBottomMostCompiledValue(((CompiledIteratorDef) list.get(0)).getCollectionExpr());
-              .toLocalizedString(new Object[] { regionPath, fromClause }));
+              .toLocalizedString(new Object[] {regionPath, fromClause}));
-  
+
-   * @param definitions An array of String objects containing canonicalized
-   *          definitions of RuntimeIterators. A Canonicalized definition of a
-   *          RuntimeIterator is the canonicalized expression obtainded from its
-   *          underlying collection expression.
-   * @param indexType IndexType object which can be either of type RangeIndex or
-   *          PrimaryKey Index
-   * @param indexedExpression CompiledValue containing the path expression on which
-   *          index needs to be created
-   * @param  context ExecutionContext         
+   * @param definitions An array of String objects containing canonicalized definitions of
+   *        RuntimeIterators. A Canonicalized definition of a RuntimeIterator is the canonicalized
+   *        expression obtainded from its underlying collection expression.
+   * @param indexType IndexType object which can be either of type RangeIndex or PrimaryKey Index
+   * @param indexedExpression CompiledValue containing the path expression on which index needs to
+   *        be created
+   * @param context ExecutionContext
-   * @throws NameResolutionException 
-   * @throws TypeMismatchException 
-   * @throws AmbiguousNameException 
+   * @throws NameResolutionException
+   * @throws TypeMismatchException
+   * @throws AmbiguousNameException
-  public IndexData getIndex(String regionPath, String[] definitions,
-      IndexType indexType, CompiledValue indexedExpression, ExecutionContext context) 
-  throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+  public IndexData getIndex(String regionPath, String[] definitions, IndexType indexType,
+      CompiledValue indexedExpression, ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-    if (region == null) { return null; }
+    if (region == null) {
+      return null;
+    }
-    IndexData indexData = indexManager.getIndex(indexType, definitions,
-        indexedExpression, context);
+    IndexData indexData = indexManager.getIndex(indexType, definitions, indexedExpression, context);
-    
-    if (pool != null){
-      throw new UnsupportedOperationException("Index Operation is not supported on the Server Region.");  
+
+    if (pool != null) {
+      throw new UnsupportedOperationException(
+          "Index Operation is not supported on the Server Region.");
-   * Asif: Gets a best match index which is available. An index with match level
-   * equal to 0 is the best index to use as it implies that the query from
-   * clause iterators belonging to the region exactly match the index from
-   * clause iterators ( the difference in the relative positions of the
-   * iterators do not matter). A match level less than 0 means that number of
-   * iteratots in the index resultset is more than that present in the query
-   * from clause and hence index resultset will need a cutdown. A match level
-   * greater than 0 means that there definitely is atleast one iterator in the
-   * query from clause which is more than the index from clause iterators &
-   * hence definitely expansion of index results will be needed. Pls note that a
-   * match level greater than 0 does not imply that index from clause does not
-   * have an extra iterator in it , too. Hence a match level greater than 0 will
-   * definitely mean expansion of index results but may also require a cut down
-   * of results . The order of preference is match level 0 , less than 0 and
-   * lastly greater than 0
+   * Asif: Gets a best match index which is available. An index with match level equal to 0 is the
+   * best index to use as it implies that the query from clause iterators belonging to the region
+   * exactly match the index from clause iterators ( the difference in the relative positions of the
+   * iterators do not matter). A match level less than 0 means that number of iteratots in the index
+   * resultset is more than that present in the query from clause and hence index resultset will
+   * need a cutdown. A match level greater than 0 means that there definitely is atleast one
+   * iterator in the query from clause which is more than the index from clause iterators & hence
+   * definitely expansion of index results will be needed. Pls note that a match level greater than
+   * 0 does not imply that index from clause does not have an extra iterator in it , too. Hence a
+   * match level greater than 0 will definitely mean expansion of index results but may also require
+   * a cut down of results . The order of preference is match level 0 , less than 0 and lastly
+   * greater than 0
-   * @param definitions An array of String objects containing canonicalized
-   *          definitions of RuntimeIterators. A Canonicalized definition of a
-   *          RuntimeIterator is the canonicalized expression obtainded from its
-   *          underlying collection expression.
-   * @param indexType IndexType object which can be either of type RangeIndex or
-   *          PrimaryKey Index
-   * @param indexedExpression CompiledValue representing  the path expression on which
-   *          index needs to be created
-   * @param  context ExecutionContext object         
+   * @param definitions An array of String objects containing canonicalized definitions of
+   *        RuntimeIterators. A Canonicalized definition of a RuntimeIterator is the canonicalized
+   *        expression obtainded from its underlying collection expression.
+   * @param indexType IndexType object which can be either of type RangeIndex or PrimaryKey Index
+   * @param indexedExpression CompiledValue representing the path expression on which index needs to
+   *        be created
+   * @param context ExecutionContext object
-   * @throws NameResolutionException 
-   * @throws TypeMismatchException 
-   * @throws AmbiguousNameException 
+   * @throws NameResolutionException
+   * @throws TypeMismatchException
+   * @throws AmbiguousNameException
-  public IndexData getBestMatchIndex(String regionPath, String definitions[],
-      IndexType indexType, CompiledValue indexedExpression, ExecutionContext context) throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+  public IndexData getBestMatchIndex(String regionPath, String definitions[], IndexType indexType,
+      CompiledValue indexedExpression, ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-    if (region == null){ 
-      return null; 
+    if (region == null) {
+      return null;
-    if (indexManager == null) { 
+    if (indexManager == null) {
-    return indexManager.getBestMatchIndex(indexType, definitions,
-        indexedExpression, context);
+    return indexManager.getBestMatchIndex(indexType, definitions, indexedExpression, context);
-      if (indexes != null) allIndexes.addAll(indexes);
+      if (indexes != null)
+        allIndexes.addAll(indexes);
-        if (indexes != null) allIndexes.addAll(indexes);
+        if (indexes != null)
+          allIndexes.addAll(indexes);
-    if (pool != null){
-      throw new UnsupportedOperationException("Index Operation is not supported on the Server Region.");  
+    if (pool != null) {
+      throw new UnsupportedOperationException(
+          "Index Operation is not supported on the Server Region.");
-      return ((PartitionedRegion)region).getIndexes();
+      return ((PartitionedRegion) region).getIndexes();
-    if (indexManager == null) return null;
+    if (indexManager == null)
+      return null;
-    if (pool != null){
-      throw new UnsupportedOperationException("Index Operation is not supported on the Server Region.");  
+    if (pool != null) {
+      throw new UnsupportedOperationException(
+          "Index Operation is not supported on the Server Region.");
-    if (indexManager == null) return null;
+    if (indexManager == null)
+      return null;
-    if (pool != null){
-      throw new UnsupportedOperationException("Index Operation is not supported on the Server Region.");  
+    if (pool != null) {
+      throw new UnsupportedOperationException(
+          "Index Operation is not supported on the Server Region.");
-       ((PartitionedRegion)region).removeIndex(index, false);
-      }
-      catch (ForceReattemptException ex) {
-        logger.info(LocalizedMessage.create(LocalizedStrings.DefaultQueryService_EXCEPTION_REMOVING_INDEX___0), ex);
+        ((PartitionedRegion) region).removeIndex(index, false);
+      } catch (ForceReattemptException ex) {
+        logger.info(LocalizedMessage
+            .create(LocalizedStrings.DefaultQueryService_EXCEPTION_REMOVING_INDEX___0), ex);
-      IndexManager indexManager = ((LocalRegion) index.getRegion())
-          .getIndexManager();
+      IndexManager indexManager = ((LocalRegion) index.getRegion()).getIndexManager();
-    if (pool != null){
-      throw new UnsupportedOperationException("Index Operation is not supported on the Server Region.");  
+    if (pool != null) {
+      throw new UnsupportedOperationException(
+          "Index Operation is not supported on the Server Region.");
-    if (pool != null){
-      throw new UnsupportedOperationException("Index Operation is not supported on the Server Region.");  
+    if (pool != null) {
+      throw new UnsupportedOperationException(
+          "Index Operation is not supported on the Server Region.");
-    
+
-        //not remotely orignated
-        ((PartitionedRegion)region).removeIndexes(false);
-      }
-      catch(ForceReattemptException ex ) {
-           // will have to throw a proper exception relating to remove index.
-           logger.info(LocalizedMessage.create(LocalizedStrings.DefaultQueryService_EXCEPTION_REMOVING_INDEX___0), ex);
+        // not remotely orignated
+        ((PartitionedRegion) region).removeIndexes(false);
+      } catch (ForceReattemptException ex) {
+        // will have to throw a proper exception relating to remove index.
+        logger.info(LocalizedMessage
+            .create(LocalizedStrings.DefaultQueryService_EXCEPTION_REMOVING_INDEX___0), ex);
-    if (indexManager == null) return;
-    
+    if (indexManager == null)
+      return;
+
-  
+
-  
+
-   * Constructs a new continuous query, represented by an instance of
-   * CqQuery. The CqQuery is not executed until the execute method
-   * is invoked on the CqQuery.
+   * Constructs a new continuous query, represented by an instance of CqQuery. The CqQuery is not
+   * executed until the execute method is invoked on the CqQuery.
+   * 
-   * @return the newly created  CqQuery object
+   * @return the newly created CqQuery object
-   * @throws IllegalStateException if this method is called from a cache
-   *         server
+   * @throws IllegalStateException if this method is called from a cache server
-   * @throws CqException if failed to create cq, failure during creating  
-   *         managing cq metadata info.
-   *   E.g.: Query string should refer only one region, join not supported.
-   *         The query must be a SELECT statement.
-   *         DISTINCT queries are not supported.
-   *         Projections are not supported.
-   *         Only one iterator in the FROM clause is supported, and it must be a region path. 
-   *         Bind parameters in the query are not yet supported.
+   * @throws CqException if failed to create cq, failure during creating managing cq metadata info.
+   *         E.g.: Query string should refer only one region, join not supported. The query must be
+   *         a SELECT statement. DISTINCT queries are not supported. Projections are not supported.
+   *         Only one iterator in the FROM clause is supported, and it must be a region path. Bind
+   *         parameters in the query are not yet supported.
-  public CqQuery newCq(String queryString, CqAttributes  cqAttributes) 
-  throws QueryInvalidException, CqException {
+  public CqQuery newCq(String queryString, CqAttributes cqAttributes)
+      throws QueryInvalidException, CqException {
-      cq = (ClientCQ)getCqService().newCq(null, queryString, cqAttributes, this.pool, false);
+      cq = (ClientCQ) getCqService().newCq(null, queryString, cqAttributes, this.pool, false);
-  
+
-   * Constructs a new continuous query, represented by an instance of
-   * CqQuery. The CqQuery is not executed until the execute method
-   * is invoked on the CqQuery.
+   * Constructs a new continuous query, represented by an instance of CqQuery. The CqQuery is not
+   * executed until the execute method is invoked on the CqQuery.
+   * 
-   * @return the newly created  CqQuery object
+   * @return the newly created CqQuery object
-   * @throws IllegalStateException if this method is called from a cache
-   *         server
+   * @throws IllegalStateException if this method is called from a cache server
-   * @throws CqException if failed to create cq, failure during creating  
-   *         managing cq metadata info.
-   *   E.g.: Query string should refer only one region, join not supported.
-   *         The query must be a SELECT statement.
-   *         DISTINCT queries are not supported.
-   *         Projections are not supported.
-   *         Only one iterator in the FROM clause is supported, and it must be a region path. 
-   *         Bind parameters in the query are not yet supported.
+   * @throws CqException if failed to create cq, failure during creating managing cq metadata info.
+   *         E.g.: Query string should refer only one region, join not supported. The query must be
+   *         a SELECT statement. DISTINCT queries are not supported. Projections are not supported.
+   *         Only one iterator in the FROM clause is supported, and it must be a region path. Bind
+   *         parameters in the query are not yet supported.
-  public CqQuery newCq(String queryString, CqAttributes  cqAttributes, boolean isDurable) 
-  throws QueryInvalidException, CqException {
+  public CqQuery newCq(String queryString, CqAttributes cqAttributes, boolean isDurable)
+      throws QueryInvalidException, CqException {
-      cq = (ClientCQ)getCqService().newCq(null, queryString, cqAttributes, this.pool, isDurable);
+      cq = (ClientCQ) getCqService().newCq(null, queryString, cqAttributes, this.pool, isDurable);
-  
-  
+
+
-   * Constructs a new named continuous query, represented by an instance of
-   * CqQuery. The CqQuery is not executed, however, until the execute method
-   * is invoked on the CqQuery. The name of the query will be used
-   * to identify this query in statistics archival.
+   * Constructs a new named continuous query, represented by an instance of CqQuery. The CqQuery is
+   * not executed, however, until the execute method is invoked on the CqQuery. The name of the
+   * query will be used to identify this query in statistics archival.
-   * @return the newly created  CqQuery object
-   * @throws CqExistsException if a CQ by this name already exists on this
-   *         client
+   * @return the newly created CqQuery object
+   * @throws CqExistsException if a CQ by this name already exists on this client
-   * @throws IllegalStateException if this method is called from a cache
-   *         server
+   * @throws IllegalStateException if this method is called from a cache server
-   * @throws CqException if failed to create cq, failure during creating  
-   *         managing cq metadata info.
-   *   E.g.: Query string should refer only one region, join not supported.
-   *         The query must be a SELECT statement.
-   *         DISTINCT queries are not supported.
-   *         Projections are not supported.
-   *         Only one iterator in the FROM clause is supported, and it must be a region path. 
-   *         Bind parameters in the query are not yet supported.
+   * @throws CqException if failed to create cq, failure during creating managing cq metadata info.
+   *         E.g.: Query string should refer only one region, join not supported. The query must be
+   *         a SELECT statement. DISTINCT queries are not supported. Projections are not supported.
+   *         Only one iterator in the FROM clause is supported, and it must be a region path. Bind
+   *         parameters in the query are not yet supported.
-  throws QueryInvalidException, CqExistsException, CqException {
+      throws QueryInvalidException, CqExistsException, CqException {
-      throw new IllegalArgumentException(LocalizedStrings.DefaultQueryService_CQNAME_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.DefaultQueryService_CQNAME_MUST_NOT_BE_NULL.toLocalizedString());
-    ClientCQ cq = (ClientCQ)getCqService().newCq(cqName, queryString, cqAttributes, this.pool, false);
+    ClientCQ cq =
+        (ClientCQ) getCqService().newCq(cqName, queryString, cqAttributes, this.pool, false);
-  
+
-   * Constructs a new named continuous query, represented by an instance of
-   * CqQuery. The CqQuery is not executed, however, until the execute method
-   * is invoked on the CqQuery. The name of the query will be used
-   * to identify this query in statistics archival.
+   * Constructs a new named continuous query, represented by an instance of CqQuery. The CqQuery is
+   * not executed, however, until the execute method is invoked on the CqQuery. The name of the
+   * query will be used to identify this query in statistics archival.
-   * @return the newly created  CqQuery object
-   * @throws CqExistsException if a CQ by this name already exists on this
-   *         client
+   * @return the newly created CqQuery object
+   * @throws CqExistsException if a CQ by this name already exists on this client
-   * @throws IllegalStateException if this method is called from a cache
-   *         server
+   * @throws IllegalStateException if this method is called from a cache server
-   * @throws CqException if failed to create cq, failure during creating  
-   *         managing cq metadata info.
-   *   E.g.: Query string should refer only one region, join not supported.
-   *         The query must be a SELECT statement.
-   *         DISTINCT queries are not supported.
-   *         Projections are not supported.
-   *         Only one iterator in the FROM clause is supported, and it must be a region path. 
-   *         Bind parameters in the query are not yet supported.
+   * @throws CqException if failed to create cq, failure during creating managing cq metadata info.
+   *         E.g.: Query string should refer only one region, join not supported. The query must be
+   *         a SELECT statement. DISTINCT queries are not supported. Projections are not supported.
+   *         Only one iterator in the FROM clause is supported, and it must be a region path. Bind
+   *         parameters in the query are not yet supported.
-  public CqQuery newCq(String cqName, String queryString, CqAttributes cqAttributes, boolean isDurable)
-  throws QueryInvalidException, CqExistsException, CqException {
+  public CqQuery newCq(String cqName, String queryString, CqAttributes cqAttributes,
+      boolean isDurable) throws QueryInvalidException, CqExistsException, CqException {
-      throw new IllegalArgumentException(LocalizedStrings.DefaultQueryService_CQNAME_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.DefaultQueryService_CQNAME_MUST_NOT_BE_NULL.toLocalizedString());
-    ClientCQ cq = (ClientCQ)getCqService().newCq(cqName, queryString, cqAttributes, this.pool, isDurable);
+    ClientCQ cq =
+        (ClientCQ) getCqService().newCq(cqName, queryString, cqAttributes, this.pool, isDurable);
-  
-  /** 
-   * Close all CQs executing in this VM, and release resources
-   * associated with executing CQs.
+
+  /**
+   * Close all CQs executing in this VM, and release resources associated with executing CQs.
-  
+
+   * 
-  
+
-   * Retrieve  all CqQuerys created by this VM.
-   * @return null if there are no cqs.   
-   */ 
+   * Retrieve all CqQuerys created by this VM.
+   * 
+   * @return null if there are no cqs.
+   */
-  
+
-  public CqQuery[] getCqs(final String regionName) throws CqException
-  {
+  public CqQuery[] getCqs(final String regionName) throws CqException {
-   * Starts execution of all the registered continuous queries for this client.
-   * This is complementary to stopCqs.
+   * Starts execution of all the registered continuous queries for this client. This is
+   * complementary to stopCqs.
+   * 
-  
-  
+
+
-   * Stops execution of all the continuous queries for this client to become inactive.
-   * This is useful when client needs to control the incoming cq messages during
-   * bulk region operations.
+   * Stops execution of all the continuous queries for this client to become inactive. This is
+   * useful when client needs to control the incoming cq messages during bulk region operations.
+   * 
-  
+
-   * Starts execution of all the continuous queries registered on the specified 
-   * region for this client. 
-   * This is complementary method to stopCQs().  
+   * Starts execution of all the continuous queries registered on the specified region for this
+   * client. This is complementary method to stopCQs().
+   * 
-        logger.debug("Unable to execute cqs on the specified region. Error :{}", cqe.getMessage(), cqe);
+        logger.debug("Unable to execute cqs on the specified region. Error :{}", cqe.getMessage(),
+            cqe);
-  
+
-   * Stops execution of all the continuous queries registered on the specified 
-   * region for this client. 
-   * This is useful when client needs to control the incoming cq messages during
-   * bulk region operations.
+   * Stops execution of all the continuous queries registered on the specified region for this
+   * client. This is useful when client needs to control the incoming cq messages during bulk region
+   * operations.
+   * 
-   */  
+   */
-        logger.debug("Unable to stop cqs on the specified region. Error :{}", cqe.getMessage(), cqe);
+        logger.debug("Unable to stop cqs on the specified region. Error :{}", cqe.getMessage(),
+            cqe);
-  
+
-   * @return CQ statistics
-   *         null if the continuous query object not found for the given cqName.
+   * 
+   * @return CQ statistics null if the continuous query object not found for the given cqName.
-  
+
+   * 
-    }    
+    }
-  
+
-  
+
-  
+
-      logger.debug("Setting ServerProxy with the Query Service using the pool :{} ", pool.getName());
+      logger.debug("Setting ServerProxy with the Query Service using the pool :{} ",
+          pool.getName());
-  
+
+      } else {
+        throw new UnsupportedOperationException(
+            "GetAllDurableCQsFromServer requires a pool to be configured.");
-      else {
-        throw new UnsupportedOperationException("GetAllDurableCQsFromServer requires a pool to be configured.");  
-      }
-    }
-    else {
-      //we are a server
+    } else {
+      // we are a server
-  public void defineKeyIndex(String indexName,
-      String indexedExpression, String fromClause)
+  public void defineKeyIndex(String indexName, String indexedExpression, String fromClause)
-    defineIndex(indexName, IndexType.PRIMARY_KEY, indexedExpression, fromClause,
-        null);
+    defineIndex(indexName, IndexType.PRIMARY_KEY, indexedExpression, fromClause, null);
-  public void defineHashIndex(String indexName, String indexedExpression,
-      String fromClause) throws RegionNotFoundException {
+  public void defineHashIndex(String indexName, String indexedExpression, String fromClause)
+      throws RegionNotFoundException {
-  public void defineHashIndex(String indexName, String indexedExpression,
-      String fromClause, String imports) throws RegionNotFoundException {
+  public void defineHashIndex(String indexName, String indexedExpression, String fromClause,
+      String imports) throws RegionNotFoundException {
-  public void defineIndex(String indexName, String indexedExpression,
-      String fromClause) throws RegionNotFoundException {
+  public void defineIndex(String indexName, String indexedExpression, String fromClause)
+      throws RegionNotFoundException {
-  public void defineIndex(String indexName, String indexedExpression,
-      String fromClause, String imports) throws RegionNotFoundException  {
+  public void defineIndex(String indexName, String indexedExpression, String fromClause,
+      String imports) throws RegionNotFoundException {
-  
+
-      String fromClause, String imports) throws RegionNotFoundException  {
+      String fromClause, String imports) throws RegionNotFoundException {
-    
+
-      for (Entry<Region, HashSet<IndexCreationData>> e : indexDefinitions
-          .entrySet()) {
+      for (Entry<Region, HashSet<IndexCreationData>> e : indexDefinitions.entrySet()) {
-          throwException = createDefinedIndexesForPR(indexes,
-              (PartitionedRegion) region, icds, exceptionsMap);
+          throwException =
+              createDefinedIndexesForPR(indexes, (PartitionedRegion) region, icds, exceptionsMap);
-          throwException = createDefinedIndexesForReplicatedRegion(indexes,
-              region, icds, exceptionsMap);
+          throwException =
+              createDefinedIndexesForReplicatedRegion(indexes, region, icds, exceptionsMap);
-  private boolean createDefinedIndexesForPR(HashSet<Index> indexes,
-      PartitionedRegion region, HashSet<IndexCreationData> icds,
-      HashMap<String, Exception> exceptionsMap) {
+  private boolean createDefinedIndexesForPR(HashSet<Index> indexes, PartitionedRegion region,
+      HashSet<IndexCreationData> icds, HashMap<String, Exception> exceptionsMap) {
-      logger.info(LocalizedMessage.create(
-              LocalizedStrings.DefaultQueryService_EXCEPTION_WHILE_CREATING_INDEX_ON_PR_DEFAULT_QUERY_PROCESSOR), e1);
+      logger.info(
+          LocalizedMessage.create(
+              LocalizedStrings.DefaultQueryService_EXCEPTION_WHILE_CREATING_INDEX_ON_PR_DEFAULT_QUERY_PROCESSOR),
+          e1);
-      logger.info(LocalizedMessage.create(
-              LocalizedStrings.DefaultQueryService_EXCEPTION_WHILE_CREATING_INDEX_ON_PR_DEFAULT_QUERY_PROCESSOR), e1);
+      logger.info(
+          LocalizedMessage.create(
+              LocalizedStrings.DefaultQueryService_EXCEPTION_WHILE_CREATING_INDEX_ON_PR_DEFAULT_QUERY_PROCESSOR),
+          e1);
-      logger.info(LocalizedMessage.create(
-              LocalizedStrings.DefaultQueryService_EXCEPTION_WHILE_CREATING_INDEX_ON_PR_DEFAULT_QUERY_PROCESSOR), e1);
+      logger.info(
+          LocalizedMessage.create(
+              LocalizedStrings.DefaultQueryService_EXCEPTION_WHILE_CREATING_INDEX_ON_PR_DEFAULT_QUERY_PROCESSOR),
+          e1);
-  private boolean createDefinedIndexesForReplicatedRegion(HashSet<Index> indexes,
-      Region region, Set<IndexCreationData> icds,
-      HashMap<String, Exception> exceptionsMap) {
+  private boolean createDefinedIndexesForReplicatedRegion(HashSet<Index> indexes, Region region,
+      Set<IndexCreationData> icds, HashMap<String, Exception> exceptionsMap) {
-        indexes.add(createIndex(icd.getIndexName(), icd.getIndexType(),
-            icd.getIndexExpression(), icd.getIndexFromClause(),
-            icd.getIndexImportString(), false, region));
+        indexes.add(createIndex(icd.getIndexName(), icd.getIndexType(), icd.getIndexExpression(),
+            icd.getIndexFromClause(), icd.getIndexImportString(), false, region));
-        exceptionsMap.put(icd.getIndexName(), new IndexCreationException(
-            "Index Creation Failed due to region destroy"));
+        exceptionsMap.put(icd.getIndexName(),
+            new IndexCreationException("Index Creation Failed due to region destroy"));
-    if(indexes.size() > 0) {
+    if (indexes.size() > 0) {
-  
+
-  
+

MOV65 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
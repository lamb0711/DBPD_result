GEODE-6309 ClusterConfigLocatorRestartDUnitTest fails to spin up a new server

This modifies auto-reconnect to lengthen the time a Locator will attempt
to join from 24 seconds to 60 seconds and prevents the Locator from
creating its own cluster (which would form a split-brain).  In an
auto-reconnect attempt the location service will not start up until a
quorum of the old cluster can be contacted, meaning that some process
that's still in the cluster exists and should have taken over the role
of membership coordinator.  The locator needs to join using that
coordinator and not create its own cluster.

This also corrects the handling of the old membership view in
GMSLocator.  The restarted location service was incorrectly using this
old view as an authority on who had the role of coordinator but it
should only be used as a hint.  This is done by putting the view into
the recoveredView variable and assigning it an invalid viewID.

In real applications this bug isn't likely to be encountered because the
first auto-reconnect attempt doesn't take place for a minute.  The
ClusterStartupRule modifies this default to start reconnecting in 5
seconds, which wasn't giving the cluster enough time to react to the
loss of the old Locator and assign a new membership coordinator.
With these changes the test passes even if the default is reduced to 1
second.

Finally, the test was incorrectly using internal APIs to detect whether
the Locator had successfully reconnected. I fixed some of that but
opened GEODE-6312 to track the problem that stopping the old Locator did
not actually stop its cluster configuration service.

-      this.locators = new ArrayList<HostAddress>(0);
+      this.locators = new ArrayList<>(0);
-        this.view = newView;
-      } else if (localAddress != null) {
-        synchronized (this.registrants) {
-          this.registrants.add(localAddress);
+        view = newView;
+        recoveredView = null;
+      } else {
+        // if we are auto-reconnecting we may already have a membership view
+        // and should use it as a "recovered view" which only hints at who is
+        // the current membership coordinator
+        if (view != null) {
+          view.setViewId(-100); // no longer a valid view
+          recoveredView = view; // auto-reconnect will be based on the recovered view
+          view = null;
+        }
+        if (localAddress != null) {
+          if (recoveredView != null) {
+            recoveredView.remove(localAddress);
+          }
+          synchronized (this.registrants) {
+            this.registrants.add(localAddress);
+          }
-  public File setViewFile(File file) {
+  File setViewFile(File file) {
-      } catch (InterruptedException e) {
+      } catch (InterruptedException ignored) {
-  public Object processRequest(Object request) throws IOException {
+  public Object processRequest(Object request) {
+          fromView = false;
-        oos.flush();
-        oos.close();
+        if (oos != null) {
+          oos.flush();
+          oos.close();
+        }
-      if (response != null && (response instanceof GetViewResponse)) {
+      if (response instanceof GetViewResponse) {
-    } catch (IOException | ClassNotFoundException ignore) {
+    } catch (IOException | ClassNotFoundException ex) {
-          ignore.getMessage());
+          ex.getMessage());

INS8 INS8 MOV62 UPD42 INS21 INS25 MOV25 INS25 UPD74 INS7 INS27 INS8 UPD42 INS27 MOV8 INS42 INS42 INS33 INS42 INS33 INS21 INS21 INS21 INS25 INS21 INS42 INS33 UPD42 INS32 INS7 INS7 INS27 INS8 INS7 INS42 INS42 INS38 INS42 INS42 INS42 INS33 INS42 INS33 INS21 INS42 INS9 INS34 INS32 INS42 INS42 INS42 DEL42 DEL43 DEL52 DEL42 DEL22 DEL83 DEL42 DEL43 DEL42 DEL33 DEL27 DEL36 DEL27
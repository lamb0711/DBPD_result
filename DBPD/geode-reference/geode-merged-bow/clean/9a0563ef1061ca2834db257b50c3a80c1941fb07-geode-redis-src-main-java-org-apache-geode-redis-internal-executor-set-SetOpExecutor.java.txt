GEODE-8170: change all hash and set commands to use function (#5125)

All hash and set commands now use the new function+delta data model.
This allowed the synchronized keyword to be removed from RedisHash and RedisSet.

-import java.util.HashSet;
-import org.apache.geode.cache.Region;
-import org.apache.geode.cache.TimeoutException;
-import org.apache.geode.redis.internal.AutoCloseableLock;
-import org.apache.geode.redis.internal.RedisData;
-import org.apache.geode.redis.internal.RegionProvider;
-    List<byte[]> commandElems = command.getProcessedCommand();
-    int setsStartIndex = isStorage() ? 2 : 1;
+    int setsStartIndex = 1;
-    RegionProvider regionProvider = context.getRegionProvider();
-    ByteArrayWrapper destination = null;
-      destination = command.getKey();
+      setsStartIndex++;
-    ByteArrayWrapper firstSetKey = new ByteArrayWrapper(commandElems.get(setsStartIndex++));
-    RedisResponse response;
-
-    if (destination != null) {
-      try (AutoCloseableLock regionLock = withRegionLock(context, destination)) {
-        response = doActualSetOperation(command, context, commandElems, setsStartIndex,
-            regionProvider, destination, firstSetKey);
-      } catch (InterruptedException e) {
-        Thread.currentThread().interrupt();
-        response = RedisResponse.error("Thread interrupted");
-      } catch (TimeoutException e) {
-        return RedisResponse.error("Timeout acquiring lock. Please try again");
+    List<ByteArrayWrapper> commandElements = command.getProcessedCommandWrappers();
+    ArrayList<ByteArrayWrapper> setKeys =
+        new ArrayList<>(commandElements.subList(setsStartIndex, commandElements.size()));
+    if (isStorage()) {
+      ByteArrayWrapper destination = command.getKey();
+      RedisSetCommands redisSetCommands = createRedisSetCommands(context);
+      int storeCount;
+      switch (command.getCommandType()) {
+        case SUNIONSTORE:
+          storeCount = redisSetCommands.sunionstore(destination, setKeys);
+          break;
+        case SINTERSTORE:
+          storeCount = redisSetCommands.sinterstore(destination, setKeys);
+          break;
+        case SDIFFSTORE:
+          storeCount = redisSetCommands.sdiffstore(destination, setKeys);
+          break;
+        default:
+          throw new IllegalStateException(
+              "expected a set store command but found: " + command.getCommandType());
+      return RedisResponse.integer(storeCount);
-      response = doActualSetOperation(command, context, commandElems, setsStartIndex,
-          regionProvider, destination, firstSetKey);
+      return doActualSetOperation(context, setKeys);
-
-    return response;
-  private RedisResponse doActualSetOperation(Command command, ExecutionHandlerContext context,
-      List<byte[]> commandElems, int setsStartIndex,
-      RegionProvider regionProvider, ByteArrayWrapper destination,
-      ByteArrayWrapper firstSetKey) {
-    Region<ByteArrayWrapper, RedisData> region = this.getRegion(context);
-    Set<ByteArrayWrapper> firstSet = new RedisSetInRegion(region).smembers(firstSetKey);
+  private RedisResponse doActualSetOperation(ExecutionHandlerContext context,
+      ArrayList<ByteArrayWrapper> setKeys) {
+    RedisSetCommands redisSetCommands = createRedisSetCommands(context);
+    ByteArrayWrapper firstSetKey = setKeys.remove(0);
+    Set<ByteArrayWrapper> resultSet = redisSetCommands.smembers(firstSetKey);
-    List<Set<ByteArrayWrapper>> setList = new ArrayList<>();
-    for (int i = setsStartIndex; i < commandElems.size(); i++) {
-      ByteArrayWrapper key = new ByteArrayWrapper(commandElems.get(i));
-
-      Set<ByteArrayWrapper> entry = new RedisSetInRegion(region).smembers(key);
-      if (entry != null) {
-        setList.add(entry);
-      } else if (this instanceof SInterExecutor) {
-        setList.add(new HashSet<>());
+    for (ByteArrayWrapper key : setKeys) {
+      Set<ByteArrayWrapper> nextSet = redisSetCommands.smembers(key);
+      if (doSetOp(resultSet, nextSet)) {
+        break;
-    if (setList.isEmpty() && !isStorage()) {
-      return respondBulkStrings(firstSet);
-    }
-
-    RedisResponse response;
-
-    Set<ByteArrayWrapper> resultSet = setOp(firstSet, setList);
-    if (isStorage()) {
-      regionProvider.removeKey(destination);
-      if (resultSet != null) {
-        if (!resultSet.isEmpty()) {
-          region.put(destination, new RedisSet(resultSet));
-        }
-        response = RedisResponse.integer(resultSet.size());
-      } else {
-        response = RedisResponse.integer(0);
-      }
+    if (resultSet.isEmpty()) {
+      return RedisResponse.emptyArray();
-      if (resultSet == null || resultSet.isEmpty()) {
-        response = RedisResponse.emptyArray();
-      } else {
-        response = respondBulkStrings(resultSet);
-      }
+      return respondBulkStrings(resultSet);
-
-    return response;
+  /**
+   * @return true if no further calls of doSetOp are needed
+   */
+  protected abstract boolean doSetOp(Set<ByteArrayWrapper> resultSet,
+      Set<ByteArrayWrapper> nextSet);
+
-  protected abstract Set<ByteArrayWrapper> setOp(Set<ByteArrayWrapper> firstSet,
-      List<Set<ByteArrayWrapper>> setList);

MOV31 INS29 INS39 UPD42 UPD74 UPD42 MOV60 INS70 MOV25 INS65 MOV74 UPD42 MOV74 INS42 MOV32 INS74 INS74 MOV59 MOV32 INS8 UPD43 MOV43 INS43 MOV43 MOV74 MOV44 INS42 INS8 MOV32 INS66 INS34 MOV43 MOV43 UPD42 INS32 INS43 MOV43 UPD42 INS60 INS60 INS60 INS50 MOV41 INS41 UPD42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 MOV60 MOV25 INS41 INS41 MOV37 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 MOV43 INS59 INS43 INS59 INS39 INS59 INS32 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS21 INS10 INS49 INS53 INS32 UPD42 INS42 INS42 INS34 INS42 UPD42 INS32 MOV32 MOV32 INS42 INS42 INS42 INS32 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 MOV32 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS7 INS42 INS7 INS42 MOV7 INS14 UPD42 INS42 MOV42 MOV42 UPD42 MOV42 UPD42 UPD42 MOV42 MOV42 UPD42 MOV42 INS10 INS42 INS42 UPD42 INS42 INS32 INS42 INS32 UPD42 INS43 INS27 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 INS42 INS42 UPD42 MOV42 INS45 INS32 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL39 DEL85 DEL5 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL34 DEL34 DEL16 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL59 DEL60 DEL42 DEL7 DEL32 DEL14 DEL43 DEL42 DEL59 DEL42 DEL45 DEL45 DEL42 DEL33 DEL27 DEL43 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL32 DEL42 DEL32 DEL21 DEL21 DEL8 DEL12 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL41 DEL42 DEL43 DEL42 DEL44 DEL39 DEL85 DEL5 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL43 DEL43 DEL74 DEL52 DEL42 DEL43 DEL42 DEL14 DEL42 DEL42 DEL42 DEL43 DEL42 DEL14 DEL42 DEL33 DEL27 DEL38 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL14 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL34 DEL32 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL60 DEL39 DEL42 DEL42 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL52 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL43 DEL74 DEL14 DEL32 DEL21 DEL8 DEL25 DEL25 DEL8 DEL24 DEL42 DEL42 DEL32 DEL42 DEL32 DEL38 DEL27 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL8 DEL25 DEL42 DEL41 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42
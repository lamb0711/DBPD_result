GEODE-6754: Cleanup LocalRegion warnings, typos, and bug refs (#3580)

Co-authored-by: Mark Hanson <mhanson@pivotal.io>

-import org.apache.geode.distributed.internal.DistributionAdvisor.Profile;
-@SuppressWarnings("deprecation")
-  /** Lock used to prevent multiple concurrent destroy region operations */
+  /**
+   * Lock used to prevent multiple concurrent destroy region operations
+   */
-  /** GuardedBy regionExpiryLock. */
+  /**
+   * GuardedBy regionExpiryLock.
+   */
-  /** GuardedBy regionExpiryLock. */
+  /**
+   * GuardedBy regionExpiryLock.
+   */
-  protected volatile ConcurrentMap subregions;
+  private final ConcurrentMap subregions;
-  private volatile boolean initialized; // added for bug 30223
+  private volatile boolean initialized;
-  /** Used for accessing region data on disk */
+  /**
+   * Used for accessing region data on disk
+   */
-  private static final ThreadLocal<LocalRegion> initializingRegion = new ThreadLocal<LocalRegion>();
+  private static final ThreadLocal<LocalRegion> initializingRegion = new ThreadLocal<>();
-  private static String calcFullPath(String regionName, LocalRegion parentRegion) {
-    StringBuilder buf = null;
+  private static String calcFullPath(String regionName, Region parentRegion) {
+    StringBuilder buf;
-        new DefaultEntryEventFactory(), (poolName) -> (PoolImpl) PoolManager.find(poolName));
+        new DefaultEntryEventFactory(), poolName -> (PoolImpl) PoolManager.find(poolName));
-    // Initialized here (and defers to parent) to fix GEODE-128
-    // prevent internal regions from participating in a TX, bug 38709
+    // prevent internal regions from participating in a TX
-  /** returns the regions version-vector */
+  /**
+   * returns the regions version-vector
+   */
-  /** returns object used to guard the size() operation during tombstone removal */
+  /**
+   * returns object used to guard the size() operation during tombstone removal
+   */
-    } else {
-      return fullPath; // avoids creating another sync object - could be anything unique to
-      // this region
+    return fullPath; // avoids creating another sync object - could be anything unique to
+    // this region
-  /** initializes a new version vector for this region */
+  /**
+   * initializes a new version vector for this region
+   */
-    if (entry != null && entry instanceof EntrySnapshot) {
+    if (entry instanceof EntrySnapshot) {
-    } else if (entry != null && entry instanceof NonTXEntry) {
+    } else if (entry instanceof NonTXEntry) {
-    ImageState is = getImageState();
-    Iterator iter = is.getDestroyedEntries();
-    while (iter.hasNext()) {
-      Object key = iter.next();
+    ImageState imageState = getImageState();
+    Iterator iterator = imageState.getDestroyedEntries();
+    while (iterator.hasNext()) {
+      Object key = iterator.next();
-      entries.removeIfDestroyed(key); // fixes bug 41957
+      entries.removeIfDestroyed(key);
-  /** Returns true if the ExpiryTask is currently allowed to expire. */
+  /**
+   * Returns true if the ExpiryTask is currently allowed to expire.
+   */
-    } else {
-      return cache.getInternalDistributedSystem().getDistributedMember();
+    return cache.getInternalDistributedSystem().getDistributedMember();
-  public Region createSubregion(String subregionName, RegionAttributes attrs,
+  public Region createSubregion(String subregionName, RegionAttributes regionAttributes,
-    RegionAttributes regionAttributes = attrs;
-    // TODO: attrs is reassigned but never used
-    attrs = cache.invokeRegionBefore(this, subregionName, attrs, internalRegionArgs);
+    cache.invokeRegionBefore(this, subregionName, regionAttributes, internalRegionArgs);
-      if (getDestroyLock)
+      if (getDestroyLock) {
-      LocalRegion existing = null;
+      }
+      LocalRegion existing;
-              cache.regionReinitialized(newRegion); // fix for bug 33534
+              cache.regionReinitialized(newRegion);
-          } // endif: existing == null
-        } // end synchronization
+          }
+        }
-      // Fix for bug 42127 - moved to outside of the destroy lock.
-        // fix for bug 32570
-    // Fix for 42448 - Only make create with null a local invalidate for
+    // Only make create with null a local invalidate for
-    } else {
-      if (!getDataView().isDeferredStats()) {
-        getCachePerfStats().endPut(startPut, false);
-      }
+    }
+    if (!getDataView().isDeferredStats()) {
+      getCachePerfStats().endPut(startPut, false);
-    } else {
-      return handleNotAvailable(event.getOldValue());
+    return handleNotAvailable(event.getOldValue());
-        // defer the lruUpdateCallback to prevent a deadlock (see bug 51121).
+        // defer the lruUpdateCallback to prevent a deadlock
-          synchronized (regionEntry) { // bug #51059 value & version must be obtained atomically
+          synchronized (regionEntry) {
+            // value & version must be obtained atomically
-        clientEvent, returnTombstones, opScopeIsLocal, false /* see GEODE-1291 */);
+        clientEvent, returnTombstones, opScopeIsLocal, false);
-          || (!returnTombstones && value == Token.TOMBSTONE);
-      // Note: if the value was Token.DESTROYED then getDeserialized
-      // returns null so we don't need the following in the above expression:
-      // || (isRegInterestInProgress() && Token.isDestroyed(value))
-      // because (value == null) will be true in this case.
+          || !returnTombstones && value == Token.TOMBSTONE;
+      // Note: if the value was Token.DESTROYED then getDeserialized returns null
-        // to fix bug 51509 raise the precedence of opScopeIsLocal
-        // if scope is local and there is no loader, then
-        // don't go further to try and get value
+        // raise the precedence of opScopeIsLocal if scope is local and there is no loader,
+        // then don't go further to try and get value
-            && ((getScope().isDistributed()) || hasServerProxy() || basicGetLoader() != null)) {
+            && (getScope().isDistributed() || hasServerProxy() || basicGetLoader() != null)) {
-        } else { // local scope with no loader, still might need to update stats
+        } else {
+          // local scope with no loader, still might need to update stats
-            // fix for bug 43023
-    } else {
-      return o;
+    return o;
-    final EntryEventImpl event = entryEventFactory.create(this, Operation.UPDATE, key, value,
-        aCallbackArgument, false, getMyId());
+    final EntryEventImpl event =
+        entryEventFactory.create(this, Operation.UPDATE, key, value,
+            aCallbackArgument, false, getMyId());
-      if (!eventReturned)
+      if (!eventReturned) {
+      }
-        if (extractDelta && ((org.apache.geode.Delta) value).hasDelta()) {
+        if (extractDelta && ((Delta) value).hasDelta()) {
-            ((org.apache.geode.Delta) value).toDelta(hdos);
+            ((Delta) value).toDelta(hdos);
-            throw new DeltaSerializationException(
-                "Caught exception while sending delta",
-                e);
+            throw new DeltaSerializationException("Caught exception while sending delta", e);
-  @SuppressWarnings("unchecked")
-  /** internally we often need to get an entry whether it is a tombstone or not */
+  /**
+   * internally we often need to get an entry whether it is a tombstone or not
+   */
-   * Just like getEntry but also updates the stats that get would have depending on a flag. See bug
-   * 42410. Also skips discovering JTA
+   * Just like getEntry but also updates the stats that get would have depending on a flag. Also
+   * skips discovering JTA
-    } else {
-      return getDataView().getEntry(getKeyInfo(key), this, false);
+    return getDataView().getEntry(getKeyInfo(key), this, false);
-  /** a fast estimate of total number of entries locally in the region */
+  /**
+   * a fast estimate of total number of entries locally in the region
+   */
-  /** returns true if this region has been destroyed */
+  /**
+   * returns true if this region has been destroyed
+   */
-      return true; // for bug 42328
+      return true;
-  /** a variant of subregions() that does not perform a readiness check */
+  /**
+   * a variant of subregions() that does not perform a readiness check
+   */
-  /** Returns set of entries without performing validation checks. */
+  /**
+   * Returns set of entries without performing validation checks.
+   */
-    } else {
-      try {
-        Entry entry = getDataView().getEntry(getKeyInfo(key), this, true);
-        return entry != null && entry.getValue() == Token.TOMBSTONE;
-      } catch (EntryDestroyedException ignore) {
-        return true;
-      }
+    }
+    try {
+      Entry entry = getDataView().getEntry(getKeyInfo(key), this, true);
+      return entry != null && entry.getValue() == Token.TOMBSTONE;
+    } catch (EntryDestroyedException ignore) {
+      return true;
-      // fix for bug #40871 - concurrent RI causes containsKey for destroyed entry
-      // to return true
+      // concurrent RI causes containsKey for destroyed entry to return true
-        // No need to to check CachedDeserializable because of Bruce's fix in r30960 for bug 42162.
-        // See bug 42732.
-        // this works because INVALID and LOCAL_INVALID will never be faulted out of mem
-        // If val is NOT_AVAILABLE that means we have a valid value on disk.
+        // No need to to check CachedDeserializable because INVALID and LOCAL_INVALID will never be
+        // faulted out of mem If val is NOT_AVAILABLE that means we have a valid value on disk.
-    // to fix bug 35134 allow attribute access on closed regions
+    // allow attribute access on closed regions
-    assert buckets == null : "unexpected buckets " + buckets + " for region " + toString();
+    assert buckets == null : "unexpected buckets " + buckets + " for region " + this;
-   *
-      } else if (!dp.withPersistence() && !isOverflowEnabled()) {
+      }
+      if (!dp.withPersistence() && !isOverflowEnabled()) {
-        rescheduleEntryExpiryTasks(); // called after gii to fix bug 35214
+        rescheduleEntryExpiryTasks();
-
-        // Refer bug #44119
-    Set<Index> indexes = new HashSet<Index>();
+    Set<Index> indexes = new HashSet<>();
-      initLevel = LocalRegion.setThreadInitLevelRequirement(ANY_INIT);
+      initLevel = setThreadInitLevelRequirement(ANY_INIT);
-      LocalRegion.setThreadInitLevelRequirement(initLevel);
+      setThreadInitLevelRequirement(initLevel);
-      // due to bug #52096, the pr index populate flags were not being set
+      // the pr index populate flags were not being set
-    if (latch == null)
+    if (latch == null) {
+    }
-    // do the cacheWriter beforeRegionDestroy first to fix bug 47736
+    // do the cacheWriter beforeRegionDestroy first
-        // I don't think this should ever happens: bulletproofing for bug 39454
-          logger.warn("recursiveDestroyRegion: problem in cacheWriteBeforeRegionDestroy",
-              e);
+          logger.warn("recursiveDestroyRegion: problem in cacheWriteBeforeRegionDestroy", e);
-          LocalRegion.setThreadInitLevelRequirement(LocalRegion.BEFORE_INITIAL_IMAGE);
+          setThreadInitLevelRequirement(BEFORE_INITIAL_IMAGE);
-            LocalRegion.setThreadInitLevelRequirement(LocalRegion.AFTER_INITIAL_IMAGE);
+            setThreadInitLevelRequirement(AFTER_INITIAL_IMAGE);
-          // I don't think this should ever happen: bulletproofing for bug 39454
-        itr.remove(); // remove from this subregion map;
+        // remove from this subregion map;
+        itr.remove();
-      } // for
+      }
-        // I don't think this should ever happens: bulletproofing for bug 39454
-      // after isDestroyed is set to true call removeResourceListener to fix bug 49555
+      // after isDestroyed is set to true call removeResourceListener
-      // Destroy cqs created aganist this Region in a server cache.
-      // fix for bug #47061
+      // Destroy cqs created against this Region in a server cache.
-   *
-        // bug #47716 - do not put an invalid entry into the cache if there's
+        // do not put an invalid entry into the cache if there's
-        // set the event id so that we can progagate
-        // the value to the server
+        // set the event id so that we can propagate the value to the server
-              return null; // tombstones are destroyed entries
+              // tombstones are destroyed entries
+              return null;
-  @SuppressWarnings({"rawtypes", "unchecked"})
-  /** @return true if this was a client region; false if not */
+  /**
+   * @return true if this was a client region; false if not
+   */
-    } else {
-      return false;
+    return false;
-        // bug #42296, serverProxy returns null when cache is closing
+        // serverProxy returns null when cache is closing
-            } else if (!requireOldValue) {
+            }
+            if (!requireOldValue) {
-      if (!keyConstraint.isInstance(key))
+      if (!keyConstraint.isInstance(key)) {
+      }
-    // of this for us. See bug 32394.
+    // of this for us.
-  /** a boolean for issuing a client/server configuration mismatch message */
+  /**
+   * a boolean for issuing a client/server configuration mismatch message
+   */
-              if (type != null && type instanceof String) {
+              if (type instanceof String) {
-  /** regions track the number of tombstones their map holds for size calculations */
+  /**
+   * regions track the number of tombstones their map holds for size calculations
+   */
-    // Fix for 45204 - don't include the tombstones in
-    // any of our entry count stats.
+    // don't include the tombstones in any of our entry count stats
-    if (eventID != null) { // bug #50683 - old members might not send an eventID
+    if (eventID != null) {
+      // old members might not send an eventID
-   * @param eventID the ID of the event (see bug #50683)
+   * @param eventID the ID of the event
-      if (fp != null || routing != null) { // null check - fix for bug #45614
+      if (fp != null || routing != null) {
-  /** local regions do not perform versioning */
+  /**
+   * local regions do not perform versioning
+   */
-    } else {
-      return getConcurrencyChecksEnabled()
-          && (entry.getVersionStamp().hasValidVersion() || getDataPolicy().withReplication());
+    return getConcurrencyChecksEnabled()
+        && (entry.getVersionStamp().hasValidVersion() || getDataPolicy().withReplication());
-   *
-   *
-    } else {
-      return txr.getEntryKeys();
+    return txr.getEntryKeys();
-   *
-   *
-   * in the VM. This is different from getValueonDisk in that it checks for a value both in asynch
-   * buffers ( subject to asynch mode enabled) as well as Disk
+   * in the VM. This is different from getValueonDisk in that it checks for a value both in async
+   * buffers ( subject to async mode enabled) as well as Disk
-   *
-   *
-    DataOutputStream out = new DataOutputStream(outputStream);
-    try {
+    try (DataOutputStream out = new DataOutputStream(outputStream)) {
-            // fix for bug 33311
-    } finally {
-      out.close();
-    if (getAttributes().getDataPolicy().withReplication() // fix for bug 36185
-        && !getAttributes().getScope().isLocal()) { // fix for bug 37692
+    if (getAttributes().getDataPolicy().withReplication()
+        && !getAttributes().getScope().isLocal()) {
-      // Checking for the Dunit test(testRegisterInterst_Destroy_Concurrent) flag
+      // Checking for the Dunit test(testRegisterInterest_Destroy_Concurrent) flag
-          Pattern.compile(regex); // TODO: result of Pattern.compile is ignored
+          Pattern.compile(regex);
-    } else {
-      throw new UnsupportedOperationException(
-          "Interest unregistration requires a pool.");
+    throw new UnsupportedOperationException(
+        "Interest unregistration requires a pool.");
-        for (Iterator it = keyList.iterator(); it.hasNext();) {
-          Object entryKey = it.next();
+        for (Object entryKey : keyList) {
-            || (allowTombstones && containsTombstone(interestArg))) {
+            || allowTombstones && containsTombstone(interestArg)) {
-    } else {
-      throw new UnsupportedOperationException(
-          "Interest list retrieval requires a pool.");
+    throw new UnsupportedOperationException(
+        "Interest list retrieval requires a pool.");
-    } else {
-      throw new UnsupportedOperationException(
-          "Server keySet requires a pool.");
+    throw new UnsupportedOperationException(
+        "Server keySet requires a pool.");
-    } else {
-      throw new UnsupportedOperationException(
-          "Server keySet requires a pool.");
+    throw new UnsupportedOperationException(
+        "Server keySet requires a pool.");
-    } else {
-      throw new UnsupportedOperationException(
-          "sizeOnServer requires a pool.");
+    throw new UnsupportedOperationException(
+        "sizeOnServer requires a pool.");
-    } else {
-      throw new UnsupportedOperationException(
-          "isEmptyOnServer requires a pool.");
+    throw new UnsupportedOperationException(
+        "isEmptyOnServer requires a pool.");
-        // ignore to fix bug 35534
+        // ignore
-    for (Iterator it = entrySet(false).iterator(); it.hasNext();) {
-      Region.Entry entry = (Region.Entry) it.next();
+    for (Object o : entrySet(false)) {
+      Entry entry = (Entry) o;
-        // ignore to fix bug 35534
+        // ignore
-    } catch (ClassNotFoundException cnfe) {
+    } catch (ClassNotFoundException e) {
-          String.format("Class %s not found in classpath.", key), cnfe);
+          String.format("Class %s not found in classpath.", key), e);
-        // ignore to fix bug 35534
+        // ignore
-    throw new InternalGemFireError(
-        "not yet supported");
+    throw new InternalGemFireError("not yet supported");
-      // int numberOfResults = keysList.size();
-            } else {
-              if (logger.isDebugEnabled()) {
-                logger.debug("refreshEntries key={} value={} version={}", currentKey, entry, tag);
-              }
-              if (tag == null) { // no version checks
-                localDestroyNoCallbacks(currentKey);
-              }
+            }
+            if (logger.isDebugEnabled()) {
+              logger.debug("refreshEntries key={} value={} version={}", currentKey, entry, tag);
+            }
+            if (tag == null) { // no version checks
+              localDestroyNoCallbacks(currentKey);
-        if (key instanceof String && key.equals("ALL_KEYS"))
+        if (key instanceof String && key.equals("ALL_KEYS")) {
-        else if (key instanceof List)
+        } else if (key instanceof List) {
-        else
+        } else {
+        }
-  /** must be holding destroy lock */
+  /**
+   * must be holding destroy lock
+   */
-  /** must be holding destroy lock */
+  /**
+   * must be holding destroy lock
+   */
-  /** must be holding destroy lock */
+  /**
+   * must be holding destroy lock
+   */
-    DataInputStream in = new DataInputStream(inputStream);
-    try {
+    try (DataInputStream in = new DataInputStream(inputStream)) {
-    } finally {
-      in.close();
-   *
-  /** wait on the initialization Latch based on thread requirements */
+  /**
+   * wait on the initialization Latch based on thread requirements
+   */
-  /** return null if not found */
+  /**
+   * return null if not found
+   */
-    basicInvalidate(event, isInitialized()/* for bug 35214 */);
+    basicInvalidate(event, isInitialized());
-  public void recordRecoveredVersonHolder(VersionSource member, RegionVersionHolder versionHolder,
+  public void recordRecoveredVersionHolder(VersionSource member, RegionVersionHolder versionHolder,
-        region.recordRecoveredVersonHolder(member, versionHolder, latestOplog);
+        region.recordRecoveredVersionHolder(member, versionHolder, latestOplog);
-      return ((DistributedRegion) this).getBestIterator(includeValues);
+      return getBestIterator(includeValues);
-   *
-      // Bug 40842: clearing index of the old value performed in AbstractRegionMap
+      // clearing index of the old value performed in AbstractRegionMap
-   * Allows null as new value to accomodate create with a null value. Assumes all key, value, and
+   * Allows null as new value to accommodate create with a null value. Assumes all key, value, and
-   *
-    // Fix for 47507 - make sure we throw an exception if we skip the TX put because
-    // the region is cleared (due to a destroy).
+    // make sure we throw an exception if we skip the TX put because
+    // the region is cleared (due to a destroy)
-    final EntryEventImpl event = entryEventFactory.create(this, Operation.CREATE, key, value,
-        theCallbackArg, false, client.getDistributedMember(),
-        true, eventId);
+    final EntryEventImpl event =
+        entryEventFactory.create(this, Operation.CREATE, key, value,
+            theCallbackArg, false, client.getDistributedMember(),
+            true, eventId);
-      // Fix for 42448 - Only make create with null a local invalidate for
+      // Only make create with null a local invalidate for
-            // bug #45520 - we must throw this for the CacheClientUpdater
+            // we must throw this for the CacheClientUpdater
-            // bug #45520 - we must throw an exception for CacheClientUpdater
+            // we must throw an exception for CacheClientUpdater
-   *        {@link java.util.Map#clear} supports no parameters.
+   *        {@link Map#clear} supports no parameters.
-    final EntryEventImpl event = entryEventFactory.create(this, Operation.DESTROY, key, null,
-        theCallbackArg, false, memberId.getDistributedMember(), true, clientEvent.getEventId());
+    final EntryEventImpl event =
+        entryEventFactory.create(this, Operation.DESTROY, key, null,
+            theCallbackArg, false, memberId.getDistributedMember(), true, clientEvent.getEventId());
-    final EntryEventImpl event = entryEventFactory.create(this, Operation.INVALIDATE, key, null,
-        theCallbackArg, false, memberId.getDistributedMember(), true, clientEvent.getEventId());
+    final EntryEventImpl event =
+        entryEventFactory.create(this, Operation.INVALIDATE, key, null,
+            theCallbackArg, false, memberId.getDistributedMember(), true, clientEvent.getEventId());
-   *
-      // #45603: trigger a background eviction since we're above the the critical
-      // threshold
+      // trigger a background eviction since we're above the the critical threshold
-    } else {
-      if (DistTXState.internalBeforeNonTXBasicPut != null) {
-        DistTXState.internalBeforeNonTXBasicPut.run();
-      }
-
-      return getRegionMap().basicPut(event, lastModified, ifNew, false, null, false, false);
+    if (DistTXState.internalBeforeNonTXBasicPut != null) {
+      DistTXState.internalBeforeNonTXBasicPut.run();
+    }
+
+    return getRegionMap().basicPut(event, lastModified, ifNew, false, null, false, false);
-    final boolean lruRecentUse = event.isNetSearch() || event.isLoad(); // fix for bug 31102
+    final boolean lruRecentUse = event.isNetSearch() || event.isLoad();
-        // fix for #46662: skip wan notification during import newwan moves notification to here
+        // skip wan notification during import newwan moves notification to here
-        // bug #45520 we should either have the lock on the region entry
+        // we should either have the lock on the region entry
-    // bug #45520 - do not send CQ events to clients out of order
+    // do not send CQ events to clients out of order
-
-    // We used to dispatch listener events here which is moved to part2 to be in RE lock #45520.
-   *
-    // #Bugfix 37518: In case of localOperations no need to notify clients.
+    // In case of localOperations no need to notify clients.
-        boolean cancelledByCacheWriterException = false; // see bug 47736
+        boolean cancelledByCacheWriterException = false;
-            // I don't think this should ever happens: bulletproofing for bug 39454
-   * @since GemFire 5.0
-   *
+   * @since GemFire 5.0
-      // Bug 49449: When client retried and returned with hasSeenEvent for both LR and DR, the
-      // server should still
+      // When client retried and returned with hasSeenEvent for both LR and DR,
+      // the server should still
-
-    try { // make sure unlockGII is called for bug 40001
+    try {
+      // make sure unlockGII is called
-   * Return true if dae was caused by a RegionDestroyedException. This was added for bug 39603.
+   * Return true if dae was caused by a RegionDestroyedException.
-    // Fix for bug#36963
-          // ignore subregions that have been destroyed to fix bug 33276
+          // ignore subregions that have been destroyed
-  /** @return true if initialization is complete */
+  /**
+   * @return true if initialization is complete
+   */
-   * @return true if event state has been transfered to this region from another cache
+   * @return true if event state has been transferred to this region from another cache
-    // mark as destroyed fixes 49555.
-    // after isDestroyed is set to true call removeResourceListener to fix bug 49555
+    // after isDestroyed is set to true call removeResourceListener
-    // fixes bug 41333
-        // This was needed to fix bug 30937
-    // bugfix for bug#34883
-   *
-      // fix for bug 31102
-  /** The listener is not closed until after the afterRegionDestroy event */
+  /**
+   * The listener is not closed until after the afterRegionDestroy event
+   */
-  /** This is only done when the cache is closed. */
+  /**
+   * This is only done when the cache is closed.
+   */
-          "Region is being destroyed. Waiting for paralle queue to drain.",
+          "Region is being destroyed. Waiting for parallel queue to drain.",
-   * Returns true if this region's config indicates that it will use a disk store. Added for bug
-   * 42055.
+   * Returns true if this region's config indicates that it will use a disk store.
-      } else if (useDefaultDiskStore()) {
+      }
+      if (useDefaultDiskStore()) {
-      } else {
-        // backwards compat mode
-        DiskStoreFactory diskStoreFactory = getGemFireCache().createDiskStoreFactory();
-        diskStoreFactory.setDiskDirsAndSizes(getDiskDirs(), getDiskDirSizes());
-        DiskWriteAttributes dwa = getDiskWriteAttributes();
-        diskStoreFactory.setAutoCompact(dwa.isRollOplogs());
-        diskStoreFactory.setMaxOplogSize(dwa.getMaxOplogSize());
-        diskStoreFactory.setTimeInterval(dwa.getTimeInterval());
-
-        if (dwa.getBytesThreshold() > 0) {
-          diskStoreFactory.setQueueSize(1);
-        } else {
-          diskStoreFactory.setQueueSize(0);
-        }
-
-        DiskStoreFactoryImpl diskStoreFactoryImpl = (DiskStoreFactoryImpl) diskStoreFactory;
-        return diskStoreFactoryImpl.createOwnedByRegion(getFullPath().replace('/', '_'),
-            this instanceof PartitionedRegion, internalRegionArgs);
+      // backwards compat mode
+      DiskStoreFactory diskStoreFactory = getGemFireCache().createDiskStoreFactory();
+      diskStoreFactory.setDiskDirsAndSizes(getDiskDirs(), getDiskDirSizes());
+      DiskWriteAttributes dwa = getDiskWriteAttributes();
+      diskStoreFactory.setAutoCompact(dwa.isRollOplogs());
+      diskStoreFactory.setMaxOplogSize(dwa.getMaxOplogSize());
+      diskStoreFactory.setTimeInterval(dwa.getTimeInterval());
+
+      if (dwa.getBytesThreshold() > 0) {
+        diskStoreFactory.setQueueSize(1);
+      } else {
+        diskStoreFactory.setQueueSize(0);
+      }
+
+      DiskStoreFactoryImpl diskStoreFactoryImpl = (DiskStoreFactoryImpl) diskStoreFactory;
+      return diskStoreFactoryImpl.createOwnedByRegion(getFullPath().replace('/', '_'),
+          this instanceof PartitionedRegion, internalRegionArgs);
-   *
-  /**
-   * Added to fix bug 31204
-   */
-      return; // don't schedule expiration until region is initialized (bug
+      // don't schedule expiration until region is initialized
+      return;
-      ExpirationAttributes idleAttributes = null;
-          // Ignore - #42273
-        } catch (EntryNotFoundException ignore) {
-          // Ignore - #51933
-        } catch (EntryDestroyedException ignore) {
-          // Ignore - #51933
+          // Ignore
+        } catch (EntryNotFoundException | EntryDestroyedException ignore) {
+          // Ignore
+      ExpirationAttributes idleAttributes = null;
-          // Ignore - #42273
-        } catch (EntryNotFoundException ignore) {
-          // Ignore - #51933
-        } catch (EntryDestroyedException ignore) {
-          // Ignore - #51933
+          // Ignore
+        } catch (EntryNotFoundException | EntryDestroyedException ignore) {
+          // Ignore
-      } else if ((ttlDisabled || ttlAttributes.equals(regionAttributes.getEntryTimeToLive()))
+      }
+      if ((ttlDisabled || ttlAttributes.equals(regionAttributes.getEntryTimeToLive()))
-      } else {
-        return new CustomEntryExpiryTask(this, regionEntry, ttlAttributes, idleAttributes);
+      return new CustomEntryExpiryTask(this, regionEntry, ttlAttributes, idleAttributes);
-    } else if (isEntryExpiryPossible()) {
-      return new EntryExpiryTask(this, regionEntry);
-    } else {
-      return null;
+    if (isEntryExpiryPossible()) {
+      return new EntryExpiryTask(this, regionEntry);
+    }
+    return null;
-      // don't schedule expiration until region is initialized (#35214)
+      // don't schedule expiration until region is initialized
-            // to fix bug 44418 see if the new tasks expiration would be earlier than
-            // the scheduled task.
+            // see if the new tasks expiration would be earlier than the scheduled task.
-    if (entryExpiryTasks == null)
+    if (entryExpiryTasks == null) {
-    if (entryExpiryTasks.isEmpty())
+    }
+    if (entryExpiryTasks.isEmpty()) {
+    }
-    } else {
-      return false;
+    return false;
-  /** doesn't throw RegionDestroyedException, used by CacheDistributionAdvisor */
+  /**
+   * doesn't throw RegionDestroyedException, used by CacheDistributionAdvisor
+   */
-    } else {
-      return null;
+    return null;
-    } else {
-      return null;
+    return null;
-      // fixes bug 45541
-    } else {
-      try {
-        if (!ignoreJTA && cache.getJTATransactionManager() != null) {
+    }
+    try {
+      if (!ignoreJTA && cache.getJTATransactionManager() != null) {
-          Transaction jtaTransaction = cache.getJTATransactionManager().getTransaction();
-          if (jtaTransaction == null
-              || jtaTransaction.getStatus() == Status.STATUS_NO_TRANSACTION) {
-            return null;
-          }
-          if (isTransactionPaused() || isJTAPaused()) {
-            // Do not bootstrap JTA again, if the transaction has been paused.
-            return null;
-          }
-          txState = cache.getTXMgr().beginJTA();
-          jtaTransaction.registerSynchronization(txState);
-          return txState;
-        } else {
+        Transaction jtaTransaction = cache.getJTATransactionManager().getTransaction();
+        if (jtaTransaction == null
+            || jtaTransaction.getStatus() == Status.STATUS_NO_TRANSACTION) {
-      } catch (SystemException se) {
-        // this can be thrown when the system is shutting down (see bug #39728)
-        stopper.checkCancelInProgress(se);
-        jtaEnlistmentFailureCleanup(txState, se);
-        return null;
-      } catch (RollbackException | IllegalStateException re) {
-        jtaEnlistmentFailureCleanup(txState, re);
-        return null;
+        if (isTransactionPaused() || isJTAPaused()) {
+          // Do not bootstrap JTA again, if the transaction has been paused.
+          return null;
+        }
+        txState = cache.getTXMgr().beginJTA();
+        jtaTransaction.registerSynchronization(txState);
+        return txState;
+      return null;
+    } catch (SystemException se) {
+      // this can be thrown when the system is shutting down
+      stopper.checkCancelInProgress(se);
+      jtaEnlistmentFailureCleanup(txState, se);
+      return null;
+    } catch (RollbackException | IllegalStateException re) {
+      jtaEnlistmentFailureCleanup(txState, re);
+      return null;
-        String.format("Failed enlistement with transaction %s",
+        String.format("Failed enlistment with transaction %s",
-  /** Does not throw RegionDestroyedException even if destroyed */
+  /**
+   * Does not throw RegionDestroyedException even if destroyed
+   */
-          // ignore for bug 37105
+          // ignore
-      // bug #40871 - test sees wrong size for region during RI
-   * will not take distributedLock. The clear operation will also clear the local tranxnl entries .
-   * The clear operation will have immediate committed state.
+   * will not take distributedLock. The clear operation will also clear the local transactional
+   * entries. The clear operation will have immediate committed state.
-          // TODO: never throw an annonymous class (and outer-class is not serializable)
+          // TODO: never throw an anonymous class (and outer-class is not serializable)
-          // in 8.0 we added transfer of tombstones with RI/getAll results for bug #40791
+          // in 8.0 we added transfer of tombstones with RI/getAll results
-              // bug #47716 - don't update if it's already here & invalid
+              // don't update if it's already here & invalid
-    Map.Entry mapEntry;
-      mapEntry = (Map.Entry) theEntry;
+      Map.Entry mapEntry = (Map.Entry) theEntry;
-    final EntryEventImpl event = entryEventFactory.create(this, Operation.PUTALL_CREATE, null,
-        null, callbackArg, false,
-        memberId.getDistributedMember(), !skipCallbacks, eventId);
+    final EntryEventImpl event =
+        entryEventFactory.create(this, Operation.PUTALL_CREATE, null,
+            null, callbackArg, false,
+            memberId.getDistributedMember(), !skipCallbacks, eventId);
-    final EntryEventImpl event = entryEventFactory.create(this, Operation.REMOVEALL_DESTROY, null,
-        null, callbackArg, false,
-        memberId.getDistributedMember(), true, eventId);
+    final EntryEventImpl event =
+        entryEventFactory.create(this, Operation.REMOVEALL_DESTROY, null,
+            null, callbackArg, false,
+            memberId.getDistributedMember(), true, eventId);
-        Runnable task = new Runnable() {
-          @Override
-          public void run() {
-            int offset = 0;
-            VersionTagHolder tagHolder = new VersionTagHolder();
-            while (iterator.hasNext()) {
-              stopper.checkCancelInProgress(null);
-              Map.Entry mapEntry = (Map.Entry) iterator.next();
-              Object key = mapEntry.getKey();
-              VersionTag versionTag = null;
-              tagHolder.setVersionTag(null);
-              final Object value;
-              boolean overwritten = false;
-              if (isVersionedResults) {
-                versionTag = ((VersionedObjectList.Entry) mapEntry).getVersionTag();
-                value = map.get(key);
-                if (isDebugEnabled) {
-                  logger.debug("putAll key {} -> {} version={}", key, value, versionTag);
-                }
-                if (versionTag == null && serverIsVersioned && getConcurrencyChecksEnabled()
-                    && getDataPolicy().withStorage()) {
-                  // server was unable to determine the version for this operation.
-                  // I'm not sure this can still happen as described below on a pr.
-                  // But it can happen on the server if NORMAL or PRELOADED. See bug 51644.
-                  // This can happen in a PR with redundancy if there is a bucket
-                  // failure or migration during the operation. We destroy the
-                  // entry since we don't know what its state should be (but the server should)
-                  if (isDebugEnabled) {
-                    logger.debug("server returned no version information for {}", key);
-                  }
-                  localDestroyNoCallbacks(key);
-                  // to be consistent we need to fetch the current entry
-                  get(key, event.getCallbackArgument(), false, null);
-                  overwritten = true;
-                }
-              } else {
-                value = mapEntry.getValue();
-                if (isDebugEnabled) {
-                  logger.debug("putAll {} -> {}", key, value);
-                }
+        Runnable task = () -> {
+          int offset = 0;
+          VersionTagHolder tagHolder = new VersionTagHolder();
+          while (iterator.hasNext()) {
+            stopper.checkCancelInProgress(null);
+            Map.Entry mapEntry = (Map.Entry) iterator.next();
+            Object key = mapEntry.getKey();
+            tagHolder.setVersionTag(null);
+            final Object value;
+            boolean overwritten = false;
+            VersionTag versionTag = null;
+            if (isVersionedResults) {
+              versionTag = ((VersionedObjectList.Entry) mapEntry).getVersionTag();
+              value = map.get(key);
+              if (isDebugEnabled) {
+                logger.debug("putAll key {} -> {} version={}", key, value, versionTag);
-              try {
-                if (serverIsVersioned) {
-                  if (isDebugEnabled) {
-                    logger.debug("associating version tag with {} version={}", key, versionTag);
-                  }
-                  // If we have received a version tag from a server, add it to the event
-                  tagHolder.setVersionTag(versionTag);
-                  tagHolder.setFromServer(true);
-                } else if (retryVersions != null && retryVersions.containsKey(key)) {
-                  // If this is a retried event, and we have a version tag for the retry,
-                  // add it to the event.
-                  tagHolder.setVersionTag(retryVersions.get(key));
-                }
-
-                if (!overwritten) {
-                  basicEntryPutAll(key, value, putAllOp, offset, tagHolder);
-                }
-                // now we must check again since the cache may have closed during
-                // distribution (causing this process to not receive and queue the
-                // event for clients
-                stopper.checkCancelInProgress(null);
-                succeeded.addKeyAndVersion(key, tagHolder.getVersionTag());
-              } catch (Exception ex) {
+              if (versionTag == null && serverIsVersioned && getConcurrencyChecksEnabled()
+                  && getDataPolicy().withStorage()) {
+                // server was unable to determine the version for this operation.
+                // I'm not sure this can still happen as described below on a pr.
+                // But it can happen on the server if NORMAL or PRELOADED.
+                // This can happen in a PR with redundancy if there is a bucket
+                // failure or migration during the operation. We destroy the
+                // entry since we don't know what its state should be (but the server should)
-                  logger.debug("PutAll operation encountered exception for key {}", key, ex);
+                  logger.debug("server returned no version information for {}", key);
-                partialKeys.saveFailedKey(key, ex);
+                localDestroyNoCallbacks(key);
+                // to be consistent we need to fetch the current entry
+                get(key, event.getCallbackArgument(), false, null);
+                overwritten = true;
-              offset++;
+            } else {
+              value = mapEntry.getValue();
+              if (isDebugEnabled) {
+                logger.debug("putAll {} -> {}", key, value);
+              }
+            try {
+              if (serverIsVersioned) {
+                if (isDebugEnabled) {
+                  logger.debug("associating version tag with {} version={}", key, versionTag);
+                }
+                // If we have received a version tag from a server, add it to the event
+                tagHolder.setVersionTag(versionTag);
+                tagHolder.setFromServer(true);
+              } else if (retryVersions != null && retryVersions.containsKey(key)) {
+                // If this is a retried event, and we have a version tag for the retry,
+                // add it to the event.
+                tagHolder.setVersionTag(retryVersions.get(key));
+              }
+
+              if (!overwritten) {
+                basicEntryPutAll(key, value, putAllOp, offset, tagHolder);
+              }
+              // now we must check again since the cache may have closed during
+              // distribution (causing this process to not receive and queue the
+              // event for clients
+              stopper.checkCancelInProgress(null);
+              succeeded.addKeyAndVersion(key, tagHolder.getVersionTag());
+            } catch (Exception ex) {
+              if (isDebugEnabled) {
+                logger.debug("PutAll operation encountered exception for key {}", key, ex);
+              }
+              partialKeys.saveFailedKey(key, ex);
+            }
+            offset++;
-          // Bug 51725: Now succeeded contains an order key list, may be missing the version tags.
+          // Now succeeded contains an order key list, may be missing the version tags.
-                // fix for #43589
-        Runnable task = new Runnable() {
-          @Override
-          public void run() {
-            int offset = 0;
-            VersionTagHolder tagHolder = new VersionTagHolder();
-            while (iterator.hasNext()) {
-              stopper.checkCancelInProgress(null);
-              tagHolder.setVersionTag(null);
-              Object key;
-              VersionTag versionTag = null;
-              if (isVersionedResults) {
-                Map.Entry mapEntry = (Map.Entry) iterator.next();
-                key = mapEntry.getKey();
-                versionTag = ((VersionedObjectList.Entry) mapEntry).getVersionTag();
+        Runnable task = () -> {
+          int offset = 0;
+          VersionTagHolder tagHolder = new VersionTagHolder();
+          while (iterator.hasNext()) {
+            stopper.checkCancelInProgress(null);
+            tagHolder.setVersionTag(null);
+            Object key;
+            VersionTag versionTag = null;
+            if (isVersionedResults) {
+              Map.Entry mapEntry = (Map.Entry) iterator.next();
+              key = mapEntry.getKey();
+              versionTag = ((VersionedObjectList.Entry) mapEntry).getVersionTag();
+              if (isDebugEnabled) {
+                logger.debug("removeAll key {} version={}", key, versionTag);
+              }
+              if (versionTag == null) {
-                  logger.debug("removeAll key {} version={}", key, versionTag);
+                  logger.debug(
+                      "removeAll found invalid version tag, which means the entry is not found at server for key={}.",
+                      key);
-                if (versionTag == null) {
-                  if (isDebugEnabled) {
-                    logger.debug(
-                        "removeAll found invalid version tag, which means the entry is not found at server for key={}.",
-                        key);
-                  }
-                  succeeded.addKeyAndVersion(key, null);
-                  continue;
-                }
-                // No need for special handling here in removeAll.
-                // We can just remove this key from the client with versionTag set to null.
-              } else {
-                key = iterator.next();
-                if (isTraceEnabled) {
-                  logger.trace("removeAll {}", key);
-                }
+                succeeded.addKeyAndVersion(key, null);
+                continue;
-
-              try {
-                if (serverIsVersioned) {
-                  if (isDebugEnabled) {
-                    logger.debug("associating version tag with {} version={}", key, versionTag);
-                  }
-                  // If we have received a version tag from a server, add it to the event
-                  tagHolder.setVersionTag(versionTag);
-                  tagHolder.setFromServer(true);
-                } else if (retryVersions != null) {
-                  VersionTag versionTag1 = retryVersions.get(offset);
-                  if (versionTag1 != null) {
-                    // If this is a retried event, and we have a version tag for the retry,
-                    // add it to the event.
-                    tagHolder.setVersionTag(versionTag1);
-                  }
-                }
-
-                basicEntryRemoveAll(key, removeAllOp, offset, tagHolder);
-                // now we must check again since the cache may have closed during
-                // distribution causing this process to not receive and queue the
-                // event for clients
-                stopper.checkCancelInProgress(null);
-                succeeded.addKeyAndVersion(key, tagHolder.getVersionTag());
-              } catch (Exception ex) {
-                partialKeys.saveFailedKey(key, ex);
+              // No need for special handling here in removeAll.
+              // We can just remove this key from the client with versionTag set to null.
+            } else {
+              key = iterator.next();
+              if (isTraceEnabled) {
+                logger.trace("removeAll {}", key);
-              offset++;
+
+            try {
+              if (serverIsVersioned) {
+                if (isDebugEnabled) {
+                  logger.debug("associating version tag with {} version={}", key, versionTag);
+                }
+                // If we have received a version tag from a server, add it to the event
+                tagHolder.setVersionTag(versionTag);
+                tagHolder.setFromServer(true);
+              } else if (retryVersions != null) {
+                VersionTag versionTag1 = retryVersions.get(offset);
+                if (versionTag1 != null) {
+                  // If this is a retried event, and we have a version tag for the retry,
+                  // add it to the event.
+                  tagHolder.setVersionTag(versionTag1);
+                }
+              }
+
+              basicEntryRemoveAll(key, removeAllOp, offset, tagHolder);
+              // now we must check again since the cache may have closed during
+              // distribution causing this process to not receive and queue the
+              // event for clients
+              stopper.checkCancelInProgress(null);
+              succeeded.addKeyAndVersion(key, tagHolder.getVersionTag());
+            } catch (Exception ex) {
+              partialKeys.saveFailedKey(key, ex);
+            }
+            offset++;
-          // Bug 51725: Now succeeded contains an order key list, may be missing the version tags.
+          // Now succeeded contains an order key list, may be missing the version tags.
-                throw partialKeys.getFailure(); // fix for #43589
+                throw partialKeys.getFailure();
-   * bug #46924 - putAll can be partially applied when a clear() occurs, leaving the cache in an
+   * putAll can be partially applied when a clear() occurs, leaving the cache in an
-            logger.debug("RemoveAll encoutered EntryNotFoundException: event={}", event);
+            logger.debug("RemoveAll encountered EntryNotFoundException: event={}", event);
-    final int oldLevel = setThreadInitLevelRequirement(LocalRegion.ANY_INIT);
+    final int oldLevel = setThreadInitLevelRequirement(ANY_INIT);
-      } else {
-        // non-null means this is a subregion under the destroyed region
-        serialForThisRegion = serialNumber;
+      // non-null means this is a subregion under the destroyed region
+      serialForThisRegion = serialNumber;
-   *
-      } else {
-        throw new IllegalStateException(
-            "To call notifyToCompact you must configure the region with <disk-write-attributes allow-force-compaction=true/>");
-    } else {
-      return false;
+      throw new IllegalStateException(
+          "To call notifyToCompact you must configure the region with <disk-write-attributes allow-force-compaction=true/>");
+    return false;
-    } else {
-      return diskDirs;
+    return diskDirs;
-    } else {
-      return diskSizes;
+    return diskSizes;
-  /** visitor over the CacheProfiles to check if the region has a CacheLoader */
+  /**
+   * visitor over the CacheProfiles to check if the region has a CacheLoader
+   */
-      new DistributionAdvisor.ProfileVisitor<Void>() {
-        @Override
-        public boolean visit(DistributionAdvisor advisor, Profile profile, int profileIndex,
-            int numProfiles, Void aggregate) {
-          assert profile instanceof CacheProfile;
-          final CacheProfile prof = (CacheProfile) profile;
+      (advisor, profile, profileIndex, numProfiles, aggregate) -> {
+        assert profile instanceof CacheProfile;
+        final CacheProfile prof = (CacheProfile) profile;
-          // if region in cache is not yet initialized, exclude
-          if (prof.regionInitialized) { // fix for bug 41102
-            // cut the visit short if we find a CacheLoader
-            return !prof.hasCacheLoader;
-          }
-          // continue the visit
-          return true;
+        // if region in cache is not yet initialized, exclude
+        if (prof.regionInitialized) {
+          // cut the visit short if we find a CacheLoader
+          return !prof.hasCacheLoader;
-      };
-
-  /** visitor over the CacheProfiles to check if the region has a CacheWriter */
-  @Immutable
-  private static final DistributionAdvisor.ProfileVisitor<Void> netWriterVisitor =
-      new DistributionAdvisor.ProfileVisitor<Void>() {
-        @Override
-        public boolean visit(DistributionAdvisor advisor, Profile profile, int profileIndex,
-            int numProfiles, Void aggregate) {
-          assert profile instanceof CacheProfile;
-          final CacheProfile prof = (CacheProfile) profile;
-
-          // if region in cache is in recovery
-          if (!prof.inRecovery) {
-            // cut the visit short if we find a CacheWriter
-            return !prof.hasCacheWriter;
-          }
-          // continue the visit
-          return true;
-        }
+        // continue the visit
+        return true;
-        LocalRegion.this, args, filter, null, null, resultSender, execution.isReExecute());
+        this, args, filter, null, null, resultSender, execution.isReExecute());
-              || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
+              || event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap())) {
-              || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
+              || event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap())) {
-  /** test hook - dump the backing map for this region */
+  /**
+   * test hook - dump the backing map for this region
+   */
-    // This check allows NORMAL with local scope to fix bug 44856
+    // This check allows NORMAL with local scope
-      // the functional spec says these data policies do not support concurrent map
-      // operations
+      // the functional spec says these data policies do not support concurrent map operations
-   *
-      } else {
-        if (!getDataView().isDeferredStats()) {
-          getCachePerfStats().endPut(startPut, false);
-        }
-        return null;
+      if (!getDataView().isDeferredStats()) {
+        getCachePerfStats().endPut(startPut, false);
+      }
+      return null;
-      } else {
-        throw rde;
+      throw rde;
-      } else {
-        if (!getDataView().isDeferredStats()) {
-          getCachePerfStats().endPut(startPut, false);
-        }
-        return true;
+      if (!getDataView().isDeferredStats()) {
+        getCachePerfStats().endPut(startPut, false);
+      }
+      return true;
-      } else {
-        if (!getDataView().isDeferredStats()) {
-          getCachePerfStats().endPut(startPut, false);
-        }
-        return event.getOldValue(); // may be null if was invalid
+      if (!getDataView().isDeferredStats()) {
+        getCachePerfStats().endPut(startPut, false);
+      }
+      return event.getOldValue(); // may be null if was invalid
-    final EntryEventImpl event = entryEventFactory.create(this, Operation.PUT_IF_ABSENT, key, null,
-        callbackArg, false, client.getDistributedMember(), true, eventId);
+    final EntryEventImpl event =
+        entryEventFactory.create(this, Operation.PUT_IF_ABSENT, key, null,
+            callbackArg, false, client.getDistributedMember(), true, eventId);
-      // to fix bug 42968 call getRawOldValue instead of getOldValue
-          // fix for 42189, putIfAbsent on server can return null if the
+          // putIfAbsent on server can return null if the
-    final EntryEventImpl event = entryEventFactory.create(this, Operation.REPLACE, key, null,
-        callbackArg, false, client.getDistributedMember(), true, eventId);
+    final EntryEventImpl event =
+        entryEventFactory.create(this, Operation.REPLACE, key, null,
+            callbackArg, false, client.getDistributedMember(), true, eventId);
-    final EntryEventImpl event = entryEventFactory.create(this, Operation.REPLACE, key, null,
-        callbackArg, false, client.getDistributedMember(), true, eventId);
+    final EntryEventImpl event =
+        entryEventFactory.create(this, Operation.REPLACE, key, null,
+            callbackArg, false, client.getDistributedMember(), true, eventId);
-        // to fix bug 42968 call getRawOldValue instead of getOldValue
-      } else {
-        return null;
+      return null;
-    final EntryEventImpl event = entryEventFactory.create(this, Operation.REMOVE, key, null,
-        callbackArg, false, memberId.getDistributedMember(), true, clientEvent.getEventId());
+    final EntryEventImpl event =
+        entryEventFactory.create(this, Operation.REMOVE, key, null,
+            callbackArg, false, memberId.getDistributedMember(), true, clientEvent.getEventId());
-   *
-   *
-   *
-   *
-        } else {
-          regionTTLExpiryTask = null;
+        regionTTLExpiryTask = null;
-        } else {
-          regionIdleExpiryTask = null;
+        regionIdleExpiryTask = null;
-    // release the sync before doing the operation to prevent deadlock caused by r48875
+    // release the sync before doing the operation to prevent deadlock
-  /** Set view of subregions */
+  /**
+   * Set view of subregions
+   */
-          } else {
-            Object element = next(true);
-            if (element != null) {
-              nextElement = element;
-              return true;
-            } else {
-              return false;
-            }
+          Object element = next(true);
+          if (element != null) {
+            nextElement = element;
+            return true;
+          }
+          return false;
-                } else {
-                  throw new NoSuchElementException();
-              } else {
-                currentIterator = (Iterator) queue.remove(0);
-                continue;
+                throw new NoSuchElementException();
+              currentIterator = (Iterator) queue.remove(0);
+              continue;
-      } else {
-        return subregions.size();
+      return subregions.size();
-      for (Iterator iter = iterator(); iter.hasNext();) {
-        temp.add(iter.next());
+      for (Object o : this) {
+        temp.add(o);
-      for (Iterator iter = iterator(); iter.hasNext();) {
-        temp.add(iter.next());
+      for (Object o : this) {
+        temp.add(o);
-        // Make a copy that has its own off-heap refcount so fix bug 48837
+        // Make a copy that has its own off-heap refcount
-    public void release() {
+    void release() {

MOV31 UPD83 UPD83 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 UPD42 MOV8 MOV65 MOV8 MOV8 MOV43 INS42 MOV44 MOV44 MOV44 INS8 MOV8 MOV8 MOV8 MOV8 UPD43 MOV41 INS25 UPD42 MOV25 MOV41 MOV41 MOV21 MOV21 MOV21 INS25 MOV21 MOV21 INS25 INS41 INS25 MOV41 MOV53 MOV53 MOV53 MOV53 MOV53 MOV53 INS70 MOV21 MOV60 MOV60 INS25 MOV25 MOV25 MOV41 MOV25 INS41 INS41 INS41 INS41 MOV25 MOV60 INS25 MOV60 MOV60 MOV60 MOV25 MOV21 MOV60 MOV60 MOV60 MOV25 MOV60 MOV60 MOV25 MOV21 INS54 MOV25 MOV41 MOV60 INS41 MOV41 MOV41 INS86 MOV6 MOV60 MOV21 MOV25 MOV21 MOV21 MOV21 MOV60 INS54 INS51 MOV60 MOV60 MOV25 MOV41 MOV8 UPD66 UPD66 UPD66 UPD66 UPD74 UPD42 UPD66 UPD66 UPD66 MOV62 UPD66 MOV32 MOV8 INS32 UPD66 UPD66 UPD66 INS42 MOV8 UPD66 UPD66 UPD66 UPD66 MOV38 MOV8 MOV27 INS8 MOV8 INS8 UPD66 INS9 MOV27 UPD66 UPD66 UPD66 UPD66 MOV32 MOV8 UPD66 UPD66 INS58 INS44 MOV32 MOV8 UPD66 UPD66 UPD66 INS58 UPD66 UPD66 UPD66 MOV32 MOV8 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV32 MOV60 INS33 INS8 INS8 INS9 UPD66 INS33 INS33 MOV27 MOV8 UPD66 UPD66 UPD66 INS8 MOV8 UPD66 MOV27 INS9 UPD66 INS59 INS59 INS59 INS59 INS59 MOV8 MOV32 INS8 UPD66 MOV8 MOV12 MOV8 INS42 MOV8 UPD9 MOV9 UPD66 INS25 INS70 INS70 MOV62 UPD42 UPD42 UPD42 MOV42 MOV42 MOV52 MOV42 UPD42 MOV42 MOV42 INS52 MOV60 INS25 MOV25 INS41 MOV60 MOV43 MOV59 INS43 INS42 INS8 MOV43 MOV59 INS25 INS25 MOV25 MOV41 INS41 INS41 MOV41 INS60 INS54 MOV21 MOV21 INS25 INS42 INS42 INS42 INS42 INS42 MOV25 MOV25 INS41 MOV25 MOV41 MOV25 MOV21 INS25 INS41 MOV25 INS42 MOV8 INS44 INS52 INS8 INS44 INS52 INS8 UPD42 INS8 INS8 MOV32 MOV8 UPD74 MOV27 INS8 INS8 UPD42 MOV42 UPD43 UPD42 MOV21 INS8 INS8 INS42 MOV27 MOV8 MOV32 MOV8 UPD45 MOV43 INS59 INS8 MOV12 MOV12 MOV12 MOV8 INS42 MOV32 MOV8 UPD27 MOV27 MOV8 INS25 INS33 MOV53 MOV38 MOV8 INS33 MOV62 INS8 INS43 INS42 MOV21 INS43 INS42 MOV21 MOV21 INS21 MOV25 MOV60 MOV60 MOV60 MOV60 MOV60 MOV60 MOV21 MOV25 MOV53 INS42 MOV21 MOV21 UPD45 INS42 MOV11 MOV60 MOV25 MOV60 MOV60 MOV60 MOV25 INS60 MOV21 MOV25 MOV32 MOV38 UPD27 MOV27 MOV8 INS25 INS25 INS21 INS41 UPD42 MOV42 UPD42 MOV42 UPD42 MOV27 UPD27 MOV27 MOV32 MOV32 INS70 UPD43 INS42 UPD42 MOV43 INS59 MOV43 INS27 MOV38 MOV32 MOV27 MOV8 MOV27 MOV8 MOV7 INS9 MOV8 UPD42 MOV42 UPD42 MOV42 MOV38 MOV25 INS25 INS44 INS42 MOV8 INS42 UPD42 INS42 INS86 INS86 MOV27 MOV27 INS27 INS25 INS41 INS27 MOV27 MOV8 MOV25 MOV43 INS42 MOV27 INS84 INS84 MOV8 MOV8 MOV27 MOV27 MOV27 MOV8 INS9 MOV8 MOV32 MOV32 MOV27 UPD42 UPD42 MOV27 INS8 INS43 MOV43 INS43 MOV43 MOV21 MOV21 UPD43 INS25 MOV25 MOV25 MOV25 MOV42 MOV42 MOV60 MOV38 INS42 UPD42 UPD42 MOV27 MOV8 MOV21 INS18 MOV62 UPD45 MOV27 UPD43 INS25 INS42 INS42 MOV8 DEL40 DEL26 DEL42 DEL45 DEL79 DEL42 DEL43 DEL33 DEL8 DEL42 DEL33 DEL27 DEL27 DEL42 DEL33 DEL27 DEL27 DEL25 DEL8 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL32 DEL7 DEL33 DEL8 DEL8 DEL36 DEL36 DEL27 DEL8 DEL21 DEL40 DEL40 DEL42 DEL45 DEL79 DEL42 DEL25 DEL8 DEL25 DEL8 DEL42 DEL32 DEL25 DEL8 DEL42 DEL43 DEL42 DEL42 DEL41 DEL40 DEL40 DEL42 DEL45 DEL45 DEL4 DEL79 DEL9 DEL41 DEL8 DEL25 DEL8 DEL25 DEL8 DEL42 DEL33 DEL27 DEL27 DEL25 DEL8 DEL8 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL8 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL36 DEL8 DEL8 DEL8 DEL8 DEL8 DEL40 DEL40 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL8 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL52 DEL11 DEL36 DEL40 DEL25 DEL8 DEL66 DEL25 DEL25 DEL8 DEL66 DEL65 DEL29 DEL43 DEL42 DEL44 DEL8 DEL12 DEL43 DEL42 DEL44 DEL8 DEL12 DEL8 DEL33 DEL41 DEL8 DEL41 DEL41 DEL9 DEL41 DEL8 DEL33 DEL41 DEL8 DEL33 DEL41 DEL8 DEL33 DEL41 DEL8 DEL25 DEL8 DEL42 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL42 DEL43 DEL42 DEL1 DEL14 DEL59 DEL60 DEL8 DEL54 DEL8 DEL54 DEL8 DEL31 DEL42 DEL43 DEL42 DEL78 DEL83 DEL39 DEL42 DEL31 DEL1 DEL14 DEL40 DEL8 DEL9 DEL41 DEL8 DEL25 DEL8 DEL8 DEL8 DEL40 DEL43 DEL42 DEL43 DEL74 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL31 DEL1 DEL14 DEL66 DEL65 DEL29 DEL42 DEL78 DEL83 DEL83 DEL83 DEL40 DEL43 DEL42 DEL43 DEL74 DEL42 DEL40 DEL43 DEL42 DEL43 DEL74 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL62 DEL6 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL40 DEL38 DEL40 DEL38 DEL41 DEL8 DEL25 DEL8 DEL31 DEL1 DEL14 DEL59 DEL23 DEL42 DEL36 DEL27 DEL36 DEL27 DEL25 DEL8 DEL8 DEL8 DEL9 DEL41 DEL8 DEL25 DEL54 DEL8 DEL33 DEL41 DEL8 DEL25 DEL8 DEL25 DEL42 DEL51 DEL8 DEL9 DEL41 DEL8 DEL25 DEL8 DEL42 DEL18 DEL8 DEL25 DEL8 DEL42 DEL25 DEL8 DEL42 DEL32 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL8 DEL24 DEL42 DEL32 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL8 DEL24 DEL83
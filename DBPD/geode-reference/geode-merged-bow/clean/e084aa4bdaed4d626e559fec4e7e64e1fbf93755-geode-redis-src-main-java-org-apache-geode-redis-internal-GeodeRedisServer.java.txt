GEODE-8130: use a single region for redis Sets and Hashes  (#5120)

* Replaced replicated metaRegion with a partitioned dataRegion.
Currently the dataRegion is used the same way as the metaRegion
except for sets and hashes which store their actual data in it.
* Exception handling now correctly deals with FunctionException
* Disabled a test until GEODE-8127 if fixed.
* Now uses the ByteArrayWrapper as the key on the meta region
and the locks map instead of using a String.
Since a ByteArrayWrapper is used as the key in the data region
this will end up saving memory.

* Found a problem with redis dynamic region management.
Some of the code was executing when we added a new set or hash to
the metaDataRegion. It was only ignoring STRING and HLL.
This caused some extra memory to be used for every redis set/hash.
Now the dynamic region code is only used for lists and sortedSet.

* This commit has some TODO comments of what looks like a bug in
the dynamic region code when a new server is started. It looks
like the new server will not create already existing dynamic regions.
We could test this by starting one server, create a LIST, then
start another server, and then shutdown the first server. Does
the LIST still exist? If we change them not to use dynamic regions
then this issue will go away.
-import org.apache.geode.cache.DataPolicy;
-import org.apache.geode.redis.internal.executor.hash.RedisHash;
-import org.apache.geode.redis.internal.executor.set.RedisSet;
- * {@link GeodeRedisServer#REDIS_META_DATA_REGION} or {@link GeodeRedisServer#STRING_REGION}. The
+ * {@link GeodeRedisServer#REDIS_DATA_REGION} or {@link GeodeRedisServer#STRING_REGION}. The
- * SMEMBERS, SMOVE, SREM, SPOP, SRANDMEMBER, SCAN, SUNION, SUNIONSTORE
+ * SMEMBERS, SMOVE, SREM, SPOP, SRANDMEMBER, SSCAN, SUNION, SUNIONSTORE
-  private RegionProvider regionCache;
+  private RegionProvider regionProvider;
-   * TThe field that defines the name of the {@link Region} which holds non-named hash. The current
-   * value of this field is {@value #HASH_REGION}.
-   */
-  public static final String HASH_REGION = "ReDiS_HASH";
-
-  /**
-   * TThe field that defines the name of the {@link Region} which holds sets. The current value of
-   * this field is {@value #SET_REGION}.
-   */
-  public static final String SET_REGION = "ReDiS_SET";
-
-
-  /**
-   * The field that defines the name of the {@link Region} which holds all of the Redis meta data.
-   * The current value of this field is {@code REDIS_META_DATA_REGION}.
+   * The name of the region that holds data stored in redis.
+   * Currently this is the meta data but at some point the value for a particular
+   * type will be changed to an instance of {@link RedisData}
-  public static final String REDIS_META_DATA_REGION = "ReDiS_MeTa_DaTa";
+  public static final String REDIS_DATA_REGION = "ReDiS_DaTa";
-  public RegionProvider getRegionCache() {
-    return regionCache;
+  public RegionProvider getRegionProvider() {
+    return regionProvider;
-      Region<ByteArrayWrapper, RedisHash> redisHash;
-      Region<String, RedisDataType> redisMetaData;
-      Region<ByteArrayWrapper, RedisSet> redisSet;
+      Region<ByteArrayWrapper, RedisData> redisData;
-      if ((redisHash = cache.getRegion(HASH_REGION)) == null) {
-        RegionFactory<ByteArrayWrapper, RedisHash> regionFactory =
-            gemFireCache.createRegionFactory(DEFAULT_REGION_TYPE);
-        redisHash = regionFactory.create(HASH_REGION);
-      }
-
-      if ((redisSet = cache.getRegion(SET_REGION)) == null) {
-        RegionFactory<ByteArrayWrapper, RedisSet> regionFactory =
-            gemFireCache.createRegionFactory(DEFAULT_REGION_TYPE);
-        redisSet = regionFactory.create(SET_REGION);
-      }
-
-      if ((redisMetaData = cache.getRegion(REDIS_META_DATA_REGION)) == null) {
-        InternalRegionFactory<String, RedisDataType> redisMetaDataFactory =
-            gemFireCache.createInternalRegionFactory();
+      if ((redisData = cache.getRegion(REDIS_DATA_REGION)) == null) {
+        InternalRegionFactory<ByteArrayWrapper, RedisData> redisMetaDataFactory =
+            gemFireCache.createInternalRegionFactory(DEFAULT_REGION_TYPE);
-        redisMetaDataFactory.setDataPolicy(DataPolicy.REPLICATE);
-        redisMetaData = redisMetaDataFactory.create(REDIS_META_DATA_REGION);
+        redisData = redisMetaDataFactory.create(REDIS_DATA_REGION);
-      keyRegistrar = new KeyRegistrar(redisMetaData);
+      keyRegistrar = new KeyRegistrar(redisData);
-      regionCache = new RegionProvider(stringsRegion, hLLRegion, keyRegistrar,
-          expirationFutures, expirationExecutor, DEFAULT_REGION_TYPE, redisHash, redisSet);
-      redisMetaData.put(REDIS_META_DATA_REGION, RedisDataType.REDIS_PROTECTED);
-      redisMetaData.put(HLL_REGION, RedisDataType.REDIS_PROTECTED);
-      redisMetaData.put(STRING_REGION, RedisDataType.REDIS_PROTECTED);
-      redisMetaData.put(SET_REGION, RedisDataType.REDIS_PROTECTED);
-      redisMetaData.put(HASH_REGION, RedisDataType.REDIS_PROTECTED);
+      regionProvider = new RegionProvider(stringsRegion, hLLRegion, keyRegistrar,
+          expirationFutures, expirationExecutor, DEFAULT_REGION_TYPE, redisData);
+      keyRegistrar.register(Coder.stringToByteArrayWrapper(REDIS_DATA_REGION),
+          RedisDataType.REDIS_PROTECTED);
+      keyRegistrar.register(Coder.stringToByteArrayWrapper(HLL_REGION),
+          RedisDataType.REDIS_PROTECTED);
+      keyRegistrar.register(Coder.stringToByteArrayWrapper(STRING_REGION),
+          RedisDataType.REDIS_PROTECTED);
+  public static final int PROTECTED_KEY_COUNT = 3;
+
-    Collection<Entry<String, RedisDataType>> entrySet = keyRegistrar.keyInfos();
-    for (Entry<String, RedisDataType> entry : entrySet) {
-      String regionName = entry.getKey();
-      RedisDataType type = entry.getValue();
-      Region<?, ?> newRegion = cache.getRegion(regionName);
-      if (newRegion == null && type != RedisDataType.REDIS_STRING && type != RedisDataType.REDIS_HLL
-          && type != RedisDataType.REDIS_PROTECTED) {
-        try {
-          regionCache
-              .createRemoteRegionReferenceLocally(Coder.stringToByteArrayWrapper(regionName), type);
-        } catch (Exception e) {
-          if (logger.errorEnabled()) {
-            logger.error(e);
-          }
+    Collection<Entry<ByteArrayWrapper, RedisData>> entrySet = keyRegistrar.keyInfos();
+    for (Entry<ByteArrayWrapper, RedisData> entry : entrySet) {
+      ByteArrayWrapper key = entry.getKey();
+      RedisDataType type = entry.getValue().getType();
+      if (!regionProvider.typeUsesDynamicRegions(type)) {
+        continue;
+      }
+      if (cache.getRegion(key.toString()) != null) {
+        // TODO: this seems to be correct (i.e. no need to call createRemoteRegionReferenceLocally
+        // if region already exists).
+        // HOWEVER: createRemoteRegionReferenceLocally ends up doing nothing if the region does not
+        // exist. So this caller of createRemoteRegionReferenceLocally basically does nothing.
+        // createRemoteRegionReferenceLocally might be needed even if the region exists because
+        // local state needs to be initialized (like indexes and queries).
+        continue;
+      }
+      try {
+        regionProvider.createRemoteRegionReferenceLocally(key, type);
+      } catch (Exception e) {
+        // TODO: this eats the exception so if something really is wrong we don't fail but just log.
+        if (logger.errorEnabled()) {
+          logger.error(e);
-            new ExecutionHandlerContext(socketChannel, cache, regionCache, GeodeRedisServer.this,
+            new ExecutionHandlerContext(socketChannel, cache, regionProvider, GeodeRedisServer.this,
-  private void afterKeyCreate(EntryEvent<String, RedisDataType> event) {
+  private void afterKeyCreate(EntryEvent<ByteArrayWrapper, RedisData> event) {
-      final String key = event.getKey();
-      final RedisDataType value = event.getNewValue();
-      if (value != RedisDataType.REDIS_STRING && value != RedisDataType.REDIS_HLL
-          && value != RedisDataType.REDIS_PROTECTED) {
-        try {
-          regionCache.createRemoteRegionReferenceLocally(Coder.stringToByteArrayWrapper(key),
-              value);
-        } catch (RegionDestroyedException ignore) { // Region already destroyed, ignore
-        }
+      final ByteArrayWrapper key = event.getKey();
+      final RedisData value = event.getNewValue();
+      try {
+        regionProvider.createRemoteRegionReferenceLocally(key, value.getType());
+      } catch (RegionDestroyedException ignore) { // Region already destroyed, ignore
-  private void afterKeyDestroy(EntryEvent<String, RedisDataType> event) {
+  private void afterKeyDestroy(EntryEvent<ByteArrayWrapper, RedisData> event) {
-      final String key = event.getKey();
-      final RedisDataType value = event.getOldValue();
-      if (value != null && value != RedisDataType.REDIS_STRING && value != RedisDataType.REDIS_HLL
-          && value != RedisDataType.REDIS_PROTECTED) {
-        ByteArrayWrapper kW = Coder.stringToByteArrayWrapper(key);
-        Region<?, ?> r = regionCache.getRegion(kW);
-        if (r != null) {
-          regionCache.removeRegionReferenceLocally(kW, value);
-        }
-      }
+      final ByteArrayWrapper key = event.getKey();
+      final RedisData value = event.getOldValue();
+      regionProvider.removeRegionReferenceLocally(key, value.getType());
-  private class MetaCacheListener extends CacheListenerAdapter<String, RedisDataType> {
+  private class MetaCacheListener extends CacheListenerAdapter<ByteArrayWrapper, RedisData> {
-    public void afterCreate(EntryEvent<String, RedisDataType> event) {
+    public void afterCreate(EntryEvent<ByteArrayWrapper, RedisData> event) {
-    public void afterDestroy(EntryEvent<String, RedisDataType> event) {
+    public void afterDestroy(EntryEvent<ByteArrayWrapper, RedisData> event) {
-      regionCache.close();
+      regionProvider.close();

MOV23 MOV23 INS31 MOV78 INS83 MOV43 INS42 INS8 INS39 MOV8 INS8 INS8 UPD74 UPD66 UPD42 UPD42 UPD45 INS41 UPD42 INS34 MOV60 INS70 UPD74 MOV25 UPD74 MOV25 UPD43 UPD43 UPD66 UPD66 UPD66 UPD65 INS42 UPD74 INS44 INS42 MOV8 MOV43 UPD43 UPD43 MOV32 MOV43 UPD43 UPD43 MOV32 UPD42 UPD42 UPD74 UPD74 UPD42 INS42 INS21 UPD74 INS74 INS42 MOV60 MOV60 INS25 INS25 UPD42 UPD42 MOV60 MOV60 UPD42 UPD42 MOV60 MOV60 MOV43 UPD43 UPD43 MOV43 UPD43 UPD43 UPD74 INS32 MOV43 MOV43 UPD43 MOV43 MOV43 UPD43 MOV43 UPD43 INS38 INS8 INS27 INS8 UPD43 UPD43 UPD43 UPD43 UPD42 UPD42 UPD42 UPD42 UPD43 UPD42 UPD42 INS42 UPD42 INS32 INS42 UPD42 INS32 UPD42 MOV42 UPD42 MOV42 INS32 MOV40 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 INS32 INS32 INS18 INS32 INS33 INS18 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS32 UPD42 UPD42 UPD74 UPD42 UPD42 UPD42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 MOV42 INS42 UPD42 MOV43 UPD43 UPD42 INS42 INS42 UPD42 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 UPD42 INS42 UPD42 MOV42 INS42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL42 DEL65 DEL66 DEL66 DEL42 DEL67 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL23 DEL42 DEL65 DEL42 DEL67 DEL66 DEL83 DEL42 DEL42 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL36 DEL33 DEL27 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL36 DEL33 DEL27 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL40 DEL32 DEL21 DEL40 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL66 DEL42 DEL65 DEL66 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL43 DEL45 DEL42 DEL42 DEL32 DEL76 DEL76 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL40 DEL27 DEL27 DEL25 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL70 DEL8 DEL42 DEL40 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL42 DEL32 DEL8 DEL25 DEL8 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL76 DEL76 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25 DEL8 DEL25 DEL8
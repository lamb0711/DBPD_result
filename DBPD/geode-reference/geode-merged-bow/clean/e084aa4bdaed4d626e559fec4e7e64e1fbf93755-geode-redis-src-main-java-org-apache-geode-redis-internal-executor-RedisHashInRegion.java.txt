GEODE-8130: use a single region for redis Sets and Hashes  (#5120)

* Replaced replicated metaRegion with a partitioned dataRegion.
Currently the dataRegion is used the same way as the metaRegion
except for sets and hashes which store their actual data in it.
* Exception handling now correctly deals with FunctionException
* Disabled a test until GEODE-8127 if fixed.
* Now uses the ByteArrayWrapper as the key on the meta region
and the locks map instead of using a String.
Since a ByteArrayWrapper is used as the key in the data region
this will end up saving memory.

* Found a problem with redis dynamic region management.
Some of the code was executing when we added a new set or hash to
the metaDataRegion. It was only ignoring STRING and HLL.
This caused some extra memory to be used for every redis set/hash.
Now the dynamic region code is only used for lists and sortedSet.

* This commit has some TODO comments of what looks like a bug in
the dynamic region code when a new server is started. It looks
like the new server will not create already existing dynamic regions.
We could test this by starting one server, create a LIST, then
start another server, and then shutdown the first server. Does
the LIST still exist? If we change them not to use dynamic regions
then this issue will go away.
+import static org.apache.geode.redis.internal.RedisDataType.REDIS_HASH;
+
+import org.apache.geode.redis.internal.RedisConstants;
+import org.apache.geode.redis.internal.RedisData;
+import org.apache.geode.redis.internal.RedisDataTypeMismatchException;
-  private final Region<ByteArrayWrapper, RedisHash> localRegion;
+  private final Region<ByteArrayWrapper, RedisData> region;
-  public RedisHashInRegion(Region<ByteArrayWrapper, RedisHash> localRegion) {
-    this.localRegion = localRegion;
+  public RedisHashInRegion(Region<ByteArrayWrapper, RedisData> region) {
+    this.region = region;
-    RedisHash hash = localRegion.get(key);
+    RedisHash hash = checkType(region.get(key));
-      return hash.hset(localRegion, key, fieldsToSet, NX);
+      return hash.hset(region, key, fieldsToSet, NX);
-      localRegion.put(key, new RedisHash(fieldsToSet));
+      region.put(key, new RedisHash(fieldsToSet));
-    return getRedisHash(key).hdel(localRegion, key, fieldsToRemove);
+    return getRedisHash(key).hdel(region, key, fieldsToRemove);
-    return localRegion.remove(key) != null;
+    return region.remove(key) != null;
-    return localRegion.getOrDefault(key, RedisHash.EMPTY);
+    return checkType(region.getOrDefault(key, RedisHash.EMPTY));
+
+  public static RedisHash checkType(RedisData redisData) {
+    if (redisData == null) {
+      return null;
+    }
+    if (redisData.getType() != REDIS_HASH) {
+      throw new RedisDataTypeMismatchException(RedisConstants.ERROR_WRONG_TYPE);
+    }
+    return (RedisHash) redisData;
+  }
+

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS31 UPD74 MOV74 INS83 INS83 MOV43 INS42 INS44 INS8 INS43 UPD42 UPD74 MOV74 UPD42 INS43 INS42 INS25 INS25 INS41 INS42 INS43 INS32 INS42 INS27 INS8 INS27 INS8 INS11 INS42 UPD42 INS32 UPD42 INS42 INS32 INS42 INS33 INS41 INS32 INS42 INS53 MOV43 INS42 UPD42 INS42 INS32 UPD42 UPD42 MOV42 MOV42 MOV42 MOV40 INS33 INS42 INS42 INS14 UPD42 MOV42 MOV42 MOV42 UPD42 UPD42 INS43 INS40 INS42 DEL32 DEL32
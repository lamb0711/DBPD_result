Revert " GEODE-6580: Cleanup static analyzer warnings. (#3415)"

This reverts commit 80a32b19c3cdbfe75c37d7b70104ea708739d2cd.

-
-import java.util.Arrays;
+import org.apache.geode.internal.SetUtils;
-      Integer.getInteger("DistributionManager.STARTUP_TIMEOUT", 15000);
+      Integer.getInteger("DistributionManager.STARTUP_TIMEOUT", 15000).intValue();
-      Integer.getInteger("DistributionManager.MAX_WAITING_THREADS", Integer.MAX_VALUE);
+      Integer.getInteger("DistributionManager.MAX_WAITING_THREADS", Integer.MAX_VALUE).intValue();
-      Integer.getInteger("DistributionManager.MAX_PR_META_DATA_CLEANUP_THREADS", 1);
+      Integer.getInteger("DistributionManager.MAX_PR_META_DATA_CLEANUP_THREADS", 1).intValue();
-      Integer.getInteger("DistributionManager.MAX_THREADS", 100);
+      Integer.getInteger("DistributionManager.MAX_THREADS", 100).intValue();
-      Math.max(Runtime.getRuntime().availableProcessors() * 4, 16));
+      Math.max(Runtime.getRuntime().availableProcessors() * 4, 16)).intValue();
-      Math.max(Runtime.getRuntime().availableProcessors() * 4, 16));
+      Math.max(Runtime.getRuntime().availableProcessors() * 4, 16)).intValue();
-      Integer.getInteger("DistributionManager.INCOMING_QUEUE_LIMIT", 80000);
+      Integer.getInteger("DistributionManager.INCOMING_QUEUE_LIMIT", 80000).intValue();
-      .getInteger("DistributionManager.SERIAL_QUEUE_THROTTLE_PERCENT", 75)) / 100;
+      .getInteger("DistributionManager.SERIAL_QUEUE_THROTTLE_PERCENT", 75).intValue()) / 100;
-  private static final int SERIAL_QUEUE_BYTE_LIMIT = Integer
-      .getInteger("DistributionManager.SERIAL_QUEUE_BYTE_LIMIT", (40 * (1024 * 1024)));
+  static final int SERIAL_QUEUE_BYTE_LIMIT = Integer
+      .getInteger("DistributionManager.SERIAL_QUEUE_BYTE_LIMIT", (40 * (1024 * 1024))).intValue();
-  private static final int SERIAL_QUEUE_THROTTLE =
+  static final int SERIAL_QUEUE_THROTTLE =
-          (int) (SERIAL_QUEUE_BYTE_LIMIT * THROTTLE_PERCENT));
+          (int) (SERIAL_QUEUE_BYTE_LIMIT * THROTTLE_PERCENT)).intValue();
-  private static final int TOTAL_SERIAL_QUEUE_BYTE_LIMIT =
-      Integer.getInteger("DistributionManager.TOTAL_SERIAL_QUEUE_BYTE_LIMIT", (80 * (1024 * 1024)));
+  static final int TOTAL_SERIAL_QUEUE_BYTE_LIMIT =
+      Integer.getInteger("DistributionManager.TOTAL_SERIAL_QUEUE_BYTE_LIMIT", (80 * (1024 * 1024)))
+          .intValue();
-  private static final int TOTAL_SERIAL_QUEUE_THROTTLE =
+  static final int TOTAL_SERIAL_QUEUE_THROTTLE =
-          (int) (SERIAL_QUEUE_BYTE_LIMIT * THROTTLE_PERCENT));
+          (int) (SERIAL_QUEUE_BYTE_LIMIT * THROTTLE_PERCENT)).intValue();
-  private static final int SERIAL_QUEUE_SIZE_LIMIT =
-      Integer.getInteger("DistributionManager.SERIAL_QUEUE_SIZE_LIMIT", 20000);
+  static final int SERIAL_QUEUE_SIZE_LIMIT =
+      Integer.getInteger("DistributionManager.SERIAL_QUEUE_SIZE_LIMIT", 20000).intValue();
-  private static final int SERIAL_QUEUE_SIZE_THROTTLE =
+  static final int SERIAL_QUEUE_SIZE_THROTTLE =
-          (int) (SERIAL_QUEUE_SIZE_LIMIT * THROTTLE_PERCENT));
+          (int) (SERIAL_QUEUE_SIZE_LIMIT * THROTTLE_PERCENT)).intValue();
-  private static final int MAX_SERIAL_QUEUE_THREAD =
-      Integer.getInteger("DistributionManager.MAX_SERIAL_QUEUE_THREAD", 20);
+  static final int MAX_SERIAL_QUEUE_THREAD =
+      Integer.getInteger("DistributionManager.MAX_SERIAL_QUEUE_THREAD", 20).intValue();
-  static final String FUNCTION_EXECUTION_PROCESSOR_THREAD_PREFIX =
+  protected static final String FUNCTION_EXECUTION_PROCESSOR_THREAD_PREFIX =
-  private int distributedSystemId;
+  private int distributedSystemId = DistributionConfig.DEFAULT_DISTRIBUTED_SYSTEM_ID;
-        logger.info(LogMarker.DM_MARKER,
-            "DistributionManager {} started on {}. There were {} other DMs. others: {} {} {}",
-            distributionManager.getDistributionManagerId(), transport,
-            distributionManager.getOtherDistributionManagerIds().size(),
+        Object[] logArgs = new Object[] {distributionManager.getDistributionManagerId(), transport,
+            Integer.valueOf(distributionManager.getOtherDistributionManagerIds().size()),
-                : (distributionManager.getDMType() == LOCATOR_DM_TYPE) ? " (locator)" : ""));
+                : (distributionManager.getDMType() == LOCATOR_DM_TYPE) ? " (locator)" : "")};
+        logger.info(LogMarker.DM_MARKER,
+            "DistributionManager {} started on {}. There were {} other DMs. others: {} {} {}",
+            logArgs);
+    this.dmType = transport.getVmKind();
-    dmType = transport.getVmKind();
-    membershipListeners = new ConcurrentHashMap<>();
-    distributedSystemId = system.getConfig().getDistributedSystemId();
+    this.membershipListeners = new ConcurrentHashMap<>();
+    this.distributedSystemId = system.getConfig().getDistributedSystemId();
-    stats = new DistributionStats(system, statId);
+    this.stats = new DistributionStats(system, statId);
-    exceptionInThreads = false;
+    this.exceptionInThreads = false;
-        threadMonitor = new ThreadsMonitoringImpl(system);
+        this.threadMonitor = new ThreadsMonitoringImpl(system);
-        threadMonitor = new ThreadsMonitoringImplDummy();
+        this.threadMonitor = new ThreadsMonitoringImplDummy();
-        serialQueuedExecutorPool =
-            new SerialQueuedExecutorPool(stats, throttlingDisabled, threadMonitor);
+        this.serialQueuedExecutorPool =
+            new SerialQueuedExecutorPool(this.stats, throttlingDisabled, this.threadMonitor);
-        BlockingQueue<Runnable> poolQueue;
+        BlockingQueue poolQueue;
-          poolQueue = new OverflowQueueWithDMStats<>(stats.getSerialQueueHelper());
+          poolQueue = new OverflowQueueWithDMStats(this.stats.getSerialQueueHelper());
-          serialQueue =
+          this.serialQueue =
-                  stats.getSerialQueueHelper());
-          poolQueue = serialQueue;
+                  this.stats.getSerialQueueHelper());
+          poolQueue = this.serialQueue;
-        serialThread = LoggingExecutors.newSerialThreadPool("Serial Message Processor",
+        this.serialThread = LoggingExecutors.newSerialThreadPool("Serial Message Processor",
-            this::doSerialThread, stats.getSerialProcessorHelper(),
+            this::doSerialThread, this.stats.getSerialProcessorHelper(),
-      viewThread =
+      this.viewThread =
-              stats.getViewProcessorHelper(), threadMonitor);
+              this.stats.getViewProcessorHelper(), threadMonitor);
-      threadPool =
+      this.threadPool =
-              MAX_THREADS, stats.getNormalPoolHelper(), threadMonitor,
-              INCOMING_QUEUE_LIMIT, stats.getOverflowQueueHelper());
+              MAX_THREADS, this.stats.getNormalPoolHelper(), threadMonitor,
+              INCOMING_QUEUE_LIMIT, this.stats.getOverflowQueueHelper());
-      highPriorityPool = LoggingExecutors.newThreadPoolWithFeedStatistics(
+      this.highPriorityPool = LoggingExecutors.newThreadPoolWithFeedStatistics(
-          MAX_THREADS, stats.getHighPriorityPoolHelper(), threadMonitor,
-          INCOMING_QUEUE_LIMIT, stats.getHighPriorityQueueHelper());
+          MAX_THREADS, this.stats.getHighPriorityPoolHelper(), threadMonitor,
+          INCOMING_QUEUE_LIMIT, this.stats.getHighPriorityQueueHelper());
-          poolQueue = new OverflowQueueWithDMStats<>(stats.getWaitingQueueHelper());
+          poolQueue = new OverflowQueueWithDMStats<>(this.stats.getWaitingQueueHelper());
-        waitingPool = LoggingExecutors.newThreadPool("Pooled Waiting Message Processor ",
+        this.waitingPool = LoggingExecutors.newThreadPool("Pooled Waiting Message Processor ",
-            MAX_WAITING_THREADS, stats.getWaitingPoolHelper(), threadMonitor, poolQueue);
+            MAX_WAITING_THREADS, this.stats.getWaitingPoolHelper(), threadMonitor, poolQueue);
-      prMetaDataCleanupThreadPool =
+      this.prMetaDataCleanupThreadPool =
-              MAX_PR_META_DATA_CLEANUP_THREADS, stats.getWaitingPoolHelper(), threadMonitor,
-              0, stats.getWaitingQueueHelper());
+              MAX_PR_META_DATA_CLEANUP_THREADS, this.stats.getWaitingPoolHelper(), threadMonitor,
+              0, this.stats.getWaitingQueueHelper());
-        partitionedRegionPool =
+        this.partitionedRegionPool =
-                MAX_PR_THREADS, stats.getPartitionedRegionPoolHelper(), threadMonitor,
-                INCOMING_QUEUE_LIMIT, stats.getPartitionedRegionQueueHelper());
+                MAX_PR_THREADS, this.stats.getPartitionedRegionPoolHelper(), threadMonitor,
+                INCOMING_QUEUE_LIMIT, this.stats.getPartitionedRegionQueueHelper());
-        partitionedRegionThread = LoggingExecutors.newSerialThreadPoolWithFeedStatistics(
+        this.partitionedRegionThread = LoggingExecutors.newSerialThreadPoolWithFeedStatistics(
-            stats.getPartitionedRegionPoolHelper(), threadMonitor,
-            INCOMING_QUEUE_LIMIT, stats.getPartitionedRegionQueueHelper());
+            this.stats.getPartitionedRegionPoolHelper(), threadMonitor,
+            INCOMING_QUEUE_LIMIT, this.stats.getPartitionedRegionQueueHelper());
-        functionExecutionPool =
+        this.functionExecutionPool =
-                MAX_FE_THREADS, stats.getFunctionExecutionPoolHelper(), threadMonitor,
-                INCOMING_QUEUE_LIMIT, stats.getFunctionExecutionQueueHelper());
+                MAX_FE_THREADS, this.stats.getFunctionExecutionPoolHelper(), threadMonitor,
+                INCOMING_QUEUE_LIMIT, this.stats.getFunctionExecutionQueueHelper());
-        functionExecutionThread =
+        this.functionExecutionThread =
-                stats.getFunctionExecutionPoolHelper(), threadMonitor,
-                INCOMING_QUEUE_LIMIT, stats.getFunctionExecutionQueueHelper());
+                this.stats.getFunctionExecutionPoolHelper(), threadMonitor,
+                INCOMING_QUEUE_LIMIT, this.stats.getFunctionExecutionQueueHelper());
-        memberEventThread =
+        this.memberEventThread =
-      StringBuilder sb = new StringBuilder(" (took ");
+      StringBuffer sb = new StringBuffer(" (took ");
-      localAddress = membershipManager.getLocalMember();
+      this.localAddress = membershipManager.getLocalMember();
-          new Object[] {localAddress,
+          new Object[] {this.localAddress,
-      description = "Distribution manager on " + localAddress + " started at "
+      this.description = "Distribution manager on " + this.localAddress + " started at "
-      setIsStartupThread();
+      setIsStartupThread(Boolean.TRUE);
-        getCancelCriterion().checkCancelInProgress(null);
+        this.getCancelCriterion().checkCancelInProgress(null);
-  private static Boolean isStartupThread() {
+  private static Boolean getIsStartupThread() {
-  private static void setIsStartupThread() {
-    ClusterDistributionManager.isStartupThread.set(Boolean.TRUE);
+  private static void setIsStartupThread(Boolean isStartup) {
+    ClusterDistributionManager.isStartupThread.set(isStartup);
-      redundancyZones.put(member, redundancyZone);
+      this.redundancyZones.put(member, redundancyZone);
-    return dmType;
+    return this.dmType;
-    return membershipManager.testMulticast();
+    return this.membershipManager.testMulticast();
-    system.setDM(this); // fix for bug 33362
-    if (memberEventThread != null)
-      memberEventThread.start();
+    this.system.setDM(this); // fix for bug 33362
+    if (this.memberEventThread != null)
+      this.memberEventThread.start();
-      getWaitingThreadPool().execute(() -> {
-        // call in background since it might need to send a reply
-        // and we are not ready to send messages until startup is finished
-        setIsStartupThread();
-        readyForMessages();
+      getWaitingThreadPool().execute(new Runnable() {
+        @Override
+        public void run() {
+          // call in background since it might need to send a reply
+          // and we are not ready to send messages until startup is finished
+          setIsStartupThread(Boolean.TRUE);
+          readyForMessages();
+        }
-      readyForMessages = true;
-      notifyAll();
+      this.readyForMessages = true;
+      this.notifyAll();
-          wait();
+          this.wait();
-    synchronized (readyToSendMsgsLock) {
-      readyToSendMsgs = true;
-      readyToSendMsgsLock.notifyAll();
+    synchronized (this.readyToSendMsgsLock) {
+      this.readyToSendMsgs = true;
+      this.readyToSendMsgsLock.notifyAll();
-    if (readyToSendMsgs) {
+    if (this.readyToSendMsgs) {
-    if (msg instanceof AdminMessageType) {
+    if (msg instanceof StartupMessage || msg instanceof StartupResponseMessage
+        || msg instanceof AdminMessageType) {
-    if (isStartupThread() == Boolean.TRUE) {
+    if (getIsStartupThread() == Boolean.TRUE) {
-    synchronized (readyToSendMsgsLock) {
-      while (!readyToSendMsgs) {
+    synchronized (this.readyToSendMsgsLock) {
+      while (!this.readyToSendMsgs) {
-          readyToSendMsgsLock.wait();
+          this.readyToSendMsgsLock.wait();
-    return exceptionInThreads
+    return this.exceptionInThreads
-    exceptionInThreads = false;
+    this.exceptionInThreads = false;
-    return system.getClock().cacheTimeMillis();
+    return this.system.getClock().cacheTimeMillis();
-    if (Objects.equals(localAddress.getName(), name)) {
+    if (Objects.equals(localAddress, name)) {
-    return localAddress;
+    return this.localAddress;
-    synchronized (membersLock) {
-      return members.keySet();
+    synchronized (this.membersLock) {
+      return this.members.keySet();
-    synchronized (membersLock) {
+    synchronized (this.membersLock) {
-      if (hostedLocatorsAll.isEmpty()) {
-        hostedLocatorsAll = new HashMap<>();
+      if (this.hostedLocatorsAll.isEmpty()) {
+        this.hostedLocatorsAll = new HashMap<>();
-          new HashMap<>(hostedLocatorsAll);
+          new HashMap<>(this.hostedLocatorsAll);
-      hostedLocatorsAll = tmp;
+      this.hostedLocatorsAll = tmp;
-        if (hostedLocatorsWithSharedConfiguration.isEmpty()) {
-          hostedLocatorsWithSharedConfiguration = new HashMap<>();
+        if (this.hostedLocatorsWithSharedConfiguration.isEmpty()) {
+          this.hostedLocatorsWithSharedConfiguration = new HashMap<>();
-        tmp = new HashMap<>(hostedLocatorsWithSharedConfiguration);
+        tmp = new HashMap<>(this.hostedLocatorsWithSharedConfiguration);
-        hostedLocatorsWithSharedConfiguration = tmp;
+        this.hostedLocatorsWithSharedConfiguration = tmp;
-    synchronized (membersLock) {
-      if (hostedLocatorsAll.containsKey(member)) {
+    synchronized (this.membersLock) {
+      if (this.hostedLocatorsAll.containsKey(member)) {
-            new HashMap<>(hostedLocatorsAll);
+            new HashMap<>(this.hostedLocatorsAll);
-        hostedLocatorsAll = tmp;
+        this.hostedLocatorsAll = tmp;
-      if (hostedLocatorsWithSharedConfiguration.containsKey(member)) {
+      if (this.hostedLocatorsWithSharedConfiguration.containsKey(member)) {
-                hostedLocatorsWithSharedConfiguration);
+                this.hostedLocatorsWithSharedConfiguration);
-        hostedLocatorsWithSharedConfiguration = tmp;
+        this.hostedLocatorsWithSharedConfiguration = tmp;
-    synchronized (membersLock) {
-      return hostedLocatorsAll.get(member);
+    synchronized (this.membersLock) {
+      return this.hostedLocatorsAll.get(member);
-    synchronized (membersLock) {
-      return hostedLocatorsAll;
+    synchronized (this.membersLock) {
+      return this.hostedLocatorsAll;
-    synchronized (membersLock) {
-      return hostedLocatorsWithSharedConfiguration;
+    synchronized (this.membersLock) {
+      return this.hostedLocatorsWithSharedConfiguration;
-    synchronized (membersLock) {
-      return membersAndAdmin;
+    synchronized (this.membersLock) {
+      return this.membersAndAdmin;
-    InternalDistributedMember result = members.get(id);
+    InternalDistributedMember result = this.members.get(id);
-    synchronized (membersLock) {
+    synchronized (this.membersLock) {
-            vmType));
+            Integer.valueOf(vmType)));
-    return localAddress;
+    return this.localAddress;
-    return description;
+    return this.description;
-      closeInProgress = true;
+      this.closeInProgress = true;
-    final String exceptionStatus = (exceptionInThreads()
+    final String exceptionStatus = (this.exceptionInThreads()
-        new Object[] {localAddress, exceptionStatus});
+        new Object[] {this.localAddress, exceptionStatus});
-      if (rootCause instanceof ForcedDisconnectException) {
+      if (this.rootCause instanceof ForcedDisconnectException) {
-        final Runnable r = () -> {
-          try {
-            ConnectionTable.threadWantsSharedResources();
-            sendShutdownMessage();
-          } catch (final CancelException e) {
-            // We were terminated.
-            logger.debug("Cancelled during shutdown message", e);
+        final Runnable r = new Runnable() {
+          @Override
+          public void run() {
+            try {
+              ConnectionTable.threadWantsSharedResources();
+              sendShutdownMessage();
+            } catch (final CancelException e) {
+              // We were terminated.
+              logger.debug("Cancelled during shutdown message", e);
+            }
-                localAddress), false, r);
+                this.localAddress), false, r);
-      shutdownMsgSent = true; // in case sendShutdownMessage failed....
+      this.shutdownMsgSent = true; // in case sendShutdownMessage failed....
-        uncleanShutdown(false);
+        this.uncleanShutdown(false);
-        final Long delta = System.currentTimeMillis() - start;
+        final Long delta = Long.valueOf(System.currentTimeMillis() - start);
-    es = serialThread;
+    es = this.serialThread;
-    es = viewThread;
+    es = this.viewThread;
-    if (serialQueuedExecutorPool != null) {
-      serialQueuedExecutorPool.shutdown();
+    if (this.serialQueuedExecutorPool != null) {
+      this.serialQueuedExecutorPool.shutdown();
-    es = functionExecutionThread;
+    es = this.functionExecutionThread;
-    es = functionExecutionPool;
+    es = this.functionExecutionPool;
-    es = partitionedRegionThread;
+    es = this.partitionedRegionThread;
-    es = partitionedRegionPool;
+    es = this.partitionedRegionPool;
-    es = highPriorityPool;
+    es = this.highPriorityPool;
-    es = waitingPool;
+    es = this.waitingPool;
-    es = prMetaDataCleanupThreadPool;
+    es = this.prMetaDataCleanupThreadPool;
-    es = threadPool;
+    es = this.threadPool;
-    Thread th = memberEventThread;
+    Thread th = this.memberEventThread;
-    ExecutorService[] allExecutors = new ExecutorService[] {serialThread, viewThread,
-        functionExecutionThread, functionExecutionPool, partitionedRegionThread,
-        partitionedRegionPool, highPriorityPool, waitingPool,
-        prMetaDataCleanupThreadPool, threadPool};
+    ExecutorService[] allExecutors = new ExecutorService[] {this.serialThread, this.viewThread,
+        this.functionExecutionThread, this.functionExecutionPool, this.partitionedRegionThread,
+        this.partitionedRegionPool, this.highPriorityPool, this.waitingPool,
+        this.prMetaDataCleanupThreadPool, this.threadPool};
-    serialQueuedExecutorPool.awaitTermination(remaining, TimeUnit.MILLISECONDS);
+
+    this.serialQueuedExecutorPool.awaitTermination(remaining, TimeUnit.MILLISECONDS);
-    Thread th = memberEventThread;
+    Thread th = this.memberEventThread;
-    StringBuilder culprits;
+    String culprits = "";
-      culprits = new StringBuilder();
-      if (executorAlive(serialThread, "serial thread")) {
+      culprits = "";
+      if (executorAlive(this.serialThread, "serial thread")) {
-        culprits.append(" serial thread;");
+        culprits = culprits + " serial thread;";
-      if (executorAlive(viewThread, "view thread")) {
+      if (executorAlive(this.viewThread, "view thread")) {
-        culprits.append(" view thread;");
+        culprits = culprits + " view thread;";
-      if (executorAlive(partitionedRegionThread, "partitioned region thread")) {
+      if (executorAlive(this.partitionedRegionThread, "partitioned region thread")) {
-        culprits.append(" partitioned region thread;");
+        culprits = culprits + " partitioned region thread;";
-      if (executorAlive(partitionedRegionPool, "partitioned region pool")) {
+      if (executorAlive(this.partitionedRegionPool, "partitioned region pool")) {
-        culprits.append(" partitioned region pool;");
+        culprits = culprits + " partitioned region pool;";
-      if (executorAlive(highPriorityPool, "high priority pool")) {
+      if (executorAlive(this.highPriorityPool, "high priority pool")) {
-        culprits.append(" high priority pool;");
+        culprits = culprits + " high priority pool;";
-      if (executorAlive(waitingPool, "waiting pool")) {
+      if (executorAlive(this.waitingPool, "waiting pool")) {
-        culprits.append(" waiting pool;");
+        culprits = culprits + " waiting pool;";
-      if (executorAlive(prMetaDataCleanupThreadPool, "prMetaDataCleanupThreadPool")) {
+      if (executorAlive(this.prMetaDataCleanupThreadPool, "prMetaDataCleanupThreadPool")) {
-        culprits.append(" special waiting pool;");
+        culprits = culprits + " special waiting pool;";
-      if (executorAlive(threadPool, "thread pool")) {
+      if (executorAlive(this.threadPool, "thread pool")) {
-        culprits.append(" thread pool;");
+        culprits = culprits + " thread pool;";
-    if (serialThread != null) {
-      serialThread.shutdownNow();
+    if (this.serialThread != null) {
+      this.serialThread.shutdownNow();
-    if (viewThread != null) {
-      viewThread.shutdownNow();
+    if (this.viewThread != null) {
+      this.viewThread.shutdownNow();
-    if (functionExecutionThread != null) {
-      functionExecutionThread.shutdownNow();
+    if (this.functionExecutionThread != null) {
+      this.functionExecutionThread.shutdownNow();
-    if (functionExecutionPool != null) {
-      functionExecutionPool.shutdownNow();
+    if (this.functionExecutionPool != null) {
+      this.functionExecutionPool.shutdownNow();
-    if (partitionedRegionThread != null) {
-      partitionedRegionThread.shutdownNow();
+    if (this.partitionedRegionThread != null) {
+      this.partitionedRegionThread.shutdownNow();
-    if (partitionedRegionPool != null) {
-      partitionedRegionPool.shutdownNow();
+    if (this.partitionedRegionPool != null) {
+      this.partitionedRegionPool.shutdownNow();
-    if (highPriorityPool != null) {
-      highPriorityPool.shutdownNow();
+    if (this.highPriorityPool != null) {
+      this.highPriorityPool.shutdownNow();
-    if (waitingPool != null) {
-      waitingPool.shutdownNow();
+    if (this.waitingPool != null) {
+      this.waitingPool.shutdownNow();
-    if (prMetaDataCleanupThreadPool != null) {
-      prMetaDataCleanupThreadPool.shutdownNow();
+    if (this.prMetaDataCleanupThreadPool != null) {
+      this.prMetaDataCleanupThreadPool.shutdownNow();
-    if (threadPool != null) {
-      threadPool.shutdownNow();
+    if (this.threadPool != null) {
+      this.threadPool.shutdownNow();
-    Thread th = memberEventThread;
+    Thread th = this.memberEventThread;
-    return shutdownInProgress;
+    return this.shutdownInProgress;
-      closeInProgress = true; // set here also to fix bug 36736
+      this.closeInProgress = true; // set here also to fix bug 36736
-        if (stats != null) {
-          stats.close();
+        if (this.stats != null) {
+          this.stats.close();
-        if (membershipManager != null) {
+        if (this.membershipManager != null) {
-              localAddress);
-          membershipManager.disconnect(beforeJoined);
+              this.localAddress);
+          this.membershipManager.disconnect(beforeJoined);
-    return system;
+    return this.system;
-    return transport;
+    return this.transport;
-    membershipListeners.putIfAbsent(l, Boolean.TRUE);
+    this.membershipListeners.putIfAbsent(l, Boolean.TRUE);
-    membershipListeners.remove(l);
+    this.membershipListeners.remove(l);
-    return Collections.unmodifiableSet(membershipListeners.keySet());
+    return Collections.unmodifiableSet(this.membershipListeners.keySet());
-    synchronized (allMembershipListenersLock) {
+    synchronized (this.allMembershipListenersLock) {
-          new HashSet<>(allMembershipListeners);
+          new HashSet<>(this.allMembershipListeners);
-      allMembershipListeners = newAllMembershipListeners;
+      this.allMembershipListeners = newAllMembershipListeners;
-    synchronized (allMembershipListenersLock) {
+    synchronized (this.allMembershipListenersLock) {
-          new HashSet<>(allMembershipListeners);
+          new HashSet<>(this.allMembershipListeners);
-      allMembershipListeners = newAllMembershipListeners;
+      this.allMembershipListeners = newAllMembershipListeners;
-  boolean isCloseInProgress() {
+  protected boolean isCloseInProgress() {
-    synchronized (membershipViewIdGuard) {
-      membershipViewIdAcknowledged = ev.getViewId();
-      membershipViewIdGuard.notifyAll();
+    synchronized (this.membershipViewIdGuard) {
+      this.membershipViewIdAcknowledged = ev.getViewId();
+      this.membershipViewIdGuard.notifyAll();
-    if (id <= membershipViewIdAcknowledged) {
+    if (id <= this.membershipViewIdAcknowledged) {
-    synchronized (membershipViewIdGuard) {
-      while (membershipViewIdAcknowledged < id && !stopper.isCancelInProgress()) {
+    synchronized (this.membershipViewIdGuard) {
+      while (this.membershipViewIdAcknowledged < id && !this.stopper.isCancelInProgress()) {
-              membershipViewIdAcknowledged);
+              this.membershipViewIdAcknowledged);
-        membershipViewIdGuard.wait();
+        this.membershipViewIdGuard.wait();
-        if (!system.isConnected
-            && isClosed()) {
+        if (!ClusterDistributionManager.this.system.isConnected
+            && ClusterDistributionManager.this.isClosed()) {
-              membershipEventQueue.take();
+              ClusterDistributionManager.this.membershipEventQueue.take();
-        membershipEventQueue.put(ev);
+        this.membershipEventQueue.put(ev);
-      shutdown();
+      this.shutdown();
-          localAddress);
-      MembershipLogger.logShutdown(localAddress);
+          this.localAddress);
+      MembershipLogger.logShutdown(this.localAddress);
-    if (shutdownMsgSent) {
+    if (this.shutdownMsgSent) {
-          getRootCause());
+          this.getRootCause());
-    return closed;
+    return this.closed;
-    synchronized (adminConsolesLock) {
-      HashSet<InternalDistributedMember> tmp = new HashSet<>(adminConsoles);
+    synchronized (this.adminConsolesLock) {
+      HashSet<InternalDistributedMember> tmp = new HashSet<>(this.adminConsoles);
-      adminConsoles = Collections.unmodifiableSet(tmp);
+      this.adminConsoles = Collections.unmodifiableSet(tmp);
-    return stats;
+    return this.stats;
-      synchronized (membersLock) {
+      synchronized (this.membersLock) {
-    receivedStartupResponse = false;
-    boolean ok;
+    this.receivedStartupResponse = false;
+    boolean ok = false;
-    if (rejectionMessage != null) {
+    if (this.rejectionMessage != null) {
-    boolean receivedAny = receivedStartupResponse;
+    boolean receivedAny = this.receivedStartupResponse;
-          StringBuilder sb = new StringBuilder();
+          StringBuffer sb = new StringBuffer();
-                  Integer.toString(allOthers.size()), sb.toString()));
+
+                  new Object[] {Integer.toString(allOthers.size()), sb.toString()}));
-      synchronized (membersLock) {
+      synchronized (this.membersLock) {
-      String msg;
+      String msg = null;
-            new Object[] {numLeft, unfinishedStartups});
+            new Object[] {Integer.valueOf(numLeft), unfinishedStartups});
-      if (!receivedStartupResponse) {
+      if (!this.receivedStartupResponse) {
-        receivedStartupResponse = true;
+        this.receivedStartupResponse = true;
-      if (theRejectionMessage != null && rejectionMessage == null) {
+      if (theRejectionMessage != null && this.rejectionMessage == null) {
-        rejectionMessage = theRejectionMessage;
+        this.rejectionMessage = theRejectionMessage;
+  /**
+   * Based on a recent JGroups view, return a member that might be the next elder.
+   *
+   * @return the elder candidate, possibly this VM.
+   */
+  private InternalDistributedMember getElderCandidate() {
+    return clusterElderManager.getElderCandidate();
+  }
+
-      synchronized (membersLock) {
+      synchronized (this.membersLock) {
-        Map<InternalDistributedMember, InternalDistributedMember> tmp = new HashMap<>(members);
+        Map<InternalDistributedMember, InternalDistributedMember> tmp = new HashMap<>(this.members);
-          members = tmp;
+          this.members = tmp;
-        Set<InternalDistributedMember> tmp2 = new HashSet<>(membersAndAdmin);
+        Set<InternalDistributedMember> tmp2 = new HashSet<>(this.membersAndAdmin);
-          membersAndAdmin = tmp2;
+          this.membersAndAdmin = tmp2;
-        removeHostedLocators(theId);
+        this.removeHostedLocators(theId);
-    HashMap<InternalDistributedMember, InternalDistributedMember> tmp;
-    synchronized (membersLock) {
+    HashMap<InternalDistributedMember, InternalDistributedMember> tmp = null;
+    synchronized (this.membersLock) {
-      tmp = new HashMap<>(members);
+      tmp = new HashMap<>(this.members);
-      members = Collections.unmodifiableMap(tmp);
+      this.members = Collections.unmodifiableMap(tmp);
-      Set<InternalDistributedMember> stmp = new HashSet<>(membersAndAdmin);
+      Set<InternalDistributedMember> stmp = new HashSet<>(this.membersAndAdmin);
-      membersAndAdmin = Collections.unmodifiableSet(stmp);
+      this.membersAndAdmin = Collections.unmodifiableSet(stmp);
-      stats.incNodes(1);
+      this.stats.incNodes(1);
-    synchronized (membersLock) {
+    synchronized (this.membersLock) {
-      m = membersAndAdmin;
+      m = this.membersAndAdmin;
-    HashSet<InternalDistributedMember> tmp;
-    synchronized (membersLock) {
+    HashSet<InternalDistributedMember> tmp = null;
+    synchronized (this.membersLock) {
-      tmp = new HashSet<>(membersAndAdmin);
+      tmp = new HashSet<>(this.membersAndAdmin);
-      membersAndAdmin = Collections.unmodifiableSet(tmp);
+      this.membersAndAdmin = Collections.unmodifiableSet(tmp);
-    synchronized (membersLock) {
+    synchronized (this.membersLock) {
-      if (!members.containsKey(theId)) {
+      if (!this.members.containsKey(theId)) {
-        Set<InternalDistributedMember> tmp = new HashSet<>(membersAndAdmin);
+        Set<InternalDistributedMember> tmp = new HashSet<>(this.membersAndAdmin);
-          membersAndAdmin = tmp;
+          this.membersAndAdmin = tmp;
-    synchronized (adminConsolesLock) {
-      if (adminConsoles.contains(theId)) {
+    synchronized (this.adminConsolesLock) {
+      if (this.adminConsoles.contains(theId)) {
-        Set<InternalDistributedMember> tmp = new HashSet<>(adminConsoles);
+        Set<InternalDistributedMember> tmp = new HashSet<>(this.adminConsoles);
-        adminConsoles = tmp;
+        this.adminConsoles = tmp;
-      String msg;
+      String msg = null;
-    membershipManager.shutdownMessageReceived(theId, reason);
+    this.membershipManager.shutdownMessageReceived(theId, reason);
-        stats.incNodes(-1);
+        this.stats.incNodes(-1);
-      if (serialQueuedExecutorPool != null) {
+      if (this.serialQueuedExecutorPool != null) {
-    InternalDistributedMember theId = getDistributionManagerId();
+    InternalDistributedMember theId = this.getDistributionManagerId();
-      logger.trace("{} Sending {} to {}", getDistributionManagerId(), m,
+      logger.trace("{} Sending {} to {}", this.getDistributionManagerId(), m,
-      stats.incSentMessages(1L);
+      this.stats.incSentMessages(1L);
-      shutdownMsgSent = true;
+      this.shutdownMsgSent = true;
-        return viewThread;
+        return this.viewThread;
-        sendViaMembershipManager(message.getRecipients(), message, this, stats);
+        sendViaMembershipManager(message.getRecipients(), message,
+            ClusterDistributionManager.this, this.stats);
+    Set<InternalDistributedMember> result = null;
-      return sendOutgoing(message);
+      result = sendOutgoing(message);
-      exceptionInThreads = true;
+      ClusterDistributionManager.this.exceptionInThreads = true;
-      logger.fatal(String.format("While pushing message <%s> to %s", message, receiver), ex);
-      if (message == null || message.forAll()) {
+      logger.fatal(String.format("While pushing message <%s> to %s",
+          new Object[] {message, receiver}),
+          ex);
+      if (message == null || message.forAll())
-      }
-      return new HashSet<>(Arrays.asList(message.getRecipients()));
+      result = new HashSet<>();
+      for (int i = 0; i < message.getRecipients().length; i++)
+        result.add(message.getRecipients()[i]);
+      return result;
+    return result;
-    message.schedule(this);
+    message.schedule(ClusterDistributionManager.this);
+  }
+
+  private List<InternalDistributedMember> getElderCandidates() {
+
+    return clusterElderManager.getElderCandidates();
-    return threadPool;
+    return this.threadPool;
-    return highPriorityPool;
+    return this.highPriorityPool;
-    return waitingPool;
+    return this.waitingPool;
-    return prMetaDataCleanupThreadPool;
+    return this.prMetaDataCleanupThreadPool;
-    if (partitionedRegionThread != null) {
-      return partitionedRegionThread;
+    if (this.partitionedRegionThread != null) {
+      return this.partitionedRegionThread;
-      return partitionedRegionPool;
+      return this.partitionedRegionPool;
-    if (functionExecutionThread != null) {
-      return functionExecutionThread;
+    if (this.functionExecutionThread != null) {
+      return this.functionExecutionThread;
-      return functionExecutionPool;
+      return this.functionExecutionPool;
-      return serialQueuedExecutorPool.getThrottledSerialExecutor(sender);
+      return this.serialQueuedExecutorPool.getThrottledSerialExecutor(sender);
-      return serialThread;
+      return this.serialThread;
-      return serialQueuedExecutorPool.getSerialQueue(sender);
+      return this.serialQueuedExecutorPool.getSerialQueue(sender);
-      return serialQueue;
+      return this.serialQueue;
+  /** returns the Threads Monitoring instance */
-    return threadMonitor;
+    return this.threadMonitor;
-    return agent;
+    return this.agent;
-    if (agent == null) {
+    if (this.agent == null) {
-      return agent.getTransport().toString();
+      return this.agent.getTransport().toString();
-    return hmMap.get(owner);
+    return this.hmMap.get(owner);
-        hmMap.remove(owner);
+        this.hmMap.remove(owner);
-      hmMap.put(owner, newHm);
+      this.hmMap.put(owner, newHm);
-      hmMap.remove(owner);
+      this.hmMap.remove(owner);
-    Iterator it = hmMap.values().iterator();
+    Iterator it = this.hmMap.values().iterator();
-    return adminConsoles;
+    return this.adminConsoles;
-      threadMonitoring = tMonitoring;
+      this.threadMonitoring = tMonitoring;
-          queueId = (serialQueuedExecutorMap.size() + 1) % MAX_SERIAL_QUEUE_THREAD;
+          queueId = Integer.valueOf((serialQueuedExecutorMap.size() + 1) % MAX_SERIAL_QUEUE_THREAD);
-          stats.getSerialQueueHelper().incThrottleCount();
+          this.stats.getSerialQueueHelper().incThrottleCount();
-      ExecutorService executor;
+      ExecutorService executor = null;
-      if (SERIAL_QUEUE_BYTE_LIMIT == 0 || throttlingDisabled) {
+      if (SERIAL_QUEUE_BYTE_LIMIT == 0 || this.throttlingDisabled) {
-            stats.getSerialQueueHelper());
+            this.stats.getSerialQueueHelper());
-          stats.getSerialPooledProcessorHelper(), threadMonitoring, poolQueue);
+          this.stats.getSerialPooledProcessorHelper(), threadMonitoring, poolQueue);
-        for (Integer value : senderToSerialQueueIdMap.values()) {
+        for (Iterator iter = senderToSerialQueueIdMap.values().iterator(); iter.hasNext();) {
+          Integer value = (Integer) iter.next();
-      long remainingNanos = unit.toNanos(time);
+      long timeNanos = unit.toNanos(time);
+      long remainingNanos = timeNanos;
-        remainingNanos = (System.nanoTime() - start);
+        remainingNanos = timeNanos = (System.nanoTime() - start);
-    DMListener(ClusterDistributionManager dm) {
+    public DMListener(ClusterDistributionManager dm) {
-      rootCause = t;
+      ClusterDistributionManager.this.rootCause = t;
-      return id;
+      return this.id;
-      return whoSuspected;
+      return this.whoSuspected;
-      return reason;
+      return this.reason;
-      return "member " + getId() + " suspected by: " + whoSuspected + " reason: " + reason;
+      return "member " + getId() + " suspected by: " + this.whoSuspected + " reason: " + reason;
-      return "view installed: " + view;
+      return "view installed: " + this.view;
-      return failures;
+      return this.failures;
-      return remaining;
+      return this.remaining;
-    return rootCause;
+    return this.rootCause;
-    rootCause = t;
+    this.rootCause = t;
-      for (InternalDistributedMember o : getDistributionManagerIds()) {
-        if (!Collections.disjoint(targetAddrs, getEquivalents(o.getInetAddress()))) {
+      for (Iterator i = getDistributionManagerIds().iterator(); i.hasNext();) {
+        InternalDistributedMember o = (InternalDistributedMember) i.next();
+        if (SetUtils.intersectsWith(targetAddrs, getEquivalents(o.getInetAddress()))) {
-    parallelGIIs.acquireUninterruptibly();
-    stats.incInitialImageRequestsInProgress(1);
+    this.parallelGIIs.acquireUninterruptibly();
+    this.stats.incInitialImageRequestsInProgress(1);
-    stats.incInitialImageRequestsInProgress(-1);
-    parallelGIIs.release();
+    this.stats.incInitialImageRequestsInProgress(-1);
+    this.parallelGIIs.release();
-    return distributedSystemId;
+    return this.distributedSystemId;
-      for (InternalDistributedMember mbr : ids) {
+      for (Iterator it = ids.iterator(); it.hasNext();) {
+        InternalDistributedMember mbr = (InternalDistributedMember) it.next();
-            && mbr.getInetAddress().equals(localAddress.getInetAddress())) {
+            && mbr.getInetAddress().equals(this.localAddress.getInetAddress())) {
-    synchronized (membersLock) {
+    synchronized (this.membersLock) {
-      for (InternalDistributedMember m : members.keySet()) {
+      for (InternalDistributedMember m : this.members.keySet()) {
-    synchronized (membersLock) {
+    synchronized (this.membersLock) {
-      for (InternalDistributedMember m : members.keySet()) {
+      for (InternalDistributedMember m : this.members.keySet()) {
-    cache = instance;
+    this.cache = instance;
-    return cache;
+    return this.cache;
-    InternalCache result = cache;
+    InternalCache result = this.cache;

MOV26 MOV31 MOV31 UPD40 INS31 INS31 INS31 INS31 INS83 MOV21 UPD42 INS44 UPD42 MOV29 UPD42 MOV44 MOV78 MOV44 MOV78 MOV44 MOV29 MOV83 MOV39 MOV42 MOV44 MOV8 MOV78 INS83 INS39 INS42 MOV44 MOV8 INS83 INS29 INS83 INS43 INS42 INS8 INS83 INS74 INS42 INS8 MOV78 MOV43 MOV78 MOV43 MOV78 MOV43 MOV78 MOV43 MOV43 MOV78 MOV43 MOV78 MOV78 MOV78 MOV78 MOV78 MOV78 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS40 INS43 INS42 MOV25 INS25 INS25 INS25 INS65 INS65 INS42 INS41 INS60 INS41 INS43 INS43 INS41 INS83 MOV43 MOV43 MOV78 MOV32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 MOV32 INS42 INS42 INS22 INS52 INS22 INS22 MOV8 INS27 MOV8 INS27 MOV8 INS22 INS22 INS22 INS22 INS22 MOV25 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS43 MOV5 MOV43 UPD43 MOV43 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS66 INS66 INS32 INS22 MOV27 INS22 INS22 INS22 INS22 MOV74 INS74 INS59 INS42 INS42 INS42 INS32 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS60 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS42 INS52 INS42 INS22 INS22 INS22 INS52 INS42 INS52 INS42 INS62 INS62 MOV62 INS32 INS40 INS52 INS42 INS22 INS22 MOV42 INS52 INS42 INS52 INS42 INS52 INS42 MOV25 INS60 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS42 INS22 INS22 MOV42 INS22 UPD42 INS45 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS22 INS52 INS42 MOV21 INS52 INS42 MOV60 MOV25 INS52 INS42 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS60 INS52 INS42 INS22 INS9 INS22 INS22 INS42 INS42 INS33 INS52 INS42 INS21 INS60 INS52 INS42 INS33 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS22 INS43 INS43 INS42 INS33 INS21 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS22 INS52 INS42 INS52 INS42 INS22 INS22 MOV21 INS52 INS42 INS39 INS59 INS22 INS22 INS22 INS22 INS22 INS52 INS42 INS22 INS24 INS22 INS22 INS22 INS22 INS52 INS42 INS24 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS22 INS32 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 UPD43 INS52 INS42 INS52 INS42 INS52 INS42 INS22 MOV38 INS42 INS43 INS42 INS43 INS42 INS38 INS52 INS42 INS52 INS42 INS22 MOV74 INS59 INS22 INS22 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 MOV5 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 MOV74 INS52 INS42 MOV74 INS59 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS22 INS7 MOV74 INS59 INS52 INS42 MOV27 INS52 INS52 INS42 INS22 INS42 INS42 INS7 INS21 INS24 INS41 INS42 INS52 INS42 INS22 INS22 INS52 INS42 INS22 INS22 INS22 INS22 INS52 INS42 INS52 INS42 MOV21 INS22 INS22 INS33 INS22 INS24 UPD42 INS42 INS42 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS58 INS32 MOV8 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS58 INS32 MOV8 INS52 INS42 INS52 INS42 MOV32 INS42 INS60 INS43 INS22 INS22 INS22 INS22 UPD42 INS22 INS22 INS40 INS22 INS52 INS42 INS14 INS22 INS52 INS22 INS22 INS42 INS42 INS22 INS52 INS42 INS22 INS22 INS42 INS14 INS22 MOV25 INS22 MOV60 INS22 MOV60 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS32 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS45 INS22 MOV21 INS22 MOV21 INS22 MOV21 INS22 MOV21 INS22 MOV21 INS22 MOV21 INS22 MOV21 INS22 MOV21 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS52 INS42 INS22 UPD42 INS22 INS22 INS22 INS52 INS22 INS22 INS42 INS14 INS22 INS52 INS42 INS52 INS42 INS33 INS22 INS52 INS42 MOV42 MOV14 INS22 INS42 INS14 INS22 INS22 INS22 INS22 MOV60 INS22 INS33 INS22 INS22 INS22 INS42 INS52 INS42 INS42 MOV32 INS41 INS7 INS58 INS27 INS37 INS21 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS22 INS52 INS42 INS52 INS42 INS22 INS22 INS52 INS42 INS52 INS42 INS22 INS58 INS32 MOV8 INS7 INS52 INS42 INS52 INS42 INS52 INS42 INS43 INS59 INS42 INS42 INS60 INS43 INS59 INS42 INS42 INS60 INS22 INS22 INS5 INS59 INS22 INS22 MOV42 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 MOV86 MOV90 UPD43 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS43 INS1 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 MOV74 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 MOV42 INS52 INS42 INS52 INS52 INS42 INS52 INS42 INS43 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS7 INS52 INS42 INS7 INS52 INS42 INS7 INS52 INS42 INS7 INS52 INS42 INS7 INS52 INS42 INS7 INS52 INS42 INS7 INS52 INS42 INS7 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS52 INS42 INS52 INS74 INS22 INS52 INS42 INS52 INS42 INS22 INS74 INS22 INS52 INS42 MOV74 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS22 INS52 INS42 MOV74 INS52 INS42 INS52 INS52 INS42 INS52 INS42 INS22 MOV33 INS42 MOV14 INS39 INS59 INS42 INS22 INS42 INS32 INS52 INS42 INS52 INS42 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS43 INS59 INS42 INS42 INS60 INS42 MOV7 INS42 INS42 INS42 INS32 MOV43 INS59 MOV32 UPD42 MOV42 INS42 INS32 INS43 INS59 INS52 INS42 INS52 INS42 INS43 INS85 INS42 INS3 UPD42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS22 INS22 INS22 INS22 INS22 INS52 INS42 MOV86 MOV90 INS22 INS22 INS22 INS22 INS22 INS22 INS22 UPD42 INS22 INS52 INS42 INS42 INS31 INS22 INS52 INS42 INS22 INS14 INS22 MOV14 INS22 INS22 INS42 INS14 INS52 INS32 INS42 INS27 INS42 INS27 INS42 INS27 INS42 INS27 INS42 INS27 INS42 INS27 INS42 INS27 INS42 INS27 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS22 INS22 INS52 INS22 INS43 INS52 INS42 INS22 INS52 INS42 INS22 INS14 INS43 INS43 INS52 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 UPD42 MOV43 INS22 INS22 INS52 INS42 INS3 INS42 INS34 MOV32 INS42 UPD42 MOV42 UPD42 MOV42 INS2 INS52 INS42 INS52 INS42 INS42 INS42 INS32 MOV43 INS59 UPD42 MOV32 INS42 INS42 INS42 INS11 UPD42 UPD42 INS42 INS42 INS42 INS42 INS11 INS42 INS5 INS4 INS52 INS42 INS22 INS22 INS22 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS52 INS42 INS52 INS42 MOV86 MOV90 INS52 INS42 MOV86 MOV90 INS52 INS42 MOV86 MOV90 INS52 INS42 MOV86 MOV90 INS52 INS42 INS52 INS42 INS52 INS78 INS83 INS39 INS42 MOV8 INS52 INS42 INS52 INS42 MOV74 INS22 INS52 INS42 INS22 INS52 INS42 INS22 INS52 INS42 MOV43 INS1 INS42 INS42 MOV27 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS42 INS45 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS42 INS42 INS52 INS42 INS42 UPD43 INS52 INS42 INS52 INS42 INS74 INS22 INS42 INS42 INS22 INS22 MOV42 MOV42 MOV74 INS22 INS52 INS42 INS52 INS42 INS42 INS5 INS4 INS32 INS42 INS32 INS22 MOV32 INS42 INS42 INS11 MOV43 INS32 INS43 INS32 INS43 INS85 MOV32 INS42 INS32 MOV32 MOV36 MOV36 INS52 INS42 INS52 INS42 INS43 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS42 INS52 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS31 INS22 INS22 INS22 INS22 INS22 INS52 INS42 INS22 UPD42 INS32 INS43 INS52 INS42 INS22 INS52 INS42 INS22 INS52 INS42 INS22 INS52 INS42 INS43 INS85 INS42 INS42 INS42 INS42 INS42 INS42 MOV27 INS22 INS52 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS42 INS42 MOV32 MOV42 INS22 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS78 INS83 INS39 INS42 MOV8 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS52 INS42 UPD43 INS3 INS42 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS40 INS42 INS42 UPD42 INS5 INS4 INS43 INS85 MOV32 MOV32 INS42 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL40 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL86 DEL42 DEL42 DEL25 DEL25 DEL42 DEL32 DEL40 DEL27 DEL25 DEL42 DEL42 DEL38 DEL42 DEL42 DEL42 DEL42 DEL52 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL86 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL14 DEL42 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL45 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL59 DEL60 DEL42 DEL31 DEL83 DEL39 DEL42 DEL31 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL40 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL41 DEL42 DEL42 DEL42 DEL41 DEL8 DEL42 DEL32 DEL14 DEL41 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL44 DEL70 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL38 DEL42 DEL44 DEL70 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL44 DEL42 DEL70 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42
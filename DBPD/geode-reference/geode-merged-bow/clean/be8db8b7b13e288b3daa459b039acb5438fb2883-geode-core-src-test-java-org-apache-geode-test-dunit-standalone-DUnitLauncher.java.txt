GEODE-1965 Create backward-compatibility unit test framework

See
https://cwiki.apache.org/confluence/display/GEODE/Writing+Backward-compatibility+DUnit+tests

This extends the distributed unit test framework to allow you to boot a
VM running an older version of Geode.  Using this extension you can create
rolling upgrade tests, client/server interoperability tests, persistent
store upgrade tests and so on.

VM numbering has not changed.  If you request that a VM use a certain
version of GEODE it will be bounced if necessary and its classpath modified
to point to that version.  The VM will continue to use that version until
bounced to a different version or the next test class is started.  All
VMs are moved to the current version at the beginning of a new test class.

Console output from versioned VMs will contain the symbolic version in use
by the VM, such as "[vm0_v100]" to help you know it is running a different
version of GEODE.

Tests are all compiled with the current Geode code, so if there are API
changes you must use reflection in order to invoke the old versions of
the API.  RollingUpgradeDUnitTests shows how to do this.

ClientServerMiscBCDUnitTest shows how to subclass an existing class to
make it run with multiple versions of Geode.  In this case the clients
are parameterized to run with older versions while servers are held to
the current version.

I will be opening a few tickets to track problems I have already encountered
with these tests.

-import batterytest.greplogs.ExpectedStrings;
-import batterytest.greplogs.LogConsumer;
+import static org.apache.geode.distributed.ConfigurationProperties.DISABLE_AUTO_RECONNECT;
+import static org.apache.geode.distributed.ConfigurationProperties.ENABLE_CLUSTER_CONFIGURATION;
+import static org.apache.geode.distributed.ConfigurationProperties.JMX_MANAGER;
+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;
+import static org.apache.geode.distributed.ConfigurationProperties.LOG_LEVEL;
+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
+import static org.apache.geode.distributed.ConfigurationProperties.USE_CLUSTER_CONFIGURATION;
+import static org.apache.geode.distributed.internal.DistributionConfig.GEMFIRE_PREFIX;
+
-import hydra.MethExecutorResult;
-
-import java.io.*;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.FileReader;
+import java.io.IOException;
-import java.rmi.*;
+import java.rmi.AccessException;
+import java.rmi.AlreadyBoundException;
+import java.rmi.NotBoundException;
+import java.rmi.Remote;
+import java.rmi.RemoteException;
-
-import static org.apache.geode.distributed.ConfigurationProperties.*;
+import batterytest.greplogs.ExpectedStrings;
+import batterytest.greplogs.LogConsumer;
+import hydra.MethExecutorResult;
- * 
+ *
- * 
+ *
-  /** change this to use a different log level in unit tests */
+  /**
+   * change this to use a different log level in unit tests
+   */
+  /**
+   * change this to have dunit/vmX directories deleted and recreated when processes are launched
+   */
+  public static final boolean MAKE_NEW_WORKING_DIRS =
+      Boolean.getBoolean("makeNewWorkingDirsOnBounce");
+
-  public static final String RMI_PORT_PARAM =
-      DistributionConfig.GEMFIRE_PREFIX + "DUnitLauncher.RMI_PORT";
-  static final String VM_NUM_PARAM = DistributionConfig.GEMFIRE_PREFIX + "DUnitLauncher.VM_NUM";
-  private static final String LAUNCHED_PROPERTY =
-      DistributionConfig.GEMFIRE_PREFIX + "DUnitLauncher.LAUNCHED";
+  public static final String RMI_PORT_PARAM = GEMFIRE_PREFIX + "DUnitLauncher.RMI_PORT";
+  static final String VM_NUM_PARAM = GEMFIRE_PREFIX + "DUnitLauncher.VM_NUM";
+  static final String VM_VERSION_PARAM = GEMFIRE_PREFIX + "DUnitLauncher.VM_VERSION";
+
+  private static final String LAUNCHED_PROPERTY = GEMFIRE_PREFIX + "DUnitLauncher.LAUNCHED";
+
+    Host.setAllVMsToCurrentVersion();
-
-
-    System.setProperty(DistributionConfig.GEMFIRE_PREFIX + "free-off-heap-memory", "true");
+    System.setProperty(GEMFIRE_PREFIX + "free-off-heap-memory", "true");
+
+
+    public BounceResult bounce(String version, int pid) throws RemoteException;
-      processManager.bounce(pid);
+      return bounce(VersionManager.CURRENT_VERSION, pid);
+    }
+
+    @Override
+    public BounceResult bounce(String version, int pid) {
+      processManager.bounce(version, pid);
-        RemoteDUnitVMIF remote = (RemoteDUnitVMIF) registry.lookup("vm" + pid);
+        RemoteDUnitVMIF remote =
+            (RemoteDUnitVMIF) registry.lookup(VM.getVMName(VersionManager.CURRENT_VERSION, pid));
+      return getVM(VersionManager.CURRENT_VERSION, n);
+    }
+    @Override
+    public VM getVM(String version, int n) {
+      if (n < getVMCount()) {
+        VM current = super.getVM(n);
+        if (!current.getVersion().equals(version)) {
+          System.out.println(
+              "Bouncing VM" + n + " from version " + current.getVersion() + " to " + version);
+          current.bounce(version);
+        }
+        return current;
+      }
+
-          for (int i = oldVMCount; i <= n; i++) {
+          // first fill in any gaps, to keep the superclass, Host, happy
+          for (int i = oldVMCount; i < n; i++) {
-          for (int i = oldVMCount; i <= n; i++) {
+          for (int i = oldVMCount; i < n; i++) {
+          // now create the one we really want
+          processManager.launchVM(version, n, false);
+          processManager.waitForVMs(STARTUP_TIMEOUT);
+          addVM(n, processManager.getStub(n));
+

MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 UPD40 INS23 INS23 INS29 INS83 INS83 INS83 INS39 INS59 MOV43 INS83 INS83 INS43 INS59 MOV43 INS31 INS31 INS31 INS65 INS42 INS32 INS42 INS42 INS27 INS21 INS83 INS43 INS42 INS44 INS44 INS43 INS78 INS83 INS43 INS42 INS44 INS8 INS44 INS78 INS83 INS43 INS42 INS44 INS8 INS44 UPD66 INS66 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS42 INS32 INS42 INS43 INS42 INS39 INS42 INS42 INS42 INS42 INS39 INS42 INS41 INS43 INS42 INS42 INS42 INS39 INS42 INS41 INS43 INS42 INS25 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS27 INS8 INS42 INS42 INS40 INS42 INS42 INS42 INS40 INS42 INS42 INS32 INS60 INS25 INS41 MOV43 INS42 INS43 INS59 INS38 INS8 INS42 INS42 INS42 INS48 INS32 INS21 INS21 INS21 INS21 INS21 MOV43 INS42 INS42 INS32 INS42 INS42 INS32 INS32 UPD27 UPD27 INS32 INS32 INS32 INS32 INS42 INS42 INS40 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS45 INS42 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL40 DEL40 DEL40 DEL45 DEL42 DEL27
GEODE-7886 Update strings tests to cover sad as well as happy paths (#4821)


Co-authored-by: Sarah Abbey <sabbey@pivotal.io>
+import org.apache.geode.cache.TimeoutException;
+import org.apache.geode.redis.internal.AutoCloseableLock;
+    long value;
-    ByteArrayWrapper valueWrapper = r.get(key);
-    /*
-     * Value does not exist
-     */
+    try (AutoCloseableLock regionLock = withRegionLock(context, key)) {
+      ByteArrayWrapper valueWrapper = r.get(key);
-    if (valueWrapper == null) {
-      byte[] newValue = INIT_VALUE_BYTES;
-      r.put(key, new ByteArrayWrapper(newValue));
-      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), INIT_VALUE_INT));
-      return;
-    }
+      /*
+       * Value does not exist
+       */
-    /*
-     * Value exists
-     */
+      if (valueWrapper == null) {
+        byte[] newValue = INIT_VALUE_BYTES;
+        r.put(key, new ByteArrayWrapper(newValue));
+        command
+            .setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), INIT_VALUE_INT));
+        return;
+      }
-    String stringValue = valueWrapper.toString();
-    long value;
-    try {
-      value = Long.parseLong(stringValue);
-    } catch (NumberFormatException e) {
+      /*
+       * Value exists
+       */
+
+      String stringValue = valueWrapper.toString();
+      try {
+        value = Long.parseLong(stringValue);
+      } catch (NumberFormatException e) {
+        command.setResponse(
+            Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_VALUE_NOT_USABLE));
+        return;
+      }
+
+      if (value == Long.MIN_VALUE) {
+        command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_OVERFLOW));
+        return;
+      }
+
+      value--;
+
+      stringValue = "" + value;
+
+      r.put(key, new ByteArrayWrapper(Coder.stringToBytes(stringValue)));
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
-          Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_VALUE_NOT_USABLE));
+          Coder.getErrorResponse(context.getByteBufAllocator(), "Thread interrupted."));
+      return;
+    } catch (TimeoutException e) {
+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
+          "Timeout acquiring lock. Please try again."));
-
-    if (value == Long.MIN_VALUE) {
-      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_OVERFLOW));
-      return;
-    }
-
-    value--;
-
-    stringValue = "" + value;
-
-    r.put(key, new ByteArrayWrapper(Coder.stringToBytes(stringValue)));
-
-

INS26 INS26 INS40 INS40 MOV60 INS54 INS58 INS8 INS12 INS12 INS43 INS59 MOV60 MOV25 MOV60 MOV54 MOV25 MOV21 MOV21 MOV21 INS44 INS8 INS44 INS8 INS42 INS42 INS32 INS43 INS42 INS21 INS21 INS41 INS43 INS42 INS21 INS41 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS32 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS45 INS42 INS42 INS32 INS45 INS42 INS42 INS42 INS42
GEODE-6008: CI Failure: ClientServerHostNameVerificationDistributedTeâ€¦ (#4839)

* GEODE-6008: CI Failure: ClientServerHostNameVerificationDistributedTest.expectConnectionFailureWhenNoHostNameInServerKey failed

The "Message distribution has terminated" failure is caused by an
unreported NullPointerException in a residual reader thread introduced
in the fix for GEODE-7727.  That fix caused a thread to say alive in a
peer-to-peer tcp/ip Connection in order to clean up the receiving side
of a socket.  The Connection shutdown method close() method, however,
releases the Connection's input buffer and nulls out the field.  The
reader thread then threw an NPE that was caught and caused the
"Message distribution has terminated" message, which is picked up as a
suspect string by the testing infrastructure.

This problem is also seen in GEODE-7894, GEODE-7871, GEODE-7873 and
GEODE-7806.

The fix is to record the fact that a residual reader thread exists and
avoid releasing the Connection's input buffer when the connection is
closed.  This lets the reader thread do the cleanup.

While testing the fix I found that the NioSslEngine was throwing an
IllegalStateException when the reader thread tried to use it in this
same situation.  This exception wasn't being caught and caused more
suspect strings to be logged.  I've changed this to a checked exception
that is already handled by the reader thread.

ClientServerHostNameVerificationDistributedTest also wasn't working on
my Mac due to its /etc/hosts configuration.  I changed the test to allow
the IP address selected by LocalHostUtil to be a valid client/server
address for the SSL certificates it generates.

* fixed failing test due to change in exceptions in NioSslEngine
+   * a Reader thread for an shared Connection will remain around in order to
+   * ensure that the socket is properly closed.
+   */
+  private volatile boolean hasResidualReaderThread;
+
+  /**
-        if (!isReceiver) {
+        if (!isReceiver && !hasResidualReaderThread()) {
+
+    if (closing.get()) {
+      return;
+    }
-    boolean isHandShakeReader = false;
+    boolean handshakeHasBeenRead = false;
-          if (!isHandShakeReader && !isReceiver && (handshakeRead || handshakeCancelled)) {
+          if (!handshakeHasBeenRead && !isReceiver && (handshakeRead || handshakeCancelled)) {
-            isHandShakeReader = true;
+            handshakeHasBeenRead = true;
+            } else {
+              // not exiting and not a Reader spawned from a ServerSocket.accept(), so
+              // let's set some state noting that this is happening
+              hasResidualReaderThread = true;
-          owner.getConduit().getCancelCriterion().checkCancelInProgress(null);
+          owner.getConduit().getCancelCriterion().checkCancelInProgress(e);
-      if (!isHandShakeReader || (sharedResource && !asyncMode)) {
+      hasResidualReaderThread = false;
+      if (!handshakeHasBeenRead || (sharedResource && !asyncMode)) {
-            remoteAddr, isHandShakeReader);
+            remoteAddr, handshakeHasBeenRead);
+   * A shared sender connection will leave a reader thread around to ensure that the
+   * socket is properly closed at this end. When that is the case isResidualReaderThread
+   * will return true.
+   */
+  public boolean hasResidualReaderThread() {
+    return hasResidualReaderThread;
+  }
+
+  /**

INS23 INS31 INS29 INS83 INS83 INS39 INS59 INS29 INS83 INS39 INS42 INS8 INS65 INS42 INS25 INS65 INS41 INS66 INS66 INS32 INS8 INS66 INS66 INS66 INS42 INS42 INS42 INS41 UPD42 INS21 INS7 INS42 INS9 INS27 UPD42 MOV38 INS38 UPD42 INS32 INS42 UPD42 INS8 INS42 UPD42 INS21 INS7 INS42 INS9 DEL33
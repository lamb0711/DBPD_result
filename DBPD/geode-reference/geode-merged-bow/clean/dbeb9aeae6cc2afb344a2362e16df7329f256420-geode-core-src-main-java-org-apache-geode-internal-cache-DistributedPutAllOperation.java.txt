Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class DistributedPutAllOperation extends AbstractUpdateOperation
-  {
+public class DistributedPutAllOperation extends AbstractUpdateOperation {
-  
+
-  
+
-  static final byte HAS_TAILKEY = (byte)0x80;
+  static final byte HAS_TAILKEY = (byte) 0x80;
-//  private boolean containsCreate = false;
-  
+  // private boolean containsCreate = false;
+
-    super(event, ((EntryEventImpl)event).getEventTime(0L));
+    super(event, ((EntryEventImpl) event).getEventTime(0L));
-  public boolean isBridgeOperation()
-  {
+  public boolean isBridgeOperation() {
-  
+
-	  return putAllData;
+    return putAllData;
-  
+
-  
+
-  public void addEntry(PutAllEntryData putAllEntry)
-  {
+  public void addEntry(PutAllEntryData putAllEntry) {
-    //cachedEvents.add(ev);
-  }
-  
-  /**
-   * Add an entry that this putall operation should distribute.
-   */
-  public void addEntry(EntryEventImpl ev)
-  {
-    this.putAllData[this.putAllDataSize] = new PutAllEntryData(ev);
-    this.putAllDataSize += 1;
-    //cachedEvents.add(ev);
+    // cachedEvents.add(ev);
-   * This method is for a special case: the callback will be called after this
-   * in hasSeenEvent() case, so we should change the status beforehand
-  public void addEntry(EntryEventImpl ev, boolean newCallbackInvoked)
-  {
+  public void addEntry(EntryEventImpl ev) {
+    this.putAllData[this.putAllDataSize] = new PutAllEntryData(ev);
+    this.putAllDataSize += 1;
+    // cachedEvents.add(ev);
+  }
+
+  /**
+   * Add an entry that this putall operation should distribute. This method is for a special case:
+   * the callback will be called after this in hasSeenEvent() case, so we should change the status
+   * beforehand
+   */
+  public void addEntry(EntryEventImpl ev, boolean newCallbackInvoked) {
-    //cachedEvents.add(ev);
+    // cachedEvents.add(ev);
-  
+
-   * @param ev
-   *           event to be added
-   * @param bucketId
-   *           message is for this bucket
+   * @param ev event to be added
+   * @param bucketId message is for this bucket
-  public void addEntry(EntryEventImpl ev, Integer bucketId)
-  {
+  public void addEntry(EntryEventImpl ev, Integer bucketId) {
-    //cachedEvents.add(ev);
+    // cachedEvents.add(ev);
-   * @param status 
-   *            whether the entry is using fake event id
+   * @param status whether the entry is using fake event id
-   * In the originating cache, this returns an iterator on the list
-   * of events caused by the putAll operation.  This is cached for
-   * listener notification purposes.  The iterator is guaranteed to return
-   * events in the order they are present in putAllData[]
+   * In the originating cache, this returns an iterator on the list of events caused by the putAll
+   * operation. This is cached for listener notification purposes. The iterator is guaranteed to
+   * return events in the order they are present in putAllData[]
+
+
-        @Unretained EntryEventImpl ev = getEventForPosition(position);
+        @Unretained
+        EntryEventImpl ev = getEventForPosition(position);
+
-  
+
-    // I do not use eventIterator here because it forces the lazy creation of EntryEventImpl by calling getEventForPosition.
-    for (int i=0; i < this.putAllDataSize; i++) {
+    // I do not use eventIterator here because it forces the lazy creation of EntryEventImpl by
+    // calling getEventForPosition.
+    for (int i = 0; i < this.putAllDataSize; i++) {
-  
+
-    LocalRegion region = (LocalRegion)this.event.getRegion();
-    @Retained EntryEventImpl ev = EntryEventImpl.create(
-        region,
-        entry.getOp(),
-        entry.getKey(), null/* value */, this.event.getCallbackArgument(),
-        false /* originRemote */,
-        this.event.getDistributedMember(),
-        this.event.isGenerateCallbacks(),
-        entry.getEventID());
+    LocalRegion region = (LocalRegion) this.event.getRegion();
+    @Retained
+    EntryEventImpl ev = EntryEventImpl.create(region, entry.getOp(), entry.getKey(),
+        null/* value */, this.event.getCallbackArgument(), false /* originRemote */,
+        this.event.getDistributedMember(), this.event.isGenerateCallbacks(), entry.getEventID());
-    ev.setPossibleDuplicate(entry.isPossibleDuplicate());
-    if (entry.versionTag != null && region.concurrencyChecksEnabled) {
-      VersionSource id = entry.versionTag.getMemberID();
-      if (id!= null) {
-        entry.versionTag.setMemberID(
-            ev.getRegion().getVersionVector().getCanonicalId(id));
+      ev.setPossibleDuplicate(entry.isPossibleDuplicate());
+      if (entry.versionTag != null && region.concurrencyChecksEnabled) {
+        VersionSource id = entry.versionTag.getMemberID();
+        if (id != null) {
+          entry.versionTag.setMemberID(ev.getRegion().getVersionVector().getCanonicalId(id));
+        }
+        ev.setVersionTag(entry.versionTag);
-      ev.setVersionTag(entry.versionTag);
-    }
-      
-    entry.event = ev;
-    returnedEv = true;
-    if (entry.getValue() == null && ev.getRegion().getAttributes().getDataPolicy() == DataPolicy.NORMAL) {
-      ev.setLocalInvalid(true);
-    }
-    ev.setNewValue(entry.getValue());
-    ev.setOldValue(entry.getOldValue());
-    CqService cqService = region.getCache().getCqService();
-    if (cqService.isRunning() && !entry.getOp().isCreate() && !ev.hasOldValue()) {
-      ev.setOldValueForQueryProcessing();
-    }
-    ev.setInvokePRCallbacks(!entry.isNotifyOnly());
-    if (getBaseEvent().getContext() != null) {
-      ev.setContext(getBaseEvent().getContext());
-    }
-    ev.callbacksInvoked(entry.isCallbacksInvoked());
-    ev.setTailKey(entry.getTailKey());
-    return ev;
+
+      entry.event = ev;
+      returnedEv = true;
+      if (entry.getValue() == null
+          && ev.getRegion().getAttributes().getDataPolicy() == DataPolicy.NORMAL) {
+        ev.setLocalInvalid(true);
+      }
+      ev.setNewValue(entry.getValue());
+      ev.setOldValue(entry.getOldValue());
+      CqService cqService = region.getCache().getCqService();
+      if (cqService.isRunning() && !entry.getOp().isCreate() && !ev.hasOldValue()) {
+        ev.setOldValueForQueryProcessing();
+      }
+      ev.setInvokePRCallbacks(!entry.isNotifyOnly());
+      if (getBaseEvent().getContext() != null) {
+        ev.setContext(getBaseEvent().getContext());
+      }
+      ev.callbacksInvoked(entry.isCallbacksInvoked());
+      ev.setTailKey(entry.getTailKey());
+      return ev;
-    
+
-    
+
-    public PutAllEntryData(DataInput in, EventID baseEventID, int idx,
-        Version version, ByteArrayDataInput bytesIn) throws IOException,
-        ClassNotFoundException {
+    public PutAllEntryData(DataInput in, EventID baseEventID, int idx, Version version,
+        ByteArrayDataInput bytesIn) throws IOException, ClassNotFoundException {
-      }
-      else {
+      } else {
-        }
-        else {
+        } else {
-        this.filterRouting = (FilterRoutingInfo)DataSerializer.readObject(in);
+        this.filterRouting = (FilterRoutingInfo) DataSerializer.readObject(in);
-      }
-      else {
+      } else {
-      sb.append("(").append(getKey()).append(",").
-        append(getValue()).append(",").
-        append(getOldValue());
+      sb.append("(").append(getKey()).append(",").append(getValue()).append(",")
+          .append(getOldValue());
-        //sb.append(",v").append(versionTag.getEntryVersion()).append(",rv"+versionTag.getRegionVersion());
+        // sb.append(",v").append(versionTag.getEntryVersion()).append(",rv"+versionTag.getRegionVersion());
-    
+
-     * Used to serialize this instances data to <code>out</code>.
-     * If changes are made to this method make sure that it is backwards
-     * compatible by creating toDataPreXX methods. Also make sure that the callers
-     * to this method are backwards compatible by creating toDataPreXX methods for
+     * Used to serialize this instances data to <code>out</code>. If changes are made to this method
+     * make sure that it is backwards compatible by creating toDataPreXX methods. Also make sure
+     * that the callers to this method are backwards compatible by creating toDataPreXX methods for
-        DataSerializer.writeByteArray((byte[])v, out);
-      }
-      else if (v instanceof CachedDeserializable) {
-        CachedDeserializable cd = (CachedDeserializable)v;
+        DataSerializer.writeByteArray((byte[]) v, out);
+      } else if (v instanceof CachedDeserializable) {
+        CachedDeserializable cd = (CachedDeserializable) v;
-      }
-      else {
+      } else {
-      if (this.filterRouting != null) bits |= FILTER_ROUTING;
+      if (this.filterRouting != null)
+        bits |= FILTER_ROUTING;
-      //TODO: Yogesh, this should be conditional, 
-      // make sure that we sent it on wire only 
+      // TODO: Yogesh, this should be conditional,
+      // make sure that we sent it on wire only
-        // fake event id should be serialized 
+        // fake event id should be serialized
-      //TODO: Yogesh, this should be conditional, 
-      // make sure that we sent it on wire only 
+      // TODO: Yogesh, this should be conditional,
+      // make sure that we sent it on wire only
-    public Object getKey()
-    {
+    public Object getKey() {
-    public Object getValue()
-    {
+    public Object getValue() {
-    
+
-    public Object getOldValue()
-    {
+    public Object getOldValue() {
-    public Long getTailKey(){
+    public Long getTailKey() {
-    
-    public void setTailKey(Long key){
+
+    public void setTailKey(Long key) {
+
-    public Operation getOp()
-    {
+    public Operation getOp() {
-    public EventID getEventID()
-    {
+    public EventID getEventID() {
-    
+
-     * @param eventId 
-     *               new event id
+     * @param eventId new event id
-    
+
-     * @param bucketId 
-     *                new bucket id
+     * @param bucketId new bucket id
-     * change event id into fake event id
-     * The algorithm is to change the threadid into 
-     * bucketid*MAX_THREAD_PER_CLIENT+oldthreadid. So from the log, we can
-     * derive the original thread id.
+     * change event id into fake event id The algorithm is to change the threadid into
+     * bucketid*MAX_THREAD_PER_CLIENT+oldthreadid. So from the log, we can derive the original
+     * thread id.
-     * @return wether current event id is fake or not 
-     *                new bucket id
+     * @return wether current event id is fake or not new bucket id
-        long threadId = ThreadIdentifier.createFakeThreadIDForBulkOp(bucketId.intValue(), eventID.getThreadID());
+        long threadId = ThreadIdentifier.createFakeThreadIDForBulkOp(bucketId.intValue(),
+            eventID.getThreadID());
-      }
-      else {
+      } else {
-      }
-      else {
+      } else {
-      }
-      else {
+      } else {
-    public EntryVersionsList () {
+    public EntryVersionsList() {
-    public EntryVersionsList (int size) {
+    public EntryVersionsList(int size) {
-      if (versionTag != null) { 
+      if (versionTag != null) {
-     * replace null membership IDs in version tags with the given member ID.
-     * VersionTags received from a server may have null IDs because they were
-     * operations  performed by that server.  We transmit them as nulls to cut
-     * costs, but have to do the swap on the receiving end (in the client)
+     * replace null membership IDs in version tags with the given member ID. VersionTags received
+     * from a server may have null IDs because they were operations performed by that server. We
+     * transmit them as nulls to cut costs, but have to do the swap on the receiving end (in the
+     * client)
+     * 
-      for (VersionTag versionTag: this) {
+      for (VersionTag versionTag : this) {
-        logger.trace(LogMarker.GII_VERSIONED_ENTRY, "serializing {} with flags 0x{}", this, Integer.toHexString(flags));
+        logger.trace(LogMarker.GII_VERSIONED_ENTRY, "serializing {} with flags 0x{}", this,
+            Integer.toHexString(flags));
-          }
-          else {
+          } else {
-            }
-            else {
+            } else {
-              }
-              else {
+              } else {
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      boolean persistent= (flags & 0x20) == 0x20;
+      boolean persistent = (flags & 0x20) == 0x20;
-        logger.debug("deserializing a InitialImageVersionedObjectList with flags 0x{}", Integer.toHexString(flags));
+        logger.debug("deserializing a InitialImageVersionedObjectList with flags 0x{}",
+            Integer.toHexString(flags));
-        int size = (int)InternalDataSerializer.readUnsignedVL(in);
+        int size = (int) InternalDataSerializer.readUnsignedVL(in);
-        for (int i=0; i<size; i++) {
+        for (int i = 0; i < size; i++) {
-          case FLAG_NULL_TAG:
-            add(null);
-            break;
-          case FLAG_FULL_TAG:
-            add(VersionTag.create(persistent, in));
-            break;
-          case FLAG_TAG_WITH_NEW_ID:
-            VersionTag tag = VersionTag.create(persistent, in);
-            ids.add(tag.getMemberID());
-            add(tag);
-            break;
-          case FLAG_TAG_WITH_NUMBER_ID:
-            tag = VersionTag.create(persistent, in);
-            int idNumber = (int)InternalDataSerializer.readUnsignedVL(in);
-            tag.setMemberID(ids.get(idNumber));
-            add(tag);
-            break;
+            case FLAG_NULL_TAG:
+              add(null);
+              break;
+            case FLAG_FULL_TAG:
+              add(VersionTag.create(persistent, in));
+              break;
+            case FLAG_TAG_WITH_NEW_ID:
+              VersionTag tag = VersionTag.create(persistent, in);
+              ids.add(tag.getMemberID());
+              add(tag);
+              break;
+            case FLAG_TAG_WITH_NUMBER_ID:
+              tag = VersionTag.create(persistent, in);
+              int idNumber = (int) InternalDataSerializer.readUnsignedVL(in);
+              tag.setMemberID(ids.get(idNumber));
+              add(tag);
+              break;
-    public void readExternal(ObjectInput in) throws IOException,
-        ClassNotFoundException {
+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
-    LocalRegion region = (LocalRegion)this.event.getRegion();
+    LocalRegion region = (LocalRegion) this.event.getRegion();
-      advisor = ((PartitionedRegion)region).getCacheDistributionAdvisor();
+      advisor = ((PartitionedRegion) region).getCacheDistributionAdvisor();
-      advisor = ((BucketRegion)region).getPartitionedRegion().getCacheDistributionAdvisor();
+      advisor = ((BucketRegion) region).getPartitionedRegion().getCacheDistributionAdvisor();
-      advisor = ((DistributedRegion)region).getCacheDistributionAdvisor();
+      advisor = ((DistributedRegion) region).getCacheDistributionAdvisor();
-    for (int i=0; i<this.putAllData.length; i++) {
-      @Unretained EntryEventImpl ev = getEventForPosition(i);
+    for (int i = 0; i < this.putAllData.length; i++) {
+      @Unretained
+      EntryEventImpl ev = getEventForPosition(i);
-//    long start = NanoTimer.getTime();
+    // long start = NanoTimer.getTime();
-//    long finish = NanoTimer.getTime();
-//    InternalDistributedSystem.getDMStats().incjChannelUpTime(finish-start);
+    // long finish = NanoTimer.getTime();
+    // InternalDistributedSystem.getDMStats().incjChannelUpTime(finish-start);
-  protected CacheOperationMessage createMessage()
- {
+  protected CacheOperationMessage createMessage() {
-   * @param bucketId
-   *               create message to send to this bucket
+   * @param bucketId create message to send to this bucket
-    for (int i=0; i<putAllDataSize; i++) {
-      prMsg.addEntry(putAllData[i]);  
+    for (int i = 0; i < putAllDataSize; i++) {
+      prMsg.addEntry(putAllData[i]);
-  public HashMap createPRMessages()
-  {
-    //getFilterRecipients(Collections.EMPTY_SET); // establish filter recipient routing information
+  public HashMap createPRMessages() {
+    // getFilterRecipients(Collections.EMPTY_SET); // establish filter recipient routing information
-    
-    for (int i=0; i<putAllDataSize; i++) {
+
+    for (int i = 0; i < putAllDataSize; i++) {
-      PutAllPRMessage prMsg = (PutAllPRMessage)prMsgMap.get(bucketId);
+      PutAllPRMessage prMsg = (PutAllPRMessage) prMsgMap.get(bucketId);
-        prMsg.setTransactionDistributed(event.getRegion().getCache().getTxManager().isDistributed());
+        prMsg
+            .setTransactionDistributed(event.getRegion().getCache().getTxManager().isDistributed());
-      // We have to set fake event id here, because we cannot derive old event id from baseId+idx as we
-      // did in DR's PutAllMessage. 
+      // We have to set fake event id here, because we cannot derive old event id from baseId+idx as
+      // we
+      // did in DR's PutAllMessage.
-  protected void initMessage(CacheOperationMessage msg,
-      DirectReplyProcessor proc)
-  {
+  protected void initMessage(CacheOperationMessage msg, DirectReplyProcessor proc) {
-    PutAllMessage m = (PutAllMessage)msg;
-    
+    PutAllMessage m = (PutAllMessage) msg;
+
-    
+
-    if (attr.getConcurrencyChecksEnabled()
-        && !attr.getDataPolicy().withReplication() 
+    if (attr.getConcurrencyChecksEnabled() && !attr.getDataPolicy().withReplication()
-        boolean success = RemotePutAllMessage.distribute((EntryEventImpl)this.event, 
+        boolean success = RemotePutAllMessage.distribute((EntryEventImpl) this.event,
-          
+
-          // Fix for #45934.  We can't continue if we need versions and we failed
+          // Fix for #45934. We can't continue if we need versions and we failed
-          boolean success = RemotePutAllMessage.distribute((EntryEventImpl)this.event,
-              versionless, versionless.length);
+          boolean success = RemotePutAllMessage.distribute((EntryEventImpl) this.event, versionless,
+              versionless.length);
-            PutAllEntryData[] versioned = selectVersionedEntries(); 
+            PutAllEntryData[] versioned = selectVersionedEntries();
-              logger.trace("Found these remaining versioned entries: {}", Arrays.toString(versioned));
+              logger.trace("Found these remaining versioned entries: {}",
+                  Arrays.toString(versioned));
-            // Fix for #45934.  We can't continue if we need versions and we failed
+            // Fix for #45934. We can't continue if we need versions and we failed
-    // bug #45704 - RemotePutAllOp's DPAO in another server conflicts with lingering DPAO from same thread, so
-    // we require an ACK if concurrency checks are enabled to make sure that the previous op has finished first.
+    // bug #45704 - RemotePutAllOp's DPAO in another server conflicts with lingering DPAO from same
+    // thread, so
+    // we require an ACK if concurrency checks are enabled to make sure that the previous op has
+    // finished first.
-    for (int i=0; i<this.putAllData.length; i++) {
+    for (int i = 0; i < this.putAllData.length; i++) {
-    for (int i=0; i<this.putAllData.length; i++) {
+    for (int i = 0; i < this.putAllData.length; i++) {
-  
+
-    for (int i=0; i<this.putAllData.length; i++) {
+    for (int i = 0; i < this.putAllData.length; i++) {
-    for (int i=0; i<this.putAllData.length; i++) {
+    for (int i = 0; i < this.putAllData.length; i++) {
-  
+
-   * version tags are gathered from local operations and remote operation
-   * responses.  This method gathers all of them and stores them in the
-   * given list.
+   * version tags are gathered from local operations and remote operation responses. This method
+   * gathers all of them and stores them in the given list.
+   * 
-    for (PutAllEntryData entry: this.putAllData) {
+    for (PutAllEntryData entry : this.putAllData) {
-  
-  
-  public static class PutAllMessage extends AbstractUpdateMessage
-   {
+
+
+  public static class PutAllMessage extends AbstractUpdateMessage {
-    
+
-    
+
-    protected static final short SKIP_CALLBACKS =
-      (short)(HAS_BRIDGE_CONTEXT << 1);
+    protected static final short SKIP_CALLBACKS = (short) (HAS_BRIDGE_CONTEXT << 1);
+
-     * Note this this is a "dummy" event since this message contains a list of
-     * entries each one of which has its own event. The key thing needed in this
-     * event is the region. This is the event that gets passed to
-     * basicOperateOnRegion
+     * Note this this is a "dummy" event since this message contains a list of entries each one of
+     * which has its own event. The key thing needed in this event is the region. This is the event
+     * that gets passed to basicOperateOnRegion
-    protected InternalCacheEvent createEvent(DistributedRegion rgn)
-    throws EntryNotFoundException
-    {
+    protected InternalCacheEvent createEvent(DistributedRegion rgn) throws EntryNotFoundException {
-      @Retained EntryEventImpl event = EntryEventImpl.create(
-          rgn,
-          Operation.PUTALL_UPDATE /* op */, null /* key */, null/* value */,
-          this.callbackArg, true /* originRemote */, getSender());
+      @Retained
+      EntryEventImpl event = EntryEventImpl.create(rgn, Operation.PUTALL_UPDATE /* op */,
+          null /* key */, null/* value */, this.callbackArg, true /* originRemote */, getSender());
-    
+
-     * Does the "put" of one entry for a "putall" operation. Note it calls back
-     * to AbstractUpdateOperation.UpdateMessage#basicOperationOnRegion
+     * Does the "put" of one entry for a "putall" operation. Note it calls back to
+     * AbstractUpdateOperation.UpdateMessage#basicOperationOnRegion
-     * @param entry
-     *          the entry being put
-     * @param rgn
-     *          the region the entry is put in
+     * @param entry the entry being put
+     * @param rgn the region the entry is put in
-      @Released EntryEventImpl ev = PutAllMessage.createEntryEvent(entry, getSender(), 
-          this.context, rgn, this.possibleDuplicate,
-          this.needsRouting, this.callbackArg, true, skipCallbacks);
-      // we don't need to set old value here, because the msg is from remote. local old value will get from next step
+      @Released
+      EntryEventImpl ev = PutAllMessage.createEntryEvent(entry, getSender(), this.context, rgn,
+          this.possibleDuplicate, this.needsRouting, this.callbackArg, true, skipCallbacks);
+      // we don't need to set old value here, because the msg is from remote. local old value will
+      // get from next step
-    
+
+     * 
-        InternalDistributedMember sender, ClientProxyMembershipID context,
-        DistributedRegion rgn,
-        boolean possibleDuplicate, boolean needsRouting, Object callbackArg,
-        boolean originRemote, boolean skipCallbacks) {
+        InternalDistributedMember sender, ClientProxyMembershipID context, DistributedRegion rgn,
+        boolean possibleDuplicate, boolean needsRouting, Object callbackArg, boolean originRemote,
+        boolean skipCallbacks) {
-      @Retained EntryEventImpl ev = EntryEventImpl.create(rgn, entry.getOp(),
-          key, null/* value */, callbackArg,
-          originRemote, sender, !skipCallbacks,
-          evId);
+      @Retained
+      EntryEventImpl ev = EntryEventImpl.create(rgn, entry.getOp(), key, null/* value */,
+          callbackArg, originRemote, sender, !skipCallbacks, evId);
-      if (context != null) {
-        ev.context = context;
-      }
-      if (entry.getValue() == null && rgn.getDataPolicy() == DataPolicy.NORMAL) {
-        ev.setLocalInvalid(true);
-      }
-      ev.setNewValue(entry.getValue());
-      ev.setPossibleDuplicate(possibleDuplicate);
-      ev.setVersionTag(entry.versionTag);
-//      if (needsRouting) {
-//               FilterProfile fp = rgn.getFilterProfile();
-//                if (fp != null) {
-//                  FilterInfo fi = fp.getLocalFilterRouting(ev);
-//                  ev.setLocalFilterInfo(fi);
-//                }
-//      }
-      if (entry.filterRouting != null) {
-        InternalDistributedMember id = rgn.getMyId();
-        ev.setLocalFilterInfo(entry.filterRouting.getFilterInfo(id));
-      }
-      /**
-       * Setting tailKey for the secondary bucket here. Tail key was update by the primary.
-       */
-      ev.setTailKey(entry.getTailKey());
-      returnedEv = true;
-      return ev;
+        if (context != null) {
+          ev.context = context;
+        }
+        if (entry.getValue() == null && rgn.getDataPolicy() == DataPolicy.NORMAL) {
+          ev.setLocalInvalid(true);
+        }
+        ev.setNewValue(entry.getValue());
+        ev.setPossibleDuplicate(possibleDuplicate);
+        ev.setVersionTag(entry.versionTag);
+        // if (needsRouting) {
+        // FilterProfile fp = rgn.getFilterProfile();
+        // if (fp != null) {
+        // FilterInfo fi = fp.getLocalFilterRouting(ev);
+        // ev.setLocalFilterInfo(fi);
+        // }
+        // }
+        if (entry.filterRouting != null) {
+          InternalDistributedMember id = rgn.getMyId();
+          ev.setLocalFilterInfo(entry.filterRouting.getFilterInfo(id));
+        }
+        /**
+         * Setting tailKey for the secondary bucket here. Tail key was update by the primary.
+         */
+        ev.setTailKey(entry.getTailKey());
+        returnedEv = true;
+        return ev;
-    protected void basicOperateOnRegion(EntryEventImpl ev, final DistributedRegion rgn)
-    {
+    protected void basicOperateOnRegion(EntryEventImpl ev, final DistributedRegion rgn) {
-      
+
-              logger.debug("putAll processing {} with {} sender={}", putAllData[i], putAllData[i].versionTag, sender);
+              logger.debug("putAll processing {} with {} sender={}", putAllData[i],
+                  putAllData[i].versionTag, sender);
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      this.putAllDataSize = (int)InternalDataSerializer.readUnsignedVL(in);
+      this.putAllDataSize = (int) InternalDataSerializer.readUnsignedVL(in);
-        final Version version = InternalDataSerializer
-            .getVersionForDataStreamOrNull(in);
+        final Version version = InternalDataSerializer.getVersionForDataStreamOrNull(in);
-          this.putAllData[i] = new PutAllEntryData(in, eventId, i, version,
-              bytesIn);
+          this.putAllData[i] = new PutAllEntryData(in, eventId, i, version, bytesIn);
-      if (this.context != null) s |= HAS_BRIDGE_CONTEXT;
-      if (this.skipCallbacks) s |= SKIP_CALLBACKS;
+      if (this.context != null)
+        s |= HAS_BRIDGE_CONTEXT;
+      if (this.skipCallbacks)
+        s |= SKIP_CALLBACKS;
-    public int getOperationCount()
-    {
+    public int getOperationCount() {
-    public ClientProxyMembershipID getContext()
-    {
+    public ClientProxyMembershipID getContext() {
-    
-    public PutAllEntryData[] getPutAllEntryData()
-    {
+
+    public PutAllEntryData[] getPutAllEntryData() {
-    
+
-    public List getOperations()
-    {
+    public List getOperations() {
-          valueBytes = ((CachedDeserializable)v).getSerializedValue();
-        }
-        else {
+          valueBytes = ((CachedDeserializable) v).getSerializedValue();
+        } else {
-          valueBytes = (byte[])v;
+          valueBytes = (byte[]) v;
-        ops[i] = new QueuedOperation(entry.getOp(), entry.getKey(), valueBytes,
-            valueObj, deserializationPolicy, this.callbackArg);
+        ops[i] = new QueuedOperation(entry.getOp(), entry.getKey(), valueBytes, valueObj,
+            deserializationPolicy, this.callbackArg);

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
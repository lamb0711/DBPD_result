GEODE-4823: OQL index not updated for tombstone (#1603)

* If the region entry is a tombstone then OQL indexes are not updated
	* The operation extracted to a external method.
-import static org.apache.geode.internal.offheap.annotations.OffHeapIdentifier.*;
+import static org.apache.geode.internal.offheap.annotations.OffHeapIdentifier.ABSTRACT_REGION_ENTRY_FILL_IN_VALUE;
+import static org.apache.geode.internal.offheap.annotations.OffHeapIdentifier.ABSTRACT_REGION_ENTRY_PREPARE_VALUE_FOR_CACHE;
-import org.apache.geode.internal.cache.GemFireCacheImpl;
-import org.apache.geode.internal.cache.RegionEntry;
-      if (!region.isProxy() && !isInvalid()) {
-        IndexManager indexManager = region.getIndexManager();
-        if (indexManager != null) {
-          try {
-            if (isValueNull()) {
-              @Released
-              Object value = getValueOffHeapOrDiskWithoutFaultIn(region);
-              try {
-                Object preparedValue = prepareValueForCache(region, value, false);
-                _setValue(preparedValue);
-                releaseOffHeapRefIfRegionBeingClosedOrDestroyed(region, preparedValue);
-              } finally {
-                OffHeapHelper.release(value);
-              }
-            }
-            indexManager.updateIndexes(this, IndexManager.REMOVE_ENTRY, IndexProtocol.OTHER_OP);
-          } catch (QueryException e) {
-            throw new IndexMaintenanceException(e);
-          }
-        }
-      }
+      updateIndexOnDestroyOperation(region);
+  protected void updateIndexOnDestroyOperation(InternalRegion region) {
+    if (!isTombstone() && !region.isProxy() && !isInvalid()) {
+      IndexManager indexManager = region.getIndexManager();
+      if (indexManager != null) {
+        try {
+          if (isValueNull()) {
+            @Released
+            Object value = getValueOffHeapOrDiskWithoutFaultIn(region);
+            try {
+              Object preparedValue = prepareValueForCache(region, value, false);
+              _setValue(preparedValue);
+              releaseOffHeapRefIfRegionBeingClosedOrDestroyed(region, preparedValue);
+            } finally {
+              OffHeapHelper.release(value);
+            }
+          }
+          indexManager.updateIndexes(this, IndexManager.REMOVE_ENTRY, IndexProtocol.OTHER_OP);
+        } catch (QueryException e) {
+          throw new IndexMaintenanceException(e);
+        }
+      }
+    }
+  }
+

MOV26 UPD40 UPD40 INS31 INS83 INS39 INS42 INS44 INS8 INS43 INS42 MOV25 INS42 INS21 INS38 INS32 INS32 INS42 INS42 INS42 DEL40 DEL26
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A connection source which uses locators to find
- * the least loaded server.
+ * A connection source which uses locators to find the least loaded server.
+ * 
-  
+
-  
+
-  private static final Comparator<InetSocketAddress> SOCKET_ADDRESS_COMPARATOR = new Comparator<InetSocketAddress>() {
-    public int compare(InetSocketAddress o1,InetSocketAddress o2){
-      //shouldn't happen, but if it does we'll say they're the same.
-      if(o1.getAddress() == null || o2.getAddress() == null) {
-        return 0;
-      }
-      
-      int result = o1.getAddress().getCanonicalHostName().compareTo(o2.getAddress().getCanonicalHostName());
-      if(result != 0) {
-        return result;
-      }
-      
-      else return o1.getPort() - o2.getPort();
-    }
-  };
+  private static final Comparator<InetSocketAddress> SOCKET_ADDRESS_COMPARATOR =
+      new Comparator<InetSocketAddress>() {
+        public int compare(InetSocketAddress o1, InetSocketAddress o2) {
+          // shouldn't happen, but if it does we'll say they're the same.
+          if (o1.getAddress() == null || o2.getAddress() == null) {
+            return 0;
+          }
+
+          int result = o1.getAddress().getCanonicalHostName()
+              .compareTo(o2.getAddress().getCanonicalHostName());
+          if (result != 0) {
+            return result;
+          }
+
+      else
+            return o1.getPort() - o2.getPort();
+        }
+      };
-  private final int connectionTimeout;  
+  private final int connectionTimeout;
-   * key is the InetSocketAddress of the locator.
-   * value will be an exception if we have already found the locator to be dead.
-   * value will be null if we last saw him alive.
+   * key is the InetSocketAddress of the locator. value will be an exception if we have already
+   * found the locator to be dead. value will be null if we last saw him alive.
-  private final Map<InetSocketAddress,Exception> locatorState = new HashMap<InetSocketAddress,Exception>();
-  
+  private final Map<InetSocketAddress, Exception> locatorState =
+      new HashMap<InetSocketAddress, Exception>();
+
-  public AutoConnectionSourceImpl(List<InetSocketAddress>contacts, String serverGroup, int handshakeTimeout) {
+  public AutoConnectionSourceImpl(List<InetSocketAddress> contacts, String serverGroup,
+      int handshakeTimeout) {
-  
+
-  public ServerLocation findReplacementServer(ServerLocation currentServer, Set/*<ServerLocation>*/ excludedServers) {
-    if(PoolImpl.TEST_DURABLE_IS_NET_DOWN) {
+  public ServerLocation findReplacementServer(ServerLocation currentServer,
+      Set/* <ServerLocation> */ excludedServers) {
+    if (PoolImpl.TEST_DURABLE_IS_NET_DOWN) {
-    ClientReplacementRequest request  = new ClientReplacementRequest(currentServer, excludedServers, serverGroup);
+    ClientReplacementRequest request =
+        new ClientReplacementRequest(currentServer, excludedServers, serverGroup);
-    if (response==null) {
+    if (response == null) {
-      //getLogger().warning("Unable to connect to any locators in the list " + locators);
-      throw new NoAvailableLocatorsException("Unable to connect to any locators in the list " + locators);
+      // getLogger().warning("Unable to connect to any locators in the list " + locators);
+      throw new NoAvailableLocatorsException(
+          "Unable to connect to any locators in the list " + locators);
-//    if(getLogger().fineEnabled()) {
-//      getLogger().fine("Received client connection response with server " + response.getServer());
-//    }
-    
+    // if(getLogger().fineEnabled()) {
+    // getLogger().fine("Received client connection response with server " + response.getServer());
+    // }
+
-    if(PoolImpl.TEST_DURABLE_IS_NET_DOWN) {
+    if (PoolImpl.TEST_DURABLE_IS_NET_DOWN) {
-    ClientConnectionRequest request  = new ClientConnectionRequest(excludedServers, serverGroup);
+    ClientConnectionRequest request = new ClientConnectionRequest(excludedServers, serverGroup);
-    if (response==null) {
+    if (response == null) {
-      //getLogger().warning("Unable to connect to any locators in the list " + locators);
-      throw new NoAvailableLocatorsException("Unable to connect to any locators in the list " + locators);
+      // getLogger().warning("Unable to connect to any locators in the list " + locators);
+      throw new NoAvailableLocatorsException(
+          "Unable to connect to any locators in the list " + locators);
-//    if(getLogger().fineEnabled()) {
-//      getLogger().fine("Received client connection response with server " + response.getServer());
-//    }
-    
+    // if(getLogger().fineEnabled()) {
+    // getLogger().fine("Received client connection response with server " + response.getServer());
+    // }
+
-  
-  
+
+
-    GetAllServersResponse response = (GetAllServersResponse)queryLocators(request);
-    if(response != null){
+    GetAllServersResponse response = (GetAllServersResponse) queryLocators(request);
+    if (response != null) {
-    }else {
-      return null ;
+    } else {
+      return null;
-  
-  public List/* ServerLocation */findServersForQueue(      
-      Set/* <ServerLocation> */excludedServers, int numServers,
-      ClientProxyMembershipID proxyId, boolean findDurableQueue) {
-    if(PoolImpl.TEST_DURABLE_IS_NET_DOWN) {
+
+  public List/* ServerLocation */ findServersForQueue(Set/* <ServerLocation> */ excludedServers,
+      int numServers, ClientProxyMembershipID proxyId, boolean findDurableQueue) {
+    if (PoolImpl.TEST_DURABLE_IS_NET_DOWN) {
-    QueueConnectionRequest request  = new QueueConnectionRequest(proxyId,numServers,excludedServers, serverGroup,findDurableQueue);
+    QueueConnectionRequest request = new QueueConnectionRequest(proxyId, numServers,
+        excludedServers, serverGroup, findDurableQueue);
-    if (response==null) {
-      throw new NoAvailableLocatorsException("Unable to connect to any locators in the list " + locators);
+    if (response == null) {
+      throw new NoAvailableLocatorsException(
+          "Unable to connect to any locators in the list " + locators);
-  
-  
-  private ServerLocationResponse queryOneLocator(InetSocketAddress locator, ServerLocationRequest request) {
+
+
+  private ServerLocationResponse queryOneLocator(InetSocketAddress locator,
+      ServerLocationRequest request) {
-      ServerLocationResponse response = (ServerLocationResponse)returnObj; 
+      ServerLocationResponse response = (ServerLocationResponse) returnObj;
-      if(response != null) {
+      if (response != null) {
-    } catch(IOException ioe) {
+    } catch (IOException ioe) {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.AutoConnectionSourceImpl_RECEIVED_EXCEPTION_FROM_LOCATOR_0, locator), e);
-      return null;    
+      logger.warn(
+          LocalizedMessage.create(
+              LocalizedStrings.AutoConnectionSourceImpl_RECEIVED_EXCEPTION_FROM_LOCATOR_0, locator),
+          e);
+      return null;
-    
+
-    } while(controllerItr.hasNext() && (response == null || !response.hasResult()));
-    
-    if(response == null) {
+    } while (controllerItr.hasNext() && (response == null || !response.hasResult()));
+
+    if (response == null) {
-    
+
-    if (response == null) return;
+    if (response == null)
+      return;
-    List<InetSocketAddress> newLocators  = new ArrayList<InetSocketAddress>(locatorResponse.size());
+    List<InetSocketAddress> newLocators = new ArrayList<InetSocketAddress>(locatorResponse.size());
-    Set<InetSocketAddress> badLocators  = new HashSet<InetSocketAddress>(initialLocators);
-    for(Iterator<ServerLocation> itr = locatorResponse.iterator(); itr.hasNext(); ) {
-      ServerLocation locator =  itr.next();
+    Set<InetSocketAddress> badLocators = new HashSet<InetSocketAddress>(initialLocators);
+    for (Iterator<ServerLocation> itr = locatorResponse.iterator(); itr.hasNext();) {
+      ServerLocation locator = itr.next();
-    if(logger.isInfoEnabled()) {
+    if (logger.isInfoEnabled()) {
-      ArrayList<InetSocketAddress> removedLocators  = new ArrayList<InetSocketAddress>(oldLocators.getLocators());
+      ArrayList<InetSocketAddress> removedLocators =
+          new ArrayList<InetSocketAddress>(oldLocators.getLocators());
-      ArrayList<InetSocketAddress> addedLocators  = new ArrayList<InetSocketAddress>(newLocators);
+      ArrayList<InetSocketAddress> addedLocators = new ArrayList<InetSocketAddress>(newLocators);
-      if(!addedLocators.isEmpty()) {
+      if (!addedLocators.isEmpty()) {
-        logger.info(LocalizedMessage.create(LocalizedStrings.AutoConnectionSourceImpl_AUTOCONNECTIONSOURCE_DISCOVERED_NEW_LOCATORS_0, addedLocators));
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.AutoConnectionSourceImpl_AUTOCONNECTIONSOURCE_DISCOVERED_NEW_LOCATORS_0,
+            addedLocators));
-      if(!removedLocators.isEmpty()) {
+      if (!removedLocators.isEmpty()) {
-        logger.info(LocalizedMessage.create(LocalizedStrings.AutoConnectionSourceImpl_AUTOCONNECTIONSOURCE_DROPPING_PREVIOUSLY_DISCOVERED_LOCATORS_0, removedLocators));
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.AutoConnectionSourceImpl_AUTOCONNECTIONSOURCE_DROPPING_PREVIOUSLY_DISCOVERED_LOCATORS_0,
+            removedLocators));
-    pool.getStats().setInitialContacts(((LocatorList)locators.get()).size());
+    pool.getStats().setInitialContacts(((LocatorList) locators.get()).size());
-    
-    pool.getBackgroundProcessor().scheduleWithFixedDelay(new UpdateLocatorListTask(), 0, pingInterval, TimeUnit.MILLISECONDS);
+
+    pool.getBackgroundProcessor().scheduleWithFixedDelay(new UpdateLocatorListTask(), 0,
+        pingInterval, TimeUnit.MILLISECONDS);
-    
+
-  
+
-  
+
-      logger.info(LocalizedMessage.create(LocalizedStrings.AutoConnectionSourceImpl_COMMUNICATION_HAS_BEEN_RESTORED_WITH_LOCATOR_0, l));
+      logger.info(LocalizedMessage.create(
+          LocalizedStrings.AutoConnectionSourceImpl_COMMUNICATION_HAS_BEEN_RESTORED_WITH_LOCATOR_0,
+          l));
-  
+
-        logger.info(LocalizedMessage.create(LocalizedStrings.AutoConnectionSourceImpl_LOCATOR_0_IS_NOT_RUNNING, l),ex);
+        logger.info(LocalizedMessage
+            .create(LocalizedStrings.AutoConnectionSourceImpl_LOCATOR_0_IS_NOT_RUNNING, l), ex);
-            new Object[] {l, ex}),ex);
+            new Object[] {l, ex}), ex);
-  
-  /** A list of locators, which
-   * remembers the last known good locator.
+
+  /**
+   * A list of locators, which remembers the last known good locator.
-    
+
-    
+
-    
+
-    
-    
+
+
-     * An iterator which iterates all of the controllers,
-     * starting at the last known good controller.
+     * An iterator which iterates all of the controllers, starting at the last known good
+     * controller.
-      private int startLocator= currentLocatorIndex.get();
+      private int startLocator = currentLocatorIndex.get();
-      
+
-      
+
-        if(!hasNext()) {
+        if (!hasNext()) {
-      
+
-  
+
-      if(pool.getCancelCriterion().isCancelInProgress()) {
+      if (pool.getCancelCriterion().isCancelInProgress()) {

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66
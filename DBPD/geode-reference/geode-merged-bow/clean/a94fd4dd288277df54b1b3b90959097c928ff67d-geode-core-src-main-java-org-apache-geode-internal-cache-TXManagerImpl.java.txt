GEODE-3516: Avoid tryResume call to add the thread again into the waiting thread queue

    Avoid tryResume add a thread multiple times into the waiting queue.
    Add a unit test that verify the fix.

+  Queue<Thread> getWaitQueue(TransactionId transactionId) {
+    return waitMap.get(transactionId);
+  }
+
+  private Queue<Thread> getOrCreateWaitQueue(TransactionId transactionId) {
+    Queue<Thread> threadq = getWaitQueue(transactionId);
+    if (threadq == null) {
+      threadq = new ConcurrentLinkedQueue<Thread>();
+      Queue<Thread> oldq = waitMap.putIfAbsent(transactionId, threadq);
+      if (oldq != null) {
+        threadq = oldq;
+      }
+    }
+    return threadq;
+  }
+
-    Thread currentThread = Thread.currentThread();
-    long timeout = unit.toNanos(time);
-    long startTime = System.nanoTime();
-    Queue<Thread> threadq = null;
+    final Thread currentThread = Thread.currentThread();
+    final long endTime = System.nanoTime() + unit.toNanos(time);
+    final Queue<Thread> threadq = getOrCreateWaitQueue(transactionId);
-        threadq = waitMap.get(transactionId);
-        if (threadq == null) {
-          threadq = new ConcurrentLinkedQueue<Thread>();
-          Queue<Thread> oldq = waitMap.putIfAbsent(transactionId, threadq);
-          if (oldq != null) {
-            threadq = oldq;
-          }
+        if (!threadq.contains(currentThread)) {
+          threadq.add(currentThread);
-        threadq.add(currentThread);
-        // after putting this thread in waitMap, we should check for
-        // an entry in suspendedTXs. if no entry is found in suspendedTXs
-        // next invocation of suspend() will unblock this thread
-        } else if (!exists(transactionId)) {
+        }
+        if (!exists(transactionId)) {
-        LockSupport.parkNanos(timeout);
-        long nowTime = System.nanoTime();
-        timeout -= nowTime - startTime;
-        startTime = nowTime;
-        if (timeout <= 0) {
-          break;
+        long parkTimeout = endTime - System.nanoTime();
+        if (parkTimeout <= 0) {
+          return false;
+        parkToRetryResume(parkTimeout);
-      threadq = waitMap.get(transactionId);
-      if (threadq != null) {
-        threadq.remove(currentThread);
-        // the queue itself will be removed at commit/rollback
-      }
+      threadq.remove(currentThread);
+      // the queue itself will be removed at commit/rollback
-    return false;
+  }
+
+  void parkToRetryResume(long timeout) {
+    LockSupport.parkNanos(timeout);

INS31 INS31 INS31 INS74 INS42 INS44 INS8 INS83 INS74 INS42 INS44 MOV8 INS39 INS42 INS44 INS8 INS43 INS43 INS43 INS42 INS41 INS43 INS43 INS43 INS42 MOV60 INS41 INS39 INS42 MOV21 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS83 INS83 INS83 INS74 INS8 MOV8 INS32 UPD42 INS27 INS43 INS43 UPD42 INS61 INS42 INS42 INS32 MOV32 INS42 INS42 UPD42 UPD42 MOV9 INS8 INS42 INS42 INS25 MOV25 MOV25 MOV60 MOV25 INS21 INS38 INS8 UPD27 INS8 INS32 INS32 MOV21 INS42 INS27 UPD42 INS34 MOV41 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 MOV32 DEL33 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL27 DEL7 DEL21 DEL42 DEL42 DEL7 DEL21 DEL42 DEL34 DEL27 DEL10 DEL8 DEL25 DEL39 DEL42 DEL33 DEL61 DEL8 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8
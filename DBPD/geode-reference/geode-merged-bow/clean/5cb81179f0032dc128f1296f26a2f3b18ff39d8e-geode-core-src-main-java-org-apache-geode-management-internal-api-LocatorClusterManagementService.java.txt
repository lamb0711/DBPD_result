Merge geode develop branch

+import static org.apache.geode.management.api.ClusterManagementResult.StatusCode.ENTITY_EXISTS;
+import static org.apache.geode.management.api.ClusterManagementResult.StatusCode.ENTITY_NOT_FOUND;
+import static org.apache.geode.management.api.ClusterManagementResult.StatusCode.ERROR;
+import static org.apache.geode.management.api.ClusterManagementResult.StatusCode.ILLEGAL_ARGUMENT;
+
+import org.apache.geode.management.api.ClusterManagementException;
+import org.apache.geode.management.api.ClusterManagementRealizationException;
-import org.apache.geode.management.internal.exceptions.EntityNotFoundException;
+import org.apache.geode.management.internal.exceptions.EntityExistsException;
-      return new ClusterManagementRealizationResult(false,
-          "Cluster configuration service needs to be enabled");
+      return assertSuccessful(new ClusterManagementRealizationResult(false,
+          "Cluster configuration service needs to be enabled"));
-    // first validate common attributes of all configuration object
-    commonValidator.validate(CacheElementOperation.CREATE, config);
-
-    ConfigurationValidator validator = validators.get(config.getClass());
-    if (validator != null) {
-      validator.validate(CacheElementOperation.CREATE, config);
+    try {
+      // first validate common attributes of all configuration object
+      commonValidator.validate(CacheElementOperation.CREATE, config);
+
+      ConfigurationValidator validator = validators.get(config.getClass());
+      if (validator != null) {
+        validator.validate(CacheElementOperation.CREATE, config);
+      }
+
+      // check if this config already exists on all/some members of this group
+      memberValidator.validateCreate(config, configurationManager);
+      // execute function on all members
+    } catch (EntityExistsException e) {
+      raise(ENTITY_EXISTS, e);
+    } catch (IllegalArgumentException e) {
+      raise(ILLEGAL_ARGUMENT, e);
-    // check if this config already exists on all/some members of this group
-    memberValidator.validateCreate(config, configurationManager);
-
-    // execute function on all members
-
-      return result;
+      return assertSuccessful(result);
-    return result;
+    return assertSuccessful(result);
-      return new ClusterManagementRealizationResult(false,
-          "Cluster configuration service needs to be enabled");
+      return assertSuccessful(new ClusterManagementRealizationResult(false,
+          "Cluster configuration service needs to be enabled"));
-    // first validate common attributes of all configuration object
-    commonValidator.validate(CacheElementOperation.DELETE, config);
+    try {
+      // first validate common attributes of all configuration object
+      commonValidator.validate(CacheElementOperation.DELETE, config);
-    ConfigurationValidator validator = validators.get(config.getClass());
-    if (validator != null) {
-      validator.validate(CacheElementOperation.DELETE, config);
+      ConfigurationValidator validator = validators.get(config.getClass());
+      if (validator != null) {
+        validator.validate(CacheElementOperation.DELETE, config);
+      }
+    } catch (IllegalArgumentException e) {
+      raise(ILLEGAL_ARGUMENT, e);
-      throw new EntityNotFoundException("Cache element '" + config.getId() + "' does not exist");
+      raise(ENTITY_NOT_FOUND, "Cache element '" + config.getId() + "' does not exist");
-    return result;
+    return assertSuccessful(result);
-      return new ClusterManagementListResult<>(false,
-          "Cluster configuration service needs to be enabled");
+      return assertSuccessful(new ClusterManagementListResult<>(false,
+          "Cluster configuration service needs to be enabled"));
-    return result;
+    return assertSuccessful(result);
-      throw new EntityNotFoundException(
+      raise(ENTITY_NOT_FOUND,
-      throw new IllegalStateException(
-          "Expect only one matching " + config.getClass().getSimpleName());
+      raise(ERROR, "Expect only one matching " + config.getClass().getSimpleName());
-    return list;
+    return assertSuccessful(list);
-    CompletableFuture<V> future = operationInstance.getFutureResult();
-    return toClusterManagementListOperationsResult(result, operationInstance);
+    return assertSuccessful(toClusterManagementListOperationsResult(result, operationInstance));
-    return new ClusterManagementListOperationsResult<>(
+    return assertSuccessful(new ClusterManagementListOperationsResult<>(
-            .map(this::toClusterManagementListOperationsResult).collect(Collectors.toList()));
+            .map(this::toClusterManagementListOperationsResult).collect(Collectors.toList())));
-      throw new EntityNotFoundException("Operation id = " + opId + " not found");
+      raise(ENTITY_NOT_FOUND, "Operation id = " + opId + " not found");
-  @Override
+  private <T extends ClusterManagementResult> T assertSuccessful(T result) {
+    if (!result.isSuccessful()) {
+      if (result instanceof ClusterManagementRealizationResult) {
+        throw new ClusterManagementRealizationException(
+            (ClusterManagementRealizationResult) result);
+      } else {
+        throw new ClusterManagementException(result);
+      }
+    }
+    return result;
+  }
+
+  private static void raise(StatusCode statusCode, String statusMessage) {
+    throw new ClusterManagementException(new ClusterManagementResult(statusCode, statusMessage));
+  }
+
+  private static void raise(StatusCode statusCode, Exception e) {
+    throw new ClusterManagementException(new ClusterManagementResult(statusCode, e.getMessage()),
+        e);
+  }
+
-      throw new IllegalArgumentException(String.format("Configuration type %s is not supported",
+      raise(ILLEGAL_ARGUMENT, String.format("Configuration type %s is not supported",

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS31 INS31 INS31 INS31 INS83 INS73 INS43 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS8 MOV83 MOV39 MOV42 MOV8 INS54 INS54 INS41 INS42 INS43 INS42 INS43 INS42 INS25 MOV41 INS43 INS42 INS43 INS42 INS53 INS43 INS42 INS43 INS42 INS53 INS8 INS12 INS12 INS32 INS8 INS12 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS38 INS8 INS42 INS42 INS14 INS42 INS42 INS14 MOV21 MOV60 MOV25 MOV21 INS44 INS8 INS44 INS8 INS42 INS42 MOV21 MOV60 MOV25 INS44 INS8 INS21 INS42 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS42 MOV32 INS42 MOV14 INS21 INS32 INS25 INS43 INS14 INS43 INS14 INS42 INS21 INS32 INS43 INS42 INS21 INS43 INS42 INS21 INS32 INS32 MOV43 INS42 INS21 INS32 INS32 INS32 INS32 INS32 INS42 INS42 INS62 INS8 INS8 INS42 INS43 INS42 INS42 INS42 INS43 INS42 INS32 INS32 INS42 MOV14 INS42 INS32 INS42 INS32 INS42 INS42 INS42 MOV14 INS32 INS42 INS42 MOV27 INS42 MOV14 INS42 INS42 MOV27 INS42 INS42 MOV27 INS42 INS42 MOV27 INS42 INS43 INS53 INS53 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS14 INS43 INS11 INS43 INS42 INS42 INS43 INS42 INS42 INS42 DEL42 DEL42 DEL42 DEL43 DEL14 DEL53 DEL42 DEL42 DEL43 DEL14 DEL53 DEL42 DEL43 DEL14 DEL53 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL14 DEL53 DEL42 DEL78 DEL31 DEL14 DEL53
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class processes responses to {@link DistributionMessage}s. It
- * handles a the generic case of simply waiting for responses from all
- * members.  It is intended to be subclassed for special cases.
+ * This class processes responses to {@link DistributionMessage}s. It handles a the generic case of
+ * simply waiting for responses from all members. It is intended to be subclassed for special cases.
- * Note that, unlike the reply processors in versions previous to
- * GemFire 2.1, this reply processor is kept entirely in JOM.
+ * Note that, unlike the reply processors in versions previous to GemFire 2.1, this reply processor
+ * is kept entirely in JOM.
- * Recommended usage pattern in subclass...<pre>
+ * Recommended usage pattern in subclass...
+ * 
+ * <pre>
- * </pre>The above usage pattern causes the waitForReplies latch to not
- * be released until after the message has been processed. In addition, it is
- * guaranteed to be released even if the custom subclass code throws a
- * runtime exception.
+ * </pre>
+ * 
+ * The above usage pattern causes the waitForReplies latch to not be released until after the
+ * message has been processed. In addition, it is guaranteed to be released even if the custom
+ * subclass code throws a runtime exception.
-public class ReplyProcessor21
-    implements MembershipListener {
+public class ReplyProcessor21 implements MembershipListener {
-  
-  public final static boolean THROW_EXCEPTION_ON_TIMEOUT = Boolean.getBoolean("ack-threshold-exception");
-  /** the ratio by which ack-severe-alert-threshold is lowered when
-   *  waiting for a BucketRegion operation */
+  public final static boolean THROW_EXCEPTION_ON_TIMEOUT =
+      Boolean.getBoolean("ack-threshold-exception");
+
+  /**
+   * the ratio by which ack-severe-alert-threshold is lowered when waiting for a BucketRegion
+   * operation
+   */
-  ////////////////////  Instance Methods  ////////////////////
+  //////////////////// Instance Methods ////////////////////
-  /** 
+  /**
-   * Set to true in preWait, set to false in postWait. Used to avoid removing
-   * membership listener in Runnable in postWait if we've called waitForReplies
-   * again.
+   * Set to true in preWait, set to false in postWait. Used to avoid removing membership listener in
+   * Runnable in postWait if we've called waitForReplies again.
-  /** An <code>Exception</code> that occurred when processing a
-   * reply
+  /**
+   * An <code>Exception</code> that occurred when processing a reply
-   * Since this is set by the executor and read by the initiating thread,
-   * this is a volatile.
+   * Since this is set by the executor and read by the initiating thread, this is a volatile.
-   * @see ReplyMessage#getException */
+   * @see ReplyMessage#getException
+   */
-  /** Used to get the ack wait threshold (which might change at
-   * runtime), etc. */
+  /**
+   * Used to get the ack wait threshold (which might change at runtime), etc.
+   */
-  /** whether this reply processor should perform severe-alert processing
-   *  for the message being ack'd */
+  /**
+   * whether this reply processor should perform severe-alert processing for the message being ack'd
+   */
-  /** whether the severe-alert timeout has been reset.  This can happen
-   *  if a member we're waiting for is waiting on a suspect member, for instance.
+  /**
+   * whether the severe-alert timeout has been reset. This can happen if a member we're waiting for
+   * is waiting on a suspect member, for instance.
-  /** whether this reply processor should shorten severe-alert processing
-   *  due to another vm waiting on this one.  This is a thread-local so that
-   *  lower level comm layers can tell that the interval should be shortened
+  /**
+   * whether this reply processor should shorten severe-alert processing due to another vm waiting
+   * on this one. This is a thread-local so that lower level comm layers can tell that the interval
+   * should be shortened
-   * whether the next replyProcessor for the current thread should
-   * perform severe-alert processing
+   * whether the next replyProcessor for the current thread should perform severe-alert processing
-  //////////////////////  Static Methods  /////////////////////
+  ////////////////////// Static Methods /////////////////////
-    String str = System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "ack-severe-alert-reduction-ratio", ".80");
+    String str = System
+        .getProperty(DistributionConfig.GEMFIRE_PREFIX + "ack-severe-alert-reduction-ratio", ".80");
-    }
-    catch (NumberFormatException e) {
-      System.err.println("Unable to parse gemfire.ack-severe-alert-reduction-ratio setting of \"" + str + "\"");
+    } catch (NumberFormatException e) {
+      System.err.println(
+          "Unable to parse gemfire.ack-severe-alert-reduction-ratio setting of \"" + str + "\"");
-  
+
-   * Returns the <code>ReplyProcessor</code> with the given
-   * id, or <code>null</code> if it no longer exists.
+   * Returns the <code>ReplyProcessor</code> with the given id, or <code>null</code> if it no longer
+   * exists.
-   * @param processorId
-   *        The id of the processor to get
+   * @param processorId The id of the processor to get
-    return (ReplyProcessor21)keeper.retrieve(processorId);
+    return (ReplyProcessor21) keeper.retrieve(processorId);
-  ///////////////////////  Constructors  //////////////////////
+  /////////////////////// Constructors //////////////////////
-   * Creates a new <code>ReplyProcessor</code> that wants replies from
-   * a single member of a distributed system.
+   * Creates a new <code>ReplyProcessor</code> that wants replies from a single member of a
+   * distributed system.
-  public ReplyProcessor21(InternalDistributedSystem system,
-                          InternalDistributedMember member) {
+  public ReplyProcessor21(InternalDistributedSystem system, InternalDistributedMember member) {
-   * Creates a new <code>ReplyProcessor</code> that wants replies from
-   * a single member of a distributed system.
+   * Creates a new <code>ReplyProcessor</code> that wants replies from a single member of a
+   * distributed system.
-   * @param cancelCriterion optional CancelCriterion to use; will use the
-   *  DistributionManager if null
+   * @param cancelCriterion optional CancelCriterion to use; will use the DistributionManager if
+   *        null
-  public ReplyProcessor21(InternalDistributedSystem system,
-                          InternalDistributedMember member,
-                          CancelCriterion cancelCriterion) {
+  public ReplyProcessor21(InternalDistributedSystem system, InternalDistributedMember member,
+      CancelCriterion cancelCriterion) {
-   * Creates a new <code>ReplyProcessor</code> that wants replies from
-   * a single member of a distributed system.
+   * Creates a new <code>ReplyProcessor</code> that wants replies from a single member of a
+   * distributed system.
-  public ReplyProcessor21(DM dm,
-                          InternalDistributedMember member) {
+  public ReplyProcessor21(DM dm, InternalDistributedMember member) {
-   * Creates a new <code>ReplyProcessor</code> that wants replies from
-   * some number of members of a distributed system. Call this method
-   * with {@link DistributionManager#getDistributionManagerIds} if
-   * you want replies from all DMs including the one hosted in this
-   * VM.
+   * Creates a new <code>ReplyProcessor</code> that wants replies from some number of members of a
+   * distributed system. Call this method with {@link DistributionManager#getDistributionManagerIds}
+   * if you want replies from all DMs including the one hosted in this VM.
-  public ReplyProcessor21(DM dm,
-                          Collection initMembers) {
+  public ReplyProcessor21(DM dm, Collection initMembers) {
-   * Creates a new <code>ReplyProcessor</code> that wants replies from
-   * some number of members of a distributed system. Call this method
-   * with {@link DistributionManager#getDistributionManagerIds} if
-   * you want replies from all DMs including the one hosted in this
-   * VM.
+   * Creates a new <code>ReplyProcessor</code> that wants replies from some number of members of a
+   * distributed system. Call this method with {@link DistributionManager#getDistributionManagerIds}
+   * if you want replies from all DMs including the one hosted in this VM.
-  public ReplyProcessor21(InternalDistributedSystem system,
-                          Collection initMembers) {
+  public ReplyProcessor21(InternalDistributedSystem system, Collection initMembers) {
-   * Creates a new <code>ReplyProcessor</code> that wants replies from
-   * some number of members of a distributed system. Call this method
-   * with {@link DistributionManager#getDistributionManagerIds} if
-   * you want replies from all DMs including the one hosted in this
-   * VM.
+   * Creates a new <code>ReplyProcessor</code> that wants replies from some number of members of a
+   * distributed system. Call this method with {@link DistributionManager#getDistributionManagerIds}
+   * if you want replies from all DMs including the one hosted in this VM.
-   * @param cancelCriterion optional CancelCriterion to use; will use the
-   * DistributedSystem's DistributionManager if null
+   * @param cancelCriterion optional CancelCriterion to use; will use the DistributedSystem's
+   *        DistributionManager if null
-  public ReplyProcessor21(InternalDistributedSystem system,
-                          Collection initMembers,
-                          CancelCriterion cancelCriterion) {
+  public ReplyProcessor21(InternalDistributedSystem system, Collection initMembers,
+      CancelCriterion cancelCriterion) {
-   * @param cancelCriterion optional CancelCriterion to use; will use the dm
-   * if null
+   * @param cancelCriterion optional CancelCriterion to use; will use the dm if null
-  private ReplyProcessor21(DM dm,
-                           InternalDistributedSystem system,
-                           Collection initMembers,
-                           CancelCriterion cancelCriterion) {
+  private ReplyProcessor21(DM dm, InternalDistributedSystem system, Collection initMembers,
+      CancelCriterion cancelCriterion) {
-   this(dm, system, initMembers, cancelCriterion, true);
+    this(dm, system, initMembers, cancelCriterion, true);
-   * @param cancelCriterion optional CancelCriterion to use; will use the dm
-   * if null
+   * @param cancelCriterion optional CancelCriterion to use; will use the dm if null
-  protected ReplyProcessor21(DM dm,
-                           InternalDistributedSystem system,
-                           Collection initMembers,
-                           CancelCriterion cancelCriterion, boolean register) {
+  protected ReplyProcessor21(DM dm, InternalDistributedSystem system, Collection initMembers,
+      CancelCriterion cancelCriterion, boolean register) {
-      int i=0;
+      int i = 0;
-        this.members[i] = (InternalDistributedMember)it.next();
+        this.members[i] = (InternalDistributedMember) it.next();
-    if(register) {
+    if (register) {
-  /////////////////////  Instance Methods  /////////////////////
+  ///////////////////// Instance Methods /////////////////////
-  /** get the distribution manager for this processor.  If the distributed system
-   *  has a distribution manager, it is used.  Otherwise, we expect a distribution
-   *  manager has been set with setDistributionManager and we'll use that
+  /**
+   * get the distribution manager for this processor. If the distributed system has a distribution
+   * manager, it is used. Otherwise, we expect a distribution manager has been set with
+   * setDistributionManager and we'll use that
-   * NOTE: the communication layer does not reliably support sending a message to oneself,
-   * so other means must be used to execute the message in this VM.  Typically
-   * you would set the sender of the message and then invoke its process()
-   * method in another thread.  If you have questions, talk to Bruce Schuchardt.
+   * NOTE: the communication layer does not reliably support sending a message to oneself, so other
+   * means must be used to execute the message in this VM. Typically you would set the sender of the
+   * message and then invoke its process() method in another thread. If you have questions, talk to
+   * Bruce Schuchardt.
-   * The first time a reply is received that contains an exception,
-   * the ReplyProcessor will save that exception to be passed
-   * along to the waiting client thread.  By default, any exception
-   * encountered after that will be logged.  Subclasses can reimplement
-   * this method to disable logging of multiple exceptions.
+   * The first time a reply is received that contains an exception, the ReplyProcessor will save
+   * that exception to be passed along to the waiting client thread. By default, any exception
+   * encountered after that will be logged. Subclasses can reimplement this method to disable
+   * logging of multiple exceptions.
-   * Makes note of a reply from a member.  If all members have
-   * replied, the waiting thread is signaled.  This method can be
-   * overridden to provide customized functionality, however the
-   * overriden method should always invoke
-   * <code>super.process()</code>.
+   * Makes note of a reply from a member. If all members have replied, the waiting thread is
+   * signaled. This method can be overridden to provide customized functionality, however the
+   * overriden method should always invoke <code>super.process()</code>.
-      ReplyException ex = ((ReplyMessage)msg).getException();
+      ReplyException ex = ((ReplyMessage) msg).getException();
-          processException(msg, (DSFIDNotFoundException)ex.getCause());
-        }
-        else {
+          processException(msg, (DSFIDNotFoundException) ex.getCause());
+        } else {
-        if (system.getConfig().getMcastPort() == 0  // could be using multicast & will get responses from everyone
-             && (viewMembers == null || viewMembers.contains(sender))) {
+        if (system.getConfig().getMcastPort() == 0 // could be using multicast & will get responses
+                                                   // from everyone
+            && (viewMembers == null || viewMembers.contains(sender))) {
-            LocalizedStrings.ReplyProcessor21_RECEIVED_REPLY_FROM_MEMBER_0_BUT_WAS_NOT_EXPECTING_ONE_MORE_THAN_ONE_REPLY_MAY_HAVE_BEEN_RECEIVED_THE_REPLY_THAT_WAS_NOT_EXPECTED_IS_1,
-            new Object[] {sender, msg}));
+              LocalizedStrings.ReplyProcessor21_RECEIVED_REPLY_FROM_MEMBER_0_BUT_WAS_NOT_EXPECTING_ONE_MORE_THAN_ONE_REPLY_MAY_HAVE_BEEN_RECEIVED_THE_REPLY_THAT_WAS_NOT_EXPECTED_IS_1,
+              new Object[] {sender, msg}));
-  protected synchronized void processException(DistributionMessage msg,
-                                               ReplyException ex) {
+  protected synchronized void processException(DistributionMessage msg, ReplyException ex) {
+
-    if (this.exception == null) {  // only keep first exception
+    if (this.exception == null) { // only keep first exception
-      if ( ! (ex.getCause() instanceof ConcurrentCacheModificationException) ) {
-        logger.fatal(LocalizedMessage.create(
-          LocalizedStrings.ReplyProcessor21_EXCEPTION_RECEIVED_IN_REPLYMESSAGE_ONLY_ONE_EXCEPTION_IS_PASSED_BACK_TO_CALLER_THIS_EXCEPTION_IS_LOGGED_ONLY),
-          ex);
+      if (!(ex.getCause() instanceof ConcurrentCacheModificationException)) {
+        logger.fatal(
+            LocalizedMessage.create(
+                LocalizedStrings.ReplyProcessor21_EXCEPTION_RECEIVED_IN_REPLYMESSAGE_ONLY_ONE_EXCEPTION_IS_PASSED_BACK_TO_CALLER_THIS_EXCEPTION_IS_LOGGED_ONLY),
+            ex);
-   * Handle a {@link DSFIDNotFoundException} indicating a message type is not
-   * implemented on another server (for example due to different product
-   * version). Default implementation logs the exception as severe and moves on.
+   * Handle a {@link DSFIDNotFoundException} indicating a message type is not implemented on another
+   * server (for example due to different product version). Default implementation logs the
+   * exception as severe and moves on.
-   * Rationale for default handling: New operations can have caused changes to
-   * other newer versioned GFE JVMs that cannot be reverted. So ignoring
-   * exceptions is a conservative way considering such scenarios. It will be
-   * upto individual messages to handle differently by overriding the above
+   * Rationale for default handling: New operations can have caused changes to other newer versioned
+   * GFE JVMs that cannot be reverted. So ignoring exceptions is a conservative way considering such
+   * scenarios. It will be upto individual messages to handle differently by overriding the above
-  protected synchronized void processException(DistributionMessage msg,
-      DSFIDNotFoundException ex) {
+  protected synchronized void processException(DistributionMessage msg, DSFIDNotFoundException ex) {
-        new Object[] { ex.getUnknownDSFID(), msg.getSender(), versionStr }), ex);
+        new Object[] {ex.getUnknownDSFID(), msg.getSender(), versionStr}), ex);
-  public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
-  }
+  public void quorumLost(Set<InternalDistributedMember> failures,
+      List<InternalDistributedMember> remaining) {}
-  public void memberSuspect(InternalDistributedMember id,
-      InternalDistributedMember whoSuspected, String reason) {
+  public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected,
+      String reason) {
-        for (int i=0; i<cells; i++) {
+        for (int i = 0; i < cells; i++) {
-   * Wait for all expected acks to be returned or an exception to come
-   * in.  This method will return whether a) we have received replies
-   * from all desired members or b) the necessary conditions have been
-   * met so that we don't need to wait anymore.
-   * @throws InternalGemFireException if ack-threshold was exceeded and system
-   *         property "ack-threshold-exception" is set to true
+   * Wait for all expected acks to be returned or an exception to come in. This method will return
+   * whether a) we have received replies from all desired members or b) the necessary conditions
+   * have been met so that we don't need to wait anymore.
+   * 
+   * @throws InternalGemFireException if ack-threshold was exceeded and system property
+   *         "ack-threshold-exception" is set to true
-  public final void waitForReplies()
-    throws InterruptedException, ReplyException {
+  public final void waitForReplies() throws InterruptedException, ReplyException {
-   * Registers this processor as a membership listener and
-   * returns a set of the current members.
+   * Registers this processor as a membership listener and returns a set of the current members.
+   * 
-    return getDistributionManager()
-      .addMembershipListenerAndGetDistributionManagerIds(this);
+    return getDistributionManager().addMembershipListenerAndGetDistributionManagerIds(this);
+
+   * 
-    }
-    catch (DistributedSystemDisconnectedException e) {
+    } catch (DistributedSystemDisconnectedException e) {
+
+   * 
-  
+
-   * perform initial membership processing while under synchronization
-   * of this.members
+   * perform initial membership processing while under synchronization of this.members
+   * 
-   * Wait a given number of milliseconds for the expected acks to be
-   * received.  If <code>msecs</code> milliseconds pass before all
-   * acknowlegdements are received, <code>false</code> is returned.
+   * Wait a given number of milliseconds for the expected acks to be received. If <code>msecs</code>
+   * milliseconds pass before all acknowlegdements are received, <code>false</code> is returned.
-   * @throws InternalGemFireException if ack-threshold was exceeded and system
-   * property "ack-threshold-exception" is set to true
+   * @throws InternalGemFireException if ack-threshold was exceeded and system property
+   *         "ack-threshold-exception" is set to true
-   * @return Whether or not we received all of the replies in the
-   *         given amount of time.
+   * @return Whether or not we received all of the replies in the given amount of time.
-  public final boolean waitForReplies(long msecs) throws InterruptedException,
-      ReplyException {
+  public final boolean waitForReplies(long msecs) throws InterruptedException, ReplyException {
-  public final boolean waitForReplies(long msecs,
-      StoppableCountDownLatch latch, boolean doCleanUp)
+  public final boolean waitForReplies(long msecs, StoppableCountDownLatch latch, boolean doCleanUp)
-      throw new IllegalStateException(LocalizedStrings.ReplyProcessor21_THIS_REPLY_PROCESSOR_HAS_ALREADY_BEEN_REMOVED_FROM_THE_PROCESSOR_KEEPER.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.ReplyProcessor21_THIS_REPLY_PROCESSOR_HAS_ALREADY_BEEN_REMOVED_FROM_THE_PROCESSOR_KEEPER
+              .toLocalizedString());
-      if (interrupted) throw new InterruptedException();
+      if (interrupted)
+        throw new InterruptedException();
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-        }
-        finally {
+        } finally {
-    }
-    finally {
+    } finally {
-          if (interrupted) throw new InterruptedException();
+          if (interrupted)
+            throw new InterruptedException();
-   * basicWait occurs after preWait and before postWait. Attempts to acquire
-   * the latch are made.
+   * basicWait occurs after preWait and before postWait. Attempts to acquire the latch are made.
+   * 
-   * @return whether or not we received all of the replies in the given amount
-   * of time
+   * @return whether or not we received all of the replies in the given amount of time
-  throws InterruptedException, ReplyException {
+      throws InterruptedException, ReplyException {
-        if (timeout <= timeSoFar+1) {
+        if (timeout <= timeSoFar + 1) {
-        if (timedOut || !latch.await(timeout-timeSoFar-1)) {
+        if (timedOut || !latch.await(timeout - timeSoFar - 1)) {
-          // members from the system.  Then we wait indefinitely
+          // members from the system. Then we wait indefinitely
-              this.severeAlertTimerReset = false;  // retry if this gets set by suspect processing (splitbrain requirement)
+              this.severeAlertTimerReset = false; // retry if this gets set by suspect processing
+                                                  // (splitbrain requirement)
-          }
-          else {
+          } else {
-          logger.info(LocalizedMessage.create(LocalizedStrings.ReplyProcessor21_WAIT_FOR_REPLIES_COMPLETED_1, shortName()));
+          logger.info(LocalizedMessage
+              .create(LocalizedStrings.ReplyProcessor21_WAIT_FOR_REPLIES_COMPLETED_1, shortName()));
-      }
-      else {
+      } else {
-            if (!latch.await(msecs-timeout)) {
-              logger.info(LocalizedMessage.create(LocalizedStrings.ReplyProcessor21_WAIT_FOR_REPLIES_TIMING_OUT_AFTER_0_SEC, Long.valueOf(msecs / 1000)));
+            if (!latch.await(msecs - timeout)) {
+              logger.info(LocalizedMessage.create(
+                  LocalizedStrings.ReplyProcessor21_WAIT_FOR_REPLIES_TIMING_OUT_AFTER_0_SEC,
+                  Long.valueOf(msecs / 1000)));
-            logger.info(LocalizedMessage.create(LocalizedStrings.ReplyProcessor21_WAIT_FOR_REPLIES_COMPLETED_1, shortName()));
+            logger.info(LocalizedMessage.create(
+                LocalizedStrings.ReplyProcessor21_WAIT_FOR_REPLIES_COMPLETED_1, shortName()));
-        }
-        else {
+        } else {
-   * Wait a given number of milliseconds for the expected acks to be
-   * received.  If <code>msecs</code> milliseconds pass before all
-   * acknowlegdements are received, <code>false</code> is returned.
+   * Wait a given number of milliseconds for the expected acks to be received. If <code>msecs</code>
+   * milliseconds pass before all acknowlegdements are received, <code>false</code> is returned.
-   * Thread interruptions will be ignored while waiting. If interruption
-   * occurred while in this method, the current thread's interrupt flag will
-   * be true, but InterruptedException will not be thrown.
+   * Thread interruptions will be ignored while waiting. If interruption occurred while in this
+   * method, the current thread's interrupt flag will be true, but InterruptedException will not be
+   * thrown.
-   * @param p_msecs the number of milliseconds to wait for replies, zero will be
-   * interpreted as Long.MAX_VALUE
+   * @param p_msecs the number of milliseconds to wait for replies, zero will be interpreted as
+   *        Long.MAX_VALUE
-   * @throws InternalGemFireException if ack-threshold was exceeded and system
-   * property "ack-threshold-exception" is set to true
+   * @throws InternalGemFireException if ack-threshold was exceeded and system property
+   *         "ack-threshold-exception" is set to true
-  public final boolean waitForRepliesUninterruptibly(long p_msecs)
-      throws ReplyException {
-	  return waitForRepliesUninterruptibly(p_msecs, getLatch(), true);
+  public final boolean waitForRepliesUninterruptibly(long p_msecs) throws ReplyException {
+    return waitForRepliesUninterruptibly(p_msecs, getLatch(), true);
-  
-  public final boolean waitForRepliesUninterruptibly(long p_msecs, 
-		  StoppableCountDownLatch latch, boolean doCleanUp)
-      throws ReplyException {
+
+  public final boolean waitForRepliesUninterruptibly(long p_msecs, StoppableCountDownLatch latch,
+      boolean doCleanUp) throws ReplyException {
-      throw new IllegalStateException(LocalizedStrings.ReplyProcessor21_THIS_REPLY_PROCESSOR_HAS_ALREADY_BEEN_REMOVED_FROM_THE_PROCESSOR_KEEPER.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.ReplyProcessor21_THIS_REPLY_PROCESSOR_HAS_ALREADY_BEEN_REMOVED_FROM_THE_PROCESSOR_KEEPER
+              .toLocalizedString());
-            }
-            catch (InterruptedException e) {
+            } catch (InterruptedException e) {
-            }
-            finally {
+            } finally {
-        }
-        finally {
+        } finally {
-   * Used to cleanup resources allocated by the processor
-   * after we are done using it.
+   * Used to cleanup resources allocated by the processor after we are done using it.
+   * 
-   * Thread interruptions will be ignored while waiting. If interruption
-   * occurred while in this method, the current thread's interrupt flag will
-   * be true, but InterruptedException will not be thrown.
+   * Thread interruptions will be ignored while waiting. If interruption occurred while in this
+   * method, the current thread's interrupt flag will be true, but InterruptedException will not be
+   * thrown.
-   * @throws InternalGemFireException if ack-threshold was exceeded and system
-   * property "ack-threshold-exception" is set to true
+   * @throws InternalGemFireException if ack-threshold was exceeded and system property
+   *         "ack-threshold-exception" is set to true
-  public final void waitForRepliesUninterruptibly()
-  throws ReplyException {
+  public final void waitForRepliesUninterruptibly() throws ReplyException {
-   * Returns the id of this reply processor.  This id is
-   * often sent in messages, so that reply messages know which
-   * processor to notify.
+   * Returns the id of this reply processor. This id is often sent in messages, so that reply
+   * messages know which processor to notify.
-   * Returns whether or not this reply processor can stop waiting for
-   * replies.  This method can be overridden to allow the waiter to be
-   * notified before all responses have been received.  This is useful
-   * when we are waiting for a value from any member, or if we can
-   * stop waiting if a remote exception occurred.  By default, this
-   * method returns <code>false</code>.
+   * Returns whether or not this reply processor can stop waiting for replies. This method can be
+   * overridden to allow the waiter to be notified before all responses have been received. This is
+   * useful when we are waiting for a value from any member, or if we can stop waiting if a remote
+   * exception occurred. By default, this method returns <code>false</code>.
-   * We're still waiting if there is any member still left
-   * in the set and an exception
-   * hasn't been returned from anyone yet.
+   * We're still waiting if there is any member still left in the set and an exception hasn't been
+   * returned from anyone yet.
-      // failed computation.  If you set the exception in onShutdown,
+      // failed computation. If you set the exception in onShutdown,
-      ReplyException re = new ReplyException(new DistributedSystemDisconnectedException(LocalizedStrings.ReplyProcessor21_ABORTED_DUE_TO_SHUTDOWN.toLocalizedString()));
+      ReplyException re = new ReplyException(new DistributedSystemDisconnectedException(
+          LocalizedStrings.ReplyProcessor21_ABORTED_DUE_TO_SHUTDOWN.toLocalizedString()));
+   * 
-   * If this processor is not waiting for any more replies, then the
-   * waiting thread will be notified.
+   * If this processor is not waiting for any more replies, then the waiting thread will be
+   * notified.
-   * Override to execute custom code after {@link #finished}. This will be
-   * invoked only once for each ReplyProcessor21.
+   * Override to execute custom code after {@link #finished}. This will be invoked only once for
+   * each ReplyProcessor21.
-  protected void postFinish() {
-  }
+  protected void postFinish() {}
-    return "<" + shortName() + " " + this.getProcessorId() +
-      " waiting for " + numMembers() + " replies" +
-      (exception == null ? "" : (" exception: " + exception)) +
-      " from " + membersToString() + ">";
+    return "<" + shortName() + " " + this.getProcessorId() + " waiting for " + numMembers()
+        + " replies" + (exception == null ? "" : (" exception: " + exception)) + " from "
+        + membersToString() + ">";
-      for (int i=0; i<cells; i++) {
+      for (int i = 0; i < cells; i++) {
-          // we may be expecting more than one response from a member.  so,
+          // we may be expecting more than one response from a member. so,
-      for (int i=0; i<cells; i++) {
+      for (int i = 0; i < cells; i++) {
-      for (int i=0; i<cells; i++) {
+      for (int i = 0; i < cells; i++) {
-   * Return the time in sec to wait before sending an alert while
-   * waiting for ack replies.  Note that the ack wait threshold may
-   * change at runtime, so we have to consult the system every time.
+   * Return the time in sec to wait before sending an alert while waiting for ack replies. Note that
+   * the ack wait threshold may change at runtime, so we have to consult the system every time.
-   * Return the time in sec to wait before removing unresponsive members
-   * from the distributed system.  This period starts after the ack-wait-threshold
-   * period has elapsed
+   * Return the time in sec to wait before removing unresponsive members from the distributed
+   * system. This period starts after the ack-wait-threshold period has elapsed
-  
-  protected boolean processTimeout(){
+
+  protected boolean processTimeout() {
-   * process a wait-timeout.  Usually suspectThem would be used in the first
-   * timeout, followed by a subsequent use of disconnectThem
+   * process a wait-timeout. Usually suspectThem would be used in the first timeout, followed by a
+   * subsequent use of disconnectThem
+   * 
-   * @param severeAlert whether to ask the membership manager to disconnect the unresponseive members
+   * @param severeAlert whether to ask the membership manager to disconnect the unresponseive
+   *        members
-    
-    if(!this.processTimeout())
+
+    if (!this.processTimeout())
-    
+
-    final Object[] msgArgs = new Object[] {Long.valueOf(timeout + (severeAlert? getSevereAlertThreshold() : 0)), this, getDistributionManager().getId(), activeMembers};
-    final StringId msg = LocalizedStrings.ReplyProcessor21_0_SEC_HAVE_ELAPSED_WHILE_WAITING_FOR_REPLIES_1_ON_2_WHOSE_CURRENT_MEMBERSHIP_LIST_IS_3;
+    final Object[] msgArgs =
+        new Object[] {Long.valueOf(timeout + (severeAlert ? getSevereAlertThreshold() : 0)), this,
+            getDistributionManager().getId(), activeMembers};
+    final StringId msg =
+        LocalizedStrings.ReplyProcessor21_0_SEC_HAVE_ELAPSED_WHILE_WAITING_FOR_REPLIES_1_ON_2_WHOSE_CURRENT_MEMBERSHIP_LIST_IS_3;
-    }
-    else {
+    } else {
-    }
-    else {
+    } else {
-              LocalizedStrings.ReplyProcessor21_VIEW_NO_LONGER_HAS_0_AS_AN_ACTIVE_MEMBER_SO_WE_WILL_NO_LONGER_WAIT_FOR_IT,
-              this.members[i]));
+                LocalizedStrings.ReplyProcessor21_VIEW_NO_LONGER_HAS_0_AS_AN_ACTIVE_MEMBER_SO_WE_WILL_NO_LONGER_WAIT_FOR_IT,
+                this.members[i]));
-          }
-          else {
+          } else {
-      TimeoutException cause = new TimeoutException(LocalizedStrings.TIMED_OUT_WAITING_FOR_ACKS.toLocalizedString());
-      throw new InternalGemFireException(LocalizedStrings.ReplyProcessor21_0_SEC_HAVE_ELAPSED_WHILE_WAITING_FOR_REPLIES_1_ON_2_WHOSE_CURRENT_MEMBERSHIP_LIST_IS_3
-          .toLocalizedString(msgArgs), cause);
-    }
-    else if (suspectThem) {
+      TimeoutException cause =
+          new TimeoutException(LocalizedStrings.TIMED_OUT_WAITING_FOR_ACKS.toLocalizedString());
+      throw new InternalGemFireException(
+          LocalizedStrings.ReplyProcessor21_0_SEC_HAVE_ELAPSED_WHILE_WAITING_FOR_REPLIES_1_ON_2_WHOSE_CURRENT_MEMBERSHIP_LIST_IS_3
+              .toLocalizedString(msgArgs),
+          cause);
+    } else if (suspectThem) {
-        getDistributionManager().getMembershipManager()
-          .suspectMembers(suspectMembers, "Failed to respond within ack-wait-threshold");
+        getDistributionManager().getMembershipManager().suspectMembers(suspectMembers,
+            "Failed to respond within ack-wait-threshold");
-   * You must be synchronize on the result of this function in order
-   * to examine its contents.
+   * You must be synchronize on the result of this function in order to examine its contents.
-   * Enables severe alert processing in this reply processor, if
-   * it has also been enabled in the distribution config.  Severe
-   * alerts are issued if acks are not received within ack-wait-threshold
-   * plus ack-severe-alert-threshold seconds.
+   * Enables severe alert processing in this reply processor, if it has also been enabled in the
+   * distribution config. Severe alerts are issued if acks are not received within
+   * ack-wait-threshold plus ack-severe-alert-threshold seconds.
+   * 
-    return ((Boolean)SevereAlertShorten.get()).booleanValue();
+    return ((Boolean) SevereAlertShorten.get()).booleanValue();
-   * Returns true if forceSevereAlertProcessing has been used to force
-   * the next reply-wait in the current thread to perform severe-alert
-   * processing.
+   * Returns true if forceSevereAlertProcessing has been used to force the next reply-wait in the
+   * current thread to perform severe-alert processing.
-    return ((Boolean)ForceSevereAlertProcessing.get()).booleanValue();
+    return ((Boolean) ForceSevereAlertProcessing.get()).booleanValue();
-   * Get the ack-severe-alert-threshold, in milliseconds,
-   * with shortening applied
+   * Get the ack-severe-alert-threshold, in milliseconds, with shortening applied
-    if (disconnectTimeout > 0 && ((Boolean)SevereAlertShorten.get()).booleanValue()) {
-      disconnectTimeout = (long)(disconnectTimeout * PR_SEVERE_ALERT_RATIO);
+    if (disconnectTimeout > 0 && ((Boolean) SevereAlertShorten.get()).booleanValue()) {
+      disconnectTimeout = (long) (disconnectTimeout * PR_SEVERE_ALERT_RATIO);
+
-   * Used by messages to store the id for the current message into a thread local.
-   * This allows the comms layer to still send replies even when it can't deserialize
-   * a message.
+   * Used by messages to store the id for the current message into a thread local. This allows the
+   * comms layer to still send replies even when it can't deserialize a message.
+
+
+
-   * Returns the reply processor id for the message currently being read.
-   * Returns 0 if no id exists.
+   * Returns the reply processor id for the message currently being read. Returns 0 if no id exists.
-      result = ((Integer)v).intValue();
+      result = ((Integer) v).intValue();
-   * To fix the hang of 42951 make sure the guys
-   * waiting on this processor are told to quit
-   * waiting and tell them why.
+   * To fix the hang of 42951 make sure the guys waiting on this processor are told to quit waiting
+   * and tell them why.
+   * 

UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
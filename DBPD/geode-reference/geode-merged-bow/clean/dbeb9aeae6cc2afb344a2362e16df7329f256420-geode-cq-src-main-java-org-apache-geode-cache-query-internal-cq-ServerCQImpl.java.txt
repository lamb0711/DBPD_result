Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  /** 
-   * This holds the keys that are part of the CQ query results.
-   * Using this CQ engine can determine whether to execute 
-   * query on old value from EntryEvent, which is an expensive
-   * operation.
+  /**
+   * This holds the keys that are part of the CQ query results. Using this CQ engine can determine
+   * whether to execute query on old value from EntryEvent, which is an expensive operation.
-   * NOTE:
-   * In case of RR this map is populated and used as intended.
-   * In case of PR this map will not be populated. If executeCQ happens after update operations
-   * this map will remain empty.
+   * NOTE: In case of RR this map is populated and used as intended. In case of PR this map will not
+   * be populated. If executeCQ happens after update operations this map will remain empty.
-  /** 
-   * This maintains the keys that are destroyed while the Results
-   * Cache is getting constructed. This avoids any keys that are
-   * destroyed (after query execution) but is still part of the 
-   * CQs result.
+  /**
+   * This maintains the keys that are destroyed while the Results Cache is getting constructed. This
+   * avoids any keys that are destroyed (after query execution) but is still part of the CQs result.
-  
+
-  
+
-  
+
-  
+
-  
+
-  
-  
+
+
-  
-  public ServerCQImpl(CqServiceImpl cqService, String cqName, String queryString, boolean isDurable, String serverCqName)  {
+
+  public ServerCQImpl(CqServiceImpl cqService, String cqName, String queryString, boolean isDurable,
+      String serverCqName) {
-  
+
-    //For deserialization
+    // For deserialization
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  
+
-  
+
-  
+
-  public void registerCq(ClientProxyMembershipID p_clientProxyId, 
-      CacheClientNotifier p_ccn, int p_cqState) 
-      throws CqException, RegionNotFoundException {      
-    
-    CacheClientProxy clientProxy = null;    
-    this.clientProxyId = p_clientProxyId; 
-    //servConnection = serverSideConnection;
+  public void registerCq(ClientProxyMembershipID p_clientProxyId, CacheClientNotifier p_ccn,
+      int p_cqState) throws CqException, RegionNotFoundException {
+
+    CacheClientProxy clientProxy = null;
+    this.clientProxyId = p_clientProxyId;
+    // servConnection = serverSideConnection;
-    
+
-    try {
-      initCq();
-    } catch (CqExistsException cqe) {
-      // Should not happen.
-      throw new CqException(LocalizedStrings.CqQueryImpl_UNABLE_TO_CREATE_CQ_0_ERROR__1.toLocalizedString(new Object[] { cqName, cqe.getMessage()}));
-    }
-    */
-    
+     * try { initCq(); } catch (CqExistsException cqe) { // Should not happen. throw new
+     * CqException(LocalizedStrings.CqQueryImpl_UNABLE_TO_CREATE_CQ_0_ERROR__1.toLocalizedString(new
+     * Object[] { cqName, cqe.getMessage()})); }
+     */
+
-    
+
-        logger.debug("Server side query for the cq: {} is: {}", cqName, this.query.getQueryString());
+        logger.debug("Server side query for the cq: {} is: {}", cqName,
+            this.query.getQueryString());
-        msg = LocalizedStrings.CqQueryImpl_CLASS_NOT_FOUND_EXCEPTION_THE_ANTLRJAR_OR_THE_SPCIFIED_CLASS_MAY_BE_MISSING_FROM_SERVER_SIDE_CLASSPATH_ERROR_0;
+        msg =
+            LocalizedStrings.CqQueryImpl_CLASS_NOT_FOUND_EXCEPTION_THE_ANTLRJAR_OR_THE_SPCIFIED_CLASS_MAY_BE_MISSING_FROM_SERVER_SIDE_CLASSPATH_ERROR_0;
-    
+
-    this.cqBaseRegion = (LocalRegion)cqService.getCache().getRegion(regionName); 
+    this.cqBaseRegion = (LocalRegion) cqService.getCache().getRegion(regionName);
-      throw new RegionNotFoundException(LocalizedStrings.CqQueryImpl_REGION__0_SPECIFIED_WITH_CQ_NOT_FOUND_CQNAME_1
-          .toLocalizedString(new Object[] {regionName, this.cqName}));
+      throw new RegionNotFoundException(
+          LocalizedStrings.CqQueryImpl_REGION__0_SPECIFIED_WITH_CQ_NOT_FOUND_CQNAME_1
+              .toLocalizedString(new Object[] {regionName, this.cqName}));
-    
-    // Make sure that the region is partitioned or 
+
+    // Make sure that the region is partitioned or
-      //replicated regions with eviction set to local destroy get turned into preloaded
-      if (dp.withPreloaded() && cqBaseRegion.getAttributes().getEvictionAttributes() != null && cqBaseRegion.getAttributes().getEvictionAttributes().getAction().equals(EvictionAction.LOCAL_DESTROY)) {
-        errMsg = LocalizedStrings.CqQueryImpl_CQ_NOT_SUPPORTED_FOR_REPLICATE_WITH_LOCAL_DESTROY.toString(this.regionName, cqBaseRegion.getAttributes().getEvictionAttributes().getAction());
+      // replicated regions with eviction set to local destroy get turned into preloaded
+      if (dp.withPreloaded() && cqBaseRegion.getAttributes().getEvictionAttributes() != null
+          && cqBaseRegion.getAttributes().getEvictionAttributes().getAction()
+              .equals(EvictionAction.LOCAL_DESTROY)) {
+        errMsg =
+            LocalizedStrings.CqQueryImpl_CQ_NOT_SUPPORTED_FOR_REPLICATE_WITH_LOCAL_DESTROY.toString(
+                this.regionName, cqBaseRegion.getAttributes().getEvictionAttributes().getAction());
+      } else {
+        errMsg = "The region " + this.regionName
+            + "  specified in CQ creation is neither replicated nor partitioned; "
+            + "only replicated or partitioned regions are allowed in CQ creation.";
-      else {
-        errMsg = "The region " + this.regionName + 
-            "  specified in CQ creation is neither replicated nor partitioned; " +
-        "only replicated or partitioned regions are allowed in CQ creation.";
-      }
-      if (isDebugEnabled){
+      if (isDebugEnabled) {
-    if ((dp.withReplication() && 
-        (!(cqBaseRegion.getAttributes().getScope().isDistributedAck() || 
-        cqBaseRegion.getAttributes().getScope().isGlobal())))) {
-      String errMsg = "The replicated region " + this.regionName + 
-          " specified in CQ creation does not have scope supported by CQ." +
-          " The CQ supported scopes are DISTRIBUTED_ACK and GLOBAL.";
-      if (isDebugEnabled){
+    if ((dp.withReplication() && (!(cqBaseRegion.getAttributes().getScope().isDistributedAck()
+        || cqBaseRegion.getAttributes().getScope().isGlobal())))) {
+      String errMsg = "The replicated region " + this.regionName
+          + " specified in CQ creation does not have scope supported by CQ."
+          + " The CQ supported scopes are DISTRIBUTED_ACK and GLOBAL.";
+      if (isDebugEnabled) {
-    
-    //checkAndSetCqOnRegion();
-    
-    //Can be null by the time we are here
+
+    // checkAndSetCqOnRegion();
+
+    // Can be null by the time we are here
-        logger.debug("Added CQ to the base region: {} With key as: {}", cqBaseRegion.getFullPath(), serverCqName);
+        logger.debug("Added CQ to the base region: {} With key as: {}", cqBaseRegion.getFullPath(),
+            serverCqName);
-    
+
-    
+
-    if(this.cqState.getState() != p_cqState) {
+    if (this.cqState.getState() != p_cqState) {
-    
-    //Register is called from both filter profile and cqService
-    //In either case, if we are trying to start/run the cq, we need to add
-    //it to other matching cqs for performance reasons
+
+    // Register is called from both filter profile and cqService
+    // In either case, if we are trying to start/run the cq, we need to add
+    // it to other matching cqs for performance reasons
-         // Add to the matchedCqMap.
-        cqService.addToMatchingCqMap(this);    
+      // Add to the matchedCqMap.
+      cqService.addToMatchingCqMap(this);
-    if(CqServiceProvider.MAINTAIN_KEYS) {
-      this.cqResultKeys = new HashMap <Object, Object>();
-      // Currently the CQ Result keys are not cached for the Partitioned 
-      // Regions. Supporting this with PR needs more work like forcing 
+    if (CqServiceProvider.MAINTAIN_KEYS) {
+      this.cqResultKeys = new HashMap<Object, Object>();
+      // Currently the CQ Result keys are not cached for the Partitioned
+      // Regions. Supporting this with PR needs more work like forcing
-      // Only the events which are seen during event processing is 
+      // Only the events which are seen during event processing is
-      if (this.isPR){
+      if (this.isPR) {
-        this.destroysWhileCqResultsInProgress = new HashSet <Object>();
+        this.destroysWhileCqResultsInProgress = new HashSet<Object>();
-    } 
+    }
-        throw new CqException(LocalizedStrings.CqQueryImpl_UNABLE_TO_CREATE_CQ_0_ERROR__1.toLocalizedString(new Object[] { cqName, cqe.getMessage()}));
+        throw new CqException(LocalizedStrings.CqQueryImpl_UNABLE_TO_CREATE_CQ_0_ERROR__1
+            .toLocalizedString(new Object[] {cqName, cqe.getMessage()}));
-  
+
+   * 
-    if (this.cqResultKeys != null){
+    if (this.cqResultKeys != null) {
-  
+
-   * Returns parameterized query used by the server.
-   * This method replaces Region name with $1 and if type is not specified
-   * in the query, looks for type from cqattributes and appends into the
+   * Returns parameterized query used by the server. This method replaces Region name with $1 and if
+   * type is not specified in the query, looks for type from cqattributes and appends into the
+   * 
-    GemFireCacheImpl cache = (GemFireCacheImpl)cqService.getCache();
-    DefaultQuery locQuery = (DefaultQuery)cache.getLocalQueryService().newQuery(this.queryString);      
+    GemFireCacheImpl cache = (GemFireCacheImpl) cqService.getCache();
+    DefaultQuery locQuery = (DefaultQuery) cache.getLocalQueryService().newQuery(this.queryString);
-    CompiledIteratorDef from = (CompiledIteratorDef)select.getIterators().get(0);
+    CompiledIteratorDef from = (CompiledIteratorDef) select.getIterators().get(0);
-    this.regionName = ((CompiledRegion)from.getCollectionExpr()).getRegionPath();
+    this.regionName = ((CompiledRegion) from.getCollectionExpr()).getRegionPath();
-    return locQuery;    
+    return locQuery;
-  
+
-   * Returns if the passed key is part of the CQs result set.
-   * This method needs to be called once the CQ result key caching
-   * is completed (cqResultsCacheInitialized is true).
+   * Returns if the passed key is part of the CQs result set. This method needs to be called once
+   * the CQ result key caching is completed (cqResultsCacheInitialized is true).
+   * 
-        //this.logger.fine("Removing keys from Destroy Cache  For CQ :" + 
-        //this.cqName + " Keys :" + this.destroysWhileCqResultsInProgress);
-        for (Object k : this.destroysWhileCqResultsInProgress){
-          this.cqResultKeys.remove(k);  
+        // this.logger.fine("Removing keys from Destroy Cache For CQ :" +
+        // this.cqName + " Keys :" + this.destroysWhileCqResultsInProgress);
+        for (Object k : this.destroysWhileCqResultsInProgress) {
+          this.cqResultKeys.remove(k);
-    
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-    if (!CqServiceProvider.MAINTAIN_KEYS){
+    if (!CqServiceProvider.MAINTAIN_KEYS) {
-    
-    //this.logger.fine("Adding key to Results Cache For CQ :" + 
-    //this.cqName + " key :" + key);
+
+    // this.logger.fine("Adding key to Results Cache For CQ :" +
+    // this.cqName + " key :" + key);
-      synchronized (this.cqResultKeys) { 
+      synchronized (this.cqResultKeys) {
-        if (!this.cqResultKeysInitialized){
+        if (!this.cqResultKeysInitialized) {
-          //this.logger.fine("Removing key from Destroy Cache For CQ :" + 
-          //this.cqName + " key :" + key);
-          if (this.destroysWhileCqResultsInProgress != null){
+          // this.logger.fine("Removing key from Destroy Cache For CQ :" +
+          // this.cqName + " key :" + key);
+          if (this.destroysWhileCqResultsInProgress != null) {
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.query.internal.InternalCqQuery2#removeFromCqResultKeys(java.lang.Object, boolean)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.query.internal.InternalCqQuery2#removeFromCqResultKeys(java.lang.Object,
+   * boolean)
-    if (!CqServiceProvider.MAINTAIN_KEYS){
+    if (!CqServiceProvider.MAINTAIN_KEYS) {
-    //this.logger.fine("Removing key from Results Cache For CQ :" + 
-    //this.cqName + " key :" + key);
+    // this.logger.fine("Removing key from Results Cache For CQ :" +
+    // this.cqName + " key :" + key);
-      synchronized (this.cqResultKeys) { 
-        if (isTokenMode && this.cqResultKeys.get(key) != Token.DESTROYED){
+      synchronized (this.cqResultKeys) {
+        if (isTokenMode && this.cqResultKeys.get(key) != Token.DESTROYED) {
-        if (!this.cqResultKeysInitialized){
-          //this.logger.fine("Adding key to Destroy Cache For CQ :" + 
-          //this.cqName + " key :" + key);
-          if (this.destroysWhileCqResultsInProgress != null){
+        if (!this.cqResultKeysInitialized) {
+          // this.logger.fine("Adding key to Destroy Cache For CQ :" +
+          // this.cqName + " key :" + key);
+          if (this.destroysWhileCqResultsInProgress != null) {
-  
+
+   * 
-  public void markAsDestroyedInCqResultKeys(Object key){
-    if (!CqServiceProvider.MAINTAIN_KEYS){
+  public void markAsDestroyedInCqResultKeys(Object key) {
+    if (!CqServiceProvider.MAINTAIN_KEYS) {
-    //this.logger.fine("Marking key in Results Cache For CQ :" + 
-    //    this.cqName + " key :" + key);
+    // this.logger.fine("Marking key in Results Cache For CQ :" +
+    // this.cqName + " key :" + key);
-      synchronized (this.cqResultKeys) { 
+      synchronized (this.cqResultKeys) {
-        if (!this.cqResultKeysInitialized){
-          //this.logger.fine("Adding key to Destroy Cache For CQ :" + 
-          //this.cqName + " key :" + key);
-          if (this.destroysWhileCqResultsInProgress != null){
+        if (!this.cqResultKeysInitialized) {
+          // this.logger.fine("Adding key to Destroy Cache For CQ :" +
+          // this.cqName + " key :" + key);
+          if (this.destroysWhileCqResultsInProgress != null) {
-    }    
+    }
-  
-  
-  /* (non-Javadoc)
+
+
+  /*
+   * (non-Javadoc)
+   * 
-   
+
+   * 
-    synchronized (this.cqResultKeys) { 
+    synchronized (this.cqResultKeys) {
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.query.internal.InternalCqQuery2#isOldValueRequiredForQueryProcessing(java.lang.Object)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.query.internal.InternalCqQuery2#isOldValueRequiredForQueryProcessing(
+   * java.lang.Object)
-  public boolean isOldValueRequiredForQueryProcessing(Object key){
+  public boolean isOldValueRequiredForQueryProcessing(Object key) {
-  
+
-   * Closes the Query.
-   *        On Client side, sends the cq close request to server.
-   *        On Server side, takes care of repository cleanup.
+   * Closes the Query. On Client side, sends the cq close request to server. On Server side, takes
+   * care of repository cleanup.
+   * 
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-      logger.debug("Started closing CQ CqName: {} SendRequestToServer: {}", cqName, sendRequestToServer);
-    }   
+      logger.debug("Started closing CQ CqName: {} SendRequestToServer: {}", cqName,
+          sendRequestToServer);
+    }
-    synchronized(this.cqState) {
+    synchronized (this.cqState) {
-        //throw new CqClosedException("CQ is already closed, CqName : " + this.cqName);
-        if (isDebugEnabled){
+        // throw new CqClosedException("CQ is already closed, CqName : " + this.cqName);
+        if (isDebugEnabled) {
-      this.cqState.setState(CqStateImpl.CLOSING);      
+      this.cqState.setState(CqStateImpl.CLOSING);
-      this.removeFromCqMap(); 
+      this.removeFromCqMap();
-        synchronized (this.cqResultKeys){
+        synchronized (this.cqResultKeys) {
-      if(this.stats != null)
+      if (this.stats != null)
-  
+
-  
+
-   * @return CacheClientNotifier 
+   * 
+   * @return CacheClientNotifier
-  
+
+   * 
-    // CqBaseRegion 
+    // CqBaseRegion
-      } 
-    }catch (Exception ex){
+      }
+    } catch (Exception ex) {
-  
+
-    
+
-  
+
-  public void stop()throws CqClosedException, CqException {
+  public void stop() throws CqClosedException, CqException {
-        throw new CqClosedException(LocalizedStrings.CqQueryImpl_CQ_IS_CLOSED_CQNAME_0
-            .toLocalizedString(this.cqName));
+        throw new CqClosedException(
+            LocalizedStrings.CqQueryImpl_CQ_IS_CLOSED_CQNAME_0.toLocalizedString(this.cqName));
-      
+
-        throw new IllegalStateException(LocalizedStrings.CqQueryImpl_CQ_IS_NOT_IN_RUNNING_STATE_STOP_CQ_DOES_NOT_APPLY_CQNAME_0
-            .toLocalizedString(this.cqName));
+        throw new IllegalStateException(
+            LocalizedStrings.CqQueryImpl_CQ_IS_NOT_IN_RUNNING_STATE_STOP_CQ_DOES_NOT_APPLY_CQNAME_0
+                .toLocalizedString(this.cqName));
-      
+
-    //this.cqName = DataSerializer.readString(in);
-    synchronized(cqState) {
+    // this.cqName = DataSerializer.readString(in);
+    synchronized (cqState) {
-  
+
-  public int getDSFID() {
-    return CQ_QUERY;
-  }
-  */
-  
+   * public int getDSFID() { return CQ_QUERY; }
+   */
+
-    //DataSerializer.writeString(this.cqName, out);
+    // DataSerializer.writeString(this.cqName, out);
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  public <E> CqResults<E> executeWithInitialResults() throws CqClosedException,
-      RegionNotFoundException, CqException {
+  public <E> CqResults<E> executeWithInitialResults()
+      throws CqClosedException, RegionNotFoundException, CqException {
-  public void execute() throws CqClosedException, RegionNotFoundException,
-      CqException {
+  public void execute() throws CqClosedException, RegionNotFoundException, CqException {
-  
-  
+
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
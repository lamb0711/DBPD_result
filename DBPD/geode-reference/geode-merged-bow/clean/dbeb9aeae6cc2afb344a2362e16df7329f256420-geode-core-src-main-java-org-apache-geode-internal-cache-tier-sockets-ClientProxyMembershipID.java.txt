Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- *  
+ * 
-  implements DataSerializableFixedID, Serializable, Externalizable {
-  
+    implements DataSerializableFixedID, Serializable, Externalizable {
+
-  
+
-	  POOL_NAME.set(poolName);
+    POOL_NAME.set(poolName);
-  
+
-	  return POOL_NAME.get();
+    return POOL_NAME.get();
-  
+
-   * the membershpi id of the distributed system in this client (if running in a
-   * client)
+   * the membershpi id of the distributed system in this client (if running in a client)
-  //durable_synch_counter=1 is reserved for durable clients
-  //so that when pools are being created and deleted the same client
-  //session is selected on the serverside by always using the 
-  //same uniqueID value which is set via the synch_counter
-  private static final int durable_synch_counter=1;
+  // durable_synch_counter=1 is reserved for durable clients
+  // so that when pools are being created and deleted the same client
+  // session is selected on the serverside by always using the
+  // same uniqueID value which is set via the synch_counter
+  private static final int durable_synch_counter = 1;
-  
+
-  public int hashCode()
-  {
+  public int hashCode() {
-    } else  {
+    } else {
-    //result = mult * result + this.unique_id;
+    // result = mult * result + this.unique_id;
-  public boolean equals(Object obj)
-  {
+  public boolean equals(Object obj) {
-  
+
-   * Return true if "that" can be used in place of "this"
-   * when canonicalizing.
+   * Return true if "that" can be used in place of "this" when canonicalizing.
-  boolean isSameDSMember(ClientProxyMembershipID that)
-  {
+  boolean isSameDSMember(ClientProxyMembershipID that) {
-      return isDurable()
-        ? this.getDurableId().equals(that.getDurableId())
-        : Arrays.equals(this.identity, that.identity);
-    }
-    else {
+      return isDurable() ? this.getDurableId().equals(that.getDurableId())
+          : Arrays.equals(this.identity, that.identity);
+    } else {
-  public static synchronized ClientProxyMembershipID getNewProxyMembership(
-      DistributedSystem sys) {
+  public static synchronized ClientProxyMembershipID getNewProxyMembership(DistributedSystem sys) {
-  public static byte[] initializeAndGetDSIdentity(DistributedSystem sys)
-  {
-	byte[] client_side_identity = null;
+  public static byte[] initializeAndGetDSIdentity(DistributedSystem sys) {
+    byte[] client_side_identity = null;
-      throw new IllegalStateException(LocalizedStrings.ClientProxyMembershipID_ATTEMPTING_TO_HANDSHAKE_WITH_CACHESERVER_BEFORE_CREATING_DISTRIBUTEDSYSTEM_AND_CACHE.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.ClientProxyMembershipID_ATTEMPTING_TO_HANDSHAKE_WITH_CACHESERVER_BEFORE_CREATING_DISTRIBUTEDSYSTEM_AND_CACHE
+              .toLocalizedString());
-    //if (system != sys) 
+    // if (system != sys)
-      }
-      catch (IOException ioe) {
-        throw new InternalGemFireException(LocalizedStrings.ClientProxyMembershipID_UNABLE_TO_SERIALIZE_IDENTITY.toLocalizedString(), ioe);
+      } catch (IOException ioe) {
+        throw new InternalGemFireException(
+            LocalizedStrings.ClientProxyMembershipID_UNABLE_TO_SERIALIZE_IDENTITY
+                .toLocalizedString(),
+            ioe);
-        this.uniqueId = durable_synch_counter;
+      this.uniqueId = durable_synch_counter;
-        this.uniqueId = id;
+      this.uniqueId = id;
-  public ClientProxyMembershipID() {
-  }
+  public ClientProxyMembershipID() {}
-  
-  
+
+
-//  private transient int transientPort; // variable for debugging member ID issues
+  // private transient int transientPort; // variable for debugging member ID issues
-  public String toString()
-  {
-    if (this.identity != null && ((InternalDistributedMember)getDistributedMember()).getPort() == 0) {
+  public String toString() {
+    if (this.identity != null
+        && ((InternalDistributedMember) getDistributedMember()).getPort() == 0) {
-  
+
-   * returns a string representation of this identifier, ignoring the toString
-   * cache
+   * returns a string representation of this identifier, ignoring the toString cache
-    StringBuffer sb = new StringBuffer("identity(").append(getDSMembership())
-    .append(",connection=").append(uniqueId);
+    StringBuffer sb = new StringBuffer("identity(").append(getDSMembership()).append(",connection=")
+        .append(uniqueId);
-    DurableClientAttributes dca = getDurableAttributes();
-    if (dca.getId().length() > 0) {
-      sb.append(",durableAttributes=")
-      .append(getDurableAttributes()).append(')').toString();
-    }
+      DurableClientAttributes dca = getDurableAttributes();
+      if (dca.getId().length() > 0) {
+        sb.append(",durableAttributes=").append(getDurableAttributes()).append(')').toString();
+      }
-  public void writeExternal(ObjectOutput out) throws IOException
-  {
-//    if (this.transientPort == 0) {
-//      InternalDistributedSystem.getLoggerI18n().warning(
-//          LocalizedStrings.DEBUG,
-//          "externalizing a client ID with zero port: " + this.toString(),
-//          new Exception("Stack trace"));
-//    }
+  public void writeExternal(ObjectOutput out) throws IOException {
+    // if (this.transientPort == 0) {
+    // InternalDistributedSystem.getLoggerI18n().warning(
+    // LocalizedStrings.DEBUG,
+    // "externalizing a client ID with zero port: " + this.toString(),
+    // new Exception("Stack trace"));
+    // }
-  public int getSerializedSize()
-  {
+  public int getSerializedSize() {
-  public void readExternal(ObjectInput in) throws IOException,
-      ClassNotFoundException
-  {
+  public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
-      throw new IOException(LocalizedStrings.ClientProxyMembershipID_HANDSHAKE_IDENTITY_LENGTH_IS_TOO_BIG.toLocalizedString());
+      throw new IOException(
+          LocalizedStrings.ClientProxyMembershipID_HANDSHAKE_IDENTITY_LENGTH_IS_TOO_BIG
+              .toLocalizedString());
-      throw new IOException(LocalizedStrings.ClientProxyMembershipID_UNEXPECTED_EOF_REACHED_UNIQUE_ID_COULD_NOT_BE_READ.toLocalizedString());
+      throw new IOException(
+          LocalizedStrings.ClientProxyMembershipID_UNEXPECTED_EOF_REACHED_UNIQUE_ID_COULD_NOT_BE_READ
+              .toLocalizedString());
-//    {toString(); this.transientPort = ((InternalDistributedMember)this.memberId).getPort();}
+    // {toString(); this.transientPort = ((InternalDistributedMember)this.memberId).getPort();}
-  private void read(ObjectInput dis, byte[] toFill) throws IOException
-  {
+  private void read(ObjectInput dis, byte[] toFill) throws IOException {
-        throw new IOException(LocalizedStrings.ClientProxyMembershipID_UNEXPECTED_EOF_REACHED_DISTRIBUTED_MEMBERSHIPID_COULD_NOT_BE_READ.toLocalizedString());
+        throw new IOException(
+            LocalizedStrings.ClientProxyMembershipID_UNEXPECTED_EOF_REACHED_DISTRIBUTED_MEMBERSHIPID_COULD_NOT_BE_READ
+                .toLocalizedString());
-  public void toData(DataOutput out) throws IOException
-  {
-//    if (this.transientPort == 0) {
-//      InternalDistributedSystem.getLoggerI18n().warning(
-//          LocalizedStrings.DEBUG,
-//          "serializing a client ID with zero port: " + this.toString(),
-//          new Exception("Stack trace"));
-//    }
+  public void toData(DataOutput out) throws IOException {
+    // if (this.transientPort == 0) {
+    // InternalDistributedSystem.getLoggerI18n().warning(
+    // LocalizedStrings.DEBUG,
+    // "serializing a client ID with zero port: " + this.toString(),
+    // new Exception("Stack trace"));
+    // }
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException
-  {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-//    {toString(); this.transientPort = ((InternalDistributedMember)this.memberId).getPort();}
-  }
-  
-  public Version getClientVersion() {
-    return ((InternalDistributedMember)getDistributedMember()).getVersionObject();
+    // {toString(); this.transientPort = ((InternalDistributedMember)this.memberId).getPort();}
-  public String getDSMembership()
-  {
+  public Version getClientVersion() {
+    return ((InternalDistributedMember) getDistributedMember()).getVersionObject();
+  }
+
+  public String getDSMembership() {
-    if (((InternalDistributedMember)getDistributedMember()).getPort() == 0) {
+    if (((InternalDistributedMember) getDistributedMember()).getPort() == 0) {
-   * this method uses CacheClientNotifier to try to obtain an ID that 
-   * is equal to this one.  This is used during deserialization to
-   * reduce storage overhead.
+   * this method uses CacheClientNotifier to try to obtain an ID that is equal to this one. This is
+   * used during deserialization to reduce storage overhead.
-   * deserializes the membership id, if necessary, and returns it. All access to
-   * membershipId should be through this method
+   * deserializes the membership id, if necessary, and returns it. All access to membershipId should
+   * be through this method
-  
-  public DistributedMember getDistributedMember()  {
-    if (memberId == null) {      
+
+  public DistributedMember getDistributedMember() {
+    if (memberId == null) {
-        memberId = (DistributedMember)DataSerializer.readObject(dis);
-      }
-      catch (Exception e) {
-        logger.error(LocalizedMessage.create(LocalizedStrings.ClientProxyMembershipID_UNABLE_TO_DESERIALIZE_MEMBERSHIP_ID), e);
+        memberId = (DistributedMember) DataSerializer.readObject(dis);
+      } catch (Exception e) {
+        logger.error(LocalizedMessage.create(
+            LocalizedStrings.ClientProxyMembershipID_UNABLE_TO_DESERIALIZE_MEMBERSHIP_ID), e);
-  
+
-  byte[] getMembershipByteArray()
-  {
+  byte[] getMembershipByteArray() {
-  
+
+   * 
-    String durableClientId = getDistributedMember().getDurableClientAttributes().getId(); 
+    String durableClientId = getDistributedMember().getDurableClientAttributes().getId();
-  
+
+   * 
-  
+
+   * 
-  
+
+   * 
-  
+
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD", justification = "Only applicable in client DS and in that case too multiple instances do not modify it at the same time.")
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(
+      value = "ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD",
+      justification = "Only applicable in client DS and in that case too multiple instances do not modify it at the same time.")
-//    this.transientPort = ((InternalDistributedMember)this.memberId).getPort();
-//    if (this.transientPort == 0) {
-//      InternalDistributedSystem.getLoggerI18n().warning(
-//          LocalizedStrings.DEBUG,
-//          "updating client ID when member port is zero: " + this.memberId,
-//          new Exception("stack trace")
-//          );
-//    }
+    // this.transientPort = ((InternalDistributedMember)this.memberId).getPort();
+    // if (this.transientPort == 0) {
+    // InternalDistributedSystem.getLoggerI18n().warning(
+    // LocalizedStrings.DEBUG,
+    // "updating client ID when member port is zero: " + this.memberId,
+    // new Exception("stack trace")
+    // );
+    // }
-      //client_side_identity = this.identity;
+      // client_side_identity = this.identity;
-    this._toString = null;  // make sure we don't retain the old ID representation in toString
+    this._toString = null; // make sure we don't retain the old ID representation in toString
-    
-  
+
+
-   * Return the name of the <code>HARegion</code> queueing this proxy's
-   * messages. This is name is generated based on whether or not this proxy id
-   * is durable. If this proxy id is durable, then the durable client id is
-   * used. If this proxy id is not durable, then the<code>DistributedMember</code>
-   * string is used.
+   * Return the name of the <code>HARegion</code> queueing this proxy's messages. This is name is
+   * generated based on whether or not this proxy id is durable. If this proxy id is durable, then
+   * the durable client id is used. If this proxy id is not durable, then
+   * the<code>DistributedMember</code> string is used.
-   * @return the name of the <code>HARegion</code> queueing this proxy's
-   * messages.
+   * @return the name of the <code>HARegion</code> queueing this proxy's messages.
-  
+
-   * Return the name of the region used for communicating interest changes
-   * between servers.
+   * Return the name of the region used for communicating interest changes between servers.
-   * @return the name of the region used for communicating interest changes
-   * between servers
+   * @return the name of the region used for communicating interest changes between servers
-  
+
-    String id = isDurable()? getDurableId() : getDSMembership();
+    String id = isDurable() ? getDurableId() : getDSMembership();
-    StringBuffer buffer = new StringBuffer()
-      .append("_gfe_")
-      .append(isDurable() ? "" : "non_")
-      .append("durable_client_")
-      .append("with_id_"+id)
-      .append("_")
-      .append(this.uniqueId);
+    StringBuffer buffer = new StringBuffer().append("_gfe_").append(isDurable() ? "" : "non_")
+        .append("durable_client_").append("with_id_" + id).append("_").append(this.uniqueId);
-   * Resets the unique id counter. This is done for durable clients that
-   * stops/starts its cache. When it restarts its cache, it needs to maintain
-   * the same unique id
+   * Resets the unique id counter. This is done for durable clients that stops/starts its cache.
+   * When it restarts its cache, it needs to maintain the same unique id
-  
+
-   * Used to represent a unique identity of this ClientProxyMembershipID.
-   * It does this by ignoring the durable id and only respecting the
-   * unique_id and identity.
+   * Used to represent a unique identity of this ClientProxyMembershipID. It does this by ignoring
+   * the durable id and only respecting the unique_id and identity.
-   * This class is used to clean up resources associated with a particular
-   * client and thus does not want to limit itself to the durable id.
+   * This class is used to clean up resources associated with a particular client and thus does not
+   * want to limit itself to the durable id.
+   * 
+
+
-      return (getUniqueId() == that.getUniqueId() &&
-              Arrays.equals(getMemberIdBytes(), that.getMemberIdBytes()));
+      return (getUniqueId() == that.getUniqueId()
+          && Arrays.equals(getMemberIdBytes(), that.getMemberIdBytes()));
+
-    
+
-    
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
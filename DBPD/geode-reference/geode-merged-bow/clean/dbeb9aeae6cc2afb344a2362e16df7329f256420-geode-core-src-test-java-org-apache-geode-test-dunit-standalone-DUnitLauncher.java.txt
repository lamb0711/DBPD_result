Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import static org.apache.geode.distributed.ConfigurationProperties.*;
+import static org.apache.geode.distributed.internal.DistributionConfig.*;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.FileReader;
+import java.io.IOException;
+import java.lang.reflect.Method;
+import java.net.InetAddress;
+import java.net.URISyntaxException;
+import java.nio.channels.FileChannel;
+import java.nio.charset.Charset;
+import java.rmi.AccessException;
+import java.rmi.AlreadyBoundException;
+import java.rmi.NotBoundException;
+import java.rmi.Remote;
+import java.rmi.RemoteException;
+import java.rmi.registry.LocateRegistry;
+import java.rmi.registry.Registry;
+import java.rmi.server.UnicastRemoteObject;
+import java.util.List;
+import java.util.Properties;
+
+import hydra.MethExecutorResult;
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.core.LoggerContext;
+import org.apache.logging.log4j.core.appender.FileAppender;
+import org.apache.logging.log4j.core.config.LoggerConfig;
+import org.apache.logging.log4j.core.layout.PatternLayout;
+import org.junit.Assert;
+
-import hydra.MethExecutorResult;
-import org.apache.logging.log4j.Level;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.core.LoggerContext;
-import org.apache.logging.log4j.core.appender.FileAppender;
-import org.apache.logging.log4j.core.config.LoggerConfig;
-import org.apache.logging.log4j.core.layout.PatternLayout;
-import org.junit.Assert;
-
-import java.io.*;
-import java.lang.reflect.Method;
-import java.net.InetAddress;
-import java.net.URISyntaxException;
-import java.nio.channels.FileChannel;
-import java.nio.charset.Charset;
-import java.rmi.*;
-import java.rmi.registry.LocateRegistry;
-import java.rmi.registry.Registry;
-import java.rmi.server.UnicastRemoteObject;
-import java.util.List;
-import java.util.Properties;
-
-import static org.apache.geode.distributed.ConfigurationProperties.*;
+import org.apache.geode.test.dunit.internal.JUnit4DistributedTestCase;
- * 
- * For use within eclipse. This class completely skips hydra and just starts
- * some vms directly, creating a fake test configuration
- * 
- * Also, it's a good idea to set your working directory, because the test code
- * a lot of files that it leaves around.
+ *
+ * For use within eclipse. This class completely skips hydra and just starts some vms directly,
+ * creating a fake test configuration
+ *
+ * Also, it's a good idea to set your working directory, because the test code a lot of files that
+ * it leaves around.
-  /** change this to use a different log level in unit tests */
+  /**
+   * change this to use a different log level in unit tests
+   */
-  
+
-  
+
+  /**
+   * change this to have dunit/vmX directories deleted and recreated when processes are launched
+   */
+  public static final boolean MAKE_NEW_WORKING_DIRS =
+      Boolean.getBoolean("makeNewWorkingDirsOnBounce");
+
-  static final long STARTUP_TIMEOUT = 30 * 1000;
+  static final long STARTUP_TIMEOUT = 120 * 1000;
+  private static final String STARTUP_TIMEOUT_MESSAGE =
+      "VMs did not start up within " + (STARTUP_TIMEOUT / 1000) + " seconds";
+
-  public static final String RMI_PORT_PARAM = DistributionConfig.GEMFIRE_PREFIX + "DUnitLauncher.RMI_PORT";
-  static final String VM_NUM_PARAM = DistributionConfig.GEMFIRE_PREFIX + "DUnitLauncher.VM_NUM";
-  private static final String LAUNCHED_PROPERTY = DistributionConfig.GEMFIRE_PREFIX + "DUnitLauncher.LAUNCHED";
+  public static final String RMI_PORT_PARAM = GEMFIRE_PREFIX + "DUnitLauncher.RMI_PORT";
+  static final String VM_NUM_PARAM = GEMFIRE_PREFIX + "DUnitLauncher.VM_NUM";
+  static final String VM_VERSION_PARAM = GEMFIRE_PREFIX + "DUnitLauncher.VM_VERSION";
+
+  private static final String LAUNCHED_PROPERTY = GEMFIRE_PREFIX + "DUnitLauncher.LAUNCHED";
-  private DUnitLauncher() {
-  }
-  
+  private DUnitLauncher() {}
+
-      //TODO - this is hacky way to test for a hydra environment - see
-      //if there is registered test configuration object.
+      // TODO - this is hacky way to test for a hydra environment - see
+      // if there is registered test configuration object.
-   * Launch DUnit. If the unit test was launched through
-   * the hydra framework, leave the test alone.
+   * Launch DUnit. If the unit test was launched through the hydra framework, leave the test alone.
-    if(System.getProperties().contains(VM_NUM_PARAM)) {
-      //we're a dunit child vm, do nothing.
+    if (System.getProperties().contains(VM_NUM_PARAM)) {
+      // we're a dunit child vm, do nothing.
-    if(!isHydra() &&!isLaunched()) {
+    if (!isHydra() && !isLaunched()) {
-        throw new RuntimeException("Unable to launch dunit VMS", e);
+        throw new RuntimeException("Unable to launch dunit VMs", e);
+
+    Host.setAllVMsToCurrentVersion();
-  
+
-  
+
-  private static void launch() throws URISyntaxException, AlreadyBoundException, IOException, InterruptedException, NotBoundException {
+  private static void launch() throws URISyntaxException, AlreadyBoundException, IOException,
+      InterruptedException, NotBoundException {
-    
-    //create an RMI registry and add an object to share our tests config
+
+    // create an RMI registry and add an object to share our tests config
-    System.setProperty(RMI_PORT_PARAM, ""+namingPort);
+    System.setProperty(RMI_PORT_PARAM, "" + namingPort);
+
+    JUnit4DistributedTestCase.initializeBlackboard();
-    
+
-//        System.out.println("shutting down DUnit JVMs");
-//        for (int i=0; i<NUM_VMS; i++) {
-//          try {
-//            processManager.getStub(i).shutDownVM();
-//          } catch (Exception e) {
-//            System.out.println("exception shutting down vm_"+i+": " + e);
-//          }
-//        }
-//        // TODO - hasLiveVMs always returns true
-//        System.out.print("waiting for JVMs to exit");
-//        long giveUp = System.currentTimeMillis() + 5000;
-//        while (giveUp > System.currentTimeMillis()) {
-//          if (!processManager.hasLiveVMs()) {
-//            return;
-//          }
-//          System.out.print(".");
-//          System.out.flush();
-//          try {
-//            Thread.sleep(1000);
-//          } catch (InterruptedException e) {
-//            break;
-//          }
-//        }
-//        System.out.println("\nkilling any remaining JVMs");
+        // System.out.println("shutting down DUnit JVMs");
+        // for (int i=0; i<NUM_VMS; i++) {
+        // try {
+        // processManager.getStub(i).shutDownVM();
+        // } catch (Exception e) {
+        // System.out.println("exception shutting down vm_"+i+": " + e);
+        // }
+        // }
+        // // TODO - hasLiveVMs always returns true
+        // System.out.print("waiting for JVMs to exit");
+        // long giveUp = System.currentTimeMillis() + 5000;
+        // while (giveUp > System.currentTimeMillis()) {
+        // if (!processManager.hasLiveVMs()) {
+        // return;
+        // }
+        // System.out.print(".");
+        // System.out.flush();
+        // try {
+        // Thread.sleep(1000);
+        // } catch (InterruptedException e) {
+        // break;
+        // }
+        // }
+        // System.out.println("\nkilling any remaining JVMs");
-
-    //Create a VM for the locator
+    // Create a VM for the locator
-    //wait for the VM to start up
-    if(!processManager.waitForVMs(STARTUP_TIMEOUT)) {
-      throw new RuntimeException("VMs did not start up with 30 seconds");
+    // wait for the VM to start up
+    if (!processManager.waitForVMs(STARTUP_TIMEOUT)) {
+      throw new RuntimeException(STARTUP_TIMEOUT_MESSAGE);
-
-    //Launch an initial set of VMs
-    for(int i=0; i < NUM_VMS; i++) {
+    // Launch an initial set of VMs
+    for (int i = 0; i < NUM_VMS; i++) {
-    //wait for the VMS to start up
-    if(!processManager.waitForVMs(STARTUP_TIMEOUT)) {
-      throw new RuntimeException("VMs did not start up with 30 seconds");
+    // wait for the VMS to start up
+    if (!processManager.waitForVMs(STARTUP_TIMEOUT)) {
+      throw new RuntimeException(STARTUP_TIMEOUT_MESSAGE);
-    //populate the Host class with our stubs. The tests use this host class
-    DUnitHost host = new DUnitHost(InetAddress.getLocalHost().getCanonicalHostName(), processManager);
+    // populate the Host class with our stubs. The tests use this host class
+    DUnitHost host =
+        new DUnitHost(InetAddress.getLocalHost().getCanonicalHostName(), processManager);
-  
+
-   * Add an appender to Log4j which sends all INFO+ messages to a separate file
-   * which will be used later to scan for suspect strings.  The pattern of the
-   * messages conforms to the original log format so that hydra will be able
-   * to parse them.
+   * Add an appender to Log4j which sends all INFO+ messages to a separate file which will be used
+   * later to scan for suspect strings. The pattern of the messages conforms to the original log
+   * format so that hydra will be able to parse them.
-    final LoggerContext appenderContext = ((org.apache.logging.log4j.core.Logger)
-        LogManager.getLogger(LogService.BASE_LOGGER_NAME)).getContext();
+    final LoggerContext appenderContext =
+        ((org.apache.logging.log4j.core.Logger) LogManager.getLogger(LogService.BASE_LOGGER_NAME))
+            .getContext();
-        "[%level{lowerCase=true} %date{yyyy/MM/dd HH:mm:ss.SSS z} <%thread> tid=%tid] %message%n%throwable%n", null, null, null,
-        Charset.defaultCharset(), true, false, "", "");
-    
+        "[%level{lowerCase=true} %date{yyyy/MM/dd HH:mm:ss.SSS z} <%thread> tid=%tid] %message%n%throwable%n",
+        null, null, null, Charset.defaultCharset(), true, false, "", "");
+
-        DUnitLauncher.class.getName(), "true", "false", "false", "0", layout, null, null, null, appenderContext.getConfiguration());
+        DUnitLauncher.class.getName(), "true", "false", "false", "0", layout, null, null, null,
+        appenderContext.getConfiguration());
-    LoggerConfig loggerConfig = appenderContext.getConfiguration().getLoggerConfig(LogService.BASE_LOGGER_NAME);
+    LoggerConfig loggerConfig =
+        appenderContext.getConfiguration().getLoggerConfig(LogService.BASE_LOGGER_NAME);
-  
+
-        LOCATOR_LOG_TO_DISK ? new File("locator-" + locatorPort + ".log") : new File(""); 
+        LOCATOR_LOG_TO_DISK ? new File("locator-" + locatorPort + ".log") : new File("");
-        //Disable the shared configuration on this locator.
-        //Shared configuration tests create their own locator
+        // Disable the shared configuration on this locator.
+        // Shared configuration tests create their own locator
-        //Tell the locator it's the first in the system for
-        //faster boot-up
+        // Tell the locator it's the first in the system for
+        // faster boot-up
-        
+
-    if(result.getException() != null) {
+    if (result.getException() != null) {
-    //fake out tests that are using a bunch of hydra stuff
-    String workspaceDir = System.getProperty(DUnitLauncher.WORKSPACE_DIR_PARAM) ;
+    // fake out tests that are using a bunch of hydra stuff
+    String workspaceDir = System.getProperty(DUnitLauncher.WORKSPACE_DIR_PARAM);
-    
+
-    
-    //Free off heap memory when disconnecting from the distributed system
-    System.setProperty(DistributionConfig.GEMFIRE_PREFIX + "free-off-heap-memory", "true");
-    
-    //indicate that this CM is controlled by the eclipse dunit.
+
+    // Free off heap memory when disconnecting from the distributed system
+    System.setProperty(GEMFIRE_PREFIX + "free-off-heap-memory", "true");
+
+    // indicate that this CM is controlled by the eclipse dunit.
-  
+
-        
+
-        
+
-        
+
+
+
+
+
+
+    public BounceResult bounce(String version, int pid) throws RemoteException;
-  
+
-    
+
-    public int getLocatorPort()  throws RemoteException{
+    public int getLocatorPort() throws RemoteException {
-    
+
-      //do nothing
+      // do nothing
-      processManager.bounce(pid);
-      
+      return bounce(VersionManager.CURRENT_VERSION, pid);
+    }
+
+    @Override
+    public BounceResult bounce(String version, int pid) {
+      processManager.bounce(version, pid);
+
-        if(!processManager.waitForVMs(STARTUP_TIMEOUT)) {
-          throw new RuntimeException("VMs did not start up with 30 seconds");
+        if (!processManager.waitForVMs(STARTUP_TIMEOUT)) {
+          throw new RuntimeException(STARTUP_TIMEOUT_MESSAGE);
-        RemoteDUnitVMIF remote = (RemoteDUnitVMIF) registry.lookup("vm" + pid);
+        RemoteDUnitVMIF remote =
+            (RemoteDUnitVMIF) registry.lookup(VM.getVMName(VersionManager.CURRENT_VERSION, pid));
-  
+
-    
+
-    
+
-    
-    public void init(Registry registry, int numVMs) throws AccessException, RemoteException, NotBoundException, InterruptedException {
-      for(int i = 0; i < numVMs; i++) {
+
+    public void init(Registry registry, int numVMs)
+        throws AccessException, RemoteException, NotBoundException, InterruptedException {
+      for (int i = 0; i < numVMs; i++) {
-      
+
-      
+
-      
-      if(n == DEBUGGING_VM_NUM) {
-        //for ease of debugging, pass -1 to get the local VM
+      return getVM(VersionManager.CURRENT_VERSION, n);
+    }
+
+    @Override
+    public VM getVM(String version, int n) {
+      if (n == DEBUGGING_VM_NUM) {
+        // for ease of debugging, pass -1 to get the local VM
+      if (n < getVMCount()) {
+        VM current = super.getVM(n);
+        if (!current.getVersion().equals(version)) {
+          System.out.println(
+              "Bouncing VM" + n + " from version " + current.getVersion() + " to " + version);
+          current.bounce(version);
+        }
+        return current;
+      }
+
-      if(n >= oldVMCount) {
-        //If we don't have a VM with that number, dynamically create it.
+      if (n >= oldVMCount) {
+        // If we don't have a VM with that number, dynamically create it.
-          for(int i = oldVMCount; i <= n; i++) {
+          // first fill in any gaps, to keep the superclass, Host, happy
+          for (int i = oldVMCount; i < n; i++) {
-          for(int i = oldVMCount; i <= n; i++) {
+          for (int i = oldVMCount; i < n; i++) {
+          // now create the one we really want
+          processManager.launchVM(version, n, false);
+          processManager.waitForVMs(STARTUP_TIMEOUT);
+          addVM(n, processManager.getStub(n));
+
-      
+

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS23 INS23 INS23 INS29 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 MOV43 INS59 MOV43 INS83 INS83 INS43 INS59 INS43 MOV25 MOV25 INS31 INS31 INS31 UPD66 UPD66 UPD66 UPD66 INS65 INS42 INS32 INS42 INS27 INS42 INS42 INS27 INS42 INS21 INS21 INS83 INS43 INS42 INS44 INS44 INS43 INS78 INS83 INS43 INS42 INS44 INS8 INS44 INS78 INS83 INS43 INS42 INS44 INS8 INS44 UPD66 INS66 INS42 INS42 INS45 UPD34 INS45 INS36 INS45 INS42 INS42 INS42 INS45 INS42 UPD66 INS32 INS32 UPD66 UPD66 UPD66 INS42 INS43 INS42 INS39 INS42 INS42 INS42 INS42 INS39 INS42 INS41 INS43 INS42 INS42 INS42 INS39 INS42 INS41 INS43 INS42 INS25 INS27 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS27 INS8 INS42 INS34 INS42 INS42 INS40 INS42 INS42 INS42 INS40 INS42 INS42 INS32 INS60 INS25 INS41 INS42 INS42 MOV43 INS42 INS43 INS59 INS38 INS8 INS42 INS42 INS42 INS48 INS32 INS21 INS21 INS21 INS21 INS21 MOV43 INS42 INS42 INS32 INS42 INS42 INS32 INS32 UPD27 UPD27 INS32 INS32 INS32 UPD45 INS42 INS32 INS42 INS42 INS40 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS40 INS42 INS45 INS42 INS45 INS32 INS45 INS42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL40 DEL40 DEL66 DEL45 DEL45 DEL66 DEL40 DEL45 DEL45 DEL42 DEL27
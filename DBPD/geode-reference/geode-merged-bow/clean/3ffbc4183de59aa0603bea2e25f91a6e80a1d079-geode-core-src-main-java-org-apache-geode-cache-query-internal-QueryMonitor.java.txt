GEODE-6488: Migrating cancellation state to execution context (#3322)

This work solves two problems.  One is that the query cancellation task
reference in DefaultQuery could be overwritten and thus never removed
from monitoring upon successful completion of a query.  Second is that
once a query execution timed out once, the query object was in an
unusable state which is undesirable.

The solution is to attach the cancellation state to the execution
context rather than the query object, so that cancellation is associated
with each independent execution of a query rather than having
cancellation state that applies to the entire query object.
- * The {@link #monitorQueryThread(DefaultQuery)} method initiates monitoring of a query. {@link
- * #stopMonitoringQueryThread(DefaultQuery)} stops monitoring a query.
+ * The {@link #monitorQueryExecution(ExecutionContext)} method initiates monitoring of a query.
+ * {@link
+ * #stopMonitoringQueryExecution(ExecutionContext)} stops monitoring a query.
- * {@link DefaultQuery#setQueryCanceledException(CacheRuntimeException)}</li>
- * <li>sets the {@link DefaultQuery#queryCanceled} thread-local variable to {@code true}
+ * {@link ExecutionContext#setQueryCanceledException(CacheRuntimeException)}</li>
+ * <li>sets the {@link ExecutionContext#queryCanceled} thread-local variable to {@code true}
- * blocks, {@link DefaultQuery#getQueryCanceledException()} is interrogated to learn the cancelation
- * cause.
+ * blocks, {@link ExecutionContext#getQueryCanceledException()} is interrogated to learn the
+ * cancelation cause.
-   * immediately upon cancelation (via {@link #stopMonitoringQueryThread(DefaultQuery)}).
+   * immediately upon cancelation (via {@link #stopMonitoringQueryExecution(ExecutionContext)}).
-  public void monitorQueryThread(final DefaultQuery query) {
-    monitorQueryThread(query, defaultMaxQueryExecutionTime);
+  public void monitorQueryExecution(final ExecutionContext executionContext) {
+    monitorQueryExecution(executionContext, defaultMaxQueryExecutionTime);
-  private void monitorQueryThread(final DefaultQuery query,
+  private void monitorQueryExecution(final ExecutionContext executionContext,
-    if (query.isCqQuery()) {
+    if (executionContext.isCqQueryContext()) {
-    query.setCancelationTask(scheduleCancelationTask(query, maxQueryExecutionTime));
+    executionContext
+        .setCancelationTask(scheduleCancelationTask(executionContext, maxQueryExecutionTime));
-      logDebug(query, "Adding thread to QueryMonitor.");
+      logDebug(executionContext, "Adding thread to QueryMonitor.");
-  public void stopMonitoringQueryThread(final DefaultQuery query) {
-    query.getCancelationTask().ifPresent(task -> task.cancel(false));
+  public void stopMonitoringQueryExecution(final ExecutionContext executionContext) {
+    executionContext.getCancelationTask().ifPresent(task -> task.cancel(false));
-      logDebug(query, "Query completed before cancelation.");
+      logDebug(executionContext, "Query completed before cancelation.");
-    if (DefaultQuery.queryCanceled.get().get()) {
+    if (ExecutionContext.isCanceled.get().get()) {
-        DefaultQuery query);
+        ExecutionContext executionContext);
-        DefaultQuery query);
+        ExecutionContext executionContext);
-          final DefaultQuery query) {
+          final ExecutionContext executionContext) {
-          final DefaultQuery query) {
+          final ExecutionContext executionContext) {
-          logger.info(String.format("%s %s", message, query));
+          logger.info(String.format("%s %s", message, executionContext));
-          final DefaultQuery query) {
+          final ExecutionContext executionContext) {
-            createCancelationException(timeLimitMillis, query);
-        query.setQueryCanceledException(lowMemoryException);
+            createCancelationException(timeLimitMillis, executionContext);
+        executionContext.setQueryCanceledException(lowMemoryException);
-          final DefaultQuery query) {
+          final ExecutionContext executionContext) {
-  private ScheduledFuture<?> scheduleCancelationTask(final DefaultQuery query,
+  private ScheduledFuture<?> scheduleCancelationTask(final ExecutionContext executionContext,
-    // Make ThreadLocal queryCanceled available to closure, which will run in a separate thread
+    // Make ThreadLocal isCanceled available to closure, which will run in a separate thread
-        DefaultQuery.queryCanceled.get();
+        ExecutionContext.isCanceled.get();
-          .createCancelationException(timeLimitMillis, query);
+          .createCancelationException(timeLimitMillis, executionContext);
-      query.setQueryCanceledException(exception);
+      executionContext.setQueryCanceledException(exception);
-    }, timeLimitMillis, TimeUnit.MILLISECONDS, executor, query);
+    }, timeLimitMillis, TimeUnit.MILLISECONDS, executor, executionContext);
-  private void logDebug(final DefaultQuery query, final String message) {
+  private void logDebug(final ExecutionContext executionContext, final String message) {
-        executor.getQueue().size(), queryThread.getId(), query.getQueryString(),
+        executor.getQueue().size(), queryThread.getId(),
+        executionContext.getQuery().getQueryString(),

UPD42 UPD42 UPD42 UPD66 UPD66 UPD66 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD42 UPD42 UPD42 UPD43 UPD42 UPD43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD43 UPD42 UPD42 UPD42 UPD40 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD40 INS32 UPD42 UPD42 UPD43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42
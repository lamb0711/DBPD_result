Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-//import org.apache.geode.internal.*;
-//import org.apache.geode.distributed.internal.*;
+// import org.apache.geode.internal.*;
+// import org.apache.geode.distributed.internal.*;
-  
+
-  public boolean supportsDirectAck()
-  {
+  public boolean supportsDirectAck() {
-  
+
+
-  /** Creates new instance of DestroyRegionOperation
-   * @param notifyOfRegionDeparture was added to fix bug 41111. If false then don't
-   * deliver afterRemoteRegionDeparture events.
+  /**
+   * Creates new instance of DestroyRegionOperation
+   * 
+   * @param notifyOfRegionDeparture was added to fix bug 41111. If false then don't deliver
+   *        afterRemoteRegionDeparture events.
-  protected Set getRecipients()
-  {
+  protected Set getRecipients() {
-  protected boolean shouldAck()
-  {
+  protected boolean shouldAck() {
-  protected CacheOperationMessage createMessage()
-  {
+  protected CacheOperationMessage createMessage() {
-      ((DestroyRegionWithContextMessage)mssg).context = ((ClientRegionEventImpl)this.event)
-          .getContext();
-    }
-    else {
+      ((DestroyRegionWithContextMessage) mssg).context =
+          ((ClientRegionEventImpl) this.event).getContext();
+    } else {
-    
+
-    
-    RegionEventImpl rei = (RegionEventImpl)this.event;
+
+    RegionEventImpl rei = (RegionEventImpl) this.event;
-  public static class DestroyRegionMessage extends CacheOperationMessage
-   {
+  public static class DestroyRegionMessage extends CacheOperationMessage {
-    
+
-    
+
-     * true if need to automatically recreate region, and mark destruction as a
-     * reinitialization
+     * true if need to automatically recreate region, and mark destruction as a reinitialization
-                                                   // lock acquisition
+    // lock acquisition
-    protected InternalCacheEvent createEvent(DistributedRegion rgn)
-        throws EntryNotFoundException
-    {
+    protected InternalCacheEvent createEvent(DistributedRegion rgn) throws EntryNotFoundException {
-        event.setLocalFilterInfo(this.filterRouting
-            .getFilterInfo((InternalDistributedMember)rgn.getMyId()));
+        event.setLocalFilterInfo(
+            this.filterRouting.getFilterInfo((InternalDistributedMember) rgn.getMyId()));
-    
-    protected RegionEventImpl createRegionEvent(DistributedRegion rgn)
-    {     
-      RegionEventImpl event = new RegionEventImpl(rgn, getOperation(),
-          this.callbackArg, true /* originRemote */, getSender());
+
+    protected RegionEventImpl createRegionEvent(DistributedRegion rgn) {
+      RegionEventImpl event = new RegionEventImpl(rgn, getOperation(), this.callbackArg,
+          true /* originRemote */, getSender());
-    private Runnable destroyOp(final DistributionManager dm,
-        final LocalRegion lclRgn, final boolean sendReply) {
+    private Runnable destroyOp(final DistributionManager dm, final LocalRegion lclRgn,
+        final boolean sendReply) {
-        public void run()
-        {
-          final int oldLevel = LocalRegion
-              .setThreadInitLevelRequirement(LocalRegion.BEFORE_INITIAL_IMAGE);
+        public void run() {
+          final int oldLevel =
+              LocalRegion.setThreadInitLevelRequirement(LocalRegion.BEFORE_INITIAL_IMAGE);
-          
+
-                advisee = PartitionedRegionHelper.getProxyBucketRegion(GemFireCacheImpl.getInstance(), regionPath, 
-                      waitForBucketInitializationToComplete);
-              }
-              catch (PRLocallyDestroyedException e) {
+                advisee =
+                    PartitionedRegionHelper.getProxyBucketRegion(GemFireCacheImpl.getInstance(),
+                        regionPath, waitForBucketInitializationToComplete);
+              } catch (PRLocallyDestroyedException e) {
-              }
-              catch (RegionDestroyedException e) {
+              } catch (RegionDestroyedException e) {
-              }
-              catch (PartitionedRegionException e) {
+              } catch (PartitionedRegionException e) {
-                advisee.getDistributionAdvisor()
-                    .removeIdWithSerial(getSender(), serialNum, isDestroy);
-              }
-              else
-              if (logger.isDebugEnabled()) {
+                advisee.getDistributionAdvisor().removeIdWithSerial(getSender(), serialNum,
+                    isDestroy);
+              } else if (logger.isDebugEnabled()) {
-            final LocalRegion lr = getRegionFromPath(dm.getSystem(), lclRgn
-                .getFullPath());
+            final LocalRegion lr = getRegionFromPath(dm.getSystem(), lclRgn.getFullPath());
-            DistributedRegion rgn = (DistributedRegion)lr;
+            DistributedRegion rgn = (DistributedRegion) lr;
-            if (DestroyRegionMessage.this.needsRouting && lclRgn.cache.getCacheServers().size() > 0) {
+            if (DestroyRegionMessage.this.needsRouting
+                && lclRgn.cache.getCacheServers().size() > 0) {
-          }
-          catch (RegionDestroyedException e) {
+          } catch (RegionDestroyedException e) {
-          }
-          catch (CancelException e) {
+          } catch (CancelException e) {
-          }
-          catch (EntryNotFoundException e) {
+          } catch (EntryNotFoundException e) {
-          }
-          catch (VirtualMachineError err) {
+          } catch (VirtualMachineError err) {
-            // If this ever returns, rethrow the error.  We're poisoned
+            // If this ever returns, rethrow the error. We're poisoned
-          }
-          catch (Throwable t) {
+          } catch (Throwable t) {
-            // catch VirtualMachineError (see above).  However, there is
+            // catch VirtualMachineError (see above). However, there is
-          }
-          finally {
+          } finally {
-                sendReply(getSender(), DestroyRegionMessage.this.processorId,
-                    rex, getReplySender(dm));
+                sendReply(getSender(), DestroyRegionMessage.this.processorId, rex,
+                    getReplySender(dm));
-            }
-            else if (thr != null) {
-              logger.error(LocalizedMessage.create(LocalizedStrings.DestroyRegionOperation_EXCEPTION_WHILE_PROCESSING__0_, this), thr);
+            } else if (thr != null) {
+              logger.error(
+                  LocalizedMessage.create(
+                      LocalizedStrings.DestroyRegionOperation_EXCEPTION_WHILE_PROCESSING__0_, this),
+                  thr);
-    
+
-    protected void basicProcess(final DistributionManager dm,
-        final LocalRegion lclRgn)
-    {
+    protected void basicProcess(final DistributionManager dm, final LocalRegion lclRgn) {
-      }
-      catch (RejectedExecutionException e) {
+      } catch (RejectedExecutionException e) {
-    protected LocalRegion getRegionFromPath(InternalDistributedSystem sys,
-        String path)
-    {
+    protected LocalRegion getRegionFromPath(InternalDistributedSystem sys, String path) {
-      GemFireCacheImpl c = (GemFireCacheImpl)CacheFactory.getInstance(sys);
+      GemFireCacheImpl c = (GemFireCacheImpl) CacheFactory.getInstance(sys);
-        this.lockRoot = (LocalRegion)c.getRegion(rootName);
+        this.lockRoot = (LocalRegion) c.getRegion(rootName);
-      return (LocalRegion)c.getRegion(path);
+      return (LocalRegion) c.getRegion(path);
+
-    protected boolean doRegionDestroy(CacheEvent event)
-        throws EntryNotFoundException
-    {
+    protected boolean doRegionDestroy(CacheEvent event) throws EntryNotFoundException {
-      RegionEventImpl ev = (RegionEventImpl)event;
-      final DistributedRegion rgn = (DistributedRegion)ev.region;
+      RegionEventImpl ev = (RegionEventImpl) event;
+      final DistributedRegion rgn = (DistributedRegion) ev.region;
-          rgn.handleRemoteLocalRegionDestroyOrClose(
-                                                    getSender(), serialNum, subregionSerialNumbers, !getOperation().isClose());
+          rgn.handleRemoteLocalRegionDestroyOrClose(getSender(), serialNum, subregionSerialNumbers,
+              !getOperation().isClose());
-      
+
-          for (Iterator itr = rgn.debugGetSubregionNames().iterator(); itr
-              .hasNext();) {
+          for (Iterator itr = rgn.debugGetSubregionNames().iterator(); itr.hasNext();) {
-          logger.debug("Processing DestroyRegionOperation, about to destroy {}, has immediate subregions: {}", fullPath, subregionNames);
+          logger.debug(
+              "Processing DestroyRegionOperation, about to destroy {}, has immediate subregions: {}",
+              fullPath, subregionNames);
-            logger.debug("Processing DestroyRegionOperation, calling reinitialize_destroy: {}", fullPath);
+            logger.debug("Processing DestroyRegionOperation, calling reinitialize_destroy: {}",
+                fullPath);
-          rgn.getDistributionManager().getWaitingThreadPool().execute(
-              new Runnable() {
-                public void run()
-                {
-                  try {
-                    rgn.reinitializeFromImageTarget(getSender());
-                  }
-                  catch (TimeoutException e) {
-                    // dlock timed out, log message
-                    logger.warn(LocalizedMessage.create(
-                        LocalizedStrings.DestroyRegionOperation_GOT_TIMEOUT_WHEN_TRYING_TO_RECREATE_REGION_DURING_REINITIALIZATION_1, 
-                        rgn.getFullPath()), e);
-                  }
-                  catch (IOException e) {
-                    // only if loading snapshot, not here
-                    InternalGemFireError assErr = new InternalGemFireError(LocalizedStrings.UNEXPECTED_EXCEPTION.toLocalizedString());
-                    assErr.initCause(e);
-                    throw assErr;
-                  }
-                  catch (ClassNotFoundException e) {
-                    // only if loading snapshot, not here
-                    InternalGemFireError assErr = new InternalGemFireError(LocalizedStrings.UNEXPECTED_EXCEPTION.toLocalizedString());
-                    assErr.initCause(e);
-                    throw assErr;
-                  }
-                  finally {
-                    if (loc_lockRoot != null)
-                      loc_lockRoot.releaseDestroyLock();
-                  }
-                }
-              });
-        }
-        else {
+          rgn.getDistributionManager().getWaitingThreadPool().execute(new Runnable() {
+            public void run() {
+              try {
+                rgn.reinitializeFromImageTarget(getSender());
+              } catch (TimeoutException e) {
+                // dlock timed out, log message
+                logger.warn(LocalizedMessage.create(
+                    LocalizedStrings.DestroyRegionOperation_GOT_TIMEOUT_WHEN_TRYING_TO_RECREATE_REGION_DURING_REINITIALIZATION_1,
+                    rgn.getFullPath()), e);
+              } catch (IOException e) {
+                // only if loading snapshot, not here
+                InternalGemFireError assErr = new InternalGemFireError(
+                    LocalizedStrings.UNEXPECTED_EXCEPTION.toLocalizedString());
+                assErr.initCause(e);
+                throw assErr;
+              } catch (ClassNotFoundException e) {
+                // only if loading snapshot, not here
+                InternalGemFireError assErr = new InternalGemFireError(
+                    LocalizedStrings.UNEXPECTED_EXCEPTION.toLocalizedString());
+                assErr.initCause(e);
+                throw assErr;
+              } finally {
+                if (loc_lockRoot != null)
+                  loc_lockRoot.releaseDestroyLock();
+              }
+            }
+          });
+        } else {
-            logger.debug("Processing DestroyRegionOperation, calling basicDestroyRegion: {}", fullPath);
+            logger.debug("Processing DestroyRegionOperation, calling basicDestroyRegion: {}",
+                fullPath);
-      }
-      catch (CacheWriterException e) {
-        throw new Error(LocalizedStrings.DestroyRegionOperation_CACHEWRITER_SHOULD_NOT_HAVE_BEEN_CALLED.toLocalizedString());
-      }
-      catch (TimeoutException e) {
-        throw new Error(LocalizedStrings.DestroyRegionOperation_DISTRIBUTEDLOCK_SHOULD_NOT_HAVE_BEEN_ACQUIRED.toLocalizedString());
-      }
-      catch (RejectedExecutionException e) {
+      } catch (CacheWriterException e) {
+        throw new Error(
+            LocalizedStrings.DestroyRegionOperation_CACHEWRITER_SHOULD_NOT_HAVE_BEEN_CALLED
+                .toLocalizedString());
+      } catch (TimeoutException e) {
+        throw new Error(
+            LocalizedStrings.DestroyRegionOperation_DISTRIBUTEDLOCK_SHOULD_NOT_HAVE_BEEN_ACQUIRED
+                .toLocalizedString());
+      } catch (RejectedExecutionException e) {
-    return true;
+      return true;
-        throws EntryNotFoundException
-    {
-      Assert
-          .assertTrue(false,
-              LocalizedStrings.DestroyRegionOperation_REGION_DESTRUCTION_MESSAGE_IMPLEMENTATION_IS_IN_BASICPROCESS__NOT_THIS_METHOD.toLocalizedString());
+        throws EntryNotFoundException {
+      Assert.assertTrue(false,
+          LocalizedStrings.DestroyRegionOperation_REGION_DESTRUCTION_MESSAGE_IMPLEMENTATION_IS_IN_BASICPROCESS__NOT_THIS_METHOD
+              .toLocalizedString());
-    protected void appendFields(StringBuilder buff)
-    {
+    protected void appendFields(StringBuilder buff) {
-      buff.append("; eventID=")
-        .append(this.eventID)
-        .append("; serialNum=")
-        .append(this.serialNum)
-        .append("; subregionSerialNumbers=")
-        .append(this.subregionSerialNumbers)
-        .append("; notifyOfRegionDeparture=")
-        .append(this.notifyOfRegionDeparture);
+      buff.append("; eventID=").append(this.eventID).append("; serialNum=").append(this.serialNum)
+          .append("; subregionSerialNumbers=").append(this.subregionSerialNumbers)
+          .append("; notifyOfRegionDeparture=").append(this.notifyOfRegionDeparture);
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException
-    {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      this.eventID = (EventID)DataSerializer.readObject(in);
+      this.eventID = (EventID) DataSerializer.readObject(in);
-    public void toData(DataOutput out) throws IOException
-    {
+    public void toData(DataOutput out) throws IOException {
-  
-  public static final class DestroyRegionWithContextMessage
-    extends DestroyRegionMessage
-   {
+
+  public static final class DestroyRegionWithContextMessage extends DestroyRegionMessage {
-    final public RegionEventImpl createRegionEvent(DistributedRegion rgn)
-    {
-      ClientRegionEventImpl event = new ClientRegionEventImpl(rgn,
-          getOperation(), this.callbackArg, true /* originRemote */,
-          getSender(), (ClientProxyMembershipID)this.context);
+    final public RegionEventImpl createRegionEvent(DistributedRegion rgn) {
+      ClientRegionEventImpl event = new ClientRegionEventImpl(rgn, getOperation(), this.callbackArg,
+          true /* originRemote */, getSender(), (ClientProxyMembershipID) this.context);
-    protected void appendFields(StringBuilder buff)
-    {
+    protected void appendFields(StringBuilder buff) {
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException
-    {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    public void toData(DataOutput out) throws IOException
-    {
+    public void toData(DataOutput out) throws IOException {

UPD66 UPD66 UPD66 DEL66
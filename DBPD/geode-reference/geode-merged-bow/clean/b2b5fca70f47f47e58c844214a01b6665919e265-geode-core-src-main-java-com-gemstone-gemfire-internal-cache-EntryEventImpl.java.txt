GEODE-1691: protect EntryEvent off-heap readers

The methods on EntryEvent that can read off-heap
data from the event are now protected from a concurrent
release of the off-heap data.

+import java.util.function.Function;
-          CachedDeserializable cd = (CachedDeserializable)ov;
-          if (doCopyOnRead) {
-            return cd.getDeserializedWritableCopy(this.region, this.re);
-          } else {
-            return cd.getDeserializedValue(this.region, this.re);
-          }
+          return callWithOffHeapLock((CachedDeserializable)ov, oldValueCD -> {
+            if (doCopyOnRead) {
+              return oldValueCD.getDeserializedWritableCopy(this.region, this.re);
+            } else {
+              return oldValueCD.getDeserializedValue(this.region, this.re);
+            }
+          });
-        CachedDeserializable cd = (CachedDeserializable)nv;
-        Object v = null;
-        if (doCopyOnRead) {
-          v = cd.getDeserializedWritableCopy(this.region, this.re);
-        } else {
-          v = cd.getDeserializedValue(this.region, this.re);
-        }
-        assert !(v instanceof CachedDeserializable) : "for key "+this.getKey()+" found nested CachedDeserializable";
-        return v;
+        return callWithOffHeapLock((CachedDeserializable)nv, newValueCD -> {
+          Object v = null;
+          if (doCopyOnRead) {
+            v = newValueCD.getDeserializedWritableCopy(this.region, this.re);
+          } else {
+            v = newValueCD.getDeserializedValue(this.region, this.re);
+          }
+          assert !(v instanceof CachedDeserializable) : "for key "+this.getKey()+" found nested CachedDeserializable";
+          return v;
+        });
+  
+  /**
+   * Invoke the given function with a lock if the given value is offheap.
+   * @return the value returned from invoking the function
+   */
+  private <T,R> R callWithOffHeapLock(T value, Function<T, R> function) {
+    if (isOffHeapReference(value)) {
+      synchronized (this.offHeapLock) {
+        if (!this.offHeapOk) {
+          throw new IllegalStateException("Attempt to access off heap value after the EntryEvent was released.");
+        }
+        return function.apply(value);
+      }
+    } else {
+      return function.apply(value);
+    }
+  }
+  
+  private final Object offHeapLock = new Object();
-      ArrayUtils.objectStringNonRecursive(basicGetOldValue(), buf);
+      synchronized (this.offHeapLock) {
+        ArrayUtils.objectStringNonRecursive(basicGetOldValue(), buf);
+      }
-      ArrayUtils.objectStringNonRecursive(basicGetNewValue(), buf);
+      synchronized (this.offHeapLock) {
+        ArrayUtils.objectStringNonRecursive(basicGetNewValue(), buf);
+      }
+    @Override
-      return getCd().getSerializedValue();
+      return callWithOffHeapLock(cd -> {
+        return cd.getSerializedValue();
+      });
+    /**
+     * The only methods that need to use this method are those on the external SerializedCacheValue interface
+     * and any other method that a customer could call that may access the off-heap values.
+     * For example if toString was implemented on this class to access the value then it would
+     * need to use this method.
+     */
+    private <R> R callWithOffHeapLock(Function<CachedDeserializable, R> function) {
+      if (this.event != null) {
+        // this call does not use getCd() to access this.cd
+        // because the check for offHeapOk is done by event.callWithOffHeapLock
+        return this.event.callWithOffHeapLock(this.cd, function);
+      } else {
+        return function.apply(getCd());
+      }
+    }
+    @Override
-      return OffHeapHelper.getHeapForm(getCd().getDeserializedForReading());
+      return getCd().getDeserializedForReading();
-      return OffHeapHelper.getHeapForm(getCd().getDeserializedWritableCopy(rgn, entry));
+      return getCd().getDeserializedWritableCopy(rgn, entry);
-      return OffHeapHelper.getHeapForm(getCd().getDeserializedValue(rgn, reentry));
+      return callWithOffHeapLock(cd -> {
+        return cd.getDeserializedValue(rgn, reentry);
+      });
-  private transient boolean offHeapOk = true;
+  transient boolean offHeapOk = true;
-    // Note that this method does not set the old/new values to null but
-    // leaves them set to the off-heap value so that future calls to getOld/NewValue
-    // will fail with an exception.
-    Object ov = basicGetOldValue();
-    Object nv = basicGetNewValue();
-    this.offHeapOk = false;
-    
-    if (ov instanceof StoredObject) {
-      //this.region.getCache().getLogger().info("DEBUG freeing ref to old value on " + System.identityHashCode(ov));
-      if (ReferenceCountHelper.trackReferenceCounts()) {
-        ReferenceCountHelper.setReferenceCountOwner(new OldValueOwner());
-        ((StoredObject) ov).release();
-        ReferenceCountHelper.setReferenceCountOwner(null);
-      } else {
-        ((StoredObject) ov).release();
+    synchronized (this.offHeapLock) {
+      // Note that this method does not set the old/new values to null but
+      // leaves them set to the off-heap value so that future calls to getOld/NewValue
+      // will fail with an exception.
+      testHookReleaseInProgress();
+      Object ov = basicGetOldValue();
+      Object nv = basicGetNewValue();
+      this.offHeapOk = false;
+
+      if (ov instanceof StoredObject) {
+        //this.region.getCache().getLogger().info("DEBUG freeing ref to old value on " + System.identityHashCode(ov));
+        if (ReferenceCountHelper.trackReferenceCounts()) {
+          ReferenceCountHelper.setReferenceCountOwner(new OldValueOwner());
+          ((StoredObject) ov).release();
+          ReferenceCountHelper.setReferenceCountOwner(null);
+        } else {
+          ((StoredObject) ov).release();
+        }
+      OffHeapHelper.releaseAndTrackOwner(nv, this);
-    OffHeapHelper.releaseAndTrackOwner(nv, this);
+  }
+  
+  void testHookReleaseInProgress() {
+    // unit test can mock or override this method
-    this.offHeapOk = false;
+    synchronized (this.offHeapLock) {
+      this.offHeapOk = false;
+    }
-    Object ov = basicGetOldValue();
-    if (isOffHeapReference(ov)) {
-      if (ReferenceCountHelper.trackReferenceCounts()) {
-        ReferenceCountHelper.setReferenceCountOwner(new OldValueOwner());
-        this.oldValue = OffHeapHelper.copyAndReleaseIfNeeded(ov);
-        ReferenceCountHelper.setReferenceCountOwner(null);
-      } else {
-        this.oldValue = OffHeapHelper.copyAndReleaseIfNeeded(ov);
+    synchronized (this.offHeapLock) {
+      Object ov = basicGetOldValue();
+      if (isOffHeapReference(ov)) {
+        if (ReferenceCountHelper.trackReferenceCounts()) {
+          ReferenceCountHelper.setReferenceCountOwner(new OldValueOwner());
+          this.oldValue = OffHeapHelper.copyAndReleaseIfNeeded(ov);
+          ReferenceCountHelper.setReferenceCountOwner(null);
+        } else {
+          this.oldValue = OffHeapHelper.copyAndReleaseIfNeeded(ov);
+        }
+      Object nv = basicGetNewValue();
+      if (isOffHeapReference(nv)) {
+        ReferenceCountHelper.setReferenceCountOwner(this);
+        this.newValue = OffHeapHelper.copyAndReleaseIfNeeded(nv);
+        ReferenceCountHelper.setReferenceCountOwner(null);
+      }
+      if (isOffHeapReference(this.newValue) || isOffHeapReference(this.oldValue)) {
+        throw new IllegalStateException("event's old/new value still off-heap after calling copyOffHeapToHeap");
+      }
+      this.offHeapOk = false;
-    Object nv = basicGetNewValue();
-    if (isOffHeapReference(nv)) {
-      ReferenceCountHelper.setReferenceCountOwner(this);
-      this.newValue = OffHeapHelper.copyAndReleaseIfNeeded(nv);
-      ReferenceCountHelper.setReferenceCountOwner(null);
-    }
-    if (isOffHeapReference(this.newValue) || isOffHeapReference(this.oldValue)) {
-      throw new IllegalStateException("event's old/new value still off-heap after calling copyOffHeapToHeap");
-    }
-    this.offHeapOk = false;

INS26 INS40 INS31 INS23 INS31 INS29 INS83 INS73 INS73 INS43 INS42 INS44 INS44 INS8 INS83 INS83 INS43 INS59 INS31 INS39 INS42 INS8 INS8 INS65 INS65 INS42 INS42 INS42 INS43 INS42 INS74 INS42 INS25 INS42 INS42 INS14 INS78 INS29 INS83 INS73 INS43 INS42 INS44 INS8 INS78 INS51 INS51 INS51 INS66 INS66 INS42 INS43 INS43 INS43 INS32 INS8 INS8 INS43 INS8 INS8 INS42 INS41 INS65 INS42 INS42 INS74 INS42 INS25 INS42 INS22 INS8 INS22 INS8 INS22 MOV8 INS42 INS42 INS42 INS42 INS42 INS51 INS41 INS42 INS51 INS51 INS32 INS66 INS66 INS66 INS66 INS43 MOV43 INS43 INS27 INS8 INS8 MOV32 MOV32 INS52 INS42 INS21 MOV60 MOV60 MOV21 MOV25 MOV21 INS52 INS42 MOV21 INS52 INS42 INS8 INS22 INS8 INS32 INS22 MOV8 INS22 MOV8 INS42 INS86 INS42 INS42 INS22 INS33 INS41 INS41 UPD42 INS86 INS32 INS41 INS52 INS42 INS25 INS41 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS59 INS8 INS52 INS42 INS32 INS32 INS59 INS8 INS42 INS8 INS32 INS38 INS8 INS32 INS42 MOV41 INS22 INS42 INS22 INS42 INS42 INS42 MOV32 INS42 INS41 INS41 INS42 MOV11 INS86 INS22 INS53 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS32 INS32 INS59 MOV8 INS52 INS42 INS14 UPD42 MOV42 INS42 MOV42 MOV42 MOV42 INS42 MOV11 INS86 INS42 INS43 INS45 INS59 MOV8 INS42 INS42 UPD42 UPD42 UPD42 UPD42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL59 DEL60 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL83
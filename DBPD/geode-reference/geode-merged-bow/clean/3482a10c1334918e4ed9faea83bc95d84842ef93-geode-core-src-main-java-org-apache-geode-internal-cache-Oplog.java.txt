GEODE-5390: Move inner classes to end of Oplog

-  public enum OPLOG_TYPE {
-    CRF(new byte[] {0x47, 0x46, 0x43, 0x52, 0x46, 0x31}), // GFCRF1
-    DRF(new byte[] {0x47, 0x46, 0x44, 0x52, 0x46, 0x31}), // GFDRF1
-    IRF(new byte[] {0x47, 0x46, 0x49, 0x52, 0x46, 0x31}), // GFIRF1
-    KRF(new byte[] {0x47, 0x46, 0x4b, 0x52, 0x46, 0x31}), // GFKRF1
-    IF(new byte[] {0x47, 0x46, 0x49, 0x46, 0x30, 0x31}); // GFIF01
-
-    private final byte[] bytes;
-
-    OPLOG_TYPE(byte[] byteSeq) {
-      this.bytes = byteSeq;
-    }
-
-    public byte[] getBytes() {
-      return bytes;
-    }
-
-    public static int getLen() {
-      return 6;
-    }
-  }
-
-  /**
-   * Used when creating a KRF to keep track of what DiskRegionView a DiskEntry belongs to.
-   */
-  private static class KRFEntry {
-    private final DiskEntry de;
-    private final DiskRegionView drv;
-    /**
-     * Fix for 42733 - a stable snapshot of the offset so we can sort It doesn't matter that this is
-     * stale, we'll filter out these entries later.
-     */
-    private final long offsetInOplog;
-    private VersionHolder versionTag;
-
-    public KRFEntry(DiskRegionView drv, DiskEntry de, VersionHolder tag) {
-      this.de = de;
-      this.drv = drv;
-      DiskId diskId = de.getDiskId();
-      this.offsetInOplog = diskId != null ? diskId.getOffsetInOplog() : 0;
-      this.versionTag = tag;
-    }
-
-    public DiskEntry getDiskEntry() {
-      return this.de;
-    }
-
-    public DiskRegionView getDiskRegionView() {
-      return this.drv;
-    }
-
-    public long getOffsetInOplogForSorting() {
-      return offsetInOplog;
-    }
-  }
-
-  private static class OplogFile {
-    public File f;
-    public UninterruptibleRandomAccessFile raf;
-    public volatile boolean RAFClosed = true;
-    public UninterruptibleFileChannel channel;
-    public ByteBuffer writeBuf;
-    public long currSize;
-    public long bytesFlushed;
-    public boolean unpreblown;
-  }
-
-  private static class KRFile {
-    public File f;
-    FileOutputStream fos;
-    BufferedOutputStream bos;
-    DataOutputStream dos;
-    long lastOffset = 0;
-    int keyNum = 0;
-  }
-
+  public void finishKrf() {
+    createKrf(false);
+  }
+
+  void prepareForClose() {
+    try {
+      finishKrf();
+    } catch (CancelException e) {
+      // workaround for 50465
+      if (logger.isDebugEnabled()) {
+        logger.debug("Got a cancel exception while creating a krf during shutown", e);
+      }
+    }
+  }
+
+  private Object deserializeKey(byte[] keyBytes, final Version version,
+      final ByteArrayDataInput in) {
+    if (!getParent().isOffline() || !PdxWriterImpl.isPdx(keyBytes)) {
+      return EntryEventImpl.deserialize(keyBytes, version, in);
+    } else {
+      return new RawByteKey(keyBytes);
+    }
+  }
+
+  /**
+   * If this OpLog is from an older version of the product, then return that {@link Version} else
+   * return null.
+   */
+  public Version getProductVersionIfOld() {
+    final Version version = this.gfversion;
+    if (version == null) {
+      // check for the case of diskstore upgrade from 6.6 to >= 7.0
+      if (getParent().isUpgradeVersionOnly()) {
+        // assume previous release version
+        return Version.GFE_66;
+      } else {
+        return null;
+      }
+    } else if (version == Version.CURRENT) {
+      return null;
+    } else {
+      // version changed so return that for VersionedDataStream
+      return version;
+    }
+  }
+
+  /**
+   * If this OpLog has data that was written by an older version of the product, then return that
+   * {@link Version} else return null.
+   */
+  public Version getDataVersionIfOld() {
+    final Version version = this.dataVersion;
+    if (version == null) {
+      // check for the case of diskstore upgrade from 6.6 to >= 7.0
+      if (getParent().isUpgradeVersionOnly()) {
+        // assume previous release version
+        return Version.GFE_66;
+      } else {
+        return null;
+      }
+    } else if (version == Version.CURRENT) {
+      return null;
+    } else {
+      // version changed so return that for VersionedDataStream
+      return version;
+    }
+  }
+
+  public enum OPLOG_TYPE {
+    CRF(new byte[] {0x47, 0x46, 0x43, 0x52, 0x46, 0x31}), // GFCRF1
+    DRF(new byte[] {0x47, 0x46, 0x44, 0x52, 0x46, 0x31}), // GFDRF1
+    IRF(new byte[] {0x47, 0x46, 0x49, 0x52, 0x46, 0x31}), // GFIRF1
+    KRF(new byte[] {0x47, 0x46, 0x4b, 0x52, 0x46, 0x31}), // GFKRF1
+    IF(new byte[] {0x47, 0x46, 0x49, 0x46, 0x30, 0x31}); // GFIF01
+
+    private final byte[] bytes;
+
+    OPLOG_TYPE(byte[] byteSeq) {
+      this.bytes = byteSeq;
+    }
+
+    public byte[] getBytes() {
+      return bytes;
+    }
+
+    public static int getLen() {
+      return 6;
+    }
+  }
+
+  /**
+   * Enumeration of the possible results of the okToSkipModifyRecord
+   */
+  private enum OkToSkipResult {
+    SKIP_RECORD, // Skip reading the key and value
+    SKIP_VALUE, // skip reading just the value
+    DONT_SKIP; // don't skip the record
+
+    public boolean skip() {
+      return this != DONT_SKIP;
+    }
+
+    public boolean skipKey() {
+      return this == SKIP_RECORD;
+    }
+
+  }
+
+  /**
+   * Used when creating a KRF to keep track of what DiskRegionView a DiskEntry belongs to.
+   */
+  private static class KRFEntry {
+    private final DiskEntry de;
+    private final DiskRegionView drv;
+    /**
+     * Fix for 42733 - a stable snapshot of the offset so we can sort It doesn't matter that this is
+     * stale, we'll filter out these entries later.
+     */
+    private final long offsetInOplog;
+    private VersionHolder versionTag;
+
+    public KRFEntry(DiskRegionView drv, DiskEntry de, VersionHolder tag) {
+      this.de = de;
+      this.drv = drv;
+      DiskId diskId = de.getDiskId();
+      this.offsetInOplog = diskId != null ? diskId.getOffsetInOplog() : 0;
+      this.versionTag = tag;
+    }
+
+    public DiskEntry getDiskEntry() {
+      return this.de;
+    }
+
+    public DiskRegionView getDiskRegionView() {
+      return this.drv;
+    }
+
+    public long getOffsetInOplogForSorting() {
+      return offsetInOplog;
+    }
+  }
+
+  private static class OplogFile {
+    public File f;
+    public UninterruptibleRandomAccessFile raf;
+    public volatile boolean RAFClosed = true;
+    public UninterruptibleFileChannel channel;
+    public ByteBuffer writeBuf;
+    public long currSize;
+    public long bytesFlushed;
+    public boolean unpreblown;
+  }
+
+  private static class KRFile {
+    public File f;
+    FileOutputStream fos;
+    BufferedOutputStream bos;
+    DataOutputStream dos;
+    long lastOffset = 0;
+    int keyNum = 0;
+  }
+
-  public interface DiskRegionInfo {
+  private interface DiskRegionInfo {
-  public abstract static class AbstractDiskRegionInfo implements DiskRegionInfo {
+  private abstract static class AbstractDiskRegionInfo implements DiskRegionInfo {
-  public static class DiskRegionInfoNoList extends AbstractDiskRegionInfo {
+  private static class DiskRegionInfoNoList extends AbstractDiskRegionInfo {
-  public static class DiskRegionInfoWithList extends AbstractDiskRegionInfo {
+  private static class DiskRegionInfoWithList extends AbstractDiskRegionInfo {
-    public class Iterator {
+    class Iterator {
-  public void finishKrf() {
-    createKrf(false);
-  }
-
-  void prepareForClose() {
-    try {
-      finishKrf();
-    } catch (CancelException e) {
-      // workaround for 50465
-      if (logger.isDebugEnabled()) {
-        logger.debug("Got a cancel exception while creating a krf during shutown", e);
-      }
-    }
-  }
-
-  private Object deserializeKey(byte[] keyBytes, final Version version,
-      final ByteArrayDataInput in) {
-    if (!getParent().isOffline() || !PdxWriterImpl.isPdx(keyBytes)) {
-      return EntryEventImpl.deserialize(keyBytes, version, in);
-    } else {
-      return new RawByteKey(keyBytes);
-    }
-  }
-
-  /**
-   * If this OpLog is from an older version of the product, then return that {@link Version} else
-   * return null.
-   */
-  public Version getProductVersionIfOld() {
-    final Version version = this.gfversion;
-    if (version == null) {
-      // check for the case of diskstore upgrade from 6.6 to >= 7.0
-      if (getParent().isUpgradeVersionOnly()) {
-        // assume previous release version
-        return Version.GFE_66;
-      } else {
-        return null;
-      }
-    } else if (version == Version.CURRENT) {
-      return null;
-    } else {
-      // version changed so return that for VersionedDataStream
-      return version;
-    }
-  }
-
-  /**
-   * If this OpLog has data that was written by an older version of the product, then return that
-   * {@link Version} else return null.
-   */
-  public Version getDataVersionIfOld() {
-    final Version version = this.dataVersion;
-    if (version == null) {
-      // check for the case of diskstore upgrade from 6.6 to >= 7.0
-      if (getParent().isUpgradeVersionOnly()) {
-        // assume previous release version
-        return Version.GFE_66;
-      } else {
-        return null;
-      }
-    } else if (version == Version.CURRENT) {
-      return null;
-    } else {
-      // version changed so return that for VersionedDataStream
-      return version;
-    }
-  }
-
-  /**
-   * Enumeration of operation log file types.
-   *
-   */
-  enum OplogFileType {
-    OPLOG_CRF, // Creates and updates
-    OPLOG_DRF, // Deletes
-    OPLOG_KRF // Keys
-  }
-
-  /**
-   * Enumeration of the possible results of the okToSkipModifyRecord
-   *
-   *
-   */
-  private static enum OkToSkipResult {
-    SKIP_RECORD, // Skip reading the key and value
-    SKIP_VALUE, // skip reading just the value
-    DONT_SKIP; // don't skip the record
-
-    public boolean skip() {
-      return this != DONT_SKIP;
-    }
-
-    public boolean skipKey() {
-      return this == SKIP_RECORD;
-    }
-
-  }
-

MOV71 MOV55 MOV55 MOV55 MOV31 MOV31 MOV31 MOV31 MOV31 MOV71 UPD83 UPD83 UPD83 UPD83 DEL83 DEL83 DEL66 DEL65 DEL29 DEL42 DEL42 DEL72 DEL42 DEL72 DEL42 DEL72 DEL71
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A request from an accessor to a datastore telling 
- * it to direct the creation of a bucket. This request is somewhat 
- * of a hack. With 6.0, we no longer recover redundancy when a
- * member crashes. However, if the member directing the creation
- * of a bucket crashes, that will leave us with low redundancy. We 
- * decided it was not good behavior to leave the system with impaired
- * redundancy if an accessor crashes. Hence, by forcing a datastore 
- * to direct the creation of the bucket, at least we will expect
- * the redundancy to be impaired if that datastore crashes (even if it
- * never hosted that bucket). 
+ * A request from an accessor to a datastore telling it to direct the creation of a bucket. This
+ * request is somewhat of a hack. With 6.0, we no longer recover redundancy when a member crashes.
+ * However, if the member directing the creation of a bucket crashes, that will leave us with low
+ * redundancy. We decided it was not good behavior to leave the system with impaired redundancy if
+ * an accessor crashes. Hence, by forcing a datastore to direct the creation of the bucket, at least
+ * we will expect the redundancy to be impaired if that datastore crashes (even if it never hosted
+ * that bucket).
-  
-  /** The key associated with the value that must be sent */ 
+
+  /** The key associated with the value that must be sent */
-  /** The value associated with the key that must be sent */ 
+  /** The value associated with the key that must be sent */
-  
+
+
-  
-  @Override  
+
+  @Override
-   * @param recipient the member to which the bucket manage request is sent 
-   * @param r  the PartitionedRegion to which the bucket belongs
+   * 
+   * @param recipient the member to which the bucket manage request is sent
+   * @param r the PartitionedRegion to which the bucket belongs
-  public static NodeResponse send(InternalDistributedMember recipient, 
-      PartitionedRegion r, int bucketId, int bucketSize) 
-      throws ForceReattemptException
-  {
+  public static NodeResponse send(InternalDistributedMember recipient, PartitionedRegion r,
+      int bucketId, int bucketSize) throws ForceReattemptException {
-    CreateBucketMessage m = new CreateBucketMessage(recipient, r.getPRId(), p, bucketId, bucketSize);
+    CreateBucketMessage m =
+        new CreateBucketMessage(recipient, r.getPRId(), p, bucketId, bucketSize);
-  
+
-   * This method is called upon receipt and make the desired changes to the
-   * PartitionedRegion
-   * Note: It is very important that this message does NOT cause any deadlocks as the sender will wait indefinitely for the acknowledgement
+   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:
+   * It is very important that this message does NOT cause any deadlocks as the sender will wait
+   * indefinitely for the acknowledgement
-  @Override  
-  protected boolean operateOnPartitionedRegion(DistributionManager dm, 
-      PartitionedRegion r, long startTime) {
+  @Override
+  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion r,
+      long startTime) {
-   
-    // This is to ensure that initialization is complete before bucket creation request is 
+
+    // This is to ensure that initialization is complete before bucket creation request is
-    if (! r.isInitialized()) {
+    if (!r.isInitialized()) {
-    
+
-      FixedPartitionAttributesImpl fpa = PartitionedRegionHelper
-          .getFixedPartitionAttributesForBucket(r, bucketId);
+      FixedPartitionAttributesImpl fpa =
+          PartitionedRegionHelper.getFixedPartitionAttributesForBucket(r, bucketId);
-    r.checkReadiness(); 
-    InternalDistributedMember primary = r.getRedundancyProvider().createBucketAtomically(bucketId, bucketSize,
-        startTime, false, partitionName);
-    r.getPrStats().endPartitionMessagesProcessing(startTime); 
-    CreateBucketReplyMessage.sendResponse(getSender(), getProcessorId(), dm, primary);      
+    r.checkReadiness();
+    InternalDistributedMember primary = r.getRedundancyProvider().createBucketAtomically(bucketId,
+        bucketSize, startTime, false, partitionName);
+    r.getPrStats().endPartitionMessagesProcessing(startTime);
+    CreateBucketReplyMessage.sendResponse(getSender(), getProcessorId(), dm, primary);
-  
+
-  @Override  
-  public void fromData(DataInput in) throws IOException,
-      ClassNotFoundException
-  {
+  @Override
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-  @Override  
-  public void toData(DataOutput out) throws IOException
-  {
+  @Override
+  public void toData(DataOutput out) throws IOException {
-  
+
-  protected void appendFields(StringBuffer buff)
-  {
+  protected void appendFields(StringBuffer buff) {
-    buff.append("; bucketId=").append(this.bucketId)
-        .append("; bucketSize=").append(this.bucketSize);
+    buff.append("; bucketId=").append(this.bucketId).append("; bucketSize=")
+        .append(this.bucketSize);
-  
-  @Override  
+
+  @Override
-   * A class that contains the reply to a {@link CreateBucketMessage} message
-   * which contains the {@link Node} that has accepted to manage the bucket. 
+   * A class that contains the reply to a {@link CreateBucketMessage} message which contains the
+   * {@link Node} that has accepted to manage the bucket.
+   * 
-    
+
-     * Empty constructor to conform to DataSerializable interface 
+     * Empty constructor to conform to DataSerializable interface
-    public CreateBucketReplyMessage() {
-    }
+    public CreateBucketReplyMessage() {}
-    private CreateBucketReplyMessage(int processorId, InternalDistributedMember primary)
-    {
+    private CreateBucketReplyMessage(int processorId, InternalDistributedMember primary) {
-      this.primary  = primary;
+      this.primary = primary;
-    
+
+     * 
-    public static void sendResponse(InternalDistributedMember recipient, int processorId, 
-        DM dm, InternalDistributedMember primary) 
-    {
+    public static void sendResponse(InternalDistributedMember recipient, int processorId, DM dm,
+        InternalDistributedMember primary) {
-}
+    }
-     * Processes this message.  This method is invoked by the receiver
-     * of the message.
+     * Processes this message. This method is invoked by the receiver of the message.
+     * 
-    @Override  
+    @Override
-        logger.trace(LogMarker.DM, "CreateBucketReplyMessage process invoking reply processor with processorId:" + this.processorId);
+        logger.trace(LogMarker.DM,
+            "CreateBucketReplyMessage process invoking reply processor with processorId:"
+                + this.processorId);
-      dm.getStats().incReplyMessageTime(DistributionStats.getStatTime()-startTime);
+      dm.getStats().incReplyMessageTime(DistributionStats.getStatTime() - startTime);
-    
-    @Override  
+
+    @Override
-      if(primary != null) {
+      if (primary != null) {
-    @Override  
-  public int getDSFID() {
-    return PR_CREATE_BUCKET_REPLY_MESSAGE;
-  }
+    @Override
+    public int getDSFID() {
+      return PR_CREATE_BUCKET_REPLY_MESSAGE;
+    }
-    @Override  
-    public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
+    @Override
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      if(hasPrimary) {
+      if (hasPrimary) {
-    @Override  
+    @Override
-      return new StringBuffer()
-      .append("CreateBucketReplyMessage ")
-      .append("processorid=").append(this.processorId)
-      .toString();
+      return new StringBuffer().append("CreateBucketReplyMessage ").append("processorid=")
+          .append(this.processorId).toString();
-  
+
+   * 
-     * the message that triggers return from waitForAcceptance.  This will
-     * be null if the target member exited
+     * the message that triggers return from waitForAcceptance. This will be null if the target
+     * member exited
-    @Override  
-    public void process(DistributionMessage msg)
-    {
+    @Override
+    public void process(DistributionMessage msg) {
-          CreateBucketReplyMessage reply =(CreateBucketReplyMessage) msg;
+          CreateBucketReplyMessage reply = (CreateBucketReplyMessage) msg;
-    
-    
+
+
-     * Wait for the response to a {@link CreateBucketMessage} request. 
+     * Wait for the response to a {@link CreateBucketMessage} request.
+     * 
-    public InternalDistributedMember waitForResponse()  throws ForceReattemptException
-    {
+    public InternalDistributedMember waitForResponse() throws ForceReattemptException {
-      }
-      catch (ReplyException e) {
+      } catch (ReplyException e) {
-          logger.debug("NodeResponse got remote cancellation, throwing PartitionedRegionCommunication Exception {}", t.getMessage(), t);
+          logger.debug(
+              "NodeResponse got remote cancellation, throwing PartitionedRegionCommunication Exception {}",
+              t.getMessage(), t);
-          logger.debug("NodeResponse got local destroy on the PartitionRegion , throwing ForceReattemptException {}", t.getMessage(), t);
+          logger.debug(
+              "NodeResponse got local destroy on the PartitionRegion , throwing ForceReattemptException {}",
+              t.getMessage(), t);
-          logger.debug("NodeResponse got ForceReattemptException due to local destroy on the PartitionRegion {}", t.getMessage(), t);
+          logger.debug(
+              "NodeResponse got ForceReattemptException due to local destroy on the PartitionRegion {}",
+              t.getMessage(), t);
-        if(t instanceof PartitionedRegionStorageException) {
+        if (t instanceof PartitionedRegionStorageException) {
-      if(message == null) {
+      if (message == null) {

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66
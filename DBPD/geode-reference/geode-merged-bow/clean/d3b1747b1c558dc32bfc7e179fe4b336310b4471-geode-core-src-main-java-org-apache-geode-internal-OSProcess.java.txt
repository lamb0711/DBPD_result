GEODE-6846: Remove PureJavaMode class (#3732)

Rename SharedLibrary as JvmSizeUtils. Remove unused code.
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import org.apache.geode.SystemFailure;
-import org.apache.geode.internal.logging.LoggingThread;
-  static final boolean pureMode = PureJavaMode.isPure();
-
-  static {
-    if (!pureMode) {
-      registerSigQuitHandler();
-    }
-  }
-
-    if (pureMode || (env != null && env.size() > 0)) {
-      StringBuffer sb = new StringBuffer();
-      Vector cmdVec = new Vector();
-      // Add shell code to spawn a process silently
-      if (isWindows) {
-        cmdVec.add("cmd.exe");
-        cmdVec.add("/c");
-        sb.append("start /b \"\" ");
-      } else {
-        // to address issue with users that don't have bash shell installed
-        if (commandShell.equals("bash")) {
-          cmdVec.add("bash");
-          cmdVec.add("--norc");
-          cmdVec.add("-c");
-        } else {
-          cmdVec.add(commandShell);
-        }
-      }
-      // Add the actual command
-      for (int i = 0; i < cmdarray.length; i++) {
-        if (i != 0)
-          sb.append(" ");
-        if (cmdarray[i].length() != 0 && cmdarray[i].charAt(0) == '\"') {
-          // The token has already been quoted, see bug 40835
-          sb.append(cmdarray[i]);
-        } else {
-          sb.append("\"");
-          sb.append(cmdarray[i]);
-          sb.append("\"");
-        }
-      }
-      // Add the IO redirction code, this prevents hangs and IO blocking
-      sb.append(" >> ");
-      sb.append(logfile.getPath());
-      sb.append(" 2>&1");
-      if (isWindows) {
-        sb.append(" <NUL");
-      } else {
-        sb.append(" </dev/null &");
-      }
-      cmdVec.add(sb.toString());
-      String[] cmdStrings = (String[]) cmdVec.toArray(new String[0]);
-      if (trace != null && trace.length() > 0) {
-        for (int i = 0; i < cmdStrings.length; i++) {
-          System.out.println("cmdStrings[" + i + "] = " + cmdStrings[i]);
-        }
-        System.out.println("workdir=" + workdir.getPath());
-        System.out.println("logfile=" + logfile.getPath());
-      }
-      final ProcessBuilder procBuilder = new ProcessBuilder(cmdStrings);
-      if (env != null && env.size() > 0) {
-        // adjust the environment variables inheriting from parent
-        procBuilder.environment().putAll(env);
-      }
-      procBuilder.directory(workdir);
-      final Process process = procBuilder.start();
-      try {
-        process.getInputStream().close();
-      } catch (IOException ignore) {
-      }
-      try {
-        process.getOutputStream().close();
-      } catch (IOException ignore) {
-      }
-      try {
-        process.getErrorStream().close();
-      } catch (IOException ignore) {
-      }
-      try {
-        // short count = 1000;
-        boolean processIsStillRunning = true;
-        while (processIsStillRunning) {
-          Thread.sleep(10);
-          try {
-            process.exitValue();
-            processIsStillRunning = false;
-          } catch (IllegalThreadStateException itse) {
-            // Ignore this, we are polling the exitStatus
-            // instead of using the blocking Process#waitFor()
-          }
-        }
-      } catch (InterruptedException ie) {
-        Thread.currentThread().interrupt();
-      }
+    StringBuffer sb = new StringBuffer();
+    Vector cmdVec = new Vector();
+    // Add shell code to spawn a process silently
+    if (isWindows) {
+      cmdVec.add("cmd.exe");
+      cmdVec.add("/c");
+      sb.append("start /b \"\" ");
-      result = bgexecInternal(cmdarray, workdir.getPath(), logfile.getPath(), inheritLogfile);
-      if (result != -1) {
-        if (pids != null) {
-          pids.add(Integer.valueOf(result));
-          if (trace != null && trace.length() > 0) {
-            System.out.println("bgexec child pid is: " + result);
-          }
-        }
+      // to address issue with users that don't have bash shell installed
+      if (commandShell.equals("bash")) {
+        cmdVec.add("bash");
+        cmdVec.add("--norc");
+        cmdVec.add("-c");
+      } else {
+        cmdVec.add(commandShell);
+    // Add the actual command
+    for (int i = 0; i < cmdarray.length; i++) {
+      if (i != 0)
+        sb.append(" ");
+      if (cmdarray[i].length() != 0 && cmdarray[i].charAt(0) == '\"') {
+        // The token has already been quoted, see bug 40835
+        sb.append(cmdarray[i]);
+      } else {
+        sb.append("\"");
+        sb.append(cmdarray[i]);
+        sb.append("\"");
+      }
+    }
+    // Add the IO redirction code, this prevents hangs and IO blocking
+    sb.append(" >> ");
+    sb.append(logfile.getPath());
+    sb.append(" 2>&1");
+    if (isWindows) {
+      sb.append(" <NUL");
+    } else {
+      sb.append(" </dev/null &");
+    }
+    cmdVec.add(sb.toString());
+
+    String[] cmdStrings = (String[]) cmdVec.toArray(new String[0]);
+    if (trace != null && trace.length() > 0) {
+      for (int i = 0; i < cmdStrings.length; i++) {
+        System.out.println("cmdStrings[" + i + "] = " + cmdStrings[i]);
+      }
+      System.out.println("workdir=" + workdir.getPath());
+      System.out.println("logfile=" + logfile.getPath());
+    }
+    final ProcessBuilder procBuilder = new ProcessBuilder(cmdStrings);
+    if (env != null && env.size() > 0) {
+      // adjust the environment variables inheriting from parent
+      procBuilder.environment().putAll(env);
+    }
+    procBuilder.directory(workdir);
+    final Process process = procBuilder.start();
+    try {
+      process.getInputStream().close();
+    } catch (IOException ignore) {
+    }
+    try {
+      process.getOutputStream().close();
+    } catch (IOException ignore) {
+    }
+    try {
+      process.getErrorStream().close();
+    } catch (IOException ignore) {
+    }
+    try {
+      // short count = 1000;
+      boolean processIsStillRunning = true;
+      while (processIsStillRunning) {
+        Thread.sleep(10);
+        try {
+          process.exitValue();
+          processIsStillRunning = false;
+        } catch (IllegalThreadStateException itse) {
+          // Ignore this, we are polling the exitStatus
+          // instead of using the blocking Process#waitFor()
+        }
+      }
+    } catch (InterruptedException ie) {
+      Thread.currentThread().interrupt();
+    }
+
-    if (pureMode) {
-      throw new RuntimeException(
-          "shutdown not allowed in pure java mode");
-    } else {
-      checkPid(pid);
-      return _shutdown(pid);
-    }
+    throw new RuntimeException(
+        "shutdown not allowed in pure java mode");
-    if (pureMode) {
-      throw new RuntimeException(
-          "kill not allowed in pure java mode");
-    } else {
-      checkPid(pid);
-      return _kill(pid);
-    }
+    throw new RuntimeException(
+        "kill not allowed in pure java mode");
-    if (pureMode || !useNative) {
+    if (!useNative) {
-    if (pureMode) {
-      throw new RuntimeException(
-          "exists not allowed in pure java mode");
-    }
-    checkPid(pid);
-
-    if (reapPid(pid)) {
-      try {
-        pids.remove(Integer.valueOf(pid));
-      } catch (Exception ignore) {
-      }
-      String trace = System.getProperty("org.apache.geode.internal.OSProcess.trace");
-      if (trace != null && trace.length() > 0) {
-        System.out.println("reaped pid: " + pid);
-      }
-    }
-    return nativeExists(pid);
+    throw new RuntimeException(
+        "exists not allowed in pure java mode");
-    if (pureMode) {
-      throw new RuntimeException(
-          "waitForPidToExit not allowed in pure java mode");
-    }
-    checkPid(pid);
-    waitForPid(pid);
+    throw new RuntimeException(
+        "waitForPidToExit not allowed in pure java mode");
-    if (pureMode) {
-      throw new RuntimeException(
-          "setCurrentDirectory not allowed in pure java mode");
-    }
-    return jniSetCurDir(curDir.getAbsolutePath());
+    throw new RuntimeException(
+        "setCurrentDirectory not allowed in pure java mode");
-    if (pureMode) {
-      // just initialize the pid cache
-      synchronized (myPid) {
-        int pid = 0;
-        // Windows checks have been disabled as the ManagementFactory hack
-        // to find the PID has been seen to work on Windows 7. Add checks
-        // for more specific versions of Windows if this fails on them
-        // if(! System.getProperty("os.name", "").startsWith("Windows")) {
-        String name = java.lang.management.ManagementFactory.getRuntimeMXBean().getName();
-        int idx = name.indexOf('@');
-        try {
-          pid = Integer.parseInt(name.substring(0, idx));
-        } catch (NumberFormatException nfe) {
-          // something changed in the RuntimeMXBean name
-        }
-        // }
-        myPid[0] = pid;
-        reaperStarted = true;
+    // just initialize the pid cache
+    synchronized (myPid) {
+      int pid = 0;
+      // Windows checks have been disabled as the ManagementFactory hack
+      // to find the PID has been seen to work on Windows 7. Add checks
+      // for more specific versions of Windows if this fails on them
+      // if(! System.getProperty("os.name", "").startsWith("Windows")) {
+      String name = java.lang.management.ManagementFactory.getRuntimeMXBean().getName();
+      int idx = name.indexOf('@');
+      try {
+        pid = Integer.parseInt(name.substring(0, idx));
+      } catch (NumberFormatException nfe) {
+        // something changed in the RuntimeMXBean name
-    } else {
-      if (reapPid(-1)) {
-        pids = Collections.synchronizedSet(new HashSet());
-        reaperThread = new LoggingThread("osprocess reaper", () -> {
-          synchronized (myPid) {
-            myPid[0] = getProcessId();
-            reaperStarted = true;
-          }
-          String trace = System.getProperty("org.apache.geode.internal.OSProcess.trace");
-          int secondsToSleep = (1000 * 60) * 1; // one minute
-          if (trace != null && trace.length() > 0) {
-            secondsToSleep = 1000; // every second
-          }
-          // reap all the pids we have every once in a while
-          while (true) {
-            SystemFailure.checkFailure();
-            try {
-              Iterator it = pids.iterator();
-              while (it.hasNext()) {
-                Object o = it.next();
-                int pid = ((Integer) o).intValue();
-                if (reapPid(pid)) {
-                  try {
-                    it.remove();
-                    if (trace != null && trace.length() > 0) {
-                      System.out.println("reaped pid: " + pid);
-                    }
-                  } catch (Exception e) {
-                    // make sure and remove it since it was
-                    // reaped.
-                    pids.remove(o);
-                    if (trace != null && trace.length() > 0) {
-                      System.out.println("reaped pid: " + pid);
-                    }
-                    throw e;
-                  }
-                }
-              }
-              Thread.sleep(secondsToSleep);
-            } catch (InterruptedException e) {
-              Thread.currentThread().interrupt();
-              break;
-            } catch (Exception e) {
-              // e.printStackTrace(); // DEBUG
-              // ignore
-            }
-          }
-        });
-        reaperThread.start();
-      } else {
-        // platform does not need a reaper thread,
-        // just initialize the pid cache
-        synchronized (myPid) {
-          myPid[0] = getProcessId();
-          reaperStarted = true;
-        }
-      }
+      // }
+      myPid[0] = pid;
+      reaperStarted = true;
-   * Get the vm's process id. On Linux, this returns the processId of the reaper thread. If we are
-   * in {@linkplain PureJavaMode#isPure pure Java mode}, then <code>0</code> is returned.
+   * Get the vm's process id. On Linux, this returns the processId of the reaper thread.
-      if (!pureMode) {
-        redirectCOutput(newOutput.getPath());
-      }

MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV8 MOV60 MOV25 MOV60 MOV60 MOV25 MOV24 MOV60 MOV25 MOV60 MOV25 MOV25 MOV25 MOV25 MOV25 MOV25 MOV60 MOV25 MOV60 MOV41 MOV38 UPD66 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL23 DEL83 DEL42 DEL38 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL28 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL36 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL42 DEL34 DEL38 DEL27 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL40 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL42 DEL27 DEL42 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL42 DEL43 DEL42 DEL42 DEL42 DEL45 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL40 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL25 DEL42 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8 DEL42 DEL42 DEL34 DEL38 DEL32 DEL42 DEL42 DEL42 DEL42 DEL43 DEL14 DEL32 DEL7 DEL21 DEL42 DEL42 DEL43 DEL45 DEL42 DEL42 DEL34 DEL2 DEL42 DEL32 DEL7 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL51 DEL42 DEL43 DEL42 DEL42 DEL42 DEL45 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL34 DEL27 DEL36 DEL34 DEL27 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL42 DEL34 DEL7 DEL21 DEL8 DEL25 DEL9 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL40 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL40 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL53 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL61 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL10 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL61 DEL8 DEL86 DEL14 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL34 DEL2 DEL42 DEL32 DEL7 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL51 DEL8 DEL25 DEL8 DEL25 DEL8 DEL66 DEL42 DEL42 DEL67 DEL66 DEL65 DEL66 DEL42 DEL38 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25
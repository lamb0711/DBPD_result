GEODE-7497: Check CQs prior to change authorizer (#4385)

The QueryConfigurationService now requires an extra flag to determine,
in the presence of continuous queries, whether to update the configured
MethodInvocationAuthorizer and invalidate the CQ's internal cache or
throw an exception and abort the update.

- Fixed minor warnings.
- Added unit and distributed tests.
- Updated docs for alter query-service command.
- Added 'forceUpdate' flag to 'AlterQueryServiceFunction' and
  'AlterQueryServiceCommand'.
- Fixed 'AlterQueryServiceCommand' to always require the
  'method-authorizer' parameter.
-import static org.apache.geode.distributed.internal.DistributionConfig.GEMFIRE_PREFIX;
+import static org.apache.geode.cache.query.internal.QueryConfigurationServiceImpl.ALLOW_UNTRUSTED_METHOD_INVOCATION_SYSTEM_PROPERTY;
-import java.util.HashSet;
+import java.util.Collections;
+import org.apache.commons.lang3.StringUtils;
+
+import org.apache.geode.cache.query.internal.QueryConfigurationService;
-  static final String AUTHORIZER_UPDATED_MESSAGE =
+  private static final long serialVersionUID = 7155576168386556341L;
+  public static final String AUTHORIZER_UPDATED_MESSAGE =
+  public static final String EMPTY_AUTHORIZER_ERROR =
+      "MethodInvocationAuthorizer class name must not be empty.";
-  public static final String DEPRECATED_PROPERTY_ERROR =
-      "Deprecated System Property: \"" + GEMFIRE_PREFIX
-          + "QueryService.allowUntrustedMethodInvocation\" is set to TRUE. In order to use a MethodInvocationAuthorizer, this property must be FALSE or undefined.";
-  private static final long serialVersionUID = 7155576168386556341L;
-
-  @Override
-  @SuppressWarnings("unchecked")
-  public CliFunctionResult executeFunction(FunctionContext<Object[]> context) {
-
-    String authorizerName = (String) context.getArguments()[0];
-    Set<String> parameterSet;
-
-    if (context.getArguments()[1] != null) {
-      parameterSet = (Set<String>) context.getArguments()[1];
-    } else {
-      parameterSet = new HashSet<>();
-    }
-
-    if (authorizerName != null) {
-      if (!isSecurityEnabled()) {
-        return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.ERROR,
-            SECURITY_NOT_ENABLED_MESSAGE);
-      }
-      if (Boolean.parseBoolean(
-          System.getProperty(GEMFIRE_PREFIX + "QueryService.allowUntrustedMethodInvocation"))) {
-        return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.ERROR,
-            DEPRECATED_PROPERTY_ERROR);
-      }
-      try {
-        Cache cache = context.getCache();
-        ((InternalCache) cache)
-            .getService(org.apache.geode.cache.query.internal.QueryConfigurationService.class)
-            .updateMethodAuthorizer(cache, authorizerName, parameterSet);
-      } catch (Exception ex) {
-        return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.ERROR,
-            ex.getMessage());
-      }
-    }
-    String message = AUTHORIZER_UPDATED_MESSAGE + authorizerName + (parameterSet.size() > 0
-        ? AUTHORIZER_PARAMETERS_MESSAGE + String.join(", ", parameterSet) : "");
-    return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.OK,
-        message);
-  }
+  public static final String DEPRECATED_PROPERTY_ERROR = "Deprecated System Property: \""
+      + ALLOW_UNTRUSTED_METHOD_INVOCATION_SYSTEM_PROPERTY
+      + "\" is set to TRUE. In order to use a MethodInvocationAuthorizer, this property must be FALSE or undefined.";
+
+  @Override
+  @SuppressWarnings({"unchecked", "deprecation"})
+  public CliFunctionResult executeFunction(FunctionContext<Object[]> context) {
+    Set<String> parameterSet;
+    boolean forceUpdate = (boolean) context.getArguments()[0];
+    String authorizerName = (String) context.getArguments()[1];
+
+    if (context.getArguments()[2] != null) {
+      parameterSet = (Set<String>) context.getArguments()[2];
+    } else {
+      parameterSet = Collections.emptySet();
+    }
+
+    if (StringUtils.isEmpty(authorizerName)) {
+      return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.ERROR,
+          EMPTY_AUTHORIZER_ERROR);
+    }
+
+    if (!isSecurityEnabled()) {
+      return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.ERROR,
+          SECURITY_NOT_ENABLED_MESSAGE);
+    }
+
+    if (Boolean
+        .parseBoolean(System.getProperty(ALLOW_UNTRUSTED_METHOD_INVOCATION_SYSTEM_PROPERTY))) {
+      return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.ERROR,
+          DEPRECATED_PROPERTY_ERROR);
+    }
+
+    try {
+      Cache cache = context.getCache();
+      ((InternalCache) cache).getService(QueryConfigurationService.class)
+          .updateMethodAuthorizer(cache, forceUpdate, authorizerName, parameterSet);
+    } catch (Exception ex) {
+      return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.ERROR,
+          ex.getMessage());
+    }
+
+    String message = AUTHORIZER_UPDATED_MESSAGE + authorizerName + (parameterSet.size() > 0
+        ? AUTHORIZER_PARAMETERS_MESSAGE + String.join(", ", parameterSet) : "");
+    return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.OK,
+        message);
+  }

INS26 INS26 MOV23 MOV31 UPD40 UPD40 INS40 INS40 INS23 INS83 INS83 INS83 INS83 MOV43 INS59 INS43 MOV8 INS42 INS45 INS42 INS4 MOV60 MOV60 INS60 INS25 INS25 MOV60 MOV41 UPD42 UPD45 INS45 INS45 INS39 MOV43 INS59 INS27 INS8 INS8 INS32 INS8 UPD42 INS42 MOV11 INS2 INS33 INS21 INS21 INS42 INS42 INS42 INS41 INS39 MOV43 INS32 INS34 INS7 INS7 INS14 INS42 INS42 INS42 INS42 INS11 INS42 INS32 INS43 INS32 INS40 INS42 INS42 MOV74 INS2 INS42 INS42 INS42 INS42 INS42 INS32 INS34 UPD43 INS42 INS42 INS42 DEL45 DEL42 DEL45 DEL27 DEL40 DEL42 DEL42 DEL32 DEL34 DEL2 DEL33 DEL27 DEL42 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL25 DEL8
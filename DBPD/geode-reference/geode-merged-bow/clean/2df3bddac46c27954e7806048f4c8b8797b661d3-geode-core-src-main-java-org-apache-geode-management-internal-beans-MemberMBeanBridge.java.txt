GEODE-6387: Clean up MemberMBeanBridge

* General cleanup of IDE warnings in MemberMBeanBridge
* Make some fields final
* Remove unused code
* Move constants to top of class
* Inline some very short methods
* Remove unnecessary uses of this
* Fix typos and improve variable names
* Apply @VisibleForTesting annotation to many methods that are not
  private only because they are invoked from tests
* Declare variables when they are used
* Weaken declared types where possible
* Weaken access scopes where possible
* Remove useless javadocs

Authored-by: Michael Oleske <moleske@pivotal.io>

-import java.lang.management.MemoryUsage;
-import java.lang.management.RuntimeMXBean;
-import java.net.InetAddress;
-import java.util.concurrent.TimeUnit;
-import javax.management.MBeanServer;
-import org.apache.geode.annotations.Immutable;
-import org.apache.geode.internal.cache.LocalRegion;
-import org.apache.geode.internal.statistics.GemFireStatSampler;
-
-  /**
-   * Static reference to the Platform MBean server
-   */
-  @Immutable
-  public static final MBeanServer mbeanServer = ManagementFactory.getPlatformMBeanServer();
-
-  /**
-   * Factor converting bytes to MBØØ
-   */
+  private static final String MEMBER_LEVEL_DISK_MONITOR = "MemberLevelDiskMonitor";
+  private static final String MEMBER_LEVEL_REGION_MONITOR = "MemberLevelRegionMonitor";
-  @Immutable
-  private static final TimeUnit nanoSeconds = TimeUnit.NANOSECONDS;
+  private final OsStatisticsProvider osStatisticsProvider = OsStatisticsProvider.build();
-  private RuntimeMXBean runtimeMXBean;
-  private long lastSystemTime = 0;
-  private long lastProcessCpuTime = 0;
-
-
-  private volatile boolean lockStatsAdded = false;
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-  private GemFireStatSampler sampler;
-
-
-  private static final String MEMBER_LEVEL_DISK_MONITOR = "MemberLevelDiskMonitor";
-  private static final String MEMBER_LEVEL_REGION_MONITOR = "MemberLevelRegionMonitor";
-
-
-
-  private final OsStatisticsProvider osStatisticsProvider = OsStatisticsProvider.build();
+  private volatile boolean lockServicesStatsAdded = false;
-  public MemberMBeanBridge(InternalCache cache, SystemManagementService service) {
+  MemberMBeanBridge(InternalCache cache, SystemManagementService service) {
-    this.system = (InternalDistributedSystem) cache.getDistributedSystem();
-    this.statisticsManager = system.getStatisticsManager();
+    system = (InternalDistributedSystem) cache.getDistributedSystem();
+    statisticsManager = system.getStatisticsManager();
-    this.dm = system.getDistributionManager();
+    dm = system.getDistributionManager();
-      this.redundancyZone = distManager
+      redundancyZone = distManager
-    this.sampler = system.getStatSampler();
-
-    this.config = system.getConfig();
+    config = system.getConfig();
-      this.commandProcessor =
+      commandProcessor =
-    intitGemfireProperties();
+    initGemfireProperties();
-      InetAddress addr = SocketCreator.getLocalHost();
-      this.hostname = addr.getHostName();
+      hostname = SocketCreator.getLocalHost().getHostName();
-      this.hostname = ManagementConstants.DEFAULT_HOST_NAME;
+      hostname = ManagementConstants.DEFAULT_HOST_NAME;
-      this.osObjectName = new ObjectName("java.lang:type=OperatingSystem");
-    } catch (MalformedObjectNameException ex) {
-      if (logger.isDebugEnabled()) {
-        logger.debug(ex.getMessage(), ex);
-      }
-    } catch (NullPointerException ex) {
+      osObjectName = new ObjectName("java.lang:type=OperatingSystem");
+    } catch (MalformedObjectNameException | NullPointerException ex) {
-    this.memoryMXBean = ManagementFactory.getMemoryMXBean();
+    memoryMXBean = ManagementFactory.getMemoryMXBean();
-    this.threadMXBean = ManagementFactory.getThreadMXBean();
+    threadMXBean = ManagementFactory.getThreadMXBean();
-    this.runtimeMXBean = ManagementFactory.getRuntimeMXBean();
-    this.osBean = ManagementFactory.getOperatingSystemMXBean();
+    osBean = ManagementFactory.getOperatingSystemMXBean();
-    this.monitor =
+    monitor =
-    this.diskMonitor = new MemberLevelDiskMonitor(MEMBER_LEVEL_DISK_MONITOR);
-    this.regionMonitor = new AggregateRegionStatsMonitor(MEMBER_LEVEL_REGION_MONITOR);
-    this.gcMonitor = new GCStatsMonitor("GCStatsMonitor");
-    this.vmStatsMonitor =
+    diskMonitor = new MemberLevelDiskMonitor(MEMBER_LEVEL_DISK_MONITOR);
+    regionMonitor = new AggregateRegionStatsMonitor(MEMBER_LEVEL_REGION_MONITOR);
+    gcMonitor = new GCStatsMonitor("GCStatsMonitor");
+    vmStatsMonitor =
-    this.systemStatsMonitor =
+    systemStatsMonitor =
-    // Initialize Proecess related informations
+    // Initialize Process related information
-    this.gemFireVersion = GemFireVersion.asString();
-    this.classPath = runtimeMXBean.getClassPath();
-    this.name = cache.getDistributedSystem().getDistributedMember().getName();
-    this.id = cache.getDistributedSystem().getDistributedMember().getId();
+    gemFireVersion = GemFireVersion.asString();
+    classPath = ManagementFactory.getRuntimeMXBean().getClassPath();
+    name = cache.getDistributedSystem().getDistributedMember().getName();
+    id = cache.getDistributedSystem().getDistributedMember().getId();
-      this.processId = ProcessUtils.identifyPid();
+      processId = ProcessUtils.identifyPid();
-    this.resourceManagerStats = cache.getInternalResourceManager().getStats();
+    resourceManagerStats = cache.getInternalResourceManager().getStats();
-    this.monitor =
-        new MBeanStatsMonitor("MemberMXBeanMonitor");
-    this.diskMonitor = new MemberLevelDiskMonitor(MEMBER_LEVEL_DISK_MONITOR);
-    this.regionMonitor = new AggregateRegionStatsMonitor(MEMBER_LEVEL_REGION_MONITOR);
-    this.gcMonitor = new GCStatsMonitor("GCStatsMonitor");
-    this.vmStatsMonitor =
-        new VMStatsMonitor("VMStatsMonitor");
-    this.systemStatsMonitor =
-        new MBeanStatsMonitor("SystemStatsManager");
+    monitor = new MBeanStatsMonitor("MemberMXBeanMonitor");
+    diskMonitor = new MemberLevelDiskMonitor(MEMBER_LEVEL_DISK_MONITOR);
+    regionMonitor = new AggregateRegionStatsMonitor(MEMBER_LEVEL_REGION_MONITOR);
+    gcMonitor = new GCStatsMonitor("GCStatsMonitor");
+    vmStatsMonitor = new VMStatsMonitor("VMStatsMonitor");
+    systemStatsMonitor = new MBeanStatsMonitor("SystemStatsManager");
-  public MemberMBeanBridge init() {
-    CachePerfStats cachePerfStats = this.cache.getCachePerfStats();
+  MemberMBeanBridge init() {
+    CachePerfStats cachePerfStats = cache.getCachePerfStats();
-    if (osStatisticsProvider.osStatsSupported()) {
-      Statistics[] systemStats = null;
-      systemStats = system.findStatisticsByType(LinuxSystemStats.getType());
+    systemStat = fetchSystemStats();
-      if (systemStats != null) {
-        systemStat = systemStats[0];
-      }
-    }
-
-    MemoryAllocator allocator = this.cache.getOffHeapStore();
+    MemoryAllocator allocator = cache.getOffHeapStore();
-  public void addOffHeapStats(OffHeapMemoryStats offHeapStats) {
+  private Statistics fetchSystemStats() {
+    if (osStatisticsProvider.osStatsSupported()) {
+      Statistics[] systemStats;
+      systemStats = system.findStatisticsByType(LinuxSystemStats.getType());
+
+      if (systemStats != null) {
+        return systemStats[0];
+      }
+    }
+    return null;
+  }
+
+  private void addOffHeapStats(OffHeapMemoryStats offHeapStats) {
+  @VisibleForTesting
+  @VisibleForTesting
+  @VisibleForTesting
-  public void addDiskStore(DiskStore dsi) {
+  void addDiskStore(DiskStore dsi) {
+  @VisibleForTesting
-  public void removeDiskStore(DiskStore dsi) {
+  void removeDiskStore(DiskStore dsi) {
-  public void removeDiskStoreStats(DiskStoreStats stats) {
+  private void removeDiskStoreStats(DiskStoreStats stats) {
-  public void addRegion(Region region) {
+  void addRegion(Region region) {
-      addPartionRegionStats(((PartitionedRegion) region).getPrStats());
+      addPartitionedRegionStats(((PartitionedRegion) region).getPrStats());
-  public void addPartionRegionStats(PartitionedRegionStats parStats) {
+  @VisibleForTesting
+  public void addPartitionedRegionStats(PartitionedRegionStats parStats) {
-  public void addLRUStats(Statistics lruStats) {
+  private void addLRUStats(Statistics lruStats) {
-  public void addDirectoryStats(DiskDirectoryStats diskDirStats) {
+  private void addDirectoryStats(DiskDirectoryStats diskDirStats) {
-  public void removeRegion(Region region) {
+  void removeRegion(Region region) {
-      removePartionRegionStats(((PartitionedRegion) region).getPrStats());
+      removePartitionedRegionStats(((PartitionedRegion) region).getPrStats());
-    LocalRegion l = (LocalRegion) region;
-    removeLRUStats(l.getEvictionStatistics());
+    InternalRegion internalRegion = (InternalRegion) region;
+    removeLRUStats(internalRegion.getEvictionStatistics());
-    DiskRegion dr = l.getDiskRegion();
-    if (dr != null) {
-      for (DirectoryHolder dh : dr.getDirectories()) {
-        removeDirectoryStats(dh.getDiskDirectoryStats());
+    DiskRegion diskRegion = internalRegion.getDiskRegion();
+    if (diskRegion != null) {
+      for (DirectoryHolder directoryHolder : diskRegion.getDirectories()) {
+        removeDirectoryStats(directoryHolder.getDiskDirectoryStats());
-  public void removePartionRegionStats(PartitionedRegionStats parStats) {
+  @VisibleForTesting
+  public void removePartitionedRegionStats(PartitionedRegionStats parStats) {
-  public void removeLRUStats(Statistics statistics) {
+  private void removeLRUStats(Statistics statistics) {
-  public void removeDirectoryStats(DiskDirectoryStats diskDirStats) {
+  private void removeDirectoryStats(DiskDirectoryStats diskDirStats) {
-  public void addLockServiceStats(DLockService lock) {
-    if (!lockStatsAdded) {
+  void addLockServiceStats(DLockService lock) {
+    if (!lockServicesStatsAdded) {
-      lockStatsAdded = true;
+      lockServicesStatsAdded = true;
+  @VisibleForTesting
-    if (vmStatsContract != null && vmStatsContract instanceof VMStats50) {
+    if (vmStatsContract instanceof VMStats50) {
-  public Number getMemberLevelStatistic(String statName) {
+  private Number getMemberLevelStatistic(String statName) {
-  public Number getVMStatistic(String statName) {
+  private Number getVMStatistic(String statName) {
-  public Number getGCStatistic(String statName) {
+  private Number getGCStatistic(String statName) {
-  public Number getSystemStatistic(String statName) {
+  private Number getSystemStatistic(String statName) {
-  public void stopMonitor() {
+  void stopMonitor() {
-  private void intitGemfireProperties() {
+  private void initGemfireProperties() {
-      this.gemFirePropertyData = BeanUtilFuncs.initGemfireProperties(config);
+      gemFirePropertyData = BeanUtilFuncs.initGemfireProperties(config);
-  /**
-   * @return Some basic JVM metrics at the particular instance
-   */
-  public JVMMetrics fetchJVMMetrics() {
+  JVMMetrics fetchJVMMetrics() {
-    // Fixed values might not be updated back by Stats monitor. Hence getting it directly
-   *
-   * @return Some basic OS metrics at the particular instance
-  public OSMetrics fetchOSMetrics() {
-    OSMetrics metrics = null;
+  OSMetrics fetchOSMetrics() {
-      long maxFileDescriptorCount = 0;
-      long openFileDescriptorCount = 0;
-      long processCpuTime = 0;
-      long committedVirtualMemorySize = 0;
-      long totalPhysicalMemorySize = 0;
-      long freePhysicalMemorySize = 0;
-      long totalSwapSpaceSize = 0;
-      long freeSwapSpaceSize = 0;
-
-      openFileDescriptorCount = getVMStatistic(StatsKey.VM_STATS_OPEN_FDS).longValue();
-      processCpuTime = getVMStatistic(StatsKey.VM_PROCESS_CPU_TIME).longValue();
+      long openFileDescriptorCount = getVMStatistic(StatsKey.VM_STATS_OPEN_FDS).longValue();
+      long processCpuTime = getVMStatistic(StatsKey.VM_PROCESS_CPU_TIME).longValue();
+      long maxFileDescriptorCount;
-            (Long) mbeanServer.getAttribute(osObjectName, "MaxFileDescriptorCount");
+            (Long) ManagementFactory.getPlatformMBeanServer()
+                .getAttribute(osObjectName, "MaxFileDescriptorCount");
+
+      long committedVirtualMemorySize;
-            (Long) mbeanServer.getAttribute(osObjectName, "CommittedVirtualMemorySize");
+            (Long) ManagementFactory.getPlatformMBeanServer()
+                .getAttribute(osObjectName, "CommittedVirtualMemorySize");
+      long totalPhysicalMemorySize;
+      long freePhysicalMemorySize;
+      long totalSwapSpaceSize;
+      long freeSwapSpaceSize;
-      metrics = new OSMetrics(maxFileDescriptorCount, openFileDescriptorCount, processCpuTime,
+      return new OSMetrics(maxFileDescriptorCount, openFileDescriptorCount, processCpuTime,
-    return metrics;
+    return null;
-  /**
-   * @return GemFire Properties
-   */
-  public GemFireProperties getGemFireProperty() {
+  GemFireProperties getGemFireProperty() {
-  /**
-   * Creates a Manager
-   *
-   * @return successful or not
-   */
-  public boolean createManager() {
+  boolean createManager() {
-  /**
-   * An instruction to members with cache that they should compact their disk stores.
-   *
-   * @return a list of compacted Disk stores
-   */
-  public String[] compactAllDiskStores() {
-    List<String> compactedStores = new ArrayList<String>();
+  String[] compactAllDiskStores() {
+    List<String> compactedStores = new ArrayList<>();
-      for (DiskStore store : this.cache.listDiskStoresIncludingRegionOwned()) {
+      for (DiskStore store : cache.listDiskStoresIncludingRegionOwned()) {
-  /**
-   * List all the disk Stores at member level
-   *
-   * @param includeRegionOwned indicates whether to show the disk belonging to any particular region
-   * @return list all the disk Stores name at cache level
-   */
-  public String[] listDiskStores(boolean includeRegionOwned) {
-    String[] retStr = null;
-    Collection<DiskStore> diskCollection = null;
+  String[] listDiskStores(boolean includeRegionOwned) {
+    Collection<DiskStore> diskCollection;
-      diskCollection = this.cache.listDiskStoresIncludingRegionOwned();
+      diskCollection = cache.listDiskStoresIncludingRegionOwned();
-      diskCollection = this.cache.listDiskStores();
+      diskCollection = cache.listDiskStores();
-    if (diskCollection != null && diskCollection.size() > 0) {
-      retStr = new String[diskCollection.size()];
+
+    String[] returnString = null;
+    if (diskCollection != null && !diskCollection.isEmpty()) {
+      returnString = new String[diskCollection.size()];
-        retStr[i] = it.next().getName();
+        returnString[i] = it.next().getName();
-    return retStr;
+    return returnString;
-  /**
-   * @return list of disk stores which defaults includeRegionOwned = true;
-   */
-  public String[] getDiskStores() {
+  String[] getDiskStores() {
-  /**
-   * @return log of the member.
-   */
-  public String fetchLog(int numLines) {
+  String fetchLog(int numLines) {
-    String mainTail = null;
+    String mainTail;
-    if (childTail == null && mainTail == null) {
-      return "No log file configured, log messages will be directed to stdout.";
-    } else {
-      StringBuilder result = new StringBuilder();
-      if (mainTail != null) {
-        result.append(mainTail);
-      }
-      if (childTail != null) {
-        result.append(getLineSeparator())
-            .append("-------------------- tail of child log --------------------")
-            .append(getLineSeparator());
-        result.append(childTail);
-      }
-      return result.toString();
+    StringBuilder result = new StringBuilder();
+    result.append(mainTail);
+    if (childTail != null) {
+      result.append(getLineSeparator())
+          .append("-------------------- tail of child log --------------------")
+          .append(getLineSeparator());
+      result.append(childTail);
+    return result.toString();
-  public void shutDownMember() {
+  void shutDownMember() {
-  /**
-   * @return The name for this member.
-   */
-  public String getName() {
+  String getName() {
-  /**
-   * @return The ID for this member.
-   */
-  public String getId() {
+  String getId() {
-  /**
-   * @return The name of the member if it's been set, otherwise the ID of the member
-   */
-  public String getMember() {
+  String getMember() {
-  public String[] getGroups() {
+  String[] getGroups() {
-  /**
-   * @return classPath of the VM
-   */
-  public String getClassPath() {
+  String getClassPath() {
-  /**
-   * @return Connected gateway receivers
-   */
-  public String[] listConnectedGatewayReceivers() {
-    if ((cache != null && cache.getGatewayReceivers().size() > 0)) {
+  String[] listConnectedGatewayReceivers() {
+    if ((cache != null && !cache.getGatewayReceivers().isEmpty())) {
-      String[] arr = new String[receivers.size()];
+      String[] receiverArray = new String[receivers.size()];
-        arr[j] = recv.getBindAddress();
+        receiverArray[j] = recv.getBindAddress();
-      return arr;
+      return receiverArray;
-  /**
-   * @return Connected gateway senders
-   */
-  public String[] listConnectedGatewaySenders() {
-    if ((cache != null && cache.getGatewaySenders().size() > 0)) {
+  String[] listConnectedGatewaySenders() {
+    if ((cache != null && !cache.getGatewaySenders().isEmpty())) {
-      String[] arr = new String[senders.size()];
+      String[] senderArray = new String[senders.size()];
-        arr[j] = sender.getId();
+        senderArray[j] = sender.getId();
-      return arr;
+      return senderArray;
-  /**
-   * @return approximate usage of CPUs
-   */
-  public float getCpuUsage() {
+  float getCpuUsage() {
-  /**
-   * @return current time of the system
-   */
-  public long getCurrentTime() {
+  long getCurrentTime() {
-  public String getHost() {
+  String getHost() {
-  /**
-   * @return the member's process id (pid)
-   */
-  public int getProcessId() {
+  int getProcessId() {
-  public String status() {
+  String status() {
-  /**
-   * @return total heap usage in bytes
-   */
-  public long getTotalBytesInUse() {
-    MemoryUsage memHeap = memoryMXBean.getHeapMemoryUsage();
-    return memHeap.getUsed();
-  }
-
-  /**
-   * @return Number of availabe CPUs
-   */
-  public int getAvailableCpus() {
-    Runtime runtime = Runtime.getRuntime();
-    return runtime.availableProcessors();
-  }
-
-  /**
-   * @return JVM thread list
-   */
-  public String[] fetchJvmThreads() {
-    long threadIds[] = threadMXBean.getAllThreadIds();
+  String[] fetchJvmThreads() {
+    long[] threadIds = threadMXBean.getAllThreadIds();
-    ArrayList<String> thrdStr = new ArrayList<String>(threadInfos.length);
-    for (ThreadInfo thInfo : threadInfos) {
-      if (thInfo != null) {
-        thrdStr.add(thInfo.getThreadName());
+    List<String> threadList = new ArrayList<>(threadInfos.length);
+    for (ThreadInfo threadInfo : threadInfos) {
+      if (threadInfo != null) {
+        threadList.add(threadInfo.getThreadName());
-    String[] result = new String[thrdStr.size()];
-    return thrdStr.toArray(result);
+    String[] result = new String[threadList.size()];
+    return threadList.toArray(result);
-  /**
-   * @return list of regions
-   */
-  public String[] getListOfRegions() {
+  String[] getListOfRegions() {
-    if (listOfAppRegions != null && listOfAppRegions.size() > 0) {
-      String[] regionStr = new String[listOfAppRegions.size()];
+    if (listOfAppRegions != null && !listOfAppRegions.isEmpty()) {
+      String[] regions = new String[listOfAppRegions.size()];
-      for (InternalRegion rg : listOfAppRegions) {
-        regionStr[j] = rg.getFullPath();
+      for (Region region : listOfAppRegions) {
+        regions[j] = region.getFullPath();
-      return regionStr;
+      return regions;
-  /**
-   * @return configuration data lock lease
-   */
-  public long getLockLease() {
+  long getLockLease() {
-  /**
-   * @return configuration data lock time out
-   */
-  public long getLockTimeout() {
+  long getLockTimeout() {
-  /**
-   * @return the duration for which the member is up
-   */
-  public long getMemberUpTime() {
+  long getMemberUpTime() {
-  /**
-   * @return root region names
-   */
-  public String[] getRootRegionNames() {
+  String[] getRootRegionNames() {
-    if (listOfRootRegions != null && listOfRootRegions.size() > 0) {
+    if (listOfRootRegions != null && !listOfRootRegions.isEmpty()) {
-  /**
-   * @return Current GemFire version
-   */
-  public String getVersion() {
+  String getVersion() {
-  /**
-   * @return true if this members has a gateway receiver
-   */
-  public boolean hasGatewayReceiver() {
-    return (cache != null && cache.getGatewayReceivers().size() > 0);
+  boolean hasGatewayReceiver() {
+    return (cache != null && !cache.getGatewayReceivers().isEmpty());
-  /**
-   * @return true if member has Gateway senders
-   */
-  public boolean hasGatewaySender() {
-    return (cache != null && cache.getAllGatewaySenders().size() > 0);
+  boolean hasGatewaySender() {
+    return (cache != null && !cache.getAllGatewaySenders().isEmpty());
-  /**
-   * @return true if member contains one locator. From 7.0 only locator can be hosted in a JVM
-   */
-  public boolean isLocator() {
+  boolean isLocator() {
-  /**
-   * @return true if the Federating Manager Thread is running
-   */
-  public boolean isManager() {
-    if (this.cache == null || this.cache.isClosed()) {
+  boolean isManager() {
+    if (cache == null || cache.isClosed()) {
-  /**
-   * Returns true if the manager has been created. Note it does not need to be running so this
-   * method can return true when isManager returns false.
-   *
-   * @return true if the manager has been created.
-   */
-  public boolean isManagerCreated() {
-    if (this.cache == null || this.cache.isClosed()) {
+  boolean isManagerCreated() {
+    if (cache == null || cache.isClosed()) {
-  /**
-   * @return true if member has a server
-   */
-  public boolean isServer() {
+  boolean isServer() {
-  public long getTotalIndexMaintenanceTime() {
+  long getTotalIndexMaintenanceTime() {
-    this.instCreatesRate = createsRate.getRate();
+    instCreatesRate = createsRate.getRate();
-    this.instGetsRate = getsRate.getRate();
+    instGetsRate = getsRate.getRate();
-    this.instPutAllRate = putAllRate.getRate();
+    instPutAllRate = putAllRate.getRate();
-  public long getPutsAvgLatency() {
+  long getPutsAvgLatency() {
-    this.instPutsRate = putsRate.getRate();
+    instPutsRate = putsRate.getRate();
-  public int getPartitionRegionCount() {
+  int getPartitionRegionCount() {
-  public long getDeserializationAvgLatency() {
+  long getDeserializationAvgLatency() {
-  public long getDeserializationLatency() {
+  long getDeserializationLatency() {
-  public float getDeserializationRate() {
+  float getDeserializationRate() {
-  public long getSerializationAvgLatency() {
+  long getSerializationAvgLatency() {
-  public long getSerializationLatency() {
+  long getSerializationLatency() {
-  public float getSerializationRate() {
+  float getSerializationRate() {
-  public long getPDXDeserializationAvgLatency() {
+  long getPDXDeserializationAvgLatency() {
-  public float getPDXDeserializationRate() {
+  float getPDXDeserializationRate() {
-  /**
-   * Processes the given command string using the given environment information if it's non-empty.
-   * Result returned is in a JSON format.
-   *
-   * @param commandString command string to be processed
-   * @param env environment information to be used for processing the command
-   * @param stagedFilePaths list of local files to be deployed
-   * @return result of the processing the given command string.
-   */
-  public String processCommand(String commandString, Map<String, String> env,
+  public String processCommand(String commandString, Map<String, String> environment,
-    ResultModel result = commandProcessor.executeCommand(commandString, env, stagedFilePaths);
+    ResultModel result =
+        commandProcessor.executeCommand(commandString, environment, stagedFilePaths);
-  public long getGarbageCollectionTime() {
+  long getGarbageCollectionTime() {
-  public long getGarbageCollectionCount() {
+  long getGarbageCollectionCount() {
-  public double getLoadAverage() {
+  double getLoadAverage() {
-  /**
-   * @return max limit of FD ..Ulimit
-   */
-  public long getFileDescriptorLimit() {
+  long getFileDescriptorLimit() {
-    long maxFileDescriptorCount = 0;
+
-      maxFileDescriptorCount =
-          (Long) mbeanServer.getAttribute(osObjectName, "MaxFileDescriptorCount");
+      return (Long) ManagementFactory.getPlatformMBeanServer()
+          .getAttribute(osObjectName, "MaxFileDescriptorCount");
-      maxFileDescriptorCount = -1;
+      // ignore
-    return maxFileDescriptorCount;
+    return -1;
-  /**
-   * @return count of currently opened FDs
-   */
-  public long getTotalFileDescriptorOpen() {
+  long getTotalFileDescriptorOpen() {
-  public int getOffHeapObjects() {
+  int getOffHeapObjects() {
-  /**
-   * @deprecated Please use {@link #getOffHeapFreeMemory()} instead.
-   */
-  /**
-   * @deprecated Please use {@link #getOffHeapUsedMemory()} instead.
-   */
-  public long getOffHeapMaxMemory() {
-    long usedSize = 0;
+  long getOffHeapMaxMemory() {
-      usedSize = stats.getMaxMemory();
+      return stats.getMaxMemory();
-    return usedSize;
+    return 0;
-  public long getOffHeapFreeMemory() {
-    long freeSize = 0;
+  long getOffHeapFreeMemory() {
-      freeSize = stats.getFreeMemory();
+      return stats.getFreeMemory();
-    return freeSize;
+    return 0;
-  public long getOffHeapUsedMemory() {
-    long usedSize = 0;
+  long getOffHeapUsedMemory() {
-      usedSize = stats.getUsedMemory();
+      return stats.getUsedMemory();
-    return usedSize;
+    return 0;
-  public int getOffHeapFragmentation() {
-    int fragmentation = 0;
+  int getOffHeapFragmentation() {
-      fragmentation = stats.getFragmentation();
+      return stats.getFragmentation();
-    return fragmentation;
+    return 0;
-  public long getOffHeapCompactionTime() {
-    long compactionTime = 0;
+  long getOffHeapCompactionTime() {
-      compactionTime = stats.getDefragmentationTime();
+      return stats.getDefragmentationTime();
-    return compactionTime;
+    return 0;
-  /**
-   * Returns the OffHeapMemoryStats for this VM.
-   */
-    OffHeapMemoryStats stats = null;
-
-    MemoryAllocator offHeap = this.cache.getOffHeapStore();
+    MemoryAllocator offHeap = cache.getOffHeapStore();
-      stats = offHeap.getStats();
+      return offHeap.getStats();
-    return stats;
+    return null;
-  public int getHostCpuUsage() {
+  int getHostCpuUsage() {
-  public int getRebalancesInProgress() {
+  int getRebalancesInProgress() {
-    Runtime rt = Runtime.getRuntime();
-    return rt.maxMemory() / MBFactor;
+    return Runtime.getRuntime().maxMemory() / MBFactor;
-    Runtime rt = Runtime.getRuntime();
-    return rt.freeMemory() / MBFactor;
+    return Runtime.getRuntime().freeMemory() / MBFactor;
-  public String getReleaseVersion() {
+  String getReleaseVersion() {

MOV23 MOV23 MOV23 MOV23 MOV31 INS31 MOV21 MOV21 MOV78 INS83 INS42 MOV44 MOV44 INS8 UPD83 INS43 INS42 INS8 UPD83 INS78 INS78 INS78 INS78 UPD83 INS78 UPD42 UPD83 UPD83 INS78 UPD42 UPD83 UPD83 INS78 UPD83 UPD83 UPD83 UPD83 UPD42 MOV60 UPD42 INS21 INS21 INS21 INS21 INS21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 MOV21 INS21 UPD42 MOV42 MOV25 INS41 INS42 INS42 INS42 INS42 INS25 INS42 MOV25 INS42 INS42 INS41 MOV60 MOV21 MOV25 MOV41 UPD42 INS54 INS41 INS41 INS41 INS41 INS41 INS41 INS7 INS7 INS7 INS7 INS7 INS7 INS33 MOV27 INS8 UPD43 MOV62 MOV60 MOV60 MOV60 INS33 UPD42 INS36 INS5 INS74 INS59 MOV5 MOV36 MOV8 MOV8 MOV8 INS12 INS38 INS34 INS34 INS34 INS34 INS34 INS33 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 MOV14 INS42 MOV14 INS42 MOV14 INS42 MOV14 INS42 MOV14 INS42 MOV14 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS21 UPD42 UPD42 UPD42 UPD42 UPD42 INS60 INS60 INS60 INS60 INS60 INS41 UPD42 INS38 INS27 UPD27 MOV27 INS39 INS85 UPD43 MOV43 MOV43 INS42 INS14 UPD42 UPD42 INS38 INS38 UPD27 MOV27 UPD27 MOV27 INS42 INS42 INS42 INS42 INS41 MOV44 INS8 MOV34 INS41 INS41 INS41 INS41 INS41 INS41 INS84 MOV32 INS42 INS42 INS42 INS42 INS32 UPD43 UPD42 UPD42 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 MOV14 UPD74 INS32 MOV27 INS38 UPD42 MOV27 INS38 UPD42 UPD42 UPD74 MOV74 MOV40 MOV5 INS32 UPD42 INS32 MOV27 INS38 MOV27 INS38 INS42 INS42 INS42 INS42 UPD42 INS11 MOV32 MOV32 MOV32 MOV32 MOV32 INS42 MOV32 MOV32 MOV32 INS42 INS42 INS42 INS42 MOV43 MOV43 INS42 INS42 INS41 INS42 MOV32 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 MOV32 MOV32 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 UPD42 MOV42 UPD42 INS32 UPD42 MOV32 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD43 UPD42 MOV42 UPD42 MOV42 MOV32 MOV32 MOV43 MOV32 MOV32 INS42 MOV2 INS42 INS42 MOV32 INS42 UPD42 UPD42 UPD42 UPD42 INS32 UPD42 INS42 UPD42 MOV42 UPD42 MOV43 MOV43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 INS32 INS42 UPD42 MOV42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL65 DEL29 DEL42 DEL78 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL42 DEL78 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL40 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL12 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL33 DEL42 DEL7 DEL21 DEL42 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL8 DEL83 DEL83 DEL83 DEL83 DEL42 DEL32 DEL21 DEL8 DEL25 DEL83 DEL42 DEL33 DEL27 DEL27 DEL83 DEL52 DEL42 DEL22 DEL66 DEL65 DEL29 DEL83 DEL66 DEL65 DEL83 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL34 DEL34 DEL34 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL42 DEL42 DEL7 DEL21 DEL42 DEL41 DEL66 DEL65 DEL29 DEL83 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL52 DEL42 DEL22 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL33 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL32 DEL34 DEL27 DEL66 DEL65 DEL29 DEL83 DEL66 DEL65 DEL29 DEL83 DEL33 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL27 DEL45 DEL41 DEL8 DEL42 DEL33 DEL27 DEL8 DEL25 DEL8 DEL25 DEL83 DEL66 DEL65 DEL29 DEL83 DEL66 DEL65 DEL29 DEL83 DEL66 DEL65 DEL29 DEL83 DEL83 DEL66 DEL65 DEL29 DEL83 DEL66 DEL65 DEL29 DEL83 DEL66 DEL65 DEL29 DEL83 DEL34 DEL27 DEL66 DEL65 DEL29 DEL83 DEL66 DEL65 DEL29 DEL83 DEL83 DEL66 DEL65 DEL29 DEL83 DEL83 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL85 DEL42 DEL43 DEL42 DEL74 DEL14 DEL59 DEL66 DEL65 DEL29 DEL83 DEL32 DEL34 DEL27 DEL66 DEL65 DEL29 DEL83 DEL66 DEL65 DEL29 DEL83 DEL66 DEL65 DEL29 DEL83 DEL66 DEL65 DEL29 DEL83 DEL32 DEL34 DEL27 DEL66 DEL65 DEL29 DEL83 DEL66 DEL65 DEL29 DEL83 DEL34 DEL27 DEL42 DEL32 DEL34 DEL27 DEL27 DEL36 DEL66 DEL65 DEL29 DEL83 DEL34 DEL27 DEL66 DEL65 DEL29 DEL83 DEL66 DEL65 DEL29 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL66 DEL65 DEL29 DEL83 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL66 DEL65 DEL29 DEL83 DEL42 DEL11 DEL7 DEL21 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL38 DEL7 DEL21 DEL8 DEL12 DEL54 DEL42 DEL41 DEL66 DEL65 DEL29 DEL83 DEL83 DEL66 DEL42 DEL68 DEL65 DEL66 DEL65 DEL29 DEL66 DEL42 DEL68 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL41 DEL83 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL41 DEL83 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL41 DEL83 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL41 DEL83 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL41 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL83
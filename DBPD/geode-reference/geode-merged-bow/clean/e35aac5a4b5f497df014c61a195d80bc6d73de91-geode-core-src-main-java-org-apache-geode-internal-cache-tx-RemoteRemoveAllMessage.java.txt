Merge branch 'release/1.5.0'

-package org.apache.geode.internal.cache;
+package org.apache.geode.internal.cache.tx;
-import java.util.Iterator;
+import org.apache.geode.cache.RegionDestroyedException;
-import org.apache.geode.distributed.internal.DM;
+import org.apache.geode.distributed.internal.ClusterDistributionManager;
+import org.apache.geode.internal.cache.DistributedRegion;
+import org.apache.geode.internal.cache.DistributedRemoveAllOperation;
+import org.apache.geode.internal.cache.EntryEventImpl;
+import org.apache.geode.internal.cache.EventID;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.RemoteOperationException;
+import org.apache.geode.internal.cache.TXManagerImpl;
- * data.
+ * data. It is also used to implement non-transactional removeAlls, see:
+ * DistributedRemoveAllOperation.initMessage
-  private transient InternalDistributedSystem internalDs;
-
-  @Override
-  public boolean isSevereAlertCompatible() {
-    // allow forced-disconnect processing for all cache op messages
-    return true;
-  }
-
-   *
-    Collection replicates = r.getCacheDistributionAdvisor().adviseInitializedReplicates();
+    Collection<InternalDistributedMember> replicates =
+        r.getCacheDistributionAdvisor().adviseInitializedReplicates();
-      ArrayList l = new ArrayList(replicates);
+      ArrayList<InternalDistributedMember> l = new ArrayList<>(replicates);
-    for (Iterator<InternalDistributedMember> it = replicates.iterator(); it.hasNext();) {
-      InternalDistributedMember replicate = it.next();
+    for (InternalDistributedMember replicate : replicates) {
-        RemoveAllResponse response = send(replicate, event, data, dataCount, false,
-            DistributionManager.SERIAL_EXECUTOR, posDup);
-        response.waitForCacheException();
+        RemoveAllResponse response = send(replicate, event, data, dataCount, false, posDup);
+        response.waitForRemoteResponse();
-        List successfulKeys = result.getKeys();
+        List<Object> successfulKeys = result.getKeys();
+        @SuppressWarnings("rawtypes")
-      } catch (RemoteOperationException e) {
+      } catch (RegionDestroyedException | RemoteOperationException e) {
-              "RemoteRemoveAllMessage caught an unexpected exception during distribution", e);
+              "RemoteRemoveAllMessage caught an exception during distribution; retrying to another member",
+              e);
-  RemoteRemoveAllMessage(EntryEventImpl event, Set recipients, DirectReplyProcessor p,
+  RemoteRemoveAllMessage(EntryEventImpl event, DistributedMember recipient, DirectReplyProcessor p,
-      int processorType, boolean possibleDuplicate) {
-    super(recipients, event.getRegion().getFullPath(), p);
-    this.resetRecipients();
-    if (recipients != null) {
-      setRecipients(recipients);
-    }
+      boolean possibleDuplicate) {
+    super((InternalDistributedMember) recipient, event.getRegion().getFullPath(), p);
-   * @throws ForceReattemptException if the peer is no longer available
+   * @throws RemoteOperationException if the peer is no longer available
-      int processorType, boolean possibleDuplicate) throws RemoteOperationException {
-    // Assert.assertTrue(recipient != null, "RemoteRemoveAllMessage NULL recipient"); recipient can
-    // be null for event notifications
-    Set recipients = Collections.singleton(recipient);
-    RemoveAllResponse p = new RemoveAllResponse(event.getRegion().getSystem(), recipients);
-    RemoteRemoveAllMessage msg = new RemoteRemoveAllMessage(event, recipients, p, removeAllData,
-        removeAllDataCount, useOriginRemote, processorType, possibleDuplicate);
-    msg.setTransactionDistributed(event.getRegion().getCache().getTxManager().isDistributed());
-    Set failures = event.getRegion().getDistributionManager().putOutgoing(msg);
+      boolean possibleDuplicate) throws RemoteOperationException {
+    RemoveAllResponse p = new RemoveAllResponse(event.getRegion().getSystem(), recipient);
+    RemoteRemoveAllMessage msg = new RemoteRemoveAllMessage(event, recipient, p, removeAllData,
+        removeAllDataCount, useOriginRemote, possibleDuplicate);
+    Set<?> failures = event.getRegion().getDistributionManager().putOutgoing(msg);
-  protected boolean operateOnRegion(DistributionManager dm, LocalRegion r, long startTime)
+  protected boolean operateOnRegion(ClusterDistributionManager dm, LocalRegion r, long startTime)
-  /* we need a event with content for waitForNodeOrCreateBucket() */
-   * @param r partitioned region
+   * @param r region
-    // create a base event and a op for RemoveAllMessage distributed btw redundant buckets
-            new VersionedObjectList(removeAllDataCount, true, dr.concurrencyChecksEnabled);
+            new VersionedObjectList(removeAllDataCount, true, dr.getConcurrencyChecksEnabled());
-                versions.addKeyAndVersion(removeAllData[i].key, ev.getVersionTag());
+                versions.addKeyAndVersion(removeAllData[i].getKey(), ev.getVersionTag());
-
-  // override reply processor type from PartitionMessage
-  RemoteOperationResponse createReplyProcessor(LocalRegion r, Set recipients, Object key) {
-    return new RemoveAllResponse(r.getSystem(), recipients);
-  }
-
-  // override reply message type from PartitionMessage
-  @Override
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
-      LocalRegion r, long startTime) {
-    ReplyMessage.send(member, procId, ex, getReplySender(dm), r != null && r.isInternalRegion());
-  }
-
-
-    /** Result of the RemoveAll operation */
-    public void process(final DM dm, final ReplyProcessor21 rp) {
+    public void process(final DistributionManager dm, final ReplyProcessor21 rp) {
-    public RemoveAllResponse(InternalDistributedSystem ds, Set recipients) {
-      super(ds, recipients, false);
+    public RemoveAllResponse(InternalDistributedSystem ds, DistributedMember recipient) {
+      super(ds, (InternalDistributedMember) recipient, false);

MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 UPD40 INS40 UPD40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS44 UPD66 INS66 INS70 UPD43 UPD42 INS43 INS42 MOV44 INS74 INS44 INS42 MOV8 UPD42 INS11 MOV43 INS74 INS42 UPD66 INS83 UPD43 UPD42 MOV43 INS43 MOV43 INS42 INS43 INS42 MOV43 INS76 UPD42 INS11 INS42 INS74 INS42 UPD42 MOV43 UPD42 MOV43 INS42 MOV43 MOV43 INS74 INS74 INS79 INS84 MOV43 UPD42 MOV43 MOV43 INS42 INS45 INS43 MOV43 INS42 INS32 INS42 INS42 UPD45 INS32 MOV2 INS42 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL78 DEL83 DEL39 DEL42 DEL9 DEL41 DEL8 DEL31 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL40 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL39 DEL42 DEL44 DEL42 DEL52 DEL42 DEL32 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21 DEL42 DEL43 DEL40 DEL42 DEL22 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL14 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42
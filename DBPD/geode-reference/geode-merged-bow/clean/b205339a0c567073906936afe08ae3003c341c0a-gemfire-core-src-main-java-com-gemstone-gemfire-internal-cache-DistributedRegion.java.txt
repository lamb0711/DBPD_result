Merge branch 'feature/GEODE-8' into develop

+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ABSTRACT_REGION_ENTRY_FILL_IN_VALUE;
+
+import com.gemstone.gemfire.internal.cache.control.InternalResourceManager.ResourceType;
+import com.gemstone.gemfire.internal.cache.wan.AbstractGatewaySender;
+import com.gemstone.gemfire.internal.cache.wan.AbstractGatewaySenderEventProcessor;
+import com.gemstone.gemfire.internal.offheap.OffHeapHelper;
+import com.gemstone.gemfire.internal.offheap.SimpleMemoryAllocatorImpl.Chunk;
+import com.gemstone.gemfire.internal.offheap.annotations.Released;
+import com.gemstone.gemfire.internal.offheap.annotations.Retained;
-   * A reference counter to protected the heapThresholdReached boolean
+   * A reference counter to protected the memoryThresholdReached boolean
-  private final Set<DistributedMember> heapThresholdReachedMembers =
+  private final Set<DistributedMember> memoryThresholdReachedMembers =
+  private ConcurrentParallelGatewaySenderQueue hdfsQueue;
+
-        cache.getResourceManager().addResourceListener(this);
+        cache.getResourceManager().addResourceListener(ResourceType.MEMORY, this);
-    if (this.entries.size() > 0) {
-      this.entries.clear(null);
+    if (!this.entries.isEmpty()) {
+      closeEntries();
-        this.entries.clear(rvv);
+        clearEntries(rvv);
+    profile.isOffHeap = getOffHeap();
+  @Retained
-        boolean preferCD, ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent, boolean returnTombstones)
+        boolean preferCD, ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent, boolean returnTombstones, boolean allowReadFromHDFS)
+    @Retained Object result = null;
+    boolean incrementUseCountForSqlf = false;
+    try {
+        try {
-          event = new EntryEventImpl(this, op, key, value,
+          event = EntryEventImpl.create(this, op, key, value,
+        } finally {
+          holder.release();
+        }
-      event = new EntryEventImpl(this, op, key, null /*newValue*/,
+      event = EntryEventImpl.create(this, op, key, null /*newValue*/,
-    if (event.hasNewValue() && !isHeapThresholdReachedForLoad()) {
+    if (event.hasNewValue() && !isMemoryThresholdReachedForLoad()) {
-          
+          incrementUseCountForSqlf = GemFireCacheImpl.sqlfSystem() ;
-    Object result;
+    
-      result = event.getRawNewValue();
-      // fix for bug 42895
-      if (!(result instanceof CachedDeserializable)) {
+      if (event.hasDelta()) {
-      }
+      } else {
+        result = event.getRawNewValueAsHeapObject();
+      }    
-      result = event.getNewValue();
+      result = event.getNewValue();     
+    }
+    //For SQLFire , we need to increment the use count so that returned
+    //object has use count 2
+    if( incrementUseCountForSqlf && result instanceof Chunk) {
+      ((Chunk)result).retain();
+    } finally {
+      if (event != null) {
+        event.release();        
+      }
+    }
+  }
+  
+  protected ConcurrentParallelGatewaySenderQueue getHDFSQueue() {
+    if (this.hdfsQueue == null) {
+      String asyncQId = this.getPartitionedRegion().getHDFSEventQueueName();
+      final AsyncEventQueueImpl asyncQ =  (AsyncEventQueueImpl)this.getCache().getAsyncEventQueue(asyncQId);
+      final AbstractGatewaySender gatewaySender = (AbstractGatewaySender)asyncQ.getSender();
+      AbstractGatewaySenderEventProcessor ep = gatewaySender.getEventProcessor();
+      if (ep == null) return null;
+      hdfsQueue = (ConcurrentParallelGatewaySenderQueue)ep.getQueue();
+    }
+    return hdfsQueue;
-  protected void setHeapThresholdFlag(MemoryEvent event) {
+  protected void setMemoryThresholdFlag(MemoryEvent event) {
-      if (event.getType().isCriticalUp()) {
-        setHeapThresholdReachedCounterTrue(event.getMember());
-      } else if (event.getType().isCriticalDown() || event.getType().isCriticalDisabled()) {
+      if (event.getState().isCritical()
+          && !event.getPreviousState().isCritical()
+          && (event.getType() == ResourceType.HEAP_MEMORY || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
+        setMemoryThresholdReachedCounterTrue(event.getMember());
+      } else if (!event.getState().isCritical()
+          && event.getPreviousState().isCritical()
+          && (event.getType() == ResourceType.HEAP_MEMORY || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
-    synchronized(this.heapThresholdReachedMembers) {
-      this.heapThresholdReachedMembers.remove(member);
-      if (this.heapThresholdReachedMembers.size() == 0) {
-        heapThresholdReached.set(false);
+    synchronized(this.memoryThresholdReachedMembers) {
+      this.memoryThresholdReachedMembers.remove(member);
+      if (this.memoryThresholdReachedMembers.size() == 0) {
+        memoryThresholdReached.set(false);
-  public Set<DistributedMember> getHeapThresholdReachedMembers() {
-    synchronized (this.heapThresholdReachedMembers) {
-      return Collections.unmodifiableSet(this.heapThresholdReachedMembers);
+  public Set<DistributedMember> getMemoryThresholdReachedMembers() {
+    synchronized (this.memoryThresholdReachedMembers) {
+      return Collections.unmodifiableSet(this.memoryThresholdReachedMembers);
-  public void initialCriticalMembers(boolean localHeapIsCritical,
+  public void initialCriticalMembers(boolean localMemoryIsCritical,
-        setHeapThresholdReachedCounterTrue(idm);
+        setMemoryThresholdReachedCounterTrue(idm);
-  private void setHeapThresholdReachedCounterTrue(final DistributedMember idm) {
-    synchronized(this.heapThresholdReachedMembers) {
-      this.heapThresholdReachedMembers.add(idm);
-      if (this.heapThresholdReachedMembers.size() > 0) {
-        heapThresholdReached.set(true);
+  private void setMemoryThresholdReachedCounterTrue(final DistributedMember idm) {
+    synchronized(this.memoryThresholdReachedMembers) {
+      this.memoryThresholdReachedMembers.add(idm);
+      if (this.memoryThresholdReachedMembers.size() > 0) {
+        memoryThresholdReached.set(true);

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS83 INS43 INS59 INS78 INS44 INS83 INS43 INS42 INS8 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS21 INS42 INS39 INS42 INS60 INS54 INS42 INS25 INS41 UPD42 UPD66 INS38 INS7 INS78 INS39 INS59 INS8 INS8 INS27 INS8 INS42 MOV32 INS40 INS32 INS42 INS33 INS42 INS9 MOV8 MOV25 MOV25 MOV25 MOV25 INS25 MOV41 INS25 INS22 INS33 INS60 INS60 INS60 INS60 INS25 INS21 UPD42 UPD42 UPD42 UPD42 INS32 INS42 INS27 INS8 INS27 INS8 INS52 INS42 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS43 INS59 INS27 INS41 INS7 INS27 INS42 INS42 INS62 INS21 INS42 INS33 INS21 INS42 INS42 INS32 INS42 INS42 INS11 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS33 INS33 INS42 INS11 INS32 INS38 INS36 INS27 INS54 INS32 INS8 INS42 INS43 INS32 INS32 INS32 INS42 INS43 INS32 INS43 INS32 INS42 INS42 INS43 INS32 INS32 UPD42 MOV42 INS32 MOV27 INS38 INS32 INS36 UPD42 UPD42 UPD42 INS40 INS42 INS8 INS8 INS32 UPD42 INS42 INS42 INS21 INS42 INS36 INS42 INS42 INS42 INS52 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS27 INS36 UPD42 INS32 INS32 INS42 INS27 UPD42 UPD42 UPD42 UPD42 UPD42 MOV60 MOV21 MOV25 INS21 INS42 INS42 INS52 INS42 INS42 INS33 INS42 INS9 MOV32 INS42 INS7 INS11 INS52 INS42 INS42 INS42 MOV32 INS40 INS27 INS32 INS42 INS42 INS42 INS27 INS36 INS32 INS21 INS42 INS32 INS43 INS42 INS27 MOV32 INS42 INS42 MOV32 INS40 INS27 INS42 INS42 INS7 INS42 INS42 INS42 MOV32 INS40 UPD42 INS27 INS32 INS42 INS32 INS32 INS40 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS9 MOV32 INS42 DEL33 DEL52 DEL42 DEL22 DEL42 DEL32 DEL34 DEL27 DEL52 DEL42 DEL22 DEL42 DEL42 DEL43 DEL52 DEL42 DEL42 DEL42 DEL42 DEL9 DEL42 DEL14 DEL42 DEL43 DEL52 DEL42 DEL42 DEL33 DEL42 DEL9 DEL42 DEL14 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL43 DEL62 DEL36 DEL38 DEL42 DEL32 DEL32
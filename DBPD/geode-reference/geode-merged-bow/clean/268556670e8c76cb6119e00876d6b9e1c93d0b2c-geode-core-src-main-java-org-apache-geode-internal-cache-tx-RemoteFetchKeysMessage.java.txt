GEODE-4372: clean up RemoteOperationMessage classes (#1338)


* throw RemoteOperationException instead of ForceReattemptException when cache is closing. All ForceReattemptException throwing by RemoteOperationMessage has been removed.

* now uses SERIAL_EXECUTOR for all RemoteOperationMessages.
Previously most of these messages where processed in the partitioned message
thread pool even though most all of these messages where not partitioned.
It is possible that RemotePutAll and RemoteRemoveAll will have some trouble
being SERIAL_EXECUTOR.

* added comments for all RemoteOperationMessages describing what
they are used for

* Improved RemoteOperationMessageTest

* added a BucketTXRegionStub to calculate bucket region size on a stub.

* removed GemFireCacheImpl.getInstance call

* added RemoteOperationResponse unit test

* renamed handleAsUnexpected to handleCause

* renamed waitForCacheException to waitForRemoteResponse

* moved RemoteOperation classes to tx package


-package org.apache.geode.internal.cache.partitioned;
+package org.apache.geode.internal.cache.tx;
-import org.apache.geode.cache.RegionDestroyedException;
-import org.apache.geode.internal.cache.ForceReattemptException;
-import org.apache.geode.internal.cache.RemoteOperationMessage;
-/**
- * TODO this class should be moved to a different package
- */
-  /*
-   * (non-Javadoc)
-   *
-   * @see org.apache.geode.internal.cache.RemoteOperationMessage#operateOnRegion(org.apache.geode.
-   * distributed.internal.DistributionManager, org.apache.geode.internal.cache.LocalRegion, long)
-   */
-    Set keys = r.keySet();
+    Set<?> keys = r.keySet();
-    } catch (ForceReattemptException e) {
+    } catch (IOException io) {
-        logger.debug("Caught exception while sending keys: {}", e.getMessage(), e);
+        logger.debug("Caught exception while sending keys: {}", io.getMessage(), io);
+        throw new RemoteOperationException(
+            LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST
+                .toLocalizedString(),
+            io);
-  /*
-   * (non-Javadoc)
-   *
-   * @see org.apache.geode.internal.DataSerializableFixedID#getDSFID()
-   */
-    FetchKeysResponse response = new FetchKeysResponse(currRegion.getSystem(), currRegion,
-        (InternalDistributedMember) target);
+    FetchKeysResponse response =
+        new FetchKeysResponse(currRegion.getSystem(), (InternalDistributedMember) target);
-  /*
-   * (non-Javadoc)
-   *
-   * @see org.apache.geode.internal.cache.RemoteOperationMessage#toData(java.io.DataOutput)
-   */
-  /*
-   * (non-Javadoc)
-   *
-   * @see org.apache.geode.internal.cache.RemoteOperationMessage#fromData(java.io.DataInput)
-   */
-     * @throws ForceReattemptException if the peer is no longer available
+     * @throws IOException if the peer is no longer available
-        final DistributionManager dm, Set keys) throws ForceReattemptException {
+        final DistributionManager dm, Set<?> keys) throws IOException {
-        logger.debug("Starting pr keys chunking for {} keys to member {}", keys.size(), recipient);
+        logger.debug("Starting region keys chunking for {} keys to member {}", keys.size(),
+            recipient);
-      try {
-        boolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES,
-            false, new ObjectIntProcedure() {
-              int msgNum = 0;
+      boolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,
+          new ObjectIntProcedure() {
+            int msgNum = 0;
-              boolean last = false;
+            boolean last = false;
-              /**
-               * @param a byte[] chunk
-               * @param b positive if last chunk
-               * @return true to continue to next chunk
-               */
-              public boolean executeWith(Object a, int b) {
-                // if (this.last)
-                // throw new
-                // InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());
-                HeapDataOutputStream chunk = (HeapDataOutputStream) a;
-                this.last = b > 0;
-                try {
-                  boolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++,
-                      numSeries, this.last);
-                  return okay;
-                } catch (CancelException e) {
-                  return false;
-                }
+            /**
+             * @param a byte[] chunk
+             * @param b positive if last chunk
+             * @return true to continue to next chunk
+             */
+            public boolean executeWith(Object a, int b) {
+              HeapDataOutputStream chunk = (HeapDataOutputStream) a;
+              this.last = b > 0;
+              try {
+                boolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++,
+                    numSeries, this.last);
+                return okay;
+              } catch (CancelException e) {
+                return false;
-            });
+            }
+          });
-        if (logger.isDebugEnabled()) {
-          logger.debug("{} pr keys chunking", (finished ? "Finished" : "DID NOT complete"));
-        }
-      } catch (IOException io) {
-        throw new ForceReattemptException(
-            LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST
-                .toLocalizedString(),
-            io);
+      if (logger.isDebugEnabled()) {
+        logger.debug("{} region keys chunking", (finished ? "Finished" : "DID NOT complete"));
-      // TODO [bruce] pass a reference to the cache or region down here so we can do this test
-      // Assert.assertTrue(!cache is closed, "chunking interrupted but cache is still open");
-      Set failures = dm.putOutgoing(reply);
+      Set<?> failures = dm.putOutgoing(reply);
-     * Serialize the given set's elments into byte[] chunks, calling proc for each one. proc args:
+     * Serialize the given set's elements into byte[] chunks, calling proc for each one. proc args:
-     * chunk, zero othewise). The return value of proc indicates whether to continue to the next
+     * chunk, zero otherwise). The return value of proc indicates whether to continue to the next
-    static boolean chunkSet(InternalDistributedMember recipient, Set set, int CHUNK_SIZE_IN_BYTES,
-        boolean includeValues, ObjectIntProcedure proc) throws IOException {
+    static boolean chunkSet(InternalDistributedMember recipient, Set<?> set,
+        int CHUNK_SIZE_IN_BYTES, boolean includeValues, ObjectIntProcedure proc)
+        throws IOException {
+      @SuppressWarnings("rawtypes")
-    private final LocalRegion region;
-
-    private final Set returnValue;
+    private final Set<Object> returnValue;
-    public FetchKeysResponse(InternalDistributedSystem system, LocalRegion region,
-        InternalDistributedMember member) {
+    public FetchKeysResponse(InternalDistributedSystem system, InternalDistributedMember member) {
-      this.region = region;
-      returnValue = new HashSet();
+      returnValue = new HashSet<>();
-      // this processing algorighm won't work well if there are multiple recipients. currently the
+      // this processing algorithm won't work well if there are multiple recipients. currently the
-      // of this message, we'll need to handle failover in this processor class and track results
+      // of this message, we'll need to handle fail over in this processor class and track results
+    @SuppressWarnings("rawtypes")
-        Throwable t = e.getCause();
-        if (t instanceof CancelException) {
-          logger.debug(
-              "RemoteFetchKeysResponse got remote CacheClosedException; forcing reattempt. {}",
-              t.getMessage(), t);
-        }
-        if (t instanceof ForceReattemptException) {
-          logger.debug("RemoteFetchKeysResponse got remote ForceReattemptException; rethrowing. {}",
-              e.getMessage(), e);
-        }
-        if (t instanceof RegionDestroyedException) {
-          RegionDestroyedException rde = (RegionDestroyedException) t;
-          throw rde;
-        }
-        e.handleAsUnexpected();
+        e.handleCause();

UPD40 INS31 INS43 MOV8 INS74 INS79 MOV83 MOV43 MOV42 MOV8 INS74 INS74 MOV42 MOV21 MOV60 MOV60 MOV25 INS74 MOV43 INS43 INS42 INS45 MOV43 INS76 MOV44 UPD42 MOV43 INS76 INS74 UPD66 UPD66 MOV43 INS76 INS79 INS42 UPD42 MOV42 MOV43 INS76 INS42 INS45 UPD42 MOV42 INS74 INS53 UPD45 UPD45 MOV43 INS14 UPD42 UPD42 INS43 MOV32 INS42 UPD42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL65 DEL29 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL53 DEL8 DEL25 DEL31
Merge branch 'release/1.5.0'

-import org.apache.commons.lang.StringUtils;
+import org.apache.commons.lang.mutable.MutableInt;
+import org.apache.geode.internal.cache.tier.ServerSideHandshake;
-   * The map of known client threads
-   */
-  private final Map _clientThreads;
-
-  /**
-   * An object used to lock the map of client threads
-   */
-  private final Object _clientThreadsLock = new Object();
-
-  /**
-  private final HashMap cleanupTable = new HashMap();
+  private final HashMap<ServerSideHandshake, MutableInt> cleanupTable = new HashMap<>();
-  private final HashMap cleanupProxyIdTable = new HashMap();
+  private final HashMap<ClientProxyMembershipID, MutableInt> cleanupProxyIdTable = new HashMap<>();
+
+  /**
+   * Used to track the connections for a particular client
+   */
+  private final HashMap<ClientProxyMembershipID, ServerConnectionCollection> proxyIdConnections =
+      new HashMap<>();
-  public void addConnection(ClientProxyMembershipID proxyID, ServerConnection connection) {
-    // logger.info("ClientHealthMonitor: Adding " + connection + " to
-    // client with member id " + proxyID);
-    synchronized (_clientThreadsLock) {
-      Set serverConnections = (Set) this._clientThreads.get(proxyID);
-      if (serverConnections == null) {
-        serverConnections = new HashSet();
-        this._clientThreads.put(proxyID, serverConnections);
-      }
-      serverConnections.add(connection);
-      // logger.info("ClientHealthMonitor: The client with member id " +
-      // proxyID + " contains " + serverConnections.size() + " threads");
+  public ServerConnectionCollection addConnection(ClientProxyMembershipID proxyID,
+      ServerConnection connection) {
+    synchronized (proxyIdConnections) {
+      ServerConnectionCollection collection = getProxyIdCollection(proxyID);
+      collection.addConnection(connection);
+      return collection;
-    // logger.info("ClientHealthMonitor: Removing " + connection + " from
-    // client with member id " + proxyID);
-    synchronized (_clientThreadsLock) {
-      Set serverConnections = (Set) this._clientThreads.get(proxyID);
-      if (serverConnections != null) { // fix for bug 35343
-        serverConnections.remove(connection);
-        // logger.info("ClientHealthMonitor: The client with member id " +
-        // proxyID + " contains " + serverConnections.size() + " threads");
-        if (serverConnections.isEmpty()) {
-          // logger.info("ClientHealthMonitor: The client with member id "
-          // + proxyID + " is being removed since it contains 0 threads");
-          this._clientThreads.remove(proxyID);
+    synchronized (proxyIdConnections) {
+      ServerConnectionCollection collection = proxyIdConnections.get(proxyID);
+      if (collection != null) {
+        collection.removeConnection(connection);
+        if (collection.getConnections().isEmpty()) {
+          proxyIdConnections.remove(proxyID);
-  public Map getConnectedClients(Set filterProxies) {
-    Map map = new HashMap(); // KEY=proxyID, VALUE=connectionCount (Integer)
-    synchronized (_clientThreadsLock) {
-      Iterator connectedClients = this._clientThreads.entrySet().iterator();
-      while (connectedClients.hasNext()) {
-        Map.Entry entry = (Map.Entry) connectedClients.next();
-        ClientProxyMembershipID proxyID = (ClientProxyMembershipID) entry.getKey();// proxyID
-                                                                                   // includes FQDN
+  public Map<String, Object[]> getConnectedClients(Set filterProxies) {
+    Map<String, Object[]> map = new HashMap<>(); // KEY=proxyID, VALUE=connectionCount (Integer)
+    synchronized (proxyIdConnections) {
+      for (Map.Entry<ClientProxyMembershipID, ServerConnectionCollection> entry : proxyIdConnections
+          .entrySet()) {
+        ClientProxyMembershipID proxyID = entry.getKey();// proxyID
+        // includes FQDN
-          Set connections = (Set) entry.getValue();
+          Set<ServerConnection> connections = entry.getValue().getConnections();
-          Iterator serverConnections = connections.iterator();
-          while (serverConnections.hasNext()) {
-            ServerConnection sc = (ServerConnection) serverConnections.next();
+          for (ServerConnection sc : connections) {
-          data = (Object[]) map.get(membershipID);
+          data = map.get(membershipID);
-  public Map getStatusForAllClients() {
-    Map result = new HashMap();
-    synchronized (_clientThreadsLock) {
-      Iterator connectedClients = this._clientThreads.entrySet().iterator();
-      while (connectedClients.hasNext()) {
-        Map.Entry entry = (Map.Entry) connectedClients.next();
-        ClientProxyMembershipID proxyID = (ClientProxyMembershipID) entry.getKey();
+  public Map<ClientProxyMembershipID, CacheClientStatus> getStatusForAllClients() {
+    Map<ClientProxyMembershipID, CacheClientStatus> result = new HashMap<>();
+    synchronized (proxyIdConnections) {
+      for (Map.Entry<ClientProxyMembershipID, ServerConnectionCollection> entry : proxyIdConnections
+          .entrySet()) {
+        ClientProxyMembershipID proxyID = entry.getKey();
-        Set connections = (Set) this._clientThreads.get(proxyID);
+        Set<ServerConnection> connections = entry.getValue().getConnections();
-          Iterator connectionsIterator = connections.iterator();
-          while (connectionsIterator.hasNext()) {
-            ServerConnection sc = (ServerConnection) connectionsIterator.next();
+          for (ServerConnection sc : connections) {
-  public void fillInClientInfo(Map allClients) {
+  public void fillInClientInfo(Map<ClientProxyMembershipID, CacheClientStatus> allClients) {
-    synchronized (_clientThreadsLock) {
-      Iterator allClientsIterator = allClients.entrySet().iterator();
-      while (allClientsIterator.hasNext()) {
-        Map.Entry entry = (Map.Entry) allClientsIterator.next();
-        ClientProxyMembershipID proxyID = (ClientProxyMembershipID) entry.getKey();// proxyID
-                                                                                   // includes FQDN
-        CacheClientStatus cci = (CacheClientStatus) entry.getValue();
-        Set connections = (Set) this._clientThreads.get(proxyID);
+    synchronized (proxyIdConnections) {
+      for (Map.Entry<ClientProxyMembershipID, CacheClientStatus> entry : allClients.entrySet()) {
+        ClientProxyMembershipID proxyID = entry.getKey();// proxyID
+        // includes FQDN
+        CacheClientStatus cci = entry.getValue();
+        ServerConnectionCollection collection = proxyIdConnections.get(proxyID);
+        Set<ServerConnection> connections = collection != null ? collection.getConnections() : null;
-          Iterator connectionsIterator = connections.iterator();
-          while (connectionsIterator.hasNext()) {
-            ServerConnection sc = (ServerConnection) connectionsIterator.next();
+          for (ServerConnection sc : connections) {
-                                             // same member id
+            // same member id
-  public Map getConnectedIncomingGateways() {
-    Map connectedIncomingGateways = new HashMap();
-    synchronized (_clientThreadsLock) {
-      Iterator connectedClients = this._clientThreads.entrySet().iterator();
-      while (connectedClients.hasNext()) {
-        Map.Entry entry = (Map.Entry) connectedClients.next();
-        ClientProxyMembershipID proxyID = (ClientProxyMembershipID) entry.getKey();
-        Set connections = (Set) entry.getValue();
-        Iterator connectionsIterator = connections.iterator();
-        while (connectionsIterator.hasNext()) {
-          ServerConnection sc = (ServerConnection) connectionsIterator.next();
+  public Map<String, IncomingGatewayStatus> getConnectedIncomingGateways() {
+    Map<String, IncomingGatewayStatus> connectedIncomingGateways = new HashMap<>();
+    synchronized (proxyIdConnections) {
+      for (Map.Entry<ClientProxyMembershipID, ServerConnectionCollection> entry : proxyIdConnections
+          .entrySet()) {
+        ClientProxyMembershipID proxyID = entry.getKey();
+        Set<ServerConnection> connections = entry.getValue().getConnections();
+        for (ServerConnection sc : connections) {
-    synchronized (this._clientThreadsLock) {
-      serverConnections = (Set) this._clientThreads.remove(proxyID);
-      // It is ok to modify the set after releasing the sync
-      // because it has been removed from the map while holding
-      // the sync.
-    } // end sync here to fix bug 37576 and 36740
+    synchronized (proxyIdConnections) {
+      ServerConnectionCollection collection = proxyIdConnections.remove(proxyID);
+      if (collection != null) {
+        serverConnections = collection.getConnections();
+      }
+    }
-        // logger.warn("Terminating " + serverConnections.size() + " connections");
-          // logger.warn("Terminating " + serverConnection);
-  protected boolean isAnyThreadProcessingMessage(ClientProxyMembershipID proxyID) {
-    boolean processingMessage = false;
-    synchronized (this._clientThreadsLock) {
-      Set serverConnections = (Set) this._clientThreads.get(proxyID);
-      if (serverConnections != null) {
-        for (Iterator it = serverConnections.iterator(); it.hasNext();) {
-          ServerConnection serverConnection = (ServerConnection) it.next();
-          if (serverConnection.isProcessingMessage()) {
-            processingMessage = true;
-            break;
-          }
-        }
+  // This will return true if the proxyID is truly idle (or if no connections are found), or false
+  // if there was a active connection.
+  private boolean prepareToTerminateIfNoConnectionIsProcessing(ClientProxyMembershipID proxyID) {
+    synchronized (proxyIdConnections) {
+      ServerConnectionCollection collection = proxyIdConnections.get(proxyID);
+      if (collection == null) {
+        return true;
+      }
+      if (collection.connectionsProcessing.get() == 0) {
+        collection.isTerminating = true;
+        return true;
+      } else {
+        return false;
-    return processingMessage;
-    Set serverConnections = null;
-    synchronized (this._clientThreadsLock) {
-      serverConnections = (Set) this._clientThreads.get(proxyID);
-      if (serverConnections != null) {
-        serverConnections = new HashSet(serverConnections);
-      }
+    Set<ServerConnection> serverConnections;
+    synchronized (proxyIdConnections) {
+      ServerConnectionCollection collection = proxyIdConnections.get(proxyID);
+      serverConnections =
+          collection != null ? new HashSet<>(collection.getConnections()) : Collections.emptySet();
-    if (serverConnections != null) {
-      for (Iterator it = serverConnections.iterator(); it.hasNext();) {
-        ServerConnection serverConnection = (ServerConnection) it.next();
-        if (serverConnection.hasBeenTimedOutOnClient()) {
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.ClientHealtMonitor_0_IS_BEING_TERMINATED_BECAUSE_ITS_CLIENT_TIMEOUT_OF_1_HAS_EXPIRED,
-              new Object[] {serverConnection,
-                  Integer.valueOf(serverConnection.getClientReadTimeout())}));
-          try {
-            serverConnection.handleTermination(true);
-            // Not all the code in a ServerConnection correctly
-            // handles interrupt. In particular it is possible to be doing
-            // p2p distribution and to have sent a message to one peer but
-            // to never send it to another due to interrupt.
-            // serverConnection.interruptOwner();
-          } finally {
-            // Just to be sure we clean it up.
-            // This call probably isn't needed.
-            removeConnection(proxyID, serverConnection);
-          }
+    for (ServerConnection serverConnection : serverConnections) {
+      if (serverConnection.hasBeenTimedOutOnClient()) {
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.ClientHealtMonitor_0_IS_BEING_TERMINATED_BECAUSE_ITS_CLIENT_TIMEOUT_OF_1_HAS_EXPIRED,
+            new Object[] {serverConnection,
+                Integer.valueOf(serverConnection.getClientReadTimeout())}));
+        try {
+          serverConnection.handleTermination(true);
+          // Not all the code in a ServerConnection correctly
+          // handles interrupt. In particular it is possible to be doing
+          // p2p distribution and to have sent a message to one peer but
+          // to never send it to another due to interrupt.
+          // serverConnection.interruptOwner();
+        } finally {
+          // Just to be sure we clean it up.
+          // This call probably isn't needed.
+          removeConnection(proxyID, serverConnection);
+
-    // Initialize the client threads map
-    this._clientThreads = new HashMap();
-
-  public Map getCleanupProxyIdTable() {
+  public ServerConnectionCollection getProxyIdCollection(ClientProxyMembershipID proxyID) {
+    return proxyIdConnections.computeIfAbsent(proxyID, key -> new ServerConnectionCollection());
+  }
+
+  public Map<ClientProxyMembershipID, MutableInt> getCleanupProxyIdTable() {
-  public Map getCleanupTable() {
+  public Map<ServerSideHandshake, MutableInt> getCleanupTable() {
-  public int getNumberOfClientsAtVersion(Version version) {
-    return numOfClientsPerVersion.get(version.ordinal());
-  }
-
+   * Interface for changing the heartbeat timeout behavior in the ClientHealthMonitorThread, should
+   * only be used for testing
+   */
+  interface HeartbeatTimeoutCheck {
+    boolean timedOut(long current, long lastHeartbeat, long interval);
+  }
+
+  void testUseCustomHeartbeatCheck(HeartbeatTimeoutCheck check) {
+    _clientMonitor.overrideHeartbeatTimeoutCheck(check);
+  }
+
+  /**
+    private HeartbeatTimeoutCheck checkHeartbeat = (long currentTime, long lastHeartbeat,
+        long allowedInterval) -> currentTime - lastHeartbeat > allowedInterval;
+
+    protected void overrideHeartbeatTimeoutCheck(HeartbeatTimeoutCheck newCheck) {
+      checkHeartbeat = newCheck;
+    }
-          // logger.warning("Monitoring " + getClientHeartbeats().size() +
-          // " client(s).");
-              if ((currentTime - latestHeartbeat) > this._maximumTimeBetweenPings) {
+              if (checkHeartbeat.timedOut(currentTime, latestHeartbeat,
+                  this._maximumTimeBetweenPings)) {
-                if (isAnyThreadProcessingMessage(proxyID)) {
-                  if (logger.isDebugEnabled()) {
-                    logger.debug(
-                        "Monitoring client with member id {}. It has been {} ms since the latest heartbeat. This client would have been terminated but at least one of its threads is processing a message.",
-                        entry.getKey(), (currentTime - latestHeartbeat));
-                  }
-                } else {
+                if (prepareToTerminateIfNoConnectionIsProcessing(proxyID)) {
+                } else {
+                  if (logger.isDebugEnabled()) {
+                    logger.debug(
+                        "Monitoring client with member id {}. It has been {} ms since the latest heartbeat. This client would have been terminated but at least one of its threads is processing a message.",
+                        entry.getKey(), (currentTime - latestHeartbeat));
+                  }
-                // logger.warning("Monitoring client with member id " +
-                // entry.getKey() + ". It has been " + (currentTime -
-                // latestHeartbeat) + " ms since the latest heartbeat. This
-                // client is healthy.");

INS26 MOV23 MOV23 MOV31 UPD40 INS40 INS31 INS31 INS55 MOV29 INS74 INS74 MOV59 INS29 INS74 INS43 INS74 INS74 INS74 UPD83 MOV83 MOV39 INS42 MOV44 INS8 MOV8 INS83 INS43 INS42 INS44 INS8 INS74 INS74 INS29 INS42 INS31 UPD39 UPD42 INS23 INS31 INS43 INS43 INS43 UPD42 INS14 MOV43 INS43 INS43 UPD42 INS65 MOV43 INS43 INS43 UPD42 MOV14 INS42 MOV43 INS43 INS5 MOV43 INS43 INS43 INS74 MOV43 INS43 INS43 MOV51 INS60 INS51 INS70 INS42 INS43 INS42 MOV41 MOV43 INS43 INS43 MOV43 INS43 INS43 INS65 INS39 INS42 INS44 INS44 INS44 UPD43 UPD42 INS21 INS83 INS43 INS59 INS83 INS39 INS42 INS44 INS8 UPD42 MOV42 INS42 INS42 INS74 UPD42 MOV42 UPD42 MOV42 INS74 INS66 INS42 INS42 INS74 UPD42 UPD42 INS42 INS43 INS85 INS74 UPD42 INS42 INS42 INS74 UPD42 MOV43 INS43 INS43 UPD42 INS42 INS42 INS74 UPD42 INS42 INS8 INS42 INS74 INS59 INS42 INS8 INS44 INS42 MOV8 INS42 INS32 INS42 INS42 INS42 INS42 INS66 INS66 INS39 INS42 INS39 INS42 INS39 INS42 UPD42 INS32 INS42 INS42 INS86 INS43 INS42 INS21 MOV43 MOV43 MOV43 MOV21 INS41 INS42 MOV43 INS43 MOV5 INS70 MOV43 INS43 INS43 INS70 INS42 INS42 INS70 MOV43 INS43 INS43 INS70 INS60 INS25 INS25 MOV25 MOV43 MOV43 INS42 INS60 INS21 MOV43 INS42 INS42 INS42 INS42 INS86 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS44 INS44 INS44 INS27 INS42 INS7 UPD43 INS42 UPD43 INS42 INS74 INS44 INS32 MOV8 INS42 INS42 INS74 INS44 INS32 MOV8 INS44 MOV32 MOV8 MOV60 INS42 INS42 INS74 INS44 INS32 MOV8 INS43 INS59 INS27 INS8 UPD43 UPD27 MOV27 INS8 INS27 INS8 INS43 INS59 INS7 INS59 INS14 INS39 INS42 INS39 INS42 INS39 INS42 INS27 INS42 INS42 INS42 UPD42 UPD42 INS32 INS42 UPD42 UPD42 UPD42 UPD42 INS32 UPD42 MOV43 INS74 INS42 UPD42 MOV42 UPD42 MOV42 MOV43 INS74 INS42 UPD42 MOV42 UPD42 MOV42 INS74 INS42 MOV43 INS74 INS42 UPD42 MOV42 UPD42 MOV42 INS70 INS42 INS42 INS32 INS42 INS33 MOV21 UPD42 UPD42 INS32 UPD42 INS41 INS32 INS34 INS41 INS41 UPD42 MOV42 UPD42 MOV42 MOV32 INS42 INS16 INS42 INS43 INS42 INS42 UPD42 MOV42 MOV42 INS42 MOV42 MOV42 MOV43 INS43 INS43 MOV43 INS43 INS43 INS74 MOV43 INS43 MOV43 UPD43 UPD43 INS74 MOV43 INS43 INS43 INS74 INS44 INS42 MOV8 INS42 INS42 INS42 INS42 MOV42 MOV42 INS9 INS40 UPD42 MOV42 INS9 INS9 UPD42 UPD42 INS42 INS27 INS14 INS32 INS42 UPD42 UPD42 INS32 UPD42 MOV42 INS42 INS32 INS70 UPD42 MOV42 INS42 INS32 MOV43 MOV43 INS32 INS70 UPD42 MOV42 INS42 UPD42 INS32 MOV32 UPD42 UPD42 INS32 MOV43 MOV43 INS16 INS70 UPD42 MOV42 INS42 INS32 MOV43 MOV43 INS32 MOV43 INS42 INS32 INS40 INS42 INS33 INS74 INS32 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 MOV42 MOV42 INS74 INS44 INS42 MOV8 MOV42 MOV42 INS32 UPD42 MOV42 INS44 INS42 MOV8 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS27 INS32 INS33 INS44 INS42 MOV8 MOV42 MOV42 MOV32 INS42 INS42 UPD42 MOV42 MOV43 INS42 INS42 INS42 MOV43 MOV43 INS32 MOV43 INS42 MOV32 INS42 UPD42 MOV42 MOV43 INS42 INS42 INS33 INS42 UPD42 MOV42 MOV43 INS42 MOV32 INS42 INS32 INS42 INS42 INS42 INS42 MOV22 MOV8 UPD42 DEL66 DEL65 DEL29 DEL43 DEL66 DEL65 DEL29 DEL43 DEL42 DEL43 DEL14 DEL59 DEL83 DEL83 DEL23 DEL14 DEL39 DEL42 DEL43 DEL52 DEL42 DEL22 DEL32 DEL11 DEL52 DEL42 DEL22 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL52 DEL42 DEL22 DEL32 DEL11 DEL52 DEL42 DEL22 DEL42 DEL40 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL32 DEL11 DEL42 DEL43 DEL11 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL11 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL32 DEL61 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL32 DEL11 DEL42 DEL43 DEL52 DEL42 DEL22 DEL32 DEL11 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL32 DEL61 DEL40 DEL40 DEL43 DEL32 DEL11 DEL11 DEL42 DEL43 DEL32 DEL11 DEL52 DEL42 DEL22 DEL42 DEL32 DEL11 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL40 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL32 DEL11 DEL42 DEL43 DEL42 DEL43 DEL11 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL32 DEL61 DEL52 DEL42 DEL22 DEL42 DEL32 DEL11 DEL52 DEL42 DEL22 DEL8 DEL52 DEL42 DEL22 DEL42 DEL43 DEL52 DEL42 DEL22 DEL32 DEL11 DEL42 DEL32 DEL42 DEL10 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL24 DEL8 DEL25 DEL42 DEL39 DEL42 DEL9 DEL59 DEL60 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL43 DEL59 DEL58 DEL32 DEL24 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL11 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL8 DEL51 DEL42 DEL33 DEL27 DEL25 DEL8 DEL52 DEL42 DEL22 DEL7 DEL21 DEL42 DEL83 DEL42 DEL32 DEL32 DEL41 DEL42 DEL42 DEL27 DEL36 DEL27
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import org.apache.geode.internal.cache.Token;
- * @version     $Revision: 1.1 $
+ * @version $Revision: 1.1 $
-  
-  
-  
+
+
+
-  
-  
-  
+
+
+
-  
-  public Object read(Object target)
-  throws NameNotFoundException, QueryInvocationTargetException {
-    if (target == null  || target == QueryService.UNDEFINED){
+
+  public Object read(Object target) throws NameNotFoundException, QueryInvocationTargetException {
+    if (target == null || target == QueryService.UNDEFINED) {
-    if (target instanceof PdxInstance){
+    if (target instanceof PdxInstance) {
-    //for non pdx objects
-    return read(target, target.getClass());
+    // for non pdx objects
+    return readReflection(target);
-  
+
-  private Object read(Object target, Class resolutionClass)
-  throws NameNotFoundException, QueryInvocationTargetException {
+  private Object readReflection(Object target)
+      throws NameNotFoundException, QueryInvocationTargetException {
-    Member m;
-    if (target.getClass().getName().startsWith("org.apache.geode.internal.cache.Token$")) {
+    if (target instanceof Token) {
-    } else {
-      m = getReadMember(resolutionClass);
+
+    Class resolutionClass = target.getClass();
+    Member m = getReadMember(resolutionClass);
-          if (target.getClass().getName().startsWith("org.apache.geode.internal.cache.Token$")) {
-            return QueryService.UNDEFINED;
-          } else {            
-            return ((Method)m).invoke(target, (Object[])null);
-          }
+          return ((Method) m).invoke(target, (Object[]) null);
-          //eat the Exception
+          // eat the Exception
-          throw new NameNotFoundException(LocalizedStrings.AttributeDescriptor_METHOD_0_IN_CLASS_1_IS_NOT_ACCESSIBLE_TO_THE_QUERY_PROCESSOR.toLocalizedString(new Object[] {m.getName(), target.getClass().getName()}), e);
+          throw new NameNotFoundException(
+              LocalizedStrings.AttributeDescriptor_METHOD_0_IN_CLASS_1_IS_NOT_ACCESSIBLE_TO_THE_QUERY_PROCESSOR
+                  .toLocalizedString(new Object[] {m.getName(), target.getClass().getName()}),
+              e);
-             //eat the exception
-             return QueryService.UNDEFINED;
+            // eat the exception
+            return QueryService.UNDEFINED;
-          if (target.getClass().getName().startsWith("org.apache.geode.internal.cache.Token$")) {
-            return QueryService.UNDEFINED;
-          } else {
-            return ((Field)m).get(target);
-          }  
+          return ((Field) m).get(target);
-          throw new NameNotFoundException(LocalizedStrings.AttributeDescriptor_FIELD_0_IN_CLASS_1_IS_NOT_ACCESSIBLE_TO_THE_QUERY_PROCESSOR.toLocalizedString(new Object[] {m.getName(), target.getClass().getName()}), e);
+          throw new NameNotFoundException(
+              LocalizedStrings.AttributeDescriptor_FIELD_0_IN_CLASS_1_IS_NOT_ACCESSIBLE_TO_THE_QUERY_PROCESSOR
+                  .toLocalizedString(new Object[] {m.getName(), target.getClass().getName()}),
+              e);
-  
-  
+
+
-        /*
-    public Object write(Object target, Object newValue)
-        throws PathEvaluationException
-    {
-        if (target == null)
-            return QueryService.UNDEFINED;
-         
-         
-        Class targetType = target.getClass();
-        Class argType = newValue == null ? null : newValue.getClass();
-        Member m = getWriteMember(targetType, argType);
-        if (m == null)
-            throw new PathEvaluationException(LocalizedStrings.AttributeDescriptor_NO_UPDATE_PATH_MAPPING_FOUND_FOR_0.toLocalizedString(_name));
-        try
-        {
-            if (m instanceof Method)
-            {
-                try
-                {
-                    ((Method)m).invoke(target, new Object[] { newValue });
-                    return null;
-                }
-                catch (InvocationTargetException e)
-                {
-                    throw new PathEvaluationException(e.getTargetException());
-                }
-            }
-            else
-            {
-                ((Field)m).set(target, newValue);
-                return null;
-            }
-        }
-        catch (IllegalAccessException e)
-        {
-            throw new PathEvaluationException(e));
-        }
-         
-    }
-         */
-  
-  
-  Member getReadMember(ObjectType targetType)
-  throws NameNotFoundException {
+  /*
+   * public Object write(Object target, Object newValue) throws PathEvaluationException { if (target
+   * == null) return QueryService.UNDEFINED;
+   * 
+   * 
+   * Class targetType = target.getClass(); Class argType = newValue == null ? null :
+   * newValue.getClass(); Member m = getWriteMember(targetType, argType); if (m == null) throw new
+   * PathEvaluationException(LocalizedStrings.AttributeDescriptor_NO_UPDATE_PATH_MAPPING_FOUND_FOR_0
+   * .toLocalizedString(_name)); try { if (m instanceof Method) { try { ((Method)m).invoke(target,
+   * new Object[] { newValue }); return null; } catch (InvocationTargetException e) { throw new
+   * PathEvaluationException(e.getTargetException()); } } else { ((Field)m).set(target, newValue);
+   * return null; } } catch (IllegalAccessException e) { throw new PathEvaluationException(e)); }
+   * 
+   * }
+   */
+
+
+  Member getReadMember(ObjectType targetType) throws NameNotFoundException {
-  
-  Member getReadMember(Class targetClass)
-  throws NameNotFoundException {
+
+  Member getReadMember(Class targetClass) throws NameNotFoundException {
-    // method (attribute())    
+    // method (attribute())
-    
-    Member m = (Member)_cache.get(key);
+
+    Member m = (Member) _cache.get(key);
-    
+
-      throw new NameNotFoundException(LocalizedStrings.AttributeDescriptor_NO_PUBLIC_ATTRIBUTE_NAMED_0_WAS_FOUND_IN_CLASS_1.toLocalizedString(new Object[] {_name, targetClass.getName()}));
+      throw new NameNotFoundException(
+          LocalizedStrings.AttributeDescriptor_NO_PUBLIC_ATTRIBUTE_NAMED_0_WAS_FOUND_IN_CLASS_1
+              .toLocalizedString(new Object[] {_name, targetClass.getName()}));
-    ((AccessibleObject)m).setAccessible(true);
+    ((AccessibleObject) m).setAccessible(true);
-  
-  
-        /* Not yet used, Here to support Update statements
-    private Member getWriteMember(Class targetType, Class argType)
-    {
-            // mapping: public field (same name), method (setAttribute(val)),
-            // method attribute(val)
-        Member m;
-        m = getWriteField(targetType, argType);
-        if (m != null)
-            return m;
-        return getWriteMethod(targetType, argType);
-    }
-         */
-  
-  
-  
+
+
+  /*
+   * Not yet used, Here to support Update statements private Member getWriteMember(Class targetType,
+   * Class argType) { // mapping: public field (same name), method (setAttribute(val)), // method
+   * attribute(val) Member m; m = getWriteField(targetType, argType); if (m != null) return m;
+   * return getWriteMethod(targetType, argType); }
+   */
+
+
+
-  
-        /* not yet used
-    private Field getWriteField(Class targetType, Class argType)
-    {
-        try
-        {
-            return targetType.getField(_name);
-        }
-        catch (NoSuchFieldException e)
-        {
-            return null;
-        }
-    }
-         */
-  
-  
-  
+
+  /*
+   * not yet used private Field getWriteField(Class targetType, Class argType) { try { return
+   * targetType.getField(_name); } catch (NoSuchFieldException e) { return null; } }
+   */
+
+
+
-    String beanMethod = "get" + _name.substring(0,1).toUpperCase() + _name.substring(1);
+    String beanMethod = "get" + _name.substring(0, 1).toUpperCase() + _name.substring(1);
-  
-        /* not yet used
-    private Method getWriteMethod(Class targetType, Class argType)
-    {
-        Method m;
-        String beanMethod = "set" + _name.substring(0,1).toUpperCase() + _name.substring(1);
-        m = getWriteMethod(targetType, argType, beanMethod);
-        if (m != null)
-            return m;
-        return getWriteMethod(targetType, argType, _name);
-    }
-         */
-  
-  
+
+  /*
+   * not yet used private Method getWriteMethod(Class targetType, Class argType) { Method m; String
+   * beanMethod = "set" + _name.substring(0,1).toUpperCase() + _name.substring(1); m =
+   * getWriteMethod(targetType, argType, beanMethod); if (m != null) return m; return
+   * getWriteMethod(targetType, argType, _name); }
+   */
+
+
-      return targetType.getMethod(methodName, (Class[])null);
+      return targetType.getMethod(methodName, (Class[]) null);
-  
-        /* not yet used
-    private Method getWriteMethod(Class targetType, Class argType, String methodName)
-    {
-        try
-        {
-                // @todo look up maximally specific method based on argType
-            return targetType.getMethod(methodName, new Class[] { argType });
-        }
-        catch (NoSuchMethodException e)
-        {
-            return null;
-        }
-    }
-         */
+
+  /*
+   * not yet used private Method getWriteMethod(Class targetType, Class argType, String methodName)
+   * { try { // @todo look up maximally specific method based on argType return
+   * targetType.getMethod(methodName, new Class[] { argType }); } catch (NoSuchMethodException e) {
+   * return null; } }
+   */
+   * 
-  private Object readPdx(PdxInstance target) throws NameNotFoundException,
-      QueryInvocationTargetException {
+  private Object readPdx(PdxInstance target)
+      throws NameNotFoundException, QueryInvocationTargetException {
-      if (pdxInstance.hasField(_name)) { 
+      if (pdxInstance.hasField(_name)) {
-      }
-      else {
+      } else {
-        
-        //don't look further for field or method or reflect on GemFire JSON data
-        if(className.equals(JSONFormatter.JSON_CLASSNAME)){
-            return QueryService.UNDEFINED;
+
+        // don't look further for field or method or reflect on GemFire JSON data
+        if (className.equals(JSONFormatter.JSON_CLASSNAME)) {
+          return QueryService.UNDEFINED;
-        
+
-            return pdxInstance.getDefaultValueIfFieldExistsInAnyPdxVersions(
-                _name, className);
+            return pdxInstance.getDefaultValueIfFieldExistsInAnyPdxVersions(_name, className);
-        }  
+        }
-        if(!this.isMethodAlreadySearchedAndNotFound(className, _name)){
-        	try{
-        		return readFieldFromDeserializedObject(pdxInstance, target);
-        	}catch (NameNotFoundException ex){
-				updateClassToMethodsMap(pdxInstance.getClassName(),_name);
-				throw ex;
-        	}
-        }else return QueryService.UNDEFINED;
+        if (!this.isMethodAlreadySearchedAndNotFound(className, _name)) {
+          try {
+            return readFieldFromDeserializedObject(pdxInstance, target);
+          } catch (NameNotFoundException ex) {
+            updateClassToMethodsMap(pdxInstance.getClassName(), _name);
+            throw ex;
+          }
+        } else
+          return QueryService.UNDEFINED;
-    }
-    else {
+    } else {
-              .toLocalizedString(new Object[] { _name,
-                  target.getClass().getName() }));
+              .toLocalizedString(new Object[] {_name, target.getClass().getName()}));
-  
-  private Object readFieldFromDeserializedObject(PdxInstanceImpl pdxInstance,
-      Object target) throws NameNotFoundException,
-      QueryInvocationTargetException {
+
+  private Object readFieldFromDeserializedObject(PdxInstanceImpl pdxInstance, Object target)
+      throws NameNotFoundException, QueryInvocationTargetException {
-      return read(obj, obj.getClass());
+      return readReflection(obj);
-              .toLocalizedString(new Object[] { _name,
-                  target.getClass().getName() }));
+              .toLocalizedString(new Object[] {_name, target.getClass().getName()}));
-  
+
-  
-  
+
+

INS26 INS40 UPD42 UPD66 INS25 INS60 INS60 INS62 MOV8 MOV43 INS59 MOV43 INS59 UPD42 INS42 INS43 INS42 MOV32 INS42 MOV32 INS42 UPD42 MOV8 MOV8 DEL42 DEL44 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL45 DEL32 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL45 DEL32 DEL40 DEL41 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL45 DEL32 DEL40 DEL41 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32
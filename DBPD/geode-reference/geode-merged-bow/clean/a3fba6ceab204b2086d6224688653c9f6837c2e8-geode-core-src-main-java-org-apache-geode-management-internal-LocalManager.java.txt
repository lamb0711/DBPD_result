GEODE-7221: Cleanup and unit test LocalManager

* Move inner class to bottom of outer class
* Remove unnecessary code
* Extract doManagementTask from ManagementTask
* Create LocalManagerTest

-import java.util.Iterator;
+import org.apache.geode.annotations.VisibleForTesting;
+import org.apache.geode.cache.CacheListener;
- * DistributionHelper solves the following problems
- *
- * a) Handles proxy creation when Management node comes up b) Handles proxy creation when a member
- * joins c) Remove proxies when a member leaves or node stops being management node. d) Takes care
- * to create resources like hidden regions for MBean and notification federation.
+ * <pre>
+ * a) Handles proxy creation when Management node comes up
+ * b) Handles proxy creation when a member joins
+ * c) Remove proxies when a member leaves or node stops being management node.
+ * d) Takes care to create resources like hidden regions for MBean and notification federation.
+ * </pre>
-  protected ScheduledExecutorService singleThreadFederationScheduler;
+  private ScheduledExecutorService singleThreadFederationScheduler;
-  public LocalManager(ManagementResourceRepo repo, InternalDistributedSystem system,
+  LocalManager(ManagementResourceRepo repo, InternalDistributedSystem system,
-    this.federatedComponentMap = new ConcurrentHashMap<ObjectName, FederationComponent>();
+    federatedComponentMap = new ConcurrentHashMap<>();
+   * <p>
-  private void startLocalManagement(Map<ObjectName, FederationComponent> federatedComponentMap) {
-
+  private void startLocalManagement() {
-      } else {
-        singleThreadFederationScheduler =
-            LoggingExecutors.newSingleThreadScheduledExecutor("Management Task");
+      }
+      singleThreadFederationScheduler =
+          LoggingExecutors.newSingleThreadScheduledExecutor("Management Task");
-        if (logger.isDebugEnabled()) {
-          logger.debug("Creating  Management Region :");
+      if (logger.isDebugEnabled()) {
+        logger.debug("Creating  Management Region :");
+      }
+
+      /*
+       * Sharing the same Internal Argument for both notification region and monitoring region
+       */
+      InternalRegionArguments internalArgs = new InternalRegionArguments();
+      internalArgs.setIsUsedForMetaRegion(true);
+
+      // Create anonymous stats holder for Management Regions
+      final HasCachePerfStats monitoringRegionStats =
+          () -> new CachePerfStats(cache.getDistributedSystem(),
+              "RegionStats-managementRegionStats", statisticsClock);
+
+      internalArgs.setCachePerfStatsHolder(monitoringRegionStats);
+
+      AttributesFactory<String, Object> monitorRegionAttributeFactory =
+          new AttributesFactory<>();
+      monitorRegionAttributeFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
+      monitorRegionAttributeFactory.setDataPolicy(DataPolicy.REPLICATE);
+      monitorRegionAttributeFactory.setConcurrencyChecksEnabled(false);
+      CacheListener<String, Object> localListener = new MonitoringRegionCacheListener(service);
+      monitorRegionAttributeFactory.addCacheListener(localListener);
+
+      RegionAttributes<String, Object> monitoringRegionAttrs =
+          monitorRegionAttributeFactory.create();
+
+      AttributesFactory<NotificationKey, Notification> notificationRegionAttributeFactory =
+          new AttributesFactory<>();
+      notificationRegionAttributeFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
+      notificationRegionAttributeFactory.setDataPolicy(DataPolicy.EMPTY);
+      notificationRegionAttributeFactory.setConcurrencyChecksEnabled(false);
+
+      RegionAttributes<NotificationKey, Notification> notifRegionAttrs =
+          notificationRegionAttributeFactory.create();
+
+      String appender = MBeanJMXAdapter.getUniqueIDForMember(system.getDistributedMember());
+
+      try {
+        repo.setLocalMonitoringRegion(
+            cache.createInternalRegion(ManagementConstants.MONITORING_REGION + "_" + appender,
+                monitoringRegionAttrs, internalArgs));
+
+      } catch (TimeoutException | RegionExistsException | ClassNotFoundException | IOException e) {
+        throw new ManagementException(e);
+      }
+
+      boolean notifRegionCreated = false;
+      try {
+        repo.setLocalNotificationRegion(
+            cache.createInternalRegion(ManagementConstants.NOTIFICATION_REGION + "_" + appender,
+                notifRegionAttrs, internalArgs));
+        notifRegionCreated = true;
+      } catch (TimeoutException | ClassNotFoundException | IOException | RegionExistsException e) {
+        throw new ManagementException(e);
+      } finally {
+        if (!notifRegionCreated) {
+          repo.getLocalMonitoringRegion().localDestroyRegion();
+
+      }
-        /*
-         * Sharing the same Internal Argument for both notification region and monitoring region
-         */
-        InternalRegionArguments internalArgs = new InternalRegionArguments();
-        internalArgs.setIsUsedForMetaRegion(true);
+      managementTask = new ManagementTask();
+      // call run to get us initialized immediately with a sync call
+      managementTask.run();
+      // All local resources are created for the ManagementTask
+      // Now Management tasks can proceed.
+      int updateRate = system.getConfig().getJmxManagerUpdateRate();
+      singleThreadFederationScheduler.scheduleAtFixedRate(managementTask, updateRate, updateRate,
+          TimeUnit.MILLISECONDS);
-        // Create anonymous stats holder for Management Regions
-        final HasCachePerfStats monitoringRegionStats =
-            () -> new CachePerfStats(cache.getDistributedSystem(),
-                "RegionStats-managementRegionStats", statisticsClock);
-
-        internalArgs.setCachePerfStatsHolder(monitoringRegionStats);
-
-        AttributesFactory<String, Object> monitorRegionAttributeFactory =
-            new AttributesFactory<String, Object>();
-        monitorRegionAttributeFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
-        monitorRegionAttributeFactory.setDataPolicy(DataPolicy.REPLICATE);
-        monitorRegionAttributeFactory.setConcurrencyChecksEnabled(false);
-        MonitoringRegionCacheListener localListener = new MonitoringRegionCacheListener(service);
-        monitorRegionAttributeFactory.addCacheListener(localListener);
-
-        RegionAttributes<String, Object> monitoringRegionAttrs =
-            monitorRegionAttributeFactory.create();
-
-        AttributesFactory<NotificationKey, Notification> notificationRegionAttributeFactory =
-            new AttributesFactory<NotificationKey, Notification>();
-        notificationRegionAttributeFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
-        notificationRegionAttributeFactory.setDataPolicy(DataPolicy.EMPTY);
-        notificationRegionAttributeFactory.setConcurrencyChecksEnabled(false);
-
-        RegionAttributes<NotificationKey, Notification> notifRegionAttrs =
-            notificationRegionAttributeFactory.create();
-
-        String appender = MBeanJMXAdapter.getUniqueIDForMember(system.getDistributedMember());
-
-        boolean monitoringRegionCreated = false;
-        boolean notifRegionCreated = false;
-
-        try {
-          repo.setLocalMonitoringRegion(
-              cache.createInternalRegion(ManagementConstants.MONITORING_REGION + "_" + appender,
-                  monitoringRegionAttrs, internalArgs));
-          monitoringRegionCreated = true;
-
-        } catch (TimeoutException e) {
-          throw new ManagementException(e);
-        } catch (RegionExistsException e) {
-          throw new ManagementException(e);
-        } catch (IOException e) {
-          throw new ManagementException(e);
-        } catch (ClassNotFoundException e) {
-          throw new ManagementException(e);
-        }
-
-        try {
-          repo.setLocalNotificationRegion(
-              cache.createInternalRegion(ManagementConstants.NOTIFICATION_REGION + "_" + appender,
-                  notifRegionAttrs, internalArgs));
-          notifRegionCreated = true;
-        } catch (TimeoutException e) {
-          throw new ManagementException(e);
-        } catch (RegionExistsException e) {
-          throw new ManagementException(e);
-        } catch (IOException e) {
-          throw new ManagementException(e);
-        } catch (ClassNotFoundException e) {
-          throw new ManagementException(e);
-        } finally {
-          if (!notifRegionCreated && monitoringRegionCreated) {
-            repo.getLocalMonitoringRegion().localDestroyRegion();
-
-          }
-        }
-
-        managementTask = new ManagementTask(federatedComponentMap);
-        // call run to get us initialized immediately with a sync call
-        managementTask.run();
-        // All local resources are created for the ManagementTask
-        // Now Management tasks can proceed.
-        int updateRate = system.getConfig().getJmxManagerUpdateRate();
-        singleThreadFederationScheduler.scheduleAtFixedRate(managementTask, updateRate, updateRate,
-            TimeUnit.MILLISECONDS);
-
-        if (logger.isDebugEnabled()) {
-          logger.debug("Management Region created with Name : {}",
-              repo.getLocalMonitoringRegion().getName());
-          logger.debug("Notification Region created with Name : {}",
-              repo.getLocalNotificationRegion().getName());
-        }
+      if (logger.isDebugEnabled()) {
+        logger.debug("Management Region created with Name : {}",
+            repo.getLocalMonitoringRegion().getName());
+        logger.debug("Notification Region created with Name : {}",
+            repo.getLocalNotificationRegion().getName());
-  public void markForFederation(ObjectName objName, FederationComponent fedComp) {
+  void markForFederation(ObjectName objName, FederationComponent fedComp) {
-  public void unMarkForFederation(ObjectName objName) {
+  void unMarkForFederation(ObjectName objName) {
-    if (this.singleThreadFederationScheduler != null) {
-      this.singleThreadFederationScheduler.shutdownNow();
+    if (singleThreadFederationScheduler != null) {
+      singleThreadFederationScheduler.shutdownNow();
-          } catch (MalformedObjectNameException e) {
-            if (logger.isDebugEnabled()) {
-              logger.debug("Unable to clean MBean: {} due to {}", objName, e.getMessage(), e);
-            }
-          } catch (NullPointerException e) {
+          } catch (MalformedObjectNameException | NullPointerException e) {
-  public ScheduledExecutorService getFederationSheduler() {
+  @VisibleForTesting
+  public ScheduledExecutorService getFederationScheduler() {
+  @VisibleForTesting
+  @Override
+  public boolean isRunning() {
+    return running;
+  }
+
+  @Override
+  public void startManager() {
+    startLocalManagement();
+    running = true;
+  }
+
+  @Override
+  public void stopManager() {
+    // Shutting down the GII executor as this node wont require it anymore
+    shutdownTasks();
+    // Clean up management Resources
+    cleanUpResources();
+    running = false;
+  }
+
+  public Map<ObjectName, FederationComponent> getFedComponents() {
+    return federatedComponentMap;
+  }
+
+  private void doManagementTask(Map<String, FederationComponent> replicaMap) {
+    if (logger.isTraceEnabled()) {
+      logger.trace("Federation started at managed node : ");
+    }
+
+    try {
+      synchronized (lock) {
+        replicaMap.clear();
+        Set<ObjectName> keySet = federatedComponentMap.keySet();
+        if (keySet.isEmpty()) {
+          return;
+        }
+
+        for (ObjectName objectName : keySet) {
+          FederationComponent fedCompInstance = federatedComponentMap.get(objectName);
+
+          if (Thread.interrupted()) {
+            replicaMap.clear();
+            return;
+          }
+
+          if (fedCompInstance != null) {
+            boolean stateChanged = fedCompInstance.refreshObjectState(service.isManager());
+            if (!stopCacheOps) {
+              String key = objectName.toString();
+              if (stateChanged || !repo.keyExistsInLocalMonitoringRegion(key)) {
+                replicaMap.put(key, fedCompInstance);
+              }
+            }
+          }
+        }
+
+        if (stopCacheOps) {
+          return;
+        }
+        if (Thread.interrupted()) {
+          replicaMap.clear();
+          return;
+        }
+        repo.putAllInLocalMonitoringRegion(replicaMap);
+      }
+    } catch (CancelException ex) {
+      if (logger.isDebugEnabled()) {
+        logger.debug("Management Task Cancelled");
+      }
+      return;
+    } catch (GemFireException ex) {
+      if (!cache.isClosed() && logger.isDebugEnabled()) {
+        logger.debug(ex.getMessage(), ex);
+      }
+      // Ignore Exception if cache is closing
+      return;
+    } catch (VirtualMachineError e) {
+      SystemFailure.initiateFailure(e);
+      throw e;
+    } catch (Throwable th) {
+      SystemFailure.checkFailure();
+      throw th;
+    }
+    if (logger.isTraceEnabled()) {
+      logger.trace("Federation completed at managed node : ");
+    }
+  }
+
-    public ManagementTask(Map<ObjectName, FederationComponent> federatedComponentMap)
-        throws ManagementException {
-      this.replicaMap = new HashMap<String, FederationComponent>();
+    private ManagementTask() {
+      replicaMap = new HashMap<>();
-      if (logger.isTraceEnabled()) {
-        logger.trace("Federation started at managed node : ");
-      }
-
-      try {
-        synchronized (lock) {
-          replicaMap.clear();
-          Set<ObjectName> keySet = federatedComponentMap.keySet();
-          if (keySet.size() == 0) {
-            return;
-          }
-
-          Iterator<ObjectName> it = keySet.iterator();
-
-          while (it.hasNext()) {
-
-            ObjectName objectName = it.next();
-            FederationComponent fedCompInstance = federatedComponentMap.get(objectName);
-
-            if (Thread.interrupted()) {
-              replicaMap.clear();
-              return;
-            }
-
-            if (fedCompInstance != null) {
-              boolean stateChanged = fedCompInstance.refreshObjectState(service.isManager());
-              if (!stopCacheOps) {
-                String key = objectName.toString();
-                if (stateChanged || !repo.keyExistsInLocalMonitoringRegion(key)) {
-                  replicaMap.put(key, fedCompInstance);
-                }
-              }
-            }
-          }
-
-          if (stopCacheOps) {
-            return;
-          }
-          if (Thread.interrupted()) {
-            replicaMap.clear();
-            return;
-          }
-          repo.putAllInLocalMonitoringRegion(replicaMap);
-        }
-      } catch (CancelException ex) {
-        if (logger.isDebugEnabled())
-          logger.debug("Management Task Cancelled");
-        return;
-      } catch (GemFireException ex) {
-        if (!cache.isClosed() && logger.isDebugEnabled()) {
-          logger.debug(ex.getMessage(), ex);
-        }
-        return; // Ignore Exception if cache is closing
-      } catch (VirtualMachineError e) {
-        SystemFailure.initiateFailure(e);
-        throw e;
-      } catch (Throwable th) {
-        SystemFailure.checkFailure();
-        throw th;
-      }
-      if (logger.isTraceEnabled()) {
-        logger.trace("Federation completed at managed node : ");
-      }
+      doManagementTask(replicaMap);
-
-  @Override
-  public boolean isRunning() {
-    return running;
-  }
-
-  @Override
-  public void startManager() {
-    startLocalManagement(federatedComponentMap);
-    running = true;
-  }
-
-  @Override
-  public void stopManager() {
-    // Shutting down the GII executor as this node wont require it anymore
-    shutdownTasks();
-    // Clean up management Resources
-    cleanUpResources();
-    running = false;
-  }
-
-  public void stopCacheOps() {
-    stopCacheOps = true;
-  }
-
-  public void startCacheOps() {
-    stopCacheOps = false;
-  }
-
-  public Map<ObjectName, FederationComponent> getFedComponents() {
-    return federatedComponentMap;
-  }
-

MOV26 INS26 INS40 UPD40 MOV31 INS55 UPD83 MOV8 INS78 UPD42 INS78 UPD83 UPD42 MOV44 MOV29 MOV83 MOV42 MOV43 MOV23 MOV31 MOV31 UPD66 UPD66 INS66 UPD66 UPD66 INS66 INS51 INS42 INS42 UPD74 UPD42 UPD83 MOV78 UPD42 INS66 INS52 MOV8 MOV60 UPD43 INS42 INS25 INS42 UPD42 INS32 UPD74 MOV27 MOV8 INS74 INS12 MOV12 INS42 INS42 INS42 INS43 INS43 INS43 INS44 MOV8 INS42 INS70 INS8 UPD74 UPD74 UPD42 MOV42 INS42 INS42 UPD74 INS84 INS42 INS84 MOV38 INS32 INS44 INS42 MOV8 MOV21 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV42 UPD42 MOV42 MOV43 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 INS42 INS84 MOV43 MOV43 DEL83 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL43 DEL42 DEL43 DEL42 DEL43 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL9 DEL7 DEL21 DEL42 DEL44 DEL12 DEL42 DEL44 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL44 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL27 DEL42 DEL25 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL52 DEL51 DEL8 DEL83 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL12 DEL55 DEL42 DEL83 DEL39 DEL42 DEL42 DEL9 DEL7 DEL21 DEL8 DEL31 DEL32 DEL34 DEL27 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL9 DEL7
Merge branch 'develop' into feature/GEODE-7049

+import org.apache.geode.internal.Assert;
+  public BitSet getBitSetForTesting() {
+    return this.bitSet;
+  }
+
-  public void setVersion(long ver) {
+  /**
+   * Should only be called as part of cloning a RegionVersionHolder
+   */
+  void setVersion(long ver) {
-    int length = BIT_SET_WIDTH;
-    int bitCountToFlush = length * 3 / 4;
+    int bitCountToFlush = BIT_SET_WIDTH * 3 / 4;
+
+    // We can only flush up to the last set bit because
+    // the exceptions list includes a "next version" that indicates a received version.
+    bitCountToFlush = bitSet.previousSetBit(bitCountToFlush);
-    if (version >= this.bitSetVersion + length + bitCountToFlush) {
+    if (bitCountToFlush == -1 || version >= this.bitSetVersion + BIT_SET_WIDTH + bitCountToFlush) {
-      addBitSetExceptions(length, version);
+      addBitSetExceptions(version);
-      addBitSetExceptions(bitCountToFlush, this.bitSetVersion + bitCountToFlush);
+      addBitSetExceptions(this.bitSetVersion + bitCountToFlush);
-      addBitSetExceptions((int) (this.version - this.bitSetVersion), this.version);
+      addBitSetExceptions(this.version);
-   *        bitset
-   * @param numBits the desired number of bits to flush from the bitset
+   *        bitset. This should *always* be a version that has been received, because this
+   *        method may need to create an exception up to this version, and the existance of an
+   *        exception implies that the final version was received.
+   *
+   *
-  private void addBitSetExceptions(int numBits, long newVersion) {
-    final boolean isDebugEnabled_RVV = logger.isTraceEnabled(LogMarker.RVV_VERBOSE);
-    int lastSetIndex = -1;
-
-    if (isDebugEnabled_RVV) {
-      logger.trace(LogMarker.RVV_VERBOSE, "addBitSetExceptions({},{})", numBits, newVersion);
+  private void addBitSetExceptions(long newVersion) {
+    if (newVersion <= bitSetVersion) {
+      return;
-    for (int idx = 0; idx < numBits;) {
-      int nextMissingIndex = this.bitSet.nextClearBit(idx);
-      if (nextMissingIndex < 0) {
-        break;
-      }
-
-      lastSetIndex = nextMissingIndex - 1;
-
-      int nextReceivedIndex = this.bitSet.nextSetBit(nextMissingIndex + 1);
-      long nextReceivedVersion = -1;
-      if (nextReceivedIndex > 0) {
-        lastSetIndex = nextReceivedIndex;
-        nextReceivedVersion = (long) (nextReceivedIndex) + this.bitSetVersion;
-        idx = nextReceivedIndex + 1;
-        if (isDebugEnabled_RVV) {
-          logger.trace(LogMarker.RVV_VERBOSE,
-              "found gap in bitSet: missing bit at index={}; next set index={}", nextMissingIndex,
-              nextReceivedIndex);
-        }
-      } else {
-        // We can't flush any more bits from the bit set because there
-        // are no more received versions
-        if (isDebugEnabled_RVV) {
-          logger.trace(LogMarker.RVV_VERBOSE,
-              "terminating flush at bit {} because of missing entries", lastSetIndex);
-        }
-        this.bitSetVersion += lastSetIndex;
-        this.bitSet.clear();
-        if (lastSetIndex != -1) {
-          this.bitSet.set(0);
-        }
-        return;
-      }
-      long nextMissingVersion = Math.max(1, nextMissingIndex + this.bitSetVersion);
-      if (nextReceivedVersion > nextMissingVersion) {
-        addException(nextMissingVersion - 1, nextReceivedVersion);
-        if (isDebugEnabled_RVV) {
-          logger.trace(LogMarker.RVV_VERBOSE, "Added rvv exception e<rv{} - rv{}>",
-              (nextMissingVersion - 1), nextReceivedVersion);
-        }
-      }
+    // Add all of the exceptions that should be flushed from the bitset as real exceptions
+    Iterator<RVVException> exceptionIterator =
+        new BitSetExceptionIterator(bitSet, bitSetVersion, newVersion);
+    while (exceptionIterator.hasNext()) {
+      addException(exceptionIterator.next());
-    this.bitSet = this.bitSet.get(lastSetIndex, Math.max(lastSetIndex + 1, bitSet.size()));
-    if (lastSetIndex > 0) {
-      this.bitSetVersion = this.bitSetVersion + (long) lastSetIndex;
+
+    // Move the data in the bitset forward to reflect the new version
+    if (newVersion > bitSetVersion + bitSet.size()) {
+      // Optimization - if the new version is past the end of the bitset, just clear the bitset
+      bitSet.clear();
+    } else {
+      // Otherwise slide the bitset over to the new offset
+      int offsetIncrease = (int) (newVersion - bitSetVersion);
+      bitSet = bitSet.get(offsetIncrease, bitSet.size());
+
+    // Move the bitset version
+    bitSetVersion = newVersion;
+
+    flushBitSetDuringRecording(version);
+
-    flushBitSetDuringRecording(version);
-    this.bitSet.set((int) (version - this.bitSetVersion));
+    long bitToSet = version - this.bitSetVersion;
+    if (bitToSet > BIT_SET_WIDTH) {
+      Assert.fail("Trying to set a bit larger than the size of the bitset " + bitToSet);
+    }
+    this.bitSet.set(Math.toIntExact(bitToSet));
-  synchronized void addException(long previousVersion, long nextVersion) {
+  synchronized void addException(final long previousVersion, final long nextVersion) {
+    RVVException newException = RVVException.createException(previousVersion, nextVersion);
+    addException(newException);
+  }
+
+  private void addException(RVVException newException) {
-      if (previousVersion >= e.nextVersion) {
-        RVVException except = RVVException.createException(previousVersion, nextVersion);
+      if (newException.previousVersion >= e.nextVersion) {
+        RVVException except = newException;
-    this.exceptions.add(RVVException.createException(previousVersion, nextVersion));
+    this.exceptions.add(newException);
-    // Initialize the bit set to be empty. Merge bit set should
-    // have already done this, but just to be sure.
-    if (this.bitSet != null) {
-      this.bitSetVersion = this.version;
-      // Make sure the bit set is empty except for the first, bit, indicating
-      // that the version has been received.
-      this.bitSet.set(0);
-    }
+
+
+    // Initialize the bit set to be empty. Merge bit set should
+    // have already done this, but just to be sure.
+    if (this.bitSet != null) {
+      this.bitSetVersion = this.version;
+      // Make sure the bit set is empty except for the first, bit, indicating
+      // that the version has been received.
+      this.bitSet.set(0);
+    }

INS26 INS40 INS31 INS31 INS31 INS31 INS83 INS43 INS42 INS8 INS29 MOV29 MOV83 MOV39 MOV42 MOV44 INS8 MOV25 INS83 INS39 INS42 MOV44 INS8 MOV29 INS83 INS39 INS42 INS44 INS44 MOV8 UPD83 INS44 MOV25 INS42 INS41 INS65 INS21 INS25 INS60 INS61 INS25 MOV21 MOV60 MOV25 MOV21 INS83 INS39 INS42 INS83 INS39 INS42 MOV60 INS43 UPD42 MOV42 MOV22 INS66 INS7 INS27 UPD66 INS66 INS66 INS27 INS8 INS74 INS59 INS32 INS8 INS27 INS8 INS8 UPD7 MOV8 INS32 INS43 INS42 INS42 INS32 INS27 MOV27 INS42 INS42 INS41 INS43 INS43 UPD42 MOV42 INS14 INS42 INS42 INS21 UPD42 MOV42 INS27 MOV21 INS60 INS21 INS42 UPD42 INS42 MOV27 UPD42 UPD42 MOV22 UPD42 MOV42 MOV32 INS42 UPD42 INS42 UPD42 UPD42 MOV42 INS42 INS42 INS42 INS42 MOV38 INS42 INS42 INS43 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS39 INS59 INS7 UPD42 INS42 UPD42 UPD42 INS42 INS42 INS32 INS42 UPD42 MOV42 INS42 INS42 INS42 INS11 INS42 INS32 UPD42 UPD42 INS27 INS40 INS60 UPD42 MOV42 UPD42 MOV42 UPD39 MOV39 MOV36 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV32 INS45 UPD42 MOV42 MOV43 INS59 INS27 INS42 INS42 INS42 INS42 DEL83 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL39 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL27 DEL36 DEL11 DEL42 DEL66 DEL65 DEL42 DEL42 DEL7 DEL42 DEL52 DEL42 DEL22 DEL39 DEL42 DEL44 DEL83 DEL39 DEL42 DEL42 DEL42 DEL40 DEL32 DEL59 DEL60 DEL39 DEL59 DEL60 DEL42 DEL42 DEL42 DEL40 DEL45 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL39 DEL42 DEL32 DEL59 DEL60 DEL34 DEL27 DEL10 DEL8 DEL25 DEL42 DEL42 DEL34 DEL27 DEL7 DEL21 DEL39 DEL42 DEL52 DEL42 DEL22 DEL42 DEL34 DEL27 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL38 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL11 DEL52 DEL42 DEL22 DEL27 DEL7 DEL21 DEL42 DEL42 DEL34 DEL27 DEL7 DEL21 DEL42 DEL42 DEL42 DEL40 DEL45 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL40 DEL45 DEL32 DEL21 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL42 DEL34 DEL38 DEL27 DEL52 DEL42 DEL22 DEL42 DEL34 DEL32 DEL21 DEL8 DEL25 DEL41 DEL8 DEL25 DEL8 DEL24 DEL42 DEL34 DEL27 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL39 DEL42 DEL11 DEL27 DEL7 DEL21 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL42 DEL34 DEL42 DEL52 DEL42 DEL22 DEL27 DEL32 DEL40 DEL45 DEL34 DEL27 DEL36 DEL42 DEL42 DEL42 DEL34 DEL27 DEL42 DEL32 DEL21 DEL42 DEL25 DEL8 DEL42 DEL34 DEL27 DEL52 DEL42 DEL22 DEL42 DEL32 DEL7 DEL83 DEL39 DEL42 DEL31 DEL52 DEL42 DEL22 DEL39 DEL36 DEL11 DEL39 DEL42 DEL44 DEL39 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+
- * A static helper for optimally creating copies.  Creating copies
- * of cache values provides improved concurrency as well as isolation.
- * For transactions, creating a copy is the guaranteed way to enforce
- * "Read Committed" isolation on changes to cache
- * <code>Entries</code>.
-
- * <p>Here is a simple example of how to use <code>CopyHelper.copy</code>
- *  <pre>
- *    Object o = r.get("stringBuf");
- *    StringBuffer s = (StringBuffer) CopyHelper.copy(o);
- *    s.append("... and they lived happily ever after.  The End.");
- *    r.put("stringBuf", s);
- *  </pre>
+ * A static helper for optimally creating copies. Creating copies of cache values provides improved
+ * concurrency as well as isolation. For transactions, creating a copy is the guaranteed way to
+ * enforce "Read Committed" isolation on changes to cache <code>Entries</code>.
+ * 
+ * <p>
+ * Here is a simple example of how to use <code>CopyHelper.copy</code>
+ * 
+ * <pre>
+ * Object o = r.get("stringBuf");
+ * StringBuffer s = (StringBuffer) CopyHelper.copy(o);
+ * s.append("... and they lived happily ever after.  The End.");
+ * r.put("stringBuf", s);
+ * </pre>
-  private CopyHelper() {
-  }
+  private CopyHelper() {}
-   * Return true if the given object is an instance of a well known
-   * immutable class.
-   * The well known classes are:
+   * Return true if the given object is an instance of a well known immutable class. The well known
+   * classes are:
+   * 
-      if (o instanceof Integer) return true;
-      if (o instanceof Long) return true;
-      if (o instanceof Byte) return true;
-      if (o instanceof Short) return true;
-      if (o instanceof Float) return true;
-      if (o instanceof Double) return true;
+      if (o instanceof Integer)
+        return true;
+      if (o instanceof Long)
+        return true;
+      if (o instanceof Byte)
+        return true;
+      if (o instanceof Short)
+        return true;
+      if (o instanceof Float)
+        return true;
+      if (o instanceof Double)
+        return true;
-      if (o.getClass().equals(BigInteger.class)) return true;
-      if (o.getClass().equals(BigDecimal.class)) return true;
+      if (o.getClass().equals(BigInteger.class))
+        return true;
+      if (o.getClass().equals(BigDecimal.class))
+        return true;
-    if (o instanceof Character) return true;
-    if (o instanceof UUID) return true;
+    if (o instanceof Character)
+      return true;
+    if (o instanceof UUID)
+      return true;
+
-   * <p>Makes a copy of the specified object. The object returned is not guaranteed
-   * to be a deep copy of the original object, as explained below.
+   * <p>
+   * Makes a copy of the specified object. The object returned is not guaranteed to be a deep copy
+   * of the original object, as explained below.
-   * <p>Copies can only be made if the original is a <tt>Cloneable</tt> or serializable by 
-   * GemFire.
-   * If o is a {@link #isWellKnownImmutableInstance(Object) well known immutable instance}
-   * then it will be returned without copying it.
+   * <p>
+   * Copies can only be made if the original is a <tt>Cloneable</tt> or serializable by GemFire. If
+   * o is a {@link #isWellKnownImmutableInstance(Object) well known immutable instance} then it will
+   * be returned without copying it.
-   * <p>If the argument o is an instance of {@link java.lang.Cloneable}, a copy is
-   * made by invoking <tt>clone</tt> on it. Note that not all implementations of <tt>clone</tt> 
-   * make deep copies (e.g. {@link java.util.HashMap#clone HashMap.clone}). Otherwise, if the
-   * argument is not an instance of <tt>Cloneable</tt>, a copy is made using serialization: if 
-   * GemFire serialization is implemented, it is used; otherwise, java serialization is used.
+   * <p>
+   * If the argument o is an instance of {@link java.lang.Cloneable}, a copy is made by invoking
+   * <tt>clone</tt> on it. Note that not all implementations of <tt>clone</tt> make deep copies
+   * (e.g. {@link java.util.HashMap#clone HashMap.clone}). Otherwise, if the argument is not an
+   * instance of <tt>Cloneable</tt>, a copy is made using serialization: if GemFire serialization is
+   * implemented, it is used; otherwise, java serialization is used.
-   * <p> The difference between this method and {@link #deepCopy(Object) deepCopy}, is that
-   * this method uses <tt>clone</tt> if available, whereas <tt>deepCopy</tt> does not. As a
-   * result, for <tt>Cloneable</tt> objects copied using this method, how deep a copy the 
-   * returned object is depends on its implementation of <tt>clone</tt>. 
+   * <p>
+   * The difference between this method and {@link #deepCopy(Object) deepCopy}, is that this method
+   * uses <tt>clone</tt> if available, whereas <tt>deepCopy</tt> does not. As a result, for
+   * <tt>Cloneable</tt> objects copied using this method, how deep a copy the returned object is
+   * depends on its implementation of <tt>clone</tt>.
-   * @throws CopyException if copying fails because a class could not
-   * be found or could not be serialized.
+   * @throws CopyException if copying fails because a class could not be found or could not be
+   *         serialized.
-        if (isWellKnownImmutableInstance(o)) return o;
+        if (isWellKnownImmutableInstance(o))
+          return o;
-            copy = (T)m.invoke(o, new Object[0]);
+            copy = (T) m.invoke(o, new Object[0]);
-              throw new CopyException(LocalizedStrings.CopyHelper_CLONE_FAILED.toLocalizedString(), cause != null ? cause : ex);
+              throw new CopyException(LocalizedStrings.CopyHelper_CLONE_FAILED.toLocalizedString(),
+                  cause != null ? cause : ex);
-            byte[] a = (byte[])o;
+            byte[] a = (byte[]) o;
-            boolean[] a = (boolean[])o;
+            boolean[] a = (boolean[]) o;
-            char[] a = (char[])o;
+            char[] a = (char[]) o;
-            int[] a = (int[])o;
+            int[] a = (int[]) o;
-            long[] a = (long[])o;
+            long[] a = (long[]) o;
-            short[] a = (short[])o;
+            short[] a = (short[]) o;
-            float[] a = (float[])o;
+            float[] a = (float[]) o;
-            double[] a = (double[])o;
+            double[] a = (double[]) o;
-   * Makes a deep copy of the specified object o using serialization, so the object
-   * has to be serializable by GemFire. 
+   * Makes a deep copy of the specified object o using serialization, so the object has to be
+   * serializable by GemFire.
-   * <p>If o is a {@link #isWellKnownImmutableInstance(Object) well known immutable 
-   * instance} then it will be returned without copying it.
+   * <p>
+   * If o is a {@link #isWellKnownImmutableInstance(Object) well known immutable instance} then it
+   * will be returned without copying it.
-   * <p>The passed in object is serialized in memory, and then deserialized into 
-   * a new instance, which is returned. If GemFire serialization is implemented 
-   * for the object, it is used; otherwise, java serialization is used.  
+   * <p>
+   * The passed in object is serialized in memory, and then deserialized into a new instance, which
+   * is returned. If GemFire serialization is implemented for the object, it is used; otherwise,
+   * java serialization is used.
-   * @throws CopyException if copying fails because a class could not
-   * be found or could not be serialized
+   * @throws CopyException if copying fails because a class could not be found or could not be
+   *         serialized
-  private static<T> T doDeepCopy(T o) {
+  private static <T> T doDeepCopy(T o) {
-      return (T)DataSerializer.readObject(new DataInputStream(hdos.getInputStream()));
+      return (T) DataSerializer.readObject(new DataInputStream(hdos.getInputStream()));
-      throw new CopyException(LocalizedStrings.CopyHelper_COPY_FAILED_ON_INSTANCE_OF_0.toLocalizedString(o.getClass()), ex);
+      throw new CopyException(
+          LocalizedStrings.CopyHelper_COPY_FAILED_ON_INSTANCE_OF_0.toLocalizedString(o.getClass()),
+          ex);
-      throw new CopyException(LocalizedStrings.CopyHelper_COPY_FAILED_ON_INSTANCE_OF_0.toLocalizedString(o.getClass()), ex);
+      throw new CopyException(
+          LocalizedStrings.CopyHelper_COPY_FAILED_ON_INSTANCE_OF_0.toLocalizedString(o.getClass()),
+          ex);

UPD66 UPD66 UPD66 UPD66 UPD66 MOV66 UPD66 UPD66 INS66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66
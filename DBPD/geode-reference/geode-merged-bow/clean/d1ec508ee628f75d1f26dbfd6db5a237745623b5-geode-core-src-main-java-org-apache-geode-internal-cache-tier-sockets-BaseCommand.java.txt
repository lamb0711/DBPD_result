GEODE-2632: refactoring preparations for SecurityService and BaseCommand changes

-import java.util.Iterator;
+import java.util.Map.Entry;
+import edu.umd.cs.findbugs.annotations.SuppressWarnings;
-import org.apache.geode.CancelException;
-import org.apache.geode.cache.Cache;
-  /**
-   * Whether zipped values are being passed to/from the client. Can be modified using the system
-   * property Message.ZIP_VALUES ? This does not appear to happen anywhere
-   */
-  protected static final boolean zipValues = false;
+  private static final byte[] OK_BYTES = new byte[] {0};
-  protected static final boolean APPLY_RETRIES =
-      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "gateway.ApplyRetries");
-
-  public static final byte[] OK_BYTES = new byte[] {0};
-
-  public static final int maximumChunkSize =
-      Integer.getInteger("BridgeServer.MAXIMUM_CHUNK_SIZE", 100).intValue();
-
-  /** Maximum number of entries in each chunked response chunk */
+  public static final int MAXIMUM_CHUNK_SIZE =
+      Integer.getInteger("BridgeServer.MAXIMUM_CHUNK_SIZE", 100);
-  private static boolean suppressIOExceptionLogging =
+  private static final boolean SUPPRESS_IO_EXCEPTION_LOGGING =
-      Integer.getInteger("BridgeServer.MAX_INCOMING_DATA", -1).intValue();
+      Integer.getInteger("BridgeServer.MAX_INCOMING_DATA", -1);
-  private static final int MAX_INCOMING_MSGS =
-      Integer.getInteger("BridgeServer.MAX_INCOMING_MSGS", -1).intValue();
+  private static final int MAX_INCOMING_MESSAGES =
+      Integer.getInteger("BridgeServer.MAX_INCOMING_MSGS", -1);
-  private static final Semaphore incomingDataLimiter;
+  private static final Semaphore INCOMING_DATA_LIMITER;
-  private static final Semaphore incomingMsgLimiter;
-  static {
-    Semaphore tmp;
-    if (MAX_INCOMING_DATA > 0) {
-      // backport requires that this is fair since we inc by values > 1
-      tmp = new Semaphore(MAX_INCOMING_DATA, true);
-    } else {
-      tmp = null;
-    }
-    incomingDataLimiter = tmp;
-    if (MAX_INCOMING_MSGS > 0) {
-      tmp = new Semaphore(MAX_INCOMING_MSGS, false); // unfair for best
-      // performance
-    } else {
-      tmp = null;
-    }
-    incomingMsgLimiter = tmp;
-
-  }
+  private static final Semaphore INCOMING_MSG_LIMITER;
-  public void execute(Message msg, ServerConnection servConn) {
+  static {
+    Semaphore semaphore;
+    if (MAX_INCOMING_DATA > 0) {
+      // backport requires that this is fair since we inc by values > 1
+      semaphore = new Semaphore(MAX_INCOMING_DATA, true);
+    } else {
+      semaphore = null;
+    }
+    INCOMING_DATA_LIMITER = semaphore;
+    if (MAX_INCOMING_MESSAGES > 0) {
+      // unfair for best performance
+      semaphore = new Semaphore(MAX_INCOMING_MESSAGES, false);
+    } else {
+      semaphore = null;
+    }
+    INCOMING_MSG_LIMITER = semaphore;
+  }
+
+  protected static byte[] okBytes() {
+    return OK_BYTES;
+  }
+
+  @Override
+  public void execute(Message clientMessage, ServerConnection serverConnection) {
-    // servConn.resetTransientData();
-    if (EntryLogger.isEnabled() && servConn != null) {
-      EntryLogger.setSource(servConn.getMembershipID(), "c2s");
+    if (EntryLogger.isEnabled() && serverConnection != null) {
+      EntryLogger.setSource(serverConnection.getMembershipID(), "c2s");
-    boolean shouldMasquerade = shouldMasqueradeForTx(msg, servConn);
+    boolean shouldMasquerade = shouldMasqueradeForTx(clientMessage, serverConnection);
-        InternalCache cache = servConn.getCache();
+        InternalCache cache = serverConnection.getCache();
-            (InternalDistributedMember) servConn.getProxyID().getDistributedMember();
+            (InternalDistributedMember) serverConnection.getProxyID().getDistributedMember();
-          tx = txMgr.masqueradeAs(msg, member, false);
-          cmdExecute(msg, servConn, start);
+          tx = txMgr.masqueradeAs(clientMessage, member, false);
+          cmdExecute(clientMessage, serverConnection, start);
-        cmdExecute(msg, servConn, start);
+        cmdExecute(clientMessage, serverConnection, start);
-      handleExceptionNoDisconnect(msg, servConn, e);
+      handleExceptionNoDisconnect(clientMessage, serverConnection, e);
-      BaseCommand.handleEOFException(msg, servConn, eof);
+      BaseCommand.handleEOFException(clientMessage, serverConnection, eof);
-      BaseCommand.handleInterruptedIOException(msg, servConn, e);
+      BaseCommand.handleInterruptedIOException(serverConnection, e);
-      BaseCommand.handleIOException(msg, servConn, e);
+      BaseCommand.handleIOException(clientMessage, serverConnection, e);
-      BaseCommand.handleShutdownException(msg, servConn, e);
+      BaseCommand.handleShutdownException(clientMessage, serverConnection, e);
-      BaseCommand.handleThrowable(msg, servConn, e);
+      BaseCommand.handleThrowable(clientMessage, serverConnection, e);
-   * @param msg
-   * @param servConn
-  protected boolean shouldMasqueradeForTx(Message msg, ServerConnection servConn) {
-    if (servConn.getClientVersion().compareTo(Version.GFE_66) >= 0
-        && msg.getTransactionId() > TXManagerImpl.NOTX) {
-      return true;
-    }
-    return false;
+  protected boolean shouldMasqueradeForTx(Message clientMessage,
+      ServerConnection serverConnection) {
+    return serverConnection.getClientVersion().compareTo(Version.GFE_66) >= 0
+        && clientMessage.getTransactionId() > TXManagerImpl.NOTX;
-   * 
-   * @param clientEvent
-    VersionTag tag = null;
-    if ((clientEvent.getVersionTag() != null) && (clientEvent.getVersionTag().isGatewayTag())) {
+    VersionTag tag;
+    if (clientEvent.getVersionTag() != null && clientEvent.getVersionTag().isGatewayTag()) {
-    return (tag != null);
+    return tag != null;
-  protected VersionTag findVersionTagsForRetriedBulkOp(LocalRegion r, EventID eventID) {
-    VersionTag tag = r.findVersionTagForClientBulkOp(eventID);
+  protected VersionTag findVersionTagsForRetriedBulkOp(LocalRegion region, EventID eventID) {
+    VersionTag tag = region.findVersionTagForClientBulkOp(eventID);
-    if (r instanceof DistributedRegion || r instanceof PartitionedRegion) {
+    if (region instanceof DistributedRegion || region instanceof PartitionedRegion) {
-      tag = FindVersionTagOperation.findVersionTag(r, eventID, true);
+      tag = FindVersionTagOperation.findVersionTag(region, eventID, true);
-  abstract public void cmdExecute(Message msg, ServerConnection servConn, long start)
-      throws IOException, ClassNotFoundException, InterruptedException;
+  public abstract void cmdExecute(Message clientMessage, ServerConnection serverConnection,
+      long start) throws IOException, ClassNotFoundException, InterruptedException;
-  protected void writeReply(Message origMsg, ServerConnection servConn) throws IOException {
-    Message replyMsg = servConn.getReplyMessage();
-    servConn.getCache().getCancelCriterion().checkCancelInProgress(null);
+  protected void writeReply(Message origMsg, ServerConnection serverConnection) throws IOException {
+    Message replyMsg = serverConnection.getReplyMessage();
+    serverConnection.getCache().getCancelCriterion().checkCancelInProgress(null);
-    replyMsg.addBytesPart(OK_BYTES);
-    replyMsg.send(servConn);
+    replyMsg.addBytesPart(okBytes());
+    replyMsg.send(serverConnection);
-      logger.trace("{}: rpl tx: {}", servConn.getName(), origMsg.getTransactionId());
+      logger.trace("{}: rpl tx: {}", serverConnection.getName(), origMsg.getTransactionId());
-  protected void writeReplyWithRefreshMetadata(Message origMsg, ServerConnection servConn,
+  protected void writeReplyWithRefreshMetadata(Message origMsg, ServerConnection serverConnection,
-    Message replyMsg = servConn.getReplyMessage();
-    servConn.getCache().getCancelCriterion().checkCancelInProgress(null);
+    Message replyMsg = serverConnection.getReplyMessage();
+    serverConnection.getCache().getCancelCriterion().checkCancelInProgress(null);
-    replyMsg.send(servConn);
+    replyMsg.send(serverConnection);
-      logger.trace("{}: rpl with REFRESH_METADAT tx: {}", servConn.getName(),
+      logger.trace("{}: rpl with REFRESH_METADATA tx: {}", serverConnection.getName(),
-  private static void handleEOFException(Message msg, ServerConnection servConn, Exception eof) {
-    CachedRegionHelper crHelper = servConn.getCachedRegionHelper();
-    CacheServerStats stats = servConn.getCacheServerStats();
-    boolean potentialModification = servConn.getPotentialModification();
+  private static void handleEOFException(Message msg, ServerConnection serverConnection,
+      Exception eof) {
+    CachedRegionHelper crHelper = serverConnection.getCachedRegionHelper();
+    CacheServerStats stats = serverConnection.getCacheServerStats();
+    boolean potentialModification = serverConnection.getPotentialModification();
-      if (!suppressIOExceptionLogging) {
+      if (!SUPPRESS_IO_EXCEPTION_LOGGING) {
-          int transId = (msg != null) ? msg.getTransactionId() : Integer.MIN_VALUE;
+          int transId = msg != null ? msg.getTransactionId() : Integer.MIN_VALUE;
-              new Object[] {servConn.getName(), servConn.getModRegion(), servConn.getModKey(),
-                  Integer.valueOf(transId)}));
+              new Object[] {serverConnection.getName(), serverConnection.getModRegion(),
+                  serverConnection.getModKey(), transId}));
-              servConn.getName()));
+              serverConnection.getName()));
-    servConn.setFlagProcessMessagesAsFalse();
-    servConn.setClientDisconnectedException(eof);
+    serverConnection.setFlagProcessMessagesAsFalse();
+    serverConnection.setClientDisconnectedException(eof);
-  private static void handleInterruptedIOException(Message msg, ServerConnection servConn,
-      Exception e) {
-    CachedRegionHelper crHelper = servConn.getCachedRegionHelper();
-    if (!crHelper.isShutdown() && servConn.isOpen()) {
-      if (!suppressIOExceptionLogging) {
+  private static void handleInterruptedIOException(ServerConnection serverConnection, Exception e) {
+    CachedRegionHelper crHelper = serverConnection.getCachedRegionHelper();
+    if (!crHelper.isShutdown() && serverConnection.isOpen()) {
+      if (!SUPPRESS_IO_EXCEPTION_LOGGING) {
-    servConn.setFlagProcessMessagesAsFalse();
-    servConn.setClientDisconnectedException(e);
+    serverConnection.setFlagProcessMessagesAsFalse();
+    serverConnection.setClientDisconnectedException(e);
-  private static void handleIOException(Message msg, ServerConnection servConn, Exception e) {
-    CachedRegionHelper crHelper = servConn.getCachedRegionHelper();
-    boolean potentialModification = servConn.getPotentialModification();
+  private static void handleIOException(Message msg, ServerConnection serverConnection,
+      Exception e) {
+    CachedRegionHelper crHelper = serverConnection.getCachedRegionHelper();
+    boolean potentialModification = serverConnection.getPotentialModification();
-    if (!crHelper.isShutdown() && servConn.isOpen()) {
-      if (!suppressIOExceptionLogging) {
+    if (!crHelper.isShutdown() && serverConnection.isOpen()) {
+      if (!SUPPRESS_IO_EXCEPTION_LOGGING) {
-          int transId = (msg != null) ? msg.getTransactionId() : Integer.MIN_VALUE;
+          int transId = msg != null ? msg.getTransactionId() : Integer.MIN_VALUE;
-              new Object[] {servConn.getName(), servConn.getModRegion(), servConn.getModKey(),
-                  Integer.valueOf(transId)}),
+              new Object[] {serverConnection.getName(), serverConnection.getModRegion(),
+                  serverConnection.getModKey(), transId}),
-              servConn.getName()), e);
+              serverConnection.getName()), e);
-    servConn.setFlagProcessMessagesAsFalse();
-    servConn.setClientDisconnectedException(e);
+    serverConnection.setFlagProcessMessagesAsFalse();
+    serverConnection.setClientDisconnectedException(e);
-  private static void handleShutdownException(Message msg, ServerConnection servConn, Exception e) {
-    CachedRegionHelper crHelper = servConn.getCachedRegionHelper();
-    boolean potentialModification = servConn.getPotentialModification();
+  private static void handleShutdownException(Message msg, ServerConnection serverConnection,
+      Exception e) {
+    CachedRegionHelper crHelper = serverConnection.getCachedRegionHelper();
+    boolean potentialModification = serverConnection.getPotentialModification();
-        int transId = (msg != null) ? msg.getTransactionId() : Integer.MIN_VALUE;
+        int transId = msg != null ? msg.getTransactionId() : Integer.MIN_VALUE;
-            new Object[] {servConn.getName(), servConn.getModRegion(), servConn.getModKey(),
-                Integer.valueOf(transId)}),
+            new Object[] {serverConnection.getName(), serverConnection.getModRegion(),
+                serverConnection.getModKey(), transId}),
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.BaseCommand_0_UNEXPECTED_SHUTDOWNEXCEPTION, servConn.getName()), e);
+        logger.warn(
+            LocalizedMessage.create(LocalizedStrings.BaseCommand_0_UNEXPECTED_SHUTDOWNEXCEPTION,
+                serverConnection.getName()),
+            e);
-    servConn.setFlagProcessMessagesAsFalse();
-    servConn.setClientDisconnectedException(e);
+    serverConnection.setFlagProcessMessagesAsFalse();
+    serverConnection.setClientDisconnectedException(e);
-  // Handle GemfireSecurityExceptions separately since the connection should not
-  // be terminated (by setting processMessages to false) unlike in
-  // handleThrowable. Fixes bugs #38384 and #39392.
-  // private static void handleGemfireSecurityException(Message msg,
-  // ServerConnection servConn, GemFireSecurityException e) {
-  //
-  // boolean requiresResponse = servConn.getTransientFlag(REQUIRES_RESPONSE);
-  // boolean responded = servConn.getTransientFlag(RESPONDED);
-  // boolean requiresChunkedResponse = servConn
-  // .getTransientFlag(REQUIRES_CHUNKED_RESPONSE);
-  // boolean potentialModification = servConn.getPotentialModification();
-  //
-  // try {
-  // try {
-  // if (requiresResponse && !responded) {
-  // if (requiresChunkedResponse) {
-  // writeChunkedException(msg, e, false, servConn);
-  // }
-  // else {
-  // writeException(msg, e, false, servConn);
-  // }
-  // servConn.setAsTrue(RESPONDED);
-  // }
-  // }
-  // finally { // inner try-finally to ensure proper ordering of logging
-  // if (potentialModification) {
-  // int transId = (msg != null) ? msg.getTransactionId()
-  // : Integer.MIN_VALUE;
-  // }
-  // }
-  // }
-  // catch (IOException ioe) {
-  // if (logger.isDebugEnabled()) {
-  // logger.fine(servConn.getName()
-  // + ": Unexpected IOException writing security exception: ", ioe);
-  // }
-  // }
-  // }
-
-  private static void handleExceptionNoDisconnect(Message msg, ServerConnection servConn,
+  private static void handleExceptionNoDisconnect(Message msg, ServerConnection serverConnection,
-    boolean requiresResponse = servConn.getTransientFlag(REQUIRES_RESPONSE);
-    boolean responded = servConn.getTransientFlag(RESPONDED);
-    boolean requiresChunkedResponse = servConn.getTransientFlag(REQUIRES_CHUNKED_RESPONSE);
-    boolean potentialModification = servConn.getPotentialModification();
-    boolean wroteExceptionResponse = false;
+    boolean requiresResponse = serverConnection.getTransientFlag(REQUIRES_RESPONSE);
+    boolean responded = serverConnection.getTransientFlag(RESPONDED);
+    boolean requiresChunkedResponse = serverConnection.getTransientFlag(REQUIRES_CHUNKED_RESPONSE);
+    boolean potentialModification = serverConnection.getPotentialModification();
+      boolean wroteExceptionResponse = false;
-            writeChunkedException(msg, e, false, servConn);
+            writeChunkedException(msg, e, serverConnection);
-            writeException(msg, e, false, servConn);
+            writeException(msg, e, false, serverConnection);
-          servConn.setAsTrue(RESPONDED);
+          serverConnection.setAsTrue(RESPONDED);
-          int transId = (msg != null) ? msg.getTransactionId() : Integer.MIN_VALUE;
+          int transId = msg != null ? msg.getTransactionId() : Integer.MIN_VALUE;
-                new Object[] {servConn.getName(), servConn.getModRegion(), servConn.getModKey(),
-                    Integer.valueOf(transId)}),
+                new Object[] {serverConnection.getName(), serverConnection.getModRegion(),
+                    serverConnection.getModKey(), transId}),
-                  servConn.getName(), servConn.getModRegion(), servConn.getModKey(), transId, e);
+                  serverConnection.getName(), serverConnection.getModRegion(),
+                  serverConnection.getModKey(), transId, e);
-                servConn.getName()), e);
+                serverConnection.getName()), e);
-              logger.debug("{}: Exception: {}", servConn.getName(), e.getMessage(), e);
+              logger.debug("{}: Exception: {}", serverConnection.getName(), e.getMessage(), e);
-        logger.debug("{}: Unexpected IOException writing exception: {}", servConn.getName(),
+        logger.debug("{}: Unexpected IOException writing exception: {}", serverConnection.getName(),
-  private static void handleThrowable(Message msg, ServerConnection servConn, Throwable th) {
-    boolean requiresResponse = servConn.getTransientFlag(REQUIRES_RESPONSE);
-    boolean responded = servConn.getTransientFlag(RESPONDED);
-    boolean requiresChunkedResponse = servConn.getTransientFlag(REQUIRES_CHUNKED_RESPONSE);
-    boolean potentialModification = servConn.getPotentialModification();
+  private static void handleThrowable(Message msg, ServerConnection serverConnection,
+      Throwable th) {
+    boolean requiresResponse = serverConnection.getTransientFlag(REQUIRES_RESPONSE);
+    boolean responded = serverConnection.getTransientFlag(RESPONDED);
+    boolean requiresChunkedResponse = serverConnection.getTransientFlag(REQUIRES_CHUNKED_RESPONSE);
+    boolean potentialModification = serverConnection.getPotentialModification();
-          logger.fatal(LocalizedMessage.create(
-              LocalizedStrings.BaseCommand_0_UNEXPECTED_ERROR_ON_SERVER, servConn.getName()), th);
+          logger.fatal(
+              LocalizedMessage.create(LocalizedStrings.BaseCommand_0_UNEXPECTED_ERROR_ON_SERVER,
+                  serverConnection.getName()),
+              th);
-            writeChunkedException(msg, th, false, servConn);
+            writeChunkedException(msg, th, serverConnection);
-            writeException(msg, th, false, servConn);
+            writeException(msg, th, false, serverConnection);
-          servConn.setAsTrue(RESPONDED);
+          serverConnection.setAsTrue(RESPONDED);
-        if (th instanceof Error) {
-          // log nothing
-        } else if (th instanceof CancelException) {
-          // log nothing
-        } else {
+        if (!(th instanceof Error || th instanceof CacheLoaderException)) {
-            int transId = (msg != null) ? msg.getTransactionId() : Integer.MIN_VALUE;
+            int transId = msg != null ? msg.getTransactionId() : Integer.MIN_VALUE;
-                new Object[] {servConn.getName(), servConn.getModRegion(), servConn.getModKey(),
-                    Integer.valueOf(transId)}),
+                new Object[] {serverConnection.getName(), serverConnection.getModRegion(),
+                    serverConnection.getModKey(), transId}),
-                servConn.getName()), th);
+                serverConnection.getName()), th);
-        logger.debug("{}: Unexpected IOException writing exception: {}", servConn.getName(),
+        logger.debug("{}: Unexpected IOException writing exception: {}", serverConnection.getName(),
-      servConn.setFlagProcessMessagesAsFalse();
-      servConn.setClientDisconnectedException(th);
+      serverConnection.setFlagProcessMessagesAsFalse();
+      serverConnection.setClientDisconnectedException(th);
-  protected static void writeChunkedException(Message origMsg, Throwable e, boolean isSevere,
-      ServerConnection servConn) throws IOException {
-    writeChunkedException(origMsg, e, isSevere, servConn, servConn.getChunkedResponseMessage());
+  protected static void writeChunkedException(Message origMsg, Throwable e,
+      ServerConnection serverConnection) throws IOException {
+    writeChunkedException(origMsg, e, serverConnection,
+        serverConnection.getChunkedResponseMessage());
-  protected static void writeChunkedException(Message origMsg, Throwable e, boolean isSevere,
-      ServerConnection servConn, ChunkedMessage originalReponse) throws IOException {
-    writeChunkedException(origMsg, e, isSevere, servConn, originalReponse, 2);
+  protected static void writeChunkedException(Message origMsg, Throwable e,
+      ServerConnection serverConnection, ChunkedMessage originalResponse) throws IOException {
+    writeChunkedException(origMsg, e, serverConnection, originalResponse, 2);
-  protected static void writeChunkedException(Message origMsg, Throwable exception,
-      boolean isSevere, ServerConnection servConn, ChunkedMessage originalReponse, int numOfParts)
+  private static void writeChunkedException(Message origMsg, Throwable exception,
+      ServerConnection serverConnection, ChunkedMessage originalResponse, int numOfParts)
-    Throwable e = getClientException(servConn, exception);
-    ChunkedMessage chunkedResponseMsg = servConn.getChunkedResponseMessage();
-    chunkedResponseMsg.setServerConnection(servConn);
-    if (originalReponse.headerHasBeenSent()) {
-      // chunkedResponseMsg = originalReponse;
-      // fix for bug 35442
+    Throwable e = getClientException(serverConnection, exception);
+    ChunkedMessage chunkedResponseMsg = serverConnection.getChunkedResponseMessage();
+    chunkedResponseMsg.setServerConnection(serverConnection);
+    if (originalResponse.headerHasBeenSent()) {
-        logger.debug("{}: Sending exception chunk while reply in progress: {}", servConn.getName(),
-            e.getMessage(), e);
+        logger.debug("{}: Sending exception chunk while reply in progress: {}",
+            serverConnection.getName(), e.getMessage(), e);
-        logger.debug("{}: Sending exception chunk: {}", servConn.getName(), e.getMessage(), e);
+        logger.debug("{}: Sending exception chunk: {}", serverConnection.getName(), e.getMessage(),
+            e);
-    chunkedResponseMsg.sendChunk(servConn);
+    chunkedResponseMsg.sendChunk(serverConnection);
-      ServerConnection servConn) throws IOException {
-    writeException(origMsg, MessageType.EXCEPTION, e, isSevere, servConn);
+      ServerConnection serverConnection) throws IOException {
+    writeException(origMsg, MessageType.EXCEPTION, e, isSevere, serverConnection);
-  private static Throwable getClientException(ServerConnection servConn, Throwable e) {
-    Cache cache = servConn.getCache();
-    if (cache instanceof InternalCache) {
-      InternalCache icache = (InternalCache) servConn.getCache();
-      OldClientSupportService svc = icache.getService(OldClientSupportService.class);
+  private static Throwable getClientException(ServerConnection serverConnection, Throwable e) {
+    InternalCache cache = serverConnection.getCache();
+    if (cache != null) {
+      OldClientSupportService svc = cache.getService(OldClientSupportService.class);
-        return svc.getThrowable(e, servConn.getClientVersion());
+        return svc.getThrowable(e, serverConnection.getClientVersion());
-      ServerConnection servConn) throws IOException {
-    Throwable theException = getClientException(servConn, e);
-    Message errorMsg = servConn.getErrorResponseMessage();
+      ServerConnection serverConnection) throws IOException {
+    Throwable theException = getClientException(serverConnection, e);
+    Message errorMsg = serverConnection.getErrorResponseMessage();
-    errorMsg.send(servConn);
+    errorMsg.send(serverConnection);
-      logger.debug("{}: Wrote exception: {}", servConn.getName(), e.getMessage(), e);
+      logger.debug("{}: Wrote exception: {}", serverConnection.getName(), e.getMessage(), e);
-      ServerConnection servConn) throws IOException {
-    Message errorMsg = servConn.getErrorResponseMessage();
+      ServerConnection serverConnection) throws IOException {
+    Message errorMsg = serverConnection.getErrorResponseMessage();
-    errorMsg.send(servConn);
+    errorMsg.send(serverConnection);
-      ServerConnection servConn) throws IOException {
-    Message errorMsg = servConn.getErrorResponseMessage();
+      ServerConnection serverConnection) throws IOException {
+    Message errorMsg = serverConnection.getErrorResponseMessage();
-    errorMsg.send(servConn);
+    errorMsg.send(serverConnection);
-      ServerConnection servConn) throws IOException {
-    String reason = servConn.getName() + ": Region named " + regionName + title;
+      ServerConnection serverConnection) throws IOException {
+    String reason = serverConnection.getName() + ": Region named " + regionName + title;
-    if (servConn.getTransientFlag(REQUIRES_CHUNKED_RESPONSE)) {
-      writeChunkedException(msg, ex, false, servConn);
+    if (serverConnection.getTransientFlag(REQUIRES_CHUNKED_RESPONSE)) {
+      writeChunkedException(msg, ex, serverConnection);
-      writeException(msg, ex, false, servConn);
+      writeException(msg, ex, false, serverConnection);
-      boolean isObject, ServerConnection servConn) throws IOException {
-    Message responseMsg = servConn.getResponseMessage();
+      boolean isObject, ServerConnection serverConnection) throws IOException {
+    Message responseMsg = serverConnection.getResponseMessage();
-      responseMsg.addObjPart(data, zipValues);
+      responseMsg.addObjPart(data, false);
-    servConn.getCache().getCancelCriterion().checkCancelInProgress(null);
-    responseMsg.send(servConn);
+    serverConnection.getCache().getCancelCriterion().checkCancelInProgress(null);
+    responseMsg.send(serverConnection);
-      Message origMsg, boolean isObject, ServerConnection servConn, PartitionedRegion pr,
+      Message origMsg, boolean isObject, ServerConnection serverConnection, PartitionedRegion pr,
-    Message responseMsg = servConn.getResponseMessage();
+    Message responseMsg = serverConnection.getResponseMessage();
-      responseMsg.addObjPart(data, zipValues);
+      responseMsg.addObjPart(data, false);
-    servConn.getCache().getCancelCriterion().checkCancelInProgress(null);
-    responseMsg.send(servConn);
+    serverConnection.getCache().getCancelCriterion().checkCancelInProgress(null);
+    responseMsg.send(serverConnection);
-      ServerConnection servConn) throws IOException {
-    Message responseMsg = servConn.getResponseMessage();
+      ServerConnection serverConnection) throws IOException {
+    Message responseMsg = serverConnection.getResponseMessage();
-    servConn.getCache().getCancelCriterion().checkCancelInProgress(null);
-    responseMsg.send(servConn);
+    serverConnection.getCache().getCancelCriterion().checkCancelInProgress(null);
+    responseMsg.send(serverConnection);
-  static protected void checkForInterrupt(ServerConnection servConn, Exception e)
+  protected static void checkForInterrupt(ServerConnection serverConnection, Exception e)
-    servConn.getCachedRegionHelper().checkCancelInProgress(e);
+    serverConnection.getCachedRegionHelper().checkCancelInProgress(e);
-  protected static void writeQueryResponseChunk(Object queryResponseChunk,
-      CollectionType collectionType, boolean lastChunk, ServerConnection servConn)
-      throws IOException {
-    ChunkedMessage queryResponseMsg = servConn.getQueryResponseMessage();
+  static void writeQueryResponseChunk(Object queryResponseChunk, CollectionType collectionType,
+      boolean lastChunk, ServerConnection serverConnection) throws IOException {
+    ChunkedMessage queryResponseMsg = serverConnection.getQueryResponseMessage();
-    queryResponseMsg.addObjPart(collectionType, zipValues);
-    queryResponseMsg.addObjPart(queryResponseChunk, zipValues);
-    queryResponseMsg.sendChunk(servConn);
+    queryResponseMsg.addObjPart(collectionType, false);
+    queryResponseMsg.addObjPart(queryResponseChunk, false);
+    queryResponseMsg.sendChunk(serverConnection);
-      boolean isSevere, ServerConnection servConn) throws IOException {
-    Throwable e = getClientException(servConn, exception);
-    ChunkedMessage queryResponseMsg = servConn.getQueryResponseMessage();
-    ChunkedMessage chunkedResponseMsg = servConn.getChunkedResponseMessage();
+      ServerConnection serverConnection) throws IOException {
+    Throwable e = getClientException(serverConnection, exception);
+    ChunkedMessage queryResponseMsg = serverConnection.getQueryResponseMessage();
+    ChunkedMessage chunkedResponseMsg = serverConnection.getChunkedResponseMessage();
-      queryResponseMsg.setServerConnection(servConn);
+      queryResponseMsg.setServerConnection(serverConnection);
-        logger.debug("{}: Sending exception chunk while reply in progress: {}", servConn.getName(),
-            e.getMessage(), e);
+        logger.debug("{}: Sending exception chunk while reply in progress: {}",
+            serverConnection.getName(), e.getMessage(), e);
-      queryResponseMsg.sendChunk(servConn);
+      queryResponseMsg.sendChunk(serverConnection);
-      chunkedResponseMsg.setServerConnection(servConn);
+      chunkedResponseMsg.setServerConnection(serverConnection);
-        logger.debug("{}: Sending exception chunk: {}", servConn.getName(), e.getMessage(), e);
+        logger.debug("{}: Sending exception chunk: {}", serverConnection.getName(), e.getMessage(),
+            e);
-      chunkedResponseMsg.sendChunk(servConn);
+      chunkedResponseMsg.sendChunk(serverConnection);
-      ServerConnection servConn) throws IOException {
+      ServerConnection serverConnection) throws IOException {
-    ChunkedMessage chunkedResponseMsg = servConn.getChunkedResponseMessage();
+    ChunkedMessage chunkedResponseMsg = serverConnection.getChunkedResponseMessage();
-      logger.debug(servConn.getName() + ": Sending error message header type: " + messageType
-          + " transaction: " + origMsg.getTransactionId());
+      logger.debug("{}: Sending error message header type: {} transaction: {}",
+          serverConnection.getName(), messageType, origMsg.getTransactionId());
-      logger.debug("{}: Sending error message chunk: {}", servConn.getName(), message);
+      logger.debug("{}: Sending error message chunk: {}", serverConnection.getName(), message);
-    chunkedResponseMsg.sendChunk(servConn);
+    chunkedResponseMsg.sendChunk(serverConnection);
-      String message, ServerConnection servConn, Throwable exception) throws IOException {
-    Throwable e = getClientException(servConn, exception);
-    ChunkedMessage functionResponseMsg = servConn.getFunctionResponseMessage();
-    ChunkedMessage chunkedResponseMsg = servConn.getChunkedResponseMessage();
+      ServerConnection serverConnection, Throwable exception) throws IOException {
+    Throwable e = getClientException(serverConnection, exception);
+    ChunkedMessage functionResponseMsg = serverConnection.getFunctionResponseMessage();
+    ChunkedMessage chunkedResponseMsg = serverConnection.getChunkedResponseMessage();
-      functionResponseMsg.setServerConnection(servConn);
+      functionResponseMsg.setServerConnection(serverConnection);
-        logger.debug("{}: Sending exception chunk while reply in progress: {}", servConn.getName(),
-            e.getMessage(), e);
+        logger.debug("{}: Sending exception chunk while reply in progress: {}",
+            serverConnection.getName(), e.getMessage(), e);
-      functionResponseMsg.sendChunk(servConn);
+      functionResponseMsg.sendChunk(serverConnection);
-      chunkedResponseMsg.setServerConnection(servConn);
+      chunkedResponseMsg.setServerConnection(serverConnection);
-        logger.debug("{}: Sending exception chunk: {}", servConn.getName(), e.getMessage(), e);
+        logger.debug("{}: Sending exception chunk: {}", serverConnection.getName(), e.getMessage(),
+            e);
-      chunkedResponseMsg.sendChunk(servConn);
+      chunkedResponseMsg.sendChunk(serverConnection);
-      requestMsg.recv(servConn, MAX_INCOMING_DATA, incomingDataLimiter, incomingMsgLimiter);
+      requestMsg.recv(servConn, MAX_INCOMING_DATA, INCOMING_DATA_LIMITER, INCOMING_MSG_LIMITER);
-      // TODO:Asif: Check if there is any need for explicitly returning
+      // TODO: Check if there is any need for explicitly returning
-      handleInterruptedIOException(null, servConn, e);
+      handleInterruptedIOException(servConn, e);
-  /*
+  /**
+
-        // handleFilter(region, (String)riKey, policy);
-        // break;
-      case InterestType.REGULAR_EXPRESSION: {
+
+      case InterestType.REGULAR_EXPRESSION:
-      }
+
+
-  @SuppressWarnings("rawtypes")
+
+
+
+
-  protected static void sendRegisterInterestResponseChunk(Region region, Object riKey,
-      ArrayList list, boolean lastChunk, ServerConnection servConn) throws IOException {
+  private static void sendRegisterInterestResponseChunk(Region region, Object riKey, List list,
+      boolean lastChunk, ServerConnection servConn) throws IOException {
-    chunkedResponseMsg.addObjPart(list, zipValues);
-    String regionName = (region == null) ? " null " : region.getFullPath();
+    chunkedResponseMsg.addObjPart(list, false);
+    String regionName = region == null ? " null " : region.getFullPath();
-      String str = servConn.getName() + ": Sending" + (lastChunk ? " last " : " ")
-          + "register interest response chunk for region: " + regionName + " for keys: " + riKey
-          + " chunk=<" + chunkedResponseMsg + ">";
-      logger.debug(str);
+      logger.debug(
+          "{}: Sending{}register interest response chunk for region: {} for keys: {} chunk=<{}>",
+          servConn.getName(), lastChunk ? " last " : " ", regionName, riKey, chunkedResponseMsg);
-   * @param servConn
-   * @param policy
-    return (policy == InterestResultPolicy.KEYS_VALUES)
-        && (servConn.getClientVersion().compareTo(Version.GFE_80) >= 0);
+    return policy == InterestResultPolicy.KEYS_VALUES
+        && servConn.getClientVersion().compareTo(Version.GFE_80) >= 0;
-   * @throws IOException
-    ArrayList newKeyList = new ArrayList(maximumChunkSize);
+    List newKeyList = new ArrayList(MAXIMUM_CHUNK_SIZE);
-      for (Iterator it = keyList.iterator(); it.hasNext();) {
-        Object entryKey = it.next();
-        if (region.containsKey(entryKey) || (sendTombstonesInRIResults(servConn, policy)
-            && region.containsTombstone(entryKey))) {
+      for (Object entryKey : keyList) {
+        if (region.containsKey(entryKey)
+            || sendTombstonesInRIResults(servConn, policy) && region.containsTombstone(entryKey)) {
-          appendInterestResponseKey(region, keyList, entryKey, newKeyList, "list", servConn);
+          appendInterestResponseKey(region, keyList, entryKey, newKeyList, servConn);
-  @SuppressWarnings("rawtypes")
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "NP_NULL_PARAM_DEREF",
+  @SuppressWarnings(value = "NP_NULL_PARAM_DEREF",
-    VersionedObjectList values = new VersionedObjectList(maximumChunkSize, true,
-        region == null ? true : region.getAttributes().getConcurrencyChecksEnabled(),
-        serializeValues);
+    VersionedObjectList values = new VersionedObjectList(MAXIMUM_CHUNK_SIZE, true,
+        region == null || region.getAttributes().getConcurrencyChecksEnabled(), serializeValues);
-   * @throws IOException
-    ArrayList keyList = new ArrayList(1);
+    List keyList = new ArrayList(1);
-          || (sendTombstonesInRIResults(servConn, policy) && region.containsTombstone(entryKey))) {
-        appendInterestResponseKey(region, entryKey, entryKey, keyList, "individual", servConn);
+          || sendTombstonesInRIResults(servConn, policy) && region.containsTombstone(entryKey)) {
+        appendInterestResponseKey(region, entryKey, entryKey, keyList, servConn);
-   * @throws IOException
-    ArrayList keyList = new ArrayList(maximumChunkSize);
+    List keyList = new ArrayList(MAXIMUM_CHUNK_SIZE);
-      for (Iterator it = region.keySet(sendTombstonesInRIResults(servConn, policy)).iterator(); it
-          .hasNext();) {
-        appendInterestResponseKey(region, "ALL_KEYS", it.next(), keyList, "ALL_KEYS", servConn);
+      for (Object entryKey : region.keySet(sendTombstonesInRIResults(servConn, policy))) {
+        appendInterestResponseKey(region, "ALL_KEYS", entryKey, keyList, servConn);
-  /**
-   * @param region
-   * @param regex
-   * @param serializeValues
-   * @param servConn
-   * @throws IOException
-   */
-    if (region != null && region instanceof PartitionedRegion) {
+    if (region instanceof PartitionedRegion) {
-    VersionedObjectList values = new VersionedObjectList(maximumChunkSize, true,
-        region == null ? true : region.getAttributes().getConcurrencyChecksEnabled(),
-        serializeValues);
+    VersionedObjectList values = new VersionedObjectList(MAXIMUM_CHUNK_SIZE, true,
+        region == null || region.getAttributes().getConcurrencyChecksEnabled(), serializeValues);
-      VersionTag versionTag = null;
-      Object data = null;
-
-        data = region.get(key, null, true, true, true, id, versionHolder, true);
-        versionTag = versionHolder.getVersionTag();
+        Object data = region.get(key, null, true, true, true, id, versionHolder, true);
+        VersionTag versionTag = versionHolder.getVersionTag();
-        if (values.size() == maximumChunkSize) {
+        if (values.size() == MAXIMUM_CHUNK_SIZE) {
-    int id = 0;
-    HashMap<Integer, HashSet> bucketKeys = null;
-    VersionedObjectList values = new VersionedObjectList(maximumChunkSize, true,
+    VersionedObjectList values = new VersionedObjectList(MAXIMUM_CHUNK_SIZE, true,
-    if (keyInfo != null && keyInfo instanceof List) {
-      bucketKeys = new HashMap<Integer, HashSet>();
+    if (keyInfo instanceof List) {
+      HashMap<Integer, HashSet> bucketKeys = new HashMap<>();
-        id = PartitionedRegionHelper.getHashKey(region, null, key, null, null);
+        int id = PartitionedRegionHelper.getHashKey(region, null, key, null, null);
-          HashSet<Object> keys = new HashSet<Object>();
+          HashSet<Object> keys = new HashSet<>();
-   * 
-   * @param value
-    } else if (value == Token.REMOVED_PHASE1 || value == Token.REMOVED_PHASE2
-        || value == Token.DESTROYED || value == Token.TOMBSTONE) {
+    } else if (isRemovalToken(value)) {
+  private static boolean isRemovalToken(final Object value) {
+    return value == Token.REMOVED_PHASE1 || value == Token.REMOVED_PHASE2
+        || value == Token.DESTROYED || value == Token.TOMBSTONE;
+  }
+
-    for (Iterator it = keySet.iterator(); it.hasNext();) {
-      Object key = it.next();
+    for (Object key : keySet) {
-      if (values.size() == maximumChunkSize) {
+      if (values.size() == MAXIMUM_CHUNK_SIZE) {
-  /**
-   * 
-   * @param region
-   * @param values {@link VersionedObjectList}
-   * @param riKeys
-   * @param set set of entries
-   * @param servConn
-   * @throws IOException
-   */
-      VersionedObjectList values, Object riKeys, Set set, ServerConnection servConn)
+      VersionedObjectList values, Object riKeys, Set<Map.Entry> set, ServerConnection servConn)
-    for (Iterator<Map.Entry> it = set.iterator(); it.hasNext();) {
-      Map.Entry entry = it.next(); // Region.Entry or Map.Entry
+    for (Entry entry : set) {
-        VersionTag vt = null;
-        Object key = null;
-        Object value = null;
+        VersionTag vt;
+        Object key;
+        Object value;
-        ArrayList list = (ArrayList) entry.getValue();
+        List list = (List) entry.getValue();
-      if (values.size() == maximumChunkSize) {
+      if (values.size() == MAXIMUM_CHUNK_SIZE) {
-        // values.setKeys(null); // Now we need to send keys too.
-    chunkedResponseMsg.addObjPart(list, zipValues);
-    String regionName = (region == null) ? " null " : region.getFullPath();
+    chunkedResponseMsg.addObjPart(list, false);
+    String regionName = region == null ? " null " : region.getFullPath();
-      String str = servConn.getName() + ": Sending" + (lastChunk ? " last " : " ")
-          + "register interest response chunk for region: " + regionName + " for keys: " + riKey
-          + " chunk=<" + chunkedResponseMsg + ">";
-      logger.debug(str);
+      logger.debug(
+          "{}: Sending{}register interest response chunk for region: {} for keys: {} chunk=<{}>",
+          servConn.getName(), lastChunk ? " last " : " ", regionName, riKey, chunkedResponseMsg);
-
-   *
-   * @param region the region
-   * @param regex the regex
-   * @param policy the policy
-   * @throws IOException
-    ArrayList keyList = new ArrayList(maximumChunkSize);
+    List keyList = new ArrayList(MAXIMUM_CHUNK_SIZE);
-    Pattern keyPattern = Pattern.compile(regex);
-      for (Iterator it = region.keySet(sendTombstonesInRIResults(servConn, policy)).iterator(); it
-          .hasNext();) {
-        Object entryKey = it.next();
+      Pattern keyPattern = Pattern.compile(regex);
+      for (Object entryKey : region.keySet(sendTombstonesInRIResults(servConn, policy))) {
-        appendInterestResponseKey(region, regex, entryKey, keyList, "regex", servConn);
+        appendInterestResponseKey(region, regex, entryKey, keyList, servConn);
-   *
-   * @param region the region
-   * @param regex the regex
-   * @param policy the policy
-   * @throws IOException
-    final ArrayList keyList = new ArrayList(maximumChunkSize);
+    final List keyList = new ArrayList(MAXIMUM_CHUNK_SIZE);
+          @Override
-            appendInterestResponseKeys(region, regex, theSet, keyList, "regex", servConn);
+            appendInterestResponseKeys(region, regex, theSet, keyList, servConn);
-   *
-   * @param region the region
-   * @param keyList the list of keys
-   * @param policy the policy
-   * @throws IOException
-    final ArrayList newKeyList = new ArrayList(maximumChunkSize);
+    final List newKeyList = new ArrayList(MAXIMUM_CHUNK_SIZE);
+          @Override
-            appendInterestResponseKeys(region, keyList, theSet, newKeyList, "list", servConn);
+            appendInterestResponseKeys(region, keyList, theSet, newKeyList, servConn);
-  @SuppressWarnings("rawtypes")
-    if (region != null && region instanceof PartitionedRegion) {
+    if (region instanceof PartitionedRegion) {
-    VersionedObjectList values = new VersionedObjectList(maximumChunkSize, true,
-        region == null ? true : region.getAttributes().getConcurrencyChecksEnabled(),
-        serializeValues);
+    VersionedObjectList values = new VersionedObjectList(MAXIMUM_CHUNK_SIZE, true,
+        region == null || region.getAttributes().getConcurrencyChecksEnabled(), serializeValues);
-      VersionTag versionTag = null;
-      Object data = null;
-      for (Iterator it = keyList.iterator(); it.hasNext();) {
-        Object key = it.next();
+      for (Object key : keyList) {
-          data = region.get(key, null, true, true, true, id, versionHolder, true);
-          versionTag = versionHolder.getVersionTag();
+          Object data = region.get(key, null, true, true, true, id, versionHolder, true);
+          VersionTag versionTag = versionHolder.getVersionTag();
-          if (values.size() == maximumChunkSize) {
+          if (values.size() == MAXIMUM_CHUNK_SIZE) {
-   * @param kind for debugging
-      ArrayList list, String kind, ServerConnection servConn) throws IOException {
+      List list, ServerConnection servConn) throws IOException {
-    if (list.size() == maximumChunkSize) {
+    if (list.size() == MAXIMUM_CHUNK_SIZE) {
-  protected static void appendInterestResponseKeys(LocalRegion region, Object riKey,
-      Collection entryKeys, ArrayList collector, String riDescr, ServerConnection servConn)
-      throws IOException {
-    for (Iterator it = entryKeys.iterator(); it.hasNext();) {
-      appendInterestResponseKey(region, riKey, it.next(), collector, riDescr, servConn);
+  private static void appendInterestResponseKeys(LocalRegion region, Object riKey,
+      Collection entryKeys, List collector, ServerConnection servConn) throws IOException {
+    for (final Object entryKey : entryKeys) {
+      appendInterestResponseKey(region, riKey, entryKey, collector, servConn);

MOV26 MOV26 MOV28 UPD40 UPD40 INS31 INS31 INS31 UPD83 INS83 MOV43 MOV43 INS83 INS83 INS5 INS42 INS8 INS78 INS83 MOV44 MOV44 MOV44 MOV43 MOV44 MOV44 MOV43 UPD83 INS83 INS29 UPD83 MOV8 INS83 INS83 INS39 INS42 INS44 INS8 INS29 MOV29 MOV83 MOV83 MOV39 MOV42 MOV44 MOV44 MOV44 MOV44 MOV43 MOV8 UPD83 INS8 UPD42 MOV32 UPD42 MOV32 UPD42 MOV32 UPD42 UPD42 INS39 INS85 INS41 INS42 UPD42 UPD42 UPD42 UPD42 INS41 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS25 UPD42 MOV25 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS65 INS43 INS25 INS42 INS60 INS25 MOV21 INS83 MOV43 INS42 INS41 INS70 UPD74 MOV74 INS70 MOV65 UPD43 UPD43 INS70 MOV43 INS42 INS27 MOV27 MOV43 INS27 MOV43 MOV27 MOV43 MOV43 INS27 MOV43 MOV43 MOV43 MOV43 MOV62 MOV8 INS8 MOV43 MOV43 MOV43 MOV43 MOV43 MOV32 MOV43 MOV43 INS66 MOV60 MOV25 INS42 UPD43 MOV27 INS8 MOV43 INS43 MOV59 MOV27 MOV8 UPD43 MOV27 INS62 MOV43 MOV62 MOV27 INS44 INS42 MOV8 MOV43 INS44 INS42 MOV8 INS43 UPD43 UPD43 MOV62 MOV43 UPD42 UPD42 INS44 INS42 INS8 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV27 MOV27 MOV27 MOV32 INS32 UPD42 UPD42 UPD42 UPD42 MOV38 INS32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV60 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS33 UPD42 UPD42 UPD42 UPD42 MOV21 INS21 UPD42 UPD42 UPD42 INS9 INS9 UPD42 UPD42 INS9 INS21 MOV27 MOV27 UPD42 INS70 UPD42 MOV42 UPD42 INS70 MOV42 MOV43 MOV60 INS32 INS43 INS42 INS25 INS43 INS42 MOV25 INS9 INS21 INS42 MOV60 INS70 UPD42 MOV32 UPD42 MOV32 INS70 UPD42 INS83 MOV43 INS42 MOV21 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 MOV32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 MOV32 UPD42 UPD42 UPD42 UPD42 MOV32 MOV32 MOV27 INS32 MOV43 INS42 INS44 INS42 INS8 MOV43 UPD42 INS27 MOV43 INS42 INS44 MOV32 INS8 MOV43 UPD42 INS27 UPD42 INS42 INS42 UPD42 MOV42 INS27 MOV8 INS42 MOV27 INS32 MOV43 INS42 INS44 MOV32 MOV8 MOV43 INS42 MOV43 MOV43 INS42 MOV43 MOV43 UPD42 INS27 INS44 INS42 MOV8 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD45 UPD42 UPD42 UPD42 MOV32 INS25 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS9 UPD42 INS9 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS45 INS32 INS42 MOV32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 MOV42 INS45 MOV32 MOV16 INS42 INS42 INS42 INS43 INS42 MOV25 MOV27 MOV32 MOV27 INS43 INS42 MOV21 MOV27 MOV32 INS60 INS60 INS14 INS60 MOV32 INS42 UPD42 INS42 UPD42 MOV42 INS45 MOV32 MOV16 INS42 INS42 INS42 INS43 INS42 MOV27 MOV32 INS43 INS42 UPD42 MOV42 MOV43 UPD42 UPD42 MOV43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV62 INS38 MOV8 UPD42 UPD42 UPD42 MOV42 MOV42 UPD42 INS42 INS27 INS8 UPD42 MOV42 MOV43 INS59 MOV43 INS59 INS74 INS39 INS59 MOV43 INS43 UPD42 MOV42 INS78 MOV44 MOV43 INS78 MOV44 MOV43 UPD42 MOV42 UPD42 UPD42 INS36 MOV32 INS42 MOV32 MOV42 INS32 INS42 MOV32 INS32 MOV32 MOV32 MOV32 MOV27 INS21 UPD42 UPD42 UPD42 MOV42 INS42 MOV32 INS42 MOV32 UPD42 INS43 INS42 MOV32 INS42 INS42 INS42 INS60 INS60 UPD42 MOV43 MOV27 MOV38 MOV38 INS27 UPD42 MOV42 UPD42 UPD42 UPD42 MOV42 INS42 UPD42 INS42 INS42 UPD42 UPD42 INS32 INS42 INS43 MOV43 INS59 MOV43 INS59 MOV27 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV62 INS62 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 MOV32 UPD42 UPD42 UPD42 MOV27 MOV27 INS42 MOV27 MOV32 MOV42 UPD43 MOV43 UPD74 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 MOV27 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 DEL40 DEL26 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL40 DEL45 DEL27 DEL32 DEL59 DEL23 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL65 DEL42 DEL65 DEL27 DEL9 DEL41 DEL8 DEL25 DEL9 DEL41 DEL42 DEL65 DEL33 DEL36 DEL36 DEL36 DEL83 DEL36 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL27 DEL36 DEL42 DEL42 DEL42 DEL32 DEL36 DEL42 DEL42 DEL42 DEL32 DEL9 DEL36 DEL42 DEL42 DEL42 DEL32 DEL9 DEL36 DEL42 DEL42 DEL42 DEL32 DEL8 DEL62 DEL8 DEL25 DEL25 DEL39 DEL42 DEL44 DEL42 DEL39 DEL42 DEL44 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL9 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL83 DEL83 DEL42 DEL42 DEL39 DEL42 DEL44 DEL32 DEL45 DEL42 DEL45 DEL27 DEL42 DEL43 DEL42 DEL44 DEL33 DEL8 DEL42 DEL45 DEL79 DEL42 DEL36 DEL42 DEL43 DEL42 DEL42 DEL32 DEL45 DEL36 DEL45 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL65 DEL42 DEL65 DEL36 DEL36 DEL42 DEL65 DEL42 DEL43 DEL42 DEL42 DEL45 DEL79 DEL40 DEL9 DEL16 DEL42 DEL65 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL36 DEL45 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL32 DEL24 DEL60 DEL36 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL42 DEL65 DEL42 DEL43 DEL42 DEL42 DEL32 DEL45 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL8 DEL24 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL29 DEL42 DEL33 DEL27 DEL27 DEL9 DEL16 DEL42 DEL33 DEL59 DEL60 DEL42 DEL33 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL33 DEL27 DEL27 DEL33 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL42 DEL7 DEL21 DEL42 DEL43 DEL42 DEL65 DEL42 DEL32 DEL59 DEL60 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL65 DEL42 DEL66 DEL42 DEL65 DEL65 DEL42 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL29 DEL42 DEL43 DEL40 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL33 DEL33 DEL33 DEL25 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL36 DEL42 DEL43 DEL42 DEL42 DEL32 DEL45 DEL36 DEL45 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL45 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL42 DEL43 DEL42 DEL45 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL29 DEL31 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL65 DEL42 DEL43 DEL42 DEL45 DEL42 DEL45 DEL79 DEL42 DEL33 DEL27 DEL27 DEL9 DEL16 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL42 DEL27 DEL42 DEL33 DEL59 DEL60 DEL42 DEL33 DEL59 DEL60 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL8 DEL24 DEL8
Merge branch 'release/1.0.0-incubating.M3'

+import java.util.concurrent.Callable;
+import com.jayway.awaitility.Awaitility;
+import hydra.MethExecutorResult;
+
+import com.gemstone.gemfire.internal.process.ProcessUtils;
-
-import hydra.MethExecutorResult;
+import com.gemstone.gemfire.test.dunit.standalone.StandAloneDUnitEnv;
- *
-  ////////////////////  Constructors  ////////////////////
-
-   * Creates a new <code>VM</code> that runs on a given host with a
-   * given process id.
+   * Returns the {@code VM} identity. For {@link StandAloneDUnitEnv} the number
+   * returned is a zero-based sequence representing the order in with
+   * the DUnit {@code VM}s were launched.
-  public VM(final Host host, final int pid, final RemoteDUnitVMIF client) {
-    this.host = host;
-    this.pid = pid;
-    this.client = client;
-    this.available = true;
-  }
-
-  //////////////////////  Accessors  //////////////////////
-
-  /**
-   * Returns the host on which this <code>VM</code> runs
-   */
-  public Host getHost() {
-    return this.host;
-  }
-
-  /**
-   * Returns the process id of this <code>VM</code>
-   */
-  public int getPid() {
-    return this.pid;
-  }
-
-  /////////////////  Remote Method Invocation  ///////////////
-
-  /**
-   * Invokes a static zero-arg method  with an {@link Object} or
-   * <code>void</code> return type in this VM.  If the return type of
-   * the method is <code>void</code>, <code>null</code> is returned.
-   *
-   * @param targetClass
-   *        The class on which to invoke the method
-   * @param methodName
-   *        The name of the method to invoke
-   *
-   * @throws RMIException
-   *         An exception occurred on while invoking the method in
-   *         this VM
-   * @deprecated Use {@link #invoke(SerializableCallableIF)} instead        
-   */
-  public Object invoke(final Class targetClass, final String methodName) {
-    return invoke(targetClass, methodName, new Object[0]);
-  }
-
-  /**
-   * Asynchronously invokes a static zero-arg method with an {@link
-   * Object} or <code>void</code> return type in this VM.  If the
-   * return type of the method is <code>void</code>, <code>null</code>
-   * is returned.
-   *
-   * @param targetClass
-   *        The class on which to invoke the method
-   * @param methodName
-   *        The name of the method to invoke
-   * @deprecated Use {@link #invoke(SerializableCallableIF)} instead       
-   */
-  public AsyncInvocation invokeAsync(final Class targetClass, final String methodName) {
-    return invokeAsync(targetClass, methodName, null);
-  }
-
-  /**
-   * Invokes a static method with an {@link Object} or
-   * <code>void</code> return type in this VM.  If the return type of
-   * the method is <code>void</code>, <code>null</code> is returned.
-   *
-   * @param targetClass
-   *        The class on which to invoke the method
-   * @param methodName
-   *        The name of the method to invoke
-   * @param args
-   *        Arguments passed to the method call (must be {@link
-   *        java.io.Serializable}). 
-   *
-   * @throws RMIException
-   *         An exception occurred on while invoking the method in
-   *         this VM
-   * @deprecated Use {@link #invoke(SerializableCallableIF)} instead        
-   */
-  public Object invoke(Class targetClass, String methodName, Object[] args) {
-    if (!this.available) {
-      String s = "VM not available: " + this;
-      throw new RMIException(this, targetClass.getName(), methodName,
-            new IllegalStateException(s));
-    }
-    MethExecutorResult result = null;
-    int retryCount = 120;
-    do {
-    try {
-      result = this.client.executeMethodOnClass(targetClass.getName(), methodName, args);
-      break; // out of while loop
-    } catch( RemoteException e ) {
-      boolean isWindows = false;
-      String os = System.getProperty("os.name");
-      if (os != null) {
-        if (os.indexOf("Windows") != -1) {
-          isWindows = true;
-        }
-      }
-      if (isWindows && retryCount-- > 0) {
-        boolean interrupted = Thread.interrupted();
-        try { Thread.sleep(1000); } catch (InterruptedException ignore) {interrupted = true;}
-        finally {
-          if (interrupted) {
-            Thread.currentThread().interrupt();
-          }
-        }
-      } else {
-        throw new RMIException(this, targetClass.getName(), methodName, e );
-      }
-    }
-    } while (true);
-
-    if (!result.exceptionOccurred()) {
-      return result.getResult();
-
-    } else {
-      Throwable thr = result.getException();
-      throw new RMIException(this, targetClass.getName(), methodName, thr,
-                             result.getStackTrace()); 
-    }
-  }
-
-  /**
-   * Asynchronously invokes a static method with an {@link Object} or
-   * <code>void</code> return type in this VM.  If the return type of
-   * the method is <code>void</code>, <code>null</code> is returned.
-   *
-   * @param targetClass
-   *        The class on which to invoke the method
-   * @param methodName
-   *        The name of the method to invoke
-   * @param args
-   *        Arguments passed to the method call (must be {@link
-   *        java.io.Serializable}).
-   * @deprecated Use {@link #invoke(SerializableCallableIF)} instead 
-   */
-  public AsyncInvocation invokeAsync(final Class targetClass, 
-                                     final String methodName,
-                                     final Object[] args) {
-    AsyncInvocation ai =
-      new AsyncInvocation(targetClass, methodName, new Runnable() {
-        public void run() {
-          final Object o = invoke(targetClass, methodName, args);
-          AsyncInvocation.setReturnValue(o);
-        }
-      });
-    ai.start();
-    return ai;
-  }
-
-  /**
-   * Asynchronously invokes an instance method with an {@link Object} or
-   * <code>void</code> return type in this VM.  If the return type of
-   * the method is <code>void</code>, <code>null</code> is returned.
-   *
-   * @param o
-   *        The object on which to invoke the method
-   * @param methodName
-   *        The name of the method to invoke
-   * @param args
-   *        Arguments passed to the method call (must be {@link
-   *        java.io.Serializable}).
-   * @deprecated Use {@link #invoke(SerializableCallableIF)} instead
-   */
-  public AsyncInvocation invokeAsync(final Object o, 
-                                     final String methodName,
-                                     final Object[] args) {
-    AsyncInvocation ai =
-      new AsyncInvocation(o, methodName, new Runnable() {
-        public void run() {
-          final Object ret = invoke(o, methodName, args);
-          AsyncInvocation.setReturnValue(ret);
-        }
-      });
-    ai.start();
-    return ai;
-  }
-
-  /**
-   * Invokes the <code>run</code> method of a {@link Runnable} in this
-   * VM.  Recall that <code>run</code> takes no arguments and has no
-   * return value.
-   *
-   * @param r
-   *        The <code>Runnable</code> to be run
-   *
-   * @see SerializableRunnable
-   */
-  public AsyncInvocation invokeAsync(SerializableRunnableIF r) {
-    return invokeAsync(r, "run", new Object[0]);
-  }
-  
-  /**
-   * Invokes the <code>run</code> method of a {@link Runnable} in this
-   * VM.  Recall that <code>run</code> takes no arguments and has no
-   * return value.  The Runnable is wrapped in a NamedRunnable having
-   * the given name so it shows up in dunit logs.
-   *
-   * @param r
-   *        The <code>Runnable</code> to be run
-   * @param name the name of the runnable, which will be logged in dunit output
-   *
-   * @see SerializableRunnable
-   */
-  public AsyncInvocation invokeAsync(String name, SerializableRunnableIF r) {
-    NamedRunnable nr = new NamedRunnable(name, r);
-    return invokeAsync(nr, "run", new Object[0]);
-  }
-  
-  /**
-   * Invokes the <code>call</code> method of a {@link Runnable} in this
-   * VM.  
-   *
-   * @param c
-   *        The <code>Callable</code> to be run
-   * @param name the name of the callable, which will be logged in dunit output
-   *
-   * @see SerializableCallable
-   */
-  public <T> AsyncInvocation<T> invokeAsync(String name, SerializableCallableIF<T> c) {
-    return invokeAsync(new NamedCallable(name, c), "call", new Object[0]);
-  }
-
-  /**
-   * Invokes the <code>call</code> method of a {@link Runnable} in this
-   * VM.  
-   *
-   * @param c
-   *        The <code>Callable</code> to be run
-   *
-   * @see SerializableCallable
-   */
-  public <T> AsyncInvocation<T> invokeAsync(SerializableCallableIF<T> c) {
-    return invokeAsync(c, "call", new Object[0]);
-  }
-
-  /**
-   * Invokes the <code>run</code> method of a {@link Runnable} in this
-   * VM.  Recall that <code>run</code> takes no arguments and has no
-   * return value.
-   *
-   * @param r
-   *        The <code>Runnable</code> to be run
-   * @param name the name of the runnable, which will be logged in dunit output
-   *
-   * @see SerializableRunnable
-   */
-  public void invoke(String name, SerializableRunnableIF r) {
-    invoke(new NamedRunnable(name, r), "run");
-  }
-
-  /**
-   * Invokes the <code>run</code> method of a {@link Runnable} in this
-   * VM.  Recall that <code>run</code> takes no arguments and has no
-   * return value.
-   *
-   * @param r
-   *        The <code>Runnable</code> to be run
-   *
-   * @see SerializableRunnable
-   */
-  public void invoke(SerializableRunnableIF r) {
-    invoke(r, "run");
-  }
-  
-  /**
-   * Invokes the <code>run</code> method of a {@link Runnable} in this
-   * VM.  Recall that <code>run</code> takes no arguments and has no
-   * return value.
-   *
-   * @param c
-   *        The <code>Callable</code> to be run
-   * @param name the name of the callable, which will be logged in dunit output
-   *
-   * @see SerializableCallable
-   */
-  public <T>  T invoke(String name, SerializableCallableIF<T> c) {
-    return (T) invoke(new NamedCallable(name, c), "call");
-  }
-  
-  /**
-   * Invokes the <code>run</code> method of a {@link Runnable} in this
-   * VM.  Recall that <code>run</code> takes no arguments and has no
-   * return value.
-   *
-   * @param c
-   *        The <code>Callable</code> to be run
-   *
-   * @see SerializableCallable
-   */
-  public <T>  T invoke(SerializableCallableIF<T> c) {
-    return (T) invoke(c, "call");
-  }
-  
-  /**
-   * Invokes the <code>run</code> method of a {@link Runnable} in this
-   * VM.  If the invocation throws AssertionFailedError, and repeatTimeoutMs
-   * is >0, the <code>run</code> method is invoked repeatedly until it
-   * either succeeds, or repeatTimeoutMs has passed.  The AssertionFailedError
-   * is thrown back to the sender of this method if <code>run</code> has not
-   * completed successfully before repeatTimeoutMs has passed.
-   * 
-   * @deprecated Please use {@link com.jayway.awaitility.Awaitility} with {@link #invoke(SerializableCallableIF)} instead.
-   */
-  public void invokeRepeatingIfNecessary(RepeatableRunnable o, long repeatTimeoutMs) {
-    invoke(o, "runRepeatingIfNecessary", new Object[] {new Long(repeatTimeoutMs)});
-  }
-
-  /**
-   * Invokes an instance method with no arguments on an object that is
-   * serialized into this VM.  The return type of the method can be
-   * either {@link Object} or <code>void</code>.  If the return type
-   * of the method is <code>void</code>, <code>null</code> is
-   * returned.
-   *
-   * @param o
-   *        The receiver of the method invocation
-   * @param methodName
-   *        The name of the method to invoke
-   *
-   * @throws RMIException
-   *         An exception occurred on while invoking the method in
-   *         this VM
-   * @deprecated Use {@link #invoke(SerializableCallableIF)} instead        
-   */
-  public Object invoke(Object o, String methodName) {
-    return invoke(o, methodName, new Object[0]);
-  }
-  
-  /**
-   * Invokes an instance method on an object that is serialized into
-   * this VM.  The return type of the method can be either {@link
-   * Object} or <code>void</code>.  If the return type of the method
-   * is <code>void</code>, <code>null</code> is returned.
-   *
-   * @param o
-   *        The receiver of the method invocation
-   * @param methodName
-   *        The name of the method to invoke
-   * @param args
-   *        Arguments passed to the method call (must be {@link
-   *        java.io.Serializable}). 
-   *
-   * @throws RMIException
-   *         An exception occurred on while invoking the method in
-   *         this VM
-   * @deprecated Use {@link #invoke(SerializableCallableIF)} instead        
-   */
-  public Object invoke(Object o, String methodName, Object[] args) {
-    if (!this.available) {
-      String s = "VM not available: " + this;
-      throw new RMIException(this, o.getClass().getName(), methodName,
-            new IllegalStateException(s));
-    }
-    MethExecutorResult result = null;
-    int retryCount = 120;
-    do {
-    try {
-      if ( args == null )
-        result = this.client.executeMethodOnObject(o, methodName);
-      else
-        result = this.client.executeMethodOnObject(o, methodName, args);
-      break; // out of while loop
-    } catch( RemoteException e ) {
-      if (retryCount-- > 0) {
-        boolean interrupted = Thread.interrupted();
-        try { Thread.sleep(1000); } catch (InterruptedException ignore) {interrupted = true;}
-        finally {
-          if (interrupted) {
-            Thread.currentThread().interrupt();
-          }
-        }
-      } else {
-        throw new RMIException(this, o.getClass().getName(), methodName, e );
-      }
-    }
-    } while (true);
-
-    if (!result.exceptionOccurred()) {
-      return result.getResult();
-
-    } else {
-      Throwable thr = result.getException();
-      throw new RMIException(this, o.getClass().getName(), methodName, thr,
-                             result.getStackTrace()); 
-    }
-  }
-
-
-
-
-  /**
-   * Synchronously bounces (mean kills and restarts) this <code>VM</code>.
-   * Concurrent bounce attempts are synchronized but attempts to invoke
-   * methods on a bouncing VM will cause test failure.  Tests using bounce
-   * should be placed at the end of the dunit test suite, since an exception
-   * here will cause all tests using the unsuccessfully bounced VM to fail.
-   * 
-   * This method is currently not supported by the standalone dunit
-   * runner.
-   *
-   * @throws RMIException if an exception occurs while bouncing this VM, for
-   *  example a HydraTimeoutException if the VM fails to stop within 
-   *  hydra.Prms#maxClientShutdownWaitSec or restart within 
-   *  hydra.Prms#maxClientStartupWaitSec.
-   */
-  public synchronized void bounce() {
-    if (!this.available) {
-      String s = "VM not available: " + this;
-      throw new RMIException(this, this.getClass().getName(), "bounceVM",
-            new IllegalStateException(s));
-    }
-    this.available = false;
-    try {
-      BounceResult result = DUnitEnv.get().bounce(this.pid);
-      
-      this.pid = result.getNewPid();
-      this.client = result.getNewClient();
-      this.available = true;
-    } catch (UnsupportedOperationException e) {
-      this.available = true;
-      throw e;
-    } catch (RemoteException e) {
-      StringWriter sw = new StringWriter();
-      e.printStackTrace(new PrintWriter(sw, true));
-      RMIException rmie = new RMIException(this, this.getClass().getName(),
-        "bounceVM", e, sw.toString());
-      throw rmie;
-    }
-  }
-
-  /////////////////////  Utility Methods  ////////////////////
-
-  public String toString() {
-    return "VM " + this.getPid() + " running on " + this.getHost();
-  }
-
-  
-  public File getWorkingDirectory() {
-    return DUnitEnv.get().getWorkingDirectory(this.getPid());
-  }
-  /** Return the total number of VMs on all hosts */
+  /**
+   * Returns the total number of {@code VM}s on all {@code Host}s (note that
+   * DUnit currently only supports one {@code Host}).
+   */
+  /**
+   * Creates a new {@code VM} that runs on a given host with a given process
+   * id.
+   *
+   * TODO: change pid to reflect value from {@link ProcessUtils#identifyPid()}
+   */
+  public VM(final Host host, final int pid, final RemoteDUnitVMIF client) {
+    this.host = host;
+    this.pid = pid;
+    this.client = client;
+    this.available = true;
+  }
+
+  /**
+   * Returns the {@code Host} on which this {@code VM} is running.
+   */
+  public Host getHost() {
+    return this.host;
+  }
+
+  /**
+   * Returns the process id of this {@code VM}.
+   */
+  public int getPid() {
+    return this.pid;
+  }
+
+  /**
+   * Invokes a static zero-arg method  with an {@link Object} or {@code void}
+   * return type in this {@code VM}.  If the return type of the method is
+   * {@code void}, {@code null} is returned.
+   *
+   * @param  targetClass
+   *         The class on which to invoke the method
+   * @param  methodName
+   *         The name of the method to invoke
+   *
+   * @throws RMIException
+   *         Wraps any underlying exception thrown while invoking the method in
+   *         this VM
+   *
+   * @deprecated Please use {@link #invoke(SerializableCallableIF)} instead
+   */
+  public Object invoke(final Class targetClass, final String methodName) {
+    return invoke(targetClass, methodName, new Object[0]);
+  }
+
+  /**
+   * Asynchronously invokes a static zero-arg method with an {@code Object} or
+   * {@code void} return type in this VM.  If the return type of the method is
+   * {@code void}, {@code null} is returned.
+   *
+   * @param  targetClass
+   *         The class on which to invoke the method
+   * @param  methodName
+   *         The name of the method to invoke
+   *
+   * @deprecated Please use {@link #invoke(SerializableCallableIF)} instead
+   */
+  public AsyncInvocation invokeAsync(final Class targetClass, final String methodName) {
+    return invokeAsync(targetClass, methodName, null);
+  }
+
+  /**
+   * Invokes a static method with an {@link Object} or {@code void} return type
+   * in this VM.  If the return type of the method is {@code void},
+   * {@code null} is returned.
+   *
+   * @param  targetClass
+   *         The class on which to invoke the method
+   * @param  methodName
+   *         The name of the method to invoke
+   * @param  args
+   *         Arguments passed to the method call (must be
+   *         {@link java.io.Serializable}).
+   *
+   * @throws RMIException
+   *         Wraps any underlying exception thrown while invoking the method in
+   *         this {@code VM}
+   *
+   * @deprecated Please use {@link #invoke(SerializableCallableIF)} instead
+   */
+  public Object invoke(final Class targetClass, final String methodName, final Object[] args) {
+    if (!this.available) {
+      throw new RMIException(this, targetClass.getName(), methodName, new IllegalStateException("VM not available: " + this));
+    }
+
+    MethExecutorResult result = execute(targetClass, methodName, args);
+
+    if (!result.exceptionOccurred()) {
+      return result.getResult();
+
+    } else {
+      throw new RMIException(this, targetClass.getName(), methodName, result.getException(), result.getStackTrace());
+    }
+  }
+
+  /**
+   * Asynchronously invokes an instance method with an {@link Object} or
+   * {@code void} return type in this {@code VM}.  If the return type of the
+   * method is {@code void}, {@code null} is returned.
+   *
+   * @param  targetObject
+   *         The object on which to invoke the method
+   * @param  methodName
+   *         The name of the method to invoke
+   * @param  args
+   *         Arguments passed to the method call (must be {@link
+   *         java.io.Serializable}).
+   *
+   * @deprecated Please use {@link #invoke(SerializableCallableIF)} instead
+   */
+  public AsyncInvocation invokeAsync(final Object targetObject, final String methodName, final Object[] args) {
+    return new AsyncInvocation(targetObject, methodName, () -> invoke(targetObject, methodName, args)).start();
+  }
+
+  /**
+   * Asynchronously invokes an instance method with an {@link Object} or
+   * {@code void} return type in this {@code VM}.  If the return type of the
+   * method is {@code void}, {@code null} is returned.
+   *
+   * @param  targetClass
+   *         The class on which to invoke the method
+   * @param  methodName
+   *         The name of the method to invoke
+   * @param  args
+   *         Arguments passed to the method call (must be {@link
+   *         java.io.Serializable}).
+   *
+   * @deprecated Please use {@link #invoke(SerializableCallableIF)} instead
+   */
+  public AsyncInvocation invokeAsync(final Class<?> targetClass, final String methodName, final Object[] args) {
+    return new AsyncInvocation(targetClass, methodName, () -> invoke(targetClass, methodName, args)).start();
+  }
+
+  /**
+   * Invokes the {@code run} method of a {@link Runnable} in this VM.  Recall
+   * that {@code run} takes no arguments and has no return value.
+   *
+   * @param  runnable
+   *         The {@code Runnable} to be run
+   *
+   * @see SerializableRunnable
+   */
+  public AsyncInvocation invokeAsync(final SerializableRunnableIF runnable) {
+    return invokeAsync(runnable, "run", new Object[0]);
+  }
+  
+  /**
+   * Invokes the {@code run} method of a {@link Runnable} in this VM.  Recall
+   * that {@code run} takes no arguments and has no return value.  The
+   * {@code Runnable} is wrapped in a {@link NamedRunnable} having the given
+   * name so it shows up in DUnit logs.
+   *
+   * @param  runnable
+   *         The {@code Runnable} to be run
+   * @param  name
+   *         The name of the {@code Runnable}, which will be logged in DUnit
+   *         output
+   *
+   * @see SerializableRunnable
+   */
+  public AsyncInvocation invokeAsync(final String name, final SerializableRunnableIF runnable) {
+    return invokeAsync(new NamedRunnable(name, runnable), "run", new Object[0]);
+  }
+  
+  /**
+   * Invokes the {@code call} method of a {@link Callable} in this {@code VM}.
+   *
+   * @param  callable
+   *         The {@code Callable} to be run
+   * @param  name
+   *         The name of the {@code Callable}, which will be logged in dunit
+   *         output
+   *
+   * @see SerializableCallable
+   */
+  public <T> AsyncInvocation<T> invokeAsync(final String name, final SerializableCallableIF<T> callable) {
+    return invokeAsync(new NamedCallable(name, callable), "call", new Object[0]);
+  }
+
+  /**
+   * Invokes the {@code call} method of a {@link Callable} in this {@code VM}.
+   *
+   * @param  callable
+   *         The {@code Callable} to be run
+   *
+   * @see SerializableCallable
+   */
+  public <T> AsyncInvocation<T> invokeAsync(final SerializableCallableIF<T> callable) {
+    return invokeAsync(callable, "call", new Object[0]);
+  }
+
+  /**
+   * Invokes the {@code run} method of a {@link Runnable} in this {@code VM}.
+   * Recall that {@code run} takes no arguments and has no return value.
+   *
+   * @param  runnable
+   *         The {@code Runnable} to be run
+   * @param  name
+   *         The name of the {@code Runnable}, which will be logged in DUnit
+   *         output
+   *
+   * @see SerializableRunnable
+   */
+  public void invoke(final String name, final SerializableRunnableIF runnable) {
+    invoke(new NamedRunnable(name, runnable), "run");
+  }
+
+  /**
+   * Invokes the {@code run} method of a {@link Runnable} in this {@code VM}.
+   * Recall that {@code run} takes no arguments and has no return value.
+   *
+   * @param  runnable
+   *         The {@code Runnable} to be run
+   *
+   * @see SerializableRunnable
+   */
+  public void invoke(final SerializableRunnableIF runnable) {
+    invoke(runnable, "run");
+  }
+  
+  /**
+   * Invokes the {@code call} method of a {@link Callable} in this {@code VM}.
+   *
+   * @param  callable
+   *         The {@code Callable} to be run
+   * @param  name
+   *         The name of the {@code Callable}, which will be logged in DUnit
+   *         output
+   *
+   * @see SerializableCallable
+   */
+  public <T>  T invoke(final String name, final SerializableCallableIF<T> callable) {
+    return (T) invoke(new NamedCallable(name, callable), "call");
+  }
+  
+  /**
+   * Invokes the {@code call} method of a {@link Callable} in this {@code VM}.
+   *
+   * @param  callable
+   *         The {@code Callable} to be run
+   *
+   * @see SerializableCallable
+   */
+  public <T>  T invoke(final SerializableCallableIF<T> callable) {
+    return (T) invoke(callable, "call");
+  }
+  
+  /**
+   * Invokes the {@code run} method of a {@link Runnable} in this {@code VM}.
+   * If the invocation throws AssertionError, and repeatTimeoutMs
+   * is >0, the {@code run} method is invoked repeatedly until it
+   * either succeeds, or repeatTimeoutMs has passed.  The AssertionError
+   * is thrown back to the sender of this method if {@code run} has not
+   * completed successfully before repeatTimeoutMs has passed.
+   * 
+   * @deprecated Please use {@link Awaitility} to await condition and then {@link #invoke(SerializableCallableIF)} instead.
+   */
+  public void invokeRepeatingIfNecessary(final RepeatableRunnable runnable, final long repeatTimeoutMs) {
+    invoke(runnable, "runRepeatingIfNecessary", new Object[] { repeatTimeoutMs });
+  }
+
+  /**
+   * Invokes an instance method with no arguments on an object that is
+   * serialized into this {@code VM}.  The return type of the method can be
+   * either {@link Object} or {@code void}.  If the return type of the method
+   * is {@code void}, {@code null} is returned.
+   *
+   * @param  targetObject
+   *         The receiver of the method invocation
+   * @param  methodName
+   *         The name of the method to invoke
+   *
+   * @throws RMIException
+   *         Wraps any underlying exception thrown while invoking the method in
+   *         this {@code VM}
+   *
+   * @deprecated Please use {@link #invoke(SerializableCallableIF)} instead.
+   */
+  public Object invoke(final Object targetObject, final String methodName) {
+    return invoke(targetObject, methodName, new Object[0]);
+  }
+  
+  /**
+   * Invokes an instance method on an object that is serialized into this
+   * {@code VM}.  The return type of the method can be either {@link Object} or
+   * {@code void}.  If the return type of the method is {@code void},
+   * {@code null} is returned.
+   *
+   * @param  targetObject
+   *         The receiver of the method invocation
+   * @param  methodName
+   *         The name of the method to invoke
+   * @param  args
+   *         Arguments passed to the method call (must be {@link
+   *         java.io.Serializable}).
+   *
+   * @throws RMIException
+   *         Wraps any underlying exception thrown while invoking the method in
+   *         this {@code VM}
+   *
+   * @deprecated Please use {@link #invoke(SerializableCallableIF)} instead.
+   */
+  public Object invoke(final Object targetObject, final String methodName, final Object[] args) {
+    if (!this.available) {
+      throw new RMIException(this, targetObject.getClass().getName(), methodName, new IllegalStateException("VM not available: " + this));
+    }
+
+    MethExecutorResult result = execute(targetObject, methodName, args);
+
+    if (!result.exceptionOccurred()) {
+      return result.getResult();
+
+    } else {
+      throw new RMIException(this, targetObject.getClass().getName(), methodName, result.getException(), result.getStackTrace());
+    }
+  }
+
+  /**
+   * Synchronously bounces (mean kills and restarts) this {@code VM}.
+   * Concurrent bounce attempts are synchronized but attempts to invoke methods
+   * on a bouncing {@code VM} will cause test failure.  Tests using bounce
+   * should be placed at the end of the DUnit test suite, since an exception
+   * here will cause all tests using the unsuccessfully bounced {@code VM} to
+   * fail.
+   * 
+   * This method is currently not supported by the standalone DUnit runner.
+   *
+   * @throws RMIException if an exception occurs while bouncing this
+   *         {@code VM}, for example a {@code HydraTimeoutException} if the
+   *         {@code VM} fails to stop within
+   *         {@code hydra.Prms#maxClientShutdownWaitSec} or restart within
+   *         {@code hydra.Prms#maxClientStartupWaitSec}.
+   */
+  public synchronized void bounce() {
+    if (!this.available) {
+      throw new RMIException(this, getClass().getName(), "bounceVM", new IllegalStateException("VM not available: " + this));
+    }
+
+    this.available = false;
+
+    try {
+      BounceResult result = DUnitEnv.get().bounce(this.pid);
+      this.pid = result.getNewPid();
+      this.client = result.getNewClient();
+      this.available = true;
+
+    } catch (UnsupportedOperationException e) {
+      this.available = true;
+      throw e;
+
+    } catch (RemoteException e) {
+      StringWriter sw = new StringWriter();
+      e.printStackTrace(new PrintWriter(sw, true));
+      RMIException rmie = new RMIException(this, getClass().getName(), "bounceVM", e, sw.toString());
+      throw rmie;
+    }
+  }
+
+  public String toString() {
+    return "VM " + getPid() + " running on " + getHost();
+  }
+
+  public File getWorkingDirectory() {
+    return DUnitEnv.get().getWorkingDirectory(getPid());
+  }
+
+  private MethExecutorResult execute(final Class targetClass, final String methodName, final Object[] args) {
+    try {
+      return this.client.executeMethodOnClass(targetClass.getName(), methodName, args);
+    } catch (RemoteException exception) {
+      throw new RMIException(this, targetClass.getName(), methodName, exception);
+    }
+  }
+
+  private MethExecutorResult execute(final Object targetObject, final String methodName, final Object[] args) {
+    try {
+      if (args == null) {
+        return this.client.executeMethodOnObject(targetObject, methodName);
+      } else {
+        return this.client.executeMethodOnObject(targetObject, methodName, args);
+      }
+    } catch (RemoteException exception) {
+      throw new RMIException(this, targetObject.getClass().getName(), methodName, exception);
+    }
+  }

MOV26 INS26 INS26 INS26 INS26 MOV31 INS40 INS40 INS40 INS40 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS83 INS39 INS42 MOV8 MOV29 INS83 MOV43 INS42 MOV44 MOV44 MOV8 MOV29 MOV83 MOV43 MOV42 MOV44 INS44 MOV44 MOV8 MOV43 INS44 MOV44 MOV44 INS8 MOV43 INS44 MOV44 MOV44 INS8 MOV44 MOV44 MOV44 MOV73 MOV43 MOV44 MOV44 MOV73 MOV43 MOV44 MOV43 INS44 MOV29 MOV83 MOV43 MOV42 MOV44 MOV44 MOV44 INS8 INS83 MOV43 INS42 INS8 INS83 INS43 INS42 INS44 INS44 INS44 INS8 INS83 INS43 INS42 MOV44 INS44 INS44 INS8 INS65 INS65 INS65 INS83 MOV43 MOV42 INS83 INS60 INS65 INS83 MOV43 INS42 INS41 INS65 MOV65 INS83 INS74 INS42 INS41 INS83 UPD42 INS83 INS83 UPD42 INS83 INS83 UPD42 INS83 UPD42 INS83 INS83 UPD42 INS83 UPD42 INS83 UPD42 INS83 UPD42 INS83 UPD42 INS83 UPD42 INS83 MOV65 MOV65 INS83 MOV43 INS42 INS83 UPD43 UPD42 MOV65 MOV65 UPD42 INS83 INS83 MOV25 MOV60 MOV25 INS41 UPD42 MOV42 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS5 INS42 INS54 INS42 INS83 UPD42 INS83 INS43 INS42 INS83 INS5 INS42 INS54 INS66 INS65 INS66 INS65 INS66 INS66 INS66 INS65 INS66 UPD66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 UPD66 UPD66 INS66 INS65 INS66 INS65 UPD66 INS65 INS66 UPD66 INS65 INS66 UPD66 MOV66 MOV65 UPD66 MOV66 INS65 UPD66 MOV66 INS65 UPD66 MOV66 INS65 UPD66 MOV66 INS65 INS66 UPD66 UPD66 UPD66 INS65 INS66 INS65 UPD66 INS65 INS66 INS65 UPD66 UPD66 UPD66 UPD66 MOV65 INS66 UPD65 UPD66 UPD66 INS65 INS66 INS65 UPD66 INS42 INS66 MOV65 INS66 UPD66 UPD66 INS65 UPD66 UPD66 MOV8 MOV43 INS59 UPD66 INS65 INS66 INS65 UPD66 INS66 INS65 INS66 INS65 UPD66 INS42 INS66 UPD66 UPD66 INS32 MOV66 MOV65 MOV66 INS65 INS66 INS65 UPD66 MOV66 UPD66 MOV66 INS65 INS66 INS65 INS66 UPD66 MOV43 INS76 INS32 UPD66 INS65 INS66 UPD66 UPD66 INS65 UPD66 UPD42 INS66 INS65 UPD66 UPD66 INS65 INS66 UPD66 INS66 INS65 UPD66 INS65 UPD66 INS65 INS66 UPD66 UPD42 INS66 INS65 UPD66 INS66 INS65 UPD66 INS66 UPD66 INS65 INS66 UPD66 INS65 INS66 UPD42 INS66 INS65 UPD66 INS66 INS65 UPD66 INS66 UPD66 INS65 INS66 UPD66 INS65 INS66 UPD42 INS66 INS65 UPD66 UPD66 UPD65 INS66 MOV65 UPD66 INS65 INS66 UPD66 INS65 UPD66 UPD42 INS66 INS65 UPD66 INS66 INS65 UPD66 INS66 UPD66 INS65 INS66 MOV65 UPD66 INS65 INS66 UPD66 INS65 UPD66 UPD42 INS66 INS65 UPD66 UPD66 INS65 INS66 INS65 UPD66 INS65 UPD66 UPD42 INS66 INS65 UPD66 INS66 INS65 UPD66 INS66 UPD66 INS65 INS66 UPD66 INS65 UPD66 UPD42 INS66 INS65 UPD66 UPD66 INS65 INS66 UPD66 INS65 INS66 UPD66 INS66 INS65 UPD66 UPD66 UPD66 INS65 INS66 UPD66 INS66 INS65 UPD66 MOV65 INS66 INS65 UPD66 INS66 INS65 INS66 INS65 UPD66 UPD42 UPD66 UPD66 INS65 UPD66 UPD66 UPD42 UPD66 INS65 UPD66 MOV65 INS66 INS65 UPD66 INS65 INS66 INS65 UPD66 UPD42 UPD66 UPD66 UPD66 INS65 UPD66 UPD66 UPD66 INS65 INS66 UPD66 INS66 INS65 UPD66 UPD66 UPD66 INS65 INS66 INS66 UPD66 UPD66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS27 INS42 INS42 INS43 INS85 MOV8 MOV12 INS42 INS43 INS85 MOV8 INS12 INS66 INS42 INS66 INS66 INS66 INS66 INS66 INS68 INS66 INS66 INS66 INS66 INS66 UPD66 MOV66 INS66 INS66 INS66 UPD66 MOV66 INS66 INS66 INS66 INS66 INS66 MOV42 INS32 INS66 INS66 INS66 INS66 INS14 MOV42 INS66 INS66 UPD66 MOV66 INS66 INS14 UPD42 MOV42 INS66 INS66 INS66 UPD42 INS66 INS66 INS66 INS42 INS66 INS66 MOV14 INS66 UPD42 UPD66 MOV66 INS66 INS66 INS66 UPD42 UPD66 MOV66 INS66 UPD42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD42 INS66 INS42 UPD66 MOV66 INS66 INS66 MOV43 INS66 UPD42 UPD66 MOV66 INS66 MOV43 INS66 INS66 INS66 INS66 INS42 UPD42 INS66 INS66 UPD66 MOV66 INS66 INS66 UPD42 INS66 INS66 INS66 INS66 INS66 INS32 INS66 INS66 UPD66 MOV66 INS66 UPD66 MOV66 INS66 UPD66 MOV66 UPD66 MOV66 INS45 INS32 INS45 INS32 INS42 INS41 INS42 INS44 INS8 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 MOV43 UPD42 MOV42 MOV42 INS86 MOV43 INS42 INS42 INS86 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 UPD43 UPD42 INS53 INS8 INS8 INS43 INS42 MOV53 MOV14 MOV32 INS32 MOV32 UPD42 INS42 MOV43 MOV32 UPD42 INS14 INS41 INS41 INS42 MOV27 INS42 INS42 UPD42 MOV42 UPD42 MOV42 MOV27 MOV27 MOV43 INS52 MOV32 INS42 INS42 MOV32 MOV32 MOV43 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 DEL65 DEL42 DEL65 DEL31 DEL42 DEL42 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL52 DEL42 DEL14 DEL53 DEL8 DEL33 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL45 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL45 DEL32 DEL34 DEL38 DEL27 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL37 DEL34 DEL27 DEL27 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL34 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL9 DEL7 DEL21 DEL8 DEL12 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL25 DEL8 DEL12 DEL54 DEL8 DEL9 DEL19 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL83 DEL42 DEL42 DEL44 DEL44 DEL31 DEL42 DEL42 DEL43 DEL83 DEL39 DEL42 DEL83 DEL42 DEL59 DEL60 DEL42 DEL32 DEL21 DEL8 DEL31 DEL1 DEL14 DEL14 DEL59 DEL60 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL65 DEL42 DEL65 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL43 DEL83 DEL39 DEL42 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL1 DEL14 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL43 DEL42 DEL44 DEL40 DEL42 DEL43 DEL42 DEL14 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL33 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL39 DEL42 DEL34 DEL59 DEL60 DEL43 DEL42 DEL44 DEL42 DEL37 DEL34 DEL27 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL34 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL8 DEL25 DEL8 DEL12 DEL54 DEL8 DEL9 DEL19 DEL8 DEL31 DEL42 DEL43 DEL42 DEL59 DEL60 DEL52 DEL42 DEL52 DEL83 DEL42 DEL45 DEL52 DEL42 DEL32 DEL45 DEL52 DEL42 DEL32 DEL27 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL31 DEL52 DEL42 DEL7 DEL21 DEL10 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL10
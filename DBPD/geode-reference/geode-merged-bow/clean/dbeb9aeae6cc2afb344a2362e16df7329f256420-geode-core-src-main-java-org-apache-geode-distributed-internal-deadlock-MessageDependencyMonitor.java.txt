Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class keeps track of the information we need
- * to determine which threads in the receiver system a reply
- * processor thread is waiting for.
+ * This class keeps track of the information we need to determine which threads in the receiver
+ * system a reply processor thread is waiting for.
-  private final UnsafeThreadLocal<ReplyProcessor21> waitingProcessors = new UnsafeThreadLocal<ReplyProcessor21>();
-  private final UnsafeThreadLocal<MessageWithReply> processingMessages= new UnsafeThreadLocal<MessageWithReply>();
-  
+  private final UnsafeThreadLocal<ReplyProcessor21> waitingProcessors =
+      new UnsafeThreadLocal<ReplyProcessor21>();
+  private final UnsafeThreadLocal<MessageWithReply> processingMessages =
+      new UnsafeThreadLocal<MessageWithReply>();
+
-  
+
-  
+
-  
+
-  
+
-    if(message instanceof MessageWithReply) {
+    if (message instanceof MessageWithReply) {
-  
+
-    if(message instanceof MessageWithReply) {
+    if (message instanceof MessageWithReply) {
-    
+
-    if(system == null) {
+    if (system == null) {
-    
-    Set<Dependency<Thread, Serializable>> blockedThreads = new HashSet<Dependency<Thread, Serializable>>();
-    for(Thread thread : allThreads) {
+
+    Set<Dependency<Thread, Serializable>> blockedThreads =
+        new HashSet<Dependency<Thread, Serializable>>();
+    for (Thread thread : allThreads) {
-      if(processor != null && processor.getProcessorId() > 0) {
-        blockedThreads.add(new Dependency<Thread, Serializable>(thread, new MessageKey(myId, processor.getProcessorId())));
+      if (processor != null && processor.getProcessorId() > 0) {
+        blockedThreads.add(new Dependency<Thread, Serializable>(thread,
+            new MessageKey(myId, processor.getProcessorId())));
-    Set<Dependency<Serializable, Thread>> heldResources = new HashSet<Dependency<Serializable, Thread>>();
-    
-    for(Thread thread : allThreads) {
+    Set<Dependency<Serializable, Thread>> heldResources =
+        new HashSet<Dependency<Serializable, Thread>>();
+
+    for (Thread thread : allThreads) {
-      if(message != null && message.getProcessorId() > 0) {
-        heldResources.add(new Dependency<Serializable, Thread>(new MessageKey(message.getSender(), message.getProcessorId()), thread));
+      if (message != null && message.getProcessorId() > 0) {
+        heldResources.add(new Dependency<Serializable, Thread>(
+            new MessageKey(message.getSender(), message.getProcessorId()), thread));
-  
+
-    
+
-    
+
-    
+
-      return "MessageFrom(" + myId + ", " + processorId + ")"; 
+      return "MessageFrom(" + myId + ", " + processorId + ")";

UPD66 UPD66 DEL66
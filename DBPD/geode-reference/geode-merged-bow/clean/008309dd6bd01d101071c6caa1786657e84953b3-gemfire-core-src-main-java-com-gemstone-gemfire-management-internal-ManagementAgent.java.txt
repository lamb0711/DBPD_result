Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2010-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * one or more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
-import java.io.File;
- * Agent implementation that controls the JMX server end points for JMX 
- * clients to connect, such as an RMI server.
+ * Agent implementation that controls the JMX server end points for JMX clients
+ * to connect, such as an RMI server.
- * MBeans hosted within it. 
+ * MBeans hosted within it.
-public class ManagementAgent  {
+public class ManagementAgent {
-  
+
-   * synchronize while configuring, starting, and eventually stopping the
-   * RMI server, the hidden management regions (in FederatingManager), etc
+   * synchronize while configuring, starting, and eventually stopping the RMI
+   * server, the hidden management regions (in FederatingManager), etc
-   * This system property is set to true when the embedded HTTP server is started so that the embedded pulse webapp
-   * can use a local MBeanServer instead of a remote JMX connection.
+   * This system property is set to true when the embedded HTTP server is
+   * started so that the embedded pulse webapp can use a local MBeanServer
+   * instead of a remote JMX connection.
-  
+
-  
+
-  
-  private boolean isAPIRestServiceRunning(GemFireCacheImpl cache){
+
+  private boolean isAPIRestServiceRunning(GemFireCacheImpl cache) {
-  
-  private boolean isServerNode(GemFireCacheImpl cache){
+
+  private boolean isServerNode(GemFireCacheImpl cache) {
-         && cache.getDistributedSystem().getDistributedMember().getVmKind() != DistributionManager.ADMIN_ONLY_DM_TYPE
-         && !cache.isClient());
+        && cache.getDistributedSystem().getDistributedMember().getVmKind() != DistributionManager.ADMIN_ONLY_DM_TYPE && !cache
+          .isClient());
-  
-  public synchronized void startAgent(GemFireCacheImpl cache){
-    //Do not start Management REST service if developer REST service is already started.
-    
-    if(!isAPIRestServiceRunning(cache)) {
+
+  public synchronized void startAgent(GemFireCacheImpl cache) {
+    // Do not start Management REST service if developer REST service is already
+    // started.
+
+    if (!isAPIRestServiceRunning(cache)) {
-    }else {
+    } else {
-        logger.debug("Developer REST APIs webapp is already running, Not Starting M&M REST and pulse!");
+        logger
+            .debug("Developer REST APIs webapp is already running, Not Starting M&M REST and pulse!");
-    
+
-      }
-      catch (IOException e) {
+      } catch (IOException e) {
-  
-  public synchronized void stopAgent(){
+
+  public synchronized void stopAgent() {
-    
-    if (!this.running) return;
-    
+
+    if (!this.running)
+      return;
+
-    
+
-  
+
-  
+  private AgentUtil agentUtil = new AgentUtil(GEMFIRE_VERSION);
+
-    final SystemManagementService managementService = (SystemManagementService) ManagementService.getManagementService(
-      CacheFactory.getAnyInstance());
+    final SystemManagementService managementService = (SystemManagementService) ManagementService
+        .getManagementService(CacheFactory.getAnyInstance());
-    
+
-      // GEMFIRE environment variable
-      final String gemfireHome = System.getenv("GEMFIRE");
-
-      // Check for empty variable. if empty, then log message and exit HTTP server startup
-      if (StringUtils.isBlank(gemfireHome)) {
+      // Check for empty variable. if empty, then log message and exit HTTP
+      // server startup
+      if (!agentUtil.isGemfireHomeDefined()) {
-      final String gemfireWar = getGemFireWarLocation(gemfireHome);
-
+      final String gemfireWar = agentUtil.getGemFireWebWarLocation();
-          logger.debug("Unable to find GemFire REST API WAR file; the REST API to GemFire will not be exported and accessible.");
+          logger.debug("Unable to find GemFire Management REST API WAR file; the Management REST Interface for GemFire will not be accessible.");
-      final String pulseWar = getPulseWarLocation(gemfireHome);
+      final String pulseWar = agentUtil.getPulseWarLocation();
-        final String message = "Unable to find Pulse web application WAR file; Pulse will not start in embeded mode";
+        final String message = "Unable to find Pulse web application WAR file; Pulse for GemFire will not be accessible";
-      
-      //Find developer REST WAR file
-      final String gemfireAPIWar =  getGemFireAPIWarLocation(gemfireHome);
+
+      // Find developer REST WAR file
+      final String gemfireAPIWar = agentUtil.getGemFireWebApiWarLocation();
-        final String message = "Unable to find developer REST web application WAR file; developer REST will not start in embeded mode";
+        final String message = "Unable to find GemFire Developer REST API WAR file; the Developer REST Interface for GemFire will not be accessible.";
-      
+
-        if (isWebApplicationAvailable(gemfireWar, pulseWar, gemfireAPIWar)) {
-          
+        if (agentUtil.isWebApplicationAvailable(gemfireWar, pulseWar, gemfireAPIWar)) {
+
-          
-          this.httpServer = JettyHelper.initJetty(bindAddress, port, 
+
+          this.httpServer = JettyHelper.initJetty(bindAddress, port,
-              this.config.getHttpServiceSSLRequireAuthentication(), 
-              this.config.getHttpServiceSSLProtocols(),
-              this.config.getHttpServiceSSLCiphers(), 
+              this.config.getHttpServiceSSLRequireAuthentication(),
+              this.config.getHttpServiceSSLProtocols(), this.config.getHttpServiceSSLCiphers(),
-          if (isWebApplicationAvailable(gemfireWar)) {
-            this.httpServer = JettyHelper.addWebApplication(this.httpServer, "/gemfire", gemfireWar);
+          if (agentUtil.isWebApplicationAvailable(gemfireWar)) {
+            this.httpServer = JettyHelper
+                .addWebApplication(this.httpServer, "/gemfire", gemfireWar);
-          if (isWebApplicationAvailable(pulseWar)) {
+          if (agentUtil.isWebApplicationAvailable(pulseWar)) {
-         
-          if(isServer && this.config.getStartDevRestApi()) {
-            if (isWebApplicationAvailable(gemfireAPIWar) ) {
-              this.httpServer = JettyHelper.addWebApplication(this.httpServer, "/gemfire-api", gemfireAPIWar);
+
+          if (isServer && this.config.getStartDevRestApi()) {
+            if (agentUtil.isWebApplicationAvailable(gemfireAPIWar)) {
+              this.httpServer = JettyHelper.addWebApplication(this.httpServer, "/gemfire-api",
+                  gemfireAPIWar);
-          }else {
-            final String message = "developer REST web application will not start when start-dev-rest-api is not set and node is not server";
+          } else {
+            final String message = "Developer REST API web application will not start when start-dev-rest-api is not set and node is not server";
-          
+
-                ((ServerConnector)this.httpServer.getConnectors()[0]).getPort(), bindAddress);
+                ((ServerConnector) this.httpServer.getConnectors()[0]).getPort(), bindAddress);
-          // now, that Tomcat has been started, we can set the URL used by web clients to connect to Pulse
-          if (isWebApplicationAvailable(pulseWar)) {
-            managerBean.setPulseURL("http://".concat(getHost(bindAddress)).concat(":").concat(String.valueOf(port))
-              .concat("/pulse/"));
+          // now, that Tomcat has been started, we can set the URL used by web
+          // clients to connect to Pulse
+          if (agentUtil.isWebApplicationAvailable(pulseWar)) {
+            managerBean.setPulseURL("http://".concat(getHost(bindAddress)).concat(":")
+                .concat(String.valueOf(port)).concat("/pulse/"));
-          
-          //set cache property for developer REST service running
-          if(isRestWebAppAdded) {
-            GemFireCacheImpl cache = (GemFireCacheImpl)CacheFactory.getAnyInstance();
+
+          // set cache property for developer REST service running
+          if (isRestWebAppAdded) {
+            GemFireCacheImpl cache = (GemFireCacheImpl) CacheFactory.getAnyInstance();
-            
-            //create region to hold query information (queryId, queryString). Added for the developer REST APIs
+
+            // create region to hold query information (queryId, queryString).
+            // Added for the developer REST APIs
-          
-          //set true for HTTP service running
+
+          // set true for HTTP service running
-      }
-      catch (Exception e) {
-        stopHttpService();//Jetty needs to be stopped even if it has failed to start. Some of the threads are left behind even if server.start() fails due to an exception
-        setStatusMessage(managerBean, "HTTP service failed to start with " + e.getClass().getSimpleName() + " '" + e.getMessage() + "'");
+      } catch (Exception e) {
+        stopHttpService();// Jetty needs to be stopped even if it has failed to
+                          // start. Some of the threads are left behind even if
+                          // server.start() fails due to an exception
+        setStatusMessage(managerBean, "HTTP service failed to start with "
+            + e.getClass().getSimpleName() + " '" + e.getMessage() + "'");
-    }
-    else {
-      setStatusMessage(managerBean, "Embedded HTTP server configured not to start (http-service-port=0) or (jmx-manager-http-port=0)");
+    } else {
+      setStatusMessage(managerBean,
+          "Embedded HTTP server configured not to start (http-service-port=0) or (jmx-manager-http-port=0)");
-  
+
-    }
-    else if (!StringUtils.isBlank(bindAddress)) {
+    } else if (!StringUtils.isBlank(bindAddress)) {
-    }
-    else {
+    } else {
-  // Use the GEMFIRE environment variable to find the GemFire product tree.
-  // First, look in the $GEMFIRE/tools/Management directory
-  // Second, look in the $GEMFIRE/lib directory
-  // Finally, if we cannot find Management WAR file then return null...
-  private String getGemFireWarLocation(final String gemfireHome) {
-    assert !StringUtils.isBlank(gemfireHome) : "The GEMFIRE environment variable must be set!";
-
-    if (new File(gemfireHome + "/tools/Extensions/gemfire-web-" + GEMFIRE_VERSION + ".war").isFile()) {
-      return gemfireHome + "/tools/Extensions/gemfire-web-" + GEMFIRE_VERSION + ".war";
-    }
-    else if (new File(gemfireHome + "/lib/gemfire-web-" + GEMFIRE_VERSION + ".war").isFile()) {
-      return gemfireHome + "/lib/gemfire-web-" + GEMFIRE_VERSION + ".war";
-    }
-    else {
-      return null;
-    }
-  }
-
-  // Use the GEMFIRE environment variable to find the GemFire product tree.
-  // First, look in the $GEMFIRE/tools/Pulse directory
-  // Second, look in the $GEMFIRE/lib directory
-  // Finally, if we cannot find the Management WAR file then return null...
-  private String getPulseWarLocation(final String gemfireHome) {
-    assert !StringUtils.isBlank(gemfireHome) : "The GEMFIRE environment variable must be set!";
-
-    if (new File(gemfireHome + "/tools/Pulse/pulse.war").isFile()) {
-      return gemfireHome + "/tools/Pulse/pulse.war";
-    }
-    else if (new File(gemfireHome + "/lib/pulse.war").isFile()) {
-      return gemfireHome + "/lib/pulse.war";
-    }
-    else {
-      return null;
-    }
-  }
-
-  private String getGemFireAPIWarLocation(final String gemfireHome) {
-    assert !StringUtils.isBlank(gemfireHome) : "The GEMFIRE environment variable must be set!";
-    if (new File(gemfireHome + "/tools/Extensions/gemfire-api" + GEMFIRE_VERSION + ".war").isFile()) {
-      return gemfireHome + "/tools/Extensions/gemfire-api" + GEMFIRE_VERSION + ".war";
-    }
-    else if (new File(gemfireHome + "/lib/gemfire-api" + GEMFIRE_VERSION + ".war").isFile()) {
-      return gemfireHome + "/lib/gemfire-api" + GEMFIRE_VERSION + ".war";
-    }
-    else {
-      return null;
-    }
-  }
-
-  private boolean isWebApplicationAvailable(final String warFileLocation) {
-    return !StringUtils.isBlank(warFileLocation);
-  }
-
-  private boolean isWebApplicationAvailable(final String... warFileLocations) {
-    for (String warFileLocation : warFileLocations) {
-      if (isWebApplicationAvailable(warFileLocation)) {
-        return true;
-      }
-    }
-
-    return false;
-  }
-
-          logger.error("Failed to properly release resources held by the HTTP service: {}", ignore.getMessage(), ignore);
+          logger.error("Failed to properly release resources held by the HTTP service: {}",
+              ignore.getMessage(), ignore);
-   * http://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html#gdfvq
-   * https://blogs.oracle.com/jmxetc/entry/java_5_premain_rmi_connectors
-   * https://blogs.oracle.com/jmxetc/entry/building_a_remotely_stoppable_connector
-   * https://blogs.oracle.com/jmxetc/entry/jmx_connecting_through_firewalls_using
+   * http://docs.oracle.com/javase/6/docs/technotes/guides/management/agent.html
+   * #gdfvq https://blogs.oracle.com/jmxetc/entry/java_5_premain_rmi_connectors
+   * https
+   * ://blogs.oracle.com/jmxetc/entry/building_a_remotely_stoppable_connector
+   * https
+   * ://blogs.oracle.com/jmxetc/entry/jmx_connecting_through_firewalls_using
-    // KIRK: I copied this from https://blogs.oracle.com/jmxetc/entry/java_5_premain_rmi_connectors
-    //       we'll need to change this significantly but it's a starting point
-    
+    // KIRK: I copied this from
+    // https://blogs.oracle.com/jmxetc/entry/java_5_premain_rmi_connectors
+    // we'll need to change this significantly but it's a starting point
+
-    
+
-      logger.debug("Starting jmx manager agent on port {}{}", port, (bindAddr != null ? (" bound to " + bindAddr) : "") + (ssl ? " using SSL" : ""));
+      logger.debug("Starting jmx manager agent on port {}{}", port,
+          (bindAddr != null ? (" bound to " + bindAddr) : "") + (ssl ? " using SSL" : ""));
-        this.config.getJmxManagerSSLProtocols(),
-        this.config.getJmxManagerSSLCiphers(),
+        this.config.getJmxManagerSSLProtocols(), this.config.getJmxManagerSSLCiphers(),
-    RMIClientSocketFactory csf = ssl ? new SslRMIClientSocketFactory() : null;//RMISocketFactory.getDefaultSocketFactory();
-      //new GemFireRMIClientSocketFactory(sc, getLogger());
+    RMIClientSocketFactory csf = ssl ? new SslRMIClientSocketFactory() : null;// RMISocketFactory.getDefaultSocketFactory();
+    // new GemFireRMIClientSocketFactory(sc, getLogger());
-    System.setProperty("sun.rmi.dgc.server.gcInterval", Long.toString(Long.MAX_VALUE-1));
-    
+    System.setProperty("sun.rmi.dgc.server.gcInterval", Long.toString(Long.MAX_VALUE - 1));
+
-    // In order to use a single port, we must use these factories 
+    // In order to use a single port, we must use these factories
-    
+
-    
-    
-    final HashMap<String,Object> env = new HashMap<String,Object>();
-    
+    final HashMap<String, Object> env = new HashMap<String, Object>();
+
-    
-    
-    
-    // Manually creates and binds a JMX RMI Connector Server stub with the 
-    // registry created above: the port we pass here is the port that can  
+
+    // Manually creates and binds a JMX RMI Connector Server stub with the
+    // registry created above: the port we pass here is the port that can
-    // Here we choose to use the same port as was specified for the   
+    // Here we choose to use the same port as was specified for the
-    
+
-    // Here we use the same port as that we choose for the RMI registry. 
+    // Here we use the same port as that we choose for the RMI registry.
-    final JMXServiceURL url = new JMXServiceURL(
-        "service:jmx:rmi://"+hostname+":"+port+"/jndi/rmi://"+hostname+":"+port+"/jmxrmi");
-    
+    final JMXServiceURL url = new JMXServiceURL("service:jmx:rmi://" + hostname + ":" + port
+        + "/jndi/rmi://" + hostname + ":" + port + "/jmxrmi");
+
-    //    
-    // KIRK: JDK 1.5 cannot use JMXConnectorServerFactory because of 
+    //
+    // KIRK: JDK 1.5 cannot use JMXConnectorServerFactory because of
-    cs = new RMIConnectorServer(new JMXServiceURL("rmi",hostname,port),
-          env,stub,mbs) {
+    cs = new RMIConnectorServer(new JMXServiceURL("rmi", hostname, port), env, stub, mbs) {
-      public JMXServiceURL getAddress() { return url;}
+      public JMXServiceURL getAddress() {
+        return url;
+      }
-    // This may be the 1.6 way of doing it but the problem is it does not use our "stub".
-    //cs = JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);
-       
+    // This may be the 1.6 way of doing it but the problem is it does not use
+    // our "stub".
+    // cs = JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);
+
-    }  
-    
+    }
+
-    //System.out.println("Server started at: "+cs.getAddress());
+    // System.out.println("Server started at: "+cs.getAddress());
-    //final Thread clean = new CleanThread(cs);
-    //clean.start();
+    // final Thread clean = new CleanThread(cs);
+    // clean.start();
-  
-  private static class GemFireRMIClientSocketFactory implements RMIClientSocketFactory, Serializable {
+
+  private static class GemFireRMIClientSocketFactory implements RMIClientSocketFactory,
+      Serializable {
-    
-    private /*final hack to prevent serialization*/ transient SocketCreator sc;
-    
+
+    private/* final hack to prevent serialization */transient SocketCreator sc;
+
-      return this.sc.connectForClient(host, port, 0/*no timeout*/);
+      return this.sc.connectForClient(host, port, 0/* no timeout */);
-  private static class GemFireRMIServerSocketFactory implements RMIServerSocketFactory, Serializable {
+
+  private static class GemFireRMIServerSocketFactory implements RMIServerSocketFactory,
+      Serializable {
-    private /*final hack to prevent serialization*/ transient SocketCreator sc;
+    private/* final hack to prevent serialization */transient SocketCreator sc;
-    
+

INS23 INS83 INS43 INS59 UPD66 UPD66 UPD66 UPD42 MOV42 INS42 INS14 UPD66 UPD66 UPD66 INS66 UPD66 UPD43 MOV43 INS42 UPD66 UPD66 INS66 UPD66 INS66 UPD66 UPD42 INS38 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD45 UPD45 INS42 UPD45 INS42 INS42 INS42 INS42 UPD45 DEL40 DEL26 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL45 DEL32 DEL59 DEL60 DEL42 DEL32 DEL83 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL38 DEL45 DEL6 DEL42 DEL45 DEL42 DEL45 DEL27 DEL14 DEL42 DEL32 DEL42 DEL45 DEL42 DEL45 DEL27 DEL41 DEL8 DEL42 DEL43 DEL42 DEL45 DEL42 DEL45 DEL27 DEL14 DEL42 DEL32 DEL42 DEL45 DEL42 DEL45 DEL27 DEL41 DEL8 DEL33 DEL41 DEL8 DEL25 DEL25 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL38 DEL45 DEL6 DEL42 DEL43 DEL42 DEL45 DEL27 DEL14 DEL42 DEL32 DEL42 DEL45 DEL27 DEL41 DEL8 DEL42 DEL43 DEL42 DEL45 DEL27 DEL14 DEL42 DEL32 DEL42 DEL45 DEL27 DEL41 DEL8 DEL33 DEL41 DEL8 DEL25 DEL25 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL38 DEL45 DEL6 DEL42 DEL43 DEL42 DEL45 DEL42 DEL45 DEL27 DEL14 DEL42 DEL32 DEL42 DEL45 DEL42 DEL45 DEL27 DEL41 DEL8 DEL42 DEL43 DEL42 DEL45 DEL42 DEL45 DEL27 DEL14 DEL42 DEL32 DEL42 DEL45 DEL42 DEL45 DEL27 DEL41 DEL8 DEL33 DEL41 DEL8 DEL25 DEL25 DEL8 DEL31 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL38 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL9 DEL41 DEL8 DEL25 DEL8 DEL70 DEL9 DEL41 DEL8 DEL31
GEODE-1760, GEODE-1762: Tests of function exceptions from clients

Extending FunctionServiceBase with tests that use a client server
topology. Added tests of onRegion with PRs as well as onServers.

Adding tests of P2P onRegion with multiple members and PRs.

Adding a temporary workaround for GEODE-1762 to let the function service
tests pass even if a Execution.execute throws an exception. This lets us
at least run the same tests against these different topologies even
though they are throwing different exceptions.

Added a test that result collectors receive partial results even after a
failure.

+import static com.gemstone.gemfire.test.dunit.Wait.pause;
+import java.util.Arrays;
-import java.util.stream.Stream;
+import com.gemstone.gemfire.cache.CacheClosedException;
+import com.gemstone.gemfire.cache.execute.Function;
+import com.gemstone.gemfire.cache.execute.FunctionContext;
+import com.gemstone.gemfire.distributed.internal.InternalDistributedSystem;
+import com.gemstone.gemfire.distributed.internal.membership.InternalDistributedMember;
-import com.gemstone.gemfire.test.dunit.internal.JUnit4DistributedTestCase;
- * here.
+ * here and have them run with all topologies in child classes.
-  private transient CustomCollector customCollector;
+  protected transient CustomCollector customCollector;
-    final Host host = Host.getHost(0);
-
-  public void defaultCollectorThrowsExceptionAfterFunctionThrowsIllegalState() {
-    final Host host = Host.getHost(0);
+  public void defaultCollectorReturnsAllIntermediateResults() {
+    ResultCollector rc = getExecution().execute((context) -> {
+      context.getResultSender().sendResult("one");
+      context.getResultSender().lastResult("two");
+    });
+    final List<String> result = (List<String>) rc.getResult();
+    assertEquals(numberOfExecutions(), result.stream().filter(s -> s.equals("one")).count());
+    assertEquals(numberOfExecutions(), result.stream().filter(s -> s.equals("two")).count());
+  }
-    ResultCollector rc = getExecution().execute((context) -> {throw new IllegalStateException();});
+  @Test()
+  public void defaultCollectorThrowsExceptionAfterFunctionThrowsIllegalState() {
+    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
-    thrown.expectCause(isA(IllegalStateException.class));
+    //GEODE-1762 - clients wrap cause in a ServerOperationException
+//    thrown.expectCause(isA(IllegalStateException.class));
+    ResultCollector rc = getExecution().execute((context) -> {throw new IllegalStateException();});
-    final Host host = Host.getHost(0);
-
-    ResultCollector rc = getExecution().execute((context) -> {throw new FunctionException();});
-
+    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    ResultCollector rc = getExecution().execute((context) -> {throw new FunctionException();});
-    final Host host = Host.getHost(0);
-
+    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    //GEODE-1762 - clients throw a ServerOperationException
+    thrown.expect(Exception.class);
+//    thrown.expect(FunctionException.class);
+//    thrown.expectCause(isA(IllegalStateException.class));
-
-    thrown.expect(FunctionException.class);
-    thrown.expectCause(isA(IllegalStateException.class));
-    final Host host = Host.getHost(0);
-
-    ResultCollector rc = getExecution().execute((context) -> {context.getResultSender().lastResult(new FunctionException());});
+    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    ResultCollector rc = getExecution().execute((context) -> {context.getResultSender().lastResult(new FunctionException());});
-    final Host host = Host.getHost(0);
-
+    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    //GEODE-1762 - client throws a ServerOperationException
+    thrown.expect(Exception.class);
+//    thrown.expect(FunctionException.class);
+//    thrown.expectCause(isA(IllegalStateException.class));
-    thrown.expect(FunctionException.class);
-    thrown.expectCause(isA(IllegalStateException.class));
-    final Host host = Host.getHost(0);
-
+    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    thrown.expect(FunctionException.class);
+    thrown.expectCause(is((Throwable) null));
-    thrown.expect(FunctionException.class);
-    thrown.expectCause(is((Throwable) null));
-    final Host host = Host.getHost(0);
-
-    final Host host = Host.getHost(0);
-
-    final Host host = Host.getHost(0);
-
-    ResultCollector rc = getExecution().withCollector(customCollector).execute((context) -> {throw new IllegalStateException();});
+    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+      ResultCollector rc = getExecution().withCollector(customCollector).execute((context) -> {throw new IllegalStateException();});
-    final Host host = Host.getHost(0);
-
-    ResultCollector rc = getExecution().withCollector(customCollector).execute((context) -> {throw new FunctionException();});
+    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+      ResultCollector rc = getExecution().withCollector(customCollector).execute((context) -> {throw new FunctionException();});
-    final Host host = Host.getHost(0);
-
-    ResultCollector rc = getExecution().execute((context) -> {context.getResultSender().lastResult(new IllegalStateException());});
+    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+      ResultCollector rc = getExecution().execute((context) -> {context.getResultSender().lastResult(new IllegalStateException());});
-    } catch (FunctionException expected) {}
+      //GEODE-1762 - clients throw a ServerOperationException
+    } catch (Exception expected) {}
-    final Host host = Host.getHost(0);
-
-    ResultCollector rc = getExecution().execute((context) -> {
-      context.getResultSender().sendResult(new IllegalStateException());
-      context.getResultSender().lastResult("done");
-    });
+    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+      ResultCollector rc = getExecution().execute((context) -> {
+        context.getResultSender().sendResult(new IllegalStateException());
+        context.getResultSender().lastResult("done");
+      });
-    } catch (FunctionException expected) {}
+      //GEODE-1762 - clients throw a ServerOperationException
+    } catch (Exception expected) {}
-    final Host host = Host.getHost(0);
-
-    final Host host = Host.getHost(0);
-
-  private static class CustomCollector implements ResultCollector<Object, List<Object>> {
+  /**
+   * Test that a custom result collector will still receive all partial
+   * results from other members when one member fails
+   */
+  @Test
+  public void nonHAFunctionResultCollectorIsPassedPartialResultsAfterCloseCache() {
+    List<InternalDistributedMember> members = getAllMembers();
+
+    InternalDistributedMember firstMember = members.iterator().next();
+
+    //Execute a function which will close the cache on one member.
+    try {
+      ResultCollector rc = getExecution()
+        .withCollector(customCollector)
+        .execute(new CacheClosingNonHAFunction(firstMember));
+      rc.getResult();
+      fail("Should have thrown an exception");
+    } catch(Exception expected) {
+      //do nothing
+    }
+    members.remove(firstMember);
+    assertEquals(members, customCollector.getResult());
+    assertEquals(numberOfExecutions() - 1, customCollector.getResult().size());
+  }
+
+  protected List<InternalDistributedMember> getAllMembers() {
+    //Get a list of all of the members
+    ResultCollector rs = getExecution().execute(functionContext -> {
+      functionContext.getResultSender().lastResult(InternalDistributedSystem.getAnyInstance().getDistributedMember());
+    });
+    return (List<InternalDistributedMember>) rs.getResult();
+  }
+
+  public static class CustomCollector implements ResultCollector<Object, List<Object>> {
+
+  /**
+   * A function which will close the cache if the given member matches
+   * the member executing this function
+   */
+  private class CacheClosingNonHAFunction implements Function {
+
+    private final InternalDistributedMember member;
+
+    public CacheClosingNonHAFunction(final InternalDistributedMember member) {
+      this.member = member;
+    }
+
+    @Override
+    public void execute(FunctionContext context) {
+      final InternalDistributedMember myId = InternalDistributedSystem.getAnyInstance().getDistributedMember();
+      if (myId.equals(member)) {
+        getCache().close();
+        throw new CacheClosedException();
+      }
+      pause(1000);
+      context.getResultSender().lastResult(myId);
+    }
+
+    @Override
+    public boolean isHA() {
+      return false;
+    }
+  }
+

MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS40 UPD40 INS40 INS40 INS40 UPD40 INS40 INS31 INS31 INS31 INS55 UPD83 INS77 INS83 INS39 INS42 INS8 MOV60 MOV60 MOV60 MOV60 MOV60 MOV60 MOV78 INS8 MOV78 INS8 INS29 INS78 INS83 INS39 INS42 INS8 INS83 INS74 INS42 INS8 UPD83 INS29 INS83 INS42 INS43 INS23 INS31 INS31 INS31 INS42 INS60 INS60 INS21 INS21 INS54 MOV54 INS54 MOV21 INS54 MOV21 INS65 INS42 INS60 INS60 INS54 INS21 INS21 INS21 INS43 INS43 INS60 INS41 INS65 INS42 INS83 INS83 INS43 INS59 INS83 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS43 INS59 INS83 INS74 INS59 INS32 INS32 INS8 MOV12 INS8 MOV8 INS12 MOV8 INS12 INS66 INS66 INS74 INS59 INS43 INS59 INS8 INS12 INS32 INS32 INS32 INS42 INS42 INS43 INS59 INS11 INS66 INS66 INS42 INS42 INS83 INS43 INS42 INS21 INS42 INS43 INS42 INS60 INS25 INS21 INS21 INS42 INS41 INS42 INS42 INS32 INS43 INS43 INS42 INS11 INS42 INS32 INS32 INS42 INS32 INS32 MOV60 INS21 MOV21 MOV60 MOV21 MOV21 MOV21 MOV21 INS44 INS8 MOV21 MOV21 INS44 INS8 INS43 INS43 INS42 INS32 INS42 INS42 INS32 INS60 MOV21 INS21 INS44 INS8 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS27 INS32 INS42 INS42 INS32 INS74 INS32 INS42 INS7 INS42 INS83 INS43 INS59 INS32 INS8 INS32 INS32 INS9 INS32 INS42 INS86 INS42 INS42 INS74 INS32 INS42 INS32 INS42 INS42 INS32 INS42 UPD43 UPD43 INS32 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS59 INS32 INS43 INS42 INS42 INS42 INS32 INS34 INS32 INS42 INS32 INS42 INS86 INS43 INS43 INS42 INS42 INS22 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS21 INS53 INS42 INS34 INS32 INS42 INS42 INS42 INS59 INS8 INS43 INS43 INS42 INS42 INS32 INS42 INS86 INS32 INS42 INS86 UPD42 UPD42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS59 INS8 INS42 INS42 INS52 INS42 INS32 INS42 INS32 INS14 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS42 INS42 INS59 INS32 INS42 INS42 INS59 INS32 INS32 INS42 INS14 INS42 INS21 INS42 INS42 INS32 INS42 INS43 INS32 INS32 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS43 INS42 INS32 INS42 INS42 INS32 INS42 INS45 INS32 INS42 INS45 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL8 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL8 DEL54 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60
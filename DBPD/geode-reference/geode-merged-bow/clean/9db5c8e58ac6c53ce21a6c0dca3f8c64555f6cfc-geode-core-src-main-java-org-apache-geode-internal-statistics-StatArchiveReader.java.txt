GEODE-2971: Introduce ExitCode to resolve inconsistency of shell exit values.

* this closes #652

* Corrected inconsistency of error handling and subsequent exit status in member status commands
* 'gfsh help' now returns 0 exit code as base behavior (previously returned 1).

-import org.apache.geode.GemFireIOException;
-import org.apache.geode.InternalGemFireException;
-import org.apache.geode.internal.Assert;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.DateFormatter;
-
+import org.apache.geode.GemFireIOException;
+import org.apache.geode.InternalGemFireException;
+import org.apache.geode.internal.Assert;
+import org.apache.geode.internal.ExitCode;
+import org.apache.geode.internal.i18n.LocalizedStrings;
+import org.apache.geode.internal.logging.DateFormatter;
+
-      System.exit(1);
+      ExitCode.FATAL.doSystemExit();
-  public static interface StatValue {
+  public interface StatValue {
-    public static final int FILTER_NONE = 0;
+    int FILTER_NONE = 0;
-    public static final int FILTER_PERSEC = 1;
+    int FILTER_PERSEC = 1;
-    public static final int FILTER_PERSAMPLE = 2;
+    int FILTER_PERSAMPLE = 2;
-    public StatValue createTrimmed(long startTime, long endTime);
+    StatValue createTrimmed(long startTime, long endTime);
-    public boolean isTrimmedLeft();
+    boolean isTrimmedLeft();
-    public ResourceType getType();
+    ResourceType getType();
-    public ResourceInst[] getResources();
+    ResourceInst[] getResources();
-    public long[] getRawAbsoluteTimeStamps();
+    long[] getRawAbsoluteTimeStamps();
-    public long[] getRawAbsoluteTimeStampsWithSecondRes();
+    long[] getRawAbsoluteTimeStampsWithSecondRes();
-    public double[] getRawSnapshots();
+    double[] getRawSnapshots();
-    public double[] getSnapshots();
+    double[] getSnapshots();
-    public int getSnapshotsSize();
+    int getSnapshotsSize();
-    public double getSnapshotsMinimum();
+    double getSnapshotsMinimum();
-    public double getSnapshotsMaximum();
+    double getSnapshotsMaximum();
-    public double getSnapshotsAverage();
+    double getSnapshotsAverage();
-    public double getSnapshotsStandardDeviation();
+    double getSnapshotsStandardDeviation();
-    public double getSnapshotsMostRecent();
+    double getSnapshotsMostRecent();
-    public boolean hasValueChanged();
+    boolean hasValueChanged();
-    public int getFilter();
+    int getFilter();
-    public void setFilter(int filter);
+    void setFilter(int filter);
-    public StatDescriptor getDescriptor();
+    StatDescriptor getDescriptor();
-      // for (int i=0; i < values.length; i++) {
-      // System.out.println("DEBUG: inst# " + i + " has "
-      // + values[i].getRawAbsoluteTimeStamps().length
-      // + " timestamps");
-      // }
-              // System.out.println("DEBUG: skipping mergeTs[" + (ourIdx-1) + "]="
-              // + tsAtInsertPoint + " because it was closer to the next one");
-            // System.out.println("DEBUG: tsToInsert=" + tsToInsert
-            // + " tsAtInsertPoint=" + tsAtInsertPoint
-            // + " timeDelta=" + timeDelta
-            // + " vDelta=" + (Math.abs(tsToInsert-tsAtInsertPoint)/2)
-            // + " numToCopy=" + numToCopy);
-            // if (j > 0) {
-            // System.out.println("DEBUG: prevTsToInsert=" + valueTimeStamps[j-1]);
-            // }
-            // if (ourIdx > 0) {
-            // System.out.println("DEBUG ourTimeStamps[" + (ourIdx-1) + "]=" +
-            // ourTimeStamps[ourIdx-1]);
-            // }
-
-            // if (numToCopy > 1) {
-            // System.out.println("DEBUG: endRunTs=" + valueTimeStamps[endRunIdx-1]);
-            // }
-          // System.out.println("DEBUG: inst #" + i
-          // + " valueTs[" + (j-1) + "]=" + tsToInsert
-          // + " found/inserted at"
-          // + " mergeTs[" + (ourIdx-1) + "]=" + ourTimeStamps[ourIdx-1]);
-      // for (int i=0; i < tsCount; i++) {
-      // System.out.println("DEBUG: mergedTs[" + i + "]=" + ourTimeStamps[i]);
-      // if (i > 0 && ourTimeStamps[i] <= ourTimeStamps[i-1]) {
-      // System.out.println("DEBUG: ERROR ts was not greater than previous");
-      // }
-      // }
-      // Now make one more pass over all the timestamps and make sure they
-      // will all fit into the current merged timestamps in ourTimeStamps
-      // boolean changed;
-      // do {
-      // changed = false;
-      // for (int i=0; i < values.length; i++) {
-      // valueTimeStamps = values[i].getRawAbsoluteTimeStamps();
-      // if (valueTimeStamps.length == 0) {
-      // continue;
-      // }
-      // int ourIdx = 0;
-      // for (int j=0; j < valueTimeStamps.length; j++) {
-      // while ((ourIdx < (tsCount-1))
-      // && !isClosest(valueTimeStamps[j], ourTimeStamps, ourIdx)) {
-      // ourIdx++;
-      // }
-      // if (ourIdx == (tsCount-1)) {
-      // // we are at the end so we need to append all our remaining stamps
-      // [j..valueTimeStamps.length-1]
-      // // and then reappend the Long.MAX_VALUE that
-      // // is currently at tsCount-1
-      // int numToCopy = valueTimeStamps.length - j;
-      // if (tsCount+numToCopy > ourTimeStamps.length) {
-      // // grow our timestamp array
-      // long[] tmp = new long[tsCount+numToCopy+1];
-      // System.arraycopy(ourTimeStamps, 0, tmp, 0, tsCount);
-      // ourTimeStamps = tmp;
-      // }
-      // System.arraycopy(valueTimeStamps, j,
-      // ourTimeStamps, ourIdx,
-      // numToCopy);
-      // tsCount += numToCopy;
-      // ourTimeStamps[tsCount-1] = Long.MAX_VALUE;
-      // //changed = true;
-      // System.out.println("DEBUG: had to add " + numToCopy
-      // + " timestamps for inst#" + i + " starting at index " + j + " starting with ts=" +
-      // valueTimeStamps[j]);
-      // break; // our of the for j loop since we just finished off this guy
-      // } else {
-      // ourIdx++;
-      // }
-      // }
-      // }
-      // } while (changed);
-      // remove the max ts we added
-          // for (int i=0; i < tsCount; i++) {
-          // if (ourTimeStamps[i] >= startTime) {
-          // break;
-          // }
-          // startIdx++;
-          // }
-          // endIdx = startIdx-1;
-          // for (int i=startIdx; i < tsCount; i++) {
-          // if (ourTimeStamps[i] >= endTime) {
-          // break;
-          // }
-          // endIdx++;
-          // }
-      // System.out.println("DEBUG: producing " + result.length + " values");
-          // System.out.println("DEBUG: inst#" + i + " has " + valueSnapshots.length + " values");
-            // System.out.println("DEBUG: Doing v with"
-            // + " vTs[" + j + "]=" + valueTimeStamps[j]
-            // + " at mergeTs[" + curIdx + "]=" + ourTimeStamps[curIdx]);
-              // System.out.println("DEBUG: skipping curIdx=" + curIdx
-              // + " valueTimeStamps[" + j + "]=" + valueTimeStamps[j]
-              // + " ourTimeStamps[" + curIdx + "]=" + ourTimeStamps[curIdx]
-              // + " ourTimeStamps[" + (curIdx+1) + "]=" + ourTimeStamps[curIdx+1]);
-            // if (result[i] > valueDelta) {
-            // System.out.println("DEBUG: timeDelta was " + timeDelta + " ms.");
-            // System.out.println("DEBUG: valueDelta was " + valueDelta);
-            // System.out.println("DEBUG: valueDelta/sec was " + result[i]);
-            // }
-    // private final int id;
-      // this.id = id;
-      // this.id = id;
-    // private int getId() {
-    // return this.id;
-    // }
-    // private final int uniqueId;
-      // this.uniqueId = uniqueId;
-  public static interface StatSpec extends ValueFilter {
+  public interface StatSpec extends ValueFilter {
-    public static final int GLOBAL = 2;
+    int GLOBAL = 2;
-    public static final int FILE = 1;
+    int FILE = 1;
-    public final int NONE = 0;
+    int NONE = 0;
-    public int getCombineType();
+    int getCombineType();
-  public static interface ValueFilter {
+  public interface ValueFilter {
-    public boolean archiveMatches(File archive);
+    boolean archiveMatches(File archive);
-    public boolean typeMatches(String typeName);
+    boolean typeMatches(String typeName);
-    public boolean statMatches(String statName);
+    boolean statMatches(String statName);
-    public boolean instanceMatches(String textId, long numericId);
+    boolean instanceMatches(String textId, long numericId);
-        // System.out.println("DEBUG: don't load type=" + typeName);
-        // System.out.println("DEBUG: don't load stat=" + stat.getName());
-        // System.out.println("DEBUG: don't load instance=" + textId);
-        // type.unload();
-      /*
-       * if (this.archiveVersion <= 1) { return dataIn.readInt(); }
-       */

MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS40 INS40 UPD42 DEL42 DEL34 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83
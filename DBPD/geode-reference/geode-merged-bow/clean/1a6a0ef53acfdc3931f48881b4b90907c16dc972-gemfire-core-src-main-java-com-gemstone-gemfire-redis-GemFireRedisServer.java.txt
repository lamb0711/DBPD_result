Fix for GEODE-109

1) To fix this floating meta data problem for the redis list implementation, this meta data has been moved into the list region itself
2) Sorted set query failures are fixed by using fully qualified names and also depends on GEODE-146
3) Concurrent region creation/destruction logic completely changed to use dedicated locks for synchronization, fixed distributed deadlock
4) Added integration tests
5) Add javadocs where necessary

This closes #13

-import com.gemstone.gemfire.internal.redis.RegionCache;
+import com.gemstone.gemfire.internal.redis.RegionProvider;
+ * If the {@link GemFireRedisServer#NUM_THREADS_SYS_PROP_NAME} system property is set to 0,
+ * one thread per client will be created. Otherwise a worker thread pool of specified size is
+ * used or a default size of 4 * {@link Runtime#availableProcessors()} if the property is not set.
+ * <p>
+ * Setting the AUTH password requires setting the property "redis-password" just as "redis-port"
+ * would be in xml or through GFSH.
-  private RegionCache regionCache;
+  private RegionProvider regionCache;
-   * The field that defines the name of the {@link Region} which holds all of
-   * the lists meta data. The current value of this field is {@value #LISTS_META_DATA_REGION}.
-   */
-  public static final String LISTS_META_DATA_REGION = "__LiStS_MeTa_DaTa";
-
-  /**
-   * This String holds the String representation of the {@link RegionShortcut}
-   * that will be used as the default Region type for all region creation. This
-   * is set by the system property {@value #DEFAULT_REGION_SYS_PROP_NAME} and the
-   * default type is {@link RegionShortcut#PARTITION}.
-   */
-  private static final String regionType = System.getProperty(DEFAULT_REGION_SYS_PROP_NAME, "PARTITION");
-
-  /**
-  public static final RegionShortcut DEFAULT_REGION_TYPE = setRegion(regionType);
+  public final RegionShortcut DEFAULT_REGION_TYPE;
+
+  private boolean shutdown;
+  private boolean started;
-   * @param regionType The String representation of a {@link RegionShortcut}
-  private static RegionShortcut setRegion(String regionType) {
+  private static RegionShortcut setRegionType() {
+    String regionType = System.getProperty(DEFAULT_REGION_SYS_PROP_NAME, "PARTITION");
-   * server and bind to the given address and port. Additionally the 
-   * number of threads used by the server to handle clients is specified
-   * as well as the logging level to be used by GemFire
+   * server and bind to the given address and port. Keep in mind that the
+   * log level configuration will only be set if a {@link Cache} does not already
+   * exist, if one already exists then setting that property will have no effect.
+    this.DEFAULT_REGION_TYPE = setRegionType();
+    this.shutdown = false;
+    this.started = false;
-  public void start() {
-    try {
-      startGemFire();
-      initializeRedis();
-      startRedisServer();
-    } catch (IOException e) {
-      throw new RuntimeException("Could not start Server", e);
-    } catch (InterruptedException e) {
-      throw new RuntimeException("Could not start Server", e);
+  public synchronized void start() {
+    if (!started) {
+      try {
+        startGemFire();
+        initializeRedis();
+        startRedisServer();
+      } catch (IOException e) {
+        throw new RuntimeException("Could not start Server", e);
+      } catch (InterruptedException e) {
+        throw new RuntimeException("Could not start Server", e);
+      }
+      started = true;
-      CacheFactory cacheFactory = new CacheFactory();
-      if (logLevel != null)
-        cacheFactory.set("log-level", logLevel);
-      this.cache = cacheFactory.create();
-    } else
-      this.cache = c;
-    this.logger = this.cache.getLogger();
+      synchronized (GemFireRedisServer.class) {
+        c = GemFireCacheImpl.getInstance();
+        if (c == null) {
+          CacheFactory cacheFactory = new CacheFactory();
+          if (logLevel != null)
+            cacheFactory.set("log-level", logLevel);
+          c = cacheFactory.create();
+        }
+      }
+    }
+    this.cache = c;
+    this.logger = c.getLogger();
-      RegionFactory<String, Integer> rfList = cache.createRegionFactory(RegionShortcut.REPLICATE);
-      Region<String, Integer> listsMetaData;
-      if ((listsMetaData = this.cache.getRegion(LISTS_META_DATA_REGION)) == null)
-        listsMetaData = rfList.create(LISTS_META_DATA_REGION);
-      this.regionCache = new RegionCache(stringsRegion, hLLRegion, redisMetaData, listsMetaData, expirationFutures, expirationExecutor);
+      this.regionCache = new RegionProvider(stringsRegion, hLLRegion, redisMetaData, expirationFutures, expirationExecutor, this.DEFAULT_REGION_TYPE);
-      redisMetaData.put(LISTS_META_DATA_REGION, RedisDataType.REDIS_PROTECTED);
-        Region<?, ?> r = this.regionCache.getRegion(Coder.stringToByteArrayWrapper(key));
+        ByteArrayWrapper kW = Coder.stringToByteArrayWrapper(key);
+        Region<?, ?> r = this.regionCache.getRegion(kW);
-          ByteArrayWrapper kW = Coder.stringToByteArrayWrapper(key);
-  public void shutdown() {
-    if (logger.infoEnabled())
-      logger.info("GemFireRedisServer shutting down");
-    ChannelFuture closeFuture = this.serverChannel.closeFuture();
-    this.serverChannel.close();
-    Future<?> c = workerGroup.shutdownGracefully();
-    Future<?> c2 = bossGroup.shutdownGracefully();
-    c.syncUninterruptibly();
-    c2.syncUninterruptibly();
-    this.regionCache.close();
-    if (mainThread != null)
-      mainThread.interrupt();
-    for (ScheduledFuture<?> f : this.expirationFutures.values())
-      f.cancel(true);
-    this.expirationFutures.clear();
-    this.expirationExecutor.shutdownNow();
-    closeFuture.syncUninterruptibly();
+  public synchronized void shutdown() {
+    if (!shutdown) {
+      if (logger.infoEnabled())
+        logger.info("GemFireRedisServer shutting down");
+      ChannelFuture closeFuture = this.serverChannel.closeFuture();
+      Future<?> c = workerGroup.shutdownGracefully();
+      Future<?> c2 = bossGroup.shutdownGracefully();
+      this.serverChannel.close();
+      c.syncUninterruptibly();
+      c2.syncUninterruptibly();
+      this.regionCache.close();
+      if (mainThread != null)
+        mainThread.interrupt();
+      for (ScheduledFuture<?> f : this.expirationFutures.values())
+        f.cancel(true);
+      this.expirationFutures.clear();
+      this.expirationExecutor.shutdownNow();
+      closeFuture.syncUninterruptibly();
+      shutdown = true;
+    }

MOV23 MOV23 UPD40 UPD43 UPD83 INS39 INS39 INS59 UPD42 INS83 INS8 MOV8 INS83 INS8 INS66 INS65 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 UPD42 UPD42 INS42 INS60 INS21 INS21 INS21 INS25 INS25 MOV21 INS25 INS67 INS68 MOV43 MOV59 UPD66 INS66 INS65 UPD66 UPD66 INS7 INS7 INS7 INS38 MOV8 INS27 INS8 MOV32 INS38 MOV8 MOV21 INS42 INS42 INS42 INS42 INS42 INS22 INS32 INS22 INS9 INS22 INS9 INS42 INS21 INS42 INS33 INS51 MOV60 MOV60 INS42 INS21 INS52 INS42 INS42 INS52 INS42 INS52 INS42 INS7 INS57 INS8 INS42 MOV27 INS7 INS42 INS9 INS43 INS21 MOV25 MOV60 INS25 INS42 INS9 INS42 INS7 UPD43 INS22 MOV27 INS8 INS42 INS32 UPD42 INS52 INS42 MOV21 INS42 INS42 UPD42 MOV42 INS42 DEL83 DEL42 DEL42 DEL32 DEL66 DEL42 DEL65 DEL66 DEL66 DEL42 DEL67 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL45 DEL66 DEL42 DEL65 DEL66 DEL66 DEL42 DEL67 DEL65 DEL66 DEL66 DEL42 DEL42 DEL67 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL66 DEL42 DEL65 DEL65 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL40 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL36 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL25 DEL42 DEL42 DEL42 DEL42 DEL40 DEL32 DEL21 DEL42 DEL42 DEL32 DEL25 DEL8
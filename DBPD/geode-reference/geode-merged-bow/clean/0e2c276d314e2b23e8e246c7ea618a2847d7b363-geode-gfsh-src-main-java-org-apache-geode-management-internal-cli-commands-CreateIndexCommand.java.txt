GEODE-8055: create index command should work on sub regions (#5034)


+import java.util.HashSet;
-import java.util.Objects;
-import java.util.stream.Collectors;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.geode.cache.configuration.CacheConfig;
+import org.apache.geode.distributed.ConfigurationPersistenceService;
-import org.apache.geode.management.api.ClusterManagementService;
-import org.apache.geode.management.configuration.Region;
+import org.apache.geode.management.configuration.AbstractConfiguration;
-    ClusterManagementService cms = getClusterManagementService();
-      regionName = getValidRegionName(regionPath, cms);
-      Set<String> calculatedGroups = getGroupsContainingRegion(cms, regionName);
+      regionName = getValidRegionName(regionPath);
+      Set<String> calculatedGroups = getGroupsContainingRegion(ccService, regionName);
-        // the calculatedGroups will have null value to indicate the "cluster" level, in thise case
+        // the calculatedGroups will have "cluster" value to indicate the "cluster" level, in thise
+        // case
-        groups = calculatedGroups.stream().filter(Objects::nonNull).toArray(String[]::new);
+        groups = calculatedGroups.stream().filter(s -> !AbstractConfiguration.CLUSTER.equals(s))
+            .toArray(String[]::new);
-    // group
-    // information.
+    // group information.
-  // this also handles the possibility when regionName has "." in it, like "/A.B". It's stripping
-  // . part one by one and check if the remaining part is a valid region name or not. If we
-  // could not find a region with any part of the name, (like, couldn't find A.B or A), then A is
-  // returned.
-  String getValidRegionName(String regionPath, ClusterManagementService cms) {
-    // Check to see if the region path contains an alias e.g "/region1 r1"
-    // Then the first string will be the regionPath
+  // since we can't create index on regions with . in it's name, we will assume tht regionName
+  // returned here should not have "."
+  String getValidRegionName(String regionPath) {
-    // check to see if the region path is in the form of "--region=region.entrySet() z"
-    while (regionName.contains(".")) {
-      Set<String> groupsContainingRegion = getGroupsContainingRegion(cms, regionName);
-      if (!groupsContainingRegion.isEmpty()) {
-        break;
-      }
-      // otherwise, strip one more . part off the regionName
-      else {
-        regionName = regionName.substring(0, regionName.lastIndexOf("."));
-      }
+    regionName = StringUtils.removeStart(regionName, "/");
+    if (regionName.contains(".")) {
+      regionName = regionName.substring(0, regionName.indexOf('.'));
-  // if region belongs to "cluster" level, it will return a set of one null value
-  Set<String> getGroupsContainingRegion(ClusterManagementService cms,
+  // if region belongs to "cluster" level, it will return a set containing "cluster" string
+  Set<String> getGroupsContainingRegion(ConfigurationPersistenceService cps,
-    Region regionConfig = new Region();
-    regionConfig.setName(regionName);
-    List<Region> regions = cms.list(regionConfig).getConfigResult();
-    return regions.stream().map(Region::getGroup)
-        .collect(Collectors.toSet());
+    Set<String> foundGroups = new HashSet<>();
+    for (String group : cps.getGroups()) {
+      CacheConfig cacheConfig = cps.getCacheConfig(group, true);
+      if (cacheConfig.findRegionConfiguration(regionName) != null) {
+        foundGroups.add(group);
+      }
+    }
+    return foundGroups;
-

MOV26 MOV26 INS26 UPD40 UPD40 INS40 UPD40 UPD40 INS8 MOV60 INS21 MOV25 MOV41 UPD43 UPD42 INS70 INS41 INS7 MOV32 UPD42 MOV74 INS44 INS32 INS8 INS42 INS42 INS32 UPD42 INS43 INS42 UPD42 MOV42 INS42 INS60 INS25 UPD42 MOV42 UPD42 MOV42 MOV42 INS45 INS74 INS42 INS43 MOV59 INS27 INS8 INS43 UPD42 MOV42 UPD42 INS32 INS33 INS21 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS9 INS42 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 INS13 UPD42 MOV42 INS42 INS42 INS86 INS59 INS38 INS42 INS32 INS40 INS42 INS42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL90 DEL42 DEL42 DEL32 DEL38 DEL10 DEL8 DEL45 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL59 DEL60 DEL8 DEL61 DEL8 DEL42 DEL43 DEL43 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL43 DEL74 DEL60 DEL32 DEL42 DEL42 DEL90 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL41
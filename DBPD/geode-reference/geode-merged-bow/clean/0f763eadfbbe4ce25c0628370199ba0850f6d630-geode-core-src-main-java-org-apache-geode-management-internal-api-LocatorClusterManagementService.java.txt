GEODE-8099: add dlock around cms create/delete operations. (#5188)


+import org.apache.geode.distributed.DistributedLockService;
+import org.apache.geode.distributed.internal.locks.DLockService;
+/**
+ * each locator will have one instance of this running if enabled
+ */
+  @VisibleForTesting
+  // the dlock service name used by the CMS
+  static final String CMS_DLOCK_SERVICE_NAME = "CMS_DLOCK_SERVICE";
+  private DistributedLockService cmsDlockService;
+  @VisibleForTesting
+  // synchronized because cmsDlockService is lazily initialized
+  synchronized DistributedLockService getCmsDlockService() {
+    if (cmsDlockService == null) {
+      cmsDlockService =
+          DLockService.getOrCreateService(CMS_DLOCK_SERVICE_NAME,
+              cache.getInternalDistributedSystem());
+    }
+    return cmsDlockService;
+  }
+
+  private boolean lockCMS() {
+    return getCmsDlockService().lock(CMS_DLOCK_SERVICE_NAME, -1, -1);
+  }
+
+  private void unlockCMS() {
+    getCmsDlockService().unlock(CMS_DLOCK_SERVICE_NAME);
+  }
+
+    lockCMS();
-      // first validate common attributes of all configuration object
-      commonValidator.validate(CacheElementOperation.CREATE, config);
-
-      ConfigurationValidator validator = validators.get(config.getClass());
-      if (validator != null) {
-        validator.validate(CacheElementOperation.CREATE, config);
-      }
-
-      // check if this config already exists
-      if (configurationManager instanceof CacheConfigurationManager) {
-        memberValidator.validateCreate(config, (CacheConfigurationManager) configurationManager);
-      }
-    } catch (EntityExistsException e) {
-      raise(StatusCode.ENTITY_EXISTS, e);
-    } catch (IllegalArgumentException e) {
-      raise(StatusCode.ILLEGAL_ARGUMENT, e);
-    }
-
-    // find the targeted members
-    Set<String> groups = new HashSet<>();
-    Set<DistributedMember> targetedMembers;
-    if (config instanceof RegionScoped) {
-      String regionName = ((RegionScoped) config).getRegionName();
-      groups = memberValidator.findGroups(regionName);
-      if (groups.isEmpty()) {
-        raise(StatusCode.ENTITY_NOT_FOUND, "Region provided does not exist: " + regionName);
-      }
-      targetedMembers = memberValidator.findServers(groups.toArray(new String[0]));
-    } else {
-      final String groupName = AbstractConfiguration.getGroupName(config.getGroup());
-      groups.add(groupName);
-      targetedMembers = memberValidator.findServers(groupName);
-    }
-
-    ClusterManagementRealizationResult result = new ClusterManagementRealizationResult();
-
-    // execute function on all targeted members
-    List<RealizationResult> functionResults = executeAndGetFunctionResult(
-        new CacheRealizationFunction(),
-        config, CacheElementOperation.CREATE,
-        targetedMembers);
-
-    functionResults.forEach(result::addMemberStatus);
-
-    // if any false result is added to the member list
-    if (result.getStatusCode() != StatusCode.OK) {
-      result.setStatus(StatusCode.ERROR, "Failed to create on all members.");
-      return assertSuccessful(result);
-    }
-
-    // persist configuration in cache config
-    List<String> updatedGroups = new ArrayList<>();
-    List<String> failedGroups = new ArrayList<>();
-    for (String groupName : groups) {
-        configurationManager.add(config, groupName);
-        updatedGroups.add(groupName);
-      } catch (Exception e) {
-        logger.error(e.getMessage(), e);
-        failedGroups.add(groupName);
+        // first validate common attributes of all configuration object
+        commonValidator.validate(CacheElementOperation.CREATE, config);
+
+        ConfigurationValidator validator = validators.get(config.getClass());
+        if (validator != null) {
+          validator.validate(CacheElementOperation.CREATE, config);
+        }
+
+        // check if this config already exists
+        if (configurationManager instanceof CacheConfigurationManager) {
+          memberValidator.validateCreate(config, (CacheConfigurationManager) configurationManager);
+        }
+      } catch (EntityExistsException e) {
+        raise(StatusCode.ENTITY_EXISTS, e);
+      } catch (IllegalArgumentException e) {
+        raise(StatusCode.ILLEGAL_ARGUMENT, e);
-    }
-    setResultStatus(result, updatedGroups, failedGroups);
+      // find the targeted members
+      Set<String> groups = new HashSet<>();
+      Set<DistributedMember> targetedMembers;
+      if (config instanceof RegionScoped) {
+        String regionName = ((RegionScoped) config).getRegionName();
+        groups = memberValidator.findGroups(regionName);
+        if (groups.isEmpty()) {
+          raise(StatusCode.ENTITY_NOT_FOUND, "Region provided does not exist: " + regionName);
+        }
+        targetedMembers = memberValidator.findServers(groups.toArray(new String[0]));
+      } else {
+        final String groupName = AbstractConfiguration.getGroupName(config.getGroup());
+        groups.add(groupName);
+        targetedMembers = memberValidator.findServers(groupName);
+      }
-    // add the config object which includes the HATEOAS information of the element created
-    if (result.isSuccessful()) {
-      result.setLinks(config.getLinks());
+      ClusterManagementRealizationResult result = new ClusterManagementRealizationResult();
+
+      // execute function on all targeted members
+      List<RealizationResult> functionResults = executeAndGetFunctionResult(
+          new CacheRealizationFunction(),
+          config, CacheElementOperation.CREATE,
+          targetedMembers);
+
+      functionResults.forEach(result::addMemberStatus);
+
+      // if any false result is added to the member list
+      if (result.getStatusCode() != StatusCode.OK) {
+        result.setStatus(StatusCode.ERROR, "Failed to create on all members.");
+        return assertSuccessful(result);
+      }
+
+      // persist configuration in cache config
+      List<String> updatedGroups = new ArrayList<>();
+      List<String> failedGroups = new ArrayList<>();
+      for (String groupName : groups) {
+        try {
+          configurationManager.add(config, groupName);
+          updatedGroups.add(groupName);
+        } catch (Exception e) {
+          logger.error(e.getMessage(), e);
+          failedGroups.add(groupName);
+        }
+      }
+
+      setResultStatus(result, updatedGroups, failedGroups);
+
+      // add the config object which includes the HATEOAS information of the element created
+      if (result.isSuccessful()) {
+        result.setLinks(config.getLinks());
+      }
+      return assertSuccessful(result);
+    } finally {
+      unlockCMS();
-    return assertSuccessful(result);
+    lockCMS();
-      // first validate common attributes of all configuration object
-      commonValidator.validate(CacheElementOperation.DELETE, config);
-
-      ConfigurationValidator validator = validators.get(config.getClass());
-      if (validator != null) {
-        validator.validate(CacheElementOperation.DELETE, config);
-      }
-    } catch (IllegalArgumentException e) {
-      raise(StatusCode.ILLEGAL_ARGUMENT, e);
-    }
-
-    String[] groupsWithThisElement =
-        memberValidator.findGroupsWithThisElement(config, configurationManager);
-    if (groupsWithThisElement.length == 0) {
-      raise(StatusCode.ENTITY_NOT_FOUND,
-          config.getClass().getSimpleName() + " '" + config.getId() + "' does not exist.");
-    }
-
-    // execute function on all members
-    ClusterManagementRealizationResult result = new ClusterManagementRealizationResult();
-
-    List<RealizationResult> functionResults = executeAndGetFunctionResult(
-        new CacheRealizationFunction(),
-        config, CacheElementOperation.DELETE,
-        memberValidator.findServers(groupsWithThisElement));
-    functionResults.forEach(result::addMemberStatus);
-
-    // if any false result is added to the member list
-    if (result.getStatusCode() != StatusCode.OK) {
-      result.setStatus(StatusCode.ERROR, "Failed to delete on all members.");
-      return result;
-    }
-
-    // persist configuration in cache config
-    List<String> updatedGroups = new ArrayList<>();
-    List<String> failedGroups = new ArrayList<>();
-    for (String finalGroup : groupsWithThisElement) {
-        configurationManager.delete(config, finalGroup);
-        updatedGroups.add(finalGroup);
-      } catch (Exception e) {
-        logger.error(e.getMessage(), e);
-        failedGroups.add(finalGroup);
+        // first validate common attributes of all configuration object
+        commonValidator.validate(CacheElementOperation.DELETE, config);
+
+        ConfigurationValidator validator = validators.get(config.getClass());
+        if (validator != null) {
+          validator.validate(CacheElementOperation.DELETE, config);
+        }
+      } catch (IllegalArgumentException e) {
+        raise(StatusCode.ILLEGAL_ARGUMENT, e);
+
+      String[] groupsWithThisElement =
+          memberValidator.findGroupsWithThisElement(config, configurationManager);
+      if (groupsWithThisElement.length == 0) {
+        raise(StatusCode.ENTITY_NOT_FOUND,
+            config.getClass().getSimpleName() + " '" + config.getId() + "' does not exist.");
+      }
+
+      // execute function on all members
+      ClusterManagementRealizationResult result = new ClusterManagementRealizationResult();
+
+      List<RealizationResult> functionResults = executeAndGetFunctionResult(
+          new CacheRealizationFunction(),
+          config, CacheElementOperation.DELETE,
+          memberValidator.findServers(groupsWithThisElement));
+      functionResults.forEach(result::addMemberStatus);
+
+      // if any false result is added to the member list
+      if (result.getStatusCode() != StatusCode.OK) {
+        result.setStatus(StatusCode.ERROR, "Failed to delete on all members.");
+        return result;
+      }
+
+      // persist configuration in cache config
+      List<String> updatedGroups = new ArrayList<>();
+      List<String> failedGroups = new ArrayList<>();
+      for (String finalGroup : groupsWithThisElement) {
+        try {
+          configurationManager.delete(config, finalGroup);
+          updatedGroups.add(finalGroup);
+        } catch (Exception e) {
+          logger.error(e.getMessage(), e);
+          failedGroups.add(finalGroup);
+        }
+      }
+
+      setResultStatus(result, updatedGroups, failedGroups);
+
+      return assertSuccessful(result);
+    } finally {
+      unlockCMS();
-
-    setResultStatus(result, updatedGroups, failedGroups);
-
-    return assertSuccessful(result);

INS26 INS26 INS40 INS40 INS29 INS23 INS23 INS31 INS31 INS31 INS65 INS78 INS83 INS83 INS43 INS59 INS83 INS43 INS59 INS78 INS83 INS43 INS42 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS66 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS25 INS41 INS41 INS21 INS21 INS54 INS21 INS54 INS27 INS8 INS42 INS32 INS32 INS32 INS8 INS8 INS32 INS8 INS8 INS42 INS33 INS21 INS32 INS42 INS42 INS38 INS38 INS32 INS42 INS42 INS42 MOV54 MOV60 MOV60 MOV25 MOV60 MOV60 MOV21 MOV25 MOV60 MOV60 MOV70 MOV21 MOV25 MOV41 INS21 INS42 MOV54 MOV60 MOV25 MOV60 MOV60 MOV21 MOV25 MOV60 MOV60 MOV70 MOV21 MOV41 INS21 INS7 INS42 INS34 INS34 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42
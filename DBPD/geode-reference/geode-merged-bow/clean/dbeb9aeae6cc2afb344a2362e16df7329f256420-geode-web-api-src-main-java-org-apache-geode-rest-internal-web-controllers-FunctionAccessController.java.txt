Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import com.wordnik.swagger.annotations.Api;
-import com.wordnik.swagger.annotations.ApiOperation;
-import com.wordnik.swagger.annotations.ApiResponse;
-import com.wordnik.swagger.annotations.ApiResponses;
+import io.swagger.annotations.Api;
+import io.swagger.annotations.ApiOperation;
+import io.swagger.annotations.ApiResponse;
+import io.swagger.annotations.ApiResponses;
+import org.springframework.security.access.prepost.PreAuthorize;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+ * 
-  private static final Logger logger = LogService.getLogger();
-
+  private static final Logger logger = LogService.getLogger();
-   *
+   * 
-   *
+   * 
-  @RequestMapping(method = RequestMethod.GET, produces = { MediaType.APPLICATION_JSON_VALUE })
-  @ApiOperation(
-      value = "list all functions",
-      notes = "list all functions available in the GemFire cluster",
-      response = void.class
-  )
-  @ApiResponses({
-      @ApiResponse(code = 200, message = "OK."),
-      @ApiResponse( code = 401, message = "Invalid Username or Password." ),
-      @ApiResponse( code = 403, message = "Insufficient privileges for operation." ),
-      @ApiResponse(code = 500, message = "GemFire throws an error or exception.")
-  })
+  @RequestMapping(method = RequestMethod.GET, produces = {MediaType.APPLICATION_JSON_UTF8_VALUE})
+  @ApiOperation(value = "list all functions",
+      notes = "list all functions available in the GemFire cluster", response = void.class)
+  @ApiResponses({@ApiResponse(code = 200, message = "OK."),
+      @ApiResponse(code = 401, message = "Invalid Username or Password."),
+      @ApiResponse(code = 403, message = "Insufficient privileges for operation."),
+      @ApiResponse(code = 500, message = "GemFire throws an error or exception.")})
+  @PreAuthorize("@securityService.authorize('DATA', 'READ')")
-    securityService.authorizeDataRead();
-    if (logger.isDebugEnabled()) {
-      logger.debug("Listing all registered Functions in GemFire...");
-    }
+    logger.debug("Listing all registered Functions in GemFire...");
-    String listFunctionsAsJson = JSONUtils.formulateJsonForListFunctionsCall(registeredFunctions.keySet());
+    String listFunctionsAsJson =
+        JSONUtils.formulateJsonForListFunctionsCall(registeredFunctions.keySet());
-    return new ResponseEntity<String>(listFunctionsAsJson, headers, HttpStatus.OK);
+    return new ResponseEntity<>(listFunctionsAsJson, headers, HttpStatus.OK);
-   * Execute a function on Gemfire data node using REST API call.
-   * Arguments to the function are passed as JSON string in the request body.
-   *
+   * Execute a function on Gemfire data node using REST API call. Arguments to the function are
+   * passed as JSON string in the request body.
+   * 
-   * @param region     list of regions on which function to be executed.
-   * @param members    list of nodes on which function to be executed.
-   * @param groups     list of groups on which function to be executed.
-   * @param filter     list of keys which the function will use to determine on which node to execute the function.
+   * @param region list of regions on which function to be executed.
+   * @param members list of nodes on which function to be executed.
+   * @param groups list of groups on which function to be executed.
+   * @param filter list of keys which the function will use to determine on which node to execute
+   *        the function.
+   *
-  @RequestMapping(method = RequestMethod.POST, value = "/{functionId}", produces = { MediaType.APPLICATION_JSON_VALUE })
-  @ApiOperation(
-      value = "execute function",
+  @RequestMapping(method = RequestMethod.POST, value = "/{functionId:.+}",
+      produces = {MediaType.APPLICATION_JSON_VALUE})
+  @ApiOperation(value = "execute function",
-      response = void.class
-  )
-  @ApiResponses({
-      @ApiResponse(code = 200, message = "OK."),
-      @ApiResponse( code = 401, message = "Invalid Username or Password." ),
-      @ApiResponse( code = 403, message = "Insufficient privileges for operation." ),
+      response = void.class)
+  @ApiResponses({@ApiResponse(code = 200, message = "OK."),
+      @ApiResponse(code = 401, message = "Invalid Username or Password."),
+      @ApiResponse(code = 403, message = "Insufficient privileges for operation."),
-      @ApiResponse(code = 400, message = "if Function arguments specified as JSON document in the request body is invalid")
-  })
+      @ApiResponse(code = 400,
+          message = "if Function arguments specified as JSON document in the request body is invalid")})
+  @PreAuthorize("@securityService.authorize('DATA', 'WRITE')")
-      @RequestBody(required = false) final String argsInBody
-  ) {
-    securityService.authorizeDataWrite();
+      @RequestBody(required = false) final String argsInBody) {
-      if (logger.isDebugEnabled()) {
-        logger.debug("Executing Function ({}) with arguments ({}) on Region ({})...", functionId,
-            ArrayUtils.toString(argsInBody), region);
-      }
+      logger.debug("Executing Function ({}) with arguments ({}) on Region ({})...", functionId,
+          ArrayUtils.toString(argsInBody), region);
-        throw new GemfireRestException(String.format("The Region identified by name (%1$s) could not found!", region), fe);
+        throw new GemfireRestException(
+            String.format("The Region identified by name (%1$s) could not found!", region), fe);
-      if (logger.isDebugEnabled()) {
-        logger.debug("Executing Function ({}) with arguments ({}) on Member ({})...", functionId,
-            ArrayUtils.toString(argsInBody), ArrayUtils.toString(members));
-      }
+      logger.debug("Executing Function ({}) with arguments ({}) on Member ({})...", functionId,
+          ArrayUtils.toString(argsInBody), ArrayUtils.toString(members));
+
-        throw new GemfireRestException("Could not found the specified members in distributed system!", fe);
+        throw new GemfireRestException(
+            "Could not found the specified members in distributed system!", fe);
-      if (logger.isDebugEnabled()) {
-        logger.debug("Executing Function ({}) with arguments ({}) on Groups ({})...", functionId,
-            ArrayUtils.toString(argsInBody), ArrayUtils.toString(groups));
-      }
+      logger.debug("Executing Function ({}) with arguments ({}) on Groups ({})...", functionId,
+          ArrayUtils.toString(argsInBody), ArrayUtils.toString(groups));
+
-        throw new GemfireRestException("no member(s) are found belonging to the provided group(s)!", fe);
+        throw new GemfireRestException("no member(s) are found belonging to the provided group(s)!",
+            fe);
-      //Default case is to execute function on all existing data node in DS, document this.
-      if (logger.isDebugEnabled()) {
-        logger.debug("Executing Function ({}) with arguments ({}) on all Members...", functionId,
-            ArrayUtils.toString(argsInBody));
-      }
+      // Default case is to execute function on all existing data node in DS, document this.
+      logger.debug("Executing Function ({}) with arguments ({}) on all Members...", functionId,
+          ArrayUtils.toString(argsInBody));
-        throw new GemfireRestException("Distributed system does not contain any valid data node to run the specified  function!", fe);
+        throw new GemfireRestException(
+            "Distributed system does not contain any valid data node to run the specified  function!",
+            fe);
-      if (logger.isDebugEnabled()) {
-        logger.debug("Executing Function ({}) with filter ({})", functionId,
-            ArrayUtils.toString(filter));
-      }
+      logger.debug("Executing Function ({}) with filter ({})", functionId,
+          ArrayUtils.toString(filter));
+
-        //execute function with specified arguments
+        // execute function with specified arguments
-        //execute function with no args
+        // execute function with no args
-      throw new GemfireRestException("Specified key is null and this region does not permit null keys!", npe);
+      throw new GemfireRestException(
+          "Specified key is null and this region does not permit null keys!", npe);
-      throw new GemfireRestException("Server has encountered error while executing the function!", fe);
+      throw new GemfireRestException("Server has encountered error while executing the function!",
+          fe);
-          String functionResultAsJson = JSONUtils.convertCollectionToJson((ArrayList<Object>) functionResult);
-          return new ResponseEntity<String>(functionResultAsJson, headers, HttpStatus.OK);
+          String functionResultAsJson =
+              JSONUtils.convertCollectionToJson((ArrayList<Object>) functionResult);
+          return new ResponseEntity<>(functionResultAsJson, headers, HttpStatus.OK);
-          throw new GemfireRestException("Could not convert function results into Restful (JSON) format!", e);
+          throw new GemfireRestException(
+              "Could not convert function results into Restful (JSON) format!", e);
-        throw new GemfireRestException("Function has returned results that could not be converted into Restful (JSON) format!");
+        throw new GemfireRestException(
+            "Function has returned results that could not be converted into Restful (JSON) format!");
-      throw new GemfireRestException("Server has encountered an error while processing function execution!", fe);
+      throw new GemfireRestException(
+          "Server has encountered an error while processing function execution!", fe);

MOV26 MOV26 MOV26 MOV26 INS26 MOV23 UPD40 UPD40 UPD40 UPD40 INS40 INS79 INS79 INS42 INS45 MOV21 INS42 INS45 MOV25 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD45 MOV38 UPD40 UPD74 MOV21 MOV8 MOV60 MOV21 MOV54 MOV8 MOV8 MOV54 MOV54 UPD74 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL8 DEL25 DEL42 DEL42 DEL32 DEL25 DEL8 DEL42 DEL42 DEL32 DEL25 DEL8 DEL42 DEL42 DEL32 DEL25 DEL8 DEL42 DEL42 DEL32 DEL8 DEL25 DEL42 DEL43
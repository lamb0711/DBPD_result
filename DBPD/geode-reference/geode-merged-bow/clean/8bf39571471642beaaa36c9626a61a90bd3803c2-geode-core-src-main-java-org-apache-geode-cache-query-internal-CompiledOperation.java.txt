Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * @version     $Revision: 1.1 $
+ * @version $Revision: 1.1 $
-  
-  
+
+
-  
+
-  
-  public String getMethodName(){
+
+  public String getMethodName() {
-  
+
-  
-  
+
+
-  
+
-      return (CompiledValue)cxt.cacheGet(this);
+      return (CompiledValue) cxt.cacheGet(this);
-  
+
-  public Object evaluate(ExecutionContext context)
-  throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-  QueryInvocationTargetException {
+  public Object evaluate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    
+
-    
+
-      RuntimeIterator rcvrItr = context.resolveImplicitOperationName(this.methodName,
-              this.args.size(), true);
+      RuntimeIterator rcvrItr =
+          context.resolveImplicitOperationName(this.methodName, this.args.size(), true);
-      // evaluate on current iteration of collection
-      if (rcvrItr != null) {
-        result = eval0(rcvrItr.evaluate(context),
-                rcvrItr.getElementType().resolveClass(),
-                context);
-      }
-      
-      // function call: no functions implemented except keywords in the grammar
-      throw new TypeMismatchException(LocalizedStrings.CompiledOperation_COULD_NOT_RESOLVE_METHOD_NAMED_0.toLocalizedString(this.methodName));
-      */
+       * // evaluate on current iteration of collection if (rcvrItr != null) { result =
+       * eval0(rcvrItr.evaluate(context), rcvrItr.getElementType().resolveClass(), context); }
+       * 
+       * // function call: no functions implemented except keywords in the grammar throw new
+       * TypeMismatchException(LocalizedStrings.CompiledOperation_COULD_NOT_RESOLVE_METHOD_NAMED_0.
+       * toLocalizedString(this.methodName));
+       */
-    
-      // short circuit null immediately
-      if (evalRcvr == null)
-      {
+
+    // short circuit null immediately
+    if (evalRcvr == null) {
+      return QueryService.UNDEFINED;
+    }
+
+    if (context.isCqQueryContext() && evalRcvr instanceof Region.Entry) {
+      Region.Entry re = (Region.Entry) evalRcvr;
+      if (re.isDestroyed()) {
-      
-      if (context.isCqQueryContext() && evalRcvr instanceof Region.Entry){
-        Region.Entry re = (Region.Entry)evalRcvr;
-        if (re.isDestroyed()) {
-          return QueryService.UNDEFINED;
-        }
-        try {
-          evalRcvr = re.getValue();
-        } catch (EntryDestroyedException ede){
-          // Even though isDestory() check is made, the entry could 
-          // throw EntryDestroyedException if the value becomes null.
-          return QueryService.UNDEFINED;
-        }
+      try {
+        evalRcvr = re.getValue();
+      } catch (EntryDestroyedException ede) {
+        // Even though isDestory() check is made, the entry could
+        // throw EntryDestroyedException if the value becomes null.
+        return QueryService.UNDEFINED;
+    }
-      // check if the receiver is the iterator, in which
-      // case we resolve the method on the constraint rather
-      // than the runtime type of the receiver
-      Class resolveClass = null;
-      //         commented out because we currently always resolve the method
-      //         on the runtime types
-      
-      //         CompiledValue rcvrVal = rcvrPath.getReceiver();
-      //         if (rcvrVal.getType() == ID)
-      //         {
-      //             CompiledValue resolvedID = context.resolve(((CompiledID)rcvrVal).getId());
-      //             if (resolvedID.getType() == ITERATOR)
-      //             {
-      //                 resolveClass = ((RuntimeIterator)resolvedID).getBaseCollection().getConstraint();
-      //             }
-      //         }
-      //         if (resolveClass == null)
-      if (evalRcvr instanceof PdxInstance) {
-        String className = ((PdxInstance)evalRcvr).getClassName();
-        try {
-          resolveClass = InternalDataSerializer.getCachedClass(className);
-        } catch (ClassNotFoundException cnfe) {
-          throw new QueryInvocationTargetException(cnfe);
-        }
-      } else if (evalRcvr instanceof PdxString) {
-        resolveClass = String.class;
-      } else {
-        resolveClass = evalRcvr.getClass();
+    // check if the receiver is the iterator, in which
+    // case we resolve the method on the constraint rather
+    // than the runtime type of the receiver
+    Class resolveClass = null;
+    // commented out because we currently always resolve the method
+    // on the runtime types
+
+    // CompiledValue rcvrVal = rcvrPath.getReceiver();
+    // if (rcvrVal.getType() == ID)
+    // {
+    // CompiledValue resolvedID = context.resolve(((CompiledID)rcvrVal).getId());
+    // if (resolvedID.getType() == ITERATOR)
+    // {
+    // resolveClass = ((RuntimeIterator)resolvedID).getBaseCollection().getConstraint();
+    // }
+    // }
+    // if (resolveClass == null)
+    if (evalRcvr instanceof PdxInstance) {
+      String className = ((PdxInstance) evalRcvr).getClassName();
+      try {
+        resolveClass = InternalDataSerializer.getCachedClass(className);
+      } catch (ClassNotFoundException cnfe) {
+        throw new QueryInvocationTargetException(cnfe);
-      
-      result = eval0(evalRcvr, resolveClass, context);
-    //}
+    } else if (evalRcvr instanceof PdxString) {
+      resolveClass = String.class;
+    } else {
+      resolveClass = evalRcvr.getClass();
+    }
+
+    result = eval0(evalRcvr, resolveClass, context);
+    // }
-      if (pr.getFullPath().equals(((Region)result).getFullPath())) {
+      if (pr.getFullPath().equals(((Region) result).getFullPath())) {
-  
-  
-  
+
+
+
-  throws TypeMismatchException, AmbiguousNameException, NameResolutionException {
+      throws TypeMismatchException, AmbiguousNameException, NameResolutionException {
-      context.addDependencies(this, ((CompiledValue)i.next()).computeDependencies(context));
+      context.addDependencies(this, ((CompiledValue) i.next()).computeDependencies(context));
-    
+
-      RuntimeIterator rcvrItr = context.resolveImplicitOperationName(this.methodName,
-              this.args.size(), true);
+      RuntimeIterator rcvrItr =
+          context.resolveImplicitOperationName(this.methodName, this.args.size(), true);
-            // function call: no functions implemented except keywords in the grammar
-        throw new TypeMismatchException(LocalizedStrings.CompiledOperation_COULD_NOT_RESOLVE_METHOD_NAMED_0.toLocalizedString(this.methodName));
+        // function call: no functions implemented except keywords in the grammar
+        throw new TypeMismatchException(
+            LocalizedStrings.CompiledOperation_COULD_NOT_RESOLVE_METHOD_NAMED_0
+                .toLocalizedString(this.methodName));
-    
+
- 
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED", justification="Does not matter if the methodDispatch that isn't stored in the map is used") 
+
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(
+      value = "RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED",
+      justification = "Does not matter if the methodDispatch that isn't stored in the map is used")
-  throws TypeMismatchException, FunctionDomainException, NameResolutionException,
-          QueryInvocationTargetException {
+      throws TypeMismatchException, FunctionDomainException, NameResolutionException,
+      QueryInvocationTargetException {
-    
+
-      CompiledValue arg = (CompiledValue)i.next();
+      CompiledValue arg = (CompiledValue) i.next();
-      
+
-      
+
-      //             else if (arg.getType() == Identifier)
-      //             {
-      //                 CompiledValue resolved = context.resolve(((CompiledID)arg).getId());
-      //                 if (resolved != null && resolved.getType() == ITERATOR)
-      //                     argTypes.add(((RuntimeIterator)resolved).getBaseCollection().getConstraint());
-      //                 else
-      //                     argTypes.add(o.getClass());
-      //             }
+      // else if (arg.getType() == Identifier)
+      // {
+      // CompiledValue resolved = context.resolve(((CompiledID)arg).getId());
+      // if (resolved != null && resolved.getType() == ITERATOR)
+      // argTypes.add(((RuntimeIterator)resolved).getBaseCollection().getConstraint());
+      // else
+      // argTypes.add(o.getClass());
+      // }
-    
+
-    List key = Arrays.asList(new Object[] { resolutionType , this.methodName, argTypes });
-    methodDispatch = (MethodDispatch)CompiledOperation.cache.get(key);
+    List key = Arrays.asList(new Object[] {resolutionType, this.methodName, argTypes});
+    methodDispatch = (MethodDispatch) CompiledOperation.cache.get(key);
-      } catch(NameResolutionException nre) {         
-        if (!org.apache.geode.cache.query.Struct.class.isAssignableFrom(resolutionType) &&
-            (DefaultQueryService.QUERY_HETEROGENEOUS_OBJECTS ||
-             DefaultQueryService.TEST_QUERY_HETEROGENEOUS_OBJECTS)) {
+      } catch (NameResolutionException nre) {
+        if (!org.apache.geode.cache.query.Struct.class.isAssignableFrom(resolutionType)
+            && (DefaultQueryService.QUERY_HETEROGENEOUS_OBJECTS
+                || DefaultQueryService.TEST_QUERY_HETEROGENEOUS_OBJECTS)) {
-        } else {         
-          throw nre;  
-        } 
-      } 
+        } else {
+          throw nre;
+        }
+      }
-          receiver = ((PdxInstanceImpl)receiver).getCachedObject();
+          receiver = ((PdxInstanceImpl) receiver).getCachedObject();
-          receiver = ((PdxInstance)receiver).getObject();
+          receiver = ((PdxInstance) receiver).getObject();
-      receiver = ((PdxString)receiver).toString();
+      receiver = ((PdxString) receiver).toString();
-  
-  //Asif :Function for generating from clause
+
+  // Asif :Function for generating from clause
-  throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-    //  Asif: if the method name starts with getABC & argument list is empty
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+    // Asif: if the method name starts with getABC & argument list is empty
-    if (this.methodName.startsWith("get") && ( len = this.methodName.length()) > 3
-            && ( this.args == null || this.args.isEmpty())) {
-      clauseBuffer.insert(0, len > 4 ? this.methodName.substring(4) : "" );
+    if (this.methodName.startsWith("get") && (len = this.methodName.length()) > 3
+        && (this.args == null || this.args.isEmpty())) {
+      clauseBuffer.insert(0, len > 4 ? this.methodName.substring(4) : "");
-    }
-    else if (this.args == null || this.args.isEmpty()) {
+    } else if (this.args == null || this.args.isEmpty()) {
-    }
-    else {
-      //The method contains arguments which need to be canonicalized
+    } else {
+      // The method contains arguments which need to be canonicalized
-      CompiledValue  cv = null;
-      for (int j = this.args.size(); j > 0; ) {
-        cv =(CompiledValue) this.args.get(--j);
-        cv. generateCanonicalizedExpression(clauseBuffer, context);
+      CompiledValue cv = null;
+      for (int j = this.args.size(); j > 0;) {
+        cv = (CompiledValue) this.args.get(--j);
+        cv.generateCanonicalizedExpression(clauseBuffer, context);
-      
+
-    rcvr.generateCanonicalizedExpression(clauseBuffer,context);
+    rcvr.generateCanonicalizedExpression(clauseBuffer, context);
-  
+

UPD66
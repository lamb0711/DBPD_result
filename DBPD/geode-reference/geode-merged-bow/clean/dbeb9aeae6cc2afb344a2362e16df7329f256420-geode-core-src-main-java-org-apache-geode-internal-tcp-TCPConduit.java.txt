Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import java.net.SocketAddress;
- * <p>TCPConduit manages a server socket and a collection of connections to
- * other systems.  Connections are identified by DistributedMember IDs.
- * These types of messages are currently supported:</p><pre>
+ * <p>
+ * TCPConduit manages a server socket and a collection of connections to other systems. Connections
+ * are identified by DistributedMember IDs. These types of messages are currently supported:
+ * </p>
+ * 
+ * <pre>
- * <p>In the current implementation, ServerDelegate is the DirectChannel
- * used by the GemFire DistributionManager to send and receive messages.<p>
- * If the ServerDelegate is null, DistributionMessages are ignored by
- * the TCPConduit.</p>
+ * <p>
+ * In the current implementation, ServerDelegate is the DirectChannel used by the GemFire
+ * DistributionManager to send and receive messages.
+ * <p>
+ * If the ServerDelegate is null, DistributionMessages are ignored by the TCPConduit.
+ * </p>
+ * 
-   * backlog is the "accept" backlog configuration parameter all
-   * conduits server socket
+   * backlog is the "accept" backlog configuration parameter all conduits server socket
-  //   public final static boolean USE_SYNC_WRITES = Boolean.getBoolean("p2p.useSyncWrites");
+  // public final static boolean USE_SYNC_WRITES = Boolean.getBoolean("p2p.useSyncWrites");
-   * Force use of Sockets rather than SocketChannels (NIO).  Note from Bruce: due to
-   * a bug in the java VM, NIO cannot be used with IPv6 addresses on Windows.
-   * When that condition holds, the useNIO flag must be disregarded.
+   * Force use of Sockets rather than SocketChannels (NIO). Note from Bruce: due to a bug in the
+   * java VM, NIO cannot be used with IPv6 addresses on Windows. When that condition holds, the
+   * useNIO flag must be disregarded.
-   * port is the tcp/ip port that this conduit binds to. If it is zero, a port
-   * from membership-port-range is selected to bind to. The actual port number this
-   * conduit is listening on will be in the "id" instance variable
+   * port is the tcp/ip port that this conduit binds to. If it is zero, a port from
+   * membership-port-range is selected to bind to. The actual port number this conduit is listening
+   * on will be in the "id" instance variable
-  private int[] tcpPortRange = new int[] { 1024, 65535 };
+  private int[] tcpPortRange = new int[] {1024, 65535};
-   * the object that receives DistributionMessage messages
-   * received by this conduit.
+   * the object that receives DistributionMessage messages received by this conduit.
+   * 
-   * <p>creates a new TCPConduit bound to the given InetAddress and port.
-   * The given ServerDelegate will receive any DistributionMessages
-   * passed to the conduit.</p>
-   * <p>This constructor forces the conduit to ignore the following
-   * system properties and look for them only in the <i>props</i> argument:</p>
+   * <p>
+   * creates a new TCPConduit bound to the given InetAddress and port. The given ServerDelegate will
+   * receive any DistributionMessages passed to the conduit.
+   * </p>
+   * <p>
+   * This constructor forces the conduit to ignore the following system properties and look for them
+   * only in the <i>props</i> argument:
+   * </p>
+   * 
-  public TCPConduit(MembershipManager mgr, int port, InetAddress address, boolean isBindAddress, DirectChannel receiver, Properties props)
-    throws ConnectionException {
+  public TCPConduit(MembershipManager mgr, int port, InetAddress address, boolean isBindAddress,
+      DirectChannel receiver, Properties props) throws ConnectionException {
-      throw new ConnectionException(LocalizedStrings.TCPConduit_UNABLE_TO_INITIALIZE_CONNECTION_TABLE.toLocalizedString(), io);
+      throw new ConnectionException(
+          LocalizedStrings.TCPConduit_UNABLE_TO_INITIALIZE_CONNECTION_TABLE.toLocalizedString(),
+          io);
-    
-    this.socketCreator = SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER);
-    
+
+    this.socketCreator =
+        SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER);
+
-    }    
+    }
-        logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_P2PTCPBUFFERSIZE), e);
+        logger.warn(
+            LocalizedMessage.create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_P2PTCPBUFFERSIZE),
+            e);
-        logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_P2PIDLECONNECTIONTIMEOUT), e);
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_P2PIDLECONNECTIONTIMEOUT), e);
-        logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_TCPPORTRANGESTART), e);
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_TCPPORTRANGESTART), e);
-        logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_TCPPORTRANGEEND), e);
+        logger.warn(
+            LocalizedMessage.create(LocalizedStrings.TCPConduit_EXCEPTION_PARSING_TCPPORTRANGEEND),
+            e);
-  private final static int HANDSHAKE_POOL_SIZE = Integer.getInteger("p2p.HANDSHAKE_POOL_SIZE", 10).intValue();
-  private final static long HANDSHAKE_POOL_KEEP_ALIVE_TIME = Long.getLong("p2p.HANDSHAKE_POOL_KEEP_ALIVE_TIME", 60).longValue();
+  private final static int HANDSHAKE_POOL_SIZE =
+      Integer.getInteger("p2p.HANDSHAKE_POOL_SIZE", 10).intValue();
+  private final static long HANDSHAKE_POOL_KEEP_ALIVE_TIME =
+      Long.getLong("p2p.HANDSHAKE_POOL_KEEP_ALIVE_TIME", 60).longValue();
-              throw new RejectedExecutionException(LocalizedStrings.TCPConduit_INTERRUPTED.toLocalizedString(), ex);
+              throw new RejectedExecutionException(
+                  LocalizedStrings.TCPConduit_INTERRUPTED.toLocalizedString(), ex);
-        tmp_hsPool = new ThreadPoolExecutor(1, HANDSHAKE_POOL_SIZE, HANDSHAKE_POOL_KEEP_ALIVE_TIME, TimeUnit.SECONDS, bq, socketThreadFactory, reh);
+        tmp_hsPool = new ThreadPoolExecutor(1, HANDSHAKE_POOL_SIZE, HANDSHAKE_POOL_KEEP_ALIVE_TIME,
+            TimeUnit.SECONDS, bq, socketThreadFactory, reh);
-        throw new ConnectionException(LocalizedStrings.TCPConduit_WHILE_CREATING_HANDSHAKE_POOL.toLocalizedString(), poolInitException);
+        throw new ConnectionException(
+            LocalizedStrings.TCPConduit_WHILE_CREATING_HANDSHAKE_POOL.toLocalizedString(),
+            poolInitException);
-        logger.info(LocalizedMessage.create(LocalizedStrings.TCPConduit_UNABLE_TO_SET_LISTENER_PRIORITY__0, e.getMessage()));
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.TCPConduit_UNABLE_TO_SET_LISTENER_PRIORITY__0, e.getMessage()));
-   * creates the server sockets.  This can be used to recreate the
-   * socket using this.port and this.bindAddress, which must be set
-   * before invoking this method.
+   * creates the server sockets. This can be used to recreate the socket using this.port and
+   * this.bindAddress, which must be set before invoking this method.
-          socket = socketCreator.createServerSocketUsingPortRange(bindAddress, b, isBindAddress, this.useNIO, 0, tcpPortRange);
+          socket = socketCreator.createServerSocketUsingPortRange(bindAddress, b, isBindAddress,
+              this.useNIO, 0, tcpPortRange);
-          InetSocketAddress inetSocketAddress = new InetSocketAddress(isBindAddress ? bindAddress : null, p);
+          InetSocketAddress inetSocketAddress =
+              new InetSocketAddress(isBindAddress ? bindAddress : null, p);
-              logger.info(LocalizedMessage.create(LocalizedStrings.TCPConduit_0_IS_1_INSTEAD_OF_THE_REQUESTED_2, new Object[] {
-                "Listener receiverBufferSize", Integer.valueOf(newSize), Integer.valueOf(tcpBufferSize)
-              }));
+              logger.info(LocalizedMessage.create(
+                  LocalizedStrings.TCPConduit_0_IS_1_INSTEAD_OF_THE_REQUESTED_2,
+                  new Object[] {"Listener receiverBufferSize", Integer.valueOf(newSize),
+                      Integer.valueOf(tcpBufferSize)}));
-            logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_FAILED_TO_SET_LISTENER_RECEIVERBUFFERSIZE_TO__0, tcpBufferSize));
+            logger.warn(LocalizedMessage.create(
+                LocalizedStrings.TCPConduit_FAILED_TO_SET_LISTENER_RECEIVERBUFFERSIZE_TO__0,
+                tcpBufferSize));
-            socket = socketCreator.createServerSocketUsingPortRange(bindAddress, b, isBindAddress, this.useNIO, this.tcpBufferSize, tcpPortRange);
+            socket = socketCreator.createServerSocketUsingPortRange(bindAddress, b, isBindAddress,
+                this.useNIO, this.tcpBufferSize, tcpPortRange);
-            socket = socketCreator.createServerSocket(p, b, isBindAddress ? bindAddress : null, this.tcpBufferSize);
+            socket = socketCreator.createServerSocket(p, b, isBindAddress ? bindAddress : null,
+                this.tcpBufferSize);
-            logger.info(LocalizedMessage.create(LocalizedStrings.TCPConduit_0_IS_1_INSTEAD_OF_THE_REQUESTED_2, new Object[] {
-              "Listener receiverBufferSize", Integer.valueOf(newSize), Integer.valueOf(this.tcpBufferSize)
-            }));
+            logger.info(LocalizedMessage.create(
+                LocalizedStrings.TCPConduit_0_IS_1_INSTEAD_OF_THE_REQUESTED_2,
+                new Object[] {"Listener receiverBufferSize", Integer.valueOf(newSize),
+                    Integer.valueOf(this.tcpBufferSize)}));
-          logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_FAILED_TO_SET_LISTENER_RECEIVERBUFFERSIZE_TO__0, this.tcpBufferSize));
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.TCPConduit_FAILED_TO_SET_LISTENER_RECEIVERBUFFERSIZE_TO__0,
+              this.tcpBufferSize));
-      throw new ConnectionException(LocalizedStrings.TCPConduit_EXCEPTION_CREATING_SERVERSOCKET.toLocalizedString(new Object[] {
-        Integer.valueOf(p),
-        bindAddress
-      }), io);
+      throw new ConnectionException(LocalizedStrings.TCPConduit_EXCEPTION_CREATING_SERVERSOCKET
+          .toLocalizedString(new Object[] {Integer.valueOf(p), bindAddress}), io);
+   * 
-   * Close the ServerSocketChannel, ServerSocket, and the
-   * ConnectionTable.
+   * Close the ServerSocketChannel, ServerSocket, and the ConnectionTable.
+   * 
-    //    stop(); // Causes grief
+    // stop(); // Causes grief
-    //    System.err.println("DEBUG: TCPConduit emergencyClose");
+    // System.err.println("DEBUG: TCPConduit emergencyClose");
-    //  this.conTable.close(); not safe against deadlocks
+    // this.conTable.close(); not safe against deadlocks
-    //    System.err.println("DEBUG: end of TCPConduit emergencyClose");
+    // System.err.println("DEBUG: end of TCPConduit emergencyClose");
-        Thread t = this.thread;
-        ;
+        Thread t = this.thread;;
-          logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_UNABLE_TO_SHUT_DOWN_LISTENER_WITHIN_0_MS_UNABLE_TO_INTERRUPT_SOCKET_ACCEPT_DUE_TO_JDK_BUG_GIVING_UP, Integer
-            .valueOf(LISTENER_CLOSE_TIMEOUT)));
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.TCPConduit_UNABLE_TO_SHUT_DOWN_LISTENER_WITHIN_0_MS_UNABLE_TO_INTERRUPT_SOCKET_ACCEPT_DUE_TO_JDK_BUG_GIVING_UP,
+              Integer.valueOf(LISTENER_CLOSE_TIMEOUT)));
+   * 
-   * starts the conduit again after it's been stopped.  This will clear the
-   * server map if the conduit's port is zero (wildcard bind)
+   * starts the conduit again after it's been stopped. This will clear the server map if the
+   * conduit's port is zero (wildcard bind)
-      throw new ConnectionException(LocalizedStrings.TCPConduit_UNABLE_TO_INITIALIZE_CONNECTION_TABLE.toLocalizedString(), io);
+      throw new ConnectionException(
+          LocalizedStrings.TCPConduit_UNABLE_TO_INITIALIZE_CONNECTION_TABLE.toLocalizedString(),
+          io);
-    for (; ; ) {
+    for (;;) {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_STOPPING_P2P_LISTENER_DUE_TO_SSL_CONFIGURATION_PROBLEM), ex);
+            logger.warn(
+                LocalizedMessage.create(
+                    LocalizedStrings.TCPConduit_STOPPING_P2P_LISTENER_DUE_TO_SSL_CONFIGURATION_PROBLEM),
+                ex);
-        //safe to ignore
+        // safe to ignore
-              logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_SERVERSOCKET_THREW_SOCKET_CLOSED_EXCEPTION_BUT_SAYS_IT_IS_NOT_CLOSED), e);
+              logger.warn(
+                  LocalizedMessage.create(
+                      LocalizedStrings.TCPConduit_SERVERSOCKET_THREW_SOCKET_CLOSED_EXCEPTION_BUT_SAYS_IT_IS_NOT_CLOSED),
+                  e);
-                logger.fatal(LocalizedMessage.create(LocalizedStrings.TCPConduit_UNABLE_TO_CLOSE_AND_RECREATE_SERVER_SOCKET), ioe);
+                logger.fatal(
+                    LocalizedMessage.create(
+                        LocalizedStrings.TCPConduit_UNABLE_TO_CLOSE_AND_RECREATE_SERVER_SOCKET),
+                    ioe);
-                  logger.info(LocalizedMessage.create(LocalizedStrings.TCPConduit_INTERRUPTED_AND_EXITING_WHILE_TRYING_TO_RECREATE_LISTENER_SOCKETS));
+                  logger.info(LocalizedMessage.create(
+                      LocalizedStrings.TCPConduit_INTERRUPTED_AND_EXITING_WHILE_TRYING_TO_RECREATE_LISTENER_SOCKETS));
-        //connections.cleanupLowWater();
+        // connections.cleanupLowWater();
-        // NOTE: do not check for distributed system closing here.  Messaging
+        // NOTE: do not check for distributed system closing here. Messaging
-        logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_SERVERSOCKET_CLOSED_REOPENING));
+        logger.warn(
+            LocalizedMessage.create(LocalizedStrings.TCPConduit_SERVERSOCKET_CLOSED_REOPENING));
-      throw new DistributedSystemDisconnectedException(LocalizedStrings.TCPConduit_TCP_LAYER_HAS_BEEN_SHUTDOWN.toLocalizedString());
+      throw new DistributedSystemDisconnectedException(
+          LocalizedStrings.TCPConduit_TCP_LAYER_HAS_BEEN_SHUTDOWN.toLocalizedString());
-        //        if (e instanceof SocketException
-        //            && "Socket closed".equals(e.getMessage())) {
-        //          // safe to ignore; see bug 31156
-        //        }
-        //        else
+        // if (e instanceof SocketException
+        // && "Socket closed".equals(e.getMessage())) {
+        // // safe to ignore; see bug 31156
+        // }
+        // else
-          logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_FAILED_TO_ACCEPT_CONNECTION_FROM_0_BECAUSE_1, new Object[] {
-            othersock.getInetAddress(), e
-          }), e);
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.TCPConduit_FAILED_TO_ACCEPT_CONNECTION_FROM_0_BECAUSE_1,
+              new Object[] {othersock.getInetAddress(), e}), e);
-      //connections.cleanupLowWater();
+      // connections.cleanupLowWater();
-   * records the current outgoing message count on all thread-owned
-   * ordered connections
+   * records the current outgoing message count on all thread-owned ordered connections
+   * 
-   * wait for the incoming connections identified by the keys in the
-   * argument to receive and dispatch the number of messages associated
-   * with the key
+   * wait for the incoming connections identified by the keys in the argument to receive and
+   * dispatch the number of messages associated with the key
+   * 
-  public void waitForThreadOwnedOrderedConnectionState(DistributedMember member, Map channelState) throws InterruptedException {
-    // if (Thread.interrupted()) throw new InterruptedException(); not necessary done in waitForThreadOwnedOrderedConnectionState
+  public void waitForThreadOwnedOrderedConnectionState(DistributedMember member, Map channelState)
+      throws InterruptedException {
+    // if (Thread.interrupted()) throw new InterruptedException(); not necessary done in
+    // waitForThreadOwnedOrderedConnectionState
-   * connections send messageReceived when a message object has been
-   * read.
+   * connections send messageReceived when a message object has been read.
+   * 
-   * gets the requested port that this TCPConduit bound to.  This could
-   * be zero if a wildcard bind was done
+   * gets the requested port that this TCPConduit bound to. This could be zero if a wildcard bind
+   * was done
-   * Return a connection to the given member.   This method must continue
-   * to attempt to create a connection to the given member as long as that
-   * member is in the membership view and the system is not shutting down.
+   * returns the socket address used for accepting connections
+   */
+  public SocketAddress getAddress() {
+    if (socket == null) {
+      return null;
+    }
+    if (address != null) {
+      return new InetSocketAddress(address, socket.getLocalPort());
+    }
+    return socket.getLocalSocketAddress();
+  }
+
+  /**
+   * Return a connection to the given member. This method must continue to attempt to create a
+   * connection to the given member as long as that member is in the membership view and the system
+   * is not shutting down.
+   * 
-   * @param ackSATimeout the ack-severe-alert-threshold * 1000 for the operation to be transmitted (or zero)
+   * @param ackSATimeout the ack-severe-alert-threshold * 1000 for the operation to be transmitted
+   *        (or zero)
-                                  final boolean preserveOrder,
-                                  boolean retry,
-                                  long startTime,
-                                  long ackTimeout,
-                                  long ackSATimeout) throws java.io.IOException, DistributedSystemDisconnectedException {
-    //final boolean preserveOrder = (processorType == DistributionManager.SERIAL_EXECUTOR )|| (processorType == DistributionManager.PARTITIONED_REGION_EXECUTOR);
+      final boolean preserveOrder, boolean retry, long startTime, long ackTimeout,
+      long ackSATimeout) throws java.io.IOException, DistributedSystemDisconnectedException {
+    // final boolean preserveOrder = (processorType == DistributionManager.SERIAL_EXECUTOR )||
+    // (processorType == DistributionManager.PARTITIONED_REGION_EXECUTOR);
-      throw new DistributedSystemDisconnectedException(LocalizedStrings.TCPConduit_THE_CONDUIT_IS_STOPPED.toLocalizedString());
+      throw new DistributedSystemDisconnectedException(
+          LocalizedStrings.TCPConduit_THE_CONDUIT_IS_STOPPED.toLocalizedString());
-    for (; ; ) {
+    for (;;) {
-        // problems.  Tear down the connection so that it gets
+        // problems. Tear down the connection so that it gets
-          if (!membershipManager.memberExists(memberAddress) || membershipManager.isShunned(memberAddress) || membershipManager.shutdownInProgress()) {
-            throw new IOException(LocalizedStrings.TCPConduit_TCPIP_CONNECTION_LOST_AND_MEMBER_IS_NOT_IN_VIEW.toLocalizedString());
+          if (!membershipManager.memberExists(memberAddress)
+              || membershipManager.isShunned(memberAddress)
+              || membershipManager.shutdownInProgress()) {
+            throw new IOException(
+                LocalizedStrings.TCPConduit_TCPIP_CONNECTION_LOST_AND_MEMBER_IS_NOT_IN_VIEW
+                    .toLocalizedString());
-          if (!membershipManager.memberExists(memberAddress) || membershipManager.isShunned(memberAddress)) {
-            // OK, the member left.  Just register an error.
-            throw new IOException(LocalizedStrings.TCPConduit_TCPIP_CONNECTION_LOST_AND_MEMBER_IS_NOT_IN_VIEW.toLocalizedString());
+          if (!membershipManager.memberExists(memberAddress)
+              || membershipManager.isShunned(memberAddress)) {
+            // OK, the member left. Just register an error.
+            throw new IOException(
+                LocalizedStrings.TCPConduit_TCPIP_CONNECTION_LOST_AND_MEMBER_IS_NOT_IN_VIEW
+                    .toLocalizedString());
-            logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_ATTEMPTING_TCPIP_RECONNECT_TO__0, memberInTrouble));
+            logger.warn(LocalizedMessage.create(
+                LocalizedStrings.TCPConduit_ATTEMPTING_TCPIP_RECONNECT_TO__0, memberInTrouble));
-                logger.debug("Closing old connection.  conn={} before retrying. memberInTrouble={}", conn, memberInTrouble);
+                logger.debug("Closing old connection.  conn={} before retrying. memberInTrouble={}",
+                    conn, memberInTrouble);
-            conn = getConTable().get(memberAddress, preserveOrder, startTime, ackTimeout, ackSATimeout);
+            conn = getConTable().get(memberAddress, preserveOrder, startTime, ackTimeout,
+                ackSATimeout);
-              problem = new IOException(LocalizedStrings.TCPConduit_UNABLE_TO_RECONNECT_TO_SERVER_POSSIBLE_SHUTDOWN_0.toLocalizedString(memberAddress));
+              problem = new IOException(
+                  LocalizedStrings.TCPConduit_UNABLE_TO_RECONNECT_TO_SERVER_POSSIBLE_SHUTDOWN_0
+                      .toLocalizedString(memberAddress));
-                logger.debug("Got an old connection for {}: {}@{}", memberAddress, conn, conn.hashCode());
+                logger.debug("Got an old connection for {}: {}@{}", memberAddress, conn,
+                    conn.hashCode());
-          if (!membershipManager.memberExists(memberAddress) || membershipManager.isShunned(memberAddress)) { // left the view
+          if (!membershipManager.memberExists(memberAddress)
+              || membershipManager.isShunned(memberAddress)) { // left the view
-              logger.info(LocalizedMessage.create(LocalizedStrings.TCPConduit_ENDING_RECONNECT_ATTEMPT_BECAUSE_0_HAS_DISAPPEARED, memberInTrouble));
+              logger.info(LocalizedMessage.create(
+                  LocalizedStrings.TCPConduit_ENDING_RECONNECT_ATTEMPT_BECAUSE_0_HAS_DISAPPEARED,
+                  memberInTrouble));
-            throw new IOException(LocalizedStrings.TCPConduit_PEER_HAS_DISAPPEARED_FROM_VIEW.toLocalizedString(memberAddress));
+            throw new IOException(LocalizedStrings.TCPConduit_PEER_HAS_DISAPPEARED_FROM_VIEW
+                .toLocalizedString(memberAddress));
-              logger.info(LocalizedMessage.create(LocalizedStrings.TCPConduit_ENDING_RECONNECT_ATTEMPT_TO_0_BECAUSE_SHUTDOWN_HAS_STARTED, memberInTrouble));
+              logger.info(LocalizedMessage.create(
+                  LocalizedStrings.TCPConduit_ENDING_RECONNECT_ATTEMPT_TO_0_BECAUSE_SHUTDOWN_HAS_STARTED,
+                  memberInTrouble));
-            throw new DistributedSystemDisconnectedException(LocalizedStrings.TCPConduit_ABANDONED_BECAUSE_SHUTDOWN_IS_IN_PROGRESS.toLocalizedString());
+            throw new DistributedSystemDisconnectedException(
+                LocalizedStrings.TCPConduit_ABANDONED_BECAUSE_SHUTDOWN_IS_IN_PROGRESS
+                    .toLocalizedString());
-          // Log the warning.  We wait until now, because we want
+          // Log the warning. We wait until now, because we want
-            logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_ERROR_SENDING_MESSAGE_TO_0_WILL_REATTEMPT_1, new Object[] {
-              memberAddress, problem
-            }));
+            logger.warn(LocalizedMessage.create(
+                LocalizedStrings.TCPConduit_ERROR_SENDING_MESSAGE_TO_0_WILL_REATTEMPT_1,
+                new Object[] {memberAddress, problem}));
-              logger.warn(LocalizedMessage.create(LocalizedStrings.TCPConduit_THROWING_IOEXCEPTION_AFTER_FINDING_BREAKLOOP_TRUE), problem);
+              logger.warn(
+                  LocalizedMessage.create(
+                      LocalizedStrings.TCPConduit_THROWING_IOEXCEPTION_AFTER_FINDING_BREAKLOOP_TRUE),
+                  problem);
-              IOException ioe = new IOException(LocalizedStrings.TCPConduit_PROBLEM_CONNECTING_TO_0.toLocalizedString(memberAddress));
+              IOException ioe = new IOException(LocalizedStrings.TCPConduit_PROBLEM_CONNECTING_TO_0
+                  .toLocalizedString(memberAddress));
-          logger.info(LocalizedMessage.create(LocalizedStrings.TCPConduit_SUCCESSFULLY_RECONNECTED_TO_MEMBER_0, memberInTrouble));
+          logger.info(LocalizedMessage.create(
+              LocalizedStrings.TCPConduit_SUCCESSFULLY_RECONNECTED_TO_MEMBER_0, memberInTrouble));
-    /* (non-Javadoc)
+    /*
+     * (non-Javadoc)
+     * 
-    /* (non-Javadoc)
+    /*
+     * (non-Javadoc)
+     * 
-   * if the conduit is disconnected due to an abnormal condition, this
-   * will describe the reason
+   * if the conduit is disconnected due to an abnormal condition, this will describe the reason
+   * 
-   * returns the SocketCreator that should be used to produce
-   * sockets for TCPConduit connections.
+   * returns the SocketCreator that should be used to produce sockets for TCPConduit connections.
-   * ARB: Called by Connection before handshake reply is sent.
-   * Returns true if member is part of view, false if membership is not confirmed before timeout.
+   * ARB: Called by Connection before handshake reply is sent. Returns true if member is part of
+   * view, false if membership is not confirmed before timeout.
-    //    this.inhibitNewConnections = true;
-    //    this.conTable.closeReceivers(true);
+    // this.inhibitNewConnections = true;
+    // this.conTable.closeReceivers(true);
-    //    this.inhibitNewConnections = false;
+    // this.inhibitNewConnections = false;

INS26 INS40 INS31 INS29 INS83 INS43 INS42 INS8 INS66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 INS66 UPD66 UPD66 INS65 INS42 INS25 INS25 INS41 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS27 INS8 INS27 INS8 INS32 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 INS42 INS33 INS41 INS42 INS33 INS41 INS42 INS42 INS33 INS14 INS43 INS42 INS32 INS42 INS42 INS42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
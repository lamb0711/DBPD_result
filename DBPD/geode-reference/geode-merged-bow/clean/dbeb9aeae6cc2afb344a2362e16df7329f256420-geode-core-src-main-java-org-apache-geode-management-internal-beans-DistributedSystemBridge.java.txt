Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This is the gateway to distributed system as a whole. Aggregated metrics and
- * stats are shown which collects data from all the available proxies.
+ * This is the gateway to distributed system as a whole. Aggregated metrics and stats are shown
+ * which collects data from all the available proxies.
- * Operation strategy is not fixed. Some of the operations operate on local
- * proxies. Some uses admin messaging for distributed message.
+ * Operation strategy is not fixed. Some of the operations operate on local proxies. Some uses admin
+ * messaging for distributed message.
-  
+
-  private  ObjectName thisMemberName;
+  private ObjectName thisMemberName;
-   * Distributed System level listener to listen on all the member level
-   * notifications It will then send the notification up the JMX layer in the
-   * name of DistributedSystemMBean.
+   * Distributed System level listener to listen on all the member level notifications It will then
+   * send the notification up the JMX layer in the name of DistributedSystemMBean.
-
-   * emitter is a helper class for sending notifications on behalf of the
-   * MemberMBean
+   * emitter is a helper class for sending notifications on behalf of the MemberMBean
-  
+
-   * NUmber of elements to be shown in queryData operation if query results contain collections like Map, List etc.
+   * NUmber of elements to be shown in queryData operation if query results contain collections like
+   * Map, List etc.
-   
+
-   * @param member
-   *          name or id of the member
+   * @param member name or id of the member
-    try{
+    try {
-    }catch(ManagementException mx){
+    } catch (ManagementException mx) {
-   * @param service
-   *          Management service
+   * @param service Management service
-    this.thisMemberName = MBeanJMXAdapter
-    .getMemberMBeanName(system.getDistributedMember());
+    this.thisMemberName = MBeanJMXAdapter.getMemberMBeanName(system.getDistributedMember());
-  private void initClusterMonitors(){
+  private void initClusterMonitors() {
-    this.senderMonitor      = new GatewaySenderClusterStatsMonitor();
-    this.receiverMonitor    = new GatewayReceiverClusterStatsMonitor();
+    this.senderMonitor = new GatewaySenderClusterStatsMonitor();
+    this.receiverMonitor = new GatewayReceiverClusterStatsMonitor();
-   * @param objectName
-   *          object name of the proxy
-   * @param proxy
-   *          actual proxy instance
+   * @param objectName object name of the proxy
+   * @param proxy actual proxy instance
-  public void addMemberToSystem(ObjectName objectName, MemberMXBean proxy, FederationComponent newState) {
+  public void addMemberToSystem(ObjectName objectName, MemberMXBean proxy,
+      FederationComponent newState) {
-      
+
-      
+
-  public void updateCacheServer(ObjectName objectName,
-      FederationComponent newState, FederationComponent oldState) {
+  public void updateCacheServer(ObjectName objectName, FederationComponent newState,
+      FederationComponent oldState) {
-  public void updateGatewaySender(ObjectName objectName,
-      FederationComponent newState, FederationComponent oldState) {
+  public void updateGatewaySender(ObjectName objectName, FederationComponent newState,
+      FederationComponent oldState) {
-  public void updateGatewayReceiver(ObjectName objectName,
-      FederationComponent newState, FederationComponent oldState) {
+  public void updateGatewayReceiver(ObjectName objectName, FederationComponent newState,
+      FederationComponent oldState) {
-   * @param objectName
-   *          name of the proxy to be removed.
-   * @param proxy
-   *          actual reference to the proxy object
-   * @return whether all proxies have been removed or not. In this case it will
-   *         always be false. Kept it for consistency for MBeanAggregator.
+   * @param objectName name of the proxy to be removed.
+   * @param proxy actual reference to the proxy object
+   * @return whether all proxies have been removed or not. In this case it will always be false.
+   *         Kept it for consistency for MBeanAggregator.
-  public boolean removeMemberFromSystem(ObjectName objectName,
-      MemberMXBean proxy, FederationComponent oldState) {
+  public boolean removeMemberFromSystem(ObjectName objectName, MemberMXBean proxy,
+      FederationComponent oldState) {
-   * @param objectName
-   *          object name of the proxy
-   * @param proxy
-   *          actual proxy instance
+   * @param objectName object name of the proxy
+   * @param proxy actual proxy instance
-  public void addServerToSystem(ObjectName objectName, CacheServerMXBean proxy, FederationComponent newState) {
+  public void addServerToSystem(ObjectName objectName, CacheServerMXBean proxy,
+      FederationComponent newState) {
-   * @param objectName
-   *          name of the proxy to be removed.
-   * @param proxy
-   *          actual reference to the proxy object
-   * @return whether all proxies have been removed or not. In this case it will
-   *         always be false. Kept it for consistency for MBeanAggregator.
+   * @param objectName name of the proxy to be removed.
+   * @param proxy actual reference to the proxy object
+   * @return whether all proxies have been removed or not. In this case it will always be false.
+   *         Kept it for consistency for MBeanAggregator.
-  public boolean removeServerFromSystem(ObjectName objectName, CacheServerMXBean proxy, FederationComponent oldState) {
+  public boolean removeServerFromSystem(ObjectName objectName, CacheServerMXBean proxy,
+      FederationComponent oldState) {
-   * @param objectName
-   *          object name of the proxy
-   * @param proxy
-   *          actual proxy instance
+   * @param objectName object name of the proxy
+   * @param proxy actual proxy instance
-  public void addGatewaySenderToSystem(ObjectName objectName,
-      GatewaySenderMXBean proxy, FederationComponent newState) {
+  public void addGatewaySenderToSystem(ObjectName objectName, GatewaySenderMXBean proxy,
+      FederationComponent newState) {
-   * @param objectName
-   *          name of the proxy to be removed.
-   * @param proxy
-   *          actual reference to the proxy object
-   * @return whether all proxies have been removed or not. In this case it will
-   *         always be false. Kept it for consistency for MBeanAggregator.
+   * @param objectName name of the proxy to be removed.
+   * @param proxy actual reference to the proxy object
+   * @return whether all proxies have been removed or not. In this case it will always be false.
+   *         Kept it for consistency for MBeanAggregator.
-  public boolean removeGatewaySenderFromSystem(ObjectName objectName,
-      GatewaySenderMXBean proxy, FederationComponent oldState) {
+  public boolean removeGatewaySenderFromSystem(ObjectName objectName, GatewaySenderMXBean proxy,
+      FederationComponent oldState) {
-   * @param objectName
-   *          object name of the proxy
-   * @param proxy
-   *          actual proxy instance
+   * @param objectName object name of the proxy
+   * @param proxy actual proxy instance
-  public void addGatewayReceiverToSystem(ObjectName objectName,
-      GatewayReceiverMXBean proxy, FederationComponent newState) {
+  public void addGatewayReceiverToSystem(ObjectName objectName, GatewayReceiverMXBean proxy,
+      FederationComponent newState) {
-   * @param objectName
-   *          name of the proxy to be removed.
-   * @param proxy
-   *          actual reference to the proxy object
-   * @return whether all proxies have been removed or not. In this case it will
-   *         always be false. Kept it for consistency for MBeanAggregator.
+   * @param objectName name of the proxy to be removed.
+   * @param proxy actual reference to the proxy object
+   * @return whether all proxies have been removed or not. In this case it will always be false.
+   *         Kept it for consistency for MBeanAggregator.
-  public boolean removeGatewayReceiverFromSystem(ObjectName objectName,
-      GatewayReceiverMXBean proxy, FederationComponent oldState) {
+  public boolean removeGatewayReceiverFromSystem(ObjectName objectName, GatewayReceiverMXBean proxy,
+      FederationComponent oldState) {
-   * @param targetDirPath
-   *          path of the directory where the back up files should be placed.
-   * @param baselineDirPath
-   *          path of the directory for baseline backup.
-   * @return open type DiskBackupStatus containing each member wise disk back up
-   *         status
+   * @param targetDirPath path of the directory where the back up files should be placed.
+   * @param baselineDirPath path of the directory for baseline backup.
+   * @return open type DiskBackupStatus containing each member wise disk back up status
-    try {
-      
-      if(targetDirPath == null || targetDirPath.isEmpty()){
-        throw new Exception(ManagementStrings.TARGET_DIR_CANT_BE_NULL_OR_EMPTY.toLocalizedString());
-      }
-      SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss");
-      File targetDir = new File(targetDirPath);
-      targetDir = new File(targetDir, format.format(new Date()));
-      
-      File baselineDir = null;
-      if (baselineDirPath != null) {
-        baselineDir = new File(baselineDirPath);
-      }
-      
-      
-      DM dm = cache.getDistributionManager();
-      Set<PersistentID> missingMembers = MissingPersistentIDsRequest.send(dm);
-      Set recipients = dm.getOtherDistributionManagerIds();
+      try {
-      BackupDataStoreResult result = BackupDataStoreHelper.backupAllMembers(dm, recipients, targetDir, baselineDir);
-
-      Iterator<DistributedMember> it = result.getSuccessfulMembers().keySet().iterator();
-
-      Map<String, String[]> backedUpDiskStores = new HashMap<String, String[]>();
-      while (it.hasNext()) {
-        DistributedMember member = it.next();
-        Set<PersistentID> setOfDisk = result.getSuccessfulMembers().get(member);
-        String[] setOfDiskStr = new String[setOfDisk.size()];
-        int j = 0;
-        for (PersistentID id : setOfDisk) {
-          setOfDiskStr[j] = id.getDirectory();
-          j++;
+        if (targetDirPath == null || targetDirPath.isEmpty()) {
+          throw new Exception(
+              ManagementStrings.TARGET_DIR_CANT_BE_NULL_OR_EMPTY.toLocalizedString());
-        backedUpDiskStores.put(member.getId(), setOfDiskStr);
-      }
+        SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd-HH-mm-ss");
+        File targetDir = new File(targetDirPath);
+        targetDir = new File(targetDir, format.format(new Date()));
-      // It's possible that when calling getMissingPersistentMembers, some
-      // members
-      // are
-      // still creating/recovering regions, and at FinishBackupRequest.send, the
-      // regions at the members are ready. Logically, since the members in
-      // successfulMembers
-      // should override the previous missingMembers
-      for (Set<PersistentID> onlineMembersIds : result.getSuccessfulMembers().values()) {
-        missingMembers.removeAll(onlineMembersIds);
-      }
+        File baselineDir = null;
+        if (baselineDirPath != null) {
+          baselineDir = new File(baselineDirPath);
+        }
-      result.getExistingDataStores().keySet().removeAll(result.getSuccessfulMembers().keySet());
-      String[] setOfMissingDiskStr = null;
-      if (result.getExistingDataStores().size() > 0) {
-        setOfMissingDiskStr = new String[result.getExistingDataStores().size()];
-        int j = 0;
-        for (Set<PersistentID> lostMembersIds : result.getExistingDataStores().values()) {
-          for (PersistentID id : lostMembersIds) {
-            setOfMissingDiskStr[j] = id.getDirectory();
+        DM dm = cache.getDistributionManager();
+        Set<PersistentID> missingMembers = MissingPersistentIDsRequest.send(dm);
+        Set recipients = dm.getOtherDistributionManagerIds();
+
+        BackupDataStoreResult result =
+            BackupDataStoreHelper.backupAllMembers(dm, recipients, targetDir, baselineDir);
+
+        Iterator<DistributedMember> it = result.getSuccessfulMembers().keySet().iterator();
+
+        Map<String, String[]> backedUpDiskStores = new HashMap<String, String[]>();
+        while (it.hasNext()) {
+          DistributedMember member = it.next();
+          Set<PersistentID> setOfDisk = result.getSuccessfulMembers().get(member);
+          String[] setOfDiskStr = new String[setOfDisk.size()];
+          int j = 0;
+          for (PersistentID id : setOfDisk) {
+            setOfDiskStr[j] = id.getDirectory();
-
+          backedUpDiskStores.put(member.getId(), setOfDiskStr);
-      }
-      DiskBackupStatus diskBackupStatus = new DiskBackupStatus();
-      diskBackupStatus.setBackedUpDiskStores(backedUpDiskStores);
-      diskBackupStatus.setOfflineDiskStores(setOfMissingDiskStr);
-      return diskBackupStatus;
-    } finally {
-      BackupDataStoreHelper.releaseLock(dm);
-    }
+        // It's possible that when calling getMissingPersistentMembers, some
+        // members
+        // are
+        // still creating/recovering regions, and at FinishBackupRequest.send, the
+        // regions at the members are ready. Logically, since the members in
+        // successfulMembers
+        // should override the previous missingMembers
+        for (Set<PersistentID> onlineMembersIds : result.getSuccessfulMembers().values()) {
+          missingMembers.removeAll(onlineMembersIds);
+        }
+
+        result.getExistingDataStores().keySet().removeAll(result.getSuccessfulMembers().keySet());
+        String[] setOfMissingDiskStr = null;
+
+        if (result.getExistingDataStores().size() > 0) {
+          setOfMissingDiskStr = new String[result.getExistingDataStores().size()];
+          int j = 0;
+          for (Set<PersistentID> lostMembersIds : result.getExistingDataStores().values()) {
+            for (PersistentID id : lostMembersIds) {
+              setOfMissingDiskStr[j] = id.getDirectory();
+              j++;
+            }
+
+          }
+        }
+
+        DiskBackupStatus diskBackupStatus = new DiskBackupStatus();
+        diskBackupStatus.setBackedUpDiskStores(backedUpDiskStores);
+        diskBackupStatus.setOfflineDiskStores(setOfMissingDiskStr);
+        return diskBackupStatus;
+      } finally {
+        BackupDataStoreHelper.releaseLock(dm);
+      }
-      throw new Exception(LocalizedStrings.DistributedSystem_BACKUP_ALREADY_IN_PROGRESS.toLocalizedString());
+      throw new Exception(
+          LocalizedStrings.DistributedSystem_BACKUP_ALREADY_IN_PROGRESS.toLocalizedString());
-   * @return Minimum level for alerts to be delivered to listeners. Should be
-   *         one of: WARNING, ERROR, SEVERE, OFF. It is not case-sensitive.
+   * @return Minimum level for alerts to be delivered to listeners. Should be one of: WARNING,
+   *         ERROR, SEVERE, OFF. It is not case-sensitive.
-    Iterator<GatewayReceiverMXBean> gatewayReceiverIterator = mapOfGatewayReceivers
-        .values().iterator();
+    Iterator<GatewayReceiverMXBean> gatewayReceiverIterator =
+        mapOfGatewayReceivers.values().iterator();
-   * @param alertLevel
-   *          Minimum level for alerts to be delivered to listeners. Should be
-   *          one of: WARNING, ERROR, SEVERE, NONE. It is not case-sensitive.
+   * @param alertLevel Minimum level for alerts to be delivered to listeners. Should be one of:
+   *        WARNING, ERROR, SEVERE, NONE. It is not case-sensitive.
-    if (alertLevel.equalsIgnoreCase("WARNING")
-        || alertLevel.equalsIgnoreCase("ERROR")
-        || alertLevel.equalsIgnoreCase("SEVERE")
-        || alertLevel.equalsIgnoreCase("NONE")) {
+    if (alertLevel.equalsIgnoreCase("WARNING") || alertLevel.equalsIgnoreCase("ERROR")
+        || alertLevel.equalsIgnoreCase("SEVERE") || alertLevel.equalsIgnoreCase("NONE")) {
-       while (memberIterator.hasNext()) {
+      while (memberIterator.hasNext()) {
-  
+
-       while (memberIterator.hasNext()) {
+      while (memberIterator.hasNext()) {
-    dm.setTotalBackupInProgress( bean.getTotalBackupInProgress());
+    dm.setTotalBackupInProgress(bean.getTotalBackupInProgress());
-    dm.setTotalBytesOnDisk( bean.getTotalDiskUsage());
+    dm.setTotalBytesOnDisk(bean.getTotalDiskUsage());
-    Iterator<GatewaySenderMXBean> gatewaySenderIterator = mapOfGatewaySenders
-        .values().iterator();
+    Iterator<GatewaySenderMXBean> gatewaySenderIterator = mapOfGatewaySenders.values().iterator();
-   * Requests the corresponding member to provide the basic JVM metrics which
-   * are listed in class JVMMetrics to be sent to Managing node.
+   * Requests the corresponding member to provide the basic JVM metrics which are listed in class
+   * JVMMetrics to be sent to Managing node.
-   * @param member
-   *          name or id of the member
+   * @param member name or id of the member
-      throw new Exception(ManagementStrings.INVALID_MEMBER_NAME_OR_ID
-          .toLocalizedString(member));
+      throw new Exception(ManagementStrings.INVALID_MEMBER_NAME_OR_ID.toLocalizedString(member));
-       return listLocators().length;
+      return listLocators().length;
-   * @param member
-   *          name or id of the member
+   * @param member name or id of the member
-  public GemFireProperties fetchMemberConfiguration(String member)
-      throws Exception {
+  public GemFireProperties fetchMemberConfiguration(String member) throws Exception {
-  
+
-   * @param member
-   *          name or id of the member
+   * @param member name or id of the member
-   * @return list of members visible to the Managing node and which can be
-   *         manageable.
+   * @return list of members visible to the Managing node and which can be manageable.
-   return ManagementConstants.NO_DATA_STRING;
+    return ManagementConstants.NO_DATA_STRING;
-          if ( memberMxBean.isLocator() ){
+          if (memberMxBean.isLocator()) {
-        if (DistributionManager.LOCATOR_DM_TYPE == ((InternalDistributedMember)member).getVmKind()) {
+        if (DistributionManager.LOCATOR_DM_TYPE == ((InternalDistributedMember) member)
+            .getVmKind()) {
-   * @param member
-   *          name or id of the member
+   * @param member name or id of the member
-  public OSMetrics showOSMetrics(String member) throws Exception  {
+  public OSMetrics showOSMetrics(String member) throws Exception {
-   * In case of replicated region during recovery all region recovery will wait
-   * till all the replicated region member are up and running so that the
-   * recovered data from the disk will be in sync;
+   * In case of replicated region during recovery all region recovery will wait till all the
+   * replicated region member are up and running so that the recovered data from the disk will be in
+   * sync;
-        missingDiskStores[j] = new PersistentMemberDetails(id.getHost()
-            .getCanonicalHostName(), id.getDirectory(), id.getUUID().toString());
+        missingDiskStores[j] = new PersistentMemberDetails(id.getHost().getCanonicalHostName(),
+            id.getDirectory(), id.getUUID().toString());
-   * Revokes or ignores the missing diskStore for which the region
-   * Initialization is stopped
+   * Revokes or ignores the missing diskStore for which the region Initialization is stopped
-   * @param diskStoreId
-   *          UUID of the disk store to revoke
+   * @param diskStoreId UUID of the disk store to revoke
-  public boolean revokeMissingDiskStores(final String diskStoreId)
-      throws Exception {
+  public boolean revokeMissingDiskStores(final String diskStoreId) throws Exception {
-      
+
-  public ObjectName fetchDistributedRegionObjectName(String regionPath)
-      throws Exception {
+  public ObjectName fetchDistributedRegionObjectName(String regionPath) throws Exception {
-    ObjectName distributedRegionMBeanName = MBeanJMXAdapter
-        .getDistributedRegionMbeanName(regionPath);
+    ObjectName distributedRegionMBeanName =
+        MBeanJMXAdapter.getDistributedRegionMbeanName(regionPath);
-      throw new Exception(
-          ManagementStrings.DISTRIBUTED_REGION_MBEAN_NOT_FOUND_IN_DS.toString());
+      throw new Exception(ManagementStrings.DISTRIBUTED_REGION_MBEAN_NOT_FOUND_IN_DS.toString());
-  public ObjectName fetchRegionObjectName(String member, String regionPath)
-      throws Exception {
+  public ObjectName fetchRegionObjectName(String member, String regionPath) throws Exception {
-    ObjectName distributedRegionMBeanName = MBeanJMXAdapter
-        .getDistributedRegionMbeanName(regionPath);
+    ObjectName distributedRegionMBeanName =
+        MBeanJMXAdapter.getDistributedRegionMbeanName(regionPath);
-      ObjectName regionMBeanName = MBeanJMXAdapter.getRegionMBeanName(member,
-          regionPath);
-      RegionMXBean bean = service.getMBeanInstance(regionMBeanName,
-          RegionMXBean.class);
+      ObjectName regionMBeanName = MBeanJMXAdapter.getRegionMBeanName(member, regionPath);
+      RegionMXBean bean = service.getMBeanInstance(regionMBeanName, RegionMXBean.class);
-        throw new Exception(ManagementStrings.REGION_MBEAN_NOT_FOUND_IN_DS
-            .toString());
+        throw new Exception(ManagementStrings.REGION_MBEAN_NOT_FOUND_IN_DS.toString());
-      throw new Exception(ManagementStrings.REGION_MBEAN_NOT_FOUND_IN_DS
-          .toString());
+      throw new Exception(ManagementStrings.REGION_MBEAN_NOT_FOUND_IN_DS.toString());
-  public ObjectName[] fetchRegionObjectNames(ObjectName memberMBeanName)
-      throws Exception {
+  public ObjectName[] fetchRegionObjectNames(ObjectName memberMBeanName) throws Exception {
-      String member = memberMBeanName
-          .getKeyProperty(ManagementConstants.OBJECTNAME_MEMBER_APPENDER);
+      String member =
+          memberMBeanName.getKeyProperty(ManagementConstants.OBJECTNAME_MEMBER_APPENDER);
-        ObjectName regionMBeanName = MBeanJMXAdapter.getRegionMBeanName(
-            member, region);
+        ObjectName regionMBeanName = MBeanJMXAdapter.getRegionMBeanName(member, region);
-      throw new Exception(ManagementStrings.MEMBER_MBEAN_NOT_FOUND_IN_DS
-          .toString());
+      throw new Exception(ManagementStrings.MEMBER_MBEAN_NOT_FOUND_IN_DS.toString());
-  public ObjectName fetchCacheServerObjectName(String member, int port)
-      throws Exception {
+  public ObjectName fetchCacheServerObjectName(String member, int port) throws Exception {
-    ObjectName serverName = MBeanJMXAdapter.getClientServiceMBeanName(port,
-        member);
+    ObjectName serverName = MBeanJMXAdapter.getClientServiceMBeanName(port, member);
-    CacheServerMXBean bean = service.getMBeanInstance(serverName,
-        CacheServerMXBean.class);
+    CacheServerMXBean bean = service.getMBeanInstance(serverName, CacheServerMXBean.class);
-        throw new Exception(
-            ManagementStrings.CACHE_SERVER_MBEAN_NOT_FOUND_IN_DS.toString());
+        throw new Exception(ManagementStrings.CACHE_SERVER_MBEAN_NOT_FOUND_IN_DS.toString());
-  public ObjectName fetchDiskStoreObjectName(String member,
-      String diskStore) throws Exception {
+  public ObjectName fetchDiskStoreObjectName(String member, String diskStore) throws Exception {
-    DiskStoreMXBean bean = service.getMBeanInstance(diskStoreName,
-        DiskStoreMXBean.class);
+    DiskStoreMXBean bean = service.getMBeanInstance(diskStoreName, DiskStoreMXBean.class);
-    if(bean != null){
+    if (bean != null) {
-    }else{ //check for local Disk Stores
+    } else { // check for local Disk Stores
-    if(bean != null){
+    if (bean != null) {
-    }else{
-      throw new Exception(
-          ManagementStrings.DISK_STORE_MBEAN_NOT_FOUND_IN_DS.toString());
+    } else {
+      throw new Exception(ManagementStrings.DISK_STORE_MBEAN_NOT_FOUND_IN_DS.toString());
-  public ObjectName fetchDistributedLockServiceObjectName(String lockServiceName)
-      throws Exception {
-    DistributedLockServiceMXBean bean = service
-        .getDistributedLockServiceMXBean(lockServiceName);
+  public ObjectName fetchDistributedLockServiceObjectName(String lockServiceName) throws Exception {
+    DistributedLockServiceMXBean bean = service.getDistributedLockServiceMXBean(lockServiceName);
-      ObjectName lockSerName = service
-          .getDistributedLockServiceMBeanName(lockServiceName);
+      ObjectName lockSerName = service.getDistributedLockServiceMBeanName(lockServiceName);
-          ManagementStrings.DISTRIBUTED_LOCK_SERVICE_MBEAN_NOT_FOUND_IN_SYSTEM
-              .toString());
+          ManagementStrings.DISTRIBUTED_LOCK_SERVICE_MBEAN_NOT_FOUND_IN_SYSTEM.toString());
-  public ObjectName fetchGatewayReceiverObjectName(String member)
-      throws Exception {
+  public ObjectName fetchGatewayReceiverObjectName(String member) throws Exception {
-    ObjectName receiverName = MBeanJMXAdapter
-        .getGatewayReceiverMBeanName(member);
-    GatewayReceiverMXBean bean = service.getMBeanInstance(receiverName,
-        GatewayReceiverMXBean.class);
+    ObjectName receiverName = MBeanJMXAdapter.getGatewayReceiverMBeanName(member);
+    GatewayReceiverMXBean bean =
+        service.getMBeanInstance(receiverName, GatewayReceiverMXBean.class);
-            ManagementStrings.GATEWAY_RECEIVER_MBEAN_NOT_FOUND_IN_SYSTEM
-                .toString());
+            ManagementStrings.GATEWAY_RECEIVER_MBEAN_NOT_FOUND_IN_SYSTEM.toString());
-  public ObjectName fetchGatewaySenderObjectName(String member,
-      String senderId) throws Exception {
+  public ObjectName fetchGatewaySenderObjectName(String member, String senderId) throws Exception {
-    ObjectName senderName = MBeanJMXAdapter.getGatewaySenderMBeanName(member,
-        senderId);
+    ObjectName senderName = MBeanJMXAdapter.getGatewaySenderMBeanName(member, senderId);
-    GatewaySenderMXBean bean = service.getMBeanInstance(senderName,
-        GatewaySenderMXBean.class);
+    GatewaySenderMXBean bean = service.getMBeanInstance(senderName, GatewaySenderMXBean.class);
-        throw new Exception(
-            ManagementStrings.GATEWAY_SENDER_MBEAN_NOT_FOUND_IN_SYSTEM
-                .toString());
+        throw new Exception(ManagementStrings.GATEWAY_SENDER_MBEAN_NOT_FOUND_IN_SYSTEM.toString());
-  public ObjectName fetchLockServiceObjectName(String member,
-      String lockService) throws Exception {
+  public ObjectName fetchLockServiceObjectName(String member, String lockService) throws Exception {
-    ObjectName lockServiceName = MBeanJMXAdapter.getLockServiceMBeanName(
-        member, lockService);
-    LockServiceMXBean bean = service.getMBeanInstance(lockServiceName,
-        LockServiceMXBean.class);
+    ObjectName lockServiceName = MBeanJMXAdapter.getLockServiceMBeanName(member, lockService);
+    LockServiceMXBean bean = service.getMBeanInstance(lockServiceName, LockServiceMXBean.class);
-        throw new Exception(
-            ManagementStrings.LOCK_SERVICE_MBEAN_NOT_FOUND_IN_SYSTEM.toString());
+        throw new Exception(ManagementStrings.LOCK_SERVICE_MBEAN_NOT_FOUND_IN_SYSTEM.toString());
-    return  mapOfServers.keySet().toArray(arr);
+    return mapOfServers.keySet().toArray(arr);
-  public ObjectName[] listGatewaySenderObjectNames(String member)
-      throws Exception {
+  public ObjectName[] listGatewaySenderObjectNames(String member) throws Exception {
-    DistributedMember distributedMember = BeanUtilFuncs
-        .getDistributedMemberByNameOrId(member);
+    DistributedMember distributedMember = BeanUtilFuncs.getDistributedMemberByNameOrId(member);
-    ObjectName pattern = new ObjectName(
-        ManagementConstants.GATEWAY_SENDER_PATTERN);
+    ObjectName pattern = new ObjectName(ManagementConstants.GATEWAY_SENDER_PATTERN);
-   * We have to iterate through the Cache servers to get Unique Client list
-   * across system. Stats will give duplicate client numbers;
+   * We have to iterate through the Cache servers to get Unique Client list across system. Stats
+   * will give duplicate client numbers;
-    return MetricsCalculator.getAverage(memberMBeanMonitor
-        .getDiskFlushAvgLatency(), memberSetSize);
+    return MetricsCalculator.getAverage(memberMBeanMonitor.getDiskFlushAvgLatency(), memberSetSize);
-   * @return Average number of batches of events removed from the event queue
-   *         and sent per second
+   * @return Average number of batches of events removed from the event queue and sent per second
-    return MetricsCalculator.getAverage(senderMonitor
-        .getGatewaySenderAverageDistributionTimePerBatch(),
-        gatewaySenderSetSize);
+    return MetricsCalculator.getAverage(
+        senderMonitor.getGatewaySenderAverageDistributionTimePerBatch(), gatewaySenderSetSize);
-  
+
-  
+
-    Iterator<DistributedRegionBridge> memberIterator = distrRegionMap.values()
-        .iterator();
+    Iterator<DistributedRegionBridge> memberIterator = distrRegionMap.values().iterator();
-   * @return Number of Initial image operations that are in progress across
-   *         system
+   * @return Number of Initial image operations that are in progress across system
-      Iterator<GatewaySenderMXBean> it = mapOfGatewaySenders.values()
-          .iterator();
+      Iterator<GatewaySenderMXBean> it = mapOfGatewaySenders.values().iterator();
-        if(dsId != null){
-          senderMap.put(dsId.toString(), bean.isConnected());
+        if (dsId != null) {
+          senderMap.merge(dsId.toString(), bean.isRunning(), Boolean::logicalAnd);
-
-
-  public String queryData(String query, String members, int limit)  throws Exception{
-    Object result=  QueryDataFunction.queryData(query, members, limit, false, queryResultSetLimit, queryCollectionsDepth);
-    return (String)result;
-
-  }
-  
-  public byte[] queryDataForCompressedResult(String query, String members, int limit)  throws Exception{
-    Object result = QueryDataFunction.queryData(query, members, limit, true, queryResultSetLimit, queryCollectionsDepth);
-    return (byte[])result;
+  public String queryData(String query, String members, int limit) throws Exception {
+    Object result = QueryDataFunction.queryData(query, members, limit, false, queryResultSetLimit,
+        queryCollectionsDepth);
+    return (String) result;
-  
+  public byte[] queryDataForCompressedResult(String query, String members, int limit)
+      throws Exception {
+    Object result = QueryDataFunction.queryData(query, members, limit, true, queryResultSetLimit,
+        queryCollectionsDepth);
+    return (byte[]) result;
+
+  }
+
+
-   this.queryResultSetLimit = queryResultSetLimit;
+    this.queryResultSetLimit = queryResultSetLimit;
-    ObjectName distributedRegionObjectName = MBeanJMXAdapter
-        .getDistributedRegionMbeanNameInternal(fullPath);
+    ObjectName distributedRegionObjectName =
+        MBeanJMXAdapter.getDistributedRegionMbeanNameInternal(fullPath);
-      DistributedRegionBridge bridge = distrRegionMap
-          .get(distributedRegionObjectName);
+      DistributedRegionBridge bridge = distrRegionMap.get(distributedRegionObjectName);
-    ObjectName distributedRegionObjectName = MBeanJMXAdapter
-        .getDistributedRegionMbeanNameInternal(fullPath);
+    ObjectName distributedRegionObjectName =
+        MBeanJMXAdapter.getDistributedRegionMbeanNameInternal(fullPath);
-        DistributedRegionBridge bridge = distrRegionMap
-            .get(distributedRegionObjectName);
+        DistributedRegionBridge bridge = distrRegionMap.get(distributedRegionObjectName);
-    ObjectName distributedRegionObjectName = MBeanJMXAdapter
-        .getDistributedRegionMbeanNameInternal(fullPath);
+    ObjectName distributedRegionObjectName =
+        MBeanJMXAdapter.getDistributedRegionMbeanNameInternal(fullPath);
-  public void addLockService(ObjectName proxyName,
-      LockServiceMXBean lockServiceProxy, FederationComponent fedComp) {
+  public void addLockService(ObjectName proxyName, LockServiceMXBean lockServiceProxy,
+      FederationComponent fedComp) {
-    ObjectName distributedLockObjectName = MBeanJMXAdapter
-        .getDistributedLockServiceName(lockServiceName);
+    ObjectName distributedLockObjectName =
+        MBeanJMXAdapter.getDistributedLockServiceName(lockServiceName);
-        DistributedLockServiceBridge bridge = distrLockServiceMap
-            .get(distributedLockObjectName);
+        DistributedLockServiceBridge bridge = distrLockServiceMap.get(distributedLockObjectName);
-        DistributedLockServiceBridge bridge = new DistributedLockServiceBridge(
-            proxyName, lockServiceProxy, fedComp);
-        DistributedLockServiceMXBean mbean = new DistributedLockServiceMBean(
-            bridge);
+        DistributedLockServiceBridge bridge =
+            new DistributedLockServiceBridge(proxyName, lockServiceProxy, fedComp);
+        DistributedLockServiceMXBean mbean = new DistributedLockServiceMBean(bridge);
-  public void removeLockService(ObjectName proxyName,
-      LockServiceMXBean lockServiceProxy, FederationComponent fedComp) {
+  public void removeLockService(ObjectName proxyName, LockServiceMXBean lockServiceProxy,
+      FederationComponent fedComp) {
-    ObjectName distributedLockObjectName = MBeanJMXAdapter
-        .getDistributedLockServiceName(lockServiceName);
+    ObjectName distributedLockObjectName =
+        MBeanJMXAdapter.getDistributedLockServiceName(lockServiceName);
-        DistributedLockServiceBridge bridge = distrLockServiceMap
-            .get(distributedLockObjectName);
+        DistributedLockServiceBridge bridge = distrLockServiceMap.get(distributedLockObjectName);
-  public void updateLockService(ObjectName proxyName,
-      FederationComponent oldValue, FederationComponent newValue) {
+  public void updateLockService(ObjectName proxyName, FederationComponent oldValue,
+      FederationComponent newValue) {
-    Notification notification = new Notification(
-        JMXNotificationType.CACHE_MEMBER_DEPARTED, MBeanJMXAdapter
-            .getMemberNameOrId(id), SequenceNumber.next(), System
-            .currentTimeMillis(),
-            ManagementConstants.CACHE_MEMBER_DEPARTED_PREFIX
-            + MBeanJMXAdapter.getMemberNameOrId(id) + " has crashed = "
-            + crashed);
+    Notification notification = new Notification(JMXNotificationType.CACHE_MEMBER_DEPARTED,
+        MBeanJMXAdapter.getMemberNameOrId(id), SequenceNumber.next(), System.currentTimeMillis(),
+        ManagementConstants.CACHE_MEMBER_DEPARTED_PREFIX + MBeanJMXAdapter.getMemberNameOrId(id)
+            + " has crashed = " + crashed);
-    Notification notification = new Notification(
-        JMXNotificationType.CACHE_MEMBER_JOINED, MBeanJMXAdapter
-            .getMemberNameOrId(id), SequenceNumber.next(), System
-            .currentTimeMillis(),
-            ManagementConstants.CACHE_MEMBER_JOINED_PREFIX
-            + MBeanJMXAdapter.getMemberNameOrId(id));
+    Notification notification = new Notification(JMXNotificationType.CACHE_MEMBER_JOINED,
+        MBeanJMXAdapter.getMemberNameOrId(id), SequenceNumber.next(), System.currentTimeMillis(),
+        ManagementConstants.CACHE_MEMBER_JOINED_PREFIX + MBeanJMXAdapter.getMemberNameOrId(id));
-  public void memberSuspect(InternalDistributedMember id,
-      InternalDistributedMember whoSuspected) {
+  public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected) {
-    Notification notification = new Notification(
-        JMXNotificationType.CACHE_MEMBER_SUSPECT, MBeanJMXAdapter
-            .getMemberNameOrId(id), SequenceNumber.next(), System
-            .currentTimeMillis(),
-            ManagementConstants.CACHE_MEMBER_SUSPECT_PREFIX
-            + MBeanJMXAdapter.getMemberNameOrId(id) + " By : "
-            + whoSuspected.getName());
+    Notification notification = new Notification(JMXNotificationType.CACHE_MEMBER_SUSPECT,
+        MBeanJMXAdapter.getMemberNameOrId(id), SequenceNumber.next(), System.currentTimeMillis(),
+        ManagementConstants.CACHE_MEMBER_SUSPECT_PREFIX + MBeanJMXAdapter.getMemberNameOrId(id)
+            + " By : " + whoSuspected.getName());

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 INS90 UPD42 INS42 INS42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
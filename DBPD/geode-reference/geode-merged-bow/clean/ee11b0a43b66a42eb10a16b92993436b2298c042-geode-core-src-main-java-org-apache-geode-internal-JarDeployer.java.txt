GEODE-2705: Jars undeployed from cluster configuration will not be loaded from disk on member restart

-import org.apache.commons.lang.ArrayUtils;
-import org.apache.geode.GemFireException;
-import org.apache.geode.GemFireIOException;
-import org.apache.geode.SystemFailure;
-import java.net.URLClassLoader;
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.HashMap;
+  /**
+   * Writes the jarBytes for the given jarName to the next version of that jar file (if the bytes do
+   * not match the latest deployed version)
+   * 
+   * @return the DeployedJar that was written from jarBytes, or null if those bytes matched the
+   *         latest deployed version
+   */
+      boolean shouldDeployNewVersion = shouldDeployNewVersion(jarName, jarBytes);
+      if (!shouldDeployNewVersion) {
+        return null;
+      }
+
+
-  protected Set<String> findDistinctDeployedJars() {
+  protected Set<String> findDistinctDeployedJarsOnDisk() {
-    final File[] oldFiles = this.deployDirectory.listFiles(new FilenameFilter() {
-      @Override
-      public boolean accept(final File file, final String name) {
-        return versionedPattern.matcher(name).matches();
-      }
-    });
+    final File[] oldFiles =
+        this.deployDirectory.listFiles((file, name) -> versionedPattern.matcher(name).matches());
-    final Set<String> jarNames = new HashSet<String>();
+    final Set<String> jarNames = new HashSet<>();
-      jarNames.add(matcher.group(1));
+      jarNames.add(matcher.group(1) + ".jar");
-    logger.debug("Renaming deployed jar from " + oldJar.getCanonicalPath() + " to "
-        + newJar.getCanonicalPath());
+    logger.debug("Renaming deployed jar from {} to {}", oldJar.getCanonicalPath(),
+        newJar.getCanonicalPath());
-    FileUtils.deleteQuietly(oldJar);
-   * Re-deploy all previously deployed JAR files.
+   * Re-deploy all previously deployed JAR files on disk.
-  public void loadPreviouslyDeployedJars() {
+  public void loadPreviouslyDeployedJarsFromDisk() {
+    logger.info("Loading previously deployed jars");
-      final Set<String> jarNames = findDistinctDeployedJars();
+      final Set<String> jarNames = findDistinctDeployedJarsOnDisk();
-      Map<String, DeployedJar> latestVersionOfEachJar = new LinkedHashMap<>();
+      List<DeployedJar> latestVersionOfEachJar = new ArrayList<>();
-        final File[] jarFiles = findSortedOldVersionsOfJar(jarName);
+        DeployedJar deployedJar = findLatestValidDeployedJarFromDisk(jarName);
-        Optional<File> latestValidDeployedJarOptional =
-            Arrays.stream(jarFiles).filter(Objects::nonNull).filter(jarFile -> {
-              try {
-                return DeployedJar.isValidJarContent(FileUtils.readFileToByteArray(jarFile));
-              } catch (IOException e) {
-                return false;
-              }
-            }).findFirst();
-
-        if (!latestValidDeployedJarOptional.isPresent()) {
-          // No valid version of this jar
-          continue;
-        }
-
-        File latestValidDeployedJar = latestValidDeployedJarOptional.get();
-        latestVersionOfEachJar.put(jarName, new DeployedJar(latestValidDeployedJar, jarName));
-
-        // Remove any old left-behind versions of this JAR file
-        for (File jarFile : jarFiles) {
-          if (!latestValidDeployedJar.equals(jarFile)) {
-            FileUtils.deleteQuietly(jarFile);
-          }
+        if (deployedJar != null) {
+          latestVersionOfEachJar.add(deployedJar);
+          deleteOtherVersionsOfJar(deployedJar);
-      registerNewVersions(latestVersionOfEachJar.values().stream().collect(toList()));
-      // ClassPathLoader.getLatest().deploy(latestVersionOfEachJar.keySet().toArray(),
-      // latestVersionOfEachJar.values().toArray())
+      registerNewVersions(latestVersionOfEachJar);
+  /**
+   * Deletes all versions of this jar on disk other than the given version
+   */
+  public void deleteOtherVersionsOfJar(DeployedJar deployedJar) {
+    logger.info("Deleting all versions of " + deployedJar.getJarName() + " other than "
+        + deployedJar.getFileName());
+    final File[] jarFiles = findSortedOldVersionsOfJar(deployedJar.getJarName());
+
+    Stream.of(jarFiles).filter(jarFile -> !jarFile.equals(deployedJar.getFile()))
+        .forEach(jarFile -> {
+          logger.info("Deleting old version of jar: " + jarFile.getAbsolutePath());
+          FileUtils.deleteQuietly(jarFile);
+        });
+  }
+
+  public DeployedJar findLatestValidDeployedJarFromDisk(String unversionedJarName)
+      throws IOException {
+    final File[] jarFiles = findSortedOldVersionsOfJar(unversionedJarName);
+
+    Optional<File> latestValidDeployedJarOptional =
+        Arrays.stream(jarFiles).filter(Objects::nonNull).filter(jarFile -> {
+          try {
+            return DeployedJar.isValidJarContent(FileUtils.readFileToByteArray(jarFile));
+          } catch (IOException e) {
+            return false;
+          }
+        }).findFirst();
+
+    if (!latestValidDeployedJarOptional.isPresent()) {
+      // No valid version of this jar
+      return null;
+    }
+
+    File latestValidDeployedJar = latestValidDeployedJarOptional.get();
+
+    return new DeployedJar(latestValidDeployedJar, unversionedJarName);
+  }
+          logger.info("Registering new version of jar: {}", deployedJar.toString());
-        boolean shouldDeployNewVersion = shouldDeployNewVersion(jarName, newJarBytes);
-
-        if (shouldDeployNewVersion) {
-          deployedJars[i] = deployWithoutRegistering(jarName, newJarBytes);
-        } else {
-          deployedJars[i] = null;
-        }
+        deployedJars[i] = deployWithoutRegistering(jarName, newJarBytes);
-      logger.warn("Jar is identical to the latest deployed version: ",
+      logger.warn("Jar is identical to the latest deployed version: {}",
+  /**
+   * Returns the latest registered {@link DeployedJar} for the given JarName
+   * 
+   * @param jarName - the unversioned jar name, e.g. myJar.jar
+   */
+      deleteAllVersionsOfJar(jarName);
+
+  public void deleteAllVersionsOfJar(String unversionedJarName) {
+    lock.lock();
+    try {
+      File[] jarFiles = findSortedOldVersionsOfJar(unversionedJarName);
+      for (File jarFile : jarFiles) {
+        logger.info("Deleting: {}", jarFile.getAbsolutePath());
+        FileUtils.deleteQuietly(jarFile);
+      }
+    } finally {
+      lock.unlock();
+    }
+
+  }

INS31 INS31 INS31 INS29 UPD42 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS8 MOV43 UPD42 INS44 INS43 MOV8 MOV8 INS29 INS83 INS39 INS42 MOV44 INS8 INS65 INS65 INS65 INS21 MOV21 INS54 INS65 INS43 INS42 INS21 INS60 INS21 MOV43 INS42 UPD42 MOV42 INS41 MOV60 MOV24 MOV21 INS54 INS65 INS65 UPD42 INS21 INS54 INS66 INS66 INS66 INS66 INS66 INS32 INS8 MOV12 MOV8 INS66 INS42 INS32 INS83 MOV5 INS59 INS32 INS5 INS14 MOV8 MOV8 INS66 INS65 INS66 INS42 INS66 INS32 INS8 INS8 INS60 INS25 INS45 MOV32 MOV32 INS42 INS42 INS45 MOV21 MOV21 MOV60 MOV25 INS60 INS70 INS21 INS42 INS42 INS27 INS42 INS32 INS32 INS42 INS86 INS43 INS85 INS41 INS43 INS42 INS42 INS24 MOV41 INS42 INS21 INS42 INS42 INS60 INS70 INS21 INS39 INS59 INS38 INS8 INS86 UPD74 INS74 INS59 MOV44 INS42 INS8 INS32 INS45 INS32 INS45 INS32 INS42 INS32 INS32 INS42 INS86 INS59 MOV8 INS42 UPD42 INS33 INS42 MOV58 MOV27 MOV37 MOV8 INS32 INS5 INS59 MOV44 INS42 INS8 INS32 INS42 INS32 INS42 INS41 INS59 INS59 MOV32 INS27 INS43 INS43 INS42 INS14 INS60 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS59 INS38 INS42 INS21 MOV60 MOV60 UPD42 MOV42 UPD42 MOV42 UPD45 INS42 INS42 INS43 INS85 INS42 INS32 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 MOV32 INS45 UPD42 INS42 INS42 INS74 MOV43 INS59 INS27 INS8 INS42 INS32 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS32 INS32 INS43 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS42 INS32 INS42 INS42 INS27 INS21 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS45 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL42 DEL43 DEL42 DEL78 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL41 DEL8 DEL31 DEL1 DEL14 DEL42 DEL43 DEL45 DEL45 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL66 DEL65 DEL29 DEL39 DEL18 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL38 DEL25 DEL8 DEL70 DEL42 DEL43 DEL74 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL70 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL32 DEL21 DEL8 DEL54 DEL8 DEL39 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL2 DEL33 DEL7 DEL21 DEL8 DEL25 DEL24 DEL54 DEL8 DEL83
Merge branch 'develop' into feature/GEODE-17-2

-import com.gemstone.gemfire.LogWriter;
- * If we can not find enough free memory then all the existing free memory is compacted.
+ * If we can not find enough free memory then all the existing free memory is defragmented.
-public class SimpleMemoryAllocatorImpl implements MemoryAllocator {
+public class MemoryAllocatorImpl implements MemoryAllocator {
-  private static SimpleMemoryAllocatorImpl singleton = null;
+  private static MemoryAllocatorImpl singleton = null;
-  public static SimpleMemoryAllocatorImpl getAllocator() {
-    SimpleMemoryAllocatorImpl result = singleton;
+  public static MemoryAllocatorImpl getAllocator() {
+    MemoryAllocatorImpl result = singleton;
-  public static MemoryAllocator create(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats, LogWriter lw, 
-      int slabCount, long offHeapMemorySize, long maxSlabSize) {
-    return create(ooohml, stats, lw, slabCount, offHeapMemorySize, maxSlabSize,
-        null, new AddressableMemoryChunkFactory() {
+  public static MemoryAllocator create(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats, int slabCount, 
+      long offHeapMemorySize, long maxSlabSize) {
+    return create(ooohml, stats, slabCount, offHeapMemorySize, maxSlabSize, null,
+        new SlabFactory() {
-      public AddressableMemoryChunk create(int size) {
-        return new UnsafeMemoryChunk(size);
+      public Slab create(int size) {
+        return new SlabImpl(size);
-  private static SimpleMemoryAllocatorImpl create(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats, LogWriter lw, 
-      int slabCount, long offHeapMemorySize, long maxSlabSize, 
-      AddressableMemoryChunk[] slabs, AddressableMemoryChunkFactory memChunkFactory) {
-    SimpleMemoryAllocatorImpl result = singleton;
+  private static MemoryAllocatorImpl create(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats, int slabCount, 
+      long offHeapMemorySize, long maxSlabSize, Slab[] slabs, 
+      SlabFactory slabFactory) {
+    MemoryAllocatorImpl result = singleton;
-      result.reuse(ooohml, lw, stats, offHeapMemorySize, slabs);
-      if (lw != null) {
-        lw.config("Reusing " + result.getTotalMemory() + " bytes of off-heap memory. The maximum size of a single off-heap object is " + result.freeList.getLargestSlabSize() + " bytes.");
-      }
+      result.reuse(ooohml, stats, offHeapMemorySize, slabs);
+      logger.info("Reusing {}  bytes of off-heap memory. The maximum size of a single off-heap object is {}  bytes.", result.getTotalMemory(), result.freeList.getLargestSlabSize());
-        //SimpleMemoryAllocatorImpl.cleanupPreviousAllocator();
-        if (lw != null) {
-          lw.config("Allocating " + offHeapMemorySize + " bytes of off-heap memory. The maximum size of a single off-heap object is " + maxSlabSize + " bytes.");
-        }
-        slabs = new UnsafeMemoryChunk[slabCount];
+        logger.info("Allocating {} bytes of off-heap memory. The maximum size of a single off-heap object is {} bytes.", offHeapMemorySize, maxSlabSize);
+        slabs = new SlabImpl[slabCount];
-              slabs[i] = memChunkFactory.create((int) maxSlabSize);
+              slabs[i] = slabFactory.create((int) maxSlabSize);
-              slabs[i] = memChunkFactory.create((int) uncreatedMemory);
+              slabs[i] = slabFactory.create((int) uncreatedMemory);
-              if (lw != null) {
-                lw.severe("Off-heap memory creation failed after successfully allocating " + (i*maxSlabSize) + " bytes of off-heap memory.");
-              }
+              logger.error("Off-heap memory creation failed after successfully allocating {} bytes of off-heap memory.", (i*maxSlabSize));
-                slabs[j].release();
+                slabs[j].free();
-      result = new SimpleMemoryAllocatorImpl(ooohml, stats, slabs);
+      result = new MemoryAllocatorImpl(ooohml, stats, slabs);
-  static SimpleMemoryAllocatorImpl createForUnitTest(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats, LogWriter lw, 
-      int slabCount, long offHeapMemorySize, long maxSlabSize, AddressableMemoryChunkFactory memChunkFactory) {
-    return create(ooohml, stats, lw, slabCount, offHeapMemorySize, maxSlabSize, 
-        null, memChunkFactory);
+  static MemoryAllocatorImpl createForUnitTest(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats, int slabCount, 
+      long offHeapMemorySize, long maxSlabSize, SlabFactory memChunkFactory) {
+    return create(ooohml, stats, slabCount, offHeapMemorySize, maxSlabSize, null, 
+        memChunkFactory);
-  public static SimpleMemoryAllocatorImpl createForUnitTest(OutOfOffHeapMemoryListener oooml, OffHeapMemoryStats stats, AddressableMemoryChunk[] slabs) {
+  public static MemoryAllocatorImpl createForUnitTest(OutOfOffHeapMemoryListener oooml, OffHeapMemoryStats stats, Slab[] slabs) {
-    return create(oooml, stats, null, slabCount, offHeapMemorySize, maxSlabSize, slabs, null);
+    return create(oooml, stats, slabCount, offHeapMemorySize, maxSlabSize, slabs, null);
-  private void reuse(OutOfOffHeapMemoryListener oooml, LogWriter lw, OffHeapMemoryStats newStats, long offHeapMemorySize, AddressableMemoryChunk[] slabs) {
+  private void reuse(OutOfOffHeapMemoryListener oooml, OffHeapMemoryStats newStats, long offHeapMemorySize, Slab[] slabs) {
-      if (lw != null) {
-        lw.warning("Using " + getTotalMemory() + " bytes of existing off-heap memory instead of the requested " + offHeapMemorySize);
-      }
+      logger.warn("Using {} bytes of existing off-heap memory instead of the requested {}.", getTotalMemory(), offHeapMemorySize);
-  private SimpleMemoryAllocatorImpl(final OutOfOffHeapMemoryListener oooml, final OffHeapMemoryStats stats, final AddressableMemoryChunk[] slabs) {
+  private MemoryAllocatorImpl(final OutOfOffHeapMemoryListener oooml, final OffHeapMemoryStats stats, final Slab[] slabs) {
-    //OSProcess.printStacks(0, InternalDistributedSystem.getAnyInstance().getLogWriter(), false);
-  public List<ObjectChunk> getLostChunks() {
-    List<ObjectChunk> liveChunks = this.freeList.getLiveChunks();
-    List<ObjectChunk> regionChunks = getRegionLiveChunks();
-    Set<ObjectChunk> liveChunksSet = new HashSet<>(liveChunks);
-    Set<ObjectChunk> regionChunksSet = new HashSet<>(regionChunks);
+  public List<OffHeapStoredObject> getLostChunks() {
+    List<OffHeapStoredObject> liveChunks = this.freeList.getLiveChunks();
+    List<OffHeapStoredObject> regionChunks = getRegionLiveChunks();
+    Set<OffHeapStoredObject> liveChunksSet = new HashSet<>(liveChunks);
+    Set<OffHeapStoredObject> regionChunksSet = new HashSet<>(regionChunks);
-    return new ArrayList<ObjectChunk>(liveChunksSet);
+    return new ArrayList<OffHeapStoredObject>(liveChunksSet);
-  private List<ObjectChunk> getRegionLiveChunks() {
-    ArrayList<ObjectChunk> result = new ArrayList<ObjectChunk>();
+  private List<OffHeapStoredObject> getRegionLiveChunks() {
+    ArrayList<OffHeapStoredObject> result = new ArrayList<OffHeapStoredObject>();
-  private void getRegionLiveChunks(Region<?,?> r, List<ObjectChunk> result) {
+  private void getRegionLiveChunks(Region<?,?> r, List<OffHeapStoredObject> result) {
-  private void basicGetRegionLiveChunks(LocalRegion r, List<ObjectChunk> result) {
+  private void basicGetRegionLiveChunks(LocalRegion r, List<OffHeapStoredObject> result) {
-        if (value instanceof ObjectChunk) {
-          result.add((ObjectChunk) value);
+        if (value instanceof OffHeapStoredObject) {
+          result.add((OffHeapStoredObject) value);
-  private ObjectChunk allocateChunk(int size) {
-    ObjectChunk result = this.freeList.allocate(size);
+  private OffHeapStoredObject allocateOffHeapStoredObject(int size) {
+    OffHeapStoredObject result = this.freeList.allocate(size);
-      ReferenceCountHelper.refCountChanged(result.getMemoryAddress(), false, 1);
+      ReferenceCountHelper.refCountChanged(result.getAddress(), false, 1);
-  public MemoryChunk allocate(int size) {
+  public StoredObject allocate(int size) {
-    ObjectChunk result = allocateChunk(size);
+    OffHeapStoredObject result = allocateOffHeapStoredObject(size);
+    return allocateAndInitialize(v, isSerialized, isCompressed, null);
+  }
+  @Override
+  public StoredObject allocateAndInitialize(byte[] v, boolean isSerialized, boolean isCompressed, byte[] originalHeapData) {
-      return new DataAsAddress(addr);
+      return new TinyStoredObject(addr);
-    ObjectChunk result = allocateChunk(v.length);
+    OffHeapStoredObject result = allocateOffHeapStoredObject(v.length);
+    if (originalHeapData != null) {
+      result = new OffHeapStoredObjectWithHeapForm(result, originalHeapData);
+    }
-    SimpleMemoryAllocatorImpl ma = singleton;
+    MemoryAllocatorImpl ma = singleton;
-      SimpleMemoryAllocatorImpl ma = SimpleMemoryAllocatorImpl.singleton;
+      MemoryAllocatorImpl ma = MemoryAllocatorImpl.singleton;
-      SimpleMemoryAllocatorImpl ma = SimpleMemoryAllocatorImpl.singleton;
+      MemoryAllocatorImpl ma = MemoryAllocatorImpl.singleton;
-    List<ObjectChunk> liveChunks = this.freeList.getLiveChunks();
-    List<ObjectChunk> regionChunks = getRegionLiveChunks();
+    List<OffHeapStoredObject> liveChunks = this.freeList.getLiveChunks();
+    List<OffHeapStoredObject> regionChunks = getRegionLiveChunks();
-    for (ObjectChunk chunk: liveChunks) {
+    for (OffHeapStoredObject chunk: liveChunks) {
-            return Long.valueOf(o1.getMemoryAddress()).compareTo(o2.getMemoryAddress());
+            return Long.valueOf(o1.getAddress()).compareTo(o2.getAddress());

UPD42 INS31 UPD43 UPD43 MOV44 MOV44 MOV44 UPD43 UPD43 MOV44 MOV44 MOV44 UPD43 UPD42 INS74 UPD74 MOV74 INS44 MOV44 UPD43 UPD42 INS78 UPD43 MOV78 INS83 INS43 INS42 INS44 INS44 INS44 INS8 INS44 UPD66 UPD42 UPD42 UPD42 UPD5 UPD43 UPD42 UPD42 UPD43 UPD42 UPD5 UPD5 MOV25 UPD5 MOV43 INS43 UPD43 UPD74 MOV74 INS42 UPD74 UPD42 INS42 UPD42 INS42 INS5 INS42 INS39 INS42 INS39 INS42 INS41 INS5 INS42 INS25 UPD43 UPD43 UPD42 UPD43 UPD42 UPD43 UPD43 MOV27 UPD43 INS42 UPD74 UPD74 MOV74 INS74 UPD74 MOV74 INS14 UPD42 UPD74 UPD43 UPD43 UPD43 UPD43 INS39 INS85 INS32 INS39 INS85 UPD43 INS27 INS8 UPD43 INS74 UPD74 MOV74 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD43 MOV43 INS43 UPD43 INS74 INS42 UPD43 MOV14 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS33 UPD42 INS42 INS33 INS21 UPD42 MOV43 INS43 UPD43 UPD43 UPD43 MOV8 UPD42 UPD42 INS42 UPD42 MOV43 INS43 UPD42 UPD74 UPD42 UPD42 INS7 UPD43 UPD43 INS42 UPD42 UPD42 UPD42 INS21 MOV21 MOV21 UPD42 UPD42 INS45 MOV32 INS42 INS42 UPD43 UPD43 INS42 INS14 UPD42 UPD40 UPD42 UPD40 UPD43 INS32 UPD42 UPD42 UPD42 INS43 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS45 MOV32 MOV32 MOV21 UPD43 INS42 UPD43 UPD42 UPD43 UPD42 UPD42 INS45 INS42 INS42 UPD42 UPD42 UPD5 UPD43 UPD42 UPD43 UPD42 UPD42 UPD42 MOV25 MOV27 UPD42 UPD42 UPD42 UPD42 INS45 MOV36 UPD42 DEL40 DEL26 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL44 DEL45 DEL45 DEL45 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL33 DEL27 DEL25 DEL8 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL33 DEL27 DEL45 DEL45 DEL27 DEL8 DEL25 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL45 DEL45 DEL42 DEL27 DEL8 DEL25 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL74
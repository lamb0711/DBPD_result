Merge branch 'feature/GEODE-8' into develop

+
+import com.gemstone.gemfire.cache.CustomEvictionAttributes;
+import com.gemstone.gemfire.internal.cache.wan.GatewaySenderEventImpl;
+import com.gemstone.gemfire.internal.concurrent.MapCallbackAdapter;
+import com.gemstone.gemfire.internal.concurrent.MapResult;
+import com.gemstone.gemfire.internal.offheap.OffHeapHelper;
+import com.gemstone.gemfire.internal.offheap.OffHeapRegionEntryHelper;
+import com.gemstone.gemfire.internal.offheap.SimpleMemoryAllocatorImpl;
+import com.gemstone.gemfire.internal.offheap.SimpleMemoryAllocatorImpl.Chunk;
+import com.gemstone.gemfire.internal.offheap.annotations.Released;
+import com.gemstone.gemfire.internal.offheap.annotations.Retained;
+import com.gemstone.gemfire.internal.offheap.annotations.Unretained;
+  /**
+   * This test hook is used to force the conditions for defect 48182.
+   * This hook is used by Bug48182JUnitTest.
+   */
+  static Runnable testHookRunnableFor48182 =  null;
+  
+    boolean offHeap = false;
+      offHeap = region.getOffHeap();
+      offHeap = ((PlaceHolderDiskRegion) owner).getOffHeap();
-              {
+              if (offHeap) {
+                factory = VersionedStatsDiskLRURegionEntryOffHeap.getEntryFactory();
+              } else {
-              {
+              if (offHeap) {
+                factory = VMStatsDiskLRURegionEntryOffHeap.getEntryFactory();
+              } else {
-              {
+              if (offHeap) {
+                factory = VersionedStatsLRURegionEntryOffHeap.getEntryFactory();
+              } else {
-              {
+              if (offHeap) {
+                factory = VMStatsLRURegionEntryOffHeap.getEntryFactory();
+              } else {
-              {
+              if (offHeap) {
+                factory = VersionedStatsDiskRegionEntryOffHeap.getEntryFactory();
+              } else {
-              {
+              if (offHeap) {
+                factory = VMStatsDiskRegionEntryOffHeap.getEntryFactory();
+              } else {
-              {
+              if (offHeap) {
+                factory = VersionedStatsRegionEntryOffHeap.getEntryFactory();
+              } else {
-              {
+              if (offHeap) {
+                factory = VMStatsRegionEntryOffHeap.getEntryFactory();
+              } else {
-              {
+              if (offHeap) {
+                factory = VersionedThinDiskLRURegionEntryOffHeap.getEntryFactory();
+              } else {
-              {
+              if (offHeap) {
+                factory = VMThinDiskLRURegionEntryOffHeap.getEntryFactory();
+              } else {
-              {
+              if (offHeap) {
+                factory = VersionedThinLRURegionEntryOffHeap.getEntryFactory();
+              } else {
-              {
+              if (offHeap) {
+                factory = VMThinLRURegionEntryOffHeap.getEntryFactory();
+              } else {
-              {
+              if (offHeap) {
+                factory = VersionedThinDiskRegionEntryOffHeap.getEntryFactory();
+              } else {
-              {
+              if (offHeap) {
+                factory = VMThinDiskRegionEntryOffHeap.getEntryFactory();
+              } else {
-              {
+              if (offHeap) {
+                factory = VersionedThinRegionEntryOffHeap.getEntryFactory();
+              } else {
-              {
+              if (offHeap) {
+                factory = VMThinRegionEntryOffHeap.getEntryFactory();
+              } else {
-      return new CustomEntryConcurrentHashMap<Object, Object>(initialCapacity, loadFactor,
-          concurrencyLevel, isIdentityMap);
+      return new CustomEntryConcurrentHashMap<Object, Object>(initialCapacity,
+          loadFactor, concurrencyLevel, isIdentityMap);
+    if (r == _getOwnerObject()) {
+      return;
+    }
-    return size();
+    return _getMap().size();
-  public final boolean containsKey(Object key)
-  {
+  @SuppressWarnings({ "unchecked", "rawtypes" })
+  @Override
+  public Collection<RegionEntry> regionEntriesInVM() {
+    return (Collection)_getMap().values();
+  }
+
+  public final boolean containsKey(Object key) {
-  public RegionEntry getEntry(Object key)
-  {
-    return (RegionEntry)_getMap().get(key);
+  public RegionEntry getEntry(Object key) {
+    RegionEntry re = (RegionEntry)_getMap().get(key);
+    if (re != null && re.isMarkedForEviction()) {
+      // entry has been faulted in from HDFS
+      return null;
+    }
+    return re;
+  protected RegionEntry getEntry(EntryEventImpl event) {
+    return getEntry(event.getKey());
+  }
+
+
-  private final RegionEntry putEntryIfAbsent(Object key, RegionEntry re)
-  {
-    return (RegionEntry)_getMap().putIfAbsent(key, re);
+
+  public final RegionEntry putEntryIfAbsent(Object key, RegionEntry re) {
+    RegionEntry value = (RegionEntry)_getMap().putIfAbsent(key, re);
+    if (value == null && (re instanceof OffHeapRegionEntry) 
+        && _isOwnerALocalRegion() && _getOwner().isThisRegionBeingClosedOrDestroyed()) {
+      // prevent orphan during concurrent destroy (#48068)
+      if (_getMap().remove(key, re)) {
+        ((OffHeapRegionEntry)re).release();
+      }
+      _getOwner().checkReadiness(); // throw RegionDestroyedException
+    }
+    return value;
+  @Override
+  public final RegionEntry getOperationalEntryInVM(Object key) {
+    RegionEntry re = (RegionEntry)_getMap().get(key);
+    if (re != null && re.isMarkedForEviction()) {
+      // entry has been faulted in from HDFS
+      return null;
+    }
+    return re;
+  }
+ 
+
-    if (re.isTombstone() && _getMap().get(key) == re) {
+    if (re.isTombstone() && _getMap().get(key) == re && !re.isMarkedForEviction()){
-    if (re.isTombstone()) {
+    if (re.isTombstone()&& _getMap().get(key) == re && !re.isMarkedForEviction()) {
+
+      //This is messy, but custom eviction calls removeEntry
+      //rather than re.destroy I think to avoid firing callbacks, etc.
+      //However, the value still needs to be set to removePhase1
+      //in order to remove the entry from disk.
+      if(event.isCustomEviction() && !re.isRemoved()) {
+        try {
+          re.removePhase1(owner, false);
+        } catch (RegionClearedException e) {
+          //that's ok, we were just trying to do evict incoming eviction
+        }
+      }
+      
-  private final void incEntryCount(int delta) {
+  protected final void incEntryCount(int delta) {
+  public void close() {
+    /*
+    for (SuspectEntryList l: this.suspectEntries.values()) {
+      for (EntryEventImpl e: l) {
+        e.release();
+      }
+    }
+    */
+    clear(null);
+  }
+  
+                if (OffHeapRegionEntryHelper.doesClearNeedToCheckForOffHeap()) {
+                  GatewaySenderEventImpl.release(re._getValue()); // OFFHEAP _getValue ok
+                }
-        it.remove(); // OFFHEAP: I'm not sure that this sets the value in the ARE to removed. If it doesn't then if it is offheap we need to decrc
+        it.remove(); // This removes the RegionEntry from "rm" but it does not decrement its refcount to an offheap value.
-        Object value = oldRe._getValueUse((RegionEntryContext) ((AbstractRegionMap) rm)._getOwnerObject(), true);
-        if (value == Token.NOT_AVAILABLE) {
-          // fix for bug 43993
-          value = null;
+        
+        @Retained @Released Object value = oldRe._getValueRetain((RegionEntryContext) ((AbstractRegionMap) rm)._getOwnerObject(), true);
+
+        try {
+          if (value == Token.NOT_AVAILABLE) {
+            // fix for bug 43993
+            value = null;
+          }
+          if (value == Token.TOMBSTONE && !_getOwner().getConcurrencyChecksEnabled()) {
+            continue;
+          }
+          RegionEntry newRe = getEntryFactory().createEntry((RegionEntryContext) _getOwnerObject(), key, value);
+          copyRecoveredEntry(oldRe, newRe);
+          // newRe is now in this._getMap().
+          if (newRe.isTombstone()) {
+            VersionTag tag = newRe.getVersionStamp().asVersionTag();
+            tombstones.put(tag, newRe);
+          }
+          _getOwner().updateSizeOnCreate(key, _getOwner().calculateRegionEntryValueSize(newRe));
+          incEntryCount(1);
+          lruEntryUpdate(newRe);
+        } finally {
+          if (OffHeapHelper.release(value)) {
+            ((OffHeapRegionEntry)oldRe).release();
+          }
-        if (value == Token.TOMBSTONE && !_getOwner().getConcurrencyChecksEnabled()) {
-          continue;
-        }
-        RegionEntry newRe = getEntryFactory().createEntry((RegionEntryContext) _getOwnerObject(), key, value);
-        copyRecoveredEntry(oldRe, newRe);
-        if (newRe.isTombstone()) {
-          VersionTag tag = newRe.getVersionStamp().asVersionTag();
-          tombstones.put(tag, newRe);
-        }
-        _getOwner().updateSizeOnCreate(key, _getOwner().calculateRegionEntryValueSize(newRe));
-        incEntryCount(1);
-        lruEntryUpdate(newRe);
-        if (_getOwner() instanceof BucketRegion) {
-          Object value = re._getValueUse(_getOwner(), false);
-          if (value == Token.NOT_AVAILABLE) {
-            value = null;
-          }
-          if(value != null) {
-            _getOwner().updateSizeOnCreate(re.getKey(), _getOwner().calculateValueSize(value));
-          }
-        }
+        _getOwner().updateSizeOnCreate(re.getKey(), _getOwner().calculateRegionEntryValueSize(re));
+  @Retained     // Region entry may contain an off-heap value
-    RegionEntry newRe = getEntryFactory().createEntry((RegionEntryContext) _getOwnerObject(), key, value);
+    @Retained RegionEntry newRe = getEntryFactory().createEntry((RegionEntryContext) _getOwnerObject(), key, value);
-          } // isRemoved
+          } 
+          /*
+           * Entry already exists which should be impossible.
+           * Free the current entry (if off-heap) and
+           * throw an exception.
+           */
-            return null;
+            if (newRe instanceof OffHeapRegionEntry) {
+              ((OffHeapRegionEntry) newRe).release();
+            }
+
+            throw new IllegalStateException("Could not recover entry for key " + key + ".  The entry already exists!");
+      
+      @Retained @Released Object oldValue = null;
+      
+      try {
-                  Object oldValue = oldRe.getValueInVM(owner); // OFFHEAP: ListOfDeltas
+                  oldValue = oldRe.getValueInVM(owner); // OFFHEAP: ListOfDeltas
-                  event = new EntryEventImpl(rgn, Operation.CREATE, key, null,
+                  event = EntryEventImpl.create(rgn, Operation.CREATE, key, null,
+                  try {
-                  oldRe.setValue(owner, prepareValueForCache(owner, event.getNewValue()), event);
+                  Object preparedNewValue =oldRe.prepareValueForCache(owner,
+                      event.getNewValueAsOffHeapDeserializedOrRaw(), true);
+                  if(preparedNewValue instanceof Chunk) {
+                    event.setNewValue(preparedNewValue);
+                  }
+                  oldRe.setValue(owner, preparedNewValue, event);
+                  } finally {
+                    if (event != null) {
+                      event.release();
+                      event = null;
+                    }
+                  }
-                    event = new EntryEventImpl(owner, Operation.CREATE, key,
+                    event = EntryEventImpl.create(owner, Operation.CREATE, key,
-                    if (oldIsTombstone){
+                    if (oldIsTombstone) {
+                  if (event != null) {
+                    event.release();
+                    event = null;
+                  }
-                  event = new EntryEventImpl(owner, Operation.CREATE, key,
+                  event = EntryEventImpl.create(owner, Operation.CREATE, key,
+              if (event != null) {
+                event.release();
+                event = null;
+              }
+      } finally {
+        if (event != null) event.release();
+        OffHeapHelper.release(oldValue);
+      }
-
+    
-    RegionEntry re = getEntry(event.getKey());
+      
+    RegionEntry re = getOrCreateRegionEntry(owner, event, Token.REMOVED_PHASE1, null, true, true); 
+    /*
+     * Execute the test hook runnable inline (not threaded) if it is not null. 
+     */
+    if(null != testHookRunnableFor48182) {
+      testHookRunnableFor48182.run();
+    }    
+    
+                  
-                      if (!confirmEvictionDestroy(oldRe)) {
+                      if (!confirmEvictionDestroy(oldRe) || (owner.getEvictionCriteria() != null && !owner.getEvictionCriteria().doEvict(event))) {
+               
+				  if (isEviction) {
+                    opCompleted = false;
+                    return opCompleted; 
+                  }
-                  if (!opCompleted && !haveTombstone /* to fix bug 51583 do this for all operations */) {
+                  if (!opCompleted && !haveTombstone  /* to fix bug 51583 do this for all operations */ ) {
+                    
+				  if (!opCompleted && isEviction) {
+                  	removeEntry(event.getKey(), newRe, false);
+                  }
-          if (!isEviction || owner.concurrencyChecksEnabled) {
+          if (!isEviction || owner.concurrencyChecksEnabled) {                                 
-                  if (throwex) {
+                  if (throwex) {                    
-                      throw new EntryNotFoundException(event.getKey().toString());
+                      // Fix for 48182, check cache state and/or region state before sending entry not found.
+                      // this is from the server and any exceptions will propogate to the client
+                      owner.checkEntryNotFound(event.getKey());
+              
-                if (!confirmEvictionDestroy(re)) {
+                if (!confirmEvictionDestroy(re) || (owner.getEvictionCriteria() != null && !owner.getEvictionCriteria().doEvict(event))) {
+              if (owner.isHDFSReadWriteRegion() && re.isRemovedPhase2()) {
+                // For HDFS region there may be a race with eviction
+                // so retry the operation. fixes bug 49150
+                retry = true;
+                continue RETRY_LOOP;
+              }
-                throw new EntryNotFoundException(event.getKey().toString());
+                owner.checkEntryNotFound(event.getKey());
+    boolean cbEventInPending = false;
-              Object oldValue = re.getValueInVM(owner); // OFFHEAP escapes to eei and sqlfEvent
+              @Retained @Released Object oldValue = re.getValueInVM(owner);
+              try {
+              try {
+                  cbEventInPending = true;
+              } finally {
+                if (!cbEventInPending) cbEvent.release();
+              }
+              } finally {
+                OffHeapHelper.release(oldValue);
+              }
+                    try {
+                        cbEventInPending = true;
+                    } finally {
+                      if (!cbEventInPending) cbEvent.release();
+                    }
+              try {
+                  cbEventInPending = true;
+              } finally {
+                if (!cbEventInPending) cbEvent.release();
+              }
+        try {
+          cbEventInPending = true;
+        }
+        } finally {
+          if (!cbEventInPending) cbEvent.release();
-                        Object oldValue = oldRe.getValueInVM(owner); // OFFHEAP EntryEventImpl oldValue
+                        
+                        @Retained @Released Object oldValue = oldRe.getValueInVM(owner); // OFFHEAP EntryEventImpl oldValue
+                        
+                        try {
+                        } finally {
+                          OffHeapHelper.release(oldValue);
+                        }
-                      event.setOldValue(re.getValueInVM(owner)); // OFFHEAP escapes to EntryEventImpl oldValue
+                      
+                      @Retained @Released Object v = re.getValueInVM(owner);
+                      
+                      try {
+                        event.setOldValue(v); // OFFHEAP escapes to EntryEventImpl oldValue
+                      } finally {
+                        OffHeapHelper.release(v);
+                      }
-            throw new EntryNotFoundException(event.getKey().toString());
+            owner.checkEntryNotFound(event.getKey());
-        throw new EntryNotFoundException(event.getKey().toString());
+        owner.checkEntryNotFound(event.getKey());
+                    try {
+                    boolean cbEventInPending = false;
+                    try {
-                      oldRe.setValue(owner, prepareValueForCache(owner, newValue));
+                      oldRe.setValue(owner, oldRe.prepareValueForCache(owner, newValue, true));
+                        cbEventInPending = true;
+                    } finally {
+                      if (!cbEventInPending) cbEvent.release();
+                    }
+                    } finally {
+                      OffHeapHelper.release(oldValue);
+                    }
+                boolean cbEventInPending = false;
+                try {
-                  newRe.setValue(owner, prepareValueForCache(owner, newValue));
+                  newRe.setValue(owner, newRe.prepareValueForCache(owner, newValue, true));
+                    cbEventInPending = true;
+                } finally {
+                  if (!cbEventInPending) cbEvent.release();
+                }
+                boolean cbEventInPending = false;
+                try {
-                  re.setValue(owner, prepareValueForCache(owner, newValue));
+                  re.setValue(owner, re.prepareValueForCache(owner, newValue, true));
+                    cbEventInPending = true;
+                } finally {
+                  if (!cbEventInPending) cbEvent.release();
+                }
+          boolean cbEventInPending = false;
+          try {
+            cbEventInPending = true;
+          }
+          } finally {
+            if (!cbEventInPending) cbEvent.release();
-  private RegionEntry getOrCreateRegionEntry(Object ownerRegion, Object key, Object value, boolean onlyExisting) {
-    RegionEntry retVal = getEntry(key);
+  private RegionEntry getOrCreateRegionEntry(Object ownerRegion,
+      EntryEventImpl event, Object value,
+      MapCallbackAdapter<Object, Object, Object, Object> valueCreator,
+      boolean onlyExisting, boolean returnTombstone) {
+    Object key = event.getKey();
+    RegionEntry retVal = null;
+    if (event.isFetchFromHDFS()) {
+      retVal = getEntry(event);
+    } else {
+      retVal = getEntryInVM(key);
+    }
-      if (retVal != null && retVal.isTombstone()) {
+      if (!returnTombstone && (retVal != null && retVal.isTombstone())) {
+    if (valueCreator != null) {
+      value = valueCreator.newValue(key, ownerRegion, value, null);
+    }
+      if (retVal instanceof OffHeapRegionEntry) {
+        ((OffHeapRegionEntry) retVal).release();
+      }
+  protected static final MapCallbackAdapter<Object, Object, Object, Object>
+      listOfDeltasCreator = new MapCallbackAdapter<Object, Object,
+          Object, Object>() {
+    @Override
+    public Object newValue(Object key, Object context, Object createParams,
+        final MapResult result) {
+      return new ListOfDeltas(4);
+    }
+  };
+  
-          final Delta delta = (Delta)event.getRawNewValue();
-          RegionEntry re = getOrCreateRegionEntry(owner, event.getKey(), new ListOfDeltas(delta), false);
+          final Delta delta = event.getDeltaNewValue();
+		  RegionEntry re = getOrCreateRegionEntry(owner, event, null,
+          	  listOfDeltasCreator, false, false);
-            Object oVal = re.getValueInVMOrDiskWithoutFaultIn(owner);
+            @Retained @Released Object oVal = re.getValueOffHeapOrDiskWithoutFaultIn(owner);
+              try {
+                @Retained Object newVal = ((AbstractRegionEntry)re).prepareValueForCache(owner, oVal, true);              
+                re.setValue(owner, newVal); // TODO:KIRK:48068 prevent orphan
+              }finally {
+                OffHeapHelper.release(oVal);
+              }
-              Object newVal = new ListOfDeltas(delta);
-              re.setValue(owner, newVal); // TODO no need to call AbstractRegionMap.prepareValueForCache here?
+              @Retained Object newVal = new ListOfDeltas(delta);
+              // TODO no need to call AbstractRegionMap.prepareValueForCache here?
+              newVal = ((AbstractRegionEntry)re).prepareValueForCache(owner, newVal, true);
+              re.setValue(owner, newVal); // TODO:KIRK:48068 prevent orphan
-    Object oldValueForDelta = null;
-        re = getOrCreateRegionEntry(owner, event.getKey(), Token.REMOVED_PHASE1, onlyExisting);
+		re = getOrCreateRegionEntry(owner, event, 
+		    Token.REMOVED_PHASE1, null, onlyExisting, false);
-              re = getOrCreateRegionEntry(owner, event.getKey(), Token.REMOVED_PHASE1, onlyExisting);
-              _getOwner().getCachePerfStats().incRetries();
+                re = getOrCreateRegionEntry(owner, event,
+                    Token.REMOVED_PHASE1, null, onlyExisting, false);
+                _getOwner().getCachePerfStats().incRetries();
+              @Released Object oldValueForDelta = null;
-                try {
-
-                    if ((cacheWrite && event.getOperation().isUpdate()) // if there is a cacheWriter, type of event has already been set
-                        || !re.isRemoved()
-                        || replaceOnClient) {
-                      // update
-                      updateEntry(event, requireOldValue, oldValueForDelta, re);
-                    } else {
-                      // create
-                      createEntry(event, owner, re);
+                    try {
+                      if ((cacheWrite && event.getOperation().isUpdate()) // if there is a cacheWriter, type of event has already been set
+                          || !re.isRemoved()
+                          || replaceOnClient) {
+                        // update
+                        updateEntry(event, requireOldValue, oldValueForDelta, re);
+                      } else {
+                        // create
+                        createEntry(event, owner, re);
+                      }
+                      owner.recordEvent(event);
+                      eventRecorded = true;
+                    } catch (RegionClearedException rce) {
+                      clearOccured = true;
+                      owner.recordEvent(event);
+                    } catch (ConcurrentCacheModificationException ccme) {
+                      VersionTag tag = event.getVersionTag();
+                      if (tag != null && tag.isTimeStampUpdated()) {
+                        // Notify gateways of new time-stamp.
+                        owner.notifyTimestampsToGateways(event);
+                      }
+                      throw ccme;
-                    owner.recordEvent(event);
-                    eventRecorded = true;
-                  } catch (RegionClearedException rce) {
-                    clearOccured = true;
-                    owner.recordEvent(event);
-                  } catch (ConcurrentCacheModificationException ccme) {
-                    VersionTag tag = event.getVersionTag();
-                    if (tag != null && tag.isTimeStampUpdated()) {
-                      // Notify gateways of new time-stamp.
-                      owner.notifyTimestampsToGateways(event);
+                    if (uninitialized) {
+                      event.inhibitCacheListenerNotification(true);
-                    throw ccme;
-                  }
-                  if (uninitialized) {
-                    event.inhibitCacheListenerNotification(true);
-                  }
-                  updateLru(clearOccured, re, event);
+                    updateLru(clearOccured, re, event);
-                  lastModifiedTime = owner.basicPutPart2(event, re,
-                      !uninitialized, lastModifiedTime, clearOccured);
+                    lastModifiedTime = owner.basicPutPart2(event, re,
+                        !uninitialized, lastModifiedTime, clearOccured);
+                  } finally {
+                    notifyIndex(re, false);
+                  }
+                  result = re;
+                  break;
-                  notifyIndex(re, false);
-                }
-                result = re;
-                break;
-              } finally {
-                if (re != null && !isOpComplete(re, event)) {
-                  owner.cleanUpOnIncompleteOp(event, re, eventRecorded,
-                      false/* updateStats */, replaceOnClient);
+                  OffHeapHelper.release(oldValueForDelta);
+                  if (re != null && !onlyExisting && !isOpComplete(re, event)) {
+                    owner.cleanUpOnIncompleteOp(event, re, eventRecorded,
+                        false/* updateStats */, replaceOnClient);
+                  }
+                  else if (re != null && owner.isUsedForPartitionedRegionBucket()) {
+                  BucketRegion br = (BucketRegion)owner;
+                  CachePerfStats stats = br.getPartitionedRegion().getCachePerfStats();
+                  long startTime= stats.startCustomEviction();
+                  CustomEvictionAttributes csAttr = br.getCustomEvictionAttributes();
+                  // No need to update indexes if entry was faulted in but operation did not succeed. 
+                  if (csAttr != null && (csAttr.isEvictIncoming() || re.isMarkedForEviction())) {
+                    
+                    if (csAttr.getCriteria().doEvict(event)) {
+                      stats.incEvictionsInProgress();
+                      // set the flag on event saying the entry should be evicted 
+                      // and not indexed
+                      EntryEventImpl destroyEvent = EntryEventImpl.create (owner, Operation.DESTROY, event.getKey(),
+                          null/* newValue */, null, false, owner.getMyId());
+                      try {
+
+                      destroyEvent.setOldValueFromRegion();
+                      destroyEvent.setCustomEviction(true);
+                      destroyEvent.setPossibleDuplicate(event.isPossibleDuplicate());
+                      if(logger.isDebugEnabled()) {
+                        logger.debug("Evicting the entry " + destroyEvent);
+                      }
+                      if(result != null) {
+                        removeEntry(event.getKey(),re, true, destroyEvent,owner, indexUpdater);
+                      }
+                      else{
+                        removeEntry(event.getKey(),re, true, destroyEvent,owner, null);
+                      }
+                      //mark the region entry for this event as evicted 
+                      event.setEvicted();
+                      stats.incEvictions();
+                      if(logger.isDebugEnabled()) {
+                        logger.debug("Evicted the entry " + destroyEvent);
+                      }
+                      //removeEntry(event.getKey(), re);
+                      } finally {
+                        destroyEvent.release();
+                        stats.decEvictionsInProgress();
+                      }
+                    } else {
+                      re.clearMarkedForEviction();
+                    }
+                  }
+                  stats.endCustomEviction(startTime);
-      Object v = re._getValueUse(event.getLocalRegion(), true);
-        if (!AbstractRegionEntry.checkExpectedOldValue(expectedOldValue, v)) {
+      SimpleMemoryAllocatorImpl.skipRefCountTracking();
+      
+      @Retained @Released Object v = re._getValueRetain(event.getLocalRegion(), true);
+      
+      SimpleMemoryAllocatorImpl.unskipRefCountTracking();
+      try {
+        if (!AbstractRegionEntry.checkExpectedOldValue(expectedOldValue, v, event.getLocalRegion())) {
+      } finally {
+        OffHeapHelper.releaseWithNoTracking(v);
+      }
+  // PRECONDITION: caller must be synced on re
-    if (getIndexUpdater() != null || cacheWrite || requireOldValue ||
-        event.getOperation().guaranteesOldValue()) {
-      if (event.hasDelta() || event.getOperation().guaranteesOldValue()) {
-        Object oldValueInVMOrDisk = re.getValueOffHeapOrDiskWithoutFaultIn(event.getLocalRegion());
-          event.setOldValue(oldValueInVMOrDisk, requireOldValue);
+    boolean needToSetOldValue = getIndexUpdater() != null || cacheWrite || requireOldValue || event.getOperation().guaranteesOldValue();
+    if (needToSetOldValue) {
+      if (event.hasDelta() || event.getOperation().guaranteesOldValue()
+          || GemFireCacheImpl.sqlfSystem()) {
+        // In these cases we want to even get the old value from disk if it is not in memory
+        SimpleMemoryAllocatorImpl.skipRefCountTracking();
+        @Released Object oldValueInVMOrDisk = re.getValueOffHeapOrDiskWithoutFaultIn(event.getLocalRegion());
+        SimpleMemoryAllocatorImpl.unskipRefCountTracking();
+        try {
+          event.setOldValue(oldValueInVMOrDisk, requireOldValue
+              || GemFireCacheImpl.sqlfSystem());
+        } finally {
+          OffHeapHelper.releaseWithNoTracking(oldValueInVMOrDisk);
+        }
-        Object oldValueInVM = re._getValueUse(event.getLocalRegion(), true); // OFFHEAP: re synced so can use its ref.
-          event.setOldValue(oldValueInVM, requireOldValue);
+        // In these cases only need the old value if it is in memory
+        SimpleMemoryAllocatorImpl.skipRefCountTracking();
+        
+        @Retained @Released Object oldValueInVM = re._getValueRetain(event.getLocalRegion(), true); // OFFHEAP: re synced so can use its ref.
+        
+        SimpleMemoryAllocatorImpl.unskipRefCountTracking();
+        try {
+          event.setOldValue(oldValueInVM,
+              requireOldValue || GemFireCacheImpl.sqlfSystem());
+        } finally {
+          OffHeapHelper.releaseWithNoTracking(oldValueInVM);
+        }
+      }
+    } else {
+      // if the old value is in memory then if it is a GatewaySenderEventImpl then
+      // we want to set the old value.
+      @Unretained Object ov = re._getValue(); // OFFHEAP _getValue is ok since re is synced and we only use it if its a GatewaySenderEventImpl.
+      // Since GatewaySenderEventImpl is never stored in an off-heap region nor a compressed region we don't need to worry about ov being compressed.
+      if (ov instanceof GatewaySenderEventImpl) {
+        event.setOldValue(ov, true);
-      boolean inTokenMode, boolean cacheWrite, Object expectedOldValue,
+      boolean inTokenMode, boolean cacheWrite, @Released Object expectedOldValue,
+    boolean cbEventInPending = false;
+    try {
-                        re.setValue(owner, prepareValueForCache(owner, newValue, cbEvent));
+                        re.setValue(owner, re.prepareValueForCache(owner, newValue, cbEvent, !putOp.isCreate()));
+                      cbEventInPending = true;
-                        oldRe.setValue(owner, prepareValueForCache(owner, newValue, cbEvent));
+                        oldRe.setValue(owner, oldRe.prepareValueForCache(owner, newValue, cbEvent, !putOp.isCreate()));
+                      cbEventInPending = true;
-                    newRe.setValue(owner, prepareValueForCache(owner, newValue, cbEvent));
+                    newRe.setValue(owner, newRe.prepareValueForCache(owner, newValue, cbEvent, !putOp.isCreate()));
+                  cbEventInPending = true;
+    } finally {
+      if (!cbEventInPending) cbEvent.release();
+      if (sqlfEvent != null) sqlfEvent.release();
+    }
+
+      // For distributed transactions, stuff the next region version generated
+      // in phase-1 commit into the cbEvent so that ARE.generateVersionTag can later
+      // just apply it and not regenerate it in phase-2 commit
+      if (cbEvent != null && txEntryState != null && txEntryState.getDistTxEntryStates() != null) {
+        cbEvent.setNextRegionVersion(txEntryState.getDistTxEntryStates().getRegionVersion());  
+      }
+      
+      //cbEvent.setNextRegionVersion(txEntryState.getNextRegionVersion());
-  public static Object prepareValueForCache(RegionEntryContext r, Object val) {
-    return prepareValueForCache(r, val, null);
-  }
-  /**
-   * Prepares and returns a value to be stored in the cache.
-   * Current prep is to make sure a PdxInstance is not stored in the cache
-   * and to copy values into offheap memory of the region is using off heap storage.
-   * 
-   * @param r the region the prepared object will be stored in
-   * @param val the value that will be stored
-   * @return the prepared value
-   */
-  public static Object prepareValueForCache(RegionEntryContext r, Object val, EntryEventImpl event) {
-    Object nv = val;
-    if (nv instanceof PdxInstance) {
-      // We do not want to put PDXs in the cache as values.
-      // So get the serialized bytes and use a CachedDeserializable.
-      try {
-        byte[] data = ((ConvertableToBytes)nv).toBytes();
-        byte[] compressedData = compressBytes(r, data);
-        if (data == compressedData) {
-          nv = CachedDeserializableFactory.create(data);
-        } else {
-          nv = compressedData;
-        }
-      } catch (IOException e) {
-        throw new PdxSerializationException("Could not convert " + nv + " to bytes", e);
-      }
-    } else {
-      nv = AbstractRegionEntry.compress(r, nv, event);
-    }
-    return nv;
-  }
-  
-  private static byte[] compressBytes(RegionEntryContext context, byte[] value) {
-    if (AbstractRegionEntry.isCompressible(context, value)) {
-      value = context.getCompressor().compress(value);
-    }
-    return value;
-  }
-  
-    EntryEventImpl retVal = new EntryEventImpl(
+    EntryEventImpl retVal = EntryEventImpl.create(
+    boolean returnedRetVal = false;
+    try {
+ 
+    returnedRetVal = true;
+    } finally {
+      if (!returnedRetVal) {
+        retVal.release();
+      }
+    }
-    int entryVersion = re.getVersionStamp().getEntryVersion();
+    VersionStamp vs = re.getVersionStamp();
+    if (vs == null) {
+      // if we have no VersionStamp why were we even added as a tombstone?
+      // We used to see an NPE here. See bug 52092.
+      logger.error("Unexpected RegionEntry scheduled as tombstone: re.getClass {} destroyedVersion {}", re.getClass(), destroyedVersion);
+      return true;
+    }
+    int entryVersion = vs.getEntryVersion();
+    synchronized(this._getOwner().getSizeGuard()) { // do this sync first; see bug 51985
-         synchronized(this._getOwner().getSizeGuard()) {

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV31 MOV31 MOV31 MOV31 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS23 INS31 INS31 INS29 INS83 INS43 INS59 INS79 INS78 INS74 UPD42 UPD83 INS43 UPD42 MOV44 INS8 UPD83 INS43 INS42 INS44 INS8 UPD83 INS83 INS43 UPD42 MOV44 MOV44 INS78 MOV83 UPD83 MOV83 INS43 INS42 INS44 INS8 UPD83 MOV83 INS39 INS42 INS8 INS78 MOV44 INS44 INS44 MOV25 INS83 INS83 INS83 INS74 INS59 INS83 INS39 INS42 MOV44 MOV44 MOV44 MOV44 INS8 INS83 INS39 INS42 MOV44 MOV44 MOV44 MOV44 INS8 MOV8 INS65 INS42 INS42 INS33 INS60 INS25 INS42 INS4 INS42 INS43 MOV43 INS42 INS60 INS25 INS41 INS42 INS43 INS42 INS41 INS42 INS60 MOV41 INS42 INS42 INS43 INS42 INS60 INS25 INS41 INS25 MOV25 INS21 INS42 INS60 INS74 INS42 INS39 INS42 INS60 INS60 INS25 INS25 INS43 MOV43 INS43 INS43 INS43 INS42 INS14 INS25 MOV41 INS60 INS25 INS78 INS60 INS54 INS60 INS54 INS25 INS60 MOV60 MOV60 MOV60 MOV41 INS66 INS66 INS39 INS59 INS27 INS8 INS45 INS45 INS42 INS11 INS43 INS59 INS27 INS8 INS42 INS42 INS32 MOV43 INS59 INS27 MOV42 INS43 INS59 INS27 MOV8 INS42 INS27 MOV8 INS27 INS32 INS78 INS8 INS39 INS59 INS42 INS43 MOV43 INS43 INS43 INS43 INS43 INS59 MOV43 INS59 INS32 INS8 INS8 INS27 MOV27 INS8 INS42 UPD42 MOV42 INS42 INS42 INS74 INS1 MOV27 INS8 INS39 INS59 INS42 INS8 INS8 INS42 INS39 INS59 INS8 INS8 MOV43 INS59 INS39 INS59 INS8 INS8 INS43 INS27 INS8 INS39 INS59 INS8 INS42 INS9 INS21 INS42 INS32 INS41 INS32 INS43 INS32 INS42 INS42 MOV11 INS27 INS32 MOV41 UPD42 MOV42 INS32 INS42 MOV11 INS27 MOV32 MOV42 INS21 UPD42 MOV42 INS42 INS11 INS27 INS32 MOV27 INS38 INS27 INS38 INS25 INS42 INS33 INS42 MOV60 MOV60 INS60 INS54 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 MOV42 INS33 INS42 INS42 INS21 INS21 INS42 INS33 INS21 INS25 MOV41 INS43 MOV43 INS43 MOV43 INS43 INS31 INS21 MOV60 INS21 INS54 UPD42 MOV42 MOV27 INS25 INS60 MOV25 INS42 INS9 MOV25 MOV25 MOV25 MOV60 MOV60 MOV25 MOV21 MOV54 INS25 INS25 INS25 INS42 INS32 INS42 INS9 MOV25 MOV25 MOV25 MOV21 MOV60 MOV60 MOV25 MOV25 MOV25 MOV21 INS21 MOV41 INS25 INS42 UPD42 MOV32 INS42 INS33 INS21 INS41 INS42 INS32 INS51 INS7 INS21 INS42 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS42 INS33 UPD42 MOV42 UPD42 MOV42 INS27 INS32 UPD42 INS32 INS32 INS43 INS32 INS42 INS33 INS42 INS42 INS32 INS32 INS27 INS32 INS27 INS8 INS78 INS78 INS43 INS59 MOV8 INS8 MOV38 INS8 INS42 INS42 INS7 INS7 INS27 INS7 INS62 INS8 INS42 UPD42 MOV42 INS42 INS78 INS83 INS43 INS42 MOV44 INS44 INS44 INS44 INS8 INS32 INS78 INS78 INS43 INS32 INS8 INS8 MOV27 INS8 INS8 INS78 INS43 INS59 INS62 INS38 INS21 INS27 INS21 INS27 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV27 INS42 INS7 INS38 INS8 INS32 INS9 INS42 INS42 INS42 MOV8 INS42 INS32 INS7 INS42 INS27 INS36 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV32 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS38 INS54 INS54 MOV21 MOV43 INS42 INS42 INS42 INS42 INS33 INS25 INS21 INS21 INS42 INS32 INS42 INS32 INS38 INS36 INS42 INS32 INS42 INS43 INS21 INS42 MOV42 MOV43 INS42 MOV43 INS42 INS83 INS43 INS42 INS41 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS25 INS21 INS32 INS21 MOV60 INS21 INS54 INS21 MOV60 INS21 INS54 INS42 UPD42 MOV42 INS42 INS32 INS42 INS43 INS42 INS32 INS42 INS33 INS32 INS27 INS27 INS21 INS42 INS9 INS42 INS21 INS42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS62 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS42 INS42 INS42 INS32 INS8 INS12 INS78 INS78 INS8 INS8 MOV42 INS27 INS21 INS32 INS25 INS32 INS42 INS42 UPD42 MOV42 MOV42 INS42 MOV27 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS32 UPD42 MOV42 MOV14 MOV42 INS33 INS9 UPD42 INS38 MOV8 INS32 INS42 INS42 INS32 INS78 INS32 INS8 INS8 INS32 INS78 INS78 MOV43 INS32 INS8 INS8 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS27 INS27 INS32 INS33 INS32 INS32 INS42 INS42 INS36 INS42 INS42 INS43 INS36 UPD42 INS42 INS42 INS42 INS21 INS44 INS8 INS42 INS42 MOV25 MOV25 MOV60 MOV21 MOV25 MOV21 MOV21 MOV21 INS25 INS42 INS33 INS32 INS42 INS42 INS42 INS27 INS8 INS54 INS42 INS42 MOV32 INS60 INS54 INS36 INS42 INS34 INS32 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 MOV21 MOV21 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 MOV21 INS21 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS9 INS42 INS33 INS42 INS33 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS11 INS42 INS11 INS32 INS43 INS42 UPD42 INS32 INS8 UPD42 UPD42 INS8 INS42 INS42 INS33 INS42 INS21 INS8 INS8 INS42 INS42 INS39 INS59 INS8 INS8 INS11 MOV43 INS42 INS42 INS42 INS42 INS32 INS32 INS32 UPD42 INS32 INS32 INS32 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS21 INS25 INS53 UPD42 INS42 MOV42 INS40 INS33 INS9 INS9 INS32 MOV25 MOV21 MOV25 INS25 MOV38 INS8 INS42 INS9 MOV21 MOV25 INS25 INS43 INS42 INS32 MOV60 UPD42 MOV42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS62 INS8 INS14 INS42 INS42 INS8 MOV8 INS38 INS21 INS21 INS60 INS54 MOV8 INS38 INS21 INS42 MOV42 UPD42 MOV42 MOV42 INS33 UPD42 MOV42 INS9 INS78 INS78 INS8 INS78 INS8 INS42 INS32 INS42 INS32 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS25 INS36 INS42 INS42 INS43 INS21 INS43 INS27 MOV60 INS60 INS54 INS21 INS42 INS32 INS32 INS60 INS54 INS39 INS59 INS8 INS8 INS21 INS42 INS32 INS42 INS42 INS54 INS21 INS42 INS21 INS25 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS8 MOV8 INS42 INS8 MOV8 INS42 INS8 MOV8 INS42 INS8 MOV8 INS42 INS8 MOV8 INS42 INS8 MOV8 INS42 INS8 MOV8 INS42 INS8 MOV8 INS42 INS8 MOV8 INS42 INS8 MOV8 INS42 INS8 MOV8 INS42 INS8 MOV8 INS42 INS8 MOV8 INS42 INS8 MOV8 INS42 INS8 MOV8 INS42 INS8 MOV8 INS11 INS42 INS32 INS42 INS45 INS42 INS45 INS78 INS78 INS43 INS59 MOV8 INS8 INS54 INS7 INS42 INS42 INS42 INS42 MOV32 INS39 INS59 INS8 INS8 INS42 INS9 MOV21 MOV21 MOV21 MOV25 MOV25 MOV21 MOV21 MOV60 MOV54 MOV21 MOV25 MOV25 MOV25 MOV25 INS7 INS42 INS42 UPD42 MOV8 INS8 INS78 INS7 MOV42 INS33 INS9 INS32 MOV27 MOV8 INS25 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS25 INS43 INS42 INS36 INS42 INS25 INS42 INS42 INS42 INS42 INS32 INS54 INS21 INS8 INS8 INS42 INS9 INS42 INS42 INS9 MOV21 MOV21 MOV21 MOV60 MOV54 MOV21 MOV25 MOV21 MOV25 MOV25 INS25 INS38 INS21 INS42 INS9 INS21 INS42 INS42 INS32 INS42 INS42 INS42 INS27 INS27 INS8 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS32 INS8 INS42 INS11 INS27 INS8 INS42 INS42 INS42 INS8 INS8 INS32 MOV21 MOV21 MOV25 MOV25 MOV21 MOV25 MOV21 MOV21 MOV25 MOV21 MOV25 INS38 INS21 INS42 MOV32 INS32 INS36 INS42 INS42 INS42 INS9 MOV27 INS38 INS27 INS32 INS60 INS60 INS60 INS60 INS25 INS21 MOV8 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS21 INS43 INS42 INS42 INS33 INS21 INS21 MOV25 MOV21 MOV25 MOV21 MOV25 MOV60 MOV54 MOV21 MOV25 MOV25 MOV25 INS25 INS42 INS42 INS42 INS38 INS21 INS54 INS42 INS32 INS8 UPD42 UPD42 INS60 INS21 INS42 INS42 INS42 INS11 INS42 INS42 INS33 INS42 INS42 MOV43 INS59 INS43 INS59 INS39 INS59 INS43 INS59 INS27 INS8 INS32 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS7 INS25 INS38 INS21 INS42 MOV32 INS8 INS8 INS42 INS42 INS21 INS21 INS78 INS43 INS59 INS32 INS43 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS27 INS36 INS25 INS42 INS42 INS42 INS7 INS42 INS42 INS32 INS21 INS25 INS42 INS42 INS42 INS33 INS27 INS8 INS42 INS32 UPD42 MOV60 INS60 MOV21 INS54 INS21 MOV21 INS21 INS42 INS9 INS32 INS7 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS27 INS32 INS8 INS8 INS42 INS9 INS42 INS42 INS7 INS27 INS8 INS32 INS32 INS21 INS18 INS21 INS8 UPD42 MOV42 UPD42 MOV42 INS54 INS21 INS39 INS59 INS8 INS8 INS32 INS42 INS9 MOV32 INS7 INS42 INS42 INS42 INS42 INS9 INS36 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS32 INS32 INS32 INS42 INS42 INS21 INS60 INS54 INS21 INS8 INS42 INS32 INS54 INS42 INS33 INS21 INS21 INS32 INS27 INS42 INS42 INS42 INS42 INS7 INS42 INS32 MOV21 INS21 INS8 INS8 INS7 INS8 INS8 INS42 INS9 MOV21 MOV21 MOV25 MOV21 MOV25 MOV25 MOV21 MOV21 MOV60 MOV54 MOV21 INS25 MOV25 MOV25 INS25 INS42 INS42 INS42 INS42 INS9 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS32 MOV43 INS59 MOV8 INS8 INS32 MOV21 INS21 INS21 MOV42 MOV42 MOV42 INS8 INS8 INS32 INS7 INS42 INS42 INS42 INS40 INS42 INS42 INS40 INS9 INS33 INS25 MOV38 INS36 INS42 INS9 INS42 INS42 MOV32 INS7 MOV21 MOV21 MOV25 MOV25 MOV21 INS25 MOV60 MOV60 MOV8 MOV21 MOV21 MOV25 MOV21 MOV21 MOV21 INS25 INS42 INS9 INS60 INS54 INS60 INS54 INS42 INS8 INS38 INS21 INS43 INS42 INS42 INS42 INS42 INS32 INS21 INS21 INS21 INS25 INS21 INS21 INS25 INS21 INS21 INS42 INS42 INS7 INS7 INS42 INS38 INS32 MOV21 MOV25 MOV21 INS60 INS25 INS21 MOV21 MOV54 INS25 INS32 INS42 INS42 INS42 INS33 INS27 INS8 INS27 INS42 INS9 INS42 INS8 INS38 INS21 INS78 INS78 INS43 INS59 MOV8 INS8 INS78 INS78 INS43 INS59 INS8 INS8 MOV21 INS25 INS42 INS32 INS42 INS42 INS42 INS42 INS40 MOV32 INS33 INS33 INS9 INS32 INS32 INS32 INS32 INS32 INS8 INS27 MOV8 MOV8 INS32 INS32 INS32 INS8 INS32 INS32 INS42 INS9 INS42 INS9 INS32 INS42 INS42 INS42 INS40 INS42 INS33 INS40 INS9 INS33 MOV43 INS59 INS62 INS8 INS32 INS27 INS8 INS42 INS42 INS42 INS40 INS42 INS42 INS40 INS9 INS33 INS25 INS38 INS42 INS21 INS27 INS38 MOV21 INS25 INS42 INS32 INS42 INS42 INS42 INS42 INS32 INS21 INS42 INS42 INS42 INS42 MOV32 MOV21 INS21 MOV27 MOV8 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS42 INS32 INS42 INS42 INS21 INS42 INS33 INS21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS21 INS42 INS42 MOV42 INS42 INS42 INS42 INS33 INS21 INS21 INS42 INS8 INS42 INS32 INS32 INS33 INS32 MOV27 MOV8 INS8 INS42 INS42 INS42 INS42 INS42 INS32 INS32 MOV21 INS21 INS42 INS42 INS32 MOV32 MOV32 MOV32 MOV32 INS32 MOV42 UPD42 MOV42 MOV42 INS32 INS9 INS42 INS32 INS32 INS7 INS21 INS41 INS42 INS32 INS42 INS9 INS42 INS42 INS32 INS42 INS42 MOV21 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS7 INS42 INS42 INS27 UPD42 INS42 INS9 INS42 INS42 INS42 UPD42 INS42 INS9 INS42 INS42 INS33 INS42 INS42 INS27 INS42 INS38 INS42 INS38 INS42 INS42 INS42 INS42 INS42 MOV42 UPD42 MOV42 INS42 INS33 INS27 INS7 INS42 INS42 INS42 INS21 INS42 INS42 INS32 INS7 INS42 INS9 INS45 INS42 INS45 INS42 INS32 INS32 MOV38 INS36 INS42 INS9 INS32 MOV42 MOV42 MOV40 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS32 INS27 INS38 UPD42 MOV42 INS42 INS32 INS33 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 DEL83 DEL8 DEL39 DEL42 DEL42 DEL32 DEL38 DEL25 DEL8 DEL25 DEL8 DEL39 DEL42 DEL9 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL25 DEL62 DEL42 DEL59 DEL60 DEL42 DEL40 DEL27 DEL42 DEL33 DEL7 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL8 DEL25 DEL8 DEL25 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL40 DEL42 DEL33 DEL40 DEL9 DEL33 DEL14 DEL42 DEL32 DEL32 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL40 DEL42 DEL42 DEL40 DEL9 DEL33 DEL14 DEL42 DEL43 DEL42 DEL40 DEL42 DEL42 DEL40 DEL9 DEL33 DEL14 DEL42 DEL32 DEL42 DEL43 DEL32 DEL14 DEL53 DEL42 DEL43 DEL42 DEL32 DEL14 DEL53 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL42 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL8 DEL42 DEL8 DEL25 DEL8 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL32 DEL11 DEL42 DEL43 DEL14 DEL53 DEL42 DEL43 DEL14 DEL53 DEL42 DEL42 DEL32 DEL7 DEL42 DEL42 DEL7 DEL42 DEL42 DEL32 DEL7 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL7 DEL8 DEL42 DEL42 DEL44 DEL42 DEL44 DEL33 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL42 DEL59 DEL60 DEL42 DEL43 DEL62 DEL39 DEL85 DEL5 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL32 DEL59 DEL60 DEL39 DEL85 DEL5 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL8 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL42 DEL45 DEL27 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL85 DEL5 DEL42 DEL43 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL8 DEL31 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL14 DEL59 DEL39 DEL42 DEL32 DEL42 DEL51 DEL8
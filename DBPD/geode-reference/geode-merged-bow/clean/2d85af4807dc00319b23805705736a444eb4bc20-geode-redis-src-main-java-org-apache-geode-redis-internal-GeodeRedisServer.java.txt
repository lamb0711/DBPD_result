GEODE-8166: reimplement redis expiration to use new data model (#5174)

* Added timestamp field to RedisData and implemented serialization and delta for it.
Both active and passive expiration have been implemented.

* RedisHash, RedisSet, and RedisString now subclass AbstractRedisData
* type command now uses function
* getset, incr, decr, incrby, and decrby now uses function and is atomic

+import static java.util.concurrent.TimeUnit.SECONDS;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
+import java.util.Map;
-import java.util.concurrent.ScheduledFuture;
+import org.apache.geode.cache.partition.PartitionRegionHelper;
+import org.apache.geode.redis.internal.executor.RedisKeyCommands;
+import org.apache.geode.redis.internal.executor.RedisKeyCommandsFunctionExecutor;
-  private static final int numExpirationThreads = 1;
-   * Map of futures to be executed for key expirations
-   */
-  private final ConcurrentMap<ByteArrayWrapper, ScheduledFuture<?>> expirationFutures;
-
-  /**
-    expirationFutures = new ConcurrentHashMap<>();
-    expirationExecutor =
-        Executors.newScheduledThreadPool(numExpirationThreads,
-            new NamedThreadFactory("GemFireRedis-ScheduledExecutor-", true));
+    expirationExecutor = Executors.newSingleThreadScheduledExecutor(
+        new NamedThreadFactory("GemFireRedis-ExpirationExecutor-", true));
-      regionProvider = new RegionProvider(expirationFutures, expirationExecutor, redisData);
+      regionProvider = new RegionProvider(redisData);
-      CommandFunction.register(regionProvider);
+      CommandFunction.register();
+      scheduleDataExpiration(redisData);
+    }
+  }
+
+  private void scheduleDataExpiration(
+      Region<ByteArrayWrapper, RedisData> redisData) {
+    int INTERVAL = 1;
+    expirationExecutor.scheduleAtFixedRate(() -> doDataExpiration(redisData), INTERVAL, INTERVAL,
+        SECONDS);
+  }
+
+  private void doDataExpiration(
+      Region<ByteArrayWrapper, RedisData> redisData) {
+    final long now = System.currentTimeMillis();
+    Region<ByteArrayWrapper, RedisData> localPrimaryData =
+        PartitionRegionHelper.getLocalPrimaryData(redisData);
+    RedisKeyCommands redisKeyCommands = new RedisKeyCommandsFunctionExecutor(redisData);
+    for (Map.Entry<ByteArrayWrapper, RedisData> entry : localPrimaryData.entrySet()) {
+      if (entry.getValue().hasExpired(now)) {
+        // pttl will do its own check using active expiration and expire the key if needed
+        redisKeyCommands.pttl(entry.getKey());
+      }
-      regionProvider.close();
-      for (ScheduledFuture<?> f : expirationFutures.values()) {
-        f.cancel(true);
-      }
-      expirationFutures.clear();

MOV26 MOV26 INS26 INS26 UPD40 UPD40 UPD40 INS40 INS40 INS31 INS31 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS74 INS42 INS60 INS21 INS74 INS42 INS60 INS60 INS60 INS70 INS43 MOV43 INS43 INS39 INS59 INS32 INS43 INS43 INS43 INS83 INS39 INS59 INS74 INS59 INS43 INS59 INS44 INS32 INS8 INS21 INS42 INS42 UPD42 MOV42 MOV34 INS42 INS42 INS86 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 UPD43 MOV43 UPD43 MOV43 INS43 INS42 INS32 INS42 INS42 INS14 INS74 INS42 INS42 INS42 INS25 UPD42 INS32 INS32 INS42 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS43 INS42 INS43 INS43 INS43 INS32 INS8 UPD45 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS32 INS42 INS42 INS21 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 DEL83 DEL83 DEL83 DEL39 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL83 DEL76 DEL74 DEL74 DEL42 DEL59 DEL23 DEL42 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL76 DEL74 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL70 DEL42 DEL42 DEL32 DEL21
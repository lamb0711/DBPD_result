Merge branch 'develop' into feature/GEODE-6187

+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.LowMemoryException;
-import org.apache.geode.cache.execute.FunctionService;
+import org.apache.geode.cache.execute.ResultSender;
+import org.apache.geode.internal.cache.execute.InternalFunctionExecutionService;
+import org.apache.geode.internal.cache.execute.InternalFunctionService;
-  protected static volatile boolean ASYNC_TX_WARNING_ISSUED = false;
+  private static volatile boolean asyncTxWarningIssued;
-  static final ExecutorService execService =
+  private static final ExecutorService execService =
-  ExecuteFunction66() {}
+  private final InternalFunctionExecutionService internalFunctionExecutionService;
+  private final ServerToClientFunctionResultSender65Factory serverToClientFunctionResultSender65Factory;
+  private final FunctionContextImplFactory functionContextImplFactory;
+
+  ExecuteFunction66() {
+    this(InternalFunctionService.getInternalFunctionExecutionService(),
+        new DefaultServerToClientFunctionResultSender65Factory(),
+        new DefaultFunctionContextImplFactory());
+  }
+
+  ExecuteFunction66(InternalFunctionExecutionService internalFunctionExecutionService,
+      ServerToClientFunctionResultSender65Factory serverToClientFunctionResultSender65Factory,
+      FunctionContextImplFactory functionContextImplFactory) {
+    this.internalFunctionExecutionService = internalFunctionExecutionService;
+    this.serverToClientFunctionResultSender65Factory = serverToClientFunctionResultSender65Factory;
+    this.functionContextImplFactory = functionContextImplFactory;
+  }
-    Object args = null;
+    Object args;
-    String[] groups = null;
+    String[] groups;
-    byte functionState = 0;
+    byte functionState;
-    boolean allMembers = false;
-    boolean ignoreFailedMembers = false;
+    boolean allMembers;
+    boolean ignoreFailedMembers;
+
-    } catch (ClassNotFoundException exception) {
-      logger.warn(String.format("Exception on server while executing function: %s",
-          function),
-          exception);
+    } catch (ClassNotFoundException e) {
+      logger.warn("Exception on server while executing function: {}", function, e);
-        writeChunkedException(clientMessage, exception, serverConnection);
+        writeChunkedException(clientMessage, e, serverConnection);
-        writeException(clientMessage, exception, false, serverConnection);
+        writeException(clientMessage, e, false, serverConnection);
-      final String message =
-          "The input function for the execute function request is null";
-      logger.warn("{} : {}",
-          new Object[] {serverConnection.getName(), message});
+      String message = "The input function for the execute function request is null";
+      logger.warn("{} : {}", serverConnection.getName(), message);
-      Function<?> functionObject = null;
+      Function<?> functionObject;
-        functionObject = FunctionService.getFunction((String) function);
+        functionObject = internalFunctionExecutionService.getFunction((String) function);
-          final String message =
-              String.format("Function named %s is not registered to FunctionService",
-                  function);
+          String message = String
+              .format("Function named %s is not registered to FunctionService for %s", function);
-            String message =
-                "Function attributes at client and server don't match for " +
-                    function;
+            String message = String
+                .format("Function attributes at client and server don't match for %s", function);
-      ChunkedMessage m = serverConnection.getFunctionResponseMessage();
-      m.setTransactionId(clientMessage.getTransactionId());
-      ServerToClientFunctionResultSender resultSender = new ServerToClientFunctionResultSender65(m,
-          MessageType.EXECUTE_FUNCTION_RESULT, serverConnection, functionObject, executeContext);
+      ChunkedMessage chunkedMessage = serverConnection.getFunctionResponseMessage();
+      chunkedMessage.setTransactionId(clientMessage.getTransactionId());
+      ServerToClientFunctionResultSender resultSender =
+          serverToClientFunctionResultSender65Factory.create(chunkedMessage,
+              MessageType.EXECUTE_FUNCTION_RESULT,
+              serverConnection, functionObject, executeContext);
-      FunctionContext context = null;
+      FunctionContext context;
-        context = new FunctionContextImpl(cache, functionObject.getId(),
+        context = functionContextImplFactory.create(cache, functionObject.getId(),
-        context =
-            new FunctionContextImpl(cache, functionObject.getId(), args, resultSender, isReexecute);
+        context = functionContextImplFactory.create(cache, functionObject.getId(), args,
+            resultSender, isReexecute);
+
-        Exception e = cache.getInternalResourceManager().getHeapMonitor()
+        LowMemoryException lowMemoryException = cache.getInternalResourceManager().getHeapMonitor()
-        if (e != null) {
-          sendException(hasResult, clientMessage, e.getMessage(), serverConnection, e);
+        if (lowMemoryException != null) {
+          sendException(hasResult, clientMessage, lowMemoryException.getMessage(), serverConnection,
+              lowMemoryException);
-        /*
-         * if cache is null, then either cache has not yet been created on this node or it is a
-         * shutdown scenario.
-         */
-        DistributionManager dm = null;
-        if (cache != null) {
-          dm = cache.getDistributionManager();
-        }
+
+        // cache is never null or the above invocations would have thrown NPE
+        DistributionManager dm = cache.getDistributionManager();
-          executeFunctionaLocally(functionObject, context,
+          executeFunctionLocally(functionObject, context,
-      } catch (FunctionException functionException) {
+      } catch (FunctionException e) {
-        throw functionException;
-      } catch (Exception exception) {
+        throw e;
+      } catch (Exception e) {
-        throw new FunctionException(exception);
+        throw new FunctionException(e);
-    } catch (IOException ioException) {
-      logger.warn(String.format("Exception on server while executing function: %s",
-          function),
-          ioException);
-      String message =
-          "Server could not send the reply";
-      sendException(hasResult, clientMessage, message, serverConnection, ioException);
-    } catch (InternalFunctionInvocationTargetException internalfunctionException) {
-      // Fix for #44709: User should not be aware of
-      // InternalFunctionInvocationTargetException. No instance of
-      // InternalFunctionInvocationTargetException is giving useful
-      // information to user to take any corrective action hence logging
-      // this at fine level logging
-      // 1> When bucket is moved
-      // 2> Incase of HA FucntionInvocationTargetException thrown. Since
-      // it is HA, fucntion will be reexecuted on right node
-      // 3> Multiple target nodes found for single hop operation
-      // 4> in case of HA member departed
-      if (logger.isDebugEnabled()) {
-        logger.debug(String.format("Exception on server while executing function: %s",
-            new Object[] {function}),
-            internalfunctionException);
-      }
-      final String message = internalfunctionException.getMessage();
-      sendException(hasResult, clientMessage, message, serverConnection, internalfunctionException);
-    } catch (Exception e) {
-      logger.warn(String.format("Exception on server while executing function: %s",
-          function),
-          e);
-      final String message = e.getMessage();
+
+    } catch (IOException e) {
+      logger.warn("Exception on server while executing function: {}}", function, e);
+      String message = "Server could not send the reply";
+
+    } catch (InternalFunctionInvocationTargetException e) {
+      /*
+       * TRAC #44709: InternalFunctionInvocationTargetException should not be logged
+       * Fix for #44709: User should not be aware of InternalFunctionInvocationTargetException. No
+       * instance is giving useful information to user to take any corrective action hence logging
+       * this at fine level logging. May occur when:
+       * 1> When bucket is moved
+       * 2> In case of HA FunctionInvocationTargetException thrown. Since it is HA, function will
+       * be re-executed on right node
+       * 3> Multiple target nodes found for single hop operation
+       * 4> in case of HA member departed
+       */
+      if (logger.isDebugEnabled()) {
+        logger.debug("Exception on server while executing function: {}", function, e);
+      }
+      sendException(hasResult, clientMessage, e.getMessage(), serverConnection, e);
+
+    } catch (Exception e) {
+      logger.warn("Exception on server while executing function: {}", function, e);
+      sendException(hasResult, clientMessage, e.getMessage(), serverConnection, e);
-  private void executeFunctionaLocally(final Function fn, final FunctionContext cx,
+  private void executeFunctionLocally(final Function fn, final FunctionContext cx,
-      if (sender.isOkayToSendResult()
-          && !((ServerToClientFunctionResultSender65) sender).isLastResultReceived()
-          && fn.hasResult()) {
+      if (sender.isOkayToSendResult() && !sender.isLastResultReceived() && fn.hasResult()) {
-            String.format("The function, %s, did not send last result",
-                fn.getId()));
+            String.format("The function, %s, did not send last result", fn.getId()));
-      final TXStateProxy txState = TXManagerImpl.getCurrentTXState();
-      Runnable functionExecution = new Runnable() {
-        public void run() {
-          InternalCache cache = null;
-          try {
-            if (txState != null) {
-              cache = GemFireCacheImpl.getExisting("executing function");
-              cache.getTxManager().masqueradeAs(txState);
-              if (cache.getLogger().warningEnabled() && !ASYNC_TX_WARNING_ISSUED) {
-                ASYNC_TX_WARNING_ISSUED = true;
-                cache.getLogger().warning(
-                    "Function invoked within transactional context, but hasResults() is false; ordering of transactional operations cannot be guaranteed.  This message is only issued once by a server.");
-              }
+      TXStateProxy txState = TXManagerImpl.getCurrentTXState();
+      Runnable functionExecution = () -> {
+        InternalCache cache = null;
+        try {
+          if (txState != null) {
+            cache = GemFireCacheImpl.getExisting("executing function");
+            cache.getTxManager().masqueradeAs(txState);
+            if (cache.getLogger().warningEnabled() && !asyncTxWarningIssued) {
+              asyncTxWarningIssued = true;
+              cache.getLogger().warning(
+                  "Function invoked within transactional context, but hasResults() is false; ordering of transactional operations cannot be guaranteed.  This message is only issued once by a server.");
-            fn.execute(cx);
-          } catch (InternalFunctionInvocationTargetException internalfunctionException) {
-            // Fix for #44709: User should not be aware of
-            // InternalFunctionInvocationTargetException. No instance of
-            // InternalFunctionInvocationTargetException is giving useful
-            // information to user to take any corrective action hence logging
-            // this at fine level logging
-            // 1> Incase of HA FucntionInvocationTargetException thrown. Since
-            // it is HA, function will be reexecuted on right node
-            // 2> in case of HA member departed
-            stats.endFunctionExecutionWithException(fn.hasResult());
-            if (logger.isDebugEnabled()) {
-              logger.debug(String.format("Exception on server while executing function: %s",
-                  new Object[] {fn}),
-                  internalfunctionException);
-            }
-          } catch (FunctionException functionException) {
-            stats.endFunctionExecutionWithException(fn.hasResult());
-            logger.warn(String.format("Exception on server while executing function: %s",
-                fn),
-                functionException);
-          } catch (Exception exception) {
-            stats.endFunctionExecutionWithException(fn.hasResult());
-            logger.warn(String.format("Exception on server while executing function: %s",
-                fn),
-                exception);
-          } finally {
-            if (txState != null && cache != null) {
-              cache.getTxManager().unmasquerade(txState);
-            }
+          }
+          fn.execute(cx);
+        } catch (InternalFunctionInvocationTargetException e) {
+          // TRAC #44709: InternalFunctionInvocationTargetException should not be logged
+          stats.endFunctionExecutionWithException(fn.hasResult());
+          if (logger.isDebugEnabled()) {
+            logger.debug("Exception on server while executing function: {}", fn, e);
+          }
+        } catch (Exception e) {
+          stats.endFunctionExecutionWithException(fn.hasResult());
+          logger.warn("Exception on server while executing function: {}", fn, e);
+        } finally {
+          if (txState != null && cache != null) {
+            cache.getTxManager().unmasquerade(txState);
-        final ClusterDistributionManager newDM = (ClusterDistributionManager) dm;
+        ClusterDistributionManager newDM = (ClusterDistributionManager) dm;
+  interface ServerToClientFunctionResultSender65Factory {
+    ServerToClientFunctionResultSender65 create(ChunkedMessage msg, int messageType,
+        ServerConnection sc, Function function, ExecuteFunctionOperationContext authzContext);
+  }
+
+  interface FunctionContextImplFactory {
+    FunctionContextImpl create(Cache cache, String functionId, Object args,
+        ResultSender resultSender, boolean isPossibleDuplicate);
+  }
+
+  private static class DefaultServerToClientFunctionResultSender65Factory
+      implements ServerToClientFunctionResultSender65Factory {
+    @Override
+    public ServerToClientFunctionResultSender65 create(ChunkedMessage msg, int messageType,
+        ServerConnection sc, Function function, ExecuteFunctionOperationContext authzContext) {
+      return new ServerToClientFunctionResultSender65(msg, messageType, sc, function, authzContext);
+    }
+  }
+
+  private static class DefaultFunctionContextImplFactory implements FunctionContextImplFactory {
+    @Override
+    public FunctionContextImpl create(Cache cache, String functionId, Object args,
+        ResultSender resultSender, boolean isPossibleDuplicat) {
+      return new FunctionContextImpl(cache, functionId, args, resultSender, isPossibleDuplicat);
+    }
+  }

MOV26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 UPD40 INS23 INS23 INS23 INS31 MOV31 INS55 INS55 INS55 INS55 UPD83 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS43 INS59 INS42 INS44 INS44 INS44 INS8 UPD83 INS42 MOV44 MOV44 MOV44 MOV44 MOV44 MOV43 INS8 INS42 INS31 INS42 INS31 INS83 INS83 INS42 INS43 INS31 INS83 INS83 INS42 INS43 INS31 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS17 INS43 INS42 INS43 INS42 INS43 INS42 INS21 INS21 INS21 MOV60 MOV21 INS25 MOV21 MOV43 INS42 INS44 INS44 INS44 INS44 INS44 MOV43 INS42 INS44 INS44 INS44 INS44 INS44 INS42 INS78 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS8 UPD42 MOV42 INS78 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS8 INS32 INS14 INS14 INS42 INS42 INS42 INS7 INS7 INS7 INS12 MOV32 MOV8 INS8 INS43 INS42 INS39 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 MOV43 INS42 MOV43 INS42 INS43 INS42 INS39 INS42 INS42 INS42 INS43 INS42 INS39 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS41 INS42 UPD42 MOV42 INS43 INS42 MOV43 INS42 MOV43 INS42 INS43 INS42 INS39 INS42 INS41 INS42 INS42 INS43 INS43 INS22 INS42 INS22 INS42 INS22 INS42 MOV25 MOV12 MOV44 MOV8 MOV44 MOV60 INS60 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 UPD42 MOV62 MOV8 UPD42 MOV21 UPD42 INS25 MOV21 MOV43 INS59 MOV27 MOV8 INS8 MOV43 INS42 INS42 INS42 INS42 INS42 MOV43 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 MOV21 INS25 UPD42 UPD42 INS32 MOV32 INS8 INS42 INS86 INS60 MOV21 UPD45 MOV45 MOV42 UPD42 MOV27 MOV8 INS8 INS42 INS42 INS42 INS40 INS42 INS42 INS42 UPD43 INS8 MOV43 UPD42 INS43 INS42 UPD45 MOV45 MOV42 UPD42 INS21 UPD42 UPD45 MOV45 INS42 UPD42 INS32 UPD42 MOV8 MOV43 MOV59 MOV60 MOV25 MOV25 INS32 INS32 UPD42 UPD42 UPD42 INS21 INS41 MOV32 INS42 INS42 INS14 INS32 INS42 UPD42 MOV42 INS42 INS42 UPD42 UPD42 UPD42 MOV8 INS42 INS42 INS42 MOV32 MOV32 INS42 INS42 INS42 INS42 INS42 MOV32 INS42 INS42 INS42 INS32 MOV43 INS42 INS42 INS42 INS45 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 UPD42 INS42 INS42 INS42 INS45 INS42 INS42 INS42 UPD42 UPD42 MOV21 UPD45 UPD45 MOV45 MOV42 UPD42 UPD42 UPD45 MOV45 INS42 UPD42 UPD42 DEL9 DEL33 DEL33 DEL34 DEL9 DEL9 DEL42 DEL42 DEL32 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL33 DEL45 DEL42 DEL27 DEL83 DEL8 DEL25 DEL42 DEL40 DEL42 DEL42 DEL42 DEL14 DEL33 DEL42 DEL42 DEL42 DEL14 DEL42 DEL42 DEL42 DEL42 DEL14 DEL33 DEL42 DEL33 DEL27 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL14 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL41 DEL42 DEL42 DEL85 DEL5 DEL42 DEL4 DEL3 DEL32 DEL8 DEL25 DEL83 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL45 DEL42 DEL32 DEL42 DEL32 DEL21 DEL83 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL12 DEL42 DEL11 DEL36 DEL83 DEL42 DEL42 DEL85 DEL5 DEL42 DEL4 DEL3 DEL32 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL45 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL12 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL83 DEL39 DEL42 DEL43 DEL42 DEL1 DEL14 DEL59 DEL60 DEL83 DEL60 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31
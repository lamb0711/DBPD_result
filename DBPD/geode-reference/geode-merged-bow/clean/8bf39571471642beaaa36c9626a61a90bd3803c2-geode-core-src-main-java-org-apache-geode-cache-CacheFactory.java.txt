Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Factory class used to create the singleton {@link Cache cache} and connect to the GemFire singleton {@link DistributedSystem distributed system}. If the application wants to connect to GemFire as a client it should use {@link org.apache.geode.cache.client.ClientCacheFactory} instead.
-<p> Once the factory has been configured using its {@link #set(String, String)} method you produce a {@link Cache} by calling the {@link #create()} method.
+ * Factory class used to create the singleton {@link Cache cache} and connect to the GemFire
+ * singleton {@link DistributedSystem distributed system}. If the application wants to connect to
+ * GemFire as a client it should use {@link org.apache.geode.cache.client.ClientCacheFactory}
+ * instead.
+ * <p>
+ * Once the factory has been configured using its {@link #set(String, String)} method you produce a
+ * {@link Cache} by calling the {@link #create()} method.
- * If an instance of {@link DistributedSystem} already exists when this factory
- * creates a cache, that instance will be used if it is compatible with this factory.
-<p>
-The following examples illustrate bootstrapping the cache using region shortcuts:
-<p>
-Example 1: Create a cache and a replicate region named customers.
-<PRE>
-  Cache c = new CacheFactory().create();
-  Region r = c.createRegionFactory(REPLICATE).create("customers");
-</PRE>
-Example 2: Create a cache and a partition region with redundancy
-<PRE>
-  Cache c = new CacheFactory().create();
-  Region r = c.createRegionFactory(PARTITION_REDUNDANT).create("customers");
-</PRE>
-Example 3: Construct the  cache region declaratively in cache.xml
-<PRE>
+ * If an instance of {@link DistributedSystem} already exists when this factory creates a cache,
+ * that instance will be used if it is compatible with this factory.
+ * <p>
+ * The following examples illustrate bootstrapping the cache using region shortcuts:
+ * <p>
+ * Example 1: Create a cache and a replicate region named customers.
+ * 
+ * <PRE>
+ * Cache c = new CacheFactory().create();
+ * Region r = c.createRegionFactory(REPLICATE).create("customers");
+ * </PRE>
+ * 
+ * Example 2: Create a cache and a partition region with redundancy
+ * 
+ * <PRE>
+ * Cache c = new CacheFactory().create();
+ * Region r = c.createRegionFactory(PARTITION_REDUNDANT).create("customers");
+ * </PRE>
+ * 
+ * Example 3: Construct the cache region declaratively in cache.xml
+ * 
+ * <PRE>
-</PRE>
-Now, create the cache telling it to read your cache.xml file:
-<PRE>
-  Cache c = new CacheFactory()
-    .set("cache-xml-file", "myCache.xml")
-    .create();
-  Region r = c.getRegion("myRegion");
-</PRE>
-
-<p> For a complete list of all region shortcuts see {@link RegionShortcut}. 
-Applications that need to explicitly control the individual region attributes can do this declaratively in XML or using APIs.
+ * </PRE>
+ * 
+ * Now, create the cache telling it to read your cache.xml file:
+ * 
+ * <PRE>
+ * Cache c = new CacheFactory().set("cache-xml-file", "myCache.xml").create();
+ * Region r = c.getRegion("myRegion");
+ * </PRE>
+ * 
+ * <p>
+ * For a complete list of all region shortcuts see {@link RegionShortcut}. Applications that need to
+ * explicitly control the individual region attributes can do this declaratively in XML or using
+ * APIs.
-  
-  private final CacheConfig cacheConfig =  new CacheConfig();
-       
+
+  private final CacheConfig cacheConfig = new CacheConfig();
+
+   * 
+
-   * Create a CacheFactory initialized with the given gemfire properties.
-   * For a list of valid GemFire properties and their meanings
-   * see {@linkplain ConfigurationProperties}.
+   * Create a CacheFactory initialized with the given gemfire properties. For a list of valid
+   * GemFire properties and their meanings see {@linkplain ConfigurationProperties}.
+   * 
-   * Sets a gemfire property that will be used when creating the Cache.
-   * For a list of valid GemFire properties and their meanings
-   * see {@link ConfigurationProperties}.
+   * Sets a gemfire property that will be used when creating the Cache. For a list of valid GemFire
+   * properties and their meanings see {@link ConfigurationProperties}.
+   * 
+
-   * The <code>system</code> can specify a <A
-   * href="../distributed/DistributedSystem.html#cache-xml-file">"cache-xml-file"</a>
-   * property which will cause this creation to also create the
-   * regions, objects, and attributes declared in the file.  The
-   * contents of the file must comply with the
-   * <code>"doc-files/cache8_0.dtd"></code> file.
-   * Note that when parsing the XML file {@link Declarable} classes
-   * are loaded using the current thread's {@linkplain
-   * Thread#getContextClassLoader context class loader}.
+   * The <code>system</code> can specify a
+   * <A href="../distributed/DistributedSystem.html#cache-xml-file">"cache-xml-file"</a> property
+   * which will cause this creation to also create the regions, objects, and attributes declared in
+   * the file. The contents of the file must comply with the <code>"doc-files/cache8_0.dtd"></code>
+   * file. Note that when parsing the XML file {@link Declarable} classes are loaded using the
+   * current thread's {@linkplain Thread#getContextClassLoader context class loader}.
-   * @param system
-   *        a <code>DistributedSystem</code> obtained by calling
+   * @param system a <code>DistributedSystem</code> obtained by calling
-   * @return a <code>Cache</code> that uses the specified
-   *         <code>system</code> for distribution.
+   * @return a <code>Cache</code> that uses the specified <code>system</code> for distribution.
-   * @throws IllegalArgumentException
-   *         If <code>system</code> is not {@link
-   *         DistributedSystem#isConnected connected}.
-   * @throws CacheExistsException
-   *         If an open cache already exists.
-   * @throws CacheXmlException
-   *         If a problem occurs while parsing the declarative caching
-   *         XML file.
-   * @throws TimeoutException
-   *         If a {@link Region#put(Object, Object)} times out while initializing the
+   * @throws IllegalArgumentException If <code>system</code> is not
+   *         {@link DistributedSystem#isConnected connected}.
+   * @throws CacheExistsException If an open cache already exists.
+   * @throws CacheXmlException If a problem occurs while parsing the declarative caching XML file.
+   * @throws TimeoutException If a {@link Region#put(Object, Object)} times out while initializing
+   *         the cache.
+   * @throws CacheWriterException If a <code>CacheWriterException</code> is thrown while
+   *         initializing the cache.
+   * @throws GatewayException If a <code>GatewayException</code> is thrown while initializing the
-   * @throws CacheWriterException
-   *         If a <code>CacheWriterException</code> is thrown while
-   *         initializing the cache.
-   * @throws GatewayException
-   *         If a <code>GatewayException</code> is thrown while
-   *         initializing the cache.
-   * @throws RegionExistsException
-   *         If the declarative caching XML file describes a region
-   *         that already exists (including the root region).
+   * @throws RegionExistsException If the declarative caching XML file describes a region that
+   *         already exists (including the root region).
-  public static synchronized Cache create(DistributedSystem system)
-    throws CacheExistsException, TimeoutException, CacheWriterException,
-           GatewayException,
-           RegionExistsException 
-  {
+  public static synchronized Cache create(DistributedSystem system) throws CacheExistsException,
+      TimeoutException, CacheWriterException, GatewayException, RegionExistsException {
-  
-  private static synchronized Cache create(DistributedSystem system, boolean existingOk, CacheConfig cacheConfig)
-    throws CacheExistsException, TimeoutException, CacheWriterException,
-           GatewayException,
-           RegionExistsException 
-  {
+
+  private static synchronized Cache create(DistributedSystem system, boolean existingOk,
+      CacheConfig cacheConfig) throws CacheExistsException, TimeoutException, CacheWriterException,
+      GatewayException, RegionExistsException {
-   * Creates a new cache that uses the configured distributed system.
-   * If a connected distributed system already exists it will be used
-   * if it is compatible with the properties on this factory.
-   * Otherwise a a distributed system will be created with the configured properties.
-   * If a cache already exists it will be returned.
-   * <p>If the cache does need to be created it will also be initialized from
-   * cache.xml if it exists.
+   * Creates a new cache that uses the configured distributed system. If a connected distributed
+   * system already exists it will be used if it is compatible with the properties on this factory.
+   * Otherwise a a distributed system will be created with the configured properties. If a cache
+   * already exists it will be returned.
+   * <p>
+   * If the cache does need to be created it will also be initialized from cache.xml if it exists.
-   * @throws CacheXmlException
-   *         If a problem occurs while parsing the declarative caching
-   *         XML file.
-   * @throws TimeoutException
-   *         If a {@link Region#put(Object, Object)} times out while initializing the
+   * @throws CacheXmlException If a problem occurs while parsing the declarative caching XML file.
+   * @throws TimeoutException If a {@link Region#put(Object, Object)} times out while initializing
+   *         the cache.
+   * @throws CacheWriterException If a <code>CacheWriterException</code> is thrown while
+   *         initializing the cache.
+   * @throws GatewayException If a <code>GatewayException</code> is thrown while initializing the
-   * @throws CacheWriterException
-   *         If a <code>CacheWriterException</code> is thrown while
-   *         initializing the cache.
-   * @throws GatewayException
-   *         If a <code>GatewayException</code> is thrown while
-   *         initializing the cache.
-   * @throws RegionExistsException
-   *         If the declarative caching XML file describes a region
-   *         that already exists (including the root region).
-   * @throws IllegalStateException if cache already exists and is not compatible
-   *         with the new configuration.
+   * @throws RegionExistsException If the declarative caching XML file describes a region that
+   *         already exists (including the root region).
+   * @throws IllegalStateException if cache already exists and is not compatible with the new
+   *         configuration.
-   * @throws AuthenticationRequiredException if the distributed system is in secure mode 
-   *         and this new member is not configured with security credentials.
+   * @throws AuthenticationRequiredException if the distributed system is in secure mode and this
+   *         new member is not configured with security credentials.
-    throws TimeoutException, CacheWriterException,
-           GatewayException,
-           RegionExistsException 
-  {
-    synchronized(CacheFactory.class) {
+      throws TimeoutException, CacheWriterException, GatewayException, RegionExistsException {
+    synchronized (CacheFactory.class) {
-   * Gets the instance of {@link Cache} produced by an
-   * earlier call to {@link #create()}.
+   * Gets the instance of {@link Cache} produced by an earlier call to {@link #create()}.
+   * 
-   * @throws CacheClosedException if a cache has not been created
-   * or the created one is {@link Cache#isClosed closed}
+   * @throws CacheClosedException if a cache has not been created or the created one is
+   *         {@link Cache#isClosed closed}
-   * Gets the instance of {@link Cache} produced by an
-   * earlier call to {@link #create()} even if it has been closed.
+   * Gets the instance of {@link Cache} produced by an earlier call to {@link #create()} even if it
+   * has been closed.
+   * 
-    if (initReq == LocalRegion.ANY_INIT
-        || initReq == LocalRegion.BEFORE_INITIAL_IMAGE) { // fix bug 33471
+    if (initReq == LocalRegion.ANY_INIT || initReq == LocalRegion.BEFORE_INITIAL_IMAGE) { // fix bug
+                                                                                          // 33471
+
-      throw new CacheClosedException(LocalizedStrings.CacheFactory_A_CACHE_HAS_NOT_YET_BEEN_CREATED.toLocalizedString());
+      throw new CacheClosedException(
+          LocalizedStrings.CacheFactory_A_CACHE_HAS_NOT_YET_BEEN_CREATED.toLocalizedString());
-        throw instance.getCacheClosedException(LocalizedStrings.CacheFactory_THE_CACHE_HAS_BEEN_CLOSED.toLocalizedString(), null);
+        throw instance.getCacheClosedException(
+            LocalizedStrings.CacheFactory_THE_CACHE_HAS_BEEN_CLOSED.toLocalizedString(), null);
-        throw new CacheClosedException(LocalizedStrings.CacheFactory_A_CACHE_HAS_NOT_YET_BEEN_CREATED_FOR_THE_GIVEN_DISTRIBUTED_SYSTEM.toLocalizedString());
+        throw new CacheClosedException(
+            LocalizedStrings.CacheFactory_A_CACHE_HAS_NOT_YET_BEEN_CREATED_FOR_THE_GIVEN_DISTRIBUTED_SYSTEM
+                .toLocalizedString());
-   * Gets an arbitrary open instance of {@link Cache} produced by an
-   * earlier call to {@link #create()}.
-   * @throws CacheClosedException if a cache has not been created
-   * or the only created one is {@link Cache#isClosed closed}
+   * Gets an arbitrary open instance of {@link Cache} produced by an earlier call to
+   * {@link #create()}.
+   * 
+   * @throws CacheClosedException if a cache has not been created or the only created one is
+   *         {@link Cache#isClosed closed}
-      throw new CacheClosedException(LocalizedStrings.CacheFactory_A_CACHE_HAS_NOT_YET_BEEN_CREATED.toLocalizedString());
+      throw new CacheClosedException(
+          LocalizedStrings.CacheFactory_A_CACHE_HAS_NOT_YET_BEEN_CREATED.toLocalizedString());
-  /** Returns the version of the cache implementation.
+  /**
+   * Returns the version of the cache implementation.
+   * 
-  
-  /** Sets the object preference to PdxInstance type. 
-   * When a cached object that was serialized as a PDX is read
-   * from the cache a {@link PdxInstance} will be returned instead of the actual domain class.
-   * The PdxInstance is an interface that provides run time access to 
-   * the fields of a PDX without deserializing the entire PDX. 
-   * The PdxInstance implementation is a light weight wrapper 
-   * that simply refers to the raw bytes of the PDX that are kept 
-   * in the cache. Using this method applications can choose to 
-   * access PdxInstance instead of Java object.
-   * <p>Note that a PdxInstance is only returned if a serialized PDX is found in the cache.
-   * If the cache contains a deserialized PDX, then a domain class instance is returned instead of a PdxInstance.
-   *  
-   *  @param readSerialized true to prefer PdxInstance
-   *  @return this CacheFactory 
-   *  @since GemFire 6.6
-   *  @see org.apache.geode.pdx.PdxInstance 
+
+  /**
+   * Sets the object preference to PdxInstance type. When a cached object that was serialized as a
+   * PDX is read from the cache a {@link PdxInstance} will be returned instead of the actual domain
+   * class. The PdxInstance is an interface that provides run time access to the fields of a PDX
+   * without deserializing the entire PDX. The PdxInstance implementation is a light weight wrapper
+   * that simply refers to the raw bytes of the PDX that are kept in the cache. Using this method
+   * applications can choose to access PdxInstance instead of Java object.
+   * <p>
+   * Note that a PdxInstance is only returned if a serialized PDX is found in the cache. If the
+   * cache contains a deserialized PDX, then a domain class instance is returned instead of a
+   * PdxInstance.
+   * 
+   * @param readSerialized true to prefer PdxInstance
+   * @return this CacheFactory
+   * @since GemFire 6.6
+   * @see org.apache.geode.pdx.PdxInstance
-  public  CacheFactory setPdxReadSerialized(boolean readSerialized) {
+  public CacheFactory setPdxReadSerialized(boolean readSerialized) {
-  
+
-   * Set the PDX serializer for the cache. If this serializer is set,
-   * it will be consulted to see if it can serialize any domain classes which are 
-   * added to the cache in portable data exchange format. 
+   * Set the PDX serializer for the cache. If this serializer is set, it will be consulted to see if
+   * it can serialize any domain classes which are added to the cache in portable data exchange
+   * format.
+   * 
-  
+
-   * Set the disk store that is used for PDX meta data. When
-   * serializing objects in the PDX format, the type definitions
-   * are persisted to disk. This setting controls which disk store
-   * is used for that persistence.
+   * Set the disk store that is used for PDX meta data. When serializing objects in the PDX format,
+   * the type definitions are persisted to disk. This setting controls which disk store is used for
+   * that persistence.
-   * @param diskStoreName the name of the disk store to use
-   * for the PDX metadata.
+   * 
+   * @param diskStoreName the name of the disk store to use for the PDX metadata.
-   * Control whether the type metadata for PDX objects is persisted to disk. The
-   * default for this setting is false. If you are using persistent regions with
-   * PDX then you must set this to true. If you are using a
-   * <code>GatewaySender</code> or <code>AsyncEventQueue</code> with PDX then
-   * you should set this to true.
+   * Control whether the type metadata for PDX objects is persisted to disk. The default for this
+   * setting is false. If you are using persistent regions with PDX then you must set this to true.
+   * If you are using a <code>GatewaySender</code> or <code>AsyncEventQueue</code> with PDX then you
+   * should set this to true.
-   * @param isPersistent
-   *          true if the metadata should be persistent
+   * @param isPersistent true if the metadata should be persistent
+
-   * Control whether pdx ignores fields that were unread during deserialization.
-   * The default is to preserve unread fields be including their data during serialization.
-   * But if you configure the cache to ignore unread fields then their data will be lost
-   * during serialization.
-   * <P>You should only set this attribute to <code>true</code> if you know this member
-   * will only be reading cache data. In this use case you do not need to pay the cost
-   * of preserving the unread fields since you will never be reserializing pdx data. 
+   * Control whether pdx ignores fields that were unread during deserialization. The default is to
+   * preserve unread fields be including their data during serialization. But if you configure the
+   * cache to ignore unread fields then their data will be lost during serialization.
+   * <P>
+   * You should only set this attribute to <code>true</code> if you know this member will only be
+   * reading cache data. In this use case you do not need to pay the cost of preserving the unread
+   * fields since you will never be reserializing pdx data.
-   * @param ignore <code>true</code> if fields not read during pdx deserialization should be ignored;
-   * <code>false</code>, the default, if they should be preserved.
+   * @param ignore <code>true</code> if fields not read during pdx deserialization should be
+   *        ignored; <code>false</code>, the default, if they should be preserved.
-} 
+}

UPD66 INS66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 MOV66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
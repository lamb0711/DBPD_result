Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  private final ConcurrentMap<Integer, List<BucketServerLocation66>> bucketServerLocationsMap 
-  = new ConcurrentHashMap<Integer, List<BucketServerLocation66>>();
+  private final ConcurrentMap<Integer, List<BucketServerLocation66>> bucketServerLocationsMap =
+      new ConcurrentHashMap<Integer, List<BucketServerLocation66>>();
-  
+
-  
+
-  
+
-        this.partitionResolver = (PartitionResolver)
-            ClassPathLoader.getLatest().forName(partitionResolverName).newInstance();
+        this.partitionResolver = (PartitionResolver) ClassPathLoader.getLatest()
+            .forName(partitionResolverName).newInstance();
-    }
-    catch (Exception e) {
-      if(logger.isErrorEnabled()) {
+    } catch (Exception e) {
+      if (logger.isErrorEnabled()) {
-      
-      throw new InternalGemFireException(LocalizedStrings.ClientPartitionAdvisor_CANNOT_CREATE_AN_INSTANCE_OF_PARTITION_RESOLVER_0.toLocalizedString(partitionResolverName));
+
+      throw new InternalGemFireException(
+          LocalizedStrings.ClientPartitionAdvisor_CANNOT_CREATE_AN_INSTANCE_OF_PARTITION_RESOLVER_0
+              .toLocalizedString(partitionResolverName));
-        totalFPABuckets+=fpa.getNumBuckets();
+        totalFPABuckets += fpa.getNumBuckets();
-        attrList.add(((FixedPartitionAttributesImpl)fpa).getStartingBucketID());
+        attrList.add(((FixedPartitionAttributesImpl) fpa).getStartingBucketID());
-      if(totalFPABuckets == this.totalNumBuckets) {
+      if (totalFPABuckets == this.totalNumBuckets) {
-      List<BucketServerLocation66> locations = this.bucketServerLocationsMap
-          .get(bucketId);
-      List<BucketServerLocation66> locationsCopy = new ArrayList<BucketServerLocation66>(
-          locations);
+      List<BucketServerLocation66> locations = this.bucketServerLocationsMap.get(bucketId);
+      List<BucketServerLocation66> locationsCopy = new ArrayList<BucketServerLocation66>(locations);
-      List<BucketServerLocation66> locations = this.bucketServerLocationsMap
-          .get(bucketList.get(random.nextInt(size)));
+      List<BucketServerLocation66> locations =
+          this.bucketServerLocationsMap.get(bucketList.get(random.nextInt(size)));
-        List<BucketServerLocation66> serverList = new ArrayList<BucketServerLocation66>(
-            locations);
+        List<BucketServerLocation66> serverList = new ArrayList<BucketServerLocation66>(locations);
-  
+
-      List<BucketServerLocation66> locationsCopy = new ArrayList<BucketServerLocation66>(
-          this.bucketServerLocationsMap.get(bucketId));
+      List<BucketServerLocation66> locationsCopy =
+          new ArrayList<BucketServerLocation66>(this.bucketServerLocationsMap.get(bucketId));
-  
+
-      List<BucketServerLocation66> locations = this.bucketServerLocationsMap
-          .get(bucketId);
-      List<BucketServerLocation66> locationsCopy = new ArrayList<BucketServerLocation66>(
-          locations);
+      List<BucketServerLocation66> locations = this.bucketServerLocationsMap.get(bucketId);
+      List<BucketServerLocation66> locationsCopy = new ArrayList<BucketServerLocation66>(locations);
-    List<BucketServerLocation66> bucketServerLocations, ClientMetadataService cms) {
+      List<BucketServerLocation66> bucketServerLocations, ClientMetadataService cms) {
-    
+
-    
+
-    Iterator<Map.Entry<Integer, List<BucketServerLocation66>>> iter = this.bucketServerLocationsMap
-        .entrySet().iterator();
+    Iterator<Map.Entry<Integer, List<BucketServerLocation66>>> iter =
+        this.bucketServerLocationsMap.entrySet().iterator();
-      List<BucketServerLocation66> newLocations = new ArrayList<BucketServerLocation66>(
-          oldLocations);
+      List<BucketServerLocation66> newLocations =
+          new ArrayList<BucketServerLocation66>(oldLocations);
-          && !this.bucketServerLocationsMap.replace(key, oldLocations,
-              newLocations)) {
+          && !this.bucketServerLocationsMap.replace(key, oldLocations, newLocations)) {
-  
+
-   
+
-  public int assignFixedBucketId(Region region, String partition,
-      Object resolveKey) {
+  public int assignFixedBucketId(Region region, String partition, Object resolveKey) {
-    }
-    else {
+    } else {
-  
-  public Map<String, List<Integer>> getFixedPAMap(){
+
+  public Map<String, List<Integer>> getFixedPAMap() {
-  
+


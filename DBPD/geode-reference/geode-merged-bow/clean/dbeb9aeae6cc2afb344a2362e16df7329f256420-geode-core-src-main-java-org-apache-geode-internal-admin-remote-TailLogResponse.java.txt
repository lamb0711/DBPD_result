Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-   
-   
+
+
-//import org.apache.geode.distributed.DistributedSystem;
-//import java.util.*;
+// import org.apache.geode.distributed.DistributedSystem;
+// import java.util.*;
-  
+
-  public static TailLogResponse create(DistributionManager dm, InternalDistributedMember recipient){
+  public static TailLogResponse create(DistributionManager dm,
+      InternalDistributedMember recipient) {
-          m.tail = LocalizedStrings.TailLogResponse_NO_LOG_FILE_WAS_SPECIFIED_IN_THE_CONFIGURATION_MESSAGES_WILL_BE_DIRECTED_TO_STDOUT.toLocalizedString(); 
+          m.tail =
+              LocalizedStrings.TailLogResponse_NO_LOG_FILE_WAS_SPECIFIED_IN_THE_CONFIGURATION_MESSAGES_WILL_BE_DIRECTED_TO_STDOUT
+                  .toLocalizedString();
-        //Assert.assertTrue(false, "TailLogRequest/Response processed in application vm with shared logging.");
-        m.childTail = tailSystemLog((File)null);
+        // Assert.assertTrue(false, "TailLogRequest/Response processed in application vm with shared
+        // logging.");
+        m.childTail = tailSystemLog((File) null);
-          m.tail = LocalizedStrings.TailLogResponse_NO_LOG_FILE_WAS_SPECIFIED_IN_THE_CONFIGURATION_MESSAGES_WILL_BE_DIRECTED_TO_STDOUT.toLocalizedString(); 
+          m.tail =
+              LocalizedStrings.TailLogResponse_NO_LOG_FILE_WAS_SPECIFIED_IN_THE_CONFIGURATION_MESSAGES_WILL_BE_DIRECTED_TO_STDOUT
+                  .toLocalizedString();
-    } catch (IOException e){
-      logger.warn(LocalizedMessage.create(LocalizedStrings.TailLogResponse_ERROR_OCCURRED_WHILE_READING_SYSTEM_LOG__0, e));
+    } catch (IOException e) {
+      logger.warn(LocalizedMessage
+          .create(LocalizedStrings.TailLogResponse_ERROR_OCCURRED_WHILE_READING_SYSTEM_LOG__0, e));
-  public void fromData(DataInput in) throws IOException,
-      ClassNotFoundException {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-  public String getTail(){
+  public String getTail() {
-  public String toString(){
+  public String toString() {
-    int maxBuffer = 65500; //DataOutput.writeUTF will only accept 65535 bytes
+    int maxBuffer = 65500; // DataOutput.writeUTF will only accept 65535 bytes
-    byte[] buffer = (fileLength > maxBuffer) ? new byte[maxBuffer] : new byte[(int)fileLength];
+    byte[] buffer = (fileLength > maxBuffer) ? new byte[maxBuffer] : new byte[(int) fileLength];
-    
-    String messageString = new String( buffer );
+
+    String messageString = new String(buffer);
-    for (int i=text.length-1,j=0; i>=0; i--){
+    for (int i = text.length - 1, j = 0; i >= 0; i--) {
-      if (j == numLines){
+      if (j == numLines) {
-    }    
+    }
-//  private static String readSystemLog(File logFile) throws IOException {
-//    if (logFile == null || logFile.equals(new File(""))) {
-//      return null;
-//    }
-//    long fileLength = logFile.length();
-//    byte[] buffer = new byte[(int)fileLength];
-//    BufferedInputStream in = new BufferedInputStream(new FileInputStream(logFile));
-//    in.read(buffer, 0, buffer.length);
-//    return new String(buffer).trim();
-//  }
+  // private static String readSystemLog(File logFile) throws IOException {
+  // if (logFile == null || logFile.equals(new File(""))) {
+  // return null;
+  // }
+  // long fileLength = logFile.length();
+  // byte[] buffer = new byte[(int)fileLength];
+  // BufferedInputStream in = new BufferedInputStream(new FileInputStream(logFile));
+  // in.read(buffer, 0, buffer.length);
+  // return new String(buffer).trim();
+  // }
-//  private static String readSystemLog(DistributionConfig sc) throws IOException {
-//    File logFile = sc.getLogFile();
-//    if (logFile == null || logFile.equals(new File(""))) {
-//      return null;
-//    }
-//    if (!logFile.isAbsolute()) {
-//      logFile = new File(logFile.getAbsolutePath());
-//    }    
-//    return readSystemLog(logFile);
-//  }  
-  
+  // private static String readSystemLog(DistributionConfig sc) throws IOException {
+  // File logFile = sc.getLogFile();
+  // if (logFile == null || logFile.equals(new File(""))) {
+  // return null;
+  // }
+  // if (!logFile.isAbsolute()) {
+  // logFile = new File(logFile.getAbsolutePath());
+  // }
+  // return readSystemLog(logFile);
+  // }
+
-    }    
+    }


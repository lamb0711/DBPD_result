Initial import of geode-1.0.0.0-SNAPSHOT-2.
All the new sub-project directories (like jvsd) were not imported.
A diff was done to confirm that this commit is exactly the same as
the open directory the snapshot was made from.

+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.nio.BufferUnderflowException;
+import java.nio.ByteOrder;
+
+import com.gemstone.gemfire.internal.ByteBufferWriter;
+import com.gemstone.gemfire.internal.HeapDataOutputStream;
+import com.gemstone.gemfire.internal.offheap.UnsafeMemoryChunk;
+import com.gemstone.gemfire.internal.offheap.SimpleMemoryAllocatorImpl.Chunk;
-  private ByteBuffer buffer;
+  /**
+   * This interface is used to wrap either a ByteBuffer or an offheap Chunk
+   * as the source of bytes for a ByteBufferInputStream.
+   * 
+   * @author dschneider
+   *
+   */
+  public static interface ByteSource {
+    int position();
+    int limit();
+    int capacity();
+    int remaining();
+
+    void position(int newPosition);
+    void limit(int endOffset);
+
+    void get(byte[] b);
+    void get(byte[] b, int off, int len);
+    byte get();
+    byte get(int pos);
+    short getShort();
+    short getShort(int pos);
+    char getChar();
+    char getChar(int pos);
+    int getInt();
+    int getInt(int pos);
+    long getLong();
+    long getLong(int pos);
+    float getFloat();
+    float getFloat(int pos);
+    double getDouble();
+    double getDouble(int pos);
+
+    boolean hasArray();
+    byte[] array();
+    int arrayOffset();
+
+    ByteSource duplicate();
+    ByteSource slice(int length);
+    ByteSource slice(int pos, int limit);
+    
+    /**
+     * Returns the ByteBuffer that this ByteSource wraps; null if no ByteBuffer
+     */
+    ByteBuffer getBackingByteBuffer();
+
+    void sendTo(ByteBuffer out);
+    void sendTo(DataOutput out) throws IOException;
+  }
+  
+  public static class ByteSourceFactory {
+    public static ByteSource wrap(byte[] bytes) {
+      return new ByteBufferByteSource(ByteBuffer.wrap(bytes));
+    }
+    public static ByteSource create(ByteBuffer bb) {
+      return new ByteBufferByteSource(bb);
+    }
+    public static ByteSource create(Chunk chunk) {
+      // Since I found a way to create a DirectByteBuffer (using reflection) from a Chunk
+      // we might not even need the ByteSource abstraction any more.
+      // But it is possible that createByteBuffer will not work on a different jdk so keep it for now.
+      ByteBuffer bb = chunk.createDirectByteBuffer();
+      if (bb != null) {
+        return create(bb);
+      } else {
+        return new OffHeapByteSource(chunk);
+      }
+    }
+  }
+  
+  public static class ByteBufferByteSource implements ByteSource {
+    private final ByteBuffer bb;
+    public ByteBufferByteSource(ByteBuffer bb) {
+      this.bb = bb;
+    }
+    /**
+     * Returns the current hash code of this byte source.
+     *
+     * <p> The hash code of a byte source depends only upon its remaining
+     * elements; that is, upon the elements from <tt>position()</tt> up to, and
+     * including, the element at <tt>limit()</tt>&nbsp;-&nbsp;<tt>1</tt>.
+     *
+     * <p> Because byte source hash codes are content-dependent, it is inadvisable
+     * to use byte sources as keys in hash maps or similar data structures unless it
+     * is known that their contents will not change.  </p>
+     *
+     * @return  The current hash code of this byte source
+     */
+    @Override
+    public int hashCode() {
+      int h = 1;
+      int p = position();
+      for (int i = limit() - 1; i >= p; i--) {
+        h = 31 * h + (int)get(i);
+      }
+      return h;
+    }
+    @Override
+    public boolean equals(Object ob) {
+      if (this == ob) {
+        return true;
+      }
+      if (!(ob instanceof ByteSource)) {
+        return false;
+      }
+      ByteSource that = (ByteSource)ob;
+      if (this.remaining() != that.remaining()) {
+        return false;
+      }
+      int p = this.position();
+      for (int i = this.limit() - 1, j = that.limit() - 1; i >= p; i--, j--) {
+        if (this.get(i) != that.get(j)) {
+          return false;
+        }
+      }
+      return true;
+    }
+
+    @Override
+    public ByteSource duplicate() {
+      return ByteSourceFactory.create(this.bb.duplicate());
+    }
+    @Override
+    public byte get() {
+      return this.bb.get();
+    }
+    @Override
+    public void get(byte[] b, int off, int len) {
+      this.bb.get(b, off, len);
+    }
+    @Override
+    public int remaining() {
+      return this.bb.remaining();
+    }
+    @Override
+    public int position() {
+      return this.bb.position();
+    }
+    @Override
+    public byte get(int pos) {
+      return this.bb.get(pos);
+    }
+    @Override
+    public char getChar() {
+      return this.bb.getChar();
+    }
+    @Override
+    public char getChar(int pos) {
+      return this.bb.getChar(pos);
+    }
+    @Override
+    public double getDouble() {
+      return this.bb.getDouble();
+    }
+    @Override
+    public double getDouble(int pos) {
+      return this.bb.getDouble(pos);
+    }
+    @Override
+    public float getFloat() {
+      return this.bb.getFloat();
+    }
+    @Override
+    public float getFloat(int pos) {
+      return this.bb.getFloat(pos);
+    }
+    @Override
+    public void get(byte[] b) {
+      this.bb.get(b);
+    }
+    @Override
+    public int getInt() {
+      return this.bb.getInt();
+    }
+    @Override
+    public int getInt(int pos) {
+      return this.bb.getInt(pos);
+    }
+    @Override
+    public long getLong() {
+      return this.bb.getLong();
+    }
+    @Override
+    public long getLong(int pos) {
+      return this.bb.getLong(pos);
+    }
+    @Override
+    public short getShort() {
+      return this.bb.getShort();
+    }
+    @Override
+    public short getShort(int pos) {
+      return this.bb.getShort(pos);
+    }
+    @Override
+    public int limit() {
+      return this.bb.limit();
+    }
+    @Override
+    public void position(int newPosition) {
+      this.bb.position(newPosition);
+    }
+    @Override
+    public boolean hasArray() {
+      return this.bb.hasArray();
+    }
+    @Override
+    public byte[] array() {
+      return this.bb.array();
+    }
+    @Override
+    public int arrayOffset() {
+      return this.bb.arrayOffset();
+    }
+    @Override
+    public void limit(int endOffset) {
+      this.bb.limit(endOffset);
+    }
+    @Override
+    public ByteSource slice(int length) {
+      if (length < 0) {
+        throw new IllegalArgumentException();
+      }
+      ByteBuffer dup = this.bb.duplicate();
+      dup.limit(dup.position() + length);
+      return ByteSourceFactory.create(dup.slice());
+    }
+    @Override
+    public ByteSource slice(int pos, int limit) {
+      ByteBuffer dup = this.bb.duplicate();
+      dup.limit(limit);
+      dup.position(pos);
+      return ByteSourceFactory.create(dup.slice());
+    }
+    @Override
+    public int capacity() {
+      return this.bb.capacity();
+    }
+    @Override
+    public void sendTo(ByteBuffer out) {
+      out.put(this.bb);
+    }
+    @Override
+    public void sendTo(DataOutput out) throws IOException {
+      int len = remaining();
+      if (len == 0) return;
+      if (out instanceof ByteBufferWriter) {
+        ((ByteBufferWriter) out).write(this.bb);
+        return;
+      }
+      if (this.bb.hasArray()) {
+        byte[] bytes = this.bb.array();
+        int offset = this.bb.arrayOffset() + this.bb.position();
+        out.write(bytes, offset, len);
+        this.bb.position(this.bb.limit());
+      } else {
+        while (len > 0) {
+          out.writeByte(get());
+          len--;
+        }
+      }
+    }
+    @Override
+    public ByteBuffer getBackingByteBuffer() {
+      return this.bb;
+    }
+  }
+  
+  public static class OffHeapByteSource implements ByteSource {
+    private int position;
+    private int limit;
+    private final Chunk chunk;
+
+    public OffHeapByteSource(Chunk c) {
+      this.chunk = c;
+      this.position = 0;
+      this.limit = capacity();
+    }
+    private OffHeapByteSource(OffHeapByteSource other) {
+      this.chunk = other.chunk;
+      this.position = other.position;
+      this.limit = other.limit;
+    }
+    
+    /**
+     * Returns the current hash code of this byte source.
+     *
+     * <p> The hash code of a byte source depends only upon its remaining
+     * elements; that is, upon the elements from <tt>position()</tt> up to, and
+     * including, the element at <tt>limit()</tt>&nbsp;-&nbsp;<tt>1</tt>.
+     *
+     * <p> Because byte source hash codes are content-dependent, it is inadvisable
+     * to use byte sources as keys in hash maps or similar data structures unless it
+     * is known that their contents will not change.  </p>
+     *
+     * @return  The current hash code of this byte source
+     */
+    @Override
+    public int hashCode() {
+      int h = 1;
+      int p = position();
+      for (int i = limit() - 1; i >= p; i--) {
+        h = 31 * h + (int)get(i);
+      }
+      return h;
+    }
+     
+    @Override
+    public boolean equals(Object ob) {
+      if (this == ob) {
+        return true;
+      }
+      if (!(ob instanceof ByteSource)) {
+        return false;
+      }
+      ByteSource that = (ByteSource)ob;
+      if (this.remaining() != that.remaining()) {
+        return false;
+      }
+      int p = this.position();
+      for (int i = this.limit() - 1, j = that.limit() - 1; i >= p; i--, j--) {
+        if (this.get(i) != that.get(j)) {
+          return false;
+        }
+      }
+      return true;
+    }
+    
+    @Override
+    public int remaining() {
+      return this.limit - this.position;
+    }
+
+    @Override
+    public int position() {
+      return this.position;
+    }
+
+    @Override
+    public int limit() {
+      return this.limit;
+    }
+
+    @Override
+    public void position(int newPosition) {
+      if ((newPosition > this.limit) || (newPosition < 0)) {
+        throw new IllegalArgumentException();
+      }
+      this.position = newPosition;
+    }
+    
+    @Override
+    public void limit(int newLimit) {
+      if ((newLimit > capacity()) || (newLimit < 0)) {
+        throw new IllegalArgumentException();
+      }
+      this.limit = newLimit;
+      if (this.position > this.limit) {
+        this.position = this.limit;
+      }
+    }
+    
+    @Override
+    public int capacity() {
+      return this.chunk.getDataSize();
+    }
+
+    private final int nextGetIndex() {
+      int p = this.position;
+      if (p >= this.limit) {
+        throw new BufferUnderflowException();
+      }
+      this.position += 1;
+      return p;
+    }
+
+    private final int nextGetIndex(int nb) {
+      int p = this.position;
+      if (this.limit - p < nb) {
+        throw new BufferUnderflowException();
+      }
+      this.position += nb;
+      return p;
+    }
+
+    /**
+     * Checks the given index against the limit, throwing an {@link
+     * IndexOutOfBoundsException} if it is not smaller than the limit
+     * or is smaller than zero.
+     */
+    private final void checkIndex(int i) {
+      if ((i < 0) || (i >= this.limit)) {
+        throw new IndexOutOfBoundsException();
+      }
+    }
+
+    private final void checkIndex(int i, int nb) {
+      if ((i < 0) || (nb > this.limit - i)) {
+        throw new IndexOutOfBoundsException();
+      }
+    }
+    private static void checkBounds(int off, int len, int size) {
+      if ((off | len | (off + len) | (size - (off + len))) < 0) {
+        throw new IndexOutOfBoundsException();
+      }
+    }
+    
+    @Override
+    public void get(byte[] b) {
+      basicGet(b, 0, b.length);
+    }
+    @Override
+    public void get(byte[] dst, int offset, int length) {
+      checkBounds(offset, length, dst.length);
+      basicGet(dst, offset, length);
+    }
+    private void basicGet(byte[] dst, int offset, int length) {
+      if (length > remaining()) {
+        throw new BufferUnderflowException();
+      }
+      int p = this.position;
+      this.position += length;
+      this.chunk.readBytes(p, dst, offset, length);
+    }
+
+    @Override
+    public byte get() {
+      return this.chunk.readByte(nextGetIndex());
+    }
+    @Override
+    public byte get(int pos) {
+      checkIndex(pos);
+      return this.chunk.readByte(pos);
+    }
+
+    /**
+     * Return true if the hardware supported unaligned reads from memory.
+     */
+    private static boolean determineUnaligned() {
+      try {
+        Class c = Class.forName("java.nio.Bits");
+        Method m = c.getDeclaredMethod("unaligned");
+        m.setAccessible(true);
+        return (boolean) m.invoke(null);
+      } catch (ClassNotFoundException | NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
+        return false;
+        //throw new IllegalStateException("Could not invoke java.nio.Bits.unaligned()", e);
+      }
+    }
+    private static final boolean unaligned = determineUnaligned();
+    
+    @Override
+    public short getShort() {
+      return basicGetShort(this.nextGetIndex(2));
+    }
+    @Override
+    public short getShort(int pos) {
+      this.checkIndex(pos, 2);
+      return basicGetShort(pos);
+    }
+    private short basicGetShort(int pos) {
+      long addr = this.chunk.getAddressForReading(pos, 2);
+      if (unaligned) {
+        short result = UnsafeMemoryChunk.readAbsoluteShort(addr);
+        if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
+          result = Short.reverseBytes(result);
+        }
+        return result;
+      } else {
+        int ch1 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        int ch2 = UnsafeMemoryChunk.readAbsoluteByte(addr);
+        return (short)((ch1 << 8) + (ch2 << 0));
+      }
+    }
+
+    @Override
+    public char getChar() {
+      return basicGetChar(this.nextGetIndex(2));
+    }
+    @Override
+    public char getChar(int pos) {
+      this.checkIndex(pos, 2);
+      return basicGetChar(pos);
+    }
+    private char basicGetChar(int pos) {
+      long addr = this.chunk.getAddressForReading(pos, 2);
+      if (unaligned) {
+        char result = UnsafeMemoryChunk.readAbsoluteChar(addr);
+        if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
+          result = Character.reverseBytes(result);
+        }
+        return result;
+      } else {
+        int ch1 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        int ch2 = UnsafeMemoryChunk.readAbsoluteByte(addr);
+        return (char)((ch1 << 8) + (ch2 << 0));
+      }
+    }
+
+    @Override
+    public int getInt() {
+      return basicGetInt(this.nextGetIndex(4));
+    }
+    @Override
+    public int getInt(int pos) {
+      this.checkIndex(pos, 4);
+      return basicGetInt(pos);
+    }
+    
+    private int basicGetInt(final int pos) {
+      long addr = this.chunk.getAddressForReading(pos, 4);
+      if (unaligned) {
+        int result = UnsafeMemoryChunk.readAbsoluteInt(addr);
+        if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
+          result = Integer.reverseBytes(result);
+        }
+        return result;
+      } else {
+        byte b0 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b1 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b2 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b3 = UnsafeMemoryChunk.readAbsoluteByte(addr);
+        return (b0 << 24) + ((b1 & 255) << 16) + ((b2 & 255) << 8) + ((b3 & 255) << 0);
+      }
+    }
+
+    @Override
+    public long getLong() {
+      return basicGetLong(this.nextGetIndex(8));
+    }
+    @Override
+    public long getLong(int pos) {
+      this.checkIndex(pos, 8);
+      return basicGetLong(pos);
+    }
+    private long basicGetLong(final int pos) {
+      long addr = this.chunk.getAddressForReading(pos, 8);
+      if (unaligned) {
+        long result = UnsafeMemoryChunk.readAbsoluteLong(addr);
+        if (ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN) {
+          result = Long.reverseBytes(result);
+        }
+        return result;
+      } else {
+        byte b0 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b1 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b2 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b3 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b4 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b5 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b6 = UnsafeMemoryChunk.readAbsoluteByte(addr++);
+        byte b7 = UnsafeMemoryChunk.readAbsoluteByte(addr);
+        return (((long)b0 << 56) +
+            ((long)(b1 & 255) << 48) +
+            ((long)(b2 & 255) << 40) +
+            ((long)(b3 & 255) << 32) +
+            ((long)(b4 & 255) << 24) +
+            ((b5 & 255) << 16) +
+            ((b6 & 255) <<  8) +
+            ((b7 & 255) <<  0));
+      }
+    }
+
+    @Override
+    public float getFloat() {
+      return basicGetFloat(this.nextGetIndex(4));
+    }
+    @Override
+    public float getFloat(int pos) {
+      this.checkIndex(pos, 4);
+      return basicGetFloat(pos);
+   }
+    private float basicGetFloat(int pos) {
+      return Float.intBitsToFloat(basicGetInt(pos));
+    }
+
+    @Override
+    public double getDouble() {
+      return basicGetDouble(this.nextGetIndex(8));
+    }
+    @Override
+    public double getDouble(int pos) {
+      this.checkIndex(pos, 8);
+      return basicGetDouble(pos);
+    }
+    private double basicGetDouble(int pos) {
+      return Double.longBitsToDouble(basicGetLong(pos));
+    }
+
+    @Override
+    public boolean hasArray() {
+      return false;
+    }
+
+    @Override
+    public byte[] array() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int arrayOffset() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ByteSource duplicate() {
+      return new OffHeapByteSource(this);
+    }
+
+    @Override
+    public ByteSource slice(int length) {
+      if (length < 0) {
+        throw new IllegalArgumentException();
+      }
+      return slice(this.position, this.position + length);
+    }
+
+    @Override
+    public ByteSource slice(int pos, int limit) {
+      if ((limit > capacity()) || (limit < 0)) {
+        throw new IllegalArgumentException();
+      }
+      if ((pos > limit) || (pos < 0)) {
+        throw new IllegalArgumentException();
+      }
+      return new OffHeapByteSource(this.chunk.slice(pos, limit));
+    }
+
+    @Override
+    public void sendTo(ByteBuffer out) {
+      int len = remaining();
+      while (len > 0) {
+        out.put(get());
+        len--;
+      }
+      // We will not even create an instance of this class if createByteBuffer works on this platform.
+//      if (len > 0) {
+//        ByteBuffer bb = this.chunk.createByteBuffer();
+//        bb.position(position());
+//        bb.limit(limit());
+//        out.put(bb);
+//        position(limit());
+//      }
+    }
+    
+    @Override
+    public void sendTo(DataOutput out) throws IOException {
+      int len = remaining();
+      while (len > 0) {
+        out.writeByte(get());
+        len--;
+      }
+    }
+    @Override
+    public ByteBuffer getBackingByteBuffer() {
+      return null;
+    }
+  }
+  
+  private ByteSource buffer;
-  public final void setBuffer(ByteBuffer buffer) {
+  public ByteBufferInputStream(Chunk blob) {
+    this.buffer = ByteSourceFactory.create(blob);
+  }
+
+  public final void setBuffer(ByteSource buffer) {
-
+  
+  public final void setBuffer(ByteBuffer bb) {
+    if (bb == null) {
+      throw new NullPointerException();
+    }
+    setBuffer(ByteSourceFactory.create(bb));
+  }
+  
-  @Override
-  public boolean markSupported() {
-    return true;
-  }
-
-  @Override
-  public void mark(int limit) {
-    this.buffer.mark();
-  }
-
-  @Override
-  public void reset() {
-    this.buffer.reset();
-  }
+  // GemFire does not use mark or reset so I changed this class
+  // to just inherit from InputStream which does not support mark/reset.
+  // That way we do not need to add support for them to the new ByteSource class.
+  
+//  @Override
+//  public boolean markSupported() {
+//    return true;
+//  }
+//
+//  @Override
+//  public void mark(int limit) {
+//    this.buffer.mark();
+//  }
+//
+//  @Override
+//  public void reset() {
+//    this.buffer.reset();
+//  }
-    byte[] bytes;
-    int offset;
-    int len = size();
-    if (this.buffer.hasArray()) {
-      bytes = this.buffer.array();
-      offset = this.buffer.arrayOffset();
-    } else {
-      this.buffer.position(0);
-      bytes = new byte[len];
-      offset = 0;
-      this.buffer.get(bytes);
-    }
-    out.write(bytes, offset, len);
-  }
+    this.buffer.position(0);
+    this.buffer.sendTo(out);
+ }
-    out.put(this.buffer);
+    this.buffer.sendTo(out);
-  public ByteBuffer slice() {
-    return this.buffer.slice();
+  public ByteSource slice(int length) {
+    return this.buffer.slice(length);
-  public ByteBuffer slice(int startOffset, int endOffset) {
-    // We make a duplicate so we will have our own position, limit, and mark
-    ByteBuffer bb = this.buffer.duplicate();
-    bb.position(startOffset);
-    bb.limit(endOffset);
-    return bb.slice();
+  public ByteSource slice(int startOffset, int endOffset) {
+    return this.buffer.slice(startOffset, endOffset);
-      this.buffer = ByteBuffer.wrap(bytes, position, limit-position);
+      setBuffer(ByteBuffer.wrap(bytes, position, limit-position));
-  public ByteBuffer getBuffer() {
+  public ByteSource getBuffer() {
-  
-  

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS55 INS55 INS55 INS55 INS23 INS31 INS31 INS31 INS31 INS31 INS29 INS83 INS83 INS42 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS42 INS31 INS31 INS31 INS83 INS83 INS42 INS43 MOV23 INS31 INS31 MOV31 INS31 INS31 MOV31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 MOV31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS42 INS43 INS23 INS23 INS23 INS31 INS31 INS31 MOV31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS43 MOV59 INS83 INS42 INS44 INS8 INS44 INS83 INS83 INS39 INS42 INS44 INS8 INS44 INS43 INS83 INS39 INS42 MOV44 MOV8 INS83 INS43 INS42 INS44 INS8 INS83 INS43 INS42 MOV44 MOV44 INS8 INS43 INS65 INS65 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS44 INS39 INS42 INS44 INS39 INS42 INS44 INS39 INS42 INS44 INS44 INS44 INS39 INS42 INS39 INS42 INS44 INS39 INS42 INS39 INS42 INS44 INS39 INS42 INS39 INS42 INS44 INS39 INS42 INS39 INS42 INS44 INS39 INS42 INS39 INS42 INS44 INS39 INS42 INS39 INS42 INS44 INS39 INS42 INS39 INS42 INS44 INS39 INS42 INS5 INS42 INS39 INS42 INS43 INS42 INS43 INS42 INS44 INS43 INS42 INS44 INS44 INS29 MOV43 INS42 INS39 INS42 INS44 INS39 INS42 INS44 INS43 INS83 INS83 INS43 INS42 INS44 INS8 INS83 INS83 INS43 INS42 MOV44 INS8 INS83 INS83 INS43 INS42 INS44 INS8 INS42 INS83 INS43 INS59 INS83 INS42 INS44 INS8 INS29 INS78 INS83 INS39 INS42 INS8 MOV78 UPD42 INS44 INS8 MOV78 INS83 INS43 INS42 INS8 MOV78 INS83 INS39 INS42 INS8 INS78 UPD42 INS44 INS44 INS44 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 UPD42 INS44 INS78 MOV83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 MOV39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS5 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS43 UPD42 MOV42 INS44 INS8 INS78 INS83 INS43 INS42 INS44 MOV44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 MOV44 MOV43 INS8 INS78 INS83 MOV43 INS42 INS8 INS42 INS83 INS39 INS59 INS83 INS39 INS59 INS83 INS83 INS43 INS59 INS83 INS42 INS44 INS8 INS83 INS42 INS44 INS8 INS29 INS78 INS83 INS39 INS42 INS8 INS78 INS39 INS42 INS44 INS8 INS78 MOV83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS83 INS39 INS42 INS8 INS83 INS83 INS83 INS39 INS59 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS5 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS43 INS42 INS8 INS78 INS83 INS43 INS42 INS44 INS8 INS78 INS83 INS43 INS42 INS44 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS43 INS8 INS78 INS83 MOV43 INS42 INS8 INS42 INS43 INS42 INS21 INS43 INS42 INS43 INS42 INS25 INS21 INS43 INS42 INS42 MOV21 INS21 INS42 INS39 INS42 INS41 INS42 INS41 INS42 INS66 INS66 INS66 INS39 INS42 INS39 INS42 INS5 INS42 INS5 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS85 INS42 INS42 INS39 INS42 INS42 INS39 INS42 INS39 INS42 INS65 INS43 INS42 INS43 INS42 INS42 INS42 INS5 INS42 INS41 INS42 UPD42 INS41 INS42 INS43 INS42 INS60 INS25 INS42 INS42 INS43 INS42 INS21 INS65 INS65 INS42 INS60 INS60 INS24 INS41 INS43 INS42 INS25 INS25 INS60 INS25 INS60 INS24 INS41 INS42 INS41 INS41 INS42 MOV5 INS42 INS39 INS42 INS39 INS42 INS42 INS41 INS42 INS41 INS42 INS39 INS42 INS41 INS42 INS41 INS42 INS39 INS42 INS41 INS42 INS41 INS42 INS39 INS42 INS41 INS42 INS41 INS42 INS39 INS42 INS41 INS42 MOV5 INS42 INS42 INS41 INS42 INS39 INS42 INS41 INS42 INS41 INS42 INS39 INS42 INS41 INS42 INS41 INS42 INS39 INS42 INS41 INS42 INS41 INS42 INS39 INS42 INS21 INS42 INS41 INS42 INS39 INS85 INS41 INS42 INS41 INS42 INS39 INS42 INS21 INS42 INS42 INS39 INS42 INS25 MOV60 INS21 INS41 INS42 INS42 INS39 INS42 INS60 INS21 INS21 INS41 INS42 INS41 INS42 INS43 INS42 INS21 INS42 MOV60 INS25 INS25 INS25 INS42 INS41 INS42 INS42 INS42 INS42 INS43 INS42 MOV21 MOV21 MOV21 INS43 INS42 INS21 INS21 INS21 INS65 INS65 INS42 INS60 INS60 INS24 INS41 INS42 INS43 INS42 INS25 INS25 INS60 INS25 INS60 INS24 INS41 INS42 INS41 INS42 INS41 INS42 INS41 INS42 INS39 INS42 INS25 INS21 INS42 INS39 INS42 INS25 INS21 INS25 INS42 INS41 INS60 INS25 INS21 INS41 INS39 INS42 INS60 INS25 INS21 INS41 INS65 INS39 INS42 INS25 INS39 INS42 INS39 INS42 INS25 INS39 INS42 INS39 INS42 INS39 INS42 INS25 INS42 INS5 INS42 INS21 INS42 INS5 INS42 INS39 INS42 INS39 INS42 INS21 INS21 INS5 INS42 INS39 INS42 INS39 INS42 INS25 INS60 INS21 INS21 INS42 INS41 INS42 INS39 INS42 INS21 INS41 INS65 INS54 INS42 INS32 INS42 INS41 INS42 INS39 INS42 INS21 INS41 INS39 INS42 MOV60 INS25 INS42 INS41 INS42 INS39 INS42 INS21 INS41 INS39 INS42 INS60 INS25 INS42 INS41 INS42 INS39 INS42 INS21 INS41 INS83 INS39 INS42 INS60 INS25 INS42 INS41 INS42 INS39 INS42 INS21 INS41 INS83 INS39 INS42 INS60 INS25 INS42 INS41 INS42 INS39 INS42 INS21 INS41 INS39 INS42 INS41 INS42 INS41 INS42 INS39 INS42 INS21 INS41 INS39 INS42 INS41 INS42 INS41 INS42 INS39 INS85 INS53 INS42 INS53 INS42 INS42 INS41 INS42 INS42 INS39 INS42 INS25 INS41 INS42 INS42 INS39 INS42 INS39 INS42 INS25 INS25 MOV41 INS42 INS43 INS42 INS60 INS61 INS42 INS43 INS42 INS42 INS60 INS61 INS42 INS41 INS42 INS7 INS42 INS42 INS27 INS8 INS32 INS42 MOV32 MOV32 MOV32 INS39 INS85 INS39 INS85 INS66 INS42 INS42 INS39 INS85 INS14 INS14 INS42 INS43 INS59 INS27 INS8 INS8 INS42 INS7 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS39 INS59 INS39 INS59 INS58 INS27 INS37 INS8 INS42 INS42 INS27 MOV8 INS38 INS8 INS43 INS59 INS27 INS8 INS39 INS59 INS58 INS27 INS37 INS37 INS8 INS9 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS27 INS8 MOV43 INS32 INS32 MOV43 MOV59 INS32 INS32 INS32 INS32 INS42 INS32 INS27 INS41 INS62 INS8 MOV32 MOV8 INS8 INS22 INS42 INS7 INS42 INS7 INS7 INS7 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS39 INS59 INS39 INS59 INS58 INS27 INS37 INS8 INS42 INS42 INS27 INS8 INS38 INS8 INS43 INS59 INS27 INS8 INS39 INS59 INS58 INS27 INS37 INS37 INS8 INS9 INS27 INS22 INS22 INS27 INS8 INS7 INS27 INS8 INS7 INS27 INS8 INS32 INS39 INS59 INS27 INS8 INS7 INS42 INS39 INS59 INS27 INS8 INS7 INS42 INS66 INS65 INS66 INS66 INS27 INS8 INS27 INS8 INS27 INS8 INS39 INS85 INS32 INS39 INS85 INS32 INS32 INS39 INS85 INS27 INS8 INS39 INS59 INS7 INS32 INS32 INS32 INS32 INS66 INS8 INS12 INS42 INS32 INS32 INS32 INS39 INS42 INS8 INS8 INS32 INS32 INS32 INS39 INS59 INS42 INS8 INS8 INS32 INS32 INS32 INS39 INS59 INS42 INS8 INS8 INS32 INS32 INS32 INS39 INS59 INS42 INS8 INS8 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS32 INS9 INS14 INS14 INS14 INS27 INS8 INS32 INS27 INS8 INS27 INS8 INS14 INS42 INS39 INS59 INS27 INS8 INS42 INS39 INS59 INS27 INS8 INS33 MOV22 INS32 INS42 INS33 INS53 INS42 INS32 INS42 INS42 UPD42 INS42 UPD42 UPD42 INS42 INS42 UPD42 INS43 INS32 INS43 INS42 INS42 INS42 INS32 INS42 INS33 INS41 INS41 INS22 INS42 INS42 INS34 INS42 INS32 INS39 INS59 INS42 INS42 INS42 INS21 INS52 INS42 INS36 INS41 INS42 INS42 INS11 INS32 INS32 INS41 INS42 INS32 INS39 INS59 INS59 INS42 INS42 INS42 INS42 INS25 INS42 INS42 INS32 INS22 INS42 UPD42 INS42 INS42 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS42 INS22 INS42 INS22 INS42 INS42 INS22 INS42 INS22 INS42 INS42 INS22 INS42 INS22 INS42 INS42 UPD42 INS42 INS22 INS42 INS22 INS42 INS42 INS22 INS42 INS22 INS42 INS42 INS22 INS42 INS22 INS42 INS42 INS22 INS42 INS22 INS42 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS42 INS42 INS34 INS53 INS42 INS32 INS42 INS42 INS27 INS42 INS42 INS32 UPD42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS22 INS42 INS42 INS42 INS22 INS42 INS34 INS42 INS43 INS21 INS41 INS60 INS60 MOV21 INS61 INS52 INS42 INS22 INS42 INS22 INS22 INS32 INS22 INS40 INS22 INS40 INS22 INS40 INS42 INS34 INS42 INS32 INS39 INS59 INS42 INS42 INS42 INS21 INS52 INS42 INS41 INS36 INS41 INS42 INS42 INS11 INS32 INS32 INS41 INS42 INS32 INS39 INS59 INS59 INS42 INS42 INS42 INS42 INS25 INS22 INS22 INS52 INS42 INS52 INS42 INS36 INS36 INS53 INS22 INS42 INS36 INS36 INS53 INS22 INS42 INS22 INS22 INS21 INS22 INS42 INS42 INS22 INS42 INS22 INS53 INS22 INS34 INS42 INS22 INS27 INS42 INS53 INS22 INS42 INS42 INS36 INS36 INS53 INS36 INS36 INS53 INS36 INS34 INS53 INS42 INS42 INS34 INS40 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS32 INS53 INS42 INS22 INS22 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS32 INS42 INS42 INS22 INS42 INS42 INS60 INS60 INS21 INS41 INS44 INS8 INS42 INS32 INS52 INS42 INS42 INS34 INS42 INS42 UPD42 INS60 INS25 INS41 INS60 INS60 INS41 INS42 INS32 INS52 INS42 INS42 INS34 INS42 INS42 INS42 INS32 INS60 INS25 INS41 INS60 INS60 INS41 INS42 INS32 INS52 INS42 INS42 INS34 INS42 INS42 INS42 INS32 INS60 INS25 INS41 INS60 INS60 INS60 INS60 INS41 INS42 INS32 INS52 INS42 INS42 INS34 INS42 INS42 INS42 INS32 INS60 INS25 INS41 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS60 INS41 INS42 INS32 INS52 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS52 INS42 INS42 INS34 INS42 INS42 INS42 INS42 INS32 INS43 INS43 INS43 INS52 INS42 INS34 INS53 INS42 INS22 INS27 INS36 INS36 INS53 INS36 INS36 INS53 INS43 INS32 INS42 INS32 INS42 INS34 INS21 INS21 INS42 INS32 INS42 INS34 INS21 INS21 INS42 INS42 INS42 INS14 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS14 INS52 INS42 INS42 INS42 INS27 INS7 INS62 INS9 INS43 INS42 INS52 INS42 INS42 INS42 INS9 INS52 INS42 INS42 INS27 INS42 INS27 INS27 INS8 INS22 INS42 INS52 INS42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS14 INS22 INS42 INS32 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS52 INS42 INS52 INS42 UPD42 INS42 INS32 UPD42 INS5 INS59 INS39 INS59 INS32 INS27 INS8 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS27 INS7 INS9 INS62 INS9 INS43 INS42 INS52 INS42 INS42 INS42 INS9 INS52 INS42 INS42 INS27 INS42 INS27 INS27 INS8 INS52 INS42 INS52 INS42 INS27 INS27 INS14 INS52 INS42 INS27 INS27 INS14 INS52 INS42 INS52 INS42 INS52 INS42 INS7 INS52 INS42 INS52 INS42 INS52 INS42 INS14 INS52 INS42 INS52 INS42 INS22 INS42 INS14 INS52 INS42 INS27 INS27 INS14 INS27 INS27 INS14 INS27 INS14 INS42 INS14 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS52 INS42 INS43 INS59 INS43 INS59 INS32 INS11 INS84 INS42 INS41 INS52 INS42 INS34 UPD42 INS42 INS34 INS39 INS59 INS27 INS8 INS42 INS39 INS59 INS39 INS59 INS11 INS52 INS42 INS34 INS22 INS42 INS42 INS34 INS39 INS59 INS27 INS8 INS42 INS39 INS59 INS39 INS59 INS11 INS52 INS42 INS34 INS22 INS42 INS42 INS34 INS39 INS59 INS27 INS8 INS42 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS27 INS52 INS42 INS34 INS22 INS42 INS42 INS34 INS39 INS59 INS27 INS8 INS42 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS39 INS59 INS36 INS52 INS42 INS34 INS42 INS42 INS52 INS42 INS34 INS42 INS42 INS42 INS42 INS42 INS14 INS52 INS42 INS22 INS42 INS27 INS27 INS14 INS27 INS27 INS14 INS42 INS22 MOV42 INS42 INS42 INS42 INS32 INS37 INS42 INS32 INS37 INS43 INS42 MOV32 INS42 INS42 INS43 INS42 INS32 INS34 INS42 INS27 INS42 INS43 INS42 INS32 INS34 INS32 INS34 INS32 INS32 INS41 INS52 INS42 INS43 INS52 INS42 INS42 INS42 INS52 INS42 INS36 INS42 INS22 INS39 INS85 INS42 INS32 INS42 INS27 INS22 INS42 INS32 INS42 INS34 INS21 INS21 INS32 INS34 INS42 INS27 INS42 INS43 INS42 INS32 INS34 INS32 INS34 INS32 INS32 INS41 INS42 INS22 INS42 INS34 INS43 INS42 INS32 INS42 INS34 INS43 INS22 INS22 INS43 INS52 INS42 INS43 INS42 INS34 INS42 INS22 INS43 INS42 INS34 INS42 INS27 INS43 INS42 INS42 INS36 INS36 INS43 INS43 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS9 INS39 INS32 INS43 INS43 INS43 INS43 INS43 INS43 INS9 UPD42 INS42 INS32 INS32 INS40 MOV21 INS42 INS32 INS42 INS32 INS39 INS36 INS52 INS42 INS42 INS32 INS32 INS40 MOV21 INS42 INS32 INS42 INS32 INS39 INS36 INS52 INS42 INS42 INS32 INS32 INS40 INS21 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS36 INS36 INS36 INS36 INS52 INS42 INS42 INS32 INS32 INS40 INS21 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 INS27 INS43 INS52 INS42 INS42 INS32 INS42 INS34 INS43 INS42 INS42 INS42 INS34 INS43 INS52 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS27 INS11 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS9 INS42 INS11 INS52 INS42 MOV22 MOV42 INS32 INS32 INS52 INS42 INS22 INS42 INS32 INS37 INS42 INS27 INS11 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS9 INS52 INS42 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS22 INS42 INS42 INS27 INS27 INS42 INS42 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS37 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS37 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS37 INS42 INS42 INS37 INS42 INS42 INS37 INS42 INS42 INS42 INS27 INS27 INS27 INS27 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS37 INS42 INS42 INS37 INS42 INS42 INS37 INS42 INS42 INS37 INS42 INS42 INS37 INS42 INS42 INS37 INS42 INS42 INS37 INS42 INS42 INS42 INS36 INS36 INS36 INS36 INS36 INS36 INS36 INS36 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS42 INS39 INS32 INS43 INS42 UPD42 INS22 INS42 INS22 INS42 INS52 INS42 INS42 INS42 INS32 INS42 INS34 INS42 INS39 INS32 INS52 INS42 INS42 INS42 INS42 INS36 INS42 INS32 INS42 INS36 INS36 INS42 INS32 INS42 INS36 INS36 INS42 INS32 INS42 INS42 INS42 INS42 INS34 INS36 INS34 INS36 INS34 INS36 INS34 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS27 INS27 INS27 INS27 INS27 INS27 INS27 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS27 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS27 INS27 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS27 INS27 INS42 INS42 INS42 INS27 INS27 INS27 INS42 INS42 INS42 INS11 INS34 INS11 INS34 INS11 INS34 INS11 INS34 INS11 INS34 INS36 INS34 INS36 INS34 INS36 INS34 INS42 INS42 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS39 INS42 INS39 INS36 INS39 INS36 INS39 INS36 INS39 INS36 INS27 INS27 INS27 INS27 INS27 INS27 INS27 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL7 DEL42 DEL42 DEL3 DEL42 DEL42 DEL32 DEL32 DEL42 DEL32 DEL39 DEL60 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL41 DEL42 DEL8 DEL31 DEL7
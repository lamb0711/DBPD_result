Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import org.apache.geode.GemFireCacheException;
-import org.apache.geode.GemFireException;
-import org.apache.geode.cache.query.IndexInvalidException;
-import org.apache.geode.cache.query.QueryException;
-import org.apache.geode.cache.query.QueryInvalidException;
-import org.apache.geode.internal.i18n.LocalizedStrings;
- * This class represents a compiled form of sort criterian present in order by
- * clause
+ * This class represents a compiled form of sort criterian present in order by clause
-      throw new CacheException(e) {
-      };
+      throw new CacheException(e) {};
-  public Object evaluate(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
-    
+  public Object evaluate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+
-  private CompiledValue getReconstructedExpression(String projAttribStr,
-      ExecutionContext context) throws AmbiguousNameException,
-      TypeMismatchException, NameResolutionException {
-    List<CompiledValue> expressions = PathUtils.collectCompiledValuesInThePath(
-        expr, context);
+  private CompiledValue getReconstructedExpression(String projAttribStr, ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+    List<CompiledValue> expressions = PathUtils.collectCompiledValuesInThePath(expr, context);
-    ListIterator<CompiledValue> listIter = expressions.listIterator(expressions
-        .size());
+    ListIterator<CompiledValue> listIter = expressions.listIterator(expressions.size());
-      
-      switch( cv.getType()) {     
-      case CompiledOperation.METHOD_INV:
-        reconstruct.add(0, ((CompiledOperation) cv).getArguments());
-        reconstruct.add(0, ((CompiledOperation) cv).getMethodName());
-        break;       
-      case CompiledPath.PATH:
-        reconstruct.add(0, ((CompiledPath) cv).getTailID());
-        break;      
-      case CompiledIndexOperation.TOK_LBRACK:
-        reconstruct.add(0, ((CompiledIndexOperation) cv).getExpression());
-        break;     
-       default:
-         throw new IllegalStateException(
-             "Unexpected CompiledValue in order by clause");
+
+      switch (cv.getType()) {
+        case CompiledOperation.METHOD_INV:
+          reconstruct.add(0, ((CompiledOperation) cv).getArguments());
+          reconstruct.add(0, ((CompiledOperation) cv).getMethodName());
+          break;
+        case CompiledPath.PATH:
+          reconstruct.add(0, ((CompiledPath) cv).getTailID());
+          break;
+        case CompiledIndexOperation.TOK_LBRACK:
+          reconstruct.add(0, ((CompiledIndexOperation) cv).getExpression());
+          break;
+        default:
+          throw new IllegalStateException("Unexpected CompiledValue in order by clause");
-      case CompiledValue.PATH:
-        currentValue = new CompiledPath(currentValue, (String) iter.next());
-        break;
-      case OQLLexerTokenTypes.METHOD_INV:
-        currentValue = new CompiledOperation(currentValue,
-            (String) iter.next(), (List) iter.next());
-        break;
-      case OQLLexerTokenTypes.TOK_LBRACK:
-        currentValue = new CompiledIndexOperation(currentValue,
-            (CompiledValue) iter.next());
-        break;
+        case CompiledValue.PATH:
+          currentValue = new CompiledPath(currentValue, (String) iter.next());
+          break;
+        case OQLLexerTokenTypes.METHOD_INV:
+          currentValue =
+              new CompiledOperation(currentValue, (String) iter.next(), (List) iter.next());
+          break;
+        case OQLLexerTokenTypes.TOK_LBRACK:
+          currentValue = new CompiledIndexOperation(currentValue, (CompiledValue) iter.next());
+          break;
-  boolean mapExpressionToProjectionField(List projAttrs,
-      ExecutionContext context) throws AmbiguousNameException,
-      TypeMismatchException, NameResolutionException {
+  boolean mapExpressionToProjectionField(List projAttrs, ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-          Object[] prj = (Object[]) TypeUtils.checkCast(projAttrs.get(i),
-              Object[].class);
+          Object[] prj = (Object[]) TypeUtils.checkCast(projAttrs.get(i), Object[].class);
-          Object[] prj = (Object[]) TypeUtils.checkCast(projAttrs.get(i),
-              Object[].class);
-          CompiledValue cvProj = (CompiledValue) TypeUtils.checkCast(prj[1],
-              CompiledValue.class);
+          Object[] prj = (Object[]) TypeUtils.checkCast(projAttrs.get(i), Object[].class);
+          CompiledValue cvProj = (CompiledValue) TypeUtils.checkCast(prj[1], CompiledValue.class);
-            CompiledValue newExpr = getReconstructedExpression(projAttribStr,
-                context);
+            CompiledValue newExpr = getReconstructedExpression(projAttribStr, context);
-            CompiledValue newExpr = getReconstructedExpression(projAttribStr,
-                context);
+            CompiledValue newExpr = getReconstructedExpression(projAttribStr, context);
-    private ProjectionField() {
-    }
+    private ProjectionField() {}
-    public Object evaluate(ExecutionContext context)
-        throws FunctionDomainException, TypeMismatchException,
-        NameResolutionException, QueryInvocationTargetException {
+    public Object evaluate(ExecutionContext context) throws FunctionDomainException,
+        TypeMismatchException, NameResolutionException, QueryInvocationTargetException {

UPD66 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66
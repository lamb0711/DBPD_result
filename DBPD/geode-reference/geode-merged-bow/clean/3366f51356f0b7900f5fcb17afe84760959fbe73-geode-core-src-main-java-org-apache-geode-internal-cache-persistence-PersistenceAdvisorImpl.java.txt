GEODE_5402 Disk recovery hangs after killing members (#2148)

GEODE-5402 Fix issue where disk recovery hangs when all members are waiting for other members to proceed.

+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import org.apache.geode.annotations.TestingOnly;
+import org.apache.geode.internal.CopyOnWriteHashSet;
+import org.apache.geode.internal.cache.persistence.PersistentStateQueryMessage.PersistentStateQueryReplyProcessor;
+  private final PersistentStateQueryMessageSenderFactory persistentStateQueryMessageSenderFactory;
+
+    this(cacheDistributionAdvisor, distributedLockService, persistentMemberView, regionPath,
+        diskRegionStats, persistentMemberManager, new PersistentStateQueryMessageSenderFactory());
+  }
+
+  @TestingOnly
+  PersistenceAdvisorImpl(CacheDistributionAdvisor cacheDistributionAdvisor,
+      DistributedLockService distributedLockService, PersistentMemberView persistentMemberView,
+      String regionPath, DiskRegionStats diskRegionStats,
+      PersistentMemberManager persistentMemberManager,
+      PersistentStateQueryMessageSenderFactory persistentStateQueryMessageSenderFactory) {
+    this.persistentStateQueryMessageSenderFactory = persistentStateQueryMessageSenderFactory;
-    equalMembers = new HashSet<>(persistentMemberView.getOfflineAndEqualMembers());
+    equalMembers = new CopyOnWriteHashSet<>(persistentMemberView.getOfflineAndEqualMembers());
-    return PersistentStateQueryMessage.send(members,
-        cacheDistributionAdvisor.getDistributionManager(), regionPath,
-        persistentMemberView.getMyPersistentID(), persistentMemberView.getMyInitializingID());
+    return fetchPersistentStateQueryResults(members,
+        cacheDistributionAdvisor.getDistributionManager(), persistentMemberView.getMyPersistentID(),
+        persistentMemberView.getMyInitializingID());
+  }
+
+  private PersistentStateQueryResults fetchPersistentStateQueryResults(
+      Set<InternalDistributedMember> members, DistributionManager dm,
+      PersistentMemberID persistentMemberID, PersistentMemberID initializingMemberId) {
+    PersistentStateQueryReplyProcessor replyProcessor = persistentStateQueryMessageSenderFactory
+        .createPersistentStateQueryReplyProcessor(dm, members);
+    PersistentStateQueryMessage message =
+        persistentStateQueryMessageSenderFactory.createPersistentStateQueryMessage(regionPath,
+            persistentMemberID, initializingMemberId, replyProcessor.getProcessorId());
+    return message.send(members, dm, replyProcessor);
-              && !id.diskStoreId.equals(getDiskStoreID())) {
+              && !id.getDiskStoreId().equals(getDiskStoreID())) {
-              && !id.diskStoreId.equals(getDiskStoreID())) {
+              && !id.getDiskStoreId().equals(getDiskStoreID())) {
-          runningDiskStores.add(mem.diskStoreId);
+          runningDiskStores.add(mem.getDiskStoreId());
-        equalMembers.removeIf(id -> !runningDiskStores.contains(id.diskStoreId));
+        for (PersistentMemberID id : equalMembers) {
+          if (!runningDiskStores.contains(id.getDiskStoreId())) {
+            equalMembers.remove(id);
+          }
+        }
-    for (Map.Entry<InternalDistributedMember, PersistentMemberState> entry : remoteStates.stateOnPeers
+    for (Map.Entry<InternalDistributedMember, PersistentMemberState> entry : remoteStates
+        .getStateOnPeers()
-      PersistentMemberID remoteId = remoteStates.persistentIds.get(member);
+      PersistentMemberID remoteId = remoteStates.getPersistentIds().get(member);
-      PersistentStateQueryResults results = PersistentStateQueryMessage.send(members,
-          cacheDistributionAdvisor.getDistributionManager(), regionPath, myPersistentID,
-          myInitializingId);
+      PersistentStateQueryResults results = fetchPersistentStateQueryResults(members,
+          cacheDistributionAdvisor.getDistributionManager(), myPersistentID, myInitializingId);
-        for (Entry<InternalDistributedMember, Set<PersistentMemberID>> entry : results.onlineMemberMap
+        for (Entry<InternalDistributedMember, Set<PersistentMemberID>> entry : results
+            .getOnlineMemberMap()
-          PersistentMemberID persistentID = results.persistentIds.get(memberId);
-          PersistentMemberID initializingID = results.initializingIds.get(memberId);
+          PersistentMemberID persistentID = results.getPersistentIds().get(memberId);
+          PersistentMemberID initializingID = results.getInitializingIds().get(memberId);
-                  && !peerOnlineMember.diskStoreId.equals(getDiskStoreID())
+                  && !peerOnlineMember.getDiskStoreId().equals(getDiskStoreID())
+      removeOlderMembers(membersToWaitFor);
-      for (Map.Entry<InternalDistributedMember, PersistentMemberState> entry : results.stateOnPeers
-          .entrySet()) {
+      for (Map.Entry<InternalDistributedMember, PersistentMemberState> entry : results
+          .getStateOnPeers().entrySet()) {
-        PersistentMemberID persistentID = results.persistentIds.get(memberId);
-        PersistentMemberID initializingID = results.initializingIds.get(memberId);
-        DiskStoreID diskStoreID = results.diskStoreIds.get(memberId);
+        PersistentMemberID persistentID = results.getPersistentIds().get(memberId);
+        PersistentMemberID initializingID = results.getInitializingIds().get(memberId);
+        DiskStoreID diskStoreID = results.getDiskStoreIds().get(memberId);
-          removeNewerPersistentID(membersToWaitFor, initializingID);
+          removeByDiskStoreID(membersToWaitFor, diskStoreID, false);
-          removeByDiskStoreID(membersToWaitFor, diskStoreID);
-          removeByDiskStoreID(offlineMembers, diskStoreID);
+          removeByDiskStoreID(membersToWaitFor, diskStoreID, true);
+          removeByDiskStoreID(offlineMembers, diskStoreID, true);
-
+   * Given a set of persistent members, if the same member occurs more than once in the set but
+   * with different timestamps, remove the older ones leaving only the most recent.
+   *
+   * @param persistentMemberSet The set of persistent members, possibly modified by this method.
+   */
+  protected void removeOlderMembers(Set<PersistentMemberID> persistentMemberSet) {
+    Map<DiskStoreID, PersistentMemberID> mostRecentMap = new HashMap<>();
+    List<PersistentMemberID> idsToRemove = new ArrayList<>();
+    for (PersistentMemberID persistentMember : persistentMemberSet) {
+      DiskStoreID diskStoreId = persistentMember.getDiskStoreId();
+      PersistentMemberID mostRecent = mostRecentMap.get(diskStoreId);
+      if (mostRecent == null) {
+        mostRecentMap.put(diskStoreId, persistentMember);
+      } else {
+        PersistentMemberID older = persistentMember;
+        boolean persistentMemberIsNewer =
+            !persistentMember.isOlderOrEqualVersionOf(mostRecent);
+        if (persistentMemberIsNewer) {
+          older = mostRecent;
+          mostRecentMap.put(diskStoreId, persistentMember);
+        }
+        idsToRemove.add(older);
+      }
+    }
+    persistentMemberSet.removeAll(idsToRemove);
+  }
+
+  /**
-      DiskStoreID diskStoreID) {
+      DiskStoreID diskStoreID, boolean updateAdvisor) {
-      if (id.diskStoreId.equals(diskStoreID)) {
+      if (id.getDiskStoreId().equals(diskStoreID)) {
-              "{}-{}: Not waiting for {} because it no longer has this region in it's disk store",
+              "{}-{}: Not waiting for {} because it no longer has this region in its disk store",
-        memberRemoved(id, false);
+        if (updateAdvisor) {
+          memberRemoved(id, false);
+        }

INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS23 INS31 INS31 INS31 INS83 INS83 INS43 INS59 INS83 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS8 INS78 INS44 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 INS44 INS42 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS17 INS42 INS43 INS42 INS21 INS42 INS74 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS60 INS60 INS41 INS65 INS65 INS74 INS42 INS60 INS60 INS70 INS21 INS39 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS7 INS43 INS43 INS42 INS42 INS42 INS43 INS59 INS43 INS59 INS32 INS66 INS66 INS42 INS66 INS43 INS43 INS74 INS59 INS74 INS59 INS44 INS42 INS8 INS32 INS43 INS22 INS42 UPD42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS21 INS42 INS42 INS43 INS43 INS43 INS42 INS14 INS43 INS43 INS42 INS14 INS43 INS42 INS60 INS60 INS25 INS42 INS42 INS42 INS42 INS52 INS42 UPD74 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS74 INS42 INS42 INS74 INS42 INS43 INS59 INS43 INS59 INS27 INS8 INS8 UPD43 INS42 INS42 INS70 INS42 INS42 INS32 INS43 INS43 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS33 INS21 INS60 INS60 INS25 INS21 INS32 INS25 UPD42 INS44 INS42 INS8 INS32 UPD42 INS42 INS42 MOV43 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS43 INS59 INS39 INS59 INS42 INS8 INS32 INS42 INS42 INS42 INS8 INS43 INS42 INS25 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS38 INS21 INS21 INS42 INS42 INS42 MOV21 INS27 MOV27 INS42 INS38 INS8 INS42 INS42 MOV43 MOV43 INS32 INS32 INS32 INS32 INS7 INS32 MOV38 MOV38 INS38 INS32 MOV32 INS21 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS9 INS9 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD45 INS32 INS42 INS42 INS32 INS32 INS32 INS32 INS32 INS42 MOV32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 DEL83 DEL42 DEL42 DEL40 DEL40 DEL42 DEL32 DEL38 DEL27 DEL40 DEL40 DEL42 DEL42 DEL42 DEL59 DEL38 DEL86 DEL32 DEL21 DEL40 DEL40 DEL42 DEL42 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Exports snapshot data using a sliding window to prevent the nodes in a 
- * partitioned region from overrunning the exporter.  When a {@link SnapshotPacket}
- * is written to the {@link ExportSink}, an ACK is sent back to the source
- * node.  The source node will continue to send data until it runs out of permits;
- * it must then wait for ACK's to resume.
+ * Exports snapshot data using a sliding window to prevent the nodes in a partitioned region from
+ * overrunning the exporter. When a {@link SnapshotPacket} is written to the {@link ExportSink}, an
+ * ACK is sent back to the source node. The source node will continue to send data until it runs out
+ * of permits; it must then wait for ACK's to resume.
-  private static final int WINDOW_SIZE = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "WindowedExporter.WINDOW_SIZE", 10);
+  private static final int WINDOW_SIZE =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "WindowedExporter.WINDOW_SIZE", 10);
-  public long export(Region<K, V> region, ExportSink sink, SnapshotOptions<K, V> options) throws IOException {
+  public long export(Region<K, V> region, ExportSink sink, SnapshotOptions<K, V> options)
+      throws IOException {
-    
+
-    
+
-      // to keep the reference to the ResultsCollector returned from execute().  
-      // Normally discarding the reference can cause issues if GC causes the 
+      // to keep the reference to the ResultsCollector returned from execute().
+      // Normally discarding the reference can cause issues if GC causes the
-      InternalExecution exec = (InternalExecution) FunctionService.onRegion(region)
-          .withArgs(args)
+      InternalExecution exec = (InternalExecution) FunctionService.onRegion(region).withArgs(args)
-      
+
-      
+
-      
+
-      
+
-      
+
-      
+
-    
+
-    
+
-    
+
-    
+
-  
+
-   * Gathers the local data on the region and sends it back to the
-   * {@link ResultCollector} in serialized form as {@link SnapshotPacket}s.  Uses
-   * a sliding window provided by the {@link FlowController} to avoid over-running
-   * the exporting member.
+   * Gathers the local data on the region and sends it back to the {@link ResultCollector} in
+   * serialized form as {@link SnapshotPacket}s. Uses a sliding window provided by the
+   * {@link FlowController} to avoid over-running the exporting member.
-    
+
-        for (Iterator<Entry<K, V>> iter = region.entrySet().iterator(); iter.hasNext() && !window.isAborted(); ) {
+        for (Iterator<Entry<K, V>> iter = region.entrySet().iterator(); iter.hasNext()
+            && !window.isAborted();) {
-            
+
-        
+
-        
+
-        
+
-   * Collects export results and places them in a queue for processing by the
-   * function invoker.
+   * Collects export results and places them in a queue for processing by the function invoker.
-  private static class WindowedExportCollector implements LocalResultCollector<Object, BlockingQueue<SnapshotPacket>> {
+  private static class WindowedExportCollector
+      implements LocalResultCollector<Object, BlockingQueue<SnapshotPacket>> {
-    
+
-    
+
-    
+
-    
+
-    
+
-      
+
-      
+
-    
+
+     * 
-    
+
-     * Aborts any further collection of results and forwards the cancellation to 
-     * the members involved in the export.
+     * Aborts any further collection of results and forwards the cancellation to the members
+     * involved in the export.
-          
+
-          
+
-    
+
-      FlowController.getInstance().sendAck(region.getDistributionManager(), 
-          packet.getSender(), packet.getWindowId(), packet.getPacketId());
+      FlowController.getInstance().sendAck(region.getDistributionManager(), packet.getSender(),
+          packet.getWindowId(), packet.getPacketId());
-    
+
-          
+
-      
+
-            
+
-            getLoggerI18n().fine("SNP: All results received for export of region " + region.getName());
-          
+            getLoggerI18n()
+                .fine("SNP: All results received for export of region " + region.getName());
+
-      exception = (ex instanceof FunctionException) ?
-          (FunctionException) ex : new FunctionException(ex);
+      exception =
+          (ex instanceof FunctionException) ? (FunctionException) ex : new FunctionException(ex);
-    
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66
GEODE-6488: Migrating cancellation state to execution context (#3322)

This work solves two problems.  One is that the query cancellation task
reference in DefaultQuery could be overwritten and thus never removed
from monitoring upon successful completion of a query.  Second is that
once a query execution timed out once, the query object was in an
unusable state which is undesirable.

The solution is to attach the cancellation state to the execution
context rather than the query object, so that cancellation is associated
with each independent execution of a query rather than having
cancellation state that applies to the entire query object.
+import java.util.Optional;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.apache.geode.cache.CacheRuntimeException;
+  private Optional<ScheduledFuture> cancelationTask;
+  private volatile CacheRuntimeException canceledException;
+  static final ThreadLocal<AtomicBoolean> isCanceled =
+      ThreadLocal.withInitial(AtomicBoolean::new);
+
+    this.cancelationTask = Optional.empty();
+  }
+
+  Optional<ScheduledFuture> getCancelationTask() {
+    return cancelationTask;
+  }
+
+  void setCancelationTask(final ScheduledFuture cancelationTask) {
+    this.cancelationTask = Optional.of(cancelationTask);
-  public void setCqQueryContext(boolean cqQuery) {
-    throw new UnsupportedOperationException("Method should not have been called");
-  }
-
+  /**
+   * Check to see if the query execution was canceled. The query gets canceled by the QueryMonitor
+   * if it takes more than the max query execution time or low memory situations
+   */
+  public boolean isCanceled() {
+    return getQueryCanceledException() != null;
+  }
+
+  public CacheRuntimeException getQueryCanceledException() {
+    return canceledException;
+  }
+
+  public void setQueryCanceledException(final CacheRuntimeException queryCanceledException) {
+    this.canceledException = queryCanceledException;
+  }
+
+  /**
+   * This method attempts to reintrepret a {@link QueryExecutionCanceledException} using the
+   * the value returned by {@link #getQueryCanceledException} (set by the {@link QueryMonitor}).
+   *
+   * @throws if {@link #getQueryCanceledException} doesn't return {@code null} then throw that
+   *         {@link CacheRuntimeException}, otherwise throw {@link QueryExecutionCanceledException}
+   */
+  Object reinterpretQueryExecutionCanceledException() {
+    final CacheRuntimeException queryCanceledException = getQueryCanceledException();
+    if (queryCanceledException != null) {
+      throw queryCanceledException;
+    } else {
+      throw new QueryExecutionCanceledException(
+          "Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
+    }
+  }

INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS74 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS74 INS59 INS74 INS42 INS8 MOV39 UPD42 MOV42 INS44 INS8 INS29 INS83 INS39 INS42 INS8 INS83 INS43 INS42 INS8 INS83 INS39 INS42 INS44 INS8 INS29 INS43 INS42 INS8 INS43 INS43 INS42 INS42 INS42 INS43 INS43 INS42 INS32 INS21 INS43 INS43 INS41 INS83 INS43 INS42 INS21 INS65 INS41 INS42 INS41 INS83 INS43 INS42 INS21 INS65 INS65 INS42 INS60 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS89 INS7 INS42 INS42 INS42 INS42 INS7 INS66 INS66 INS27 INS42 INS42 INS7 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS83 INS43 INS59 INS27 INS8 INS8 INS43 INS22 INS32 INS22 INS32 INS32 INS33 INS22 INS42 INS42 INS67 INS42 INS67 INS66 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS53 MOV53 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS42 INS42 UPD43 UPD45 UPD42 DEL83 DEL39 DEL42 DEL44 DEL8 DEL31
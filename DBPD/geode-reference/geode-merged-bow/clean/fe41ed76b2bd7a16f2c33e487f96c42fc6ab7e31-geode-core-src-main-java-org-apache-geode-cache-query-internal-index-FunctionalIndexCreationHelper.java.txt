GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-/*
- * IndexCreationHelper.java
- *
- * Created on March 16, 2005, 6:20 PM
- */
+import static org.apache.commons.lang.StringUtils.isEmpty;
+
-import org.apache.geode.cache.Cache;
+import org.apache.geode.internal.cache.InternalCache;
-/**
- *
- */
+
-  // If true means pattern is *, if false & still map type index that means
-  // more than 1 specific keys
+
+  /**
+   * If true means pattern is *, if false & still map type index that means more than 1 specific
+   * keys
+   */
-  CompiledValue indexedExpr;
-  List fromClauseIterators;
+
+  private CompiledValue indexedExpr;
+
+  private List fromClauseIterators;
+
+
+
+
-   * Asif : The Iterators for index creation are different then those which are used for index
-   * updates as in case of Index creation the 0th iterator is modified such that it always
-   * represents collection of Region.Entry objects. As a result all the rest of iterators as well as
-   * indexed expression have to be modified to appropriately resolve the dependency on 0th
-   * iterator.The missing link indicates the dependency. The original 0th iterator is evaluated as
-   * additional projection attribute. These changes provide significant improvement in Index
-   * creation as compared to previous method. In this approach the IMQ acts on all the entries of
-   * the region while in previous , it iterated over the individual entry of the Region & applied
-   * IMQ to it.
+   * The Iterators for index creation are different then those which are used for index updates as
+   * in case of Index creation the 0th iterator is modified such that it always represents
+   * collection of Region.Entry objects. As a result all the rest of iterators as well as indexed
+   * expression have to be modified to appropriately resolve the dependency on 0th iterator.The
+   * missing link indicates the dependency. The original 0th iterator is evaluated as additional
+   * projection attribute. These changes provide significant improvement in Index creation as
+   * compared to previous method. In this approach the IMQ acts on all the entries of the region
+   * while in previous , it iterated over the individual entry of the Region & applied IMQ to it.
-
-  CompiledValue missingLink = null;
-  CompiledValue additionalProj = null;
-  ObjectType addnlProjType = null;
-  CompiledValue modifiedIndexExpr = null;
-  boolean isFirstIteratorRegionEntry = false;
-  boolean isFirstIteratorRegionKey = false;
-  final String imports;
-  // TODO: Asif Remove the fromClause being passed as parameter to the
-  // constructor
+  CompiledValue missingLink = null;
+
+  CompiledValue additionalProj = null;
+
+  ObjectType addnlProjType = null;
+
+  CompiledValue modifiedIndexExpr = null;
+
+  boolean isFirstIteratorRegionEntry = false;
+
+  boolean isFirstIteratorRegionKey = false;
+
+  private final String imports;
+
+  // TODO: Remove the fromClause being passed as parameter to the constructor
-      String projectionAttributes, String imports, Cache cache, ExecutionContext externalContext,
-      IndexManager imgr) throws IndexInvalidException {
+      String projectionAttributes, String imports, InternalCache cache,
+      ExecutionContext externalContext, IndexManager imgr) throws IndexInvalidException {
-    Object data[] = modfiyIterDefToSuiteIMQ((CompiledIteratorDef) fromClauseIterators.get(0));
+    Object[] data = modifyIterDefToSuiteIMQ((CompiledIteratorDef) this.fromClauseIterators.get(0));
-    fromClauseIterators.remove(0);
-    fromClauseIterators.add(0, data[1]);
-    region = (QRegion) data[0];
+    this.fromClauseIterators.remove(0);
+    this.fromClauseIterators.add(0, data[1]);
+    this.region = (QRegion) data[0];
+  @Override
-    return fromClauseIterators;
+    return this.fromClauseIterators;
+  @Override
-    return indexedExpr;
+    return this.indexedExpr;
+  @Override
-    return region.getRegion();
+    return this.region.getRegion();
-
-
-  /*
-   * Asif : The function is modified to optmize the index creation code. If the 0th iterator of from
+  /**
+   * The function is modified to optimize the index creation code. If the 0th iterator of from
+   * <p>
+   * TODO: method is too complex for IDE to analyze -- refactor prepareFromClause
-    if (imports != null) {
+    if (this.imports != null) {
-    List list = this.compiler.compileFromClause(fromClause);
+    List list = this.compiler.compileFromClause(this.fromClause);
-              .toLocalizedString(fromClause));
+              .toLocalizedString(this.fromClause));
-    boolean isFromClauseNull = true;
-    CompiledIteratorDef newItr = null;
-    StringBuffer tempBuff = new StringBuffer();
+    StringBuilder tempBuff = new StringBuilder();
+    boolean isFromClauseNull = true;
+
-        context.addToIndependentRuntimeItrMapForIndexCreation(iterDef);
+        this.context.addToIndependentRuntimeItrMapForIndexCreation(iterDef);
-                  .toLocalizedString(fromClause));
+                  .toLocalizedString(this.fromClause));
+
-        // Asif: Bind the Index_Internal_ID to the RuntimeIterator
+
+        // Bind the Index_Internal_ID to the RuntimeIterator
-          // if (iterDef.getCollectionExpr() instanceof CompiledRegion ||
-          // iterDef.getCollectionExpr() instanceof CompiledPath) {
-          // pr.getIndexManager().putCanonicalizedIteratorName(pr.getFullPath(),
-          // this.canonicalizedIteratorNames[i]);
-          // } else {
-          // }
+        CompiledIteratorDef newItr;
+
-          addnlProjType = rIter.getElementType();
-          String name = null;
-          if ((name = iterDef.getName()) == null || name.equals("")) {
-            // In case the name of iterator is null or balnk set it to
-            // index_internal_id
+          this.addnlProjType = rIter.getElementType();
+          String name = iterDef.getName();
+          if (isEmpty(name)) {
+            // In case the name of iterator is null or blank set it to index_internal_id
-          // TODO Asif : What if cv is not an instance of CompiledRegion
+
+          // TODO: What if cv is not an instance of CompiledRegion
-            missingLink = new CompiledPath(new CompiledID(name), "value");
-            // missingLinkPath = name + ".value";
-            additionalProj = missingLink;
+            this.missingLink = new CompiledPath(new CompiledID(name), "value");
+            this.additionalProj = this.missingLink;
+
-            CompiledValue prevCV = null;
+            CompiledValue prevCV;
-                cv = ((CompiledOperation) cv).getReceiver(context);
+                cv = ((CompiledOperation) cv).getReceiver(this.context);
-                cv = ((CompiledPath) cv).getReceiver();
+                cv = cv.getReceiver();
-                cv = ((CompiledIndexOperation) cv).getReceiver();
+                cv = cv.getReceiver();
-              reconstruct.add(0, Integer.valueOf(prevCV.getType()));
+              reconstruct.add(0, prevCV.getType());
-            int firstTokenType = ((Integer) reconstruct.get(0)).intValue();
+
+            int firstTokenType = (Integer) reconstruct.get(0);
-              // CompiledPath cp = (CompiledPath) reconstruct.get(1);
+
-                missingLink = new CompiledPath(new CompiledID(name), "value");
-                // missingLinkPath = name + ".value";
+                this.missingLink = new CompiledPath(new CompiledID(name), "value");
-                missingLink = new CompiledPath(new CompiledID(name), "key");
-                isFirstIteratorRegionKey = true;
-                // missingLinkPath = name + ".key";
+                this.missingLink = new CompiledPath(new CompiledID(name), "key");
+                this.isFirstIteratorRegionKey = true;
-                isFirstIteratorRegionEntry = true;
+                this.isFirstIteratorRegionEntry = true;
+
-              int secondTokenType =
-                  (reconstruct.size() > 1) ? ((Integer) reconstruct.get(0)).intValue() : -1;
-              if (!isFirstIteratorRegionEntry
-                  && (secondTokenType == OQLLexerTokenTypes.TOK_LBRACK)) {
-                // Asif: If the field just next to region , is values or
-                // getValues & next to it is
-                // CompiledIndexOpn, it indirectly means Map operation & we are
-                // able to take care of it by adding a flag in CompiledIndexOp
-                // which
-                // indicates to it whether to return entry or value.But if the
-                // field
-                // is asList or toArray , we have a problem as we don't have a
-                // corresponding
-                // list of entries. If the field is keys , an exception should
-                // be thrown
-                // as IndexOpn on set is not defined.
+              int secondTokenType = reconstruct.size() > 1 ? (Integer) reconstruct.get(0) : -1;
+              if (!this.isFirstIteratorRegionEntry
+                  && secondTokenType == OQLLexerTokenTypes.TOK_LBRACK) {
+
+                // If the field just next to region , is values or getValues & next to it is
+                // CompiledIndexOpn, it indirectly means Map operation & we are able to take care of
+                // it by adding a flag in CompiledIndexOp which indicates to it whether to return
+                // entry or value. But if the field is asList or toArray , we have a problem as we
+                // don't have a corresponding list of entries. If the field is keys , an exception
+                // should be thrown as IndexOpn on set is not defined.
-                  additionalProj = new CompiledIndexOperation(new CompiledBindArgument(1),
+                  this.additionalProj = new CompiledIndexOperation(new CompiledBindArgument(1),
+
-                  // TODO:Asif . This needs to be supported
+                  // TODO: add support for toList and toArray
+
-              } else if (!isFirstIteratorRegionEntry
+
+              } else if (!this.isFirstIteratorRegionEntry
-                // Asif :Check if the second token name is toList or toArray or
-                // asSet.We need to remove those
+
+                // Check if the second token name is toList or toArray or asSet.We need to remove
+                // those
-                  remove(reconstruct, ((secondTokenType == OQLLexerTokenTypes.METHOD_INV) ? 3 : 2),
-                      0);
+                  remove(reconstruct, secondTokenType == OQLLexerTokenTypes.METHOD_INV ? 3 : 2, 0);
+
-              additionalProj = new CompiledIndexOperation(new CompiledBindArgument(1),
+              this.additionalProj = new CompiledIndexOperation(new CompiledBindArgument(1),
+
-                missingLink = new CompiledPath(new CompiledID(name), "value");
-                // missingLinkPath = name + ".value";
+                this.missingLink = new CompiledPath(new CompiledID(name), "value");
-                missingLink = new CompiledPath(new CompiledID(name), "key");
-                isFirstIteratorRegionKey = true;
-                // missingLinkPath = name + ".key";
+                this.missingLink = new CompiledPath(new CompiledID(name), "key");
+                this.isFirstIteratorRegionKey = true;
-                isFirstIteratorRegionEntry = true;
+                this.isFirstIteratorRegionEntry = true;
+
-              int secondTokenType =
-                  (reconstruct.size() > 1) ? ((Integer) reconstruct.get(0)).intValue() : -1;
-              if (!isFirstIteratorRegionEntry
-                  && (secondTokenType == OQLLexerTokenTypes.TOK_LBRACK)) {
+              int secondTokenType = reconstruct.size() > 1 ? (Integer) reconstruct.get(0) : -1;
+              if (!this.isFirstIteratorRegionEntry
+                  && secondTokenType == OQLLexerTokenTypes.TOK_LBRACK) {
+
-                  // TODO:Asif . This needs to be supported
+                  // TODO: add support for toList and toArray
+
-              } else if (!isFirstIteratorRegionEntry
+              } else if (!this.isFirstIteratorRegionEntry
-                // Asif :Check if the second token name is toList or toArray or
-                // asSet.We need to remove those
+
+                // Check if the second token name is toList or toArray or asSet.We need to remove
+                // those
-                  remove(reconstruct, ((secondTokenType == OQLLexerTokenTypes.METHOD_INV) ? 3 : 2),
-                      0);
+                  remove(reconstruct, secondTokenType == OQLLexerTokenTypes.METHOD_INV ? 3 : 2, 0);
-            if (!isFirstIteratorRegionEntry) {
-              additionalProj = missingLink;
+
+            if (!this.isFirstIteratorRegionEntry) {
+              this.additionalProj = this.missingLink;
-                  int tokenType = ((Integer) obj).intValue();
+                  int tokenType = (Integer) obj;
-                    additionalProj =
-                        new CompiledPath(additionalProj, (String) reconstruct.get(++j));
+                    this.additionalProj =
+                        new CompiledPath(this.additionalProj, (String) reconstruct.get(++j));
-                    additionalProj = new CompiledIndexOperation(additionalProj,
+                    this.additionalProj = new CompiledIndexOperation(this.additionalProj,
-                    additionalProj = new CompiledOperation(additionalProj,
+                    this.additionalProj = new CompiledOperation(this.additionalProj,
+
-            indexInitIterators.add(newItr);
+            this.indexInitIterators.add(newItr);
+
-          if (rIter.getDefinition().indexOf(this.canonicalizedIteratorNames[0]) != -1) {
-            newItr =
-                (CompiledIteratorDef) getModifiedDependentCompiledValue(context, i, iterDef, true);
+          if (rIter.getDefinition().contains(this.canonicalizedIteratorNames[0])) {
+            newItr = (CompiledIteratorDef) getModifiedDependentCompiledValue(this.context, i,
+                iterDef, true);
+    } catch (IndexInvalidException e) {
+      throw e;
-      if (e instanceof IndexInvalidException)
-        throw (IndexInvalidException) e;
-              .toLocalizedString(fromClause));
+              .toLocalizedString(this.fromClause));
-  /*
-   * Asif: This fuinction is modified so that if the indexed expression has any dependency on the
-   * 0th iterator, then it needs to modified by using the missing link so that it is derivable from
-   * the 0th iterator.
+  /**
+   * This function is modified so that if the indexed expression has any dependency on the 0th
+   * iterator, then it needs to modified by using the missing link so that it is derivable from the
+   * 0th iterator.
+   * <p>
+   * TODO: refactor large method prepareIndexExpression
-    // List indexedExprs = this.compiler.compileProjectionAttributes(indexedExpression);
-        || expr instanceof CompiledNegation)
+        || expr instanceof CompiledNegation) {
+    }
+
-      StringBuffer sb = new StringBuffer();
+      StringBuilder sb = new StringBuilder();
-        // CompiledIndexOperation cio = (CompiledIndexOperation)expr;
+
-          expr.generateCanonicalizedExpression(sb, context);
+          expr.generateCanonicalizedExpression(sb, this.context);
-          expr.generateCanonicalizedExpression(sb, context);
+          expr.generateCanonicalizedExpression(sb, this.context);
+
-          expr.generateCanonicalizedExpression(sb, context);
+          expr.generateCanonicalizedExpression(sb, this.context);
-          StringBuffer buff2 = new StringBuffer();
+          StringBuilder sb2 = new StringBuilder();
-            this.mapKeys[size - j - 1] = cv.evaluate(context);
-            StringBuffer sbuff = new StringBuffer();
-            cv.generateCanonicalizedExpression(sbuff, context);
-            sbuff.insert(0, prefixStr);
-            sbuff.append(']');
-            this.multiIndexKeysPattern[j] = sbuff.toString();
-            cv.generateCanonicalizedExpression(buff2, context);
-            buff2.insert(0, ',');
+            this.mapKeys[size - j - 1] = cv.evaluate(this.context);
+            StringBuilder sb3 = new StringBuilder();
+            cv.generateCanonicalizedExpression(sb3, this.context);
+            sb3.insert(0, prefixStr);
+            sb3.append(']');
+            this.multiIndexKeysPattern[j] = sb3.toString();
+            cv.generateCanonicalizedExpression(sb2, this.context);
+            sb2.insert(0, ',');
-          buff2.deleteCharAt(0);
-          sb.append(buff2.toString());
+          sb2.deleteCharAt(0);
+          sb.append(sb2);
-        expr.generateCanonicalizedExpression(sb, context);
+        expr.generateCanonicalizedExpression(sb, this.context);
-      // expr.generateCanonicalizedExpression(sb, this.context);
-      // String tempStr = this.indexedExpression;
-      modifiedIndexExpr = expr;
+      this.modifiedIndexExpr = expr;
-          && this.indexedExpression.indexOf(this.canonicalizedIteratorNames[0]) >= 0) {
-        modifiedIndexExpr = getModifiedDependentCompiledValue(context, -1, expr, true);
+          && this.indexedExpression.contains(this.canonicalizedIteratorNames[0])) {
+        this.modifiedIndexExpr = getModifiedDependentCompiledValue(this.context, -1, expr, true);
-      // e.printStackTrace();
-    indexedExpr = expr;
+    this.indexedExpr = expr;
-  private Object[] modfiyIterDefToSuiteIMQ(CompiledIteratorDef iterDef)
+  private Object[] modifyIterDefToSuiteIMQ(CompiledIteratorDef iterDef)
-    Object retValues[] = {null, null};
+    Object[] retValues = {null, null};
-      // System.out.println("def = "+def);
-        retValues[0] = def.evaluate(context);
+        retValues[0] = def.evaluate(this.context);
+
-        CompiledValue prevCV = null;
+
-          prevCV = cv;
+          CompiledValue prevCV = cv;
-            cv = ((CompiledOperation) cv).getReceiver(context);
+            cv = ((CompiledOperation) cv).getReceiver(this.context);
-          reconstruct.add(0, Integer.valueOf(prevCV.getType()));
+          reconstruct.add(0, prevCV.getType());
+
-            int tokenType = ((Integer) obj).intValue();
+            int tokenType = (Integer) obj;
+
-        retValues[0] = v.evaluate(context);
+        retValues[0] = v.evaluate(this.context);
-  /*
-   * Asif : This function is used to correct the complied value's dependency , in case the
-   * compiledvalue is dependent on the 0th RuntimeIterator in some way. Thus the dependent compiled
-   * value is prefixed with the missing link so that it is derivable from the 0th iterator.
+  /**
+   * This function is used to correct the complied value's dependency , in case the compiledValue is
+   * dependent on the 0th RuntimeIterator in some way. Thus the dependent compiled value is prefixed
+   * with the missing link so that it is derivable from the 0th iterator.
+
-      if (canonFrmClause.startsWith(this.canonicalizedIteratorNames[0]))
-        isDependent = true;
-      else
-        isDependent = false;
+
+      // TODO: original value of isDependent is always ignored
+      isDependent = canonFrmClause.startsWith(this.canonicalizedIteratorNames[0]);
+
+
+
-      int len = list.size();
-      for (int i = 0; i < len; ++i) {
-        CompiledValue cv1 = (CompiledValue) list.get(i);
-        StringBuffer sbuff = new StringBuffer();
-        cv1.generateCanonicalizedExpression(sbuff, context);
-        if (sbuff.toString().startsWith(this.canonicalizedIteratorNames[0])) {
+      for (Object aList : list) {
+        CompiledValue cv1 = (CompiledValue) aList;
+        StringBuilder sb = new StringBuilder();
+        cv1.generateCanonicalizedExpression(sb, context);
+        if (sb.toString().startsWith(this.canonicalizedIteratorNames[0])) {
-      // Asif: What if the receiver is null?
+
+      // What if the receiver is null?
+
-        StringBuffer sbuff = new StringBuffer();
-        cv1.generateCanonicalizedExpression(sbuff, context);
-        if (sbuff.toString().startsWith(this.canonicalizedIteratorNames[0])) {
+        StringBuilder sb = new StringBuilder();
+        cv1.generateCanonicalizedExpression(sb, context);
+        if (sb.toString().startsWith(this.canonicalizedIteratorNames[0])) {
+
-        String name = null;
+        String name;
-          // Asif: The CompiledID is a RuneTimeIterator & so it needs to be
-          // replaced by the missing link
+          // The CompiledID is a RuneTimeIterator & so it needs to be replaced by the missing link
-          // Asif: The compiledID is a compiledpath
-          return new CompiledPath(missingLink, id.getId());
+          // The compiledID is a compiledPath
+          return new CompiledPath(this.missingLink, id.getId());
+
-      StringBuffer sbuff = new StringBuffer();
-      cv1.generateCanonicalizedExpression(sbuff, context);
-      if (sbuff.toString().startsWith(this.canonicalizedIteratorNames[0])) {
+      StringBuilder sb = new StringBuilder();
+      cv1.generateCanonicalizedExpression(sb, context);
+      if (sb.toString().startsWith(this.canonicalizedIteratorNames[0])) {

MOV26 INS26 INS40 UPD40 INS29 INS83 INS83 INS83 INS78 INS78 INS78 INS29 MOV60 INS29 UPD42 INS29 INS65 UPD43 INS42 INS42 INS42 INS65 INS65 INS65 INS66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 INS5 INS22 INS22 INS66 INS66 INS66 INS66 INS66 INS66 INS66 UPD43 INS12 INS12 INS66 INS66 INS66 INS66 INS66 INS8 INS5 INS66 INS66 INS66 INS43 INS85 INS22 INS22 INS22 INS52 INS42 INS52 INS42 INS22 INS22 UPD42 MOV44 INS8 INS44 INS8 MOV53 INS22 INS43 INS85 INS21 MOV42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 UPD43 UPD43 INS53 INS43 INS42 INS53 MOV43 UPD43 UPD27 MOV27 INS52 INS42 INS42 MOV7 INS52 INS42 UPD42 INS60 MOV42 INS42 UPD42 MOV42 INS14 INS22 UPD42 INS22 MOV38 MOV32 INS70 INS22 INS22 MOV43 INS59 INS43 INS42 INS52 INS42 UPD43 INS52 INS42 UPD42 INS44 INS42 MOV8 INS52 INS42 INS52 INS42 INS22 INS42 MOV42 UPD42 INS22 INS22 INS60 MOV43 INS42 INS52 INS42 INS32 INS52 INS42 INS52 INS42 INS22 INS22 MOV43 INS59 MOV32 INS22 MOV43 UPD43 INS22 MOV32 INS42 MOV42 MOV32 INS22 UPD43 INS52 INS42 INS52 INS42 INS42 INS42 UPD42 UPD42 INS34 INS52 INS42 UPD42 UPD42 UPD42 UPD43 UPD43 INS22 INS52 INS42 UPD42 INS52 INS42 INS22 INS22 UPD42 UPD42 UPD42 UPD42 MOV42 MOV43 INS42 UPD43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS52 INS42 INS22 INS22 INS22 INS22 INS52 INS42 INS52 INS42 UPD43 UPD43 MOV11 UPD42 UPD43 UPD42 UPD43 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 MOV11 INS22 INS52 INS42 UPD42 UPD42 UPD42 UPD42 INS22 UPD42 UPD42 UPD42 INS22 UPD42 INS22 UPD42 UPD42 MOV32 INS52 INS42 INS22 UPD43 INS52 INS42 UPD42 INS52 INS42 INS52 INS42 INS22 UPD42 UPD42 INS34 MOV27 INS22 INS22 INS22 INS52 INS42 UPD42 INS52 INS42 MOV27 MOV11 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS22 INS52 INS42 MOV27 INS22 INS52 INS42 INS22 INS22 INS52 INS42 MOV27 MOV11 INS22 INS52 INS42 INS42 INS52 INS42 INS52 INS42 INS22 INS22 INS22 INS52 INS42 INS22 MOV11 INS42 INS52 INS42 INS52 INS42 MOV16 INS52 INS42 INS22 INS22 INS52 INS42 MOV27 INS52 INS42 INS52 INS42 INS22 INS22 INS52 INS42 MOV16 INS52 INS42 INS22 INS22 MOV27 INS52 INS42 INS52 INS42 INS22 INS22 INS52 INS42 INS52 INS42 INS22 INS52 INS42 DEL29 DEL66 DEL43 DEL85 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL42 DEL33 DEL42 DEL7 DEL36 DEL33 DEL27 DEL42 DEL45 DEL32 DEL27 DEL42 DEL42 DEL42 DEL33 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL34 DEL32 DEL36 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL36 DEL36 DEL42 DEL32 DEL42 DEL36 DEL42 DEL42 DEL36 DEL36 DEL42 DEL42 DEL42 DEL42 DEL42 DEL36 DEL36 DEL42 DEL32 DEL42 DEL36 DEL42 DEL36 DEL36 DEL42 DEL42 DEL42 DEL36 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL34 DEL38 DEL27 DEL42 DEL42 DEL43 DEL62 DEL43 DEL42 DEL11 DEL53 DEL25 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL85 DEL42 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL34 DEL32 DEL36 DEL42 DEL32 DEL42 DEL9 DEL21 DEL42 DEL9 DEL7 DEL21 DEL25 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL38 DEL24 DEL33 DEL42
GEODE-8175: remove unsupported redis commands (#5146)

Removed list and zset commands.
Removed redis HyperLog commands.
Removed redis transaction commands.
-import java.util.Collection;
-import java.util.Map.Entry;
-import org.apache.geode.cache.EntryEvent;
-import org.apache.geode.cache.RegionDestroyedException;
-import org.apache.geode.cache.util.CacheListenerAdapter;
-import org.apache.geode.internal.hll.HyperLogLogPlus;
-  private final MetaCacheListener metaListener;
-
-   * The field that defines the name of the {@link Region} which holds all of the HyperLogLogs. The
-   * current value of this field is {@code HLL_REGION}.
-   */
-  public static final String HLL_REGION = "ReDiS_HlL";
-
-  /**
-    metaListener = new MetaCacheListener();
-  /**
-   * Initializes the {@link Cache}, and creates Redis necessities Region and protects declares that
-   * {@link Region} to be protected. Also, every {@code GeodeRedisServer} will check for entries
-   * already in the meta data Region.
-   */
-      Region<ByteArrayWrapper, HyperLogLogPlus> hLLRegion;
-      if ((hLLRegion = cache.getRegion(HLL_REGION)) == null) {
-        RegionFactory<ByteArrayWrapper, HyperLogLogPlus> regionFactory =
-            gemFireCache.createRegionFactory(DEFAULT_REGION_TYPE);
-        hLLRegion = regionFactory.create(HLL_REGION);
-      }
-        redisMetaDataFactory.addCacheListener(metaListener);
-      regionProvider = new RegionProvider(stringsRegion, hLLRegion, keyRegistrar,
-          expirationFutures, expirationExecutor, DEFAULT_REGION_TYPE, redisData);
-      keyRegistrar.register(Coder.stringToByteArrayWrapper(REDIS_DATA_REGION),
-          RedisDataType.REDIS_PROTECTED);
-      keyRegistrar.register(Coder.stringToByteArrayWrapper(HLL_REGION),
-          RedisDataType.REDIS_PROTECTED);
-      keyRegistrar.register(Coder.stringToByteArrayWrapper(STRING_REGION),
-          RedisDataType.REDIS_PROTECTED);
+      regionProvider = new RegionProvider(stringsRegion, keyRegistrar,
+          expirationFutures, expirationExecutor, redisData);
-    checkForRegions();
-  public static final int PROTECTED_KEY_COUNT = 3;
-
-  private void checkForRegions() {
-    Collection<Entry<ByteArrayWrapper, RedisData>> entrySet = keyRegistrar.keyInfos();
-    for (Entry<ByteArrayWrapper, RedisData> entry : entrySet) {
-      ByteArrayWrapper key = entry.getKey();
-      RedisDataType type = entry.getValue().getType();
-      if (!regionProvider.typeUsesDynamicRegions(type)) {
-        continue;
-      }
-      if (cache.getRegion(key.toString()) != null) {
-        // TODO: this seems to be correct (i.e. no need to call createRemoteRegionReferenceLocally
-        // if region already exists).
-        // HOWEVER: createRemoteRegionReferenceLocally ends up doing nothing if the region does not
-        // exist. So this caller of createRemoteRegionReferenceLocally basically does nothing.
-        // createRemoteRegionReferenceLocally might be needed even if the region exists because
-        // local state needs to be initialized (like indexes and queries).
-        continue;
-      }
-      try {
-        regionProvider.createRemoteRegionReferenceLocally(key, type);
-      } catch (Exception e) {
-        // TODO: this eats the exception so if something really is wrong we don't fail but just log.
-        if (logger.errorEnabled()) {
-          logger.error(e);
-        }
-      }
-    }
-  }
-
-   * Takes an entry event and processes it. If the entry denotes that a {@link
-   * RedisDataType#REDIS_LIST} or {@link RedisDataType#REDIS_SORTEDSET} was created then this
-   * function will call the necessary calls to create the parameterized queries for those keys.
-   *
-   * @param event EntryEvent from meta data region
-   */
-  private void afterKeyCreate(EntryEvent<ByteArrayWrapper, RedisData> event) {
-    if (event.isOriginRemote()) {
-      final ByteArrayWrapper key = event.getKey();
-      final RedisData value = event.getNewValue();
-      try {
-        regionProvider.createRemoteRegionReferenceLocally(key, value.getType());
-      } catch (RegionDestroyedException ignore) { // Region already destroyed, ignore
-      }
-    }
-  }
-
-  /**
-   * When a key is removed then this function will make sure the associated queries with the key are
-   * also removed from each vm to avoid unnecessary data retention
-   */
-  private void afterKeyDestroy(EntryEvent<ByteArrayWrapper, RedisData> event) {
-    if (event.isOriginRemote()) {
-      final ByteArrayWrapper key = event.getKey();
-      final RedisData value = event.getOldValue();
-      regionProvider.removeRegionReferenceLocally(key, value.getType());
-    }
-  }
-
-  private class MetaCacheListener extends CacheListenerAdapter<ByteArrayWrapper, RedisData> {
-    @Override
-    public void afterCreate(EntryEvent<ByteArrayWrapper, RedisData> event) {
-      afterKeyCreate(event);
-    }
-
-    @Override
-    public void afterDestroy(EntryEvent<ByteArrayWrapper, RedisData> event) {
-      afterKeyDestroy(event);
-    }
-  }
-
-  /**

DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL42 DEL65 DEL66 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL23 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL66 DEL42 DEL65 DEL66 DEL42 DEL65 DEL66 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL36 DEL33 DEL27 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL40 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL40 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL40 DEL32 DEL21 DEL42 DEL32 DEL21 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL38 DEL18 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL33 DEL27 DEL18 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL12 DEL54 DEL8 DEL70 DEL8 DEL31 DEL66 DEL42 DEL42 DEL67 DEL65 DEL66 DEL42 DEL42 DEL67 DEL65 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL42 DEL32 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL42 DEL32 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL55
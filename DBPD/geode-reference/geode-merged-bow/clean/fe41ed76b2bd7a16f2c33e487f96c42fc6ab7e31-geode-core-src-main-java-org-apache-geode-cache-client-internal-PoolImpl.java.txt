GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

+import static org.apache.commons.lang.StringUtils.isEmpty;
+
+import java.net.InetSocketAddress;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Properties;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
+import org.apache.logging.log4j.Logger;
+
-import org.apache.geode.cache.*;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.CacheClosedException;
+import org.apache.geode.cache.CacheFactory;
+import org.apache.geode.cache.NoSubscriptionServersAvailableException;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.RegionService;
-import org.apache.geode.internal.statistics.DummyStatisticsFactory;
-import org.apache.geode.internal.cache.*;
+import org.apache.geode.internal.cache.EventID;
+import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.cache.PoolFactoryImpl;
+import org.apache.geode.internal.cache.PoolManagerImpl;
+import org.apache.geode.internal.cache.PoolStats;
-import org.apache.logging.log4j.Logger;
-
-import java.net.InetSocketAddress;
-import java.util.*;
-import java.util.Map.Entry;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
+import org.apache.geode.internal.statistics.DummyStatisticsFactory;
+
-  public static final int HANDSHAKE_TIMEOUT =
-      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.HANDSHAKE_TIMEOUT",
-          AcceptorImpl.DEFAULT_HANDSHAKE_TIMEOUT_MS).intValue();
-  public static final long SHUTDOWN_TIMEOUT = Long
-      .getLong(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.SHUTDOWN_TIMEOUT", 30000).longValue();
-  public static final int BACKGROUND_TASK_POOL_SIZE = Integer
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.BACKGROUND_TASK_POOL_SIZE", 20)
-      .intValue();
-  public static final int BACKGROUND_TASK_POOL_KEEP_ALIVE =
-      Integer
-          .getInteger(
-              DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.BACKGROUND_TASK_POOL_KEEP_ALIVE", 1000)
-          .intValue();
-  // For durable client tests only. Connection Sources read this flag
-  // and return an empty list of servers.
+  private static final int HANDSHAKE_TIMEOUT =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.HANDSHAKE_TIMEOUT",
+          AcceptorImpl.DEFAULT_HANDSHAKE_TIMEOUT_MS);
+
+  public static final long SHUTDOWN_TIMEOUT =
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.SHUTDOWN_TIMEOUT", 30000);
+
+  private static final int BACKGROUND_TASK_POOL_SIZE = Integer
+      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.BACKGROUND_TASK_POOL_SIZE", 20);
+
+  private static final int BACKGROUND_TASK_POOL_KEEP_ALIVE = Integer.getInteger(
+      DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.BACKGROUND_TASK_POOL_KEEP_ALIVE", 1000);
+
+  /**
+   * For durable client tests only. Connection Sources read this flag and return an empty list of
+   * servers.
+   */
-      } catch (RuntimeException e2) {
+      } catch (RuntimeException ignore) {
-        : new PoolStats(statFactory,
-            getName() + "->" + (serverGroup == null || serverGroup.equals("") ? "[any servers]"
-                : "[" + getServerGroup() + "]"));
+        : new PoolStats(statFactory, getName() + "->"
+            + (isEmpty(serverGroup) ? "[any servers]" : "[" + getServerGroup() + "]"));
-                .toLocalizedString(Integer.valueOf(cnt)));
+                .toLocalizedString(cnt));
-   * 
-   * @param conn
-      return Collections.EMPTY_MAP;
+      return Collections.emptyMap();
-      return Collections.EMPTY_MAP;
+      return Collections.emptyMap();
-        } catch (ServerConnectivityException expected) {
+        } catch (ServerConnectivityException ignore) {
-    List result = Collections.EMPTY_LIST;
+    List result = Collections.emptyList();
-    List result = Collections.EMPTY_LIST;
+    List result = Collections.emptyList();
-      java.lang.Thread.sleep(this.pingInterval * 2);
-    } catch (java.lang.InterruptedException ex) {
+      Thread.sleep(this.pingInterval * 2);
+    } catch (java.lang.InterruptedException ignore) {
-      java.lang.Thread.sleep(this.pingInterval * 2);
-    } catch (java.lang.InterruptedException ex) {
+      Thread.sleep(this.pingInterval * 2);
+    } catch (java.lang.InterruptedException ignore) {
-      } catch (CancelException e) {
-        // throw e;
+      } catch (CancelException ignore) {
-          logger.debug("Pool task <{}> cancelled", this, logger.isTraceEnabled() ? e : null);
+          logger.debug("Pool task <{}> cancelled", this);
-    ProxyCache proxy = new ProxyCache(props, (GemFireCacheImpl) cache, this);
+    ProxyCache proxy = new ProxyCache(props, (InternalCache) cache, this);
-    Cache cache = GemFireCacheImpl.getInstance();
+    InternalCache cache = GemFireCacheImpl.getInstance();
-      if (cacheCriterion == null) {
-        cacheCriterion = cache.getCancelCriterion();
-      } else if (cacheCriterion != cache.getCancelCriterion()) {
-        /*
-         * If the cache instance has somehow changed, we need to get a reference to the new
-         * criterion. This is pretty unlikely because the cache closes all the pools when it shuts
-         * down, but I wanted to be safe.
-         */
+      if (cacheCriterion == null || cacheCriterion != cache.getCancelCriterion()) {
-      Cache cache = GemFireCacheImpl.getInstance();
+      InternalCache cache = GemFireCacheImpl.getInstance();
-    GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
+    InternalCache cache = GemFireCacheImpl.getInstance();

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 UPD40 INS40 INS40 UPD83 UPD83 UPD83 INS29 MOV32 MOV32 MOV32 MOV32 INS65 UPD42 UPD42 INS66 INS66 MOV43 UPD43 UPD43 INS32 INS32 INS32 INS32 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 MOV43 INS27 UPD43 INS42 INS42 UPD42 UPD43 MOV27 MOV27 UPD42 UPD42 UPD42 INS32 MOV42 UPD42 INS42 MOV42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL33 DEL27 DEL42 DEL45 DEL32 DEL27 DEL42 DEL42 DEL32 DEL42 DEL65 DEL40 DEL40 DEL40 DEL40 DEL40 DEL40 DEL42 DEL42 DEL32 DEL42 DEL33 DEL16 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25
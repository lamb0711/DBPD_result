GEODE-5111: Set offline members to null only when done waiting for them (#1873)

* GEODE-5111: Set offline members to null only when done waiting for them

-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import org.apache.geode.distributed.internal.DistributionConfig;
-import org.apache.geode.distributed.internal.MembershipListener;
-public class PersistenceAdvisorImpl implements PersistenceAdvisor {
+public class PersistenceAdvisorImpl implements InternalPersistenceAdvisor {
+  private static final PersistenceAdvisorObserver DEFAULT_PERSISTENCE_ADVISOR_OBSERVER = s -> {
+  };
+  private static PersistenceAdvisorObserver persistenceAdvisorObserver =
+      DEFAULT_PERSISTENCE_ADVISOR_OBSERVER;
-  protected CacheDistributionAdvisor advisor;
-  private DistributedLockService dl;
-  protected String regionPath;
-  protected PersistentMemberView storage;
-  protected volatile boolean online = false;
-  private volatile Set<PersistentStateListener> listeners = Collections.emptySet();
-  private DiskRegionStats stats;
-  private PersistentMemberManager memberManager;
-  private ProfileChangeListener listener;
+  protected final Object lock;
+
+  protected final CacheDistributionAdvisor cacheDistributionAdvisor;
+  protected final String regionPath;
+  protected final PersistentMemberView persistentMemberView;
+  private final DiskRegionStats diskRegionStats;
+  private final PersistentMemberManager persistentMemberManager;
+  private final ProfileChangeListener profileChangeListener;
+
+  private final Set<PersistentMemberID> recoveredMembers;
+  private final Set<PersistentMemberID> removedMembers = new HashSet<>();
+  private final Set<PersistentMemberID> equalMembers;
+  private final DistributedLockService distributedLockService;
+
+  private volatile boolean holdingTieLock;
+
+  protected volatile boolean online;
+  private volatile Set<PersistentStateListener> persistentStateListeners = Collections.emptySet();
-  private volatile boolean holdingTieLock;
-  private Set<PersistentMemberID> recoveredMembers;
-  private Set<PersistentMemberID> removedMembers = new HashSet<PersistentMemberID>();
-  private Set<PersistentMemberID> equalMembers;
-  private volatile Set<PersistentMemberID> allMembersWaitingFor;
-  private volatile Set<PersistentMemberID> offlineMembersWaitingFor;
-  protected final Object lock;
-  private static PersistenceAdvisorObserver observer = null;
+  protected volatile Set<PersistentMemberID> allMembersWaitingFor;
+  protected volatile Set<PersistentMemberID> offlineMembersWaitingFor;
-  private static final int PERSISTENT_VIEW_RETRY =
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "PERSISTENT_VIEW_RETRY", 5);
-
-  public PersistenceAdvisorImpl(CacheDistributionAdvisor advisor, DistributedLockService dl,
-      PersistentMemberView storage, String regionPath, DiskRegionStats diskStats,
-      PersistentMemberManager memberManager) {
-    this.advisor = advisor;
-    this.dl = dl;
+  public PersistenceAdvisorImpl(CacheDistributionAdvisor cacheDistributionAdvisor,
+      DistributedLockService distributedLockService, PersistentMemberView persistentMemberView,
+      String regionPath, DiskRegionStats diskRegionStats,
+      PersistentMemberManager persistentMemberManager) {
+    this.cacheDistributionAdvisor = cacheDistributionAdvisor;
+    this.distributedLockService = distributedLockService;
-    this.storage = storage;
-    this.stats = diskStats;
-    this.listener = new ProfileChangeListener();
-    this.memberManager = memberManager;
+    this.persistentMemberView = persistentMemberView;
+    this.diskRegionStats = diskRegionStats;
+    profileChangeListener = new ProfileChangeListener();
+    this.persistentMemberManager = persistentMemberManager;
-    // Prevent membership changes while we are persisting the membership view
-    // online. TODO prpersist is this the best thing to sync on?
-    // If we synchronize on something else, we need to be careful about
-    // lock ordering because the membership notifications are called
-    // with the advisor lock held.
-    this.lock = advisor;
+    // Prevent membership changes while we are persisting the membership view online. If we
+    // synchronize on something else, we need to be careful about lock ordering because the
+    // membership notifications are called with the advisor lock held.
+    lock = cacheDistributionAdvisor;
-    // Remember which members we know about because of what
-    // we have persisted
-    // We will later use this to handle updates from peers.
+    // Remember which members we know about because of what we have persisted. We will later use
+    // this to handle updates from peers.
-    // To prevent races if we crash during initialization,
-    // mark equal members as online before we initialize. We will
-    // still report these members as equal, but if we crash and recover
-    // they will no longer be considered equal.
-    equalMembers = new HashSet<PersistentMemberID>(storage.getOfflineAndEqualMembers());
+    // To prevent races if we crash during initialization, mark equal members as online before we
+    // initialize. We will still report these members as equal, but if we crash and recover they
+    // will no longer be considered equal.
+    equalMembers = new HashSet<>(persistentMemberView.getOfflineAndEqualMembers());
-      storage.memberOnline(id);
+      persistentMemberView.memberOnline(id);
+  @Override
-    advisor.addProfileChangeListener(listener);
+    cacheDistributionAdvisor.addProfileChangeListener(profileChangeListener);
-    Set<PersistentMemberPattern> revokedMembers =
-        this.memberManager.addRevocationListener(listener, storage.getRevokedMembers());
+    Set<PersistentMemberPattern> revokedMembers = persistentMemberManager
+        .addRevocationListener(profileChangeListener, persistentMemberView.getRevokedMembers());
-  protected void startMemberLogging() {
-    this.addListener(new PersistentStateListener.PersistentStateAdapter() {
+  private void startMemberLogging() {
+    addListener(new PersistentStateListener.PersistentStateAdapter() {
-          Set<String> onlineMembers = new HashSet<String>();
-          Set<PersistentMemberID> members = new HashSet<PersistentMemberID>();
-          members.addAll(
-              PersistenceAdvisorImpl.this.advisor.adviseInitializedPersistentMembers().values());
+          Set<PersistentMemberID> members =
+              new HashSet<>(cacheDistributionAdvisor.adviseInitializedPersistentMembers().values());
+          Set<String> onlineMembers = new HashSet<>();
-              new Object[] {PersistenceAdvisorImpl.this.regionPath,
+              new Object[] {regionPath,
-  public boolean acquireTieLock() {
-    holdingTieLock = dl.lock("PERSISTENCE_" + regionPath, 0, -1);
-    return holdingTieLock;
-  }
-
-  public void releaseTieLock() {
-    if (holdingTieLock) {
-      dl.unlock("PERSISTENCE_" + regionPath);
-      holdingTieLock = false;
-    }
-  }
-
+  @Override
-
-    PersistentStateQueryResults results =
-        PersistentStateQueryMessage.send(members, advisor.getDistributionManager(), regionPath,
-            storage.getMyPersistentID(), storage.getMyInitializingID());
-
-    return results;
+    return PersistentStateQueryMessage.send(members,
+        cacheDistributionAdvisor.getDistributionManager(), regionPath,
+        persistentMemberView.getMyPersistentID(), persistentMemberView.getMyInitializingID());
+  @Override
-    // If we have a member that is marked as online that
-    // is an older version of the peers id, tell them they are online
-    for (PersistentMemberID online : storage.getOnlineMembers()) {
-      if (online.isOlderOrEqualVersionOf(id)) {
+    // If we have a member that is marked as online that is an older version of the peers id, tell
+    // them they are online
+    for (PersistentMemberID onlineMember : persistentMemberView.getOnlineMembers()) {
+      if (onlineMember.isOlderOrEqualVersionOf(id)) {
-    // If we have a member that is marked as offline that
-    // is a newer version of the peers id, tell them they are online
-    for (PersistentMemberID offline : storage.getOfflineMembers()) {
+    // If we have a member that is marked as offline that is a newer version of the peers id, tell
+    // them they are online
+    for (PersistentMemberID offline : persistentMemberView.getOfflineMembers()) {
-  public void updateMembershipView(InternalDistributedMember replicate,
-      boolean targetReinitializing) {
+  @Override
+  public void updateMembershipView(InternalDistributedMember peer, boolean targetReinitializing) {
-    DistributionManager dm = advisor.getDistributionManager();
-    PersistentMembershipView view =
-        MembershipViewRequest.send(replicate, dm, regionPath, targetReinitializing);
+    DistributionManager dm = cacheDistributionAdvisor.getDistributionManager();
+    PersistentMembershipView peersPersistentMembershipView =
+        MembershipViewRequest.send(peer, dm, regionPath, targetReinitializing);
-          shortDiskStoreId(), regionPath, replicate);
+          shortDiskStoreId(), regionPath, peer);
-          view.getOnlineMembers();
-      Set<PersistentMemberID> peersOfflineMembers = view.getOfflineMembers();
+          peersPersistentMembershipView.getOnlineMembers();
+      Set<PersistentMemberID> peersOfflineMembers =
+          peersPersistentMembershipView.getOfflineMembers();
-                  shortDiskStoreId(), regionPath, id, replicate);
+                  shortDiskStoreId(), regionPath, id, peer);
-            storage.memberOnline(id);
+            persistentMemberView.memberOnline(id);
-          // This method is called before the current member is online.
-          // if the peer knows about a member that the current member doesn't know
-          // about, that means that member must have been added to the DS after
-          // the current member went offline. Therefore, that member is *newer* than
-          // the current member. So mark that member as online (meaning, online later
+          // This method is called before the current member is online. if the peer knows about a
+          // member that the current member doesn't know about, that means that member must have
+          // been added to the DS after the current member went offline. Therefore, that member is
+          // *newer* than the current member. So mark that member as online (meaning, online later
-                  shortDiskStoreId(), regionPath, id, replicate);
+                  shortDiskStoreId(), regionPath, id, peer);
-            storage.memberOnline(id);
+            persistentMemberView.memberOnline(id);
-              shortDiskStoreId(), regionPath, id, replicate);
+              shortDiskStoreId(), regionPath, id, peer);
-        storage.memberRemoved(id);
+        persistentMemberView.memberRemoved(id);
-    // Update the set of revoked members from the peer
-    // This should be called without holding the lock to
-    // avoid deadlocks
-    Set<PersistentMemberPattern> revokedMembers = view.getRevokedMembers();
+    // Update the set of revoked members from the peer. This should be called without holding the
+    // lock to avoid deadlocks
+    Set<PersistentMemberPattern> revokedMembers = peersPersistentMembershipView.getRevokedMembers();
-      memberManager.revokeMember(revoked);
+      persistentMemberManager.revokeMember(revoked);
-  protected boolean isRevoked(PersistentMemberID id) {
-    return memberManager.isRevoked(this.regionPath, id);
+  private boolean isRevoked(PersistentMemberID id) {
+    return persistentMemberManager.isRevoked(regionPath, id);
+  @Override
-      // Transition any members that are marked as online, but not actually
-      // currently running, to offline.
+      // Transition any members that are marked as online, but not actually currently running, to
+      // offline.
-          new HashSet<PersistentMemberID>(storage.getOnlineMembers());
+          new HashSet<>(persistentMemberView.getOnlineMembers());
-        onlineMembers = advisor.adviseInitializedPersistentMembers();
+        onlineMembers = cacheDistributionAdvisor.adviseInitializedPersistentMembers();
-        // Fix for 41100 - If this is an atomic bucket creation, don't
-        // mark our peers, which are concurrently intitializing, as offline
-        // they have the exact same data as we do (none), so we are not
-        // technically "newer," and this avoids a race where both members
-        // can think the other is offline ("older").
-        onlineMembers = advisor.advisePersistentMembers();
+        // Fix for 41100 - If this is an atomic bucket creation, don't mark our peers, which are
+        // concurrently initializing, as offline they have the exact same data as we do (none), so
+        // we are not technically "newer," and this avoids a race where both members can think the
+        // other is offline ("older").
+        onlineMembers = cacheDistributionAdvisor.advisePersistentMembers();
-      // Another fix for 41100
-      // Don't mark equal members as offline if that are currently running.
-      // We don't have newer data than these members
-      // so this is safe, and it it avoids a race where we mark them offline
-      // at this point, and then later they mark us as offline.
+      // Another fix for 41100 - Don't mark equal members as offline if that are currently running.
+      // We don't have newer data than these members so this is safe, and it it avoids a race where
+      // we mark them offline at this point, and then later they mark us as offline.
-        // This is slightly hacky. We're looking for a running member that has
-        // the same disk store as our equal members, because all have is a persistent
-        // id of the equal members. The persistent id of the running member may be
-        // different than what we have marked as equal, because the id in the profile
-        // is the new id for the member.
-        Collection<PersistentMemberID> allMembers = advisor.advisePersistentMembers().values();
-        Set<DiskStoreID> runningDiskStores = new HashSet<DiskStoreID>();
+        // This is slightly hacky. We're looking for a running member that has the same disk store
+        // as our equal members, because all have is a persistent id of the equal members. The
+        // persistent id of the running member may be different than what we have marked as equal,
+        // because the id in the profile is the new id for the member.
+        Collection<PersistentMemberID> allMembers =
+            cacheDistributionAdvisor.advisePersistentMembers().values();
+        Set<DiskStoreID> runningDiskStores = new HashSet<>();
-        for (Iterator<PersistentMemberID> itr = equalMembers.iterator(); itr.hasNext();) {
-          PersistentMemberID id = itr.next();
-          if (!runningDiskStores.contains(id.diskStoreId)) {
-            itr.remove();
-          }
-        }
+        equalMembers.removeIf(id -> !runningDiskStores.contains(id.diskStoreId));
-        storage.memberOffline(id);
+        persistentMemberView.memberOffline(id);
-            shortDiskStoreId(), regionPath, storage.getOnlineMembers(), storage.getOfflineMembers(),
-            equalMembers);
+            shortDiskStoreId(), regionPath, persistentMemberView.getOnlineMembers(),
+            persistentMemberView.getOfflineMembers(), equalMembers);
-      storage.setInitialized();
+      persistentMemberView.setInitialized();
-      removedMembers = Collections.emptySet();
+      removedMembers.clear();
-    if (stats != null) {
-      stats.incInitializations(!didGII);
+    if (diskRegionStats != null) {
+      diskRegionStats.incInitializations(!didGII);
-            advisor.adviseInitializedPersistentMembers();
+            cacheDistributionAdvisor.adviseInitializedPersistentMembers();
+  @Override
-
-    DistributionManager dm = advisor.getDistributionManager();
+    DistributionManager dm = cacheDistributionAdvisor.getDistributionManager();
-    Set profileUpdateRecipients = advisor.adviseProfileUpdate();
-    if (newId == null || (!newId.equals(oldId) && !newId.equals(initializingId))) {
+    Set<InternalDistributedMember> profileUpdateRecipients =
+        cacheDistributionAdvisor.adviseProfileUpdate();
+    if (newId == null || !newId.equals(oldId) && !newId.equals(initializingId)) {
-      // This will only be the case if we crashed
-      // while initializing previously. In the case, we are essentially
-      // finishing what we started by preparing that ID first. This
-      // will remove that ID from the peers.
+      // This will only be the case if we crashed while initializing previously. In the case, we are
+      // essentially finishing what we started by preparing that ID first. This will remove that ID
+      // from the peers.
-        // TODO prpersist - clean this up
-        long viewVersion = advisor.startOperation();
+        long viewVersion = cacheDistributionAdvisor.startOperation();
-            advisor.endOperation(viewVersion);
+            cacheDistributionAdvisor.endOperation(viewVersion);
-      storage.setInitializing(newId);
+      persistentMemberView.setInitializing(newId);
-    profileUpdateRecipients = advisor.adviseProfileUpdate();
+    profileUpdateRecipients = cacheDistributionAdvisor.adviseProfileUpdate();
+  @Override
-    return storage.generatePersistentID();
+    return persistentMemberView.generatePersistentID();
+  @Override
-        advisor.adviseInitializedPersistentMembers();
+        cacheDistributionAdvisor.adviseInitializedPersistentMembers();
-      onlineMembers.put(advisor.getDistributionManager().getDistributionManagerId(), myId);
+      onlineMembers
+          .put(cacheDistributionAdvisor.getDistributionManager().getDistributionManagerId(), myId);
-    PersistentMembershipView view = new PersistentMembershipView(offlineMembers, onlineMembers,
-        memberManager.getRevokedMembers());
-    return view;
+    return new PersistentMembershipView(offlineMembers, onlineMembers,
+        persistentMemberManager.getRevokedMembers());
+  @Override
-    Set<PersistentMemberID> offlineMembers = storage.getOfflineMembers();
-    Set<PersistentMemberID> equalMembers = storage.getOfflineAndEqualMembers();
-    Set<PersistentMemberID> onlineMembers = storage.getOnlineMembers();
-    Set<PersistentMemberID> persistentMembers = new HashSet<PersistentMemberID>();
-    persistentMembers.addAll(offlineMembers);
-    persistentMembers.addAll(equalMembers);
-    persistentMembers.addAll(onlineMembers);
+    Set<PersistentMemberID> persistentMembers = new HashSet<>();
+    persistentMembers.addAll(persistentMemberView.getOfflineMembers());
+    persistentMembers.addAll(persistentMemberView.getOfflineAndEqualMembers());
+    persistentMembers.addAll(persistentMemberView.getOnlineMembers());
+  @Override
+  public boolean checkMyStateOnMembers(Set<InternalDistributedMember> replicates)
+      throws ReplyException {
+    PersistentStateQueryResults remoteStates = getMyStateOnMembers(replicates);
+
+    persistenceAdvisorObserver.observe(regionPath);
+
+    boolean equal = false;
+    for (Map.Entry<InternalDistributedMember, PersistentMemberState> entry : remoteStates.stateOnPeers
+        .entrySet()) {
+      InternalDistributedMember member = entry.getKey();
+      PersistentMemberID remoteId = remoteStates.persistentIds.get(member);
+
+      final PersistentMemberID myId = getPersistentID();
+      PersistentMemberState stateOnPeer = entry.getValue();
+
+      if (PersistentMemberState.REVOKED.equals(stateOnPeer)) {
+        throw new RevokedPersistentDataException(
+            LocalizedStrings.PersistentMemberManager_Member_0_is_already_revoked
+                .toLocalizedString(myId));
+      }
+
+      if (myId != null && stateOnPeer == null) {
+        String message = LocalizedStrings.CreatePersistentRegionProcessor_SPLIT_DISTRIBUTED_SYSTEM
+            .toLocalizedString(regionPath, member, remoteId, myId);
+        throw new ConflictingPersistentDataException(message);
+      }
+
+      if (myId != null && stateOnPeer == PersistentMemberState.EQUAL) {
+        equal = true;
+      }
+
+      // The other member changes its ID when it comes back online.
+      if (remoteId != null) {
+        PersistentMemberState remoteState = getPersistedStateOfMember(remoteId);
+        if (remoteState == PersistentMemberState.OFFLINE) {
+          String message =
+              LocalizedStrings.CreatePersistentRegionProcessor_INITIALIZING_FROM_OLD_DATA
+                  .toLocalizedString(regionPath, member, remoteId, myId);
+          throw new ConflictingPersistentDataException(message);
+        }
+      }
+    }
+    return equal;
+  }
+
+  public static void setPersistenceAdvisorObserver(PersistenceAdvisorObserver o) {
+    persistenceAdvisorObserver = o == null ? DEFAULT_PERSISTENCE_ADVISOR_OBSERVER : o;
+  }
+
+  @Override
-      return storage.getMyPersistentID();
+      return persistentMemberView.getMyPersistentID();
-      boolean foundMember = false;
-      foundMember |= recoveredMembers.remove(persistentID);
+      boolean foundMember = recoveredMembers.remove(persistentID);
-      // Don't persist members as offline until we are online. Otherwise, we may
-      // think we have later data than them during recovery.
+      // Don't persist members as offline until we are online. Otherwise, we may think we have later
+      // data than them during recovery.
-          if (storage.getOfflineAndEqualMembers().contains(persistentID)) {
+          if (persistentMemberView.getOfflineAndEqualMembers().contains(persistentID)) {
-          // Don't mark the member as offline if we have never seen it. If we haven't seen it
-          // that means it's not done initializing yet.
+          // Don't mark the member as offline if we have never seen it. If we haven't seen it that
+          // means it's not done initializing yet.
-              storage.memberOffline(persistentID);
+              persistentMemberView.memberOffline(persistentID);
-            storage.memberOnline(persistentID);
+            persistentMemberView.memberOnline(persistentID);
-    // Persist the revoked member, so if we recover later we will
-    // remember that they were revoked.
-    storage.memberRevoked(pattern);
+    // Persist the revoked member, so if we recover later we will remember that they were revoked.
+    persistentMemberView.memberRevoked(pattern);
-    for (PersistentMemberID id : storage.getOfflineMembers()) {
+    for (PersistentMemberID id : persistentMemberView.getOfflineMembers()) {
-    for (PersistentMemberID id : storage.getOnlineMembers()) {
+    for (PersistentMemberID id : persistentMemberView.getOnlineMembers()) {
-    for (PersistentMemberID id : storage.getOfflineAndEqualMembers()) {
+    for (PersistentMemberID id : persistentMemberView.getOfflineAndEqualMembers()) {
-          storage.memberRemoved(id);
+          persistentMemberView.memberRemoved(id);
-        // Purge any IDs that are old versions of the the id that
-        // we just removed
+        // Purge any IDs that are old versions of the the id that we just removed
-            storage.memberRemoved(persistedId);
+            persistentMemberView.memberRemoved(persistedId);
+  @Override
-    return storage.getMyPersistentID();
+    return persistentMemberView.getMyPersistentID();
+  @Override
-    return storage.getMyInitializingID();
+    return persistentMemberView.getMyInitializingID();
+  @Override
-      HashSet<PersistentStateListener> tmpListeners =
-          new HashSet<PersistentStateListener>(listeners);
+      Set<PersistentStateListener> tmpListeners = new HashSet<>(persistentStateListeners);
-      listeners = Collections.unmodifiableSet(tmpListeners);
+      persistentStateListeners = Collections.unmodifiableSet(tmpListeners);
+  @Override
-      HashSet<PersistentStateListener> tmpListeners =
-          new HashSet<PersistentStateListener>(listeners);
+      Set<PersistentStateListener> tmpListeners = new HashSet<>(persistentStateListeners);
-      listeners = Collections.unmodifiableSet(tmpListeners);
+      persistentStateListeners = Collections.unmodifiableSet(tmpListeners);
-    for (PersistentStateListener listener : listeners) {
+    for (PersistentStateListener listener : persistentStateListeners) {
-    for (PersistentStateListener listener : listeners) {
+    for (PersistentStateListener listener : persistentStateListeners) {
-    for (PersistentStateListener listener : listeners) {
+    for (PersistentStateListener listener : persistentStateListeners) {
-
+  @Override
-    HashSet<PersistentMemberID> members =
-        new HashSet<PersistentMemberID>(storage.getOnlineMembers());
+    HashSet<PersistentMemberID> members = new HashSet<>(persistentMemberView.getOnlineMembers());
+  @Override
-      // Don't prepare the ID if the advisor doesn't have a profile. This prevents
-      // A race with the advisor remove
-      if (!advisor.containsId(sender)) {
+      // Don't prepare the ID if the advisor doesn't have a profile. This prevents a race with the
+      // advisor remove
+      if (!cacheDistributionAdvisor.containsId(sender)) {
-      // Persist new members even if we are not online yet
-      // Two members can become online at once. This way,
-      // they will know about each other.
-      storage.memberOnline(newId);
+      // Persist new members even if we are not online yet. Two members can become online at once.
+      // This way, they will know about each other.
+      persistentMemberView.memberOnline(newId);
-      // The oldId and newId could be the same if the member
-      // is retrying a GII. See bug #42051
+      // The oldId and newId could be the same if the member is retrying a GII. See bug #42051
+  @Override
+  @Override
+  @Override
+  public CacheDistributionAdvisor getCacheDistributionAdvisor() {
+    return cacheDistributionAdvisor;
+  }
+
+  @Override
-    this.allMembersWaitingFor = allMembersToWaitFor;
-    this.offlineMembersWaitingFor = offlineMembersToWaitFor;
+    allMembersWaitingFor = allMembersToWaitFor;
+    offlineMembersWaitingFor = offlineMembersToWaitFor;
-  public boolean checkMyStateOnMembers(Set<InternalDistributedMember> replicates)
-      throws ReplyException {
-    PersistentStateQueryResults remoteStates = getMyStateOnMembers(replicates);
-    boolean equal = false;
-
-    if (observer != null) {
-      observer.observe(regionPath);
-    }
-
-    for (Map.Entry<InternalDistributedMember, PersistentMemberState> entry : remoteStates.stateOnPeers
-        .entrySet()) {
-      InternalDistributedMember member = entry.getKey();
-      PersistentMemberID remoteId = remoteStates.persistentIds.get(member);
-
-      final PersistentMemberID myId = getPersistentID();
-      PersistentMemberState stateOnPeer = entry.getValue();
-
-      if (PersistentMemberState.REVOKED.equals(stateOnPeer)) {
-        throw new RevokedPersistentDataException(
-            LocalizedStrings.PersistentMemberManager_Member_0_is_already_revoked
-                .toLocalizedString(myId));
-      }
-
-      if (myId != null && stateOnPeer == null) {
-        String message = LocalizedStrings.CreatePersistentRegionProcessor_SPLIT_DISTRIBUTED_SYSTEM
-            .toLocalizedString(regionPath, member, remoteId, myId);
-        throw new ConflictingPersistentDataException(message);
-      }
-
-      if (myId != null && stateOnPeer == PersistentMemberState.EQUAL) {
-        equal = true;
-      }
-
-      // TODO prpersist - This check might not help much. The other member changes it's ID when it
-      // comes back online.
-      if (remoteId != null) {
-        PersistentMemberState remoteState = getPersistedStateOfMember(remoteId);
-        if (remoteState == PersistentMemberState.OFFLINE) {
-          String message =
-              LocalizedStrings.CreatePersistentRegionProcessor_INITIALIZING_FROM_OLD_DATA
-                  .toLocalizedString(regionPath, member, remoteId, myId);
-          throw new ConflictingPersistentDataException(message);
-        }
-      }
-    }
-    return equal;
+  @Override
+  public boolean isClosed() {
+    return isClosed;
+
-    long viewVersion = advisor.startOperation();
+    long viewVersion = cacheDistributionAdvisor.startOperation();
-      RemovePersistentMemberMessage.send(advisor.adviseProfileUpdate(),
-          advisor.getDistributionManager(), regionPath, getPersistentID(), getInitializingID());
+      RemovePersistentMemberMessage.send(cacheDistributionAdvisor.adviseProfileUpdate(),
+          cacheDistributionAdvisor.getDistributionManager(), regionPath, getPersistentID(),
+          getInitializingID());
-      storage.finishPendingDestroy();
+      persistentMemberView.finishPendingDestroy();
-        advisor.endOperation(viewVersion);
+        cacheDistributionAdvisor.endOperation(viewVersion);
-  public CacheDistributionAdvisor.InitialImageAdvice getInitialImageAdvice(
-      CacheDistributionAdvisor.InitialImageAdvice previousAdvice, boolean recoverFromDisk) {
-    final boolean isPersistAdvisorDebugEnabled =
-        logger.isDebugEnabled(LogMarker.PERSIST_ADVISOR_VERBOSE);
-
-    MembershipChangeListener listener = new MembershipChangeListener();
-    advisor.addMembershipAndProxyListener(listener);
-    addListener(listener);
-    try {
-      while (true) {
-        Set<PersistentMemberID> previouslyOnlineMembers = getPersistedOnlineOrEqualMembers();
-
-        advisor.getAdvisee().getCancelCriterion().checkCancelInProgress(null);
-        try {
-          InitialImageAdvice advice = advisor.adviseInitialImage(previousAdvice, true);
-
-          if (!advice.getReplicates().isEmpty()) {
-            if (isPersistAdvisorDebugEnabled) {
-              logger.debug(LogMarker.PERSIST_ADVISOR_VERBOSE,
-                  "{}-{}: There are members currently online. Checking for our state on those members and then initializing",
-                  shortDiskStoreId(), regionPath);
-            }
-            // We will go ahead and take the other members contents if we ourselves didn't recover
-            // from disk.
-            if (recoverFromDisk) {
-              // Check with these members to make sure that they
-              // have heard of us
-              // If any of them say we have the same data on disk, we don't need to do a GII
-              if (checkMyStateOnMembers(advice.getReplicates())) {
-                if (isPersistAdvisorDebugEnabled) {
-                  logger.debug(LogMarker.PERSIST_ADVISOR_VERBOSE,
-                      "{}-{}: We have the same data on disk as one of {} recovering gracefully",
-                      shortDiskStoreId(), regionPath, advice.getReplicates());
-                }
-                advice.getReplicates().clear();
-              } else {
-                // If we have to do a GII, we have not equal members anymore.
-                synchronized (lock) {
-                  equalMembers.clear();
-                }
-              }
-            }
-            return advice;
-          } else if (!advice.getNonPersistent().isEmpty()) {
-            // We support a persistent member getting a membership view
-            // from a non persistent member and using that information to wait
-            // for the other known persistent members. See
-            // PersistentRecoveryOrderDUnitTest.testTransmitCrashedMembersWithNonPeristentRegion
-            updateViewFromNonPersistent(recoverFromDisk, advice);
-            previouslyOnlineMembers = getPersistedOnlineOrEqualMembers();
-          }
-
-          // Fix for 51698 - If there are online members that we previously
-          // failed to get a GII from, retry those members rather than wait
-          // for new persistent members to recover.
-          if (previousAdvice != null && !previousAdvice.getReplicates().isEmpty()) {
-            logger.info(
-                LocalizedMessage.create(LocalizedStrings.PersistenceAdvisorImpl_RETRYING_GII));
-            previousAdvice = null;
-            continue;
-          }
-
-          // If there are no currently online members, and no
-          // previously online members, this member should just go with what's
-          // on it's own disk
-          if (previouslyOnlineMembers.isEmpty()) {
-            if (isPersistAdvisorDebugEnabled) {
-              logger.debug(LogMarker.PERSIST_ADVISOR_VERBOSE,
-                  "{}-{}: No previously online members. Recovering with the data from the local disk",
-                  shortDiskStoreId(), regionPath);
-            }
-            return advice;
-          }
-
-
-          Set<PersistentMemberID> offlineMembers = new HashSet<PersistentMemberID>();
-          Set<PersistentMemberID> membersToWaitFor =
-              getMembersToWaitFor(previouslyOnlineMembers, offlineMembers);
-
-          if (membersToWaitFor.isEmpty()) {
-            if (isPersistAdvisorDebugEnabled) {
-              logger.debug(LogMarker.PERSIST_ADVISOR_VERBOSE,
-                  "{}-{}: All of the previously online members are now online and waiting for us. Acquiring tie lock. Previously online members {}",
-                  shortDiskStoreId(), regionPath, advice.getReplicates());
-            }
-            // We're tied for the latest copy of the data. try to get the distributed lock.
-            if (acquireTieLock()) {
-              advice = advisor.adviseInitialImage(previousAdvice, true);
-              if (isPersistAdvisorDebugEnabled) {
-                logger.debug(LogMarker.PERSIST_ADVISOR_VERBOSE,
-                    "{}-{}: Acquired the lock. This member will initialize", shortDiskStoreId(),
-                    regionPath);
-              }
-              if (!advice.getReplicates().isEmpty()) {
-                if (isPersistAdvisorDebugEnabled) {
-                  logger.debug(LogMarker.PERSIST_ADVISOR_VERBOSE,
-                      "{}-{}: Another member has initialized while we were getting the lock. We will initialize from that member",
-                      shortDiskStoreId(), regionPath);
-                }
-                checkMyStateOnMembers(advice.getReplicates());
-              }
-              return advice;
-            } else {
-              if (isPersistAdvisorDebugEnabled) {
-                logger.debug(LogMarker.PERSIST_ADVISOR_VERBOSE,
-                    "{}-{}: Failed to acquire the lock.", shortDiskStoreId(), regionPath);
-              }
-            }
-          } else {
-            if (isPersistAdvisorDebugEnabled) {
-              logger.debug(LogMarker.PERSIST_ADVISOR_VERBOSE,
-                  "{}-{}: Going to wait for these member ids: {}", shortDiskStoreId(), regionPath,
-                  membersToWaitFor);
-            }
-          }
-
-          beginWaitingForMembershipChange(membersToWaitFor);
-          try {
-            // The persistence advisor needs to know which members are really not available
-            // because the user uses this information to decide which members they
-            // haven't started yet. membersToWaitFor includes members that
-            // are still waiting to start up, but are waiting for members other than
-            // the current member. So we pass the set of offline members here
-            listener.waitForChange(membersToWaitFor, offlineMembers);
-          } finally {
-            endWaitingForMembershipChange();
-          }
-        } catch (InterruptedException e) {
-          logger.debug("Interrupted while trying to determine latest persisted copy: {}",
-              e.getMessage(), e);
-        }
-      }
-    } finally {
-      advisor.removeMembershipAndProxyListener(listener);
-      removeListener(listener);
-    }
-  }
-
-  public void updateViewFromNonPersistent(boolean recoverFromDisk, InitialImageAdvice advice) {
-    for (InternalDistributedMember replicate : advice.getNonPersistent()) {
-      try {
-        updateMembershipView(replicate, recoverFromDisk);
-        return;
-      } catch (ReplyException e) {
-        if (logger.isDebugEnabled(LogMarker.PERSIST_ADVISOR_VERBOSE)) {
-          logger.debug(LogMarker.PERSIST_ADVISOR_VERBOSE, "Failed to update membership view", e);
-        }
-      }
-    }
+  @Override
+  public InitialImageAdvice getInitialImageAdvice(InitialImageAdvice previousAdvice,
+      boolean hasDiskImageToRecoverFrom) {
+    PersistenceInitialImageAdvisor piia = new PersistenceInitialImageAdvisor(this,
+        shortDiskStoreId(), regionPath, cacheDistributionAdvisor, hasDiskImageToRecoverFrom);
+    return piia.getAdvice(previousAdvice);
+  @Override
-      throws ReplyException, InterruptedException {
+      throws ReplyException {
-    Set<PersistentMemberID> membersToWaitFor =
-        new HashSet<PersistentMemberID>(previouslyOnlineMembers);
+    Set<PersistentMemberID> membersToWaitFor = new HashSet<>(previouslyOnlineMembers);
-      Set<InternalDistributedMember> members = advisor.adviseProfileUpdate();
-      Set<InternalDistributedMember> membersHostingThisRegion = advisor.adviseGeneric();
+      Set<InternalDistributedMember> members = cacheDistributionAdvisor.adviseProfileUpdate();
+      Set<InternalDistributedMember> membersHostingThisRegion =
+          cacheDistributionAdvisor.adviseGeneric();
-          advisor.getDistributionManager(), regionPath, myPersistentID, myInitializingId);
+          cacheDistributionAdvisor.getDistributionManager(), regionPath, myPersistentID,
+          myInitializingId);
-      // iterate through all of the peers. For each peer:
-      // if the guy was previously online according to us, grab it's online
-      // members and add them to the members to wait for set.
-      // We may need to do this several times until we discover all of the
-      // members that may have newer data than
-      // us,
+      // iterate through all of the peers. For each peer: if the guy was previously online according
+      // to us, grab its online members and add them to the members to wait for set. We may need to
+      // do this several times until we discover all of the members that may have newer data than
+      // us.
-                  && !storage.getOfflineMembers().contains(peerOnlineMember)) {
+                  && !persistentMemberView.getOfflineMembers().contains(peerOnlineMember)) {
-                  storage.memberOnline(peerOnlineMember);
+                  persistentMemberView.memberOnline(peerOnlineMember);
-        // If the peer thinks we are newer or equal to them, we don't
-        // need to wait for this peer.
+        // If the peer thinks we are newer or equal to them, we don't need to wait for this peer.
-        // If the peer thinks we are newer or equal to them, we don't
-        // need to wait for this peer.
+        // If the peer thinks we are newer or equal to them, we don't need to wait for this peer.
-        // If we were able to determine what disk store this member
-        // is in, and it doesn't have a persistent ID, but we think
-        // we should be waiting for it, stop waiting for it.
+        // If we were able to determine what disk store this member is in, and it doesn't have a
+        // persistent ID, but we think we should be waiting for it, stop waiting for it.
-  protected void beginWaitingForMembershipChange(Set<PersistentMemberID> membersToWaitFor) {
-    // do nothing
-  }
-
-  protected void endWaitingForMembershipChange() {
-    // do nothing
-  }
-
+  @Override
-  protected void logWaitingForMember(Set<PersistentMemberID> allMembersToWaitFor,
-      Set<PersistentMemberID> offlineMembersToWaitFor) {
-    Set<String> membersToWaitForLogEntries = new HashSet<String>();
+  @Override
+  public void logWaitingForMembers() {
+    Set<String> membersToWaitForLogEntries = new HashSet<>();
-    if (offlineMembersToWaitFor != null && !offlineMembersToWaitFor.isEmpty()) {
-      TransformUtils.transform(offlineMembersToWaitFor, membersToWaitForLogEntries,
+    if (offlineMembersWaitingFor != null && !offlineMembersWaitingFor.isEmpty()) {
+      TransformUtils.transform(offlineMembersWaitingFor, membersToWaitForLogEntries,
-          LocalizedStrings.CreatePersistentRegionProcessor_WAITING_FOR_LATEST_MEMBER,
-          new Object[] {regionPath,
-              TransformUtils.persistentMemberIdToLogEntryTransformer.transform(getPersistentID()),
-              membersToWaitForLogEntries});
+          LocalizedStrings.CreatePersistentRegionProcessor_WAITING_FOR_LATEST_MEMBER, regionPath,
+          TransformUtils.persistentMemberIdToLogEntryTransformer.transform(getPersistentID()),
+          membersToWaitForLogEntries);
-      TransformUtils.transform(allMembersToWaitFor, membersToWaitForLogEntries,
+      TransformUtils.transform(allMembersWaitingFor, membersToWaitForLogEntries,
-          new Object[] {regionPath,
-              TransformUtils.persistentMemberIdToLogEntryTransformer.transform(getPersistentID()),
-              membersToWaitForLogEntries});
+          regionPath,
+          TransformUtils.persistentMemberIdToLogEntryTransformer.transform(getPersistentID()),
+          membersToWaitForLogEntries);
-  protected void checkInterruptedByShutdownAll() {}
-
-  protected class MembershipChangeListener implements MembershipListener, PersistentStateListener {
-
-    private boolean warned = false;
-    private final long warningTime;
-
-    public MembershipChangeListener() {
-      long waitThreshold = advisor.getDistributionManager().getConfig().getAckWaitThreshold();
-      warningTime = System.nanoTime() + TimeUnit.SECONDS.toNanos(waitThreshold);
+  @Override
+  public void clearEqualMembers() {
+    synchronized (lock) {
+      equalMembers.clear();
+  }
-    private boolean membershipChanged = false;
+  @Override
+  public void checkInterruptedByShutdownAll() {}
-    public void waitForChange(Set<PersistentMemberID> allMembersToWaitFor,
-        Set<PersistentMemberID> offlineMembersToWaitFor) throws InterruptedException {
-      synchronized (this) {
-        try {
-          setWaitingOnMembers(allMembersToWaitFor, offlineMembersToWaitFor);
-          long exitTime = System.nanoTime() + TimeUnit.SECONDS.toNanos(PERSISTENT_VIEW_RETRY);
-          while (!membershipChanged && !isClosed) {
-            checkInterruptedByShutdownAll();
-            advisor.getAdvisee().getCancelCriterion().checkCancelInProgress(null);
-            this.wait(100);
-            long time = System.nanoTime();
+  @Override
+  public void close() {
+    isClosed = true;
+    persistentMemberManager.removeRevocationListener(profileChangeListener);
+    cacheDistributionAdvisor.removeProfileChangeListener(profileChangeListener);
+    releaseTieLock();
+  }
-            // Fix for #50415 go out and message other members to see if there
-            // status has changed. This handles any case where we might have
-            // missed a notification due to concurrent startup.
-            if (time > exitTime) {
-              break;
-            }
-            if (!warned && time > warningTime) {
-
-              logWaitingForMember(allMembersToWaitFor, offlineMembersToWaitFor);
-
-              warned = true;
-            }
-          }
-          this.membershipChanged = false;
-        } finally {
-          setWaitingOnMembers(null, null);
-        }
+  /**
+   * Try to acquire the distributed lock which members must grab for in the case of a tie. Whoever
+   * gets the lock initializes first.
+   */
+  @Override
+  public boolean acquireTieLock() {
+    // We're tied for the latest copy of the data. try to get the distributed lock.
+    holdingTieLock = distributedLockService.lock("PERSISTENCE_" + regionPath, 0, -1);
+    if (!holdingTieLock) {
+      if (logger.isDebugEnabled(LogMarker.PERSIST_ADVISOR_VERBOSE)) {
+        logger.debug(LogMarker.PERSIST_ADVISOR_VERBOSE, "{}-{}: Failed to acquire the lock.",
+            shortDiskStoreId(), regionPath);
+    return holdingTieLock;
+  }
-    public void memberJoined(DistributionManager distributionManager,
-        InternalDistributedMember id) {
-      afterMembershipChange();
+  @Override
+  public void releaseTieLock() {
+    if (holdingTieLock) {
+      distributedLockService.unlock("PERSISTENCE_" + regionPath);
+      holdingTieLock = false;
+  }
-    private void afterMembershipChange() {
-      synchronized (this) {
-        this.membershipChanged = true;
-        this.notifyAll();
-      }
+  private boolean wasAboutToDestroy() {
+    return persistentMemberView.wasAboutToDestroy()
+        || persistentMemberView.wasAboutToDestroyDataStorage();
+  }
+
+  protected synchronized void resetState() {
+    online = false;
+    removedMembers.clear();
+  }
+
+  public void flushMembershipChanges() {
+    try {
+      cacheDistributionAdvisor.waitForCurrentOperations();
+    } catch (RegionDestroyedException ignored) {
+  }
-    public void memberDeparted(DistributionManager distributionManager,
-        InternalDistributedMember id, boolean crashed) {
-      afterMembershipChange();
+  @Override
+  public void persistMembersOfflineAndEqual(
+      Map<InternalDistributedMember, PersistentMemberID> map) {
+    for (PersistentMemberID persistentID : map.values()) {
+      persistentMemberView.memberOfflineAndEqual(persistentID);
+  }
-    public void memberSuspect(DistributionManager distributionManager, InternalDistributedMember id,
-        InternalDistributedMember whoSuspected, String reason) {}
+  @Override
+  public DiskStoreID getDiskStoreID() {
+    return persistentMemberView.getDiskStoreID();
+  }
-    @Override
-    public void quorumLost(DistributionManager distributionManager,
-        Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {}
+  @Override
+  public boolean isOnline() {
+    return online;
+  }
-    public void memberOffline(InternalDistributedMember member, PersistentMemberID persistentID) {
-      afterMembershipChange();
-    }
-
-    public void memberOnline(InternalDistributedMember member, PersistentMemberID persistentID) {
-      afterMembershipChange();
-    }
-
-    public void memberRemoved(PersistentMemberID id, boolean revoked) {
-      afterMembershipChange();
-    }
+  public interface PersistenceAdvisorObserver {
+    void observe(String regionPath);
+    @Override
-    public void profileRemoved(Profile profile, boolean regionDestroyed) {
+    @Override
+    public void profileRemoved(Profile profile, boolean destroyed) {
-        if (regionDestroyed) {
+        if (destroyed) {
+    @Override
+    @Override
+    @Override
+    @Override
-
-  public void close() {
-    isClosed = true;
-    memberManager.removeRevocationListener(listener);
-    advisor.removeProfileChangeListener(listener);
-    releaseTieLock();
-  }
-
-  private boolean wasAboutToDestroy() {
-    return storage.wasAboutToDestroy() || storage.wasAboutToDestroyDataStorage();
-  }
-
-  protected synchronized void resetState() {
-    this.online = false;
-    this.removedMembers = new HashSet<PersistentMemberID>();
-  }
-
-  public void flushMembershipChanges() {
-    try {
-      advisor.waitForCurrentOperations();
-    } catch (RegionDestroyedException e) {
-      // continue with the next region
-    }
-
-  }
-
-  public void persistMembersOfflineAndEqual(
-      Map<InternalDistributedMember, PersistentMemberID> map) {
-    for (PersistentMemberID persistentID : map.values()) {
-      storage.memberOfflineAndEqual(persistentID);
-    }
-  }
-
-  public DiskStoreID getDiskStoreID() {
-    return storage.getDiskStoreID();
-  }
-
-  public boolean isOnline() {
-    return online;
-  }
-
-  public interface PersistenceAdvisorObserver {
-    default void observe(String regionPath) {}
-  }
-
-  public static void setPersistenceAdvisorObserver(PersistenceAdvisorObserver o) {
-    observer = o;
-  }

MOV23 MOV23 MOV23 MOV23 MOV23 MOV23 MOV23 MOV23 MOV23 MOV31 MOV31 MOV31 MOV31 MOV55 UPD43 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 UPD42 UPD83 INS83 INS83 INS43 INS59 INS83 MOV43 INS83 MOV43 INS83 UPD83 MOV43 INS83 INS83 INS83 INS83 INS83 INS83 UPD83 MOV43 UPD83 UPD83 UPD39 UPD83 UPD83 INS78 UPD83 INS78 INS78 INS78 UPD83 INS78 INS78 INS78 INS78 INS78 MOV83 MOV74 MOV42 INS8 INS78 INS83 INS83 INS39 INS42 MOV44 INS8 INS78 MOV70 MOV70 INS78 MOV43 INS78 MOV43 INS78 UPD42 MOV44 INS78 UPD42 MOV44 INS78 INS78 INS78 INS78 INS78 INS83 INS43 INS42 INS8 INS78 INS78 INS83 INS39 INS42 INS8 INS78 MOV43 INS8 INS78 INS78 INS78 UPD83 MOV83 MOV39 UPD42 MOV42 MOV8 INS78 MOV83 MOV39 INS42 MOV8 INS78 MOV83 MOV39 INS42 MOV8 INS78 MOV83 MOV39 MOV42 MOV8 INS29 INS78 INS78 INS78 INS78 INS78 INS42 INS42 INS86 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS41 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS41 INS42 MOV60 INS21 INS21 MOV21 MOV41 INS42 MOV21 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS41 INS42 INS42 INS41 INS42 MOV43 UPD42 INS60 INS41 INS42 MOV60 INS42 INS42 INS42 INS42 INS42 INS65 INS42 INS25 INS42 INS42 INS42 INS42 INS78 INS78 INS78 INS78 INS78 MOV78 INS59 INS8 UPD74 INS32 MOV32 MOV70 MOV74 INS14 INS32 INS32 INS7 UPD42 UPD42 UPD42 MOV74 MOV59 INS42 INS42 INS43 INS59 INS32 MOV60 INS66 INS66 INS38 INS8 INS32 INS42 INS42 UPD42 INS42 INS42 INS42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 INS42 UPD42 UPD42 UPD42 MOV42 MOV42 MOV42 MOV32 MOV42 MOV32 MOV32 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 MOV27 UPD42 MOV43 MOV42 MOV42 MOV32 UPD42 INS14 INS42 INS42 INS32 INS42 INS42 INS32 INS32 UPD42 INS42 INS16 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV21 MOV21 UPD42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS14 UPD42 MOV42 UPD42 MOV42 MOV42 UPD42 INS14 UPD42 UPD42 UPD42 UPD42 INS42 INS25 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD74 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV44 MOV32 MOV44 INS42 MOV44 UPD42 INS32 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 INS74 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 INS27 INS42 INS42 INS74 UPD74 INS59 UPD74 INS32 UPD42 INS43 INS52 MOV32 INS42 INS42 INS42 INS74 INS42 UPD74 UPD42 UPD42 MOV32 MOV8 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 UPD42 UPD42 INS21 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS43 INS42 INS33 UPD42 MOV32 INS43 INS43 UPD42 UPD43 INS42 INS14 UPD42 INS42 INS42 UPD42 UPD42 UPD42 MOV42 INS43 UPD42 UPD42 UPD42 UPD42 INS42 MOV32 INS42 UPD42 INS42 MOV32 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV32 UPD74 INS32 INS42 INS42 INS42 UPD74 UPD42 UPD42 UPD74 MOV74 INS42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS86 UPD42 UPD42 UPD42 UPD42 MOV60 UPD42 UPD42 UPD74 INS59 MOV38 UPD42 UPD42 UPD42 UPD42 MOV32 UPD42 UPD42 MOV42 UPD42 MOV74 MOV74 MOV32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD74 INS32 UPD74 INS32 INS42 UPD45 MOV32 UPD42 UPD45 UPD42 UPD42 INS42 INS42 INS42 UPD42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL59 DEL39 DEL9 DEL42 DEL43 DEL33 DEL83 DEL42 DEL42 DEL40 DEL45 DEL27 DEL34 DEL32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL43 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL41 DEL42 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL42 DEL32 DEL7 DEL43 DEL36 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL41 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL9 DEL42 DEL7 DEL21 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL14 DEL59 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL40 DEL43 DEL40 DEL43 DEL83 DEL39 DEL42 DEL42 DEL42 DEL40 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL9 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL33 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL40 DEL45 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL40 DEL45 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL41 DEL8 DEL42 DEL42 DEL32 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL32 DEL38 DEL27 DEL42 DEL42 DEL42 DEL42 DEL40 DEL32 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL18 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL40 DEL45 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL25 DEL42 DEL43 DEL43 DEL74 DEL42 DEL43 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL40 DEL45 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL32 DEL42 DEL9 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL40 DEL45 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL40 DEL45 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL42 DEL25 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL40 DEL45 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL61 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL41 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL40 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL12 DEL54 DEL8 DEL70 DEL8 DEL31 DEL42 DEL43 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL8 DEL31 DEL83 DEL39 DEL42 DEL8 DEL31 DEL42 DEL43 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL42 DEL32 DEL21 DEL83 DEL39 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL31 DEL83 DEL39 DEL42 DEL8 DEL31 DEL83 DEL42 DEL42 DEL43 DEL42 DEL43 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL42 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL27 DEL7 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL52 DEL42 DEL42 DEL42 DEL32 DEL21 DEL39 DEL42 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL38 DEL42 DEL38 DEL27 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL33 DEL32 DEL21 DEL52 DEL42 DEL34 DEL32 DEL21 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL10 DEL8 DEL25 DEL42 DEL38 DEL42 DEL42 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL61 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL8 DEL42 DEL33 DEL33 DEL32 DEL21 DEL8 DEL54 DEL8 DEL51 DEL8 DEL31 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL52 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL52 DEL42 DEL32 DEL21 DEL8 DEL51 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL21 DEL8 DEL31 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL32 DEL21 DEL8 DEL31 DEL55 DEL83 DEL39 DEL31 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL7 DEL83 DEL8 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL7 DEL21 DEL8 DEL31
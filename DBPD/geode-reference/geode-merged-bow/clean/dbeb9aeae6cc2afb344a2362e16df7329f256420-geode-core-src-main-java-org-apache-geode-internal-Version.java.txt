Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * There are dependencies in versioning code that require newer versions
- * to have ordinals higher than older versions in order to protect against
- * deserialization problems.  Client/server code also uses greater-than
- * comparison of ordinals in backward-compatibility checks.
+ * There are dependencies in versioning code that require newer versions to have ordinals higher
+ * than older versions in order to protect against deserialization problems. Client/server code also
+ * uses greater-than comparison of ordinals in backward-compatibility checks.
-  
+
-  
+
-   * Set to non-null if the underlying GemFire version is different from product
-   * version
+   * Set to non-null if the underlying GemFire version is different from product version
-  public static final int HIGHEST_VERSION = 45;
+  public static final int HIGHEST_VERSION = 50;
-  private static final Version[] VALUES = new Version[HIGHEST_VERSION+1];
+  private static final Version[] VALUES = new Version[HIGHEST_VERSION + 1];
-   * Reserved token that cannot be used for product version but as a flag in
-   * internal contexts.
+   * Reserved token that cannot be used for product version but as a flag in internal contexts.
-  public static final Version TOKEN = new Version("", "TOKEN", (byte)-1, (byte)0,
-      (byte)0, (byte)0, TOKEN_ORDINAL);
+  public static final Version TOKEN =
+      new Version("", "TOKEN", (byte) -1, (byte) 0, (byte) 0, (byte) 0, TOKEN_ORDINAL);
-  public static final Version GFE_56 = new Version("GFE", "5.6", (byte)5, (byte)6,
-      (byte)0, (byte)0, GFE_56_ORDINAL);
+  public static final Version GFE_56 =
+      new Version("GFE", "5.6", (byte) 5, (byte) 6, (byte) 0, (byte) 0, GFE_56_ORDINAL);
-  public static final Version GFE_57 = new Version("GFE", "5.7", (byte)5, (byte)7,
-      (byte)0, (byte)0, GFE_57_ORDINAL);
+  public static final Version GFE_57 =
+      new Version("GFE", "5.7", (byte) 5, (byte) 7, (byte) 0, (byte) 0, GFE_57_ORDINAL);
-  public static final Version GFE_58 = new Version("GFE", "5.8", (byte)5, (byte)8,
-      (byte)0, (byte)0, GFE_58_ORDINAL);
+  public static final Version GFE_58 =
+      new Version("GFE", "5.8", (byte) 5, (byte) 8, (byte) 0, (byte) 0, GFE_58_ORDINAL);
-  public static final Version GFE_603 = new Version("GFE", "6.0.3", (byte)6,
-      (byte)0, (byte)3, (byte)0, GFE_603_ORDINAL);
+  public static final Version GFE_603 =
+      new Version("GFE", "6.0.3", (byte) 6, (byte) 0, (byte) 3, (byte) 0, GFE_603_ORDINAL);
-  public static final Version GFE_61 = new Version("GFE", "6.1", (byte)6, (byte)1,
-      (byte)0, (byte)0, GFE_61_ORDINAL);
+  public static final Version GFE_61 =
+      new Version("GFE", "6.1", (byte) 6, (byte) 1, (byte) 0, (byte) 0, GFE_61_ORDINAL);
-  public static final Version GFE_65 = new Version("GFE", "6.5", (byte)6, (byte)5,
-      (byte)0, (byte)0, GFE_65_ORDINAL);
+  public static final Version GFE_65 =
+      new Version("GFE", "6.5", (byte) 6, (byte) 5, (byte) 0, (byte) 0, GFE_65_ORDINAL);
-  public static final Version GFE_651 = new Version("GFE", "6.5.1", (byte)6,
-      (byte)5, (byte)1, (byte)0, GFE_651_ORDINAL);
+  public static final Version GFE_651 =
+      new Version("GFE", "6.5.1", (byte) 6, (byte) 5, (byte) 1, (byte) 0, GFE_651_ORDINAL);
-  public static final Version GFE_6516 = new Version("GFE", "6.5.1.6", (byte)6,
-      (byte)5, (byte)1, (byte)6, GFE_6516_ORDINAL);
+  public static final Version GFE_6516 =
+      new Version("GFE", "6.5.1.6", (byte) 6, (byte) 5, (byte) 1, (byte) 6, GFE_6516_ORDINAL);
-  public static final Version GFE_66 = new Version("GFE", "6.6", (byte)6, (byte)6,
-      (byte)0, (byte)0, GFE_66_ORDINAL);
+  public static final Version GFE_66 =
+      new Version("GFE", "6.6", (byte) 6, (byte) 6, (byte) 0, (byte) 0, GFE_66_ORDINAL);
-  public static final Version GFE_662 = new Version("GFE", "6.6.2", (byte)6,
-      (byte)6, (byte)2, (byte)0, GFE_662_ORDINAL);
+  public static final Version GFE_662 =
+      new Version("GFE", "6.6.2", (byte) 6, (byte) 6, (byte) 2, (byte) 0, GFE_662_ORDINAL);
-  public static final Version GFE_6622 = new Version("GFE", "6.6.2.2", (byte)6,
-      (byte)6, (byte)2, (byte)2, GFE_6622_ORDINAL);
+  public static final Version GFE_6622 =
+      new Version("GFE", "6.6.2.2", (byte) 6, (byte) 6, (byte) 2, (byte) 2, GFE_6622_ORDINAL);
-  public static final Version GFE_70 = new Version("GFE", "7.0", (byte)7, (byte)0,
-      (byte)0, (byte)0, GFE_70_ORDINAL);
+  public static final Version GFE_70 =
+      new Version("GFE", "7.0", (byte) 7, (byte) 0, (byte) 0, (byte) 0, GFE_70_ORDINAL);
-  public static final Version GFE_701 = new Version("GFE", "7.0.1", (byte)7,
-      (byte)0, (byte)1, (byte)0, GFE_701_ORDINAL);
+  public static final Version GFE_701 =
+      new Version("GFE", "7.0.1", (byte) 7, (byte) 0, (byte) 1, (byte) 0, GFE_701_ORDINAL);
-  public static final Version GFE_7099 = new Version("GFE", "7.0.99", (byte)7,
-          (byte)0, (byte)99, (byte)0, GFE_7099_ORDINAL);
+  public static final Version GFE_7099 =
+      new Version("GFE", "7.0.99", (byte) 7, (byte) 0, (byte) 99, (byte) 0, GFE_7099_ORDINAL);
-  public static final Version GFE_71 = new Version("GFE", "7.1", (byte)7,
-      (byte)1, (byte)0, (byte)0, GFE_71_ORDINAL);
+  public static final Version GFE_71 =
+      new Version("GFE", "7.1", (byte) 7, (byte) 1, (byte) 0, (byte) 0, GFE_71_ORDINAL);
-  
+
-  public static final Version GFE_80 = new Version("GFE", "8.0", (byte)8,
-      (byte)0, (byte)0, (byte)0, GFE_80_ORDINAL);
-  
+  public static final Version GFE_80 =
+      new Version("GFE", "8.0", (byte) 8, (byte) 0, (byte) 0, (byte) 0, GFE_80_ORDINAL);
+
-  
+
-  public static final Version GFE_8009 = new Version("GFE", "8.0.0.9", (byte)8,
-      (byte)0, (byte)0, (byte)9, GFE_8009_ORDINAL);
+  public static final Version GFE_8009 =
+      new Version("GFE", "8.0.0.9", (byte) 8, (byte) 0, (byte) 0, (byte) 9, GFE_8009_ORDINAL);
-  public static final Version GFE_81 = new Version("GFE", "8.1", (byte)8,
-      (byte)1, (byte)0, (byte)0, GFE_81_ORDINAL);
-  
+  public static final Version GFE_81 =
+      new Version("GFE", "8.1", (byte) 8, (byte) 1, (byte) 0, (byte) 0, GFE_81_ORDINAL);
+
-  public static final Version GFE_82 = new Version("GFE", "8.2", (byte)8,
-      (byte)2, (byte)0, (byte)0, GFE_82_ORDINAL);
+  public static final Version GFE_82 =
+      new Version("GFE", "8.2", (byte) 8, (byte) 2, (byte) 0, (byte) 0, GFE_82_ORDINAL);
-  public static final Version GFE_90 = new Version("GFE", "9.0", (byte)9,
-      (byte)0, (byte)0, (byte)0, GFE_90_ORDINAL);
+  public static final Version GFE_90 =
+      new Version("GFE", "9.0", (byte) 9, (byte) 0, (byte) 0, (byte) 0, GFE_90_ORDINAL);
+
+  private static final byte GFE_91_ORDINAL = 50;
+
+  public static final Version GFE_91 =
+      new Version("GFE", "9.1", (byte) 9, (byte) 1, (byte) 0, (byte) 0, GFE_91_ORDINAL);
-   * This constant must be set to the most current version of the product.
-   * !!! NOTE: update HIGHEST_VERSION when changing CURRENT !!!
+   * This constant must be set to the most current version of the product. !!! NOTE: update
+   * HIGHEST_VERSION when changing CURRENT !!!
-  public static final Version CURRENT = GFE_90;
+  public static final Version CURRENT = GFE_91;
- /**
-  * version ordinal for test Backward compatibility.
-  */  
+  /**
+   * version ordinal for test Backward compatibility.
+   */
-  public static final Version TEST_VERSION = new Version("TEST", "VERSION",
-      (byte)0, (byte)0, (byte)0, (byte)0, validOrdinalForTesting);
-  
+  public static final Version TEST_VERSION = new Version("TEST", "VERSION", (byte) 0, (byte) 0,
+      (byte) 0, (byte) 0, validOrdinalForTesting);
+
-  private Version(String product, String name, byte major, byte minor, byte release,
-      byte patch, byte ordinal) {
+  private Version(String product, String name, byte major, byte minor, byte release, byte patch,
+      byte ordinal) {
-    this.methodSuffix = this.productName + "_"+ this.majorVersion + "_" + this.minorVersion 
-        + "_" + this.release + "_" + this.patch;
+    this.methodSuffix = this.productName + "_" + this.majorVersion + "_" + this.minorVersion + "_"
+        + this.release + "_" + this.patch;
-   * Creates a new instance of <code>Version</code> with a different underlying
-   * GemFire version
+   * Creates a new instance of <code>Version</code> with a different underlying GemFire version
-  private Version(String product, String name, byte major, byte minor, byte release,
-      byte patch, byte ordinal, Version gemfireVersion) {
+  private Version(String product, String name, byte major, byte minor, byte release, byte patch,
+      byte ordinal, Version gemfireVersion) {
-    if (ordinal == NOT_SUPPORTED_ORDINAL){
+    if (ordinal == NOT_SUPPORTED_ORDINAL) {
-      throw new UnsupportedVersionException(
-          LocalizedStrings.Version_REMOTE_VERSION_NOT_SUPPORTED
-              .toLocalizedString(ordinal, CURRENT.name));
+      throw new UnsupportedVersionException(LocalizedStrings.Version_REMOTE_VERSION_NOT_SUPPORTED
+          .toLocalizedString(ordinal, CURRENT.name));
-   * return the version corresponding to the given ordinal, or CURRENT
-   * if the ordinal isn't valid
+   * return the version corresponding to the given ordinal, or CURRENT if the ordinal isn't valid
-   * Write the given ordinal (result of {@link #ordinal()}) to given
-   * {@link DataOutput}. This keeps the serialization of ordinal compatible with
-   * previous versions writing a single byte to DataOutput when possible, and a
-   * token with 2 bytes if it is large.
+   * Write the given ordinal (result of {@link #ordinal()}) to given {@link DataOutput}. This keeps
+   * the serialization of ordinal compatible with previous versions writing a single byte to
+   * DataOutput when possible, and a token with 2 bytes if it is large.
-   * @param out
-   *          the {@link DataOutput} to write the ordinal write to
-   * @param ordinal
-   *          the version to be written
-   * @param compressed
-   *          if true, then use single byte for ordinal < 128, and three bytes
-   *          for beyond that, else always use three bytes where the first byte
-   *          is {@link #TOKEN_ORDINAL}; former mode is useful for
-   *          interoperatibility with previous versions while latter to use
-   *          fixed size for writing version; typically former will be used for
-   *          P2P/client-server communications while latter for persisting to
-   *          disk; we use the token to ensure that
-   *          {@link #readOrdinal(DataInput)} can deal with both
-   *          compressed/uncompressed cases seemlessly
+   * @param out the {@link DataOutput} to write the ordinal write to
+   * @param ordinal the version to be written
+   * @param compressed if true, then use single byte for ordinal < 128, and three bytes for beyond
+   *        that, else always use three bytes where the first byte is {@link #TOKEN_ORDINAL}; former
+   *        mode is useful for interoperatibility with previous versions while latter to use fixed
+   *        size for writing version; typically former will be used for P2P/client-server
+   *        communications while latter for persisting to disk; we use the token to ensure that
+   *        {@link #readOrdinal(DataInput)} can deal with both compressed/uncompressed cases
+   *        seemlessly
-  public static void writeOrdinal(DataOutput out, short ordinal,
-      boolean compressed) throws IOException {
+  public static void writeOrdinal(DataOutput out, short ordinal, boolean compressed)
+      throws IOException {
-    }
-    else {
+    } else {
-   * Write this {@link Version}'s ordinal (result of {@link #ordinal()}) to
-   * given {@link DataOutput}. This keeps the serialization of ordinal
-   * compatible with previous versions writing a single byte to DataOutput when
-   * possible, and a token with 2 bytes if it is large.
+   * Write this {@link Version}'s ordinal (result of {@link #ordinal()}) to given
+   * {@link DataOutput}. This keeps the serialization of ordinal compatible with previous versions
+   * writing a single byte to DataOutput when possible, and a token with 2 bytes if it is large.
-   * @param out
-   *          the {@link DataOutput} to write the ordinal write to
-   * @param compressed
-   *          if true, then use single byte for ordinal < 128, and three bytes
-   *          for beyond that, else always use three bytes where the first byte
-   *          is {@link #TOKEN_ORDINAL}; former mode is useful for
-   *          interoperatibility with previous versions while latter to use
-   *          fixed size for writing version; typically former will be used for
-   *          P2P/client-server communications while latter for persisting to
-   *          disk; we use the token to ensure that
-   *          {@link #readOrdinal(DataInput)} can deal with both
-   *          compressed/uncompressed cases seemlessly
+   * @param out the {@link DataOutput} to write the ordinal write to
+   * @param compressed if true, then use single byte for ordinal < 128, and three bytes for beyond
+   *        that, else always use three bytes where the first byte is {@link #TOKEN_ORDINAL}; former
+   *        mode is useful for interoperatibility with previous versions while latter to use fixed
+   *        size for writing version; typically former will be used for P2P/client-server
+   *        communications while latter for persisting to disk; we use the token to ensure that
+   *        {@link #readOrdinal(DataInput)} can deal with both compressed/uncompressed cases
+   *        seemlessly
-  public final void writeOrdinal(DataOutput out, boolean compressed)
-      throws IOException {
+  public final void writeOrdinal(DataOutput out, boolean compressed) throws IOException {
-   * Fixed number of bytes required for serializing this version when
-   * "compressed" flag is false in {@link #writeOrdinal(DataOutput, boolean)}.
+   * Fixed number of bytes required for serializing this version when "compressed" flag is false in
+   * {@link #writeOrdinal(DataOutput, boolean)}.
-   * Fixed number of bytes required for serializing this version when
-   * "compressed" flag is true in {@link #writeOrdinal(DataOutput, boolean)}.
+   * Fixed number of bytes required for serializing this version when "compressed" flag is true in
+   * {@link #writeOrdinal(DataOutput, boolean)}.
-    }
-    else {
+    } else {
-   * Write the given ordinal (result of {@link #ordinal()}) to given
-   * {@link ByteBuffer}. This keeps the serialization of ordinal compatible with
-   * previous versions writing a single byte to DataOutput when possible, and a
-   * token with 2 bytes if it is large.
+   * Write the given ordinal (result of {@link #ordinal()}) to given {@link ByteBuffer}. This keeps
+   * the serialization of ordinal compatible with previous versions writing a single byte to
+   * DataOutput when possible, and a token with 2 bytes if it is large.
-   * @param buffer
-   *          the {@link ByteBuffer} to write the ordinal write to
-   * @param ordinal
-   *          the version to be written
-   * @param compressed
-   *          if true, then use single byte for ordinal < 128, and three bytes
-   *          for beyond that, else always use three bytes where the first byte
-   *          is {@link #TOKEN_ORDINAL}
+   * @param buffer the {@link ByteBuffer} to write the ordinal write to
+   * @param ordinal the version to be written
+   * @param compressed if true, then use single byte for ordinal < 128, and three bytes for beyond
+   *        that, else always use three bytes where the first byte is {@link #TOKEN_ORDINAL}
-  public static void writeOrdinal(ByteBuffer buffer, short ordinal,
-      boolean compressed) throws IOException {
+  public static void writeOrdinal(ByteBuffer buffer, short ordinal, boolean compressed)
+      throws IOException {
-      buffer.put((byte)ordinal);
-    }
-    else {
+      buffer.put((byte) ordinal);
+    } else {
-   * Reads ordinal as written by {@link #writeOrdinal} from
-   * given {@link DataInput}.
+   * Reads ordinal as written by {@link #writeOrdinal} from given {@link DataInput}.
-    }
-    else {
+    } else {
-   * Return the <code>Version</code> reading from given {@link DataInput} as
-   * serialized by {@link #writeOrdinal(DataOutput, boolean)}.
+   * Return the <code>Version</code> reading from given {@link DataInput} as serialized by
+   * {@link #writeOrdinal(DataOutput, boolean)}.
-   * If the incoming ordinal is greater than or equal to current ordinal then
-   * this will return null or {@link #CURRENT} indicating that version is same
-   * as that of {@link #CURRENT} assuming that peer will support this JVM.
+   * If the incoming ordinal is greater than or equal to current ordinal then this will return null
+   * or {@link #CURRENT} indicating that version is same as that of {@link #CURRENT} assuming that
+   * peer will support this JVM.
-   * This method is not meant to be used for client-server protocol since
-   * servers cannot support higher version clients, rather is only meant for
-   * P2P/JGroups messaging where a mixed version of servers can be running at
-   * the same time. Similarly cannot be used when recovering from disk since
-   * higher version data cannot be read.
+   * This method is not meant to be used for client-server protocol since servers cannot support
+   * higher version clients, rather is only meant for P2P/JGroups messaging where a mixed version of
+   * servers can be running at the same time. Similarly cannot be used when recovering from disk
+   * since higher version data cannot be read.
-   * @param in
-   *          the {@link DataInput} to read the version from
-   * @param returnNullForCurrent
-   *          if true then return null if incoming version >= {@link #CURRENT}
-   *          else return {@link #CURRENT}
+   * @param in the {@link DataInput} to read the version from
+   * @param returnNullForCurrent if true then return null if incoming version >= {@link #CURRENT}
+   *        else return {@link #CURRENT}
-  public static Version readVersion(DataInput in, boolean returnNullForCurrent)
-      throws IOException {
+  public static Version readVersion(DataInput in, boolean returnNullForCurrent) throws IOException {
-   * Return the <code>Version</code> represented by specified ordinal while not
-   * throwing exception if given ordinal is higher than any known ones or does not
-   * map to an actual Version instance due to gaps in the version ordinal sequence.
+   * Return the <code>Version</code> represented by specified ordinal while not throwing exception
+   * if given ordinal is higher than any known ones or does not map to an actual Version instance
+   * due to gaps in the version ordinal sequence.
-   * Reads ordinal as written by {@link #writeOrdinal} from given
-   * {@link InputStream}. Returns -1 on end of stream.
+   * Reads ordinal as written by {@link #writeOrdinal} from given {@link InputStream}. Returns -1 on
+   * end of stream.
-  public static short readOrdinalFromInputStream(InputStream is)
-      throws IOException {
+  public static short readOrdinalFromInputStream(InputStream is) throws IOException {
-        return (short)ordinal;
-      }
-      else {
+        return (short) ordinal;
+      } else {
-          return (short)((ordinalPart1 << 8) | ordinalPart2);
-        }
-        else {
+          return (short) ((ordinalPart1 << 8) | ordinalPart2);
+        } else {
-    }
-    else {
+    } else {
-  
+
-  
+
-  
+
-   * Returns whether this <code>Version</code> is compatible with the input
-   * <code>Version</code>
+   * Returns whether this <code>Version</code> is compatible with the input <code>Version</code>
-   * @return whether this <code>Version</code> is compatible with the input
-   *         <code>Version</code>
+   * @return whether this <code>Version</code> is compatible with the input <code>Version</code>
-   * Finds the Version instance corresponding to the given ordinal and returns
-   * the result of compareTo(Version)
+   * Finds the Version instance corresponding to the given ordinal and returns the result of
+   * compareTo(Version)
+   * 
-   * @return negative if this version is older, positive if this version is newer, 0 if this is the same version
+   * @return negative if this version is older, positive if this version is newer, 0 if this is the
+   *         same version
-  
+
-//      // byte min/max can't overflow int, so use (a-b)
-//      final int thisOrdinal = this.ordinal;
-//      final int otherOrdinal = o.ordinal;
-//      return (thisOrdinal - otherOrdinal);
-      //[bruce] new implementation uses major/minor/patch/build
+      // // byte min/max can't overflow int, so use (a-b)
+      // final int thisOrdinal = this.ordinal;
+      // final int otherOrdinal = o.ordinal;
+      // return (thisOrdinal - otherOrdinal);
+      // [bruce] new implementation uses major/minor/patch/build
-      if (this.release > other.release){
+      if (this.release > other.release) {
-    }
-    else {
+    } else {
-  /** Returns a string representation for this <code>Version</code>.
-     * @return the name of this operation.
-     */
+  /**
+   * Returns a string representation for this <code>Version</code>.
+   * 
+   * @return the name of this operation.
+   */
-    }
-    else {
+    } else {
-    if (other == this) return true;
+    if (other == this)
+      return true;
-      return this.ordinal == ((Version)other).ordinal;
-    }
-    else {
+      return this.ordinal == ((Version) other).ordinal;
+    } else {
-  
+
-    bytes[0] = (byte)(ordinal >> 8);
-    bytes[1] = (byte)ordinal;
+    bytes[0] = (byte) (ordinal >> 8);
+    bytes[1] = (byte) ordinal;
+  public boolean isPre65() {
+    return compareTo(Version.GFE_65) < 0;
+  }

MOV31 INS23 INS23 INS31 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS43 INS59 INS83 UPD42 MOV8 UPD42 MOV8 INS83 INS39 INS42 INS8 UPD66 UPD66 UPD66 UPD34 INS42 INS34 INS42 INS42 INS14 UPD42 MOV66 INS41 UPD66 UPD66 INS43 INS45 INS45 INS11 INS11 INS11 INS11 INS42 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS27 INS42 INS39 INS34 INS39 INS34 INS39 INS34 INS39 INS34 INS32 INS34 INS42 INS40 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL83 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
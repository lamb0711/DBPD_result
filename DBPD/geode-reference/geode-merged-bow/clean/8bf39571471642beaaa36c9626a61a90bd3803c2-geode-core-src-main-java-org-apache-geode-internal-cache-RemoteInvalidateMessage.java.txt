Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
-  /**
-   * Empty constructor to satisfy {@link org.apache.geode.DataSerializer}
-   * requirements
-   */
-  public RemoteInvalidateMessage() {
-  }
-  private RemoteInvalidateMessage(Set recipients,
-                            String regionPath,
-                            DirectReplyProcessor processor,
-                            EntryEventImpl event,
-                            boolean useOriginRemote, boolean possibleDuplicate) {
-    super(recipients,
-          regionPath,
-          processor,
-          event,
-          null, DistributionManager.PARTITIONED_REGION_EXECUTOR, useOriginRemote,
-          possibleDuplicate);
+  /**
+   * Empty constructor to satisfy {@link org.apache.geode.DataSerializer} requirements
+   */
+  public RemoteInvalidateMessage() {}
+
+  private RemoteInvalidateMessage(Set recipients, String regionPath, DirectReplyProcessor processor,
+      EntryEventImpl event, boolean useOriginRemote, boolean possibleDuplicate) {
+    super(recipients, regionPath, processor, event, null,
+        DistributionManager.PARTITIONED_REGION_EXECUTOR, useOriginRemote, possibleDuplicate);
-    DistributedRegion r = (DistributedRegion)event.getRegion();
-    Collection replicates = onlyPersistent ? r.getCacheDistributionAdvisor()
-        .adviseInitializedPersistentMembers().keySet() : r
-        .getCacheDistributionAdvisor().adviseInitializedReplicates();
+    DistributedRegion r = (DistributedRegion) event.getRegion();
+    Collection replicates = onlyPersistent
+        ? r.getCacheDistributionAdvisor().adviseInitializedPersistentMembers().keySet()
+        : r.getCacheDistributionAdvisor().adviseInitializedReplicates();
-    for (Iterator<InternalDistributedMember> it=replicates.iterator(); it.hasNext(); ) {
+    for (Iterator<InternalDistributedMember> it = replicates.iterator(); it.hasNext();) {
-        InvalidateResponse processor = send(replicate, event.getRegion(), 
-            event, DistributionManager.SERIAL_EXECUTOR, false, posDup);
+        InvalidateResponse processor = send(replicate, event.getRegion(), event,
+            DistributionManager.SERIAL_EXECUTOR, false, posDup);
-            event.getRegion().getVersionVector().recordVersion(versionTag.getMemberID(), versionTag);
+            event.getRegion().getVersionVector().recordVersion(versionTag.getMemberID(),
+                versionTag);
-  
+
-      
+
-        throw new EntryNotFoundException(""+event.getKey());
-        
+        throw new EntryNotFoundException("" + event.getKey());
+
-      
-      } catch(RemoteOperationException e) {
+
+      } catch (RemoteOperationException e) {
-          logger.trace(LogMarker.DM, "RemoteDestroyMessage caught an unexpected exception during distribution", e);
+          logger.trace(LogMarker.DM,
+              "RemoteDestroyMessage caught an unexpected exception during distribution", e);
-   * {@link org.apache.geode.cache.Region#invalidate(Object)}message to the
-   * recipient
+   * {@link org.apache.geode.cache.Region#invalidate(Object)}message to the recipient
-   * @param r
-   *          the ReplicateRegion for which the invalidate was performed
+   * @param r the ReplicateRegion for which the invalidate was performed
-  public static InvalidateResponse send(DistributedMember recipient,
-      LocalRegion r, EntryEventImpl event, int processorType,
-      boolean useOriginRemote, boolean possibleDuplicate)
-      throws RemoteOperationException
-  {
-    //Assert.assertTrue(recipient != null, "RemoteInvalidateMessage NULL recipient");  recipient may be null for remote notifications
+  public static InvalidateResponse send(DistributedMember recipient, LocalRegion r,
+      EntryEventImpl event, int processorType, boolean useOriginRemote, boolean possibleDuplicate)
+      throws RemoteOperationException {
+    // Assert.assertTrue(recipient != null, "RemoteInvalidateMessage NULL recipient"); recipient may
+    // be null for remote notifications
-    RemoteInvalidateMessage m = new RemoteInvalidateMessage(recipients,
-        r.getFullPath(), p, event, useOriginRemote, possibleDuplicate);
+    RemoteInvalidateMessage m = new RemoteInvalidateMessage(recipients, r.getFullPath(), p, event,
+        useOriginRemote, possibleDuplicate);
-    Set failures =r.getDistributionManager().putOutgoing(m); 
-    if (failures != null && failures.size() > 0 ) {
-      throw new RemoteOperationException(LocalizedStrings.InvalidateMessage_FAILED_SENDING_0.toLocalizedString(m));
+    Set failures = r.getDistributionManager().putOutgoing(m);
+    if (failures != null && failures.size() > 0) {
+      throw new RemoteOperationException(
+          LocalizedStrings.InvalidateMessage_FAILED_SENDING_0.toLocalizedString(m));
-   * This method is called upon receipt and make the desired changes to the
-   * PartitionedRegion Note: It is very important that this message does NOT
-   * cause any deadlocks as the sender will wait indefinitely for the
-   * acknowledgement
+   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:
+   * It is very important that this message does NOT cause any deadlocks as the sender will wait
+   * indefinitely for the acknowledgement
-  protected boolean operateOnRegion(DistributionManager dm,
-      LocalRegion r, long startTime)
-      throws EntryExistsException, RemoteOperationException
-  {
+  protected boolean operateOnRegion(DistributionManager dm, LocalRegion r, long startTime)
+      throws EntryExistsException, RemoteOperationException {
-       eventSender = getSender();
+      eventSender = getSender();
-    @Released final EntryEventImpl event = EntryEventImpl.create(
-        r,
-        getOperation(),
-        key,
-        null, /*newValue*/
+    @Released
+    final EntryEventImpl event = EntryEventImpl.create(r, getOperation(), key, null, /* newValue */
-        this.useOriginRemote/*originRemote - false to force distribution in buckets*/,
-        eventSender,
-        true/*generateCallbacks*/,
-        false/*initializeId*/);
+        this.useOriginRemote/* originRemote - false to force distribution in buckets */,
+        eventSender, true/* generateCallbacks */, false/* initializeId */);
-    if (this.bridgeContext != null) {
-      event.setContext(this.bridgeContext);
-    }
-    
-    event.setCausedByMessage(this);
+      if (this.bridgeContext != null) {
+        event.setContext(this.bridgeContext);
+      }
-    if (this.versionTag != null) {
-      this.versionTag.replaceNullIDs(getSender());
-      event.setVersionTag(this.versionTag);
-    }
-    Assert.assertTrue(eventId != null);
-    event.setEventId(eventId);
-    
-    event.setPossibleDuplicate(this.possibleDuplicate);
-    
-    // for cqs, which needs old value based on old value being sent on wire.
-    boolean eventShouldHaveOldValue = getHasOldValue();
-    if (eventShouldHaveOldValue){
-      if (getOldValueIsSerialized()){
-        event.setSerializedOldValue(getOldValueBytes());
+      event.setCausedByMessage(this);
+
+      if (this.versionTag != null) {
+        this.versionTag.replaceNullIDs(getSender());
+        event.setVersionTag(this.versionTag);
-      else{
-        event.setOldValue(getOldValueBytes());
+      Assert.assertTrue(eventId != null);
+      event.setEventId(eventId);
+
+      event.setPossibleDuplicate(this.possibleDuplicate);
+
+      // for cqs, which needs old value based on old value being sent on wire.
+      boolean eventShouldHaveOldValue = getHasOldValue();
+      if (eventShouldHaveOldValue) {
+        if (getOldValueIsSerialized()) {
+          event.setSerializedOldValue(getOldValueBytes());
+        } else {
+          event.setOldValue(getOldValueBytes());
+        }
-    }
-    boolean sendReply = true;
+      boolean sendReply = true;
-        sendReply(getSender(), this.processorId, dm, /*ex*/null, 
-            event.getRegion(), event.getVersionTag(), startTime);
+        sendReply(getSender(), this.processorId, dm, /* ex */null, event.getRegion(),
+            event.getVersionTag(), startTime);
-      }
-      catch (EntryNotFoundException eee) {
-        //        failed = true;
+      } catch (EntryNotFoundException eee) {
+        // failed = true;
-      }
-      catch (PrimaryBucketException pbe) {
+      } catch (PrimaryBucketException pbe) {
-    return sendReply;
+      return sendReply;
-  
+
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm,
-      ReplyException ex, LocalRegion r, long startTime) {
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+      LocalRegion r, long startTime) {
-  
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex, 
+
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
-    /*if (pr != null && startTime > 0) {
-      pr.getPrStats().endPartitionMessagesProcessing(startTime); 
-    }*/
+    /*
+     * if (pr != null && startTime > 0) { pr.getPrStats().endPartitionMessagesProcessing(startTime);
+     * }
+     */
-  
+
-    private static final byte PERSISTENT  = 0x02;
+    private static final byte PERSISTENT = 0x02;
+
-    public InvalidateReplyMessage() {
-    }
-  
-    private InvalidateReplyMessage(int processorId, VersionTag versionTag, ReplyException ex)
-    {
+    public InvalidateReplyMessage() {}
+
+    private InvalidateReplyMessage(int processorId, VersionTag versionTag, ReplyException ex) {
-    
+
-        ReplySender replySender, VersionTag versionTag, ReplyException ex) 
-    {
+        ReplySender replySender, VersionTag versionTag, ReplyException ex) {
-      
+
-     * Processes this message.  This method is invoked by the receiver
-     * of the message.
+     * Processes this message. This method is invoked by the receiver of the message.
+     * 
-        logger.trace(LogMarker.DM, "InvalidateReplyMessage process invoking reply processor with processorId:{}", this.processorId);
+        logger.trace(LogMarker.DM,
+            "InvalidateReplyMessage process invoking reply processor with processorId:{}",
+            this.processorId);
-  
+
-        InvalidateResponse processor = (InvalidateResponse)rp;
+        InvalidateResponse processor = (InvalidateResponse) rp;
-  
+
-      dm.getStats().incReplyMessageTime(NanoTimer.getTime()-startTime);
+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);
-    
+
-    
+
-      if(this.versionTag != null) {
+      if (this.versionTag != null) {
-      if(this.versionTag instanceof DiskVersionTag) {
+      if (this.versionTag instanceof DiskVersionTag) {
+      }
-    }
-  
+
-    public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      boolean hasTag = (b & HAS_VERSION) != 0; 
+      boolean hasTag = (b & HAS_VERSION) != 0;
-  
+
-      sb.append("InvalidateReplyMessage ")
-      .append("processorid=").append(this.processorId)
-      .append(" exception=").append(getException());
+      sb.append("InvalidateReplyMessage ").append("processorid=").append(this.processorId)
+          .append(" exception=").append(getException());
+   * 
-  public static class InvalidateResponse extends RemoteOperationResponse  {
+  public static class InvalidateResponse extends RemoteOperationResponse {
-    
+
-    public void waitForResult() throws CacheException, RemoteOperationException
-    {
+    public void waitForResult() throws CacheException, RemoteOperationException {
-      }
-      catch (RemoteOperationException e) {
+      } catch (RemoteOperationException e) {
-        throw new RemoteOperationException(LocalizedStrings.InvalidateMessage_NO_RESPONSE_CODE_RECEIVED.toLocalizedString());
+        throw new RemoteOperationException(
+            LocalizedStrings.InvalidateMessage_NO_RESPONSE_CODE_RECEIVED.toLocalizedString());
-    
+
+    }
-  }
-  
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66
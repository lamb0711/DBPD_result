Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  private enum CPU { 
+  private enum CPU {
-    /** stands for aggregation of all columns not present in the enum list*/
+    /** stands for aggregation of all columns not present in the enum list */
-  }  
-  
+  }
+
-  private static final String pageSizeProperty = DistributionConfig.GEMFIRE_PREFIX + "statistics.linux.pageSize";
+  private static final String pageSizeProperty =
+      DistributionConfig.GEMFIRE_PREFIX + "statistics.linux.pageSize";
- 
+
-  
+
-  
-  //Do not create instances of this class
-  private LinuxProcFsStatistics() {
-  }
-  
+
+  // Do not create instances of this class
+  private LinuxProcFsStatistics() {}
+
-  
+
-  
-  /* get the statistics for the specified process. 
-   * ( pid_rssSize, pid_imageSize )
-   * vsize is assumed to be in units of kbytes
-   * System property gemfire.statistics.pagesSize can be used to configure 
+
+  /*
+   * get the statistics for the specified process. ( pid_rssSize, pid_imageSize ) vsize is assumed
+   * to be in units of kbytes System property gemfire.statistics.pagesSize can be used to configure
-   */ 
-  public static void refreshProcess(int pid, int[] ints, long[] longs, double[] doubles) { // TODO: was package-protected
-    //Just incase a pid is not available
-    if(pid == 0) return;
+   */
+  public static void refreshProcess(int pid, int[] ints, long[] longs, double[] doubles) { // TODO:
+                                                                                           // was
+                                                                                           // package-protected
+    // Just incase a pid is not available
+    if (pid == 0)
+      return;
-      File file = new File( "/proc/" + pid + "/stat" );
-      isr = new InputStreamReader( new FileInputStream( file ));
+      File file = new File("/proc/" + pid + "/stat");
+      isr = new InputStreamReader(new FileInputStream(file));
-      if ( line == null ) {
+      if (line == null) {
-      ints[LinuxProcessStats.rssSizeINT] = (int) ((st.nextTokenAsLong()*pageSize)/OneMeg);
-    } catch ( NoSuchElementException nsee ) {
+      ints[LinuxProcessStats.rssSizeINT] = (int) ((st.nextTokenAsLong() * pageSize) / OneMeg);
+    } catch (NoSuchElementException nsee) {
-      // where trying to get its stats. 
+      // where trying to get its stats.
-    } catch ( IOException ioe ) {
+    } catch (IOException ioe) {
-      // where trying to get its stats. 
+      // where trying to get its stats.
-      if(br != null) try { br.close(); } catch(IOException ignore) {}
+      if (br != null)
+        try {
+          br.close();
+        } catch (IOException ignore) {
+        }
-  public static void refreshSystem(int[] ints, long[] longs, double[] doubles) { // TODO: was package-protected
-    ints[LinuxSystemStats.processesINT] = getProcessCount();        
+  public static void refreshSystem(int[] ints, long[] longs, double[] doubles) { // TODO: was
+                                                                                 // package-protected
+    ints[LinuxSystemStats.processesINT] = getProcessCount();
-      isr = new InputStreamReader( new FileInputStream( "/proc/stat" ));
+      isr = new InputStreamReader(new FileInputStream("/proc/stat"));
-      while ( ( line = br.readLine() ) != null ) {
+      while ((line = br.readLine()) != null) {
-            ints[LinuxSystemStats.cpuIdleINT]   = cpuData[CPU.IDLE.ordinal()]; 
-            ints[LinuxSystemStats.cpuNiceINT]   = cpuData[CPU.NICE.ordinal()];
-            ints[LinuxSystemStats.cpuSystemINT] = cpuData[CPU.SYSTEM.ordinal()]; 
-            ints[LinuxSystemStats.cpuUserINT]   = cpuData[CPU.USER.ordinal()];
-            ints[LinuxSystemStats.iowaitINT]    = cpuData[CPU.IOWAIT.ordinal()];
-            ints[LinuxSystemStats.irqINT]       = cpuData[CPU.IRQ.ordinal()];
-            ints[LinuxSystemStats.softirqINT]   = cpuData[CPU.SOFTIRQ.ordinal()];          
+            ints[LinuxSystemStats.cpuIdleINT] = cpuData[CPU.IDLE.ordinal()];
+            ints[LinuxSystemStats.cpuNiceINT] = cpuData[CPU.NICE.ordinal()];
+            ints[LinuxSystemStats.cpuSystemINT] = cpuData[CPU.SYSTEM.ordinal()];
+            ints[LinuxSystemStats.cpuUserINT] = cpuData[CPU.USER.ordinal()];
+            ints[LinuxSystemStats.iowaitINT] = cpuData[CPU.IOWAIT.ordinal()];
+            ints[LinuxSystemStats.irqINT] = cpuData[CPU.IRQ.ordinal()];
+            ints[LinuxSystemStats.softirqINT] = cpuData[CPU.SOFTIRQ.ordinal()];
-                                                   + cpuData[CPU.SYSTEM.ordinal()]
-                                                   + cpuData[CPU.IOWAIT.ordinal()]
-                                                   + cpuData[CPU.IRQ.ordinal()]
-                                                   + cpuData[CPU.SOFTIRQ.ordinal()];
-          } else if ( !hasProcVmStat && line.startsWith(PAGE)) {
+                + cpuData[CPU.SYSTEM.ordinal()] + cpuData[CPU.IOWAIT.ordinal()]
+                + cpuData[CPU.IRQ.ordinal()] + cpuData[CPU.SOFTIRQ.ordinal()];
+          } else if (!hasProcVmStat && line.startsWith(PAGE)) {
-            longs[LinuxSystemStats.pagesPagedInLONG] = SpaceTokenizer.parseAsLong(line.substring(PAGE.length(), secondIndex));
-            longs[LinuxSystemStats.pagesPagedOutLONG] = SpaceTokenizer.parseAsLong(line.substring(secondIndex+1));
-          } else if ( !hasProcVmStat && line.startsWith(SWAP)) {
+            longs[LinuxSystemStats.pagesPagedInLONG] =
+                SpaceTokenizer.parseAsLong(line.substring(PAGE.length(), secondIndex));
+            longs[LinuxSystemStats.pagesPagedOutLONG] =
+                SpaceTokenizer.parseAsLong(line.substring(secondIndex + 1));
+          } else if (!hasProcVmStat && line.startsWith(SWAP)) {
-            longs[LinuxSystemStats.pagesSwappedInLONG] = SpaceTokenizer.parseAsLong(line.substring(SWAP.length(), secondIndex));
-            longs[LinuxSystemStats.pagesSwappedOutLONG] = SpaceTokenizer.parseAsLong(line.substring(secondIndex+1));
-          } else if ( line.startsWith(CTXT)) {
-            longs[LinuxSystemStats.contextSwitchesLONG] = SpaceTokenizer.parseAsLong(line.substring(CTXT.length()));    
-          } else if ( line.startsWith(PROCESSES)) {
-            longs[LinuxSystemStats.processCreatesLONG] = SpaceTokenizer.parseAsInt(line.substring(PROCESSES.length()));        
+            longs[LinuxSystemStats.pagesSwappedInLONG] =
+                SpaceTokenizer.parseAsLong(line.substring(SWAP.length(), secondIndex));
+            longs[LinuxSystemStats.pagesSwappedOutLONG] =
+                SpaceTokenizer.parseAsLong(line.substring(secondIndex + 1));
+          } else if (line.startsWith(CTXT)) {
+            longs[LinuxSystemStats.contextSwitchesLONG] =
+                SpaceTokenizer.parseAsLong(line.substring(CTXT.length()));
+          } else if (line.startsWith(PROCESSES)) {
+            longs[LinuxSystemStats.processCreatesLONG] =
+                SpaceTokenizer.parseAsInt(line.substring(PROCESSES.length()));
-        } catch ( NoSuchElementException nsee ) {
-          //this is the result of reading a partially formed file
-          //just do not update what ever entry had the problem
+        } catch (NoSuchElementException nsee) {
+          // this is the result of reading a partially formed file
+          // just do not update what ever entry had the problem
-    } catch ( IOException ioe ) {
+    } catch (IOException ioe) {
-      if(br != null) try { br.close(); } catch(IOException ignore) {}
+      if (br != null)
+        try {
+          br.close();
+        } catch (IOException ignore) {
+        }
-    if(hasProcVmStat) {
+    if (hasProcVmStat) {
-      isr = new InputStreamReader( new FileInputStream( "/proc/loadavg" ));
+      isr = new InputStreamReader(new FileInputStream("/proc/loadavg"));
-      if ( line == null ) {
+      if (line == null) {
-      doubles[LinuxSystemStats.loadAverage5DOUBLE]  = st.nextTokenAsDouble();
+      doubles[LinuxSystemStats.loadAverage5DOUBLE] = st.nextTokenAsDouble();
-    } catch ( NoSuchElementException nsee ) {
+    } catch (NoSuchElementException nsee) {
-      if(br != null) try { br.close(); } catch(IOException ignore) {}
+      if (br != null)
+        try {
+          br.close();
+        } catch (IOException ignore) {
+        }
+   * 
-      BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("/proc/meminfo")));
+      BufferedReader br =
+          new BufferedReader(new InputStreamReader(new FileInputStream("/proc/meminfo")));
-        
+
-        
+
-        
+
-  
+
-  //          total:    used:    free:  shared: buffers:  cached:
-  //Mem:  4118380544 3816050688 302329856        0 109404160 3060326400
-  //Swap: 4194881536 127942656 4066938880
+  // total: used: free: shared: buffers: cached:
+  // Mem: 4118380544 3816050688 302329856 0 109404160 3060326400
+  // Swap: 4194881536 127942656 4066938880
-    InputStreamReader isr = null;  
+    InputStreamReader isr = null;
-      isr = new InputStreamReader( new FileInputStream( "/proc/meminfo" ));
+      isr = new InputStreamReader(new FileInputStream("/proc/meminfo"));
-      //Assume all values read in are in kB, convert to MB
+      // Assume all values read in are in kB, convert to MB
-      while ( (line = br.readLine()) != null) {
+      while ((line = br.readLine()) != null) {
-          if ( line.startsWith("MemTotal: ")) {
+          if (line.startsWith("MemTotal: ")) {
-            st.skipToken(); //Burn initial token
+            st.skipToken(); // Burn initial token
-          } else if ( line.startsWith("MemFree: ")) {
+          } else if (line.startsWith("MemFree: ")) {
-            st.skipToken(); //Burn initial token
+            st.skipToken(); // Burn initial token
-          } else if ( line.startsWith("SharedMem: ")) {
-           st.setString(line);
-           st.skipToken(); //Burn initial token
-           ints[LinuxSystemStats.sharedMemoryINT] = (int) (st.nextTokenAsLong() / 1024);
-          } else if ( line.startsWith("Buffers: ")) {
+          } else if (line.startsWith("SharedMem: ")) {
-            st.nextToken(); //Burn initial token
+            st.skipToken(); // Burn initial token
+            ints[LinuxSystemStats.sharedMemoryINT] = (int) (st.nextTokenAsLong() / 1024);
+          } else if (line.startsWith("Buffers: ")) {
+            st.setString(line);
+            st.nextToken(); // Burn initial token
-          } else if ( line.startsWith("SwapTotal: ")) {
+          } else if (line.startsWith("SwapTotal: ")) {
-            st.skipToken(); //Burn initial token
+            st.skipToken(); // Burn initial token
-          } else if ( line.startsWith("SwapFree: ")) {
+          } else if (line.startsWith("SwapFree: ")) {
-            st.skipToken(); //Burn initial token
+            st.skipToken(); // Burn initial token
-          } else if ( line.startsWith("Cached: ")) {
+          } else if (line.startsWith("Cached: ")) {
-            st.skipToken(); //Burn initial token
+            st.skipToken(); // Burn initial token
-          } else if ( line.startsWith("Dirty: ")) {
+          } else if (line.startsWith("Dirty: ")) {
-            st.skipToken(); //Burn initial token
+            st.skipToken(); // Burn initial token
-          } else if ( line.startsWith("Inact_dirty: ")) { // 2.4 kernels
+          } else if (line.startsWith("Inact_dirty: ")) { // 2.4 kernels
-            st.skipToken(); //Burn initial token
+            st.skipToken(); // Burn initial token
-        } catch(NoSuchElementException nsee) {
-          //ignore and let that stat not to be updated this time
+        } catch (NoSuchElementException nsee) {
+          // ignore and let that stat not to be updated this time
-    } catch ( IOException ioe ) {
+    } catch (IOException ioe) {
-      if(br != null) try { br.close(); } catch(IOException ignore) {}
+      if (br != null)
+        try {
+          br.close();
+        } catch (IOException ignore) {
+        }
-Inter-|   Receive                                                |  Transmit
- face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed
-    lo:1908275823 326949246    0    0    0     0          0         0 1908275823 326949246    0    0    0     0       0          0
-*/
+   * Inter-| Receive | Transmit face |bytes packets errs drop fifo frame compressed multicast|bytes
+   * packets errs drop fifo colls carrier compressed lo:1908275823 326949246 0 0 0 0 0 0 1908275823
+   * 326949246 0 0 0 0 0 0
+   */
-      isr = new InputStreamReader( new FileInputStream( "/proc/net/dev" ));
+      isr = new InputStreamReader(new FileInputStream("/proc/net/dev"));
-      long lo_recv_packets = 0, lo_recv_bytes = 0; 
-      long other_recv_packets = 0, other_recv_bytes = 0; 
-      long other_recv_errs    = 0, other_recv_drop  = 0; 
-      long other_xmit_packets = 0, other_xmit_bytes = 0; 
-      long other_xmit_errs    = 0, other_xmit_drop  = 0, other_xmit_colls = 0; 
+      long lo_recv_packets = 0, lo_recv_bytes = 0;
+      long other_recv_packets = 0, other_recv_bytes = 0;
+      long other_recv_errs = 0, other_recv_drop = 0;
+      long other_xmit_packets = 0, other_xmit_bytes = 0;
+      long other_xmit_errs = 0, other_xmit_drop = 0, other_xmit_colls = 0;
-      while ( (line = br.readLine()) != null) {
+      while ((line = br.readLine()) != null) {
-        st.setString(line.substring(index+1).trim());
-        long recv_bytes   = st.nextTokenAsLong(); 
-        long recv_packets = st.nextTokenAsLong(); 
-        long recv_errs    = st.nextTokenAsLong(); 
-        long recv_drop    = st.nextTokenAsLong(); 
-        st.skipTokens(4); //fifo, frame, compressed, multicast
-        long xmit_bytes   = st.nextTokenAsLong(); 
-        long xmit_packets = st.nextTokenAsLong(); 
-        long xmit_errs    = st.nextTokenAsLong(); 
-        long xmit_drop    = st.nextTokenAsLong(); 
-        st.skipToken(); //fifo
-        long xmit_colls   = st.nextTokenAsLong(); 
+        st.setString(line.substring(index + 1).trim());
+        long recv_bytes = st.nextTokenAsLong();
+        long recv_packets = st.nextTokenAsLong();
+        long recv_errs = st.nextTokenAsLong();
+        long recv_drop = st.nextTokenAsLong();
+        st.skipTokens(4); // fifo, frame, compressed, multicast
+        long xmit_bytes = st.nextTokenAsLong();
+        long xmit_packets = st.nextTokenAsLong();
+        long xmit_errs = st.nextTokenAsLong();
+        long xmit_drop = st.nextTokenAsLong();
+        st.skipToken(); // fifo
+        long xmit_colls = st.nextTokenAsLong();
-        }
-        else {
-          other_recv_packets += recv_packets; 
+        } else {
+          other_recv_packets += recv_packets;
-      if(br != null) try { br.close(); } catch(IOException ignore) {}
+      if (br != null)
+        try {
+          br.close();
+        } catch (IOException ignore) {
+        }
-//    1    0 ram0 0 0 0 0 0 0 0 0 0 0 0
-//    1    1 ram1 0 0 0 0 0 0 0 0 0 0 0
-//    1    2 ram2 0 0 0 0 0 0 0 0 0 0 0
-//    1    3 ram3 0 0 0 0 0 0 0 0 0 0 0
-//    1    4 ram4 0 0 0 0 0 0 0 0 0 0 0
-//    1    5 ram5 0 0 0 0 0 0 0 0 0 0 0
-//    1    6 ram6 0 0 0 0 0 0 0 0 0 0 0
-//    1    7 ram7 0 0 0 0 0 0 0 0 0 0 0
-//    1    8 ram8 0 0 0 0 0 0 0 0 0 0 0
-//    1    9 ram9 0 0 0 0 0 0 0 0 0 0 0
-//    1   10 ram10 0 0 0 0 0 0 0 0 0 0 0
-//    1   11 ram11 0 0 0 0 0 0 0 0 0 0 0
-//    1   12 ram12 0 0 0 0 0 0 0 0 0 0 0
-//    1   13 ram13 0 0 0 0 0 0 0 0 0 0 0
-//    1   14 ram14 0 0 0 0 0 0 0 0 0 0 0
-//    1   15 ram15 0 0 0 0 0 0 0 0 0 0 0
-//    8    0 sda 1628761 56603 37715982 5690640 6073889 34091137 330349716 279787924 0 25235208 285650572
-//    8    1 sda1 151 638 45 360
-//    8    2 sda2 674840 11202608 8591346 68716852
-//    8    3 sda3 1010409 26512312 31733575 253868616
-//    8   16 sdb 12550386 47814 213085738 60429448 5529812 210792345 1731459040 1962038752 0 33797176 2024138028
-//    8   17 sdb1 12601113 213085114 216407197 1731257800
-//    3    0 hda 0 0 0 0 0 0 0 0 0 0 0
+  // 1 0 ram0 0 0 0 0 0 0 0 0 0 0 0
+  // 1 1 ram1 0 0 0 0 0 0 0 0 0 0 0
+  // 1 2 ram2 0 0 0 0 0 0 0 0 0 0 0
+  // 1 3 ram3 0 0 0 0 0 0 0 0 0 0 0
+  // 1 4 ram4 0 0 0 0 0 0 0 0 0 0 0
+  // 1 5 ram5 0 0 0 0 0 0 0 0 0 0 0
+  // 1 6 ram6 0 0 0 0 0 0 0 0 0 0 0
+  // 1 7 ram7 0 0 0 0 0 0 0 0 0 0 0
+  // 1 8 ram8 0 0 0 0 0 0 0 0 0 0 0
+  // 1 9 ram9 0 0 0 0 0 0 0 0 0 0 0
+  // 1 10 ram10 0 0 0 0 0 0 0 0 0 0 0
+  // 1 11 ram11 0 0 0 0 0 0 0 0 0 0 0
+  // 1 12 ram12 0 0 0 0 0 0 0 0 0 0 0
+  // 1 13 ram13 0 0 0 0 0 0 0 0 0 0 0
+  // 1 14 ram14 0 0 0 0 0 0 0 0 0 0 0
+  // 1 15 ram15 0 0 0 0 0 0 0 0 0 0 0
+  // 8 0 sda 1628761 56603 37715982 5690640 6073889 34091137 330349716 279787924 0 25235208
+  // 285650572
+  // 8 1 sda1 151 638 45 360
+  // 8 2 sda2 674840 11202608 8591346 68716852
+  // 8 3 sda3 1010409 26512312 31733575 253868616
+  // 8 16 sdb 12550386 47814 213085738 60429448 5529812 210792345 1731459040 1962038752 0 33797176
+  // 2024138028
+  // 8 17 sdb1 12601113 213085114 216407197 1731257800
+  // 3 0 hda 0 0 0 0 0 0 0 0 0 0 0
-        isr = new InputStreamReader( new FileInputStream( "/proc/diskstats" ));
+        isr = new InputStreamReader(new FileInputStream("/proc/diskstats"));
-        isr = new InputStreamReader( new FileInputStream( "/proc/partitions" ));
+        isr = new InputStreamReader(new FileInputStream("/proc/partitions"));
-      long readsCompleted = 0, readsMerged = 0; 
-      long sectorsRead    = 0, timeReading  = 0; 
-      long writesCompleted = 0, writesMerged = 0; 
-      long sectorsWritten  = 0, timeWriting = 0;
+      long readsCompleted = 0, readsMerged = 0;
+      long sectorsRead = 0, timeReading = 0;
+      long writesCompleted = 0, writesMerged = 0;
+      long sectorsWritten = 0, timeWriting = 0;
-      while ( (line = br.readLine()) != null) {
+      while ((line = br.readLine()) != null) {
-          if (Character.isDigit(tok.charAt(tok.length()-1))) {
+          if (Character.isDigit(tok.charAt(tok.length() - 1))) {
-        long tmp_readsCompleted = st.nextTokenAsLong(); 
-        long tmp_readsMerged = st.nextTokenAsLong(); 
-        long tmp_sectorsRead = st.nextTokenAsLong(); 
+        long tmp_readsCompleted = st.nextTokenAsLong();
+        long tmp_readsMerged = st.nextTokenAsLong();
+        long tmp_sectorsRead = st.nextTokenAsLong();
-//       org.apache.geode.distributed.internal.InternalDistributedSystem.getAnyInstance().getLoggerI18n().fine("unexpected NoSuchElementException line=" + line, nsee);
+      // org.apache.geode.distributed.internal.InternalDistributedSystem.getAnyInstance().getLoggerI18n().fine("unexpected
+      // NoSuchElementException line=" + line, nsee);
-      if(br != null) try { br.close(); } catch(IOException ignore) {}
+      if (br != null)
+        try {
+          br.close();
+        } catch (IOException ignore) {
+        }
-  //Example of /proc/vmstat
-  //...
-  //pgpgin 294333738
-  //pgpgout 1057420300
-  //pswpin 19422
-  //pswpout 14495
+  // Example of /proc/vmstat
+  // ...
+  // pgpgin 294333738
+  // pgpgout 1057420300
+  // pswpin 19422
+  // pswpout 14495
-      isr = new InputStreamReader( new FileInputStream( "/proc/vmstat" ));
+      isr = new InputStreamReader(new FileInputStream("/proc/vmstat"));
-      while((line = br.readLine()) != null) {
-        if(line.startsWith(PGPGIN)) {
-          longs[LinuxSystemStats.pagesPagedInLONG] 
-                = SpaceTokenizer.parseAsLong(line.substring(PGPGIN.length()));  
-        } else if(line.startsWith(PGPGOUT)) {
-          longs[LinuxSystemStats.pagesPagedOutLONG] 
-                = SpaceTokenizer.parseAsLong(line.substring(PGPGOUT.length())); 
-        } else if(line.startsWith(PSWPIN)) {
-          longs[LinuxSystemStats.pagesSwappedInLONG] 
-                = SpaceTokenizer.parseAsLong(line.substring(PSWPIN.length()));
-        } else if(line.startsWith(PSWPOUT)) {
-          longs[LinuxSystemStats.pagesSwappedOutLONG] 
-                = SpaceTokenizer.parseAsLong(line.substring(PSWPOUT.length()));
+      while ((line = br.readLine()) != null) {
+        if (line.startsWith(PGPGIN)) {
+          longs[LinuxSystemStats.pagesPagedInLONG] =
+              SpaceTokenizer.parseAsLong(line.substring(PGPGIN.length()));
+        } else if (line.startsWith(PGPGOUT)) {
+          longs[LinuxSystemStats.pagesPagedOutLONG] =
+              SpaceTokenizer.parseAsLong(line.substring(PGPGOUT.length()));
+        } else if (line.startsWith(PSWPIN)) {
+          longs[LinuxSystemStats.pagesSwappedInLONG] =
+              SpaceTokenizer.parseAsLong(line.substring(PSWPIN.length()));
+        } else if (line.startsWith(PSWPOUT)) {
+          longs[LinuxSystemStats.pagesSwappedOutLONG] =
+              SpaceTokenizer.parseAsLong(line.substring(PSWPOUT.length()));
-      if(br != null) try { br.close(); } catch(IOException ignore) {}
+      if (br != null)
+        try {
+          br.close();
+        } catch (IOException ignore) {
+        }
-   * Count the number of files in /proc that do not represent processes.
-   * This value is cached to make counting the number of running process a 
-   * cheap operation. The assumption is that the contents of /proc will not 
-   * change on a running system.
+   * Count the number of files in /proc that do not represent processes. This value is cached to
+   * make counting the number of running process a cheap operation. The assumption is that the
+   * contents of /proc will not change on a running system.
+   * 
-    if(procFiles != null) {
-      for(String filename : procFiles) {
+    if (procFiles != null) {
+      for (String filename : procFiles) {
-        if(! Character.isDigit(c)) {
+        if (!Character.isDigit(c)) {
- 
+
-   * @return the number of running processes on the system 
+   * @return the number of running processes on the system
-    if(procFiles == null) {
-      //unknown error, continue without this stat
+    if (procFiles == null) {
+      // unknown error, continue without this stat
-  //The array indices must be ordered as they appear in /proc/stats
-  //      (user)   (nice) (system) (idle)    (iowait) (irq)  (softirq)
-  // cpu  42813766 10844  8889075 1450764512 49963779 808244 3084872
+  // The array indices must be ordered as they appear in /proc/stats
+  // (user) (nice) (system) (idle) (iowait) (irq) (softirq)
+  // cpu 42813766 10844 8889075 1450764512 49963779 808244 3084872
-    public int[] calculateStats( String newStatLine ) {
+    public int[] calculateStats(String newStatLine) {
-      st.skipToken(); //cpu name
+      st.skipToken(); // cpu name
-      /* newer kernels now have 8 columns for cpu in
-       * /proc/stat (up from 7). This number may increase
-       * even further, hence we now use List in place of long[].
-       * We add up entries from all columns after 7 into CPU.OTHER
+      /*
+       * newer kernels now have 8 columns for cpu in /proc/stat (up from 7). This number may
+       * increase even further, hence we now use List in place of long[]. We add up entries from all
+       * columns after 7 into CPU.OTHER
-      
+
-      
-      if ( lastCpuStatsInvalid ) {
+
+      if (lastCpuStatsInvalid) {
-        for (int i=0; i<MAX_CPU_STATS; i++) {
+        for (int i = 0; i < MAX_CPU_STATS; i++) {
-        for (int i=0; i<actualCpuStats; i++) {
+        for (int i = 0; i < actualCpuStats; i++) {
-        if(total_change == 0) {
-          //avoid divide by zero
+        if (total_change == 0) {
+          // avoid divide by zero
-        } 
+        }
-        for (int i=MAX_CPU_STATS; i<actualCpuStats; i++) {
+        for (int i = MAX_CPU_STATS; i < actualCpuStats; i++) {
-      ret[CPU.OTHER.ordinal()] += (int)unaccountedCpuUtilization;
-      return ret; 
-    }  
+      ret[CPU.OTHER.ordinal()] += (int) unaccountedCpuUtilization;
+      return ret;
+    }
-  
-  private static class SpaceTokenizer { 
+
+  private static class SpaceTokenizer {
-      if(endIdx == rawChars.length || beginIdx == -1) {
+      if (endIdx == rawChars.length || beginIdx == -1) {
-      for(int i = origin+1; i < rawChars.length; i++) {
+      for (int i = origin + 1; i < rawChars.length; i++) {
-        //Add all delimiters here
-        if(c == ' ' || c == '\t' || c == '\n' || c == '\r') {
-          if(endIdx == -1) {
-            endIdx = i;	 
+        // Add all delimiters here
+        if (c == ' ' || c == '\t' || c == '\n' || c == '\r') {
+          if (endIdx == -1) {
+            endIdx = i;
-          //this handles multiple consecutive delimiters 
-          if(endIdx != -1) {
+          // this handles multiple consecutive delimiters
+          if (endIdx != -1) {
-      if( endIdx == -1 ) {
-        //indicates we were still reading white space at the end of the string
+      if (endIdx == -1) {
+        // indicates we were still reading white space at the end of the string
-      if(hasMoreTokens()) {
+      if (hasMoreTokens()) {
-    
+
-      if(hasMoreTokens()) {
+      if (hasMoreTokens()) {
-      if(hasMoreTokens()) {
+      if (hasMoreTokens()) {
-    protected void skipTokens(int numberToSkip) {  
+    protected void skipTokens(int numberToSkip) {
-      } catch(NumberFormatException nfe) {}
+      } catch (NumberFormatException nfe) {
+      }
-      } catch(NumberFormatException nfe) {}
+      } catch (NumberFormatException nfe) {
+      }
-      } catch(NumberFormatException nfe) {}
+      } catch (NumberFormatException nfe) {
+      }
-      } catch(NumberFormatException nfe) {}
+      } catch (NumberFormatException nfe) {
+      }
-      } catch(NumberFormatException nfe) {}
+      } catch (NumberFormatException nfe) {
+      }

UPD66 UPD66 UPD66 UPD66 UPD66 DEL66
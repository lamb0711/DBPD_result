Merge branch 'release/1.0.0-incubating.M3'

-import static com.gemstone.gemfire.management.internal.cli.multistep.CLIMultiStepHelper.execCLISteps;
+import static com.gemstone.gemfire.management.internal.cli.multistep.CLIMultiStepHelper.*;
-import org.springframework.shell.core.ExecutionStrategy;
-import org.springframework.shell.core.Shell;
-import org.springframework.shell.event.ParseResult;
-import org.springframework.util.Assert;
-import org.springframework.util.ReflectionUtils;
-
+import com.gemstone.gemfire.security.NotAuthorizedException;
+
+import org.springframework.shell.core.ExecutionStrategy;
+import org.springframework.shell.core.Shell;
+import org.springframework.shell.event.ParseResult;
+import org.springframework.util.Assert;
+import org.springframework.util.ReflectionUtils;
- * @since 7.0
+ * @since GemFire 7.0
-      
-    //Check if it's a multi-step command
+      //Check if it's a multi-step command
-      MultiStepCommand cmd = reflectmethod.getAnnotation(MultiStepCommand.class);      
-      if(cmd!=null){
-        return execCLISteps(logWrapper, shell,parseResult);
+      MultiStepCommand cmd = reflectmethod.getAnnotation(MultiStepCommand.class);
+      if (cmd != null) {
+        return execCLISteps(logWrapper, shell, parseResult);
-//      See #46072 
-//      String commandName = getCommandName(parseResult);
-//      if (commandName != null) {
-//        shell.flashMessage("Executing " + getCommandName(parseResult) + " ... ");
-//      }
-      //Check if it's a remote command
-      if (!isShellOnly(method)) {
-        if (GfshParseResult.class.isInstance(parseResult)) {
-          result = executeOnRemote((GfshParseResult)parseResult);
-        } else {//Remote command means implemented for Gfsh and ParseResult should be GfshParseResult.
-          //TODO - Abhishek: should this message be more specific?
-          throw new IllegalStateException("Configuration error!");
-        }
-      } else {
+      //check if it's a shell only command
+      if(isShellOnly(method)){
-          //TODO: Remove Assert
-          result = ReflectionUtils.invokeMethod(parseResult.getMethod(), parseResult.getInstance(), parseResult.getArguments());
+          return ReflectionUtils.invokeMethod(parseResult.getMethod(), parseResult.getInstance(), parseResult.getArguments());
-//    See #46072
-//      shell.flashMessage("");
-    } catch (JMXInvocationException e) {
+
+      //check if it's a GfshParseResult
+      if(!GfshParseResult.class.isInstance(parseResult)){
+        throw new IllegalStateException("Configuration error!");
+      }
+
+      result = executeOnRemote((GfshParseResult) parseResult);
+    }
+    catch(NotAuthorizedException e) {
+      result = ResultBuilder.createGemFireUnAuthorizedErrorResult("Unauthorized. Reason: " + e.getMessage());
+    }
+    catch (JMXInvocationException e) {
-    } catch (IllegalStateException e) {
+    }
+    catch (IllegalStateException e) {
-    } catch (CommandProcessingException e) {
+    }
+    catch (CommandProcessingException e) {
-    } catch (RuntimeException e) {
+    }
+    catch (RuntimeException e) {
-    } catch (Exception e) {
+    }
+    catch (Exception e) {
-    
-    if (shell.isConnectedAndReady()) {
-      byte[][]             fileData    = null;
-      CliAroundInterceptor interceptor = null;
-      
-      String interceptorClass = getInterceptor(parseResult.getMethod());
-      
-      //1. Pre Remote Execution
-      if (!CliMetaData.ANNOTATION_NULL_VALUE.equals(interceptorClass)) {
-        try {
-          interceptor = (CliAroundInterceptor) ClassPathLoader.getLatest().forName(interceptorClass).newInstance();
-        } catch (InstantiationException e) {
-          shell.logWarning("Configuration error", e);
-        } catch (IllegalAccessException e) {
-          shell.logWarning("Configuration error", e);
-        } catch (ClassNotFoundException e) {
-          shell.logWarning("Configuration error", e);
-        }
-        if (interceptor != null) {
-          Result preExecResult = interceptor.preExecution(parseResult);
-          if (Status.ERROR.equals(preExecResult.getStatus())) {
-            return preExecResult;
-          } else if (preExecResult instanceof FileResult) {            
-            FileResult fileResult = (FileResult) preExecResult;
-            fileData = fileResult.toBytes();
-          }
-        } else {
-          return ResultBuilder.createBadConfigurationErrorResult("Interceptor Configuration Error");
-        }
-      }
-      //2. Remote Execution
-      final Map<String, String> env = shell.getEnv();
-      response = shell.getOperationInvoker().processCommand(new CommandRequest(parseResult, env, fileData));
-      env.clear();
-      
-      if (response == null) {
-        shell.logWarning("Response was null for: \""+parseResult.getUserInput()+"\". (gfsh.isConnected="+shell.isConnectedAndReady()+")", null);
-        commandResult = 
-            ResultBuilder.createBadResponseErrorResult(" Error occurred while " + 
-                "executing \""+parseResult.getUserInput()+"\" on manager. " +
-                		"Please check manager logs for error.");
-      } else {
-        if (logWrapper.fineEnabled()) {
-          logWrapper.fine("Received response :: "+response);
-        }
-        CommandResponse commandResponse = CommandResponseBuilder.prepareCommandResponseFromJson((String) response);
-        
-        if (commandResponse.isFailedToPersist()) {
-          shell.printAsSevere(CliStrings.SHARED_CONFIGURATION_FAILED_TO_PERSIST_COMMAND_CHANGES);
-          logWrapper.severe(CliStrings.SHARED_CONFIGURATION_FAILED_TO_PERSIST_COMMAND_CHANGES);
-        }
-        
-        String debugInfo = commandResponse.getDebugInfo();
-        if (debugInfo != null && !debugInfo.trim().isEmpty()) {
-          //TODO - Abhishek When debug is ON, log response in gfsh logs
-          //TODO - Abhishek handle \n better. Is it coming from GemFire formatter
-          debugInfo = debugInfo.replaceAll("\n\n\n", "\n");
-          debugInfo = debugInfo.replaceAll("\n\n", "\n");
-          debugInfo = debugInfo.replaceAll("\n", "\n[From Manager : "+commandResponse.getSender()+"]");
-          debugInfo = "[From Manager : "+commandResponse.getSender()+"]" + debugInfo;
-          LogWrapper.getInstance().info(debugInfo);
-        }
-        commandResult = ResultBuilder.fromJson((String) response);
-        
-        
-        //3. Post Remote Execution
-        if (interceptor != null) {
-          Result postExecResult = interceptor.postExecution(parseResult, commandResult);
-          if (postExecResult != null) {
-            if (Status.ERROR.equals(postExecResult.getStatus())) {
-              if (logWrapper.infoEnabled()) {
-                logWrapper.info("Post execution Result :: "+ResultBuilder.resultAsString(postExecResult));
-              }
-            } else if (logWrapper.fineEnabled()) {
-              logWrapper.fine("Post execution Result :: "+ResultBuilder.resultAsString(postExecResult));
-            }
-            commandResult = postExecResult;
-          }
-        }
-      }// not null response
-    } else {
+    if(!shell.isConnectedAndReady()){
+      return null;
+
+    byte[][]             fileData    = null;
+    CliAroundInterceptor interceptor = null;
+
+    String interceptorClass = getInterceptor(parseResult.getMethod());
+
+    //1. Pre Remote Execution
+    if (!CliMetaData.ANNOTATION_NULL_VALUE.equals(interceptorClass)) {
+      try {
+        interceptor = (CliAroundInterceptor) ClassPathLoader.getLatest().forName(interceptorClass).newInstance();
+      } catch (InstantiationException e) {
+        shell.logWarning("Configuration error", e);
+      } catch (IllegalAccessException e) {
+        shell.logWarning("Configuration error", e);
+      } catch (ClassNotFoundException e) {
+        shell.logWarning("Configuration error", e);
+      }
+      if (interceptor != null) {
+        Result preExecResult = interceptor.preExecution(parseResult);
+        if (Status.ERROR.equals(preExecResult.getStatus())) {
+          return preExecResult;
+        } else if (preExecResult instanceof FileResult) {
+          FileResult fileResult = (FileResult) preExecResult;
+          fileData = fileResult.toBytes();
+        }
+      } else {
+        return ResultBuilder.createBadConfigurationErrorResult("Interceptor Configuration Error");
+      }
+    }
+
+    //2. Remote Execution
+    final Map<String, String> env = shell.getEnv();
+    try {
+      response = shell.getOperationInvoker().processCommand(new CommandRequest(parseResult, env, fileData));
+    } catch(NotAuthorizedException e) {
+      return ResultBuilder.createGemFireUnAuthorizedErrorResult("Unauthorized. Reason : " + e.getMessage());
+    }
+    finally {
+      env.clear();
+    }
+
+    if (response == null) {
+      shell.logWarning("Response was null for: \"" + parseResult.getUserInput() + "\". (gfsh.isConnected=" + shell.isConnectedAndReady() + ")", null);
+      return ResultBuilder.createBadResponseErrorResult(" Error occurred while " +
+        "executing \"" + parseResult.getUserInput() + "\" on manager. " +
+        "Please check manager logs for error.");
+    }
+
+    if (logWrapper.fineEnabled()) {
+      logWrapper.fine("Received response :: "+response);
+    }
+    CommandResponse commandResponse = CommandResponseBuilder.prepareCommandResponseFromJson((String) response);
+
+    if (commandResponse.isFailedToPersist()) {
+      shell.printAsSevere(CliStrings.SHARED_CONFIGURATION_FAILED_TO_PERSIST_COMMAND_CHANGES);
+      logWrapper.severe(CliStrings.SHARED_CONFIGURATION_FAILED_TO_PERSIST_COMMAND_CHANGES);
+    }
+
+    String debugInfo = commandResponse.getDebugInfo();
+    if (debugInfo != null && !debugInfo.trim().isEmpty()) {
+      //TODO - Abhishek When debug is ON, log response in gfsh logs
+      //TODO - Abhishek handle \n better. Is it coming from GemFire formatter
+      debugInfo = debugInfo.replaceAll("\n\n\n", "\n");
+      debugInfo = debugInfo.replaceAll("\n\n", "\n");
+      debugInfo = debugInfo.replaceAll("\n", "\n[From Manager : "+commandResponse.getSender()+"]");
+      debugInfo = "[From Manager : "+commandResponse.getSender()+"]" + debugInfo;
+      LogWrapper.getInstance().info(debugInfo);
+    }
+    commandResult = ResultBuilder.fromJson((String) response);
+
+    //3. Post Remote Execution
+    if (interceptor != null) {
+      Result postExecResult = interceptor.postExecution(parseResult, commandResult);
+      if (postExecResult != null) {
+        if (Status.ERROR.equals(postExecResult.getStatus())) {
+          if (logWrapper.infoEnabled()) {
+            logWrapper.info("Post execution Result :: "+ResultBuilder.resultAsString(postExecResult));
+          }
+        } else if (logWrapper.fineEnabled()) {
+          logWrapper.fine("Post execution Result :: "+ResultBuilder.resultAsString(postExecResult));
+        }
+        commandResult = postExecResult;
+      }
+    }
+

MOV26 MOV26 MOV26 MOV26 MOV26 INS26 UPD40 INS40 MOV8 UPD66 MOV60 MOV60 INS25 MOV60 MOV60 MOV60 MOV25 MOV60 INS54 INS25 MOV41 INS12 INS38 INS8 INS8 INS12 INS8 MOV27 MOV8 MOV25 MOV21 INS44 INS8 MOV32 MOV21 MOV21 INS41 MOV21 INS44 INS8 MOV21 INS41 MOV32 INS38 INS43 INS42 INS21 INS33 INS43 INS42 INS41 MOV32 MOV32 INS42 INS7 INS42 INS32 INS42 INS32 INS42 INS42 INS27 INS41 INS42 INS42 INS27 INS45 INS32 MOV32 INS45 INS32 INS42 INS42 INS42 INS42 DEL38 DEL8 DEL42 DEL7 DEL21 DEL8 DEL42 DEL7 DEL21 DEL25 DEL8 DEL8 DEL25 DEL8
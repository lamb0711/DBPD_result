Merge branch 'develop' into feature/GEODE-17-2

-import com.gemstone.gemfire.LogWriter;
+import org.apache.logging.log4j.Logger;
+
-import com.gemstone.gemfire.distributed.internal.InternalDistributedSystem;
+import com.gemstone.gemfire.internal.logging.LogService;
- * Manages the free lists for a SimpleMemoryAllocatorImpl
+ * Manages the free lists and slabs for a MemoryAllocator
+  static final Logger logger = LogService.getLogger();
+
-  private final AddressableMemoryChunk[] slabs;
+  private final Slab[] slabs;
-  final private AtomicReferenceArray<SyncChunkStack> tinyFreeLists = new AtomicReferenceArray<SyncChunkStack>(TINY_FREE_LIST_COUNT);
+  final private AtomicReferenceArray<OffHeapStoredObjectAddressStack> tinyFreeLists = new AtomicReferenceArray<OffHeapStoredObjectAddressStack>(TINY_FREE_LIST_COUNT);
-  private final ConcurrentSkipListSet<ObjectChunk> hugeChunkSet = new ConcurrentSkipListSet<ObjectChunk>();
+  private final ConcurrentSkipListSet<OffHeapStoredObject> hugeChunkSet = new ConcurrentSkipListSet<OffHeapStoredObject>();
-  List<ObjectChunk> getLiveChunks() {
-    ArrayList<ObjectChunk> result = new ArrayList<ObjectChunk>();
+  List<OffHeapStoredObject> getLiveChunks() {
+    ArrayList<OffHeapStoredObject> result = new ArrayList<OffHeapStoredObject>();
-  private void getLiveChunks(AddressableMemoryChunk slab, List<ObjectChunk> result) {
+  private void getLiveChunks(Slab slab, List<OffHeapStoredObject> result) {
-    while (addr <= (slab.getMemoryAddress() + slab.getSize() - ObjectChunk.MIN_CHUNK_SIZE)) {
+    while (addr <= (slab.getMemoryAddress() + slab.getSize() - OffHeapStoredObject.MIN_CHUNK_SIZE)) {
-        addr = f.getMemoryAddress() + f.getSize();
+        addr = f.getAddress() + f.getSize();
-        int curChunkSize = ObjectChunk.getSize(addr);
-        int refCount = ObjectChunk.getRefCount(addr);
+        int curChunkSize = OffHeapStoredObject.getSize(addr);
+        int refCount = OffHeapStoredObject.getRefCount(addr);
-          result.add(new ObjectChunk(addr));
+          result.add(new OffHeapStoredObject(addr));
-      if (addr >= (f.getMemoryAddress() + f.getFreeIndex()) && addr < (f.getMemoryAddress() + f.getSize())) {
+      if (addr >= (f.getAddress() + f.getFreeIndex()) && addr < (f.getAddress() + f.getSize())) {
-      if (freeSpace >= ObjectChunk.MIN_CHUNK_SIZE) {
+      if (freeSpace >= OffHeapStoredObject.MIN_CHUNK_SIZE) {
-      SyncChunkStack cl = this.tinyFreeLists.get(i);
+      OffHeapStoredObjectAddressStack cl = this.tinyFreeLists.get(i);
-    for (ObjectChunk c: this.hugeChunkSet) {
+    for (OffHeapStoredObject c: this.hugeChunkSet) {
-  private final SimpleMemoryAllocatorImpl ma;
+  private final MemoryAllocatorImpl ma;
-  public FreeListManager(SimpleMemoryAllocatorImpl ma, final AddressableMemoryChunk[] slabs) {
+  public FreeListManager(MemoryAllocatorImpl ma, final Slab[] slabs) {
-  public ObjectChunk allocate(int size) {
+  public OffHeapStoredObject allocate(int size) {
-    ObjectChunk result = basicAllocate(size, true);
+    OffHeapStoredObject result = basicAllocate(size, true);
-  private ObjectChunk basicAllocate(int size, boolean useSlabs) {
+  private OffHeapStoredObject basicAllocate(int size, boolean useSlabs) {
-      size += ObjectChunk.OFF_HEAP_HEADER_SIZE;
+      size += OffHeapStoredObject.HEADER_SIZE;
-  private ObjectChunk allocateFromFragments(int chunkSize) {
+  private OffHeapStoredObject allocateFromFragments(int chunkSize) {
-        ObjectChunk result = allocateFromFragment(i, chunkSize);
+        OffHeapStoredObject result = allocateFromFragment(i, chunkSize);
-        ObjectChunk result = allocateFromFragment(i, chunkSize);
+        OffHeapStoredObject result = allocateFromFragment(i, chunkSize);
-    } while (compact(chunkSize));
+    } while (defragment(chunkSize));
-    if (InternalDistributedSystem.getAnyInstance() != null) {
-      LogWriter lw = InternalDistributedSystem.getAnyInstance().getLogWriter();
-      logOffHeapState(lw, chunkSize);
-    }
+    logOffHeapState(logger, chunkSize);
-  void logOffHeapState(LogWriter lw, int chunkSize) {
+  void logOffHeapState(Logger lw, int chunkSize) {
-    lw.info("OutOfOffHeapMemory allocating size of " + chunkSize + ". allocated=" + this.allocatedSize.get() + " compactions=" + this.compactCount.get() + " objects=" + stats.getObjects() + " free=" + stats.getFreeMemory() + " fragments=" + stats.getFragments() + " largestFragment=" + stats.getLargestFragment() + " fragmentation=" + stats.getFragmentation());
+    lw.info("OutOfOffHeapMemory allocating size of " + chunkSize + ". allocated=" + this.allocatedSize.get() + " defragmentations=" + this.defragmentationCount.get() + " objects=" + stats.getObjects() + " free=" + stats.getFreeMemory() + " fragments=" + stats.getFragments() + " largestFragment=" + stats.getLargestFragment() + " fragmentation=" + stats.getFragmentation());
-  private void logHugeState(LogWriter lw) {
-    for (ObjectChunk c: this.hugeChunkSet) {
+  private void logHugeState(Logger lw) {
+    for (OffHeapStoredObject c: this.hugeChunkSet) {
-  private void logTinyState(LogWriter lw) {
+  private void logTinyState(Logger lw) {
-      SyncChunkStack cl = this.tinyFreeLists.get(i);
+      OffHeapStoredObjectAddressStack cl = this.tinyFreeLists.get(i);
-  private void logFragmentState(LogWriter lw) {
+  private void logFragmentState(Logger lw) {
-        lw.info("Fragment at " + f.getMemoryAddress() + " of size " + f.getSize() + " has " + freeSpace + " bytes free.");
+        lw.info("Fragment at " + f.getAddress() + " of size " + f.getSize() + " has " + freeSpace + " bytes free.");
-  protected final AtomicInteger compactCount = new AtomicInteger();
+  protected final AtomicInteger defragmentationCount = new AtomicInteger();
-   * Compacts memory and returns true if enough memory to allocate chunkSize
+   * Defragments memory and returns true if enough memory to allocate chunkSize
-   * up to 2G then the compactor may unify them together into a single Chunk and our 32-bit chunkSize
+   * up to 2G then the FreeListManager may unify them together into a single Chunk and our 32-bit chunkSize
-  boolean compact(int chunkSize) {
-    final long startCompactionTime = this.ma.getStats().startCompaction();
-    final int countPreSync = this.compactCount.get();
-    afterCompactCountFetched();
+  boolean defragment(int chunkSize) {
+    final long startDefragmentationTime = this.ma.getStats().startDefragmentation();
+    final int countPreSync = this.defragmentationCount.get();
+    afterDefragmentationCountFetched();
-        if (this.compactCount.get() != countPreSync) {
-          // someone else did a compaction while we waited on the sync.
+        if (this.defragmentationCount.get() != countPreSync) {
+          // someone else did a defragmentation while we waited on the sync.
-        ArrayList<SyncChunkStack> freeChunks = new ArrayList<SyncChunkStack>();
+        ArrayList<OffHeapStoredObjectAddressStack> freeChunks = new ArrayList<OffHeapStoredObjectAddressStack>();
-        for (SyncChunkStack l: freeChunks) {
+        for (OffHeapStoredObjectAddressStack l: freeChunks) {
-                int lowSize = ObjectChunk.getSize(lowAddr);
+                int lowSize = OffHeapStoredObject.getSize(lowAddr);
-                  ObjectChunk.setSize(lowAddr, lowSize + ObjectChunk.getSize(addr));
+                  OffHeapStoredObject.setSize(lowAddr, lowSize + OffHeapStoredObject.getSize(addr));
-              int addrSize = ObjectChunk.getSize(addr);
+              int addrSize = OffHeapStoredObject.getSize(addr);
-                ObjectChunk.setSize(addr, addrSize + ObjectChunk.getSize(highAddr));
+                OffHeapStoredObject.setSize(addr, addrSize + OffHeapStoredObject.getSize(highAddr));
-                  int lowSize = ObjectChunk.getSize(lowAddr);
+                  int lowSize = OffHeapStoredObject.getSize(lowAddr);
-                    ObjectChunk.setSize(lowAddr, lowSize + addrSize);
+                    OffHeapStoredObject.setSize(lowAddr, lowSize + addrSize);
-          int lowSize = ObjectChunk.getSize(lowAddr);
+          int lowSize = OffHeapStoredObject.getSize(lowAddr);
-            ObjectChunk.setSize(lowAddr, lowSize + ObjectChunk.getSize(addr));
+            OffHeapStoredObject.setSize(lowAddr, lowSize + OffHeapStoredObject.getSize(addr));
-          int addrSize = ObjectChunk.getSize(addr);
+          int addrSize = OffHeapStoredObject.getSize(addr);
-        // Signal any waiters that a compaction happened.
-        this.compactCount.incrementAndGet();
+        // Signal any waiters that a defragmentation happened.
+        this.defragmentationCount.incrementAndGet();
-        updateFragmentation(largestFragment);
+        this.ma.getStats().setFragmentation(getFragmentation());
-      this.ma.getStats().endCompaction(startCompactionTime);
+      this.ma.getStats().endDefragmentation(startDefragmentationTime);
-  protected void afterCompactCountFetched() {
+  protected void afterDefragmentationCountFetched() {
-  private void updateFragmentation(long largestFragment) {      
-    long freeSize = getFreeMemory();
-
-    // Calculate free space fragmentation only if there is free space available.
-    if(freeSize > 0) {
-      long numerator = freeSize - largestFragment;
-
-      double percentage = (double) numerator / (double) freeSize;
-      percentage *= 100d;
-
-      int wholePercentage = (int) Math.rint(percentage);
-      this.ma.getStats().setFragmentation(wholePercentage);
+  protected int getFragmentCount() {
+    return this.fragmentList.size();
+  }
+  
+  protected int getFragmentation() {
+    if(getUsedMemory() == 0) {
+      //when no memory is used then there is no fragmentation
+      return 0;
-      // No free space? Then we have no free space fragmentation.
-      this.ma.getStats().setFragmentation(0);
+      int availableFragments = getFragmentCount();
+      if (availableFragments == 0) {
+        //zero fragments means no free memory then no fragmentation
+        return 0;
+      } else if (availableFragments == 1) {
+        //free memory is available as one fragment, so no fragmentation
+        return 0;
+      } else {
+        //more than 1 fragment is available so freeMemory is > ObjectChunk.MIN_CHUNK_SIZE
+        long freeMemory = getFreeMemory();
+        assert freeMemory > OffHeapStoredObject.MIN_CHUNK_SIZE;
+        long maxPossibleFragments = freeMemory / OffHeapStoredObject.MIN_CHUNK_SIZE;
+        double fragmentation = ((double) availableFragments /(double) maxPossibleFragments) * 100d;
+        return (int) Math.rint(fragmentation);
+      }
-  private void collectFreeChunks(List<SyncChunkStack> l) {
+  private void collectFreeChunks(List<OffHeapStoredObjectAddressStack> l) {
-  private void collectFreeFragmentChunks(List<SyncChunkStack> l) {
+  private void collectFreeFragmentChunks(List<OffHeapStoredObjectAddressStack> l) {
-    SyncChunkStack result = new SyncChunkStack();
+    OffHeapStoredObjectAddressStack result = new OffHeapStoredObjectAddressStack();
-      } while (diff >= ObjectChunk.MIN_CHUNK_SIZE && !f.allocate(offset, offset+diff));
-      if (diff < ObjectChunk.MIN_CHUNK_SIZE) {
-        // If diff > 0 then that memory will be lost during compaction.
+      } while (diff >= OffHeapStoredObject.MIN_CHUNK_SIZE && !f.allocate(offset, offset+diff));
+      if (diff < OffHeapStoredObject.MIN_CHUNK_SIZE) {
+        // If diff > 0 then that memory will be lost during defragmentation.
-      long chunkAddr = f.getMemoryAddress()+offset;
-      ObjectChunk.setSize(chunkAddr, diff);
+      long chunkAddr = f.getAddress()+offset;
+      OffHeapStoredObject.setSize(chunkAddr, diff);
-    // The compaction will create new fragments.
+    // The defragmentation will create new fragments.
-  private void collectFreeTinyChunks(List<SyncChunkStack> l) {
+  private void collectFreeTinyChunks(List<OffHeapStoredObjectAddressStack> l) {
-      SyncChunkStack cl = this.tinyFreeLists.get(i);
+      OffHeapStoredObjectAddressStack cl = this.tinyFreeLists.get(i);
-          l.add(new SyncChunkStack(head));
+          l.add(new OffHeapStoredObjectAddressStack(head));
-  private void collectFreeHugeChunks(List<SyncChunkStack> l) {
-    ObjectChunk c = this.hugeChunkSet.pollFirst();
-    SyncChunkStack result = null;
+  private void collectFreeHugeChunks(List<OffHeapStoredObjectAddressStack> l) {
+    OffHeapStoredObject c = this.hugeChunkSet.pollFirst();
+    OffHeapStoredObjectAddressStack result = null;
-        result = new SyncChunkStack();
+        result = new OffHeapStoredObjectAddressStack();
-      result.offer(c.getMemoryAddress());
+      result.offer(c.getAddress());
-  ObjectChunk allocateFromFragment(final int fragIdx, final int chunkSize) {
+  OffHeapStoredObject allocateFromFragment(final int fragIdx, final int chunkSize) {
-      // A concurrent compaction can cause this.
+      // A concurrent defragmentation can cause this.
-        if (extraSize < ObjectChunk.MIN_CHUNK_SIZE) {
+        if (extraSize < OffHeapStoredObject.MIN_CHUNK_SIZE) {
-          ObjectChunk result = new ObjectChunk(fragment.getMemoryAddress()+oldOffset, chunkSize+extraSize);
+          OffHeapStoredObject result = new OffHeapStoredObject(fragment.getAddress()+oldOffset, chunkSize+extraSize);
-          ObjectChunk result = basicAllocate(chunkSize, false);
+          OffHeapStoredObject result = basicAllocate(chunkSize, false);
-  private ObjectChunk allocateTiny(int size, boolean useFragments) {
+  private OffHeapStoredObject allocateTiny(int size, boolean useFragments) {
-  private ObjectChunk basicAllocate(int idx, int multiple, int offset, AtomicReferenceArray<SyncChunkStack> freeLists, boolean useFragments) {
-    SyncChunkStack clq = freeLists.get(idx);
+  private OffHeapStoredObject basicAllocate(int idx, int multiple, int offset, AtomicReferenceArray<OffHeapStoredObjectAddressStack> freeLists, boolean useFragments) {
+    OffHeapStoredObjectAddressStack clq = freeLists.get(idx);
-        ObjectChunk result = new ObjectChunk(memAddr);
+        OffHeapStoredObject result = new OffHeapStoredObject(memAddr);
-  private ObjectChunk allocateHuge(int size, boolean useFragments) {
+  private OffHeapStoredObject allocateHuge(int size, boolean useFragments) {
-    ObjectChunk sizeHolder = new FakeChunk(size);
-    NavigableSet<ObjectChunk> ts = this.hugeChunkSet.tailSet(sizeHolder);
-    ObjectChunk result = ts.pollFirst();
+    OffHeapStoredObject sizeHolder = new SearchMarker(size);
+    NavigableSet<OffHeapStoredObject> ts = this.hugeChunkSet.tailSet(sizeHolder);
+    OffHeapStoredObject result = ts.pollFirst();
-      if (result.getSize() - (HUGE_MULTIPLE - ObjectChunk.OFF_HEAP_HEADER_SIZE) < size) {
+      if (result.getSize() - (HUGE_MULTIPLE - OffHeapStoredObject.HEADER_SIZE) < size) {
-  private void checkDataIntegrity(ObjectChunk data) {
+  private void checkDataIntegrity(OffHeapStoredObject data) {
-   * ConcurrentSkipListSet. This is not a real chunk
+   * ConcurrentSkipListSet. This is not a real OffHeapStoredObject
-  private static class FakeChunk extends ObjectChunk {
+  private static class SearchMarker extends OffHeapStoredObject {
-    public FakeChunk(int size) {
+    public SearchMarker(int size) {
-      ObjectChunk.fill(addr);
+      OffHeapStoredObject.fill(addr);
-    int cSize = ObjectChunk.getSize(addr);
+    int cSize = OffHeapStoredObject.getSize(addr);
-  private void basicFree(long addr, int idx, AtomicReferenceArray<SyncChunkStack> freeLists) {
-    SyncChunkStack clq = freeLists.get(idx);
+  private void basicFree(long addr, int idx, AtomicReferenceArray<OffHeapStoredObjectAddressStack> freeLists) {
+    OffHeapStoredObjectAddressStack clq = freeLists.get(idx);
-  protected SyncChunkStack createFreeListForEmptySlot(AtomicReferenceArray<SyncChunkStack> freeLists, int idx) {
-    return new SyncChunkStack();
+  protected OffHeapStoredObjectAddressStack createFreeListForEmptySlot(AtomicReferenceArray<OffHeapStoredObjectAddressStack> freeLists, int idx) {
+    return new OffHeapStoredObjectAddressStack();
-    this.hugeChunkSet.add(new ObjectChunk(addr)); // TODO make this a collection of longs
+    this.hugeChunkSet.add(new OffHeapStoredObject(addr)); // TODO make this a collection of longs
-            return Long.valueOf(o1.getMemoryAddress()).compareTo(o2.getMemoryAddress());
+            return Long.valueOf(o1.getAddress()).compareTo(o2.getAddress());
-  private void addBlocksFromChunks(Collection<ObjectChunk> src, List<MemoryBlock> dest) {
-    for (ObjectChunk chunk : src) {
+  private void addBlocksFromChunks(Collection<OffHeapStoredObject> src, List<MemoryBlock> dest) {
+    for (OffHeapStoredObject chunk : src) {
-    final SimpleMemoryAllocatorImpl sma = this.ma;
+    final MemoryAllocatorImpl sma = this.ma;
-        addr = ObjectChunk.getNext(addr);
+        addr = OffHeapStoredObject.getNext(addr);
-            return Long.valueOf(o1.getMemoryAddress()).compareTo(o2.getMemoryAddress());
+            return Long.valueOf(o1.getAddress()).compareTo(o2.getAddress());
-  private static final class TinyMemoryBlock implements MemoryBlock {
+  protected static final class TinyMemoryBlock implements MemoryBlock {
-    private TinyMemoryBlock(long address, int freeListId) {
+    protected TinyMemoryBlock(long address, int freeListId) {
-    public long getMemoryAddress() {
+    public long getAddress() {
-      return ObjectChunk.getSize(address);
+      return OffHeapStoredObject.getSize(address);
-        return getMemoryAddress() == ((TinyMemoryBlock) o).getMemoryAddress();
+        return getAddress() == ((TinyMemoryBlock) o).getAddress();
-      long value = this.getMemoryAddress();
+      long value = this.getAddress();
-      slabs[i].release();
+      slabs[i].free();
-  boolean okToReuse(AddressableMemoryChunk[] newSlabs) {
+  boolean okToReuse(Slab[] newSlabs) {
-      AddressableMemoryChunk slab = this.slabs[i];
+      Slab slab = this.slabs[i];

UPD40 UPD40 INS23 INS31 INS83 INS83 INS43 INS59 UPD5 UPD74 MOV74 UPD74 MOV74 UPD74 UPD43 UPD43 UPD43 UPD43 INS8 UPD42 UPD42 INS83 INS39 INS42 INS8 UPD83 UPD39 UPD42 INS8 UPD43 UPD43 UPD43 UPD43 UPD42 UPD43 UPD43 UPD83 UPD66 INS42 INS42 INS32 UPD43 UPD43 UPD43 UPD43 UPD43 UPD74 UPD42 UPD43 UPD5 UPD42 UPD42 UPD42 MOV21 UPD43 UPD43 UPD43 UPD43 UPD42 INS41 INS25 UPD74 UPD74 UPD74 UPD74 UPD42 UPD42 UPD42 UPD74 UPD42 UPD43 UPD42 UPD42 UPD74 UPD42 UPD74 UPD74 UPD83 UPD42 UPD5 INS42 INS42 UPD42 UPD42 UPD74 MOV74 UPD42 UPD74 MOV74 UPD42 UPD74 MOV74 UPD42 UPD43 UPD42 UPD43 UPD43 UPD42 UPD42 UPD42 UPD42 UPD66 UPD66 INS32 INS27 INS8 INS8 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD74 UPD43 UPD42 UPD66 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD42 UPD43 UPD42 UPD42 UPD42 UPD42 UPD43 UPD42 UPD42 INS22 INS42 INS32 INS34 INS41 INS60 MOV25 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD42 UPD42 UPD42 UPD42 UPD43 UPD42 UPD43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD74 MOV74 UPD43 UPD42 UPD45 UPD42 UPD43 UPD42 INS52 INS42 INS42 INS34 INS39 INS59 UPD27 INS8 INS25 UPD43 UPD43 UPD43 UPD42 UPD42 UPD42 UPD43 UPD42 UPD42 UPD43 UPD43 UPD40 UPD40 UPD42 UPD40 UPD42 UPD42 UPD42 UPD42 INS42 INS32 UPD42 INS41 INS27 INS8 MOV8 UPD42 UPD40 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD43 UPD42 UPD74 MOV74 INS42 INS34 INS42 INS34 INS41 MOV60 INS6 INS41 UPD40 UPD42 UPD43 UPD42 UPD42 UPD43 UPD43 MOV32 UPD42 INS32 INS34 INS27 INS11 UPD42 UPD40 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD74 MOV74 UPD42 UPD42 UPD42 MOV42 UPD42 INS42 INS40 UPD42 UPD27 UPD42 INS27 MOV39 MOV32 UPD43 UPD43 UPD43 UPD43 UPD40 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD42 INS40 INS36 INS34 UPD42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD42 UPD42 UPD42 INS27 UPD43 UPD43 UPD42 UPD42 UPD42 UPD42 MOV11 MOV11 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25 DEL8 DEL42 DEL27 DEL42 DEL34 DEL7 DEL21 DEL39 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL34 DEL32 DEL21 DEL8 DEL39 DEL42 DEL44 DEL8
Merge branch 'develop' into feature/GEODE-420

# Conflicts:
#	geode-assembly/src/test/java/com/gemstone/gemfire/rest/internal/web/controllers/RestAPIsWithSSLDUnitTest.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/DistributionConfig.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/membership/gms/GMSUtil.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/AcceptorImpl.java
#	geode-core/src/main/java/com/gemstone/gemfire/management/internal/ManagementAgent.java
#	geode-core/src/main/java/org/apache/geode/redis/GeodeRedisServer.java
#	geode-core/src/test/java/com/gemstone/gemfire/distributed/LocatorDUnitTest.java

-
+import java.io.IOException;
+import java.io.Serializable;
-import java.security.Principal;
+import org.apache.commons.lang.SerializationException;
-import org.apache.geode.security.GeodePermission;
-import org.apache.geode.security.GeodePermission.Operation;
-import org.apache.geode.security.GeodePermission.Resource;
+import org.apache.geode.security.ResourcePermission;
+import org.apache.geode.security.ResourcePermission.Operation;
+import org.apache.geode.security.ResourcePermission.Resource;
+import com.gemstone.gemfire.GemFireIOException;
+import com.gemstone.gemfire.internal.cache.EntryEventImpl;
+import com.gemstone.gemfire.internal.util.BlobHelper;
-  private static Logger logger = LogService.getLogger();
+  private static Logger logger = LogService.getLogger(LogService.SECURITY_LOGGER_NAME);
+  private static PostProcessor postProcessor;
+  private static SecurityManager securityManager;
+  private static boolean isIntegratedSecurity;
+  private static boolean isClientAuthenticator;
+  private static boolean isPeerAuthenticator;
-   * It first looks the shiro subject in AccessControlContext since JMX will use multiple threads to process operations from the same client.
-   * then it looks into Shiro's thead context.
+   * It first looks the shiro subject in AccessControlContext since JMX will
+   * use multiple threads to process operations from the same client, then it
+   * looks into Shiro's thead context.
+   *
-   * @param username
-   * @param password
-   * this binds the passed-in subject to the executing thread, normally, you would do this:
+   * this binds the passed-in subject to the executing thread, normally, you
+   * would do this:
+   *
-    authorize(new GeodePermission(resource, operation, regionName, key));
+    authorize(new ResourcePermission(resource, operation, regionName, key));
-  public static void authorize(GeodePermission context) {
+  public static void authorize(ResourcePermission context) {
-  private static PostProcessor postProcessor;
-  private static SecurityManager securityManager;
-  private static boolean isIntegratedSecurity;
-  private static boolean isClientAuthenticator;
-  private static boolean isPeerAuthenticator;
-
-   * @param securityProps
-   * postProcess call already has this logic built in, you don't need to call this everytime you call postProcess.
-   * But if your postProcess is pretty involved with preparations and you need to bypass it entirely, call this first.
+   * postProcess call already has this logic built in, you don't need to call
+   * this everytime you call postProcess. But if your postProcess is pretty
+   * involved with preparations and you need to bypass it entirely, call this
+   * first.
-  public static Object postProcess(String regionPath, Object key, Object result){
-    if(postProcessor == null)
-      return result;
-
-    Subject subject = getSubject();
-
-    if(subject == null)
-      return result;
-
-    String regionName = StringUtils.stripStart(regionPath, "/");
-    return postProcessor.processRegionValue((Principal)subject.getPrincipal(), regionName, key,  result);
+  public static Object postProcess(String regionPath, Object key, Object value, boolean valueIsSerialized){
+    return postProcess(null, regionPath, key, value, valueIsSerialized);
+  public static Object postProcess(Serializable principal, String regionPath, Object key, Object value, boolean valueIsSerialized) {
+    if (!needPostProcess())
+      return value;
+
+    if (principal == null) {
+      Subject subject = getSubject();
+      if (subject == null)
+        return value;
+      principal = (Serializable) subject.getPrincipal();
+    }
+
+    String regionName = StringUtils.stripStart(regionPath, "/");
+    Object newValue = null;
+
+    // if the data is a byte array, but the data itself is supposed to be an object, we need to desearized it before we pass
+    // it to the callback.
+    if (valueIsSerialized && value instanceof byte[]) {
+      try {
+        Object oldObj = EntryEventImpl.deserialize((byte[]) value);
+        Object newObj = postProcessor.processRegionValue(principal, regionName, key,  oldObj);
+        newValue = BlobHelper.serializeToBlob(newObj);
+      } catch (IOException|SerializationException e) {
+        throw new GemFireIOException("Exception de/serializing entry value", e);
+      }
+    }
+    else {
+      newValue = postProcessor.processRegionValue(principal, regionName, key, value);
+    }
+
+    return newValue;
+  }
+
+  private static void checkSameClass(Object obj1, Object obj2){
+
+  }
-   * this method would never return null, it either throws an exception or returns an object
-   * @param className
-   * @param expectedClazz
-   * @param <T>
-   * @return
+   * this method would never return null, it either throws an exception or
+   * returns an object
-   * this method would never return null, it either throws an exception or returns an object
-   * @param factoryMethodName
-   * @param expectedClazz
-   * @param <T>
-   * @return
+   * this method would never return null, it either throws an exception or
+   * returns an object
-   * this method would never return null, it either throws an exception or returns an object
-   * @param classOrMethod
-   * @param expectedClazz
-   * @param <T>
-   * @return an object of type expectedClazz. This method would never return null. It either returns an non-null
-   * object or throws exception.
+   * this method would never return null, it either throws an exception or
+   * returns an object
+   *
+   * @return an object of type expectedClazz. This method would never return
+   * null. It either returns an non-null object or throws exception.
+  public static PostProcessor getPostProcessor() {
+    return postProcessor;
+  }

MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 MOV23 MOV23 MOV23 MOV23 MOV23 UPD40 INS40 INS40 UPD40 UPD40 UPD40 INS40 INS40 INS40 INS31 INS31 INS31 INS43 INS44 INS44 INS44 INS8 INS83 INS83 MOV43 INS42 INS44 MOV44 MOV44 INS44 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS83 INS43 INS42 INS8 UPD43 INS42 INS43 INS42 INS43 INS42 UPD42 INS39 INS42 INS41 INS43 INS42 INS43 INS42 INS39 INS42 INS25 INS25 MOV60 INS60 INS25 INS41 INS43 INS42 INS43 INS42 UPD65 UPD65 UPD65 INS42 INS41 INS40 UPD66 INS66 UPD66 UPD66 INS66 UPD42 UPD66 INS66 UPD66 INS66 INS42 INS42 INS32 INS42 INS42 INS38 INS41 INS27 MOV8 INS43 INS59 INS27 INS8 INS8 INS42 INS42 INS42 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS33 INS21 INS42 INS42 INS33 INS42 INS62 INS54 INS21 UPD43 INS42 INS7 INS42 INS5 INS8 INS12 INS7 UPD42 UPD42 INS42 MOV11 INS39 INS85 INS60 INS60 INS21 INS44 INS8 INS42 INS32 UPD43 INS43 INS59 INS43 INS59 INS7 INS84 INS42 INS53 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS43 INS43 INS14 INS42 INS42 INS11 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS45 INS42 INS5 INS42 INS42 INS39 INS85 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL33 DEL27 DEL42 DEL41 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42 DEL65 DEL66 DEL65 DEL42 DEL65 DEL42 DEL65 DEL42
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-/** Creates instances of {@link RegionAttributes}. An <code>AttributesFactory</code>
- * instance maintains state for creating <code>RegionAttributes</code> instances.
- * The setter methods are used to change the settings that will be used for
- * creating the next attributes instance with the {@link #create}
- * method. If you create a factory with the default constructor, then the
- * factory is set up to create attributes with all default settings. You can
- * also create a factory by providing a <code>RegionAttributes</code>, which
- * will set up the new factory with the settings provided in that attributes
- * instance.
+/**
+ * Creates instances of {@link RegionAttributes}. An <code>AttributesFactory</code> instance
+ * maintains state for creating <code>RegionAttributes</code> instances. The setter methods are used
+ * to change the settings that will be used for creating the next attributes instance with the
+ * {@link #create} method. If you create a factory with the default constructor, then the factory is
+ * set up to create attributes with all default settings. You can also create a factory by providing
+ * a <code>RegionAttributes</code>, which will set up the new factory with the settings provided in
+ * that attributes instance.
- * <p>Once a <code>RegionAttributes</code> is created, it can only be modified
- * after it has been used to create a <code>Region</code>, and then only by
- * using an {@link AttributesMutator} obtained from the region.
+ * <p>
+ * Once a <code>RegionAttributes</code> is created, it can only be modified after it has been used
+ * to create a <code>Region</code>, and then only by using an {@link AttributesMutator} obtained
+ * from the region.
- *     <dd>User-implemented plug-in for loading data on cache misses.<br>
- *        {@link #setCacheLoader} {@link RegionAttributes#getCacheLoader}
- *        {@link AttributesMutator#setCacheLoader}</dd>
+ * <dd>User-implemented plug-in for loading data on cache misses.<br>
+ * {@link #setCacheLoader} {@link RegionAttributes#getCacheLoader}
+ * {@link AttributesMutator#setCacheLoader}</dd>
- *     <dd>User-implemented plug-in for intercepting cache modifications, e.g.
- *         for writing to an external data source.<br>
- *         {@link #setCacheWriter} {@link RegionAttributes#getCacheWriter}
- *         {@link AttributesMutator#setCacheWriter}</dd>
+ * <dd>User-implemented plug-in for intercepting cache modifications, e.g. for writing to an
+ * external data source.<br>
+ * {@link #setCacheWriter} {@link RegionAttributes#getCacheWriter}
+ * {@link AttributesMutator#setCacheWriter}</dd>
- *     <dd>User-implemented plug-in for receiving and handling cache related events.<br>
- *         {@link #addCacheListener} {@link #initCacheListeners}
- *         {@link #initCacheListeners}
- *         {@link RegionAttributes#getCacheListeners}
- *         {@link AttributesMutator#initCacheListeners}
- *         {@link AttributesMutator#addCacheListener}
- *         {@link AttributesMutator#removeCacheListener}</dd>
+ * <dd>User-implemented plug-in for receiving and handling cache related events.<br>
+ * {@link #addCacheListener} {@link #initCacheListeners} {@link #initCacheListeners}
+ * {@link RegionAttributes#getCacheListeners} {@link AttributesMutator#initCacheListeners}
+ * {@link AttributesMutator#addCacheListener} {@link AttributesMutator#removeCacheListener}</dd>
- * <dt>{@link Scope}[<em>default:</em> {@link Scope#DISTRIBUTED_NO_ACK}]
- * </dt>
- * <dd>Properties of distribution for the region, including whether it is
- * distributed at all, whether acknowledgements are required, and whether
- * distributed synchronization is required. <br>
+ * <dt>{@link Scope}[<em>default:</em> {@link Scope#DISTRIBUTED_NO_ACK}]</dt>
+ * <dd>Properties of distribution for the region, including whether it is distributed at all,
+ * whether acknowledgements are required, and whether distributed synchronization is required. <br>
- *     <dd>Whether or not acks required by <code>Scope.DISTRIBUTED_ACK</code>
- *     are sent after an operation is processed. If <code>true</code>
- *     then remote caches will ACK before processing an operation sent
- *     by the cache that has set earlyAck to <code>true</code>.
- *     Note that this attribute is only meaningful on the cache that
- *     is initiating an operation; it does not matter what it is set to
- *     on the cache that receives the operation.<br>
- *     {@link #setEarlyAck} {@link RegionAttributes#getEarlyAck}</dd>
-
+ * <dd>Whether or not acks required by <code>Scope.DISTRIBUTED_ACK</code> are sent after an
+ * operation is processed. If <code>true</code> then remote caches will ACK before processing an
+ * operation sent by the cache that has set earlyAck to <code>true</code>. Note that this attribute
+ * is only meaningful on the cache that is initiating an operation; it does not matter what it is
+ * set to on the cache that receives the operation.<br>
+ * {@link #setEarlyAck} {@link RegionAttributes#getEarlyAck}</dd>
+ * 
- *     <dd>How will the region in this cache subscribe to other distributed
- *     instances of this region.
- *     <br>
- *     {@link #setSubscriptionAttributes} {@link RegionAttributes#getSubscriptionAttributes}</dd>
+ * <dd>How will the region in this cache subscribe to other distributed instances of this region.
+ * <br>
+ * {@link #setSubscriptionAttributes} {@link RegionAttributes#getSubscriptionAttributes}</dd>
- *     <dd>Whether or not conflation is enabled for sending
- *     messages to async peers. Async peers are those whose
- *     <code>async-distribution-timeout</code> gemfire.property is greater
- *     than zero. AsyncConflation is ignored if the scope is
- *     <code>DISTRIBUTED_ACK</code> or <code>GLOBAL</code>.
- *     Conflation is only done on entry update operations. It is done
- *     by dropping the earlier update from the message queue.
- *     {@link #setEnableAsyncConflation} {@link RegionAttributes#getEnableAsyncConflation}</dd>
+ * <dd>Whether or not conflation is enabled for sending messages to async peers. Async peers are
+ * those whose <code>async-distribution-timeout</code> gemfire.property is greater than zero.
+ * AsyncConflation is ignored if the scope is <code>DISTRIBUTED_ACK</code> or <code>GLOBAL</code>.
+ * Conflation is only done on entry update operations. It is done by dropping the earlier update
+ * from the message queue. {@link #setEnableAsyncConflation}
+ * {@link RegionAttributes#getEnableAsyncConflation}</dd>
- *     <dd>Whether or not this region is a client that is to use
- *     connections from the named pool to communicate with servers.
- *     If <code>null</code>, then it is not a client.
- *     If <code>non-null</code>, then the named pool will be used.
- *     {@link #setPoolName} {@link RegionAttributes#getPoolName}</dd>
+ * <dd>Whether or not this region is a client that is to use connections from the named pool to
+ * communicate with servers. If <code>null</code>, then it is not a client. If
+ * <code>non-null</code>, then the named pool will be used. {@link #setPoolName}
+ * {@link RegionAttributes#getPoolName}</dd>
- *     <dd>Whether or not conflation is enabled for sending
- *     messages from a cache server to its clients. Note: This parameter
- *     is only valid for cache server to client communication. It has no
- *     effect in peer to peer communication.
- *     If <code>true</code>, messages will be conflated before they are
- *     sent from a cache server to its clients. Only the latest value
- *     will be sent.
- *     Note that this attribute is only meaningful in a client server
- *     topology.
- *     {@link #setEnableSubscriptionConflation} {@link RegionAttributes#getEnableSubscriptionConflation}</dd>
+ * <dd>Whether or not conflation is enabled for sending messages from a cache server to its clients.
+ * Note: This parameter is only valid for cache server to client communication. It has no effect in
+ * peer to peer communication. If <code>true</code>, messages will be conflated before they are sent
+ * from a cache server to its clients. Only the latest value will be sent. Note that this attribute
+ * is only meaningful in a client server topology. {@link #setEnableSubscriptionConflation}
+ * {@link RegionAttributes#getEnableSubscriptionConflation}</dd>
- *     <dd>Whether or not a region is a publisher. Publishers are regions
- *         that will have distributed write operations done on them.
- *         If a publisher is also a replicate then it will be used
- *         as the preferred source for initializing other replicates.
- *     {@link #setPublisher} {@link RegionAttributes#getPublisher}</dd>
+ * <dd>Whether or not a region is a publisher. Publishers are regions that will have distributed
+ * write operations done on them. If a publisher is also a replicate then it will be used as the
+ * preferred source for initializing other replicates. {@link #setPublisher}
+ * {@link RegionAttributes#getPublisher}</dd>
- *     <dd>Whether or not value is cloned before appling <code>Delta</code>s
- *     If <code>false</code>, value will not be cloned
- *     {@link #setCloningEnabled} {@link RegionAttributes#getCloningEnabled()}</dd></dt>
+ * <dd>Whether or not value is cloned before appling <code>Delta</code>s If <code>false</code>,
+ * value will not be cloned {@link #setCloningEnabled}
+ * {@link RegionAttributes#getCloningEnabled()}</dd></dt>
- * <h4>Storage (see also <a href="package-summary.html#storage">package summary
- * </a>)</h4>
+ * <h4>Storage (see also <a href="package-summary.html#storage">package summary </a>)</h4>
- *     <dd>Specifies the data storage policy.<br>
- *         {@link #setDataPolicy} {@link RegionAttributes#getDataPolicy}</dd>
+ * <dd>Specifies the data storage policy.<br>
+ * {@link #setDataPolicy} {@link RegionAttributes#getDataPolicy}</dd>
- *     <dd><em>Deprecated</em>, use DataPolicy instead.</dd>
+ * <dd><em>Deprecated</em>, use DataPolicy instead.</dd>
- *      <dd>{@link EvictionAttributes} are the replacement for the deprecated and removed CapacityController interface.
- *          EvictionAttributes describe the {@link EvictionAlgorithm} and the {@link EvictionAction}
- *          as well as the various conditions under which the algorithm perform the action
- *          e.g. when the maximum number of entries has been reached or
- *          the maximum percentage of JVM heap has been consumed.
- *          Setting <code>EvictionAttributes</code> installs an eviction controller
- *          on the Region instantiated with the associated RegionAttributes </dd>
+ * <dd>{@link EvictionAttributes} are the replacement for the deprecated and removed
+ * CapacityController interface. EvictionAttributes describe the {@link EvictionAlgorithm} and the
+ * {@link EvictionAction} as well as the various conditions under which the algorithm perform the
+ * action e.g. when the maximum number of entries has been reached or the maximum percentage of JVM
+ * heap has been consumed. Setting <code>EvictionAttributes</code> installs an eviction controller
+ * on the Region instantiated with the associated RegionAttributes</dd>
- *     <dd>The Class to constrain the keys to in the region.<br>
- *         {@link #setKeyConstraint} {@link RegionAttributes#getKeyConstraint}</dd>
+ * <dd>The Class to constrain the keys to in the region.<br>
+ * {@link #setKeyConstraint} {@link RegionAttributes#getKeyConstraint}</dd>
- *     <dd>The Class to constrain the values to in the region. In addition to the
- *         utility of this for applications in general, a <code>valueConstraint</code>
- *         is helpful for compiling queries.<br>
- *         {@link #setValueConstraint} {@link RegionAttributes#getValueConstraint}</dd>
+ * <dd>The Class to constrain the values to in the region. In addition to the utility of this for
+ * applications in general, a <code>valueConstraint</code> is helpful for compiling queries.<br>
+ * {@link #setValueConstraint} {@link RegionAttributes#getValueConstraint}</dd>
- * {@link java.util.HashMap} {@link #setLoadFactor}
- * {@link RegionAttributes#getLoadFactor}</dd>
+ * {@link java.util.HashMap} {@link #setLoadFactor} {@link RegionAttributes#getLoadFactor}</dd>
- * <dd>The allowed concurrency among updates to values in the region is guided
- * by the <tt>concurrencyLevel</tt>, which is used as a hint for internal
- * sizing. The actual concurrency will vary. Ideally, you should choose a value
- * to accommodate as many threads as will ever concurrently modify values in the
- * region. Using a significantly higher value than you need can waste space and
- * time, and a significantly lower value can lead to thread contention. But
- * overestimates and underestimates within an order of magnitude do not usually
- * have much noticeable impact. A value of one is appropriate when it is known
- * that only one thread will modify and all others will only read. <br>
- * {@link #setConcurrencyLevel} {@link RegionAttributes#getConcurrencyLevel}
- * </dd>
+ * <dd>The allowed concurrency among updates to values in the region is guided by the
+ * <tt>concurrencyLevel</tt>, which is used as a hint for internal sizing. The actual concurrency
+ * will vary. Ideally, you should choose a value to accommodate as many threads as will ever
+ * concurrently modify values in the region. Using a significantly higher value than you need can
+ * waste space and time, and a significantly lower value can lead to thread contention. But
+ * overestimates and underestimates within an order of magnitude do not usually have much noticeable
+ * impact. A value of one is appropriate when it is known that only one thread will modify and all
+ * others will only read. <br>
+ * {@link #setConcurrencyLevel} {@link RegionAttributes#getConcurrencyLevel}</dd>
- * <dd>Enables a distributed versioning algorithm that detects concurrency
- * conflicts in regions and ensures that changes to an
- * entry are not applied in a different order in other members.  This can
- * cause operations to be conflated, so that some cache listeners may see
- * an event while others do not, but it guarantees that the system will
- * be consistent.
- * </dd>
+ * <dd>Enables a distributed versioning algorithm that detects concurrency conflicts in regions and
+ * ensures that changes to an entry are not applied in a different order in other members. This can
+ * cause operations to be conflated, so that some cache listeners may see an event while others do
+ * not, but it guarantees that the system will be consistent.</dd>
- * <dd>Whether statistics are enabled for this region. The default is disabled,
- * which conserves on memory. <br>
- * {@link #setStatisticsEnabled} {@link RegionAttributes#getStatisticsEnabled}
- * </dd>
+ * <dd>Whether statistics are enabled for this region. The default is disabled, which conserves on
+ * memory. <br>
+ * {@link #setStatisticsEnabled} {@link RegionAttributes#getStatisticsEnabled}</dd>
- *     <dd>Whether JTA transactions are ignored for this region.  The
- *     default is to look for and join JTA transactions for operations
- *     performed on a region.
+ * <dd>Whether JTA transactions are ignored for this region. The default is to look for and join JTA
+ * transactions for operations performed on a region.
- *    <dd>If not <code>null</code> then this region will write its data
- *    to the named {@link DiskStore}.<br>
- *    {@link #setDiskStoreName} {@link RegionAttributes#getDiskStoreName}</dd>
+ * <dd>If not <code>null</code> then this region will write its data to the named
+ * {@link DiskStore}.<br>
+ * {@link #setDiskStoreName} {@link RegionAttributes#getDiskStoreName}</dd>
- *    <dd>If <code>true</code> then any writes to disk done for this region
- *    will be done synchronously. This means that they will be in the file system
- *    buffer before the operation doing the write returns.<br>
- *    If <code>false</code> then any writes to disk done for this region
- *    will be done asynchronously. This means that they are queued up to be written
- *    and when they are actually written to the file system buffer is determined
- *    by the region's {@link DiskStore} configuration.
- *    Asynchronous writes will be conflated if the same entry is written while a
- *    previous operation for the same entry is still in the queue.<br>
- *    {@link #setDiskSynchronous} {@link RegionAttributes#isDiskSynchronous}</dd>
-
+ * <dd>If <code>true</code> then any writes to disk done for this region will be done synchronously.
+ * This means that they will be in the file system buffer before the operation doing the write
+ * returns.<br>
+ * If <code>false</code> then any writes to disk done for this region will be done asynchronously.
+ * This means that they are queued up to be written and when they are actually written to the file
+ * system buffer is determined by the region's {@link DiskStore} configuration. Asynchronous writes
+ * will be conflated if the same entry is written while a previous operation for the same entry is
+ * still in the queue.<br>
+ * {@link #setDiskSynchronous} {@link RegionAttributes#isDiskSynchronous}</dd>
+ * 
- *     <dd>Whether or not a persistent backup should be made of the
- *     region.<br>
- *     {@link #setPersistBackup} {@link RegionAttributes#getPersistBackup}</dd>
- *     <dd><em>Deprecated</em>, use {@link DataPolicy#PERSISTENT_REPLICATE} or {@link DataPolicy#PERSISTENT_PARTITION} instead.</dd>
+ * <dd>Whether or not a persistent backup should be made of the region.<br>
+ * {@link #setPersistBackup} {@link RegionAttributes#getPersistBackup}</dd>
+ * <dd><em>Deprecated</em>, use {@link DataPolicy#PERSISTENT_REPLICATE} or
+ * {@link DataPolicy#PERSISTENT_PARTITION} instead.</dd>
- * <dt>DiskWriteAttributes [<em>default:</em> Asynchronously write to
- *            disk every second (a <code>timeInterval</code> of 1000 and a
- *            <code>byteThreshold</codE> of 0). <code>rollOplogs</code> is set to true and
- *            <code>maxOplogSize</code> is set to 1024 MB]</dt>
- *     <dd>How region data should be written to disk.  Determines
- *     whether data should be written synchronously or asynchronously.
- *     Data that is written asynchronously can be written at a certain
- *     {@linkplain DiskWriteAttributes#getTimeInterval time interval}
- *     or once a certain number of {@linkplain
- *     DiskWriteAttributes#getBytesThreshold bytes of data} have been
- *     enqueued.<br>
- *     {@link DiskWriteAttributes} {@link #setDiskWriteAttributes} {@link RegionAttributes#getDiskWriteAttributes}</dd>
- *     <dd><em>Deprecated</em>, use {@link #setDiskStoreName} and {@link #setDiskSynchronous} instead.</dd>
+ * <dt>DiskWriteAttributes [<em>default:</em> Asynchronously write to disk every second (a
+ * <code>timeInterval</code> of 1000 and a <code>byteThreshold</codE> of 0). <code>rollOplogs</code>
+ * is set to true and <code>maxOplogSize</code> is set to 1024 MB]</dt>
+ * <dd>How region data should be written to disk. Determines whether data should be written
+ * synchronously or asynchronously. Data that is written asynchronously can be written at a certain
+ * {@linkplain DiskWriteAttributes#getTimeInterval time interval} or once a certain number of
+ * {@linkplain DiskWriteAttributes#getBytesThreshold bytes of data} have been enqueued.<br>
+ * {@link DiskWriteAttributes} {@link #setDiskWriteAttributes}
+ * {@link RegionAttributes#getDiskWriteAttributes}</dd>
+ * <dd><em>Deprecated</em>, use {@link #setDiskStoreName} and {@link #setDiskSynchronous}
+ * instead.</dd>
- * <dt>DiskDirs [<em>default:</em> Current working directory (<code>user.dir</code> {@linkplain System#getProperties system property})]</dt>
- *     <dd>The directories to which the region's data are written.  If
- *     multiple directories are used, GemFire will attempt to distribute the
- *     data evenly among them. <br>
- *     {@link #setDiskDirs} {@link RegionAttributes#getDiskDirs}</dd>
- *     <dd><em>Deprecated</em>, use {@link #setDiskStoreName} instead.</dd>
+ * <dt>DiskDirs [<em>default:</em> Current working directory (<code>user.dir</code>
+ * {@linkplain System#getProperties system property})]</dt>
+ * <dd>The directories to which the region's data are written. If multiple directories are used,
+ * GemFire will attempt to distribute the data evenly among them. <br>
+ * {@link #setDiskDirs} {@link RegionAttributes#getDiskDirs}</dd>
+ * <dd><em>Deprecated</em>, use {@link #setDiskStoreName} instead.</dd>
- * <dd> The size of the directory to which region's data is written.<br>
+ * <dd>The size of the directory to which region's data is written.<br>
- * <dt>{@link PartitionAttributes} [<em>default:</em> <code>null</code>, meaning no region partitioning]</dt>
- *     <dd>How region data is partitioned among the members of the
- *     distributed system.
- *     <br>
- *     {@link #setPartitionAttributes} {@link RegionAttributes#getPartitionAttributes}</dd>
+ * <dt>{@link PartitionAttributes} [<em>default:</em> <code>null</code>, meaning no region
+ * partitioning]</dt>
+ * <dd>How region data is partitioned among the members of the distributed system. <br>
+ * {@link #setPartitionAttributes} {@link RegionAttributes#getPartitionAttributes}</dd>
- *     <dd>How access to the region is affected when one or more required roles
- *     are missing from the region membership.
- *     <br>
- *     {@link #setMembershipAttributes} {@link RegionAttributes#getMembershipAttributes}</dd>
- * <dd><em>Deprecated</em>, this API is scheduled to be removed</dd>
- * </dt>
+ * <dd>How access to the region is affected when one or more required roles are missing from the
+ * region membership. <br>
+ * {@link #setMembershipAttributes} {@link RegionAttributes#getMembershipAttributes}</dd>
+ * <dd><em>Deprecated</em>, this API is scheduled to be removed</dd></dt>
- *     <dd>Should this process become lock grantor for the region?</dd><br>
- *     {@link #setLockGrantor} {@link RegionAttributes#isLockGrantor}
- *     {@link Region#becomeLockGrantor}
+ * <dd>Should this process become lock grantor for the region?</dd><br>
+ * {@link #setLockGrantor} {@link RegionAttributes#isLockGrantor} {@link Region#becomeLockGrantor}
- *     <dd>Are indexes built over in this region updated
- *         synchronously when the underlying data is
- *         modified?</dd><br>
- *     {@link #setIndexMaintenanceSynchronous} {@link
- *     RegionAttributes#getIndexMaintenanceSynchronous}
+ * <dd>Are indexes built over in this region updated synchronously when the underlying data is
+ * modified?</dd><br>
+ * {@link #setIndexMaintenanceSynchronous} {@link RegionAttributes#getIndexMaintenanceSynchronous}
- * <p>Note that the RegionAttributes are not distributed with the region.
+ * <p>
+ * Note that the RegionAttributes are not distributed with the region.
- * <a name="compatibility"><h3>Compatibility Rules</h3>
- * <h4>RegionAttributes Creation Constraints</h4>
- * If any of the following compatibility rules are violated when
- * {@link #create}</code> is called then an
- * {@link IllegalStateException} is thrown.
+ * <a name="compatibility">
+ * <h3>Compatibility Rules</h3>
+ * <h4>RegionAttributes Creation Constraints</h4> If any of the following compatibility rules are
+ * violated when {@link #create}</code> is called then an {@link IllegalStateException} is thrown.
- * <a name="creationConstraints"><h3>Creation Constraints</h3>
+ * <a name="creationConstraints">
+ * <h3>Creation Constraints</h3>
- * If any of the following rules are violated when {@link
- * Region#createSubregion createSubregion} or {@link Cache#createRegion
- * createRegion} are called, then an
- * <code>IllegalStateException</code> is thrown.
+ * If any of the following rules are violated when {@link Region#createSubregion createSubregion} or
+ * {@link Cache#createRegion createRegion} are called, then an <code>IllegalStateException</code> is
+ * thrown.
- * <li><code>Scope.GLOBAL</code> is illegal if there is any other cache in
- * the distributed system that has the same region with
- * <code>Scope.DISTRIBUTED_NO_ACK</code> or <code>Scope.DISTRIBUTED_ACK</code>.
- * </li>
- * <li><code>Scope.DISTRIBUTED_ACK</code> is illegal if there is any other
- * cache in the distributed system that has the same region with
- * <code>Scope.DISTRIBUTED_NO_ACK</code> or <code>Scope.GLOBAL</code>.
- * </li>
- * <li><code>Scope.DISTRIBUTED_NO_ACK</code> is illegal if there is any other
- * cache in the distributed system that has the same region with
- * <code>Scope.DISTRIBUTED_ACK</code> or <code>Scope.GLOBAL</code>.</li>
+ * <li><code>Scope.GLOBAL</code> is illegal if there is any other cache in the distributed system
+ * that has the same region with <code>Scope.DISTRIBUTED_NO_ACK</code> or
+ * <code>Scope.DISTRIBUTED_ACK</code>.</li>
+ * <li><code>Scope.DISTRIBUTED_ACK</code> is illegal if there is any other cache in the distributed
+ * system that has the same region with <code>Scope.DISTRIBUTED_NO_ACK</code> or
+ * <code>Scope.GLOBAL</code>.</li>
+ * <li><code>Scope.DISTRIBUTED_NO_ACK</code> is illegal if there is any other cache in the
+ * distributed system that has the same region with <code>Scope.DISTRIBUTED_ACK</code> or
+ * <code>Scope.GLOBAL</code>.</li>
- * @deprecated as of 6.5 use {@link Cache#createRegionFactory(RegionShortcut)} or {@link ClientCache#createClientRegionFactory(ClientRegionShortcut)} instead.
+ * @deprecated as of 6.5 use {@link Cache#createRegionFactory(RegionShortcut)} or
+ *             {@link ClientCache#createClientRegionFactory(ClientRegionShortcut)} instead.
-public class AttributesFactory<K,V> {
-  private final RegionAttributesImpl<K,V> regionAttributes = new RegionAttributesImpl<K,V>();
+public class AttributesFactory<K, V> {
+  private final RegionAttributesImpl<K, V> regionAttributes = new RegionAttributesImpl<K, V>();
-   * <p>Current value: <code>true</code> each.
+   * <p>
+   * Current value: <code>true</code> each.
+   * 
-  
-  /**
-   * Creates a new instance of AttributesFactory ready to create a
-   * <code>RegionAttributes</code> with default settings.
-   */
-  public AttributesFactory() {
-  }
-   * Creates a new instance of AttributesFactory ready to create a
-   * <code>RegionAttributes</code> with the same settings as those in the
-   * specified <code>RegionAttributes</code>.
+   * Creates a new instance of AttributesFactory ready to create a <code>RegionAttributes</code>
+   * with default settings.
+   */
+  public AttributesFactory() {}
+
+  /**
+   * Creates a new instance of AttributesFactory ready to create a <code>RegionAttributes</code>
+   * with the same settings as those in the specified <code>RegionAttributes</code>.
-   * @param regionAttributes
-   *          the <code>RegionAttributes</code> used to initialize this
-   *          AttributesFactory
+   * @param regionAttributes the <code>RegionAttributes</code> used to initialize this
+   *        AttributesFactory
-  public AttributesFactory(RegionAttributes<K,V> regionAttributes) {
+  public AttributesFactory(RegionAttributes<K, V> regionAttributes) {
-      this.regionAttributes.cacheListeners = new ArrayList<CacheListener<K,V>>(Arrays.asList(regionAttributes.getCacheListeners()));
+      this.regionAttributes.cacheListeners =
+          new ArrayList<CacheListener<K, V>>(Arrays.asList(regionAttributes.getCacheListeners()));
-    this.regionAttributes.regionTimeToLive = regionAttributes
-        .getRegionTimeToLive().getTimeout();
-    this.regionAttributes.regionTimeToLiveExpirationAction = regionAttributes
-        .getRegionTimeToLive().getAction();
-    this.regionAttributes.regionIdleTimeout = regionAttributes
-        .getRegionIdleTimeout().getTimeout();
-    this.regionAttributes.regionIdleTimeoutExpirationAction = regionAttributes
-        .getRegionIdleTimeout().getAction();
-    
-    this.regionAttributes.entryTimeToLive = regionAttributes
-        .getEntryTimeToLive().getTimeout();
-    this.regionAttributes.entryTimeToLiveExpirationAction = regionAttributes
-        .getEntryTimeToLive().getAction();
-    this.regionAttributes.customEntryTimeToLive = regionAttributes
-        .getCustomEntryTimeToLive();
-    this.regionAttributes.entryIdleTimeout = regionAttributes
-        .getEntryIdleTimeout().getTimeout();
-    this.regionAttributes.entryIdleTimeoutExpirationAction = regionAttributes
-        .getEntryIdleTimeout().getAction();
-    this.regionAttributes.customEntryIdleTimeout = regionAttributes
-        .getCustomEntryIdleTimeout();
-    
+    this.regionAttributes.regionTimeToLive = regionAttributes.getRegionTimeToLive().getTimeout();
+    this.regionAttributes.regionTimeToLiveExpirationAction =
+        regionAttributes.getRegionTimeToLive().getAction();
+    this.regionAttributes.regionIdleTimeout = regionAttributes.getRegionIdleTimeout().getTimeout();
+    this.regionAttributes.regionIdleTimeoutExpirationAction =
+        regionAttributes.getRegionIdleTimeout().getAction();
+
+    this.regionAttributes.entryTimeToLive = regionAttributes.getEntryTimeToLive().getTimeout();
+    this.regionAttributes.entryTimeToLiveExpirationAction =
+        regionAttributes.getEntryTimeToLive().getAction();
+    this.regionAttributes.customEntryTimeToLive = regionAttributes.getCustomEntryTimeToLive();
+    this.regionAttributes.entryIdleTimeout = regionAttributes.getEntryIdleTimeout().getTimeout();
+    this.regionAttributes.entryIdleTimeoutExpirationAction =
+        regionAttributes.getEntryIdleTimeout().getAction();
+    this.regionAttributes.customEntryIdleTimeout = regionAttributes.getCustomEntryIdleTimeout();
+
-    this.regionAttributes.valueConstraint = regionAttributes
-        .getValueConstraint();
-    this.regionAttributes.initialCapacity = regionAttributes
-        .getInitialCapacity();
+    this.regionAttributes.valueConstraint = regionAttributes.getValueConstraint();
+    this.regionAttributes.initialCapacity = regionAttributes.getInitialCapacity();
-    this.regionAttributes.concurrencyLevel = regionAttributes
-        .getConcurrencyLevel();
+    this.regionAttributes.concurrencyLevel = regionAttributes.getConcurrencyLevel();
-      this.regionAttributes.diskWriteAttributes = regionAttributes
-      .getDiskWriteAttributes();
+      this.regionAttributes.diskWriteAttributes = regionAttributes.getDiskWriteAttributes();
-    this.regionAttributes.indexMaintenanceSynchronous = regionAttributes
-        .getIndexMaintenanceSynchronous();
-    this.regionAttributes.partitionAttributes = regionAttributes
-        .getPartitionAttributes();
-    this.regionAttributes.evictionAttributes = (EvictionAttributesImpl)regionAttributes
-        .getEvictionAttributes();
+    this.regionAttributes.indexMaintenanceSynchronous =
+        regionAttributes.getIndexMaintenanceSynchronous();
+    this.regionAttributes.partitionAttributes = regionAttributes.getPartitionAttributes();
+    this.regionAttributes.evictionAttributes =
+        (EvictionAttributesImpl) regionAttributes.getEvictionAttributes();
-    this.regionAttributes.evictionAttributes = (EvictionAttributesImpl) regionAttributes.getEvictionAttributes();
+    this.regionAttributes.evictionAttributes =
+        (EvictionAttributesImpl) regionAttributes.getEvictionAttributes();
-    this.regionAttributes.enableSubscriptionConflation = regionAttributes.getEnableSubscriptionConflation();
+    this.regionAttributes.enableSubscriptionConflation =
+        regionAttributes.getEnableSubscriptionConflation();
-    this.regionAttributes.gatewaySenderIds = new CopyOnWriteArraySet<String>(regionAttributes.getGatewaySenderIds());
-    this.regionAttributes.asyncEventQueueIds = new CopyOnWriteArraySet<String>(regionAttributes.getAsyncEventQueueIds());
+    this.regionAttributes.gatewaySenderIds =
+        new CopyOnWriteArraySet<String>(regionAttributes.getGatewaySenderIds());
+    this.regionAttributes.asyncEventQueueIds =
+        new CopyOnWriteArraySet<String>(regionAttributes.getAsyncEventQueueIds());
-      this.regionAttributes.setIndexes(((UserSpecifiedRegionAttributes<K,V>) regionAttributes).getIndexes());
+      this.regionAttributes
+          .setIndexes(((UserSpecifiedRegionAttributes<K, V>) regionAttributes).getIndexes());
-      // Selectively set has* fields to true, propigating those non-default 
+      // Selectively set has* fields to true, propigating those non-default
-      UserSpecifiedRegionAttributes<K,V> nonDefault = (UserSpecifiedRegionAttributes<K,V>) regionAttributes;
+      UserSpecifiedRegionAttributes<K, V> nonDefault =
+          (UserSpecifiedRegionAttributes<K, V>) regionAttributes;
-      
-      
-      
-//      
-//      // Special Partitioned Region handling by
-//      // pretending the user didn't explicitly ask for the default scope
-//      if (AbstractRegion.DEFAULT_SCOPE.equals(this.regionAttributes.getScope())) {
-//        this.regionAttributes.setHasScope(false); 
-//      }
+
+
+
+      //
+      // // Special Partitioned Region handling by
+      // // pretending the user didn't explicitly ask for the default scope
+      // if (AbstractRegion.DEFAULT_SCOPE.equals(this.regionAttributes.getScope())) {
+      // this.regionAttributes.setHasScope(false);
+      // }
-    
+
-   * @param cacheLoader
-   *          the cache loader or null if no loader
+   * @param cacheLoader the cache loader or null if no loader
-  public void setCacheLoader(CacheLoader<K,V> cacheLoader)
-  {
+  public void setCacheLoader(CacheLoader<K, V> cacheLoader) {
-   * @param cacheWriter
-   *          the cache writer or null if no cache writer
+   * @param cacheWriter the cache writer or null if no cache writer
-  public void setCacheWriter(CacheWriter<K,V> cacheWriter)
-  {
+  public void setCacheWriter(CacheWriter<K, V> cacheWriter) {
-  /** Sets the CacheListener for the next <code>RegionAttributes</code> created.
-   * Any existing cache listeners on this factory are removed.
+  /**
+   * Sets the CacheListener for the next <code>RegionAttributes</code> created. Any existing cache
+   * listeners on this factory are removed.
+   * 
-  public void setCacheListener(CacheListener<K,V> aListener) {
-    ArrayList<CacheListener<K,V>> col;
+  public void setCacheListener(CacheListener<K, V> aListener) {
+    ArrayList<CacheListener<K, V>> col;
-      col = new ArrayList<CacheListener<K,V>>(1);
+      col = new ArrayList<CacheListener<K, V>>(1);
+
+   * 
-  public void addCacheListener(CacheListener<K,V> aListener) {
+  public void addCacheListener(CacheListener<K, V> aListener) {
-      throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_ADDCACHELISTENER_PARAMETER_WAS_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_ADDCACHELISTENER_PARAMETER_WAS_NULL
+              .toLocalizedString());
+
+   * 
-  public void initCacheListeners(CacheListener<K,V>[] newListeners) {
+  public void initCacheListeners(CacheListener<K, V>[] newListeners) {
-        List<CacheListener<K,V>> nl = Arrays.asList(newListeners);
+        List<CacheListener<K, V>> nl = Arrays.asList(newListeners);
-          throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_INITCACHELISTENERS_PARAMETER_HAD_A_NULL_ELEMENT.toLocalizedString());
+          throw new IllegalArgumentException(
+              LocalizedStrings.AttributesFactory_INITCACHELISTENERS_PARAMETER_HAD_A_NULL_ELEMENT
+                  .toLocalizedString());
-        this.regionAttributes.cacheListeners = new ArrayList<CacheListener<K,V>>(nl);
+        this.regionAttributes.cacheListeners = new ArrayList<CacheListener<K, V>>(nl);
-   * <code>RegionAttributes</code> created.
-   * Default is 0 which indicates no expiration of this type.
+   * <code>RegionAttributes</code> created. Default is 0 which indicates no expiration of this type.
-   * @param idleTimeout
-   *          the idleTimeout ExpirationAttributes for entries in this region
-   * @throws IllegalArgumentException
-   *           if idleTimeout is null
+   * @param idleTimeout the idleTimeout ExpirationAttributes for entries in this region
+   * @throws IllegalArgumentException if idleTimeout is null
-  public void setEntryIdleTimeout(ExpirationAttributes idleTimeout)
-  {
+  public void setEntryIdleTimeout(ExpirationAttributes idleTimeout) {
-      throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_IDLETIMEOUT_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_IDLETIMEOUT_MUST_NOT_BE_NULL.toLocalizedString());
-    this.regionAttributes.entryIdleTimeoutExpirationAction = idleTimeout
-        .getAction();
+    this.regionAttributes.entryIdleTimeoutExpirationAction = idleTimeout.getAction();
-   * Sets the idleTimeout CustomExpiry for the next <code>RegionAttributes</code>
-   * created.
+   * Sets the idleTimeout CustomExpiry for the next <code>RegionAttributes</code> created.
-  public void setCustomEntryIdleTimeout(CustomExpiry<K,V> custom) {
+  public void setCustomEntryIdleTimeout(CustomExpiry<K, V> custom) {
-  
+
-   * <code>RegionAttributes</code> created.
-   * Default is 0 which indicates no expiration of this type.
+   * <code>RegionAttributes</code> created. Default is 0 which indicates no expiration of this type.
-   * @param timeToLive
-   *          the timeToLive ExpirationAttributes for entries in this region
-   * @throws IllegalArgumentException
-   *           if timeToLive is null
+   * @param timeToLive the timeToLive ExpirationAttributes for entries in this region
+   * @throws IllegalArgumentException if timeToLive is null
-  public void setEntryTimeToLive(ExpirationAttributes timeToLive)
-  {
+  public void setEntryTimeToLive(ExpirationAttributes timeToLive) {
-      throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_TIMETOLIVE_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_TIMETOLIVE_MUST_NOT_BE_NULL.toLocalizedString());
-    this.regionAttributes.entryTimeToLiveExpirationAction = timeToLive
-        .getAction();
+    this.regionAttributes.entryTimeToLiveExpirationAction = timeToLive.getAction();
-   * Sets the custom timeToLive for the next <code>RegionAttributes</code>
-   * created.
+   * Sets the custom timeToLive for the next <code>RegionAttributes</code> created.
-   * @param custom the CustomExpiry to use, none if the default for the region
-   * is to be used.
+   * @param custom the CustomExpiry to use, none if the default for the region is to be used.
-  public void setCustomEntryTimeToLive(CustomExpiry<K,V> custom) {
+  public void setCustomEntryTimeToLive(CustomExpiry<K, V> custom) {
-  
-  /**
-   * Sets the idleTimeout expiration attributes for the region itself for the
-   * next <code>RegionAttributes</code> created.
-   * Default is 0 which indicates no expiration of this type is set. 
-   *
-   * @param idleTimeout
-   *          the ExpirationAttributes for this region idleTimeout
-   * @throws IllegalArgumentException
-   *           if idleTimeout is null
-   */
-  public void setRegionIdleTimeout(ExpirationAttributes idleTimeout)
-  {
-    if (idleTimeout == null) {
-      throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_IDLETIMEOUT_MUST_NOT_BE_NULL.toLocalizedString());
-    }
-    this.regionAttributes.regionIdleTimeout = idleTimeout.getTimeout();
-    this.regionAttributes.regionIdleTimeoutExpirationAction = idleTimeout
-        .getAction();
-    this.regionAttributes.setHasRegionIdleTimeout(true);
-  }
-  
-   * Sets the timeToLive expiration attributes for the region itself for the
-   * next <code>RegionAttributes</code> created.
-   * Default is 0 i.e. no expiration of this type.
+   * Sets the idleTimeout expiration attributes for the region itself for the next
+   * <code>RegionAttributes</code> created. Default is 0 which indicates no expiration of this type
+   * is set.
-   * @param timeToLive
-   *          the ExpirationAttributes for this region timeToLive
-   * @throws IllegalArgumentException
-   *           if timeToLive is null
+   * @param idleTimeout the ExpirationAttributes for this region idleTimeout
+   * @throws IllegalArgumentException if idleTimeout is null
-  public void setRegionTimeToLive(ExpirationAttributes timeToLive)
-  {
+  public void setRegionIdleTimeout(ExpirationAttributes idleTimeout) {
+    if (idleTimeout == null) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_IDLETIMEOUT_MUST_NOT_BE_NULL.toLocalizedString());
+    }
+    this.regionAttributes.regionIdleTimeout = idleTimeout.getTimeout();
+    this.regionAttributes.regionIdleTimeoutExpirationAction = idleTimeout.getAction();
+    this.regionAttributes.setHasRegionIdleTimeout(true);
+  }
+
+
+  /**
+   * Sets the timeToLive expiration attributes for the region itself for the next
+   * <code>RegionAttributes</code> created. Default is 0 i.e. no expiration of this type.
+   *
+   * @param timeToLive the ExpirationAttributes for this region timeToLive
+   * @throws IllegalArgumentException if timeToLive is null
+   */
+  public void setRegionTimeToLive(ExpirationAttributes timeToLive) {
-      throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_TIMETOLIVE_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_TIMETOLIVE_MUST_NOT_BE_NULL.toLocalizedString());
-    this.regionAttributes.regionTimeToLiveExpirationAction = timeToLive
-        .getAction();
+    this.regionAttributes.regionTimeToLiveExpirationAction = timeToLive.getAction();
-   * Sets the scope for the next <code>RegionAttributes</code> created.
-   * Default scope is DISTRIBUTED_NO_ACK. Refer gemfire documentation for more details on this.
-   * @param scopeType
-   *          the type of Scope to use for the region
-   * @throws IllegalArgumentException
-   *           if scopeType is null
+   * Sets the scope for the next <code>RegionAttributes</code> created. Default scope is
+   * DISTRIBUTED_NO_ACK. Refer gemfire documentation for more details on this.
+   * 
+   * @param scopeType the type of Scope to use for the region
+   * @throws IllegalArgumentException if scopeType is null
-  public void setScope(Scope scopeType)
-  {
+  public void setScope(Scope scopeType) {
-      throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_SCOPETYPE_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_SCOPETYPE_MUST_NOT_BE_NULL.toLocalizedString());
-   * Sets the EvictionController for the next <code>RegionAttributes</code>
-   * created. Use one of the creation methods on {@link EvictionAttributes} e.g.
-   * {@link EvictionAttributes#createLRUHeapAttributes()} to create the desired
-   * instance for this <code>AttributesFactory</code>
+   * Sets the EvictionController for the next <code>RegionAttributes</code> created. Use one of the
+   * creation methods on {@link EvictionAttributes} e.g.
+   * {@link EvictionAttributes#createLRUHeapAttributes()} to create the desired instance for this
+   * <code>AttributesFactory</code>
-   * @param evictAttrs
-   *          Explains how and when eviction occurs in the Region.
+   * @param evictAttrs Explains how and when eviction occurs in the Region.
-   public void setEvictionAttributes(EvictionAttributes evictAttrs) {
-     if (evictAttrs != null) {
-       this.regionAttributes.evictionAttributes = (EvictionAttributesImpl) evictAttrs;
-     } else {
-       this.regionAttributes.evictionAttributes = new EvictionAttributesImpl();
-     }
-     this.regionAttributes.setHasEvictionAttributes(true);
-   }
+  public void setEvictionAttributes(EvictionAttributes evictAttrs) {
+    if (evictAttrs != null) {
+      this.regionAttributes.evictionAttributes = (EvictionAttributesImpl) evictAttrs;
+    } else {
+      this.regionAttributes.evictionAttributes = new EvictionAttributesImpl();
+    }
+    this.regionAttributes.setHasEvictionAttributes(true);
+  }
-   /** Sets the mirror type for the next <code>RegionAttributes</code> created.
+  /**
+   * Sets the mirror type for the next <code>RegionAttributes</code> created.
+   * 
-      throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_MIRRORTYPE_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_MIRRORTYPE_MUST_NOT_BE_NULL.toLocalizedString());
-  /** Sets the data policy for the next <code>RegionAttributes</code> created.
-   * Default data policy is 'Normal'. Please refer gemfire documentation for more details on this.
+
+  /**
+   * Sets the data policy for the next <code>RegionAttributes</code> created. Default data policy is
+   * 'Normal'. Please refer gemfire documentation for more details on this.
+   * 
-      throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_DATAPOLICY_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_DATAPOLICY_MUST_NOT_BE_NULL.toLocalizedString());
-      if ( !PartitionedRegionHelper.ALLOWED_DATA_POLICIES.contains(dataPolicy) ) {
-        throw new IllegalStateException( LocalizedStrings.AttributesFactory_DATA_POLICIES_OTHER_THAN_0_ARE_NOT_SUPPORTED_FOR_PARTITIONED_REGIONS
-            .toLocalizedString(PartitionedRegionHelper.ALLOWED_DATA_POLICIES));
+      if (!PartitionedRegionHelper.ALLOWED_DATA_POLICIES.contains(dataPolicy)) {
+        throw new IllegalStateException(
+            LocalizedStrings.AttributesFactory_DATA_POLICIES_OTHER_THAN_0_ARE_NOT_SUPPORTED_FOR_PARTITIONED_REGIONS
+                .toLocalizedString(PartitionedRegionHelper.ALLOWED_DATA_POLICIES));
-  /** Sets the key constraint for the next <code>RegionAttributes</code> created.
-   * Keys in the region will be constrained to this class (or subclass).
-   * Any attempt to store a key of an incompatible type in the region will
-   * cause a <code>ClassCastException</code> to be thrown.
+  /**
+   * Sets the key constraint for the next <code>RegionAttributes</code> created. Keys in the region
+   * will be constrained to this class (or subclass). Any attempt to store a key of an incompatible
+   * type in the region will cause a <code>ClassCastException</code> to be thrown.
+   * 
-   * @throws IllegalArgumentException if <code>keyConstraint</code> is a class
-   * denoting a primitive type
+   * @throws IllegalArgumentException if <code>keyConstraint</code> is a class denoting a primitive
+   *         type
-      throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_KEYCONSTRAINT_MUST_NOT_BE_A_PRIMITIVE_TYPE.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_KEYCONSTRAINT_MUST_NOT_BE_A_PRIMITIVE_TYPE
+              .toLocalizedString());
-  /** Sets the value constraint for the next <code>RegionAttributes</code> created.
-   * Values in the region will be constrained to this class (or subclass).
-   * Any attempt to store a value of an incompatible type in the region will
-   * cause a <code>ClassCastException</code> to be thrown.
+  /**
+   * Sets the value constraint for the next <code>RegionAttributes</code> created. Values in the
+   * region will be constrained to this class (or subclass). Any attempt to store a value of an
+   * incompatible type in the region will cause a <code>ClassCastException</code> to be thrown.
+   * 
-   * @throws IllegalArgumentException if <code>valueConstraint</code> is a class
-   * denoting a primitive type
+   * @throws IllegalArgumentException if <code>valueConstraint</code> is a class denoting a
+   *         primitive type
-      throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_VALUECONSTRAINT_MUST_NOT_BE_A_PRIMITIVE_TYPE.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_VALUECONSTRAINT_MUST_NOT_BE_A_PRIMITIVE_TYPE
+              .toLocalizedString());
-  /** Sets the entry initial capacity for the next <code>RegionAttributes</code>
-   * created. This value
-   * is used in initializing the map that holds the entries.
-   * Default is 16.
+  /**
+   * Sets the entry initial capacity for the next <code>RegionAttributes</code> created. This value
+   * is used in initializing the map that holds the entries. Default is 16.
+   * 
-        throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_INITIALCAPACITY_MUST_BE_0.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_INITIALCAPACITY_MUST_BE_0.toLocalizedString());
-  /** Sets the entry load factor for the next <code>RegionAttributes</code>
-   * created. This value is
-   * used in initializing the map that holds the entries.
-   * Default is 0.75.
+  /**
+   * Sets the entry load factor for the next <code>RegionAttributes</code> created. This value is
+   * used in initializing the map that holds the entries. Default is 0.75.
+   * 
-        throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_LOADFACTOR_MUST_BE_0_VALUE_IS_0.toLocalizedString(new Float(loadFactor)));
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_LOADFACTOR_MUST_BE_0_VALUE_IS_0
+              .toLocalizedString(new Float(loadFactor)));
-  /** Sets the concurrency level of the next <code>RegionAttributes</code>
-   * created. This value is used in initializing the map that holds the entries.
-   * Default is 16.
+  /**
+   * Sets the concurrency level of the next <code>RegionAttributes</code> created. This value is
+   * used in initializing the map that holds the entries. Default is 16.
+   * 
-        throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_CONCURRENCYLEVEL_MUST_BE_0.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_CONCURRENCYLEVEL_MUST_BE_0.toLocalizedString());
-  
+
-   * Enables or disabled concurrent modification checks.  Concurrency checks are enabled
-   * by default.
+   * Enables or disabled concurrent modification checks. Concurrency checks are enabled by default.
+   * 
-   * Sets whether or not a persistent backup should be made of the
-   * region.
+   * Sets whether or not a persistent backup should be made of the region.
+
-   * @deprecated This setting no longer has any effect. 
+   * @deprecated This setting no longer has any effect.
-  
+
-//    this.regionAttributes.publisher = v;
-//    this.regionAttributes.setHasPublisher(true);
+    // this.regionAttributes.publisher = v;
+    // this.regionAttributes.setHasPublisher(true);
-   * Sets whether or not conflation is enabled for sending messages
-   * to async peers.
-   * Default value is false.
+   * Sets whether or not conflation is enabled for sending messages to async peers. Default value is
+   * false.
-  
+
-   * Sets whether or not conflation is enabled for sending messages
-   * from a cache server to its clients.
-   * Default is false.
+   * Sets whether or not conflation is enabled for sending messages from a cache server to its
+   * clients. Default is false.
+   * 
-      throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_GATEWAY_SENDER_ID_IS_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_GATEWAY_SENDER_ID_IS_NULL.toLocalizedString());
-  
+
+   * 
-      throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_GATEWAY_SENDER_ID_IS_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_GATEWAY_SENDER_ID_IS_NULL.toLocalizedString());
-  
+
-   * Sets whether or not conflation is enabled for sending messages
-   * from a cache server to its clients.
+   * Sets whether or not conflation is enabled for sending messages from a cache server to its
+   * clients.
-   * Sets whether or not conflation is enabled for sending messages
-   * from a cache server to its clients.
+   * Sets whether or not conflation is enabled for sending messages from a cache server to its
+   * clients.
-  */
+   */
-      throw new IllegalStateException(LocalizedStrings.DiskStore_Deprecated_API_0_Cannot_Mix_With_DiskStore_1
-          .toLocalizedString(new Object[] {"setDiskWriteAttributes", this.regionAttributes.getDiskStoreName()}));
+      throw new IllegalStateException(
+          LocalizedStrings.DiskStore_Deprecated_API_0_Cannot_Mix_With_DiskStore_1.toLocalizedString(
+              new Object[] {"setDiskWriteAttributes", this.regionAttributes.getDiskStoreName()}));
-   * Sets the directories with
-   * the default size of 10240 MB to which the region's data is written
+   * Sets the directories with the default size of 10240 MB to which the region's data is written
-      throw new IllegalStateException(LocalizedStrings.DiskStore_Deprecated_API_0_Cannot_Mix_With_DiskStore_1
-          .toLocalizedString(new Object[] {"setDiskDirs", this.regionAttributes.getDiskStoreName()}));
+      throw new IllegalStateException(
+          LocalizedStrings.DiskStore_Deprecated_API_0_Cannot_Mix_With_DiskStore_1.toLocalizedString(
+              new Object[] {"setDiskDirs", this.regionAttributes.getDiskStoreName()}));
-    for (int i=0; i < diskDirs.length; i++) {
+    for (int i = 0; i < diskDirs.length; i++) {
-   * Sets the DiskStore name attribute.
-   * This causes the region to use the {@link DiskStore}.
+   * Sets the DiskStore name attribute. This causes the region to use the {@link DiskStore}.
+   * 
-    if (this.regionAttributes.hasDiskDirs() ||  this.regionAttributes.hasDiskWriteAttributes()) {
-      throw new IllegalStateException(LocalizedStrings.DiskStore_Deprecated_API_0_Cannot_Mix_With_DiskStore_1
-          .toLocalizedString(new Object[] {"setDiskDirs or setDiskWriteAttributes", name}));
+    if (this.regionAttributes.hasDiskDirs() || this.regionAttributes.hasDiskWriteAttributes()) {
+      throw new IllegalStateException(
+          LocalizedStrings.DiskStore_Deprecated_API_0_Cannot_Mix_With_DiskStore_1
+              .toLocalizedString(new Object[] {"setDiskDirs or setDiskWriteAttributes", name}));
-  
+
-   * Sets whether or not the writing to the disk is synchronous.
-   * Default is true.
+   * Sets whether or not the writing to the disk is synchronous. Default is true.
-   * @param isSynchronous
-   *          boolean if true indicates synchronous writes
+   * @param isSynchronous boolean if true indicates synchronous writes
-  public void setDiskSynchronous(boolean isSynchronous)
-  {
+  public void setDiskSynchronous(boolean isSynchronous) {
-      DiskWriteAttributesFactory dwaf = new DiskWriteAttributesFactory(this.regionAttributes.diskWriteAttributes);
+      DiskWriteAttributesFactory dwaf =
+          new DiskWriteAttributesFactory(this.regionAttributes.diskWriteAttributes);
-        this.regionAttributes.diskWriteAttributes = DiskWriteAttributesImpl.getDefaultSyncInstance();
+        this.regionAttributes.diskWriteAttributes =
+            DiskWriteAttributesImpl.getDefaultSyncInstance();
-        this.regionAttributes.diskWriteAttributes = DiskWriteAttributesImpl.getDefaultAsyncInstance();
+        this.regionAttributes.diskWriteAttributes =
+            DiskWriteAttributesImpl.getDefaultAsyncInstance();
-   * Sets the directories to which the region's data is written and also set their sizes in megabytes
+   * Sets the directories to which the region's data is written and also set their sizes in
+   * megabytes
-   * @throws IllegalArgumentException if a dir does not exist or the length of the size array
-   * does not match to the length of the dir array or the given length is not a valid positive number
+   * @throws IllegalArgumentException if a dir does not exist or the length of the size array does
+   *         not match to the length of the dir array or the given length is not a valid positive
+   *         number
-  public void setDiskDirsAndSizes(File[] diskDirs,int[] diskSizes) {
+  public void setDiskDirsAndSizes(File[] diskDirs, int[] diskSizes) {
-      throw new IllegalStateException(LocalizedStrings.DiskStore_Deprecated_API_0_Cannot_Mix_With_DiskStore_1
-          .toLocalizedString(new Object[] {"setDiskDirsAndSizes", this.regionAttributes.getDiskStoreName()}));
+      throw new IllegalStateException(
+          LocalizedStrings.DiskStore_Deprecated_API_0_Cannot_Mix_With_DiskStore_1.toLocalizedString(
+              new Object[] {"setDiskDirsAndSizes", this.regionAttributes.getDiskStoreName()}));
-    if(diskSizes.length != this.regionAttributes.diskDirs.length) {
-      throw new IllegalArgumentException(LocalizedStrings.AttributesFactory_NUMBER_OF_DISKSIZES_IS_0_WHICH_IS_NOT_EQUAL_TO_NUMBER_OF_DISK_DIRS_WHICH_IS_1.toLocalizedString(new Object[] {Integer.valueOf(diskSizes.length), Integer.valueOf(diskDirs.length)}));
+    if (diskSizes.length != this.regionAttributes.diskDirs.length) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.AttributesFactory_NUMBER_OF_DISKSIZES_IS_0_WHICH_IS_NOT_EQUAL_TO_NUMBER_OF_DISK_DIRS_WHICH_IS_1
+              .toLocalizedString(new Object[] {Integer.valueOf(diskSizes.length),
+                  Integer.valueOf(diskDirs.length)}));
-   * Sets the <code>PartitionAttributes</code> that describe how the
-   * region is partitioned among members of the distributed system.  This
-   * also establishes a data policy of {@link DataPolicy#PARTITION PARTITION},
-   * if the data policy has not already been set.
+   * Sets the <code>PartitionAttributes</code> that describe how the region is partitioned among
+   * members of the distributed system. This also establishes a data policy of
+   * {@link DataPolicy#PARTITION PARTITION}, if the data policy has not already been set.
-      if (! this.regionAttributes.hasDataPolicy()) { 
-          this.regionAttributes.dataPolicy = PartitionedRegionHelper.DEFAULT_DATA_POLICY;        
+      if (!this.regionAttributes.hasDataPolicy()) {
+        this.regionAttributes.dataPolicy = PartitionedRegionHelper.DEFAULT_DATA_POLICY;
+      } else if (!PartitionedRegionHelper.ALLOWED_DATA_POLICIES
+          .contains(this.regionAttributes.dataPolicy)) {
+        throw new IllegalStateException(
+            LocalizedStrings.AttributesFactory_DATA_POLICY_0_IS_NOT_ALLOWED_FOR_A_PARTITIONED_REGION_DATAPOLICIES_OTHER_THAN_1_ARE_NOT_ALLOWED
+                .toLocalizedString(new Object[] {this.regionAttributes.dataPolicy,
+                    PartitionedRegionHelper.ALLOWED_DATA_POLICIES}));
-      else if ( !PartitionedRegionHelper.ALLOWED_DATA_POLICIES.contains(this.regionAttributes.dataPolicy) ) {
-        throw new IllegalStateException(LocalizedStrings.AttributesFactory_DATA_POLICY_0_IS_NOT_ALLOWED_FOR_A_PARTITIONED_REGION_DATAPOLICIES_OTHER_THAN_1_ARE_NOT_ALLOWED
-            .toLocalizedString(new Object[] {this.regionAttributes.dataPolicy, PartitionedRegionHelper.ALLOWED_DATA_POLICIES}));
-      }
-      if (this.regionAttributes.hasPartitionAttributes() 
+      if (this.regionAttributes.hasPartitionAttributes()
-        PartitionAttributesImpl copy = ((PartitionAttributesImpl) this.regionAttributes.partitionAttributes).copy();
+        PartitionAttributesImpl copy =
+            ((PartitionAttributesImpl) this.regionAttributes.partitionAttributes).copy();
-      
-      ((PartitionAttributesImpl) this.regionAttributes.partitionAttributes).setOffHeap(this.regionAttributes.offHeap);
-    }
-    else {
+
+      ((PartitionAttributesImpl) this.regionAttributes.partitionAttributes)
+          .setOffHeap(this.regionAttributes.offHeap);
+    } else {
-  }   
-   
+  }
+
-   * Sets the <code>MembershipAttributes</code> that describe the membership
-   * roles required for reliable access to the region.
+   * Sets the <code>MembershipAttributes</code> that describe the membership roles required for
+   * reliable access to the region.
-   * Sets the <code>SubscriptionAttributes</code> that describe how the region
-   * will subscribe to other distributed cache instances of the region.
+   * Sets the <code>SubscriptionAttributes</code> that describe how the region will subscribe to
+   * other distributed cache instances of the region.
-   * Set how indexes on the region should be maintained. It will be either synchronous
-   * or asynchronous.
-   * Default is true.
+   * Set how indexes on the region should be maintained. It will be either synchronous or
+   * asynchronous. Default is true.
-  /** Sets whether statistics are enabled for this region and its entries.
-   * Default is false.
+  /**
+   * Sets whether statistics are enabled for this region and its entries. Default is false.
+   * 
-   * Sets the flag telling a region to ignore JTA transactions.
-   * Default is false.
+   * Sets the flag telling a region to ignore JTA transactions. Default is false.
+   * 
-  /** Sets whether this region should become lock grantor.
-   * Default value is false.
+  /**
+   * Sets whether this region should become lock grantor. Default value is false.
+   * 
-  /** Sets whether distributed operations on this region should attempt
-      to use multicast.  Multicast must also be enabled in the
-      cache's DistributedSystem (see
-      <a href=../distributed/DistributedSystem.html#mcast-port">"mcast-port"</a>).
-      Default is false.
-      @since GemFire 5.0
-      @see RegionAttributes#getMulticastEnabled
+  /**
+   * Sets whether distributed operations on this region should attempt to use multicast. Multicast
+   * must also be enabled in the cache's DistributedSystem (see <a
+   * href=../distributed/DistributedSystem.html#mcast-port">"mcast-port"</a>). Default is false.
+   * 
+   * @since GemFire 5.0
+   * @see RegionAttributes#getMulticastEnabled
-  }  
+  }
+
-   * Sets cloning on region.
-   * Default is false.
-   * Note: off-heap regions always behave as if cloning is enabled.
+   * Sets cloning on region. Default is false. Note: off-heap regions always behave as if cloning is
+   * enabled.
-  
+
-   * Sets the pool name attribute.
-   * This causes regions that use these attributes
-   * to be a client region which communicates with the
-   * servers that the connection pool communicates with.
-   * <p>If this attribute is set to <code>null</code> or <code>""</code>
-   * then the connection pool is disabled causing regions that use these attributes
-   * to be communicate with peers instead of servers.
-   * <p>The named connection pool must exist on the cache at the time these
-   * attributes are used to create a region. See {@link PoolManager#createFactory}
-   * for how to create a connection pool.
-   * @param name the name of the connection pool to use; if <code>null</code>
-   * or <code>""</code> then the connection pool is disabled for regions
-   * using these attributes.
+   * Sets the pool name attribute. This causes regions that use these attributes to be a client
+   * region which communicates with the servers that the connection pool communicates with.
+   * <p>
+   * If this attribute is set to <code>null</code> or <code>""</code> then the connection pool is
+   * disabled causing regions that use these attributes to be communicate with peers instead of
+   * servers.
+   * <p>
+   * The named connection pool must exist on the cache at the time these attributes are used to
+   * create a region. See {@link PoolManager#createFactory} for how to create a connection pool.
+   * 
+   * @param name the name of the connection pool to use; if <code>null</code> or <code>""</code>
+   *        then the connection pool is disabled for regions using these attributes.
-    
+
-  
+
+   * 
-    
+
+   * 
-    
+
-  
+
-  /** Creates a <code>RegionAttributes</code> with the current settings.
+  /**
+   * Creates a <code>RegionAttributes</code> with the current settings.
+   * 
-   * <a href="#compatibility">compatibility rules</a>
+   *         <a href="#compatibility">compatibility rules</a>
-  public RegionAttributes<K,V> createRegionAttributes() {
+  public RegionAttributes<K, V> createRegionAttributes() {
-  /** Creates a <code>RegionAttributes</code> with the current settings.
+
+  /**
+   * Creates a <code>RegionAttributes</code> with the current settings.
+   * 
-   * <a href="#compatibility">compatibility rules</a>
+   *         <a href="#compatibility">compatibility rules</a>
-  public RegionAttributes<K,V> create() {
-    if (this.regionAttributes.hasDataPolicy() &&
-        this.regionAttributes.dataPolicy.withPartitioning() &&
-        this.regionAttributes.partitionAttributes == null) {
+  public RegionAttributes<K, V> create() {
+    if (this.regionAttributes.hasDataPolicy() && this.regionAttributes.dataPolicy.withPartitioning()
+        && this.regionAttributes.partitionAttributes == null) {
-      // fix bug #52033 by invoking setOffHeap now (localMaxMemory may now be the temporary placeholder for off-heap until DistributedSystem is created
-      ((PartitionAttributesImpl)this.regionAttributes.partitionAttributes).setOffHeap(this.regionAttributes.getOffHeap());
+      // fix bug #52033 by invoking setOffHeap now (localMaxMemory may now be the temporary
+      // placeholder for off-heap until DistributedSystem is created
+      ((PartitionAttributesImpl) this.regionAttributes.partitionAttributes)
+          .setOffHeap(this.regionAttributes.getOffHeap());
-      if (!attrs.hasStatisticsEnabled() && !attrs.getStatisticsEnabled() &&
-          (attrs.getRegionTimeToLive().getTimeout() != 0 ||
-           attrs.getRegionIdleTimeout().getTimeout() != 0 ||
-           attrs.getEntryTimeToLive().getTimeout() != 0 ||
-           attrs.getEntryIdleTimeout().getTimeout() != 0 ||
-           attrs.getCustomEntryIdleTimeout() != null ||
-           attrs.getCustomEntryTimeToLive() != null)
-          ) {
+      if (!attrs.hasStatisticsEnabled() && !attrs.getStatisticsEnabled()
+          && (attrs.getRegionTimeToLive().getTimeout() != 0
+              || attrs.getRegionIdleTimeout().getTimeout() != 0
+              || attrs.getEntryTimeToLive().getTimeout() != 0
+              || attrs.getEntryIdleTimeout().getTimeout() != 0
+              || attrs.getCustomEntryIdleTimeout() != null
+              || attrs.getCustomEntryTimeToLive() != null)) {
-      if (attrs.getDataPolicy().withReplication()
-          && !attrs.getDataPolicy().withPersistence()
+      if (attrs.getDataPolicy().withReplication() && !attrs.getDataPolicy().withPersistence()
-        RegionAttributesImpl<?,?> rattr = attrs;
+        RegionAttributesImpl<?, ?> rattr = attrs;
-    return (RegionAttributes<K,V>)this.regionAttributes.clone();
+    return (RegionAttributes<K, V>) this.regionAttributes.clone();
-   * Validates that the attributes are consistent with each other.
-   * The following rules are checked and enforced:
-   <ul>
-   <li>If the data policy {@link DataPolicy#withReplication uses replication}
-       and the scope is {@link Scope#isDistributed distributed} then the
-       following are incompatible:
-      <ul>
-      <li>ExpirationAction.LOCAL_INVALIDATE on the region</li
-      <li>ExpirationAction.LOCAL_DESTROY on the entries</li>
-      <li>ExpirationAction.LOCAL_INVALIDATE on the entries</li>
-      <li>An LRU with local destroy eviction action</li>
-      </ul>
-   </li>
-   <li>Region or entry expiration
-      is incompatible with disabled statistics on the region</li>
-   <li>Entry expiration
-      is incompatible with the {@link DataPolicy#EMPTY} data policy</li>
-   <li>{@link EvictionAttributes Eviction}
-      is incompatible with the {@link DataPolicy#EMPTY} data policy</li>
-   </ul>
+   * Validates that the attributes are consistent with each other. The following rules are checked
+   * and enforced:
+   * <ul>
+   * <li>If the data policy {@link DataPolicy#withReplication uses replication} and the scope is
+   * {@link Scope#isDistributed distributed} then the following are incompatible:
+   * <ul>
+   * <li>ExpirationAction.LOCAL_INVALIDATE on the region</li<li>ExpirationAction.LOCAL_DESTROY on
+   * the entries</li>
+   * <li>ExpirationAction.LOCAL_INVALIDATE on the entries</li>
+   * <li>An LRU with local destroy eviction action</li>
+   * </ul>
+   * </li>
+   * <li>Region or entry expiration is incompatible with disabled statistics on the region</li>
+   * <li>Entry expiration is incompatible with the {@link DataPolicy#EMPTY} data policy</li>
+   * <li>{@link EvictionAttributes Eviction} is incompatible with the {@link DataPolicy#EMPTY} data
+   * policy</li>
+   * </ul>
+   * 
-    if (attrs.getDataPolicy().withReplication()
-        && attrs.getScope().isDistributed()) {
-      boolean isForBucketRegion = false; 
+    if (attrs.getDataPolicy().withReplication() && attrs.getScope().isDistributed()) {
+      boolean isForBucketRegion = false;
-        RegionAttributesImpl<?,?> regionAttributes = (RegionAttributesImpl<?,?>)attrs;
+        RegionAttributesImpl<?, ?> regionAttributes = (RegionAttributesImpl<?, ?>) attrs;
-        throw new IllegalStateException(LocalizedStrings.AttributesFactory_EXPIRATIONACTIONLOCAL_DESTROY_ON_THE_ENTRIES_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION.toLocalizedString());
+          throw new IllegalStateException(
+              LocalizedStrings.AttributesFactory_EXPIRATIONACTIONLOCAL_DESTROY_ON_THE_ENTRIES_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION
+                  .toLocalizedString());
-          throw new IllegalStateException(LocalizedStrings.AttributesFactory_AN_EVICTION_CONTROLLER_WITH_LOCAL_DESTROY_EVICTION_ACTION_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION.toLocalizedString());
+          throw new IllegalStateException(
+              LocalizedStrings.AttributesFactory_AN_EVICTION_CONTROLLER_WITH_LOCAL_DESTROY_EVICTION_ACTION_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION
+                  .toLocalizedString());
-          throw new IllegalStateException(LocalizedStrings.AttributesFactory_EXPIRATIONACTIONLOCAL_INVALIDATE_ON_THE_REGION_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION.toLocalizedString());
+          throw new IllegalStateException(
+              LocalizedStrings.AttributesFactory_EXPIRATIONACTIONLOCAL_INVALIDATE_ON_THE_REGION_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION
+                  .toLocalizedString());
-        throw new IllegalStateException(LocalizedStrings.AttributesFactory_EXPIRATIONACTIONLOCAL_INVALIDATE_ON_THE_ENTRIES_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION.toLocalizedString());
+          throw new IllegalStateException(
+              LocalizedStrings.AttributesFactory_EXPIRATIONACTIONLOCAL_INVALIDATE_ON_THE_ENTRIES_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION
+                  .toLocalizedString());
-         //TODO: Is it possible to add this check while region is getting created
-//        for(String senderId : attrs.getGatewaySenderIds()){
-//          if(sender.isParallel()){
-//            throw new IllegalStateException(
-//                LocalizedStrings.AttributesFactory_PARALLELGATEWAYSENDER_0_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION
-//                    .toLocalizedString(sender));
-//          }
-//        }
+        // TODO: Is it possible to add this check while region is getting created
+        // for(String senderId : attrs.getGatewaySenderIds()){
+        // if(sender.isParallel()){
+        // throw new IllegalStateException(
+        // LocalizedStrings.AttributesFactory_PARALLELGATEWAYSENDER_0_IS_INCOMPATIBLE_WITH_DISTRIBUTED_REPLICATION
+        // .toLocalizedString(sender));
+        // }
+        // }
-    
+
-      if (!attrs.getDataPolicy().withPersistence() && (ea != null && ea.getAction() != EvictionAction.OVERFLOW_TO_DISK)) {
-        throw new IllegalStateException(LocalizedStrings.DiskStore_IS_USED_IN_NONPERSISTENT_REGION.toLocalizedString());        
+      if (!attrs.getDataPolicy().withPersistence()
+          && (ea != null && ea.getAction() != EvictionAction.OVERFLOW_TO_DISK)) {
+        throw new IllegalStateException(
+            LocalizedStrings.DiskStore_IS_USED_IN_NONPERSISTENT_REGION.toLocalizedString());
-    
-    if (!attrs.getStatisticsEnabled() &&
-          (attrs.getRegionTimeToLive().getTimeout() != 0 ||
-           attrs.getRegionIdleTimeout().getTimeout() != 0 ||
-           attrs.getEntryTimeToLive().getTimeout() != 0 ||
-           attrs.getEntryIdleTimeout().getTimeout() != 0 ||
-           attrs.getCustomEntryIdleTimeout() != null ||
-           attrs.getCustomEntryTimeToLive() != null)
-           ) {
-      throw new IllegalStateException(LocalizedStrings.AttributesFactory_STATISTICS_MUST_BE_ENABLED_FOR_EXPIRATION.toLocalizedString());
+
+    if (!attrs.getStatisticsEnabled() && (attrs.getRegionTimeToLive().getTimeout() != 0
+        || attrs.getRegionIdleTimeout().getTimeout() != 0
+        || attrs.getEntryTimeToLive().getTimeout() != 0
+        || attrs.getEntryIdleTimeout().getTimeout() != 0
+        || attrs.getCustomEntryIdleTimeout() != null || attrs.getCustomEntryTimeToLive() != null)) {
+      throw new IllegalStateException(
+          LocalizedStrings.AttributesFactory_STATISTICS_MUST_BE_ENABLED_FOR_EXPIRATION
+              .toLocalizedString());
-      if (attrs.getEntryTimeToLive().getTimeout() != 0 ||
-          attrs.getEntryIdleTimeout().getTimeout() != 0 ||
-          attrs.getCustomEntryTimeToLive() != null ||
-          attrs.getCustomEntryIdleTimeout() != null
-          ) {
-        throw new IllegalStateException(LocalizedStrings.AttributesFactory_IF_THE_DATA_POLICY_IS_0_THEN_ENTRY_EXPIRATION_IS_NOT_ALLOWED
-            .toLocalizedString(attrs.getDataPolicy()));
+      if (attrs.getEntryTimeToLive().getTimeout() != 0
+          || attrs.getEntryIdleTimeout().getTimeout() != 0
+          || attrs.getCustomEntryTimeToLive() != null
+          || attrs.getCustomEntryIdleTimeout() != null) {
+        throw new IllegalStateException(
+            LocalizedStrings.AttributesFactory_IF_THE_DATA_POLICY_IS_0_THEN_ENTRY_EXPIRATION_IS_NOT_ALLOWED
+                .toLocalizedString(attrs.getDataPolicy()));
-        throw new IllegalStateException(LocalizedStrings.AttributesFactory_IF_THE_DATA_POLICY_IS_0_THEN_EVICTION_IS_NOT_ALLOWED
-            .toLocalizedString(attrs.getDataPolicy()));
+        throw new IllegalStateException(
+            LocalizedStrings.AttributesFactory_IF_THE_DATA_POLICY_IS_0_THEN_EVICTION_IS_NOT_ALLOWED
+                .toLocalizedString(attrs.getDataPolicy()));
-        throw new IllegalStateException(LocalizedStrings.AttributesFactory_IF_THE_MEMBERSHIP_ATTRIBUTES_HAS_REQUIRED_ROLES_THEN_SCOPE_MUST_NOT_BE_LOCAL.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.AttributesFactory_IF_THE_MEMBERSHIP_ATTRIBUTES_HAS_REQUIRED_ROLES_THEN_SCOPE_MUST_NOT_BE_LOCAL
+                .toLocalizedString());
-    
+
-      ((PartitionAttributesImpl)pa).validateWhenAllAttributesAreSet(attrs instanceof RegionAttributesCreation);
+      ((PartitionAttributesImpl) pa)
+          .validateWhenAllAttributesAreSet(attrs instanceof RegionAttributesCreation);
-      
+
-            LocalizedStrings.AttributesFactory_LOCAL_DESTROY_IS_NOT_SUPPORTED_FOR_PR.toLocalizedString());
+            LocalizedStrings.AttributesFactory_LOCAL_DESTROY_IS_NOT_SUPPORTED_FOR_PR
+                .toLocalizedString());
-          || (entryTimeToLive.getAction().isLocalInvalidate() && entryTimeToLive.getTimeout() > 0)) {
+          || (entryTimeToLive.getAction().isLocalInvalidate()
+              && entryTimeToLive.getTimeout() > 0)) {
-            LocalizedStrings.AttributesFactory_LOCAL_INVALIDATE_IS_NOT_SUPPORTED_FOR_PR.toLocalizedString());
+            LocalizedStrings.AttributesFactory_LOCAL_INVALIDATE_IS_NOT_SUPPORTED_FOR_PR
+                .toLocalizedString());
-      if (attrs instanceof UserSpecifiedRegionAttributes<?,?>) {
-        UserSpecifiedRegionAttributes<?,?> rac = (UserSpecifiedRegionAttributes<?,?>) attrs;
+      if (attrs instanceof UserSpecifiedRegionAttributes<?, ?>) {
+        UserSpecifiedRegionAttributes<?, ?> rac = (UserSpecifiedRegionAttributes<?, ?>) attrs;
-          throw new IllegalStateException(LocalizedStrings.AttributesFactory_SETTING_SCOPE_ON_A_PARTITIONED_REGIONS_IS_NOT_ALLOWED.toLocalizedString());
+          throw new IllegalStateException(
+              LocalizedStrings.AttributesFactory_SETTING_SCOPE_ON_A_PARTITIONED_REGIONS_IS_NOT_ALLOWED
+                  .toLocalizedString());
-      
+
-      
-//    if (attrs.getScope() == Scope.GLOBAL) {
-//    throw new IllegalStateException(
-//    "Global Scope is incompatible with Partitioned Regions");
-//  }
-//  if (attrs.getScope() == Scope.LOCAL) {
-//    throw new IllegalStateException(
-//        "Local Scope is incompatible with Partitioned Regions");
-//  }
+
+      // if (attrs.getScope() == Scope.GLOBAL) {
+      // throw new IllegalStateException(
+      // "Global Scope is incompatible with Partitioned Regions");
+      // }
+      // if (attrs.getScope() == Scope.LOCAL) {
+      // throw new IllegalStateException(
+      // "Local Scope is incompatible with Partitioned Regions");
+      // }
-        throw new IllegalStateException(LocalizedStrings.AttributesFactory_TOTAL_SIZE_OF_PARTITION_REGION_MUST_BE_0.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.AttributesFactory_TOTAL_SIZE_OF_PARTITION_REGION_MUST_BE_0
+                .toLocalizedString());
-// listeners are supported here as of v5.1
-//      if (attrs.getCacheListeners().length > 0) {
-//        throw new IllegalStateException(
-//            "Can not add cache listeners to RegionAttributes when PartitionAttributes are set.");
-//      }
-// loaders are supported here as of v5.1
-//      if (attrs.getCacheLoader() != null) {
-//        throw new IllegalStateException(
-//            "Can not set CacheLoader in RegionAttributes when PartitionAttributes are set.");
-//      }
-      if ( ! PartitionedRegionHelper.ALLOWED_DATA_POLICIES.contains(attrs.getDataPolicy())) {
-        throw new IllegalStateException(LocalizedStrings.AttributesFactory_DATA_POLICIES_OTHER_THAN_0_ARE_NOT_ALLOWED_IN_PARTITIONED_REGIONS
-            .toLocalizedString(PartitionedRegionHelper.ALLOWED_DATA_POLICIES));
+      // listeners are supported here as of v5.1
+      // if (attrs.getCacheListeners().length > 0) {
+      // throw new IllegalStateException(
+      // "Can not add cache listeners to RegionAttributes when PartitionAttributes are set.");
+      // }
+      // loaders are supported here as of v5.1
+      // if (attrs.getCacheLoader() != null) {
+      // throw new IllegalStateException(
+      // "Can not set CacheLoader in RegionAttributes when PartitionAttributes are set.");
+      // }
+      if (!PartitionedRegionHelper.ALLOWED_DATA_POLICIES.contains(attrs.getDataPolicy())) {
+        throw new IllegalStateException(
+            LocalizedStrings.AttributesFactory_DATA_POLICIES_OTHER_THAN_0_ARE_NOT_ALLOWED_IN_PARTITIONED_REGIONS
+                .toLocalizedString(PartitionedRegionHelper.ALLOWED_DATA_POLICIES));
-//      if ( attrs.getDataPolicy().isEmpty() && pa.getLocalMaxMemory() != 0) {
-//        throw new IllegalStateException(
-//            "A non-zero PartitionAttributes localMaxMemory setting is not compatible" +
-//            " with an empty DataPolicy.  Please use DataPolicy.NORMAL instead.");
-//      }
-      
+      // if ( attrs.getDataPolicy().isEmpty() && pa.getLocalMaxMemory() != 0) {
+      // throw new IllegalStateException(
+      // "A non-zero PartitionAttributes localMaxMemory setting is not compatible" +
+      // " with an empty DataPolicy. Please use DataPolicy.NORMAL instead.");
+      // }
+
-      if (((PartitionAttributesImpl)pa).getLocalMaxMemoryForValidation() < 0) {
-        throw new IllegalStateException(LocalizedStrings.AttributesFactory_PARTITIONATTRIBUTES_LOCALMAXMEMORY_MUST_NOT_BE_NEGATIVE.toLocalizedString());
+      if (((PartitionAttributesImpl) pa).getLocalMaxMemoryForValidation() < 0) {
+        throw new IllegalStateException(
+            LocalizedStrings.AttributesFactory_PARTITIONATTRIBUTES_LOCALMAXMEMORY_MUST_NOT_BE_NEGATIVE
+                .toLocalizedString());
-      
+
-        throw new IllegalStateException(LocalizedStrings.AttributesFactory_SETLOCKGRANTERTRUE_IS_NOT_ALLOWED_IN_PARTITIONED_REGIONS.toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.AttributesFactory_SETLOCKGRANTERTRUE_IS_NOT_ALLOWED_IN_PARTITIONED_REGIONS
+                .toLocalizedString());
-      
+
-      if (((PartitionAttributesImpl)pa).getLocalMaxMemoryForValidation() == 0 && attrs.getDataPolicy() == DataPolicy.PERSISTENT_PARTITION) {
-        throw new IllegalStateException("Persistence is not allowed when local-max-memory is zero.");
+      if (((PartitionAttributesImpl) pa).getLocalMaxMemoryForValidation() == 0
+          && attrs.getDataPolicy() == DataPolicy.PERSISTENT_PARTITION) {
+        throw new IllegalStateException(
+            "Persistence is not allowed when local-max-memory is zero.");
-    
+
-  private static class RegionAttributesImpl<K,V>
-  extends UserSpecifiedRegionAttributes<K,V> implements Cloneable, Serializable {
+  private static class RegionAttributesImpl<K, V> extends UserSpecifiedRegionAttributes<K, V>
+      implements Cloneable, Serializable {
-    public Set<String>  asyncEventQueueIds;
+    public Set<String> asyncEventQueueIds;
-    ArrayList<CacheListener<K,V>> cacheListeners;
-    CacheLoader<K,V> cacheLoader;
-    CacheWriter<K,V> cacheWriter;
+    ArrayList<CacheListener<K, V>> cacheListeners;
+    CacheLoader<K, V> cacheLoader;
+    CacheWriter<K, V> cacheWriter;
-    CustomExpiry<K,V> customEntryTimeToLive = null;
+    CustomExpiry<K, V> customEntryTimeToLive = null;
-    CustomExpiry<K,V> customEntryIdleTimeout = null;
+    CustomExpiry<K, V> customEntryIdleTimeout = null;
-    PartitionAttributes partitionAttributes = null; //new PartitionAttributes();
+    PartitionAttributes partitionAttributes = null; // new PartitionAttributes();
-    EvictionAttributesImpl evictionAttributes = new EvictionAttributesImpl();  // TODO need to determine the constructor
+    EvictionAttributesImpl evictionAttributes = new EvictionAttributesImpl(); // TODO need to
+                                                                              // determine the
+                                                                              // constructor
-    
+
-    /** Constructs an instance of <code>RegionAttributes</code> with default settings.
+    /**
+     * Constructs an instance of <code>RegionAttributes</code> with default settings.
+     * 
-    public RegionAttributesImpl() {
-    }
+    public RegionAttributesImpl() {}
+
-      buf
-        .append("RegionAttributes@").append(System.identityHashCode(this)).append(": ")
-        .append("scope=").append(scope)
-        .append("; earlyAck=").append(earlyAck)
-        .append("; publisher=").append(publisher)
-        .append("; partitionAttrs=").append(partitionAttributes)
-        .append("; membershipAttrs=").append(membershipAttributes)
-        .append("; subscriptionAttrs=").append(subscriptionAttributes)
-        .append("; regionTTL=").append(regionTimeToLive)
-        .append("; action=").append(regionTimeToLiveExpirationAction)
-        .append("; regionIdleTimeout=").append(regionIdleTimeout)
-        .append("; action=").append(regionIdleTimeoutExpirationAction)
-        .append("; TTL=").append(entryTimeToLive)
-        .append("; action=").append(entryTimeToLiveExpirationAction)
-        .append("; custom=").append(customEntryTimeToLive)
-        .append("; idleTimeout=").append(entryIdleTimeout)
-        .append("; action=").append(entryIdleTimeoutExpirationAction)
-        .append("; custom=").append(customEntryIdleTimeout)
-        .append("; dataPolicy=").append(dataPolicy)
-        .append("; statisticsEnabled=").append(statisticsEnabled)
-        .append("; ignoreJTA=").append(ignoreJTA)
-        .append("; isLockGrantor=").append(isLockGrantor)
-        .append("; keyConstraint=").append(keyConstraint)
-        .append("; valueConstraint=").append(valueConstraint)
-        .append("; initialCapacity=").append(initialCapacity)
-        .append("; loadFactor=").append(loadFactor)
-        .append("; concurrencyLevel=").append(concurrencyLevel)
-        .append("; concurrencyChecksEnabled=").append(concurrencyChecksEnabled)
-        .append("; enableAsyncConflation=").append(enableAsyncConflation)
-        .append("; enableSubscriptionConflation=").append(enableSubscriptionConflation)
-        .append("; isBucketRegion=").append(isBucketRegion) 
-        .append("; poolName=").append(poolName)
-        .append("; diskSynchronous=").append(diskSynchronous)
-        .append("; multicastEnabled=").append(multicastEnabled)
-        .append("; isCloningEnabled=").append(isCloningEnabled)
-        ;
+      buf.append("RegionAttributes@").append(System.identityHashCode(this)).append(": ")
+          .append("scope=").append(scope).append("; earlyAck=").append(earlyAck)
+          .append("; publisher=").append(publisher).append("; partitionAttrs=")
+          .append(partitionAttributes).append("; membershipAttrs=").append(membershipAttributes)
+          .append("; subscriptionAttrs=").append(subscriptionAttributes).append("; regionTTL=")
+          .append(regionTimeToLive).append("; action=").append(regionTimeToLiveExpirationAction)
+          .append("; regionIdleTimeout=").append(regionIdleTimeout).append("; action=")
+          .append(regionIdleTimeoutExpirationAction).append("; TTL=").append(entryTimeToLive)
+          .append("; action=").append(entryTimeToLiveExpirationAction).append("; custom=")
+          .append(customEntryTimeToLive).append("; idleTimeout=").append(entryIdleTimeout)
+          .append("; action=").append(entryIdleTimeoutExpirationAction).append("; custom=")
+          .append(customEntryIdleTimeout).append("; dataPolicy=").append(dataPolicy)
+          .append("; statisticsEnabled=").append(statisticsEnabled).append("; ignoreJTA=")
+          .append(ignoreJTA).append("; isLockGrantor=").append(isLockGrantor)
+          .append("; keyConstraint=").append(keyConstraint).append("; valueConstraint=")
+          .append(valueConstraint).append("; initialCapacity=").append(initialCapacity)
+          .append("; loadFactor=").append(loadFactor).append("; concurrencyLevel=")
+          .append(concurrencyLevel).append("; concurrencyChecksEnabled=")
+          .append(concurrencyChecksEnabled).append("; enableAsyncConflation=")
+          .append(enableAsyncConflation).append("; enableSubscriptionConflation=")
+          .append(enableSubscriptionConflation).append("; isBucketRegion=").append(isBucketRegion)
+          .append("; poolName=").append(poolName).append("; diskSynchronous=")
+          .append(diskSynchronous).append("; multicastEnabled=").append(multicastEnabled)
+          .append("; isCloningEnabled=").append(isCloningEnabled);
-        buf.append("; diskAttrs=").append(diskWriteAttributes)
-          .append("; diskDirs=").append(Arrays.toString(diskDirs))
-          .append("; diskDirSizes=").append(Arrays.toString(diskSizes));
+        buf.append("; diskAttrs=").append(diskWriteAttributes).append("; diskDirs=")
+            .append(Arrays.toString(diskDirs)).append("; diskDirSizes=")
+            .append(Arrays.toString(diskSizes));
-      buf.append("; compressor=").append(compressor == null ? null : compressor.getClass().getName());
+      buf.append("; compressor=")
+          .append(compressor == null ? null : compressor.getClass().getName());
-    public CacheLoader<K,V> getCacheLoader() {
+
+    public CacheLoader<K, V> getCacheLoader() {
-    public CacheWriter<K,V> getCacheWriter() {
+
+    public CacheWriter<K, V> getCacheWriter() {
+
+
+
-    } 
-    public ExpirationAttributes getRegionTimeToLive() {
-      return new ExpirationAttributes(
-      this.regionTimeToLive, this.regionTimeToLiveExpirationAction);
+
+    public ExpirationAttributes getRegionTimeToLive() {
+      return new ExpirationAttributes(this.regionTimeToLive, this.regionTimeToLiveExpirationAction);
+    }
+
-      return new ExpirationAttributes(
-      this.regionIdleTimeout, this.regionIdleTimeoutExpirationAction);
+      return new ExpirationAttributes(this.regionIdleTimeout,
+          this.regionIdleTimeoutExpirationAction);
-      return new ExpirationAttributes(
-      this.entryTimeToLive, this.entryTimeToLiveExpirationAction);
+      return new ExpirationAttributes(this.entryTimeToLive, this.entryTimeToLiveExpirationAction);
-    public CustomExpiry<K,V> getCustomEntryTimeToLive() {
+
+    public CustomExpiry<K, V> getCustomEntryTimeToLive() {
+
-      return new ExpirationAttributes(
-      this.entryIdleTimeout, this.entryIdleTimeoutExpirationAction);
+      return new ExpirationAttributes(this.entryIdleTimeout, this.entryIdleTimeoutExpirationAction);
-    public CustomExpiry<K,V> getCustomEntryIdleTimeout() {
+
+    public CustomExpiry<K, V> getCustomEntryIdleTimeout() {
-      if (this.dataPolicy.isNormal() || this.dataPolicy.isPreloaded()
-          || this.dataPolicy.isEmpty() || this.dataPolicy.withPartitioning()) {
+      if (this.dataPolicy.isNormal() || this.dataPolicy.isPreloaded() || this.dataPolicy.isEmpty()
+          || this.dataPolicy.withPartitioning()) {
-        throw new IllegalStateException(LocalizedStrings.AttributesFactory_NO_MIRROR_TYPE_CORRESPONDS_TO_DATA_POLICY_0
-            .toLocalizedString(this.dataPolicy));
+        throw new IllegalStateException(
+            LocalizedStrings.AttributesFactory_NO_MIRROR_TYPE_CORRESPONDS_TO_DATA_POLICY_0
+                .toLocalizedString(this.dataPolicy));
+
+
-    
+
+
-    private static final CacheListener<?,?>[] EMPTY_LISTENERS = new CacheListener[0];
+
+    private static final CacheListener<?, ?>[] EMPTY_LISTENERS = new CacheListener[0];
+
-    public CacheListener<K,V>[] getCacheListeners() {
-      ArrayList<CacheListener<K,V>> listeners = this.cacheListeners;
+    public CacheListener<K, V>[] getCacheListeners() {
+      ArrayList<CacheListener<K, V>> listeners = this.cacheListeners;
-        return (CacheListener<K,V>[])EMPTY_LISTENERS;
+        return (CacheListener<K, V>[]) EMPTY_LISTENERS;
-            return (CacheListener<K,V>[])EMPTY_LISTENERS;
+            return (CacheListener<K, V>[]) EMPTY_LISTENERS;
-            CacheListener<K,V>[] result = new CacheListener[listeners.size()];
+            CacheListener<K, V>[] result = new CacheListener[listeners.size()];
-    public CacheListener<K,V> getCacheListener() {
-      ArrayList<CacheListener<K,V>> listeners = this.cacheListeners;
+
+    public CacheListener<K, V> getCacheListener() {
+      ArrayList<CacheListener<K, V>> listeners = this.cacheListeners;
-      throw new IllegalStateException(LocalizedStrings.AttributesFactory_MORE_THAN_ONE_CACHE_LISTENER_EXISTS.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.AttributesFactory_MORE_THAN_ONE_CACHE_LISTENER_EXISTS
+              .toLocalizedString());
-    protected void addCacheListener(CacheListener<K,V> aListener) {
-      ArrayList<CacheListener<K,V>> listeners = this.cacheListeners;
+
+    protected void addCacheListener(CacheListener<K, V> aListener) {
+      ArrayList<CacheListener<K, V>> listeners = this.cacheListeners;
-        ArrayList<CacheListener<K,V>> al = new ArrayList<CacheListener<K,V>>(1);
+        ArrayList<CacheListener<K, V>> al = new ArrayList<CacheListener<K, V>>(1);
-    
+
-      if(this.gatewaySenderIds == null){
+      if (this.gatewaySenderIds == null) {
-      }else{
+      } else {
-                .toLocalizedString(gatewaySenderId));
+                    .toLocalizedString(gatewaySenderId));
-    
+
-      if(this.asyncEventQueueIds == null){
+      if (this.asyncEventQueueIds == null) {
-      } else{
+      } else {
-                .toLocalizedString(asyncEventQueueId));
+                    .toLocalizedString(asyncEventQueueId));
-    
+
+
+
+
+
+
+
-    @SuppressWarnings({ "rawtypes", "unchecked" })
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
-        RegionAttributesImpl<K,V> copy = (RegionAttributesImpl<K,V>) super.clone();
+        RegionAttributesImpl<K, V> copy = (RegionAttributesImpl<K, V>) super.clone();
-          copy.partitionAttributes = ((PartitionAttributesImpl)copy.partitionAttributes).copy();
+          copy.partitionAttributes = ((PartitionAttributesImpl) copy.partitionAttributes).copy();
-          copy.cacheListeners = new ArrayList<CacheListener<K,V>>(copy.cacheListeners);
+          copy.cacheListeners = new ArrayList<CacheListener<K, V>>(copy.cacheListeners);
-          copy.gatewaySenderIds =  new CopyOnWriteArraySet<String>(copy.gatewaySenderIds);
+          copy.gatewaySenderIds = new CopyOnWriteArraySet<String>(copy.gatewaySenderIds);
-      }
-      catch (CloneNotSupportedException e) {
-        throw new InternalError(LocalizedStrings.AttributesFactory_CLONENOTSUPPORTEDEXCEPTION_THROWN_IN_CLASS_THAT_IMPLEMENTS_CLONEABLE.toLocalizedString());
+      } catch (CloneNotSupportedException e) {
+        throw new InternalError(
+            LocalizedStrings.AttributesFactory_CLONENOTSUPPORTEDEXCEPTION_THROWN_IN_CLASS_THAT_IMPLEMENTS_CLONEABLE
+                .toLocalizedString());
-    
+
-        throw new IllegalStateException(LocalizedStrings.DiskStore_Deprecated_API_0_Cannot_Mix_With_DiskStore_1
-            .toLocalizedString(new Object[] {"getDiskWriteAttributes", this.diskStoreName}));
+        throw new IllegalStateException(
+            LocalizedStrings.DiskStore_Deprecated_API_0_Cannot_Mix_With_DiskStore_1
+                .toLocalizedString(new Object[] {"getDiskWriteAttributes", this.diskStoreName}));
-        throw new IllegalStateException(LocalizedStrings.DiskStore_Deprecated_API_0_Cannot_Mix_With_DiskStore_1
-            .toLocalizedString(new Object[] {"getDiskDirs", this.diskStoreName}));
+        throw new IllegalStateException(
+            LocalizedStrings.DiskStore_Deprecated_API_0_Cannot_Mix_With_DiskStore_1
+                .toLocalizedString(new Object[] {"getDiskDirs", this.diskStoreName}));
-    public EvictionAttributes getEvictionAttributes()
-    {
+
+    public EvictionAttributes getEvictionAttributes() {
-    
+
-    
+
-        throw new IllegalStateException(LocalizedStrings.DiskStore_Deprecated_API_0_Cannot_Mix_With_DiskStore_1
-            .toLocalizedString(new Object[] {"getDiskDirSizes", this.diskStoreName}));
+        throw new IllegalStateException(
+            LocalizedStrings.DiskStore_Deprecated_API_0_Cannot_Mix_With_DiskStore_1
+                .toLocalizedString(new Object[] {"getDiskDirSizes", this.diskStoreName}));
+
+
-      return this.multicastEnabled; 
+      return this.multicastEnabled;
-    
+
+
-//    public void setCloningEnable(boolean val) {
-//      this.isCloningEnabled = val;
-//      setHasCloningEnabled(true);
-//    }
+
+    // public void setCloningEnable(boolean val) {
+    // this.isCloningEnabled = val;
+    // setHasCloningEnabled(true);
+    // }
-      if(!hasGatewaySenderId()){
+      if (!hasGatewaySenderId()) {
-    
+
-      if(!hasAsyncEventListeners()){
+      if (!hasAsyncEventListeners()) {
-    
+

MOV66 MOV65 MOV65 MOV65 MOV65 MOV65 MOV65 MOV65 MOV65 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 MOV65 MOV65 MOV65 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
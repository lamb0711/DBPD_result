Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Processes remote GemFire Command Line Interface (CLI) commands. Refer to the
- * vFabric GemFire documentation for information regarding local vs. remote
- * commands.
+ * Processes remote GemFire Command Line Interface (CLI) commands. Refer to the vFabric GemFire
+ * documentation for information regarding local vs. remote commands.
- * <b>NOTE:</b> <code>CommandService</code> is currently available only on
- * GemFire Manager nodes.
+ * <b>NOTE:</b> <code>CommandService</code> is currently available only on GemFire Manager nodes.
-   * Returns whether the underlying <code>Cache</code> exists and is not closed.
-   * The Cache must be ready in order for commands to be processed using this
-   * <code>CommandService</code>. A call to this method should be made before
-   * attempting to process commands.
+   * Returns whether the underlying <code>Cache</code> exists and is not closed. The Cache must be
+   * ready in order for commands to be processed using this <code>CommandService</code>. A call to
+   * this method should be made before attempting to process commands.
-   * @return True if the <code>Cache</code> exists and is not closed, false
-   *         otherwise.
+   * @return True if the <code>Cache</code> exists and is not closed, false otherwise.
-   * Processes the specified command string. Only remote commands can be
-   * processed using this method. Refer to the vFabric GemFire documentation for
-   * details.
+   * Processes the specified command string. Only remote commands can be processed using this
+   * method. Refer to the vFabric GemFire documentation for details.
-   * @param commandString
-   *          Command string to be processed.
+   * @param commandString Command string to be processed.
-   * Processes the specified command string. Only remote commands can be
-   * processed using this method. Refer to the vFabric GemFire documentation for
-   * details.
+   * Processes the specified command string. Only remote commands can be processed using this
+   * method. Refer to the vFabric GemFire documentation for details.
-   * @param commandString
-   *          Command string to be processed.
-   * @param env
-   *          Environmental values that will be used during the execution of
-   *          this command.
+   * @param commandString Command string to be processed.
+   * @param env Environmental values that will be used during the execution of this command.
-   * Creates a <code>CommandStatement</code> from the specified command string.
-   * Only remote commands can be processed using this method. Refer to the
-   * vFabric GemFire documentation for details.
+   * Creates a <code>CommandStatement</code> from the specified command string. Only remote commands
+   * can be processed using this method. Refer to the vFabric GemFire documentation for details.
-   * @param commandString
-   *          Command string from which to create a
-   *          <code>CommandStatement</code>.
-   * @return A <code>CommandStatement</code> which can be used to repeatedly
-   *         process the same command.
+   * @param commandString Command string from which to create a <code>CommandStatement</code>.
+   * @return A <code>CommandStatement</code> which can be used to repeatedly process the same
+   *         command.
-   * Creates a <code>CommandStatement</code> from the specified command string.
-   * Only remote commands can be processed using this method. Refer to the
-   * vFabric GemFire documentation for details.
+   * Creates a <code>CommandStatement</code> from the specified command string. Only remote commands
+   * can be processed using this method. Refer to the vFabric GemFire documentation for details.
-   * @param commandString
-   *          Command string from which to create a
-   *          <code>CommandStatement</code>.
-   * @param env
-   *          Environmental values that will be used during the execution of
-   *          this command.
-   * @return A <code>CommandStatement</code> which can be used to repeatedly
-   *         process the same command.
+   * @param commandString Command string from which to create a <code>CommandStatement</code>.
+   * @param env Environmental values that will be used during the execution of this command.
+   * @return A <code>CommandStatement</code> which can be used to repeatedly process the same
+   *         command.
-  protected abstract CommandStatement createCommandStatement(String commandString, Map<String, String> env);
+  protected abstract CommandStatement createCommandStatement(String commandString,
+      Map<String, String> env);
-   * @param cache
-   *          Underlying <code>Cache</code> instance to be used to create a Command Service.
-   * @throws CommandServiceException
-   *           If command service could not be initialized.
+   * @param cache Underlying <code>Cache</code> instance to be used to create a Command Service.
+   * @throws CommandServiceException If command service could not be initialized.
-      throw new CacheClosedException("Can not create command service as cache doesn't exist or cache is closed.");
+      throw new CacheClosedException(
+          "Can not create command service as cache doesn't exist or cache is closed.");
-   /* if (!cache.isServer()) {
-      throw new IllegalArgumentException("Server cache is required.");
-    }*/
+    /*
+     * if (!cache.isServer()) { throw new IllegalArgumentException("Server cache is required."); }
+     */
-        throw new DependenciesNotFoundException(LocalizedStrings.CommandServiceManager_COULD_NOT_FIND__0__LIB_NEEDED_FOR_CLI_GFSH.toLocalizedString(new Object[] {nonExistingDependency}));
+        throw new DependenciesNotFoundException(
+            LocalizedStrings.CommandServiceManager_COULD_NOT_FIND__0__LIB_NEEDED_FOR_CLI_GFSH
+                .toLocalizedString(new Object[] {nonExistingDependency}));
-   * Returns an existing 'usable' <code>CommandService></code>. A
-   * <code>CommandService</code> is considered usable if at has an underlying
-   * <code>Cache</code> which is not closed.
+   * Returns an existing 'usable' <code>CommandService></code>. A <code>CommandService</code> is
+   * considered usable if at has an underlying <code>Cache</code> which is not closed.
-   * @return A usable <code>CommandService</code> or null if one cannot be
-   *         found.
+   * @return A usable <code>CommandService</code> or null if one cannot be found.
-//  public static CommandService createCommandService(RegionService regionService) {
-//    if (regionService == null || regionService.isClosed()) {
-//      throw new CacheClosedException("Can not create command service as region service doesn't exist or cache is closed.");
-//    }
-//
-//    CommandService commandService;
-//
-//    if (Cache.class.isInstance(regionService) &&
-//        ((Cache) regionService).isServer() &&
-//        CacheFactory.getAnyInstance() == regionService) {
-//      commandService = createLocalCommandService((Cache) regionService);
-//    } else {
-//      Pool poolToUse = null;
-//      if (ProxyCache.class.isInstance(regionService)) {
-//        ProxyCache proxyCache = (ProxyCache) regionService;
-//        poolToUse = proxyCache.getUserAttributes().getPool();
-//      } else if (ClientCache.class.isInstance(regionService)) {
-//        ClientCache localCache = (ClientCache) regionService;
-//        poolToUse = localCache.getDefaultPool();
-//      } else {
-//        throw new IllegalArgumentException("Can not create Command Service for given Region Service: " + regionService);
-//      }
-//      commandService = new ProxyCommandService(poolToUse);
-//    }
-//
-//    return commandService;
-//  }
-//
-//  public static CommandService createRemoteCommandService(String poolName) {
-//    Pool poolToUse = PoolManager.find(poolName);
-//
-//    if (poolToUse == null) {
-//      throw new IllegalArgumentException("Can not create Command Service as a Pool with name \"" + poolName+"\" was not found.");
-//    }
-//
-//    return new ProxyCommandService(poolToUse);
-//  }
+  // public static CommandService createCommandService(RegionService regionService) {
+  // if (regionService == null || regionService.isClosed()) {
+  // throw new CacheClosedException("Can not create command service as region service doesn't exist
+  // or cache is closed.");
+  // }
+  //
+  // CommandService commandService;
+  //
+  // if (Cache.class.isInstance(regionService) &&
+  // ((Cache) regionService).isServer() &&
+  // CacheFactory.getAnyInstance() == regionService) {
+  // commandService = createLocalCommandService((Cache) regionService);
+  // } else {
+  // Pool poolToUse = null;
+  // if (ProxyCache.class.isInstance(regionService)) {
+  // ProxyCache proxyCache = (ProxyCache) regionService;
+  // poolToUse = proxyCache.getUserAttributes().getPool();
+  // } else if (ClientCache.class.isInstance(regionService)) {
+  // ClientCache localCache = (ClientCache) regionService;
+  // poolToUse = localCache.getDefaultPool();
+  // } else {
+  // throw new IllegalArgumentException("Can not create Command Service for given Region Service: "
+  // + regionService);
+  // }
+  // commandService = new ProxyCommandService(poolToUse);
+  // }
+  //
+  // return commandService;
+  // }
+  //
+  // public static CommandService createRemoteCommandService(String poolName) {
+  // Pool poolToUse = PoolManager.find(poolName);
+  //
+  // if (poolToUse == null) {
+  // throw new IllegalArgumentException("Can not create Command Service as a Pool with name \"" +
+  // poolName+"\" was not found.");
+  // }
+  //
+  // return new ProxyCommandService(poolToUse);
+  // }

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
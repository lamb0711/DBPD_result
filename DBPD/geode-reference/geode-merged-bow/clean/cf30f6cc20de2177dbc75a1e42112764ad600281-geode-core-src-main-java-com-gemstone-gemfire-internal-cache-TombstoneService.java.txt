Reverted accidental push of tombstone code

This reverts commit 850adfc653ece2f1f3e54f6f6d208acaf6aad142.
This reverts commit 6e2a9b257eec9ddc3ddad5d57cec52da3c5aaa49.
This reverts commit 71318b6568bea00a8779dc27ca6fad44cf907e10.
This reverts commit f82a8cebca32c78dd2c6cd90783728a0b9c1e2df.
This reverts commit 02599e3b8a7e538c3aadc5d50dbffcc8463a70f9.
This reverts commit 0861549c920f66fd45d3d22f6699318fb14a7572.
This reverts commit 161c80fffdf196996d9e8acd20789339ff9d2744.
This reverts commit 83c4940544e2006e02106953493e9b4a7d390b5c.

+import com.gemstone.gemfire.internal.cache.control.MemoryEvent;
+import com.gemstone.gemfire.internal.cache.control.ResourceListener;
-public class TombstoneService {
+public class TombstoneService  implements ResourceListener<MemoryEvent> {
-  public static int EXPIRED_TOMBSTONE_LIMIT = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "tombstone-gc-threshold", 100000);
+  public static long EXPIRED_TOMBSTONE_LIMIT = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "tombstone-gc-threshold", 100000);
-   * two sweepers, one for replicated regions (including PR buckets) and one for
+   * tasks for cleaning up tombstones
+   */
+  private TombstoneSweeper replicatedTombstoneSweeper;
+  private TombstoneSweeper nonReplicatedTombstoneSweeper;
+
+  /** a tombstone service is tied to a cache */
+  private GemFireCacheImpl cache;
+
+  /**
+   * two queues, one for replicated regions (including PR buckets) and one for
-  private final TombstoneSweeper replicatedTombstoneSweeper;
-  private final TombstoneSweeper nonReplicatedTombstoneSweeper;
+  private Queue<Tombstone> replicatedTombstones = new ConcurrentLinkedQueue<Tombstone>();
+  private Queue<Tombstone> nonReplicatedTombstones = new ConcurrentLinkedQueue<Tombstone>();
-  public final Object blockGCLock = new Object();
+  private AtomicLong replicatedTombstoneQueueSize = new AtomicLong();
+  private AtomicLong nonReplicatedTombstoneQueueSize = new AtomicLong();
+  
+  public Object blockGCLock = new Object();
-    this.replicatedTombstoneSweeper = new TombstoneSweeper(cache, new ConcurrentLinkedQueue<Tombstone>(),
-        REPLICATED_TOMBSTONE_TIMEOUT, true, new AtomicLong());
-    this.nonReplicatedTombstoneSweeper = new TombstoneSweeper(cache, new ConcurrentLinkedQueue<Tombstone>(),
-        CLIENT_TOMBSTONE_TIMEOUT, false, new AtomicLong());
-    this.replicatedTombstoneSweeper.start();
-    this.nonReplicatedTombstoneSweeper.start();
+    this.cache = cache;
+    this.replicatedTombstoneSweeper = new TombstoneSweeper(cache, this.replicatedTombstones,
+        REPLICATED_TOMBSTONE_TIMEOUT, true, this.replicatedTombstoneQueueSize);
+    this.nonReplicatedTombstoneSweeper = new TombstoneSweeper(cache, this.nonReplicatedTombstones,
+        CLIENT_TOMBSTONE_TIMEOUT, false, this.nonReplicatedTombstoneQueueSize);
+    startSweeper(this.replicatedTombstoneSweeper);
+    startSweeper(this.nonReplicatedTombstoneSweeper);
+  private void startSweeper(TombstoneSweeper tombstoneSweeper) {
+    synchronized(tombstoneSweeper) {
+      if (tombstoneSweeper.sweeperThread == null) {
+        tombstoneSweeper.sweeperThread = new Thread(LoggingThreadGroup.createThreadGroup("Destroyed Entries Processors",
+            logger), tombstoneSweeper);
+        tombstoneSweeper.sweeperThread.setDaemon(true);
+        String product = "GemFire";
+        if (tombstoneSweeper == this.replicatedTombstoneSweeper) {
+          tombstoneSweeper.sweeperThread.setName(product + " Garbage Collection Thread 1");
+        } else {
+          tombstoneSweeper.sweeperThread.setName(product + " Garbage Collection Thread 2");
+        }
+        tombstoneSweeper.sweeperThread.start();
+      }
+    }
+  }
+  
-    this.replicatedTombstoneSweeper.stop();
-    this.nonReplicatedTombstoneSweeper.stop();
+    stopSweeper(this.replicatedTombstoneSweeper);
+    stopSweeper(this.nonReplicatedTombstoneSweeper);
- /**
+  private void stopSweeper(TombstoneSweeper t) {
+    Thread sweeperThread;
+    synchronized(t) {
+      sweeperThread = t.sweeperThread;
+      t.isStopped = true;
+      if (sweeperThread != null) {
+        t.notifyAll();
+      }
+    }
+    try {
+      sweeperThread.join(100);
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+    }
+    t.tombstones.clear();
+  }
+  
+  /**
+    boolean useReplicated = useReplicatedQueue(r);
-    this.getSweeper(r).scheduleTombstone(ts);
+    if (useReplicated) {
+      this.replicatedTombstones.add(ts);
+      this.replicatedTombstoneQueueSize.addAndGet(ts.getSize());
+    } else {
+      this.nonReplicatedTombstones.add(ts);
+      this.nonReplicatedTombstoneQueueSize.addAndGet(ts.getSize());
+    }
-  private TombstoneSweeper getSweeper(LocalRegion r)  {
-    if (r.getScope().isDistributed() && r.getServerProxy() == null && r.dataPolicy.withReplication()) {
-      return this.replicatedTombstoneSweeper;
-    } else {
-      return this.nonReplicatedTombstoneSweeper;
-    }
+  private boolean useReplicatedQueue(LocalRegion r) {
+    return (r.getScope().isDistributed() && r.getServerProxy() == null) && r.dataPolicy.withReplication();
-    TombstoneSweeper sweeper = this.getSweeper(r);
-    Queue<Tombstone> queue = sweeper.getQueue();
+    Queue<Tombstone> queue =
+      r.getAttributes().getDataPolicy().withReplication() ? replicatedTombstones : nonReplicatedTombstones;
-    sweeper.incQueueSize(-removalSize);
+    if (queue == replicatedTombstones) {
+      replicatedTombstoneQueueSize.addAndGet(-removalSize);
+    } else {
+      nonReplicatedTombstoneQueueSize.addAndGet(-removalSize);
+    }
+    Queue<Tombstone> queue;
+    boolean replicated = false;
+    Tombstone currentTombstone;
+    StoppableReentrantLock lock = null;
+    boolean locked = false;
-    final TombstoneSweeper sweeper = this.getSweeper(r);
-    Tombstone currentTombstone = sweeper.lockAndGetCurrentTombstone();
+      locked = false;
+      if (r.getServerProxy() != null) {
+        queue = this.nonReplicatedTombstones;
+        lock = this.nonReplicatedTombstoneSweeper.currentTombstoneLock;
+        lock.lock();
+        locked = true;
+        currentTombstone = this.nonReplicatedTombstoneSweeper.currentTombstone;
+      } else {
+        queue = this.replicatedTombstones;
+        replicated = true;
+        lock = this.replicatedTombstoneSweeper.currentTombstoneLock;
+        lock.lock();
+        locked = true;
+        currentTombstone = this.replicatedTombstoneSweeper.currentTombstone;
+      }
-          removalSize += currentTombstone.getSize();
-          sweeper.clearCurrentTombstone();
-      for (Iterator<Tombstone> it=sweeper.getQueue().iterator(); it.hasNext(); ) {
-        Tombstone t = it.next();
+      for (Tombstone t: queue) {
-            it.remove();
-      sweeper.incQueueSize(-removalSize);
+      
+      queue.removeAll(removals);
+      if (replicated) {
+        this.replicatedTombstoneQueueSize.addAndGet(-removalSize);
+      } else {
+        this.nonReplicatedTombstoneQueueSize.addAndGet(-removalSize);
+      }
-      sweeper.unlock();
+      if (locked) {
+        lock.unlock();
+      }
-      boolean tombstoneWasStillInRegionMap = t.region.getRegionMap().removeTombstone(t.entry, t, false, true);
-      if (tombstoneWasStillInRegionMap && isBucket) {
+      if (t.region.getRegionMap().removeTombstone(t.entry, t, false, true) && isBucket) {
-    if (r.getServerProxy() == null) {
-      // if the region does not have a server proxy
-      // then it will not have any tombstones to gc for the server.
-      return;
-    }
-    final TombstoneSweeper sweeper = this.getSweeper(r);
+    Queue<Tombstone> queue = this.nonReplicatedTombstones;
-    Tombstone currentTombstone = sweeper.lockAndGetCurrentTombstone();
+    this.nonReplicatedTombstoneSweeper.currentTombstoneLock.lock();
+      Tombstone currentTombstone = this.nonReplicatedTombstoneSweeper.currentTombstone;
-          removalSize += currentTombstone.getSize();
-          sweeper.clearCurrentTombstone();
-      for (Iterator<Tombstone> it=sweeper.getQueue().iterator(); it.hasNext(); ) {
-        Tombstone t = it.next();
+      for (Tombstone t: queue) {
-            it.remove();
-      sweeper.incQueueSize(-removalSize);
+      
+      queue.removeAll(removals);
+      nonReplicatedTombstoneQueueSize.addAndGet(removalSize);
+      
-      sweeper.unlock();
+      this.nonReplicatedTombstoneSweeper.currentTombstoneLock.unlock();
+  /**
+   * Test Hook - slow operation
+   * verify whether a tombstone is scheduled for expiration
+   */
+  public boolean isTombstoneScheduled(LocalRegion r, RegionEntry re) {
+    Queue<Tombstone> queue;
+    if (r.getDataPolicy().withReplication()) {
+      queue = this.replicatedTombstones;
+    } else {
+      queue = this.nonReplicatedTombstones;
+    }
+    VersionSource myId = r.getVersionMember();
+    VersionTag entryTag = re.getVersionStamp().asVersionTag();
+    int entryVersion = entryTag.getEntryVersion();
+    for (Tombstone t: queue) {
+      if (t.region == r) {
+        VersionSource destroyingMember = t.getMemberID();
+        if (destroyingMember == null) {
+          destroyingMember = myId;
+        }
+        if (t.region == r
+            && t.entry.getKey().equals(re.getKey())
+            && t.getEntryVersion() == entryVersion) {
+          return true;
+        }
+      }
+    }
+    if (this.replicatedTombstoneSweeper != null) {
+      return this.replicatedTombstoneSweeper.hasExpiredTombstone(r, re, entryTag);
+    }
+    return false;
+  }
+
-    return "Destroyed entries GC service.  Replicate Queue=" + this.replicatedTombstoneSweeper.getQueue().toString()
-    + " Non-replicate Queue=" + this.nonReplicatedTombstoneSweeper.getQueue().toString()
+    return "Destroyed entries GC service.  Replicate Queue=" + this.replicatedTombstones.toString()
+    + " Non-replicate Queue=" + this.nonReplicatedTombstones
-    private final Queue<Tombstone> tombstones;
+    Queue<Tombstone> tombstones;
-    private final AtomicLong queueSize;
+    AtomicLong queueSize = new AtomicLong();
-    private final Thread sweeperThread;
+    Thread sweeperThread;
-    private final boolean batchMode;
+    boolean batchMode;
-     * The sweeper thread's current tombstone.
-     * Only set by the run() thread while holding the currentTombstoneLock.
-     * Read by other threads while holding the currentTombstoneLock.
+     * this suspends batch expiration.  It is intended for administrative use
+     * so an operator can suspend the garbage-collection of tombstones for
+     * replicated/partitioned regions if a persistent member goes off line
-    private Tombstone currentTombstone;
+    volatile boolean batchExpirationSuspended;
+    /**
+     * The sweeper thread's current tombstone
+     */
+    Tombstone currentTombstone;
-    private final StoppableReentrantLock currentTombstoneLock;
+    final StoppableReentrantLock currentTombstoneLock;
-    private final List<Tombstone> expiredTombstones;
+    Set<Tombstone> expiredTombstones;
-    private int forceExpirationCount = 0;
+    private long forceExpirationCount = 0;
-     * Part of expireBatch is done in a background thread
-     * and until that completes batch expiration is in progress.
-    private final GemFireCacheImpl cache;
+    private GemFireCacheImpl cache;
-      this.batchMode = batchMode;
-        this.expiredTombstones = new ArrayList<Tombstone>();
-      } else {
-        this.expiredTombstones = null;
+        this.batchMode = true;
+        this.expiredTombstones = new HashSet<Tombstone>();
-      this.sweeperThread = new Thread(LoggingThreadGroup.createThreadGroup("Destroyed Entries Processors", logger), this);
-      this.sweeperThread.setDaemon(true);
-      String product = "GemFire";
-      String threadName = product + " Garbage Collection Thread " + (batchMode ? "1" : "2");
-      this.sweeperThread.setName(threadName);
-
-  synchronized void start() {
-    this.sweeperThread.start();
-  }
-
-  synchronized void stop() {
-    this.isStopped = true;
-    if (this.sweeperThread != null) {
-      notifyAll();
+    
+    /** stop tombstone removal for sweepers that have batchMode==true */
+    @SuppressWarnings("unused")
+    void suspendBatchExpiration() {
+      this.batchExpirationSuspended = true;
-    try {
-      this.sweeperThread.join(100);
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
+    
+    
+    /** enables tombstone removal for sweepers that have batchMode==true */
+    @SuppressWarnings("unused")
+    void resumeBatchExpiration () {
+      if (this.batchExpirationSuspended) {
+        this.batchExpirationSuspended = false; // volatile write
+      }
-    getQueue().clear();
-  }
-
-    public Tombstone lockAndGetCurrentTombstone() {
-      lock();
-      return this.currentTombstone;
-    }
-
-    public void lock() {
-      this.currentTombstoneLock.lock();
-    }
-    public void unlock() {
-      this.currentTombstoneLock.unlock();
-    }
-
-    public void incQueueSize(long delta) {
-      this.queueSize.addAndGet(delta);
-    }
-
-    public Queue<Tombstone> getQueue() {
-      return this.tombstones;
-    }
-
+    
-    void scheduleTombstone(Tombstone ts) {
-      this.tombstones.add(ts);
-      this.queueSize.addAndGet(ts.getSize());
-    }
-    
-      if (this.forceBatchExpiration 
-          || this.expiredTombstones.size() >= EXPIRED_TOMBSTONE_LIMIT
-          || testHook_batchExpired != null) {
+      if ((!batchExpirationSuspended &&
+          (this.forceBatchExpiration || (this.expiredTombstones.size() >= EXPIRED_TOMBSTONE_LIMIT)))
+        || testHook_batchExpired != null) {
+    /** test hook - unsafe since not synchronized */
+    boolean hasExpiredTombstone(LocalRegion r, RegionEntry re, VersionTag tag) {
+      int entryVersion = tag.getEntryVersion();
+      boolean retry;
+      do {
+        retry = false;
+        try {
+          for (Tombstone t: this.expiredTombstones) {
+            if (t.region == r
+                && t.entry.getKey().equals(re.getKey())
+                && t.getEntryVersion() == entryVersion) {
+              return true;
+            }
+          }
+        } catch (ConcurrentModificationException e) {
+          retry = true;
+        }
+      } while (retry);
+      return false;
+    }
+    
+    
+    
+        final Set<DistributedRegion> regionsAffected = new HashSet<DistributedRegion>();
+        Set<Tombstone> expired = expiredTombstones;
+        expiredTombstones = new HashSet<Tombstone>();
+        if (expired.size() == 0) {
+          return;
+        }
-        {
-          final Set<DistributedRegion> regionsAffected = new HashSet<DistributedRegion>();
-          //Update the GC RVV for all of the affected regions.
-          //We need to do this so that we can persist the GC RVV before
-          //we start removing entries from the map.
-          for (Tombstone t: expiredTombstones) {
-            t.region.getVersionVector().recordGCVersion(t.getMemberID(), t.getRegionVersion());
-            regionsAffected.add((DistributedRegion)t.region);
-          }
+        //Update the GC RVV for all of the affected regions.
+        //We need to do this so that we can persist the GC RVV before
+        //we start removing entries from the map.
+        for (Tombstone t: expired) {
+          t.region.getVersionVector().recordGCVersion(t.getMemberID(), t.getRegionVersion());
+          regionsAffected.add((DistributedRegion)t.region);
+        }
+        
+        for (DistributedRegion r: regionsAffected) {
+          //Remove any exceptions from the RVV that are older than the GC version
+          r.getVersionVector().pruneOldExceptions();
-          for (DistributedRegion r: regionsAffected) {
-            //Remove any exceptions from the RVV that are older than the GC version
-            r.getVersionVector().pruneOldExceptions();
-
-            //Persist the GC RVV to disk. This needs to happen BEFORE we remove
-            //the entries from map, to prevent us from removing a tombstone
-            //from disk that has a version greater than the persisted
-            //GV RVV.
-            if(r.getDataPolicy().withPersistence()) {
-              r.getDiskRegion().writeRVVGC(r);
-            }
+          //Persist the GC RVV to disk. This needs to happen BEFORE we remove
+          //the entries from map, to prevent us from removing a tombstone
+          //from disk that has a version greater than the persisted
+          //GV RVV.
+          if(r.getDataPolicy().withPersistence()) {
+            r.getDiskRegion().writeRVVGC(r);
-        // TODO seems like no need for the value of this map to be a Set.
-        // It could instead be a List, which would be nice because the per entry
-        // memory overhead for a set is much higher than an ArrayList
-        // BUT we send it to clients and the old
-        // version of them expects it to be a Set.
-        final Map<DistributedRegion, Set<Object>> reapedKeys = new HashMap<>();
+        final Map<LocalRegion, Set<Object>> reapedKeys = new HashMap<LocalRegion, Set<Object>>();
-        for (Tombstone t: expiredTombstones) {
+        for (Tombstone t: expired) {
-          DistributedRegion tr = (DistributedRegion) t.region;
-          boolean tombstoneWasStillInRegionMap = tr.getRegionMap().removeTombstone(t.entry, t, false, true);
-          if (tombstoneWasStillInRegionMap && tr.isUsedForPartitionedRegionBucket()) {
-            Set<Object> keys = reapedKeys.get(tr);
+          if (t.region.getRegionMap().removeTombstone(t.entry, t, false, true) && t.region.isUsedForPartitionedRegionBucket()) {
+            Set<Object> keys = reapedKeys.get(t.region);
-              reapedKeys.put(tr, keys);
+              reapedKeys.put(t.region, keys);
-        expiredTombstones.clear();
-        if (!reapedKeys.isEmpty()) {
-          // do messaging in a pool so this thread is not stuck trying to
-          // communicate with other members
-          cache.getDistributionManager().getWaitingThreadPool().execute(new Runnable() {
-            public void run() {
-              try {
-                // this thread should not reference other sweeper state, which is not synchronized
-                for (Map.Entry<DistributedRegion, Set<Object>> mapEntry: reapedKeys.entrySet()) {
-                  DistributedRegion r = mapEntry.getKey();
-                  Set<Object> rKeysReaped = mapEntry.getValue();
-                  r.distributeTombstoneGC(rKeysReaped);
-                }
-              } finally {
-                batchExpirationInProgress = false;
+        // do messaging in a pool so this thread is not stuck trying to
+        // communicate with other members
+        cache.getDistributionManager().getWaitingThreadPool().execute(new Runnable() {
+          public void run() {
+            try {
+              // this thread should not reference other sweeper state, which is not synchronized
+              for (DistributedRegion r: regionsAffected) {
+                r.distributeTombstoneGC(reapedKeys.get(r));
+            } finally {
+              batchExpirationInProgress = false;
-          });
-          batchScheduled = true;
-        }
+          }
+        });
+        batchScheduled = true;
+      currentTombstone = null;
-          Tombstone myTombstone = lockAndGetCurrentTombstone();
-          boolean needsUnlock = true;
-          try {
-            if (myTombstone == null) {
-              myTombstone = tombstones.poll();
-              if (myTombstone != null) {
-                if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
-                  logger.trace(LogMarker.TOMBSTONE, "current tombstone is {}", myTombstone);
-                }
-                currentTombstone = myTombstone;
-              } else {
-                if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
-                  logger.trace(LogMarker.TOMBSTONE, "queue is empty - will sleep");
-                }
-                forceExpirationCount = 0;
-              }
-            }
-            long sleepTime = 0;
-            boolean expireMyTombstone = false;
-            if (myTombstone == null) {
-              sleepTime = expiryTime;
-            } else {
-              long msTillMyTombstoneExpires = myTombstone.getVersionTimeStamp() + expiryTime - now;
-              if (forceExpirationCount > 0) {
-                if (msTillMyTombstoneExpires > 0 && msTillMyTombstoneExpires <= minimumRetentionMs) {
-                  sleepTime = msTillMyTombstoneExpires;
-                } else {
-                  forceExpirationCount--;
-                  expireMyTombstone = true;
-                }
-              } else if (msTillMyTombstoneExpires > 0) {
-                sleepTime = msTillMyTombstoneExpires;
-              } else {
-                expireMyTombstone = true;
-              }
-            }
-            if (expireMyTombstone) {
+          if (currentTombstone == null) {
+            try {
+              currentTombstoneLock.lock();
-                if (batchMode) {
-                  if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
-                    logger.trace(LogMarker.TOMBSTONE, "expiring tombstone {}", myTombstone);
-                  }
-                  expiredTombstones.add(myTombstone);
-                } else {
-                  if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
-                    logger.trace(LogMarker.TOMBSTONE, "removing expired tombstone {}", myTombstone);
-                  }
-                  queueSize.addAndGet(-myTombstone.getSize());
-                  myTombstone.region.getRegionMap().removeTombstone(myTombstone.entry, myTombstone, false, true);
+                currentTombstone = tombstones.remove();
+              } finally {
+                currentTombstoneLock.unlock();
+              }
+              if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
+                logger.trace(LogMarker.TOMBSTONE, "current tombstone is {}", currentTombstone);
+              }
+            } catch (NoSuchElementException e) {
+              // expected
+              if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
+                logger.trace(LogMarker.TOMBSTONE, "queue is empty - will sleep");
+              }
+              forceExpirationCount = 0;
+            }
+          }
+          long sleepTime;
+          if (currentTombstone == null) {
+            sleepTime = expiryTime;
+          } else if (currentTombstone.getVersionTimeStamp()+expiryTime > now && (forceExpirationCount <= 0 || (currentTombstone.getVersionTimeStamp() + expiryTime - now) <= minimumRetentionMs)) {
+            sleepTime = currentTombstone.getVersionTimeStamp()+expiryTime - now;
+          } else {
+            if (forceExpirationCount > 0) {
+              forceExpirationCount--;
+            }
+            sleepTime = 0;
+            try {
+              if (batchMode) {
+                if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
+                  logger.trace(LogMarker.TOMBSTONE, "expiring tombstone {}", currentTombstone);
-                myTombstone = null;
-                clearCurrentTombstone();
-              } catch (CancelException e) {
-                return;
-              } catch (Exception e) {
-                logger.warn(LocalizedMessage.create(LocalizedStrings.GemFireCacheImpl_TOMBSTONE_ERROR), e);
-                myTombstone = null;
-                clearCurrentTombstone();
+                expiredTombstones.add(currentTombstone);
+              } else {
+                if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
+                  logger.trace(LogMarker.TOMBSTONE, "removing expired tombstone {}", currentTombstone);
+                }
+                queueSize.addAndGet(-currentTombstone.getSize());
+                currentTombstone.region.getRegionMap().removeTombstone(currentTombstone.entry, currentTombstone, false, true);
+              }
+              currentTombstoneLock.lock();
+              try {
+                currentTombstone = null;
+              } finally {
+                currentTombstoneLock.unlock();
+              }
+            } catch (CancelException e) {
+              return;
+            } catch (Exception e) {
+              logger.warn(LocalizedMessage.create(LocalizedStrings.GemFireCacheImpl_TOMBSTONE_ERROR), e);
+              currentTombstoneLock.lock();
+              try {
+                currentTombstone = null;
+              } finally {
+                currentTombstoneLock.unlock();
-            if (sleepTime > 0) {
-              // initial sleeps could be very long, so we reduce the interval to allow
-              // this thread to periodically sweep up tombstones for resurrected entries
-              sleepTime = Math.min(sleepTime, scanInterval);
-              if (sleepTime > minimumScanTime  &&  (now - lastScanTime) > scanInterval) {
-                lastScanTime = now;
-                long start = now;
-                // see if any have been superseded
-                for (Iterator<Tombstone> it = getQueue().iterator(); it.hasNext(); ) {
+          }
+          if (sleepTime > 0) {
+            // initial sleeps could be very long, so we reduce the interval to allow
+            // this thread to periodically sweep up tombstones for resurrected entries
+            sleepTime = Math.min(sleepTime, scanInterval);
+            if (sleepTime > minimumScanTime  &&  (now - lastScanTime) > scanInterval) {
+              lastScanTime = now;
+              long start = now;
+              // see if any have been superseded
+              for (Iterator<Tombstone> it = tombstones.iterator(); it.hasNext(); ) {
+                Tombstone test = it.next();
+                if (it.hasNext()) {
+                  if (test.region.getRegionMap().isTombstoneNotNeeded(test.entry, test.getEntryVersion())) {
+                    it.remove();
+                    this.queueSize.addAndGet(-test.getSize());
+                    if (test == currentTombstone) {
+                      currentTombstoneLock.lock();
+                      try {
+                        currentTombstone = null;
+                      } finally {
+                        currentTombstoneLock.unlock();
+                      }
+                      sleepTime = 0;
+                    }
+                  } else if (batchMode && test != currentTombstone && (test.getVersionTimeStamp()+expiryTime) <= now) {
+                    it.remove();
+                    this.queueSize.addAndGet(-test.getSize());
+                    if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
+                      logger.trace(LogMarker.TOMBSTONE, "expiring tombstone {}", currentTombstone);
+                    }
+                    expiredTombstones.add(test);
+                    sleepTime = 0;
+                  }
+                }
+              }
+              // now check the batch of timed-out tombstones, if there is one
+              if (batchMode) {
+                for (Iterator<Tombstone> it = expiredTombstones.iterator(); it.hasNext(); ) {
-                    if (test == myTombstone) {
-                      myTombstone = null;
-                      clearCurrentTombstone();
+                    if (test == currentTombstone) {
+                      currentTombstoneLock.lock();
+                      try {
+                        currentTombstone = null;
+                      } finally {
+                        currentTombstoneLock.unlock();
+                      }
-                  } else if (batchMode && (test.getVersionTimeStamp()+expiryTime) <= now) {
-                    it.remove();
-                    if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
-                      logger.trace(LogMarker.TOMBSTONE, "expiring tombstone {}", test);
-                    }
-                    expiredTombstones.add(test);
-                    sleepTime = 0;
-                    if (test == myTombstone) {
-                      myTombstone = null;
-                      clearCurrentTombstone();
-                    }
-                // now check the batch of timed-out tombstones, if there is one
-                if (batchMode) {
-                  for (Iterator<Tombstone> it = expiredTombstones.iterator(); it.hasNext(); ) {
-                    Tombstone test = it.next();
-                    if (test.region.getRegionMap().isTombstoneNotNeeded(test.entry, test.getEntryVersion())) {
-                      if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
-                        logger.trace(LogMarker.TOMBSTONE, "removing obsolete tombstone: {}", test);
-                      }
-                      it.remove();
-                      this.queueSize.addAndGet(-test.getSize());
-                      if (test == myTombstone) {
-                        myTombstone = null;
-                        clearCurrentTombstone();
-                        sleepTime = 0;
-                      }
-                    }
-                  }
-                }
-                if (sleepTime > 0) {
-                  long elapsed = this.cache.cacheTimeMillis() - start;
-                  sleepTime = sleepTime - elapsed;
-                  if (sleepTime <= 0) {
-                    minimumScanTime = elapsed;
-                    continue;
-                  }
-                }
-              }
-              // test hook:  if there are expired tombstones and nothing else is expiring soon,
-              // perform distributed tombstone GC
-              if (batchMode && IDLE_EXPIRATION && sleepTime >= expiryTime && !this.expiredTombstones.isEmpty()) {
-                expireBatch();
-                try {
-                  sleepTime = Math.min(sleepTime, maximumSleepTime);
-                  if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
-                    logger.trace(LogMarker.TOMBSTONE, "sleeping for {}", sleepTime);
-                  }
-                  needsUnlock = false;
-                  unlock();
-                  synchronized(this) {
-                    if(isStopped) {
-                      return;
-                    }
-                    this.wait(sleepTime);
-                  }
-                } catch (InterruptedException e) {
-                  return;
+                long elapsed = this.cache.cacheTimeMillis() - start;
+                sleepTime = sleepTime - elapsed;
+                if (sleepTime <= 0) {
+                  minimumScanTime = elapsed;
+                  continue;
-            } // sleepTime > 0
-          } finally {
-            if (needsUnlock) {
-              unlock();
-          }
+            // test hook:  if there are expired tombstones and nothing else is expiring soon,
+            // perform distributed tombstone GC
+            if (batchMode && IDLE_EXPIRATION && sleepTime >= expiryTime) {
+              if (this.expiredTombstones.size() > 0) {
+                expireBatch();
+              }
+            }
+            if (sleepTime > 0) {
+              try {
+                sleepTime = Math.min(sleepTime, maximumSleepTime);
+                if (logger.isTraceEnabled(LogMarker.TOMBSTONE)) {
+                  logger.trace(LogMarker.TOMBSTONE, "sleeping for {}", sleepTime);
+                }
+                synchronized(this) {
+                  if(isStopped) {
+                    return;
+                  }
+                  this.wait(sleepTime);
+                }
+              } catch (InterruptedException e) {
+                return;
+              }
+            }
+          } // sleepTime > 0
-
-    private void clearCurrentTombstone() {
-      assert this.currentTombstoneLock.isHeldByCurrentThread();
-      currentTombstone = null;
-    }
+    
+
+  /* (non-Javadoc)
+   * @see com.gemstone.gemfire.internal.cache.control.ResourceListener#onEvent(java.lang.Object)
+   */
+  @Override
+  public void onEvent(MemoryEvent event) {
+    if (event.isLocal()) {
+      if (event.getState().isEviction() && !event.getPreviousState().isEviction()) {
+        this.replicatedTombstoneSweeper.forceBatchExpiration();
+      }
+    }
+  }
+
+

INS26 INS26 INS40 INS40 INS74 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS43 INS43 UPD39 INS29 INS83 MOV43 MOV59 INS29 INS83 INS43 INS59 MOV29 MOV83 INS74 INS59 UPD83 MOV83 MOV74 INS59 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS39 UPD42 INS29 INS83 INS39 INS42 INS44 INS44 INS8 INS23 INS31 INS78 INS83 INS39 INS42 INS44 INS8 INS42 INS42 INS65 INS65 INS42 INS42 INS43 INS43 INS42 MOV14 INS42 MOV14 INS42 INS42 MOV14 INS42 INS42 MOV14 INS21 INS21 MOV43 INS42 INS51 MOV43 INS42 INS60 INS51 MOV54 INS21 INS60 INS25 MOV41 INS25 INS60 INS21 INS65 INS43 INS42 INS43 INS42 INS60 INS25 INS60 INS60 INS60 INS70 INS25 INS41 UPD83 INS39 INS59 INS29 MOV43 MOV59 INS74 UPD39 INS29 INS79 UPD42 INS29 INS79 UPD42 INS8 INS29 INS39 UPD42 MOV42 INS44 INS44 INS44 INS8 MOV8 INS42 INS43 INS42 INS25 UPD42 UPD42 INS66 INS66 UPD66 INS42 INS42 INS7 INS32 INS42 INS8 INS43 INS59 INS42 INS8 INS32 INS39 INS59 INS42 INS8 INS8 MOV27 MOV74 INS27 INS8 INS8 MOV60 INS74 MOV59 INS32 INS66 INS66 INS42 INS42 INS74 INS59 INS32 INS8 INS8 INS43 INS59 INS43 INS59 INS39 INS59 INS44 INS42 INS8 INS27 INS8 INS9 INS14 INS42 INS65 INS43 MOV43 INS65 INS42 INS45 INS65 INS42 INS45 INS25 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS60 INS60 INS19 INS41 MOV60 MOV60 MOV25 MOV21 MOV60 MOV60 MOV60 INS61 INS42 INS32 INS8 INS22 INS42 MOV22 MOV22 UPD42 INS22 INS42 INS22 INS25 UPD42 INS22 UPD42 INS22 INS42 INS42 INS21 INS21 INS25 INS40 INS42 INS42 INS32 INS21 INS21 INS21 INS21 INS36 UPD42 INS16 INS42 INS42 MOV21 INS21 INS60 INS60 INS60 INS60 INS43 INS43 UPD42 INS22 INS22 UPD42 MOV42 INS60 INS70 INS21 INS43 INS43 INS42 INS32 INS42 INS21 INS21 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS43 INS42 INS25 MOV22 INS33 INS41 INS22 INS43 UPD66 UPD66 UPD66 INS66 INS42 INS66 INS7 INS66 INS22 INS8 INS66 INS42 INS42 INS42 INS39 INS59 INS39 INS59 INS8 INS42 INS9 MOV27 MOV8 INS42 INS42 INS25 INS52 INS42 MOV43 INS22 INS22 MOV43 INS22 INS22 INS52 INS42 INS52 INS42 INS27 INS8 INS52 INS42 INS52 INS42 INS7 INS7 INS27 INS8 UPD42 MOV42 MOV42 INS32 INS32 INS32 INS32 MOV27 INS32 INS42 INS42 INS32 INS74 INS39 INS59 MOV43 INS59 INS43 INS59 INS39 INS59 INS8 INS42 UPD42 MOV42 INS52 INS42 MOV22 INS42 MOV43 INS59 INS44 INS42 MOV8 INS32 INS42 INS42 INS42 INS42 INS7 INS7 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS27 INS8 INS32 MOV22 MOV52 UPD42 MOV42 INS42 MOV21 MOV21 INS22 INS9 INS52 INS42 MOV21 INS36 INS42 INS32 INS42 MOV21 INS54 UPD42 MOV33 MOV60 MOV25 INS27 INS8 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS40 INS33 MOV21 INS21 MOV60 INS25 INS21 INS42 INS40 INS40 INS9 INS42 INS33 INS21 INS42 INS22 INS42 MOV42 INS22 INS42 INS32 INS22 INS42 INS42 INS22 INS42 MOV32 INS32 INS42 UPD42 UPD42 UPD42 MOV42 INS42 INS38 INS43 INS43 UPD42 INS42 INS9 MOV42 INS42 INS42 INS33 INS42 INS9 INS21 INS25 INS70 INS21 INS25 INS25 INS52 INS42 INS42 INS22 INS43 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS42 INS22 INS42 INS22 INS42 INS22 INS42 INS42 INS40 INS42 INS60 INS25 INS25 MOV22 INS42 INS42 INS42 INS42 UPD42 MOV52 UPD42 MOV42 INS27 INS42 UPD42 MOV42 INS7 INS8 INS12 MOV21 MOV12 MOV12 MOV12 INS32 INS38 INS21 INS32 INS27 INS8 INS8 INS32 INS32 INS52 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS32 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS7 INS27 INS8 INS8 INS44 INS42 MOV8 INS32 INS42 INS8 INS8 INS42 INS8 MOV22 INS42 MOV8 MOV42 INS22 INS42 INS52 INS42 INS52 INS42 INS43 INS59 INS27 INS8 INS27 INS8 INS9 INS14 UPD9 INS38 INS36 INS42 INS9 INS70 INS44 INS8 MOV60 INS60 INS25 MOV70 MOV70 MOV21 MOV21 MOV25 MOV21 MOV60 MOV25 INS25 INS32 INS42 INS32 INS32 INS40 INS40 INS42 INS9 INS42 INS22 INS21 INS21 INS40 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS9 MOV32 INS33 INS21 INS21 INS21 INS21 MOV21 INS21 INS21 INS21 INS21 INS21 INS21 INS43 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS21 MOV21 MOV21 MOV32 MOV25 INS52 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS27 INS27 INS41 UPD74 MOV74 UPD42 INS42 MOV27 INS44 MOV22 INS8 INS43 INS42 MOV21 INS74 INS59 INS7 INS27 MOV8 UPD42 UPD74 UPD42 MOV27 MOV8 INS25 MOV21 INS21 INS42 INS42 INS32 INS42 INS22 INS42 INS42 INS52 INS42 INS32 INS32 INS7 INS7 INS32 INS7 INS7 INS7 INS7 INS7 INS32 INS7 INS7 INS8 MOV42 INS32 MOV32 INS42 INS42 INS7 INS27 INS32 INS32 INS42 INS9 UPD43 INS36 MOV43 UPD42 MOV42 INS25 INS42 INS43 MOV43 INS42 INS42 INS42 INS14 INS32 INS34 UPD43 UPD42 INS54 UPD42 INS27 MOV8 INS8 INS7 INS42 INS42 INS52 INS42 INS40 INS42 INS27 INS40 INS42 INS27 INS42 INS22 INS42 INS22 INS42 INS42 INS42 INS9 INS42 INS22 INS42 INS22 INS42 INS9 INS42 INS22 INS42 INS42 INS42 INS9 INS42 INS22 MOV21 INS25 INS22 UPD42 MOV42 INS38 INS22 UPD42 UPD42 INS42 INS42 INS40 INS42 INS32 INS42 INS32 INS42 INS42 UPD42 MOV27 INS27 INS8 UPD42 INS9 INS42 INS74 UPD42 MOV42 UPD42 MOV42 UPD42 UPD74 INS8 INS12 INS27 INS36 INS25 MOV21 MOV54 MOV27 INS8 MOV42 MOV42 MOV42 MOV42 INS42 UPD42 MOV42 INS42 INS45 INS42 INS45 INS52 INS42 MOV22 INS42 MOV22 INS42 INS52 INS42 MOV22 INS42 INS22 INS42 MOV27 INS8 INS52 INS42 INS42 INS52 INS42 MOV42 INS40 INS42 INS42 INS42 INS27 INS27 INS41 INS43 MOV43 INS43 MOV74 INS32 INS32 INS21 INS54 MOV25 INS44 MOV8 MOV27 MOV42 INS27 MOV27 MOV8 INS25 INS52 INS42 MOV21 MOV21 INS27 INS32 INS32 INS42 INS9 INS42 INS42 INS32 INS42 INS40 UPD42 MOV42 INS9 INS9 INS40 MOV42 INS32 INS8 INS8 MOV32 INS43 INS42 UPD27 MOV27 MOV27 INS27 INS34 INS21 INS54 INS8 UPD27 MOV27 MOV8 INS40 INS42 INS32 UPD42 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 INS40 INS42 MOV43 MOV43 INS42 INS42 MOV21 INS21 INS42 UPD42 UPD42 INS36 INS27 INS42 INS32 INS8 INS8 INS21 INS54 MOV60 INS25 MOV32 INS34 INS40 UPD42 MOV42 INS42 UPD42 MOV42 INS40 INS32 INS27 INS32 INS42 MOV21 INS42 INS42 MOV21 MOV21 INS32 INS8 INS8 MOV32 INS8 UPD42 INS40 UPD42 INS42 INS42 UPD42 INS27 INS42 INS42 INS42 MOV32 MOV32 INS32 INS42 INS42 MOV21 MOV21 UPD42 MOV42 MOV25 INS42 UPD42 INS32 INS42 UPD42 INS42 INS42 INS38 UPD40 UPD42 UPD42 UPD42 INS42 MOV43 INS42 INS21 INS42 INS42 MOV32 UPD40 UPD42 UPD42 INS42 MOV21 MOV21 INS32 UPD42 UPD42 INS27 MOV21 INS42 UPD42 MOV42 INS32 INS22 UPD42 INS38 UPD42 INS21 INS54 MOV21 MOV42 INS27 MOV32 UPD42 INS21 INS54 MOV21 INS42 UPD42 MOV42 MOV42 INS52 INS42 INS32 INS32 INS8 INS8 INS42 INS42 INS32 INS8 INS8 MOV42 INS42 INS42 INS42 MOV21 MOV21 INS42 INS42 MOV21 MOV21 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 INS42 DEL23 DEL83 DEL83 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL52 DEL32 DEL42 DEL32 DEL21 DEL8 DEL41 DEL8 DEL25 DEL52 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL43 DEL52 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL43 DEL74 DEL42 DEL32 DEL42 DEL32 DEL59 DEL58 DEL42 DEL32 DEL24 DEL8 DEL39 DEL42 DEL59 DEL60 DEL42 DEL52 DEL42 DEL42 DEL32 DEL33 DEL27 DEL25 DEL83 DEL43 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL43 DEL74 DEL42 DEL32 DEL32 DEL59 DEL58 DEL24 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL66 DEL66 DEL83 DEL42 DEL33 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL8 DEL52 DEL42 DEL22 DEL42 DEL9 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL45 DEL42 DEL45 DEL45 DEL16 DEL36 DEL27 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL21 DEL83 DEL22 DEL42 DEL32 DEL83 DEL52 DEL42 DEL22 DEL33 DEL27 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL83 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL8 DEL31 DEL83 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL32 DEL21 DEL52 DEL42 DEL22 DEL32 DEL21 DEL8 DEL31 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL8 DEL42 DEL43 DEL42 DEL42 DEL43 DEL40 DEL11 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL40 DEL42 DEL9 DEL9 DEL32 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL40 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL32 DEL38 DEL8 DEL25 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL34 DEL42 DEL42 DEL42 DEL9 DEL7 DEL21 DEL42 DEL42 DEL7 DEL42 DEL42 DEL42 DEL42 DEL32 DEL38 DEL32 DEL21 DEL39 DEL42 DEL9 DEL59 DEL60 DEL39 DEL42 DEL27 DEL59 DEL60 DEL27 DEL25 DEL8 DEL42 DEL34 DEL27 DEL8 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL25 DEL8 DEL25 DEL42 DEL8 DEL25 DEL32 DEL42 DEL40 DEL45 DEL42 DEL42 DEL40 DEL32 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL27 DEL42 DEL33 DEL7 DEL21 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL38 DEL42 DEL9 DEL7 DEL21 DEL42 DEL32 DEL21 DEL42 DEL8 DEL25 DEL8 DEL54 DEL61 DEL8 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL6 DEL8 DEL31
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  public CompiledIteratorDef(String name, ObjectType elementType,
-      CompiledValue collectionExpr) {
+  public CompiledIteratorDef(String name, ObjectType elementType, CompiledValue collectionExpr) {
-    this.elementType = elementType == null ? TypeUtils.OBJECT_TYPE
-        : elementType;
+    this.elementType = elementType == null ? TypeUtils.OBJECT_TYPE : elementType;
-  
+
-  
+
-   * Returns a RuntimeIterator (or null if evaluates to null or UNDEFINED); the
-   * collection expr is evaluated lazily after dependencies are known
+   * Returns a RuntimeIterator (or null if evaluates to null or UNDEFINED); the collection expr is
+   * evaluated lazily after dependencies are known
-  public Object evaluate(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
-    throw new UnsupportedOperationException(LocalizedStrings.CompiledIteratorDef_NOT_TO_BE_EVALUATED_DIRECTLY.toLocalizedString());
+  public Object evaluate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+    throw new UnsupportedOperationException(
+        LocalizedStrings.CompiledIteratorDef_NOT_TO_BE_EVALUATED_DIRECTLY.toLocalizedString());
-    if (rIter != null) { return rIter; }
+    if (rIter != null) {
+      return rIter;
+    }
-      }
-      else {
+      } else {
-    // Rahul : generate from clause should take care of bucket region substitution if 
+    // Rahul : generate from clause should take care of bucket region substitution if
-    String fromClause = genFromClause(context); 
+    String fromClause = genFromClause(context);
-     * Asif : If the type of RunTimeIterator is still ObjectType & if the
-     * RuneTimeIterator is independent of any iterator of the scopes less than
-     * or equal to its own scope, we can evaluate the collection via
-     * RuntimeIterator. This will initialize the Collection of RuntimeIterator ,
-     * which is OK. The code in RuntimeIterator will be rectified such that the
+     * Asif : If the type of RunTimeIterator is still ObjectType & if the RuneTimeIterator is
+     * independent of any iterator of the scopes less than or equal to its own scope, we can
+     * evaluate the collection via RuntimeIterator. This will initialize the Collection of
+     * RuntimeIterator , which is OK. The code in RuntimeIterator will be rectified such that the
-     *  
+     * 
-       	&& !this.isDependentOnAnyIteratorOfScopeLessThanItsOwn(context)) {
-      //The current Iterator definition is independent , so lets evaluate
+        && !this.isDependentOnAnyIteratorOfScopeLessThanItsOwn(context)) {
+      // The current Iterator definition is independent , so lets evaluate
-      }
-      catch (QueryExecutionTimeoutException qet){
-        throw qet;        
-      }
-      catch (RegionNotFoundException re) {
+      } catch (QueryExecutionTimeoutException qet) {
+        throw qet;
+      } catch (RegionNotFoundException re) {
-      }
-      catch (Exception e) {
+      } catch (Exception e) {
-        throw new TypeMismatchException(LocalizedStrings.CompiledIteratorDef_EXCEPTION_IN_EVALUATING_THE_COLLECTION_EXPRESSION_IN_GETRUNTIMEITERATOR_EVEN_THOUGH_THE_COLLECTION_IS_INDEPENDENT_OF_ANY_RUNTIMEITERATOR.toLocalizedString(), e);
+        throw new TypeMismatchException(
+            LocalizedStrings.CompiledIteratorDef_EXCEPTION_IN_EVALUATING_THE_COLLECTION_EXPRESSION_IN_GETRUNTIMEITERATOR_EVEN_THOUGH_THE_COLLECTION_IS_INDEPENDENT_OF_ANY_RUNTIMEITERATOR
+                .toLocalizedString(),
+            e);
-      if (!(typ instanceof CollectionType)) { throw new TypeMismatchException(LocalizedStrings.CompiledIteratorDef_AN_ITERATOR_DEFINITION_MUST_BE_A_COLLECTION_TYPE_NOT_A_0.toLocalizedString(typ)); }
+      if (!(typ instanceof CollectionType)) {
+        throw new TypeMismatchException(
+            LocalizedStrings.CompiledIteratorDef_AN_ITERATOR_DEFINITION_MUST_BE_A_COLLECTION_TYPE_NOT_A_0
+                .toLocalizedString(typ));
+      }
-  SelectResults evaluateCollection(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  SelectResults evaluateCollection(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-   * @param stopAtIter the RuntimeIterator associated with this iterator defn --
-   *          don't use this or any subsequent runtime iterators to evaluate.
+   * @param stopAtIter the RuntimeIterator associated with this iterator defn -- don't use this or
+   *        any subsequent runtime iterators to evaluate.
-  SelectResults evaluateCollection(ExecutionContext context,
-      RuntimeIterator stopAtIter) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+  SelectResults evaluateCollection(ExecutionContext context, RuntimeIterator stopAtIter)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-    }
-    finally {
+    } finally {
-    
+
-    
+
-   * TODO:Asif : We need to implement the belwo method of computeDependencies
-   * Once we come to implement changes for partitioned region querying, as in
-   * that case if first iterator itself is a Select Query , then ideally we
-   * cannot call that CompiledIteratorDef independent ( which will be the case
-   * at present). When we use this commented function we will also need to take
-   * care of correctly implementing the function isDependentOnCurrentScope etc
-   * functions.
+   * TODO:Asif : We need to implement the belwo method of computeDependencies Once we come to
+   * implement changes for partitioned region querying, as in that case if first iterator itself is
+   * a Select Query , then ideally we cannot call that CompiledIteratorDef independent ( which will
+   * be the case at present). When we use this commented function we will also need to take care of
+   * correctly implementing the function isDependentOnCurrentScope etc functions.
-   * public Set computeDependencies(ExecutionContext context) throws
-   * TypeMismatchException, AmbiguousNameException { //Asif : If a
-   * CompiledIteratorDef has a collection expression which boils down to //a
-   * CompiledRegion or CompiledBindArgumnet , then its dependency is empty . In
-   * such cases // we will assume that the current CompiledIteratorDef has a
-   * dependency on itself. // This will be required once we start the changes
-   * for partitionedRegion Querying //But when we are doing check of whether the
-   * CompiledIteratorDef is dependent on its // own RuntimeIterator we will
-   * still return false. Set set =
-   * this.collectionExpr.computeDependencies(context); Set retSet = null;
-   * if(set.isEmpty()){ retSet =
-   * context.addDependency(this,this.getRuntimeIterator(context)); }else {
-   * retSet = context.addDependencies(this, set); } return retSet; }
+   * public Set computeDependencies(ExecutionContext context) throws TypeMismatchException,
+   * AmbiguousNameException { //Asif : If a CompiledIteratorDef has a collection expression which
+   * boils down to //a CompiledRegion or CompiledBindArgumnet , then its dependency is empty . In
+   * such cases // we will assume that the current CompiledIteratorDef has a dependency on itself.
+   * // This will be required once we start the changes for partitionedRegion Querying //But when we
+   * are doing check of whether the CompiledIteratorDef is dependent on its // own RuntimeIterator
+   * we will still return false. Set set = this.collectionExpr.computeDependencies(context); Set
+   * retSet = null; if(set.isEmpty()){ retSet =
+   * context.addDependency(this,this.getRuntimeIterator(context)); }else { retSet =
+   * context.addDependencies(this, set); } return retSet; }
-    return context.addDependencies(this, this.collectionExpr
-        .computeDependencies(context));
+    return context.addDependencies(this, this.collectionExpr.computeDependencies(context));
-  private ObjectType computeElementType(ExecutionContext context)
-      throws AmbiguousNameException
-  {
-    ObjectType type = PathUtils.computeElementTypeOfExpression(context,
-        this.collectionExpr);
+  private ObjectType computeElementType(ExecutionContext context) throws AmbiguousNameException {
+    ObjectType type = PathUtils.computeElementTypeOfExpression(context, this.collectionExpr);
-      return ((MapType)type).getEntryType();
+      return ((MapType) type).getEntryType();
-      return ((CollectionType)type).getElementType();
+      return ((CollectionType) type).getElementType();
-   * Convert the given object to a SelectResults. Must be a collection of some
-   * sort. The obj passed in must be unmodified, but the resulting SelectResults
-   * may or may not be modifiable. Return null if obj is null or UNDEFINED.
+   * Convert the given object to a SelectResults. Must be a collection of some sort. The obj passed
+   * in must be unmodified, but the resulting SelectResults may or may not be modifiable. Return
+   * null if obj is null or UNDEFINED.
-  private SelectResults prepareIteratorDef(Object obj, ObjectType elementType, ExecutionContext context)
-      throws TypeMismatchException {
-    if (obj == null) { return null; }
-    if (obj == QueryService.UNDEFINED) { return null; }
+  private SelectResults prepareIteratorDef(Object obj, ObjectType elementType,
+      ExecutionContext context) throws TypeMismatchException {
+    if (obj == null) {
+      return null;
+    }
+    if (obj == QueryService.UNDEFINED) {
+      return null;
+    }
-      ResultsCollectionWrapper res = new ResultsCollectionWrapper(elementType,
-          (Collection) obj);
+      ResultsCollectionWrapper res = new ResultsCollectionWrapper(elementType, (Collection) obj);
-        elementType = TypeUtils
-            .getObjectType(obj.getClass().getComponentType());
+        elementType = TypeUtils.getObjectType(obj.getClass().getComponentType());
-      ResultsCollectionWrapper res = new ResultsCollectionWrapper(elementType,
-          Arrays.asList((Object[]) obj));
+      ResultsCollectionWrapper res =
+          new ResultsCollectionWrapper(elementType, Arrays.asList((Object[]) obj));
-      ResultsCollectionWrapper res = new ResultsCollectionWrapper(elementType,
-          ((Map) obj).entrySet());
+      ResultsCollectionWrapper res =
+          new ResultsCollectionWrapper(elementType, ((Map) obj).entrySet());
-    }
- else { 
-      obj = new Object[]{obj};
+    } else {
+      obj = new Object[] {obj};
-        elementType = TypeUtils
-            .getObjectType(obj.getClass().getComponentType());
+        elementType = TypeUtils.getObjectType(obj.getClass().getComponentType());
-      ResultsCollectionWrapper res = new ResultsCollectionWrapper(elementType,
-          Arrays.asList((Object[]) obj));
+      ResultsCollectionWrapper res =
+          new ResultsCollectionWrapper(elementType, Arrays.asList((Object[]) obj));
-  String genFromClause(ExecutionContext context) throws AmbiguousNameException,
-      TypeMismatchException, NameResolutionException {
+  String genFromClause(ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-  
+
-   * Checks if the iterator in question is dependent on any other
-   * RuntimeIterator of its own or lesser scope.
+   * Checks if the iterator in question is dependent on any other RuntimeIterator of its own or
+   * lesser scope.
-  boolean isDependentOnAnyIteratorOfScopeLessThanItsOwn(ExecutionContext context)
-  {
+  boolean isDependentOnAnyIteratorOfScopeLessThanItsOwn(ExecutionContext context) {
-      RuntimeIterator ritr = (RuntimeIterator)itr.next();
+      RuntimeIterator ritr = (RuntimeIterator) itr.next();

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66
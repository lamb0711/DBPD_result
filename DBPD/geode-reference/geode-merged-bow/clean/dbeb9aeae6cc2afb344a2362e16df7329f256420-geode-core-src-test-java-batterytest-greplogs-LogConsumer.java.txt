Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
-  private static final Pattern ExpectedExceptionPattern = Pattern.compile("<ExpectedException action=(add|remove)>(.*)</ExpectedException>");
-  private static final Pattern logPattern = Pattern.compile("^\\[(?:fatal|error|warn|info|debug|trace|severe|warning|fine|finer|finest)");
+
+  private static final Pattern ExpectedExceptionPattern =
+      Pattern.compile("<ExpectedException action=(add|remove)>(.*)</ExpectedException>");
+  private static final Pattern logPattern =
+      Pattern.compile("^\\[(?:fatal|error|warn|info|debug|trace|severe|warning|fine|finer|finest)");
-  private static final Pattern skipLevelPattern = Pattern.compile("^\\[(?:warn|warning|info|debug|trace|fine|finer|finest)");
+  private static final Pattern skipLevelPattern =
+      Pattern.compile("^\\[(?:warn|warning|info|debug|trace|fine|finer|finest)");
-  private static final Pattern shortErrPattern = Pattern.compile("^\\[[^\\]]+\\](.*)$", Pattern.MULTILINE | Pattern.DOTALL);
-  private static final Pattern wroteExceptionPattern = Pattern.compile("\\[debug.*Wrote exception:");
-  private static final Pattern rmiWarnPattern = Pattern.compile("^WARNING: Failed to .*java.rmi.ConnectException: Connection refused to host: .*; nested exception is:");
+  private static final Pattern shortErrPattern =
+      Pattern.compile("^\\[[^\\]]+\\](.*)$", Pattern.MULTILINE | Pattern.DOTALL);
+  private static final Pattern wroteExceptionPattern =
+      Pattern.compile("\\[debug.*Wrote exception:");
+  private static final Pattern rmiWarnPattern = Pattern.compile(
+      "^WARNING: Failed to .*java.rmi.ConnectException: Connection refused to host: .*; nested exception is:");
-  private static final Pattern exceptionPattern2 = Pattern.compile("( [\\w\\.]+Exception: (([\\S]+ ){0,6}))");
+  private static final Pattern exceptionPattern2 =
+      Pattern.compile("( [\\w\\.]+Exception: (([\\S]+ ){0,6}))");
-  private static final Pattern rvvBitSetMessagePattern = Pattern.compile("RegionVersionVector.+bsv\\d+.+bs=\\{\\d+\\}");
+  private static final Pattern rvvBitSetMessagePattern =
+      Pattern.compile("RegionVersionVector.+bsv\\d+.+bs=\\{\\d+\\}");
-  
-  
-  
-  
-  public LogConsumer(boolean skipLogMsgs, 
-      List testExpectStrs, String fileName, int repeatLimit) {
+
+
+
+  public LogConsumer(boolean skipLogMsgs, List testExpectStrs, String fileName, int repeatLimit) {
-        if ( m.group(1).equals("add")) {
+        if (m.group(1).equals("add")) {
-          //assume add and remove are the only choices
+          // assume add and remove are the only choices
-    if(skipLogMsgs) {
-      if(infoMsgFlag) {
-        if(logPattern.matcher(line).find()) {
+    if (skipLogMsgs) {
+      if (infoMsgFlag) {
+        if (logPattern.matcher(line).find()) {
-      if (skipLevelPattern.matcher(line).find()){
+      if (skipLevelPattern.matcher(line).find()) {
-    
-    if ( eatLines != 0 ) {
+
+    if (eatLines != 0) {
-      if(saveFlag || fatalOrErrorPattern.matcher(line).find()) {
-        if(! saveFlag) {
+      if (saveFlag || fatalOrErrorPattern.matcher(line).find()) {
+        if (!saveFlag) {
-          tmpErrFlag = true;   
-          if(checkExpectedStrs(line, expectedExceptions)) {
+          tmpErrFlag = true;
+          if (checkExpectedStrs(line, expectedExceptions)) {
-          if(tmpErrFlag) {
-            tmpErrLines=1;
+          if (tmpErrFlag) {
+            tmpErrLines = 1;
-            // reset the counters and throw it all away if it matches 
+            // reset the counters and throw it all away if it matches
-            saveFlag = false; 
+            saveFlag = false;
-          
+
-          //looking for a blank line here
+          // looking for a blank line here
-              Integer occurances = 
-                new Integer((i == null) ? 1 : i.intValue() + 1);
+              Integer occurances = new Integer((i == null) ? 1 : i.intValue() + 1);
-              return enforceErrorLimit(occurances.intValue(), 
-                                all.toString(), 
-                                //reader.getLineNumber(),
-                                savelinenum,
-                                fileName);
-              
+              return enforceErrorLimit(occurances.intValue(), all.toString(),
+                  // reader.getLineNumber(),
+                  savelinenum, fileName);
+
-              //error in determining shortName, wing it
-              return enforceErrorLimit(1, 
-                                all.toString(), 
-                                lineNumber,
-                                fileName);
+              // error in determining shortName, wing it
+              return enforceErrorLimit(1, all.toString(), lineNumber, fileName);
-          
+
-          // all the lines we're trying to save          
-          if ( tmpErrFlag ) {
-            if ( tmpErrLines < ERROR_BUFFER_LIMIT ) {
+          // all the lines we're trying to save
+          if (tmpErrFlag) {
+            if (tmpErrLines < ERROR_BUFFER_LIMIT) {
-            if ( tmpErrLines == ERROR_BUFFER_LIMIT ) {
-              tmpErrLines++; //increment to prevent this line from repeating
+            if (tmpErrLines == ERROR_BUFFER_LIMIT) {
+              tmpErrLines++; // increment to prevent this line from repeating
-                 .append(" the error was too long to display completely.\n");
+                  .append(" the error was too long to display completely.\n");
-            
+
-      // unique condition for when bridge server see log exception and      
-      // logging level is set to fine. Message looks like this:
-      //[fine 2005/10/25 17:53:13.586 PDT gemfire2 Server connection from hobbes.gemstone.com:34466-0xf4 nid=0x23e40f1] Server connection from hobbes.gemstone.com:34466: Wrote exception:
-      //org.apache.geode.cache.EntryNotFoundException: remote-destroy-key
-      // also now handles a JMX WARNING
-      } else if(wroteExceptionPattern.matcher(line).find() 
-                || rmiWarnPattern.matcher(line).find()) {
-        //Eat only the single EntryNotFound Exception
-        eatLines=1;
-        // if we are here then the line didn't have severe or error in it and      
-        // didn't meet any special cases that require eating lines      
-        // Check for other kinds of exceptions. This is by no means inclusive      
-        //of all types of exceptions that could occur and some ARE missed.               
-      } else if (exceptionPattern.matcher(line).find()
-                 || javaLangErrorPattern.matcher(line).find()
-                 || (misformatedI18nMessagePattern.matcher(line).find()
-                     && !(skipLevelPattern.matcher(line).find()
-                         && rvvBitSetMessagePattern.matcher(line).find())) ) {
-        if(! checkExpectedStrs(line, expectedExceptions)) {
+        // unique condition for when bridge server see log exception and
+        // logging level is set to fine. Message looks like this:
+        // [fine 2005/10/25 17:53:13.586 PDT gemfire2 Server connection from
+        // hobbes.gemstone.com:34466-0xf4 nid=0x23e40f1] Server connection from
+        // hobbes.gemstone.com:34466: Wrote exception:
+        // org.apache.geode.cache.EntryNotFoundException: remote-destroy-key
+        // also now handles a JMX WARNING
+      } else if (wroteExceptionPattern.matcher(line).find()
+          || rmiWarnPattern.matcher(line).find()) {
+        // Eat only the single EntryNotFound Exception
+        eatLines = 1;
+        // if we are here then the line didn't have severe or error in it and
+        // didn't meet any special cases that require eating lines
+        // Check for other kinds of exceptions. This is by no means inclusive
+        // of all types of exceptions that could occur and some ARE missed.
+      } else if (exceptionPattern.matcher(line).find() || javaLangErrorPattern.matcher(line).find()
+          || (misformatedI18nMessagePattern.matcher(line).find()
+              && !(skipLevelPattern.matcher(line).find()
+                  && rvvBitSetMessagePattern.matcher(line).find()))) {
+        if (!checkExpectedStrs(line, expectedExceptions)) {
-           
-          if(m2.find()) {
+
+          if (m2.find()) {
-          Integer i = (Integer) individalErrorCount.get(shortName);
-          Integer occurances = 
-            new Integer((i == null) ? 1 : i.intValue() + 1);
-          individalErrorCount.put(shortName, occurances);
-          return enforceErrorLimit(occurances.intValue(), 
-                            line + "\n", 
-                            lineNumber,
-                            fileName);
+            Integer i = (Integer) individalErrorCount.get(shortName);
+            Integer occurances = new Integer((i == null) ? 1 : i.intValue() + 1);
+            individalErrorCount.put(shortName, occurances);
+            return enforceErrorLimit(occurances.intValue(), line + "\n", lineNumber, fileName);
-    
+
-  
+
-    if(saveFlag) {
-      //  Bug fix for severe that occurs at the end of a log file. Since we
+    if (saveFlag) {
+      // Bug fix for severe that occurs at the end of a log file. Since we
-      
+
-  
+
-    for(int i = 0; i < expectedExceptions.size(); i++) {
+    for (int i = 0; i < expectedExceptions.size(); i++) {
-      if(p.matcher(line).find()) return true;
+      if (p.matcher(line).find())
+        return true;
-    for(int i = 0; i < testExpectStrs.size(); i++) {
+    for (int i = 0; i < testExpectStrs.size(); i++) {
-      if(p.matcher(line).find()) return true;
+      if (p.matcher(line).find())
+        return true;
-  
-  private StringBuilder enforceErrorLimit(int hits, 
-      String line,
-      int linenum,
-      String filename) {
-    if ( hits <= repeatLimit ) {
+
+  private StringBuilder enforceErrorLimit(int hits, String line, int linenum, String filename) {
+    if (hits <= repeatLimit) {
-      .append("Found suspect string in ")
-      .append(filename)
-      .append(" at line ")
-      .append(linenum)
-      .append("\n\n")
-      .append(line)
-      .append("\n");
+          .append("Found suspect string in ").append(filename).append(" at line ").append(linenum)
+          .append("\n\n").append(line).append("\n");
-    if ( hits == repeatLimit ) {
+    if (hits == repeatLimit) {
-      buffer.append("\n\nHit occurrence limit of ")
-      .append(hits)
-      .append(" for this string.\n")
-      .append("Further reporting of this type of error will be suppressed.\n");
+      buffer.append("\n\nHit occurrence limit of ").append(hits).append(" for this string.\n")
+          .append("Further reporting of this type of error will be suppressed.\n");


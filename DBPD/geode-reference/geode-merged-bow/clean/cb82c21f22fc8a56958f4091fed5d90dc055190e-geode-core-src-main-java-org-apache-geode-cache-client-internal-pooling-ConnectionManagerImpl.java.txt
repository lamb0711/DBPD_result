GEODE-4615 Deadlock shutting down client cache

Disallow adding a new connection to the ConnectionMap when it is being
closed.

This revision replaces the connection map's connection list with a
poisoned list under sync and then closes each connection outside
of the connection map's lock.  This removes the lock inversion since
the closing thread no longer holds the map's lock.  The thread adding
a connection will either see closing==true or it will try to add
the connection to the poisoned list.  Either results in it
throwing a CacheClosedException.

+import java.util.Collection;
+import org.apache.geode.cache.CacheClosedException;
-import org.apache.geode.distributed.internal.DistributionConfig;
-  static long AQUIRE_TIMEOUT = Long
-      .getLong(DistributionConfig.GEMFIRE_PREFIX + "ConnectionManager.AQUIRE_TIMEOUT", 10 * 1000)
-      .longValue();
-  protected final long prefillRetry; // ms // make this an int
-  // private final long pingInterval; // ms // make this an int
+  protected final long prefillRetry; // ms
-    private final LinkedList/* <PooledConnection> */ allConnections =
-        new LinkedList/* <PooledConnection> */(); // in the order they were created
+    private List/* <PooledConnection> */ allConnections = new LinkedList/* <PooledConnection> */(); // in
+                                                                                                    // the
+                                                                                                    // order
+                                                                                                    // they
+                                                                                                    // were
+                                                                                                    // created
+    volatile boolean closing;
-      addToEndpointMap(connection);
+      if (this.closing) {
+        throw new CacheClosedException("This pool is closing");
+      }
+
+      getPoolStats().incPoolConnections(1);
-      getPoolStats().incPoolConnections(1);
-      // logger.info("DEBUG: addConnection incPoolConnections(1)->" +
-      // getPoolStats().getPoolConnections() + " con="+connection,
-      // new RuntimeException("STACK"));
-      this.allConnections.addLast(connection);
+      this.allConnections.add(connection);
+
+      addToEndpointMap(connection);
+
+      if (this.closing) {
+        throw new CacheClosedException("This pool is closing");
+      }
-        this.allConnections.addLast(con);
+        this.allConnections.add(con);
-    public synchronized void close(boolean keepAlive) {
-      map.clear();
+    public void close(boolean keepAlive) {
+      List<PooledConnection> connections;
-      while (!this.allConnections.isEmpty()) {
-        PooledConnection pc = (PooledConnection) this.allConnections.removeFirst();
+
+      synchronized (this) {
+        if (closing) {
+          return;
+        }
+        closing = true;
+        map.clear();
+        connections = allConnections;
+        allConnections = new ClosedPoolConnectionList();
+      }
+
+      for (PooledConnection pc : connections) {
+      closing = true;
-        PooledConnection pc = (PooledConnection) this.allConnections.removeFirst();
+        PooledConnection pc = (PooledConnection) this.allConnections.remove(0);
-     * See if any of the expired connections (that have not idle expired) are already connected to
-     * this sl and have not idle expired. If so then just update them in-place to simulate a
-     * replace.
-     *
-     * @param sl the location of the server we should see if we are connected to
-     * @return true if we were able to extend an existing connection's lifetime or if we have no
-     *         connection's whose lifetime has expired. false if we need to create a replacement
-     *         connection.
-     */
-    public synchronized boolean tryToExtendLifeTime(ServerLocation sl) {
-      // a better approach might be to get the most loaded server
-      // (if they are not balanced) and then scan through and extend the lifetime
-      // of everyone not connected to that server and do a replace on just one
-      // of the guys who has lifetime expired to the most loaded server
-      boolean result = true;
-      if (!this.allConnections.isEmpty()) {
-        final long now = System.nanoTime();
-        for (Iterator it = this.allConnections.iterator(); it.hasNext();) {
-          PooledConnection pc = (PooledConnection) it.next();
-          if (pc.remainingLife(now, lifetimeTimeoutNanos) > 0) {
-            // no more connections whose lifetime could have expired
-            break;
-            // note don't ignore idle guys because they are still connected
-            // } else if (pc.remainingIdle(now, idleTimeoutNanos) <= 0) {
-            // // this con has already idle expired so ignore it
-          } else if (pc.shouldDestroy()) {
-            // this con has already been destroyed so ignore it
-          } else if (sl.equals(pc.getEndpoint().getLocation())) {
-            // we found a guy to whose lifetime we can extend
-            it.remove();
-            // logger.fine("DEBUG: tryToExtendLifeTime extending life of: " + pc);
-            pc.setBirthDate(now);
-            getPoolStats().incLoadConditioningExtensions();
-            this.allConnections.addLast(pc);
-            return true;
-          } else {
-            // the current pc is a candidate for reconnection to another server
-            // so set result to false which will stick unless we find another con
-            // whose life can be extended.
-            result = false;
-          }
-        }
-      }
-      // if (result) {
-      // logger.fine("DEBUG: tryToExtendLifeTime found no one to extend");
-      // }
-      return result;
-    }
-
-    /**
-            this.allConnections.addLast(pc);
+            this.allConnections.add(pc);
+
+
+  private static class ClosedPoolConnectionList extends ArrayList {
+    @Override
+    public Object set(int index, Object element) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+
+    @Override
+    public boolean add(Object element) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+
+    @Override
+    public void add(int index, Object element) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+
+    @Override
+    public Object remove(int index) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+
+    @Override
+    public boolean addAll(Collection c) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+
+    @Override
+    public boolean addAll(int index, Collection c) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+  }

MOV26 INS26 INS40 UPD40 INS55 INS23 INS83 INS83 INS42 INS43 INS31 INS31 INS31 INS31 INS31 INS31 UPD43 INS83 INS39 INS59 MOV21 MOV29 UPD39 UPD42 MOV44 INS42 INS78 INS83 INS43 INS42 INS44 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS78 INS83 INS43 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS8 UPD42 UPD42 MOV42 INS25 INS25 INS60 INS51 INS70 INS21 UPD65 MOV65 MOV42 INS42 INS42 INS39 INS42 INS43 INS42 INS53 INS42 INS43 INS42 INS53 INS42 INS39 INS42 INS43 INS42 INS53 INS42 INS42 INS39 INS42 INS53 INS42 INS43 INS42 INS53 INS42 INS39 INS42 INS43 INS42 INS53 INS22 INS8 INS22 INS8 INS74 INS59 INS52 INS8 INS44 INS42 MOV8 INS7 UPD66 INS42 INS14 INS42 INS14 INS42 INS14 INS14 INS42 INS14 INS42 INS14 INS52 INS42 INS53 UPD42 INS52 INS42 INS53 INS43 MOV43 INS42 INS25 INS21 MOV21 INS21 INS21 MOV43 INS42 INS42 INS9 INS43 INS45 INS43 INS45 INS43 INS45 INS43 INS45 INS43 INS45 INS43 INS45 INS14 INS14 INS42 INS42 INS8 INS7 INS7 INS7 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS45 INS43 INS45 UPD42 INS41 INS42 INS9 INS42 INS42 INS42 INS14 INS42 INS42 INS43 MOV43 INS42 UPD42 INS34 INS10 UPD42 DEL83 DEL39 DEL42 DEL42 DEL42 DEL40 DEL45 DEL27 DEL34 DEL34 DEL27 DEL32 DEL42 DEL32 DEL59 DEL23 DEL83 DEL83 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL11 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL32 DEL38 DEL61 DEL42 DEL66 DEL66 DEL66 DEL65 DEL66 DEL66 DEL66 DEL65 DEL39 DEL42 DEL9 DEL59 DEL60 DEL9 DEL41 DEL42 DEL9 DEL7 DEL21 DEL8 DEL42 DEL41 DEL83 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL38 DEL83 DEL39 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL10 DEL8 DEL42 DEL42 DEL32 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL21 DEL10 DEL8 DEL25 DEL25 DEL25 DEL8 DEL24 DEL8 DEL25 DEL8 DEL31
GEODE-3948 Improve CQ performance under flaky network conditions

This adds a new PoolFactory setting allowing subscription connections to
time out and initiate failover to a backup server. The new setting is
setSubscriptionTimeoutMultiplier:

A server has an inactivity monitor that ensures a message is sent to a client at least once a
minute (60,000 milliseconds). If a subscription timeout multipler is set in the client it
enables timing out of the subscription feed with failover to another server.

A value of zero (the default) disables timeouts

A value of one will time out the server connection after one of its ping intervals (not
recommended)

A value of two or more will time out the server connection after that many ping intervals have
elapsed

The client/server handshake is modified for clients having version 1.5 or
later. The server sends its ping-interval setting to the client. The client
then uses this and the multiplier to establish a read-timeout in the
CacheClientUpdater subscription processor.

Two tests are added to ensure that 1) the Message method that allows a
read to timeout functions correctly and 2) the CacheClientUpdater
correctly receives the multiplier setting.

This closes #1364

+  public ServerQueueStatus getServerQueueStatus() {
+    return serverQueueStatus;
+  }
+
+  /**
+   * server-side queue status at the time we connected to it
+   */
+  private ServerQueueStatus serverQueueStatus;
+
-      ServerQueueStatus sqs = handshake.handshakeWithSubscriptionFeed(mySock, this.isPrimary);
-      if (sqs.isPrimary() || sqs.isNonRedundant()) {
+      this.serverQueueStatus = handshake.handshakeWithSubscriptionFeed(mySock, this.isPrimary);
+      if (serverQueueStatus.isPrimary() || serverQueueStatus.isNonRedundant()) {
-          pool.setPendingEventCount(sqs.getServerQueueSize());
+          pool.setPendingEventCount(serverQueueStatus.getServerQueueSize());
-        // Don't want the timeout after handshake
-        if (mySock != null) {
-          try {
-            mySock.setSoTimeout(0);
-          } catch (SocketException ignore) {
-          }
-        }
-
+
+    final int headerReadTimeout = (int) Math.round(serverQueueStatus.getPingInterval()
+        * qManager.getPool().getSubscriptionTimeoutMultiplier() * 1.25);
+
-          clientMessage.recv();
+          clientMessage.receiveWithHeaderReadTimeout(headerReadTimeout);

INS31 INS23 INS83 MOV43 INS42 INS8 INS29 INS83 INS43 INS59 INS41 INS65 INS42 INS42 INS60 INS42 INS66 INS83 INS39 INS59 INS21 INS42 INS11 INS7 INS39 INS32 INS22 MOV32 INS42 INS42 INS27 INS52 INS42 UPD42 UPD42 INS32 INS32 INS34 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 INS42 UPD42 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL34 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL25
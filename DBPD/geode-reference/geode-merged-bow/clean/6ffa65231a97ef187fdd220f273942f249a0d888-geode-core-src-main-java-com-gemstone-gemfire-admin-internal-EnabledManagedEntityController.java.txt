GEODE-1792: Revert:  Changed protocols and ciphers to be comma separated
Make ssl-ciphers and ssl-protocols comma separated properties.
The legacy *-ssl-ciphers and *-ssl-protocols still use space separated.

-import static com.gemstone.gemfire.distributed.ConfigurationProperties.*;
-
-import java.io.File;
-import java.util.Iterator;
-import java.util.Properties;
-
-import org.apache.logging.log4j.Logger;
-
-import com.gemstone.gemfire.management.internal.SSLUtil;
+import org.apache.logging.log4j.Logger;
+
+import java.io.File;
+import java.util.Iterator;
+import java.util.Properties;
+
+import static com.gemstone.gemfire.distributed.ConfigurationProperties.*;
- * <p>
- * <p>
- * <p>
+ *
+ * <P>
+ *
+ *
-
-  //  /** A lock to ensure that only entity is managed at a time.  See bug
-  //   * 31374. */
-  //  private static Object startStopLock = new Object();
+//  /** A lock to ensure that only entity is managed at a time.  See bug
+//   * 31374. */
+//  private static Object startStopLock = new Object();
-  /**
-   * Known strings found in output indicating error.
-   */
+  /** Known strings found in output indicating error. */
-    "No such file or directory", "The system cannot find the file specified.", "Access is denied.", "cannot open", "ERROR"
+    "No such file or directory",
+    "The system cannot find the file specified.",
+    "Access is denied.",
+    "cannot open",
+    "ERROR"
-  /**
-   * Token in command prefix to be replaced with actual HOST
-   */
+  /** Token in command prefix to be replaced with actual HOST */
-  /**
-   * Token in command prefix to be replaced with actual execution CMD
-   */
+  /** Token in command prefix to be replaced with actual execution CMD */
-  /**
-   * The thread group in which threads launched by this system
-   * controller reside.
-   */
+  /** The thread group in which threads launched by this system
+   * controller reside. */
-  /**
-   * System to which the managed entities belong
-   */
+  /** System to which the managed entities belong */
-    this.threadGroup = LoggingThreadGroup.createThreadGroup("ManagedEntityController threads", logger);
+    this.threadGroup =
+      LoggingThreadGroup.createThreadGroup("ManagedEntityController threads", logger);
-    if (output == null) {
-      return false;
-    }
+    if (output == null) return false;
-      if (error) {
-        return error;
-      }
+      if (error) return error;
-   * @param command The full command to remotely execute
+   *
+   * @param command
+   *        The full command to remotely execute
-   * <code>null</code> if the executing the command failed.
+   *         <code>null</code> if the executing the command failed.
-  protected String execute(String command, InternalManagedEntity entity) {
+  protected String execute(String command,
+                         InternalManagedEntity entity) {
-    File workingDir = new File(entity.getEntityConfig().getWorkingDirectory());
-    logger.info(LocalizedMessage.create(LocalizedStrings.ManagedEntityController_EXECUTING_REMOTE_COMMAND_0_IN_DIRECTORY_1, new Object[] {
-      command,
-      workingDir
-    }));
+    File workingDir =
+      new File(entity.getEntityConfig().getWorkingDirectory());
+    logger.info(LocalizedMessage.create(LocalizedStrings.ManagedEntityController_EXECUTING_REMOTE_COMMAND_0_IN_DIRECTORY_1, new Object[] {command, workingDir}));
-      p = Runtime.getRuntime().exec(command, null /* env */, workingDir);
+      p = Runtime.getRuntime().exec(command, null /* env */,
+                                    workingDir);
-    logger.info(LocalizedMessage.create(LocalizedStrings.ManagedEntityController_RESULT_OF_EXECUTING_0_IS_1, new Object[] {
-      command,
-      Integer.valueOf(retCode)
-    }));
-    logger.info(LocalizedMessage.create(LocalizedStrings.ManagedEntityController_OUTPUT_OF_0_IS_1, new Object[] { command, output }));
+    logger.info(LocalizedMessage.create(LocalizedStrings.ManagedEntityController_RESULT_OF_EXECUTING_0_IS_1, new Object[] {command, Integer.valueOf(retCode)}));
+    logger.info(LocalizedMessage.create(LocalizedStrings.ManagedEntityController_OUTPUT_OF_0_IS_1, new Object[] {command, output}));
-  /**
-   * Returns true if the path ends with a path separator.
-   */
+  /** Returns true if the path ends with a path separator. */
-  /**
-   * Translates the path between Windows and UNIX.
-   */
+  /** Translates the path between Windows and UNIX. */
-  //  /** Returns true if the path is on Windows. */
-  //  private boolean pathIsWindows(File path) {
-  //    return pathIsWindows(path.toString());
-  //  }
+//  /** Returns true if the path is on Windows. */
+//  private boolean pathIsWindows(File path) {
+//    return pathIsWindows(path.toString());
+//  }
-  /**
-   * Returns true if the path is on Windows.
-   */
+  /** Returns true if the path is on Windows. */
-      return (Character.isLetter(path.charAt(0)) && path.charAt(1) == ':') || (path.startsWith("//") || path.startsWith("\\\\"));
+      return (Character.isLetter(path.charAt(0)) && path.charAt(1) == ':') ||
+        (path.startsWith("//") || path.startsWith("\\\\"));
-   * @throws IllegalStateException If a remote command is required, but one has not been
-   * specified.
+   *
+   * @throws IllegalStateException
+   *        If a remote command is required, but one has not been
+   *        specified.
-  private String arrangeRemoteCommand(InternalManagedEntity entity, String cmd) {
+  private String arrangeRemoteCommand(InternalManagedEntity entity,
+                                      String cmd) {
-      throw new IllegalStateException(LocalizedStrings.ManagedEntityController_A_REMOTE_COMMAND_MUST_BE_SPECIFIED_TO_OPERATE_ON_A_MANAGED_ENTITY_ON_HOST_0.toLocalizedString(host));
+      throw new IllegalStateException(LocalizedStrings.ManagedEntityController_A_REMOTE_COMMAND_MUST_BE_SPECIFIED_TO_OPERATE_ON_A_MANAGED_ENTITY_ON_HOST_0
+          .toLocalizedString(host));
-   * <p>
-   * <p>
-   * <p>
+   *
+   * <P>
+   *
-   * @param executable The name of the executable that resides in
-   * <code>$GEMFIRE/bin</code>.
+   *
+   * @param executable
+   *        The name of the executable that resides in
+   *        <code>$GEMFIRE/bin</code>.
-  public String getProductExecutable(InternalManagedEntity entity, String executable) {
-    String productDirectory = entity.getEntityConfig().getProductDirectory();
+  public String getProductExecutable(InternalManagedEntity entity,
+                                     String executable) {
+    String productDirectory =
+      entity.getEntityConfig().getProductDirectory();
-    //    if (productDir != null) (cannot be null)
+//    if (productDir != null) (cannot be null)
-    //    else {
-    //      path = "";
-    //    }
+//    else {
+//      path = "";
+//    }
-    if (sslProps == null) {
-      return null;
-    }
+    if (sslProps == null) return null;
-    for (Iterator iter = sslProps.keySet().iterator(); iter.hasNext(); ) {
+    for (Iterator iter = sslProps.keySet().iterator(); iter.hasNext();) {
-   * @param forCommandLine true indicates that
-   * {@link DistributionConfig#GEMFIRE_PREFIX} should be
-   * prepended so the argument will become -Dgemfire.xxxx
+   *
+   * @param forCommandLine
+   *                true indicates that
+   *                {@link DistributionConfig#GEMFIRE_PREFIX} should be
+   *                prepended so the argument will become -Dgemfire.xxxx
-  private Properties buildSSLProperties(DistributedSystemConfig config, boolean forCommandLine) {
-    if (!config.isSSLEnabled()) {
-      return null;
-    }
+  private Properties buildSSLProperties(DistributedSystemConfig config,
+                                        boolean forCommandLine) {
+    if (!config.isSSLEnabled()) return null;
-    if (forCommandLine) {
-      prefix = DistributionConfig.GEMFIRE_PREFIX;
-    }
+    if (forCommandLine) prefix = DistributionConfig.GEMFIRE_PREFIX;
-    sslProps.setProperty(prefix + MCAST_PORT, "0");
-    sslProps.setProperty(prefix + CLUSTER_SSL_ENABLED, String.valueOf(config.isSSLEnabled()));
-    sslProps.setProperty(prefix + CLUSTER_SSL_CIPHERS, SSLUtil.arrayToSpaceDelimitedString(config.getSSLCiphers()));
-    sslProps.setProperty(prefix + CLUSTER_SSL_PROTOCOLS, SSLUtil.arrayToSpaceDelimitedString(config.getSSLProtocols()));
-    sslProps.setProperty(prefix + CLUSTER_SSL_REQUIRE_AUTHENTICATION, String.valueOf(config.isSSLAuthenticationRequired()));
+    sslProps.setProperty(prefix +
+            MCAST_PORT,
+                         "0");
+    sslProps.setProperty(prefix +
+                         CLUSTER_SSL_ENABLED,
+                         String.valueOf(config.isSSLEnabled()));
+    sslProps.setProperty(prefix +
+                         CLUSTER_SSL_CIPHERS,
+                         config.getSSLCiphers());
+    sslProps.setProperty(prefix +
+                         CLUSTER_SSL_PROTOCOLS,
+                         config.getSSLProtocols());
+    sslProps.setProperty(prefix +
+                         CLUSTER_SSL_REQUIRE_AUTHENTICATION,
+                         String.valueOf(config.isSSLAuthenticationRequired()));
-    final String command = arrangeRemoteCommand(entity, entity.getStartCommand());
+    final String command =
+      arrangeRemoteCommand(entity, entity.getStartCommand());
-      public void run() {
-        execute(command, entity);
-      }
-    }, "Start " + entity.getEntityType());
+        public void run() {
+          execute(command, entity);
+        }
+      }, "Start " + entity.getEntityType());
-    final String command = arrangeRemoteCommand(entity, entity.getStopCommand());
+    final String command =
+      arrangeRemoteCommand(entity, entity.getStopCommand());
-      public void run() {
-        execute(command, entity);
-      }
-    }, "Stop " + entity.getEntityType());
+        public void run() {
+          execute(command, entity);
+        }
+      }, "Stop " + entity.getEntityType());
-    final String command = arrangeRemoteCommand(entity, entity.getIsRunningCommand());
+    final String command =
+      arrangeRemoteCommand(entity, entity.getIsRunningCommand());
-    if (output == null || (output.indexOf("stop" /* "ing" "ped" */) != -1) || (output.indexOf("killed") != -1) || (output.indexOf("starting") != -1)) {
+    if (output == null ||
+        (output.indexOf("stop" /* "ing" "ped" */) != -1) ||
+        (output.indexOf("killed") != -1) ||
+        (output.indexOf("starting") != -1)) {
-      throw new IllegalStateException(LocalizedStrings.ManagedEntityController_COULD_NOT_DETERMINE_IF_MANAGED_ENTITY_WAS_RUNNING_0.toLocalizedString(output));
+      throw new IllegalStateException(LocalizedStrings.ManagedEntityController_COULD_NOT_DETERMINE_IF_MANAGED_ENTITY_WAS_RUNNING_0
+          .toLocalizedString(output));
-    String command = arrangeRemoteCommand(locator, locator.getLogCommand());
+    String command =
+      arrangeRemoteCommand(locator, locator.getLogCommand());
-  private String listDirectory(InternalManagedEntity entity, String dir) {
+  private String listDirectory(InternalManagedEntity entity,
+                               String dir) {
-    String listFile = pathIsWindows(config.getProductDirectory()) ? "dir " : "ls ";
-    String command = arrangeRemoteCommand(entity, listFile + dir);
+    String listFile =
+        pathIsWindows(config.getProductDirectory()) ? "dir " : "ls ";
+    String command =
+      arrangeRemoteCommand(entity, listFile + dir);

MOV26 MOV26 MOV26 MOV26 MOV26 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV41 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV41 UPD66 MOV41 MOV21 MOV32 MOV32 UPD42 UPD42 MOV27 UPD42 UPD42 MOV27 MOV41 DEL40 DEL26 DEL66 DEL66 DEL8 DEL8 DEL66 DEL66 DEL8 DEL8 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32
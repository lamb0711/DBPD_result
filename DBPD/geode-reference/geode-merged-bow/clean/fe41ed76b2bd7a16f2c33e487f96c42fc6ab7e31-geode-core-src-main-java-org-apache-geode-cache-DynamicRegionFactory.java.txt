GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-
+import java.util.SortedMap;
-import org.apache.geode.internal.cache.GemFireCacheImpl;
+import org.apache.geode.internal.cache.InternalCache;
-
- * <code>  DynamicRegionFactory factory = DynamicRegionFactory.get();
- *  factory.open(config);</code>
+ * {
+ *   DynamicRegionFactory factory = DynamicRegionFactory.get();
+ *   factory.open(config);
+ * }
- * <code>  DynamicRegionFactory myFactoryHandle = DynamicRegionFactory.get().open(config);</code>
+ * {
+ *   DynamicRegionFactory myFactoryHandle = DynamicRegionFactory.get().open(config);
+ * }
- *
+
+
-      Long.getLong("DynamicRegionFactory.msDelay", 250).longValue();
-  private static DynamicRegionFactory singleInstance = new DynamicRegionFactoryImpl();
-  GemFireCacheImpl c = null;
-  Config config = null;
+      Long.getLong("DynamicRegionFactory.msDelay", 250);
+
+  private static final DynamicRegionFactory singleInstance = new DynamicRegionFactoryImpl();
+
+  InternalCache cache = null;
+
+  private Config config = null;
-  private static volatile List regionListeners = Collections.EMPTY_LIST;
+  private static volatile List regionListeners = Collections.emptyList();
+
-  protected void _close() {
+  protected void doClose() {
-    this.c = null;
+    this.cache = null;
-    return isOpen() && this.c != null;
+    return isOpen() && this.cache != null;
+   * <p>
+   * This method is called internally during cache initialization at the correct time. Initialize
+   * the factory with a GemFire Cache. We create the metadata Region which holds all our dynamically
+   * created regions.
-   * @param theCache The GemFire <code>Cache</code>
-   * @throws CacheException
+   * @param theCache The GemFire {@code Cache}
-
-  protected void _internalInit(GemFireCacheImpl theCache) throws CacheException {
-
+  protected void doInternalInit(InternalCache theCache) throws CacheException {
-    /**
-     * This method is called internally during cache initialization at the correct time. Initialize
-     * the factory with a GemFire Cache. We create the metadata Region which holds all our
-     * dynamically created regions.
-     */
+
-      this.c = theCache;
+      this.cache = theCache;
-          for (GatewaySender gs : c.getGatewaySenders()) {
+          for (GatewaySender gs : this.cache.getGatewaySenders()) {
-          dynamicRegionList = theCache.createVMRegion(dynamicRegionListName, af.create(), ira);
+          this.dynamicRegionList = theCache.createVMRegion(dynamicRegionListName, af.create(), ira);
-          InternalGemFireError assErr = new InternalGemFireError(
-              LocalizedStrings.DynamicRegionFactory_UNEXPECTED_EXCEPTION.toLocalizedString());
-          assErr.initCause(e);
-          throw assErr;
+          throw new InternalGemFireError(
+              LocalizedStrings.DynamicRegionFactory_UNEXPECTED_EXCEPTION.toLocalizedString(), e);
-          InternalGemFireError assErr = new InternalGemFireError(
-              LocalizedStrings.DynamicRegionFactory_UNEXPECTED_EXCEPTION.toLocalizedString());
-          assErr.initCause(e);
-          throw assErr;
+          throw new InternalGemFireError(
+              LocalizedStrings.DynamicRegionFactory_UNEXPECTED_EXCEPTION.toLocalizedString(), e);
-          dynamicRegionList.registerInterest("ALL_KEYS");
+          this.dynamicRegionList.registerInterest("ALL_KEYS");
-          theCache.getLoggerI18n().fine("Created dynamic region: " + dynamicRegionList);
+          theCache.getLoggerI18n().fine("Created dynamic region: " + this.dynamicRegionList);
-          theCache.getLoggerI18n().fine("Retrieved dynamic region: " + dynamicRegionList);
+          theCache.getLoggerI18n().fine("Retrieved dynamic region: " + this.dynamicRegionList);
-      //
-   *
-    // TODO: perhaps add some logic here to avoid the possiblity of synchronization issues . . . .
-    Set s = dynamicRegionList.entrySet(false);
+    // TODO: perhaps add some logic here to avoid the possibility of synchronization issues
+    Set set = this.dynamicRegionList.entrySet(false);
-    Iterator i = s.iterator();
-    TreeMap sorted = new TreeMap();
+    Iterator iterator = set.iterator();
+    SortedMap sorted = new TreeMap();
-    while (i.hasNext()) {
-      Region.Entry e = (Region.Entry) i.next();
+    while (iterator.hasNext()) {
+      Region.Entry e = (Region.Entry) iterator.next();
-      sorted.put(dda.rootRegionName + "/" + dda.name, dda);
+      sorted.put(dda.rootRegionName + '/' + dda.name, dda);
-    i = sorted.values().iterator();
+    iterator = sorted.values().iterator();
-    while (i.hasNext()) {
-      DynamicRegionAttributes dda = (DynamicRegionAttributes) i.next();
+    while (iterator.hasNext()) {
+      DynamicRegionAttributes dda = (DynamicRegionAttributes) iterator.next();
-      doBeforeRegionCreated(dda.rootRegionName, dda.name, null);
+      doBeforeRegionCreated(dda.rootRegionName, dda.name);
-
-
-   * Returns the <code>DynamicRegionFactory</code> singleton instance.
+   * Returns the {@code DynamicRegionFactory} singleton instance.
-   * @return the <code>DynamicRegionFactory</code> singleton instance
+   * @return the {@code DynamicRegionFactory} singleton instance
-   * Registers a <code>DynamicRegionListener</code> for callbacks.
+   * Registers a {@code DynamicRegionListener} for callbacks.
-   * @param listener The <code>DynamicRegionListener</code> to be registered
+   * @param listener The {@code DynamicRegionListener} to be registered
-   * Unregisters a <code>DynamicRegionListener</code> for callbacks.
+   * Unregisters a {@code DynamicRegionListener} for callbacks.
-   * @param listener The <code>DynamicRegionListener</code> to be unregistered
+   * @param listener The {@code DynamicRegionListener} to be unregistered
-  private void doBeforeRegionCreated(String parentRegion, String regionName,
-      DistributedMember mbr) {
-    for (Iterator i = regionListeners.iterator(); i.hasNext();) {
-      DynamicRegionListener listener = (DynamicRegionListener) i.next();
+  private void doBeforeRegionCreated(String parentRegion, String regionName) {
+    for (Object regionListener : regionListeners) {
+      DynamicRegionListener listener = (DynamicRegionListener) regionListener;
-        this.c.getLoggerI18n().warning(
+        this.cache.getLoggerI18n().warning(
-    for (Iterator i = regionListeners.iterator(); i.hasNext();) {
-      DynamicRegionListener listener = (DynamicRegionListener) i.next();
+    for (Object regionListener : regionListeners) {
+      DynamicRegionListener listener = (DynamicRegionListener) regionListener;
-        listener.afterRegionCreate(event /* region */ );
+        listener.afterRegionCreate(event /* region */);
-        this.c.getLoggerI18n().warning(
+        this.cache.getLoggerI18n().warning(
-    for (Iterator i = regionListeners.iterator(); i.hasNext();) {
-      DynamicRegionListener listener = (DynamicRegionListener) i.next();
+    for (Object regionListener : regionListeners) {
+      DynamicRegionListener listener = (DynamicRegionListener) regionListener;
-        listener.beforeRegionDestroy(event /* fullRegionName */ );
+        listener.beforeRegionDestroy(event /* fullRegionName */);
-        this.c.getLoggerI18n().warning(
+        this.cache.getLoggerI18n().warning(
-    for (Iterator i = regionListeners.iterator(); i.hasNext();) {
-      DynamicRegionListener listener = (DynamicRegionListener) i.next();
+    for (Object regionListener : regionListeners) {
+      DynamicRegionListener listener = (DynamicRegionListener) regionListener;
-        listener.afterRegionDestroy(event /* fullRegionName */ );
+        listener.afterRegionDestroy(event /* fullRegionName */);
-        this.c.getLoggerI18n().warning(
+        this.cache.getLoggerI18n().warning(
-      return InternalDistributedSystem.getAnyInstance().getDistributedMember();
+      return this.cache.getInternalDistributedSystem().getDistributedMember();
-
-   * @return the <code>Region</code> created
-   * @throws CacheException
+   * @return the {@code Region} created
-    doBeforeRegionCreated(parentRegionName, regionName, null);
+    doBeforeRegionCreated(parentRegionName, regionName);
-   * @param fullRegionName The full path of the <code>Region</code> to be dynamically destroyed
-   * @throws CacheException
+   * @param fullRegionName The full path of the {@code Region} to be dynamically destroyed
-    if (!dynamicRegionList.containsKey(fullRegionName)) {
+    if (!this.dynamicRegionList.containsKey(fullRegionName)) {
-    Region region = c.getRegion(fullRegionName);
+    Region region = this.cache.getRegion(fullRegionName);
-    Region parentRegion = c.getRegion(parentRegionName);
-    Region newRegion = null;
+    Region parentRegion = this.cache.getRegion(parentRegionName);
-      c.getLoggerI18n().warning(
+      this.cache.getLoggerI18n().warning(
-    RegionAttributes newRegionAttributes = null;
-    {
-      EvictionAttributes ev = rra.getEvictionAttributes();
-      if (ev != null && ev.getAlgorithm().isLRU()) {
-        EvictionAttributes rev = new EvictionAttributesImpl((EvictionAttributesImpl) ev);
-        af.setEvictionAttributes(rev);
-      }
+    EvictionAttributes ev = rra.getEvictionAttributes();
+    if (ev != null && ev.getAlgorithm().isLRU()) {
+      EvictionAttributes rev = new EvictionAttributesImpl((EvictionAttributesImpl) ev);
+      af.setEvictionAttributes(rev);
-    // regions [bruce]
+    // regions
-      af.setPartitionAttributes((new PartitionAttributesFactory()).create());
+      af.setPartitionAttributes(new PartitionAttributesFactory().create());
-    newRegionAttributes = af.create();
+    RegionAttributes newRegionAttributes = af.create();
+    Region newRegion;
-      c.getLoggerI18n().fine("Created dynamic region " + newRegion);
+      this.cache.getLoggerI18n().fine("Created dynamic region " + newRegion);
-      c.getLoggerI18n().fine(
+      this.cache.getLoggerI18n().fine(
-      // } catch ( CacheException e ) {
-      // c.getLoggerI18n().warning ( "Error creating new Dynamic Region '" + newRegionName, e );
-      // throw e;
-      if (c.getLoggerI18n().fineEnabled()) {
-        c.getLoggerI18n()
+      if (this.cache.getLoggerI18n().fineEnabled()) {
+        this.cache.getLoggerI18n()
-      dynamicRegionList.put(newRegion.getFullPath(), dra);
+      this.dynamicRegionList.put(newRegion.getFullPath(), dra);
-    if (config.getRegisterInterest()) {
+    if (this.config.getRegisterInterest()) {
-            c.getSecurityLoggerI18n().warning(
+            this.cache.getSecurityLoggerI18n().warning(
-      } catch (InterruptedException e) {
+      } catch (InterruptedException ignore) {
-    if (c.getLoggerI18n().fineEnabled()) {
-      c.getLoggerI18n().fine("Created Dynamic Region " + newRegion.getFullPath());
+    if (this.cache.getLoggerI18n().fineEnabled()) {
+      this.cache.getLoggerI18n().fine("Created Dynamic Region " + newRegion.getFullPath());
-      if (c.getLoggerI18n().fineEnabled()) {
-        c.getLoggerI18n()
+      if (this.cache.getLoggerI18n().fineEnabled()) {
+        this.cache.getLoggerI18n()
-      dynamicRegionList.destroy(fullRegionName);
+      this.dynamicRegionList.destroy(fullRegionName);
-      c.getLoggerI18n().warning(
+      this.cache.getLoggerI18n().warning(
-    if (c.getLoggerI18n().fineEnabled()) {
-      c.getLoggerI18n().fine("Destroyed Dynamic Region " + fullRegionName);
+    if (this.cache.getLoggerI18n().fineEnabled()) {
+      this.cache.getLoggerI18n().fine("Destroyed Dynamic Region " + fullRegionName);
-   * <li>diskDir: <code>null</code>
-   * <li>poolName: <code>null</code>
-   * <li>persistBackup: <code>true</code>
-   * <li>registerInterest: <code>true</code>
+   * <li>diskDir: {@code null}
+   * <li>poolName: {@code null}
+   * <li>persistBackup: {@code true}
+   * <li>registerInterest: {@code true}
-     * null if no directory has been specified. The diskDir is only used if
-     * <code>persistBackup</code> is true.
+     * null if no directory has been specified. The diskDir is only used if {@code persistBackup} is
+     * true.
-      doBeforeRegionCreated(parentRegionName, newRegionName, event.getDistributedMember());
+      doBeforeRegionCreated(parentRegionName, newRegionName);
-      c.getLoggerI18n().warning(
+      cache.getLoggerI18n().warning(
-    // // Ignore the callback if it originated in this process (because the region
-    // // will already have been destroyed)
-    // if ( !event.isOriginRemote() && !(event instanceof BridgeEntryEventImpl)) return;
+
+    // Ignore the callback if it originated in this process (because the region
+    // will already have been destroyed)
-    Region drRegion = c.getRegion(fullRegionName);
+    Region drRegion = cache.getRegion(fullRegionName);
-        c.getLoggerI18n().warning(
+        cache.getLoggerI18n().warning(
-  // private class DRListener implements CacheListener {
-  // public void afterCreate(EntryEvent arg0) {
-  // buildDynamicRegion(arg0);
-  // }
-  //
-  // public void afterDestroy(EntryEvent arg0) {
-  // razeDynamicRegion(arg0);
-  // }
-  //
-  // public void afterInvalidate(EntryEvent arg0) {
-  // // Stub, nothing to do.
-  // }
-  //
-  // public void afterRegionDestroy(RegionEvent arg0) {
-  // // Stub, nothing to do.
-  // }
-  //
-  // public void afterRegionInvalidate(RegionEvent arg0) {
-  // // Stub, nothing to do.
-  // }
-  //
-  // public void afterUpdate(EntryEvent arg0) {
-  // // Stub, nothing to do.
-  // }
-  //
-  // public void close() {
-  // // Stub, nothing to do.
-  // }
-  // }
-
-      super(dynamicRegionListName, attrs, null, DynamicRegionFactory.this.c, ira);
+      super(dynamicRegionListName, attrs, null, DynamicRegionFactory.this.cache, ira);
-            } catch (InterruptedException ie) {
+            } catch (InterruptedException ignore) {
-              stopper.checkCancelInProgress(null);
+              this.stopper.checkCancelInProgress(null);
-      super(dynamicRegionListName, attrs, null, DynamicRegionFactory.this.c,
+      super(dynamicRegionListName, attrs, null, DynamicRegionFactory.this.cache,
-            } catch (InterruptedException ie) {
+            } catch (InterruptedException ignore) {
-              stopper.checkCancelInProgress(null);
+              this.stopper.checkCancelInProgress(null);

MOV26 INS26 INS40 UPD40 INS83 UPD43 INS83 UPD42 UPD42 MOV60 MOV60 INS66 UPD66 UPD66 INS66 INS66 UPD66 INS66 MOV32 UPD42 UPD42 INS32 UPD43 INS65 INS65 INS70 INS70 INS70 INS70 MOV60 MOV25 INS42 INS42 INS66 INS66 INS66 INS66 UPD66 INS65 UPD42 UPD43 INS66 INS65 UPD66 INS66 INS65 UPD66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 INS66 INS66 INS65 UPD66 INS44 INS42 MOV8 INS44 INS42 MOV8 INS44 INS42 MOV8 INS44 INS42 MOV8 INS66 INS65 UPD66 INS66 INS65 UPD66 MOV43 MOV43 UPD66 INS65 UPD66 INS65 UPD66 INS65 UPD66 INS65 INS66 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS66 INS66 UPD66 MOV66 UPD66 MOV66 UPD66 MOV66 INS66 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS66 INS66 UPD42 MOV32 UPD42 INS22 INS66 INS66 INS66 INS66 UPD66 INS65 INS66 INS66 UPD42 INS22 UPD42 MOV43 MOV43 UPD42 MOV42 MOV43 UPD42 MOV42 MOV43 UPD42 MOV42 MOV43 UPD42 MOV42 MOV43 INS22 INS22 INS22 INS52 INS42 INS22 INS22 UPD66 MOV66 UPD42 UPD42 UPD42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS22 INS52 INS42 UPD42 MOV43 INS13 MOV43 MOV43 INS42 MOV43 INS42 MOV43 INS42 MOV43 INS42 INS22 UPD42 INS22 MOV14 INS22 INS22 INS52 INS42 UPD42 INS22 INS22 INS52 INS42 INS22 UPD42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS52 INS42 UPD42 INS52 INS42 INS22 INS22 INS52 INS42 INS22 INS22 MOV14 MOV14 INS22 INS52 INS42 INS52 INS42 UPD42 INS52 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS22 INS22 UPD42 UPD42 UPD42 UPD42 INS52 INS42 INS52 INS42 UPD42 UPD42 INS22 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 DEL42 DEL32 DEL40 DEL42 DEL65 DEL42 DEL42 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL45 DEL33 DEL65 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL42 DEL65 DEL33 DEL42 DEL65 DEL42 DEL42 DEL42 DEL42 DEL8 DEL36 DEL33 DEL33 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42
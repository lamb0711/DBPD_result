Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class CompiledComparison extends AbstractCompiledValue implements
-    Negatable, OQLLexerTokenTypes, Indexable {
+public class CompiledComparison extends AbstractCompiledValue
+    implements Negatable, OQLLexerTokenTypes, Indexable {
-    Support.Assert(op == TOK_LT || op == TOK_LE || op == TOK_GT || op == TOK_GE
-        || op == TOK_EQ || op == TOK_NE, String.valueOf(op));
+    Support.Assert(op == TOK_LT || op == TOK_LE || op == TOK_GT || op == TOK_GE || op == TOK_EQ
+        || op == TOK_NE, String.valueOf(op));
-  public Object evaluate(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  public Object evaluate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    
+
-    
-    if(left == null || right == null){
-      return TypeUtils.compare(left,right,_operator);
+
+    if (left == null || right == null) {
+      return TypeUtils.compare(left, right, _operator);
-    if(!context.getCache().getPdxReadSerialized()) {
-      if(left instanceof PdxInstance && !(right instanceof PdxInstance) && ((PdxInstance)left).getClassName().equals(right.getClass().getName())) {
-        left = ((PdxInstance)left).getObject();
-      } else if(right instanceof PdxInstance && !(left instanceof PdxInstance) && ((PdxInstance)right).getClassName().equals(left.getClass().getName())) {
-        right = ((PdxInstance)right).getObject();
+    if (!context.getCache().getPdxReadSerialized()) {
+      if (left instanceof PdxInstance && !(right instanceof PdxInstance)
+          && ((PdxInstance) left).getClassName().equals(right.getClass().getName())) {
+        left = ((PdxInstance) left).getObject();
+      } else if (right instanceof PdxInstance && !(left instanceof PdxInstance)
+          && ((PdxInstance) right).getClassName().equals(left.getClass().getName())) {
+        right = ((PdxInstance) right).getObject();
-    } 
+    }
-        case LITERAL:
-          right = ((CompiledLiteral) _right).getSavedPdxString();
-          break;
-        case QUERY_PARAM:
-          right = ((CompiledBindArgument) _right).getSavedPdxString(context);
-          break;
-        case FUNCTION:
-        case PATH:
-          right = new PdxString((String) right);
+          case LITERAL:
+            right = ((CompiledLiteral) _right).getSavedPdxString();
+            break;
+          case QUERY_PARAM:
+            right = ((CompiledBindArgument) _right).getSavedPdxString(context);
+            break;
+          case FUNCTION:
+          case PATH:
+            right = new PdxString((String) right);
-      case LITERAL:
-        left = ((CompiledLiteral) _left).getSavedPdxString();
-        break;
-      case QUERY_PARAM:
-        left = ((CompiledBindArgument) _left).getSavedPdxString(context);
-        break;
-      case FUNCTION:
-      case PATH:
-        left = new PdxString((String) left);
+        case LITERAL:
+          left = ((CompiledLiteral) _left).getSavedPdxString();
+          break;
+        case QUERY_PARAM:
+          left = ((CompiledBindArgument) _left).getSavedPdxString(context);
+          break;
+        case FUNCTION:
+        case PATH:
+          left = new PdxString((String) left);
-   return TypeUtils.compare(left,right,_operator);
+    return TypeUtils.compare(left, right, _operator);
-  
+
-   * Asif : Evaluates as a filter taking advantage of indexes if appropriate.
-   * This function has a meaningful implementation only in CompiledComparison &
-   * CompiledUndefined . It is unsupported in other classes. The additional
-   * parameters which it takes are a boolean which is used to indicate whether
-   * the index result set needs to be expanded to the top level or not. The
-   * second is a CompiledValue representing the operands which are only iter
-   * evaluatable. The CompiledValue passed will be null except if a
-   * GroupJunction has only one filter evaluatable condition & rest are iter
-   * operands. In such cases , the iter operands will be evaluated while
-   * expanding/cutting down the index resultset
+   * Asif : Evaluates as a filter taking advantage of indexes if appropriate. This function has a
+   * meaningful implementation only in CompiledComparison & CompiledUndefined . It is unsupported in
+   * other classes. The additional parameters which it takes are a boolean which is used to indicate
+   * whether the index result set needs to be expanded to the top level or not. The second is a
+   * CompiledValue representing the operands which are only iter evaluatable. The CompiledValue
+   * passed will be null except if a GroupJunction has only one filter evaluatable condition & rest
+   * are iter operands. In such cases , the iter operands will be evaluated while expanding/cutting
+   * down the index resultset
-  public SelectResults filterEvaluate(ExecutionContext context,
-      SelectResults intermediateResults, boolean completeExpansionNeeded,
-      @Retained CompiledValue iterOperands, RuntimeIterator[] indpndntItrs, boolean isIntersection, boolean conditioningNeeded, boolean evaluateProjection)
-      throws FunctionDomainException, TypeMismatchException,
+  public SelectResults filterEvaluate(ExecutionContext context, SelectResults intermediateResults,
+      boolean completeExpansionNeeded, @Retained CompiledValue iterOperands,
+      RuntimeIterator[] indpndntItrs, boolean isIntersection, boolean conditioningNeeded,
+      boolean evaluateProjection) throws FunctionDomainException, TypeMismatchException,
-        return super.filterEvaluate(context, intermediateResults);
+      return super.filterEvaluate(context, intermediateResults);
-    Support
-        .Assert(
-            idxInfo != null,
-            "a comparison that is dependent, not indexed, and filter evaluated is not possible");
+    Support.Assert(idxInfo != null,
+        "a comparison that is dependent, not indexed, and filter evaluated is not possible");
-          completeExpansionNeeded, iterOperands, idxInfo[0], indpndntItrs, isIntersection,conditioningNeeded, evaluateProjection);
-    }
-    else {
-      Support
-          .Assert(
-              idxInfo.length == 2,
-              "A Composite CompiledComparison which is filter evaluatable needs to have two indexes");
+          completeExpansionNeeded, iterOperands, idxInfo[0], indpndntItrs, isIntersection,
+          conditioningNeeded, evaluateProjection);
+    } else {
+      Support.Assert(idxInfo.length == 2,
+          "A Composite CompiledComparison which is filter evaluatable needs to have two indexes");
-  }  
+  }
-   * evaluate as a filter, producing an intermediate result set. This may
-   * require iteration if there is no index available. Asif :The booelan true
-   * implies that CompiledComparsion when existing on its own always requires a
-   * Completeexpansion to top level iterators. This flag can get toggled to
-   * false only from inside a GroupJunction
+   * evaluate as a filter, producing an intermediate result set. This may require iteration if there
+   * is no index available. Asif :The booelan true implies that CompiledComparsion when existing on
+   * its own always requires a Completeexpansion to top level iterators. This flag can get toggled
+   * to false only from inside a GroupJunction
-   * @param intermediateResults if this parameter is provided, and we have to
-   *          iterate, then iterate over this result set instead of the entire
-   *          base collection.
+   * @param intermediateResults if this parameter is provided, and we have to iterate, then iterate
+   *        over this result set instead of the entire base collection.
-  public SelectResults filterEvaluate(ExecutionContext context,
-      SelectResults intermediateResults) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+  public SelectResults filterEvaluate(ExecutionContext context, SelectResults intermediateResults)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-    
+
-    Set rntmItrs =  QueryUtils.getCurrentScopeUltimateRuntimeIteratorsIfAny(this,context);
-    if(rntmItrs.size() ==1 && currentScopeIndpndntItrs.size() ==1  ) {
-      indpndntItr = (RuntimeIterator)rntmItrs.iterator().next();
+    Set rntmItrs = QueryUtils.getCurrentScopeUltimateRuntimeIteratorsIfAny(this, context);
+    if (rntmItrs.size() == 1 && currentScopeIndpndntItrs.size() == 1) {
+      indpndntItr = (RuntimeIterator) rntmItrs.iterator().next();
-    
-    
+
+
-                                                             * Complete
-                                                             * Expansion needed
-                                                             */, null, indpndntItr !=null?new RuntimeIterator[]{indpndntItr}:null/*
-                    * Asif :It is safe to pass null as the independent iterator
-                    * to which the condition belongs is required only if boolean
-                    * complete expansion turns out to be false, which can happen
-                    * only in case of CompiledComparison/CompiledUndefined
-                    * called from roupJunction or CompositeGroupJunction
-                    */, true,this.isConditioningNeededForIndex(indpndntItr, context, true),true /*evaluate projection attribute */);
+                                                             * Complete Expansion needed
+                                                             */, null,
+        indpndntItr != null ? new RuntimeIterator[] {indpndntItr}
+            : null/*
+                   * Asif :It is safe to pass null as the independent iterator to which the
+                   * condition belongs is required only if boolean complete expansion turns out to
+                   * be false, which can happen only in case of CompiledComparison/CompiledUndefined
+                   * called from roupJunction or CompositeGroupJunction
+                   */,
+        true, this.isConditioningNeededForIndex(indpndntItr, context, true),
+        true /* evaluate projection attribute */);
-   * Asif : This function should never get invoked as now if a CompiledJunction
-   * or GroupJunction contains a single filterable CompiledComparison it should
-   * directly call filterEvaluate rather than auxFilterEvalutae. Overriding this
-   * function just for ensuring that auxFilterEvaluate is not being called by
-   * mistake.
+   * Asif : This function should never get invoked as now if a CompiledJunction or GroupJunction
+   * contains a single filterable CompiledComparison it should directly call filterEvaluate rather
+   * than auxFilterEvalutae. Overriding this function just for ensuring that auxFilterEvaluate is
+   * not being called by mistake.
-      SelectResults intermediateResults) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
-    Support
-        .assertionFailed(" This auxFilterEvaluate of CompiledComparison should never have got invoked.");
+      SelectResults intermediateResults) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
+    Support.assertionFailed(
+        " This auxFilterEvaluate of CompiledComparison should never have got invoked.");
-    if (indexInfo == null) return result;
+    if (indexInfo == null)
+      return result;
-    String preferredCondn = (String)context.cacheGet(PREF_INDEX_COND);
-   if(preferredCondn != null) {
-     //This means that the system is having only one independent iterator so equi join is ruled out.
-     // thus the first index is guaranteed to be on the condition which may match our preferred index
-     if(indexInfo[0]._index.getCanonicalizedIndexedExpression().equals(preferredCondn) && 
-         indexInfo[0]._index.getType() != IndexType.PRIMARY_KEY) {
-       result.isPreferred = true;
-     }
-   }
+    String preferredCondn = (String) context.cacheGet(PREF_INDEX_COND);
+    if (preferredCondn != null) {
+      // This means that the system is having only one independent iterator so equi join is ruled
+      // out.
+      // thus the first index is guaranteed to be on the condition which may match our preferred
+      // index
+      if (indexInfo[0]._index.getCanonicalizedIndexedExpression().equals(preferredCondn)
+          && indexInfo[0]._index.getType() != IndexType.PRIMARY_KEY) {
+        result.isPreferred = true;
+      }
+    }
-  }  
-  
+  }
+
-  
+
-    if(this._left instanceof MapIndexable || this._right instanceof MapIndexable ) {
+    if (this._left instanceof MapIndexable || this._right instanceof MapIndexable) {
-  public int getSizeEstimate(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException
-  {
+  public int getSizeEstimate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    
+
-   * evaluate as a filter, involving a single iterator. Use an index if
-   * possible.
+   * evaluate as a filter, involving a single iterator. Use an index if possible.
-  private SelectResults singleBaseCollectionFilterEvaluate(
-      ExecutionContext context,  SelectResults intermediateResults,
-      final boolean completeExpansionNeeded, @Retained CompiledValue iterOperands,
-      IndexInfo indexInfo, RuntimeIterator[] indpndntItr, boolean isIntersection, boolean conditioningNeeded, boolean evaluateProj)
-      throws TypeMismatchException, AmbiguousNameException,
-      FunctionDomainException, NameResolutionException,
-      QueryInvocationTargetException
-  {
+  private SelectResults singleBaseCollectionFilterEvaluate(ExecutionContext context,
+      SelectResults intermediateResults, final boolean completeExpansionNeeded,
+      @Retained CompiledValue iterOperands, IndexInfo indexInfo, RuntimeIterator[] indpndntItr,
+      boolean isIntersection, boolean conditioningNeeded, boolean evaluateProj)
+      throws TypeMismatchException, AmbiguousNameException, FunctionDomainException,
+      NameResolutionException, QueryInvocationTargetException {
-    createEmptySet = (key != null && key.equals(QueryService.UNDEFINED)) ;
+    createEmptySet = (key != null && key.equals(QueryService.UNDEFINED));
-      indexFieldsSize = ((StructTypeImpl)resultType).getFieldNames().length;
-    }
-    else {
-      indexFieldsSize = 1;      
+      indexFieldsSize = ((StructTypeImpl) resultType).getFieldNames().length;
+    } else {
+      indexFieldsSize = 1;
-     * Asif : First obtain the match level of index resultset. If the match
-     * level happens to be zero , this implies that we just have to change the
-     * StructType ( again if only the Index resultset is a StructBag). If the
-     * match level is zero & expand to to top level flag is true & iff the total
-     * no. of iterators in current scope is greater than the no. of fields in
-     * StructBag , then only we need to do any expansion.
+     * Asif : First obtain the match level of index resultset. If the match level happens to be zero
+     * , this implies that we just have to change the StructType ( again if only the Index resultset
+     * is a StructBag). If the match level is zero & expand to to top level flag is true & iff the
+     * total no. of iterators in current scope is greater than the no. of fields in StructBag , then
+     * only we need to do any expansion.
-      if( !createEmptySet) {
+      if (!createEmptySet) {
-      }	
+      }
-      boolean useLinkedDataStructure = false;  
+      boolean useLinkedDataStructure = false;
-      Boolean orderByClause = (Boolean)context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-      if(orderByClause != null && orderByClause.booleanValue()) {
-        List orderByAttrs = (List)context.cacheGet(CompiledValue.ORDERBY_ATTRIB);        
-        useLinkedDataStructure =orderByAttrs.size()==1;
-        nullValuesAtStart = !((CompiledSortCriterion)orderByAttrs.get(0)).getCriterion();
+      Boolean orderByClause = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
+      if (orderByClause != null && orderByClause.booleanValue()) {
+        List orderByAttrs = (List) context.cacheGet(CompiledValue.ORDERBY_ATTRIB);
+        useLinkedDataStructure = orderByAttrs.size() == 1;
+        nullValuesAtStart = !((CompiledSortCriterion) orderByAttrs.get(0)).getCriterion();
-        ObjectType projResultType = evaluateProj ? (ObjectType)context
-            .cacheGet(RESULT_TYPE) : null;
+        ObjectType projResultType =
+            evaluateProj ? (ObjectType) context.cacheGet(RESULT_TYPE) : null;
-          projAttrib = (List)context.cacheGet(PROJ_ATTRIB);
+          projAttrib = (List) context.cacheGet(PROJ_ATTRIB);
-        
+
-            context.getCache().getLogger().fine(
-                "StructType resultType.class="
-                    + resultType.getClass().getName());
-            if(useLinkedDataStructure) {
-              set = context.isDistinct() ? new LinkedStructSet((StructTypeImpl)resultType) 
-              : new SortedResultsBag<Struct>((StructTypeImpl)resultType, nullValuesAtStart);
-            }else {
-              set = QueryUtils.createStructCollection(context, (StructTypeImpl)resultType) ;
-            }
-            indexFieldsSize = ((StructTypeImpl)resultType).getFieldNames().length;
-          }
-          else {
-            context.getCache().getLogger().fine(
-                "non-StructType resultType.class="
-                    + resultType.getClass().getName());
+            context.getCache().getLogger()
+                .fine("StructType resultType.class=" + resultType.getClass().getName());
-              set = context.isDistinct() ? new LinkedResultSet(resultType) :
-                new SortedResultsBag(resultType, nullValuesAtStart) ;
+              set = context.isDistinct() ? new LinkedStructSet((StructTypeImpl) resultType)
+                  : new SortedResultsBag<Struct>((StructTypeImpl) resultType, nullValuesAtStart);
-              set = QueryUtils.createResultCollection(context, resultType) ;
+              set = QueryUtils.createStructCollection(context, (StructTypeImpl) resultType);
+            }
+            indexFieldsSize = ((StructTypeImpl) resultType).getFieldNames().length;
+          } else {
+            context.getCache().getLogger()
+                .fine("non-StructType resultType.class=" + resultType.getClass().getName());
+            if (useLinkedDataStructure) {
+              set = context.isDistinct() ? new LinkedResultSet(resultType)
+                  : new SortedResultsBag(resultType, nullValuesAtStart);
+            } else {
+              set = QueryUtils.createResultCollection(context, resultType);
-        }
-        else {
+        } else {
-          if (intermediateResults != null && context.getQuery() != null && 
-              ((DefaultQuery)context.getQuery()).getSelect().isDistinct()) {
-              set = intermediateResults;
-              intermediateResults = null;
-          }
-          else {
+          if (intermediateResults != null && context.getQuery() != null
+              && ((DefaultQuery) context.getQuery()).getSelect().isDistinct()) {
+            set = intermediateResults;
+            intermediateResults = null;
+          } else {
-              context.getCache().getLogger().fine(
-                  "StructType resultType.class="
-                      + resultType.getClass().getName());
-              if(useLinkedDataStructure) {
-                set = context.isDistinct() ? new LinkedStructSet((StructTypeImpl)resultType) 
-                : new  SortedResultsBag<Struct>((StructTypeImpl)resultType, nullValuesAtStart);
-              }else {
-                set = QueryUtils.createStructCollection(context,(StructTypeImpl)resultType) ;
-              }
-              indexFieldsSize = ((StructTypeImpl)resultType).getFieldNames().length;
-            }
-            else {
-              context.getCache().getLogger().fine(
-                  "non-StructType resultType.class="
-                      + resultType.getClass().getName());
+              context.getCache().getLogger()
+                  .fine("StructType resultType.class=" + resultType.getClass().getName());
-                set = context.isDistinct() ? new LinkedResultSet(resultType) : 
-                  new SortedResultsBag(resultType, nullValuesAtStart ); 
+                set = context.isDistinct() ? new LinkedStructSet((StructTypeImpl) resultType)
+                    : new SortedResultsBag<Struct>((StructTypeImpl) resultType, nullValuesAtStart);
-                set = QueryUtils.createResultCollection(context, resultType) ;
+                set = QueryUtils.createStructCollection(context, (StructTypeImpl) resultType);
+              }
+              indexFieldsSize = ((StructTypeImpl) resultType).getFieldNames().length;
+            } else {
+              context.getCache().getLogger()
+                  .fine("non-StructType resultType.class=" + resultType.getClass().getName());
+              if (useLinkedDataStructure) {
+                set = context.isDistinct() ? new LinkedResultSet(resultType)
+                    : new SortedResultsBag(resultType, nullValuesAtStart);
+              } else {
+                set = QueryUtils.createResultCollection(context, resultType);
-        if(!createEmptySet) {
-          indexInfo._index.query(key, op, set, iterOperands, indpndntItr != null? indpndntItr[0]:null,
-            context, projAttrib, intermediateResults,
-            isIntersection);
+        if (!createEmptySet) {
+          indexInfo._index.query(key, op, set, iterOperands,
+              indpndntItr != null ? indpndntItr[0] : null, context, projAttrib, intermediateResults,
+              isIntersection);
-      }
-      else {
+      } else {
-          context.getCache().getLogger().fine(
-              "StructType resultType.class=" + resultType.getClass().getName());
+          context.getCache().getLogger()
+              .fine("StructType resultType.class=" + resultType.getClass().getName());
-            set = context.isDistinct() ? new LinkedStructSet((StructTypeImpl)resultType) 
-            : new SortedResultsBag<Struct>((StructTypeImpl)resultType, nullValuesAtStart);
+            set = context.isDistinct() ? new LinkedStructSet((StructTypeImpl) resultType)
+                : new SortedResultsBag<Struct>((StructTypeImpl) resultType, nullValuesAtStart);
-            set = QueryUtils.createStructCollection(context, (StructTypeImpl)resultType) ;
+            set = QueryUtils.createStructCollection(context, (StructTypeImpl) resultType);
-          
-          indexFieldsSize = ((StructTypeImpl)resultType).getFieldNames().length;
-        }
-        else {
-          context.getCache().getLogger().fine(
-              "non-StructType resultType.class="
-                  + resultType.getClass().getName());
+
+          indexFieldsSize = ((StructTypeImpl) resultType).getFieldNames().length;
+        } else {
+          context.getCache().getLogger()
+              .fine("non-StructType resultType.class=" + resultType.getClass().getName());
-            set = context.isDistinct() ? new LinkedResultSet(resultType) :
-              new SortedResultsBag(resultType, nullValuesAtStart);
+            set = context.isDistinct() ? new LinkedResultSet(resultType)
+                : new SortedResultsBag(resultType, nullValuesAtStart);
-            set = QueryUtils.createResultCollection(context, resultType) ;
-          }     
+            set = QueryUtils.createResultCollection(context, resultType);
+          }
-        if(!createEmptySet) {
+        if (!createEmptySet) {
-    }
-    finally {
-      if(!createEmptySet) {
+    } finally {
+      if (!createEmptySet) {
-      }	
+      }
-      return QueryUtils.getconditionedIndexResults(set, indexInfo, context,
-          indexFieldsSize, completeExpansionNeeded, iterOperands, indpndntItr);
-    }
-    else {
+      return QueryUtils.getconditionedIndexResults(set, indexInfo, context, indexFieldsSize,
+          completeExpansionNeeded, iterOperands, indpndntItr);
+    } else {
-   * evaluate as a filter, involving a two independent iterators. Use an index
-   * if possible on both. And merge theresults obtained.
+   * evaluate as a filter, involving a two independent iterators. Use an index if possible on both.
+   * And merge theresults obtained.
-  private SelectResults doubleBaseCollectionFilterEvaluate(
-      ExecutionContext context, SelectResults intermediateResults,
-      boolean completeExpansionNeeded, CompiledValue iterOperands,
-      IndexInfo[] indxInfo, RuntimeIterator[] indpdntItrs)
-      throws TypeMismatchException, AmbiguousNameException,
-      FunctionDomainException, NameResolutionException,
-      QueryInvocationTargetException {
-    //Asif : First we need to collect the results of the two indexes
-    //We will be calling a function of Index & passing the other Index as a
+  private SelectResults doubleBaseCollectionFilterEvaluate(ExecutionContext context,
+      SelectResults intermediateResults, boolean completeExpansionNeeded,
+      CompiledValue iterOperands, IndexInfo[] indxInfo, RuntimeIterator[] indpdntItrs)
+      throws TypeMismatchException, AmbiguousNameException, FunctionDomainException,
+      NameResolutionException, QueryInvocationTargetException {
+    // Asif : First we need to collect the results of the two indexes
+    // We will be calling a function of Index & passing the other Index as a
-    //We will be getting List object. Each element of the List will contain a
+    // We will be getting List object. Each element of the List will contain a
-    //Object array. The first row will contain the result objects of the first
+    // Object array. The first row will contain the result objects of the first
-    //& secondrow will contain that of second index. The object contained in
+    // & secondrow will contain that of second index. The object contained in
-     * Asif : If the independent Group of iterators passed is not null or the
-     * independent Group of iterators passed is null & complete expansion flag
-     * is true & the intermediate result set is empty or null, in such cases ,
-     * we have to definitely use indexes on both conditions & go for complete
-     * expansion or CompsoiteGroupJunction expansion as be the case. ( ie
-     * retaining the old logic of expanding the index result to top or
-     * compositeGroupJunction level)
+     * Asif : If the independent Group of iterators passed is not null or the independent Group of
+     * iterators passed is null & complete expansion flag is true & the intermediate result set is
+     * empty or null, in such cases , we have to definitely use indexes on both conditions & go for
+     * complete expansion or CompsoiteGroupJunction expansion as be the case. ( ie retaining the old
+     * logic of expanding the index result to top or compositeGroupJunction level)
-     * The condition in which we sure are to use indexes on both LHS & RHS & the
-     * the resultset expanded to CGJ or top level are 1) A stand alone
-     * filterable composite condition : In such cases the independent group of
-     * itr is passed as null , the intermediate resultset is empty & the
-     * complete expansion flag is true. This indicates that we have to expand to
-     * top level. 2) Multiple filterable composite condition in OR junction: In
-     * such cases the independent grp of its passed is not null but the
-     * intermediate resultset is null . This means that indexes on both LHS &
-     * RHS to be used & expanded to top or CGJ level ( same as above)
+     * The condition in which we sure are to use indexes on both LHS & RHS & the the resultset
+     * expanded to CGJ or top level are 1) A stand alone filterable composite condition : In such
+     * cases the independent group of itr is passed as null , the intermediate resultset is empty &
+     * the complete expansion flag is true. This indicates that we have to expand to top level. 2)
+     * Multiple filterable composite condition in OR junction: In such cases the independent grp of
+     * its passed is not null but the intermediate resultset is null . This means that indexes on
+     * both LHS & RHS to be used & expanded to top or CGJ level ( same as above)
-     * The case which is different from above is AND condition evaluation In
-     * such cases, till the last but one filerable condition we pass complete
-     * expn flag as false & group of indpndt itrs as null. Only last filterabel
-     * condn is passed genuine value of expn flag & the not null grp of
-     * independent itrs . The intermedaite set is not null & not empty for such
-     * cases which wil help us distinguish the case from OR junction
+     * The case which is different from above is AND condition evaluation In such cases, till the
+     * last but one filerable condition we pass complete expn flag as false & group of indpndt itrs
+     * as null. Only last filterabel condn is passed genuine value of expn flag & the not null grp
+     * of independent itrs . The intermedaite set is not null & not empty for such cases which wil
+     * help us distinguish the case from OR junction
-     * IndependentGroup Iterators being null or not null is not a definitive &
-     * exclusive * criteria for knowing whether the CC result needs to be
-     * expanded to Top or CGJ level as for independent grp not null will happen
-     * in OR junction implying expn to CGJ level & ignoring intermediate
-     * resultset as well as in evalaution of last filterable condition of AND
-     * junction implying usage of intermediate resultset for cartesian.
+     * IndependentGroup Iterators being null or not null is not a definitive & exclusive * criteria
+     * for knowing whether the CC result needs to be expanded to Top or CGJ level as for independent
+     * grp not null will happen in OR junction implying expn to CGJ level & ignoring intermediate
+     * resultset as well as in evalaution of last filterable condition of AND junction implying
+     * usage of intermediate resultset for cartesian.
-     * Similarly grp of indpendent itrs can be null for stand alone condition
-     * implying expn to top level & ignoring intermediate set & also for
-     * evaluating all the conditions except last in AND junction( which means
-     * using intermediate resultset for cartesian)
-     *  
+     * Similarly grp of indpendent itrs can be null for stand alone condition implying expn to top
+     * level & ignoring intermediate set & also for evaluating all the conditions except last in AND
+     * junction( which means using intermediate resultset for cartesian)
+     * 
-       * Asif : First obtain the match level of index resultset. If the match
-       * level happens to be zero , this implies that we just have to change the
-       * StructType ( again if only the Index resultset is a StructBag). If the
-       * match level is zero & expand to to top level flag is true & iff the
-       * total no. of iterators in current scope is greater than the no. of
-       * fields in StructBag , then only we need to do any expansion.
-       *  
+       * Asif : First obtain the match level of index resultset. If the match level happens to be
+       * zero , this implies that we just have to change the StructType ( again if only the Index
+       * resultset is a StructBag). If the match level is zero & expand to to top level flag is true
+       * & iff the total no. of iterators in current scope is greater than the no. of fields in
+       * StructBag , then only we need to do any expansion.
+       * 
-      Support
-          .Assert(this._operator == TOK_EQ,
-              "A relationship index is not usable for any condition other than equality");
+      Support.Assert(this._operator == TOK_EQ,
+          "A relationship index is not usable for any condition other than equality");
-      }
-      finally {
+      } finally {
-      return QueryUtils
-          .getconditionedRelationshipIndexResultsExpandedToTopOrCGJLevel(data,
-              indxInfo, context, completeExpansionNeeded, iterOperands,
-              indpdntItrs);
-    }
-    else {
+      return QueryUtils.getconditionedRelationshipIndexResultsExpandedToTopOrCGJLevel(data,
+          indxInfo, context, completeExpansionNeeded, iterOperands, indpdntItrs);
+    } else {
-      return QueryUtils
-          .getRelationshipIndexResultsMergedWithIntermediateResults(
-              intermediateResults, indxInfo, context, completeExpansionNeeded,
-              iterOperands, indpdntItrs);
+      return QueryUtils.getRelationshipIndexResultsMergedWithIntermediateResults(
+          intermediateResults, indxInfo, context, completeExpansionNeeded, iterOperands,
+          indpdntItrs);
-      
+
-    if (indexInfo != null ) {
-      if(indexInfo == NO_INDEXES_IDENTIFIER) {
+    if (indexInfo != null) {
+      if (indexInfo == NO_INDEXES_IDENTIFIER) {
-      }else {
+      } else {
-    
-    if (!IndexUtils.indexesEnabled) return null;   
+
+    if (!IndexUtils.indexesEnabled)
+      return null;
-      IndexData[] indexData = QueryUtils.getRelationshipIndexIfAny(_left,
-          _right, context, this._operator);// findOnlyFunctionalIndex.
+      IndexData[] indexData =
+          QueryUtils.getRelationshipIndexIfAny(_left, _right, context, this._operator);// findOnlyFunctionalIndex.
-          newIndexInfo[i] = new IndexInfo(null, i == 0 ? _left : _right,
-              indexData[i].getIndex(), indexData[i].getMatchLevel(),
-              indexData[i].getMapping(), i == 0 ? this._operator : reflectOperator(this._operator));
+          newIndexInfo[i] = new IndexInfo(null, i == 0 ? _left : _right, indexData[i].getIndex(),
+              indexData[i].getMatchLevel(), indexData[i].getMapping(),
+              i == 0 ? this._operator : reflectOperator(this._operator));
-    }
-    else {
+    } else {
-        indexData = QueryUtils.getAvailableIndexIfAny(path, context,
-            OQLLexerTokenTypes.LITERAL_like);
+        indexData =
+            QueryUtils.getAvailableIndexIfAny(path, context, OQLLexerTokenTypes.LITERAL_like);
-        indexData = QueryUtils.getAvailableIndexIfAny(path, context,
-            this._operator);
+        indexData = QueryUtils.getAvailableIndexIfAny(path, context, this._operator);
- 
+
-        newIndexInfo[0] = new IndexInfo(indexKey, path, index, indexData
-            .getMatchLevel(), indexData.getMapping(), reflectOnOperator(indexKey));
+        newIndexInfo[0] = new IndexInfo(indexKey, path, index, indexData.getMatchLevel(),
+            indexData.getMapping(), reflectOnOperator(indexKey));
-    if(newIndexInfo != null ) {
+    if (newIndexInfo != null) {
-    }else {
+    } else {
-  
-  CompiledValue getKey(ExecutionContext context) throws AmbiguousNameException, TypeMismatchException {    
-    return getPathAndKey(context)._key;    
+
+  CompiledValue getKey(ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException {
+    return getPathAndKey(context)._key;
-   * get the path to see if there's an index for, and also determine which
-   * CompiledValue is the key while we're at it
+   * get the path to see if there's an index for, and also determine which CompiledValue is the key
+   * while we're at it
-    if ((isLeftDependent == false) == (isRightDependent == false)) return null;
+    if ((isLeftDependent == false) == (isRightDependent == false))
+      return null;
-    }
-    else {
+    } else {
-    if (indexKey.isDependentOnCurrentScope(context)) return null; // this check
+    if (indexKey.isDependentOnCurrentScope(context))
+      return null; // this check
-  public boolean isProjectionEvaluationAPossibility(ExecutionContext context)
-  {
+  public boolean isProjectionEvaluationAPossibility(ExecutionContext context) {
-  
+
-  public boolean isLimitApplicableAtIndexLevel(ExecutionContext context)  {
+  public boolean isLimitApplicableAtIndexLevel(ExecutionContext context) {
-  
+
-      String canonicalizedOrderByClause) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
+      String canonicalizedOrderByClause) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
-        IndexProtocol ip = (IndexProtocol)pi.indexes.get(0);
-        if (ip.getCanonicalizedIndexedExpression().equals(
-            canonicalizedOrderByClause) && ip.getType() != IndexType.PRIMARY_KEY && pi.isPreferred) {
+        IndexProtocol ip = (IndexProtocol) pi.indexes.get(0);
+        if (ip.getCanonicalizedIndexedExpression().equals(canonicalizedOrderByClause)
+            && ip.getType() != IndexType.PRIMARY_KEY && pi.isPreferred) {
-  
-  public boolean isConditioningNeededForIndex(RuntimeIterator independentIter, 
-      ExecutionContext context, boolean completeExpnsNeeded) throws AmbiguousNameException, TypeMismatchException, NameResolutionException  {
+
+  public boolean isConditioningNeededForIndex(RuntimeIterator independentIter,
+      ExecutionContext context, boolean completeExpnsNeeded)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-    if(idxInfo == null || idxInfo.length > 1) {
+    if (idxInfo == null || idxInfo.length > 1) {
-    //assert idxInfo.length == 1;
+    // assert idxInfo.length == 1;
-      indexFieldsSize = ((StructTypeImpl)indexRsltType).getFieldNames().length;
+      indexFieldsSize = ((StructTypeImpl) indexRsltType).getFieldNames().length;
+    } else {
+      indexFieldsSize = 1;
-    else {
-      indexFieldsSize = 1;      
-    }
-    
-    if (independentIter != null   && indexFieldsSize == 1) {
-      ich = new IndexConditioningHelper(idxInfo[0], context, indexFieldsSize,
-          completeExpnsNeeded, null, independentIter);
+
+    if (independentIter != null && indexFieldsSize == 1) {
+      ich = new IndexConditioningHelper(idxInfo[0], context, indexFieldsSize, completeExpnsNeeded,
+          null, independentIter);
-   
+
-  
+
-  
-  public boolean isBetterFilter(Filter comparedTo, ExecutionContext context, final int thisSize) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException 
-  {
-    //If the current filter is equality & comparedTo filter is also equality based , then 
+
+  public boolean isBetterFilter(Filter comparedTo, ExecutionContext context, final int thisSize)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
+    // If the current filter is equality & comparedTo filter is also equality based , then
-   
+
-    int thatOperator = comparedTo.getOperator() ;
-    
-    //Go with the lowest cost when hint is used.  
-    if (context instanceof QueryExecutionContext && ((QueryExecutionContext)context).hasHints()) {
+    int thatOperator = comparedTo.getOperator();
+
+    // Go with the lowest cost when hint is used.
+    if (context instanceof QueryExecutionContext && ((QueryExecutionContext) context).hasHints()) {
-    
-    //There may be some hard rules that give unoptimal selections based on these switch cases.
-    if(this._operator == TOK_EQ || this._operator == TOK_NE || this._operator == TOK_NE_ALT) {
-       switch(thatOperator) {
+
+    // There may be some hard rules that give unoptimal selections based on these switch cases.
+    if (this._operator == TOK_EQ || this._operator == TOK_NE || this._operator == TOK_NE_ALT) {
+      switch (thatOperator) {
-           isThisBetter = thisSize <= thatSize;
-           break;
+          isThisBetter = thisSize <= thatSize;
+          break;
-// This is is possible only in case of RangeJunction. 
-          if(this._operator == TOK_NE || this._operator == TOK_NE_ALT ) {
-            //Asif: Give preference to range as I am assuming that range will fetch less data 
+          // This is is possible only in case of RangeJunction.
+          if (this._operator == TOK_NE || this._operator == TOK_NE_ALT) {
+            // Asif: Give preference to range as I am assuming that range will fetch less data
-            isThisBetter = false;            
+            isThisBetter = false;
-          //Give preference to this rather than that as this is more deterministic
+          // Give preference to this rather than that as this is more deterministic
-        default :
-            throw  new IllegalArgumentException("The operator type ="+ thatOperator + " is unknown");
-       }          
-    }else  {
-      //This is a inequality. If that is true the priority goes to equality & Not Equality & Range 
-      switch(thatOperator) {
+        default:
+          throw new IllegalArgumentException("The operator type =" + thatOperator + " is unknown");
+      }
+    } else {
+      // This is a inequality. If that is true the priority goes to equality & Not Equality & Range
+      switch (thatOperator) {
-        case TOK_NE_ALT:      
-        case LITERAL_and:       
-          //Asif: Give preference to range as I am assuming that raneg will fetch less data 
+        case TOK_NE_ALT:
+        case LITERAL_and:
+          // Asif: Give preference to range as I am assuming that raneg will fetch less data
-          isThisBetter = false;      
+          isThisBetter = false;
-        default :
-          throw  new IllegalArgumentException("The operator type ="+ thatOperator + " is unknown");
-      
+        default:
+          throw new IllegalArgumentException("The operator type =" + thatOperator + " is unknown");
+
-    }  
+    }
-  }  
-  
+  }
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66
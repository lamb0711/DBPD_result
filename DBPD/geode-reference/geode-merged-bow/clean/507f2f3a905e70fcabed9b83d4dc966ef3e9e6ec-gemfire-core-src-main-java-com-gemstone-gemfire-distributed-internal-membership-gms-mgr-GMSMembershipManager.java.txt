Revert "Removing TCPConduit's Stub ID class"

This reverts commit 5b35e43f93bfbf6d62eadf7979eb3a8b7f59b77e.

This commit was causing compilation failures.

+import com.gemstone.gemfire.internal.tcp.Stub;
+    Stub stub;
-        sb.append("connect; member = <" + member + ">");
+        sb.append("connect; member = <" + member + ">; stub = " + stub);
+     * @param id the stub
-    StartupEvent(final InternalDistributedMember member) {
+    StartupEvent(final InternalDistributedMember member, final Stub id) {
+      this.stub = id;
+   * a map keyed on InternalDistributedMember, values are Stubs that represent direct
+   * channels to other systems
+   * 
+   * Accesses must be under the read or write lock of {@link #latestViewLock}.
+   */
+  protected final Map<InternalDistributedMember, Stub> memberToStubMap = 
+      new ConcurrentHashMap<InternalDistributedMember, Stub>();
+
+  /**
+   * a map of direct channels (Stub) to InternalDistributedMember. key instanceof Stub
+   * value instanceof InternalDistributedMember
+   * 
+   * Accesses must be under the read or write lock of {@link #latestViewLock}.
+   */
+  protected final Map<Stub, InternalDistributedMember> stubToMemberMap = 
+      new ConcurrentHashMap<Stub, InternalDistributedMember>();
+  
+  /**
+        // fix for bug #42006, lingering old identity
+        Object oldStub = this.memberToStubMap.remove(m);
+        if (oldStub != null) {
+          this.stubToMemberMap.remove(oldStub);
+        }
+
+      Stub stub = directChannel.getLocalStub();
+      memberToStubMap.put(address, stub);
+      stubToMemberMap.put(stub, address);
+   * @param stub its stub
+    Stub stub = new Stub(member.getInetAddress(), member.getDirectChannelPort(), member.getVmViewId());
-        startupMessages.add(new StartupEvent(member));
+        startupMessages.add(new StartupEvent(member, stub));
-    processSurpriseConnect(member);
+    processSurpriseConnect(member, stub);
+   * @param stub the member's stub
-  public boolean addSurpriseMember(DistributedMember dm) {
+  public boolean addSurpriseMember(DistributedMember dm, 
+      Stub stub) {
+    Stub s = null;
+        // fix for bug #42006, lingering old identity
+        Object oldStub = this.memberToStubMap.remove(member);
+        if (oldStub != null) {
+          this.stubToMemberMap.remove(oldStub);
+        }
+
+        s = stub == null ? getStubForMember(member) : stub;
+        // Make sure that channel information is consistent
+        addChannel(member, s);
+
-          shunned = !addSurpriseMember(m);
+          shunned = !addSurpriseMember(m, getStubForMember(m));
-      throw new MemberShunnedException(m);
+      throw new MemberShunnedException(getStubForMember(m));
+   * @param stub
-      InternalDistributedMember member) 
+      InternalDistributedMember member, 
+      Stub stub) 
-    addSurpriseMember(member);
+    addSurpriseMember(member, stub);
-      processSurpriseConnect(o.member);
+      processSurpriseConnect(o.member, o.stub);
-  public boolean memberExists(DistributedMember m) {
+  public boolean memberExists(InternalDistributedMember m) {
+    // could we guarantee not to allocate objects?  We're using Darrel's 
+    // factory, so it's possible that an unsafe implementation could be
+    // introduced here.
+//    stubToMemberMap.clear();
+//    memberToStubMap.clear();
+    
-        List<InternalDistributedMember> keySet = latestView.getMembers();
+        Set keySet = memberToStubMap.keySet();
+  /**
+   * Get or create stub for given member
+   */
+  public Stub getStubForMember(InternalDistributedMember m)
+  {
+    if (shutdownInProgress) {
+      throw new DistributedSystemDisconnectedException(LocalizedStrings.GroupMembershipService_DISTRIBUTEDSYSTEM_IS_SHUTTING_DOWN.toLocalizedString(), services.getShutdownCause());
+    }
+
+    if (services.getConfig().getDistributionConfig().getDisableTcp()) {
+      return new Stub(m.getInetAddress(), m.getPort(), m.getVmViewId());
+    }
+    
+    // Return existing one if it is already in place
+    Stub result;
+    result = (Stub)memberToStubMap.get(m);
+    if (result != null)
+      return result;
+
+    latestViewLock.writeLock().lock();
+    try {
+      // Do all of this work in a critical region to prevent
+      // members from slipping in during shutdown
+      if (shutdownInProgress())
+        return null; // don't try to create a stub during shutdown
+      if (isShunned(m))
+        return null; // don't let zombies come back to life
+      
+      // OK, create one.  Update the table to reflect the creation.
+      result = directChannel.createConduitStub(m);
+      addChannel(m, result);
+    } finally {
+      latestViewLock.writeLock().unlock();
+    }
+   return result;
+  }
+
+  public InternalDistributedMember getMemberForStub(Stub s, boolean validated)
+  {
+    latestViewLock.writeLock().lock();
+    try {
+      if (shutdownInProgress) {
+        throw new DistributedSystemDisconnectedException(LocalizedStrings.GroupMembershipService_DISTRIBUTEDSYSTEM_IS_SHUTTING_DOWN.toLocalizedString(), services.getShutdownCause());
+      }
+      InternalDistributedMember result = (InternalDistributedMember)
+          stubToMemberMap.get(s);
+      if (result != null) {
+        if (validated && !this.latestView.contains(result)) {
+          // Do not return this member unless it is in the current view.
+          if (!surpriseMembers.containsKey(result)) {
+            // if not a surprise member, this stub is lingering and should be removed
+            stubToMemberMap.remove(s);
+            memberToStubMap.remove(result);
+          }
+          result = null;
+          // fall through to see if there is a newer member using the same direct port
+        }
+      }
+      if (result == null) {
+        // it may have not been added to the stub->idm map yet, so check the current view
+        for (InternalDistributedMember idm: latestView.getMembers()) {
+          if (GMSUtil.compareAddresses(idm.getInetAddress(), s.getInetAddress()) == 0
+              && idm.getDirectChannelPort() == s.getPort()) {
+            addChannel(idm, s);
+            return idm;
+          }
+        }
+      }
+      return result;
+    } finally {
+      latestViewLock.writeLock().unlock();
+    }
+  }
+
+  /**
+   * Add a mapping from the given member to the given stub. Must
+   * be called with {@link #latestViewLock} held.
+   * 
+   * @param member
+   * @param theChannel
+   */
+  protected void addChannel(InternalDistributedMember member, Stub theChannel)
+  {
+    if (theChannel != null) {
+      // Don't overwrite existing stub information with a null
+      this.memberToStubMap.put(member, theChannel);
+
+      // Can't create reverse mapping if the stub is null
+      this.stubToMemberMap.put(theChannel, member);
+    }
+  }
+
+    // Clean up the maps
+    Stub theChannel = (Stub)memberToStubMap.remove(member);
+    if (theChannel != null) {
+      this.stubToMemberMap.remove(theChannel);
+    }
+    
-  public Map getChannelStates(DistributedMember member, boolean includeMulticast) {
+  public Map getMessageState(DistributedMember member, boolean includeMulticast) {
+    Stub stub = (Stub)memberToStubMap.get(member);
-    if (dc != null) {
-      dc.getChannelStates(member, result);
+    if (stub != null && dc != null) {
+      dc.getChannelStates(stub, result);
-    if (dc != null) {
-      dc.waitForChannelState(otherMember, channelState);
+    Stub stub;
+    latestViewLock.writeLock().lock();
+    try {
+      stub = (Stub)memberToStubMap.get(otherMember);
+    } finally {
+      latestViewLock.writeLock().unlock();
+    }
+    if (dc != null && stub != null) {
+      dc.waitForChannelState(stub, state);
+    Stub stub = new Stub(idm.getInetAddress(), idm.getPort(), idm.getVmViewId());
-        if (dc.hasReceiversFor(idm)) {
+        if (dc.hasReceiversFor(stub)) {

INS26 INS40 INS23 INS23 INS31 INS31 INS31 INS23 INS29 INS83 INS83 INS74 INS59 INS29 INS83 INS83 INS74 INS59 INS44 INS44 INS29 INS83 INS43 INS42 INS44 INS8 INS83 MOV43 INS42 INS44 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS8 UPD42 INS43 INS59 INS44 INS65 INS43 INS43 INS43 INS42 INS14 INS65 INS43 INS43 INS43 INS42 INS14 INS65 INS60 INS65 INS43 INS42 INS60 INS65 INS43 INS42 UPD43 INS65 INS42 INS43 INS42 INS25 INS25 INS60 INS21 INS25 INS21 INS54 INS41 INS43 INS42 INS39 INS42 INS21 INS54 INS65 INS65 INS65 INS43 INS42 INS43 INS42 INS25 INS60 INS25 INS60 INS60 INS21 INS54 INS60 INS42 INS42 INS65 INS83 INS43 INS42 INS21 INS66 INS66 INS66 INS65 INS66 INS42 INS42 INS42 INS74 INS66 INS66 INS66 INS65 INS66 INS42 INS42 INS42 INS74 INS42 INS66 INS43 INS59 INS42 INS66 INS42 INS43 INS59 INS42 INS42 UPD42 INS66 INS42 INS42 INS8 INS32 INS8 INS43 INS59 INS7 INS27 INS41 INS32 INS8 INS8 INS42 INS42 INS32 INS8 INS8 INS66 INS66 INS65 INS66 INS42 INS42 INS42 INS42 INS27 INS8 INS43 INS59 INS27 INS8 INS43 INS59 INS27 INS43 INS59 INS32 INS8 INS8 INS27 INS43 INS59 INS42 INS66 INS42 INS7 INS67 INS43 INS43 INS43 INS67 INS43 INS43 INS43 INS60 INS21 INS21 INS42 INS42 INS14 INS42 INS42 INS42 INS33 INS42 INS53 INS32 INS42 INS41 INS42 INS42 INS42 INS11 INS42 INS33 INS42 INS32 INS42 INS25 INS25 INS21 INS21 INS21 INS32 INS42 INS25 INS60 INS25 INS25 INS41 INS21 INS67 INS42 INS33 INS21 INS21 INS42 INS42 INS11 INS42 INS33 INS21 INS42 INS42 INS11 INS27 MOV27 INS42 INS42 INS32 INS42 INS21 INS21 MOV27 INS27 INS42 INS42 INS14 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS59 INS32 INS32 INS43 INS32 INS32 INS32 INS14 INS32 INS42 INS14 INS43 INS32 INS42 INS42 INS32 INS41 INS32 INS41 INS7 INS32 INS32 INS42 INS42 INS42 INS8 INS43 INS59 INS27 INS8 INS27 INS8 INS42 INS32 INS42 INS32 INS32 INS43 INS32 INS32 INS43 INS32 INS42 INS33 INS42 INS42 INS7 INS32 INS42 INS33 INS43 INS32 INS32 INS32 INS52 INS42 INS60 INS25 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS25 INS21 INS21 INS32 INS43 INS32 INS32 INS42 INS42 INS43 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS53 INS42 INS42 INS11 INS42 INS33 INS25 INS42 INS33 INS70 INS32 INS42 INS22 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS11 INS32 INS42 UPD42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD45 INS42 INS43 INS59 INS27 INS8 INS42 INS42 INS43 INS59 INS27 INS8 INS7 INS32 INS42 INS42 INS43 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS43 INS32 INS27 INS8 INS44 MOV32 INS8 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS43 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS16 INS42 INS42 INS42 INS40 UPD42 MOV42 INS32 INS43 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS38 INS25 INS21 INS43 INS42 INS25 INS42 INS42 INS42 INS42 UPD42 INS22 INS42 INS42 INS32 INS42 INS22 INS42 INS42 INS32 INS27 INS32 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 INS32 INS38 INS8 INS7 INS42 INS27 INS8 INS52 INS42 INS22 INS42 INS42 INS52 INS42 INS22 INS42 INS42 INS42 INS33 INS42 INS42 INS22 INS42 INS42 INS32 INS21 INS21 INS42 INS33 INS27 INS27 INS21 INS41 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS32 INS32 INS32 INS34 INS32 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL42 DEL43 DEL74
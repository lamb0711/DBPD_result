GEODE-6580: Cleanup static analyzer warnings. (#3432)


+
-  protected final long prefillRetry; // ms
+  private final long prefillRetry; // ms
-  protected final long idleTimeoutNanos;
-  final int lifetimeTimeout;
-  final long lifetimeTimeoutNanos;
+  private final long idleTimeoutNanos;
+  private final int lifetimeTimeout;
+  private final long lifetimeTimeoutNanos;
-  protected ScheduledExecutorService backgroundProcessor;
-  protected ScheduledExecutorService loadConditioningProcessor;
+  private ScheduledExecutorService backgroundProcessor;
+  private ScheduledExecutorService loadConditioningProcessor;
-  protected boolean haveIdleExpireConnectionsTask;
-  protected final AtomicBoolean havePrefillTask = new AtomicBoolean(false);
+  private boolean haveIdleExpireConnectionsTask;
+  private final AtomicBoolean havePrefillTask = new AtomicBoolean(false);
-    this.connectionFactory = factory;
+    connectionFactory = factory;
-    this.connectionAccounting = new ConnectionAccounting(minConnections,
+    connectionAccounting = new ConnectionAccounting(minConnections,
-    this.lifetimeTimeoutNanos = MILLISECONDS.toNanos(this.lifetimeTimeout);
+    lifetimeTimeoutNanos = MILLISECONDS.toNanos(this.lifetimeTimeout);
-    this.idleTimeoutNanos = MILLISECONDS.toNanos(this.idleTimeout);
-    this.securityLogWriter = securityLogger;
-    this.prefillRetry = pingInterval;
+    idleTimeoutNanos = MILLISECONDS.toNanos(this.idleTimeout);
+    securityLogWriter = securityLogger;
+    prefillRetry = pingInterval;
-    this.endpointListener = new EndpointManager.EndpointListenerAdapter() {
+    endpointListener = new EndpointManager.EndpointListenerAdapter() {
-   * Always creates a connection and may cause {@link #connectionCount} to exceed
-   * {@link #maxConnections}.
+   * Always creates a connection and may cause {@link ConnectionAccounting} to exceed maximum.
-   * Always creates a connection and may cause {@link #connectionCount} to exceed
-   * {@link #maxConnections}.
+   * Always creates a connection and may cause {@link ConnectionAccounting} to exceed maximum.
-    if (timeout < System.nanoTime()) {
-      return true;
-    }
+    return timeout < System.nanoTime();
-    return false;
-    this.cancelCriterion.checkCancelInProgress(null);
+    cancelCriterion.checkCancelInProgress(null);
-    return this.poolName;
+    return poolName;
-  protected void invalidateServer(Endpoint endpoint) {
+  private void invalidateServer(Endpoint endpoint) {
-   * Destroys connection if and only if {@link #connectionCount} exceeds {@link #maxConnections}.
+   * Destroys connection if and only if {@link ConnectionAccounting} exceeds maximum.
-          connection.internalClose(durable || this.keepAlive);
+          connection.internalClose(durable || keepAlive);
-    this.loadConditioningProcessor =
+    loadConditioningProcessor =
-      if (this.loadConditioningProcessor != null) {
-        this.loadConditioningProcessor.shutdown();
-        if (!this.loadConditioningProcessor.awaitTermination(PoolImpl.SHUTDOWN_TIMEOUT,
+      if (loadConditioningProcessor != null) {
+        loadConditioningProcessor.shutdown();
+        if (!loadConditioningProcessor.awaitTermination(PoolImpl.SHUTDOWN_TIMEOUT,
-    if (this.loadConditioningProcessor != null) {
-      this.loadConditioningProcessor.shutdown();
+    if (loadConditioningProcessor != null) {
+      loadConditioningProcessor.shutdown();
-  protected void startBackgroundExpiration() {
+  private void startBackgroundExpiration() {
-      synchronized (this.allConnectionsMap) {
+      synchronized (allConnectionsMap) {
-  protected boolean prefill() {
+  private void prefill() {
-          return true;
+          return;
-          return false;
+          return;
-      return false;
-    return true;
-    return this.poolStats;
+    return poolStats;
-   * @return true if someone takes our offer; false if not
-  private boolean offerReplacementConnection(Connection con, ServerLocation currentServer) {
+  private void offerReplacementConnection(Connection con, ServerLocation currentServer) {
-      PooledConnection target = this.allConnectionsMap.findReplacementTarget(currentServer);
+      PooledConnection target = allConnectionsMap.findReplacementTarget(currentServer);
-            this.allConnectionsMap.addReplacedCnx(target, targetEP);
-            return true;
+            allConnectionsMap.addReplacedCnx(target, targetEP);
+            return;
-    return false;
-   * @param idlePossible true if we have more cnxs than minPoolSize
-  private boolean createLifetimeReplacementConnection(ServerLocation currentServer,
-      boolean idlePossible) {
+  private boolean createLifetimeReplacementConnection(ServerLocation currentServer) {
-      Connection con = null;
+      Connection con;
-            String.format("Security exception connecting to server '%s': %s",
-                new Object[] {sl, e}));
+            String.format("Security exception connecting to server '%s': %s", sl, e));
-        logger.warn("Server '{}' refused new connection: {}",
-            new Object[] {sl, srce});
+        logger.warn("Server '{}' refused new connection: {}", sl, srce.getMessage());
-    public synchronized boolean isIdleExpirePossible() {
-      return this.allConnections.size() > connectionAccounting.getMinimum();
+    synchronized boolean isIdleExpirePossible() {
+      return allConnections.size() > connectionAccounting.getMinimum();
-      StringBuffer sb = new StringBuffer();
+      StringBuilder sb = new StringBuilder();
-      for (Iterator it = this.allConnections.iterator(); it.hasNext();) {
+      for (Iterator it = allConnections.iterator(); it.hasNext();) {
-    public synchronized void addConnection(PooledConnection connection) {
-      if (this.closing) {
+    synchronized void addConnection(PooledConnection connection) {
+      if (closing) {
-      this.allConnections.add(connection);
+      allConnections.add(connection);
-        } else {
-          // either no possible lifetime expires or we scheduled one
-    public synchronized void addReplacedCnx(PooledConnection con, Endpoint oldEndpoint) {
-      if (this.closing) {
+    synchronized void addReplacedCnx(PooledConnection con, Endpoint oldEndpoint) {
+      if (closing) {
-      if (this.allConnections.remove(con)) {
+      if (allConnections.remove(con)) {
-        this.allConnections.add(con);
+        allConnections.add(con);
-    public synchronized Set<PooledConnection> removeEndpoint(Endpoint endpoint) {
-      final Set<PooledConnection> endpointConnections = this.map.remove(endpoint);
+    synchronized Set<PooledConnection> removeEndpoint(Endpoint endpoint) {
+      final Set<PooledConnection> endpointConnections = map.remove(endpoint);
-        for (Iterator<PooledConnection> it = this.allConnections.iterator(); it.hasNext();) {
+        for (Iterator<PooledConnection> it = allConnections.iterator(); it.hasNext();) {
-    public synchronized boolean removeConnection(PooledConnection connection) {
-      boolean result = this.allConnections.remove(connection);
+    synchronized boolean removeConnection(PooledConnection connection) {
+      boolean result = allConnections.remove(connection);
-      Set<PooledConnection> endpointConnections = map.get(connection.getEndpoint());
-      if (endpointConnections == null) {
-        endpointConnections = new HashSet<>();
-        map.put(connection.getEndpoint(), endpointConnections);
-      }
+      Set<PooledConnection> endpointConnections =
+          map.computeIfAbsent(connection.getEndpoint(), k -> new HashSet<>());
-      Set<PooledConnection> endpointConnections = this.map.get(endpoint);
+      Set<PooledConnection> endpointConnections = map.get(endpoint);
-          this.map.remove(endpoint);
+          map.remove(endpoint);
-      while (!this.allConnections.isEmpty()) {
-        PooledConnection pc = (PooledConnection) this.allConnections.remove(0);
+      while (!allConnections.isEmpty()) {
+        PooledConnection pc = allConnections.remove(0);
-    public synchronized PooledConnection findReplacementTarget(ServerLocation currentServer) {
+    synchronized PooledConnection findReplacementTarget(ServerLocation currentServer) {
-    public synchronized boolean hasExpiredCnxToServer(ServerLocation currentServer) {
-      if (!this.allConnections.isEmpty()) {
+    synchronized boolean hasExpiredCnxToServer(ServerLocation currentServer) {
+      if (!allConnections.isEmpty()) {
-            continue;
-    public synchronized boolean checkForReschedule(boolean rescheduleOk) {
-      if (!this.allConnections.isEmpty()) {
+    synchronized boolean checkForReschedule(boolean rescheduleOk) {
+      if (!allConnections.isEmpty()) {
-    public synchronized void extendLifeOfCnxToServer(ServerLocation sl) {
-      if (!this.allConnections.isEmpty()) {
+    synchronized void extendLifeOfCnxToServer(ServerLocation sl) {
+      if (!allConnections.isEmpty()) {
-        for (Iterator<PooledConnection> it = this.allConnections.iterator(); it.hasNext();) {
+        for (Iterator<PooledConnection> it = allConnections.iterator(); it.hasNext();) {
-            this.allConnections.add(pc);
+            allConnections.add(pc);
-    public synchronized void startBackgroundLifetimeExpiration(long delay) {
-      if (!this.haveLifetimeExpireConnectionsTask) {
-        this.haveLifetimeExpireConnectionsTask = true;
+    synchronized void startBackgroundLifetimeExpiration(long delay) {
+      if (!haveLifetimeExpireConnectionsTask) {
+        haveLifetimeExpireConnectionsTask = true;
-    public void expireIdleConnections() {
+    void expireIdleConnections() {
-      List<PooledConnection> toClose = null;
+      List<PooledConnection> toClose;
-    public void checkLifetimes() {
+    void checkLifetimes() {
-        this.haveLifetimeExpireConnectionsTask = false;
+        haveLifetimeExpireConnectionsTask = false;
-        boolean idlePossible = true;
+        boolean idlePossible;
-          for (Iterator<PooledConnection> it = this.allConnections.iterator(); it.hasNext()
+          for (Iterator<PooledConnection> it = allConnections.iterator(); it.hasNext()
-              boolean idleTimedOut =
-                  idlePossible ? pc.hasIdleExpired(now, idleTimeoutNanos) : false;
+              boolean idleTimedOut = idlePossible && pc.hasIdleExpired(now, idleTimeoutNanos);
-            } else if (firstLife == -1) {
+            } else {
-          done = !createLifetimeReplacementConnection(candidate, idlePossible);
+          done = !createLifetimeReplacementConnection(candidate);
-  private static class ClosedPoolConnectionList extends ArrayList {
+  private static class ClosedPoolConnectionList extends ArrayList<PooledConnection> {
-    public Object set(int index, Object element) {
+    public PooledConnection set(int index, PooledConnection element) {
-    public boolean add(Object element) {
+    public boolean add(PooledConnection element) {
-    public void add(int index, Object element) {
+    public void add(int index, PooledConnection element) {
-    public Object remove(int index) {
+    public PooledConnection remove(int index) {

UPD83 UPD83 INS83 INS83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD39 UPD39 INS74 MOV41 MOV43 INS43 MOV78 UPD43 MOV44 MOV8 MOV78 MOV8 MOV78 MOV8 MOV78 UPD43 MOV44 MOV8 UPD66 UPD66 MOV27 INS42 UPD66 INS42 INS25 MOV25 INS42 UPD42 MOV43 UPD43 UPD43 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD43 INS42 MOV8 INS42 MOV74 MOV74 UPD42 UPD42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 UPD43 INS42 INS42 UPD42 INS86 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS59 MOV14 INS32 INS42 INS42 INS42 INS42 INS42 MOV42 MOV34 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV8 INS42 INS42 INS42 INS42 INS27 INS42 MOV32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL67 DEL42 DEL67 DEL65 DEL66 DEL42 DEL67 DEL42 DEL67 DEL65 DEL66 DEL9 DEL8 DEL25 DEL9 DEL41 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL67 DEL42 DEL67 DEL65 DEL66 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL9 DEL9 DEL9 DEL41 DEL9 DEL41 DEL52 DEL42 DEL22 DEL66 DEL65 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL9 DEL9 DEL41 DEL42 DEL66 DEL65 DEL39 DEL42 DEL44 DEL33 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL8 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL25 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL42 DEL33 DEL27 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL32 DEL11 DEL83 DEL83 DEL52 DEL42 DEL22 DEL18 DEL83 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL33 DEL83 DEL52 DEL42 DEL22 DEL9 DEL52 DEL42 DEL22 DEL42 DEL9 DEL16 DEL42 DEL34 DEL38 DEL27 DEL25 DEL42 DEL42 DEL43
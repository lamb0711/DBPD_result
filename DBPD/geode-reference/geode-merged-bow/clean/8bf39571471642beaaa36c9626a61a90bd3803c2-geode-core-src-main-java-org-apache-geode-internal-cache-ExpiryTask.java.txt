Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-  
+
-  
+
-    int nThreads = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "EXPIRY_THREADS", 0).intValue();
+    int nThreads =
+        Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "EXPIRY_THREADS", 0).intValue();
-          private int nextId = 0;
+        private int nextId = 0;
-          public Thread newThread(final Runnable command) {
-            String name = "Expiration threads";
-            final ThreadGroup group =
-              LoggingThreadGroup.createThreadGroup(name);
-            final Runnable r = new Runnable() {
-                public void run() {
-                  ConnectionTable.threadWantsSharedResources();
-                  try {
-                    command.run();
-                  } finally {
-                    ConnectionTable.releaseThreadsSockets();
-                  }
-                }
-              };
-            Thread thread = new Thread(group, r, "Expiry " + nextId++);
-            thread.setDaemon(true);
-            return thread;
-          }
-        };
-      //LinkedBlockingQueue q = new LinkedBlockingQueue();
+        public Thread newThread(final Runnable command) {
+          String name = "Expiration threads";
+          final ThreadGroup group = LoggingThreadGroup.createThreadGroup(name);
+          final Runnable r = new Runnable() {
+            public void run() {
+              ConnectionTable.threadWantsSharedResources();
+              try {
+                command.run();
+              } finally {
+                ConnectionTable.releaseThreadsSockets();
+              }
+            }
+          };
+          Thread thread = new Thread(group, r, "Expiry " + nextId++);
+          thread.setDaemon(true);
+          return thread;
+        }
+      };
+      // LinkedBlockingQueue q = new LinkedBlockingQueue();
+
-  
+
-   * @return the absolute time (ms since Jan 1, 1970) at which this
-   * region expires, due to either time-to-live or idle-timeout (whichever
-   * will occur first), or 0 if neither are used.
+   * @return the absolute time (ms since Jan 1, 1970) at which this region expires, due to either
+   *         time-to-live or idle-timeout (whichever will occur first), or 0 if neither are used.
-      if (getLocalRegion()!=null && !getLocalRegion().EXPIRY_UNITS_MS) {
+      if (getLocalRegion() != null && !getLocalRegion().EXPIRY_UNITS_MS) {
-      if (getLocalRegion()!=null && !getLocalRegion().EXPIRY_UNITS_MS) {
+      if (getLocalRegion() != null && !getLocalRegion().EXPIRY_UNITS_MS) {
-  /** Returns the number of milliseconds until this task should expire.
-      The return value will never be negative. */
+  /**
+   * Returns the number of milliseconds until this task should expire. The return value will never
+   * be negative.
+   */
-   * Return true if current task could have expired.
-   * Return false if expiration is impossible.
+   * Return true if current task could have expired. Return false if expiration is impossible.
-  
-  /** 
-   * Returns false if the region reliability state does not allow this expiry 
-   * task to fire.
+
+  /**
+   * Returns false if the region reliability state does not allow this expiry task to fire.
-  
+
-      logger.debug("{}.performTimeout(): getExpirationTime() returns {}", this.toString(), getExpirationTime());
+      logger.debug("{}.performTimeout(): getExpirationTime() returns {}", this.toString(),
+          getExpirationTime());
+
-   * Test method that causes expiration to be suspended until
-   * permitExpiration is called.
+   * Test method that causes expiration to be suspended until permitExpiration is called.
+   * 
+
+
-   * Wait until permission is given for expiration to be done.
-   * Tests are allowed to suspend expiration.
+   * Wait until permission is given for expiration to be done. Tests are allowed to suspend
+   * expiration.
+   * 
-      for (;;) {
-        getLocalRegion().getCancelCriterion().checkCancelInProgress(null);
-        synchronized (suspendLock) {
-          boolean interrupted = Thread.interrupted();
-          try {
-            while (expirationSuspended) {
-              suspendLock.wait();
-            }
-            break;
-          } catch (InterruptedException ex) {
-            interrupted = true;
-            getLocalRegion().getCancelCriterion().checkCancelInProgress(null);
-            // keep going, we can't cancel
+    for (;;) {
+      getLocalRegion().getCancelCriterion().checkCancelInProgress(null);
+      synchronized (suspendLock) {
+        boolean interrupted = Thread.interrupted();
+        try {
+          while (expirationSuspended) {
+            suspendLock.wait();
-          finally {
-            if (interrupted) {
-              Thread.currentThread().interrupt();
-            }
+          break;
+        } catch (InterruptedException ex) {
+          interrupted = true;
+          getLocalRegion().getCancelCriterion().checkCancelInProgress(null);
+          // keep going, we can't cancel
+        } finally {
+          if (interrupted) {
+            Thread.currentThread().interrupt();
-        } // synchronized
-      } // for
+        }
+      } // synchronized
+    } // for
-  
-  protected final boolean expire(boolean isPending) throws CacheException 
-  {
+
+  protected final boolean expire(boolean isPending) throws CacheException {
-    if (action == null) return false;
+    if (action == null)
+      return false;
-  
-  /** Why did this expire?
-    * @return the action to perform or null if NONE */
+
+  /**
+   * Why did this expire?
+   * 
+   * @return the action to perform or null if NONE
+   */
-      if (idle == 0) return null;
+      if (idle == 0)
+        return null;
-  
+
-    if (action.isInvalidate())      return invalidate();
-    if (action.isDestroy())         return destroy(isPending);
-    if (action.isLocalInvalidate()) return localInvalidate();
-    if (action.isLocalDestroy())    return localDestroy();
-    throw new InternalGemFireError(LocalizedStrings.ExpiryTask_UNRECOGNIZED_EXPIRATION_ACTION_0.toLocalizedString(action));
+    if (action.isInvalidate())
+      return invalidate();
+    if (action.isDestroy())
+      return destroy(isPending);
+    if (action.isLocalInvalidate())
+      return localInvalidate();
+    if (action.isLocalDestroy())
+      return localDestroy();
+    throw new InternalGemFireError(
+        LocalizedStrings.ExpiryTask_UNRECOGNIZED_EXPIRATION_ACTION_0.toLocalizedString(action));
-  /** 
+  /**
-  
-  /** 
-   * An ExpiryTask is sent run() to perform its task.  Note that
-   * this run() method should never throw an exception - otherwise,
-   * it takes out the java.util.Timer thread, causing an exception
+
+  /**
+   * An ExpiryTask is sent run() to perform its task. Note that this run() method should never throw
+   * an exception - otherwise, it takes out the java.util.Timer thread, causing an exception
-            public void run() {
-              runInThreadPool();
-            }
-          });
+          public void run() {
+            runInThreadPool();
+          }
+        });
-      } 
-      catch (VirtualMachineError err) {
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-    }
-    catch (CancelException e) {
+    } catch (CancelException e) {
-    }
-    catch (VirtualMachineError err) {
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Throwable ex) {
+    } catch (Throwable ex) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.ExpiryTask_EXCEPTION_IN_EXPIRATION_TASK), ex);
+      logger.fatal(
+          LocalizedMessage.create(LocalizedStrings.ExpiryTask_EXCEPTION_IN_EXPIRATION_TASK), ex);
-      if (isCacheClosing() || 
-          getLocalRegion().isClosed() || 
-          getLocalRegion().isDestroyed()) {
+      if (isCacheClosing() || getLocalRegion().isClosed() || getLocalRegion().isDestroyed()) {
-    } 
-    catch (CancelException ex) {
+    } catch (CancelException ex) {
-    } 
-     catch (VirtualMachineError err) {
-       SystemFailure.initiateFailure(err);
-       // If this ever returns, rethrow the error.  We're poisoned
-       // now, so don't let this thread continue.
-       throw err;
-     }
-     catch (Throwable ex) {
-       // Whenever you catch Error or Throwable, you must also
-       // catch VirtualMachineError (see above).  However, there is
-       // _still_ a possibility that you are dealing with a cascading
-       // error condition, so you also need to check to see if the JVM
-       // is still usable:
-       SystemFailure.checkFailure();
-       logger.fatal(LocalizedMessage.create(LocalizedStrings.ExpiryTask_EXCEPTION_IN_EXPIRATION_TASK), ex);
+    } catch (VirtualMachineError err) {
+      SystemFailure.initiateFailure(err);
+      // If this ever returns, rethrow the error. We're poisoned
+      // now, so don't let this thread continue.
+      throw err;
+    } catch (Throwable ex) {
+      // Whenever you catch Error or Throwable, you must also
+      // catch VirtualMachineError (see above). However, there is
+      // _still_ a possibility that you are dealing with a cascading
+      // error condition, so you also need to check to see if the JVM
+      // is still usable:
+      SystemFailure.checkFailure();
+      logger.fatal(
+          LocalizedMessage.create(LocalizedStrings.ExpiryTask_EXCEPTION_IN_EXPIRATION_TASK), ex);
-   *  Reschedule (or not) this task for later consideration
+   * Reschedule (or not) this task for later consideration
-    } 
-    catch (VirtualMachineError err) {
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Throwable t) {
+    } catch (Throwable t) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-    return super.toString() + " for " + getLocalRegion()
-      + ", ttl expiration time: " + expTtl
-      + ", idle expiration time: " + expIdle +
-      ("[now:" + calculateNow() + "]");
+    return super.toString() + " for " + getLocalRegion() + ", ttl expiration time: " + expTtl
+        + ", idle expiration time: " + expIdle + ("[now:" + calculateNow() + "]");
-  
+
-  
+
-   * To reduce the number of times we need to call System.currentTimeMillis you
-   * can call this method to set a thread local. Make sure and call
-   * {@link #clearNow()} in a finally block after calling this method.
+   * To reduce the number of times we need to call System.currentTimeMillis you can call this method
+   * to set a thread local. Make sure and call {@link #clearNow()} in a finally block after calling
+   * this method.
-  
+
-   * Call this method after a thread has called {@link #setNow()} once you are
-   * done calling code that may call {@link #getNow()}.
+   * Call this method after a thread has called {@link #setNow()} once you are done calling code
+   * that may call {@link #getNow()}.
-   * Returns the current time in milliseconds. If the current thread has called
-   * {@link #setNow()} then that time is return.
+   * Returns the current time in milliseconds. If the current thread has called {@link #setNow()}
+   * then that time is return.
-  
+
-   * Used by tests to determine if events related
-   * to an ExpiryTask have happened.
+   * Used by tests to determine if events related to an ExpiryTask have happened.
-     * Called after entry is schedule for expiration. 
+     * Called after entry is schedule for expiration.
+
-     * Called after the given expiry task has run.
-     * This means that the time it was originally
-     * scheduled to run has elapsed and the scheduler
-     * has run the task. While running the task it
+     * Called after the given expiry task has run. This means that the time it was originally
+     * scheduled to run has elapsed and the scheduler has run the task. While running the task it
+
-     * Called after the given expiry task has been
-     * rescheduled. afterTaskRan can still be called
-     * on the same task.
-     * In some cases a task is rescheduled without expiring it.
-     * In others it is expired and rescheduled.
+     * Called after the given expiry task has been rescheduled. afterTaskRan can still be called on
+     * the same task. In some cases a task is rescheduled without expiring it. In others it is
+     * expired and rescheduled.
+
-    
+
-    
+

MOV44 MOV44 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
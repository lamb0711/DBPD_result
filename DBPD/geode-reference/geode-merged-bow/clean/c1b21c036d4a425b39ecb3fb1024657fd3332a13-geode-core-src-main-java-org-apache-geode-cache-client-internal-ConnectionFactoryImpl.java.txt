GEODE-4439 Refactor HandShake.java

Created ServerSideHandshake and ServerSideHandshakeImpl for servers.

Created ClientSideHandshake and ClientSideHandshakeImpl for clients.

Message encryption/decryption is now in an Encryptor interface.

HandShake is renamed Handshake.

+import org.apache.geode.internal.cache.tier.ClientSideHandshake;
-import org.apache.geode.internal.cache.tier.sockets.HandShake;
-  private final HandShake handshake;
+  private final ClientSideHandshakeImpl handshake;
-  private final int handShakeTimeout;
+  private final int handshakeTimeout;
-      InternalDistributedSystem sys, int socketBufferSize, int handShakeTimeout, int readTimeout,
+      InternalDistributedSystem sys, int socketBufferSize, int handshakeTimeout, int readTimeout,
-    this.handshake = new HandShake(proxyId, sys, sys.getSecurityService());
+    this.handshake =
+        new ClientSideHandshakeImpl(proxyId, sys, sys.getSecurityService(), multiuserSecureMode);
-    this.handShakeTimeout = handShakeTimeout;
-    this.handshake.setMultiuserSecureMode(multiuserSecureMode);
+    this.handshakeTimeout = handshakeTimeout;
-      HandShake connHandShake = new HandShake(handshake);
+      ClientSideHandshake connHandShake = new ClientSideHandshakeImpl(handshake);
-          handShakeTimeout, readTimeout, getCommMode(forQueue), this.gatewaySender,
+          handshakeTimeout, readTimeout, getCommMode(forQueue), this.gatewaySender,
-      connection.setHandShake(connHandShake);
+      connection.setHandshake(connHandShake);
-    // if(conn == null) {
-    // logger.fine("Unable to create a connection in the allowed time.");
-    //
-    // if(fatalException!=null) {
-    // throw fatalException;
-    // }
-    // }
-        isPrimary, ds, new HandShake(this.handshake), qManager, endpointManager, endpoint,
-        handShakeTimeout, this.socketCreator);
+        isPrimary, ds, new ClientSideHandshakeImpl(this.handshake), qManager, endpointManager,
+        endpoint, handshakeTimeout, this.socketCreator);
-    // Wait for the client update thread to be ready
-    // if (!updater.waitForInitialization()) {
-    // Yogesh : This doesn't wait for notify if the updater
-    // thread exits from the run in case of Exception in CCU thread
-    // Yogesh : fix for 36690
-    // because when CCU thread gets a ConnectException, it comes out of run method
-    // and when a thread is no more running it notifies all the waiting threads on the thread
-    // object.
-    // so above wait will come out irrelevant of notify from CCU thread, when CCU thread has got an
-    // exception
-    // To avoid this problem we check isAlive before returning from this method.
-    // if (logger != null && logger.infoEnabled()) {
-    // logger.info(LocalizedStrings.AutoConnectionSourceImpl_0_NOT_STARTED_1, new Object[] {this,
-    // clientUpdateName});
-    // }
-    // return null;
-    // }else {
-    // if (logger != null && logger.infoEnabled()) {
-    // logger.info(LocalizedStrings.AutoConnectionSourceImpl_0_STARTED_1, new Object[] {this,
-    // clientUpdateName});
-    // }
-    // }

MOV26 UPD40 UPD43 UPD42 UPD42 UPD42 UPD42 UPD43 INS42 UPD42 UPD43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD43 UPD43 UPD42 UPD42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL21
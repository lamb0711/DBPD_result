Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A Set constrained to contain Structs of all the same type. To conserve on
- * objects, we store the StructType once and reuse it to generate Struct
- * instances on demand.
+ * A Set constrained to contain Structs of all the same type. To conserve on objects, we store the
+ * StructType once and reuse it to generate Struct instances on demand.
- * The values in this set are stored as Object[] and get wrapped in Structs as
- * necessary.
+ * The values in this set are stored as Object[] and get wrapped in Structs as necessary.
-public final class StructSet /*extends ObjectOpenCustomHashSet*/ implements Set, SelectResults, 
-DataSerializableFixedID, StructFields {
+public final class StructSet /* extends ObjectOpenCustomHashSet */ implements Set, SelectResults,
+    DataSerializableFixedID, StructFields {
-  
+
-  public StructSet() {  
-  }
+  public StructSet() {}
-        if (obj != null) h += obj.hashCode();
+        if (obj != null)
+          h += obj.hashCode();
-    	if (o1 == null) return o2 == null;
-        if (!(o1 instanceof Object[]) || !(o2 instanceof Object[])) {
-          return o1.equals(o2);
-        } 
+      if (o1 == null)
+        return o2 == null;
+      if (!(o1 instanceof Object[]) || !(o2 instanceof Object[])) {
+        return o1.equals(o2);
+      }
-    if (structType == null) { throw new IllegalArgumentException(LocalizedStrings.StructSet_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString()); }
+    if (structType == null) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructSet_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString());
+    }
-    if (structType == null) { throw new IllegalArgumentException(LocalizedStrings.StructSet_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString()); }
+    if (structType == null) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructSet_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString());
+    }
-  /** Creates a StructSet directly from a StructBag;
-   *  (internal use) 
-   *  @since GemFire 5.1
+  /**
+   * Creates a StructSet directly from a StructBag; (internal use)
+   * 
+   * @since GemFire 5.1
-    this.structType = (StructType)bag.elementType;
+    this.structType = (StructType) bag.elementType;
-        addFieldValues((Object[])itr.next());
+        addFieldValues((Object[]) itr.next());
-    }
-    else {
+    } else {
-        addFieldValues((Object[])key);
+        addFieldValues((Object[]) key);
-    
+
-    if (structType == null) { throw new IllegalArgumentException(LocalizedStrings.StructSet_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString()); }
+    if (structType == null) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructSet_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString());
+    }
-    this.contents = new ObjectOpenCustomHashSet(initialCapacity, loadFactor, new ObjectArrayHashingStrategy());
-    if (structType == null) { throw new IllegalArgumentException(LocalizedStrings.StructSet_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString()); }
+    this.contents =
+        new ObjectOpenCustomHashSet(initialCapacity, loadFactor, new ObjectArrayHashingStrategy());
+    if (structType == null) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructSet_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString());
+    }
-    if (!this.structType.equals(((StructSet)other).structType)) {
+    if (!this.structType.equals(((StructSet) other).structType)) {
-      return this.contents.equals(((StructSet)other).contents);
+      return this.contents.equals(((StructSet) other).contents);
-  
+
-  
-  
+
+
-    if (!(obj instanceof StructImpl)) { throw new IllegalArgumentException(LocalizedStrings.StructSet_THIS_SET_ONLY_ACCEPTS_STRUCTIMPL.toLocalizedString()); }
+    if (!(obj instanceof StructImpl)) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructSet_THIS_SET_ONLY_ACCEPTS_STRUCTIMPL.toLocalizedString());
+    }
-      throw new IllegalArgumentException(LocalizedStrings.StructSet_OBJ_DOES_NOT_HAVE_THE_SAME_STRUCTTYPE_REQUIRED_0_ACTUAL_1.toLocalizedString(new Object[] {this.structType, s.getStructType()}));
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructSet_OBJ_DOES_NOT_HAVE_THE_SAME_STRUCTTYPE_REQUIRED_0_ACTUAL_1
+              .toLocalizedString(new Object[] {this.structType, s.getStructType()}));
-    if (!(obj instanceof Struct)) { return false; }
+    if (!(obj instanceof Struct)) {
+      return false;
+    }
-    if (!this.structType.equals(StructTypeImpl.typeFromStruct(s))) { return false; }
+    if (!this.structType.equals(StructTypeImpl.typeFromStruct(s))) {
+      return false;
+    }
-   * Does this set contain a Struct of the correct type with the specified
-   * values?
+   * Does this set contain a Struct of the correct type with the specified values?
-    if (!(o instanceof Struct)) { return false; }
+    if (!(o instanceof Struct)) {
+      return false;
+    }
-    if (!this.structType.equals(StructTypeImpl.typeFromStruct(s))) { return false; }
+    if (!this.structType.equals(StructTypeImpl.typeFromStruct(s))) {
+      return false;
+    }
-    if (c instanceof StructSet) { return addAll((StructSet) c); }
-    return this.contents.addAll(c);
+    if (c instanceof StructSet) {
+      return addAll((StructSet) c);
+    } else {
+      boolean modified = false;
+      for (Object o : c) {
+        modified |= add(o);
+      }
+      return modified;
+    }
-    if (c instanceof StructSet) { return removeAll((StructSet) c); }
-    return this.contents.removeAll(c);
+    if (c instanceof StructSet) {
+      return removeAll((StructSet) c);
+    } else {
+      boolean modified = false;
+      for (Object o : c) {
+        modified |= remove(o);
+      }
+      return modified;
+    }
-    if (c instanceof StructSet) { return retainAll((StructSet) c); }
+    if (c instanceof StructSet) {
+      return retainAll((StructSet) c);
+    }
-    if (!this.structType.equals(ss.structType)) { throw new IllegalArgumentException(LocalizedStrings.StructSet_TYPES_DONT_MATCH.toLocalizedString()); }
+    if (!this.structType.equals(ss.structType)) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructSet_TYPES_DONT_MATCH.toLocalizedString());
+    }
-    if (!this.structType.equals(ss.structType)) { return false; // nothing
-                                                                // modified
+    if (!this.structType.equals(ss.structType)) {
+      return false; // nothing
+                    // modified
-      }
-      else {
+      } else {
-    if (!(elementType instanceof StructTypeImpl)) { throw new IllegalArgumentException(LocalizedStrings.StructSet_ELEMENT_TYPE_MUST_BE_STRUCT.toLocalizedString()); }
+    if (!(elementType instanceof StructTypeImpl)) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructSet_ELEMENT_TYPE_MUST_BE_STRUCT.toLocalizedString());
+    }
-  
+
-      if (hasNext) buf.append(", ");
+      if (hasNext)
+        buf.append(", ");
-      return new StructImpl((StructTypeImpl)StructSet.this.structType, (Object[]) this.itr.next());
+      return new StructImpl((StructTypeImpl) StructSet.this.structType, (Object[]) this.itr.next());
-  
+
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException
-  {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    this.structType = (StructTypeImpl)DataSerializer.readObject(in);
+    this.structType = (StructTypeImpl) DataSerializer.readObject(in);
-  public void toData(DataOutput out) throws IOException
-  {    
+  public void toData(DataOutput out) throws IOException {
-    for (Iterator iter = this.iterator(); iter.hasNext();) {      
-      structs[i++]  = (Struct)iter.next();
+    for (Iterator iter = this.iterator(); iter.hasNext();) {
+      structs[i++] = (Struct) iter.next();
-    return structs;    
+    return structs;
-  public Object[] toArray(Object[] a) {    
+  public Object[] toArray(Object[] a) {
-    for(Object o : array) {
-      array[i++] = new StructImpl((StructTypeImpl)this.structType, (Object[])o);
+    for (Object o : array) {
+      array[i++] = new StructImpl((StructTypeImpl) this.structType, (Object[]) o);
-    if(o instanceof Struct) {
-      o = ((Struct)o).getFieldValues();
+    if (o instanceof Struct) {
+      o = ((Struct) o).getFieldValues();
-    //TODO: Asif : This is wrong ,we need to fix this.
+    // TODO: Asif : This is wrong ,we need to fix this.

UPD66 UPD66 UPD66 UPD66 UPD66 INS8 INS8 INS60 INS70 INS41 INS60 INS70 INS41 INS39 INS59 INS44 INS42 INS8 INS42 INS39 INS59 INS44 INS42 INS8 INS42 INS42 INS9 INS43 INS42 INS21 INS42 INS9 INS43 INS42 INS21 INS42 INS7 INS42 INS7 INS42 INS32 INS42 INS32 INS42 INS42 INS42 INS42 DEL66 DEL66 DEL66 DEL66 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL41 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL41
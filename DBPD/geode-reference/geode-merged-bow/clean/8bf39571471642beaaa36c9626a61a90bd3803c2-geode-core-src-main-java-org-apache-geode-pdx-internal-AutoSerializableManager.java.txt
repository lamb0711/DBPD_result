Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * The core of auto serialization which is used in both aspect and
- * reflection-based auto-serialization. This simple manager class is a singleton
- * which tracks the relevant fields for each class which is to be
- * auto-serialized.
- * This class used to be a singleton. But now every instance of ReflectionBasedAutoSerializer
- * will have its own instance of this class. We allow instances of this class to be found
- * so that tests can access internal apis that are not exposed on the public ReflectionBasedAutoSerializer.
+ * The core of auto serialization which is used in both aspect and reflection-based
+ * auto-serialization. This simple manager class is a singleton which tracks the relevant fields for
+ * each class which is to be auto-serialized. This class used to be a singleton. But now every
+ * instance of ReflectionBasedAutoSerializer will have its own instance of this class. We allow
+ * instances of this class to be found so that tests can access internal apis that are not exposed
+ * on the public ReflectionBasedAutoSerializer.
-  
+
-   * This is an internal parameter which, when set either as a system property
-   * or via cache.xml will not evaluate any hardcoded excludes. This helps with
-   * testing as well as possibly debugging future customer issues.
+   * This is an internal parameter which, when set either as a system property or via cache.xml will
+   * not evaluate any hardcoded excludes. This helps with testing as well as possibly debugging
+   * future customer issues.
-  private boolean noHardcodedExcludes =
-      Boolean.getBoolean(NO_HARDCODED_EXCLUDES_PARAM);
+  private boolean noHardcodedExcludes = Boolean.getBoolean(NO_HARDCODED_EXCLUDES_PARAM);
-   * Holds a set of regex patterns which match the list of classes we're
-   * interested in.
+   * Holds a set of regex patterns which match the list of classes we're interested in.
-  private Set<Pattern> hardcodedExclusions = new HashSet<Pattern>() {{
-    add(Pattern.compile("com\\.gemstone\\..*"));
-    add(Pattern.compile("java\\..*"));
-    add(Pattern.compile("javax\\..*"));
-  }};
+  private Set<Pattern> hardcodedExclusions = new HashSet<Pattern>() {
+    {
+      add(Pattern.compile("com\\.gemstone\\..*"));
+      add(Pattern.compile("java\\..*"));
+      add(Pattern.compile("javax\\..*"));
+    }
+  };
-   * Cache of class names which have been determined to be excluded from
-   * serialization. Built up within isRelevant().
+   * Cache of class names which have been determined to be excluded from serialization. Built up
+   * within isRelevant().
-  private final Set<String> cachedExcludedClasses =
-    new CopyOnWriteHashSet<String>();
+  private final Set<String> cachedExcludedClasses = new CopyOnWriteHashSet<String>();
-   * Cache of class names which have been determined to be included for
-   * serialization. Built up within isRelevant().
+   * Cache of class names which have been determined to be included for serialization. Built up
+   * within isRelevant().
-  private final Set<String> cachedIncludedClasses =
-      new CopyOnWriteHashSet<String>();
+  private final Set<String> cachedIncludedClasses = new CopyOnWriteHashSet<String>();
-   * Used to hold the class names which have triggered a warning because
-   * they have been determined that they should be auto serialized 
-   * based on a pattern much but were not because that either do not
-   * have a public no-arg constructor or have explicit java serialization code.
+   * Used to hold the class names which have triggered a warning because they have been determined
+   * that they should be auto serialized based on a pattern much but were not because that either do
+   * not have a public no-arg constructor or have explicit java serialization code.
-  private final Set<String> loggedNoAutoSerializeMsg =
-      new CopyOnWriteHashSet<String>();
+  private final Set<String> loggedNoAutoSerializeMsg = new CopyOnWriteHashSet<String>();
-  
+
-  public static AutoSerializableManager create(ReflectionBasedAutoSerializer owner, boolean checkPortability, String... patterns) {
+  public static AutoSerializableManager create(ReflectionBasedAutoSerializer owner,
+      boolean checkPortability, String... patterns) {
+
+
-  
+
-  
+
-   * Helper method to determine whether the class of a given object is a class
-   * which we are interested in (de)serializing.
+   * Helper method to determine whether the class of a given object is a class which we are
+   * interested in (de)serializing.
-   * @return true if the object should be considered for serialization or false
-   * otherwise
+   * @return true if the object should be considered for serialization or false otherwise
-  public boolean defaultIsClassAutoSerialized(Class <?> clazz) {
+  public boolean defaultIsClassAutoSerialized(Class<?> clazz) {
-    if (! noHardcodedExcludes) {
+    if (!noHardcodedExcludes) {
-        if (hasValidConstructor(clazz, p)
-            && !needsStandardSerialization(clazz, p)) {
+        if (hasValidConstructor(clazz, p) && !needsStandardSerialization(clazz, p)) {
-  
+
-   * Helper method to determine whether a class has a default constructor.
-   * That's needed so that it can be re-instantiated by PDX on de-serialization.
+   * Helper method to determine whether a class has a default constructor. That's needed so that it
+   * can be re-instantiated by PDX on de-serialization.
-      if (! loggedNoAutoSerializeMsg.contains(className)) {
+      if (!loggedNoAutoSerializeMsg.contains(className)) {
-        logger.warn("Class {} matched with '{}' cannot be auto-serialized due to missing public no-arg constructor. Will attempt using Java serialization.",
+        logger.warn(
+            "Class {} matched with '{}' cannot be auto-serialized due to missing public no-arg constructor. Will attempt using Java serialization.",
+
-        if (! loggedNoAutoSerializeMsg.contains(className)) {
+        if (!loggedNoAutoSerializeMsg.contains(className)) {
-          logger.warn("Class {} matched with '{}' cannot be auto-serialized because it is Externalizable. Java serialization will be used instead of auto-serialization.",
+          logger.warn(
+              "Class {} matched with '{}' cannot be auto-serialized because it is Externalizable. Java serialization will be used instead of auto-serialization.",
-        if (getPrivateMethod(clazz, "writeObject", 
-            new Class[] { ObjectOutputStream.class }, Void.TYPE)) {
+        if (getPrivateMethod(clazz, "writeObject", new Class[] {ObjectOutputStream.class},
+            Void.TYPE)) {
-          if (! loggedNoAutoSerializeMsg.contains(className)) {
+          if (!loggedNoAutoSerializeMsg.contains(className)) {
-            logger.warn("Class {} matched with '{}' cannot be auto-serialized because it has a writeObject(ObjectOutputStream) method. Java serialization will be used instead of auto-serialization.",
+            logger.warn(
+                "Class {} matched with '{}' cannot be auto-serialized because it has a writeObject(ObjectOutputStream) method. Java serialization will be used instead of auto-serialization.",
-          if (! loggedNoAutoSerializeMsg.contains(className)) {
+          if (!loggedNoAutoSerializeMsg.contains(className)) {
-            logger.warn("Class {} matched with '{}' cannot be auto-serialized because it has a writeReplace() method. Java serialization will be used instead of auto-serialization.",
+            logger.warn(
+                "Class {} matched with '{}' cannot be auto-serialized because it has a writeReplace() method. Java serialization will be used instead of auto-serialization.",
-  /**
-   * Returns true if a non-static private method with given signature defined by given
-   * class, or false if none found.
-   */
-  private static boolean getPrivateMethod(Class cl, String name, 
-                                         Class[] argTypes,
-                                         Class returnType)
-  {
-      try {
-          Method meth = cl.getDeclaredMethod(name, argTypes);
-          int mods = meth.getModifiers();
-          return ((meth.getReturnType() == returnType) &&
-                  ((mods & Modifier.STATIC) == 0) &&
-                  ((mods & Modifier.PRIVATE) != 0));
-      } catch (NoSuchMethodException ex) {
-          return false;
-      }
-  }
-  /**
-   * Returns true if a non-static, non-abstract method with given signature provided it
-   * is defined by or accessible (via inheritance) by the given class, or
-   * false if no match found.
-   */
-  private static boolean getInheritableMethod(Class cl, String name,
-                                             Class[] argTypes,
-                                             Class returnType)
-  {
-      Method meth = null;
-      Class defCl = cl;
-      while (defCl != null) {
-          try {
-              meth = defCl.getDeclaredMethod(name, argTypes);
-              break;
-          } catch (NoSuchMethodException ex) {
-              defCl = defCl.getSuperclass();
-          }
-      }
-      if ((meth == null) || (meth.getReturnType() != returnType)) {
-          return false;
-      }
-      int mods = meth.getModifiers();
-      if ((mods & (Modifier.STATIC | Modifier.ABSTRACT)) != 0) {
-          return false;
-      } else if ((mods & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0) {
-          return true;
-      } else if ((mods & Modifier.PRIVATE) != 0) {
-          return (cl == defCl);
-      } else {
-          return packageEquals(cl, defCl);
-      }
-  }
-   * Returns true if classes are defined in the same runtime package, false
-   * otherwise.
+   * Returns true if a non-static private method with given signature defined by given class, or
+   * false if none found.
+   */
+  private static boolean getPrivateMethod(Class cl, String name, Class[] argTypes,
+      Class returnType) {
+    try {
+      Method meth = cl.getDeclaredMethod(name, argTypes);
+      int mods = meth.getModifiers();
+      return ((meth.getReturnType() == returnType) && ((mods & Modifier.STATIC) == 0)
+          && ((mods & Modifier.PRIVATE) != 0));
+    } catch (NoSuchMethodException ex) {
+      return false;
+    }
+  }
+
+  /**
+   * Returns true if a non-static, non-abstract method with given signature provided it is defined
+   * by or accessible (via inheritance) by the given class, or false if no match found.
+   */
+  private static boolean getInheritableMethod(Class cl, String name, Class[] argTypes,
+      Class returnType) {
+    Method meth = null;
+    Class defCl = cl;
+    while (defCl != null) {
+      try {
+        meth = defCl.getDeclaredMethod(name, argTypes);
+        break;
+      } catch (NoSuchMethodException ex) {
+        defCl = defCl.getSuperclass();
+      }
+    }
+
+    if ((meth == null) || (meth.getReturnType() != returnType)) {
+      return false;
+    }
+    int mods = meth.getModifiers();
+    if ((mods & (Modifier.STATIC | Modifier.ABSTRACT)) != 0) {
+      return false;
+    } else if ((mods & (Modifier.PUBLIC | Modifier.PROTECTED)) != 0) {
+      return true;
+    } else if ((mods & Modifier.PRIVATE) != 0) {
+      return (cl == defCl);
+    } else {
+      return packageEquals(cl, defCl);
+    }
+  }
+
+  /**
+   * Returns true if classes are defined in the same runtime package, false otherwise.
-      return (cl1.getClassLoader() == cl2.getClassLoader() &&
-              getPackageName(cl1).equals(getPackageName(cl2)));
+    return (cl1.getClassLoader() == cl2.getClassLoader()
+        && getPackageName(cl1).equals(getPackageName(cl2)));
+
-      String s = cl.getName();
-      int i = s.lastIndexOf('[');
-      if (i >= 0) {
-          s = s.substring(i + 2);
-      }
-      i = s.lastIndexOf('.');
-      return (i >= 0) ? s.substring(0, i) : "";
+    String s = cl.getName();
+    int i = s.lastIndexOf('[');
+    if (i >= 0) {
+      s = s.substring(i + 2);
+    }
+    i = s.lastIndexOf('.');
+    return (i >= 0) ? s.substring(0, i) : "";
+
-   * Given a class, figure out which fields we're interested in serializing. The
-   * class' entire hierarchy will be traversed and used. Transients and statics
-   * will be ignored.
+   * Given a class, figure out which fields we're interested in serializing. The class' entire
+   * hierarchy will be traversed and used. Transients and statics will be ignored.
-   * @param clazz
-   *          the <code>Class</code> we're interested in
+   * @param clazz the <code>Class</code> we're interested in
-    
+
+
+
-        if (classInfo != null) return classInfo;
-        
+        if (classInfo != null)
+          return classInfo;
+
-                  getOwner().getFieldName(f, clazz),
-                  getOwner().transformFieldValue(f, clazz),
+                  getOwner().getFieldName(f, clazz), getOwner().transformFieldValue(f, clazz),
-        logger.info("Auto serializer generating type for {} for fields: {}", clazz, classInfo.toFormattedString());
+        logger.info("Auto serializer generating type for {} for fields: {}", clazz,
+            classInfo.toFormattedString());
-  
+
-  
+
-    return !Modifier.isTransient(f.getModifiers())
-        && !Modifier.isStatic(f.getModifiers())
+    return !Modifier.isTransient(f.getModifiers()) && !Modifier.isStatic(f.getModifiers())
-  public FieldType defaultGetFieldType(Field f, Class<?>  clazz) {
+
+  public FieldType defaultGetFieldType(Field f, Class<?> clazz) {
+
+
+
+
+
-    public void setBoolean(Object o, boolean v) throws IllegalArgumentException, IllegalAccessException {
+
+    public void setBoolean(Object o, boolean v)
+        throws IllegalArgumentException, IllegalAccessException {
+
+
+
-    public void setShort(Object o, short v) throws IllegalArgumentException, IllegalAccessException {
+
+    public void setShort(Object o, short v)
+        throws IllegalArgumentException, IllegalAccessException {
+
+
+
+
+
-    public void setFloat(Object o, float v) throws IllegalArgumentException, IllegalAccessException {
+
+    public void setFloat(Object o, float v)
+        throws IllegalArgumentException, IllegalAccessException {
+
-    public void setDouble(Object o, double v) throws IllegalArgumentException, IllegalAccessException {
+
+    public void setDouble(Object o, double v)
+        throws IllegalArgumentException, IllegalAccessException {
+
-    public void setObject(Object o, Object v) throws IllegalArgumentException, IllegalAccessException {
+
+    public void setObject(Object o, Object v)
+        throws IllegalArgumentException, IllegalAccessException {
+
-  
+
+
+
+
+
-    public void setBoolean(Object o, boolean v) throws IllegalArgumentException, IllegalAccessException {
+    public void setBoolean(Object o, boolean v)
+        throws IllegalArgumentException, IllegalAccessException {
+
+
+
+
-    public void setShort(Object o, short v) throws IllegalArgumentException, IllegalAccessException {
+    public void setShort(Object o, short v)
+        throws IllegalArgumentException, IllegalAccessException {
+
+
+
+
+
+
-    public void setFloat(Object o, float v) throws IllegalArgumentException, IllegalAccessException {
+    public void setFloat(Object o, float v)
+        throws IllegalArgumentException, IllegalAccessException {
+
+
-    public void setDouble(Object o, double v) throws IllegalArgumentException, IllegalAccessException {
+    public void setDouble(Object o, double v)
+        throws IllegalArgumentException, IllegalAccessException {
+
+
-    public void setObject(Object o, Object v) throws IllegalArgumentException, IllegalAccessException {
+    public void setObject(Object o, Object v)
+        throws IllegalArgumentException, IllegalAccessException {
-    
-    protected PdxFieldWrapper(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+
+    protected PdxFieldWrapper(AutoSerializableManager owner, Field f, String name,
+        boolean transformValue, boolean isIdentityField) {
-    public static PdxFieldWrapper create(AutoSerializableManager owner, Field f, FieldType ft, String name, boolean transformValue, boolean isIdentityField) {
+
+    public static PdxFieldWrapper create(AutoSerializableManager owner, Field f, FieldType ft,
+        String name, boolean transformValue, boolean isIdentityField) {
-      case INT:
-        return new IntField(owner, f, name, transformValue, isIdentityField);
-      case BYTE:
-        return new ByteField(owner, f, name, transformValue, isIdentityField);
-      case LONG:
-        return new LongField(owner, f, name, transformValue, isIdentityField);
-      case BOOLEAN:
-        return new BooleanField(owner, f, name, transformValue, isIdentityField);
-      case CHAR:
-        return new CharField(owner, f, name, transformValue, isIdentityField);
-      case SHORT:
-        return new ShortField(owner, f, name, transformValue, isIdentityField);
-      case DOUBLE:
-        return new DoubleField(owner, f, name, transformValue, isIdentityField);
-      case FLOAT:
-        return new FloatField(owner, f, name, transformValue, isIdentityField);
-      case STRING:
-        return new StringField(owner, f, name, transformValue, isIdentityField);
-      case DATE:
-        return new DateField(owner, f, name, transformValue, isIdentityField);
-      case BYTE_ARRAY:
-        return new ByteArrayField(owner, f, name, transformValue, isIdentityField);
-      case STRING_ARRAY:
-        return new StringArrayField(owner, f, name, transformValue, isIdentityField);
-      case ARRAY_OF_BYTE_ARRAYS:
-        return new ByteArrayArrayField(owner, f, name, transformValue, isIdentityField);
-      case BOOLEAN_ARRAY:
-        return new BooleanArrayField(owner, f, name, transformValue, isIdentityField);
-      case CHAR_ARRAY:
-        return new CharArrayField(owner, f, name, transformValue, isIdentityField);
-      case SHORT_ARRAY:
-        return new ShortArrayField(owner, f, name, transformValue, isIdentityField);
-      case INT_ARRAY:
-        return new IntArrayField(owner, f, name, transformValue, isIdentityField);
-      case LONG_ARRAY:
-        return new LongArrayField(owner, f, name, transformValue, isIdentityField);
-      case FLOAT_ARRAY:
-        return new FloatArrayField(owner, f, name, transformValue, isIdentityField);
-      case DOUBLE_ARRAY:
-        return new DoubleArrayField(owner, f, name, transformValue, isIdentityField);
-      case OBJECT_ARRAY:
-        return new ObjectArrayField(owner, f, name, transformValue, isIdentityField);
-      case OBJECT:
-        return new ObjectField(owner, f, name, transformValue, isIdentityField);
-      default:
-        throw new IllegalStateException("unhandled field type " + ft);
+        case INT:
+          return new IntField(owner, f, name, transformValue, isIdentityField);
+        case BYTE:
+          return new ByteField(owner, f, name, transformValue, isIdentityField);
+        case LONG:
+          return new LongField(owner, f, name, transformValue, isIdentityField);
+        case BOOLEAN:
+          return new BooleanField(owner, f, name, transformValue, isIdentityField);
+        case CHAR:
+          return new CharField(owner, f, name, transformValue, isIdentityField);
+        case SHORT:
+          return new ShortField(owner, f, name, transformValue, isIdentityField);
+        case DOUBLE:
+          return new DoubleField(owner, f, name, transformValue, isIdentityField);
+        case FLOAT:
+          return new FloatField(owner, f, name, transformValue, isIdentityField);
+        case STRING:
+          return new StringField(owner, f, name, transformValue, isIdentityField);
+        case DATE:
+          return new DateField(owner, f, name, transformValue, isIdentityField);
+        case BYTE_ARRAY:
+          return new ByteArrayField(owner, f, name, transformValue, isIdentityField);
+        case STRING_ARRAY:
+          return new StringArrayField(owner, f, name, transformValue, isIdentityField);
+        case ARRAY_OF_BYTE_ARRAYS:
+          return new ByteArrayArrayField(owner, f, name, transformValue, isIdentityField);
+        case BOOLEAN_ARRAY:
+          return new BooleanArrayField(owner, f, name, transformValue, isIdentityField);
+        case CHAR_ARRAY:
+          return new CharArrayField(owner, f, name, transformValue, isIdentityField);
+        case SHORT_ARRAY:
+          return new ShortArrayField(owner, f, name, transformValue, isIdentityField);
+        case INT_ARRAY:
+          return new IntArrayField(owner, f, name, transformValue, isIdentityField);
+        case LONG_ARRAY:
+          return new LongArrayField(owner, f, name, transformValue, isIdentityField);
+        case FLOAT_ARRAY:
+          return new FloatArrayField(owner, f, name, transformValue, isIdentityField);
+        case DOUBLE_ARRAY:
+          return new DoubleArrayField(owner, f, name, transformValue, isIdentityField);
+        case OBJECT_ARRAY:
+          return new ObjectArrayField(owner, f, name, transformValue, isIdentityField);
+        case OBJECT:
+          return new ObjectField(owner, f, name, transformValue, isIdentityField);
+        default:
+          throw new IllegalStateException("unhandled field type " + ft);
+
+
+
+
+
-    public abstract void serializeValue(PdxWriterImpl writer, Object newValue, boolean optimizeWrite);
+
+    public abstract void serializeValue(PdxWriterImpl writer, Object newValue,
+        boolean optimizeWrite);
+
+
-    
-    protected final Object readTransformIf(Object o, Object serializedValue) throws IllegalArgumentException, IllegalAccessException {
-      if (!transform()) return serializedValue;
+
+    protected final Object readTransformIf(Object o, Object serializedValue)
+        throws IllegalArgumentException, IllegalAccessException {
+      if (!transform())
+        return serializedValue;
-    protected final Object readTransform(Object o, Object serializedValue) throws IllegalArgumentException, IllegalAccessException {
+
+    protected final Object readTransform(Object o, Object serializedValue)
+        throws IllegalArgumentException, IllegalAccessException {
+
+
+
+
-    protected void setBoolean(Object o, boolean v) throws IllegalArgumentException, IllegalAccessException {
+
+    protected void setBoolean(Object o, boolean v)
+        throws IllegalArgumentException, IllegalAccessException {
+
-    protected void setByte(Object o, byte v) throws IllegalArgumentException, IllegalAccessException {
+
+    protected void setByte(Object o, byte v)
+        throws IllegalArgumentException, IllegalAccessException {
+
-    protected void setShort(Object o, short v) throws IllegalArgumentException, IllegalAccessException {
+
+    protected void setShort(Object o, short v)
+        throws IllegalArgumentException, IllegalAccessException {
+
-    protected void setChar(Object o, char v) throws IllegalArgumentException, IllegalAccessException {
+
+    protected void setChar(Object o, char v)
+        throws IllegalArgumentException, IllegalAccessException {
+
-    protected void setLong(Object o, long v) throws IllegalArgumentException, IllegalAccessException {
+
+    protected void setLong(Object o, long v)
+        throws IllegalArgumentException, IllegalAccessException {
+
-    protected void setFloat(Object o, float v) throws IllegalArgumentException, IllegalAccessException {
+
+    protected void setFloat(Object o, float v)
+        throws IllegalArgumentException, IllegalAccessException {
+
-    protected void setDouble(Object o, double v) throws IllegalArgumentException, IllegalAccessException {
+
+    protected void setDouble(Object o, double v)
+        throws IllegalArgumentException, IllegalAccessException {
+
-    protected void setObject(Object o, Object v) throws IllegalArgumentException, IllegalAccessException {
+
+    protected void setObject(Object o, Object v)
+        throws IllegalArgumentException, IllegalAccessException {
+
+
-  
+
-    public IntField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public IntField(AutoSerializableManager owner, Field f, String name, boolean transformValue,
+        boolean isIdentityField) {
+
-        writer.writeInt((Integer)newValue);
+        writer.writeInt((Integer) newValue);
-        writer.writeInt(getName(), (Integer)newValue);
+        writer.writeInt(getName(), (Integer) newValue);
-    public ByteField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public ByteField(AutoSerializableManager owner, Field f, String name, boolean transformValue,
+        boolean isIdentityField) {
+
-        writer.writeByte((Byte)newValue);
+        writer.writeByte((Byte) newValue);
-        writer.writeByte(getName(), (Byte)newValue);
+        writer.writeByte(getName(), (Byte) newValue);
-    public LongField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public LongField(AutoSerializableManager owner, Field f, String name, boolean transformValue,
+        boolean isIdentityField) {
+
-        writer.writeLong((Long)newValue);
+        writer.writeLong((Long) newValue);
-        writer.writeLong(getName(), (Long)newValue);
+        writer.writeLong(getName(), (Long) newValue);
-    public BooleanField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public BooleanField(AutoSerializableManager owner, Field f, String name, boolean transformValue,
+        boolean isIdentityField) {
+
-        writer.writeBoolean((Boolean)newValue);
+        writer.writeBoolean((Boolean) newValue);
-        writer.writeBoolean(getName(), (Boolean)newValue);
+        writer.writeBoolean(getName(), (Boolean) newValue);
-    public CharField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public CharField(AutoSerializableManager owner, Field f, String name, boolean transformValue,
+        boolean isIdentityField) {
+
-        writer.writeChar((Character)newValue);
+        writer.writeChar((Character) newValue);
-        writer.writeChar(getName(), (Character)newValue);
+        writer.writeChar(getName(), (Character) newValue);
-    public ShortField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public ShortField(AutoSerializableManager owner, Field f, String name, boolean transformValue,
+        boolean isIdentityField) {
+
-        writer.writeShort((Short)newValue);
+        writer.writeShort((Short) newValue);
-        writer.writeShort(getName(), (Short)newValue);
+        writer.writeShort(getName(), (Short) newValue);
-    public FloatField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public FloatField(AutoSerializableManager owner, Field f, String name, boolean transformValue,
+        boolean isIdentityField) {
+
-        writer.writeFloat((Float)newValue);
+        writer.writeFloat((Float) newValue);
-        writer.writeFloat(getName(), (Float)newValue);
+        writer.writeFloat(getName(), (Float) newValue);
-    public DoubleField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public DoubleField(AutoSerializableManager owner, Field f, String name, boolean transformValue,
+        boolean isIdentityField) {
+
-        writer.writeDouble((Double)newValue);
+        writer.writeDouble((Double) newValue);
-        writer.writeDouble(getName(), (Double)newValue);
+        writer.writeDouble(getName(), (Double) newValue);
-    public ObjectField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public ObjectField(AutoSerializableManager owner, Field f, String name, boolean transformValue,
+        boolean isIdentityField) {
+
-    public StringField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public StringField(AutoSerializableManager owner, Field f, String name, boolean transformValue,
+        boolean isIdentityField) {
+
-        writer.writeString((String)newValue);
+        writer.writeString((String) newValue);
-        writer.writeString(getName(), (String)newValue);
+        writer.writeString(getName(), (String) newValue);
-    public DateField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public DateField(AutoSerializableManager owner, Field f, String name, boolean transformValue,
+        boolean isIdentityField) {
+
-        writer.writeDate((Date)newValue);
+        writer.writeDate((Date) newValue);
-        writer.writeDate(getName(), (Date)newValue);
+        writer.writeDate(getName(), (Date) newValue);
-    public ByteArrayField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public ByteArrayField(AutoSerializableManager owner, Field f, String name,
+        boolean transformValue, boolean isIdentityField) {
+
-        writer.writeByteArray((byte[])newValue);
+        writer.writeByteArray((byte[]) newValue);
-        writer.writeByteArray(getName(), (byte[])newValue);
+        writer.writeByteArray(getName(), (byte[]) newValue);
-    public BooleanArrayField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public BooleanArrayField(AutoSerializableManager owner, Field f, String name,
+        boolean transformValue, boolean isIdentityField) {
+
-        writer.writeBooleanArray((boolean[])newValue);
+        writer.writeBooleanArray((boolean[]) newValue);
-        writer.writeBooleanArray(getName(), (boolean[])newValue);
+        writer.writeBooleanArray(getName(), (boolean[]) newValue);
-    public ShortArrayField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public ShortArrayField(AutoSerializableManager owner, Field f, String name,
+        boolean transformValue, boolean isIdentityField) {
+
-        writer.writeShortArray((short[])newValue);
+        writer.writeShortArray((short[]) newValue);
-        writer.writeShortArray(getName(), (short[])newValue);
+        writer.writeShortArray(getName(), (short[]) newValue);
-    public CharArrayField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public CharArrayField(AutoSerializableManager owner, Field f, String name,
+        boolean transformValue, boolean isIdentityField) {
+
-        writer.writeCharArray((char[])newValue);
+        writer.writeCharArray((char[]) newValue);
-        writer.writeCharArray(getName(), (char[])newValue);
+        writer.writeCharArray(getName(), (char[]) newValue);
-    public IntArrayField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public IntArrayField(AutoSerializableManager owner, Field f, String name,
+        boolean transformValue, boolean isIdentityField) {
+
-        writer.writeIntArray((int[])newValue);
+        writer.writeIntArray((int[]) newValue);
-        writer.writeIntArray(getName(), (int[])newValue);
+        writer.writeIntArray(getName(), (int[]) newValue);
-    public LongArrayField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public LongArrayField(AutoSerializableManager owner, Field f, String name,
+        boolean transformValue, boolean isIdentityField) {
+
-        writer.writeLongArray((long[])newValue);
+        writer.writeLongArray((long[]) newValue);
-        writer.writeLongArray(getName(), (long[])newValue);
+        writer.writeLongArray(getName(), (long[]) newValue);
-    public FloatArrayField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public FloatArrayField(AutoSerializableManager owner, Field f, String name,
+        boolean transformValue, boolean isIdentityField) {
+
-        writer.writeFloatArray((float[])newValue);
+        writer.writeFloatArray((float[]) newValue);
-        writer.writeFloatArray(getName(), (float[])newValue);
+        writer.writeFloatArray(getName(), (float[]) newValue);
-    public DoubleArrayField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public DoubleArrayField(AutoSerializableManager owner, Field f, String name,
+        boolean transformValue, boolean isIdentityField) {
+
-        writer.writeDoubleArray((double[])newValue);
+        writer.writeDoubleArray((double[]) newValue);
-        writer.writeDoubleArray(getName(), (double[])newValue);
+        writer.writeDoubleArray(getName(), (double[]) newValue);
-    public StringArrayField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public StringArrayField(AutoSerializableManager owner, Field f, String name,
+        boolean transformValue, boolean isIdentityField) {
+
-        writer.writeStringArray((String[])newValue);
+        writer.writeStringArray((String[]) newValue);
-        writer.writeStringArray(getName(), (String[])newValue);
+        writer.writeStringArray(getName(), (String[]) newValue);
-    public ByteArrayArrayField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public ByteArrayArrayField(AutoSerializableManager owner, Field f, String name,
+        boolean transformValue, boolean isIdentityField) {
+
-        writer.writeArrayOfByteArrays((byte[][])newValue);
+        writer.writeArrayOfByteArrays((byte[][]) newValue);
-        writer.writeArrayOfByteArrays(getName(), (byte[][])newValue);
+        writer.writeArrayOfByteArrays(getName(), (byte[][]) newValue);
-    public ObjectArrayField(AutoSerializableManager owner, Field f, String name, boolean transformValue, boolean isIdentityField) {
+    public ObjectArrayField(AutoSerializableManager owner, Field f, String name,
+        boolean transformValue, boolean isIdentityField) {
+
-        writer.writeObjectArray((Object[])newValue, getCheckPortability());
+        writer.writeObjectArray((Object[]) newValue, getCheckPortability());
-        writer.writeObjectArray(getName(), (Object[])newValue, getCheckPortability());
+        writer.writeObjectArray(getName(), (Object[]) newValue, getCheckPortability());
+
-   * Given an object, use its class to determine which fields are to be used
-   * when (de)serializing.
+   * Given an object, use its class to determine which fields are to be used when (de)serializing.
-   * @param obj
-   *          the object whose class we're interested in
-   * @return a list of fields to be used when this object's class is
-   *         (de)serialized
+   * @param obj the object whose class we're interested in
+   * @return a list of fields to be used when this object's class is (de)serialized
-   * Using the given PdxWriter, write out the relevant fields for the object
-   * instance passed in.
+   * Using the given PdxWriter, write out the relevant fields for the object instance passed in.
-   * @param writer
-   *          the <code>PdxWriter</code> to use when writing the object
-   * @param obj
-   *          the object to serialize
-   * @return <code>true</code> if the object was serialized, <code>false</code>
-   *         otherwise
+   * @param writer the <code>PdxWriter</code> to use when writing the object
+   * @param obj the object to serialize
+   * @return <code>true</code> if the object was serialized, <code>false</code> otherwise
-  private static void handleException(Exception ex, boolean serialization, String fieldName, Object obj) {
+  private static void handleException(Exception ex, boolean serialization, String fieldName,
+      Object obj) {
-      throw (CancelException)ex;
+      throw (CancelException) ex;
-      throw (NonPortableClassException)ex;
+      throw (NonPortableClassException) ex;
-      throw new PdxSerializationException((serialization ? "Serialization" : "Deserialization") 
-          + " error on field "
-          + fieldName + " for class " + obj.getClass().getName(), ex);
+      throw new PdxSerializationException((serialization ? "Serialization" : "Deserialization")
+          + " error on field " + fieldName + " for class " + obj.getClass().getName(), ex);
-   * @param writer
-   *          the <code>PdxWriter</code> to use when writing the object
-   * @param obj
-   *          the object to serialize
-   * @param autoClassInfo
-   *          a <code>List</code> of <code>Field</code>s which are to be written
-   *          out
+   * @param writer the <code>PdxWriter</code> to use when writing the object
+   * @param obj the object to serialize
+   * @param autoClassInfo a <code>List</code> of <code>Field</code>s which are to be written out
-    PdxWriterImpl w = (PdxWriterImpl)writer;
+    PdxWriterImpl w = (PdxWriterImpl) writer;
-      //System.out.println("DEBUG writing field=" + f.getField().getName() + " offset=" + ((PdxWriterImpl)writer).position());
+      // System.out.println("DEBUG writing field=" + f.getField().getName() + " offset=" +
+      // ((PdxWriterImpl)writer).position());
-          Object newValue = getOwner().writeTransform(f.getField(), obj.getClass(), f.getObject(obj));
+          Object newValue =
+              getOwner().writeTransform(f.getField(), obj.getClass(), f.getObject(obj));
-  private static final boolean USE_CONSTRUCTOR = !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "autopdx.ignoreConstructor");
-  
+  private static final boolean USE_CONSTRUCTOR =
+      !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "autopdx.ignoreConstructor");
+
-   * @param reader
-   *          the <code>PdxReader</code> to use when reading the object
-   * @param clazz
-   *          the class of the object to re-create
+   * @param reader the <code>PdxReader</code> to use when reading the object
+   * @param clazz the class of the object to re-create
-      InternalPdxReader ri = (InternalPdxReader)reader;
+      InternalPdxReader ri = (InternalPdxReader) reader;
+   * 
-   * @param fieldPattern the pattern to identify a field as an identity field
-   *  within the given class pattern
+   * @param fieldPattern the pattern to identify a field as an identity field within the given class
+   *        pattern
-   * Return the identity patterns. The patterns are returned as a <code>List</code>
-   * of <code>String</code> arrays of size 2 - essentially a tuple of the form
+   * Return the identity patterns. The patterns are returned as a <code>List</code> of
+   * <code>String</code> arrays of size 2 - essentially a tuple of the form
+   * 
+   * 
-   * @param fieldPattern the pattern to exclude a field from serialization
-   *  within the given class pattern
+   * @param fieldPattern the pattern to exclude a field from serialization within the given class
+   *        pattern
-   * Return the exclude patterns. The patterns are returned as a <code>List</code>
-   * of <code>String</code> arrays of size 2 - essentially a tuple of the form
+   * Return the exclude patterns. The patterns are returned as a <code>List</code> of
+   * <code>String</code> arrays of size 2 - essentially a tuple of the form
+   * 
-   * Helper method which determines whether a given field matches a set of
-   * class/field patterns.
+   * Helper method which determines whether a given field matches a set of class/field patterns.
+   * 
-   * @param matches a map containing the 
+   * 
+   * @param matches a map containing the
+   * 
-  private boolean fieldMatches(Field field, 
-      String className, 
-      List<String[]> matches) {
+  private boolean fieldMatches(Field field, String className, List<String[]> matches) {
-     * The pdxType ids that do not exactly match our class.
-     * Either their field order differs it they have extra or missing fields.
+     * The pdxType ids that do not exactly match our class. Either their field order differs it they
+     * have extra or missing fields.
-    
+
-    
+
-    
+
-      for (Object o: this.fields) {
+      for (Object o : this.fields) {
-                .toLocalizedString(clazz.getName()), ex);
+                .toLocalizedString(clazz.getName()),
+            ex);
+
-    
+
+
-      for (PdxFieldWrapper f: this.fields) {
+      for (PdxFieldWrapper f : this.fields) {
-          return false; // If the type has a deleted field then we can't do ordered deserialization because we need to skip over the deleted field's bytes.
+          return false; // If the type has a deleted field then we can't do ordered deserialization
+                        // because we need to skip over the deleted field's bytes.
+
-          String key = (String)o;
+          String key = (String) o;
-            throw new IllegalArgumentException("ReflectionBasedAutoSerializer: unknown init property \"" + key + "\"");
+            throw new IllegalArgumentException(
+                "ReflectionBasedAutoSerializer: unknown init property \"" + key + "\"");
-          throw new IllegalArgumentException("ReflectionBasedAutoSerializer: unknown non-String init property \"" + o + "\"");
+          throw new IllegalArgumentException(
+              "ReflectionBasedAutoSerializer: unknown non-String init property \"" + o + "\"");
-    for (Iterator<String> i = tmp.iterator(); i.hasNext(); ) {
+    for (Iterator<String> i = tmp.iterator(); i.hasNext();) {
-      for (Iterator<String[]> i = getIdentityPatterns().iterator();
-          i.hasNext(); ) {
+      for (Iterator<String[]> i = getIdentityPatterns().iterator(); i.hasNext();) {
-      for (Iterator<String[]> i = getExcludePatterns().iterator();
-          i.hasNext(); ) {
+      for (Iterator<String[]> i = getExcludePatterns().iterator(); i.hasNext();) {
-    
+
+
-            throw new IllegalArgumentException("Unable to correctly process auto serialization init value: " +
-                value);
+            throw new IllegalArgumentException(
+                "Unable to correctly process auto serialization init value: " + value);
-            throw new IllegalArgumentException("Unable to correctly process auto serialization init value: " +
-                value);
+            throw new IllegalArgumentException(
+                "Unable to correctly process auto serialization init value: " + value);
-  
+
+
-    result = prime * result
-        + ((classPatterns == null) ? 0 : classPatterns.hashCode());
-    result = prime * result
-        + ((excludePatterns == null) ? 0 : excludePatterns.hashCode());
-    result = prime * result
-        + ((identityPatterns == null) ? 0 : identityPatterns.hashCode());
+    result = prime * result + ((classPatterns == null) ? 0 : classPatterns.hashCode());
+    result = prime * result + ((excludePatterns == null) ? 0 : excludePatterns.hashCode());
+    result = prime * result + ((identityPatterns == null) ? 0 : identityPatterns.hashCode());

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
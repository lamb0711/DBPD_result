Merge branch 'release/1.5.0'

+import org.apache.geode.Statistics;
+import org.apache.geode.cache.client.internal.ClientSideHandshakeImpl;
-import org.apache.geode.distributed.DistributedSystem;
-import org.apache.geode.distributed.internal.DM;
+import org.apache.geode.distributed.internal.DistributionManager;
+import org.apache.geode.internal.cache.eviction.EvictionController;
+import org.apache.geode.internal.cache.eviction.EvictionCounters;
-import org.apache.geode.internal.cache.tier.sockets.HandShake;
-  private RegionVersionVector versionVector;
+  private final RegionVersionVector versionVector;
-  public final Lock clientMetaDataLock = new ReentrantLock();
+  private final Lock clientMetaDataLock = new ReentrantLock();
+
+    versionVector = createRegionVersionVector();
-    if (!this.concurrencyChecksEnabled) {
+    if (!this.getConcurrencyChecksEnabled()) {
-  /** initializes a new version vector for this region */
-  void createVersionVector() {
-    this.versionVector = RegionVersionVector.create(getVersionMember(), this);
+  protected RegionVersionVector createRegionVersionVector() {
+    if (getConcurrencyChecksEnabled()) {
+      return createVersionVector();
+    }
+    return null;
+  }
-    if (this.dataPolicy.withPersistence()) {
+  /** initializes a new version vector for this region */
+  private RegionVersionVector createVersionVector() {
+    RegionVersionVector regionVersionVector = RegionVersionVector.create(getVersionMember(), this);
+
+    if (this.getDataPolicy().withPersistence()) {
-      RegionVersionVector diskVector = this.diskRegion.getRegionVersionVector();
-      this.versionVector.recordVersions(diskVector.getCloneForTransmission());
-    } else if (!this.dataPolicy.withStorage()) {
+      RegionVersionVector diskVector = diskRegion.getRegionVersionVector();
+      regionVersionVector.recordVersions(diskVector.getCloneForTransmission());
+    } else if (!this.getDataPolicy().withStorage()) {
-      this.versionVector.turnOffRecordingForEmptyRegion();
+      regionVersionVector.turnOffRecordingForEmptyRegion();
-    if (this.serverRegionProxy != null) {
-      this.versionVector.setIsClientVector();
+    if (serverRegionProxy != null) {
+      regionVersionVector.setIsClientVector();
-    this.cache.getDistributionManager().addMembershipListener(this.versionVector);
+    cache.getDistributionManager().addMembershipListener(regionVersionVector);
+    return regionVersionVector;
+  @Override
-    if (this.dataPolicy.withPersistence()) {
+    if (this.getDataPolicy().withPersistence()) {
-        } else if (HandShake.isDeltaEnabledOnServer()) {
+        } else if (ClientSideHandshakeImpl.isDeltaEnabledOnServer()) {
-  Set basicSubregions(boolean recursive) {
+  @Override
+  public Set basicSubregions(boolean recursive) {
-    if (!this.concurrencyChecksEnabled) {
+    if (!this.getConcurrencyChecksEnabled()) {
-  protected int getRegionSize() {
+  public int getRegionSize() {
-      if (this.imageState.isClient() && !this.concurrencyChecksEnabled) {
+      if (this.imageState.isClient() && !this.getConcurrencyChecksEnabled()) {
-   * Look up the LocalRegion with the specified full path.
-   *
-   * @param system the distributed system whose cache contains the root of interest
-   * @return the LocalRegion or null if not found
-   */
-  static LocalRegion getRegionFromPath(DistributedSystem system, String path) {
-    Cache cache = GemFireCacheImpl.getInstance();
-    if (cache == null) {
-      return null;
-    } else {
-      return (LocalRegion) cache.getRegion(path);
-    }
-  }
-
-  /**
-  protected void initialize(InputStream snapshotInputStream, InternalDistributedMember imageTarget,
+  @Override
+  public void initialize(InputStream snapshotInputStream, InternalDistributedMember imageTarget,
-    // if we're versioning entries we need a region-level version vector
-    if (this.concurrencyChecksEnabled && this.versionVector == null) {
-      createVersionVector();
-    }
-      this.indexManager = IndexUtils.getIndexManager(this, true);
+      this.indexManager = IndexUtils.getIndexManager(cache, this, true);
-      if (this.concurrencyChecksEnabled && this.dataPolicy.withReplication()
+      if (this.getConcurrencyChecksEnabled() && this.getDataPolicy().withReplication()
-    this.entries.close();
+    this.entries.close(null);
-    return this.entries.clear(rvv);
+    return this.entries.clear(rvv, null);
-  void checkEntryNotFound(Object entryKey) {
+  @Override
+  public void checkEntryNotFound(Object entryKey) {
-        final LoaderHelper loaderHelper =
-            this.loaderHelperFactory.createLoaderHelper(key, aCallbackArgument,
-                false /* netSearchAllowed */, true /* netloadAllowed */, null /* searcher */);
+        fromServer = false;
-          value = loader.load(loaderHelper);
-          fromServer = false;
+          value = callCacheLoader(loader, key, aCallbackArgument);
-    if (fromServer && value == Token.TOMBSTONE && !this.concurrencyChecksEnabled) {
+    if (fromServer && value == Token.TOMBSTONE && !this.getConcurrencyChecksEnabled()) {
+  @SuppressWarnings({"rawtypes", "unchecked"})
+  protected Object callCacheLoader(CacheLoader loader, final Object key,
+      final Object aCallbackArgument) {
+    LoaderHelper loaderHelper = this.loaderHelperFactory.createLoaderHelper(key, aCallbackArgument,
+        false /* netSearchAllowed */, true /* netloadAllowed */, null /* searcher */);
+    Object result = loader.load(loaderHelper);
+    result = this.getCache().convertPdxInstanceIfNeeded(result);
+    return result;
+  }
+
-  boolean bridgeWriteBeforeDestroy(EntryEventImpl event, Object expectedOldValue)
+  @Override
+  public boolean bridgeWriteBeforeDestroy(EntryEventImpl event, Object expectedOldValue)
-  void rescheduleTombstone(RegionEntry entry, VersionTag version) {
+  @Override
+  public void rescheduleTombstone(RegionEntry entry, VersionTag version) {
-    if (!this.concurrencyChecksEnabled) {
+    if (!this.getConcurrencyChecksEnabled()) {
-    if (this.concurrencyChecksEnabled) {
+    if (this.getConcurrencyChecksEnabled()) {
-      return this.concurrencyChecksEnabled
-          && (entry.getVersionStamp().hasValidVersion() || this.dataPolicy.withReplication());
+      return this.getConcurrencyChecksEnabled()
+          && (entry.getVersionStamp().hasValidVersion() || this.getDataPolicy().withReplication());
-    this.concurrencyChecksEnabled = true;
-    if (this.dataPolicy.withStorage()) {
+    this.setConcurrencyChecksEnabled(true);
+    if (this.getDataPolicy().withStorage()) {
-      createVersionVector();
-    return this.concurrencyChecksEnabled;
+    return this.getConcurrencyChecksEnabled();
+            logger.warn(
+                "Usage of registerInterest('ALL_KEYS') has been deprecated.  Please use registerInterestForAllKeys()");
+              logger.warn(
+                  "Usage of registerInterest(List) has been deprecated. Please use registerInterestForKeys(Iterable)");
-            boolean isTombstone = this.concurrencyChecksEnabled && entry.isKeyNotOnServer()
+            boolean isTombstone = this.getConcurrencyChecksEnabled() && entry.isKeyNotOnServer()
-              val = CachedDeserializableFactory.create((byte[]) val);
+              val = CachedDeserializableFactory.create((byte[]) val, getCache());
-        if (this.concurrencyChecksEnabled) {
+        if (this.getConcurrencyChecksEnabled()) {
-  Region getSubregion(String path, boolean destroyedRegionOk) {
+  @Override
+  public Region getSubregion(String path, boolean destroyedRegionOk) {
-  boolean checkForInitialization() {
+  @Override
+  public boolean checkForInitialization() {
+  @Override
-  void basicInvalidate(EntryEventImpl event) throws EntryNotFoundException {
+  public void basicInvalidate(EntryEventImpl event) throws EntryNotFoundException {
-    if (this.concurrencyChecksEnabled) {
+    if (this.getConcurrencyChecksEnabled()) {
-    if (this.concurrencyChecksEnabled) {
+    if (this.getConcurrencyChecksEnabled()) {
-    if (this.concurrencyChecksEnabled) {
+    if (this.getConcurrencyChecksEnabled()) {
-      if (this.concurrencyChecksEnabled && event.getVersionTag() != null
+      if (this.getConcurrencyChecksEnabled() && event.getVersionTag() != null
-  protected boolean basicPut(EntryEventImpl event, boolean ifNew, boolean ifOld,
+  public boolean basicPut(EntryEventImpl event, boolean ifNew, boolean ifOld,
-    if (!this.concurrencyMessageIssued && tag == null && this.concurrencyChecksEnabled) {
+    if (!this.concurrencyMessageIssued && tag == null && this.getConcurrencyChecksEnabled()) {
-          new Object[] {!this.concurrencyChecksEnabled, this.concurrencyChecksEnabled, this}));
+          new Object[] {!this.getConcurrencyChecksEnabled(), this.getConcurrencyChecksEnabled(),
+              this}));
-          final boolean forceNewEntry = this.concurrencyChecksEnabled;
+          final boolean forceNewEntry = this.getConcurrencyChecksEnabled();
-      if (this.concurrencyChecksEnabled && event.getVersionTag() != null
+      if (this.getConcurrencyChecksEnabled() && event.getVersionTag() != null
+      notifyGatewaySender(event.getOperation().isUpdate() ? EnumListenerEvent.AFTER_UPDATE
+          : EnumListenerEvent.AFTER_CREATE, event);
-    if (mySRP != null && this.dataPolicy == DataPolicy.EMPTY) {
+    if (mySRP != null && this.getDataPolicy() == DataPolicy.EMPTY) {
-  void notifyTimestampsToGateways(EntryEventImpl event) {
+  @Override
+  public void notifyTimestampsToGateways(EntryEventImpl event) {
-  @Override
-  public boolean isConcurrencyChecksEnabled() {
-    return this.concurrencyChecksEnabled;
-  }
-
-  void syncBulkOp(Runnable task, EventID eventId) {
+  public void syncBulkOp(Runnable task, EventID eventId) {
-    if (isPdxTypesRegion() || event.isConcurrencyConflict()) {
-      // isConcurrencyConflict is usually a concurrent cache modification problem
+    if (isPdxTypesRegion()) {
-  protected void postCreateRegion() {
+  @Override
+  public void postCreateRegion() {
-      if (this.concurrencyChecksEnabled && event.getVersionTag() != null
+      if (this.getConcurrencyChecksEnabled() && event.getVersionTag() != null
+  private boolean isJTAPaused() {
+    TXManagerImpl txMgr = (TXManagerImpl) getCache().getCacheTransactionManager();
+    return txMgr.isJTAPaused();
+  }
+
+        notifyGatewaySender(EnumListenerEvent.AFTER_DESTROY, event);
-  protected void basicDestroyBeforeRemoval(RegionEntry entry, EntryEventImpl event) {
+  @Override
+  public void basicDestroyBeforeRemoval(RegionEntry entry, EntryEventImpl event) {
-  void basicDestroyPart2(RegionEntry re, EntryEventImpl event, boolean inTokenMode,
+  @Override
+  public void basicDestroyPart2(RegionEntry re, EntryEventImpl event, boolean inTokenMode,
-    if (inTokenMode && !(this.concurrencyChecksEnabled || event.isFromRILocalDestroy())) {
+    if (inTokenMode && !(this.getConcurrencyChecksEnabled() || event.isFromRILocalDestroy())) {
-      if (this.concurrencyChecksEnabled && !(this instanceof HARegion)) {
+      if (this.getConcurrencyChecksEnabled() && !(this instanceof HARegion)) {
-  void basicDestroyPart3(RegionEntry re, EntryEventImpl event, boolean inTokenMode,
+  @Override
+  public void basicDestroyPart3(RegionEntry re, EntryEventImpl event, boolean inTokenMode,
+  @Override
-  void cleanupFailedInitialization() {
+  @Override
+  public void cleanupFailedInitialization() {
-      region = this.cache.getReinitializingRegion(thePath);
+      region = (LocalRegion) this.cache.getReinitializingRegion(thePath);
-    closeCacheCallback(getEvictionController());
+    EvictionController evictionController = getEvictionController();
+    if (evictionController != null) {
+      evictionController.close();
+    }
-  void handleCacheClose(Operation operation) {
+  @Override
+  public void handleCacheClose(Operation operation) {
-        throw new CacheClosedException("Cache is being closed by ShutdownAll");
+        throw cache.getCacheClosedException("Cache is being closed by ShutdownAll");
-  /**
-   * Used by unit tests to get access to the EntryExpiryTask of the given key. Returns null if the
-   * entry exists but does not have an expiry task.
-   *
-   * @throws EntryNotFoundException if no entry exists key.
-   */
+  @Override
-  void cancelExpiryTask(RegionEntry regionEntry) {
+  @Override
+  public void cancelExpiryTask(RegionEntry regionEntry) {
-          if (isTransactionPaused()) {
+          if (isTransactionPaused() || isJTAPaused()) {
-    if (useRVV && this.dataPolicy.withReplication() && this.concurrencyChecksEnabled) {
+    if (useRVV && this.getDataPolicy().withReplication() && this.getConcurrencyChecksEnabled()) {
-    if (rvv != null && this.dataPolicy.withStorage()) {
+    if (rvv != null && this.getDataPolicy().withStorage()) {
-      if (!this.dataPolicy.withPersistence()) {
+      if (!this.getDataPolicy().withPersistence()) {
-            createTombstone = entry.getVersionTag() != null && this.concurrencyChecksEnabled;
+            createTombstone = entry.getVersionTag() != null && this.getConcurrencyChecksEnabled();
-        new VersionedObjectList(map.size(), true, this.concurrencyChecksEnabled);
+        new VersionedObjectList(map.size(), true, this.getConcurrencyChecksEnabled());
-        && !isTX() && this.dataPolicy != DataPolicy.EMPTY;
+        && !isTX() && this.getDataPolicy() != DataPolicy.EMPTY;
-                if (versionTag == null && serverIsVersioned && concurrencyChecksEnabled
-                    && dataPolicy.withStorage()) {
+                if (versionTag == null && serverIsVersioned && getConcurrencyChecksEnabled()
+                    && getDataPolicy().withStorage()) {
-        new VersionedObjectList(keys.size(), true, this.concurrencyChecksEnabled);
+        new VersionedObjectList(keys.size(), true, this.getConcurrencyChecksEnabled());
-    if (this.versionVector != null && this.dataPolicy.withReplication()) {
+    if (this.versionVector != null && this.getDataPolicy().withReplication()) {
-    if (this.versionVector != null && this.dataPolicy.withReplication()) {
+    if (this.versionVector != null && this.getDataPolicy().withReplication()) {
-    if (!this.dataPolicy.withStorage() && this.concurrencyChecksEnabled
+    if (!this.getDataPolicy().withStorage() && this.getConcurrencyChecksEnabled()
-    if (!this.dataPolicy.withStorage() && this.concurrencyChecksEnabled
+    if (!this.getDataPolicy().withStorage() && this.getConcurrencyChecksEnabled()
-    return this.concurrencyChecksEnabled && this.dataPolicy.withReplication()
+    return this.getConcurrencyChecksEnabled() && this.getDataPolicy().withReplication()
+  @Override
+  @Override
+  @Override
-  protected boolean isSecret() {
+  @Override
+  public boolean isSecret() {
-    return !isSecret() || this.dataPolicy.withPersistence();
+    return !isSecret() || this.getDataPolicy().withPersistence();
-  void cleanupForClient(CacheClientNotifier clientNotifier, ClientProxyMembershipID client) {
+  @Override
+  public void cleanupForClient(CacheClientNotifier clientNotifier, ClientProxyMembershipID client) {
-    final DM dm = getDistributionManager();
+    final DistributionManager dm = getDistributionManager();
-  void updateSizeOnRemove(Object key, int oldSize) {
+  public void updateSizeOnRemove(Object key, int oldSize) {
+  @Override
-  void senderCreated() {
+  @Override
+  public void senderCreated() {
-        && (this.dataPolicy == DataPolicy.NORMAL && this.scope.isDistributed()
-            || this.dataPolicy == DataPolicy.EMPTY)) {
+        && (this.getDataPolicy() == DataPolicy.NORMAL && this.scope.isDistributed()
+            || this.getDataPolicy() == DataPolicy.EMPTY)) {
-    return this.dataPolicy.withStorage();
+    return this.getDataPolicy().withStorage();
-  public long getEvictions() {
+  public long getTotalEvictions() {
+  public void incBucketEvictions() {
+    // nothing needed by default
+    // override this method on BucketRegion
+  }
+
+  @Override
+  public long getEvictionCounter() {
+    long result = 0L;
+    EvictionController evictionController = getEvictionController();
+    if (evictionController != null) {
+      EvictionCounters es = evictionController.getCounters();
+      if (es != null) {
+        result = es.getCounter();
+      }
+    }
+    return result;
+  }
+
+  public long getEvictionLimit() {
+    long result = 0L;
+    EvictionController evictionController = getEvictionController();
+    if (evictionController != null) {
+      EvictionCounters es = evictionController.getCounters();
+      if (es != null) {
+        result = es.getLimit();
+      }
+    }
+    return result;
+  }
+
+  public long getEvictionDestroys() {
+    long result = 0;
+    EvictionController evictionController = getEvictionController();
+    if (evictionController != null) {
+      EvictionCounters es = evictionController.getCounters();
+      if (es != null) {
+        result = es.getDestroys();
+      }
+    }
+    return result;
+  }
+
+  public EvictionController getEvictionController() {
+    return getRegionMap().getEvictionController();
+  }
+
+  @Override
+  public void setEvictionMaximum(int maximum) {
+    EvictionController evictionController = getEvictionController();
+    if (evictionController != null) {
+      evictionController.setLimit(maximum);
+    }
+  }
+
+  @Override
+  public Statistics getEvictionStatistics() {
+    Statistics result = null;
+    EvictionController evictionController = getEvictionController();
+    if (evictionController != null) {
+      EvictionCounters es = evictionController.getCounters();
+      if (es != null) {
+        result = es.getStatistics();
+      }
+    }
+    return result;
+  }
+
+  @Override
+  public EvictionController getExistingController(InternalRegionArguments internalArgs) {
+    return null;
+  }
+
+  @Override
+  public String getNameForStats() {
+    return getFullPath();
+  }
+
+  @Override
+  public Lock getClientMetaDataLock() {
+    return clientMetaDataLock;
+  }

MOV26 MOV26 MOV26 INS26 INS26 MOV31 MOV31 UPD40 INS40 UPD40 INS40 UPD40 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 UPD83 INS83 INS43 INS42 INS8 INS83 INS43 INS78 INS78 INS83 UPD83 INS78 UPD83 INS83 INS39 INS42 MOV8 MOV8 INS78 INS83 INS79 UPD83 UPD43 UPD42 INS44 INS78 INS83 INS78 INS83 INS78 INS83 MOV78 INS83 INS78 INS83 UPD83 INS78 INS83 INS83 INS78 UPD83 UPD83 UPD42 INS78 UPD83 INS78 INS83 INS78 INS83 INS78 INS78 INS83 INS78 INS83 INS78 INS78 INS83 INS78 INS78 INS78 INS78 UPD83 INS78 INS83 INS83 INS78 INS78 INS83 UPD42 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS83 INS43 INS42 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS43 INS42 INS8 INS78 INS83 INS43 INS42 INS44 MOV8 INS78 INS83 INS43 INS42 INS8 INS78 INS83 INS43 INS42 INS8 INS21 INS42 INS25 INS41 INS42 INS60 INS41 INS42 INS42 INS42 INS21 INS41 INS42 INS42 INS4 UPD42 UPD43 UPD42 INS83 UPD43 UPD42 INS83 INS43 INS42 MOV60 INS21 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS42 INS42 INS42 INS42 INS42 INS60 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS60 INS60 INS25 INS41 INS60 INS60 INS25 INS41 INS60 INS60 INS25 INS41 INS42 INS41 INS42 INS39 INS42 INS60 INS25 INS42 INS42 INS60 INS60 INS25 INS41 INS42 INS42 INS43 INS42 INS42 INS42 INS41 INS42 INS42 INS41 INS7 INS32 MOV8 INS33 MOV43 INS59 INS42 MOV32 MOV32 INS45 INS45 UPD42 UPD42 INS42 UPD43 INS7 INS42 INS32 INS32 INS32 INS32 INS32 INS32 MOV32 INS43 INS59 INS32 INS43 INS59 INS27 INS8 INS27 MOV27 UPD43 INS39 INS59 INS43 INS59 INS27 INS8 INS42 INS39 INS59 INS43 INS59 INS27 INS8 INS42 INS39 INS59 INS43 INS59 INS27 INS8 INS42 INS32 INS43 INS59 INS27 INS8 INS43 INS59 INS43 INS59 INS27 INS8 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS41 INS42 MOV32 INS32 INS42 INS42 INS32 INS32 UPD42 INS33 UPD42 INS42 INS33 UPD42 UPD42 MOV32 INS42 INS32 INS32 INS52 INS42 INS52 INS42 INS9 INS32 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS32 INS42 INS42 INS11 INS42 INS42 INS42 INS42 MOV32 INS42 INS33 MOV21 INS32 MOV27 INS32 INS32 INS32 INS32 UPD42 INS32 INS42 INS34 INS42 INS42 INS32 INS42 INS33 INS60 INS25 INS42 INS34 INS42 INS42 INS32 INS42 INS33 INS60 INS25 INS42 INS34 INS42 INS42 INS32 INS42 INS33 INS60 INS25 INS32 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS33 INS42 INS42 INS32 INS42 INS33 INS60 INS25 INS42 INS42 INS52 INS42 MOV32 INS52 INS42 INS43 INS42 INS52 INS42 INS52 INS42 INS32 INS32 UPD42 MOV42 UPD42 MOV42 INS52 INS42 INS52 INS42 INS52 INS42 INS21 INS32 INS43 INS32 INS32 INS52 INS42 INS32 INS32 INS32 INS32 INS42 INS32 INS52 INS42 INS52 INS42 INS52 INS42 INS32 INS32 INS52 INS42 INS42 INS43 INS59 INS27 INS8 INS42 INS43 INS59 INS27 INS8 INS42 INS43 INS59 INS27 INS8 INS42 INS42 INS32 INS42 INS43 INS59 INS27 INS8 INS42 INS42 INS32 INS42 INS32 MOV21 INS52 INS42 INS52 UPD42 MOV42 INS32 INS32 INS52 INS42 INS42 INS32 INS42 INS32 INS11 INS42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS32 INS52 INS42 INS52 INS42 INS52 INS42 INS32 INS32 INS52 INS42 INS52 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS52 INS42 INS42 INS32 INS42 INS52 INS42 INS32 INS52 INS42 INS21 INS32 INS32 INS32 INS42 INS16 INS42 INS32 INS42 INS21 INS32 INS52 INS42 MOV43 MOV32 INS32 INS52 INS42 INS52 INS42 INS52 INS42 INS32 INS42 INS42 INS7 INS42 INS42 INS7 INS42 INS42 INS7 INS42 INS42 INS7 INS52 INS42 INS52 INS42 INS32 INS52 INS42 INS52 INS42 INS52 INS42 INS32 INS40 INS40 INS52 INS42 INS32 INS52 INS42 INS32 INS52 INS42 INS32 INS52 INS42 INS42 INS32 INS42 INS32 INS42 INS32 INS42 INS32 UPD42 INS32 INS42 INS42 INS45 INS21 INS32 INS32 INS42 INS42 INS40 INS42 INS42 INS42 INS45 INS27 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS52 INS42 INS32 INS32 INS52 INS42 INS32 INS42 INS42 MOV32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS52 INS42 INS52 INS42 INS42 INS32 INS32 INS52 INS42 INS52 INS42 INS32 INS42 INS32 INS32 INS42 UPD42 MOV42 DEL52 DEL42 DEL22 DEL21 DEL39 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL33 DEL27 DEL27 DEL25 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL41 DEL83 DEL39 DEL42 DEL31 DEL21 DEL52 DEL42 DEL22 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL32 DEL11 DEL41 DEL8 DEL25 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL9 DEL7 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL27 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL45 DEL14 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL27 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22
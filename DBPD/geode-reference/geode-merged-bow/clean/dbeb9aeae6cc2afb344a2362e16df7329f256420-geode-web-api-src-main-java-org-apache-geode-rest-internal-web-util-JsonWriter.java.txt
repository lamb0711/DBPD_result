Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import java.io.IOException;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.springframework.hateoas.Link;
-import org.springframework.http.HttpHeaders;
-import org.springframework.http.MediaType;
-import org.springframework.util.CollectionUtils;
-
-import org.apache.geode.rest.internal.web.exception.GemfireRestException;
+import org.springframework.hateoas.Link;
+import org.springframework.http.HttpHeaders;
+import org.springframework.http.MediaType;
+import org.springframework.util.CollectionUtils;
+
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+ *
-  
-  public static void writeLinkAsJson(JsonGenerator generator, Link value, String pdxField) throws JsonGenerationException, IOException {
+
+  public static void writeLinkAsJson(JsonGenerator generator, Link value, String pdxField)
+      throws JsonGenerationException, IOException {
-    
+
-    
+
-    
+
-    
+
-    
+
-    List<Charset>  arg = new ArrayList<Charset>();
+    List<Charset> arg = new ArrayList<Charset>();
-    
-    generator.writeString(header.getContentType() + ", charset=" + header.getAcceptCharset().get(0).displayName());
-    
+
+    generator.writeString(
+        header.getContentType() + ", charset=" + header.getAcceptCharset().get(0).displayName());
+
-  
-  public static void writeQueryListAsJson(JsonGenerator generator, String pdxField, Region<String, String> region) throws JsonGenerationException, IOException{
+
+  public static void writeQueryListAsJson(JsonGenerator generator, String pdxField,
+      Region<String, String> region) throws JsonGenerationException, IOException {
-    
+
-    
-    for (Map.Entry<String,String> entry : region.entrySet()){ 
+
+    for (Map.Entry<String, String> entry : region.entrySet()) {
-      
-      generator.writeFieldName("id"); 
+
+      generator.writeFieldName("id");
-      
+
-      
-      generator.writeEndObject();  
+
+      generator.writeEndObject();
-    
+
-  
-  public static void writeQueryAsJson(JsonGenerator generator, String queryId, String query) throws JsonGenerationException, IOException{
-    generator.writeStartObject();
-    
-    generator.writeFieldName("id"); 
-    generator.writeString(queryId);
-      
-    generator.writeFieldName("oql");
-    generator.writeString(query);
-      
-    generator.writeEndObject();
-  }
-  public static void writeListAsJson(JsonGenerator generator, Map map, String name, String fieldName) throws JsonGenerationException, IOException{
+  public static void writeQueryAsJson(JsonGenerator generator, String queryId, String query)
+      throws JsonGenerationException, IOException {
+    generator.writeStartObject();
+
+    generator.writeFieldName("id");
+    generator.writeString(queryId);
+
+    generator.writeFieldName("oql");
+    generator.writeString(query);
+
+    generator.writeEndObject();
+  }
+
+  public static void writeListAsJson(JsonGenerator generator, Map map, String name,
+      String fieldName) throws JsonGenerationException, IOException {
-    //introspect the Map and write its value into desired format
+    // introspect the Map and write its value into desired format
-    while(iter.hasNext()) {
+    while (iter.hasNext()) {
-      //Iterate over Map and write key-value
+      // Iterate over Map and write key-value
-  public static void writeCollectionAsJson(JsonGenerator generator, /*List*/ Collection<?> coll) throws JsonGenerationException, IOException
-  {
+  public static void writeCollectionAsJson(JsonGenerator generator, /* List */ Collection<?> coll)
+      throws JsonGenerationException, IOException {
-    
-    for (Object obj : coll)
-    {
+
+    for (Object obj : coll) {
-    generator.writeEndArray();    
+    generator.writeEndArray();
-  
-  public static void writeStructAsJson(JsonGenerator generator, StructImpl element) throws JsonGenerationException, IOException{
+
+  public static void writeStructAsJson(JsonGenerator generator, StructImpl element)
+      throws JsonGenerationException, IOException {
-    
+
-    //Iterate over Map and write key-value
-      generator.writeFieldName(fieldNames[fieldNamesIndex]); //write Key in a Map
+      // Iterate over Map and write key-value
+      generator.writeFieldName(fieldNames[fieldNamesIndex]); // write Key in a Map
-      writeValueAsJson(generator, value, null); //write value in a Map
+      writeValueAsJson(generator, value, null); // write value in a Map
-  
-  public static String writePdxInstanceAsJson(JsonGenerator generator, PdxInstance pdxInstance) throws JsonGenerationException, IOException
-  {
+
+  public static String writePdxInstanceAsJson(JsonGenerator generator, PdxInstance pdxInstance)
+      throws JsonGenerationException, IOException {
-    
+
-    
-    for (String pdxField : pdxFields)
-    {
+
+    for (String pdxField : pdxFields) {
-  } 
-  
-  public static void writeArrayAsJson(JsonGenerator generator, Object value, String pdxField) throws JsonGenerationException, IOException {
-    
-    if(value.getClass().getName().equals("[Z")) 
-    {
-      writePrimitiveBoolArrayAsJson(generator, (boolean[])value);
-    }
-    else if(value.getClass().getName().equals("[B")) 
-    {
-      writePrimitiveByteArrayAsJson(generator, (byte[])value);
-    }
-    else if(value.getClass().getName().equals("[S")) 
-    {
-      writePrimitiveShortArrayAsJson(generator, (short[])value);
-    }
-    else if(value.getClass().getName().equals("[I")) 
-    {
-      writePrimitiveIntArrayAsJson(generator, (int[])value);
-    }
-    else if(value.getClass().getName().equals("[J")) 
-    {
-      writePrimitiveLongArrayAsJson(generator, (long[])value);
-    }
-    else if(value.getClass().getName().equals("[F"))
-    {
-      writePrimitiveFloatArrayAsJson(generator, (float[])value);
-    }
-    else if(value.getClass().getName().equals("[D")) 
-    {
-      writePrimitiveDoubleArrayAsJson(generator, (double[])value);
-    }
-    else if(value.getClass().equals(Boolean[].class))
-    {
-      writeWrapperBoolArrayAsJson(generator, (Boolean[])value);
-    }
-    else if(value.getClass().equals(Byte[].class))
-    {
-      writeWrapperByteArrayAsJson(generator, (Byte[])value);
-    }
-    else if(value.getClass().equals(Short[].class))
-    {
-      writeWrapperShortArrayAsJson(generator, (Short[])value);
-    }
-    else if(value.getClass().equals(Integer[].class))
-    {
-      writeWrapperIntArrayAsJson(generator, (Integer[])value);
-    }
-    else if(value.getClass().equals(Long[].class))
-    {
-      writeWrapperLongArrayAsJson(generator, (Long[])value);
-    }
-    else if(value.getClass().equals(Float[].class))
-    {
-      writeWrapperFloatArrayAsJson(generator, (Float[])value);
-    }
-    else if(value.getClass().equals(Double[].class))
-    {
-      writeWrapperDoubleArrayAsJson(generator, (Double[])value);
-    }
-    else if(value.getClass().equals(BigInteger[].class))
-    {
-      writeBigIntArrayAsJson(generator, (BigInteger[])value);
-    }
-    else if(value.getClass().equals(BigDecimal[].class))
-    {
-      writeBigDecimalArrayAsJson(generator, (BigDecimal[])value);
-    }
-    else if(value.getClass().equals(String[].class))
-    {
-      writeStringArrayAsJson(generator, (String[])value);
-    }else if (value.getClass().equals(Object[].class)) 
-    {
-      writeObjectArrayAsJson(generator, (Object[])value, pdxField);
-    } else{
-      throw new IllegalStateException("PdxInstance returns unknwon pdxfield " + pdxField + " for type " + value);
+  }
+
+  public static void writeArrayAsJson(JsonGenerator generator, Object value, String pdxField)
+      throws JsonGenerationException, IOException {
+
+    if (value.getClass().getName().equals("[Z")) {
+      writePrimitiveBoolArrayAsJson(generator, (boolean[]) value);
+    } else if (value.getClass().getName().equals("[B")) {
+      writePrimitiveByteArrayAsJson(generator, (byte[]) value);
+    } else if (value.getClass().getName().equals("[S")) {
+      writePrimitiveShortArrayAsJson(generator, (short[]) value);
+    } else if (value.getClass().getName().equals("[I")) {
+      writePrimitiveIntArrayAsJson(generator, (int[]) value);
+    } else if (value.getClass().getName().equals("[J")) {
+      writePrimitiveLongArrayAsJson(generator, (long[]) value);
+    } else if (value.getClass().getName().equals("[F")) {
+      writePrimitiveFloatArrayAsJson(generator, (float[]) value);
+    } else if (value.getClass().getName().equals("[D")) {
+      writePrimitiveDoubleArrayAsJson(generator, (double[]) value);
+    } else if (value.getClass().equals(Boolean[].class)) {
+      writeWrapperBoolArrayAsJson(generator, (Boolean[]) value);
+    } else if (value.getClass().equals(Byte[].class)) {
+      writeWrapperByteArrayAsJson(generator, (Byte[]) value);
+    } else if (value.getClass().equals(Short[].class)) {
+      writeWrapperShortArrayAsJson(generator, (Short[]) value);
+    } else if (value.getClass().equals(Integer[].class)) {
+      writeWrapperIntArrayAsJson(generator, (Integer[]) value);
+    } else if (value.getClass().equals(Long[].class)) {
+      writeWrapperLongArrayAsJson(generator, (Long[]) value);
+    } else if (value.getClass().equals(Float[].class)) {
+      writeWrapperFloatArrayAsJson(generator, (Float[]) value);
+    } else if (value.getClass().equals(Double[].class)) {
+      writeWrapperDoubleArrayAsJson(generator, (Double[]) value);
+    } else if (value.getClass().equals(BigInteger[].class)) {
+      writeBigIntArrayAsJson(generator, (BigInteger[]) value);
+    } else if (value.getClass().equals(BigDecimal[].class)) {
+      writeBigDecimalArrayAsJson(generator, (BigDecimal[]) value);
+    } else if (value.getClass().equals(String[].class)) {
+      writeStringArrayAsJson(generator, (String[]) value);
+    } else if (value.getClass().equals(Object[].class)) {
+      writeObjectArrayAsJson(generator, (Object[]) value, pdxField);
+    } else {
+      throw new IllegalStateException(
+          "PdxInstance returns unknwon pdxfield " + pdxField + " for type " + value);
- 
-  public static void writePrimitiveBoolArrayAsJson(JsonGenerator generator, boolean[] array) throws JsonGenerationException, IOException{
+
+  public static void writePrimitiveBoolArrayAsJson(JsonGenerator generator, boolean[] array)
+      throws JsonGenerationException, IOException {
-    for (boolean obj : array)
-    {
-      generator.writeBoolean(obj); 
+    for (boolean obj : array) {
+      generator.writeBoolean(obj);
-  
-  public static void writePrimitiveByteArrayAsJson(JsonGenerator generator, byte[] array) throws JsonGenerationException, IOException{
+
+  public static void writePrimitiveByteArrayAsJson(JsonGenerator generator, byte[] array)
+      throws JsonGenerationException, IOException {
-    for (byte obj : array)
-    {
-      generator.writeNumber(obj);   
+    for (byte obj : array) {
+      generator.writeNumber(obj);
-  
-  public static void writePrimitiveShortArrayAsJson(JsonGenerator generator, short[] array) throws JsonGenerationException, IOException{
+
+  public static void writePrimitiveShortArrayAsJson(JsonGenerator generator, short[] array)
+      throws JsonGenerationException, IOException {
-    for (short obj : array)
-    {
-      generator.writeNumber(obj);   
+    for (short obj : array) {
+      generator.writeNumber(obj);
-  
-  public static void writePrimitiveIntArrayAsJson(JsonGenerator generator, int[] array) throws JsonGenerationException, IOException{
+
+  public static void writePrimitiveIntArrayAsJson(JsonGenerator generator, int[] array)
+      throws JsonGenerationException, IOException {
-    for (int obj : array)
-    {
-      generator.writeNumber(obj);   
+    for (int obj : array) {
+      generator.writeNumber(obj);
-  
-  public static void writePrimitiveLongArrayAsJson(JsonGenerator generator, long[] array) throws JsonGenerationException, IOException{
+
+  public static void writePrimitiveLongArrayAsJson(JsonGenerator generator, long[] array)
+      throws JsonGenerationException, IOException {
-    for (long obj : array)
-    {
-      generator.writeNumber(obj);   
+    for (long obj : array) {
+      generator.writeNumber(obj);
-  
-  public static void writePrimitiveFloatArrayAsJson(JsonGenerator generator, float[] array) throws JsonGenerationException, IOException{
+
+  public static void writePrimitiveFloatArrayAsJson(JsonGenerator generator, float[] array)
+      throws JsonGenerationException, IOException {
-    for (float obj : array)
-    {
-      generator.writeNumber(obj);   
+    for (float obj : array) {
+      generator.writeNumber(obj);
-  
-  public static void writePrimitiveDoubleArrayAsJson(JsonGenerator generator, double[] array) throws JsonGenerationException, IOException{
+
+  public static void writePrimitiveDoubleArrayAsJson(JsonGenerator generator, double[] array)
+      throws JsonGenerationException, IOException {
-    for (double obj : array)
-    {
-      generator.writeNumber(obj);   
+    for (double obj : array) {
+      generator.writeNumber(obj);
-  
-  
-  public static void writeWrapperBoolArrayAsJson(JsonGenerator generator, Boolean[] array) throws JsonGenerationException, IOException{
+
+
+  public static void writeWrapperBoolArrayAsJson(JsonGenerator generator, Boolean[] array)
+      throws JsonGenerationException, IOException {
-    for (Boolean obj : array)
-    {
-      generator.writeBoolean(obj.booleanValue());   
+    for (Boolean obj : array) {
+      generator.writeBoolean(obj.booleanValue());
-  
-  public static void writeWrapperByteArrayAsJson(JsonGenerator generator, Byte[] array) throws JsonGenerationException, IOException{
+
+  public static void writeWrapperByteArrayAsJson(JsonGenerator generator, Byte[] array)
+      throws JsonGenerationException, IOException {
-    for (Byte obj : array)
-    {
-      generator.writeNumber(obj.byteValue());   
+    for (Byte obj : array) {
+      generator.writeNumber(obj.byteValue());
-  
-  public static void writeWrapperShortArrayAsJson(JsonGenerator generator, Short[] array) throws JsonGenerationException, IOException{
+
+  public static void writeWrapperShortArrayAsJson(JsonGenerator generator, Short[] array)
+      throws JsonGenerationException, IOException {
-    for (Short obj : array)
-    {
-      generator.writeNumber(obj.shortValue());   
+    for (Short obj : array) {
+      generator.writeNumber(obj.shortValue());
-  
-  public static void writeWrapperIntArrayAsJson(JsonGenerator generator, Integer[] array) throws JsonGenerationException, IOException{
+
+  public static void writeWrapperIntArrayAsJson(JsonGenerator generator, Integer[] array)
+      throws JsonGenerationException, IOException {
-    for (Integer obj : array)
-    {
-      generator.writeNumber(obj.intValue());   
+    for (Integer obj : array) {
+      generator.writeNumber(obj.intValue());
-  
-  public static void writeWrapperLongArrayAsJson(JsonGenerator generator, Long[] array) throws JsonGenerationException, IOException{
+
+  public static void writeWrapperLongArrayAsJson(JsonGenerator generator, Long[] array)
+      throws JsonGenerationException, IOException {
-    for (Long obj : array)
-    {
-      generator.writeNumber(obj.longValue());   
+    for (Long obj : array) {
+      generator.writeNumber(obj.longValue());
-  
-  public static void writeWrapperFloatArrayAsJson(JsonGenerator generator, Float[] array) throws JsonGenerationException, IOException{
+
+  public static void writeWrapperFloatArrayAsJson(JsonGenerator generator, Float[] array)
+      throws JsonGenerationException, IOException {
-    for (Float obj : array)
-    {
-      generator.writeNumber(obj.floatValue());   
+    for (Float obj : array) {
+      generator.writeNumber(obj.floatValue());
-  
-  public static void writeWrapperDoubleArrayAsJson(JsonGenerator generator, Double[] array) throws JsonGenerationException, IOException{
+
+  public static void writeWrapperDoubleArrayAsJson(JsonGenerator generator, Double[] array)
+      throws JsonGenerationException, IOException {
-    for (Double obj : array)
-    {
-      generator.writeNumber(obj.doubleValue());   
+    for (Double obj : array) {
+      generator.writeNumber(obj.doubleValue());
-  
-  public static void writeBigIntArrayAsJson(JsonGenerator generator, BigInteger[] array) throws JsonGenerationException, IOException{
+
+  public static void writeBigIntArrayAsJson(JsonGenerator generator, BigInteger[] array)
+      throws JsonGenerationException, IOException {
-    for (BigInteger obj : array)
-    {
-      generator.writeNumber(obj);   
+    for (BigInteger obj : array) {
+      generator.writeNumber(obj);
-  
-  public static void writeBigDecimalArrayAsJson(JsonGenerator generator, BigDecimal[] array) throws JsonGenerationException, IOException{
+
+  public static void writeBigDecimalArrayAsJson(JsonGenerator generator, BigDecimal[] array)
+      throws JsonGenerationException, IOException {
-    for (BigDecimal obj : array)
-    {
-      generator.writeNumber(obj);   
+    for (BigDecimal obj : array) {
+      generator.writeNumber(obj);
-  
-  public static void writeStringArrayAsJson(JsonGenerator generator, String[] array) throws JsonGenerationException, IOException{
+
+  public static void writeStringArrayAsJson(JsonGenerator generator, String[] array)
+      throws JsonGenerationException, IOException {
-    for (String obj : array)
-    {
-      generator.writeString(obj);   
+    for (String obj : array) {
+      generator.writeString(obj);
-  
-  public static void writeObjectArrayAsJson(JsonGenerator generator, Object[] array, String pdxField ) throws JsonGenerationException, IOException
-  {
+
+  public static void writeObjectArrayAsJson(JsonGenerator generator, Object[] array,
+      String pdxField) throws JsonGenerationException, IOException {
-  
-    if(ArrayUtils.isNotEmpty(array)) {
-      for (Object obj : array)
-      {
+
+    if (ArrayUtils.isNotEmpty(array)) {
+      for (Object obj : array) {
-      }  
+      }
-    
+
-  
-  public static void writeRegionDetailsAsJson(JsonGenerator generator, Region<?,?> region) throws JsonGenerationException, IOException {
+
+  public static void writeRegionDetailsAsJson(JsonGenerator generator, Region<?, ?> region)
+      throws JsonGenerationException, IOException {
-    
+
-    
+
-    
-    if(region.getAttributes().getDataPolicy() != null) {
+
+    if (region.getAttributes().getDataPolicy() != null) {
-    }else {
+    } else {
-    
+
-    if(region.getAttributes().getKeyConstraint() != null) {
+    if (region.getAttributes().getKeyConstraint() != null) {
-    }else {
+    } else {
-    
+
-    if(region.getAttributes().getValueConstraint() != null) {
+    if (region.getAttributes().getValueConstraint() != null) {
-    }else {
+    } else {
-    
+
-    
+
-  
-  public static void writeRegionSetAsJson(JsonGenerator generator, Set<Region<?, ?>> regions ) throws JsonGenerationException, IOException
-  {
+
+  public static void writeRegionSetAsJson(JsonGenerator generator, Set<Region<?, ?>> regions)
+      throws JsonGenerationException, IOException {
-  
-    if(!CollectionUtils.isEmpty(regions)) {
-     
+
+    if (!CollectionUtils.isEmpty(regions)) {
+
-      } 
-    }  
+      }
+    }
-  
-  public static void writeMapAsJson(JsonGenerator generator, Map map, String pdxField) throws JsonGenerationException, IOException{
-    
+
+  public static void writeMapAsJson(JsonGenerator generator, Map map, String pdxField)
+      throws JsonGenerationException, IOException {
+
-    
+
-    while(iter.hasNext()) {
+    while (iter.hasNext()) {
-      
-      //Iterate over Map and write key-value
-      generator.writeFieldName(entry.getKey().toString()); //write Key in a Map
-      writeValueAsJson(generator, entry.getValue(), pdxField); //write value in a Map
+
+      // Iterate over Map and write key-value
+      generator.writeFieldName(entry.getKey().toString()); // write Key in a Map
+      writeValueAsJson(generator, entry.getValue(), pdxField); // write value in a Map
-  
-  public static void writeValueAsJson (JsonGenerator generator, Object value, String pdxField) throws JsonGenerationException, IOException {
-      
-    if(value == null)
-    {      
+
+  public static void writeValueAsJson(JsonGenerator generator, Object value, String pdxField)
+      throws JsonGenerationException, IOException {
+
+    if (value == null) {
-    }
-    else if(value.getClass().equals(Boolean.class))
-    { 
-      boolean b = (Boolean)value;
-      generator.writeBoolean(b);  
-    }
-    else if(value.getClass().equals(Byte.class))
-    {  
-      Byte b = (Byte)value;
-      generator.writeNumber(b);  
-    }
-    else if(value.getClass().equals(Short.class))
-    { 
-      Short b = (Short)value;
-      generator.writeNumber(b);  
-    }
-    else if(value.getClass().equals(Integer.class))
-    { 
-      int i = (Integer)value;
+    } else if (value.getClass().equals(Boolean.class)) {
+      boolean b = (Boolean) value;
+      generator.writeBoolean(b);
+    } else if (value.getClass().equals(Byte.class)) {
+      Byte b = (Byte) value;
+      generator.writeNumber(b);
+    } else if (value.getClass().equals(Short.class)) {
+      Short b = (Short) value;
+      generator.writeNumber(b);
+    } else if (value.getClass().equals(Integer.class)) {
+      int i = (Integer) value;
-    }
-    else if(value.getClass().equals(Long.class))
-    { 
-      long i = (Long)value;
+    } else if (value.getClass().equals(Long.class)) {
+      long i = (Long) value;
-    }
-    else if(value.getClass().equals(BigInteger.class))
-    { 
-      BigInteger i = (BigInteger)value;
+    } else if (value.getClass().equals(BigInteger.class)) {
+      BigInteger i = (BigInteger) value;
-    }
-    else if(value.getClass().equals(Float.class))
-    {
-      float i = (Float)value;
+    } else if (value.getClass().equals(Float.class)) {
+      float i = (Float) value;
-    }
-    else if(value.getClass().equals(BigDecimal.class))
-    {
-      BigDecimal i = (BigDecimal)value;
+    } else if (value.getClass().equals(BigDecimal.class)) {
+      BigDecimal i = (BigDecimal) value;
-    }
-    else if(value.getClass().equals(Double.class))
-    { 
-      double d = (Double)value;
+    } else if (value.getClass().equals(Double.class)) {
+      double d = (Double) value;
-    }
-    else if(value.getClass().equals(String.class))
-    { 
-      String s = (String)value;
+    } else if (value.getClass().equals(String.class)) {
+      String s = (String) value;
-    }
-    else if(value.getClass().isArray()){ 
+    } else if (value.getClass().isArray()) {
-    }else if (value.getClass().equals(Link.class)) {
-     writeLinkAsJson(generator, (Link)value, pdxField);
-    }
-    else if(value.getClass().equals(Date.class)){
-      generator.writeObject((Date)value);
-    }
-    else if(value.getClass().equals(EnumInfo.class))
-    { 
+    } else if (value.getClass().equals(Link.class)) {
+      writeLinkAsJson(generator, (Link) value, pdxField);
+      // } else if (value.getClass().equals(Date.class)) {
+      // generator.writeObject((Date) value);
+    } else if (value.getClass().equals(EnumInfo.class)) {
-      try {
-        generator.writeString(((EnumInfo)value).getEnum().name());
-      } catch (ClassNotFoundException e) {
-        throw new IllegalStateException("PdxInstance returns unknwon pdxfield " + pdxField + " for type " + value);
-      }
-      */
+       * try { generator.writeString(((EnumInfo)value).getEnum().name()); } catch
+       * (ClassNotFoundException e) { throw new
+       * IllegalStateException("PdxInstance returns unknwon pdxfield " + pdxField + " for type " +
+       * value); }
+       */
-    }
-    else if(value.getClass().equals(PdxInstanceEnumInfo.class))
-    { 
+    } else if (value.getClass().equals(PdxInstanceEnumInfo.class)) {
-    }
-    else 
-    {
-      if(value instanceof Struct){
-        writeStructAsJson(generator, (StructImpl)value);
-      }
-      else if(value instanceof PdxInstance)
-      {
-        writePdxInstanceAsJson(generator, (PdxInstance)value);
-      }
-      else if(value instanceof Collection)
-      { 
-        writeCollectionAsJson(generator, (Collection<?>)value);
-      }
-      else if (value instanceof Map){ 
-        writeMapAsJson(generator, (Map)value, pdxField);
-      }
-      else
-      {
-        // TODO:: can value be a domain object...? As we have configured PdxInstance based storage,  
-        //        Throw GemfireRestException for value of type domain objects. 
-        
-        //TODO:Do we need to convert domain objects into the JSON using ObjectMapper. There is no gurantee that domain class is in classpath. 
-        /*
-        ObjectMapper mapper = new ObjectMapper();
-        mapper.setDateFormat(new SimpleDateFormat("MM/dd/yyyy"));
-        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
-        mapper.configure(com.fasterxml.jackson.core.JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);
-        mapper.writeValueAsString(value)
-        
-        Object classInstance = mapper.readValue(JSON, Class.forName(className));
-        */
-        throw new GemfireRestException("Requested data could not convert into REST format[JSON] " );
+    } else {
+      if (value instanceof Struct) {
+        writeStructAsJson(generator, (StructImpl) value);
+      } else if (value instanceof PdxInstance) {
+        writePdxInstanceAsJson(generator, (PdxInstance) value);
+      } else if (value instanceof Collection) {
+        writeCollectionAsJson(generator, (Collection<?>) value);
+      } else if (value instanceof Map) {
+        writeMapAsJson(generator, (Map) value, pdxField);
+      } else {
+        generator.writeObject(value);
-  } 
+  }

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV25 MOV27 MOV8 MOV32 MOV8 MOV32 MOV8 MOV32 MOV8 MOV32 MOV8 MOV32 MOV8 MOV32 MOV8 MOV32 MOV8 MOV32 MOV8 MOV32 MOV8 MOV32 MOV8 MOV32 MOV8 MOV32 MOV8 INS21 INS32 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL57 DEL32 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL42 DEL43 DEL45 DEL14 DEL53 DEL25
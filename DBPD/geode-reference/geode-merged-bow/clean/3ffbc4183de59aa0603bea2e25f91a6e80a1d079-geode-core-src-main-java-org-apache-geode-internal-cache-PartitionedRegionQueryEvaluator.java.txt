GEODE-6488: Migrating cancellation state to execution context (#3322)

This work solves two problems.  One is that the query cancellation task
reference in DefaultQuery could be overwritten and thus never removed
from monitoring upon successful completion of a query.  Second is that
once a query execution timed out once, the query object was in an
unusable state which is undesirable.

The solution is to attach the cancellation state to the execution
context rather than the query object, so that cancellation is associated
with each independent execution of a query rather than having
cancellation state that applies to the entire query object.
+  private final ExecutionContext executionContext;
-  public PartitionedRegionQueryEvaluator(InternalDistributedSystem sys, PartitionedRegion pr,
-      DefaultQuery query, Object[] parameters, SelectResults cumulativeResults,
-      Set<Integer> bucketsToQuery) {
+  public PartitionedRegionQueryEvaluator(final InternalDistributedSystem sys,
+      final PartitionedRegion pr,
+      final DefaultQuery query,
+      final ExecutionContext executionContext,
+      final Object[] parameters,
+      final SelectResults cumulativeResults,
+      final Set<Integer> bucketsToQuery) {
+    this.executionContext = executionContext;
-              .doTestHook(DefaultQuery.TestHook.SPOTS.PULL_OFF_PR_QUERY_TRACE_INFO, null);
+              .doTestHook(DefaultQuery.TestHook.SPOTS.PULL_OFF_PR_QUERY_TRACE_INFO, null, null);
-      if (!QueryMonitor.isLowMemory() && !this.query.isCanceled()) {
+      if (!QueryMonitor.isLowMemory() && !this.executionContext.isCanceled()) {
-          query.setQueryCanceledException(new QueryExecutionLowMemoryException(reason));
+          executionContext.setQueryCanceledException(new QueryExecutionLowMemoryException(reason));
-                + query.getQueryCanceledException());
+                + executionContext.getQueryCanceledException());
-    if (query.isCanceled()) {
-      throw query.getQueryCanceledException();
+    if (executionContext.isCanceled()) {
+      throw executionContext.getQueryCanceledException();
-          .doTestHook(DefaultQuery.TestHook.SPOTS.BEFORE_BUILD_CUMULATIVE_RESULT, null);
+          .doTestHook(DefaultQuery.TestHook.SPOTS.BEFORE_BUILD_CUMULATIVE_RESULT, null, null);
-            .doTestHook(DefaultQuery.TestHook.SPOTS.CREATE_PR_QUERY_TRACE_STRING, null);
+            .doTestHook(DefaultQuery.TestHook.SPOTS.CREATE_PR_QUERY_TRACE_STRING, null, null);
-      query.setQueryCanceledException(new QueryExecutionLowMemoryException(reason));
+      executionContext.setQueryCanceledException(new QueryExecutionLowMemoryException(reason));
-            .doTestHook(DefaultQuery.TestHook.SPOTS.BEFORE_THROW_QUERY_CANCELED_EXCEPTION, null);
+            .doTestHook(DefaultQuery.TestHook.SPOTS.BEFORE_THROW_QUERY_CANCELED_EXCEPTION, null,
+                null);
-      throw query.getQueryCanceledException();
-    } else if (query.isCanceled()) {
-      throw query.getQueryCanceledException();
+      throw executionContext.getQueryCanceledException();
+    } else if (executionContext.isCanceled()) {
+      throw executionContext.getQueryCanceledException();
-
-
-                    null);
+                    null, null);
-          query.setQueryCanceledException(new QueryExecutionLowMemoryException(reason));
+          executionContext.setQueryCanceledException(new QueryExecutionLowMemoryException(reason));

INS23 INS83 INS83 INS43 INS59 INS44 INS42 INS42 INS83 INS83 INS83 INS83 INS43 INS42 INS83 INS83 INS83 INS21 INS42 INS7 INS22 INS42 UPD42 INS52 INS42 UPD42 UPD42 INS33 UPD42 UPD42 UPD42 INS33 INS33 UPD42 UPD42 INS33 UPD42 INS33 UPD42
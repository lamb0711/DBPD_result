Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2010-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * one or more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
-import java.util.concurrent.CopyOnWriteArrayList;
+
+import org.apache.logging.log4j.Logger;
-import com.gemstone.gemfire.cache.AttributesFactory;
-import com.gemstone.gemfire.cache.FixedPartitionResolver;
+import com.gemstone.gemfire.cache.FixedPartitionAttributes;
-import com.gemstone.gemfire.cache.FixedPartitionAttributes;
-import com.gemstone.gemfire.internal.InternalDataSerializer;
-import com.gemstone.gemfire.internal.i18n.LocalizedStrings;
-
+import com.gemstone.gemfire.distributed.internal.InternalDistributedSystem;
+import com.gemstone.gemfire.internal.InternalDataSerializer;
+import com.gemstone.gemfire.internal.i18n.LocalizedStrings;
+import com.gemstone.gemfire.internal.offheap.OffHeapStorage;
+import com.gemstone.gemfire.internal.logging.LogService;
+import com.gemstone.gemfire.internal.logging.log4j.LocalizedMessage;
+  private static final Logger logger = LogService.getLogger();
+  
+  private static final int OFF_HEAP_LOCAL_MAX_MEMORY_PLACEHOLDER = 1;
-    
-  // transient ExpirationAttributes entryTimeToLiveExpiration = ExpirationAttributes.DEFAULT;
-
-  // transient ExpirationAttributes entryIdleTimeoutExpiration = ExpirationAttributes.DEFAULT;
+  
+  /*
+   * This is used to artificially set the amount of available off-heap memory
+   * when no distributed system is available. This value works the same way as
+   * specifying off-heap as a GemFire property, so "100m" = 100 megabytes,
+   * "100g" = 100 gigabytes, etc.
+   */
+  private static String testAvailableOffHeapMemory = null;
+  private transient boolean localMaxMemoryExists;
+  /** Used to determine how to calculate the default local max memory.
+   * This was made transient since we do not support p2p backwards compat changes to values stored in a region
+   * and our PR implementation stores this object in the internal PRRoot internal region.
+   */
+  private transient boolean offHeap = false;
+  private transient boolean hasOffHeap;
+  
+    this.localMaxMemoryExists = true;
+  public void setOffHeap(final boolean offHeap) {
+    this.offHeap = offHeap;
+    this.hasOffHeap = true;
+    if (this.offHeap && !this.hasLocalMaxMemory) {
+      this.localMaxMemory = computeOffHeapLocalMaxMemory();
+    }
+  }
+  
+  public boolean getOffHeap() {
+    return this.offHeap;
+  }
+  
+  /**
+   * Returns localMaxMemory that must not be a temporary placeholder for
+   * offHeapLocalMaxMemory if off-heap. This must return the true final value
+   * of localMaxMemory which requires the DistributedSystem to be created if
+   * off-heap. See bug #52003.
+   * 
+   * @throws IllegalStateException if off-heap and the actual value is not yet known (because the DistributedSystem has not yet been created)
+   * @see #getLocalMaxMemoryForValidation()
+   */
+    if (this.offHeap && !this.localMaxMemoryExists) {
+      int value = computeOffHeapLocalMaxMemory();
+      if (this.localMaxMemoryExists) { // real value now exists so set it and return
+        this.localMaxMemory = value;
+      }
+    }
+    checkLocalMaxMemoryExists();
+    return this.localMaxMemory;
+  }
+  /**
+   * @throws IllegalStateException if off-heap and the actual value is not yet known (because the DistributedSystem has not yet been created)
+   */
+  private void checkLocalMaxMemoryExists() {
+    if (this.offHeap && !this.localMaxMemoryExists) { // real value does NOT yet exist so throw IllegalStateException
+      throw new IllegalStateException("Attempting to use localMaxMemory for off-heap but value is not yet known (default value is equal to off-heap-memory-size)");
+    }
+  }
+  
+  /**
+   * Returns localMaxMemory for validation of attributes before Region is 
+   * created (possibly before DistributedSystem is created). Returned value may 
+   * be the temporary placeholder representing offHeapLocalMaxMemory which 
+   * cannot be calculated until the DistributedSystem is created. See bug 
+   * #52003.
+   * 
+   * @see #OFF_HEAP_LOCAL_MAX_MEMORY_PLACEHOLDER 
+   * @see #getLocalMaxMemory()
+   */
+  public int getLocalMaxMemoryForValidation() {
+    if (this.offHeap && !this.hasLocalMaxMemory && !this.localMaxMemoryExists) {
+      int value = computeOffHeapLocalMaxMemory();
+      if (this.localMaxMemoryExists) { // real value now exists so set it and return
+        this.localMaxMemory = value;
+      }
+    }
-    public String toString()
-    {
-      StringBuffer s = new StringBuffer();
-      return s.append("PartitionAttributes@")
-        .append(System.identityHashCode(this))
-        .append("[redundantCopies=").append(getRedundantCopies())
-        .append(";localMaxMemory=").append(this.localMaxMemory)
-        .append(";totalMaxMemory=").append(this.totalMaxMemory)
-        .append(";totalNumBuckets=").append(this.totalNumBuckets)
-        .append(";partitionResolver=").append(this.partitionResolver)
-        .append(";colocatedWith=").append(this.colocatedRegionName)
-        .append(";recoveryDelay=").append(this.recoveryDelay)
-        .append(";startupRecoveryDelay=").append(this.startupRecoveryDelay)
-        .append(";FixedPartitionAttributes=").append(this.fixedPAttrs)
-        .append(";partitionListeners=").append(this.partitionListeners)
-        .append("]") .toString();
+  public String toString()
+  {
+    StringBuffer s = new StringBuffer();
+    return s.append("PartitionAttributes@")
+      .append(System.identityHashCode(this))
+      .append("[redundantCopies=").append(getRedundantCopies())
+      .append(";localMaxMemory=").append(getLocalMaxMemory())
+      .append(";totalMaxMemory=").append(this.totalMaxMemory)
+      .append(";totalNumBuckets=").append(this.totalNumBuckets)
+      .append(";partitionResolver=").append(this.partitionResolver)
+      .append(";colocatedWith=").append(this.colocatedRegionName)
+      .append(";recoveryDelay=").append(this.recoveryDelay)
+      .append(";startupRecoveryDelay=").append(this.startupRecoveryDelay)
+      .append(";FixedPartitionAttributes=").append(this.fixedPAttrs)
+      .append(";partitionListeners=").append(this.partitionListeners)
+      .append("]") .toString();
-    public void toData(DataOutput out) throws IOException {
-      out.writeInt(this.redundancy);
-      out.writeLong(this.totalMaxMemory);
-      out.writeInt(this.localMaxMemory);
-      out.writeInt(this.totalNumBuckets);
-      DataSerializer.writeString(this.colocatedRegionName, out);
-      DataSerializer.writeObject(this.localProperties, out);
-      DataSerializer.writeObject(this.globalProperties, out);
-      out.writeLong(this.recoveryDelay);
-      out.writeLong(this.startupRecoveryDelay);
-      DataSerializer.writeObject(this.fixedPAttrs, out);
-    }
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException {
-      this.redundancy = in.readInt();
-      this.totalMaxMemory = in.readLong();
-      this.localMaxMemory = in.readInt();
-      this.totalNumBuckets = in.readInt();
-      this.colocatedRegionName = DataSerializer.readString(in);
-      this.localProperties = (Properties)DataSerializer.readObject(in);
-      this.globalProperties = (Properties)DataSerializer.readObject(in);
-      this.recoveryDelay = in.readLong();
-      this.startupRecoveryDelay = in.readLong();
-      this.fixedPAttrs = DataSerializer.readObject(in);
-    }
+  /**
+   * @throws IllegalStateException if off-heap and the actual value is not yet known (because the DistributedSystem has not yet been created)
+   */
+  public void toData(DataOutput out) throws IOException {
+    checkLocalMaxMemoryExists();
+    out.writeInt(this.redundancy);
+    out.writeLong(this.totalMaxMemory);
+    out.writeInt(getLocalMaxMemory()); // call the gettor to force it to be computed in the offheap case
+    out.writeInt(this.totalNumBuckets);
+    DataSerializer.writeString(this.colocatedRegionName, out);
+    DataSerializer.writeObject(this.localProperties, out);
+    DataSerializer.writeObject(this.globalProperties, out);
+    out.writeLong(this.recoveryDelay);
+    out.writeLong(this.startupRecoveryDelay);
+    DataSerializer.writeObject(this.fixedPAttrs, out);
+  }
+  
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
+    this.redundancy = in.readInt();
+    this.totalMaxMemory = in.readLong();
+    this.localMaxMemory = in.readInt();
+    this.totalNumBuckets = in.readInt();
+    this.colocatedRegionName = DataSerializer.readString(in);
+    this.localProperties = (Properties)DataSerializer.readObject(in);
+    this.globalProperties = (Properties)DataSerializer.readObject(in);
+    this.recoveryDelay = in.readLong();
+    this.startupRecoveryDelay = in.readLong();
+    this.fixedPAttrs = DataSerializer.readObject(in);
+  }
-    public boolean equals(final Object obj) {
-      if (this == obj) { 
-        return true;
-      }
-      
-    if (! (obj instanceof PartitionAttributesImpl)) {
-      return false;
+  public boolean equals(final Object obj) {
+    if (this == obj) { 
+      return true;
-      
-    PartitionAttributesImpl other = (PartitionAttributesImpl) obj;
-      
-      if (this.redundancy != other.getRedundantCopies()
-          || this.localMaxMemory != other.getLocalMaxMemory()
-          || this.totalNumBuckets != other.getTotalNumBuckets()
-          || this.totalMaxMemory != other.getTotalMaxMemory()
-          || this.startupRecoveryDelay != other.getStartupRecoveryDelay()
-          || this.recoveryDelay != other.getRecoveryDelay()
+    
+  if (! (obj instanceof PartitionAttributesImpl)) {
+    return false;
+  }
+    
+  PartitionAttributesImpl other = (PartitionAttributesImpl) obj;
+    
+    if (this.redundancy != other.getRedundantCopies()
+        || getLocalMaxMemory() != other.getLocalMaxMemory()
+        || this.offHeap != other.getOffHeap()
+        || this.totalNumBuckets != other.getTotalNumBuckets()
+        || this.totalMaxMemory != other.getTotalMaxMemory()
+        || this.startupRecoveryDelay != other.getStartupRecoveryDelay()
+        || this.recoveryDelay != other.getRecoveryDelay()
-          || ((this.partitionResolver == null) != (other.getPartitionResolver() == null))
-          || (this.partitionResolver != null && !this.partitionResolver
-            .equals(other.getPartitionResolver()))
-          || ((this.colocatedRegionName == null) != (other.getColocatedWith() == null))
-          || (this.colocatedRegionName != null && !this.colocatedRegionName
-            .equals(other.getColocatedWith()))
-          ||((this.fixedPAttrs == null) != (other.getFixedPartitionAttributes()== null))
-          ||(this.fixedPAttrs != null && !this.fixedPAttrs.equals(other.getFixedPartitionAttributes()))
-          ) {
-        //throw new RuntimeException("this="+this.toString() + "   other=" + other.toString());
-        return false;
-        
+        || ((this.partitionResolver == null) != (other.getPartitionResolver() == null))
+        || (this.partitionResolver != null && !this.partitionResolver
+          .equals(other.getPartitionResolver()))
+        || ((this.colocatedRegionName == null) != (other.getColocatedWith() == null))
+        || (this.colocatedRegionName != null && !this.colocatedRegionName
+          .equals(other.getColocatedWith()))
+        ||((this.fixedPAttrs == null) != (other.getFixedPartitionAttributes()== null))
+        ||(this.fixedPAttrs != null && !this.fixedPAttrs.equals(other.getFixedPartitionAttributes()))
+        ) {
+      //throw new RuntimeException("this="+this.toString() + "   other=" + other.toString());
+      return false;
+    if (pa.hasOffHeap) {
+      setOffHeap(pa.getOffHeap());
+    }
-
-    @SuppressWarnings("unchecked")
-    public void setAll(@SuppressWarnings("rawtypes") PartitionAttributes pa) {
-      setRedundantCopies(pa.getRedundantCopies());
-      setLocalProperties(pa.getLocalProperties());
-      setGlobalProperties(pa.getGlobalProperties());
-      setLocalMaxMemory(pa.getLocalMaxMemory());
-      setTotalMaxMemory(pa.getTotalMaxMemory());
-      setTotalNumBuckets(pa.getTotalNumBuckets());
-      setPartitionResolver(pa.getPartitionResolver());
-      setColocatedWith(pa.getColocatedWith());
-      setRecoveryDelay(pa.getRecoveryDelay());
-      setStartupRecoveryDelay(pa.getStartupRecoveryDelay());
-      addFixedPartitionAttributes(pa.getFixedPartitionAttributes());
-    }
+  @SuppressWarnings("unchecked")
+  public void setAll(@SuppressWarnings("rawtypes")
+  PartitionAttributes pa) {
+    setRedundantCopies(pa.getRedundantCopies());
+    setLocalProperties(pa.getLocalProperties());
+    setGlobalProperties(pa.getGlobalProperties());
+    setLocalMaxMemory(pa.getLocalMaxMemory());
+    setTotalMaxMemory(pa.getTotalMaxMemory());
+    setTotalNumBuckets(pa.getTotalNumBuckets());
+    setPartitionResolver(pa.getPartitionResolver());
+    setColocatedWith(pa.getColocatedWith());
+    setRecoveryDelay(pa.getRecoveryDelay());
+    setStartupRecoveryDelay(pa.getStartupRecoveryDelay());
+    setOffHeap(((PartitionAttributesImpl) pa).getOffHeap());
+    addFixedPartitionAttributes(pa.getFixedPartitionAttributes());
+  
+  /**
+   * Only used for testing. Sets the amount of available off-heap memory when no
+   * distributed system is available. This method must be called before any
+   * instances of PartitionAttributesImpl are created. Specify the value the
+   * same way the off-heap memory property is specified. So, "100m" = 100
+   * megabytes, etc.
+   * 
+   * @param newTestAvailableOffHeapMemory The new test value for available
+   * off-heap memory.
+   */
+  public static void setTestAvailableOffHeapMemory(final String newTestAvailableOffHeapMemory) {
+    testAvailableOffHeapMemory = newTestAvailableOffHeapMemory;
+  }
+  
+  /**
+   * By default the partition can use up to 100% of the allocated off-heap
+   * memory.
+   */
+  private int computeOffHeapLocalMaxMemory() {
+    
+    long availableOffHeapMemoryInMB = 0;
+    if (testAvailableOffHeapMemory != null) {
+      availableOffHeapMemoryInMB = OffHeapStorage.parseOffHeapMemorySize(testAvailableOffHeapMemory) / (1024 * 1024);
+    } else if (InternalDistributedSystem.getAnyInstance() == null) {
+      this.localMaxMemoryExists = false;
+      return OFF_HEAP_LOCAL_MAX_MEMORY_PLACEHOLDER; // fix 52033: return non-negative, non-zero temporary placeholder for offHeapLocalMaxMemory
+    } else {
+      String offHeapSizeConfigValue = InternalDistributedSystem.getAnyInstance().getOriginalConfig().getOffHeapMemorySize();
+      availableOffHeapMemoryInMB = OffHeapStorage.parseOffHeapMemorySize(offHeapSizeConfigValue) / (1024 * 1024);
+    }
+    
+    if (availableOffHeapMemoryInMB > Integer.MAX_VALUE) {
+      logger.warn(LocalizedMessage.create(LocalizedStrings.PartitionAttributesImpl_REDUCED_LOCAL_MAX_MEMORY_FOR_PARTITION_ATTRIBUTES_WHEN_SETTING_FROM_AVAILABLE_OFF_HEAP_MEMORY_SIZE));
+      return Integer.MAX_VALUE;
+    }
+    
+    this.localMaxMemoryExists = true;
+    return (int) availableOffHeapMemoryInMB;
+  }
+  
+  public int getLocalMaxMemoryDefault() {
+    if (!this.offHeap) {
+      return PartitionAttributesFactory.LOCAL_MAX_MEMORY_DEFAULT;
+    }
+    
+    return computeOffHeapLocalMaxMemory();
+  }
+}

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS40 UPD40 UPD40 UPD40 INS40 INS23 INS23 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS43 INS59 INS83 INS83 INS39 INS59 INS29 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS8 INS29 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS8 INS29 INS29 INS83 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS42 INS42 INS32 INS42 INS34 INS42 INS42 INS33 INS42 INS65 INS42 INS9 INS42 INS21 INS83 INS39 INS42 INS21 INS21 INS25 INS41 INS65 INS65 INS65 INS25 INS21 INS41 INS65 INS25 INS65 INS65 INS65 INS25 MOV41 INS65 INS21 INS21 INS25 INS21 INS65 INS65 INS83 INS43 INS42 INS21 INS65 INS60 INS25 INS25 INS21 INS41 INS25 INS41 INS42 INS42 INS66 INS66 INS66 INS7 INS7 INS7 INS27 INS8 INS22 INS66 INS66 INS66 INS66 INS42 INS66 INS68 INS27 INS8 INS32 INS22 INS42 INS66 INS27 INS8 INS66 INS66 INS66 INS66 INS66 INS67 INS66 INS68 INS27 INS8 INS42 INS66 INS32 INS32 INS40 INS8 INS32 INS66 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS42 INS7 INS66 INS66 INS39 INS59 INS27 INS8 INS25 INS27 INS8 INS7 INS11 INS38 INS8 INS32 INS22 INS9 INS22 INS42 INS22 INS9 INS22 INS38 MOV21 INS52 INS42 INS42 INS22 INS38 INS60 INS25 INS42 INS52 INS42 INS22 INS38 INS53 INS42 INS42 INS22 INS38 INS38 INS60 INS25 INS42 INS42 INS42 INS32 INS21 INS42 INS32 INS42 INS42 INS42 INS34 INS42 INS33 INS21 INS27 INS8 INS8 INS42 INS40 INS21 INS41 INS22 INS9 INS39 INS42 INS22 INS41 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS7 INS52 INS42 INS22 INS39 INS59 INS22 INS8 INS52 INS42 INS22 INS14 INS52 INS42 INS22 INS22 INS39 INS59 INS22 INS8 INS42 INS32 INS36 INS42 INS7 INS32 INS33 INS21 INS41 INS60 INS21 INS32 INS40 INS52 INS42 INS52 INS42 INS40 INS52 INS42 MOV22 INS32 INS52 INS42 INS42 INS32 INS52 INS42 INS21 INS52 INS42 INS43 INS45 INS52 INS42 INS52 INS42 INS42 INS32 INS52 INS42 INS21 INS42 INS32 INS11 INS42 INS27 INS42 INS42 INS7 INS42 INS43 INS59 INS7 INS42 INS42 INS32 UPD42 MOV42 INS42 INS7 INS42 INS42 INS7 INS42 INS42 INS43 INS42 INS32 INS36 INS22 INS9 INS42 INS42 INS32 INS42 INS27 INS42 INS42 INS40 MOV22 INS42 MOV22 INS42 INS42 INS42 INS42 INS42 INS27 INS52 INS42 INS32 INS42 INS32 INS36 INS34 INS34 INS32 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS34 INS34 INS27 MOV27 INS27 INS22 INS32 INS32 INS52 INS42 INS42 INS42 INS42 INS32 INS42 DEL42 DEL32 DEL8
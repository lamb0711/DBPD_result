GEODE-6295: Use InternalCacheBuilder for constructing GemFireCacheImpl (#3260)

All code (product and tests) now use InternalCacheBuilder to construct
instances of GemFireCacheImpl.

-import static org.apache.geode.distributed.internal.InternalDistributedSystem.ALLOW_MULTIPLE_SYSTEMS;
-
-import org.apache.geode.distributed.internal.InternalDistributedSystem;
-import org.apache.geode.distributed.internal.SecurityConfig;
-import org.apache.geode.internal.cache.CacheConfig;
-import org.apache.geode.internal.cache.GemFireCacheImpl;
-import org.apache.geode.internal.cache.InternalCache;
-import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.CacheFactoryStatics;
+import org.apache.geode.internal.cache.InternalCacheBuilder;
-import org.apache.geode.security.GemFireSecurityException;
- * GemFire as a client it should use {@link org.apache.geode.cache.client.ClientCacheFactory}
- * instead.
+ * GemFire as a client it should use {@link ClientCacheFactory} instead.
-  private final Properties dsProps;
-
-  private final CacheConfig cacheConfig = new CacheConfig();
+  private final InternalCacheBuilder internalCacheBuilder;
-    if (props == null) {
-      props = new Properties();
-    }
-    this.dsProps = props;
+    internalCacheBuilder = new InternalCacheBuilder(props);
+  }
+
+  /**
+   * Creates a new cache that uses the configured distributed system. If a connected distributed
+   * system already exists it will be used if it is compatible with the properties on this factory.
+   * Otherwise a a distributed system will be created with the configured properties. If a cache
+   * already exists it will be returned.
+   * <p>
+   * If the cache does need to be created it will also be initialized from cache.xml if it exists.
+   *
+   * @return the created or already existing singleton cache
+   *
+   * @throws CacheXmlException If a problem occurs while parsing the declarative caching XML file.
+   * @throws TimeoutException If a {@link Region#put(Object, Object)} times out while initializing
+   *         the cache.
+   * @throws CacheWriterException If a {@code CacheWriterException} is thrown while initializing the
+   *         cache.
+   * @throws GatewayException If a {@code GatewayException} is thrown while initializing the cache.
+   * @throws RegionExistsException If the declarative caching XML file describes a region that
+   *         already exists (including the root region).
+   * @throws IllegalStateException if cache already exists and is not compatible with the new
+   *         configuration.
+   * @throws AuthenticationFailedException if authentication fails.
+   * @throws AuthenticationRequiredException if the distributed system is in secure mode and this
+   *         new member is not configured with security credentials.
+   * @since GemFire 6.5
+   */
+  public Cache create()
+      throws TimeoutException, CacheWriterException, GatewayException, RegionExistsException {
+    return internalCacheBuilder.create();
-    this.dsProps.setProperty(name, value);
+    internalCacheBuilder.set(name, value);
+    return this;
+  }
+
+  /**
+   * Sets the object preference to PdxInstance type. When a cached object that was serialized as a
+   * PDX is read from the cache a {@link PdxInstance} will be returned instead of the actual domain
+   * class. The PdxInstance is an interface that provides run time access to the fields of a PDX
+   * without deserializing the entire PDX. The PdxInstance implementation is a light weight wrapper
+   * that simply refers to the raw bytes of the PDX that are kept in the cache. Using this method
+   * applications can choose to access PdxInstance instead of Java object.
+   * <p>
+   * Note that a PdxInstance is only returned if a serialized PDX is found in the cache. If the
+   * cache contains a deserialized PDX, then a domain class instance is returned instead of a
+   * PdxInstance.
+   *
+   * @param readSerialized true to prefer PdxInstance
+   * @return this CacheFactory
+   * @since GemFire 6.6
+   * @see org.apache.geode.pdx.PdxInstance
+   */
+  public CacheFactory setPdxReadSerialized(boolean readSerialized) {
+    internalCacheBuilder.setPdxReadSerialized(readSerialized);
+    return this;
+  }
+
+  /**
+   * Sets the securityManager for the cache. If this securityManager is set, it will override the
+   * security-manager property you set in your gemfire system properties.
+   *
+   * This is provided mostly for container to inject an already initialized securityManager. An
+   * object provided this way is expected to be initialized already. We are not calling the init
+   * method on this object
+   *
+   * @return this CacheFactory
+   */
+  public CacheFactory setSecurityManager(SecurityManager securityManager) {
+    internalCacheBuilder.setSecurityManager(securityManager);
+    return this;
+  }
+
+  /**
+   * Sets the postProcessor for the cache. If this postProcessor is set, it will override the
+   * security-post-processor setting in the gemfire system properties.
+   *
+   * This is provided mostly for container to inject an already initialized post processor. An
+   * object provided this way is expected to be initialized already. We are not calling the init
+   * method on this object
+   *
+   * @return this CacheFactory
+   */
+  public CacheFactory setPostProcessor(PostProcessor postProcessor) {
+    internalCacheBuilder.setPostProcessor(postProcessor);
+    return this;
+  }
+
+  /**
+   * Set the PDX serializer for the cache. If this serializer is set, it will be consulted to see if
+   * it can serialize any domain classes which are added to the cache in portable data exchange
+   * format.
+   *
+   * @param serializer the serializer to use
+   * @return this CacheFactory
+   * @since GemFire 6.6
+   * @see PdxSerializer
+   */
+  public CacheFactory setPdxSerializer(PdxSerializer serializer) {
+    internalCacheBuilder.setPdxSerializer(serializer);
+    return this;
+  }
+
+  /**
+   * Set the disk store that is used for PDX meta data. When serializing objects in the PDX format,
+   * the type definitions are persisted to disk. This setting controls which disk store is used for
+   * that persistence.
+   *
+   * If not set, the metadata will go in the default disk store.
+   *
+   * @param diskStoreName the name of the disk store to use for the PDX metadata.
+   * @return this CacheFactory
+   * @since GemFire 6.6
+   */
+  public CacheFactory setPdxDiskStore(String diskStoreName) {
+    internalCacheBuilder.setPdxDiskStore(diskStoreName);
+    return this;
+  }
+
+  /**
+   * Control whether the type metadata for PDX objects is persisted to disk. The default for this
+   * setting is false. If you are using persistent regions with PDX then you must set this to true.
+   * If you are using a {@code GatewaySender} or {@code AsyncEventQueue} with PDX then you should
+   * set this to true.
+   *
+   * @param isPersistent true if the metadata should be persistent
+   * @return this CacheFactory
+   * @since GemFire 6.6
+   */
+  public CacheFactory setPdxPersistent(boolean isPersistent) {
+    internalCacheBuilder.setPdxPersistent(isPersistent);
+    return this;
+  }
+
+  /**
+   * Control whether pdx ignores fields that were unread during deserialization. The default is to
+   * preserve unread fields be including their data during serialization. But if you configure the
+   * cache to ignore unread fields then their data will be lost during serialization.
+   * <P>
+   * You should only set this attribute to {@code true} if you know this member will only be reading
+   * cache data. In this use case you do not need to pay the cost of preserving the unread fields
+   * since you will never be reserializing pdx data.
+   *
+   * @param ignore {@code true} if fields not read during pdx deserialization should be ignored;
+   *        {@code false}, the default, if they should be preserved.
+   * @return this CacheFactory
+   * @since GemFire 6.6
+   */
+  public CacheFactory setPdxIgnoreUnreadFields(boolean ignore) {
+    internalCacheBuilder.setPdxIgnoreUnreadFields(ignore);
-  public static synchronized Cache create(DistributedSystem system) throws CacheExistsException,
+  public static Cache create(DistributedSystem system) throws CacheExistsException,
-    return create(system, false, new CacheConfig());
-  }
-
-  private static synchronized Cache create(DistributedSystem system, boolean existingOk,
-      CacheConfig cacheConfig) throws CacheExistsException, TimeoutException, CacheWriterException,
-      GatewayException, RegionExistsException {
-    // Moved code in this method to GemFireCacheImpl.create
-    return GemFireCacheImpl.create((InternalDistributedSystem) system, existingOk, cacheConfig);
-  }
-
-  /**
-   * Creates a new cache that uses the configured distributed system. If a connected distributed
-   * system already exists it will be used if it is compatible with the properties on this factory.
-   * Otherwise a a distributed system will be created with the configured properties. If a cache
-   * already exists it will be returned.
-   * <p>
-   * If the cache does need to be created it will also be initialized from cache.xml if it exists.
-   *
-   * @return the created or already existing singleton cache
-   *
-   * @throws CacheXmlException If a problem occurs while parsing the declarative caching XML file.
-   * @throws TimeoutException If a {@link Region#put(Object, Object)} times out while initializing
-   *         the cache.
-   * @throws CacheWriterException If a {@code CacheWriterException} is thrown while initializing the
-   *         cache.
-   * @throws GatewayException If a {@code GatewayException} is thrown while initializing the cache.
-   * @throws RegionExistsException If the declarative caching XML file describes a region that
-   *         already exists (including the root region).
-   * @throws IllegalStateException if cache already exists and is not compatible with the new
-   *         configuration.
-   * @throws AuthenticationFailedException if authentication fails.
-   * @throws AuthenticationRequiredException if the distributed system is in secure mode and this
-   *         new member is not configured with security credentials.
-   * @since GemFire 6.5
-   */
-  public Cache create()
-      throws TimeoutException, CacheWriterException, GatewayException, RegionExistsException {
-    synchronized (CacheFactory.class) {
-      DistributedSystem ds = null;
-      if (this.dsProps.isEmpty() && !ALLOW_MULTIPLE_SYSTEMS) {
-        // any ds will do
-        ds = InternalDistributedSystem.getConnectedInstance();
-        validateUsabilityOfSecurityCallbacks(ds);
-      }
-      if (ds == null) {
-        ds = InternalDistributedSystem.connectInternal(dsProps, new SecurityConfig(
-            this.cacheConfig.getSecurityManager(),
-            this.cacheConfig.getPostProcessor()));
-      }
-      return create(ds, true, this.cacheConfig);
-    }
-  }
-
-  /**
-   * Throws GemFireSecurityException if existing DistributedSystem connection cannot use specified
-   * SecurityManager or PostProcessor.
-   */
-  private void validateUsabilityOfSecurityCallbacks(DistributedSystem ds)
-      throws GemFireSecurityException {
-    if (ds == null) {
-      return;
-    }
-    // pre-existing DistributedSystem already has an incompatible SecurityService in use
-    if (this.cacheConfig.getSecurityManager() != null) {
-      // invalid configuration
-      throw new GemFireSecurityException(
-          "Existing DistributedSystem connection cannot use specified SecurityManager");
-    }
-    if (this.cacheConfig.getPostProcessor() != null) {
-      // invalid configuration
-      throw new GemFireSecurityException(
-          "Existing DistributedSystem connection cannot use specified PostProcessor");
-    }
+    return CacheFactoryStatics.create(system);
-    return basicGetInstance(system, false);
+    return CacheFactoryStatics.getInstance(system);
-    return basicGetInstance(system, true);
-  }
-
-  private static Cache basicGetInstance(DistributedSystem system, boolean closeOk) {
-    // Avoid synchronization if this is an initialization thread to avoid
-    // deadlock when messaging returns to this VM
-    final int initReq = LocalRegion.threadInitLevelRequirement();
-    if (initReq == LocalRegion.ANY_INIT || initReq == LocalRegion.BEFORE_INITIAL_IMAGE) { // fix bug
-                                                                                          // 33471
-      return basicGetInstancePart2(system, closeOk);
-    } else {
-      synchronized (CacheFactory.class) {
-        return basicGetInstancePart2(system, closeOk);
-      }
-    }
-  }
-
-  private static Cache basicGetInstancePart2(DistributedSystem system, boolean closeOk) {
-    InternalCache instance = GemFireCacheImpl.getInstance();
-    if (instance == null) {
-      throw new CacheClosedException(
-          "A cache has not yet been created.");
-    } else {
-      if (instance.isClosed() && !closeOk) {
-        throw instance.getCacheClosedException(
-            "The cache has been closed.", null);
-      }
-      if (!instance.getDistributedSystem().equals(system)) {
-        throw instance.getCacheClosedException(
-            "A cache has not yet been created for the given distributed system.");
-      }
-      return instance;
-    }
+    return CacheFactoryStatics.getInstanceCloseOk(system);
-  public static synchronized Cache getAnyInstance() {
-    InternalCache instance = GemFireCacheImpl.getInstance();
-    if (instance == null) {
-      throw new CacheClosedException(
-          "A cache has not yet been created.");
-    } else {
-      instance.getCancelCriterion().checkCancelInProgress(null);
-      return instance;
-    }
+  public static Cache getAnyInstance() {
+    return CacheFactoryStatics.getAnyInstance();
-
-  /**
-   * Sets the object preference to PdxInstance type. When a cached object that was serialized as a
-   * PDX is read from the cache a {@link PdxInstance} will be returned instead of the actual domain
-   * class. The PdxInstance is an interface that provides run time access to the fields of a PDX
-   * without deserializing the entire PDX. The PdxInstance implementation is a light weight wrapper
-   * that simply refers to the raw bytes of the PDX that are kept in the cache. Using this method
-   * applications can choose to access PdxInstance instead of Java object.
-   * <p>
-   * Note that a PdxInstance is only returned if a serialized PDX is found in the cache. If the
-   * cache contains a deserialized PDX, then a domain class instance is returned instead of a
-   * PdxInstance.
-   *
-   * @param readSerialized true to prefer PdxInstance
-   * @return this CacheFactory
-   * @since GemFire 6.6
-   * @see org.apache.geode.pdx.PdxInstance
-   */
-  public CacheFactory setPdxReadSerialized(boolean readSerialized) {
-    this.cacheConfig.setPdxReadSerialized(readSerialized);
-    return this;
-  }
-
-  /**
-   * Sets the securityManager for the cache. If this securityManager is set, it will override the
-   * security-manager property you set in your gemfire system properties.
-   *
-   * This is provided mostly for container to inject an already initialized securityManager. An
-   * object provided this way is expected to be initialized already. We are not calling the init
-   * method on this object
-   *
-   * @return this CacheFactory
-   */
-  public CacheFactory setSecurityManager(SecurityManager securityManager) {
-    this.cacheConfig.setSecurityManager(securityManager);
-    return this;
-  }
-
-  /**
-   * Sets the postProcessor for the cache. If this postProcessor is set, it will override the
-   * security-post-processor setting in the gemfire system properties.
-   *
-   * This is provided mostly for container to inject an already initialized post processor. An
-   * object provided this way is expected to be initialized already. We are not calling the init
-   * method on this object
-   *
-   * @return this CacheFactory
-   */
-  public CacheFactory setPostProcessor(PostProcessor postProcessor) {
-    this.cacheConfig.setPostProcessor(postProcessor);
-    return this;
-  }
-
-  /**
-   * Set the PDX serializer for the cache. If this serializer is set, it will be consulted to see if
-   * it can serialize any domain classes which are added to the cache in portable data exchange
-   * format.
-   *
-   * @param serializer the serializer to use
-   * @return this CacheFactory
-   * @since GemFire 6.6
-   * @see PdxSerializer
-   */
-  public CacheFactory setPdxSerializer(PdxSerializer serializer) {
-    this.cacheConfig.setPdxSerializer(serializer);
-    return this;
-  }
-
-  /**
-   * Set the disk store that is used for PDX meta data. When serializing objects in the PDX format,
-   * the type definitions are persisted to disk. This setting controls which disk store is used for
-   * that persistence.
-   *
-   * If not set, the metadata will go in the default disk store.
-   *
-   * @param diskStoreName the name of the disk store to use for the PDX metadata.
-   * @return this CacheFactory
-   * @since GemFire 6.6
-   */
-  public CacheFactory setPdxDiskStore(String diskStoreName) {
-    this.cacheConfig.setPdxDiskStore(diskStoreName);
-    return this;
-  }
-
-  /**
-   * Control whether the type metadata for PDX objects is persisted to disk. The default for this
-   * setting is false. If you are using persistent regions with PDX then you must set this to true.
-   * If you are using a {@code GatewaySender} or {@code AsyncEventQueue} with PDX then you should
-   * set this to true.
-   *
-   * @param isPersistent true if the metadata should be persistent
-   * @return this CacheFactory
-   * @since GemFire 6.6
-   */
-  public CacheFactory setPdxPersistent(boolean isPersistent) {
-    this.cacheConfig.setPdxPersistent(isPersistent);
-    return this;
-  }
-
-  /**
-   * Control whether pdx ignores fields that were unread during deserialization. The default is to
-   * preserve unread fields be including their data during serialization. But if you configure the
-   * cache to ignore unread fields then their data will be lost during serialization.
-   * <P>
-   * You should only set this attribute to {@code true} if you know this member will only be reading
-   * cache data. In this use case you do not need to pay the cost of preserving the unread fields
-   * since you will never be reserializing pdx data.
-   *
-   * @param ignore {@code true} if fields not read during pdx deserialization should be ignored;
-   *        {@code false}, the default, if they should be preserved.
-   * @return this CacheFactory
-   * @since GemFire 6.6
-   */
-  public CacheFactory setPdxIgnoreUnreadFields(boolean ignore) {
-    this.cacheConfig.setPdxIgnoreUnreadFields(ignore);
-    return this;
-  }

MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 UPD40 UPD40 INS23 MOV83 MOV83 INS43 INS59 INS8 INS8 UPD66 UPD42 MOV42 INS42 MOV21 MOV41 MOV41 MOV41 MOV41 MOV41 MOV41 MOV41 INS41 INS42 INS32 UPD42 UPD42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD43 INS42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL23 DEL42 DEL33 DEL27 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL9 DEL52 DEL42 DEL22 DEL42 DEL43 DEL57 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL38 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL32 DEL52 DEL42 DEL22 DEL42 DEL32 DEL14 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL51 DEL8 DEL52 DEL42 DEL22 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL33 DEL27 DEL41 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL32 DEL33 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL32 DEL33 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL8 DEL31 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL40 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL43 DEL57 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL51 DEL8 DEL25 DEL8 DEL31 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL42 DEL42 DEL32 DEL42 DEL38 DEL27 DEL42 DEL42 DEL45 DEL33 DEL32 DEL53 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL45 DEL32 DEL53 DEL8 DEL25 DEL42 DEL41 DEL8 DEL25 DEL8 DEL31 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL9 DEL42 DEL43 DEL14 DEL9 DEL9 DEL83 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL42 DEL42 DEL32 DEL42 DEL33 DEL32 DEL21 DEL42 DEL41 DEL8 DEL25
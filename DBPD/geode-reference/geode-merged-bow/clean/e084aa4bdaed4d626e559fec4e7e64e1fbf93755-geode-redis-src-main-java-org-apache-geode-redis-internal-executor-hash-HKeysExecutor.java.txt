GEODE-8130: use a single region for redis Sets and Hashes  (#5120)

* Replaced replicated metaRegion with a partitioned dataRegion.
Currently the dataRegion is used the same way as the metaRegion
except for sets and hashes which store their actual data in it.
* Exception handling now correctly deals with FunctionException
* Disabled a test until GEODE-8127 if fixed.
* Now uses the ByteArrayWrapper as the key on the meta region
and the locks map instead of using a String.
Since a ByteArrayWrapper is used as the key in the data region
this will end up saving memory.

* Found a problem with redis dynamic region management.
Some of the code was executing when we added a new set or hash to
the metaDataRegion. It was only ignoring STRING and HLL.
This caused some extra memory to be used for every redis set/hash.
Now the dynamic region code is only used for lists and sortedSet.

* This commit has some TODO comments of what looks like a bug in
the dynamic region code when a new server is started. It looks
like the new server will not create already existing dynamic regions.
We could test this by starting one server, create a LIST, then
start another server, and then shutdown the first server. Does
the LIST still exist? If we change them not to use dynamic regions
then this issue will go away.
-import java.util.List;
-import org.apache.geode.cache.TimeoutException;
-import org.apache.geode.redis.internal.AutoCloseableLock;
-    List<ByteArrayWrapper> keys;
-    try (AutoCloseableLock regionLock = withRegionLock(context, key)) {
-      RedisHash keyMap = getMap(context, key);
-      keys = keyMap.keys();
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
-      command.setResponse(
-          Coder.getErrorResponse(context.getByteBufAllocator(), "Thread interrupted."));
-      return;
-    } catch (TimeoutException e) {
-      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
-          "Timeout acquiring lock. Please try again."));
-      return;
-    }
-
-    if (keys.isEmpty()) {
+    RedisHash keyMap = getRedisHash(context, key);
+    if (keyMap.isEmpty()) {
-    respondBulkStrings(command, context, keys);
+    respondBulkStrings(command, context, keyMap.keys());

INS8 MOV60 MOV60 MOV25 MOV21 INS32 UPD42 INS42 INS42 INS42 MOV32 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL42 DEL7 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL45 DEL32 DEL32 DEL21 DEL41 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL45 DEL32 DEL32 DEL21 DEL41 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8
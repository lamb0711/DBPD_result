GEODE-5985 Possible integer overflow

We had a number of calculations that were taking place with ints instead
of longs.  I've modified them to, in most places, just add an L to the
constant multiplier.  In other places I had to change a variable type
from int to long.

There were a few places that were also assigning a long to an int
variable or an int to a byte variable.  In these I added bit AND
operators to reduce the chances of overflow.

IndexElemArray needed a lot of work due to its "size" instvar being
a byte.

This closes #2783

- * operations supported and the maximum size of 128 elements
+ * operations supported and the maximum size of 255 elements
+    if (minCapacity > 255) {
+      throw new IllegalStateException("attempt to increase the size beyond 255 elements");
+    }
-      if (newCapacity < minCapacity) {
+      if (newCapacity < minCapacity || 255 < newCapacity) {
-    return size;
+    return size & 0xff;
+      int currentSize = size();
-        for (int i = 0; i < size; i++)
+        for (int i = 0; i < currentSize; i++)
-        for (int i = 0; i < size; i++)
+        for (int i = 0; i < currentSize; i++)
-      RangeCheck(index);
+      rangeCheck(index);
-      RangeCheck(index);
+      rangeCheck(index);
-      ensureCapacity(size + 1);
-      elementData[size] = e;
-      ++size;
+      int currentSize = size(); // byte to int
+      ensureCapacity(currentSize + 1);
+      elementData[currentSize] = e;
+      currentSize++;
+      setSize(currentSize);
+  private void setSize(int size) {
+    this.size = (byte) (size & 0xff);
+  }
+
+      int currentSize = size(); // byte to int
-        for (int index = 0; index < size; index++)
+        for (int index = 0; index < currentSize; index++)
-        for (int index = 0; index < size; index++)
+        for (int index = 0; index < currentSize; index++)
-    // Let gc do its work
-      for (int i = 0; i < size; i++) {
-        elementData[i] = null;
-      }
+      Arrays.fill(this.elementData, null);
-  private void RangeCheck(int index) {
-    if (index >= size) {
-      throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
+  private void rangeCheck(int index) {
+    int currentSize = size(); // byte to int
+    if (index >= currentSize) {
+      throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + currentSize);
-      ensureCapacity(size + numNew);
-      System.arraycopy(a, 0, elementData, size, numNew);
-      size += numNew;
+      int currentSize = size(); // byte to int
+      ensureCapacity(currentSize + numNew);
+      System.arraycopy(a, 0, elementData, currentSize, numNew);
+      setSize(currentSize + numNew);
-    return Arrays.copyOf(elementData, size);
+    synchronized (lock) {
+      return Arrays.copyOf(elementData, size);
+    }
-        len = size;
+        len = size();

INS31 INS83 INS39 INS42 INS44 INS8 UPD42 INS8 UPD66 INS25 INS39 INS42 INS21 INS60 INS51 INS27 INS8 INS27 INS7 INS39 INS59 INS42 MOV8 INS42 INS34 INS53 INS42 INS34 INS60 INS60 INS21 INS22 INS11 INS60 INS21 INS42 INS32 UPD42 INS60 INS14 INS27 INS39 INS59 INS39 INS59 INS37 INS32 INS52 INS42 INS39 INS36 INS39 INS59 INS32 INS42 INS39 INS59 INS32 INS43 INS45 MOV27 INS27 INS42 INS32 UPD42 UPD42 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS32 INS42 INS42 INS22 INS33 INS42 INS32 UPD42 INS42 INS27 INS42 INS34 INS42 INS42 INS42 UPD42 UPD42 INS42 INS34 INS42 INS52 INS42 UPD42 INS42 UPD42 INS42 INS42 INS32 UPD42 UPD42 UPD42 UPD42 INS42 DEL42 DEL42 DEL38 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL33 DEL7 DEL21 DEL8 DEL24 DEL42 DEL42 DEL7 DEL42
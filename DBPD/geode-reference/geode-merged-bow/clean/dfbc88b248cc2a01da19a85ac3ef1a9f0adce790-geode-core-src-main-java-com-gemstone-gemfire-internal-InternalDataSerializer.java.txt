Merge branch 'develop' into feature/GEODE-420

# Conflicts:
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/AbstractDistributionConfig.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/DistributionConfig.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/DistributionConfigImpl.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/InternalLocator.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/StartupMessage.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/SystemAdmin.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/AcceptorImpl.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/CacheServerStats.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/i18n/LocalizedStrings.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/statistics/HostStatHelper.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/statistics/HostStatSampler.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/statistics/StatArchiveWriter.java
#	geode-core/src/main/java/com/gemstone/gemfire/management/internal/ManagementAgent.java
#	geode-core/src/test/java/com/gemstone/gemfire/distributed/internal/DistributionConfigJUnitTest.java
#	geode-core/src/test/java/com/gemstone/gemfire/internal/statistics/GemFireStatSamplerIntegrationTest.java
#	geode-core/src/test/java/com/gemstone/gemfire/internal/statistics/SimpleStatSamplerIntegrationTest.java

-    // @todo add: LinkedHashMap (hard to do because it might not be insertion ordered)
-        // TODO once .NET is enhanced to support inline enums then it should be compatible.
-//       DSDataOutput out2 = new DSDataOutput(out);
-
-//       for (int i = 0; i < serializers.length; i++) {
-//         final DataSerializer myserializer =
-//           (DataSerializer) serializers[i];
-//         out2.setSerializerId(myserializer.getId());
-//         if (myserializer.toData(o, out2)) {
-//           if (!out2.hasWritten()) {
-//             String s = "Serializer " + serializer + " serialized a " +
-//               o.getClass().getName() + ", but it did not write " +
-//               "any data";
-//             throw new IOException(s);
-//           }
-//           return true;
-
-//         } else {
-//           if (out2.hasWritten()) {
-//             String s = "Serializer " + myserializer +
-//               " did not serialize a " + o.getClass().getName() +
-//               ", but it wrote data";
-//             throw new IOException(s);
-//           }
-//         }
-//       }
-   * 
-   * TODO - this is a hack. We should have different flavor of
-   * write object for user objects that calls the serializer. Other
-   * kinds of write object shouldn't even get to the pdx serializer.
-            || o.getClass().getName().startsWith("com.gemstone."))
+            || o.getClass().getName().startsWith("com.gemstone.")
+             || o.getClass().getName().startsWith("org.apache.geode"))
-      // @todo darrel: make a subinterface of DataSerializable
-      // named InstantiatedDataSerializable
-      // which adds one method which returns the instantiator code.
-      // This would allow the serialization side to not need a map lookup (instead they just call the method)
-      // which also helps the DataSerializable case to no longer do the lookup.
-      // We could also use it to get rid of the need for static register calls
-      // but that would mean that when we find one of these that we check to see
-      // if that class had been registered and do so if not.
-      // So from the customer's point of view this would be easier; just implement
-      // a method that returns an int.
-              //               public int read(byte[] b, int off, int len)
-              //                 throws IOException {
-              //                 // @todo davidw Do read() and readFully() have the
-              //                 // same semantics in this case?
-              //                 in.readFully(b, off, len);
-              //                 return len;
-              //               }
-
-              //               public long skip(long n) throws IOException {
-              //                 // @todo davidw Is casting the right thing to do?
-              //                 return in.skipBytes((int) n);
-              //               }

INS32 INS32 INS42 INS45 INS32 INS42 INS42 INS42 DEL66 DEL66 DEL66
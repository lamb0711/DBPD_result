Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  private static final int IMPORT_CONCURRENCY = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "RegionSnapshotServiceImpl.IMPORT_CONCURRENCY", 10);
-  
+  private static final int IMPORT_CONCURRENCY = Integer.getInteger(
+      DistributionConfig.GEMFIRE_PREFIX + "RegionSnapshotServiceImpl.IMPORT_CONCURRENCY", 10);
+
-  static final int BUFFER_SIZE = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "RegionSnapshotServiceImpl.BUFFER_SIZE", 1024 * 1024);
-  
+  static final int BUFFER_SIZE = Integer.getInteger(
+      DistributionConfig.GEMFIRE_PREFIX + "RegionSnapshotServiceImpl.BUFFER_SIZE", 1024 * 1024);
+
-        return new File[] { snapshot };
+        return new File[] {snapshot};
-      
+
-  
+
-   *  
+   * 
-    long export(Region<K, V> region, ExportSink sink, SnapshotOptions<K, V> options) throws IOException; 
+    long export(Region<K, V> region, ExportSink sink, SnapshotOptions<K, V> options)
+        throws IOException;
-  
+
-  
+
-  public void save(File snapshot, SnapshotFormat format, SnapshotOptions<K, V> options) 
+  public void save(File snapshot, SnapshotFormat format, SnapshotOptions<K, V> options)
-    
+
-      snapshotInParallel(new ParallelArgs<K, V>(snapshot, format, options), new ParallelExportFunction<K, V>());
+      snapshotInParallel(new ParallelArgs<K, V>(snapshot, format, options),
+          new ParallelExportFunction<K, V>());
-      
+
-  public void load(File snapshot, SnapshotFormat format) throws IOException,
-      ClassNotFoundException {
+  public void load(File snapshot, SnapshotFormat format)
+      throws IOException, ClassNotFoundException {
-  public void load(File snapshot, SnapshotFormat format, SnapshotOptions<K, V> options) 
+  public void load(File snapshot, SnapshotFormat format, SnapshotOptions<K, V> options)
-      snapshotInParallel(new ParallelArgs<K, V>(snapshot, format, options), new ParallelImportFunction<K, V>());
+      snapshotInParallel(new ParallelArgs<K, V>(snapshot, format, options),
+          new ParallelImportFunction<K, V>());
-      
+
-    return ((SnapshotOptionsImpl<K, V>) options).isParallelMode() 
+    return ((SnapshotOptionsImpl<K, V>) options).isParallelMode()
-      
+
-      
+
-    
+
-    
+
-    
+
-      
+
-        
+
-        // have to subvert the API by using Token.INVALID.  Alternatively we could
+        // have to subvert the API by using Token.INVALID. Alternatively we could
-        // bulk operations.  The ugly type coercion below is necessary to allow 
+        // bulk operations. The ugly type coercion below is necessary to allow
-          // CachedDeserializable.  Somewhere along the line the header bytes
+          // CachedDeserializable. Somewhere along the line the header bytes
-          
+
-            
+
-            Future<?> f = GemFireCacheImpl
-                .getExisting("Importing region from snapshot")
-                .getDistributionManager().getWaitingThreadPool()
-                .submit(new Runnable() {
-              @Override
-              public void run() {
-                local.basicImportPutAll(copy, true);
-              }
-            });
-            
+            Future<?> f = GemFireCacheImpl.getExisting("Importing region from snapshot")
+                .getDistributionManager().getWaitingThreadPool().submit(new Runnable() {
+                  @Override
+                  public void run() {
+                    local.basicImportPutAll(copy, true);
+                  }
+                });
+
-      
+
-        getLoggerI18n().info(LocalizedStrings.Snapshot_IMPORT_END_0_1_2_3, 
-            new Object[] { count, bytes, region.getName(), snapshot });
+        getLoggerI18n().info(LocalizedStrings.Snapshot_IMPORT_END_0_1_2_3,
+            new Object[] {count, bytes, region.getName(), snapshot});
-      
+
-      
+
-    
+
-      
+
-        getLoggerI18n().info(LocalizedStrings.Snapshot_EXPORT_END_0_1_2_3, 
-            new Object[] { count, sink.getBytesWritten(), region.getName(), snapshot });
+        getLoggerI18n().info(LocalizedStrings.Snapshot_EXPORT_END_0_1_2_3,
+            new Object[] {count, sink.getBytesWritten(), region.getName(), snapshot});
-        @Override public V setValue(V value) { throw new UnsupportedOperationException(); }
-        @Override public K getKey() { return key; }
-        @Override public V getValue() { 
+        @Override
+        public V setValue(V value) {
+          throw new UnsupportedOperationException();
+        }
+
+        @Override
+        public K getKey() {
+          return key;
+        }
+
+        @Override
+        public V getValue() {
-      
+
-  
+
-      
+
-        || region instanceof LocalDataSet
-        || (((SnapshotOptionsImpl<K, V>) options).isParallelMode() 
+        || region instanceof LocalDataSet || (((SnapshotOptionsImpl<K, V>) options).isParallelMode()
-      
+
-      //    for loner systems to avoid inlining fn execution
-      //    for NORMAL/PRELOAD since they don't support fn execution
-      //    for LocalDataSet since we're already running a fn
-      //    for parallel ops since we're already running a fn
+      // for loner systems to avoid inlining fn execution
+      // for NORMAL/PRELOAD since they don't support fn execution
+      // for LocalDataSet since we're already running a fn
+      // for parallel ops since we're already running a fn
-    
+
-  
+
-   * Writes snapshot data to a {@link SnapshotWriter}.  Caller is responsible
-   * for invoking {@link SnapshotWriter#snapshotComplete()}.
+   * Writes snapshot data to a {@link SnapshotWriter}. Caller is responsible for invoking
+   * {@link SnapshotWriter#snapshotComplete()}.
-    
+
-    
+
-    
+
-  
+
-   * Forwards snapshot data to a {@link ResultSender}.  Caller is responsible for
-   * invoking {@link ResultSender#lastResult(Object)}.
+   * Forwards snapshot data to a {@link ResultSender}. Caller is responsible for invoking
+   * {@link ResultSender#lastResult(Object)}.
-    
+
-    
+
-  
+
-    
+
-    
+
-      
+
-    
+
-    
+
-    
+
-  
+
-        Region<K, V> local = PartitionRegionHelper.getLocalDataForContext((RegionFunctionContext) context);
+        Region<K, V> local =
+            PartitionRegionHelper.getLocalDataForContext((RegionFunctionContext) context);
-        
+
-        
+
-        
+
-        
+
-        Region<K, V> local = PartitionRegionHelper.getLocalDataForContext((RegionFunctionContext) context);
+        Region<K, V> local =
+            PartitionRegionHelper.getLocalDataForContext((RegionFunctionContext) context);
-        
+
-              throw new IOException(LocalizedStrings.Snapshot_INVALID_IMPORT_FILE.toLocalizedString(f));
+              throw new IOException(
+                  LocalizedStrings.Snapshot_INVALID_IMPORT_FILE.toLocalizedString(f));
-        
+

UPD66 UPD66 DEL66 DEL66
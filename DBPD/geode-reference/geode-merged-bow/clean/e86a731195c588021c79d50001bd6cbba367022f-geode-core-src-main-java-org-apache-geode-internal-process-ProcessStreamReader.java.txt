Merge branch 'release/1.3.0'

-import java.io.BufferedReader;
-import java.io.IOException;
+import static org.apache.commons.lang.Validate.isTrue;
+import static org.apache.commons.lang.Validate.notNull;
+
-import java.io.InputStreamReader;
-import org.apache.logging.log4j.Logger;
-
-import org.apache.geode.internal.logging.LogService;
-  private static final int DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLISECONDS = 5000;
-  private static final Logger logger = LogService.getLogger();
+
+  private static final int DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLIS = 5000;
+    notNull(builder, "Invalid builder '" + builder + "' specified");
+
+
-  @Override
-  public void run() {
-    final boolean isDebugEnabled = logger.isDebugEnabled();
-    if (isDebugEnabled) {
-      logger.debug("Running {}", this);
-    }
-    BufferedReader reader = null;
-    try {
-      reader = new BufferedReader(new InputStreamReader(inputStream));
-      String line;
-      while ((line = reader.readLine()) != null) {
-        this.inputListener.notifyInputLine(line);
-      }
-    } catch (IOException e) {
-      if (isDebugEnabled) {
-        logger.debug("Failure reading from buffered input stream: {}", e.getMessage(), e);
-      }
-    } finally {
-      try {
-        reader.close();
-      } catch (IOException e) {
-        if (isDebugEnabled) {
-          logger.debug("Failure closing buffered input stream reader: {}", e.getMessage(), e);
-        }
-      }
-      if (isDebugEnabled) {
-        logger.debug("Terminating {}", this);
-      }
-    }
-  }
-
-      if (this.thread == null) {
-        this.thread = new Thread(this, createThreadName());
-        this.thread.setDaemon(true);
-        this.thread.start();
-      } else if (this.thread.isAlive()) {
+      if (thread == null) {
+        thread = new Thread(this, createThreadName());
+        thread.setDaemon(true);
+        thread.start();
+      } else if (thread.isAlive()) {
-      if (this.thread != null && this.thread.isAlive()) {
-        this.thread.interrupt();
-      } else if (this.thread != null) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("{} has already been stopped", this);
-        }
-      } else {
-        if (logger.isDebugEnabled()) {
-          logger.debug("{} has not been started", this);
-        }
+      if (thread != null && thread.isAlive()) {
+        thread.interrupt();
-    Runnable delayedStop = new Runnable() {
-      @Override
-      public void run() {
-        try {
-          Thread.sleep(delayMillis);
-        } catch (InterruptedException e) {
-        } finally {
-          stop();
-        }
+    Runnable delayedStop = () -> {
+      try {
+        Thread.sleep(delayMillis);
+      } catch (InterruptedException ignored) {
+      } finally {
+        stop();
+
-      if (this.thread != null) {
-        return this.thread.isAlive();
+      if (thread != null) {
+        return thread.isAlive();
-  public void join() throws InterruptedException {
+  public ProcessStreamReader join() throws InterruptedException {
+    return this;
-  public void join(final long millis) throws InterruptedException {
+  public ProcessStreamReader join(final long millis) throws InterruptedException {
+    return this;
-  public void join(final long millis, final int nanos) throws InterruptedException {
+  public ProcessStreamReader join(final long millis, final int nanos) throws InterruptedException {
+    return this;
-    final StringBuilder sb = new StringBuilder(getClass().getSimpleName());
+    StringBuilder sb = new StringBuilder(getClass().getSimpleName());
-    sb.append(" alive=").append(isRunning()); // this.thread == null ? false :
-                                              // this.thread.isAlive());
-    sb.append(" listener=").append(this.inputListener);
+    sb.append(" alive=").append(isRunning());
+    sb.append(" listener=").append(inputListener);
-    return getClass().getSimpleName() + "@" + Integer.toHexString(hashCode());
+    return getClass().getSimpleName() + '@' + Integer.toHexString(hashCode());
-  public static interface InputListener {
-    public void notifyInputLine(String line);
+  public interface InputListener {
+    void notifyInputLine(final String line);
-  public static enum ReadingMode {
-    BLOCKING, NON_BLOCKING;
+  public enum ReadingMode {
+    BLOCKING, NON_BLOCKING
-  public static String waitAndCaptureProcessStandardOutputStream(final Process process) {
-    return waitAndCaptureProcessStandardOutputStream(process,
-        DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLISECONDS);
-  }
-
-  public static String waitAndCaptureProcessStandardOutputStream(final Process process,
+  private static String waitAndCaptureProcessStandardOutputStream(final Process process,
+    notNull(process, "Invalid process '" + process + "' specified");
+
-        DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLISECONDS);
+        DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLIS);
-      final InputStream processInputStream, long waitTimeMilliseconds) {
-    final StringBuffer buffer = new StringBuffer();
+      final InputStream processInputStream, final long waitTimeMilliseconds) {
+    StringBuffer buffer = new StringBuffer();
-      final long endTime = (System.currentTimeMillis() + waitTimeMilliseconds);
+      long endTime = System.currentTimeMillis() + waitTimeMilliseconds;
-   * 
+   *
-    protected Process process;
-    protected InputStream inputStream;
-    protected InputListener inputListener;
-    protected long continueReadingMillis = 0;
-    protected ReadingMode readingMode = ReadingMode.BLOCKING;
+
+    final Process process;
+    InputStream inputStream;
+    InputListener inputListener;
+    long continueReadingMillis = 0;
+    ReadingMode readingMode = ReadingMode.BLOCKING;
-      if (process == null) {
-        throw new NullPointerException("process may not be null");
-      }
-      if (inputStream == null) {
-        throw new NullPointerException("inputStream may not be null");
-      }
-      if (continueReadingMillis < 0) {
-        throw new IllegalArgumentException("continueReadingMillis must zero or positive");
-      }
-      switch (this.readingMode) {
+      notNull(process, "Invalid process '" + process + "' specified");
+      notNull(inputStream, "Invalid inputStream '" + inputStream + "' specified");
+      isTrue(continueReadingMillis >= 0,
+          "Invalid continueReadingMillis '" + continueReadingMillis + "' specified");
+
+      switch (readingMode) {

MOV26 MOV26 UPD40 UPD40 INS31 MOV83 INS43 MOV42 MOV8 INS43 MOV43 INS43 UPD83 MOV43 MOV44 UPD42 INS21 UPD42 MOV42 INS42 INS41 INS41 INS42 INS41 INS21 INS83 UPD83 INS32 MOV43 INS52 INS52 INS52 INS83 MOV43 INS32 INS21 INS21 INS21 INS42 INS42 INS27 INS86 INS42 INS13 INS42 INS42 INS27 UPD42 INS32 INS32 INS32 INS42 INS45 INS42 INS45 MOV8 INS45 INS42 INS45 INS42 INS42 INS27 INS42 INS42 INS27 INS42 INS27 INS27 INS42 INS42 MOV27 INS45 MOV42 INS45 INS45 MOV42 INS45 MOV42 MOV34 INS45 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL23 DEL42 DEL78 DEL39 DEL42 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL45 DEL52 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL43 DEL43 DEL42 DEL14 DEL14 DEL7 DEL21 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL7 DEL36 DEL33 DEL27 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL21 DEL8 DEL61 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL12 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL45 DEL52 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL31 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL52 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL52 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL83 DEL31 DEL42 DEL43 DEL42 DEL78 DEL83 DEL39 DEL42 DEL31 DEL1 DEL14 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL39 DEL39 DEL39 DEL83 DEL52 DEL42 DEL22 DEL45 DEL83 DEL83 DEL42 DEL43 DEL83 DEL83 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL83 DEL36 DEL83 DEL83 DEL83 DEL83 DEL33 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL33 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL52 DEL42 DEL22
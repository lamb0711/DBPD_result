Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
-import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
- * @version     $Revision: 1.1 $
+ * @version $Revision: 1.1 $
-  
+
-  
+
-  
+
-  
+
-  
+
-   * We retrieve the collection from the context cache if it exists
-   * This allows us to not have to reevaluate the sub query on every iteration.
-   * This improves performance for queries such as 
-   * "select * from /receipts r where r.type = 'large' and r.id in (select c.id from /customers c where c.status = 'preferred')
-   * The sub query would create a set that would not change and store it 
-   * into the context if it does not yet exist
+   * We retrieve the collection from the context cache if it exists This allows us to not have to
+   * reevaluate the sub query on every iteration. This improves performance for queries such as
+   * "select * from /receipts r where r.type = 'large' and r.id in (select c.id from /customers c
+   * where c.status = 'preferred') The sub query would create a set that would not change and store
+   * it into the context if it does not yet exist
-  private Object evaluateColln(ExecutionContext context) 
-      throws QueryInvocationTargetException, NameResolutionException, 
-      TypeMismatchException, FunctionDomainException {
+  private Object evaluateColln(ExecutionContext context) throws QueryInvocationTargetException,
+      NameResolutionException, TypeMismatchException, FunctionDomainException {
-    }
-    else {
+    } else {
-      if (evalColln == null ) {
+      if (evalColln == null) {
-  
-  public Object evaluate(ExecutionContext context)
-  throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-          QueryInvocationTargetException {
+
+  public Object evaluate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    
+
-    
+
-    
+
-      evalColln = ((Map)evalColln).entrySet();
+      evalColln = ((Map) evalColln).entrySet();
-    
+
-      Iterator iterator = ((Collection)evalColln).iterator();
+      Iterator iterator = ((Collection) evalColln).iterator();
-    
+
-      throw new TypeMismatchException(LocalizedStrings.CompiledIn_OPERAND_OF_IN_CANNOT_BE_INTERPRETED_AS_A_COLLECTION_IS_INSTANCE_OF_0.toLocalizedString(evalColln.getClass().getName()));
+      throw new TypeMismatchException(
+          LocalizedStrings.CompiledIn_OPERAND_OF_IN_CANNOT_BE_INTERPRETED_AS_A_COLLECTION_IS_INSTANCE_OF_0
+              .toLocalizedString(evalColln.getClass().getName()));
-        throw new TypeMismatchException(LocalizedStrings.CompiledIn_IN_OPERATOR_CHECK_FOR_NULL_IN_PRIMITIVE_ARRAY.toLocalizedString());
+        throw new TypeMismatchException(
+            LocalizedStrings.CompiledIn_IN_OPERATOR_CHECK_FOR_NULL_IN_PRIMITIVE_ARRAY
+                .toLocalizedString());
-    
+
-   
+
-  
+
-      throws TypeMismatchException, AmbiguousNameException,
-      NameResolutionException {
+      throws TypeMismatchException, AmbiguousNameException, NameResolutionException {
-      IndexData indexData = QueryUtils.getAvailableIndexIfAny(path, context,
-          this.TOK_EQ);
+      IndexData indexData = QueryUtils.getAvailableIndexIfAny(path, context, this.TOK_EQ);
-        newIndexInfo[0] = new IndexInfo(indexKey, path, index, indexData
-            .getMatchLevel(), indexData.getMapping(), this.TOK_EQ);
+        newIndexInfo[0] = new IndexInfo(indexKey, path, index, indexData.getMatchLevel(),
+            indexData.getMapping(), this.TOK_EQ);
-    if (indexInfo == null) return result;
+    if (indexInfo == null)
+      return result;
-    String preferredCondn = (String)context.cacheGet(PREF_INDEX_COND);
-    if(preferredCondn != null) {
-      //This means that the system is having only one independent iterator so equi join is ruled out.
-      // thus the first index is guaranteed to be on the condition which may match our preferred index
-      if(indexInfo[0]._index.getCanonicalizedIndexedExpression().equals(preferredCondn) && 
-          (indexInfo[0]._index.getType() == IndexType.FUNCTIONAL || indexInfo[0]._index.getType() == IndexType.HASH)) {
+    String preferredCondn = (String) context.cacheGet(PREF_INDEX_COND);
+    if (preferredCondn != null) {
+      // This means that the system is having only one independent iterator so equi join is ruled
+      // out.
+      // thus the first index is guaranteed to be on the condition which may match our preferred
+      // index
+      if (indexInfo[0]._index.getCanonicalizedIndexedExpression().equals(preferredCondn)
+          && (indexInfo[0]._index.getType() == IndexType.FUNCTIONAL
+              || indexInfo[0]._index.getType() == IndexType.HASH)) {
-  throws TypeMismatchException, AmbiguousNameException, NameResolutionException {
+      throws TypeMismatchException, AmbiguousNameException, NameResolutionException {
-  
+
+   * 
-  List optimizeBulkGet(CompiledRegion cRgn, ExecutionContext context) 
-  throws RegionNotFoundException, TypeMismatchException,
-         NameResolutionException, FunctionDomainException, QueryInvocationTargetException {
+  List optimizeBulkGet(CompiledRegion cRgn, ExecutionContext context)
+      throws RegionNotFoundException, TypeMismatchException, NameResolutionException,
+      FunctionDomainException, QueryInvocationTargetException {
-    
+
-      String id = ((CompiledID)this.elm).getId();
-      if (id.equals("key") || id.equals("getKey")){
+      String id = ((CompiledID) this.elm).getId();
+      if (id.equals("key") || id.equals("getKey")) {
-          resolution = ((CompiledPath)resolution).getReceiver();
+          resolution = ((CompiledPath) resolution).getReceiver();
-    }
-    else if (this.elm instanceof CompiledPath) {
-      CompiledPath cPath = (CompiledPath)this.elm;
+    } else if (this.elm instanceof CompiledPath) {
+      CompiledPath cPath = (CompiledPath) this.elm;
-        if (cVal instanceof CompiledID) { 
-          resolution = context.resolve(((CompiledID)cVal).getId());
+        if (cVal instanceof CompiledID) {
+          resolution = context.resolve(((CompiledID) cVal).getId());
-    }
-    else if (this.elm instanceof CompiledOperation) {
-      CompiledOperation cOp = (CompiledOperation)this.elm;
+    } else if (this.elm instanceof CompiledOperation) {
+      CompiledOperation cOp = (CompiledOperation) this.elm;
-          resolution = context.resolve(((CompiledID)cOp.getReceiver(context)).getId());
-        }
-        else if (cOp.getReceiver(context) == null) {
+          resolution = context.resolve(((CompiledID) cOp.getReceiver(context)).getId());
+        } else if (cOp.getReceiver(context) == null) {
-    
+
-    
+
-    
+
-      colln = (Collection)evalColln;
+      colln = (Collection) evalColln;
-      colln = Arrays.asList((Object[])evalColln);
+      colln = Arrays.asList((Object[]) evalColln);
-    
+
-      QRegion rgn = (QRegion)cRgn.evaluate(context);
-      
+      QRegion rgn = (QRegion) cRgn.evaluate(context);
+
-      
+
-      
+
-      for (Iterator itr = colln.iterator(); itr.hasNext(); ) {
+      for (Iterator itr = colln.iterator(); itr.hasNext();) {
-  }  
+  }
-   * get the path to see if there's an index for, and also determine which
-   * CompiledValue is the key while we're at it
+   * get the path to see if there's an index for, and also determine which CompiledValue is the key
+   * while we're at it
-    if ( !isLeftDependent  || isRightDependent ) return null;
+    if (!isLeftDependent || isRightDependent)
+      return null;
-    //Asif Do not worry about the nature of the collection. As long as it
-    //is not dependent on the current scope we should be fine
-    
+    // Asif Do not worry about the nature of the collection. As long as it
+    // is not dependent on the current scope we should be fine
+
-  
+
-   * Asif : Evaluates as a filter taking advantage of indexes if appropriate.
-   * This function has a meaningful implementation only in CompiledComparison &
-   * CompiledUndefined . It is unsupported in other classes. The additional
-   * parameters which it takes are a boolean which is used to indicate whether
-   * the index result set needs to be expanded to the top level or not. The
-   * second is a CompiledValue representing the operands which are only iter
-   * evaluatable. The CompiledValue passed will be null except if a
-   * GroupJunction has only one filter evaluatable condition & rest are iter
-   * operands. In such cases , the iter operands will be evaluated while
-   * expanding/cutting down the index resultset
+   * Asif : Evaluates as a filter taking advantage of indexes if appropriate. This function has a
+   * meaningful implementation only in CompiledComparison & CompiledUndefined . It is unsupported in
+   * other classes. The additional parameters which it takes are a boolean which is used to indicate
+   * whether the index result set needs to be expanded to the top level or not. The second is a
+   * CompiledValue representing the operands which are only iter evaluatable. The CompiledValue
+   * passed will be null except if a GroupJunction has only one filter evaluatable condition & rest
+   * are iter operands. In such cases , the iter operands will be evaluated while expanding/cutting
+   * down the index resultset
-  public SelectResults filterEvaluate(ExecutionContext context,
-      SelectResults intermediateResults, boolean completeExpansionNeeded,
-      CompiledValue iterOperands, RuntimeIterator[] indpndntItrs, boolean isIntersection, boolean conditioningNeeded, boolean evalProj)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException
-  {
+  public SelectResults filterEvaluate(ExecutionContext context, SelectResults intermediateResults,
+      boolean completeExpansionNeeded, CompiledValue iterOperands, RuntimeIterator[] indpndntItrs,
+      boolean isIntersection, boolean conditioningNeeded, boolean evalProj)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-    Support
-        .Assert(
-            idxInfo != null,
-            "a comparison that is dependent, not indexed, and filter evaluated is not possible");
-    Support.Assert(idxInfo.length == 1,
-        "In operator should have only one index");
+    Support.Assert(idxInfo != null,
+        "a comparison that is dependent, not indexed, and filter evaluated is not possible");
+    Support.Assert(idxInfo.length == 1, "In operator should have only one index");
-    return singleBaseCollectionFilterEvaluate(context, intermediateResults,
-        completeExpansionNeeded, iterOperands, idxInfo[0], indpndntItrs, isIntersection,conditioningNeeded,evalProj);
+    return singleBaseCollectionFilterEvaluate(context, intermediateResults, completeExpansionNeeded,
+        iterOperands, idxInfo[0], indpndntItrs, isIntersection, conditioningNeeded, evalProj);
-  
+
-  /** **************** PRIVATE METHODS ************************** 
-   * @throws QueryInvocationTargetException 
-   * @throws NameResolutionException 
-   * @throws FunctionDomainException 
-   * @throws TypeMismatchException */
-  
-  private void queryIndex(Object key,
-                          IndexInfo indexInfo,
-                          SelectResults results,
-                          CompiledValue iterOperands,
-                          RuntimeIterator[] indpndntItrs,
-                          ExecutionContext context,
-                          List projAttrib,
-                          boolean conditioningNeeded)
-  throws TypeMismatchException,
-         FunctionDomainException,
-         NameResolutionException,
-         QueryInvocationTargetException {
-    
+  /**
+   * **************** PRIVATE METHODS **************************
+   * 
+   * @throws QueryInvocationTargetException
+   * @throws NameResolutionException
+   * @throws FunctionDomainException
+   * @throws TypeMismatchException
+   */
+
+  private void queryIndex(Object key, IndexInfo indexInfo, SelectResults results,
+      CompiledValue iterOperands, RuntimeIterator[] indpndntItrs, ExecutionContext context,
+      List projAttrib, boolean conditioningNeeded) throws TypeMismatchException,
+      FunctionDomainException, NameResolutionException, QueryInvocationTargetException {
+
- 
+
-    IndexInfo contextIndexInfo = new IndexInfo(new CompiledLiteral(key),
-        indexInfo._path(), indexInfo._getIndex(), 0, null,
-        indexInfo._operator());
+    IndexInfo contextIndexInfo = new IndexInfo(new CompiledLiteral(key), indexInfo._path(),
+        indexInfo._getIndex(), 0, null, indexInfo._operator());
-    indexInfo._index.query(key,
-                             TOK_EQ,
-                             results,
-                             !conditioningNeeded ? iterOperands : null,
-                             indpndntItrs == null ? null : indpndntItrs[0],
-                             context,
-                             projAttrib,
-                             null,
-                             false); // is Intersection    
+    indexInfo._index.query(key, TOK_EQ, results, !conditioningNeeded ? iterOperands : null,
+        indpndntItrs == null ? null : indpndntItrs[0], context, projAttrib, null, false); // is
+                                                                                          // Intersection
-                  
-    
-   
+
+
+
-   * evaluate as a filter, involving a single iterator. Use an index if
-   * possible.
+   * evaluate as a filter, involving a single iterator. Use an index if possible.
-  private SelectResults singleBaseCollectionFilterEvaluate(
-      ExecutionContext context, SelectResults intermediateResults,
-      boolean completeExpansionNeeded, CompiledValue iterOperands,
-      IndexInfo indexInfo, RuntimeIterator[] indpndntItr, boolean isIntersection, boolean conditioningNeeded, boolean evalProj)
-      throws TypeMismatchException, AmbiguousNameException,
-      FunctionDomainException, NameResolutionException,
-      QueryInvocationTargetException
-  {
+  private SelectResults singleBaseCollectionFilterEvaluate(ExecutionContext context,
+      SelectResults intermediateResults, boolean completeExpansionNeeded,
+      CompiledValue iterOperands, IndexInfo indexInfo, RuntimeIterator[] indpndntItr,
+      boolean isIntersection, boolean conditioningNeeded, boolean evalProj)
+      throws TypeMismatchException, AmbiguousNameException, FunctionDomainException,
+      NameResolutionException, QueryInvocationTargetException {
-      indexFieldsSize = ((StructTypeImpl)resultType).getFieldNames().length;
+      indexFieldsSize = ((StructTypeImpl) resultType).getFieldNames().length;
+    } else {
+      indexFieldsSize = 1;
-    else {
-      indexFieldsSize = 1;      
-    }    
-    boolean useLinkedDataStructure = false; 
+    boolean useLinkedDataStructure = false;
-    Boolean orderByClause = (Boolean)context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-    if(orderByClause != null && orderByClause.booleanValue()) {
-      List orderByAttrs = (List)context.cacheGet(CompiledValue.ORDERBY_ATTRIB);        
-      useLinkedDataStructure =orderByAttrs.size()==1; 
-      nullValuesAtStart = !((CompiledSortCriterion)orderByAttrs.get(0)).getCriterion();
+    Boolean orderByClause = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
+    if (orderByClause != null && orderByClause.booleanValue()) {
+      List orderByAttrs = (List) context.cacheGet(CompiledValue.ORDERBY_ATTRIB);
+      useLinkedDataStructure = orderByAttrs.size() == 1;
+      nullValuesAtStart = !((CompiledSortCriterion) orderByAttrs.get(0)).getCriterion();
-    
+
-      projResultType = evalProj ? (ObjectType)context
-          .cacheGet(RESULT_TYPE) : null;
+      projResultType = evalProj ? (ObjectType) context.cacheGet(RESULT_TYPE) : null;
-        projAttrib = (List)context.cacheGet(PROJ_ATTRIB);
+        projAttrib = (List) context.cacheGet(PROJ_ATTRIB);
-          context.getCache().getLogger().fine(
-              "StructType resultType.class=" + resultType.getClass().getName());
-          if(useLinkedDataStructure) {
-            results  = context.isDistinct() ? new LinkedStructSet((StructTypeImpl)resultType) 
-            : new SortedResultsBag<Struct>((StructTypeImpl)resultType, nullValuesAtStart);
-          }else {
-            results = QueryUtils.createStructCollection(context, (StructTypeImpl)resultType);
-          }
-          indexFieldsSize = ((StructTypeImpl)resultType).getFieldNames().length;
-        }
-        else {
-          context.getCache().getLogger().fine(
-              "non-StructType resultType.class="
-                  + resultType.getClass().getName());
+          context.getCache().getLogger()
+              .fine("StructType resultType.class=" + resultType.getClass().getName());
-            results = context.isDistinct() ? new LinkedResultSet(resultType) :
-              new SortedResultsBag(resultType, nullValuesAtStart);
+            results = context.isDistinct() ? new LinkedStructSet((StructTypeImpl) resultType)
+                : new SortedResultsBag<Struct>((StructTypeImpl) resultType, nullValuesAtStart);
-            results = QueryUtils.createResultCollection(context, resultType) ;
+            results = QueryUtils.createStructCollection(context, (StructTypeImpl) resultType);
+          }
+          indexFieldsSize = ((StructTypeImpl) resultType).getFieldNames().length;
+        } else {
+          context.getCache().getLogger()
+              .fine("non-StructType resultType.class=" + resultType.getClass().getName());
+          if (useLinkedDataStructure) {
+            results = context.isDistinct() ? new LinkedResultSet(resultType)
+                : new SortedResultsBag(resultType, nullValuesAtStart);
+          } else {
+            results = QueryUtils.createResultCollection(context, resultType);
-      }
-      else {
+      } else {
-        }
-        else {
+        } else {
-            context.getCache().getLogger().fine(
-                "StructType resultType.class="
-                    + resultType.getClass().getName());
+            context.getCache().getLogger()
+                .fine("StructType resultType.class=" + resultType.getClass().getName());
-              results = context.isDistinct() ? new LinkedStructSet((StructTypeImpl)resultType) 
-              :new SortedResultsBag<Struct>((StructTypeImpl)resultType, nullValuesAtStart);
+              results = context.isDistinct() ? new LinkedStructSet((StructTypeImpl) resultType)
+                  : new SortedResultsBag<Struct>((StructTypeImpl) resultType, nullValuesAtStart);
-              results = QueryUtils.createStructCollection(context, (StructTypeImpl)resultType) ;
+              results = QueryUtils.createStructCollection(context, (StructTypeImpl) resultType);
-            indexFieldsSize = ((StructTypeImpl)resultType).getFieldNames().length;
-          }
-          else {
-            context.getCache().getLogger().fine(
-                "non-StructType resultType.class="
-                    + resultType.getClass().getName());
+            indexFieldsSize = ((StructTypeImpl) resultType).getFieldNames().length;
+          } else {
+            context.getCache().getLogger()
+                .fine("non-StructType resultType.class=" + resultType.getClass().getName());
-              results = context.isDistinct() ? new LinkedResultSet(resultType) :
-                new SortedResultsBag(resultType, nullValuesAtStart);
+              results = context.isDistinct() ? new LinkedResultSet(resultType)
+                  : new SortedResultsBag(resultType, nullValuesAtStart);
-              results = QueryUtils.createResultCollection(context, resultType) ;
+              results = QueryUtils.createResultCollection(context, resultType);
-    }else {
+    } else {
-        context.getCache().getLogger().fine(
-            "StructType resultType.class=" + resultType.getClass().getName());
+        context.getCache().getLogger()
+            .fine("StructType resultType.class=" + resultType.getClass().getName());
-          results = context.isDistinct() ? new LinkedStructSet((StructTypeImpl)resultType) :
-            new SortedResultsBag<Struct>((StructTypeImpl)resultType, nullValuesAtStart);
+          results = context.isDistinct() ? new LinkedStructSet((StructTypeImpl) resultType)
+              : new SortedResultsBag<Struct>((StructTypeImpl) resultType, nullValuesAtStart);
-           results = QueryUtils.createStructCollection(context, (StructTypeImpl)resultType) ;
+          results = QueryUtils.createStructCollection(context, (StructTypeImpl) resultType);
-        indexFieldsSize = ((StructTypeImpl)resultType).getFieldNames().length;
-      }
-      else {
-        context.getCache().getLogger().fine(
-            "non-StructType resultType.class="
-                + resultType.getClass().getName());
+        indexFieldsSize = ((StructTypeImpl) resultType).getFieldNames().length;
+      } else {
+        context.getCache().getLogger()
+            .fine("non-StructType resultType.class=" + resultType.getClass().getName());
-          results = context.isDistinct() ? new LinkedResultSet(resultType) : 
-            new SortedResultsBag(resultType,  nullValuesAtStart);
+          results = context.isDistinct() ? new LinkedResultSet(resultType)
+              : new SortedResultsBag(resultType, nullValuesAtStart);
-          results = QueryUtils.createResultCollection(context,resultType);
+          results = QueryUtils.createResultCollection(context, resultType);
-    
-    
+
+
-      observer.beforeIndexLookup(indexInfo._index, TOK_EQ, evalColln);      
-      //We need to reset the result type just in case the colln turned out to 
-      //be a compiled comparison which could change the result type
-      //Exec caches are incorrectly shared across all queries, this would result
-      //in overriding the result type.  Once the result type was overridden
-      //multiple projections and class cast exceptions could result due to
-      //unexpected values overwriting expected values
+      observer.beforeIndexLookup(indexInfo._index, TOK_EQ, evalColln);
+      // We need to reset the result type just in case the colln turned out to
+      // be a compiled comparison which could change the result type
+      // Exec caches are incorrectly shared across all queries, this would result
+      // in overriding the result type. Once the result type was overridden
+      // multiple projections and class cast exceptions could result due to
+      // unexpected values overwriting expected values
-        Iterator itr = ((Map)evalColln).entrySet().iterator();
+        Iterator itr = ((Map) evalColln).entrySet().iterator();
-          this.queryIndex(itr.next(),indexInfo, results,iterOperands, indpndntItr, context, projAttrib,conditioningNeeded);
+          this.queryIndex(itr.next(), indexInfo, results, iterOperands, indpndntItr, context,
+              projAttrib, conditioningNeeded);
-      }
-      else if (evalColln instanceof Collection) {
+      } else if (evalColln instanceof Collection) {
-        //If the index is a map index, the key is actually an object[] tuple that contains the map key in the [1]
-        //and the evalColln in the [0] position
+        // If the index is a map index, the key is actually an object[] tuple that contains the map
+        // key in the [1]
+        // and the evalColln in the [0] position
-          Iterator iterator = ((ResultsSet)((Object[]) key)[0]).iterator();
+          Iterator iterator = ((ResultsSet) ((Object[]) key)[0]).iterator();
-            this.queryIndex(new Object[]{iterator.next(), ((Object[])key)[1]}, indexInfo, results, iterOperands, indpndntItr, context, projAttrib, conditioningNeeded);
+            this.queryIndex(new Object[] {iterator.next(), ((Object[]) key)[1]}, indexInfo, results,
+                iterOperands, indpndntItr, context, projAttrib, conditioningNeeded);
-        }
-        else {
-          //Removing duplicates from the collection
+        } else {
+          // Removing duplicates from the collection
-            this.queryIndex(itr.next(), indexInfo, results, iterOperands, indpndntItr, context, projAttrib, conditioningNeeded);
+            this.queryIndex(itr.next(), indexInfo, results, iterOperands, indpndntItr, context,
+                projAttrib, conditioningNeeded);
-      }
-      else {
+      } else {
-          throw new TypeMismatchException(
-              "Operand of IN cannot be interpreted as a Collection. "
-                  + "Is instance of " + evalColln.getClass().getName());
+          throw new TypeMismatchException("Operand of IN cannot be interpreted as a Collection. "
+              + "Is instance of " + evalColln.getClass().getName());
-          Object[] arr = (Object[])evalColln;
+          Object[] arr = (Object[]) evalColln;
-            this.queryIndex(arr[i],indexInfo,results, iterOperands, indpndntItr, context, projAttrib,conditioningNeeded);
+            this.queryIndex(arr[i], indexInfo, results, iterOperands, indpndntItr, context,
+                projAttrib, conditioningNeeded);
-        }
-        else if (evalColln instanceof long[]) {
-          long[] a = (long[])evalColln;
-          for (int i = 0; i < a.length; i++) {            
-            this.queryIndex(Long.valueOf(a[i]),indexInfo,results, iterOperands, indpndntItr, context, projAttrib,conditioningNeeded);
-          }
-
-        }
-        else if (evalColln instanceof double[]) {
-          double[] a = (double[])evalColln;
+        } else if (evalColln instanceof long[]) {
+          long[] a = (long[]) evalColln;
-            this.queryIndex(Double.valueOf(a[i]),indexInfo,results, iterOperands, indpndntItr, context, projAttrib,conditioningNeeded);
+            this.queryIndex(Long.valueOf(a[i]), indexInfo, results, iterOperands, indpndntItr,
+                context, projAttrib, conditioningNeeded);
-        }
-        else if (evalColln instanceof float[]) {
-          float[] a = (float[])evalColln;
+        } else if (evalColln instanceof double[]) {
+          double[] a = (double[]) evalColln;
-            this.queryIndex(new Float(a[i]),indexInfo, results, iterOperands, indpndntItr, context, projAttrib,conditioningNeeded);
+            this.queryIndex(Double.valueOf(a[i]), indexInfo, results, iterOperands, indpndntItr,
+                context, projAttrib, conditioningNeeded);
-        }
-        else if (evalColln instanceof int[]) {
-          int[] a = (int[])evalColln;
+        } else if (evalColln instanceof float[]) {
+          float[] a = (float[]) evalColln;
-            this.queryIndex(Integer.valueOf(a[i]),indexInfo, results, iterOperands, indpndntItr, context, projAttrib,conditioningNeeded);
-          }
-        }
-        else if (evalColln instanceof short[]) {
-          short[] a = (short[])evalColln;
-          for (int i = 0; i < a.length; i++) {
-            this.queryIndex(new Short(a[i]),indexInfo, results, iterOperands, indpndntItr, context, projAttrib,conditioningNeeded);
+            this.queryIndex(new Float(a[i]), indexInfo, results, iterOperands, indpndntItr, context,
+                projAttrib, conditioningNeeded);
-        }
-        else if (evalColln instanceof char[]) {
-          char[] a = (char[])evalColln;
+        } else if (evalColln instanceof int[]) {
+          int[] a = (int[]) evalColln;
-            this.queryIndex(new Character(a[i]),indexInfo,results,iterOperands, indpndntItr, context, projAttrib,conditioningNeeded);
+            this.queryIndex(Integer.valueOf(a[i]), indexInfo, results, iterOperands, indpndntItr,
+                context, projAttrib, conditioningNeeded);
+          }
+        } else if (evalColln instanceof short[]) {
+          short[] a = (short[]) evalColln;
+          for (int i = 0; i < a.length; i++) {
+            this.queryIndex(new Short(a[i]), indexInfo, results, iterOperands, indpndntItr, context,
+                projAttrib, conditioningNeeded);
-        }
-        else if (evalColln instanceof byte[]) {
-          byte[] a = (byte[])evalColln;
+        } else if (evalColln instanceof char[]) {
+          char[] a = (char[]) evalColln;
-            this.queryIndex(new Byte(a[i]),indexInfo,results, iterOperands, indpndntItr, context, projAttrib,conditioningNeeded);
+            this.queryIndex(new Character(a[i]), indexInfo, results, iterOperands, indpndntItr,
+                context, projAttrib, conditioningNeeded);
-        }
-        else {
+        } else if (evalColln instanceof byte[]) {
+          byte[] a = (byte[]) evalColln;
+          for (int i = 0; i < a.length; i++) {
+            this.queryIndex(new Byte(a[i]), indexInfo, results, iterOperands, indpndntItr, context,
+                projAttrib, conditioningNeeded);
+          }
+
+        } else {
-      
-      if(conditioningNeeded) {
-        results =  QueryUtils.getconditionedIndexResults(results, indexInfo,
-            context, indexFieldsSize, completeExpansionNeeded,
-            iterOperands, indpndntItr);        
-      }else {       
-        if(isIntersection && intermediateResults != null) {
+
+      if (conditioningNeeded) {
+        results = QueryUtils.getconditionedIndexResults(results, indexInfo, context,
+            indexFieldsSize, completeExpansionNeeded, iterOperands, indpndntItr);
+      } else {
+        if (isIntersection && intermediateResults != null) {
-    }
-    finally {
+    } finally {
-  public boolean isProjectionEvaluationAPossibility(ExecutionContext context)
-  {
+  public boolean isProjectionEvaluationAPossibility(ExecutionContext context) {
-  
+
-  public boolean isLimitApplicableAtIndexLevel(ExecutionContext context)  {
+  public boolean isLimitApplicableAtIndexLevel(ExecutionContext context) {
-  
+
-      String canonicalizedOrderByClause) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {   
+      String canonicalizedOrderByClause) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
-  public boolean isConditioningNeededForIndex(RuntimeIterator independentIter, 
-      ExecutionContext context, boolean completeExpnsNeeded) throws AmbiguousNameException, TypeMismatchException, NameResolutionException  {
+
+  public boolean isConditioningNeededForIndex(RuntimeIterator independentIter,
+      ExecutionContext context, boolean completeExpnsNeeded)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-      indexFieldsSize = ((StructTypeImpl)indexRsltType).getFieldNames().length;
+      indexFieldsSize = ((StructTypeImpl) indexRsltType).getFieldNames().length;
+    } else {
+      indexFieldsSize = 1;
-    else {
-      indexFieldsSize = 1;      
-    }
-    
-    if (independentIter != null   && indexFieldsSize == 1) {
-      ich = new IndexConditioningHelper(idxInfo[0], context, indexFieldsSize,
-          completeExpnsNeeded, null, independentIter);
+
+    if (independentIter != null && indexFieldsSize == 1) {
+      ich = new IndexConditioningHelper(idxInfo[0], context, indexFieldsSize, completeExpnsNeeded,
+          null, independentIter);
-  
+
-   * evaluate as a filter, producing an intermediate result set. This may
-   * require iteration if there is no index available. Asif :The booelan true
-   * implies that CompiledComparsion when existing on its own always requires a
-   * Completeexpansion to top level iterators. This flag can get toggled to
-   * false only from inside a GroupJunction
+   * evaluate as a filter, producing an intermediate result set. This may require iteration if there
+   * is no index available. Asif :The booelan true implies that CompiledComparsion when existing on
+   * its own always requires a Completeexpansion to top level iterators. This flag can get toggled
+   * to false only from inside a GroupJunction
-   * @param intermediateResults
-   *          if this parameter is provided, and we have to iterate, then
-   *          iterate over this result set instead of the entire base
-   *          collection.
+   * @param intermediateResults if this parameter is provided, and we have to iterate, then iterate
+   *        over this result set instead of the entire base collection.
-  public SelectResults filterEvaluate(ExecutionContext context,
-      SelectResults intermediateResults) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+  public SelectResults filterEvaluate(ExecutionContext context, SelectResults intermediateResults)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-    Set rntmItrs =  QueryUtils.getCurrentScopeUltimateRuntimeIteratorsIfAny(this,context);
-    if(rntmItrs.size() ==1 && currentScopeIndpndntItrs.size() == 1 ) {
-      indpndntItr = (RuntimeIterator)rntmItrs.iterator().next();
+    Set rntmItrs = QueryUtils.getCurrentScopeUltimateRuntimeIteratorsIfAny(this, context);
+    if (rntmItrs.size() == 1 && currentScopeIndpndntItrs.size() == 1) {
+      indpndntItr = (RuntimeIterator) rntmItrs.iterator().next();
-    
+
-                                                             * Complete
-                                                             * Expansion needed
-                                                             */, null, indpndntItr !=null?new RuntimeIterator[]{indpndntItr}:null/*
-                    * Asif :It is safe to pass null as the independent iterator
-                    * to which the condition belongs is required only if boolean
-                    * complete expansion turns out to be false, which can happen
-                    * only in case of CompiledComparison/CompiledUndefined
-                    * called from roupJunction or CompositeGroupJunction
-                    */,true /*is intersection*/,this.isConditioningNeededForIndex(indpndntItr, context, true), true);
+                                                             * Complete Expansion needed
+                                                             */, null,
+        indpndntItr != null ? new RuntimeIterator[] {indpndntItr}
+            : null/*
+                   * Asif :It is safe to pass null as the independent iterator to which the
+                   * condition belongs is required only if boolean complete expansion turns out to
+                   * be false, which can happen only in case of CompiledComparison/CompiledUndefined
+                   * called from roupJunction or CompositeGroupJunction
+                   */,
+        true /* is intersection */, this.isConditioningNeededForIndex(indpndntItr, context, true),
+        true);
-   * Asif : This function should never get invoked as now if a CompiledJunction
-   * or GroupJunction contains a single filterable CompiledComparison it should
-   * directly call filterEvaluate rather than auxFilterEvalutae. Overriding this
-   * function just for ensuring that auxFilterEvaluate is not being called by
-   * mistake.
+   * Asif : This function should never get invoked as now if a CompiledJunction or GroupJunction
+   * contains a single filterable CompiledComparison it should directly call filterEvaluate rather
+   * than auxFilterEvalutae. Overriding this function just for ensuring that auxFilterEvaluate is
+   * not being called by mistake.
-      SelectResults intermediateResults) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
-    Support
-        .assertionFailed(" This auxFilterEvaluate of CompiledIn should never have got invoked.");
+      SelectResults intermediateResults) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
+    Support.assertionFailed(" This auxFilterEvaluate of CompiledIn should never have got invoked.");
-  public boolean isBetterFilter(Filter comparedTo, ExecutionContext context, final int thisSize) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException 
-  {
-    //If the current filter is equality & comparedTo filter is also equality based , then 
+
+  public boolean isBetterFilter(Filter comparedTo, ExecutionContext context, final int thisSize)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
+    // If the current filter is equality & comparedTo filter is also equality based , then
-   
+
-    int thatOperator = comparedTo.getOperator() ;    
-    
-    //Go with the lowest cost when hint is used.  
-    if (context instanceof QueryExecutionContext && ((QueryExecutionContext)context).hasHints()) {
+    int thatOperator = comparedTo.getOperator();
+
+    // Go with the lowest cost when hint is used.
+    if (context instanceof QueryExecutionContext && ((QueryExecutionContext) context).hasHints()) {
-        
-    switch(thatOperator) {
-        case TOK_EQ:
-        case TOK_NE:
-        case TOK_NE_ALT:
-           isThisBetter = thisSize < thatSize;
-           break;
-        case LITERAL_and:
-         //Asif: Give preference to IN . Is this right? It does not appear . Ideally we need to get
-          //some estimate on Range. This case is possible only in case of RangeJunction
-          break;
-        case TOK_LE:
-        case TOK_LT:
-        case TOK_GE:
-        case TOK_GT:
-          //Give preference to this rather than that as this is more deterministic
-          break;
-        default :
-            throw  new IllegalArgumentException("The operator type ="+ thatOperator + " is unknown");
-    }          
-      
+
+    switch (thatOperator) {
+      case TOK_EQ:
+      case TOK_NE:
+      case TOK_NE_ALT:
+        isThisBetter = thisSize < thatSize;
+        break;
+      case LITERAL_and:
+        // Asif: Give preference to IN . Is this right? It does not appear . Ideally we need to get
+        // some estimate on Range. This case is possible only in case of RangeJunction
+        break;
+      case TOK_LE:
+      case TOK_LT:
+      case TOK_GE:
+      case TOK_GT:
+        // Give preference to this rather than that as this is more deterministic
+        break;
+      default:
+        throw new IllegalArgumentException("The operator type =" + thatOperator + " is unknown");
+    }
+
-  public int getSizeEstimate(ExecutionContext context)throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException  {
+
+  public int getSizeEstimate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    
+
-    
+
-    
+
-      Iterator itr = ((Map)evalColln).entrySet().iterator();
-      while (itr.hasNext()) {        
-        size+=idxInfo[0]._index.getSizeEstimate(itr.next(), TOK_EQ, idxInfo[0]._matchLevel);                  
+      Iterator itr = ((Map) evalColln).entrySet().iterator();
+      while (itr.hasNext()) {
+        size += idxInfo[0]._index.getSizeEstimate(itr.next(), TOK_EQ, idxInfo[0]._matchLevel);
-    }
-    else if (evalColln instanceof Collection) {
+    } else if (evalColln instanceof Collection) {
-        Iterator iterator = ((ResultsSet)((Object[]) key)[0]).iterator();
+        Iterator iterator = ((ResultsSet) ((Object[]) key)[0]).iterator();
-          size+=idxInfo[0]._index.getSizeEstimate(new Object[]{iterator.next(), ((Object[])key)[1]}, TOK_EQ, idxInfo[0]._matchLevel);
+          size += idxInfo[0]._index.getSizeEstimate(
+              new Object[] {iterator.next(), ((Object[]) key)[1]}, TOK_EQ, idxInfo[0]._matchLevel);
-      }
-      else {
+      } else {
-    }
-    else {
+    } else {
-        throw new TypeMismatchException(
-            "Operand of IN cannot be interpreted as a Collection. "
-                + "Is instance of " + evalColln.getClass().getName());
+        throw new TypeMismatchException("Operand of IN cannot be interpreted as a Collection. "
+            + "Is instance of " + evalColln.getClass().getName());
-        Object[] arr = (Object[])evalColln;
+        Object[] arr = (Object[]) evalColln;
-          size+=idxInfo[0]._index.getSizeEstimate(arr[i], TOK_EQ, idxInfo[0]._matchLevel);
+          size += idxInfo[0]._index.getSizeEstimate(arr[i], TOK_EQ, idxInfo[0]._matchLevel);
-      }
-      else if (evalColln instanceof long[]) {
-        long[] a = (long[])evalColln;
-        for (int i = 0; i < a.length; i++) {         
-          size+=idxInfo[0]._index.getSizeEstimate(Long.valueOf(a[i]), TOK_EQ, idxInfo[0]._matchLevel);
+      } else if (evalColln instanceof long[]) {
+        long[] a = (long[]) evalColln;
+        for (int i = 0; i < a.length; i++) {
+          size +=
+              idxInfo[0]._index.getSizeEstimate(Long.valueOf(a[i]), TOK_EQ, idxInfo[0]._matchLevel);
-      }
-      else if (evalColln instanceof double[]) {
-        double[] a = (double[])evalColln;
-        for (int i = 0; i < a.length; i++) {          
-          size+=idxInfo[0]._index.getSizeEstimate(Double.valueOf(a[i]), TOK_EQ, idxInfo[0]._matchLevel);          
+      } else if (evalColln instanceof double[]) {
+        double[] a = (double[]) evalColln;
+        for (int i = 0; i < a.length; i++) {
+          size += idxInfo[0]._index.getSizeEstimate(Double.valueOf(a[i]), TOK_EQ,
+              idxInfo[0]._matchLevel);
-      }
-      else if (evalColln instanceof float[]) {
-        float[] a = (float[])evalColln;
-        for (int i = 0; i < a.length; i++) {          
-          size+=idxInfo[0]._index.getSizeEstimate(new Float(a[i]), TOK_EQ, idxInfo[0]._matchLevel);
-          
+      } else if (evalColln instanceof float[]) {
+        float[] a = (float[]) evalColln;
+        for (int i = 0; i < a.length; i++) {
+          size +=
+              idxInfo[0]._index.getSizeEstimate(new Float(a[i]), TOK_EQ, idxInfo[0]._matchLevel);
+
-      }
-      else if (evalColln instanceof int[]) {
-        int[] a = (int[])evalColln;
-        for (int i = 0; i < a.length; i++) {          
-          size+=idxInfo[0]._index.getSizeEstimate(Integer.valueOf(a[i]), TOK_EQ, idxInfo[0]._matchLevel);
+      } else if (evalColln instanceof int[]) {
+        int[] a = (int[]) evalColln;
+        for (int i = 0; i < a.length; i++) {
+          size += idxInfo[0]._index.getSizeEstimate(Integer.valueOf(a[i]), TOK_EQ,
+              idxInfo[0]._matchLevel);
-      }
-      else if (evalColln instanceof short[]) {
-        short[] a = (short[])evalColln;
-        for (int i = 0; i < a.length; i++) {          
-          size+=idxInfo[0]._index.getSizeEstimate(new Short(a[i]), TOK_EQ, idxInfo[0]._matchLevel);
-          
+      } else if (evalColln instanceof short[]) {
+        short[] a = (short[]) evalColln;
+        for (int i = 0; i < a.length; i++) {
+          size +=
+              idxInfo[0]._index.getSizeEstimate(new Short(a[i]), TOK_EQ, idxInfo[0]._matchLevel);
+
-      }
-      else if (evalColln instanceof char[]) {
-        char[] a = (char[])evalColln;
-        for (int i = 0; i < a.length; i++) {          
-          size+=idxInfo[0]._index.getSizeEstimate(new Character(a[i]), TOK_EQ, idxInfo[0]._matchLevel);
+      } else if (evalColln instanceof char[]) {
+        char[] a = (char[]) evalColln;
+        for (int i = 0; i < a.length; i++) {
+          size += idxInfo[0]._index.getSizeEstimate(new Character(a[i]), TOK_EQ,
+              idxInfo[0]._matchLevel);
-      }
-      else if (evalColln instanceof byte[]) {
-        byte[] a = (byte[])evalColln;
-        for (int i = 0; i < a.length; i++) {         
-          size+=idxInfo[0]._index.getSizeEstimate(new Byte(a[i]), TOK_EQ, idxInfo[0]._matchLevel);
-          
+      } else if (evalColln instanceof byte[]) {
+        byte[] a = (byte[]) evalColln;
+        for (int i = 0; i < a.length; i++) {
+          size += idxInfo[0]._index.getSizeEstimate(new Byte(a[i]), TOK_EQ, idxInfo[0]._matchLevel);
+
-      }
-      else {
+      } else {
-    
+
-  public boolean isRangeEvaluatable() {	
-	return false;
+  public boolean isRangeEvaluatable() {
+    return false;
-  
+

MOV26 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
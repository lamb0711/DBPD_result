GEODE-730: Optimize single filter join queries

When executing a join query with additional filters on a single region, we now detect this scenario and
instead of creating a CompositeGroupJunction, we create a regular GroupJunction.  When we being cutdown
and expansion, we then create new compiled comparisons so that we can do an index lookup.

For example "select * from /region1 a, /region2 b where a.name = "joe" and a.id = b.id"
We will now execute the a.name first assuming an index is present on a.name

During cutdown and expand, we determine that the comparison a.id = b.id can create a new compiled comparison
because the alias a from a.id matches our original filter a.name.  We can evaluate a.id at this point, say id
evaluated to 8.  So we create a compiled comparison of b.id = 8.  We can now do a lookup using the index on b.id.
We retrieve these results and place them into a map.  This map will be used to continue to derive additional joins
if they exist.  Such as b.id = c.id, etc...

We can continue with the iteration but instead of iterating the entire b region, we can now go over derived results.

This also includes a fix to not unlock an index lock when reevaluating an inner query.

+  
+  /*
+   * Set in context for the where clause to signify that it has been evaluated at least one time
+   * for any other CompiledValue that may use precalculated indexes
+   * we want to mark this as Evaluated so that we don't unlock locks
+   * that don't belong to this iteration of evaluate.
+   * This is similar to how CompiledComparisons store their IndexInfo in the context
+   * but for example a CompiledJunction that uses 2 Comparisons
+   * would have unlocked the readlocks because we check to see if the clause has a mapped value
+   * in the context. Because CompiledJunctions did not, we unlocked the read locks.
+   * Now we set a value so that it will not do this. See where we use this value to see how unlock is determined
+   */
+  private final static String CLAUSE_EVALUATED = "Evaluated";
-          if(obj != null && obj instanceof IndexInfo[]) {
+          if(obj != null && (obj instanceof IndexInfo[] || obj.equals(CLAUSE_EVALUATED))) {
+          if (context.cacheGet(this.whereClause) == null) {
+            context.cachePut(this.whereClause, CLAUSE_EVALUATED);
+          }
-	}
+  }
-	}
+  }

INS23 INS83 INS83 INS83 INS43 INS59 INS42 INS42 INS45 INS25 INS27 INS8 INS36 INS32 INS33 INS21 INS27 INS42 INS42 INS22 INS32 MOV62 INS32 INS52 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS42 INS52 INS42
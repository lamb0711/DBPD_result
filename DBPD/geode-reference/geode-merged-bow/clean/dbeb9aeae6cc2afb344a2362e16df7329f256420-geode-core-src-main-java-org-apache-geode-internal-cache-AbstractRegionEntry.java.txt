Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Abstract implementation class of RegionEntry interface.
- * This is the topmost implementation class so common behavior
- * lives here.
+ * Abstract implementation class of RegionEntry interface. This is the topmost implementation class
+ * so common behavior lives here.
-public abstract class AbstractRegionEntry implements RegionEntry,
-    HashEntry<Object, Object> {
+public abstract class AbstractRegionEntry implements RegionEntry, HashEntry<Object, Object> {
-  
+
-   * Whether to disable last access time update when a put occurs. The default
-   * is false (enable last access time update on put). To disable it, set the
-   * 'gemfire.disableAccessTimeUpdateOnPut' system property.
+   * Whether to disable last access time update when a put occurs. The default is false (enable last
+   * access time update on put). To disable it, set the 'gemfire.disableAccessTimeUpdateOnPut'
+   * system property.
-  protected static final boolean DISABLE_ACCESS_TIME_UPDATE_ON_PUT = Boolean
-      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "disableAccessTimeUpdateOnPut");
+  protected static final boolean DISABLE_ACCESS_TIME_UPDATE_ON_PUT =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "disableAccessTimeUpdateOnPut");
-   * Flags for a Region Entry.
-   * These flags are stored in the msb of the long used to also store the lastModicationTime.
+   * Flags for a Region Entry. These flags are stored in the msb of the long used to also store the
+   * lastModicationTime.
-  private static final long VALUE_RESULT_OF_SEARCH          = 0x01L<<56;
-  private static final long UPDATE_IN_PROGRESS              = 0x02L<<56;
-  private static final long TOMBSTONE_SCHEDULED             = 0x04L<<56;
-  private static final long LISTENER_INVOCATION_IN_PROGRESS = 0x08L<<56;
-  /**  used for LRUEntry instances. */
-  protected static final long RECENTLY_USED = 0x10L<<56;
-  /**  used for LRUEntry instances. */
-  protected static final long EVICTED = 0x20L<<56;
+  private static final long VALUE_RESULT_OF_SEARCH = 0x01L << 56;
+  private static final long UPDATE_IN_PROGRESS = 0x02L << 56;
+  private static final long TOMBSTONE_SCHEDULED = 0x04L << 56;
+  private static final long LISTENER_INVOCATION_IN_PROGRESS = 0x08L << 56;
+  /** used for LRUEntry instances. */
+  protected static final long RECENTLY_USED = 0x10L << 56;
+  /** used for LRUEntry instances. */
+  protected static final long EVICTED = 0x20L << 56;
-   * Set if the entry is being used by a transactions.
-   * Some features (eviction and expiration) will not modify an entry when a tx is using it
-   * to prevent the tx to fail do to conflict.
+   * Set if the entry is being used by a transactions. Some features (eviction and expiration) will
+   * not modify an entry when a tx is using it to prevent the tx to fail do to conflict.
-  protected static final long IN_USE_BY_TX = 0x40L<<56;
+  protected static final long IN_USE_BY_TX = 0x40L << 56;
-  protected static final long MARKED_FOR_EVICTION = 0x80L<<56;
-//  public Exception removeTrace; // debugging hot loop in AbstractRegionMap.basicPut()
-  
+  protected static final long MARKED_FOR_EVICTION = 0x80L << 56;
+  // public Exception removeTrace; // debugging hot loop in AbstractRegionMap.basicPut()
+
-    
-    setValue(context,this.prepareValueForCache(context, value, false),false);
-//    setLastModified(System.currentTimeMillis()); [bruce] this must be set later so we can use ==0 to know this is a new entry in checkForConflicts
+
+    setValue(context, this.prepareValueForCache(context, value, false), false);
+    // setLastModified(System.currentTimeMillis()); [bruce] this must be set later so we can use ==0
+    // to know this is a new entry in checkForConflicts
-  
+
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="IMSE_DONT_CATCH_IMSE")
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "IMSE_DONT_CATCH_IMSE")
-       return true;
+      return true;
-    
+
-    
+
+  /**
+   * This sets the lastModified time for the entry. In subclasses with statistics it will also set
+   * the lastAccessed time unless the system property gemfire.disableAccessTimeUpdateOnPut is set to
+   * true.
+   * 
+   * @param lastModified the time of last modification of the entry
+   */
+    setLastModifiedAndAccessedTimes(lastModified, lastModified);
+  }
+
+  /**
+   * This sets the lastModified and lastAccessed time for the entry. Subclasses that do not keep
+   * track of lastAccessed time will ignore the second parameter.
+   * 
+   * @param lastModified the time of last modification of the entry
+   * @param lastAccessed the time the entry was last accessed
+   */
+  protected void setLastModifiedAndAccessedTimes(long lastModified, long lastAccessed) {
-  }        
+  }
-    setLastModified(currTime);
+    setLastModifiedAndAccessedTimes(currTime, currTime);
-  
-  public final void updateStatsForPut(long lastModifiedTime) {
-    setLastModified(lastModifiedTime);
+
+  public final void updateStatsForPut(long lastModifiedTime, long lastAccessedTime) {
+    setLastModifiedAndAccessedTimes(lastModifiedTime, lastAccessedTime);
-  
+
-    
+
-    
+
-//    this.removeTrace = new Exception("stack trace for thread " + Thread.currentThread());
+    // this.removeTrace = new Exception("stack trace for thread " + Thread.currentThread());
+
-  
+
-//    this.removeTrace = new Exception("stack trace for thread " + Thread.currentThread());
+    // this.removeTrace = new Exception("stack trace for thread " + Thread.currentThread());
-  
+
-    if (r.getServerProxy() == null &&
-        r.getVersionVector().isTombstoneTooOld(version.getMemberID(), version.getRegionVersion())) {
+    if (r.getServerProxy() == null && r.getVersionVector().isTombstoneTooOld(version.getMemberID(),
+        version.getRegionVersion())) {
-        setValue(r, Token.TOMBSTONE);
+        basicMakeTombstone(r);
-      setValue(r, Token.TOMBSTONE);
+      basicMakeTombstone(r);
-  
-  @Override
-  public void setValueWithTombstoneCheck(@Unretained Object v, EntryEvent e) throws RegionClearedException {
-    if (v == Token.TOMBSTONE) {
-      makeTombstone((LocalRegion)e.getRegion(), ((EntryEventImpl)e).getVersionTag());
-    } else {
-      setValue((LocalRegion)e.getRegion(), v, (EntryEventImpl)e);
+  private void basicMakeTombstone(LocalRegion r) throws RegionClearedException {
+    boolean setValueCompleted = false;
+    try {
+      setValue(r, Token.TOMBSTONE);
+      setValueCompleted = true;
+    } finally {
+      if (!setValueCompleted && isTombstone()) {
+        removePhase2();
+      }
-  
+
+
+  @Override
+  public void setValueWithTombstoneCheck(@Unretained Object v, EntryEvent e)
+      throws RegionClearedException {
+    if (v == Token.TOMBSTONE) {
+      makeTombstone((LocalRegion) e.getRegion(), ((EntryEventImpl) e).getVersionTag());
+    } else {
+      setValue((LocalRegion) e.getRegion(), v, (EntryEventImpl) e);
+    }
+  }
+
-   * TODO this method does NOT return true if the object
-   * is Token.DESTROYED. dispatchListenerEvents relies on that
-   * fact to avoid removing destroyed tokens from the map.
-   * We should refactor so that this method calls Token.isRemoved,
-   * and places that don't want a destroyed Token can explicitly check
-   * for a DESTROY token.
+   * TODO this method does NOT return true if the object is Token.DESTROYED. dispatchListenerEvents
+   * relies on that fact to avoid removing destroyed tokens from the map. We should refactor so that
+   * this method calls Token.isRemoved, and places that don't want a destroyed Token can explicitly
+   * check for a DESTROY token.
-  
+
-  
+
-  
+
-  
+
-  
+
-                             @Retained(ABSTRACT_REGION_ENTRY_FILL_IN_VALUE) InitialImageOperation.Entry dst,
-                             ByteArrayDataInput in,
-                             DM mgr)
-  {
+      @Retained(ABSTRACT_REGION_ENTRY_FILL_IN_VALUE) InitialImageOperation.Entry dst,
+      ByteArrayDataInput in, DM mgr) {
-    @Retained(ABSTRACT_REGION_ENTRY_FILL_IN_VALUE) final Object v;
+    @Retained(ABSTRACT_REGION_ENTRY_FILL_IN_VALUE)
+    final Object v;
-    }
-    else if (v == Token.LOCAL_INVALID) {
+    } else if (v == Token.LOCAL_INVALID) {
-    }
-    else if (v == Token.TOMBSTONE) {
+    } else if (v == Token.TOMBSTONE) {
-    }
-    else if (v instanceof CachedDeserializable) {
+    } else if (v instanceof CachedDeserializable) {
-              HeapDataOutputStream hdos = new HeapDataOutputStream(
-                  Version.CURRENT);
+              HeapDataOutputStream hdos = new HeapDataOutputStream(Version.CURRENT);
-    }
-    else if (v instanceof byte[]) {
+    } else if (v instanceof byte[]) {
-    }
-    else { 
+    } else {
-    {
-      try {
-        HeapDataOutputStream hdos = new HeapDataOutputStream(Version.CURRENT);
-        BlobHelper.serializeTo(preparedValue, hdos);
-        hdos.trim();
-        dst.value = hdos;
-        dst.setSerialized(true);
-      } catch (IOException e) {
-        RuntimeException e2 = new IllegalArgumentException(LocalizedStrings.AbstractRegionEntry_AN_IOEXCEPTION_WAS_THROWN_WHILE_SERIALIZING.toLocalizedString());
-        e2.initCause(e);
-        throw e2;
+      {
+        try {
+          HeapDataOutputStream hdos = new HeapDataOutputStream(Version.CURRENT);
+          BlobHelper.serializeTo(preparedValue, hdos);
+          hdos.trim();
+          dst.value = hdos;
+          dst.setSerialized(true);
+        } catch (IOException e) {
+          RuntimeException e2 = new IllegalArgumentException(
+              LocalizedStrings.AbstractRegionEntry_AN_IOEXCEPTION_WAS_THROWN_WHILE_SERIALIZING
+                  .toLocalizedString());
+          e2.initCause(e);
+          throw e2;
+        }
-    }
-  
+
-   * To fix bug 49901 if v is a GatewaySenderEventImpl then make
-   * a heap copy of it if it is offheap.
+   * To fix bug 49901 if v is a GatewaySenderEventImpl then make a heap copy of it if it is offheap.
+   * 
-  
+
-    @Retained Object result = _getValueRetain(context, true);
-    //Asif: If the thread is an Index Creation Thread & the value obtained is 
-    //Token.REMOVED , we can skip  synchronization block. This is required to prevent
+    @Retained
+    Object result = _getValueRetain(context, true);
+    // Asif: If the thread is an Index Creation Thread & the value obtained is
+    // Token.REMOVED , we can skip synchronization block. This is required to prevent
-    // gets the temporary value of token.REMOVED as the  correct value will get indexed
+    // gets the temporary value of token.REMOVED as the correct value will get indexed
-//    if ((result == Token.REMOVED_PHASE1 || result == Token.REMOVED_PHASE2) && !r.isIndexCreationThread()) {
-//      synchronized (this) {
-//        result = _getValue();
-//      }
-//    }
-    
+    // if ((result == Token.REMOVED_PHASE1 || result == Token.REMOVED_PHASE2) &&
+    // !r.isIndexCreationThread()) {
+    // synchronized (this) {
+    // result = _getValue();
+    // }
+    // }
+
-  
+
-    @Retained Object result = _getValueRetain(context, true);
+    @Retained
+    Object result = _getValueRetain(context, true);
-  
+
-  public void setValue(RegionEntryContext context, @Unretained Object value) throws RegionClearedException {
+  public void setValue(RegionEntryContext context, @Unretained Object value)
+      throws RegionClearedException {
-    setValue(context,value,true);
+    setValue(context, value, true);
-  
+
-  public void setValue(RegionEntryContext context, Object value, EntryEventImpl event) throws RegionClearedException {
-    setValue(context,value);
+  public void setValue(RegionEntryContext context, Object value, EntryEventImpl event)
+      throws RegionClearedException {
+    setValue(context, value);
-  
+
-  protected void setValue(RegionEntryContext context, @Unretained Object value, boolean recentlyUsed) {
+  protected void setValue(RegionEntryContext context, @Unretained Object value,
+      boolean recentlyUsed) {
-  public void releaseOffHeapRefIfRegionBeingClosedOrDestroyed(
-      RegionEntryContext context, Object ref) {
+  public void releaseOffHeapRefIfRegionBeingClosedOrDestroyed(RegionEntryContext context,
+      Object ref) {
-      ((OffHeapRegionEntry)this).release();
+      ((OffHeapRegionEntry) this).release();
-        && ((LocalRegion)context).isThisRegionBeingClosedOrDestroyed();
+        && ((LocalRegion) context).isThisRegionBeingClosedOrDestroyed();
-        && ref instanceof StoredObject && ((StoredObject)ref).hasRefCount();
+        && ref instanceof StoredObject && ((StoredObject) ref).hasRefCount();
-   * This method determines if the value is in a compressed representation and decompresses it if it is.
+   * This method determines if the value is in a compressed representation and decompresses it if it
+   * is.
-   * @param context the values context. 
+   * @param context the values context.
-  static Object decompress(RegionEntryContext context,Object value) {
-    if(isCompressible(context, value)) {
+  static Object decompress(RegionEntryContext context, Object value) {
+    if (isCompressible(context, value)) {
-      context.getCachePerfStats().endDecompression(time);      
+      context.getCachePerfStats().endDecompression(time);
-    
+
-  
-  static protected Object compress(RegionEntryContext context,Object value) {
+
+  static protected Object compress(RegionEntryContext context, Object value) {
-    /**
+  /**
-   * @param context the values context. 
+   * @param context the values context.
-  static protected Object compress(RegionEntryContext context,Object value, EntryEventImpl event) {
-    if(isCompressible(context, value)) {
+  static protected Object compress(RegionEntryContext context, Object value, EntryEventImpl event) {
+    if (isCompressible(context, value)) {
-            serializedValue = EntryEventImpl.serialize(CachedDeserializableFactory.create(serializedValue));
+            serializedValue =
+                EntryEventImpl.serialize(CachedDeserializableFactory.create(serializedValue));
-              event.setCachedSerializedNewValue((byte[])cdVal);
+              event.setCachedSerializedNewValue((byte[]) cdVal);
-      context.getCachePerfStats().endCompression(time, serializedValue.length, ((byte []) value).length);
+      context.getCachePerfStats().endCompression(time, serializedValue.length,
+          ((byte[]) value).length);
-    
-    return value;    
+
+    return value;
-  
+
-  
-  
+
+
-    @Released Object v = _getValueRetain(context, true);
-    
+    @Released
+    Object v = _getValueRetain(context, true);
+
-  
-  public  Object getValueInVMOrDiskWithoutFaultIn(LocalRegion owner) {
-   return getValueInVM(owner);
+
+  public Object getValueInVMOrDiskWithoutFaultIn(LocalRegion owner) {
+    return getValueInVM(owner);
-  
+
-    @Retained Object result = _getValueRetain(owner, true);
-//    if (result instanceof ByteSource) {
-//      // If the ByteSource contains a Delta or ListOfDelta then we want to deserialize it
-//      Object deserVal = ((CachedDeserializable)result).getDeserializedForReading();
-//      if (deserVal != result) {
-//        OffHeapHelper.release(result);
-//        result = deserVal;
-//      }
-//    }
+    @Retained
+    Object result = _getValueRetain(owner, true);
+    // if (result instanceof ByteSource) {
+    // // If the ByteSource contains a Delta or ListOfDelta then we want to deserialize it
+    // Object deserVal = ((CachedDeserializable)result).getDeserializedForReading();
+    // if (deserVal != result) {
+    // OffHeapHelper.release(result);
+    // result = deserVal;
+    // }
+    // }
-  
-  public Object getValueOnDisk(LocalRegion r)
-  throws EntryNotFoundException
-  {
-    throw new IllegalStateException(LocalizedStrings.AbstractRegionEntry_CANNOT_GET_VALUE_ON_DISK_FOR_A_REGION_THAT_DOES_NOT_ACCESS_THE_DISK.toLocalizedString());
+
+  public Object getValueOnDisk(LocalRegion r) throws EntryNotFoundException {
+    throw new IllegalStateException(
+        LocalizedStrings.AbstractRegionEntry_CANNOT_GET_VALUE_ON_DISK_FOR_A_REGION_THAT_DOES_NOT_ACCESS_THE_DISK
+            .toLocalizedString());
-  public Object getSerializedValueOnDisk(final LocalRegion r)
-  throws EntryNotFoundException
-  {
-    throw new IllegalStateException(LocalizedStrings.AbstractRegionEntry_CANNOT_GET_VALUE_ON_DISK_FOR_A_REGION_THAT_DOES_NOT_ACCESS_THE_DISK.toLocalizedString());
+  public Object getSerializedValueOnDisk(final LocalRegion r) throws EntryNotFoundException {
+    throw new IllegalStateException(
+        LocalizedStrings.AbstractRegionEntry_CANNOT_GET_VALUE_ON_DISK_FOR_A_REGION_THAT_DOES_NOT_ACCESS_THE_DISK
+            .toLocalizedString());
-  
- public Object getValueOnDiskOrBuffer(LocalRegion r)
-  throws EntryNotFoundException
- {
-  throw new IllegalStateException(LocalizedStrings.AbstractRegionEntry_CANNOT_GET_VALUE_ON_DISK_FOR_A_REGION_THAT_DOES_NOT_ACCESS_THE_DISK.toLocalizedString());
-  // @todo darrel if value is Token.REMOVED || Token.DESTROYED throw EntryNotFoundException
- }
-  public final boolean initialImagePut(final LocalRegion region,
-                                       final long lastModifiedTime,
-                                       Object newValue,
-                                       boolean wasRecovered,
-                                       boolean versionTagAccepted) throws RegionClearedException
-  {
+  public Object getValueOnDiskOrBuffer(LocalRegion r) throws EntryNotFoundException {
+    throw new IllegalStateException(
+        LocalizedStrings.AbstractRegionEntry_CANNOT_GET_VALUE_ON_DISK_FOR_A_REGION_THAT_DOES_NOT_ACCESS_THE_DISK
+            .toLocalizedString());
+    // @todo darrel if value is Token.REMOVED || Token.DESTROYED throw EntryNotFoundException
+  }
+
+  public final boolean initialImagePut(final LocalRegion region, final long lastModifiedTime,
+      Object newValue, boolean wasRecovered, boolean versionTagAccepted)
+      throws RegionClearedException {
-    return initialImageInit(region, lastModifiedTime, newValue, this.isTombstone(), wasRecovered, versionTagAccepted);
+    return initialImageInit(region, lastModifiedTime, newValue, this.isTombstone(), wasRecovered,
+        versionTagAccepted);
-  public boolean initialImageInit(final LocalRegion region,
-                                        final long lastModifiedTime,
-                                        final Object newValue,
-                                        final boolean create,
-                                        final boolean wasRecovered,
-                                        final boolean versionTagAccepted) throws RegionClearedException
-  {
+  public boolean initialImageInit(final LocalRegion region, final long lastModifiedTime,
+      final Object newValue, final boolean create, final boolean wasRecovered,
+      final boolean versionTagAccepted) throws RegionClearedException {
-    if (versionTagAccepted || create || (vTok != Token.DESTROYED || vTok != Token.TOMBSTONE)) { // OFFHEAP noop
+    if (versionTagAccepted || create || (vTok != Token.DESTROYED || vTok != Token.TOMBSTONE)) { // OFFHEAP
+                                                                                                // noop
-      boolean putValue = versionTagAccepted || create
-        || (newValueToWrite != Token.LOCAL_INVALID
-            && (wasRecovered || (vTok == Token.LOCAL_INVALID))); // OFFHEAP noop
-    
-      if (region.isUsedForPartitionedRegionAdmin() && newValueToWrite instanceof CachedDeserializable) {
+      boolean putValue = versionTagAccepted || create || (newValueToWrite != Token.LOCAL_INVALID
+          && (wasRecovered || (vTok == Token.LOCAL_INVALID))); // OFFHEAP noop
+
+      if (region.isUsedForPartitionedRegionAdmin()
+          && newValueToWrite instanceof CachedDeserializable) {
-        newValueToWrite = ((CachedDeserializable) newValueToWrite).getDeserializedValue(region, null);
+        newValueToWrite =
+            ((CachedDeserializable) newValueToWrite).getDeserializedValue(region, null);
-          final Object oldValue = getValueInVM(region); // Heap value should always be deserialized at this point // OFFHEAP will not be deserialized
+          final Object oldValue = getValueInVM(region); // Heap value should always be deserialized
+                                                        // at this point // OFFHEAP will not be
+                                                        // deserialized
-          if(oldValue == null) {
-          	putValue = true;
-          }
-          else if (oldValue instanceof Versionable) {
+          if (oldValue == null) {
+            putValue = true;
+          } else if (oldValue instanceof Versionable) {
-          }  
+          }
-          }
-          else if (imageState.getClearRegionFlag()) {
+          } else if (imageState.getClearRegionFlag()) {
-              //Asif: If the region has been issued cleared during
+              // Asif: If the region has been issued cleared during
-              throw new RegionClearedException(LocalizedStrings.AbstractRegionEntry_DURING_THE_GII_PUT_OF_ENTRY_THE_REGION_GOT_CLEARED_SO_ABORTING_THE_OPERATION.toLocalizedString());
+              throw new RegionClearedException(
+                  LocalizedStrings.AbstractRegionEntry_DURING_THE_GII_PUT_OF_ENTRY_THE_REGION_GOT_CLEARED_SO_ABORTING_THE_OPERATION
+                      .toLocalizedString());
-        } 
+        }
-        if (newValueToWrite != Token.TOMBSTONE){
+        if (newValueToWrite != Token.TOMBSTONE) {
-        
+
-                region.getFullPath(), getKey(),((CachedDeserializable)newValueToWrite).getStringForm());
-          }
-          else {
-            logger.trace("ProcessChunk: region={}; put({},{})", region.getFullPath(), getKey(), StringUtils.forceToString(newValueToWrite));
+                region.getFullPath(), getKey(),
+                ((CachedDeserializable) newValueToWrite).getStringForm());
+          } else {
+            logger.trace("ProcessChunk: region={}; put({},{})", region.getFullPath(), getKey(),
+                StringUtils.forceToString(newValueToWrite));
- 
+
-   * @throws EntryNotFoundException if expectedOldValue is
-   * not null and is not equal to current value
+   * @throws EntryNotFoundException if expectedOldValue is not null and is not equal to current
+   *         value
-  public final boolean destroy(LocalRegion region,
-                            EntryEventImpl event,
-                            boolean inTokenMode,
-                            boolean cacheWrite,
-                            @Unretained Object expectedOldValue,
-                            boolean forceDestroy,
-                            boolean removeRecoveredEntry)
-    throws CacheWriterException,
-           EntryNotFoundException,
-           TimeoutException,
-           RegionClearedException {
+  public final boolean destroy(LocalRegion region, EntryEventImpl event, boolean inTokenMode,
+      boolean cacheWrite, @Unretained Object expectedOldValue, boolean forceDestroy,
+      boolean removeRecoveredEntry) throws CacheWriterException, EntryNotFoundException,
+      TimeoutException, RegionClearedException {
-    // A design decision was made to not retrieve the old value from the disk
-    // if the entry has been evicted to only have the CacheListener afterDestroy
-    // method ignore it. We don't want to pay the performance penalty. The 
-    // getValueInVM method does not retrieve the value from disk if it has been
-    // evicted. Instead, it uses the NotAvailable token.
-    //
-    // If the region is a WAN queue region, the old value is actually used by the 
-    // afterDestroy callback on a secondary. It is not needed on a primary.
-    // Since the destroy that sets WAN_QUEUE_TOKEN always originates on the primary
-    // we only pay attention to WAN_QUEUE_TOKEN if the event is originRemote.
-    //
-    // :ezoerner:20080814 We also read old value from disk or buffer
-    // in the case where there is a non-null expectedOldValue
-    // see PartitionedRegion#remove(Object key, Object value)
-    ReferenceCountHelper.skipRefCountTracking();
-    @Retained @Released Object curValue = _getValueRetain(region, true);
-    ReferenceCountHelper.unskipRefCountTracking();
-    try {
-    if (curValue == null) curValue = Token.NOT_AVAILABLE;
-    
-    if (curValue == Token.NOT_AVAILABLE) {
-      // In some cases we need to get the current value off of disk.
-      
-      // if the event is transmitted during GII and has an old value, it was
-      // the state of the transmitting cache's entry & should be used here
-      if (event.getCallbackArgument() != null
-          && event.getCallbackArgument().equals(RegionQueue.WAN_QUEUE_TOKEN)
-          && event.isOriginRemote()) { // check originRemote for bug 40508
-        //curValue = getValue(region); can cause deadlock if GII is occurring
-        curValue = getValueOnDiskOrBuffer(region);
-      } 
-      else {
-        FilterProfile fp = region.getFilterProfile();
-        if (fp != null && ((fp.getCqCount() > 0) || expectedOldValue != null)) {
-          //curValue = getValue(region); can cause deadlock will fault in the value
-          // and will confuse LRU. rdubey.
-          curValue = getValueOnDiskOrBuffer(region);
-        }      
-      }
-    }
+      // A design decision was made to not retrieve the old value from the disk
+      // if the entry has been evicted to only have the CacheListener afterDestroy
+      // method ignore it. We don't want to pay the performance penalty. The
+      // getValueInVM method does not retrieve the value from disk if it has been
+      // evicted. Instead, it uses the NotAvailable token.
+      //
+      // If the region is a WAN queue region, the old value is actually used by the
+      // afterDestroy callback on a secondary. It is not needed on a primary.
+      // Since the destroy that sets WAN_QUEUE_TOKEN always originates on the primary
+      // we only pay attention to WAN_QUEUE_TOKEN if the event is originRemote.
+      //
+      // :ezoerner:20080814 We also read old value from disk or buffer
+      // in the case where there is a non-null expectedOldValue
+      // see PartitionedRegion#remove(Object key, Object value)
+      ReferenceCountHelper.skipRefCountTracking();
+      @Retained
+      @Released
+      Object curValue = _getValueRetain(region, true);
+      ReferenceCountHelper.unskipRefCountTracking();
+      try {
+        if (curValue == null)
+          curValue = Token.NOT_AVAILABLE;
-    if (expectedOldValue != null) {
-      if (!checkExpectedOldValue(expectedOldValue, curValue, region)) {
-        throw new EntryNotFoundException(
-          LocalizedStrings.AbstractRegionEntry_THE_CURRENT_VALUE_WAS_NOT_EQUAL_TO_EXPECTED_VALUE.toLocalizedString());
-      }
-    }
+        if (curValue == Token.NOT_AVAILABLE) {
+          // In some cases we need to get the current value off of disk.
-    if (inTokenMode && event.hasOldValue()) {
-      proceed = true;
-    }
-    else {
-      proceed = event.setOldValue(curValue, curValue instanceof GatewaySenderEventImpl) || removeRecoveredEntry
-                || forceDestroy || region.getConcurrencyChecksEnabled() // fix for bug #47868 - create a tombstone
-                || (event.getOperation() == Operation.REMOVE // fix for bug #42242
-                    && (curValue == null || curValue == Token.LOCAL_INVALID
-                        || curValue == Token.INVALID));
-    }
-    } finally {
-      OffHeapHelper.releaseWithNoTracking(curValue);
-    }
+          // if the event is transmitted during GII and has an old value, it was
+          // the state of the transmitting cache's entry & should be used here
+          if (event.getCallbackArgument() != null
+              && event.getCallbackArgument().equals(RegionQueue.WAN_QUEUE_TOKEN)
+              && event.isOriginRemote()) { // check originRemote for bug 40508
+            // curValue = getValue(region); can cause deadlock if GII is occurring
+            curValue = getValueOnDiskOrBuffer(region);
+          } else {
+            FilterProfile fp = region.getFilterProfile();
+            if (fp != null && ((fp.getCqCount() > 0) || expectedOldValue != null)) {
+              // curValue = getValue(region); can cause deadlock will fault in the value
+              // and will confuse LRU. rdubey.
+              curValue = getValueOnDiskOrBuffer(region);
+            }
+          }
+        }
+
+        if (expectedOldValue != null) {
+          if (!checkExpectedOldValue(expectedOldValue, curValue, region)) {
+            throw new EntryNotFoundException(
+                LocalizedStrings.AbstractRegionEntry_THE_CURRENT_VALUE_WAS_NOT_EQUAL_TO_EXPECTED_VALUE
+                    .toLocalizedString());
+          }
+        }
+
+        if (inTokenMode && event.hasOldValue()) {
+          proceed = true;
+        } else {
+          proceed = event.setOldValue(curValue, curValue instanceof GatewaySenderEventImpl)
+              || removeRecoveredEntry || forceDestroy || region.getConcurrencyChecksEnabled() // fix
+                                                                                              // for
+                                                                                              // bug
+                                                                                              // #47868
+                                                                                              // -
+                                                                                              // create
+                                                                                              // a
+                                                                                              // tombstone
+              || (event.getOperation() == Operation.REMOVE // fix for bug #42242
+                  && (curValue == null || curValue == Token.LOCAL_INVALID
+                      || curValue == Token.INVALID));
+        }
+      } finally {
+        OffHeapHelper.releaseWithNoTracking(curValue);
+      }
-    
+
-      //Generate the version tag if needed. This method should only be 
-      //called if we are in fact going to destroy the entry, so it must be
-      //after the entry not found exception above.
-      if(!removeRecoveredEntry) {
+      // Generate the version tag if needed. This method should only be
+      // called if we are in fact going to destroy the entry, so it must be
+      // after the entry not found exception above.
+      if (!removeRecoveredEntry) {
-            if(isValueNull()) {
-              @Released Object value = getValueOffHeapOrDiskWithoutFaultIn(region);
+            if (isValueNull()) {
+              @Released
+              Object value = getValueOffHeapOrDiskWithoutFaultIn(region);
-            indexManager.updateIndexes(this,
-                IndexManager.REMOVE_ENTRY,
-                IndexProtocol.OTHER_OP);
-          }
-          catch (QueryException e) {
+            indexManager.updateIndexes(this, IndexManager.REMOVE_ENTRY, IndexProtocol.OTHER_OP);
+          } catch (QueryException e) {
-          && !event.isFromRILocalDestroy()) { // bug #46780, don't retain tombstones for entries destroyed for register-interest
-        // Destroy will write a tombstone instead 
-        if (v == null || !v.hasValidVersion()) { 
+          && !event.isFromRILocalDestroy()) { // bug #46780, don't retain tombstones for entries
+                                              // destroyed for register-interest
+        // Destroy will write a tombstone instead
+        if (v == null || !v.hasValidVersion()) {
-          if (stamp != null) {  // proxy has no stamps
+          if (stamp != null) { // proxy has no stamps
-        if(inTokenMode && !event.getOperation().isEviction()) {
-          setValue(region, Token.DESTROYED);  
+        if (inTokenMode && !event.getOperation().isEviction()) {
+          setValue(region, Token.DESTROYED);
-      
+
-    }
-    else {
+    } else {
-  
- 
-  static boolean checkExpectedOldValue(@Unretained Object expectedOldValue, @Unretained Object actualValue, LocalRegion lr) {
+
+
+  static boolean checkExpectedOldValue(@Unretained Object expectedOldValue,
+      @Unretained Object actualValue, LocalRegion lr) {
-      boolean isCompressedOffHeap = lr.getAttributes().getOffHeap() && lr.getAttributes().getCompressor() != null;
+      boolean isCompressedOffHeap =
+          lr.getAttributes().getOffHeap() && lr.getAttributes().getCompressor() != null;
-  
+
-            return Arrays.equals((byte[])v2, (byte[])v1);
+            return Arrays.equals((byte[]) v2, (byte[]) v1);
-            return Arrays.deepEquals((Object[])v2, (Object[])v1);
+            return Arrays.deepEquals((Object[]) v2, (Object[]) v1);
-            return Arrays.equals((int[])v2, (int[])v1);
+            return Arrays.equals((int[]) v2, (int[]) v1);
-            return Arrays.equals((long[])v2, (long[])v1);
+            return Arrays.equals((long[]) v2, (long[]) v1);
-            return Arrays.equals((boolean[])v2, (boolean[])v1);
+            return Arrays.equals((boolean[]) v2, (boolean[]) v1);
-            return Arrays.equals((short[])v2, (short[])v1);
+            return Arrays.equals((short[]) v2, (short[]) v1);
-            return Arrays.equals((char[])v2, (char[])v1);
+            return Arrays.equals((char[]) v2, (char[]) v1);
-            return Arrays.equals((float[])v2, (float[])v1);
+            return Arrays.equals((float[]) v2, (float[]) v1);
-            return Arrays.equals((double[])v2, (double[])v1);
+            return Arrays.equals((double[]) v2, (double[]) v1);
-  
-  static boolean checkEquals(@Unretained Object v1, @Unretained Object v2, boolean isCompressedOffHeap) {
+
+  static boolean checkEquals(@Unretained Object v1, @Unretained Object v2,
+      boolean isCompressedOffHeap) {
-      return checkPdxEquals((PdxInstance)v1, v2);
+      return checkPdxEquals((PdxInstance) v1, v2);
-      return checkPdxEquals((PdxInstance)v2, v1);
+      return checkPdxEquals((PdxInstance) v2, v1);
-      return checkOffHeapEquals((StoredObject)v1, v2);
+      return checkOffHeapEquals((StoredObject) v1, v2);
-      return checkOffHeapEquals((StoredObject)v2, v1);
+      return checkOffHeapEquals((StoredObject) v2, v1);
-      return checkCDEquals((CachedDeserializable)v1, v2, isCompressedOffHeap);
+      return checkCDEquals((CachedDeserializable) v1, v2, isCompressedOffHeap);
-      return checkCDEquals((CachedDeserializable)v2, v1, isCompressedOffHeap);
+      return checkCDEquals((CachedDeserializable) v2, v1, isCompressedOffHeap);
-  private static boolean checkOffHeapEquals(@Unretained StoredObject ohVal, @Unretained Object obj) {
+
+  private static boolean checkOffHeapEquals(@Unretained StoredObject ohVal,
+      @Unretained Object obj) {
-      PdxInstance pi = InternalDataSerializer.readPdxInstance(ohVal.getSerializedValue(), GemFireCacheImpl.getForPdx("Could not check value equality"));
+      PdxInstance pi = InternalDataSerializer.readPdxInstance(ohVal.getSerializedValue(),
+          GemFireCacheImpl.getForPdx("Could not check value equality"));
-      return ohVal.checkDataEquals((StoredObject)obj);
+      return ohVal.checkDataEquals((StoredObject) obj);
-        if (obj == null || obj == Token.NOT_AVAILABLE
-            || Token.isInvalidOrRemoved(obj)) {
+        if (obj == null || obj == Token.NOT_AVAILABLE || Token.isInvalidOrRemoved(obj)) {
-  
-  private static boolean checkCDEquals(CachedDeserializable cd, Object obj, boolean isCompressedOffHeap) {
+
+  private static boolean checkCDEquals(CachedDeserializable cd, Object obj,
+      boolean isCompressedOffHeap) {
-      byte[] cdValBytes = (byte[])cdVal;
-      PdxInstance pi = InternalDataSerializer.readPdxInstance(cdValBytes, GemFireCacheImpl.getForPdx("Could not check value equality"));
+      byte[] cdValBytes = (byte[]) cdVal;
+      PdxInstance pi = InternalDataSerializer.readPdxInstance(cdValBytes,
+          GemFireCacheImpl.getForPdx("Could not check value equality"));
-          serializedObj = EntryEventImpl.serialize(obj); 
+          serializedObj = EntryEventImpl.serialize(obj);
-        return Arrays.equals(cdValBytes, serializedObj); 
+        return Arrays.equals(cdValBytes, serializedObj);
-      Object deserializedObj;
-      if (obj instanceof CachedDeserializable) {
-        deserializedObj =((CachedDeserializable) obj).getDeserializedForReading();
-      } else {
-        if (obj == null || obj == Token.NOT_AVAILABLE
-            || Token.isInvalidOrRemoved(obj)) {
-          return false;
+        Object deserializedObj;
+        if (obj instanceof CachedDeserializable) {
+          deserializedObj = ((CachedDeserializable) obj).getDeserializedForReading();
+        } else {
+          if (obj == null || obj == Token.NOT_AVAILABLE || Token.isInvalidOrRemoved(obj)) {
+            return false;
+          }
+          // TODO OPTIMIZE: Before serializing all of obj we could get the top
+          // level class name of cdVal and compare it to the top level class name of obj.
+          deserializedObj = obj;
-        // TODO OPTIMIZE: Before serializing all of obj we could get the top
-        // level class name of cdVal and compare it to the top level class name of obj.
-        deserializedObj = obj;
-      }
-      return basicEquals(deserializedObj, cd.getDeserializedForReading());
+        return basicEquals(deserializedObj, cd.getDeserializedForReading());
+
-      // obj may be a CachedDeserializable in which case we want to convert it to a PdxInstance even if we are not readSerialized.
+      // obj may be a CachedDeserializable in which case we want to convert it to a PdxInstance even
+      // if we are not readSerialized.
-          PdxInstance pi = InternalDataSerializer.readPdxInstance(cdValBytes, GemFireCacheImpl.getForPdx("Could not check value equality"));
+          PdxInstance pi = InternalDataSerializer.readPdxInstance(cdValBytes,
+              GemFireCacheImpl.getForPdx("Could not check value equality"));
-              if (InternalDataSerializer.autoSerialized(obj, hdos) ||
-                  InternalDataSerializer.writePdx(hdos, gfc, obj, pdxSerializer)) {
+              if (InternalDataSerializer.autoSerialized(obj, hdos)
+                  || InternalDataSerializer.writePdx(hdos, gfc, obj, pdxSerializer)) {
-  
+
-  
-  public static class HashRegionEntryCreator implements
-      CustomEntryConcurrentHashMap.HashEntryCreator<Object, Object> {
+
+  public static class HashRegionEntryCreator
+      implements CustomEntryConcurrentHashMap.HashEntryCreator<Object, Object> {
-      final AbstractRegionEntry entry = (AbstractRegionEntry)value;
+      final AbstractRegionEntry entry = (AbstractRegionEntry) value;
-          Assert.fail("unexpected mismatch of hash, expected=" + hash
-              + ", actual=" + entryHash + " for " + entry);
+          Assert.fail("unexpected mismatch of hash, expected=" + hash + ", actual=" + entryHash
+              + " for " + entry);
-  
+
-    if (v == null) return false;
-    if (Token.isInvalidOrRemoved(v)) return false;
-    if (v == Token.NOT_AVAILABLE) return false;
-    if (v instanceof DiskEntry.RecoveredEntry) return false; // The disk layer has special logic that ends up storing the nested value in the RecoveredEntry off heap
-    if (!(e instanceof OffHeapRegionEntry)) return false;
+    if (v == null)
+      return false;
+    if (Token.isInvalidOrRemoved(v))
+      return false;
+    if (v == Token.NOT_AVAILABLE)
+      return false;
+    if (v instanceof DiskEntry.RecoveredEntry)
+      return false; // The disk layer has special logic that ends up storing the nested value in the
+                    // RecoveredEntry off heap
+    if (!(e instanceof OffHeapRegionEntry))
+      return false;
-   * Default implementation. Override in subclasses with primitive keys
-   * to prevent creating an Object form of the key for each equality check.
+   * Default implementation. Override in subclasses with primitive keys to prevent creating an
+   * Object form of the key for each equality check.
-      throw new IllegalStateException("Expected lastModifiedTime " + lastModifiedTime + " to be >= 0 and <= " + LAST_MODIFIED_MASK);
+      throw new IllegalStateException("Expected lastModifiedTime " + lastModifiedTime
+          + " to be >= 0 and <= " + LAST_MODIFIED_MASK);
+
+
+
+
-    return ( getlastModifiedField() & bitMask ) != 0L;
+    return (getlastModifiedField() & bitMask) != 0L;
+
-      if (bits == newBits) return;
+      if (bits == newBits)
+        return;
-    } while(!done);
+    } while (!done);
+
-      if (bits == newBits) return;
+      if (bits == newBits)
+        return;
-    } while(!done);
+    } while (!done);
-  public  Object prepareValueForCache(RegionEntryContext r,
-      @Retained(ABSTRACT_REGION_ENTRY_PREPARE_VALUE_FOR_CACHE) Object val,
-      boolean isEntryUpdate) {
+  public Object prepareValueForCache(RegionEntryContext r,
+      @Retained(ABSTRACT_REGION_ENTRY_PREPARE_VALUE_FOR_CACHE) Object val, boolean isEntryUpdate) {
-  public  Object prepareValueForCache(RegionEntryContext r,
-      @Retained(ABSTRACT_REGION_ENTRY_PREPARE_VALUE_FOR_CACHE) Object val,
-      EntryEventImpl event, boolean isEntryUpdate) {
+  public Object prepareValueForCache(RegionEntryContext r,
+      @Retained(ABSTRACT_REGION_ENTRY_PREPARE_VALUE_FOR_CACHE) Object val, EntryEventImpl event,
+      boolean isEntryUpdate) {
-            data = ((CachedDeserializable)val).getSerializedValue();
+            data = ((CachedDeserializable) val).getSerializedValue();
-              data = ((ConvertableToBytes)val).toBytes();
+              data = ((ConvertableToBytes) val).toBytes();
-    @Unretained Object nv = val;
+    @Unretained
+    Object nv = val;
-        byte[] data = ((ConvertableToBytes)nv).toBytes();
+        byte[] data = ((ConvertableToBytes) nv).toBytes();
-  
+
-  
+
+
-          lruList.appendEntry((LRUClockNode)this);
+          lruList.appendEntry((LRUClockNode) this);
-        lruList.appendEntry((LRUClockNode)this);
+        lruList.appendEntry((LRUClockNode) this);
+
-  
+
-      return (Token)v;
+      return (Token) v;
-  
+
-   * Reads the value of this region entry.
-   * Provides low level access to the value field.
+   * Reads the value of this region entry. Provides low level access to the value field.
+   * 
+
-   * Set the value of this region entry.
-   * Provides low level access to the value field.
+   * Set the value of this region entry. Provides low level access to the value field.
+   * 
-  
+
-  
+
-    VersionStamp stamp = (VersionStamp)this;
+    VersionStamp stamp = (VersionStamp) this;
-      Assert.fail("AbstractRegionEntry#setMapValue: unexpected setMapValue "
-          + "with newValue=" + newValue + ", this=" + this);
+      Assert.fail("AbstractRegionEntry#setMapValue: unexpected setMapValue " + "with newValue="
+          + newValue + ", this=" + this);
-    final StringBuilder sb = new StringBuilder(this.getClass().getSimpleName())
-        .append('@').append(Integer.toHexString(System.identityHashCode(this)))
-        .append(" (");
+    final StringBuilder sb = new StringBuilder(this.getClass().getSimpleName()).append('@')
+        .append(Integer.toHexString(System.identityHashCode(this))).append(" (");
-    sb.append("key=").append(getKey()).append("; rawValue=")
-        .append(_getValue()); // OFFHEAP _getValue ok: the current toString on ObjectChunk is safe to use without incing refcount.
+    sb.append("key=").append(getKey()).append("; rawValue=").append(_getValue()); // OFFHEAP
+                                                                                  // _getValue ok:
+                                                                                  // the current
+                                                                                  // toString on
+                                                                                  // ObjectChunk is
+                                                                                  // safe to use
+                                                                                  // without incing
+                                                                                  // refcount.
-      sb.append("; version=").append(stamp.asVersionTag()+";member="+stamp.getMemberID());
-  }
+      sb.append("; version=").append(stamp.asVersionTag() + ";member=" + stamp.getMemberID());
+    }
-  
+
-   * (non-Javadoc)
-   * This generates version tags for outgoing messages for all subclasses
-   * supporting concurrency versioning.  It also sets the entry's version
-   * stamp to the tag's values.
+   * (non-Javadoc) This generates version tags for outgoing messages for all subclasses supporting
+   * concurrency versioning. It also sets the entry's version stamp to the tag's values.
-   * @see org.apache.geode.internal.cache.RegionEntry#generateVersionTag(org.apache.geode.distributed.DistributedMember, boolean)
+   * @see
+   * org.apache.geode.internal.cache.RegionEntry#generateVersionTag(org.apache.geode.distributed.
+   * DistributedMember, boolean)
-  public VersionTag generateVersionTag(VersionSource mbr, boolean withDelta, LocalRegion region, EntryEventImpl event) {
+  public VersionTag generateVersionTag(VersionSource mbr, boolean withDelta, LocalRegion region,
+      EntryEventImpl event) {
-      int v = stamp.getEntryVersion()+1;
+      int v = stamp.getEntryVersion() + 1;
-      
-      
-      //For non persistent regions, we allow the member to be null and
-      //when we send a message and the remote side can determine the member
-      //from the sender. For persistent regions, we need to send
-      //the persistent id to the remote side.
+
+
+      // For non persistent regions, we allow the member to be null and
+      // when we send a message and the remote side can determine the member
+      // from the sender. For persistent regions, we need to send
+      // the persistent id to the remote side.
-      //TODO - RVV - optimize the way we send the persistent id to save
-      //space. 
-      if(mbr == null) {
+      // TODO - RVV - optimize the way we send the persistent id to save
+      // space.
+      if (mbr == null) {
-        if(regionMember instanceof DiskStoreID) {
+        if (regionMember instanceof DiskStoreID) {
-      
+
-          rvv.recordVersion(rvv.getOwnerId(),nextRegionVersion);
+          rvv.recordVersion(rvv.getOwnerId(), nextRegionVersion);
-            logger.debug("recorded region version {}; region={}", nextRegionVersion, region.getFullPath());
+            logger.debug("recorded region version {}; region={}", nextRegionVersion,
+                region.getFullPath());
-          tag.setRegionVersion(region.getVersionVector().getNextVersion());  
+          tag.setRegionVersion(region.getVersionVector().getNextVersion());
-        logger.debug("generated tag {}; key={}; oldvalue={} newvalue={} client={} region={}; rvv={}", tag,
+        logger.debug(
+            "generated tag {}; key={}; oldvalue={} newvalue={} client={} region={}; rvv={}", tag,
-            (event.getContext() == null? "none" : event.getContext().getDistributedMember().getName()),
+            (event.getContext() == null ? "none"
+                : event.getContext().getDistributedMember().getName()),
-  
+
-  
+
-   * return the flag noting whether a tombstone has been scheduled for this entry.  This should
-   * be called under synchronization on the region entry if you want an accurate result.
+   * return the flag noting whether a tombstone has been scheduled for this entry. This should be
+   * called under synchronization on the region entry if you want an accurate result.
-   * (non-Javadoc)
-   * This performs a concurrency check.
+   * (non-Javadoc) This performs a concurrency check.
-   * Wraparound of the version number is detected and handled by extending the
-   * range of versions by one bit.
+   * Wraparound of the version number is detected and handled by extending the range of versions by
+   * one bit.
-   * Note that a tag from a remote (WAN) system may be in the event.  If this
-   * is the case this method will either invoke a user plugin that allows/disallows
-   * the event (and may modify the value) or it determines whether to allow
-   * or disallow the event based on timestamps and distributedSystemIDs.
+   * Note that a tag from a remote (WAN) system may be in the event. If this is the case this method
+   * will either invoke a user plugin that allows/disallows the event (and may modify the value) or
+   * it determines whether to allow or disallow the event based on timestamps and
+   * distributedSystemIDs.
-   * @throws ConcurrentCacheModificationException if the event conflicts with
-   * an event that has already been applied to the entry.
+   * @throws ConcurrentCacheModificationException if the event conflicts with an event that has
+   * already been applied to the entry.
-   * @see org.apache.geode.internal.cache.RegionEntry#concurrencyCheck(org.apache.geode.cache.EntryEvent)
+   * @see
+   * org.apache.geode.internal.cache.RegionEntry#concurrencyCheck(org.apache.geode.cache.EntryEvent)
-  
-  
+
+
-    EntryEventImpl event = (EntryEventImpl)cacheEvent;
+    EntryEventImpl event = (EntryEventImpl) cacheEvent;
-    
+
-        if (processGatewayTag(cacheEvent)) { 
+        if (processGatewayTag(cacheEvent)) {
-  
+
-  
-      final InternalDistributedMember originator = (InternalDistributedMember)event.getDistributedMember();
+
+      final InternalDistributedMember originator =
+          (InternalDistributedMember) event.getDistributedMember();
-        
-        if (stampDsId != 0  &&  stampDsId != tagDsId  &&  stampDsId != -1) {
+
+        if (stampDsId != 0 && stampDsId != tagDsId && stampDsId != -1) {
-            verbose.append("processing tag for key " + getKey() + ", stamp=" + stamp.asVersionTag() + ", tag=").append(tag);
+            verbose.append(
+                "processing tag for key " + getKey() + ", stamp=" + stamp.asVersionTag() + ", tag=")
+                .append(tag);
-          if (stampTime > 0 && (tagTime > stampTime
-              || (tagTime == stampTime  &&  tag.getDistributedSystemId() >= stamp.getDistributedSystemId()))) {
+          if (stampTime > 0 && (tagTime > stampTime || (tagTime == stampTime
+              && tag.getDistributedSystemId() >= stamp.getDistributedSystemId()))) {
-  
+
-      if (r.getVersionVector() != null &&
-          r.getServerProxy() == null &&
-          (r.getDataPolicy().withPersistence() ||
-              !r.getScope().isLocal())) { // bug #45258 - perf degradation for local regions and RVV
+      if (r.getVersionVector() != null && r.getServerProxy() == null
+          && (r.getDataPolicy().withPersistence() || !r.getScope().isLocal())) { // bug #45258 -
+                                                                                 // perf degradation
+                                                                                 // for local
+                                                                                 // regions and RVV
-  
-      assert !tag.isFromOtherMember() || tag.getMemberID() != null : "remote tag is missing memberID";
-  
-      
+
+      assert !tag.isFromOtherMember()
+          || tag.getMemberID() != null : "remote tag is missing memberID";
+
+
-      // receiving a response from a server and applying it to the cache.  This lowered
+      // receiving a response from a server and applying it to the cache. This lowered
-//      if (r.getServerProxy() != null && conflictCheck) {
-//        // events coming from servers while a local sync is held on the entry
-//        // do not require a conflict check.  Conflict checks were already
-//        // performed on the server and here we just consume whatever was sent back.
-//        // Event.isFromServer() returns true for client-update messages and
-//        // for putAll/getAll, which do not hold syncs during the server operation.
-//        conflictCheck = event.isFromServer();
-//      }
-//      else
-      
+      // if (r.getServerProxy() != null && conflictCheck) {
+      // // events coming from servers while a local sync is held on the entry
+      // // do not require a conflict check. Conflict checks were already
+      // // performed on the server and here we just consume whatever was sent back.
+      // // Event.isFromServer() returns true for client-update messages and
+      // // for putAll/getAll, which do not hold syncs during the server operation.
+      // conflictCheck = event.isFromServer();
+      // }
+      // else
+
-      // Bug 45669 showed a primary dying in the middle of distribution.  This caused
-      // one backup bucket to have a v2.  The other bucket was promoted to primary and
-      // generated a conflicting v2.  We need to do the check so that if this second
+      // Bug 45669 showed a primary dying in the middle of distribution. This caused
+      // one backup bucket to have a v2. The other bucket was promoted to primary and
+      // generated a conflicting v2. We need to do the check so that if this second
-//      if (r.isUsedForPartitionedRegionBucket()) {
-//        conflictCheck = false; // primary/secondary model 
-//      }
-  
+      // if (r.isUsedForPartitionedRegionBucket()) {
+      // conflictCheck = false; // primary/secondary model
+      // }
+
-  
-  protected final void basicProcessVersionTag(LocalRegion region, VersionTag tag, boolean isTombstoneFromGII,
-      boolean deltaCheck, VersionSource dmId, InternalDistributedMember sender, boolean checkForConflict) {
-    
+
+  protected final void basicProcessVersionTag(LocalRegion region, VersionTag tag,
+      boolean isTombstoneFromGII, boolean deltaCheck, VersionSource dmId,
+      InternalDistributedMember sender, boolean checkForConflict) {
+
-    
+
-        if (stampTag.hasValidVersion() && checkForConflict) { // only be verbose here if there's a possibility we might reject the operation
+        if (stampTag.hasValidVersion() && checkForConflict) { // only be verbose here if there's a
+                                                              // possibility we might reject the
+                                                              // operation
-          verbose.append("processing tag for key " + getKey() + ", stamp=" + stamp.asVersionTag() + ", tag=").append(tag)
-                 .append(", checkForConflict=").append(checkForConflict); //.append(", current value=").append(_getValue());
+          verbose.append(
+              "processing tag for key " + getKey() + ", stamp=" + stamp.asVersionTag() + ", tag=")
+              .append(tag).append(", checkForConflict=").append(checkForConflict); // .append(",
+                                                                                   // current
+                                                                                   // value=").append(_getValue());
-      
+
-        throw new IllegalStateException("message contained a version tag but this region has no version storage");
+        throw new IllegalStateException(
+            "message contained a version tag but this region has no version storage");
-      
+
-          apply = checkForConflict(region, stamp, tag, isTombstoneFromGII, deltaCheck, dmId, sender, verbose);
+          apply = checkForConflict(region, stamp, tag, isTombstoneFromGII, deltaCheck, dmId, sender,
+              verbose);
-        if (!tag.isGatewayTag()
-            && stamp.getDistributedSystemId() == tag.getDistributedSystemId()
+        if (!tag.isGatewayTag() && stamp.getDistributedSystemId() == tag.getDistributedSystemId()
-            verbose.append("\nThough in conflict the tag timestamp was more recent and was recorded.");
+            verbose
+                .append("\nThough in conflict the tag timestamp was more recent and was recorded.");
-        throw e; 
+        throw e;
-      
+
-  
-  private void applyVersionTag(LocalRegion region, VersionStamp stamp, VersionTag tag, InternalDistributedMember sender) {
+
+  private void applyVersionTag(LocalRegion region, VersionStamp stamp, VersionTag tag,
+      InternalDistributedMember sender) {
-        tag.setPreviousMemberID(region.getVersionVector().getCanonicalId(
-            tag.getPreviousMemberID()));
+        tag.setPreviousMemberID(
+            region.getVersionVector().getCanonicalId(tag.getPreviousMemberID()));
-  protected boolean checkForConflict(LocalRegion region,
-      VersionStamp stamp, VersionTag tag,
-      boolean isTombstoneFromGII,
-      boolean deltaCheck, VersionSource dmId,
+  protected boolean checkForConflict(LocalRegion region, VersionStamp stamp, VersionTag tag,
+      boolean isTombstoneFromGII, boolean deltaCheck, VersionSource dmId,
-    
+
-    
+
-      // check for wrap-around on the version number  
+      // check for wrap-around on the version number
-          verbose.append("\nversion rollover detected: tag="+tagVersion + " stamp=" + stampVersion);
+          verbose
+              .append("\nversion rollover detected: tag=" + tagVersion + " stamp=" + stampVersion);
-      verbose.append("\nstamp=v").append(stampVersion)
-             .append(" tag=v").append(tagVersion);
+      verbose.append("\nstamp=v").append(stampVersion).append(" tag=v").append(tagVersion);
-    
-    if (stampVersion == 0  ||  stampVersion < tagVersion) {
-      if (verbose != null) { verbose.append(" - applying change"); }
+
+    if (stampVersion == 0 || stampVersion < tagVersion) {
+      if (verbose != null) {
+        verbose.append(" - applying change");
+      }
-      if (overwritingOldTombstone(region, stamp, tag, verbose)  && tag.getVersionTimeStamp() > stamp.getVersionTimeStamp()) {
+      if (overwritingOldTombstone(region, stamp, tag, verbose)
+          && tag.getVersionTimeStamp() > stamp.getVersionTimeStamp()) {
-          // A special case to apply: when remote entry is expired tombstone, then let local vs remote with newer timestamp to win
-          if (verbose != null) { verbose.append(" - applying change in Delta GII"); }
+          // A special case to apply: when remote entry is expired tombstone, then let local vs
+          // remote with newer timestamp to win
+          if (verbose != null) {
+            verbose.append(" - applying change in Delta GII");
+          }
-          if (verbose != null) { verbose.append(" - disallowing"); }
-          throwex= true;
+          if (verbose != null) {
+            verbose.append(" - disallowing");
+          }
+          throwex = true;
-        if (verbose != null) { verbose.append("\ncomparing IDs"); }
+        if (verbose != null) {
+          verbose.append("\ncomparing IDs");
+        }
-          if (verbose != null) { verbose.append(" - applying change"); }
+          if (verbose != null) {
+            verbose.append(" - applying change");
+          }
-          if (verbose != null) { verbose.append(" - disallowing"); }
+          if (verbose != null) {
+            verbose.append(" - disallowing");
+          }
-          if (verbose != null) { verbose.append(" - disallowing duplicate marked with posdup"); }
+          if (verbose != null) {
+            verbose.append(" - disallowing duplicate marked with posdup");
+          }
-        } else /* if (isTombstoneFromGII && isTombstone()) {
-          if (verbose != null) { verbose.append(" - disallowing duplicate tombstone from GII"); }
-          return false;  // bug #49601 don't schedule tombstones from GII if there's already one here
-        } else */ {
-          if (verbose != null) { verbose.append(" - allowing duplicate"); }
+        } else /*
+                * if (isTombstoneFromGII && isTombstone()) { if (verbose != null) {
+                * verbose.append(" - disallowing duplicate tombstone from GII"); } return false; //
+                * bug #49601 don't schedule tombstones from GII if there's already one here } else
+                */ {
+          if (verbose != null) {
+            verbose.append(" - allowing duplicate");
+          }
-    return isTombstone && (timestamp + TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT) <= region.cacheTimeMillis();
+    return isTombstone
+        && (timestamp + TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT) <= region.cacheTimeMillis();
-  
-  private boolean overwritingOldTombstone(LocalRegion region, VersionStamp stamp, VersionTag tag, StringBuilder verbose) {
+
+  private boolean overwritingOldTombstone(LocalRegion region, VersionStamp stamp, VersionTag tag,
+      StringBuilder verbose) {
-    // are being removed.  Because of this we might get an operation that was applied
+    // are being removed. Because of this we might get an operation that was applied
-    // entry version number.  Because of this we check the timestamp on the current
-    // local entry and see if it is old enough to have expired.  If this is the case
+    // entry version number. Because of this we check the timestamp on the current
+    // local entry and see if it is old enough to have expired. If this is the case
-      if (verbose != null) { verbose.append(" - accepting because local timestamp is old"); }
+      if (verbose != null) {
+        verbose.append(" - accepting because local timestamp is old");
+      }
-    // only persist region needs to persist conflict tag 
+    // only persist region needs to persist conflict tag
-  
+
-   * for an event containing a delta we must check to see if the tag's
-   * previous member id is the stamp's member id and ensure that the
-   * version is only incremented by 1.  Otherwise the delta is being
-   * applied to a value that does not match the source of the delta.
+   * for an event containing a delta we must check to see if the tag's previous member id is the
+   * stamp's member id and ensure that the version is only incremented by 1. Otherwise the delta is
+   * being applied to a value that does not match the source of the delta.
-  private void checkForDeltaConflict(LocalRegion region,
-      long stampVersion, long tagVersion,
-      VersionStamp stamp, VersionTag tag,
-      VersionSource dmId, InternalDistributedMember sender,
+  private void checkForDeltaConflict(LocalRegion region, long stampVersion, long tagVersion,
+      VersionStamp stamp, VersionTag tag, VersionSource dmId, InternalDistributedMember sender,
-    if (tagVersion != stampVersion+1) {
+    if (tagVersion != stampVersion + 1) {
-          verbose.append("\ndelta requires full value.  tag.previous=")
-          .append(tagID).append(" but stamp.current=").append(stampID);
+          verbose.append("\ndelta requires full value.  tag.previous=").append(tagID)
+              .append(" but stamp.current=").append(stampID);
-  
+
-    // modification methods.  They do not have version numbers or distributed
-    // member IDs.  Instead they only have timestamps and distributed system IDs.
+    // modification methods. They do not have version numbers or distributed
+    // member IDs. Instead they only have timestamps and distributed system IDs.
-    // If there is a resolver plug-in, invoke it.  Otherwise we use the timestamps and
+    // If there is a resolver plug-in, invoke it. Otherwise we use the timestamps and
-    
+
-    
+
-    EntryEventImpl event = (EntryEventImpl)cacheEvent;
+    EntryEventImpl event = (EntryEventImpl) cacheEvent;
-      logger.debug("processing gateway version information for {}.  Stamp dsid={} time={} Tag dsid={} time={}",
-        event.getKey(), stampDsid, stampTime, tagDsid, tagTime);
+      logger.debug(
+          "processing gateway version information for {}.  Stamp dsid={} time={} Tag dsid={} time={}",
+          event.getKey(), stampDsid, stampTime, tagDsid, tagTime);
-      final Object[] newValue = new Object[] { this };
+      final Object[] newValue = new Object[] {this};
-      @Released TimestampedEntryEventImpl timestampedEvent =
-        (TimestampedEntryEventImpl)event.getTimestampedEvent(tagDsid, stampDsid, tagTime, stampTime);
+      @Released
+      TimestampedEntryEventImpl timestampedEvent = (TimestampedEntryEventImpl) event
+          .getTimestampedEvent(tagDsid, stampDsid, tagTime, stampTime);
-        timestampedEvent.setOldValue(getValue(timestampedEvent.getRegion())); // OFFHEAP: since isRemoved I think getValue will never be stored off heap in this case
+        timestampedEvent.setOldValue(getValue(timestampedEvent.getRegion())); // OFFHEAP: since
+                                                                              // isRemoved I think
+                                                                              // getValue will never
+                                                                              // be stored off heap
+                                                                              // in this case
-      
+
-      }
-      catch (CancelException cancelled) {
+      } catch (CancelException cancelled) {
-      }
-      catch (VirtualMachineError err) {
+      } catch (VirtualMachineError err) {
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-        logger.error(LocalizedMessage.create(LocalizedStrings.LocalRegion_EXCEPTION_OCCURRED_IN_CONFLICTRESOLVER), t);
+        logger.error(LocalizedMessage
+            .create(LocalizedStrings.LocalRegion_EXCEPTION_OCCURRED_IN_CONFLICTRESOLVER), t);
-          throw new ConcurrentCacheModificationException("WAN conflict resolver rejected the operation");
+          throw new ConcurrentCacheModificationException(
+              "WAN conflict resolver rejected the operation");
-        
+
-        
+
-    if (tagTime > stampTime
-        || (tagTime == stampTime  &&  tagDsid >= stampDsid)) {
+    if (tagTime > stampTime || (tagTime == stampTime && tagDsid >= stampDsid)) {
-  static boolean isCompressible(RegionEntryContext context,Object value) {
-    return ((value != null) && (context != null) && (context.getCompressor() != null) && !Token.isInvalidOrRemoved(value));
+  static boolean isCompressible(RegionEntryContext context, Object value) {
+    return ((value != null) && (context != null) && (context.getCompressor() != null)
+        && !Token.isInvalidOrRemoved(value));
-  
+
-  
+
-  
+
-  
+
-   * This is only retained in off-heap subclasses.  However, it's marked as
-   * Retained here so that callers are aware that the value may be retained.
+   * This is only retained in off-heap subclasses. However, it's marked as Retained here so that
+   * callers are aware that the value may be retained.
-  @Retained 
+  @Retained
-  
+

INS31 INS31 INS29 INS44 INS8 INS29 INS83 INS39 INS42 MOV44 INS44 MOV8 INS44 INS83 INS39 INS42 INS44 INS43 INS8 UPD66 UPD66 INS65 INS65 INS39 INS42 INS21 INS65 INS65 INS65 INS39 INS42 INS39 INS42 INS43 INS42 INS42 INS60 INS54 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 INS66 INS42 INS66 INS32 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS39 INS59 MOV8 INS8 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 INS42 INS42 UPD42 INS42 UPD42 INS42 INS42 INS9 INS21 INS25 INS8 INS7 INS27 INS8 INS21 MOV21 UPD42 INS42 INS9 INS38 INS32 INS21 INS32 INS42 INS42 INS32 INS42 INS42 INS42 DEL66 DEL66 DEL40 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
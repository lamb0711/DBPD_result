Revert " GEODE-6580: Cleanup static analyzer warnings. (#3415)"

This reverts commit 80a32b19c3cdbfe75c37d7b70104ea708739d2cd.

-
+import java.util.Collection;
+import java.util.Iterator;
-import org.apache.geode.annotations.VisibleForTesting;
+import org.apache.geode.cache.Cache;
+  /** Maps Classes to their ids */
-  private static final ConcurrentMap<String, Instantiator> dsMap = new ConcurrentHashMap<>();
+  private static final ConcurrentMap/* <String,Instantiator> */ dsMap = new ConcurrentHashMap();
-  private static final ConcurrentMap<Integer, Object> idsToInstantiators =
-      new ConcurrentHashMap<>();
+  private static final ConcurrentMap/* <Integer,Instantiator|Marker> */ idsToInstantiators =
+      new ConcurrentHashMap();
-      new ConcurrentHashMap<>();
+      new ConcurrentHashMap<String, InstantiatorAttributesHolder>();
-  private static final ConcurrentHashMap<Integer, InstantiatorAttributesHolder> idsToHolders;
-
-  static {
-    idsToHolders = new ConcurrentHashMap<>();
-  }
+  private static final ConcurrentHashMap<Integer, InstantiatorAttributesHolder> idsToHolders =
+      new ConcurrentHashMap<Integer, InstantiatorAttributesHolder>();
-    // Skip the checkForThread() check if the instantiation is not
+    // [sumedh] Skip the checkForThread() check if the instantiation has not
-      throw new NullPointerException("Cannot register a null Instantiator.");
+      throw new NullPointerException(
+          "Cannot register a null Instantiator.");
-      throw new IllegalArgumentException("Instantiator id cannot be zero");
+      throw new IllegalArgumentException(
+          "Instantiator id cannot be zero");
-        throw new IllegalStateException(String.format(
-            "Class %s is already registered with id %s so it can not be registered with id %s",
-            c.getName(), oldId, classId));
+        throw new IllegalStateException(
+            String.format(
+                "Class %s is already registered with id %s so it can not be registered with id %s",
+
+                new Object[] {c.getName(), Integer.valueOf(oldId), Integer.valueOf(classId)}));
-    final Integer idx = classId;
+    final Integer idx = Integer.valueOf(classId);
-              throw new IllegalStateException(String.format(
-                  "Class id %s is already registered for class %s so it could not be registered for class %s",
-                  classId, oldClass.getName(), cName));
+              throw new IllegalStateException(
+                  String.format(
+                      "Class id %s is already registered for class %s so it could not be registered for class %s",
+
+                      new Object[] {Integer.valueOf(classId), oldClass.getName(), cName}));
-              // it was already registered
-              return;
+              return; // it was already registered
-      setEventIdIfNew(instantiator);
+      // if instantiator is getting registered for first time
+      // its EventID will be null, so generate a new event id
+      // the the distributed system is connected
+      InternalCache cache = GemFireCacheImpl.getInstance();
+      if (cache != null && instantiator.getEventId() == null) {
+        instantiator.setEventId(new EventID(cache.getDistributedSystem()));
+      }
-      logger.info("Instantiator registered with id {} class {}", classId, c.getName());
+      logger
+          .info("Instantiator registered with id {} class {}",
+              Integer.valueOf(classId), c.getName());
-    if (distribute) {
-      // originated in this VM
+    if (distribute) { // originated in this VM
+      // send a message to other peers telling them about a newly-registered
+      // instantiator, it also send event id of the originator along with the
+      // instantiator
+      // send it to cache servers if it is a client
+    // send it to all cache clients irrelevant of distribute
+    // cache servers send it all the clients irrelevant of
+    // originator VM
-   * if instantiator is getting registered for first time its EventID will be null, so generate a
-   * new event id the the distributed system is connected
-   */
-  private static void setEventIdIfNew(final Instantiator instantiator) {
-    final InternalCache cache = getInternalCache();
-    if (cache != null && instantiator.getEventId() == null) {
-      instantiator.setEventId(new EventID(cache.getDistributedSystem()));
-    }
-  }
-
-  @SuppressWarnings("deprecation")
-  private static InternalCache getInternalCache() {
-    return GemFireCacheImpl.getInstance();
-  }
-
-  /**
-    if (isCacheCreated()) {
-      return new EventID(InternalDistributedSystem.getAnyInstance());
+    InternalCache cache = GemFireCacheImpl.getInstance();
+    if (cache == null) {
+      // A cache has not yet created
+      return null;
-    return null;
+    return new EventID(InternalDistributedSystem.getAnyInstance());
-    if (!isCacheCreated()) {
+    Cache cache = GemFireCacheImpl.getInstance();
+    if (cache == null) {
+      // A cache has not yet been created.
+      // we can't propagate it to clients
-  private static boolean isCacheCreated() {
-    return getInternalCache() != null;
-  }
-
-    Object inst;
+    Object inst = null;
-          throw new IllegalArgumentException("Instantiator id cannot be zero");
+          throw new IllegalArgumentException(
+              "Instantiator id cannot be zero");
-          throw new IllegalStateException(String.format(
-              "Class %s is already registered with id %s so it can not be registered with id %s",
-              instantiatorClassName, iah.getId(), holder.getId()));
+          throw new IllegalStateException(
+              String.format(
+                  "Class %s is already registered with id %s so it can not be registered with id %s",
+
+                  new Object[] {instantiatorClassName, iah.getId(), holder.getId()}));
-        logger.info("Instantiator registered with holder id {} class {}", holder.getId(),
+        logger.info("Instantiator registered with holder id {} class {}",
+            Integer.valueOf(holder.getId()),
+        // fix bug 46355, need to move getCachedClass() outside of sync
-      } catch (ClassNotFoundException e) {
-        logClassNotFoundException(e);
+      } catch (ClassNotFoundException cnfe) {
+        InternalCache cache = GemFireCacheImpl.getInstance();
+        if (cache != null && cache.getLogger() != null && cache.getLogger().infoEnabled()) {
+          cache.getLogger().info(
+              String.format("Could not load instantiator class: %s",
+                  new Object[] {cnfe.getMessage()}));
+        }
+            // recurse
+          } else {
+            // already registered
+            return;
-  private static void logClassNotFoundException(final ClassNotFoundException e) {
-    final InternalCache cache = getInternalCache();
-    if (cache != null && cache.getLogger() != null && cache.getLogger().infoEnabled()) {
-      cache.getLogger()
-          .info(String.format("Could not load instantiator class: %s", e.getMessage()));
-    }
-  }
-
-    InstantiatorAttributesHolder(String instantiatorClass, String instantiatedClass,
+    public InstantiatorAttributesHolder(String instantiatorClass, String instantiatedClass,
-      instantiatorName = instantiatorClass;
-      instantiatedName = instantiatedClass;
+      this.instantiatorName = instantiatorClass;
+      this.instantiatedName = instantiatedClass;
-    InstantiatorAttributesHolder(String instantiatorClass, String instantiatedClass, int id,
+    public InstantiatorAttributesHolder(String instantiatorClass, String instantiatedClass, int id,
-      instantiatorName = instantiatorClass;
-      instantiatedName = instantiatedClass;
+      this.instantiatorName = instantiatorClass;
+      this.instantiatedName = instantiatedClass;
-      return "InstantiatorAttributesHolder[irName=" + instantiatorName + ",idName="
-          + instantiatedName + ",id=" + id
-          + (eventId != null ? ",this.eventId=" + eventId : "")
-          + (context != null ? ",this.context=" + context : "") + "]";
+      return "InstantiatorAttributesHolder[irName=" + this.instantiatorName + ",idName="
+          + this.instantiatedName + ",id=" + this.id
+          + (this.eventId != null ? ",this.eventId=" + this.eventId : "")
+          + (this.context != null ? ",this.context=" + this.context : "") + "]";
-    final Integer idx = classId;
+    final Integer idx = Integer.valueOf(classId);
-          String.format("Class %s was not registered with id %s", c.getName(), classId));
+          String.format("Class %s was not registered with id %s",
+              new Object[] {c.getName(), Integer.valueOf(classId)}));
-  /**
-   * testhook that removes all registed instantiators
-   */
-  @VisibleForTesting
+  // testhook that removes all registed instantiators
-    final Instantiator i = dsMap.get(c.getName());
+    final Instantiator i = (Instantiator) dsMap.get(c.getName());
-    final Integer idx = classId;
+    final Integer idx = Integer.valueOf(classId);
-        } catch (ClassNotFoundException e) {
-          logClassNotFoundException(e);
+        } catch (ClassNotFoundException cnfe) {
+          InternalCache cache = GemFireCacheImpl.getInstance();
+          if (cache != null && cache.getLogger() != null
+              && cache.getLogger().infoEnabled()) {
+            cache.getLogger().info(
+                String.format("Could not load instantiator class: %s", cnfe.getMessage()));
+          }
-      RegistrationMessage m;
+      RegistrationMessage m = null;
-  protected static Instantiator newInstance(Class<?> instantiatorClass, Class<?> instantiatedClass,
-      int id) throws IllegalArgumentException {
+  protected static Instantiator newInstance(Class instantiatorClass, Class instantiatedClass,
+      int id) {
+    Class[] types;
-      init = instantiatorClass.getDeclaredConstructor(Class.class, int.class);
+      types = new Class[] {Class.class, int.class};
+      init = instantiatorClass.getDeclaredConstructor(types);
-        init = instantiatorClass.getDeclaredConstructor(Class.class, byte.class);
+        types = new Class[] {Class.class, byte.class};
+        init = instantiatorClass.getDeclaredConstructor(types);
-          throw new IllegalArgumentException(String.format(
+          String msg = String.format(
-              instantiatorClass.getName(), instantiatorClass.getDeclaringClass()));
+              instantiatorClass.getName(), instantiatorClass.getDeclaringClass());
+          throw new IllegalArgumentException(msg);
-        throw new IllegalArgumentException(
-            String.format("Class %s does not have a two-argument (Class, int) constructor.",
-                instantiatorClass.getName()));
+        String msg = String.format(
+            "Class %s does not have a two-argument (Class, int) constructor.",
+            instantiatorClass.getName());
+        throw new IllegalArgumentException(msg);
-      s = (Instantiator) init.newInstance(instantiatedClass, convertId(id, intConstructor));
+      Object[] args = new Object[] {instantiatedClass,
+          intConstructor ? (Object) Integer.valueOf(id) : (Object) Byte.valueOf((byte) id)};
+      s = (Instantiator) init.newInstance(args);
+
-      throw new IllegalArgumentException(String
-          .format("Could not access zero-argument constructor of %s", instantiatorClass.getName()));
+      throw new IllegalArgumentException(
+          String.format("Could not access zero-argument constructor of %s",
+              instantiatorClass.getName()));
-      throw new IllegalArgumentException(
-          String.format("Could not instantiate an instance of %s", instantiatorClass.getName()),
-          ex);
+      RuntimeException ex2 = new IllegalArgumentException(
+          String.format("Could not instantiate an instance of %s",
+              instantiatorClass.getName()));
+      ex2.initCause(ex);
+      throw ex2;
-      throw new IllegalArgumentException(
-          String.format("While instantiating an instance of %s", instantiatorClass.getName()), ex);
+      RuntimeException ex2 = new IllegalArgumentException(
+          String.format("While instantiating an instance of %s",
+              instantiatorClass.getName()));
+      ex2.initCause(ex);
+      throw ex2;
-  private static Object convertId(int id, boolean asInteger) {
-    if (asInteger) {
-      return id;
-    }
-    return (byte) id;
-  }
-
+    Collection coll = new ArrayList();
-      for (InstantiatorAttributesHolder holder : classNamesToHolders.values()) {
+      Iterator it = classNamesToHolders.values().iterator();
+      while (it.hasNext()) {
+          InstantiatorAttributesHolder holder = (InstantiatorAttributesHolder) it.next();
-        } catch (ClassNotFoundException e) {
-          logClassNotFoundException(e);
+        } catch (ClassNotFoundException cnfe) {
+          InternalCache cache = GemFireCacheImpl.getInstance();
+          if (cache != null && cache.getLogger() != null
+              && cache.getLogger().infoEnabled()) {
+            cache.getLogger().info(
+                String.format("Could not load instantiator class: %s",
+                    cnfe.getMessage()));
+          }
-    return dsMap.values().toArray(new Instantiator[0]);
+    coll.addAll(dsMap.values()); // Don't move it before the if block above.
+    return (Instantiator[]) coll.toArray(new Instantiator[coll.size()]);
-    ArrayList<Object> instantiators = new ArrayList<>(dsMap.size() + idsToHolders.size());
-    instantiators.addAll(dsMap.values());
-    instantiators.addAll(classNamesToHolders.values());
-    return instantiators.toArray();
+    Collection coll = new ArrayList(dsMap.size() + idsToHolders.size());
+    coll.addAll(dsMap.values());
+    coll.addAll(classNamesToHolders.values()); // TODO (ashetkar) will it add duplicates?
+    return coll.toArray(new Object[coll.size()]);
+  public static int getIdsToHoldersSize() {
+    return idsToHolders.size();
+  }
+
+  public static int getNamesToHoldersSize() {
+    return classNamesToHolders.size();
+  }
+  /////////////////////// Inner Classes ///////////////////////
+
-        if (instantiator == null) {
+        if (this.instantiator == null) {
-            wait(InternalDataSerializer.GetMarker.WAIT_MS);
+            this.wait(InternalDataSerializer.GetMarker.WAIT_MS);
-        return instantiator;
+        return this.instantiator;
-        notifyAll();
+        this.notifyAll();
+   * Persist this class's map to out
+   */
+  public static void saveRegistrations(DataOutput out) throws IOException {
+    for (Instantiator inst : InternalInstantiator.getInstantiators()) {
+      out.writeInt(inst.getId());
+      DataSerializer.writeClass(inst.getClass(), out);
+      DataSerializer.writeClass(inst.getInstantiatedClass(), out);
+    }
+    // We know that Instantiator id's must not be 0 so write a zero
+    // to mark then end of the instantiators.
+    out.writeInt(0);
+  }
+
+  /**
+   * Read the data from in and register it with this class.
+   *
+   * @throws IllegalArgumentException if a registration fails
+   */
+  public static void loadRegistrations(DataInput in) throws IOException {
+    int instId;
+    while ((instId = in.readInt()) != 0) {
+      Class instClass = null;
+      Class instantiatedClass = null;
+      boolean skip = false;
+      try {
+        instClass = DataSerializer.readClass(in);
+      } catch (ClassNotFoundException ex) {
+        skip = true;
+      }
+      try {
+        instantiatedClass = DataSerializer.readClass(in);
+      } catch (ClassNotFoundException ex) {
+        skip = true;
+      }
+      if (skip) {
+        continue;
+      }
+      register(newInstance(instClass, instantiatedClass, instId), true);
+    }
+  }
+
+  /**
-    Class instantiatorClass;
+    protected Class instantiatorClass;
-    Class instantiatedClass;
+    protected Class instantiatedClass;
-    transient StringBuffer fromDataProblems;
+    protected transient StringBuffer fromDataProblems;
-    String instantiatorClassName;
+    protected String instantiatorClassName;
-    String instantiatedClassName;
+    protected String instantiatedClassName;
-      instantiatorClass = s.getClass();
-      instantiatedClass = s.getInstantiatedClass();
-      id = s.getId();
-      eventId = (EventID) s.getEventId();
+      this.instantiatorClass = s.getClass();
+      this.instantiatedClass = s.getInstantiatedClass();
+      this.id = s.getId();
+      this.eventId = (EventID) s.getEventId();
-      if (fromDataProblems != null) {
+      if (this.fromDataProblems != null) {
-          logger.debug(fromDataProblems);
+          logger.debug(this.fromDataProblems);
-      if (instantiatorClass != null && instantiatedClass != null) {
-        Instantiator s = newInstance(instantiatorClass, instantiatedClass, id);
+      if (this.instantiatorClass != null && this.instantiatedClass != null) {
+        Instantiator s = newInstance(this.instantiatorClass, this.instantiatedClass, this.id);
-      } else if (instantiatorClassName != null && instantiatedClassName != null) {
-        InternalInstantiator.register(instantiatorClassName, instantiatedClassName,
-            id, false, eventId, null);
+      } else if (this.instantiatorClassName != null && this.instantiatedClassName != null) {
+        InternalInstantiator.register(this.instantiatorClassName, this.instantiatedClassName,
+            this.id, false, this.eventId, null);
-      DataSerializer.writeNonPrimitiveClassName(instantiatorClass.getName(), out);
-      DataSerializer.writeNonPrimitiveClassName(instantiatedClass.getName(), out);
-      out.writeInt(id);
-      DataSerializer.writeObject(eventId, out);
+      DataSerializer.writeNonPrimitiveClassName(this.instantiatorClass.getName(), out);
+      DataSerializer.writeNonPrimitiveClassName(this.instantiatedClass.getName(), out);
+      out.writeInt(this.id);
+      DataSerializer.writeObject(this.eventId, out);
-      if (fromDataProblems == null) {
-        fromDataProblems = new StringBuffer();
+      if (this.fromDataProblems == null) {
+        this.fromDataProblems = new StringBuffer();
-      fromDataProblems.append(s);
-      fromDataProblems.append("\n\n");
+      this.fromDataProblems.append(s);
+      this.fromDataProblems.append("\n\n");
-      instantiatorClassName = DataSerializer.readNonPrimitiveClassName(in);
-      instantiatedClassName = DataSerializer.readNonPrimitiveClassName(in);
+      this.instantiatorClassName = DataSerializer.readNonPrimitiveClassName(in);
+      this.instantiatedClassName = DataSerializer.readNonPrimitiveClassName(in);
-          instantiatorClass = InternalDataSerializer.getCachedClass(instantiatorClassName);
+          this.instantiatorClass =
+              InternalDataSerializer.getCachedClass(this.instantiatorClassName); // fix for bug
+                                                                                 // 41206
-          recordFromDataProblem(String.format("Could not load instantiator class: %s", ex));
-          instantiatorClass = null;
+          recordFromDataProblem(
+              String.format("Could not load instantiator class: %s",
+                  ex));
+          this.instantiatorClass = null;
-          instantiatedClass = InternalDataSerializer.getCachedClass(instantiatedClassName);
+          this.instantiatedClass =
+              InternalDataSerializer.getCachedClass(this.instantiatedClassName); // fix for bug
+                                                                                 // 41206
-          recordFromDataProblem(String.format("Could not load instantiated class: %s", ex));
-          instantiatedClass = null;
+          recordFromDataProblem(
+              String.format("Could not load instantiated class: %s",
+                  ex));
+          this.instantiatedClass = null;
-      id = in.readInt();
-      eventId = DataSerializer.readObject(in);
+      this.id = in.readInt();
+      this.eventId = (EventID) DataSerializer.readObject(in);
-      String instatiatorName = (instantiatorClass == null) ? instantiatorClassName
-          : instantiatorClass.getName();
-      String instatiatedName = (instantiatedClass == null) ? instantiatedClassName
-          : instantiatedClass.getName();
-      return String.format("Register Instantiator %s of class %s that instantiates a %s", id,
-          instatiatorName, instatiatedName);
+      String instatiatorName = (this.instantiatorClass == null) ? this.instantiatorClassName
+          : this.instantiatorClass.getName();
+      String instatiatedName = (this.instantiatedClass == null) ? this.instantiatedClassName
+          : this.instantiatedClass.getName();
+      return String.format("Register Instantiator %s of class %s that instantiates a %s",
+
+          new Object[] {Integer.valueOf(this.id), instatiatorName, instatiatedName});
-      instantiatorClass = s.getClass();
-      instantiatedClass = s.getInstantiatedClass();
-      id = s.getId();
-      eventId = (EventID) s.getEventId();
-      context = (ClientProxyMembershipID) s.getContext();
+      this.instantiatorClass = s.getClass();
+      this.instantiatedClass = s.getInstantiatedClass();
+      this.id = s.getId();
+      this.eventId = (EventID) s.getEventId();
+      this.context = (ClientProxyMembershipID) s.getContext();
-      if (instantiatorClass != null && instantiatedClass != null) {
-        Instantiator s = newInstance(instantiatorClass, instantiatedClass, id);
-        s.setEventId(eventId);
-        s.setContext(context);
+      if (this.instantiatorClass != null && this.instantiatedClass != null) {
+        Instantiator s = newInstance(this.instantiatorClass, this.instantiatedClass, this.id);
+        s.setEventId(this.eventId);
+        s.setContext(this.context);
-      } else if (instantiatorClassName != null && instantiatedClassName != null) {
-        InternalInstantiator.register(instantiatorClassName, instantiatedClassName,
-            id, false, eventId, context);
+      } else if (this.instantiatorClassName != null && this.instantiatedClassName != null) {
+        InternalInstantiator.register(this.instantiatorClassName, this.instantiatedClassName,
+            this.id, false, this.eventId, this.context);
-      context = ClientProxyMembershipID.readCanonicalized(in);
+      this.context = ClientProxyMembershipID.readCanonicalized(in);
-      DataSerializer.writeObject(context, out);
+      DataSerializer.writeObject(this.context, out);
-    for (Instantiator instantiator : dsMap.values()) {
-      logger.info("Instantiator registered with id {} class {}", instantiator.getId(),
-          instantiator.getInstantiatedClass().getName());
+    for (Iterator itr = dsMap.values().iterator(); itr.hasNext();) {
+      Instantiator instantiator = (Instantiator) itr.next();
+
+      logger
+          .info("Instantiator registered with id {} class {}",
+              Integer.valueOf(instantiator.getId()),
+              instantiator.getInstantiatedClass().getName());
-    for (InstantiatorAttributesHolder holder : idsToHolders.values()) {
-      logger.info("Instantiator registered with holder id {} class {}", holder.getId(),
-          holder.getInstantiatedClassName());
+    for (Iterator itr = idsToHolders.values().iterator(); itr.hasNext();) {
+      InstantiatorAttributesHolder holder = (InstantiatorAttributesHolder) itr.next();
+
+      logger.info("Instantiator registered with holder id {} class {}",
+          Integer.valueOf(holder.getId()), holder.getInstantiatedClassName());

MOV26 INS26 INS26 MOV31 MOV31 MOV31 INS40 INS40 UPD40 MOV44 INS31 INS55 MOV43 MOV43 MOV8 UPD83 UPD39 INS42 INS8 UPD83 UPD39 UPD42 INS29 UPD83 UPD42 INS43 INS8 INS29 UPD83 MOV83 MOV83 INS39 INS42 INS44 INS43 INS8 MOV29 INS83 INS83 INS42 MOV43 MOV23 MOV31 INS31 MOV31 MOV31 MOV31 MOV31 INS14 INS60 INS25 INS60 INS25 INS83 INS83 MOV43 UPD42 MOV43 UPD42 INS60 INS60 INS21 INS41 INS65 UPD43 UPD42 UPD42 MOV42 INS70 INS21 INS65 INS65 INS43 INS42 INS42 INS60 INS61 INS83 INS83 INS83 INS83 INS83 INS8 MOV78 MOV44 MOV78 MOV44 MOV43 MOV21 MOV29 INS83 INS42 MOV44 MOV8 MOV78 MOV44 MOV78 MOV44 MOV43 INS24 INS24 MOV43 MOV43 UPD74 INS74 MOV43 INS59 INS27 INS8 INS43 INS59 INS27 MOV8 MOV39 MOV43 INS5 INS59 INS43 INS59 INS32 INS11 INS43 INS32 INS32 INS66 UPD42 INS44 INS32 INS8 INS32 INS66 INS42 INS66 UPD42 MOV42 INS39 INS59 INS27 INS8 INS21 INS21 INS21 INS21 MOV21 INS21 MOV21 INS58 INS32 MOV8 INS58 INS32 MOV8 INS43 INS43 INS43 INS43 INS43 INS32 INS60 MOV25 INS42 MOV32 INS42 INS33 MOV41 INS42 INS42 INS32 INS42 INS33 INS33 INS32 INS11 INS32 INS43 INS85 INS42 INS21 INS60 INS42 INS42 INS14 INS60 INS61 INS42 INS42 INS32 MOV5 INS32 UPD42 MOV42 UPD42 UPD42 MOV32 UPD42 UPD42 INS3 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 MOV42 MOV43 INS42 UPD42 MOV42 INS42 INS21 INS21 INS21 UPD42 MOV42 UPD42 MOV42 INS34 INS42 INS36 INS34 INS60 INS60 INS60 INS54 INS54 INS25 INS21 INS7 INS7 INS7 INS7 INS7 MOV43 MOV43 INS7 INS43 INS59 UPD42 MOV42 UPD42 MOV42 INS60 INS43 INS59 INS42 INS42 INS60 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 INS59 UPD42 MOV42 INS42 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS42 INS42 INS42 MOV43 MOV32 INS42 INS42 INS42 INS42 INS7 INS5 INS59 INS60 INS21 INS60 INS21 MOV43 INS43 INS59 INS32 MOV8 INS42 INS42 INS42 MOV42 MOV3 MOV43 MOV42 MOV42 INS5 INS32 INS32 INS32 INS32 MOV7 INS43 INS59 INS43 INS59 INS39 INS59 INS8 INS12 INS8 INS12 INS42 INS8 INS32 INS22 MOV32 INS22 INS32 INS22 MOV32 INS22 MOV11 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS22 INS32 INS22 INS11 INS3 INS22 INS22 INS22 INS22 INS22 MOV11 INS22 INS22 UPD42 MOV42 INS42 INS32 INS43 INS59 UPD42 MOV42 INS42 INS32 INS43 INS59 INS42 INS32 INS32 INS8 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS33 UPD42 INS3 INS42 INS32 INS43 INS85 INS42 INS3 INS43 INS59 INS32 INS42 INS43 INS59 INS32 INS42 UPD42 MOV42 INS42 INS32 INS42 INS42 INS5 INS32 INS43 INS85 INS42 INS42 INS22 INS42 INS42 INS32 INS42 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS32 UPD42 MOV42 UPD42 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS9 INS21 INS44 INS8 MOV21 INS44 INS8 INS18 INS42 INS32 INS9 INS52 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS22 MOV43 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS43 MOV32 INS22 INS22 INS5 INS4 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS22 MOV43 INS52 INS42 INS52 INS42 MOV32 INS42 INS42 INS42 INS11 INS32 MOV32 INS42 INS42 INS42 INS11 INS32 INS42 INS42 INS42 INS42 MOV42 UPD42 INS60 INS25 INS3 INS5 INS4 INS42 INS42 INS42 INS21 INS42 INS5 INS4 INS42 INS42 MOV14 INS42 INS42 INS42 INS42 INS42 MOV14 INS42 INS42 INS42 MOV32 INS42 INS43 INS85 INS42 INS42 INS42 INS22 INS52 INS42 INS52 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS7 INS43 INS42 MOV21 INS43 INS42 MOV21 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS52 INS42 INS52 INS42 MOV42 INS22 INS22 INS52 INS42 INS52 INS42 INS22 INS42 INS52 INS42 INS22 INS52 INS42 INS22 INS43 INS85 INS32 INS42 INS42 INS52 INS42 INS52 INS42 INS22 INS22 INS22 INS22 INS43 INS32 INS42 INS42 MOV32 INS43 INS32 INS42 INS42 MOV32 INS3 INS42 UPD42 MOV42 INS32 MOV43 INS59 MOV27 INS8 INS22 INS22 INS22 INS22 INS5 INS4 INS8 INS43 INS85 MOV57 MOV57 INS7 INS60 INS43 INS85 INS42 INS16 UPD42 INS60 INS8 INS42 INS52 INS42 INS42 INS32 INS42 INS42 INS22 INS22 INS22 INS52 INS42 INS52 INS42 INS22 INS22 INS22 INS22 INS52 INS42 INS22 INS52 INS42 INS22 INS52 INS42 INS42 INS42 INS42 INS22 INS22 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS22 INS22 INS22 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS5 INS4 INS42 INS42 MOV32 INS42 INS42 INS32 MOV21 INS8 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS43 INS85 MOV32 INS32 UPD42 INS60 INS25 INS42 UPD42 INS3 INS42 INS32 INS43 INS59 INS42 INS42 INS11 INS11 INS43 INS59 UPD42 INS60 INS25 INS42 INS42 INS42 INS42 INS9 UPD42 UPD42 INS42 INS42 INS9 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS22 INS22 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS43 INS85 MOV32 INS32 INS32 INS42 INS42 INS42 INS32 INS42 INS32 INS41 INS42 INS42 INS42 MOV42 INS43 INS59 INS27 INS8 INS5 INS4 INS42 INS42 INS42 INS60 INS42 INS42 MOV32 MOV43 INS42 MOV43 INS32 MOV43 INS32 INS42 INS42 INS11 INS43 INS59 INS27 INS8 INS52 INS42 INS52 INS42 INS22 INS22 INS52 INS42 INS22 INS22 INS42 INS42 INS42 MOV42 INS42 INS42 MOV42 INS3 INS42 INS42 MOV32 INS42 INS32 INS42 INS42 INS32 INS27 INS32 MOV21 INS43 INS85 MOV57 MOV57 MOV43 INS59 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV11 INS43 INS32 INS42 INS42 INS32 INS27 INS32 MOV21 INS52 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS5 INS4 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS45 INS3 INS42 INS42 INS27 INS27 INS32 INS42 INS32 INS42 INS42 MOV32 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS27 INS32 INS42 INS32 INS43 INS85 INS42 MOV32 MOV32 INS5 INS4 INS42 INS33 INS32 INS33 INS42 INS42 INS32 INS42 INS32 INS42 INS33 INS32 INS33 INS42 INS42 INS32 INS42 INS32 INS42 INS43 INS85 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS45 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS45 INS32 INS3 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 INS5 INS4 INS43 INS85 INS32 MOV32 INS42 INS42 INS42 INS42 MOV42 DEL74 DEL74 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL83 DEL42 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL8 DEL28 DEL42 DEL42 DEL42 DEL42 DEL45 DEL79 DEL83 DEL83 DEL42 DEL41 DEL8 DEL31 DEL42 DEL32 DEL25 DEL8 DEL32 DEL38 DEL25 DEL42 DEL32 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL66 DEL65 DEL29 DEL42 DEL78 DEL42 DEL32 DEL8 DEL76 DEL74 DEL76 DEL74 DEL42 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL41 DEL8 DEL25 DEL41 DEL8 DEL31 DEL32 DEL8 DEL43 DEL42 DEL44 DEL70 DEL34 DEL32 DEL74 DEL74 DEL66 DEL66 DEL65 DEL29 DEL42 DEL83 DEL42 DEL44 DEL83 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL32 DEL33 DEL27 DEL42 DEL42 DEL83 DEL83 DEL42 DEL32 DEL59 DEL60 DEL45 DEL32 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL83 DEL83 DEL42 DEL83 DEL42 DEL42 DEL7 DEL21 DEL42 DEL7 DEL21 DEL8 DEL31 DEL55 DEL43 DEL42 DEL44 DEL70 DEL43 DEL42 DEL44 DEL70
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * An object of this class gets created during the organization of operands in a
- * CompiledJunction. It gets created if there exists multiple filter evaluable
- * conditions in where clause of the query with those conditions dependent on
- * more than one group of independent iterators. Thus presence of more than one
- * region in a query is a prerequisite for the creation of this object. However,
- * actual creation will occur iff there exists more than one GroupJunction or
- * more than one CompositeGroupJunction or a combination of one or more
- * GroupJunctions & one or more CompositeGroupJunctions
+ * An object of this class gets created during the organization of operands in a CompiledJunction.
+ * It gets created if there exists multiple filter evaluable conditions in where clause of the query
+ * with those conditions dependent on more than one group of independent iterators. Thus presence of
+ * more than one region in a query is a prerequisite for the creation of this object. However,
+ * actual creation will occur iff there exists more than one GroupJunction or more than one
+ * CompositeGroupJunction or a combination of one or more GroupJunctions & one or more
+ * CompositeGroupJunctions
-public class AllGroupJunction extends AbstractCompiledValue implements Filter,
-    OQLLexerTokenTypes {
+public class AllGroupJunction extends AbstractCompiledValue implements Filter, OQLLexerTokenTypes {
-  
+
-  public SelectResults filterEvaluate(ExecutionContext context,
-      SelectResults intermediateResults) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+  public SelectResults filterEvaluate(ExecutionContext context, SelectResults intermediateResults)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-    }
-    else {
+    } else {
-   * Asif:Evaluates the individual GroupJunctions and CompositeGroupJunctions
-   * and does a cartesian of the results so obtained and simultaneously
-   * expanding it to the query from clause level as well as evaluating any iter
-   * evaluatable conditions. The evaluated result of an AllGroupJunction will
-   * always be of the query from clause level which can be ORed or ANDd with
-   * filter evaluatable subtree CompiledJunction
+   * Asif:Evaluates the individual GroupJunctions and CompositeGroupJunctions and does a cartesian
+   * of the results so obtained and simultaneously expanding it to the query from clause level as
+   * well as evaluating any iter evaluatable conditions. The evaluated result of an AllGroupJunction
+   * will always be of the query from clause level which can be ORed or ANDd with filter evaluatable
+   * subtree CompiledJunction
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-      Support
-          .Assert(filterResults != null, "FilterResults cannot be null here");
+      Support.Assert(filterResults != null, "FilterResults cannot be null here");
-          StructType type = QueryUtils
-              .createStructTypeForRuntimeIterators(finalList);
+          StructType type = QueryUtils.createStructTypeForRuntimeIterators(finalList);
-        }
-        else {
-          ObjectType type = ((RuntimeIterator) finalList.iterator().next())
-              .getElementType();
+        } else {
+          ObjectType type = ((RuntimeIterator) finalList.iterator().next()).getElementType();
-            return QueryUtils.createStructCollection(context, (StructTypeImpl)type);
-          }
-          else {
+            return QueryUtils.createStructCollection(context, (StructTypeImpl) type);
+          } else {
-      }
-      else {
+      } else {
-        grpItrs = (gj instanceof CompositeGroupJunction) ? QueryUtils
-            .getDependentItrChainForIndpndntItrs(((CompositeGroupJunction) gj)
-                .getIndependentIteratorsOfCJ(), context)
-            : context
-                .getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(((AbstractGroupOrRangeJunction) gj)
-                    .getIndependentIteratorForGroup()[0]);
+        grpItrs = (gj instanceof CompositeGroupJunction)
+            ? QueryUtils.getDependentItrChainForIndpndntItrs(
+                ((CompositeGroupJunction) gj).getIndependentIteratorsOfCJ(), context)
+            : context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(
+                ((AbstractGroupOrRangeJunction) gj).getIndependentIteratorForGroup()[0]);
-      //TODO ASIF : Avoid creation of CompiledJunction by providing
+      // TODO ASIF : Avoid creation of CompiledJunction by providing
-      }
-      else {
+      } else {
-    observer
-        .beforeCartesianOfGroupJunctionsInAnAllGroupJunctionOfType_AND(results);
-    resultsSet = QueryUtils.cartesian(results, itrsForResultFields,
-        expansionList, finalList, context, iterOperandsToSend);
+    observer.beforeCartesianOfGroupJunctionsInAnAllGroupJunctionOfType_AND(results);
+    resultsSet = QueryUtils.cartesian(results, itrsForResultFields, expansionList, finalList,
+        context, iterOperandsToSend);
-    Support.Assert(resultsSet != null,
-        "ResultsSet obtained was NULL in AllGroupJunction");
+    Support.Assert(resultsSet != null, "ResultsSet obtained was NULL in AllGroupJunction");
-   * Evaluates the individual GroupJunctions and CompositeGroupJunctions and
-   * expands the individual results so obtained to the query from clause
-   * iterator level ( i.e top level iterators). The expanded results so obtained
-   * are then merged (union) to get the ORed results.The evaluated result of an
-   * AllGroupJunction will always be of the query from clause iterator level 
-   * (top level) which can be ORed or ANDd with filter evaluable subtree
-   * CompiledJunction.
+   * Evaluates the individual GroupJunctions and CompositeGroupJunctions and expands the individual
+   * results so obtained to the query from clause iterator level ( i.e top level iterators). The
+   * expanded results so obtained are then merged (union) to get the ORed results.The evaluated
+   * result of an AllGroupJunction will always be of the query from clause iterator level (top
+   * level) which can be ORed or ANDd with filter evaluable subtree CompiledJunction.
-  private SelectResults evaluateOrJunction(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  private SelectResults evaluateOrJunction(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-      grpItrs = (gj instanceof CompositeGroupJunction) ? QueryUtils
-          .getDependentItrChainForIndpndntItrs(((CompositeGroupJunction) gj)
-              .getIndependentIteratorsOfCJ(), context) : context
-          .getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(((AbstractGroupOrRangeJunction) gj)
-              .getIndependentIteratorForGroup()[0]);
+      grpItrs = (gj instanceof CompositeGroupJunction)
+          ? QueryUtils.getDependentItrChainForIndpndntItrs(
+              ((CompositeGroupJunction) gj).getIndependentIteratorsOfCJ(), context)
+          : context.getCurrScopeDpndntItrsBasedOnSingleIndpndntItr(
+              ((AbstractGroupOrRangeJunction) gj).getIndependentIteratorForGroup()[0]);
-      SelectResults expandedResult = QueryUtils.cartesian(grpResults,
-          itrsForResultFields, expansionList, finalList, context, null/*
-                                                                       * Iter
-                                                                       * oprenad
-                                                                       * for OR
-                                                                       * Junction
-                                                                       * evaluation
-                                                                       * should
-                                                                       * be null
-                                                                       */);
+      SelectResults expandedResult =
+          QueryUtils.cartesian(grpResults, itrsForResultFields, expansionList, finalList, context,
+              null/*
+                   * Iter oprenad for OR Junction evaluation should be null
+                   */);
-  
-  public int getSizeEstimate(ExecutionContext context)throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException  {
-	 return 1;
+
+  public int getSizeEstimate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+    return 1;

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66
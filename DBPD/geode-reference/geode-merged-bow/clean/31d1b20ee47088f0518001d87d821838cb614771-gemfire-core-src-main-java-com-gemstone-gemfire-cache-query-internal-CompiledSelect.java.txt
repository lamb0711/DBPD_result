Initial import of geode-1.0.0.0-SNAPSHOT-2.
All the new sub-project directories (like jvsd) were not imported.
A diff was done to confirm that this commit is exactly the same as
the open directory the snapshot was made from.

-import it.unimi.dsi.fastutil.objects.Object2ObjectOpenCustomHashMap;
-
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.TreeSet;
+import com.gemstone.gemfire.cache.query.QueryInvalidException;
-  private List orderByAttrs; //order by attributes: list of CompiledValue
+  protected List<CompiledSortCriterion> orderByAttrs; //order by attributes: list of CompiledValue
-  private List projAttrs; //projection attributes: list of Object[2]:
+  protected List projAttrs; //projection attributes: list of Object[2]:
+  protected List<CompiledValue> groupBy = null;
-  private ArrayList hints;
+  private List<String> hints;
+  protected boolean transformationDone = false;
+  protected ObjectType cachedElementTypeForOrderBy = null;
+  private boolean hasUnmappedOrderByCols = false; 
+  
-                        List iterators, List projAttrs,List orderByAttrs, CompiledValue limit, ArrayList hints) {
+                        List iterators, List projAttrs,List<CompiledSortCriterion> orderByAttrs, CompiledValue limit,
+                        List<String> hints, List<CompiledValue> groupByClause) {
+    this.groupBy = groupByClause;
+     
+  
+  public boolean isGroupBy() { 
+    return this.groupBy != null;
+  }
+  
+  public boolean isOrderBy() { 
+    return this.orderByAttrs != null;
+  }
-  public List getOrderByAttrs() {
+  public List<CompiledSortCriterion> getOrderByAttrs() {
+      
+        this.doTreeTransformation(context);
+        
+        this.doTreeTransformation(context);
+  
+  protected void doTreeTransformation(ExecutionContext context) throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+    if(!this.transformationDone) {
+      this.cachedElementTypeForOrderBy = prepareResultType(context);
+      this.mapOrderByColumns(context);
+      this.transformGroupByIfPossible(context);         
+    }
+    this.transformationDone = true;
+  }
+  
+  /**
+   * Transforms the group by clause into distinct order by clause, if possible
+   * @param context
+   * @throws AmbiguousNameException
+   * @throws TypeMismatchException
+   * @throws NameResolutionException
+   */
+  private void transformGroupByIfPossible(ExecutionContext context) 
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException  {
+    //for time being assume that the group by cols are explicitly mentioned in proj
+    if(this.groupBy != null) {
+      List projAttribs = this.projAttrs;
+      if(projAttribs == null) {
+        projAttribs = new ArrayList();
+        List currentIters = context.getCurrentIterators();
+        for(Object o: currentIters) {
+          RuntimeIterator rIter = (RuntimeIterator)o;
+          String name = rIter.getName();
+          projAttribs.add(new Object[]{name, rIter});
+        }
+      }
+      
+      if(projAttribs != null && projAttribs.size() != this.groupBy.size()) {
+        throw new QueryInvalidException(
+            LocalizedStrings.DefaultQuery_PROJ_COL_ABSENT_IN_GROUP_BY.toLocalizedString() +" or "
+            + LocalizedStrings.DefaultQuery_GROUP_BY_COL_ABSENT_IN_PROJ.toLocalizedString());
+      }
+     
+      boolean shouldTransform = true;
+      StringBuffer lhsBuffer = new StringBuffer();
+      StringBuffer rhsBuffer = new StringBuffer();
+      
+      outer :for(int i = 0; i < projAttribs.size() ; ++i) {
+        Object[] prj = (Object[]) TypeUtils.checkCast(projAttribs.get(i), Object[].class);
+        CompiledValue groupByAttr = this.groupBy.get(i);
+        if(prj[0] != null) {
+          if( groupByAttr instanceof CompiledID ) {
+            if (prj[0].equals(((CompiledID)groupByAttr).getId())) {              
+              lhsBuffer.delete(0,lhsBuffer.length());
+              rhsBuffer.delete(0,rhsBuffer.length());
+              continue;  
+            }
+          }
+        }
+        CompiledValue cvProj = (CompiledValue) TypeUtils.checkCast(prj[1], CompiledValue.class);
+        cvProj.generateCanonicalizedExpression(lhsBuffer, context);
+        groupByAttr.generateCanonicalizedExpression(rhsBuffer, context);
+        if(lhsBuffer.length() == rhsBuffer.length()) {          
+          for(int indx = 0; indx < lhsBuffer.length() ; ++indx) {
+            if(lhsBuffer.charAt(indx) != rhsBuffer.charAt(indx)) {
+              shouldTransform = false;
+              break outer;
+            }
+          }
+        }else {
+          shouldTransform = false;
+          break;
+        }     
+       
+        lhsBuffer.delete(0,lhsBuffer.length());
+        rhsBuffer.delete(0,rhsBuffer.length());
+        
+      }
+      //check if the order by clause is null or order by clause is same as proj.
+      //for now check if order by is null
+      if(shouldTransform && this.orderByAttrs == null) {
+        this.modifyGroupByToOrderBy(true, context);
+      }else {
+        throw new QueryInvalidException(
+            LocalizedStrings.DefaultQuery_PROJ_COL_ABSENT_IN_GROUP_BY.toLocalizedString() +" or "
+            + LocalizedStrings.DefaultQuery_GROUP_BY_COL_ABSENT_IN_PROJ.toLocalizedString());
+      }
+    }
+  }
+  
+  protected void modifyGroupByToOrderBy(boolean setDistinct, ExecutionContext context) throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+    if(setDistinct) {
+      this.distinct = setDistinct;
+    }
+    this.orderByAttrs = new ArrayList<CompiledSortCriterion>(this.groupBy.size());
+    int colIndex = 0;
+    for(CompiledValue cv : this.groupBy) {      
+      CompiledSortCriterion csc = new CompiledSortCriterion(false, cv);      
+      csc.mapExpressionToProjectionField(projAttrs, context) ;       
+      this.orderByAttrs.add(csc);
+    }
+    this.groupBy = null;
+  }
+  
+  private void mapOrderByColumns(ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException,
+      NameResolutionException {
+    if (this.orderByAttrs != null) {
+      Iterator<CompiledSortCriterion> iter = this.orderByAttrs.iterator();
+      while (iter.hasNext()) {
+        CompiledSortCriterion csc = iter.next();
+
+        // Asif: Ideally for replicated regions, the requirement that
+        // projected columns should
+        // contain order by fields ( directly or derivable on it),
+        // is not needed. But for PR , the query gathers only projected
+        // columns, so applying order by on the query node
+        // will need order by values ( which we dont send). So this
+        // restriction is needed.
+        // Also if this restriction is assumed to be correct, then the order
+        // by comparator can be optimized as
+        // it does not need to keep the mapping of evaluated order by clause,
+        // for comparison
+        if (!csc.mapExpressionToProjectionField(this.projAttrs, context)) {          
+          this.hasUnmappedOrderByCols = true;
+        }
+      }
+    }
+  }
+  
+  
+  private void evalCanonicalizedExpressionForCSC(CompiledSortCriterion csc, ExecutionContext context,
+      StringBuffer buffer) throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+    csc.getExpr().generateCanonicalizedExpression(buffer, context);
+  }
-  public Object evaluate(ExecutionContext context) throws FunctionDomainException, TypeMismatchException,
+  public ObjectType getElementTypeForOrderByQueries() {
+    return this.cachedElementTypeForOrderBy;
+  }
+  
+  public SelectResults evaluate(ExecutionContext context) throws FunctionDomainException, TypeMismatchException,
+    if(this.hasUnmappedOrderByCols && context.getBucketList() != null) {
+      throw new QueryInvalidException(LocalizedStrings.DefaultQuery_ORDER_BY_ATTRIBS_NOT_PRESENT_IN_PROJ.toLocalizedString()); 
+    }
-      Integer limitValue = evaluateLimitValue(context);
-      Object result = null;
+      Integer limitValue = evaluateLimitValue(context, this.limit);
+      SelectResults result = null;
-            csc.getExpr().generateCanonicalizedExpression(preferredIndexCondn, context);
+            this.evalCanonicalizedExpressionForCSC(csc, context, preferredIndexCondn);
-                ((CompiledSortCriterion) this.orderByAttrs.get(0)).expr
-                    .generateCanonicalizedExpression(temp, context);
-
+                CompiledSortCriterion csc = (CompiledSortCriterion) this.orderByAttrs.get(0);
+                this.evalCanonicalizedExpressionForCSC(csc, context, temp);
-                ObjectType resultType = this.prepareResultType(context);
+                ObjectType resultType = this.cachedElementTypeForOrderBy != null? this.cachedElementTypeForOrderBy :this.prepareResultType(context);
-                result = applyProjectionOnCollection(result, context,
+                result = applyProjectionOnCollection( result, context,
-      if (result == null) { return QueryService.UNDEFINED; }
+      //TODO:Asif: It does not appear that results would be null ever. 
+      //if (result == null) { return QueryService.UNDEFINED; }
+      assert result != null;
-          if (r instanceof ResultsBag.SetView) {
+          if (r instanceof Bag.SetView) {
-            ((ResultsBag)sr).applyLimit(limitValue);
+            ((Bag)sr).applyLimit(limitValue);
-  int getLimitValue(Object[] bindArguments) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+  public int getLimitValue(Object[] bindArguments) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    SelectResults results = context.getResults();
-    if (results == null) {
-      results = prepareEmptyResultSet(context,false);
-    }
+    SelectResults results = prepareEmptyResultSet(context,false);
+    
-        Integer limitValue = evaluateLimitValue(context);
+        Integer limitValue = evaluateLimitValue(context, this.limit);
-  private Object applyProjectionOnCollection(Object resultSet,
+  private SelectResults applyProjectionOnCollection(SelectResults resultSet,
-      if (resultSet instanceof StructBag) {
-        Iterator resultsIter = ((StructBag)resultSet).iterator();
+      boolean isStructType = resultSet.getCollectionType().getElementType() != null 
+          && resultSet.getCollectionType().getElementType().isStructType();  
+      if (isStructType) {
+        Iterator resultsIter = resultSet.iterator();
-        Integer limitValue = evaluateLimitValue(context);
+        Integer limitValue = evaluateLimitValue(context, this.limit);
-        Integer limitValue = evaluateLimitValue(context);
+        Integer limitValue = evaluateLimitValue(context, this.limit);
-  {
+ {
-    ObjectType elementType = prepareResultType(context);
+    ObjectType elementType = this.cachedElementTypeForOrderBy != null ? this.cachedElementTypeForOrderBy
+        : prepareResultType(context);
-        if(!this.distinct) {
-          throw new UnsupportedOperationException(LocalizedStrings.CompiledSelect_NONDISTINCT_ORDERBY_NOT_YET_SUPPORTED.toLocalizedString());
-        }
+        boolean nullValuesAtStart = !((CompiledSortCriterion)orderByAttrs.get(0)).getCriterion();
-          if(ignoreOrderBy) {
-            results = new LinkedStructSet((StructTypeImpl)elementType);
-          }else {
-            results = new SortedStructSet(new OrderByComparator( (StructTypeImpl)elementType),(StructTypeImpl)elementType);
+          if (ignoreOrderBy) {
+            results = this.distinct ? new LinkedStructSet(
+                (StructTypeImpl) elementType) : new SortedResultsBag(
+                elementType, nullValuesAtStart);
+
+          } else {
+            OrderByComparator comparator = this.hasUnmappedOrderByCols ? new OrderByComparatorUnmapped(
+                this.orderByAttrs, (StructTypeImpl) elementType, context)
+                : new OrderByComparator(this.orderByAttrs,
+                    (StructTypeImpl) elementType, context);
+            results = this.distinct ? new SortedStructSet(comparator,
+                (StructTypeImpl) elementType) : new SortedStructBag(comparator,
+                (StructTypeImpl) elementType, nullValuesAtStart);
+
-          if(ignoreOrderBy) {
-            results = new LinkedResultSet();
-          }else {
-            results = new SortedResultSet(new OrderByComparator(elementType));
+          if (ignoreOrderBy) {
+            results = this.distinct ? new LinkedResultSet()
+                : new SortedResultsBag(nullValuesAtStart);
+
+          } else {
+            OrderByComparator comparator = this.hasUnmappedOrderByCols ? new OrderByComparatorUnmapped(
+                this.orderByAttrs, elementType, context)
+                : new OrderByComparator(this.orderByAttrs, elementType, context);
+            results = this.distinct ? new SortedResultSet(comparator)
+                : new SortedResultsBag(comparator, nullValuesAtStart);
-        if (elementType.isStructType()) {
-          results = new StructBag((StructType)elementType,  context.getCachePerfStats());
+        if (this.distinct) {
+          if (elementType.isStructType()) {
+            results = new StructSet((StructType) elementType);
+          } else {
+            results = new ResultsSet(elementType);
+          }
-          results = new ResultsBag(elementType, context.getCachePerfStats());
+          if (elementType.isStructType()) {
+            results = new StructBag((StructType) elementType,
+                context.getCachePerfStats());
+          } else {
+            results = new ResultsBag(elementType, context.getCachePerfStats());
+          }
-      // Shobhit: If its a 'COUNT' query and no End processing required Like for 'DISTINCT'
-      // we can directly keep count in ResultSet and ResultBag is good enough for that.
-      results = new ResultsBag(new ObjectTypeImpl(Integer.class), 1 /*initial capacity for count value*/, context.getCachePerfStats());
+      // Shobhit: If its a 'COUNT' query and no End processing required Like for
+      // 'DISTINCT'
+      // we can directly keep count in ResultSet and ResultBag is good enough
+      // for that.
+      results = new ResultsBag(new ObjectTypeImpl(Integer.class), 1 /*
+                                                                     * initial
+                                                                     * capacity
+                                                                     * for count
+                                                                     * value
+                                                                     */,
+          context.getCachePerfStats());
-      
+
-    
-    return results;
-    
-    /*
-    if (elementType.isStructType()) {
-      if (this.orderByAttrs != null) { // sorted struct
-        return prepareEmptySortedStructSet((StructTypeImpl)elementType);
-      } else { // unsorted struct
-        return new StructBag((StructType)elementType,  context.getCachePerfStats());
-      }
-    }
-    else { // non-struct
-      if (this.orderByAttrs != null) { // sorted non-struct
-        return prepareEmptySortedResultSet(elementType);
-      } else { // unsorted non-struct
-        return new ResultsBag(elementType, context.getCachePerfStats());
-      }
-    }
-    */
-    /*
-    return prepareEmptySelectResults(elementType, this.orderByAttrs != null,
-        context);
-    */
+   return results;   
-  public ObjectType prepareResultType(ExecutionContext context)
+  protected ObjectType prepareResultType(ExecutionContext context)
+  
-      Object resultSet, boolean ignoreOrderBy) throws FunctionDomainException, TypeMismatchException,
+      SelectResults resultSet, boolean ignoreOrderBy) throws FunctionDomainException, TypeMismatchException,
-    // Asif : Code modified to fix the bug of incorrect composition of
-    // ResultSet
-    //boolean newAddition = false;
+
-    boolean isStructSet = resultSet instanceof StructSet;
-    boolean isStructBag = resultSet instanceof StructBag;
-    boolean isResultBag = resultSet instanceof ResultsBag;
-    boolean isLinkedStructSet = resultSet instanceof LinkedStructSet;
-    boolean isLinkedResultSet = resultSet instanceof LinkedResultSet;
-    // @todo (resultSet instanceof SortedStructBag) ||
-    boolean isSortedStructSet = resultSet instanceof SortedStructSet;
+    ObjectType elementType = resultSet.getCollectionType().getElementType();
+    boolean isStruct = elementType != null && elementType.isStructType();
+
+    //TODO : Asif : Optimize this condition in some clean way
+    boolean isLinkedStructure = resultSet instanceof Ordered && ((Ordered)resultSet).dataPreordered();
+   
-      // In case PR order-by will get applied on the coordinator node 
+      // In case PR order-by will get applied on the coordinator node
-      Integer limitValue = evaluateLimitValue(context);
+      Integer limitValue = evaluateLimitValue(context, this.limit);
-    
+
-      comparator = (OrderByComparator)((TreeSet)resultSet).comparator();
+      comparator = (OrderByComparator) ((Ordered) resultSet).comparator();
-        RuntimeIterator iter = (RuntimeIterator)currrentRuntimeIters.get(i);
+        RuntimeIterator iter = (RuntimeIterator) currrentRuntimeIters.get(i);
-        // We still have to honor the cache level readserialized flag in 
+        // We still have to honor the cache level readserialized flag in
-      
+
-        //Counter is local to CompileSelect and not available in ResultSet until
-        //the end of evaluate call to this CompiledSelect object.
+        // Counter is local to CompileSelect and not available in ResultSet
+        // until
+        // the end of evaluate call to this CompiledSelect object.
-          evaluatedOrderByClause = evaluateSortCriteria(context, resultSet);
-          if (isSortedStructSet) {
-            if (values.length == 1 &&  values[0] instanceof StructImpl) {
-              structImpl = (StructImpl)values[0];
-              comparator.orderByMap.put(structImpl.getFieldValues(), evaluatedOrderByClause);
-              occurence = ((SortedStructSet)resultSet).add(structImpl) ? 1 : 0;
+          if (this.distinct) {
+            if (isStruct) {
+              if (values.length == 1 && values[0] instanceof StructImpl) {
+                structImpl = (StructImpl) values[0];
+                comparator.addEvaluatedSortCriteria(
+                    structImpl.getFieldValues(), context);
+                occurence =  resultSet.add(structImpl) ? 1
+                    : 0;
+              } else {
+                comparator.addEvaluatedSortCriteria(values, context);
+                occurence = ((StructFields) resultSet).addFieldValues(values) ? 1
+                    : 0;
+              }
+              // Asif: TODO:Instead of a normal Map containing which holds
+              // StructImpl object
+              // use a THashObject with Object[] array hashing stragtegy as we
+              // are unnnecessarily
+              // creating objects of type Object[]
-              comparator.orderByMap.put(values, evaluatedOrderByClause);
-              occurence = ((SortedStructSet)resultSet).addFieldValues(values) ? 1 : 0;            
-            } 
-            //Asif: TODO:Instead of a normal Map containing which holds StructImpl object
-            // use a THashObject with Object[] array hashing stragtegy as we are unnnecessarily
-            //creating objects of type Object[]          
-          }
-          else {
-            comparator.orderByMap.put(values[0], evaluatedOrderByClause);
-            occurence = ((SortedResultSet)resultSet).add(values[0]) ? 1 : 0;
+              comparator.addEvaluatedSortCriteria(values[0], context);
+              occurence =  resultSet.add(values[0]) ? 1 : 0;
+            }
+          } else {
+            if (isStruct) {
+              if (values.length == 1 && values[0] instanceof StructImpl) {
+                structImpl = (StructImpl) values[0];
+                comparator.addEvaluatedSortCriteria(
+                    structImpl.getFieldValues(), context);
+                occurence = ((Bag) resultSet).addAndGetOccurence(structImpl.getFieldValues());
+              } else {
+                comparator.addEvaluatedSortCriteria(values, context);
+                occurence = ((Bag) resultSet).addAndGetOccurence(values) ;
+                    
+              }
+            } else {
+              comparator.addEvaluatedSortCriteria(values[0], context);
+              occurence = ((Bag) resultSet)
+                  .addAndGetOccurence(values[0]);
+            }
-          if (isStructSet) {
-            occurence = ((StructSet) resultSet).addFieldValues(values) ? 1 : 0;
-          } else if (isStructBag) {
-            occurence = ((ResultsBag) resultSet).addAndGetOccurence(values);
-          } else if (isLinkedStructSet) {
-            StructImpl structImpl;
-            if (values.length == 1 && values[0] instanceof StructImpl) {
-              structImpl = (StructImpl) values[0];
-            } else {
-              structImpl = new StructImpl(((LinkedStructSet) resultSet).structType, values);
+          if(isLinkedStructure) {
+            if(isStruct) {
+              StructImpl structImpl;
+              if (values.length == 1 && values[0] instanceof StructImpl) {
+                structImpl = (StructImpl) values[0];
+              } else {
+                structImpl = new StructImpl(
+                    (StructTypeImpl)elementType, values);
+              }
+              if(this.distinct) {
+                occurence = resultSet.add(structImpl) ? 1 : 0;
+              }else {
+                occurence = ((Bag)resultSet).addAndGetOccurence(structImpl);
+              } 
+            }else {
+              if(this.distinct) {
+                occurence = resultSet.add(values[0]) ? 1 : 0;  
+              }else {
+                occurence = ((Bag)resultSet).addAndGetOccurence(values[0]);
+              }
+              
-            occurence = ((LinkedStructSet) resultSet).add(structImpl) ? 1 : 0;
-          } else if (isLinkedResultSet) {
-            occurence = ((LinkedResultSet) resultSet).add(values[0]) ? 1 : 0;
-          } else if (isResultBag) {
-            boolean add = true;
-            if (context.isCqQueryContext()) {
-              if (values[0] instanceof Region.Entry) {
-                Region.Entry e = (Region.Entry) values[0];
-                if (!e.isDestroyed()) {
-                  try {
-                    values[0] = new CqEntry(e.getKey(), e.getValue());
-                  } catch (EntryDestroyedException ede) {
-                    // Even though isDestory() check is made, the entry could
-                    // throw EntryDestroyedException if the value becomes null.
-                    add = false;
+          }
+          else {
+            if (this.distinct) {
+              if (isStruct) {
+                occurence = ((StructFields) resultSet).addFieldValues(values) ? 1
+                    : 0;
+              } else {
+                occurence =  resultSet.add(values[0]) ? 1 : 0;
+              }
+            } else {
+              if (isStruct) {
+                occurence = ((Bag) resultSet)
+                    .addAndGetOccurence(values);
+              } else {
+                boolean add = true;
+                if (context.isCqQueryContext()) {
+                  if (values[0] instanceof Region.Entry) {
+                    Region.Entry e = (Region.Entry) values[0];
+                    if (!e.isDestroyed()) {
+                      try {
+                        values[0] = new CqEntry(e.getKey(), e.getValue());
+                      } catch (EntryDestroyedException ede) {
+                        // Even though isDestory() check is made, the entry
+                        // could
+                        // throw EntryDestroyedException if the value becomes
+                        // null.
+                        add = false;
+                      }
+                    } else {
+                      add = false;
+                    }
-                } else {
-                  add = false;
+                }
+                if (add) {
+                  occurence = ((Bag) resultSet)
+                      .addAndGetOccurence(values[0]);
-            if (add) {
-              occurence = ((ResultsBag) resultSet).addAndGetOccurence(values[0]);
-            }
-          } else {
-            // Is a ResultsSet
-            occurence = ((SelectResults) resultSet).add(values[0]) ? 1 : 0;
-    }
-    else { // One or more projection attributes
+    } else { // One or more projection attributes
-        Object projDef[] = (Object[])projAttrs.get(i);
-        values[i] = ((CompiledValue)projDef[1]).evaluate(context);
+        Object projDef[] = (Object[]) projAttrs.get(i);
+        values[i] = ((CompiledValue) projDef[1]).evaluate(context);
-        // We still have to honor the cache level readserialized flag in 
+        // We still have to honor the cache level readserialized flag in
-
-     // if order by is present
+      // if order by is present
-        evaluatedOrderByClause = evaluateSortCriteria(context, resultSet);
-        if (isSortedStructSet) {
-          comparator.orderByMap.put(values, evaluatedOrderByClause);
-          //Asif: Occurence field is used to identify the corrcet number of iterations
-          //required to implement the limit based on the presence or absence
-          //of distinct clause
-          occurence = ((SortedStructSet)resultSet).addFieldValues(values) ? 1 : 0;
+        if (distinct) {
+          if (isStruct) {
+            comparator.addEvaluatedSortCriteria(values, context);
+            // Asif: Occurence field is used to identify the corrcet number of
+            // iterations
+            // required to implement the limit based on the presence or absence
+            // of distinct clause
+            occurence = ((StructFields) resultSet).addFieldValues(values) ? 1
+                : 0;
+          } else {
+            comparator.addEvaluatedSortCriteria(values[0], context);
+            occurence =  resultSet.add(values[0]) ? 1 : 0;
+          }
+        } else {
+          if (isStruct) {
+            comparator.addEvaluatedSortCriteria(values, context);
+            occurence = ((Bag) resultSet).addAndGetOccurence(values);
+          } else {
+            comparator.addEvaluatedSortCriteria(values[0], context);
+            occurence = ((Bag) resultSet)
+                .addAndGetOccurence(values[0]);
+          }
-        else {
-          comparator.orderByMap.put(values[0], evaluatedOrderByClause);
-          occurence = ((SortedResultSet)resultSet).add(values[0]) ? 1 : 0;
-        }
-      }
-      else {
-        if (isStructSet) {
-          occurence = ((StructSet)resultSet).addFieldValues(values) ? 1 : 0;
-        }
-        else if (isStructBag) {
-          occurence = ((ResultsBag)resultSet).addAndGetOccurence(values);
-        }else if(isLinkedStructSet) {
-          StructImpl structImpl = new StructImpl(
-              ((LinkedStructSet)resultSet).structType, values);;
-                    
-          occurence = ((LinkedStructSet)resultSet).add(structImpl) ? 1 : 0;
-        }else if(isLinkedResultSet) {
-          occurence = ((LinkedResultSet)resultSet).add(values[0]) ? 1 : 0;
-        }
-        else if (isResultBag) {
-          occurence = ((ResultsBag)resultSet).addAndGetOccurence(values[0]);
-        }
-        else {
-          // Is a ResultsSet
-          occurence = ((SelectResults)resultSet).add(values[0]) ? 1 : 0;
+      } else {
+        if(isLinkedStructure) {
+          if(isStruct) {
+            StructImpl structImpl = new StructImpl((StructTypeImpl)elementType, values);
+            if(this.distinct) {
+              occurence = resultSet.add(structImpl) ? 1 : 0;
+            }else {
+              occurence = ((Bag)resultSet).addAndGetOccurence(structImpl);
+            }
+   
+          }else {
+            if(this.distinct) {
+              occurence =  resultSet.add(values[0]) ? 1 : 0;
+            }else {
+              occurence = ((Bag)resultSet).addAndGetOccurence(values[0]);
+            }
+          }
+        }else {
+          if (this.distinct) {
+            if (isStruct) {
+              occurence = ((StructFields) resultSet).addFieldValues(values) ? 1
+                  : 0;
+            } else {
+              occurence =  resultSet.add(values[0]) ? 1 : 0;
+            }
+          } else {
+            if (isStruct) {
+              occurence = ((Bag) resultSet)
+                  .addAndGetOccurence(values);
+            } else {
+              occurence = ((Bag) resultSet)
+                  .addAndGetOccurence(values[0]);
+            }
+          }
-  /**
-   * Yogesh : This methods evaluates sort criteria and returns a ArrayList of 
-   *          Object[] arrays of evaluated criteria  
-   * @param context
-   * @param sr
-   * @return ArrayList
-   * @throws FunctionDomainException
-   * @throws TypeMismatchException
-   * @throws NameResolutionException
-   * @throws QueryInvocationTargetException
-   */
-  private ArrayList evaluateSortCriteria(ExecutionContext context, Object sr)
-  throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-  	
-    CompiledSortCriterion csc ;    
-    ArrayList list = new ArrayList();
-    if(orderByAttrs != null){
-      Iterator orderiter = orderByAttrs.iterator();
-      while (orderiter.hasNext()) {
-    	csc = (CompiledSortCriterion)orderiter.next();
-    	Object[] arr = new Object[2];
-    	arr[0] = csc.evaluate(context);
-    	arr[1] = Boolean.valueOf(csc.criterion);
-     	list.add(arr);     	
-      }
-   
-  	}
-    return list;
-  }
+ 
-  private Integer evaluateLimitValue(ExecutionContext context) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+  protected static Integer evaluateLimitValue(ExecutionContext context, CompiledValue limit) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    if (this.limit != null) {
-        limitValue =  (Integer)this.limit.evaluate(context);
+    if (limit != null) {
+        limitValue =  (Integer)limit.evaluate(context);
-  }
+  }  
+
-/**
- * Yogesh : A generic comparator class which compares two Object/StructImpl according to 
- * their sort criterion specified in order by clause 
- */
-class OrderByComparator implements Comparator 
-{
-  /** a map of the form 
-   * <StructImpl/Object,  List(Object[], Object[])>
-   */
-  final Map orderByMap ;
-  private final ObjectType objType;
-  public OrderByComparator(ObjectType objType) {
-    this.objType = objType;
-    if(objType.isStructType()) {
-      orderByMap = new Object2ObjectOpenCustomHashMap(new StructBag.ObjectArrayFUHashingStrategy());
-    }else {
-      this.orderByMap = new HashMap();
-    }
-  }
-  /**
-   * Compares its two arguments for order.  Returns a negative integer,
-   * zero, or a positive integer as the first argument is less than, equal
-   * to, or greater than the second.
-   * @param obj1 the first object to be compared.
-   * @param obj2 the second object to be compared.
-   * @return a negative integer, zero, or a positive integer as the
-   * 	       first argument is less than, equal to, or greater than the
-   *	       second. 
-   * @throws ClassCastException if the arguments' types prevent them from
-   * 	       being compared by this Comparator. 
-   */
-  public int compare(Object obj1 , Object obj2){
-    int result = -1;	
-    if (obj1 == null && obj2 == null) {
-      return 0;
-    }
-    if ((this.objType.isStructType() && obj1 instanceof Object[] && obj2 instanceof Object[]) || 
-        !this.objType.isStructType()){ // obj1 instanceof Object && obj2 instanceof Object){
-      ArrayList list1 = (ArrayList)orderByMap.get(obj1);          
-      ArrayList list2 = (ArrayList)orderByMap.get(obj2);
-      if(list1.size() != list2.size()){ 
-        Support.assertionFailed("Error Occured due to improper sort criteria evaluation ");
-      }else{
-        for (int i=0; i< list1.size(); i++){
-          Object arr1[] = (Object [])list1.get(i);
-          Object arr2[] = (Object [])list2.get(i);
-          // check for null.
-          if (arr1[0] == null || arr2[0] == null) {
-            if (arr1[0] == null) {
-              result = (arr2[0] == null ? 0: -1); 
-            } else {
-              result = 1;
-            }
-          } else if (arr1[0] == QueryService.UNDEFINED || arr2[0] == QueryService.UNDEFINED) {
-            if (arr1[0] == QueryService.UNDEFINED) {
-              result = (arr2[0] == QueryService.UNDEFINED ? 0: -1); 
-            } else {
-              result = 1;
-            }
-          } else {
-            if(arr1[0] instanceof PdxString && arr2[0] instanceof String){
-              arr2[0] = new PdxString((String) arr2[0]);
-            }
-            else if(arr2[0] instanceof PdxString && arr1[0] instanceof String){
-              arr1[0] = new PdxString((String) arr1[0]);
-            }
-            result = ((Comparable)arr1[0]).compareTo(arr2[0]);
-          }
-
-          // equals.
-          if (result == 0) {
-            continue;
-          } else {
-            // not equal, change the sign based on the order by type (asc, desc).
-            if(((Boolean)arr1[1]).booleanValue()) {
-              result = (result * -1);
-            }
-            return result;
-          }		 			
-        }
-        //The comparable fields are equal, so we check if the overall keys are equal or not
-        if(this.objType.isStructType()) {
-          int i =0;
-          for(Object o1:(Object[])obj1) {
-            Object o2 = ((Object[])obj2)[i++];
-
-            // Check for null value.
-            if (o1 == null || o2 == null)
-            {
-              if (o1 == null) {
-                if (o2 == null) {
-                  continue;
-                }
-                return -1;
-              } else {
-                return 1;
-              }
-            } else if (o1 == QueryService.UNDEFINED || o2 == QueryService.UNDEFINED) {
-              if (o1 == QueryService.UNDEFINED) {
-                if (o2 == QueryService.UNDEFINED) {
-                  continue;
-                }
-                return -1;
-              } else {
-                return 1;
-              }
-            }
-
-            if (o1 instanceof Comparable) {
-              if(o1 instanceof PdxString && o2 instanceof String){
-                o2 = new PdxString((String) o2);
-              }
-              else if(o2 instanceof PdxString && o1 instanceof String){
-                o1 = new PdxString((String) o1);
-              }
-              int rslt = ((Comparable) o1).compareTo(o2);
-              if (rslt == 0) {
-                continue;
-              } else {
-                return rslt;
-              }
-            } else if(!o1.equals(o2)) {
-              return -1; 
-            }
-          }
-          return 0;
-        }else {
-          if(obj1 instanceof PdxString && obj2 instanceof String){
-            obj2 = new PdxString((String) obj2);
-          }
-          else if(obj2 instanceof PdxString && obj1 instanceof String){
-            obj1 = new PdxString((String) obj1);
-          }
-
-          if (obj1 instanceof Comparable) {
-            return ((Comparable) obj1).compareTo(obj2);
-          } else {
-            return obj1.equals(obj2)?0:-1;
-          }
-        }
-      } 	
-    }		
-    return -1;
-  } 
-  
-}

MOV26 UPD40 INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 UPD83 INS74 UPD83 INS83 INS74 INS59 INS74 INS83 INS39 INS59 INS83 INS43 INS59 INS83 INS39 INS59 INS44 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS8 INS74 INS83 INS39 INS42 INS44 INS43 INS43 INS43 INS8 MOV29 MOV83 INS39 INS42 MOV44 INS43 MOV43 MOV43 INS8 INS83 INS39 INS42 INS44 INS44 INS43 INS43 INS43 INS8 INS83 INS39 INS42 INS44 INS43 INS43 INS43 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS43 INS43 INS8 INS83 MOV43 INS42 INS8 UPD43 INS83 UPD43 UPD83 MOV8 UPD83 INS83 INS44 MOV43 INS43 INS43 INS43 INS42 INS33 INS43 MOV43 INS42 INS9 INS42 INS42 INS33 INS42 INS9 INS74 INS74 INS74 INS42 INS21 INS41 INS41 MOV43 INS43 INS43 INS42 INS42 INS42 INS42 INS25 INS21 INS42 INS25 INS39 INS42 INS43 INS42 INS42 INS42 INS42 INS25 MOV21 MOV60 INS70 INS21 INS43 INS42 INS42 INS42 INS42 INS25 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 MOV21 MOV41 UPD42 INS25 UPD42 UPD43 MOV43 MOV60 MOV60 INS60 INS60 INS60 MOV60 MOV60 MOV60 MOV25 INS25 MOV41 INS43 INS42 INS42 INS42 INS42 UPD42 MOV42 MOV43 INS43 INS43 MOV43 INS43 INS43 INS7 INS27 INS27 INS42 INS42 INS38 INS8 INS7 UPD66 UPD42 INS27 INS8 INS42 INS42 INS8 INS39 INS44 INS22 INS8 INS7 INS42 INS27 INS8 INS42 INS42 INS42 INS22 INS27 INS8 UPD42 MOV43 INS59 INS39 INS59 INS39 INS59 MOV27 INS8 MOV27 MOV8 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS22 INS33 INS22 INS33 INS22 INS21 INS21 INS21 INS22 INS9 INS22 INS33 INS60 INS25 INS25 INS60 INS60 MOV60 INS30 INS25 INS21 INS22 INS14 UPD42 INS34 INS43 INS42 INS52 INS42 INS60 MOV21 MOV21 INS22 INS33 INS22 INS33 INS60 INS61 UPD42 INS52 INS42 INS22 INS27 INS53 INS6 MOV32 INS60 INS16 INS42 INS32 INS42 INS27 INS42 INS27 INS21 MOV60 MOV60 MOV24 MOV60 MOV60 MOV24 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS7 INS32 INS32 INS52 INS42 INS52 INS42 INS43 INS59 INS27 INS8 INS27 INS8 INS39 INS59 INS43 INS59 UPD43 INS42 INS24 INS27 INS8 INS8 INS7 INS52 INS42 INS74 INS32 INS42 INS43 INS59 INS32 INS52 INS42 INS52 INS42 INS74 INS59 INS32 INS8 INS52 INS42 INS32 INS33 INS14 INS43 INS27 INS39 INS59 INS42 INS27 INS22 INS32 INS8 INS32 INS42 INS27 INS32 INS62 INS32 MOV43 INS7 MOV27 MOV8 INS8 INS8 INS21 INS21 INS22 MOV32 INS52 INS42 INS42 INS52 INS42 INS42 UPD42 MOV42 INS42 INS22 INS42 INS33 INS21 INS60 INS70 INS27 INS27 INS53 INS42 INS9 UPD42 MOV42 INS42 INS14 UPD42 UPD42 INS14 MOV58 INS27 INS38 INS8 INS42 INS27 INS21 INS53 INS22 INS42 MOV43 INS43 INS22 UPD42 MOV42 INS42 INS42 INS14 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS22 UPD42 MOV43 INS43 INS42 INS32 INS42 INS42 INS60 INS25 INS42 INS42 INS43 INS32 INS42 MOV42 MOV33 INS42 INS27 INS22 INS33 INS52 INS42 INS42 INS42 INS60 INS25 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS43 INS36 INS42 MOV42 INS42 INS11 MOV25 INS25 INS25 INS32 INS32 INS52 INS42 INS52 INS42 INS7 INS43 INS59 INS44 INS42 INS8 INS42 INS33 INS32 INS32 INS14 INS43 INS43 INS42 INS32 INS42 MOV60 INS60 INS25 MOV60 INS21 INS21 INS25 INS21 INS21 INS22 INS33 INS32 INS14 INS52 INS42 MOV42 INS52 INS42 INS43 INS9 INS42 INS52 INS42 INS42 INS22 INS42 INS43 INS59 INS38 INS8 INS42 INS40 INS42 INS22 INS43 INS27 INS32 INS52 INS42 INS39 INS59 INS22 INS8 MOV8 INS42 INS11 MOV22 INS43 INS32 INS42 INS8 INS8 INS42 INS8 INS8 INS42 INS8 INS8 MOV43 INS52 INS42 INS42 INS52 INS42 INS42 INS42 MOV14 INS42 INS42 INS32 MOV43 INS42 INS60 INS60 INS21 INS42 INS42 INS22 INS42 INS43 INS27 INS42 INS42 INS42 INS42 MOV5 INS43 INS59 MOV27 INS8 INS43 INS32 INS32 INS27 INS8 INS8 INS32 INS32 INS52 INS42 INS52 INS42 INS9 INS42 INS43 INS27 INS42 INS52 INS42 INS42 INS42 INS32 INS32 INS21 INS52 INS42 INS42 INS32 INS33 INS32 INS42 INS42 INS38 INS52 INS42 INS25 INS43 INS42 INS42 INS36 INS42 MOV60 INS25 MOV25 INS25 INS25 INS25 INS25 INS42 INS42 INS42 INS43 INS59 MOV43 INS59 INS32 INS52 INS42 UPD42 MOV42 INS32 INS45 INS32 INS42 INS11 INS42 INS42 INS32 INS2 INS25 INS42 UPD42 INS11 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS32 INS32 INS24 INS21 INS10 INS42 INS42 INS34 INS32 INS42 INS42 INS34 INS32 INS42 INS32 INS45 INS32 INS42 INS42 INS42 INS42 INS22 INS42 INS7 INS22 INS32 INS42 INS32 INS42 INS42 INS22 INS32 INS32 INS8 INS8 INS42 INS11 INS22 MOV8 INS8 UPD42 INS8 INS8 INS42 INS8 INS8 INS42 INS8 INS8 INS42 INS8 INS8 INS22 INS8 INS8 INS42 INS42 INS11 INS42 INS32 INS42 INS42 INS3 INS40 INS42 INS40 INS42 MOV5 INS32 INS22 INS42 INS42 INS42 INS34 INS62 INS8 INS43 INS32 INS42 INS42 INS42 INS42 INS58 INS27 INS38 INS8 INS7 INS42 INS42 INS42 INS42 INS40 INS42 INS40 INS42 INS52 INS42 INS22 INS9 INS21 UPD43 INS52 INS42 INS42 INS42 INS42 INS42 INS52 INS42 MOV22 INS36 INS42 INS60 INS60 INS42 INS42 INS21 INS21 INS43 INS42 INS52 INS42 INS25 INS25 MOV25 INS21 INS21 INS21 MOV21 INS21 INS21 INS21 INS21 INS60 INS25 INS25 INS52 INS42 INS25 INS25 INS43 INS42 INS42 INS42 MOV5 INS4 INS42 INS42 INS32 INS57 INS52 INS42 INS42 INS43 INS25 INS42 UPD42 MOV42 UPD42 MOV42 INS2 INS57 INS39 INS59 INS42 INS32 INS42 INS25 INS42 INS9 INS52 INS42 INS32 UPD40 INS11 MOV43 INS59 MOV43 INS59 INS7 INS7 INS42 UPD42 UPD42 MOV42 INS8 INS8 INS42 MOV8 INS8 INS22 INS8 INS8 INS32 INS7 INS32 INS7 INS32 INS7 INS32 INS7 MOV43 INS59 INS22 INS8 INS8 INS22 INS8 INS8 INS42 INS8 INS8 INS42 INS8 INS8 INS42 INS42 INS42 INS42 INS42 INS42 MOV5 INS42 INS32 INS8 INS42 INS34 INS43 INS42 INS34 INS42 INS42 INS27 INS8 INS52 INS42 INS42 INS42 INS42 INS43 INS32 INS16 INS42 INS16 INS16 INS16 INS42 INS16 INS16 INS42 INS14 INS42 INS14 INS21 INS25 INS21 INS21 INS25 INS25 INS52 INS42 INS25 MOV25 MOV8 INS42 INS42 INS42 INS42 INS42 INS16 INS42 INS42 MOV2 INS42 INS42 INS16 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS2 INS42 INS42 INS32 INS42 INS14 INS52 INS42 INS21 INS21 INS52 INS42 INS21 INS21 INS21 INS21 INS21 INS21 INS2 INS42 INS32 INS21 INS21 INS18 INS42 INS32 INS32 INS21 INS10 UPD42 MOV42 UPD42 MOV42 INS42 INS34 MOV22 MOV14 INS14 INS22 INS14 INS14 INS22 INS14 INS14 INS22 MOV14 INS14 INS22 INS14 INS14 INS22 INS14 INS14 MOV43 INS11 INS43 INS42 INS32 INS27 INS8 MOV8 INS32 INS7 INS22 INS8 INS8 INS22 INS8 INS8 UPD42 MOV42 MOV8 INS8 UPD42 INS32 INS34 INS34 MOV32 MOV2 INS34 INS34 INS36 INS42 INS42 INS42 INS34 INS36 INS42 INS2 MOV43 INS11 INS42 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS7 INS42 INS34 INS36 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS60 UPD43 INS43 INS42 INS42 INS52 INS42 INS43 INS22 MOV11 INS42 MOV43 INS22 INS11 INS42 INS52 INS42 MOV43 INS42 INS11 INS43 INS42 INS11 INS42 INS52 INS42 INS43 INS42 INS52 INS42 INS43 INS22 INS42 INS42 INS43 INS22 INS42 INS42 INS52 INS42 MOV43 INS42 INS43 INS42 INS42 INS43 INS42 INS42 INS42 INS42 MOV2 INS42 INS27 INS62 INS21 INS21 INS21 INS21 INS42 INS42 MOV2 INS42 INS42 INS32 INS52 INS42 MOV21 INS21 INS52 INS42 INS21 INS21 INS21 INS36 INS42 INS42 UPD42 UPD42 INS11 INS11 INS42 INS34 INS43 INS42 INS42 INS16 INS42 INS32 INS42 INS16 INS42 INS32 INS42 INS16 INS42 INS16 INS42 INS32 INS42 INS32 INS11 INS42 INS42 INS34 INS32 INS42 INS42 INS34 INS32 INS42 INS9 MOV43 INS59 UPD42 INS42 INS42 INS52 INS42 INS52 INS42 INS43 INS42 MOV42 INS43 INS42 INS42 INS43 INS42 INS42 INS42 INS52 INS42 INS42 INS52 INS42 MOV42 INS42 INS42 MOV32 INS40 INS34 INS2 INS43 INS7 INS32 INS7 INS32 INS36 INS42 MOV2 INS7 INS7 INS7 INS7 INS11 INS43 INS42 INS43 INS42 INS42 INS32 INS34 INS34 INS36 INS42 INS42 INS32 INS34 INS34 INS36 INS42 INS2 INS32 INS34 INS34 INS32 INS34 INS34 INS36 INS42 INS42 INS36 INS42 INS2 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV11 INS52 UPD42 UPD42 INS42 INS16 INS42 INS42 INS42 UPD42 UPD42 INS42 UPD42 INS42 UPD42 INS42 MOV2 INS42 INS34 INS42 INS42 INS11 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS11 MOV14 INS42 INS32 INS42 INS16 INS42 INS32 INS42 INS16 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS11 INS42 INS42 INS2 INS11 INS42 INS34 INS36 INS42 INS42 INS42 INS42 INS2 INS11 INS11 INS42 INS34 INS42 INS27 INS22 MOV32 INS43 INS2 INS42 INS42 INS36 INS42 INS32 INS43 INS42 MOV43 INS42 INS36 INS42 INS42 INS32 INS34 INS34 INS36 INS42 MOV2 INS32 INS34 INS34 MOV36 UPD42 MOV42 INS42 INS42 INS43 INS42 INS42 INS34 INS43 INS42 INS11 INS42 INS34 INS43 INS42 INS43 INS42 INS22 INS33 INS52 INS42 INS42 INS42 INS42 INS34 INS11 INS42 INS42 INS42 INS42 INS11 INS42 INS42 MOV2 INS11 UPD42 INS42 INS42 INS42 MOV2 INS42 INS42 INS43 INS42 INS42 INS42 INS52 INS42 INS43 INS42 UPD43 INS43 INS42 INS43 INS42 UPD43 MOV2 INS42 UPD43 INS42 UPD42 INS42 INS42 UPD43 UPD42 UPD42 UPD42 UPD43 UPD42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL43 DEL66 DEL42 DEL65 DEL66 DEL65 DEL42 DEL65 DEL43 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL11 DEL34 DEL3 DEL42 DEL34 DEL2 DEL40 DEL32 DEL7 DEL42 DEL42 DEL36 DEL42 DEL22 DEL27 DEL40 DEL41 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL33 DEL27 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL11 DEL36 DEL38 DEL43 DEL40 DEL32 DEL14 DEL53 DEL8 DEL25 DEL14 DEL42 DEL14 DEL14 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL40 DEL42 DEL11 DEL36 DEL40 DEL42 DEL11 DEL36 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL22 DEL42 DEL14 DEL42 DEL43 DEL42 DEL11 DEL36 DEL32 DEL34 DEL34 DEL16 DEL42 DEL42 DEL11 DEL36 DEL42 DEL42 DEL32 DEL34 DEL34 DEL16 DEL7 DEL21 DEL40 DEL39 DEL42 DEL42 DEL42 DEL43 DEL62 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL43 DEL62 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL43 DEL62 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL43 DEL62 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL43 DEL62 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL43 DEL62 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL11 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL40 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL32 DEL34 DEL34 DEL16 DEL7 DEL21 DEL8 DEL40 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL34 DEL34 DEL16 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL32 DEL34 DEL34 DEL16 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL22 DEL42 DEL14 DEL59 DEL60 DEL20 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL32 DEL34 DEL34 DEL16 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL34 DEL34 DEL16 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL11 DEL36 DEL42 DEL32 DEL34 DEL34 DEL16 DEL7 DEL21 DEL8 DEL25 DEL25 DEL25 DEL25 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL43 DEL42 DEL43 DEL42 DEL44 DEL43 DEL43 DEL32 DEL42 DEL34 DEL2 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL61 DEL8 DEL25 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL42 DEL42 DEL43 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL59 DEL23 DEL83 DEL42 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL40 DEL43 DEL14 DEL14 DEL7 DEL21 DEL8 DEL52 DEL42 DEL22 DEL42 DEL43 DEL14 DEL7 DEL21 DEL8 DEL25 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL34 DEL38 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL27 DEL34 DEL41 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL42 DEL43 DEL85 DEL5 DEL62 DEL42 DEL42 DEL43 DEL85 DEL5 DEL62 DEL27 DEL36 DEL52 DEL42 DEL22 DEL42 DEL32 DEL38 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL85 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL85 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL34 DEL2 DEL33 DEL27 DEL42 DEL34 DEL2 DEL33 DEL27 DEL27 DEL42 DEL34 DEL2 DEL33 DEL27 DEL42 DEL42 DEL34 DEL2 DEL33 DEL27 DEL34 DEL34 DEL38 DEL16 DEL36 DEL7 DEL21 DEL8 DEL42 DEL34 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL34 DEL2 DEL40 DEL27 DEL42 DEL34 DEL2 DEL40 DEL27 DEL27 DEL42 DEL34 DEL2 DEL40 DEL27 DEL42 DEL42 DEL34 DEL2 DEL40 DEL27 DEL34 DEL34 DEL38 DEL16 DEL36 DEL7 DEL21 DEL8 DEL42 DEL34 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL34 DEL2 DEL42 DEL43 DEL62 DEL42 DEL34 DEL2 DEL62 DEL27 DEL42 DEL34 DEL2 DEL42 DEL43 DEL42 DEL34 DEL2 DEL11 DEL14 DEL7 DEL21 DEL8 DEL42 DEL34 DEL2 DEL42 DEL43 DEL62 DEL42 DEL34 DEL2 DEL62 DEL27 DEL42 DEL34 DEL2 DEL42 DEL43 DEL42 DEL43 DEL42 DEL34 DEL2 DEL11 DEL14 DEL7 DEL21 DEL8 DEL25 DEL25 DEL42 DEL42 DEL43 DEL42 DEL34 DEL2 DEL11 DEL36 DEL42 DEL42 DEL34 DEL2 DEL32 DEL7 DEL21 DEL8 DEL25 DEL25 DEL42 DEL34 DEL27 DEL18 DEL8 DEL42 DEL43 DEL42 DEL34 DEL2 DEL11 DEL36 DEL42 DEL32 DEL42 DEL42 DEL34 DEL38 DEL27 DEL36 DEL7 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL25 DEL8 DEL24 DEL52 DEL42 DEL22 DEL42 DEL32 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL85 DEL5 DEL42 DEL11 DEL42 DEL43 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL11 DEL36 DEL42 DEL37 DEL2 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL27 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL18 DEL8 DEL25 DEL34 DEL38 DEL41 DEL8 DEL34 DEL41 DEL8 DEL25 DEL8 DEL42 DEL40 DEL27 DEL42 DEL40 DEL27 DEL27 DEL42 DEL40 DEL27 DEL42 DEL40 DEL27 DEL18 DEL8 DEL25 DEL34 DEL38 DEL41 DEL8 DEL34 DEL41 DEL8 DEL25 DEL8 DEL25 DEL25 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL27 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL11 DEL14 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL27 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL11 DEL14 DEL7 DEL21 DEL8 DEL25 DEL25 DEL39 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL34 DEL27 DEL18 DEL8 DEL42 DEL41 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL32 DEL38 DEL34 DEL38 DEL41 DEL8 DEL25 DEL25 DEL8 DEL70 DEL34 DEL41 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL27 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL11 DEL14 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL27 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL11 DEL14 DEL7 DEL21 DEL8 DEL25 DEL25 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL42 DEL42 DEL32 DEL34 DEL34 DEL38 DEL16 DEL41 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL34 DEL38 DEL41 DEL8 DEL31 DEL55
GEODE-607: improve SimpleMemoryAllocatorImpl unit test coverage

Also changed ChunkType to an interface and removed dead code.
Refactored duplicate code into AbstractStoredObject.
Removed some more sqlf dead code.

+   * This does not account for the additional internal fragmentation caused by the off-heap header
+   * which currently is always 8 bytes.
+  /**
+   * How many unused bytes are allowed in a huge memory allocation.
+   */
-  private static final AtomicReference<Thread> asyncCleanupThread = new AtomicReference<Thread>();
+  private static final AtomicReference<Thread> asyncCleanupThread = new AtomicReference<>();
-  private static final boolean PRETOUCH = Boolean.getBoolean("gemfire.OFF_HEAP_PRETOUCH_PAGES");
-  static final int OFF_HEAP_PAGE_SIZE = Integer.getInteger("gemfire.OFF_HEAP_PAGE_SIZE", UnsafeMemoryChunk.getPageSize());
-  private static final boolean DO_EXPENSIVE_VALIDATION = Boolean.getBoolean("gemfire.OFF_HEAP_DO_EXPENSIVE_VALIDATION");;
+  private static final boolean DO_EXPENSIVE_VALIDATION = Boolean.getBoolean("gemfire.OFF_HEAP_DO_EXPENSIVE_VALIDATION");
-  public static MemoryAllocator create(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats, LogWriter lw, int slabCount, long offHeapMemorySize, long maxSlabSize) {
+  public static MemoryAllocator create(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats, LogWriter lw, 
+      int slabCount, long offHeapMemorySize, long maxSlabSize) {
+    return create(ooohml, stats, lw, slabCount, offHeapMemorySize, maxSlabSize,
+        null, TINY_MULTIPLE, BATCH_SIZE, TINY_FREE_LIST_COUNT, HUGE_MULTIPLE, 
+        new UnsafeMemoryChunk.Factory() {
+      @Override
+      public UnsafeMemoryChunk create(int size) {
+        return new UnsafeMemoryChunk(size);
+      }
+    });
+  }
+
+  private static SimpleMemoryAllocatorImpl create(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats, LogWriter lw, 
+      int slabCount, long offHeapMemorySize, long maxSlabSize, 
+      UnsafeMemoryChunk[] slabs, int tinyMultiple, int batchSize, int tinyFreeListCount, int hugeMultiple,
+      UnsafeMemoryChunk.Factory memChunkFactory) {
-      result.reuse(ooohml, lw, stats, offHeapMemorySize);
-      lw.config("Reusing " + result.getTotalMemory() + " bytes of off-heap memory. The maximum size of a single off-heap object is " + result.largestSlab + " bytes.");
+      result.reuse(ooohml, lw, stats, offHeapMemorySize, slabs);
+      if (lw != null) {
+        lw.config("Reusing " + result.getTotalMemory() + " bytes of off-heap memory. The maximum size of a single off-heap object is " + result.largestSlab + " bytes.");
+      }
-      // allocate memory chunks
-      //SimpleMemoryAllocatorImpl.cleanupPreviousAllocator();
-      lw.config("Allocating " + offHeapMemorySize + " bytes of off-heap memory. The maximum size of a single off-heap object is " + maxSlabSize + " bytes.");
-      UnsafeMemoryChunk[] slabs = new UnsafeMemoryChunk[slabCount];
-      long uncreatedMemory = offHeapMemorySize;
-      for (int i=0; i < slabCount; i++) {
-        try {
-        if (uncreatedMemory >= maxSlabSize) {
-          slabs[i] = new UnsafeMemoryChunk((int) maxSlabSize);
-          uncreatedMemory -= maxSlabSize;
-        } else {
-          // the last slab can be smaller then maxSlabSize
-          slabs[i] = new UnsafeMemoryChunk((int) uncreatedMemory);
+      if (slabs == null) {
+        // allocate memory chunks
+        //SimpleMemoryAllocatorImpl.cleanupPreviousAllocator();
+        if (lw != null) {
+          lw.config("Allocating " + offHeapMemorySize + " bytes of off-heap memory. The maximum size of a single off-heap object is " + maxSlabSize + " bytes.");
-        } catch (OutOfMemoryError err) {
-          if (i > 0) {
-            lw.severe("Off-heap memory creation failed after successfully allocating " + (i*maxSlabSize) + " bytes of off-heap memory.");
-          }
-          for (int j=0; j < i; j++) {
-            if (slabs[j] != null) {
-              slabs[j].release();
+        slabs = new UnsafeMemoryChunk[slabCount];
+        long uncreatedMemory = offHeapMemorySize;
+        for (int i=0; i < slabCount; i++) {
+          try {
+            if (uncreatedMemory >= maxSlabSize) {
+              slabs[i] = memChunkFactory.create((int) maxSlabSize);
+              uncreatedMemory -= maxSlabSize;
+            } else {
+              // the last slab can be smaller then maxSlabSize
+              slabs[i] = memChunkFactory.create((int) uncreatedMemory);
+          } catch (OutOfMemoryError err) {
+            if (i > 0) {
+              if (lw != null) {
+                lw.severe("Off-heap memory creation failed after successfully allocating " + (i*maxSlabSize) + " bytes of off-heap memory.");
+              }
+            }
+            for (int j=0; j < i; j++) {
+              if (slabs[j] != null) {
+                slabs[j].release();
+              }
+            }
+            throw err;
-          throw err;
-      result = new SimpleMemoryAllocatorImpl(ooohml, stats, slabs);
-      created = true;
+      result = new SimpleMemoryAllocatorImpl(ooohml, stats, slabs, tinyMultiple, batchSize, tinyFreeListCount, hugeMultiple);
+      created = true;
-        stats.close();
-        ooohml.close();
+        if (stats != null) {
+          stats.close();
+        }
+        if (ooohml != null) {
+          ooohml.close();
+        }
+  static SimpleMemoryAllocatorImpl create(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats, LogWriter lw, 
+      int slabCount, long offHeapMemorySize, long maxSlabSize, UnsafeMemoryChunk.Factory memChunkFactory) {
+    return create(ooohml, stats, lw, slabCount, offHeapMemorySize, maxSlabSize, 
+        null, TINY_MULTIPLE, BATCH_SIZE, TINY_FREE_LIST_COUNT, HUGE_MULTIPLE, memChunkFactory);
+  }
+  // for unit tests
-    SimpleMemoryAllocatorImpl result = new SimpleMemoryAllocatorImpl(oooml, stats, slabs);
-    singleton = result;
-    LifecycleListener.invokeAfterCreate(result);
-    return result;
+    return create(oooml, stats, slabs, TINY_MULTIPLE, BATCH_SIZE, TINY_FREE_LIST_COUNT, HUGE_MULTIPLE);
+  }
+  // for unit tests
+  static SimpleMemoryAllocatorImpl create(OutOfOffHeapMemoryListener oooml, OffHeapMemoryStats stats, UnsafeMemoryChunk[] slabs,
+      int tinyMultiple, int batchSize, int tinyFreeListCount, int hugeMultiple) {
+    int slabCount = 0;
+    long offHeapMemorySize = 0;
+    long maxSlabSize = 0;
+    if (slabs != null) {
+      slabCount = slabs.length;
+      for (int i=0; i < slabCount; i++) {
+        int slabSize = slabs[i].getSize();
+        offHeapMemorySize += slabSize;
+        if (slabSize > maxSlabSize) {
+          maxSlabSize = slabSize;
+        }
+      }
+    }
+    return create(oooml, stats, null, slabCount, offHeapMemorySize, maxSlabSize, slabs, tinyMultiple, batchSize, tinyFreeListCount, hugeMultiple, null);
-  private void reuse(OutOfOffHeapMemoryListener oooml, LogWriter lw, OffHeapMemoryStats newStats, long offHeapMemorySize) {
+  
+  private void reuse(OutOfOffHeapMemoryListener oooml, LogWriter lw, OffHeapMemoryStats newStats, long offHeapMemorySize, UnsafeMemoryChunk[] slabs) {
-      lw.warning("Using " + getTotalMemory() + " bytes of existing off-heap memory instead of the requested " + offHeapMemorySize);
+      if (lw != null) {
+        lw.warning("Using " + getTotalMemory() + " bytes of existing off-heap memory instead of the requested " + offHeapMemorySize);
+      }
+    }
+    if (slabs != null) {
+      // this will only happen in unit tests
+      if (slabs != this.slabs) {
+        // If the unit test gave us a different array
+        // of slabs then something is wrong because we
+        // are trying to reuse the old already allocated
+        // array which means that the new one will never
+        // be used. Note that this code does not bother
+        // comparing the contents of the arrays.
+        throw new IllegalStateException("attempted to reuse existing off-heap memory even though new off-heap memory was allocated");
+      }
-  public static void cleanupPreviousAllocator() {
-    Thread t = asyncCleanupThread.getAndSet(null);
-    if (t != null) {
-//      try {
-//        // HACK to see if a delay fixes bug 47883
-//        Thread.sleep(3000);
-//      } catch (InterruptedException ignore) {
-//      }
-      t.interrupt();
-      try {
-        t.join(FREE_PAUSE_MILLIS);
-      } catch (InterruptedException ignore) {
-        Thread.currentThread().interrupt();
-      }
-    }
-  }
-  
-  private SimpleMemoryAllocatorImpl(final OutOfOffHeapMemoryListener oooml, final OffHeapMemoryStats stats, final UnsafeMemoryChunk[] slabs) {
+  private SimpleMemoryAllocatorImpl(final OutOfOffHeapMemoryListener oooml, final OffHeapMemoryStats stats, final UnsafeMemoryChunk[] slabs,
+      int tinyMultiple, int batchSize, int tinyFreeListCount, int hugeMultiple) {
-    if (TINY_MULTIPLE <= 0 || (TINY_MULTIPLE & 3) != 0) {
+    if (tinyMultiple <= 0 || (tinyMultiple & 3) != 0) {
-    if (TINY_MULTIPLE > 256) {
+    if (tinyMultiple > 256) {
-    if (BATCH_SIZE <= 0) {
+    if (batchSize <= 0) {
-    if (TINY_FREE_LIST_COUNT <= 0) {
+    if (tinyFreeListCount <= 0) {
-    assert HUGE_MULTIPLE <= 256;
+    if (hugeMultiple > 256 || hugeMultiple < 0) {
+      // this restriction exists because of the dataSize field in the object header.
+      throw new IllegalStateException("HUGE_MULTIPLE must be >= 0 and <= 256 but it was " + hugeMultiple);
+    }
-    if(GemFireCacheImpl.sqlfSystem()) {
-      throw new IllegalStateException("offheap sqlf not supported");
-//       String provider = GemFireCacheImpl.SQLF_FACTORY_PROVIDER;
-//       try {
-//         Class<?> factoryProvider = Class.forName(provider);
-//         Method method = factoryProvider.getDeclaredMethod("getChunkFactory");        
-//         this.chunkFactory  = (ChunkFactory)method.invoke(null, (Object [])null);
-//       }catch (Exception e) {
-//         throw new IllegalStateException("Exception in obtaining ChunkFactory class",  e);
-//       }
-
-    }else {
-      
-      this.chunkFactory = new GemFireChunkFactory();
-    }
+    this.chunkFactory = new GemFireChunkFactory();
-    if (PRETOUCH) {
-      final int tc;
-      if (Runtime.getRuntime().availableProcessors() > 1) {
-        tc = Runtime.getRuntime().availableProcessors() / 2;
-      } else {
-        tc = 1;
-      }
-      Thread[] threads = new Thread[tc];
-      for (int i=0; i < tc; i++) {
-        final int threadId = i;
-        threads[i] = new Thread(new Runnable() {
-          @Override
-          public void run() {
-            for (int slabId=threadId; slabId < slabs.length; slabId+=tc) {
-              final int slabSize = slabs[slabId].getSize();
-              for (int pageId=0; pageId < slabSize; pageId+=OFF_HEAP_PAGE_SIZE) {
-                slabs[slabId].writeByte(pageId, (byte) 0);
-              }
-            }
-          }
-        });
-        threads[i].start();
-      }
-      for (int i=0; i < tc; i++) {
-        try {
-          threads[i].join();
-        } catch (InterruptedException e) {
-          Thread.currentThread().interrupt();
-          break;
-        }
-      }
-    }
-      freeSlabsAsync(this.slabs);
+      freeSlabs(this.slabs);
-  private static final int FREE_PAUSE_MILLIS = Integer.getInteger("gemfire.OFF_HEAP_FREE_PAUSE_MILLIS", 90000);
-
-  
-  
-  private static void freeSlabsAsync(final UnsafeMemoryChunk[] slabs) {
-    //debugLog("called freeSlabsAsync", false);
-    // since we no longer free off-heap memory on every cache close
-    // and production code does not free it but instead reuses it
-    // we should be able to free it sync.
-    // If it turns out that it does need to be async then we need
-    // to make sure we call cleanupPreviousAllocator.
+  private static void freeSlabs(final UnsafeMemoryChunk[] slabs) {
+    //debugLog("called freeSlabs", false);
-//    Thread t = new Thread(new Runnable() {
-//      @Override
-//      public void run() {
-//        // pause this many millis before freeing the slabs.
-//        try {
-//          Thread.sleep(FREE_PAUSE_MILLIS);
-//        } catch (InterruptedException ignore) {
-//          // If we are interrupted we should wakeup
-//          // and free our slabs.
-//        }
-//        //debugLog("returning offheap memory to OS", false);
-//        for (int i=0; i < slabs.length; i++) {
-//          slabs[i].free();
-//        }
-//        //debugLog("returned offheap memory to OS", false);
-//        asyncCleanupThread.compareAndSet(Thread.currentThread(), null);
-//      }
-//    }, "asyncSlabDeallocator");
-//    t.setDaemon(true);
-//    t.start();
-//    asyncCleanupThread.set(t);    
-  protected int findSlab(long addr) {
+  int findSlab(long addr) {
-    validateAddressAndSizeWithinSlab(addr, size);
+    validateAddressAndSizeWithinSlab(addr, size, DO_EXPENSIVE_VALIDATION);
-  static void validateAddressAndSizeWithinSlab(long addr, int size) {
-    if (DO_EXPENSIVE_VALIDATION) {
+  static void validateAddressAndSizeWithinSlab(long addr, int size, boolean doExpensiveValidation) {
+    if (doExpensiveValidation) {
-  public List<MemoryBlock> getDeallocatedBlocks() {
-    return null;
-  }
-
-  @Override
-  public List<MemoryBlock> getUnusedBlocks() {
-    return null;
-  }
-  
-  @Override
-  public MemoryBlock getBlockContaining(long memoryAddress) {
-    return null;
-  }
-  
-  @Override

INS31 INS31 INS31 INS29 INS83 INS83 MOV43 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS8 UPD83 INS43 INS44 INS44 INS44 INS44 INS44 INS44 INS83 MOV43 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS8 MOV83 MOV43 UPD42 MOV42 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS8 INS44 INS44 INS44 INS44 INS44 MOV25 UPD42 INS44 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS41 INS42 INS5 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS41 INS41 INS43 INS42 INS43 INS42 INS5 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS60 INS60 INS60 INS25 INS41 INS5 INS42 INS25 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 MOV21 INS39 INS42 INS66 INS66 INS66 UPD74 INS42 INS42 INS42 INS32 INS43 INS85 INS40 INS42 INS42 INS42 INS40 INS32 INS32 UPD42 MOV42 INS42 INS43 INS85 INS39 INS59 INS39 INS59 INS39 INS59 INS27 INS8 INS32 INS43 INS85 INS8 INS27 INS8 INS27 INS8 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS33 INS21 INS24 INS42 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 INS25 INS42 INS33 INS25 UPD42 UPD42 UPD42 INS27 INS27 INS53 INS42 INS43 INS1 MOV21 INS8 INS7 MOV58 INS27 MOV37 INS8 INS27 MOV8 INS27 INS8 UPD42 INS42 UPD34 MOV34 INS42 UPD34 MOV34 INS14 INS40 INS31 INS25 INS25 INS25 INS25 INS42 INS40 INS42 INS42 INS60 INS21 INS25 INS42 INS33 INS42 INS22 INS53 UPD43 MOV43 INS27 UPD42 MOV78 INS83 MOV43 INS42 INS44 INS8 INS27 INS8 INS27 INS8 INS27 MOV8 INS27 INS8 INS39 INS59 INS7 INS27 INS8 INS52 INS42 INS14 UPD42 UPD42 INS45 UPD42 MOV42 INS39 INS42 INS41 INS42 INS42 INS33 MOV21 INS42 INS33 INS25 INS21 MOV60 MOV24 INS42 INS33 INS42 INS33 MOV21 UPD42 MOV42 MOV32 INS42 INS42 INS42 INS42 INS21 MOV43 INS45 INS14 INS27 INS8 INS7 MOV43 INS42 INS42 INS42 INS42 INS2 UPD42 INS7 MOV43 INS42 INS42 INS33 MOV21 INS42 MOV3 INS42 INS42 INS42 INS42 INS8 INS25 INS32 INS32 INS27 MOV8 INS42 INS42 MOV11 INS42 INS42 MOV11 INS42 INS33 DEL42 DEL43 DEL83 DEL83 DEL83 DEL39 DEL42 DEL45 DEL32 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL32 DEL32 DEL59 DEL23 DEL14 DEL42 DEL43 DEL14 DEL85 DEL5 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL42 DEL32 DEL21 DEL42 DEL41 DEL42 DEL45 DEL34 DEL83 DEL39 DEL43 DEL42 DEL42 DEL42 DEL33 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL31 DEL42 DEL83 DEL39 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL7 DEL21 DEL8 DEL42 DEL34 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL3 DEL59 DEL60 DEL42 DEL42 DEL27 DEL83 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL2 DEL42 DEL43 DEL83 DEL39 DEL42 DEL39 DEL42 DEL42 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL42 DEL7 DEL83 DEL39 DEL42 DEL42 DEL42 DEL2 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL27 DEL42 DEL42 DEL7 DEL42 DEL42 DEL2 DEL42 DEL42 DEL39 DEL34 DEL11 DEL32 DEL21 DEL8 DEL24 DEL8 DEL24 DEL8 DEL31 DEL1 DEL14 DEL14 DEL7 DEL21 DEL42 DEL42 DEL2 DEL42 DEL32 DEL21 DEL8 DEL24 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL10 DEL8 DEL12 DEL54 DEL8 DEL24 DEL8 DEL42 DEL34 DEL27 DEL6 DEL42 DEL42 DEL32 DEL45 DEL14 DEL53 DEL8 DEL8 DEL25 DEL83 DEL83 DEL83 DEL39 DEL59 DEL23 DEL83 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL33 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL33 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL39 DEL42 DEL44 DEL33 DEL41 DEL8 DEL31
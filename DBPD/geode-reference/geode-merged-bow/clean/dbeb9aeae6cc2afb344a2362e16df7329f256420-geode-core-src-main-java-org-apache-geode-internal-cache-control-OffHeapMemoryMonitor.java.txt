Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Allows for the setting of eviction and critical thresholds. These thresholds
- * are compared against current off-heap usage and, with the help of {#link
- * InternalResourceManager}, dispatches events when the thresholds are crossed.
+ * Allows for the setting of eviction and critical thresholds. These thresholds are compared against
+ * current off-heap usage and, with the help of {#link InternalResourceManager}, dispatches events
+ * when the thresholds are crossed.
-  private volatile MemoryEvent mostRecentEvent = new MemoryEvent(ResourceType.OFFHEAP_MEMORY, MemoryState.DISABLED,
-      MemoryState.DISABLED, null, 0L, true, this.thresholds);
+  private volatile MemoryEvent mostRecentEvent = new MemoryEvent(ResourceType.OFFHEAP_MEMORY,
+      MemoryState.DISABLED, MemoryState.DISABLED, null, 0L, true, this.thresholds);
-  
+
-  
+
-   * InternalResoruceManager insists on creating a OffHeapMemoryMonitor even when it
-   * does not have off-heap memory. So we need to handle memoryAllocator being null.
+   * InternalResoruceManager insists on creating a OffHeapMemoryMonitor even when it does not have
+   * off-heap memory. So we need to handle memoryAllocator being null.
-  OffHeapMemoryMonitor(final InternalResourceManager resourceManager, final GemFireCacheImpl cache, final MemoryAllocator memoryAllocator, final ResourceManagerStats stats) {
+  OffHeapMemoryMonitor(final InternalResourceManager resourceManager, final GemFireCacheImpl cache,
+      final MemoryAllocator memoryAllocator, final ResourceManagerStats stats) {
-    
+
-    
+
-   * Start monitoring off-heap memory usage by adding this as a listener to the
-   * off-heap memory allocator.
+   * Start monitoring off-heap memory usage by adding this as a listener to the off-heap memory
+   * allocator.
-      ThreadGroup group = LoggingThreadGroup.createThreadGroup("OffHeapMemoryMonitor Threads", logger);
+      ThreadGroup group =
+          LoggingThreadGroup.createThreadGroup("OffHeapMemoryMonitor Threads", logger);
-      
+
-      
+
+
-      
+
-      
+
-  
+
-   * Used by unit tests to be notified when OffHeapMemoryMonitor
-   * does something.
+   * Used by unit tests to be notified when OffHeapMemoryMonitor does something.
+     * 
-     * @param willSendEvent true if an event will be sent to the OffHeapMemoryUsageListener. 
+     * @param willSendEvent true if an event will be sent to the OffHeapMemoryUsageListener.
+
+
+     * 
-     * @param willSendEvent true if an event will be sent to the OffHeapMemoryUsageListener. 
+     * @param willSendEvent true if an event will be sent to the OffHeapMemoryUsageListener.
+
+
-    public void updateStateAndSendEventIgnore(long bytesUsed, MemoryState oldState, MemoryState newState, long mostRecentBytesUsed,
-        boolean deliverNextAbnormalEvent);
+
+    public void updateStateAndSendEventIgnore(long bytesUsed, MemoryState oldState,
+        MemoryState newState, long mostRecentBytesUsed, boolean deliverNextAbnormalEvent);
+
-  
+
-        throw new IllegalArgumentException(LocalizedStrings.MemoryThresholds_CRITICAL_PERCENTAGE_GT_ZERO_AND_LTE_100
-            .toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.MemoryThresholds_CRITICAL_PERCENTAGE_GT_ZERO_AND_LTE_100
+                .toLocalizedString());
-        throw new IllegalStateException(LocalizedStrings.OffHeapMemoryMonitor_NO_OFF_HEAP_MEMORY_HAS_BEEN_CONFIGURED
-            .toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.OffHeapMemoryMonitor_NO_OFF_HEAP_MEMORY_HAS_BEEN_CONFIGURED
+                .toLocalizedString());
-        throw new IllegalArgumentException(LocalizedStrings.MemoryThresholds_CRITICAL_PERCENTAGE_GTE_EVICTION_PERCENTAGE
-            .toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.MemoryThresholds_CRITICAL_PERCENTAGE_GTE_EVICTION_PERCENTAGE
+                .toLocalizedString());
-      this.thresholds = new MemoryThresholds(this.thresholds.getMaxMemoryBytes(), criticalThreshold, this.thresholds
-          .getEvictionThreshold());
+      this.thresholds = new MemoryThresholds(this.thresholds.getMaxMemoryBytes(), criticalThreshold,
+          this.thresholds.getEvictionThreshold());
-      if (this.thresholds.isEvictionThresholdEnabled() || this.thresholds.isCriticalThresholdEnabled()) {
+      if (this.thresholds.isEvictionThresholdEnabled()
+          || this.thresholds.isCriticalThresholdEnabled()) {
-      } else if (!this.thresholds.isEvictionThresholdEnabled() && !this.thresholds.isCriticalThresholdEnabled()) {
+      } else if (!this.thresholds.isEvictionThresholdEnabled()
+          && !this.thresholds.isCriticalThresholdEnabled()) {
-  
+
-  
+
-    
+
-        throw new IllegalArgumentException(LocalizedStrings.MemoryThresholds_EVICTION_PERCENTAGE_GT_ZERO_AND_LTE_100
-            .toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.MemoryThresholds_EVICTION_PERCENTAGE_GT_ZERO_AND_LTE_100
+                .toLocalizedString());
-        throw new IllegalStateException(LocalizedStrings.OffHeapMemoryMonitor_NO_OFF_HEAP_MEMORY_HAS_BEEN_CONFIGURED
-            .toLocalizedString());
+        throw new IllegalStateException(
+            LocalizedStrings.OffHeapMemoryMonitor_NO_OFF_HEAP_MEMORY_HAS_BEEN_CONFIGURED
+                .toLocalizedString());
-        throw new IllegalArgumentException(LocalizedStrings.MemoryMonitor_EVICTION_PERCENTAGE_LTE_CRITICAL_PERCENTAGE
-            .toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.MemoryMonitor_EVICTION_PERCENTAGE_LTE_CRITICAL_PERCENTAGE
+                .toLocalizedString());
-      this.thresholds = new MemoryThresholds(this.thresholds.getMaxMemoryBytes(), this.thresholds.getCriticalThreshold(),
-          evictionThreshold);
+      this.thresholds = new MemoryThresholds(this.thresholds.getMaxMemoryBytes(),
+          this.thresholds.getCriticalThreshold(), evictionThreshold);
-      if (this.thresholds.isEvictionThresholdEnabled() || this.thresholds.isCriticalThresholdEnabled()) {
+      if (this.thresholds.isEvictionThresholdEnabled()
+          || this.thresholds.isCriticalThresholdEnabled()) {
-      } else if (!this.thresholds.isEvictionThresholdEnabled() && !this.thresholds.isCriticalThresholdEnabled()) {
+      } else if (!this.thresholds.isEvictionThresholdEnabled()
+          && !this.thresholds.isCriticalThresholdEnabled()) {
-   * Compare the number of bytes used (fetched from the JVM) to the thresholds.
-   * If necessary, change the state and send an event for the state change.
+   * Compare the number of bytes used (fetched from the JVM) to the thresholds. If necessary, change
+   * the state and send an event for the state change.
+   * 
-   * Compare the number of bytes used to the thresholds. If necessary, change
-   * the state and send an event for the state change.
+   * Compare the number of bytes used to the thresholds. If necessary, change the state and send an
+   * event for the state change.
-   * @param bytesUsed
-   *          Number of bytes of off-heap memory currently used.
+   * @param bytesUsed Number of bytes of off-heap memory currently used.
-        
-        MemoryEvent event = new MemoryEvent(ResourceType.OFFHEAP_MEMORY, oldState, newState, this.cache.getMyId(), bytesUsed, true, thresholds);
+
+        MemoryEvent event = new MemoryEvent(ResourceType.OFFHEAP_MEMORY, oldState, newState,
+            this.cache.getMyId(), bytesUsed, true, thresholds);
-        
-      } else if (!oldState.isNormal()
-          && bytesUsed != mre.getBytesUsed()
+
+      } else if (!oldState.isNormal() && bytesUsed != mre.getBytesUsed()
-        MemoryEvent event = new MemoryEvent(ResourceType.OFFHEAP_MEMORY, oldState, newState, this.cache.getMyId(), bytesUsed, true, thresholds);
+        MemoryEvent event = new MemoryEvent(ResourceType.OFFHEAP_MEMORY, oldState, newState,
+            this.cache.getMyId(), bytesUsed, true, thresholds);
-          _testHook.updateStateAndSendEventIgnore(bytesUsed, oldState, newState, mre.getBytesUsed(), this.deliverNextAbnormalEvent);
+          _testHook.updateStateAndSendEventIgnore(bytesUsed, oldState, newState, mre.getBytesUsed(),
+              this.deliverNextAbnormalEvent);
-        
+
-  
+
-   * Return true if the given number of bytes compared to the
-   * current monitor state would generate a new memory event.
+   * Return true if the given number of bytes compared to the current monitor state would generate a
+   * new memory event.
-   * @param bytesUsed
-   *          Number of bytes of off-heap memory currently used.
+   * @param bytesUsed Number of bytes of off-heap memory currently used.
-    } else if (!oldState.isNormal()
-        && bytesUsed != mre.getBytesUsed()
+    } else if (!oldState.isNormal() && bytesUsed != mre.getBytesUsed()
-  
+
-   
+
-   * Used by the OffHeapMemoryUsageListener to tell us that
-   * the next abnormal event should be delivered even if the
-   * state does not change as long as the memory usage changed.
-   * For some reason, unknown to me, if we stay in an abnormal
-   * state for more than a second then we want to send another
-   * event to update the memory usage.
+   * Used by the OffHeapMemoryUsageListener to tell us that the next abnormal event should be
+   * delivered even if the state does not change as long as the memory usage changed. For some
+   * reason, unknown to me, if we stay in an abnormal state for more than a second then we want to
+   * send another event to update the memory usage.
-   * @param event
-   *          Event from which to derive data for updating stats.
+   * @param event Event from which to derive data for updating stats.
-   * @param profile
-   *          Profile to populate.
+   * @param profile Profile to populate.
-    profile.setOffHeapData(eventToPopulate.getBytesUsed(), eventToPopulate.getState(), eventToPopulate.getThresholds());
+    profile.setOffHeapData(eventToPopulate.getBytesUsed(), eventToPopulate.getState(),
+        eventToPopulate.getThresholds());
-    return new MemoryThresholds(saveThresholds.getMaxMemoryBytes(), saveThresholds.getCriticalThreshold(), saveThresholds
-        .getEvictionThreshold());
+    return new MemoryThresholds(saveThresholds.getMaxMemoryBytes(),
+        saveThresholds.getCriticalThreshold(), saveThresholds.getEvictionThreshold());
-   * Returns the number of bytes of memory reported by the memory allocator as
-   * currently in use.
+   * Returns the number of bytes of memory reported by the memory allocator as currently in use.
-   * Deliver a memory event from one of the monitors to both local listeners and
-   * remote resource managers. Also, if a critical event is received and a query
-   * monitor has been enabled, then the query monitor will be notified.
+   * Deliver a memory event from one of the monitors to both local listeners and remote resource
+   * managers. Also, if a critical event is received and a query monitor has been enabled, then the
+   * query monitor will be notified.
-   * @param event
-   *          Event to process.
+   * @param event Event to process.
-      logger.error(LocalizedMessage.create(LocalizedStrings.MemoryMonitor_MEMBER_ABOVE_CRITICAL_THRESHOLD,
-          new Object[] { event.getMember(), "off-heap" }));
+      logger.error(
+          LocalizedMessage.create(LocalizedStrings.MemoryMonitor_MEMBER_ABOVE_CRITICAL_THRESHOLD,
+              new Object[] {event.getMember(), "off-heap"}));
-      logger.error(LocalizedMessage.create(LocalizedStrings.MemoryMonitor_MEMBER_BELOW_CRITICAL_THRESHOLD,
-          new Object[] { event.getMember(), "off-heap" }));
+      logger.error(
+          LocalizedMessage.create(LocalizedStrings.MemoryMonitor_MEMBER_BELOW_CRITICAL_THRESHOLD,
+              new Object[] {event.getMember(), "off-heap"}));
-      logger.info(LocalizedMessage.create(LocalizedStrings.MemoryMonitor_MEMBER_ABOVE_HIGH_THRESHOLD,
-          new Object[] { event.getMember(), "off-heap" }));
+      logger
+          .info(LocalizedMessage.create(LocalizedStrings.MemoryMonitor_MEMBER_ABOVE_HIGH_THRESHOLD,
+              new Object[] {event.getMember(), "off-heap"}));
-      logger.info(LocalizedMessage.create(LocalizedStrings.MemoryMonitor_MEMBER_BELOW_HIGH_THRESHOLD,
-          new Object[] { event.getMember(),  "off-heap" }));
+      logger
+          .info(LocalizedMessage.create(LocalizedStrings.MemoryMonitor_MEMBER_BELOW_HIGH_THRESHOLD,
+              new Object[] {event.getMember(), "off-heap"}));
-    
+
-  
+
-        logger.error(LocalizedMessage.create(LocalizedStrings.MemoryMonitor_EXCEPTION_OCCURED_WHEN_NOTIFYING_LISTENERS), t);
+        logger.error(LocalizedMessage
+            .create(LocalizedStrings.MemoryMonitor_EXCEPTION_OCCURED_WHEN_NOTIFYING_LISTENERS), t);
-  
+
-    return "OffHeapMemoryMonitor [thresholds=" + this.thresholds + ", mostRecentEvent=" + this.mostRecentEvent + "]";
+    return "OffHeapMemoryMonitor [thresholds=" + this.thresholds + ", mostRecentEvent="
+        + this.mostRecentEvent + "]";
-  
+
-    
-    OffHeapMemoryUsageListener() {
-    }
-    
+
+    OffHeapMemoryUsageListener() {}
+
-    
+
-      final int MAX_CALLS_WITH_NO_EVENT = 1000/MS_TIMEOUT;
+      final int MAX_CALLS_WITH_NO_EVENT = 1000 / MS_TIMEOUT;
-            try {  
+            try {
-        
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66
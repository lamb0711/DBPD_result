GEODE-2787: When distribution happened, it calls startOperation() to increase a count, then call an endOperation() to decrease the count.

state flush will wait for this count to become 0.

But notifyGateway() is called after distribute(). So there's race that stateflush finished but notifyGateway has not done yet.

The fix is to move the endOperation() after callbacks.

-    if (!event.isOriginRemote() && !event.isNetSearch() && getBucketAdvisor().isPrimary()) {
-      if (event.isBulkOpInProgress()) {
-        // consolidate the UpdateOperation for each entry into a PutAllMessage
-        // since we did not call basicPutPart3(), so we have to explicitly addEntry here
-        event.getPutAllOperation().addEntry(event, this.getId());
-      } else {
-        new UpdateOperation(event, lastModified).distribute();
-        if (logger.isDebugEnabled()) {
-          logger.debug("sent update operation : for region  : {}: with event: {}", this.getName(),
-              event);
+    long token = -1;
+    UpdateOperation op = null;
+
+    try {
+      if (!event.isOriginRemote() && !event.isNetSearch() && getBucketAdvisor().isPrimary()) {
+        if (event.isBulkOpInProgress()) {
+          // consolidate the UpdateOperation for each entry into a PutAllMessage
+          // since we did not call basicPutPart3(), so we have to explicitly addEntry here
+          event.getPutAllOperation().addEntry(event, this.getId());
+        } else {
+          // before distribute: BR's put
+          op = new UpdateOperation(event, lastModified);
+          token = op.startOperation();
+          if (logger.isDebugEnabled()) {
+            logger.debug("sent update operation : for region  : {}: with event: {}", this.getName(),
+                event);
+          }
-    }
-    if (!event.getOperation().isPutAll()) { // putAll will invoke listeners later
-      event.invokeCallbacks(this, true, true);
+      if (!event.getOperation().isPutAll()) { // putAll will invoke listeners later
+        event.invokeCallbacks(this, true, true);
+      }
+    } finally {
+      if (op != null) {
+        op.endOperation(token);
+      }
-    // Update the get stats if necessary.
-    if (this.partitionedRegion.getDataStore().hasClientInterest(event)) {
-      updateStatsForGet(entry, true);
-    }
-    if (!event.isOriginRemote()) {
-      if (event.getVersionTag() == null || event.getVersionTag().isGatewayTag()) {
-        boolean eventHasDelta = event.getDeltaBytes() != null;
-        VersionTag v = entry.generateVersionTag(null, eventHasDelta, this, event);
-        if (v != null) {
-          if (logger.isDebugEnabled()) {
-            logger.debug("generated version tag {} in region {}", v, this.getName());
+
+    long token = -1;
+    UpdateOperation op = null;
+
+    try {
+      // Update the get stats if necessary.
+      if (this.partitionedRegion.getDataStore().hasClientInterest(event)) {
+        updateStatsForGet(entry, true);
+      }
+      if (!event.isOriginRemote()) {
+        if (event.getVersionTag() == null || event.getVersionTag().isGatewayTag()) {
+          boolean eventHasDelta = event.getDeltaBytes() != null;
+          VersionTag v = entry.generateVersionTag(null, eventHasDelta, this, event);
+          if (v != null) {
+            if (logger.isDebugEnabled()) {
+              logger.debug("generated version tag {} in region {}", v, this.getName());
+            }
+
+        // This code assumes it is safe ignore token mode (GII in progress)
+        // because it assumes when the origin of the event is local,
+        // the GII has completed and the region is initialized and open for local
+        // ops
+
+        if (!event.isBulkOpInProgress()) {
+          long start = this.partitionedRegion.getPrStats().startSendReplication();
+          try {
+            // before distribute: PR's put PR
+            op = new UpdateOperation(event, modifiedTime);
+            token = op.startOperation();
+          } finally {
+            this.partitionedRegion.getPrStats().endSendReplication(start);
+          }
+        } else {
+          // consolidate the UpdateOperation for each entry into a PutAllMessage
+          // basicPutPart3 takes care of this
+        }
-      // This code assumes it is safe ignore token mode (GII in progress)
-      // because it assumes when the origin of the event is local,
-      // the GII has completed and the region is initialized and open for local
-      // ops
-      if (!event.isBulkOpInProgress()) {
-        long start = this.partitionedRegion.getPrStats().startSendReplication();
-        try {
-          UpdateOperation op = new UpdateOperation(event, modifiedTime);
-          op.distribute();
-        } finally {
-          this.partitionedRegion.getPrStats().endSendReplication(start);
-        }
-      } else {
-        // consolidate the UpdateOperation for each entry into a PutAllMessage
-        // basicPutPart3 takes care of this
+      long lastModifiedTime =
+          super.basicPutPart2(event, entry, isInitialized, lastModified, clearConflict);
+      return lastModifiedTime;
+    } finally {
+      if (op != null) {
+        op.endOperation(token);
-
-    return super.basicPutPart2(event, entry, isInitialized, lastModified, clearConflict);
-    if (!event.isOriginRemote() && getBucketAdvisor().isPrimary()) {
-      // This cache has processed the event, forward operation
-      // and event messages to backup buckets
-      new InvalidateOperation(event).distribute();
+    InvalidateOperation op = null;
+    long token = -1;
+    try {
+      if (!event.isOriginRemote() && getBucketAdvisor().isPrimary()) {
+        // This cache has processed the event, forward operation
+        // and event messages to backup buckets
+        // before distribute: BR.invalidate hasSeenEvent
+        op = new InvalidateOperation(event);
+        token = op.startOperation();
+      }
+      event.invokeCallbacks(this, true, false);
+    } finally {
+      if (op != null) {
+        op.endOperation(token);
+      }
-    event.invokeCallbacks(this, true, false);
-    if (!event.isOriginRemote()) {
-      if (event.getVersionTag() == null || event.getVersionTag().isGatewayTag()) {
-        VersionTag v = re.generateVersionTag(null, false, this, event);
-        if (logger.isDebugEnabled() && v != null) {
-          logger.debug("generated version tag {} in region {}", v, this.getName());
+    long token = -1;
+    InvalidateOperation op = null;
+
+    try {
+      if (!event.isOriginRemote()) {
+        if (event.getVersionTag() == null || event.getVersionTag().isGatewayTag()) {
+          VersionTag v = re.generateVersionTag(null, false, this, event);
+          if (logger.isDebugEnabled() && v != null) {
+            logger.debug("generated version tag {} in region {}", v, this.getName());
+          }
+          event.setVersionTag(v);
-        event.setVersionTag(v);
+
+        // This code assumes it is safe ignore token mode (GII in progress)
+        // because it assumes when the origin of the event is local,
+        // the GII has completed and the region is initialized and open for local
+        // ops
+
+        // This code assumes that this bucket is primary
+        // distribute op to bucket secondaries and event to other listeners
+        // before distribute: BR's invalidate
+        op = new InvalidateOperation(event);
+        token = op.startOperation();
-
-      // This code assumes it is safe ignore token mode (GII in progress)
-      // because it assumes when the origin of the event is local,
-      // the GII has completed and the region is initialized and open for local
-      // ops
-
-      // This code assumes that this bucket is primary
-      // distribute op to bucket secondaries and event to other listeners
-      InvalidateOperation op = new InvalidateOperation(event);
-      op.distribute();
+      super.basicInvalidatePart2(re, event, clearConflict /* Clear conflict occurred */,
+          invokeCallbacks);
+    } finally {
+      if (op != null) {
+        op.endOperation(token);
+      }
-    super.basicInvalidatePart2(re, event, clearConflict /* Clear conflict occurred */,
-        invokeCallbacks);
-    if (logger.isTraceEnabled(LogMarker.DM)) {
-      logger.trace(LogMarker.DM, "BR.basicDestroy: this cache has already seen this event {}",
-          event);
-    }
-    if (!event.isOriginRemote() && getBucketAdvisor().isPrimary()) {
-      if (event.isBulkOpInProgress()) {
-        // consolidate the DestroyOperation for each entry into a RemoveAllMessage
-        event.getRemoveAllOperation().addEntry(event, this.getId());
-      } else {
-        // This cache has processed the event, forward operation
-        // and event messages to backup buckets
-        event.setOldValueFromRegion();
-        new DestroyOperation(event).distribute();
-      }
-    }
+    long token = -1;
+    DestroyOperation op = null;
-    if (!event.getOperation().isRemoveAll()) { // removeAll will invoke listeners later
-      event.invokeCallbacks(this, true, false);
+    try {
+      if (logger.isTraceEnabled(LogMarker.DM)) {
+        logger.trace(LogMarker.DM, "BR.basicDestroy: this cache has already seen this event {}",
+            event);
+      }
+      if (!event.isOriginRemote() && getBucketAdvisor().isPrimary()) {
+        if (event.isBulkOpInProgress()) {
+          // consolidate the DestroyOperation for each entry into a RemoveAllMessage
+          event.getRemoveAllOperation().addEntry(event, this.getId());
+        } else {
+          // This cache has processed the event, forward operation
+          // and event messages to backup buckets
+          // before distribute: BR's destroy, not to trigger callback here
+          event.setOldValueFromRegion();
+          op = new DestroyOperation(event);
+          token = op.startOperation();
+        }
+      }
+
+      if (!event.getOperation().isRemoveAll()) { // removeAll will invoke listeners later
+        event.invokeCallbacks(this, true, false);
+      }
+    } finally {
+      if (op != null) {
+        op.endOperation(token);
+      }
-    // Assumed this is called with entry synchrony
-    if (!event.isOriginRemote() && !event.isBulkOpInProgress() && !event.getOperation().isLocal()
-        && !Operation.EVICT_DESTROY.equals(event.getOperation())
-        && !(event.isExpiration() && isEntryEvictDestroyEnabled())) {
+    long token = -1;
+    DestroyOperation op = null;
+    try {
+      // Assumed this is called with entry synchrony
+      if (!event.isOriginRemote() && !event.isBulkOpInProgress() && !event.getOperation().isLocal()
+          && !Operation.EVICT_DESTROY.equals(event.getOperation())
+          && !(event.isExpiration() && isEntryEvictDestroyEnabled())) {
-      if (event.getVersionTag() == null || event.getVersionTag().isGatewayTag()) {
-        VersionTag v = entry.generateVersionTag(null, false, this, event);
-        if (logger.isDebugEnabled() && v != null) {
-          logger.debug("generated version tag {} in region {}", v, this.getName());
+        if (event.getVersionTag() == null || event.getVersionTag().isGatewayTag()) {
+          VersionTag v = entry.generateVersionTag(null, false, this, event);
+          if (logger.isDebugEnabled() && v != null) {
+            logger.debug("generated version tag {} in region {}", v, this.getName());
+          }
+
+        // This code assumes it is safe ignore token mode (GII in progress)
+        // because it assume when the origin of the event is local,
+        // then GII has completed (the region has been completely initialized)
+
+        // This code assumes that this bucket is primary
+        // before distribute: BR.destroy for retain
+        op = new DestroyOperation(event);
+        token = op.startOperation();
-
-      // This code assumes it is safe ignore token mode (GII in progress)
-      // because it assume when the origin of the event is local,
-      // then GII has completed (the region has been completely initialized)
-
-      // This code assumes that this bucket is primary
-      new DestroyOperation(event).distribute();
+      super.basicDestroyBeforeRemoval(entry, event);
+    } finally {
+      if (op != null) {
+        op.endOperation(token);
+      }
-    super.basicDestroyBeforeRemoval(entry, event);

INS8 INS8 INS8 INS8 INS8 INS8 INS60 INS60 INS54 MOV60 INS60 INS60 INS54 INS60 INS60 INS54 INS60 INS60 INS54 INS60 INS60 INS54 INS60 INS60 INS54 INS39 INS59 INS43 INS59 MOV8 INS8 INS39 INS59 MOV43 INS59 MOV8 INS8 MOV43 INS59 INS39 INS59 MOV8 INS8 INS39 INS59 INS43 INS59 MOV8 INS8 INS39 INS59 INS43 INS59 MOV8 INS8 INS39 INS59 INS43 INS59 MOV8 INS8 INS42 INS38 INS42 INS42 INS33 INS25 INS42 INS38 INS42 INS33 INS60 INS25 INS42 INS33 INS42 INS38 INS25 INS42 INS38 INS42 INS42 INS33 INS25 INS42 INS38 INS42 INS42 INS33 INS25 INS42 INS38 INS42 INS42 INS33 INS25 INS34 INS27 INS8 INS34 INS39 INS59 INS42 INS27 INS8 INS34 INS27 INS8 INS34 INS27 INS8 INS34 INS27 INS8 INS34 INS27 INS8 INS42 INS33 INS21 INS42 MOV48 INS42 INS33 INS21 INS21 INS21 INS42 INS33 INS21 MOV21 INS21 INS42 INS33 INS21 INS42 INS33 INS21 MOV21 INS42 INS33 INS21 INS32 INS32 INS7 INS7 INS32 INS7 INS7 INS32 INS32 INS7 INS7 INS32 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV14 INS42 INS32 INS42 INS42 INS42 INS42 MOV14 INS42 INS32 INS42 INS42 INS42 INS21 INS21 INS42 INS42 INS42 INS42 MOV14 INS42 INS32 INS42 INS42 INS42 INS7 INS7 INS42 INS42 MOV42 UPD42 MOV42 INS7 INS7 INS42 UPD42 MOV42 INS42 MOV14 INS42 INS32 INS21 INS42 MOV14 INS42 INS32 INS42 INS42 INS7 INS7 INS42 INS42 INS42 MOV14 INS42 INS32 MOV42 UPD42 MOV42 DEL42 DEL32 DEL42 DEL59 DEL60 DEL32 DEL42 DEL32 DEL42 DEL59 DEL60 DEL32 DEL21 DEL42 DEL32 DEL32
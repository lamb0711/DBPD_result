Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-
+import org.apache.geode.test.junit.categories.FlakyTest;
+import org.junit.experimental.categories.Category;
- * Base class for tests of FunctionService that are agnostic to the
- * type of Execution that they are running on. The goal is to completely
- * cover all common behavior of sending results and sending exceptions
- * here and have them run with all topologies in child classes.
+ * Base class for tests of FunctionService that are agnostic to the type of Execution that they are
+ * running on. The goal is to completely cover all common behavior of sending results and sending
+ * exceptions here and have them run with all topologies in child classes.
-   * Return the execution used to execute functions for this
-   * test. Subclasses should override this to provide a specific
-   * execution, for example onMember.
+   * Return the execution used to execute functions for this test. Subclasses should override this
+   * to provide a specific execution, for example onMember.
-   * Return the number of members the function is expected
-   * to execute on
+   * Return the number of members the function is expected to execute on
-    ResultCollector rc = getExecution().execute((context) -> {context.getResultSender().lastResult("done");});
+    ResultCollector rc = getExecution().execute((context) -> {
+      context.getResultSender().lastResult("done");
+    });
-    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    // GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
-    //GEODE-1762 - clients wrap cause in a ServerOperationException
-//    thrown.expectCause(isA(IllegalStateException.class));
-    ResultCollector rc = getExecution().execute((context) -> {throw new IllegalStateException();});
+    // GEODE-1762 - clients wrap cause in a ServerOperationException
+    // thrown.expectCause(isA(IllegalStateException.class));
+    ResultCollector rc = getExecution().execute((context) -> {
+      throw new IllegalStateException();
+    });
-    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    // GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
-    ResultCollector rc = getExecution().execute((context) -> {throw new FunctionException();});
+    ResultCollector rc = getExecution().execute((context) -> {
+      throw new FunctionException();
+    });
-   * Tests what happens if a function returns an exception as a result. This
-   * is kind a weird, but it seems that the default collector will just throw it
-   * as an exception
+   * Tests what happens if a function returns an exception as a result. This is kind a weird, but it
+   * seems that the default collector will just throw it as an exception
-    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
-    //GEODE-1762 - clients throw a ServerOperationException
+    // GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    // GEODE-1762 - clients throw a ServerOperationException
-//    thrown.expect(FunctionException.class);
-//    thrown.expectCause(isA(IllegalStateException.class));
-    ResultCollector rc = getExecution().execute((context) -> {context.getResultSender().lastResult(new IllegalStateException());});
+    // thrown.expect(FunctionException.class);
+    // thrown.expectCause(isA(IllegalStateException.class));
+    ResultCollector rc = getExecution().execute((context) -> {
+      context.getResultSender().lastResult(new IllegalStateException());
+    });
-    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    // GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
-    ResultCollector rc = getExecution().execute((context) -> {context.getResultSender().lastResult(new FunctionException());});
+    ResultCollector rc = getExecution().execute((context) -> {
+      context.getResultSender().lastResult(new FunctionException());
+    });
-    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
-    //GEODE-1762 - client throws a ServerOperationException
+    // GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    // GEODE-1762 - client throws a ServerOperationException
-//    thrown.expect(FunctionException.class);
-//    thrown.expectCause(isA(IllegalStateException.class));
+    // thrown.expect(FunctionException.class);
+    // thrown.expectCause(isA(IllegalStateException.class));
-        context.getResultSender().sendResult(new IllegalStateException());
-        context.getResultSender().lastResult("done");
-      });
+      context.getResultSender().sendResult(new IllegalStateException());
+      context.getResultSender().lastResult("done");
+    });
-    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    // GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
-        context.getResultSender().sendResult(new FunctionException());
-        context.getResultSender().lastResult("done");
+      context.getResultSender().sendResult(new FunctionException());
+      context.getResultSender().lastResult("done");
-    result.stream().forEach(element -> assertEquals(IllegalStateException.class, element.getClass()));
+    result.stream()
+        .forEach(element -> assertEquals(IllegalStateException.class, element.getClass()));
-    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    // GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
-      ResultCollector rc = getExecution().withCollector(customCollector).execute((context) -> {throw new IllegalStateException();});
+      ResultCollector rc = getExecution().withCollector(customCollector).execute((context) -> {
+        throw new IllegalStateException();
+      });
-    } catch (FunctionException expected) {}
+    } catch (FunctionException expected) {
+    }
-    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    // GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
-      ResultCollector rc = getExecution().withCollector(customCollector).execute((context) -> {throw new FunctionException();});
+      ResultCollector rc = getExecution().withCollector(customCollector).execute((context) -> {
+        throw new FunctionException();
+      });
-    } catch (FunctionException expected) {}
+    } catch (FunctionException expected) {
+    }
-    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    // GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
-      ResultCollector rc = getExecution().execute((context) -> {context.getResultSender().lastResult(new IllegalStateException());});
+      ResultCollector rc = getExecution().execute((context) -> {
+        context.getResultSender().lastResult(new IllegalStateException());
+      });
-      //GEODE-1762 - clients throw a ServerOperationException
-    } catch (Exception expected) {}
+      // GEODE-1762 - clients throw a ServerOperationException
+    } catch (Exception expected) {
+    }
-    //GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
+    // GEODE-1762 - clients throw from execute, but peers throw from rc.getResult
-      //GEODE-1762 - clients throw a ServerOperationException
-    } catch (Exception expected) {}
+      // GEODE-1762 - clients throw a ServerOperationException
+    } catch (Exception expected) {
+    }
+  @Category(FlakyTest.class) // GEODE-1981
-    result.stream().forEach(element -> assertEquals(IllegalStateException.class, element.getClass()));
+    result.stream()
+        .forEach(element -> assertEquals(IllegalStateException.class, element.getClass()));
+  @Category(FlakyTest.class) // GEODE-1827
-   * Test that a custom result collector will still receive all partial
-   * results from other members when one member fails
+   * Test that a custom result collector will still receive all partial results from other members
+   * when one member fails
-    //Execute a function which will close the cache on one member.
+    // Execute a function which will close the cache on one member.
-      ResultCollector rc = getExecution()
-        .withCollector(customCollector)
-        .execute(new CacheClosingNonHAFunction(firstMember));
+      ResultCollector rc = getExecution().withCollector(customCollector)
+          .execute(new CacheClosingNonHAFunction(firstMember));
-    } catch(Exception expected) {
-      //do nothing
+    } catch (Exception expected) {
+      // do nothing
-    //Get a list of all of the members
+    // Get a list of all of the members
-      functionContext.getResultSender().lastResult(InternalDistributedSystem.getAnyInstance().getDistributedMember());
+      functionContext.getResultSender()
+          .lastResult(InternalDistributedSystem.getAnyInstance().getDistributedMember());
-      throws FunctionException, InterruptedException
-    {
+        throws FunctionException, InterruptedException {
-    public void endResults() {
-    }
+    public void endResults() {}
-   * A function which will close the cache if the given member matches
-   * the member executing this function
+   * A function which will close the cache if the given member matches the member executing this
+   * function
-      final InternalDistributedMember myId = InternalDistributedSystem.getAnyInstance().getDistributedMember();
+      final InternalDistributedMember myId =
+          InternalDistributedSystem.getAnyInstance().getDistributedMember();

INS26 INS26 INS40 INS40 INS79 INS79 INS42 INS57 INS42 INS57 UPD66 UPD66 UPD66 UPD66 UPD66 INS43 INS43 UPD66 UPD66 UPD66 UPD66 INS42 INS42 DEL66 DEL66 DEL66
Merge branch 'develop' into feature/GEODE-584

+
+/*           
+ * insertionIndex(), index(), trimToSize() are based on code provided by fastutil
+ * They are based from add(), contains() and other methods from ObjectOpenHashSet
+ * We have used the traversing mechanism and the HashCommon.mix()
+ * Copyright (C) 2002-2014 Sebastiano Vigna 
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License. 
+ */
+import static it.unimi.dsi.fastutil.HashCommon.arraySize;
+import it.unimi.dsi.fastutil.HashCommon;
-import java.util.concurrent.ConcurrentMap;
-import com.gemstone.gemfire.cache.query.internal.AttributeDescriptor;
+import com.gemstone.gemfire.cache.query.internal.parse.OQLLexerTokenTypes;
-import com.gemstone.gemfire.internal.util.ObjectProcedure;
-import com.gemstone.gemfire.internal.util.PrimeFinder;
+import com.gemstone.gemfire.pdx.internal.PdxString;
- * An implementation of the <tt>Set</tt> interface that uses an open-addressed
- * hash table to store its contents.
- * 
- * On collisions, will store contents in an IndexElemArray and once a threshold
- * has been hit, will store in ConcurrentHashSets.
+ * An implementation of the <tt>Set</tt> interface for the HashIndex
+ * Not exactly a set as the hash keys can actually collide but will
+ * continue to look for an empty location to store the value
+ *
-
-  /** the current number of occupied slots in the hash. */
+  /** the current number of entries in the set */
-  
-  /** the current number of free slots in the hash. */
+
+  /** the current number of open slots in the hash.
+   * Originally used when we collapsed collided keys into collections
+   * Not really used now */
-  
-  /** the current number of occupied slots in the hash. */
-  protected transient int _removedTokens;
+
+  /** number of removed tokens in the set, these are index positions that may be reused*/
+  transient int _removedTokens;
-  /**
-   * the default initial capacity for the hash table. This is one less than a
-   * prime value because one is added to it when searching for a prime capacity
-   * to account for the free slot required by open addressing. Thus, the real
-   * default capacity is 11.
-   */
-  protected static final int DEFAULT_INITIAL_CAPACITY = 100;
+  protected static final int DEFAULT_INITIAL_CAPACITY = 128;
-  /**
-   * Determines how full the internal table can become before rehashing is
-   * required. This must be a value in the range: 0.0 < loadFactor < 1.0. The
-   * default value is 0.5, which is about as large as you can get in open
-   * addressing without hurting performance. Cf. Knuth, Volume 3., Chapter 6.
-   */
+  
+  /** size of the backing table (-1)**/
+  protected int n;
+  
+  /** used for hashing into the table**/
+  protected int _mask;
-   * The maximum number of elements allowed without allocating more space.
+   * The maximum number of elements before rehashing
-  protected static final int CONDITIONAL_COMPACT_FACTOR = 2;
-  
-  //If after an update, the number of removed tokens X percent of the max size,
-  //we will compact and rehash to remove the tokens.
+  /** If after an update, the number of removed tokens X percent of the max size,
+    * we will compact and rehash to remove the tokens.
+    */
-  /** the strategy used to hash objects in this collection. */
-  protected HashIndexStrategy _hashingStrategy;
+  protected HashIndex.IMQEvaluator _imqEvaluator;
+ /**
+  * The removed token
+  */
-  
+
-   * Map for RegionEntries=>value of indexedExpression (reverse map)
+   * This is used when inplace modification is off to detect old key
-  private ConcurrentMap<Object, Object> entryToValuesMap;
-  protected ThreadLocal<Object2ObjectOpenHashMap> entryToOldKeysMap;
-  protected InternalIndexStatistics internalIndexStats;
-  
-  private AttributeDescriptor attDesc;
-  /**
-   * Creates a new <code>HashIndexSet</code> instance with the default capacity
-   * and load factor.
-   */
-  }
-  public HashIndexSet(ConcurrentMap reverseMap, ThreadLocal<Object2ObjectOpenHashMap> entryToOldKeysMap, InternalIndexStatistics internalIndexStats) {
-    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
-    this.entryToValuesMap = reverseMap;
-    this.entryToOldKeysMap = entryToOldKeysMap;
-    this.internalIndexStats = internalIndexStats;
-  }
-  
-  /**
-   * Creates a new <code>HashIndexSet</code> instance with the default capacity
-   * and load factor.
-   * 
-   * @param strategy used to compute hash codes and to compare objects.
-   */
-  public HashIndexSet(HashIndexStrategy strategy) {
-    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
-    this._hashingStrategy = strategy;
-  }
-
-  /**
-   * Creates a new <code>HashIndexSet</code> instance with a prime capacity
-   * equal to or greater than <tt>initialCapacity</tt> and with the default load
-   * factor.
-   * 
-   * @param initialCapacity
-   *          an <code>int</code> value
-   */
-  public HashIndexSet(int initialCapacity) {
-    this(initialCapacity, DEFAULT_LOAD_FACTOR);
-  }
-
-  /**
-   * Creates a new <code>HashIndexSet</code> instance with a prime capacity
-   * equal to or greater than <tt>initialCapacity</tt> and with the default load
-   * factor.
-   * 
-   * @param initialCapacity an <code>int</code> value
-   * @param strategy used to compute hash codes and to compare objects.
-   */
-  public HashIndexSet(int initialCapacity, HashIndexStrategy strategy) {
-    this(initialCapacity, DEFAULT_LOAD_FACTOR);
-    this._hashingStrategy = strategy;
-  public HashIndexSet(int initialCapacity, float loadFactor) {
-    _loadFactor = loadFactor;
-    setUp((int) Math.ceil(initialCapacity / loadFactor));
+  private HashIndexSet(int initialCapacity, float loadFactor) {
+    setUp(initialCapacity , loadFactor);
-  /**
-   * Creates a new <code>HashIndexSet</code> instance with a prime capacity
-   * equal to or greater than <tt>initialCapacity</tt> and with the specified
-   * load factor.
-   * 
-   * @param initialCapacity
-   *          an <code>int</code> value
-   * @param loadFactor
-   *          a <code>float</code> value
-   * @param strategy
-   *          used to compute hash codes and to compare objects.
-   */
-  public HashIndexSet(int initialCapacity, float loadFactor,
-      HashIndexStrategy strategy) {
-    this(initialCapacity, loadFactor);
-    this._hashingStrategy = strategy;
-  }
-
-  /**
-   * Creates a new <code>HashIndexSet</code> instance containing the elements of
-   * <tt>collection</tt>.
-   * 
-   * @param collection
-   *          a <code>Collection</code> value
-   */
-  public HashIndexSet(Collection collection) {
-    this(collection.size());
-    addAll(collection);
-  }
-
-  /**
-   * Creates a new <code>HashIndexSet</code> instance containing the elements of
-   * <tt>collection</tt>.
-   * 
-   * @param collection
-   *          a <code>Collection</code> value
-   * @param strategy
-   *          used to compute hash codes and to compare objects.
-   */
-  public HashIndexSet(Collection collection, HashIndexStrategy strategy) {
-    this(collection.size(), strategy);
-    addAll(collection);
-  }
-
-  public void setHashIndexStrategy(HashIndexStrategy hashingStrategy) {
-    this._hashingStrategy = hashingStrategy;
+  public void setEvaluator(HashIndex.IMQEvaluator evaluator) {
+    this._imqEvaluator = evaluator;
-  
+
-   * @param object can be either a region entry or index key
-   * @param recomputeKey
-              whether the object is a region entry and needs to have the key recomputed
+   * @param object is the index key
-  
-  private int computeHash(Object object, boolean recomputeKey) {
-    return _hashingStrategy.computeHashCode(object, recomputeKey) & 0x7fffffff;
+
+  private int computeHash(Object object) {
+    return object.hashCode();
-   * @param obj an <code>Object</code> value, expected to be a
+   * @param obj an <code>Object</code> value, expected to be the value object
-    return index(_hashingStrategy.computeKey(obj), obj);
+    return index(_imqEvaluator.evaluateKey(obj), obj);
-  
+
-  
+
+   * 
-    int hash, probe, index, length;
+    int hash;
+    int pos;
-    Object cur;
-
+    int mask = _mask;
-    length = set.length;
-    hash = computeHash(key, false);
-    index = hash % length;
-    cur = set[index];
-    
-    long start = -1L;
-    if (this.cacheStats != null) {
-      start = this.cacheStats.getStatTime();
-    }
-    //Find the correct collection that matches key of the object we are looking for
-    //if one exists, we then look to see if the element exists in the collection
-    //If a collection is not correct, we probe for the next collection until a null is found
-    while (cur != null) {
-      if (cur != REMOVED && index != ignoreThisSlot) {
-        if (cur instanceof RegionEntry) {
-          if (_hashingStrategy.equalsOnAdd(obj, cur)) {
-            return index;
-          }
-        }
-      }
+    Object curr;
+    hash = computeHash(key);
-      probe = 1 + (hash % (length - 2));
-      index -= probe;
-      if (index < 0) {
-        index += length;
+    /* Code originated from fastutils
+     * Copyright (C) 2002-2014 Sebastiano Vigna
+     * 
+     * Licensed under the Apache License, Version 2.0 (the "License");
+     * you may not use this file except in compliance with the License.
+     * You may obtain a copy of the License at
+     * 
+     * http://www.apache.org/licenses/LICENSE-2.0 
+     */
+    if (!((curr = set[pos = (it.unimi.dsi.fastutil.HashCommon.mix(hash)) & mask]) == null || curr == REMOVED)) {
+      if (((curr).equals(obj) && pos != ignoreThisSlot))
+        return pos;
+      while (!((curr = set[pos = (pos + 1) & mask]) == null || curr == REMOVED)) {
+        if (((curr).equals(obj)) && pos != ignoreThisSlot)
+          return pos;
-      cur = set[index];
-  
+
-  
+
-   * @return the a collection of objects that match the index key or an empty
-   *         collection if none match
+   * @return Iterator over a collection of objects that match the key
-   * @param set the array that all elements are stored in
+   * @param set represents the array that all elements are stored in
-      throwObjectContractViolation(set[(-index - 1)], newObject);
+      throw new ArrayIndexOutOfBoundsException("Cannot add:" + newObject + " into array position:" + index);
-    } else if (oldObject instanceof RegionEntry) {
-      IndexElemArray elemArray = new IndexElemArray();
-      elemArray.add(oldObject);
-      elemArray.add(newObject);
-      set[index] = elemArray;
-    } else if (oldObject instanceof IndexConcurrentHashSet) {
-      added = ((IndexConcurrentHashSet) oldObject).add(newObject);
-    } else if (oldObject instanceof IndexElemArray) {
-      IndexElemArray elemArray = (IndexElemArray) oldObject;
-      if (elemArray.size() >= IndexManager.INDEX_ELEMARRAY_THRESHOLD) {
-        IndexConcurrentHashSet newSet = new IndexConcurrentHashSet(
-            IndexManager.INDEX_ELEMARRAY_THRESHOLD + 20, 0.75f, 1);
-        newSet.addAll(elemArray);
-        newSet.add(newObject);
-        set[index] = newSet;
-      } else {
-        elemArray.add(newObject);
-      }
-    }
+    } 
-   * Inserts a value into the set.
-   * 
-   * @param obj an <code>Object</code> value
-   * @return true if the set was modified by the add operation
+   * Unsupported, we do not use HashIndexSet as a general all purpose set
-  public synchronized boolean add(Object obj){
-    throw new UnsupportedOperationException(
-        "add(Object) not supported, try add(Object key, Object obj) instead");
+  public synchronized boolean add(Object obj) {
+    throw new UnsupportedOperationException("add(Object) not supported, try add(Object key, Object obj) instead");
-  public synchronized boolean add(Object indexKey, Object obj) throws TypeMismatchException {   
-    // Before adding the entry with new value, remove it from reverse map and
-    // using the oldValue remove entry from the forward map.
-    // Reverse-map is used based on the system property
-    Object oldKey = null;
-    if (IndexManager.isObjectModificationInplace() && this.entryToValuesMap.containsKey(obj)){
-        oldKey = this.entryToValuesMap.get(obj);
+  /**
+   * Add an object using the hash value of the provided indexKey
+   * 
+   * @param indexKey 
+   * @param obj the object to add
+   * @return true if object has been added
+   * @throws TypeMismatchException
+   */
+  public synchronized int add(Object indexKey, Object obj) throws TypeMismatchException {
+    if (indexKey == null) {
+      indexKey = IndexManager.NULL;
-    else if (!IndexManager.isObjectModificationInplace() && this.entryToOldKeysMap != null) {
-      Map oldKeyMap = this.entryToOldKeysMap.get();
-      if (oldKeyMap != null) {
-        oldKey = TypeUtils.indexKeyFor(oldKeyMap.get(obj));        
-      }
-    }
-    // Note we cannot make the optimization for hash index.  Due to in place modification
+    // Note we cannot make the below optimization for hash index. Due to in place modification
-    
-    //grow/shrink capacity if needed
+
+    // grow/shrink capacity if needed
-    if (indexSlot < 0) {
-      return false; // already present in set, nothing to add
-    }
-    boolean added = addObjectToSet(_set, indexSlot, obj);
-    
-    if (added) {
-      //Update the reverse map
-      if ( IndexManager.isObjectModificationInplace()) {
-        this.entryToValuesMap.put(obj, indexKey);
-      }
-      if (indexKey != null && oldKey != null) {
-        remove(oldKey, obj, false, indexSlot);
-      }
-      // Update Stats after real addition
-      internalIndexStats.incNumValues(1);
-    }
-    
+    addObjectToSet(_set, indexSlot, obj);
+
-    }
-    else {
+    } else {
-    return added; // yes, we added something
+    return indexSlot; // yes, we added something
-   * Locates the index at which <tt>obj</tt> can be inserted. if there is
-   * already a value equal()ing <tt>obj</tt> in the set, returns that value's
-   * index as <tt>-index - 1</tt>.
+   * Locates the next available insertion index for the provided indexKey and set
-   * @return the index of a FREE slot at which obj can be inserted or, if obj is
-   *         already stored in the hash, the negative value of that index, minus
-   *         1: -index -1.
-   */
-  protected int insertionIndex(Object obj) {
-    return insertionIndex(_hashingStrategy.computeKey(obj), obj, _set);
-  }
-  
-  protected int insertionIndex(Object obj, Object[] set) {
-    return insertionIndex(_hashingStrategy.computeKey(obj), obj, set);
-  }
-  
-  
-  /**
-   * Locates the index at which <tt>obj</tt> can be inserted. if there is
-   * already a value equal()ing <tt>obj</tt> in the set, returns that value's
-   * index as <tt>-index - 1</tt>.
-   * 
-   * @param obj
-   *          an <code>Object</code> value
-   * @return the index of a FREE slot at which obj can be inserted or, if obj is
-   *         already stored in the hash, the negative value of that index, minus
-   *         1: -index -1.
+   * @return the index of an open or resused position
-    int hash, probe, indexSlot, length;
-    Object cur;
+    int hash;
+    int pos;
+    int mask = _mask;
+    Object curr;
+    final Object[] array = set;
+    hash = computeHash(indexKey);
-    length = set.length;
-    hash = computeHash(indexKey, false);
-    indexSlot = hash % length;
-
-    cur = set[indexSlot];
-
-    if (cur == null) {
-      return indexSlot; // empty, all done
-    }
-
-    // Getting here means we have yet to find the correct key collection
-    // so we must find the double hash
-
-      // compute the double hash
-      probe = 1 + (hash % (length - 2));
-      // if the slot we landed on is FULL (but not removed), probe
-      // until we find an empty slot, a REMOVED slot, or an element
-      // equal to the one we are trying to insert.
-      // finding an empty slot means that the value is not present
-      // and that we should use that slot as the insertion point;
-      // finding a REMOVED slot means that we need to keep searching,
-      // however we want to remember the offset of that REMOVED slot
-      // so we can reuse it in case a "new" insertion (i.e. not an update)
-      // is possible.
-      // finding a matching value means that we've found that our desired
-      // key is already in the table
-      if (cur != REMOVED) {
-        // starting at the natural offset, probe until we find an
-        // offset that isn't full.
-        do {
-
-          indexSlot -= probe;
-          if (indexSlot < 0) {
-            indexSlot += length;
-          }
-          cur = set[indexSlot];
-        } while (cur != null && cur != REMOVED);
+      /* Code originated from fastutils
+       * Copyright (C) 2002-2014 Sebastiano Vigna
+       * 
+       * Licensed under the Apache License, Version 2.0 (the "License");
+       * you may not use this file except in compliance with the License.
+       * You may obtain a copy of the License at
+       * 
+       * http://www.apache.org/licenses/LICENSE-2.0 
+       */
+      if (!((curr = array[pos = (it.unimi.dsi.fastutil.HashCommon.mix(hash)) & mask]) == null || curr == REMOVED)) {
+        while (!((curr = array[pos = (pos + 1) & mask]) == null || curr == REMOVED)) {
+        }
-      return indexSlot;
+      return pos;
-
+  
-  // GemStoneAddition
-    if (!(other instanceof Set)) {
+    if (!(other instanceof HashIndexSet)) {
-  // GemStoneAddition
-    HashProcedure p = new HashProcedure();
-    forEach(p);
-    return p.getHashCode();
-  }
-
-  /**
-   * Executes <tt>procedure</tt> for each element in the set.
-   * 
-   * @param procedure
-   *          a <code>TObjectProcedure</code> value
-   * @return false if the loop over the set terminated because the procedure
-   *         returned false for some value.
-   */
-  public boolean forEach(ObjectProcedure procedure) {
+    int hash = 0;
-      if (set[i] != null && set[i] != REMOVED && !procedure.executeWith(set[i])) {
-        return false;
+      if (set[i] != null && set[i] != REMOVED) {
+        hash += set[i].hashCode();
-    return true;
-  }
-
-  protected/* GemStoneAddition */final class HashProcedure implements
-      ObjectProcedure {
-    private int h = 0;
-
-    public int getHashCode() {
-      return h;
-    }
-
-    public final boolean executeWith(Object key) {
-      h += _hashingStrategy.computeHashCode(key);
-      return true;
-    }
+    return hash;
-   * Expands the set to accomodate new values.
+   * Expands or contracts a set to the new specified n.
-   * @param newCapacity
-   *          an <code>int</code> value
+   * @param newN the expected size
-  // GemStoneAddition
-  protected void rehash(int newCapacity) {
+  protected void rehash(int newN) {
-        Thread.yield();
+      Thread.yield();
-    
-    Object[] newSet = new Object[newCapacity];
+
-    //adds/removes/rehash should all be synchronized by the hashindex
-    //we are ok to clear this map and repopulate
-    //we do not do this for _set because we could still be querying 
-    //but the reversemap is only used for adds/removes/rehash
-    if (IndexManager.isObjectModificationInplace()) {
-      entryToValuesMap.clear();
-    }
+    
+    n = newN;
+    _mask = n - 1;
+    _maxSize = computeMaxSize(n, _loadFactor);
+    _free = computeNumFree();
+    Object[] newSet = new Object[n + 1];
+    
-        if (o instanceof RegionEntry) {
-          Object key = _hashingStrategy.computeKey(o);
-          if (key == null) {
-            key = IndexManager.NULL;
-          }
-          int index = insertionIndex(key, o, newSet);
-          if (index >= 0)
-            if (addObjectToSet(newSet, index, o)) {
-              updateReverseMap(o, key);
-            }
-        } 
+        Object key = _imqEvaluator.evaluateKey(o);
+        if (key == null) {
+          key = IndexManager.NULL;
+        }
+        int index = insertionIndex(key, o, newSet);
+        if (index >= 0) {
+          addObjectToSet(newSet, index, o);
+        }
-  
-  private void updateReverseMap(Object regionEntry, Object key) {
-    if (IndexManager.isObjectModificationInplace()) {
-      entryToValuesMap.put(regionEntry, key);
-    }
-  }
+
-   * Convenience methods for subclasses to use in throwing exceptions about
-   * badly behaved user objects employed as keys. We have to throw an
-   * IllegalArgumentException with a rather verbose message telling the user
-   * that they need to fix their object implementation to conform to the general
-   * contract for java.lang.Object.
-   * 
-   * @param o1
-   *          the first of the equal elements with unequal hash codes.
-   * @param o2
-   *          the second of the equal elements with unequal hash codes.
-   * @exception IllegalArgumentException
-   *              the whole point of this method.
-   */
-  protected final void throwObjectContractViolation(Object o1, Object o2)
-      throws IllegalArgumentException {
-    throw new IllegalArgumentException(
-        "Equal objects must have equal hashcodes. "
-            + "During rehashing, Trove discovered that "
-            + "the following two objects claim to be "
-            + "equal (as in java.lang.Object.equals()) "
-            + "but their hashCodes (or those calculated by "
-            + "your HashIndexStrategy) are not equal."
-            + "This violates the general contract of "
-            + "java.lang.Object.hashCode().  See bullet point two "
-            + "in that method's documentation. " + "object #1 ="
-            + objToString(o1) + "; object #2 =" + objToString(o2));
-  }
-
-  private static String objToString(Object o) {
-    if (o instanceof Object[]) {
-      return java.util.Arrays.toString((Object[]) o);
-    } else {
-      return String.valueOf(o);
-    }
-  }
-
-  /**
-   * Returns a new array containing the objects in the set.
+   * Unsupported as the hash index does not use this method call
-    throw new UnsupportedOperationException(
-        "toArray not yet supported");
+    throw new UnsupportedOperationException("toArray not yet supported");
-   * Returns a typed array of the objects in the set.
-   * 
+   * Unsupported as the hash index does not use this method call
-    throw new UnsupportedOperationException(
-        "toArray(Object[] a) not yet supported");
+    throw new UnsupportedOperationException("toArray(Object[] a) not yet supported");
-  // GemStoneAddition
-    if (IndexManager.isObjectModificationInplace()) {
-      entryToValuesMap.clear();
-    }
+
-  /**
-   * Removes <tt>obj</tt> from the set.  
-   * Currently not implemented correctly, use {@link HashIndexSet#remove(Object, Object, boolean)}
-   * 
-   * @param obj an <code>Object</code> value
-   * @return true if the set was modified by the remove operation.
-   */
-  public boolean remove(Object obj) {
-    throw new UnsupportedOperationException(
-        "remove(Object) not supported, try remove(Object key, Object obj) instead");
+  public boolean remove(Object obj) {
+    return remove(_imqEvaluator.evaluateKey(obj), obj);
-  
-  
-  public synchronized boolean remove(Object key, Object obj, boolean updateReverseMap) {
-    return remove(key, obj, updateReverseMap, -1);
+
+  public synchronized boolean remove(Object key, Object obj) {
+    return remove(key, obj, -1);
-  
+
-   * @param updateReverseMap
-   *  we end up scanning the entire index.  We want to remove the region entry from the index slot
-   *  but not the newly added (correct) slot.  Rather only the "old/wrong" slot
+   *          we end up scanning the entire index. We want to remove the region entry from the index slot
+   *          but not the newly added (correct) slot. Rather only the "old/wrong" slot
-  public synchronized boolean remove(Object key, Object obj, boolean updateReverseMap, int newIndexSlot) {
+  public synchronized boolean remove(Object key, Object obj, int newIndexSlot) {
-    //The check for newIndexSlot != indexSlot is incase of in place modification.
-    //When inplace occurs, oldkey == newkey and we end up wiping out the "new key" slow rather
-    //than the old key slot.  Instead let's get to the else portion
+    // The check for newIndexSlot != indexSlot is incase of in place modification.
+    // When inplace occurs, oldkey == newkey and we end up wiping out the "new key" slow rather
+    // than the old key slot. Instead let's get to the else portion
-      if (removed) {
-        if (updateReverseMap && IndexManager.isObjectModificationInplace()) {
-          entryToValuesMap.remove(obj);
-        }
-        internalIndexStats.incNumValues(-1);
-      }
-    }
-    else if (!IndexManager.isObjectModificationInplace()){
-      //object could not be found so it's possible there was an inplace modification
-        HashIndexSetIterator iterator = (HashIndexSetIterator)getAll();
-        while (iterator.hasNext()) {
-          Object indexedObject = iterator.next();
-          if (_hashingStrategy.equalsOnAdd(indexedObject, obj) && iterator.currentObjectIndex() != newIndexSlot) {
-            iterator.remove();
-            internalIndexStats.incNumValues(-1);
-            return true;
-          }
+    } else if (!IndexManager.isObjectModificationInplace()) {
+      // object could not be found so it's possible there was an inplace modification
+      HashIndexSetIterator iterator = (HashIndexSetIterator) getAll();
+      while (iterator.hasNext()) {
+        Object indexedObject = iterator.next();
+        if (areObjectsEqual(indexedObject, obj) && iterator.currentObjectIndex() != newIndexSlot) {
+          iterator.remove();
+          return true;
+      }
-  
+  public final boolean areObjectsEqual(Object o1, Object o2) {
+    if (o1 == null) {
+      return o2 == null;
+    }
+    try {
+      return TypeUtils.compare(o1, o2, OQLLexerTokenTypes.TOK_EQ).equals(Boolean.TRUE);
+    }
+    catch (TypeMismatchException e) {
+      return o1.equals(o2);
+    }
+  }
-   * Tests the set to determine if all of the elements in <tt>collection</tt>
-   * are present.
+   * Determine if all of the elements in <tt>collection</tt> are present.
-   * @return true if all elements were present in the set.
+   * @return true if all elements are present.
-   * Adds all of the elements in <tt>collection</tt> to the set.
-   * 
-   * @param collection a <code>Collection</code> value
-   * @return true if the set was modified by the add all operation.
+   * Unsupported because type mismatch exception cannot be thrown from Set interface
-    boolean changed = false;
-    int size = collection.size();
-    Iterator it;
-
-    ensureCapacity(size);
-    it = collection.iterator();
-    while (size-- > 0) {
-      Object obj = it.next();
-      if (obj != null && add(obj)) {
-        changed = true;
-      }
-    }
-    return changed;
+    throw new UnsupportedOperationException("Add all not implemented");
-    Iterator it;
-    it = collection.iterator();
+    Iterator it = collection.iterator();
-   * Removes any values in the set which are not contained in
-   * <tt>collection</tt>.
+   * Removes any values in the set which are not contained in <tt>collection</tt>.
-    Iterator it;
-    it = iterator();
-    while (size-- > 0) {
-      if (!collection.contains(it.next())) {
+    Iterator it = iterator();
+    while (it.hasNext()) {
+      Object object = it.next();
+      if (!collection.contains(object)) {
-
-  // GemStoneAddition
-
-   * Tells whether this set is currently holding any elements.
-   * 
-   * @return a <code>boolean</code> value
+   * return true if no elements exist in the array that are non null or REMOVED tokens
-   * Returns the number of slots used in the backing array
+   * Returns the number of positions used in the backing array
+   * as the array may contain REMOVED tokens
-  
-  public int size(Object indexKey) {
-    int hash, probe, index, length;
-    Object[] set;
-    Object cur;
-    int size = 0;
-    //find the first array index location
-    set = _set;
-    length = set.length;
-    hash = computeHash(indexKey, false);
-    index = hash % length;
-    cur = set[index];
-
-    if (cur == null) {
-      // return
-      return 0;
-    }
-
-    while (cur != null) {
-      if (cur != REMOVED) {
-        if (cur instanceof RegionEntry) {
-          if (_hashingStrategy.equalsOnGet(indexKey, cur)) {
-            size++;
-          }
-        }
-        break;
-      }
-      //If this is not the correct collection, one that does not match the key
-      //we are looking for, then continue our search
-      probe = 1 + (hash % (length - 2));
-      index -= probe;
-      if (index < 0) {
-        index += length;
-      }
-      cur = set[index];
-    }
-    return size;
-  }
-  
-   * Ensure that this hashtable has sufficient capacity to hold
-   * <tt>desiredCapacity<tt> <b>additional</b> elements without
-   * requiring a rehash.  This is a tuning method you can call
-   * before doing a large insert.
-   * 
-   * @param desiredCapacity an <code>int</code> value
+   * only used for query optimization.  Instead of crawling the entire array doing matches
+   * let's just return the size of the array as that is the worst case size
-  public void ensureCapacity(int desiredCapacity) {
-    if (desiredCapacity > (_maxSize - size())) {
-      rehash(PrimeFinder.nextPrime((int) Math.ceil(desiredCapacity + size()
-          / _loadFactor) + 1));
-      computeMaxSize(capacity());
-    }
+  public int size(Object indexKey) {
+    return _size;
-   * Compresses the hashtable to the minimum prime size (as defined by
-   * PrimeFinder) that will hold all of the elements currently in the table. If
-   * you have done a lot of <tt>remove</tt> operations and plan to do a lot of
-   * queries or insertions or iteration, it is a good idea to invoke this
-   * method. Doing so will accomplish two things:
-   * 
-   * <ol>
-   * <li>You'll free memory allocated to the table but no longer needed because
-   * of the remove()s.</li>
-   * 
-   * <li>You'll get better query/insert/iterator performance because there won't
-   * be any <tt>REMOVED</tt> slots to skip over when probing for indices in the
-   * table.</li>
-   * </ol>
+   * Compress the backing array if possible
-    // need at least one free spot for open addressing
-    rehash(PrimeFinder.nextPrime((int) Math.ceil(size() / _loadFactor) + 1));
-    computeMaxSize(capacity());
+    trimToSize(_size);
-
-  // GemStoneAddition
-  /**
-   * Calls compact by taking next set expansion into account. The set is
-   * expanded based on the capacity and load factor (default .5) this method
-   * calls the compact if the size is well below next expansion.
-   */
-  public void conditionalCompact() {
-    if (_size < (capacity() * (_loadFactor / CONDITIONAL_COMPACT_FACTOR))) {
-      compact();
+  
+  public boolean trimToSize( final int n ) {
+    final int l = HashCommon.nextPowerOfTwo( (int)Math.ceil( n / _loadFactor ) );
+    if ( this.n <= l ) return true;
+    try {
+            rehash( l );
-  }
+    catch ( OutOfMemoryError cantDoIt ) {
+            return false;
+    }
+    return true;
+}
-   * This simply calls {@link #compact compact}. It is included for symmetry
-   * with other collection classes. Note that the name of this method is
-   * somewhat misleading (which is why we prefer <tt>compact</tt>) as the load
-   * factor may require capacity above and beyond the size of this collection.
-   * 
-   * @see #compact
-   */
-  public final void trimToSize() {
-    compact();
-  }
-
-  /**
-   * Delete the record at <tt>index</tt>. Reduces the size of the collection by
-   * one.
+   * Remove the object at <tt>index</tt>.
-      //nothing removed
+      // nothing removed
-      _removedTokens ++;
+      _removedTokens++;
-    } 
+    }
-   * initializes the hashtable to a prime capacity which is at least
-   * <tt>initialCapacity + 1</tt>.
-   * 
-   * @param initialCapacity an <code>int</code> value
-   * @return the actual capacity chosen
+   * initializes this index set
-  protected int setUp(int initialCapacity) {
-    int capacity;
-    capacity = PrimeFinder.nextPrime(initialCapacity);
-    computeMaxSize(capacity);
-    _set = new Object[capacity];
-    return capacity;
+  protected int setUp(final int expectedCapacity, final float loadFactor) {
+    n = arraySize( expectedCapacity, loadFactor );
+    this._loadFactor = loadFactor;
+    _maxSize = computeMaxSize(n, loadFactor);
+    _mask = n - 1;
+    _free = computeNumFree();
+    _set = new Object[n + 1];
+    return n;
+  }
+  
+  private int computeNumFree() {
+    return n - _size;
+  }
+  
+  private int computeMaxSize(int n, float loadFactor) {
+    return Math.min( (int)Math.ceil( n * loadFactor ), n - 1 );
-   * Computes the values of maxSize. There will always be at least one free slot
-   * required.
-   * 
-   * @param capacity an <code>int</code> value
-   */
-  private final void computeMaxSize(int capacity) {
-    // need at least one free slot for open addressing
-    _maxSize = Math.min(capacity - 1, (int) Math.floor(capacity * _loadFactor));
-    _free = capacity - _size; // reset the free element count
-  }
-
-  /**
-   * After an insert, this hook is called to adjust the size/free values of the
-   * set and to perform rehashing if necessary.
+   * After insert, allows for calculating metadata
-    }
-    else {
-      //we used a removeToken
+    } else {
+      // we used a removeToken
-  
+
+  /**
+   * Before inserting we can ensure we have capacity
+   */
- // rehash whenever we exhaust the available space in the table
-      // choose a new capacity suited to the new state of the table
-      // if we've grown beyond our maximum size, double capacity;
-      // if we've exhausted the free spots, rehash to the same capacity,
-      // which will free up any stale removed slots for reuse.
-      int newCapacity = _size > _maxSize ? PrimeFinder
-          .nextPrime(capacity() << 1) : capacity();
-      rehash(newCapacity);
-      computeMaxSize(capacity());
-    }
-    else if (_removedTokens > _maxSize * CONDITIONAL_REMOVED_TOKEN_REHASH_FACTOR) {
+      rehash(arraySize(_size + 1, _loadFactor));
+      computeMaxSize(capacity(), _loadFactor);
+      _free = computeNumFree();
+    } else if (_removedTokens > _maxSize * CONDITIONAL_REMOVED_TOKEN_REHASH_FACTOR) {
-  final class ToObjectArrayProcedure implements ObjectProcedure {
-    private final Object[] target;
-    private int pos = 0;
-
-    public ToObjectArrayProcedure(final Object[] target) {
-      this.target = target;
-    }
-
-    public final boolean executeWith(Object value) {
-      target[pos++] = value;
-      return true;
-    }
-  } // ToObjectArrayProcedure
-
-  public String printAll() {
-    StringBuffer s = new StringBuffer();
-    for (int i = 0; i < _set.length; i++) {
-      Object object = _set[i];
-      if (object != null && object != REMOVED) {
-        s.append("\n slot[" + i + "]:");
-        if (object instanceof Collection) {
-          for (Object o : ((Collection) object)) {
-            if (o != null) {
-              RegionEntry re = (RegionEntry) o;
-              Object val = re._getValue(); // OFFHEAP _getValue ok
-              if (val instanceof StoredObject) {
-                // We don't have enough info here to deserialize an off-heap value
-                // so we can't call getDeserializedForReading.
-                // Also we can't call _getValueRetain because we do not
-                // know what region to pass in to it.
-                // So for now we just convert it to a String which all StoredObject
-                // impls can do without needing a refcount or to decompress.
-                val = val.toString();
-              }
-              if (val instanceof CachedDeserializable) {
-                val = ((CachedDeserializable) val).getDeserializedForReading();
-              }
-              s.append(re.getKey() + " =>  " + val + " # ");
-            }
-          }
-        } else {
-          RegionEntry re = (RegionEntry) object;
-          Object val = re._getValue(); // OFFHEAP _getValue ok
-          if (val instanceof StoredObject) {
-            // We don't have enough info here to deserialize an off-heap value
-            // so we can't call getDeserializedForReading.
-            // Also we can't call _getValueRetain because we do not
-            // know what region to pass in to it.
-            // So for now we just convert it to a String which all StoredObject
-            // impls can do without needing a refcount or to decompress.
-            val = val.toString();
-          }
-          if (val instanceof CachedDeserializable) {
-            val = ((CachedDeserializable) val).getDeserializedForReading();
-          }
-          s.append(re.getKey() + " =>  " + val);
-        }
-      }
-    }
-    return s.toString();
-     }
-     
-  
-    //objects at time of iterator creation
+    // objects at time of iterator creation
-    private int indexSlot;
+    private int pos;
+    private int prevPos;
-    private int length;
+    private int mask;
-    
-    private HashIndexSetIterator(Collection keysToRemove, Object[] objects ) {
+
+    private HashIndexSetIterator(Collection keysToRemove, Object[] objects) {
-      this.indexSlot = 0;
+      this.pos = 0;
+      this.prevPos = 0;
-      current = objects[indexSlot];
+      current = objects[pos];
-    
+
-      
-      length = objects.length;
-      hash = computeHash(keyToMatch, false);
-      probe = 1 + (hash % (length - 2));
-      indexSlot = hash % length;
-      current = objects[indexSlot];
+
+      mask = _mask;
+      hash = computeHash(keyToMatch);
+      pos = (it.unimi.dsi.fastutil.HashCommon.mix(hash)) & mask;
+      prevPos = pos;
+      current = objects[pos];
+    private void setPos(int pos) {
+      this.prevPos = this.pos;
+      this.pos = pos;
+    }
+
-        while (indexSlot < objects.length) {
-          current = objects[indexSlot];
+        while (pos < objects.length) {
+          current = objects[pos];
-            //continue searching
-          }
-          else if (notMatchingAnyKeyToRemove(keysToRemove, current)) {
+            // continue searching
+          } else if (notMatchingAnyKeyToRemove(keysToRemove, current)) {
-     
-          indexSlot++;
+          setPos(pos+1);
-
-        current = objects[indexSlot];
+        current = objects[pos];
-            if (_hashingStrategy.equalsOnGet(keyToMatch, current)) {
+            if (objectMatchesIndexKey(keyToMatch, current)) {
-          indexSlot -= probe;
-          if (indexSlot < 0) {
-            indexSlot += length;
-          }
-          
-          current = objects[indexSlot];
-        } 
+          setPos((pos + 1) & mask);
+          current = objects[pos];
+        }
+
-        if (_hashingStrategy.equalsOnGet(keyToMatch, current)) {
+        if (objectMatchesIndexKey(keyToMatch, current)) {
-        Object obj = current;
-        if (keysToRemove != null) {
-          // for Not equals we need to continue looking
-          // so increment the index here
-          indexSlot++;
-        } else {
-          //advance the pointer
-          indexSlot -= probe;
-          if (indexSlot < 0) {
-            indexSlot += length;
-          }
-        }
-        return obj;
-    }
-
-    int currentObjectIndex() {
-      int indexToRemove = 0;
-      //Because we advanced on the next() call, we need to get the indexSlot prior to advancing
+      Object obj = current;
-        indexToRemove = indexSlot - 1;
+        setPos(pos+1);
-        //move back the pointer
-        indexToRemove = indexSlot + probe;
-        if (indexSlot >= objects.length) {
-          indexToRemove = indexSlot - length;
-        }
+        // advance the pointer
+        setPos((pos + 1) & mask);
-      return indexToRemove;
+      return obj;
-    
+
+    int currentObjectIndex() {
+      return prevPos;
+    }
+
+    
+    public boolean objectMatchesIndexKey(Object indexKey, Object o) {
+      Object fieldValue = _imqEvaluator.evaluateKey(o);
+     
+      if (fieldValue == IndexManager.NULL && indexKey == IndexManager.NULL) {
+        return true;
+      } else {
+        try {
+          if (fieldValue instanceof PdxString) {
+           if (indexKey instanceof String) {
+             fieldValue = ((PdxString) fieldValue).toString(); 
+           }
+         }
+         else if (indexKey instanceof PdxString) {
+           if (fieldValue instanceof String) {
+             fieldValue = new PdxString((String)fieldValue);
+           }
+         }
+         return TypeUtils.compare(fieldValue, indexKey, OQLLexerTokenTypes.TOK_EQ).equals(Boolean.TRUE);
+        }
+        catch (TypeMismatchException e) {
+          return fieldValue.equals(indexKey);
+        }
+      }
+    }
-} // HashIndexSet
+}

MOV26 MOV26 MOV26 MOV23 MOV31 MOV31 UPD40 UPD40 UPD40 UPD40 INS23 INS23 INS23 INS23 INS31 MOV31 INS31 INS31 INS31 INS31 INS31 MOV23 MOV29 MOV83 MOV39 MOV59 INS39 MOV29 MOV83 INS39 MOV59 INS29 INS83 INS83 INS83 INS39 MOV59 INS83 INS43 INS59 INS29 MOV8 UPD83 UPD42 INS29 UPD39 MOV29 MOV83 MOV39 MOV42 MOV44 MOV44 MOV44 INS8 MOV78 UPD39 INS42 MOV8 UPD42 MOV44 UPD83 INS83 UPD39 INS42 MOV44 MOV44 INS8 UPD83 MOV83 MOV83 UPD39 MOV39 UPD42 MOV42 MOV44 MOV44 INS8 MOV8 INS29 INS44 INS8 UPD42 INS8 MOV83 UPD39 MOV39 UPD42 MOV42 INS44 INS8 MOV29 MOV83 MOV39 MOV42 MOV44 INS44 INS8 INS83 INS39 INS42 INS8 INS83 INS39 UPD42 MOV42 MOV44 MOV44 INS8 INS29 UPD83 INS83 INS39 INS42 INS8 INS23 INS31 INS31 INS31 INS31 UPD66 UPD66 UPD66 UPD34 UPD42 UPD42 MOV65 INS40 INS42 INS65 UPD65 UPD43 UPD42 INS60 INS60 INS60 MOV60 INS25 INS25 MOV25 INS65 INS65 INS65 INS65 INS65 MOV25 MOV21 MOV41 INS60 INS60 INS60 MOV60 INS60 MOV21 MOV60 MOV25 INS54 INS60 INS41 UPD42 MOV25 MOV60 MOV60 MOV21 INS21 INS21 INS21 INS21 MOV60 INS24 MOV21 INS41 INS41 INS25 INS54 UPD65 INS65 INS43 INS42 INS41 MOV21 INS83 INS39 INS42 INS60 INS25 INS54 MOV41 INS83 UPD42 INS83 INS39 INS42 MOV21 MOV21 INS21 MOV21 MOV21 INS21 INS41 INS41 INS39 INS42 INS41 INS65 MOV25 INS83 INS39 INS59 UPD83 MOV83 INS39 UPD42 MOV42 INS44 INS8 MOV78 INS83 MOV43 INS42 MOV43 INS8 MOV39 MOV42 INS8 INS83 INS39 INS42 MOV44 MOV44 MOV8 UPD66 UPD66 INS66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 INS40 UPD66 INS32 UPD66 MOV39 MOV59 INS39 MOV59 INS39 MOV59 INS38 INS8 UPD66 UPD66 MOV27 MOV8 MOV27 MOV8 UPD66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 UPD27 MOV32 UPD66 UPD66 INS39 MOV59 INS39 INS59 MOV39 MOV59 INS83 MOV5 MOV59 INS8 MOV8 MOV8 INS39 INS59 INS42 UPD66 UPD42 UPD66 INS7 INS7 INS7 INS7 MOV5 MOV58 MOV27 MOV8 UPD66 UPD66 INS32 INS32 UPD66 UPD66 MOV8 INS27 MOV8 INS8 INS12 UPD66 UPD66 UPD66 UPD66 MOV43 INS32 UPD66 INS66 INS66 INS66 MOV42 INS42 UPD66 INS32 INS83 INS39 INS59 UPD27 MOV27 MOV41 INS8 INS12 UPD66 UPD66 INS7 INS7 INS42 INS27 INS32 UPD66 INS66 MOV27 MOV25 UPD42 UPD42 INS42 INS21 INS39 INS42 MOV21 MOV21 MOV60 MOV25 MOV41 INS41 INS25 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS42 UPD42 INS36 INS25 INS61 INS53 UPD42 INS42 UPD42 INS42 UPD42 INS42 UPD42 INS25 MOV41 INS42 INS34 INS42 INS42 INS42 INS27 INS42 INS32 INS42 INS32 INS42 INS32 INS42 UPD42 MOV42 MOV42 INS42 MOV38 MOV21 MOV41 INS42 INS33 MOV41 INS44 INS8 UPD45 MOV32 MOV32 INS42 INS42 MOV60 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS22 INS42 MOV21 INS44 MOV8 UPD42 INS22 INS42 INS42 INS32 UPD42 INS27 INS32 INS42 INS3 INS42 INS42 INS42 INS42 INS11 INS27 MOV21 MOV21 MOV21 INS7 INS7 UPD7 MOV27 INS8 INS42 MOV43 INS27 MOV8 INS8 UPD42 UPD42 UPD42 INS27 INS36 INS41 INS38 INS8 INS14 INS38 MOV8 INS42 MOV27 INS8 INS42 INS34 INS42 INS42 INS42 INS42 MOV5 INS27 MOV27 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS27 INS32 UPD43 MOV43 UPD42 MOV42 MOV41 MOV43 UPD42 MOV42 UPD42 MOV42 INS11 INS52 INS42 INS43 INS42 UPD42 UPD42 UPD42 INS52 INS42 INS42 INS42 INS42 UPD42 MOV42 MOV34 INS42 MOV5 INS27 INS39 INS32 INS42 INS34 INS22 INS34 UPD42 INS42 UPD42 UPD27 UPD42 INS42 INS22 INS22 INS22 UPD42 INS21 UPD42 INS32 INS27 INS27 INS54 INS27 INS27 INS27 INS42 INS36 INS25 INS43 INS27 INS42 INS40 INS36 INS61 UPD43 INS21 INS42 INS34 MOV60 MOV25 INS42 INS33 INS32 INS42 INS40 UPD42 UPD42 MOV39 MOV32 UPD42 INS42 INS42 INS42 MOV34 INS42 INS42 INS27 UPD42 INS32 INS42 UPD42 UPD42 INS52 INS42 UPD42 INS42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 MOV8 INS32 INS32 INS42 INS42 INS42 UPD42 MOV42 INS40 UPD42 MOV42 INS40 INS8 INS12 INS36 INS33 UPD42 MOV42 INS42 INS32 MOV27 INS27 INS27 INS41 UPD42 MOV42 INS45 INS42 INS45 INS42 INS27 INS38 INS8 UPD42 INS7 MOV43 MOV27 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS40 UPD42 UPD42 UPD42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 MOV27 INS42 INS42 INS32 UPD42 INS21 UPD42 INS42 INS27 INS42 INS27 INS25 INS41 INS44 INS8 INS7 INS36 INS42 INS42 UPD42 INS27 INS27 INS36 INS27 INS42 INS27 INS27 INS36 INS42 MOV32 MOV42 INS42 INS42 INS34 INS40 INS42 INS42 INS32 UPD42 INS32 UPD42 MOV42 UPD34 MOV34 INS36 INS42 INS62 INS8 INS25 INS32 INS43 INS42 MOV41 UPD42 MOV42 INS2 INS42 INS36 INS33 INS42 INS42 INS32 INS42 INS42 INS36 INS33 UPD42 MOV42 MOV42 INS27 UPD42 UPD42 UPD42 MOV32 INS42 INS27 INS42 INS27 INS27 INS42 INS43 INS25 INS62 INS8 INS32 INS42 INS40 INS42 INS32 MOV42 INS7 INS7 INS36 INS42 INS42 INS7 INS27 UPD27 MOV27 UPD42 UPD42 INS42 INS34 INS8 INS36 INS42 UPD42 INS42 INS34 INS42 INS62 INS8 INS42 INS43 INS25 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS42 UPD42 MOV42 INS27 INS42 INS2 INS42 UPD42 MOV42 INS2 INS36 MOV33 UPD42 UPD42 INS41 INS27 INS42 MOV43 MOV21 INS42 INS62 MOV8 INS36 INS42 INS42 INS7 UPD42 MOV42 INS7 INS7 INS9 UPD42 MOV42 UPD34 MOV34 INS42 MOV43 INS32 UPD42 MOV42 INS27 UPD42 MOV42 UPD27 MOV27 UPD42 MOV42 INS2 UPD42 INS32 INS40 INS42 UPD42 MOV42 MOV36 INS42 INS42 INS42 INS7 INS36 INS42 UPD42 INS14 UPD27 INS32 UPD42 MOV42 INS27 INS11 INS43 INS11 UPD42 UPD34 INS40 INS42 INS42 INS36 INS42 INS43 INS42 INS42 INS43 INS42 INS27 INS42 INS42 INS42 INS34 DEL66 DEL83 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL34 DEL23 DEL83 DEL83 DEL83 DEL39 DEL23 DEL83 DEL83 DEL83 DEL39 DEL23 DEL42 DEL43 DEL66 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL31 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL17 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL17 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL17 DEL8 DEL31 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL17 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL17 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL17 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL17 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL7 DEL21 DEL39 DEL42 DEL42 DEL42 DEL42 DEL27 DEL32 DEL11 DEL42 DEL42 DEL66 DEL65 DEL39 DEL42 DEL44 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL59 DEL60 DEL42 DEL40 DEL7 DEL21 DEL9 DEL42 DEL42 DEL42 DEL27 DEL7 DEL21 DEL42 DEL2 DEL7 DEL21 DEL39 DEL42 DEL34 DEL38 DEL59 DEL60 DEL52 DEL42 DEL22 DEL33 DEL27 DEL52 DEL42 DEL22 DEL32 DEL7 DEL21 DEL8 DEL25 DEL33 DEL27 DEL42 DEL42 DEL27 DEL27 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL41 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL34 DEL42 DEL27 DEL36 DEL27 DEL7 DEL21 DEL42 DEL42 DEL7 DEL21 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL2 DEL7 DEL21 DEL8 DEL61 DEL66 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL2 DEL42 DEL7 DEL21 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL38 DEL34 DEL27 DEL36 DEL2 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL40 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL40 DEL34 DEL27 DEL34 DEL34 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL2 DEL42 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL8 DEL25 DEL25 DEL25 DEL25 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL27 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL32 DEL38 DEL52 DEL42 DEL22 DEL33 DEL27 DEL27 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25 DEL25 DEL42 DEL34 DEL27 DEL25 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL32 DEL39 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL33 DEL27 DEL27 DEL42 DEL42 DEL42 DEL9 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL34 DEL32 DEL21 DEL8 DEL25 DEL42 DEL41 DEL66 DEL66 DEL66 DEL66 DEL9 DEL34 DEL42 DEL42 DEL34 DEL27 DEL36 DEL27 DEL42 DEL7 DEL21 DEL42 DEL34 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL2 DEL7 DEL21 DEL8 DEL42 DEL27 DEL27 DEL19 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL40 DEL7 DEL21 DEL42 DEL42 DEL42 DEL27 DEL7 DEL21 DEL42 DEL2 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL41 DEL8 DEL25 DEL7 DEL21 DEL27 DEL25 DEL8 DEL54 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL65 DEL29 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL38 DEL27 DEL83 DEL83 DEL42 DEL42 DEL43 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL39 DEL42 DEL42 DEL41 DEL8 DEL31 DEL55 DEL42 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL32 DEL25 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL24 DEL8 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL43 DEL45 DEL45 DEL45 DEL45 DEL45 DEL45 DEL45 DEL45 DEL45 DEL45 DEL27 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL27 DEL14 DEL53 DEL8 DEL31 DEL83 DEL83 DEL42 DEL42 DEL62 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL83 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL66 DEL66 DEL42 DEL42 DEL42 DEL43 DEL69 DEL42 DEL43 DEL69 DEL39 DEL69 DEL68 DEL65 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL44 DEL31 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL8 DEL31 DEL42 DEL65 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL27 DEL25 DEL42 DEL42 DEL34 DEL38 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL34 DEL38 DEL32 DEL21 DEL40 DEL42 DEL42 DEL11 DEL32 DEL32 DEL42 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL39 DEL42 DEL9 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL7 DEL21 DEL42 DEL37 DEL34 DEL27 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL61 DEL42 DEL41 DEL8 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL66 DEL42 DEL43 DEL42 DEL7 DEL21 DEL42 DEL37 DEL34 DEL27 DEL42 DEL32 DEL39 DEL42 DEL59 DEL42 DEL59 DEL42 DEL59 DEL42 DEL59 DEL60 DEL43 DEL85 DEL5 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL42 DEL7 DEL21 DEL42 DEL40 DEL7 DEL21 DEL42 DEL42 DEL42 DEL9 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL27 DEL7 DEL21 DEL42 DEL42 DEL42 DEL2 DEL7 DEL21 DEL42 DEL33 DEL27 DEL34 DEL41 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL27 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL37 DEL21 DEL8 DEL25 DEL8 DEL25 DEL10 DEL8 DEL25 DEL42 DEL34 DEL42 DEL42 DEL34 DEL27 DEL36 DEL27 DEL36 DEL27 DEL7 DEL21 DEL42 DEL42 DEL7 DEL21 DEL42 DEL34 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL2 DEL7 DEL21 DEL8 DEL61 DEL42 DEL41 DEL8 DEL66 DEL66 DEL66 DEL42 DEL66 DEL65 DEL42 DEL42 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL27 DEL32 DEL11 DEL34 DEL27 DEL32 DEL32 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL27 DEL36 DEL27 DEL8 DEL25 DEL8 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL27 DEL36 DEL27 DEL36 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL11 DEL34 DEL27 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL8 DEL25 DEL8 DEL31 DEL66 DEL42 DEL67 DEL66 DEL65 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL67 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL66 DEL66 DEL42 DEL66 DEL65 DEL66 DEL65 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL3 DEL42 DEL42 DEL27 DEL39 DEL42 DEL42 DEL42 DEL42 DEL27 DEL32 DEL11 DEL32 DEL42 DEL42 DEL27 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL39 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL8 DEL31 DEL66 DEL83 DEL83 DEL39 DEL42 DEL39 DEL42 DEL42 DEL42 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL32 DEL42 DEL32 DEL16 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL42 DEL43 DEL83 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL37 DEL2 DEL42 DEL7 DEL21 DEL9 DEL41 DEL8 DEL31 DEL55 DEL42 DEL33 DEL27 DEL42 DEL42 DEL27 DEL27 DEL42 DEL42 DEL32 DEL45 DEL42 DEL45 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL42 DEL45 DEL42 DEL45 DEL27 DEL32 DEL21 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL70 DEL8 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL43 DEL62 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL32 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL8 DEL24 DEL42 DEL42 DEL32 DEL41 DEL8 DEL40 DEL9 DEL34 DEL42 DEL42 DEL34 DEL27 DEL36 DEL27 DEL42 DEL42 DEL27 DEL42 DEL37 DEL42 DEL42 DEL37 DEL42 DEL42 DEL42 DEL7 DEL21 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL9 DEL41 DEL8 DEL27 DEL42 DEL42 DEL7 DEL8 DEL8 DEL25 DEL8 DEL31 DEL31 DEL39 DEL34 DEL42 DEL42 DEL27 DEL42 DEL42 DEL27 DEL42 DEL33 DEL27 DEL42 DEL34 DEL27 DEL7 DEL21 DEL8 DEL42 DEL40 DEL27 DEL25 DEL8 DEL25
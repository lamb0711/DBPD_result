Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-  public static final String EVICTION_ATTRIBUTE_MAXIMUM_MEMORY_MESSAGE = " the Eviction Attribute for maximum memory, ";
+  public static final String EVICTION_ATTRIBUTE_MAXIMUM_MEMORY_MESSAGE =
+      " the Eviction Attribute for maximum memory, ";
-  public static final String EVICTION_ATTRIBUTE_MAXIMUM_ENTRIES_MESSAGE = " the Eviction Attribute for maximum entries, ";
+  public static final String EVICTION_ATTRIBUTE_MAXIMUM_ENTRIES_MESSAGE =
+      " the Eviction Attribute for maximum entries, ";
-  public static final String EVICTION_ATTRIBUTES_ARE_INCOMPATIBLE_MESSAGE = " is incompatible with other VMs which have EvictionAttributes ";
+  public static final String EVICTION_ATTRIBUTES_ARE_INCOMPATIBLE_MESSAGE =
+      " is incompatible with other VMs which have EvictionAttributes ";
-   * This method validates the PartitionedAttributes that user provided PR
-   * Attributes with PR Attributes set in PR Config obtained from global
-   * meta-data allPartitionedRegion region
+   * This method validates the PartitionedAttributes that user provided PR Attributes with PR
+   * Attributes set in PR Config obtained from global meta-data allPartitionedRegion region
-    final PartitionAttributes userPA = pr.getAttributes()
-        .getPartitionAttributes();
+    final PartitionAttributes userPA = pr.getAttributes().getPartitionAttributes();
-              .toLocalizedString(new Object[] {
-                  Integer.valueOf(userPA.getRedundantCopies()),
-                  Integer.valueOf(prconfPA.getRedundantCopies()) }));
+              .toLocalizedString(new Object[] {Integer.valueOf(userPA.getRedundantCopies()),
+                  Integer.valueOf(prconfPA.getRedundantCopies())}));
-              .toLocalizedString(new Object[] {
-                  Integer.valueOf(userPA.getTotalNumBuckets()),
-                  Integer.valueOf(prconfTotalNumBuckets) }));
+              .toLocalizedString(new Object[] {Integer.valueOf(userPA.getTotalNumBuckets()),
+                  Integer.valueOf(prconfTotalNumBuckets)}));
-     validatePartitionListeners(prconf, userPA);
-     validatePartitionResolver(prconf, userPA);
-     validateColocatedWith(prconf, userPA);
-     validateExpirationAttributes(pr.getAttributes(), prconf);
+    validatePartitionListeners(prconf, userPA);
+    validatePartitionResolver(prconf, userPA);
+    validateColocatedWith(prconf, userPA);
+    validateExpirationAttributes(pr.getAttributes(), prconf);
-  
+
-    if (userPA.getPartitionListeners() == null
-        && userPA.getPartitionListeners().length == 0 && prconfList != null) {
+    if (userPA.getPartitionListeners() == null && userPA.getPartitionListeners().length == 0
+        && prconfList != null) {
-              .toLocalizedString(new Object[] { null, prconfList }));
+              .toLocalizedString(new Object[] {null, prconfList}));
-                .toLocalizedString(new Object[] { userPRList, prconfList }));
+                .toLocalizedString(new Object[] {userPRList, prconfList}));
-                  .toLocalizedString(new Object[] { userPRList, prconfList }));
+                  .toLocalizedString(new Object[] {userPRList, prconfList}));
-    /* if (userPA.getPartitionResolver() == null
-        && prconf.getPartitionResolverClassName() != null) {
-      throw new IllegalStateException(
-          LocalizedStrings.PartitionRegionConfigValidator_INCOMPATIBLE_PARTITION_RESOLVER
-              .toLocalizedString(new Object[] { "null",
-                  prconf.getPartitionResolverClassName() }));
-    }*/ 
-	if (userPA.getPartitionResolver() != null
-        && prconf.getResolverClassName() != null) {
-      if (!(prconf.getResolverClassName().equals(userPA
-          .getPartitionResolver().getClass().getName()))) {
+    /*
+     * if (userPA.getPartitionResolver() == null && prconf.getPartitionResolverClassName() != null)
+     * { throw new IllegalStateException(
+     * LocalizedStrings.PartitionRegionConfigValidator_INCOMPATIBLE_PARTITION_RESOLVER
+     * .toLocalizedString(new Object[] { "null", prconf.getPartitionResolverClassName() })); }
+     */
+    if (userPA.getPartitionResolver() != null && prconf.getResolverClassName() != null) {
+      if (!(prconf.getResolverClassName()
+          .equals(userPA.getPartitionResolver().getClass().getName()))) {
-                .toLocalizedString(new Object[] {
-                    userPA.getPartitionResolver().getClass().getName(),
-                    prconf.getResolverClassName() }));
+                .toLocalizedString(new Object[] {userPA.getPartitionResolver().getClass().getName(),
+                    prconf.getResolverClassName()}));
-              .toLocalizedString(new Object[] { "null",
-                  prconf.getColocatedWith() }));
+              .toLocalizedString(new Object[] {"null", prconf.getColocatedWith()}));
-                .toLocalizedString(new Object[] { userPA.getColocatedWith(),
-                    prconf.getColocatedWith() }));
+                .toLocalizedString(
+                    new Object[] {userPA.getColocatedWith(), prconf.getColocatedWith()}));
-              .toLocalizedString(new Object[] { " region idle timout " }));
+              .toLocalizedString(new Object[] {" region idle timout "}));
-              .toLocalizedString(new Object[] { " region time to live " }));
+              .toLocalizedString(new Object[] {" region time to live "}));
-              .toLocalizedString(new Object[] { " entry idle timout " }));
+              .toLocalizedString(new Object[] {" entry idle timout "}));
-              .toLocalizedString(new Object[] { " entry time to live " }));
+              .toLocalizedString(new Object[] {" entry time to live "}));
-  
+
-   * The 2nd step of Eviction Attributes validation to ensure that all VMs are
-   * reasonably similar to prevent weird config. issues.
+   * The 2nd step of Eviction Attributes validation to ensure that all VMs are reasonably similar to
+   * prevent weird config. issues.
-   * @param prconfEa
-   *                the eviction attributes currently used by other VMs
+   * @param prconfEa the eviction attributes currently used by other VMs
-  private void validateDistributedEvictionAttributes(
-      final EvictionAttributes prconfEa) {
+  private void validateDistributedEvictionAttributes(final EvictionAttributes prconfEa) {
-    final boolean equivAlgoAndAction = ea.getAlgorithm().equals(
-        prconfEa.getAlgorithm())
+    final boolean equivAlgoAndAction = ea.getAlgorithm().equals(prconfEa.getAlgorithm())
-      throw new IllegalStateException("For Partitioned Region "
-          + pr.getFullPath() + " the configured EvictionAttributes " + ea
-          + EVICTION_ATTRIBUTES_ARE_INCOMPATIBLE_MESSAGE + prconfEa);
-    }
-    else {
+      throw new IllegalStateException(
+          "For Partitioned Region " + pr.getFullPath() + " the configured EvictionAttributes " + ea
+              + EVICTION_ATTRIBUTES_ARE_INCOMPATIBLE_MESSAGE + prconfEa);
+    } else {
-        if (! ea.getAlgorithm().isLRUHeap() && ea.getMaximum() != prconfEa.getMaximum()) {
+        if (!ea.getAlgorithm().isLRUHeap() && ea.getMaximum() != prconfEa.getMaximum()) {
-   /**
-   * The 3rd step of EvictionAttributes validation, where mutation is acceptible
-   * This should be done before buckets are created. Validate EvictionAttributes
-   * with respect to localMaxMemory potentially changing the eviction
-   * attributes.
+  /**
+   * The 3rd step of EvictionAttributes validation, where mutation is acceptible This should be done
+   * before buckets are created. Validate EvictionAttributes with respect to localMaxMemory
+   * potentially changing the eviction attributes.
-    if (pr.getLocalMaxMemory()==0 && !ea.getAction().isNone()) {
+    if (pr.getLocalMaxMemory() == 0 && !ea.getAction().isNone()) {
-          new Object[] { ea, pr.getFullPath(), Integer.valueOf(pr.localMaxMemory)}));
+          new Object[] {ea, pr.getFullPath(), Integer.valueOf(pr.localMaxMemory)}));
-   * validates the persistence for datastores should match
-   * between members
+   * validates the persistence for datastores should match between members
-    final boolean isPersistent = pr.getAttributes().getDataPolicy() == DataPolicy.PERSISTENT_PARTITION;
-    if (pr.getLocalMaxMemory()==0 || prconf==null) {
+    final boolean isPersistent =
+        pr.getAttributes().getDataPolicy() == DataPolicy.PERSISTENT_PARTITION;
+    if (pr.getLocalMaxMemory() == 0 || prconf == null) {
-      Node n = (Node)itor.next();
+      Node n = (Node) itor.next();
-        if (n.isPersistent() != (pr.getAttributes().getDataPolicy() == DataPolicy.PERSISTENT_PARTITION)) {
+        if (n.isPersistent() != (pr.getAttributes()
+            .getDataPolicy() == DataPolicy.PERSISTENT_PARTITION)) {
-    final PartitionAttributesImpl userPA = (PartitionAttributesImpl) pr.getAttributes()
-        .getPartitionAttributes();
-    
+    final PartitionAttributesImpl userPA =
+        (PartitionAttributesImpl) pr.getAttributes().getPartitionAttributes();
+
-      if (colocatedPR.getPartitionAttributes().getTotalNumBuckets()!= userPA.getTotalNumBuckets()){
+      if (colocatedPR.getPartitionAttributes().getTotalNumBuckets() != userPA
+          .getTotalNumBuckets()) {
-      if (colocatedPR.getPartitionAttributes().getRedundantCopies()!= userPA.getRedundantCopies()){
+      if (colocatedPR.getPartitionAttributes().getRedundantCopies() != userPA
+          .getRedundantCopies()) {
-        throw new IllegalStateException(
-            "Colocated regions should have accessors at the same node");
+        throw new IllegalStateException("Colocated regions should have accessors at the same node");
-      if ((colocatedPR.getLocalMaxMemory() != 0)
-          && (userPA.getLocalMaxMemory() == 0)) {
-        throw new IllegalStateException(
-            "Colocated regions should have accessors at the same node");
+      if ((colocatedPR.getLocalMaxMemory() != 0) && (userPA.getLocalMaxMemory() == 0)) {
+        throw new IllegalStateException("Colocated regions should have accessors at the same node");
-  public void validateCacheLoaderWriterBetweenDataStores(
-      PartitionRegionConfig prconf) {
+  public void validateCacheLoaderWriterBetweenDataStores(PartitionRegionConfig prconf) {
-      Node n = (Node)itor.next();
+      Node n = (Node) itor.next();
-      }
-      else {
-        if (n.isCacheLoaderAttached()
-            && pr.getAttributes().getCacheLoader() == null) {
+      } else {
+        if (n.isCacheLoaderAttached() && pr.getAttributes().getCacheLoader() == null) {
-                  .toLocalizedString(new Object[] { this.pr.getName() }));
+                  .toLocalizedString(new Object[] {this.pr.getName()}));
-        if (!n.isCacheLoaderAttached()
-            && pr.getAttributes().getCacheLoader() != null) {
+        if (!n.isCacheLoaderAttached() && pr.getAttributes().getCacheLoader() != null) {
-                  .toLocalizedString(new Object[] { this.pr.getName() }));
+                  .toLocalizedString(new Object[] {this.pr.getName()}));
-        if (n.isCacheWriterAttached()
-            && pr.getAttributes().getCacheWriter() == null) {
+        if (n.isCacheWriterAttached() && pr.getAttributes().getCacheWriter() == null) {
-                  .toLocalizedString(new Object[] { this.pr.getName() }));
+                  .toLocalizedString(new Object[] {this.pr.getName()}));
-        if (!n.isCacheWriterAttached()
-            && pr.getAttributes().getCacheWriter() != null) {
+        if (!n.isCacheWriterAttached() && pr.getAttributes().getCacheWriter() != null) {
-                  .toLocalizedString(new Object[] { this.pr.getName() }));
+                  .toLocalizedString(new Object[] {this.pr.getName()}));
-   * validate that for all partitions defined across all datastores, sum of
-   * num-buckets is not more than total-num-buckets defined
+   * validate that for all partitions defined across all datastores, sum of num-buckets is not more
+   * than total-num-buckets defined
-    for (FixedPartitionAttributesImpl fpa : this.pr
-        .getFixedPartitionAttributesImpl()) {
+    for (FixedPartitionAttributesImpl fpa : this.pr.getFixedPartitionAttributesImpl()) {
-        Object[] prms = new Object[] { this.pr.getName(), numBuckets,
-            this.pr.getTotalNumberOfBuckets() };
+        Object[] prms =
+            new Object[] {this.pr.getName(), numBuckets, this.pr.getTotalNumberOfBuckets()};
-  
+
-   * Validate that for the given partition, number if secondaries are never
-   * exceed redundant copies defined Validate that the num-buckets defined for a
-   * partition are same across all datastores
+   * Validate that for the given partition, number if secondaries are never exceed redundant copies
+   * defined Validate that the num-buckets defined for a partition are same across all datastores
-      List<FixedPartitionAttributesImpl> allSameFPAs = this.pr.getRegionAdvisor().adviseSameFPAs(fpa);
+      List<FixedPartitionAttributesImpl> allSameFPAs =
+          this.pr.getRegionAdvisor().adviseSameFPAs(fpa);
-      
+
-            Object[] prms = new Object[] { this.pr.getName(),
-                fpa.getPartitionName(), fpa.getNumBuckets(),
-                otherfpa.getNumBuckets() };
+            Object[] prms = new Object[] {this.pr.getName(), fpa.getPartitionName(),
+                fpa.getNumBuckets(), otherfpa.getNumBuckets()};
-          
+
-              Object[] prms = new Object[] { this.pr.getName(), numSecondaries,
-                  fpa.getPartitionName(), this.pr.getRedundantCopies() };
+              Object[] prms = new Object[] {this.pr.getName(), numSecondaries,
+                  fpa.getPartitionName(), this.pr.getRedundantCopies()};
-  
+
-   * Validate that same partition is not defined as primary on more that one
-   * datastore
+   * Validate that same partition is not defined as primary on more that one datastore
-    List<FixedPartitionAttributesImpl> remotePrimaryFPAs = this.pr.getRegionAdvisor().adviseRemotePrimaryFPAs();
-    
+    List<FixedPartitionAttributesImpl> remotePrimaryFPAs =
+        this.pr.getRegionAdvisor().adviseRemotePrimaryFPAs();
+
-        Object[] prms = new Object[]{this.pr.getName(), fpa.getPartitionName()};
+        Object[] prms = new Object[] {this.pr.getName(), fpa.getPartitionName()};
-    while (itr.hasNext()) {     
+    while (itr.hasNext()) {
-        if (n.getPRType() == Node.DATASTORE
-            || n.getPRType() == Node.ACCESSOR_DATASTORE) {
+        if (n.getPRType() == Node.DATASTORE || n.getPRType() == Node.ACCESSOR_DATASTORE) {
-          Object[] prms = new Object[] { pr.getName() };
+          Object[] prms = new Object[] {pr.getName()};
-          if (n.getPRType() == Node.FIXED_PR_ACCESSOR
-              || n.getPRType() == Node.FIXED_PR_DATASTORE) {
+          if (n.getPRType() == Node.FIXED_PR_ACCESSOR || n.getPRType() == Node.FIXED_PR_DATASTORE) {
-            Object[] prms = new Object[] { pr.getName() };
+            Object[] prms = new Object[] {pr.getName()};

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66
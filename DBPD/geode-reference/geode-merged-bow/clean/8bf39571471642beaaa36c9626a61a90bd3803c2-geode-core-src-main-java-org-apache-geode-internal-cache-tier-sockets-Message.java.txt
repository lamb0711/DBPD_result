Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class encapsulates the wire protocol. It provides accessors to
- * encode and decode a message and  serialize it out to the wire.
+ * This class encapsulates the wire protocol. It provides accessors to encode and decode a message
+ * and serialize it out to the wire.
- * We read the fixed length 16 bytes into a byte[] and populate a bytebuffer
- * We read the fixed length header tokens from the header
- * parse the header and use information contained in there to read the payload.
+ * We read the fixed length 16 bytes into a byte[] and populate a bytebuffer We read the fixed
+ * length header tokens from the header parse the header and use information contained in there to
+ * read the payload.
-public class Message  {
+public class Message {
-   * maximum size of an outgoing message.  See GEODE-478
+   * maximum size of an outgoing message. See GEODE-478
-  public static int MAX_MESSAGE_SIZE = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "client.max-message-size", DEFAULT_MAX_MESSAGE_SIZE).intValue();
+  public static int MAX_MESSAGE_SIZE =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "client.max-message-size",
+          DEFAULT_MAX_MESSAGE_SIZE).intValue();
-  
+
-  
+
-  
+
-  protected int payloadLength=0;
-  protected int numberOfParts =0;
+  protected int payloadLength = 0;
+  protected int numberOfParts = 0;
-//  private int MAX_MSGS = -1;
+  // private int MAX_MSGS = -1;
-  private boolean hdrRead = false;  
-  private int chunkSize = 1024;//Default Chunk Size.
+  private boolean hdrRead = false;
+  private int chunkSize = 1024;// Default Chunk Size.
-  public static final byte MESSAGE_HAS_SECURE_PART = (byte)0x02;
-  public static final byte MESSAGE_IS_RETRY = (byte)0x04;
-  
-  public static final byte MESSAGE_IS_RETRY_MASK = (byte)0xFB;
+  public static final byte MESSAGE_HAS_SECURE_PART = (byte) 0x02;
+  public static final byte MESSAGE_IS_RETRY = (byte) 0x04;
+
+  public static final byte MESSAGE_IS_RETRY_MASK = (byte) 0xFB;
-  
+
-  
+
-    for (int i=0;i<partsList.length;i++) {
+    for (int i = 0; i < partsList.length; i++) {
-  public boolean isSecureMode() {    
+  public boolean isSecureMode() {
-  
-  public byte[] getSecureBytes()
-    throws IOException, ClassNotFoundException {
-    return (byte[])this.securePart.getObject();
+
+  public byte[] getSecureBytes() throws IOException, ClassNotFoundException {
+    return (byte[]) this.securePart.getObject();
-  
+
-      throw new IllegalArgumentException(LocalizedStrings.Message_INVALID_MESSAGETYPE.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.Message_INVALID_MESSAGETYPE.toLocalizedString());
-  
+
-    this.flags = (byte)(this.flags | MESSAGE_HAS_SECURE_PART);
+    this.flags = (byte) (this.flags | MESSAGE_HAS_SECURE_PART);
-  
+
-    this.flags = (byte)(this.flags & MESSAGE_HAS_SECURE_PART);
+    this.flags = (byte) (this.flags & MESSAGE_HAS_SECURE_PART);
-   *  Sets and builds the {@link Part}s that are sent
-   *  in the payload of the Message
+   * Sets and builds the {@link Part}s that are sent in the payload of the Message
+   * 
-    //hitesh: need to add security header here from server
-    //need to insure it is not chunked message
-    //should we look message type to avoid internal message like ping
+    // hitesh: need to add security header here from server
+    // need to insure it is not chunked message
+    // should we look message type to avoid internal message like ping
-    this.currentPart=0;
+    this.currentPart = 0;
-      for (int i=0;i<numberOfParts;i++) {
+      for (int i = 0; i < numberOfParts; i++) {
-  
+
+   * 
-  
+
-  
+
-   * This returns true if the message has been marked as having been previously
-   * transmitted to a different server.
+   * This returns true if the message has been marked as having been previously transmitted to a
+   * different server.
-  /*Sets size for HDOS chunk.*/
+  /* Sets size for HDOS chunk. */
-  
+
-   * When building a Message this will return the number of the
-   * next Part to be added to the message
+   * When building a Message this will return the number of the next Part to be added to the message
-  
-  private static final Map<String,byte[]> CACHED_STRINGS = new ConcurrentHashMap<String,byte[]>();
-  
+
+  private static final Map<String, byte[]> CACHED_STRINGS = new ConcurrentHashMap<String, byte[]>();
+
-    if (str==null) {
-      addRawPart((byte[])null, false);
-    }
-    else {
+    if (str == null) {
+      addRawPart((byte[]) null, false);
+    } else {
-  
+
-   * Adds a new part to this message that contains a <code>byte</code>
-   * array (as opposed to a serialized object).
+   * Adds a new part to this message that contains a <code>byte</code> array (as opposed to a
+   * serialized object).
-      addStringPart((String)o);
+      addStringPart((String) o);
+
-   * Like addObjPart(Object) but also prefers to reference
-   * objects in the part instead of copying them into a byte buffer.
+   * Like addObjPart(Object) but also prefers to reference objects in the part instead of copying
+   * them into a byte buffer.
-      addRawPart((byte[])o, false);
+      addRawPart((byte[]) o, false);
+
-      addRawPart((byte[])o, false);
+      addRawPart((byte[]) o, false);
-      addRawPart((byte[])o, isObject);
+      addRawPart((byte[]) o, isObject);
-      part.setPartState((StoredObject)o, isObject);
+      part.setPartState((StoredObject) o, isObject);
-  
+
-    if (version.equals(Version.CURRENT)){
+    if (version.equals(Version.CURRENT)) {
-    // create the HDOS with a flag telling it that it can keep any byte[] or ByteBuffers/ByteSources passed to it.
+    // create the HDOS with a flag telling it that it can keep any byte[] or ByteBuffers/ByteSources
+    // passed to it.
-    
+
-      throw new UnsupportedOperationException("zipValues no longer supported");    
-      
+      throw new UnsupportedOperationException("zipValues no longer supported");
+
-      if (version.equals(Version.CURRENT)){
+      if (version.equals(Version.CURRENT)) {
-  
+
-  
+
-   * Adds a new part to this message that may contain a serialized
-   * object.
+   * Adds a new part to this message that may contain a serialized object.
-  public void addRawPart(byte[] newPart,boolean isObject) {
+  public void addRawPart(byte[] newPart, boolean isObject) {
-  
+
-    }
-    else {
+    } else {
-    //hitesh: setting second bit of flags byte for client 
-    //this is not require but this makes all changes easily at client side right now
-    //just see this bit and process security header
+    // hitesh: setting second bit of flags byte for client
+    // this is not require but this makes all changes easily at client side right now
+    // just see this bit and process security header
-    getCommBuffer()
-      .putInt(this.msgType)
-      .putInt(msgLen)
-      .putInt(this.numberOfParts)
-      .putInt(this.transactionId)
-      .put(flagsByte);
+    getCommBuffer().putInt(this.msgType).putInt(msgLen).putInt(this.numberOfParts)
+        .putInt(this.transactionId).put(flagsByte);
-    if (this.sc != null ) {
-      //look types right put get etc
-     return this.sc.updateAndGetSecurityPart(); 
+    if (this.sc != null) {
+      // look types right put get etc
+      return this.sc.updateAndGetSecurityPart();
-          throw new MessageTooLargeException("Message size (" + (headerLen + totalPartLen)
-              + ") exceeds maximum integer value");
+          throw new MessageTooLargeException(
+              "Message size (" + (headerLen + totalPartLen) + ") exceeds maximum integer value");
-  private void read()
-  throws IOException {
+  private void read() throws IOException {
-    //TODO:Hitesh ??? for server changes make sure sc is not null as this class also used by client :(
+    // TODO:Hitesh ??? for server changes make sure sc is not null as this class also used by client
+    // :(
-        //System.out.println("DEBUG: fetchHeader read " + bytesRead + " bytes commBuffer=" + cb);
+        // System.out.println("DEBUG: fetchHeader read " + bytesRead + " bytes commBuffer=" + cb);
-          throw new EOFException(LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_HEADER.toLocalizedString());
+          throw new EOFException(
+              LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_HEADER
+                  .toLocalizedString());
-        bytesRead = this.is.read(cb.array(),hdr, headerLength-hdr);
+        bytesRead = this.is.read(cb.array(), hdr, headerLength - hdr);
-          throw new EOFException(LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_HEADER.toLocalizedString());
+          throw new EOFException(
+              LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_HEADER
+                  .toLocalizedString());
-  private void readHeaderAndPayload()
-  throws IOException {
+  private void readHeaderAndPayload() throws IOException {
-      throw new IOException(LocalizedStrings.Message_INVALID_MESSAGE_TYPE_0_WHILE_READING_HEADER.toLocalizedString(Integer.valueOf(type)));
+      throw new IOException(LocalizedStrings.Message_INVALID_MESSAGE_TYPE_0_WHILE_READING_HEADER
+          .toLocalizedString(Integer.valueOf(type)));
-        for (;;) {
-          this.sc.getCachedRegionHelper().checkCancelInProgress(null);
-          boolean interrupted = Thread.interrupted();
-          try {
-            if (timeToWait == 0) {
-              this.msgLimiter.acquire(1);
-            } 
-            else {
-              if (!this.msgLimiter.tryAcquire(1, timeToWait, TimeUnit.MILLISECONDS)) {
-                if (this.msgStats != null
-                    && this.msgStats instanceof CacheServerStats) {
-                  ((CacheServerStats)this.msgStats).incConnectionsTimedOut();
-                }
-                throw new IOException(LocalizedStrings.Message_OPERATION_TIMED_OUT_ON_SERVER_WAITING_ON_CONCURRENT_MESSAGE_LIMITER_AFTER_WAITING_0_MILLISECONDS.toLocalizedString(Integer.valueOf(timeToWait)));
+      for (;;) {
+        this.sc.getCachedRegionHelper().checkCancelInProgress(null);
+        boolean interrupted = Thread.interrupted();
+        try {
+          if (timeToWait == 0) {
+            this.msgLimiter.acquire(1);
+          } else {
+            if (!this.msgLimiter.tryAcquire(1, timeToWait, TimeUnit.MILLISECONDS)) {
+              if (this.msgStats != null && this.msgStats instanceof CacheServerStats) {
+                ((CacheServerStats) this.msgStats).incConnectionsTimedOut();
-            }
-            break;
-          }
-          catch (InterruptedException e) {
-            interrupted = true;
-          }
-          finally {
-            if (interrupted) {
-              Thread.currentThread().interrupt();
+              throw new IOException(
+                  LocalizedStrings.Message_OPERATION_TIMED_OUT_ON_SERVER_WAITING_ON_CONCURRENT_MESSAGE_LIMITER_AFTER_WAITING_0_MILLISECONDS
+                      .toLocalizedString(Integer.valueOf(timeToWait)));
-        } // for
+          break;
+        } catch (InterruptedException e) {
+          interrupted = true;
+        } finally {
+          if (interrupted) {
+            Thread.currentThread().interrupt();
+          }
+        }
+      } // for
-        throw new IOException(LocalizedStrings.Message_MESSAGE_SIZE_0_EXCEEDED_MAX_LIMIT_OF_1.toLocalizedString(new Object[] {Integer.valueOf(len), Integer.valueOf(this.maxIncomingMessageLength)}));
+        throw new IOException(LocalizedStrings.Message_MESSAGE_SIZE_0_EXCEEDED_MAX_LIMIT_OF_1
+            .toLocalizedString(new Object[] {Integer.valueOf(len),
+                Integer.valueOf(this.maxIncomingMessageLength)}));
-            } 
-            else {
+            } else {
-                newTimeToWait -= (int)sc.getCurrentMessageProcessingTime();
+                newTimeToWait -= (int) sc.getCurrentMessageProcessingTime();
-              if (newTimeToWait <= 0 || !this.msgLimiter.tryAcquire(1, newTimeToWait, TimeUnit.MILLISECONDS)) {
-                throw new IOException(LocalizedStrings.Message_OPERATION_TIMED_OUT_ON_SERVER_WAITING_ON_CONCURRENT_DATA_LIMITER_AFTER_WAITING_0_MILLISECONDS.toLocalizedString(timeToWait));
+              if (newTimeToWait <= 0
+                  || !this.msgLimiter.tryAcquire(1, newTimeToWait, TimeUnit.MILLISECONDS)) {
+                throw new IOException(
+                    LocalizedStrings.Message_OPERATION_TIMED_OUT_ON_SERVER_WAITING_ON_CONCURRENT_DATA_LIMITER_AFTER_WAITING_0_MILLISECONDS
+                        .toLocalizedString(timeToWait));
-            this.payloadLength = len; // makes sure payloadLength gets set now so we will release the semaphore
+            this.payloadLength = len; // makes sure payloadLength gets set now so we will release
+                                      // the semaphore
-          }
-          catch (InterruptedException e) {
+          } catch (InterruptedException e) {
-          }
-          finally {
+          } finally {
-    
+
-    bits = (byte)(bits & MESSAGE_IS_RETRY_MASK);
+    bits = (byte) (bits & MESSAGE_IS_RETRY_MASK);
-    // this.numberOfParts = numParts;  Already set in setPayloadFields via setNumberOfParts
+    // this.numberOfParts = numParts; Already set in setPayloadFields via setNumberOfParts
-  protected void readPayloadFields(final int numParts, final int len)
-  throws IOException {
-    if (len > 0 && numParts <= 0 ||
-        len <= 0 && numParts > 0) {
-      throw new IOException(LocalizedStrings.Message_PART_LENGTH_0_AND_NUMBER_OF_PARTS_1_INCONSISTENT.toLocalizedString(
-            new Object[] {Integer.valueOf(len), Integer.valueOf(numParts)}));
+  protected void readPayloadFields(final int numParts, final int len) throws IOException {
+    if (len > 0 && numParts <= 0 || len <= 0 && numParts > 0) {
+      throw new IOException(
+          LocalizedStrings.Message_PART_LENGTH_0_AND_NUMBER_OF_PARTS_1_INCONSISTENT
+              .toLocalizedString(new Object[] {Integer.valueOf(len), Integer.valueOf(numParts)}));
-      int pingParts = 10; // Some number which will not throw OOM but still be acceptable for a ping operation.
+      int pingParts = 10; // Some number which will not throw OOM but still be acceptable for a ping
+                          // operation.
-        throw new IOException("Part length ( " + numParts
-            + " ) is  inconsistent for " + MessageType.getString(msgType)
-            + " operation.");
+        throw new IOException("Part length ( " + numParts + " ) is  inconsistent for "
+            + MessageType.getString(msgType) + " operation.");
-  
+
-    }    
-    
+    }
+
-    
+
-    for (int i = 0; ((i < numParts + readSecurePart) || ((readSecurePart == 1) && (cb
-        .remaining() > 0))); i++) {
+    for (int i = 0; ((i < numParts + readSecurePart)
+        || ((readSecurePart == 1) && (cb.remaining() > 0))); i++) {
-      
-      if(i < numParts) {
+
+      if (i < numParts) {
-      }
-      else {
+      } else {
-      
+
-              throw new EOFException(LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_A_PART.toLocalizedString());
+              throw new EOFException(
+                  LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_A_PART
+                      .toLocalizedString());
-              throw new EOFException(LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_A_PART.toLocalizedString());
+              throw new EOFException(
+                  LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_A_PART
+                      .toLocalizedString());
-    }
-    else {
+    } else {
-        cb.limit(cb.position()+bytesRemaining);
+        cb.limit(cb.position() + bytesRemaining);
-          throw new EOFException(LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_PAYLOAD.toLocalizedString());
+          throw new EOFException(
+              LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_PAYLOAD
+                  .toLocalizedString());
-          throw new EOFException(LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_PAYLOAD.toLocalizedString());
+          throw new EOFException(
+              LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_PAYLOAD
+                  .toLocalizedString());
-    for (int i=0; i< partsList.length; i++){
+    for (int i = 0; i < partsList.length; i++) {
-    this.currentPart=0;
+    this.currentPart = 0;
-    for (int i = 0; i < numberOfParts; i ++) {
+    for (int i = 0; i < numberOfParts; i++) {
-  
-  public void setComms(ServerConnection sc, Socket socket, ByteBuffer bb, MessageStats msgStats) throws IOException {
+
+  public void setComms(ServerConnection sc, Socket socket, ByteBuffer bb, MessageStats msgStats)
+      throws IOException {
-      setComms(socket, null, null,  bb, msgStats);
+      setComms(socket, null, null, bb, msgStats);
-  
-  public void setComms(Socket socket, InputStream is, OutputStream os, ByteBuffer bb, MessageStats msgStats)
-    throws IOException
-  {
+
+  public void setComms(Socket socket, InputStream is, OutputStream os, ByteBuffer bb,
+      MessageStats msgStats) throws IOException {
+
+   * 
-   * Sends this message to its receiver over its
-   * setOutputStream?? output stream.
+   * Sends this message to its receiver over its setOutputStream?? output stream.
-  public void send()
-  throws IOException {
+  public void send() throws IOException {
-  
-  public void send(ServerConnection servConn)
-  throws IOException {
-    if (this.sc != servConn) throw new IllegalStateException("this.sc was not correctly set");
+
+  public void send(ServerConnection servConn) throws IOException {
+    if (this.sc != servConn)
+      throw new IllegalStateException("this.sc was not correctly set");
-  
+
-   * Sends this message to its receiver over its
-   * setOutputStream?? output stream.
+   * Sends this message to its receiver over its setOutputStream?? output stream.
-  public void send(boolean clearMessage)
-  throws IOException {
+  public void send(boolean clearMessage) throws IOException {
-   *  Populates the stats of this <code>Message</code> with information
-   *  received via its socket
+   * Populates the stats of this <code>Message</code> with information received via its socket
-  public void recv()
-  throws IOException {
+  public void recv() throws IOException {
-      synchronized(getCommBuffer()) {
+      synchronized (getCommBuffer()) {
-    }
-    else {
+    } else {
-  public void recv(ServerConnection sc, int maxMessageLength, Semaphore dataLimiter, Semaphore msgLimiter)
-  throws IOException {
+
+  public void recv(ServerConnection sc, int maxMessageLength, Semaphore dataLimiter,
+      Semaphore msgLimiter) throws IOException {

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
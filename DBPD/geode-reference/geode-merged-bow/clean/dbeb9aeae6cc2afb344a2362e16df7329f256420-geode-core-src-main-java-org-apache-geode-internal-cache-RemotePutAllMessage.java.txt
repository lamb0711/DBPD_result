Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A Replicate Region putAll message.  Meant to be sent only to
- * the peer who hosts transactional data.
+ * A Replicate Region putAll message. Meant to be sent only to the peer who hosts transactional
+ * data.
-public final class RemotePutAllMessage extends RemoteOperationMessageWithDirectReply
-  {
+public final class RemotePutAllMessage extends RemoteOperationMessageWithDirectReply {
-  
+
-  /** An additional object providing context for the operation, e.g., for BridgeServer notification */
+  /**
+   * An additional object providing context for the operation, e.g., for BridgeServer notification
+   */
-  
+
-  
+
-//  private boolean useOriginRemote;
+  // private boolean useOriginRemote;
-  
+
-  
+
-   * this is similar to send() but it selects an initialized replicate
-   * that is used to proxy the message
+   * this is similar to send() but it selects an initialized replicate that is used to proxy the
+   * message
-  public static boolean distribute(EntryEventImpl event, PutAllEntryData[] data,
-      int dataCount) {
+  public static boolean distribute(EntryEventImpl event, PutAllEntryData[] data, int dataCount) {
-    DistributedRegion r = (DistributedRegion)event.getRegion();
+    DistributedRegion r = (DistributedRegion) event.getRegion();
-    for (Iterator<InternalDistributedMember> it=replicates.iterator(); it.hasNext(); ) {
+    for (Iterator<InternalDistributedMember> it = replicates.iterator(); it.hasNext();) {
-      
+
-      
+
-      } catch(RemoteOperationException e) {
+      } catch (RemoteOperationException e) {
-          logger.trace(LogMarker.DM, "RemotePutMessage caught an unexpected exception during distribution", e);
+          logger.trace(LogMarker.DM,
+              "RemotePutMessage caught an unexpected exception during distribution", e);
-      PutAllEntryData[] putAllData, int putAllDataCount,
-      boolean useOriginRemote, int processorType, boolean possibleDuplicate, boolean skipCallbacks) {
+      PutAllEntryData[] putAllData, int putAllDataCount, boolean useOriginRemote, int processorType,
+      boolean possibleDuplicate, boolean skipCallbacks) {
-    this.processorId = p==null? 0 : p.getProcessorId();
+    this.processorId = p == null ? 0 : p.getProcessorId();
-//    this.useOriginRemote = useOriginRemote;
-//    this.processorType = processorType;
+    // this.useOriginRemote = useOriginRemote;
+    // this.processorType = processorType;
-  public RemotePutAllMessage() {
-  }
+  public RemotePutAllMessage() {}
+   * 
-   * @param r  the LocalRegion for which the put was performed
-   * @return the processor used to await acknowledgement that the update was
-   *         sent, or null to indicate that no acknowledgement will be sent
+   * 
+   * @param r the LocalRegion for which the put was performed
+   * 
+   * @return the processor used to await acknowledgement that the update was sent, or null to
+   * indicate that no acknowledgement will be sent
+   * 
-      PutAllEntryData[] putAllData, int putAllDataCount, boolean useOriginRemote,
-      int processorType, boolean possibleDuplicate) throws RemoteOperationException {
-    //Assert.assertTrue(recipient != null, "RemotePutAllMessage NULL recipient");  recipient can be null for event notifications
+      PutAllEntryData[] putAllData, int putAllDataCount, boolean useOriginRemote, int processorType,
+      boolean possibleDuplicate) throws RemoteOperationException {
+    // Assert.assertTrue(recipient != null, "RemotePutAllMessage NULL recipient"); recipient can be
+    // null for event notifications
-    RemotePutAllMessage msg = new RemotePutAllMessage(event, recipients, p,
-        putAllData, putAllDataCount, useOriginRemote, processorType, possibleDuplicate, !event.isGenerateCallbacks());
+    RemotePutAllMessage msg =
+        new RemotePutAllMessage(event, recipients, p, putAllData, putAllDataCount, useOriginRemote,
+            processorType, possibleDuplicate, !event.isGenerateCallbacks());
-      throw new RemoteOperationException(LocalizedStrings.RemotePutMessage_FAILED_SENDING_0.toLocalizedString(msg));
+      throw new RemoteOperationException(
+          LocalizedStrings.RemotePutMessage_FAILED_SENDING_0.toLocalizedString(msg));
-  
+
-  public final void fromData(DataInput in) throws IOException,
-      ClassNotFoundException {
+  public final void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    this.eventId = (EventID)DataSerializer.readObject(in);
+    this.eventId = (EventID) DataSerializer.readObject(in);
-    this.putAllDataCount = (int)InternalDataSerializer.readUnsignedVL(in);
+    this.putAllDataCount = (int) InternalDataSerializer.readUnsignedVL(in);
-      final Version version = InternalDataSerializer
-          .getVersionForDataStreamOrNull(in);
+      final Version version = InternalDataSerializer.getVersionForDataStreamOrNull(in);
-        this.putAllData[i] = new PutAllEntryData(in, this.eventId, i, version,
-            bytesIn);
+        this.putAllData[i] = new PutAllEntryData(in, this.eventId, i, version, bytesIn);
-    if (this.posDup) flags |= POS_DUP;
-    if (this.bridgeContext != null) flags |= HAS_BRIDGE_CONTEXT;
-    if (this.skipCallbacks) flags |= SKIP_CALLBACKS;
+    if (this.posDup)
+      flags |= POS_DUP;
+    if (this.bridgeContext != null)
+      flags |= HAS_BRIDGE_CONTEXT;
+    if (this.skipCallbacks)
+      flags |= SKIP_CALLBACKS;
-  protected boolean operateOnRegion(DistributionManager dm,
-      LocalRegion r,long startTime) throws RemoteOperationException {
+  protected boolean operateOnRegion(DistributionManager dm, LocalRegion r, long startTime)
+      throws RemoteOperationException {
-    }
-    catch (RemoteOperationException e) {
-      sendReply(getSender(), getProcessorId(), dm, 
-          new ReplyException(e), r, startTime);
+    } catch (RemoteOperationException e) {
+      sendReply(getSender(), getProcessorId(), dm, new ReplyException(e), r, startTime);
-   * This method is called by both operateOnLocalRegion() when processing a remote msg
-   * or by sendMsgByBucket() when processing a msg targeted to local Jvm. 
-   * LocalRegion Note: It is very important that this message does NOT
-   * cause any deadlocks as the sender will wait indefinitely for the
-   * acknowledgment
-   * @param r partitioned region
-   *        eventSender the endpoint server who received request from client
+   * This method is called by both operateOnLocalRegion() when processing a remote msg or by
+   * sendMsgByBucket() when processing a msg targeted to local Jvm. LocalRegion Note: It is very
+   * important that this message does NOT cause any deadlocks as the sender will wait indefinitely
+   * for the acknowledgment
+   * 
+   * @param r partitioned region eventSender the endpoint server who received request from client
-  public final boolean doLocalPutAll(final LocalRegion r, final InternalDistributedMember eventSender, long lastModified)
-    throws EntryExistsException, RemoteOperationException {
-    final DistributedRegion dr = (DistributedRegion)r;
-    
+  public final boolean doLocalPutAll(final LocalRegion r,
+      final InternalDistributedMember eventSender, long lastModified)
+      throws EntryExistsException, RemoteOperationException {
+    final DistributedRegion dr = (DistributedRegion) r;
+
-    @Released EntryEventImpl baseEvent = EntryEventImpl.create(
-        r, Operation.PUTALL_CREATE,
-        null, null, this.callbackArg, false, eventSender, !skipCallbacks);
+    @Released
+    EntryEventImpl baseEvent = EntryEventImpl.create(r, Operation.PUTALL_CREATE, null, null,
+        this.callbackArg, false, eventSender, !skipCallbacks);
-    baseEvent.setCausedByMessage(this);
-    
-    // set baseEventId to the first entry's event id. We need the thread id for DACE
-    baseEvent.setEventId(this.eventId);
-    if (this.bridgeContext != null) {
-      baseEvent.setContext(this.bridgeContext);
-    }
-    baseEvent.setPossibleDuplicate(this.posDup);
-    if (logger.isDebugEnabled()) {
-      logger.debug("RemotePutAllMessage.doLocalPutAll: eventSender is {}, baseEvent is {}, msg is {}",
-          eventSender, baseEvent, this);
-    }
-    final DistributedPutAllOperation dpao = new DistributedPutAllOperation(baseEvent, putAllDataCount, false);
-    try {
-    final VersionedObjectList versions = new VersionedObjectList(putAllDataCount, true, dr.concurrencyChecksEnabled);
-    dr.syncBulkOp(new Runnable() {
-      @SuppressWarnings("synthetic-access")
-      public void run() {
-//        final boolean requiresRegionContext = dr.keyRequiresRegionContext();
-        InternalDistributedMember myId = r.getDistributionManager().getDistributionManagerId();
-        for (int i = 0; i < putAllDataCount; ++i) {
-          @Released EntryEventImpl ev = PutAllPRMessage.getEventFromEntry(r, myId, eventSender, i, putAllData, false, bridgeContext, posDup, !skipCallbacks);
-          try {
-          ev.setPutAllOperation(dpao);
-          if (logger.isDebugEnabled()) {
-            logger.debug("invoking basicPut with {}", ev);
-          }
-          if (dr.basicPut(ev, false, false, null, false)) {
-            putAllData[i].versionTag = ev.getVersionTag();
-            versions.addKeyAndVersion(putAllData[i].key, ev.getVersionTag());
-          }
-          } finally {
-            ev.release();
-          }
-        }
+      baseEvent.setCausedByMessage(this);
+
+      // set baseEventId to the first entry's event id. We need the thread id for DACE
+      baseEvent.setEventId(this.eventId);
+      if (this.bridgeContext != null) {
+        baseEvent.setContext(this.bridgeContext);
-    }, baseEvent.getEventId());
-    if(getTXUniqId()!=TXManagerImpl.NOTX || dr.getConcurrencyChecksEnabled()) {
-    	dr.getDataView().postPutAll(dpao, versions, dr);
-    }
-    PutAllReplyMessage.send(getSender(), this.processorId, 
-        getReplySender(r.getDistributionManager()), versions, this.putAllData, this.putAllDataCount);
-    return false;
-    } finally {
-      dpao.freeOffHeapResources();
-    }
+      baseEvent.setPossibleDuplicate(this.posDup);
+      if (logger.isDebugEnabled()) {
+        logger.debug(
+            "RemotePutAllMessage.doLocalPutAll: eventSender is {}, baseEvent is {}, msg is {}",
+            eventSender, baseEvent, this);
+      }
+      final DistributedPutAllOperation dpao =
+          new DistributedPutAllOperation(baseEvent, putAllDataCount, false);
+      try {
+        final VersionedObjectList versions =
+            new VersionedObjectList(putAllDataCount, true, dr.concurrencyChecksEnabled);
+        dr.syncBulkOp(new Runnable() {
+          @SuppressWarnings("synthetic-access")
+          public void run() {
+            // final boolean requiresRegionContext = dr.keyRequiresRegionContext();
+            InternalDistributedMember myId = r.getDistributionManager().getDistributionManagerId();
+            for (int i = 0; i < putAllDataCount; ++i) {
+              @Released
+              EntryEventImpl ev = PutAllPRMessage.getEventFromEntry(r, myId, eventSender, i,
+                  putAllData, false, bridgeContext, posDup, !skipCallbacks);
+              try {
+                ev.setPutAllOperation(dpao);
+                if (logger.isDebugEnabled()) {
+                  logger.debug("invoking basicPut with {}", ev);
+                }
+                if (dr.basicPut(ev, false, false, null, false)) {
+                  putAllData[i].versionTag = ev.getVersionTag();
+                  versions.addKeyAndVersion(putAllData[i].key, ev.getVersionTag());
+                }
+              } finally {
+                ev.release();
+              }
+            }
+          }
+        }, baseEvent.getEventId());
+        if (getTXUniqId() != TXManagerImpl.NOTX || dr.getConcurrencyChecksEnabled()) {
+          dr.getDataView().postPutAll(dpao, versions, dr);
+        }
+        PutAllReplyMessage.send(getSender(), this.processorId,
+            getReplySender(r.getDistributionManager()), versions, this.putAllData,
+            this.putAllDataCount);
+        return false;
+      } finally {
+        dpao.freeOffHeapResources();
+      }
-  
+
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex, LocalRegion r, long startTime) {
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+      LocalRegion r, long startTime) {
-  protected final void appendFields(StringBuffer buff)
-  {
+  protected final void appendFields(StringBuffer buff) {
-    for (int i=0; i<putAllDataCount; i++) {
-      buff.append("; entry"+i+":").append(putAllData[i]==null? "null" : putAllData[i].getKey());
+    for (int i = 0; i < putAllDataCount; i++) {
+      buff.append("; entry" + i + ":")
+          .append(putAllData[i] == null ? "null" : putAllData[i].getKey());
-  
+
-    //private PutAllResponseData[] responseData;
+    // private PutAllResponseData[] responseData;
-    private PutAllReplyMessage(int processorId, VersionedObjectList versionList, PutAllEntryData[] putAllData, int putAllCount)  {
+    private PutAllReplyMessage(int processorId, VersionedObjectList versionList,
+        PutAllEntryData[] putAllData, int putAllCount) {
-    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm, VersionedObjectList versions,
-        PutAllEntryData[] putAllData, int putAllDataCount)  {
+    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm,
+        VersionedObjectList versions, PutAllEntryData[] putAllData, int putAllDataCount) {
-      PutAllReplyMessage m = new PutAllReplyMessage(processorId, versions, putAllData, putAllDataCount);
+      PutAllReplyMessage m =
+          new PutAllReplyMessage(processorId, versions, putAllData, putAllDataCount);
-     * Processes this message.  This method is invoked by the receiver
-     * of the message.
+     * Processes this message. This method is invoked by the receiver of the message.
+     * 
-        PutAllResponse processor = (PutAllResponse)rp;
+        PutAllResponse processor = (PutAllResponse) rp;
-      dm.getStats().incReplyMessageTime(NanoTimer.getTime()-startTime);
+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);
-    public PutAllReplyMessage() {
-    }
+    public PutAllReplyMessage() {}
-    public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      this.versions = (VersionedObjectList)DataSerializer.readObject(in); 
+      this.versions = (VersionedObjectList) DataSerializer.readObject(in);
-      sb.append("PutAllReplyMessage ")
-        .append(" processorid=").append(this.processorId)
-        .append(" returning versionTags=").append(this.versions);
+      sb.append("PutAllReplyMessage ").append(" processorid=").append(this.processorId)
+          .append(" returning versionTags=").append(this.versions);
-  
+
-    //private volatile PutAllResponseData[] returnValue;
+    // private volatile PutAllResponseData[] returnValue;
-    
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66
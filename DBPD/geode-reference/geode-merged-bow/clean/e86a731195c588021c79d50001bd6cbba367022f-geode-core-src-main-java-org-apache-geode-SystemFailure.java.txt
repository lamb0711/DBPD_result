Merge branch 'release/1.3.0'

-/**
- * 
- */
+import org.apache.geode.internal.ExitCode;
-  private static volatile Runnable failureAction = new Runnable() {
-    public void run() {
-      System.err.println(JVM_CORRUPTION);
-      failure.printStackTrace();
-    }
+  private static volatile Runnable failureAction = () -> {
+    System.err.println(JVM_CORRUPTION);
+    failure.printStackTrace();
-  // merge42180: Added this method while merging 42180. It should have already be here through
-  // different merges or will come later
-    // all VirtualMachineErrors are not fatal to the JVM, in particular
-    // StackOverflowError is not
-      // If the watchdog is correctly written, this will never get executed.
-      // However, there's no reason for us not to eat our own dog food
-      // (har, har) -- see the javadoc above.
-        // Uhhh...if the watchdog is running, we *know* there's some
-        // sort of serious error, no need to check for it here.
-      // Our work is done, don't restart
-      watchDog = new Thread(tg, new Runnable() {
-        public void run() {
-          runWatchDog();
-        }
-      }, "SystemFailure WatchDog");
+      watchDog = new Thread(tg, SystemFailure::runWatchDog, "SystemFailure WatchDog");
-      // Uhhh...are we shutting down?
+      // Determine if we're shutting down...
-          if (msg.indexOf("Shutdown in progress") >= 0) {
+          if (msg.contains("Shutdown in progress")) {
-      // In any event, we're toast
-        // Poke nose in the air, take a sniff...
+
+        // Perform watchdog sentinel duties.
-          // early out, for testing
-          // Tail wag. Go back to sleep.
-        // BOW WOW WOW WOW WOW! Corrupted system.
-        // If any of the following fail, we will go back to sleep and
-        // retry.
-            continue; // go back to sleep
+            continue;
-              continue; // go back to sleep
+              continue;
-          logWarning(WATCHDOG_NAME,
-              // No "+" in this long message, we're out of memory!
-              CALLING_SYSTEM_EXIT, exitExcuse);
+          logWarning(WATCHDOG_NAME, CALLING_SYSTEM_EXIT, exitExcuse);
-          System.exit(1);
+          ExitCode.FATAL.doSystemExit();
-        // Our job here is done
-        // We *never* give up. NEVER EVER!
-    } // for
+    }
-   * Well, if you're gonna have a watchdog, why not a watch CAT????
-   * 
-  static long minimumMemoryThreshold =
-      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "SystemFailure.chronic_memory_threshold",
-          1048576).longValue();
+  static long minimumMemoryThreshold = Long.getLong(
+      DistributionConfig.GEMFIRE_PREFIX + "SystemFailure.chronic_memory_threshold", 1048576);
-      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "SystemFailure.MEMORY_POLL_INTERVAL", 1)
-          .longValue();
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "SystemFailure.MEMORY_POLL_INTERVAL", 1);
-  static final public long MEMORY_MAX_WAIT = Long
-      .getLong(DistributionConfig.GEMFIRE_PREFIX + "SystemFailure.MEMORY_MAX_WAIT", 15).longValue();
+  static final public long MEMORY_MAX_WAIT =
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "SystemFailure.MEMORY_MAX_WAIT", 15);
-      // no point!
-      proctor = new Thread(tg, new Runnable() {
-        public void run() {
-          runProctor();
-        }
-      }, "SystemFailure Proctor");
+      proctor = new Thread(tg, SystemFailure::runProctor, "SystemFailure Proctor");
-    Thread proctorSnapshot = null;
+    Thread proctorSnapshot;
-   * This is the run loop for the proctor thread (formally known as the "watchcat" (grin)
+   * This is the run loop for the proctor thread
-    // If it does, the proctor will never do its job...
-    // Allocate this error in advance, since it's too late once
-    // it's been detected!
+    // Allocate this error in advance, since it's too late once it's been detected!
-    // Catenation, but should be OK when starting up
-        // *** catnap...
-        // *** Twitch ear, take a bath...
-          // it's all over, we're late
-          notifyWatchDog(); // wake the dog, just in case
+          notifyWatchDog();
-        // *** Sit up, stretch...
-          // We haven't finished growing the heap, so no worries...yet
-            // This message has catenation, we don't want this in
-            // production code :-)
-          // Don't get too impatient if the heap just now grew
-          lastTotalMemory = totalMemory; // now we're maxed
-          firstStarveTime = NEVER_STARVED; // reset the clock
+          lastTotalMemory = totalMemory;
+          firstStarveTime = NEVER_STARVED;
-        lastTotalMemory = totalMemory; // make a note of this
+        lastTotalMemory = totalMemory;
-        // *** Hey, is that the food bowl?
-
-        // At this point, freeMemory really indicates how much
-        // trouble we're in.
-          /*
-           * This is to workaround X bug #41821 in JRockit. Often, Jrockit returns 0 from
-           * Runtime.getRuntime().freeMemory() Allocating this one object and calling again seems to
-           * workaround the problem.
-           */
+          // This is to workaround X bug #41821 in JRockit. Often, Jrockit returns 0 from
+          // Runtime.getRuntime().freeMemory() Allocating this one object and calling again seems to
+          // workaround the problem.
-        if (freeMemory >= curThreshold /* enough memory */
-            || curThreshold == 0 /* disabled */) {
+        if (freeMemory >= curThreshold || curThreshold == 0) {
-            // This message has catenation, we don't want this in
-            // production code :-)
-        // Memory is low
-        // *** Leap to feet, nose down, tail switching...
+        // Memory is low
-          // first sighting
-            // Catenation in this message, don't put in production
-          System.gc(); // at least TRY...
+          System.gc(); // Attempt to free memory and avoid overflow
-        // *** squirm, wait for the right moment...wait...wait...
-          // Very recent; problem may correct itself.
-            // catenation
-        // *** Meow! Meow! MEOWWWW!!!!!
-
-        // Like any smart cat, let the Dog do all the work.
-        return; // we're done!
+        return;
-        // We *never* give up. NEVER EVER!
-    } // for
+    }
-    // This method was called to basically load this class
-    // and invoke its static initializers. Now that we don't
-    // use statics to start the threads all we need to do is
-    // call startThreads. The watchdog thread will call basicLoadEmergencyClasses.
-    // Make the cache (more) useless and inaccessible...
-    // Arcane strange DS's exist in this class:
-    // If memory was the problem, make an explicit attempt at
-    // this point to clean up.
-
-    System.gc(); // This will fail if we're out of memory?/
+    // If memory was the problem, make an explicit attempt at this point to clean up.
+    System.gc();
-    // Do not return normally...
-    startWatchDog(); // just in case
+    startWatchDog();
-    // created (OutOfMemoryError), and no stack frames are created
-    // (StackOverflowError). There is a slight chance that the
-    // very first error may get overwritten, but this avoids the
-    // potential of object creation via a fat lock
-      firstStarveTime = NEVER_STARVED; // reset
+      firstStarveTime = NEVER_STARVED;
-    startProctor(); // just in case
+    startProctor();
-  // /**
-  // * For use by GemStone Quality Assurance Only
-  // *
-  // * @deprecated TODO remove this
-  // */
-  // public static void reset() {
-  // System.gc();
-  // logWarning("DJP", "do not commit SystemFailure#reset", null);
-  // failure = null;
-  // failureAction = new Runnable() {
-  // public void run() {
-  // System.err.println("(SystemFailure) JVM corruption has been detected!");
-  // failure.printStackTrace();
-  // }
-  // };
-  // gemfireCloseCompleted = false;
-  // failureActionCompleted = false;
-  // synchronized (failureSync) {
-  // if (watchDog != null) {
-  // watchDog.interrupt();
-  // }
-  // watchDog = null;
-  // if (watchCat != null) {
-  // watchCat.interrupt();
-  // }
-  // watchCat = null;
-  // }
-  //
-  // startWatchDog();
-  // startWatchCat();
-  // }
-
-    // As far as I can tell, this code path doesn't allocate
-    // any objects!!!!
-    // if (PREFER_STDERR) {
-    // return logStdErr("warning", name, s, t);
-    // }
-    // try {
-    // log.warning(name + ": " + s, t);
-    // return true;
-    // }
-    // catch (Throwable t2) {
-    // return logStdErr("warning", name, s, t);
-    // }
-    // if (PREFER_STDERR) {
-    // logStdErr("info", name, s, null);
-    // return;
-    // }
-    // try {
-    // log.info(name + ": " + s);
-    // }
-    // catch (Throwable t) {
-    // logStdErr("info", name, s, t);
-    // }
-    // if (DEBUG && PREFER_STDERR) {
-    // logStdErr("fine", name, s, null);
-    // return;
-    // }
-    // try {
-    // log.fine(name + ": " + s);
-    // }
-    // catch (Throwable t) {
-    // if (DEBUG) {
-    // logStdErr("fine", name, s, null);
-    // }
-    // }

INS26 INS40 INS86 MOV32 MOV32 MOV32 MOV8 MOV43 UPD66 INS90 MOV43 INS90 INS42 INS42 INS42 INS42 INS32 INS40 UPD42 MOV42 UPD42 MOV42 MOV45 DEL29 DEL42 DEL43 DEL83 DEL39 DEL42 DEL31 DEL1 DEL14 DEL42 DEL43 DEL83 DEL39 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL1 DEL14 DEL32 DEL34 DEL27 DEL42 DEL34 DEL66 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL83 DEL39 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL1 DEL14 DEL33
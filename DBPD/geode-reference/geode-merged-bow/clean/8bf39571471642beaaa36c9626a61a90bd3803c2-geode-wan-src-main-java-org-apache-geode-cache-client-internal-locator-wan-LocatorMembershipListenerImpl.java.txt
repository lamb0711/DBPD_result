Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  private ConcurrentMap<Integer, Set<DistributionLocatorId>> allLocatorsInfo = new ConcurrentHashMap<Integer, Set<DistributionLocatorId>>();
-  
-  private ConcurrentMap<Integer, Set<String>> allServerLocatorsInfo = new ConcurrentHashMap<Integer, Set<String>>();
-  
+  private ConcurrentMap<Integer, Set<DistributionLocatorId>> allLocatorsInfo =
+      new ConcurrentHashMap<Integer, Set<DistributionLocatorId>>();
+
+  private ConcurrentMap<Integer, Set<String>> allServerLocatorsInfo =
+      new ConcurrentHashMap<Integer, Set<String>>();
+
-  
+
-  
+
-  
+
-  
+
-  
-  public void setPort(int port){
+
+  public void setPort(int port) {
-  
+
-   * When the new locator is added to remote locator metadata, inform all other
-   * locators in remote locator metadata about the new locator so that they can
-   * update their remote locator metadata.
+   * When the new locator is added to remote locator metadata, inform all other locators in remote
+   * locator metadata about the new locator so that they can update their remote locator metadata.
-  
-  public void locatorJoined(final int distributedSystemId,
-      final DistributionLocatorId locator,
+
+  public void locatorJoined(final int distributedSystemId, final DistributionLocatorId locator,
-        
+
-          localLocatorId = new DistributionLocatorId(port, config
-              .getBindAddress());
-        }
-        else {
+          localLocatorId = new DistributionLocatorId(port, config.getBindAddress());
+        } else {
-        
-        Map<Integer, Set<DistributionLocatorId>> localCopy = new HashMap<Integer, Set<DistributionLocatorId>>();
-        for(Map.Entry<Integer, Set<DistributionLocatorId>> entry : remoteLocators.entrySet()){
-          Set<DistributionLocatorId> value = new CopyOnWriteHashSet<DistributionLocatorId>(entry.getValue());
+
+        Map<Integer, Set<DistributionLocatorId>> localCopy =
+            new HashMap<Integer, Set<DistributionLocatorId>>();
+        for (Map.Entry<Integer, Set<DistributionLocatorId>> entry : remoteLocators.entrySet()) {
+          Set<DistributionLocatorId> value =
+              new CopyOnWriteHashSet<DistributionLocatorId>(entry.getValue());
-        }  
-        for(Map.Entry<Integer, Set<DistributionLocatorId>> entry : localCopy.entrySet()){
-          for(DistributionLocatorId removeLocId : locatorsToRemove){
-            if(entry.getValue().contains(removeLocId)){
+        }
+        for (Map.Entry<Integer, Set<DistributionLocatorId>> entry : localCopy.entrySet()) {
+          for (DistributionLocatorId removeLocId : locatorsToRemove) {
+            if (entry.getValue().contains(removeLocId)) {
-                  new LocatorJoinMessage(distributedSystemId, locator, localLocatorId, ""), 1000, false);
-            }
-            catch (Exception e) {
+                  new LocatorJoinMessage(distributedSystemId, locator, localLocatorId, ""), 1000,
+                  false);
+            } catch (Exception e) {
-                logger.debug(LocalizedMessage.create(LocalizedStrings.LOCATOR_MEMBERSHIP_LISTENER_COULD_NOT_EXCHANGE_LOCATOR_INFORMATION_0_1_WIHT_2_3, 
-                    new Object[] { locator.getHost(), locator.getPort(), value.getHost(), value.getPort() }));
+                logger.debug(LocalizedMessage.create(
+                    LocalizedStrings.LOCATOR_MEMBERSHIP_LISTENER_COULD_NOT_EXCHANGE_LOCATOR_INFORMATION_0_1_WIHT_2_3,
+                    new Object[] {locator.getHost(), locator.getPort(), value.getHost(),
+                        value.getPort()}));
-            }
-            catch (Exception e) {
+            } catch (Exception e) {
-                logger.debug(LocalizedMessage.create(LocalizedStrings.LOCATOR_MEMBERSHIP_LISTENER_COULD_NOT_EXCHANGE_LOCATOR_INFORMATION_0_1_WIHT_2_3,
-                    new Object[] { value.getHost(), value.getPort(), locator.getHost(), locator.getPort() }));
+                logger.debug(LocalizedMessage.create(
+                    LocalizedStrings.LOCATOR_MEMBERSHIP_LISTENER_COULD_NOT_EXCHANGE_LOCATOR_INFORMATION_0_1_WIHT_2_3,
+                    new Object[] {value.getHost(), value.getPort(), locator.getHost(),
+                        locator.getPort()}));
-      response = updateAllLocatorInfo((RemoteLocatorJoinRequest)request);
-    }
-    else if (request instanceof LocatorJoinMessage) {
-      response = informAboutRemoteLocators((LocatorJoinMessage)request);
-    }
-    else if (request instanceof RemoteLocatorPingRequest) {
-      response = getPingResponse((RemoteLocatorPingRequest)request);
-    }
-    else if (request instanceof RemoteLocatorRequest) {
-      response = getRemoteLocators((RemoteLocatorRequest)request);
+      response = updateAllLocatorInfo((RemoteLocatorJoinRequest) request);
+    } else if (request instanceof LocatorJoinMessage) {
+      response = informAboutRemoteLocators((LocatorJoinMessage) request);
+    } else if (request instanceof RemoteLocatorPingRequest) {
+      response = getPingResponse((RemoteLocatorPingRequest) request);
+    } else if (request instanceof RemoteLocatorRequest) {
+      response = getRemoteLocators((RemoteLocatorRequest) request);
-  
+
-   * A locator from the request is checked against the existing remote locator
-   * metadata. If it is not available then added to existing remote locator
-   * metadata and LocatorMembershipListener is invoked to inform about the
-   * this newly added locator to all other locators available in remote locator
-   * metadata. As a response, remote locator metadata is sent.
+   * A locator from the request is checked against the existing remote locator metadata. If it is
+   * not available then added to existing remote locator metadata and LocatorMembershipListener is
+   * invoked to inform about the this newly added locator to all other locators available in remote
+   * locator metadata. As a response, remote locator metadata is sent.
-  
+
-   return new RemoteLocatorPingResponse();
+    return new RemoteLocatorPingResponse();
-  
-  private Object informAboutRemoteLocators(LocatorJoinMessage request){
+
+  private Object informAboutRemoteLocators(LocatorJoinMessage request) {
-//    synchronized (locatorJoinObject) {
-//      if (locatorJoinMessages.contains(request)) {
-//        return null;
-//      }
-//      locatorJoinMessages.add(request);  
-//    }
+    // synchronized (locatorJoinObject) {
+    // if (locatorJoinMessages.contains(request)) {
+    // return null;
+    // }
+    // locatorJoinMessages.add(request);
+    // }
-  
+
-  
+
-  public ConcurrentMap<Integer,Set<DistributionLocatorId>> getAllLocatorsInfo() {
+  public ConcurrentMap<Integer, Set<DistributionLocatorId>> getAllLocatorsInfo() {
-  
-  public ConcurrentMap<Integer,Set<String>> getAllServerLocatorsInfo() {
+
+  public ConcurrentMap<Integer, Set<String>> getAllServerLocatorsInfo() {
-  
-  public void clearLocatorInfo(){
+
+  public void clearLocatorInfo() {

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66
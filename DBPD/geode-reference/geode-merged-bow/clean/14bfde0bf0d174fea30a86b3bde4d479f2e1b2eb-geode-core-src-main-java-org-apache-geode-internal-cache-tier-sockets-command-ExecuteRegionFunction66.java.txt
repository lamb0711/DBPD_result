Merge branch 'release/1.8.0'

-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
-  private ExecuteRegionFunction66() {}
+  ExecuteRegionFunction66() {}
-    int removedNodesSize = 0;
-    int filterSize = 0, partNumber = 0;
-    CachedRegionHelper crHelper = serverConnection.getCachedRegionHelper();
+    int partNumber = 0;
-      if (part != null) {
-        Object obj = part.getObject();
-        if (obj instanceof MemberMappedArgument) {
-          memberMappedArg = (MemberMappedArgument) obj;
-        }
-      }
+      memberMappedArg = extractMemberMappedArgument(part);
+
-      filterSize = clientMessage.getPart(6).getInt();
-      if (filterSize != 0) {
-        filter = new HashSet<Object>();
-        partNumber = 7;
-        for (int i = 0; i < filterSize; i++) {
-          filter.add(clientMessage.getPart(partNumber + i).getStringOrObject());
-        }
-      }
+      int filterSize = clientMessage.getPart(6).getInt();
+      filter = populateFilters(clientMessage, filterSize);
-      removedNodesSize = clientMessage.getPart(partNumber).getInt();
-      if (removedNodesSize != 0) {
-        removedNodesSet = new HashSet<Object>();
-        partNumber = partNumber + 1;
-
-        for (int i = 0; i < removedNodesSize; i++) {
-          removedNodesSet.add(clientMessage.getPart(partNumber + i).getStringOrObject());
-        }
-      }
+      int removedNodesSize = clientMessage.getPart(partNumber).getInt();
+      removedNodesSet =
+          populateRemovedNodes(clientMessage, removedNodesSize, partNumber);
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.ExecuteRegionFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0,
-          function), exception);
+      logger.warn(String.format("Exception on server while executing function : %s",
+          function),
+          exception);
-      String message = null;
-      if (function == null) {
-        message =
-            LocalizedStrings.ExecuteRegionFunction_THE_INPUT_0_FOR_THE_EXECUTE_FUNCTION_REQUEST_IS_NULL
-                .toLocalizedString("function");
-      }
-      if (regionName == null) {
-        message =
-            LocalizedStrings.ExecuteRegionFunction_THE_INPUT_0_FOR_THE_EXECUTE_FUNCTION_REQUEST_IS_NULL
-                .toLocalizedString("region");
-      }
+      String message = generateNullArgumentMessage(regionName, function);
+    CachedRegionHelper crHelper = serverConnection.getCachedRegionHelper();
-          LocalizedStrings.ExecuteRegionFunction_THE_REGION_NAMED_0_WAS_NOT_FOUND_DURING_EXECUTE_FUNCTION_REQUEST
-              .toLocalizedString(regionName);
+          String.format("The region named %s was not found during execute Function request.",
+              regionName);
-        if (functionObject == null) {
-          String message =
-              LocalizedStrings.ExecuteRegionFunction_THE_FUNCTION_0_HAS_NOT_BEEN_REGISTERED
-                  .toLocalizedString(function);
-          logger.warn("{}: {}", serverConnection.getName(), message);
-          sendError(hasResult, clientMessage, message, serverConnection);
+        if (!validateFunctionObject(clientMessage, serverConnection, function, hasResult,
+            functionState,
+            functionObject)) {
-        } else {
-          byte functionStateOnServerSide = AbstractExecution.getFunctionState(functionObject.isHA(),
-              functionObject.hasResult(), functionObject.optimizeForWrite());
-          if (logger.isDebugEnabled()) {
-            logger.debug("Function State on server side: {} on client: {}",
-                functionStateOnServerSide, functionState);
-          }
-          if (functionStateOnServerSide != functionState) {
-            String message =
-                LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH_CLIENT_SERVER
-                    .toLocalizedString(function);
-            logger.warn("{}: {}", serverConnection.getName(), message);
-            sendError(hasResult, clientMessage, message, serverConnection);
-            return;
-          }
-      functionObject.getRequiredPermissions(regionName).forEach(securityService::authorize);
-      AuthorizeRequest authzRequest = serverConnection.getAuthzRequest();
-      final String functionName = functionObject.getId();
-      final String regionPath = region.getFullPath();
-      ExecuteFunctionOperationContext executeContext = null;
-      if (authzRequest != null) {
-        executeContext = authzRequest.executeFunctionAuthorize(functionName, regionPath, filter,
-            args, functionObject.optimizeForWrite());
-      }
+      functionObject.getRequiredPermissions(regionName, args).forEach(securityService::authorize);
+      ExecuteFunctionOperationContext executeContext =
+          getAuthorizedExecuteFunctionOperationContext(args, filter,
+              functionObject.optimizeForWrite(), serverConnection.getAuthzRequest(),
+              functionObject.getId(), region.getFullPath());
-      // Construct execution
-      AbstractExecution execution = (AbstractExecution) FunctionService.onRegion(region);
+
+      AbstractExecution execution =
+          createExecution(args, memberMappedArg, isBucketsAsFilter, filter,
+              removedNodesSet,
+              region, resultSender);
-        execution = new PartitionedRegionFunctionExecutor((PartitionedRegion) region, filter, args,
-            memberMappedArg, resultSender, removedNodesSet, isBucketsAsFilter);
-      } else {
-        execution = new DistributedRegionFunctionExecutor((DistributedRegion) region, filter, args,
-            memberMappedArg, resultSender);
-        if (function instanceof String) {
-          switch (functionState) {
-            case AbstractExecution.NO_HA_HASRESULT_NO_OPTIMIZEFORWRITE:
-              execution.execute((String) function).getResult();
-              break;
-            case AbstractExecution.HA_HASRESULT_NO_OPTIMIZEFORWRITE:
-              execution.execute((String) function).getResult();
-              break;
-            case AbstractExecution.HA_HASRESULT_OPTIMIZEFORWRITE:
-              execution.execute((String) function).getResult();
-              break;
-            case AbstractExecution.NO_HA_HASRESULT_OPTIMIZEFORWRITE:
-              execution.execute((String) function).getResult();
-              break;
-          }
-        } else {
-          execution.execute(functionObject).getResult();
-        }
+        executeFunctionWithResult(function, functionState, functionObject, execution);
-        if (function instanceof String) {
-          switch (functionState) {
-            case AbstractExecution.NO_HA_NO_HASRESULT_NO_OPTIMIZEFORWRITE:
-              execution.execute((String) function);
-              break;
-            case AbstractExecution.NO_HA_NO_HASRESULT_OPTIMIZEFORWRITE:
-              execution.execute((String) function);
-              break;
-          }
-        } else {
-          execution.execute(functionObject);
-        }
+        executeFunctionNoResult(function, functionState, functionObject, execution);
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.ExecuteRegionFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0,
-          function), ioe);
-      final String message = LocalizedStrings.ExecuteRegionFunction_SERVER_COULD_NOT_SEND_THE_REPLY
-          .toLocalizedString();
+      logger.warn(String.format("Exception on server while executing function : %s",
+          function),
+          ioe);
+      final String message = "Server could not send the reply";
-        if (cause instanceof InternalFunctionInvocationTargetException) {
-          // Fix for #44709: User should not be aware of
-          // InternalFunctionInvocationTargetException. No instance of
-          // InternalFunctionInvocationTargetException is giving useful
-          // information to user to take any corrective action hence logging
-          // this at fine level logging
-          // 1> When bucket is moved
-          // 2> Incase of HA FucntionInvocationTargetException thrown. Since
-          // it is HA, fucntion will be reexecuted on right node
-          // 3> Multiple target nodes found for single hop operation
-          // 4> in case of HA member departed
-          if (logger.isDebugEnabled()) {
-            logger.debug(LocalizedMessage.create(
-                LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0,
-                new Object[] {function}), fe);
-          }
-        } else if (functionObject.isHA()) {
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.ExecuteRegionFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0,
-              function + " :" + message));
-        } else {
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.ExecuteRegionFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0,
-              function), fe);
-        }
-
+        logFunctionExceptionCause(function, functionObject, fe, message, cause);
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.ExecuteRegionFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0,
-              function), fe);
+          logger.warn(String.format("Exception on server while executing function : %s",
+              function),
+              fe);
-
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.ExecuteRegionFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0,
-            function), e);
+        logger.warn(String.format("Exception on server while executing function : %s",
+            function),
+            e);
+  void logFunctionExceptionCause(Object function, Function<?> functionObject,
+      FunctionException fe, String message, Object cause) {
+    if (cause instanceof InternalFunctionInvocationTargetException) {
+      // Fix for #44709: User should not be aware of
+      // InternalFunctionInvocationTargetException. No instance of
+      // InternalFunctionInvocationTargetException is giving useful
+      // information to user to take any corrective action hence logging
+      // this at fine level logging
+      // 1> When bucket is moved
+      // 2> Incase of HA FucntionInvocationTargetException thrown. Since
+      // it is HA, fucntion will be reexecuted on right node
+      // 3> Multiple target nodes found for single hop operation
+      // 4> in case of HA member departed
+      if (logger.isDebugEnabled()) {
+        logger.debug(String.format("Exception on server while executing function: %s",
+            new Object[] {function}),
+            fe);
+      }
+    } else if (functionObject.isHA()) {
+      logger.warn("Exception on server while executing function : {}",
+          function + " :" + message);
+    } else {
+      logger.warn(String.format("Exception on server while executing function : %s",
+          function),
+          fe);
+    }
+  }
+
+  AbstractExecution createExecution(Object args, MemberMappedArgument memberMappedArg,
+      boolean isBucketsAsFilter, Set<Object> filter,
+      Set<Object> removedNodesSet, Region region,
+      ServerToClientFunctionResultSender resultSender) {
+
+    AbstractExecution execution = (AbstractExecution) FunctionService.onRegion(region);
+    if (execution instanceof PartitionedRegionFunctionExecutor) {
+      execution = new PartitionedRegionFunctionExecutor((PartitionedRegion) region, filter, args,
+          memberMappedArg, resultSender, removedNodesSet, isBucketsAsFilter);
+    } else {
+      execution = new DistributedRegionFunctionExecutor((DistributedRegion) region, filter, args,
+          memberMappedArg, resultSender);
+    }
+    return execution;
+  }
+
+  boolean validateFunctionObject(Message clientMessage, ServerConnection serverConnection,
+      Object function, byte hasResult, byte functionState,
+      Function<?> functionObject) throws IOException {
+    if (functionObject == null) {
+      String message =
+          String.format("The function, %s, has not been registered",
+              function);
+      logger.warn("{}: {}", serverConnection.getName(), message);
+      sendError(hasResult, clientMessage, message, serverConnection);
+      return false;
+    } else {
+      byte functionStateOnServerSide = AbstractExecution.getFunctionState(functionObject.isHA(),
+          functionObject.hasResult(), functionObject.optimizeForWrite());
+      if (logger.isDebugEnabled()) {
+        logger.debug("Function State on server side: {} on client: {}",
+            functionStateOnServerSide, functionState);
+      }
+      if (functionStateOnServerSide != functionState) {
+        String message =
+            String.format("Function attributes at client and server don't match: %s",
+                function);
+        logger.warn("{}: {}", serverConnection.getName(), message);
+        sendError(hasResult, clientMessage, message, serverConnection);
+        return false;
+      }
+    }
+    return true;
+  }
+
+  String generateNullArgumentMessage(String regionName, Object function) {
+    String message = null;
+    if (regionName == null) {
+      message =
+          String.format("The input region for the execute function request is null");
+    } else if (function == null) {
+      message =
+          String.format("The input function for the execute function request is null");
+    }
+
+    return message;
+  }
+
+  MemberMappedArgument extractMemberMappedArgument(Part part)
+      throws IOException, ClassNotFoundException {
+    MemberMappedArgument memberMappedArg = null;
+    if (part != null) {
+      Object obj = part.getObject();
+      if (obj instanceof MemberMappedArgument) {
+        memberMappedArg = (MemberMappedArgument) obj;
+      }
+    }
+    return memberMappedArg;
+  }
+
+  Set<Object> populateRemovedNodes(Message clientMessage, int removedNodesSize, int partNumber)
+      throws IOException, ClassNotFoundException {
+    Set<Object> removedNodesSet = null;
+    if (removedNodesSize != 0) {
+      removedNodesSet = new HashSet<Object>();
+      partNumber = partNumber + 1;
+
+      for (int i = 0; i < removedNodesSize; i++) {
+        removedNodesSet.add(clientMessage.getPart(partNumber + i).getStringOrObject());
+      }
+    }
+    return removedNodesSet;
+  }
+
+  Set<Object> populateFilters(Message clientMessage, int filterSize)
+      throws IOException, ClassNotFoundException {
+    Set<Object> filter = null;
+    int partNumber;
+    if (filterSize != 0) {
+      filter = new HashSet<Object>();
+      partNumber = 7;
+      for (int i = 0; i < filterSize; i++) {
+        filter.add(clientMessage.getPart(partNumber + i).getStringOrObject());
+      }
+    }
+    return filter;
+  }
+
+  ExecuteFunctionOperationContext getAuthorizedExecuteFunctionOperationContext(Object args,
+      Set<Object> filter,
+      boolean optimizedForWrite,
+      AuthorizeRequest authzRequest,
+      String functionName,
+      String regionPath) {
+    ExecuteFunctionOperationContext executeContext = null;
+    if (authzRequest != null) {
+      executeContext = authzRequest.executeFunctionAuthorize(functionName, regionPath, filter,
+          args, optimizedForWrite);
+    }
+    return executeContext;
+  }
+
+  void executeFunctionNoResult(Object function, byte functionState,
+      Function<?> functionObject, AbstractExecution execution) {
+    if (function instanceof String) {
+      switch (functionState) {
+        case AbstractExecution.NO_HA_NO_HASRESULT_NO_OPTIMIZEFORWRITE:
+          execution.execute((String) function);
+          break;
+        case AbstractExecution.NO_HA_NO_HASRESULT_OPTIMIZEFORWRITE:
+          execution.execute((String) function);
+          break;
+      }
+    } else {
+      execution.execute(functionObject);
+    }
+  }
+
+  void executeFunctionWithResult(Object function, byte functionState,
+      Function<?> functionObject, AbstractExecution execution) {
+    if (function instanceof String) {
+      switch (functionState) {
+        case AbstractExecution.NO_HA_HASRESULT_NO_OPTIMIZEFORWRITE:
+          execution.execute((String) function).getResult();
+          break;
+        case AbstractExecution.HA_HASRESULT_NO_OPTIMIZEFORWRITE:
+          execution.execute((String) function).getResult();
+          break;
+        case AbstractExecution.HA_HASRESULT_OPTIMIZEFORWRITE:
+          execution.execute((String) function).getResult();
+          break;
+        case AbstractExecution.NO_HA_HASRESULT_OPTIMIZEFORWRITE:
+          execution.execute((String) function).getResult();
+          break;
+      }
+    } else {
+      execution.execute(functionObject).getResult();
+    }
+  }
+

INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 MOV60 INS39 INS42 INS44 INS44 INS44 INS44 INS44 MOV8 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS44 INS8 INS39 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS43 MOV8 MOV43 INS42 INS44 INS44 INS8 INS43 INS42 INS44 INS43 INS43 INS8 INS74 INS42 INS44 INS44 INS44 INS43 INS43 INS8 INS74 INS42 INS44 INS44 INS43 INS43 INS8 INS43 INS42 INS44 INS44 INS44 INS44 INS44 INS44 INS8 INS39 INS42 INS44 INS44 INS44 INS44 MOV8 INS39 INS42 INS44 INS44 INS44 INS44 MOV8 MOV25 INS43 INS42 INS74 INS42 INS43 INS42 MOV43 INS42 INS43 INS42 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS74 INS42 INS74 INS42 INS43 INS42 INS43 INS42 MOV60 MOV25 INS41 INS43 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS74 INS42 INS42 INS25 INS41 INS43 INS42 INS43 INS42 MOV60 INS25 INS41 INS42 INS43 INS42 INS42 INS42 INS60 MOV25 INS41 INS43 INS43 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS42 INS60 MOV25 INS41 INS43 INS43 INS43 INS42 INS39 INS42 INS42 INS42 INS60 INS60 MOV25 INS41 INS42 INS43 INS42 INS74 INS42 INS39 INS42 MOV43 INS42 INS43 INS42 INS43 INS42 MOV60 INS25 INS41 INS43 INS42 INS39 INS42 INS74 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS74 INS42 INS43 INS42 MOV27 MOV8 MOV60 MOV25 INS42 INS43 INS76 INS42 INS42 INS42 INS42 INS43 INS43 INS43 INS43 INS42 INS42 INS8 INS42 INS42 INS42 INS42 INS43 INS76 MOV27 MOV8 INS8 INS9 INS42 INS42 MOV27 INS8 INS25 INS42 INS42 INS43 INS59 INS42 INS42 INS42 INS42 INS74 INS59 INS42 INS42 INS42 INS42 INS74 INS59 INS39 INS59 INS42 INS42 INS43 INS43 INS42 INS42 MOV27 INS8 INS42 INS42 INS43 INS76 INS42 INS42 INS43 INS76 INS42 INS21 INS60 INS60 INS60 INS25 INS42 INS42 INS42 INS42 INS42 MOV21 INS42 MOV60 MOV25 MOV25 INS21 MOV27 INS8 INS42 INS42 INS33 INS43 INS43 INS42 INS33 INS43 INS43 INS42 INS33 INS42 INS42 INS42 INS21 INS42 INS42 INS7 INS39 INS59 INS39 INS59 INS43 MOV59 UPD43 INS62 MOV8 MOV27 INS8 INS43 INS9 INS8 INS7 INS21 INS42 INS42 INS42 INS42 INS7 INS42 INS32 INS42 MOV32 INS42 INS32 INS42 MOV32 INS42 INS32 INS42 INS42 INS32 UPD42 INS42 INS32 INS42 INS43 INS21 MOV21 MOV43 INS8 MOV32 INS42 INS60 MOV21 MOV21 INS41 INS42 INS32 INS7 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 UPD42 INS42 INS45 INS38 INS8 INS42 INS42 INS42 INS42 MOV32 MOV32 MOV32 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS45 INS21 MOV21 UPD42 UPD42 INS45 UPD42 INS42 INS45 INS43 INS59 INS9 INS42 INS42 INS45 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS45 INS32 INS41 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS45 INS32 UPD42 UPD42 INS45 INS42 INS42 INS32 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS45 INS42 INS42 INS45 INS42 UPD42 UPD42 INS45 UPD42 UPD42 INS45 DEL40 DEL26 DEL40 DEL26 DEL83 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL34 DEL59 DEL42 DEL42 DEL40 DEL40 DEL42 DEL40 DEL42 DEL45 DEL32 DEL7 DEL21 DEL8 DEL42 DEL40 DEL42 DEL45 DEL32 DEL7 DEL21 DEL8 DEL25 DEL41 DEL8 DEL25 DEL40 DEL42 DEL42 DEL59 DEL60 DEL83 DEL60 DEL83 DEL42 DEL42 DEL42 DEL32 DEL7 DEL25 DEL40 DEL40 DEL42 DEL32 DEL40 DEL40 DEL40 DEL40 DEL42 DEL42 DEL32 DEL40 DEL40
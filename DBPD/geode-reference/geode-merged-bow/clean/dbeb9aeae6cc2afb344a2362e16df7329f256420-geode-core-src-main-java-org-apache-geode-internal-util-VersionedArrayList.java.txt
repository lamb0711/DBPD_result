Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Versioned ArrayList which maintains the version everytime the list gets
- * modified. This is thread-safe in terms of add and remove operations and also
- * list is an unmodifiable list to avoid ConcurrentModificationException.
+ * Versioned ArrayList which maintains the version everytime the list gets modified. This is
+ * thread-safe in terms of add and remove operations and also list is an unmodifiable list to avoid
+ * ConcurrentModificationException.
-public class VersionedArrayList implements DataSerializable, Versionable, Iterable<Node>
-{
+public class VersionedArrayList implements DataSerializable, Versionable, Iterable<Node> {
-  
-//  private List vhist = new ArrayList();  // DEBUG
-  
+
+  // private List vhist = new ArrayList(); // DEBUG
+
-//    incrementVersion("i->" + list);
+    // incrementVersion("i->" + list);
-   * Adds obj to the list. Addition is done by making a copy of the existing
-   * list and then adding the obj to the new list and assigning the old list to
-   * the new unmodifiable list. This is to ensure that the iterator of the list
-   * doesn't get ConcurrentModificationException.
+   * Adds obj to the list. Addition is done by making a copy of the existing list and then adding
+   * the obj to the new list and assigning the old list to the new unmodifiable list. This is to
+   * ensure that the iterator of the list doesn't get ConcurrentModificationException.
-  public synchronized void add(Node obj)
-  {
+  public synchronized void add(Node obj) {
-//    incrementVersion("a->" + obj);
+    // incrementVersion("a->" + obj);
-   * Removes obj from the list. Removal is done by making a copy of the existing
-   * list and then removing the obj from the new list.  If the object was removed, 
-   * the list is assigning to the new unmodifiable list. 
-   * This is to ensure that the iterator of the list doesn't get ConcurrentModificationException.
-   * @return true if the element was removed and the version was changed, otherwise version and list are left
-   * unmodified.
+   * Removes obj from the list. Removal is done by making a copy of the existing list and then
+   * removing the obj from the new list. If the object was removed, the list is assigning to the new
+   * unmodifiable list. This is to ensure that the iterator of the list doesn't get
+   * ConcurrentModificationException.
+   * 
+   * @return true if the element was removed and the version was changed, otherwise version and list
+   *         are left unmodified.
-  public synchronized boolean remove(Node obj)
-  {
+  public synchronized boolean remove(Node obj) {
-//      incrementVersion("r->" + obj);
+      // incrementVersion("r->" + obj);
-    } 
+    }
-  public synchronized Iterator<Node> iterator()
-  {
+  public synchronized Iterator<Node> iterator() {
-  public synchronized int size()
-  {
+  public synchronized int size() {
-  public boolean contains(Node obj)
-  {
-    final List<Node> l; 
-    synchronized(this) {
+  public boolean contains(Node obj) {
+    final List<Node> l;
+    synchronized (this) {
-  
+
-  public Object get(int i)
-  {
-    final List<Node> l; 
-    synchronized(this) {
+  public Object get(int i) {
+    final List<Node> l;
+    synchronized (this) {
-  public int indexOf(Object obj)
-  {
+  public int indexOf(Object obj) {
-    synchronized(this) {
+    synchronized (this) {
-  public Set<Node> getListCopy()
-  {
+  public Set<Node> getListCopy() {
-    synchronized(this) {
+    synchronized (this) {
-  public String toString()
-  {
+  public String toString() {
-//    final List vh;
-    synchronized(this) {
+    // final List vh;
+    synchronized (this) {
-//      vh = this.vhist;
+      // vh = this.vhist;
-//    sb.append("vhist:\n " + vh);
+    // sb.append("vhist:\n " + vh);
- 
-  public void toData(DataOutput out) throws IOException
-  {
+
+  public void toData(DataOutput out) throws IOException {
-//    final List vh;
+    // final List vh;
-//      vh = this.vhist;
+      // vh = this.vhist;
-//    final int sh = vh.size();
-//    out.writeInt(sh);
-//    for (int k = 0; k < sh; k++) {
-//      out.writeUTF((String) vh.get(k));
-//    }
+    // final int sh = vh.size();
+    // out.writeInt(sh);
+    // for (int k = 0; k < sh; k++) {
+    // out.writeUTF((String) vh.get(k));
+    // }
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException
-  {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    for (int k = 0; k < size; k++) {      
+    for (int k = 0; k < size; k++) {
-    
-//    final ArrayList vh = new ArrayList();
-//    final int vhsize = in.readInt();
-//    for (int k = 0; k < vhsize; k++) {      
-//      vh.add(in.readUTF());
-//    }
-    
+
+    // final ArrayList vh = new ArrayList();
+    // final int vhsize = in.readInt();
+    // for (int k = 0; k < vhsize; k++) {
+    // vh.add(in.readUTF());
+    // }
+
-//      this.vhist = Collections.unmodifiableList(vh);
+      // this.vhist = Collections.unmodifiableList(vh);
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  public synchronized Comparable getVersion()
-  {
+  public synchronized Comparable getVersion() {
-  
+
-      synchronized(this) {
+      synchronized (this) {
-    } 
+    }
-  
+
-      synchronized(other) {
-        v = ((VersionedArrayList) other).version;        
+      synchronized (other) {
+        v = ((VersionedArrayList) other).version;
-      synchronized(this) {
+      synchronized (this) {
-    } 
+    }
-  
-  public boolean isSame(Versionable other)
-  {
+
+  public boolean isSame(Versionable other) {
-      synchronized(other) {
-        v = ((VersionedArrayList) other).version;        
+      synchronized (other) {
+        v = ((VersionedArrayList) other).version;
-      synchronized(this) {
+      synchronized (this) {
-    } 
+    }
-//private synchronized void incrementVersion(String op)
-  private synchronized void incrementVersion()
-  {
-// DEBUG
-//    {
-//      StringWriter s = new StringWriter();
-//      final String pre = 
-//        "o=" + op + 
-//        ":t=" + System.currentTimeMillis() + 
-//        ":m=" + InternalDistributedSystem.getAnyInstance().getDistributedMember().toString() + ": ";
-//      s.write(pre);
-//      PrintWriter p = new PrintWriter(s);
-//      new Exception().fillInStackTrace().printStackTrace(p);
-//      
-//      ArrayList newList = new ArrayList(this.vhist);
-//      newList.add(pre); // Capture what code added this version
-//      this.vhist = Collections.unmodifiableList(newList);
-//    }
-    
+  // private synchronized void incrementVersion(String op)
+  private synchronized void incrementVersion() {
+    // DEBUG
+    // {
+    // StringWriter s = new StringWriter();
+    // final String pre =
+    // "o=" + op +
+    // ":t=" + System.currentTimeMillis() +
+    // ":m=" + InternalDistributedSystem.getAnyInstance().getDistributedMember().toString() + ": ";
+    // s.write(pre);
+    // PrintWriter p = new PrintWriter(s);
+    // new Exception().fillInStackTrace().printStackTrace(p);
+    //
+    // ArrayList newList = new ArrayList(this.vhist);
+    // newList.add(pre); // Capture what code added this version
+    // this.vhist = Collections.unmodifiableList(newList);
+    // }
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66
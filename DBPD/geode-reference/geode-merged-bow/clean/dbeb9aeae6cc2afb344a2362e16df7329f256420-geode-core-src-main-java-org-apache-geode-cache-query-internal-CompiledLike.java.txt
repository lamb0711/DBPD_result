Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import org.apache.geode.cache.query.QueryInvalidException;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-public class CompiledLike extends CompiledComparison
-{
+public class CompiledLike extends CompiledComparison {
-  
+
-  
+
-  
+
-  
+
-  final static char BOUNDARY_CHAR = (char)255;
+  final static char BOUNDARY_CHAR = (char) 255;
-  
-  //private final CompiledBindArgument bindArg;
+
+  // private final CompiledBindArgument bindArg;
-  
+
-    return (Integer)context.cacheGet(wildcardPositionKey, -1);
+    return (Integer) context.cacheGet(wildcardPositionKey, -1);
-  
+
-    return (Integer)context.cacheGet(wildcardTypeKey, -1);
+    return (Integer) context.cacheGet(wildcardTypeKey, -1);
-  
+
-  
+
-  
-  OrganizedOperands organizeOperands(ExecutionContext context,
-      boolean completeExpansionNeeded, RuntimeIterator[] indpndntItrs)
-      throws FunctionDomainException, TypeMismatchException,
+
+  OrganizedOperands organizeOperands(ExecutionContext context, boolean completeExpansionNeeded,
+      RuntimeIterator[] indpndntItrs) throws FunctionDomainException, TypeMismatchException,
-        filter = new RangeJunction(OQLLexerTokenTypes.LITERAL_and,
-            indpndntItrs, completeExpansionNeeded, cvs);
+        filter = new RangeJunction(OQLLexerTokenTypes.LITERAL_and, indpndntItrs,
+            completeExpansionNeeded, cvs);
- 
+
-  
+
-   * Expands the CompiledLike operands based on sargability into 
-   * multiple CompiledComparisons
+   * Expands the CompiledLike operands based on sargability into multiple CompiledComparisons
+   * 
-  CompiledComparison[] getExpandedOperandsWithIndexInfoSetIfAny(
-      ExecutionContext context) throws AmbiguousNameException,
-      TypeMismatchException, NameResolutionException, FunctionDomainException,
-      QueryInvocationTargetException {
+  CompiledComparison[] getExpandedOperandsWithIndexInfoSetIfAny(ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException,
+      FunctionDomainException, QueryInvocationTargetException {
-        // set the index key in the indexinfo of the CC since the index key 
+        // set the index key in the indexinfo of the CC since the index key
-        IndexInfo indexInfo = new IndexInfo(cc.getKey(context),
-            thisIndexInfo[0]._path, thisIndexInfo[0]._index,
-            thisIndexInfo[0]._matchLevel, thisIndexInfo[0].mapping,
-            cc.getOperator());
-        context.cachePut(cc, new IndexInfo[] { indexInfo });
+        IndexInfo indexInfo =
+            new IndexInfo(cc.getKey(context), thisIndexInfo[0]._path, thisIndexInfo[0]._index,
+                thisIndexInfo[0]._matchLevel, thisIndexInfo[0].mapping, cc.getOperator());
+        context.cachePut(cc, new IndexInfo[] {indexInfo});
-  
-  @Override
-  public SelectResults filterEvaluate(ExecutionContext context,
-      SelectResults intermediateResults, boolean completeExpansionNeeded,
-      CompiledValue iterOperands, RuntimeIterator[] indpndntItrs, boolean isIntersection, boolean conditioningNeeded,
-      boolean evaluateProjection)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
-    OrganizedOperands newOperands = organizeOperands(context, completeExpansionNeeded,  indpndntItrs);
-    assert newOperands.iterateOperand == null;
-    SelectResults result = intermediateResults;
-    result =  (newOperands.filterOperand) .filterEvaluate(context,intermediateResults,  completeExpansionNeeded,
-    iterOperands,indpndntItrs,isIntersection, conditioningNeeded, evaluateProjection) ;
-    
-    return result;
-  } 
-  public SelectResults filterEvaluate(ExecutionContext context,
-      SelectResults intermediateResults) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException
-  {
-    RuntimeIterator grpItr = (RuntimeIterator)QueryUtils.getCurrentScopeUltimateRuntimeIteratorsIfAny(this, context).iterator().next();
-    OrganizedOperands newOperands = organizeOperands(context,true,new RuntimeIterator[]{grpItr});
+  public SelectResults filterEvaluate(ExecutionContext context, SelectResults intermediateResults,
+      boolean completeExpansionNeeded, CompiledValue iterOperands, RuntimeIterator[] indpndntItrs,
+      boolean isIntersection, boolean conditioningNeeded, boolean evaluateProjection)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
+    OrganizedOperands newOperands =
+        organizeOperands(context, completeExpansionNeeded, indpndntItrs);
-    result =  (newOperands.filterOperand) .filterEvaluate(context, intermediateResults) ;   
+    result = (newOperands.filterOperand).filterEvaluate(context, intermediateResults,
+        completeExpansionNeeded, iterOperands, indpndntItrs, isIntersection, conditioningNeeded,
+        evaluateProjection);
+
-  
+
+  @Override
+  public SelectResults filterEvaluate(ExecutionContext context, SelectResults intermediateResults)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
+    RuntimeIterator grpItr = (RuntimeIterator) QueryUtils
+        .getCurrentScopeUltimateRuntimeIteratorsIfAny(this, context).iterator().next();
+    OrganizedOperands newOperands = organizeOperands(context, true, new RuntimeIterator[] {grpItr});
+    assert newOperands.iterateOperand == null;
+    SelectResults result = intermediateResults;
+    result = (newOperands.filterOperand).filterEvaluate(context, intermediateResults);
+    return result;
+  }
+
-   * Breaks down the like predicate (if sargable) into 2 or 3
-   * CompiledComparisons based on the presence of wildcard
+   * Breaks down the like predicate (if sargable) into 2 or 3 CompiledComparisons based on the
+   * presence of wildcard
-  CompiledComparison[] getRangeIfSargable(ExecutionContext context, CompiledValue var, String pattern) {
+  CompiledComparison[] getRangeIfSargable(ExecutionContext context, CompiledValue var,
+      String pattern) {
-        cv = new CompiledComparison[] {
-            new CompiledComparison(var, new CompiledLiteral(LOWEST_STRING),
-                OQLLexerTokenTypes.TOK_GE), this };
+        cv = new CompiledComparison[] {new CompiledComparison(var,
+            new CompiledLiteral(LOWEST_STRING), OQLLexerTokenTypes.TOK_GE), this};
-        CompiledComparison c1 = new CompiledComparison(var,
-            new CompiledLiteral(lowerBound), OQLLexerTokenTypes.TOK_GE);
-        CompiledComparison c2 = new CompiledComparison(var,
-            new CompiledLiteral(upperBound), OQLLexerTokenTypes.TOK_LT);
-        
+        CompiledComparison c1 =
+            new CompiledComparison(var, new CompiledLiteral(lowerBound), OQLLexerTokenTypes.TOK_GE);
+        CompiledComparison c2 =
+            new CompiledComparison(var, new CompiledLiteral(upperBound), OQLLexerTokenTypes.TOK_LT);
+
-            cv = new CompiledComparison[] {
-                new CompiledComparison(var, new CompiledLiteral(LOWEST_STRING),
-                    OQLLexerTokenTypes.TOK_GE), this };
+            cv = new CompiledComparison[] {new CompiledComparison(var,
+                new CompiledLiteral(LOWEST_STRING), OQLLexerTokenTypes.TOK_GE), this};
-            cv = new CompiledComparison[] { c1, c2, this };
+            cv = new CompiledComparison[] {c1, c2, this};
-          cv = new CompiledComparison[] { c1, c2 };
+          cv = new CompiledComparison[] {c1, c2};
-      cv = new CompiledComparison[] { new CompiledComparison(var,
-          new CompiledLiteral(buffer.toString()), getOperator()) };
+      cv = new CompiledComparison[] {
+          new CompiledComparison(var, new CompiledLiteral(buffer.toString()), getOperator())};
-    for (int i = 0; i < len;i++) {
+    for (int i = 0; i < len; i++) {
-        case ']' :
-        case '[' :
-        case '^' :
-        case '*' :
-        case '.' :
-        case '+' :
-        case '?' :
-        case '(' :
-        case ')' :
-        case '|' :
-        case '{' :
-        case '}' :
-        case '\\' :
-          //if ((ch == '\\') && (i+1) < len && (pattern.charAt(i+1) == '_' || pattern.charAt(i+1) == '%')) {
+        case ']':
+        case '[':
+        case '^':
+        case '*':
+        case '.':
+        case '+':
+        case '?':
+        case '(':
+        case ')':
+        case '|':
+        case '{':
+        case '}':
+        case '\\':
+          // if ((ch == '\\') && (i+1) < len && (pattern.charAt(i+1) == '_' || pattern.charAt(i+1)
+          // == '%')) {
-            if (!((i+1) < len && (pattern.charAt(i+1) == '\\'))) {
+            if (!((i + 1) < len && (pattern.charAt(i + 1) == '\\'))) {
-          } 
+          }
-          // \Q is used for start of string literal 
+          // \Q is used for start of string literal
-        case '%':  // replace with .*
+        case '%': // replace with .*
-              while ((i+1) < len && pattern.charAt(i + 1) == '%') {
+              while ((i + 1) < len && pattern.charAt(i + 1) == '%') {
-            }
-            else {
+            } else {
-          }
-          else {
+          } else {
-   * Checks if index can be used for Strings with wildcards. Two wild cards are
-   * supported % and _. The wildcard could be at any index position of the
-   * string.
+   * Checks if index can be used for Strings with wildcards. Two wild cards are supported % and _.
+   * The wildcard could be at any index position of the string.
-          if (buffer.charAt(i + 1) == PERCENT
-              || buffer.charAt(i + 1) == UNDERSCORE) {
+          if (buffer.charAt(i + 1) == PERCENT || buffer.charAt(i + 1) == UNDERSCORE) {
-  @Override
-  public Object evaluate(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException
-  {
-    CompiledValue iterEvaluator = (CompiledValue)context.cacheGet(this.bindArg);
-    if(iterEvaluator == null) {
-      String pattern = (String)this.bindArg.evaluate(context);
-      CompiledComparison[] cvs = getRangeIfSargable(this.var, pattern);
+   * @Override public Object evaluate(ExecutionContext context) throws FunctionDomainException,
+   * TypeMismatchException, NameResolutionException, QueryInvocationTargetException { CompiledValue
+   * iterEvaluator = (CompiledValue)context.cacheGet(this.bindArg); if(iterEvaluator == null) {
+   * String pattern = (String)this.bindArg.evaluate(context); CompiledComparison[] cvs =
+   * getRangeIfSargable(this.var, pattern);
+   * 
+   * for (CompiledComparison cp : cvs) { cp.computeDependencies(context);
+   * 
+   * } if(cvs.length ==2 ) { iterEvaluator = new CompiledJunction(cvs,
+   * OQLLexerTokenTypes.LITERAL_and); }else { iterEvaluator = cvs[0]; }
+   * context.cachePut(this.bindArg, iterEvaluator);
+   * 
+   * } return iterEvaluator.evaluate(context); }
+   */
-      for (CompiledComparison cp : cvs) {
-        cp.computeDependencies(context);
-
-      }
-      if(cvs.length ==2 ) {
-        iterEvaluator = new CompiledJunction(cvs, OQLLexerTokenTypes.LITERAL_and);   
-      }else {
-        iterEvaluator = cvs[0];
-      }
-      context.cachePut(this.bindArg, iterEvaluator);
-      
-    }
-    return iterEvaluator.evaluate(context);   
-  }
-  */
-  
-  public Object evaluate(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException
-  {
-    //reset the isIndexEvaluated flag here since index is not being used here
+  public Object evaluate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+    // reset the isIndexEvaluated flag here since index is not being used here
-    Pattern pattern = (Pattern)context.cacheGet(this.bindArg);
-    if(pattern == null) {
-      String strPattern = this.bindArg.evaluate(context).toString(); // handles both Strings and PdxStrings
+    Pattern pattern = (Pattern) context.cacheGet(this.bindArg);
+    if (pattern == null) {
+      String strPattern = this.bindArg.evaluate(context).toString(); // handles both Strings and
+                                                                     // PdxStrings
-        throw new UnsupportedOperationException("Null values are not supported with LIKE predicate.");
+        throw new UnsupportedOperationException(
+            "Null values are not supported with LIKE predicate.");
-      pattern = Pattern.compile(getRegexPattern(strPattern),Pattern.MULTILINE|Pattern.DOTALL);
-      //GemFireCacheImpl.getInstance().getLogger().fine("### DEBUG : string :" + strPattern + " pattern :" + pattern.toString());
+      pattern = Pattern.compile(getRegexPattern(strPattern), Pattern.MULTILINE | Pattern.DOTALL);
+      // GemFireCacheImpl.getInstance().getLogger().fine("### DEBUG : string :" + strPattern + "
+      // pattern :" + pattern.toString());
-    if (!((value instanceof String)  || (value instanceof PdxString) || (value == QueryService.UNDEFINED))) {
-//      throw new TypeMismatchException(
-//          LocalizedStrings.TypeUtils_UNABLE_TO_COMPARE_OBJECT_OF_TYPE_0_WITH_OBJECT_OF_TYPE_1
-//              .toLocalizedString("java.lang.String", value.getClass().getName()));
+    if (!((value instanceof String) || (value instanceof PdxString)
+        || (value == QueryService.UNDEFINED))) {
+      // throw new TypeMismatchException(
+      // LocalizedStrings.TypeUtils_UNABLE_TO_COMPARE_OBJECT_OF_TYPE_0_WITH_OBJECT_OF_TYPE_1
+      // .toLocalizedString("java.lang.String", value.getClass().getName()));
-    boolean isMatched = pattern.matcher(value.toString()).matches(); 
+    boolean isMatched = pattern.matcher(value.toString()).matches();
-  
+
-     * During filterevaluation, CompiledLike is converted to 2 or 3
-     * CompiledComparisons. One of the CCs could be a CompiledLike itself. For
-     * example If the wildcard is _ or the % is anywhere except at the end in
-     * the pattern, a GroupJunction is created. For 'ab%cd', the GroupJunction
-     * would be ">=ab AND < ac AND LIKE ab%cd". The check avoids the
-     * re-filterevaluation of this CompiledLike.
+     * During filterevaluation, CompiledLike is converted to 2 or 3 CompiledComparisons. One of the
+     * CCs could be a CompiledLike itself. For example If the wildcard is _ or the % is anywhere
+     * except at the end in the pattern, a GroupJunction is created. For 'ab%cd', the GroupJunction
+     * would be ">=ab AND < ac AND LIKE ab%cd". The check avoids the re-filterevaluation of this
+     * CompiledLike.
-      if (result.indexes.size() > 0
-          && result.indexes.get(0) instanceof PrimaryKeyIndex) {
+      if (result.indexes.size() > 0 && result.indexes.get(0) instanceof PrimaryKeyIndex) {
-  
+
+
-  public boolean isLimitApplicableAtIndexLevel(ExecutionContext context)  {
+  public boolean isLimitApplicableAtIndexLevel(ExecutionContext context) {
-  
+
-      String canonicalizedOrderByClause) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
+      String canonicalizedOrderByClause) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
-        IndexProtocol ip = (IndexProtocol)pi.indexes.get(0);
-        if (ip.getCanonicalizedIndexedExpression().equals(
-            canonicalizedOrderByClause)) {
+        IndexProtocol ip = (IndexProtocol) pi.indexes.get(0);
+        if (ip.getCanonicalizedIndexedExpression().equals(canonicalizedOrderByClause)) {

UPD66 UPD66 UPD66 UPD66 UPD66 DEL40 DEL26 DEL40 DEL26 DEL66 DEL66
Merge branch 'release/1.0.0-incubating.M3'

-
-import java.io.IOException;
-import java.lang.reflect.Method;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import com.gemstone.gemfire.internal.cache.region.entry.RegionEntryFactoryBuilder;
-import org.apache.logging.log4j.Logger;
-
-import com.gemstone.gemfire.cache.CacheRuntimeException;
-import com.gemstone.gemfire.cache.CacheWriter;
-import com.gemstone.gemfire.cache.CacheWriterException;
-import com.gemstone.gemfire.cache.CustomEvictionAttributes;
-import com.gemstone.gemfire.cache.DiskAccessException;
-import com.gemstone.gemfire.cache.EntryExistsException;
-import com.gemstone.gemfire.cache.EntryNotFoundException;
-import com.gemstone.gemfire.cache.Operation;
-import com.gemstone.gemfire.cache.RegionDestroyedException;
-import com.gemstone.gemfire.cache.TimeoutException;
-import com.gemstone.gemfire.cache.TransactionId;
+import com.gemstone.gemfire.cache.*;
-import com.gemstone.gemfire.cache.query.internal.IndexUpdater;
+import com.gemstone.gemfire.distributed.internal.DistributionConfig;
-import com.gemstone.gemfire.internal.ClassPathLoader;
-import com.gemstone.gemfire.internal.cache.delta.Delta;
+import com.gemstone.gemfire.internal.cache.region.entry.RegionEntryFactoryBuilder;
-import com.gemstone.gemfire.internal.cache.versions.ConcurrentCacheModificationException;
-import com.gemstone.gemfire.internal.cache.versions.RegionVersionVector;
-import com.gemstone.gemfire.internal.cache.versions.VersionHolder;
-import com.gemstone.gemfire.internal.cache.versions.VersionSource;
-import com.gemstone.gemfire.internal.cache.versions.VersionStamp;
-import com.gemstone.gemfire.internal.cache.versions.VersionTag;
+import com.gemstone.gemfire.internal.cache.versions.*;
-import com.gemstone.gemfire.pdx.PdxInstance;
-import com.gemstone.gemfire.pdx.PdxSerializationException;
-import com.gemstone.gemfire.pdx.internal.ConvertableToBytes;
+import org.apache.logging.log4j.Logger;
+
+import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
- * @since 3.5.1
+ * @since GemFire 3.5.1
-//Asif: In case of sqlFabric System, we are creating a different set of RegionEntry 
-// which are derived from the concrete  GFE RegionEntry classes.
-// In future if any new concrete  RegionEntry class is defined, the new  SqlFabric
-// RegionEntry Classes need to be created. There is a junit test in sqlfabric
-// which checks for RegionEntry classes of GFE and validates the same with its 
-// own classes.
-
-  /** An internal Listener for index maintenance for SQLFabric. */
-  private final IndexUpdater indexUpdater;
-    if (internalRegionArgs != null) {
-      this.indexUpdater = internalRegionArgs.getIndexUpdater();
-    }
-    else {
-      this.indexUpdater = null;
-    }
-  }
-
-  public final IndexUpdater getIndexUpdater() {
-    return this.indexUpdater;
-    if (cache != null && cache.isSqlfSystem()) {
-      String provider = GemFireCacheImpl.SQLF_ENTRY_FACTORY_PROVIDER;
-      try {
-        Class<?> factoryProvider = ClassPathLoader.getLatest().forName(provider);
-        Method method = factoryProvider.getDeclaredMethod(
-            "getRegionEntryFactory", new Class[] { Boolean.TYPE, Boolean.TYPE,
-                Boolean.TYPE, Object.class, InternalRegionArguments.class });
-        RegionEntryFactory ref = (RegionEntryFactory)method.invoke(null,
-            new Object[] { Boolean.valueOf(attr.statisticsEnabled),
-                Boolean.valueOf(isLRU), Boolean.valueOf(isDisk), owner,
-                internalRegionArgs });
-
-        // TODO need to have the SQLF entry factory support version stamp storage
-        setEntryFactory(ref);
-
-      }
-      catch (Exception e) {
-        throw new CacheRuntimeException(
-            "Exception in obtaining RegionEntry Factory" + " provider class ",
-            e) {
-        };
-      }
-    }
-    else {
-      setEntryFactory(new RegionEntryFactoryBuilder().getRegionEntryFactoryOrNull(attr.statisticsEnabled,isLRU,isDisk,withVersioning,offHeap));
-    }
+    setEntryFactory(new RegionEntryFactoryBuilder().getRegionEntryFactoryOrNull(attr.statisticsEnabled,isLRU,isDisk,withVersioning,offHeap));
-    if (re != null && re.isMarkedForEviction()) {
-      // entry has been faulted in from HDFS
-      return null;
-    }
-    if (re != null && re.isMarkedForEviction()) {
-      // entry has been faulted in from HDFS
-      return null;
-    }
-    if (re.isTombstone() && _getMap().get(key) == re && !re.isMarkedForEviction()){
+    if (re.isTombstone() && _getMap().get(key) == re){
-      EntryEventImpl event, final LocalRegion owner,
-      final IndexUpdater indexUpdater) {
+      EntryEventImpl event, final LocalRegion owner) {
-    if (re.isTombstone()&& _getMap().get(key) == re && !re.isMarkedForEviction()) {
+    if (re.isTombstone()&& _getMap().get(key) == re) {
-    try {
-      if (indexUpdater != null) {
-        indexUpdater.onEvent(owner, event, re);
-      }
-
-      //This is messy, but custom eviction calls removeEntry
-      //rather than re.destroy I think to avoid firing callbacks, etc.
-      //However, the value still needs to be set to removePhase1
-      //in order to remove the entry from disk.
-      if(event.isCustomEviction() && !re.isRemoved()) {
-        try {
-          re.removePhase1(owner, false);
-        } catch (RegionClearedException e) {
-          //that's ok, we were just trying to do evict incoming eviction
-        }
-      }
-      
-      if (_getMap().remove(key, re)) {
-        re.removePhase2();
-        success = true;
-        if (updateStat) {
-          incEntryCount(-1);
-        }
-      }
-    } finally {
-      if (indexUpdater != null) {
-        indexUpdater.postEvent(owner, event, re, success);
+    if (_getMap().remove(key, re)) {
+      re.removePhase2();
+      success = true;
+      if (updateStat) {
+        incEntryCount(-1);
-    assert indexUpdater == null : "indexUpdater should only exist if sqlfire";
+        if (haContainer == null) {
+          return false;
+        }
-                          if (!confirmEvictionDestroy(oldRe) || (owner.getEvictionCriteria() != null && !owner.getEvictionCriteria().doEvict(event))) {
+                          if (!confirmEvictionDestroy(oldRe)) {
-                    if (!confirmEvictionDestroy(re) || (owner.getEvictionCriteria() != null && !owner.getEvictionCriteria().doEvict(event))) {
+                    if (!confirmEvictionDestroy(re)) {
-                          removeEntry(event.getKey(), re, true, event, owner,
-                              indexUpdater);
+                          removeEntry(event.getKey(), re, true, event, owner);
-                          removeEntry(event.getKey(), re, true, event, owner,
-                              indexUpdater);
+                          removeEntry(event.getKey(), re, true, event, owner);
-                        removeEntry(event.getKey(), re, true, event, owner,
-                            indexUpdater);
+                        removeEntry(event.getKey(), re, true, event, owner);
-                  if (owner.isHDFSReadWriteRegion() && re.isRemovedPhase2()) {
-                    // For HDFS region there may be a race with eviction
-                    // so retry the operation. fixes bug 49150
-                    retry = true;
-                    continue;
-                  }
-              EntryEventImpl sqlfEvent = null;
-              @Retained @Released Object oldValue = re.getValueInVM(owner);
-              try {
+              Object oldValue = re.getValueInVM(owner);
-              EntryEventImpl cbEvent = createCBEvent(owner, op,
+              @Released EntryEventImpl cbEvent = createCBEvent(owner, op,
-              if (/* owner.isUsedForPartitionedRegionBucket() && */ 
-                  indexUpdater != null) {
-                 sqlfEvent = cbEvent;
-              } else {
-              }
-                    if (sqlfEvent != null) {
-                      re.removePhase1(owner, false); // fix for bug 43063
-                      re.removePhase2();
-                      removeEntry(key, re, true, sqlfEvent, owner, indexUpdater);
-                    } else {
+                    {
-              } finally {
-                OffHeapHelper.release(oldValue);
-              }
-        EntryEventImpl cbEvent = createCBEvent(owner, op,
+        @Released EntryEventImpl cbEvent = createCBEvent(owner, op,
-  public static boolean FORCE_INVALIDATE_EVENT = Boolean.getBoolean("gemfire.FORCE_INVALIDATE_EVENT");
+  public static boolean FORCE_INVALIDATE_EVENT = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "FORCE_INVALIDATE_EVENT");
-                        @Retained @Released Object oldValue = oldRe.getValueInVM(owner); // OFFHEAP EntryEventImpl oldValue
+                        Object oldValue = oldRe.getValueInVM(owner); // OFFHEAP EntryEventImpl oldValue
-                        try {
-                        } finally {
-                          OffHeapHelper.release(oldValue);
-                        }
-                      
-                      @Retained @Released Object v = re.getValueInVM(owner);
-                      
-                      try {
-                        event.setOldValue(v); // OFFHEAP escapes to EntryEventImpl oldValue
-                      } finally {
-                        OffHeapHelper.release(v);
-                      }
+                      Object v = re.getValueInVM(owner);
+                      event.setOldValue(v); // OFFHEAP escapes to EntryEventImpl oldValue
-    EntryEventImpl cbEvent = null;
+    @Released EntryEventImpl cbEvent = null;
-                    try {
-                    } finally {
-                      OffHeapHelper.release(oldValue);
-                    }
-    if (event.isFetchFromHDFS()) {
-      retVal = getEntry(event);
-    } else {
-      retVal = getEntryInVM(key);
-    }
+    retVal = getEntry(event);
-  protected static final MapCallbackAdapter<Object, Object, Object, Object>
-      listOfDeltasCreator = new MapCallbackAdapter<Object, Object,
-          Object, Object>() {
-    @Override
-    public Object newValue(Object key, Object context, Object createParams,
-        final MapResult result) {
-      return new ListOfDeltas(4);
-    }
-  };
-  
-  /**
-   * Neeraj: The below if block is to handle the special
-   * scenario witnessed in Sqlfabric for now. (Though its
-   * a general scenario). The scenario is that the updates start coming 
-   * before the base value reaches through GII. In that scenario the updates
-   * essentially the deltas are added to a list and kept as oldValue in the
-   * map and this method returns. When through GII the actual base value arrives
-   * these updates or deltas are applied on it and the new value thus got is put
-   * in the map.
-   * @param event 
-   * @param ifOld 
-   * @return true if delta was enqued
-   */
-  private boolean enqueDelta(EntryEventImpl event, boolean ifOld) {
-    final IndexUpdater indexManager = getIndexUpdater();
-    LocalRegion owner = _getOwner();
-    if (indexManager != null && !owner.isInitialized() && event.hasDelta()) {
-      boolean isOldValueDelta = true;
-      try {
-        if (ifOld) {
-          final Delta delta = event.getDeltaNewValue();
-		  RegionEntry re = getOrCreateRegionEntry(owner, event, null,
-          	  listOfDeltasCreator, false, false);
-          assert re != null;
-          synchronized (re) {
-            @Retained @Released Object oVal = re.getValueOffHeapOrDiskWithoutFaultIn(owner);
-            if (oVal != null) {
-              try {
-              if (oVal instanceof ListOfDeltas) {
-                if (logger.isDebugEnabled()) {
-                  logger.debug("basicPut: adding delta to list of deltas: {}", delta);
-                }
-                ((ListOfDeltas)oVal).merge(delta);
-                @Retained Object newVal = ((AbstractRegionEntry)re).prepareValueForCache(owner, oVal, true);              
-                re.setValue(owner, newVal); // TODO:KIRK:48068 prevent orphan
-              }
-              else {
-                isOldValueDelta = false;
-              }
-              }finally {
-                OffHeapHelper.release(oVal);
-              }
-            }
-            else {
-              if (logger.isDebugEnabled()) {
-                logger.debug("basicPut: new list of deltas with delta: {}", delta);
-              }
-              @Retained Object newVal = new ListOfDeltas(delta);
-              // TODO no need to call AbstractRegionMap.prepareValueForCache here?
-              newVal = ((AbstractRegionEntry)re).prepareValueForCache(owner, newVal, true);
-              re.setValue(owner, newVal); // TODO:KIRK:48068 prevent orphan
-            }
-          }
-        }
-      } catch (RegionClearedException ex) {
-        // Neeraj: We can just ignore this exception because we are returning after this block
-      }
-      if (isOldValueDelta) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-    // SqlFabric Changes - BEGIN
-    if (enqueDelta(event, ifOld)) {
-      return null;
-    }
-
-    final IndexUpdater indexManager = getIndexUpdater();
-
-    boolean sqlfIndexLocked = false;
-    // SqlFabric Changes - END
-
-      // take read lock for SQLF index initializations if required; the index
-      // GII lock is for any updates that may come in while index is being
-      // loaded during replay see bug #41377; this will go away once we allow
-      // for indexes to be loaded completely in parallel (#40899); need to
-      // take this lock before the RegionEntry lock else a deadlock can happen
-      // between this thread and index loading thread that will first take the
-      // corresponding write lock on the IndexUpdater
-      if (indexManager != null) {
-        sqlfIndexLocked = indexManager.lockForIndexGII();
-      }
-          throwExceptionForSqlFire(event);
-                throwExceptionForSqlFire(event);
-                    owner.cleanUpOnIncompleteOp(event, re, eventRecorded,
-                        false/* updateStats */, replaceOnClient);
+                    owner.cleanUpOnIncompleteOp(event, re);
-                  long startTime= stats.startCustomEviction();
-                  CustomEvictionAttributes csAttr = br.getCustomEvictionAttributes();
-                  // No need to update indexes if entry was faulted in but operation did not succeed. 
-                  if (csAttr != null && (csAttr.isEvictIncoming() || re.isMarkedForEviction())) {
-                    
-                    if (csAttr.getCriteria().doEvict(event)) {
-                      stats.incEvictionsInProgress();
-                      // set the flag on event saying the entry should be evicted 
-                      // and not indexed
-                      EntryEventImpl destroyEvent = EntryEventImpl.create (owner, Operation.DESTROY, event.getKey(),
-                          null/* newValue */, null, false, owner.getMyId());
-                      try {
-
-                      destroyEvent.setOldValueFromRegion();
-                      destroyEvent.setCustomEviction(true);
-                      destroyEvent.setPossibleDuplicate(event.isPossibleDuplicate());
-                      if(logger.isDebugEnabled()) {
-                        logger.debug("Evicting the entry " + destroyEvent);
-                      }
-                      if(result != null) {
-                        removeEntry(event.getKey(),re, true, destroyEvent,owner, indexUpdater);
-                      }
-                      else{
-                        removeEntry(event.getKey(),re, true, destroyEvent,owner, null);
-                      }
-                      //mark the region entry for this event as evicted 
-                      event.setEvicted();
-                      stats.incEvictions();
-                      if(logger.isDebugEnabled()) {
-                        logger.debug("Evicted the entry " + destroyEvent);
-                      }
-                      //removeEntry(event.getKey(), re);
-                      } finally {
-                        destroyEvent.release();
-                        stats.decEvictionsInProgress();
-                      }
-                    } else {
-                      re.clearMarkedForEviction();
-                    }
-                  }
-                  stats.endCustomEviction(startTime);
-        if (sqlfIndexLocked) {
-          indexManager.unlockForIndexGII();
-        }
-          } catch (EntryExistsException eee) {
-            // SQLFabric changes BEGIN
-            // ignore EntryExistsException in distribution from a non-empty
-            // region since actual check will be done in this put itself
-            // and it can happen in distribution if put comes in from
-            // GII as well as distribution channel
-            if (indexManager != null) {
-              if (logger.isTraceEnabled()) {
-                logger.trace("basicPut: ignoring EntryExistsException in distribution {}", eee);
-              }
-            }
-            else {
-              // can this happen for non-SQLFabric case?
-              throw eee;
-            }
-            // SQLFabric changes END
-  // Asif: If the new value is an instance of SerializableDelta, then
-  // the old value requirement is a must & it needs to be faulted in
-  // if overflown to disk without affecting LRU? This is needed for
-  // Sql Fabric.
-  // [sumedh] store both the value in VM and the value in VM or disk;
-  // the former is used for updating the VM size calculations, while
-  // the latter is used in other places like passing to
-  // SqlfIndexManager or setting the old value in the event; this is
-  // required since using the latter for updating the size
-  // calculations will be incorrect in case the value was read from
-  // disk but not brought into the VM like what getValueInVMOrDisk
-  // method does when value is not found in VM
-    boolean needToSetOldValue = getIndexUpdater() != null || cacheWrite || requireOldValue || event.getOperation().guaranteesOldValue();
+    boolean needToSetOldValue = cacheWrite || requireOldValue || event.getOperation().guaranteesOldValue();
-      if (event.hasDelta() || event.getOperation().guaranteesOldValue()
-          || GemFireCacheImpl.sqlfSystem()) {
+      if (event.getOperation().guaranteesOldValue()) {
-          event.setOldValue(oldValueInVMOrDisk, requireOldValue
-              || GemFireCacheImpl.sqlfSystem());
+          event.setOldValue(oldValueInVMOrDisk, requireOldValue);
-          event.setOldValue(oldValueInVM,
-              requireOldValue || GemFireCacheImpl.sqlfSystem());
+          event.setOldValue(oldValueInVM, requireOldValue);
-  /**
-   * Asif: If the system is sqlfabric and the event has delta, then re == null 
-   * implies update on non existent row . Throwing ENFE in that case 
-   * As  returning a boolean etc has other complications in terms of PR reattempt etc  
-   */
-  private void throwExceptionForSqlFire(EntryEventImpl event) {
-    if (event.hasDelta() && _getOwner().getGemFireCache().isSqlfSystem()) {
-      throw new EntryNotFoundException(
-          "SqlFabric::No row found for update");
-    }
-  }
-
-    EntryEventImpl cbEvent = null;
-    EntryEventImpl sqlfEvent = null;
+    @Released EntryEventImpl cbEvent = null;
-    if (/*owner.isUsedForPartitionedRegionBucket() && */ 
-       (getIndexUpdater() != null ||
-       (newValue instanceof com.gemstone.gemfire.internal.cache.delta.Delta))) {
-      sqlfEvent = createCBEvent(owner, putOp, key, newValue, txId, 
-          txEvent, eventId, aCallbackArgument,filterRoutingInfo,bridgeContext, txEntryState, versionTag, tailKey);
-    }
-                  if (sqlfEvent != null) {
-                    sqlfEvent.setOldValue(re.getValueInVM(owner)); // OFFHEAP eei
-                  }
-                      // Rahul: applies the delta and sets the new value in 
-                      // region entry (required for sqlfabric delta).
-                      if (newValue instanceof com.gemstone.gemfire.internal.cache.delta.Delta 
-                          && sqlfEvent != null) {
-                        //cbEvent.putExistingEntry(owner, re);
-                        sqlfEvent.putExistingEntry(owner, re);
-                      } else {
+                      {
-                        if (sqlfEvent != null) {
-                          owner.updateSizeOnPut(key, oldSize, sqlfEvent.getNewValueBucketSize());
-                        } else {
+                        {
-                  if (sqlfEvent != null) {
-                    sqlfEvent.setOldValue(oldRe.getValueInVM(owner)); // OFFHEAP eei
-                  }
-                      if (newValue instanceof com.gemstone.gemfire.internal.cache.delta.Delta 
-                          && sqlfEvent != null ) {
-                        //cbEvent.putExistingEntry(owner, oldRe);
-                        sqlfEvent.putExistingEntry(owner, oldRe);
-                      } else {
+                      {
-                        if (sqlfEvent != null) {
-                          owner.updateSizeOnPut(key, oldSize, sqlfEvent.getNewValueBucketSize());
-                        } else {
+                        {
-                  if (sqlfEvent != null ) {
-                    sqlfEvent.putNewEntry(owner,newRe);
-                  } else {
+                  {
-      if (sqlfEvent != null) sqlfEvent.release();
+  @Retained
-    EntryEventImpl retVal = EntryEventImpl.create(
+    @Retained EntryEventImpl retVal = EntryEventImpl.create(
-  public final void unscheduleTombstone(RegionEntry re) {
-  }
-  
-    RegionEntry actualRe = getEntry(re.getKey());
-    if (actualRe != re) {  // null actualRe is okay here
-      return true; // tombstone was evicted at some point
+    if ( getEntry(re.getKey()) != re) {
+      // region entry was either removed (null)
+      // or changed to a different region entry.
+      // In either case the old tombstone is no longer needed.
+      return true;
-    VersionStamp vs = re.getVersionStamp();
+    if (!re.isTombstone()) {
+      // if the region entry no longer contains a tombstone
+      // then the old tombstone is no longer needed
+      return true;
+    }
+    VersionStamp<?> vs = re.getVersionStamp();
-    int entryVersion = vs.getEntryVersion();
-    boolean isSameTombstone = (entryVersion == destroyedVersion && re.isTombstone());
-    return !isSameTombstone;
+    if (vs.getEntryVersion() != destroyedVersion) {
+      // the version changed so old tombstone no longer needed
+      return true;
+    }
+    // region entry still has the same tombstone so we need to keep it.
+    return false;
-          boolean isTombstone = re.isTombstone();
-          boolean isSameTombstone = (entryVersion == destroyedVersion && isTombstone);
-          if (isSameTombstone || (isTombstone && entryVersion < destroyedVersion)) {
+          if (!re.isTombstone() || entryVersion > destroyedVersion) {
-              // logs are at info level for TomstoneService.DEBUG_TOMBSTONE_COUNT so customer doesn't have to use fine level
-              if (isSameTombstone) {
+              logger.trace(LogMarker.TOMBSTONE_COUNT,
+                  "tombstone for {} was resurrected with v{}; destroyed version was v{}; count is {}; entryMap size is {}",
+                  re.getKey(), re.getVersionStamp().getEntryVersion(), destroyedVersion, this._getOwner().getTombstoneCount(), size());
+            }
+          } else {
+            if (logger.isTraceEnabled(LogMarker.TOMBSTONE_COUNT)) {
+              if (entryVersion == destroyedVersion) {
-          } else {
-            if (logger.isTraceEnabled(LogMarker.TOMBSTONE_COUNT)) {
-              logger.trace(LogMarker.TOMBSTONE_COUNT,
-                  "tombstone for {} was resurrected with v{}; destroyed version was v{}; count is {}; entryMap size is {}",
-                  re.getKey(), re.getVersionStamp().getEntryVersion(), destroyedVersion, this._getOwner().getTombstoneCount(), size());
-            }

MOV26 MOV26 MOV26 MOV26 MOV31 MOV31 UPD40 UPD40 UPD40 UPD40 INS8 MOV43 INS42 MOV44 MOV78 INS83 MOV43 INS42 MOV44 INS8 MOV8 MOV8 MOV8 MOV78 UPD66 MOV21 INS25 MOV25 MOV60 MOV25 MOV60 MOV60 MOV21 MOV60 MOV60 MOV60 MOV21 MOV60 MOV60 MOV21 MOV60 MOV60 MOV60 MOV60 MOV60 MOV25 MOV21 INS54 MOV21 INS25 INS25 MOV41 MOV27 MOV8 MOV27 MOV8 MOV12 MOV8 INS27 MOV78 MOV8 MOV12 MOV8 MOV25 MOV78 MOV43 MOV78 MOV8 INS38 INS8 INS74 INS27 MOV8 MOV60 INS40 INS45 MOV27 MOV32 INS32 INS41 MOV43 INS76 MOV32 INS42 MOV27 MOV8 INS25 MOV32 INS42 INS8 MOV8 MOV27 MOV8 INS42 INS42 MOV32 MOV42 MOV42 INS9 INS25 MOV25 MOV27 MOV8 INS25 MOV42 MOV42 UPD42 MOV60 MOV60 INS51 MOV8 INS27 INS8 INS8 MOV60 MOV60 MOV60 MOV25 MOV60 MOV54 MOV27 INS8 INS42 MOV8 INS42 INS33 INS41 INS51 MOV25 MOV59 INS60 MOV54 INS38 UPD27 MOV27 INS9 INS42 INS8 UPD42 MOV78 MOV43 MOV59 INS8 MOV8 INS32 INS25 INS21 MOV60 INS61 MOV25 MOV25 INS42 INS42 INS42 INS42 MOV27 MOV8 MOV32 MOV27 INS8 MOV27 MOV27 MOV60 MOV60 MOV60 MOV60 UPD42 UPD42 INS51 MOV78 MOV43 INS8 INS42 INS8 INS25 MOV25 MOV21 MOV21 MOV25 MOV21 MOV25 MOV60 INS54 MOV21 MOV25 MOV25 MOV25 INS25 INS25 MOV27 MOV8 MOV8 MOV12 MOV38 MOV21 MOV32 MOV8 MOV8 MOV8 MOV60 MOV60 MOV21 INS21 INS21 UPD42 MOV42 MOV32 UPD42 MOV42 INS32 MOV21 MOV60 MOV60 MOV60 MOV21 MOV21 MOV21 MOV8 INS42 MOV8 INS32 INS32 MOV42 MOV42 INS42 INS42 MOV32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 MOV42 MOV25 UPD42 MOV42 MOV38 MOV38 INS8 MOV8 INS42 MOV54 MOV27 UPD42 MOV42 UPD42 MOV42 MOV8 MOV42 UPD42 MOV42 UPD42 MOV42 MOV8 INS25 MOV8 MOV25 MOV8 MOV25 MOV21 MOV21 MOV25 MOV25 MOV21 MOV25 MOV60 MOV60 MOV8 MOV21 MOV21 MOV25 MOV21 MOV21 MOV21 MOV32 MOV8 MOV8 MOV32 MOV8 MOV25 MOV32 MOV8 MOV25 UPD42 MOV42 UPD42 MOV42 MOV32 MOV8 MOV60 MOV32 MOV32 MOV42 MOV42 MOV42 MOV32 MOV42 MOV9 INS60 MOV8 MOV8 MOV32 UPD42 MOV42 INS43 INS59 MOV38 INS42 INS42 INS32 MOV32 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL33 DEL27 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL8 DEL25 DEL8 DEL83 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL42 DEL43 DEL42 DEL40 DEL59 DEL60 DEL42 DEL43 DEL76 DEL74 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL45 DEL42 DEL43 DEL85 DEL5 DEL40 DEL40 DEL40 DEL42 DEL43 DEL57 DEL42 DEL43 DEL57 DEL4 DEL3 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL33 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL4 DEL3 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL45 DEL45 DEL27 DEL42 DEL1 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL8 DEL25 DEL83 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL25 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL33 DEL41 DEL8 DEL25 DEL42 DEL42 DEL32 DEL38 DEL27 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL38 DEL27 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL27 DEL42 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL42 DEL33 DEL27 DEL45 DEL6 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL27 DEL36 DEL27 DEL42 DEL42 DEL32 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL27 DEL36 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL42 DEL9 DEL7 DEL21 DEL18 DEL8 DEL25 DEL42 DEL78 DEL42 DEL43 DEL42 DEL33 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL9 DEL32 DEL21 DEL32 DEL21 DEL42 DEL42 DEL9 DEL42 DEL32 DEL21 DEL42 DEL25 DEL42 DEL51 DEL8 DEL60 DEL8 DEL25 DEL25 DEL25 DEL8 DEL54 DEL8 DEL45 DEL42 DEL78 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL42 DEL78 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL25 DEL42 DEL51 DEL42 DEL42 DEL61 DEL8 DEL54 DEL8 DEL51 DEL8 DEL25 DEL8 DEL54 DEL8 DEL42 DEL42 DEL32 DEL8 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL34 DEL14 DEL41 DEL8 DEL31 DEL1 DEL14 DEL59 DEL23 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL83 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL38 DEL27 DEL42 DEL42 DEL32 DEL27 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL33 DEL42 DEL9 DEL9 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL6 DEL42 DEL42 DEL78 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL42 DEL9 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL51 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL42 DEL25 DEL8 DEL25 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL33 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL33 DEL41 DEL8 DEL25 DEL42 DEL9 DEL42 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL36 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL40 DEL42 DEL42 DEL32 DEL33 DEL33 DEL9 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL32 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL9 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL42 DEL9 DEL42 DEL42 DEL33 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL53 DEL8 DEL25 DEL8 DEL12 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL33 DEL27 DEL42 DEL27 DEL42 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL8 DEL31 DEL42 DEL43 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL32 DEL33 DEL27 DEL42 DEL40 DEL43 DEL62 DEL36 DEL27 DEL36 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL40 DEL43 DEL62 DEL42 DEL33 DEL27 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL42 DEL40 DEL43 DEL62 DEL42 DEL33 DEL27 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL25 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL39 DEL42 DEL59 DEL60 DEL39 DEL42 DEL32 DEL27 DEL36 DEL59 DEL60 DEL42 DEL38 DEL41 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL27 DEL42 DEL27 DEL36 DEL59 DEL60 DEL42 DEL42 DEL27 DEL36 DEL42
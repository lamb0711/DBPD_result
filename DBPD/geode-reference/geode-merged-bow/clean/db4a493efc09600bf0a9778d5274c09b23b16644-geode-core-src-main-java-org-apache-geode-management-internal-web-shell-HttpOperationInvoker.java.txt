GEODE-3685: MBean wrappers are properly invoked over http

This closes #838.

-import java.io.BufferedReader;
-import java.io.InputStreamReader;
+import org.apache.commons.lang.StringUtils;
-import org.springframework.http.HttpStatus;
-import org.springframework.web.client.ResponseErrorHandler;
-import org.apache.geode.internal.lang.StringUtils;
-import org.apache.geode.security.AuthenticationFailedException;
-import org.apache.geode.security.NotAuthorizedException;
-  protected static final long DEFAULT_INITIAL_DELAY = TimeUnit.SECONDS.toMillis(1);
-  protected static final long DEFAULT_PERIOD = TimeUnit.MILLISECONDS.toMillis(2000);
+  private static final long DEFAULT_INITIAL_DELAY = TimeUnit.SECONDS.toMillis(1);
+  private static final long DEFAULT_PERIOD = TimeUnit.MILLISECONDS.toMillis(2000);
-  protected static final String REST_API_BASE_URL = "http://localhost:8080";
-  protected static final String REST_API_VERSION = "/v1";
-  protected static final String REST_API_WEB_APP_CONTEXT = "/geode-mgmt";
-  protected static final String REST_API_URL =
+  private static final String REST_API_BASE_URL = "http://localhost:8080";
+  private static final String REST_API_VERSION = "/v1";
+  private static final String REST_API_WEB_APP_CONTEXT = "/geode-mgmt";
+  private static final String REST_API_URL =
-  protected static final String USER_AGENT_HTTP_REQUEST_HEADER_VALUE =
+  private static final String USER_AGENT_HTTP_REQUEST_HEADER_VALUE =
-  protected static final TimeUnit DEFAULT_TIME_UNIT = TimeUnit.MILLISECONDS;
+  private static final TimeUnit DEFAULT_TIME_UNIT = TimeUnit.MILLISECONDS;
-  protected static final String RESOURCES_REQUEST_PARAMETER = "resources";
+  private static final String RESOURCES_REQUEST_PARAMETER = "resources";
-  HttpOperationInvoker(final String baseUrl) {
+  private HttpOperationInvoker(final String baseUrl) {
-   * via HTTP for procsessing along with the base URL to the GemFire Manager's embedded HTTP service
+   * via HTTP for processing along with the base URL to the GemFire Manager's embedded HTTP service
-    // add our custom HttpMessageConverter for serializing DTO Objects into the HTTP request message
-    // body
-    // and de-serializing HTTP response message body content back into DTO Objects
+    // add our custom HttpMessageConverter for serializing DTO Objects into the HTTP request
+    // message body and de-serializing HTTP response message body content back into DTO Objects
-    this.restTemplate.setErrorHandler(new ResponseErrorHandler() {
-      @Override
-      public boolean hasError(final ClientHttpResponse response) throws IOException {
-        final HttpStatus status = response.getStatusCode();
+    this.restTemplate.setErrorHandler(new RestOperationErrorHandler(gfsh));
-        switch (status) {
-          case BAD_REQUEST: // 400 *
-          case UNAUTHORIZED: // 401
-          case FORBIDDEN: // 403
-          case NOT_FOUND: // 404 *
-          case METHOD_NOT_ALLOWED: // 405 *
-          case NOT_ACCEPTABLE: // 406 *
-          case REQUEST_TIMEOUT: // 408
-          case CONFLICT: // 409
-          case REQUEST_ENTITY_TOO_LARGE: // 413
-          case REQUEST_URI_TOO_LONG: // 414
-          case UNSUPPORTED_MEDIA_TYPE: // 415 *
-          case TOO_MANY_REQUESTS: // 429
-          case INTERNAL_SERVER_ERROR: // 500 *
-          case NOT_IMPLEMENTED: // 501
-          case BAD_GATEWAY: // 502 ?
-          case SERVICE_UNAVAILABLE: // 503
-            return true;
-          default:
-            return false;
-        }
-      }
-
-      @Override
-      public void handleError(final ClientHttpResponse response) throws IOException {
-        String body = readBody(response);
-        final String message = String.format("The HTTP request failed with: %1$d - %2$s.",
-            response.getRawStatusCode(), body);
-
-        if (gfsh.getDebug()) {
-          gfsh.logSevere(body, null);
-        }
-
-        if (response.getRawStatusCode() == 401) {
-          throw new AuthenticationFailedException(message);
-        } else if (response.getRawStatusCode() == 403) {
-          throw new NotAuthorizedException(message);
-        } else {
-          throw new RuntimeException(message);
-        }
-      }
-
-      private String readBody(final ClientHttpResponse response) throws IOException {
-        BufferedReader responseBodyReader = null;
-
-        try {
-          responseBodyReader = new BufferedReader(new InputStreamReader(response.getBody()));
-
-          final StringBuilder buffer = new StringBuilder();
-          String line;
-
-          while ((line = responseBodyReader.readLine()) != null) {
-            buffer.append(line).append(StringUtils.LINE_SEPARATOR);
-          }
-
-          return buffer.toString().trim();
-        } finally {
-          IOUtils.close(responseBodyReader);
-        }
-      }
-    });
-  protected void setupBackgroundPingRequest() {
+  private void setupBackgroundPingRequest() {
-  protected ScheduledExecutorService getExecutorService() {
+  private ScheduledExecutorService getExecutorService() {
-  protected RestTemplate getRestTemplate() {
+  private RestTemplate getRestTemplate() {
-  protected void printDebug(final String message, final Object... args) {
+  private void printDebug(final String message, final Object... args) {
-  void addHeaderValues(org.springframework.http.client.ClientHttpRequest request)
-      throws IOException {
+  private void addHeaderValues(org.springframework.http.client.ClientHttpRequest request) {
-  protected void initClusterId() {
+  private void initClusterId() {
-    MultiValueMap<String, Object> content = new LinkedMultiValueMap<String, Object>();
+    MultiValueMap<String, Object> content = new LinkedMultiValueMap<>();
-      return IOUtils
-          .deserializeObject(post(link, MediaType.MULTIPART_FORM_DATA, content, byte[].class));
+      byte[] postResult = post(link, MediaType.MULTIPART_FORM_DATA, content, byte[].class);
+      return IOUtils.deserializeObject(postResult);
-      MultiValueMap<String, Object> content = new LinkedMultiValueMap<String, Object>();
+      MultiValueMap<String, Object> content = new LinkedMultiValueMap<>();

MOV26 UPD40 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 UPD83 INS83 UPD83 UPD83 UPD83 UPD83 INS83 UPD83 INS60 UPD66 MOV74 INS59 INS42 INS14 INS60 MOV60 UPD43 INS42 INS74 INS5 INS59 UPD42 MOV43 INS39 INS85 INS42 MOV32 INS42 UPD74 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL42 DEL78 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL49 DEL42 DEL49 DEL42 DEL49 DEL42 DEL49 DEL42 DEL49 DEL42 DEL49 DEL42 DEL49 DEL42 DEL49 DEL42 DEL49 DEL42 DEL49 DEL42 DEL49 DEL42 DEL49 DEL42 DEL49 DEL42 DEL49 DEL42 DEL49 DEL42 DEL49 DEL9 DEL41 DEL49 DEL9 DEL41 DEL50 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL33 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL42 DEL42 DEL32 DEL34 DEL27 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL42 DEL43 DEL42 DEL14 DEL53 DEL8 DEL25 DEL25 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL14 DEL14 DEL7 DEL21 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL7 DEL36 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL21 DEL8 DEL61 DEL42 DEL42 DEL32 DEL42 DEL32 DEL41 DEL8 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL1 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60
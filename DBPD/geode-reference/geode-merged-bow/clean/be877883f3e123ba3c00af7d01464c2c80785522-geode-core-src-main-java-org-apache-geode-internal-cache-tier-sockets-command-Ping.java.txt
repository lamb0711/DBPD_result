GEODE-7565: Allow gateway receivers with same host and port (2nd try)

This reverts the revert of the original commit, adds extra tests and
also fixes the originally introduced issues.

----

There was a problem with Geode WAN replication when GW receivers are
configured with the same hostname-for-senders and port on all servers.
The reason for such a setup is deploying Geode cluster on a Kubernetes
cluster where all GW receivers are reachable from the outside world on
the same VIP and port.

The problem experienced is that shutting down one server is stopping
replication to this cluster until the server is up again. This is
because Geode incorrectly assumes there are no more alive servers when
just one of them is down, because since they share hostname-for-senders
and port, they are treated as one same server.

With these changes locator is able to distinguish the different
receivers using the same hostname and port so replication is not
impacted when one server is stopped.
+import org.apache.geode.cache.client.ServerOperationException;
+import org.apache.geode.distributed.DistributedMember;
-import org.apache.geode.internal.cache.tier.CachedRegionHelper;
+import org.apache.geode.distributed.internal.membership.InternalDistributedMember;
+import org.apache.geode.internal.cache.DistributedPingMessage;
+  protected ClientHealthMonitor getClientHealthMonitor() {
+    return ClientHealthMonitor.getInstance();
+  }
+
-    ClientHealthMonitor chm = ClientHealthMonitor.getInstance();
-    if (chm != null)
+    if (clientMessage.getNumberOfParts() > 0) {
+      try {
+        InternalDistributedMember targetServer =
+            (InternalDistributedMember) clientMessage.getPart(0).getObject();
+        InternalDistributedMember myID = serverConnection.getCache().getMyId();
+        if (!myID.equals(targetServer)) {
+          if (myID.compareTo(targetServer, true, false) == 0) {
+            String errorMessage =
+                "Target server " + targetServer + " has different viewId: " + myID;
+            logger.warn(errorMessage);
+            writeException(clientMessage, new ServerOperationException(errorMessage), false,
+                serverConnection);
+            serverConnection.setAsTrue(RESPONDED);
+            return;
+          }
+
+          pingCorrectServer(clientMessage, targetServer, serverConnection);
+          serverConnection.setAsTrue(RESPONDED);
+          return;
+        }
+      } catch (ClassNotFoundException e) {
+        logger.warn("Unable to deserialize message from " + serverConnection.getProxyID());
+        writeException(clientMessage, e, false, serverConnection);
+        serverConnection.setAsTrue(RESPONDED);
+        return;
+      }
+    }
+    ClientHealthMonitor chm = getClientHealthMonitor();
+    if (chm != null) {
-    CachedRegionHelper crHelper = serverConnection.getCachedRegionHelper();
+    }
+  /**
+   * Process a ping request that was sent to the wrong server
+   */
+  protected void pingCorrectServer(Message clientMessage, DistributedMember targetServer,
+      ServerConnection serverConnection)
+      throws IOException {
+    if (logger.isDebugEnabled()) {
+      logger.debug("Received a Ping request from {} intended for {}. Forwarding the ping...",
+          serverConnection.getProxyID(), targetServer);
+    }
+    if (!serverConnection.getCache().getDistributionManager().isCurrentMember(targetServer)) {
+      String errorMessage = "Unable to ping non-member " + targetServer + " for client "
+          + serverConnection.getProxyID();
+      logger.warn(errorMessage);
+      writeException(clientMessage, new ServerOperationException(errorMessage), false,
+          serverConnection);
+      serverConnection.setAsTrue(RESPONDED);
+    } else {
+      // send a ping message to the server. This is a one-way message that doesn't send a reply
+      final DistributedPingMessage distributedPingMessage =
+          new DistributedPingMessage(targetServer, serverConnection.getProxyID());
+      serverConnection.getCache().getDistributionManager().putOutgoing(distributedPingMessage);
+      writeReply(clientMessage, serverConnection);
+    }
+  }
+

INS26 INS26 INS26 INS40 INS40 INS40 UPD40 INS31 INS31 INS83 MOV43 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS43 INS8 INS41 INS25 INS60 INS65 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS25 INS25 MOV32 INS27 INS8 INS43 INS59 INS8 INS66 INS42 INS42 INS42 INS32 INS8 INS38 INS8 INS8 INS32 INS34 INS54 INS42 INS42 INS32 MOV21 INS42 INS42 INS21 INS32 INS60 INS21 INS21 INS21 INS60 INS21 INS21 INS42 INS42 INS8 INS12 INS42 INS32 INS32 INS42 INS42 INS43 INS59 INS32 INS32 INS32 INS83 INS43 INS59 INS32 INS32 MOV60 MOV60 INS25 INS44 INS8 INS42 INS42 INS45 INS32 INS42 INS32 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS14 INS9 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS32 INS42 INS42 INS42 INS42 INS42 INS43 UPD43 INS38 INS8 INS43 INS42 INS21 INS21 INS21 INS41 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS32 INS43 INS42 INS43 INS42 INS32 INS32 INS42 INS42 INS42 INS11 UPD42 UPD42 INS32 INS32 INS25 INS21 INS21 INS41 INS42 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS32 INS32 INS42 INS42 INS42 INS42 INS27 INS8 INS32 INS32 INS42 INS42 INS27 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS42 INS42 INS32 INS42 MOV42 UPD42 MOV42 INS32 INS34 INS60 INS21 INS21 INS21 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 INS32 INS42 INS42 INS34 INS42 INS42 INS42 INS9 INS9 INS43 INS59 INS32 INS32 INS32 INS42 INS42 INS42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 INS14 INS9 INS42 INS42 INS42 INS42 INS45 INS42 INS45 INS42 INS43 INS42 INS42 DEL42 DEL32
Merge branch 'release/1.8.0'

-import java.util.concurrent.ThreadFactory;
-import org.apache.geode.i18n.StringId;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.LoggingThreadGroup;
+import org.apache.geode.internal.logging.LoggingExecutors;
+import org.apache.geode.internal.logging.LoggingThread;
+import org.apache.geode.internal.logging.LoggingUncaughtExceptionHandler;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
-import org.apache.geode.internal.util.concurrent.StoppableReentrantLock;
-  /**
-   * Mutex to control access to {@link #waitingForElderChange} or {@link #elder}.
-   */
-  private final Object elderMonitor = new Object();
+  private final Stopper stopper = new Stopper(this);
-  /**
-   * Must be read/written while holding {@link #elderMonitor}
-   *
-   * @see #elderChangeWait()
-   */
-  private boolean waitingForElderChange = false;
-
-  /**
-   * @see DistributionManager#isAdam()
-   */
-  private boolean adam = false;
-
-  /**
-   * This is the "elder" member of the distributed system, responsible for certain types of
-   * arbitration.
-   *
-   * Must hold {@link #elderMonitor} in order to change this.
-   *
-   * @see #getElderId()
-   */
-  protected volatile InternalDistributedMember elder = null;
+  private final ClusterElderManager clusterElderManager = new ClusterElderManager(this);
-  /** The group of distribution manager threads */
-  protected LoggingThreadGroup threadGroup;
-
-  private ThreadPoolExecutor threadPool;
+  private ExecutorService threadPool;
-  private ThreadPoolExecutor highPriorityPool;
+  private ExecutorService highPriorityPool;
-  private ThreadPoolExecutor waitingPool;
+  private ExecutorService waitingPool;
-  private ThreadPoolExecutor prMetaDataCleanupThreadPool;
+  private ExecutorService prMetaDataCleanupThreadPool;
-  private ThreadPoolExecutor partitionedRegionThread;
-  private ThreadPoolExecutor partitionedRegionPool;
+  private ExecutorService partitionedRegionThread;
+  private ExecutorService partitionedRegionPool;
-  private ThreadPoolExecutor functionExecutionThread;
-  private ThreadPoolExecutor functionExecutionPool;
+  private ExecutorService functionExecutionThread;
+  private ExecutorService functionExecutionPool;
-  private ThreadPoolExecutor serialThread;
+  private ExecutorService serialThread;
-  private ThreadPoolExecutor viewThread;
+  private ExecutorService viewThread;
-              // SO once we find ourself break out of this loop.
+              // SO once we find ourselves break out of this loop.
-        distributionManager.selectElder(); // ShutdownException could be thrown here
-          // We'll we didn't hear back from anyone else. We assume that
+          // Well we didn't hear back from anyone else. We assume that
-            logger.info(LocalizedMessage.create(
-                LocalizedStrings.DistributionManager_DIDNT_HEAR_BACK_FROM_ANY_OTHER_SYSTEM_I_AM_THE_FIRST_ONE));
+            logger.info("Did not hear back from any other system. I am the first one.");
-              logger.warn(LocalizedMessage.create(
-                  LocalizedStrings.DistributionManager_RECEIVED_NO_STARTUP_RESPONSES_BUT_OTHER_MEMBERS_EXIST_MULTICAST_IS_NOT_RESPONSIVE));
+              logger.warn(
+                  "Did not receive a startup response but other members exist.  Multicast does not seem to be working.");
-            LocalizedStrings.DistributionManager_INTERRUPTED_WHILE_WAITING_FOR_FIRST_STARTUPRESPONSEMESSAGE
-                .toLocalizedString(),
+            "Interrupted while waiting for first StartupResponseMessage",
-            LocalizedMessage.create(
-                LocalizedStrings.DistributionManager_DISTRIBUTIONMANAGER_0_STARTED_ON_1_THERE_WERE_2_OTHER_DMS_3_4_5,
-                logArgs));
+            "DistributionManager {} started on {}. There were {} other DMs. others: {} {} {}",
+            logArgs);
-    this.elderLock = new StoppableReentrantLock(stopper);
-    // Start the processing threads
-    final LoggingThreadGroup group =
-        LoggingThreadGroup.createThreadGroup("DistributionManager Threads", logger);
-    this.threadGroup = group;
-
-            new SerialQueuedExecutorPool(this.threadGroup, this.stats, throttlingDisabled,
-                this.threadMonitor);
+            new SerialQueuedExecutorPool(this.stats, throttlingDisabled, this.threadMonitor);
-        ThreadFactory tf = new ThreadFactory() {
-          @Override
-          public Thread newThread(final Runnable command) {
-            ClusterDistributionManager.this.stats.incSerialThreadStarts();
-            final Runnable r = new Runnable() {
-              @Override
-              public void run() {
-                ClusterDistributionManager.this.stats.incNumSerialThreads(1);
-                try {
-                  ConnectionTable.threadWantsSharedResources();
-                  Connection.makeReaderThread();
-                  runUntilShutdown(command);
-                  // command.run();
-                } finally {
-                  ConnectionTable.releaseThreadsSockets();
-                  ClusterDistributionManager.this.stats.incNumSerialThreads(-1);
-                }
-              }
-            };
-            Thread thread = new Thread(group, r,
-                LocalizedStrings.DistributionManager_SERIAL_MESSAGE_PROCESSOR.toLocalizedString());
-            thread.setDaemon(true);
-            return thread;
-          }
-        };
+        this.serialThread = LoggingExecutors.newSerialThreadPool("Serial Message Processor",
+            thread -> stats.incSerialThreadStarts(),
+            this::doSerialThread, this.stats.getSerialProcessorHelper(),
+            threadMonitor, poolQueue);
-        this.serialThread = new SerialQueuedExecutorWithDMStats(poolQueue,
-            this.stats.getSerialProcessorHelper(), tf, threadMonitor);
-      }
-      {
-        BlockingQueue q = new LinkedBlockingQueue();
-        ThreadFactory tf = new ThreadFactory() {
-          @Override
-          public Thread newThread(final Runnable command) {
-            ClusterDistributionManager.this.stats.incViewThreadStarts();
-            final Runnable r = new Runnable() {
-              @Override
-              public void run() {
-                ClusterDistributionManager.this.stats.incNumViewThreads(1);
-                try {
-                  ConnectionTable.threadWantsSharedResources();
-                  Connection.makeReaderThread();
-                  runUntilShutdown(command);
-                } finally {
-                  ConnectionTable.releaseThreadsSockets();
-                  ClusterDistributionManager.this.stats.incNumViewThreads(-1);
-                }
-              }
-            };
-            Thread thread = new Thread(group, r,
-                LocalizedStrings.DistributionManager_VIEW_MESSAGE_PROCESSOR.toLocalizedString());
-            thread.setDaemon(true);
-            return thread;
-          }
-        };
-        this.viewThread = new SerialQueuedExecutorWithDMStats(q,
-            this.stats.getViewProcessorHelper(), tf, threadMonitor);
-      {
-        BlockingQueue<Runnable> poolQueue;
-        if (INCOMING_QUEUE_LIMIT == 0) {
-          poolQueue = new OverflowQueueWithDMStats<>(this.stats.getOverflowQueueHelper());
-        } else {
-          poolQueue = new OverflowQueueWithDMStats<>(INCOMING_QUEUE_LIMIT,
-              this.stats.getOverflowQueueHelper());
-        }
-        ThreadFactory tf = new ThreadFactory() {
-          private int next = 0;
+      this.viewThread =
+          LoggingExecutors.newSerialThreadPoolWithUnlimitedFeed("View Message Processor",
+              thread -> stats.incViewThreadStarts(), this::doViewThread,
+              this.stats.getViewProcessorHelper(), threadMonitor);
-          @Override
-          public Thread newThread(final Runnable command) {
-            ClusterDistributionManager.this.stats.incProcessingThreadStarts();
-            final Runnable r = new Runnable() {
-              @Override
-              public void run() {
-                ClusterDistributionManager.this.stats.incNumProcessingThreads(1);
-                try {
-                  ConnectionTable.threadWantsSharedResources();
-                  Connection.makeReaderThread();
-                  runUntilShutdown(command);
-                } finally {
-                  ConnectionTable.releaseThreadsSockets();
-                  ClusterDistributionManager.this.stats.incNumProcessingThreads(-1);
-                }
-              }
-            };
-            Thread thread = new Thread(group, r,
-                LocalizedStrings.DistributionManager_POOLED_MESSAGE_PROCESSOR.toLocalizedString()
-                    + (next++));
-            thread.setDaemon(true);
-            return thread;
-          }
-        };
-        this.threadPool = new PooledExecutorWithDMStats(poolQueue, MAX_THREADS,
-            this.stats.getNormalPoolHelper(), tf, threadMonitor);
-      }
+      this.threadPool =
+          LoggingExecutors.newThreadPoolWithFeedStatistics("Pooled Message Processor ",
+              thread -> stats.incProcessingThreadStarts(), this::doProcessingThread,
+              MAX_THREADS, this.stats.getNormalPoolHelper(), threadMonitor,
+              INCOMING_QUEUE_LIMIT, this.stats.getOverflowQueueHelper());
+      this.highPriorityPool = LoggingExecutors.newThreadPoolWithFeedStatistics(
+          "Pooled High Priority Message Processor ",
+          thread -> stats.incHighPriorityThreadStarts(), this::doHighPriorityThread,
+          MAX_THREADS, this.stats.getHighPriorityPoolHelper(), threadMonitor,
+          INCOMING_QUEUE_LIMIT, this.stats.getHighPriorityQueueHelper());
-        if (INCOMING_QUEUE_LIMIT == 0) {
-          poolQueue = new OverflowQueueWithDMStats<>(this.stats.getHighPriorityQueueHelper());
-        } else {
-          poolQueue = new OverflowQueueWithDMStats<>(INCOMING_QUEUE_LIMIT,
-              this.stats.getHighPriorityQueueHelper());
-        }
-        ThreadFactory tf = new ThreadFactory() {
-          private int next = 0;
-
-          @Override
-          public Thread newThread(final Runnable command) {
-            ClusterDistributionManager.this.stats.incHighPriorityThreadStarts();
-            final Runnable r = new Runnable() {
-              @Override
-              public void run() {
-                ClusterDistributionManager.this.stats.incHighPriorityThreads(1);
-                try {
-                  ConnectionTable.threadWantsSharedResources();
-                  Connection.makeReaderThread();
-                  runUntilShutdown(command);
-                } finally {
-                  ConnectionTable.releaseThreadsSockets();
-                  ClusterDistributionManager.this.stats.incHighPriorityThreads(-1);
-                }
-              }
-            };
-            Thread thread = new Thread(group, r,
-                LocalizedStrings.DistributionManager_POOLED_HIGH_PRIORITY_MESSAGE_PROCESSOR
-                    .toLocalizedString() + (next++));
-            thread.setDaemon(true);
-            return thread;
-          }
-        };
-        this.highPriorityPool = new PooledExecutorWithDMStats(poolQueue, MAX_THREADS,
-            this.stats.getHighPriorityPoolHelper(), tf, threadMonitor);
-      }
-
-
-      {
-        ThreadFactory tf = new ThreadFactory() {
-          private int next = 0;
-
-          @Override
-          public Thread newThread(final Runnable command) {
-            ClusterDistributionManager.this.stats.incWaitingThreadStarts();
-            final Runnable r = new Runnable() {
-              @Override
-              public void run() {
-                ClusterDistributionManager.this.stats.incWaitingThreads(1);
-                try {
-                  ConnectionTable.threadWantsSharedResources();
-                  Connection.makeReaderThread();
-                  runUntilShutdown(command);
-                } finally {
-                  ConnectionTable.releaseThreadsSockets();
-                  ClusterDistributionManager.this.stats.incWaitingThreads(-1);
-                }
-              }
-            };
-            Thread thread = new Thread(group, r,
-                LocalizedStrings.DistributionManager_POOLED_WAITING_MESSAGE_PROCESSOR
-                    .toLocalizedString() + (next++));
-            thread.setDaemon(true);
-            return thread;
-          }
-        };
-        BlockingQueue<Runnable> poolQueue;
-        this.waitingPool = new PooledExecutorWithDMStats(poolQueue, MAX_WAITING_THREADS,
-            this.stats.getWaitingPoolHelper(), tf, threadMonitor);
+        this.waitingPool = LoggingExecutors.newThreadPool("Pooled Waiting Message Processor ",
+            thread -> stats.incWaitingThreadStarts(), this::doWaitingThread,
+            MAX_WAITING_THREADS, this.stats.getWaitingPoolHelper(), threadMonitor, poolQueue);
-      {
-        ThreadFactory tf = new ThreadFactory() {
-          private int next = 0;
+      // should this pool using the waiting pool stats?
+      this.prMetaDataCleanupThreadPool =
+          LoggingExecutors.newThreadPoolWithFeedStatistics("PrMetaData cleanup Message Processor ",
+              thread -> stats.incWaitingThreadStarts(), this::doWaitingThread,
+              MAX_PR_META_DATA_CLEANUP_THREADS, this.stats.getWaitingPoolHelper(), threadMonitor,
+              0, this.stats.getWaitingQueueHelper());
-          @Override
-          public Thread newThread(final Runnable command) {
-            ClusterDistributionManager.this.stats.incWaitingThreadStarts();// will it be ok?
-            final Runnable r = new Runnable() {
-              @Override
-              public void run() {
-                ClusterDistributionManager.this.stats.incWaitingThreads(1);// will it be ok
-                try {
-                  ConnectionTable.threadWantsSharedResources();
-                  Connection.makeReaderThread();
-                  runUntilShutdown(command);
-                } finally {
-                  ConnectionTable.releaseThreadsSockets();
-                  ClusterDistributionManager.this.stats.incWaitingThreads(-1);
-                }
-              }
-            };
-            Thread thread = new Thread(group, r,
-                LocalizedStrings.DistributionManager_PR_META_DATA_CLEANUP_MESSAGE_PROCESSOR
-                    .toLocalizedString() + (next++));
-            thread.setDaemon(true);
-            return thread;
-          }
-        };
-        BlockingQueue<Runnable> poolQueue;
-        poolQueue = new OverflowQueueWithDMStats<>(this.stats.getWaitingQueueHelper());
-        this.prMetaDataCleanupThreadPool = new PooledExecutorWithDMStats(poolQueue,
-            MAX_PR_META_DATA_CLEANUP_THREADS, this.stats.getWaitingPoolHelper(), tf, threadMonitor);
+      if (MAX_PR_THREADS > 1) {
+        this.partitionedRegionPool =
+            LoggingExecutors.newThreadPoolWithFeedStatistics("PartitionedRegion Message Processor",
+                thread -> stats.incPartitionedRegionThreadStarts(), this::doPartitionRegionThread,
+                MAX_PR_THREADS, this.stats.getPartitionedRegionPoolHelper(), threadMonitor,
+                INCOMING_QUEUE_LIMIT, this.stats.getPartitionedRegionQueueHelper());
+      } else {
+        this.partitionedRegionThread = LoggingExecutors.newSerialThreadPoolWithFeedStatistics(
+            "PartitionedRegion Message Processor",
+            thread -> stats.incPartitionedRegionThreadStarts(), this::doPartitionRegionThread,
+            this.stats.getPartitionedRegionPoolHelper(), threadMonitor,
+            INCOMING_QUEUE_LIMIT, this.stats.getPartitionedRegionQueueHelper());
-
-      {
-        BlockingQueue<Runnable> poolQueue;
-        if (INCOMING_QUEUE_LIMIT == 0) {
-          poolQueue = new OverflowQueueWithDMStats<>(this.stats.getPartitionedRegionQueueHelper());
-        } else {
-          poolQueue = new OverflowQueueWithDMStats<>(INCOMING_QUEUE_LIMIT,
-              this.stats.getPartitionedRegionQueueHelper());
-        }
-        ThreadFactory tf = new ThreadFactory() {
-          private int next = 0;
-
-          @Override
-          public Thread newThread(final Runnable command) {
-            ClusterDistributionManager.this.stats.incPartitionedRegionThreadStarts();
-            final Runnable r = new Runnable() {
-              @Override
-              public void run() {
-                stats.incPartitionedRegionThreads(1);
-                try {
-                  ConnectionTable.threadWantsSharedResources();
-                  Connection.makeReaderThread();
-                  runUntilShutdown(command);
-                } finally {
-                  ConnectionTable.releaseThreadsSockets();
-                  stats.incPartitionedRegionThreads(-1);
-                }
-              }
-            };
-            Thread thread = new Thread(group, r, "PartitionedRegion Message Processor" + (next++));
-            thread.setDaemon(true);
-            return thread;
-          }
-        };
-        if (MAX_PR_THREADS > 1) {
-          this.partitionedRegionPool = new PooledExecutorWithDMStats(poolQueue, MAX_PR_THREADS,
-              this.stats.getPartitionedRegionPoolHelper(), tf, threadMonitor);
-        } else {
-          this.partitionedRegionThread = new SerialQueuedExecutorWithDMStats(poolQueue,
-              this.stats.getPartitionedRegionPoolHelper(), tf, threadMonitor);
-        }
-
-      }
-
-      {
-        BlockingQueue<Runnable> poolQueue;
-        if (INCOMING_QUEUE_LIMIT == 0) {
-          poolQueue = new OverflowQueueWithDMStats<>(this.stats.getFunctionExecutionQueueHelper());
-        } else {
-          poolQueue = new OverflowQueueWithDMStats<>(INCOMING_QUEUE_LIMIT,
-              this.stats.getFunctionExecutionQueueHelper());
-        }
-        ThreadFactory tf = new ThreadFactory() {
-          private int next = 0;
-
-          @Override
-          public Thread newThread(final Runnable command) {
-            ClusterDistributionManager.this.stats.incFunctionExecutionThreadStarts();
-            final Runnable r = new Runnable() {
-              @Override
-              public void run() {
-                stats.incFunctionExecutionThreads(1);
-                isFunctionExecutionThread.set(Boolean.TRUE);
-                try {
-                  ConnectionTable.threadWantsSharedResources();
-                  Connection.makeReaderThread();
-                  runUntilShutdown(command);
-                } finally {
-                  ConnectionTable.releaseThreadsSockets();
-                  stats.incFunctionExecutionThreads(-1);
-                }
-              }
-            };
-            Thread thread = new Thread(group, r, "Function Execution Processor" + (next++));
-            thread.setDaemon(true);
-            return thread;
-          }
-        };
-
-        if (MAX_FE_THREADS > 1) {
-          this.functionExecutionPool = new FunctionExecutionPooledExecutor(poolQueue,
-              MAX_FE_THREADS, this.stats.getFunctionExecutionPoolHelper(), tf,
-              true /* for fn exec */, this.threadMonitor);
-        } else {
-          this.functionExecutionThread = new SerialQueuedExecutorWithDMStats(poolQueue,
-              this.stats.getFunctionExecutionPoolHelper(), tf, threadMonitor);
-        }
-
+      if (MAX_FE_THREADS > 1) {
+        this.functionExecutionPool =
+            LoggingExecutors.newFunctionThreadPoolWithFeedStatistics("Function Execution Processor",
+                thread -> stats.incFunctionExecutionThreadStarts(), this::doFunctionExecutionThread,
+                MAX_FE_THREADS, this.stats.getFunctionExecutionPoolHelper(), threadMonitor,
+                INCOMING_QUEUE_LIMIT, this.stats.getFunctionExecutionQueueHelper());
+      } else {
+        this.functionExecutionThread =
+            LoggingExecutors.newSerialThreadPoolWithFeedStatistics("Function Execution Processor",
+                thread -> stats.incFunctionExecutionThreadStarts(), this::doFunctionExecutionThread,
+                this.stats.getFunctionExecutionPoolHelper(), threadMonitor,
+                INCOMING_QUEUE_LIMIT, this.stats.getFunctionExecutionQueueHelper());
-            new Thread(group, new MemberEventInvoker(), "DM-MemberEventInvoker");
-        this.memberEventThread.setDaemon(true);
+            new LoggingThread("DM-MemberEventInvoker", new MemberEventInvoker());
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.DistributionManager_STARTING_DISTRIBUTIONMANAGER_0_1,
+      logger.info("Starting DistributionManager {}. {}",
-              (logger.isInfoEnabled(LogMarker.DM_MARKER) ? sb.toString() : "")}));
+              (logger.isInfoEnabled(LogMarker.DM_MARKER) ? sb.toString() : "")});
+  private void doFunctionExecutionThread(Runnable command) {
+    stats.incFunctionExecutionThreads(1);
+    isFunctionExecutionThread.set(Boolean.TRUE);
+    try {
+      ConnectionTable.threadWantsSharedResources();
+      Connection.makeReaderThread();
+      runUntilShutdown(command);
+    } finally {
+      ConnectionTable.releaseThreadsSockets();
+      stats.incFunctionExecutionThreads(-1);
+    }
+  }
+
+  private void doProcessingThread(Runnable command) {
+    stats.incNumProcessingThreads(1);
+    try {
+      ConnectionTable.threadWantsSharedResources();
+      Connection.makeReaderThread();
+      runUntilShutdown(command);
+    } finally {
+      ConnectionTable.releaseThreadsSockets();
+      stats.incNumProcessingThreads(-1);
+    }
+  }
+
+  private void doHighPriorityThread(Runnable command) {
+    stats.incHighPriorityThreads(1);
+    try {
+      ConnectionTable.threadWantsSharedResources();
+      Connection.makeReaderThread();
+      runUntilShutdown(command);
+    } finally {
+      ConnectionTable.releaseThreadsSockets();
+      stats.incHighPriorityThreads(-1);
+    }
+  }
+
+  private void doWaitingThread(Runnable command) {
+    stats.incWaitingThreads(1);
+    try {
+      ConnectionTable.threadWantsSharedResources();
+      Connection.makeReaderThread();
+      runUntilShutdown(command);
+    } finally {
+      ConnectionTable.releaseThreadsSockets();
+      stats.incWaitingThreads(-1);
+    }
+  }
+
+  private void doPartitionRegionThread(Runnable command) {
+    stats.incPartitionedRegionThreads(1);
+    try {
+      ConnectionTable.threadWantsSharedResources();
+      Connection.makeReaderThread();
+      runUntilShutdown(command);
+    } finally {
+      ConnectionTable.releaseThreadsSockets();
+      stats.incPartitionedRegionThreads(-1);
+    }
+  }
+
+  private void doViewThread(Runnable command) {
+    stats.incNumViewThreads(1);
+    try {
+      ConnectionTable.threadWantsSharedResources();
+      Connection.makeReaderThread();
+      runUntilShutdown(command);
+    } finally {
+      ConnectionTable.releaseThreadsSockets();
+      stats.incNumViewThreads(-1);
+    }
+  }
+
+  private void doSerialThread(Runnable command) {
+    stats.incNumSerialThreads(1);
+    try {
+      ConnectionTable.threadWantsSharedResources();
+      Connection.makeReaderThread();
+      runUntilShutdown(command);
+    } finally {
+      ConnectionTable.releaseThreadsSockets();
+      stats.incNumSerialThreads(-1);
+    }
+  }
+
-        logger.warn(LocalizedMessage
-            .create(LocalizedStrings.DistributionManager_TASK_FAILED_WITH_EXCEPTION), t);
+        logger.warn("Task failed with exception", t);
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.DistributionManager_DISTRIBUTIONMANAGER_MEMBER_0_IS_1_EQUIVALENT,
-          logArgs));
+      logger.info("Member {} is {} equivalent or in the same redundancy zone.",
+          logArgs);
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.DistributionManager_INITIAL_MEMBERSHIPMANAGER_VIEW___0,
-          String.valueOf(v)));
+      logger.info("Initial (distribution manager) view, {}",
+          String.valueOf(v));
-      // Figure out who the elder is...
-      selectElder(); // ShutdownException could be thrown here
-          LocalizedStrings.DistributionManager_COULD_NOT_PROCESS_INITIAL_VIEW.toLocalizedString(),
+          "Could not process initial view",
-      logger.fatal(LocalizedMessage.create(
-          LocalizedStrings.DistributionManager_UNCAUGHT_EXCEPTION_CALLING_READYFORMESSAGES), t);
+      logger.fatal("Uncaught exception calling readyForMessages", t);
-    return this.exceptionInThreads || this.threadGroup.getUncaughtExceptionsCount() > 0;
+    return this.exceptionInThreads
+        || LoggingUncaughtExceptionHandler.getUncaughtExceptionsCount() > 0;
-    this.threadGroup.clearUncaughtExceptionsCount();
+    LoggingUncaughtExceptionHandler.clearUncaughtExceptionsCount();
-        throw new InternalGemFireError(LocalizedStrings.DistributionManager_UNKNOWN_MEMBER_TYPE_0
-            .toLocalizedString(Integer.valueOf(vmType)));
+        throw new InternalGemFireError(String.format("Unknown member type: %s",
+            Integer.valueOf(vmType)));
-        ? LocalizedStrings.DistributionManager_AT_LEAST_ONE_EXCEPTION_OCCURRED.toLocalizedString()
+        ? "At least one Exception occurred."
-    logger.info(LocalizedMessage.create(
-        LocalizedStrings.DistributionManager_SHUTTING_DOWN_DISTRIBUTIONMANAGER_0_1,
-        new Object[] {this.localAddress, exceptionStatus}));
+    logger.info("Shutting down DistributionManager {}. {}",
+        new Object[] {this.localAddress, exceptionStatus});
-        final Thread t = new Thread(threadGroup, r,
-            LocalizedStrings.DistributionManager_SHUTDOWN_MESSAGE_THREAD_FOR_0
-                .toLocalizedString(this.localAddress));
+        final Thread t =
+            new LoggingThread(String.format("Shutdown Message Thread for %s",
+                this.localAddress), false, r);
-          logger.warn(
-              LocalizedMessage.create(
-                  LocalizedStrings.DistributionManager_INTERRUPTED_SENDING_SHUTDOWN_MESSAGE_TO_PEERS),
+          logger.warn("Interrupted sending shutdown message to peers",
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.DistributionManager_FAILED_SENDING_SHUTDOWN_MESSAGE_TO_PEERS_TIMEOUT));
+          logger.warn("Failed sending shutdown message to peers (timeout)");
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.DistributionManager_DISTRIBUTIONMANAGER_STOPPED_IN_0_MS, delta));
+        logger.info("DistributionManager stopped in {}ms.", delta);
-      logger.warn(LocalizedMessage
-          .create(LocalizedStrings.DistributionManager_FORCING_THREAD_STOP_ON__0_, t));
+      logger.warn("Forcing thread stop on < {} >", t);
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.DistributionManager_CLOBBERTHREAD_THREAD_REFUSED_TO_DIE__0, t));
+        logger.warn("Thread refused to die: {}", t);
-  private boolean executorAlive(ThreadPoolExecutor tpe, String name) {
+  private boolean executorAlive(ExecutorService tpe, String name) {
-      int ac = tpe.getActiveCount();
+      int ac = ((ThreadPoolExecutor) tpe).getActiveCount();
-        logger.warn(LocalizedMessage
-            .create(LocalizedStrings.DistributionManager_INTERRUPTED_DURING_SHUTDOWN), e);
+        logger.warn("Interrupted during shutdown", e);
-    logger.warn(LocalizedMessage.create(
-        LocalizedStrings.DistributionManager_DAEMON_THREADS_ARE_SLOW_TO_STOP_CULPRITS_INCLUDE_0,
-        culprits));
+    logger.warn("Daemon threads are slow to stop; culprits include: {}",
+        culprits);
-          logger.info(LocalizedMessage.create(
-              LocalizedStrings.DistributionManager_NOW_CLOSING_DISTRIBUTION_FOR__0,
-              this.localAddress));
+          logger.info("Now closing distribution for {}",
+              this.localAddress);
-  private boolean isCloseInProgress() {
+  protected boolean isCloseInProgress() {
-            logger.warn(LocalizedMessage
-                .create(LocalizedStrings.DistributionManager_UNEXPECTED_INTERRUPTEDEXCEPTION), e);
+            logger.warn("Unexpected InterruptedException", e);
-            logger.warn(LocalizedMessage
-                .create(LocalizedStrings.DistributionManager_UNEXPECTED_CANCELLATION), e);
+            logger.warn("Unexpected cancellation", e);
-              LocalizedMessage.create(
-                  LocalizedStrings.DistributionManager_UNCAUGHT_EXCEPTION_PROCESSING_MEMBER_EVENT),
+              "Uncaught exception processing member event",
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.DistributionManager_MARKING_DISTRIBUTIONMANAGER_0_AS_CLOSED,
-          this.localAddress));
+      logger.info("Marking DistributionManager {} as closed.",
+          this.localAddress);
-          LocalizedStrings.DistributionManager_MESSAGE_DISTRIBUTION_HAS_TERMINATED
-              .toLocalizedString(),
+          "Message distribution has terminated",
-    logger.info(LocalizedMessage.create(
-        LocalizedStrings.DistributionManager_NEW_ADMINISTRATION_MEMBER_DETECTED_AT_0, theId));
+    logger.info("New administration member detected at {}.", theId);
-          LocalizedStrings.DistributionManager_ONE_OR_MORE_PEERS_GENERATED_EXCEPTIONS_DURING_CONNECTION_ATTEMPT
-              .toLocalizedString(),
+          "One or more peers generated exceptions during connection attempt",
-                LocalizedStrings.DistributionManager_NO_STARTUP_REPLIES_FROM_0
-                    .toLocalizedString(unfinishedStartups));
+                String.format("No startup replies from: %s",
+                    unfinishedStartups));
-              LocalizedStrings.DistributionManager_RECEIVED_NO_CONNECTION_ACKNOWLEDGMENTS_FROM_ANY_OF_THE_0_SENIOR_CACHE_MEMBERS_1
-                  .toLocalizedString(
-                      new Object[] {Integer.toString(allOthers.size()), sb.toString()}));
+              String.format(
+                  "Received no connection acknowledgments from any of the %s senior cache members: %s",
+
+                  new Object[] {Integer.toString(allOthers.size()), sb.toString()}));
-      InternalDistributedMember e = getElderId();
+      InternalDistributedMember e = clusterElderManager.getElderId();
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.DistributionManager_FORCING_AN_ELDER_JOIN_EVENT_SINCE_A_STARTUP_RESPONSE_WAS_NOT_RECEIVED_FROM_ELDER__0_,
-              e));
+          logger.warn(
+              "Forcing an elder join event since a startup response was not received from elder {}.",
+              e);
-      StringId msg = null;
+      String msg = null;
-            LocalizedStrings.DistributionManager_STOPPED_WAITING_FOR_STARTUP_REPLY_FROM_0_BECAUSE_THE_PEER_DEPARTED_THE_VIEW;
+            "Stopped waiting for startup reply from <{}> because the peer departed the view.";
-            LocalizedStrings.DistributionManager_STOPPED_WAITING_FOR_STARTUP_REPLY_FROM_0_BECAUSE_THE_REPLY_WAS_FINALLY_RECEIVED;
+            "Stopped waiting for startup reply from <{}> because the reply was finally received.";
-      logger.info(LocalizedMessage.create(msg, m));
+      logger.info(msg, m);
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.DistributionManager_STILL_AWAITING_0_RESPONSES_FROM_1,
-            new Object[] {Integer.valueOf(numLeft), unfinishedStartups}));
+        logger.info("Still awaiting {} response(s) from: {}.",
+            new Object[] {Integer.valueOf(numLeft), unfinishedStartups});
-    List<InternalDistributedMember> theMembers = getViewMembers();
-
-    // Assert.assertTrue(!closeInProgress
-    // && theMembers.contains(this.localAddress)); // bug36202?
-
-    int elderCandidates = 0;
-    Iterator<InternalDistributedMember> it;
-
-    // for bug #50510 we need to know if there are any members older than v8.0
-    it = theMembers.iterator();
-    boolean anyPre80Members = false;
-    while (it.hasNext()) {
-      InternalDistributedMember member = it.next();
-      if (member.getVersionObject().compareTo(Version.GFE_80) < 0) {
-        anyPre80Members = true;
-      }
-    }
-
-    // determine number of elder candidates (unless adam)
-    if (!this.adam) {
-      it = theMembers.iterator();
-      while (it.hasNext()) {
-        InternalDistributedMember member = it.next();
-        int managerType = member.getVmKind();
-        if (managerType == ADMIN_ONLY_DM_TYPE)
-          continue;
-
-        if (managerType == LOCATOR_DM_TYPE) {
-          // Fix for #50510 - pre-8.0 members will not let a locator be the elder
-          // so we need to make the same decision here
-          if (anyPre80Members) {
-            continue;
-          }
-        }
-
-        // Fix for #45566. Using a surprise member as the elder can cause a
-        // deadlock.
-        if (getMembershipManager().isSurpriseMember(member)) {
-          continue;
-        }
-
-        elderCandidates++;
-        if (elderCandidates > 1) {
-          // If we have more than one candidate then we are not adam
-          break;
-        }
-      } // while
-    }
-
-    // Second pass over members...
-    it = theMembers.iterator();
-    while (it.hasNext()) {
-      InternalDistributedMember member = it.next();
-      int managerType = member.getVmKind();
-      if (managerType == ADMIN_ONLY_DM_TYPE)
-        continue;
-
-      if (managerType == LOCATOR_DM_TYPE) {
-        // Fix for #50510 - pre-8.0 members will not let a locator be the elder
-        // so we need to make the same decision here
-        if (anyPre80Members) {
-          continue;
-        }
-      }
-
-      // Fix for #45566. Using a surprise member as the elder can cause a
-      // deadlock.
-      if (getMembershipManager().isSurpriseMember(member)) {
-        continue;
-      }
-
-      if (member.equals(this.localAddress)) {
-        if (!this.adam && elderCandidates == 1) {
-          this.adam = true;
-          logger.info(LocalizedMessage.create(
-              LocalizedStrings.DistributionManager_0_IS_THE_ELDER_AND_THE_ONLY_MEMBER,
-              this.localAddress));
-        } else {
-          logger.info(LocalizedMessage.create(LocalizedStrings.DistributionManager_I_0_AM_THE_ELDER,
-              this.localAddress));
-        }
-      }
-      return member;
-    } // while
-    // If we get this far then no elder exists
-    return null;
-  }
-
-  /**
-   * Select a new elder
-   *
-   */
-  private void selectElder() {
-    getSystem().getCancelCriterion().checkCancelInProgress(null); // bug 37884, if DS is
-                                                                  // disconnecting, throw exception
-
-    // Once we are the elder, we're stuck until we leave the view.
-    if (this.localAddress.equals(this.elder)) {
-      return;
-    }
-
-    // Determine who is the elder...
-    InternalDistributedMember candidate = getElderCandidate();
-    if (candidate == null) {
-      changeElder(null);
-      return; // No valid elder in current context
-    }
-
-    // Carefully switch to new elder
-    synchronized (this.elderMonitor) {
-      if (!candidate.equals(this.elder)) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("The elder is: {} (was {})", candidate, this.elder);
-        }
-        changeElder(candidate);
-      }
-    } // synchronized
+    return clusterElderManager.getElderCandidate();
-    // In any event, make sure that this member is no longer an elder.
-    if (!theId.equals(localAddress) && theId.equals(elder)) {
-      try {
-        selectElder();
-      } catch (DistributedSystemDisconnectedException e) {
-        // ignore
-      }
-    }
-
-    logger.info(LocalizedMessage.create(
-        LocalizedStrings.DistributionManager_ADMITTING_MEMBER_0_NOW_THERE_ARE_1_NONADMIN_MEMBERS,
-        new Object[] {theId, Integer.valueOf(tmp.size())}));
+    logger.info("Admitting member <{}>. Now there are {} non-admin member(s).",
+        theId, tmp.size());
-    logger.info(LocalizedMessage.create(
-        LocalizedStrings.DistributionManager_DMMEMBERSHIP_ADMITTING_NEW_ADMINISTRATION_MEMBER__0_,
-        theId));
+    logger.info("DMMembership: Admitting new administration member < {} >.",
+        theId);
-      // membersAndAdmin if he is not in members.
-      // This happens when we have an admin guy colocated with a normal DS.
+      // membersAndAdmin if it is not in members.
+      // This happens when we have an admin member colocated with a normal DS.
-      StringId msg = null;
+      String msg = null;
-        msg = LocalizedStrings.DistributionManager_ADMINISTRATION_MEMBER_AT_0_CRASHED_1;
+        msg = "Administration member at {} crashed: {}";
-        msg = LocalizedStrings.DistributionManager_ADMINISTRATION_MEMBER_AT_0_CLOSED_1;
+        msg = "Administration member at {} closed: {}";
-      logger.info(LocalizedMessage.create(msg, new Object[] {theId, reason}));
+      logger.info(msg, new Object[] {theId, reason});
-        LocalizedStrings.ShutdownMessage_SHUTDOWN_MESSAGE_RECEIVED.toLocalizedString());
+        "shutdown message received");
-    // this fixes a race introduced in 5.0.1 by the fact that an explicit
-    // shutdown will cause a member to no longer be in our DM membership
-    // but still in the javagroup view.
-    try {
-      selectElder();
-    } catch (DistributedSystemDisconnectedException e) {
-      // keep going
-    }
-
-
-
-      StringId msg;
+      String msg;
-            LocalizedStrings.DistributionManager_MEMBER_AT_0_UNEXPECTEDLY_LEFT_THE_DISTRIBUTED_CACHE_1;
+            "Member at {} unexpectedly left the distributed cache: {}";
-            LocalizedStrings.DistributionManager_MEMBER_AT_0_GRACEFULLY_LEFT_THE_DISTRIBUTED_CACHE_1;
+            "Member at {} gracefully left the distributed cache: {}";
-      logger.info(LocalizedMessage.create(msg, new Object[] {theId, prettifyReason(p_reason)}));
+      logger.info(msg, new Object[] {theId, prettifyReason(p_reason)});
-      logger.debug("CancelException caught sending shutdown: {}", e.getMessage(), e);
+      logger.debug(String.format("CancelException caught sending shutdown: %s", e.getMessage()), e);
-      logger.fatal(LocalizedMessage
-          .create(LocalizedStrings.DistributionManager_WHILE_SENDING_SHUTDOWN_MESSAGE), ex2);
+      logger.fatal("While sending shutdown message", ex2);
-        throw new InternalGemFireError(LocalizedStrings.DistributionManager_UNKNOWN_PROCESSOR_TYPE
-            .toLocalizedString(processorType));
+        throw new InternalGemFireError(String.format("unknown processor type %s",
+            processorType));
-      logger.fatal(
-          LocalizedMessage.create(LocalizedStrings.DistributionManager_WHILE_PUSHING_MESSAGE_0_TO_1,
-              new Object[] {message, receiver}),
+      logger.fatal(String.format("While pushing message <%s> to %s",
+          new Object[] {message, receiver}),
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.DistributionChannel_ATTEMPTING_A_SEND_TO_A_DISCONNECTED_DISTRIBUTIONMANAGER));
+      logger.warn("Attempting a send to a disconnected DistributionManager");
-  @Override
-  public boolean isAdam() {
-    return this.adam;
+  private List<InternalDistributedMember> getElderCandidates() {
+
+    return clusterElderManager.getElderCandidates();
-    if (closeInProgress) {
-      throw new DistributedSystemDisconnectedException(
-          LocalizedStrings.DistributionManager_NO_VALID_ELDER_WHEN_SYSTEM_IS_SHUTTING_DOWN
-              .toLocalizedString(),
-          this.getRootCause());
-    }
-    getSystem().getCancelCriterion().checkCancelInProgress(null);
-
-    // Cache a recent value of the elder
-    InternalDistributedMember result = elder;
-    if (result != null && membershipManager.memberExists(result)) {
-      return result;
-    }
-    logger.info(LocalizedMessage.create(
-        LocalizedStrings.DistributionManager_ELDER__0__IS_NOT_CURRENTLY_AN_ACTIVE_MEMBER_SELECTING_NEW_ELDER,
-        elder));
-
-    selectElder(); // ShutdownException can be thrown here
-    logger.info(LocalizedMessage
-        .create(LocalizedStrings.DistributionManager_NEWLY_SELECTED_ELDER_IS_NOW__0_, elder));
-    return elder;
+    return clusterElderManager.getElderId();
-    return getId().equals(elder);
+    return clusterElderManager.isElder();
-  private final StoppableReentrantLock elderLock;
-  private ElderState elderState;
-  private volatile boolean elderStateInitialized;
-
-  public ElderState getElderState(boolean force, boolean useTryLock) {
-    if (force) {
-      if (logger.isDebugEnabled()) {
-        if (!this.localAddress.equals(this.elder)) {
-          logger.debug("Forcing myself, {}, to be the elder.", this.localAddress);
-        }
-      }
-      changeElder(this.localAddress);
-    }
-    if (force || this.localAddress.equals(elder)) {
-      // we are the elder
-      if (this.elderStateInitialized) {
-        return this.elderState;
-      }
-      return getElderStateWithTryLock(useTryLock);
-    } else {
-      // we are not the elder so return null
-      return null;
-    }
-  }
-
-  /**
-   * Usage: GrantorRequestProcessor calls getElderState with useTryLock set to true if the
-   * becomeGrantor Collaboration is already acquired.
-   * <p>
-   * This tryLock is attempted and if it fails, an exception is thrown to cause a Doug Lea style
-   * back-off (p. 149). It throws an exception because it needs to back down a couple of packages
-   * and I didn't want to couple this pkg too tightly with the dlock pkg.
-   * <p>
-   * GrantorRequestProcessor catches the exception, releases and reacquires the Collaboration, and
-   * then comes back here to attempt the tryLock again. Currently nothing will stop it from
-   * re-attempting forever. It has to get the ElderState and cannot give up, but it can free up the
-   * Collaboration and then re-enter it. The other thread holding the elder lock will hold it only
-   * briefly. I've added a volatile called elderStateInitialized which should cause this back-off to
-   * occur only once in the life of a vm... once the elder, always the elder.
-   * <p>
-   */
-  private ElderState getElderStateWithTryLock(boolean useTryLock) {
-    boolean locked = false;
-    if (useTryLock) {
-      boolean interrupted = Thread.interrupted();
-      try {
-        locked = this.elderLock.tryLock(2000);
-      } catch (InterruptedException e) {
-        interrupted = true;
-        getCancelCriterion().checkCancelInProgress(e);
-        // one last attempt and then allow it to fail for back-off...
-        locked = this.elderLock.tryLock();
-      } finally {
-        if (interrupted) {
-          Thread.currentThread().interrupt();
-        }
-      }
-    } else {
-      locked = true;
-      this.elderLock.lock();
-    }
-    if (!locked) {
-      // try-lock must have failed
-      throw new IllegalStateException(
-          LocalizedStrings.DistributionManager_POSSIBLE_DEADLOCK_DETECTED.toLocalizedString());
-    }
-    try {
-      if (this.elderState == null) {
-        this.elderState = new ElderState(this);
-      }
-    } finally {
-      this.elderLock.unlock();
-    }
-    this.elderStateInitialized = true;
-    return this.elderState;
+  public ElderState getElderState(boolean waitToBecomeElder) {
+    return clusterElderManager.getElderState(waitToBecomeElder);
-   * @return true if newElder is the elder; false if he is no longer a member or we are the elder.
+   * @return true if newElder is the elder; false if it is no longer a member or we are the elder.
-    MembershipListener l = null;
-    try {
-      // Assert.assertTrue(
-      // desiredElder.getVmKind() != DistributionManager.ADMIN_ONLY_DM_TYPE);
-      synchronized (this.elderMonitor) {
-        while (true) {
-          if (closeInProgress)
-            return false;
-          InternalDistributedMember currentElder = this.elder;
-          // Assert.assertTrue(
-          // currentElder.getVmKind() != DistributionManager.ADMIN_ONLY_DM_TYPE);
-          if (desiredElder.equals(currentElder)) {
-            return true;
-          }
-          if (!isCurrentMember(desiredElder)) {
-            return false; // no longer present
-          }
-          if (this.localAddress.equals(currentElder)) {
-            // Once we become the elder we no longer allow anyone else to be the
-            // elder so don't let them wait anymore.
-            return false;
-          }
-          if (l == null) {
-            l = new MembershipListener() {
-              @Override
-              public void memberJoined(DistributionManager distributionManager,
-                  InternalDistributedMember theId) {
-                // nothing needed
-              }
-              @Override
-              public void memberDeparted(DistributionManager distributionManager,
-                  InternalDistributedMember theId, boolean crashed) {
-                if (desiredElder.equals(theId)) {
-                  notifyElderChangeWaiters();
-                }
-              }
-
-              @Override
-              public void memberSuspect(DistributionManager distributionManager,
-                  InternalDistributedMember id, InternalDistributedMember whoSuspected,
-                  String reason) {}
-
-              @Override
-              public void quorumLost(DistributionManager distributionManager,
-                  Set<InternalDistributedMember> failures,
-                  List<InternalDistributedMember> remaining) {}
-            };
-            addMembershipListener(l);
-          }
-          logger.info(LocalizedMessage.create(
-              LocalizedStrings.DistributionManager_CHANGING_ELDER_FROM_0_TO_1,
-              new Object[] {currentElder, desiredElder}));
-          elderChangeWait();
-        } // while true
-      }
-    } finally {
-      if (l != null) {
-        removeMembershipListener(l);
-      }
-    }
-  }
-
-  /**
-   * Set the elder to newElder and notify anyone waiting for it to change
-   */
-  private void changeElder(InternalDistributedMember newElder) {
-    synchronized (this.elderMonitor) {
-      if (newElder != null && this.localAddress != null && !this.localAddress.equals(newElder)) {
-        if (this.localAddress.equals(this.elder)) {
-          // someone else changed the elder while this thread was off cpu
-          if (logger.isDebugEnabled()) {
-            logger.debug("changeElder found this VM to be the elder and is taking an early out");
-          }
-          return;
-        }
-      }
-      this.elder = newElder;
-      if (this.waitingForElderChange) {
-        this.waitingForElderChange = false;
-        this.elderMonitor.notifyAll();
-      }
-    }
-  }
-
-  /**
-   * Used to wakeup someone in elderChangeWait even though the elder has not changed
-   */
-  private void notifyElderChangeWaiters() {
-    synchronized (this.elderMonitor) {
-      if (this.waitingForElderChange) {
-        this.waitingForElderChange = false;
-        this.elderMonitor.notifyAll();
-      }
-    }
-  }
-
-  /**
-   * Must be called holding {@link #elderMonitor} lock
-   */
-  private void elderChangeWait() {
-    // This is OK since we're holding the elderMonitor lock, so no
-    // new events will come through until the wait() below.
-    this.waitingForElderChange = true;
-
-    while (this.waitingForElderChange) {
-      stopper.checkCancelInProgress(null);
-      boolean interrupted = Thread.interrupted();
-      try {
-        this.elderMonitor.wait();
-        break;
-      } catch (InterruptedException ignore) {
-        interrupted = true;
-      } finally {
-        if (interrupted) {
-          Thread.currentThread().interrupt();
-        }
-      }
-    } // while
+    return clusterElderManager.waitForElder(desiredElder);
-            LocalizedStrings.DistributionManager_THERE_IS_ALREADY_AN_ADMIN_AGENT_ASSOCIATED_WITH_THIS_DISTRIBUTION_MANAGER
-                .toLocalizedString());
+            "There is already an Admin Agent associated with this distribution manager.");
-            LocalizedStrings.DistributionManager_THERE_WAS_NEVER_AN_ADMIN_AGENT_ASSOCIATED_WITH_THIS_DISTRIBUTION_MANAGER
-                .toLocalizedString());
+            "There was never an Admin Agent associated with this distribution manager.");
-    final ConcurrentMap<Integer, SerialQueuedExecutorWithDMStats> serialQueuedExecutorMap =
+    final ConcurrentMap<Integer, ExecutorService> serialQueuedExecutorMap =
-    final ThreadGroup threadGroup;
-    /**
-     * Constructor.
-     *
-     * @param group thread group to which the threads will belog to.
-     */
-    SerialQueuedExecutorPool(ThreadGroup group, DistributionStats stats,
+    SerialQueuedExecutorPool(DistributionStats stats,
-      this.threadGroup = group;
-    SerialQueuedExecutorWithDMStats getThrottledSerialExecutor(
+    ExecutorService getThrottledSerialExecutor(
-      SerialQueuedExecutorWithDMStats executor = getSerialExecutor(sender);
+      ExecutorService executor = getSerialExecutor(sender);
-    SerialQueuedExecutorWithDMStats getSerialExecutor(InternalDistributedMember sender) {
-      SerialQueuedExecutorWithDMStats executor = null;
+    ExecutorService getSerialExecutor(InternalDistributedMember sender) {
+      ExecutorService executor = null;
-    private SerialQueuedExecutorWithDMStats createSerialExecutor(final Integer id) {
+    private ExecutorService createSerialExecutor(final Integer id) {
-      ThreadFactory tf = new ThreadFactory() {
-        @Override
-        public Thread newThread(final Runnable command) {
-          SerialQueuedExecutorPool.this.stats.incSerialPooledThreadStarts();
-          final Runnable r = new Runnable() {
-            @Override
-            public void run() {
-              ConnectionTable.threadWantsSharedResources();
-              Connection.makeReaderThread();
-              try {
-                command.run();
-              } finally {
-                ConnectionTable.releaseThreadsSockets();
-              }
-            }
-          };
+      return LoggingExecutors.newSerialThreadPool("Pooled Serial Message Processor" + id + "-",
+          thread -> stats.incSerialPooledThreadStarts(), this::doSerialPooledThread,
+          this.stats.getSerialPooledProcessorHelper(), threadMonitoring, poolQueue);
+    }
-          Thread thread = new Thread(threadGroup, r, "Pooled Serial Message Processor " + id);
-          thread.setDaemon(true);
-          return thread;
-        }
-      };
-      return new SerialQueuedExecutorWithDMStats(poolQueue,
-          this.stats.getSerialPooledProcessorHelper(), tf, this.threadMonitoring);
+    private void doSerialPooledThread(Runnable command) {
+      ConnectionTable.threadWantsSharedResources();
+      Connection.makeReaderThread();
+      try {
+        command.run();
+      } finally {
+        ConnectionTable.releaseThreadsSockets();
+      }
-                LocalizedMessage.create(
-                    LocalizedStrings.DistributionManager_MARKING_THE_SERIALQUEUEDEXECUTOR_WITH_ID__0__USED_BY_THE_MEMBER__1__TO_BE_UNUSED,
-                    new Object[] {queueId, member}));
+                "Marking the SerialQueuedExecutor with id : {} used by the member {} to be unused.",
+                new Object[] {queueId, member});
-      processElderSelection();
-    private void processElderSelection() {
-      // If we currently had no elder, this member might be the elder;
-      // go through the selection process and decide now.
-      try {
-        dm.selectElder();
-      } catch (DistributedSystemDisconnectedException e) {
-        // ignore
-      }
-    }
-            logger.warn(LocalizedMessage
-                .create(LocalizedStrings.DistributionManager_UNEXPECTED_CANCELLATION), e);
+            logger.warn("Unexpected cancellation", e);
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.DistributionManager_EXCEPTION_WHILE_CALLING_MEMBERSHIP_LISTENER_FOR_EVENT__0,
-              this), t);
+          logger.warn(String.format("Exception while calling membership listener for event: %s",
+              this),
+              t);
-          LocalizedStrings.CacheFactory_A_CACHE_HAS_NOT_YET_BEEN_CREATED.toLocalizedString());
+          "A cache has not yet been created.");
-          LocalizedStrings.CacheFactory_THE_CACHE_HAS_BEEN_CLOSED.toLocalizedString(), null);
+          "The cache has been closed.", null);
-        return LocalizedStrings.DistributionManager__0_MESSAGE_DISTRIBUTION_HAS_TERMINATED
-            .toLocalizedString(dm.toString());
+        return String.format("%s: Message distribution has terminated",
+            dm.toString());
-  private final Stopper stopper = new Stopper(this);
-

MOV26 MOV26 MOV23 MOV31 MOV23 UPD40 UPD40 UPD40 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD43 UPD83 UPD42 INS44 UPD83 UPD42 INS44 UPD83 UPD42 INS44 UPD83 UPD42 INS44 UPD83 UPD42 INS44 UPD83 UPD42 INS44 UPD83 UPD42 INS44 UPD83 INS8 MOV74 INS42 INS8 MOV78 MOV78 MOV78 INS8 INS8 MOV31 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 INS42 MOV43 INS42 MOV43 INS42 MOV43 INS42 MOV43 INS42 MOV43 INS42 MOV43 INS42 INS43 INS41 INS41 INS41 UPD42 MOV41 INS41 UPD74 UPD43 UPD43 UPD43 UPD83 UPD42 INS44 UPD43 INS52 MOV32 INS42 INS32 MOV32 INS32 INS32 UPD66 INS32 MOV8 UPD43 UPD42 UPD42 UPD42 INS41 MOV43 INS42 UPD42 INS21 INS21 INS21 INS8 INS21 INS25 INS25 INS42 INS42 UPD42 INS42 UPD42 INS42 UPD42 INS42 UPD42 INS42 UPD42 UPD42 INS45 INS45 MOV42 MOV21 INS45 MOV42 INS60 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 INS45 INS42 INS45 MOV42 MOV60 INS45 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS42 UPD42 UPD42 UPD42 MOV42 INS42 INS42 MOV25 UPD42 UPD43 UPD43 INS32 INS21 INS7 INS7 INS7 MOV60 MOV25 INS21 INS7 MOV27 INS8 INS8 MOV27 INS8 INS8 MOV32 MOV32 MOV32 MOV32 INS43 MOV59 UPD43 MOV32 UPD43 MOV32 MOV27 UPD42 UPD42 INS42 UPD42 MOV42 INS27 INS86 INS90 MOV32 INS42 INS42 INS7 MOV22 INS32 MOV22 INS32 MOV22 INS32 INS7 MOV22 INS32 INS21 INS21 INS21 INS21 UPD42 UPD42 INS45 INS42 INS42 UPD42 INS42 UPD42 INS42 UPD42 INS42 UPD42 INS45 MOV42 UPD42 UPD42 INS45 INS42 UPD42 INS42 INS45 INS45 INS45 MOV42 UPD42 UPD42 INS45 INS45 INS42 MOV42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS32 UPD42 INS42 INS45 INS45 UPD45 MOV45 MOV42 INS45 INS59 INS32 INS52 INS42 INS45 INS45 MOV22 INS32 INS42 INS42 INS45 INS86 INS90 MOV32 INS42 INS42 INS42 INS45 INS86 INS90 INS42 MOV32 INS42 INS42 MOV32 INS42 INS42 INS45 INS86 INS90 INS42 MOV32 INS42 INS42 MOV32 MOV22 INS32 INS42 INS42 INS45 INS86 INS90 INS42 MOV32 INS42 INS34 MOV32 INS7 INS7 INS7 INS7 INS45 INS45 MOV32 INS36 MOV43 INS45 INS42 MOV32 INS42 INS42 MOV32 INS42 INS45 INS42 UPD42 MOV42 INS42 UPD42 INS42 INS45 INS45 MOV42 INS42 INS42 INS45 INS86 INS90 MOV32 INS42 INS42 INS59 INS32 INS52 INS42 INS59 INS32 INS52 INS42 INS59 INS32 INS52 INS42 INS42 INS42 INS45 INS86 INS90 INS42 MOV32 INS42 INS42 INS59 INS32 INS52 INS42 MOV22 INS32 MOV22 INS32 MOV22 INS32 MOV22 INS32 MOV14 INS45 MOV42 INS45 MOV42 INS11 INS21 INS45 INS45 UPD42 UPD42 INS45 INS45 INS45 INS45 INS45 UPD42 UPD42 UPD45 UPD42 UPD42 INS45 INS45 INS45 INS45 INS59 INS32 INS52 INS42 INS42 INS42 MOV42 UPD42 MOV42 INS42 MOV42 UPD42 MOV42 INS42 MOV42 INS59 INS32 INS52 INS42 UPD42 MOV42 INS42 MOV42 INS42 INS42 INS45 INS86 INS90 INS42 MOV32 INS42 INS42 MOV32 INS42 INS42 INS45 INS86 INS90 MOV32 INS42 INS42 MOV32 INS42 INS42 INS45 INS86 INS90 INS42 MOV32 INS42 INS42 MOV32 INS42 INS42 INS45 INS86 INS90 MOV32 INS42 INS42 MOV32 UPD43 INS45 UPD43 INS9 INS42 MOV43 INS42 INS45 INS32 MOV32 INS42 INS42 MOV42 UPD42 MOV42 INS42 MOV42 INS59 INS32 INS52 INS42 INS59 INS32 INS52 INS42 INS59 INS32 INS52 INS42 INS59 INS32 INS52 INS42 UPD42 UPD42 UPD42 INS42 INS45 INS45 INS42 INS42 INS45 MOV22 INS45 INS45 MOV42 UPD42 UPD42 UPD40 INS45 UPD42 MOV42 INS42 MOV42 INS42 UPD42 MOV42 INS42 UPD42 MOV42 INS42 MOV42 INS42 UPD42 MOV42 INS42 MOV52 MOV42 INS45 UPD42 INS42 INS45 UPD42 UPD42 INS45 INS45 INS45 INS45 MOV43 INS45 UPD42 INS42 INS45 INS45 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL42 DEL67 DEL65 DEL65 DEL42 DEL68 DEL65 DEL29 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL42 DEL42 DEL68 DEL65 DEL29 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL66 DEL66 DEL66 DEL42 DEL67 DEL65 DEL66 DEL65 DEL42 DEL68 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL33 DEL59 DEL23 DEL66 DEL42 DEL67 DEL65 DEL66 DEL42 DEL67 DEL65 DEL66 DEL65 DEL29 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL40 DEL42 DEL32 DEL42 DEL42 DEL40 DEL32 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL14 DEL7 DEL21 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL45 DEL42 DEL32 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL52 DEL42 DEL22 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL21 DEL42 DEL52 DEL42 DEL22 DEL42 DEL34 DEL38 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL40 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL52 DEL42 DEL22 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL40 DEL42 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL42 DEL43 DEL74 DEL52 DEL42 DEL22 DEL42 DEL32 DEL14 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL74 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL83 DEL39 DEL34 DEL59 DEL23 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL52 DEL42 DEL22 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL40 DEL42 DEL32 DEL42 DEL37 DEL36 DEL27 DEL14 DEL59 DEL60 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL42 DEL43 DEL74 DEL52 DEL42 DEL22 DEL42 DEL32 DEL14 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL74 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL83 DEL39 DEL34 DEL59 DEL23 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL52 DEL42 DEL22 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL40 DEL42 DEL32 DEL42 DEL37 DEL36 DEL27 DEL14 DEL59 DEL60 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL43 DEL83 DEL39 DEL34 DEL59 DEL23 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL52 DEL42 DEL22 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL40 DEL42 DEL32 DEL42 DEL37 DEL36 DEL27 DEL14 DEL59 DEL60 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL43 DEL83 DEL39 DEL34 DEL59 DEL23 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL52 DEL42 DEL22 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL40 DEL42 DEL32 DEL42 DEL37 DEL36 DEL27 DEL14 DEL59 DEL60 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL74 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL83 DEL39 DEL34 DEL59 DEL23 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL52 DEL42 DEL22 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL45 DEL42 DEL37 DEL36 DEL27 DEL14 DEL59 DEL60 DEL42 DEL9 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL74 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL83 DEL39 DEL34 DEL59 DEL23 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL52 DEL42 DEL22 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL45 DEL42 DEL37 DEL36 DEL27 DEL14 DEL59 DEL60 DEL42 DEL9 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL9 DEL52 DEL42 DEL22 DEL14 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL52 DEL42 DEL22 DEL42 DEL9 DEL32 DEL21 DEL40 DEL42 DEL42 DEL32 DEL42 DEL78 DEL42 DEL78 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL42 DEL78 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL42 DEL78 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL42 DEL78 DEL42 DEL78 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL42 DEL78 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL40 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL40 DEL42 DEL32 DEL42 DEL42 DEL40 DEL32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL40 DEL40 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL42 DEL42 DEL40 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL40 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL40 DEL32 DEL32 DEL21 DEL40 DEL42 DEL32 DEL42 DEL42 DEL40 DEL32 DEL40 DEL42 DEL32 DEL40 DEL40 DEL42 DEL42 DEL40 DEL32 DEL40 DEL40 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL40 DEL32 DEL34 DEL27 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL61 DEL52 DEL42 DEL22 DEL38 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL18 DEL25 DEL42 DEL42 DEL27 DEL42 DEL18 DEL8 DEL25 DEL8 DEL25 DEL42 DEL32 DEL42 DEL42 DEL32 DEL18 DEL8 DEL25 DEL42 DEL37 DEL21 DEL42 DEL34 DEL27 DEL10 DEL8 DEL25 DEL8 DEL61 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL18 DEL25 DEL42 DEL42 DEL27 DEL42 DEL18 DEL8 DEL25 DEL8 DEL25 DEL42 DEL32 DEL42 DEL42 DEL32 DEL18 DEL8 DEL25 DEL42 DEL42 DEL52 DEL42 DEL22 DEL32 DEL52 DEL42 DEL22 DEL38 DEL42 DEL34 DEL27 DEL27 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL42 DEL42 DEL40 DEL32 DEL32 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL40 DEL52 DEL42 DEL22 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL41 DEL8 DEL61 DEL33 DEL41 DEL8 DEL42 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL40 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL32 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL43 DEL60 DEL40 DEL40 DEL42 DEL42 DEL32 DEL40 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL40 DEL40 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL40 DEL32 DEL40 DEL40 DEL42 DEL42 DEL40 DEL32 DEL66 DEL65 DEL29 DEL39 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL33 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL32 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL33 DEL32 DEL21 DEL41 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL42 DEL52 DEL42 DEL22 DEL32 DEL38 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL52 DEL42 DEL22 DEL32 DEL21 DEL8 DEL25 DEL32 DEL21 DEL8 DEL25 DEL8 DEL51 DEL8 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL42 DEL42 DEL43 DEL40 DEL42 DEL32 DEL52 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL42 DEL32 DEL42 DEL32 DEL42 DEL33 DEL32 DEL21 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL40 DEL32 DEL32 DEL21 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL40 DEL42 DEL32 DEL32 DEL21 DEL42 DEL41 DEL32 DEL42 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL78 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL32 DEL38 DEL42 DEL42 DEL45 DEL52 DEL42 DEL22 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL52 DEL42 DEL22 DEL32 DEL21 DEL8 DEL25 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL27 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL41 DEL8 DEL25 DEL8 DEL33 DEL41 DEL8 DEL25 DEL8 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL39 DEL42 DEL44 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL52 DEL42 DEL22 DEL42 DEL34 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL9 DEL7 DEL21 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL7 DEL21 DEL8 DEL12 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL42 DEL9 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL25 DEL52 DEL42 DEL22 DEL33 DEL27 DEL52 DEL42 DEL22 DEL42 DEL43 DEL52 DEL14 DEL7 DEL21 DEL8 DEL25 DEL8 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL54 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL52 DEL42 DEL22 DEL9 DEL42 DEL9 DEL41 DEL25 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL9 DEL41 DEL8 DEL25 DEL42 DEL42 DEL32 DEL38 DEL9 DEL41 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL9 DEL41 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL43 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL8 DEL31 DEL1 DEL14 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL40 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL32 DEL32 DEL21 DEL42 DEL32 DEL21 DEL8 DEL61 DEL8 DEL51 DEL8 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL33 DEL27 DEL52 DEL42 DEL22 DEL33 DEL27 DEL27 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL38 DEL27 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL41 DEL8 DEL25 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL51 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL51 DEL8 DEL31 DEL66 DEL42 DEL67 DEL65 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL33 DEL32 DEL21 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL10 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL9 DEL7 DEL21 DEL8 DEL12 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL61 DEL8 DEL31 DEL40 DEL42 DEL32 DEL42 DEL38 DEL40 DEL42 DEL32 DEL42 DEL43 DEL40 DEL42 DEL32 DEL14 DEL53 DEL25 DEL8 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL52 DEL42 DEL22 DEL32 DEL21 DEL83 DEL42 DEL43 DEL42 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL27 DEL14 DEL59 DEL60 DEL42 DEL9 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL1 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL52 DEL42 DEL22 DEL14 DEL41 DEL42 DEL78 DEL42 DEL42 DEL40 DEL32 DEL42 DEL32 DEL21 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL31 DEL42 DEL42 DEL40 DEL32 DEL40 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40
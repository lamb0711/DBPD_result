Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class represents a catastrophic failure of the system,
- * especially the Java virtual machine.  Any class may,
- * at any time, indicate that a system failure has occurred by calling
- * {@link #initiateFailure(Error)} (or, less commonly,
- * {@link #setFailure(Error)}).
+ * This class represents a catastrophic failure of the system, especially the Java virtual machine.
+ * Any class may, at any time, indicate that a system failure has occurred by calling
+ * {@link #initiateFailure(Error)} (or, less commonly, {@link #setFailure(Error)}).
- * In practice, the most common type of failure that is likely to be
- * reported by an otherwise healthy JVM is {@link OutOfMemoryError}.  However,
- * GemFire will report any occurrence of {@link VirtualMachineError} as
- * a JVM failure.
+ * In practice, the most common type of failure that is likely to be reported by an otherwise
+ * healthy JVM is {@link OutOfMemoryError}. However, GemFire will report any occurrence of
+ * {@link VirtualMachineError} as a JVM failure.
- * When a failure is reported, you must assume that the JVM has <em>broken 
- * its fundamental execution contract</em> with your application. 
- * No programming invariant can be assumed to be true, and your 
+ * When a failure is reported, you must assume that the JVM has <em>broken its fundamental execution
+ * contract</em> with your application. No programming invariant can be assumed to be true, and your
- * <h1>Failure Hooks</h1>
- * GemFire uses this class to disable its distributed system (group
- * communication) and any open caches.  It also provides a hook for you
- * to respond to after GemFire disables itself.
- * <h1>Failure WatchDog</h1>
- * When {@link #startThreads()} is called, a "watchdog" {@link Thread} is started that 
- * periodically checks to see if system corruption has been reported.  When 
- * system corruption is detected, this thread proceeds to:
+ * <h1>Failure Hooks</h1> GemFire uses this class to disable its distributed system (group
+ * communication) and any open caches. It also provides a hook for you to respond to after GemFire
+ * disables itself.
+ * <h1>Failure WatchDog</h1> When {@link #startThreads()} is called, a "watchdog" {@link Thread} is
+ * started that periodically checks to see if system corruption has been reported. When system
+ * corruption is detected, this thread proceeds to:
- * <li>
- * <em>Close GemFire</em> -- Group communication is ceased (this cache
- * member recuses itself from the distributed system) and the cache
- * is further poisoned (it is pointless to try to cleanly close it at this
- * point.).
+ * <li><em>Close GemFire</em> -- Group communication is ceased (this cache member recuses itself
+ * from the distributed system) and the cache is further poisoned (it is pointless to try to cleanly
+ * close it at this point.).
- * After this has successfully ended, we launch a
- * </li>
- * <li>
- * <em>failure action</em>, a user-defined Runnable
- * {@link #setFailureAction(Runnable)}.
- * By default, this Runnable performs nothing.  If you feel you need to perform
- * an action before exiting the JVM, this hook gives you a
- * means of attempting some action.  Whatever you attempt should be extremely
- * simple, since your Java execution environment has been corrupted.
+ * After this has successfully ended, we launch a</li>
+ * <li><em>failure action</em>, a user-defined Runnable {@link #setFailureAction(Runnable)}. By
+ * default, this Runnable performs nothing. If you feel you need to perform an action before exiting
+ * the JVM, this hook gives you a means of attempting some action. Whatever you attempt should be
+ * extremely simple, since your Java execution environment has been corrupted.
- * GemStone recommends that you employ 
- * <a href="http://wrapper.tanukisoftware.org/doc/english/introduction.html">
- * Java Service Wrapper</a> to detect when your JVM exits and to perform
- * appropriate failure and restart actions.
+ * GemStone recommends that you employ
+ * <a href="http://wrapper.tanukisoftware.org/doc/english/introduction.html"> Java Service
+ * Wrapper</a> to detect when your JVM exits and to perform appropriate failure and restart actions.
- * <li>
- * Finally, if the application has granted the watchdog permission to exit the JVM
- * (via {@link #setExitOK(boolean)}), the watchdog calls {@link System#exit(int)} with
- * an argument of 1.  If you have not granted this class permission to
- * close the JVM, you are <em>strongly</em>  advised to call it in your
- * failure action (in the previous step).
- * </li>
+ * <li>Finally, if the application has granted the watchdog permission to exit the JVM (via
+ * {@link #setExitOK(boolean)}), the watchdog calls {@link System#exit(int)} with an argument of 1.
+ * If you have not granted this class permission to close the JVM, you are <em>strongly</em> advised
+ * to call it in your failure action (in the previous step).</li>
- * <p> 
- * Each of these actions will be run exactly once in the above described
- * order.  However, if either step throws any type of error ({@link Throwable}), 
- * the watchdog will assume that the JVM is still under duress (esp. an 
- * {@link OutOfMemoryError}), will wait a bit, and then retry the failed action.
- * It bears repeating that you should be very cautious of any Runnables you
- * ask this class to run.  By definition the JVM is <em>very sick</em>
- * when failure has been signalled.  
+ * Each of these actions will be run exactly once in the above described order. However, if either
+ * step throws any type of error ({@link Throwable}), the watchdog will assume that the JVM is still
+ * under duress (esp. an {@link OutOfMemoryError}), will wait a bit, and then retry the failed
+ * action.
- * <h1>Failure Proctor</h1>
- * In addition to the failure watchdog, {@link #startThreads()} creates a second
- * thread (the "proctor") that monitors free memory. It does this by examining
- * {@link Runtime#freeMemory() free memory},  
- * {@link Runtime#totalMemory() total memory} and 
- * {@link Runtime#maxMemory() maximum memory}.  If the amount of available 
- * memory stays below a given 
- * {@link #setFailureMemoryThreshold(long) threshold}, for
- * more than {@link #WATCHDOG_WAIT} seconds, the watchdog is notified.
+ * It bears repeating that you should be very cautious of any Runnables you ask this class to run.
+ * By definition the JVM is <em>very sick</em> when failure has been signalled.
+ * <p>
+ * <h1>Failure Proctor</h1> In addition to the failure watchdog, {@link #startThreads()} creates a
+ * second thread (the "proctor") that monitors free memory. It does this by examining
+ * {@link Runtime#freeMemory() free memory}, {@link Runtime#totalMemory() total memory} and
+ * {@link Runtime#maxMemory() maximum memory}. If the amount of available memory stays below a given
+ * {@link #setFailureMemoryThreshold(long) threshold}, for more than {@link #WATCHDOG_WAIT} seconds,
+ * the watchdog is notified.
- * {@link SystemFailure#setFailureMemoryThreshold(long) setting} the failure memory threshold
- * to a negative value.
+ * {@link SystemFailure#setFailureMemoryThreshold(long) setting} the failure memory threshold to a
+ * negative value.
- * The proctor is a second line of defense, attempting to detect 
- * OutOfMemoryError conditions in circumstances where nothing alerted the
- * watchdog.  For instance, a third-party jar might incorrectly handle this
- * error and leave your virtual machine in a "stuck" state.
+ * The proctor is a second line of defense, attempting to detect OutOfMemoryError conditions in
+ * circumstances where nothing alerted the watchdog. For instance, a third-party jar might
+ * incorrectly handle this error and leave your virtual machine in a "stuck" state.
- * Note that the proctor does not relieve you of the obligation to
- * follow the best practices in the next section.
+ * Note that the proctor does not relieve you of the obligation to follow the best practices in the
+ * next section.
- * <h2>Catch and Handle VirtualMachineError</h2>
- * If you feel obliged to catch <em>either</em> {@link Error}, or 
- * {@link Throwable}, you <em>must</em>also check for 
- * {@link VirtualMachineError} like so:
+ * <h2>Catch and Handle VirtualMachineError</h2> If you feel obliged to catch <em>either</em>
+ * {@link Error}, or {@link Throwable}, you <em>must</em>also check for {@link VirtualMachineError}
+ * like so:
+ * 
- * <h2>Periodically Check For Errors</h2>
- * Check for serious system errors at
- * appropriate points in your algorithms.  You may elect to use
- * the {@link #checkFailure()} utility function, but you are
- * not required to (you could just see if {@link SystemFailure#getFailure()}
- * returns a non-null result).  
+ * 
+ * <h2>Periodically Check For Errors</h2> Check for serious system errors at appropriate points in
+ * your algorithms. You may elect to use the {@link #checkFailure()} utility function, but you are
+ * not required to (you could just see if {@link SystemFailure#getFailure()} returns a non-null
+ * result).
- * A job processing loop is a good candidate, for
- * instance, in org.apache.org.jgroups.protocols.UDP#run(), 
- * which implements {@link Thread#run}:
+ * A job processing loop is a good candidate, for instance, in
+ * org.apache.org.jgroups.protocols.UDP#run(), which implements {@link Thread#run}:
+ * 
- * <h2>Create Logging ThreadGroups</h2>
- * If you create any Thread, a best practice is to catch severe errors
- * and signal failure appropriately.  One trick to do this is to create a 
- * ThreadGroup that handles uncaught exceptions by overriding 
- * {@link ThreadGroup#uncaughtException(Thread, Throwable)} and to declare 
- * your thread as a member of that {@link ThreadGroup}.  This also has a 
- * significant side-benefit in that most uncaught exceptions 
- * can be detected:
+ * 
+ * <h2>Create Logging ThreadGroups</h2> If you create any Thread, a best practice is to catch severe
+ * errors and signal failure appropriately. One trick to do this is to create a ThreadGroup that
+ * handles uncaught exceptions by overriding
+ * {@link ThreadGroup#uncaughtException(Thread, Throwable)} and to declare your thread as a member
+ * of that {@link ThreadGroup}. This also has a significant side-benefit in that most uncaught
+ * exceptions can be detected:
+ * 
-      }; * </pre>
- * <p>
-  * <h2>Catches of Error and Throwable Should Check for Failure</h2>
-  * Keep in mind that peculiar or flat-out<em>impossible</em>  exceptions may 
-  * ensue after a VirtualMachineError has been thrown <em>anywhere</em> in
-  * your virtual machine. Whenever you catch {@link Error} or {@link Throwable}, 
-  * you should also make sure that you aren't dealing with a corrupted JVM:
-  * <p>
-  * <pre>
-        catch (Throwable t) {
-          // Whenever you catch Error or Throwable, you must also
-          // catch VirtualMachineError (see above).  However, there is
-          // _still_ a possibility that you are dealing with a cascading
-          // error condition, so you also need to check to see if the JVM
-          // is still usable:
-          SystemFailure.{@link #checkFailure() checkFailure}();
-          ...
-        }
+      }; *
+ * <p>
+ * <h2>Catches of Error and Throwable Should Check for Failure</h2> Keep in mind that peculiar or
+ * flat-out<em>impossible</em> exceptions may ensue after a VirtualMachineError has been thrown
+ * <em>anywhere</em> in your virtual machine. Whenever you catch {@link Error} or {@link Throwable},
+ * you should also make sure that you aren't dealing with a corrupted JVM:
+ * <p>
+ * 
+ * <pre>
+       catch (Throwable t) {
+         // Whenever you catch Error or Throwable, you must also
+         // catch VirtualMachineError (see above).  However, there is
+         // _still_ a possibility that you are dealing with a cascading
+         // error condition, so you also need to check to see if the JVM
+         // is still usable:
+         SystemFailure.{@link #checkFailure() checkFailure}();
+         ...
+       }
+ * </pre>
+ * 
-@edu.umd.cs.findbugs.annotations.SuppressWarnings(value="DM_GC", justification="This class performs System.gc as last ditch effort during out-of-memory condition.") 
+@edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "DM_GC",
+    justification = "This class performs System.gc as last ditch effort during out-of-memory condition.")
-   * Time to wait during stopWatchdog and stopProctor. Not final
-   * for tests
+   * Time to wait during stopWatchdog and stopProctor. Not final for tests
-   * Preallocated error messages\
-   * LocalizedStrings may use memory (in the form of an iterator)
-   * so we must get the translated messages in advance.
+   * Preallocated error messages\ LocalizedStrings may use memory (in the form of an iterator) so we
+   * must get the translated messages in advance.
-   static final String JVM_CORRUPTION = LocalizedStrings.SystemFailure_JVM_CORRUPTION_HAS_BEEN_DETECTED.toLocalizedString();
-   static final String CALLING_SYSTEM_EXIT = LocalizedStrings.SystemFailure_SINCE_THIS_IS_A_DEDICATED_CACHE_SERVER_AND_THE_JVM_HAS_BEEN_CORRUPTED_THIS_PROCESS_WILL_NOW_TERMINATE_PERMISSION_TO_CALL_SYSTEM_EXIT_INT_WAS_GIVEN_IN_THE_FOLLOWING_CONTEXT.toLocalizedString();
-   public static final String DISTRIBUTION_HALTED_MESSAGE = LocalizedStrings.SystemFailure_DISTRIBUTION_HALTED_DUE_TO_JVM_CORRUPTION.toLocalizedString();
-   public static final String DISTRIBUTED_SYSTEM_DISCONNECTED_MESSAGE = LocalizedStrings.SystemFailure_DISTRIBUTED_SYSTEM_DISCONNECTED_DUE_TO_JVM_CORRUPTION.toLocalizedString();
+  static final String JVM_CORRUPTION =
+      LocalizedStrings.SystemFailure_JVM_CORRUPTION_HAS_BEEN_DETECTED.toLocalizedString();
+  static final String CALLING_SYSTEM_EXIT =
+      LocalizedStrings.SystemFailure_SINCE_THIS_IS_A_DEDICATED_CACHE_SERVER_AND_THE_JVM_HAS_BEEN_CORRUPTED_THIS_PROCESS_WILL_NOW_TERMINATE_PERMISSION_TO_CALL_SYSTEM_EXIT_INT_WAS_GIVEN_IN_THE_FOLLOWING_CONTEXT
+          .toLocalizedString();
+  public static final String DISTRIBUTION_HALTED_MESSAGE =
+      LocalizedStrings.SystemFailure_DISTRIBUTION_HALTED_DUE_TO_JVM_CORRUPTION.toLocalizedString();
+  public static final String DISTRIBUTED_SYSTEM_DISCONNECTED_MESSAGE =
+      LocalizedStrings.SystemFailure_DISTRIBUTED_SYSTEM_DISCONNECTED_DUE_TO_JVM_CORRUPTION
+          .toLocalizedString();
-   * This is usually an instance of {@link VirtualMachineError}, but it
-   * is not required to be such.
+   * This is usually an instance of {@link VirtualMachineError}, but it is not required to be such.
-  
+
-  
+
-  
+
-   * If we're going to exit the JVM, I want to be accountable for who
-   * told us it was OK.
+   * If we're going to exit the JVM, I want to be accountable for who told us it was OK.
-  
+
-   * Indicate whether it is acceptable to call {@link System#exit(int)} after
-   * failure processing has completed.
+   * Indicate whether it is acceptable to call {@link System#exit(int)} after failure processing has
+   * completed.
-    }
-    else {
+    } else {
-  
-  //merge42180: Added this method while merging 42180. It should have already be here through different merges or will come later
+
+  // merge42180: Added this method while merging 42180. It should have already be here through
+  // different merges or will come later
-   * Returns true if the given Error is a fatal to the JVM and it should be shut
-   * down. Code should call {@link #initiateFailure(Error)} or
-   * {@link #setFailure(Error)} if this returns true.
+   * Returns true if the given Error is a fatal to the JVM and it should be shut down. Code should
+   * call {@link #initiateFailure(Error)} or {@link #setFailure(Error)} if this returns true.
+
-    
+
-  
+
-   * Synchronizes access to state variables, used to notify the watchdog
-   * when to run
+   * Synchronizes access to state variables, used to notify the watchdog when to run
-  
+
-  private static volatile  boolean failureActionCompleted = false;
+  private static volatile boolean failureActionCompleted = false;
-      };  
-    }
-  
+    };
+  }
+
-   * This is the amount of time, in seconds, the watchdog periodically awakens
-   * to see if the system has been corrupted.
+   * This is the amount of time, in seconds, the watchdog periodically awakens to see if the system
+   * has been corrupted.
-   * The watchdog will be explicitly awakened by calls to
-   * {@link #setFailure(Error)} or {@link #initiateFailure(Error)}, but
-   * it will awaken of its own accord periodically to check for failure even
-   * if the above calls do not occur.
+   * The watchdog will be explicitly awakened by calls to {@link #setFailure(Error)} or
+   * {@link #initiateFailure(Error)}, but it will awaken of its own accord periodically to check for
+   * failure even if the above calls do not occur.
-   * This can be set with the system property 
-   * <code>gemfire.WATCHDOG_WAIT</code>. The default is 15 sec.
+   * This can be set with the system property <code>gemfire.WATCHDOG_WAIT</code>. The default is 15
+   * sec.
-  static public final int WATCHDOG_WAIT = Integer
-      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "WATCHDOG_WAIT", 15).intValue();
-  
+  static public final int WATCHDOG_WAIT =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "WATCHDOG_WAIT", 15).intValue();
+
-  
+
-   * Should be invoked when GemFire cache is being created. 
+   * Should be invoked when GemFire cache is being created.
-   * Should be invoked when GemFire cache is closing or closed. 
+   * Should be invoked when GemFire cache is closing or closed.
-  
+
-    if(watchDogSnapshot != null) {
+    if (watchDogSnapshot != null) {
-  
+
-    
+
-    
+
-    }
-    catch (ExceptionInInitializerError e) {
+    } catch (ExceptionInInitializerError e) {
-    }
-    catch (CancelException e) {
+    } catch (CancelException e) {
-    }
-    catch (Throwable t) {
+    } catch (Throwable t) {
-         logFine(WATCHDOG_NAME, "Waiting for disaster");
+          logFine(WATCHDOG_NAME, "Waiting for disaster");
-            failureSync.wait(WATCHDOG_WAIT * 1000); 
-          }
-          catch (InterruptedException e) {
+            failureSync.wait(WATCHDOG_WAIT * 1000);
+          } catch (InterruptedException e) {
-        
+
-          // Tail wag.  Go back to sleep.
+          // Tail wag. Go back to sleep.
-        // BOW WOW WOW WOW WOW!  Corrupted system.
-        if (!warned ) {
+        // BOW WOW WOW WOW WOW! Corrupted system.
+        if (!warned) {
-        
+
-          }
-          catch (Throwable t) {
+          } catch (Throwable t) {
-        
+
-            }
-            catch (Throwable t) {
+            } catch (Throwable t) {
-        
+
-        
+
-              CALLING_SYSTEM_EXIT,
-              exitExcuse);
-          
+              CALLING_SYSTEM_EXIT, exitExcuse);
+
-          // acceptable to call System.exit.  This is one of those
+          // acceptable to call System.exit. This is one of those
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-  
+
-   * This mutex controls access to {@link #firstStarveTime} and
-   * {@link #minimumMemoryThreshold}.
+   * This mutex controls access to {@link #firstStarveTime} and {@link #minimumMemoryThreshold}.
-   * I'm hoping that a fat lock is never created here, so that
-   * an object allocation isn't necessary to acquire this
-   * mutex.  You'd have to have A LOT of contention on this mutex
-   * in order for a fat lock to be created, which indicates IMHO
-   * a serious problem in your applications.
+   * I'm hoping that a fat lock is never created here, so that an object allocation isn't necessary
+   * to acquire this mutex. You'd have to have A LOT of contention on this mutex in order for a fat
+   * lock to be created, which indicates IMHO a serious problem in your applications.
-  
+
-   * This is the minimum amount of memory that the proctor will
-   * tolerate before declaring a system failure.
+   * This is the minimum amount of memory that the proctor will tolerate before declaring a system
+   * failure.
-  static long minimumMemoryThreshold = Long.getLong(
-      DistributionConfig.GEMFIRE_PREFIX + "SystemFailure.chronic_memory_threshold", 1048576).longValue();
-  
+  static long minimumMemoryThreshold =
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "SystemFailure.chronic_memory_threshold",
+          1048576).longValue();
+
-   * This is the interval, in seconds, that the proctor
-   * thread will awaken and poll system free memory.
+   * This is the interval, in seconds, that the proctor thread will awaken and poll system free
+   * memory.
-   * The default is 1 sec.  This can be set using the system property
+   * The default is 1 sec. This can be set using the system property
-  static final public long MEMORY_POLL_INTERVAL = Long.getLong(
-      DistributionConfig.GEMFIRE_PREFIX + "SystemFailure.MEMORY_POLL_INTERVAL", 1).longValue();
-  
+  static final public long MEMORY_POLL_INTERVAL =
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "SystemFailure.MEMORY_POLL_INTERVAL", 1)
+          .longValue();
+
-   * This is the maximum amount of time, in seconds, that the proctor thread
-   * will tolerate seeing free memory stay below
-   * {@link #setFailureMemoryThreshold(long)}, after which point it will 
+   * This is the maximum amount of time, in seconds, that the proctor thread will tolerate seeing
+   * free memory stay below {@link #setFailureMemoryThreshold(long)}, after which point it will
-   * The default is 15 sec.  This can be set using the system property
+   * The default is 15 sec. This can be set using the system property
-  static final public long MEMORY_MAX_WAIT = Long.getLong(
-      DistributionConfig.GEMFIRE_PREFIX + "SystemFailure.MEMORY_MAX_WAIT", 15).longValue();
-  
+  static final public long MEMORY_MAX_WAIT = Long
+      .getLong(DistributionConfig.GEMFIRE_PREFIX + "SystemFailure.MEMORY_MAX_WAIT", 15).longValue();
+
-   * Flag that determines whether or not we monitor memory on our own.
-   * If this flag is set, we will check freeMemory, invoke GC if free memory 
-   * gets low, and start throwing our own OutOfMemoryException if 
+   * Flag that determines whether or not we monitor memory on our own. If this flag is set, we will
+   * check freeMemory, invoke GC if free memory gets low, and start throwing our own
+   * OutOfMemoryException if
-   * The default is false, so this monitoring is turned off. This monitoring has been found 
-   * to be unreliable in non-Sun VMs when the VM is under stress or behaves in unpredictable ways.
+   * The default is false, so this monitoring is turned off. This monitoring has been found to be
+   * unreliable in non-Sun VMs when the VM is under stress or behaves in unpredictable ways.
-  static final public boolean MONITOR_MEMORY = Boolean.getBoolean(
-      DistributionConfig.GEMFIRE_PREFIX + "SystemFailure.MONITOR_MEMORY");
-  
+  static final public boolean MONITOR_MEMORY =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "SystemFailure.MONITOR_MEMORY");
+
-  
+
-  
+
-  
+
-  
+
-   * This is the previous measure of total memory.  If it changes,
-   * we reset the proctor's starve statistic.
+   * This is the previous measure of total memory. If it changes, we reset the proctor's starve
+   * statistic.
-  
+
-   * This is the run loop for the proctor thread (formally known
-   * as the "watchcat" (grin)
+   * This is the run loop for the proctor thread (formally known as the "watchcat" (grin)
-    
+
-    final OutOfMemoryError oome = new OutOfMemoryError(LocalizedStrings.SystemFailure_0_MEMORY_HAS_REMAINED_CHRONICALLY_BELOW_1_BYTES_OUT_OF_A_MAXIMUM_OF_2_FOR_3_SEC.toLocalizedString(new Object[] {PROCTOR_NAME, Long.valueOf(minimumMemoryThreshold), Long.valueOf(maxMemory), Integer.valueOf(WATCHDOG_WAIT)}));
-    
+    final OutOfMemoryError oome = new OutOfMemoryError(
+        LocalizedStrings.SystemFailure_0_MEMORY_HAS_REMAINED_CHRONICALLY_BELOW_1_BYTES_OUT_OF_A_MAXIMUM_OF_2_FOR_3_SEC
+            .toLocalizedString(new Object[] {PROCTOR_NAME, Long.valueOf(minimumMemoryThreshold),
+                Long.valueOf(maxMemory), Integer.valueOf(WATCHDOG_WAIT)}));
+
-    logFine(PROCTOR_NAME, "Starting, threshold = " + minimumMemoryThreshold 
-        + "; max = " + maxMemory);
+    logFine(PROCTOR_NAME,
+        "Starting, threshold = " + minimumMemoryThreshold + "; max = " + maxMemory);
-        //*** catnap...
+        // *** catnap...
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-        
+
-        //*** Twitch ear, take a bath...
+        // *** Twitch ear, take a bath...
-        
-        if(!MONITOR_MEMORY) {
+
+        if (!MONITOR_MEMORY) {
-        //*** Sit up, stretch...
+        // *** Sit up, stretch...
-            logFine(PROCTOR_NAME, "totalMemory (" + totalMemory 
-                + ") < maxMemory (" + maxMemory + ")");
+            logFine(PROCTOR_NAME,
+                "totalMemory (" + totalMemory + ") < maxMemory (" + maxMemory + ")");
-        //*** Hey, is that the food bowl?
-        
+        // *** Hey, is that the food bowl?
+
-        if(freeMemory==0) {
+        if (freeMemory == 0) {
-           * This is to workaround X bug #41821 in JRockit.
-           * Often, Jrockit returns 0 from Runtime.getRuntime().freeMemory()
-           * Allocating this one object and calling again seems to workaround the problem.
+           * This is to workaround X bug #41821 in JRockit. Often, Jrockit returns 0 from
+           * Runtime.getRuntime().freeMemory() Allocating this one object and calling again seems to
+           * workaround the problem.
-        
+
-          
+
-        
-        //*** Leap to feet, nose down, tail switching...
+
+        // *** Leap to feet, nose down, tail switching...
-            logFine(PROCTOR_NAME, "Noting current memory " + freeMemory 
-                + " is less than threshold " + curThreshold);
-          }
-          else {
-            logWarning(
-                PROCTOR_NAME,
-                "Noting that current memory available is less than the currently designated threshold", null);
+            logFine(PROCTOR_NAME,
+                "Noting current memory " + freeMemory + " is less than threshold " + curThreshold);
+          } else {
+            logWarning(PROCTOR_NAME,
+                "Noting that current memory available is less than the currently designated threshold",
+                null);
-        
-        //*** squirm, wait for the right moment...wait...wait...
+
+        // *** squirm, wait for the right moment...wait...wait...
-            logFine(PROCTOR_NAME, "...memory is still below threshold: "
-                + freeMemory);
-          }
-          else {
-            logWarning(
-                PROCTOR_NAME,
-                "Noting that current memory available is still below currently designated threshold", null);
+            logFine(PROCTOR_NAME, "...memory is still below threshold: " + freeMemory);
+          } else {
+            logWarning(PROCTOR_NAME,
+                "Noting that current memory available is still below currently designated threshold",
+                null);
-        
-        //*** Meow! Meow! MEOWWWW!!!!!
-        
+
+        // *** Meow! Meow! MEOWWWW!!!!!
+
-      }
-      catch (Throwable t) {
+      } catch (Throwable t) {
-  
+
-  
+
-   * If true, we track the progress of emergencyClose
-   * on System.err
+   * If true, we track the progress of emergencyClose on System.err
-  
+
-  
+
-  
+
-  
+
-   * Since it requires object memory to unpack a jar file,
-   * make sure this JVM has loaded the classes necessary for
-   * closure <em>before</em> it becomes necessary to use them.
+   * Since it requires object memory to unpack a jar file, make sure this JVM has loaded the classes
+   * necessary for closure <em>before</em> it becomes necessary to use them.
-   * Note that just touching the class in order to load it
-   * is usually sufficient, so all an implementation needs
-   * to do is to reference the same classes used in
-   * {@link #emergencyClose()}.  Just make sure to do it while
-   * you still have memory to succeed!
+   * Note that just touching the class in order to load it is usually sufficient, so all an
+   * implementation needs to do is to reference the same classes used in {@link #emergencyClose()}.
+   * Just make sure to do it while you still have memory to succeed!
+
-    if (emergencyClassesLoaded) return;
+    if (emergencyClassesLoaded)
+      return;
-  
+
-   * The contract of this method is that it should not
-   * acquire any synchronization mutexes nor create any objects.
+   * The contract of this method is that it should not acquire any synchronization mutexes nor
+   * create any objects.
-   * The former is because the system is in an undefined state and
-   * attempting to acquire the mutex may cause a hang.
+   * The former is because the system is in an undefined state and attempting to acquire the mutex
+   * may cause a hang.
-   * The latter is because the likelihood is that we are invoking
-   * this method due to memory exhaustion, so any attempt to create
-   * an object will also cause a hang.
+   * The latter is because the likelihood is that we are invoking this method due to memory
+   * exhaustion, so any attempt to create an object will also cause a hang.
-   * This method is not meant to be called directly (but, well, I
-   * guess it could).  It is public to document the contract
-   * that is implemented by <code>emergencyClose</code> in other
-   * parts of the system.
+   * This method is not meant to be called directly (but, well, I guess it could). It is public to
+   * document the contract that is implemented by <code>emergencyClose</code> in other parts of the
+   * system.
-    
+
-    if  (TRACE_CLOSE) {
+    if (TRACE_CLOSE) {
-    
+
-    
-    System.gc(); //  This will fail if we're out of memory?/
-    if (TRACE_CLOSE)  {
+    System.gc(); // This will fail if we're out of memory?/
+
+    if (TRACE_CLOSE) {
-   * Unfortunately, attempting to create a new Throwable at this
-   * point may cause the thread to hang (instead of generating
-   * another OutOfMemoryError), so we have to make do with whatever
-   * Error we have, instead of wrapping it with one pertinent
-   * to the current context.  See bug 38394.
+   * Unfortunately, attempting to create a new Throwable at this point may cause the thread to hang
+   * (instead of generating another OutOfMemoryError), so we have to make do with whatever Error we
+   * have, instead of wrapping it with one pertinent to the current context. See bug 38394.
-    if (failure != null) throw failure;
+    if (failure != null)
+      throw failure;
-  
+
-  
+
-   * Utility function to check for failures.  If a failure is
-   * detected, this methods throws an AssertionFailure.
+   * Utility function to check for failures. If a failure is detected, this methods throws an
+   * AssertionFailure.
-   * @throws Error if the system has been corrupted and a thread-specific 
-   * AssertionError cannot be allocated
+   * @throws Error if the system has been corrupted and a thread-specific AssertionError cannot be
+   *         allocated
-   * Signals that a system failure has occurred and then throws an
-   * AssertionError.
+   * Signals that a system failure has occurred and then throws an AssertionError.
-   * This method does not generate an error, and should only be used
-   * in circumstances where execution needs to continue, such as when
-   * re-implementing {@link ThreadGroup#uncaughtException(Thread, Throwable)}.
+   * This method does not generate an error, and should only be used in circumstances where
+   * execution needs to continue, such as when re-implementing
+   * {@link ThreadGroup#uncaughtException(Thread, Throwable)}.
-      throw new IllegalArgumentException(LocalizedStrings.SystemFailure_YOU_ARE_NOT_PERMITTED_TO_UNSET_A_SYSTEM_FAILURE.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.SystemFailure_YOU_ARE_NOT_PERMITTED_TO_UNSET_A_SYSTEM_FAILURE
+              .toLocalizedString());
-    // (StackOverflowError).  There is a slight chance that the
+    // (StackOverflowError). There is a slight chance that the
-  
+
-   * This is usually (though not necessarily) an instance of
-   * {@link VirtualMachineError}.
+   * This is usually (though not necessarily) an instance of {@link VirtualMachineError}.
-   * A return value of null indicates that no system failure has yet been
-   * detected.
+   * A return value of null indicates that no system failure has yet been detected.
-   * Object synchronization can implicitly require object creation (fat locks 
-   * in JRockit for instance), so the underlying value is not synchronized
-   * (it is a volatile). This means the return value from this call is not 
-   * necessarily the <em>first</em> failure reported by the JVM.
+   * Object synchronization can implicitly require object creation (fat locks in JRockit for
+   * instance), so the underlying value is not synchronized (it is a volatile). This means the
+   * return value from this call is not necessarily the <em>first</em> failure reported by the JVM.
-   * Note that even if it <em>were</em> synchronized, it would only be a 
-   * proximal indicator near the time that the JVM crashed, and may not 
-   * actually reflect the underlying root cause that generated the failure.  
-   * For instance, if your JVM is running short of memory, this Throwable is 
-   * probably an innocent victim and <em>not</em> the actual allocation (or 
-   * series of allocations) that caused your JVM to exhaust memory.
+   * Note that even if it <em>were</em> synchronized, it would only be a proximal indicator near the
+   * time that the JVM crashed, and may not actually reflect the underlying root cause that
+   * generated the failure. For instance, if your JVM is running short of memory, this Throwable is
+   * probably an innocent victim and <em>not</em> the actual allocation (or series of allocations)
+   * that caused your JVM to exhaust memory.
-   * If this function returns a non-null value, keep in mind that the JVM is
-   * very limited.  In particular, any attempt to allocate objects may fail
-   * if the original failure was an OutOfMemoryError.  
+   * If this function returns a non-null value, keep in mind that the JVM is very limited. In
+   * particular, any attempt to allocate objects may fail if the original failure was an
+   * OutOfMemoryError.
-   * Sets a user-defined action that is run in the event
-   * that failure has been detected.
-   * <p> 
-   * This action is run <em>after</em> the GemFire cache has been shut down.
-   * If it throws any error, it will be reattempted indefinitely until it
-   * succeeds. This action may be dynamically modified while the system
-   * is running.
+   * Sets a user-defined action that is run in the event that failure has been detected.
+   * <p>
+   * This action is run <em>after</em> the GemFire cache has been shut down. If it throws any error,
+   * it will be reattempted indefinitely until it succeeds. This action may be dynamically modified
+   * while the system is running.
-   * Set the memory threshold under which system failure will be
-   * notified. 
+   * Set the memory threshold under which system failure will be notified.
-   * This value may be dynamically  modified while the system
-   * is running.  The default is 1048576 bytes.  This can be set using the 
-   * system property <code>gemfire.SystemFailure.chronic_memory_threshold</code>.
+   * This value may be dynamically modified while the system is running. The default is 1048576
+   * bytes. This can be set using the system property
+   * <code>gemfire.SystemFailure.chronic_memory_threshold</code>.
-  
-//  /**
-//   * For use by GemStone Quality Assurance Only
-//   * 
-//   * @deprecated TODO remove this
-//   */
-//  public static void reset() {
-//    System.gc();
-//    logWarning("DJP", "do not commit SystemFailure#reset", null);
-//    failure = null;
-//    failureAction = new Runnable() {
-//      public void run() {
-//        System.err.println("(SystemFailure) JVM corruption has been detected!");
-//        failure.printStackTrace();
-//      }
-//    };
-//    gemfireCloseCompleted = false;
-//    failureActionCompleted = false;
-//    synchronized (failureSync) {
-//      if (watchDog != null) {
-//        watchDog.interrupt();
-//      }
-//      watchDog = null;
-//      if (watchCat != null) {
-//        watchCat.interrupt();
-//      }
-//      watchCat = null;
-//    }
-//
-//    startWatchDog();
-//    startWatchCat();
-//  }
-  
+
+  // /**
+  // * For use by GemStone Quality Assurance Only
+  // *
+  // * @deprecated TODO remove this
+  // */
+  // public static void reset() {
+  // System.gc();
+  // logWarning("DJP", "do not commit SystemFailure#reset", null);
+  // failure = null;
+  // failureAction = new Runnable() {
+  // public void run() {
+  // System.err.println("(SystemFailure) JVM corruption has been detected!");
+  // failure.printStackTrace();
+  // }
+  // };
+  // gemfireCloseCompleted = false;
+  // failureActionCompleted = false;
+  // synchronized (failureSync) {
+  // if (watchDog != null) {
+  // watchDog.interrupt();
+  // }
+  // watchDog = null;
+  // if (watchCat != null) {
+  // watchCat.interrupt();
+  // }
+  // watchCat = null;
+  // }
+  //
+  // startWatchDog();
+  // startWatchCat();
+  // }
+
-    }
-    catch (Throwable t2) {
+    } catch (Throwable t2) {
-  
+
-   * Logging can require allocation of objects, so we wrap the
-   * logger so that failures are silently ignored.
+   * Logging can require allocation of objects, so we wrap the logger so that failures are silently
+   * ignored.
-//    if (PREFER_STDERR) {
-//      return logStdErr("warning", name, s, t);
-//    }
-//    try {
-//      log.warning(name + ": " + s, t);
-//      return true;
-//    }
-//    catch (Throwable t2) {
-//      return logStdErr("warning", name, s, t);
-//    }
+    // if (PREFER_STDERR) {
+    // return logStdErr("warning", name, s, t);
+    // }
+    // try {
+    // log.warning(name + ": " + s, t);
+    // return true;
+    // }
+    // catch (Throwable t2) {
+    // return logStdErr("warning", name, s, t);
+    // }
-  
+
-   * Logging can require allocation of objects, so we wrap the
-   * logger so that failures are silently ignored.
+   * Logging can require allocation of objects, so we wrap the logger so that failures are silently
+   * ignored.
-//    if (PREFER_STDERR) {
-//      logStdErr("info", name, s, null);
-//      return;
-//    }
-//    try {
-//      log.info(name + ": " + s);
-//    }
-//    catch (Throwable t) {
-//      logStdErr("info", name, s, t);
-//    }
+    // if (PREFER_STDERR) {
+    // logStdErr("info", name, s, null);
+    // return;
+    // }
+    // try {
+    // log.info(name + ": " + s);
+    // }
+    // catch (Throwable t) {
+    // logStdErr("info", name, s, t);
+    // }
-  
+
-   * Logging can require allocation of objects, so we wrap the
-   * logger so that failures are silently ignored.
+   * Logging can require allocation of objects, so we wrap the logger so that failures are silently
+   * ignored.
-//    if (DEBUG && PREFER_STDERR) {
-//      logStdErr("fine", name, s, null);
-//      return;
-//    }
-//    try {
-//      log.fine(name + ": " + s);
-//    }
-//    catch (Throwable t) {
-//      if (DEBUG) {
-//        logStdErr("fine", name, s, null);
-//      }
-//    }
+    // if (DEBUG && PREFER_STDERR) {
+    // logStdErr("fine", name, s, null);
+    // return;
+    // }
+    // try {
+    // log.fine(name + ": " + s);
+    // }
+    // catch (Throwable t) {
+    // if (DEBUG) {
+    // logStdErr("fine", name, s, null);
+    // }
+    // }
-  
+
-  
+
-   * This starts up the watchdog and proctor threads.
-   * This method is called when a Cache is created.
+   * This starts up the watchdog and proctor threads. This method is called when a Cache is created.
+
-   * This stops the threads that implement this service.
-   * This method is called when a Cache is closed.
+   * This stops the threads that implement this service. This method is called when a Cache is
+   * closed.
-  
+
-  
+

MOV66 INS29 MOV29 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS65 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL66
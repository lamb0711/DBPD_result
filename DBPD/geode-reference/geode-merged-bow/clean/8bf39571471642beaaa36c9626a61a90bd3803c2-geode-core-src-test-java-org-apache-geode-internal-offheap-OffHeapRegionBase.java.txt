Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Basic test of regions that use off heap storage.
- * Subclasses exist for the different types of offheap store.
+ * Basic test of regions that use off heap storage. Subclasses exist for the different types of
+ * offheap store.
-  
+
+
+
+
-    GemFireCacheImpl result = (GemFireCacheImpl) new CacheFactory(props).setPdxPersistent(isPersistent).create();
+    GemFireCacheImpl result =
+        (GemFireCacheImpl) new CacheFactory(props).setPdxPersistent(isPersistent).create();
+
-  
+
-  
+
-      assertEquals(64+perObjectOverhead(), ma.getUsedMemory());
-      assertEquals(offHeapSize-(64+perObjectOverhead()), ma.getFreeMemory());
+      assertEquals(64 + perObjectOverhead(), ma.getUsedMemory());
+      assertEquals(offHeapSize - (64 + perObjectOverhead()), ma.getFreeMemory());
-        ma.allocate(1024*1024*20);
+        ma.allocate(1024 * 1024 * 20);
-  
+
-      assertEquals(64+perObjectOverhead(), ma.getUsedMemory());
-      assertEquals(offHeapSize-(64+perObjectOverhead()), ma.getFreeMemory());
+      assertEquals(64 + perObjectOverhead(), ma.getUsedMemory());
+      assertEquals(offHeapSize - (64 + perObjectOverhead()), ma.getFreeMemory());
-        ma.allocate(1024*1024*10);
+        ma.allocate(1024 * 1024 * 10);
-      
+
+
-      org.apache.geode.test.dunit.Wait.waitForCriterion(waitForDisconnect, 10*1000, 100, true);
+      org.apache.geode.test.dunit.Wait.waitForCriterion(waitForDisconnect, 10 * 1000, 100, true);
-      byte[] data = new byte[] {1,2,3,4,5,6,7,8};
-      StoredObject mc1 = (StoredObject)ma.allocateAndInitialize(data, false, false);
-      assertEquals(data.length+perObjectOverhead(), ma.getUsedMemory());
-      assertEquals(offHeapSize-(data.length+perObjectOverhead()), ma.getFreeMemory());
+      byte[] data = new byte[] {1, 2, 3, 4, 5, 6, 7, 8};
+      StoredObject mc1 = (StoredObject) ma.allocateAndInitialize(data, false, false);
+      assertEquals(data.length + perObjectOverhead(), ma.getUsedMemory());
+      assertEquals(offHeapSize - (data.length + perObjectOverhead()), ma.getFreeMemory());
-      data = new byte[] {1,2,3,4,5,6,7};
+      data = new byte[] {1, 2, 3, 4, 5, 6, 7};
-      data2 = (byte[])so1.getDeserializedForReading();
+      data2 = (byte[]) so1.getDeserializedForReading();
-    doRegionTest(rs, rName, false/*compressed*/);
+    doRegionTest(rs, rName, false/* compressed */);
-  @SuppressWarnings({ "rawtypes", "unchecked" })
+  @SuppressWarnings({"rawtypes", "unchecked"})
-    boolean isPersistent = rs == RegionShortcut.LOCAL_PERSISTENT || rs == RegionShortcut.REPLICATE_PERSISTENT || rs == RegionShortcut.PARTITION_PERSISTENT;
+    boolean isPersistent = rs == RegionShortcut.LOCAL_PERSISTENT
+        || rs == RegionShortcut.REPLICATE_PERSISTENT || rs == RegionShortcut.PARTITION_PERSISTENT;
-      //System.out.println("After put of Integer value off heap used memory=" + ma.getUsedMemory());
+      // System.out.println("After put of Integer value off heap used memory=" +
+      // ma.getUsedMemory());
-      
+
-      
-      
+
+
-      //System.out.println("After put of Integer value off heap used memory=" + ma.getUsedMemory());
+      // System.out.println("After put of Integer value off heap used memory=" +
+      // ma.getUsedMemory());
-      //System.out.println("After put of Integer value off heap used memory=" + ma.getUsedMemory());
+      // System.out.println("After put of Integer value off heap used memory=" +
+      // ma.getUsedMemory());
-        
-        readBytes = (byte[])r.putIfAbsent("byteArray", originalBytes);
+
+        readBytes = (byte[]) r.putIfAbsent("byteArray", originalBytes);
-        
+
-          
+
-      /*while (value != null) */ {
+      /* while (value != null) */ {
-        
+
-    
+
-  
+
+
-    @Override public boolean equals(Object other) {
+
+    @Override
+    public boolean equals(Object other) {
+
-    public MyPdxWithPartialEquals() {
-    }
+
+    public MyPdxWithPartialEquals() {}
+
+
-  
+
-    
+
-    
+
-    
+
-        ((OffHeapStoredObject)this.ohOldValue).release();
+        ((OffHeapStoredObject) this.ohOldValue).release();
-        ((OffHeapStoredObject)this.ohNewValue).release();
+        ((OffHeapStoredObject) this.ohNewValue).release();
-  
+
+
+
+
+
+
+
+
+
+
-      r = gfc.createRegionFactory(RegionShortcut.LOCAL_PERSISTENT).setOffHeap(false).create("changedFromHeapToOffHeap");
+      r = gfc.createRegionFactory(RegionShortcut.LOCAL_PERSISTENT).setOffHeap(false)
+          .create("changedFromHeapToOffHeap");
-      r = gfc.createRegionFactory(RegionShortcut.LOCAL_PERSISTENT).setOffHeap(true).create("changedFromHeapToOffHeap");
+      r = gfc.createRegionFactory(RegionShortcut.LOCAL_PERSISTENT).setOffHeap(true)
+          .create("changedFromHeapToOffHeap");
-      r = gfc.createRegionFactory(RegionShortcut.LOCAL_PERSISTENT).setOffHeap(true).setCompressor(new SnappyCompressor()).create("region1");
+      r = gfc.createRegionFactory(RegionShortcut.LOCAL_PERSISTENT).setOffHeap(true)
+          .setCompressor(new SnappyCompressor()).create("region1");
-      r = gfc.createRegionFactory(RegionShortcut.LOCAL_PERSISTENT).setOffHeap(true).setCompressor(null).create("region1");
+      r = gfc.createRegionFactory(RegionShortcut.LOCAL_PERSISTENT).setOffHeap(true)
+          .setCompressor(null).create("region1");
-      if (orphans.size() >0) {
+      if (orphans.size() > 0) {
-      if (r !=null && !r.isDestroyed()) {
+      if (r != null && !r.isDestroyed()) {

UPD66 UPD66
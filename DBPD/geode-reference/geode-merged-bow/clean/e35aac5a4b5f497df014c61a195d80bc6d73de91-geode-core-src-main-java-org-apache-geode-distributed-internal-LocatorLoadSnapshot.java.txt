Merge branch 'release/1.5.0'

+
+  public static final String LOAD_IMBALANCE_THRESHOLD_PROPERTY_NAME =
+      "gemfire.locator-load-imbalance-threshold";
+
+  public static final float DEFAULT_LOAD_IMBALANCE_THRESHOLD = 10;
+
+  /**
+   * when replacing a client's current server we do not move a client from a highly loaded server to
+   * a less loaded server until imbalance reaches this threshold. Then we aggressively move clients
+   * until balance is achieved.
+   */
+  private float loadImbalanceThreshold;
+
+  /**
+   * when the loadImbalanceThreshold is hit this variable will be true and it will remain true until
+   * balance is achieved.
+   */
+  private boolean rebalancing;
+
+
+    String property = System.getProperty(LOAD_IMBALANCE_THRESHOLD_PROPERTY_NAME);
+    if (property != null) {
+      loadImbalanceThreshold = Float.parseFloat(property);
+    } else {
+      loadImbalanceThreshold = DEFAULT_LOAD_IMBALANCE_THRESHOLD;
+    }
-  private synchronized boolean isBalanced(Map groupServers) {
+  private synchronized boolean isBalanced(Map<ServerLocation, LoadHolder> groupServers) {
+    return isBalanced(groupServers, false);
+  }
+
+  private synchronized boolean isBalanced(Map<ServerLocation, LoadHolder> groupServers,
+      boolean withThresholdCheck) {
-    for (Iterator itr = groupServers.entrySet().iterator(); itr.hasNext();) {
-      Map.Entry next = (Entry) itr.next();
-      LoadHolder nextLoadReference = (LoadHolder) next.getValue();
+    for (Entry<ServerLocation, LoadHolder> loadHolderEntry : groupServers.entrySet()) {
+      LoadHolder nextLoadReference = loadHolderEntry.getValue();
-    return (worstLoad - bestLoad) <= largestLoadPerConnection;
+    boolean balanced = (worstLoad - bestLoad) <= largestLoadPerConnection;
+
+    if (withThresholdCheck) {
+      balanced = thresholdCheck(bestLoad, worstLoad, largestLoadPerConnection, balanced);
+    }
+
+    return balanced;
+  }
+
+
+  /**
+   * In order to keep from ping-ponging clients around the cluster we don't move a client unless
+   * imbalance is greater than the loadImbalanceThreshold.
+   * <p>
+   * When the threshold is reached we report imbalance until proper balance is achieved.
+   * </p>
+   * <p>
+   * This method has the side-effect of setting the <code>rebalancing</code> instance variable
+   * which, at the time of this writing, is only used by this method.
+   * </p>
+   */
+  synchronized boolean thresholdCheck(float bestLoad, float worstLoad,
+      float largestLoadPerConnection, boolean balanced) {
+    if (rebalancing) {
+      if (balanced) {
+        rebalancing = false;
+      }
+      return balanced;
+    }
+
+    // see if we're out of balance enough to trigger rebalancing or whether we
+    // should tolerate the imbalance
+    if (!balanced) {
+      float imbalance = worstLoad - bestLoad;
+      if (imbalance >= (largestLoadPerConnection * loadImbalanceThreshold)) {
+        rebalancing = true;
+      } else {
+        // we're not in balance but are within the threshold
+        balanced = true;
+      }
+    }
+    return balanced;
+  }
+
+  synchronized boolean isRebalancing() {
+    return rebalancing;
-    Map groupServers = (Map) connectionLoadMap.get(group);
+    Map<ServerLocation, LoadHolder> groupServers = (Map) connectionLoadMap.get(group);
-    if (isBalanced(groupServers)) {
+    if (isBalanced(groupServers, true)) {
-  public synchronized Map getLoadMap() {
+  public synchronized Map<ServerLocation, ServerLoad> getLoadMap() {
-  private List/* <LoadHolder> */ findBestServers(Map groupServers, Set excludedServers, int count) {
+  /**
+   *
+   * @param groupServers the servers to consider
+   * @param excludedServers servers to exclude
+   * @param count how many you want. a negative number means all of them in order of best to worst
+   * @return a list of best...worst server LoadHolders
+   */
+  private List /* <LoadHolder> */ findBestServers(Map<ServerLocation, LoadHolder> groupServers,
+      Set excludedServers, int count) {
+
+    boolean retainAll = (count < 0);
-    for (Iterator itr = groupServers.entrySet().iterator(); itr.hasNext();) {
-      Map.Entry next = (Entry) itr.next();
-      ServerLocation location = (ServerLocation) next.getKey();
+
+    for (Map.Entry<ServerLocation, LoadHolder> loadEntry : groupServers.entrySet()) {
+      ServerLocation location = loadEntry.getKey();
-      LoadHolder nextLoadReference = (LoadHolder) next.getValue();
+
+      LoadHolder nextLoadReference = loadEntry.getValue();
-      if (bestEntries.size() < count || count == -1 || nextLoad < lastBestLoad) {
+      if ((bestEntries.size() < count) || retainAll || (nextLoad < lastBestLoad)) {
-        if (count != -1 && bestEntries.size() > count) {
+        if (!retainAll && (bestEntries.size() > count)) {
-  private LoadHolder isCurrentServerMostLoaded(ServerLocation currentServer, Map groupServers) {
-    final LoadHolder currentLH = (LoadHolder) groupServers.get(currentServer);
+  private LoadHolder isCurrentServerMostLoaded(ServerLocation currentServer,
+      Map<ServerLocation, LoadHolder> groupServers) {
+    final LoadHolder currentLH = groupServers.get(currentServer);
-    for (Iterator itr = groupServers.entrySet().iterator(); itr.hasNext();) {
-      Map.Entry next = (Entry) itr.next();
-      ServerLocation location = (ServerLocation) next.getKey();
+    for (Map.Entry<ServerLocation, LoadHolder> loadEntry : groupServers.entrySet()) {
+      ServerLocation location = loadEntry.getKey();
-      LoadHolder nextLoadReference = (LoadHolder) next.getValue();
+      LoadHolder nextLoadReference = loadEntry.getValue();

INS23 INS23 INS23 INS23 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS83 INS83 INS83 INS39 INS59 INS29 INS83 INS39 INS59 INS29 INS83 INS39 INS59 INS83 INS83 INS39 INS42 INS44 INS8 INS44 INS29 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS8 INS83 INS39 INS42 INS8 INS74 INS29 INS42 INS42 INS45 INS42 INS34 INS65 INS42 INS65 INS42 INS60 INS25 INS74 INS42 INS41 INS74 INS39 INS42 INS70 INS60 INS25 INS65 INS39 INS42 INS39 INS42 INS39 INS42 INS39 INS42 INS25 INS25 INS41 INS41 MOV43 INS43 INS43 INS65 INS65 INS65 INS65 INS74 INS60 INS70 INS74 INS70 INS66 INS66 INS66 INS66 INS66 INS43 INS59 INS27 INS8 INS8 MOV43 INS43 MOV43 INS32 MOV43 INS43 INS43 INS44 MOV32 MOV8 INS39 INS59 INS42 INS8 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS8 INS38 INS8 INS42 INS42 INS74 MOV42 INS42 INS42 INS42 INS66 INS42 INS66 INS42 INS66 INS66 MOV43 MOV43 MOV43 INS39 INS59 INS44 MOV32 MOV8 INS43 INS43 MOV43 MOV43 INS44 MOV32 MOV8 INS42 INS42 INS32 INS42 INS33 INS21 INS21 INS42 INS42 INS42 INS9 INS42 INS42 INS42 INS74 INS42 INS42 MOV27 INS21 INS25 INS41 INS42 INS60 INS25 MOV43 INS43 INS43 INS9 MOV42 INS42 INS36 INS74 INS42 UPD42 MOV42 INS60 MOV42 INS42 MOV32 INS74 INS42 INS42 INS42 INS42 INS7 INS7 MOV43 INS43 INS43 MOV43 INS7 INS42 INS8 INS42 INS39 INS59 INS27 INS8 INS8 INS42 INS42 INS27 MOV43 MOV43 MOV43 MOV43 MOV59 MOV43 MOV27 MOV43 INS43 INS43 INS42 INS32 INS42 INS42 INS42 UPD42 MOV42 INS32 INS42 INS32 INS21 INS42 INS27 INS42 INS36 INS21 INS21 INS42 INS34 INS32 INS32 INS36 INS42 INS36 UPD42 MOV42 INS42 INS32 INS32 INS42 INS42 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS7 INS42 INS42 INS27 INS7 INS7 UPD42 MOV42 MOV42 UPD42 MOV42 MOV42 MOV27 MOV27 UPD42 MOV42 MOV42 UPD42 MOV42 MOV42 INS42 INS9 INS42 INS42 INS42 INS9 INS42 INS9 INS38 INS36 INS42 MOV27 DEL40 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL32 DEL11 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL32 DEL24 DEL32 DEL11 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL60 DEL32 DEL11 DEL34 DEL38 DEL27 DEL27 DEL42 DEL34 DEL38 DEL27 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL32 DEL24 DEL11 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL32 DEL11 DEL32 DEL11 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  protected static final byte REPLY_REFUSED = (byte)60;
+  protected static final byte REPLY_REFUSED = (byte) 60;
-  protected static final byte REPLY_INVALID = (byte)61;
+  protected static final byte REPLY_INVALID = (byte) 61;
-    }
-    catch (IOException e) {
-      //Only log an exception if the server is still running.
-      if(connection.getAcceptor().isRunning()) {
-      // Server logging
+    } catch (IOException e) {
+      // Only log an exception if the server is still running.
+      if (connection.getAcceptor().isRunning()) {
+        // Server logging
-    }
-    catch (UnsupportedVersionException uve) {
+    } catch (UnsupportedVersionException uve) {
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-      connection
-          .refuseHandshake(
-              LocalizedStrings.ServerHandShakeProcessor_0_SERVERS_CURRENT_VERSION_IS_1
-                  .toLocalizedString(new Object[] { e.getMessage(),
-                      Acceptor.VERSION.toString() }), REPLY_REFUSED);
+      connection.refuseHandshake(
+          LocalizedStrings.ServerHandShakeProcessor_0_SERVERS_CURRENT_VERSION_IS_1
+              .toLocalizedString(new Object[] {e.getMessage(), Acceptor.VERSION.toString()}),
+          REPLY_REFUSED);
-    
+
-  
+
-  
+
-          validHandShake = readGFEHandshake(connection, clientVersion);
+        validHandShake = readGFEHandshake(connection, clientVersion);
-          connection.refuseHandshake("Unsupported version "
-              + clientVersion + "Server's current version "
-              + Acceptor.VERSION, REPLY_REFUSED);
+        connection.refuseHandshake(
+            "Unsupported version " + clientVersion + "Server's current version " + Acceptor.VERSION,
+            REPLY_REFUSED);
-    
+
-   * @param out
-   *                the Stream to the waiting greeter.
-   * @param message
-   *                providing details about the refusal reception, mainly for
-   *                client logging.
+   * @param out the Stream to the waiting greeter.
+   * @param message providing details about the refusal reception, mainly for client logging.
-  public static void refuse(OutputStream out, String message) throws IOException
-  {
-    refuse(out,message,REPLY_REFUSED);
+  public static void refuse(OutputStream out, String message) throws IOException {
+    refuse(out, message, REPLY_REFUSED);
-  
+
-   * @param out
-   *                the Stream to the waiting greeter.
-   * @param message
-   *                providing details about the refusal reception, mainly for
-   *                client logging.
-   * @param exception
-   *                providing details about exception occurred.
+   * @param out the Stream to the waiting greeter.
+   * @param message providing details about the refusal reception, mainly for client logging.
+   * @param exception providing details about exception occurred.
-  public static void refuse(OutputStream out, String message, byte exception)
-      throws IOException {
+  public static void refuse(OutputStream out, String message, byte exception) throws IOException {
-    DistributedMember member = InternalDistributedSystem.getAnyInstance()
-        .getDistributedMember();
+    DistributedMember member = InternalDistributedSystem.getAnyInstance().getDistributedMember();
+
-  protected static void writeServerMember(DistributedMember member,
-      DataOutputStream dos) throws IOException {
+  protected static void writeServerMember(DistributedMember member, DataOutputStream dos)
+      throws IOException {
-  
-  private static boolean readGFEHandshake(ServerConnection connection,
-      Version clientVersion) {
+
+  private static boolean readGFEHandshake(ServerConnection connection, Version clientVersion) {
-      //hitesh:it will set credentials and principals
-      HandShake handshake = new HandShake(socket, handShakeTimeout, system,
-          clientVersion, connection.getCommunicationMode());
+      // hitesh:it will set credentials and principals
+      HandShake handshake = new HandShake(socket, handShakeTimeout, system, clientVersion,
+          connection.getCommunicationMode());
-      //hitesh: it gets principals
-      //Hitesh:for older version we should set this
+      // hitesh: it gets principals
+      // Hitesh:for older version we should set this
-         long uniqueId = setAuthAttributes(connection);
-         connection.setUserAuthId(uniqueId);//for older clients < 6.5
+        long uniqueId = setAuthAttributes(connection);
+        connection.setUserAuthId(uniqueId);// for older clients < 6.5
-    }
-    catch (SocketTimeoutException timeout) {
+    } catch (SocketTimeoutException timeout) {
-        LocalizedStrings.ServerHandShakeProcessor_0_HANDSHAKE_REPLY_CODE_TIMEOUT_NOT_RECEIVED_WITH_IN_1_MS,
-        new Object[] {connection.getName(), Integer.valueOf(handShakeTimeout)}));
+          LocalizedStrings.ServerHandShakeProcessor_0_HANDSHAKE_REPLY_CODE_TIMEOUT_NOT_RECEIVED_WITH_IN_1_MS,
+          new Object[] {connection.getName(), Integer.valueOf(handShakeTimeout)}));
-    }
-    catch (EOFException e) {
+    } catch (EOFException e) {
-    }
-    catch (SocketException e) { // no need to warn client just gave up on this
+    } catch (SocketException e) { // no need to warn client just gave up on this
-    }
-    catch (IOException e) {
+    } catch (IOException e) {
-    }
-    catch (AuthenticationRequiredException noauth) {
+    } catch (AuthenticationRequiredException noauth) {
-        securityLogWriter.warning(
-            LocalizedStrings.ONE_ARG, 
+        securityLogWriter.warning(LocalizedStrings.ONE_ARG,
-    }
-    catch (AuthenticationFailedException failed) {
+    } catch (AuthenticationFailedException failed) {
-        securityLogWriter.warning(
-          LocalizedStrings.ONE_ARG,
-          connection.getName() + ": Security exception: " + exStr);
+        securityLogWriter.warning(LocalizedStrings.ONE_ARG,
+            connection.getName() + ": Security exception: " + exStr);
-    }
-    catch (Exception ex) {
+    } catch (Exception ex) {
-  
-  public static long setAuthAttributes(ServerConnection connection)
-    throws Exception{
+
+  public static long setAuthAttributes(ServerConnection connection) throws Exception {
-      Object principal = ((HandShake)connection.getHandshake()).verifyCredentials();
+      Object principal = ((HandShake) connection.getHandshake()).verifyCredentials();
-      if(principal instanceof Subject){
-        uniqueId = connection.getClientUserAuths(connection.getProxyID()).putSubject((Subject)principal);
-      }
-      else {
-        //this sets principal in map as well....
-        uniqueId = getUniqueId(connection, (Principal)principal);
-        connection.setPrincipal((Principal)principal);//TODO:hitesh is this require now ???
+      if (principal instanceof Subject) {
+        uniqueId =
+            connection.getClientUserAuths(connection.getProxyID()).putSubject((Subject) principal);
+      } else {
+        // this sets principal in map as well....
+        uniqueId = getUniqueId(connection, (Principal) principal);
+        connection.setPrincipal((Principal) principal);// TODO:hitesh is this require now ???
-    }catch(Exception ex) {
+    } catch (Exception ex) {
-  
-  public static long getUniqueId(ServerConnection connection, Principal principal ) 
-  throws Exception{
+
+  public static long getUniqueId(ServerConnection connection, Principal principal)
+      throws Exception {
-      //hitesh:auth callbacks
-      String authzFactoryName = systemProperties
-          .getProperty(SECURITY_CLIENT_ACCESSOR);
-      String postAuthzFactoryName = systemProperties
-          .getProperty(SECURITY_CLIENT_ACCESSOR_PP);
+      // hitesh:auth callbacks
+      String authzFactoryName = systemProperties.getProperty(SECURITY_CLIENT_ACCESSOR);
+      String postAuthzFactoryName = systemProperties.getProperty(SECURITY_CLIENT_ACCESSOR_PP);
-      
+
-              + ": Setting pre-process authorization callback to: "
-              + authzFactoryName);
+              + ": Setting pre-process authorization callback to: " + authzFactoryName);
-                new Object[] {connection.getName(), SECURITY_CLIENT_AUTHENTICATOR, connection.getProxyID()});
+                new Object[] {connection.getName(), SECURITY_CLIENT_AUTHENTICATOR,
+                    connection.getProxyID()});
-        authzRequest = new AuthorizeRequest(authzFactoryName,
-            connection.getProxyID(), principal, connection.getCache());
-       // connection.setAuthorizeRequest(authzRequest);
+        authzRequest = new AuthorizeRequest(authzFactoryName, connection.getProxyID(), principal,
+            connection.getCache());
+        // connection.setAuthorizeRequest(authzRequest);
-              + ": Setting post-process authorization callback to: "
-              + postAuthzFactoryName);
+              + ": Setting post-process authorization callback to: " + postAuthzFactoryName);
-              LocalizedStrings.ServerHandShakeProcessor_0_POSTPROCESS_AUTHORIZATION_ENABLED_BUT_NO_AUTHENTICATION_CALLBACK_2_IS_CONFIGURED,
-              new Object[] {connection.getName(), SECURITY_CLIENT_AUTHENTICATOR});
-          }      
+                LocalizedStrings.ServerHandShakeProcessor_0_POSTPROCESS_AUTHORIZATION_ENABLED_BUT_NO_AUTHENTICATION_CALLBACK_2_IS_CONFIGURED,
+                new Object[] {connection.getName(), SECURITY_CLIENT_AUTHENTICATOR});
+          }
-        postAuthzRequest = new AuthorizeRequestPP(
-            postAuthzFactoryName, connection.getProxyID(), principal, connection.getCache());
-       // connection.setPostAuthorizeRequest(postAuthzRequest);
+        postAuthzRequest = new AuthorizeRequestPP(postAuthzFactoryName, connection.getProxyID(),
+            principal, connection.getCache());
+        // connection.setPostAuthorizeRequest(postAuthzRequest);
-      }catch(Exception ex) {
-        throw ex;
-      }
+    } catch (Exception ex) {
+      throw ex;
+    }
-  
+
-    
+
-          LocalizedStrings.ServerHandShakeProcessor_HANDSHAKEREADER_EOF_REACHED_BEFORE_CLIENT_VERSION_COULD_BE_READ.toLocalizedString()); 
+            LocalizedStrings.ServerHandShakeProcessor_HANDSHAKEREADER_EOF_REACHED_BEFORE_CLIENT_VERSION_COULD_BE_READ
+                .toLocalizedString());
-      Version clientVersion = null;      
-      try{
+      Version clientVersion = null;
+      try {
-      }
-      catch (UnsupportedVersionException uve) {
+      } catch (UnsupportedVersionException uve) {
-        if(connection.getCommunicationMode() == Acceptor.GATEWAY_TO_GATEWAY 
-            && ! (clientVersionOrdinal == Version.NOT_SUPPORTED_ORDINAL)) {
+        if (connection.getCommunicationMode() == Acceptor.GATEWAY_TO_GATEWAY
+            && !(clientVersionOrdinal == Version.NOT_SUPPORTED_ORDINAL)) {
-    
+
-        throw new IncompatibleVersionException(clientVersion, Acceptor.VERSION);//we can throw this to restrict
-      }                                                 // Backward Compatibilty Support to limited no of versions          
-      return clientVersion;                             
+        throw new IncompatibleVersionException(clientVersion, Acceptor.VERSION);// we can throw this
+                                                                                // to restrict
+      } // Backward Compatibilty Support to limited no of versions
+      return clientVersion;
-        try {        
+        try {
-        }
-        catch (IOException ignore) {
+        } catch (IOException ignore) {

UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public final class RemoveAllPRMessage extends PartitionMessageWithDirectReply
-{
+public final class RemoveAllPRMessage extends PartitionMessageWithDirectReply {
-  
+
-  /** An additional object providing context for the operation, e.g., for BridgeServer notification */
+  /**
+   * An additional object providing context for the operation, e.g., for BridgeServer notification
+   */
-   * state from operateOnRegion that must be preserved for transmission
-   * from the waiting pool
+   * state from operateOnRegion that must be preserved for transmission from the waiting pool
-  
+
-  public RemoveAllPRMessage() {
-  }
+  public RemoveAllPRMessage() {}
-  public RemoveAllPRMessage(int bucketId, int size, boolean notificationOnly,
-      boolean posDup, boolean skipCallbacks, Object callbackArg) {
+  public RemoveAllPRMessage(int bucketId, int size, boolean notificationOnly, boolean posDup,
+      boolean skipCallbacks, Object callbackArg) {
-  public void initMessage(PartitionedRegion r, Set recipients, boolean notifyOnly, DirectReplyProcessor p) {
+  public void initMessage(PartitionedRegion r, Set recipients, boolean notifyOnly,
+      DirectReplyProcessor p) {
-    this.processorId = p==null? 0 : p.getProcessorId();
+    this.processorId = p == null ? 0 : p.getProcessorId();
-  
+
-    for (int i=0; i<removeAllPRData.length; i++) {
+    for (int i = 0; i < removeAllPRData.length; i++) {
+   * 
-   * @param r  the PartitionedRegion for which the op was performed
-   * @return the processor used to await acknowledgement that the op was
-   *         sent, or null to indicate that no acknowledgement will be sent
+   * @param r the PartitionedRegion for which the op was performed
+   * @return the processor used to await acknowledgement that the op was sent, or null to indicate
+   *         that no acknowledgement will be sent
-      throws ForceReattemptException
-  {
-    //Assert.assertTrue(recipient != null, "RemoveAllPRMessage NULL recipient");  recipient can be null for event notifications
+      throws ForceReattemptException {
+    // Assert.assertTrue(recipient != null, "RemoveAllPRMessage NULL recipient"); recipient can be
+    // null for event notifications
-    Set failures =r.getDistributionManager().putOutgoing(this);
+    Set failures = r.getDistributionManager().putOutgoing(this);
-  
+
-    this.bucketId = Integer.valueOf((int)InternalDataSerializer
-        .readSignedVL(in));
+    this.bucketId = Integer.valueOf((int) InternalDataSerializer.readSignedVL(in));
-    this.removeAllPRDataSize = (int)InternalDataSerializer.readUnsignedVL(in);
+    this.removeAllPRDataSize = (int) InternalDataSerializer.readUnsignedVL(in);
-      final Version version = InternalDataSerializer
-          .getVersionForDataStreamOrNull(in);
+      final Version version = InternalDataSerializer.getVersionForDataStreamOrNull(in);
-        this.removeAllPRData[i] = new RemoveAllEntryData(in, null, i, version,
-            bytesIn);
+        this.removeAllPRData[i] = new RemoveAllEntryData(in, null, i, version, bytesIn);
-    if (this.bridgeContext != null) s |= HAS_BRIDGE_CONTEXT;
-    if (this.skipCallbacks) s |= SKIP_CALLBACKS;
+    if (this.bridgeContext != null)
+      s |= HAS_BRIDGE_CONTEXT;
+    if (this.skipCallbacks)
+      s |= SKIP_CALLBACKS;
-  protected void setBooleans(short s, DataInput in) throws IOException,
-      ClassNotFoundException {
+  protected void setBooleans(short s, DataInput in) throws IOException, ClassNotFoundException {
-   * This method is called upon receipt and make the desired changes to the
-   * PartitionedRegion Note: It is very important that this message does NOT
-   * cause any deadlocks as the sender will wait indefinitely for the
-   * acknowledgement
+   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:
+   * It is very important that this message does NOT cause any deadlocks as the sender will wait
+   * indefinitely for the acknowledgement
-  protected final boolean operateOnPartitionedRegion(DistributionManager dm,
-      PartitionedRegion r, long startTime)  throws EntryExistsException,
-      ForceReattemptException, DataLocationException
-  {
+  protected final boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion r,
+      long startTime) throws EntryExistsException, ForceReattemptException, DataLocationException {
-    }
-    catch (ForceReattemptException fre) {
-      sendReply(getSender(), getProcessorId(), dm, 
-          new ReplyException(fre), r, startTime);
+    } catch (ForceReattemptException fre) {
+      sendReply(getSender(), getProcessorId(), dm, new ReplyException(fre), r, startTime);
-    
-    @Retained EntryEventImpl ev = EntryEventImpl.create(r, 
-        removeAllPRData[0].getOp(),
-        removeAllPRData[0].getKey(), 
-        null /*value*/, 
-        this.callbackArg,
-        false /* originRemote */,
-        getSender(),
-        true/* generate Callbacks */,
-        removeAllPRData[0].getEventID());
+
+    @Retained
+    EntryEventImpl ev = EntryEventImpl.create(r, removeAllPRData[0].getOp(),
+        removeAllPRData[0].getKey(), null /* value */, this.callbackArg, false /* originRemote */,
+        getSender(), true/* generate Callbacks */, removeAllPRData[0].getEventID());
-  
+
-   * This method is called by both operateOnPartitionedRegion() when processing a remote msg
-   * or by sendMsgByBucket() when processing a msg targeted to local Jvm. 
-   * PartitionedRegion Note: It is very important that this message does NOT
-   * cause any deadlocks as the sender will wait indefinitely for the
-   * acknowledgment
+   * This method is called by both operateOnPartitionedRegion() when processing a remote msg or by
+   * sendMsgByBucket() when processing a msg targeted to local Jvm. PartitionedRegion Note: It is
+   * very important that this message does NOT cause any deadlocks as the sender will wait
+   * indefinitely for the acknowledgment
+   * 
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="IMSE_DONT_CATCH_IMSE")
-  public final boolean doLocalRemoveAll(PartitionedRegion r, InternalDistributedMember eventSender, boolean cacheWrite)
-  throws EntryExistsException,
-  ForceReattemptException,DataLocationException
-  {
-    boolean didRemove=false;
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "IMSE_DONT_CATCH_IMSE")
+  public final boolean doLocalRemoveAll(PartitionedRegion r, InternalDistributedMember eventSender,
+      boolean cacheWrite)
+      throws EntryExistsException, ForceReattemptException, DataLocationException {
+    boolean didRemove = false;
-        logger.debug("RemoveAllPRMessage: doLocalRemoveAll: clientReadTimeOut is {}", clientReadTimeOut);
+        logger.debug("RemoveAllPRMessage: doLocalRemoveAll: clientReadTimeOut is {}",
+            clientReadTimeOut);
-    
+
-    @Released EntryEventImpl baseEvent = null;
+    @Released
+    EntryEventImpl baseEvent = null;
-    
-    if (!notificationOnly) {
-      // bucketRegion is not null only when !notificationOnly
-      bucketRegion = ds.getInitializedBucketForId(null, bucketId);
-      
-      this.versions = new VersionedObjectList(this.removeAllPRDataSize, true, bucketRegion.getAttributes().getConcurrencyChecksEnabled());
-      // create a base event and a DPAO for RemoveAllMessage distributed btw redundant buckets
-      baseEvent = EntryEventImpl.create(
-          bucketRegion, Operation.REMOVEALL_DESTROY,
-          null, null, this.callbackArg, true, eventSender, !skipCallbacks, true);
-      // set baseEventId to the first entry's event id. We need the thread id for DACE
-      baseEvent.setEventId(removeAllPRData[0].getEventID());
-      if (this.bridgeContext != null) {
-        baseEvent.setContext(this.bridgeContext);
-      }
-      baseEvent.setPossibleDuplicate(this.posDup);
-      if (logger.isDebugEnabled()) {
-        logger.debug("RemoveAllPRMessage.doLocalRemoveAll: eventSender is {}, baseEvent is {}, msg is {}",
-            eventSender, baseEvent, this);
-      }
-      op = new DistributedRemoveAllOperation(baseEvent, removeAllPRDataSize, false);
-    }
+      if (!notificationOnly) {
+        // bucketRegion is not null only when !notificationOnly
+        bucketRegion = ds.getInitializedBucketForId(null, bucketId);
-    // Fix the updateMsg misorder issue
-    // Lock the keys when doing postRemoveAll
-    Object keys[] = new Object[removeAllPRDataSize];
-    for (int i = 0; i < removeAllPRDataSize; ++i) {
-      keys[i] = removeAllPRData[i].getKey();
-    }
+        this.versions = new VersionedObjectList(this.removeAllPRDataSize, true,
+            bucketRegion.getAttributes().getConcurrencyChecksEnabled());
-    if (!notificationOnly) {
-      try {
-        if(removeAllPRData.length > 0) {
-          if (this.posDup && bucketRegion.getConcurrencyChecksEnabled()) {
-            if (logger.isDebugEnabled()) {
-              logger.debug("attempting to locate version tags for retried event");
-            }
-            // bug #48205 - versions may have already been generated for a posdup event
-            // so try to recover them before wiping out the eventTracker's record
-            // of the previous attempt
-            for (int i=0; i<removeAllPRDataSize; i++) {
-              if (removeAllPRData[i].versionTag == null) {
-                removeAllPRData[i].versionTag = bucketRegion.findVersionTagForClientBulkOp(removeAllPRData[i].getEventID());
-                if (removeAllPRData[i].versionTag != null) {
-                  removeAllPRData[i].versionTag.replaceNullIDs(bucketRegion.getVersionMember());
-                }
-              }
-            }
-          }
-          EventID eventID = removeAllPRData[0].getEventID();
-          ThreadIdentifier membershipID = new ThreadIdentifier(
-              eventID.getMembershipID(), eventID.getThreadID());
-          bucketRegion.recordBulkOpStart(membershipID);
+        // create a base event and a DPAO for RemoveAllMessage distributed btw redundant buckets
+        baseEvent = EntryEventImpl.create(bucketRegion, Operation.REMOVEALL_DESTROY, null, null,
+            this.callbackArg, true, eventSender, !skipCallbacks, true);
+        // set baseEventId to the first entry's event id. We need the thread id for DACE
+        baseEvent.setEventId(removeAllPRData[0].getEventID());
+        if (this.bridgeContext != null) {
+          baseEvent.setContext(this.bridgeContext);
-        bucketRegion.waitUntilLocked(keys);
-        boolean lockedForPrimary = false;
-        final ArrayList<Object> succeeded = new ArrayList<Object>();
-        PutAllPartialResult partialKeys = new PutAllPartialResult(removeAllPRDataSize);
-        Object key = keys[0];
+        baseEvent.setPossibleDuplicate(this.posDup);
+        if (logger.isDebugEnabled()) {
+          logger.debug(
+              "RemoveAllPRMessage.doLocalRemoveAll: eventSender is {}, baseEvent is {}, msg is {}",
+              eventSender, baseEvent, this);
+        }
+        op = new DistributedRemoveAllOperation(baseEvent, removeAllPRDataSize, false);
+      }
+
+      // Fix the updateMsg misorder issue
+      // Lock the keys when doing postRemoveAll
+      Object keys[] = new Object[removeAllPRDataSize];
+      for (int i = 0; i < removeAllPRDataSize; ++i) {
+        keys[i] = removeAllPRData[i].getKey();
+      }
+
+      if (!notificationOnly) {
-          bucketRegion.doLockForPrimary(false);
-          lockedForPrimary = true;
-      
-          /* The real work to be synchronized, it will take long time. We don't 
-           * worry about another thread to send any msg which has the same key
-           * in this request, because these request will be blocked by foundKey
-           */
-          for (int i=0; i<removeAllPRDataSize; i++) {
-            @Released EntryEventImpl ev = getEventFromEntry(r, myId, eventSender, i,removeAllPRData,notificationOnly,bridgeContext,posDup,skipCallbacks);
-            try {
-            key = ev.getKey();
-
-            ev.setRemoveAllOperation(op);
-
-            // ev will be added into the op in removeLocally()
-            // real operation will be modified into ev in removeLocally()
-            // then in basicPutPart3(), the ev is added into op
-            try {
-              r.getDataView().destroyOnRemote(ev, cacheWrite, null);
-              didRemove = true;
+          if (removeAllPRData.length > 0) {
+            if (this.posDup && bucketRegion.getConcurrencyChecksEnabled()) {
-                logger.debug("RemoveAllPRMessage.doLocalRemoveAll:removeLocally success for "+ev);
+                logger.debug("attempting to locate version tags for retried event");
-            } catch (EntryNotFoundException ignore) {
-              didRemove = true;
-              if (ev.getVersionTag() == null) {
-                if (logger.isDebugEnabled()) {
-                  logger.debug("doLocalRemoveAll:RemoveAll encoutered EntryNotFoundException: event={}", ev);
+              // bug #48205 - versions may have already been generated for a posdup event
+              // so try to recover them before wiping out the eventTracker's record
+              // of the previous attempt
+              for (int i = 0; i < removeAllPRDataSize; i++) {
+                if (removeAllPRData[i].versionTag == null) {
+                  removeAllPRData[i].versionTag =
+                      bucketRegion.findVersionTagForClientBulkOp(removeAllPRData[i].getEventID());
+                  if (removeAllPRData[i].versionTag != null) {
+                    removeAllPRData[i].versionTag.replaceNullIDs(bucketRegion.getVersionMember());
+                  }
-            } catch (ConcurrentCacheModificationException e) {
-              didRemove = true;
-              if (logger.isDebugEnabled()) {
-                logger.debug("RemoveAllPRMessage.doLocalRemoveAll:removeLocally encountered concurrent cache modification for "+ev);
-              }
-            removeAllPRData[i].setTailKey(ev.getTailKey());
-            if (!didRemove) { // make sure the region hasn't gone away
-              r.checkReadiness();
-              ForceReattemptException fre = new ForceReattemptException(
-              "unable to perform remove in RemoveAllPR, but operation should not fail");
-              fre.setHash(ev.getKey().hashCode());
-              throw fre;
-            } else {
-              succeeded.add(removeAllPRData[i].getKey());
-              this.versions.addKeyAndVersion(removeAllPRData[i].getKey(), ev.getVersionTag());
-            }
-            } finally {
-              ev.release();
-            }
-          } // for
-
-        } catch (IllegalMonitorStateException ex) {
-          ForceReattemptException fre = new ForceReattemptException(
-          "unable to get lock for primary, retrying... ");
-          throw fre;
-        } catch (CacheWriterException cwe) {
-          // encounter cacheWriter exception
-          partialKeys.saveFailedKey(key, cwe);
-        } finally {
+            EventID eventID = removeAllPRData[0].getEventID();
+            ThreadIdentifier membershipID =
+                new ThreadIdentifier(eventID.getMembershipID(), eventID.getThreadID());
+            bucketRegion.recordBulkOpStart(membershipID);
+          }
+          bucketRegion.waitUntilLocked(keys);
+          boolean lockedForPrimary = false;
+          final ArrayList<Object> succeeded = new ArrayList<Object>();
+          PutAllPartialResult partialKeys = new PutAllPartialResult(removeAllPRDataSize);
+          Object key = keys[0];
-            // Only RemoveAllPRMessage knows if the thread id is fake. Event has no idea.
-            // So we have to manually set useFakeEventId for this op
-            op.setUseFakeEventId(true);
-            r.checkReadiness();
-            bucketRegion.getDataView().postRemoveAll(op, this.versions, bucketRegion);
+            bucketRegion.doLockForPrimary(false);
+            lockedForPrimary = true;
+
+            /*
+             * The real work to be synchronized, it will take long time. We don't worry about
+             * another thread to send any msg which has the same key in this request, because these
+             * request will be blocked by foundKey
+             */
+            for (int i = 0; i < removeAllPRDataSize; i++) {
+              @Released
+              EntryEventImpl ev = getEventFromEntry(r, myId, eventSender, i, removeAllPRData,
+                  notificationOnly, bridgeContext, posDup, skipCallbacks);
+              try {
+                key = ev.getKey();
+
+                ev.setRemoveAllOperation(op);
+
+                // ev will be added into the op in removeLocally()
+                // real operation will be modified into ev in removeLocally()
+                // then in basicPutPart3(), the ev is added into op
+                try {
+                  r.getDataView().destroyOnRemote(ev, cacheWrite, null);
+                  didRemove = true;
+                  if (logger.isDebugEnabled()) {
+                    logger.debug(
+                        "RemoveAllPRMessage.doLocalRemoveAll:removeLocally success for " + ev);
+                  }
+                } catch (EntryNotFoundException ignore) {
+                  didRemove = true;
+                  if (ev.getVersionTag() == null) {
+                    if (logger.isDebugEnabled()) {
+                      logger.debug(
+                          "doLocalRemoveAll:RemoveAll encoutered EntryNotFoundException: event={}",
+                          ev);
+                    }
+                  }
+                } catch (ConcurrentCacheModificationException e) {
+                  didRemove = true;
+                  if (logger.isDebugEnabled()) {
+                    logger.debug(
+                        "RemoveAllPRMessage.doLocalRemoveAll:removeLocally encountered concurrent cache modification for "
+                            + ev);
+                  }
+                }
+                removeAllPRData[i].setTailKey(ev.getTailKey());
+                if (!didRemove) { // make sure the region hasn't gone away
+                  r.checkReadiness();
+                  ForceReattemptException fre = new ForceReattemptException(
+                      "unable to perform remove in RemoveAllPR, but operation should not fail");
+                  fre.setHash(ev.getKey().hashCode());
+                  throw fre;
+                } else {
+                  succeeded.add(removeAllPRData[i].getKey());
+                  this.versions.addKeyAndVersion(removeAllPRData[i].getKey(), ev.getVersionTag());
+                }
+              } finally {
+                ev.release();
+              }
+            } // for
+
+          } catch (IllegalMonitorStateException ex) {
+            ForceReattemptException fre =
+                new ForceReattemptException("unable to get lock for primary, retrying... ");
+            throw fre;
+          } catch (CacheWriterException cwe) {
+            // encounter cacheWriter exception
+            partialKeys.saveFailedKey(key, cwe);
-            if (lockedForPrimary) {
-              bucketRegion.doUnlockForPrimary();
+            try {
+              // Only RemoveAllPRMessage knows if the thread id is fake. Event has no idea.
+              // So we have to manually set useFakeEventId for this op
+              op.setUseFakeEventId(true);
+              r.checkReadiness();
+              bucketRegion.getDataView().postRemoveAll(op, this.versions, bucketRegion);
+            } finally {
+              if (lockedForPrimary) {
+                bucketRegion.doUnlockForPrimary();
+              }
-        }
-        if (partialKeys.hasFailure()) {
-          partialKeys.addKeysAndVersions(this.versions);
-          if (logger.isDebugEnabled()) {
-            logger.debug("RemoveAllPRMessage: partial keys applied, map to bucket {}'s keys:{}. Applied {}",
-                bucketId, Arrays.toString(keys), succeeded);
+          if (partialKeys.hasFailure()) {
+            partialKeys.addKeysAndVersions(this.versions);
+            if (logger.isDebugEnabled()) {
+              logger.debug(
+                  "RemoveAllPRMessage: partial keys applied, map to bucket {}'s keys:{}. Applied {}",
+                  bucketId, Arrays.toString(keys), succeeded);
+            }
+            throw new PutAllPartialResultException(partialKeys);
-          throw new PutAllPartialResultException(partialKeys);
-        }
-      } catch(RegionDestroyedException e) {
-          ds.checkRegionDestroyedOnBucket(bucketRegion ,true, e);
-      } finally {
-        bucketRegion.removeAndNotifyKeys(keys);
-      }
-    } else {
-      for (int i=0; i<removeAllPRDataSize; i++) {
-        EntryEventImpl ev = getEventFromEntry(r, myId, eventSender, i,removeAllPRData,notificationOnly,bridgeContext,posDup,skipCallbacks);
-        try {
-        ev.setOriginRemote(true);
-        if (this.callbackArg != null) {
-          ev.setCallbackArgument(this.callbackArg);
-        }
-        r.invokeDestroyCallbacks(EnumListenerEvent.AFTER_DESTROY, ev, r.isInitialized(), true);
+        } catch (RegionDestroyedException e) {
+          ds.checkRegionDestroyedOnBucket(bucketRegion, true, e);
-          ev.release();
+          bucketRegion.removeAndNotifyKeys(keys);
+        }
+      } else {
+        for (int i = 0; i < removeAllPRDataSize; i++) {
+          EntryEventImpl ev = getEventFromEntry(r, myId, eventSender, i, removeAllPRData,
+              notificationOnly, bridgeContext, posDup, skipCallbacks);
+          try {
+            ev.setOriginRemote(true);
+            if (this.callbackArg != null) {
+              ev.setCallbackArgument(this.callbackArg);
+            }
+            r.invokeDestroyCallbacks(EnumListenerEvent.AFTER_DESTROY, ev, r.isInitialized(), true);
+          } finally {
+            ev.release();
+          }
+    } finally {
+      if (baseEvent != null)
+        baseEvent.release();
+      if (op != null)
+        op.freeOffHeapResources();
-  } finally {
-    if (baseEvent != null) baseEvent.release();
-    if (op != null) op.freeOffHeapResources();
-  }
-  
+
-  
+
-        return true;
+    return true;
+
-  public static EntryEventImpl getEventFromEntry(LocalRegion r,
-      InternalDistributedMember myId, InternalDistributedMember eventSender,
-      int idx, DistributedRemoveAllOperation.RemoveAllEntryData[] data,
-      boolean notificationOnly, ClientProxyMembershipID bridgeContext,
-      boolean posDup, boolean skipCallbacks) {
+  public static EntryEventImpl getEventFromEntry(LocalRegion r, InternalDistributedMember myId,
+      InternalDistributedMember eventSender, int idx,
+      DistributedRemoveAllOperation.RemoveAllEntryData[] data, boolean notificationOnly,
+      ClientProxyMembershipID bridgeContext, boolean posDup, boolean skipCallbacks) {
-    @Retained EntryEventImpl ev = EntryEventImpl.create(r, dataItem.getOp(), dataItem.getKey(), null, null, false, eventSender, !skipCallbacks, dataItem.getEventID());
+    @Retained
+    EntryEventImpl ev = EntryEventImpl.create(r, dataItem.getOp(), dataItem.getKey(), null, null,
+        false, eventSender, !skipCallbacks, dataItem.getEventID());
-    ev.setOldValue(dataItem.getOldValue());
-    if (bridgeContext != null) {
-      ev.setContext(bridgeContext);
-    }
-    ev.setInvokePRCallbacks(!notificationOnly);
-    ev.setPossibleDuplicate(posDup);
-    if (dataItem.filterRouting != null) {
-      ev.setLocalFilterInfo(dataItem.filterRouting.getFilterInfo(myId));
-    }
-    if (dataItem.versionTag != null) {
-      dataItem.versionTag.replaceNullIDs(eventSender);
-      ev.setVersionTag(dataItem.versionTag);
-    }
-    if(notificationOnly){
-      ev.setTailKey(-1L);
-    } else {
-      ev.setTailKey(dataItem.getTailKey());
-    }
-    evReturned = true;
-    return ev;
+      ev.setOldValue(dataItem.getOldValue());
+      if (bridgeContext != null) {
+        ev.setContext(bridgeContext);
+      }
+      ev.setInvokePRCallbacks(!notificationOnly);
+      ev.setPossibleDuplicate(posDup);
+      if (dataItem.filterRouting != null) {
+        ev.setLocalFilterInfo(dataItem.filterRouting.getFilterInfo(myId));
+      }
+      if (dataItem.versionTag != null) {
+        dataItem.versionTag.replaceNullIDs(eventSender);
+        ev.setVersionTag(dataItem.versionTag);
+      }
+      if (notificationOnly) {
+        ev.setTailKey(-1L);
+      } else {
+        ev.setTailKey(dataItem.getTailKey());
+      }
+      evReturned = true;
+      return ev;
-  
+
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex, PartitionedRegion pr, long startTime) {
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+      PartitionedRegion pr, long startTime) {
-  protected final void appendFields(StringBuffer buff)
-  {
+  protected final void appendFields(StringBuffer buff) {
-    buff.append("; removeAllPRDataSize=").append(removeAllPRDataSize)
-        .append("; bucketId=").append(bucketId);
+    buff.append("; removeAllPRDataSize=").append(removeAllPRDataSize).append("; bucketId=")
+        .append(bucketId);
-    buff.append("; directAck=")
-        .append(this.directAck);
-    
-    for (int i=0; i<removeAllPRDataSize; i++) {
-      buff.append("; entry"+i+":").append(removeAllPRData[i].getKey())
-        .append(",").append(removeAllPRData[i].versionTag);
+    buff.append("; directAck=").append(this.directAck);
+
+    for (int i = 0; i < removeAllPRDataSize; i++) {
+      buff.append("; entry" + i + ":").append(removeAllPRData[i].getKey()).append(",")
+          .append(removeAllPRData[i].versionTag);
-  public final InternalDistributedSystem getInternalDs()
-  {
+  public final InternalDistributedSystem getInternalDs() {
-  public final void setInternalDs(InternalDistributedSystem internalDs)
-  {
+  public final void setInternalDs(InternalDistributedSystem internalDs) {
-  public final void setDirectAck(boolean directAck)
-  {
+  public final void setDirectAck(boolean directAck) {
-    public RemoveAllReplyMessage() {
-    }
+    public RemoveAllReplyMessage() {}
-    private RemoveAllReplyMessage(int processorId, boolean result, VersionedObjectList versions, ReplyException ex) {
+    private RemoveAllReplyMessage(int processorId, boolean result, VersionedObjectList versions,
+        ReplyException ex) {
-    public static void send(InternalDistributedMember recipient, int processorId,
-        ReplySender dm, boolean result, VersionedObjectList versions, ReplyException ex) {
+    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm,
+        boolean result, VersionedObjectList versions, ReplyException ex) {
-     * Processes this message.  This method is invoked by the receiver
-     * of the message.
+     * Processes this message. This method is invoked by the receiver of the message.
+     * 
-        RemoveAllResponse processor = (RemoveAllResponse)rp;
+        RemoveAllResponse processor = (RemoveAllResponse) rp;
-      dm.getStats().incReplyMessageTime(NanoTimer.getTime()-startTime);
+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);
-    public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      this.versions = (VersionedObjectList)DataSerializer.readObject(in);
+      this.versions = (VersionedObjectList) DataSerializer.readObject(in);
-      sb.append("RemoveAllReplyMessage ")
-      .append("processorid=").append(this.processorId)
-      .append(" returning ").append(this.result)
-      .append(" exception=").append(getException())
-      .append(" versions= ").append(this.versions);
+      sb.append("RemoveAllReplyMessage ").append("processorid=").append(this.processorId)
+          .append(" returning ").append(this.result).append(" exception=").append(getException())
+          .append(" versions= ").append(this.versions);
-  
+
+   * 
-    public RemoveAllResult waitForResult() throws CacheException,
-        ForceReattemptException {
+    public RemoveAllResult waitForResult() throws CacheException, ForceReattemptException {
-      }
-      catch (ForceReattemptException e) {
+      } catch (ForceReattemptException e) {
-    
+
+
-      return "RemoveAllResult("+this.returnValue+", "+this.versions+")";
-  }
+      return "RemoveAllResult(" + this.returnValue + ", " + this.versions + ")";
+    }

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66
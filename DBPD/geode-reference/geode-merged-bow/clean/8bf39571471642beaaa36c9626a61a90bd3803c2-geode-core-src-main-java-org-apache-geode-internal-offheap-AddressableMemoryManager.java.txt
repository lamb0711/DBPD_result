Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class supports allocating and freeing large amounts of addressable memory
- * (i.e. slabs). It also supports using an "address" to operate on the memory.
- * Note that this class's implementation is currently a singleton so all the methods
- * on it are static.
+ * This class supports allocating and freeing large amounts of addressable memory (i.e. slabs). It
+ * also supports using an "address" to operate on the memory. Note that this class's implementation
+ * is currently a singleton so all the methods on it are static.
-  
+
-      if (!SharedLibrary.is64Bit() && size >= (1024*1024*1024)) {
-        msg += " The JVM looks like a 32-bit one. For large amounts of off-heap memory a 64-bit JVM is needed.";
+      if (!SharedLibrary.is64Bit() && size >= (1024 * 1024 * 1024)) {
+        msg +=
+            " The JVM looks like a 32-bit one. For large amounts of off-heap memory a 64-bit JVM is needed.";
-  
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
-    
+
-    assert bytesOffset + size <= bytes.length : "byteOffset=" + bytesOffset + ",size=" + size + ",bytes.length=" + bytes.length;
-    
+    assert bytesOffset + size <= bytes.length : "byteOffset=" + bytesOffset + ",size=" + size
+        + ",bytes.length=" + bytes.length;
+
-    unsafe.copyMemory(null, addr, bytes, ARRAY_BYTE_BASE_OFFSET+bytesOffset, size);
+    unsafe.copyMemory(null, addr, bytes, ARRAY_BYTE_BASE_OFFSET + bytesOffset, size);
+
+
-  
+
-    assert bytesOffset + size <= bytes.length : "byteOffset=" + bytesOffset + ",size=" + size + ",bytes.length=" + bytes.length;
-    
+    assert bytesOffset + size <= bytes.length : "byteOffset=" + bytesOffset + ",size=" + size
+        + ",bytes.length=" + bytes.length;
+
-    unsafe.copyMemory(bytes, ARRAY_BYTE_BASE_OFFSET+bytesOffset, null, addr, size);
+    unsafe.copyMemory(bytes, ARRAY_BYTE_BASE_OFFSET + bytesOffset, null, addr, size);
+
-   * Returns the address of the Unsafe memory for the first byte of a direct ByteBuffer.
-   * If the buffer is not direct or the address can not be obtained return 0.
+   * Returns the address of the Unsafe memory for the first byte of a direct ByteBuffer. If the
+   * buffer is not direct or the address can not be obtained return 0.
-  @SuppressWarnings({ "rawtypes", "unchecked" })
+  @SuppressWarnings({"rawtypes", "unchecked"})
-          //throw new IllegalStateException("Could not find java.nio.DirectByteBuffer", e);
+          // throw new IllegalStateException("Could not find java.nio.DirectByteBuffer", e);
-        //throw new IllegalStateException("Could not get method DirectByteBuffer.address()", e);
+        // throw new IllegalStateException("Could not get method DirectByteBuffer.address()", e);
-      return (Long)m.invoke(bb);
+      return (Long) m.invoke(bb);
-      //throw new IllegalStateException("Could not create an invoke DirectByteBuffer.address()", e);
+      // throw new IllegalStateException("Could not create an invoke DirectByteBuffer.address()",
+      // e);
-   * Create a direct byte buffer given its address and size.
-   * The returned ByteBuffer will be direct and use the memory at the given address.
+   * Create a direct byte buffer given its address and size. The returned ByteBuffer will be direct
+   * and use the memory at the given address.
+   * 
-  @SuppressWarnings({ "rawtypes", "unchecked" })
+  @SuppressWarnings({"rawtypes", "unchecked"})
-          //throw new IllegalStateException("Could not find java.nio.DirectByteBuffer", e);
+          // throw new IllegalStateException("Could not find java.nio.DirectByteBuffer", e);
-        //throw new IllegalStateException("Could not get constructor DirectByteBuffer(long, int)", e);
+        // throw new IllegalStateException("Could not get constructor DirectByteBuffer(long, int)",
+        // e);
-      return (ByteBuffer)ctor.newInstance(address, size);
-    } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
-      //throw new IllegalStateException("Could not create an instance using DirectByteBuffer(long, int)", e);
+      return (ByteBuffer) ctor.newInstance(address, size);
+    } catch (InstantiationException | IllegalAccessException | IllegalArgumentException
+        | InvocationTargetException e) {
+      // throw new IllegalStateException("Could not create an instance using DirectByteBuffer(long,
+      // int)", e);

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66
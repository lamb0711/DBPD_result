Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import org.apache.geode.internal.cache.tier.sockets.OldClientSupportService;
- * Provides static helper methods for reading and writing
- * non-primitive data when working with a {@link DataSerializable}.
- * For instance, classes that implement <code>DataSerializable</code>
- * can use the <code>DataSerializer</code> in their
- * <code>toData</code> and <code>fromData</code> methods:
+ * Provides static helper methods for reading and writing non-primitive data when working with a
+ * {@link DataSerializable}. For instance, classes that implement <code>DataSerializable</code> can
+ * use the <code>DataSerializer</code> in their <code>toData</code> and <code>fromData</code>
+ * methods:
- * <!--
- * The source code for the Employee class resides in
- *         tests/com/examples/ds/Employee.java
- * Please keep the below code snippet in sync with that file.
- * -->
+ * <!-- The source code for the Employee class resides in tests/com/examples/ds/Employee.java Please
+ * keep the below code snippet in sync with that file. -->
-public class Employee implements DataSerializable {
-  private int id;
-  private String name;
-  private Date birthday;
-  private Company employer;
-
-  public void toData(DataOutput out) throws IOException {
-    out.writeInt(this.id);
-    out.writeUTF(this.name);
-    DataSerializer.writeDate(this.birthday, out);
-    DataSerializer.writeObject(this.employer, out);
-  }
-
-  public void fromData(DataInput in)
-    throws IOException, ClassNotFoundException {
-
-    this.id = in.readInt();
-    this.name = in.readUTF();
-    this.birthday = DataSerializer.readDate(in);
-    this.employer = (Company) DataSerializer.readObject(in);
-  }
-}
-
+ * public class Employee implements DataSerializable {
+ *   private int id;
+ *   private String name;
+ *   private Date birthday;
+ *   private Company employer;
+ * 
+ *   public void toData(DataOutput out) throws IOException {
+ *     out.writeInt(this.id);
+ *     out.writeUTF(this.name);
+ *     DataSerializer.writeDate(this.birthday, out);
+ *     DataSerializer.writeObject(this.employer, out);
+ *   }
+ * 
+ *   public void fromData(DataInput in) throws IOException, ClassNotFoundException {
+ * 
+ *     this.id = in.readInt();
+ *     this.name = in.readUTF();
+ *     this.birthday = DataSerializer.readDate(in);
+ *     this.employer = (Company) DataSerializer.readObject(in);
+ *   }
+ * }
+ * 
- * Instances of <code>DataSerializer</code> are used to data serialize
- * objects (such as instances of standard Java classes or third-party
- * classes for which the source code is not available) that do not
- * implement the <code>DataSerializable</code> interface.
+ * Instances of <code>DataSerializer</code> are used to data serialize objects (such as instances of
+ * standard Java classes or third-party classes for which the source code is not available) that do
+ * not implement the <code>DataSerializable</code> interface.
- * The following <code>DataSerializer</code> data serializes instances
- * of <code>Company</code>.  In order for the data serialization
- * framework to consult this custom serializer, it must be {@linkplain
- * #register(Class) registered} with the framework.
+ * The following <code>DataSerializer</code> data serializes instances of <code>Company</code>. In
+ * order for the data serialization framework to consult this custom serializer, it must be
+ * {@linkplain #register(Class) registered} with the framework.
- * <!--
- * The source code for the CompanySerializer class resides in
- *         tests/com/examples/ds/CompanySerializer.java
- * Please keep the below code snippet in sync with that file.
- * -->
+ * <!-- The source code for the CompanySerializer class resides in
+ * tests/com/examples/ds/CompanySerializer.java Please keep the below code snippet in sync with that
+ * file. -->
- * Just like {@link Instantiator}s, a <code>DataSerializer</code> may
- * be sent to other members of the distributed system when it is
- * {@linkplain #register(Class) registered}.  The data serialization
- * framework does not require that a <code>DataSerializer</code> be
- * {@link Serializable}, but it does require that it provide a
- * {@linkplain #DataSerializer() zero-argument constructor}.
+ * Just like {@link Instantiator}s, a <code>DataSerializer</code> may be sent to other members of
+ * the distributed system when it is {@linkplain #register(Class) registered}. The data
+ * serialization framework does not require that a <code>DataSerializer</code> be
+ * {@link Serializable}, but it does require that it provide a {@linkplain #DataSerializer()
+ * zero-argument constructor}.
- * @since GemFire 3.5 */
+ * @since GemFire 3.5
+ */
-  
+
-  
+
-    Boolean.getBoolean("DataSerializer.TRACE_SERIALIZABLE");
+      Boolean.getBoolean("DataSerializer.TRACE_SERIALIZABLE");
-  protected static final ThreadLocal<Boolean> DISALLOW_JAVA_SERIALIZATION = new ThreadLocal<Boolean>();
+  protected static final ThreadLocal<Boolean> DISALLOW_JAVA_SERIALIZATION =
+      new ThreadLocal<Boolean>();
-  //////////////////////  Instance Fields  /////////////////////
+  ////////////////////// Instance Fields /////////////////////
-  //////////////////////  Static Methods  //////////////////////
+  ////////////////////// Static Methods //////////////////////
-   * Writes an instance of <code>Class</code> to a
-   * <code>DataOutput</code>.
-   * This method will handle a
-   * <code>null</code> value and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an instance of <code>Class</code> to a <code>DataOutput</code>. This method will handle
+   * a <code>null</code> value and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeClass(Class<?> c, DataOutput out)
-    throws IOException {
+  public static void writeClass(Class<?> c, DataOutput out) throws IOException {
-    }
-    else {
+    } else {
-      cname = swizzleClassNameForWrite(cname, out);
+      cname = InternalDataSerializer.processOutgoingClassName(cname, out);
-   * Writes class name to a <code>DataOutput</code>. This method will handle a
-   * <code>null</code> value and not throw a <code>NullPointerException</code>.
+   * Writes class name to a <code>DataOutput</code>. This method will handle a <code>null</code>
+   * value and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *           A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-    throws IOException {
+      throws IOException {
-    writeString(swizzleClassNameForWrite(className, out), out);
+    writeString(InternalDataSerializer.processOutgoingClassName(className, out), out);
-   * Reads an instance of <code>Class</code> from a
-   * <code>DataInput</code>.  The class will be loaded using the
-   * {@linkplain Thread#getContextClassLoader current content class
-   * loader}.
-   * The return value may be <code>null</code>.
+   * Reads an instance of <code>Class</code> from a <code>DataInput</code>. The class will be loaded
+   * using the {@linkplain Thread#getContextClassLoader current content class loader}. The return
+   * value may be <code>null</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
-   * @throws ClassNotFoundException
-   *         The class cannot be loaded
+   * @throws IOException A problem occurs while reading from <code>in</code>
+   * @throws ClassNotFoundException The class cannot be loaded
-  public static Class<?> readClass(DataInput in)
-    throws IOException, ClassNotFoundException {
+  public static Class<?> readClass(DataInput in) throws IOException, ClassNotFoundException {
-      className = swizzleClassNameForRead(className, in);
-    }
-    else {
+    } else {
-  
+
-   * For backward compatibility we must swizzle the package of
-   * some classes that had to be moved when GemFire was open-
-   * sourced.  This preserves backward-compatibility.
-   * 
-   * @param name the fully qualified class name
-   * @param in the source of the class name
-   * @return the name of the class in this implementation
-   */
-  private static String swizzleClassNameForRead(String name, DataInput in) {
-    // TCPServer classes are used before a cache exists and support for old clients has been initialized
-    String oldPackage = "com.gemstone.org.jgroups.stack.tcpserver";
-    String newPackage = "org.apache.geode.distributed.internal.tcpserver";
-    if (name.startsWith(oldPackage)) {
-      return newPackage + name.substring(oldPackage.length());
-    }
-    OldClientSupportService svc = InternalDataSerializer.getOldClientSupportService();
-    if (svc != null) {
-      return svc.processIncomingClassName(name, in);
-    }
-    return name;
-  }
-  
-  /**
-   * For backward compatibility we must swizzle the package of
-   * some classes that had to be moved when GemFire was open-
-   * sourced.  This preserves backward-compatibility.
-   * 
-   * @param name the fully qualified class name
-   * @param out the consumer of the serialized object
-   * @return the name of the class in this implementation
-   */
-  private static String swizzleClassNameForWrite(String name, DataOutput out) {
-    // TCPServer classes are used before a cache exists and support for old clients has been initialized
-    String oldPackage = "com.gemstone.org.jgroups.stack.tcpserver";
-    String newPackage = "org.apache.geode.distributed.internal.tcpserver";
-    if (name.startsWith(newPackage)) {
-      return oldPackage + name.substring(newPackage.length());
-    }
-    OldClientSupportService svc = InternalDataSerializer.getOldClientSupportService();
-    if (svc != null) {
-      return svc.processOutgoingClassName(name, out);
-    }
-    return name;
-  }
-  
-  /**
-   * Reads name of an instance of <code>Class</code> from a
-   * <code>DataInput</code>.
+   * Reads name of an instance of <code>Class</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *           A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-  public static String readNonPrimitiveClassName(DataInput in)
-      throws IOException {
+  public static String readNonPrimitiveClassName(DataInput in) throws IOException {
-    return swizzleClassNameForRead(readString(in), in);
+    return InternalDataSerializer.processIncomingClassName(readString(in));
-   * Writes an instance of Region. A Region is serialized as just a reference
-   * to a full path only. It will be recreated on the other end by calling
-   * {@link CacheFactory#getAnyInstance} and then calling
-   * <code>getRegion</code> on it.
-   * This method will handle a
-   * <code>null</code> value and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an instance of Region. A Region is serialized as just a reference to a full path only.
+   * It will be recreated on the other end by calling {@link CacheFactory#getAnyInstance} and then
+   * calling <code>getRegion</code> on it. This method will handle a <code>null</code> value and not
+   * throw a <code>NullPointerException</code>.
-  public static void writeRegion(Region<?,?> rgn, DataOutput out)
-  throws IOException {
+  public static void writeRegion(Region<?, ?> rgn, DataOutput out) throws IOException {
-   * Reads an instance of Region. A Region is serialized as a reference to a
-   * full path only. It is recreated on the other end by calling
-   * {@link CacheFactory#getAnyInstance} and then calling
-   * <code>getRegion</code> on it.
-   * The return value may be <code>null</code>.
+   * Reads an instance of Region. A Region is serialized as a reference to a full path only. It is
+   * recreated on the other end by calling {@link CacheFactory#getAnyInstance} and then calling
+   * <code>getRegion</code> on it. The return value may be <code>null</code>.
-   * created one is closed.
-   * @throws RegionNotFoundException if there is no region by this name
-   * in the Cache
+   *         created one is closed.
+   * @throws RegionNotFoundException if there is no region by this name in the Cache
-  public static <K,V> Region<K,V> readRegion(DataInput in)
-  throws IOException, ClassNotFoundException {
+  public static <K, V> Region<K, V> readRegion(DataInput in)
+      throws IOException, ClassNotFoundException {
-    Region<K,V> rgn = null;
+    Region<K, V> rgn = null;
-      rgn = ((Cache)GemFireCacheImpl.getExisting("Needed cache to find region.")).getRegion(fullPath);
+      rgn = ((Cache) GemFireCacheImpl.getExisting("Needed cache to find region."))
+          .getRegion(fullPath);
-      throw new RegionNotFoundException(LocalizedStrings.DataSerializer_REGION_0_COULD_NOT_BE_FOUND_WHILE_READING_A_DATASERIALIZER_STREAM.toLocalizedString(fullPath));
+        throw new RegionNotFoundException(
+            LocalizedStrings.DataSerializer_REGION_0_COULD_NOT_BE_FOUND_WHILE_READING_A_DATASERIALIZER_STREAM
+                .toLocalizedString(fullPath));
-   * Writes an instance of <code>Date</code> to a
-   * <code>DataOutput</code>.  Note that even though <code>date</code>
-   * may be an instance of a subclass of <code>Date</code>,
-   * <code>readDate</code> will always return an instance of
-   * <code>Date</code>, <B>not</B> an instance of the subclass.  To
-   * preserve the class type of <code>date</code>,\
-   * {@link #writeObject(Object, DataOutput)} should be used for data serialization.
-   * This method will handle a
-   * <code>null</code> value and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an instance of <code>Date</code> to a <code>DataOutput</code>. Note that even though
+   * <code>date</code> may be an instance of a subclass of <code>Date</code>, <code>readDate</code>
+   * will always return an instance of <code>Date</code>, <B>not</B> an instance of the subclass. To
+   * preserve the class type of <code>date</code>,\ {@link #writeObject(Object, DataOutput)} should
+   * be used for data serialization. This method will handle a <code>null</code> value and not throw
+   * a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeDate(Date date, DataOutput out)
-    throws IOException {
+  public static void writeDate(Date date, DataOutput out) throws IOException {
-        throw new IllegalArgumentException("Dates whose getTime returns -1 can not be DataSerialized.");
+        throw new IllegalArgumentException(
+            "Dates whose getTime returns -1 can not be DataSerialized.");
-   * Reads an instance of <code>Date</code> from a
-   * <code>DataInput</code>.
-   * The return value may be <code>null</code>.
+   * Reads an instance of <code>Date</code> from a <code>DataInput</code>. The return value may be
+   * <code>null</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes an instance of <code>File</code> to a
-   * <code>DataOutput</code>.  Note that even though <code>file</code>
-   * may be an instance of a subclass of <code>File</code>,
-   * <code>readFile</code> will always return an instance of
-   * <code>File</code>, <B>not</B> an instance of the subclass.  To
-   * preserve the class type of <code>file</code>,
-   * {@link #writeObject(Object, DataOutput)} should be used for data serialization.
-   * This method will handle a
-   * <code>null</code> value and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an instance of <code>File</code> to a <code>DataOutput</code>. Note that even though
+   * <code>file</code> may be an instance of a subclass of <code>File</code>, <code>readFile</code>
+   * will always return an instance of <code>File</code>, <B>not</B> an instance of the subclass. To
+   * preserve the class type of <code>file</code>, {@link #writeObject(Object, DataOutput)} should
+   * be used for data serialization. This method will handle a <code>null</code> value and not throw
+   * a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeFile(File file, DataOutput out)
-    throws IOException {
+  public static void writeFile(File file, DataOutput out) throws IOException {
-   * Reads an instance of <code>File</code> from a
-   * <code>DataInput</code>.
-   * The return value may be <code>null</code>.
+   * Reads an instance of <code>File</code> from a <code>DataInput</code>. The return value may be
+   * <code>null</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes an instance of <code>InetAddress</code> to a
-   * <code>DataOutput</code>.  The <code>InetAddress</code> is data
-   * serialized by writing its {@link InetAddress#getAddress byte}
-   * representation to the <code>DataOutput</code>.  {@link
-   * #readInetAddress} converts the <code>byte</code> representation
-   * to an instance of <code>InetAddress</code> using {@link
-   * InetAddress#getAddress}.  As a result, if <code>address</code>
-   * is an instance of a user-defined subclass of
-   * <code>InetAddress</code> (that is, not an instance of one of the
-   * subclasses from the <code>java.net</code> package), its class
-   * will not be preserved.  In order to be able to read an instance
-   * of the user-defined class, {@link #writeObject(Object, DataOutput)} should be used.
-   * This method will handle a
-   * <code>null</code> value and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an instance of <code>InetAddress</code> to a <code>DataOutput</code>. The
+   * <code>InetAddress</code> is data serialized by writing its {@link InetAddress#getAddress byte}
+   * representation to the <code>DataOutput</code>. {@link #readInetAddress} converts the
+   * <code>byte</code> representation to an instance of <code>InetAddress</code> using
+   * {@link InetAddress#getAddress}. As a result, if <code>address</code> is an instance of a
+   * user-defined subclass of <code>InetAddress</code> (that is, not an instance of one of the
+   * subclasses from the <code>java.net</code> package), its class will not be preserved. In order
+   * to be able to read an instance of the user-defined class,
+   * {@link #writeObject(Object, DataOutput)} should be used. This method will handle a
+   * <code>null</code> value and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeInetAddress(InetAddress address,
-                                      DataOutput out)
-    throws IOException {
+  public static void writeInetAddress(InetAddress address, DataOutput out) throws IOException {
-   * Reads an instance of <code>InetAddress</code> from a
-   * <code>DataInput</code>.
-   * The return value may be <code>null</code>.
+   * Reads an instance of <code>InetAddress</code> from a <code>DataInput</code>. The return value
+   * may be <code>null</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
-   *         or the address read from <code>in</code> is unknown
+   * @throws IOException A problem occurs while reading from <code>in</code> or the address read
+   *         from <code>in</code> is unknown
-  public static InetAddress readInetAddress(DataInput in)
-    throws IOException {
+  public static InetAddress readInetAddress(DataInput in) throws IOException {
-      IOException ex2 = new IOException(LocalizedStrings.DataSerializer_WHILE_READING_AN_INETADDRESS.toLocalizedString());
+      IOException ex2 = new IOException(
+          LocalizedStrings.DataSerializer_WHILE_READING_AN_INETADDRESS.toLocalizedString());
-   * Writes an instance of <code>String</code> to a
-   * <code>DataOutput</code>.
-   * This method will handle a
-   * <code>null</code> value and not throw a
-   * <code>NullPointerException</code>.
-   * <p>As of 5.7 strings longer than 0xFFFF can be serialized.
+   * Writes an instance of <code>String</code> to a <code>DataOutput</code>. This method will handle
+   * a <code>null</code> value and not throw a <code>NullPointerException</code>.
+   * <p>
+   * As of 5.7 strings longer than 0xFFFF can be serialized.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeString(String value, DataOutput out)
-    throws IOException {
+  public static void writeString(String value, DataOutput out) throws IOException {
-      // then writes the bytes.  Since we usually deal with ISO-8859-1
+      // then writes the bytes. Since we usually deal with ISO-8859-1
-      // with charAt and fill a single-byte buffer.  If we run into
+      // with charAt and fill a single-byte buffer. If we run into
-      for (int i=0; i<len; i++) {
+      for (int i = 0; i < len; i++) {
-      }
-      else {
+      } else {
-   * Reads an instance of <code>String</code> from a
-   * <code>DataInput</code>.  The return value may be
+   * Reads an instance of <code>String</code> from a <code>DataInput</code>. The return value may be
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes an instance of <code>Boolean</code> to a
-   * <code>DataOutput</code>.
+   * Writes an instance of <code>Boolean</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeBoolean(Boolean value, DataOutput out)
-    throws IOException {
+  public static void writeBoolean(Boolean value, DataOutput out) throws IOException {
-   * Reads an instance of <code>Boolean</code> from a
-   * <code>DataInput</code>.
+   * Reads an instance of <code>Boolean</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes an instance of <code>Character</code> to a
-   * <code>DataOutput</code>.
+   * Writes an instance of <code>Character</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeCharacter(Character value, DataOutput out)
-    throws IOException {
+  public static void writeCharacter(Character value, DataOutput out) throws IOException {
-   * Reads an instance of <code>Character</code> from a
-   * <code>DataInput</code>.
+   * Reads an instance of <code>Character</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-  public static Character readCharacter(DataInput in)
-    throws IOException {
+  public static Character readCharacter(DataInput in) throws IOException {
-   * Writes an instance of <code>Byte</code> to a
-   * <code>DataOutput</code>.
+   * Writes an instance of <code>Byte</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeByte(Byte value, DataOutput out)
-    throws IOException {
+  public static void writeByte(Byte value, DataOutput out) throws IOException {
-   * Reads an instance of <code>Byte</code> from a
-   * <code>DataInput</code>.
+   * Reads an instance of <code>Byte</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes an instance of <code>Short</code> to a
-   * <code>DataOutput</code>.
+   * Writes an instance of <code>Short</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeShort(Short value, DataOutput out)
-    throws IOException {
+  public static void writeShort(Short value, DataOutput out) throws IOException {
-   * Reads an instance of <code>Short</code> from a
-   * <code>DataInput</code>.
+   * Reads an instance of <code>Short</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes an instance of <code>Integer</code> to a
-   * <code>DataOutput</code>.
+   * Writes an instance of <code>Integer</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeInteger(Integer value, DataOutput out)
-    throws IOException {
+  public static void writeInteger(Integer value, DataOutput out) throws IOException {
-   * Reads an instance of <code>Integer</code> from a
-   * <code>DataInput</code>.
+   * Reads an instance of <code>Integer</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes an instance of <code>Long</code> to a
-   * <code>DataOutput</code>.
+   * Writes an instance of <code>Long</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeLong(Long value, DataOutput out)
-    throws IOException {
+  public static void writeLong(Long value, DataOutput out) throws IOException {
-   * Reads an instance of <code>Long</code> from a
-   * <code>DataInput</code>.
+   * Reads an instance of <code>Long</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes an instance of <code>Float</code> to a
-   * <code>DataOutput</code>.
+   * Writes an instance of <code>Float</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeFloat(Float value, DataOutput out)
-    throws IOException {
+  public static void writeFloat(Float value, DataOutput out) throws IOException {
-   * Reads an instance of <code>Float</code> from a
-   * <code>DataInput</code>.
+   * Reads an instance of <code>Float</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes an instance of <code>Double</code> to a
-   * <code>DataOutput</code>.
+   * Writes an instance of <code>Double</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeDouble(Double value, DataOutput out)
-    throws IOException {
+  public static void writeDouble(Double value, DataOutput out) throws IOException {
-   * Reads an instance of <code>Double</code> from a
-   * <code>DataInput</code>.
+   * Reads an instance of <code>Double</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes a primitive <code>boolean</code> to a
-   * <code>DataOutput</code>.
+   * Writes a primitive <code>boolean</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writePrimitiveBoolean(boolean value, DataOutput out)
-    throws IOException {
+  public static void writePrimitiveBoolean(boolean value, DataOutput out) throws IOException {
-   * Reads a primitive <code>boolean</code> from a
-   * <code>DataInput</code>.
+   * Reads a primitive <code>boolean</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes a primitive <code>byte</code> to a
-   * <code>DataOutput</code>.
+   * Writes a primitive <code>byte</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writePrimitiveByte(byte value, DataOutput out)
-    throws IOException {
+  public static void writePrimitiveByte(byte value, DataOutput out) throws IOException {
-   * Reads a primitive <code>byte</code> from a
-   * <code>DataInput</code>.
+   * Reads a primitive <code>byte</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes a primitive  <code>char</code> to a
-   * <code>DataOutput</code>.
+   * Writes a primitive <code>char</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writePrimitiveChar(char value, DataOutput out)
-    throws IOException {
+  public static void writePrimitiveChar(char value, DataOutput out) throws IOException {
-   * Reads a primitive <code>char</code> from a
-   * <code>DataInput</code>.
+   * Reads a primitive <code>char</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes a primitive <code>short</code> to a
-   * <code>DataOutput</code>.
+   * Writes a primitive <code>short</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writePrimitiveShort(short value, DataOutput out)
-    throws IOException {
+  public static void writePrimitiveShort(short value, DataOutput out) throws IOException {
-   * Reads a primitive <code>short</code> from a
-   * <code>DataInput</code>.
+   * Reads a primitive <code>short</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes a primitive <code>int</code> as an unsigned byte to a
-   * <code>DataOutput</code>.
+   * Writes a primitive <code>int</code> as an unsigned byte to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeUnsignedByte(int value, DataOutput out)
-    throws IOException {
+  public static void writeUnsignedByte(int value, DataOutput out) throws IOException {
-   * Reads a primitive <code>int</code> as an unsigned byte from a
-   * <code>DataInput</code> using {@link DataInput#readUnsignedByte}.
+   * Reads a primitive <code>int</code> as an unsigned byte from a <code>DataInput</code> using
+   * {@link DataInput#readUnsignedByte}.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes a primitive <code>int</code> as an unsigned short to a
-   * <code>DataOutput</code>.
+   * Writes a primitive <code>int</code> as an unsigned short to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeUnsignedShort(int value, DataOutput out)
-    throws IOException {
+  public static void writeUnsignedShort(int value, DataOutput out) throws IOException {
-   * Reads a primitive <code>int</code> as an unsigned short from a
-   * <code>DataInput</code> using {@link DataInput#readUnsignedShort}.
+   * Reads a primitive <code>int</code> as an unsigned short from a <code>DataInput</code> using
+   * {@link DataInput#readUnsignedShort}.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes a primitive <code>int</code> to a
-   * <code>DataOutput</code>.
+   * Writes a primitive <code>int</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writePrimitiveInt(int value, DataOutput out)
-    throws IOException {
+  public static void writePrimitiveInt(int value, DataOutput out) throws IOException {
-   * Reads a primitive <code>int</code> from a
-   * <code>DataInput</code>.
+   * Reads a primitive <code>int</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes a primitive <code>long</code> to a
-   * <code>DataOutput</code>.
+   * Writes a primitive <code>long</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writePrimitiveLong(long value, DataOutput out)
-    throws IOException {
+  public static void writePrimitiveLong(long value, DataOutput out) throws IOException {
-   * Reads a primitive <code>long</code> from a
-   * <code>DataInput</code>.
+   * Reads a primitive <code>long</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes a primitive <code>float</code> to a
-   * <code>DataOutput</code>.
+   * Writes a primitive <code>float</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writePrimitiveFloat(float value, DataOutput out)
-    throws IOException {
+  public static void writePrimitiveFloat(float value, DataOutput out) throws IOException {
-   * Reads a primitive <code>float</code> from a
-   * <code>DataInput</code>.
+   * Reads a primitive <code>float</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes a primtive <code>double</code> to a
-   * <code>DataOutput</code>.
+   * Writes a primtive <code>double</code> to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writePrimitiveDouble(double value, DataOutput out)
-    throws IOException {
+  public static void writePrimitiveDouble(double value, DataOutput out) throws IOException {
-   * Reads a primitive <code>double</code> from a
-   * <code>DataInput</code>.
+   * Reads a primitive <code>double</code> from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-   * Writes an array of <code>byte</code>s to a
-   * <code>DataOutput</code>.
-   * This method will serialize a
-   * <code>null</code> array and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an array of <code>byte</code>s to a <code>DataOutput</code>. This method will serialize
+   * a <code>null</code> array and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeByteArray(byte[] array, DataOutput out)
-    throws IOException {
+  public static void writeByteArray(byte[] array, DataOutput out) throws IOException {
-   * Writes the first <code>len</code> elements
-   * of an array of <code>byte</code>s to a
-   * <code>DataOutput</code>.
-   * This method will serialize a
-   * <code>null</code> array and not throw a
+   * Writes the first <code>len</code> elements of an array of <code>byte</code>s to a
+   * <code>DataOutput</code>. This method will serialize a <code>null</code> array and not throw a
-   * @param len the actual number of entries to write. If len is greater
-   * than then length of the array then the entire array is written.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @param len the actual number of entries to write. If len is greater than then length of the
+   *        array then the entire array is written.
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeByteArray(byte[] array, int len, DataOutput out)
-    throws IOException {
+  public static void writeByteArray(byte[] array, int len, DataOutput out) throws IOException {
-    
+
+
-   * Serialize the given object <code>obj</code> into a byte array
-   * using {@link #writeObject(Object, DataOutput)} and then writes the byte array
-   * to the given data output <code>out</code> in the same format
-   * {@link #writeByteArray(byte[], DataOutput)} does.
-   * This method will serialize a
-   * <code>null</code> obj and not throw a
+   * Serialize the given object <code>obj</code> into a byte array using
+   * {@link #writeObject(Object, DataOutput)} and then writes the byte array to the given data
+   * output <code>out</code> in the same format {@link #writeByteArray(byte[], DataOutput)} does.
+   * This method will serialize a <code>null</code> obj and not throw a
-   * @throws IllegalArgumentException
-   *         if a problem occurs while serialize <code>obj</code>
-   * @throws IOException
-   *         if a problem occurs while writing to <code>out</code>
+   * @throws IllegalArgumentException if a problem occurs while serialize <code>obj</code>
+   * @throws IOException if a problem occurs while writing to <code>out</code>
-  public static void writeObjectAsByteArray(Object obj, DataOutput out)
-    throws IOException {
+  public static void writeObjectAsByteArray(Object obj, DataOutput out) throws IOException {
-        StoredObject so = (StoredObject)obj;
+        StoredObject so = (StoredObject) obj;
-        logger.trace(LogMarker.SERIALIZER, "writeObjectAsByteArray obj.getClass={}", object.getClass());
+        logger.trace(LogMarker.SERIALIZER, "writeObjectAsByteArray obj.getClass={}",
+            object.getClass());
-      writeByteArray((byte[])object, out);
+      writeByteArray((byte[]) object, out);
-      ((ObjToByteArraySerializer)out).writeAsSerializedByteArray(object);
-    }/*else if (obj instanceof Sendable) {
-      ((Sendable)obj).sendTo(out); 
-    } */ 
+      ((ObjToByteArraySerializer) out).writeAsSerializedByteArray(object);
+    } /*
+       * else if (obj instanceof Sendable) { ((Sendable)obj).sendTo(out); }
+       */
-        hdos = (HeapDataOutputStream)object;
+        hdos = (HeapDataOutputStream) object;
-          RuntimeException e2 = new IllegalArgumentException(LocalizedStrings.DataSerializer_PROBELM_WHILE_SERIALIZING.toLocalizedString());
+          RuntimeException e2 = new IllegalArgumentException(
+              LocalizedStrings.DataSerializer_PROBELM_WHILE_SERIALIZING.toLocalizedString());
-   * Reads an array of <code>byte</code>s from a
-   * <code>DataInput</code>.
+   * Reads an array of <code>byte</code>s from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-  public static byte[] readByteArray(DataInput in)
-    throws IOException {
+  public static byte[] readByteArray(DataInput in) throws IOException {
-      InternalDataSerializer.checkIn(in);
+    InternalDataSerializer.checkIn(in);
-      int length = InternalDataSerializer.readArrayLength(in);
-      if (length == -1) {
-        return null;
-      } else {
-        byte[] array = new byte[length];
-        in.readFully(array, 0, length);
+    int length = InternalDataSerializer.readArrayLength(in);
+    if (length == -1) {
+      return null;
+    } else {
+      byte[] array = new byte[length];
+      in.readFully(array, 0, length);
-        if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
-          logger.trace(LogMarker.SERIALIZER, "Read byte array of length {}", length);
-        }
-
-        return array;
+      if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
+        logger.trace(LogMarker.SERIALIZER, "Read byte array of length {}", length);
+
+      return array;
+  }
-   * Writes an array of <code>String</code>s to a
-   * <code>DataOutput</code>.
-   * This method will serialize a
-   * <code>null</code> array and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an array of <code>String</code>s to a <code>DataOutput</code>. This method will
+   * serialize a <code>null</code> array and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeStringArray(String[] array, DataOutput out)
-    throws IOException {
+  public static void writeStringArray(String[] array, DataOutput out) throws IOException {
-   * Reads an array of <code>String</code>s from a
-   * <code>DataInput</code>.
+   * Reads an array of <code>String</code>s from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-  public static String[] readStringArray(DataInput in)
-    throws IOException {
+  public static String[] readStringArray(DataInput in) throws IOException {
-      InternalDataSerializer.checkIn(in);
+    InternalDataSerializer.checkIn(in);
-      int length = InternalDataSerializer.readArrayLength(in);
-      if (length == -1) {
-        return null;
-      } else {
-        String[] array = new String[length];
-        for (int i = 0; i < length; i++) {
-          array[i] = readString(in);
-        }
-
-        if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
-          logger.trace(LogMarker.SERIALIZER, "Read String array of length {}", length);
-        }
-
-        return array;
+    int length = InternalDataSerializer.readArrayLength(in);
+    if (length == -1) {
+      return null;
+    } else {
+      String[] array = new String[length];
+      for (int i = 0; i < length; i++) {
+        array[i] = readString(in);
+
+      if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
+        logger.trace(LogMarker.SERIALIZER, "Read String array of length {}", length);
+      }
+
+      return array;
+  }
-   * Writes an array of <code>short</code>s to a
-   * <code>DataOutput</code>.
-   * This method will serialize a
-   * <code>null</code> array and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an array of <code>short</code>s to a <code>DataOutput</code>. This method will serialize
+   * a <code>null</code> array and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeShortArray(short[] array, DataOutput out)
-    throws IOException {
+  public static void writeShortArray(short[] array, DataOutput out) throws IOException {
-   * Reads an array of <code>short</code>s from a
-   * <code>DataInput</code>.
+   * Reads an array of <code>short</code>s from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-  public static short[] readShortArray(DataInput in)
-    throws IOException {
+  public static short[] readShortArray(DataInput in) throws IOException {
-      InternalDataSerializer.checkIn(in);
+    InternalDataSerializer.checkIn(in);
-      int length = InternalDataSerializer.readArrayLength(in);
-      if (length == -1) {
-        return null;
-      } else {
-        short[] array = new short[length];
-        for (int i = 0; i < length; i++) {
-          array[i] = in.readShort();
-        }
-
-        if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
-          logger.trace(LogMarker.SERIALIZER, "Read short array of length {}", length);
-        }
-
-        return array;
+    int length = InternalDataSerializer.readArrayLength(in);
+    if (length == -1) {
+      return null;
+    } else {
+      short[] array = new short[length];
+      for (int i = 0; i < length; i++) {
+        array[i] = in.readShort();
+
+      if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
+        logger.trace(LogMarker.SERIALIZER, "Read short array of length {}", length);
+      }
+
+      return array;
+  }
-   * Writes an array of <code>char</code>s to a
-   * <code>DataOutput</code>.
+   * Writes an array of <code>char</code>s to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeCharArray(char[] array, DataOutput out)
-      throws IOException {
+  public static void writeCharArray(char[] array, DataOutput out) throws IOException {
-    InternalDataSerializer.writeCharArray(array, array != null ? array.length
-        : -1, out);
+    InternalDataSerializer.writeCharArray(array, array != null ? array.length : -1, out);
-   * Reads an array of <code>char</code>s from a
-   * <code>DataInput</code>.
+   * Reads an array of <code>char</code>s from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-  public static char[] readCharArray(DataInput in)
-    throws IOException {
+  public static char[] readCharArray(DataInput in) throws IOException {
+
-   * Writes an array of <code>boolean</code>s to a
-   * <code>DataOutput</code>.
+   * Writes an array of <code>boolean</code>s to a <code>DataOutput</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeBooleanArray(boolean[] array, DataOutput out)
-    throws IOException {
+  public static void writeBooleanArray(boolean[] array, DataOutput out) throws IOException {
-   * Reads an array of <code>boolean</code>s from a
-   * <code>DataInput</code>.
+   * Reads an array of <code>boolean</code>s from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-  public static boolean[] readBooleanArray(DataInput in)
-    throws IOException {
+  public static boolean[] readBooleanArray(DataInput in) throws IOException {
+
-   * Writes an <code>int</code> array to a <code>DataOutput</code>.
-   * This method will serialize a
-   * <code>null</code> array and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an <code>int</code> array to a <code>DataOutput</code>. This method will serialize a
+   * <code>null</code> array and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeIntArray(int[] array, DataOutput out)
-    throws IOException {
+  public static void writeIntArray(int[] array, DataOutput out) throws IOException {
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-  public static int[] readIntArray(DataInput in)
-    throws IOException {
+  public static int[] readIntArray(DataInput in) throws IOException {
-      InternalDataSerializer.checkIn(in);
+    InternalDataSerializer.checkIn(in);
-      int length = InternalDataSerializer.readArrayLength(in);
-      if (length == -1) {
-        return null;
-      } else {
-        int[] array = new int[length];
-        for (int i = 0; i < length; i++) {
-          array[i] = in.readInt();
-        }
-
-        if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
-          logger.trace(LogMarker.SERIALIZER, "Read int array of length {}", length);
-        }
-
-        return array;
+    int length = InternalDataSerializer.readArrayLength(in);
+    if (length == -1) {
+      return null;
+    } else {
+      int[] array = new int[length];
+      for (int i = 0; i < length; i++) {
+        array[i] = in.readInt();
+
+      if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
+        logger.trace(LogMarker.SERIALIZER, "Read int array of length {}", length);
+      }
+
+      return array;
+  }
-   * Writes an array of <code>long</code>s to a
-   * <code>DataOutput</code>.
-   * This method will serialize a
-   * <code>null</code> array and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an array of <code>long</code>s to a <code>DataOutput</code>. This method will serialize
+   * a <code>null</code> array and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeLongArray(long[] array, DataOutput out)
-    throws IOException {
+  public static void writeLongArray(long[] array, DataOutput out) throws IOException {
-   * Reads an array of <code>long</code>s from a
-   * <code>DataInput</code>.
+   * Reads an array of <code>long</code>s from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-  public static long[] readLongArray(DataInput in)
-    throws IOException {
+  public static long[] readLongArray(DataInput in) throws IOException {
-      InternalDataSerializer.checkIn(in);
+    InternalDataSerializer.checkIn(in);
-      int length = InternalDataSerializer.readArrayLength(in);
-      if (length == -1) {
-        return null;
-      } else {
-        long[] array = new long[length];
-        for (int i = 0; i < length; i++) {
-          array[i] = in.readLong();
-        }
-
-        if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
-          logger.trace(LogMarker.SERIALIZER, "Read long array of length {}", length);
-        }
-
-        return array;
+    int length = InternalDataSerializer.readArrayLength(in);
+    if (length == -1) {
+      return null;
+    } else {
+      long[] array = new long[length];
+      for (int i = 0; i < length; i++) {
+        array[i] = in.readLong();
+
+      if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
+        logger.trace(LogMarker.SERIALIZER, "Read long array of length {}", length);
+      }
+
+      return array;
+  }
-   * Writes an array of <code>float</code>s to a
-   * <code>DataOutput</code>.
-   * This method will serialize a
-   * <code>null</code> array and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an array of <code>float</code>s to a <code>DataOutput</code>. This method will serialize
+   * a <code>null</code> array and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeFloatArray(float[] array, DataOutput out)
-    throws IOException {
+  public static void writeFloatArray(float[] array, DataOutput out) throws IOException {
-   * Reads an array of <code>float</code>s from a
-   * <code>DataInput</code>.
+   * Reads an array of <code>float</code>s from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-  public static float[] readFloatArray(DataInput in)
-    throws IOException {
+  public static float[] readFloatArray(DataInput in) throws IOException {
-      InternalDataSerializer.checkIn(in);
+    InternalDataSerializer.checkIn(in);
-      int length = InternalDataSerializer.readArrayLength(in);
-      if (length == -1) {
-        return null;
-      } else {
-        float[] array = new float[length];
-        for (int i = 0; i < length; i++) {
-          array[i] = in.readFloat();
-        }
-
-        if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
-          logger.trace(LogMarker.SERIALIZER, "Read float array of length {}", length);
-        }
-
-        return array;
+    int length = InternalDataSerializer.readArrayLength(in);
+    if (length == -1) {
+      return null;
+    } else {
+      float[] array = new float[length];
+      for (int i = 0; i < length; i++) {
+        array[i] = in.readFloat();
+
+      if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
+        logger.trace(LogMarker.SERIALIZER, "Read float array of length {}", length);
+      }
+
+      return array;
+  }
-   * Writes an array of <code>double</code>s to a
-   * <code>DataOutput</code>.
-   * This method will serialize a
-   * <code>null</code> array and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an array of <code>double</code>s to a <code>DataOutput</code>. This method will
+   * serialize a <code>null</code> array and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeDoubleArray(double[] array, DataOutput out)
-    throws IOException {
+  public static void writeDoubleArray(double[] array, DataOutput out) throws IOException {
-   * Reads an array of <code>double</code>s from a
-   * <code>DataInput</code>.
+   * Reads an array of <code>double</code>s from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-  public static double[] readDoubleArray(DataInput in)
-    throws IOException {
+  public static double[] readDoubleArray(DataInput in) throws IOException {
-      InternalDataSerializer.checkIn(in);
+    InternalDataSerializer.checkIn(in);
-      int length = InternalDataSerializer.readArrayLength(in);
-      if (length == -1) {
-        return null;
-      } else {
-        double[] array = new double[length];
-        for (int i = 0; i < length; i++) {
-          array[i] = in.readDouble();
-        }
-
-        if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
-          logger.trace(LogMarker.SERIALIZER, "Read double array of length {}", length);
-        }
-
-        return array;
+    int length = InternalDataSerializer.readArrayLength(in);
+    if (length == -1) {
+      return null;
+    } else {
+      double[] array = new double[length];
+      for (int i = 0; i < length; i++) {
+        array[i] = in.readDouble();
+
+      if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
+        logger.trace(LogMarker.SERIALIZER, "Read double array of length {}", length);
+      }
+
+      return array;
+  }
-   * Writes an array of <code>Object</code>s to a
-   * <code>DataOutput</code>.
-   * This method will serialize a
-   * <code>null</code> array and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an array of <code>Object</code>s to a <code>DataOutput</code>. This method will
+   * serialize a <code>null</code> array and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeObjectArray(Object[] array, DataOutput out)
-    throws IOException {
+  public static void writeObjectArray(Object[] array, DataOutput out) throws IOException {
-  
+
-   * Reads an array of <code>Object</code>s from a
-   * <code>DataInput</code>.
+   * Reads an array of <code>Object</code>s from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-  public static Object[] readObjectArray(DataInput in)
-    throws IOException, ClassNotFoundException {
+  public static Object[] readObjectArray(DataInput in) throws IOException, ClassNotFoundException {
-      InternalDataSerializer.checkIn(in);
+    InternalDataSerializer.checkIn(in);
-      int length = InternalDataSerializer.readArrayLength(in);
-      if (length == -1) {
-        return null;
-      } else {
-        Class<?> c = null;
-        byte typeCode = in.readByte();
-        String typeString = null;
-        if (typeCode == DSCODE.CLASS) {
-          typeString = readString(in);
-        }
-        
-        GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
-        boolean lookForPdxInstance = false;
-        ClassNotFoundException cnfEx = null;
-        if (typeCode == DSCODE.CLASS
-            && cache != null && cache.getPdxReadSerializedByAnyGemFireServices()) {
-          try {
-            c = InternalDataSerializer.getCachedClass(typeString);
-            lookForPdxInstance = true;
-          } catch (ClassNotFoundException ignore) {
-            c = Object.class;
-            cnfEx = ignore;
-          }
-        } else {
-          if (typeCode == DSCODE.CLASS) {
-            c = InternalDataSerializer.getCachedClass(typeString);
-          } else {
-            c = InternalDataSerializer.decodePrimitiveClass(typeCode);
-          }
-        }
-        Object o = null;
-        if (length > 0) {
-          o = readObject(in);
-          if (lookForPdxInstance && o instanceof PdxInstance) {
-            lookForPdxInstance = false;
-            c = Object.class;
-          }
-        }
-        Object[] array = (Object[]) Array.newInstance(c, length);
-        if (length > 0) {
-          array[0] = o;
-        }
-        for (int i = 1; i < length; i++) {
-          o = readObject(in);
-          if (lookForPdxInstance && o instanceof PdxInstance) {
-            // create an Object[] and copy all the entries we already did into it
-            lookForPdxInstance = false;
-            c = Object.class;
-            Object[] newArray = (Object[])Array.newInstance(c, length);
-            System.arraycopy(array, 0, newArray, 0, i);
-            array = newArray;
-          }
-          array[i] = o;
-        }
-        if (lookForPdxInstance && cnfEx != null && length > 0) {
-          // We have a non-empty array and didn't find any
-          // PdxInstances in it. So we should have been able
-          // to load the element type.
-          // Note that empty arrays in this case will deserialize
-          // as an Object[] since we can't tell if the element
-          // type is a pdx one.
-          throw cnfEx;
-        }
-
-        if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
-          logger.trace(LogMarker.SERIALIZER, "Read Object array of length {}", length);
-        }
-
-        return array;
+    int length = InternalDataSerializer.readArrayLength(in);
+    if (length == -1) {
+      return null;
+    } else {
+      Class<?> c = null;
+      byte typeCode = in.readByte();
+      String typeString = null;
+      if (typeCode == DSCODE.CLASS) {
+        typeString = readString(in);
+
+      GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
+      boolean lookForPdxInstance = false;
+      ClassNotFoundException cnfEx = null;
+      if (typeCode == DSCODE.CLASS && cache != null
+          && cache.getPdxReadSerializedByAnyGemFireServices()) {
+        try {
+          c = InternalDataSerializer.getCachedClass(typeString);
+          lookForPdxInstance = true;
+        } catch (ClassNotFoundException ignore) {
+          c = Object.class;
+          cnfEx = ignore;
+        }
+      } else {
+        if (typeCode == DSCODE.CLASS) {
+          c = InternalDataSerializer.getCachedClass(typeString);
+        } else {
+          c = InternalDataSerializer.decodePrimitiveClass(typeCode);
+        }
+      }
+      Object o = null;
+      if (length > 0) {
+        o = readObject(in);
+        if (lookForPdxInstance && o instanceof PdxInstance) {
+          lookForPdxInstance = false;
+          c = Object.class;
+        }
+      }
+      Object[] array = (Object[]) Array.newInstance(c, length);
+      if (length > 0) {
+        array[0] = o;
+      }
+      for (int i = 1; i < length; i++) {
+        o = readObject(in);
+        if (lookForPdxInstance && o instanceof PdxInstance) {
+          // create an Object[] and copy all the entries we already did into it
+          lookForPdxInstance = false;
+          c = Object.class;
+          Object[] newArray = (Object[]) Array.newInstance(c, length);
+          System.arraycopy(array, 0, newArray, 0, i);
+          array = newArray;
+        }
+        array[i] = o;
+      }
+      if (lookForPdxInstance && cnfEx != null && length > 0) {
+        // We have a non-empty array and didn't find any
+        // PdxInstances in it. So we should have been able
+        // to load the element type.
+        // Note that empty arrays in this case will deserialize
+        // as an Object[] since we can't tell if the element
+        // type is a pdx one.
+        throw cnfEx;
+      }
+
+      if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
+        logger.trace(LogMarker.SERIALIZER, "Read Object array of length {}", length);
+      }
+
+      return array;
-  
+  }
+
-   * @throws IOException
-   *         A problem occurs while writing to <tt>out</tt>.
+   * @throws IOException A problem occurs while writing to <tt>out</tt>.
-  public static void writeArrayOfByteArrays(byte[][] array, DataOutput out)
-  throws IOException {    
-    
+  public static void writeArrayOfByteArrays(byte[][] array, DataOutput out) throws IOException {
+
-    }
-    else {
+    } else {
-  
+
-   * Reads an array of <code>byte[]</code>s from a
-   * <code>DataInput</code>.
+   * Reads an array of <code>byte[]</code>s from a <code>DataInput</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-  throws IOException, ClassNotFoundException {
-    
+      throws IOException, ClassNotFoundException {
+
-    
+
-      
+
-      
+
-  
-  
+
+
-   * Writes an <code>ArrayList</code> to a <code>DataOutput</code>.
-   * Note that even though <code>list</code> may be an instance of a
-   * subclass of <code>ArrayList</code>, <code>readArrayList</code>
-   * will always return an instance of <code>ArrayList</code>,
-   * <B>not</B> an instance of the subclass.  To preserve the class
-   * type of <code>list</code>, {@link #writeObject(Object, DataOutput)} should be used
-   * for data serialization.
-   * This method will serialize a
-   * <code>null</code> list and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an <code>ArrayList</code> to a <code>DataOutput</code>. Note that even though
+   * <code>list</code> may be an instance of a subclass of <code>ArrayList</code>,
+   * <code>readArrayList</code> will always return an instance of <code>ArrayList</code>, <B>not</B>
+   * an instance of the subclass. To preserve the class type of <code>list</code>,
+   * {@link #writeObject(Object, DataOutput)} should be used for data serialization. This method
+   * will serialize a <code>null</code> list and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeArrayList(ArrayList<?> list, DataOutput out)
-    throws IOException {
+  public static void writeArrayList(ArrayList<?> list, DataOutput out) throws IOException {
-      for (int i=0; i < size; i++) {
+      for (int i = 0; i < size; i++) {
-  
-  
+
+
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
-   * @throws ClassNotFoundException
-   *         The class of one of the <Code>ArrayList</code>'s
-   *         elements cannot be found.
+   * @throws IOException A problem occurs while reading from <code>in</code>
+   * @throws ClassNotFoundException The class of one of the <Code>ArrayList</code>'s elements cannot
+   *         be found.
-    throws IOException, ClassNotFoundException {
+      throws IOException, ClassNotFoundException {
-   * Writes an <code>Vector</code> to a <code>DataOutput</code>.
-   * Note that even though <code>list</code> may be an instance of a
-   * subclass of <code>Vector</code>, <code>readVector</code>
-   * will always return an instance of <code>Vector</code>,
-   * <B>not</B> an instance of the subclass.  To preserve the class
-   * type of <code>list</code>, {@link #writeObject(Object, DataOutput)} should be used
-   * for data serialization.
+   * Writes an <code>Vector</code> to a <code>DataOutput</code>. Note that even though
+   * <code>list</code> may be an instance of a subclass of <code>Vector</code>,
+   * <code>readVector</code> will always return an instance of <code>Vector</code>, <B>not</B> an
+   * instance of the subclass. To preserve the class type of <code>list</code>,
+   * {@link #writeObject(Object, DataOutput)} should be used for data serialization.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeVector(Vector<?> list, DataOutput out)
-    throws IOException {
+  public static void writeVector(Vector<?> list, DataOutput out) throws IOException {
-      for (int i=0; i < size; i++) {
+      for (int i = 0; i < size; i++) {
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
-   * @throws ClassNotFoundException
-   *         The class of one of the <Code>Vector</code>'s
-   *         elements cannot be found.
+   * @throws IOException A problem occurs while reading from <code>in</code>
+   * @throws ClassNotFoundException The class of one of the <Code>Vector</code>'s elements cannot be
+   *         found.
-  public static <E> Vector<E> readVector(DataInput in)
-    throws IOException, ClassNotFoundException {
+  public static <E> Vector<E> readVector(DataInput in) throws IOException, ClassNotFoundException {
-   * Writes an <code>Stack</code> to a <code>DataOutput</code>.
-   * Note that even though <code>list</code> may be an instance of a
-   * subclass of <code>Stack</code>, <code>readStack</code>
-   * will always return an instance of <code>Stack</code>,
-   * <B>not</B> an instance of the subclass.  To preserve the class
-   * type of <code>list</code>, {@link #writeObject(Object, DataOutput)} should be used
-   * for data serialization.
+   * Writes an <code>Stack</code> to a <code>DataOutput</code>. Note that even though
+   * <code>list</code> may be an instance of a subclass of <code>Stack</code>,
+   * <code>readStack</code> will always return an instance of <code>Stack</code>, <B>not</B> an
+   * instance of the subclass. To preserve the class type of <code>list</code>,
+   * {@link #writeObject(Object, DataOutput)} should be used for data serialization.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeStack(Stack<?> list, DataOutput out)
-    throws IOException {
+  public static void writeStack(Stack<?> list, DataOutput out) throws IOException {
-      for (int i=0; i < size; i++) {
+      for (int i = 0; i < size; i++) {
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
-   * @throws ClassNotFoundException
-   *         The class of one of the <Code>Stack</code>'s
-   *         elements cannot be found.
+   * @throws IOException A problem occurs while reading from <code>in</code>
+   * @throws ClassNotFoundException The class of one of the <Code>Stack</code>'s elements cannot be
+   *         found.
-  public static <E> Stack<E> readStack(DataInput in)
-    throws IOException, ClassNotFoundException {
+  public static <E> Stack<E> readStack(DataInput in) throws IOException, ClassNotFoundException {
-   * Writes an <code>LinkedList</code> to a <code>DataOutput</code>.
-   * Note that even though <code>list</code> may be an instance of a
-   * subclass of <code>LinkedList</code>, <code>readLinkedList</code>
-   * will always return an instance of <code>LinkedList</code>,
-   * <B>not</B> an instance of the subclass.  To preserve the class
-   * type of <code>list</code>, {@link #writeObject(Object, DataOutput)} should be used
-   * for data serialization.
-   * This method will serialize a
-   * <code>null</code> list and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an <code>LinkedList</code> to a <code>DataOutput</code>. Note that even though
+   * <code>list</code> may be an instance of a subclass of <code>LinkedList</code>,
+   * <code>readLinkedList</code> will always return an instance of <code>LinkedList</code>,
+   * <B>not</B> an instance of the subclass. To preserve the class type of <code>list</code>,
+   * {@link #writeObject(Object, DataOutput)} should be used for data serialization. This method
+   * will serialize a <code>null</code> list and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeLinkedList(LinkedList<?> list, DataOutput out)
-    throws IOException {
+  public static void writeLinkedList(LinkedList<?> list, DataOutput out) throws IOException {
-      for (Object e: list) {
+      for (Object e : list) {
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
-   * @throws ClassNotFoundException
-   *         The class of one of the <Code>LinkedList</code>'s
-   *         elements cannot be found.
+   * @throws IOException A problem occurs while reading from <code>in</code>
+   * @throws ClassNotFoundException The class of one of the <Code>LinkedList</code>'s elements
+   *         cannot be found.
-    throws IOException, ClassNotFoundException {
+      throws IOException, ClassNotFoundException {
-   * Writes a <code>HashSet</code> to a <code>DataOutput</code>.  Note
-   * that even though <code>set</code> may be an instance of a
-   * subclass of <code>HashSet</code>, <code>readHashSet</code> will
-   * always return an instance of <code>HashSet</code>, <B>not</B> an
-   * instance of the subclass.  To preserve the class type of
-   * <code>set</code>, {@link #writeObject(Object, DataOutput)} should be used for data
-   * serialization.
-   * This method will serialize a
-   * <code>null</code> set and not throw a
-   * <code>NullPointerException</code>.
+   * Writes a <code>HashSet</code> to a <code>DataOutput</code>. Note that even though
+   * <code>set</code> may be an instance of a subclass of <code>HashSet</code>,
+   * <code>readHashSet</code> will always return an instance of <code>HashSet</code>, <B>not</B> an
+   * instance of the subclass. To preserve the class type of <code>set</code>,
+   * {@link #writeObject(Object, DataOutput)} should be used for data serialization. This method
+   * will serialize a <code>null</code> set and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeHashSet(HashSet<?> set, DataOutput out)
-    throws IOException {
+  public static void writeHashSet(HashSet<?> set, DataOutput out) throws IOException {
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
-   * @throws ClassNotFoundException
-   *         The class of one of the <Code>HashSet</code>'s
-   *         elements cannot be found.
+   * @throws IOException A problem occurs while reading from <code>in</code>
+   * @throws ClassNotFoundException The class of one of the <Code>HashSet</code>'s elements cannot
+   *         be found.
-    throws IOException, ClassNotFoundException {
+      throws IOException, ClassNotFoundException {
-   * Writes a <code>LinkedHashSet</code> to a <code>DataOutput</code>.  Note
-   * that even though <code>set</code> may be an instance of a
-   * subclass of <code>LinkedHashSet</code>, <code>readLinkedHashSet</code> will
-   * always return an instance of <code>LinkedHashSet</code>, <B>not</B> an
-   * instance of the subclass.  To preserve the class type of
-   * <code>set</code>, {@link #writeObject(Object, DataOutput)} should be used for data
-   * serialization.
+   * Writes a <code>LinkedHashSet</code> to a <code>DataOutput</code>. Note that even though
+   * <code>set</code> may be an instance of a subclass of <code>LinkedHashSet</code>,
+   * <code>readLinkedHashSet</code> will always return an instance of <code>LinkedHashSet</code>,
+   * <B>not</B> an instance of the subclass. To preserve the class type of <code>set</code>,
+   * {@link #writeObject(Object, DataOutput)} should be used for data serialization.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeLinkedHashSet(LinkedHashSet<?> set, DataOutput out)
-    throws IOException {
+  public static void writeLinkedHashSet(LinkedHashSet<?> set, DataOutput out) throws IOException {
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
-   * @throws ClassNotFoundException
-   *         The class of one of the <Code>LinkedHashSet</code>'s
-   *         elements cannot be found.
+   * @throws IOException A problem occurs while reading from <code>in</code>
+   * @throws ClassNotFoundException The class of one of the <Code>LinkedHashSet</code>'s elements
+   *         cannot be found.
-    throws IOException, ClassNotFoundException {
+      throws IOException, ClassNotFoundException {
-   * Writes a <code>HashMap</code> to a <code>DataOutput</code>.  Note
-   * that even though <code>map</code> may be an instance of a
-   * subclass of <code>HashMap</code>, <code>readHashMap</code> will
-   * always return an instance of <code>HashMap</code>, <B>not</B> an
-   * instance of the subclass.  To preserve the class type of
-   * <code>map</code>, {@link #writeObject(Object, DataOutput)} should be used for data
-   * serialization.
-   * This method will serialize a
-   * <code>null</code> map and not throw a
-   * <code>NullPointerException</code>.
+   * Writes a <code>HashMap</code> to a <code>DataOutput</code>. Note that even though
+   * <code>map</code> may be an instance of a subclass of <code>HashMap</code>,
+   * <code>readHashMap</code> will always return an instance of <code>HashMap</code>, <B>not</B> an
+   * instance of the subclass. To preserve the class type of <code>map</code>,
+   * {@link #writeObject(Object, DataOutput)} should be used for data serialization. This method
+   * will serialize a <code>null</code> map and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeHashMap(Map<?,?> map, DataOutput out)
-    throws IOException {
+  public static void writeHashMap(Map<?, ?> map, DataOutput out) throws IOException {
-      for (Map.Entry<?,?> entry: map.entrySet()) {
+      for (Map.Entry<?, ?> entry : map.entrySet()) {
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
-   * @throws ClassNotFoundException
-   *         The class of one of the <Code>HashMap</code>'s
-   *         elements cannot be found.
+   * @throws IOException A problem occurs while reading from <code>in</code>
+   * @throws ClassNotFoundException The class of one of the <Code>HashMap</code>'s elements cannot
+   *         be found.
-  public static <K,V> HashMap<K,V> readHashMap(DataInput in)
-    throws IOException, ClassNotFoundException {
+  public static <K, V> HashMap<K, V> readHashMap(DataInput in)
+      throws IOException, ClassNotFoundException {
-      HashMap<K,V> map = new HashMap<K,V>(size);
+      HashMap<K, V> map = new HashMap<K, V>(size);
-   * Writes a <code>IdentityHashMap</code> to a <code>DataOutput</code>.  Note
-   * that even though <code>map</code> may be an instance of a
-   * subclass of <code>IdentityHashMap</code>, <code>readIdentityHashMap</code> will
-   * always return an instance of <code>IdentityHashMap</code>, <B>not</B> an
-   * instance of the subclass.  To preserve the class type of
-   * <code>map</code>, {@link #writeObject(Object, DataOutput)} should be used for data
+   * Writes a <code>IdentityHashMap</code> to a <code>DataOutput</code>. Note that even though
+   * <code>map</code> may be an instance of a subclass of <code>IdentityHashMap</code>,
+   * <code>readIdentityHashMap</code> will always return an instance of
+   * <code>IdentityHashMap</code>, <B>not</B> an instance of the subclass. To preserve the class
+   * type of <code>map</code>, {@link #writeObject(Object, DataOutput)} should be used for data
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeIdentityHashMap(IdentityHashMap<?,?> map, DataOutput out)
-    throws IOException {
+  public static void writeIdentityHashMap(IdentityHashMap<?, ?> map, DataOutput out)
+      throws IOException {
-      for (Map.Entry<?,?> entry: map.entrySet()){
+      for (Map.Entry<?, ?> entry : map.entrySet()) {
-   * Reads a <code>IdentityHashMap</code> from a <code>DataInput</code>.
-   * Note that key identity is not preserved unless the keys belong to a class
-   * whose serialization preserves identity.
+   * Reads a <code>IdentityHashMap</code> from a <code>DataInput</code>. Note that key identity is
+   * not preserved unless the keys belong to a class whose serialization preserves identity.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
-   * @throws ClassNotFoundException
-   *         The class of one of the <Code>IdentityHashMap</code>'s
-   *         elements cannot be found.
+   * @throws IOException A problem occurs while reading from <code>in</code>
+   * @throws ClassNotFoundException The class of one of the <Code>IdentityHashMap</code>'s elements
+   *         cannot be found.
-  public static <K,V> IdentityHashMap<K,V> readIdentityHashMap(DataInput in)
-    throws IOException, ClassNotFoundException {
+  public static <K, V> IdentityHashMap<K, V> readIdentityHashMap(DataInput in)
+      throws IOException, ClassNotFoundException {
-      IdentityHashMap<K,V> map = new IdentityHashMap<K,V>(size);
+      IdentityHashMap<K, V> map = new IdentityHashMap<K, V>(size);
-   * Writes a <code>ConcurrentHashMap</code> to a <code>DataOutput</code>.  Note
-   * that even though <code>map</code> may be an instance of a
-   * subclass of <code>ConcurrentHashMap</code>, <code>readConcurrentHashMap</code> will
-   * always return an instance of <code>ConcurrentHashMap</code>, <B>not</B> an
-   * instance of the subclass.  To preserve the class type of
-   * <code>map</code>, {@link #writeObject(Object, DataOutput)} should be used for data
+   * Writes a <code>ConcurrentHashMap</code> to a <code>DataOutput</code>. Note that even though
+   * <code>map</code> may be an instance of a subclass of <code>ConcurrentHashMap</code>,
+   * <code>readConcurrentHashMap</code> will always return an instance of
+   * <code>ConcurrentHashMap</code>, <B>not</B> an instance of the subclass. To preserve the class
+   * type of <code>map</code>, {@link #writeObject(Object, DataOutput)} should be used for data
-   * <P>At this time if {@link #writeObject(Object, DataOutput)} is called with an instance
-   * of ConcurrentHashMap then it will be serialized with normal java.io Serialization. So
-   * if you want the keys and values of a ConcurrentHashMap to take advantage of GemFire serialization
-   * it must be serialized with this method.
+   * <P>
+   * At this time if {@link #writeObject(Object, DataOutput)} is called with an instance of
+   * ConcurrentHashMap then it will be serialized with normal java.io Serialization. So if you want
+   * the keys and values of a ConcurrentHashMap to take advantage of GemFire serialization it must
+   * be serialized with this method.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeConcurrentHashMap(ConcurrentHashMap<?,?> map, DataOutput out)
-    throws IOException {
+  public static void writeConcurrentHashMap(ConcurrentHashMap<?, ?> map, DataOutput out)
+      throws IOException {
-    Collection<Map.Entry<?,?>> entrySnapshot = null;
+    Collection<Map.Entry<?, ?>> entrySnapshot = null;
-      entrySnapshot = new ArrayList<Map.Entry<?,?>>(map.entrySet());
+      entrySnapshot = new ArrayList<Map.Entry<?, ?>>(map.entrySet());
-      logger.trace(LogMarker.SERIALIZER, "Writing ConcurrentHashMap with {} elements: {}", size, entrySnapshot);
+      logger.trace(LogMarker.SERIALIZER, "Writing ConcurrentHashMap with {} elements: {}", size,
+          entrySnapshot);
-      for (Map.Entry<?,?> entry: entrySnapshot) {
+      for (Map.Entry<?, ?> entry : entrySnapshot) {
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
-   * @throws ClassNotFoundException
-   *         The class of one of the <Code>ConcurrentHashMap</code>'s
+   * @throws IOException A problem occurs while reading from <code>in</code>
+   * @throws ClassNotFoundException The class of one of the <Code>ConcurrentHashMap</code>'s
-  public static <K,V> ConcurrentHashMap<K,V> readConcurrentHashMap(DataInput in)
-    throws IOException, ClassNotFoundException {
+  public static <K, V> ConcurrentHashMap<K, V> readConcurrentHashMap(DataInput in)
+      throws IOException, ClassNotFoundException {
-      ConcurrentHashMap<K,V> map = new ConcurrentHashMap<K,V>(size);
+      ConcurrentHashMap<K, V> map = new ConcurrentHashMap<K, V>(size);
-        logger.trace(LogMarker.SERIALIZER, "Read ConcurrentHashMap with {} elements: {}", size, map);
+        logger.trace(LogMarker.SERIALIZER, "Read ConcurrentHashMap with {} elements: {}", size,
+            map);
-   * Writes a <code>Hashtable</code> to a <code>DataOutput</code>.  Note
-   * that even though <code>map</code> may be an instance of a
-   * subclass of <code>Hashtable</code>, <code>readHashtable</code> will
-   * always return an instance of <code>Hashtable</code>, <B>not</B> an
-   * instance of the subclass.  To preserve the class type of
-   * <code>map</code>, {@link #writeObject(Object, DataOutput)} should be used for data
-   * serialization.
+   * Writes a <code>Hashtable</code> to a <code>DataOutput</code>. Note that even though
+   * <code>map</code> may be an instance of a subclass of <code>Hashtable</code>,
+   * <code>readHashtable</code> will always return an instance of <code>Hashtable</code>, <B>not</B>
+   * an instance of the subclass. To preserve the class type of <code>map</code>,
+   * {@link #writeObject(Object, DataOutput)} should be used for data serialization.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeHashtable(Hashtable<?,?> map, DataOutput out)
-    throws IOException {
+  public static void writeHashtable(Hashtable<?, ?> map, DataOutput out) throws IOException {
-      for (Map.Entry<?,?> entry: map.entrySet()) {
+      for (Map.Entry<?, ?> entry : map.entrySet()) {
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
-   * @throws ClassNotFoundException
-   *         The class of one of the <Code>Hashtable</code>'s
-   *         elements cannot be found.
+   * @throws IOException A problem occurs while reading from <code>in</code>
+   * @throws ClassNotFoundException The class of one of the <Code>Hashtable</code>'s elements cannot
+   *         be found.
-  public static <K,V> Hashtable<K,V> readHashtable(DataInput in)
-    throws IOException, ClassNotFoundException {
+  public static <K, V> Hashtable<K, V> readHashtable(DataInput in)
+      throws IOException, ClassNotFoundException {
-      Hashtable<K,V> map = new Hashtable<K,V>(size);
+      Hashtable<K, V> map = new Hashtable<K, V>(size);
-   * Writes a <code>TreeMap</code> to a <code>DataOutput</code>.  Note
-   * that even though <code>map</code> may be an instance of a
-   * subclass of <code>TreeMap</code>, <code>readTreeMap</code> will
-   * always return an instance of <code>TreeMap</code>, <B>not</B> an
-   * instance of the subclass.  To preserve the class type of
-   * <code>map</code>, {@link #writeObject(Object, DataOutput)} should be used for data
-   * serialization.
-   * <p>If the map has a comparator then it must also be serializable.
+   * Writes a <code>TreeMap</code> to a <code>DataOutput</code>. Note that even though
+   * <code>map</code> may be an instance of a subclass of <code>TreeMap</code>,
+   * <code>readTreeMap</code> will always return an instance of <code>TreeMap</code>, <B>not</B> an
+   * instance of the subclass. To preserve the class type of <code>map</code>,
+   * {@link #writeObject(Object, DataOutput)} should be used for data serialization.
+   * <p>
+   * If the map has a comparator then it must also be serializable.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeTreeMap(TreeMap<?,?> map, DataOutput out)
-    throws IOException {
+  public static void writeTreeMap(TreeMap<?, ?> map, DataOutput out) throws IOException {
-      for (Map.Entry<?,?> entry: map.entrySet()) {
+      for (Map.Entry<?, ?> entry : map.entrySet()) {
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
-   * @throws ClassNotFoundException
-   *         The class of one of the <Code>TreeMap</code>'s
-   *         elements cannot be found.
+   * @throws IOException A problem occurs while reading from <code>in</code>
+   * @throws ClassNotFoundException The class of one of the <Code>TreeMap</code>'s elements cannot
+   *         be found.
-  public static <K,V> TreeMap<K,V> readTreeMap(DataInput in)
-    throws IOException, ClassNotFoundException {
+  public static <K, V> TreeMap<K, V> readTreeMap(DataInput in)
+      throws IOException, ClassNotFoundException {
-      Comparator<? super K> c = InternalDataSerializer.<Comparator<? super K>>readNonPdxInstanceObject(in);
-      TreeMap<K,V> map = new TreeMap<K,V>(c);
+      Comparator<? super K> c =
+          InternalDataSerializer.<Comparator<? super K>>readNonPdxInstanceObject(in);
+      TreeMap<K, V> map = new TreeMap<K, V>(c);
-   * Writes a <code>TreeSet</code> to a <code>DataOutput</code>.  Note
-   * that even though <code>set</code> may be an instance of a
-   * subclass of <code>TreeSet</code>, <code>readTreeSet</code> will
-   * always return an instance of <code>TreeSet</code>, <B>not</B> an
-   * instance of the subclass.  To preserve the class type of
-   * <code>set</code>, {@link #writeObject(Object, DataOutput)} should be used for data
-   * serialization.
-   * <p>If the set has a comparator then it must also be serializable.
+   * Writes a <code>TreeSet</code> to a <code>DataOutput</code>. Note that even though
+   * <code>set</code> may be an instance of a subclass of <code>TreeSet</code>,
+   * <code>readTreeSet</code> will always return an instance of <code>TreeSet</code>, <B>not</B> an
+   * instance of the subclass. To preserve the class type of <code>set</code>,
+   * {@link #writeObject(Object, DataOutput)} should be used for data serialization.
+   * <p>
+   * If the set has a comparator then it must also be serializable.
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeTreeSet(TreeSet<?> set, DataOutput out)
-    throws IOException {
+  public static void writeTreeSet(TreeSet<?> set, DataOutput out) throws IOException {
-    
+
-      for (Object e: set) {
+      for (Object e : set) {
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
-   * @throws ClassNotFoundException
-   *         The class of one of the <Code>TreeSet</code>'s
-   *         elements cannot be found.
+   * @throws IOException A problem occurs while reading from <code>in</code>
+   * @throws ClassNotFoundException The class of one of the <Code>TreeSet</code>'s elements cannot
+   *         be found.
-    throws IOException, ClassNotFoundException {
+      throws IOException, ClassNotFoundException {
-      Comparator<? super E> c = InternalDataSerializer.<Comparator<? super E>>readNonPdxInstanceObject(in);
+      Comparator<? super E> c =
+          InternalDataSerializer.<Comparator<? super E>>readNonPdxInstanceObject(in);
-   * <P> NOTE: The <code>defaults</code> of the specified <code>props</code>
-   * are not serialized.
-   * <p> Note that even though <code>props</code> may be an instance of a
-   * subclass of <code>Properties</code>, <code>readProperties</code> will
-   * always return an instance of <code>Properties</code>, <B>not</B> an
-   * instance of the subclass.  To preserve the class type of
+   * <P>
+   * NOTE: The <code>defaults</code> of the specified <code>props</code> are not serialized.
+   * <p>
+   * Note that even though <code>props</code> may be an instance of a subclass of
+   * <code>Properties</code>, <code>readProperties</code> will always return an instance of
+   * <code>Properties</code>, <B>not</B> an instance of the subclass. To preserve the class type of
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
+   * @throws IOException A problem occurs while writing to <code>out</code>
-  public static void writeProperties(Properties props, DataOutput out)
-      throws IOException {
+  public static void writeProperties(Properties props, DataOutput out) throws IOException {
-    Set<Map.Entry<Object,Object>> s;
+    Set<Map.Entry<Object, Object>> s;
-      for (Map.Entry<Object,Object> entry: s) {
+      for (Map.Entry<Object, Object> entry : s) {
-   * <P> NOTE: the <code>defaults</code> are always empty in the returned <code>Properties</code>.
+   * <P>
+   * NOTE: the <code>defaults</code> are always empty in the returned <code>Properties</code>.
-   * @throws IOException
-   *         A problem occurs while reading from <code>in</code>
+   * @throws IOException A problem occurs while reading from <code>in</code>
-  public static Properties readProperties(DataInput in) throws IOException,
-      ClassNotFoundException {
+  public static Properties readProperties(DataInput in) throws IOException, ClassNotFoundException {
-    }
-    else {
+    } else {
-   * Writes an arbitrary object to a <code>DataOutput</code>.  If
-   * <code>o</code> is not an instance of a specially-handled
-   * standard Java class (see the list in {@link #getSupportedClasses}),
-   * the {@link DataSerializer#toData toData} method of each
-   * registered <code>DataSerializer</code> is invoked until the object
-   * is serialized.  If no registered serializer can serialize the
-   * object and <code>o</code> does not implement
-   * <code>DataSerializable</code>, then it is serialized to
-   * <code>out</code> using standard Java {@linkplain
-   * java.io.Serializable serialization}.
-   * This method will serialize a
-   * <code>null</code> o and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an arbitrary object to a <code>DataOutput</code>. If <code>o</code> is not an instance
+   * of a specially-handled standard Java class (see the list in {@link #getSupportedClasses}), the
+   * {@link DataSerializer#toData toData} method of each registered <code>DataSerializer</code> is
+   * invoked until the object is serialized. If no registered serializer can serialize the object
+   * and <code>o</code> does not implement <code>DataSerializable</code>, then it is serialized to
+   * <code>out</code> using standard Java {@linkplain java.io.Serializable serialization}. This
+   * method will serialize a <code>null</code> o and not throw a <code>NullPointerException</code>.
-   * @param allowJavaSerialization
-   *        If false, then a NotSerializableException is thrown
-   *        in the case where standard Java serialization would
-   *        otherwise be used for object <code>o</code> or for any nested
-   *        subobject of <code>o</code>. This is used to prevent
-   *        Java serialization from being used when sending data
-   *        to a non-Java client
-   * @throws IOException
-   *         A problem occurs while writing <code>o</code> to
-   *         <code>out</code>
+   * @param allowJavaSerialization If false, then a NotSerializableException is thrown in the case
+   *        where standard Java serialization would otherwise be used for object <code>o</code> or
+   *        for any nested subobject of <code>o</code>. This is used to prevent Java serialization
+   *        from being used when sending data to a non-Java client
+   * @throws IOException A problem occurs while writing <code>o</code> to <code>out</code>
-    throws IOException {
-    
-      if (allowJavaSerialization) {
-        writeObject(o, out);
-        return;
-      }
+      throws IOException {
-      DISALLOW_JAVA_SERIALIZATION.set(Boolean.TRUE);
-      try {
-        writeObject(o, out);
-      } finally {
-        DISALLOW_JAVA_SERIALIZATION.set(Boolean.FALSE); // with JDK 1.5 this can be changed to remove()
-      }
+    if (allowJavaSerialization) {
+      writeObject(o, out);
+      return;
+    }
+
+    DISALLOW_JAVA_SERIALIZATION.set(Boolean.TRUE);
+    try {
+      writeObject(o, out);
+    } finally {
+      DISALLOW_JAVA_SERIALIZATION.set(Boolean.FALSE); // with JDK 1.5 this can be changed to
+                                                      // remove()
+    }
-   * Writes an arbitrary object to a <code>DataOutput</code>.  If
-   * <code>o</code> is not an instance of a specially-handled
-   * standard Java class (such as <code>Date</code>,
-   * <code>Integer</code>, or <code>ArrayList</code>), the {@link
-   * DataSerializer#toData toData} method of each
-   * registered <code>DataSerializer</code> is invoked until the object
-   * is serialized.  If no registered serializer can serialize the
-   * object and <code>o</code> does not implement
-   * <code>DataSerializable</code>, then it is serialized to
-   * <code>out</code> using standard Java {@linkplain
-   * java.io.Serializable serialization}.
-   * This method will serialize a
-   * <code>null</code> o and not throw a
-   * <code>NullPointerException</code>.
+   * Writes an arbitrary object to a <code>DataOutput</code>. If <code>o</code> is not an instance
+   * of a specially-handled standard Java class (such as <code>Date</code>, <code>Integer</code>, or
+   * <code>ArrayList</code>), the {@link DataSerializer#toData toData} method of each registered
+   * <code>DataSerializer</code> is invoked until the object is serialized. If no registered
+   * serializer can serialize the object and <code>o</code> does not implement
+   * <code>DataSerializable</code>, then it is serialized to <code>out</code> using standard Java
+   * {@linkplain java.io.Serializable serialization}. This method will serialize a <code>null</code>
+   * o and not throw a <code>NullPointerException</code>.
-   * @throws IOException
-   *         A problem occurs while writing <code>o</code> to
-   *         <code>out</code>
+   * @throws IOException A problem occurs while writing <code>o</code> to <code>out</code>
-  public static final void writeObject(Object o, DataOutput out)
-    throws IOException {
+  public static final void writeObject(Object o, DataOutput out) throws IOException {
-   * Reads an arbitrary object from a <code>DataInput</code>.
-   * Instances of classes that are not handled specially (such as
-   * <code>String</code>, <code>Class</code>, and
-   * <code>DataSerializable</code>) are read using standard Java
-   * {@linkplain java.io.Serializable serialization}.
+   * Reads an arbitrary object from a <code>DataInput</code>. Instances of classes that are not
+   * handled specially (such as <code>String</code>, <code>Class</code>, and
+   * <code>DataSerializable</code>) are read using standard Java {@linkplain java.io.Serializable
+   * serialization}.
-   * Note that if an object is deserialized using standard Java
-   * serialization, its class will be loaded using the current
-   * thread's {@link Thread#getContextClassLoader context class
-   * loader} before the one normally used by Java serialization is
-   * consulted.
+   * Note that if an object is deserialized using standard Java serialization, its class will be
+   * loaded using the current thread's {@link Thread#getContextClassLoader context class loader}
+   * before the one normally used by Java serialization is consulted.
-   * @throws IOException
-   *         A problem occured while reading from <code>in</code>
-   *        (may wrap another exception)
-   * @throws ClassNotFoundException
-   *         The class of an object read from <code>in</code> could
-   *         not be found
+   * @throws IOException A problem occured while reading from <code>in</code> (may wrap another
+   *         exception)
+   * @throws ClassNotFoundException The class of an object read from <code>in</code> could not be
+   *         found
-    throws IOException, ClassNotFoundException {
+      throws IOException, ClassNotFoundException {
-   * Registers a <code>DataSerializer</code>  class with the data
-   * serialization framework.  This method uses reflection to create
-   * an instance of the <code>DataSerializer</code> class by invoking
-   * its zero-argument constructor.
+   * Registers a <code>DataSerializer</code> class with the data serialization framework. This
+   * method uses reflection to create an instance of the <code>DataSerializer</code> class by
+   * invoking its zero-argument constructor.
-   * {@link #writeObject(Object, DataOutput)} and {@link #readObject} methods.
-   * Note that no two serializers can support the same class.
+   * {@link #writeObject(Object, DataOutput)} and {@link #readObject} methods. Note that no two
+   * serializers can support the same class.
-   * This method invokes the <Code>DataSerializer</code> instance's
-   * {@link #getSupportedClasses} method and keeps track of which
-   * classes can have their instances serialized by by this data serializer.
+   * This method invokes the <Code>DataSerializer</code> instance's {@link #getSupportedClasses}
+   * method and keeps track of which classes can have their instances serialized by by this data
+   * serializer.
-   * @param c
-   *        the <code>DataSerializer</code> class to create and
-   *        register with the data serialization framework.
-   * @return the registered serializer instance 
+   * @param c the <code>DataSerializer</code> class to create and register with the data
+   *        serialization framework.
+   * @return the registered serializer instance
-   * @throws IllegalArgumentException
-   *         If <code>c</code> does not subclass
-   *         <code>DataSerializer</code>, if <code>c</code> does not
-   *         have a zero-argument constructor,
-   *         if <code>id</code> is 0,
-   *         if getSupportedClasses returns null or an empty array,
-   *         if getSupportedClasses returns and array with null elements
-   * @throws IllegalStateException
-   *         if another serializer
-   *         instance with id <code>id</code> has already been registered,
-   *         if another serializer instance that supports one of this instances
-   *         classes has already been registered,
-   *         if an attempt is made to support any of the classes reserved by DataSerializer
-   *         (see {@link #getSupportedClasses} for a list).
+   * @throws IllegalArgumentException If <code>c</code> does not subclass
+   *         <code>DataSerializer</code>, if <code>c</code> does not have a zero-argument
+   *         constructor, if <code>id</code> is 0, if getSupportedClasses returns null or an empty
+   *         array, if getSupportedClasses returns and array with null elements
+   * @throws IllegalStateException if another serializer instance with id <code>id</code> has
+   *         already been registered, if another serializer instance that supports one of this
+   *         instances classes has already been registered, if an attempt is made to support any of
+   *         the classes reserved by DataSerializer (see {@link #getSupportedClasses} for a list).
+
-  ///////////////////////  Constructors  ///////////////////////
+  /////////////////////// Constructors ///////////////////////
-   * Creates a new <code>DataSerializer</code>.  All class that
-   * implement <code>DataSerializer</code> must provide a
-   * zero-argument constructor.
+   * Creates a new <code>DataSerializer</code>. All class that implement <code>DataSerializer</code>
+   * must provide a zero-argument constructor.
-  /////////////////////  Instance Methods  /////////////////////
+  ///////////////////// Instance Methods /////////////////////
-   * Returns the <code>Class</code>es whose instances are data
-   * serialized by this <code>DataSerializer</code>.  This method is
-   * invoked when this serializer is {@linkplain #register(Class)
-   * registered}. This method is not allowed to return <code>null</code>
-   * nor an empty array.
-   * Only instances whose class name is the same as one of the class names
-   * in the result will be serialized by this <code>DataSerializer</code>.
-   * Two <code>DataSerializer</code>s are not allowed to support the same class.
-   * The following classes can not be supported by user defined data serializers
-   * since they are all supported by the predefined data serializer:
+   * Returns the <code>Class</code>es whose instances are data serialized by this
+   * <code>DataSerializer</code>. This method is invoked when this serializer is
+   * {@linkplain #register(Class) registered}. This method is not allowed to return
+   * <code>null</code> nor an empty array. Only instances whose class name is the same as one of the
+   * class names in the result will be serialized by this <code>DataSerializer</code>. Two
+   * <code>DataSerializer</code>s are not allowed to support the same class. The following classes
+   * can not be supported by user defined data serializers since they are all supported by the
+   * predefined data serializer:
-   * Data serializes an object to a <code>DataOutput</code>.  It is
-   * very important that when performing the "switch" on
-   * <code>o</code>'s class, your code test for a subclass before it
-   * tests for a superclass.  Otherwise, the incorrect class id could
-   * be written to the serialization stream.
+   * Data serializes an object to a <code>DataOutput</code>. It is very important that when
+   * performing the "switch" on <code>o</code>'s class, your code test for a subclass before it
+   * tests for a superclass. Otherwise, the incorrect class id could be written to the serialization
+   * stream.
-   * @param o
-   *        The object to data serialize.  It will never be
-   *        <code>null</code>.
+   * @param o The object to data serialize. It will never be <code>null</code>.
-   * @return <code>false</code> if this <code>DataSerializer</code> does
-   *         not know how to data serialize <code>o</code>.
+   * @return <code>false</code> if this <code>DataSerializer</code> does not know how to data
+   *         serialize <code>o</code>.
-  public abstract boolean toData(Object o, DataOutput out)
-    throws IOException;
+  public abstract boolean toData(Object o, DataOutput out) throws IOException;
-   * Reads an object from a <code>DataInput</code>.
-   * This implementation must support deserializing everything serialized by
-   * the matching {@link #toData}.
+   * Reads an object from a <code>DataInput</code>. This implementation must support deserializing
+   * everything serialized by the matching {@link #toData}.
-   * @throws IOException
-   *         If this serializer cannot read an object from
-   *         <code>in</code>.
+   * @throws IOException If this serializer cannot read an object from <code>in</code>.
-  public abstract Object fromData(DataInput in)
-    throws IOException, ClassNotFoundException;
+  public abstract Object fromData(DataInput in) throws IOException, ClassNotFoundException;
-   * <p> Returns an int instead of a byte since 5.7.
+   * <p>
+   * Returns an int instead of a byte since 5.7.
-   * Two <code>DataSerializer</code>s are consider to be equal if they
-   * have the same id and the same class
+   * Two <code>DataSerializer</code>s are consider to be equal if they have the same id and the same
+   * class
-      DataSerializer oDS = (DataSerializer)o;
+      DataSerializer oDS = (DataSerializer) o;
+
-  
+
-   * For internal use only.
-   * Sets the unique <code>eventId</code> of this
-   * <code>DataSerializer</code>. 
-   * @since GemFire 6.5
-   */
-  public final void setEventId(Object/*EventID*/ eventId) {
-    this.eventId = (EventID)eventId;
-  }
-  
-  /**
-   * For internal use only.
-   * Returns the unique <code>eventId</code> of this
+   * For internal use only. Sets the unique <code>eventId</code> of this
+   * 
-  public final Object/*EventID*/ getEventId() {
+  public final void setEventId(Object/* EventID */ eventId) {
+    this.eventId = (EventID) eventId;
+  }
+
+  /**
+   * For internal use only. Returns the unique <code>eventId</code> of this
+   * <code>DataSerializer</code>.
+   * 
+   * @since GemFire 6.5
+   */
+  public final Object/* EventID */ getEventId() {
-  
+
-   * For internal use only.
-   * Sets the context of this
-   * <code>DataSerializer</code>. 
+   * For internal use only. Sets the context of this <code>DataSerializer</code>.
+   * 
-  public final void setContext(Object/*ClientProxyMembershipID*/ context) {
-    this.context = (ClientProxyMembershipID)context;
+  public final void setContext(Object/* ClientProxyMembershipID */ context) {
+    this.context = (ClientProxyMembershipID) context;
-  
+
-   * For internal use only.
-   * Returns the context of this
-   * <code>DataSerializer</code>.
+   * For internal use only. Returns the context of this <code>DataSerializer</code>.
+   * 
-  public final Object/*ClientProxyMembershipID*/ getContext() {
+  public final Object/* ClientProxyMembershipID */ getContext() {
-  
+
-   * gets the enum constants for the given class.
-   * {@link Class#getEnumConstants()} uses reflection, so we keep around the
-   * class to enumConstants mapping in the {@link #knownEnums} map
+   * gets the enum constants for the given class. {@link Class#getEnumConstants()} uses reflection,
+   * so we keep around the class to enumConstants mapping in the {@link #knownEnums} map
-    E[] returnVal = (E[])knownEnums.get(clazz);
+    E[] returnVal = (E[]) knownEnums.get(clazz);
-   * Writes the <code>Enum constant</code> to <code>DataOutput</code>. Unlike
-   * standard java serialization which serializes both the enum name String and
-   * the ordinal, GemFire only serializes the ordinal byte, so for backward
-   * compatibility new enum constants should only be added to the end of the
-   * enum type.<br />
+   * Writes the <code>Enum constant</code> to <code>DataOutput</code>. Unlike standard java
+   * serialization which serializes both the enum name String and the ordinal, GemFire only
+   * serializes the ordinal byte, so for backward compatibility new enum constants should only be
+   * added to the end of the enum type.<br />
-          LocalizedStrings.DataSerializer_ENUM_TO_SERIALIZE_IS_NULL
-              .toLocalizedString());
+          LocalizedStrings.DataSerializer_ENUM_TO_SERIALIZE_IS_NULL.toLocalizedString());
-   * Reads a <code>Enum constant</code> from <code>DataInput</code>. Unlike
-   * standard java serialization which serializes both the enum name String and
-   * the ordinal, GemFire only serializes the ordinal byte, so be careful about
-   * using the correct enum class. Also, for backward compatibility new enum
-   * constants should only be added to the end of the enum type.<br />
-   * Example:
-   * <code>DAY_OF_WEEK d = DataSerializer.readEnum(DAY_OF_WEEK.class, in);</code>
+   * Reads a <code>Enum constant</code> from <code>DataInput</code>. Unlike standard java
+   * serialization which serializes both the enum name String and the ordinal, GemFire only
+   * serializes the ordinal byte, so be careful about using the correct enum class. Also, for
+   * backward compatibility new enum constants should only be added to the end of the enum
+   * type.<br />
+   * Example: <code>DAY_OF_WEEK d = DataSerializer.readEnum(DAY_OF_WEEK.class, in);</code>
-   * @throws IOException
-   *           A problem occurs while writing to <code>out</code>
-   * @throws ArrayIndexOutOfBoundsException
-   *           if the wrong enum class/enum class with a different version and
-   *           less enum constants is used
+   * @throws IOException A problem occurs while writing to <code>out</code>
+   * @throws ArrayIndexOutOfBoundsException if the wrong enum class/enum class with a different
+   *         version and less enum constants is used
-  public static <E extends Enum<E>> E readEnum(Class<E> clazz, DataInput in)
-      throws IOException {
+  public static <E extends Enum<E>> E readEnum(Class<E> clazz, DataInput in) throws IOException {
-          LocalizedStrings.DataSerializer_ENUM_CLASS_TO_DESERIALIZE_IS_NULL
-              .toLocalizedString());
+          LocalizedStrings.DataSerializer_ENUM_CLASS_TO_DESERIALIZE_IS_NULL.toLocalizedString());
-          LocalizedStrings.DataSerializer_CLASS_0_NOT_ENUM
-              .toLocalizedString(clazz.getName()));
+          LocalizedStrings.DataSerializer_CLASS_0_NOT_ENUM.toLocalizedString(clazz.getName()));

INS29 MOV29 INS29 MOV29 MOV29 MOV29 MOV29 MOV29 INS29 MOV29 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS65 INS65 MOV65 MOV65 MOV65 MOV65 MOV65 INS65 INS65 MOV65 INS65 INS65 MOV65 MOV65 INS65 INS65 MOV65 MOV65 MOV65 MOV65 MOV65 MOV65 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV32 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 INS66 INS66 INS66 INS66 MOV65 INS66 INS66 INS66 INS42 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS42 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS67 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV67 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 INS66 INS66 MOV65 INS66 INS66 INS66 INS42 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 UPD66 MOV65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 UPD42 INS68 INS42 UPD42 UPD42 UPD42 UPD42 UPD66 MOV66 UPD66 MOV66 UPD66 UPD66 UPD66 INS42 UPD42 INS42 INS69 INS69 MOV69 INS43 INS43 MOV43 INS42 UPD42 INS42 INS42 MOV42 DEL40 DEL26 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL27 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL43 DEL42 DEL45 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL27 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
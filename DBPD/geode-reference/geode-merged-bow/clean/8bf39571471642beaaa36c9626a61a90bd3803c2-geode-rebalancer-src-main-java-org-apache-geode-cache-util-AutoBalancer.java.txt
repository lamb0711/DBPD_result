Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Re-balancing operation relocates data from heavily loaded members to lightly
- * loaded members. In most cases, the decision to re-balance is based on the
- * size of the member and a few other statistics. {@link AutoBalancer} monitors
- * these statistics and if necessary, triggers a re-balancing request.
- * Auto-Balancing is expected to prevent failures and data loss.
+ * Re-balancing operation relocates data from heavily loaded members to lightly loaded members. In
+ * most cases, the decision to re-balance is based on the size of the member and a few other
+ * statistics. {@link AutoBalancer} monitors these statistics and if necessary, triggers a
+ * re-balancing request. Auto-Balancing is expected to prevent failures and data loss.
- * This implementation is based on {@code Initializer} implementation. By
- * default auto-balancing is disabled. A user needs to configure
- * {@link AutoBalancer} during cache initialization
+ * This implementation is based on {@code Initializer} implementation. By default auto-balancing is
+ * disabled. A user needs to configure {@link AutoBalancer} during cache initialization
- * In a cluster only one member owns auto-balancing responsibility. This is
- * achieved by grabbing a distributed lock. In case of a failure a new member
- * will grab the lock and manage auto balancing.
+ * In a cluster only one member owns auto-balancing responsibility. This is achieved by grabbing a
+ * distributed lock. In case of a failure a new member will grab the lock and manage auto balancing.
-   * Use this configuration to manage out-of-balance audit frequency. If the
-   * auditor finds the system to be out-of-balance, it will trigger
-   * re-balancing. Any valid cron string is accepted. The sub-expressions
-   * represent the following:
+   * Use this configuration to manage out-of-balance audit frequency. If the auditor finds the
+   * system to be out-of-balance, it will trigger re-balancing. Any valid cron string is accepted.
+   * The sub-expressions represent the following:
-   * Use this configuration to manage re-balance invocation. Rebalance operation
-   * will be triggered if the total number of bytes rebalance operation may move
-   * is more than this threshold, in percentage of the total data size.
+   * Use this configuration to manage re-balance invocation. Rebalance operation will be triggered
+   * if the total number of bytes rebalance operation may move is more than this threshold, in
+   * percentage of the total data size.
-   * Default value of {@link AutoBalancer#SIZE_THRESHOLD_PERCENT}. If 10% of
-   * data is misplaced, its a good time to redistribute buckets
+   * Default value of {@link AutoBalancer#SIZE_THRESHOLD_PERCENT}. If 10% of data is misplaced, its
+   * a good time to redistribute buckets
-   * In the initial data load phases,
-   * {@link AutoBalancer#SIZE_THRESHOLD_PERCENT} based rebalance invocation may
-   * be unnecessary. Rebalance should not be triggered if the total data size
-   * managed by cluster is too small. Rebalance operation will be triggered if
-   * the total number of bytes rebalance operation may move is more than this
-   * number of bytes.
+   * In the initial data load phases, {@link AutoBalancer#SIZE_THRESHOLD_PERCENT} based rebalance
+   * invocation may be unnecessary. Rebalance should not be triggered if the total data size managed
+   * by cluster is too small. Rebalance operation will be triggered if the total number of bytes
+   * rebalance operation may move is more than this number of bytes.
-   * Default value of {@link AutoBalancer#MINIMUM_SIZE}. In the initial data
-   * load phases, {@link AutoBalancer#SIZE_THRESHOLD_PERCENT} based rebalance
-   * invocation may be unnecessary. Do not rebalance if the data to be moved is
-   * less than 100MB
+   * Default value of {@link AutoBalancer#MINIMUM_SIZE}. In the initial data load phases,
+   * {@link AutoBalancer#SIZE_THRESHOLD_PERCENT} based rebalance invocation may be unnecessary. Do
+   * not rebalance if the data to be moved is less than 100MB
-   * Name of the DistributedLockService that {@link AutoBalancer} will use to
-   * guard against concurrent maintenance activity
+   * Name of the DistributedLockService that {@link AutoBalancer} will use to guard against
+   * concurrent maintenance activity
-   * <LI>schedules a out-of-balance audit task to be started after delay
-   * computed earlier
-   * <LI>once the audit task completes, it repeats delay computation and task
-   * submission
+   * <LI>schedules a out-of-balance audit task to be started after delay computed earlier
+   * <LI>once the audit task completes, it repeats delay computation and task submission
-      } catch(Exception e) {
+      } catch (Exception e) {
-        logger.debug("Now={}, next audit time={}, delay={} ms", new Date(currentTime), nextSchedule, delay);
+        logger.debug("Now={}, next audit time={}, delay={} ms", new Date(currentTime), nextSchedule,
+            delay);
-            logger.warn("Cache closed while attempting to rebalance the cluster. Abort future jobs", e);
+            logger.warn("Cache closed while attempting to rebalance the cluster. Abort future jobs",
+                e);
-   * Queries member statistics and health to determine if a re-balance operation
-   * is needed
+   * Queries member statistics and health to determine if a re-balance operation is needed
-            throw new GemFireConfigException(SIZE_THRESHOLD_PERCENT + " should be integer, 1 to 99");
+            throw new GemFireConfigException(
+                SIZE_THRESHOLD_PERCENT + " should be integer, 1 to 99");
-          logger.debug("Another member owns auto-balance lock. Skip this attempt to rebalance the cluster");
+          logger.debug(
+              "Another member owns auto-balance lock. Skip this attempt to rebalance the cluster");
-     * By default auto-balancer will avoid rebalancing, because a user can
-     * always trigger rebalance manually. So in case of error or inconsistent
-     * data, return false. Return true if
+     * By default auto-balancer will avoid rebalancing, because a user can always trigger rebalance
+     * manually. So in case of error or inconsistent data, return false. Return true if
-     * <LI>total transfer size is above threshold percent of total data size at
-     * cluster level
-     * <LI>If some smaller capacity nodes are heavily loaded while bigger
-     * capacity nodes are balanced. In such a scenario transfer size based
-     * trigger may not cause rebalance.
+     * <LI>total transfer size is above threshold percent of total data size at cluster level
+     * <LI>If some smaller capacity nodes are heavily loaded while bigger capacity nodes are
+     * balanced. In such a scenario transfer size based trigger may not cause rebalance.
-   * Hides cache level details and exposes simple methods relevant for
-   * auto-balancing
+   * Hides cache level details and exposes simple methods relevant for auto-balancing
-        InternalPRInfo info = region.getRedundancyProvider().buildPartitionedRegionInfo(true, probe);
+        InternalPRInfo info =
+            region.getRedundancyProvider().buildPartitionedRegionInfo(true, probe);
-              logger.debug("Region:{}, Member: {}, Size: {}", region.getFullPath(), member, member.getSize());
+              logger.debug("Region:{}, Member: {}, Size: {}", region.getFullPath(), member,
+                  member.getSize());
-        RebalanceOperation operation = getCache().getResourceManager().createRebalanceFactory().simulate();
+        RebalanceOperation operation =
+            getCache().getResourceManager().createRebalanceFactory().simulate();
-          logger.debug(
-              "Rebalance estimate: RebalanceResultsImpl [TotalBucketCreateBytes=" + result.getTotalBucketCreateBytes()
-                  + ", TotalBucketCreatesCompleted=" + result.getTotalBucketCreatesCompleted()
-                  + ", TotalBucketTransferBytes=" + result.getTotalBucketTransferBytes()
-                  + ", TotalBucketTransfersCompleted=" + result.getTotalBucketTransfersCompleted()
-                  + ", TotalPrimaryTransfersCompleted=" + result.getTotalPrimaryTransfersCompleted() + "]");
+          logger.debug("Rebalance estimate: RebalanceResultsImpl [TotalBucketCreateBytes="
+              + result.getTotalBucketCreateBytes() + ", TotalBucketCreatesCompleted="
+              + result.getTotalBucketCreatesCompleted() + ", TotalBucketTransferBytes="
+              + result.getTotalBucketTransferBytes() + ", TotalBucketTransfersCompleted="
+              + result.getTotalBucketTransfersCompleted() + ", TotalPrimaryTransfersCompleted="
+              + result.getTotalPrimaryTransfersCompleted() + "]");
-        RebalanceOperation operation = getCache().getResourceManager().createRebalanceFactory().start();
+        RebalanceOperation operation =
+            getCache().getResourceManager().createRebalanceFactory().start();
-        logger.info("Rebalance result: [TotalBucketCreateBytes=" + result.getTotalBucketCreateBytes()
-            + ", TotalBucketCreateTime=" + result.getTotalBucketCreateTime() + ", TotalBucketCreatesCompleted="
-            + result.getTotalBucketCreatesCompleted() + ", TotalBucketTransferBytes="
-            + result.getTotalBucketTransferBytes() + ", TotalBucketTransferTime=" + result.getTotalBucketTransferTime()
-            + ", TotalBucketTransfersCompleted=" + +result.getTotalBucketTransfersCompleted()
-            + ", TotalPrimaryTransferTime=" + result.getTotalPrimaryTransferTime() + ", TotalPrimaryTransfersCompleted="
-            + result.getTotalPrimaryTransfersCompleted() + ", TotalTime=" + result.getTotalTime() + "]");
+        logger
+            .info("Rebalance result: [TotalBucketCreateBytes=" + result.getTotalBucketCreateBytes()
+                + ", TotalBucketCreateTime=" + result.getTotalBucketCreateTime()
+                + ", TotalBucketCreatesCompleted=" + result.getTotalBucketCreatesCompleted()
+                + ", TotalBucketTransferBytes=" + result.getTotalBucketTransferBytes()
+                + ", TotalBucketTransferTime=" + result.getTotalBucketTransferTime()
+                + ", TotalBucketTransfersCompleted=" + +result.getTotalBucketTransfersCompleted()
+                + ", TotalPrimaryTransferTime=" + result.getTotalPrimaryTransferTime()
+                + ", TotalPrimaryTransfersCompleted=" + result.getTotalPrimaryTransfersCompleted()
+                + ", TotalTime=" + result.getTotalTime() + "]");
-                logger.debug("Another member owns auto-balance lock. Skip this attempt to rebalance the cluster");
+                logger.debug(
+                    "Another member owns auto-balance lock. Skip this attempt to rebalance the cluster");
-      DistributedLockService dls = DistributedLockService.getServiceNamed(AUTO_BALANCER_LOCK_SERVICE_NAME);
+      DistributedLockService dls =
+          DistributedLockService.getServiceNamed(AUTO_BALANCER_LOCK_SERVICE_NAME);
-        dls = DLockService.create(AUTO_BALANCER_LOCK_SERVICE_NAME, cache.getDistributedSystem(), true, true, true);
+        dls = DLockService.create(AUTO_BALANCER_LOCK_SERVICE_NAME, cache.getDistributedSystem(),
+            true, true, true);

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
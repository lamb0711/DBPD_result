Merge branch 'release/1.8.0'

-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.LoggingThreadGroup;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+import org.apache.geode.internal.logging.LoggingThread;
-
-            // skip this guy since the dm no longer knows about him
+            // skip this member since the dm no longer knows about it
-          // now remove from the recipients any guys that the dm no
+          // now remove from the recipients any recipients that the dm no
-              // Run in test mode, splitting out individaual recipients,
+              // Run in test mode, splitting out individual recipients,
-              // Run in normal mode sending to mulitiple recipients in
+              // Run in normal mode sending to multiple recipients in
-          LocalizedStrings.TXCommitMessage_THESE_REGIONS_EXPERIENCED_RELIABILITY_FAILURE_DURING_DISTRIBUTION_OF_THE_OPERATION_0
-              .toLocalizedString(failedRegionNames),
+          String.format(
+              "These regions experienced reliability failure during distribution of the operation: %s",
+              failedRegionNames),
-              logger.error(
-                  LocalizedMessage.create(
-                      LocalizedStrings.TXCommitMessage_EXCEPTION_OCCURRED_IN_TRANSACTIONLISTENER),
+              logger.error("Exception occurred in TransactionListener",
-      logger.error(LocalizedMessage.create(
-          LocalizedStrings.TXCommitMessage_TRANSACTION_MESSAGE_0_FROM_SENDER_1_FAILED_PROCESSING_UNKNOWN_TRANSACTION_STATE_2,
-          new Object[] {this, getSender(), problem}));
+      logger.error(
+          "Transaction message {} from sender {} failed processing, unknown transaction state: {}",
+          new Object[] {this, getSender(), problem});
-            LocalizedStrings.TXCommitMessage_COMMIT_OPERATION_GENERATED_ONE_OR_MORE_EXCEPTIONS_FROM_0
-                .toLocalizedString(this.getSender()),
+            String.format("Commit operation generated one or more exceptions from %s",
+                this.getSender()),
-              LocalizedStrings.TXCommitMessage_REGION_NOT_FOUND.toLocalizedString(),
+              "Region not found",
-      final boolean processMsgReceived = txTracker.commitProcessReceived(this.trackerKey, dm);
+      final boolean processMsgReceived = txTracker.commitProcessReceived(this.trackerKey);
+  private void doOriginDepartedCommit() {
+    try {
+      // Set processor to zero to avoid the ack to the now departed origin
+      processorId = 0;
+      basicProcess();
+    } finally {
+      txTracker.processed(this);
+    }
+  }
+
-    this.dm.removeMembershipListener(this);
+    distributionManager.removeMembershipListener(this);
-    ThreadGroup group = LoggingThreadGroup.createThreadGroup("TXCommitMessage Threads", logger);
-
-    if (this.farSiders != null && !this.farSiders.isEmpty()) {
+    if (getFarSiders() != null && !getFarSiders().isEmpty()) {
-      Thread fellowFarSidersQuery = new Thread(group, "CommitProcessQuery Thread") {
-        // Should I use a thread pool?, Darrel suggests look in DM somewhere or introduce a zero
-        // sized thread pool
-        @Override
-        public void run() {
-          final TXCommitMessage mess = TXCommitMessage.this;
-          Object trackerKey = mess.getTrackerKey();
-          DistributedMember member = getMemberFromTrackerKey(trackerKey);
-          if (!mess.getSender().equals(member)) {
-            /*
-             * Do not send a CommitProcessQueryMessage when the sender of CommitMessage is not the
-             * member in the tracker key. (If this happens we are the redundant node for PR, and the
-             * primary just crashed).
-             */
-            txTracker.removeMessage(mess);
-            return;
-          }
-          CommitProcessQueryReplyProcessor replProc =
-              new CommitProcessQueryReplyProcessor(mess.dm, mess.farSiders);
-          CommitProcessQueryMessage query =
-              new CommitProcessQueryMessage(mess.getTrackerKey(), replProc.getProcessorId());
-          query.setRecipients(mess.farSiders);
-          mess.dm.putOutgoing(query);
-          // Wait for any one positive response or all negative responses.
-          // (while() loop removed for bug 36983 - you can't loop on waitForReplies()
-          TXCommitMessage.this.dm.getCancelCriterion().checkCancelInProgress(null);
-          try {
-            replProc.waitForRepliesUninterruptibly();
-          } catch (ReplyException e) {
-            e.handleCause();
-          }
-          if (replProc.receivedACommitProcessMessage()) {
-            if (logger.isDebugEnabled()) {
-              logger.debug(
-                  "Transaction associated with lockID: {} from orign {} is processing due to a received \"commit process\" message",
-                  mess.lockId, id);
-            }
-
-            try {
-              // Set processor to zero to avoid the ack to the now departed origin
-              mess.processorId = 0;
-              mess.basicProcess();
-            } finally {
-              txTracker.processed(mess);
-            }
-          } else {
-            if (logger.isDebugEnabled()) {
-              logger.debug(
-                  "Transaction associated with lockID: {} from origin {} ignored.  No other recipients received \"commit process\" message",
-                  mess.lockId, id);
-            }
-            txTracker.removeMessage(mess);
-          }
-
-        }
-
-        private DistributedMember getMemberFromTrackerKey(Object trackerKey) {
-          if (trackerKey instanceof TXId) {
-            TXId id1 = (TXId) trackerKey;
-            return id1.getMemberId();
-          } else if (trackerKey instanceof TXLockId) {
-            TXLockId id2 = (TXLockId) trackerKey;
-            return id2.getMemberId();
-          }
-          return null;
-        }
-      };
-      fellowFarSidersQuery.setDaemon(true);
+      // Should I use a thread pool?, Darrel suggests look in DM somewhere or introduce a zero
+      // sized thread pool
+      Thread fellowFarSidersQuery = new LoggingThread("CommitProcessQuery Thread",
+          () -> doCommitProcessQuery(id));
-      Thread originDepartedCommit = new Thread(group, "Origin Departed Commit") {
-        @Override
-        public void run() {
-          final TXCommitMessage mess = TXCommitMessage.this;
-          try {
-            // Set processor to zero to avoid the ack to the now departed origin
-            mess.processorId = 0;
-            mess.basicProcess();
-          } finally {
-            txTracker.processed(mess);
-          }
-        }
-      };
-      originDepartedCommit.setDaemon(true);
+      Thread originDepartedCommit = new LoggingThread("Origin Departed Commit",
+          this::doOriginDepartedCommit);
+  HashSet getFarSiders() {
+    return farSiders;
+  }
+
+  DistributionManager getDistributionManager() {
+    return dm;
+  }
+
+  void doCommitProcessQuery(final InternalDistributedMember id) {
+    CommitProcessQueryReplyProcessor replyProcessor = createReplyProcessor();
+    CommitProcessQueryMessage queryMessage = createQueryMessage(replyProcessor);
+    queryMessage.setRecipients(this.farSiders);
+    getDistributionManager().putOutgoing(queryMessage);
+    // Wait for any one positive response or all negative responses.
+    // (while() loop removed for bug 36983 - you can't loop on waitForReplies()
+    getDistributionManager().getCancelCriterion().checkCancelInProgress(null);
+    try {
+      replyProcessor.waitForRepliesUninterruptibly();
+    } catch (ReplyException e) {
+      e.handleCause();
+    }
+    if (replyProcessor.receivedACommitProcessMessage()) {
+      if (logger.isDebugEnabled()) {
+        logger.debug(
+            "Transaction associated with lockID: {} from orign {} is processing due to a received \"commit process\" message",
+            lockId, id);
+      }
+
+      try {
+        // Set processor to zero to avoid the ack to the now departed origin
+        processorId = 0;
+        basicProcess();
+      } finally {
+        txTracker.processed(this);
+      }
+    } else {
+      if (logger.isDebugEnabled()) {
+        logger.debug(
+            "Transaction associated with lockID: {} from origin {} ignored.  No other recipients received \"commit process\" message",
+            lockId, id);
+      }
+      txTracker.removeMessage(this);
+    }
+  }
+
+  CommitProcessQueryReplyProcessor createReplyProcessor() {
+    return new CommitProcessQueryReplyProcessor(dm, farSiders);
+  }
+
+  CommitProcessQueryMessage createQueryMessage(CommitProcessQueryReplyProcessor replyProcessor) {
+    return new CommitProcessQueryMessage(getTrackerKey(), replyProcessor.getProcessorId());
+  }
+
+  private DistributedMember getMemberFromTrackerKey(Object trackerKey) {
+    if (trackerKey instanceof TXId) {
+      TXId id1 = (TXId) trackerKey;
+      return id1.getMemberId();
+    } else if (trackerKey instanceof TXLockId) {
+      TXLockId id2 = (TXLockId) trackerKey;
+      return id2.getMemberId();
+    }
+    return null;
+  }
+

UPD40 INS31 INS31 INS31 INS31 INS31 INS31 INS31 MOV31 UPD83 MOV83 MOV39 UPD42 MOV42 INS8 MOV78 INS83 INS39 INS42 MOV44 MOV44 MOV44 INS8 INS43 INS42 INS8 INS43 INS42 INS8 INS39 INS42 INS44 INS8 MOV43 INS42 INS8 MOV43 INS42 INS44 MOV8 INS54 MOV25 INS21 MOV51 INS25 UPD42 MOV42 INS41 UPD42 MOV42 INS41 INS83 INS43 INS42 MOV60 MOV60 MOV21 MOV21 MOV21 MOV54 MOV25 INS41 INS43 INS42 INS41 INS8 INS8 INS32 MOV27 INS8 INS8 INS42 INS42 INS42 MOV43 MOV43 MOV32 MOV22 INS14 INS42 INS14 INS21 INS21 MOV21 UPD42 MOV42 UPD42 MOV42 INS52 MOV25 INS60 MOV21 MOV25 MOV60 MOV21 UPD42 INS32 UPD42 INS32 UPD42 INS42 INS32 UPD42 UPD42 INS43 INS42 INS42 INS43 INS32 INS32 INS7 INS32 INS32 INS32 MOV43 INS59 MOV43 INS59 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV32 INS42 INS34 INS42 INS42 UPD42 INS42 INS32 INS42 MOV42 INS14 INS42 INS14 INS42 UPD42 INS52 UPD42 INS42 INS45 UPD42 UPD42 INS45 INS42 INS43 MOV45 INS86 INS43 INS45 INS90 INS42 INS32 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS42 UPD42 INS42 INS45 INS45 INS45 DEL40 DEL26 DEL40 DEL26 DEL40 DEL42 DEL42 DEL40 DEL32 DEL40 DEL42 DEL42 DEL32 DEL40 DEL40 DEL42 DEL32 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL42 DEL43 DEL42 DEL42 DEL52 DEL59 DEL40 DEL40 DEL14 DEL42 DEL42 DEL32 DEL32 DEL14 DEL42 DEL42 DEL40 DEL32 DEL40 DEL42 DEL52 DEL42 DEL22 DEL40 DEL40 DEL42 DEL42 DEL40 DEL42 DEL83 DEL43 DEL42 DEL42 DEL52 DEL59 DEL60 DEL40 DEL34 DEL7 DEL21 DEL42 DEL32 DEL21 DEL8 DEL42 DEL32 DEL21 DEL8 DEL54 DEL42 DEL43 DEL42 DEL42 DEL45 DEL32 DEL59 DEL60 DEL42 DEL42 DEL78 DEL83 DEL39 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL41 DEL8 DEL25 DEL8 DEL31 DEL1 DEL14 DEL59 DEL60 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL43 DEL42 DEL42 DEL43 DEL42 DEL45 DEL42 DEL78 DEL83 DEL39 DEL42 DEL31 DEL1 DEL14 DEL59 DEL60 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31
GEODE-7945: Replace Map with ConcurrentMap for GemFireCacheImpl.rootRegions (#4899)

* Remove unnecessary synchronized block

* Replace Map.get and remove with remove

* Fix the typo in log messages

* Remove unnecessary copy of rootRegions values

Authored-by: Jianxia Chen <jchen21@apache.org>
-import org.apache.geode.internal.Assert;
-  private final Map<String, InternalRegion> rootRegions;
+  private final ConcurrentMap<String, InternalRegion> rootRegions;
-      rootRegions = new HashMap<>();
+      rootRegions = new ConcurrentHashMap<>();
-          List<InternalRegion> rootRegionValues;
-          synchronized (rootRegions) {
-            rootRegionValues = new ArrayList<>(rootRegions.values());
-          }
-
-          for (InternalRegion lr : rootRegionValues) {
+          for (InternalRegion lr : rootRegions.values()) {
+        // synchronize the block because rootRegions get and then put have to stay together as an
+        // atomic operation
+            // Note that rootRegions is a ConcurrentMap. After rootRegions.put(name, region),
+            // the ConcurrentMap entry is now available for the other threads to consume,
+            // although rootRegions.put(name, region) is still in a synchronized block.
-
-            synchronized (rootRegions) {
-              Region rootRegion = rootRegions.get(name);
-              if (rootRegion == region) {
-                rootRegions.remove(name);
-              }
-            }
+            rootRegions.remove(name, region);
-    synchronized (rootRegions) {
-      for (Region<?, ?> region : rootRegions.values()) {
-        if (region instanceof PartitionedRegion) {
-          PartitionedRegion partitionedRegion = (PartitionedRegion) region;
-          PartitionedRegionDataStore dataStore = partitionedRegion.getDataStore();
-          if (dataStore != null) {
-            Set<Entry<Integer, BucketRegion>> bucketEntries =
-                partitionedRegion.getDataStore().getAllLocalBuckets();
-            for (Entry entry : bucketEntries) {
-              result.add((InternalRegion) entry.getValue());
-            }
+
+    for (Region<?, ?> region : rootRegions.values()) {
+      if (region instanceof PartitionedRegion) {
+        PartitionedRegion partitionedRegion = (PartitionedRegion) region;
+        PartitionedRegionDataStore dataStore = partitionedRegion.getDataStore();
+        if (dataStore != null) {
+          Set<Entry<Integer, BucketRegion>> bucketEntries =
+              partitionedRegion.getDataStore().getAllLocalBuckets();
+          for (Entry entry : bucketEntries) {
+            result.add((InternalRegion) entry.getValue());
-        } else if (region instanceof InternalRegion) {
-          InternalRegion internalRegion = (InternalRegion) region;
-          result.add(internalRegion);
-          result.addAll(internalRegion.basicSubregions(true));
+      } else if (region instanceof InternalRegion) {
+        InternalRegion internalRegion = (InternalRegion) region;
+        result.add(internalRegion);
+        result.addAll(internalRegion.basicSubregions(true));
+
-    synchronized (rootRegions) {
-      for (Object region : rootRegions.values()) {
-        InternalRegion internalRegion = (InternalRegion) region;
-        if (internalRegion.isInternalRegion()) {
-          // Skip internal regions
-          continue;
-        }
-        result.add(internalRegion);
-        result.addAll(internalRegion.basicSubregions(true));
+
+    for (Object region : rootRegions.values()) {
+      InternalRegion internalRegion = (InternalRegion) region;
+      if (internalRegion.isInternalRegion()) {
+        // Skip internal regions
+        continue;
+      result.add(internalRegion);
+      result.addAll(internalRegion.basicSubregions(true));
+
-    synchronized (rootRegions) {
-      for (InternalRegion region : rootRegions.values()) {
-        if (region.getDataPolicy().withPersistence()) {
+
+    for (InternalRegion region : rootRegions.values()) {
+      if (region.getDataPolicy().withPersistence()) {
+        return true;
+      }
+      for (InternalRegion subRegion : region.basicSubregions(true)) {
+        if (subRegion.getDataPolicy().withPersistence()) {
-        for (InternalRegion subRegion : region.basicSubregions(true)) {
-          if (subRegion.getDataPolicy().withPersistence()) {
-            return true;
-          }
-        }
-      return false;
+    return false;
+
-        synchronized (rootRegions) {
-          rootRegion = rootRegions.get(pathParts[0]);
-          if (rootRegion == null) {
-            return null;
-          }
+
+        rootRegion = rootRegions.get(pathParts[0]);
+        if (rootRegion == null) {
+          return null;
+
-    synchronized (rootRegions) {
-      rootRegion = rootRegions.get(pathParts[0]);
-      if (rootRegion == null) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("GemFireCache.getRegion, no region found for {}", pathParts[0]);
-        }
-        stopper.checkCancelInProgress(null);
-        return null;
+
+    rootRegion = rootRegions.get(pathParts[0]);
+    if (rootRegion == null) {
+      if (logger.isDebugEnabled()) {
+        logger.debug("GemFireCache.getRegion, no region found for {}", pathParts[0]);
-      if (!returnDestroyedRegion && rootRegion.isDestroyed()) {
-        stopper.checkCancelInProgress(null);
-        return null;
-      }
+      stopper.checkCancelInProgress(null);
+      return null;
+    if (!returnDestroyedRegion && rootRegion.isDestroyed()) {
+      stopper.checkCancelInProgress(null);
+      return null;
+    }
+
-    synchronized (rootRegions) {
-      for (InternalRegion region : rootRegions.values()) {
-        // If this is an internal meta-region, don't return it to end user
-        if (region.isSecret()
-            || region.isUsedForMetaRegion()
-            || !includePRAdminRegions
-                && (region.isUsedForPartitionedRegionAdmin()
-                    || region.isUsedForPartitionedRegionBucket())) {
-          // Skip administrative PartitionedRegions
-          continue;
-        }
-        regions.add(region);
+
+    for (InternalRegion region : rootRegions.values()) {
+      // If this is an internal meta-region, don't return it to end user
+      if (region.isSecret()
+          || region.isUsedForMetaRegion()
+          || !includePRAdminRegions
+              && (region.isUsedForPartitionedRegionAdmin()
+                  || region.isUsedForPartitionedRegionBucket())) {
+        // Skip administrative PartitionedRegions
+        continue;
+      regions.add(region);
+
-    synchronized (rootRegions) {
-      String regionName = rootRgn.getName();
-      InternalRegion found = rootRegions.get(regionName);
-      if (found == rootRgn) {
-        InternalRegion previous = rootRegions.remove(regionName);
-        Assert.assertTrue(previous == rootRgn);
-        return true;
-      }
-      return false;
-    }
+
+    String regionName = rootRgn.getName();
+    return rootRegions.remove(regionName, rootRgn);
+
-    synchronized (rootRegions) {
-      Set<InternalRegion> applicationRegions = getApplicationRegions();
-      for (InternalRegion region : applicationRegions) {
-        Set<String> senders = region.getAllGatewaySenderIds();
-        if (senders.contains(sender.getId()) && !sender.isParallel()) {
-          region.senderCreated();
-        }
+
+    Set<InternalRegion> applicationRegions = getApplicationRegions();
+    for (InternalRegion region : applicationRegions) {
+      Set<String> senders = region.getAllGatewaySenderIds();
+      if (senders.contains(sender.getId()) && !sender.isParallel()) {
+        region.senderCreated();
+

UPD74 MOV8 MOV8 MOV8 MOV8 MOV8 INS8 UPD43 MOV60 MOV41 MOV60 MOV41 MOV21 MOV60 MOV25 MOV60 MOV60 MOV25 MOV41 MOV21 MOV60 MOV25 MOV41 MOV60 INS41 MOV60 MOV70 UPD42 INS32 MOV42 MOV42 MOV42 INS42 MOV21 MOV25 UPD74 UPD43 UPD42 MOV32 INS8 MOV21 MOV21 INS42 DEL40 DEL26 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL43 DEL74 DEL14 DEL7 DEL21 DEL8 DEL51 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL8 DEL25 DEL8 DEL51 DEL8 DEL42 DEL51 DEL8 DEL42 DEL51 DEL8 DEL42 DEL51 DEL8 DEL42 DEL8 DEL51 DEL42 DEL51 DEL8 DEL42 DEL51 DEL8 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL27 DEL32 DEL21 DEL9 DEL41 DEL8 DEL25 DEL9 DEL41 DEL8 DEL51 DEL8 DEL42 DEL8 DEL51
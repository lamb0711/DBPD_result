Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import javax.management.InstanceNotFoundException;
- * Manager implementation which manages federated MBeans for the entire
- * DistributedSystem and controls the JMX server endpoints for JMX clients to
- * connect, such as an RMI server.
+ * Manager implementation which manages federated MBeans for the entire DistributedSystem and
+ * controls the JMX server endpoints for JMX clients to connect, such as an RMI server.
- * The FederatingManager is only appropriate for a peer or server in a GemFire
- * distributed system.
+ * The FederatingManager is only appropriate for a peer or server in a GemFire distributed system.
-   * utilize the processing powers available. Going with unbounded queue because
-   * tasks wont be unbounded in practical situation as number of members will be
-   * a finite set at any given point of time
+   * utilize the processing powers available. Going with unbounded queue because tasks wont be
+   * unbounded in practical situation as number of members will be a finite set at any given point
+   * of time
-  
+
-  
-  
+
+
-  
+
-  
+
-  
+
-   * @param jmxAdapter
-   *          JMX Adpater
-   * @param repo
-   *          Management resource repo
-   * @param system
-   *          Internal Distributed System
-   * @param service
-   *          SystemManagement Service
+   * @param jmxAdapter JMX Adpater
+   * @param repo Management resource repo
+   * @param system Internal Distributed System
+   * @param service SystemManagement Service
-  public FederatingManager(MBeanJMXAdapter jmxAdapter,
-      ManagementResourceRepo repo, InternalDistributedSystem system, SystemManagementService service, Cache cache) {
+  public FederatingManager(MBeanJMXAdapter jmxAdapter, ManagementResourceRepo repo,
+      InternalDistributedSystem system, SystemManagementService service, Cache cache) {
-    this.proxyFactory = new MBeanProxyFactory(remoteFilterChain, jmxAdapter,
-        service);
-    this.jmxAdapter  = jmxAdapter;
+    this.proxyFactory = new MBeanProxyFactory(remoteFilterChain, jmxAdapter, service);
+    this.jmxAdapter = jmxAdapter;
-  
- 
+
+
-   * This method will be invoked whenever a member wants to be a managing node.
-   * The exception Management exception has to be handled by the caller.
+   * This method will be invoked whenever a member wants to be a managing node. The exception
+   * Management exception has to be handled by the caller.
-      
+
-      
+
-      
+
-      
+
-    if(!running){
+    if (!running) {
-   
+
-  
+
-   * This method will be invoked whenever a member stops being a managing node.
-   * The exception Management exception has to be handled by the caller.   * 
+   * This method will be invoked whenever a member stops being a managing node. The exception
+   * Management exception has to be handled by the caller. *
+   * 
-   * This method will be invoked from MembershipListener which is registered
-   * when the member becomes a Management node.
+   * This method will be invoked from MembershipListener which is registered when the member becomes
+   * a Management node.
-   * This method will delegate task to another thread and exit, so that it wont
-   * block the membership listener
+   * This method will delegate task to another thread and exit, so that it wont block the membership
+   * listener
+   * 
-    submitTask(giiTask);    
+    executeTask(new Runnable() {
+      @Override
+      public void run() {
+        giiTask.call();
+      }
+    });
-  
-  
+
+
-   * This method will be invoked from MembershipListener which is registered
-   * when the member becomes a Management node.
+   * This method will be invoked from MembershipListener which is registered when the member becomes
+   * a Management node.
-   * This method will delegate task to another thread and exit, so that it wont
-   * block the membership listener
+   * This method will delegate task to another thread and exit, so that it wont block the membership
+   * listener
-    submitTask(removeTask);
+    executeTask(removeTask);
-  
+
-  
-  private class RemoveMemberTask implements Callable<DistributedMember> {
+
+  private void executeTask(Runnable task) {
+    try {
+      pooledMembershipExecutor.execute(task);
+    } catch (java.util.concurrent.RejectedExecutionException ex) {
+      // Ignore, we are getting shutdown
+    }
+  }
+
+  private class RemoveMemberTask implements Runnable {
-    
+
-    public DistributedMember call() {
-      return removeMemberArtifacts(member, crashed);
+    public void run() {
+      removeMemberArtifacts(member, crashed);
-  
+
-   * This method will be invoked from MembershipListener which is registered
-   * when the member becomes a Management node.
+   * This method will be invoked from MembershipListener which is registered when the member becomes
+   * a Management node.
-   * this method will delegate task to another thread and exit, so that it wont
-   * block the membership listener
+   * this method will delegate task to another thread and exit, so that it wont block the membership
+   * listener
-  public void suspectMember(DistributedMember member, InternalDistributedMember whoSuspected, String reason) {
+  public void suspectMember(DistributedMember member, InternalDistributedMember whoSuspected,
+      String reason) {
-   * This method will be invoked when a node transitions from managed node to
-   * managing node This method will block for all GIIs to be completed But each
-   * GII is given a specific time frame. After that the task will be marked as
-   * cancelled.
+   * This method will be invoked when a node transitions from managed node to managing node This
+   * method will block for all GIIs to be completed But each GII is given a specific time frame.
+   * After that the task will be marked as cancelled.
-    
-    Set<DistributedMember> members = cache.getDistributionManager().getOtherDistributionManagerIds();
+
+    Set<DistributedMember> members =
+        cache.getDistributionManager().getOtherDistributionManagerIds();
-    List<GIITask> giiTaskList = new ArrayList<GIITask>();
+    final List<Callable<DistributedMember>> giiTaskList = new ArrayList<>();
-          if(returnedMember != null){
+          if (returnedMember != null) {
-          
+
-            
+
-            
+
- 
-        } catch(CancellationException e){
+
+        } catch (CancellationException e) {
-            ManagementException mgEx =  new ManagementException(e.fillInStackTrace());
-            logger.debug("InterruptedException while creating Monitoring resource with error : {}", mgEx.getMessage(), mgEx);
+            ManagementException mgEx = new ManagementException(e.fillInStackTrace());
+            logger.debug("InterruptedException while creating Monitoring resource with error : {}",
+                mgEx.getMessage(), mgEx);
-        logger.debug("InterruptedException while creating Monitoring resource with error : ", mgEx.getMessage(), mgEx);
+        logger.debug("InterruptedException while creating Monitoring resource with error : ",
+            mgEx.getMessage(), mgEx);
-   * It will perform the GII request which might originate from
-   * TranstionListener or Membership Listener.
+   * It will perform the GII request which might originate from TranstionListener or Membership
+   * Listener.
-   * Managing Node side resources are created per member which is visible to
-   * this node
+   * Managing Node side resources are created per member which is visible to this node
-   * 1)Management Region : its a Replicated NO_ACK region 2)Notification Region
-   * : its a Replicated Proxy NO_ACK region
+   * 1)Management Region : its a Replicated NO_ACK region 2)Notification Region : its a Replicated
+   * Proxy NO_ACK region
-   * Listeners are added to the above two regions 1) ManagementCacheListener()
-   * 2) NotificationCacheListener
+   * Listeners are added to the above two regions 1) ManagementCacheListener() 2)
+   * NotificationCacheListener
-   * This task can be cancelled from the calling thread if a timeout happens. In
-   * that case we have to handle the thread interrupt
+   * This task can be cancelled from the calling thread if a timeout happens. In that case we have
+   * to handle the thread interrupt
-          
+
-              return new CachePerfStats(cache.getDistributedSystem(),
-                  "managementRegionStats");
+              return new CachePerfStats(cache.getDistributedSystem(), "managementRegionStats");
-          AttributesFactory<String, Object> monitorAttrFactory = new AttributesFactory<String, Object>();
+          AttributesFactory<String, Object> monitorAttrFactory =
+              new AttributesFactory<String, Object>();
-          ManagementCacheListener mgmtCacheListener = new ManagementCacheListener(
-              proxyFactory);
+          ManagementCacheListener mgmtCacheListener = new ManagementCacheListener(proxyFactory);
-          RegionAttributes<String, Object> monitoringRegionAttrs = monitorAttrFactory
-              .create();
+          RegionAttributes<String, Object> monitoringRegionAttrs = monitorAttrFactory.create();
-          AttributesFactory<NotificationKey, Notification> notifAttrFactory = new AttributesFactory<NotificationKey, Notification>();
+          AttributesFactory<NotificationKey, Notification> notifAttrFactory =
+              new AttributesFactory<NotificationKey, Notification>();
-          
+
-          notifAttrFactory.setEvictionAttributes(EvictionAttributes.createLRUEntryAttributes(ManagementConstants.NOTIF_REGION_MAX_ENTRIES,
-              EvictionAction.LOCAL_DESTROY));
+          notifAttrFactory.setEvictionAttributes(EvictionAttributes.createLRUEntryAttributes(
+              ManagementConstants.NOTIF_REGION_MAX_ENTRIES, EvictionAction.LOCAL_DESTROY));
-          RegionAttributes<NotificationKey, Notification> notifRegionAttrs = notifAttrFactory
-              .create();
+          RegionAttributes<NotificationKey, Notification> notifRegionAttrs =
+              notifAttrFactory.create();
-            if(!running){
+            if (!running) {
-            proxyMonitoringRegion = cache.createVMRegion(ManagementConstants.MONITORING_REGION + "_" + appender, monitoringRegionAttrs, internalArgs);
+            proxyMonitoringRegion =
+                cache.createVMRegion(ManagementConstants.MONITORING_REGION + "_" + appender,
+                    monitoringRegionAttrs, internalArgs);
-   
+
-            if(!running){
+            if (!running) {
-            proxyNotificationgRegion = cache.createVMRegion(ManagementConstants.NOTIFICATION_REGION + "_" + appender, notifRegionAttrs, internalArgs);
+            proxyNotificationgRegion =
+                cache.createVMRegion(ManagementConstants.NOTIFICATION_REGION + "_" + appender,
+                    notifRegionAttrs, internalArgs);
-            logger.debug("Management Region created with Name : {}", proxyMonitoringRegion.getName());
-            logger.debug("Notification Region created with Name : {}", proxyNotificationgRegion.getName());
+            logger.debug("Management Region created with Name : {}",
+                proxyMonitoringRegion.getName());
+            logger.debug("Notification Region created with Name : {}",
+                proxyNotificationgRegion.getName());
-          try{
-            if(!running){
+          try {
+            if (!running) {
- 
+
-          }catch(Exception e){
+          } catch (Exception e) {
-            
+
-          
+
-      } catch(Exception e) {
+      } catch (Exception e) {
-      
-      // Before completing task intimate all listening ProxyListener which might send notifications. 
+
+      // Before completing task intimate all listening ProxyListener which might send notifications.
-      
-      
+
+
-   *For internal Use only
+   * For internal Use only
-   * @param objectName
-   *          {@link javax.management.ObjectName} of the MBean
+   * @param objectName {@link javax.management.ObjectName} of the MBean
-   * Find a particular proxy instance for a {@link javax.management.ObjectName}
-   * , {@link org.apache.geode.distributed.DistributedMember} and interface
-   * class If the proxy interface does not implement the given interface class a
-   * {@link java.lang.ClassCastException}. will be thrown
+   * Find a particular proxy instance for a {@link javax.management.ObjectName} ,
+   * {@link org.apache.geode.distributed.DistributedMember} and interface class If the proxy
+   * interface does not implement the given interface class a {@link java.lang.ClassCastException}.
+   * will be thrown
-   * @param objectName
-   *          {@link javax.management.ObjectName} of the MBean
-   * @param interfaceClass
-   *          interface class implemented by proxy
+   * @param objectName {@link javax.management.ObjectName} of the MBean
+   * @param interfaceClass interface class implemented by proxy
-   * Find a set of proxies given a
-   * {@link org.apache.geode.distributed.DistributedMember}
+   * Find a set of proxies given a {@link org.apache.geode.distributed.DistributedMember}
-   * @param member
-   *          {@link org.apache.geode.distributed.DistributedMember}
+   * @param member {@link org.apache.geode.distributed.DistributedMember}
-  
+

INS31 INS83 INS39 INS42 INS44 INS8 INS43 MOV65 UPD66 UPD66 UPD66 INS43 INS42 INS54 INS42 INS39 INS42 UPD65 UPD65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 INS8 INS12 INS21 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS83 UPD74 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 MOV65 UPD66 UPD66 UPD66 INS66 UPD66 INS66 MOV65 UPD66 INS66 INS42 UPD66 UPD42 INS14 UPD42 INS21 INS44 INS8 MOV32 MOV74 INS43 INS1 INS32 INS43 INS42 UPD74 INS42 INS31 INS42 INS42 INS42 INS40 INS78 INS83 INS39 INS42 INS8 INS42 INS21 INS32 MOV42 INS42 DEL40 DEL26 DEL66 DEL66 DEL42 DEL43 DEL42 DEL41 DEL66 DEL42 DEL43 DEL42 DEL43 DEL66 DEL42
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
-  //////////////////////  Instance Fields  ///////////////////////
+
+  ////////////////////// Instance Fields ///////////////////////
-   * A flag used to indicate that this disk region
-   * is being recreated using already existing data on the disk. 
+   * A flag used to indicate that this disk region is being recreated using already existing data on
+   * the disk.
-  
+
-   * Records the version vector of what has been persisted to disk.
-   * This may lag behind the version vector of what is in memory, because
-   * updates may be written asynchronously to disk. We need to keep track
-   * of exactly what has been written to disk so that we can record a version
-   * vector at the beginning of each oplog.
+   * Records the version vector of what has been persisted to disk. This may lag behind the version
+   * vector of what is in memory, because updates may be written asynchronously to disk. We need to
+   * keep track of exactly what has been written to disk so that we can record a version vector at
+   * the beginning of each oplog.
-   * The version vector of what is in memory is held in is held 
-   * in LocalRegion.versionVector. 
+   * The version vector of what is in memory is held in is held in LocalRegion.versionVector.
-  
+
-   * A flag whether the current version vector accurately represents
-   * what has been written to this members disk.
+   * A flag whether the current version vector accurately represents what has been written to this
+   * members disk.
-  
+
-      this.equalMembers = new CopyOnWriteHashSet<PersistentMemberID>(drv.getOfflineAndEqualMembers());
+      this.equalMembers =
+          new CopyOnWriteHashSet<PersistentMemberID>(drv.getOfflineAndEqualMembers());
-      //Use the same atomic counters as the previous disk region. This ensures that
-      //updates from threads with a reference to the old region update this disk region
-      //See 49943
-      this.numOverflowOnDisk = ((AbstractDiskRegion)drv).numOverflowOnDisk;
-      this.numEntriesInVM = ((AbstractDiskRegion)drv).numEntriesInVM;
-      this.numOverflowBytesOnDisk = ((AbstractDiskRegion)drv).numOverflowBytesOnDisk;
+      // Use the same atomic counters as the previous disk region. This ensures that
+      // updates from threads with a reference to the old region update this disk region
+      // See 49943
+      this.numOverflowOnDisk = ((AbstractDiskRegion) drv).numOverflowOnDisk;
+      this.numEntriesInVM = ((AbstractDiskRegion) drv).numEntriesInVM;
+      this.numOverflowBytesOnDisk = ((AbstractDiskRegion) drv).numOverflowBytesOnDisk;
-      this.recoveryCompleted = ((AbstractDiskRegion)drv).recoveryCompleted;
+      this.recoveryCompleted = ((AbstractDiskRegion) drv).recoveryCompleted;
-      //This is a brand new disk region.
+      // This is a brand new disk region.
-//       {
-//         DiskRegion existingDr = ds.getByName(name);
-//         if (existingDr != null) {
-//           throw new IllegalStateException("DiskRegion named " + name + " already exists with id=" + existingDr.getId());
-//         }
-//       }
+      // {
+      // DiskRegion existingDr = ds.getByName(name);
+      // if (existingDr != null) {
+      // throw new IllegalStateException("DiskRegion named " + name + " already exists with id=" +
+      // existingDr.getId());
+      // }
+      // }
-    //We do not initialize the soplog set here. The soplog set needs
-    //to be handled the complete set of recovered soplogs, which is not available
-    //at the time a recovered disk region is first created.
+    // We do not initialize the soplog set here. The soplog set needs
+    // to be handled the complete set of recovered soplogs, which is not available
+    // at the time a recovered disk region is first created.
+
+   * 
-    this.recoveryCompleted = ((AbstractDiskRegion)drv).recoveryCompleted;
+    this.recoveryCompleted = ((AbstractDiskRegion) drv).recoveryCompleted;
-  
-  //////////////////////  Instance Methods  //////////////////////
-  
+
+  ////////////////////// Instance Methods //////////////////////
+
-  
+
+
+
-  
+
-  public void setConfig(byte lruAlgorithm, byte lruAction, int lruLimit,
-                        int concurrencyLevel, int initialCapacity,
-                        float loadFactor, boolean statisticsEnabled,
-                        boolean isBucket, EnumSet<DiskRegionFlag> flags,
-                        String partitionName, int startingBucketId, 
-                        String compressorClassName, boolean offHeap) {
+  public void setConfig(byte lruAlgorithm, byte lruAction, int lruLimit, int concurrencyLevel,
+      int initialCapacity, float loadFactor, boolean statisticsEnabled, boolean isBucket,
+      EnumSet<DiskRegionFlag> flags, String partitionName, int startingBucketId,
+      String compressorClassName, boolean offHeap) {
-  
+
-        Class<Compressor> compressorClass = (Class<Compressor>) ClassPathLoader.getLatest().forName(compressorClassName);
+        Class<Compressor> compressorClass =
+            (Class<Compressor>) ClassPathLoader.getLatest().forName(compressorClassName);
-  
+
-    return new EvictionAttributesImpl()
-      .setAlgorithm(getActualLruAlgorithm())
-      .setAction(getActualLruAction())
-      .internalSetMaximum(getLruLimit());
+    return new EvictionAttributesImpl().setAlgorithm(getActualLruAlgorithm())
+        .setAction(getActualLruAction()).internalSetMaximum(getLruLimit());
+
-  
+
+
+
+
+
+
+
+
+
+
-  
+
-    if(result != null) {
+    if (result != null) {
+
+
+
+
+
+
+
+
-  
+
-  
+
-  
+
-    if (dif == null) return this.myInitializingId;
+    if (dif == null)
+      return this.myInitializingId;
+
-    if (dif == null) return this.myInitializedId;
+    if (dif == null)
+      return this.myInitializedId;
+
-    if (dif == null) return this.onlineMembers.getSnapshot();
+    if (dif == null)
+      return this.onlineMembers.getSnapshot();
+
-    if (dif == null) return this.offlineMembers.getSnapshot();
+    if (dif == null)
+      return this.offlineMembers.getSnapshot();
+
-    if (dif == null) return this.equalMembers.getSnapshot();
+    if (dif == null)
+      return this.equalMembers.getSnapshot();
+
+
-      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - member offline {}", getDiskStoreID().abbrev(), this.getName(), persistentID);
+      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - member offline {}",
+          getDiskStoreID().abbrev(), this.getName(), persistentID);
+
-      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - member offline and equal {}", getDiskStoreID().abbrev(), this.getName(), persistentID);
+      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - member offline and equal {}",
+          getDiskStoreID().abbrev(), this.getName(), persistentID);
+
-      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - member online {}", getDiskStoreID().abbrev(), this.getName(), persistentID);
+      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - member online {}",
+          getDiskStoreID().abbrev(), this.getName(), persistentID);
+
-      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - member removed {}", getDiskStoreID().abbrev(), this.getName(), persistentID);
+      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - member removed {}",
+          getDiskStoreID().abbrev(), this.getName(), persistentID);
+
-      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - member revoked {}", getDiskStoreID().abbrev(), this.getName(), revokedPattern);
+      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - member revoked {}",
+          getDiskStoreID().abbrev(), this.getName(), revokedPattern);
+
-      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - initializing local id: {}", getDiskStoreID().abbrev(), this.getName(), getMyInitializingID());
+      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - initializing local id: {}",
+          getDiskStoreID().abbrev(), this.getName(), getMyInitializingID());
+
-      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - initialized local id: {}", getDiskStoreID().abbrev(), this.getName(), getMyPersistentID());
+      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - initialized local id: {}",
+          getDiskStoreID().abbrev(), this.getName(), getMyPersistentID());
+
+
+
+
-  
+
-    //Clean up the state if we were ready to recover this region
-    if(isReadyForRecovery()) {
+    // Clean up the state if we were ready to recover this region
+    if (isReadyForRecovery()) {
-        CustomEntryConcurrentHashMap<Object, Object> other = ((AbstractRegionMap)this.entries)._getMap();
-        Iterator<Map.Entry<Object, Object>> it = other
-            .entrySetWithReusableEntries().iterator();
+        CustomEntryConcurrentHashMap<Object, Object> other =
+            ((AbstractRegionMap) this.entries)._getMap();
+        Iterator<Map.Entry<Object, Object>> it = other.entrySetWithReusableEntries().iterator();
-          RegionEntry oldRe = (RegionEntry)me.getValue();
+          RegionEntry oldRe = (RegionEntry) me.getValue();
-    
+
-        logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - endDestroyDataStorage: {}", getDiskStoreID().abbrev(), this.getName(), getMyPersistentID());
+        logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - endDestroyDataStorage: {}",
+            getDiskStoreID().abbrev(), this.getName(), getMyPersistentID());
-      this.ds.endDestroyRegion(region, (DiskRegion)this);
+      this.ds.endDestroyRegion(region, (DiskRegion) this);
-        logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - endDestroy: {}", getDiskStoreID().abbrev(), this.getName(), getMyPersistentID());
+        logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - endDestroy: {}",
+            getDiskStoreID().abbrev(), this.getName(), getMyPersistentID());
-    
+
-      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - beginDestroy: {}", getDiskStoreID().abbrev(), this.getName(), getMyPersistentID());
+      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - beginDestroy: {}",
+          getDiskStoreID().abbrev(), this.getName(), getMyPersistentID());
-   * Destroy the data storage this this disk region. Destroying the
-   * data storage leaves the persistent view, but removes
-   * the data.
+   * Destroy the data storage this this disk region. Destroying the data storage leaves the
+   * persistent view, but removes the data.
-    this.ds.beginDestroyDataStorage((DiskRegion)this);
+    this.ds.beginDestroyDataStorage((DiskRegion) this);
-      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - beginDestroyDataStorage: {}", getDiskStoreID().abbrev(), this.getName(), getMyPersistentID());
+      logger.trace(LogMarker.PERSIST, "PersistentView {} - {} - beginDestroyDataStorage: {}",
+          getDiskStoreID().abbrev(), this.getName(), getMyPersistentID());
-  
-  public void createDataStorage() {
-  }
+
+  public void createDataStorage() {}
+
-  
+
-   * Total number of entries recovered by restoring from backup. Its initialized
-   * right after a recovery but may be updated later as recovered entries go
-   * away due to updates and destroys.
+   * Total number of entries recovered by restoring from backup. Its initialized right after a
+   * recovery but may be updated later as recovered entries go away due to updates and destroys.
-  
+
-//      if (result != null) {
-//        result.changeOwner(lr);
-//      }
+      // if (result != null) {
+      // result.changeOwner(lr);
+      // }
-  
+
-      //there because we don't have the value length at that point. So leave
-      //those stats alone.
+      // there because we don't have the value length at that point. So leave
+      // those stats alone.
-      lr.initializeStats(this.getNumEntriesInVM(), this.getNumOverflowOnDisk(), this.getNumOverflowBytesOnDisk());
+      lr.initializeStats(this.getNumEntriesInVM(), this.getNumOverflowOnDisk(),
+          this.getNumOverflowBytesOnDisk());
-  
+
+
-  
+
-  
+
-  
+
-  
+
+
+
-  
+
+
-    
+
+
+
+
-   * Returns true if this region maintains a backup of all its keys and values
-   * on disk. Returns false if only values that will not fit in memory are
-   * written to disk.
+   * Returns true if this region maintains a backup of all its keys and values on disk. Returns
+   * false if only values that will not fit in memory are written to disk.
+
-    String msg = name + ":"
-      + " -lru=" + getEvictionAttributes().getAlgorithm();
+    String msg = name + ":" + " -lru=" + getEvictionAttributes().getAlgorithm();
-    msg += " -concurrencyLevel=" + getConcurrencyLevel()
-      + " -initialCapacity=" + getInitialCapacity()
-      + " -loadFactor=" + getLoadFactor()
-      + " -offHeap=" + getOffHeap()
-      + " -compressor=" + (getCompressorClassName() == null ? "none" : getCompressorClassName())
-      + " -statisticsEnabled=" + getStatisticsEnabled();
+    msg += " -concurrencyLevel=" + getConcurrencyLevel() + " -initialCapacity="
+        + getInitialCapacity() + " -loadFactor=" + getLoadFactor() + " -offHeap=" + getOffHeap()
+        + " -compressor=" + (getCompressorClassName() == null ? "none" : getCompressorClassName())
+        + " -statisticsEnabled=" + getStatisticsEnabled();
-      msg += " drId=" + getId()
-        + " isBucket=" + isBucket()
-        + " clearEntryId=" + getClearOplogEntryId()
-        + " MyInitializingID=<" + getMyInitializingID() + ">"
-        + " MyPersistentID=<" + getMyPersistentID() + ">"
-        + " onlineMembers=" + getOnlineMembers()
-        + " offlineMembers=" + getOfflineMembers()
-        + " equalsMembers=" + getOfflineAndEqualMembers();
+      msg += " drId=" + getId() + " isBucket=" + isBucket() + " clearEntryId="
+          + getClearOplogEntryId() + " MyInitializingID=<" + getMyInitializingID() + ">"
+          + " MyPersistentID=<" + getMyPersistentID() + ">" + " onlineMembers=" + getOnlineMembers()
+          + " offlineMembers=" + getOfflineMembers() + " equalsMembers="
+          + getOfflineAndEqualMembers();
-  
+
-    String msg = name + ":"
-      + " -lru=" + getEvictionAttributes().getAlgorithm();
-    
-    sb.append(name); sb.append(lineSeparator);
-    sb.append("lru=" + getEvictionAttributes().getAlgorithm()); sb.append(lineSeparator);
-    
+    String msg = name + ":" + " -lru=" + getEvictionAttributes().getAlgorithm();
+
+    sb.append(name);
+    sb.append(lineSeparator);
+    sb.append("lru=" + getEvictionAttributes().getAlgorithm());
+    sb.append(lineSeparator);
+
-      
+
-    
-    sb.append("-concurrencyLevel=" + getConcurrencyLevel()); sb.append(lineSeparator);
-    sb.append("-initialCapacity=" + getInitialCapacity()); sb.append(lineSeparator);
-    sb.append("-loadFactor=" + getLoadFactor()); sb.append(lineSeparator);
-    sb.append("-offHeap=" + getOffHeap()); sb.append(lineSeparator);
-    sb.append("-compressor=" + (getCompressorClassName() == null ? "none" : getCompressorClassName())); sb.append(lineSeparator);
-    sb.append("-statisticsEnabled=" + getStatisticsEnabled()); sb.append(lineSeparator);
-    
+
+    sb.append("-concurrencyLevel=" + getConcurrencyLevel());
+    sb.append(lineSeparator);
+    sb.append("-initialCapacity=" + getInitialCapacity());
+    sb.append(lineSeparator);
+    sb.append("-loadFactor=" + getLoadFactor());
+    sb.append(lineSeparator);
+    sb.append("-offHeap=" + getOffHeap());
+    sb.append(lineSeparator);
+    sb.append(
+        "-compressor=" + (getCompressorClassName() == null ? "none" : getCompressorClassName()));
+    sb.append(lineSeparator);
+    sb.append("-statisticsEnabled=" + getStatisticsEnabled());
+    sb.append(lineSeparator);
+
-      sb.append("drId=" + getId()); sb.append(lineSeparator);
-      sb.append("isBucket=" + isBucket()); sb.append(lineSeparator);
-      sb.append("clearEntryId=" + getClearOplogEntryId()); sb.append(lineSeparator);
-      sb.append("MyInitializingID=<" + getMyInitializingID() + ">"); sb.append(lineSeparator);
-      sb.append("MyPersistentID=<" + getMyPersistentID() + ">"); sb.append(lineSeparator);
-      sb.append("onlineMembers=" + getOnlineMembers()); sb.append(lineSeparator);
-      sb.append("offlineMembers=" + getOfflineMembers()); sb.append(lineSeparator);
-      sb.append("equalsMembers=" + getOfflineAndEqualMembers()); sb.append(lineSeparator);
-      sb.append("flags=").append(getFlags()); sb.append(lineSeparator);
+      sb.append("drId=" + getId());
+      sb.append(lineSeparator);
+      sb.append("isBucket=" + isBucket());
+      sb.append(lineSeparator);
+      sb.append("clearEntryId=" + getClearOplogEntryId());
+      sb.append(lineSeparator);
+      sb.append("MyInitializingID=<" + getMyInitializingID() + ">");
+      sb.append(lineSeparator);
+      sb.append("MyPersistentID=<" + getMyPersistentID() + ">");
+      sb.append(lineSeparator);
+      sb.append("onlineMembers=" + getOnlineMembers());
+      sb.append(lineSeparator);
+      sb.append("offlineMembers=" + getOfflineMembers());
+      sb.append(lineSeparator);
+      sb.append("equalsMembers=" + getOfflineAndEqualMembers());
+      sb.append(lineSeparator);
+      sb.append("flags=").append(getFlags());
+      sb.append(lineSeparator);
-  
+
-    //TODO - DAN - make this a flag
-//    if (isBucket() && !DiskStoreImpl.TRACE_RECOVERY) {
-//      name = getPrName();
-//    }
-    
+    // TODO - DAN - make this a flag
+    // if (isBucket() && !DiskStoreImpl.TRACE_RECOVERY) {
+    // name = getPrName();
+    // }
+
-    
+
-    
+
+   * 
-    
+
+   * 
-    
+
-    
+
-   * This method was added to fix bug 40192.
-   * It is like getBytesAndBits except it will return Token.REMOVE_PHASE1 if
-   * the htreeReference has changed (which means a clear was done).
+   * This method was added to fix bug 40192. It is like getBytesAndBits except it will return
+   * Token.REMOVE_PHASE1 if the htreeReference has changed (which means a clear was done).
+   * 
-    try {    
+    try {
-    }
-    finally {
+    } finally {
-  
+
-  
+
-    //TODO - RVV - I'm not sure about this recordGCVersion method. It seems
-    //like it's not doing the right thing if the current member is the member
-    //we just recovered.
+    // TODO - RVV - I'm not sure about this recordGCVersion method. It seems
+    // like it's not doing the right thing if the current member is the member
+    // we just recovered.
-    
+
-  public void recordRecoveredVersonHolder(VersionSource member,
-      RegionVersionHolder versionHolder, boolean latestOplog) {
+
+  public void recordRecoveredVersonHolder(VersionSource member, RegionVersionHolder versionHolder,
+      boolean latestOplog) {
-  
+
-  
+
-   * Indicate that the current RVV for this disk region does not
-   * accurately reflect what has been recorded on disk. This is true
-   * while we are in the middle of a GII, because we record the new RVV
-   * at the beginning of the GII. If we recover in this state, we need to
-   * know that the recovered RVV is not something we can use to do a delta
-   * GII.
+   * Indicate that the current RVV for this disk region does not accurately reflect what has been
+   * recorded on disk. This is true while we are in the middle of a GII, because we record the new
+   * RVV at the beginning of the GII. If we recover in this state, we need to know that the
+   * recovered RVV is not something we can use to do a delta GII.
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-    //do nothing. Overriden in ExportDiskRegion
+    // do nothing. Overriden in ExportDiskRegion

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
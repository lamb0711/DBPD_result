Merge remote-tracking branch 'origin/develop' into feature/GEODE-11

+import com.gemstone.gemfire.internal.SocketCloser;
+  
+  /** Set to false once run() is terminating. Using this instead of Thread.isAlive  
+    * as the reader thread may be a pooled thread.
+    */ 
+  private volatile boolean isRunning = false; 
-  // return true if this thread is a reader thread
-    isReaderThread.set(Boolean.TRUE);
+    makeReaderThread(true);
+  private final static void makeReaderThread(boolean v) {
+    isReaderThread.set(v);
+  }
+  // return true if this thread is a reader thread
-  Thread readerThread;
+  private volatile Thread readerThread;
-      c.startReader();
+      c.startReader(t);
-        SocketCreator.asyncClose(s, this.remoteAddr.toString(), null);
+        t.getSocketCloser().asyncClose(s, this.remoteAddr.toString(), null);
+  private final AtomicBoolean asyncCloseCalled = new AtomicBoolean();
+  
-    Runnable r = new Runnable() {
-      public void run() {
-        boolean rShuttingDown = readerShuttingDown;
-        synchronized(stateLock) {
-          if (readerThread != null && readerThread.isAlive() &&
-              !rShuttingDown && connectionState == STATE_READING
-              || connectionState == STATE_READING_ACK) {
-            readerThread.interrupt();
-          }
-        }
-      }
-    };
+
-      r.run();
+      prepareForAsyncClose();
-      SocketCreator.asyncClose(this.socket, String.valueOf(this.remoteAddr), r);
+      if (this.asyncCloseCalled.compareAndSet(false, true)) {
+        Socket s = this.socket;
+        if (s != null && !s.isClosed()) {
+          prepareForAsyncClose();
+          this.owner.getSocketCloser().asyncClose(s, String.valueOf(this.remoteAddr), null);
+        }
+      }
+  private void prepareForAsyncClose() {
+    synchronized(stateLock) {
+      if (readerThread != null && isRunning && !readerShuttingDown
+          && (connectionState == STATE_READING || connectionState == STATE_READING_ACK)) {
+        readerThread.interrupt();
+      }
+    }
+  }
-  private void attemptHandshake() throws IOException {
+  private void attemptHandshake(ConnectionTable connTable) throws IOException {
-    startReader(); // this reader only reads the handshake and then exits
+    startReader(connTable); // this reader only reads the handshake and then exits
-            conn.attemptHandshake();
+            conn.attemptHandshake(t);
-    if (!beingSick && this.readerThread != null && !isIBM && this.readerThread.isAlive()
-        && this.readerThread != Thread.currentThread()) {
-      try {
-        this.readerThread.join(500);
-        if (this.readerThread.isAlive() && !this.readerShuttingDown
-            && owner.getDM().getRootCause() == null) { // don't wait twice if there's a system failure
-          this.readerThread.join(1500);
-          if (this.readerThread.isAlive()) {
-            logger.info(LocalizedMessage.create(LocalizedStrings.Connection_TIMED_OUT_WAITING_FOR_READERTHREAD_ON_0_TO_FINISH, this));
+    {
+      // Now that readerThread is returned to a pool after we close
+      // we need to be more careful not to join on a thread that belongs
+      // to someone else.
+      Thread readerThreadSnapshot = this.readerThread;
+      if (!beingSick && readerThreadSnapshot != null && !isIBM
+          && this.isRunning && !this.readerShuttingDown
+          && readerThreadSnapshot != Thread.currentThread()) {
+        try {
+          readerThreadSnapshot.join(500);
+          readerThreadSnapshot = this.readerThread;
+          if (this.isRunning && !this.readerShuttingDown
+              && readerThreadSnapshot != null
+              && owner.getDM().getRootCause() == null) { // don't wait twice if there's a system failure
+            readerThreadSnapshot.join(1500);
+            if (this.isRunning) {
+              logger.info(LocalizedMessage.create(LocalizedStrings.Connection_TIMED_OUT_WAITING_FOR_READERTHREAD_ON_0_TO_FINISH, this));
+            }
+        catch (IllegalThreadStateException ignore) {
+          // ignored - thread already stopped
+        }
+        catch (InterruptedException ignore) {
+          Thread.currentThread().interrupt();
+          // but keep going, we're trying to close.
+        }
-      catch (IllegalThreadStateException ignore) {
-        // ignored - thread already stopped
-      }
-      catch (InterruptedException ignore) {
-        Thread.currentThread().interrupt();
-        // but keep going, we're trying to close.
-      }
-    } // !onlyCleanup
+    }
-  private void startReader() {
-    ThreadGroup group =
-      LoggingThreadGroup.createThreadGroup("P2P Reader Threads", logger);
-    Assert.assertTrue(this.readerThread == null);
-    this.readerThread =
-      new Thread(group, this, p2pReaderName());
-    this.readerThread.setDaemon(true);
-    stopped = false;
-    this.readerThread.start();
-  }
+  private void startReader(ConnectionTable connTable) { 
+    Assert.assertTrue(!this.isRunning); 
+    stopped = false; 
+    this.isRunning = true; 
+    connTable.executeCommand(this);  
+  } 
+    this.readerThread = Thread.currentThread();
+    this.readerThread.setName(p2pReaderName());
-    if (this.isReceiver) {
-      makeReaderThread();
-    }
+    makeReaderThread(this.isReceiver);
+      this.readerThread.setName("unused p2p reader");
+      synchronized (this.stateLock) {
+        this.isRunning = false;
+        this.readerThread = null;
+      }
-  protected byte connectionState;
+  protected byte connectionState = STATE_IDLE;

INS26 INS40 INS23 INS31 INS23 MOV31 INS29 INS83 INS83 INS39 INS59 INS83 INS83 INS83 INS39 INS42 INS8 UPD83 INS44 INS83 INS83 INS83 INS83 INS43 INS59 INS8 UPD83 UPD42 INS44 INS44 INS8 INS65 INS42 INS9 INS21 INS39 INS42 INS42 INS42 INS14 INS25 INS43 INS42 INS43 INS42 INS21 MOV21 INS21 INS21 MOV21 MOV21 MOV21 INS42 INS66 INS66 INS32 INS43 INS42 INS8 INS8 INS42 UPD42 MOV42 INS32 INS7 INS32 INS7 INS32 INS42 INS9 INS42 INS42 INS21 INS25 INS42 INS8 UPD42 MOV42 UPD42 MOV42 INS38 INS22 INS9 INS42 INS42 INS52 MOV22 INS32 MOV22 INS42 MOV32 MOV22 MOV21 INS51 INS32 INS32 INS8 MOV27 INS60 MOV25 INS22 INS52 INS42 UPD42 MOV42 INS42 INS22 INS8 INS42 INS42 INS22 INS42 INS9 INS9 MOV60 MOV25 INS36 MOV43 INS59 INS27 INS52 INS42 UPD42 INS45 INS52 INS42 INS21 MOV21 INS52 INS42 UPD43 INS27 INS27 INS42 MOV22 INS27 MOV27 INS7 INS7 UPD42 UPD42 MOV22 INS27 INS38 INS21 INS42 UPD42 MOV27 MOV27 MOV27 MOV38 INS42 INS22 INS9 MOV22 INS33 INS32 INS42 INS33 INS32 INS32 MOV32 INS22 INS21 INS52 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 UPD42 INS33 MOV52 UPD42 MOV42 INS32 INS7 INS27 INS22 UPD42 MOV42 INS42 INS42 INS34 INS42 MOV22 INS27 MOV27 INS52 INS42 INS42 INS42 INS22 INS38 INS27 INS22 INS52 INS42 INS22 INS42 INS33 INS42 MOV52 UPD42 MOV42 MOV52 UPD42 MOV42 DEL40 DEL42 DEL43 DEL1 DEL14 DEL42 DEL32 DEL21 DEL8 DEL8 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL27 DEL52 DEL42 DEL22 DEL22 DEL42 DEL32 DEL52 DEL42 DEL22 DEL27 DEL42 DEL34 DEL32 DEL22 DEL42 DEL32 DEL27 DEL22 DEL42 DEL32 DEL43 DEL42 DEL45 DEL42 DEL32 DEL59 DEL60 DEL8 DEL32 DEL42 DEL52 DEL14 DEL7 DEL8 DEL25 DEL9 DEL42 DEL42 DEL33 DEL27 DEL32
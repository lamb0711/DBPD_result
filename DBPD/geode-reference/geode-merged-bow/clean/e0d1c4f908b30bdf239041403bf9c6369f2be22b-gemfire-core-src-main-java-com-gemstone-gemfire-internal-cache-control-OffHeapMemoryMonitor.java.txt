Merge remote-tracking branch 'origin/develop' into feature/GEODE-77

+    if (!mightSendEvent(bytesUsed)) {
+      return;
+    }
-   *          Number of bytes of heap memory currently used.
+   *          Number of bytes of off-heap memory currently used.
-      MemoryState oldState = this.mostRecentEvent.getState();
-      MemoryState newState = this.thresholds.computeNextState(oldState, bytesUsed);
+      final MemoryEvent mre = this.mostRecentEvent;
+      final MemoryState oldState = mre.getState();
+      final MemoryThresholds thresholds = this.thresholds;
+      MemoryState newState = thresholds.computeNextState(oldState, bytesUsed);
-        MemoryEvent event = new MemoryEvent(ResourceType.OFFHEAP_MEMORY, oldState, newState, this.cache.getMyId(), bytesUsed, true,
-            this.thresholds);
+        MemoryEvent event = new MemoryEvent(ResourceType.OFFHEAP_MEMORY, oldState, newState, this.cache.getMyId(), bytesUsed, true, thresholds);
-      // The state didn't change.  However, if the state isn't normal and we've
-      // been in that state for a while, send another event with the updated
-      // memory usage.
-      } else if (!oldState.isNormal() && (System.currentTimeMillis() - this.mostRecentEvent.getEventTime()) > 1000) {
-        MemoryEvent event = new MemoryEvent(ResourceType.OFFHEAP_MEMORY, oldState, newState, this.cache.getMyId(), bytesUsed, true,
-            this.thresholds);
+      } else if (!oldState.isNormal()
+          && bytesUsed != mre.getBytesUsed()
+          && this.deliverNextAbnormalEvent) {
+        this.deliverNextAbnormalEvent = false;
+        MemoryEvent event = new MemoryEvent(ResourceType.OFFHEAP_MEMORY, oldState, newState, this.cache.getMyId(), bytesUsed, true, thresholds);
+  
+  /**
+   * Return true if the given number of bytes compared to the
+   * current monitor state would generate a new memory event.
+   * 
+   * @param bytesUsed
+   *          Number of bytes of off-heap memory currently used.
+   * @return true if a new event might need to be sent
+   */
+  private boolean mightSendEvent(long bytesUsed) {
+    final MemoryEvent mre = this.mostRecentEvent;
+    final MemoryState oldState = mre.getState();
+    final MemoryThresholds thresholds = this.thresholds;
+    MemoryState newState = thresholds.computeNextState(oldState, bytesUsed);
+    if (oldState != newState) {
+      return true;
+    } else if (!oldState.isNormal()
+        && bytesUsed != mre.getBytesUsed()
+        && this.deliverNextAbnormalEvent) {
+      return true;
+    }
+    return false;
+  }
+  
+  private volatile boolean deliverNextAbnormalEvent = false;
+   
+  /**
+   * Used by the OffHeapMemoryUsageListener to tell us that
+   * the next abnormal event should be delivered even if the
+   * state does not change as long as the memory usage changed.
+   * For some reason, unknown to me, if we stay in an abnormal
+   * state for more than a second then we want to send another
+   * event to update the memory usage.
+   */
+  void deliverNextAbnormalEvent() {
+    this.deliverNextAbnormalEvent = true;
+  }
-    volatile long offHeapMemoryUsed; // In bytes
+    long offHeapMemoryUsed; // In bytes
-
+      long lastOffHeapMemoryUsed;
+      synchronized (this) {
+        lastOffHeapMemoryUsed = this.offHeapMemoryUsed;
+      }
-        final long saveOffHeapMemoryUsed = this.offHeapMemoryUsed;
-        updateStateAndSendEvent(saveOffHeapMemoryUsed);
+        updateStateAndSendEvent(lastOffHeapMemoryUsed);
-          if (saveOffHeapMemoryUsed == this.offHeapMemoryUsed && !this.stopRequested) {
+          if (lastOffHeapMemoryUsed == this.offHeapMemoryUsed && !this.stopRequested) {
-              this.wait();
+              do {
+                this.wait(1000);
+                if (this.offHeapMemoryUsed == lastOffHeapMemoryUsed) {
+                  // The wait timed out. So tell the OffHeapMemoryMonitor
+                  // that we need an event if the state is not normal.
+                  deliverNextAbnormalEvent();
+                } else {
+                  // we have been notified so exit the inner while loop
+                  // and call updateStateAndSendEvent.
+                  lastOffHeapMemoryUsed = this.offHeapMemoryUsed;
+                  break;
+                }
+              } while (true);

INS31 INS23 INS31 INS29 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS59 INS29 INS39 INS42 INS8 INS25 INS65 INS65 INS65 INS39 INS42 INS60 INS60 INS60 INS60 INS25 INS41 INS42 INS9 INS65 INS21 INS38 INS8 UPD66 INS66 INS66 INS42 INS66 INS66 INS83 INS43 INS59 INS83 INS43 INS59 INS83 INS43 INS59 MOV43 INS59 INS27 INS8 INS25 INS9 INS66 INS66 INS66 INS66 INS66 INS66 INS7 INS60 INS51 INS32 INS41 INS60 INS60 INS42 INS42 MOV22 INS42 INS42 INS32 INS42 INS42 MOV22 INS42 INS32 INS42 INS42 INS41 INS27 INS8 INS22 INS9 INS39 INS59 INS52 INS8 INS42 INS42 INS83 INS43 INS83 INS43 INS59 INS83 INS43 MOV59 MOV43 INS59 INS42 INS42 INS42 INS42 INS42 INS42 INS9 INS27 INS22 INS41 INS52 INS42 INS42 INS21 INS42 UPD42 MOV22 INS42 INS42 INS32 INS42 INS42 MOV22 INS42 INS32 INS38 INS27 INS52 INS42 INS9 INS7 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 UPD27 INS22 INS21 INS32 INS42 INS32 INS42 MOV22 UPD42 MOV38 INS27 INS52 INS42 INS7 MOV43 INS42 INS42 INS42 INS42 MOV43 INS42 INS42 INS32 INS22 INS9 UPD42 MOV42 UPD42 MOV42 INS52 INS42 MOV43 INS42 UPD42 MOV22 INS8 INS19 INS8 INS9 MOV21 INS25 INS27 INS8 INS8 INS34 INS22 INS42 INS21 INS21 INS10 INS52 INS42 INS32 INS7 INS42 INS42 INS22 INS52 INS42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL42 DEL32 DEL32 DEL27 DEL36 DEL34 DEL83 DEL83 DEL39 DEL42 DEL59 DEL60 DEL8
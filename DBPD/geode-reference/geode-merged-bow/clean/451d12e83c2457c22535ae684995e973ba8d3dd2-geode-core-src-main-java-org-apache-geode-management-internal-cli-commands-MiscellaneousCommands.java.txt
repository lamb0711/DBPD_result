GEODE-2919: Provide finer grained security

 - For full details, see https://cwiki.apache.org/confluence/display/GEODE/Finer+grained+security

+import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.PrintWriter;
+import java.text.MessageFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.zip.DataFormatException;
+import java.util.zip.GZIPInputStream;
+
+import javax.management.ObjectName;
+
+import org.apache.logging.log4j.Logger;
+import org.springframework.shell.core.annotation.CliCommand;
+import org.springframework.shell.core.annotation.CliOption;
+
-import org.apache.geode.management.internal.cli.result.CommandResultException;
-import org.apache.logging.log4j.Logger;
-import org.springframework.shell.core.annotation.CliAvailabilityIndicator;
-import org.springframework.shell.core.annotation.CliCommand;
-import org.springframework.shell.core.annotation.CliOption;
-
-import java.io.BufferedInputStream;
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.io.PrintWriter;
-import java.text.MessageFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.zip.DataFormatException;
-import java.util.zip.GZIPInputStream;
-import javax.management.ObjectName;
-      // convert to mili-seconds
+      // convert to milliseconds
-          Set<DistributedMember> lsSet = new HashSet<DistributedMember>();
+          Set<DistributedMember> lsSet = new HashSet<>();
-      Set<DistributedMember> mgrSet = new HashSet<DistributedMember>();
+      Set<DistributedMember> mgrSet = new HashSet<>();
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-    Result result = null;
+    Result result;
-    Set<DistributedMember> dsMembers = new HashSet<DistributedMember>();
+    Set<DistributedMember> dsMembers = new HashSet<>();
-      List<?> resultList = null;
+      List<?> resultList;
-      for (int i = 0; i < resultList.size(); i++) {
-        Object object = resultList.get(i);
+      for (Object object : resultList) {
-      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS}, mandatory = false,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},
-      @CliOption(key = CliStrings.GROUP, mandatory = false,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          optionContext = ConverterHint.MEMBERGROUP,
+      @CliOption(key = CliStrings.GROUP, optionContext = ConverterHint.MEMBERGROUP,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-    Result result = null;
+    Result result;
-    Map<String, DistributedMember> hostMemberMap = new HashMap<String, DistributedMember>();
-    Map<String, List<String>> hostMemberListMap = new HashMap<String, List<String>>();
+    Map<String, DistributedMember> hostMemberMap = new HashMap<>();
+    Map<String, List<String>> hostMemberListMap = new HashMap<>();
-        Set<String> notFoundMembers = new HashSet<String>();
+        Set<String> notFoundMembers = new HashSet<>();
-        Set<DistributedMember> membersToExecuteOn = null;
+        Set<DistributedMember> membersToExecuteOn;
-      String lineSeparatorToUse = null;
+      String lineSeparatorToUse;
-        Set<DistributedMember> membersToExecuteOn =
-            new HashSet<DistributedMember>(hostMemberMap.values());
+        Set<DistributedMember> membersToExecuteOn = new HashSet<>(hostMemberMap.values());
-        for (int i = 0; i < resultList.size(); i++) {
-          NetstatFunctionResult netstatFunctionResult = (NetstatFunctionResult) resultList.get(i);
+        for (Object aResultList : resultList) {
+          NetstatFunctionResult netstatFunctionResult = (NetstatFunctionResult) aResultList;
-    List<String> list = null;
+    List<String> list;
-      list = new ArrayList<String>();
+      list = new ArrayList<>();
-  @CliMetaData(shellOnly = false, relatedTopic = {CliStrings.TOPIC_GEODE_DEBUG_UTIL})
+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DEBUG_UTIL})
-    Result result = null;
+    Result result;
-  @CliMetaData(shellOnly = false, relatedTopic = {CliStrings.TOPIC_GEODE_DEBUG_UTIL})
+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DEBUG_UTIL})
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          help = CliStrings.SHOW_LOG_LINE_NUM_HELP, mandatory = false) int numberOfLines) {
-    Result result = null;
+          help = CliStrings.SHOW_LOG_LINE_NUM_HELP) int numberOfLines) {
+    Result result;
-      MemberMXBean bean = null;
+      MemberMXBean bean;
-  @CliMetaData(shellOnly = false, relatedTopic = {CliStrings.TOPIC_GEODE_DEBUG_UTIL})
+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DEBUG_UTIL})
-    Result result = null;
+    Result result;
-      Map<String, byte[]> dumps = new HashMap<String, byte[]>();
+      Map<String, byte[]> dumps = new HashMap<>();
-        // we dont to show any info result
+        // we don't to show any info result
-    String filePath = null;
-    OutputStream os = null;
-    PrintWriter ps = null;
-    File outputFile = null;
+    String filePath;
+    PrintWriter ps;
+    File outputFile;
-    try {
-      outputFile = new File(fileName);
-      os = new FileOutputStream(outputFile);
+    outputFile = new File(fileName);
+    try (OutputStream os = new FileOutputStream(outputFile)) {
-      for (Map.Entry<String, byte[]> entry : dumps.entrySet()) {
+      for (Entry<String, byte[]> entry : dumps.entrySet()) {
-    } finally {
-      os.close();
-  @CliMetaData(shellOnly = false, relatedTopic = {CliStrings.TOPIC_GEODE_STATISTICS})
+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_STATISTICS})
-    Result result = null;
+    Result result;
-  private ResultData getSystemWideMetrics(String export_to_report_to, String[] categoriesArr)
-      throws Exception {
+  private ResultData getSystemWideMetrics(String export_to_report_to, String[] categoriesArr) {
-    final ManagementService managmentService = ManagementService.getManagementService(cache);
-    DistributedSystemMXBean dsMxBean = managmentService.getDistributedSystemMXBean();
+    final ManagementService managementService = ManagementService.getManagementService(cache);
+    DistributedSystemMXBean dsMxBean = managementService.getDistributedSystemMXBean();
-        Set<String> checkSet = new HashSet<String>(categoriesMap.keySet());
+        Set<String> checkSet = new HashSet<>(categoriesMap.keySet());
-      if (categoriesMap.get("cluster").booleanValue()) {
+      if (categoriesMap.get("cluster")) {
-      if (categoriesMap.get("cache").booleanValue()) {
+      if (categoriesMap.get("cache")) {
-      if (categoriesMap.get("diskstore").booleanValue()) {
+      if (categoriesMap.get("diskstore")) {
-      if (categoriesMap.get("query").booleanValue()) {
+      if (categoriesMap.get("query")) {
-    ObjectName csMxBeanName = null;
+    ObjectName csMxBeanName;
-        Set<String> checkSet = new HashSet<String>(categoriesMap.keySet());
+        Set<String> checkSet = new HashSet<>(categoriesMap.keySet());
-      if (categoriesMap.get("member").booleanValue()) {
+      if (categoriesMap.get("member")) {
-      if (categoriesMap.get("jvm").booleanValue()) {
+      if (categoriesMap.get("jvm")) {
-      if (categoriesMap.get("region").booleanValue()) {
+      if (categoriesMap.get("region")) {
-        // Not available from stats. After Stats re-org it will be avaialble
+        // Not available from stats. After Stats re-org it will be available
-      if (categoriesMap.get("serialization").booleanValue()) {
+      if (categoriesMap.get("serialization")) {
-      if (categoriesMap.get("communication").booleanValue()) {
+      if (categoriesMap.get("communication")) {
-      if (categoriesMap.get("function").booleanValue()) {
+      if (categoriesMap.get("function")) {
-        // Not Avaialble from Stats
-        // writeToTableAndCsv(metricsTable, "", "funcExecutionQueueSize",
-        // memberMxBean.getFuncExecutionQueueSize(), csvBuilder);
-      if (categoriesMap.get("transaction").booleanValue()) {
+      if (categoriesMap.get("transaction")) {
-      if (categoriesMap.get("diskstore").booleanValue()) {
+      if (categoriesMap.get("diskstore")) {
-      if (categoriesMap.get("lock").booleanValue()) {
+      if (categoriesMap.get("lock")) {
-      if (categoriesMap.get("eviction").booleanValue()) {
+      if (categoriesMap.get("eviction")) {
-      if (categoriesMap.get("distribution").booleanValue()) {
+      if (categoriesMap.get("distribution")) {
-            memberMxBean.getInitialImagesInProgres(), csvBuilder);
+            memberMxBean.getInitialImagesInProgress(), csvBuilder);
-      if (categoriesMap.get("offheap").booleanValue()) {
+      if (categoriesMap.get("offheap")) {
-        Set<String> checkSet = new HashSet<String>(categoriesMap.keySet());
+        Set<String> checkSet = new HashSet<>(categoriesMap.keySet());
-      if (categoriesMap.get("cluster").booleanValue()) {
+      if (categoriesMap.get("cluster")) {
-      if (categoriesMap.get("region").booleanValue()) {
+      if (categoriesMap.get("region")) {
-      if (categoriesMap.get("partition").booleanValue()) {
+      if (categoriesMap.get("partition")) {
-      if (categoriesMap.get("diskstore").booleanValue()) {
+      if (categoriesMap.get("diskstore")) {
-      if (categoriesMap.get("callback").booleanValue()) {
+      if (categoriesMap.get("callback")) {
-      if (categoriesMap.get("eviction").booleanValue()) {
+      if (categoriesMap.get("eviction")) {
-        Set<String> checkSet = new HashSet<String>(categoriesMap.keySet());
+        Set<String> checkSet = new HashSet<>(categoriesMap.keySet());
-      if (categoriesMap.get("region").booleanValue()) {
+      if (categoriesMap.get("region")) {
-      if (categoriesMap.get("partition").booleanValue()) {
+      if (categoriesMap.get("partition")) {
-      if (categoriesMap.get("diskstore").booleanValue()) {
+      if (categoriesMap.get("diskstore")) {
-      if (categoriesMap.get("callback").booleanValue()) {
+      if (categoriesMap.get("callback")) {
-      if (categoriesMap.get("eviction").booleanValue()) {
+      if (categoriesMap.get("eviction")) {
-    metricsTable.accumulate(CliStrings.SHOW_METRICS__VALUE__HEADER, Double.valueOf(metricValue));
+    metricsTable.accumulate(CliStrings.SHOW_METRICS__VALUE__HEADER, metricValue);
-    Set<String> categoriesSet = new HashSet<String>();
-    for (String category : categories) {
-      categoriesSet.add(category);
-    }
+    Set<String> categoriesSet = new HashSet<>();
+    Collections.addAll(categoriesSet, categories);
-    Map<String, Boolean> categories = new HashMap<String, Boolean>();
+    Map<String, Boolean> categories = new HashMap<>();
-    Map<String, Boolean> categories = new HashMap<String, Boolean>();
+    Map<String, Boolean> categories = new HashMap<>();
-    Map<String, Boolean> categories = new HashMap<String, Boolean>();
+    Map<String, Boolean> categories = new HashMap<>();
-      Set<DistributedMember> dsMembers = new HashSet<DistributedMember>();
+      Set<DistributedMember> dsMembers = new HashSet<>();
-          Iterator<DistributedMember> it = ds.iterator();
-          while (it.hasNext()) {
-            DistributedMember mem = it.next();
+          for (DistributedMember mem : ds) {
-          continue;
-    Set<String> setDifference = new HashSet<String>();
+    Set<String> setDifference = new HashSet<>();

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 UPD40 MOV21 MOV21 INS60 MOV60 INS59 MOV59 INS58 MOV74 INS59 INS70 INS42 INS14 UPD42 MOV43 INS59 UPD42 MOV42 UPD42 UPD42 INS42 UPD42 INS42 INS14 UPD74 INS44 INS42 MOV8 INS74 UPD74 INS42 MOV14 UPD42 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 MOV32 UPD74 INS74 UPD74 UPD74 UPD74 INS43 INS42 MOV43 INS70 UPD74 MOV43 UPD74 INS42 INS44 INS42 MOV8 UPD74 UPD74 UPD43 UPD74 MOV43 INS42 INS42 INS70 UPD74 UPD74 MOV43 UPD74 UPD74 UPD42 UPD74 UPD74 INS44 INS42 MOV8 MOV43 INS42 UPD74 MOV43 INS42 DEL40 DEL26 DEL40 DEL26 DEL42 DEL43 DEL42 DEL43 DEL42 DEL40 DEL80 DEL42 DEL40 DEL80 DEL33 DEL42 DEL43 DEL33 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL24 DEL42 DEL9 DEL80 DEL42 DEL40 DEL80 DEL42 DEL9 DEL80 DEL42 DEL40 DEL80 DEL42 DEL40 DEL80 DEL33 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL14 DEL59 DEL42 DEL43 DEL33 DEL33 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL24 DEL33 DEL42 DEL43 DEL42 DEL9 DEL80 DEL33 DEL42 DEL9 DEL80 DEL42 DEL40 DEL80 DEL42 DEL9 DEL80 DEL33 DEL33 DEL42 DEL9 DEL80 DEL33 DEL42 DEL43 DEL39 DEL85 DEL5 DEL33 DEL42 DEL33 DEL59 DEL60 DEL33 DEL33 DEL42 DEL7 DEL21 DEL40 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL9 DEL80 DEL33 DEL42 DEL43 DEL42 DEL43 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL33 DEL42 DEL43 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL8 DEL70 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL18 DEL42 DEL43
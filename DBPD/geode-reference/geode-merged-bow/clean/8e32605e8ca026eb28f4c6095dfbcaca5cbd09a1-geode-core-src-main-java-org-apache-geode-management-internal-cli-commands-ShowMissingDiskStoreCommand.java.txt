GEODE-6329, GEODE-6328: Fix issues with show missing-disk-stores (#3136)

* Using consistent logic for finding missing disk stores

The gfsh command for finding missing disk stores was not ignoring
present disk stores. However, the JMX command was. The gfsh command was also not deduplicating the missing disk stores. Changing the gfsh command to use the JMX logic.

* Making sure member is removed from persistent view

When we start up a member that has persistent data that it should delete
(due to already established redundancy), the member was not correctly
removing members from it's persistent view in
PersistenceAdvisorImpl.updateMembershipView. This was due to the fact
that the destroyOfflineData method was clearing the recoveredMembers
set, but not the underlying persistentMemberView.

The persistentMemberView probably should be preserved, in case the
member is killed and restarted before it gets a new view. So we should
reset the recoveredMembers set to the correct value.

* Simplifying the logic for reporting present disk stores

The logic for reporting what disk stores were actually running on a
node, for the purposes of not reporting those disk stores as missing,
was overly complicated. Due to that, it only included disk stores that
actually had any persistent regions/buckets on that node, rather than
all disk stores.

Refactoring the code to just list all disk stores.
-import java.util.ArrayList;
+import java.util.stream.Collectors;
-import org.apache.geode.internal.cache.persistence.PersistentMemberPattern;
+import org.apache.geode.management.DistributedSystemMXBean;
+import org.apache.geode.management.ManagementService;
+import org.apache.geode.management.PersistentMemberDetails;
-    List<?> results = getMissingDiskStoresList(dataMembers);
+    List<ColocatedRegionDetails> missingRegions = getMissingColocatedRegionList(dataMembers);
-    return toMissingDiskStoresTabularResult(results);
+    DistributedSystemMXBean dsMXBean =
+        ManagementService.getManagementService(getCache()).getDistributedSystemMXBean();
+    PersistentMemberDetails[] missingDiskStores = dsMXBean.listMissingDiskStores();
+
+    return toMissingDiskStoresTabularResult(missingDiskStores, missingRegions);
-  private List<?> getMissingDiskStoresList(Set<DistributedMember> members) {
+  private List<ColocatedRegionDetails> getMissingColocatedRegionList(
+      Set<DistributedMember> members) {
-    final List<?> distributedPersistentRecoveryDetails = new ArrayList<>(results.size());
-    for (final Object result : results) {
-      if (result instanceof Set) {
-        distributedPersistentRecoveryDetails.addAll((Set) result);
-      }
-    }
-    return distributedPersistentRecoveryDetails;
+
+    // Clean up the data. For backwards compatibility, the ShowMissingDiskStoresFunction
+    // sends a List of Sets. Some of the sets are Set<PersistentMemberIds>, some are
+    // Set<ColocatedRegionDetails>. We want to return a List of all of the ColocatedRegionDetails,
+    // and ignore the PersistentMemberIds
+    return results.stream().filter(Set.class::isInstance)
+        .map(Set.class::cast)
+        .flatMap(Set::stream)
+        .filter(ColocatedRegionDetails.class::isInstance)
+        .map(ColocatedRegionDetails.class::cast)
+        .collect(Collectors.toList());
-  private ResultModel toMissingDiskStoresTabularResult(final List<?> resultDetails)
+  private ResultModel toMissingDiskStoresTabularResult(
+      PersistentMemberDetails[] missingDiskStores,
+      final List<ColocatedRegionDetails> missingColocatedRegions)
-    List<PersistentMemberPattern> missingDiskStores = new ArrayList<>();
-    List<ColocatedRegionDetails> missingColocatedRegions = new ArrayList<>();
-    for (Object detail : resultDetails) {
-      if (detail instanceof PersistentMemberPattern) {
-        missingDiskStores.add((PersistentMemberPattern) detail);
-      } else if (detail instanceof ColocatedRegionDetails) {
-        missingColocatedRegions.add((ColocatedRegionDetails) detail);
-      } else {
-        throw new ResultDataException("Unknown type of PersistentRecoveryFailures result");
-      }
-    }
-
-    boolean hasMissingDiskStores = !missingDiskStores.isEmpty();
+    boolean hasMissingDiskStores = missingDiskStores.length != 0;
+
-      for (PersistentMemberPattern persistentMemberDetails : missingDiskStores) {
+      for (PersistentMemberDetails persistentMemberDetails : missingDiskStores) {
-            persistentMemberDetails.getUUID().toString());
-        missingDiskStoreSection.accumulate("Host", persistentMemberDetails.getHost().toString());
+            persistentMemberDetails.getDiskStoreId());
+        missingDiskStoreSection.accumulate("Host", persistentMemberDetails.getHost());

MOV26 INS26 INS26 UPD40 INS40 INS40 UPD40 UPD74 UPD42 INS44 INS60 INS60 INS43 INS41 INS5 INS42 UPD74 UPD42 MOV74 INS43 INS59 INS5 INS59 INS42 INS32 INS43 INS85 INS43 UPD42 INS42 INS42 INS32 INS43 INS85 INS42 INS32 UPD42 INS42 INS32 UPD42 MOV42 INS32 INS42 INS42 INS27 UPD42 INS32 INS42 INS42 INS42 INS42 INS32 INS42 INS90 INS42 INS42 INS40 INS34 INS42 INS42 INS32 INS32 UPD42 MOV42 INS90 INS57 INS42 UPD43 INS42 INS32 INS42 INS90 INS57 INS42 MOV43 UPD42 MOV32 MOV32 INS32 INS42 INS90 INS42 INS42 MOV43 MOV32 UPD42 INS42 INS45 INS32 INS42 INS90 INS57 INS42 UPD42 INS42 INS42 INS57 INS42 MOV43 MOV43 DEL76 DEL76 DEL83 DEL42 DEL43 DEL76 DEL74 DEL42 DEL42 DEL43 DEL74 DEL42 DEL32 DEL14 DEL59 DEL60 DEL83 DEL43 DEL42 DEL44 DEL42 DEL42 DEL62 DEL42 DEL42 DEL11 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL41 DEL76 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL43 DEL62 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL42 DEL62 DEL42 DEL42 DEL42 DEL11 DEL32 DEL21 DEL8 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL25 DEL8 DEL70 DEL42 DEL42 DEL32 DEL38 DEL42 DEL32 DEL42 DEL42 DEL45 DEL32
Merge branch 'release/1.0.0-incubating.M3'

+import com.gemstone.gemfire.SerializationException;
+import com.gemstone.gemfire.distributed.internal.DistributionConfig;
+import com.gemstone.gemfire.internal.Assert;
+import com.gemstone.gemfire.internal.HeapDataOutputStream;
+import com.gemstone.gemfire.internal.Version;
+import com.gemstone.gemfire.internal.cache.TXManagerImpl;
+import com.gemstone.gemfire.internal.cache.tier.MessageType;
+import com.gemstone.gemfire.internal.i18n.LocalizedStrings;
+import com.gemstone.gemfire.internal.logging.LogService;
+import com.gemstone.gemfire.internal.logging.log4j.LocalizedMessage;
+import com.gemstone.gemfire.internal.offheap.StoredObject;
+import com.gemstone.gemfire.internal.offheap.annotations.Unretained;
+import com.gemstone.gemfire.internal.util.BlobHelper;
+import org.apache.logging.log4j.Logger;
+
-import org.apache.logging.log4j.Logger;
-
-import com.gemstone.gemfire.SerializationException;
-import com.gemstone.gemfire.internal.Assert;
-import com.gemstone.gemfire.internal.HeapDataOutputStream;
-import com.gemstone.gemfire.internal.SocketUtils;
-import com.gemstone.gemfire.internal.Version;
-import com.gemstone.gemfire.internal.cache.TXManagerImpl;
-import com.gemstone.gemfire.internal.cache.tier.MessageType;
-import com.gemstone.gemfire.internal.i18n.LocalizedStrings;
-import com.gemstone.gemfire.internal.logging.LogService;
-import com.gemstone.gemfire.internal.logging.log4j.LocalizedMessage;
-import com.gemstone.gemfire.internal.offheap.StoredObject;
-import com.gemstone.gemfire.internal.offheap.annotations.Unretained;
-import com.gemstone.gemfire.internal.util.BlobHelper;
-
-  public static int MAX_MESSAGE_SIZE = Integer.getInteger("gemfire.client.max-message-size", DEFAULT_MAX_MESSAGE_SIZE).intValue();
+  public static int MAX_MESSAGE_SIZE = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "client.max-message-size", DEFAULT_MAX_MESSAGE_SIZE).intValue();
-    // TODO OFFHEAP: Change Part to look for an HDOS and just pass a reference to its DirectByteBuffer.
-    // Then change HDOS sendTo(SocketChannel...) to use the GatheringByteChannel to write a bunch of bbs.
-    // TODO OFFHEAP This code optimizes one part which works pretty good for getAll since all the values are
-    // returned in one part. But the following seems even better...
-    // BETTER: change Message to consolidate all the part hdos bb lists into a single bb array and have it do the GatheringByteChannel write.
-    // Message can use slice for the small parts (msg header and part header) that are not in the parts data (its a byte array, Chunk, or HDOS).
-    // EVEN BETTER: the message can have a single HDOS which owns a direct comm buffer. It can reserve space if it does not yet know the value to write (for example the size of the message or part).
-    // If we write something to the HDOS that is direct then it does not need to be copied.
-    // But large heap byte arrays will need to be copied to the hdos (the socket write does this anyway).
-    // If the direct buffer is full then we can allocate another one. If a part is already in a heap byte array
-    // then we could defer copying it by slicing the current direct bb and then adding the heap byte array
-    // as bb using ByteBuffer.wrap. Once we have all the data in the HDOS we can finally generate the header
-    // and then start working on sending the ByteBuffers to the channel. If we have room in a direct bb then
-    // we can copy a heap bb to it. Otherwise we can write the bb ahead of it which would free up room to copy
-    // the heap bb to the existing direct bb without needing to allocate extra direct bbs.
-    // Delaying the flush uses more direct memory but reduces the number of system calls.
-    if (this.socket != null) {
+    if (this.socket == null) {
+      throw new IOException(LocalizedStrings.Message_DEAD_CONNECTION.toLocalizedString());
+    }
+    try {
-      synchronized(cb) {
+      synchronized (cb) {
-        
-        for (int i=0; i < this.numberOfParts; i++) {
+
+        for (int i = 0; i < this.numberOfParts; i++) {
-        if ( (headerLen + totalPartLen) > Integer.MAX_VALUE ) {
-          throw new MessageTooLargeException("Message size (" + (headerLen + totalPartLen) 
+        if ((headerLen + totalPartLen) > Integer.MAX_VALUE) {
+          throw new MessageTooLargeException("Message size (" + (headerLen + totalPartLen)
-        
-        msgLen = (int)(headerLen + totalPartLen);
-        
+
+        msgLen = (int) (headerLen + totalPartLen);
+
-        
+
-        for (int i=0; i < partsToTransmit; i++) {
+        for (int i = 0; i < partsToTransmit; i++) {
-          
+
-      if(clearMessage) {
+    } finally {
+      if (clearMessage) {
-    else {
-      throw new IOException(LocalizedStrings.Message_DEAD_CONNECTION.toLocalizedString());
-    }
-      setComms(socket, SocketUtils.getInputStream(socket), SocketUtils.getOutputStream(socket), bb, msgStats);
+      setComms(socket, socket.getInputStream(), socket.getOutputStream(), bb, msgStats);
-   * @since 5.7
+   * @since GemFire 5.7

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 UPD40 INS54 UPD27 MOV8 INS8 UPD66 INS27 MOV25 INS40 INS45 UPD42 UPD42 DEL45 DEL42 DEL42
GEODE-3870: move region entry classes to new entries package (#972)

* Move Region Entries into entries package
* Move NonLocalRegionEntry back to internal.cache package
* Regenerate region entry classes from Linux

+ * <p>
+ * Our RegionEntry does not need to keep a reference to the key. It is being referenced by the
+ * Map.Entry whose value field references this RegionEntry.
+ *
- *
- * 
- *        Implementations: (unshared) ThinEntry protected volatile long lastModified; StatsEntry
- *        extends ThinEntry private volatile long lastAccessed; private volatile int hitCount;
- *        private volatile int missCount; DiskThinEntry extends ThinEntry private volatile long id;
- *        DiskStatsEntry extends StatsEntry private volatile long id; ThinLRUEntry extends ThinEntry
- *        int bitField1; LRUClockNode nextLRU; int size; StatsLRUEntry extends StatsEntry int
- *        bitField1; LRUClockNode nextLRU; int size; DiskThinLRUEntry extends ThinLRUEntry private
- *        volatile long id; DiskStatsLRUEntry extends StatsLRUEntry private volatile long id;
- *
-  // Our RegionEntry does not need to keep a reference to the key.
-  // It is being referenced by the Map.Entry whose value field
-  // references this RegionEntry.
-  // Object getKey();
-  public long getLastModified();
+  long getLastModified();
-  public boolean hasStats();
+  boolean hasStats();
-  public long getLastAccessed() throws InternalStatisticsDisabledException;
+  long getLastAccessed() throws InternalStatisticsDisabledException;
-  public default void setLastAccessed(long lastAccessed) {
+  default void setLastAccessed(long lastAccessed) {
-  public long getHitCount() throws InternalStatisticsDisabledException;
+  long getHitCount() throws InternalStatisticsDisabledException;
-  public long getMissCount() throws InternalStatisticsDisabledException;
+  long getMissCount() throws InternalStatisticsDisabledException;
-  public void updateStatsForPut(long lastModifiedTime, long lastAccessedTime);
+  void updateStatsForPut(long lastModifiedTime, long lastAccessedTime);
-  public VersionStamp getVersionStamp();
+  VersionStamp getVersionStamp();
-  public VersionTag generateVersionTag(VersionSource member, boolean withDelta, LocalRegion region,
+  VersionTag generateVersionTag(VersionSource member, boolean withDelta, LocalRegion region,
-  public boolean dispatchListenerEvents(EntryEventImpl event) throws InterruptedException;
+  boolean dispatchListenerEvents(EntryEventImpl event) throws InterruptedException;
-  public void setRecentlyUsed();
+  void setRecentlyUsed();
-  public void updateStatsForGet(boolean hit, long time);
+  void updateStatsForGet(boolean hit, long time);
-  public void txDidDestroy(long currTime);
+  void txDidDestroy(long currTime);
-  public void resetCounts() throws InternalStatisticsDisabledException;
+  void resetCounts() throws InternalStatisticsDisabledException;
-   * @throws RegionClearedException
-  public void makeTombstone(LocalRegion r, VersionTag version) throws RegionClearedException;
+  void makeTombstone(LocalRegion r, VersionTag version) throws RegionClearedException;
-  public void removePhase1(LocalRegion r, boolean clear) throws RegionClearedException;
+  void removePhase1(LocalRegion r, boolean clear) throws RegionClearedException;
-  public void removePhase2();
+  void removePhase2();
-  public boolean isRemoved();
+  boolean isRemoved();
-  public boolean isRemovedPhase2();
+  boolean isRemovedPhase2();
-  public boolean isTombstone();
+  boolean isTombstone();
+   *
-   * 
+   * @return false if map entry not found
+   *
-   * @return false if map entry not found
-  public boolean fillInValue(LocalRegion r,
-      @Retained(ABSTRACT_REGION_ENTRY_FILL_IN_VALUE) Entry entry, ByteArrayDataInput in, DM mgr,
-      final Version version);
+  boolean fillInValue(LocalRegion r, @Retained(ABSTRACT_REGION_ENTRY_FILL_IN_VALUE) Entry entry,
+      ByteArrayDataInput in, DM mgr, final Version version);
-  public boolean isOverflowedToDisk(LocalRegion r, DistributedRegion.DiskPosition dp);
+  boolean isOverflowedToDisk(LocalRegion r, DistributedRegion.DiskPosition dp);
-  public Object getKey();
+  Object getKey();
-  public Object getValue(RegionEntryContext context);
+  Object getValue(RegionEntryContext context);
-  public Object getValueRetain(RegionEntryContext context);
+  Object getValueRetain(RegionEntryContext context);
-  public void setValue(RegionEntryContext context, @Unretained Object value)
-      throws RegionClearedException;
+  void setValue(RegionEntryContext context, @Unretained Object value) throws RegionClearedException;
-  public void setValue(RegionEntryContext context, Object value, EntryEventImpl event)
+  void setValue(RegionEntryContext context, Object value, EntryEventImpl event)
-  public Object _getValueRetain(RegionEntryContext context, boolean decompress);
+  Object _getValueRetain(RegionEntryContext context, boolean decompress);
-  public Object _getValue();
+  Object _getValue();
-  public Token getValueAsToken();
+  Token getValueAsToken();
-  public void setValueWithTombstoneCheck(@Unretained Object value, EntryEvent event)
+  void setValueWithTombstoneCheck(@Unretained Object value, EntryEvent event)
-  public Object getTransformedValue();
+  Object getTransformedValue();
-  public Object getValueInVM(RegionEntryContext context);
+  Object getValueInVM(RegionEntryContext context);
-  public Object getValueOnDisk(LocalRegion r) throws EntryNotFoundException;
+  Object getValueOnDisk(LocalRegion r) throws EntryNotFoundException;
-  public Object getValueOnDiskOrBuffer(LocalRegion r) throws EntryNotFoundException;
+  Object getValueOnDiskOrBuffer(LocalRegion r) throws EntryNotFoundException;
-  public boolean initialImagePut(LocalRegion region, long lastModified, Object newValue,
+  boolean initialImagePut(LocalRegion region, long lastModified, Object newValue,
-   * getInitialImage. // put if LOCAL_INVALID and nonexistant // put if INVALID and nonexistant,
-   * recovered, or LOCAL_INVALID // put if valid and nonexistant, recovered, or LOCAL_INVALID // //
-   * REGION_INVALIDATED: (special case) // If the region itself has been invalidated since
-   * getInitialImage // started, and newValue is LOCAL_INVALID or valid, // then force creation of
-   * INVALID key if currently nonexistant // or invalidate if current recovered. // // must
-   * write-synchronize to protect agains puts from other // threads running this method
+   * getInitialImage.
+   *
+   * <p>
+   * put if LOCAL_INVALID and nonexistant<br>
+   * put if INVALID and nonexistant, recovered, or LOCAL_INVALID<br>
+   * put if valid and nonexistant, recovered, or LOCAL_INVALID
+   *
+   * <p>
+   * REGION_INVALIDATED: (special case)<br>
+   * If the region itself has been invalidated since getInitialImage<br>
+   * started, and newValue is LOCAL_INVALID or valid,<br>
+   * then force creation of INVALID key if currently nonexistent<br>
+   * or invalidate if current recovered.<br>
+   *
+   * <p>
+   * must write-synchronize to protect against puts from other<br>
+   * threads running this method
-  public boolean initialImageInit(LocalRegion region, long lastModified, Object newValue,
-      boolean create, boolean wasRecovered, boolean acceptedVersionTag)
-      throws RegionClearedException;
+  boolean initialImageInit(LocalRegion region, long lastModified, Object newValue, boolean create,
+      boolean wasRecovered, boolean acceptedVersionTag) throws RegionClearedException;
-  public boolean destroy(LocalRegion region, EntryEventImpl event, boolean inTokenMode,
-      boolean cacheWrite, @Unretained Object expectedOldValue, boolean forceDestroy,
-      boolean removeRecoveredEntry)
+  boolean destroy(LocalRegion region, EntryEventImpl event, boolean inTokenMode, boolean cacheWrite,
+      @Unretained Object expectedOldValue, boolean forceDestroy, boolean removeRecoveredEntry)
-  public boolean getValueWasResultOfSearch();
+  boolean getValueWasResultOfSearch();
-  public void setValueResultOfSearch(boolean v);
+  void setValueResultOfSearch(boolean v);
-  public Object getSerializedValueOnDisk(LocalRegion localRegion);
+  Object getSerializedValueOnDisk(LocalRegion localRegion);
-  public Object getValueInVMOrDiskWithoutFaultIn(LocalRegion owner);
+  Object getValueInVMOrDiskWithoutFaultIn(LocalRegion owner);
-  public Object getValueOffHeapOrDiskWithoutFaultIn(LocalRegion owner);
+  Object getValueOffHeapOrDiskWithoutFaultIn(LocalRegion owner);
-  public boolean isUpdateInProgress();
+  boolean isUpdateInProgress();
-   *
-   * @param underUpdate
-  public void setUpdateInProgress(final boolean underUpdate);
+  void setUpdateInProgress(final boolean underUpdate);
-  public boolean isCacheListenerInvocationInProgress();
+  boolean isCacheListenerInvocationInProgress();
-   * 
-   * @param isListenerInvoked
-  public void setCacheListenerInvocationInProgress(final boolean isListenerInvoked);
+  void setCacheListenerInvocationInProgress(final boolean isListenerInvoked);
-  public boolean isValueNull();
+  boolean isValueNull();
-  public boolean isInvalid();
+  boolean isInvalid();
-  public boolean isDestroyed();
+  boolean isDestroyed();
-  public boolean isDestroyedOrRemoved();
+  boolean isDestroyedOrRemoved();
-  public boolean isDestroyedOrRemovedButNotTombstone();
+  boolean isDestroyedOrRemovedButNotTombstone();
-  public boolean isInvalidOrRemoved();
+  boolean isInvalidOrRemoved();
-  public void setValueToNull();
+  void setValueToNull();
-  public void returnToPool();
+  void returnToPool();
-  public boolean isInUseByTransaction();
+  boolean isInUseByTransaction();
-  public void setInUseByTransaction(final boolean v);
+  void setInUseByTransaction(final boolean v);
-  public void incRefCount();
+  void incRefCount();
-  public void decRefCount(NewLRUClockHand lruList, LocalRegion lr);
+  void decRefCount(NewLRUClockHand lruList, LocalRegion lr);
-  public void resetRefCount(NewLRUClockHand lruList);
+  void resetRefCount(NewLRUClockHand lruList);
-  public Object prepareValueForCache(RegionEntryContext r, Object val, boolean isEntryUpdate);
+  Object prepareValueForCache(RegionEntryContext r, Object val, boolean isEntryUpdate);
-  public Object prepareValueForCache(RegionEntryContext r, Object val, EntryEventImpl event,
+  Object prepareValueForCache(RegionEntryContext r, Object val, EntryEventImpl event,

MOV43 MOV43 MOV65 MOV79 MOV44 MOV79 MOV44 INS66 INS66 INS66 INS66 INS66 INS66 UPD66 UPD66 INS66 INS66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 INS66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL65 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL65 DEL83 DEL83 DEL42 DEL65 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83
Revert "GEODE-7828: Convert backing store for Redis Hashes and Sets to single regions (#4745)" (#4780)

This reverts commit 2f6bf013368df5a4b5efe68162a4953f9a88bbf2.
-import java.util.Map;
-import org.apache.geode.cache.TimeoutException;
-import org.apache.geode.redis.internal.AutoCloseableLock;
+import org.apache.geode.cache.Region;
+import org.apache.geode.redis.internal.RedisDataType;
-/**
- * <pre>
- * Implements the HSET command to sets field in the hash stored at key to value.
- * A new entry in the hash is created if key does not exist.
- * Any existing in the hash with the given key is overwritten.
- *
- * Examples:
- *
- * redis> HSET myhash field1 "Hello"
- * (integer) 1
- * redis> HGET myhash field1
- *
- *
- * </pre>
- */
+  private final int EXISTING_FIELD = 0;
+
+  private final int NEW_FIELD = 1;
+
+  private final int VALUE_INDEX = 3;
+
-    if (commandElems.size() < 4 || commandElems.size() % 2 == 1) {
+    if (commandElems.size() < 4) {
+    Region<ByteArrayWrapper, ByteArrayWrapper> keyRegion =
+        getOrCreateRegion(context, key, RedisDataType.REDIS_HASH);
+
+    byte[] byteField = commandElems.get(FIELD_INDEX);
+    ByteArrayWrapper field = new ByteArrayWrapper(byteField);
+
+    byte[] value = commandElems.get(VALUE_INDEX);
+
-    int fieldsAdded = 0;
-    try (AutoCloseableLock regionLock = withRegionLock(context, key)) {
-      Map<ByteArrayWrapper, ByteArrayWrapper> map = getMap(context, key);
+    if (onlySetOnAbsent())
+      oldValue = keyRegion.putIfAbsent(field, new ByteArrayWrapper(value));
+    else
+      oldValue = keyRegion.put(field, new ByteArrayWrapper(value));
-      for (int i = 2; i < commandElems.size(); i += 2) {
-        byte[] fieldArray = commandElems.get(i);
-        ByteArrayWrapper field = new ByteArrayWrapper(fieldArray);
-        byte[] value = commandElems.get(i + 1);
-        ByteArrayWrapper putValue = new ByteArrayWrapper(value);
+    if (oldValue == null)
+      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), NEW_FIELD));
+    else
+      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), EXISTING_FIELD));
-        if (onlySetOnAbsent()) {
-          oldValue = map.putIfAbsent(field, putValue);
-        } else {
-          oldValue = map.put(field, putValue);
-        }
-
-        if (oldValue == null) {
-          fieldsAdded++;
-        }
-      }
-
-      this.saveMap(map, context, key);
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
-      command.setResponse(
-          Coder.getErrorResponse(context.getByteBufAllocator(), "Thread interrupted."));
-      return;
-    } catch (TimeoutException e) {
-      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
-          "Timeout acquiring lock. Please try again."));
-      return;
-    }
-
-    command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), fieldsAdded));

MOV26 UPD40 UPD40 INS23 INS23 INS23 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS59 INS42 INS34 INS42 INS34 INS42 INS34 MOV60 MOV60 MOV60 MOV60 MOV25 MOV25 MOV27 UPD74 MOV5 MOV43 MOV5 INS21 INS21 MOV21 MOV21 UPD43 UPD42 UPD42 MOV7 MOV7 UPD42 UPD42 INS40 UPD42 MOV43 UPD42 INS42 UPD42 INS14 UPD42 MOV14 UPD42 INS42 UPD42 INS42 INS43 INS42 INS42 DEL40 DEL26 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL42 DEL32 DEL34 DEL27 DEL34 DEL27 DEL27 DEL42 DEL34 DEL27 DEL42 DEL42 DEL21 DEL8 DEL21 DEL8 DEL45 DEL45 DEL42 DEL37 DEL21 DEL8 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL34 DEL7 DEL42 DEL43 DEL42 DEL59 DEL60 DEL8 DEL24 DEL52 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL41 DEL8 DEL12 DEL42 DEL43 DEL42 DEL44 DEL41 DEL8 DEL12 DEL54 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL21
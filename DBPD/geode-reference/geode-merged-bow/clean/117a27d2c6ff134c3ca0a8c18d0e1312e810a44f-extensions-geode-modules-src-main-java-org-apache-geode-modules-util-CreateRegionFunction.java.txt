GEODE-6719 : Handling default disktore request from AppServers (#3516)

* If the existing region was using the DEFAULT diskstore but it was not explicitly linked to the
   * region using setDiskStore or disk-store-name tags. diskStoreName is set as null. This is
   * interpreted by Geode as use the DEFAULT diskstore.
   * This link between the existing region and a diskstore may happen because the diskstore is
   * named as DEFAULT.
   * The user may change the default location of the DEFAULT diskstore but the AppServer always
   * requests it be at the default location.
   * This comparison with always used to fail and the AppServer could not start up.
   * The goal of this method is that if both existing region and requested region are using the
   * DEFAULT diskstore, the existing regions take precedence and the requested ones are ignored.
   * This is current behavior which can be seen in
   * {@link RegionAttributesCreation#sameAs(RegionAttributes)}
   * The logic is to intercept the configurations for the regions and only if the both the regions
   * have diskStoreName set to null, meaning both should use the DEFAULT diskstore, the diskstore
   * names are sent as DEFAULT in the configuration and send to geode-core for comparison for rest
   * of the region attributes.
+import org.apache.geode.cache.EvictionAction;
+import org.apache.geode.cache.EvictionAttributes;
+import org.apache.geode.internal.cache.xmlcache.RegionAttributesCreation;
-        RegionHelper.validateRegion(this.cache, configuration, region);
+        RegionAttributes existingRegionAttributes = region.getAttributes();
+        RegionAttributes requestedRegionAttributes =
+            RegionHelper.getRegionAttributes(this.cache, configuration);
+        compareRegionAttributes(existingRegionAttributes, requestedRegionAttributes);
+  /**
+   * If the existing region was using the DEFAULT diskstore but it was not explicitly linked to the
+   * region using setDiskStore or disk-store-name tags. diskStoreName is set as null. This is
+   * interpreted by Geode as use the DEFAULT diskstore.
+   * This link between the existing region and a diskstore may happen because the diskstore is
+   * named as DEFAULT.
+   * The user may change the default location of the DEFAULT diskstore but the AppServer always
+   * requests it be at the default location.
+   * This comparison with always used to fail and the AppServer could not start up.
+   * The goal of this method is that if both existing region and requested region are using the
+   * DEFAULT diskstore, the existing regions take precedence and the requested ones are ignored.
+   * This is current behavior which can be seen in
+   * {@link RegionAttributesCreation#sameAs(RegionAttributes)}
+   * The logic is to intercept the configurations for the regions and only if the both the regions
+   * have diskStoreName set to null, meaning both should use the DEFAULT diskstore, the diskstore
+   * names are sent as DEFAULT in the configuration and send to geode-core for comparison for rest
+   * of the region attributes.
+   */
+  void compareRegionAttributes(RegionAttributes existingRegionAttributes,
+      RegionAttributes requestedRegionAttributes) {
+    RegionAttributesCreation existingRACreation =
+        new RegionAttributesCreation(existingRegionAttributes, false);
+    EvictionAttributes evictionAttributes = existingRegionAttributes.getEvictionAttributes();
+    if (existingRegionAttributes.getDataPolicy().withPersistence() || (evictionAttributes != null
+        && evictionAttributes.getAction() == EvictionAction.OVERFLOW_TO_DISK)) {
+      if (requestedRegionAttributes.getDiskStoreName() == null
+          && existingRegionAttributes.getDiskStoreName() == null) {
+        AttributesFactory attributesFactory = new AttributesFactory(requestedRegionAttributes);
+        attributesFactory.setDiskStoreName("DEFAULT");
+        requestedRegionAttributes = attributesFactory.create();
+        existingRACreation = new RegionAttributesCreation(existingRegionAttributes, false);
+        existingRACreation.setDiskStoreName("DEFAULT");
+      }
+    }
+    existingRACreation.sameAs(requestedRegionAttributes);
+  }
+

INS26 INS26 INS26 INS40 INS40 INS40 INS31 INS29 INS39 INS42 INS44 INS44 INS8 INS65 INS43 INS42 INS43 INS42 INS60 INS60 INS25 INS21 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS42 INS42 INS43 INS59 INS43 INS59 INS27 INS8 INS32 INS68 INS42 INS42 INS14 INS42 INS42 INS32 INS32 INS36 INS25 INS42 INS42 INS42 INS42 INS42 INS69 INS43 INS42 INS9 INS42 INS42 INS32 INS42 INS27 INS27 INS8 INS60 INS60 INS43 INS42 INS42 INS42 INS27 INS27 INS27 INS27 INS60 INS21 INS21 INS21 INS21 INS43 INS59 INS43 INS59 INS32 INS42 INS42 INS33 INS32 INS40 INS32 INS33 INS32 INS33 INS43 INS59 INS32 INS7 INS7 INS32 INS42 INS42 INS32 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS45 INS42 INS32 INS42 INS14 INS42 INS42 INS45 INS42 INS42 UPD42 INS43 INS42 INS42 INS42 INS43 INS42 INS9 INS42 INS42 DEL42
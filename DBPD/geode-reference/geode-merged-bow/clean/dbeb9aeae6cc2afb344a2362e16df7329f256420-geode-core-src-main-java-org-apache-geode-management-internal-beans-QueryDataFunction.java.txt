Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This function is executed on one or multiple members based on the member
- * input to DistributedSystemMXBean.queryData()
+ * This function is executed on one or multiple members based on the member input to
+ * DistributedSystemMXBean.queryData()
-@SuppressWarnings({ "deprecation", "unchecked" })
+@SuppressWarnings({"deprecation", "unchecked"})
-  private static final Pattern SELECT_EXPR_PATTERN = Pattern.compile(SELECT_EXPR, Pattern.CASE_INSENSITIVE);
-  private static final String SELECT_WITH_LIMIT_EXPR = "\\s*SELECT\\s+.+\\s+FROM(\\s+|(.*\\s+))LIMIT\\s+[0-9]+.*";
-  private static final Pattern SELECT_WITH_LIMIT_EXPR_PATTERN = Pattern.compile(SELECT_WITH_LIMIT_EXPR, Pattern.CASE_INSENSITIVE);
+  private static final Pattern SELECT_EXPR_PATTERN =
+      Pattern.compile(SELECT_EXPR, Pattern.CASE_INSENSITIVE);
+  private static final String SELECT_WITH_LIMIT_EXPR =
+      "\\s*SELECT\\s+.+\\s+FROM(\\s+|(.*\\s+))LIMIT\\s+[0-9]+.*";
+  private static final Pattern SELECT_WITH_LIMIT_EXPR_PATTERN =
+      Pattern.compile(SELECT_WITH_LIMIT_EXPR, Pattern.CASE_INSENSITIVE);
-      context.getResultSender().lastResult(selectWithType(context, queryString, showMember, regionName, limit, queryResultSetLimit, queryCollectionsDepth));
+      context.getResultSender().lastResult(selectWithType(context, queryString, showMember,
+          regionName, limit, queryResultSetLimit, queryCollectionsDepth));
-  private QueryDataFunctionResult selectWithType(final FunctionContext context, String queryString, final boolean showMember, final String regionName, final int limit, final int queryResultSetLimit, final int queryCollectionsDepth) throws Exception {
+  private QueryDataFunctionResult selectWithType(final FunctionContext context, String queryString,
+      final boolean showMember, final String regionName, final int limit,
+      final int queryResultSetLimit, final int queryCollectionsDepth) throws Exception {
-    Function loclQueryFunc = new LocalQueryFunction("LocalQueryFunction", regionName, showMember).setOptimizeForWrite(true);
+    Function loclQueryFunc = new LocalQueryFunction("LocalQueryFunction", regionName, showMember)
+        .setOptimizeForWrite(true);
-        throw new Exception(ManagementStrings.QUERY__MSG__REGIONS_NOT_FOUND_ON_MEMBER.toLocalizedString(regionName, cache.getDistributedSystem().getDistributedMember().getId()));
+        throw new Exception(
+            ManagementStrings.QUERY__MSG__REGIONS_NOT_FOUND_ON_MEMBER.toLocalizedString(regionName,
+                cache.getDistributedSystem().getDistributedMember().getId()));
-        PartitionedRegion parRegion = PartitionedRegionHelper.getPartitionedRegion(regionName, cache);
+        PartitionedRegion parRegion =
+            PartitionedRegionHelper.getPartitionedRegion(regionName, cache);
-            Set<BucketRegion> localPrimaryBucketRegions = parRegion.getDataStore().getAllLocalPrimaryBucketRegions();
+            Set<BucketRegion> localPrimaryBucketRegions =
+                parRegion.getDataStore().getAllLocalPrimaryBucketRegions();
-            SelectResults selectResults = (SelectResults) lds.executeQuery(query, null, localPrimaryBucketSet);
+            SelectResults selectResults =
+                (SelectResults) lds.executeQuery(query, null, localPrimaryBucketSet);
-          rcollector = FunctionService.onRegion(cache.getRegion(regionName)).withArgs(queryString).execute(loclQueryFunc);
+          rcollector = FunctionService.onRegion(cache.getRegion(regionName)).withArgs(queryString)
+              .execute(loclQueryFunc);
-        for (Iterator iter = selectResults.iterator(); iter.hasNext(); ) {
+        for (Iterator iter = selectResults.iterator(); iter.hasNext();) {
-        return new QueryDataFunctionResult(QUERY_EXEC_SUCCESS, BeanUtilFuncs.compress(new JsonisedErroMessage(NO_DATA_FOUND).toString()));
+        return new QueryDataFunctionResult(QUERY_EXEC_SUCCESS,
+            BeanUtilFuncs.compress(new JsonisedErroMessage(NO_DATA_FOUND).toString()));
-      return new QueryDataFunctionResult(QUERY_EXEC_SUCCESS, BeanUtilFuncs.compress(result.toString()));
+      return new QueryDataFunctionResult(QUERY_EXEC_SUCCESS,
+          BeanUtilFuncs.compress(result.toString()));
-   * Matches the input query with query with limit pattern. If limit is found in
-   * input query this function ignores. Else it will append a default limit ..
-   * 1000 If input limit is 0 then also it will append default limit of 1000
+   * Matches the input query with query with limit pattern. If limit is found in input query this
+   * function ignores. Else it will append a default limit .. 1000 If input limit is 0 then also it
+   * will append default limit of 1000
-  protected static String applyLimitClause(final String query, int limit, final int queryResultSetLimit) {
+  protected static String applyLimitClause(final String query, int limit,
+      final int queryResultSetLimit) {
-  private static Object callFunction(final Object functionArgs, final Set<DistributedMember> members, final boolean zipResult) throws Exception {
+  private static Object callFunction(final Object functionArgs,
+      final Set<DistributedMember> members, final boolean zipResult) throws Exception {
-        ResultCollector collector = FunctionService.onMember(member).withArgs(functionArgs).execute(ManagementConstants.QUERY_DATA_FUNCTION);
+        ResultCollector collector = FunctionService.onMember(member).withArgs(functionArgs)
+            .execute(ManagementConstants.QUERY_DATA_FUNCTION);
-        ResultCollector coll = FunctionService.onMembers(members).withArgs(functionArgs).execute(ManagementConstants.QUERY_DATA_FUNCTION);
+        ResultCollector coll = FunctionService.onMembers(members).withArgs(functionArgs)
+            .execute(ManagementConstants.QUERY_DATA_FUNCTION);
-      throw new Exception(ManagementStrings.QUERY__MSG__QUERY_EXEC.toLocalizedString(fe.getMessage()));
+      throw new Exception(
+          ManagementStrings.QUERY__MSG__QUERY_EXEC.toLocalizedString(fe.getMessage()));
-      throw new Exception(ManagementStrings.QUERY__MSG__QUERY_EXEC.toLocalizedString(e.getMessage()));
+      throw new Exception(
+          ManagementStrings.QUERY__MSG__QUERY_EXEC.toLocalizedString(e.getMessage()));
-      throw new Exception(ManagementStrings.QUERY__MSG__QUERY_EXEC.toLocalizedString(e.getMessage()));
+      throw new Exception(
+          ManagementStrings.QUERY__MSG__QUERY_EXEC.toLocalizedString(e.getMessage()));
-      throw new Exception(ManagementStrings.QUERY__MSG__QUERY_EXEC.toLocalizedString(e.getMessage()));
+      throw new Exception(
+          ManagementStrings.QUERY__MSG__QUERY_EXEC.toLocalizedString(e.getMessage()));
-  public static Object queryData(final String query, final String members, final int limit, final boolean zipResult, final int queryResultSetLimit, final int queryCollectionsDepth) throws Exception {
+  public static Object queryData(final String query, final String members, final int limit,
+      final boolean zipResult, final int queryResultSetLimit, final int queryCollectionsDepth)
+      throws Exception {
-      return new JsonisedErroMessage(ManagementStrings.QUERY__MSG__QUERY_EMPTY.toLocalizedString()).toString();
+      return new JsonisedErroMessage(ManagementStrings.QUERY__MSG__QUERY_EMPTY.toLocalizedString())
+          .toString();
-          return new JsonisedErroMessage(ManagementStrings.QUERY__MSG__INVALID_MEMBER.toLocalizedString(member)).toString();
+          return new JsonisedErroMessage(
+              ManagementStrings.QUERY__MSG__INVALID_MEMBER.toLocalizedString(member)).toString();
-      SystemManagementService service = (SystemManagementService) ManagementService.getExistingManagementService(cache);
+      SystemManagementService service =
+          (SystemManagementService) ManagementService.getExistingManagementService(cache);
-            return new JsonisedErroMessage(ManagementStrings.QUERY__MSG__REGIONS_NOT_FOUND.toLocalizedString(regionPath)).toString();
+            return new JsonisedErroMessage(
+                ManagementStrings.QUERY__MSG__REGIONS_NOT_FOUND.toLocalizedString(regionPath))
+                    .toString();
-            Set<DistributedMember> associatedMembers = DataCommands.getRegionAssociatedMembers(regionPath, cache, true);
+            Set<DistributedMember> associatedMembers =
+                DataCommands.getRegionAssociatedMembers(regionPath, cache, true);
-                return new JsonisedErroMessage(ManagementStrings.QUERY__MSG__REGIONS_NOT_FOUND_ON_MEMBERS.toLocalizedString(regionPath)).toString();
+                return new JsonisedErroMessage(
+                    ManagementStrings.QUERY__MSG__REGIONS_NOT_FOUND_ON_MEMBERS
+                        .toLocalizedString(regionPath)).toString();
-        return new JsonisedErroMessage(ManagementStrings.QUERY__MSG__INVALID_QUERY.toLocalizedString("Region mentioned in query probably missing /")).toString();
+        return new JsonisedErroMessage(ManagementStrings.QUERY__MSG__INVALID_QUERY
+            .toLocalizedString("Region mentioned in query probably missing /")).toString();
-          if (regionMBean.getRegionType().equals(DataPolicy.PARTITION.toString()) || regionMBean.getRegionType().equals(DataPolicy.PERSISTENT_PARTITION.toString())) {
-            return new JsonisedErroMessage(ManagementStrings.QUERY__MSG__JOIN_OP_EX.toLocalizedString()).toString();
+          if (regionMBean.getRegionType().equals(DataPolicy.PARTITION.toString())
+              || regionMBean.getRegionType().equals(DataPolicy.PERSISTENT_PARTITION.toString())) {
+            return new JsonisedErroMessage(
+                ManagementStrings.QUERY__MSG__JOIN_OP_EX.toLocalizedString()).toString();
-      Set<DistributedMember> associatedMembers = DataCommands.getQueryRegionsAssociatedMembers(regionsInQuery, cache, false);// First available member
+      Set<DistributedMember> associatedMembers =
+          DataCommands.getQueryRegionsAssociatedMembers(regionsInQuery, cache, false);// First
+                                                                                      // available
+                                                                                      // member
-        return new JsonisedErroMessage(ManagementStrings.QUERY__MSG__REGIONS_NOT_FOUND.toLocalizedString(regionsInQuery.toString())).toString();
+        return new JsonisedErroMessage(ManagementStrings.QUERY__MSG__REGIONS_NOT_FOUND
+            .toLocalizedString(regionsInQuery.toString())).toString();
-      return new JsonisedErroMessage(ManagementStrings.QUERY__MSG__INVALID_QUERY.toLocalizedString(qe.getMessage())).toString();
+      return new JsonisedErroMessage(
+          ManagementStrings.QUERY__MSG__INVALID_QUERY.toLocalizedString(qe.getMessage()))
+              .toString();
-   * Compile the query and return a set of regions involved in the query It
-   * throws an QueryInvalidException if the query is not proper
+   * Compile the query and return a set of regions involved in the query It throws an
+   * QueryInvalidException if the query is not proper
-  private static Set<String> compileQuery(final Cache cache, final String query) throws QueryInvalidException {
+  private static Set<String> compileQuery(final Cache cache, final String query)
+      throws QueryInvalidException {
-   * Function to gather data locally. This function is required to execute query
-   * with region context
+   * Function to gather data locally. This function is required to execute query with region context

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66
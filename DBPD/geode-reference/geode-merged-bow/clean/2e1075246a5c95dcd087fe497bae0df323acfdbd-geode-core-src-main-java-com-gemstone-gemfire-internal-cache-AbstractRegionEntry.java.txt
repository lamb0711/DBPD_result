Merge branch 'release/1.0.0-incubating.M3'

-import java.io.IOException;
-import java.util.Arrays;
-
-import org.apache.logging.log4j.Logger;
-
-import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ABSTRACT_REGION_ENTRY_FILL_IN_VALUE;
-import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ABSTRACT_REGION_ENTRY_PREPARE_VALUE_FOR_CACHE;
-
-import com.gemstone.gemfire.cache.CacheWriterException;
-import com.gemstone.gemfire.cache.EntryEvent;
-import com.gemstone.gemfire.cache.EntryNotFoundException;
-import com.gemstone.gemfire.cache.Operation;
-import com.gemstone.gemfire.cache.TimeoutException;
+import com.gemstone.gemfire.cache.*;
+import com.gemstone.gemfire.distributed.internal.DistributionConfig;
-import com.gemstone.gemfire.internal.Assert;
-import com.gemstone.gemfire.internal.ByteArrayDataInput;
-import com.gemstone.gemfire.internal.HeapDataOutputStream;
-import com.gemstone.gemfire.internal.InternalDataSerializer;
-import com.gemstone.gemfire.internal.InternalStatisticsDisabledException;
-import com.gemstone.gemfire.internal.Version;
+import com.gemstone.gemfire.internal.*;
-import com.gemstone.gemfire.internal.cache.versions.ConcurrentCacheModificationException;
-import com.gemstone.gemfire.internal.cache.versions.RegionVersionVector;
-import com.gemstone.gemfire.internal.cache.versions.VersionSource;
-import com.gemstone.gemfire.internal.cache.versions.VersionStamp;
-import com.gemstone.gemfire.internal.cache.versions.VersionTag;
+import com.gemstone.gemfire.internal.cache.versions.*;
-import com.gemstone.gemfire.internal.offheap.MemoryAllocator;
-import com.gemstone.gemfire.internal.offheap.OffHeapHelper;
-import com.gemstone.gemfire.internal.offheap.ReferenceCountHelper;
-import com.gemstone.gemfire.internal.offheap.MemoryAllocatorImpl;
-import com.gemstone.gemfire.internal.offheap.StoredObject;
+import com.gemstone.gemfire.internal.offheap.*;
+import org.apache.logging.log4j.Logger;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ABSTRACT_REGION_ENTRY_FILL_IN_VALUE;
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ABSTRACT_REGION_ENTRY_PREPARE_VALUE_FOR_CACHE;
- * @since 3.5.1
+ * @since GemFire 3.5.1
-      .getBoolean("gemfire.disableAccessTimeUpdateOnPut");
+      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "disableAccessTimeUpdateOnPut");
-        rgn.getRegionMap().removeEntry(event.getKey(), this, true, event, rgn, rgn.getIndexUpdater());
+        rgn.getRegionMap().removeEntry(event.getKey(), this, true, event, rgn);
-    final boolean isEagerDeserialize = dst.isEagerDeserialize();
-    if (isEagerDeserialize) {
-      dst.clearEagerDeserialize();
-    }
-//      if(v instanceof ByteSource && CachedDeserializableFactory.preferObject()) {
-//        // For SQLFire we prefer eager deserialized
-//        dst.setEagerDeserialize();         
-//      }
-        /*if (v instanceof ByteSource && CachedDeserializableFactory.preferObject()) {
-          dst.value = v;
-        } else */ {
+        {
-    if (CachedDeserializableFactory.preferObject()) {
-      dst.value = preparedValue;
-      dst.setEagerDeserialize();
-    }
-    else {
+    {
-      result = OffHeapHelper.copyAndReleaseIfNeeded(result); // sqlf does not dec ref count in this call
+      result = OffHeapHelper.copyAndReleaseIfNeeded(result);
-  @Retained
-    @Retained Object v = _getValueRetain(context, true);
+    @Released Object v = _getValueRetain(context, true);
-    @Retained Object result = OffHeapHelper.copyAndReleaseIfNeeded(v); // TODO OFFHEAP keep it offheap?
+    Object result = OffHeapHelper.copyAndReleaseIfNeeded(v);
-  @Retained
-          @Retained @Released final Object oldValue = getValueInVM(region); // Heap value should always be deserialized at this point // OFFHEAP will not be deserialized
-          try {
+          final Object oldValue = getValueInVM(region); // Heap value should always be deserialized at this point // OFFHEAP will not be deserialized
-          } finally {
-            OffHeapHelper.release(oldValue);
-          }
-        // rdubey: Old value also required for SqlfIndexManager.
-        if (fp != null && ((fp.getCqCount() > 0) || expectedOldValue != null
-            || event.getRegion().getIndexUpdater() != null)) {
+        if (fp != null && ((fp.getCqCount() > 0) || expectedOldValue != null)) {
-      // See #47887, we do not insert a tombstone for evicted HDFS
-      // entries since the value is still present in HDFS
-      // Check if we have to evict or just do destroy.
-      boolean forceRemoveEntry = 
-          (event.isEviction() || event.isExpiration()) 
-          && event.getRegion().isUsedForPartitionedRegionBucket()
-          && event.getRegion().getPartitionedRegion().isHDFSRegion();
-
-      if (removeEntry || forceRemoveEntry) {
+      if (removeEntry) {
-        // else it is DataAsAddress. This code just returns it as prepared.
-        // TODO OFFHEAP: Review the callers to see if they will handle DataAsAddress correctly.
+        // else it is has no refCount so just return it as prepared.
-            // TODO OFFHEAP: cache data in event?
-              // TODO OFFHEAP: cache data in event?
-            // TODO OFFHEAP: cache data in event?
-  @Override
-  public final boolean isMarkedForEviction() {
-    return areAnyBitsSet(MARKED_FOR_EVICTION);
-  }
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public final void setMarkedForEviction() {
-    setBits(MARKED_FOR_EVICTION);
-  }
-
-  /**
-   * {@inheritDoc}
-   */
-  @Override
-  public final void clearMarkedForEviction() {
-    clearBits(~MARKED_FOR_EVICTION);
-  }
-  
-  /**
-   * soubhik: this method is overridden in sqlf flavor of entries.
-   * Instead of overriding this method; override areSetValue.
-   */
-    return isTombstone && (timestamp + TombstoneService.REPLICATED_TOMBSTONE_TIMEOUT) <= region.cacheTimeMillis();
+    return isTombstone && (timestamp + TombstoneService.REPLICATE_TOMBSTONE_TIMEOUT) <= region.cacheTimeMillis();
-      TimestampedEntryEventImpl timestampedEvent =
+      @Released TimestampedEntryEventImpl timestampedEvent =

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 UPD40 UPD40 UPD40 UPD40 UPD40 MOV29 UPD66 MOV25 INS27 MOV27 MOV8 MOV78 INS40 INS45 MOV27 MOV8 MOV25 MOV27 MOV8 MOV27 INS42 INS78 MOV62 MOV8 MOV25 MOV21 INS25 INS42 MOV62 MOV8 MOV27 MOV8 UPD40 MOV60 MOV25 MOV8 MOV60 UPD27 MOV27 MOV27 INS36 MOV27 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL45 DEL42 DEL42 DEL32 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL40 DEL42 DEL7 DEL21 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL78 DEL42 DEL78 DEL42 DEL78 DEL42 DEL78 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL32 DEL33 DEL27 DEL36 DEL27 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL36 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL27 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL78 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL65 DEL65 DEL29 DEL42 DEL78 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL65 DEL65 DEL29 DEL42 DEL78 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL38 DEL32 DEL21 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29
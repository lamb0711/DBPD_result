GEODE-6536: Added retry in borrowConnection/single hop (#4719)

* GEODE-6536: Added retry in borrowConnection/single hop

* GEODE-6536: bug fix

* GEODE-6536: update after comments

-  /**
-   * Borrow a connection to a specific server. This task currently allows us to break the connection
-   * limit, because it is used by tasks from the background thread that shouldn't be constrained by
-   * the limit. They will only violate the limit by 1 connection, and that connection will be
-   * destroyed when returned to the pool.
-   */
-  public PooledConnection borrowConnection(ServerLocation server,
-      boolean onlyUseExistingCnx) throws AllConnectionsInUseException, NoAvailableServersException {
+  public PooledConnection borrowConnection(ServerLocation server, long acquireTimeout,
+      boolean onlyUseExistingCnx)
+      throws AllConnectionsInUseException, NoAvailableServersException,
+      ServerConnectivityException {
+
-    if (onlyUseExistingCnx) {
-      throw new AllConnectionsInUseException();
+    if (!onlyUseExistingCnx) {
+      connection = forceCreateConnection(server);
+      if (null != connection) {
+        return connection;
+      }
+      throw new ServerConnectivityException(BORROW_CONN_ERROR_MSG + server);
-    connection = forceCreateConnection(server);
-    if (null != connection) {
-      return connection;
+    long waitStart = NOT_WAITING;
+    try {
+      long timeout = System.nanoTime() + MILLISECONDS.toNanos(acquireTimeout);
+      while (true) {
+        connection =
+            availableConnectionManager.useFirst((c) -> c.getServer().equals(server));
+        if (null != connection) {
+          return connection;
+        }
+
+        if (checkShutdownInterruptedOrTimeout(timeout)) {
+          break;
+        }
+
+        waitStart = beginConnectionWaitStatIfNotStarted(waitStart);
+
+        Thread.yield();
+      }
+    } finally {
+      endConnectionWaitStatIfStarted(waitStart);
-    throw new ServerConnectivityException(BORROW_CONN_ERROR_MSG + server);
+    cancelCriterion.checkCancelInProgress(null);
+
+    throw new AllConnectionsInUseException();

INS44 INS43 INS8 INS39 INS42 INS42 MOV60 MOV25 INS25 INS60 INS54 INS21 MOV53 INS38 MOV8 INS39 INS59 INS8 INS8 INS32 INS42 INS42 INS42 INS60 INS61 INS21 INS42 INS42 INS33 INS39 INS59 INS9 INS8 INS32 INS42 INS27 INS21 INS25 INS25 INS21 INS21 INS42 INS42 INS32 INS32 INS7 INS27 INS8 INS32 INS8 INS7 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS33 INS42 INS41 INS42 INS42 INS10 INS42 INS32 INS42 INS42 INS42 INS42 INS86 INS42 INS42 INS42 INS59 INS32 INS42 INS32 INS42 INS42 INS42 INS42 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL8 DEL25
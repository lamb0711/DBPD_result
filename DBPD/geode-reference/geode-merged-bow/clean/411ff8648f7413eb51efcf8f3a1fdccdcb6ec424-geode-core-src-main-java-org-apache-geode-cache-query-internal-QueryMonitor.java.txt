GEODE-5993: Eliminate race in monitorQueryThread() (#2818)

A race existed between setting low memory in the heap monitor thread,
and checking the low memory state in query monitoring thread.

The cancelation executor was shut down and no longer accepting new
tasks when this race occurred, causing a RejectedExecutionException.

This commit solves that problem by encapsulating the scheduling
behavior using the state design pattern.

Co-authored-by: Ryan McMahon <rmcmahon@pivotal.io>
Co-authored-by: Bill Burcham <bburcham@pivotal.io>

+import java.util.concurrent.ScheduledExecutorService;
- * query execution time might be set (upon construction) via the system property
- * {@link GemFireCacheImpl#MAX_QUERY_EXECUTION_TIME}. The number of threads allocated to query
- * monitoring is determined by the instance of {@link ScheduledThreadPoolExecutorFactory} passed
- * to the constructor.
+ * query execution time might be set (upon construction) via the system property {@link
+ * GemFireCacheImpl#MAX_QUERY_EXECUTION_TIME}. The number of threads allocated to query monitoring
+ * is determined by the instance of {@link ScheduledThreadPoolExecutor} passed to the
+ * constructor.
- * This class supports a low-memory mode, established by {@link #setLowMemory(boolean, long)}. \
- * In that mode, any attempt to monitor a (new) query will throw an exception.
+ * This class supports a low-memory mode, established by {@link #setLowMemory(boolean, long)}
+ * with {@code isLowMemory=true}. In that mode, any attempt to monitor a (new) query will
+ * throw an exception.
- * The {@link #monitorQueryThread(DefaultQuery)} method initiates monitoring of a query.
- * {@link #stopMonitoringQueryThread(DefaultQuery)} stops monitoring a query.
+ * The {@link #monitorQueryThread(DefaultQuery)} method initiates monitoring of a query. {@link
+ * #stopMonitoringQueryThread(DefaultQuery)} stops monitoring a query.
- * If the {@link QueryMonitor} determines a query needs to be canceled: either because it is
- * taking too long, or because memory is running low, it does two things:
+ * If the {@link QueryMonitor} determines a query needs to be canceled: either because it is taking
+ * too long, or because memory is running low, it does two things:
- * so that subsequent calls to {@link #throwExceptionIfQueryOnCurrentThreadIsCanceled()}
- * will throw an exception</li>
+ * so that subsequent calls to {@link #throwExceptionIfQueryOnCurrentThreadIsCanceled()} will throw
+ * an exception</li>
- * Code outside this class, that wishes to participate in cooperative cancelation of queries
- * calls {@link #throwExceptionIfQueryOnCurrentThreadIsCanceled()} at various yield points.
- * In catch blocks, {@link DefaultQuery#getQueryCanceledException()} is interrogated to learn
- * the cancelation cause.
+ * Code outside this class, that wishes to participate in cooperative cancelation of queries calls
+ * {@link #throwExceptionIfQueryOnCurrentThreadIsCanceled()} at various yield points. In catch
+ * blocks, {@link DefaultQuery#getQueryCanceledException()} is interrogated to learn the cancelation
+ * cause.
-  private final ScheduledThreadPoolExecutorFactory executorFactory;
+  private final ScheduledThreadPoolExecutor executor;
-  private volatile ScheduledThreadPoolExecutor executor;
+  private static volatile MemoryState memoryState = MemoryStateImpl.HEAP_AVAILABLE;
-  private volatile boolean cancelingDueToLowMemory;
-
-  private static volatile Boolean LOW_MEMORY = Boolean.FALSE;
-
-  private static volatile long LOW_MEMORY_USED_BYTES = 0;
-
-  @FunctionalInterface
-  public interface ScheduledThreadPoolExecutorFactory {
-    ScheduledThreadPoolExecutor create();
-  }
+  private static volatile long memoryUsedBytes = 0;
-   * This class will call {@link ScheduledThreadPoolExecutor#setRemoveOnCancelPolicy(boolean)}
-   * on {@link ScheduledThreadPoolExecutor} instances returned by the
-   * {@link ScheduledThreadPoolExecutorFactory} to set that property to {@code true}.
+   * This class will call {@link ScheduledThreadPoolExecutor#setRemoveOnCancelPolicy(boolean)} on
+   * {@code executor} to set that property to {@code true}.
-   * The default behavior of a {@link ScheduledThreadPoolExecutor} is to keep canceled
-   * tasks in the queue, relying on the timeout processing loop to remove them
-   * when their time is up. That behaviour would result in tasks for completed
-   * queries to remain in the queue until their timeout deadline was reached,
-   * resulting in queue growth.
+   * The default behavior of a {@link ScheduledThreadPoolExecutor} is to keep canceled tasks in the
+   * queue, relying on the timeout processing loop to remove them when their time is up. That
+   * behaviour would cause tasks for completed queries to remain in the queue until their
+   * timeout deadline was reached, resulting in queue growth.
-   * Setting the remove-on-cancel-policy to {@code true} changes that behavior so tasks are
-   * removed immediately upon cancelation (via {@link #stopMonitoringQueryThread(DefaultQuery)}).
+   * Setting the remove-on-cancel-policy to {@code true} changes that behavior so tasks are removed
+   * immediately upon cancelation (via {@link #stopMonitoringQueryThread(DefaultQuery)}).
-   * @param executorFactory is called to construct the initial executor. It's called subsequently
-   *        every time the QueryMonitor moves out of the low-memory state, to create a new executor.
+   * @param executor is responsible for processing scheduled cancelation tasks
-   * @param defaultMaxQueryExecutionTime is the maximum time, in milliseconds, that any query
-   *        is allowed to run
+   * @param defaultMaxQueryExecutionTime is the maximum time, in milliseconds, that any query is
+   *        allowed to run
-  public QueryMonitor(final ScheduledThreadPoolExecutorFactory executorFactory,
+  public QueryMonitor(final ScheduledThreadPoolExecutor executor,
-    Objects.requireNonNull(executorFactory);
+    Objects.requireNonNull(executor);
-    this.executorFactory = executorFactory;
-    this.executor = executorFactory.create();
+    this.executor = executor;
-   * Add query to be monitored.
+   * Start monitoring the query.
-   * Must not be called from a thread that is not the query thread,
-   * because this class uses a ThreadLocal on the query thread!
+   * Must not be called from a thread that is not the query thread, because this class uses a
+   * ThreadLocal on the query thread!
-   * Each query can have a different maxQueryExecution time. Make this method public to
-   * expose that feature to callers.
+   * Each query can have a different maxQueryExecution time. Make this method public to expose that
+   * feature to callers.
-   * Must not be called from a thread that is not the query thread,
-   * because this class uses a ThreadLocal on the query thread!
+   * Must not be called from a thread that is not the query thread, because this class uses a
+   * ThreadLocal on the query thread!
-    if (LOW_MEMORY) {
-      final QueryExecutionLowMemoryException lowMemoryException = createLowMemoryException();
-      query.setQueryCanceledException(lowMemoryException);
-      throw lowMemoryException;
-    }
-
-   * Stops monitoring the query.
+   * Stop monitoring the query.
-   * Must not be called from a thread that is not the query thread,
-   * because this class uses a ThreadLocal on the query thread!
+   * Must not be called from a thread that is not the query thread, because this class uses a
+   * ThreadLocal on the query thread!
-   * Throw an exception if the query has been canceled. The {@link QueryMonitor} cancels the
-   * query if it takes more than the max query execution time or in low memory situations where
-   * critical heap percentage has been set on the resource manager.
+   * Throw an exception if the query has been canceled. The {@link QueryMonitor} cancels the query
+   * if it takes more than the max query execution time or in low memory situations where critical
+   * heap percentage has been set on the resource manager.
-  /**
-   * Assumes LOW_MEMORY will only be set if query monitor is enabled
-   */
-    return LOW_MEMORY;
+    return memoryState.isLowMemory();
-  public static long getMemoryUsedDuringLowMemory() {
-    return LOW_MEMORY_USED_BYTES;
+  public static long getMemoryUsedBytes() {
+    return memoryUsedBytes;
-   * Caller should not call this method concurrently from multiple threads. Doing so can
-   * result in lost low memory state updates due to lock unfairness.
+   * Caller must not call this method concurrently from multiple threads.
+   * In addition to causing data inconsistency, concurrent calls will result in
+   * lost updates e.g. transitions to low-memory status could be missed,
+   * resulting in a failure to cancel queries.
-  public synchronized void setLowMemory(final boolean isLowMemory, final long usedBytes) {
-    if (!cache.isQueryMonitorDisabledForLowMemory()) {
-      QueryMonitor.LOW_MEMORY_USED_BYTES = usedBytes;
-      final boolean memoryStateChanged = isLowMemory != QueryMonitor.LOW_MEMORY;
-      if (memoryStateChanged) {
+  public void setLowMemory(final boolean isLowMemory, final long usedBytes) {
+    memoryState.setLowMemory(executor, isLowMemory, usedBytes, cache);
+  }
+
+  /**
+   * This interface plays the role of the "State" interface in the GoF "State" design pattern.
+   * Its implementations embodied in the {@link MemoryStateImpl} enum (an abstract base class,
+   * or ABC) and its enum constants (subclasses of the ABC) play the role of "ConcreteState"
+   * classes in that design pattern.
+   *
+   * The "Context" role is fulfilled by the melange of behavior
+   * and state embodied in the (static) {@link #isLowMemory()} and
+   * {@link #getMemoryUsedBytes()} methods and the {@link #setLowMemory(boolean, long)}
+   * method and the static fields they manipulate.
+   */
+  private interface MemoryState {
+    void setLowMemory(ScheduledThreadPoolExecutor executor,
+        boolean isLowMemory,
+        long usedBytes,
+        InternalCache cache);
+
+    ScheduledFuture<?> schedule(Runnable command,
+        long delay,
+        TimeUnit unit,
+        ScheduledExecutorService scheduledExecutorService,
+        DefaultQuery query);
+
+    boolean isLowMemory();
+
+    CacheRuntimeException createCancelationException(long timeLimitMillis,
+        DefaultQuery query);
+  }
+
+  /**
+   * This enum (an abstract base class or ABC) and its enum constants (subclasses of the ABC)
+   * play the role of "ConcreteState" classes in the GoF "State" pattern.
+   *
+   * See {@link MemoryState} for details.
+   */
+  private enum MemoryStateImpl implements MemoryState {
+    HEAP_AVAILABLE {
+      @Override
+      public void _setLowMemory(final ScheduledThreadPoolExecutor executor,
+          final boolean isLowMemory,
+          final long usedBytes,
+          final InternalCache cache) {
-          cancelAllQueriesDueToMemory();
-        } else {
+          memoryState = HEAP_EXHAUSTED;
+
-           * Executor was shut down and made permanently unusable when we went into
-           * the low-memory state. We have to make a new executor now that we're monitoring
-           * queries again.
+           * We need to already be in the HEAP_EXHAUSTED state because we want the
+           * cancelation behavior associated with that state.
-          executor = executorFactory.create();
+          cancelAllQueries(executor);
+        }
+        // Otherwise, no state change
+      }
+
+      @Override
+      public boolean isLowMemory() {
+        return false;
+      }
+
+      @Override
+      public ScheduledFuture<?> schedule(final Runnable command, final long delay,
+          final TimeUnit unit,
+          final ScheduledExecutorService scheduledExecutorService,
+          final DefaultQuery query) {
+        return scheduledExecutorService.schedule(command, delay, unit);
+      }
+
+      @Override
+      public CacheRuntimeException createCancelationException(final long timeLimitMillis,
+          final DefaultQuery query) {
+        final String message = String.format(
+            "Query execution canceled after exceeding max execution time %sms.",
+            timeLimitMillis);
+        if (logger.isInfoEnabled()) {
+          logger.info(String.format("%s %s", message, query));
+        }
+        return new QueryExecutionTimeoutException(message);
+      }
+
+      /**
+       * Run all cancelation tasks. Leave the executor's task queue empty.
+       */
+      private void cancelAllQueries(final ScheduledThreadPoolExecutor executor) {
+        final BlockingQueue<Runnable> expirationTaskQueue = executor.getQueue();
+        for (final Runnable cancelationTask : expirationTaskQueue) {
+          if (expirationTaskQueue.remove(cancelationTask)) {
+            cancelationTask.run();
+          }
-      QueryMonitor.LOW_MEMORY = isLowMemory;
-    }
-  }
-  /**
-   * Stop accepting new monitoring requests. Run all cancelation tasks with
-   * {@link #cancelingDueToLowMemory} set. Leave the executor's task queue empty.
-   */
-  private synchronized void cancelAllQueriesDueToMemory() {
-
-    /*
-     * A cancelation task is dual-purpose. Its primary purpose is to cancel
-     * a query if the query runs too long. Alternately, if this flag
-     * {@link #cancelingDueToLowMemory} is set, the cancelation task will cancel the query
-     * due to low memory.
-     */
-    cancelingDueToLowMemory = true;
-
-    try {
-      /*
-       * It's tempting to try to process the list of tasks returned from shutdownNow().
-       * Unfortunately, that call leaves the executor in a state that causes the task's
-       * run() to cancel the task, instead of actually running it. By calling shutdown()
-       * we block new task additions and put the executor in a state that allows the
-       * task's run() to actually run the task logic.
-       */
-      executor.shutdown(); // executor won't accept new work ever again
-      final BlockingQueue<Runnable> expirationTaskQueue = executor.getQueue();
-      for (final Runnable cancelationTask : expirationTaskQueue) {
-        cancelationTask.run();
+    },
+    HEAP_EXHAUSTED {
+      @Override
+      public void _setLowMemory(final ScheduledThreadPoolExecutor executor,
+          final boolean isLowMemory,
+          final long usedBytes,
+          final InternalCache cache) {
+        if (!isLowMemory) {
+          memoryState = HEAP_AVAILABLE;
+        }
+        // Otherwise, no state change
-      expirationTaskQueue.clear();
-    } finally {
-      cancelingDueToLowMemory = false;
+
+      @Override
+      public boolean isLowMemory() {
+        return true;
+      }
+
+      @Override
+      public ScheduledFuture<?> schedule(final Runnable command, final long timeLimitMillis,
+          final TimeUnit unit,
+          final ScheduledExecutorService scheduledExecutorService,
+          final DefaultQuery query) {
+        final CacheRuntimeException lowMemoryException =
+            createCancelationException(timeLimitMillis, query);
+        query.setQueryCanceledException(lowMemoryException);
+        throw lowMemoryException;
+      }
+
+      @Override
+      public CacheRuntimeException createCancelationException(final long timeLimitMillis,
+          final DefaultQuery query) {
+        return new QueryExecutionLowMemoryException(
+            String.format(
+                "Query execution canceled due to memory threshold crossed in system, memory used: %s bytes.",
+                memoryUsedBytes));
+      }
+
+    };
+
+    @Override
+    public void setLowMemory(final ScheduledThreadPoolExecutor executor,
+        final boolean isLowMemory,
+        final long usedBytes,
+        final InternalCache cache) {
+      if (cache.isQueryMonitorDisabledForLowMemory()) {
+        return;
+      }
+
+      memoryUsedBytes = usedBytes;
+
+      _setLowMemory(executor, isLowMemory, usedBytes, cache);
+    }
+
+    void _setLowMemory(final ScheduledThreadPoolExecutor executor,
+        final boolean isLowMemory,
+        final long usedBytes,
+        final InternalCache cache) {
+      throw new IllegalStateException("subclass must override");
-    return executor.schedule(() -> {
-      final CacheRuntimeException exception = cancelingDueToLowMemory ? createLowMemoryException()
-          : createExpirationException(timeLimitMillis);
+    /*
+     * This is where the GoF "State" design pattern comes home to roost.
+     *
+     * memoryState.schedule() is going to either schedule or throw an exception depending on what
+     * state we are _currently_ in. Remember the switching of that state (reference) happens
+     * in a separate thread, up in the setLowMemory() method, generally called by the
+     * HeapMemoryMonitor.
+     *
+     * The first line of the lambda/closure, when it _eventually_ runs (in yet another thread--
+     * a thread from the executor), will access what is _then_ the current state, through
+     * memoryState, to createCancelationException().
+     */
+    return memoryState.schedule(() -> {
+      final CacheRuntimeException exception = memoryState
+          .createCancelationException(timeLimitMillis, query);
-      if (logger.isInfoEnabled() && !cancelingDueToLowMemory) {
-        logger.info(String.format("%s %s", exception.getMessage(), query));
-      }
-    }, timeLimitMillis, TimeUnit.MILLISECONDS);
-  }
-
-  private QueryExecutionTimeoutException createExpirationException(final long timeLimitMillis) {
-    return new QueryExecutionTimeoutException(
-        String.format(
-            "Query execution canceled after exceeding max execution time %sms.",
-            timeLimitMillis));
-  }
-
-  private QueryExecutionLowMemoryException createLowMemoryException() {
-    return new QueryExecutionLowMemoryException(
-        String.format(
-            "Query execution canceled due to memory threshold crossed in system, memory used: %s bytes.",
-            LOW_MEMORY_USED_BYTES));
+    }, timeLimitMillis, TimeUnit.MILLISECONDS, executor, query);

INS26 INS40 INS31 INS55 INS71 UPD83 UPD43 UPD42 MOV29 MOV83 MOV39 MOV42 INS44 INS44 INS8 INS29 INS83 INS42 INS31 INS31 INS31 INS31 INS29 INS83 INS42 INS43 INS72 INS72 INS31 INS31 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS65 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 UPD42 UPD40 UPD42 UPD43 UPD42 INS83 INS39 INS42 INS83 INS39 INS42 MOV21 INS65 INS39 INS42 INS44 INS44 INS44 INS44 INS74 INS42 INS44 INS44 INS44 INS44 INS44 INS39 INS42 INS43 INS42 INS44 INS44 INS65 INS42 INS42 INS1 INS42 INS1 INS78 INS83 INS39 INS42 INS44 MOV44 MOV44 INS44 INS8 INS39 INS42 INS44 INS44 INS44 INS44 INS8 UPD42 INS66 UPD66 UPD65 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 UPD66 UPD66 UPD66 UPD42 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS32 UPD42 UPD66 INS66 UPD66 INS66 INS32 INS66 INS66 INS65 INS66 INS66 INS66 INS66 INS66 INS65 INS66 INS65 INS66 INS65 INS66 MOV43 INS42 INS39 INS42 INS39 INS42 INS43 INS42 INS43 INS76 INS43 INS42 INS39 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS39 INS42 INS43 INS42 INS66 INS66 INS66 INS65 INS66 INS31 INS31 INS31 INS31 MOV31 INS31 INS31 INS31 INS31 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS25 INS21 INS21 INS83 INS43 INS42 INS83 INS39 INS42 INS83 INS39 INS42 INS83 INS43 INS42 INS53 INS66 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS68 INS68 INS68 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS78 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 INS83 INS74 INS42 INS44 INS44 INS44 INS44 INS44 INS8 INS78 INS83 INS43 INS42 MOV44 INS44 INS8 UPD42 INS44 MOV8 INS78 INS83 INS39 INS42 INS44 INS44 INS44 INS44 INS8 INS78 INS83 INS39 INS42 INS8 INS78 UPD83 MOV83 INS74 INS42 INS44 INS44 INS44 INS44 INS44 MOV8 INS78 UPD83 MOV83 UPD43 MOV43 UPD42 MOV42 INS44 INS44 MOV8 INS42 INS42 MOV32 INS8 INS7 INS32 INS42 INS42 INS14 UPD42 INS42 INS42 INS42 INS42 INS42 INS69 INS69 INS42 INS83 INS43 INS42 INS83 INS39 INS42 INS83 INS39 INS42 INS83 INS43 INS42 INS25 INS42 INS41 INS42 INS43 INS76 INS83 INS43 INS42 INS83 INS39 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS41 INS42 INS42 INS83 INS43 INS42 INS60 INS25 INS41 INS83 INS43 INS42 INS42 INS83 INS43 INS42 INS83 INS39 INS42 INS83 INS39 INS42 INS83 INS43 INS42 INS25 INS42 INS41 INS42 INS43 INS76 INS83 INS43 INS42 INS83 INS39 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS83 INS43 INS42 INS60 MOV21 MOV53 INS42 UPD42 INS83 INS39 INS42 INS83 INS43 INS42 INS41 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS45 INS39 INS39 INS42 INS42 INS42 MOV8 INS9 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS83 INS43 INS59 MOV32 MOV8 INS14 UPD66 INS42 INS8 INS42 INS42 INS38 INS8 INS9 INS42 INS42 INS42 UPD42 MOV42 INS42 INS83 MOV43 INS59 INS42 INS42 INS60 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 MOV43 INS42 INS25 INS42 MOV21 INS42 INS32 MOV83 INS43 INS59 INS7 INS32 INS32 MOV8 INS42 INS42 INS42 UPD42 INS42 INS42 INS32 INS42 INS42 UPD42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 INS42 UPD42 MOV42 UPD42 MOV42 MOV42 MOV42 UPD42 MOV42 INS42 INS45 UPD42 MOV42 INS42 DEL66 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL78 DEL83 DEL42 DEL42 DEL31 DEL55 DEL66 DEL42 DEL66 DEL66 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL83 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25 DEL66 DEL65 DEL29 DEL42 DEL40 DEL42 DEL7 DEL42 DEL32 DEL7 DEL66 DEL42 DEL67 DEL65 DEL83 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL9 DEL7 DEL21 DEL8 DEL54 DEL8 DEL40 DEL14 DEL41 DEL83 DEL38 DEL83 DEL39 DEL42 DEL42 DEL40 DEL27 DEL59 DEL60 DEL42 DEL42 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31 DEL42 DEL42 DEL32 DEL32 DEL16 DEL59 DEL60 DEL42 DEL38 DEL27 DEL42 DEL42 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL32 DEL32 DEL21 DEL8 DEL25 DEL43 DEL42 DEL31 DEL31
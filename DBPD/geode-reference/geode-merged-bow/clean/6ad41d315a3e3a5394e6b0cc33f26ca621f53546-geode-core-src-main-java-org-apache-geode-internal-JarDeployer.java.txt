Revert "GEODE-7436: Deploy jar using semantic versioning scheme (#4343)" (#4380)

This reverts commit 0d4c1912


+import static java.util.stream.Collectors.joining;
+import java.net.URL;
-import java.nio.file.Path;
+import java.util.Objects;
+import java.util.Optional;
-import org.apache.commons.io.FilenameUtils;
-  // The pound version scheme predates the sequenced version scheme
-  private static final Pattern POUND_VERSION_SCHEME =
-      Pattern.compile("^vf\\.gf#(?<artifact>.*)\\.jar#(?<version>\\d+)$");
-  // Every deployed file will use this scheme to signify the sequence it's been deployed
-  static final Pattern DEPLOYED_FILE_PATTERN =
-      Pattern.compile("(?<baseName>..*)\\.v(?<version>\\d++).jar$");
-  // we can recognize jar files with below pattern. If two jar files have the same artifact, then
-  // the latter will replace the former deployed jar
-  private static final Pattern USER_VERSION_PATTERN =
-      Pattern.compile("(?<artifact>.*?)[-.]\\d+.*\\.jar$");
-
+  public static final String JAR_PREFIX_FOR_REGEX = "";
+
+
+  // Split a versioned filename into its name and version
+  public static final Pattern versionedPattern =
+      Pattern.compile(JAR_PREFIX_FOR_REGEX + "(.*)\\.v(\\d++).jar$");
+
+  public File getDeployDirectory() {
+    return this.deployDirectory;
+  }
+
-   * not match the latest deployed version).
+   * not match the latest deployed version)
-  public DeployedJar deployWithoutRegistering(final File stagedJar)
+  public DeployedJar deployWithoutRegistering(final String jarName, final File stagedJar)
-    String stagedJarName = stagedJar.getName();
-    String artifactId = getArtifactId(stagedJarName);
+
-      boolean shouldDeployNewVersion = shouldDeployNewVersion(artifactId, stagedJar);
+      boolean shouldDeployNewVersion = shouldDeployNewVersion(jarName, stagedJar);
-        logger.debug("No need to deploy a new version of {}", stagedJarName);
+        logger.debug("No need to deploy a new version of {}", jarName);
-      Path deployedFile = getNextVersionedJarFile(stagedJarName).toPath();
-      Files.copy(stagedJar.toPath(), deployedFile);
-      return new DeployedJar(deployedFile.toFile());
+      File newVersionedJarFile = getNextVersionedJarFile(jarName);
+      Files.copy(stagedJar.toPath(), newVersionedJarFile.toPath());
+
+      return new DeployedJar(newVersionedJarFile, jarName);
-    int maxVersion = getMaxVersion(getArtifactId(unversionedJarName));
+    File[] oldVersions = findSortedOldVersionsOfJar(unversionedJarName);
-    String nextVersionJarName =
-        FilenameUtils.getBaseName(unversionedJarName) + ".v" + (maxVersion + 1) + ".jar";
+    String nextVersionedJarName;
+    if (oldVersions == null || oldVersions.length == 0) {
+      nextVersionedJarName = removeJarExtension(unversionedJarName) + ".v1.jar";
+    } else {
+      String latestVersionedJarName = oldVersions[0].getName();
+      int nextVersion = extractVersionFromFilename(latestVersionedJarName) + 1;
+      nextVersionedJarName = removeJarExtension(unversionedJarName) + ".v" + nextVersion + ".jar";
+    }
-    logger.debug("Next versioned jar name for {} is {}", unversionedJarName, nextVersionJarName);
+    logger.debug("Next versioned jar name for {} is {}", unversionedJarName, nextVersionedJarName);
-    return new File(deployDirectory, nextVersionJarName);
-  }
-
-  protected int getMaxVersion(String artifactId) {
-    return Arrays.stream(deployDirectory.list()).filter(x -> artifactId.equals(toArtifactId(x)))
-        .map(JarDeployer::extractVersionFromFilename)
-        .reduce(Integer::max).orElse(0);
+    return new File(deployDirectory, nextVersionedJarName);
-    final Matcher matcher = DEPLOYED_FILE_PATTERN.matcher(filename);
+    final Matcher matcher = versionedPattern.matcher(filename);
-  public static boolean isDeployedFile(String filename) {
-    return DEPLOYED_FILE_PATTERN.matcher(filename).find();
-  }
+  protected Set<String> findDistinctDeployedJarsOnDisk() {
+    // Find all deployed JAR files
+    final File[] oldFiles =
+        this.deployDirectory.listFiles((file, name) -> versionedPattern.matcher(name).matches());
-  public static boolean isSemanticVersion(String filename) {
-    return USER_VERSION_PATTERN.matcher(filename).find();
+    // Now add just the original JAR name to the set
+    final Set<String> jarNames = new HashSet<>();
+    for (File oldFile : oldFiles) {
+      Matcher matcher = versionedPattern.matcher(oldFile.getName());
+      matcher.find();
+      jarNames.add(matcher.group(1) + ".jar");
+    }
+    return jarNames;
-   * get the artifact id from the existing files on the server. This will skip files that
-   * do not have sequence id appended to them.
+   * Find all versions of the JAR file that are currently on disk and return them sorted from newest
+   * (highest version) to oldest
-   * @param sequencedJarFileName the file names that exists on the server, it should always ends
-   *        with a sequence number
-   * @return the artifact id. if a file with no sequence number is passed in, this will return null
+   * @param unversionedJarName Name of the JAR file that we want old versions of
+   * @return Sorted array of files that are older versions of the given JAR
-  static String toArtifactId(String sequencedJarFileName) {
-    String baseName = getDeployedFileBaseName(sequencedJarFileName);
-    if (baseName == null) {
-      return null;
-    }
+  protected File[] findSortedOldVersionsOfJar(final String unversionedJarName) {
+    logger.debug("Finding sorted old versions of {}", unversionedJarName);
+    // Find all matching files
+    final Pattern pattern = Pattern.compile(
+        JAR_PREFIX_FOR_REGEX + removeJarExtension(unversionedJarName) + "\\.v\\d++\\.jar$");
+    final File[] oldJarFiles =
+        this.deployDirectory.listFiles((file, name) -> (pattern.matcher(name).matches()));
-    return getArtifactId(baseName + ".jar");
+    // Sort them in order from newest (highest version) to oldest
+    Arrays.sort(oldJarFiles, (file1, file2) -> {
+      int file1Version = extractVersionFromFilename(file1.getName());
+      int file2Version = extractVersionFromFilename(file2.getName());
+      return file2Version - file1Version;
+    });
+
+    logger.debug("Found [{}]",
+        Arrays.stream(oldJarFiles).map(File::getAbsolutePath).collect(joining(",")));
+    return oldJarFiles;
-  /**
-   * get the artifact id from the files deployed by the user. This will recognize files with
-   * SEMANTIC_VERSION_PATTERN, it will strip off the version part from the filename. For all other
-   * file names, it will just return the basename.
-   *
-   * @param deployedJarFileName the filename that's deployed by the user. could be in the form of
-   *        abc.jar or abc-1.0.0.jar, both should return abc
-   * @return the artifact id of the string
-   */
-  public static String getArtifactId(String deployedJarFileName) {
-    Matcher semanticVersionMatcher = USER_VERSION_PATTERN.matcher(deployedJarFileName);
-    if (semanticVersionMatcher.matches()) {
-      return semanticVersionMatcher.group("artifact");
+  protected String removeJarExtension(String jarName) {
+    if (jarName != null && jarName.endsWith(".jar")) {
+      return jarName.replaceAll("\\.jar$", "");
-      return FilenameUtils.getBaseName(deployedJarFileName);
-    }
-  }
-
-  public static String getDeployedFileBaseName(String sequencedJarFileName) {
-    Matcher semanticVersionMatcher = DEPLOYED_FILE_PATTERN.matcher(sequencedJarFileName);
-    if (semanticVersionMatcher.matches()) {
-      return semanticVersionMatcher.group("baseName");
-    } else {
-      return null;
+      return jarName;
+  final Pattern oldNamingPattern = Pattern.compile("^vf\\.gf#(.*)\\.jar#(\\d+)$");
+
-    return POUND_VERSION_SCHEME.matcher(fileName).matches();
+    return oldNamingPattern.matcher(fileName).matches();
-    Matcher matcher = POUND_VERSION_SCHEME.matcher(oldJar.getName());
+    Matcher matcher = oldNamingPattern.matcher(oldJar.getName());
-   * It will clean up the old version of deployed jars that are in the deployed directory
-      // find all the artifacts and its max versions
-      Map<String, Integer> artifactToMaxVersion = findArtifactsAndMaxVersion();
+
+      final Set<String> jarNames = findDistinctDeployedJarsOnDisk();
+      if (jarNames.isEmpty()) {
+        return;
+      }
+
-      // clean up the old versions and find the latest version of each jar
-      for (File file : deployDirectory.listFiles()) {
-        String artifactId = toArtifactId(file.getName());
-        if (artifactId == null) {
-          continue;
-        }
-        int version = extractVersionFromFilename(file.getName());
-        if (version < artifactToMaxVersion.get(artifactId)) {
-          FileUtils.deleteQuietly(file);
-        } else {
-          latestVersionOfEachJar.add(new DeployedJar(file));
+      for (String jarName : jarNames) {
+        DeployedJar deployedJar = findLatestValidDeployedJarFromDisk(jarName);
+
+        if (deployedJar != null) {
+          latestVersionOfEachJar.add(deployedJar);
+          deleteOtherVersionsOfJar(deployedJar);
-  Map<String, Integer> findArtifactsAndMaxVersion() {
-    Map<String, Integer> artifactToMaxVersion = new HashMap<>();
-    for (String fileName : deployDirectory.list()) {
-      String artifactId = toArtifactId(fileName);
-      if (artifactId == null) {
-        continue;
-      }
-      int version = extractVersionFromFilename(fileName);
-      Integer maxVersion = artifactToMaxVersion.get(artifactId);
-      if (maxVersion == null || maxVersion < version) {
-        artifactToMaxVersion.put(artifactId, version);
-      }
-    }
-    return artifactToMaxVersion;
+  /**
+   * Deletes all versions of this jar on disk other than the given version
+   */
+  public void deleteOtherVersionsOfJar(DeployedJar deployedJar) {
+    logger.info("Deleting all versions of " + deployedJar.getJarName() + " other than "
+        + deployedJar.getFileName());
+    final File[] jarFiles = findSortedOldVersionsOfJar(deployedJar.getJarName());
+
+    Stream.of(jarFiles).filter(jarFile -> !jarFile.equals(deployedJar.getFile()))
+        .forEach(jarFile -> {
+          logger.info("Deleting old version of jar: " + jarFile.getAbsolutePath());
+          FileUtils.deleteQuietly(jarFile);
+        });
+  public DeployedJar findLatestValidDeployedJarFromDisk(String unversionedJarName)
+      throws IOException {
+    final File[] jarFiles = findSortedOldVersionsOfJar(unversionedJarName);
+
+    Optional<File> latestValidDeployedJarOptional = Arrays.stream(jarFiles).filter(Objects::nonNull)
+        .filter(jarFile -> DeployedJar.hasValidJarContent(jarFile)).findFirst();
+
+    if (!latestValidDeployedJarOptional.isPresent()) {
+      // No valid version of this jar
+      return null;
+    }
+
+    File latestValidDeployedJar = latestValidDeployedJarOptional.get();
+
+    return new DeployedJar(latestValidDeployedJar, unversionedJarName);
+  }
+
+  public URL[] getDeployedJarURLs() {
+    return this.deployedJars.values().stream().map(DeployedJar::getFileURL).toArray(URL[]::new);
+
+  }
-          DeployedJar oldJar = this.deployedJars.put(deployedJar.getArtifactId(), deployedJar);
+          DeployedJar oldJar = this.deployedJars.put(deployedJar.getJarName(), deployedJar);
-   * When deploying a jar file, it will always append a sequence number .v<digit> to the end of
-   * the file, no matter how the original file is named. This is to allow server on startup to
-   * know what's the last version that gets deployed without cluster configuration.
-   *
-  public List<DeployedJar> deploy(final Set<File> stagedJarFiles)
+  public List<DeployedJar> deploy(final Map<String, File> stagedJarFiles)
-    for (File jar : stagedJarFiles) {
+    for (File jar : stagedJarFiles.values()) {
-      for (File stagedJarFile : stagedJarFiles) {
-        deployedJars.add(deployWithoutRegistering(stagedJarFile));
+      for (String fileName : stagedJarFiles.keySet()) {
+        deployedJars.add(deployWithoutRegistering(fileName, stagedJarFiles.get(fileName)));
-  private boolean shouldDeployNewVersion(String artifactId, File stagedJar) throws IOException {
-    DeployedJar oldDeployedJar = this.deployedJars.get(artifactId);
+  private boolean shouldDeployNewVersion(String jarName, File stagedJar) throws IOException {
+    DeployedJar oldDeployedJar = this.deployedJars.get(jarName);
-  @VisibleForTesting
-    return this.deployedJars.get(getArtifactId(jarName));
+    return this.deployedJars.get(jarName);
-  public DeployedJar deploy(final File stagedJarFile)
+  public DeployedJar deploy(final String jarName, final File stagedJarFile)
-    Set<File> jarFiles = new HashSet();
-    jarFiles.add(stagedJarFile);
+    Map<String, File> jarFiles = new HashMap<>();
+    jarFiles.put(jarName, stagedJarFile);
+
-   * Undeploy the jar file identified by the given artifact ID.
+   * Undeploy the given JAR file.
-   * @param jarName The jarFile to undeploy
+   * @param jarName The name of the JAR file to undeploy
-    String artifactId = getArtifactId(jarName);
-      DeployedJar deployedJar = deployedJars.get(artifactId);
+      DeployedJar deployedJar = deployedJars.remove(jarName);
-        throw new IllegalArgumentException(jarName + " not deployed");
+        throw new IllegalArgumentException("JAR not deployed");
-      if (!deployedJar.getDeployedFileName().equals(jarName)) {
-        throw new IllegalArgumentException(jarName + " not deployed");
-      }
-
-      // remove the deployedJar
-      deployedJars.remove(artifactId);
-      ClassPathLoader.getLatest().unloadClassloaderForArtifact(artifactId);
+      ClassPathLoader.getLatest().unloadClassloaderForJar(jarName);
-  /**
-   *
-   * @param jarName a user deployed jar name (abc.jar or abc-1.0.jar)
-   */
-  public void deleteAllVersionsOfJar(String jarName) {
+  public void deleteAllVersionsOfJar(String unversionedJarName) {
-    String artifactId = getArtifactId(jarName);
-      for (File file : this.deployDirectory.listFiles()) {
-        if (artifactId.equals(toArtifactId(file.getName()))) {
-          logger.info("Deleting: {}", file.getAbsolutePath());
-          FileUtils.deleteQuietly(file);
-        }
+      File[] jarFiles = findSortedOldVersionsOfJar(unversionedJarName);
+      for (File jarFile : jarFiles) {
+        logger.info("Deleting: {}", jarFile.getAbsolutePath());
+        FileUtils.deleteQuietly(jarFile);

MOV26 MOV26 INS26 INS26 MOV23 INS40 UPD40 UPD40 INS40 INS31 INS31 INS31 INS23 INS31 INS31 INS31 INS31 UPD83 MOV43 INS83 MOV43 INS83 MOV43 INS42 INS8 INS44 INS8 MOV83 INS74 INS42 INS8 MOV29 UPD83 MOV83 INS5 INS42 INS44 INS8 UPD83 MOV43 UPD42 INS83 MOV43 INS59 INS29 INS83 INS39 INS42 INS44 INS8 INS83 INS43 INS42 INS44 INS43 INS8 INS83 INS5 INS42 INS8 INS44 MOV83 MOV39 MOV42 MOV44 INS8 UPD42 INS45 UPD42 INS41 INS83 INS43 INS42 MOV21 MOV54 INS60 INS60 INS25 INS43 MOV43 INS60 MOV60 INS70 INS41 INS43 INS85 INS83 MOV43 INS42 INS21 INS60 INS60 INS21 INS21 INS41 UPD42 INS25 INS42 INS32 INS65 INS43 INS42 INS21 INS60 INS21 INS42 INS43 INS42 INS42 INS60 MOV60 MOV25 MOV60 INS41 INS43 INS85 INS41 UPD74 MOV74 UPD42 INS83 INS43 INS42 MOV60 UPD42 MOV21 INS54 INS27 INS22 UPD66 MOV42 INS5 INS59 MOV43 INS59 INS27 INS8 INS8 INS42 INS83 INS5 INS59 INS83 UPD74 INS44 INS42 INS8 INS42 UPD66 UPD66 UPD42 UPD66 UPD66 UPD42 MOV42 INS32 INS83 MOV43 INS59 INS83 INS5 INS59 INS32 INS32 INS42 INS27 MOV8 MOV8 INS42 INS42 INS45 INS66 UPD42 MOV42 INS32 INS83 INS5 INS59 INS32 MOV42 INS83 INS5 MOV59 UPD74 MOV74 INS38 MOV43 INS14 INS42 INS32 UPD43 INS32 INS42 INS74 UPD66 UPD66 INS8 MOV8 INS42 INS45 INS52 INS42 INS43 INS85 INS42 INS32 INS42 INS27 INS27 INS21 INS60 MOV60 INS21 UPD42 UPD42 INS43 INS85 INS42 INS32 MOV43 UPD42 INS43 INS42 INS60 INS21 INS21 UPD42 MOV42 INS42 INS45 UPD42 MOV42 INS42 INS32 INS43 INS85 INS42 INS32 INS42 INS42 INS42 INS86 INS42 INS42 UPD45 MOV45 INS32 INS27 INS32 INS25 INS70 INS42 INS42 INS27 MOV43 INS85 INS42 INS32 INS32 INS42 INS86 INS43 INS85 UPD42 UPD43 UPD42 INS32 INS32 UPD42 MOV43 INS42 INS42 INS32 INS42 INS89 UPD42 INS42 INS42 MOV42 MOV43 MOV43 INS43 UPD42 UPD42 INS42 MOV60 MOV70 UPD43 INS42 INS42 INS42 INS42 INS33 INS40 INS34 INS7 MOV43 INS59 INS7 UPD42 INS42 INS22 UPD42 MOV42 INS86 INS74 INS42 MOV43 INS59 INS32 INS32 UPD42 MOV42 INS42 MOV27 INS42 MOV22 INS42 INS86 INS59 INS59 INS8 INS32 UPD42 MOV42 INS32 INS42 INS33 UPD42 MOV42 UPD42 MOV42 INS45 INS42 UPD42 UPD42 INS83 UPD74 INS32 INS8 INS44 INS42 INS8 INS45 INS32 INS45 INS32 INS42 INS32 INS32 INS42 INS86 INS59 INS8 INS42 UPD42 UPD42 UPD42 INS32 INS42 INS42 INS42 UPD42 INS32 UPD42 MOV42 INS90 INS5 MOV44 INS32 UPD42 INS42 MOV8 INS5 INS42 INS8 UPD42 UPD42 INS32 INS32 INS42 INS42 INS42 INS27 INS42 INS32 UPD42 INS27 INS42 INS27 INS52 INS42 INS59 MOV59 INS32 MOV43 INS42 INS32 MOV42 MOV42 INS42 INS42 INS27 INS42 INS32 UPD45 INS59 INS59 INS36 INS42 INS42 MOV60 INS60 INS41 INS32 INS42 INS90 INS42 INS45 UPD42 UPD42 INS45 UPD45 UPD43 UPD43 UPD42 UPD42 MOV42 UPD42 MOV42 INS41 INS43 INS42 MOV60 MOV25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS59 INS38 INS42 INS21 INS21 INS32 INS42 INS86 MOV32 UPD42 MOV42 INS42 INS42 INS43 INS85 INS42 INS42 UPD42 UPD42 MOV43 INS85 UPD42 INS43 INS42 MOV21 MOV21 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS45 INS2 INS42 INS32 INS34 MOV32 MOV45 UPD42 MOV42 MOV45 INS42 UPD42 INS32 UPD42 MOV42 INS42 UPD42 MOV42 INS32 INS32 INS45 INS42 INS42 INS42 INS42 INS32 INS39 INS39 INS59 INS27 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 UPD42 MOV42 MOV43 UPD27 INS8 INS42 INS32 INS32 INS32 INS32 UPD42 MOV42 INS90 INS59 INS32 UPD42 MOV42 INS42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 INS42 INS42 INS42 INS34 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 MOV42 UPD42 MOV42 INS34 INS32 INS42 UPD42 INS42 INS32 INS42 INS42 UPD42 INS32 UPD42 INS33 MOV21 MOV21 INS42 INS42 INS32 UPD42 MOV42 INS42 INS27 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS45 UPD42 INS42 INS42 INS42 UPD42 INS32 UPD42 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS45 INS32 INS43 INS42 INS32 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS32 UPD42 MOV42 INS42 INS42 INS22 INS42 INS32 INS42 INS52 INS42 INS42 INS42 DEL42 DEL42 DEL45 DEL32 DEL83 DEL83 DEL83 DEL42 DEL42 DEL42 DEL45 DEL32 DEL59 DEL23 DEL45 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL42 DEL32 DEL32 DEL42 DEL42 DEL34 DEL27 DEL36 DEL27 DEL59 DEL60 DEL39 DEL42 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL32 DEL86 DEL32 DEL42 DEL42 DEL90 DEL32 DEL42 DEL42 DEL42 DEL90 DEL32 DEL34 DEL32 DEL41 DEL8 DEL31 DEL66 DEL42 DEL83 DEL83 DEL39 DEL42 DEL42 DEL44 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL32 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL42 DEL43 DEL42 DEL44 DEL32 DEL42 DEL42 DEL32 DEL41 DEL8 DEL42 DEL42 DEL32 DEL41 DEL8 DEL25 DEL8 DEL31 DEL83 DEL33 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL32 DEL25 DEL66 DEL39 DEL42 DEL32 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL14 DEL8 DEL8 DEL42 DEL44 DEL32 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL18 DEL8 DEL25 DEL8 DEL70 DEL39 DEL32 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL43 DEL74 DEL42 DEL32 DEL43 DEL60 DEL42 DEL33 DEL27 DEL18 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL27 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL42 DEL42 DEL44 DEL42 DEL42 DEL78 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL45 DEL27 DEL42 DEL43 DEL42 DEL45 DEL27 DEL14 DEL53 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL38 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL8 DEL25 DEL8 DEL42 DEL66 DEL65 DEL29 DEL8 DEL54 DEL8 DEL31
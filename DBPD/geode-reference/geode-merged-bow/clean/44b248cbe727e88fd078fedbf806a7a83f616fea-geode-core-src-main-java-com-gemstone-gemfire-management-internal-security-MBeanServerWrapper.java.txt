GEODE-17: more cleanup

* break the cirucular dependency in MBeanServerWrapper and ManagementInterceptor
* Now custom authenticator and authorizer can be set independant of each other
* re-arrange the tests
* add test to test local JMX calls to make sure they don't go through the MBeanServerWrapper

Merge branch 'feature/GEODE-17-2' of https://git-wip-us.apache.org/repos/asf/incubator-geode into feature/GEODE-17-2

-import com.gemstone.gemfire.cache.operations.OperationContext.OperationCode;
+import javax.management.Query;
-import java.util.HashSet;
-import static com.gemstone.gemfire.management.internal.security.ResourceConstants.ACCESS_DENIED_MESSAGE;
-
- *
- *
- * @author tushark
-  
+
-  
+
+    // allow operations which requires no permissions
+    if(context == null)
+      return;
+
+    if(context == null)
+      return;
+
-      InstanceAlreadyExistsException, MBeanRegistrationException, MBeanException, NotCompliantMBeanException {
-    throw new SecurityException(ACCESS_DENIED_MESSAGE);
+      InstanceAlreadyExistsException, MBeanException, NotCompliantMBeanException {
+    throw new SecurityException(ResourceConstants.ACCESS_DENIED_MESSAGE);
-      throws ReflectionException, InstanceAlreadyExistsException, MBeanRegistrationException, MBeanException,
+      throws ReflectionException, InstanceAlreadyExistsException, MBeanException,
-    throw new SecurityException(ACCESS_DENIED_MESSAGE);
+    throw new SecurityException(ResourceConstants.ACCESS_DENIED_MESSAGE);
-      throws ReflectionException, InstanceAlreadyExistsException, MBeanRegistrationException, MBeanException,
+      throws ReflectionException, InstanceAlreadyExistsException, MBeanException,
-    throw new SecurityException(ACCESS_DENIED_MESSAGE);
+    throw new SecurityException(ResourceConstants.ACCESS_DENIED_MESSAGE);
-      String[] signature) throws ReflectionException, InstanceAlreadyExistsException, MBeanRegistrationException,
+      String[] signature) throws ReflectionException, InstanceAlreadyExistsException,
-    throw new SecurityException(ACCESS_DENIED_MESSAGE);
+    throw new SecurityException(ResourceConstants.ACCESS_DENIED_MESSAGE);
-    throw new SecurityException(ACCESS_DENIED_MESSAGE);
+    throw new SecurityException(ResourceConstants.ACCESS_DENIED_MESSAGE);
-    throw new SecurityException(ACCESS_DENIED_MESSAGE);
+    throw new SecurityException(ResourceConstants.ACCESS_DENIED_MESSAGE);
+  private static QueryExp notAccessControlMBean = Query.not(Query.isInstanceOf(Query.value(AccessControlMXBean.class.getName())));
-    ResourceOperationContext ctx = new ResourceOperationContext(Resource.MBEAN, OperationCode.QUERY);
-    return filterAccessControlMBeanInstance(mbs.queryMBeans(name, query));
-  }
-
-  private Set<ObjectInstance> filterAccessControlMBeanInstance(Set<ObjectInstance> queryMBeans) {
-    Set<ObjectInstance> set = new HashSet<ObjectInstance>();
-    for(ObjectInstance oi : queryMBeans) {
-      if(!oi.getObjectName().equals(interceptor.getAccessControlMBeanON())){
-        set.add(oi);
-      }
-    }
-    return set;
+    // We need to filter out the AccessControlMXBean so that the clients wouldn't see it
+    if(query!=null)
+      return mbs.queryMBeans(name, Query.and(query, notAccessControlMBean));
+    else
+      return mbs.queryMBeans(name,notAccessControlMBean);
-    return filterAccessControlMBean(mbs.queryNames(name, query));
-  }
-
-  private Set<ObjectName> filterAccessControlMBean(Set<ObjectName> queryNames) {
-    Set<ObjectName> set = new HashSet<ObjectName>();
-    for(ObjectName oi : queryNames) {
-      if(!oi.equals(interceptor.getAccessControlMBeanON())){
-        set.add(oi);
-      }
-    }
-    return set;
+    if(query!=null)
+      return mbs.queryNames(name, Query.and(query, notAccessControlMBean));
+    else
+      return mbs.queryNames(name,notAccessControlMBean);
-    ctx.setPostOperationResult(result);
+    if(ctx != null) {
+      ctx.setPostOperationResult(result);
+    }
-    ctx.setPostOperationResult(result);
+    if(ctx!=null)
+      ctx.setPostOperationResult(result);
-    // Initialize the context with the default value
-    ResourceOperationContext result = new ResourceOperationContext(Resource.DEFAULT, OperationCode.LIST_DS);
+    // If there is no annotation defined either in the class level or method level, we should consider this operation/attribute freely accessible
+    ResourceOperationContext result = null;
+  public ManagementInterceptor getInterceptor() {
+    return interceptor;
+  }
+

MOV26 MOV31 UPD40 INS23 UPD43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 INS83 INS83 INS43 INS59 MOV78 UPD83 MOV74 INS42 MOV44 MOV44 UPD83 INS43 UPD42 INS8 INS25 INS25 UPD42 INS42 INS42 INS32 INS25 INS25 INS25 INS25 UPD42 MOV42 INS41 INS27 INS41 INS27 INS41 INS42 INS42 INS32 INS27 INS41 INS41 INS27 INS41 INS41 INS27 INS8 INS27 MOV21 INS42 INS42 INS33 INS42 INS33 INS40 INS40 INS40 INS40 INS40 INS40 INS42 UPD42 MOV42 MOV32 INS42 INS33 INS32 INS32 INS42 INS33 INS32 INS32 INS42 INS33 MOV21 INS42 INS33 INS33 UPD42 UPD42 INS32 INS42 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 MOV42 MOV42 MOV42 INS32 INS42 INS42 INS42 INS42 INS57 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 MOV42 INS42 INS43 INS42 DEL40 DEL26 DEL40 DEL26 DEL66 DEL65 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL83 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL40 DEL40 DEL14 DEL59 DEL60 DEL32 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL32 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL41 DEL42 DEL32 DEL32 DEL41 DEL42 DEL43 DEL40 DEL40 DEL14 DEL43 DEL42 DEL43 DEL74 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL41 DEL8
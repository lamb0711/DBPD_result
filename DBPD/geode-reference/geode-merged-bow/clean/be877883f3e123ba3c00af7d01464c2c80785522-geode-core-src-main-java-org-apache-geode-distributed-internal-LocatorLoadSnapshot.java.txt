GEODE-7565: Allow gateway receivers with same host and port (2nd try)

This reverts the revert of the original commit, adds extra tests and
also fixes the originally introduced issues.

----

There was a problem with Geode WAN replication when GW receivers are
configured with the same hostname-for-senders and port on all servers.
The reason for such a setup is deploying Geode cluster on a Kubernetes
cluster where all GW receivers are reachable from the outside world on
the same VIP and port.

The problem experienced is that shutting down one server is stopping
replication to this cluster until the server is up again. This is
because Geode incorrectly assumes there are no more alive servers when
just one of them is down, because since they share hostname-for-senders
and port, they are treated as one same server.

With these changes locator is able to distinguish the different
receivers using the same hostname and port so replication is not
impacted when one server is stopped.
+import org.apache.geode.InternalGemFireException;
+import org.apache.geode.annotations.VisibleForTesting;
-  private final Map<String, Map<ServerLocation, LoadHolder>> connectionLoadMap = new HashMap<>();
+  private final Map<String, Map<ServerLocationAndMemberId, LoadHolder>> connectionLoadMap =
+      new HashMap<>();
-  public void addServer(ServerLocation location, String[] groups, ServerLoad initialLoad) {
-    addServer(location, groups, initialLoad, 30000);
-  }
-
-  public synchronized void addServer(ServerLocation location, String[] groups,
+  public synchronized void addServer(ServerLocation location, String memberId, String[] groups,
-    LoadHolder connectionLoad = new LoadHolder(location, initialLoad.getConnectionLoad(),
-        initialLoad.getLoadPerConnection(), loadPollInterval);
-    addGroups(connectionLoadMap, groups, connectionLoad);
-    LoadHolder queueLoad = new LoadHolder(location, initialLoad.getSubscriptionConnectionLoad(),
+    LoadHolder connectionLoad =
+        new LoadHolder(location, initialLoad.getConnectionLoad(),
+            initialLoad.getLoadPerConnection(), loadPollInterval);
+    addGroups(connectionLoadMap, groups, connectionLoad, memberId);
+    LoadHolder queueLoad = new LoadHolder(location,
+        initialLoad.getSubscriptionConnectionLoad(),
-    updateLoad(location, initialLoad);
+    updateLoad(location, memberId, initialLoad);
-  public synchronized void removeServer(ServerLocation location) {
+  public synchronized void removeServer(ServerLocation location, String memberId) {
-      removeFromMap(connectionLoadMap, groups, location);
+      removeFromMap(connectionLoadMap, groups, location, memberId);
-  public void updateLoad(ServerLocation location, ServerLoad newLoad) {
-    updateLoad(location, newLoad, null);
+  public void updateLoad(ServerLocation location, String memberId, ServerLoad newLoad) {
+    updateLoad(location, memberId, newLoad, null);
-  synchronized void updateLoad(ServerLocation location, ServerLoad newLoad,
+  synchronized void updateLoad(ServerLocation location, String memberId, ServerLoad newLoad,
+
-    updateMap(connectionLoadMap, location, newLoad.getConnectionLoad(),
+    updateMap(connectionLoadMap, location, memberId, newLoad.getConnectionLoad(),
-    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
+    Map<ServerLocationAndMemberId, LoadHolder> groupServers = connectionLoadMap.get(group);
-  private synchronized boolean isBalanced(Map<ServerLocation, LoadHolder> groupServers) {
+  private synchronized boolean isBalanced(Map<ServerLocationAndMemberId, LoadHolder> groupServers) {
-  private synchronized boolean isBalanced(Map<ServerLocation, LoadHolder> groupServers,
+  private synchronized boolean isBalanced(Map<ServerLocationAndMemberId, LoadHolder> groupServers,
-    for (Entry<ServerLocation, LoadHolder> loadHolderEntry : groupServers.entrySet()) {
+    for (Entry<ServerLocationAndMemberId, LoadHolder> loadHolderEntry : groupServers.entrySet()) {
-    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
+    Map<ServerLocationAndMemberId, LoadHolder> groupServers = connectionLoadMap.get(group);
-    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
+    Map<ServerLocationAndMemberId, LoadHolder> groupServers = connectionLoadMap.get(group);
-
-    return new ArrayList<>(groupServers.keySet());
+    ArrayList result = new ArrayList<>();
+    for (ServerLocationAndMemberId locationAndMemberId : groupServers.keySet()) {
+      result.add(locationAndMemberId.getServerLocation());
+    }
+    return result;
-   * Pick the least loaded server in the given group if currentServer is the most loaded server. n
+   * Pick the least loaded server in the given group if currentServer is the most loaded server.
-    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
+    Map<ServerLocationAndMemberId, LoadHolder> groupServers = connectionLoadMap.get(group);
-    Map<ServerLocation, LoadHolder> connectionMap = connectionLoadMap.get(null);
+    Map<ServerLocationAndMemberId, LoadHolder> connectionMap = connectionLoadMap.get(null);
-    for (Entry<ServerLocation, LoadHolder> entry : connectionMap
+    for (Entry<ServerLocationAndMemberId, LoadHolder> entry : connectionMap
-      ServerLocation location = entry.getKey();
+      ServerLocation location = entry.getKey().getServerLocation();
-  private void addGroups(Map<String, Map<ServerLocation, LoadHolder>> map, String[] groups,
+  @VisibleForTesting
+  void addGroups(Map<String, Map<ServerLocation, LoadHolder>> map, String[] groups,
-  private void removeFromMap(Map<String, Map<ServerLocation, LoadHolder>> map, String[] groups,
+  @VisibleForTesting
+  void addGroups(Map<String, Map<ServerLocationAndMemberId, LoadHolder>> map,
+      String[] groups,
+      LoadHolder holder, String memberId) {
+    for (String group : groups) {
+      Map<ServerLocationAndMemberId, LoadHolder> groupMap =
+          map.computeIfAbsent(group, k -> new HashMap<>());
+      groupMap.put(new ServerLocationAndMemberId(holder.getLocation(), memberId), holder);
+    }
+    // Special case for GatewayReceiver where we don't put those serverlocation against holder
+    if (!(groups.length > 0 && groups[0].equals(GatewayReceiver.RECEIVER_GROUP))) {
+      Map<ServerLocationAndMemberId, LoadHolder> groupMap =
+          map.computeIfAbsent(null, k -> new HashMap<>());
+      groupMap.put(new ServerLocationAndMemberId(holder.getLocation(), memberId), holder);
+    }
+  }
+
+  @VisibleForTesting
+  void removeFromMap(Map<String, Map<ServerLocation, LoadHolder>> map, String[] groups,
-  private void updateMap(Map map, ServerLocation location, float load, float loadPerConnection) {
+  @VisibleForTesting
+  void removeFromMap(Map<String, Map<ServerLocationAndMemberId, LoadHolder>> map,
+      String[] groups,
+      ServerLocation location, String memberId) {
+    ServerLocationAndMemberId locationAndMemberId =
+        new ServerLocationAndMemberId(location, memberId);
+    for (String group : groups) {
+      Map<ServerLocationAndMemberId, LoadHolder> groupMap = map.get(group);
+      if (groupMap != null) {
+        groupMap.remove(locationAndMemberId);
+        if (groupMap.size() == 0) {
+          map.remove(group);
+        }
+      }
+    }
+    Map groupMap = map.get(null);
+    groupMap.remove(locationAndMemberId);
+  }
+
+  @VisibleForTesting
+  void updateMap(Map map, ServerLocation location, float load, float loadPerConnection) {
+    updateMap(map, location, "", load, loadPerConnection);
+  }
+
+  @VisibleForTesting
+  void updateMap(Map map, ServerLocation location, String memberId, float load,
+      float loadPerConnection) {
-    LoadHolder holder = (LoadHolder) groupMap.get(location);
+    LoadHolder holder;
+    if (memberId.equals("")) {
+      holder = (LoadHolder) groupMap.get(location);
+    } else {
+      ServerLocationAndMemberId locationAndMemberId =
+          new ServerLocationAndMemberId(location, memberId);
+      holder = (LoadHolder) groupMap.get(locationAndMemberId);
+    }
-  private List<LoadHolder> findBestServers(Map<ServerLocation, LoadHolder> groupServers,
+  @VisibleForTesting
+  List<LoadHolder> findBestServers(
+      Map<?, LoadHolder> groupServers,
+    if (count == 0) {
+      return new ArrayList<>();
+    }
+
-    for (Map.Entry<ServerLocation, LoadHolder> loadEntry : groupServers.entrySet()) {
-      ServerLocation location = loadEntry.getKey();
+    for (Map.Entry<?, LoadHolder> loadEntry : groupServers.entrySet()) {
+      ServerLocation location;
+      Object key = loadEntry.getKey();
+      if (key instanceof ServerLocationAndMemberId) {
+        location = ((ServerLocationAndMemberId) key).getServerLocation();
+      } else if (key instanceof ServerLocation) {
+        location = ((ServerLocation) key);
+      } else {
+        throw new InternalGemFireException(
+            "findBestServers method was called with incorrect type parameters.");
+      }
-  private LoadHolder isCurrentServerMostLoaded(ServerLocation currentServer,
-      Map<ServerLocation, LoadHolder> groupServers) {
-    final LoadHolder currentLH = groupServers.get(currentServer);
+  @VisibleForTesting
+  LoadHolder isCurrentServerMostLoaded(ServerLocation currentServer,
+      Map<ServerLocationAndMemberId, LoadHolder> groupServers) {
+
+    // Check if there are keys in the map that contains currentServer.
+    LoadHolder currentLH = null;
+    for (ServerLocationAndMemberId locationAndMemberId : groupServers.keySet()) {
+      if (currentServer.equals(locationAndMemberId.getServerLocation())) {
+        currentLH = groupServers.get(locationAndMemberId);
+        break;
+      }
+    }
-    for (Map.Entry<ServerLocation, LoadHolder> loadEntry : groupServers.entrySet()) {
-      ServerLocation location = loadEntry.getKey();
+    for (Map.Entry<ServerLocationAndMemberId, LoadHolder> loadEntry : groupServers.entrySet()) {
+      ServerLocation location = loadEntry.getKey().getServerLocation();
-  private static class LoadHolder {
+  @VisibleForTesting
+  static class LoadHolder {

INS26 INS26 MOV31 INS40 INS40 INS31 INS31 INS31 UPD74 MOV74 INS44 INS44 MOV83 MOV39 INS42 MOV44 INS44 MOV44 INS8 INS44 INS78 INS78 INS39 UPD42 MOV42 INS44 MOV44 INS44 INS44 INS8 INS78 INS78 INS39 INS42 INS44 INS44 MOV44 INS44 MOV8 INS78 UPD42 INS44 MOV44 INS44 INS44 INS78 INS44 INS78 INS78 INS78 MOV43 INS74 INS43 INS42 INS43 INS42 INS43 INS42 INS21 INS43 INS42 UPD74 UPD74 INS60 INS70 INS42 INS42 INS74 INS42 INS43 INS42 INS43 INS42 INS70 INS25 INS42 INS42 INS74 INS42 INS5 INS42 UPD43 UPD42 INS43 INS42 INS60 INS70 INS60 INS21 INS42 INS43 INS42 INS39 INS42 INS39 INS42 INS42 INS43 INS42 INS25 INS42 INS74 INS25 INS42 UPD74 INS60 INS70 INS42 MOV43 UPD43 MOV43 MOV43 INS42 INS42 INS42 INS32 INS42 UPD74 UPD43 UPD43 UPD74 UPD74 INS43 INS59 INS44 MOV32 INS8 INS42 UPD66 UPD74 UPD74 INS43 INS43 INS74 INS42 INS42 INS44 INS42 INS8 INS38 INS8 INS43 INS43 INS74 INS43 INS85 UPD42 INS42 INS43 INS59 INS44 INS42 INS8 MOV43 INS59 INS32 INS42 INS42 INS32 INS8 INS8 INS43 INS76 INS43 INS27 INS8 INS43 UPD43 INS43 MOV43 INS59 INS44 INS32 INS8 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS33 INS42 UPD43 UPD42 UPD42 UPD74 UPD43 UPD43 INS42 INS42 MOV14 INS43 INS42 INS21 UPD43 UPD43 UPD74 INS42 INS42 INS43 INS43 INS43 INS43 INS42 INS60 INS21 INS36 INS60 INS21 INS42 INS42 INS43 INS43 MOV43 INS42 INS42 INS42 INS14 INS43 INS42 INS60 INS25 INS42 INS32 INS42 INS42 INS42 UPD42 INS42 INS45 UPD42 INS42 INS42 INS42 INS45 INS21 INS60 INS21 INS42 INS42 INS42 INS34 INS41 UPD74 INS60 INS60 INS25 INS42 UPD42 INS42 MOV42 INS33 INS43 INS42 INS42 INS42 INS25 UPD74 MOV60 UPD42 UPD43 UPD42 UPD42 INS42 INS32 UPD42 UPD42 UPD43 INS42 INS42 INS42 INS42 INS74 INS59 INS32 INS27 UPD74 MOV74 INS59 INS32 INS42 INS42 INS43 INS42 INS42 INS42 INS74 INS59 INS27 INS8 INS42 INS42 INS33 INS7 INS43 INS59 INS7 INS14 MOV43 INS76 UPD43 MOV43 INS59 INS43 INS59 INS62 INS8 INS25 INS42 INS32 INS8 MOV43 UPD43 INS43 INS42 UPD42 INS42 INS42 INS32 UPD42 INS32 INS43 INS43 INS43 INS42 INS32 INS42 INS42 INS14 INS42 INS27 INS32 UPD43 INS42 INS32 INS42 INS42 INS14 INS42 INS42 INS43 INS43 MOV43 INS42 INS32 INS42 INS33 INS21 INS25 INS42 MOV11 INS42 INS42 INS14 INS42 INS11 INS74 UPD42 INS42 INS42 INS42 MOV32 INS42 INS43 INS21 INS62 INS8 INS8 INS42 INS42 INS32 INS21 INS10 UPD42 INS42 INS32 INS42 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS86 INS43 INS32 INS42 INS40 INS34 INS2 INS42 INS40 UPD42 INS42 INS42 INS33 INS86 INS43 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS27 INS8 INS43 INS42 INS42 INS43 INS32 INS43 INS42 INS7 INS42 INS43 INS21 INS53 INS42 INS42 INS7 MOV32 INS42 INS59 INS14 INS42 INS42 INS42 INS42 INS34 INS59 INS14 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS32 INS34 INS21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS7 INS14 INS42 INS32 INS42 INS74 INS42 INS74 INS42 INS42 INS32 INS36 INS42 INS42 INS36 INS43 INS45 MOV42 MOV42 UPD42 MOV42 INS43 INS43 INS42 INS42 INS42 INS11 INS11 INS42 INS42 INS42 INS43 INS42 MOV43 INS42 INS42 DEL74 DEL31 DEL83 DEL83 DEL42 DEL42 DEL42 DEL34 DEL32 DEL21 DEL83 DEL33 DEL83 DEL83 DEL83 DEL83 DEL32 DEL59 DEL60 DEL42 DEL59 DEL60 DEL83
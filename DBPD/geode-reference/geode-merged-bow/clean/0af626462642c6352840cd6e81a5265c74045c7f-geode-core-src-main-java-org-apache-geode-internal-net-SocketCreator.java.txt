GEODE-7808: standardize on use of HostAndPort to form client-side connections (#4743)

* Squashed merge of feature/GEODE-7808

removed HostAddress
renamed LocatorAddress to HostAndPort
modified TcpClient methods to take a HostAndPort argument instead of
InetAddress
modified SocketCreator to take a HostAndPort argument instead of
InetAddress

* GEODE-7808 - standardize on use of HostAndPort for connection formation

This continues a previous PR that passed and was approved for merge.
This commit raises up several methods from SocketCreator into the
TcpSocketCreator interface.  This is an intermediate commit.  A
subsequent commit will refactor TcpSocketCreator to separate the client
and server methods for creating server-sockets and client connections to
server-sockets.

* refactored socket-creators to separate concerns

ServerSocketCreator holds methods for non-client comms
ClientSocketCreator holds methods that clients should use for comms
AdvancedSocketCreator holds methods for people who need to get around
the limitations of the other two interfaces

* adding missing interface

* move code out of inner-classes into first-class classes

* renaming interfaces and methods to be less confusing

-import java.net.SocketAddress;
-import java.util.concurrent.ConcurrentHashMap;
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-import javax.net.ssl.SSLServerSocket;
-import org.apache.geode.SystemConnectException;
+import org.apache.geode.annotations.VisibleForTesting;
-import org.apache.geode.distributed.internal.tcpserver.ConnectionWatcher;
+import org.apache.geode.distributed.internal.tcpserver.AdvancedSocketCreatorImpl;
- * Analyze configuration data (gemfire.properties) and configure sockets accordingly for SSL.
+ * SocketCreators are built using a SocketCreatorFactory using Geode distributed-system properties.
+ * They know how to properly configure sockets for TLS (SSL) communications and perform
+ * handshakes. Connection-initiation uses a HostAndPort instance that is similar to an
+ * InetSocketAddress.
- * gemfire.useSSL = (true|false) default false.<br/>
- * gemfire.ssl.debug = (true|false) default false.<br/>
- * gemfire.ssl.needClientAuth = (true|false) default true.<br/>
- * gemfire.ssl.protocols = <i>list of protocols</i><br/>
- * gemfire.ssl.ciphers = <i>list of cipher suites</i><br/>
- * <p>
- * The following may be included to configure the certificates used by the Sun Provider.
- * <p>
- * javax.net.ssl.trustStore = <i>pathname</i><br/>
- * javax.net.ssl.trustStorePassword = <i>password</i><br/>
- * javax.net.ssl.keyStore = <i>pathname</i><br/>
- * javax.net.ssl.keyStorePassword = <i>password</i><br/>
- * <p>
- * Additional properties will be set as System properties to be available as needed by other
- * provider implementations.
+ * SocketCreator also supports a client-socket-factory that is designated with the property
+ * gemfire.clientSocketFactory for use in creating client->server connections.
-  @MakeNotStatic
-  private static final ConcurrentHashMap<InetAddress, String> hostNames = new ConcurrentHashMap<>();
-
-  /**
-   * context for SSL socket factories
-   */
-  /**
-   * A factory used to create client <code>Sockets</code>.
-   */
-  public static final boolean ENABLE_TCP_KEEP_ALIVE = TcpSocketCreatorImpl.ENABLE_TCP_KEEP_ALIVE;
+  public static final boolean ENABLE_TCP_KEEP_ALIVE =
+      AdvancedSocketCreatorImpl.ENABLE_TCP_KEEP_ALIVE;
+
+  // -------------------------------------------------------------------------
+  // Static instance accessors
+  // -------------------------------------------------------------------------
+
+  /**
+   * @deprecated use LocalHostUtil.getLocalHost()
+   */
+  public static InetAddress getLocalHost() throws UnknownHostException {
+    return LocalHostUtil.getLocalHost();
+  }
-  // Static instance accessors
-  // -------------------------------------------------------------------------
-
-  /**
-   * @deprecated use LocalHostUtil.getLocalHost()
-   */
-  public static InetAddress getLocalHost() throws UnknownHostException {
-    return LocalHostUtil.getLocalHost();
-  }
-
-  /**
-   * returns the host name for the given inet address, using a local cache of names to avoid dns
-   * hits and duplicate strings
-   */
-  public static String getHostName(InetAddress addr) {
-    String result = hostNames.get(addr);
-    if (result == null) {
-      result = addr.getHostName();
-      hostNames.put(addr, result);
-    }
-    return result;
-  }
-
-  /**
-   * returns the host name for the given inet address, using a local cache of names to avoid dns
-   * hits and duplicate strings
-   */
-  public static String getCanonicalHostName(InetAddress addr, String hostName) {
-    String result = hostNames.get(addr);
-    if (result == null) {
-      hostNames.put(addr, hostName);
-      return hostName;
-    }
-    return result;
-  }
-
-  /**
-   * Reset the hostNames caches
-   */
-  public static void resetHostNameCache() {
-    hostNames.clear();
-  }
-
-  // -------------------------------------------------------------------------
+  protected void initializeCreators() {
+    serverSocketCreator = new SCServerSocketCreator(this);
+    clientSocketCreator = new SCClientSocketCreator(this);
+    advancedSocketCreator = new SCAdvancedSocketCreator(this);
+  }
+
-        if (this.sslConfig.isEnabled() && sslContext == null) {
+        if (this.sslConfig.isEnabled() && getSslContext() == null) {
+  /**
+   * context for SSL socket factories
+   */
+  @VisibleForTesting
+  /**
+   * A factory used to create client <code>Sockets</code>.
+   */
+  public ClientSocketFactory getClientSocketFactory() {
+    return clientSocketFactory;
+  }
+
+  public SSLConfig getSslConfig() {
+    return sslConfig;
+  }
+
+  /**
+   * ExtendedAliasKeyManager supports use of certificate aliases in distributed system
+   * properties.
+   */
+  /**
+   * Returns true if this SocketCreator is configured to use SSL.
+   */
+  @Override
+  protected boolean useSSL() {
+    return this.sslConfig.isEnabled();
+  }
+
-   * Returns true if this SocketCreator is configured to use SSL.
-   */
-  @Override
-  public boolean useSSL() {
-    return this.sslConfig.isEnabled();
-  }
-
-  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
-      List<GatewayTransportFilter> transportFilters, int socketBufferSize) throws IOException {
-    if (transportFilters.isEmpty()) {
-      return createServerSocket(nport, backlog, bindAddr, socketBufferSize);
-    } else {
-      printConfig();
-      ServerSocket result = new TransportFilterServerSocket(transportFilters);
-      result.setReuseAddress(true);
-      // Set the receive buffer size before binding the socket so
-      // that large buffers will be allocated on accepted sockets (see
-      // java.net.ServerSocket.setReceiverBufferSize javadocs)
-      result.setReceiveBufferSize(socketBufferSize);
-      try {
-        result.bind(new InetSocketAddress(bindAddr, nport), backlog);
-      } catch (BindException e) {
-        BindException throwMe = new BindException(
-            String.format("Failed to create server socket on %s[%s]", bindAddr, nport));
-        throwMe.initCause(e);
-        throw throwMe;
-      }
-      return result;
-    }
-  }
-
-  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
-      int socketBufferSize) throws IOException {
-    return createServerSocket(nport, backlog, bindAddr, socketBufferSize, sslConfig.isEnabled());
-  }
-
-  @Override
-  protected ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
-      int socketBufferSize, boolean sslConnection) throws IOException {
-    printConfig();
-    if (!sslConnection) {
-      return super.createServerSocket(nport, backlog, bindAddr, socketBufferSize, sslConnection);
-    }
-    if (this.sslContext == null) {
-      throw new GemFireConfigException(
-          "SSL not configured correctly, Please look at previous error");
-    }
-    ServerSocketFactory ssf = this.sslContext.getServerSocketFactory();
-    SSLServerSocket serverSocket = (SSLServerSocket) ssf.createServerSocket();
-    serverSocket.setReuseAddress(true);
-    // If necessary, set the receive buffer size before binding the socket so
-    // that large buffers will be allocated on accepted sockets (see
-    // java.net.ServerSocket.setReceiverBufferSize javadocs)
-    if (socketBufferSize != -1) {
-      serverSocket.setReceiveBufferSize(socketBufferSize);
-    }
-    serverSocket.bind(new InetSocketAddress(bindAddr, nport), backlog);
-    finishServerSocket(serverSocket);
-    return serverSocket;
-  }
-
-  /**
-   * Creates or bind server socket to a random port selected from tcp-port-range which is same as
-   * membership-port-range.
-   *
-   *
-   * @return Returns the new server socket.
-   *
-   */
-  public ServerSocket createServerSocketUsingPortRange(InetAddress ba, int backlog,
-      boolean isBindAddress, boolean useNIO, int tcpBufferSize, int[] tcpPortRange)
-      throws IOException {
-    return createServerSocketUsingPortRange(ba, backlog, isBindAddress, useNIO, tcpBufferSize,
-        tcpPortRange, sslConfig.isEnabled());
-  }
-
-  @Override
-  protected RuntimeException problemCreatingSocketInPortRangeException(String s, IOException e) {
-    return new GemFireConfigException(s, e);
-  }
-
-  @Override
-  protected RuntimeException noFreePortException(String reason) {
-    return new SystemConnectException(reason);
-  }
-
-  /**
-   * Return a client socket. This method is used by client/server clients.
-   */
-  public Socket connectForClient(String host, int port, int timeout) throws IOException {
-    return connect(InetAddress.getByName(host), port, timeout, null, true, -1);
-  }
-
-  /**
-   * Return a client socket. This method is used by client/server clients.
-   */
-  public Socket connectForClient(String host, int port, int timeout, int socketBufferSize)
-      throws IOException {
-    return connect(InetAddress.getByName(host), port, timeout, null, true, socketBufferSize);
-  }
-
-  /**
-   * Return a client socket. This method is used by peers.
-   */
-  public Socket connectForServer(InetAddress inetadd, int port) throws IOException {
-    return connect(inetadd, port, 0, null, false, -1);
-  }
-
-  /**
-   * Return a client socket, timing out if unable to connect and timeout > 0 (millis). The parameter
-   * <i>timeout</i> is ignored if SSL is being used, as there is no timeout argument in the ssl
-   * socket factory
-   */
-  public Socket connect(InetAddress inetadd, int port, int timeout,
-      ConnectionWatcher optionalWatcher, boolean clientSide, int socketBufferSize)
-      throws IOException {
-    return connect(inetadd, port, timeout, optionalWatcher, clientSide, socketBufferSize,
-        sslConfig.isEnabled());
-  }
-
-  /**
-   * Return a client socket, timing out if unable to connect and timeout > 0 (millis). The parameter
-   * <i>timeout</i> is ignored if SSL is being used, as there is no timeout argument in the ssl
-   * socket factory
-   */
-  @Override
-  public Socket connect(InetAddress inetadd, int port, int timeout,
-      ConnectionWatcher optionalWatcher, boolean clientSide, int socketBufferSize,
-      boolean sslConnection) throws IOException {
-
-    printConfig();
-
-    if (!sslConnection) {
-      return super.connect(inetadd, port, timeout, optionalWatcher, clientSide, socketBufferSize,
-          sslConnection);
-    }
-
-    // create an SSL connection
-
-    Socket socket;
-    SocketAddress sockaddr = new InetSocketAddress(inetadd, port);
-    if (this.sslContext == null) {
-      throw new GemFireConfigException(
-          "SSL not configured correctly, Please look at previous error");
-    }
-    SocketFactory sf = this.sslContext.getSocketFactory();
-    socket = sf.createSocket();
-
-    // Optionally enable SO_KEEPALIVE in the OS network protocol.
-    socket.setKeepAlive(ENABLE_TCP_KEEP_ALIVE);
-
-    // If necessary, set the receive buffer size before connecting the
-    // socket so that large buffers will be allocated on accepted sockets
-    // (see java.net.Socket.setReceiverBufferSize javadocs for details)
-    if (socketBufferSize != -1) {
-      socket.setReceiveBufferSize(socketBufferSize);
-    }
-
-    try {
-      if (optionalWatcher != null) {
-        optionalWatcher.beforeConnect(socket);
-      }
-      socket.connect(sockaddr, Math.max(timeout, 0));
-      configureClientSSLSocket(socket, timeout);
-      return socket;
-
-    } finally {
-      if (optionalWatcher != null) {
-        optionalWatcher.afterConnect(socket);
-      }
-    }
-  }
-
-  @Override
-  protected Socket createCustomClientSocket(InetAddress inetadd, int port) throws IOException {
-    if (this.clientSocketFactory != null) {
-      return this.clientSocketFactory.createSocket(inetadd, port);
-    }
-    return null;
-  }
-
-  /**
-    return sslContext.createSSLEngine(hostName, port);
+    return getSslContext().createSSLEngine(hostName, port);
-  public void handshakeIfSocketIsSSL(Socket socket, int timeout) throws IOException {
+  void handshakeIfSocketIsSSL(Socket socket, int timeout) throws IOException {
+  /**
+   * Create a server socket with the given transport filters.<br>
+   * Note: This method is outside of the
+   * client/server/advanced interfaces because it references WAN classes that aren't
+   * available to them.
+   */
+  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
+      List<GatewayTransportFilter> transportFilters, int socketBufferSize) throws IOException {
+    if (transportFilters.isEmpty()) {
+      return ((SCServerSocketCreator) forCluster())
+          .createServerSocket(nport, backlog, bindAddr, socketBufferSize, useSSL());
+    } else {
+      printConfig();
+      ServerSocket result = new TransportFilterServerSocket(transportFilters);
+      result.setReuseAddress(true);
+      // Set the receive buffer size before binding the socket so
+      // that large buffers will be allocated on accepted sockets (see
+      // java.net.ServerSocket.setReceiverBufferSize javadocs)
+      result.setReceiveBufferSize(socketBufferSize);
+      try {
+        result.bind(new InetSocketAddress(bindAddr, nport), backlog);
+      } catch (BindException e) {
+        BindException throwMe = new BindException(
+            String.format("Failed to create server socket on %s[%s]", bindAddr, nport));
+        throwMe.initCause(e);
+        throw throwMe;
+      }
+      return result;
+    }
+  }
+
+
-  /**
-   * Configure the SSLServerSocket based on this SocketCreator's settings.
-   */
-  private void finishServerSocket(SSLServerSocket serverSocket) {
-    serverSocket.setUseClientMode(false);
-    if (this.sslConfig.isRequireAuth()) {
-      // serverSocket.setWantClientAuth( true );
-      serverSocket.setNeedClientAuth(true);
-    }
-    serverSocket.setEnableSessionCreation(true);
-
-    // restrict protocols
-    String[] protocols = this.sslConfig.getProtocolsAsStringArray();
-    if (!"any".equalsIgnoreCase(protocols[0])) {
-      serverSocket.setEnabledProtocols(protocols);
-    }
-    // restrict ciphers
-    String[] ciphers = this.sslConfig.getCiphersAsStringArray();
-    if (!"any".equalsIgnoreCase(ciphers[0])) {
-      serverSocket.setEnabledCipherSuites(ciphers);
-    }
-
-    SSLParameterExtension sslParameterExtension = this.sslConfig.getSSLParameterExtension();
-    if (sslParameterExtension != null) {
-      SSLParameters modifiedParams =
-          sslParameterExtension.modifySSLServerSocketParameters(serverSocket.getSSLParameters());
-      serverSocket.setSSLParameters(modifiedParams);
-    }
-
-  }
-  private void configureClientSSLSocket(Socket socket, int timeout) throws IOException {
+  void configureClientSSLSocket(Socket socket, int timeout) throws IOException {
-  private void printConfig() {
+  void printConfig() {
-
-

MOV26 MOV23 MOV23 MOV31 MOV55 MOV31 MOV31 MOV31 MOV31 UPD40 UPD40 MOV43 MOV59 INS43 MOV59 INS39 INS42 MOV29 MOV43 INS42 MOV8 MOV29 UPD83 MOV43 INS42 INS8 UPD83 INS43 INS42 INS29 UPD83 INS29 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 UPD40 INS21 INS21 UPD42 MOV41 UPD42 MOV42 INS41 INS65 INS65 INS7 INS7 INS7 INS42 INS42 INS66 INS66 INS66 INS66 INS66 INS66 INS42 INS14 INS42 INS14 INS42 INS14 INS32 INS43 INS52 INS43 INS52 UPD43 MOV43 INS52 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 INS36 INS32 INS11 INS42 INS43 INS32 INS32 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL78 DEL83 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL83 DEL23 DEL42 DEL78 DEL42 DEL43 DEL42 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL32 DEL21 DEL42 DEL38 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL48 DEL41 DEL8 DEL25 DEL52 DEL42 DEL22 DEL33 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL34 DEL38 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL14 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL42 DEL83 DEL42 DEL31 DEL83 DEL42 DEL43 DEL42 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL14 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL14 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL33 DEL9 DEL34 DEL38 DEL32 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL33 DEL9 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL33 DEL9 DEL34 DEL38 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL32 DEL21 DEL42 DEL38 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL48 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL14 DEL59 DEL60 DEL52 DEL42 DEL22 DEL33 DEL27 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL34 DEL38 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL42 DEL78 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL52 DEL42 DEL22 DEL33 DEL27 DEL8 DEL25 DEL33 DEL41 DEL8 DEL66 DEL65 DEL29 DEL39 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL9 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL43 DEL85 DEL5 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL59 DEL60 DEL45 DEL42 DEL42 DEL34 DEL2 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL85 DEL5 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL59 DEL60 DEL45 DEL42 DEL42 DEL34 DEL2 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL83 DEL83 DEL83
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * An utility class to retrieve colocated regions in a colocation hierarchy in
- * various scenarios
+ * An utility class to retrieve colocated regions in a colocation hierarchy in various scenarios
-  /** Whether to ignore missing parallel queues on restart
-   * if they are not attached to the region. See bug 50120. Mutable
-   * for tests.
+  /**
+   * Whether to ignore missing parallel queues on restart if they are not attached to the region.
+   * See bug 50120. Mutable for tests.
-  public static boolean IGNORE_UNRECOVERED_QUEUE = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "IGNORE_UNRECOVERED_QUEUE");
+  public static boolean IGNORE_UNRECOVERED_QUEUE =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "IGNORE_UNRECOVERED_QUEUE");
-   * An utility method to retrieve colocated region of a given partitioned
-   * region
+   * An utility method to retrieve colocated region of a given partitioned region
-  public static PartitionedRegion getColocatedRegion(
-      final PartitionedRegion partitionedRegion) {
+  public static PartitionedRegion getColocatedRegion(final PartitionedRegion partitionedRegion) {
-    String colocatedWith = partitionedRegion.getPartitionAttributes()
-        .getColocatedWith();
+    String colocatedWith = partitionedRegion.getPartitionAttributes().getColocatedWith();
-    Region prRoot = PartitionedRegionHelper.getPRRoot(partitionedRegion
-        .getCache());
-    PartitionRegionConfig prConf = (PartitionRegionConfig)prRoot
-        .get(getRegionIdentifier(colocatedWith));
+    Region prRoot = PartitionedRegionHelper.getPRRoot(partitionedRegion.getCache());
+    PartitionRegionConfig prConf =
+        (PartitionRegionConfig) prRoot.get(getRegionIdentifier(colocatedWith));
-      throw new IllegalStateException(LocalizedStrings.ColocationHelper_REGION_SPECIFIED_IN_COLOCATEDWITH_DOES_NOT_EXIST.toLocalizedString(
-          new Object[] {colocatedWith, partitionedRegion.getFullPath()}));
+      throw new IllegalStateException(
+          LocalizedStrings.ColocationHelper_REGION_SPECIFIED_IN_COLOCATEDWITH_DOES_NOT_EXIST
+              .toLocalizedString(new Object[] {colocatedWith, partitionedRegion.getFullPath()}));
+      } else {
+        throw new IllegalStateException(
+            LocalizedStrings.ColocationHelper_REGION_SPECIFIED_IN_COLOCATEDWITH_DOES_NOT_EXIST
+                .toLocalizedString(new Object[] {colocatedWith, partitionedRegion.getFullPath()}));
-      else {
-        throw new IllegalStateException(LocalizedStrings.ColocationHelper_REGION_SPECIFIED_IN_COLOCATEDWITH_DOES_NOT_EXIST.toLocalizedString(
-            new Object[] {colocatedWith, partitionedRegion.getFullPath()}));
-      }
-    }
-    catch (PRLocallyDestroyedException e) {
+    } catch (PRLocallyDestroyedException e) {
-        logger.debug("PRLocallyDestroyedException : Region with prId={} is locally destroyed on this node", prID, e);
+        logger.debug(
+            "PRLocallyDestroyedException : Region with prId={} is locally destroyed on this node",
+            prID, e);
-  
+
-   * An utility to make sure that a member contains all of the partitioned
-   * regions that are colocated with a given region on other members.
-   * TODO rebalance - this is rather inefficient, and probably all this junk should
-   * be in the advisor.
+   * An utility to make sure that a member contains all of the partitioned regions that are
+   * colocated with a given region on other members. TODO rebalance - this is rather inefficient,
+   * and probably all this junk should be in the advisor.
-  public static boolean checkMembersColocation(PartitionedRegion partitionedRegion, InternalDistributedMember member) {
+  public static boolean checkMembersColocation(PartitionedRegion partitionedRegion,
+      InternalDistributedMember member) {
-    Region prRoot = PartitionedRegionHelper.getPRRoot(partitionedRegion
-        .getCache());
-    PartitionRegionConfig regionConfig =(PartitionRegionConfig) prRoot.get(partitionedRegion.getRegionIdentifier());
-    //The region was probably concurrently destroyed
-    if(regionConfig == null) {
+    Region prRoot = PartitionedRegionHelper.getPRRoot(partitionedRegion.getCache());
+    PartitionRegionConfig regionConfig =
+        (PartitionRegionConfig) prRoot.get(partitionedRegion.getRegionIdentifier());
+    // The region was probably concurrently destroyed
+    if (regionConfig == null) {
-      PartitionRegionConfig tempToBeColocatedWith = tempcolocatedRegions
-          .remove(0);
+      PartitionRegionConfig tempToBeColocatedWith = tempcolocatedRegions.remove(0);
-        String prName = (String)itr.next();
+        String prName = (String) itr.next();
-          prConf = (PartitionRegionConfig)prRoot.get(prName);
-        }
-        catch (EntryDestroyedException ede) {
+          prConf = (PartitionRegionConfig) prRoot.get(prName);
+        } catch (EntryDestroyedException ede) {
-          if (prConf.getColocatedWith().equals(
-              tempToBeColocatedWith.getFullPath())
-              || ("/" + prConf.getColocatedWith())
-              .equals(tempToBeColocatedWith.getFullPath())) {
+          if (prConf.getColocatedWith().equals(tempToBeColocatedWith.getFullPath())
+              || ("/" + prConf.getColocatedWith()).equals(tempToBeColocatedWith.getFullPath())) {
-          prConf = (PartitionRegionConfig)prRoot
-              .get(getRegionIdentifier(colocatedWithRegionName));
-        }
-        catch (EntryDestroyedException ede) {
+          prConf = (PartitionRegionConfig) prRoot.get(getRegionIdentifier(colocatedWithRegionName));
+        } catch (EntryDestroyedException ede) {
-    
-    //Now check to make sure that all of the colocated regions
-    //Have this member.
-    //We don't need a hostname because the equals method doesn't check it.
-    for(PartitionRegionConfig config: colocatedRegions) {
-      if(config.isColocationComplete() && !config.containsMember(member)) {
+    // Now check to make sure that all of the colocated regions
+    // Have this member.
+
+    // We don't need a hostname because the equals method doesn't check it.
+    for (PartitionRegionConfig config : colocatedRegions) {
+      if (config.isColocationComplete() && !config.containsMember(member)) {
-    //Check to make sure all of the persisted regions that are colocated
-    //with this region have been created.
-    if(hasOfflineColocatedChildRegions(partitionedRegion)) {
+    // Check to make sure all of the persisted regions that are colocated
+    // with this region have been created.
+    if (hasOfflineColocatedChildRegions(partitionedRegion)) {
-    
+
-  
+
-   * Returns true if there are regions that are persisted on this member and
-   * were previously colocated with the given region, but have not yet been created.
+   * Returns true if there are regions that are persisted on this member and were previously
+   * colocated with the given region, but have not yet been created.
-   * @return true if there are any child regions that are persisted on this
-   * member, but have not yet been created.
+   * @return true if there are any child regions that are persisted on this member, but have not yet
+   *         been created.
-      //Look through all of the disk stores for offline colocated child regions
-      for(DiskStoreImpl diskStore: stores) {
-        //Look at all of the partitioned regions.
-        for(Map.Entry<String, PRPersistentConfig> entry : diskStore.getAllPRs().entrySet()) {
+      // Look through all of the disk stores for offline colocated child regions
+      for (DiskStoreImpl diskStore : stores) {
+        // Look at all of the partitioned regions.
+        for (Map.Entry<String, PRPersistentConfig> entry : diskStore.getAllPRs().entrySet()) {
-          //Check to see if they're colocated with this region.
-          if(region.getFullPath().equals(config.getColocatedWith())) {
+          // Check to see if they're colocated with this region.
+          if (region.getFullPath().equals(config.getColocatedWith())) {
-            if(childRegion == null) {
-              //If the child region is offline, return true
-              //unless it is a parallel queue that the user has removed.
-              if(!ignoreUnrecoveredQueue(region, childName)) {
+            if (childRegion == null) {
+              // If the child region is offline, return true
+              // unless it is a parallel queue that the user has removed.
+              if (!ignoreUnrecoveredQueue(region, childName)) {
-              //Otherwise, look for offline children of that region.
-              if(hasOfflineColocatedChildRegions(childRegion)) {
+              // Otherwise, look for offline children of that region.
+              if (hasOfflineColocatedChildRegions(childRegion)) {
-    //Hack for #50120 if the childRegion is an async queue, but we
-    //no longer define the async queue, ignore it.
-    if(!ParallelGatewaySenderQueue.isParallelQueue(childName)) {
+    // Hack for #50120 if the childRegion is an async queue, but we
+    // no longer define the async queue, ignore it.
+    if (!ParallelGatewaySenderQueue.isParallelQueue(childName)) {
-    
+
-    if(!region.getAsyncEventQueueIds().contains(senderId) 
-        && !region.getParallelGatewaySenderIds().contains(senderId)
-        && IGNORE_UNRECOVERED_QUEUE) {
+    if (!region.getAsyncEventQueueIds().contains(senderId)
+        && !region.getParallelGatewaySenderIds().contains(senderId) && IGNORE_UNRECOVERED_QUEUE) {
-    
+
-  /** A utility to check to see if a region has been created on
-   * all of the VMs that host the regions this region is colocated with.
+  /**
+   * A utility to check to see if a region has been created on all of the VMs that host the regions
+   * this region is colocated with.
-    Region prRoot = PartitionedRegionHelper.getPRRoot(region
-        .getCache());
+    Region prRoot = PartitionedRegionHelper.getPRRoot(region.getCache());
-    //Fix for  bug 40075. There is race between this call and the region being concurrently
-    //destroyed.
-    if(config == null) {
-      Assert.assertTrue(region.isDestroyed() || region.isClosed, "Region is not destroyed, but there is no entry in the prRoot for region " + region);
+    // Fix for bug 40075. There is race between this call and the region being concurrently
+    // destroyed.
+    if (config == null) {
+      Assert.assertTrue(region.isDestroyed() || region.isClosed,
+          "Region is not destroyed, but there is no entry in the prRoot for region " + region);
-  
+
-   * An utility method to retrieve all partitioned regions(excluding self) in a
-   * colocation chain<br>
+   * An utility method to retrieve all partitioned regions(excluding self) in a colocation chain<br>
-   * For example, shipmentPR is colocated with orderPR and orderPR is colocated
-   * with customerPR <br>
+   * For example, shipmentPR is colocated with orderPR and orderPR is colocated with customerPR <br>
-   * @return List of all partitioned regions (excluding self) in a colocated
-   *         chain
+   * @return List of all partitioned regions (excluding self) in a colocated chain
-      PartitionedRegion colocatedWithRegion = tempColocatedWith
-          .getColocatedWithRegion();
+      PartitionedRegion colocatedWithRegion = tempColocatedWith.getColocatedWithRegion();
-        colocatedRegions.put(colocatedWithRegion.getFullPath(),
-            colocatedWithRegion);
+        colocatedRegions.put(colocatedWithRegion.getFullPath(), colocatedWithRegion);
-      Map.Entry me = (Entry)itr.next();
+      Map.Entry me = (Entry) itr.next();
-      colocatedLocalRegions.put((String)me.getKey(), context.getLocalDataSet(pr));
+      colocatedLocalRegions.put((String) me.getKey(), context.getLocalDataSet(pr));
-  
+
-    Map<String, PartitionedRegion> colocatedRegions = ColocationHelper
-        .getAllColocationRegions(region);
+    Map<String, PartitionedRegion> colocatedRegions =
+        ColocationHelper.getAllColocationRegions(region);
-          new LocalDataSet((PartitionedRegion)colocatedRegion, bucketSet));
+          new LocalDataSet((PartitionedRegion) colocatedRegion, bucketSet));
-  
-  public static Map<String, LocalDataSet> getColocatedLocalDataSetsForBuckets(PartitionedRegion region, Set<Integer> bucketSet) {
+
+  public static Map<String, LocalDataSet> getColocatedLocalDataSetsForBuckets(
+      PartitionedRegion region, Set<Integer> bucketSet) {
-    Map<String, PartitionedRegion> colocatedRegions = ColocationHelper
-        .getAllColocationRegions(region);
+    Map<String, PartitionedRegion> colocatedRegions =
+        ColocationHelper.getAllColocationRegions(region);
-          new LocalDataSet((PartitionedRegion)colocatedRegion, bucketSet));
+          new LocalDataSet((PartitionedRegion) colocatedRegion, bucketSet));
-   * A utility method to retrieve all child partitioned regions that are
-   * directly colocated to the specified partitioned region.<br>
+   * A utility method to retrieve all child partitioned regions that are directly colocated to the
+   * specified partitioned region.<br>
-   * For example, shipmentPR is colocated with orderPR and orderPR is colocated
-   * with customerPR. <br>
+   * For example, shipmentPR is colocated with orderPR and orderPR is colocated with customerPR.
+   * <br>
-    Region prRoot = PartitionedRegionHelper.getPRRoot(partitionedRegion
-        .getCache());
+    Region prRoot = PartitionedRegionHelper.getPRRoot(partitionedRegion.getCache());
-   // final List allPRNamesList = new ArrayList(prRoot.keySet());
+    // final List allPRNamesList = new ArrayList(prRoot.keySet());
-    while ( itr.hasNext()) {
+    while (itr.hasNext()) {
-        String prName = (String)itr.next();
+        String prName = (String) itr.next();
-          prConf = (PartitionRegionConfig)prRoot.get(prName);
-        }
-        catch (EntryDestroyedException ede) {
+          prConf = (PartitionRegionConfig) prRoot.get(prName);
+        } catch (EntryDestroyedException ede) {
-             if (prRegion.getColocatedWith().equals(
-                partitionedRegion.getFullPath())
-                || ("/" + prRegion.getColocatedWith()).equals(partitionedRegion
-                    .getFullPath())) {
+            if (prRegion.getColocatedWith().equals(partitionedRegion.getFullPath())
+                || ("/" + prRegion.getColocatedWith()).equals(partitionedRegion.getFullPath())) {
-               prRegion.waitOnBucketMetadataInitialization();
-               colocatedChildRegions.add(prRegion);
+              prRegion.waitOnBucketMetadataInitialization();
+              colocatedChildRegions.add(prRegion);
-      }
-      catch (PRLocallyDestroyedException e) {
+      } catch (PRLocallyDestroyedException e) {
-          logger.debug("PRLocallyDestroyedException : Region ={} is locally destroyed on this node", prConf.getPRId(), e);
+          logger.debug("PRLocallyDestroyedException : Region ={} is locally destroyed on this node",
+              prConf.getPRId(), e);
-      }
-      catch (RegionDestroyedException e) {
+      } catch (RegionDestroyedException e) {
-    //Fix for 44484 - Make the list of colocated child regions
-    //is always in the same order on all nodes.
+    // Fix for 44484 - Make the list of colocated child regions
+    // is always in the same order on all nodes.
-        if(o1.isShadowPR() == o2.isShadowPR()) {
+        if (o1.isShadowPR() == o2.isShadowPR()) {
-        if(o1.isShadowPR()) {
+        if (o1.isShadowPR()) {
-  
-  //TODO why do we have this method here?
+
+  // TODO why do we have this method here?
-      functionInstance = FunctionService.getFunction((String)function);
-      Assert.assertTrue(functionInstance != null, "Function " + function
-          + " is not registered on this node ");
-    }
-    else {
-      functionInstance = (Function)function;
+      functionInstance = FunctionService.getFunction((String) function);
+      Assert.assertTrue(functionInstance != null,
+          "Function " + function + " is not registered on this node ");
+    } else {
+      functionInstance = (Function) function;
-    
-    while((parentRegion = getColocatedRegion(prRegion)) != null) {
+
+    while ((parentRegion = getColocatedRegion(prRegion)) != null) {
-    
+
-    }
-    else {
+    } else {
-   * Test to see if there are any persistent child regions
-   * of a partitioned region.
+   * Test to see if there are any persistent child regions of a partitioned region.
-  public static boolean hasPersistentChildRegion(
-      PartitionedRegion region) {
-    for(PartitionedRegion child : getColocatedChildRegions(region)) {
-      if(child.getDataPolicy().withPersistence()) {
+  public static boolean hasPersistentChildRegion(PartitionedRegion region) {
+    for (PartitionedRegion child : getColocatedChildRegions(region)) {
+      if (child.getDataPolicy().withPersistence()) {

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Queue built on top of {@link ParallelGatewaySenderQueue} which allows
- * multiple dispatcher to register and do peek/remove from the 
- * underlying {@link ParallelGatewaySenderQueue} 
+ * Queue built on top of {@link ParallelGatewaySenderQueue} which allows multiple dispatcher to
+ * register and do peek/remove from the underlying {@link ParallelGatewaySenderQueue}
- * There is only one queue, but this class co-ordinates access
- * by multiple threads such that we get zero contention while peeking
- * or removing.
+ * There is only one queue, but this class co-ordinates access by multiple threads such that we get
+ * zero contention while peeking or removing.
- * It implements RegionQueue so that AbstractGatewaySenderEventProcessor
- * can work on it.
- *   
+ * It implements RegionQueue so that AbstractGatewaySenderEventProcessor can work on it.
+ * 
-  
+
-		  ParallelGatewaySenderEventProcessor pro[]) {
+      ParallelGatewaySenderEventProcessor pro[]) {
-  
+
-  
+
-    this.commonQueue.close();
-    // no need to free peekedEvents since they all had makeOffHeap called on them.
-	  throw new UnsupportedOperationException("CPGAQ method(close) is not supported");
-    */
+     * this.commonQueue.close(); // no need to free peekedEvents since they all had makeOffHeap
+     * called on them. throw new
+     * UnsupportedOperationException("CPGAQ method(close) is not supported");
+     */
-	  return this.processors[0].getQueue().getRegion();
+    return this.processors[0].getQueue().getRegion();
-  
+
-  
+
-	return ((ParallelGatewaySenderQueue)(processors[0].getQueue())).getRegions();
+    return ((ParallelGatewaySenderQueue) (processors[0].getQueue())).getRegions();
-	throw new UnsupportedOperationException("This method(take) is not suported");
+    throw new UnsupportedOperationException("This method(take) is not suported");
-	throw new UnsupportedOperationException("This method(take) is not suported");
+    throw new UnsupportedOperationException("This method(take) is not suported");
-	  throw new UnsupportedOperationException("This method(remove) is not suported");      
+    throw new UnsupportedOperationException("This method(remove) is not suported");
-	  throw new UnsupportedOperationException("This method(peek) is not suported");
+    throw new UnsupportedOperationException("This method(peek) is not suported");
-	  throw new UnsupportedOperationException("This method(peek) is not suported");
+    throw new UnsupportedOperationException("This method(peek) is not suported");
-  public List peek(int batchSize, int timeToWait) throws InterruptedException,
-      CacheException {
-    throw new UnsupportedOperationException("This method(peek) is not suported");  
+  public List peek(int batchSize, int timeToWait) throws InterruptedException, CacheException {
+    throw new UnsupportedOperationException("This method(peek) is not suported");
-	//is that fine??
-	return this.processors[0].getQueue().size();
+    // is that fine??
+    return this.processors[0].getQueue().size();
-  
+
-	return ((ParallelGatewaySenderQueue)(processors[0].getQueue())).localSize();
+    return ((ParallelGatewaySenderQueue) (processors[0].getQueue())).localSize();
-	  this.processors[0].getQueue().addCacheListener(listener);    
+    this.processors[0].getQueue().addCacheListener(listener);
-    this.processors[0].removeCacheListener();    
+    this.processors[0].removeCacheListener();
-	throw new UnsupportedOperationException("This method(remove) is not suported");
+    throw new UnsupportedOperationException("This method(remove) is not suported");
-/*  public void resetLastPeeked(){
-    this.resetLastPeeked = true;
-  }*/  
-  
+  /*
+   * public void resetLastPeeked(){ this.resetLastPeeked = true; }
+   */
+
-	long size = 0;
-	for(int i=0; i< processors.length; i++)
-	  size += ((ParallelGatewaySenderQueue)this.processors[i].getQueue()).estimateMemoryFootprint(sizer);
-	return size;
+    long size = 0;
+    for (int i = 0; i < processors.length; i++)
+      size += ((ParallelGatewaySenderQueue) this.processors[i].getQueue())
+          .estimateMemoryFootprint(sizer);
+    return size;
-  /*@Override
-  public void release() {
-	for(int i =0; i< processors.length; i++){
-	  processors[i].getQueue().release();
-	}
-  }*/
-  
+  /*
+   * @Override public void release() { for(int i =0; i< processors.length; i++){
+   * processors[i].getQueue().release(); } }
+   */
+
-  	for(int i =0; i< processors.length; i++){
-   	 processors[i].removeShadowPR(prRegionName);
+    for (int i = 0; i < processors.length; i++) {
+      processors[i].removeShadowPR(prRegionName);
-  
+
-    // This is done so that any events received while the shadow PR is added are queued in the tmpQueuedEvents
+    // This is done so that any events received while the shadow PR is added are queued in the
+    // tmpQueuedEvents
-  
+
-  	int index = bucketId % this.processors.length;
-  	return processors[index];
+    int index = bucketId % this.processors.length;
+    return processors[index];
-   return getPGSProcessor(bucketId).getBucketTmpQueue(bucketId);
+    return getPGSProcessor(bucketId).getBucketTmpQueue(bucketId);
-  
+
-   getPGSProcessor( bucketId).notifyEventProcessorIfRequired(bucketId);
+    getPGSProcessor(bucketId).notifyEventProcessorIfRequired(bucketId);
-  
+
-  	getPGSProcessor(bucketId).clear(pr, bucketId);
+    getPGSProcessor(bucketId).clear(pr, bucketId);
-  
+
-	for(int i=0; i< processors.length; i++)
-	  ((ParallelGatewaySenderQueue)this.processors[i].getQueue()).cleanUp();
+    for (int i = 0; i < processors.length; i++)
+      ((ParallelGatewaySenderQueue) this.processors[i].getQueue()).cleanUp();
-  
-  public void conflateEvent(Conflatable conflatableObject, int bucketId,
-      Long tailKey) {
-  	getPGSProcessor(bucketId).conflateEvent(conflatableObject, bucketId, tailKey);
+
+  public void conflateEvent(Conflatable conflatableObject, int bucketId, Long tailKey) {
+    getPGSProcessor(bucketId).conflateEvent(conflatableObject, bucketId, tailKey);
-  
+
-	for(int i =0; i< processors.length; i++){
-  	 processors[i].addShadowPartitionedRegionForUserRR(userRegion);;
-   }
+    for (int i = 0; i < processors.length; i++) {
+      processors[i].addShadowPartitionedRegionForUserRR(userRegion);;
+    }
-  
+
-	return ((ParallelGatewaySenderQueue)(processors[0].getQueue())).getNumEntriesInVMTestOnly();
+    return ((ParallelGatewaySenderQueue) (processors[0].getQueue())).getNumEntriesInVMTestOnly();
-	 
+
-	return ((ParallelGatewaySenderQueue)(processors[0].getQueue())).getNumEntriesOverflowOnDiskTestOnly();
+    return ((ParallelGatewaySenderQueue) (processors[0].getQueue()))
+        .getNumEntriesOverflowOnDiskTestOnly();

UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66
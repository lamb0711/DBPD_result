Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
-  public RemoteFetchKeysMessage() {
-  }
-  private RemoteFetchKeysMessage(InternalDistributedMember recipient, String regionPath, ReplyProcessor21 processor) {
+  public RemoteFetchKeysMessage() {}
+
+  private RemoteFetchKeysMessage(InternalDistributedMember recipient, String regionPath,
+      ReplyProcessor21 processor) {
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.RemoteOperationMessage#operateOnRegion(org.apache.geode.distributed.internal.DistributionManager, org.apache.geode.internal.cache.LocalRegion, long)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.internal.cache.RemoteOperationMessage#operateOnRegion(org.apache.geode.
+   * distributed.internal.DistributionManager, org.apache.geode.internal.cache.LocalRegion, long)
-  protected boolean operateOnRegion(DistributionManager dm, LocalRegion r,
-      long startTime) throws RemoteOperationException {
-    if ( ! (r instanceof PartitionedRegion) ) { // prs already wait on initialization
+  protected boolean operateOnRegion(DistributionManager dm, LocalRegion r, long startTime)
+      throws RemoteOperationException {
+    if (!(r instanceof PartitionedRegion)) { // prs already wait on initialization
-        logger.debug("Caught exception while sending keys: {}", e.getMessage(),e);
+        logger.debug("Caught exception while sending keys: {}", e.getMessage(), e);
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-    FetchKeysResponse response = new FetchKeysResponse(currRegion.getSystem(),
-        currRegion, (InternalDistributedMember)target);
-    RemoteFetchKeysMessage msg = new RemoteFetchKeysMessage((InternalDistributedMember)target,
-            currRegion.getFullPath(), response);
+    FetchKeysResponse response = new FetchKeysResponse(currRegion.getSystem(), currRegion,
+        (InternalDistributedMember) target);
+    RemoteFetchKeysMessage msg = new RemoteFetchKeysMessage((InternalDistributedMember) target,
+        currRegion.getFullPath(), response);
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  
+
-    
+
-     * Empty constructor to conform to DataSerializable interface 
+     * Empty constructor to conform to DataSerializable interface
-    public RemoteFetchKeysReplyMessage() {
-    }
-  
-    private RemoteFetchKeysReplyMessage(InternalDistributedMember recipient, int processorId, HeapDataOutputStream chunk,
-                                  int seriesNum, int msgNum, int numSeries, boolean lastInSeries)
-    {
+    public RemoteFetchKeysReplyMessage() {}
+
+    private RemoteFetchKeysReplyMessage(InternalDistributedMember recipient, int processorId,
+        HeapDataOutputStream chunk, int seriesNum, int msgNum, int numSeries,
+        boolean lastInSeries) {
-    /** 
-     * Send an ack 
+    /**
+     * Send an ack
+     * 
-      
+
-        
+
-        boolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,
-          new ObjectIntProcedure() {
-            int msgNum = 0;
-              
-            boolean last = false;
-            /**
-              * @param a byte[] chunk
-              * @param b positive if last chunk
-              * @return true to continue to next chunk
-              */
-            public boolean executeWith(Object a, int b) {
-//              if (this.last)
-//                throw new InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());
-              HeapDataOutputStream chunk = (HeapDataOutputStream)a;
-              this.last = b > 0;
-              try {
-                boolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++, numSeries, this.last);
-                return okay;
+        boolean finished = chunkSet(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES,
+            false, new ObjectIntProcedure() {
+              int msgNum = 0;
+
+              boolean last = false;
+
+              /**
+               * @param a byte[] chunk
+               * @param b positive if last chunk
+               * @return true to continue to next chunk
+               */
+              public boolean executeWith(Object a, int b) {
+                // if (this.last)
+                // throw new
+                // InternalGemFireError(LocalizedStrings.FetchKeysMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());
+                HeapDataOutputStream chunk = (HeapDataOutputStream) a;
+                this.last = b > 0;
+                try {
+                  boolean okay = sendChunk(recipient, processorId, dm, chunk, seriesNum, msgNum++,
+                      numSeries, this.last);
+                  return okay;
+                } catch (CancelException e) {
+                  return false;
+                }
-              catch (CancelException e) {
-                return false;
-              }
-            }
-          });
-  
+            });
+
-          logger.debug("{} pr keys chunking", (finished?"Finished" : "DID NOT complete"));
+          logger.debug("{} pr keys chunking", (finished ? "Finished" : "DID NOT complete"));
-      }
-      catch (IOException io) {
-        throw new ForceReattemptException(LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST.toLocalizedString(), io);
+      } catch (IOException io) {
+        throw new ForceReattemptException(
+            LocalizedStrings.FetchKeysMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCH_KEYS_REQUEST
+                .toLocalizedString(),
+            io);
-      //Assert.assertTrue(!cache is closed, "chunking interrupted but cache is still open");
+      // Assert.assertTrue(!cache is closed, "chunking interrupted but cache is still open");
-    
-    
-    static boolean sendChunk(InternalDistributedMember recipient, int processorId, DM dm, HeapDataOutputStream chunk,
-                                      int seriesNum, int msgNum, int numSeries, boolean lastInSeries) {
-      RemoteFetchKeysReplyMessage reply = new RemoteFetchKeysReplyMessage(recipient, processorId, chunk, seriesNum,
-                                      msgNum, numSeries, lastInSeries);
+
+
+    static boolean sendChunk(InternalDistributedMember recipient, int processorId, DM dm,
+        HeapDataOutputStream chunk, int seriesNum, int msgNum, int numSeries,
+        boolean lastInSeries) {
+      RemoteFetchKeysReplyMessage reply = new RemoteFetchKeysReplyMessage(recipient, processorId,
+          chunk, seriesNum, msgNum, numSeries, lastInSeries);
-    
+
-     * Serialize the given set's elments into byte[] chunks, calling proc for each
-     * one. proc args: the byte[] chunk and an int indicating whether it
-     * is the last chunk (positive means last chunk, zero othewise).
-     * The return value of proc indicates whether to continue to the next
+     * Serialize the given set's elments into byte[] chunks, calling proc for each one. proc args:
+     * the byte[] chunk and an int indicating whether it is the last chunk (positive means last
+     * chunk, zero othewise). The return value of proc indicates whether to continue to the next
-    static boolean chunkSet(InternalDistributedMember recipient, Set set, int CHUNK_SIZE_IN_BYTES, boolean includeValues,
-                      ObjectIntProcedure proc)
-    throws IOException
-    {
+    static boolean chunkSet(InternalDistributedMember recipient, Set set, int CHUNK_SIZE_IN_BYTES,
+        boolean includeValues, ObjectIntProcedure proc) throws IOException {
-          InitialImageOperation.CHUNK_SIZE_IN_BYTES+2048, recipient.getVersionObject());
+          InitialImageOperation.CHUNK_SIZE_IN_BYTES + 2048, recipient.getVersionObject());
-        while ((mos.size()+avgItemSize) < InitialImageOperation.CHUNK_SIZE_IN_BYTES && it.hasNext()) {
+        while ((mos.size() + avgItemSize) < InitialImageOperation.CHUNK_SIZE_IN_BYTES
+            && it.hasNext()) {
-        DataSerializer.writeObject((Object)null, mos);
+        DataSerializer.writeObject((Object) null, mos);
-     * Processes this message.  This method is invoked by the receiver
-     * of the message.
+     * Processes this message. This method is invoked by the receiver of the message.
+     * 
-      FetchKeysResponse processor = (FetchKeysResponse)p;
-  
+      FetchKeysResponse processor = (FetchKeysResponse) p;
+
-      dm.getStats().incReplyMessageTime(DistributionStats.getStatTime()
-          - startTime);
+      dm.getStats().incReplyMessageTime(DistributionStats.getStatTime() - startTime);
-    
+
-  
+
-    public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-  
+
-      sb.append("RemoteFetchKeysReplyMessage ")
-        .append("processorid=").append(this.processorId);
-      if (getSender() != null) { 
+      sb.append("RemoteFetchKeysReplyMessage ").append("processorid=").append(this.processorId);
+      if (getSender() != null) {
-      sb.append(",seriesNum=").append(seriesNum)
-        .append(",msgNum=").append(msgNum)
-        .append(",numSeries=").append(numSeries)
-        .append(",lastInSeries=").append(lastInSeries);
+      sb.append(",seriesNum=").append(seriesNum).append(",msgNum=").append(msgNum)
+          .append(",numSeries=").append(numSeries).append(",lastInSeries=").append(lastInSeries);
-      }
-      else if (chunk != null) {
+      } else if (chunk != null) {
-  
-  
+
+
-    
+
-    
+
-    
-    
-    public FetchKeysResponse(InternalDistributedSystem system,
-        LocalRegion region, InternalDistributedMember member) {
+
+
+    public FetchKeysResponse(InternalDistributedSystem system, LocalRegion region,
+        InternalDistributedMember member) {
-          RemoteFetchKeysReplyMessage fkrm = (RemoteFetchKeysReplyMessage)msg;
+          RemoteFetchKeysReplyMessage fkrm = (RemoteFetchKeysReplyMessage) msg;
-            doneProcessing = processChunk((RemoteFetchKeysReplyMessage)msg);
+            doneProcessing = processChunk((RemoteFetchKeysReplyMessage) msg);
-    
+
-      // this processing algorighm won't work well if there are multiple recipients.  currently the
-      // retry logic for failed recipients is in PartitionedRegion.  If we parallelize the sending
+      // this processing algorighm won't work well if there are multiple recipients. currently the
+      // retry logic for failed recipients is in PartitionedRegion. If we parallelize the sending
-        
+
-            synchronized(returnValue) {
+            synchronized (returnValue) {
-          }
-          else {
+          } else {
-        synchronized(this.endLock) {
+        synchronized (this.endLock) {
-          if (((msg.seriesNum+1) == msg.numSeries)  &&  msg.lastInSeries) {
+          if (((msg.seriesNum + 1) == msg.numSeries) && msg.lastInSeries) {
-          if (lastChunkReceived  &&  (chunksExpected == chunksProcessed)) {
+          if (lastChunkReceived && (chunksExpected == chunksProcessed)) {
-            logger.trace(LogMarker.DM, "{} chunksProcessed={},lastChunkReceived={},chunksExpected={},done={}",
-                this, chunksProcessed, lastChunkReceived, chunksExpected, doneProcessing);
+            logger.trace(LogMarker.DM,
+                "{} chunksProcessed={},lastChunkReceived={},chunksExpected={},done={}", this,
+                chunksProcessed, lastChunkReceived, chunksExpected, doneProcessing);
-      }
-      catch (Exception e) {
-        processException(new ReplyException(LocalizedStrings.FetchKeysMessage_ERROR_DESERIALIZING_KEYS.toLocalizedString(), e));
+      } catch (Exception e) {
+        processException(new ReplyException(
+            LocalizedStrings.FetchKeysMessage_ERROR_DESERIALIZING_KEYS.toLocalizedString(), e));
-    
+
-          logger.debug("RemoteFetchKeysResponse got remote CacheClosedException; forcing reattempt. {}", t.getMessage(), t);
+          logger.debug(
+              "RemoteFetchKeysResponse got remote CacheClosedException; forcing reattempt. {}",
+              t.getMessage(), t);
-          logger.debug("RemoteFetchKeysResponse got remote ForceReattemptException; rethrowing. {}", e.getMessage(), e);
+          logger.debug("RemoteFetchKeysResponse got remote ForceReattemptException; rethrowing. {}",
+              e.getMessage(), e);

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66
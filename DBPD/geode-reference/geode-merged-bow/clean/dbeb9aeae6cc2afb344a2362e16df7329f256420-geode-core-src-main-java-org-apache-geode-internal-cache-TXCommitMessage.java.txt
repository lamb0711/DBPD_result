Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-/** TXCommitMessage is the message that contains all the information
- * that needs to be distributed, on commit, to other cache members.
+/**
+ * TXCommitMessage is the message that contains all the information that needs to be distributed, on
+ * commit, to other cache members.
-public class TXCommitMessage extends PooledDistributionMessage implements MembershipListener, MessageWithReply
-{
+public class TXCommitMessage extends PooledDistributionMessage
+    implements MembershipListener, MessageWithReply {
-  
+
-  
+
-  private transient HashMap<InternalDistributedMember, RegionCommitList> msgMap = null; // Maps receiver Serializables to RegionCommitList instances
+  private transient HashMap<InternalDistributedMember, RegionCommitList> msgMap = null; // Maps
+                                                                                        // receiver
+                                                                                        // Serializables
+                                                                                        // to
+                                                                                        // RegionCommitList
+                                                                                        // instances
-   * List of operations to do when processing this tx.
-   * Valid on farside only.
+   * List of operations to do when processing this tx. Valid on farside only.
-  
+
-  
+
-  
+
-   * Version of the client that this TXCommitMessage is being sent to.
-   * Used for backwards compatibility
+   * Version of the client that this TXCommitMessage is being sent to. Used for backwards
+   * compatibility
-  
+
-   * A token to be put in TXManagerImpl#failoverMap to represent a
-   * CommitConflictException while committing a transaction
+   * A token to be put in TXManagerImpl#failoverMap to represent a CommitConflictException while
+   * committing a transaction
-   * A token to be put in TXManagerImpl#failoverMap to represent an
-   * exception while committing a transaction
+   * A token to be put in TXManagerImpl#failoverMap to represent an exception while committing a
+   * transaction
-  /**
-   * this is set if this message should deserialize the WAN shadowKey
-   * sent by the sender. Sender will not send shadowKeys when there is
-   * a mix of 7.0 and 7.0.1 members
+   * /** this is set if this message should deserialize the WAN shadowKey sent by the sender. Sender
+   * will not send shadowKeys when there is a mix of 7.0 and 7.0.1 members
-  private transient boolean shouldReadShadowKey;
-  /**
-   * this is set if the sender has decided to send WAN shadowKey
-   * for 7.0.1 members
+   * private transient boolean shouldReadShadowKey; /** this is set if the sender has decided to
+   * send WAN shadowKey for 7.0.1 members
-  private transient boolean shouldWriteShadowKey;
-  */
+   * private transient boolean shouldWriteShadowKey;
+   */
-  public TXCommitMessage(TXId txIdent, DM dm, TXState txState)
-  {
+  public TXCommitMessage(TXId txIdent, DM dm, TXState txState) {
+
-  
+
+   * 
-    return new EventID(this.farsideBaseMembershipId,
-                       this.farsideBaseThreadId,
-                       this.farsideBaseSequenceId + eventOffset);
+    return new EventID(this.farsideBaseMembershipId, this.farsideBaseThreadId,
+        this.farsideBaseSequenceId + eventOffset);
-   * Return the TXCommitMessage we have already received that is
-   * associated with id. Note because of bug 37657 we may need to wait
-   * for it to show up.
+   * Return the TXCommitMessage we have already received that is associated with id. Note because of
+   * bug 37657 we may need to wait for it to show up.
-  
+
+
-      //Get the persistent ids for the current region and save them
-      Map<InternalDistributedMember, PersistentMemberID> persistentIds = getPersistentIds(this.currentRegion.r);
+      // Get the persistent ids for the current region and save them
+      Map<InternalDistributedMember, PersistentMemberID> persistentIds =
+          getPersistentIds(this.currentRegion.r);
-      
+
-          
+
-          } else if (rcl.get(rcl.size()-1) != this.currentRegion) {
+          } else if (rcl.get(rcl.size() - 1) != this.currentRegion) {
-        Iterator<Map.Entry<InternalDistributedMember, RegionCommitList>> it = this.msgMap.entrySet().iterator();
+        Iterator<Map.Entry<InternalDistributedMember, RegionCommitList>> it =
+            this.msgMap.entrySet().iterator();
-  
-  
-  
+
+
+
-    if(r instanceof DistributedRegion) {
+    if (r instanceof DistributedRegion) {
-  
+
-        if(this.regions==null) {
+        if (this.regions == null) {
-  
-  
+
+
-  private transient boolean disableListeners  = false;
+  private transient boolean disableListeners = false;
-  
+
+
-    for (Iterator it=viewVersions.entrySet().iterator(); it.hasNext(); ) {
-      Map.Entry e = (Map.Entry)it.next();
-      DistributedRegion dr = (DistributedRegion)e.getKey();
-      Long viewVersion = (Long)e.getValue();
+    for (Iterator it = viewVersions.entrySet().iterator(); it.hasNext();) {
+      Map.Entry e = (Map.Entry) it.next();
+      DistributedRegion dr = (DistributedRegion) e.getKey();
+      Long viewVersion = (Long) e.getValue();
-      }
-      catch (RuntimeException ex) {
+      } catch (RuntimeException ex) {
-  
+
-  void addOp(LocalRegion r,Object key, TXEntryState entry,Set otherRecipients) {
+
+  void addOp(LocalRegion r, Object key, TXEntryState entry, Set otherRecipients) {
+
-    Assert.assertTrue(this.txState!=null, "Send must have transaction state.");
-    this.lockId = (TXLockIdImpl)lockId;
+    Assert.assertTrue(this.txState != null, "Send must have transaction state.");
+    this.lockId = (TXLockIdImpl) lockId;
-    IdentityHashMap distMap = new IdentityHashMap(); // Map of RegionCommitList keys to Sets of receivers
+    IdentityHashMap distMap = new IdentityHashMap(); // Map of RegionCommitList keys to Sets of
+                                                     // receivers
-        Map.Entry me = (Map.Entry)it.next();
-        RegionCommitList rcl = (RegionCommitList)me.getValue();
+        Map.Entry me = (Map.Entry) it.next();
+        RegionCommitList rcl = (RegionCommitList) me.getValue();
-        HashSet receivers = (HashSet)distMap.get(rcl);
+        HashSet receivers = (HashSet) distMap.get(rcl);
-      while(rI.hasNext()) {
+      while (rI.hasNext()) {
-        
-        if (! recips.containsAll(newRegionMemberView)) {
+
+        if (!recips.containsAll(newRegionMemberView)) {
-              LocalizedStrings.TXCommitMessage_NEW_MEMBERS_FOR_REGION_0_ORIG_LIST_1_NEW_LIST_2,  
+              LocalizedStrings.TXCommitMessage_NEW_MEMBERS_FOR_REGION_0_ORIG_LIST_1_NEW_LIST_2,
-          
+
-          Map.Entry me = (Map.Entry)it.next();
-          RegionCommitList rcl = (RegionCommitList)me.getKey();
-          HashSet recipients = (HashSet)me.getValue();
+          Map.Entry me = (Map.Entry) it.next();
+          RegionCommitList rcl = (RegionCommitList) me.getKey();
+          HashSet recipients = (HashSet) me.getValue();
-              while(indivRecip.hasNext()) {
+              while (indivRecip.hasNext()) {
-      final CommitProcessMessage cpMsg; 
+      final CommitProcessMessage cpMsg;
-        while(indivRecip.hasNext()) {
+        while (indivRecip.hasNext()) {
-  
+
-  /** 
-   * Checks reliable regions and throws CommitDistributionException if any
-   * required roles may not have received the commit message.
+  /**
+   * Checks reliable regions and throws CommitDistributionException if any required roles may not
+   * have received the commit message.
-   * @throws CommitDistributionException if any required roles may not have
-   * received the commit message
+   * @throws CommitDistributionException if any required roles may not have received the commit
+   *         message
-    
+
-      
+
-        RegionCommit rc = (RegionCommit) rclIter.next(); 
+        RegionCommit rc = (RegionCommit) rclIter.next();
-        
+
-        
+
-    
-    Set cacheClosedMembers = (processor == null) ? Collections.EMPTY_SET : 
-      processor.getCacheClosedMembers();
-    Set departedMembers = (processor == null) ? Collections.EMPTY_SET : 
-      processor.getDepartedMembers();
+
+    Set cacheClosedMembers =
+        (processor == null) ? Collections.EMPTY_SET : processor.getCacheClosedMembers();
+    Set departedMembers =
+        (processor == null) ? Collections.EMPTY_SET : processor.getDepartedMembers();
-      
+
-      
+
-      Set regionDestroyedMembers = (processor == null) ? Collections.EMPTY_SET :
-        processor.getRegionDestroyedMembers(rc.r.getFullPath());
-      
+      Set regionDestroyedMembers = (processor == null) ? Collections.EMPTY_SET
+          : processor.getRegionDestroyedMembers(rc.r.getFullPath());
+
-      
+
-//            public Set getSuccessfulRecipients(ReliableReplyProcessor21 processor) {
-//              return successfulRecipients;
-//            }
-            public int getOperationCount() {
-              return rc.getOperationCount();
-            }
-            public List getOperations() {
-              return rc.getOperations();
-            }
-          };
+          // public Set getSuccessfulRecipients(ReliableReplyProcessor21 processor) {
+          // return successfulRecipients;
+          // }
+          public int getOperationCount() {
+            return rc.getOperationCount();
+          }
+
+          public List getOperations() {
+            return rc.getOperations();
+          }
+        };
-      }
-      catch (RegionDistributionException e) {
+      } catch (RegionDistributionException e) {
-      throw new CommitDistributionException(LocalizedStrings.TXCommitMessage_THESE_REGIONS_EXPERIENCED_RELIABILITY_FAILURE_DURING_DISTRIBUTION_OF_THE_OPERATION_0.toLocalizedString(failedRegionNames), regionDistributionExceptions);
+      throw new CommitDistributionException(
+          LocalizedStrings.TXCommitMessage_THESE_REGIONS_EXPERIENCED_RELIABILITY_FAILURE_DURING_DISTRIBUTION_OF_THE_OPERATION_0
+              .toLocalizedString(failedRegionNames),
+          regionDistributionExceptions);
-  
+
-   * Helper method for send 
+   * Helper method for send
-  private final void setRecipientsSendData(Set recipients, 
-                                           ReplyProcessor21 processor, 
-                                           RegionCommitList rcl) {
+  private final void setRecipientsSendData(Set recipients, ReplyProcessor21 processor,
+      RegionCommitList rcl) {
-      synchronized(this) {
+      synchronized (this) {
-        memberDeparted(getSender(), false /*don't care*/);
+        memberDeparted(getSender(), false /* don't care */);
+
-  
+
-    if (this.processingExceptions == Collections.EMPTY_SET ||
-        e instanceof CancelException) {
+    if (this.processingExceptions == Collections.EMPTY_SET || e instanceof CancelException) {
-  
-  
+
+
-	  this.dm = dm;
+    this.dm = dm;
-    synchronized(this) {
+    synchronized (this) {
-    final int oldLevel = LocalRegion.setThreadInitLevelRequirement(LocalRegion.BEFORE_INITIAL_IMAGE); // do this before CacheFactory.getInstance for bug 33471
+    final int oldLevel =
+        LocalRegion.setThreadInitLevelRequirement(LocalRegion.BEFORE_INITIAL_IMAGE); // do this
+                                                                                     // before
+                                                                                     // CacheFactory.getInstance
+                                                                                     // for bug
+                                                                                     // 33471
-      final Cache cache = CacheFactory.getInstance(dm.getSystem());      
-      if(cache==null) {
+      final Cache cache = CacheFactory.getInstance(dm.getSystem());
+      if (cache == null) {
-        // return ... this cache is closed so we can't do anything. 
+        // return ... this cache is closed so we can't do anything.
-      // Pre-process each Region in the tx
-      try {
-        {
-          Iterator it = this.regions.iterator();
-          while (it.hasNext()) {
-            boolean failedBeginProcess = true;
-            RegionCommit rc = (RegionCommit)it.next();
-            try {
-              failedBeginProcess = !rc.beginProcess(dm, this.txIdent, txEvent);
-            } catch (CacheRuntimeException problem) {
-              processCacheRuntimeException(problem);
-            } finally {
-              if (failedBeginProcess) {
-                rc.r = null; // Cause related FarSideEntryOps to skip processing
-                it.remove(); // Skip endProcessing as well
+        // Pre-process each Region in the tx
+        try {
+          {
+            Iterator it = this.regions.iterator();
+            while (it.hasNext()) {
+              boolean failedBeginProcess = true;
+              RegionCommit rc = (RegionCommit) it.next();
+              try {
+                failedBeginProcess = !rc.beginProcess(dm, this.txIdent, txEvent);
+              } catch (CacheRuntimeException problem) {
+                processCacheRuntimeException(problem);
+              } finally {
+                if (failedBeginProcess) {
+                  rc.r = null; // Cause related FarSideEntryOps to skip processing
+                  it.remove(); // Skip endProcessing as well
+                }
-        }
-        basicProcessOps();
-      } finally { // fix for bug 40001
-      // post-process each Region in the tx
-        Iterator it = this.regions.iterator();
-        while (it.hasNext()) {
-          try {
-            RegionCommit rc = (RegionCommit)it.next();
-            rc.endProcess();
-            if(rc.isForceFireEvent(dm)) {
-              forceListener = true;
+          basicProcessOps();
+        } finally { // fix for bug 40001
+          // post-process each Region in the tx
+          Iterator it = this.regions.iterator();
+          while (it.hasNext()) {
+            try {
+              RegionCommit rc = (RegionCommit) it.next();
+              rc.endProcess();
+              if (rc.isForceFireEvent(dm)) {
+                forceListener = true;
+              }
+            } catch (CacheRuntimeException problem) {
+              processCacheRuntimeException(problem);
-          } catch (CacheRuntimeException problem) {
-            processCacheRuntimeException(problem);
-      }
-      /*
-       * We need to make sure that we should fire a TX afterCommit event.
-       */
-      boolean internalEvent = (txEvent != null && txEvent.hasOnlyInternalEvents());
-      if (!disableListeners && !internalEvent
-          && (forceListener || (txEvent!=null && !txEvent.isEmpty()))) {
-        for (int i=0; i < tls.length; i++) {
-          try {
-            tls[i].afterCommit(txEvent);
-          } 
-          catch (VirtualMachineError err) {
-            SystemFailure.initiateFailure(err);
-            // If this ever returns, rethrow the error.  We're poisoned
-            // now, so don't let this thread continue.
-            throw err;
-          }
-          catch (Throwable t) {
-            // Whenever you catch Error or Throwable, you must also
-            // catch VirtualMachineError (see above).  However, there is
-            // _still_ a possibility that you are dealing with a cascading
-            // error condition, so you also need to check to see if the JVM
-            // is still usable:
-            SystemFailure.checkFailure();
-            logger.error(LocalizedMessage.create(LocalizedStrings.TXCommitMessage_EXCEPTION_OCCURRED_IN_TRANSACTIONLISTENER), t);
+        /*
+         * We need to make sure that we should fire a TX afterCommit event.
+         */
+        boolean internalEvent = (txEvent != null && txEvent.hasOnlyInternalEvents());
+        if (!disableListeners && !internalEvent
+            && (forceListener || (txEvent != null && !txEvent.isEmpty()))) {
+          for (int i = 0; i < tls.length; i++) {
+            try {
+              tls[i].afterCommit(txEvent);
+            } catch (VirtualMachineError err) {
+              SystemFailure.initiateFailure(err);
+              // If this ever returns, rethrow the error. We're poisoned
+              // now, so don't let this thread continue.
+              throw err;
+            } catch (Throwable t) {
+              // Whenever you catch Error or Throwable, you must also
+              // catch VirtualMachineError (see above). However, there is
+              // _still_ a possibility that you are dealing with a cascading
+              // error condition, so you also need to check to see if the JVM
+              // is still usable:
+              SystemFailure.checkFailure();
+              logger.error(
+                  LocalizedMessage.create(
+                      LocalizedStrings.TXCommitMessage_EXCEPTION_OCCURRED_IN_TRANSACTIONLISTENER),
+                  t);
+            }
+      } catch (CancelException e) {
+        processCacheRuntimeException(e);
+      } finally {
+        if (txEvent != null) {
+          txEvent.freeOffHeapResources();
+        }
-    } catch(CancelException e) {
-      processCacheRuntimeException(e);
-      if (txEvent != null) {
-        txEvent.freeOffHeapResources();
-      }
-    }
-    }
-    finally {
-      if(isAckRequired()) {
-    	  ack();
+      if (isAckRequired()) {
+        ack();
-  
+
-          RegionCommit.FarSideEntryOp entryOp = (RegionCommit.FarSideEntryOp)it.next();
+          RegionCommit.FarSideEntryOp entryOp = (RegionCommit.FarSideEntryOp) it.next();
-        } catch (Exception e ) {
+        } catch (Exception e) {
-    while(ci.hasNext()) {
+    while (ci.hasNext()) {
-      addProcessingException(problem);      
+      addProcessingException(problem);
-          new Object[] { this, getSender(), problem}));
+          new Object[] {this, getSender(), problem}));
-        replyEx = new CommitReplyException(LocalizedStrings.TXCommitMessage_COMMIT_OPERATION_GENERATED_ONE_OR_MORE_EXCEPTIONS_FROM_0.toLocalizedString(this.getSender()), this.processingExceptions);
+        replyEx = new CommitReplyException(
+            LocalizedStrings.TXCommitMessage_COMMIT_OPERATION_GENERATED_ONE_OR_MORE_EXCEPTIONS_FROM_0
+                .toLocalizedString(this.getSender()),
+            this.processingExceptions);
-    //if (shouldSend701Message()) {
-      //this.shouldWriteShadowKey = true;
-      //return TX_COMMIT_MESSAGE_701;
-      return TX_COMMIT_MESSAGE;
-    /*
-    }
-    this.shouldWriteShadowKey = false;
+    // if (shouldSend701Message()) {
+    // this.shouldWriteShadowKey = true;
+    // return TX_COMMIT_MESSAGE_701;
-    */
+    /*
+     * } this.shouldWriteShadowKey = false; return TX_COMMIT_MESSAGE;
+     */
-  /**
-   * Do not send shadowKey to clients or when there are member(s) older than
-   * 7.0.1.
+   * /** Do not send shadowKey to clients or when there are member(s) older than 7.0.1.
-  private boolean shouldSend701Message() {
-    if (this.clientVersion == null
-        && this.getDM().getMembersWithOlderVersion("7.0.1").isEmpty()) {
-      return true;
-    }
-    return false;
-  }
-
-  public boolean shouldReadShadowKey() {
-    return this.shouldReadShadowKey;
-  }
-
-  public void setShouldReadShadowKey(boolean shouldReadShadowKey) {
-    this.shouldReadShadowKey = shouldReadShadowKey;
-  }
-
-  public boolean shouldWriteShadowKey() {
-    return this.shouldWriteShadowKey;
-  }
-  */
+   * private boolean shouldSend701Message() { if (this.clientVersion == null &&
+   * this.getDM().getMembersWithOlderVersion("7.0.1").isEmpty()) { return true; } return false; }
+   * 
+   * public boolean shouldReadShadowKey() { return this.shouldReadShadowKey; }
+   * 
+   * public void setShouldReadShadowKey(boolean shouldReadShadowKey) { this.shouldReadShadowKey =
+   * shouldReadShadowKey; }
+   * 
+   * public boolean shouldWriteShadowKey() { return this.shouldWriteShadowKey; }
+   */
-    
-    if(isAckRequired()) {
+
+    if (isAckRequired()) {
-      
+
-    
+
-    
-    
+
+
-    
+
-    for (int i=0; i < regionsSize; i++) {
+    for (int i = 0; i < regionsSize; i++) {
-    
+
-   * Return true if a distributed ack message is required. On the client side of a transaction, 
-   * this returns false, while returning true elsewhere.
+   * Return true if a distributed ack message is required. On the client side of a transaction, this
+   * returns false, while returning true elsewhere.
-  
-  
+
+
-    if(!a) {
+    if (!a) {
-  
+
-      if(this.regions!=null) {
+      if (this.regions != null) {
-        for (int i=0; i < this.regions.size(); i++) {
-          RegionCommit rc = (RegionCommit)this.regions.get(i);
+        for (int i = 0; i < this.regions.size(); i++) {
+          RegionCommit rc = (RegionCommit) this.regions.get(i);
-    
-    if(this.txState!=null) {
+
+    if (this.txState != null) {
-    
-    if(this.txState!=null) {
-      DataSerializer.writeBoolean(this.txState.needsLargeModCount(),out);
+
+    if (this.txState != null) {
+      DataSerializer.writeBoolean(this.txState.needsLargeModCount(), out);
-      DataSerializer.writeBoolean(this.needsLargeModCount,out);
+      DataSerializer.writeBoolean(this.needsLargeModCount, out);
-      
-    
+
+
-      if(regionsSize>0) {
-        for (int i=0; i < this.regions.size(); i++) {
-          RegionCommit rc = (RegionCommit)this.regions.get(i);
+      if (regionsSize > 0) {
+        for (int i = 0; i < this.regions.size(); i++) {
+          RegionCommit rc = (RegionCommit) this.regions.get(i);
-    
-    DataSerializer.writeObject(bridgeContext,out);
-    
+
+    DataSerializer.writeObject(bridgeContext, out);
+
-  
+
-    result.append("TXCommitMessage@")
-      .append(System.identityHashCode(this))
-      .append("#")
-      .append(this.sequenceNum)
-      .append(" processorId=")
-      .append(this.processorId)
-      .append(" txId=")
-      .append(this.txIdent);
+    result.append("TXCommitMessage@").append(System.identityHashCode(this)).append("#")
+        .append(this.sequenceNum).append(" processorId=").append(this.processorId).append(" txId=")
+        .append(this.txIdent);
-    if (this.farSiders!=null) {
+    if (this.farSiders != null) {
-      while(fs.hasNext()) {
+      while (fs.hasNext()) {
-        result.append(' ')
-          .append(it.next());
+        result.append(' ').append(it.next());
-   * Combines a set of small TXCommitMessages that belong to one transaction
-   * into a txCommitMessage that represents an entire transaction. At commit
-   * time the txCommitMessage sent to each node can be a subset of the transaction,
-   * this method will combine those subsets into a complete message.
+   * Combines a set of small TXCommitMessages that belong to one transaction into a txCommitMessage
+   * that represents an entire transaction. At commit time the txCommitMessage sent to each node can
+   * be a subset of the transaction, this method will combine those subsets into a complete message.
+   * 
-  
+
-   * Combines the other TXCommitMessage into this message.
-   * Used to compute complete TXCommitMessage from parts.
+   * Combines the other TXCommitMessage into this message. Used to compute complete TXCommitMessage
+   * from parts.
+   * 
-  
-  public final static class RegionCommitList extends ArrayList<RegionCommit>  {
+
+  public final static class RegionCommitList extends ArrayList<RegionCommit> {
-    
+
+
-      RegionCommit rc = (RegionCommit)o;
+      RegionCommit rc = (RegionCommit) o;
+
-     * Creates a new list, if needed, that contains all the elements
-     * of the specified old list except the last one if it is 'rc'.
-     * Also recomputes needsAck field.
+     * Creates a new list, if needed, that contains all the elements of the specified old list
+     * except the last one if it is 'rc'. Also recomputes needsAck field.
-      if (get(size()-1) != rc) {
+      if (get(size() - 1) != rc) {
-      result.remove(result.size()-1);
+      result.remove(result.size() - 1);
-          RegionCommit itrc = (RegionCommit)it.next();
+          RegionCommit itrc = (RegionCommit) it.next();
+
-      result.append('@')
-        .append(System.identityHashCode(this))
-        .append(' ')
-        .append(super.toString());
+      result.append('@').append(System.identityHashCode(this)).append(' ').append(super.toString());
-  
-  public static class RegionCommit  {
+
+  public static class RegionCommit {
-     * The region that this commit represents.
-     * Valid on both nearside and farside.
+     * The region that this commit represents. Valid on both nearside and farside.
-     * The message this region commit is a part of.
-     * Valid on both farside and nearside.
+     * The message this region commit is a part of. Valid on both farside and nearside.
-     * Number of RegionCommitList instances that have this RegionCommit in them
-     * Valid only on nearside.
+     * Number of RegionCommitList instances that have this RegionCommit in them Valid only on
+     * nearside.
-     * Upperbound on the number of operations this region could possibly have
-     * Valid only on nearside.
+     * Upperbound on the number of operations this region could possibly have Valid only on
+     * nearside.
-     * A list of Object; each one is the entry key for a distributed operation
-     * done by this transaction.
-     * The list must be kept in sync with opKeys.
-     * Valid only on nearside.
+     * A list of Object; each one is the entry key for a distributed operation done by this
+     * transaction. The list must be kept in sync with opKeys. Valid only on nearside.
-     * A list of TXEntryState; each one is the entry info for a distributed operation
-     * done by this transaction.
-     * The list must be kept in sync with opKeys.
-     * Valid only on nearside.
+     * A list of TXEntryState; each one is the entry info for a distributed operation done by this
+     * transaction. The list must be kept in sync with opKeys. Valid only on nearside.
-    
+
-     * The persistent ids of the peers for this region.
-     * Used to mark peers as offline if they do not apply the commit
-     * due to a cache close.
+     * The persistent ids of the peers for this region. Used to mark peers as offline if they do not
+     * apply the commit due to a cache close.
-     * Valid on farside after beginProcess.
-     * Used to remember what to do at region cleanup time
+     * Valid on farside after beginProcess. Used to remember what to do at region cleanup time
-     * Valid on farside after beginProcess.
-     * Used to remember what to do at region cleanup time
+     * Valid on farside after beginProcess. Used to remember what to do at region cleanup time
-     * Valid on farside after beginProcess
-     * This is the txEvent that should be used by this RegionCommit
+     * Valid on farside after beginProcess This is the txEvent that should be used by this
+     * RegionCommit
+     * 
-      throws CacheClosedException
-    {
+        throws CacheClosedException {
-          this.msg.addProcessingException(new RegionDestroyedException(LocalizedStrings.TXCommitMessage_REGION_NOT_FOUND.toLocalizedString(), this.regionPath));
+          this.msg.addProcessingException(new RegionDestroyedException(
+              LocalizedStrings.TXCommitMessage_REGION_NOT_FOUND.toLocalizedString(),
+              this.regionPath));
-      }
-      catch (RegionDestroyedException e) {
+      } catch (RegionDestroyedException e) {
-          logger.debug("Received unneeded commit data for region {} because the region was destroyed.", this.regionPath, e);
+          logger.debug(
+              "Received unneeded commit data for region {} because the region was destroyed.",
+              this.regionPath, e);
+
-      if(this.r==null && this.parentRegionPath!=null) {
+      if (this.r == null && this.parentRegionPath != null) {
-     * Called when processing is complete; only needs to be called if beginProcess
-     * returned true.
+     * Called when processing is complete; only needs to be called if beginProcess returned true.
+     * 
-    
-    
+
+
-    protected void txApplyEntryOp(FarSideEntryOp entryOp, List<EntryEventImpl> pendingCallbacks)
-    {
+    protected void txApplyEntryOp(FarSideEntryOp entryOp, List<EntryEventImpl> pendingCallbacks) {
-      boolean callbacksOnly = (this.r.getDataPolicy() == DataPolicy.PARTITION)
-          || isDuplicate;
+      boolean callbacksOnly = (this.r.getDataPolicy() == DataPolicy.PARTITION) || isDuplicate;
-        // No need to release because it is added to pendingCallbacks and they will be released later
-        EntryEventImpl eei = AbstractRegionMap.createCBEvent(this.r, entryOp.op, entryOp.key, entryOp.value, this.msg.txIdent, txEvent, getEventId(entryOp), entryOp.callbackArg,entryOp.filterRoutingInfo,this.msg.bridgeContext, null, entryOp.versionTag, entryOp.tailKey);
-        if(entryOp.filterRoutingInfo!=null) {
-          eei.setLocalFilterInfo(entryOp.filterRoutingInfo.getFilterInfo(this.r.getCache().getMyId()));
+        // No need to release because it is added to pendingCallbacks and they will be released
+        // later
+        EntryEventImpl eei = AbstractRegionMap.createCBEvent(this.r, entryOp.op, entryOp.key,
+            entryOp.value, this.msg.txIdent, txEvent, getEventId(entryOp), entryOp.callbackArg,
+            entryOp.filterRoutingInfo, this.msg.bridgeContext, null, entryOp.versionTag,
+            entryOp.tailKey);
+        if (entryOp.filterRoutingInfo != null) {
+          eei.setLocalFilterInfo(
+              entryOp.filterRoutingInfo.getFilterInfo(this.r.getCache().getMyId()));
-          logger.debug("invoking transactional callbacks for {} key={} needsUnlock={} event={}", entryOp.op, entryOp.key, this.needsUnlock, eei);
+          logger.debug("invoking transactional callbacks for {} key={} needsUnlock={} event={}",
+              entryOp.op, entryOp.key, this.needsUnlock, eei);
-            entryOp.op, entryOp.key, this.needsUnlock, getEventId(entryOp), entryOp.filterRoutingInfo);
+            entryOp.op, entryOp.key, this.needsUnlock, getEventId(entryOp),
+            entryOp.filterRoutingInfo);
-        this.r.txApplyDestroy(entryOp.key,
-                              this.msg.txIdent,
-                              this.txEvent,
-                              this.needsUnlock,
-                              entryOp.op,
-                              getEventId(entryOp),
-                              entryOp.callbackArg,
-                              pendingCallbacks,
-                              entryOp.filterRoutingInfo,
-                              this.msg.bridgeContext,
-                              false /* origin remote */,
-                              null/*txEntryState*/,
-                              entryOp.versionTag,
-                              entryOp.tailKey);
+        this.r.txApplyDestroy(entryOp.key, this.msg.txIdent, this.txEvent, this.needsUnlock,
+            entryOp.op, getEventId(entryOp), entryOp.callbackArg, pendingCallbacks,
+            entryOp.filterRoutingInfo, this.msg.bridgeContext, false /* origin remote */,
+            null/* txEntryState */, entryOp.versionTag, entryOp.tailKey);
-        this.r.txApplyInvalidate(entryOp.key,
-                                 Token.INVALID,
-                                 entryOp.didDestroy,
-                                 this.msg.txIdent,
-                                 this.txEvent,
-                                 false /*localOp*/,
-                                 getEventId(entryOp),
-                                 entryOp.callbackArg,
-                                 pendingCallbacks,
-                                 entryOp.filterRoutingInfo,
-                                 this.msg.bridgeContext,
-                                 null/*txEntryState*/,
-                                 entryOp.versionTag,
-                                 entryOp.tailKey);
+        this.r.txApplyInvalidate(entryOp.key, Token.INVALID, entryOp.didDestroy, this.msg.txIdent,
+            this.txEvent, false /* localOp */, getEventId(entryOp), entryOp.callbackArg,
+            pendingCallbacks, entryOp.filterRoutingInfo, this.msg.bridgeContext,
+            null/* txEntryState */, entryOp.versionTag, entryOp.tailKey);
-        this.r.txApplyPut(entryOp.op,
-                          entryOp.key,
-                          entryOp.value,
-                          entryOp.didDestroy,
-                          this.msg.txIdent,
-                          this.txEvent,
-                          getEventId(entryOp),
-                          entryOp.callbackArg,
-                          pendingCallbacks,
-                          entryOp.filterRoutingInfo,
-                          this.msg.bridgeContext,
-                          null/*txEntryState*/,
-                          entryOp.versionTag,
-                          entryOp.tailKey);
+        this.r.txApplyPut(entryOp.op, entryOp.key, entryOp.value, entryOp.didDestroy,
+            this.msg.txIdent, this.txEvent, getEventId(entryOp), entryOp.callbackArg,
+            pendingCallbacks, entryOp.filterRoutingInfo, this.msg.bridgeContext,
+            null/* txEntryState */, entryOp.versionTag, entryOp.tailKey);
-    protected void txApplyEntryOpAdjunctOnly(FarSideEntryOp entryOp)
-    {
+    protected void txApplyEntryOpAdjunctOnly(FarSideEntryOp entryOp) {
-      boolean callbacksOnly = (this.r.getDataPolicy() == DataPolicy.PARTITION)
-          || isDuplicate;
+      boolean callbacksOnly = (this.r.getDataPolicy() == DataPolicy.PARTITION) || isDuplicate;
-        
-        PartitionedRegion pr = (PartitionedRegion)r;
+
+        PartitionedRegion pr = (PartitionedRegion) r;
-        InternalDistributedMember thisMember = GemFireCacheImpl.getExisting().getDistributionManager().getId();
+        InternalDistributedMember thisMember =
+            GemFireCacheImpl.getExisting().getDistributionManager().getId();
-        
+
-        @Released EntryEventImpl eei = AbstractRegionMap.createCBEvent(this.r, entryOp.op, entryOp.key, entryOp.value, this.msg.txIdent, txEvent, getEventId(entryOp), entryOp.callbackArg,entryOp.filterRoutingInfo,this.msg.bridgeContext, null, entryOp.versionTag, entryOp.tailKey);
+        @Released
+        EntryEventImpl eei = AbstractRegionMap.createCBEvent(this.r, entryOp.op, entryOp.key,
+            entryOp.value, this.msg.txIdent, txEvent, getEventId(entryOp), entryOp.callbackArg,
+            entryOp.filterRoutingInfo, this.msg.bridgeContext, null, entryOp.versionTag,
+            entryOp.tailKey);
-        if(entryOp.filterRoutingInfo!=null) {
-          eei.setLocalFilterInfo(entryOp.filterRoutingInfo.getFilterInfo(this.r.getCache().getMyId()));
-        }
-        if (isDuplicate) {
-          eei.setPossibleDuplicate(true);
-        }
-        if (logger.isDebugEnabled()) {
-          logger.debug("invoking transactional callbacks for {} key={} needsUnlock={} event={}", entryOp.op, entryOp.key, this.needsUnlock, eei);
-        }
-        // we reach this spot because the event is either delivered to this member
-        // as an "adjunct" message or because the bucket was being created when
-        // the message was sent and already reflects the change caused by this event.
-        // In the latter case we need to invoke listeners
-        final boolean skipListeners = !isDuplicate;
-        eei.invokeCallbacks(this.r, skipListeners, true);
+          if (entryOp.filterRoutingInfo != null) {
+            eei.setLocalFilterInfo(
+                entryOp.filterRoutingInfo.getFilterInfo(this.r.getCache().getMyId()));
+          }
+          if (isDuplicate) {
+            eei.setPossibleDuplicate(true);
+          }
+          if (logger.isDebugEnabled()) {
+            logger.debug("invoking transactional callbacks for {} key={} needsUnlock={} event={}",
+                entryOp.op, entryOp.key, this.needsUnlock, eei);
+          }
+          // we reach this spot because the event is either delivered to this member
+          // as an "adjunct" message or because the bucket was being created when
+          // the message was sent and already reflects the change caused by this event.
+          // In the latter case we need to invoke listeners
+          final boolean skipListeners = !isDuplicate;
+          eei.invokeCallbacks(this.r, skipListeners, true);
-    
-    
+
+
+
+     * 
+
+
-    
+
-      if (r instanceof PartitionedRegion
-          || (r != null && r.isUsedForPartitionedRegionBucket())) {
+      if (r instanceof PartitionedRegion || (r != null && r.isUsedForPartitionedRegionBucket())) {
-    
+
-      
+
-        for (int i=0; i < size; i++) {
+        for (int i = 0; i < size; i++) {
-        result.append(" refCount=")
-          .append(this.refCount);
+        result.append(" refCount=").append(this.refCount);
-    
+
+     * 
-      for (int i=0; i < ops.length; i++) {
-        TXEntryState es = (TXEntryState)this.opEntries.get(i);
+      for (int i = 0; i < ops.length; i++) {
+        TXEntryState es = (TXEntryState) this.opEntries.get(i);
-      if(this.r!=null) {
+      if (this.r != null) {
-        if(this.r instanceof BucketRegion) {
-          DataSerializer.writeString(((BucketRegion)this.r).getPartitionedRegion().getFullPath(), out);
+        if (this.r instanceof BucketRegion) {
+          DataSerializer.writeString(((BucketRegion) this.r).getPartitionedRegion().getFullPath(),
+              out);
-          DataSerializer.writeString(null, out);  
+          DataSerializer.writeString(null, out);
-        DataSerializer.writeString(this.parentRegionPath,out);
+        DataSerializer.writeString(this.parentRegionPath, out);
-      
-      if (isEmpty() || this.opKeys.size()==0) {
+
+      if (isEmpty() || this.opKeys.size() == 0) {
-        
+
-        if(this.msg.txState!=null) {
+        if (this.msg.txState != null) {
-        final boolean sendVersionTags = this.msg.clientVersion == null
-            || Version.GFE_70.compareTo(this.msg.clientVersion) <= 0;
+        final boolean sendVersionTags =
+            this.msg.clientVersion == null || Version.GFE_70.compareTo(this.msg.clientVersion) <= 0;
-        for (int i=0; i < size; i++) {
+        for (int i = 0; i < size; i++) {
-          if(this.msg.txState!=null) {
+          if (this.msg.txState != null) {
-            ((TXEntryState)this.opEntries.get(i)).toFarSideData(out, largeModCount, sendVersionTags, this.msg.clientVersion == null);
+            ((TXEntryState) this.opEntries.get(i)).toFarSideData(out, largeModCount,
+                sendVersionTags, this.msg.clientVersion == null);
-            ((FarSideEntryOp)this.opEntries.get(i)).toData(out,largeModCount, sendVersionTags, this.msg.clientVersion == null);
+            ((FarSideEntryOp) this.opEntries.get(i)).toData(out, largeModCount, sendVersionTags,
+                this.msg.clientVersion == null);
-    
-    
+
+
+
+     * 
+
-       * Create a new representation of a tx entry op on the far side.
-       * All init will be done by a call to fromData
+       * Create a new representation of a tx entry op on the far side. All init will be done by a
+       * call to fromData
-      public FarSideEntryOp() {
-      }
+      public FarSideEntryOp() {}
+
-       * Creates and returns a new instance of a tx entry op on the far side.
-       * The "toData" that this should match is {@link TXEntryState#toFarSideData}.
+       * Creates and returns a new instance of a tx entry op on the far side. The "toData" that this
+       * should match is {@link TXEntryState#toFarSideData}.
+       * 
-        throws IOException, ClassNotFoundException
-      {
+          throws IOException, ClassNotFoundException {
-      
-      public void toData(DataOutput out, boolean largeModCount, boolean sendVersionTag, boolean sendShadowKey)
-      throws IOException
-    {
-//        DataSerializer.writeObject(this.key,out);
+
+      public void toData(DataOutput out, boolean largeModCount, boolean sendVersionTag,
+          boolean sendShadowKey) throws IOException {
+        // DataSerializer.writeObject(this.key,out);
-        
+
-        if(largeModCount) {
+        if (largeModCount) {
-        DataSerializer.writeObject(this.callbackArg,out);
-        DataSerializer.writeObject(this.filterRoutingInfo,out);
+        DataSerializer.writeObject(this.callbackArg, out);
+        DataSerializer.writeObject(this.filterRoutingInfo, out);
-        if(!this.op.isDestroy()) {
+        if (!this.op.isDestroy()) {
-          if(!this.op.isInvalidate()) {
+          if (!this.op.isInvalidate()) {
-    }
-      
-      
+      }
+
+
-      
+
-      
+
+
+
-        FarSideEntryOp other = (FarSideEntryOp)o;
+        FarSideEntryOp other = (FarSideEntryOp) o;
+
-        if (o == null || !(o instanceof FarSideEntryOp)) return false;
+        if (o == null || !(o instanceof FarSideEntryOp))
+          return false;
+
-      return this.txIdent; 
+      return this.txIdent;
-  
+
-   * Used to prevent processing of the message if 
-   * we have reported to other FarSiders that 
-   * we did not received the CommitProcessMessage
+   * Used to prevent processing of the message if we have reported to other FarSiders that we did
+   * not received the CommitProcessMessage
-   * Indicate that this message should not be processed
-   * if we receive CommitProcessMessage (late)
+   * Indicate that this message should not be processed if we receive CommitProcessMessage (late)
-    this.dontProcess = true; 
+    this.dontProcess = true;
-  
-  /********************* Region Commit Process Messages  ***************************************/
-  /** 
-   *  The CommitProcessForLockIDMessaage is sent by the Distributed
-   *  ACK TX origin to the recipients (aka FarSiders) to indicate that
-   *  a previously received RegionCommit that contained a lockId should commence
-   *  processing.
+  /********************* Region Commit Process Messages ***************************************/
+
+  /**
+   * The CommitProcessForLockIDMessaage is sent by the Distributed ACK TX origin to the recipients
+   * (aka FarSiders) to indicate that a previously received RegionCommit that contained a lockId
+   * should commence processing.
-  static final public class CommitProcessForLockIdMessage extends CommitProcessMessage  {
+  static final public class CommitProcessForLockIdMessage extends CommitProcessMessage {
-    
+
+
-      Assert.assertTrue(this.lockId != null, "CommitProcessForLockIdMessage must have a non-null lockid!");
+      Assert.assertTrue(this.lockId != null,
+          "CommitProcessForLockIdMessage must have a non-null lockid!");
+
+
-    return COMMIT_PROCESS_FOR_LOCKID_MESSAGE;
+      return COMMIT_PROCESS_FOR_LOCKID_MESSAGE;
+
+
-      Assert.assertTrue(this.lockId != null, "CommitProcessForLockIdMessage must have a non-null lockid!");
+      Assert.assertTrue(this.lockId != null,
+          "CommitProcessForLockIdMessage must have a non-null lockid!");
+
-      result.append("CommitProcessForLockIdMessage@")
-        .append(System.identityHashCode(this))
-        .append(" lockId=")
-        .append(this.lockId);
+      result.append("CommitProcessForLockIdMessage@").append(System.identityHashCode(this))
+          .append(" lockId=").append(this.lockId);
-  /** 
-   *  The CommitProcessForTXIdMessaage is sent by the Distributed ACK
-   *  TX origin to the recipients (aka FarSiders) to indicate that a
-   *  previously received RegionCommit that contained a TXId should
-   *  commence processing.  RegionCommit messages that contain a TXId
-   *  (and no TXLockId) are typically sent if all the TX changes are a
-   *  result of load/netsearch/netload values (thus no lockid)
+  /**
+   * The CommitProcessForTXIdMessaage is sent by the Distributed ACK TX origin to the recipients
+   * (aka FarSiders) to indicate that a previously received RegionCommit that contained a TXId
+   * should commence processing. RegionCommit messages that contain a TXId (and no TXLockId) are
+   * typically sent if all the TX changes are a result of load/netsearch/netload values (thus no
+   * lockid)
-  static final public class CommitProcessForTXIdMessage extends CommitProcessMessage  {
+  static final public class CommitProcessForTXIdMessage extends CommitProcessMessage {
+
-      Assert.assertTrue(this.txId != null, "CommitProcessMessageForTXId must have a non-null txid!");
+      Assert.assertTrue(this.txId != null,
+          "CommitProcessMessageForTXId must have a non-null txid!");
+
-    } 
+    }
+
+
+
-      Assert.assertTrue(this.txId != null, "CommitProcessMessageForTXId must have a non-null txid!");
+      Assert.assertTrue(this.txId != null,
+          "CommitProcessMessageForTXId must have a non-null txid!");
+
-      result.append("CommitProcessForTXIdMessage@")
-        .append(System.identityHashCode(this))
-        .append(" txId=")
-        .append(this.txId);
+      result.append("CommitProcessForTXIdMessage@").append(System.identityHashCode(this))
+          .append(" txId=").append(this.txId);
-  static abstract public class CommitProcessMessage extends PooledDistributionMessage  {
+  static abstract public class CommitProcessMessage extends PooledDistributionMessage {
-      synchronized(mess) {
+      synchronized (mess) {
-    } 
+    }
-  /********************* Commit Process Query Message  ***************************************/
+  /********************* Commit Process Query Message ***************************************/
-  /** 
-   *  The CommitProcessQueryMessage is used to attempt to recover - in
-   *  the Distributed ACK TXs - when the origin of the CommitProcess
-   *  messages departed from the distributed system.  The sender of
-   *  this message is attempting to query other potential fellow
-   *  FarSiders (aka recipients) who may have received the
-   *  CommitProcess message.  
+  /**
+   * The CommitProcessQueryMessage is used to attempt to recover - in the Distributed ACK TXs - when
+   * the origin of the CommitProcess messages departed from the distributed system. The sender of
+   * this message is attempting to query other potential fellow FarSiders (aka recipients) who may
+   * have received the CommitProcess message.
-   *  Since the occurance of this message will be rare (hopefully), it
-   *  was decided to be general about the the tracker key - opting not
-   *  to have specific messages for each type like
-   *  CommitProcessFor<Lock/TX>Id - and take the performance penalty
-   *  of an extra call to DataSerializer
+   * Since the occurance of this message will be rare (hopefully), it was decided to be general
+   * about the the tracker key - opting not to have specific messages for each type like
+   * CommitProcessFor<Lock/TX>Id - and take the performance penalty of an extra call to
+   * DataSerializer
-  static final public class CommitProcessQueryMessage extends PooledDistributionMessage  {
+  static final public class CommitProcessQueryMessage extends PooledDistributionMessage {
-    
+
-      CommitProcessQueryReplyMessage resp = 
-        new CommitProcessQueryReplyMessage(processMsgReceived);
+      CommitProcessQueryReplyMessage resp = new CommitProcessQueryReplyMessage(processMsgReceived);
-    } 
+    }
-      result.append("CommitProcessQueryMessage@")
-        .append(System.identityHashCode(this))
-        .append(" trackerKeyClass=")
-        .append(this.trackerKey.getClass().getName())
-        .append(" trackerKey=")
-        .append(this.trackerKey)
-        .append(" processorId=")
-        .append(this.processorId);
+      result.append("CommitProcessQueryMessage@").append(System.identityHashCode(this))
+          .append(" trackerKeyClass=").append(this.trackerKey.getClass().getName())
+          .append(" trackerKey=").append(this.trackerKey).append(" processorId=")
+          .append(this.processorId);
-  /********************* Commit Process Query Response Message  **********************************/
-  static final public class CommitProcessQueryReplyMessage extends ReplyMessage  {
+  /********************* Commit Process Query Response Message **********************************/
+  static final public class CommitProcessQueryReplyMessage extends ReplyMessage {
+
-    public void fromData(DataInput in)
-    throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
+
-      result.append("CommitProcessQueryReplyMessage@")
-        .append(System.identityHashCode(this))
-        .append(" wasReceived=")
-        .append(this.wasReceived)
-        .append(" processorId=")
-        .append(this.processorId)
-        .append(" from ")
-        .append(this.getSender());
+      result.append("CommitProcessQueryReplyMessage@").append(System.identityHashCode(this))
+          .append(" wasReceived=").append(this.wasReceived).append(" processorId=")
+          .append(this.processorId).append(" from ").append(this.getSender());
-  /********************* Commit Process Query Response Processor  *********************************/
-  static final public class CommitProcessQueryReplyProcessor extends ReplyProcessor21  {
+  /********************* Commit Process Query Response Processor *********************************/
+  static final public class CommitProcessQueryReplyProcessor extends ReplyProcessor21 {
+
-    
+
-      } 
+      }
-  /********************* MembershipListener Implementation  ***************************************/
-  public void memberJoined(InternalDistributedMember id) {
-  }
-  
-  public void memberSuspect(InternalDistributedMember id,
-      InternalDistributedMember whoSuspected, String reason) {
-  }
-  
-  public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
-  }
+  /********************* MembershipListener Implementation ***************************************/
+  public void memberJoined(InternalDistributedMember id) {}
+
+  public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected,
+      String reason) {}
+
+  public void quorumLost(Set<InternalDistributedMember> failures,
+      List<InternalDistributedMember> remaining) {}
-    if ( ! getSender().equals(id)) {
+    if (!getSender().equals(id)) {
-    ThreadGroup group =
-      LoggingThreadGroup.createThreadGroup("TXCommitMessage Threads", logger);
+    ThreadGroup group = LoggingThreadGroup.createThreadGroup("TXCommitMessage Threads", logger);
-          logger.debug("Member departed: Commit data is already being processed for lockid: {}", lockId);
+          logger.debug("Member departed: Commit data is already being processed for lockid: {}",
+              lockId);
-      } 
+      }
-    if (this.farSiders != null && ! this.farSiders.isEmpty()) {
+    if (this.farSiders != null && !this.farSiders.isEmpty()) {
-        logger.debug("Member departed: {} sending query for CommitProcess message to other recipients.", id); 
+        logger.debug(
+            "Member departed: {} sending query for CommitProcess message to other recipients.", id);
-      // Create a new thread, send the CommitProcessQuery, wait for a response and potentially process
+      // Create a new thread, send the CommitProcessQuery, wait for a response and potentially
+      // process
-          // Should I use a thread pool?, Darrel suggests look in DM somewhere or introduce a zero sized thread pool
+        // Should I use a thread pool?, Darrel suggests look in DM somewhere or introduce a zero
+        // sized thread pool
-          public void run() {
-            final TXCommitMessage mess = TXCommitMessage.this;
-            Object trackerKey = mess.getTrackerKey();
-            DistributedMember member = getMemberFromTrackerKey(trackerKey);
-            if (!mess.getSender().equals(member)) {
-              /* Do not send a CommitProcessQueryMessage when the sender of CommitMessage
-               * is not the member in the tracker key. (If this happens we are the redundant
-               * node for PR, and the primary just crashed).
-               */
-              txTracker.removeMessage(mess);
-              return;
-            }
-            CommitProcessQueryReplyProcessor replProc = 
+        public void run() {
+          final TXCommitMessage mess = TXCommitMessage.this;
+          Object trackerKey = mess.getTrackerKey();
+          DistributedMember member = getMemberFromTrackerKey(trackerKey);
+          if (!mess.getSender().equals(member)) {
+            /*
+             * Do not send a CommitProcessQueryMessage when the sender of CommitMessage is not the
+             * member in the tracker key. (If this happens we are the redundant node for PR, and the
+             * primary just crashed).
+             */
+            txTracker.removeMessage(mess);
+            return;
+          }
+          CommitProcessQueryReplyProcessor replProc =
-            CommitProcessQueryMessage query = new CommitProcessQueryMessage(mess.getTrackerKey(), replProc.getProcessorId());
-            query.setRecipients(mess.farSiders);
-            mess.dm.putOutgoing(query);
-            // Wait for any one positive response or all negative responses.
-            // (while() loop removed for bug 36983 - you can't loop on waitForReplies()
-              TXCommitMessage.this.dm.getCancelCriterion().checkCancelInProgress(null);
-              try {
-                replProc.waitForRepliesUninterruptibly();
-              } catch (ReplyException e) {
-                e.handleAsUnexpected();
-              }
-            if (replProc.receivedACommitProcessMessage()) {
-              if (logger.isDebugEnabled()) {
-                logger.debug("Transaction associated with lockID: {} from orign {} is processing due to a received \"commit process\" message",
-                    mess.lockId, id);
-              }
-              
-              try {
-                // Set processor to zero to avoid the ack to the now departed origin
-                mess.processorId = 0;
-                mess.basicProcess();
-              } finally {
-                txTracker.processed(mess);
-              }
-            } else {
-              if (logger.isDebugEnabled()) {
-                logger.debug("Transaction associated with lockID: {} from origin {} ignored.  No other recipients received \"commit process\" message",
-                    mess.lockId, id);
-              }
-              txTracker.removeMessage(mess);
+          CommitProcessQueryMessage query =
+              new CommitProcessQueryMessage(mess.getTrackerKey(), replProc.getProcessorId());
+          query.setRecipients(mess.farSiders);
+          mess.dm.putOutgoing(query);
+          // Wait for any one positive response or all negative responses.
+          // (while() loop removed for bug 36983 - you can't loop on waitForReplies()
+          TXCommitMessage.this.dm.getCancelCriterion().checkCancelInProgress(null);
+          try {
+            replProc.waitForRepliesUninterruptibly();
+          } catch (ReplyException e) {
+            e.handleAsUnexpected();
+          }
+          if (replProc.receivedACommitProcessMessage()) {
+            if (logger.isDebugEnabled()) {
+              logger.debug(
+                  "Transaction associated with lockID: {} from orign {} is processing due to a received \"commit process\" message",
+                  mess.lockId, id);
+            try {
+              // Set processor to zero to avoid the ack to the now departed origin
+              mess.processorId = 0;
+              mess.basicProcess();
+            } finally {
+              txTracker.processed(mess);
+            }
+          } else {
+            if (logger.isDebugEnabled()) {
+              logger.debug(
+                  "Transaction associated with lockID: {} from origin {} ignored.  No other recipients received \"commit process\" message",
+                  mess.lockId, id);
+            }
+            txTracker.removeMessage(mess);
+        }
+
-            TXId id1 = (TXId)trackerKey;
+            TXId id1 = (TXId) trackerKey;
-            TXLockId id2 = (TXLockId)trackerKey;
+            TXLockId id2 = (TXLockId) trackerKey;
-        };
+      };
-          public void run() {
-            final TXCommitMessage mess = TXCommitMessage.this;
-            try {
-              // Set processor to zero to avoid the ack to the now departed origin
-              mess.processorId = 0;
-              mess.basicProcess();
-            } finally {
-              txTracker.processed(mess);
-            }
+        public void run() {
+          final TXCommitMessage mess = TXCommitMessage.this;
+          try {
+            // Set processor to zero to avoid the ack to the now departed origin
+            mess.processorId = 0;
+            mess.basicProcess();
+          } finally {
+            txTracker.processed(mess);
-        };
+        }
+      };
-   * Intended to be called after TXState.applyChanges when the
-   * potential for a different set of TX members has been determined
-   * and it is safe to ignore any new members because the changes have
-   * been applied to committed state.  This was added as the solution
-   * to bug 32999 and the recovery when the TXLock Lessor (the sending
-   * VM) crashes/departs before or while sending the TXCommitMessage.
+   * Intended to be called after TXState.applyChanges when the potential for a different set of TX
+   * members has been determined and it is safe to ignore any new members because the changes have
+   * been applied to committed state. This was added as the solution to bug 32999 and the recovery
+   * when the TXLock Lessor (the sending VM) crashes/departs before or while sending the
+   * TXCommitMessage.
+   * 
-  
-//  /** Custom subclass that keeps all ReplyExceptions */
-//  private class ReliableCommitReplyProcessor extends ReliableReplyProcessor21 {
-//
-//    /** Set of members that threw CacheClosedExceptions */
-//    private Set cacheExceptions = new HashSet();
-//    /** key=region path, value=Set of members */
-//    private Map regionExceptions = new HashMap();
-//
-//    public ReliableCommitReplyProcessor(DM dm,
-//                                        Set initMembers) {
-//      super(dm, initMembers);
-//    }
-//    protected synchronized void processException(DistributionMessage msg,
-//                                                 ReplyException re) {
-//      // only interested in CommitReplyException
-//      if (re instanceof CommitReplyException) {
-//        CommitReplyException cre = (CommitReplyException) re;
-//        Set exceptions = cre.getExceptions();
-//        for (Iterator iter = exceptions.iterator(); iter.hasNext();) {
-//          Exception ex = (Exception) iter.next();
-//          if (ex instanceof CacheClosedException) {
-//            cacheExceptions.add(msg.getSender());
-//          }
-//          else if (ex instanceof RegionDestroyedException) {
-//            String r = ((RegionDestroyedException)ex).getRegionFullPath();
-//            Set members = (Set) regionExceptions.get(r);
-//            if (members == null) {
-//              members = new HashSet();
-//              regionExceptions.put(r, members);
-//            }
-//            members.add(msg.getSender());
-//          }
-//        }
-//      }
-//      else {
-//        // allow superclass to handle all other exceptions
-//        super.processException(msg, re);
-//      }
-//    }
-//    // these two accessors should be called after wait for replies completes
-//    protected Set getCacheClosedMembers() {
-//      return this.cacheExceptions;
-//    }
-//    protected Set getRegionDestroyedMembers(String regionFullPath) {
-//      Set members = (Set) this.regionExceptions.get(regionFullPath);
-//      if (members == null) {
-//        members = Collections.EMPTY_SET;
-//      }
-//      return members;
-//    }
-//  }
+
+  // /** Custom subclass that keeps all ReplyExceptions */
+  // private class ReliableCommitReplyProcessor extends ReliableReplyProcessor21 {
+  //
+  // /** Set of members that threw CacheClosedExceptions */
+  // private Set cacheExceptions = new HashSet();
+  // /** key=region path, value=Set of members */
+  // private Map regionExceptions = new HashMap();
+  //
+  // public ReliableCommitReplyProcessor(DM dm,
+  // Set initMembers) {
+  // super(dm, initMembers);
+  // }
+  // protected synchronized void processException(DistributionMessage msg,
+  // ReplyException re) {
+  // // only interested in CommitReplyException
+  // if (re instanceof CommitReplyException) {
+  // CommitReplyException cre = (CommitReplyException) re;
+  // Set exceptions = cre.getExceptions();
+  // for (Iterator iter = exceptions.iterator(); iter.hasNext();) {
+  // Exception ex = (Exception) iter.next();
+  // if (ex instanceof CacheClosedException) {
+  // cacheExceptions.add(msg.getSender());
+  // }
+  // else if (ex instanceof RegionDestroyedException) {
+  // String r = ((RegionDestroyedException)ex).getRegionFullPath();
+  // Set members = (Set) regionExceptions.get(r);
+  // if (members == null) {
+  // members = new HashSet();
+  // regionExceptions.put(r, members);
+  // }
+  // members.add(msg.getSender());
+  // }
+  // }
+  // }
+  // else {
+  // // allow superclass to handle all other exceptions
+  // super.processException(msg, re);
+  // }
+  // }
+  // // these two accessors should be called after wait for replies completes
+  // protected Set getCacheClosedMembers() {
+  // return this.cacheExceptions;
+  // }
+  // protected Set getRegionDestroyedMembers(String regionFullPath) {
+  // Set members = (Set) this.regionExceptions.get(regionFullPath);
+  // if (members == null) {
+  // members = Collections.EMPTY_SET;
+  // }
+  // return members;
+  // }
+  // }
-   * Reply processor which collects all CommitReplyExceptions and emits
-   * a detailed failure exception if problems occur
+   * Reply processor which collects all CommitReplyExceptions and emits a detailed failure exception
+   * if problems occur
+   * 
-    
-    public CommitReplyProcessor(DM dm,
-        Set initMembers, HashMap msgMap) {
+
+    public CommitReplyProcessor(DM dm, Set initMembers, HashMap msgMap) {
-      }
-      catch (CommitExceptionCollectingException e) {
+      } catch (CommitExceptionCollectingException e) {
-    protected void processException(DistributionMessage msg,
-        ReplyException ex) {
+    protected void processException(DistributionMessage msg, ReplyException ex) {
-        synchronized(this) {
+        synchronized (this) {
-          CommitExceptionCollectingException cce = (CommitExceptionCollectingException) this.exception;
+          CommitExceptionCollectingException cce =
+              (CommitExceptionCollectingException) this.exception;
-    
+
-        CommitExceptionCollectingException cce = (CommitExceptionCollectingException) this.exception;
+        CommitExceptionCollectingException cce =
+            (CommitExceptionCollectingException) this.exception;
+
-        CommitExceptionCollectingException cce = (CommitExceptionCollectingException) this.exception;
+        CommitExceptionCollectingException cce =
+            (CommitExceptionCollectingException) this.exception;
+   * 
-private static final long serialVersionUID = 589384721273797822L;
+    private static final long serialVersionUID = 589384721273797822L;
-    
+
+
-     * Determine if the commit processing was incomplete, if so throw a detailed
-     * exception indicating the source of the problem
-     * @param msgMap 
+     * Determine if the commit processing was incomplete, if so throw a detailed exception
+     * indicating the source of the problem
+     * 
+     * @param msgMap
-    public void handlePotentialCommitFailure(HashMap<InternalDistributedMember, RegionCommitList> msgMap) {
+    public void handlePotentialCommitFailure(
+        HashMap<InternalDistributedMember, RegionCommitList> msgMap) {
-        StringBuffer errorMessage = new StringBuffer("Incomplete commit of transaction ")
-        .append(id).append(".  Caused by the following exceptions: ");
+        StringBuffer errorMessage = new StringBuffer("Incomplete commit of transaction ").append(id)
+            .append(".  Caused by the following exceptions: ");
-          for (Iterator ei = exceptions.iterator(); ei.hasNext(); )
-          {
+          for (Iterator ei = exceptions.iterator(); ei.hasNext();) {
-      
-      //Mark any persistent members as offline
+
+      // Mark any persistent members as offline
-    
+
-    private void handleRegionDestroyed(HashMap<InternalDistributedMember, RegionCommitList> msgMap) {
-      if(regionExceptions == null || regionExceptions.isEmpty()) {
+    private void handleRegionDestroyed(
+        HashMap<InternalDistributedMember, RegionCommitList> msgMap) {
+      if (regionExceptions == null || regionExceptions.isEmpty()) {
-      
-      for(Map.Entry<InternalDistributedMember, RegionCommitList> memberMap: msgMap.entrySet()) {
+
+      for (Map.Entry<InternalDistributedMember, RegionCommitList> memberMap : msgMap.entrySet()) {
-        for(RegionCommit region : rcl) {
-          Set<InternalDistributedMember> failedMembers = regionExceptions.get(region.r.getFullPath());
-          if(failedMembers != null && failedMembers.contains(member)) {
+        for (RegionCommit region : rcl) {
+          Set<InternalDistributedMember> failedMembers =
+              regionExceptions.get(region.r.getFullPath());
+          if (failedMembers != null && failedMembers.contains(member)) {
-      
+
-      for(InternalDistributedMember member: getCacheClosedMembers()) {
+      for (InternalDistributedMember member : getCacheClosedMembers()) {
-        
-        for(RegionCommit region : rcl) {
+
+        for (RegionCommit region : rcl) {
-      }  
+      }
-    private void markMemberOffline(InternalDistributedMember member,
-        RegionCommit region) {
-      if(region.persistentIds == null) {
+    private void markMemberOffline(InternalDistributedMember member, RegionCommit region) {
+      if (region.persistentIds == null) {
-      
+
-      ///iterate over the list and mark the members offline
-      if(persistentId != null) {
-        //Fix for bug 42142 - In order for recovery to work, 
-        //we must either
+      /// iterate over the list and mark the members offline
+      if (persistentId != null) {
+        // Fix for bug 42142 - In order for recovery to work,
+        // we must either
-        //or
+        // or
-        
-        //if we have started to shutdown, we don't want to mark the peer
-        //as offline, or we will think we have newer data when in fact we don't
+
+        // if we have started to shutdown, we don't want to mark the peer
+        // as offline, or we will think we have newer data when in fact we don't
-        
-        //Otherwise, mark the peer as offline, because it didn't complete
-        //the operation.
-        ((DistributedRegion) region.r).getPersistenceAdvisor().markMemberOffline(member, persistentId);
+
+        // Otherwise, mark the peer as offline, because it didn't complete
+        // the operation.
+        ((DistributedRegion) region.r).getPersistenceAdvisor().markMemberOffline(member,
+            persistentId);
+
+     * 
-        }
-        else if (ex instanceof RegionDestroyedException) {
-          String r = ((RegionDestroyedException)ex).getRegionFullPath();
+        } else if (ex instanceof RegionDestroyedException) {
+          String r = ((RegionDestroyedException) ex).getRegionFullPath();
-    if(regions!=null) {
+    if (regions != null) {
-      while(it.hasNext()) {
-        RegionCommit rc = (RegionCommit)it.next();
+      while (it.hasNext()) {
+        RegionCommit rc = (RegionCommit) it.next();
-    
+
-  
-  
+
+
+   * 
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
Merge branch 'release/1.4.0'

-import org.apache.geode.internal.cache.tier.sockets.ClientProtocolService;
-import org.apache.geode.management.internal.configuration.handlers.ConfigurationRequestHandler;
-import org.apache.geode.management.internal.configuration.messages.ConfigurationRequest;
- * 
+ *
-   * locator state file
-   */
-  private File stateFile;
-
-  /**
-  // TODO: return value of removeLocator is never used
-  private static boolean removeLocator(InternalLocator locator) {
+  private static void removeLocator(InternalLocator locator) {
-      return false;
+      return;
-      if (locator != null && locator.equals(InternalLocator.locator)) {
+      if (locator.equals(InternalLocator.locator)) {
-        return true;
-      return false;
-   * 
+   *
-   * @param stateFile the file that state should be read from / written to for recovery
-  public static InternalLocator createLocator(int port, File logFile, File stateFile,
-      InternalLogWriter logger, InternalLogWriter securityLogger, InetAddress bindAddress,
-      String hostnameForClients, Properties distributedSystemProperties,
-      boolean startDistributedSystem) {
+  public static InternalLocator createLocator(int port, File logFile, InternalLogWriter logger,
+      InternalLogWriter securityLogger, InetAddress bindAddress, String hostnameForClients,
+      Properties distributedSystemProperties, boolean startDistributedSystem) {
-          new InternalLocator(port, logFile, stateFile, logger, securityLogger, bindAddress,
+          new InternalLocator(port, logFile, logger, securityLogger, bindAddress,
-   * 
+   *
-  public static InternalLocator startLocator(int port, File logFile, File stateFile,
-      InternalLogWriter logger, InternalLogWriter securityLogger, InetAddress bindAddress,
-      boolean startDistributedSystem, Properties dsProperties, String hostnameForClients)
-      throws IOException {
+  public static InternalLocator startLocator(int port, File logFile, InternalLogWriter logger,
+      InternalLogWriter securityLogger, InetAddress bindAddress, boolean startDistributedSystem,
+      Properties dsProperties, String hostnameForClients) throws IOException {
-      newLocator = createLocator(port, logFile, stateFile, logger, securityLogger, bindAddress,
+      newLocator = createLocator(port, logFile, logger, securityLogger, bindAddress,
-      // TODO:GEODE-1243: this.server is now a TcpServer and it should store or return its non-zero
-      // port in a variable to use here
-        newLocator.startPeerLocation(startDistributedSystem);
+        newLocator.startPeerLocation();
+
-            // TODO:GEODE-1243: throws Exception if TcpServer still has zero for its locator port
-   * 
+   *
-   * 
+   *
-   * @param stateF the file that state should be read from / written to for recovery
-  private InternalLocator(int port, File logF, File stateF, InternalLogWriter logWriter,
+  private InternalLocator(int port, File logF, InternalLogWriter logWriter,
-    if (stateF == null) {
-      this.stateFile = new File("locator" + port + "view.dat");
-    } else {
-      this.stateFile = stateF;
-    }
-    File productUseFile = new File("locator" + port + "views.log");
-    this.productUseLog = new ProductUseLog(productUseFile);
-  // Reset the file names with the correct port number if startLocatorAndDS was called with port
-  // number 0
-  public void resetInternalLocatorFileNamesWithCorrectPortNumber(int port) {
-    this.stateFile = new File("locator" + port + "view.dat");
-    File productUseFile = new File("locator" + port + "views.log");
-    this.productUseLog = new ProductUseLog(productUseFile);
-  }
-
+    if (myCache == null) {
+      return GemFireCacheImpl.getInstance();
+    }
-   * <p>
-   * TODO: parameter withDS is never used
-   * @param withDS true if a distributed system has been or will be started
-   *
+   * @return returns the port that the locator to which the locator is bound
-  void startPeerLocation(boolean withDS) throws IOException {
+  int startPeerLocation() throws IOException {
-    boolean locatorsAreCoordinators = false;
+    boolean locatorsAreCoordinators;
-    this.locatorImpl = MemberFactory.newLocatorHandler(this.bindAddress, this.stateFile,
-        locatorsProp, locatorsAreCoordinators, networkPartitionDetectionEnabled, this.stats,
-        securityUDPDHAlgo);
+    this.locatorImpl = MemberFactory.newLocatorHandler(this.bindAddress, locatorsProp,
+        locatorsAreCoordinators, networkPartitionDetectionEnabled, this.stats, securityUDPDHAlgo);
+    int boundPort = this.server.getPort();
+    File productUseFile = new File("locator" + boundPort + "views.log");
+    productUseLog = new ProductUseLog(productUseFile);
+
+    return boundPort;
-  public PrimaryHandler getPrimaryHandler() {
-    return this.handler;
-  }
-
-   * 
+   *
-  public static InternalLocator startLocator(int locatorPort, File logFile, File stateFile,
+  public static InternalLocator startLocator(int locatorPort, File logFile,
-    return startLocator(locatorPort, logFile, stateFile, logger, logger1, addr, true, dsProperties,
-        s);
-  }
-
-  class SharedConfigurationRunnable implements Runnable {
-
-    private final InternalLocator locator = InternalLocator.this;
-
-    @Override
-    public void run() {
-      try {
-        if (this.locator.sharedConfig == null) {
-          // locator.sharedConfig will already be created in case of auto-reconnect
-          this.locator.sharedConfig = new ClusterConfigurationService(locator.myCache);
-        }
-        this.locator.sharedConfig.initSharedConfiguration(this.locator.loadFromSharedConfigDir());
-        this.locator.installSharedConfigDistribution();
-        logger.info(
-            "Cluster configuration service start up completed successfully and is now running ....");
-      } catch (CancelException | LockServiceDestroyedException e) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("Cluster configuration start up was cancelled", e);
-        }
-      } catch (Exception e) {
-        logger.error(e.getMessage(), e);
-      }
-    }
+    return startLocator(locatorPort, logFile, logger, logger1, addr, true, dsProperties, s);
-   * 
+   *
-    startSharedConfigurationService(internalCache);
+    startSharedConfigurationService();
-   * 
+   *
-   * 
+   *
-    this.productUseLog.monitorUse(distributedSystem);
-
+    // the product use is not guaranteed to be initialized until the server is started, so
+    // the last thing we do is tell it to start logging
+    this.productUseLog.monitorUse(distributedSystem);
-   * 
+   *
-    this.productUseLog.close();
+    if (this.productUseLog != null) {
+      this.productUseLog.close();
+    }
-   * 
+   *
-   * 
+   *
-      if (isSharedConfigurationEnabled()) {
-        this.sharedConfig = new ClusterConfigurationService(newCache);
-      }
+
-      this.isSharedConfigurationStarted = true;
-      if (isSharedConfigurationEnabled()) {
-        ExecutorService es = newCache.getDistributionManager().getThreadPool();
-        es.execute(new SharedConfigurationRunnable());
-      }
+      startSharedConfigurationService();
-    return this.myDs;
+    if (myDs == null) {
+      return InternalDistributedSystem.getAnyInstance();
+    }
+
+    return myDs;
-   * 
+   *
-      // TODO: this for-loop is probably not necessary as the if to break is always true
-      for (int i = 0; i < MAX_RETRIES; i++) {
-        if (locator.sharedConfig != null) {
-          SharedConfigurationStatus status = locator.sharedConfig.getStatus();
-          if (status != SharedConfigurationStatus.STARTED
-              || status != SharedConfigurationStatus.NOT_STARTED) {
-            break;
-          }
-        }
-        Thread.sleep(SLEEPTIME);
-      }
+
-    // GEODE-2253 test condition
-    private boolean hasWaitedForHandlerInitialization = false;
-              this.hasWaitedForHandlerInitialization = true;
-    /**
-     * GEODE-2253 test condition - has this handler waited for a subordinate handler to be
-     * installed?
-     */
-    public boolean hasWaitedForHandlerInitialization() {
-      return this.hasWaitedForHandlerInitialization;
-    }
-
-
-      ClientProtocolService clientProtocolService = this.server.getClientProtocolService();
-      if (clientProtocolService != null) {
-        clientProtocolService.initializeStatistics("LocatorStats", sys);
-      }
-   * 
+   *
-  private void startSharedConfigurationService(InternalCache internalCache) {
+  private void startSharedConfigurationService() {
-    if (this.config.getEnableClusterConfiguration() && !this.isSharedConfigurationStarted) {
-      if (!isDedicatedLocator()) {
-        logger.info("Cluster configuration service not enabled as it is only supported "
-            + "in dedicated locators");
-        return;
-      }
-
-      ExecutorService es = internalCache.getDistributionManager().getThreadPool();
-      es.execute(new SharedConfigurationRunnable());
-    } else {
+    if (!config.getEnableClusterConfiguration()) {
+      return;
+    }
+
+    if (isSharedConfigurationStarted) {
+      logger.info("Cluster configuration service is already started.");
+      return;
+    }
+
+    if (!isDedicatedLocator()) {
+      logger.info("Cluster configuration service not enabled as it is only supported "
+          + "in dedicated locators");
+      return;
+    }
+
+    try {
+      if (locator.sharedConfig == null) {
+        // locator.sharedConfig will already be created in case of auto-reconnect
+        locator.sharedConfig = new ClusterConfigurationService(locator.myCache);
+      }
+      locator.sharedConfig.initSharedConfiguration(locator.loadFromSharedConfigDir());
+      logger.info(
+          "Cluster configuration service start up completed successfully and is now running ....");
+      isSharedConfigurationStarted = true;
+    } catch (CancelException | LockServiceDestroyedException e) {
+      if (logger.isDebugEnabled()) {
+        logger.debug("Cluster configuration start up was cancelled", e);
+      }
+    } catch (Exception e) {
+      logger.error(e.getMessage(), e);
-  /**
-   * Creates and installs the handler {@link ConfigurationRequestHandler}
-   */
-  private void installSharedConfigDistribution() {
-    if (!this.handler.isHandled(ConfigurationRequest.class)) {
-      this.handler.addHandler(ConfigurationRequest.class,
-          new ConfigurationRequestHandler(this.sharedConfig));
-      logger.info("ConfigRequestHandler installed");
-    }
-  }
-

MOV31 INS31 MOV31 UPD39 MOV83 MOV43 MOV42 MOV8 UPD39 MOV21 MOV78 UPD83 MOV43 UPD42 UPD83 UPD42 MOV41 UPD65 INS60 INS60 MOV21 INS41 INS25 INS41 MOV21 INS25 INS25 MOV25 UPD27 UPD66 INS39 INS59 MOV43 INS59 INS42 INS27 INS8 INS27 INS42 INS38 INS8 INS42 INS8 MOV21 INS42 INS33 INS41 INS42 INS32 INS42 INS14 INS42 MOV22 INS33 MOV21 MOV21 INS42 INS33 INS41 INS32 MOV21 INS41 INS21 INS41 MOV32 MOV43 INS32 MOV22 INS42 MOV43 INS27 INS32 INS42 INS42 INS32 INS7 UPD42 MOV42 UPD42 MOV42 INS45 INS42 INS45 INS42 INS42 UPD42 MOV42 INS42 INS42 INS45 INS40 INS40 INS42 INS9 MOV43 INS42 INS40 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL9 DEL42 DEL33 DEL27 DEL27 DEL9 DEL41 DEL9 DEL41 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL52 DEL42 DEL22 DEL42 DEL43 DEL45 DEL42 DEL45 DEL27 DEL14 DEL7 DEL21 DEL8 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL45 DEL27 DEL14 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL14 DEL7 DEL21 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL43 DEL45 DEL42 DEL45 DEL27 DEL14 DEL7 DEL21 DEL42 DEL45 DEL42 DEL45 DEL27 DEL14 DEL59 DEL60 DEL8 DEL31 DEL52 DEL42 DEL22 DEL42 DEL32 DEL52 DEL42 DEL22 DEL38 DEL42 DEL43 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL43 DEL14 DEL32 DEL21 DEL8 DEL83 DEL8 DEL31 DEL66 DEL66 DEL42 DEL39 DEL42 DEL44 DEL9 DEL52 DEL42 DEL22 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL43 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL52 DEL59 DEL23 DEL55 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL14 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL43 DEL14 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25 DEL66 DEL42 DEL65 DEL65 DEL29 DEL39 DEL52 DEL42 DEL22 DEL42 DEL42 DEL43 DEL57 DEL32 DEL38 DEL52 DEL42 DEL22 DEL42 DEL43 DEL57 DEL42 DEL43 DEL52 DEL42 DEL22 DEL14 DEL32 DEL21 DEL42 DEL42 DEL45 DEL32 DEL21 DEL83 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL40 DEL33 DEL27 DEL42 DEL43 DEL42 DEL40 DEL42 DEL32 DEL59 DEL60 DEL42 DEL40 DEL27 DEL42 DEL40 DEL27 DEL27 DEL10 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL78 DEL52 DEL42 DEL22 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL31
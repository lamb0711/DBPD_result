GEODE-7090 Remove dependency on DataSerializer from membership classes

DataSerializableFixedID is used by most internal classes for
serialization.  Membership, in particular, was constrained in its
implementation to use only "fixed" serialization identifiers because our
other serialization mechanisms (DataSerialiable, PDX) are dependent on
membership and messaging.

This PR moves serialization of DataSerializableFixedID to a new
sub-project, geode-serialization in support of also separating
membership into its own sub-project.

Many files are touched by this PR.  The vast majority are due to a
change in the serialization interface that introduces a new parameter in
DataSerializableFixedID's toData and fromData methods.  This parameter
gives access to the serializer and to the Version of the
source/destination.  This parameter was added to begin moving from a
"static" based serialization service to an instance based service.

Serialization code concerning "DSFID"s has been moved from
InternalDataSerializer to the new class DSFIDSerialzerImpl.
InternalDataSerializer holds on to an instance of this class and
delegates DSFID serialization to it.

InternalDataSerializer also effects registration of Geode's DSFID
classes with this serializer.  Membership "Services" handles
registration of its own DSFID classes with the service, as do other
sub-projects like geode-web.

HeapDataOutputStream has been used by most of our serialization code to
provide a DataOutput for our toData methods.  Over the years this class
has accumulated a lot of adornments for PDX serialization that aren't
appropriate for a geode-serialization sub-project.  Consequently I've
moved much of its code into a superclass, BufferDataOutputStream, that
provides most of its functionality w/o needing to reference other geode-
core classes.

Version.java has been repackaged in this PR, moving it into a
"serialization" package.  This affected some rolling-upgrade and
backward-compatibility tests that were referring to
Version.CURRENT_ORDINAL.  These have been modified to get the "current
version ordinal" from VersionManager.

Finally, InternalDataSerializer injects a serializer into the new
sub-project that provideds an API for handling other types of
serializable objects like PDX.  This serializer is available in the
DataSerializableFixedID toData/fromData context parameter and is used by
membership services when serializing Geode DistributionMessages.

-import org.apache.geode.internal.util.DscodeHelper;
+import org.apache.geode.internal.serialization.DSCODE;
+import org.apache.geode.internal.serialization.DSFIDSerializer;
+import org.apache.geode.internal.serialization.DSFIDSerializerFactory;
+import org.apache.geode.internal.serialization.DataSerializableFixedID;
+import org.apache.geode.internal.serialization.DeserializationContext;
+import org.apache.geode.internal.serialization.DscodeHelper;
+import org.apache.geode.internal.serialization.ObjectDeserializer;
+import org.apache.geode.internal.serialization.ObjectSerializer;
+import org.apache.geode.internal.serialization.SerializationContext;
+import org.apache.geode.internal.serialization.SerializationVersions;
+import org.apache.geode.internal.serialization.StaticSerialization;
+import org.apache.geode.internal.serialization.Version;
+import org.apache.geode.internal.serialization.VersionedDataStream;
-  // array is null
-  public static final byte NULL_ARRAY = -1;
-  /**
-   * array len encoded as int in next 4 bytes
-   *
-   * @since GemFire 5.7
-   */
-  public static final byte INT_ARRAY_LEN = -3;
-  private static final byte TIME_UNIT_NANOSECONDS = -1;
-  private static final byte TIME_UNIT_MICROSECONDS = -2;
-  private static final byte TIME_UNIT_MILLISECONDS = -3;
-  private static final byte TIME_UNIT_SECONDS = -4;
-  /**
-   * array len encoded as unsigned short in next 2 bytes
-   *
-   * @since GemFire 5.7
-   */
-  private static final byte SHORT_ARRAY_LEN = -2;
-  private static final int MAX_BYTE_ARRAY_LEN = (byte) -4 & 0xFF;
-  // Variable Length long encoded as int in next 4 bytes
-  private static final byte INT_VL = 126;
-  // Variable Length long encoded as long in next 8 bytes
-  private static final byte LONG_VL = 127;
-  private static final int MAX_BYTE_VL = 125;
+
+  @MakeNotStatic
+  private static final DSFIDSerializer dsfidSerializer;
+
+  @MakeNotStatic
+  private static final DSFIDFactory dsfidFactory;
+
+    dsfidSerializer = new DSFIDSerializerFactory().setObjectSerializer(new ObjectSerializer() {
+      @Override
+      public void writeObject(Object obj, DataOutput output) throws IOException {
+        InternalDataSerializer.writeObject(obj, output);
+      }
+
+      @Override
+      public void invokeToData(Object ds, DataOutput out) throws IOException {
+        InternalDataSerializer.invokeToData(ds, out);
+      }
+
+      @Override
+      public void writeDSFID(DataSerializableFixedID object, int dsfid, DataOutput out)
+          throws IOException {
+        InternalDataSerializer.writeDSFID(object, dsfid, out);
+      }
+    }).setObjectDeserializer(new ObjectDeserializer() {
+      @Override
+      public Object readObject(DataInput input) throws IOException, ClassNotFoundException {
+        return InternalDataSerializer.readObject(input);
+      }
+
+      @Override
+      public void invokeFromData(Object ds, DataInput in)
+          throws IOException, ClassNotFoundException {
+        InternalDataSerializer.invokeFromData(ds, in);
+      }
+    }).create();
+    dsfidFactory = new DSFIDFactory(dsfidSerializer);
-            out.writeByte(TIME_UNIT_NANOSECONDS);
+            out.writeByte(StaticSerialization.TIME_UNIT_NANOSECONDS);
-            out.writeByte(TIME_UNIT_MICROSECONDS);
+            out.writeByte(StaticSerialization.TIME_UNIT_MICROSECONDS);
-            out.writeByte(TIME_UNIT_MILLISECONDS);
+            out.writeByte(StaticSerialization.TIME_UNIT_MILLISECONDS);
-            out.writeByte(TIME_UNIT_SECONDS);
+            out.writeByte(StaticSerialization.TIME_UNIT_SECONDS);
-    if (dsfidToClassMap != null
-        && logger.isTraceEnabled(LogMarker.SERIALIZER_WRITE_DSFID_VERBOSE)) {
-      logger.trace(LogMarker.SERIALIZER_WRITE_DSFID_VERBOSE, "writeDSFID {} class={}", dsfid,
-          o.getClass());
-      if (dsfid != DataSerializableFixedID.NO_FIXED_ID
-          && dsfid != DataSerializableFixedID.ILLEGAL) {
-        // consistency check to make sure that the same DSFID is not used
-        // for two different classes
-        String newClassName = o.getClass().getName();
-        String existingClassName = dsfidToClassMap.putIfAbsent(dsfid, newClassName);
-        if (existingClassName != null && !existingClassName.equals(newClassName)) {
-          logger.trace(LogMarker.SERIALIZER_WRITE_DSFID_VERBOSE,
-              "dsfid={} is used for class {} and class {}", dsfid, existingClassName, newClassName);
-        }
+    try {
+      if (dsfid != DataSerializableFixedID.NO_FIXED_ID) {
+        dsfidSerializer.writeDSFID(o, dsfid, out);
+        return;
-    }
-    if (dsfid == DataSerializableFixedID.NO_FIXED_ID) {
-    } else {
-      writeDSFIDHeader(dsfid, out);
-    }
-    try {
-      case TIME_UNIT_NANOSECONDS:
+      case StaticSerialization.TIME_UNIT_NANOSECONDS:
-      case TIME_UNIT_MICROSECONDS:
+      case StaticSerialization.TIME_UNIT_MICROSECONDS:
-      case TIME_UNIT_MILLISECONDS:
+      case StaticSerialization.TIME_UNIT_MILLISECONDS:
-      case TIME_UNIT_SECONDS:
+      case StaticSerialization.TIME_UNIT_SECONDS:
-      writeDSFID(dsfid, out);
+      dsfidSerializer.writeDSFID(dsfid, out);
-    boolean isDSFID = ds instanceof DataSerializableFixedID;
+      if (ds instanceof DataSerializableFixedID) {
+        dsfidSerializer.invokeToData(ds, out);
+        return;
+      }
-        if (isDSFID) {
-          ((DataSerializableFixedID) ds).toData(out);
-        } else {
-          ((DataSerializable) ds).toData(out);
-        }
+        ((DataSerializable) ds).toData(out);
-      // DSFID serialization expects an IOException but otherwise
-      // we want to catch it and transform into a ToDataException
-      // since it might be in user code and we want to report it
-      // as a problem with the plugin code
-      if (isDSFID) {
-        throw io;
-      } else {
-        throw new ToDataException("toData failed on DataSerializable " + ds.getClass(), io);
-      }
+      throw new ToDataException("toData failed on DataSerializable " + ds.getClass(), io);
+    if (ds instanceof DataSerializableFixedID) {
+      dsfidSerializer.invokeFromData(ds, in);
+      return;
+    }
-        if (ds instanceof DataSerializableFixedID) {
-          ((DataSerializableFixedID) ds).fromData(in);
-        } else {
-          ((DataSerializable) ds).fromData(in);
-        }
+        ((DataSerializable) ds).fromData(in);
-          logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read {} {}",
-              ds instanceof DataSerializableFixedID ? "DataSerializableFixedID"
-                  : "DataSerializable",
+          logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read DataSerializable {}",
-   * Get the {@link Version} of the peer or disk store that created this {@link DataInput}.
+   * Get the {@link Version} of the peer or disk store that created this
+   * {@link DataInput}.
-   * Get the {@link Version} of the peer or disk store that created this {@link DataInput}. Returns
+   * Get the {@link Version} of the peer or disk store that created this
+   * {@link DataInput}. Returns
-   * Get the {@link Version} of the peer or disk store that created this {@link DataOutput}.
+   * Get the {@link Version} of the peer or disk store that created this
+   * {@link DataOutput}.
-   * Get the {@link Version} of the peer or disk store that created this {@link DataOutput}. Returns
+   * Get the {@link Version} of the peer or disk store that created this
+   * {@link DataOutput}. Returns
-      out.writeByte(NULL_ARRAY);
-    } else if (len <= MAX_BYTE_ARRAY_LEN) {
+      out.writeByte(StaticSerialization.NULL_ARRAY);
+    } else if (len <= StaticSerialization.MAX_BYTE_ARRAY_LEN) {
-      out.writeByte(SHORT_ARRAY_LEN);
+      out.writeByte(StaticSerialization.SHORT_ARRAY_LEN);
-      out.writeByte(INT_ARRAY_LEN);
+      out.writeByte(StaticSerialization.INT_ARRAY_LEN);
-    if (code == NULL_ARRAY) {
+    if (code == StaticSerialization.NULL_ARRAY) {
-      if (result > MAX_BYTE_ARRAY_LEN) {
-        if (code == SHORT_ARRAY_LEN) {
+      if (result > StaticSerialization.MAX_BYTE_ARRAY_LEN) {
+        if (code == StaticSerialization.SHORT_ARRAY_LEN) {
-        } else if (code == INT_ARRAY_LEN) {
+        } else if (code == StaticSerialization.INT_ARRAY_LEN) {
-        return DSFIDFactory.create(in.readByte(), in);
+        return dsfidFactory.create(in.readByte(), in);
-        return DSFIDFactory.create(in.readShort(), in);
+        return dsfidFactory.create(in.readShort(), in);
-        return DSFIDFactory.create(in.readInt(), in);
+        return dsfidFactory.create(in.readInt(), in);
-  private static int readDSFIDHeader(final DataInput in, DSCODE dscode) throws IOException {
-    switch (dscode) {
-      case DS_FIXED_ID_BYTE:
-        return in.readByte();
-      case DS_FIXED_ID_SHORT:
-        return in.readShort();
-      case DS_FIXED_ID_INT:
-        return in.readInt();
-      default:
-        throw new IllegalStateException("unexpected byte: " + dscode + " while reading dsfid");
-    }
-  }
-
-  public static int readDSFIDHeader(final DataInput in) throws IOException {
-    checkIn(in);
-    return readDSFIDHeader(in, DscodeHelper.toDSCODE(in.readByte()));
-  }
-
-  @MakeNotStatic("not tied to the cache lifecycle")
-  private static final ThreadLocalByteArrayCache threadLocalByteArrayCache =
-      new ThreadLocalByteArrayCache(65535);
-
-  /**
-   * Returns a byte array for use by the calling thread.
-   * The returned byte array may be longer than minimumLength.
-   * The byte array belongs to the calling thread but callers must
-   * be careful to not call other methods that may also use this
-   * byte array.
-   */
-  public static byte[] getThreadLocalByteArray(int minimumLength) {
-    return threadLocalByteArrayCache.get(minimumLength);
-  }
-
-    byte[] buf = getThreadLocalByteArray(len);
+    byte[] buf = StaticSerialization.getThreadLocalByteArray(len);
-    return readString(in, DscodeHelper.toDSCODE(header));
+    return StaticSerialization.readString(in, header);
-        return DSFIDFactory.create(in.readByte(), in);
+        return dsfidFactory.create(in.readByte(), in);
-        return DSFIDFactory.create(in.readShort(), in);
+        return dsfidFactory.create(in.readShort(), in);
-        return DSFIDFactory.create(in.readInt(), in);
+        return dsfidFactory.create(in.readInt(), in);
-    if (data <= MAX_BYTE_VL) {
+    if (data <= StaticSerialization.MAX_BYTE_VL) {
-      out.writeByte(INT_VL);
+      out.writeByte(StaticSerialization.INT_VL);
-      out.writeByte(LONG_VL);
+      out.writeByte(StaticSerialization.LONG_VL);
-    } else if (code <= MAX_BYTE_VL) {
+    } else if (code <= StaticSerialization.MAX_BYTE_VL) {
-    } else if (code == INT_VL) {
+    } else if (code == StaticSerialization.INT_VL) {
+  public static DSFIDSerializer getDSFIDSerializer() {
+    return dsfidSerializer;
+  }
+
+  /**
+   * shortcut for getDSFIDSerializer().createDeserializationContext(), this should be used
+   * when you need to create a deserialization "context" to pass to a fromData method
+   * and don't have one available
+   */
+  public static DeserializationContext createDeserializationContext(DataInput in) {
+    return dsfidSerializer.createDeserializationContext(in);
+  }
+
+  /**
+   * shortcut for getDSFIDSerializer().createSerializationContext(), this should be used
+   * when you need to create a deserialization "context" to pass to a toData method and
+   * don't have a one available
+   */
+  public static SerializationContext createSerializationContext(DataOutput out) {
+    return dsfidSerializer.createSerializationContext(out);
+  }
+
+  public static DSFIDFactory getDSFIDFactory() {
+    return dsfidFactory;
+  }
+
-    public void toData(DataOutput out) throws IOException {
-      super.toData(out);
+    public void toData(DataOutput out,
+        SerializationContext context) throws IOException {
+      super.toData(out, context);
-    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      super.fromData(in);
+    public void fromData(DataInput in,
+        DeserializationContext context) throws IOException, ClassNotFoundException {
+      super.fromData(in, context);

INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 MOV23 MOV23 MOV31 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS28 INS31 INS31 INS31 INS78 UPD83 INS43 INS78 UPD83 INS43 INS83 INS8 INS83 INS83 INS43 INS42 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS8 INS43 UPD42 INS83 INS83 INS43 INS42 INS8 INS42 INS42 UPD42 INS42 INS42 UPD42 INS21 MOV21 INS21 INS25 INS42 INS41 INS65 UPD42 MOV42 INS43 INS42 INS41 INS42 INS43 INS42 INS42 INS41 INS44 INS44 INS7 INS7 MOV8 MOV25 MOV62 INS8 UPD66 UPD66 UPD66 UPD66 INS42 INS66 INS66 INS66 UPD42 MOV42 INS32 UPD66 UPD66 UPD66 INS42 INS42 INS43 INS42 INS43 INS42 INS42 INS32 INS42 INS14 INS25 MOV21 INS40 INS40 INS40 INS40 MOV25 MOV8 INS21 INS41 MOV25 INS40 INS42 MOV42 INS40 INS42 INS42 INS42 UPD42 UPD42 UPD42 INS42 INS42 INS32 UPD42 MOV42 INS43 INS42 MOV27 INS8 MOV62 MOV38 INS32 MOV38 INS40 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 INS40 INS42 INS42 INS32 UPD42 MOV42 INS14 INS42 INS21 INS41 INS21 INS41 INS42 INS42 INS42 INS42 INS25 INS40 INS40 INS40 INS14 INS42 INS14 INS43 INS1 INS32 INS42 INS32 MOV32 INS8 INS43 INS43 INS1 INS42 INS31 INS31 MOV8 MOV8 MOV49 MOV8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS40 INS40 INS40 INS40 INS40 INS42 INS42 INS31 INS31 INS31 INS78 INS83 INS43 INS42 INS44 MOV43 INS43 INS8 INS78 MOV83 UPD39 MOV39 UPD42 MOV42 INS44 MOV44 MOV43 INS43 INS8 INS32 INS40 INS78 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS43 INS8 INS78 INS83 INS39 INS42 INS44 INS44 MOV44 INS43 INS8 INS42 INS42 INS43 INS42 INS42 INS41 INS42 INS43 INS42 INS42 MOV21 INS42 INS42 INS40 INS45 INS42 INS42 INS43 INS42 INS43 INS42 INS42 INS21 INS42 INS43 INS42 INS43 INS42 INS42 INS21 INS42 MOV43 INS42 INS39 INS42 UPD43 UPD42 UPD42 MOV42 INS21 INS42 MOV32 INS42 INS42 INS42 INS32 INS42 INS42 INS32 UPD42 INS32 UPD42 UPD42 INS42 UPD42 INS42 INS42 INS40 INS40 INS40 INS40 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL38 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL38 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL38 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL38 DEL59 DEL23 DEL66 DEL65 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL38 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL39 DEL34 DEL38 DEL11 DEL34 DEL27 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL34 DEL59 DEL23 DEL39 DEL34 DEL38 DEL66 DEL65 DEL66 DEL65 DEL29 DEL39 DEL34 DEL38 DEL83 DEL83 DEL83 DEL8 DEL28 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL27 DEL42 DEL42 DEL40 DEL32 DEL27 DEL42 DEL42 DEL40 DEL45 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL42 DEL40 DEL27 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL38 DEL27 DEL42 DEL42 DEL40 DEL45 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL42 DEL40 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL42 DEL39 DEL42 DEL42 DEL42 DEL43 DEL62 DEL59 DEL60 DEL42 DEL42 DEL11 DEL36 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL53 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL40 DEL45 DEL45 DEL45 DEL16 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL83 DEL83 DEL39 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL49 DEL42 DEL32 DEL41 DEL42 DEL49 DEL42 DEL42 DEL32 DEL41 DEL42 DEL49 DEL41 DEL49 DEL42 DEL43 DEL45 DEL42 DEL45 DEL27 DEL14 DEL53 DEL50 DEL8 DEL31 DEL83 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL32 DEL41 DEL8 DEL31 DEL42 DEL45 DEL79 DEL83 DEL83 DEL83 DEL43 DEL42 DEL43 DEL34 DEL14 DEL59 DEL23 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL66 DEL66 DEL39 DEL85 DEL5 DEL39 DEL42
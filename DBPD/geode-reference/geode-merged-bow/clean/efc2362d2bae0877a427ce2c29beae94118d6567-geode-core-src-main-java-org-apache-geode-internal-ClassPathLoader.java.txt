GEODE-6964: Move geode log4j core classes to geode-log4j

Introduce new Logging and Alerting SPIs. Extract all log4j-core code to
geode-log4j module.

The geode-core module no longer contains log4j2.xml and no longer has a
dependency on log4j-core.

All code that uses log4j-core has moved to the new module geode-log4j.
The log4j2.xml for Geode now lives in geode-log4j as well. These
changes ensure that users have better control over logging including
which backend to use. This should improve user experience when using
Spring Boot.

Co-authored-by: Mark Hanson <mhanson@pivotal.io>

+import org.apache.logging.log4j.LogManager;
+import org.apache.geode.annotations.VisibleForTesting;
-import org.apache.geode.internal.logging.LogService;
+ *
- * <li><tt>System.setProperty("gemfire.excludeThreadContextClassLoader", "true");
- * </tt>
+ * <li><tt>System.setProperty("gemfire.excludeThreadContextClassLoader", "true");</tt>
+ *
- * class loaders results in either a {@link java.lang.SecurityException SecurityException} or a
- * null, then that class loader is quietly skipped. Duplicate class loaders will be skipped.
+ * class loaders results in either a {@code SecurityException} or a null, then that class loader is
+ * quietly skipped. Duplicate class loaders will be skipped.
+ * </ul>
+ *
- * This class it not an extension of ClassLoader due to #43080. See also
- * http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html
+ * See http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html for more information about
+ * {@code ClassLoader}s.
-  private static final Logger logger = LogService.getLogger();
+  private static final Logger logger = LogManager.getLogger();
-  public final HashMap<String, DeployJarChildFirstClassLoader> latestJarNamesToClassLoader =
+  private final HashMap<String, DeployJarChildFirstClassLoader> latestJarNamesToClassLoader =
-  private boolean excludeTCCL;
+  private final boolean excludeTCCL;
-    this.jarDeployer = new JarDeployer();
+    jarDeployer = new JarDeployer();
-    this.jarDeployer = new JarDeployer(workingDir);
+    jarDeployer = new JarDeployer(workingDir);
+  @VisibleForTesting
-    return this.jarDeployer;
+    return jarDeployer;
+  @VisibleForTesting
-  synchronized void rebuildClassLoaderForDeployedJars() {
+  private synchronized void rebuildClassLoaderForDeployedJars() {
-  ClassLoader getLeafLoader() {
+  private ClassLoader getLeafLoader() {
-    this.leafLoader = new DeployJarChildFirstClassLoader(latestJarNamesToClassLoader,
+    leafLoader = new DeployJarChildFirstClassLoader(latestJarNamesToClassLoader,
-    final boolean isDebugEnabled = logger.isTraceEnabled();
-    if (isDebugEnabled) {
+    final boolean isTraceEnabled = logger.isTraceEnabled();
+    if (isTraceEnabled) {
-      if (isDebugEnabled) {
+      if (isTraceEnabled) {
-          if (isDebugEnabled) {
+          if (isTraceEnabled) {
-    final boolean isDebugEnabled = logger.isTraceEnabled();
-    if (isDebugEnabled) {
+    final boolean isTraceEnabled = logger.isTraceEnabled();
+    if (isTraceEnabled) {
-    Class<?> clazz = forName(name, isDebugEnabled);
+    Class<?> clazz = forName(name, isTraceEnabled);
-  private Class<?> forName(String name, boolean isDebugEnabled) {
-    for (ClassLoader classLoader : this.getClassLoaders()) {
-      if (isDebugEnabled) {
+  private Class<?> forName(String name, boolean isTraceEnabled) {
+    for (ClassLoader classLoader : getClassLoaders()) {
+      if (isTraceEnabled) {
-          if (isDebugEnabled) {
+          if (isTraceEnabled) {
-    for (ClassLoader classLoader : this.getClassLoaders()) {
+    for (ClassLoader classLoader : getClassLoaders()) {
-    sb.append(", excludeTCCL=").append(this.excludeTCCL);
+    sb.append(", excludeTCCL=").append(excludeTCCL);
-    sb.append(this.getClassLoaders().stream().map(ClassLoader::toString).collect(joining(", ")));
+    sb.append(getClassLoaders().stream().map(ClassLoader::toString).collect(joining(", ")));
-   * the context class for the resource before searching all other {@link ClassLoader}s.
+   * the context class for the resource before searching all other {@code ClassLoader}s.
-   * @return An enumeration of {@link java.net.URL <tt>URL</tt>} objects for the resource. If no
-   *         resources could be found, the enumeration will be empty. Resources that the class
-   *         loader doesn't have access to will not be in the enumeration.
+   * @return An enumeration of <tt>URL</tt> objects for the resource. If no resources could be
+   *         found, the enumeration will be empty. Resources that the class loader doesn't have
+   *         access to will not be in the enumeration.
-    final LinkedHashSet<URL> urls = new LinkedHashSet<URL>();
+    final LinkedHashSet<URL> urls = new LinkedHashSet<>();
-   * Wrap this {@link ClassPathLoader} with a {@link ClassLoader} facade.
+   * Wrap this {@code ClassPathLoader} with a {@code ClassLoader} facade.
-   * @return {@link ClassLoader} facade.
+   * @return a ClassLoader facade.
-        return ClassPathLoader.this.forName(name);
+        return forName(name);
-        return ClassPathLoader.this.forName(name);
+        return forName(name);
-   * Helper method equivalent to <code>ClassPathLoader.getLatest().asClassLoader();</code>.
+   * Helper method equivalent to {@code ClassPathLoader.getLatest().asClassLoader();}.
-   * @return {@link ClassLoader} for current {@link ClassPathLoader}.
+   * @return a ClassLoader for current ClassPathLoader.

MOV26 INS26 UPD40 INS40 UPD83 INS83 INS78 INS78 INS83 INS83 UPD66 UPD65 UPD66 UPD66 INS66 INS66 INS65 UPD66 INS42 INS42 UPD42 INS65 UPD66 MOV66 UPD42 INS42 UPD42 UPD42 UPD65 UPD66 UPD66 UPD66 UPD65 UPD65 UPD66 INS66 INS65 INS66 UPD66 INS42 INS42 INS42 UPD42 UPD42 INS42 INS66 INS66 INS66 UPD66 MOV66 UPD42 UPD42 UPD42 UPD74 UPD42 UPD42 DEL66 DEL40 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL66 DEL40 DEL66 DEL65 DEL42 DEL43 DEL42 DEL42 DEL66 DEL42 DEL65 DEL42 DEL52 DEL42 DEL52 DEL65 DEL66 DEL42 DEL65 DEL42 DEL65 DEL66
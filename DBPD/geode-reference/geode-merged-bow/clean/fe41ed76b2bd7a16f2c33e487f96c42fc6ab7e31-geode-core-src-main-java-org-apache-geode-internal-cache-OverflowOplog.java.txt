GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

- * 
+
-  /** preallocated space available for writing to* */
-  // volatile private long opLogSpace = 0L;
-  private static final ByteBuffer EMPTY = ByteBuffer.allocate(0);
-
-  // ///////////////////// Constructors ////////////////////////
-  // /**
-  // * Creates new <code>Oplog</code> for the given region.
-  // *
-  // * @param oplogId
-  // * int identifying the new oplog
-  // * @param dirHolder
-  // * The directory in which to create new Oplog
-  // *
-  // * @throws DiskAccessException
-  // * if the disk files can not be initialized
-  // */
-  // OverflowOplog(int oplogId, DiskStoreImpl parent, DirectoryHolder dirHolder) {
-  // this.oplogId = oplogId;
-  // this.parent = parent;
-  // this.dirHolder = dirHolder;
-  // this.opState = new OpState();
-  // long maxOplogSizeParam = this.parent.getMaxOplogSizeInBytes();
-  // long availableSpace = this.dirHolder.getAvailableSpace();
-  // if (availableSpace < maxOplogSizeParam) {
-  // this.maxOplogSize = availableSpace;
-  // } else {
-  // this.maxOplogSize = maxOplogSizeParam;
-  // }
-  // this.stats = this.parent.getStats();
-
-  // this.closed = false;
-  // String n = this.parent.getName();
-  // this.diskFile = new File(this.dirHolder.getDir(),
-  // "OVERFLOW"
-  // + n + "_" + oplogId);
-  // try {
-  // createCrf();
-  // }
-  // catch (IOException ex) {
-  // throw new
-  // DiskAccessException(LocalizedStrings.Oplog_FAILED_CREATING_OPERATION_LOG_BECAUSE_0.toLocalizedString(ex),
-  // this.parent);
-  // }
-  // }
-
-   * Asif: A copy constructor used for creating a new oplog based on the previous Oplog. This
-   * constructor is invoked only from the function switchOplog
+   * A copy constructor used for creating a new oplog based on the previous Oplog. This constructor
+   * is invoked only from the function switchOplog
-    } catch (IOException ioe) {
-      // @todo need a warning since this can impact perf.
+    } catch (IOException ignore) {
+      // TODO: need a warning since this can impact perf.
-      // raf.close();
-      // if (!this.opLogFile.delete() && this.opLogFile.exists()) {
-      // throw new
-      // DiskAccessException(LocalizedStrings.NewLBHTreeDiskRegion_COULD_NOT_DELETE__0_.toLocalizedString(this.opLogFile.getAbsolutePath()),
-      // this.owner);
-      // }
-      // f = new File(this.diskFile.getPath() + OPLOG_FILE_EXT);
-      // this.opLogFile = f;
-      // raf = new RandomAccessFile(f, "rw");
-   * 
-   * @throws IOException
-      result = ByteBuffer.allocateDirect(Integer.getInteger("WRITE_BUF_SIZE", 32768).intValue());
+      result = ByteBuffer.allocateDirect(Integer.getInteger("WRITE_BUF_SIZE", 32768));
-   * Flushes any pending writes to disk.
-   * 
-   * public final void flush() { forceFlush(); }
-   */
-
-  /**
-   * 
-   * @throws IOException
-   * @throws SyncFailedException
-  public final BytesAndBits getBytesAndBits(DiskRegionView dr, DiskId id, boolean faultingIn,
+  public BytesAndBits getBytesAndBits(DiskRegionView dr, DiskId id, boolean faultingIn,
-    // Asif: If the offset happens to be -1, still it is possible that
+    // If the offset happens to be -1, still it is possible that
-      // Asif: Since it is given that a get operation has alreadty
+      // Since it is given that a get operation has alreadty
-      // if (id.getOplogId() == this.oplogId) {
-      // }
-      // }
-    // Asif :If the current OpLog is not destroyed ( its opLogRaf file
+    // If the current OpLog is not destroyed ( its opLogRaf file
-    // Asif: If bb is still null then entry has been compacted to the Htree
+    // If bb is still null then entry has been compacted to the Htree
-    // Asif: Since the compacter takes a lock on Entry as well as DiskId , the
+    // Since the compacter takes a lock on Entry as well as DiskId , the
-    /*
-     * if (bb == null) { // TODO: added by mitul, remove it later Assert.assertTrue(id.getOplogId()
-     * != this.oplogId);
-     */
-              .toLocalizedString(new Object[] {id, Boolean.valueOf(dr.isSync())}));
+              .toLocalizedString(new Object[] {id, dr.isSync()}));
-
-   * 
-  public final BytesAndBits getNoBuffer(DiskRegion dr, DiskId id) {
+  public BytesAndBits getNoBuffer(DiskRegion dr, DiskId id) {
-      BytesAndBits bb =
-          basicGet(dr, id.getOffsetInOplog(), false, id.getValueLength(), id.getUserBits());
-      return bb;
+      return basicGet(dr, id.getOffsetInOplog(), false, id.getValueLength(), id.getUserBits());
-   * 
+   * <p>
+   * Modified the code so as to reuse the already created ByteBuffer during transition. Minimizing
+   * the synchronization allowing multiple put operations for different entries to proceed
+   * concurrently for asynch mode
-   * 
-   * @throws DiskAccessException
-   * @throws IllegalStateException
-   */
-  /*
-   * Asif: Modified the code so as to reuse the already created ByteBuffer during transition.
-   * Minimizing the synchronization allowing multiple put operations for different entries to
-   * proceed concurrently for asynch mode
-   * 
-  public final boolean modify(DiskRegion dr, DiskEntry entry, ValueWrapper value, boolean async) {
+  public boolean modify(DiskRegion dr, DiskEntry entry, ValueWrapper value, boolean async) {
-  public final boolean copyForwardForOverflowCompact(DiskEntry entry, byte[] value, int length,
+  public boolean copyForwardForOverflowCompact(DiskEntry entry, byte[] value, int length,
-   * Asif: A helper function which identifies whether to modify the entry in the current oplog or to
-   * make the switch to the next oplog. This function enables us to reuse the byte buffer which got
+   * A helper function which identifies whether to modify the entry in the current oplog or to make
+   * the switch to the next oplog. This function enables us to reuse the byte buffer which got
-   * @throws IOException
-   * @throws InterruptedException
-  public final void remove(DiskRegion dr, DiskEntry entry) {
+  public void remove(DiskRegion dr, DiskEntry entry) {
-   * 
-   * Asif: A helper function which identifies whether to record a removal of entry in the current
-   * oplog or to make the switch to the next oplog. This function enables us to reuse the byte
-   * buffer which got created for an oplog which no longer permits us to use itself.
+   * A helper function which identifies whether to record a removal of entry in the current oplog or
+   * to make the switch to the next oplog. This function enables us to reuse the byte buffer which
+   * got created for an oplog which no longer permits us to use itself.
-   * @throws IOException
-   * @throws InterruptedException
-
-  // /**
-  // * This is only used for an assertion check.
-  // */
-  // private long lastWritePos = -1;
-
-  public final ByteBuffer getWriteBuf() {
+  public ByteBuffer getWriteBuf() {
-  public final void flush() throws IOException {
+  public void flush() throws IOException {
-  public final void flush(ByteBuffer b1, ByteBuffer b2) throws IOException {
+  public void flush(ByteBuffer b1, ByteBuffer b2) throws IOException {
-  public final void flushAll() {
+  public void flushAll() {
-   * Asif: Since the ByteBuffer being writen to can have additional bytes which are used for
-   * extending the size of the file, it is necessary that the ByteBuffer provided should have limit
-   * which is set to the position till which it contains the actual bytes. If the mode is synched
-   * write then only we will write up to the capacity & opLogSpace variable have any meaning. For
-   * asynch mode it will be zero. Also this method must be synchronized on the file , whether we use
-   * synch or asynch write because the fault in operations can clash with the asynch writing. Write
-   * the specified bytes to the oplog. Note that since extending a file is expensive this code will
+   * Since the ByteBuffer being writen to can have additional bytes which are used for extending the
+   * size of the file, it is necessary that the ByteBuffer provided should have limit which is set
+   * to the position till which it contains the actual bytes. If the mode is synched write then only
+   * we will write up to the capacity & opLogSpace variable have any meaning. For asynch mode it
+   * will be zero. Also this method must be synchronized on the file , whether we use synch or
+   * asynch write because the fault in operations can clash with the asynch writing. Write the
+   * specified bytes to the oplog. Note that since extending a file is expensive this code will
-      // Asif : It is assumed that the file pointer is already at the
+      // It is assumed that the file pointer is already at the
-      // if (this.closed || this.deleted.get()) {
-      // throw new DiskAccessException("attempting get on "
-      // + (this.deleted.get() ? "destroyed" : "closed")
-      // + " oplog #" + getOplogId(), this.owner);
-      // }
-      final long readPosition = offsetInOplog;
-      assert readPosition >= 0;
+      assert offsetInOplog >= 0;
-        bb = attemptWriteBufferGet(writePosition, readPosition, valueLength, userBits);
+        bb = attemptWriteBufferGet(writePosition, offsetInOplog, valueLength, userBits);
-               */ (readPosition + valueLength) > this.crf.bytesFlushed && !this.closed) {
+               */ (offsetInOplog + valueLength) > this.crf.bytesFlushed && !this.closed) {
-        myRAF.seek(readPosition);
+        myRAF.seek(offsetInOplog);
-   * Asif: Extracts the Value byte array & UserBit from the OpLog
+   * Extracts the Value byte array & UserBit from the OpLog
-          } catch (InterruptedIOException e) { // bug 39756
+          } catch (InterruptedIOException ignore) {
+            // bug 39756
-                .toLocalizedString(new Object[] {this.diskFile.getPath(),
-                    Long.valueOf(this.oplogId), Long.valueOf(offsetInOplog),
-                    Long.valueOf(this.crf.currSize), Long.valueOf(this.crf.bytesFlushed),
-                    Boolean.valueOf(!dr.isSync()), Boolean.valueOf(false)}),
+                .toLocalizedString(this.diskFile.getPath(), (long) this.oplogId, offsetInOplog,
+                    this.crf.currSize, this.crf.bytesFlushed, !dr.isSync(), false),
+
-      double rvHWM = rvHWMtmp;
-      if (((rv / rvHWM) * 100) <= parent.getCompactionThreshold()) {
+      if (((rv / (double) rvHWMtmp) * 100) <= parent.getCompactionThreshold()) {
-  private GemFireCacheImpl getGemFireCache() {
-    return this.parent.getCache();
-  }
-
-  private final OplogFile getOLF() {
+  private OplogFile getOLF() {
-  // // Comparable code //
-  // public int compareTo(Oplog o) {
-  // return getOplogId() - o.getOplogId();
-  // }
-  // public boolean equals(Object o) {
-  // if (o instanceof Oplog) {
-  // return compareTo((Oplog)o) == 0;
-  // } else {
-  // return false;
-  // }
-  // }
-  // public int hashCode() {
-  // return getOplogId();
-  // }
-
-  // //////// Methods used during recovery //////////////
-
-  // ////////////////////Inner Classes //////////////////////
-
+
+
+
-    public final int getSize() {
+    public int getSize() {
-    private final void write(ValueWrapper vw) throws IOException {
+    private void write(ValueWrapper vw) throws IOException {
-  private final static ThreadLocal isCompactorThread = new ThreadLocal();
+  private static final ThreadLocal isCompactorThread = new ThreadLocal();
-        // Asif:Start with a fresh wrapper on every compaction so that
+        // Start with a fresh wrapper on every compaction so that
-            // Asif: Check if the value byte array happens to be any of the constant
+            // Check if the value byte array happens to be any of the constant
-   * Asif:This function retrieves the value for an entry being compacted subject to entry
-   * referencing the oplog being compacted. Attempt is made to retrieve the value from in memory ,
-   * if available, else from asynch buffers ( if asynch mode is enabled), else from the Oplog being
-   * compacted. It is invoked from switchOplog as well as OplogCompactor's compact function.
+   * This function retrieves the value for an entry being compacted subject to entry referencing the
+   * oplog being compacted. Attempt is made to retrieve the value from in memory , if available,
+   * else from asynch buffers ( if asynch mode is enabled), else from the Oplog being compacted. It
+   * is invoked from switchOplog as well as OplogCompactor's compact function.
-      // Asif: If the mode is synch it is guaranteed to be present in the disk
+      // If the mode is synch it is guaranteed to be present in the disk
-   * Asif: Extracts the Value byte array & UserBit from the OpLog and inserts it in the wrapper
-   * Object of type BytesAndBitsForCompactor which is passed
+   * Extracts the Value byte array & UserBit from the OpLog and inserts it in the wrapper Object of
+   * type BytesAndBitsForCompactor which is passed
-          final long readPosition = offsetInOplog;
-               */ (readPosition + valueLength) > this.crf.bytesFlushed && !this.closed) {
+               */ (offsetInOplog + valueLength) > this.crf.bytesFlushed && !this.closed) {
-          if ((readPosition + valueLength) > writePosition) {
+          if ((offsetInOplog + valueLength) > writePosition) {
-                    .toLocalizedString(
-                        new Object[] {readPosition + valueLength, writePosition, this.crf.raf}),
+                    .toLocalizedString(offsetInOplog + valueLength, writePosition, this.crf.raf),
-          } else if (readPosition < 0) {
+          } else if (offsetInOplog < 0) {
-                    new Object[] {Long.valueOf(offsetInOplog), this.diskFile.getPath()}),
+                    offsetInOplog, this.diskFile.getPath()),
-          // if (this.closed || this.deleted.get()) {
-          // throw new DiskAccessException("attempting get on "
-          // + (this.deleted.get() ? "destroyed" : "closed")
-          // + " oplog #" + getOplogId(), this.owner);
-          // }
-            this.crf.raf.seek(readPosition);
+            this.crf.raf.seek(offsetInOplog);
-                .toLocalizedString(new Object[] {this.diskFile.getPath(),
-                    Long.valueOf(this.oplogId), Long.valueOf(offsetInOplog),
-                    Long.valueOf(this.crf.currSize), Long.valueOf(this.crf.bytesFlushed),
-                    Boolean.valueOf(/* !dr.isSync() @todo */false), Boolean.valueOf(false)}),
+                .toLocalizedString(this.diskFile.getPath(), (long) this.oplogId, offsetInOplog,
+                    this.crf.currSize, this.crf.bytesFlushed, false, false),

INS83 UPD65 UPD66 UPD66 INS66 INS66 INS66 INS66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 MOV32 MOV32 MOV32 UPD42 UPD42 INS42 UPD42 MOV32 UPD42 MOV43 MOV32 INS11 MOV42 MOV22 MOV22 MOV38 MOV9 INS11 MOV32 INS11 MOV42 MOV22 MOV22 MOV9 MOV9 UPD42 INS39 MOV22 INS39 INS42 UPD42 INS39 MOV22 UPD42 MOV43 MOV32 UPD42 UPD42 UPD42 INS27 INS42 MOV22 MOV43 MOV32 UPD42 MOV42 MOV42 INS42 MOV32 UPD42 MOV42 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL34 DEL32 DEL59 DEL23 DEL42 DEL65 DEL42 DEL42 DEL32 DEL42 DEL65 DEL42 DEL65 DEL83 DEL42 DEL42 DEL32 DEL83 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL42 DEL65 DEL83 DEL83 DEL42 DEL65 DEL42 DEL65 DEL83 DEL42 DEL65 DEL42 DEL65 DEL83 DEL83 DEL83 DEL83 DEL83 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL4 DEL3 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL41 DEL8 DEL31 DEL83 DEL83 DEL83 DEL83 DEL83 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL27 DEL42 DEL4 DEL3 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL4 DEL3 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL4 DEL3
GEODE-8170: change all hash and set commands to use function (#5125)

All hash and set commands now use the new function+delta data model.
This allowed the synchronized keyword to be removed from RedisHash and RedisSet.

+    boolean useStripedExecutor = true;
+      case SUNIONSTORE: {
+        ArrayList<ByteArrayWrapper> setKeys = (ArrayList<ByteArrayWrapper>) args[1];
+        callable =
+            () -> new RedisSetInRegion(localRegion).sunionstore(stripedExecutor, key, setKeys);
+        useStripedExecutor = false;
+        break;
+      }
+      case SINTERSTORE: {
+        ArrayList<ByteArrayWrapper> setKeys = (ArrayList<ByteArrayWrapper>) args[1];
+        callable =
+            () -> new RedisSetInRegion(localRegion).sinterstore(stripedExecutor, key, setKeys);
+        useStripedExecutor = false;
+        break;
+      }
+      case SDIFFSTORE: {
+        ArrayList<ByteArrayWrapper> setKeys = (ArrayList<ByteArrayWrapper>) args[1];
+        callable =
+            () -> new RedisSetInRegion(localRegion).sdiffstore(stripedExecutor, key, setKeys);
+        useStripedExecutor = false;
+        break;
+      }
+      case HEXISTS: {
+        ByteArrayWrapper field = (ByteArrayWrapper) args[1];
+        callable = () -> new RedisHashInRegion(localRegion).hexists(key, field);
+        break;
+      }
+      case HGET: {
+        ByteArrayWrapper field = (ByteArrayWrapper) args[1];
+        callable = () -> new RedisHashInRegion(localRegion).hget(key, field);
+        break;
+      }
+      case HLEN: {
+        callable = () -> new RedisHashInRegion(localRegion).hlen(key);
+        break;
+      }
+      case HMGET: {
+        List<ByteArrayWrapper> fields = (List<ByteArrayWrapper>) args[1];
+        callable = () -> new RedisHashInRegion(localRegion).hmget(key, fields);
+        break;
+      }
+      case HVALS: {
+        callable = () -> new RedisHashInRegion(localRegion).hvals(key);
+        break;
+      }
+      case HKEYS: {
+        callable = () -> new RedisHashInRegion(localRegion).hkeys(key);
+        break;
+      }
+      case HSCAN: {
+        Object[] hsetArgs = (Object[]) args[1];
+        Pattern pattern = (Pattern) hsetArgs[0];
+        int count = (int) hsetArgs[1];
+        int cursor = (int) hsetArgs[2];
+        callable = () -> new RedisHashInRegion(localRegion).hscan(key, pattern, count, cursor);
+        break;
+      }
+      case HINCRBY: {
+        Object[] hsetArgs = (Object[]) args[1];
+        ByteArrayWrapper field = (ByteArrayWrapper) hsetArgs[0];
+        long increment = (long) hsetArgs[1];
+        callable = () -> new RedisHashInRegion(localRegion).hincrby(key, field, increment);
+        break;
+      }
+      case HINCRBYFLOAT: {
+        Object[] hsetArgs = (Object[]) args[1];
+        ByteArrayWrapper field = (ByteArrayWrapper) hsetArgs[0];
+        double increment = (double) hsetArgs[1];
+        callable = () -> new RedisHashInRegion(localRegion).hincrbyfloat(key, field, increment);
+        break;
+      }
-    return stripedExecutor.execute(key, callable);
+    if (useStripedExecutor) {
+      return stripedExecutor.execute(key, callable);
+    } else {
+      try {
+        return callable.call();
+      } catch (RuntimeException re) {
+        throw re;
+      } catch (Exception e) {
+        throw new RuntimeException(e);
+      }
+    }

INS60 MOV49 INS25 INS39 INS59 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS8 INS49 INS42 INS8 INS8 INS42 INS9 INS42 INS60 INS21 INS21 INS10 INS42 INS60 INS21 INS21 INS10 INS42 INS60 INS21 INS21 INS10 INS42 INS60 INS21 INS10 INS42 INS60 INS21 INS10 INS42 INS21 INS10 INS42 INS60 INS21 INS10 INS42 INS21 INS10 INS42 INS21 INS10 INS42 INS60 INS60 INS60 INS60 INS21 INS10 INS42 INS60 INS60 INS60 INS21 INS10 INS42 INS60 INS60 INS60 INS21 INS10 MOV41 INS54 INS74 INS59 INS7 INS7 INS74 INS59 INS7 INS7 INS74 INS59 INS7 INS7 INS43 INS59 INS7 INS43 INS59 INS7 INS7 INS74 INS59 INS7 INS7 INS7 INS5 INS59 INS43 INS59 INS39 INS59 INS39 INS59 INS7 INS5 INS59 INS43 INS59 INS39 INS59 INS7 INS5 INS59 INS43 INS59 INS39 INS59 INS7 INS8 INS12 INS12 INS43 INS43 INS42 INS11 INS42 INS86 INS42 INS9 INS43 INS43 INS42 INS11 INS42 INS86 INS42 INS9 INS43 INS43 INS42 INS11 INS42 INS86 INS42 INS9 INS42 INS42 INS11 INS42 INS86 INS42 INS42 INS11 INS42 INS86 INS42 INS86 INS43 INS43 INS42 INS11 INS42 INS86 INS42 INS86 INS42 INS86 INS43 INS85 INS42 INS11 INS42 INS42 INS11 INS42 INS11 INS42 INS11 INS42 INS86 INS43 INS85 INS42 INS11 INS42 INS42 INS11 INS42 INS11 INS42 INS86 INS43 INS85 INS42 INS11 INS42 INS42 INS11 INS42 INS11 INS42 INS86 INS41 INS44 INS8 INS44 INS8 INS42 INS42 INS74 INS2 INS32 INS42 INS42 INS74 INS2 INS32 INS42 INS42 INS74 INS2 INS32 INS43 INS2 INS32 INS43 INS2 INS32 INS32 INS42 INS42 INS74 INS2 INS32 INS32 INS32 INS42 INS5 INS2 INS43 INS2 INS39 INS2 INS39 INS2 INS32 INS42 INS5 INS2 INS43 INS2 INS39 INS2 INS32 INS42 INS5 INS2 INS43 INS2 INS39 INS2 INS32 INS32 INS43 INS42 INS53 INS43 INS42 INS53 INS43 INS43 INS42 INS34 INS14 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS34 INS14 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS34 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS34 INS14 INS42 INS42 INS42 INS42 INS42 INS34 INS14 INS42 INS42 INS42 INS14 INS42 INS42 INS43 INS43 INS42 INS34 INS14 INS42 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS43 INS85 INS42 INS34 INS42 INS42 INS34 INS42 INS34 INS42 INS34 INS14 INS42 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS34 INS42 INS42 INS34 INS42 INS34 INS14 INS42 INS42 INS42 INS42 INS43 INS85 INS42 INS34 INS42 INS42 INS34 INS42 INS34 INS14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS42 INS43 INS42 INS42 INS42 INS43 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS43 INS42 INS43 INS42 INS43 INS42 INS42 INS43 INS42 INS42 INS43 INS42 INS42 INS43 INS42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42
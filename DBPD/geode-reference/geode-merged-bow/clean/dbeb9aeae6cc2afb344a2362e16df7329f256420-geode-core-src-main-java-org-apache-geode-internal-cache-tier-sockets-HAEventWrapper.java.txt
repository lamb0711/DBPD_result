Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This new class acts as a wrapper for the existing
- * <code>ClientUpdateMessageImpl</code>. Now, the <code>HARegionQueue</code>s
- * will contain instances of <code>HAEventWrapper</code> as value, instead
- * that of <code>ClientUpdateMessagesImpl</code>. It implements the
- * <code>Conflatable</code> interface to fit itself into the
- * <code>HARegionQueue</code> mechanics. It also has a property to indicate
- * the number of <code>HARegionQueue</code>s referencing this instance.
+ * This new class acts as a wrapper for the existing <code>ClientUpdateMessageImpl</code>. Now, the
+ * <code>HARegionQueue</code>s will contain instances of <code>HAEventWrapper</code> as value,
+ * instead that of <code>ClientUpdateMessagesImpl</code>. It implements the <code>Conflatable</code>
+ * interface to fit itself into the <code>HARegionQueue</code> mechanics. It also has a property to
+ * indicate the number of <code>HARegionQueue</code>s referencing this instance.
-   * The underlying map for all the ha region queues associated with a bridge
-   * server.
+   * The underlying map for all the ha region queues associated with a bridge server.
-   * Indicates the number of <code>HARegionQueue</code>s referencing
-   * <code>this</code> instance.
-   * All access should be done using rcUpdater.
+   * Indicates the number of <code>HARegionQueue</code>s referencing <code>this</code> instance. All
+   * access should be done using rcUpdater.
-  private static final AtomicLongFieldUpdater<HAEventWrapper> rcUpdater
-    = AtomicLongFieldUpdater.newUpdater(HAEventWrapper.class, "referenceCount");
-  
+  private static final AtomicLongFieldUpdater<HAEventWrapper> rcUpdater =
+      AtomicLongFieldUpdater.newUpdater(HAEventWrapper.class, "referenceCount");
+
-   * If true, the entry containing this HAEventWrapper instance will not be
-   * removed from the haContainer, even if the referenceCount value is zero.
+   * If true, the entry containing this HAEventWrapper instance will not be removed from the
+   * haContainer, even if the referenceCount value is zero.
-   * A value true indicates that this instance is not used in the
-   * <code>haContainer</code>. So any changes in this instance will not be
-   * visible to the <code>haContainer</code>.
+   * A value true indicates that this instance is not used in the <code>haContainer</code>. So any
+   * changes in this instance will not be visible to the <code>haContainer</code>.
-   * This will hold the CQ list while its ClientUpdateMessageImpl is overflown
-   * to disk, and reassign it back when it's faulted-in.
+   * This will hold the CQ list while its ClientUpdateMessageImpl is overflown to disk, and reassign
+   * it back when it's faulted-in.
-    rcUpdater.set(this,  0);
+    rcUpdater.set(this, 0);
-    this.clientCqs = ((ClientUpdateMessageImpl)event).getClientCqs();
+    this.clientCqs = ((ClientUpdateMessageImpl) event).getClientCqs();
-    this.clientUpdateMessage = new ClientUpdateMessageImpl(
-        EnumListenerEvent.AFTER_CREATE, new ClientProxyMembershipID(), eventId);
-    rcUpdater.set(this,  0);
+    this.clientUpdateMessage = new ClientUpdateMessageImpl(EnumListenerEvent.AFTER_CREATE,
+        new ClientProxyMembershipID(), eventId);
+    rcUpdater.set(this, 0);
-  public HAEventWrapper() {
-  }
+  public HAEventWrapper() {}
-   * Use this method <B>only</B> when put operation on HARegionQueue is in
-   * progress. It'll always return null otherwise.
+   * Use this method <B>only</B> when put operation on HARegionQueue is in progress. It'll always
+   * return null otherwise.
-   * This implementation considers only the EventID of
-   * <code>HAEventWrapper</code> for the equality test. It allows an instance
-   * of {@link EventID} to be tested for equality.
+   * This implementation considers only the EventID of <code>HAEventWrapper</code> for the equality
+   * test. It allows an instance of {@link EventID} to be tested for equality.
-   * @param other
-   *          The instance of HAEventWrapper or EventID to be tested for
-   *          equality.
+   * @param other The instance of HAEventWrapper or EventID to be tested for equality.
-   * @return boolean true if <code>this</code> object's event id matches with
-   *         that of other.
+   * @return boolean true if <code>this</code> object's event id matches with that of other.
-    return this == other
-        || this.getEventId().equals(((HAEventWrapper)other).getEventId());
+    return this == other || this.getEventId().equals(((HAEventWrapper) other).getEventId());
-      return "HAEventWrapper[refCount=" + getReferenceCount() + "; msg=" +
-      		this.clientUpdateMessage+"]";
+      return "HAEventWrapper[refCount=" + getReferenceCount() + "; msg=" + this.clientUpdateMessage
+          + "]";
-      return "HAEventWrapper[region=" + this.regionName
-        + "; key=" + this.keyOfInterest
-        + "; refCount=" + getReferenceCount()
-        + "; inContainer=" + this.isRefFromHAContainer
-        + "; putInProgress=" + this.putInProgress
-        + "; event=" + this.eventIdentifier
-        + ((this.clientUpdateMessage == null) ? "; no message" : ";with message")
-        + ((this.clientUpdateMessage == null) ? "" : ("; op=" + this.clientUpdateMessage.getOperation()))
-        + ((this.clientUpdateMessage == null) ? "" : ("; version=" + this.clientUpdateMessage.getVersionTag()))
-        + "]";
+      return "HAEventWrapper[region=" + this.regionName + "; key=" + this.keyOfInterest
+          + "; refCount=" + getReferenceCount() + "; inContainer=" + this.isRefFromHAContainer
+          + "; putInProgress=" + this.putInProgress + "; event=" + this.eventIdentifier
+          + ((this.clientUpdateMessage == null) ? "; no message" : ";with message")
+          + ((this.clientUpdateMessage == null) ? ""
+              : ("; op=" + this.clientUpdateMessage.getOperation()))
+          + ((this.clientUpdateMessage == null) ? ""
+              : ("; version=" + this.clientUpdateMessage.getVersionTag()))
+          + "]";
-   * Calls toData() on its clientUpdateMessage present in the
-   * haContainer (client-messages-region or the map).
+   * Calls toData() on its clientUpdateMessage present in the haContainer (client-messages-region or
+   * the map).
-   * @param out
-   *          The output stream which the object should be written to.
+   * @param out The output stream which the object should be written to.
-    ClientUpdateMessageImpl cum = (ClientUpdateMessageImpl)this.haContainer
-        .get(this);
+    ClientUpdateMessageImpl cum = (ClientUpdateMessageImpl) this.haContainer.get(this);
-    }
-    else {
+    } else {
-   * Calls fromData() on ClientUpdateMessage and sets it as its member variable.
-   * Also, sets the referenceCount to zero.
+   * Calls fromData() on ClientUpdateMessage and sets it as its member variable. Also, sets the
+   * referenceCount to zero.
-   * @param in
-   *          The input stream from which the object should be constructed.
+   * @param in The input stream from which the object should be constructed.
-      this.eventIdentifier = (EventID)DataSerializer.readObject(in);
+      this.eventIdentifier = (EventID) DataSerializer.readObject(in);
-      ((ClientUpdateMessageImpl)this.clientUpdateMessage)
-          .setEventIdentifier(this.eventIdentifier);
+      ((ClientUpdateMessageImpl) this.clientUpdateMessage).setEventIdentifier(this.eventIdentifier);
-                    throw new IllegalStateException("The value of a ConcurrentHashMap is not allowed to be null.");
+                    throw new IllegalStateException(
+                        "The value of a ConcurrentHashMap is not allowed to be null.");
-                  throw new IllegalStateException("The value of a ConcurrentHashMap is not allowed to be null.");
+                  throw new IllegalStateException(
+                      "The value of a ConcurrentHashMap is not allowed to be null.");
-                  throw new IllegalStateException("Expected DSCODE.NULL or DSCODE.HASH_MAP but read " + typeByte);
+                  throw new IllegalStateException(
+                      "Expected DSCODE.NULL or DSCODE.HASH_MAP but read " + typeByte);
-        ((ClientUpdateMessageImpl)this.clientUpdateMessage)
-            .setClientCqs(this.clientCqs);
+        ((ClientUpdateMessageImpl) this.clientUpdateMessage).setClientCqs(this.clientCqs);
-    }
-    else {
+    } else {
-        logger.debug("HAEventWrapper.fromData(): The event has already been sent to the client by the primary server.");
+        logger.debug(
+            "HAEventWrapper.fromData(): The event has already been sent to the client by the primary server.");
-  
+
-   * Returning zero as default size. This is because this method will be called
-   * only in case of ha-overflow, in which case, we ignore size of instances of
-   * <code>HAEventWrapper</code>, as they are never overflown to disk.
+   * Returning zero as default size. This is because this method will be called only in case of
+   * ha-overflow, in which case, we ignore size of instances of <code>HAEventWrapper</code>, as they
+   * are never overflown to disk.
-     return null;
+    return null;
-  
+
-  
+
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
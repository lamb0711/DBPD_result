GEODE-4734: cleanup tests for use as examples in Geode wiki (#1518)



-import java.util.concurrent.atomic.AtomicInteger;
-  private Host host;
+  private final Host host;
-    if (!this.available) {
-      this.available = true;
+    if (!available) {
+      available = true;
-  public static String getVMName(String version, int pid) {
+  public static String getVMName(final String version, final int pid) {
-  public VM(final Host host, int id, final RemoteDUnitVMIF client) {
+  public VM(final Host host, final int id, final RemoteDUnitVMIF client) {
-    this.available = true;
+    available = true;
-    return this.host;
+    return host;
-    return this.version;
+    return version;
-    return this.id;
+    return id;
-  public Object invoke(final Class targetClass, final String methodName) {
+  @Deprecated
+  public <V> V invoke(final Class<?> targetClass, final String methodName) {
-  public AsyncInvocation invokeAsync(final Class targetClass, final String methodName) {
+  @Deprecated
+  public <V> AsyncInvocation<V> invokeAsync(final Class<?> targetClass, final String methodName) {
-  public Object invoke(final Class targetClass, final String methodName, final Object[] args) {
-    if (!this.available) {
+  @Deprecated
+  public <V> V invoke(final Class<?> targetClass, final String methodName, final Object[] args) {
+    if (!available) {
-      return result.getResult();
+      return (V) result.getResult();
-  public AsyncInvocation invokeAsync(final Object targetObject, final String methodName,
+  @Deprecated
+  public <V> AsyncInvocation<V> invokeAsync(final Object targetObject, final String methodName,
-    return new AsyncInvocation(targetObject, methodName,
+    return new AsyncInvocation<V>(targetObject, methodName,
-  public AsyncInvocation invokeAsync(final Class<?> targetClass, final String methodName,
+  @Deprecated
+  public <V> AsyncInvocation<V> invokeAsync(final Class<?> targetClass, final String methodName,
-    return new AsyncInvocation(targetClass, methodName, () -> invoke(targetClass, methodName, args))
-        .start();
+    return new AsyncInvocation<V>(targetClass, methodName,
+        () -> invoke(targetClass, methodName, args)).start();
-  public AsyncInvocation invokeAsync(final SerializableRunnableIF runnable) {
+  public <V> AsyncInvocation<V> invokeAsync(final SerializableRunnableIF runnable) {
-  public AsyncInvocation invokeAsync(final String name, final SerializableRunnableIF runnable) {
+  public <V> AsyncInvocation<V> invokeAsync(final String name,
+      final SerializableRunnableIF runnable) {
-  public <T> AsyncInvocation<T> invokeAsync(final String name,
-      final SerializableCallableIF<T> callable) {
-    return invokeAsync(new NamedCallable(name, callable), "call", new Object[0]);
+  public <V> AsyncInvocation<V> invokeAsync(final String name,
+      final SerializableCallableIF<V> callable) {
+    return invokeAsync(new NamedCallable<>(name, callable), "call", new Object[0]);
-  public <T> AsyncInvocation<T> invokeAsync(final SerializableCallableIF<T> callable) {
+  public <V> AsyncInvocation<V> invokeAsync(final SerializableCallableIF<V> callable) {
-  public <T> T invoke(final String name, final SerializableCallableIF<T> callable) {
-    return (T) invoke(new NamedCallable(name, callable), "call");
+  public <V> V invoke(final String name, final SerializableCallableIF<V> callable) {
+    return invoke(new NamedCallable<>(name, callable), "call");
-  public <T> T invoke(final SerializableCallableIF<T> callable) {
-    return (T) invoke(callable, "call");
+  public <V> V invoke(final SerializableCallableIF<V> callable) {
+    return invoke(callable, "call");
+  @Deprecated
-  public Object invoke(final Object targetObject, final String methodName) {
+  @Deprecated
+  public <V> V invoke(final Object targetObject, final String methodName) {
-  public Object invoke(final Object targetObject, final String methodName, final Object[] args) {
-    if (!this.available) {
+  @Deprecated
+  public <V> V invoke(final Object targetObject, final String methodName, final Object[] args) {
+    if (!available) {
-      return result.getResult();
+      return (V) result.getResult();
-   * @throws RMIException if an exception occurs while bouncing this {@code VM}, for example a
-   *         {@code HydraTimeoutException} if the {@code VM} fails to stop within
-   *         {@code hydra.Prms#maxClientShutdownWaitSec} or restart within
-   *         {@code hydra.Prms#maxClientStartupWaitSec}.
+   * @throws RMIException if an exception occurs while bouncing this {@code VM}
-    bounce(this.version);
+    bounce(version);
-  public synchronized void bounce(String targetVersion) {
-    if (!this.available) {
+  public synchronized void bounce(final String targetVersion) {
+    if (!available) {
-    this.available = false;
+    available = false;
-      BounceResult result = DUnitEnv.get().bounce(targetVersion, this.id);
-      this.id = result.getNewId();
-      this.client = result.getNewClient();
-      this.version = targetVersion;
-      this.available = true;
+      BounceResult result = DUnitEnv.get().bounce(targetVersion, id);
+      id = result.getNewId();
+      client = result.getNewClient();
+      version = targetVersion;
+      available = true;
-      this.available = true;
+      available = true;
-      RMIException rmie =
-          new RMIException(this, getClass().getName(), "bounceVM", e, sw.toString());
-      throw rmie;
+      throw new RMIException(this, getClass().getName(), "bounceVM", e, sw.toString());
+  @Override
-  private MethExecutorResult execute(final Class targetClass, final String methodName,
+  private MethExecutorResult execute(final Class<?> targetClass, final String methodName,
-      return this.client.executeMethodOnClass(targetClass.getName(), methodName, args);
+      return client.executeMethodOnClass(targetClass.getName(), methodName, args);
-        return this.client.executeMethodOnObject(targetObject, methodName);
+        return client.executeMethodOnObject(targetObject, methodName);
-        return this.client.executeMethodOnObject(targetObject, methodName, args);
+        return client.executeMethodOnObject(targetObject, methodName, args);

INS83 INS78 INS73 UPD43 INS78 INS73 INS74 INS78 INS73 UPD43 INS78 INS73 INS74 INS78 INS73 INS74 INS73 INS74 INS73 INS74 UPD74 INS44 UPD74 MOV44 UPD43 INS44 INS8 UPD43 MOV44 INS78 INS78 INS73 UPD43 INS78 INS73 UPD43 INS78 INS83 INS83 INS83 INS42 INS42 UPD42 INS74 INS42 INS42 MOV43 INS43 INS74 INS42 INS42 UPD42 INS74 INS42 INS42 MOV43 INS43 INS42 INS42 MOV43 INS43 INS42 MOV43 INS43 INS42 INS43 INS43 UPD42 UPD43 INS83 INS74 INS42 UPD42 MOV43 UPD43 UPD74 UPD42 UPD42 INS83 INS74 INS42 INS41 UPD42 UPD42 UPD74 INS42 INS42 INS42 UPD42 INS42 INS42 UPD42 INS83 INS42 INS74 INS42 INS42 INS42 INS43 INS76 INS42 INS43 INS76 INS43 INS76 INS42 UPD42 MOV42 INS42 INS42 MOV42 INS42 UPD42 MOV43 INS43 UPD42 UPD43 MOV43 INS43 INS32 UPD43 MOV32 INS43 INS76 INS42 INS42 MOV42 MOV42 MOV42 INS42 INS42 UPD42 INS42 MOV42 MOV14 MOV45 UPD42 INS42 INS42 INS42 INS42 MOV42 INS11 INS74 INS74 INS74 INS74 INS11 INS42 INS43 MOV32 MOV43 INS43 MOV43 INS43 MOV43 MOV43 INS43 MOV32 INS42 INS42 INS42 INS42 MOV14 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL43 DEL43 DEL43 DEL52 DEL42 DEL22 DEL42 DEL43 DEL83 DEL42 DEL43 DEL74 DEL42 DEL44 DEL43 DEL32 DEL11 DEL41 DEL8 DEL83 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL11 DEL52 DEL42 DEL22 DEL66 DEL66 DEL65 DEL66 DEL66 DEL65 DEL66 DEL66 DEL65 DEL66 DEL66 DEL65 DEL66 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL43 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22
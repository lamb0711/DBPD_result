Merge branch 'release/1.0.0-incubating.M3'

-import java.lang.management.ManagementFactory;
-import java.lang.management.MemoryMXBean;
-import java.lang.management.MemoryPoolMXBean;
-import java.lang.management.MemoryType;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.Executors;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
-
-import javax.management.ListenerNotFoundException;
-import javax.management.Notification;
-import javax.management.NotificationEmitter;
-import javax.management.NotificationListener;
-
-import org.apache.logging.log4j.Logger;
-
+import com.gemstone.gemfire.distributed.internal.DistributionConfig;
+import org.apache.logging.log4j.Logger;
+
+import javax.management.ListenerNotFoundException;
+import javax.management.Notification;
+import javax.management.NotificationEmitter;
+import javax.management.NotificationListener;
+import java.lang.management.ManagementFactory;
+import java.lang.management.MemoryMXBean;
+import java.lang.management.MemoryPoolMXBean;
+import java.lang.management.MemoryType;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.*;
- * @since 9.0
+ * @since Geode 1.0
-  private static final String HEAP_POOL = System.getProperty("gemfire.ResourceManager.HEAP_POOL");
+  private static final String HEAP_POOL = System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "ResourceManager.HEAP_POOL");
-  public static final String POLLER_INTERVAL_PROP = "gemfire.heapPollerInterval";
+  public static final String POLLER_INTERVAL_PROP = DistributionConfig.GEMFIRE_PREFIX + "heapPollerInterval";
-  
-  private volatile MemoryThresholds thresholds = new MemoryThresholds(tenuredPoolMaxMemory);
-  private volatile MemoryEvent mostRecentEvent = new MemoryEvent(ResourceType.HEAP_MEMORY, MemoryState.DISABLED,
-      MemoryState.DISABLED, null, 0L, true, this.thresholds);
-  private volatile MemoryState currentState = MemoryState.DISABLED;
-
-  //Set when startMonitoring() and stopMonitoring() are called
-  private Boolean started = false;
-  
-  // Set to true when setEvictionThreshold(...) is called.
-  private boolean hasEvictionThreshold = false;
-  
-   // Only change state when these counters exceed {@link HeapMemoryMonitor#memoryStateChangeTolerance}
-  private int criticalToleranceCounter;
-  private int evictionToleranceCounter;
-  
-  private final InternalResourceManager resourceManager;
-  private final ResourceAdvisor resourceAdvisor;
-  private final GemFireCacheImpl cache;
-  private final ResourceManagerStats stats;
-  
-  private static boolean testDisableMemoryUpdates = false;
-  private static long testBytesUsedForThresholdSet = -1;
-      memoryStateChangeTolerance = Integer.getInteger("gemfire.memoryEventTolerance",1);
+      memoryStateChangeTolerance = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "memoryEventTolerance", 1);
-      memoryStateChangeTolerance = Integer.getInteger("gemfire.memoryEventTolerance",5);
+      memoryStateChangeTolerance = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "memoryEventTolerance", 5);
-    
+
-  
- // Calculated value for the amount of JVM tenured heap memory available.
- private static final long tenuredPoolMaxMemory;
+  // Calculated value for the amount of JVM tenured heap memory available.
+  private static final long tenuredPoolMaxMemory;
- static {
-   if (tenuredMemoryPoolMXBean != null && tenuredMemoryPoolMXBean.getUsage().getMax() != -1) {
-     tenuredPoolMaxMemory = tenuredMemoryPoolMXBean.getUsage().getMax();
-   } else {
-     long calculatedMaxMemory = Runtime.getRuntime().maxMemory();
-     List<MemoryPoolMXBean> pools = ManagementFactory.getMemoryPoolMXBeans();
-     for (MemoryPoolMXBean p : pools) {
-       if (p.getType() == MemoryType.HEAP && p.getUsage().getMax() != -1) {
-         calculatedMaxMemory -= p.getUsage().getMax();
-       }
-     }
-     tenuredPoolMaxMemory = calculatedMaxMemory;
-   }
- }
+  static {
+    if (tenuredMemoryPoolMXBean != null && tenuredMemoryPoolMXBean.getUsage().getMax() != -1) {
+      tenuredPoolMaxMemory = tenuredMemoryPoolMXBean.getUsage().getMax();
+    } else {
+      long calculatedMaxMemory = Runtime.getRuntime().maxMemory();
+      List<MemoryPoolMXBean> pools = ManagementFactory.getMemoryPoolMXBeans();
+      for (MemoryPoolMXBean p : pools) {
+        if (p.getType() == MemoryType.HEAP && p.getUsage().getMax() != -1) {
+          calculatedMaxMemory -= p.getUsage().getMax();
+        }
+      }
+      tenuredPoolMaxMemory = calculatedMaxMemory;
+    }
+  }
+
+  private volatile MemoryThresholds thresholds = new MemoryThresholds(tenuredPoolMaxMemory);
+  private volatile MemoryEvent mostRecentEvent = new MemoryEvent(ResourceType.HEAP_MEMORY, MemoryState.DISABLED,
+      MemoryState.DISABLED, null, 0L, true, this.thresholds);
+  private volatile MemoryState currentState = MemoryState.DISABLED;
+
+  //Set when startMonitoring() and stopMonitoring() are called
+  private Boolean started = false;
+
+  // Set to true when setEvictionThreshold(...) is called.
+  private boolean hasEvictionThreshold = false;
+
+  // Only change state when these counters exceed {@link HeapMemoryMonitor#memoryStateChangeTolerance}
+  private int criticalToleranceCounter;
+  private int evictionToleranceCounter;
+
+  private final InternalResourceManager resourceManager;
+  private final ResourceAdvisor resourceAdvisor;
+  private final GemFireCacheImpl cache;
+  private final ResourceManagerStats stats;
+
+  private static boolean testDisableMemoryUpdates = false;
+  private static long testBytesUsedForThresholdSet = -1;
+
+
+
+
+
-      synchronized (list) {
-        for (Object o : list) {
-          if (o instanceof StatisticsImpl) {
-            StatisticsImpl si = (StatisticsImpl) o;
-            if (si.getTextId().contains(tenuredPoolName) && si.getType().getName().contains("PoolStats")) {
-              sampler.addLocalStatListener(this.statListener, si, "currentUsedMemory");
-              if (this.cache.getLoggerI18n().fineEnabled()) {
-                this.cache.getLoggerI18n().fine("Registered stat listener for " + si.getTextId());
-              }
-
-              return true;
+      for (Object o : list) {
+        if (o instanceof StatisticsImpl) {
+          StatisticsImpl si = (StatisticsImpl) o;
+          if (si.getTextId().contains(tenuredPoolName) && si.getType().getName().contains("PoolStats")) {
+            sampler.addLocalStatListener(this.statListener, si, "currentUsedMemory");
+            if (this.cache.getLoggerI18n().fineEnabled()) {
+              this.cache.getLoggerI18n().fine("Registered stat listener for " + si.getTextId());
+
+            return true;

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV23 MOV28 MOV23 MOV28 MOV23 MOV28 UPD40 UPD40 MOV8 UPD66 INS27 MOV60 MOV25 INS54 MOV41 INS27 INS40 INS45 MOV8 MOV12 INS40 INS45 MOV21 MOV60 MOV60 INS27 INS27 INS40 INS45 INS40 INS45 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL45 DEL45 DEL45 DEL45 DEL42 DEL51 DEL54 DEL8
GEODE-4176 locator creates "locator0view.dat" file when started with port 0

Modified the locator to ensure that the wildcard bind has occurred before
GMSLocator creates its persistent view file.  I also did some code
cleanup and addressed GEODE-1243.

This closes #1214

-   * locator state file
-   */
-  private File stateFile;
-
-  /**
-  // TODO: return value of removeLocator is never used
-  private static boolean removeLocator(InternalLocator locator) {
+  private static void removeLocator(InternalLocator locator) {
-      return false;
+      return;
-      if (locator != null && locator.equals(InternalLocator.locator)) {
+      if (locator.equals(InternalLocator.locator)) {
-        return true;
-      return false;
-   * @param stateFile the file that state should be read from / written to for recovery
-  public static InternalLocator createLocator(int port, File logFile, File stateFile,
-      InternalLogWriter logger, InternalLogWriter securityLogger, InetAddress bindAddress,
-      String hostnameForClients, Properties distributedSystemProperties,
-      boolean startDistributedSystem) {
+  public static InternalLocator createLocator(int port, File logFile, InternalLogWriter logger,
+      InternalLogWriter securityLogger, InetAddress bindAddress, String hostnameForClients,
+      Properties distributedSystemProperties, boolean startDistributedSystem) {
-          new InternalLocator(port, logFile, stateFile, logger, securityLogger, bindAddress,
+          new InternalLocator(port, logFile, logger, securityLogger, bindAddress,
-  public static InternalLocator startLocator(int port, File logFile, File stateFile,
-      InternalLogWriter logger, InternalLogWriter securityLogger, InetAddress bindAddress,
-      boolean startDistributedSystem, Properties dsProperties, String hostnameForClients)
-      throws IOException {
+  public static InternalLocator startLocator(int port, File logFile, InternalLogWriter logger,
+      InternalLogWriter securityLogger, InetAddress bindAddress, boolean startDistributedSystem,
+      Properties dsProperties, String hostnameForClients) throws IOException {
-      newLocator = createLocator(port, logFile, stateFile, logger, securityLogger, bindAddress,
+      newLocator = createLocator(port, logFile, logger, securityLogger, bindAddress,
-      // TODO:GEODE-1243: this.server is now a TcpServer and it should store or return its non-zero
-      // port in a variable to use here
-        newLocator.startPeerLocation(startDistributedSystem);
+        newLocator.startPeerLocation();
+
-            // TODO:GEODE-1243: throws Exception if TcpServer still has zero for its locator port
-   * @param stateF the file that state should be read from / written to for recovery
-  private InternalLocator(int port, File logF, File stateF, InternalLogWriter logWriter,
+  private InternalLocator(int port, File logF, InternalLogWriter logWriter,
-    if (stateF == null) {
-      this.stateFile = new File("locator" + port + "view.dat");
-    } else {
-      this.stateFile = stateF;
-    }
-    File productUseFile = new File("locator" + port + "views.log");
-    this.productUseLog = new ProductUseLog(productUseFile);
-  // Reset the file names with the correct port number if startLocatorAndDS was called with port
-  // number 0
-  public void resetInternalLocatorFileNamesWithCorrectPortNumber(int port) {
-    this.stateFile = new File("locator" + port + "view.dat");
-    File productUseFile = new File("locator" + port + "views.log");
-    this.productUseLog = new ProductUseLog(productUseFile);
-  }
-
-   * <p>
-   * TODO: parameter withDS is never used
-   * @param withDS true if a distributed system has been or will be started
-   *
+   * @return returns the port that the locator to which the locator is bound
-  void startPeerLocation(boolean withDS) throws IOException {
+  int startPeerLocation() throws IOException {
-    boolean locatorsAreCoordinators = false;
+    boolean locatorsAreCoordinators;
-    this.locatorImpl = MemberFactory.newLocatorHandler(this.bindAddress, this.stateFile,
-        locatorsProp, locatorsAreCoordinators, networkPartitionDetectionEnabled, this.stats,
-        securityUDPDHAlgo);
+    this.locatorImpl = MemberFactory.newLocatorHandler(this.bindAddress, locatorsProp,
+        locatorsAreCoordinators, networkPartitionDetectionEnabled, this.stats, securityUDPDHAlgo);
+    int boundPort = this.server.getPort();
+    File productUseFile = new File("locator" + boundPort + "views.log");
+    productUseLog = new ProductUseLog(productUseFile);
+
+    return boundPort;
-  public PrimaryHandler getPrimaryHandler() {
-    return this.handler;
-  }
-
-  public static InternalLocator startLocator(int locatorPort, File logFile, File stateFile,
+  public static InternalLocator startLocator(int locatorPort, File logFile,
-    return startLocator(locatorPort, logFile, stateFile, logger, logger1, addr, true, dsProperties,
-        s);
+    return startLocator(locatorPort, logFile, logger, logger1, addr, true, dsProperties, s);
-    this.productUseLog.monitorUse(distributedSystem);
-
+    // the product use is not guaranteed to be initialized until the server is started, so
+    // the last thing we do is tell it to start logging
+    this.productUseLog.monitorUse(distributedSystem);
-    this.productUseLog.close();
+    if (this.productUseLog != null) {
+      this.productUseLog.close();
+    }
-      // TODO: this for-loop is probably not necessary as the if to break is always true
-      for (int i = 0; i < MAX_RETRIES; i++) {
-        if (locator.sharedConfig != null) {
-          SharedConfigurationStatus status = locator.sharedConfig.getStatus();
-          if (status != SharedConfigurationStatus.STARTED
-              || status != SharedConfigurationStatus.NOT_STARTED) {
-            break;
-          }
-        }
-        Thread.sleep(SLEEPTIME);
-      }
+
-      if (this.locator.sharedConfig == null) {
+      if (locator.sharedConfig == null) {
-        this.locator.sharedConfig = new ClusterConfigurationService(locator.myCache);
+        locator.sharedConfig = new ClusterConfigurationService(locator.myCache);
-      this.locator.sharedConfig.initSharedConfiguration(this.locator.loadFromSharedConfigDir());
+      locator.sharedConfig.initSharedConfiguration(locator.loadFromSharedConfigDir());

UPD39 UPD39 MOV21 UPD65 INS60 INS60 MOV21 INS41 INS25 UPD66 INS39 INS59 MOV43 INS59 INS42 INS27 INS8 INS42 INS32 INS42 INS14 INS42 MOV22 INS33 MOV21 MOV32 MOV43 INS22 INS42 MOV43 INS27 INS52 INS42 INS45 INS42 INS45 INS40 INS40 MOV43 INS42 INS40 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL9 DEL42 DEL33 DEL27 DEL27 DEL9 DEL41 DEL9 DEL41 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL52 DEL42 DEL22 DEL42 DEL43 DEL45 DEL42 DEL45 DEL27 DEL14 DEL7 DEL21 DEL8 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL45 DEL42 DEL45 DEL27 DEL14 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL14 DEL7 DEL21 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL43 DEL45 DEL42 DEL45 DEL27 DEL14 DEL7 DEL21 DEL42 DEL45 DEL42 DEL45 DEL27 DEL14 DEL59 DEL60 DEL8 DEL31 DEL66 DEL66 DEL42 DEL39 DEL42 DEL44 DEL9 DEL52 DEL42 DEL22 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL44 DEL42 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL27 DEL42 DEL37 DEL40 DEL33 DEL27 DEL42 DEL43 DEL42 DEL40 DEL42 DEL32 DEL59 DEL60 DEL42 DEL40 DEL27 DEL42 DEL40 DEL27 DEL27 DEL10 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL24 DEL52 DEL42 DEL22 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL22 DEL52 DEL42 DEL22
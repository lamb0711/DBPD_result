Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- *  AbstractLRUClockHand holds the lrulist, and the behavior for
- *  maintaining the list in a cu-pipe and determining the next entry to be removed.
- *  Each EntriesMap that supports LRU holds one of these.
+ * AbstractLRUClockHand holds the lrulist, and the behavior for maintaining the list in a cu-pipe
+ * and determining the next entry to be removed. Each EntriesMap that supports LRU holds one of
+ * these.
-public class NewLRUClockHand  {
+public class NewLRUClockHand {
-  
+
-  /**  The last node in the LRU list after which all new nodes are added */
+  /** The last node in the LRU list after which all new nodes are added */
-  /**  The starting point in the LRU list for searching for the LRU node */
+  /** The starting point in the LRU list for searching for the LRU node */
-  
+
-  /**  Description of the Field */
+  /** Description of the Field */
-  public static final boolean debug = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "verbose-lru-clock");
+  public static final boolean debug =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "verbose-lru-clock");
-static private final int maxEntries;
+  static private final int maxEntries;
-static {
-  String squelch = System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "lru.maxSearchEntries");
-  if (squelch == null)
-    maxEntries = -1;
-  else
-    maxEntries = Integer.parseInt(squelch);
-}
+  static {
+    String squelch = System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "lru.maxSearchEntries");
+    if (squelch == null)
+      maxEntries = -1;
+    else
+      maxEntries = Integer.parseInt(squelch);
+  }
-  
-//   private long size = 0;
-public NewLRUClockHand(Object region, EnableLRU ccHelper,
+  // private long size = 0;
+
+  public NewLRUClockHand(Object region, EnableLRU ccHelper,
-     // behavior relies on a single evicted node in the pipe when the pipe is empty.
+    // behavior relies on a single evicted node in the pipe when the pipe is empty.
-      this.stats = internalRegionArgs.getPartitionedRegion() != null ? internalRegionArgs
-          .getPartitionedRegion().getEvictionController().stats
-          : null;
-    }
-    else {
+      this.stats = internalRegionArgs.getPartitionedRegion() != null
+          ? internalRegionArgs.getPartitionedRegion().getEvictionController().stats : null;
+    } else {
-        tmp = ((PlaceHolderDiskRegion)region).getPRLRUStats();
+        tmp = ((PlaceHolderDiskRegion) region).getPRLRUStats();
-        tmp = ((PartitionedRegion)region).getPRLRUStatsDuringInitialization(); // bug 41938
-        PartitionedRegion pr = (PartitionedRegion)region;
+        tmp = ((PartitionedRegion) region).getPRLRUStatsDuringInitialization(); // bug 41938
+        PartitionedRegion pr = (PartitionedRegion) region;
-      this.bucketRegion = (BucketRegion)r; // see bug 41388
+      this.bucketRegion = (BucketRegion) r; // see bug 41388
- 
-  public NewLRUClockHand( Region region, EnableLRU ccHelper, NewLRUClockHand oldList) {
+
+  public NewLRUClockHand(Region region, EnableLRU ccHelper, NewLRUClockHand oldList) {
-     // behavior relies on a single evicted node in the pipe when the pipe is empty.
+    // behavior relies on a single evicted node in the pipe when the pipe is empty.
-      }
-      else {
+      } else {
-  
-  /**  Description of the Method */
+
+  /** Description of the Method */
-    if(bucketRegion!=null)
+    if (bucketRegion != null)
-    if( ls != null ) {
+    if (ls != null) {
-   *  Adds a new lru node for the entry between the current tail and head
-   *  of the list.
+   * Adds a new lru node for the entry between the current tail and head of the list.
-   * @param  aNode  Description of the Parameter
-   */  
-  public final void appendEntry( final LRUClockNode aNode ) {
+   * @param aNode Description of the Parameter
+   */
+  public final void appendEntry(final LRUClockNode aNode) {
-        logger.trace(LogMarker.LRU_CLOCK, LocalizedMessage.create(LocalizedStrings.NewLRUClockHand_ADDING_ANODE_TO_LRU_LIST, aNode));
+        logger.trace(LogMarker.LRU_CLOCK, LocalizedMessage
+            .create(LocalizedStrings.NewLRUClockHand_ADDING_ANODE_TO_LRU_LIST, aNode));
-      
+
-  /** return the head entry in the list preserving the cupipe requirement of at
-   * least one entry left in the list 
+  /**
+   * return the head entry in the list preserving the cupipe requirement of at least one entry left
+   * in the list
-      if(aNode == this.tail) {
+      if (aNode == this.tail) {
-      
+
-      
+
-  
-  /** return the Entry that is considered least recently used. The entry will no longer
-    * be in the pipe (unless it is the last empty marker).
-    */
+
+  /**
+   * return the Entry that is considered least recently used. The entry will no longer be in the
+   * pipe (unless it is the last empty marker).
+   */
-    
+
-	LRUClockNode aNode = null;
-	aNode = getHeadEntry();
+      LRUClockNode aNode = null;
+      aNode = getHeadEntry();
-        if (logger.isTraceEnabled(LogMarker.LRU_CLOCK)) {
-	  logger.trace(LogMarker.LRU_CLOCK, "lru considering {}", aNode);
-	}
+      if (logger.isTraceEnabled(LogMarker.LRU_CLOCK)) {
+        logger.trace(LogMarker.LRU_CLOCK, "lru considering {}", aNode);
+      }
-      if ( aNode == null ) { // hit the end of the list
+      if (aNode == null) { // hit the end of the list
-        if (((AbstractRegionEntry) aNode).isInUseByTransaction()) {
-          if (logger.isTraceEnabled(LogMarker.LRU_CLOCK)) {
-            logger.trace(LogMarker.LRU_CLOCK, LocalizedMessage.create(LocalizedStrings.NewLRUClockHand_REMOVING_TRANSACTIONAL_ENTRY_FROM_CONSIDERATION));
+          if (((AbstractRegionEntry) aNode).isInUseByTransaction()) {
+            if (logger.isTraceEnabled(LogMarker.LRU_CLOCK)) {
+              logger.trace(LogMarker.LRU_CLOCK, LocalizedMessage.create(
+                  LocalizedStrings.NewLRUClockHand_REMOVING_TRANSACTIONAL_ENTRY_FROM_CONSIDERATION));
+            }
+            continue;
-          continue;
-        }
-            logger.trace(LogMarker.LRU_CLOCK, LocalizedMessage.create(LocalizedStrings.NewLRUClockHand_DISCARDING_EVICTED_ENTRY));
+            logger.trace(LogMarker.LRU_CLOCK,
+                LocalizedMessage.create(LocalizedStrings.NewLRUClockHand_DISCARDING_EVICTED_ENTRY));
-        
-        // At this point we have any acceptable entry.  Now
+
+        // At this point we have any acceptable entry. Now
-            logger.trace(LogMarker.LRU_CLOCK, LocalizedMessage.create(LocalizedStrings.NewLRUClockHand_GREEDILY_PICKING_AN_AVAILABLE_ENTRY));
+            logger.trace(LogMarker.LRU_CLOCK, LocalizedMessage
+                .create(LocalizedStrings.NewLRUClockHand_GREEDILY_PICKING_AN_AVAILABLE_ENTRY));
-          // fall through, return this node           
-        }
-        else
-        if ( aNode.testRecentlyUsed()) {
+          // fall through, return this node
+        } else if (aNode.testRecentlyUsed()) {
-            logger.trace(LogMarker.LRU_CLOCK, LocalizedMessage.create(LocalizedStrings.NewLRUClockHand_SKIPPING_RECENTLY_USED_ENTRY, aNode));
+            logger.trace(LogMarker.LRU_CLOCK, LocalizedMessage
+                .create(LocalizedStrings.NewLRUClockHand_SKIPPING_RECENTLY_USED_ENTRY, aNode));
-        }
-        else {
+        } else {
-            logger.trace(LogMarker.LRU_CLOCK, LocalizedMessage.create(LocalizedStrings.NewLRUClockHand_RETURNING_UNUSED_ENTRY, aNode));
+            logger.trace(LogMarker.LRU_CLOCK, LocalizedMessage
+                .create(LocalizedStrings.NewLRUClockHand_RETURNING_UNUSED_ENTRY, aNode));
-      int idx=1;
-      for (LRUClockNode aNode = this.head; aNode != null; aNode = aNode.nextLRUNode())  {
+      int idx = 1;
+      for (LRUClockNode aNode = this.head; aNode != null; aNode = aNode.nextLRUNode()) {
-  
+
-      for (LRUClockNode aNode = this.head.nextLRUNode(); aNode != this.tail; aNode = aNode.nextLRUNode()) {
+      for (LRUClockNode aNode = this.head.nextLRUNode(); aNode != this.tail; aNode =
+          aNode.nextLRUNode()) {
-  
-  public String getAuditReport( ) {
+
+  public String getAuditReport() {
-    while( h != null ) {
+    while (h != null) {
-      if ( h.testEvicted() ) evictedNodes++;
-      if ( h.testRecentlyUsed() ) usedNodes++;
+      if (h.testEvicted())
+        evictedNodes++;
+      if (h.testRecentlyUsed())
+        usedNodes++;
-    result.append("LRUList Audit: listEntries = ")
-      .append(totalNodes)      
-      .append(" evicted = ")
-      .append(evictedNodes)
-      .append(" used = ")
-      .append(usedNodes);
+    result.append("LRUList Audit: listEntries = ").append(totalNodes).append(" evicted = ")
+        .append(evictedNodes).append(" used = ").append(usedNodes);
-  public void audit( ) {
+  public void audit() {
-  
+
-      logger.trace(LogMarker.LRU_CLOCK, LocalizedMessage.create(LocalizedStrings.NewLRUClockHand_UNLINKENTRY_CALLED, entry));
+      logger.trace(LogMarker.LRU_CLOCK,
+          LocalizedMessage.create(LocalizedStrings.NewLRUClockHand_UNLINKENTRY_CALLED, entry));
-    synchronized(lock) {
+    synchronized (lock) {
-      if(next == null || prev == null) {
-        //not in the list anymore.
+      if (next == null || prev == null) {
+        // not in the list anymore.
-  
+
-   *  Get the modifier for lru based statistics.
+   * Get the modifier for lru based statistics.
-   * @return    The LRUStatistics for this Clock hand's region.
+   * @return The LRUStatistics for this Clock hand's region.
-    return this.stats; 
-  }  /**
+    return this.stats;
+  }
+
+  /**
-    synchronized  (this.lock ) {
-      if (bucketRegion!=null) {
+    synchronized (this.lock) {
+      if (bucketRegion != null) {
-      }
-      else {
+      } else {
-      //      LRUClockNode node = this.tail;
-      //      node.setEvicted();
-      //      
-      //      // NYI need to walk the list and call unsetInList for each one.
-      //      
-      //      // tail's next should already be null.
-      //      setHead( node );
+      // LRUClockNode node = this.tail;
+      // node.setEvicted();
+      //
+      // // NYI need to walk the list and call unsetInList for each one.
+      //
+      // // tail's next should already be null.
+      // setHead( node );
-    //I'm not sure, but I think it's important that we 
-    //drop the references to the old head and tail on a region clear
-    //That will prevent any concurrent operations that are messing
-    //with existing nodes from screwing up the head and tail after
-    //the clear.
-    //Dan 9/23/09
+    // I'm not sure, but I think it's important that we
+    // drop the references to the old head and tail on a region clear
+    // That will prevent any concurrent operations that are messing
+    // with existing nodes from screwing up the head and tail after
+    // the clear.
+    // Dan 9/23/09
-  
-    /**
-     * Get size of LRU queue
-     *
-     * @return size
-     */
-    public int size() {
-        return size;
-    }
+
+  /**
+   * Get size of LRU queue
+   *
+   * @return size
+   */
+  public int size() {
+    return size;
+  }
-//  private void internalClear() {
-//    stats().resetCounter();
-//    LRUClockNode node = this.tail;
-//    node.setEvicted();
-//
-//    // NYI need to walk the list and call unsetInList for each one.
-//    
-//    // tail's next should already be null.
-//    setHead( node );
-//  }
+  // private void internalClear() {
+  // stats().resetCounter();
+  // LRUClockNode node = this.tail;
+  // node.setEvicted();
+  //
+  // // NYI need to walk the list and call unsetInList for each one.
+  //
+  // // tail's next should already be null.
+  // setHead( node );
+  // }
-  protected static class HeadLock extends Object  { }
-  
+  protected static class HeadLock extends Object {
+  }
+
-      
+
-    public void setRecentlyUsed() {
-    }
+    public void setRecentlyUsed() {}
-    public void unsetEvicted() {
-    }
+    public void unsetEvicted() {}
-    public void unsetRecentlyUsed() {
-    }
+    public void unsetRecentlyUsed() {}
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66
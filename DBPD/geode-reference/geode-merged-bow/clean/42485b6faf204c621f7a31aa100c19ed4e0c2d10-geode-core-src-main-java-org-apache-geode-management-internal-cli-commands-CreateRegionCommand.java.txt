GEODE-4625: rework name collision check logic and add more tests (#1505)

* GEODE-4625: rework name collision check logic and add more tests

-      @CliOption(key = CliStrings.CREATE_REGION__SKIPIFEXISTS, specifiedDefaultValue = "true",
-          unspecifiedDefaultValue = "false",
-          help = CliStrings.CREATE_REGION__SKIPIFEXISTS__HELP) boolean skipIfExists,
-      @CliOption(key = CliStrings.IFNOTEXISTS, specifiedDefaultValue = "true",
-          unspecifiedDefaultValue = "false",
+      @CliOption(key = {CliStrings.IFNOTEXISTS, CliStrings.CREATE_REGION__SKIPIFEXISTS},
+          specifiedDefaultValue = "true", unspecifiedDefaultValue = "false",
-    // adding name collision check for regions created with regionShortcut only
+    /*
+     * Adding name collision check for regions created with regionShortcut only.
+     * Regions can be categories as Proxy(replicate/partition), replicate/partition, and local
+     * For concise purpose: we call existing region (E) and region to be created (C)
+     */
-      // when creating a non-proxy region and there is already a non empty node
-      if (!regionShortcut.isProxy() && regionBean.getMemberCount() > regionBean.getEmptyNodes()) {
+      String existingDataPolicy = regionBean.getRegionType();
+      // either C is local, or E is local or E and C are both non-proxy regions. this is to make
+      // sure local, replicate or partition regions have unique names across the entire cluster
+      if (regionShortcut.isLocal() || existingDataPolicy.equals("NORMAL")
+          || !regionShortcut.isProxy()
+              && (regionBean.getMemberCount() > regionBean.getEmptyNodes())) {
-      // proxy regions can only be created on members not having this regionName already defined
-      if (regionShortcut.isProxy()) {
-        Set<String> membersWithThisRegion =
-            Arrays.stream(regionBean.getMembers()).collect(Collectors.toSet());
-        Set<String> membersWithinGroup = findMembers(groups, null).stream()
-            .map(DistributedMember::getName).collect(Collectors.toSet());
-        if (!Collections.disjoint(membersWithinGroup, membersWithThisRegion)) {
-          throw new EntityExistsException(String.format(
-              "Region %s already exists on these members: %s. You can only create "
-                  + "proxy regions with the same name on other members.",
-              regionPath, StringUtils.join(membersWithThisRegion, ",")), ifNotExists);
-        }
-      }
+      // after this, one of E and C is proxy region or both are proxy regions.
-      // then check if the existing region's data policy is compatible
-      if (regionShortcut.isPartition() && !regionBean.getRegionType().contains("PARTITION")) {
+      // we first make sure E and C have the compatible data policy
+      if (regionShortcut.isPartition() && !existingDataPolicy.contains("PARTITION")) {
-      if (regionShortcut.isReplicate() && !(regionBean.getRegionType().equals("EMPTY")
-          || regionBean.getRegionType().contains("REPLICATE"))) {
+      if (regionShortcut.isReplicate()
+          && !(existingDataPolicy.equals("EMPTY") || existingDataPolicy.contains("REPLICATE")
+              || existingDataPolicy.contains("PRELOADED"))) {
+      // then we make sure E and C are on different members
+      Set<String> membersWithThisRegion =
+          Arrays.stream(regionBean.getMembers()).collect(Collectors.toSet());
+      Set<String> membersWithinGroup = findMembers(groups, null).stream()
+          .map(DistributedMember::getName).collect(Collectors.toSet());
+      if (!Collections.disjoint(membersWithinGroup, membersWithThisRegion)) {
+        throw new EntityExistsException(
+            String.format("Region %s already exists on these members: %s.", regionPath,
+                StringUtils.join(membersWithThisRegion, ",")),
+            ifNotExists);
+      }
-    functionArgs.setIfNotExists(ifNotExists || skipIfExists);
+    functionArgs.setIfNotExists(ifNotExists);

MOV25 MOV27 INS4 INS60 MOV25 INS25 INS25 INS42 INS40 INS40 INS43 INS59 INS27 INS27 MOV8 INS27 MOV8 INS42 INS42 MOV32 INS32 INS32 MOV27 MOV32 INS38 MOV32 INS38 INS42 INS42 INS42 INS42 INS45 INS36 INS32 INS36 MOV27 INS42 INS42 INS45 INS27 INS32 INS32 INS32 INS45 INS42 INS42 INS45 INS42 INS42 INS45 INS42 INS42 INS45 DEL42 DEL42 DEL40 DEL80 DEL42 DEL45 DEL80 DEL42 DEL45 DEL80 DEL42 DEL40 DEL80 DEL77 DEL39 DEL42 DEL44 DEL40 DEL42 DEL42 DEL32 DEL45 DEL45 DEL27 DEL42 DEL45 DEL32 DEL38 DEL27 DEL25 DEL42 DEL42 DEL32 DEL42 DEL45 DEL32 DEL42 DEL42 DEL32 DEL42 DEL45 DEL32 DEL27 DEL36 DEL38 DEL27 DEL25 DEL8 DEL25 DEL42 DEL42 DEL27
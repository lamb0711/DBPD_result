Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class manages the state an logic to backup a single
- * cache.
+ * This class manages the state an logic to backup a single cache.
-  //TODO prpersist internationalize this.
+  // TODO prpersist internationalize this.
-  public  static final String DATA_STORES = "diskstores";
+  public static final String DATA_STORES = "diskstores";
-  public BackupManager(InternalDistributedMember sender,
-      GemFireCacheImpl gemFireCache) {
+  public BackupManager(InternalDistributedMember sender, GemFireCacheImpl gemFireCache) {
-    this.cache =gemFireCache;
+    this.cache = gemFireCache;
-  
+
-    //We need to watch for pure admin guys that depart. this allMembershipListener set
-    //looks like it should receive those events.
+    // We need to watch for pure admin guys that depart. this allMembershipListener set
+    // looks like it should receive those events.
-    if(!allIds.contains(sender)) {
+    if (!allIds.contains(sender)) {
-    for(DiskStoreImpl store : diskStores) {
+    for (DiskStoreImpl store : diskStores) {
-  
+
-    for(DiskStoreImpl store : diskStores) {
+    for (DiskStoreImpl store : diskStores) {
-      if(store.hasPersistedData()) {
+      if (store.hasPersistedData()) {
-   * Returns the memberId directory for this member in the baseline.  The memberId may have changed if this
-   * member has been restarted since the last backup.
+   * Returns the memberId directory for this member in the baseline. The memberId may have changed
+   * if this member has been restarted since the last backup.
+   * 
-    for(DiskStoreImpl diskStore : cache.listDiskStoresIncludingRegionOwned()) {
+    for (DiskStoreImpl diskStore : cache.listDiskStoresIncludingRegionOwned()) {
-      if(null != baselineDir) {
+      if (null != baselineDir) {
-    
+
-     * We found it? Good. Set this member's baseline to the backed up disk store's member dir (two levels up).
+     * We found it? Good. Set this member's baseline to the backed up disk store's member dir (two
+     * levels up).
-    if(null != baselineDir) {
+    if (null != baselineDir) {
-    
+
-   * Performs a sanity check on the baseline directory for incremental backups. If a baseline directory
-   * exists for the member and there is no INCOMPLETE_BACKUP file then return the data stores directory
-   * for this member.
-   * @param baselineParentDir a previous backup directory.  This is used with the incremental backup option.  May be null if the user specified a full backup.
-   * @return null if the backup is to be a full backup otherwise return the data store directory in the previous backup for this member (if incremental).
+   * Performs a sanity check on the baseline directory for incremental backups. If a baseline
+   * directory exists for the member and there is no INCOMPLETE_BACKUP file then return the data
+   * stores directory for this member.
+   * 
+   * @param baselineParentDir a previous backup directory. This is used with the incremental backup
+   *        option. May be null if the user specified a full backup.
+   * @return null if the backup is to be a full backup otherwise return the data store directory in
+   *         the previous backup for this member (if incremental).
-  private File checkBaseline(File baselineParentDir) throws IOException{
+  private File checkBaseline(File baselineParentDir) throws IOException {
-    
-    if(null != baselineParentDir) {
+
+    if (null != baselineParentDir) {
-      
-      if(!baselineDir.exists()) {
+
+      if (!baselineDir.exists()) {
-      } 
-      
-      if(null != baselineDir) {
+      }
+
+      if (null != baselineDir) {
-        File incompleteBackup = new File(baselineDir,INCOMPLETE_BACKUP);
-        if(incompleteBackup.exists()) {
-           baselineDir = null;
+        File incompleteBackup = new File(baselineDir, INCOMPLETE_BACKUP);
+        if (incompleteBackup.exists()) {
+          baselineDir = null;
-      }        
+      }
-    
+
-  
-  public HashSet<PersistentID> finishBackup(File targetDir, File baselineDir, boolean abort) throws IOException {
+
+  public HashSet<PersistentID> finishBackup(File targetDir, File baselineDir, boolean abort)
+      throws IOException {
-      if(abort) {
+      if (abort) {
-      
+
-      
+
-      BackupInspector inspector = (baselineDir == null ? null : BackupInspector.createInspector(baselineDir));
-            
+      BackupInspector inspector =
+          (baselineDir == null ? null : BackupInspector.createInspector(baselineDir));
+
-      Collection<DiskStoreImpl> diskStores = new ArrayList<DiskStoreImpl>(cache.listDiskStoresIncludingRegionOwned());
+      Collection<DiskStoreImpl> diskStores =
+          new ArrayList<DiskStoreImpl>(cache.listDiskStoresIncludingRegionOwned());
-      for(Iterator<DiskStoreImpl> itr = diskStores.iterator(); itr.hasNext();) {
+      for (Iterator<DiskStoreImpl> itr = diskStores.iterator(); itr.hasNext();) {
-        if(store.hasPersistedData()) {
-          if(!foundPersistentData) {
+        if (store.hasPersistedData()) {
+          if (!foundPersistentData) {
-      for(DiskStoreImpl store : diskStores) {
+      for (DiskStoreImpl store : diskStores) {
-      if(foundPersistentData) {
+      if (foundPersistentData) {
-        if(!incompleteFile.delete()) {
+        if (!incompleteFile.delete()) {
-  
+
-  
+
-    if(url != null) {
-      File cacheXMLBackup = new File(configBackupDir, DistributionConfig.DEFAULT_CACHE_XML_FILE.getName());
+    if (url != null) {
+      File cacheXMLBackup =
+          new File(configBackupDir, DistributionConfig.DEFAULT_CACHE_XML_FILE.getName());
-    
+
-    if(propertyURL != null) {
-      File propertyBackup = new File(configBackupDir, DistributionConfig.GEMFIRE_PREFIX + "properties");
+    if (propertyURL != null) {
+      File propertyBackup =
+          new File(configBackupDir, DistributionConfig.GEMFIRE_PREFIX + "properties");
-    
+
-    for(File original : backupFiles) {
-      if(original.exists()) {
+    for (File original : backupFiles) {
+      if (original.exists()) {
+   * 
-   * @throws IOException one or more of the jars did not successfully copy. 
+   * @throws IOException one or more of the jars did not successfully copy.
-  private void backupDeployedJars(RestoreScript restoreScript, File backupDir)  throws IOException {
+  private void backupDeployedJars(RestoreScript restoreScript, File backupDir) throws IOException {
-    
+
-      
+
-       * Suspend any user deployed jar file updates during this
-       * backup.
+       * Suspend any user deployed jar file updates during this backup.
-      
+
-      if(!jarList.isEmpty()) {
+      if (!jarList.isEmpty()) {
-        
-        for(JarClassLoader loader : jarList) {
+
+        for (JarClassLoader loader : jarList) {
-          File dest = new File(userBackupDir,source.getName());
-          FileUtil.copy(source,dest);
+          File dest = new File(userBackupDir, source.getName());
+          FileUtil.copy(source, dest);
-        }        
+        }
-      if(null != deployer) {
+      if (null != deployer) {
-    File backupDir  = new File(targetDir, vmId);
-    
-    
+    File backupDir = new File(targetDir, vmId);
+
+
-  
+
-    if(backupDir.exists()) {
+    if (backupDir.exists()) {
-    
-    if(!FileUtil.mkdirs(backupDir)) {
+
+    if (!FileUtil.mkdirs(backupDir)) {
-    
+
-    if(!incompleteFile.createNewFile()) {
+    if (!incompleteFile.createNewFile()) {
-    
+
-    
+
-  
+
-  public void memberJoined(InternalDistributedMember id) {
-  }
+  public void memberJoined(InternalDistributedMember id) {}
-  public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
-  }
+  public void quorumLost(Set<InternalDistributedMember> failures,
+      List<InternalDistributedMember> remaining) {}
-  public void memberSuspect(InternalDistributedMember id,
-      InternalDistributedMember whoSuspected, String reason) {
-  }
+  public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected,
+      String reason) {}

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 DEL66
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-   * Whether zipped values are being passed to/from the client. Can be modified
-   * using the system property Message.ZIP_VALUES ? This does not appear to
-   * happen anywhere
+   * Whether zipped values are being passed to/from the client. Can be modified using the system
+   * property Message.ZIP_VALUES ? This does not appear to happen anywhere
-  protected static final boolean APPLY_RETRIES = Boolean
-      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "gateway.ApplyRetries");
+  protected static final boolean APPLY_RETRIES =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "gateway.ApplyRetries");
-  public static final byte[] OK_BYTES = new byte[]{0};  
+  public static final byte[] OK_BYTES = new byte[] {0};
-  public static final int maximumChunkSize = Integer.getInteger(
-      "BridgeServer.MAXIMUM_CHUNK_SIZE", 100).intValue();
+  public static final int maximumChunkSize =
+      Integer.getInteger("BridgeServer.MAXIMUM_CHUNK_SIZE", 100).intValue();
-  private static boolean suppressIOExceptionLogging = Boolean
-      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "bridge.suppressIOExceptionLogging");
+  private static boolean suppressIOExceptionLogging =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "bridge.suppressIOExceptionLogging");
-   * Maximum number of concurrent incoming client message bytes that a bridge
-   * server will allow. Once a server is working on this number additional
-   * incoming client messages will wait until one of them completes or fails.
-   * The bytes are computed based in the size sent in the incoming msg header.
+   * Maximum number of concurrent incoming client message bytes that a bridge server will allow.
+   * Once a server is working on this number additional incoming client messages will wait until one
+   * of them completes or fails. The bytes are computed based in the size sent in the incoming msg
+   * header.
-  private static final int MAX_INCOMING_DATA = Integer.getInteger(
-      "BridgeServer.MAX_INCOMING_DATA", -1).intValue();
+  private static final int MAX_INCOMING_DATA =
+      Integer.getInteger("BridgeServer.MAX_INCOMING_DATA", -1).intValue();
-   * Maximum number of concurrent incoming client messages that a bridge server
-   * will allow. Once a server is working on this number additional incoming
-   * client messages will wait until one of them completes or fails.
+   * Maximum number of concurrent incoming client messages that a bridge server will allow. Once a
+   * server is working on this number additional incoming client messages will wait until one of
+   * them completes or fails.
-  private static final int MAX_INCOMING_MSGS = Integer.getInteger(
-      "BridgeServer.MAX_INCOMING_MSGS", -1).intValue();
+  private static final int MAX_INCOMING_MSGS =
+      Integer.getInteger("BridgeServer.MAX_INCOMING_MSGS", -1).intValue();
-    }
-    else {
+    } else {
-    }
-    else {
+    } else {
-    //servConn.resetTransientData();
-    if(EntryLogger.isEnabled() && servConn  != null) {
+    // servConn.resetTransientData();
+    if (EntryLogger.isEnabled() && servConn != null) {
-        GemFireCacheImpl  cache = (GemFireCacheImpl)servConn.getCache();
-        InternalDistributedMember member = (InternalDistributedMember)servConn.getProxyID().getDistributedMember();
+        GemFireCacheImpl cache = (GemFireCacheImpl) servConn.getCache();
+        InternalDistributedMember member =
+            (InternalDistributedMember) servConn.getProxyID().getDistributedMember();
-      
-    }   
-    catch (TransactionException
-        | CopyException
-        | SerializationException
-        | CacheWriterException
-        | CacheLoaderException
-        | GemFireSecurityException
-        | PartitionOfflineException
+
+    } catch (TransactionException | CopyException | SerializationException | CacheWriterException
+        | CacheLoaderException | GemFireSecurityException | PartitionOfflineException
-    }
-    catch (EOFException eof) {
+    } catch (EOFException eof) {
-    }
-    catch (InterruptedIOException e) { // Solaris only
+    } catch (InterruptedIOException e) { // Solaris only
-    }
-    catch (IOException e) {
+    } catch (IOException e) {
-    }
-    catch (DistributedSystemDisconnectedException e) {
+    } catch (DistributedSystemDisconnectedException e) {
-    }
-    catch (VirtualMachineError err) {
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Throwable e) {
+    } catch (Throwable e) {
-   * checks to see if this thread needs to masquerade as a transactional thread.
-   * clients after GFE_66 should be able to start a transaction.
+   * checks to see if this thread needs to masquerade as a transactional thread. clients after
+   * GFE_66 should be able to start a transaction.
+   * 
-  
+
-   * If an operation is retried then some server may have seen it already.
-   * We cannot apply this operation to the cache without knowing whether a
-   * version tag has already been created for it.  Otherwise caches that have
-   * seen the event already will reject it but others will not, but will have
-   * no version tag with which to perform concurrency checks.
-   * <p>The client event should have the event identifier from the client and
-   * the region affected by the operation.
+   * If an operation is retried then some server may have seen it already. We cannot apply this
+   * operation to the cache without knowing whether a version tag has already been created for it.
+   * Otherwise caches that have seen the event already will reject it but others will not, but will
+   * have no version tag with which to perform concurrency checks.
+   * <p>
+   * The client event should have the event identifier from the client and the region affected by
+   * the operation.
+   * 
-    VersionTag tag =  null;
+    VersionTag tag = null;
-    }
-    else {
+    } else {
-        logger.debug("recovered version tag {} for replayed operation {}", tag, clientEvent.getEventId());
+        logger.debug("recovered version tag {} for replayed operation {}", tag,
+            clientEvent.getEventId());
-  
+
-   * If an operation is retried then some server may have seen it already.
-   * We cannot apply this operation to the cache without knowing whether a
-   * version tag has already been created for it.  Otherwise caches that have
-   * seen the event already will reject it but others will not, but will have
-   * no version tag with which to perform concurrency checks.
-   * <p>The client event should have the event identifier from the client and
-   * the region affected by the operation.
+   * If an operation is retried then some server may have seen it already. We cannot apply this
+   * operation to the cache without knowing whether a version tag has already been created for it.
+   * Otherwise caches that have seen the event already will reject it but others will not, but will
+   * have no version tag with which to perform concurrency checks.
+   * <p>
+   * The client event should have the event identifier from the client and the region affected by
+   * the operation.
-    if(tag != null) {
+    if (tag != null) {
-  abstract public void cmdExecute(Message msg, ServerConnection servConn,
-      long start) throws IOException, ClassNotFoundException, InterruptedException;
+  abstract public void cmdExecute(Message msg, ServerConnection servConn, long start)
+      throws IOException, ClassNotFoundException, InterruptedException;
-  protected void writeReply(Message origMsg, ServerConnection servConn)
-      throws IOException {
+  protected void writeReply(Message origMsg, ServerConnection servConn) throws IOException {
-  protected void writeReplyWithRefreshMetadata(Message origMsg,
-      ServerConnection servConn, PartitionedRegion pr, byte nwHop) throws IOException {
+
+  protected void writeReplyWithRefreshMetadata(Message origMsg, ServerConnection servConn,
+      PartitionedRegion pr, byte nwHop) throws IOException {
-    replyMsg.addBytesPart(new byte[]{pr.getMetadataVersion(), nwHop});
+    replyMsg.addBytesPart(new byte[] {pr.getMetadataVersion(), nwHop});
-      logger.trace("{}: rpl with REFRESH_METADAT tx: {}", servConn.getName(), origMsg.getTransactionId());
+      logger.trace("{}: rpl with REFRESH_METADAT tx: {}", servConn.getName(),
+          origMsg.getTransactionId());
-  private static void handleEOFException(Message msg,
-      ServerConnection servConn, Exception eof) {
+  private static void handleEOFException(Message msg, ServerConnection servConn, Exception eof) {
-      }
-      else {
+      } else {
-          int transId = (msg != null) ? msg.getTransactionId()
-              : Integer.MIN_VALUE;
+          int transId = (msg != null) ? msg.getTransactionId() : Integer.MIN_VALUE;
-            LocalizedStrings.BaseCommand_0_EOFEXCEPTION_DURING_A_WRITE_OPERATION_ON_REGION__1_KEY_2_MESSAGEID_3,
-            new Object[] {servConn.getName(), servConn.getModRegion(), servConn.getModKey(), Integer.valueOf(transId)}));
-        }
-        else {
+              LocalizedStrings.BaseCommand_0_EOFEXCEPTION_DURING_A_WRITE_OPERATION_ON_REGION__1_KEY_2_MESSAGEID_3,
+              new Object[] {servConn.getName(), servConn.getModRegion(), servConn.getModKey(),
+                  Integer.valueOf(transId)}));
+        } else {
-            LocalizedStrings.BaseCommand_0_CONNECTION_DISCONNECT_DETECTED_BY_EOF,
-            servConn.getName()));
+              LocalizedStrings.BaseCommand_0_CONNECTION_DISCONNECT_DETECTED_BY_EOF,
+              servConn.getName()));
-  private static void handleInterruptedIOException(Message msg,
-      ServerConnection servConn, Exception e) {
+  private static void handleInterruptedIOException(Message msg, ServerConnection servConn,
+      Exception e) {
-  private static void handleIOException(Message msg, ServerConnection servConn,
-      Exception e) {
+  private static void handleIOException(Message msg, ServerConnection servConn, Exception e) {
-          int transId = (msg != null) ? msg.getTransactionId()
-              : Integer.MIN_VALUE;
+          int transId = (msg != null) ? msg.getTransactionId() : Integer.MIN_VALUE;
-            LocalizedStrings.BaseCommand_0_UNEXPECTED_IOEXCEPTION_DURING_OPERATION_FOR_REGION_1_KEY_2_MESSID_3,
-            new Object[] {servConn.getName(), servConn.getModRegion(), servConn.getModKey(), Integer.valueOf(transId)}), e);
-        }
-        else {
-          logger.warn(LocalizedMessage.create(
-            LocalizedStrings.BaseCommand_0_UNEXPECTED_IOEXCEPTION,
-            servConn.getName()), e);
+              LocalizedStrings.BaseCommand_0_UNEXPECTED_IOEXCEPTION_DURING_OPERATION_FOR_REGION_1_KEY_2_MESSID_3,
+              new Object[] {servConn.getName(), servConn.getModRegion(), servConn.getModKey(),
+                  Integer.valueOf(transId)}),
+              e);
+        } else {
+          logger.warn(LocalizedMessage.create(LocalizedStrings.BaseCommand_0_UNEXPECTED_IOEXCEPTION,
+              servConn.getName()), e);
-  private static void handleShutdownException(Message msg,
-      ServerConnection servConn, Exception e) {
+  private static void handleShutdownException(Message msg, ServerConnection servConn, Exception e) {
-        int transId = (msg != null) ? msg.getTransactionId()
-            : Integer.MIN_VALUE;
+        int transId = (msg != null) ? msg.getTransactionId() : Integer.MIN_VALUE;
-          LocalizedStrings.BaseCommand_0_UNEXPECTED_SHUTDOWNEXCEPTION_DURING_OPERATION_ON_REGION_1_KEY_2_MESSAGEID_3,
-          new Object[] {servConn.getName(), servConn.getModRegion(), servConn.getModKey(), Integer.valueOf(transId)}), e);
+            LocalizedStrings.BaseCommand_0_UNEXPECTED_SHUTDOWNEXCEPTION_DURING_OPERATION_ON_REGION_1_KEY_2_MESSAGEID_3,
+            new Object[] {servConn.getName(), servConn.getModRegion(), servConn.getModKey(),
+                Integer.valueOf(transId)}),
+            e);
+      } else {
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.BaseCommand_0_UNEXPECTED_SHUTDOWNEXCEPTION, servConn.getName()), e);
-      else {
-        logger.warn(LocalizedMessage.create(
-          LocalizedStrings.BaseCommand_0_UNEXPECTED_SHUTDOWNEXCEPTION,
-          servConn.getName()),e);
-        }
-//  private static void handleGemfireSecurityException(Message msg,
-//      ServerConnection servConn, GemFireSecurityException e) {
-//
-//    boolean requiresResponse = servConn.getTransientFlag(REQUIRES_RESPONSE);
-//    boolean responded = servConn.getTransientFlag(RESPONDED);
-//    boolean requiresChunkedResponse = servConn
-//        .getTransientFlag(REQUIRES_CHUNKED_RESPONSE);
-//    boolean potentialModification = servConn.getPotentialModification();
-//
-//    try {
-//      try {
-//        if (requiresResponse && !responded) {
-//          if (requiresChunkedResponse) {
-//            writeChunkedException(msg, e, false, servConn);
-//          }
-//          else {
-//            writeException(msg, e, false, servConn);
-//          }
-//          servConn.setAsTrue(RESPONDED);
-//        }
-//      }
-//      finally { // inner try-finally to ensure proper ordering of logging
-//        if (potentialModification) {
-//          int transId = (msg != null) ? msg.getTransactionId()
-//              : Integer.MIN_VALUE;
-//        }
-//      }
-//    }
-//    catch (IOException ioe) {
-//      if (logger.isDebugEnabled()) {
-//        logger.fine(servConn.getName()
-//            + ": Unexpected IOException writing security exception: ", ioe);
-//      }
-//    }
-//  }
+  // private static void handleGemfireSecurityException(Message msg,
+  // ServerConnection servConn, GemFireSecurityException e) {
+  //
+  // boolean requiresResponse = servConn.getTransientFlag(REQUIRES_RESPONSE);
+  // boolean responded = servConn.getTransientFlag(RESPONDED);
+  // boolean requiresChunkedResponse = servConn
+  // .getTransientFlag(REQUIRES_CHUNKED_RESPONSE);
+  // boolean potentialModification = servConn.getPotentialModification();
+  //
+  // try {
+  // try {
+  // if (requiresResponse && !responded) {
+  // if (requiresChunkedResponse) {
+  // writeChunkedException(msg, e, false, servConn);
+  // }
+  // else {
+  // writeException(msg, e, false, servConn);
+  // }
+  // servConn.setAsTrue(RESPONDED);
+  // }
+  // }
+  // finally { // inner try-finally to ensure proper ordering of logging
+  // if (potentialModification) {
+  // int transId = (msg != null) ? msg.getTransactionId()
+  // : Integer.MIN_VALUE;
+  // }
+  // }
+  // }
+  // catch (IOException ioe) {
+  // if (logger.isDebugEnabled()) {
+  // logger.fine(servConn.getName()
+  // + ": Unexpected IOException writing security exception: ", ioe);
+  // }
+  // }
+  // }
-  private static void handleExceptionNoDisconnect(Message msg,
-      ServerConnection servConn, Exception e) {
+  private static void handleExceptionNoDisconnect(Message msg, ServerConnection servConn,
+      Exception e) {
-    boolean requiresChunkedResponse = servConn
-        .getTransientFlag(REQUIRES_CHUNKED_RESPONSE);
+    boolean requiresChunkedResponse = servConn.getTransientFlag(REQUIRES_CHUNKED_RESPONSE);
-          }
-          else {
+          } else {
-      }
-      finally { // inner try-finally to ensure proper ordering of logging
+      } finally { // inner try-finally to ensure proper ordering of logging
-          int transId = (msg != null) ? msg.getTransactionId()
-              : Integer.MIN_VALUE;
+          int transId = (msg != null) ? msg.getTransactionId() : Integer.MIN_VALUE;
-                new Object[] {servConn.getName(),servConn.getModRegion(), servConn.getModKey(), Integer.valueOf(transId)}), e);
+                new Object[] {servConn.getName(), servConn.getModRegion(), servConn.getModKey(),
+                    Integer.valueOf(transId)}),
+                e);
-              logger.debug("{}: Exception during operation on region: {} key: {} messageId: {}", servConn.getName(),
-                  servConn.getModRegion(), servConn.getModKey(), transId, e);
+              logger.debug("{}: Exception during operation on region: {} key: {} messageId: {}",
+                  servConn.getName(), servConn.getModRegion(), servConn.getModKey(), transId, e);
-        }
-        else {
+        } else {
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.BaseCommand_0_UNEXPECTED_EXCEPTION,
+            logger.warn(LocalizedMessage.create(LocalizedStrings.BaseCommand_0_UNEXPECTED_EXCEPTION,
-    }
-    catch (IOException ioe) {
+    } catch (IOException ioe) {
-        logger.debug("{}: Unexpected IOException writing exception: {}", servConn.getName(), ioe.getMessage(), ioe);
+        logger.debug("{}: Unexpected IOException writing exception: {}", servConn.getName(),
+            ioe.getMessage(), ioe);
-  private static void handleThrowable(Message msg, ServerConnection servConn,
-      Throwable th) {
+  private static void handleThrowable(Message msg, ServerConnection servConn, Throwable th) {
-    boolean requiresChunkedResponse = servConn
-        .getTransientFlag(REQUIRES_CHUNKED_RESPONSE);
+    boolean requiresChunkedResponse = servConn.getTransientFlag(REQUIRES_CHUNKED_RESPONSE);
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.BaseCommand_0_UNEXPECTED_ERROR_ON_SERVER,
-              servConn.getName()), th);
+          logger.fatal(LocalizedMessage.create(
+              LocalizedStrings.BaseCommand_0_UNEXPECTED_ERROR_ON_SERVER, servConn.getName()), th);
-          }
-          else {
+          } else {
-      }
-      finally { // inner try-finally to ensure proper ordering of logging
+      } finally { // inner try-finally to ensure proper ordering of logging
-            int transId = (msg != null) ? msg.getTransactionId()
-                : Integer.MIN_VALUE;
+            int transId = (msg != null) ? msg.getTransactionId() : Integer.MIN_VALUE;
-              LocalizedStrings.BaseCommand_0_UNEXPECTED_EXCEPTION_DURING_OPERATION_ON_REGION_1_KEY_2_MESSAGEID_3,
-              new Object[] {servConn.getName(),servConn.getModRegion(), servConn.getModKey(), Integer.valueOf(transId)}), th);
-          }
-          else {
-            logger.warn(LocalizedMessage.create(
-              LocalizedStrings.BaseCommand_0_UNEXPECTED_EXCEPTION,
-              servConn.getName()), th);
+                LocalizedStrings.BaseCommand_0_UNEXPECTED_EXCEPTION_DURING_OPERATION_ON_REGION_1_KEY_2_MESSAGEID_3,
+                new Object[] {servConn.getName(), servConn.getModRegion(), servConn.getModKey(),
+                    Integer.valueOf(transId)}),
+                th);
+          } else {
+            logger.warn(LocalizedMessage.create(LocalizedStrings.BaseCommand_0_UNEXPECTED_EXCEPTION,
+                servConn.getName()), th);
-        logger.debug("{}: Unexpected IOException writing exception: {}", servConn.getName(), ioe.getMessage(), ioe);
+        logger.debug("{}: Unexpected IOException writing exception: {}", servConn.getName(),
+            ioe.getMessage(), ioe);
-  
-  protected static void writeChunkedException(Message origMsg, Throwable e,
-      boolean isSevere, ServerConnection servConn) throws IOException {
+
+  protected static void writeChunkedException(Message origMsg, Throwable e, boolean isSevere,
+      ServerConnection servConn) throws IOException {
-  protected static void writeChunkedException(Message origMsg, Throwable e,
-      boolean isSevere, ServerConnection servConn, ChunkedMessage originalReponse) throws IOException {
+  protected static void writeChunkedException(Message origMsg, Throwable e, boolean isSevere,
+      ServerConnection servConn, ChunkedMessage originalReponse) throws IOException {
-      boolean isSevere, ServerConnection servConn, ChunkedMessage originalReponse, int numOfParts) throws IOException {
+      boolean isSevere, ServerConnection servConn, ChunkedMessage originalReponse, int numOfParts)
+      throws IOException {
-      //chunkedResponseMsg = originalReponse;
+      // chunkedResponseMsg = originalReponse;
-      chunkedResponseMsg.addObjPart(e); 
+      chunkedResponseMsg.addObjPart(e);
-        logger.debug("{}: Sending exception chunk while reply in progress: {}", servConn.getName(), e.getMessage(), e);
+        logger.debug("{}: Sending exception chunk while reply in progress: {}", servConn.getName(),
+            e.getMessage(), e);
-    }
-    else {
+    } else {
-  protected static void writeException(Message origMsg, Throwable e,
-      boolean isSevere, ServerConnection servConn) throws IOException {
+  protected static void writeException(Message origMsg, Throwable e, boolean isSevere,
+      ServerConnection servConn) throws IOException {
-  
+
-  protected static void writeException(Message origMsg, int msgType, Throwable e,
-      boolean isSevere, ServerConnection servConn) throws IOException {
+  protected static void writeException(Message origMsg, int msgType, Throwable e, boolean isSevere,
+      ServerConnection servConn) throws IOException {
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.BaseCommand_SEVERE_CACHE_EXCEPTION_0, msg));
+      logger.fatal(
+          LocalizedMessage.create(LocalizedStrings.BaseCommand_SEVERE_CACHE_EXCEPTION_0, msg));
-      throw (IOException)e;
+      throw (IOException) e;
-    errorMsg
-        .addStringPart(LocalizedStrings.BaseCommand_INVALID_DATA_RECEIVED_PLEASE_SEE_THE_CACHE_SERVER_LOG_FILE_FOR_ADDITIONAL_DETAILS.toLocalizedString());
+    errorMsg.addStringPart(
+        LocalizedStrings.BaseCommand_INVALID_DATA_RECEIVED_PLEASE_SEE_THE_CACHE_SERVER_LOG_FILE_FOR_ADDITIONAL_DETAILS
+            .toLocalizedString());
-  protected static void writeErrorResponse(Message origMsg, int messageType,
-      String msg, ServerConnection servConn) throws IOException {
+  protected static void writeErrorResponse(Message origMsg, int messageType, String msg,
+      ServerConnection servConn) throws IOException {
-  protected static void writeRegionDestroyedEx(Message msg, String regionName,
-      String title, ServerConnection servConn) throws IOException {
+  protected static void writeRegionDestroyedEx(Message msg, String regionName, String title,
+      ServerConnection servConn) throws IOException {
-    RegionDestroyedException ex = new RegionDestroyedException(reason,
-        regionName);
+    RegionDestroyedException ex = new RegionDestroyedException(reason, regionName);
-    }
-    else {
+    } else {
-  protected static void writeResponse(Object data, Object callbackArg,
-      Message origMsg, boolean isObject, ServerConnection servConn)
-      throws IOException {
+  protected static void writeResponse(Object data, Object callbackArg, Message origMsg,
+      boolean isObject, ServerConnection servConn) throws IOException {
-    
+
-    }
-    else {
+    } else {
-      responseMsg.addRawPart((byte[])data, isObject);
-    }
-    else {
-      Assert.assertTrue(isObject,
-          "isObject should be true when value is not a byte[]");
+      responseMsg.addRawPart((byte[]) data, isObject);
+    } else {
+      Assert.assertTrue(isObject, "isObject should be true when value is not a byte[]");
-  
-  protected static void writeResponseWithRefreshMetadata(Object data,
-      Object callbackArg, Message origMsg, boolean isObject,
-      ServerConnection servConn, PartitionedRegion pr, byte nwHop) throws IOException {
+
+  protected static void writeResponseWithRefreshMetadata(Object data, Object callbackArg,
+      Message origMsg, boolean isObject, ServerConnection servConn, PartitionedRegion pr,
+      byte nwHop) throws IOException {
-    }
-    else {
+    } else {
-      responseMsg.addRawPart((byte[])data, isObject);
-    }
-    else {
-      Assert.assertTrue(isObject,
-          "isObject should be true when value is not a byte[]");
+      responseMsg.addRawPart((byte[]) data, isObject);
+    } else {
+      Assert.assertTrue(isObject, "isObject should be true when value is not a byte[]");
-    responseMsg.addBytesPart(new byte[]{pr.getMetadataVersion(),nwHop});
+    responseMsg.addBytesPart(new byte[] {pr.getMetadataVersion(), nwHop});
-  protected static void writeResponseWithFunctionAttribute(byte[] data,
-      Message origMsg, ServerConnection servConn) throws IOException {
+  protected static void writeResponseWithFunctionAttribute(byte[] data, Message origMsg,
+      ServerConnection servConn) throws IOException {
-  
-  static protected void checkForInterrupt(ServerConnection servConn, Exception e) 
+
+  static protected void checkForInterrupt(ServerConnection servConn, Exception e)
-      throw (InterruptedException)e;
+      throw (InterruptedException) e;
-      throw (InterruptedIOException)e;
+      throw (InterruptedIOException) e;
-      CollectionType collectionType, boolean lastChunk,
-      ServerConnection servConn) throws IOException {
+      CollectionType collectionType, boolean lastChunk, ServerConnection servConn)
+      throws IOException {
-  protected static void writeQueryResponseException(Message origMsg,
-      Throwable exception, boolean isSevere, ServerConnection servConn)
-      throws IOException {
+  protected static void writeQueryResponseException(Message origMsg, Throwable exception,
+      boolean isSevere, ServerConnection servConn) throws IOException {
-        logger.debug("{}: Sending exception chunk while reply in progress: {}", servConn.getName(), e.getMessage(), e);
+        logger.debug("{}: Sending exception chunk while reply in progress: {}", servConn.getName(),
+            e.getMessage(), e);
-    }
-    else {
+    } else {
-  protected static void writeChunkedErrorResponse(Message origMsg,
-      int messageType, String message, ServerConnection servConn)
-      throws IOException {
+  protected static void writeChunkedErrorResponse(Message origMsg, int messageType, String message,
+      ServerConnection servConn) throws IOException {
-      logger.debug(servConn.getName() + ": Sending error message header type: "
-          + messageType + " transaction: " + origMsg.getTransactionId());
+      logger.debug(servConn.getName() + ": Sending error message header type: " + messageType
+          + " transaction: " + origMsg.getTransactionId());
-  
-  protected static void writeFunctionResponseException(Message origMsg,
-      int messageType, String message, ServerConnection servConn, Throwable exception)
-      throws IOException {
+
+  protected static void writeFunctionResponseException(Message origMsg, int messageType,
+      String message, ServerConnection servConn, Throwable exception) throws IOException {
-      functionResponseMsg.setLastChunkAndNumParts(true,2);
+      functionResponseMsg.setLastChunkAndNumParts(true, 2);
-        logger.debug("{}: Sending exception chunk while reply in progress: {}", servConn.getName(), e.getMessage(), e);
+        logger.debug("{}: Sending exception chunk while reply in progress: {}", servConn.getName(),
+            e.getMessage(), e);
-    }
-    else {
+    } else {
-      chunkedResponseMsg.setLastChunkAndNumParts(true,2);
+      chunkedResponseMsg.setLastChunkAndNumParts(true, 2);
-  
-  protected static void writeFunctionResponseError(Message origMsg,
-      int messageType, String message, ServerConnection servConn)
-      throws IOException {
+
+  protected static void writeFunctionResponseError(Message origMsg, int messageType, String message,
+      ServerConnection servConn) throws IOException {
-        logger.debug("{}: Sending Error chunk while reply in progress: {}", servConn.getName(), message);
+        logger.debug("{}: Sending Error chunk while reply in progress: {}", servConn.getName(),
+            message);
-    }
-    else {
+    } else {
-  protected static void writeKeySetErrorResponse(Message origMsg,
-      int messageType, String message, ServerConnection servConn)
-      throws IOException {
+  protected static void writeKeySetErrorResponse(Message origMsg, int messageType, String message,
+      ServerConnection servConn) throws IOException {
-      logger.debug("{}: Sending error message header type: {} transaction: {}",
-          servConn.getName(), messageType, origMsg.getTransactionId());
+      logger.debug("{}: Sending error message header type: {} transaction: {}", servConn.getName(),
+          messageType, origMsg.getTransactionId());
-  
+
-      requestMsg.recv(servConn, MAX_INCOMING_DATA, incomingDataLimiter,
-          incomingMsgLimiter);
+      requestMsg.recv(servConn, MAX_INCOMING_DATA, incomingDataLimiter, incomingMsgLimiter);
-    }
-    catch (EOFException eof) {
+    } catch (EOFException eof) {
-    }
-    catch (InterruptedIOException e) { // Solaris only
+    } catch (InterruptedIOException e) { // Solaris only
-    }
-    catch (IOException e) {
+    } catch (IOException e) {
-    }
-    catch (DistributedSystemDisconnectedException e) {
+    } catch (DistributedSystemDisconnectedException e) {
-    }
-    catch (VirtualMachineError err) {
+    } catch (VirtualMachineError err) {
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    }
-    catch (Throwable e) {
+    } catch (Throwable e) {
-  protected static void fillAndSendRegisterInterestResponseChunks(
-      LocalRegion region, Object riKey, int interestType,
-      InterestResultPolicy policy, ServerConnection servConn)
-      throws IOException {
-    fillAndSendRegisterInterestResponseChunks(region, riKey, interestType,
-        false, policy, servConn);
+  protected static void fillAndSendRegisterInterestResponseChunks(LocalRegion region, Object riKey,
+      int interestType, InterestResultPolicy policy, ServerConnection servConn) throws IOException {
+    fillAndSendRegisterInterestResponseChunks(region, riKey, interestType, false, policy, servConn);
-  protected static void fillAndSendRegisterInterestResponseChunks(
-      LocalRegion region, Object riKey, int interestType, boolean serializeValues,
-      InterestResultPolicy policy, ServerConnection servConn)
-      throws IOException {
+  protected static void fillAndSendRegisterInterestResponseChunks(LocalRegion region, Object riKey,
+      int interestType, boolean serializeValues, InterestResultPolicy policy,
+      ServerConnection servConn) throws IOException {
-      sendRegisterInterestResponseChunk(region, riKey, new ArrayList(), true,
-          servConn);
+      sendRegisterInterestResponseChunk(region, riKey, new ArrayList(), true, servConn);
-    if (policy.isKeysValues()
-        && servConn.getClientVersion().compareTo(Version.GFE_80) >= 0) {
-        handleKeysValuesPolicy(region, riKey, interestType, serializeValues, servConn);
-        return;
+    if (policy.isKeysValues() && servConn.getClientVersion().compareTo(Version.GFE_80) >= 0) {
+      handleKeysValuesPolicy(region, riKey, interestType, serializeValues, servConn);
+      return;
-      handleList(region, (List)riKey, policy, servConn);
+      handleList(region, (List) riKey, policy, servConn);
-    case InterestType.OQL_QUERY:
-      // Not supported yet
-      throw new InternalGemFireError(LocalizedStrings.BaseCommand_NOT_YET_SUPPORTED.toLocalizedString());
-    case InterestType.FILTER_CLASS:
-      throw new InternalGemFireError(LocalizedStrings.BaseCommand_NOT_YET_SUPPORTED.toLocalizedString());
-      // handleFilter(region, (String)riKey, policy);
-      // break;
-    case InterestType.REGULAR_EXPRESSION: {
-      String regEx = (String)riKey;
-      if (regEx.equals(".*")) {
-        handleAllKeys(region, policy, servConn);
+      case InterestType.OQL_QUERY:
+        // Not supported yet
+        throw new InternalGemFireError(
+            LocalizedStrings.BaseCommand_NOT_YET_SUPPORTED.toLocalizedString());
+      case InterestType.FILTER_CLASS:
+        throw new InternalGemFireError(
+            LocalizedStrings.BaseCommand_NOT_YET_SUPPORTED.toLocalizedString());
+        // handleFilter(region, (String)riKey, policy);
+        // break;
+      case InterestType.REGULAR_EXPRESSION: {
+        String regEx = (String) riKey;
+        if (regEx.equals(".*")) {
+          handleAllKeys(region, policy, servConn);
+        } else {
+          handleRegEx(region, regEx, policy, servConn);
+        }
-      else {
-        handleRegEx(region, regEx, policy, servConn);
-      }
-    }
-      break;
-    case InterestType.KEY:
-      if (riKey.equals("ALL_KEYS")) {
-        handleAllKeys(region, policy, servConn);
-      }
-      else {
-        handleSingleton(region, riKey, policy, servConn);
-      }
-      break;
-    default:
-      throw new InternalGemFireError(LocalizedStrings.BaseCommand_UNKNOWN_INTEREST_TYPE.toLocalizedString());
+        break;
+      case InterestType.KEY:
+        if (riKey.equals("ALL_KEYS")) {
+          handleAllKeys(region, policy, servConn);
+        } else {
+          handleSingleton(region, riKey, policy, servConn);
+        }
+        break;
+      default:
+        throw new InternalGemFireError(
+            LocalizedStrings.BaseCommand_UNKNOWN_INTEREST_TYPE.toLocalizedString());
-  private static void handleKeysValuesPolicy(LocalRegion region, Object riKey,
-      int interestType, boolean serializeValues, ServerConnection servConn)
-      throws IOException {
+  private static void handleKeysValuesPolicy(LocalRegion region, Object riKey, int interestType,
+      boolean serializeValues, ServerConnection servConn) throws IOException {
-      handleKVList(region, (List)riKey, serializeValues, servConn);
+      handleKVList(region, (List) riKey, serializeValues, servConn);
-    case InterestType.OQL_QUERY:
-      throw new InternalGemFireError(LocalizedStrings.BaseCommand_NOT_YET_SUPPORTED.toLocalizedString());
-    case InterestType.FILTER_CLASS:
-      throw new InternalGemFireError(LocalizedStrings.BaseCommand_NOT_YET_SUPPORTED.toLocalizedString());
-    case InterestType.REGULAR_EXPRESSION:
-      String regEx = (String)riKey;
-      if (regEx.equals(".*")) {
-        handleKVAllKeys(region, null, serializeValues, servConn);
-      } else {
-        handleKVAllKeys(region, regEx, serializeValues, servConn);
-      }
-      break;
-    case InterestType.KEY:
-      if (riKey.equals("ALL_KEYS")) {
-        handleKVAllKeys(region, null, serializeValues, servConn);
-      } else {
-        handleKVSingleton(region, riKey, serializeValues, servConn);
-      }
-      break;
-    default:
-      throw new InternalGemFireError(LocalizedStrings.BaseCommand_UNKNOWN_INTEREST_TYPE.toLocalizedString());
+      case InterestType.OQL_QUERY:
+        throw new InternalGemFireError(
+            LocalizedStrings.BaseCommand_NOT_YET_SUPPORTED.toLocalizedString());
+      case InterestType.FILTER_CLASS:
+        throw new InternalGemFireError(
+            LocalizedStrings.BaseCommand_NOT_YET_SUPPORTED.toLocalizedString());
+      case InterestType.REGULAR_EXPRESSION:
+        String regEx = (String) riKey;
+        if (regEx.equals(".*")) {
+          handleKVAllKeys(region, null, serializeValues, servConn);
+        } else {
+          handleKVAllKeys(region, regEx, serializeValues, servConn);
+        }
+        break;
+      case InterestType.KEY:
+        if (riKey.equals("ALL_KEYS")) {
+          handleKVAllKeys(region, null, serializeValues, servConn);
+        } else {
+          handleKVSingleton(region, riKey, serializeValues, servConn);
+        }
+        break;
+      default:
+        throw new InternalGemFireError(
+            LocalizedStrings.BaseCommand_UNKNOWN_INTEREST_TYPE.toLocalizedString());
-   * @param list
-   *                is a List of entry keys
+   * @param list is a List of entry keys
-  protected static void sendRegisterInterestResponseChunk(Region region,
-      Object riKey, ArrayList list, boolean lastChunk, ServerConnection servConn)
-      throws IOException {
+  protected static void sendRegisterInterestResponseChunk(Region region, Object riKey,
+      ArrayList list, boolean lastChunk, ServerConnection servConn) throws IOException {
-      String str = servConn.getName() + ": Sending"
-          + (lastChunk ? " last " : " ")
-          + "register interest response chunk for region: " + regionName
-          + " for keys: " + riKey + " chunk=<" + chunkedResponseMsg + ">";
+      String str = servConn.getName() + ": Sending" + (lastChunk ? " last " : " ")
+          + "register interest response chunk for region: " + regionName + " for keys: " + riKey
+          + " chunk=<" + chunkedResponseMsg + ">";
-  
+
-   * Determines whether keys for destroyed entries (tombstones) should be sent
-   * to clients in register-interest results.
+   * Determines whether keys for destroyed entries (tombstones) should be sent to clients in
+   * register-interest results.
-  private static boolean sendTombstonesInRIResults(ServerConnection servConn, InterestResultPolicy policy) {
+  private static boolean sendTombstonesInRIResults(ServerConnection servConn,
+      InterestResultPolicy policy) {
-         && (servConn.getClientVersion().compareTo(Version.GFE_80) >= 0);
+        && (servConn.getClientVersion().compareTo(Version.GFE_80) >= 0);
-   * @param region
-   *                the region
-   * @param keyList
-   *                the list of keys
-   * @param policy
-   *                the policy
+   * @param region the region
+   * @param keyList the list of keys
+   * @param policy the policy
-  private static void handleList(LocalRegion region, List keyList,
-      InterestResultPolicy policy, ServerConnection servConn)
-      throws IOException {
+  private static void handleList(LocalRegion region, List keyList, InterestResultPolicy policy,
+      ServerConnection servConn) throws IOException {
-      handleListPR((PartitionedRegion)region, keyList, policy, servConn);
+      handleListPR((PartitionedRegion) region, keyList, policy, servConn);
-        if (region.containsKey(entryKey)
-            || (sendTombstonesInRIResults(servConn, policy) && region.containsTombstone(entryKey))) {
-          
-          appendInterestResponseKey(region, keyList, entryKey, newKeyList,
-              "list", servConn);
+        if (region.containsKey(entryKey) || (sendTombstonesInRIResults(servConn, policy)
+            && region.containsTombstone(entryKey))) {
+
+          appendInterestResponseKey(region, keyList, entryKey, newKeyList, "list", servConn);
-    sendRegisterInterestResponseChunk(region, keyList, newKeyList, true,
-        servConn);
+    sendRegisterInterestResponseChunk(region, keyList, newKeyList, true, servConn);
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="NP_NULL_PARAM_DEREF", justification="Null value handled in sendNewRegisterInterestResponseChunk()")
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "NP_NULL_PARAM_DEREF",
+      justification = "Null value handled in sendNewRegisterInterestResponseChunk()")
-      boolean serializeValues, ServerConnection servConn)
-      throws IOException {
-    VersionedObjectList values = new VersionedObjectList(maximumChunkSize,
-        true, region == null ? true : region.getAttributes()
-            .getConcurrencyChecksEnabled(), serializeValues);
+      boolean serializeValues, ServerConnection servConn) throws IOException {
+    VersionedObjectList values = new VersionedObjectList(maximumChunkSize, true,
+        region == null ? true : region.getAttributes().getConcurrencyChecksEnabled(),
+        serializeValues);
-   * @param region
-   *                the region
-   * @param entryKey
-   *                the key
-   * @param policy
-   *                the policy
+   * @param region the region
+   * @param entryKey the key
+   * @param policy the policy
-      InterestResultPolicy policy, ServerConnection servConn)
-      throws IOException {
+      InterestResultPolicy policy, ServerConnection servConn) throws IOException {
-      if (region.containsKey(entryKey) ||
-          (sendTombstonesInRIResults(servConn, policy) && region.containsTombstone(entryKey))) {
-        appendInterestResponseKey(region, entryKey, entryKey, keyList,
-            "individual", servConn);
+      if (region.containsKey(entryKey)
+          || (sendTombstonesInRIResults(servConn, policy) && region.containsTombstone(entryKey))) {
+        appendInterestResponseKey(region, entryKey, entryKey, keyList, "individual", servConn);
-   * @param region
-   *                the region
-   * @param policy
-   *                the policy
+   * @param region the region
+   * @param policy the policy
-  private static void handleAllKeys(LocalRegion region,
-      InterestResultPolicy policy, ServerConnection servConn)
-      throws IOException {
+  private static void handleAllKeys(LocalRegion region, InterestResultPolicy policy,
+      ServerConnection servConn) throws IOException {
-      for (Iterator it = region.keySet(sendTombstonesInRIResults(servConn, policy)).iterator(); it.hasNext();) {
-        appendInterestResponseKey(region, "ALL_KEYS", it.next(), keyList,
-            "ALL_KEYS", servConn);
+      for (Iterator it = region.keySet(sendTombstonesInRIResults(servConn, policy)).iterator(); it
+          .hasNext();) {
+        appendInterestResponseKey(region, "ALL_KEYS", it.next(), keyList, "ALL_KEYS", servConn);
-    sendRegisterInterestResponseChunk(region, "ALL_KEYS", keyList, true,
-        servConn);
+    sendRegisterInterestResponseChunk(region, "ALL_KEYS", keyList, true, servConn);
-  private static void handleKVAllKeys(LocalRegion region, String regex,
-      boolean serializeValues, ServerConnection servConn) throws IOException {
+  private static void handleKVAllKeys(LocalRegion region, String regex, boolean serializeValues,
+      ServerConnection servConn) throws IOException {
-    VersionedObjectList values = new VersionedObjectList(maximumChunkSize,
-        true, region == null ? true : region.getAttributes()
-            .getConcurrencyChecksEnabled(), serializeValues);
+    VersionedObjectList values = new VersionedObjectList(maximumChunkSize, true,
+        region == null ? true : region.getAttributes().getConcurrencyChecksEnabled(),
+        serializeValues);
-          sendNewRegisterInterestResponseChunk(region, regex != null ? regex : "ALL_KEYS", values, false, servConn);
+          sendNewRegisterInterestResponseChunk(region, regex != null ? regex : "ALL_KEYS", values,
+              false, servConn);
-    sendNewRegisterInterestResponseChunk(region, regex != null ? regex : "ALL_KEYS", values, true, servConn);
+    sendNewRegisterInterestResponseChunk(region, regex != null ? regex : "ALL_KEYS", values, true,
+        servConn);
-    VersionedObjectList values = new VersionedObjectList(maximumChunkSize,
-        true, region.getConcurrencyChecksEnabled(), serializeValues);
+    VersionedObjectList values = new VersionedObjectList(maximumChunkSize, true,
+        region.getConcurrencyChecksEnabled(), serializeValues);
-      region.fetchEntries((String)keyInfo, values, servConn);
+      region.fetchEntries((String) keyInfo, values, servConn);
-    sendNewRegisterInterestResponseChunk(region, keyInfo != null ? keyInfo : "ALL_KEYS", values, true, servConn);
+    sendNewRegisterInterestResponseChunk(region, keyInfo != null ? keyInfo : "ALL_KEYS", values,
+        true, servConn);
-   * Copied from Get70.getValueAndIsObject(), except a minor change. (Make the
-   * method static instead of copying it here?)
+   * Copied from Get70.getValueAndIsObject(), except a minor change. (Make the method static instead
+   * of copying it here?)
-  private static void updateValues(VersionedObjectList values, Object key, Object value, VersionTag versionTag) {
+  private static void updateValues(VersionedObjectList values, Object key, Object value,
+      VersionTag versionTag) {
-      value = ((CachedDeserializable)value).getValue();
-    }
-    else if (value == Token.REMOVED_PHASE1 || value == Token.REMOVED_PHASE2 || value == Token.DESTROYED || value == Token.TOMBSTONE) {
+      value = ((CachedDeserializable) value).getValue();
+    } else if (value == Token.REMOVED_PHASE1 || value == Token.REMOVED_PHASE2
+        || value == Token.DESTROYED || value == Token.TOMBSTONE) {
-    }
-    else if (value == Token.INVALID || value == Token.LOCAL_INVALID) {
+    } else if (value == Token.INVALID || value == Token.LOCAL_INVALID) {
-    }
-    else if (value instanceof byte[]) {
+    } else if (value instanceof byte[]) {
-      
+
-        sendNewRegisterInterestResponseChunk(region, riKeys != null ? riKeys : "ALL_KEYS", values, false, servConn);
+        sendNewRegisterInterestResponseChunk(region, riKeys != null ? riKeys : "ALL_KEYS", values,
+            false, servConn);
-          VersionStamp vs = ((NonTXEntry)entry).getRegionEntry().getVersionStamp();
+          VersionStamp vs = ((NonTXEntry) entry).getRegionEntry().getVersionStamp();
-          value = ((NonTXEntry)entry).getRegionEntry()._getValueRetain(region, true);
+          value = ((NonTXEntry) entry).getRegionEntry()._getValueRetain(region, true);
-        ArrayList list = (ArrayList)entry.getValue();
+        ArrayList list = (ArrayList) entry.getValue();
-        VersionTag tag = (VersionTag)list.get(1);
+        VersionTag tag = (VersionTag) list.get(1);
-        sendNewRegisterInterestResponseChunk(region, riKeys != null ? riKeys : "ALL_KEYS", values, false, servConn);
+        sendNewRegisterInterestResponseChunk(region, riKeys != null ? riKeys : "ALL_KEYS", values,
+            false, servConn);
-  public static void sendNewRegisterInterestResponseChunk(LocalRegion region,
-      Object riKey, VersionedObjectList list, boolean lastChunk, ServerConnection servConn)
-      throws IOException {
+  public static void sendNewRegisterInterestResponseChunk(LocalRegion region, Object riKey,
+      VersionedObjectList list, boolean lastChunk, ServerConnection servConn) throws IOException {
-      String str = servConn.getName() + ": Sending"
-          + (lastChunk ? " last " : " ")
-          + "register interest response chunk for region: " + regionName
-          + " for keys: " + riKey + " chunk=<" + chunkedResponseMsg + ">";
+      String str = servConn.getName() + ": Sending" + (lastChunk ? " last " : " ")
+          + "register interest response chunk for region: " + regionName + " for keys: " + riKey
+          + " chunk=<" + chunkedResponseMsg + ">";
-   * @param region
-   *                the region
-   * @param regex
-   *                the regex
-   * @param policy
-   *                the policy
+   * @param region the region
+   * @param regex the regex
+   * @param policy the policy
-  private static void handleRegEx(LocalRegion region, String regex,
-      InterestResultPolicy policy, ServerConnection servConn)
-      throws IOException {
+  private static void handleRegEx(LocalRegion region, String regex, InterestResultPolicy policy,
+      ServerConnection servConn) throws IOException {
-      handleRegExPR((PartitionedRegion)region, regex, policy, servConn);
+      handleRegExPR((PartitionedRegion) region, regex, policy, servConn);
-      for (Iterator it = region.keySet(sendTombstonesInRIResults(servConn, policy)).iterator(); it.hasNext();) {
+      for (Iterator it = region.keySet(sendTombstonesInRIResults(servConn, policy)).iterator(); it
+          .hasNext();) {
-        if (!keyPattern.matcher((String)entryKey).matches()) {
+        if (!keyPattern.matcher((String) entryKey).matches()) {
-        appendInterestResponseKey(region, regex, entryKey, keyList, "regex",
-            servConn);
+        appendInterestResponseKey(region, regex, entryKey, keyList, "regex", servConn);
-   * @param region
-   *                the region
-   * @param regex
-   *                the regex
-   * @param policy
-   *                the policy
+   * @param region the region
+   * @param regex the regex
+   * @param policy the policy
-  private static void handleRegExPR(final PartitionedRegion region,
-      final String regex, final InterestResultPolicy policy,
-      final ServerConnection servConn) throws IOException {
+  private static void handleRegExPR(final PartitionedRegion region, final String regex,
+      final InterestResultPolicy policy, final ServerConnection servConn) throws IOException {
-    region.getKeysWithRegEx(regex, sendTombstonesInRIResults(servConn, policy), new PartitionedRegion.SetCollector() {
-      public void receiveSet(Set theSet) throws IOException {
-        appendInterestResponseKeys(region, regex, theSet, keyList, "regex",
-            servConn);
-      }
-    });
+    region.getKeysWithRegEx(regex, sendTombstonesInRIResults(servConn, policy),
+        new PartitionedRegion.SetCollector() {
+          public void receiveSet(Set theSet) throws IOException {
+            appendInterestResponseKeys(region, regex, theSet, keyList, "regex", servConn);
+          }
+        });
-   * @param region
-   *                the region
-   * @param keyList
-   *                the list of keys
-   * @param policy
-   *                the policy
+   * @param region the region
+   * @param keyList the list of keys
+   * @param policy the policy
-  private static void handleListPR(final PartitionedRegion region,
-      final List keyList, final InterestResultPolicy policy,
-      final ServerConnection servConn) throws IOException {
+  private static void handleListPR(final PartitionedRegion region, final List keyList,
+      final InterestResultPolicy policy, final ServerConnection servConn) throws IOException {
-    region.getKeysWithList(keyList, sendTombstonesInRIResults(servConn, policy), new PartitionedRegion.SetCollector() {
-      public void receiveSet(Set theSet) throws IOException {
-        appendInterestResponseKeys(region, keyList, theSet, newKeyList, "list",
-            servConn);
-      }
-    });
+    region.getKeysWithList(keyList, sendTombstonesInRIResults(servConn, policy),
+        new PartitionedRegion.SetCollector() {
+          public void receiveSet(Set theSet) throws IOException {
+            appendInterestResponseKeys(region, keyList, theSet, newKeyList, "list", servConn);
+          }
+        });
-    sendRegisterInterestResponseChunk(region, keyList, newKeyList, true,
-        servConn);
+    sendRegisterInterestResponseChunk(region, keyList, newKeyList, true, servConn);
-  private static void handleKVList(final LocalRegion region,
-      final List keyList, boolean serializeValues,
-      final ServerConnection servConn) throws IOException {
+  private static void handleKVList(final LocalRegion region, final List keyList,
+      boolean serializeValues, final ServerConnection servConn) throws IOException {
-      handleKVKeysPR((PartitionedRegion)region, keyList, serializeValues, servConn);
+      handleKVKeysPR((PartitionedRegion) region, keyList, serializeValues, servConn);
-    VersionedObjectList values = new VersionedObjectList(maximumChunkSize,
-        true, region == null ? true : region.getAttributes()
-            .getConcurrencyChecksEnabled(), serializeValues);
+    VersionedObjectList values = new VersionedObjectList(maximumChunkSize, true,
+        region == null ? true : region.getAttributes().getConcurrencyChecksEnabled(),
+        serializeValues);
-          ClientProxyMembershipID id = servConn == null ? null : servConn
-              .getProxyID();
-          data = region.get(key, null, true, true, true, id, versionHolder,
-              true);
+          ClientProxyMembershipID id = servConn == null ? null : servConn.getProxyID();
+          data = region.get(key, null, true, true, true, id, versionHolder, true);
-   * @param region
-   *                the region (for debugging)
-   * @param riKey
-   *                the registerInterest "key" (what the client is interested
-   *                in)
-   * @param entryKey
-   *                key we're responding to
-   * @param list
-   *                list to append to
-   * @param kind
-   *                for debugging
+   * @param region the region (for debugging)
+   * @param riKey the registerInterest "key" (what the client is interested in)
+   * @param entryKey key we're responding to
+   * @param list list to append to
+   * @param kind for debugging
-  private static void appendInterestResponseKey(LocalRegion region,
-      Object riKey, Object entryKey, ArrayList list, String kind,
-      ServerConnection servConn) throws IOException {
+  private static void appendInterestResponseKey(LocalRegion region, Object riKey, Object entryKey,
+      ArrayList list, String kind, ServerConnection servConn) throws IOException {
-  protected static void appendInterestResponseKeys(LocalRegion region,
-      Object riKey, Collection entryKeys, ArrayList collector, String riDescr,
-      ServerConnection servConn) throws IOException {
+  protected static void appendInterestResponseKeys(LocalRegion region, Object riKey,
+      Collection entryKeys, ArrayList collector, String riDescr, ServerConnection servConn)
+      throws IOException {
-      appendInterestResponseKey(region, riKey, it.next(), collector, riDescr,
-          servConn);
+      appendInterestResponseKey(region, riKey, it.next(), collector, riDescr, servConn);

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66
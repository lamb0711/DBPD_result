GEODE-6580: Cleanup static analyzer warnings. (#3432)


-import java.util.Iterator;
-import org.apache.geode.cache.CacheClosedException;
-  public static volatile boolean TEST_DURABLE_IS_NET_DOWN = false;
+  static volatile boolean TEST_DURABLE_IS_NET_DOWN = false;
-  private final InternalDistributedSystem dsys;
+  private final InternalDistributedSystem distributedSystem;
-  protected void finishCreate(PoolManagerImpl pm) {
+  private void finishCreate(PoolManagerImpl pm) {
-      List<HostAddress> locAddresses, InternalDistributedSystem distributedSystem,
-      InternalCache cache, ThreadsMonitoring tMonitoring) {
-    this.threadMonitoring = tMonitoring;
+      List<HostAddress> locatorAddresses, InternalDistributedSystem distributedSystem,
+      InternalCache cache, ThreadsMonitoring threadMonitoring) {
-    this.socketConnectTimeout = attributes.getSocketConnectTimeout();
-    this.freeConnectionTimeout = attributes.getFreeConnectionTimeout();
-    this.loadConditioningInterval = attributes.getLoadConditioningInterval();
-    this.socketBufferSize = attributes.getSocketBufferSize();
-    this.threadLocalConnections = attributes.getThreadLocalConnections();
-    this.readTimeout = attributes.getReadTimeout();
-    this.minConnections = attributes.getMinConnections();
-    this.maxConnections = attributes.getMaxConnections();
-    this.retryAttempts = attributes.getRetryAttempts();
-    this.idleTimeout = attributes.getIdleTimeout();
-    this.pingInterval = attributes.getPingInterval();
-    this.statisticInterval = attributes.getStatisticInterval();
-    this.subscriptionEnabled = attributes.getSubscriptionEnabled();
-    this.prSingleHopEnabled = attributes.getPRSingleHopEnabled();
-    this.subscriptionRedundancyLevel = attributes.getSubscriptionRedundancy();
-    this.subscriptionMessageTrackingTimeout = attributes.getSubscriptionMessageTrackingTimeout();
-    this.subscriptionAckInterval = attributes.getSubscriptionAckInterval();
-    this.subscriptionTimeoutMultiplier = attributes.getSubscriptionTimeoutMultiplier();
-    if (this.subscriptionTimeoutMultiplier < 0) {
-      throw new IllegalArgumentException("The subscription timeout multipler must not be negative");
-    }
-    this.serverGroup = attributes.getServerGroup();
-    this.multiuserSecureModeEnabled = attributes.getMultiuserAuthentication();
-    this.locatorAddresses = locAddresses;
-    this.locators = attributes.getLocators();
-    this.servers = attributes.getServers();
-    this.startDisabled =
-        ((PoolFactoryImpl.PoolAttributes) attributes).startDisabled || !pm.isNormal();
-    this.usedByGateway = ((PoolFactoryImpl.PoolAttributes) attributes).isGateway();
-    this.gatewaySender = ((PoolFactoryImpl.PoolAttributes) attributes).getGatewaySender();
-    this.dsys = distributedSystem;
-    if (this.dsys == null) {
+    this.locatorAddresses = locatorAddresses;
+    if (distributedSystem == null) {
+    this.distributedSystem = distributedSystem;
-    this.securityLogWriter = this.dsys.getSecurityInternalLogWriter();
-    if (!this.dsys.getConfig().getStatisticSamplingEnabled() && this.statisticInterval > 0) {
-      logger.info("statistic-sampling must be enabled for sampling rate of {} to take affect",
-          this.statisticInterval);
+    this.threadMonitoring = threadMonitoring;
+
+    socketConnectTimeout = attributes.getSocketConnectTimeout();
+    freeConnectionTimeout = attributes.getFreeConnectionTimeout();
+    loadConditioningInterval = attributes.getLoadConditioningInterval();
+    socketBufferSize = attributes.getSocketBufferSize();
+    threadLocalConnections = attributes.getThreadLocalConnections();
+    readTimeout = attributes.getReadTimeout();
+    minConnections = attributes.getMinConnections();
+    maxConnections = attributes.getMaxConnections();
+    retryAttempts = attributes.getRetryAttempts();
+    idleTimeout = attributes.getIdleTimeout();
+    pingInterval = attributes.getPingInterval();
+    statisticInterval = attributes.getStatisticInterval();
+    subscriptionEnabled = attributes.getSubscriptionEnabled();
+    prSingleHopEnabled = attributes.getPRSingleHopEnabled();
+    subscriptionRedundancyLevel = attributes.getSubscriptionRedundancy();
+    subscriptionMessageTrackingTimeout = attributes.getSubscriptionMessageTrackingTimeout();
+    subscriptionAckInterval = attributes.getSubscriptionAckInterval();
+    subscriptionTimeoutMultiplier = attributes.getSubscriptionTimeoutMultiplier();
+    if (subscriptionTimeoutMultiplier < 0) {
+      throw new IllegalArgumentException("The subscription timeout multipler must not be negative");
-    this.cancelCriterion = new Stopper();
+    serverGroup = attributes.getServerGroup();
+    multiuserSecureModeEnabled = attributes.getMultiuserAuthentication();
+    locators = attributes.getLocators();
+    servers = attributes.getServers();
+    startDisabled =
+        ((PoolFactoryImpl.PoolAttributes) attributes).startDisabled || !pm.isNormal();
+    usedByGateway = ((PoolFactoryImpl.PoolAttributes) attributes).isGateway();
+    gatewaySender = ((PoolFactoryImpl.PoolAttributes) attributes).getGatewaySender();
+    securityLogWriter = distributedSystem.getSecurityInternalLogWriter();
+    if (!distributedSystem.getConfig().getStatisticSamplingEnabled() && statisticInterval > 0) {
+      logger.info("statistic-sampling must be enabled for sampling rate of {} to take affect",
+          statisticInterval);
+    }
+    cancelCriterion = new Stopper();
-      this.proxyId = ClientProxyMembershipID.getNewProxyMembership(this.dsys);
+      proxyId = ClientProxyMembershipID.getNewProxyMembership(distributedSystem);
-      this.proxyId = ClientProxyMembershipID.getNewProxyMembership(this.dsys);
+      proxyId = ClientProxyMembershipID.getNewProxyMembership(distributedSystem);
-    StatisticsFactory statFactory = null;
-    if (this.gatewaySender != null) {
+    StatisticsFactory statFactory;
+    if (gatewaySender != null) {
-      statFactory = this.dsys;
+      statFactory = distributedSystem;
-    this.stats = this.startDisabled ? null
+    stats = startDisabled ? null
-    endpointManager = new EndpointManagerImpl(name, this.dsys, this.cancelCriterion, this.stats);
-    connectionFactory = new ConnectionFactoryImpl(source, endpointManager, this.dsys,
-        socketBufferSize, socketConnectTimeout, readTimeout, proxyId, this.cancelCriterion,
+    endpointManager = new EndpointManagerImpl(name, distributedSystem, cancelCriterion,
+        stats);
+    connectionFactory = new ConnectionFactoryImpl(source, endpointManager, distributedSystem,
+        socketBufferSize, socketConnectTimeout, readTimeout, proxyId, cancelCriterion,
-    if (this.multiuserSecureModeEnabled) {
-      this.proxyCacheList = new ArrayList<ProxyCache>();
+    if (multiuserSecureModeEnabled) {
+      proxyCacheList = new ArrayList<>();
-      this.proxyCacheList = null;
+      proxyCacheList = null;
-    if (this.startDisabled)
+    if (startDisabled)
-    if (this.statisticInterval > 0 && this.dsys.getConfig().getStatisticSamplingEnabled()) {
+    if (statisticInterval > 0 && distributedSystem.getConfig().getStatisticSamplingEnabled()) {
-        new Object[] {this.name, this.multiuserSecureModeEnabled});
+        new Object[] {name, multiuserSecureModeEnabled});
-    return this.cancelCriterion;
+    return cancelCriterion;
-    return this.name;
+    return name;
-    return this.socketConnectTimeout;
+    return socketConnectTimeout;
-    return this.freeConnectionTimeout;
+    return freeConnectionTimeout;
-    return this.loadConditioningInterval;
+    return loadConditioningInterval;
-    return this.statisticInterval;
+    return statisticInterval;
-    return this.socketBufferSize;
+    return socketBufferSize;
-    return this.threadLocalConnections;
+    return threadLocalConnections;
-    return this.readTimeout;
+    return readTimeout;
-    return this.subscriptionEnabled;
+    return subscriptionEnabled;
-    return this.prSingleHopEnabled;
+    return prSingleHopEnabled;
-    return this.subscriptionRedundancyLevel;
+    return subscriptionRedundancyLevel;
-    return this.subscriptionMessageTrackingTimeout;
+    return subscriptionMessageTrackingTimeout;
-    return this.serverGroup;
+    return serverGroup;
-    return this.multiuserSecureModeEnabled;
+    return multiuserSecureModeEnabled;
-    return this.locators;
+    return locators;
-    return this.source.getOnlineLocators();
+    return source.getOnlineLocators();
-    return this.servers;
+    return servers;
-  public InternalLogWriter getSecurityInternalLogWriter() {
-    return this.securityLogWriter;
-  }
-
-    StringBuilder sb = new StringBuilder(100);
-    sb.append(this.getClass().getSimpleName()).append('@').append(System.identityHashCode(this))
-        .append(" name=").append(getName());
-    return sb.toString();
+    return getClass().getSimpleName() + '@' + System.identityHashCode(this) + " name=" + getName();
-            if (cache == null && dsys != null) {
-              cache = dsys.getCache();
+            if (cache == null && distributedSystem != null) {
+              cache = distributedSystem.getCache();
-                throw new IllegalStateException(
-                    "Cache must be created before creating pool");
+                throw new IllegalStateException("Cache must be created before creating pool");
-            if (!cache.isClosed() && this.getPoolOrCacheCancelInProgress() == null) {
+            if (!cache.isClosed() && getPoolOrCacheCancelInProgress() == null) {
-                      && subroots.getAttributes().getPoolName().equals(this.name)) {
+                      && subroots.getAttributes().getPoolName().equals(name)) {
-                          cnt, subroots.getName(), this.name);
+                          cnt, subroots.getName(), name);
-                    && roots.getAttributes().getPoolName().equals(this.name)) {
+                    && roots.getAttributes().getPoolName().equals(name)) {
-                        cnt, roots.getName(), this.name);
+                        cnt, roots.getName(), name);
-          } catch (CacheClosedException ccex) {
+          } catch (Exception e) {
-              logger.debug(ccex.getMessage(), ccex);
-            }
-          } catch (Exception ex) {
-            if (logger.isDebugEnabled()) {
-              logger.debug(ex.getMessage(), ex);
+              logger.debug(e.getMessage(), e);
-      } // end special case
+      }
-    if (this.pm.unregister(this)) {
+    if (pm.unregister(this)) {
-      this.destroyed = true;
+      destroyed = true;
-        if (this.source != null) {
-          this.source.stop();
+        if (source != null) {
+          source.stop();
-        if (this.queueManager != null) {
+        if (queueManager != null) {
-        if (this.manager != null) {
+        if (manager != null) {
-        if (this.stats != null) {
-          this.stats.close();
+        if (stats != null) {
+          stats.close();
-      throw new RuntimeException(
-          String.format("%s is not the same as %s because it should have been a PoolImpl",
-              new Object[] {this, obj}));
+      throw new RuntimeException(String
+          .format("%s is not the same as %s because it should have been a PoolImpl", this, obj));
-    return this.stats;
+    return stats;
-    return this.riTracker;
+    return riTracker;
-    return this.endpointManager.getConnectedServerCount();
+    return endpointManager.getConnectedServerCount();
-    return ((QueueStateImpl) this.queueManager.getState()).verifyIfDuplicate(eventId);
-  }
-
-  public boolean verifyIfDuplicate(EventID eventId, boolean addToMap) {
-    return ((QueueStateImpl) this.queueManager.getState()).verifyIfDuplicate(eventId);
+    return queueManager.getState().verifyIfDuplicate(eventId);
-    if (this.queueManager == null)
+    if (queueManager == null)
-    if (this.queueManager.getState() == null)
+    if (queueManager.getState() == null)
-    return this.queueManager.getState().getThreadIdToSequenceIdMap();
+    return queueManager.getState().getThreadIdToSequenceIdMap();
-    return ((QueueManagerImpl) this.queueManager).isPrimaryUpdaterAlive();
+    return ((QueueManagerImpl) queueManager).isPrimaryUpdaterAlive();
-    if (this.queueManager != null) {
-      QueueManager.QueueConnections cons = this.queueManager.getAllConnections();
+    if (queueManager != null) {
+      QueueManager.QueueConnections cons = queueManager.getAllConnections();
-  // Pool that are declared in a cache.xml will set this property to true.
-  private boolean declaredInXML;
-
-  public void setDeclaredInXML(boolean v) {
-    this.declaredInXML = v;
-  }
-
-  public boolean getDeclaredInXML() {
-    return this.declaredInXML;
-  }
-
-    return this.readyForEventsCalled;
+    return readyForEventsCalled;
-    this.readyForEventsCalled = true;
+    readyForEventsCalled = true;
-    boolean isDurable = false;
-    DistributionConfig config = dsys.getConfig();
+    DistributionConfig config = distributedSystem.getConfig();
-    isDurable = durableClientId != null && durableClientId.length() > 0;
-    return isDurable;
+    return durableClientId != null && durableClientId.length() > 0;
-    if (this.queueManager != null) {
-      QueueManager.QueueConnections cons = this.queueManager.getAllConnections();
+    if (queueManager != null) {
+      QueueManager.QueueConnections cons = queueManager.getAllConnections();
-    if (this.queueManager != null) {
-      QueueManager.QueueConnections cons = this.queueManager.getAllConnections();
+    if (queueManager != null) {
+      QueueManager.QueueConnections cons = queueManager.getAllConnections();
-    List result = Collections.emptyList();
-    if (this.queueManager != null) {
-      QueueManager.QueueConnections cons = this.queueManager.getAllConnections();
+    List<String> result = Collections.emptyList();
+    if (queueManager != null) {
+      QueueManager.QueueConnections cons = queueManager.getAllConnections();
-        result = new ArrayList(backupCons.size());
-        Iterator<Connection> it = backupCons.iterator();
-        while (it.hasNext()) {
-          Connection con = it.next();
+        result = new ArrayList<>(backupCons.size());
+        for (Connection con : backupCons) {
-    List result = Collections.emptyList();
-    if (this.queueManager != null) {
-      QueueManager.QueueConnections cons = this.queueManager.getAllConnections();
+    List<ServerLocation> result = Collections.emptyList();
+    if (queueManager != null) {
+      QueueManager.QueueConnections cons = queueManager.getAllConnections();
-        result = new ArrayList(backupCons.size());
-        Iterator<Connection> it = backupCons.iterator();
-        while (it.hasNext()) {
-          Connection con = it.next();
+        result = new ArrayList<>(backupCons.size());
+        for (Connection con : backupCons) {
-    return this.attachCount.get();
+    return attachCount.get();
-    this.attachCount.getAndIncrement();
+    attachCount.getAndIncrement();
-    this.attachCount.getAndDecrement();
+    attachCount.getAndDecrement();
-    ArrayList result = new ArrayList();
-    Map endpointMap = endpointManager.getEndpointMap();
-    result.addAll(endpointMap.keySet());
-    return result;
+    Map<ServerLocation, Endpoint> endpointMap = endpointManager.getEndpointMap();
+    return new ArrayList<>(endpointMap.keySet());
-    ArrayList<String> result = new ArrayList(servers.size());
-    Iterator it = servers.iterator();
-    while (it.hasNext()) {
-      ServerLocation sl = (ServerLocation) it.next();
+    ArrayList<String> result = new ArrayList<>(servers.size());
+    for (ServerLocation sl : servers) {
-      Thread.sleep(this.pingInterval * 2);
+      Thread.sleep(pingInterval * 2);
-    Map endpoints = endpointManager.getEndpointMap();
-    for (Iterator itr = endpoints.values().iterator(); itr.hasNext();) {
-      Endpoint endpoint = (Endpoint) itr.next();
+    Map<ServerLocation, Endpoint> endpoints = endpointManager.getEndpointMap();
+    for (Endpoint endpoint : endpoints.values()) {
-      Thread.sleep(this.pingInterval * 2);
+      Thread.sleep(pingInterval * 2);
-    return ((QueueStateImpl) this.queueManager.getState()).getInvalidateCount();
+    return ((QueueStateImpl) queueManager.getState()).getInvalidateCount();
-  public static volatile boolean AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG = false;
+  static volatile boolean AFTER_PRIMARY_RECOVERED_CALLBACK_FLAG = false;
-    if (!this.multiuserSecureModeEnabled) {
+    if (!multiuserSecureModeEnabled) {
-    if (cache == null && dsys != null) {
-      cache = dsys.getCache();
+    if (cache == null && distributedSystem != null) {
+      cache = distributedSystem.getCache();
-    synchronized (this.proxyCacheList) {
-      this.proxyCacheList.add(proxy);
+    synchronized (proxyCacheList) {
+      proxyCacheList.add(proxy);
-      if (dsys != null) {
-        cache = dsys.getCache();
+      if (distributedSystem != null) {
+        cache = distributedSystem.getCache();
-    String reason = null;
+    String reason;
-  public ArrayList<ProxyCache> getProxyCacheList() {
-    return this.proxyCacheList;
+  ArrayList<ProxyCache> getProxyCacheList() {
+    return proxyCacheList;
-    if (this.multiuserSecureModeEnabled && ((AbstractOp) op).needsUserId()) {
+    if (multiuserSecureModeEnabled && ((AbstractOp) op).needsUserId()) {
-        if (this.queueManager == null) {
+        if (queueManager == null) {
-        Connection primary = this.queueManager.getAllConnectionsNoWait().getPrimary();
+        Connection primary = queueManager.getAllConnectionsNoWait().getPrimary();
-        List<Connection> backups = this.queueManager.getAllConnectionsNoWait().getBackups();
-        for (int i = 0; i < backups.size(); i++) {
-          Connection conn = backups.get(i);
+        List<Connection> backups = queueManager.getAllConnectionsNoWait().getBackups();
+        for (Connection conn : backups) {
-    this.primaryQueueSize.set(count);
+    primaryQueueSize.set(count);
-    if (!isDurableClient() || this.queueManager == null) {
+    if (!isDurableClient() || queueManager == null) {
-    if (this.readyForEventsCalled) {
+    if (readyForEventsCalled) {
-    return this.primaryQueueSize.get();
+    return primaryQueueSize.get();

UPD83 MOV21 MOV21 MOV21 MOV25 MOV21 MOV78 MOV43 MOV78 MOV78 MOV78 MOV78 MOV78 MOV78 MOV78 MOV78 MOV78 MOV78 MOV78 MOV78 MOV43 MOV78 MOV78 MOV74 MOV78 MOV78 MOV74 MOV74 UPD42 UPD42 UPD42 INS41 INS60 MOV60 INS41 INS70 INS54 INS70 INS25 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS27 INS42 INS42 MOV41 MOV41 INS42 MOV27 INS74 MOV59 INS74 INS74 INS14 INS44 INS42 MOV8 MOV8 MOV12 INS74 INS44 MOV32 MOV8 MOV12 MOV27 INS8 INS42 MOV8 INS42 INS42 UPD42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS13 MOV32 INS45 MOV32 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS43 INS43 INS42 INS43 INS43 INS42 INS42 INS42 INS42 MOV43 INS43 INS43 INS74 MOV32 MOV43 INS42 MOV43 MOV43 MOV43 MOV43 INS42 INS42 INS21 MOV25 MOV25 MOV25 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV32 MOV42 INS42 MOV42 INS42 INS42 MOV43 UPD42 MOV43 MOV43 INS42 INS42 MOV43 MOV42 INS42 MOV43 INS42 INS42 INS42 MOV43 INS74 UPD42 MOV42 UPD42 INS7 INS8 INS27 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS21 INS70 MOV21 INS70 MOV43 INS42 INS32 MOV53 INS42 INS42 INS33 INS70 INS42 INS42 INS42 INS74 INS52 INS42 INS42 INS42 INS42 INS42 INS7 INS44 INS42 MOV8 INS42 INS44 INS42 MOV8 INS42 INS42 INS42 INS42 INS42 MOV43 INS44 INS42 MOV8 MOV43 INS42 INS42 INS42 INS42 INS42 INS14 MOV43 INS42 MOV43 INS42 INS42 MOV43 INS42 INS74 MOV32 INS74 UPD42 INS42 INS42 UPD43 MOV43 MOV43 INS42 INS42 UPD42 UPD42 MOV32 UPD42 UPD42 UPD42 UPD42 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL33 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL52 DEL42 DEL43 DEL42 DEL42 DEL43 DEL34 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL32 DEL42 DEL13 DEL32 DEL42 DEL32 DEL42 DEL45 DEL32 DEL42 DEL32 DEL21 DEL42 DEL42 DEL32 DEL41 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL12 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL85 DEL5 DEL52 DEL42 DEL4 DEL3 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL52 DEL42 DEL22 DEL32 DEL11 DEL36 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL32 DEL11 DEL36 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL7 DEL21 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL74 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL43 DEL42 DEL43 DEL60 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL14 DEL7 DEL21 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL52 DEL42 DEL22 DEL54 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL8 DEL33 DEL83 DEL42 DEL43 DEL42 DEL43 DEL74 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL24 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22
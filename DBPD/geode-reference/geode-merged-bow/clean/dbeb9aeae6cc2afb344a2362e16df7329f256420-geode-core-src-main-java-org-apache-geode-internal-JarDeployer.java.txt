Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-                  logger.warn("Invalid JAR file found and deleted: {}", jarFiles[0].getAbsolutePath());
+                  logger.warn("Invalid JAR file found and deleted: {}",
+                      jarFiles[0].getAbsolutePath());
-                  if (jarClassLoader == null || !jarClassLoader.getFileName().equals(jarFiles[0].getName())) {
+                  if (jarClassLoader == null
+                      || !jarClassLoader.getFileName().equals(jarFiles[0].getName())) {
-                  logger.debug("Failed attempt to use JAR to create JarClassLoader for: {}", jarName);
+                  logger.debug("Failed attempt to use JAR to create JarClassLoader for: {}",
+                      jarName);
-                if (jarFile.exists() && (jarClassLoader == null || !jarClassLoader.getFileName().equals(jarFile.getName()))) {
+                if (jarFile.exists() && (jarClassLoader == null
+                    || !jarClassLoader.getFileName().equals(jarFile.getName()))) {
-   * @param jarNames
-   *          Array of names of the JAR files to deploy.
-   * @param jarBytes
-   *          Array of contents of the JAR files to deploy.
-   * @return An array of newly created JAR class loaders. Entries will be null for an JARs that were already deployed.
-   * @throws IOException
-   *           When there's an error saving the JAR file to disk
+   * @param jarNames Array of names of the JAR files to deploy.
+   * @param jarBytes Array of contents of the JAR files to deploy.
+   * @return An array of newly created JAR class loaders. Entries will be null for an JARs that were
+   *         already deployed.
+   * @throws IOException When there's an error saving the JAR file to disk
-  public JarClassLoader[] deploy(final String jarNames[], final byte[][] jarBytes) throws IOException, ClassNotFoundException {
+  public JarClassLoader[] deploy(final String jarNames[], final byte[][] jarBytes)
+      throws IOException, ClassNotFoundException {
-          throw new IllegalArgumentException("File does not contain valid JAR content: " + jarNames[i]);
+          throw new IllegalArgumentException(
+              "File does not contain valid JAR content: " + jarNames[i]);
-      
+
-   * @param jarName
-   *          Name of the JAR file to deploy.
-   * @param jarBytes
-   *          Contents of the JAR file to deploy.
+   * @param jarName Name of the JAR file to deploy.
+   * @param jarBytes Contents of the JAR file to deploy.
-   * @throws IOException
-   *           When there's an error saving the JAR file to disk
+   * @throws IOException When there's an error saving the JAR file to disk
-  private JarClassLoader deployWithoutRegistering(final String jarName, final byte[] jarBytes) throws IOException {
+  private JarClassLoader deployWithoutRegistering(final String jarName, final byte[] jarBytes)
+      throws IOException {
-      logger.debug("Deploying {}: {}", jarName, 
-          (oldJarClassLoader == null ? ": not yet deployed" : ": already deployed as " + oldJarClassLoader.getFileCanonicalPath()));
+      logger.debug("Deploying {}: {}", jarName, (oldJarClassLoader == null ? ": not yet deployed"
+          : ": already deployed as " + oldJarClassLoader.getFileCanonicalPath()));
-              logger.debug("Successfully created initial JarClassLoader at file: {}", nextVersionJarFile.getAbsolutePath());
+              logger.debug("Successfully created initial JarClassLoader at file: {}",
+                  nextVersionJarFile.getAbsolutePath());
-              logger.debug("Unable to write contents for first version of JAR to file: {}", nextVersionJarFile.getAbsolutePath());
+              logger.debug("Unable to write contents for first version of JAR to file: {}",
+                  nextVersionJarFile.getAbsolutePath());
-              logger.debug("A version on disk was an exact match for the JAR being deployed: {}", oldJarFiles[0].getAbsolutePath());
+              logger.debug("A version on disk was an exact match for the JAR being deployed: {}",
+                  oldJarFiles[0].getAbsolutePath());
-              logger.debug("Successfully reused JAR to create JarClassLoader from file: {}", oldJarFiles[0].getAbsolutePath());
+              logger.debug("Successfully reused JAR to create JarClassLoader from file: {}",
+                  oldJarFiles[0].getAbsolutePath());
-                logger.debug("Successfully created next JarClassLoader at file: {}", nextVersionJarFile.getAbsolutePath());
+                logger.debug("Successfully created next JarClassLoader at file: {}",
+                    nextVersionJarFile.getAbsolutePath());
-                logger.debug("Unable to write contents for next version of JAR to file: {}", nextVersionJarFile.getAbsolutePath());
+                logger.debug("Unable to write contents for next version of JAR to file: {}",
+                    nextVersionJarFile.getAbsolutePath());
-        logger.info("Failed attempt to use JAR to create JarClassLoader for: {} : {}", jarName, ioex.getMessage());
+        logger.info("Failed attempt to use JAR to create JarClassLoader for: {} : {}", jarName,
+            ioex.getMessage());
-          logger.debug("Unable to determine a JAR file location, will loop and try again: {}", jarName);
+          logger.debug("Unable to determine a JAR file location, will loop and try again: {}",
+              jarName);
-          logger.debug("Exiting loop for JarClassLoader creation using file: {}", newJarClassLoader.getFileName());
+          logger.debug("Exiting loop for JarClassLoader creation using file: {}",
+              newJarClassLoader.getFileName());
-   * @param jarName
-   *          The name of the JAR file to undeploy
+   * @param jarName The name of the JAR file to undeploy
-   * @throws IOException
-   *           If there's a problem deleting the file
+   * @throws IOException If there's a problem deleting the file
-   * Suspend all deploy and undeploy operations. This is done by acquiring and holding
-   * the lock needed in order to perform a deploy or undeploy and so it will cause all
-   * threads attempting to do one of these to block. This makes it somewhat of a time
-   * sensitive call as forcing these other threads to block for an extended period of
-   * time may cause other unforeseen problems.  It must be followed by a call
-   * to {@link #resumeAll()}.
+   * Suspend all deploy and undeploy operations. This is done by acquiring and holding the lock
+   * needed in order to perform a deploy or undeploy and so it will cause all threads attempting to
+   * do one of these to block. This makes it somewhat of a time sensitive call as forcing these
+   * other threads to block for an extended period of time may cause other unforeseen problems. It
+   * must be followed by a call to {@link #resumeAll()}.
-  
+
-   * Release the lock that controls entry into the deploy/undeploy methods
-   * which will allow those activities to continue.
+   * Release the lock that controls entry into the deploy/undeploy methods which will allow those
+   * activities to continue.
-  
+
-   * @param latestJarName
-   *          The previous most recent version of the JAR file or original name if there wasn't one
+   * @param latestJarName The previous most recent version of the JAR file or original name if there
+   *        wasn't one
-   * Attempt to write the given bytes to the given file. If this VM is able to successfully write the contents to the
-   * file, or another VM writes the exact same contents, then the write is considered to be successful.
+   * Attempt to write the given bytes to the given file. If this VM is able to successfully write
+   * the contents to the file, or another VM writes the exact same contents, then the write is
+   * considered to be successful.
-   * @param file
-   *          File of the JAR file to deploy.
-   * @param jarBytes
-   *          Contents of the JAR file to deploy.
+   * @param file File of the JAR file to deploy.
+   * @param jarBytes Contents of the JAR file to deploy.
-   * Determine if the contents of the file referenced is an exact match for the bytes provided. The method first checks
-   * to see if the file is actively being written by checking the length over time. If it appears that the file is
-   * actively being written, then it loops waiting for that to complete before doing the comparison.
+   * Determine if the contents of the file referenced is an exact match for the bytes provided. The
+   * method first checks to see if the file is actively being written by checking the length over
+   * time. If it appears that the file is actively being written, then it loops waiting for that to
+   * complete before doing the comparison.
-   * @param file
-   *          File to compare
-   * @param bytes
-   *          Bytes to compare
+   * @param file File to compare
+   * @param bytes Bytes to compare
-   * @throws IOException
-   *           If there's a problem reading the file
+   * @throws IOException If there's a problem reading the file
-        logger.debug("Unmatching file length when waiting for another to write file: {}", absolutePath);
+        logger.debug("Unmatching file length when waiting for another to write file: {}",
+            absolutePath);
-            logger.debug("Did not find a match when waiting for another to write file: {}", absolutePath);
+            logger.debug("Did not find a match when waiting for another to write file: {}",
+                absolutePath);
-            logger.debug("Tried and acquired exclusive lock for file: {}, w/ channel {}", absolutePath, fileLock.channel());
+            logger.debug("Tried and acquired exclusive lock for file: {}, w/ channel {}",
+                absolutePath, fileLock.channel());
-              logger.debug("Could not delete file, will truncate instead and delete on exit: {}", absolutePath);
+              logger.debug("Could not delete file, will truncate instead and delete on exit: {}",
+                  absolutePath);
-              logger.debug("Released file lock for file: {}, w/ channel: {}", absolutePath, fileLock.channel());
+              logger.debug("Released file lock for file: {}, w/ channel: {}", absolutePath,
+                  fileLock.channel());
-   * @param file
-   *          File to get the version number from
+   * @param file File to get the version number from
-   * Find all versions of the JAR file that are currently on disk and return them sorted from newest (highest version)
-   * to oldest
+   * Find all versions of the JAR file that are currently on disk and return them sorted from newest
+   * (highest version) to oldest
-   * @param jarFilename
-   *          Name of the JAR file that we want old versions of
+   * @param jarFilename Name of the JAR file that we want old versions of
-      if (classLoader instanceof JarClassLoader && ((JarClassLoader) classLoader).getJarName().equals(jarName)) {
+      if (classLoader instanceof JarClassLoader
+          && ((JarClassLoader) classLoader).getJarName().equals(jarName)) {
-   * @throws IOException
-   *           If the directory isn't writable
+   * @throws IOException If the directory isn't writable
-    throw new IOException("Unable to write to deploy directory");
+    throw new IOException(
+        "Unable to write to deploy directory: " + this.deployDirectory.getCanonicalPath());
-  
+

UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS27 INS45 INS32 INS22 INS42 INS52 INS42 DEL66 DEL45
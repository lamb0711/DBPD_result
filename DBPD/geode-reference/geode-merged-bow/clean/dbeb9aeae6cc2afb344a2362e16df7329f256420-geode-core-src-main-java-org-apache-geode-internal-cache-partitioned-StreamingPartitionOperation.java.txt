Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-* StreamingPartitionOperation is an abstraction for sending messages to multiple (or single)
- * recipients requesting a potentially large amount of data from a Partitioned Region datastore
- * and receiving the reply with data chunked into several messages.
+ * StreamingPartitionOperation is an abstraction for sending messages to multiple (or single)
+ * recipients requesting a potentially large amount of data from a Partitioned Region datastore and
+ * receiving the reply with data chunked into several messages.
-  
+
-  
+
-  
+
-    throw new UnsupportedOperationException(LocalizedStrings.StreamingPartitionOperation_CALL_GETPARTITIONEDDATAFROM_INSTEAD.toLocalizedString());
+    throw new UnsupportedOperationException(
+        LocalizedStrings.StreamingPartitionOperation_CALL_GETPARTITIONEDDATAFROM_INSTEAD
+            .toLocalizedString());
-  
+
-  * Returns normally if succeeded to get data, otherwise throws an exception
+   * Returns normally if succeeded to get data, otherwise throws an exception
-  throws org.apache.geode.cache.TimeoutException, InterruptedException, QueryException, ForceReattemptException {
-    if (Thread.interrupted()) throw new InterruptedException();
+      throws org.apache.geode.cache.TimeoutException, InterruptedException, QueryException,
+      ForceReattemptException {
+    if (Thread.interrupted())
+      throw new InterruptedException();
-    
+
-  
+
-  @Override  
-  protected abstract DistributionMessage createRequestMessage(Set recipients, ReplyProcessor21 processor);
+  @Override
+  protected abstract DistributionMessage createRequestMessage(Set recipients,
+      ReplyProcessor21 processor);
-    
+
-    private final Set<InternalDistributedMember> failedMembers = new CopyOnWriteHashSet<InternalDistributedMember>();
-    
+    private final Set<InternalDistributedMember> failedMembers =
+        new CopyOnWriteHashSet<InternalDistributedMember>();
+
-      
+
-        
+
-          logger.debug("Streaming Message Tracking Status: Processor id: {}; Sender: {}; Messages Processed: {}; NumMsgs: {}",
+          logger.debug(
+              "Streaming Message Tracking Status: Processor id: {}; Sender: {}; Messages Processed: {}; NumMsgs: {}",
-        
+
-  
+
-    
-    public StreamingPartitionResponse(InternalDistributedSystem system,
-                                      Set members) {
+
+    public StreamingPartitionResponse(InternalDistributedSystem system, Set members) {
-    
+
-      
+
-        StreamingReplyMessage m = (StreamingReplyMessage)msg;
+        StreamingReplyMessage m = (StreamingReplyMessage) msg;
-        if (objects != null) {  // CONSTRAINT: objects should only be null if there's no data at all
+        if (objects != null) { // CONSTRAINT: objects should only be null if there's no data at all
-            isAborted = !processChunk(objects, m.getSender(),
-                m.getMessageNumber(), m.isLastMessage());
+            isAborted =
+                !processChunk(objects, m.getSender(), m.getMessageNumber(), m.isLastMessage());
-        }
-        else {
+        } else {
-       if (isLast) { //commented by Suranjan watch this out
+        if (isLast) { // commented by Suranjan watch this out
-      }
-      finally {
+      } finally {
-        checkIfDone(); // check to see if decrementing msgsBeingProcessed requires signalling to proceed
-      }          
-    }  
+        checkIfDone(); // check to see if decrementing msgsBeingProcessed requires signalling to
+                       // proceed
+      }
+    }
-    protected synchronized void processException(DistributionMessage msg,
-        ReplyException ex) {
+    protected synchronized void processException(DistributionMessage msg, ReplyException ex) {
-      if (t instanceof ForceReattemptException ||
-          t instanceof CacheClosedException) {
+      if (t instanceof ForceReattemptException || t instanceof CacheClosedException) {
-          logger.debug("StreamingPartitionResponse received exception {} for member {} query retry required.", t, msg.getSender());
+          logger.debug(
+              "StreamingPartitionResponse received exception {} for member {} query retry required.",
+              t, msg.getSender());
-      if (id!=null && waitingOnMember(id)) {
+      if (id != null && waitingOnMember(id)) {
-        this.memberDepartedMessage = LocalizedStrings.StreamingPartitionOperation_GOT_MEMBERDEPARTED_EVENT_FOR_0_CRASHED_1.toLocalizedString(new Object[] {id, Boolean.valueOf(crashed)});
+        this.memberDepartedMessage =
+            LocalizedStrings.StreamingPartitionOperation_GOT_MEMBERDEPARTED_EVENT_FOR_0_CRASHED_1
+                .toLocalizedString(new Object[] {id, Boolean.valueOf(crashed)});
-     * @throws CacheException  if the recipient threw a cache exception during message processing
+     * 
+     * @throws CacheException if the recipient threw a cache exception during message processing
-      }
-      catch (ReplyException e) {
+      } catch (ReplyException e) {
-          throw (CacheException)t;
-        } else if(t instanceof RegionDestroyedException) {
-          throw (RegionDestroyedException)t;
+          throw (CacheException) t;
+        } else if (t instanceof RegionDestroyedException) {
+          throw (RegionDestroyedException) t;
-          throw (QueryException)t;
+          throw (QueryException) t;
-        //This won't be reached, because of the above,
-        //but it makes the compiler happy.
+        // This won't be reached, because of the above,
+        // but it makes the compiler happy.
-    
+
-     * Contract of {@link ReplyProcessor21#stillWaiting()} is that it never
-     * returns true after returning false.
+     * Contract of {@link ReplyProcessor21#stillWaiting()} is that it never returns true after
+     * returning false.
-    
-    /** Overridden to wait for messages being currently processed:
-      *  This situation can come about if a member departs while we
-      *  are still processing data from that member
-      */
-    @Override  
+
+    /**
+     * Overridden to wait for messages being currently processed: This situation can come about if a
+     * member departs while we are still processing data from that member
+     */
+    @Override
-      finishedWaiting =  finishedWaiting ||
-          this.abort || !super.stillWaiting();
+      finishedWaiting = finishedWaiting || this.abort || !super.stillWaiting();
-    
-    @Override  
+
+    @Override
-      }
-      else {
+      } else {
-        sb.append(" replies"); 
+        sb.append(" replies");
-    }    
-    
+    }
+
-        status = (Status)this.statusMap.get(m.getSender());
+        status = (Status) this.statusMap.get(m.getSender());
-      for (Iterator i=notReceivedMembers.iterator(); i.hasNext(); ) {
-        removeMember((InternalDistributedMember)i.next(), true);
+      for (Iterator i = notReceivedMembers.iterator(); i.hasNext();) {
+        removeMember((InternalDistributedMember) i.next(), true);
-  
-  public static abstract class StreamingPartitionMessage extends PartitionMessage {    
+
+  public static abstract class StreamingPartitionMessage extends PartitionMessage {
-    
+
-    
+
-    
-    /** send a reply message.  This is in a method so that subclasses can override the reply message type
-      *  @see PutMessage#sendReply
-      */
-    @Override  
-    protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex, PartitionedRegion pr, long startTime) {
+
+    /**
+     * send a reply message. This is in a method so that subclasses can override the reply message
+     * type
+     * 
+     * @see PutMessage#sendReply
+     */
+    @Override
+    protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+        PartitionedRegion pr, long startTime) {
-      StreamingReplyMessage.send(member, procId, ex, dm, this.outStream,
-                                 this.numObjectsInChunk, this.replyMsgNum,
-                                 this.replyLastMsg);
+      StreamingReplyMessage.send(member, procId, ex, dm, this.outStream, this.numObjectsInChunk,
+          this.replyMsgNum, this.replyLastMsg);
-    
+
-      * An operation upon the messages partitioned region
+     * An operation upon the messages partitioned region
-     * @param dm
-     *          the manager that received the message
-     * @param pr
-     *          the partitioned region that should be modified
+     * @param dm the manager that received the message
+     * @param pr the partitioned region that should be modified
-    @Override  
-    protected boolean operateOnPartitionedRegion(DistributionManager dm,
-                                                 PartitionedRegion pr, long startTime)
-    throws CacheException, QueryException, ForceReattemptException, InterruptedException {
+    @Override
+    protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion pr,
+        long startTime)
+        throws CacheException, QueryException, ForceReattemptException, InterruptedException {
-      
-      if (Thread.interrupted()) throw new InterruptedException();
+
+      if (Thread.interrupted())
+        throw new InterruptedException();
-      
+
-      
-      try {        
+
+      try {
-//          boolean firstObject = true;
-          
+          // boolean firstObject = true;
+
-              logger.trace("Writing this object to StreamingPartitionMessage outStream: '{}'", nextObject);
-            } 
+              logger.trace("Writing this object to StreamingPartitionMessage outStream: '{}'",
+                  nextObject);
+            }
-            
+
-              outStream.disallowExpansion(CHUNK_FULL); // sets the mark where rollback occurs on CHUNK_FULL
-              
+              outStream.disallowExpansion(CHUNK_FULL); // sets the mark where rollback occurs on
+                                                       // CHUNK_FULL
+
-              
+
-                  
+
-                    logger.trace("Writing this object to StreamingPartitionMessage outStream: '{}'", nextObject);
-                  } 
+                    logger.trace("Writing this object to StreamingPartitionMessage outStream: '{}'",
+                        nextObject);
+                  }
-                } 
+                }
-          
+
-          } 
-          catch (CancelException e) {
+          } catch (CancelException e) {
-                                   // does not queue the message but outStream has
-                                   // already been used          
+                                  // does not queue the message but outStream has
+                                  // already been used
-      
-      
-      if (!sentFinalMessage && !receiverCacheClosed) {    
-        throw new InternalGemFireError(LocalizedStrings.StreamingPartitionOperation_UNEXPECTED_CONDITION.toLocalizedString());
+
+
+      if (!sentFinalMessage && !receiverCacheClosed) {
+        throw new InternalGemFireError(
+            LocalizedStrings.StreamingPartitionOperation_UNEXPECTED_CONDITION.toLocalizedString());
-      
-      //otherwise, we're already done, so don't send another reply
-      return false;      
-    } 
-    
-    /** override in subclass to provide reply data.
-      *  terminate by returning END_OF_STREAM token object
-      */
+
+      // otherwise, we're already done, so don't send another reply
+      return false;
+    }
+
+    /**
+     * override in subclass to provide reply data. terminate by returning END_OF_STREAM token object
+     */
-    throws CacheException, ForceReattemptException, InterruptedException;
-    
+        throws CacheException, ForceReattemptException, InterruptedException;
+
-      throw new UnsupportedOperationException(LocalizedStrings.StreamingPartitionOperation_USE_GETNEXTREPLYOBJECTPARTITIONEDREGION_INSTEAD.toLocalizedString());
+      throw new UnsupportedOperationException(
+          LocalizedStrings.StreamingPartitionOperation_USE_GETNEXTREPLYOBJECTPARTITIONEDREGION_INSTEAD
+              .toLocalizedString());

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 DEL66 DEL66
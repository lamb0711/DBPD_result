GEODE-8302: Fixed 'events not queued conflated' stats when group-tranâ€¦ (#5313)

* GEODE-8302: Fixed 'events not queued conflated' stats when group-transaction-events is true

Batch conflation is not compatible with group-transaction-events.
It must be prevented that both are enabled at the same time for
a given gateway sender.

* GEODE-8302: Add extra checks in propagation with HA tests and add fix in conflation stats

* GEODE-8302: Update GatewaySenderFactory javadoc

Added information about incompatibility between
group-transaction-events and enable-batch-conflation.

* GEODE-8302: Doc changes after review

* GEODE-8302: Fix for failing testReplicatedSerialPropagationHAWithGroupTransactionEvents

* GEODE-8302: doc and error messages changes after review

* GEODE-8302: Fix failing test case and possibly fix GEODE-8320
+   * Contains the set of peekedIds that were peeked to complete a transaction
+   * inside a batch when groupTransactionEvents is set and that have
+   * been sent in a batch but have not yet been removed.
+   */
+  private final Set<Long> extraPeekedIdsSentNotRemoved = ConcurrentHashMap.newKeySet();
+
+  /**
-      extraPeekedIds.remove(key);
+      boolean isExtraPeeked = extraPeekedIds.remove(key);
-        updateHeadKey(key.longValue());
+        if (!isExtraPeeked) {
+          updateHeadKey(key.longValue());
+        }
-      this.lastDispatchedKey = key;
+      if (!isExtraPeeked) {
+        this.lastDispatchedKey = key;
+        // Remove also the extraPeekedIds right after this one so that
+        // they do not stay in the secondary's queue forever
+        long tmpKey = key;
+        while (extraPeekedIdsSentNotRemoved.contains(tmpKey = inc(tmpKey))) {
+          extraPeekedIdsSentNotRemoved.remove(tmpKey);
+          this.lastDispatchedKey = tmpKey;
+          updateHeadKey(tmpKey);
+        }
+      } else {
+        extraPeekedIdsSentNotRemoved.add(key);
+        // Remove if previous key was already dispatched so that it does
+        // not stay in the secondary's queue forever
+        long tmpKey = dec(key);
+        if (this.lastDispatchedKey == tmpKey) {
+          this.lastDispatchedKey = key;
+          updateHeadKey(key);
+        }
+      }
+  private long dec(long value) {
+    long val = value - 1;
+    val = val == -1 ? MAXIMUM_KEY - 1 : val;
+    return val;
+  }
+
+
-    this.peekedIds.clear();
+    peekedIds.clear();
-    if (lastPeekedId.equals(-1)) {
+    if (lastPeekedId.get() == -1) {
-      if (this.stats != null) {
+      // When mustGroupTransactionEvents is true, conflation cannot be enabled.
+      // Therefore, if we reach here, it would not be due to a conflated event
+      // but rather to an extra peeked event already sent.
+      if (!mustGroupTransactionEvents() && this.stats != null) {
-      this.peekedIds.add(currentKey);
+      peekedIds.add(currentKey);

INS23 INS31 INS29 INS83 INS83 INS74 INS59 INS83 INS39 INS42 INS44 INS8 INS65 INS43 INS43 INS42 INS32 INS39 INS42 INS60 INS21 INS41 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS39 INS59 INS7 INS42 INS27 INS60 INS25 INS42 INS27 INS42 INS16 INS42 INS32 INS38 INS39 INS59 INS38 INS8 INS8 INS42 INS34 INS27 INS27 INS42 MOV42 UPD42 MOV42 INS34 INS27 INS42 MOV32 INS25 INS42 MOV21 INS60 INS61 INS21 INS60 INS25 INS42 MOV38 INS42 INS34 INS38 MOV27 INS42 INS38 INS8 INS39 INS59 INS32 INS8 INS32 INS39 INS59 INS27 INS8 INS32 INS42 MOV21 INS42 INS42 INS42 INS42 INS7 MOV21 INS21 INS21 INS42 INS42 INS42 INS42 INS32 INS22 INS42 INS21 INS21 INS42 INS42 INS32 INS32 INS7 INS32 INS42 INS42 INS52 INS42 INS7 INS32 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS22 INS42 INS42 INS42 INS52 INS42 INS52 INS42 DEL52 DEL42 DEL22 DEL32 DEL52 DEL42 DEL22
Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import java.util.Map;
+import com.gemstone.gemfire.distributed.DistributedMember;
-    other systems.  Connections are identified by host/port Stubs.
+    other systems.  Connections are identified by DistributedMember IDs.
-  /** id is an endpoint Stub representing this server.  It holds the
-      actual port the server is listening on */
-  private Stub id;
+  /** server socket address */
+  private InetSocketAddress id;
-      id = new Stub(socket.getInetAddress(), localPort, 0);
+      id = new InetSocketAddress(socket.getInetAddress(), localPort);
-      String s = "While creating ServerSocket and Stub on port " + p;
+      String s = "While creating ServerSocket on port " + p;
-  /**
-   * After startup we install the view ID into the conduit stub to avoid
-   * confusion during overlapping shutdown/startup from the same member.
-   * 
-   * @param viewID
-   */
-  public void setVmViewID(int viewID) {
-    this.id.setViewID(viewID);
-  }
-
-
-      logger.trace(LogMarker.DM, "Starting P2P Listener on  {}", this.getId());
+      logger.trace(LogMarker.DM, "Starting P2P Listener on  {}", id);
-          if (logger.isTraceEnabled(LogMarker.QA)) {
-            logger.trace(LogMarker.QA, "Test hook: inhibiting acceptance of connection {}", othersock);
-          }
+//          if (logger.isTraceEnabled(LogMarker.QA)) {
+            logger.info("Test hook: inhibiting acceptance of connection {}", othersock);
+//          }
-      logger.debug("Stopped P2P Listener on  {}", this.getId());
+      logger.debug("Stopped P2P Listener on  {}", id);
-    Stub member,
-    HashMap result)
+    DistributedMember member,
+    Map result)
-  public void waitForThreadOwnedOrderedConnectionState(Stub member, HashMap channelState)
+  public void waitForThreadOwnedOrderedConnectionState(DistributedMember member, Map channelState)
-      directChannel.receive(msg, bytesRead, receiver.getRemoteId());
+      msg.setSharedReceiver(receiver.isSharedResource());
+      directChannel.receive(msg, bytesRead);
-  /** gets the Stub representing this conduit's ServerSocket endpoint.  This
-      is used to generate other stubs containing endpoint information. */
-  public Stub getId() {
+  /** gets the address of this conduit's ServerSocket endpoint */
+  public InetSocketAddress getId() {
-  /** gets the channel that is used to process non-Stub messages */
+  /** gets the channel that is used to process non-DistributedMember messages */
-  public InternalDistributedMember getMemberForStub(Stub s, boolean validate) {
-    return membershipManager.getMemberForStub(s, validate);
-  }
-  
-  public InternalDistributedMember getLocalId() {
+  public InternalDistributedMember getLocalAddr() {
-   * @param remoteId the TCPConduit stub for this member
-  public Connection getConnection(InternalDistributedMember memberAddress, Stub remoteId, final boolean preserveOrder, boolean retry,
-      long startTime, long ackTimeout, long ackSATimeout)
+  public Connection getConnection(InternalDistributedMember memberAddress, final boolean preserveOrder, boolean retry, long startTime,
+      long ackTimeout, long ackSATimeout)
-        // Consult with the membership manager; if member has gone away,
-        // there will not be an entry for this stub.
-        InternalDistributedMember m = this.membershipManager.getMemberForStub(remoteId, true);
-        if (m == null) {
-          // OK, the member left.  Just register an error.
+        if (!membershipManager.memberExists(memberAddress) || membershipManager.isShunned(memberAddress) || membershipManager.shutdownInProgress()) {
-        m = this.membershipManager.getMemberForStub(remoteId, true);
-        if (m == null) {
+        if (!membershipManager.memberExists(memberAddress) || membershipManager.isShunned(memberAddress)) {
-          memberInTrouble = m;
+          memberInTrouble = memberAddress;
-              logger.debug("Closing old connection.  conn={} before retrying. remoteID={} memberInTrouble={}",
-                  conn, remoteId,  memberInTrouble);
+              logger.debug("Closing old connection.  conn={} before retrying. memberInTrouble={}",
+                  conn, memberInTrouble);
-          conn = getConTable().get(remoteId, preserveOrder, startTime, ackTimeout, ackSATimeout);
+          conn = getConTable().get(memberAddress, preserveOrder, startTime, ackTimeout, ackSATimeout);
-            problem = new IOException(LocalizedStrings.TCPConduit_UNABLE_TO_RECONNECT_TO_SERVER_POSSIBLE_SHUTDOWN_0.toLocalizedString(remoteId));
+            problem = new IOException(LocalizedStrings.TCPConduit_UNABLE_TO_RECONNECT_TO_SERVER_POSSIBLE_SHUTDOWN_0.toLocalizedString(memberAddress));
-        InternalDistributedMember m = this.membershipManager.getMemberForStub(remoteId, true);
-        if (m == null) { // left the view
+        if (!membershipManager.memberExists(memberAddress) || membershipManager.isShunned(memberAddress)) { // left the view
-          throw new IOException(LocalizedStrings.TCPConduit_PEER_HAS_DISAPPEARED_FROM_VIEW.toLocalizedString(remoteId));
+          throw new IOException(LocalizedStrings.TCPConduit_PEER_HAS_DISAPPEARED_FROM_VIEW.toLocalizedString(memberAddress));
-          new Object[] {m, problem}));
-          memberInTrouble = m;
+          new Object[] {memberAddress, problem}));
+          memberInTrouble = memberAddress;
-            logger.debug("Error sending message to {}", m, problem);
+            logger.debug("Error sending message to {}", memberAddress, problem);
-            IOException ioe = new IOException( LocalizedStrings.TCPConduit_PROBLEM_CONNECTING_TO_0.toLocalizedString(remoteId));
+            IOException ioe = new IOException( LocalizedStrings.TCPConduit_PROBLEM_CONNECTING_TO_0.toLocalizedString(memberAddress));
-          logger.trace("new connection is {} remoteId={} memberAddress={}", conn, remoteId, memberAddress);
-      }
+          logger.trace("new connection is {} memberAddress={}", conn, memberAddress);
+        }
-//   /**
-//    * Send a message.
-//    * @return the connection used to send the message
-//    * @throws IOException if peer departed view or shutdown in progress
-//    */
-//   private Connection send(Stub remoteId, ByteBuffer bb, boolean preserveOrder, DistributionMessage msg)
-//     throws java.io.IOException
-//   {
-//     if (stopped) {
-//       throw new ConduitStoppedException("The conduit is stopped");
-//     }
-
-//     if (!QUIET) {
-//       LogWriterI18n l = getLogger();
-//       if (l.finerEnabled()) {
-//         l.finer(id.toString() + " sending " + bb
-//                 + " to " + remoteId);
-//       }
-//     }
-
-//     Connection conn = null;
-//     InternalDistributedMember memberInTrouble = null;
-//     for (;;) {
-//       // If this is the second time through this loop, we had
-//       // problems.  Tear down the connection so that it gets
-//       // rebuilt.
-//       if (conn != null) { // not first time in loop
-//         // Consult with the membership manager; if member has gone away,
-//         // there will not be an entry for this stub.
-//         InternalDistributedMember m = membershipManager.getMemberForStub(remoteId);
-//         if (m == null) {
-//           // OK, the member left.  Just register an error.
-//           throw new IOException("TCP/IP connection lost and member no longer in view");
-//         }
-//         // bug35953: Member is still in view; we MUST NOT give up!
-        
-//         // Pause just a tiny bit...
-//         try {
-//           Thread.sleep(5000);
-//         }
-//         catch (InterruptedException e) {
-//           Thread.currentThread().interrupt();
-//           if (membershipManager.shutdownInProgress()) { // shutdown in progress
-//             // Bracket our original warning
-//             if (memberInTrouble != null) {
-//               logger.info("Ending retry attempt because shutdown has started.");
-//             }
-//             throw new IOException("Abandoned because shutdown is in progress");
-//           } // shutdown in progress
-          
-//           // Strange random interrupt intercepted?
-//           logger.warning("Thread has been interrupted but no shutdown in progress", e);
-//           throw new DistributedSystemDisconnectedException(e);
-//         }
-        
-//         // Print a warning (once)
-//         if (memberInTrouble == null) {
-//           memberInTrouble = m;
-//           getLogger().warning("Attempting TCP/IP reconnect to " + memberInTrouble); 
-//         }
-//         else {
-//           getLogger().fine("Attempting TCP/IP reconnect to " + memberInTrouble);
-//         }
-        
-//         // Close the connection (it will get rebuilt later).
-//         this.stats.incReconnectAttempts();
-//         try { 
-//           conn.closeForReconnect("closing before retrying"); 
-//           } 
-//         catch (CancelException ex) {
-//           // In general we ignore close problems, but if the system
-//           // is shutting down, we should just quit.
-//           throw ex;
-//         }
-//         catch (Exception ex) {
-//           }
-//       } // not first time in loop
-      
-//       // Do the send
-//       Exception problem = null;
-//       try {
-//         // Get (or regenerate) the connection
-//         // bug36202: this could generate a ConnectionException, so it
-//         // must be caught and retried
-//         conn = getConTable().get(remoteId, preserveOrder);
-//         //      getLogger().info ("connections returned " + conn);
-//         if (conn == null) {
-//           // conduit may be closed - otherwise an ioexception would be thrown
-//           throw new IOException("Unable to reconnect to server; possible shutdown: " 
-//               + remoteId);
-//         }
-
-//         conn.sendPreserialized(bb, msg);
-//       }
-//       catch (ConnectionException e) {
-//         // Race condition between acquiring the connection and attempting
-//         // to use it: another thread closed it.
-//         problem = e;
-//       }
-//       catch (IOException e) {
-//         problem = e;
-//       }
-
-//       if (problem != null) {
-//         // Some problems are not recoverable; check an error out early.
-//         InternalDistributedMember m = membershipManager.getMemberForStub(remoteId);
-//         if (m == null) { // left the view
-//           // Bracket our original warning
-//           if (memberInTrouble != null) {
-//             logger.info("Ending retry attempt because " + memberInTrouble 
-//                 + " has disappeared.");
-//           }
-//           throw new IOException("Peer has disappeared from view");
-//         } // left the view
-        
-//         if (membershipManager.shutdownInProgress()) { // shutdown in progress
-//           // Bracket our original warning
-//           if (memberInTrouble != null) {
-//             logger.info("Ending retry attempt because shutdown has started.");
-//           }
-//           throw new IOException("Abandoned because shutdown is in progress");
-//         } // shutdown in progress
-        
-//         if (endpointRemoved(remoteId)) { // endpoint removed
-//           // TODO what does this mean?
-//           // Bracket our original warning
-//           if (memberInTrouble != null) {
-//             logger.info("Ending retry attempt because " + memberInTrouble 
-//                 + " has lost its endpoint.");
-//           }
-//           throw new IOException("Endpoint was removed");
-//         } // endpoint removed
-        
-//         // Log the warning.  We wait until now, because we want
-//         // to have m defined for a nice message...
-//         if (memberInTrouble == null) {
-//           logger.warning(
-//               "Error sending message to " + m + " (will reattempt): " 
-//                   + problem.toString(), 
-//               logger.finerEnabled() ? problem : null);
-//           memberInTrouble = m;
-//         }
-//         else {
-//           logger.fine("Error sending message to " + m, problem);
-//         }
-        
-//         // Retry the operation (indefinitely)
-//         continue;
-//       } // problem != null
-//       // Success!
-      
-//       // Make sure our logging is bracketed if there was a problem
-//       if (memberInTrouble != null) {
-//         logger.info("Successfully reestablished connection to server " 
-//             + memberInTrouble);
-//       }
-//       return conn;
-//     } // while retry
-//   }
-
-//   /**
-//    * Sends an already serialized message in a byte buffer
-//    * to the given endpoint. Waits for the send to complete
-//    * before returning.
-//    * @return the connection used to send the message
-//    */
-//   public Connection sendSync(Stub remoteId, ByteBuffer bb, int processorType, DistributionMessage msg)
-//     throws java.io.IOException
-//   {
-//     return send(remoteId, bb,
-//                 processorType == DistributionManager.SERIAL_EXECUTOR,
-//                 msg);
-//   }
-
-   * Closes any connections used to communicate with the given stub
+   * Closes any connections used to communicate with the given member
-  public void removeEndpoint(Stub stub, String reason) {
-    removeEndpoint(stub, reason, true);
+  public void removeEndpoint(DistributedMember mbr, String reason) {
+    removeEndpoint(mbr, reason, true);
-  public void removeEndpoint(Stub stub, String reason, boolean notifyDisconnect) {
+  public void removeEndpoint(DistributedMember mbr, String reason, boolean notifyDisconnect) {
-    ct.removeEndpoint(stub, reason, notifyDisconnect);
+    ct.removeEndpoint(mbr, reason, notifyDisconnect);
-  public boolean hasReceiversFor(Stub endPoint) {
+  public boolean hasReceiversFor(DistributedMember endPoint) {

INS26 INS26 INS40 INS40 UPD43 UPD43 UPD42 UPD66 UPD42 UPD43 UPD43 UPD43 UPD43 UPD42 UPD43 UPD42 UPD43 UPD42 UPD43 UPD66 UPD42 UPD42 UPD42 UPD42 UPD66 UPD66 UPD66 UPD42 UPD42 UPD42 INS21 UPD42 UPD42 INS32 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 UPD43 INS42 INS42 MOV25 MOV54 UPD42 UPD45 MOV21 UPD27 UPD27 UPD27 UPD42 INS38 INS32 INS32 INS38 INS32 INS38 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42 INS42 INS42 MOV43 UPD42 UPD45 UPD42 UPD42 MOV43 UPD42 UPD42 MOV43 UPD45 UPD42 UPD42 DEL66 DEL34 DEL66 DEL66 DEL65 DEL42 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL52 DEL32 DEL40 DEL42 DEL42 DEL40 DEL32 DEL8 DEL25 DEL52 DEL32 DEL42 DEL42 DEL32 DEL66 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL9 DEL32 DEL7 DEL21 DEL42 DEL33 DEL42 DEL33 DEL42 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL9 DEL32 DEL59 DEL60 DEL42 DEL33 DEL42
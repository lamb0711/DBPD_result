Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A Bag constrained to contain Structs of all the same type. To conserve on
- * objects, we store the StructType once and reuse it to generate Struct
- * instances on demand.
+ * A Bag constrained to contain Structs of all the same type. To conserve on objects, we store the
+ * StructType once and reuse it to generate Struct instances on demand.
- * The values in this set are stored as Object[] and get wrapped in Structs as
- * necessary.
+ * The values in this set are stored as Object[] and get wrapped in Structs as necessary.
-        throw new ClassCastException(LocalizedStrings.StructBag_EXPECTED_AN_OBJECT_BUT_ACTUAL_IS_0.toLocalizedString(o.getClass().getName()));
+        throw new ClassCastException(LocalizedStrings.StructBag_EXPECTED_AN_OBJECT_BUT_ACTUAL_IS_0
+            .toLocalizedString(o.getClass().getName()));
-        if (obj != null) h += obj.hashCode();
+        if (obj != null)
+          h += obj.hashCode();
-        if (o1 == null) return o2 == null;
-        if (!(o1 instanceof Object[]) || !(o2 instanceof Object[])) {
-          return o1.equals(o2);
-        } 
+      if (o1 == null)
+        return o2 == null;
+      if (!(o1 instanceof Object[]) || !(o2 instanceof Object[])) {
+        return o1.equals(o2);
+      }
-    
+
-    
-  }
-  
-  /** Creates a new instance of StructBag
-   * @param stats the CachePerfStats to track hash collisions. Should
-   * be null unless this is used as a query execution-time result set.
+  }
+
+
+  /**
+   * Creates a new instance of StructBag
+   * 
+   * @param stats the CachePerfStats to track hash collisions. Should be null unless this is used as
+   *        a query execution-time result set.
-    if (structType == null) { throw new IllegalArgumentException(LocalizedStrings.StructBag_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString()); }
+    if (structType == null) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructBag_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString());
+    }
-   * @param stats the CachePerfStats to track hash collisions. Should
-   * be null unless this is used as a query execution-time result set.
+   * @param stats the CachePerfStats to track hash collisions. Should be null unless this is used as
+   *        a query execution-time result set.
-    if (structType == null) { throw new IllegalArgumentException(LocalizedStrings.StructBag_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString()); }
+    if (structType == null) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructBag_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString());
+    }
-   * @param stats the CachePerfStats to track hash collisions. Should
-   * be null unless this is used as a query execution-time result set.
+   * @param stats the CachePerfStats to track hash collisions. Should be null unless this is used as
+   *        a query execution-time result set.
-  public StructBag(int initialCapacity,
-                   StructType structType,
-                   CachePerfStats stats) {
+  public StructBag(int initialCapacity, StructType structType, CachePerfStats stats) {
-    if (structType == null) { throw new IllegalArgumentException(LocalizedStrings.StructBag_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString()); }
+    if (structType == null) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructBag_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString());
+    }
-   * @param stats the CachePerfStats to track hash collisions. Should
-   * be null unless this is used as a query execution-time result set.
+   * @param stats the CachePerfStats to track hash collisions. Should be null unless this is used as
+   *        a query execution-time result set.
-  public StructBag(int initialCapacity,
-                   float loadFactor,
-                   StructType structType,
-                   CachePerfStats stats) {
+  public StructBag(int initialCapacity, float loadFactor, StructType structType,
+      CachePerfStats stats) {
-    if (structType == null) { throw new IllegalArgumentException(LocalizedStrings.StructBag_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString()); }
+    if (structType == null) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructBag_STRUCTTYPE_MUST_NOT_BE_NULL.toLocalizedString());
+    }
-  
+
-  
+
-      throw new IllegalArgumentException(LocalizedStrings.StructBag_THIS_SET_ONLY_ACCEPTS_STRUCTIMPL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructBag_THIS_SET_ONLY_ACCEPTS_STRUCTIMPL.toLocalizedString());
-      throw new IllegalArgumentException(LocalizedStrings.StructBag_OBJ_DOES_NOT_HAVE_THE_SAME_STRUCTTYPE.
-          toLocalizedString(this.elementType, s.getStructType()));
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructBag_OBJ_DOES_NOT_HAVE_THE_SAME_STRUCTTYPE
+              .toLocalizedString(this.elementType, s.getStructType()));
-    if (!(obj instanceof Struct)) { return false; }
+    if (!(obj instanceof Struct)) {
+      return false;
+    }
-    if (!this.elementType.equals(StructTypeImpl.typeFromStruct(s))) { return false; }
+    if (!this.elementType.equals(StructTypeImpl.typeFromStruct(s))) {
+      return false;
+    }
-   * Does this set contain a Struct of the correct type with the specified
-   * values?
+   * Does this set contain a Struct of the correct type with the specified values?
-        if (Arrays.equals((Object[])fieldItr.next(), fieldValues)) {
+        if (Arrays.equals((Object[]) fieldItr.next(), fieldValues)) {
-    }
-    else {
+    } else {
-  
+
-    Struct s = (Struct)element;
+    Struct s = (Struct) element;
-        Object[] structFields = (Object[])itr.next();
+        Object[] structFields = (Object[]) itr.next();
-        }
-        else if (encounteredObject) {
+        } else if (encounteredObject) {
-    }
-    else {
+    } else {
-  
-  public int occurrences(Object[] element) {    
+
+  public int occurrences(Object[] element) {
-  
+
-    if (!(o instanceof Struct)) { return false; }
+    if (!(o instanceof Struct)) {
+      return false;
+    }
-    if (!this.elementType.equals(StructTypeImpl.typeFromStruct(s))) { return false; }
+    if (!this.elementType.equals(StructTypeImpl.typeFromStruct(s))) {
+      return false;
+    }
-        if (Arrays.equals((Object[])fieldItr.next(), fieldValues)) {
+        if (Arrays.equals((Object[]) fieldItr.next(), fieldValues)) {
-    }
-    else {
+    } else {
-  
+
-    if (c instanceof StructFields) { return addAll((StructFields) c); }
+    if (c instanceof StructFields) {
+      return addAll((StructFields) c);
+    }
-    if (c instanceof StructFields) { return removeAll((StructFields) c); }
+    if (c instanceof StructFields) {
+      return removeAll((StructFields) c);
+    }
-    if (c instanceof StructFields) { return retainAll((StructFields) c); }
+    if (c instanceof StructFields) {
+      return retainAll((StructFields) c);
+    }
-      throw new IllegalArgumentException(LocalizedStrings.StructBag_TYPES_DONT_MATCH.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructBag_TYPES_DONT_MATCH.toLocalizedString());
-    
-    for (Iterator itr = sb.fieldValuesIterator(); itr.hasNext();) {      
+
+    for (Iterator itr = sb.fieldValuesIterator(); itr.hasNext();) {
-      Object[] vals = (Object[])itr.next();
+      Object[] vals = (Object[]) itr.next();
-      }
-      else {
+      } else {
-  /** Return an iterator over the elements in this collection. Duplicates
-    *  will show up the number of times it has occurrances.
-    */
+  /**
+   * Return an iterator over the elements in this collection. Duplicates will show up the number of
+   * times it has occurrances.
+   */
-      throw new IllegalArgumentException(LocalizedStrings.StructBag_ELEMENT_TYPE_MUST_BE_STRUCT.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.StructBag_ELEMENT_TYPE_MUST_BE_STRUCT.toLocalizedString());
-  
+
-  
+
-  
+
-  
-  void writeNumNulls(DataOutput out) {    
-  }
-  
-  void readNumNulls(DataInput in) {    
-  }
+
+  void writeNumNulls(DataOutput out) {}
+
+  void readNumNulls(DataInput in) {}
-      return new StructImpl((StructTypeImpl)StructBag.this.elementType,
-                            (Object[]) this.itr.next());
+      return new StructImpl((StructTypeImpl) StructBag.this.elementType,
+          (Object[]) this.itr.next());

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66
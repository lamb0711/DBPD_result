GEODE-5393: StateFlushOperation hangs waiting for non-existant operation to complete

I've added additional debugging to DistributionAdvisor so that it knows
which threads are performing operations and can log them at debug level.
This let me determine that a putAll operation was the source of the hang
due to an exception being thrown during message distribution in
DistributedCacheOperation.startOperation().  The exception resulted in
DistributionAdvisor.endOperation() not being invoked correctly.

+import java.io.OutputStream;
+import java.io.PrintStream;
-   * This system property is not supported and disabling intelligent messaging is currently
-   * problematic
+   * The operationMonitor tracks in-progress cache operations and holds the profile set
+   * version number
-  protected static final boolean disabled = Boolean.getBoolean("disable-intelligent-msg");
-
+  private final OperationMonitor operationMonitor =
+      logger.isDebugEnabled() ? new ThreadTrackingOperationMonitor(this)
+          : new OperationMonitor(this);
-   * the version of the profile set
-   *
-   * @since GemFire 5.1
-   */
-  private long membershipVersion;
-
-  /**
-   * opCountLock guards access to previousVersionOpCount and currentVersionOpCount
-   */
-  private final Object opCountLock = new Object();
-
-  /**
-   * the number of operations in-progress for previous versions of the profile set. Guarded by
-   * opCountLock
-   */
-  private long previousVersionOpCount;
-
-  /**
-   * the number of operations in-progress for the current version of the profile set. Guarded by
-   * opCountLock
-   */
-  private long currentVersionOpCount;
-
-  /**
-        synchronized (this.opCountLock) {
-          this.previousVersionOpCount = 0;
-          this.currentVersionOpCount = 0;
-        }
+        operationMonitor.close();
+
-          membershipVersion++;
-          if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP_VERBOSE)) {
-            logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,
-                "StateFlush incremented membership version: {}", membershipVersion);
-          }
-          newProfile.initialMembershipVersion = membershipVersion;
-          synchronized (this.opCountLock) {
-            previousVersionOpCount += currentVersionOpCount;
-            currentVersionOpCount = 0;
-          }
+          operationMonitor.initNewProfile(newProfile);
-      forceNewMembershipVersion();
+      operationMonitor.forceNewMembershipVersion();
-  public synchronized void forceNewMembershipVersion() {
-    if (!membershipClosed) {
-      membershipVersion++;
-      if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP_VERBOSE)) {
-        logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,
-            "StateFlush forced new membership version: {}", membershipVersion);
-      }
-      synchronized (this.opCountLock) {
-        previousVersionOpCount += currentVersionOpCount;
-        currentVersionOpCount = 0;
-        if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_STATE_FLUSH_VERBOSE)) {
-          logger.trace(LogMarker.DISTRIBUTION_STATE_FLUSH_VERBOSE,
-              "advisor for {} forced new membership version to {} previousOpCount={}", getAdvisee(),
-              membershipVersion, previousVersionOpCount);
-        }
-      }
-    }
+  public void forceNewMembershipVersion() {
+    operationMonitor.forceNewMembershipVersion();
-  public synchronized long startOperation() {
-    if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_STATE_FLUSH_VERBOSE)) {
-      logger.trace(LogMarker.DISTRIBUTION_STATE_FLUSH_VERBOSE,
-          "startOperation() op count is now {} in view version {}", currentVersionOpCount + 1,
-          membershipVersion);
-    }
-    synchronized (this.opCountLock) {
-      currentVersionOpCount++;
-      if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP_VERBOSE)) {
-        logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE, "StateFlush current opcount incremented: {}",
-            currentVersionOpCount);
-      }
-    }
-    return membershipVersion;
+  public long startOperation() {
+    return operationMonitor.startOperation();
-  public synchronized long endOperation(long version) {
-    synchronized (this.opCountLock) {
-      if (version == membershipVersion) {
-        currentVersionOpCount--;
-        if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP_VERBOSE)) {
-          logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,
-              "StateFlush current opcount deccremented: {}", currentVersionOpCount);
-        }
-      } else {
-        previousVersionOpCount--;
-        if (logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP_VERBOSE)) {
-          logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,
-              "StateFlush previous opcount incremented: {}", previousVersionOpCount);
-        }
-      }
-    }
-    return membershipVersion;
+  public void endOperation(long version) {
+    operationMonitor.endOperation(version);
-    long timeout =
-        1000L * this.getDistributionManager().getSystem().getConfig().getAckWaitThreshold();
-    waitForCurrentOperations(logger, timeout, timeout * 2L);
+    operationMonitor.waitForCurrentOperations();
-    final long startTime = System.currentTimeMillis();
-    final long warnTime = startTime + warnMS;
-    final long severeAlertTime = startTime + severeAlertMS;
-    boolean warned = false;
-    boolean severeAlertIssued = false;
-    final boolean isDebugEnabled_STATE_FLUSH_OP =
-        DistributionAdvisor.logger.isTraceEnabled(LogMarker.STATE_FLUSH_OP_VERBOSE);
-    while (true) {
-      long opCount;
-      synchronized (this.opCountLock) {
-        opCount = this.previousVersionOpCount;
-      }
-      if (opCount <= 0) {
-        if (warned) {
-          alertLogger.info("Wait for current operations completed");
-        }
-        break;
-      }
-      // The advisor's close() method will set the pVOC to zero. This loop
-      // must not terminate due to cache closure until that happens.
-      // See bug 34361 comment 79
-      if (isDebugEnabled_STATE_FLUSH_OP) {
-        DistributionAdvisor.logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,
-            "Waiting for current operations to finish({})", opCount);
-      }
-      try {
-        Thread.sleep(50);
-      } catch (InterruptedException e) {
-        throw new GemFireIOException("State flush interrupted");
-      }
-      long now = System.currentTimeMillis();
-      if ((!warned) && System.currentTimeMillis() >= warnTime) {
-        warned = true;
-        alertLogger.warn("This operation has been stalled for {} milliseconds waiting for "
-            + "current operations to complete.", warnMS);
-      } else if (warned && !severeAlertIssued && (now >= severeAlertTime)) {
-        // OSProcess.printStacks(0);
-        alertLogger.fatal("This operation has been stalled for {} milliseconds "
-            + "waiting for current operations to complete.  Something may be blocking operations.",
-            severeAlertMS);
-        severeAlertIssued = true;
-      }
-    }
-    if (this.membershipClosed) {
-      if (isDebugEnabled_STATE_FLUSH_OP) {
-        DistributionAdvisor.logger.trace(LogMarker.STATE_FLUSH_OP_VERBOSE,
-            "State Flush stopped waiting for operations to distribute because advisor has been closed");
-      }
-    }
+    operationMonitor.waitForCurrentOperations(alertLogger, warnMS, severeAlertMS);
-    if (disabled) {
-      if (logger.isDebugEnabled()) {
-        logger.debug("Intelligent Messaging Disabled");
-      }
-      return getDefaultDistributionMembers();
-    }
-    if (disabled) {
-      if (logger.isDebugEnabled()) {
-        logger.debug("Intelligent Messaging Disabled");
-      }
-      return !getDefaultDistributionMembers().isEmpty();
-    }
+
+
+
+  private static class OperationMonitor {
+    private final DistributionAdvisor distributionAdvisor;
+
+    /**
+     * the version of the profile set
+     */
+    private long membershipVersion;
+
+    /**
+     * the number of operations in-progress for previous versions of the profile set
+     */
+    private long previousVersionOpCount;
+    /**
+     * the number of operations in-progress for the current version of the profile set
+     */
+    private long currentVersionOpCount;
+
+    /**
+     * for debugging stalled state-flush operations we track threads performing operations
+     * and capture the state when startOperatiopn is invoked
+     */
+    private boolean closed;
+
+    private OperationMonitor(DistributionAdvisor distributionAdvisor) {
+      this.distributionAdvisor = distributionAdvisor;
+    }
+
+    private synchronized void incrementMembershipVersion() {
+      membershipVersion++;
+    }
+
+    /**
+     * Create a new version of the membership profile set. This is used in flushing state out of the
+     * VM for previous versions of the set.
+     *
+     * @since GemFire 5.1
+     */
+    synchronized void forceNewMembershipVersion() {
+      if (!closed) {
+        incrementMembershipVersion();
+        previousVersionOpCount += currentVersionOpCount;
+        currentVersionOpCount = 0;
+        membershipVersionChanged();
+      }
+    }
+
+    /**
+     * this method must be invoked at the start of every operation that can modify the state of
+     * resource. The return value must be recorded and sent to the advisor in an endOperation
+     * message when messages for the operation have been put in the DistributionManager's outgoing
+     * "queue".
+     *
+     * @return the current membership version for this advisor
+     * @since GemFire 5.1
+     */
+    synchronized long startOperation() {
+      logNewOperation();
+      currentVersionOpCount++;
+      return membershipVersion;
+    }
+
+    /**
+     * This method must be invoked when messages for an operation have been put in the
+     * DistributionManager's outgoing queue.
+     *
+     * @param version The membership version returned by startOperation
+     * @since GemFire 5.1
+     */
+    synchronized void endOperation(long version) {
+      if (version == membershipVersion) {
+        currentVersionOpCount--;
+        logEndOperation(true);
+      } else {
+        previousVersionOpCount--;
+        logEndOperation(false);
+      }
+    }
+
+    /**
+     * wait for the current operations being sent on views prior to the joining of the given member
+     * to be placed on communication channels before returning
+     *
+     * @since GemFire 5.1
+     */
+    void waitForCurrentOperations() {
+      long timeout =
+          1000L * distributionAdvisor.getDistributionManager().getSystem().getConfig()
+              .getAckWaitThreshold();
+      waitForCurrentOperations(logger, timeout, timeout * 2L);
+    }
+
+    void waitForCurrentOperations(Logger alertLogger, long warnMS, long severeAlertMS) {
+      // this may wait longer than it should if the membership version changes, dumping
+      // more operations into the previousVersionOpCount
+      final long startTime = System.currentTimeMillis();
+      final long warnTime = startTime + warnMS;
+      final long severeAlertTime = startTime + severeAlertMS;
+      boolean warned = false;
+      boolean severeAlertIssued = false;
+      while (operationsAreInProgress()) {
+        // The advisor's close() method will set the pVOC to zero. This loop
+        // must not terminate due to cache closure until that happens.
+        try {
+          Thread.sleep(50);
+        } catch (InterruptedException e) {
+          throw new GemFireIOException("State flush interrupted");
+        }
+        long now = System.currentTimeMillis();
+        if ((!warned) && System.currentTimeMillis() >= warnTime) {
+          warned = true;
+          logWaitOnOperationsWarning(alertLogger, warnMS);
+        } else if (warned && !severeAlertIssued && (now >= severeAlertTime)) {
+          logWaitOnOperationsSevere(alertLogger, severeAlertMS);
+          severeAlertIssued = true;
+        }
+      }
+      if (warned) {
+        alertLogger.info("Wait for current operations completed");
+      }
+    }
+
+    synchronized boolean operationsAreInProgress() {
+      return previousVersionOpCount > 0;
+    }
+
+    synchronized void initNewProfile(Profile newProfile) {
+      membershipVersion++;
+      newProfile.initialMembershipVersion = membershipVersion;
+      previousVersionOpCount =
+          previousVersionOpCount + currentVersionOpCount;
+      currentVersionOpCount = 0;
+      membershipVersionChanged();
+    }
+
+    synchronized void close() {
+      previousVersionOpCount = 0;
+      currentVersionOpCount = 0;
+      closed = true;
+    }
+
+    void logNewOperation() {}
+
+    void logEndOperation(boolean newOperation) {}
+
+    void logWaitOnOperationsSevere(Logger alertLogger, long severeAlertMS) {
+      // OSProcess.printStacks(0);
+      alertLogger.fatal("This thread has been stalled for {} milliseconds "
+          + "waiting for current operations to complete.  Something may be blocking operations.",
+          severeAlertMS);
+    }
+
+    void logWaitOnOperationsWarning(Logger alertLogger, long warnMS) {
+      alertLogger.warn("This thread has been stalled for {} milliseconds waiting for "
+          + "current operations to complete.", warnMS);
+    }
+
+    void membershipVersionChanged() {}
+
+  }
+
+  private static class ThreadTrackingOperationMonitor extends OperationMonitor {
+
+    /**
+     * for debugging stalled state-flush operations we track threads performing operations
+     * and capture the state when startOperatiopn is invoked
+     */
+    private final Map<Thread, ExceptionWrapper> currentVersionOperationThreads;
+    private final Map<Thread, ExceptionWrapper> previousVersionOperationThreads;
+
+    private ThreadTrackingOperationMonitor(
+        DistributionAdvisor distributionAdvisor) {
+      super(distributionAdvisor);
+      this.currentVersionOperationThreads = new HashMap<>();
+      this.previousVersionOperationThreads = new HashMap<>();
+    }
+
+    @Override
+    void logNewOperation() {
+      currentVersionOperationThreads.put(Thread.currentThread(),
+          new ExceptionWrapper(new Exception("stack trace")));
+    }
+
+    @Override
+    void logEndOperation(boolean newOp) {
+      if (newOp) {
+        currentVersionOperationThreads.remove(Thread.currentThread());
+      } else {
+        previousVersionOperationThreads.remove(Thread.currentThread());
+      }
+    }
+
+    @Override
+    void logWaitOnOperationsWarning(Logger alertLogger, long warnMS) {
+      super.logWaitOnOperationsWarning(alertLogger, warnMS);
+      synchronized (this) {
+        logger
+            .debug("Waiting for these threads: {}", previousVersionOperationThreads);
+        logger
+            .debug("New version threads are {}", currentVersionOperationThreads);
+      }
+    }
+
+    @Override
+    void logWaitOnOperationsSevere(Logger alertLogger, long severeAlertMS) {
+      super.logWaitOnOperationsSevere(alertLogger, severeAlertMS);
+      synchronized (this) {
+        logger
+            .debug("Waiting for these threads: {}", previousVersionOperationThreads);
+        logger
+            .debug("New version threads are {}", currentVersionOperationThreads);
+      }
+    }
+
+    @Override
+    void membershipVersionChanged() {
+      super.membershipVersionChanged();
+      previousVersionOperationThreads
+          .putAll(currentVersionOperationThreads);
+      currentVersionOperationThreads.clear();
+    }
+
+
+    /**
+     * ExceptionWrapper is used in debugging hangs in waitForCurrentOperations(). It
+     * captures the call stack of a thread invoking startOperation().
+     */
+    private static class ExceptionWrapper {
+      private Exception exception;
+
+      ExceptionWrapper(Exception exception) {
+        this.exception = exception;
+      }
+
+      @Override
+      public String toString() {
+        StringBuilder builder = new StringBuilder(500);
+        OutputStream os = new OutputStream() {
+          @Override
+          public void write(int i) {
+            builder.append((char) i);
+          }
+        };
+        PrintStream stream = new PrintStream(os);
+        exception.printStackTrace(stream);
+        return builder.toString();
+      }
+    }
+
+  }
+

INS26 INS26 INS40 INS40 INS23 INS31 INS31 INS31 INS31 INS31 INS55 INS55 MOV29 UPD83 MOV83 INS83 INS43 INS59 MOV29 INS83 INS39 INS42 INS8 MOV29 INS83 INS39 INS42 INS8 INS29 INS83 INS39 INS42 INS44 INS8 MOV29 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS44 INS44 INS44 INS8 INS83 INS83 INS42 INS23 MOV23 MOV23 MOV23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 MOV31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS42 INS43 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS55 INS42 INS42 INS16 INS21 INS41 INS65 UPD65 MOV65 INS65 INS39 INS42 INS21 INS21 INS43 INS42 INS39 INS42 INS39 INS42 INS21 INS83 MOV83 UPD43 MOV43 MOV59 INS29 INS83 INS39 INS59 INS83 INS42 INS44 INS8 INS83 MOV83 MOV39 INS42 INS8 INS29 INS83 INS39 MOV42 INS8 INS29 INS83 INS39 INS42 INS8 MOV29 INS83 INS39 INS42 MOV44 INS8 INS29 INS39 INS42 INS8 INS83 INS39 INS42 INS8 UPD83 MOV83 INS39 INS42 INS44 INS8 MOV83 INS39 INS42 INS8 INS39 INS42 INS8 INS39 INS42 INS44 INS8 INS39 INS42 INS44 INS44 INS8 INS39 INS42 INS44 INS44 INS8 INS39 INS42 INS8 INS42 INS29 INS83 INS83 INS74 INS59 INS83 INS83 INS74 INS59 INS83 INS42 INS44 INS8 INS78 INS39 INS42 INS8 INS78 INS39 INS42 INS44 INS8 INS78 INS39 INS42 INS44 INS44 INS8 INS78 INS39 INS42 INS44 INS44 INS8 INS78 INS39 INS42 INS8 INS29 INS83 INS83 INS42 INS23 INS31 MOV31 UPD66 UPD66 MOV32 INS14 INS14 MOV8 INS32 INS32 INS66 INS66 INS42 UPD66 INS66 INS32 INS32 INS42 INS32 UPD42 UPD42 INS65 INS42 INS43 INS42 INS21 MOV21 INS65 INS65 INS25 INS65 INS65 INS65 INS21 MOV21 MOV41 MOV25 INS65 MOV65 INS60 MOV21 MOV25 INS41 INS43 INS42 MOV21 MOV21 INS21 INS21 INS21 INS21 MOV21 INS21 INS39 INS42 INS43 INS42 INS39 INS42 INS21 INS43 INS42 INS39 INS42 MOV21 INS65 INS43 INS43 INS43 INS42 INS43 INS43 INS43 INS42 INS43 INS42 INS46 INS21 INS21 INS42 INS21 INS42 INS39 INS42 MOV25 INS42 INS43 INS42 INS39 INS42 INS21 INS51 INS42 INS43 INS42 INS39 INS42 INS21 INS51 INS42 INS21 INS21 INS21 INS65 INS83 INS43 INS59 INS42 INS44 INS8 INS78 INS43 INS42 INS8 INS43 INS52 INS43 INS52 INS42 INS42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD66 UPD66 INS66 INS66 INS42 INS7 INS66 INS66 INS66 MOV38 INS8 INS66 INS66 INS66 INS66 INS66 INS66 INS32 MOV27 INS8 INS66 INS66 INS39 INS59 INS32 INS27 INS42 INS7 INS7 INS32 INS7 INS7 INS42 INS32 INS42 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS7 INS32 INS42 INS8 INS42 INS48 INS52 INS8 INS42 INS48 INS52 INS8 INS48 INS32 INS32 INS66 INS66 INS42 INS42 INS43 INS42 INS21 INS42 INS42 INS60 INS60 INS60 INS21 INS41 INS42 INS42 MOV27 MOV8 INS22 INS42 UPD42 INS21 MOV21 MOV21 INS21 INS42 MOV21 INS21 MOV21 INS42 INS27 INS42 INS42 INS34 INS42 INS27 INS42 INS34 INS42 INS42 INS34 INS42 INS9 UPD42 MOV42 UPD42 MOV42 INS27 INS42 UPD42 UPD42 UPD42 INS22 INS14 INS22 INS14 INS42 INS42 INS32 INS14 INS21 INS42 INS42 INS42 INS21 MOV21 INS42 INS42 INS42 INS21 MOV21 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS43 INS59 INS43 INS59 INS43 INS59 INS32 INS32 INS21 INS42 INS52 INS42 INS32 INS32 INS32 INS34 INS32 INS42 INS42 INS45 INS45 INS45 INS45 MOV52 UPD42 MOV42 INS74 INS52 INS42 INS74 INS42 INS42 INS43 INS14 INS32 INS32 INS32 INS22 INS42 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS32 MOV38 INS42 INS42 UPD42 MOV42 INS9 UPD42 INS9 INS32 UPD42 MOV42 INS43 INS43 INS42 INS43 INS45 UPD42 MOV42 INS42 INS32 UPD42 UPD42 INS32 MOV42 UPD42 MOV42 INS45 INS42 UPD42 UPD45 UPD42 MOV42 UPD42 MOV42 INS45 INS42 UPD42 UPD45 UPD42 INS52 INS42 INS43 INS34 INS43 INS1 INS43 INS42 INS42 INS42 INS32 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS42 INS42 INS31 INS42 INS32 UPD42 MOV42 INS42 INS78 INS83 MOV39 UPD42 MOV42 INS44 INS8 UPD42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS39 INS42 INS21 INS32 UPD42 MOV42 INS42 INS11 INS39 INS42 DEL83 DEL83 DEL39 DEL42 DEL45 DEL32 DEL59 DEL23 DEL29 DEL83 DEL23 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL8 DEL51 DEL42 DEL42 DEL40 DEL32 DEL40 DEL45 DEL52 DEL42 DEL22 DEL42 DEL42 DEL7 DEL21 DEL8 DEL51 DEL25 DEL8 DEL83 DEL52 DEL42 DEL22 DEL40 DEL32 DEL40 DEL45 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL51 DEL8 DEL25 DEL8 DEL31 DEL39 DEL42 DEL40 DEL32 DEL8 DEL25 DEL22 DEL8 DEL51 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL40 DEL32 DEL8 DEL25 DEL8 DEL40 DEL32 DEL8 DEL25 DEL8 DEL25 DEL8 DEL51 DEL42 DEL41 DEL8 DEL31 DEL42 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL42 DEL32 DEL41 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL42 DEL32 DEL42 DEL32 DEL38 DEL41 DEL8 DEL25 DEL42 DEL43 DEL14 DEL66 DEL66 DEL42 DEL40 DEL32 DEL42 DEL40 DEL45 DEL42 DEL83 DEL83 DEL39 DEL42 DEL40 DEL42 DEL40 DEL32 DEL59 DEL60 DEL9 DEL39 DEL42 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL7 DEL21 DEL8 DEL51 DEL42 DEL34 DEL27 DEL10 DEL8 DEL25 DEL42 DEL40 DEL42 DEL40 DEL45 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL45 DEL45 DEL27 DEL42 DEL45 DEL45 DEL27 DEL52 DEL42 DEL22 DEL42 DEL40 DEL42 DEL40 DEL45 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL40 DEL45 DEL42 DEL34 DEL40 DEL32 DEL40 DEL45 DEL40 DEL40 DEL39 DEL42 DEL34 DEL52 DEL32 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL27 DEL59 DEL60 DEL8
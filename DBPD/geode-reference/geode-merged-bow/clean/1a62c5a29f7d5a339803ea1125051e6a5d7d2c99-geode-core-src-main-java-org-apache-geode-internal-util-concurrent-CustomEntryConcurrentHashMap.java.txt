GEODE-5653: Synchronize and free GatewaySenderEvents in background thâ€¦ (#2407)

   * Synchronize and free GatewaySenderEvents in background thread
   * Await off-heap release in test

+import org.apache.geode.internal.cache.tier.sockets.command.KeySet;
+ * <p>
+ * Modifications made to the Java {@link java.util.Hashtable} implementation
+ * are indicated using comments to mark the beginning and end of Geode changes.
+ *
-  // GemStone addition
+  // Geode addition
-  // End GemStone addition
+  // End Geode addition
-  transient Set<Map.Entry<K, V>> reusableEntrySet; // GemStone addition
+  transient Set<Map.Entry<K, V>> reusableEntrySet; // Geode addition
-  // GemStone addition
-  // GemStone changed HashEntry to be an interface with original HashEntry
+  // Geode addition
+  // Geode changed HashEntry to be an interface with original HashEntry
-  // End GemStone addition
+  // End Geode addition
-    // GemStone addition
+    // Geode addition
-    // End GemStone addition
+    // End Geode addition
-    // GemStone added the method below
+    // Geode added the method below
-        // GemStone change to acquire the read lock on list updates
+        // Geode change to acquire the read lock on list updates
-        // GemStone change to acquire the read lock on list updates
+        // Geode change to acquire the read lock on list updates
-        // GemStone change to acquire the read lock on list updates
+        // Geode change to acquire the read lock on list updates
-        // GemStone change to acquire the read lock on list updates
+        // Geode change to acquire the read lock on list updates
-                // GemStone changes BEGIN
+                // Geode changes BEGIN
-                // GemStone changes END
+                // Geode changes END
-    // GemStone additions
+    // Geode additions
-    // End GemStone additions
+    // End Geode additions
-            // GemStone changes BEGIN
+            // Geode changes BEGIN
-            // GemStone changes END
+            // Geode changes END
-    // GemStone change
+    // Geode change
-      // End GemStone change
+      // End Geode change
-        // GemStone change
+        // Geode change
-          // GemStone change
+          // Geode change
-            // End GemStone change
+            // End Geode change
-            // GemStone changes BEGIN
+            // Geode changes BEGIN
-            // GemStone changes END
+            // Geode changes END
-     * GemStone added the clearedEntries param and the result
+     * Geode added the clearedEntries param and the result
-          // GemStone changes BEGIN
-          boolean collectEntries = clearedEntries != null;
-          if (!collectEntries) {
-            // see if we have a map with off-heap region entries
-            for (HashEntry<K, V> he : tab) {
-              if (he != null) {
-                collectEntries = he instanceof OffHeapRegionEntry;
-                if (collectEntries) {
-                  clearedEntries = new ArrayList<HashEntry<?, ?>>();
+          // Geode changes BEGIN
+          if (clearedEntries == null) {
+            final boolean checkForGatewaySenderEvent =
+                OffHeapRegionEntryHelper.doesClearNeedToCheckForOffHeap();
+            if (checkForGatewaySenderEvent) {
+              clearedEntries = new ArrayList<HashEntry<?, ?>>();
+            } else {
+              // see if we have a map with off-heap region entries
+              for (HashEntry<K, V> he : tab) {
+                if (he != null) {
+                  if (he instanceof OffHeapRegionEntry) {
+                    clearedEntries = new ArrayList<HashEntry<?, ?>>();
+                  }
+                  // after the first non-null entry we are done
+                  break;
-                // after the first non-null entry we are done
-                break;
-          final boolean checkForGatewaySenderEvent =
-              OffHeapRegionEntryHelper.doesClearNeedToCheckForOffHeap();
-          final boolean skipProcessOffHeap = !collectEntries && !checkForGatewaySenderEvent;
-          if (skipProcessOffHeap) {
+          if (clearedEntries == null) {
-              if (collectEntries) {
-                clearedEntries.add(he);
-              } else {
-                for (HashEntry<K, V> p = he; p != null; p = p.getNextEntry()) {
-                  if (p instanceof RegionEntry) {
-                    // It is ok to call GatewaySenderEventImpl release without being synced
-                    // on the region entry. It will not create an orphan.
-                    GatewaySenderEventImpl.release(((RegionEntry) p).getValue()); // OFFHEAP
-                                                                                  // _getValue ok
-                  }
-                }
-              }
+              clearedEntries.add(he);
-            // GemStone changes END
+            // Geode changes END
-      return clearedEntries; // GemStone change
+      return clearedEntries; // Geode change
-  // GemStone addition
+  // Geode addition
-  // End GemStone addition
+  // End Geode addition
-  // GemStone addition
+  // Geode addition
-  // End GemStone addition
+  // End Geode addition
-  // GemStone addition
+  // Geode addition
-        final Runnable runnable = new Runnable() {
-          public void run() {
-            for (HashEntry<?, ?> he : clearedEntries) {
-              for (HashEntry<?, ?> p = he; p != null; p = p.getNextEntry()) {
-                synchronized (p) {
-                  ((OffHeapRegionEntry) p).release();
+        Runnable runnable;
+        if (OffHeapRegionEntryHelper.doesClearNeedToCheckForOffHeap()) {
+          runnable = new Runnable() {
+            public void run() {
+              for (HashEntry<?, ?> he : clearedEntries) {
+                for (HashEntry<?, ?> p = he; p != null; p = p.getNextEntry()) {
+                  if (p instanceof RegionEntry) {
+                    synchronized (p) {
+                      GatewaySenderEventImpl.release(((RegionEntry) p).getValue()); // OFFHEAP
+                    }
+                  }
-          }
-        };
+          };
+        } else {
+          runnable = new Runnable() {
+            public void run() {
+              for (HashEntry<?, ?> he : clearedEntries) {
+                for (HashEntry<?, ?> p = he; p != null; p = p.getNextEntry()) {
+                  synchronized (p) {
+                    ((OffHeapRegionEntry) p).release();
+                  }
+                }
+              }
+            }
+          };
+        }
-  // End GemStone addition
+  // End Geode addition
-  // GemStone addition
+  // Geode addition
-  // End GemStone addition
+  // End Geode addition
-    // GemStone changed HashEntry<K, V>[] currentTable to currentSegment
+    // Geode changed HashEntry<K, V>[] currentTable to currentSegment
-      // GemStone changes BEGIN
+      // Geode changes BEGIN
-      // GemStone changes END
+      // Geode changes END
-    // GemStone added the method below
+    // Geode added the method below
-    protected K key; // GemStone change; made non-final to enable reuse
+    protected K key; // Geode change; made non-final to enable reuse
-    // GemStone change
+    // Geode change
-    // End GemStone change
+    // End Geode change
-    // GemStone change
+    // Geode change
-    // End GemStone change
+    // End Geode change

INS26 INS40 INS66 INS66 INS65 INS66 INS66 INS40 UPD66 INS25 INS43 INS32 INS8 INS8 INS27 MOV8 INS27 INS42 INS42 INS42 INS21 INS21 INS42 INS33 MOV60 INS42 INS33 INS7 INS7 INS42 MOV8 INS8 INS8 INS42 INS14 INS42 MOV14 INS70 MOV60 MOV25 MOV21 MOV21 MOV43 INS1 MOV44 INS42 INS8 INS31 INS25 INS83 INS39 INS42 MOV8 MOV27 MOV8 INS70 INS25 INS44 INS42 MOV8 MOV62 INS8 INS74 INS42 MOV21 MOV43 INS76 INS76 UPD74 UPD42 INS14 UPD43 INS76 INS76 INS8 INS74 UPD42 INS51 INS43 INS74 INS42 MOV8 INS42 INS43 INS76 INS76 INS42 DEL39 DEL42 DEL42 DEL33 DEL27 DEL59 DEL60 DEL42 DEL25 DEL42 DEL38 DEL42 DEL70 DEL8 DEL83 DEL39 DEL42 DEL42 DEL38 DEL42 DEL38 DEL27 DEL59 DEL60 DEL42 DEL83 DEL42 DEL43 DEL42 DEL8 DEL25
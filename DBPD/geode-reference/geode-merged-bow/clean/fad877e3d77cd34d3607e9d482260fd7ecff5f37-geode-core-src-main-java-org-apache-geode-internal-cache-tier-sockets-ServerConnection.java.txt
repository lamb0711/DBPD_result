GEODE-3200 Remove unused authzrequest (#2311)


-  public static final String DISALLOW_INTERNAL_MESSAGES_WITHOUT_CREDENTIALS_NAME =
+  private static final String DISALLOW_INTERNAL_MESSAGES_WITHOUT_CREDENTIALS_NAME =
-  protected Socket theSocket;
-  // private InputStream in = null;
-  // private OutputStream out = null;
+  Socket theSocket;
-  protected String name = null;
+  protected String name;
-  private Message requestMsg = new Message(2, Version.CURRENT);
-  private Message replyMsg = new Message(1, Version.CURRENT);
-  private Message responseMsg = new Message(1, Version.CURRENT);
-  private Message errorMsg = new Message(1, Version.CURRENT);
+  private Message requestMessage = new Message(2, Version.CURRENT);
+  private Message replyMessage = new Message(1, Version.CURRENT);
+  private Message responseMessage = new Message(1, Version.CURRENT);
+  private Message errorMessage = new Message(1, Version.CURRENT);
-  private ChunkedMessage queryResponseMsg = new ChunkedMessage(2, Version.CURRENT);
-  private ChunkedMessage chunkedResponseMsg = new ChunkedMessage(1, Version.CURRENT);
-  private ChunkedMessage executeFunctionResponseMsg = new ChunkedMessage(1, Version.CURRENT);
-  private ChunkedMessage registerInterestResponseMsg = new ChunkedMessage(1, Version.CURRENT);
-  private ChunkedMessage keySetResponseMsg = new ChunkedMessage(1, Version.CURRENT);
+  private ChunkedMessage queryResponseMessage = new ChunkedMessage(2, Version.CURRENT);
+  private ChunkedMessage chunkedResponseMessage = new ChunkedMessage(1, Version.CURRENT);
+  private ChunkedMessage executeFunctionResponseMessage = new ChunkedMessage(1, Version.CURRENT);
+  private ChunkedMessage registerInterestResponseMessage = new ChunkedMessage(1, Version.CURRENT);
+  private ChunkedMessage keySetResponseMessage = new ChunkedMessage(1, Version.CURRENT);
-  byte[] memberIdByteArray;
-
-  /**
-   * Authorize client requests using this object. This is set when each operation on this connection
-   * is authorized in pre-operation phase.
-   */
-  private AuthorizeRequest authzRequest;
+  private byte[] memberIdByteArray;
-  private final String communicationModeStr;
-      new ConcurrentHashMap<ClientProxyMembershipID, ClientUserAuths>();
+      new ConcurrentHashMap<>();
-  private Random randomConnectionIdGen = null;
+  private Random randomConnectionIdGen;
-  public static boolean TEST_VERSION_AFTER_HANDSHAKE_FLAG = false;
-
-  public static short testVersionAfterHandshake = 4;
+  private static boolean TEST_VERSION_AFTER_HANDSHAKE_FLAG = false;
-    this.communicationModeStr = communicationModeStr;
-    this.authzRequest = null;
-  private static final ThreadLocal<Byte> executeFunctionOnLocalNodeOnly = new ThreadLocal<Byte>() {
-    @Override
-    protected Byte initialValue() {
-      return 0x00;
-    }
-  };
+  private static final ThreadLocal<Byte> executeFunctionOnLocalNodeOnly =
+      ThreadLocal.withInitial(() -> (byte) 0x00);
-    byte b = value.byteValue();
+    byte b = value;
-              new Object[] {getName(), Integer.valueOf(handshakeTimeout)}));
+              new Object[] {getName(), handshakeTimeout}));
-  protected int getHandShakeTimeout() {
+  private int getHandShakeTimeout() {
-    this.replyMsg.setVersion(v);
-    this.requestMsg.setVersion(v);
-    this.responseMsg.setVersion(v);
-    this.errorMsg.setVersion(v);
+    this.replyMessage.setVersion(v);
+    this.requestMessage.setVersion(v);
+    this.responseMessage.setVersion(v);
+    this.errorMessage.setVersion(v);
-    this.queryResponseMsg.setVersion(v);
-    this.chunkedResponseMsg.setVersion(v);
-    this.executeFunctionResponseMsg.setVersion(v);
-    this.registerInterestResponseMsg.setVersion(v);
-    this.keySetResponseMsg.setVersion(v);
+    this.queryResponseMessage.setVersion(v);
+    this.chunkedResponseMessage.setVersion(v);
+    this.executeFunctionResponseMessage.setVersion(v);
+    this.registerInterestResponseMessage.setVersion(v);
+    this.keySetResponseMessage.setVersion(v);
-  public void setRequestMsg(Message requestMsg) {
-    this.requestMsg = requestMsg;
+  void setRequestMessage(Message requestMessage) {
+    this.requestMessage = requestMessage;
-  public long setUserAuthorizeAndPostAuthorizeRequest(AuthorizeRequest authzRequest,
+  private long setUserAuthorizeAndPostAuthorizeRequest(AuthorizeRequest authzRequest,
-    } catch (NullPointerException npe) {
+    } catch (NullPointerException exception) {
-      throw npe;
+      throw exception;
-  protected boolean processHandShake() {
+  boolean processHandShake() {
-      } // sync
-    } // try
-    finally {
-      if (isTerminated() || result == false) {
+      }
+    } finally {
+      if (isTerminated() || !result) {
-    } // finally
+    }
-  protected void refuseHandshake(String msg, byte exception) {
+  private void refuseHandshake(String message, byte exception) {
-      acceptor.refuseHandshake(this.theSocket.getOutputStream(), msg, exception);
+      acceptor.refuseHandshake(this.theSocket.getOutputStream(), message, exception);
-  protected boolean acceptHandShake(byte endpiontType, int queueSize) {
-    return doHandShake(endpiontType, queueSize) && handshakeAccepted();
+  private boolean acceptHandShake(byte endpointType, int queueSize) {
+    return doHandShake(endpointType, queueSize) && handshakeAccepted();
-
-  protected boolean handshakeAccepted() {
+  private boolean handshakeAccepted() {
-    if (this.requestMsg.isSecureMode()) {
+    if (this.requestMessage.isSecureMode()) {
-        byte[] secureBytes = this.requestMsg.getSecureBytes();
+        byte[] secureBytes = this.requestMessage.getSecureBytes();
-    if (this.requestMsg.isSecureMode()) {
+    if (this.requestMessage.isSecureMode()) {
-  protected boolean processMessages = true;
+  boolean processMessages = true;
+      short testVersionAfterHandshake = 4;
-  protected void doNormalMsg() {
+  void doNormalMessage() {
-    Message msg = null;
-    msg = BaseCommand.readRequest(this);
+    Message message;
+    message = BaseCommand.readRequest(this);
-      if (msg != null) {
+      if (message != null) {
-                getName(), MessageType.getString(msg.getMessageType()), this.proxyId);
+                getName(), MessageType.getString(message.getMessageType()), this.proxyId);
-        if (msg.getMessageType() != MessageType.PING) {
+        if (message.getMessageType() != MessageType.PING) {
-          if (msg.getNumberOfParts() <= 0) {
+          if (message.getNumberOfParts() <= 0) {
-              MessageType.getString(msg.getMessageType()), msg.getTransactionId());
-          if (msg.getTransactionId() < -1) { // TODO: why is this happening?
-            msg.setTransactionId(-1);
+              MessageType.getString(message.getMessageType()), message.getTransactionId());
+          if (message.getTransactionId() < -1) { // TODO: why is this happening?
+            message.setTransactionId(-1);
-        if (msg.getMessageType() != MessageType.PING) {
+        if (message.getMessageType() != MessageType.PING) {
-        Command command = getCommand(Integer.valueOf(msg.getMessageType()));
+        Command command = getCommand(message.getMessageType());
-            && !isInternalMessage(this.requestMsg, allowInternalMessagesWithoutCredentials)
+            && !isInternalMessage(this.requestMessage, allowInternalMessagesWithoutCredentials)
-          String messageType = MessageType.getString(this.requestMsg.getMessageType());
+          String messageType = MessageType.getString(this.requestMessage.getMessageType());
-        command.execute(msg, this, this.securityService);
+        command.execute(message, this, this.securityService);
-      clearRequestMsg();
+      clearRequestMessage();
-    { // moved out of above if to fix bug 36751
-
-      boolean needsUnregister = false;
-      synchronized (this.chmLock) {
-        if (this.chmRegistered) {
-          needsUnregister = true;
-          this.chmRegistered = false;
-        }
-      }
-      if (unregisterClient)// last serverconnection call all close on auth objects
-      {
-        cleanClientAuths();
-      }
-      this.clientUserAuths = null;
-      if (needsUnregister) {
-        this.acceptor.getClientHealthMonitor().removeConnection(this.proxyId, this);
-        if (unregisterClient) {
-          this.acceptor.getClientHealthMonitor().unregisterClient(this.proxyId, getAcceptor(),
-              this.clientDisconnectedCleanly, this.clientDisconnectedException);
-        }
+    // moved out of above if to fix bug 36751
+    boolean needsUnregister = false;
+    synchronized (this.chmLock) {
+      if (this.chmRegistered) {
+        needsUnregister = true;
+        this.chmRegistered = false;
+    if (unregisterClient)// last serverconnection call all close on auth objects
+    {
+      cleanClientAuths();
+    }
+    this.clientUserAuths = null;
+    if (needsUnregister) {
+      this.acceptor.getClientHealthMonitor().removeConnection(this.proxyId, this);
+      if (unregisterClient) {
+        this.acceptor.getClientHealthMonitor().unregisterClient(this.proxyId, getAcceptor(),
+            this.clientDisconnectedCleanly, this.clientDisconnectedException);
+      }
+    }
+
-    ClientUserAuths cua = new ClientUserAuths(proxyId.hashCode());
-    ClientUserAuths retCua = proxyIdVsClientUserAuths.putIfAbsent(proxyId, cua);
+    ClientUserAuths clientUserAuths = new ClientUserAuths(proxyId.hashCode());
+    ClientUserAuths returnedClientUserAuths =
+        proxyIdVsClientUserAuths.putIfAbsent(proxyId, clientUserAuths);
-    if (retCua == null) {
-      return cua;
+    if (returnedClientUserAuths == null) {
+      return clientUserAuths;
-    return retCua;
+    return returnedClientUserAuths;
-  protected void initializeCommands() {
+  void initializeCommands() {
-
-    Command cc = (Command) this.commands.get(messageType);
-    return cc;
+    return (Command) this.commands.get(messageType);
-  public boolean removeUserAuth(Message msg, boolean keepalive) {
+  public void removeUserAuth(Message message, boolean keepAlive) {
-      byte[] secureBytes = msg.getSecureBytes();
+      byte[] secureBytes = message.getSecureBytes();
-        // if not successfull, try the old way
+        // if not successful, try the old way
-          removed = this.clientUserAuths.removeUserId(aIds.getUniqueId(), keepalive);
+          this.clientUserAuths.removeUserId(aIds.getUniqueId(), keepAlive);
-        return removed;
-
-      } catch (NullPointerException npe) {
+      } catch (NullPointerException exception) {
-        logger.debug("Exception {}", npe);
-        return false;
+        logger.debug("Exception {}", exception);
-    } catch (Exception ex) {
-      throw new AuthenticationFailedException("Authentication failed", ex);
+    } catch (Exception exception) {
+      throw new AuthenticationFailedException("Authentication failed", exception);
-  public byte[] setCredentials(Message msg) throws Exception {
+  public byte[] setCredentials(Message message) {
-      // need to decrpt bytes if its in DH mode
+      // need to decrypt bytes if its in DH mode
-      // need to send back in response with encrption
-      if (!AcceptorImpl.isAuthenticationRequired() && msg.isSecureMode()) {
+      // need to send back in response with encryption
+      if (!AcceptorImpl.isAuthenticationRequired() && message.isSecureMode()) {
-      if (!msg.isSecureMode()) {
+      if (!message.isSecureMode()) {
-      byte[] secureBytes = msg.getSecureBytes();
+      byte[] secureBytes = message.getSecureBytes();
-      byte[] credBytes = msg.getPart(0).getSerializedForm();
+      byte[] credBytes = message.getPart(0).getSerializedForm();
-      // When here, security is enfored on server, if login returns a subject, then it's the newly
+      // When here, security is enforced on server, if login returns a subject, then it's the newly
-      // create secure part which will be send in respones
-      return encryptId(uniqueId, this);
-    } catch (AuthenticationFailedException afe) {
-      throw afe;
-    } catch (AuthenticationRequiredException are) {
-      throw are;
-    } catch (Exception e) {
-      throw new AuthenticationFailedException("REPLY_REFUSED", e);
+      // create secure part which will be send in response
+      return encryptId(uniqueId);
+    } catch (AuthenticationFailedException | AuthenticationRequiredException exception) {
+      throw exception;
+    } catch (Exception exception) {
+      throw new AuthenticationFailedException("REPLY_REFUSED", exception);
-      byte[] id = encryptId(this.connectionId, this);
+      byte[] id = encryptId(this.connectionId);
-        && !this.communicationMode.isWAN() && !this.requestMsg.getAndResetIsMetaRegion()
-        && !isInternalMessage(this.requestMsg, allowInternalMessagesWithoutCredentials)) {
+        && !this.communicationMode.isWAN() && !this.requestMessage.getAndResetIsMetaRegion()
+        && !isInternalMessage(this.requestMessage, allowInternalMessagesWithoutCredentials)) {
-            "ServerConnection.updateAndGetSecurityPart() not adding security part for msg type {}",
-            MessageType.getString(this.requestMsg.messageType));
+            "ServerConnection.updateAndGetSecurityPart() not adding security part for message type {}",
+            MessageType.getString(this.requestMessage.messageType));
-      boolean finishedMsg = false;
+      boolean finishedMessage = false;
-            registerWithSelector(); // finished msg so reregister
-            finishedMsg = true;
+            registerWithSelector(); // finished message so reregister
+            finishedMessage = true;
-        if (!finishedMsg) {
+        if (!finishedMessage) {
-   * If registered with a selector then this will be the key we are registered with.
-   */
-  // private SelectionKey sKey = null;
-
-  /**
-  public void registerWithSelector() throws IOException {
-    // logger.info("DEBUG: registerWithSelector " + this);
+  void registerWithSelector() throws IOException {
-  public SelectableChannel getSelectableChannel() {
+  SelectableChannel getSelectableChannel() {
-  public void registerWithSelector2(Selector s) throws IOException {
+  void registerWithSelector2(Selector s) throws IOException {
-   * Switch this guy to blocking mode so we can use oldIO to read and write msgs.
+   * Switch this guy to blocking mode so we can use oldIO to read and write messages.
-  public void makeBlocking() throws IOException {
-    // logger.info("DEBUG: makeBlocking " + this);
-
-    // if (this.sKey != null) {
-    // this.sKey = null;
-    // }
+  void makeBlocking() throws IOException {
-  // private DistributedMember getClientDistributedMember() {
-  // return this.proxyId.getDistributedMember();
-  // }
-
-  protected String getCommunicationModeString() {
-    return this.communicationModeStr;
-  }
-
-  protected InetAddress getSocketAddress() {
+  InetAddress getSocketAddress() {
-  protected boolean isProcessingMessage() {
-    if (isTerminated()) {
-      return false;
-    }
-    synchronized (this.processingMessageLock) {
-      return basicIsProcessingMessage();
-    }
-  }
-
-  private boolean basicIsProcessingMessage() {
-    return this.processingMessageStartTime != -1;
-  }
-
-  protected void setNotProcessingMessage() {
+  private void setNotProcessingMessage() {
-  protected boolean hasBeenTimedOutOnClient() {
+  boolean hasBeenTimedOutOnClient() {
-      StringBuffer buffer = new StringBuffer(50).append(theSocket.getInetAddress()).append(':')
-          .append(theSocket.getPort()).append(" timeout: ").append(theSocket.getSoTimeout());
-      return buffer.toString();
+      return String.valueOf(theSocket.getInetAddress()) + ':' +
+          theSocket.getPort() + " timeout: " + theSocket.getSoTimeout();
-  void clearRequestMsg() {
-    requestMsg.clear();
+  private void clearRequestMessage() {
+    requestMessage.clear();
-          new Object[] {Integer.valueOf(justProcessed),
-              Integer.valueOf(this.latestBatchIdReplied)}));
+          new Object[] {justProcessed,
+              this.latestBatchIdReplied}));
-  protected void interruptOwner() {
-    synchronized (this.ownerLock) {
-      if (this.owner != null) {
-        this.owner.interrupt();
-      }
-    }
-  }
-
-  protected void initStreams(Socket s, int socketBufferSize, MessageStats msgStats) {
+  void initStreams(Socket s, int socketBufferSize, MessageStats messageStats) {
-      requestMsg.setComms(this, theSocket, commBuffer, msgStats);
-      replyMsg.setComms(this, theSocket, commBuffer, msgStats);
-      responseMsg.setComms(this, theSocket, commBuffer, msgStats);
-      errorMsg.setComms(this, theSocket, commBuffer, msgStats);
+      requestMessage.setComms(this, theSocket, commBuffer, messageStats);
+      replyMessage.setComms(this, theSocket, commBuffer, messageStats);
+      responseMessage.setComms(this, theSocket, commBuffer, messageStats);
+      errorMessage.setComms(this, theSocket, commBuffer, messageStats);
-      chunkedResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
-      queryResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
-      executeFunctionResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
-      registerInterestResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
-      keySetResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
+      chunkedResponseMessage.setComms(this, theSocket, commBuffer, messageStats);
+      queryResponseMessage.setComms(this, theSocket, commBuffer, messageStats);
+      executeFunctionResponseMessage.setComms(this, theSocket, commBuffer, messageStats);
+      registerInterestResponseMessage.setComms(this, theSocket, commBuffer, messageStats);
+      keySetResponseMessage.setComms(this, theSocket, commBuffer, messageStats);
+
-    } catch (Exception e) {
+    } catch (Exception ignored) {
-    try {
-      if (this.authzRequest != null) {
-        this.authzRequest.close();
-        this.authzRequest = null;
-      }
-    } catch (Exception ex) {
-      if (securityLogWriter.warningEnabled()) {
-        securityLogWriter.warning(
-            LocalizedStrings.ServerConnection_0_AN_EXCEPTION_WAS_THROWN_WHILE_CLOSING_CLIENT_AUTHORIZATION_CALLBACK_1,
-            new Object[] {this.name, ex});
-      }
-    }
+
+
-    ByteBuffer bb = this.commBuffer;
-    if (bb != null) {
+    ByteBuffer byteBuffer = this.commBuffer;
+    if (byteBuffer != null) {
-      ServerConnection.releaseCommBuffer(bb);
+      ServerConnection.releaseCommBuffer(byteBuffer);
-    return this.replyMsg;
+    return this.replyMessage;
-    return this.chunkedResponseMsg;
+    return this.chunkedResponseMessage;
-    return this.errorMsg;
+    return this.errorMessage;
-    return this.responseMsg;
+    return this.responseMessage;
-  public Message getRequestMessage() {
-    return this.requestMsg;
+  Message getRequestMessage() {
+    return this.requestMessage;
-  public ChunkedMessage getQueryResponseMessage() {
-    return this.queryResponseMsg;
+  ChunkedMessage getQueryResponseMessage() {
+    return this.queryResponseMessage;
-    return this.executeFunctionResponseMsg;
+    return this.executeFunctionResponseMessage;
-  public ChunkedMessage getKeySetResponseMessage() {
-    return this.keySetResponseMsg;
+  ChunkedMessage getKeySetResponseMessage() {
+    return this.keySetResponseMessage;
-    return this.registerInterestResponseMsg;
+    return this.registerInterestResponseMessage;
-    queryResponseMsg.setNumberOfParts(2);
-    chunkedResponseMsg.setNumberOfParts(1);
-    executeFunctionResponseMsg.setNumberOfParts(1);
-    registerInterestResponseMsg.setNumberOfParts(1);
-    keySetResponseMsg.setNumberOfParts(1);
+    queryResponseMessage.setNumberOfParts(2);
+    chunkedResponseMessage.setNumberOfParts(1);
+    executeFunctionResponseMessage.setNumberOfParts(1);
+    registerInterestResponseMessage.setNumberOfParts(1);
+    keySetResponseMessage.setNumberOfParts(1);
-                .toLocalizedString(Integer.valueOf(boolID)));
+                .toLocalizedString(boolID));
-                .toLocalizedString(Integer.valueOf(boolID)));
+                .toLocalizedString(boolID));
-  public void setUserAuthId(long uniqueId) {
+  void setUserAuthId(long uniqueId) {
-  private byte[] encryptId(long id, ServerConnection servConn) throws Exception {
+  private byte[] encryptId(long id) throws Exception {
-    HeapDataOutputStream hdos = null;
-    try {
-      hdos = new HeapDataOutputStream(Version.CURRENT);
+    try (HeapDataOutputStream heapDataOutputStream = new HeapDataOutputStream(Version.CURRENT)) {
-      hdos.writeLong(id);
+      heapDataOutputStream.writeLong(id);
-      return this.handshake.getEncryptor().encryptBytes(hdos.toByteArray());
-    } finally {
-      hdos.close();
+      return this.handshake.getEncryptor().encryptBytes(heapDataOutputStream.toByteArray());
-    long uniqueId = 0;
+    long uniqueId;
-    } else if (this.requestMsg.isSecureMode()) {
-      uniqueId = messageIdExtractor.getUniqueIdFromMessage(this.requestMsg,
+    } else if (this.requestMessage.isSecureMode()) {
+      uniqueId = messageIdExtractor.getUniqueIdFromMessage(this.requestMessage,
-    // for other look "requestMsg" here and get unique-id from this to get the authzrequest
+    // for other look "requestMessage" here and get unique-id from this to get the authzrequest
-    // for other look "requestMsg" here and get unique-id from this to get the authzrequest
+    // for other look "requestMessage" here and get unique-id from this to get the authzrequest
-    AuthorizeRequestPP postAuthReq = uaa.getPostAuthzRequest();
-
-    return postAuthReq;
+    return uaa.getPostAuthzRequest();
-  public void setMessageIdExtractor(MessageIdExtractor messageIdExtractor) {
+  void setMessageIdExtractor(MessageIdExtractor messageIdExtractor) {
-  void setAuthAttributes() throws Exception {
+  private void setAuthAttributes() throws Exception {

INS31 UPD83 INS83 UPD83 UPD83 UPD42 UPD83 UPD83 UPD83 UPD83 UPD42 UPD39 INS44 MOV44 UPD83 MOV83 MOV39 UPD42 MOV42 MOV8 MOV43 MOV43 MOV43 MOV8 INS83 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS32 UPD42 UPD42 UPD42 MOV60 MOV51 MOV25 MOV21 MOV25 MOV43 INS42 UPD42 UPD42 UPD42 INS54 UPD74 INS42 INS42 INS86 UPD42 MOV11 UPD66 INS58 INS8 MOV32 INS11 INS42 UPD42 INS60 UPD42 UPD42 UPD42 UPD42 UPD42 INS41 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 INS59 MOV21 MOV41 INS39 INS34 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS39 MOV59 UPD42 UPD42 UPD42 MOV5 MOV5 INS84 UPD42 UPD42 INS27 UPD42 MOV43 MOV43 INS42 MOV14 UPD42 INS38 UPD42 UPD42 UPD42 MOV43 MOV43 UPD42 UPD42 MOV32 INS13 MOV32 INS45 MOV32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 MOV42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD45 UPD42 UPD42 UPD42 MOV32 MOV32 UPD42 INS42 MOV22 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 DEL83 DEL33 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL43 DEL33 DEL83 DEL83 DEL39 DEL23 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL34 DEL41 DEL8 DEL31 DEL1 DEL14 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL83 DEL83 DEL42 DEL9 DEL27 DEL83 DEL83 DEL33 DEL42 DEL42 DEL32 DEL8 DEL83 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL42 DEL7 DEL42 DEL41 DEL9 DEL41 DEL42 DEL44 DEL42 DEL43 DEL52 DEL42 DEL44 DEL42 DEL53 DEL8 DEL12 DEL52 DEL83 DEL83 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL83 DEL83 DEL39 DEL42 DEL42 DEL32 DEL9 DEL41 DEL8 DEL25 DEL52 DEL42 DEL22 DEL42 DEL32 DEL41 DEL8 DEL51 DEL8 DEL31 DEL39 DEL42 DEL52 DEL42 DEL22 DEL34 DEL38 DEL27 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL34 DEL14 DEL42 DEL43 DEL42 DEL42 DEL13 DEL32 DEL42 DEL32 DEL42 DEL45 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL41 DEL31 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL83 DEL39 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL33 DEL27 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL51 DEL8 DEL31 DEL83 DEL52 DEL42 DEL22 DEL33 DEL27 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL33 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL42 DEL42 DEL40 DEL42 DEL43 DEL85 DEL5 DEL52 DEL42 DEL22 DEL42 DEL4 DEL3 DEL32 DEL21 DEL8 DEL25 DEL8 DEL12 DEL54 DEL83 DEL83 DEL83 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL7 DEL21 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL34 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL83
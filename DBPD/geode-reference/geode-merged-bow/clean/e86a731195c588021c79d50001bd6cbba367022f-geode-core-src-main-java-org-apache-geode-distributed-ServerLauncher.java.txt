Merge branch 'release/1.3.0'

-
+import static org.apache.commons.lang.StringUtils.EMPTY;
+import static org.apache.commons.lang.StringUtils.defaultIfBlank;
+import static org.apache.commons.lang.StringUtils.isBlank;
+import static org.apache.commons.lang.StringUtils.isNotBlank;
+import static org.apache.commons.lang.StringUtils.lowerCase;
+import static org.apache.geode.internal.lang.ObjectUtils.defaultIfNull;
+import static org.apache.geode.internal.lang.StringUtils.wrap;
+import static org.apache.geode.internal.lang.SystemUtils.CURRENT_DIRECTORY;
+import static org.apache.geode.internal.util.IOUtils.tryGetCanonicalPathElseGetAbsolutePath;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.lang.management.ManagementFactory;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.ServiceLoader;
+import java.util.TreeMap;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
+
+import javax.management.MalformedObjectNameException;
+import javax.management.ObjectName;
+
+import joptsimple.OptionException;
+import joptsimple.OptionParser;
+import joptsimple.OptionSet;
+import org.apache.commons.lang.exception.ExceptionUtils;
-import org.apache.geode.internal.lang.StringUtils;
-import org.apache.geode.internal.lang.SystemUtils;
-import org.apache.geode.internal.process.ClusterConfigurationNotAvailableException;
-import org.apache.geode.internal.process.StartupStatusListener;
-import org.apache.geode.internal.util.IOUtils;
+import org.apache.geode.management.internal.cli.util.HostUtils;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.lang.management.ManagementFactory;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-import java.util.ServiceLoader;
-import java.util.TreeMap;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.management.MalformedObjectNameException;
-import javax.management.ObjectName;
-import joptsimple.OptionException;
-import joptsimple.OptionParser;
-import joptsimple.OptionSet;
-
- * 
+ *
-  /**
-   * @deprecated This is specific to the internal implementation and may go away in a future
-   *             release.
-   */
-  @Deprecated
-  protected static final Integer DEFAULT_SERVER_PORT = getDefaultServerPort();
-
+    helpMap.put("delete-pid-file-on-stop",
+        "Specifies that this Server's PID file should be deleted on stop.  The default is to not delete this Server's PID file until JVM exit if --delete-pid-file-on-stop is not specified.");
-  /**
-   * @deprecated This is specific to the internal implementation and may go away in a future
-   *             release.
-   */
-  @Deprecated
-  public static final String DEFAULT_SERVER_PID_FILE = "vf.gf.server.pid";
-
+  private final boolean deletePidFileOnStop;
-   * 
+   *
-    } catch (AttachAPINotFoundException e) {
-      System.err.println(e.getMessage());
+    } catch (AttachAPINotFoundException handled) {
+      System.err.println(handled.getMessage());
-   * 
+   *
-   * 
+   *
-    return (getInstance() != null ? getInstance().status() : null);
+    return getInstance() != null ? getInstance().status() : null;
-   * 
+   *
+    this.deletePidFileOnStop = Boolean.TRUE.equals(builder.getDeletePidFileOnStop());
-    // TODO:KIRK: set ThreadLocal for LogService with getLogFile or getLogFileName
-   * 
+   *
-   * 
+   *
-    if (StringUtils.isNotBlank(serverPort)) {
+    if (isNotBlank(serverPort)) {
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
+  @Override
-    return StringUtils.defaultIfBlank(getMemberName(), DEFAULT_SERVER_LOG_NAME)
-        .concat(DEFAULT_SERVER_LOG_EXT);
+    return defaultIfBlank(getMemberName(), DEFAULT_SERVER_LOG_NAME).concat(DEFAULT_SERVER_LOG_EXT);
-   * 
+   *
-    return StringUtils.defaultIfBlank(this.memberName, super.getMemberName());
+    return defaultIfBlank(this.memberName, super.getMemberName());
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-    } catch (UnknownHostException ignore) {
-      // TODO determine a better value for the host on which the Server is running to return here...
-      // NOTE returning localhost/127.0.0.1 implies the serverBindAddress was null and no IP address
-      // for localhost
-      // could be found
+    } catch (UnknownHostException handled) {
+      // Returning localhost/127.0.0.1 implies the serverBindAddress was null and no IP address
+      // for localhost could be found
-   * 
+   *
-   * 
+   *
-    return ObjectUtils.defaultIfNull(getServerPort(), getDefaultServerPort()).toString();
+    return defaultIfNull(getServerPort(), getDefaultServerPort()).toString();
-   * 
+   *
+  @Override
-   * 
+   *
-   * 
+   *
-    return StringUtils.isNotBlank(this.springXmlLocation);
+    return isNotBlank(this.springXmlLocation);
-   * 
+   *
-   * 
+   *
-      info(StringUtils.wrap(helpMap.get(command.getName()), 80, ""));
+      info(wrap(helpMap.get(command.getName()), 80, ""));
-      info(StringUtils.wrap("> java ... " + getClass().getName() + ' ' + usageMap.get(command), 80,
-          "\t\t"));
+      info(wrap("> java ... " + getClass().getName() + ' ' + usageMap.get(command), 80, "\t\t"));
-        info(StringUtils.wrap("--" + option + ": " + helpMap.get(option) + '\n', 80, "\t"));
+        info(wrap("--" + option + ": " + helpMap.get(option) + '\n', 80, "\t"));
-   * 
+   *
-    info(StringUtils.wrap(helpMap.get("launcher"), 80, "\t"));
+    info(wrap(helpMap.get("launcher"), 80, "\t"));
-   * 
+   *
-   * 
+   *
-    return (!isRunning() && this.starting.compareAndSet(false, true));
+    return !isRunning() && this.starting.compareAndSet(false, true);
-            new StartupStatusListener() {
-              @Override
-              public void setStatus(final String statusMessage) {
-                debug("Callback setStatus(String) called with message (%1$s)...", statusMessage);
-                ServerLauncher.this.statusMessage = statusMessage;
-              }
+            (String statusMessage) -> {
+              debug("Callback setStatus(String) called with message (%1$s)...", statusMessage);
+              ServerLauncher.this.statusMessage = statusMessage;
-      } catch (ClusterConfigurationNotAvailableException e) {
-        failOnStart(e);
-        throw e;
-      } catch (RuntimeException e) {
+      } catch (RuntimeException | Error e) {
-      } catch (Error e) {
-        failOnStart(e);
-        throw e;
-   * 
+   *
-      this.process.stop();
+      this.process.stop(this.deletePidFileOnStop);
-   * 
+   *
-   * 
+   *
-    return (isRunning() && (cache.getDistributedSystem().isConnected() || cache.isReconnecting()));
+    return isRunning() && (cache.getDistributedSystem().isConnected() || cache.isReconnecting());
-              wait(500l);
+              wait(500L);
-          } catch (InterruptedException ignore) {
+          } catch (InterruptedException handled) {
+            // loop back around
-   * 
+   *
-    return (cache.getCacheServers().isEmpty() && !isDisableDefaultServer());
+    return cache.getCacheServers().isEmpty() && !isDisableDefaultServer();
-   * 
+   *
-          (getServerBindAddress() == null ? null : getServerBindAddress().getHostAddress());
+          getServerBindAddress() == null ? null : getServerBindAddress().getHostAddress();
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-    return (this.starting.get() || isRunning());
+    return this.starting.get() || isRunning();
-      return new ServerState(this, (isRunning() ? Status.ONLINE : Status.STARTING));
+      return new ServerState(this, isRunning() ? Status.ONLINE : Status.STARTING);
-
-    debug(
-        "This ServerLauncher was not the instance used to launch the GemFire Cache Server, and neither PID "
-            .concat("nor working directory were specified; the Server's state is unknown.%n"));
+    debug("This ServerLauncher was not the instance used to launch the GemFire Cache Server, and "
+        + "neither PID nor working directory were specified; the Server's state is unknown.%n");
-      return new ServerState(this, (isRunning() ? Status.ONLINE : Status.STARTING));
+      return new ServerState(this, isRunning() ? Status.ONLINE : Status.STARTING);
-    }
-    // catch (NoClassDefFoundError error) {
-    // if (isAttachAPINotFound(error)) {
-    // throw new
-    // AttachAPINotFoundException(LocalizedStrings.Launcher_ATTACH_API_NOT_FOUND_ERROR_MESSAGE
-    // .toLocalizedString(), error);
-    // }
-    //
-    // throw error;
-    // }
-    catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException handled) {
-      return createNoResponseState(e, "Failed to connect to server with process id " + getPid());
-    } catch (IOException e) {
-      // failed to open or read file or dir
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + getPid());
-    }
-    // catch (MalformedObjectNameException e) { // impossible
-    // // JMX object name is bad
-    // return createNoResponseState(e, "Failed to communicate with server with process id " +
-    // getPid());
-    // }
-    catch (MBeanInvocationFailedException e) {
-      // MBean either doesn't exist or method or attribute don't exist
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + getPid());
-    }
-    // catch (PidUnavailableException e) {
-    // // couldn't determine pid from within server JVM
-    // return createNoResponseState(e, "Failed to communicate with server with process id " +
-    // getPid());
-    // }
-    catch (UnableToControlProcessException e) {
-      // TODO comment me
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + getPid());
-    } catch (InterruptedException e) {
-      // TODO comment me
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + getPid());
-    } catch (TimeoutException e) {
-      // TODO comment me
-      return createNoResponseState(e,
+      return createNoResponseState(handled,
+          "Failed to connect to server with process id " + getPid());
+    } catch (IOException | MBeanInvocationFailedException | UnableToControlProcessException
+        | InterruptedException | TimeoutException handled) {
+      return createNoResponseState(handled,
-      final ProcessController controller = new ProcessControllerFactory().createProcessController(
-          this.controllerParameters, new File(getWorkingDirectory()),
-          ProcessType.SERVER.getPidFileName(), READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
+      final ProcessController controller =
+          new ProcessControllerFactory().createProcessController(this.controllerParameters,
+              new File(getWorkingDirectory()), ProcessType.SERVER.getPidFileName());
-    } catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException handled) {
-      return createNoResponseState(e, "Failed to connect to server with process id " + parsedPid);
-    } catch (FileNotFoundException e) {
+      return createNoResponseState(handled,
+          "Failed to connect to server with process id " + parsedPid);
+    } catch (FileNotFoundException handled) {
-      return createNoResponseState(e, "Failed to find process file "
+      return createNoResponseState(handled, "Failed to find process file "
-    } catch (IOException e) {
-      // failed to open or read file or dir
-      return createNoResponseState(e,
+    } catch (IOException | MBeanInvocationFailedException | UnableToControlProcessException
+        | TimeoutException handled) {
+      return createNoResponseState(handled,
-    } catch (InterruptedException e) {
+    } catch (InterruptedException handled) {
-      return createNoResponseState(e,
+      return createNoResponseState(handled,
-    } catch (MBeanInvocationFailedException e) {
-      // MBean either doesn't exist or method or attribute don't exist
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + parsedPid);
-    } catch (PidUnavailableException e) {
+    } catch (PidUnavailableException handled) {
-      return createNoResponseState(e, "Failed to find usable process id within file "
+      return createNoResponseState(handled, "Failed to find usable process id within file "
-    } catch (UnableToControlProcessException e) {
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + parsedPid);
-    } catch (TimeoutException e) {
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + parsedPid);
-   * 
+   *
-    // TODO give user detailed error message?
-        this.process.stop();
+        this.process.stop(this.deletePidFileOnStop);
-    }
-    // catch (NoClassDefFoundError error) {
-    // if (isAttachAPINotFound(error)) {
-    // throw new
-    // AttachAPINotFoundException(LocalizedStrings.Launcher_ATTACH_API_NOT_FOUND_ERROR_MESSAGE
-    // .toLocalizedString(), error);
-    // }
-    //
-    // throw error;
-    // }
-    catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException handled) {
-      return createNoResponseState(e, "Failed to connect to server with process id " + getPid());
-    } catch (IOException e) {
-      // failed to open or read file or dir
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + getPid());
-    }
-    // catch (MalformedObjectNameException e) { // impossible
-    // // JMX object name is bad
-    // return createNoResponseState(e, "Failed to communicate with server with process id " +
-    // getPid());
-    // }
-    catch (MBeanInvocationFailedException e) {
-      // MBean either doesn't exist or method or attribute don't exist
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + getPid());
-    }
-    // catch (PidUnavailableException e) {
-    // // couldn't determine pid from within server JVM
-    // return createNoResponseState(e, "Failed to communicate with server with process id " +
-    // getPid());
-    // }
-    catch (UnableToControlProcessException e) {
-      // TODO comment me
-      return createNoResponseState(e,
+      return createNoResponseState(handled,
+          "Failed to connect to server with process id " + getPid());
+    } catch (IOException | MBeanInvocationFailedException
+        | UnableToControlProcessException handled) {
+      return createNoResponseState(handled,
-      final ProcessController controller = new ProcessControllerFactory().createProcessController(
-          this.controllerParameters, new File(getWorkingDirectory()),
-          ProcessType.SERVER.getPidFileName(), READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
+      final ProcessController controller =
+          new ProcessControllerFactory().createProcessController(this.controllerParameters,
+              new File(getWorkingDirectory()), ProcessType.SERVER.getPidFileName());
-    } catch (ConnectionFailedException e) {
+    } catch (ConnectionFailedException handled) {
-      return createNoResponseState(e, "Failed to connect to server with process id " + parsedPid);
-    } catch (FileNotFoundException e) {
+      return createNoResponseState(handled,
+          "Failed to connect to server with process id " + parsedPid);
+    } catch (FileNotFoundException handled) {
-      return createNoResponseState(e, "Failed to find process file "
+      return createNoResponseState(handled, "Failed to find process file "
-    } catch (IOException e) {
-      // failed to open or read file or dir
-      return createNoResponseState(e,
+    } catch (IOException | MBeanInvocationFailedException
+        | UnableToControlProcessException handled) {
+      return createNoResponseState(handled,
-    } catch (InterruptedException e) {
+    } catch (InterruptedException handled) {
-      return createNoResponseState(e,
+      return createNoResponseState(handled,
-    } catch (MBeanInvocationFailedException e) {
-      // MBean either doesn't exist or method or attribute don't exist
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + parsedPid);
-    } catch (PidUnavailableException e) {
+    } catch (PidUnavailableException handled) {
-      return createNoResponseState(e, "Failed to find usable process id within file "
+      return createNoResponseState(handled, "Failed to find usable process id within file "
-    } catch (TimeoutException e) {
-      return createNoResponseState(e, "Timed out trying to find usable process id within file "
-          + ProcessType.SERVER.getPidFileName() + " in " + getWorkingDirectory());
-    } catch (UnableToControlProcessException e) {
-      return createNoResponseState(e,
-          "Failed to communicate with server with process id " + parsedPid);
+    } catch (TimeoutException handled) {
+      return createNoResponseState(handled,
+          "Timed out trying to find usable process id within file "
+              + ProcessType.SERVER.getPidFileName() + " in " + getWorkingDirectory());
-
-    debug(cause);
+    debug(ExceptionUtils.getFullStackTrace(cause) + errorMessage);
-  private Properties getOverriddenDefaults() {
+  private Properties getOverriddenDefaults() throws IOException {
-        getLogFileName());
+        getLogFile().getCanonicalPath());
-    public File getWorkingDirectory() {
+    public File getDirectory() {
-      } catch (MalformedObjectNameException | NullPointerException ignore) {
+      } catch (MalformedObjectNameException | NullPointerException handled) {
+    private Boolean deletePidFileOnStop;
-     * 
+     *
-     * 
+     *
-     * 
+     *
+        setDeletePidFileOnStop(options.has("delete-pid-file-on-stop"));
-        // TODO why are these option not inside the 'if (!isHelping())' conditional block!?
+        // why are these option not inside the 'if (!isHelping())' conditional block?
-     * 
+     *
-     * 
+     *
-     * 
+     *
-      return ObjectUtils.defaultIfNull(this.command, DEFAULT_COMMAND);
+      return defaultIfNull(this.command, DEFAULT_COMMAND);
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * Determines whether a default cache server will be added when the GemFire Server comes online.
-     * 
+     * Determines whether the Geode Server should delete the pid file when its service stops or when
+     * the JVM exits.
+     *
+     * @return a boolean value indicating if the pid file should be deleted when this service stops
+     *         or when the JVM exits.
+     * @see #setDeletePidFileOnStop(Boolean)
+     */
+    public Boolean getDeletePidFileOnStop() {
+      return this.deletePidFileOnStop;
+    }
+
+    /**
+     * Sets whether the Geode Server should delete the pid file when its service stops or when the
+     * JVM exits.
+     *
+     * @param deletePidFileOnStop a boolean value indicating if the pid file should be deleted when
+     *        this service stops or when the JVM exits.
+     * @return this Builder instance.
+     * @see #getDeletePidFileOnStop()
+     */
+    public Builder setDeletePidFileOnStop(final Boolean deletePidFileOnStop) {
+      this.deletePidFileOnStop = deletePidFileOnStop;
+      return this;
+    }
+
+    /**
+     * Determines whether a default cache server will be added when the Geode Server comes online.
+     *
-     * 
+     *
-     * 
+     *
-     * @see org.apache.geode.internal.process.LocalProcessLauncher
-      return ObjectUtils.defaultIfNull(this.force, DEFAULT_FORCE);
+      return defaultIfNull(this.force, DEFAULT_FORCE);
-     * 
+     *
-     * @see org.apache.geode.internal.process.LocalProcessLauncher
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-      if (StringUtils.isBlank(memberName)) {
+      if (isBlank(memberName)) {
-     * 
+     *
-     * 
+     *
-     * Determines whether the new instance of LocatorLauncher will redirect output to system logs
-     * when starting a Locator.
-     * 
+     * Determines whether the new instance of ServerLauncher will redirect output to system logs
+     * when starting a Server.
+     *
-     *         a Locator
-     * 
+     *         a Server
-     * 
+     *
-     * Sets whether the new instance of LocatorLauncher will redirect output to system logs when
-     * starting a Locator.
-     * 
+     * Sets whether the new instance of ServerLauncher will redirect output to system logs when
+     * starting a Server.
+     *
-     *        when starting a Locator.
+     *        when starting a Server.
-     * 
+     *
-     * 
+     *
-      if (StringUtils.isBlank(serverBindAddress)) {
+      if (isBlank(serverBindAddress)) {
-     * 
+     *
-      return ObjectUtils.defaultIfNull(this.serverPort, getDefaultServerPort());
+      return defaultIfNull(this.serverPort, getDefaultServerPort());
-     * 
+     *
-      if (serverPort != null && (serverPort < 0 || serverPort > 65535)) {
+      if (serverPort == null) {
+        this.serverPort = null;
+        this.serverPortSetByUser = false;
+        return this;
+      }
+
+      if ((serverPort < 0 || serverPort > 65535)) {
-      this.serverPort = serverPort;
-      this.serverPortSetByUser = true;
+
+      if (serverPort == 0) {
+        this.serverPort = 0;
+        this.serverPortSetByUser = false;
+      } else {
+        this.serverPort = serverPort;
+        this.serverPortSetByUser = true;
+      }
+
-     * 
+     *
-     * 
+     *
-     * 
+     *
-      return IOUtils.tryGetCanonicalPathElseGetAbsolutePath(
-          new File(StringUtils.defaultIfBlank(this.workingDirectory, DEFAULT_WORKING_DIRECTORY)));
+      return tryGetCanonicalPathElseGetAbsolutePath(
+          new File(defaultIfBlank(this.workingDirectory, DEFAULT_WORKING_DIRECTORY)));
-     * 
+     *
-      if (!(new File(StringUtils.defaultIfBlank(workingDirectory, DEFAULT_WORKING_DIRECTORY))
-          .isDirectory())) {
+      if (!new File(defaultIfBlank(workingDirectory, DEFAULT_WORKING_DIRECTORY)).isDirectory()) {
+      if (isBlank(hostNameForClients)) {
+        throw new IllegalArgumentException(
+            "The hostname used by clients to connect to the Server must have an argument if the --hostname-for-clients command-line option is specified!");
+      }
-
-     * 
+     *
-     * 
+     *
-        if (StringUtils.isBlank(getMemberName())
+        if (isBlank(getMemberName())
-        if (!SystemUtils.CURRENT_DIRECTORY.equals(getWorkingDirectory())) {
+        if (!CURRENT_DIRECTORY.equals(getWorkingDirectory())) {
-     * 
+     *
-     * 
+     *
-     * 
+     *
-      assert StringUtils.isNotBlank(name) : "The name of the command must be specified!";
+      assert isNotBlank(name) : "The name of the command must be specified!";
-      this.options = (options != null ? Collections.unmodifiableList(Arrays.asList(options))
-          : Collections.<String>emptyList());
+      this.options = options != null ? Collections.unmodifiableList(Arrays.asList(options))
+          : Collections.emptyList();
-     * 
+     *
-      return (valueOfName(name) != null);
+      return valueOfName(name) != null;
-     * 
+     *
-      return (command == null || command.isUnspecified());
+      return command == null || command.isUnspecified();
-     * 
+     *
-     * 
+     *
-     * Gets a set of valid options that can be used with the Locator launcher command when used from
+     * Gets a set of valid options that can be used with the Server launcher command when used from
-     * 
+     *
-     * Determines whether this Locator launcher command has the specified command-line option.
-     * 
+     * Determines whether this Server launcher command has the specified command-line option.
+     *
-      return getOptions().contains(StringUtils.lowerCase(option));
+      return getOptions().contains(lowerCase(option));
-     * 
+     *
-      return (this == UNSPECIFIED);
+      return this == UNSPECIFIED;
-     * 
+     *
-   * The ServerState is an immutable type representing the state of the specified Locator at any
-   * given moment in time. The state of the Locator is assessed at the exact moment an instance of
+   * The ServerState is an immutable type representing the state of the specified Server at any
+   * given moment in time. The state of the Server is assessed at the exact moment an instance of
-   * 
+   *
-     * 
+     *
-        // TODO: or should we return OFFLINE?
-          null, // serverLocation
+          getServerLocation(launcher), // serverLocation
-          Collections.<String>emptyList(), // jvmArguments
+          ManagementFactory.getRuntimeMXBean().getInputArguments(), // jvmArguments
-          null, // javaVersion
+          System.getProperty("java.version"), // javaVersion
-          null, // host
-          null, // port
+          getServerBindAddressAsString(launcher), // host
+          launcher.getServerPortAsString(), // port
+    /*
+     * Guards against throwing NPEs due to incorrect or missing host information while constructing
+     * error states
+     */
+    private static String getServerLocation(ServerLauncher launcher) {
+      if (launcher.getServerPort() == null) {
+        return launcher.getId();
+      }
+      if (launcher.getServerBindAddress() == null) {
+        return HostUtils.getLocatorId(HostUtils.getLocalHost(), launcher.getServerPort());
+      }
+      return HostUtils.getServerId(launcher.getServerBindAddress().getCanonicalHostName(),
+          launcher.getServerPort());
+    }
+
-          final String logFileCanonicalPath =
-              IOUtils.tryGetCanonicalPathElseGetAbsolutePath(logFile);
-          if (StringUtils.isNotBlank(logFileCanonicalPath)) {
+          final String logFileCanonicalPath = tryGetCanonicalPathElseGetAbsolutePath(logFile);
+          if (isNotBlank(logFileCanonicalPath)) {
-
-          if (StringUtils.isNotBlank(serverBindAddressAsString)) {
+          if (isNotBlank(serverBindAddressAsString)) {
-
-          if (StringUtils.isNotBlank(portAsString)) {
+          if (isNotBlank(portAsString)) {
-
-      return (launcher.isDisableDefaultServer() ? StringUtils.EMPTY
-          : launcher.getServerPortAsString());
+      return launcher.isDisableDefaultServer() ? EMPTY : launcher.getServerPortAsString();
-

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 MOV23 UPD40 INS40 INS40 INS40 INS40 UPD40 UPD40 UPD40 UPD40 INS40 UPD40 INS31 UPD83 INS39 MOV29 INS78 INS83 MOV43 MOV42 MOV8 MOV78 INS43 INS23 INS31 INS31 INS31 INS21 UPD42 INS21 UPD42 MOV42 INS42 UPD42 INS83 INS43 INS59 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS44 INS8 INS83 INS83 MOV43 INS42 INS44 INS8 INS32 MOV16 INS7 MOV27 MOV27 MOV27 MOV27 INS42 INS42 INS65 INS65 INS65 INS42 INS41 INS65 INS65 INS65 INS65 INS42 INS83 INS43 INS42 INS21 INS41 INS25 INS25 INS25 UPD66 UPD66 INS43 INS42 INS25 INS25 INS41 INS42 INS42 INS45 INS45 INS22 INS32 INS27 MOV44 INS44 MOV44 INS27 INS32 INS66 INS66 INS66 INS66 INS68 INS22 INS66 INS66 INS42 INS66 INS66 INS66 INS68 INS42 INS7 INS52 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS27 INS8 MOV36 INS27 INS8 INS8 INS32 INS8 MOV27 MOV27 UPD66 UPD66 MOV27 INS32 INS32 INS32 INS32 INS32 INS42 INS27 INS8 INS27 INS8 INS32 MOV16 UPD42 INS52 INS42 INS40 INS42 INS32 UPD42 INS45 INS45 UPD42 INS84 INS42 UPD42 UPD42 INS84 INS42 UPD42 UPD42 MOV43 INS42 INS84 INS42 UPD42 UPD42 INS84 INS42 UPD42 UPD42 UPD42 INS32 INS42 MOV32 INS42 INS21 INS42 INS69 INS52 INS42 INS42 INS22 INS42 INS42 INS33 INS21 INS21 INS41 INS42 INS34 INS21 INS21 MOV21 MOV21 INS32 INS42 INS42 INS53 MOV16 INS42 INS42 INS32 INS42 INS42 INS42 INS45 INS42 INS42 INS42 INS42 INS32 INS33 INS41 INS32 INS33 INS41 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS22 MOV16 MOV16 MOV16 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 INS42 INS42 MOV42 UPD42 UPD42 INS32 INS43 INS52 INS42 INS7 INS7 INS52 INS7 INS7 MOV14 MOV42 INS14 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS84 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS42 INS32 INS42 INS22 INS33 INS22 INS9 INS22 INS34 INS22 INS9 INS43 INS45 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 UPD42 INS86 MOV43 MOV43 INS22 INS42 INS42 INS45 INS52 INS42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV44 MOV8 INS52 INS42 UPD42 UPD34 DEL66 DEL66 DEL65 DEL29 DEL78 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL23 DEL66 DEL66 DEL65 DEL29 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL32 DEL36 DEL42 DEL42 DEL83 DEL31 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL36 DEL83 DEL42 DEL43 DEL83 DEL39 DEL42 DEL31 DEL1 DEL14 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL36 DEL36 DEL36 DEL36 DEL36 DEL45 DEL42 DEL45 DEL32 DEL36 DEL42 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL40 DEL42 DEL42 DEL44 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL40 DEL42 DEL44 DEL42 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL27 DEL32 DEL41 DEL8 DEL12 DEL42 DEL40 DEL65 DEL42 DEL40 DEL65 DEL42 DEL42 DEL42 DEL42 DEL33 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL36 DEL42 DEL40 DEL42 DEL42 DEL43 DEL36 DEL36 DEL36 DEL42 DEL36 DEL33 DEL32 DEL33 DEL33 DEL33 DEL42 DEL42 DEL42 DEL42 DEL40 DEL36
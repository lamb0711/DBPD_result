Merge branch 'develop' into feature/GEODE-7049

+
-import java.util.Iterator;
+  private static final String LOCK_NAME = "PDX_LOCK";
-  public static final int PLACE_HOLDER_FOR_TYPE_ID = 0xFFFFFF;
-  public static final int PLACE_HOLDER_FOR_DS_ID = 0xFF000000;
-  private int dsId;
-  private final int maxTypeId;
-  private volatile DistributedLockService dls;
+  @VisibleForTesting
+  public static final int PLACE_HOLDER_FOR_TYPE_ID = 0xFFFFFF;
+  private static final int PLACE_HOLDER_FOR_DS_ID = 0xFF000000;
+  private static final int MAX_TYPE_ID = 0xFFFFFF;
+
+  private final TypeRegistrationStatistics statistics;
+
+  private final int typeIdPrefix;
-  private InternalCache cache;
+  private final InternalCache cache;
+
+  private volatile DistributedLockService dls;
-  /**
-   * This map serves two purposes. It lets us look up an id based on a type, if we previously found
-   * that type in the region. And, if a type is present in this map, that means we read the type
-   * while holding the dlock, which means the type was distributed to all members.
-   */
-  private Map<PdxType, Integer> typeToId =
-      Collections.synchronizedMap(new HashMap<PdxType, Integer>());
-
-  private Map<EnumInfo, EnumId> enumToId =
-      Collections.synchronizedMap(new HashMap<EnumInfo, EnumId>());
+  private PeerTypeRegistrationReverseMap reverseMap = new PeerTypeRegistrationReverseMap();
-  public PeerTypeRegistration(InternalCache cache) {
+  public PeerTypeRegistration(final InternalCache cache) {
-    int distributedSystemId =
-        cache.getInternalDistributedSystem().getDistributionManager().getDistributedSystemId();
+    final InternalDistributedSystem internalDistributedSystem =
+        cache.getInternalDistributedSystem();
+    typeIdPrefix = getDistributedSystemId(internalDistributedSystem) << 24;
+    statistics =
+        new TypeRegistrationStatistics(internalDistributedSystem.getStatisticsManager(), this);
+  }
+
+  private static int getDistributedSystemId(
+      final InternalDistributedSystem internalDistributedSystem) {
+    final int distributedSystemId =
+        internalDistributedSystem.getDistributionManager().getDistributedSystemId();
-      distributedSystemId = 0;
+      return 0;
-    this.dsId = distributedSystemId << 24;
-    this.maxTypeId = 0xFFFFFF;
+    return distributedSystemId;
-    if (this.idToType != null) {
-      return this.idToType;
+    if (idToType != null) {
+      return idToType;
-      if (this.cache.getPdxPersistent() && this.cache.getCacheConfig().pdxDiskStoreUserSet) {
+      if (cache.getPdxPersistent() && cache.getCacheConfig().pdxDiskStoreUserSet) {
-                + this.cache.getPdxDiskStore() + " was not created.");
+                + cache.getPdxDiskStore() + " was not created.");
-    AttributesFactory<Object, Object> factory = new AttributesFactory<Object, Object>();
+    @SuppressWarnings("deprecation")
+    AttributesFactory<Object, Object> factory = getAttributesFactory();
+
-        // update a local map with the pdxtypes registered
+        // update the local map and reverse map with the pdxtypes registered
-        if (value instanceof PdxType) {
-          updateLocalMaps((PdxType) value);
+        Object key = event.getKey();
+        if (value != null) {
+          updateLocalAndReverseMaps(key, value);
-      this.idToType = cache.createVMRegion(REGION_NAME, regionAttrs, internalArgs);
-    } catch (IOException ex) {
-      throw new PdxInitializationException("Could not create pdx registry", ex);
-    } catch (TimeoutException ex) {
-      throw new PdxInitializationException("Could not create pdx registry", ex);
-    } catch (RegionExistsException ex) {
-      throw new PdxInitializationException("Could not create pdx registry", ex);
-    } catch (ClassNotFoundException ex) {
+      idToType = cache.createVMRegion(REGION_NAME, regionAttrs, internalArgs);
+    } catch (IOException | TimeoutException | RegionExistsException | ClassNotFoundException ex) {
+    statistics.initialize();
+
-    if (this.dls != null) {
-      return this.dls;
+    if (dls != null) {
+      return dls;
-    synchronized (this.dlsLock) {
-      if (this.dls == null) {
+    synchronized (dlsLock) {
+      if (dls == null) {
-          this.dls = DLockService.create(LOCK_SERVICE_NAME,
-              this.cache.getInternalDistributedSystem(), true /* distributed */,
+          dls = DLockService.create(LOCK_SERVICE_NAME,
+              cache.getInternalDistributedSystem(), true /* distributed */,
-          this.dls = DistributedLockService.getServiceNamed(LOCK_SERVICE_NAME);
-          if (this.dls == null) {
+          dls = DistributedLockService.getServiceNamed(LOCK_SERVICE_NAME);
+          if (dls == null) {
-      return this.dls;
+      return dls;
-  private static final String LOCK_NAME = "PDX_LOCK";
-
-    int newTypeId = id | this.dsId;
+    int newTypeId = id | typeIdPrefix;
-      int maxTry = maxTypeId;
+      int maxTry = MAX_TYPE_ID;
-                  + maxTypeId);
+                  + MAX_TYPE_ID);
-        if (id > this.maxTypeId) {
+        if (id > MAX_TYPE_ID) {
-        newTypeId = id | this.dsId;
+        newTypeId = id | typeIdPrefix;
-    int newEnumId = id | this.dsId;
+    int newEnumId = id | typeIdPrefix;
-      int maxTry = this.maxTypeId;
+      int maxTry = MAX_TYPE_ID;
-                  + this.maxTypeId);
+                  + MAX_TYPE_ID);
-        if (id > this.maxTypeId) {
+        if (id > MAX_TYPE_ID) {
-        newEnumId = id | this.dsId;
+        newEnumId = id | typeIdPrefix;
+    statistics.typeDefined();
-    Integer existingId = typeToId.get(newType);
-
+    Integer existingId = reverseMap.getIdFromReverseMap(newType);
-      if (typeToId.isEmpty()) {
-        buildTypeToIdFromIdToType();
+      if (reverseMap.shouldReloadFromRegion(getIdToType())) {
+        buildReverseMapsFromRegion();
-      // double check if my type is in region in case the typeToId map has been updated while
-      // waiting to obtain a lock
-      existingId = typeToId.get(newType);
+      reverseMap.flushPendingReverseMap();
+
+      // double check if my PdxType is in the reverse map in case it was just flushed into it
+      existingId = reverseMap.getIdFromReverseMap(newType);
+
+      // flush the reverse map for the member that introduced this new PdxType
+      reverseMap.flushPendingReverseMap();
+    statistics.typeCreated();
+    statistics.enumCreated();
+  @SuppressWarnings("unchecked")
-    if (!typeRegistryInUse || this.idToType == null) {
+    if (!typeRegistryInUse || idToType == null) {
-    checkAllowed(true, this.cache.hasPersistentRegion());
+    checkAllowed(true, cache.hasPersistentRegion());
-  public boolean hasGatewaySender() {
+  private boolean hasGatewaySender() {
-    Iterator<GatewaySender> itr = sendersAndAsyncQueues.iterator();
-    while (itr.hasNext()) {
-      GatewaySender sender = itr.next();
-      if (AsyncEventQueueImpl.isAsyncEventQueue(sender.getId())) {
-        itr.remove();
-      }
-    }
+    sendersAndAsyncQueues.removeIf(sender -> AsyncEventQueueImpl.isAsyncEventQueue(sender.getId()));
-    if (typeRegistryInUse) {
-      return;
-    } else {
-      checkAllowed(hasGatewaySender(), this.cache.hasPersistentRegion());
+    if (!typeRegistryInUse) {
+      checkAllowed(hasGatewaySender(), cache.hasPersistentRegion());
-  private void buildTypeToIdFromIdToType() {
+  /**
+   * Should only be called holding the dlock
+   * This method iterates through the entire PdxTypes region and syncs the reverse map with the pdx
+   * region This is an expensive operation and should only be called during initialization. A cache
+   * listener is used to keep the reverse maps up to date.
+   */
+  void buildReverseMapsFromRegion() {
+    int totalEnumIdInDS = 0;
+      reverseMap.clear();
-        Object v = entry.getValue();
+        Object v = entry.getValue();
-          EnumInfo info = (EnumInfo) v;
-          enumToId.put(info, id);
-        } else {
-          PdxType foundType = (PdxType) v;
-          Integer id = (Integer) k;
-          int tmpDsId = PLACE_HOLDER_FOR_DS_ID & id;
-          if (tmpDsId == this.dsId) {
-            totalPdxTypeIdInDS++;
-            if (totalPdxTypeIdInDS >= this.maxTypeId) {
+          int tmpDsId = PLACE_HOLDER_FOR_DS_ID & id.intValue();
+          if (tmpDsId == typeIdPrefix) {
+            totalEnumIdInDS++;
+            if (totalEnumIdInDS >= MAX_TYPE_ID) {
-                  "Used up all of the PDX type ids for this distributed system. The maximum number of PDX types is "
-                      + this.maxTypeId);
+                  "Used up all of the PDX enum ids for this distributed system. The maximum number of PDX types is "
+                      + MAX_TYPE_ID);
-
-          typeToId.put(foundType, id);
-        }
-      }
-    } finally {
-      resumeTX(currentState);
-    }
-  }
-
-  /** Should be called holding the dlock */
-  private EnumId getExistingIdForEnum(EnumInfo ei) {
-    TXStateProxy currentState = suspendTX();
-    int totalEnumIdInDS = 0;
-    try {
-      EnumId result = null;
-      for (Map.Entry<Object, Object> entry : getIdToType().entrySet()) {
-        Object v = entry.getValue();
-        Object k = entry.getKey();
-        if (k instanceof EnumId) {
-          EnumId id = (EnumId) k;
-          EnumInfo info = (EnumInfo) v;
-          enumToId.put(info, id);
-          int tmpDsId = PLACE_HOLDER_FOR_DS_ID & id.intValue();
-          if (tmpDsId == this.dsId) {
-            totalEnumIdInDS++;
-          }
-          if (ei.equals(info)) {
-            result = id;
-          }
-          typeToId.put((PdxType) v, (Integer) k);
+          Integer id = (Integer) k;
+          int tmpDsId = PLACE_HOLDER_FOR_DS_ID & id;
+          if (tmpDsId == typeIdPrefix) {
+            totalPdxTypeIdInDS++;
+            if (totalPdxTypeIdInDS >= MAX_TYPE_ID) {
+              throw new InternalGemFireError(
+                  "Used up all of the PDX type ids for this distributed system. The maximum number of PDX types is "
+                      + MAX_TYPE_ID);
+            }
+          }
+        reverseMap.save(k, v);
-
-      if (totalEnumIdInDS == this.maxTypeId) {
-        throw new InternalGemFireError(
-            "Used up all of the PDX enum ids for this distributed system. The maximum number of PDX types is "
-                + this.maxTypeId);
-      }
-      return result;
-    verifyConfiguration();
-    EnumInfo ei = new EnumInfo(v);
-    EnumId existingId = enumToId.get(ei);
-    if (existingId != null) {
-      return existingId.intValue();
-    }
-    lock();
-    try {
-      EnumId id = getExistingIdForEnum(ei);
-      if (id != null) {
-        return id.intValue();
-      }
-
-      id = allocateEnumId(ei);
-
-      updateIdToEnumRegion(id, ei);
-
-      enumToId.put(ei, id);
-
-      return id.intValue();
-    } finally {
-      unlock();
-    }
+    return defineEnum(new EnumInfo(v));
-  public int defineEnum(EnumInfo newInfo) {
+  public int defineEnum(final EnumInfo newInfo) {
+    statistics.enumDefined();
-    EnumId existingId = enumToId.get(newInfo);
+    EnumId existingId = reverseMap.getIdFromReverseMap(newInfo);
-      EnumId id = getExistingIdForEnum(newInfo);
-      if (id != null) {
-        return id.intValue();
+      if (reverseMap.shouldReloadFromRegion(getIdToType())) {
+        buildReverseMapsFromRegion();
+      }
+      reverseMap.flushPendingReverseMap();
+
+      // double check if my Enum is in the reverse map in case it was just flushed into it
+      existingId = reverseMap.getIdFromReverseMap(newInfo);
+      if (existingId != null) {
+        return existingId.intValue();
-      id = allocateEnumId(newInfo);
-
+      EnumId id = allocateEnumId(newInfo);
-      enumToId.put(newInfo, id);
-
+      // flush the reverse map for the member that introduced this new enumInfo
+      reverseMap.flushPendingReverseMap();
-    Map<Integer, EnumInfo> enums = new HashMap<Integer, EnumInfo>();
+    Map<Integer, EnumInfo> enums = new HashMap<>();
-  private void updateLocalMaps(PdxType type) {
-    if (type != null) {
-      typeToId.put(type, type.getTypeId());
-      synchronized (this.classToType) {
+  private void updateLocalAndReverseMaps(Object key, Object value) {
+    reverseMap.saveToPending(key, value);
+    if (value instanceof PdxType) {
+      PdxType type = (PdxType) value;
+      synchronized (classToType) {
-        CopyOnWriteHashSet<PdxType> pdxTypeSet = this.classToType.get(type.getClassName());
+        CopyOnWriteHashSet<PdxType> pdxTypeSet = classToType.get(type.getClassName());
-          pdxTypeSet = new CopyOnWriteHashSet<PdxType>();
+          pdxTypeSet = new CopyOnWriteHashSet<>();
+  @Deprecated
-    if (cache == null) {
-      return 0;
-    }
-
-    return idToType.size();
+    return getIdToType().size();
+  }
+
+  @VisibleForTesting
+  @SuppressWarnings("deprecation")
+  protected AttributesFactory<Object, Object> getAttributesFactory() {
+    return new AttributesFactory<>();
-    return typeToId.size();
+    return reverseMap.typeToIdSize();
+  }
+
+  @VisibleForTesting
+  public int getEnumToIdSize() {
+    return reverseMap.enumToIdSize();

MOV23 MOV23 MOV23 MOV31 MOV31 INS31 INS31 INS31 INS78 UPD83 INS83 INS83 INS43 INS83 INS39 INS83 INS43 INS83 INS83 INS39 INS42 INS44 INS8 INS79 UPD83 INS29 UPD42 MOV78 UPD83 INS39 INS42 MOV44 INS8 MOV78 UPD42 INS44 UPD42 INS44 INS78 MOV78 MOV83 MOV39 INS42 INS8 INS78 INS79 INS83 MOV74 INS42 INS8 INS78 UPD42 UPD42 INS42 UPD42 INS34 INS42 UPD42 UPD42 UPD42 MOV42 INS42 INS14 INS83 INS83 INS43 INS42 INS60 MOV25 INS41 INS21 MOV54 MOV54 INS21 INS21 INS21 INS42 INS45 INS21 INS65 MOV60 INS41 INS83 MOV43 INS42 MOV21 MOV21 INS43 INS42 INS43 UPD42 INS21 INS42 MOV41 INS42 INS42 INS45 INS41 INS42 INS43 INS83 INS43 INS42 INS83 INS39 INS59 MOV8 INS42 INS79 INS32 INS42 MOV8 MOV8 INS32 INS32 INS32 INS32 MOV38 INS66 INS66 INS66 INS66 INS32 MOV43 INS42 INS42 INS32 MOV62 INS14 UPD42 MOV42 INS42 UPD42 INS42 INS42 INS14 INS42 INS32 INS42 INS42 INS45 INS32 INS42 INS42 INS42 MOV41 MOV41 INS42 INS42 INS21 INS21 INS42 INS42 INS42 INS42 INS38 MOV42 UPD42 MOV42 INS86 INS21 UPD42 MOV42 MOV14 UPD42 INS42 INS25 MOV25 INS60 MOV21 MOV41 INS21 INS42 INS42 INS42 INS42 INS60 INS32 UPD42 INS74 UPD42 UPD42 UPD42 UPD42 INS42 UPD42 INS32 INS43 INS32 INS52 INS32 INS42 INS42 INS42 INS84 INS42 INS42 INS42 MOV27 INS42 MOV27 UPD42 UPD42 INS32 INS32 INS42 INS42 INS42 INS59 MOV32 INS32 MOV60 UPD42 UPD42 UPD42 INS32 MOV8 INS32 INS7 MOV43 INS59 INS32 UPD74 MOV43 INS59 INS42 UPD42 MOV42 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 MOV43 MOV43 MOV43 INS42 INS42 UPD42 UPD42 UPD42 INS32 INS42 INS42 INS42 INS42 MOV42 INS42 INS42 INS25 MOV21 INS42 INS42 INS32 INS21 UPD42 MOV42 UPD42 MOV42 INS42 INS32 INS42 MOV32 INS42 INS42 INS42 MOV11 INS42 INS42 INS42 UPD42 UPD42 INS42 MOV62 INS8 INS8 UPD42 MOV42 INS32 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS60 INS42 UPD42 INS42 UPD42 UPD42 MOV60 MOV60 INS25 MOV60 MOV60 MOV25 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 INS43 INS59 INS27 INS42 INS42 MOV43 MOV39 MOV59 INS27 INS8 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS42 MOV32 MOV32 MOV42 MOV11 INS42 INS42 MOV21 INS25 INS42 INS42 INS42 UPD42 INS42 INS42 INS9 INS9 INS9 INS42 INS42 INS42 UPD42 MOV43 INS27 INS8 UPD74 UPD42 INS42 INS42 INS42 INS42 INS53 INS42 INS14 MOV43 INS27 UPD42 MOV42 INS45 INS42 INS42 DEL40 DEL26 DEL39 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL32 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL32 DEL39 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL34 DEL42 DEL34 DEL7 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL14 DEL52 DEL42 DEL22 DEL42 DEL44 DEL42 DEL43 DEL45 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL44 DEL42 DEL43 DEL45 DEL42 DEL14 DEL53 DEL8 DEL12 DEL42 DEL44 DEL42 DEL43 DEL45 DEL42 DEL14 DEL53 DEL8 DEL12 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL9 DEL9 DEL9 DEL32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL61 DEL42 DEL41 DEL8 DEL52 DEL42 DEL22 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL8 DEL25 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL59 DEL60 DEL40 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL52 DEL42 DEL22 DEL27 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL43 DEL42 DEL11 DEL42 DEL43 DEL42 DEL11 DEL32 DEL21 DEL8 DEL25 DEL8 DEL70 DEL42 DEL52 DEL42 DEL22 DEL27 DEL45 DEL52 DEL42 DEL22 DEL27 DEL14 DEL53 DEL8 DEL25 DEL42 DEL41 DEL8 DEL42 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL42 DEL43 DEL42 DEL59 DEL60 DEL42 DEL32 DEL21 DEL42 DEL32 DEL41 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL25 DEL42 DEL32 DEL7 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL42 DEL42 DEL32 DEL41 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL8 DEL25 DEL42 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL32 DEL21 DEL8 DEL54 DEL8 DEL31 DEL42 DEL43 DEL42 DEL43 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL33 DEL27 DEL25
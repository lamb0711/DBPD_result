Merge branch 'release/1.1.0'

- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
+ * in compliance with the License. You may obtain a copy of the License at
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * HLL is an improved version of LogLog that is capable of estimating
- * the cardinality of a set with accuracy = 1.04/sqrt(m) where
- * m = 2^b.  So we can control accuracy vs space usage by increasing
- * or decreasing b.
+ * HLL is an improved version of LogLog that is capable of estimating the cardinality of a set with
+ * accuracy = 1.04/sqrt(m) where m = 2^b. So we can control accuracy vs space usage by increasing or
+ * decreasing b.
- * The main benefit of using HLL over LL is that it only requires 64%
- * of the space that LL does to get the same accuracy.
+ * The main benefit of using HLL over LL is that it only requires 64% of the space that LL does to
+ * get the same accuracy.
- * This implementation implements a single counter.  If a large (millions)
- * number of counters are required you may want to refer to:
+ * This implementation implements a single counter. If a large (millions) number of counters are
+ * required you may want to refer to:
- * It has a more complex implementation of HLL that supports multiple counters
- * in a single object, drastically reducing the java overhead from creating
- * a large number of objects.
+ * It has a more complex implementation of HLL that supports multiple counters in a single object,
+ * drastically reducing the java overhead from creating a large number of objects.
- * This implementation leveraged a javascript implementation that Yammer has
- * been working on:
+ * This implementation leveraged a javascript implementation that Yammer has been working on:
- * Note that this implementation does not include the long range correction function
- * defined in the original paper.  Empirical evidence shows that the correction
- * function causes more harm than good.
+ * Note that this implementation does not include the long range correction function defined in the
+ * original paper. Empirical evidence shows that the correction function causes more harm than good.
- * Users have different motivations to use different types of hashing functions.
- * Rather than try to keep up with all available hash functions and to remove
- * the concern of causing future binary incompatibilities this class allows clients
- * to offer the value in hashed int or long form.  This way clients are free
- * to change their hash function on their own time line.  We recommend using Google's
- * Guava Murmur3_128 implementation as it provides good performance and speed when
- * high precision is required.  In our tests the 32bit MurmurHash function included
- * in this project is faster and produces better results than the 32 bit murmur3
- * implementation google provides.
+ * Users have different motivations to use different types of hashing functions. Rather than try to
+ * keep up with all available hash functions and to remove the concern of causing future binary
+ * incompatibilities this class allows clients to offer the value in hashed int or long form. This
+ * way clients are free to change their hash function on their own time line. We recommend using
+ * Google's Guava Murmur3_128 implementation as it provides good performance and speed when high
+ * precision is required. In our tests the 32bit MurmurHash function included in this project is
+ * faster and produces better results than the 32 bit murmur3 implementation google provides.
-   * @param rsd - the relative standard deviation for the counter.
-   *            smaller values create counters that require more space.
+   * @param rsd - the relative standard deviation for the counter. smaller values create counters
+   *        that require more space.
-   * Create a new HyperLogLog instance.  The log2m parameter defines the accuracy of
-   * the counter.  The larger the log2m the better the accuracy.
+   * Create a new HyperLogLog instance. The log2m parameter defines the accuracy of the counter. The
+   * larger the log2m the better the accuracy.
-   * Creates a new HyperLogLog instance using the given registers.  Used for unmarshalling a serialized
-   * instance and for merging multiple counters together.
+   * Creates a new HyperLogLog instance using the given registers. Used for unmarshalling a
+   * serialized instance and for merging multiple counters together.
-      throw new IllegalArgumentException("log2m argument is "
-          + log2m + " and is outside the range [0, 30]");
+      throw new IllegalArgumentException(
+          "log2m argument is " + log2m + " and is outside the range [0, 30]");
-    final int r = Long.numberOfLeadingZeros((hashedValue << this.log2m) | (1 << (this.log2m - 1)) + 1) + 1;
+    final int r =
+        Long.numberOfLeadingZeros((hashedValue << this.log2m) | (1 << (this.log2m - 1)) + 1) + 1;
-    final int r = Integer.numberOfLeadingZeros((hashedValue << this.log2m) | (1 << (this.log2m - 1)) + 1) + 1;
+    final int r =
+        Integer.numberOfLeadingZeros((hashedValue << this.log2m) | (1 << (this.log2m - 1)) + 1) + 1;
-    HyperLogLog merged = new HyperLogLog(HllExecutor.DEFAULT_HLL_STD_DEV);//new HyperLogLog(log2m, new RegisterSet(this.registerSet.count));
+    HyperLogLog merged = new HyperLogLog(HllExecutor.DEFAULT_HLL_STD_DEV);// new HyperLogLog(log2m,
+                                                                          // new
+                                                                          // RegisterSet(this.registerSet.count));
-   * This class exists to support Externalizable semantics for
-   * HyperLogLog objects without having to expose a public
-   * constructor, public write/read methods, or pretend final
-   * fields aren't final.
+   * This class exists to support Externalizable semantics for HyperLogLog objects without having to
+   * expose a public constructor, public write/read methods, or pretend final fields aren't final.
-   * In short, Externalizable allows you to skip some of the more
-   * verbose meta-data default Serializable gets you, but still
-   * includes the class name. In that sense, there is some cost
-   * to this holder object because it has a longer class name. I
-   * imagine people who care about optimizing for that have their
-   * own work-around for long class names in general, or just use
-   * a custom serialization framework. Therefore we make no attempt
-   * to optimize that here (eg. by raising this from an inner class
-   * and giving it an unhelpful name).
+   * In short, Externalizable allows you to skip some of the more verbose meta-data default
+   * Serializable gets you, but still includes the class name. In that sense, there is some cost to
+   * this holder object because it has a longer class name. I imagine people who care about
+   * optimizing for that have their own work-around for long class names in general, or just use a
+   * custom serialization framework. Therefore we make no attempt to optimize that here (eg. by
+   * raising this from an inner class and giving it an unhelpful name).
-    case 4:
-      return 0.673 * m * m;
-    case 5:
-      return 0.697 * m * m;
-    case 6:
-      return 0.709 * m * m;
-    default:
-      return (0.7213 / (1 + 1.079 / m)) * m * m;
+      case 4:
+        return 0.673 * m * m;
+      case 5:
+        return 0.697 * m * m;
+      case 6:
+        return 0.709 * m * m;
+      default:
+        return (0.7213 / (1 + 1.079 / m)) * m * m;

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
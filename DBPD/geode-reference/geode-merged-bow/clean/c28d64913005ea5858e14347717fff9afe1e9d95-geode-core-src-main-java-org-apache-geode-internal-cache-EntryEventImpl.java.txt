Merge branch 'release/1.4.0'

+import java.io.ByteArrayInputStream;
+import java.io.DataInput;
+import java.io.DataInputStream;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.function.Function;
+
+import org.apache.logging.log4j.Logger;
+
-import org.apache.geode.internal.cache.lru.Sizeable;
+import org.apache.geode.internal.cache.entries.OffHeapRegionEntry;
+import org.apache.geode.internal.size.Sizeable;
-import org.apache.logging.log4j.Logger;
-
-import java.io.ByteArrayInputStream;
-import java.io.DataInput;
-import java.io.DataInputStream;
-import java.io.DataOutput;
-import java.io.IOException;
-import java.util.function.Function;
-  public final static Object SUSPECT_TOKEN = new Object();
+  public static final Object SUSPECT_TOKEN = new Object();
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-      Object ov = basicGetOldValue();
-      if (ov == null) {
-        return null;
-      } else if (ov == Token.NOT_AVAILABLE) {
-        return AbstractRegion.handleNotAvailable(ov);
-      }
-      boolean doCopyOnRead = getRegion().isCopyOnRead();
+      Object ov = handleNotAvailableOldValue();
+        boolean doCopyOnRead = getRegion().isCopyOnRead();
+   * returns the old value after handling one this is NOT_AVAILABLE. If the old value is
+   * NOT_AVAILABLE then it may try to read it from disk. If it can't read an unavailable old value
+   * from disk then it will return null instead of NOT_AVAILABLE.
+   */
+  @Unretained(ENTRY_EVENT_OLD_VALUE)
+  private Object handleNotAvailableOldValue() {
+    @Unretained
+    Object result = basicGetOldValue();
+    if (result != Token.NOT_AVAILABLE) {
+      return result;
+    }
+    if (getReadOldValueFromDisk()) {
+      try {
+        result = this.region.getValueInVMOrDiskWithoutFaultIn(getKey());
+      } catch (EntryNotFoundException ex) {
+        result = null;
+      }
+    }
+    result = AbstractRegion.handleNotAvailable(result);
+    return result;
+  }
+
+  /**
+   * If true then when getOldValue is called if the NOT_AVAILABLE is found then an attempt will be
+   * made to read the old value from disk without faulting it in. Should only be set to true when
+   * product is calling a method on a CacheWriter.
+   */
+  private boolean readOldValueFromDisk;
+
+  public boolean getReadOldValueFromDisk() {
+    return this.readOldValueFromDisk;
+  }
+
+  public void setReadOldValueFromDisk(boolean v) {
+    this.readOldValueFromDisk = v;
+  }
+
+  /**
-   * 
+   *
-  private void basicSetOldValue(@Unretained(ENTRY_EVENT_OLD_VALUE) Object v) {
+  void basicSetOldValue(@Unretained(ENTRY_EVENT_OLD_VALUE) Object v) {
-    if (v == curOldValue)
+    if (v == curOldValue) {
+    }
-    if (v == this.oldValue)
+    if (v == this.oldValue) {
-
+    }
-  private Object basicGetOldValue() {
+  Object basicGetOldValue() {
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-   * 
+   *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-   * 
+   *
-   * 
+   *
-   * 
+   *
+  protected boolean areOldValuesEnabled() {
+    return EVENT_OLD_VALUE;
+  }
-   * 
+   *
-        if (requireOldValue || EVENT_OLD_VALUE || this.region instanceof HARegion // fix for bug
-                                                                                  // 37909
+        if (requireOldValue || areOldValuesEnabled() || this.region instanceof HARegion // fix for
+                                                                                        // bug
+        // 37909
-            ov = reentry._getValueRetain(owner, true);
+            ov = reentry.getValueRetain(owner, true);
-            ov = reentry._getValueRetain(owner, true);
+            ov = reentry.getValueRetain(owner, true);
-      if (mustBeAvailable || oldVal == null || EVENT_OLD_VALUE) {
+      if (mustBeAvailable || oldVal == null || areOldValuesEnabled()) {
-  /** @return false if entry doesn't exist */
-  public boolean setOldValueFromRegion() {
+  public void setOldValueFromRegion() {
-      if (re == null)
-        return false;
+      if (re == null) {
+        return;
+      }
-      Object v = re._getValueRetain(this.region, true);
+      Object v = re.getValueRetain(this.region, true);
+      if (v == null) {
+        v = Token.NOT_AVAILABLE;
+      }
-        return setOldValue(v);
+        setOldValue(v);
-      return false;
-  /**
-   * @return false if value 'v' indicates that entry does not exist
-   */
-  public boolean setOldValue(Object v) {
-    return setOldValue(v, false);
+  public void setOldValue(Object v) {
+    setOldValue(v, false);
-   * @param force true if the old value should be forcibly set, used for HARegions, methods like
-   *        putIfAbsent, etc., where the old value must be available.
-   * @return false if value 'v' indicates that entry does not exist
+   * @param force true if the old value should be forcibly set, methods like putIfAbsent, etc.,
+   *        where the old value must be available.
-  public boolean setOldValue(Object v, boolean force) {
-    if (v == null || Token.isRemoved(v)) {
-      return false;
-    } else {
-      if (Token.isInvalid(v)) {
+  public void setOldValue(Object v, boolean force) {
+    if (v != null) {
+      if (Token.isInvalidOrRemoved(v)) {
-      } else {
-        if (force || (this.region instanceof HARegion) // fix for bug 37909
-        ) {
-          // set oldValue to "v".
-        } else if (EVENT_OLD_VALUE) {
-          // TODO Rusty add compression support here
-          // set oldValue to "v".
-        } else {
-          v = Token.NOT_AVAILABLE;
-        }
+      } else if (shouldOldValueBeUnavailable(v, force)) {
+        v = Token.NOT_AVAILABLE;
-      retainAndSetOldValue(v);
-      return true;
+    retainAndSetOldValue(v);
+  }
+
+  private boolean shouldOldValueBeUnavailable(Object v, boolean force) {
+    if (force) {
+      return false;
+    }
+    if (areOldValuesEnabled()) {
+      return false;
+    }
+    if (this.region instanceof HARegion) {
+      return false;
+    }
+    return true;
-   * 
+   *
+        ov = AbstractRegion.handleNotAvailable(ov);
-  private static abstract class EventFlags {
+  private abstract static class EventFlags {
-   * 
+   *
-  void invokeCallbacks(LocalRegion rgn, boolean skipListeners, boolean notifyGateways) {
+  public void invokeCallbacks(InternalRegion rgn, boolean skipListeners, boolean notifyGateways) {
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS40 UPD40 INS31 INS23 INS31 INS31 INS31 INS31 INS83 INS29 INS79 INS83 INS43 INS42 INS8 INS29 INS83 INS39 INS59 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS8 UPD39 UPD39 UPD39 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS83 INS65 INS42 INS42 INS42 MOV60 INS25 INS25 INS21 INS41 INS65 INS42 INS41 INS39 INS42 INS21 INS41 INS21 MOV21 INS43 INS42 INS39 INS42 INS25 INS25 INS25 MOV41 UPD43 INS66 INS66 INS66 INS27 INS8 INS32 INS8 INS7 INS42 INS66 INS66 INS66 INS22 INS7 INS8 INS8 INS42 MOV32 UPD66 UPD66 INS27 INS8 INS42 INS42 MOV8 INS32 MOV8 MOV62 INS8 UPD42 INS60 UPD42 INS42 INS40 INS41 INS42 INS54 INS42 INS32 INS52 INS42 INS22 INS42 INS41 INS41 INS25 INS8 MOV42 MOV33 INS25 INS42 INS41 INS78 INS43 INS59 INS42 INS8 INS12 INS42 INS42 INS42 INS52 INS42 INS8 MOV27 INS8 INS32 MOV8 INS25 INS9 INS21 INS42 INS42 INS42 INS32 MOV60 INS21 INS44 INS8 INS32 INS41 INS42 INS33 INS21 INS21 MOV42 UPD42 MOV42 MOV42 INS32 MOV8 INS7 INS42 INS7 INS43 INS42 INS21 INS42 UPD42 INS7 MOV32 UPD42 MOV42 MOV42 INS42 INS42 MOV32 INS42 INS32 INS42 INS7 INS32 INS42 INS40 INS22 INS42 INS32 INS42 INS33 INS42 INS52 INS42 INS42 UPD42 UPD42 DEL83 DEL42 DEL33 DEL27 DEL33 DEL41 DEL8 DEL42 DEL40 DEL27 DEL41 DEL8 DEL25 DEL25 DEL83 DEL41 DEL41 DEL83 DEL42 DEL42 DEL66 DEL65 DEL29 DEL9 DEL41 DEL41 DEL66 DEL65 DEL29 DEL41 DEL66 DEL65 DEL32 DEL27 DEL42 DEL32 DEL42 DEL36 DEL27 DEL8 DEL42 DEL8 DEL25 DEL25 DEL8 DEL25 DEL8 DEL83
GEODE-7436: Deploy jar using semantic versioning scheme (#4343)

Co-authored-by: Dale Emery <demery@pivotal.io>
Co-authored-by: Jinmei Liao <jiliao@pivotal.io>
Co-authored-by: Darrel Schneider <dschneider@pivotal.io>
Co-authored-by: Joris Melchior <jmelchior@pivotal.io>

* Deploy jar using semantic versioning scheme
* always add sequence number at the end of the filename no matter what version scheme the deployed file uses.

-import static java.util.stream.Collectors.joining;
-import java.net.URL;
+import java.nio.file.Path;
-import java.util.Objects;
-import java.util.Optional;
+import org.apache.commons.io.FilenameUtils;
-  public static final String JAR_PREFIX_FOR_REGEX = "";
+  // The pound version scheme predates the sequenced version scheme
+  private static final Pattern POUND_VERSION_SCHEME =
+      Pattern.compile("^vf\\.gf#(?<artifact>.*)\\.jar#(?<version>\\d+)$");
+  // Every deployed file will use this scheme to signify the sequence it's been deployed
+  static final Pattern DEPLOYED_FILE_PATTERN =
+      Pattern.compile("(?<baseName>..*)\\.v(?<version>\\d++).jar$");
+  // we can recognize jar files with below pattern. If two jar files have the same artifact, then
+  // the latter will replace the former deployed jar
+  private static final Pattern USER_VERSION_PATTERN =
+      Pattern.compile("(?<artifact>.*?)[-.]\\d+.*\\.jar$");
+
-
-
-  // Split a versioned filename into its name and version
-  public static final Pattern versionedPattern =
-      Pattern.compile(JAR_PREFIX_FOR_REGEX + "(.*)\\.v(\\d++).jar$");
-
-  public File getDeployDirectory() {
-    return this.deployDirectory;
-  }
-
-   * not match the latest deployed version)
+   * not match the latest deployed version).
-  public DeployedJar deployWithoutRegistering(final String jarName, final File stagedJar)
+  public DeployedJar deployWithoutRegistering(final File stagedJar)
-
+    String stagedJarName = stagedJar.getName();
+    String artifactId = getArtifactId(stagedJarName);
-      boolean shouldDeployNewVersion = shouldDeployNewVersion(jarName, stagedJar);
+      boolean shouldDeployNewVersion = shouldDeployNewVersion(artifactId, stagedJar);
-        logger.debug("No need to deploy a new version of {}", jarName);
+        logger.debug("No need to deploy a new version of {}", stagedJarName);
+      Path deployedFile = getNextVersionedJarFile(stagedJarName).toPath();
+      Files.copy(stagedJar.toPath(), deployedFile);
-      File newVersionedJarFile = getNextVersionedJarFile(jarName);
-      Files.copy(stagedJar.toPath(), newVersionedJarFile.toPath());
-
-      return new DeployedJar(newVersionedJarFile, jarName);
+      return new DeployedJar(deployedFile.toFile());
-    File[] oldVersions = findSortedOldVersionsOfJar(unversionedJarName);
+    int maxVersion = getMaxVersion(getArtifactId(unversionedJarName));
-    String nextVersionedJarName;
-    if (oldVersions == null || oldVersions.length == 0) {
-      nextVersionedJarName = removeJarExtension(unversionedJarName) + ".v1.jar";
-    } else {
-      String latestVersionedJarName = oldVersions[0].getName();
-      int nextVersion = extractVersionFromFilename(latestVersionedJarName) + 1;
-      nextVersionedJarName = removeJarExtension(unversionedJarName) + ".v" + nextVersion + ".jar";
-    }
+    String nextVersionJarName =
+        FilenameUtils.getBaseName(unversionedJarName) + ".v" + (maxVersion + 1) + ".jar";
-    logger.debug("Next versioned jar name for {} is {}", unversionedJarName, nextVersionedJarName);
+    logger.debug("Next versioned jar name for {} is {}", unversionedJarName, nextVersionJarName);
-    return new File(deployDirectory, nextVersionedJarName);
+    return new File(deployDirectory, nextVersionJarName);
+  }
+
+  protected int getMaxVersion(String artifactId) {
+    return Arrays.stream(deployDirectory.list()).filter(x -> artifactId.equals(toArtifactId(x)))
+        .map(JarDeployer::extractVersionFromFilename)
+        .reduce(Integer::max).orElse(0);
-    final Matcher matcher = versionedPattern.matcher(filename);
+    final Matcher matcher = DEPLOYED_FILE_PATTERN.matcher(filename);
-  protected Set<String> findDistinctDeployedJarsOnDisk() {
-    // Find all deployed JAR files
-    final File[] oldFiles =
-        this.deployDirectory.listFiles((file, name) -> versionedPattern.matcher(name).matches());
+  public static boolean isDeployedFile(String filename) {
+    return DEPLOYED_FILE_PATTERN.matcher(filename).find();
+  }
-    // Now add just the original JAR name to the set
-    final Set<String> jarNames = new HashSet<>();
-    for (File oldFile : oldFiles) {
-      Matcher matcher = versionedPattern.matcher(oldFile.getName());
-      matcher.find();
-      jarNames.add(matcher.group(1) + ".jar");
-    }
-    return jarNames;
+  public static boolean isSemanticVersion(String filename) {
+    return USER_VERSION_PATTERN.matcher(filename).find();
-   * Find all versions of the JAR file that are currently on disk and return them sorted from newest
-   * (highest version) to oldest
+   * get the artifact id from the existing files on the server. This will skip files that
+   * do not have sequence id appended to them.
-   * @param unversionedJarName Name of the JAR file that we want old versions of
-   * @return Sorted array of files that are older versions of the given JAR
+   * @param sequencedJarFileName the file names that exists on the server, it should always ends
+   *        with a sequence number
+   * @return the artifact id. if a file with no sequence number is passed in, this will return null
-  protected File[] findSortedOldVersionsOfJar(final String unversionedJarName) {
-    logger.debug("Finding sorted old versions of {}", unversionedJarName);
-    // Find all matching files
-    final Pattern pattern = Pattern.compile(
-        JAR_PREFIX_FOR_REGEX + removeJarExtension(unversionedJarName) + "\\.v\\d++\\.jar$");
-    final File[] oldJarFiles =
-        this.deployDirectory.listFiles((file, name) -> (pattern.matcher(name).matches()));
+  static String toArtifactId(String sequencedJarFileName) {
+    String baseName = getDeployedFileBaseName(sequencedJarFileName);
+    if (baseName == null) {
+      return null;
+    }
-    // Sort them in order from newest (highest version) to oldest
-    Arrays.sort(oldJarFiles, (file1, file2) -> {
-      int file1Version = extractVersionFromFilename(file1.getName());
-      int file2Version = extractVersionFromFilename(file2.getName());
-      return file2Version - file1Version;
-    });
-
-    logger.debug("Found [{}]",
-        Arrays.stream(oldJarFiles).map(File::getAbsolutePath).collect(joining(",")));
-    return oldJarFiles;
+    return getArtifactId(baseName + ".jar");
-  protected String removeJarExtension(String jarName) {
-    if (jarName != null && jarName.endsWith(".jar")) {
-      return jarName.replaceAll("\\.jar$", "");
+  /**
+   * get the artifact id from the files deployed by the user. This will recognize files with
+   * SEMANTIC_VERSION_PATTERN, it will strip off the version part from the filename. For all other
+   * file names, it will just return the basename.
+   *
+   * @param deployedJarFileName the filename that's deployed by the user. could be in the form of
+   *        abc.jar or abc-1.0.0.jar, both should return abc
+   * @return the artifact id of the string
+   */
+  public static String getArtifactId(String deployedJarFileName) {
+    Matcher semanticVersionMatcher = USER_VERSION_PATTERN.matcher(deployedJarFileName);
+    if (semanticVersionMatcher.matches()) {
+      return semanticVersionMatcher.group("artifact");
-      return jarName;
+      return FilenameUtils.getBaseName(deployedJarFileName);
+    }
+  }
+
+  public static String getDeployedFileBaseName(String sequencedJarFileName) {
+    Matcher semanticVersionMatcher = DEPLOYED_FILE_PATTERN.matcher(sequencedJarFileName);
+    if (semanticVersionMatcher.matches()) {
+      return semanticVersionMatcher.group("baseName");
+    } else {
+      return null;
-  final Pattern oldNamingPattern = Pattern.compile("^vf\\.gf#(.*)\\.jar#(\\d+)$");
-
-    return oldNamingPattern.matcher(fileName).matches();
+    return POUND_VERSION_SCHEME.matcher(fileName).matches();
-    Matcher matcher = oldNamingPattern.matcher(oldJar.getName());
+    Matcher matcher = POUND_VERSION_SCHEME.matcher(oldJar.getName());
+   * It will clean up the old version of deployed jars that are in the deployed directory
-
-      final Set<String> jarNames = findDistinctDeployedJarsOnDisk();
-      if (jarNames.isEmpty()) {
-        return;
-      }
-
+      // find all the artifacts and its max versions
+      Map<String, Integer> artifactToMaxVersion = findArtifactsAndMaxVersion();
-      for (String jarName : jarNames) {
-        DeployedJar deployedJar = findLatestValidDeployedJarFromDisk(jarName);
-
-        if (deployedJar != null) {
-          latestVersionOfEachJar.add(deployedJar);
-          deleteOtherVersionsOfJar(deployedJar);
+      // clean up the old versions and find the latest version of each jar
+      for (File file : deployDirectory.listFiles()) {
+        String artifactId = toArtifactId(file.getName());
+        if (artifactId == null) {
+          continue;
+        }
+        int version = extractVersionFromFilename(file.getName());
+        if (version < artifactToMaxVersion.get(artifactId)) {
+          FileUtils.deleteQuietly(file);
+        } else {
+          latestVersionOfEachJar.add(new DeployedJar(file));
-  /**
-   * Deletes all versions of this jar on disk other than the given version
-   */
-  public void deleteOtherVersionsOfJar(DeployedJar deployedJar) {
-    logger.info("Deleting all versions of " + deployedJar.getJarName() + " other than "
-        + deployedJar.getFileName());
-    final File[] jarFiles = findSortedOldVersionsOfJar(deployedJar.getJarName());
-
-    Stream.of(jarFiles).filter(jarFile -> !jarFile.equals(deployedJar.getFile()))
-        .forEach(jarFile -> {
-          logger.info("Deleting old version of jar: " + jarFile.getAbsolutePath());
-          FileUtils.deleteQuietly(jarFile);
-        });
-  }
-
-  public DeployedJar findLatestValidDeployedJarFromDisk(String unversionedJarName)
-      throws IOException {
-    final File[] jarFiles = findSortedOldVersionsOfJar(unversionedJarName);
-
-    Optional<File> latestValidDeployedJarOptional = Arrays.stream(jarFiles).filter(Objects::nonNull)
-        .filter(jarFile -> DeployedJar.hasValidJarContent(jarFile)).findFirst();
-
-    if (!latestValidDeployedJarOptional.isPresent()) {
-      // No valid version of this jar
-      return null;
+  Map<String, Integer> findArtifactsAndMaxVersion() {
+    Map<String, Integer> artifactToMaxVersion = new HashMap<>();
+    for (String fileName : deployDirectory.list()) {
+      String artifactId = toArtifactId(fileName);
+      if (artifactId == null) {
+        continue;
+      }
+      int version = extractVersionFromFilename(fileName);
+      Integer maxVersion = artifactToMaxVersion.get(artifactId);
+      if (maxVersion == null || maxVersion < version) {
+        artifactToMaxVersion.put(artifactId, version);
+      }
-
-    File latestValidDeployedJar = latestValidDeployedJarOptional.get();
-
-    return new DeployedJar(latestValidDeployedJar, unversionedJarName);
+    return artifactToMaxVersion;
-  public URL[] getDeployedJarURLs() {
-    return this.deployedJars.values().stream().map(DeployedJar::getFileURL).toArray(URL[]::new);
-
-  }
-          DeployedJar oldJar = this.deployedJars.put(deployedJar.getJarName(), deployedJar);
+          DeployedJar oldJar = this.deployedJars.put(deployedJar.getArtifactId(), deployedJar);
+   * When deploying a jar file, it will always append a sequence number .v<digit> to the end of
+   * the file, no matter how the original file is named. This is to allow server on startup to
+   * know what's the last version that gets deployed without cluster configuration.
+   *
-  public List<DeployedJar> deploy(final Map<String, File> stagedJarFiles)
+  public List<DeployedJar> deploy(final Set<File> stagedJarFiles)
-    for (File jar : stagedJarFiles.values()) {
+    for (File jar : stagedJarFiles) {
-      for (String fileName : stagedJarFiles.keySet()) {
-        deployedJars.add(deployWithoutRegistering(fileName, stagedJarFiles.get(fileName)));
+      for (File stagedJarFile : stagedJarFiles) {
+        deployedJars.add(deployWithoutRegistering(stagedJarFile));
-  private boolean shouldDeployNewVersion(String jarName, File stagedJar) throws IOException {
-    DeployedJar oldDeployedJar = this.deployedJars.get(jarName);
+  private boolean shouldDeployNewVersion(String artifactId, File stagedJar) throws IOException {
+    DeployedJar oldDeployedJar = this.deployedJars.get(artifactId);
+  @VisibleForTesting
-    return this.deployedJars.get(jarName);
+    return this.deployedJars.get(getArtifactId(jarName));
-  public DeployedJar deploy(final String jarName, final File stagedJarFile)
+  public DeployedJar deploy(final File stagedJarFile)
-    Map<String, File> jarFiles = new HashMap<>();
-    jarFiles.put(jarName, stagedJarFile);
+    Set<File> jarFiles = new HashSet();
+    jarFiles.add(stagedJarFile);
-
-   * Undeploy the given JAR file.
+   * Undeploy the jar file identified by the given artifact ID.
-   * @param jarName The name of the JAR file to undeploy
+   * @param jarName The jarFile to undeploy
+    String artifactId = getArtifactId(jarName);
-      DeployedJar deployedJar = deployedJars.remove(jarName);
+      DeployedJar deployedJar = deployedJars.get(artifactId);
-        throw new IllegalArgumentException("JAR not deployed");
+        throw new IllegalArgumentException(jarName + " not deployed");
-      ClassPathLoader.getLatest().unloadClassloaderForJar(jarName);
+      if (!deployedJar.getDeployedFileName().equals(jarName)) {
+        throw new IllegalArgumentException(jarName + " not deployed");
+      }
+
+      // remove the deployedJar
+      deployedJars.remove(artifactId);
+      ClassPathLoader.getLatest().unloadClassloaderForArtifact(artifactId);
-  public void deleteAllVersionsOfJar(String unversionedJarName) {
+  /**
+   *
+   * @param jarName a user deployed jar name (abc.jar or abc-1.0.jar)
+   */
+  public void deleteAllVersionsOfJar(String jarName) {
+    String artifactId = getArtifactId(jarName);
-      File[] jarFiles = findSortedOldVersionsOfJar(unversionedJarName);
-      for (File jarFile : jarFiles) {
-        logger.info("Deleting: {}", jarFile.getAbsolutePath());
-        FileUtils.deleteQuietly(jarFile);
+      for (File file : this.deployDirectory.listFiles()) {
+        if (artifactId.equals(toArtifactId(file.getName()))) {
+          logger.info("Deleting: {}", file.getAbsolutePath());
+          FileUtils.deleteQuietly(file);
+        }

MOV26 MOV26 MOV23 UPD40 UPD40 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS31 UPD83 MOV43 MOV43 INS83 INS83 INS83 MOV43 INS59 INS8 MOV83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 INS83 INS83 INS39 INS42 INS44 INS8 MOV29 UPD83 MOV83 MOV43 INS42 INS44 INS8 INS29 INS83 INS83 MOV43 INS42 INS44 INS8 UPD83 INS83 MOV43 UPD42 INS74 INS42 INS8 INS44 INS78 INS29 MOV83 MOV39 MOV42 MOV44 INS8 UPD42 INS32 UPD42 INS42 INS32 MOV21 INS60 INS60 MOV54 MOV60 INS60 MOV43 INS42 INS41 MOV43 INS42 INS41 INS43 INS42 INS41 INS43 INS42 INS60 MOV25 INS41 INS65 INS65 INS65 INS43 INS42 MOV60 INS25 UPD42 INS60 INS25 MOV43 MOV43 INS43 MOV60 INS70 INS41 UPD74 MOV74 INS43 INS42 MOV60 INS42 MOV60 INS60 INS65 MOV21 MOV60 INS54 INS42 INS42 INS45 INS45 INS42 INS42 INS45 UPD66 INS43 INS59 INS43 INS59 MOV43 INS59 INS32 INS32 INS42 INS32 UPD66 UPD66 UPD42 UPD66 INS66 UPD66 UPD42 MOV42 INS43 INS59 INS27 INS32 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS42 MOV43 INS32 INS8 INS8 INS43 INS59 INS32 MOV8 MOV8 INS66 UPD42 MOV42 UPD74 MOV74 MOV44 INS32 INS8 INS42 INS66 INS66 INS66 MOV43 INS42 INS42 MOV32 UPD74 UPD66 UPD66 INS43 INS59 INS42 INS66 MOV43 INS8 MOV8 MOV42 INS42 INS32 INS42 INS42 INS32 UPD42 INS32 INS42 INS27 UPD42 UPD42 INS32 UPD42 MOV42 INS34 INS32 MOV42 INS32 INS42 INS42 INS42 INS32 INS42 INS33 UPD42 MOV42 MOV27 UPD42 UPD42 MOV42 UPD42 MOV42 INS41 INS41 INS42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS70 UPD43 UPD42 UPD42 MOV42 UPD42 MOV42 MOV60 INS25 MOV60 MOV60 INS25 UPD42 INS32 MOV43 UPD42 UPD42 INS42 INS42 INS32 INS60 INS25 INS25 INS21 UPD42 MOV70 INS42 INS42 INS42 INS42 UPD43 UPD42 MOV42 INS32 MOV32 MOV45 INS36 MOV45 INS32 INS42 INS90 UPD42 INS42 MOV42 INS42 INS42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD45 UPD42 UPD42 MOV42 UPD42 MOV42 INS32 INS32 INS42 INS42 INS42 INS33 UPD42 UPD42 INS74 INS44 INS32 INS8 UPD42 INS43 INS27 INS8 INS39 INS43 INS27 INS8 INS44 INS42 UPD42 MOV42 UPD42 INS42 MOV42 MOV43 INS42 INS42 MOV43 INS59 MOV27 INS8 INS38 MOV8 INS32 UPD42 UPD42 INS32 INS8 UPD42 UPD42 INS32 UPD42 MOV42 INS32 INS42 UPD42 MOV42 UPD42 INS42 INS27 INS32 UPD42 MOV42 INS90 INS42 INS42 INS42 INS42 UPD45 MOV45 INS42 INS42 UPD42 MOV42 UPD42 UPD42 UPD45 INS43 MOV43 INS43 UPD42 MOV43 INS42 UPD42 MOV42 UPD42 MOV42 INS60 INS25 MOV60 MOV25 UPD42 MOV42 UPD42 INS32 INS42 INS33 INS18 UPD42 UPD42 MOV42 UPD42 INS32 INS27 INS27 INS21 MOV43 INS42 INS42 INS32 INS53 INS32 MOV42 MOV42 UPD42 MOV42 UPD42 UPD42 MOV43 INS42 MOV22 INS42 INS25 UPD42 INS32 INS42 INS42 INS42 UPD42 MOV42 INS34 INS32 INS42 INS86 INS42 INS42 INS42 INS42 UPD42 INS42 INS43 INS59 INS27 INS8 INS39 UPD27 INS8 INS8 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS33 INS42 INS42 INS32 INS42 INS42 INS42 INS14 INS32 INS42 INS42 INS32 INS8 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS32 MOV59 INS32 MOV42 INS42 INS32 INS42 INS33 INS18 UPD42 INS32 UPD42 INS32 MOV21 MOV21 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS60 INS43 INS27 INS42 INS42 INS27 INS42 INS42 INS32 MOV21 MOV21 INS42 UPD42 MOV42 UPD42 UPD42 MOV42 UPD42 MOV42 INS32 INS42 INS32 INS42 INS32 INS42 INS42 INS42 MOV43 INS59 UPD42 MOV42 UPD42 MOV42 INS42 INS45 INS42 INS45 INS42 INS32 UPD42 MOV42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 UPD42 UPD42 UPD42 UPD42 INS14 INS42 MOV32 INS42 INS42 UPD42 MOV43 INS42 INS42 INS32 INS42 UPD42 UPD42 MOV42 INS42 DEL40 DEL26 DEL40 DEL26 DEL45 DEL83 DEL42 DEL45 DEL27 DEL83 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL83 DEL43 DEL42 DEL44 DEL32 DEL42 DEL32 DEL42 DEL42 DEL8 DEL32 DEL34 DEL27 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL59 DEL60 DEL42 DEL33 DEL27 DEL40 DEL34 DEL27 DEL27 DEL42 DEL42 DEL42 DEL32 DEL45 DEL27 DEL7 DEL21 DEL8 DEL42 DEL42 DEL34 DEL2 DEL42 DEL32 DEL59 DEL60 DEL42 DEL27 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL38 DEL42 DEL42 DEL42 DEL32 DEL39 DEL32 DEL42 DEL43 DEL74 DEL42 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL52 DEL42 DEL22 DEL42 DEL59 DEL32 DEL32 DEL86 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL32 DEL21 DEL42 DEL42 DEL34 DEL32 DEL45 DEL27 DEL32 DEL21 DEL8 DEL70 DEL42 DEL41 DEL8 DEL31 DEL43 DEL85 DEL5 DEL42 DEL83 DEL42 DEL44 DEL42 DEL45 DEL32 DEL21 DEL83 DEL42 DEL42 DEL32 DEL59 DEL60 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL59 DEL42 DEL59 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL36 DEL86 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL59 DEL42 DEL59 DEL39 DEL42 DEL42 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL41 DEL8 DEL86 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL90 DEL32 DEL42 DEL45 DEL32 DEL32 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL45 DEL42 DEL42 DEL33 DEL27 DEL45 DEL32 DEL27 DEL25 DEL83 DEL42 DEL42 DEL42 DEL45 DEL32 DEL59 DEL23 DEL83 DEL32 DEL41 DEL8 DEL25 DEL32 DEL33 DEL8 DEL43 DEL42 DEL44 DEL42 DEL8 DEL70 DEL42 DEL43 DEL74 DEL83 DEL85 DEL5 DEL42 DEL32 DEL32 DEL83 DEL42 DEL43 DEL85 DEL5 DEL43 DEL74 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL90 DEL32 DEL42 DEL42 DEL59 DEL32 DEL86 DEL32 DEL42 DEL32 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL32 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL59 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL38 DEL86 DEL32 DEL42 DEL42 DEL59 DEL42 DEL42 DEL45 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL86 DEL32 DEL21 DEL8 DEL31 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL14 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL32 DEL42 DEL42 DEL90 DEL32 DEL42 DEL42 DEL43 DEL85 DEL5 DEL89 DEL32 DEL41 DEL8 DEL31 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL74 DEL42 DEL45 DEL43 DEL42 DEL32 DEL59 DEL60 DEL25 DEL85 DEL5 DEL42 DEL43 DEL42 DEL42 DEL8 DEL42 DEL43 DEL42 DEL44 DEL8 DEL54 DEL8 DEL31
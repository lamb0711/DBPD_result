Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A connection source where the list of endpoints is specified explicitly. 
+ * A connection source where the list of endpoints is specified explicitly.
+ * 
- * TODO - the UnusedServerMonitor basically will force the pool to
- * have at least one connection to each server. Maybe we need to have it
- * create connections that are outside the pool?
+ *        TODO - the UnusedServerMonitor basically will force the pool to have at least one
+ *        connection to each server. Maybe we need to have it create connections that are outside
+ *        the pool?
-  
+
-  
-  /**
-   * A debug flag, which can be toggled by tests to disable/enable shuffling of
-   * the endpoints list
-   */
-  private boolean DISABLE_SHUFFLING = Boolean
-      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "bridge.disableShufflingOfEndpoints");
-  public ExplicitConnectionSourceImpl(List/*<InetSocketAddress>*/contacts) {
+  /**
+   * A debug flag, which can be toggled by tests to disable/enable shuffling of the endpoints list
+   */
+  private boolean DISABLE_SHUFFLING =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "bridge.disableShufflingOfEndpoints");
+
+  public ExplicitConnectionSourceImpl(List/* <InetSocketAddress> */ contacts) {
-    for(int i = 0; i < contacts.size(); i++) {
-      InetSocketAddress addr = (InetSocketAddress)contacts.get(i);
+    for (int i = 0; i < contacts.size(); i++) {
+      InetSocketAddress addr = (InetSocketAddress) contacts.get(i);
-  
+
-    //do nothing
+    // do nothing
-  public ServerLocation findReplacementServer(ServerLocation currentServer, Set/*<ServerLocation>*/ excludedServers) {
+  public ServerLocation findReplacementServer(ServerLocation currentServer,
+      Set/* <ServerLocation> */ excludedServers) {
-  
+
-    if(PoolImpl.TEST_DURABLE_IS_NET_DOWN) {
+    if (PoolImpl.TEST_DURABLE_IS_NET_DOWN) {
-      if(++nextServerIndex >= serverList.size()) {
+      if (++nextServerIndex >= serverList.size()) {
-      if(!excludedServers.contains(nextServer)) {
+      if (!excludedServers.contains(nextServer)) {
-    } while(nextServerIndex != startIndex);
-    
+    } while (nextServerIndex != startIndex);
+
-  
+
-   * TODO - this algorithm could be cleaned up. Right now we have to
-   * connect to every server in the system to find where our durable
-   * queue lives.
+   * TODO - this algorithm could be cleaned up. Right now we have to connect to every server in the
+   * system to find where our durable queue lives.
-  public synchronized List findServersForQueue(Set excludedServers,
-      int numServers, ClientProxyMembershipID proxyId, boolean findDurableQueue) {
-    if(PoolImpl.TEST_DURABLE_IS_NET_DOWN) {
+  public synchronized List findServersForQueue(Set excludedServers, int numServers,
+      ClientProxyMembershipID proxyId, boolean findDurableQueue) {
+    if (PoolImpl.TEST_DURABLE_IS_NET_DOWN) {
-    if(numServers == -1) {
+    if (numServers == -1) {
-    if(findDurableQueue && proxyId.isDurable()) {
+    if (findDurableQueue && proxyId.isDurable()) {
-  
+
-  
-  private List pickQueueServers(Set excludedServers,
-      int numServers) {
-    
+
+  private List pickQueueServers(Set excludedServers, int numServers) {
+
-      nextQueue= (ServerLocation) serverList.get(nextQueueIndex);
-      if(++nextQueueIndex >= serverList.size()) {
+      nextQueue = (ServerLocation) serverList.get(nextQueueIndex);
+      if (++nextQueueIndex >= serverList.size()) {
-      if(!excludedServers.contains(nextQueue)) {
+      if (!excludedServers.contains(nextQueue)) {
-    } while(nextQueueIndex != startIndex && result.size() < numServers);
-    
+    } while (nextQueueIndex != startIndex && result.size() < numServers);
+
+
+
-  
-  private List findDurableQueues(Set excludedServers,
-      int numServers) {
+
+  private List findDurableQueues(Set excludedServers, int numServers) {
-    
+
-    
-    for(Iterator itr = serverList.iterator(); itr.hasNext(); ) {
+
+    for (Iterator itr = serverList.iterator(); itr.hasNext();) {
-      if(excludedServers.contains(server)) {
+      if (excludedServers.contains(server)) {
-      
-      //the pool will automatically create a connection to this server
-      //and store it for future use.
+
+      // the pool will automatically create a connection to this server
+      // and store it for future use.
-      } catch(GemFireSecurityException e) {
+      } catch (GemFireSecurityException e) {
-      } catch(Exception e) {
-        if(e.getCause() instanceof GemFireSecurityException) {
-          throw (GemFireSecurityException)e.getCause();
+      } catch (Exception e) {
+        if (e.getCause() instanceof GemFireSecurityException) {
+          throw (GemFireSecurityException) e.getCause();
-        if(logger.isDebugEnabled()) {
+        if (logger.isDebugEnabled()) {
-      if(hasQueue != null) {
-        if(hasQueue.booleanValue()) {
-          if(logger.isDebugEnabled()) {
+      if (hasQueue != null) {
+        if (hasQueue.booleanValue()) {
+          if (logger.isDebugEnabled()) {
-          if(logger.isDebugEnabled()) {
+          if (logger.isDebugEnabled()) {
-    if(remainingServers > otherServers.size()) {
+    if (remainingServers > otherServers.size()) {
-    //note, we're always prefering the servers in the beginning of the list
-    //but that's ok because we already shuffled the list in our constructor.
-    if(remainingServers > 0) {
+    // note, we're always prefering the servers in the beginning of the list
+    // but that's ok because we already shuffled the list in our constructor.
+    if (remainingServers > 0) {
-    
-    if(logger.isDebugEnabled()) {
+
+    if (logger.isDebugEnabled()) {
-    
+
-  
-  private void shuffle(List endpoints)
-  {
-    //this check was copied from ConnectionProxyImpl
+
+  private void shuffle(List endpoints) {
+    // this check was copied from ConnectionProxyImpl
-       * It is not safe to shuffle an ArrayList of size 1
-       * java.lang.IndexOutOfBoundsException: Index: 1, Size: 1 at
-       * java.util.ArrayList.RangeCheck(Unknown Source) at
-       * java.util.ArrayList.get(Unknown Source) at
-       * java.util.Collections.swap(Unknown Source) at
+       * It is not safe to shuffle an ArrayList of size 1 java.lang.IndexOutOfBoundsException:
+       * Index: 1, Size: 1 at java.util.ArrayList.RangeCheck(Unknown Source) at
+       * java.util.ArrayList.get(Unknown Source) at java.util.Collections.swap(Unknown Source) at
-  
+
-    synchronized(this) {
+    synchronized (this) {
-      while(it.hasNext()) {
-        ServerLocation loc = (ServerLocation)it.next();
-        sb.append(loc.getHostName()+":"+loc.getPort());
-        if(it.hasNext()) {
+      while (it.hasNext()) {
+        ServerLocation loc = (ServerLocation) it.next();
+        sb.append(loc.getHostName() + ":" + loc.getPort());
+        if (it.hasNext()) {
-  
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66
GEODE-6588: Cleanup generics and other static analyzer issues. (#3391)


+
+import org.apache.geode.cache.query.CqQuery;
-  public static final int interestListIndexForUpdatesAsInvalidates = 2;
-  public static final int durableInterestListIndexForUpdatesAsInvalidates = 3;
+  private static final int interestListIndexForUpdatesAsInvalidates = 2;
+  private static final int durableInterestListIndexForUpdatesAsInvalidates = 3;
-  private final ConcurrentMap cqs /* <CqQuery,Boolean> */ = new ConcurrentHashMap();
+  private final ConcurrentMap<CqQuery, Boolean> cqs = new ConcurrentHashMap<>();
-  public List getInterestList(String regionName, int interestType) {
+  public List<Object> getInterestList(String regionName, int interestType) {
-    ArrayList result = new ArrayList();
+    ArrayList<Object> result = new ArrayList<>();
-  public void addSingleInterest(LocalRegion r, Object key, int interestType,
-      InterestResultPolicy pol, boolean isDurable, boolean receiveUpdatesAsInvalidates) {
+  void addSingleInterest(LocalRegion r, Object key, int interestType,
+      InterestResultPolicy pol, boolean isDurable,
+      boolean receiveUpdatesAsInvalidates) {
-  public boolean removeSingleInterest(LocalRegion r, Object key, int interestType,
+  boolean removeSingleInterest(LocalRegion r, Object key, int interestType,
-  public void addInterestList(LocalRegion r, List keys, InterestResultPolicy pol, boolean isDurable,
+  void addInterestList(LocalRegion r, List keys, InterestResultPolicy pol, boolean isDurable,
-    for (int i = 0; i < keys.size(); i++) {
-      rie.getInterests().put(keys.get(i), pol);
+    for (Object key : keys) {
+      rie.getInterests().put(key, pol);
-    this.cqs.put(cqi, Boolean.valueOf(isDurable));
+    this.cqs.put(cqi, isDurable);
-  public void removeCq(InternalCqQuery cqi, boolean isDurable) {
+  public void removeCq(InternalCqQuery cqi) {
-  public Map getCqsMap() {
+  Map getCqsMap() {
-  public void unregisterRegion(ServerRegionProxy srp, boolean keepalive) {
+  void unregisterRegion(ServerRegionProxy srp, boolean keepalive) {
-  public boolean removeInterestList(LocalRegion r, List keys, boolean isDurable,
+  boolean removeInterestList(LocalRegion r, List keys, boolean isDurable,
-    for (int i = 0; i < keys.size(); i++) {
-      Object key = keys.get(i);
+    for (Object key : keys) {
-  public ConcurrentMap getRegionToInterestsMap(int interestType, boolean isDurable,
+  ConcurrentMap<String, RegionInterestEntry> getRegionToInterestsMap(int interestType,
+      boolean isDurable,
-    ConcurrentMap mapOfInterest = null;
-
-        mapOfInterest = fil.keysOfInterest;
-        break;
+        return fil.keysOfInterest;
-        mapOfInterest = fil.regexOfInterest;
-        break;
+        return fil.regexOfInterest;
-        mapOfInterest = fil.filtersOfInterest;
-        break;
+        return fil.filtersOfInterest;
-        mapOfInterest = fil.cqsOfInterest;
-        break;
+        return fil.cqsOfInterest;
-        mapOfInterest = fil.queriesOfInterest;
-        break;
+        return fil.queriesOfInterest;
-    return mapOfInterest;
-    ConcurrentMap mapOfInterest =
+    ConcurrentMap<String, RegionInterestEntry> mapOfInterest =
-    RegionInterestEntry result = (RegionInterestEntry) mapOfInterest.get(regionName);
+    RegionInterestEntry result = mapOfInterest.get(regionName);
-      result = (RegionInterestEntry) mapOfInterest.putIfAbsent(regionName, rie);
+      result = mapOfInterest.putIfAbsent(regionName, rie);
-    final ConcurrentMap keysOfInterest = new ConcurrentHashMap();
+    final ConcurrentMap<String, RegionInterestEntry> keysOfInterest = new ConcurrentHashMap<>();
-    final ConcurrentMap regexOfInterest = new ConcurrentHashMap();
+    final ConcurrentMap<String, RegionInterestEntry> regexOfInterest = new ConcurrentHashMap<>();
-    final ConcurrentMap filtersOfInterest = new ConcurrentHashMap();
+    final ConcurrentMap<String, RegionInterestEntry> filtersOfInterest = new ConcurrentHashMap<>();
-    final ConcurrentMap queriesOfInterest = new ConcurrentHashMap();
+    final ConcurrentMap<String, RegionInterestEntry> queriesOfInterest = new ConcurrentHashMap<>();
-    final ConcurrentMap cqsOfInterest = new ConcurrentHashMap();
+    final ConcurrentMap<String, RegionInterestEntry> cqsOfInterest = new ConcurrentHashMap<>();
-    private final ConcurrentMap interests;
+    private final ConcurrentMap<Object, InterestResultPolicy> interests;
-      this.interests = new ConcurrentHashMap();
+      this.interests = new ConcurrentHashMap<>();
-    public ConcurrentMap getInterests() {
+    public ConcurrentMap<Object, InterestResultPolicy> getInterests() {

INS26 INS40 UPD83 UPD83 INS74 INS74 INS74 MOV43 INS43 INS43 MOV43 INS43 INS70 INS70 MOV43 INS43 INS43 INS74 MOV59 INS74 MOV59 INS74 MOV59 INS74 MOV59 INS74 MOV59 INS74 INS74 MOV42 INS42 INS42 INS74 INS42 INS74 INS44 INS42 INS8 INS44 INS42 MOV8 INS42 INS42 INS41 INS41 INS41 INS41 INS41 INS74 MOV43 MOV43 INS43 MOV43 UPD42 MOV43 INS43 INS43 UPD42 MOV43 INS43 INS43 UPD42 MOV43 INS43 INS43 UPD42 MOV43 INS43 INS43 UPD42 MOV43 MOV43 INS43 MOV43 INS43 INS43 MOV43 MOV43 INS43 INS43 INS42 MOV21 MOV42 INS43 INS42 INS40 INS40 INS40 INS40 INS40 MOV43 INS43 MOV43 MOV32 INS42 INS74 INS42 INS42 INS74 INS42 INS42 INS74 INS42 INS42 INS74 INS42 INS42 INS74 UPD42 MOV42 INS42 INS42 INS42 INS74 INS42 INS42 INS42 MOV43 MOV43 MOV43 MOV43 MOV43 MOV43 UPD42 MOV42 MOV32 INS74 MOV43 DEL43 DEL83 DEL83 DEL83 DEL42 DEL42 DEL32 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL8 DEL24 DEL42 DEL42 DEL32 DEL39 DEL42 DEL44 DEL83 DEL83 DEL83 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL24 DEL83 DEL42 DEL33 DEL59 DEL60 DEL42 DEL40 DEL7 DEL21 DEL10 DEL42 DEL40 DEL7 DEL21 DEL10 DEL42 DEL40 DEL7 DEL21 DEL10 DEL42 DEL40 DEL7 DEL21 DEL10 DEL42 DEL40 DEL7 DEL21 DEL10 DEL42 DEL41 DEL11 DEL11
GEODE-5984 Address LGTM recommendations

Addressing minor issues in javadocs and code reported by LooksGoodToMe.

One change that I made wasn't reported by that tool: I removed
two static variables from AcceptorImpl that duplicated variables in
Handshake.

This closes #2780

-import java.util.NoSuchElementException;
-   * Creates a new map with the same mappings as the given map. The map is created with a capacity
-   * of 1.5 times the number of mappings in the given map or 16 (whichever is greater), and a
-   * default load factor (0.75) and concurrencyLevel (16).
-   *
-   * @param m the map
-   */
-  /*
-   * public ObjIdConcurrentMap(Map<? extends K, ? extends V> m) { this(Math.max((int) (m.size() /
-   * DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR,
-   * DEFAULT_CONCURRENCY_LEVEL); putAll(m); }
-   */
-
-  /**
-   * Copies all of the mappings from the specified map to this one. These mappings replace any
-   * mappings that this map had for any of the keys currently in the specified map.
-   *
-   * @param m mappings to be stored in this map
-   */
-  /*
-   * public void putAll(Map<? extends K, ? extends V> m) { for (Map.Entry<? extends K, ? extends V>
-   * e : m.entrySet()) put(e.getKey(), e.getValue()); }
-   */
-
-  /**
-  /*
-   * Returns a {@link Set} view of the keys contained in this map. The set is backed by the map, so
-   * changes to the map are reflected in the set, and vice-versa. The set supports element removal,
-   * which removes the corresponding mapping from this map, via the <tt>Iterator.remove</tt>,
-   * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt> operations. It
-   * does not support the <tt>add</tt> or <tt>addAll</tt> operations.
-   *
-   * <p>The view's <tt>iterator</tt> is a "weakly consistent" iterator that will never throw {@link
-   * ConcurrentModificationException}, and guarantees to traverse elements as they existed upon
-   * construction of the iterator, and may (but is not guaranteed to) reflect any modifications
-   * subsequent to construction.
-   */
-  /*
-   * public Set<K> keySet() { Set<K> ks = keySet; return (ks != null) ? ks : (keySet = new
-   * KeySet()); }
-   *
-   * /** Returns a {@link Collection} view of the values contained in this map. The collection is
-   * backed by the map, so changes to the map are reflected in the collection, and vice-versa. The
-   * collection supports element removal, which removes the corresponding mapping from this map, via
-   * the <tt>Iterator.remove</tt>, <tt>Collection.remove</tt>, <tt>removeAll</tt>,
-   * <tt>retainAll</tt>, and <tt>clear</tt> operations. It does not support the <tt>add</tt> or
-   * <tt>addAll</tt> operations.
-   *
-   * <p>The view's <tt>iterator</tt> is a "weakly consistent" iterator that will never throw {@link
-   * ConcurrentModificationException}, and guarantees to traverse elements as they existed upon
-   * construction of the iterator, and may (but is not guaranteed to) reflect any modifications
-   * subsequent to construction.
-   */
-  /*
-   * public Collection<V> values() { Collection<V> vs = values; return (vs != null) ? vs : (values =
-   * new Values()); }
-   *
-   * /** Returns a {@link Set} view of the mappings contained in this map. The set is backed by the
-   * map, so changes to the map are reflected in the set, and vice-versa. The set supports element
-   * removal, which removes the corresponding mapping from the map, via the
-   * <tt>Iterator.remove</tt>, <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt>, and
-   * <tt>clear</tt> operations. It does not support the <tt>add</tt> or <tt>addAll</tt> operations.
-   *
-   * <p>The view's <tt>iterator</tt> is a "weakly consistent" iterator that will never throw {@link
-   * ConcurrentModificationException}, and guarantees to traverse elements as they existed upon
-   * construction of the iterator, and may (but is not guaranteed to) reflect any modifications
-   * subsequent to construction.
-   */
-  /*
-   * public Set<Map.Entry<K,V>> entrySet() { Set<Map.Entry<K,V>> es = entrySet; return (es != null)
-   * ? es : (entrySet = new EntrySet()); }
-   *
-   * /** Returns an enumeration of the keys in this table.
-   *
-   * @return an enumeration of the keys in this table
-   *
-   * @see #keySet()
-   */
-  /*
-   * public Enumeration<K> keys() { return new KeyIterator(); }
-   *
-   * /** Returns an enumeration of the values in this table.
-   *
-   * @return an enumeration of the values in this table
-   *
-   * @see #values()
-   */
-  /*
-   * public Enumeration<V> elements() { return new ValueIterator(); }
-   */
-
-  /* ---------------- Iterator Support -------------- */
-
-  abstract class HashIterator {
-    int nextSegmentIndex;
-    int nextTableIndex;
-    HashEntry<V>[] currentTable;
-    HashEntry<V> nextEntry;
-    HashEntry<V> lastReturned;
-
-    HashIterator() {
-      nextSegmentIndex = segments.length - 1;
-      nextTableIndex = -1;
-      advance();
-    }
-
-    public boolean hasMoreElements() {
-      return hasNext();
-    }
-
-    void advance() {
-      if (nextEntry != null && (nextEntry = nextEntry.next) != null)
-        return;
-
-      while (nextTableIndex >= 0) {
-        if ((nextEntry = currentTable[nextTableIndex--]) != null)
-          return;
-      }
-
-      while (nextSegmentIndex >= 0) {
-        Segment<V> seg = segments[nextSegmentIndex--];
-        if (seg.count != 0) {
-          currentTable = seg.table;
-          for (int j = currentTable.length - 1; j >= 0; --j) {
-            if ((nextEntry = currentTable[j]) != null) {
-              nextTableIndex = j - 1;
-              return;
-            }
-          }
-        }
-      }
-    }
-
-    public boolean hasNext() {
-      return nextEntry != null;
-    }
-
-    HashEntry<V> nextEntry() {
-      if (nextEntry == null)
-        throw new NoSuchElementException();
-      lastReturned = nextEntry;
-      advance();
-      return lastReturned;
-    }
-
-    public void remove() {
-      if (lastReturned == null)
-        throw new IllegalStateException();
-      ObjIdConcurrentMap.this.remove(lastReturned.key);
-      lastReturned = null;
-    }
-  }
-
-  /*
-   * class KeyIterator extends HashIterator implements Iterator<K>, Enumeration<K> { public K next()
-   * { return super.nextEntry().key; } public K nextElement() { return super.nextEntry().key; } }
-   *
-   * class ValueIterator extends HashIterator implements Iterator<V>, Enumeration<V> { public V
-   * next() { return super.nextEntry().value; } public V nextElement() { return
-   * super.nextEntry().value; } }
-   */
-
-  // interface Entry<V> {
-  // int getKey();
-  // V getValue();
-  // V setValue(V value);
-  // boolean equals(Object o);
-  // int hashCode();
-  // }
-
-
-  // static class SimpleEntry<V> implements Entry<V> {
-  // int key;
-  // V value;
-  //
-  // public SimpleEntry(int key, V value) {
-  // this.key = key;
-  // this.value = value;
-  // }
-  //
-  // public SimpleEntry(Entry<V> e) {
-  // this.key = e.getKey();
-  // this.value = e.getValue();
-  // }
-  //
-  // public int getKey() {
-  // return key;
-  // }
-  //
-  // public V getValue() {
-  // return value;
-  // }
-  //
-  // public V setValue(V value) {
-  // V oldValue = this.value;
-  // this.value = value;
-  // return oldValue;
-  // }
-  //
-  // @Override
-  // public boolean equals(Object o) {
-  // if (!(o instanceof Map.Entry))
-  // return false;
-  // Map.Entry<?, ?> e = (Map.Entry<?, ?>)o;
-  // return eq(key, e.getKey()) && eq(value, e.getValue());
-  // }
-  //
-  // @Override
-  // public int hashCode() {
-  // return (key) ^
-  // ((value == null) ? 0 : value.hashCode());
-  // }
-  //
-  // @Override
-  // public String toString() {
-  // return key + "=" + value;
-  // }
-  //
-  // private static boolean eq(Object o1, Object o2) {
-  // return (o1 == null ? o2 == null : o1.equals(o2));
-  // }
-  // }
-  // /**
-  // * Custom Entry class used by EntryIterator.next(), that relays
-  // * setValue changes to the underlying map.
-  // */
-  // class WriteThroughEntry
-  // extends SimpleEntry<V>
-  // {
-  // WriteThroughEntry(int k, V v) {
-  // super(k,v);
-  // }
-  //
-  // /**
-  // * Set our entry's value and write through to the map. The
-  // * value to return is somewhat arbitrary here. Since a
-  // * WriteThroughEntry does not necessarily track asynchronous
-  // * changes, the most recent "previous" value could be
-  // * different from what we return (or could even have been
-  // * removed in which case the put will re-establish). We do not
-  // * and cannot guarantee more.
-  // */
-  // @Override
-  // public V setValue(V value) {
-  // if (value == null) throw new NullPointerException();
-  // V v = super.setValue(value);
-  // ObjIdConcurrentMap.this.put(getKey(), value);
-  // return v;
-  // }
-  // }
-
-  /*
-   * class EntryIterator extends HashIterator implements Iterator<Entry<V>> { public Entry<V> next()
-   * { HashEntry<V> e = super.nextEntry(); return new WriteThroughEntry(e.key, e.value); } }
-   *
-   * class KeySet extends AbstractSet<K> { public Iterator<K> iterator() { return new KeyIterator();
-   * } public int size() { return ObjIdConcurrentMap.this.size(); } public boolean isEmpty() {
-   * return ObjIdConcurrentMap.this.isEmpty(); } public boolean contains(Object o) { return
-   * ObjIdConcurrentMap.this.containsKey(o); } public boolean remove(Object o) { return
-   * ObjIdConcurrentMap.this.remove(o) != null; } public void clear() {
-   * ObjIdConcurrentMap.this.clear(); } }
-   *
-   * class Values extends AbstractCollection<V> { public Iterator<V> iterator() { return new
-   * ValueIterator(); } public int size() { return ObjIdConcurrentMap.this.size(); } public boolean
-   * isEmpty() { return ObjIdConcurrentMap.this.isEmpty(); } public boolean contains(Object o) {
-   * return ObjIdConcurrentMap.this.containsValue(o); } public void clear() {
-   * ObjIdConcurrentMap.this.clear(); } }
-   *
-   * class EntrySet extends AbstractSet<Map.Entry<K,V>> { public Iterator<Map.Entry<K,V>> iterator()
-   * { return new EntryIterator(); } public boolean contains(Object o) { if (!(o instanceof
-   * Map.Entry)) return false; Map.Entry<?,?> e = (Map.Entry<?,?>)o; V v =
-   * ObjIdConcurrentMap.this.get(e.getKey()); return v != null && v.equals(e.getValue()); } public
-   * boolean remove(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry<?,?> e =
-   * (Map.Entry<?,?>)o; return ObjIdConcurrentMap.this.remove(e.getKey(), e.getValue()); } public
-   * int size() { return ObjIdConcurrentMap.this.size(); } public boolean isEmpty() { return
-   * ObjIdConcurrentMap.this.isEmpty(); } public void clear() { ObjIdConcurrentMap.this.clear(); } }
-   */
-

INS83 INS42 DEL40 DEL26 DEL83 DEL42 DEL83 DEL42 DEL39 DEL42 DEL59 DEL23 DEL39 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL43 DEL74 DEL85 DEL5 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL23 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL59 DEL23 DEL42 DEL42 DEL40 DEL34 DEL27 DEL7 DEL21 DEL42 DEL34 DEL38 DEL7 DEL21 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL32 DEL41 DEL8 DEL31 DEL39 DEL42 DEL42 DEL33 DEL27 DEL42 DEL40 DEL7 DEL36 DEL33 DEL27 DEL27 DEL41 DEL25 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL37 DEL2 DEL7 DEL36 DEL33 DEL27 DEL41 DEL25 DEL8 DEL61 DEL42 DEL34 DEL27 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL42 DEL37 DEL2 DEL59 DEL60 DEL40 DEL34 DEL27 DEL42 DEL40 DEL7 DEL21 DEL39 DEL42 DEL40 DEL34 DEL27 DEL59 DEL58 DEL42 DEL34 DEL27 DEL42 DEL38 DEL42 DEL42 DEL42 DEL2 DEL7 DEL36 DEL33 DEL27 DEL42 DEL42 DEL34 DEL27 DEL7 DEL21 DEL41 DEL8 DEL25 DEL8 DEL24 DEL8 DEL25 DEL8 DEL61 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL33 DEL27 DEL41 DEL8 DEL31 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL33 DEL27 DEL42 DEL43 DEL14 DEL53 DEL25 DEL42 DEL42 DEL7 DEL21 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL33 DEL27 DEL42 DEL43 DEL14 DEL53 DEL25 DEL42 DEL52 DEL42 DEL40 DEL32 DEL21 DEL42 DEL33 DEL7 DEL21 DEL8 DEL31 DEL55
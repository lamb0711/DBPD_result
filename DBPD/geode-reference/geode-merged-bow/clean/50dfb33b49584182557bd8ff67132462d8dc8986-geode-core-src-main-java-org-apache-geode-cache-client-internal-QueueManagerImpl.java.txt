GEODE-6588: Cleanup generics and other static analyzer issues. (#3391)


+
-import java.util.Iterator;
-  private static final Comparator QSIZE_COMPARATOR = new QSizeComparator();
+  private static final Comparator<ServerQueueStatus> QSIZE_COMPARATOR = new QSizeComparator();
-  protected final long redundancyRetryInterval;
+  private final long redundancyRetryInterval;
+  @SuppressWarnings("deprecation")
-  protected final ServerDenyList denyList;
+  private final ServerDenyList denyList;
-  protected final CountDownLatch initializedLatch = new CountDownLatch(1);
+  private final CountDownLatch initializedLatch = new CountDownLatch(1);
-  protected volatile ConnectionList queueConnections = new ConnectionList();
-  protected volatile RedundancySatisfierTask redundancySatisfierTask = null;
+  private volatile ConnectionList queueConnections = new ConnectionList();
+  private volatile RedundancySatisfierTask redundancySatisfierTask = null;
-      long redundancyRetryInterval, InternalLogWriter securityLogger,
+      long redundancyRetryInterval,
+      @SuppressWarnings("deprecation") InternalLogWriter securityLogger,
-  public boolean isPrimaryUpdaterAlive() {
+  boolean isPrimaryUpdaterAlive() {
+  @Deprecated
-    List backups = queueConnections.getBackups();
-    for (Iterator itr = backups.iterator(); itr.hasNext();) {
-      QueueConnectionImpl backup = (QueueConnectionImpl) itr.next();
+    List<Connection> backups = queueConnections.getBackups();
+    for (Connection connection : backups) {
+      QueueConnectionImpl backup = (QueueConnectionImpl) connection;
-    List backups = queueConnections.getBackups();
-    for (int i = 0; i < backups.size(); i++) {
-      Connection backup = (Connection) backups.get(i);
+    List<Connection> backups = queueConnections.getBackups();
+    for (Connection backup : backups) {
-        primary = null;
-  public void readyForEventsAfterFailover(QueueConnectionImpl primary) {
+  private void readyForEventsAfterFailover(QueueConnectionImpl primary) {
-  void endpointCrashed(Endpoint endpoint) {
-    QueueConnectionImpl deadConnection = null;
+  private void endpointCrashed(Endpoint endpoint) {
+    QueueConnectionImpl deadConnection;
-    QueueConnectionImpl deadConnection = null;
+    QueueConnectionImpl deadConnection;
-    Set excludedServers = new HashSet(denyList.getBadServers());
-    List servers = findQueueServers(excludedServers, queuesNeeded, true, false, null);
+    Set<ServerLocation> excludedServers = new HashSet<>(denyList.getBadServers());
+    List<ServerLocation> servers =
+        findQueueServers(excludedServers, queuesNeeded, true, false, null);
-    SortedMap/* <ServerQueueStatus,Connection> */ oldQueueServers = new TreeMap(QSIZE_COMPARATOR);
-    List nonRedundantServers = new ArrayList();
+    SortedMap<ServerQueueStatus, Connection> oldQueueServers = new TreeMap<>(QSIZE_COMPARATOR);
+    List<Connection> nonRedundantServers = new ArrayList<>();
-    for (Iterator itr = servers.iterator(); itr.hasNext();) {
-      ServerLocation server = (ServerLocation) itr.next();
+    for (ServerLocation server : servers) {
-      } catch (GemFireSecurityException e) {
-        throw e;
-      } catch (GemFireConfigException e) {
+      } catch (GemFireSecurityException | GemFireConfigException e) {
-      newPrimary = (Connection) oldQueueServers.remove(oldQueueServers.lastKey());
+      newPrimary = oldQueueServers.remove(oldQueueServers.lastKey());
-      newPrimary = (Connection) nonRedundantServers.remove(0);
+      newPrimary = nonRedundantServers.remove(0);
-    for (Iterator itr = nonRedundantServers.iterator(); itr.hasNext();) {
-      Connection connection = (Connection) itr.next();
+    for (Connection connection : nonRedundantServers) {
+  @SuppressWarnings("deprecation")
+  private InternalCache getInternalCache() {
+    return GemFireCacheImpl.getInstance();
+  }
+
-    InternalCache cache = GemFireCacheImpl.getInstance();
+    InternalCache cache = getInternalCache();
-    InternalCache cache = GemFireCacheImpl.getInstance();
+    InternalCache cache = getInternalCache();
-  protected boolean recoverRedundancy(Set excludedServers, boolean recoverInterest) {
+  private void recoverRedundancy(Set<ServerLocation> excludedServers, boolean recoverInterest) {
-      return true;
+      return;
-      List servers = findQueueServers(excludedServers,
+      List<ServerLocation> servers = findQueueServers(excludedServers,
-          (redundancyLevel == -1 ? false : printRedundancyNotSatisfiedError),
+          redundancyLevel != -1 && printRedundancyNotSatisfiedError,
-        return false;
+        return;
-      for (Iterator itr = servers.iterator(); itr.hasNext();) {
-        ServerLocation server = (ServerLocation) itr.next();
+      for (ServerLocation server : servers) {
-    return true;
-  private QueueConnectionImpl createNewPrimary(Set excludedServers) {
+  private QueueConnectionImpl createNewPrimary(Set<ServerLocation> excludedServers) {
-      List servers = findQueueServers(excludedServers, 1, false, printPrimaryNotFoundError,
-          "Could not find any server to host primary client queue. Number of excluded servers is %s and exception is %s");
+      List<ServerLocation> servers =
+          findQueueServers(excludedServers, 1, false, printPrimaryNotFoundError,
+              "Could not find any server to host primary client queue. Number of excluded servers is %s and exception is %s");
-        connection = factory.createClientToServerConnection((ServerLocation) servers.get(0), true);
+        connection = factory.createClientToServerConnection(servers.get(0), true);
-  private List findQueueServers(Set excludedServers, int count, boolean findDurable,
+  private List<ServerLocation> findQueueServers(Set<ServerLocation> excludedServers, int count,
+      boolean findDurable,
-    List servers = null;
+    List<ServerLocation> servers = null;
-      /*
-       * logger .warning(
-       * LocalizedStrings.QueueManagerImpl_COULD_NOT_RETRIEVE_LIST_OF_SERVERS_FOR_SUBSCRIPTION_0,
-       * new Object[] { e.getMessage() });
-       */
-        logger.debug("SubscriptionManager - Error getting the list of servers: {}", e);
+        logger.debug("SubscriptionManager - Error getting the list of servers: {}", e.getMessage());
-            new Object[] {(excludedServers != null ? excludedServers.size() : 0),
-                (ex != null ? ex.getMessage() : "no exception")}));
+            excludedServers != null ? excludedServers.size() : 0,
+            ex != null ? ex.getMessage() : "no exception"));
-  protected void recoverPrimary(Set excludedServers) {
+  private void recoverPrimary(Set<ServerLocation> excludedServers) {
-  protected void scheduleRedundancySatisfierIfNeeded(long delay) {
+  private void scheduleRedundancySatisfierIfNeeded(long delay) {
-    Iterator i = this.getPool().getRITracker()
-        .getRegionToInterestsMap(interestType, isDurable, !receiveValues).values().iterator();
-    while (i.hasNext()) { // restore a region
-      RegionInterestEntry e = (RegionInterestEntry) i.next();
+    for (RegionInterestEntry e : this.getPool().getRITracker()
+        .getRegionToInterestsMap(interestType, isDurable, !receiveValues)
+        .values()) {
+      // restore a region
-    } // restore a region
+    }
-    Iterator i = cqs.entrySet().iterator();
-    while (i.hasNext()) {
-      Map.Entry e = (Map.Entry) i.next();
+    for (Object o : cqs.entrySet()) {
+      Map.Entry e = (Map.Entry) o;
-  private void recoverSingleRegion(LocalRegion r, Map keys, int interestType,
+  private void recoverSingleRegion(LocalRegion r, Map<Object, InterestResultPolicy> keys,
+      int interestType,
-    HashMap policyMap = new HashMap();
-    Iterator keysIter = keys.entrySet().iterator();
-    while (keysIter.hasNext()) { // restore and commit an interest
-      Map.Entry me = (Map.Entry) keysIter.next();
+    HashMap<InterestResultPolicy, LinkedList<Object>> policyMap = new HashMap<>();
+    for (Map.Entry<Object, InterestResultPolicy> me : keys.entrySet()) {
+      // restore and commit an interest
-      InterestResultPolicy pol = (InterestResultPolicy) me.getValue();
+      InterestResultPolicy pol = me.getValue();
-        LinkedList keyList = (LinkedList) policyMap.get(pol);
+        LinkedList<Object> keyList = policyMap.get(pol);
-          keyList = new LinkedList();
+          keyList = new LinkedList<>();
-    Iterator polIter = policyMap.entrySet().iterator();
-    while (polIter.hasNext()) {
-      Map.Entry me = (Map.Entry) polIter.next();
-      LinkedList keyList = (LinkedList) me.getValue();
-      InterestResultPolicy pol = (InterestResultPolicy) me.getKey();
+    for (Map.Entry<InterestResultPolicy, LinkedList<Object>> me : policyMap.entrySet()) {
+      LinkedList<Object> keyList = me.getValue();
+      InterestResultPolicy pol = me.getKey();
-          serverKeys = r.getServerProxy().registerInterestOn(recoveredConnection, keys,
+          r.getServerProxy().registerInterestOn(recoveredConnection, keys,
-  protected void recoverAllInterestTypes(final Connection recoveredConnection,
+  private void recoverAllInterestTypes(final Connection recoveredConnection,
-  protected static class QSizeComparator implements java.util.Comparator {
+  protected static class QSizeComparator implements java.util.Comparator<ServerQueueStatus> {
-    public int compare(Object o1, Object o2) {
-      ServerQueueStatus s1 = (ServerQueueStatus) o1;
-      ServerQueueStatus s2 = (ServerQueueStatus) o2;
+    public int compare(ServerQueueStatus s1, ServerQueueStatus s2) {
-    private final Map/* <Endpoint, QueueConnection> */ connectionMap;
-    private final List/* <QueueConnection> */ backups;
+    private final Map<Endpoint, Connection> connectionMap;
+    private final List<Connection> backups;
-    public ConnectionList() {
+    ConnectionList() {
-      connectionMap = Collections.EMPTY_MAP;
-      backups = Collections.EMPTY_LIST;
+      connectionMap = Collections.emptyMap();
+      backups = Collections.emptyList();
-    private ConnectionList(QueueConnectionImpl primary, List backups,
+    private ConnectionList(QueueConnectionImpl primary, List<Connection> backups,
-      Map allConnectionsTmp = new HashMap();
-      for (Iterator itr = backups.iterator(); itr.hasNext();) {
-        QueueConnectionImpl nextConnection = (QueueConnectionImpl) itr.next();
+      Map<Endpoint, Connection> allConnectionsTmp = new HashMap<>();
+      for (Connection nextConnection : backups) {
-      this.backups = Collections.unmodifiableList(new ArrayList(backups));
+      this.backups = Collections.unmodifiableList(new ArrayList<>(backups));
-      List newBackups = backups;
+      List<Connection> newBackups = backups;
-        newBackups = new ArrayList(backups);
+        newBackups = new ArrayList<>(backups);
-    public ConnectionList setPrimaryDiscoveryFailed(GemFireException p_discoveryException) {
+    ConnectionList setPrimaryDiscoveryFailed(GemFireException p_discoveryException) {
-    public ConnectionList addBackup(QueueConnectionImpl queueConnection) {
-      ArrayList newBackups = new ArrayList(backups);
+    ConnectionList addBackup(QueueConnectionImpl queueConnection) {
+      ArrayList<Connection> newBackups = new ArrayList<>(backups);
-    public ConnectionList removeConnection(QueueConnectionImpl connection) {
+    ConnectionList removeConnection(QueueConnectionImpl connection) {
-        ArrayList newBackups = new ArrayList(backups);
+        ArrayList<Connection> newBackups = new ArrayList<>(backups);
-    public List/* <QueueConnection> */ getBackups() {
+    public List<Connection> getBackups() {
-    public ClientUpdater getFailedUpdater() {
+    ClientUpdater getFailedUpdater() {
-    public boolean primaryDiscoveryFailed() {
+    boolean primaryDiscoveryFailed() {
-    public GemFireException getPrimaryDiscoveryException() {
+    GemFireException getPrimaryDiscoveryException() {
-    public Set/* <ServerLocation> */ getAllLocations() {
-      HashSet locations = new HashSet();
-      for (Iterator itr = connectionMap.keySet().iterator(); itr.hasNext();) {
-        org.apache.geode.cache.client.internal.Endpoint endpoint =
-            (org.apache.geode.cache.client.internal.Endpoint) itr.next();
+    Set<ServerLocation> getAllLocations() {
+      HashSet<ServerLocation> locations = new HashSet<>();
+      for (Endpoint endpoint : connectionMap.keySet()) {
-
-  protected void logError(String message, Throwable t) {
+  private void logError(String message, Throwable t) {
-    public long getRemainingDelay() {
+    long getRemainingDelay() {
-        Set excludedServers = queueConnections.getAllLocations();
+        Set<ServerLocation> excludedServers = queueConnections.getAllLocations();

INS31 INS74 UPD83 INS79 UPD83 UPD83 UPD83 UPD83 INS78 UPD83 INS83 INS79 INS83 INS43 INS42 INS8 UPD83 UPD39 INS74 UPD83 UPD83 UPD83 INS74 UPD83 MOV43 INS43 INS42 INS45 INS79 INS42 INS70 INS70 INS70 INS70 INS42 INS45 INS42 INS41 INS74 INS74 MOV43 MOV43 INS74 INS74 INS70 INS70 INS74 INS70 INS70 MOV43 MOV43 INS74 INS74 INS74 INS74 INS42 INS42 INS45 INS74 INS44 INS42 MOV8 INS74 INS44 INS42 INS8 INS74 INS74 INS74 INS74 INS44 INS42 MOV8 INS44 INS42 MOV8 MOV32 MOV43 MOV43 MOV43 INS43 MOV43 INS43 MOV43 INS43 INS74 MOV43 INS43 INS44 MOV32 MOV8 INS44 MOV32 MOV8 MOV43 MOV43 INS43 INS74 INS44 MOV32 MOV8 MOV60 INS44 MOV32 MOV8 MOV43 UPD42 MOV43 UPD42 MOV43 INS43 INS43 MOV43 INS43 INS74 INS70 MOV43 INS43 MOV43 INS43 INS70 MOV43 INS43 MOV43 INS42 MOV43 MOV43 MOV43 INS42 MOV21 MOV43 INS43 MOV43 MOV43 MOV43 MOV43 INS43 MOV43 MOV43 MOV43 INS42 MOV43 INS42 INS32 INS42 INS70 INS42 INS42 MOV43 INS43 INS42 MOV43 INS42 MOV43 INS42 INS42 MOV43 MOV43 INS74 INS74 INS42 INS74 INS42 MOV60 INS42 INS42 INS42 MOV43 INS43 INS74 INS44 INS42 MOV8 INS74 INS74 UPD42 MOV42 INS42 INS74 INS44 MOV32 MOV8 INS42 MOV43 INS42 INS74 INS42 INS74 INS74 INS42 UPD42 INS74 INS44 INS42 MOV8 INS74 INS42 MOV43 MOV43 INS43 INS74 MOV43 MOV43 INS43 MOV43 MOV43 MOV43 INS74 INS74 MOV43 INS32 INS32 INS42 INS42 MOV43 INS43 INS43 MOV43 INS42 MOV43 INS43 MOV43 INS43 MOV14 MOV43 INS43 INS43 INS42 MOV43 MOV43 MOV43 MOV32 MOV43 MOV43 MOV43 INS42 MOV43 INS43 INS42 MOV43 UPD42 MOV42 UPD42 MOV32 MOV43 INS43 MOV43 INS43 UPD42 MOV32 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 INS74 INS42 INS42 INS74 INS74 INS42 INS74 UPD42 MOV42 INS74 MOV43 INS42 INS84 MOV32 INS27 INS42 MOV43 INS42 UPD42 MOV42 UPD42 MOV42 INS74 INS42 INS42 INS42 MOV43 INS74 INS14 MOV43 MOV43 INS43 MOV43 MOV43 INS43 INS43 MOV43 UPD27 MOV27 INS42 MOV43 INS43 MOV32 MOV43 INS74 INS42 UPD42 MOV42 INS74 INS42 INS42 MOV32 INS32 MOV16 MOV16 INS42 MOV32 MOV43 MOV43 MOV42 INS42 INS42 INS74 MOV43 DEL40 DEL26 DEL83 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL24 DEL42 DEL33 DEL7 DEL21 DEL33 DEL33 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL53 DEL8 DEL12 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL11 DEL11 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL9 DEL9 DEL42 DEL16 DEL36 DEL9 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL9 DEL41 DEL11 DEL85 DEL5 DEL36 DEL36 DEL4 DEL3 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL42 DEL32 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL32 DEL11 DEL11 DEL11 DEL40 DEL43 DEL42 DEL40 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL11 DEL59 DEL60 DEL11 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL7 DEL42 DEL42 DEL11 DEL59 DEL60 DEL42 DEL42 DEL11 DEL59 DEL60 DEL83 DEL40 DEL40 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL83 DEL83 DEL42 DEL14 DEL83 DEL83 DEL83 DEL83 DEL83 DEL40 DEL43 DEL42 DEL40 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL43 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL83
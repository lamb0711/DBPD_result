GEODE-6918: Cleanup and unit test PersistentOplogSet (#3775)

* Create PersistentOplogSetTest
* Encapsulate fields
* Reorganize fields
* Fix misc IDE warnings
* Remove unused code
* Remove commented out code
* Remove unnecessary uses of this
* Improve whitespace and comments
* Improve variable names

Co-authored-by: Aaron Lindsey <alindsey@pivotal.io>

+import java.util.Collection;
-  /** The active oplog * */
-  protected volatile Oplog child;
-
-  /** counter used for round-robin logic * */
-  int dirCounter = -1;
-
-  final Map<Long, Oplog> drfOnlyOplogs = new LinkedHashMap<Long, Oplog>();
+  private final Map<Long, Oplog> drfOnlyOplogs = new LinkedHashMap<>();
-  /** oplogs that are ready to compact */
-  final Map<Long, Oplog> oplogIdToOplog = new LinkedHashMap<Long, Oplog>();
+  private final Map<Long, Oplog> oplogIdToOplog = new LinkedHashMap<>();
+
-  private final Map<Long, Oplog> inactiveOplogs = new LinkedHashMap<Long, Oplog>(16, 0.75f, true);
+  private final Map<Long, Oplog> inactiveOplogs = new LinkedHashMap<>(16, 0.75f, true);
-  final AtomicInteger inactiveOpenCount = new AtomicInteger();
+  private final AtomicInteger inactiveOpenCount = new AtomicInteger();
-  private final Map<Long, DiskRecoveryStore> pendingRecoveryMap =
-      new HashMap<Long, DiskRecoveryStore>();
-  private final Map<Long, DiskRecoveryStore> currentRecoveryMap =
-      new HashMap<Long, DiskRecoveryStore>();
+  private final Map<Long, DiskRecoveryStore> pendingRecoveryMap = new HashMap<>();
+  private final Map<Long, DiskRecoveryStore> currentRecoveryMap = new HashMap<>();
-  final AtomicBoolean alreadyRecoveredOnce = new AtomicBoolean(false);
+  private final AtomicBoolean alreadyRecoveredOnce = new AtomicBoolean(false);
+
+  /** The active oplog * */
+  private volatile Oplog child;
-  private volatile long maxRecoveredOplogId = 0;
+  private volatile long maxRecoveredOplogId;
+  /** counter used for round-robin logic * */
+  private int dirCounter = -1;
-    return this.child;
+    return child;
-   *
-    this.child = oplog;
-    // oplogSetAdd(oplog);
+    child = oplog;
-  public Oplog[] getAllOplogs() {
-    synchronized (this.oplogIdToOplog) {
-      int rollNum = this.oplogIdToOplog.size();
-      int inactiveNum = this.inactiveOplogs.size();
-      int drfOnlyNum = this.drfOnlyOplogs.size();
+  Oplog[] getAllOplogs() {
+    synchronized (getOplogIdToOplog()) {
+      int rollNum = getOplogIdToOplog().size();
+      int inactiveNum = inactiveOplogs.size();
+      int drfOnlyNum = drfOnlyOplogs.size();
-      {
-        Iterator<Oplog> itr = this.oplogIdToOplog.values().iterator();
-        for (int i = 1; i <= rollNum; i++) {
-          oplogs[i] = itr.next();
-        }
+
+      Iterator<Oplog> oplogIterator = getOplogIdToOplog().values().iterator();
+      for (int i = 1; i <= rollNum; i++) {
+        oplogs[i] = oplogIterator.next();
-      {
-        Iterator<Oplog> itr = this.inactiveOplogs.values().iterator();
-        for (int i = 1; i <= inactiveNum; i++) {
-          oplogs[i + rollNum] = itr.next();
-        }
+
+      oplogIterator = inactiveOplogs.values().iterator();
+      for (int i = 1; i <= inactiveNum; i++) {
+        oplogs[i + rollNum] = oplogIterator.next();
-      {
-        Iterator<Oplog> itr = this.drfOnlyOplogs.values().iterator();
-        for (int i = 1; i <= drfOnlyNum; i++) {
-          oplogs[i + rollNum + inactiveNum] = itr.next();
-        }
+
+      oplogIterator = drfOnlyOplogs.values().iterator();
+      for (int i = 1; i <= drfOnlyNum; i++) {
+        oplogs[i + rollNum + inactiveNum] = oplogIterator.next();
+
-    TreeSet<Oplog> result = new TreeSet<Oplog>(new Comparator() {
-      @Override
-      public int compare(Object arg0, Object arg1) {
-        return Long.signum(((Oplog) arg1).getOplogId() - ((Oplog) arg0).getOplogId());
-      }
-    });
+    TreeSet<Oplog> result = new TreeSet<Oplog>(
+        (Comparator) (arg0, arg1) -> Long
+            .signum(((Oplog) arg1).getOplogId() - ((Oplog) arg0).getOplogId()));
-    Oplog localOplog = this.child;
+    Oplog localOplog = child;
-    } else {
-      Long key = Long.valueOf(id);
-      synchronized (this.oplogIdToOplog) {
-        Oplog result = oplogIdToOplog.get(key);
-        if (result == null) {
-          result = inactiveOplogs.get(key);
-        }
-        return result;
+    }
+
+    synchronized (getOplogIdToOplog()) {
+      Oplog result = getOplogIdToOplog().get(id);
+      if (result == null) {
+        result = inactiveOplogs.get(id);
+      return result;
-  public void offlineModify(DiskRegionView drv, DiskEntry entry, byte[] value,
+  void offlineModify(DiskRegionView drv, DiskEntry entry, byte[] value,
-  public Map<File, DirectoryHolder> findFiles(String partialFileName) {
-    this.dirCounter = 0;
-    Map<File, DirectoryHolder> backupFiles = new HashMap<File, DirectoryHolder>();
+  Map<File, DirectoryHolder> findFiles(String partialFileName) {
+    dirCounter = 0;
+    Map<File, DirectoryHolder> backupFiles = new HashMap<>();
+
-  protected FilenameFilter getFileNameFilter(String partialFileName) {
+  private FilenameFilter getFileNameFilter(String partialFileName) {
-  public void createOplogs(boolean needsOplogs, Map<File, DirectoryHolder> backupFiles) {
+  void createOplogs(boolean needsOplogs, Map<File, DirectoryHolder> backupFiles) {
-
-      int underscorePosition = absolutePath.lastIndexOf("_");
-      int pointPosition = absolutePath.lastIndexOf(".");
-      String opid = absolutePath.substring(underscorePosition + 1, pointPosition);
-      long oplogId = Long.parseLong(opid);
+
+      int underscorePosition = absolutePath.lastIndexOf('_');
+      int pointPosition = absolutePath.lastIndexOf('.');
+      String oplogIdString = absolutePath.substring(underscorePosition + 1, pointPosition);
+      long oplogId = Long.parseLong(oplogIdString);
+
+
+
-          } catch (Exception ex) {// ignore
+          } catch (Exception ignore) {
+            // ignore
-          continue; // this file we unable to delete earlier
+          // this file we unable to delete earlier
+          continue;
+
-          continue; // this file we unable to delete earlier
+          // this file we unable to delete earlier
+          continue;
-        // oplogSet.add(oplog);
+
-  protected boolean isDrfOplogIdPresent(long oplogId) {
+  private boolean isDrfOplogIdPresent(long oplogId) {
-  protected boolean isCrfOplogIdPresent(long oplogId) {
+  private boolean isCrfOplogIdPresent(long oplogId) {
-  protected void verifyOplogs(LongOpenHashSet foundCrfs, LongOpenHashSet foundDrfs) {
+  private void verifyOplogs(LongOpenHashSet foundCrfs, LongOpenHashSet foundDrfs) {
-    } catch (Exception e) {
+    } catch (Exception ignore) {
-  void addRecoveredOplog(Oplog oplog) {
+  private void addRecoveredOplog(Oplog oplog) {
-      oplog.close(); // fix for bug 41687
+      oplog.close();
+
-      int inactivePromotedCount = 0;
-      Long key = Long.valueOf(oplog.getOplogId());
-      synchronized (this.oplogIdToOplog) {
-        if (this.inactiveOplogs.remove(key) != null) {
+      Long key = oplog.getOplogId();
+      int inactivePromotedCount = 0;
+
+      synchronized (getOplogIdToOplog()) {
+        if (inactiveOplogs.remove(key) != null) {
-        this.oplogIdToOplog.put(key, oplog);
+        getOplogIdToOplog().put(key, oplog);
+
-  public void recoverRegionsThatAreReady() {
+  void recoverRegionsThatAreReady() {
-    synchronized (this.alreadyRecoveredOnce) {
+    synchronized (getAlreadyRecoveredOnce()) {
+
-      synchronized (this.pendingRecoveryMap) {
-        this.currentRecoveryMap.clear();
-        this.currentRecoveryMap.putAll(this.pendingRecoveryMap);
-        this.pendingRecoveryMap.clear();
+      synchronized (pendingRecoveryMap) {
+        currentRecoveryMap.clear();
+        currentRecoveryMap.putAll(pendingRecoveryMap);
+        pendingRecoveryMap.clear();
-      if (this.currentRecoveryMap.isEmpty() && this.alreadyRecoveredOnce.get()) {
+
+      if (currentRecoveryMap.isEmpty() && getAlreadyRecoveredOnce().get()) {
-      for (DiskRecoveryStore drs : this.currentRecoveryMap.values()) {
+      for (DiskRecoveryStore drs : currentRecoveryMap.values()) {
-      if (!this.alreadyRecoveredOnce.get()) {
+
+      if (!getAlreadyRecoveredOnce().get()) {
-      final long start = parent.getStats().startRecovery();
-      long byteCount = 0;
+      long start = parent.getStats().startRecovery();
+
+      long byteCount = 0;
-          prSizes = new HashMap<String, Integer>();
-          prBuckets = new HashMap<String, Integer>();
+          prSizes = new HashMap<>();
+          prBuckets = new HashMap<>();
-        for (DiskRecoveryStore drs : this.currentRecoveryMap.values()) {
+
+        for (DiskRecoveryStore drs : currentRecoveryMap.values()) {
+
-              ValidatingDiskRegion vdr = ((ValidatingDiskRegion) drs);
+              ValidatingDiskRegion vdr = (ValidatingDiskRegion) drs;
+
-            System.out.println(me.getKey() + " entryCount=" + me.getValue() + " bucketCount="
-                + prBuckets.get(me.getKey()));
+
-        this.alreadyRecoveredOnce.set(true);
-        this.currentRecoveryMap.clear();
+        getAlreadyRecoveredOnce().set(true);
+        currentRecoveryMap.clear();
-
-    Set<Oplog> oplogsNeedingValueRecovery = new HashSet<Oplog>();
-    if (!this.alreadyRecoveredOnce.get()) {
+
+    if (!getAlreadyRecoveredOnce().get()) {
-    if (oplogSet.size() > 0) {
+
+    Set<Oplog> oplogsNeedingValueRecovery = new HashSet<>();
+
+    if (!oplogSet.isEmpty()) {
+
-        byteCount += oplog.recoverDrf(deletedIds, this.alreadyRecoveredOnce.get(), latestOplog);
+        byteCount += oplog.recoverDrf(deletedIds, getAlreadyRecoveredOnce().get(), latestOplog);
-        if (!this.alreadyRecoveredOnce.get()) {
+        if (!getAlreadyRecoveredOnce().get()) {
+
+
-        long bytesRead = oplog.recoverCrf(deletedIds,
-            // @todo make recoverValues per region
-            recoverValues(), recoverValuesSync(), this.alreadyRecoveredOnce.get(),
-            oplogsNeedingValueRecovery, latestOplog);
+        long bytesRead = oplog.recoverCrf(deletedIds, recoverValues(), recoverValuesSync(),
+            getAlreadyRecoveredOnce().get(), oplogsNeedingValueRecovery, latestOplog);
-        if (!this.alreadyRecoveredOnce.get()) {
+        if (!getAlreadyRecoveredOnce().get()) {
-        for (DiskRecoveryStore drs : this.currentRecoveryMap.values()) {
+        for (DiskRecoveryStore drs : currentRecoveryMap.values()) {
+
-      logger
-          .info("recovery oplog load took {} ms", elapsed);
+      logger.info("recovery oplog load took {} ms", elapsed);
+
+
-      for (DiskRecoveryStore drs : this.currentRecoveryMap.values()) {
+      for (DiskRecoveryStore drs : currentRecoveryMap.values()) {
-      if (!this.alreadyRecoveredOnce.get()) {
+
+      if (!getAlreadyRecoveredOnce().get()) {
-          // TODO DAN - should we defer compaction until after
-          // value recovery is complete? Or at least until after
-          // value recovery for a given oplog is complete?
-          // Right now, that's effectively what we're doing
-          // because this uses up the compactor thread.
-          parent.scheduleValueRecovery(oplogsNeedingValueRecovery, this.currentRecoveryMap);
+          // value recovery defers compaction because it is using the compactor thread
+          parent.scheduleValueRecovery(oplogsNeedingValueRecovery, currentRecoveryMap);
-        if (!this.alreadyRecoveredOnce.get()) {
+
+        if (!getAlreadyRecoveredOnce().get()) {
-        logger
-            .info("recovery region initialization took {} ms",
-                endRegionInit - startRegionInit);
+        logger.info("recovery region initialization took {} ms", endRegionInit - startRegionInit);
-  protected boolean recoverValuesSync() {
+  private boolean recoverValuesSync() {
-  protected boolean recoverValues() {
+  private boolean recoverValues() {
-    if (parent.isOffline() && !parent.isOfflineCompacting() && !parent.isOfflineModify())
+    if (parent.isOffline() && !parent.isOfflineCompacting() && !parent.isOfflineModify()) {
+    }
+
-      dirCounter = (++dirCounter) % parent.dirLength;
+      dirCounter = ++dirCounter % parent.dirLength;
+
-    this.oplogEntryId.set(DiskStoreImpl.INVALID_ID);
+    oplogEntryId.set(DiskStoreImpl.INVALID_ID);
-      curVal = this.oplogEntryId.get();
+      curVal = oplogEntryId.get();
-    } while (!this.oplogEntryId.compareAndSet(curVal, v));
+    } while (!oplogEntryId.compareAndSet(curVal, v));
-    return this.oplogEntryId.get();
+    return oplogEntryId.get();
-    long result = this.oplogEntryId.incrementAndGet();
-    return result;
+    return oplogEntryId.incrementAndGet();
-    DirectoryHolder dirHolder = null;
-    DirectoryHolder selectedHolder = null;
-    synchronized (parent.directories) {
+
+    DirectoryHolder selectedHolder = null;
+    synchronized (parent.getDirectoryHolders()) {
-        dirHolder = parent.directories[this.dirCounter];
-        // Asif :Increment the directory counter to next position so that next
-        // time when this operation is invoked, it checks for the Directory
-        // Space in a cyclical fashion.
-        dirCounter = (++dirCounter) % parent.dirLength;
-        // if the current directory has some space, then quit and
-        // return the dir
+        DirectoryHolder dirHolder = parent.directories[dirCounter];
+
+        // Increment the directory counter to next position so that next time when this operation
+        // is invoked, it checks for the Directory Space in a cyclical fashion.
+        dirCounter = ++dirCounter % parent.dirLength;
+
+        // if the current directory has some space, then quit and return the dir
-          /*
-           * try { this.isThreadWaitingForSpace = true; this.directories.wait(MAX_WAIT_FOR_SPACE); }
-           * catch (InterruptedException ie) { throw new DiskAccessException(LocalizedStrings.
-           * DiskRegion_UNABLE_TO_GET_FREE_SPACE_FOR_CREATING_AN_OPLOG_AS_THE_THREAD_ENCOUNETERD_EXCEPTION_WHILE_WAITING_FOR_COMPACTOR_THREAD_TO_FREE_SPACE
-           * ), ie); }
-           */
+          selectedHolder = parent.directories[dirCounter];
-          selectedHolder = parent.directories[this.dirCounter];
-          this.dirCounter = (++this.dirCounter) % parent.dirLength;
+          dirCounter = ++dirCounter % parent.dirLength;
-            /*
-             * throw new DiskAccessException(LocalizedStrings.
-             * DiskRegion_UNABLE_TO_GET_FREE_SPACE_FOR_CREATING_AN_OPLOG_AFTER_WAITING_FOR_0_1_2_SECONDS
-             * new Object[] {MAX_WAIT_FOR_SPACE, /, (1000)}));
-             */
-                new Object[] {Long.valueOf(selectedHolder.getUsedSpace()),
-                    Long.valueOf(selectedHolder.getCapacity())});
+                selectedHolder.getUsedSpace(), selectedHolder.getCapacity());
-              "Disk is full and compaction is disabled. No space can be created",
-              parent);
+              "Disk is full and compaction is disabled. No space can be created", parent);
-    return selectedHolder;
+    return selectedHolder;
-  void addDrf(Oplog oplog) {
-    synchronized (this.oplogIdToOplog) {
-      this.drfOnlyOplogs.put(Long.valueOf(oplog.getOplogId()), oplog);
+  private void addDrf(Oplog oplog) {
+    synchronized (getOplogIdToOplog()) {
+      drfOnlyOplogs.put(oplog.getOplogId(), oplog);
-    synchronized (this.oplogIdToOplog) {
-      this.drfOnlyOplogs.remove(Long.valueOf(oplog.getOplogId()));
+    synchronized (getOplogIdToOplog()) {
+      drfOnlyOplogs.remove(oplog.getOplogId());
-    synchronized (this.oplogIdToOplog) {
-      Iterator<Long> it = this.oplogIdToOplog.keySet().iterator();
-      while (it.hasNext()) {
-        long otherId = it.next().longValue();
+    synchronized (getOplogIdToOplog()) {
+      for (long otherId : getOplogIdToOplog().keySet()) {
+
-      it = this.inactiveOplogs.keySet().iterator();
-      while (it.hasNext()) {
-        long otherId = it.next().longValue();
+      for (long otherId : inactiveOplogs.keySet()) {
+
-   * Destroy all the oplogs that are: 1. the oldest (based on smallest oplog id) 2. empty (have no
-   * live values)
+   * Destroy all the oplogs that are:
+   *
+   * <pre>
+   * 1. the oldest (based on smallest oplog id)
+   * 2. empty (have no live values)
+   * </pre>
-    synchronized (this.oplogIdToOplog) {
-      if (this.drfOnlyOplogs.isEmpty())
+    synchronized (getOplogIdToOplog()) {
+      if (drfOnlyOplogs.isEmpty()) {
+      }
+
-    ArrayList<Oplog> toDestroy = new ArrayList<Oplog>();
+    List<Oplog> toDestroy = new ArrayList<>();
+
-      synchronized (this.oplogIdToOplog) {
-        toDestroy.addAll(this.drfOnlyOplogs.values());
+      synchronized (getOplogIdToOplog()) {
+        toDestroy.addAll(drfOnlyOplogs.values());
+
-      synchronized (this.oplogIdToOplog) {
-        for (Oplog oplog : this.drfOnlyOplogs.values()) {
+      synchronized (getOplogIdToOplog()) {
+        for (Oplog oplog : drfOnlyOplogs.values()) {
-            // } else {
-            // // since drfOnlyOplogs is sorted any other ones will be even
-            // bigger
-            // // so we can break out of this loop
-            // break;
+
-  /**
-   * Returns the oldest oplog that is ready to compact. Returns null if no oplogs are ready to
-   * compact. Age is based on the oplog id.
-   */
-  private Oplog getOldestReadyToCompact() {
-    Oplog oldest = null;
-    synchronized (this.oplogIdToOplog) {
-      Iterator<Oplog> it = this.oplogIdToOplog.values().iterator();
-      while (it.hasNext()) {
-        Oplog oldestCompactable = it.next();
-        if (oldest == null || oldestCompactable.getOplogId() < oldest.getOplogId()) {
-          oldest = oldestCompactable;
-        }
-      }
-      it = this.drfOnlyOplogs.values().iterator();
-      while (it.hasNext()) {
-        Oplog oldestDrfOnly = it.next();
-        if (oldest == null || oldestDrfOnly.getOplogId() < oldest.getOplogId()) {
-          oldest = oldestDrfOnly;
-        }
-      }
-    }
-    return oldest;
-  }
-
-    synchronized (this.oplogIdToOplog) {
-      Iterator<Oplog> it = this.oplogIdToOplog.values().iterator();
-      while (it.hasNext()) {
-        Oplog n = it.next();
-        if (result == null || n.getOplogId() < result.getOplogId()) {
-          result = n;
+    synchronized (getOplogIdToOplog()) {
+      for (Oplog oplog : getOplogIdToOplog().values()) {
+        if (result == null || oplog.getOplogId() < result.getOplogId()) {
+          result = oplog;
+
-      it = this.inactiveOplogs.values().iterator();
-      while (it.hasNext()) {
-        Oplog n = it.next();
-        if (result == null || n.getOplogId() < result.getOplogId()) {
-          result = n;
+      for (Oplog oplog : inactiveOplogs.values()) {
+        if (result == null || oplog.getOplogId() < result.getOplogId()) {
+          result = oplog;
+
-    Long key = Long.valueOf(oplog.getOplogId());
-    synchronized (this.oplogIdToOplog) {
+    Long key = oplog.getOplogId();
+    synchronized (getOplogIdToOplog()) {
-      this.inactiveOplogs.get(key);
+      inactiveOplogs.get(key);
-    Long key = Long.valueOf(oplog.getOplogId());
-    ArrayList<Oplog> openlist = null;
-    synchronized (this.oplogIdToOplog) {
+    Long key = oplog.getOplogId();
+    List<Oplog> openlist = null;
+    synchronized (getOplogIdToOplog()) {
+
-        // It is possible that 'oplog' is compactable instead of inactive.
-        // So set the isInactive.
-        isInactive = this.inactiveOplogs.get(key) != null;
+        // It is possible that 'oplog' is compactible instead of inactive. So set isInactive.
+        isInactive = inactiveOplogs.get(key) != null;
-        this.inactiveOplogs.put(key, oplog);
+        inactiveOplogs.put(key, oplog);
-      if ((reopen && isInactive) || oplog.isRAFOpen()) {
+
+      if (reopen && isInactive || oplog.isRAFOpen()) {
-          openlist = new ArrayList<Oplog>();
-          for (Oplog o : this.inactiveOplogs.values()) {
-            if (o.isRAFOpen()) {
+          openlist = new ArrayList<>();
+          for (Oplog inactiveOplog : inactiveOplogs.values()) {
+            if (inactiveOplog.isRAFOpen()) {
-              openlist.add(o);
+              openlist.add(inactiveOplog);
-      for (Oplog o : openlist) {
-        if (o.closeRAF()) {
+      for (Oplog openOplog : openlist) {
+        if (openOplog.closeRAF()) {
-  public void clear(DiskRegion dr, RegionVersionVector rvv) {
+  public void clear(DiskRegion diskRegion, RegionVersionVector regionVersionVector) {
-    // to fix bug 44336 put them in another collection
-    ArrayList<Oplog> oplogsToClear = new ArrayList<Oplog>();
-    synchronized (this.oplogIdToOplog) {
-      for (Oplog oplog : this.oplogIdToOplog.values()) {
-        oplogsToClear.add(oplog);
+    Collection<Oplog> oplogsToClear = new ArrayList<>();
+    synchronized (getOplogIdToOplog()) {
+      oplogsToClear.addAll(getOplogIdToOplog().values());
+      oplogsToClear.addAll(inactiveOplogs.values());
+
+      Oplog child = getChild();
+      if (child != null) {
+        oplogsToClear.add(child);
-      for (Oplog oplog : this.inactiveOplogs.values()) {
-        oplogsToClear.add(oplog);
-      }
-      {
-        Oplog child = getChild();
-        if (child != null) {
-          oplogsToClear.add(child);
-        }
-      }
-    }
-    for (Oplog oplog : oplogsToClear) {
-      oplog.clear(dr, rvv);
-    if (rvv != null) {
-      parent.getDiskInitFile().clearRegion(dr, rvv);
+    for (Oplog oplog : oplogsToClear) {
+      oplog.clear(diskRegion, regionVersionVector);
+    }
+
+    if (regionVersionVector != null) {
+      parent.getDiskInitFile().clearRegion(diskRegion, regionVersionVector);
-      parent.getDiskInitFile().clearRegion(dr, clearedOplogEntryId);
+      parent.getDiskInitFile().clearRegion(diskRegion, clearedOplogEntryId);
-    RuntimeException rte = null;
+    RuntimeException firstRuntimeException = null;
-      if (rte != null) {
-        rte = e;
-      }
+      firstRuntimeException = e;
-    if (this.child != null) {
+    if (child != null) {
-        this.child.finishKrf();
+        child.finishKrf();
-        if (rte != null) {
-          rte = e;
+        if (firstRuntimeException != null) {
+          firstRuntimeException = e;
-        this.child.close();
+        child.close();
-        if (rte != null) {
-          rte = e;
+        if (firstRuntimeException != null) {
+          firstRuntimeException = e;
-    return rte;
+    return firstRuntimeException;
-    // if there are oplogs which are to be compacted, destroy them
-    // do not do oplogs[0]
+
+    // if there are oplogs which are to be compacted, destroy them do not do oplogs[0]
-    Oplog oplog = null;
+    Oplog oplog;
-    Long key = Long.valueOf(id);
-    synchronized (this.oplogIdToOplog) {
-      oplog = this.oplogIdToOplog.remove(key);
+
+    synchronized (getOplogIdToOplog()) {
+      Long key = id;
+      oplog = getOplogIdToOplog().remove(key);
-        oplog = this.inactiveOplogs.remove(key);
+        oplog = inactiveOplogs.remove(key);
-          oplog = this.drfOnlyOplogs.remove(key);
+          oplog = drfOnlyOplogs.remove(key);
+
+
+
-    ArrayList<Oplog> oplogsToClose = new ArrayList<Oplog>();
-    synchronized (this.oplogIdToOplog) {
-      oplogsToClose.addAll(this.oplogIdToOplog.values());
-      oplogsToClose.addAll(this.inactiveOplogs.values());
-      oplogsToClose.addAll(this.drfOnlyOplogs.values());
-      {
-        Oplog child = getChild();
-        if (child != null) {
-          oplogsToClose.add(child);
-        }
+    List<Oplog> oplogsToClose = new ArrayList<>();
+    synchronized (getOplogIdToOplog()) {
+      oplogsToClose.addAll(getOplogIdToOplog().values());
+      oplogsToClose.addAll(inactiveOplogs.values());
+      oplogsToClose.addAll(drfOnlyOplogs.values());
+
+      Oplog child = getChild();
+      if (child != null) {
+        oplogsToClose.add(child);
+
-    ArrayList<Oplog> oplogsToPrepare = new ArrayList<Oplog>();
-    synchronized (this.oplogIdToOplog) {
-      oplogsToPrepare.addAll(this.oplogIdToOplog.values());
-      oplogsToPrepare.addAll(this.inactiveOplogs.values());
+    Collection<Oplog> oplogsToPrepare = new ArrayList<>();
+    synchronized (getOplogIdToOplog()) {
+      oplogsToPrepare.addAll(getOplogIdToOplog().values());
+      oplogsToPrepare.addAll(inactiveOplogs.values());
+
-    long child_oplogid = this.getChild() == null ? -1 : this.getChild().oplogId;
+    long childOplogId = getChild() == null ? -1 : getChild().oplogId;
+
-      if (child_oplogid != -1 && oplog.oplogId == child_oplogid) {
+      if (childOplogId != -1 && oplog.oplogId == childOplogId) {
-    if (!childPreparedForClose && this.getChild() != null) {
-      this.getChild().prepareForClose();
+
+    if (!childPreparedForClose && getChild() != null) {
+      getChild().prepareForClose();
-  public void basicDestroy(DiskRegion dr) {
-    ArrayList<Oplog> oplogsToDestroy = new ArrayList<Oplog>();
-    synchronized (this.oplogIdToOplog) {
-      for (Oplog oplog : this.oplogIdToOplog.values()) {
-        oplogsToDestroy.add(oplog);
-      }
-      for (Oplog oplog : this.inactiveOplogs.values()) {
-        oplogsToDestroy.add(oplog);
-      }
-      for (Oplog oplog : this.drfOnlyOplogs.values()) {
-        oplogsToDestroy.add(oplog);
-      }
-      {
-        Oplog child = getChild();
-        if (child != null) {
-          oplogsToDestroy.add(child);
-        }
+  public void basicDestroy(DiskRegion diskRegion) {
+    Collection<Oplog> oplogsToDestroy = new ArrayList<>();
+    synchronized (getOplogIdToOplog()) {
+      oplogsToDestroy.addAll(getOplogIdToOplog().values());
+      oplogsToDestroy.addAll(inactiveOplogs.values());
+      oplogsToDestroy.addAll(drfOnlyOplogs.values());
+
+      Oplog child = getChild();
+      if (child != null) {
+        oplogsToDestroy.add(child);
+
-      oplog.destroy(dr);
+      oplog.destroy(diskRegion);
-  public void destroyAllOplogs() {
-    // get a snapshot to prevent CME
+  void destroyAllOplogs() {
+    // get a snapshot to prevent ConcurrentModificationException
-  public void getCompactableOplogs(List<CompactableOplog> l, int max) {
-    synchronized (this.oplogIdToOplog) {
-      // Sort this list so we compact the oldest first instead of the one
-      // that was
-      // compactable first.
-      // ArrayList<CompactableOplog> l = new
-      // ArrayList<CompactableOplog>(this.oplogIdToOplog.values());
-      // Collections.sort(l);
-      // Iterator<Oplog> itr = l.iterator();
-      {
-        Iterator<Oplog> itr = this.oplogIdToOplog.values().iterator();
-        while (itr.hasNext() && l.size() < max) {
-          Oplog oplog = itr.next();
-          if (oplog.needsCompaction()) {
-            l.add(oplog);
-          }
+  void getCompactableOplogs(List<CompactableOplog> compactableOplogs) {
+    synchronized (getOplogIdToOplog()) {
+      // Sort this list so we compact the oldest first instead of the first compactable one
+      for (Oplog oplog : getOplogIdToOplog().values()) {
+        if (oplog.needsCompaction()) {
+          compactableOplogs.add(oplog);
-  public void scheduleForRecovery(DiskRecoveryStore drs) {
-    DiskRegionView dr = drs.getDiskRegionView();
-    if (dr.isRecreated() && (dr.getMyPersistentID() != null || dr.getMyInitializingID() != null)) {
+  void scheduleForRecovery(DiskRecoveryStore diskRecoveryStore) {
+    DiskRegionView diskRegionView = diskRecoveryStore.getDiskRegionView();
+    if (diskRegionView.isRecreated() &&
+        (diskRegionView.getMyPersistentID() != null
+            || diskRegionView.getMyInitializingID() != null)) {
-      DiskRecoveryStore p_drs = drs;
-      synchronized (this.pendingRecoveryMap) {
-        this.pendingRecoveryMap.put(dr.getId(), p_drs);
+      synchronized (pendingRecoveryMap) {
+        pendingRecoveryMap.put(diskRegionView.getId(), diskRecoveryStore);
-  public DiskRecoveryStore getCurrentlyRecovering(long drId) {
-    return this.currentRecoveryMap.get(drId);
+  DiskRecoveryStore getCurrentlyRecovering(long drId) {
+    return currentRecoveryMap.get(drId);
-  public void initChild() {
+  void initChild() {
-    { // remove any oplogs that only have a drf to fix bug 42036
-      ArrayList<Oplog> toDestroy = new ArrayList<Oplog>();
-      synchronized (this.oplogIdToOplog) {
-        Iterator<Oplog> it = this.oplogIdToOplog.values().iterator();
-        while (it.hasNext()) {
-          Oplog n = it.next();
-          if (n.isDrfOnly()) {
-            toDestroy.add(n);
-          }
+    // remove any oplogs that only have a drf
+    Collection<Oplog> oplogsToDestroy = new ArrayList<>();
+    synchronized (getOplogIdToOplog()) {
+      for (Oplog oplog : getOplogIdToOplog().values()) {
+        if (oplog.isDrfOnly()) {
+          oplogsToDestroy.add(oplog);
-      for (Oplog oplog : toDestroy) {
-        oplog.destroy();
-      }
-      destroyOldestReadyToCompact();
+
+    for (Oplog oplog : oplogsToDestroy) {
+      oplog.destroy();
+    }
+
+    destroyOldestReadyToCompact();
-  public void updateDiskRegion(AbstractDiskRegion dr) {
+  void updateDiskRegion(AbstractDiskRegion diskRegion) {
-        oplog.updateDiskRegion(dr);
+        oplog.updateDiskRegion(diskRegion);
-  public void flushChild() {
+  void flushChild() {
-  public void crfCreate(long oplogId) {
+  void crfCreate(long oplogId) {
-  public void drfCreate(long oplogId) {
+  void drfCreate(long oplogId) {
-  public void crfDelete(long oplogId) {
+  void crfDelete(long oplogId) {
-  public void drfDelete(long oplogId) {
+  void drfDelete(long oplogId) {
-  public boolean couldHaveKrf() {
+  boolean couldHaveKrf() {
+
+  /** oplogs that are ready to compact */
+  Map<Long, Oplog> getOplogIdToOplog() {
+    return oplogIdToOplog;
+  }
+
+  AtomicBoolean getAlreadyRecoveredOnce() {
+    return alreadyRecoveredOnce;
+  }

INS26 MOV23 MOV23 MOV23 MOV31 INS40 INS23 INS31 INS31 INS83 INS59 INS74 MOV59 MOV29 INS83 INS83 MOV74 MOV59 INS83 INS83 UPD83 INS83 UPD83 UPD83 UPD83 UPD83 INS83 MOV60 UPD83 UPD83 MOV60 INS83 UPD42 MOV44 UPD42 MOV44 INS8 MOV29 MOV74 INS42 INS8 INS43 INS42 INS8 INS42 INS14 UPD43 MOV43 MOV43 MOV43 UPD42 UPD42 UPD42 UPD42 INS25 INS51 INS41 MOV60 MOV60 UPD42 UPD42 INS60 INS51 MOV8 INS60 INS51 MOV60 UPD42 UPD42 MOV43 INS42 MOV25 MOV60 MOV51 MOV70 MOV21 UPD42 INS41 INS42 INS41 INS74 UPD42 UPD74 UPD74 INS34 INS34 INS9 UPD74 UPD74 INS42 INS32 MOV43 MOV27 MOV8 INS32 INS8 MOV12 MOV60 INS32 MOV60 INS38 INS8 INS32 INS32 INS32 INS32 INS32 INS66 INS66 UPD66 UPD66 INS66 INS32 INS74 INS32 MOV43 INS32 MOV8 UPD74 INS32 INS74 INS59 INS32 MOV8 MOV44 UPD42 MOV43 INS32 INS74 INS59 INS32 MOV8 INS74 INS32 UPD74 INS32 MOV8 MOV44 INS32 INS8 UPD74 INS32 MOV44 UPD42 INS42 INS42 INS43 INS42 INS42 MOV60 MOV24 INS21 MOV24 INS21 MOV24 MOV14 INS42 INS42 MOV60 INS25 MOV41 INS42 INS42 INS32 INS41 INS21 INS42 INS42 INS42 MOV42 INS42 INS42 INS42 INS42 INS42 INS70 INS70 INS42 INS43 MOV43 INS14 INS42 INS70 INS70 MOV32 UPD42 MOV42 MOV32 UPD43 MOV43 INS42 INS43 MOV43 INS42 INS14 UPD42 MOV42 INS21 INS21 UPD42 MOV60 UPD42 MOV44 INS8 INS42 INS42 INS60 UPD43 MOV43 MOV43 INS42 INS14 INS42 INS21 INS21 INS21 INS43 MOV43 UPD42 INS42 UPD42 UPD43 MOV43 MOV14 INS42 INS21 INS21 INS21 INS42 INS70 UPD42 INS42 UPD43 MOV43 UPD42 INS42 INS70 INS42 INS7 INS7 MOV74 INS11 MOV43 MOV27 INS8 UPD74 UPD42 INS32 INS42 INS32 UPD74 MOV42 UPD42 MOV42 INS7 INS42 MOV32 MOV32 INS44 INS32 MOV8 INS44 INS32 MOV8 INS8 INS42 INS74 INS32 INS32 MOV44 INS32 MOV8 MOV44 INS32 MOV8 MOV32 UPD42 INS42 UPD74 MOV74 INS32 INS32 MOV21 MOV43 INS59 UPD42 UPD74 MOV74 INS32 INS32 INS32 INS42 UPD74 MOV38 UPD42 UPD74 INS32 INS32 INS32 MOV44 INS32 INS8 UPD42 UPD42 INS42 UPD42 UPD74 MOV74 MOV44 INS32 INS8 UPD42 INS42 INS32 INS42 INS32 MOV43 INS86 UPD42 INS21 UPD42 MOV32 INS42 INS42 INS42 MOV25 MOV25 INS42 INS42 INS27 INS60 MOV21 UPD42 UPD42 INS42 UPD42 UPD42 INS39 INS42 INS32 MOV42 INS39 INS42 INS42 MOV42 INS42 INS41 INS43 INS42 INS42 INS32 MOV42 INS42 MOV42 MOV27 MOV43 INS42 INS42 INS42 INS32 INS42 INS42 INS32 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV44 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 UPD42 INS32 MOV42 MOV25 INS32 MOV42 MOV25 INS32 INS42 INS42 MOV32 MOV42 MOV32 MOV42 INS59 INS59 MOV32 INS32 UPD42 INS7 INS13 INS13 UPD42 INS42 INS32 INS32 MOV21 INS32 INS38 INS40 INS42 MOV43 INS59 INS42 INS42 INS42 INS32 INS42 INS42 INS42 UPD42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 UPD42 MOV38 UPD42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 MOV8 INS42 INS32 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS2 MOV21 INS42 INS42 UPD42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 INS42 UPD42 UPD42 UPD42 UPD42 MOV42 MOV42 UPD42 MOV42 INS12 INS42 INS42 INS42 INS32 INS32 INS32 MOV40 INS42 MOV38 INS42 UPD42 UPD42 INS42 UPD42 INS44 INS8 UPD42 UPD42 INS32 INS42 INS32 INS42 INS42 INS42 UPD42 UPD42 UPD42 UPD42 INS42 MOV14 MOV43 UPD42 INS42 UPD42 MOV43 INS42 UPD74 UPD74 INS42 INS42 INS42 MOV38 UPD74 UPD42 UPD42 INS42 MOV32 MOV32 UPD42 MOV11 UPD42 DEL83 DEL23 DEL42 DEL43 DEL42 DEL43 DEL42 DEL74 DEL34 DEL34 DEL9 DEL14 DEL59 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL34 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL8 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL32 DEL59 DEL60 DEL8 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL32 DEL59 DEL60 DEL8 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL41 DEL8 DEL31 DEL1 DEL14 DEL52 DEL42 DEL22 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL32 DEL59 DEL60 DEL25 DEL8 DEL51 DEL8 DEL25 DEL83 DEL83 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL83 DEL45 DEL45 DEL42 DEL44 DEL8 DEL12 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL52 DEL42 DEL22 DEL36 DEL40 DEL42 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL32 DEL45 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL27 DEL32 DEL21 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL32 DEL34 DEL27 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL41 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL39 DEL42 DEL52 DEL42 DEL22 DEL32 DEL59 DEL60 DEL42 DEL41 DEL42 DEL33 DEL59 DEL60 DEL40 DEL36 DEL42 DEL52 DEL42 DEL22 DEL2 DEL7 DEL21 DEL52 DEL42 DEL22 DEL36 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL38 DEL36 DEL40 DEL27 DEL7 DEL21 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL4 DEL3 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL52 DEL42 DEL22 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL52 DEL42 DEL22 DEL32 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL61 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL41 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL33 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL61 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL27 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL61 DEL8 DEL51 DEL42 DEL41 DEL8 DEL31 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL43 DEL74 DEL42 DEL52 DEL42 DEL22 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL61 DEL42 DEL52 DEL42 DEL22 DEL32 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL61 DEL42 DEL42 DEL32 DEL42 DEL7 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL36 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL8 DEL51 DEL42 DEL33 DEL27 DEL8 DEL25 DEL8 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL43 DEL33 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL32 DEL21 DEL42 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL32 DEL21 DEL8 DEL51 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL52 DEL52 DEL52 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL70 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL52 DEL42 DEL22 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL70 DEL8 DEL83 DEL83 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL52 DEL42 DEL22 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL27 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL61 DEL8 DEL8 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL59 DEL60 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL83 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL52 DEL42 DEL22 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL61 DEL42 DEL43 DEL42 DEL44 DEL8 DEL8 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83 DEL83
GEODE-6515: refactor ConnectionManagerImpl (#3304)

Refactors the ConnectionManagerImpl to a non-locking implementation to allow gets to scale with more threads. The previous implementation locked around all logic for getting, creating, or returning a connection to the pool, which resulted in a high degree of contention for that lock.

Additionally, much of the logic for accounting for the number of total connections, and the dequeue of available connections have been extracted to ConnectionAccounting and AvailableConnectionManager respectively. This was done in order to add unit and concurrent tests for that logic.

* Refactor ConnectionManagerImpl to a non-locking implementation
* add unit tests for ConnectionManagerImpl
* update ConnectionManagerImpl Javadocs
* extract ConnectionAccounting from ConnectionManagerImpl
* add unit test for ConnectionAccounting
* add concurrency tests for ConnectionAccounting
* extract AvailableConnectionManager from ConnectionManagerImpl
* add unit tests for AvailableConnectionManager
* add concurrency tests for AvailableConnectionManager
* add unit test for ConcurrentTestRunner
* add javadocs to AvailableConnectionManager and improved the method names
* activate returns false if the connection has been destroyed instead of throwing ConnectionDestroyedException
* start background prefill if under the minimum number of connections in ConnectionManagerImpl#borrowConnection when create fails
* add generic <ServerLocation> to Set in ConnectionManagerImpl
* Correct invalidateServer logic in ConnectionManagerImpl
* make NOT_WAITING private in ConnectionManagerImpl
* made createLifetimeReplacementConnection private since it is only
used by ConnectionMap

Signed-off-by: Helena Bales <hbales@pivotal.io>
Signed-off-by: Jacob Barrett <jbarrett@pivotal.io>
Signed-off-by: Darrel Schneider <dschneider@pivotal.io>

+import java.util.ArrayList;
+import java.util.Collection;
+  default <T> Collection<Future<T>> inParallel(RunnableWithException runnable, int count) {
+    ArrayList<Future<T>> futures = new ArrayList<>(count);
+    for (; count > 0; count--) {
+      futures.add(inParallel(runnable));
+    }
+    return futures;
+  }
+
+

INS26 INS26 INS40 INS40 INS31 INS83 INS73 INS74 INS42 INS44 INS44 INS8 INS42 INS43 INS74 INS43 INS42 INS39 INS42 INS60 INS24 INS41 INS42 INS43 INS43 INS42 INS74 INS59 INS27 INS37 INS8 INS42 INS42 INS42 INS43 INS74 INS42 INS14 INS42 INS34 INS42 INS21 INS42 INS43 INS43 INS74 INS42 INS32 INS42 INS42 INS43 INS42 INS42 INS32 INS42 INS42 INS42
Merge branch 'release/1.8.0'

-import org.apache.geode.i18n.LogWriterI18n;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.LoggingThreadGroup;
+import org.apache.geode.internal.logging.LoggingThread;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+   * A value of Boolean.TRUE will identify a thread being used to execute
+   * disconnectListeners. {@link #addDisconnectListener} will not throw ShutdownException if the
+   * value is Boolean.TRUE.
+   */
+  final ThreadLocal<Boolean> isDisconnectThread = new ThreadLocal() {
+    @Override
+    public Boolean initialValue() {
+      return Boolean.FALSE;
+    }
+  };
+
+  /**
-   * A Constant that matches the ThreadGroup name of the shutdown hook. This constant is used to
-   * insure consistency with LoggingThreadGroup. Due to Bug 38407, be careful about moving this to
-   * another class.
+   * Due to Bug 38407, be careful about moving this to another class.
-        // bug44365 - logwriters accumulate, causing mem leak
-        LoggingThreadGroup.cleanUpThreadGroups();
-  public static LogWriterI18n getLoggerI18n() {
+  public static LogWriter getLogger() {
-      return sys.logWriter.convertToLogWriterI18n();
+      return sys.logWriter;
-      // bridge server and will need to enforce the member limit
+      // cache server and will need to enforce the member limit
-            LocalizedStrings.InternalDistributedSystem_PROBLEM_IN_INITIALIZING_KEYS_FOR_CLIENT_AUTHENTICATION
-                .toLocalizedString(),
+            "Problem in initializing keys for client authentication",
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT_WARN, size - avail));
+            logger.warn(
+                "System memory appears to be over committed by {} bytes.  You may experience instability, performance issues, or terminated processes due to the Linux OOM killer.",
+                size - avail);
-                LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT
-                    .toLocalizedString(avail, size));
+                String.format(
+                    "Insufficient free memory (%s) when attempting to lock %s bytes.  Either reduce the amount of heap or off-heap memory requested or free up additional system memory.  You may also specify -Dgemfire.Cache.ALLOW_MEMORY_OVERCOMMIT=true on the command-line to override the constraint check.",
+                    avail, size));
-            LocalizedStrings.InternalDistributedSystem_DISTRIBUTED_SYSTEM_HAS_DISCONNECTED
-                .toLocalizedString(),
+            "Distributed system has disconnected during startup.",
-        if (!quorumChecker.checkForQuorum(3 * this.config.getMemberTimeout())) {
+        if (!quorumChecker.checkForQuorum(3L * this.config.getMemberTimeout())) {
-          LocalizedStrings.InternalDistributedSystem_PROBLEM_STARTING_A_LOCATOR_SERVICE
-              .toLocalizedString(),
+          "Problem starting a locator service",
-          LocalizedStrings.InternalDistributedSystem_THIS_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_HAS_BEEN_DISCONNECTED
-              .toLocalizedString(),
+          "This connection to a distributed system has been disconnected.",
-        LocalizedStrings.InternalDistributedSystem_NORMAL_DISCONNECT.toLocalizedString(), false);
+        "normal disconnect", false);
-  private void runDisconnect(final DisconnectListener dc, ThreadGroup tg) {
+  private void runDisconnect(final DisconnectListener dc) {
-          disconnectListenerThread.set(Boolean.TRUE);
+          isDisconnectThread.set(Boolean.TRUE);
-    Thread t = new Thread(tg, r, dc.toString());
+    Thread t = new LoggingThread(dc.toString(), false, r);
-      logger.warn(
-          LocalizedMessage.create(
-              LocalizedStrings.InternalDistributedSystem_INTERRUPTED_WHILE_PROCESSING_DISCONNECT_LISTENER),
+      logger.warn("Interrupted while processing disconnect listener",
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.InternalDistributedSystem_DISCONNECT_LISTENER_STILL_RUNNING__0, dc));
+      logger.warn("Disconnect listener still running: {}", dc);
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.InternalDistributedSystem_DISCONNECT_LISTENER_IGNORED_ITS_INTERRUPT__0,
-            dc));
+        logger.warn("Disconnect listener ignored its interrupt: {}",
+            dc);
-  public boolean isDisconnectListenerThread() {
-    Boolean disconnectListenerThreadBoolean = (Boolean) this.disconnectListenerThread.get();
+  public boolean isDisconnectThread() {
+    return this.isDisconnectThread.get();
+  }
-    return disconnectListenerThreadBoolean != null
-        && disconnectListenerThreadBoolean.booleanValue();
+  public void setIsDisconnectThread() {
+    this.isDisconnectThread.set(Boolean.TRUE);
-   * @param tg the thread group to run the listener in
-  private void runDisconnectForReconnect(final DisconnectListener dc, ThreadGroup tg) {
+  private void runDisconnectForReconnect(final DisconnectListener dc) {
-   * A logging thread group for the disconnect and shutdown listeners
-   */
-  private final ThreadGroup disconnectListenerThreadGroup =
-      LoggingThreadGroup.createThreadGroup("Disconnect Listeners");
-
-  /**
-        runDisconnectForReconnect(listener, disconnectListenerThreadGroup);
+        runDisconnectForReconnect(listener);
-        runDisconnect(listener, disconnectListenerThreadGroup);
+        runDisconnect(listener);
-        logger.fatal(LocalizedMessage
-            .create(LocalizedStrings.InternalDistributedSystem_SHUTDOWNLISTENER__0__THREW, s), t);
+        logger.fatal(String.format("ShutdownListener < %s > threw...", s), t);
-      // Run the disconnect
-      runDisconnect(dcListener, disconnectListenerThreadGroup);
+      runDisconnect(dcListener);
-          logger.fatal(LocalizedMessage.create(
-              LocalizedStrings.InternalDistributedSystem_DISCONNECTLISTENERSHUTDOWN_THREW), t);
+          logger.fatal("DisconnectListener/Shutdown threw...", t);
-          getLogWriter().convertToLogWriterI18n()
-              .warning(LocalizedStrings.InternalDistributedSystem_DISCONNECT_WAIT_INTERRUPTED, e);
+          getLogWriter()
+              .warning("Disconnect wait interrupted", e);
-            disconnectListenerThread.set(Boolean.TRUE); // bug #42663 - this must be set while
-                                                        // closing the cache
+            isDisconnectThread.set(Boolean.TRUE); // bug #42663 - this must be set while
+                                                  // closing the cache
-                  LocalizedMessage.create(
-                      LocalizedStrings.InternalDistributedSystem_EXCEPTION_TRYING_TO_CLOSE_CACHE),
+                  "Exception trying to close cache",
-              disconnectListenerThread.set(Boolean.FALSE);
+              isDisconnectThread.set(Boolean.FALSE);
-      // NOTE: no logging after this point :-)
-
-      LoggingThreadGroup.cleanUpThreadGroups(); // bug35388 - logwriters accumulate, causing mem
-                                                // leak
-        LocalizedStrings.PureStatSampler_COULD_NOT_FIND_STATISTICS_INSTANCE.toLocalizedString());
+        "Could not find statistics instance");
-          sys.getLogWriter().convertToLogWriterI18n()
-              .severe(LocalizedStrings.InternalDistributedSystem_CONNECTLISTENER_THREW, t);
+          sys.getLogWriter()
+              .severe("ConnectListener threw...", t);
-        logger.fatal(LocalizedMessage
-            .create(LocalizedStrings.InternalDistributedSystem_CONNECTLISTENER_THREW), t);
+        logger.fatal("ConnectListener threw...", t);
-      Boolean disconnectListenerThreadBoolean = (Boolean) disconnectListenerThread.get();
+      boolean disconnectThreadBoolean = isDisconnectThread.get();
-      if (disconnectListenerThreadBoolean == null
-          || !disconnectListenerThreadBoolean.booleanValue()) {
+      if (!disconnectThreadBoolean) {
-              LocalizedStrings.InternalDistributedSystem_NO_LISTENERS_PERMITTED_AFTER_SHUTDOWN_0
-                  .toLocalizedString(reason),
+              String.format("No listeners permitted after shutdown: %s",
+                  reason),
-   * A non-null value of Boolean.TRUE will identify a thread being used to execute
-   * disconnectListeners. {@link #addDisconnectListener} will not throw ShutdownException if the
-   * value is Boolean.TRUE.
-   */
-  final ThreadLocal disconnectListenerThread = new ThreadLocal();
-
-  /**
-        LocalizedStrings.InternalDistributedSystem_NOT_IMPLEMENTED_YET.toLocalizedString());
+        "Not implemented yet");
-    ThreadGroup tg = LoggingThreadGroup.createThreadGroup(SHUTDOWN_HOOK_NAME);
-        tmp_shutdownHook = new Thread(tg, new Runnable() {
-          public void run() {
-            DistributedSystem ds = InternalDistributedSystem.getAnyInstance();
-            setThreadsSocketPolicy(true /* conserve sockets */);
-            if (ds != null && ds.isConnected()) {
-              LogWriterI18n log = ((InternalDistributedSystem) ds).getInternalLogWriter();
-              log.info(LocalizedStrings.InternalDistributedSystem_shutdownHook_shuttingdown);
-              DurableClientAttributes dca = ((InternalDistributedSystem) ds).getDistributedMember()
-                  .getDurableClientAttributes();
-              boolean isDurableClient = false;
+        tmp_shutdownHook = new LoggingThread(SHUTDOWN_HOOK_NAME, false, () -> {
+          DistributedSystem ds = InternalDistributedSystem.getAnyInstance();
+          setThreadsSocketPolicy(true /* conserve sockets */);
+          if (ds != null && ds.isConnected()) {
+            logger.info("VM is exiting - shutting down distributed system");
+            DurableClientAttributes dca = ((InternalDistributedSystem) ds).getDistributedMember()
+                .getDurableClientAttributes();
+            boolean isDurableClient = false;
-              if (dca != null) {
-                isDurableClient = (!(dca.getId() == null || dca.getId().isEmpty()));
-              }
-
-              ((InternalDistributedSystem) ds).disconnect(false,
-                  LocalizedStrings.InternalDistributedSystem_NORMAL_DISCONNECT.toLocalizedString(),
-                  isDurableClient/* keep alive drive from this */);
-              // this was how we wanted to do it for 5.7, but there were shutdown
-              // issues in PR/dlock (see bug 39287)
-              // InternalDistributedSystem ids = (InternalDistributedSystem)ds;
-              // if (ids.getDistributionManager() != null &&
-              // ids.getDistributionManager().getMembershipManager() != null) {
-              // ids.getDistributionManager().getMembershipManager()
-              // .uncleanShutdown("VM is exiting", null);
-              // }
+            if (dca != null) {
+              isDurableClient = (!(dca.getId() == null || dca.getId().isEmpty()));
+
+            ((InternalDistributedSystem) ds).disconnect(false,
+                "normal disconnect",
+                isDurableClient/* keep alive drive from this */);
+            // this was how we wanted to do it for 5.7, but there were shutdown
+            // issues in PR/dlock (see bug 39287)
+            // InternalDistributedSystem ids = (InternalDistributedSystem)ds;
+            // if (ids.getDistributionManager() != null &&
+            // ids.getDistributionManager().getMembershipManager() != null) {
+            // ids.getDistributionManager().getMembershipManager()
+            // .uncleanShutdown("VM is exiting", null);
+            // }
-        }, SHUTDOWN_HOOK_NAME);
+        });
-    // new Exception("stack trace"));
+    // new Exception("stack trace");
-                  LocalizedStrings.InternalDistributedSystem_SOME_REQUIRED_ROLES_MISSING
-                      .toLocalizedString());
+                  "Some required roles missing");
-                  LocalizedStrings.InternalDistributedSystem_SOME_REQUIRED_ROLES_MISSING
-                      .toLocalizedString());
+                  "Some required roles missing");
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.InternalDistributedSystem_WAITING_THREAD_FOR_RECONNECT_GOT_INTERRUPTED));
+          logger.warn("Waiting thread for reconnect got interrupted.");
-        logger.info(LocalizedMessage.create(LocalizedStrings.DISTRIBUTED_SYSTEM_RECONNECTING,
-            new Object[] {reconnectAttemptCounter}));
+        logger.info(
+            "Attempting to reconnect to the distributed system.  This is attempt #{}.",
+            reconnectAttemptCounter);
-        int savNumOfTries = reconnectAttemptCounter;
+        int saveNumberOfTries = reconnectAttemptCounter;
-            logger.warn(
-                LocalizedMessage.create(
-                    LocalizedStrings.InternalDistributedSystem_EXCEPTION_OCCURRED_WHILE_TRYING_TO_CONNECT_THE_SYSTEM_DURING_RECONNECT),
+            logger.warn("Exception occurred while trying to connect the system during reconnect",
-          logger.warn(
-              LocalizedMessage.create(
-                  LocalizedStrings.InternalDistributedSystem_EXCEPTION_OCCURRED_WHILE_TRYING_TO_CONNECT_THE_SYSTEM_DURING_RECONNECT),
+          logger.warn("Exception occurred while trying to connect the system during reconnect",
-          reconnectAttemptCounter = savNumOfTries;
+          reconnectAttemptCounter = saveNumberOfTries;
-              createAndStartCacheServers(cacheServerCreation, cache);
-
-              if (cache.getCachePerfStats().getReliableRegionsMissing() == 0) {
-                reconnectAttemptCounter = 0;
-              } else {
-                // this try failed. The new cache will call reconnect again
+              if (!cache.isClosed()) {
+                createAndStartCacheServers(cacheServerCreation, cache);
+                if (cache.getCachePerfStats().getReliableRegionsMissing() == 0) {
+                  reconnectAttemptCounter = 0;
+                }
+
+              // If this reconnect is for required-roles the algorithm is recursive and we
+              // shouldn't retry at this level
+              if (!forcedDisconnect) {
+                break;
+              }
-              logger.warn(
-                  LocalizedMessage.create(
-                      LocalizedStrings.InternalDistributedSystem_EXCEPTION_OCCURRED_WHILE_TRYING_TO_CREATE_THE_CACHE_DURING_RECONNECT),
+              logger.warn("Exception occurred while trying to create the cache during reconnect",
-            Thread.sleep(config.getMemberTimeout() * 3);
+            Thread.sleep(config.getMemberTimeout() * 3L);
-
-        notifyReconnectListeners(this, this.reconnectDS, false);
+        if (reconnectDS.isConnected()) {
+          notifyReconnectListeners(this, this.reconnectDS, false);
+        }
-    } else {
+    } else if (reconnectDS != null && reconnectDS.isConnected()) {
-            LocalizedStrings.CacheCreation_WHILE_STARTING_CACHE_SERVER_0.toLocalizedString(server),
+            String.format("While starting cache server %s", server),
-            LocalizedStrings.InternalDistributedSystem_A_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_ALREADY_EXISTS_IN_THIS_VM_IT_HAS_THE_FOLLOWING_CONFIGURATION_0
-                .toLocalizedString(sb.toString()));
+            String.format(
+                "A connection to a distributed system already exists in this VM.  It has the following configuration:%s",
+                sb.toString()));
-            LocalizedStrings.InternalDistributedSystem_A_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_ALREADY_EXISTS_IN_THIS_VM_IT_HAS_THE_FOLLOWING_CONFIGURATION_0
-                .toLocalizedString(sb.toString()),
+            String.format(
+                "A connection to a distributed system already exists in this VM.  It has the following configuration:%s",
+                sb.toString()),
-      return LocalizedStrings.InternalDistributedSystem_NO_DISTRIBUTION_MANAGER.toLocalizedString();
+      return "no distribution manager";
-    // new Exception("stack trace"));
+    // new Exception("stack trace");

UPD40 INS23 INS23 INS31 MOV29 INS83 INS74 INS59 INS29 INS83 MOV83 MOV83 MOV43 MOV59 UPD43 UPD42 UPD42 INS83 INS39 INS42 INS8 MOV43 MOV43 INS42 INS14 INS65 UPD42 INS41 INS21 UPD66 UPD66 MOV65 UPD66 INS66 MOV43 INS1 INS66 MOV43 INS32 INS32 INS25 INS31 INS45 MOV42 MOV22 MOV42 INS22 UPD42 MOV42 INS40 INS45 INS45 INS27 MOV8 MOV8 INS78 INS83 MOV43 INS42 INS8 INS40 INS43 INS9 UPD42 INS52 INS42 INS39 INS38 INS27 INS32 INS45 INS42 INS41 INS45 INS42 INS45 MOV42 UPD42 INS32 INS42 INS25 INS42 INS33 INS42 INS42 INS40 INS45 INS45 UPD42 MOV42 MOV42 INS32 INS8 INS45 MOV42 MOV14 INS45 INS42 UPD42 INS42 INS42 MOV21 MOV43 MOV43 MOV22 INS45 INS45 INS45 UPD43 INS42 INS9 INS86 MOV21 UPD42 INS42 INS45 UPD42 INS42 INS45 UPD34 UPD42 UPD42 INS45 MOV32 MOV32 UPD42 MOV8 UPD42 UPD42 INS42 INS45 MOV32 INS45 UPD42 INS45 INS42 UPD42 INS45 INS42 UPD42 INS42 INS45 INS45 MOV21 INS45 UPD42 UPD42 INS45 UPD42 UPD42 INS25 UPD42 INS42 INS45 INS45 INS38 INS8 INS25 UPD34 UPD42 MOV32 INS45 INS45 INS32 MOV21 MOV25 INS38 INS8 INS45 UPD42 INS45 UPD42 INS9 INS45 INS42 INS42 INS42 INS42 INS10 INS45 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL23 DEL42 DEL42 DEL32 DEL21 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL40 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL27 DEL41 DEL42 DEL66 DEL65 DEL42 DEL43 DEL42 DEL44 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL45 DEL32 DEL59 DEL23 DEL42 DEL42 DEL40 DEL42 DEL42 DEL42 DEL40 DEL32 DEL42 DEL40 DEL42 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL32 DEL21 DEL40 DEL42 DEL32 DEL42 DEL40 DEL42 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL43 DEL42 DEL43 DEL32 DEL11 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL38 DEL27 DEL40 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL14 DEL59 DEL23 DEL40 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL59 DEL60 DEL40 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL9 DEL40 DEL42 DEL32 DEL42 DEL32 DEL83 DEL39 DEL42 DEL31 DEL1 DEL42 DEL43 DEL42 DEL42 DEL14 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL32 DEL42 DEL42 DEL40 DEL32 DEL42 DEL42 DEL40 DEL32 DEL8 DEL42 DEL42 DEL40 DEL32 DEL40 DEL40 DEL40 DEL40 DEL42 DEL32
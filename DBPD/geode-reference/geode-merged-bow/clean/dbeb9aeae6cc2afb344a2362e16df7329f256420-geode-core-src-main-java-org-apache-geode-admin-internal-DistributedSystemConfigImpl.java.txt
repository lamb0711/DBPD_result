Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * An implementation of the configuration object for an
- * <code>AdminDistributedSystem</code>.  After a config has been used
- * to create an <code>AdminDistributedSystem</code> most of the
- * configuration attributes cannot be changed.  However, some
- * operations (such as getting information about GemFire managers and
- * distribution locators) are "passed through" to the
- * <code>AdminDistributedSystem</code> associated with this
- * configuration object.
+ * An implementation of the configuration object for an <code>AdminDistributedSystem</code>. After a
+ * config has been used to create an <code>AdminDistributedSystem</code> most of the configuration
+ * attributes cannot be changed. However, some operations (such as getting information about GemFire
+ * managers and distribution locators) are "passed through" to the
+ * <code>AdminDistributedSystem</code> associated with this configuration object.
-public class DistributedSystemConfigImpl
-    implements DistributedSystemConfig {
+public class DistributedSystemConfigImpl implements DistributedSystemConfig {
-   * Configs for the managed distribution locators in the distributed
-   * system
+   * Configs for the managed distribution locators in the distributed system
-   * The admin distributed system object that is configured by this
-   * config object.
+   * The admin distributed system object that is configured by this config object.
-   * @since GemFire 4.0 */
+   * @since GemFire 4.0
+   */
-  ///////////////////////  Static Methods  ///////////////////////
+  /////////////////////// Static Methods ///////////////////////
-   * Filters out all properties that are unique to the admin
-   * <code>DistributedSystemConfig</code> that are not present in the
-   * internal <code>DistributionConfig</code>.
+   * Filters out all properties that are unique to the admin <code>DistributedSystemConfig</code>
+   * that are not present in the internal <code>DistributionConfig</code>.
-  private static Properties
-  filterOutAdminProperties(Properties props) {
+  private static Properties filterOutAdminProperties(Properties props) {
-    for (Enumeration names = props.propertyNames();
-         names.hasMoreElements(); ) {
+    for (Enumeration names = props.propertyNames(); names.hasMoreElements();) {
-      if (!(ENTITY_CONFIG_XML_FILE_NAME.equals(name) ||
-          REFRESH_INTERVAL_NAME.equals(name) ||
-          REMOTE_COMMAND_NAME.equals(name)
-      )
-          ) {
+      if (!(ENTITY_CONFIG_XML_FILE_NAME.equals(name) || REFRESH_INTERVAL_NAME.equals(name)
+          || REMOTE_COMMAND_NAME.equals(name))) {
-  ////////////////////////  Constructors  ////////////////////////
+  //////////////////////// Constructors ////////////////////////
-   * Creates a new <code>DistributedSystemConfigImpl</code> based on
-   * the configuration stored in a <code>DistributedSystem</code>'s
-   * <code>DistributionConfig</code>.
+   * Creates a new <code>DistributedSystemConfigImpl</code> based on the configuration stored in a
+   * <code>DistributedSystem</code>'s <code>DistributionConfig</code>.
-  public DistributedSystemConfigImpl(DistributionConfig distConfig,
-      String remoteCommand) {
+  public DistributedSystemConfigImpl(DistributionConfig distConfig, String remoteCommand) {
-      throw new IllegalArgumentException(LocalizedStrings.DistributedSystemConfigImpl_DISTRIBUTIONCONFIG_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.DistributedSystemConfigImpl_DISTRIBUTIONCONFIG_MUST_NOT_BE_NULL
+              .toLocalizedString());
-    this.membershipPortRange =
-        getMembershipPortRangeString(distConfig.getMembershipPortRange());
+    this.membershipPortRange = getMembershipPortRangeString(distConfig.getMembershipPortRange());
-    this.logLevel =
-        LogWriterImpl.levelToString(distConfig.getLogLevel());
+    this.logLevel = LogWriterImpl.levelToString(distConfig.getLogLevel());
-   * Creates a new <code>DistributedSystemConifgImpl</code> whose
-   * configuration is specified by the given <code>Properties</code>
-   * object.
+   * Creates a new <code>DistributedSystemConifgImpl</code> whose configuration is specified by the
+   * given <code>Properties</code> object.
-   * Creates a new <code>DistributedSystemConifgImpl</code> whose configuration
-   * is specified by the given <code>Properties</code> object.
+   * Creates a new <code>DistributedSystemConifgImpl</code> whose configuration is specified by the
+   * given <code>Properties</code> object.
-   * @param props
-   *          The configuration properties specified by the caller
-   * @param ignoreGemFirePropsFile
-   *          whether to skip loading distributed system properties from
-   *          gemfire.properties file
-   *          
+   * @param props The configuration properties specified by the caller
+   * @param ignoreGemFirePropsFile whether to skip loading distributed system properties from
+   *        gemfire.properties file
+   * 
-  protected DistributedSystemConfigImpl(Properties props,
-      boolean ignoreGemFirePropsFile) {
-    this(new DistributionConfigImpl(
-            filterOutAdminProperties(props), ignoreGemFirePropsFile),
+  protected DistributedSystemConfigImpl(Properties props, boolean ignoreGemFirePropsFile) {
+    this(new DistributionConfigImpl(filterOutAdminProperties(props), ignoreGemFirePropsFile),
-    String entityConfigXMLFile =
-        props.getProperty(ENTITY_CONFIG_XML_FILE_NAME);
+    String entityConfigXMLFile = props.getProperty(ENTITY_CONFIG_XML_FILE_NAME);
-    String refreshInterval =
-        props.getProperty(REFRESH_INTERVAL_NAME);
+    String refreshInterval = props.getProperty(REFRESH_INTERVAL_NAME);
-            LocalizedStrings.DistributedSystemConfigImpl_0_IS_NOT_A_VALID_INTEGER_1.toLocalizedString(new Object[] { refreshInterval, REFRESH_INTERVAL_NAME }));
+            LocalizedStrings.DistributedSystemConfigImpl_0_IS_NOT_A_VALID_INTEGER_1
+                .toLocalizedString(new Object[] {refreshInterval, REFRESH_INTERVAL_NAME}));
-  //////////////////////  Instance Methods  //////////////////////
+  ////////////////////// Instance Methods //////////////////////
-   * Returns the <code>LogWriterI18n</code> to be used when administering
-   * the distributed system. Returns null if nothing has been provided via
-   * <code>setInternalLogWriter</code>.
+   * Returns the <code>LogWriterI18n</code> to be used when administering the distributed system.
+   * Returns null if nothing has been provided via <code>setInternalLogWriter</code>.
-    // LOG: used only for sharing between IDS, AdminDSImpl and AgentImpl -- to prevent multiple banners, etc.
+    // LOG: used only for sharing between IDS, AdminDSImpl and AgentImpl -- to prevent multiple
+    // banners, etc.
-   * Sets the <code>LogWriterI18n</code> to be used when administering the
-   * distributed system.
+   * Sets the <code>LogWriterI18n</code> to be used when administering the distributed system.
-    // LOG: used only for sharing between IDS, AdminDSImpl and AgentImpl -- to prevent multiple banners, etc.
+    // LOG: used only for sharing between IDS, AdminDSImpl and AgentImpl -- to prevent multiple
+    // banners, etc.
-   * Marks this config object as "read only".  Attempts to modify a
-   * config object will result in a {@link IllegalStateException}
-   * being thrown.
+   * Marks this config object as "read only". Attempts to modify a config object will result in a
+   * {@link IllegalStateException} being thrown.
-   * Checks to see if this config object is "read only".  If it is,
-   * then an {@link IllegalStateException} is thrown.
+   * Checks to see if this config object is "read only". If it is, then an
+   * {@link IllegalStateException} is thrown.
-   * Parses the XML configuration file that describes managed
-   * entities.
+   * Parses the XML configuration file that describes managed entities.
-        throw new AdminXmlException(LocalizedStrings.DistributedSystemConfigImpl_ENTITY_CONFIGURATION_XML_FILE_0_DOES_NOT_EXIST.toLocalizedString(fileName));
+        throw new AdminXmlException(
+            LocalizedStrings.DistributedSystemConfigImpl_ENTITY_CONFIGURATION_XML_FILE_0_DOES_NOT_EXIST
+                .toLocalizedString(fileName));
-      throw new AdminXmlException(LocalizedStrings.DistributedSystemConfigImpl_WHILE_PARSING_0.toLocalizedString(fileName), ex);
+      throw new AdminXmlException(
+          LocalizedStrings.DistributedSystemConfigImpl_WHILE_PARSING_0.toLocalizedString(fileName),
+          ex);
-   * @param membershipPortRangeStr the value for membership-port-range given as two numbers separated
-   *                               by a minus sign.
+   * @param membershipPortRangeStr the value for membership-port-range given as two numbers
+   *        separated by a minus sign.
-     * FIXME: Setting attributes in DistributedSystemConfig has no effect on
-     * DistributionConfig which is actually used for connection with DS. This is
-     * true for all such attributes. Should be addressed in the Admin Revamp if 
-     * we want these 'set' calls to affect anything. Then we can use the 
-     * validation code in DistributionConfigImpl code.
+     * FIXME: Setting attributes in DistributedSystemConfig has no effect on DistributionConfig
+     * which is actually used for connection with DS. This is true for all such attributes. Should
+     * be addressed in the Admin Revamp if we want these 'set' calls to affect anything. Then we can
+     * use the validation code in DistributionConfigImpl code.
-                  .toLocalizedString(new Object[] { membershipPortRangeStr,
-                      MEMBERSHIP_PORT_RANGE_NAME }));
+                  .toLocalizedString(
+                      new Object[] {membershipPortRangeStr, MEMBERSHIP_PORT_RANGE_NAME}));
-   * Validates the given string - which is expected in the format as two numbers
-   * separated by a minus sign - in to an integer array of length 2 with first
-   * element as lower end & second element as upper end of the range.
+   * Validates the given string - which is expected in the format as two numbers separated by a
+   * minus sign - in to an integer array of length 2 with first element as lower end & second
+   * element as upper end of the range.
-   *                            sign.
+   *        sign.
-      //NumberFormatException if any could be thrown
+      // NumberFormatException if any could be thrown
-      if (range[0] < 0 || range[0] >= range[1] ||
-          range[1] < 0 || range[1] > 65535) {
+      if (range[0] < 0 || range[0] >= range[1] || range[1] < 0 || range[1] > 65535) {
-   * @return the String representation of membershipPortRange with lower & upper
-   * limits of the port range separated by '-' e.g. 1-65535
+   * @return the String representation of membershipPortRange with lower & upper limits of the port
+   *         range separated by '-' e.g. 1-65535
-    if (membershipPortRange != null &&
-        membershipPortRange.length == 2) {
-      membershipPortRangeString = membershipPortRange[0] + "-" +
-          membershipPortRange[1];
+    if (membershipPortRange != null && membershipPortRange.length == 2) {
+      membershipPortRangeString = membershipPortRange[0] + "-" + membershipPortRange[1];
-      throw new IllegalArgumentException(LocalizedStrings.DistributedSystemConfigImpl_INVALID_BIND_ADDRESS_0.toLocalizedString(bindAddress));
+      throw new IllegalArgumentException(
+          LocalizedStrings.DistributedSystemConfigImpl_INVALID_BIND_ADDRESS_0
+              .toLocalizedString(bindAddress));
-      throw new IllegalArgumentException(LocalizedStrings.DistributedSystemConfigImpl_INVALID_BIND_ADDRESS_0.toLocalizedString(bindAddress));
+      throw new IllegalArgumentException(
+          LocalizedStrings.DistributedSystemConfigImpl_INVALID_BIND_ADDRESS_0
+              .toLocalizedString(bindAddress));
-   * Sets the remote command for this config object.  This attribute
-   * may be modified after this config object has been used to create
-   * an admin distributed system.
+   * Sets the remote command for this config object. This attribute may be modified after this
+   * config object has been used to create an admin distributed system.
-  private static final boolean ALLOW_ALL_REMOTE_COMMANDS = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "admin.ALLOW_ALL_REMOTE_COMMANDS");
-  private static final String[] LEGAL_REMOTE_COMMANDS = { "rsh", "ssh" };
-  private static final String ILLEGAL_REMOTE_COMMAND_RSH_OR_SSH = "Allowed remote commands include \"rsh {HOST} {CMD}\" or \"ssh {HOST} {CMD}\" with valid rsh or ssh switches. Invalid: ";
+  private static final boolean ALLOW_ALL_REMOTE_COMMANDS =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "admin.ALLOW_ALL_REMOTE_COMMANDS");
+  private static final String[] LEGAL_REMOTE_COMMANDS = {"rsh", "ssh"};
+  private static final String ILLEGAL_REMOTE_COMMAND_RSH_OR_SSH =
+      "Allowed remote commands include \"rsh {HOST} {CMD}\" or \"ssh {HOST} {CMD}\" with valid rsh or ssh switches. Invalid: ";
-            if (!(string.endsWith(LEGAL_REMOTE_COMMANDS[j]) || string.endsWith(LEGAL_REMOTE_COMMANDS[j] + ".exe"))) {
+            if (!(string.endsWith(LEGAL_REMOTE_COMMANDS[j])
+                || string.endsWith(LEGAL_REMOTE_COMMANDS[j] + ".exe"))) {
-        // additional elements must be switches or values-for-switches or {host} or user@{host} or {cmd}
+        // additional elements must be switches or values-for-switches or {host} or user@{host} or
+        // {cmd}
-          final String previous = (array == null || array.isEmpty()) ? null : array.get(array.size() - 1);
+          final String previous =
+              (array == null || array.isEmpty()) ? null : array.get(array.size() - 1);
-   * Returns an array of configurations for statically known
-   * CacheServers
+   * Returns an array of configurations for statically known CacheServers
-   */ 
+   */
-    return (CacheServerConfig[]) this.cacheServerConfigs.toArray(
-        new CacheServerConfig[this.cacheServerConfigs.size()]);
+    return (CacheServerConfig[]) this.cacheServerConfigs
+        .toArray(new CacheServerConfig[this.cacheServerConfigs.size()]);
-    return (CacheVmConfig[]) this.cacheServerConfigs.toArray(new CacheVmConfig[this.cacheServerConfigs.size()]);
+    return (CacheVmConfig[]) this.cacheServerConfigs
+        .toArray(new CacheVmConfig[this.cacheServerConfigs.size()]);
-    for (Iterator iter = this.cacheServerConfigs.iterator(); iter.hasNext(); ) {
+    for (Iterator iter = this.cacheServerConfigs.iterator(); iter.hasNext();) {
-      DistributionLocator[] locators =
-          this.system.getDistributionLocators();
-      DistributionLocatorConfig[] configs =
-          new DistributionLocatorConfig[locators.length];
+      DistributionLocator[] locators = this.system.getDistributionLocators();
+      DistributionLocatorConfig[] configs = new DistributionLocatorConfig[locators.length];
-      Object[] array =
-          new DistributionLocatorConfig[this.locatorConfigs.size()];
+      Object[] array = new DistributionLocatorConfig[this.locatorConfigs.size()];
-   * Validates the bind address.  The address may be a host name or IP address,
-   * but it must not be empty and must be usable for creating an InetAddress.
-   * Cannot have a leading '/' (which InetAddress.toString() produces).
+   * Validates the bind address. The address may be a host name or IP address, but it must not be
+   * empty and must be usable for creating an InetAddress. Cannot have a leading '/' (which
+   * InetAddress.toString() produces).
-      clients = (ConfigListener[])
-          listeners.toArray(new ConfigListener[this.listeners.size()]);
+      clients = (ConfigListener[]) listeners.toArray(new ConfigListener[this.listeners.size()]);
-  //   SSL support...
+  // SSL support...
-  private boolean sslEnabled =
-      DistributionConfig.DEFAULT_SSL_ENABLED;
-  private String sslProtocols =
-      DistributionConfig.DEFAULT_SSL_PROTOCOLS;
-  private String sslCiphers =
-      DistributionConfig.DEFAULT_SSL_CIPHERS;
-  private boolean sslAuthenticationRequired =
-      DistributionConfig.DEFAULT_SSL_REQUIRE_AUTHENTICATION;
+  private boolean sslEnabled = DistributionConfig.DEFAULT_SSL_ENABLED;
+  private String sslProtocols = DistributionConfig.DEFAULT_SSL_PROTOCOLS;
+  private String sslCiphers = DistributionConfig.DEFAULT_SSL_CIPHERS;
+  private boolean sslAuthenticationRequired = DistributionConfig.DEFAULT_SSL_REQUIRE_AUTHENTICATION;
-   * Makes sure that the mcast port and locators are correct and
-   * consistent.
+   * Makes sure that the mcast port and locators are correct and consistent.
-    if (this.getMcastPort() < MIN_MCAST_PORT ||
-        this.getMcastPort() > MAX_MCAST_PORT) {
-      throw new IllegalArgumentException(LocalizedStrings.DistributedSystemConfigImpl_MCASTPORT_MUST_BE_AN_INTEGER_INCLUSIVELY_BETWEEN_0_AND_1
-          .toLocalizedString(new Object[] { Integer.valueOf(MIN_MCAST_PORT), Integer.valueOf(MAX_MCAST_PORT) }));
+    if (this.getMcastPort() < MIN_MCAST_PORT || this.getMcastPort() > MAX_MCAST_PORT) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.DistributedSystemConfigImpl_MCASTPORT_MUST_BE_AN_INTEGER_INCLUSIVELY_BETWEEN_0_AND_1
+              .toLocalizedString(
+                  new Object[] {Integer.valueOf(MIN_MCAST_PORT), Integer.valueOf(MAX_MCAST_PORT)}));
-    //if (!DEFAULT_LOCATORS.equals(this.getLocators()) &&
-    //    this.mcastPort > 0) { 
-    //  throw new IllegalArgumentException(
-    //    "mcastPort must be zero when locators are specified");
-    //}
+    // if (!DEFAULT_LOCATORS.equals(this.getLocators()) &&
+    // this.mcastPort > 0) {
+    // throw new IllegalArgumentException(
+    // "mcastPort must be zero when locators are specified");
+    // }
-    if (this.logFileSizeLimit < MIN_LOG_FILE_SIZE_LIMIT ||
-        this.logFileSizeLimit > MAX_LOG_FILE_SIZE_LIMIT) {
-      throw new IllegalArgumentException(LocalizedStrings.DistributedSystemConfigImpl_LOGFILESIZELIMIT_MUST_BE_AN_INTEGER_BETWEEN_0_AND_1
-          .toLocalizedString(new Object[] { Integer.valueOf(MIN_LOG_FILE_SIZE_LIMIT), Integer.valueOf(MAX_LOG_FILE_SIZE_LIMIT) }));
+    if (this.logFileSizeLimit < MIN_LOG_FILE_SIZE_LIMIT
+        || this.logFileSizeLimit > MAX_LOG_FILE_SIZE_LIMIT) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.DistributedSystemConfigImpl_LOGFILESIZELIMIT_MUST_BE_AN_INTEGER_BETWEEN_0_AND_1
+              .toLocalizedString(new Object[] {Integer.valueOf(MIN_LOG_FILE_SIZE_LIMIT),
+                  Integer.valueOf(MAX_LOG_FILE_SIZE_LIMIT)}));
-    if (this.logDiskSpaceLimit < MIN_LOG_DISK_SPACE_LIMIT ||
-        this.logDiskSpaceLimit > MAX_LOG_DISK_SPACE_LIMIT) {
-      throw new IllegalArgumentException(LocalizedStrings.DistributedSystemConfigImpl_LOGDISKSPACELIMIT_MUST_BE_AN_INTEGER_BETWEEN_0_AND_1
-          .toLocalizedString(new Object[] { Integer.valueOf(MIN_LOG_DISK_SPACE_LIMIT), Integer.valueOf(MAX_LOG_DISK_SPACE_LIMIT) }));
+    if (this.logDiskSpaceLimit < MIN_LOG_DISK_SPACE_LIMIT
+        || this.logDiskSpaceLimit > MAX_LOG_DISK_SPACE_LIMIT) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.DistributedSystemConfigImpl_LOGDISKSPACELIMIT_MUST_BE_AN_INTEGER_BETWEEN_0_AND_1
+              .toLocalizedString(new Object[] {Integer.valueOf(MIN_LOG_DISK_SPACE_LIMIT),
+                  Integer.valueOf(MAX_LOG_DISK_SPACE_LIMIT)}));
-    DistributedSystemConfigImpl other =
-        (DistributedSystemConfigImpl) super.clone();
+    DistributedSystemConfigImpl other = (DistributedSystemConfigImpl) super.clone();
-    DistributionLocatorConfig[] myLocators =
-        this.getDistributionLocatorConfigs();
+    DistributionLocatorConfig[] myLocators = this.getDistributionLocatorConfigs();

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+
-  public CompiledGroupBySelect(boolean distinct, boolean count,
-      CompiledValue whereClause, List iterators, List projAttrs,
-      List<CompiledSortCriterion> orderByAttrs, CompiledValue limit,
+  public CompiledGroupBySelect(boolean distinct, boolean count, CompiledValue whereClause,
+      List iterators, List projAttrs, List<CompiledSortCriterion> orderByAttrs, CompiledValue limit,
-    super(false, false, whereClause, iterators, projAttrs, null,null,
-        hints, groupByClause);
-    this.aggregateFunctions = new CompiledAggregateFunction[aggMap != null ? aggMap
-        .size() : 0];
+    super(false, false, whereClause, iterators, projAttrs, null, null, hints, groupByClause);
+    this.aggregateFunctions = new CompiledAggregateFunction[aggMap != null ? aggMap.size() : 0];
-      for (Map.Entry<Integer, CompiledAggregateFunction> entry : aggMap
-          .entrySet()) {
+      for (Map.Entry<Integer, CompiledAggregateFunction> entry : aggMap.entrySet()) {
-      throws TypeMismatchException, AmbiguousNameException,
-      NameResolutionException {
+      throws TypeMismatchException, AmbiguousNameException, NameResolutionException {
-      if (param == null
-          && aggFunc.getFunctionType() == OQLLexerTokenTypes.COUNT) {
+      if (param == null && aggFunc.getFunctionType() == OQLLexerTokenTypes.COUNT) {
-        throw new QueryInvalidException(
-            "aggregate function passed invalid parameter");
+        throw new QueryInvalidException("aggregate function passed invalid parameter");
-  
+
-      bitStart = index + 1;      
+      bitStart = index + 1;
-      throws AmbiguousNameException, TypeMismatchException,
-      NameResolutionException {
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-      if(this.originalOrderByClause != null) {
+      if (this.originalOrderByClause != null) {
-  
+
-      throws AmbiguousNameException, TypeMismatchException,
-      NameResolutionException {
-      this.revertAggregateFunctionInProjection();
-      Iterator<CompiledSortCriterion> iter = this.originalOrderByClause.iterator();
-      while (iter.hasNext()) {
-        CompiledSortCriterion csc = iter.next();       
-        if (!csc.mapExpressionToProjectionField(this.projAttrs, context)) {          
-          throw new QueryInvalidException(LocalizedStrings.DefaultQuery_ORDER_BY_ATTRIBS_NOT_PRESENT_IN_PROJ.toLocalizedString());
-        }
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+    this.revertAggregateFunctionInProjection();
+    Iterator<CompiledSortCriterion> iter = this.originalOrderByClause.iterator();
+    while (iter.hasNext()) {
+      CompiledSortCriterion csc = iter.next();
+      if (!csc.mapExpressionToProjectionField(this.projAttrs, context)) {
+        throw new QueryInvalidException(
+            LocalizedStrings.DefaultQuery_ORDER_BY_ATTRIBS_NOT_PRESENT_IN_PROJ.toLocalizedString());
-      this.replaceAggregateFunctionInProjection();
-    
+    }
+    this.replaceAggregateFunctionInProjection();
+
-  public SelectResults evaluate(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  public SelectResults evaluate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-  public SelectResults applyAggregateAndGroupBy(SelectResults baseResults,
-      ExecutionContext context) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+  public SelectResults applyAggregateAndGroupBy(SelectResults baseResults, ExecutionContext context)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-    boolean[] objectChangedMarker = new boolean[]{false};
+    boolean[] objectChangedMarker = new boolean[] {false};
-    SelectResults newResults = createResultSet(context, elementType, isStruct,
-        createOrderedResultSet);
+    SelectResults newResults =
+        createResultSet(context, elementType, isStruct, createOrderedResultSet);
-      applyGroupBy(baseResults, context, isStruct, newResults, aggregators,
-          !createOrderedResultSet, objectChangedMarker, limitValue);
+      applyGroupBy(baseResults, context, isStruct, newResults, aggregators, !createOrderedResultSet,
+          objectChangedMarker, limitValue);
-        this.terminateAndAddToResults(isStruct, newResults, aggregators,
-            current, context, !createOrderedResultSet, limitValue);
+        this.terminateAndAddToResults(isStruct, newResults, aggregators, current, context,
+            !createOrderedResultSet, limitValue);
-   
+
-  private SelectResults createResultSet(ExecutionContext context,
-      ObjectType elementType, boolean isStruct, boolean createOrderedResults) {
+  private SelectResults createResultSet(ExecutionContext context, ObjectType elementType,
+      boolean isStruct, boolean createOrderedResults) {
-    
-    //boolean isBucketNodes = context.getBucketList() != null;
+
+    // boolean isBucketNodes = context.getBucketList() != null;
-      } else {    
-        if(this.originalOrderByClause != null) {
-          Comparator comparator = new OrderByComparator(this.originalOrderByClause, elementType, context);
-          newResults = new SortedStructBag(comparator, (StructType)elementType,
+      } else {
+        if (this.originalOrderByClause != null) {
+          Comparator comparator =
+              new OrderByComparator(this.originalOrderByClause, elementType, context);
+          newResults = new SortedStructBag(comparator, (StructType) elementType,
-        }else {
-          newResults = QueryUtils.createStructCollection(this.isDistinct,
-            (StructType) elementType, context);
+        } else {
+          newResults =
+              QueryUtils.createStructCollection(this.isDistinct, (StructType) elementType, context);
-        if(this.originalOrderByClause != null) {
-          Comparator comparator = new OrderByComparator(this.originalOrderByClause, elementType, context);
-          newResults = new SortedResultsBag(comparator,elementType,
+        if (this.originalOrderByClause != null) {
+          Comparator comparator =
+              new OrderByComparator(this.originalOrderByClause, elementType, context);
+          newResults = new SortedResultsBag(comparator, elementType,
-        }else {
-          newResults = QueryUtils.createResultCollection(this.isDistinct,
-               elementType, context);
+        } else {
+          newResults = QueryUtils.createResultCollection(this.isDistinct, elementType, context);
-       
+
-  private ObjectType createNewElementType(ObjectType elementType,
-      boolean isStruct) {
+  private ObjectType createNewElementType(ObjectType elementType, boolean isStruct) {
-            newFieldTypes[i] = this.aggregateFunctions[aggFuncIndex++]
-                .getObjectType();
+            newFieldTypes[i] = this.aggregateFunctions[aggFuncIndex++].getObjectType();
-      return this.aggregateFunctions.length > 0 ? this.aggregateFunctions[0]
-          .getObjectType() : elementType;
+      return this.aggregateFunctions.length > 0 ? this.aggregateFunctions[0].getObjectType()
+          : elementType;
-  private void applyGroupBy(SelectResults baseResults,
-      ExecutionContext context, boolean isStruct, SelectResults newResults,
-      Aggregator[] aggregators, boolean isStructFields, boolean[] objectChangedMarker,
-       int limitValue)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  private void applyGroupBy(SelectResults baseResults, ExecutionContext context, boolean isStruct,
+      SelectResults newResults, Aggregator[] aggregators, boolean isStructFields,
+      boolean[] objectChangedMarker, int limitValue) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-   
+
-        orderByCurrent = this.getOrderByEvaluatedTuple(context,
-            isSingleOrderBy, null,
+        orderByCurrent = this.getOrderByEvaluatedTuple(context, isSingleOrderBy, null,
-        orderByTupleHolderCurrent = (Object[]) this.getOrderByEvaluatedTuple(
-            context, isSingleOrderBy, orderByTupleHolderCurrent,
+        orderByTupleHolderCurrent = (Object[]) this.getOrderByEvaluatedTuple(context,
+            isSingleOrderBy, orderByTupleHolderCurrent,
-      if (isFirst
-          || areOrderByTupleEqual(isSingleOrderBy, orderByPrev, orderByCurrent,
-              orderByTupleHolderPrev, orderByTupleHolderCurrent)) {
+      if (isFirst || areOrderByTupleEqual(isSingleOrderBy, orderByPrev, orderByCurrent,
+          orderByTupleHolderPrev, orderByTupleHolderCurrent)) {
-        keepAdding = terminateAndAddToResults(isStruct, newResults, aggregators, prev,
-            context, isStructFields, limitValue);
+        keepAdding = terminateAndAddToResults(isStruct, newResults, aggregators, prev, context,
+            isStructFields, limitValue);
-      this.terminateAndAddToResults(isStruct, newResults, aggregators, prev,
-          context, isStructFields, limitValue);
+      this.terminateAndAddToResults(isStruct, newResults, aggregators, prev, context,
+          isStructFields, limitValue);
-    
-    if(this.originalOrderByClause != null && limitValue > 0
-        && (context.getIsPRQueryNode() || context.getBucketList() == null)
-        ) {
-      ((Bag)newResults).applyLimit(limitValue);
+
+    if (this.originalOrderByClause != null && limitValue > 0
+        && (context.getIsPRQueryNode() || context.getBucketList() == null)) {
+      ((Bag) newResults).applyLimit(limitValue);
-  private boolean terminateAndAddToResults(boolean isStruct,
-      SelectResults newResults, Aggregator[] aggregators, Object prev,
-      ExecutionContext context, boolean isStrucFields, int limitValue)
-      throws FunctionDomainException, TypeMismatchException,
+  private boolean terminateAndAddToResults(boolean isStruct, SelectResults newResults,
+      Aggregator[] aggregators, Object prev, ExecutionContext context, boolean isStrucFields,
+      int limitValue) throws FunctionDomainException, TypeMismatchException,
-    if(limitValue == 0) {
+    if (limitValue == 0) {
-    
+
-    
+
-        newResults.add(new StructImpl((StructTypeImpl) ((Struct) prev)
-            .getStructType(), newRowArray));
+        newResults
+            .add(new StructImpl((StructTypeImpl) ((Struct) prev).getStructType(), newRowArray));
-    if(this.originalOrderByClause == null && limitValue > 0
+    if (this.originalOrderByClause == null && limitValue > 0
-  private void refreshAggregators(Aggregator[] aggregators,
-      ExecutionContext context) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+  private void refreshAggregators(Aggregator[] aggregators, ExecutionContext context)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-  private void accumulate(boolean isStruct, Aggregator[] aggregators,
-      Object current, boolean[] objectChangedMarker) {
+  private void accumulate(boolean isStruct, Aggregator[] aggregators, Object current,
+      boolean[] objectChangedMarker) {
-        Object scalar = PDXUtils.convertPDX(struct.getFieldValues()[pos], false, true, true, true, objectChangedMarker, isStruct);
-        
+        Object scalar = PDXUtils.convertPDX(struct.getFieldValues()[pos], false, true, true, true,
+            objectChangedMarker, isStruct);
+
-        current =   PDXUtils.convertPDX(current, false, true, true, true, objectChangedMarker, isStruct);
+        current =
+            PDXUtils.convertPDX(current, false, true, true, true, objectChangedMarker, isStruct);
-  private boolean areOrderByTupleEqual(boolean isSingleOrderBy, Object prev,
-      Object current, Object[] prevHolder, Object[] currentHolder) {
+  private boolean areOrderByTupleEqual(boolean isSingleOrderBy, Object prev, Object current,
+      Object[] prevHolder, Object[] currentHolder) {
-  private Object getOrderByEvaluatedTuple(ExecutionContext context,
-      boolean isOrderByTupleSingle, Object[] holder, Object data, boolean[] objectChangedMarker) {
+  private Object getOrderByEvaluatedTuple(ExecutionContext context, boolean isOrderByTupleSingle,
+      Object[] holder, Object data, boolean[] objectChangedMarker) {
-      return  PDXUtils.convertPDX(this.orderByAttrs.get(0).evaluate(data, context), 
-          false, true, true, true, objectChangedMarker, false);
+      return PDXUtils.convertPDX(this.orderByAttrs.get(0).evaluate(data, context), false, true,
+          true, true, objectChangedMarker, false);
-        holder[i++] = PDXUtils.convertPDX(csc.evaluate(data, context), false, true, true, true, objectChangedMarker, false); 
+        holder[i++] = PDXUtils.convertPDX(csc.evaluate(data, context), false, true, true, true,
+            objectChangedMarker, false);
-      throws AmbiguousNameException, TypeMismatchException,
-      NameResolutionException {
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-              LocalizedStrings.DefaultQuery_PROJ_COL_ABSENT_IN_GROUP_BY
-                  .toLocalizedString());
+              LocalizedStrings.DefaultQuery_PROJ_COL_ABSENT_IN_GROUP_BY.toLocalizedString());
-            LocalizedStrings.DefaultQuery_GROUP_BY_COL_ABSENT_IN_PROJ
-                .toLocalizedString());
+            LocalizedStrings.DefaultQuery_GROUP_BY_COL_ABSENT_IN_PROJ.toLocalizedString());
-  private boolean checkProjectionInGroupBy(Object[] projElem,
-      ExecutionContext context) throws AmbiguousNameException,
-      TypeMismatchException, NameResolutionException {
+  private boolean checkProjectionInGroupBy(Object[] projElem, ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-    CompiledValue cvProj = (CompiledValue) TypeUtils.checkCast(projElem[1],
-        CompiledValue.class);
+    CompiledValue cvProj = (CompiledValue) TypeUtils.checkCast(projElem[1], CompiledValue.class);
-          if (projElem[0] != null
-              && projElem[0].equals(((CompiledID) grpBy).getId())) {
+          if (projElem[0] != null && projElem[0].equals(((CompiledID) grpBy).getId())) {


GEODE-7582: Update initlocator list (#4488)

* GEODE-7582: Update initlocator list

* GEODE-7582: update after rebase

* GEODE-7582: Updated initialLocators list

* GEODE-7582: Update LocatorAddress

* GEODE-7582: update of LocatorAddress after comments

* GEODE-7582: Update solution

* GEODE-7582: removed unused methods and tests

* GEODE-7582: added test for LocatorAddress

* GEODE-7582: added more tests

* GEODE-7582: update dependencies

* GEODE-7582: update tests after comments

+import java.util.Objects;
-  private final String hostname;
-  private final int port;
-  private final boolean isIpString;
-    this.socketInetAddress = loc;
-    this.hostname = locStr;
-    this.port = loc.getPort();
-    this.isIpString = InetAddressValidator.getInstance().isValid(locStr);
-  }
-
-  public boolean isIpString() {
-    return isIpString;
+    if (InetAddressValidator.getInstance().isValid(locStr)) {
+      socketInetAddress = new InetSocketAddress(locStr, loc.getPort());
+    } else {
+      socketInetAddress = cloneUnresolved(loc);
+    }
-   * if host is ipString then it will return the cached InetSocketAddress Otherwise it will create
-   * the new instance of InetSocketAddress
+   * @deprecated Users should not care if literal IP or hostname is used.
+   */
+  @Deprecated
+  public boolean isIpString() {
+    return !socketInetAddress.isUnresolved();
+  }
+
+  /**
+   * If location is not litteral IP address a new resolved {@link InetSocketAddress} is returned.
+   *
+   * @return resolved {@link InetSocketAddress}, otherwise stored {@link InetSocketAddress} if
+   *         literal IP address is used.
-    if (this.isIpString) {
-      return this.socketInetAddress;
+    if (socketInetAddress.isUnresolved()) {
+      return new InetSocketAddress(socketInetAddress.getHostString(), socketInetAddress.getPort());
-      return new InetSocketAddress(hostname, this.socketInetAddress.getPort());
+      return this.socketInetAddress;
-    return hostname;
+    return socketInetAddress.getHostString();
-    return port;
-  }
-
-  /**
-   * If component has retry logic then use this method to get the InetSocketAddress address
-   * AutoConnectionSourceImpl for client has retry logic; This way client will not make DNS query
-   * each time
-   *
-   */
-  public InetSocketAddress getSocketInetAddressNoLookup() {
-    return this.socketInetAddress;
+    return socketInetAddress.getPort();
-    int prime = 31;
-    int result = 1;
-    result = prime * result + (isIpString ? 1231 : 1237);
-    result = prime * result + (socketInetAddress == null ? 0 : socketInetAddress.hashCode());
-    result = prime * result + (hostname == null ? 0 : hostname.hashCode());
-    return result;
+    return socketInetAddress.hashCode();
-  public boolean equals(Object obj) {
-    if (this == obj)
+  public boolean equals(Object o) {
+    if (this == o) {
-    if (obj == null)
+    }
+    if (o == null || getClass() != o.getClass()) {
-    if (getClass() != obj.getClass())
-      return false;
-    LocatorAddress other = (LocatorAddress) obj;
-    if (isIpString != other.isIpString)
-      return false;
-    if (socketInetAddress == null) {
-      if (other.socketInetAddress != null)
-        return false;
-    } else if (!socketInetAddress.equals(other.socketInetAddress))
-      return false;
-    if (hostname == null) {
-      if (other.hostname != null)
-        return false;
-    } else if (!hostname.equals(other.hostname))
-      return false;
-    return true;
+    }
+    LocatorAddress that = (LocatorAddress) o;
+    return Objects.equals(socketInetAddress, that.socketInetAddress);
-    return getClass().getSimpleName()
-        + " [socketInetAddress=" + socketInetAddress + ", hostname=" + hostname
-        + ", isIpString=" + isIpString + "]";
+    return getClass().getSimpleName() + " [socketInetAddress=" + socketInetAddress + "]";
+  }
+
+  private InetSocketAddress cloneUnresolved(final InetSocketAddress inetSocketAddress) {
+    return InetSocketAddress.createUnresolved(inetSocketAddress.getHostString(),
+        inetSocketAddress.getPort());

INS26 INS40 INS31 INS29 INS78 INS83 MOV43 INS42 INS44 INS8 INS25 INS65 INS42 INS65 UPD65 MOV8 UPD42 INS25 INS41 INS83 INS43 INS42 INS41 MOV32 INS8 INS8 INS66 INS38 INS66 INS65 INS66 INS66 INS65 UPD66 INS65 INS66 UPD66 INS32 INS32 INS32 MOV32 INS8 INS27 MOV8 MOV43 INS32 INS42 INS32 MOV21 MOV21 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV41 INS27 INS27 MOV41 UPD42 UPD42 MOV42 MOV42 INS42 UPD40 MOV40 INS42 INS42 INS32 INS32 INS42 INS42 UPD42 MOV42 MOV33 MOV32 MOV32 MOV43 UPD42 INS42 INS42 INS42 INS42 INS42 INS14 INS42 INS32 INS32 UPD42 INS43 INS42 MOV32 INS42 INS42 INS42 INS42 INS42 INS42 DEL83 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL7 DEL21 DEL52 DEL42 DEL22 DEL7 DEL21 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL31 DEL39 DEL42 DEL34 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL42 DEL42 DEL27 DEL42 DEL34 DEL34 DEL16 DEL36 DEL27 DEL7 DEL21 DEL42 DEL42 DEL42 DEL27 DEL42 DEL33 DEL27 DEL34 DEL16 DEL36 DEL27 DEL7 DEL21 DEL42 DEL42 DEL42 DEL27 DEL42 DEL33 DEL27 DEL34 DEL42 DEL42 DEL32 DEL16 DEL36 DEL27 DEL7 DEL21 DEL42 DEL40 DEL33 DEL27 DEL9 DEL41 DEL25 DEL27 DEL25 DEL27 DEL9 DEL41 DEL25 DEL42 DEL40 DEL27 DEL9 DEL41 DEL25 DEL42 DEL33 DEL27 DEL32 DEL38 DEL9 DEL41 DEL25 DEL25 DEL42 DEL33 DEL27 DEL40 DEL33 DEL27 DEL9 DEL41 DEL25 DEL8 DEL42 DEL42 DEL40 DEL32 DEL38 DEL9 DEL41 DEL25 DEL25 DEL9 DEL41 DEL45 DEL42 DEL45 DEL42
Merge branch 'release/1.4.0'

+import org.apache.geode.internal.cache.entries.AbstractRegionEntry;
- * 
+ *
- * 
+ *
- * 
+ *
-   * 
+   *
+    {
+      TXStateProxy curProxy = txContext.get();
+      if (curProxy == PAUSED) {
+        throw new java.lang.IllegalStateException(
+            "Current thread has paused its transaction so it can not start a new transaction");
+      }
+    }
+    if (tsp == PAUSED) {
+      // treats paused transaction as no transaction.
+      return null;
+    }
-   * 
+   *
+    assert tsp != PAUSED;
+  private static final TXStateProxy PAUSED = new PausedTXStateProxyImpl();
+
+  /**
+   * If the current thread is in a transaction then pause will cause it to no longer be in a
+   * transaction. The same thread is expected to unpause/resume the transaction later. The thread
+   * should not start a new transaction after it paused a transaction.
+   *
+   * @return the state of the transaction or null. Pass this value to
+   *         {@link TXManagerImpl#unpauseTransaction} to reactivate the puased/suspended
+   *         transaction.
+   */
+  public TXStateProxy pauseTransaction() {
+    return internalSuspend(true);
+  }
+
+  /**
+   * If the current thread is in a transaction then internal suspend will cause it to no longer be
+   * in a transaction. The thread can start a new transaction after it internal suspended a
+   * transaction.
+   *
+   * @return the state of the transaction or null. to reactivate the suspended transaction.
+   */
+  public TXStateProxy internalSuspend() {
+    return internalSuspend(false);
+  }
+
-   * 
-   * @return the state of the transaction or null. Pass this value to {@link TXManagerImpl#resume}
-   *         to reactivate the suspended transaction.
+   *
+   * @param needToResumeBySameThread whether a suspended transaction needs to be resumed by the same
+   *        thread.
+   * @return the state of the transaction or null. Pass this value to
+   *         {@link TXManagerImpl#internalResume(TXStateProxy, boolean)} to reactivate the suspended
+   *         transaction.
-  public TXStateProxy internalSuspend() {
+  private TXStateProxy internalSuspend(boolean needToResumeBySameThread) {
-      setTXState(null);
+      if (needToResumeBySameThread) {
+        setTXState(PAUSED);
+      } else {
+        setTXState(null);
+      }
-   * Activates the specified transaction on the calling thread.
-   * 
+   * Activates the specified transaction on the calling thread. Only the same thread that pause the
+   * transaction can unpause it.
+   *
+   * @param tx the transaction to be unpaused.
+   * @throws IllegalStateException if this thread already has an active transaction or this thread
+   *         did not pause the transaction.
+   */
+  public void unpauseTransaction(TXStateProxy tx) {
+    internalResume(tx, true);
+  }
+
+  /**
+   * Activates the specified transaction on the calling thread. Does not require the same thread to
+   * resume it.
+   *
+    internalResume(tx, false);
+  }
+
+  /**
+   * Activates the specified transaction on the calling thread.
+   *
+   * @param tx the transaction to activate.
+   * @param needToResumeBySameThread whether a suspended transaction needs to be resumed by the same
+   *        thread.
+   * @throws IllegalStateException if this thread already has an active transaction
+   */
+  private void internalResume(TXStateProxy tx, boolean needToResumeBySameThread) {
+      if (needToResumeBySameThread) {
+        TXStateProxy result = txContext.get();
+        if (result != PAUSED) {
+          throw new java.lang.IllegalStateException(
+              "try to unpause a transaction not paused by the same thread");
+        }
+      }
+
+  public boolean isTransactionPaused() {
+    return txContext.get() == PAUSED;
+  }
+
-    if (t != null) {
+    if (t != null && t != PAUSED) {
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-      internalSuspend();
+      result.suspend();
+      setTXState(null);
-    internalResume(txProxy);
+    assert getTXState() == null;
+    setTXState(txProxy);
+    txProxy.resume();
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *

INS26 INS40 INS23 INS31 INS31 INS31 INS31 INS31 INS83 INS83 INS83 INS43 INS59 INS29 INS83 INS43 INS42 INS8 INS29 INS83 INS43 INS42 INS8 UPD83 INS44 INS29 INS83 INS39 INS42 INS44 INS8 INS29 INS83 INS39 INS42 INS44 INS8 UPD83 INS44 INS83 INS39 INS42 INS8 INS8 INS25 INS6 INS42 INS42 INS14 INS65 INS65 INS42 INS41 INS65 INS65 INS42 INS41 INS65 INS39 INS42 INS25 INS65 INS65 INS65 INS43 INS42 INS21 INS65 INS65 INS65 INS43 INS42 INS21 INS65 INS39 INS42 INS41 INS6 INS21 INS60 INS25 INS27 INS8 INS27 INS43 INS66 INS66 INS66 INS66 INS65 INS66 INS66 INS32 INS66 INS66 INS66 INS66 INS32 INS42 INS66 INS66 UPD66 UPD66 INS66 MOV27 INS8 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS42 INS32 INS66 INS66 INS42 INS66 INS42 INS66 INS42 INS32 INS42 INS66 INS66 INS27 INS27 INS27 INS32 INS43 INS59 INS27 INS8 INS42 INS42 INS41 INS42 INS42 INS42 INS67 INS42 INS9 INS42 INS9 INS68 MOV21 MOV25 INS42 INS42 INS9 INS42 INS42 INS9 INS25 INS32 INS42 MOV27 INS27 MOV21 INS32 INS33 UPD42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS53 INS33 INS42 INS42 INS42 INS42 INS69 INS69 INS42 INS8 INS42 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS14 INS43 INS39 INS21 INS21 INS60 INS25 INS42 UPD42 INS43 INS45 INS42 INS32 INS32 INS43 INS59 INS27 INS8 INS40 INS42 INS42 INS42 INS33 INS42 INS42 INS32 INS42 INS42 INS53 INS42 INS42 INS14 INS43 INS45 INS40 DEL42 DEL42 DEL67
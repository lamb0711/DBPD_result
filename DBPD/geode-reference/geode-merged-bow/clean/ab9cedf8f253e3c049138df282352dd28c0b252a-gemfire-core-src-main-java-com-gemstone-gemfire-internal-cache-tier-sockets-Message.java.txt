GEODE-981: NPE in Message.clear()

This fixes the NPE and adds a unit test for it.  I also did some cleanup
of Message, removing unused methods and old commented out code and
changing the earlyAck byte to be "flags" and not allow external
manipulation of the byte's bits.

-import com.gemstone.gemfire.internal.cache.CachedDeserializable;
-import com.gemstone.gemfire.internal.offheap.annotations.Retained;
- * earlyAck      - byte- 1 byte   filled in by the requestor
+ * flags         - byte- 1 byte   filled in by the requestor
- * @author Sudhir Menon
- * @since 2.0.2
-  @Override
-  public String toString() {
-    StringBuffer sb = new StringBuffer();
-    sb.append("type=" + MessageType.getString(msgType));
-    sb.append("; payloadLength=" + payloadLength);
-    sb.append("; numberOfParts=" + numberOfParts);
-    sb.append("; transactionId=" + transactionId);
-    //sb.append("; bufferLength=" + bufferLength);
-    sb.append("; currentPart=" + currentPart);
-    sb.append("; messageModified=" + messageModified);
-    sb.append("; earlyAck=" + earlyAck);
-    for (int i = 0; i < numberOfParts; i ++) {
-      sb.append("; part[" + i + "]={");
-      sb.append(this.partsList[i].toString());
-      sb.append("}");
-    }
-    return sb.toString();
-  }
+  private static final int PART_HEADER_SIZE = 5; // 4 bytes for length, 1 byte for isObject
+  
+  private static final int FIXED_LENGTH = 17;
-  protected final static int FIXED_LENGTH = 17;
+  private static final ThreadLocal<ByteBuffer> tlCommBuffer = new ThreadLocal<>();
+
-  private byte earlyAck = 0x00;
+  private byte flags = 0x00;
-  private int MAX_DATA = -1;
+  private int maxIncomingMessageLength = -1;
+  private boolean isMetaRegion = false;
-  // These two statics are fields shoved into the earlyAck byte for transmission.
+
+  // These two statics are fields shoved into the flags byte for transmission.
-  /**
-   * Sets whether this message is early-ack
-   * @param earlyAck whether this message is early-ack
-   */
-  public void setEarlyAck(boolean earlyAck) {
-    if (earlyAck) {
-      this.earlyAck = 0x01;
-    } else {
-      this.earlyAck = 0x00;
-    }
+  public void setMessageHasSecurePartFlag() {
+    this.flags = (byte)(this.flags | MESSAGE_HAS_SECURE_PART);
-
-  // TODO (ashetkar) To be removed later.
-  public void setEarlyAck(byte earlyAck) {
-    // Check that the passed in value is within the acceptable range.
-    if (0x00 <= earlyAck && earlyAck <= 0x02) {
-      this.earlyAck |= earlyAck;
-    }
+  
+  public void clearMessageHasSecurePartFlag() {
+    this.flags = (byte)(this.flags & MESSAGE_HAS_SECURE_PART);
-  /*
-   * public void setPayloadLength(int payloadLength) {
-     this.payloadLength = payloadLength;
-  }*/
-
+  
+  /**
+   * When building a Message this will return the number of the
+   * next Part to be added to the message
+   */
+  public int getNextPartNumber() {
+    return this.currentPart;
+  }
-  /**
-   * Sets whether or not a
-   * <code>DataOutputStream</code>/<code>DataOutputStream</code>
-   * should be used to send/receive data.
-      public void setUseDataStream (boolean useDataStream) {
-        this.useDataStream = useDataStream;
-    }
-   */
-
-  public void addDeltaPart(HeapDataOutputStream hdos) { // TODO: Amogh- Should it be just DataOutput?
+  public void addDeltaPart(HeapDataOutputStream hdos) {
-//      logger.fine("hitesh before serializatino: " );
-//      
-//      if (o != null ){
-//        logger.fine("hitesh before serializatino: " + o.toString());
-//        logger.fine("hitesh before serializatino: " + o.getClass().getName());
-//      }
-//       byte[] b = CacheServerHelper.serialize(o, zipValues);
-//       addRawPart(b, true);
-//        logger.fine("hitesh before serializatino: " );
-//        
-//        if (o != null ){
-//          logger.fine("hitesh before serializatino: " + o.toString());
-//          logger.fine("hitesh before serializatino: " + o.getClass().getName());
-//        }
-  public boolean getEarlyAck() {
-    return this.earlyAck == 0x01 ? true: false;
-  }
-
-  // TODO (ashetkar) To be removed
-  public byte getEarlyAckByte() {
-    return this.earlyAck;
-  }
-
-  private static ThreadLocal tlCommBuffer = new ThreadLocal();
-
-    ByteBuffer result = (ByteBuffer)tlCommBuffer.get();
+    ByteBuffer result = tlCommBuffer.get();
-      return (ByteBuffer)tlCommBuffer.get();
+      return tlCommBuffer.get();
-    if (this.socket != null) {
-      getCommBuffer().clear();
+    ByteBuffer buffer = getCommBuffer();
+    if (buffer != null) {
+      buffer.clear();
-      this.MAX_DATA = 0;
+      this.maxIncomingMessageLength = 0;
+    this.flags = 0;
-    //TODO:hitesh setting second bit of early ack for client 
+    //TODO:hitesh setting second bit of flags byte for client 
-    byte eAck = this.earlyAck;
+    byte flagsByte = this.flags;
-      eAck |= MESSAGE_HAS_SECURE_PART;
+      flagsByte |= MESSAGE_HAS_SECURE_PART;
-      eAck |= MESSAGE_IS_RETRY;
+      flagsByte |= MESSAGE_IS_RETRY;
-      .put(eAck);
+      .put(flagsByte);
-  private static final int PART_HEADER_SIZE = 5; // 4 bytes for length, 1 byte for isObject
-  
-  private boolean m_isMetaRegion = false;
-
-    this.m_isMetaRegion = isMetaRegion;
+    this.isMetaRegion = isMetaRegion;
-    boolean isMetaRegion = this.m_isMetaRegion;
-    this.m_isMetaRegion = false;
+    boolean isMetaRegion = this.isMetaRegion;
+    this.isMetaRegion = false;
-        //this.logger.fine("hitesh sendbytes forServer_SecurityPart " + numOfSecureParts);
-    byte early = cb.get();
+    byte bits = cb.get();
-      if (this.MAX_DATA > 0 && len > this.MAX_DATA) {
-        throw new IOException(LocalizedStrings.Message_MESSAGE_SIZE_0_EXCEEDED_MAX_LIMIT_OF_1.toLocalizedString(new Object[] {Integer.valueOf(len), Integer.valueOf(this.MAX_DATA)}));
+      if (this.maxIncomingMessageLength > 0 && len > this.maxIncomingMessageLength) {
+        throw new IOException(LocalizedStrings.Message_MESSAGE_SIZE_0_EXCEEDED_MAX_LIMIT_OF_1.toLocalizedString(new Object[] {Integer.valueOf(len), Integer.valueOf(this.maxIncomingMessageLength)}));
-    this.isRetry = (early & MESSAGE_IS_RETRY) != 0;
-    early = (byte)(early & MESSAGE_IS_RETRY_MASK);
-
-    //TODO:hitesh it was below ??
-    this.earlyAck = early;
+    this.isRetry = (bits & MESSAGE_IS_RETRY) != 0;
+    bits = (byte)(bits & MESSAGE_IS_RETRY_MASK);
+    this.flags = bits;
+    // TODO why is the msgType set twice, here and after reading the payload fields?
-    //this.logger.fine("Before reading message parts, earlyAck already read as " + this.earlyAck);
+
-    this.earlyAck = early;
+    this.flags = bits;
-//   static final int MAX_PART_BUFFERS = 2;
-//   static final int MIN_PART_BUFFER_SIZE = 999;
-//   static final int MAX_PART_BUFFER_SIZE = 1024*1024*11;
-//   static ArrayList partBuffers = new ArrayList(2);
-//   static int partBufferIdx = 0;
-//   static {
-//     for (int i=0; i < MAX_PART_BUFFERS; i++) {
-//       partBuffers.add(i, null);
-//     }
-//   }
-
-//   private static synchronized byte[] getPartBuffer(int size) {
-//     byte[] result;
-//     synchronized (partBuffers) {
-//       result = (byte[])partBuffers.get(partBufferIdx);
-//       if (result == null) {
-//         result = new byte[size];
-//         partBuffers.add(partBufferIdx, result);
-//       } else if (result.length != size) {
-//         // can't use a cached one
-//         return null;
-//       }
-//       partBufferIdx++;
-//       if (partBufferIdx >= MAX_PART_BUFFERS) {
-//         partBufferIdx = 0;
-//       }
-//     }
-//     return result;
-//   }
-
-    //this.logger.fine("readPayloadFields() early ack = " + this.earlyAck);
-    //this.logger.fine("readPayloadFields() : numParts=" + numParts + " len=" + len);
-//      this.logger.fine("readPayloadFields(): partLen=" + partLen + " partType=" + partType);
-//         if (partLen >= MIN_PART_BUFFER_SIZE && partLen <= MAX_PART_BUFFER_SIZE) {
-//           partBytes = getPartBuffer(partLen);
-//         }
-//         if (partBytes == null) {
-          partBytes = new byte[partLen];
-//         }
+        partBytes = new byte[partLen];
-            //System.out.println("DEBUG: part read " + res + " bytes commBuffer=" + cb);
-//              res = 0;
-    if ((this.earlyAck | MESSAGE_HAS_SECURE_PART) == this.earlyAck) {
+    if ((this.flags | MESSAGE_HAS_SECURE_PART) == this.flags) {
-    //this.logger.info("DEBUG: commBuffer.remaining=" + cb.remaining());
-        //System.out.println("DEBUG: partChunk read " + res + " bytes commBuffer=" + cb);
-//          res = 0;
+
+  @Override
+  public String toString() {
+    StringBuffer sb = new StringBuffer();
+    sb.append("type=").append(MessageType.getString(msgType));
+    sb.append("; payloadLength=").append(payloadLength);
+    sb.append("; numberOfParts=").append(numberOfParts);
+    sb.append("; transactionId=").append(transactionId);
+    sb.append("; currentPart=").append(currentPart);
+    sb.append("; messageModified=").append(messageModified);
+    sb.append("; flags=").append(Integer.toHexString(flags));
+    for (int i = 0; i < numberOfParts; i ++) {
+      sb.append("; part[").append(i).append("]={");
+      sb.append(this.partsList[i].toString());
+      sb.append("}");
+    }
+    return sb.toString();
+  }
+
+  
-  public void recv(ServerConnection sc, int MAX_DATA, Semaphore dataLimiter, int MAX_MSGS, Semaphore msgLimiter)
+  public void recv(ServerConnection sc, int maxMessageLength, Semaphore dataLimiter, Semaphore msgLimiter)
-    this.MAX_DATA = MAX_DATA;
+    this.maxIncomingMessageLength = maxMessageLength;
-//    this.MAX_MSGS = MAX_MSGS;
-  public boolean canStartRemoteTransaction() {
-    return true;
-  }

MOV31 MOV31 MOV31 MOV23 MOV23 INS23 UPD83 INS83 INS83 INS74 INS83 INS39 INS59 UPD42 INS8 UPD39 UPD42 INS29 UPD39 UPD42 UPD66 MOV43 MOV43 UPD42 UPD42 INS42 INS9 MOV21 INS21 INS65 INS60 INS21 UPD42 INS74 UPD7 INS7 INS66 INS66 MOV43 MOV43 INS59 INS7 MOV43 INS11 INS22 INS11 UPD42 MOV32 INS42 MOV32 INS42 INS22 INS34 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS32 INS42 MOV32 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 UPD42 UPD42 INS39 INS36 INS52 INS42 INS39 INS36 MOV32 INS52 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV42 MOV42 INS45 MOV42 MOV42 INS45 MOV42 MOV42 INS45 MOV42 MOV42 INS45 MOV42 MOV42 INS45 MOV42 MOV42 INS45 MOV42 MOV42 INS45 INS42 INS42 INS42 UPD42 INS27 INS27 INS42 UPD42 UPD42 INS32 INS42 INS45 INS22 INS42 MOV22 INS42 UPD42 UPD42 UPD42 UPD42 INS32 INS42 INS42 INS52 INS42 UPD42 UPD42 UPD42 MOV42 MOV42 INS45 UPD42 DEL40 DEL26 DEL40 DEL26 DEL66 DEL65 DEL66 DEL65 DEL83 DEL66 DEL65 DEL42 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL8 DEL52 DEL42 DEL22 DEL34 DEL7 DEL21 DEL8 DEL25 DEL8 DEL31 DEL42 DEL39 DEL42 DEL44 DEL34 DEL42 DEL27 DEL42 DEL34 DEL27 DEL27 DEL8 DEL25 DEL8 DEL34 DEL27 DEL9 DEL9 DEL16 DEL41 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL11 DEL11 DEL52 DEL42 DEL22 DEL83 DEL39 DEL42 DEL9 DEL59 DEL23 DEL45 DEL27 DEL45 DEL42 DEL27 DEL45 DEL42 DEL27 DEL45 DEL42 DEL27 DEL45 DEL42 DEL27 DEL45 DEL42 DEL27 DEL45 DEL42 DEL27 DEL45 DEL42 DEL45 DEL27 DEL39 DEL42 DEL44 DEL83 DEL39 DEL42 DEL9 DEL41 DEL8 DEL31
GEODE-7597: Factor out code needed in Membership from SocketCreator (#4637)

* GEODE-7597: Factor out code needed in Membership from SocketCreator

Implemented a new TcpSocketCreatorImpl.  Due to GeodeHttpClientRule
dependencies this and associated interfaces are in geode-common.  I'd
rather have them in geode-tcp-server.

SocketCreator now subclasses TcpSocketCreatorImpl and I've removed the
adapter class, which is no longer needed.

* added missing files

* fixing dunit failure and moving TcpSocketCreator back to the tcp-server project

* fixing bind address and inheritance problems in socket creators

* fixes for unit test failures

* spotless

* relax assertion in test that fails stress-testing

-import java.nio.channels.ServerSocketChannel;
-import java.util.concurrent.ThreadLocalRandom;
+import org.apache.geode.distributed.internal.tcpserver.TcpSocketCreatorImpl;
-public class SocketCreator {
+public class SocketCreator extends TcpSocketCreatorImpl {
-  public static final boolean ENABLE_TCP_KEEP_ALIVE;
-
-  static {
-    // bug #49484 - customers want tcp/ip keep-alive turned on by default
-    // to avoid dropped connections. It can be turned off by setting this
-    // property to false
-    String str = System.getProperty(GeodeGlossary.GEMFIRE_PREFIX + "setTcpKeepAlive");
-    if (str != null) {
-      ENABLE_TCP_KEEP_ALIVE = Boolean.valueOf(str);
-    } else {
-      ENABLE_TCP_KEEP_ALIVE = true;
-    }
-  }
+  public static final boolean ENABLE_TCP_KEEP_ALIVE = TcpSocketCreatorImpl.ENABLE_TCP_KEEP_ALIVE;
+  @Override
-  /**
-   * Return a ServerSocket possibly configured for SSL. SSL configuration is left up to JSSE
-   * properties in java.security file.
-   */
-  public ServerSocket createServerSocket(int nport, int backlog) throws IOException {
-    return createServerSocket(nport, backlog, null);
-  }
-
-  /**
-   * Return a ServerSocket possibly configured for SSL. SSL configuration is left up to JSSE
-   * properties in java.security file.
-   */
-  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr)
-      throws IOException {
-    return createServerSocket(nport, backlog, bindAddr, -1, sslConfig.isEnabled());
-  }
-
-  private ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
+  @Override
+  protected ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
-    if (sslConnection) {
-      if (this.sslContext == null) {
-        throw new GemFireConfigException(
-            "SSL not configured correctly, Please look at previous error");
-      }
-      ServerSocketFactory ssf = this.sslContext.getServerSocketFactory();
-      SSLServerSocket serverSocket = (SSLServerSocket) ssf.createServerSocket();
-      serverSocket.setReuseAddress(true);
-      // If necessary, set the receive buffer size before binding the socket so
-      // that large buffers will be allocated on accepted sockets (see
-      // java.net.ServerSocket.setReceiverBufferSize javadocs)
-      if (socketBufferSize != -1) {
-        serverSocket.setReceiveBufferSize(socketBufferSize);
-      }
-      serverSocket.bind(new InetSocketAddress(bindAddr, nport), backlog);
-      finishServerSocket(serverSocket);
-      return serverSocket;
-    } else {
-      // log.info("Opening server socket on " + nport, new Exception("SocketCreation"));
-      ServerSocket result = new ServerSocket();
-      result.setReuseAddress(true);
-      // If necessary, set the receive buffer size before binding the socket so
-      // that large buffers will be allocated on accepted sockets (see
-      // java.net.ServerSocket.setReceiverBufferSize javadocs)
-      if (socketBufferSize != -1) {
-        result.setReceiveBufferSize(socketBufferSize);
-      }
-      try {
-        result.bind(new InetSocketAddress(bindAddr, nport), backlog);
-      } catch (BindException e) {
-        BindException throwMe =
-            new BindException(String.format("Failed to create server socket on %s[%s]",
-                bindAddr == null ? InetAddress.getLocalHost() : bindAddr,
-                String.valueOf(nport)));
-        throwMe.initCause(e);
-        throw throwMe;
-      }
-      return result;
+    if (!sslConnection) {
+      return super.createServerSocket(nport, backlog, bindAddr, socketBufferSize, sslConnection);
+    if (this.sslContext == null) {
+      throw new GemFireConfigException(
+          "SSL not configured correctly, Please look at previous error");
+    }
+    ServerSocketFactory ssf = this.sslContext.getServerSocketFactory();
+    SSLServerSocket serverSocket = (SSLServerSocket) ssf.createServerSocket();
+    serverSocket.setReuseAddress(true);
+    // If necessary, set the receive buffer size before binding the socket so
+    // that large buffers will be allocated on accepted sockets (see
+    // java.net.ServerSocket.setReceiverBufferSize javadocs)
+    if (socketBufferSize != -1) {
+      serverSocket.setReceiveBufferSize(socketBufferSize);
+    }
+    serverSocket.bind(new InetSocketAddress(bindAddr, nport), backlog);
+    finishServerSocket(serverSocket);
+    return serverSocket;
-  /**
-   * Creates or bind server socket to a random port selected from tcp-port-range which is same as
-   * membership-port-range.
-   *
-   * @param sslConnection whether to connect using SSL
-   *
-   * @return Returns the new server socket.
-   *
-   */
-  public ServerSocket createServerSocketUsingPortRange(InetAddress ba, int backlog,
-      boolean isBindAddress, boolean useNIO, int tcpBufferSize, int[] tcpPortRange,
-      boolean sslConnection) {
+  @Override
+  protected RuntimeException problemCreatingSocketInPortRangeException(String s, IOException e) {
+    return new GemFireConfigException(s, e);
+  }
-    try {
-      // Get a random port from range.
-      int startingPort = tcpPortRange[0]
-          + ThreadLocalRandom.current().nextInt(tcpPortRange[1] - tcpPortRange[0] + 1);
-      int localPort = startingPort;
-      int portLimit = tcpPortRange[1];
-
-      while (true) {
-        if (localPort > portLimit) {
-          if (startingPort != 0) {
-            localPort = tcpPortRange[0];
-            portLimit = startingPort - 1;
-            startingPort = 0;
-          } else {
-            throw new SystemConnectException(
-                "Unable to find a free port in the membership-port-range");
-          }
-        }
-        ServerSocket socket = null;
-        try {
-          if (useNIO) {
-            ServerSocketChannel channel = ServerSocketChannel.open();
-            socket = channel.socket();
-
-            InetSocketAddress address = new InetSocketAddress(isBindAddress ? ba : null, localPort);
-            socket.bind(address, backlog);
-          } else {
-            socket = this.createServerSocket(localPort, backlog, isBindAddress ? ba : null,
-                tcpBufferSize, sslConnection);
-          }
-          return socket;
-        } catch (java.net.SocketException ex) {
-          if (socket != null && !socket.isClosed()) {
-            socket.close();
-          }
-          localPort++;
-        }
-      }
-    } catch (IOException e) {
-      throw new GemFireConfigException("unable to create a socket in the membership-port range", e);
-    }
+  @Override
+  protected RuntimeException noFreePortException(String reason) {
+    return new SystemConnectException(reason);
-      ConnectionWatcher optionalWatcher, boolean clientSide) throws IOException {
-    return connect(inetadd, port, timeout, optionalWatcher, clientSide, -1);
-  }
-
-  /**
-   * Return a client socket, timing out if unable to connect and timeout > 0 (millis). The parameter
-   * <i>timeout</i> is ignored if SSL is being used, as there is no timeout argument in the ssl
-   * socket factory
-   */
-  public Socket connect(InetAddress inetadd, int port, int timeout,
+  @Override
-    Socket socket = null;
-    SocketAddress sockaddr = new InetSocketAddress(inetadd, port);
+
+
+    if (!sslConnection) {
+      return super.connect(inetadd, port, timeout, optionalWatcher, clientSide, socketBufferSize,
+          sslConnection);
+    }
+
+    // create an SSL connection
+
+    Socket socket;
+    SocketAddress sockaddr = new InetSocketAddress(inetadd, port);
+    if (this.sslContext == null) {
+      throw new GemFireConfigException(
+          "SSL not configured correctly, Please look at previous error");
+    }
+    SocketFactory sf = this.sslContext.getSocketFactory();
+    socket = sf.createSocket();
+
+    // Optionally enable SO_KEEPALIVE in the OS network protocol.
+    socket.setKeepAlive(ENABLE_TCP_KEEP_ALIVE);
+
+    // If necessary, set the receive buffer size before connecting the
+    // socket so that large buffers will be allocated on accepted sockets
+    // (see java.net.Socket.setReceiverBufferSize javadocs for details)
+    if (socketBufferSize != -1) {
+      socket.setReceiveBufferSize(socketBufferSize);
+    }
+
-      if (sslConnection) {
-        if (this.sslContext == null) {
-          throw new GemFireConfigException(
-              "SSL not configured correctly, Please look at previous error");
-        }
-        SocketFactory sf = this.sslContext.getSocketFactory();
-        socket = sf.createSocket();
-
-        // Optionally enable SO_KEEPALIVE in the OS network protocol.
-        socket.setKeepAlive(ENABLE_TCP_KEEP_ALIVE);
-
-        // If necessary, set the receive buffer size before connecting the
-        // socket so that large buffers will be allocated on accepted sockets
-        // (see java.net.Socket.setReceiverBufferSize javadocs for details)
-        if (socketBufferSize != -1) {
-          socket.setReceiveBufferSize(socketBufferSize);
-        }
-
-        if (optionalWatcher != null) {
-          optionalWatcher.beforeConnect(socket);
-        }
-        socket.connect(sockaddr, Math.max(timeout, 0));
-        configureClientSSLSocket(socket, timeout);
-        return socket;
-      } else {
-        if (clientSide && this.clientSocketFactory != null) {
-          socket = this.clientSocketFactory.createSocket(inetadd, port);
-        } else {
-          socket = new Socket();
-
-          // Optionally enable SO_KEEPALIVE in the OS network protocol.
-          socket.setKeepAlive(ENABLE_TCP_KEEP_ALIVE);
-
-          // If necessary, set the receive buffer size before connecting the
-          // socket so that large buffers will be allocated on accepted sockets
-          // (see java.net.Socket.setReceiverBufferSize javadocs for details)
-          if (socketBufferSize != -1) {
-            socket.setReceiveBufferSize(socketBufferSize);
-          }
-
-          if (optionalWatcher != null) {
-            optionalWatcher.beforeConnect(socket);
-          }
-          socket.connect(sockaddr, Math.max(timeout, 0));
-        }
-        return socket;
+      if (optionalWatcher != null) {
+        optionalWatcher.beforeConnect(socket);
+      socket.connect(sockaddr, Math.max(timeout, 0));
+      configureClientSSLSocket(socket, timeout);
+      return socket;
+
+  @Override
+  protected Socket createCustomClientSocket(InetAddress inetadd, int port) throws IOException {
+    if (this.clientSocketFactory != null) {
+      return this.clientSocketFactory.createSocket(inetadd, port);
+    }
+    return null;
+  }
+
-    if (socket instanceof SSLSocket) {
-      int oldTimeout = socket.getSoTimeout();
-      socket.setSoTimeout(timeout);
-      SSLSocket sslSocket = (SSLSocket) socket;
-      try {
-        sslSocket.startHandshake();
-      } catch (SSLPeerUnverifiedException ex) {
-        if (this.sslConfig.isRequireAuth()) {
-          logger.fatal(String.format("SSL Error in authenticating peer %s[%s].",
-              socket.getInetAddress(), socket.getPort()), ex);
-          throw ex;
-        }
+    if (!(socket instanceof SSLSocket)) {
+      return;
+    }
+    int oldTimeout = socket.getSoTimeout();
+    socket.setSoTimeout(timeout);
+    SSLSocket sslSocket = (SSLSocket) socket;
+    try {
+      sslSocket.startHandshake();
+    } catch (SSLPeerUnverifiedException ex) {
+      if (this.sslConfig.isRequireAuth()) {
+        logger.fatal(String.format("SSL Error in authenticating peer %s[%s].",
+            socket.getInetAddress(), socket.getPort()), ex);
+        throw ex;
-      // Pre jkd11, startHandshake is throwing SocketTimeoutException.
-      // in jdk 11 it is throwing SSLProtocolException with a cause of SocketTimeoutException.
-      // this is to keep the exception consistent across jdk
-      catch (SSLProtocolException ex) {
-        if (ex.getCause() instanceof SocketTimeoutException) {
-          throw (SocketTimeoutException) ex.getCause();
-        } else {
-          throw ex;
-        }
-      } finally {
-        try {
-          socket.setSoTimeout(oldTimeout);
-        } catch (SocketException ignored) {
-        }
+    }
+    // Pre jkd11, startHandshake is throwing SocketTimeoutException.
+    // in jdk 11 it is throwing SSLProtocolException with a cause of SocketTimeoutException.
+    // this is to keep the exception consistent across jdk
+    catch (SSLProtocolException ex) {
+      if (ex.getCause() instanceof SocketTimeoutException) {
+        throw (SocketTimeoutException) ex.getCause();
+      } else {
+        throw ex;
+      }
+    } finally {
+      try {
+        socket.setSoTimeout(oldTimeout);
+      } catch (SocketException ignored) {

MOV26 MOV31 UPD40 INS43 INS31 INS31 INS42 INS78 INS78 UPD83 MOV8 INS78 UPD83 MOV83 UPD43 MOV43 UPD42 MOV42 MOV44 MOV44 MOV8 INS78 UPD83 MOV83 UPD43 MOV43 INS42 MOV44 MOV8 INS78 MOV8 INS78 UPD83 MOV43 UPD42 MOV44 MOV44 MOV43 INS8 MOV8 INS40 INS42 INS42 MOV21 INS25 INS42 UPD42 MOV43 UPD42 INS41 INS42 UPD42 UPD43 UPD42 INS41 INS42 MOV21 INS25 INS60 MOV60 INS54 INS42 MOV25 MOV41 INS25 INS38 INS8 MOV14 UPD42 MOV14 INS38 INS8 MOV43 INS59 INS8 MOV8 MOV27 MOV8 INS33 INS38 INS8 INS42 INS41 INS42 INS42 INS42 INS41 INS42 MOV25 MOV21 MOV21 MOV41 INS41 INS36 INS41 INS48 INS48 MOV32 MOV62 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 DEL40 DEL26 DEL83 DEL42 DEL42 DEL42 DEL40 DEL45 DEL27 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL28 DEL66 DEL66 DEL65 DEL29 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL33 DEL32 DEL41 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL42 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL34 DEL38 DEL42 DEL42 DEL32 DEL32 DEL41 DEL8 DEL31 DEL42 DEL42 DEL43 DEL42 DEL42 DEL43 DEL14 DEL59 DEL60 DEL42 DEL42 DEL9 DEL32 DEL21 DEL42 DEL34 DEL38 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL43 DEL42 DEL42 DEL14 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL45 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL42 DEL16 DEL42 DEL42 DEL42 DEL32 DEL32 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL53 DEL8 DEL12 DEL54 DEL42 DEL41 DEL8 DEL25 DEL8 DEL39 DEL45 DEL53 DEL45 DEL53 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL34 DEL38 DEL32 DEL41 DEL8 DEL31 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL42 DEL43 DEL14 DEL7 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL34 DEL38 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL32 DEL21 DEL8 DEL25 DEL42 DEL41 DEL8 DEL25 DEL8 DEL54 DEL8 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL65 DEL29 DEL42 DEL43 DEL42 DEL7 DEL21 DEL42 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL33 DEL16 DEL42 DEL14 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL52 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL16 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL85 DEL5 DEL42 DEL44 DEL39 DEL42 DEL44 DEL39 DEL42 DEL42 DEL34 DEL2 DEL42 DEL42 DEL32 DEL42 DEL42 DEL34 DEL2 DEL42 DEL34 DEL2 DEL27 DEL34 DEL27 DEL32 DEL27 DEL59 DEL60 DEL39 DEL42 DEL42 DEL59 DEL60 DEL39 DEL42 DEL42 DEL34 DEL2 DEL59 DEL60 DEL9 DEL42 DEL42 DEL27 DEL42 DEL34 DEL27 DEL42 DEL42 DEL34 DEL2 DEL7 DEL21 DEL42 DEL42 DEL34 DEL27 DEL7 DEL21 DEL42 DEL34 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL8 DEL40 DEL43 DEL42 DEL44 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL38 DEL27 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL37 DEL21 DEL8 DEL12 DEL54 DEL8 DEL61 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A <code>HeapLRUCapacityController</code> controls the contents of
- * {@link Region} based on the percentage of memory that is
- * currently being used. If the percentage of memory in use exceeds
- * the given percentage, then the least recently used entry of the region is
- * evicted.
+ * A <code>HeapLRUCapacityController</code> controls the contents of {@link Region} based on the
+ * percentage of memory that is currently being used. If the percentage of memory in use exceeds the
+ * given percentage, then the least recently used entry of the region is evicted.
- * For heap regions:
- * GemStone has found that the <code>HeapLRUCapacityController</code> has the
- * most effect on a VM that is lauched with both the <code>-Xmx</code> and
- * <code>-Xms</code> switches used. Many virtual machine implementations have
- * additional VM switches to control the behavior of the garbage collector. We
- * suggest that you investigate tuning the garbage collector when using a
- * <code>HeapLRUCapacityController</code>. In particular, we have found that
- * when running with Sun's <A
- * href="http://java.sun.com/docs/hotspot/gc/index.html">HotSpot</a> VM, the
- * <code>-XX:+UseConcMarkSweepGC</code> and <code>-XX:+UseParNewGC</code>
- * options improve the behavior of the <code>HeapLRUCapacityController</code>.
+ * For heap regions: GemStone has found that the <code>HeapLRUCapacityController</code> has the most
+ * effect on a VM that is lauched with both the <code>-Xmx</code> and <code>-Xms</code> switches
+ * used. Many virtual machine implementations have additional VM switches to control the behavior of
+ * the garbage collector. We suggest that you investigate tuning the garbage collector when using a
+ * <code>HeapLRUCapacityController</code>. In particular, we have found that when running with Sun's
+ * <A href="http://java.sun.com/docs/hotspot/gc/index.html">HotSpot</a> VM, the
+ * <code>-XX:+UseConcMarkSweepGC</code> and <code>-XX:+UseParNewGC</code> options improve the
+ * behavior of the <code>HeapLRUCapacityController</code>.
-  public static final String TOP_UP_HEAP_EVICTION_PERCENTAGE_PROPERTY = DistributionConfig.GEMFIRE_PREFIX + "topUpHeapEvictionPercentage";
-  
+  public static final String TOP_UP_HEAP_EVICTION_PERCENTAGE_PROPERTY =
+      DistributionConfig.GEMFIRE_PREFIX + "topUpHeapEvictionPercentage";
+
-  
+
-   * The default number of milliseconds the evictor thread should wait before
-   * evicting the LRU entry.
+   * The default number of milliseconds the evictor thread should wait before evicting the LRU
+   * entry.
-    final String entryBytesDesc = "The amount of memory currently used by regions configured for eviction.";
+    final String entryBytesDesc =
+        "The amount of memory currently used by regions configured for eviction.";
-    final String lruDestroysDesc = "Number of entries destroyed in the region through both destroy cache operations and eviction. Reset to zero each time it exceeds lruDestroysLimit.";
-    final String lruDestroysLimitDesc = "Maximum number of entry destroys triggered by LRU before scan occurs.";
+    final String lruDestroysDesc =
+        "Number of entries destroyed in the region through both destroy cache operations and eviction. Reset to zero each time it exceeds lruDestroysLimit.";
+    final String lruDestroysLimitDesc =
+        "Maximum number of entry destroys triggered by LRU before scan occurs.";
-    statType = f
-        .createType(
-            "HeapLRUStatistics",
-            "Statistics about byte based Least Recently Used region entry disposal",
-            new StatisticDescriptor[] {
-                f.createLongGauge("entryBytes", entryBytesDesc, "bytes"),
-                f.createLongCounter("lruEvictions", lruEvictionsDesc, "entries"),
-                f.createLongCounter("lruDestroys", lruDestroysDesc, "entries"),
-                f.createLongGauge("lruDestroysLimit", lruDestroysLimitDesc, "entries"),
-                f.createLongCounter("lruEvaluations", lruEvaluationsDesc, "entries"),
-                f.createLongCounter("lruGreedyReturns", lruGreedyReturnsDesc, "entries"), });
+    statType = f.createType("HeapLRUStatistics",
+        "Statistics about byte based Least Recently Used region entry disposal",
+        new StatisticDescriptor[] {f.createLongGauge("entryBytes", entryBytesDesc, "bytes"),
+            f.createLongCounter("lruEvictions", lruEvictionsDesc, "entries"),
+            f.createLongCounter("lruDestroys", lruDestroysDesc, "entries"),
+            f.createLongGauge("lruDestroysLimit", lruDestroysLimitDesc, "entries"),
+            f.createLongCounter("lruEvaluations", lruEvaluationsDesc, "entries"),
+            f.createLongCounter("lruGreedyReturns", lruGreedyReturnsDesc, "entries"),});
-   * @param evictionAction
-   *          The action that will occur when an entry is evicted
+   * @param evictionAction The action that will occur when an entry is evicted
-  public HeapLRUCapacityController(ObjectSizer sizerImpl,EvictionAction evictionAction, Region region) {
+  public HeapLRUCapacityController(ObjectSizer sizerImpl, EvictionAction evictionAction,
+      Region region) {
-  public void setLimit(int maximum) {
-  }
+  public void setLimit(int maximum) {}
+   * 
-   * Note that we just need to make sure that equal objects return equal
-   * hashcodes; nothing really elaborate is done here.
+   * Note that we just need to make sure that equal objects return equal hashcodes; nothing really
+   * elaborate is done here.
-  
+
-    return LocalizedStrings.HeapLRUCapacityController_HEAPLRUCAPACITYCONTROLLER_WITH_A_CAPACITY_OF_0_OF_HEAP_AND_AN_THREAD_INTERVAL_OF_1_AND_EVICTION_ACTION_2.toLocalizedString(new Object[] { Long.valueOf(this.getLimit()), this.getEvictionAction()});
+    return LocalizedStrings.HeapLRUCapacityController_HEAPLRUCAPACITYCONTROLLER_WITH_A_CAPACITY_OF_0_OF_HEAP_AND_AN_THREAD_INTERVAL_OF_1_AND_EVICTION_ACTION_2
+        .toLocalizedString(new Object[] {Long.valueOf(this.getLimit()), this.getEvictionAction()});
-   * Sets the {@link ObjectSizer} used to calculate the size of
-   * objects placed in the cache.
+   * Sets the {@link ObjectSizer} used to calculate the size of objects placed in the cache.
-   * @param sizer
-   *        The name of the sizer class
+   * @param sizer The name of the sizer class
-  
+
-       * Indicate what kind of <code>EvictionAlgorithm</code> this helper
-       * implements
+       * Indicate what kind of <code>EvictionAlgorithm</code> this helper implements
-      public int entrySize(Object key, Object value)
-          throws IllegalArgumentException {
+      public int entrySize(Object key, Object value) throws IllegalArgumentException {
-        
+
-       * In addition to initializing the statistics, create an evictor thread to
-       * periodically evict the LRU entry.
+       * In addition to initializing the statistics, create an evictor thread to periodically evict
+       * the LRU entry.
-        final LRUStatistics stats
-          = new HeapLRUStatistics(sf, getRegionName(), this);
+        final LRUStatistics stats = new HeapLRUStatistics(sf, getRegionName(), this);
-      
+
-       * Okay, deep breath. Instead of basing the LRU calculation on the number
-       * of entries in the region or on their "size" (which turned out to be
-       * incorrectly estimated in the general case), we use the amount of
-       * memory currently in use. If the amount of memory current in use
-       * {@linkplain Runtime#maxMemory max memory} -
-       * {@linkplain Runtime#freeMemory free memory} is greater than the
-       * overflow threshold, then we evict the LRU entry.
+       * Okay, deep breath. Instead of basing the LRU calculation on the number of entries in the
+       * region or on their "size" (which turned out to be incorrectly estimated in the general
+       * case), we use the amount of memory currently in use. If the amount of memory current in use
+       * {@linkplain Runtime#maxMemory max memory} - {@linkplain Runtime#freeMemory free memory} is
+       * greater than the overflow threshold, then we evict the LRU entry.
-        
+
-        
+
-        
+
-        
+
-   * Return the size of an object as stored in GemFire... Typically this is the
-   * serialized size in bytes.. This implementation is slow.... Need to add
-   * Sizer interface and call it for customer objects.
+   * Return the size of an object as stored in GemFire... Typically this is the serialized size in
+   * bytes.. This implementation is slow.... Need to add Sizer interface and call it for customer
+   * objects.

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
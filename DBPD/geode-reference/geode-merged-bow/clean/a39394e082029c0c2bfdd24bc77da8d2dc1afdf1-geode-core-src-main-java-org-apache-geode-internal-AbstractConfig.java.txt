GEODE-4320: Reconcile disparity between Banner and AbstractConfig


-import static org.apache.geode.distributed.ConfigurationProperties.*;
+import static org.apache.geode.distributed.ConfigurationProperties.MEMBERSHIP_PORT_RANGE;
+import static org.apache.geode.distributed.ConfigurationProperties.SECURITY_SHIRO_INIT;
-import org.apache.geode.distributed.internal.DistributionConfig;
+import org.apache.geode.internal.util.ArgumentRedactor;
-  public static final String GEM_FIRE_PROPERTIES_USING_DEFAULT_VALUES =
+  private static final String GEM_FIRE_PROPERTIES_USING_DEFAULT_VALUES =
-  public static final String GEM_FIRE_PROPERTIES_DEFINED_WITH_PREFIX =
+  private static final String GEM_FIRE_PROPERTIES_DEFINED_WITH_PREFIX =
-  public static final String GEM_FIRE_PROPERTIES_DEFINED_WITH_SUFFIX = " ###";
-
-  /**
-   * Returns the string to use as the exception message when an attempt is made to set an
-   * unmodifiable attribute.
-   */
-  protected String _getUnmodifiableMsg(String attName) {
-    return LocalizedStrings.AbstractConfig_THE_0_CONFIGURATION_ATTRIBUTE_CAN_NOT_BE_MODIFIED
-        .toLocalizedString(attName);
-  }
-
-  /**
-   * Returns a map that contains attribute descriptions
-   */
-  protected abstract Map getAttDescMap();
-
-  protected abstract Map<String, ConfigSource> getAttSourceMap();
-
-  public static final String sourceHeader = "PropertiesSourceHeader";
-
-  /**
-   * Set to true if most of the attributes can be modified. Set to false if most of the attributes
-   * are read only.
-   */
-  protected boolean _modifiableDefault() {
-    return false;
-  }
+  private static final String GEM_FIRE_PROPERTIES_DEFINED_WITH_SUFFIX = " ###";
-    return getClass().getName() + "@" + Integer.toHexString(hashCode());
+    return super.toString();
-   * @param source
-   *
-    Map<String, String> configProps = new HashMap<String, String>();
+    Map<String, String> configProps = new HashMap<>();
-    for (int i = 0; i < validAttributeNames.length; i++) {
-      String attName = validAttributeNames[i];
-      if (source == null) {
-        if (sm.get(attName) != null) {
-          continue;
-        }
-      } else if (!source.equals(sm.get(attName))) {
+    for (String attName : validAttributeNames) {
+      if ((source == null && sm.get(attName) != null)
+          || (source != null && !source.equals(sm.get(attName)))) {
-    Map<String, String> configProps = new HashMap<String, String>();
+    Map<String, String> configProps = new HashMap<>();
-  private List<ConfigSource> getFileSources() {
-    ArrayList<ConfigSource> result = new ArrayList<ConfigSource>();
-    for (ConfigSource cs : getAttSourceMap().values()) {
-      if (cs.getType() == ConfigSource.Type.FILE || cs.getType() == ConfigSource.Type.SECURE_FILE) {
-        if (!result.contains(cs)) {
-          result.add(cs);
-        }
-      }
-    }
-    return result;
-  }
-
-  private void printSourceSection(ConfigSource source, PrintWriter pw) {
-    String[] validAttributeNames = getAttributeNames();
-    boolean sourceFound = false;
-    Map<String, ConfigSource> sm = getAttSourceMap();
-    boolean secureSource = false;
-    if (source != null && source.getType() == ConfigSource.Type.SECURE_FILE) {
-      secureSource = true;
-    }
-    for (int i = 0; i < validAttributeNames.length; i++) {
-      String attName = validAttributeNames[i];
-      if (source == null) {
-        if (sm.get(attName) != null) {
-          continue;
-        }
-      } else if (!source.equals(sm.get(attName))) {
-        continue;
-      }
-      if (!sourceFound) {
-        sourceFound = true;
-        if (source == null) {
-          pw.println(GEM_FIRE_PROPERTIES_USING_DEFAULT_VALUES);
-        } else {
-          pw.println(GEM_FIRE_PROPERTIES_DEFINED_WITH_PREFIX + source.getDescription()
-              + GEM_FIRE_PROPERTIES_DEFINED_WITH_SUFFIX);
-        }
-      }
-      // hide the shiro-init configuration for now. Remove after we can allow customer to specify
-      // shiro.ini file
-      if (attName.equals(SECURITY_SHIRO_INIT)) {
-        continue;
-      }
-      pw.print(attName);
-      pw.print('=');
-      if (source == null // always show defaults
-          || (!secureSource // show no values from a secure source
-              && okToDisplayPropertyValue(attName))) {
-        pw.println(getAttribute(attName));
-      } else {
-        pw.println("********");
-      }
-    }
-  }
-
-  private boolean okToDisplayPropertyValue(String attName) {
-    if (attName.startsWith(SECURITY_PREFIX)) {
-      return false;
-    }
-    if (attName.startsWith(DistributionConfig.SSL_SYSTEM_PROPS_NAME)) {
-      return false;
-    }
-    if (attName.startsWith(DistributionConfig.SYS_PROP_NAME)) {
-      return false;
-    }
-    return !attName.toLowerCase().contains("password");
-  }
-
-  /**
-   * This class was added to fix bug 39382. It does this be overriding "keys" which is used by the
-   * store0 implementation of Properties.
-   */
-  protected static class SortedProperties extends Properties {
-
-    private static final long serialVersionUID = 7156507110684631135L;
-
-    @Override
-    public Enumeration keys() {
-      // the TreeSet gets the sorting we desire but is only safe
-      // because the keys in this context are always String which is Comparable
-      return Collections.enumeration(new TreeSet(keySet()));
-    }
-  }
-
-  public boolean isDeprecated(String attName) {
-    return false;
-  }
-
+  @Override
-    for (int i = 0; i < attNames.length; i++) {
-      if (isDeprecated(attNames[i])) {
-        continue;
-      }
-      result.setProperty(attNames[i], getAttribute(attNames[i]));
+    for (String attName : attNames) {
+      result.setProperty(attName, getAttribute(attName));
+  @Override
-    FileOutputStream out = new FileOutputStream(f);
-    try {
+    try (FileOutputStream out = new FileOutputStream(f)) {
-    } finally {
-      out.close();
+  @Override
-    for (int i = 0; i < validAttributeNames.length; i++) {
-      String attName = validAttributeNames[i];
-      if (this.isDeprecated(attName)) {
-        // since toProperties skips isDeprecated sameAs
-        // needs to also skip them.
-        // See GEODE-405.
-        continue;
-      }
+    for (String attName : validAttributeNames) {
-      if (thisAtt == otherAtt) {
-        continue;
-      } else if (thisAtt == null) {
-        return false;
-      } else if (thisAtt.getClass().isArray()) {
-        int thisLength = Array.getLength(thisAtt);
-        int otherLength = Array.getLength(otherAtt);
-        if (thisLength != otherLength) {
+      if (thisAtt != otherAtt) {
+        if (thisAtt == null) {
-        }
-        for (int j = 0; j < thisLength; j++) {
-          Object thisArrObj = Array.get(thisAtt, j);
-          Object otherArrObj = Array.get(otherAtt, j);
-          if (thisArrObj == otherArrObj) {
-            continue;
-          } else if (thisArrObj == null) {
-            return false;
-          } else if (!thisArrObj.equals(otherArrObj)) {
+        } else if (thisAtt.getClass().isArray()) {
+          int thisLength = Array.getLength(thisAtt);
+          int otherLength = Array.getLength(otherAtt);
+          if (thisLength != otherLength) {
+          for (int j = 0; j < thisLength; j++) {
+            Object thisArrObj = Array.get(thisAtt, j);
+            Object otherArrObj = Array.get(otherAtt, j);
+            if (thisArrObj != otherArrObj) {
+              if (thisArrObj == null) {
+                return false;
+              } else if (!thisArrObj.equals(otherArrObj)) {
+                return false;
+              }
+            }
+          }
+        } else if (!thisAtt.equals(otherAtt)) {
+          return false;
-      } else if (!thisAtt.equals(otherAtt)) {
-        return false;
-  protected void checkAttributeName(String attName) {
-    String[] validAttNames = getAttributeNames();
-    if (!Arrays.asList(validAttNames).contains(attName.toLowerCase())) {
-      throw new IllegalArgumentException(
-          LocalizedStrings.AbstractConfig_UNKNOWN_CONFIGURATION_ATTRIBUTE_NAME_0_VALID_ATTRIBUTE_NAMES_ARE_1
-              .toLocalizedString(new Object[] {attName, SystemAdmin.join(validAttNames)}));
-    }
-  }
+  @Override
-      String addrName = null;
+      String addrName;
+  @Override
+  @Override
-        attObjectValue = commaDelimitedStringToStringArray(attValue);
+        attObjectValue = attValue.split(",");
-        value[0] = Integer.valueOf(attValue.substring(0, minus)).intValue();
-        value[1] = Integer.valueOf(attValue.substring(minus + 1)).intValue();
+        value[0] = Integer.valueOf(attValue.substring(0, minus));
+        value[1] = Integer.valueOf(attValue.substring(minus + 1));
-                  .toLocalizedString(new Object[] {attName, attValue, ex.toString()}));
+                  .toLocalizedString(attName, attValue, ex.toString()));
-          String trimAttName = trimAttributeName(attName);
+          String trimAttName = attName.substring(0, attName.length() - 1);
-                  .toLocalizedString(new Object[] {attName, attValue}));
+                  .toLocalizedString(attName, attValue));
-        int credits = 0;
-        float thresh = (float) 0.0;
-        int waittime = 0;
+        int allowance;
+        float threshold;
+        int waitTime;
-          credits = Integer.parseInt(values[0].trim());
-          thresh = Float.valueOf(values[1].trim()).floatValue();
-          waittime = Integer.parseInt(values[2].trim());
+          allowance = Integer.parseInt(values[0].trim());
+          threshold = Float.valueOf(values[1].trim());
+          waitTime = Integer.parseInt(values[2].trim());
-                  .toLocalizedString(new Object[] {attName, attValue}));
+                  .toLocalizedString(attName, attValue));
-        attObjectValue = new FlowControlParams(credits, thresh, waittime);
+        attObjectValue = new FlowControlParams(allowance, threshold, waitTime);
-                .toLocalizedString(new Object[] {valueType, attName}));
+                .toLocalizedString(valueType, attName));
-    } catch (NumberFormatException ex)
-
-    {
+    } catch (NumberFormatException ex) {
-          .toLocalizedString(new Object[] {attName, attValue}));
+          .toLocalizedString(attName, attValue));
-
-  private String[] commaDelimitedStringToStringArray(final String tokenizeString) {
-    StringTokenizer stringTokenizer = new StringTokenizer(tokenizeString, ",");
-    String[] strings = new String[stringTokenizer.countTokens()];
-    for (int i = 0; i < strings.length; i++) {
-      strings[i] = stringTokenizer.nextToken();
+  @Override
+  public String getAttributeDescription(String attName) {
+    checkAttributeName(attName);
+    if (!getAttDescMap().containsKey(attName)) {
+      throw new InternalGemFireException(
+          LocalizedStrings.AbstractConfig_UNHANDLED_ATTRIBUTE_NAME_0.toLocalizedString(attName));
-    return strings;
+    return (String) getAttDescMap().get(attName);
+  }
+
+  /**
+   * Returns the string to use as the exception message when an attempt is made to set an
+   * unmodifiable attribute.
+   */
+  protected String _getUnmodifiableMsg(String attName) {
+    return LocalizedStrings.AbstractConfig_THE_0_CONFIGURATION_ATTRIBUTE_CAN_NOT_BE_MODIFIED
+        .toLocalizedString(attName);
+  }
+
+  /**
+   * Returns a map that contains attribute descriptions
+   */
+  protected abstract Map getAttDescMap();
+
+  protected abstract Map<String, ConfigSource> getAttSourceMap();
+
+  /**
+   * Set to true if most of the attributes can be modified. Set to false if most of the attributes
+   * are read only.
+   */
+  protected boolean _modifiableDefault() {
+    return false;
+  }
+
+  protected void checkAttributeName(String attName) {
+    String[] validAttNames = getAttributeNames();
+    if (!Arrays.asList(validAttNames).contains(attName.toLowerCase())) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.AbstractConfig_UNKNOWN_CONFIGURATION_ATTRIBUTE_NAME_0_VALID_ATTRIBUTE_NAMES_ARE_1
+              .toLocalizedString(attName, SystemAdmin.join(validAttNames)));
+    }
+  }
+
+  private List<ConfigSource> getFileSources() {
+    ArrayList<ConfigSource> result = new ArrayList<>();
+    for (ConfigSource cs : getAttSourceMap().values()) {
+      if (cs.getType() == ConfigSource.Type.FILE || cs.getType() == ConfigSource.Type.SECURE_FILE) {
+        if (!result.contains(cs)) {
+          result.add(cs);
+        }
+      }
+    }
+    return result;
+  }
+
+  private void printSourceSection(ConfigSource source, PrintWriter pw) {
+    String[] validAttributeNames = getAttributeNames();
+    boolean sourceFound = false;
+    Map<String, ConfigSource> sourceMap = getAttSourceMap();
+    boolean sourceIsSecured = false;
+    if (source != null && source.getType() == ConfigSource.Type.SECURE_FILE) {
+      sourceIsSecured = true;
+    }
+    for (String attName : validAttributeNames) {
+      if (source == null) {
+        if (sourceMap.get(attName) != null) {
+          continue;
+        }
+      } else if (!source.equals(sourceMap.get(attName))) {
+        continue;
+      }
+      if (!sourceFound) {
+        sourceFound = true;
+        if (source == null) {
+          pw.println(GEM_FIRE_PROPERTIES_USING_DEFAULT_VALUES);
+        } else {
+          pw.println(GEM_FIRE_PROPERTIES_DEFINED_WITH_PREFIX + source.getDescription()
+              + GEM_FIRE_PROPERTIES_DEFINED_WITH_SUFFIX);
+        }
+      }
+      // hide the shiro-init configuration for now. Remove after we can allow customer to specify
+      // shiro.ini file
+      if (attName.equals(SECURITY_SHIRO_INIT)) {
+        continue;
+      }
+
+      String attributeValueToPrint;
+      if (source == null) {
+        // always show defaults values
+        attributeValueToPrint = getAttribute(attName);
+      } else if (sourceIsSecured) {
+        // Never show secure sources
+        attributeValueToPrint = ArgumentRedactor.redacted;
+      } else {
+        // Otherwise, redact based on the key string
+        attributeValueToPrint =
+            ArgumentRedactor.redactValueIfNecessary(attName, getAttribute(attName));
+      }
+      pw.print(attName);
+      pw.print('=');
+      pw.println(attributeValueToPrint);
+    }
-   * Removes the last character of the input string and returns the trimmed name
+   * This class was added to fix bug 39382. It does this be overriding "keys" which is used by the
+   * store0 implementation of Properties.
-  protected static String trimAttributeName(String attName) {
-    return attName.substring(0, attName.length() - 1);
-  }
+  protected static class SortedProperties extends Properties {
-  public String getAttributeDescription(String attName) {
-    checkAttributeName(attName);
-    if (!getAttDescMap().containsKey(attName)) {
-      throw new InternalGemFireException(
-          LocalizedStrings.AbstractConfig_UNHANDLED_ATTRIBUTE_NAME_0.toLocalizedString(attName));
+    private static final long serialVersionUID = 7156507110684631135L;
+
+    @Override
+    public Enumeration keys() {
+      // the TreeSet gets the sorting we desire but is only safe
+      // because the keys in this context are always String which is Comparable
+      return Collections.enumeration(new TreeSet(keySet()));
-    return (String) getAttDescMap().get(attName);

MOV26 INS26 MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 MOV55 MOV31 MOV31 UPD40 UPD40 INS40 INS31 UPD83 UPD83 UPD83 INS78 MOV83 MOV43 MOV42 INS8 INS78 INS78 INS78 INS78 INS78 INS78 INS60 INS70 MOV60 INS42 MOV60 MOV60 INS70 MOV41 INS42 INS42 INS70 INS42 INS42 INS42 INS42 INS70 INS48 MOV74 INS59 INS44 INS42 MOV8 MOV44 INS42 MOV8 INS58 MOV44 INS42 MOV8 MOV74 INS59 MOV44 INS42 MOV8 INS42 UPD42 MOV42 INS14 INS43 INS42 MOV43 MOV59 INS42 INS14 UPD42 UPD42 INS60 INS25 MOV21 INS74 INS42 INS27 MOV8 UPD74 UPD27 MOV43 INS74 MOV42 MOV27 INS43 INS59 MOV27 INS8 INS25 MOV43 INS36 INS36 UPD42 UPD42 INS42 MOV25 MOV43 UPD42 INS42 INS42 INS21 INS42 INS8 INS8 INS42 INS27 INS27 MOV43 INS42 MOV32 MOV18 INS7 INS21 INS21 MOV27 MOV27 INS27 MOV38 INS42 INS42 INS42 INS32 INS7 INS7 INS42 INS33 UPD42 UPD42 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS45 INS42 UPD42 MOV42 MOV42 INS32 INS42 INS42 UPD27 MOV25 MOV32 MOV32 UPD42 UPD42 UPD42 MOV42 UPD42 UPD42 UPD42 INS42 INS42 MOV32 MOV42 MOV42 MOV34 MOV27 MOV43 UPD42 UPD42 MOV32 UPD42 INS42 INS42 INS42 INS42 MOV42 INS42 INS42 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL23 DEL42 DEL32 DEL42 DEL32 DEL45 DEL42 DEL42 DEL42 DEL32 DEL32 DEL27 DEL42 DEL65 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL25 DEL8 DEL18 DEL8 DEL25 DEL39 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL24 DEL42 DEL43 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL83 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL9 DEL41 DEL8 DEL25 DEL42 DEL42 DEL40 DEL32 DEL9 DEL41 DEL8 DEL25 DEL42 DEL42 DEL40 DEL32 DEL9 DEL41 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL45 DEL32 DEL38 DEL41 DEL8 DEL31 DEL39 DEL42 DEL9 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL42 DEL2 DEL32 DEL18 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL2 DEL42 DEL42 DEL42 DEL2 DEL32 DEL32 DEL21 DEL8 DEL24 DEL8 DEL31 DEL60 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL52 DEL42 DEL42 DEL32 DEL18 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL24 DEL42 DEL43 DEL33 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL34 DEL39 DEL34 DEL11 DEL34 DEL42 DEL32 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL4 DEL3 DEL83 DEL42 DEL43 DEL85 DEL5 DEL42 DEL83 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL45 DEL14 DEL59 DEL60 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL32 DEL3 DEL59 DEL60 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL42 DEL42 DEL2 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL24 DEL42 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL83 DEL42 DEL41 DEL8 DEL31 DEL42 DEL43 DEL85 DEL5 DEL42 DEL4 DEL3 DEL42 DEL43 DEL74 DEL42 DEL14 DEL59 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL45 DEL42 DEL38 DEL32 DEL27 DEL36 DEL27 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL24
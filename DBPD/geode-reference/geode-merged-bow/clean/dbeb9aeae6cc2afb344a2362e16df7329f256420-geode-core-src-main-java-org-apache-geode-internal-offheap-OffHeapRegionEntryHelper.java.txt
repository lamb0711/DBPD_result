Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * The class just has static methods
- * that operate on instances of {@link OffHeapRegionEntry}.
- * It allows common code to be shared for all the
- * classes we have that implement {@link OffHeapRegionEntry}.
+ * The class just has static methods that operate on instances of {@link OffHeapRegionEntry}. It
+ * allows common code to be shared for all the classes we have that implement
+ * {@link OffHeapRegionEntry}.
-  protected static final long NULL_ADDRESS = 0L<<1;
-  protected static final long INVALID_ADDRESS = 1L<<1;
-  protected static final long LOCAL_INVALID_ADDRESS = 2L<<1;
-  protected static final long DESTROYED_ADDRESS = 3L<<1;
-  protected static final long REMOVED_PHASE1_ADDRESS = 4L<<1;
-  protected static final long REMOVED_PHASE2_ADDRESS = 5L<<1;
-  protected static final long END_OF_STREAM_ADDRESS = 6L<<1;
-  protected static final long NOT_AVAILABLE_ADDRESS = 7L<<1;
-  protected static final long TOMBSTONE_ADDRESS = 8L<<1;
+  protected static final long NULL_ADDRESS = 0L << 1;
+  protected static final long INVALID_ADDRESS = 1L << 1;
+  protected static final long LOCAL_INVALID_ADDRESS = 2L << 1;
+  protected static final long DESTROYED_ADDRESS = 3L << 1;
+  protected static final long REMOVED_PHASE1_ADDRESS = 4L << 1;
+  protected static final long REMOVED_PHASE2_ADDRESS = 5L << 1;
+  protected static final long END_OF_STREAM_ADDRESS = 6L << 1;
+  protected static final long NOT_AVAILABLE_ADDRESS = 7L << 1;
+  protected static final long TOMBSTONE_ADDRESS = 8L << 1;
-  
-  private static final Token[] addrToObj = new Token[]{
-    null,
-    Token.INVALID,
-    Token.LOCAL_INVALID,
-    Token.DESTROYED,
-    Token.REMOVED_PHASE1,
-    Token.REMOVED_PHASE2,
-    Token.END_OF_STREAM,
-    Token.NOT_AVAILABLE,
-    Token.TOMBSTONE,
-  };
-  
+
+  private static final Token[] addrToObj =
+      new Token[] {null, Token.INVALID, Token.LOCAL_INVALID, Token.DESTROYED, Token.REMOVED_PHASE1,
+          Token.REMOVED_PHASE2, Token.END_OF_STREAM, Token.NOT_AVAILABLE, Token.TOMBSTONE,};
+
-    if (v instanceof StoredObject) return ((StoredObject) v).getAddress();
-    if (v == null) return NULL_ADDRESS;
-    if (v == Token.TOMBSTONE) return TOMBSTONE_ADDRESS;
-    if (v == Token.INVALID) return INVALID_ADDRESS;
-    if (v == Token.LOCAL_INVALID) return LOCAL_INVALID_ADDRESS;
-    if (v == Token.DESTROYED) return DESTROYED_ADDRESS;
-    if (v == Token.REMOVED_PHASE1) return REMOVED_PHASE1_ADDRESS;
-    if (v == Token.REMOVED_PHASE2) return REMOVED_PHASE2_ADDRESS;
-    if (v == Token.END_OF_STREAM) return END_OF_STREAM_ADDRESS;
-    if (v == Token.NOT_AVAILABLE) return NOT_AVAILABLE_ADDRESS;
+    if (v instanceof StoredObject)
+      return ((StoredObject) v).getAddress();
+    if (v == null)
+      return NULL_ADDRESS;
+    if (v == Token.TOMBSTONE)
+      return TOMBSTONE_ADDRESS;
+    if (v == Token.INVALID)
+      return INVALID_ADDRESS;
+    if (v == Token.LOCAL_INVALID)
+      return LOCAL_INVALID_ADDRESS;
+    if (v == Token.DESTROYED)
+      return DESTROYED_ADDRESS;
+    if (v == Token.REMOVED_PHASE1)
+      return REMOVED_PHASE1_ADDRESS;
+    if (v == Token.REMOVED_PHASE2)
+      return REMOVED_PHASE2_ADDRESS;
+    if (v == Token.END_OF_STREAM)
+      return END_OF_STREAM_ADDRESS;
+    if (v == Token.NOT_AVAILABLE)
+      return NOT_AVAILABLE_ADDRESS;
-  
+
-   * This method may release the object stored at ohAddress if the result
-   * needs to be decompressed and the decompress parameter is true.
-   * This decompressed result will be on the heap.
+   * This method may release the object stored at ohAddress if the result needs to be decompressed
+   * and the decompress parameter is true. This decompressed result will be on the heap.
-  @Unretained @Retained
-  public static Object addressToObject(@Released @Retained long ohAddress, boolean decompress, RegionEntryContext context) {
+  @Unretained
+  @Retained
+  public static Object addressToObject(@Released @Retained long ohAddress, boolean decompress,
+      RegionEntryContext context) {
-      @Unretained OffHeapStoredObject chunk =  new OffHeapStoredObject(ohAddress);
-      @Unretained Object result = chunk;
+      @Unretained
+      OffHeapStoredObject chunk = new OffHeapStoredObject(ohAddress);
+      @Unretained
+      Object result = chunk;
-            // return a VMCachedDeserializable with the decompressed serialized bytes since chunk is serialized
+            // return a VMCachedDeserializable with the decompressed serialized bytes since chunk is
+            // serialized
-          // we would return it. But we have unwrapped it and are returning the decompressed results.
+          // we would return it. But we have unwrapped it and are returning the decompressed
+          // results.
-            chunk.release();
+          chunk.release();
-          // return a VMCachedDeserializable with the decompressed serialized bytes since daa is serialized
+          // return a VMCachedDeserializable with the decompressed serialized bytes since daa is
+          // serialized
-      return addrToObj[(int) ohAddress>>1];
+      return addrToObj[(int) ohAddress >> 1];
-  
+
-    
-     if ((ohAddress & ENCODED_BIT) != 0) {     
-      boolean isLong = (ohAddress & LONG_BIT) != 0;     
+
+    if ((ohAddress & ENCODED_BIT) != 0) {
+      boolean isLong = (ohAddress & LONG_BIT) != 0;
-       return 9;
+        return 9;
-        return (int) ((ohAddress & SIZE_MASK) >> SIZE_SHIFT);        
-      }     
+        return (int) ((ohAddress & SIZE_MASK) >> SIZE_SHIFT);
+      }
-  
- /*
-  * This method is optimized for cases where if the caller wants to convert address to a Token
-  * compared to addressToObject which would deserialize the value.
-  */
+
+  /*
+   * This method is optimized for cases where if the caller wants to convert address to a Token
+   * compared to addressToObject which would deserialize the value.
+   */
-      return addrToObj[(int) ohAddress>>1];
+      return addrToObj[(int) ohAddress >> 1];
-  
+
-  public static void releaseEntry(@Unretained OffHeapRegionEntry re, @Released StoredObject expectedValue) {
+  public static void releaseEntry(@Unretained OffHeapRegionEntry re,
+      @Released StoredObject expectedValue) {
-    } /*else {
-      if (!calledSetValue || re.getAddress() != newAddress) {
-        expectedValue.release();
-      }
-    }*/
+    } /*
+       * else { if (!calledSetValue || re.getAddress() != newAddress) { expectedValue.release(); } }
+       */
-  
+
-  
+
-      for (int i=0; i < v.length; i++) {
+      for (int i = 0; i < v.length; i++) {
-          for (int i=2; i < v.length; i++) {
+          for (int i = 2; i < v.length; i++) {
-      byte[] bytes = decodeUncompressedAddressToBytes(ohAddress);
+    byte[] bytes = decodeUncompressedAddressToBytes(ohAddress);
-      boolean isSerialized = (ohAddress & SERIALIZED_BIT) != 0;
-      if (isSerialized) {
-         return EntryEventImpl.deserialize(bytes);
-      } else {
-          return bytes;
-      }
+    boolean isSerialized = (ohAddress & SERIALIZED_BIT) != 0;
+    if (isSerialized) {
+      return EntryEventImpl.deserialize(bytes);
+    } else {
+      return bytes;
+    }
-  
+
-   * Returns the bytes encoded in the given address.
-   * Note that compressed addresses are not supported by this method.
+   * Returns the bytes encoded in the given address. Note that compressed addresses are not
+   * supported by this method.
+   * 
-  
+
-   * Returns the "raw" bytes that have been encoded in the given address.
-   * Note that if address is compressed then the raw bytes are the compressed bytes.
+   * Returns the "raw" bytes that have been encoded in the given address. Note that if address is
+   * compressed then the raw bytes are the compressed bytes.
-      for (int i=8; i >=2; i--) {
+      for (int i = 8; i >= 2; i--) {
-      for (int i=size-1; i >=0; i--) {
+      for (int i = size - 1; i >= 0; i--) {
-   * The previous value at the address in 're' will be @Released and then the
-   * address in 're' will be set to the @Unretained address of 'v'.
+   * The previous value at the address in 're' will be @Released and then the address in 're' will
+   * be set to the @Unretained address of 'v'.
- 
+
-    return addressToObject(re.getAddress(), false, null); // no context needed so decompress is false
+    return addressToObject(re.getAddress(), false, null); // no context needed so decompress is
+                                                          // false
-  
+
-    if ((addr & ENCODED_BIT) != 0) return false;
-    if (addr < 0) return true;
+    if ((addr & ENCODED_BIT) != 0)
+      return false;
+    if (addr < 0)
+      return true;
-   * If the value stored at the location held in 're' is returned, then it will
-   * be Retained.  If the value returned is 're' decompressed into another
-   * off-heap location, then 're' will be Unretained but the new,
-   * decompressed value will be Retained.  Therefore, whichever is returned
-   * (the value at the address in 're' or the decompressed value) it will have
-   * been Retained.
+   * If the value stored at the location held in 're' is returned, then it will be Retained. If the
+   * value returned is 're' decompressed into another off-heap location, then 're' will be
+   * Unretained but the new, decompressed value will be Retained. Therefore, whichever is returned
+   * (the value at the address in 're' or the decompressed value) it will have been Retained.
-  public static Object _getValueRetain(@Retained @Unretained OffHeapRegionEntry re, boolean decompress, RegionEntryContext context) {
+  public static Object _getValueRetain(@Retained @Unretained OffHeapRegionEntry re,
+      boolean decompress, RegionEntryContext context) {
-    @Retained long addr = re.getAddress();
+    @Retained
+    long addr = re.getAddress();
-        @Unretained long addr2 = re.getAddress();
+        @Unretained
+        long addr2 = re.getAddress();
-          throw new IllegalStateException("retain failed addr=" + addr + " addr2=" + addr + " 100 times" + " history=" + ReferenceCountHelper.getFreeRefCountInfo(addr));
+          throw new IllegalStateException("retain failed addr=" + addr + " addr2=" + addr
+              + " 100 times" + " history=" + ReferenceCountHelper.getFreeRefCountInfo(addr));
-  
- 
+
+
-  
+
+
+

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66
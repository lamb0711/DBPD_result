Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.InetAddress;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketTimeoutException;
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ScheduledFuture;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.stream.*;
-
-import org.apache.logging.log4j.Logger;
-import org.jgroups.util.UUID;
-
+import org.apache.logging.log4j.Logger;
+import org.jgroups.util.UUID;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.InetAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketTimeoutException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.Timer;
+import java.util.TimerTask;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.stream.Collectors;
- * 
- * This class make sure that each member is alive and communicating to this member.
- * To make sure that we create the ring of members based on current view. On this
- * ring, each member make sure that next-member in ring is communicating with it.
- * For that we record last message timestamp from next-member. And if it sees this
- * member has not communicated in last period(member-timeout) then we check whether
- * this member is still alive or not. Based on that we informed probable coordinators
- * to remove that member from view.
- * 
- * It has {@link #suspect(InternalDistributedMember, String)} api, which can be used
- * to initiate suspect processing for any member. First is checks whether the member is
- * responding or not. Then it informs probable coordinators to remove that member from
- * view.
- * 
- * It has {@link #checkIfAvailable(DistributedMember, String, boolean)} api to see
- * if that member is alive. Then based on removal flag it initiates the suspect processing
- * for that member.
- * 
- * */
-@SuppressWarnings({ "SynchronizationOnLocalVariableOrMethodParameter", "NullableProblems" })
+ * <p>
+ * This class make sure that each member is alive and communicating to this member. To make sure
+ * that we create the ring of members based on current view. On this ring, each member make sure
+ * that next-member in ring is communicating with it. For that we record last message timestamp from
+ * next-member. And if it sees this member has not communicated in last period(member-timeout) then
+ * we check whether this member is still alive or not. Based on that we informed probable
+ * coordinators to remove that member from view.
+ * <p>
+ * It has {@link #suspect(InternalDistributedMember, String)} api, which can be used to initiate
+ * suspect processing for any member. First is checks whether the member is responding or not. Then
+ * it informs probable coordinators to remove that member from view.
+ * <p>
+ * It has {@link #checkIfAvailable(DistributedMember, String, boolean)} api to see if that member is
+ * alive. Then based on removal flag it initiates the suspect processing for that member.
+ */
+@SuppressWarnings({"SynchronizationOnLocalVariableOrMethodParameter", "NullableProblems"})
-  /** membership logger */
-  private static final Logger logger = Services.getLogger();
-  
-   * The number of recipients of periodic heartbeats.  The recipients will
-   * be selected from the members that are likely to be monitoring this member.
+   * membership logger
+   */
+  private static final Logger logger = Services.getLogger();
+
+  /**
+   * The number of recipients of periodic heartbeats. The recipients will be selected from the
+   * members that are likely to be monitoring this member.
-   * Member activity will be recorded per interval/period. Timer task will set interval's starting time.
-   * Each interval will be member-timeout/LOGICAL_INTERVAL. LOGICAL_INTERVAL may be configured
+   * Member activity will be recorded per interval/period. Timer task will set interval's starting
+   * time. Each interval will be member-timeout/LOGICAL_INTERVAL. LOGICAL_INTERVAL may be configured
-  public static final int LOGICAL_INTERVAL = Integer.getInteger("geode.logical-message-received-interval", 2);
+  public static final int LOGICAL_INTERVAL =
+      Integer.getInteger("geode.logical-message-received-interval", 2);
-  /** stall time to wait for members leaving concurrently */
-  public static final long MEMBER_SUSPECT_COLLECTION_INTERVAL = Long.getLong("geode.suspect-member-collection-interval", 200);
+  /**
+   * stall time to wait for members leaving concurrently
+   */
+  public static final long MEMBER_SUSPECT_COLLECTION_INTERVAL =
+      Long.getLong("geode.suspect-member-collection-interval", 200);
-  
-  /** this member's ID */
+
+  /**
+   * this member's ID
+   */
-  final ConcurrentMap<InternalDistributedMember, TimeStamp> memberTimeStamps = new ConcurrentHashMap<>();
-  
+  final ConcurrentMap<InternalDistributedMember, TimeStamp> memberTimeStamps =
+      new ConcurrentHashMap<>();
+
-  final private ConcurrentHashMap<InternalDistributedMember, NetView> suspectedMemberInView = new ConcurrentHashMap<>();
-  
+  final private ConcurrentHashMap<InternalDistributedMember, NetView> suspectedMemberInView =
+      new ConcurrentHashMap<>();
+
-  final private List<InternalDistributedMember> membersInFinalCheck = Collections.synchronizedList(new ArrayList<>(30));
+  final private List<InternalDistributedMember> membersInFinalCheck =
+      Collections.synchronizedList(new ArrayList<>(30));
-  
+
-  
-  /** test hook */
+
+  /**
+   * test hook
+   */
-  /** test hook */
+  /**
+   * test hook
+   */
-  
+
-  static final int ERROR = 0x00;  
+  static final int ERROR = 0x00;
-  
-  /** Statistics about health monitor */
+
+  /**
+   * Statistics about health monitor
+   */
+
-    
+
-   * This class sets start interval timestamp to record the activity of all members.
-   * That is used by {@link GMSHealthMonitor#contactedBy(InternalDistributedMember)} to
-   * record the activity of member.
-   * 
+   * This class sets start interval timestamp to record the activity of all members. That is used by
+   * {@link GMSHealthMonitor#contactedBy(InternalDistributedMember)} to record the activity of
+   * member.
+   *
+
-      
+
-      
+
-      //this is the start of interval to record member activity
+      // this is the start of interval to record member activity
-        synchronized(GMSHealthMonitor.this) {
+        synchronized (GMSHealthMonitor.this) {
-        
+
-        
+
-   * Response will have requestId, which is used to get ResponseObject. Then it is used to
-   * notify waiting thread.
+   * Response will have requestId, which is used to get ResponseObject. Then it is used to notify
+   * waiting thread.
+
-        int  vmViewId = in.readInt();
+        int vmViewId = in.readInt();
-                   && uuidMSBs == myUUID.getMostSignificantBits()
-                   && vmViewId == myVmViewId) {
+            && uuidMSBs == myUUID.getMostSignificantBits() && vmViewId == myVmViewId) {
-            logger.debug("HealthMonitor: sending ERROR reply - my UUID is {},{} received is {},{}.  My viewID is {} received is {}", 
-              Long.toHexString(myUUID.getMostSignificantBits()),
-              Long.toHexString(myUUID.getLeastSignificantBits()), 
-              Long.toHexString(uuidMSBs),
-              Long.toHexString(uuidLSBs),
-              myVmViewId, vmViewId);
+            logger.debug(
+                "HealthMonitor: sending ERROR reply - my UUID is {},{} received is {},{}.  My viewID is {} received is {}",
+                Long.toHexString(myUUID.getMostSignificantBits()),
+                Long.toHexString(myUUID.getLeastSignificantBits()), Long.toHexString(uuidMSBs),
+                Long.toHexString(uuidLSBs), myVmViewId, vmViewId);
-  public static void loadEmergencyClasses() {
-  }
+  public static void loadEmergencyClasses() {}
-  
-  
+
+
+      setNextNeighbor(currentView, null);
-    setNextNeighbor(currentView, null);
-  
-  private HeartbeatRequestMessage constructHeartbeatRequestMessage(final InternalDistributedMember mbr) {
+
+  private HeartbeatRequestMessage constructHeartbeatRequestMessage(
+      final InternalDistributedMember mbr) {
-        
+
-   * This method sends heartbeat request to other member and waits for member-timeout
-   * time for response. If it doesn't see response then it returns false.
+   * This method sends heartbeat request to other member and waits for member-timeout time for
+   * response. If it doesn't see response then it returns false.
-      } else if (waitForResponse){
+      } else if (waitForResponse) {
-      logger.debug("GMSHealthMonitor checking thread interrupted, while waiting for response from member: {} .", member);
+      logger.debug(
+          "GMSHealthMonitor checking thread interrupted, while waiting for response from member: {} .",
+          member);
-      if(waitForResponse) {
+      if (waitForResponse) {
-   * During final check, establish TCP connection between current member and suspect member.
-   * And exchange PING/PONG message to see if the suspect member is still alive.
+   * During final check, establish TCP connection between current member and suspect member. And
+   * exchange PING/PONG message to see if the suspect member is still alive.
-    InternalDistributedSystem internalDistributedSystem = InternalDistributedSystem.getConnectedInstance();
+    InternalDistributedSystem internalDistributedSystem =
+        InternalDistributedSystem.getConnectedInstance();
-      logger.debug("Checking member {} with TCP socket connection {}:{}.", suspectMember, suspectMember.getInetAddress(), port);
-      clientSocket = SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER).connect(suspectMember.getInetAddress(), port,
-          (int)memberTimeout, new ConnectTimeoutTask(services.getTimer(), memberTimeout), false, -1, false);
+      logger.debug("Checking member {} with TCP socket connection {}:{}.", suspectMember,
+          suspectMember.getInetAddress(), port);
+      clientSocket =
+          SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER)
+              .connect(suspectMember.getInetAddress(), port, (int) memberTimeout,
+                  new ConnectTimeoutTask(services.getTimer(), memberTimeout), false, -1, false);
-    }
-    catch (IOException e) {
+    } catch (IOException e) {
-    }
-    catch (IllegalStateException e) {
+    } catch (IllegalStateException e) {
-    }
-    finally {
+    } finally {
-  //Package protected for testing purposes
+  // Package protected for testing purposes
-          logger.debug("Received {}", (b == OK ? "OK" : (b == ERROR ? "ERROR" : "unknown response: " + b)));
+          logger.debug("Received {}",
+              (b == OK ? "OK" : (b == ERROR ? "ERROR" : "unknown response: " + b)));
-          //received ERROR
+          // received ERROR
-    } 
+    }
-  
+
-  
+
-//    synchronized (suspectRequests) {
-//      SuspectRequest sr = new SuspectRequest((InternalDistributedMember) mbr, reason);
-//      if (!suspectRequests.contains(sr)) {
-//        logger.info("Suspecting member {}. Reason= {}.", mbr, reason);
-//        suspectRequests.add(sr);
-//        suspectRequests.notify();
-//      }
-//    }
+    // synchronized (suspectRequests) {
+    // SuspectRequest sr = new SuspectRequest((InternalDistributedMember) mbr, reason);
+    // if (!suspectRequests.contains(sr)) {
+    // logger.info("Suspecting member {}. Reason= {}.", mbr, reason);
+    // suspectRequests.add(sr);
+    // suspectRequests.notify();
+    // }
+    // }
-    return inlineCheckIfAvailable(localAddress, currentView, initiateRemoval, (InternalDistributedMember)mbr, reason);
+    return inlineCheckIfAvailable(localAddress, currentView, initiateRemoval,
+        (InternalDistributedMember) mbr, reason);
-        Thread th = new Thread(Services.getThreadGroup(), r, "Geode Failure Detection thread " + id);
+        Thread th =
+            new Thread(Services.getThreadGroup(), r, "Geode Failure Detection thread " + id);
-//    suspectRequestCollectorThread = this.new RequestCollector<SuspectRequest>("Geode Suspect Message Collector", Services.getThreadGroup(), suspectRequests,
-//        new Callback<SuspectRequest>() {
-//      @Override
-//      public void process(List<SuspectRequest> requests) {
-//        GMSHealthMonitor.this.sendSuspectRequest(requests);
-//
-//      }
-//    }, MEMBER_SUSPECT_COLLECTION_INTERVAL);
-//    suspectRequestCollectorThread.setDaemon(true);
-//    suspectRequestCollectorThread.start()
-    
+    // suspectRequestCollectorThread = this.new RequestCollector<SuspectRequest>("Geode Suspect
+    // Message Collector", Services.getThreadGroup(), suspectRequests,
+    // new Callback<SuspectRequest>() {
+    // @Override
+    // public void process(List<SuspectRequest> requests) {
+    // GMSHealthMonitor.this.sendSuspectRequest(requests);
+    //
+    // }
+    // }, MEMBER_SUSPECT_COLLECTION_INTERVAL);
+    // suspectRequestCollectorThread.setDaemon(true);
+    // suspectRequestCollectorThread.start()
+
-        Thread th = new Thread(Services.getThreadGroup(), r, "Geode Failure Detection Server thread " + id);
+        Thread th =
+            new Thread(Services.getThreadGroup(), r, "Geode Failure Detection Server thread " + id);
-      serverSocket = SocketCreatorFactory.getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER).createServerSocketUsingPortRange(socketAddress, 50/*backlog*/,
-        true/*isBindAddress*/, false/*useNIO*/, 65536/*tcpBufferSize*/, portRange, false);
+      serverSocket = SocketCreatorFactory
+          .getSocketCreatorForComponent(SecurableCommunicationChannel.CLUSTER)
+          .createServerSocketUsingPortRange(socketAddress, 50/* backlog */, true/* isBindAddress */,
+              false/* useNIO */, 65536/* tcpBufferSize */, portRange, false);
-      throw new GemFireConfigException("Unable to allocate a failure detection port in the membership-port range", e);
+      throw new GemFireConfigException(
+          "Unable to allocate a failure detection port in the membership-port range", e);
-  
+
-   * start the thread that listens for tcp/ip connections and responds
-   * to connection attempts
+   * start the thread that listens for tcp/ip connections and responds to connection attempts
-      logger.info("Started failure detection server thread on {}:{}.", ssocket.getInetAddress(), socketPort);
+      logger.info("Started failure detection server thread on {}:{}.", ssocket.getInetAddress(),
+          socketPort);
-        while (!services.getCancelCriterion().isCancelInProgress() 
+        while (!services.getCancelCriterion().isCancelInProgress()
-            serverSocketExecutor.execute(new ClientSocketHandler(socket)); //start();  [bruce] I'm seeing a lot of failures due to this thread not being created fast enough, sometimes as long as 30 seconds
-          
+            serverSocketExecutor.execute(new ClientSocketHandler(socket)); // start(); [bruce] I'm
+            // seeing a lot of
+            // failures due to this
+            // thread not being
+            // created fast enough,
+            // sometimes as long as
+            // 30 seconds
+
-  
+
-   * start the thread that periodically sends a message to processes
-   * that might be watching this process
+   * start the thread that periodically sends a message to processes that might be watching this
+   * process
+
-            Thread.sleep(memberTimeout/LOGICAL_INTERVAL);
+            Thread.sleep(memberTimeout / LOGICAL_INTERVAL);
-      
+
-            index = mbrs.size()-1;
+            index = mbrs.size() - 1;
-    for (Iterator<InternalDistributedMember> it=memberTimeStamps.keySet().iterator(); it.hasNext(); ) {
+    for (Iterator<InternalDistributedMember> it = memberTimeStamps.keySet().iterator(); it
+        .hasNext();) {
-    for (Iterator<InternalDistributedMember> it=suspectedMemberInView.keySet().iterator(); it.hasNext(); ) {
+    for (Iterator<InternalDistributedMember> it = suspectedMemberInView.keySet().iterator(); it
+        .hasNext();) {
-//    for (InternalDistributedMember mbr: newView.getMembers()) {
-//      if (!memberVsLastMsgTS.containsKey(mbr)) {
-//        CustomTimeStamp customTS = new CustomTimeStamp(System.currentTimeMillis());
-//        memberVsLastMsgTS.put(mbr, customTS);
-//      }
-//    }
+    // for (InternalDistributedMember mbr: newView.getMembers()) {
+    // if (!memberVsLastMsgTS.containsKey(mbr)) {
+    // CustomTimeStamp customTS = new CustomTimeStamp(System.currentTimeMillis());
+    // memberVsLastMsgTS.put(mbr, customTS);
+    // }
+    // }
+  /**
+   * this method is primarily for tests. The current view should be pulled from JoinLeave or the
+   * MembershipManager (which includes surprise members)
+   */
+  public synchronized NetView getView() {
+    return currentView;
+  }
+
-   * 
-   * if nextTo == null
-   * then it watches member next to it.
-   * 
-   * It becomes null when we suspect current neighbour, during that time it watches
-   * member next to suspect member.
+   *
+   * if nextTo == null then it watches member next to it.
+   *
+   * It becomes null when we suspect current neighbour, during that time it watches member next to
+   * suspect member.
-    
-    Set<InternalDistributedMember> checkAllSuspected = new HashSet<>(allMembers);
-    checkAllSuspected.removeAll(suspectedMemberInView.keySet());
-    checkAllSuspected.remove(localAddress);
-    if (checkAllSuspected.isEmpty() && allMembers.size() > 1) {
-      logger.info("All other members are suspect at this point");
-      nextNeighbor = null;
-      return;
+    //
+    // Set<InternalDistributedMember> checkAllSuspected = new HashSet<>(allMembers);
+    // checkAllSuspected.removeAll(suspectedMemberInView.keySet());
+    // checkAllSuspected.remove(localAddress);
+    // if (checkAllSuspected.isEmpty() && allMembers.size() > 1) {
+    // logger.info("All other members are suspect at this point");
+    // nextNeighbor = null;
+    // return;
+    // }
+
+    if (allMembers.size() > 1 && suspectedMemberInView.size() >= allMembers.size() - 1) {
+      boolean nonSuspectFound = false;
+      for (InternalDistributedMember member : allMembers) {
+        if (member.equals(localAddress)) {
+          continue;
+        }
+        if (!suspectedMemberInView.containsKey(member)) {
+          nonSuspectFound = true;
+          break;
+        }
+      }
+      if (!nonSuspectFound) {
+        logger.info("All other members are suspect at this point");
+        nextNeighbor = null;
+        return;
+      }
-    
+
-    
+
-  
+
-    setLocalAddress( services.getMessenger().getMemberID());
-    serverSocket = createServerSocket(localAddress.getInetAddress(), services.getConfig().getMembershipPortRange());
+    setLocalAddress(services.getMessenger().getMemberID());
+    serverSocket = createServerSocket(localAddress.getInetAddress(),
+        services.getConfig().getMembershipPortRange());
-        }
-        catch (IOException e) {
+        } catch (IOException e) {
-      }      
+      }
-      logger.info("GMSHealthMonitor serverSocketExecutor is " + (serverSocketExecutor.isTerminated() ? "terminated" : "not terminated"));
+      logger.info("GMSHealthMonitor serverSocketExecutor is "
+          + (serverSocketExecutor.isTerminated() ? "terminated" : "not terminated"));
-    
-//    if (suspectRequestCollectorThread != null) {
-//      suspectRequestCollectorThread.shutdown();
-//    }
+
+    // if (suspectRequestCollectorThread != null) {
+    // suspectRequestCollectorThread.shutdown();
+    // }
-    return scheduler.isShutdown() && checkExecutor.isShutdown() && serverSocketExecutor.isShutdown() /*&& !suspectRequestCollectorThread.isAlive()*/;
+    return scheduler.isShutdown() && checkExecutor.isShutdown()
+        && serverSocketExecutor.isShutdown() /* && !suspectRequestCollectorThread.isAlive() */;
-  public void memberSuspected(InternalDistributedMember initiator, InternalDistributedMember suspect, String reason) {
-  }
+  public void memberSuspected(InternalDistributedMember initiator,
+      InternalDistributedMember suspect, String reason) {}
-  
+
-    case HEARTBEAT_REQUEST:
-      if (beingSick || playingDead) {
-        logger.debug("sick member is ignoring check request");
-      } else {
-        processHeartbeatRequest((HeartbeatRequestMessage) m);
-      }
-      break;
-    case HEARTBEAT_RESPONSE:
-      if (beingSick || playingDead) {
-        logger.debug("sick member is ignoring check response");
-      } else {
-        processHeartbeat((HeartbeatMessage) m);
-      }
-      break;
-    case SUSPECT_MEMBERS_MESSAGE:
-      if (beingSick || playingDead) {
-        logger.debug("sick member is ignoring suspect message");
-      } else {
-        processSuspectMembersRequest((SuspectMembersMessage) m);
-      }
-      break;
-    default:
-      throw new IllegalArgumentException("unknown message type: " + m);
+      case HEARTBEAT_REQUEST:
+        if (beingSick || playingDead) {
+          logger.debug("sick member is ignoring check request");
+        } else {
+          processHeartbeatRequest((HeartbeatRequestMessage) m);
+        }
+        break;
+      case HEARTBEAT_RESPONSE:
+        if (beingSick || playingDead) {
+          logger.debug("sick member is ignoring check response");
+        } else {
+          processHeartbeat((HeartbeatMessage) m);
+        }
+        break;
+      case SUSPECT_MEMBERS_MESSAGE:
+        if (beingSick || playingDead) {
+          logger.debug("sick member is ignoring suspect message");
+        } else {
+          processSuspectMembersRequest((SuspectMembersMessage) m);
+        }
+        break;
+      default:
+        throw new IllegalArgumentException("unknown message type: " + m);
-    
+
-    
+
-    
+
-    if (me.getVmViewId() >= 0  &&  m.getTarget().equals(me)) {
+    if (me.getVmViewId() >= 0 && m.getTarget().equals(me)) {
-    if (m.getRequestId() < 0) {
-      // a periodic heartbeat
-      contactedBy(m.getSender(), System.currentTimeMillis());
-    } else {
+    if (m.getRequestId() >= 0) {
-      logger.trace("Got heartbeat from member {}. {}", m.getSender(), (resp != null ? "Check thread still waiting" : "Check thread is not waiting"));
+      logger.trace("Got heartbeat from member {}. {}", m.getSender(),
+          (resp != null ? "Check thread still waiting" : "Check thread is not waiting"));
-      //we got heartbeat lets update timestamp
-      contactedBy(m.getSender(), System.currentTimeMillis());
+
+    // we got heartbeat lets update timestamp
+    contactedBy(m.getSender(), System.currentTimeMillis());
-   * Process a Suspect request from another member. This may cause this member
-   * to become the new membership coordinator.
-   * it will to final check on that member and then it will send remove request
-   * for that member
+   * Process a Suspect request from another member. This may cause this member to become the new
+   * membership coordinator. it will to final check on that member and then it will send remove
+   * request for that member
-    
+
-    
+
-      logger.info("Membership ignoring suspect request for " + incomingRequest + " from non-member " + incomingRequest.getSender());
-      services.getJoinLeave().remove(sender, "this process is initiating suspect processing but is no longer a member");
+      logger.info("Membership ignoring suspect request for " + incomingRequest + " from non-member "
+          + incomingRequest.getSender());
+      services.getJoinLeave().remove(sender,
+          "this process is initiating suspect processing but is no longer a member");
-      for (Iterator<SuspectRequest> it = incomingRequest.getMembers().iterator(); it.hasNext(); ) {
+      for (Iterator<SuspectRequest> it = incomingRequest.getMembers().iterator(); it.hasNext();) {
-    
-      for (SuspectRequest req: incomingRequest.getMembers()) {
-        logger.info("received suspect message from {} for {}: {}",
-           sender, req.getSuspectMember(), req.getReason());
+      for (SuspectRequest req : incomingRequest.getMembers()) {
+        logger.info("received suspect message from {} for {}: {}", sender, req.getSuspectMember(),
+            req.getReason());
-    }// coordinator ends
+    } // coordinator ends
-        for (SuspectRequest req: incomingRequest.getMembers()) {
-          logger.info("received suspect message from {} for {}: {}",
-             sender, req.getSuspectMember(), req.getReason());
+        for (SuspectRequest req : incomingRequest.getMembers()) {
+          logger.info("received suspect message from {} for {}: {}", sender, req.getSuspectMember(),
+              req.getReason());
-   * This method make sure that records suspectRequest. We need to make sure this
-   * on preferred coordinators, as elder coordinator might be in suspected list next. 
+   * This method make sure that records suspectRequest. We need to make sure this on preferred
+   * coordinators, as elder coordinator might be in suspected list next.
-      for (SuspectRequest sr: sMembers) {       
+      for (SuspectRequest sr : sMembers) {
-   * performs a "final" health check on the member.  If failure-detection
-   * socket information is available for the member (in the view) then
-   * we attempt to connect to its socket and ask if it's the expected member.
-   * Otherwise we send a heartbeat request and wait for a reply.
+   * performs a "final" health check on the member. If failure-detection socket information is
+   * available for the member (in the view) then we attempt to connect to its socket and ask if it's
+   * the expected member. Otherwise we send a heartbeat request and wait for a reply.
-      // suspected.  Since that code is updating this collection we
+      // suspected. Since that code is updating this collection we
-      //      NetView view;
-      //      view = suspectedMemberInView.putIfAbsent(mbr, cv);
+      // NetView view;
+      // view = suspectedMemberInView.putIfAbsent(mbr, cv);
-      //      if (view == null || !view.equals(cv)) {
+      // if (view == null || !view.equals(cv)) {
-      //      }// scheduling for final check and removing it..
+      // }// scheduling for final check and removing it..
-  private boolean inlineCheckIfAvailable(
-      final InternalDistributedMember initiator, final NetView cv,
-      boolean initiateRemoval,
-      final InternalDistributedMember mbr, final String reason) {
+  private boolean inlineCheckIfAvailable(final InternalDistributedMember initiator,
+      final NetView cv, boolean initiateRemoval, final InternalDistributedMember mbr,
+      final String reason) {
-  
+
-          logger.debug("\ncurrent view: {}\nports: {}", cv, Arrays.toString(cv.getFailureDetectionPorts()));
+          logger.debug("\ncurrent view: {}\nports: {}", cv,
+              Arrays.toString(cv.getFailureDetectionPorts()));
-        //this will just send heartbeat request, it will not wait for response
-        //if we will get heartbeat then it will change the timestamp, which we are 
-        //checking below in case of tcp check failure..
+        // this will just send heartbeat request, it will not wait for response
+        // if we will get heartbeat then it will change the timestamp, which we are
+        // checking below in case of tcp check failure..
-  
+
-          logger.info("Final check failed but detected recent message traffic for suspect member " + mbr);
+          logger.info(
+              "Final check failed but detected recent message traffic for suspect member " + mbr);
-    
+
-  public void memberShutdown(DistributedMember mbr, String reason) {
-  }
-  
+  public void memberShutdown(DistributedMember mbr, String reason) {}
+
-//    synchronized (suspectRequests) {
-//      if (suspectRequests.size() > 0) {
-//        for (SuspectRequest sr: suspectRequests) {
-//          if (!requests.contains(sr)) {
-//            requests.add(sr);
-//          }
-//        }
-//        suspectRequests.clear();
-//      }
-//    }
+    // synchronized (suspectRequests) {
+    // if (suspectRequests.size() > 0) {
+    // for (SuspectRequest sr: suspectRequests) {
+    // if (!requests.contains(sr)) {
+    // requests.add(sr);
+    // }
+    // }
+    // suspectRequests.clear();
+    // }
+    // }
-      for (Enumeration<InternalDistributedMember> e = suspectedMemberInView.keys(); e.hasMoreElements();) {
+      for (Enumeration<InternalDistributedMember> e = suspectedMemberInView.keys(); e
+          .hasMoreElements();) {
-      filter.addAll(requests.stream().map(SuspectRequest::getSuspectMember).collect(Collectors.toList()));
-      recipients = currentView.getPreferredCoordinators(filter, services.getJoinLeave().getMemberID(), 5);
+      filter.addAll(
+          requests.stream().map(SuspectRequest::getSuspectMember).collect(Collectors.toList()));
+      recipients =
+          currentView.getPreferredCoordinators(filter, services.getJoinLeave().getMemberID(), 5);
+
-    
+
-    
+
-    
+
-    
+
-  
+

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 UPD40 INS31 INS29 INS83 INS83 INS43 INS42 INS8 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS65 INS42 INS41 INS25 MOV21 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS66 INS42 UPD66 UPD66 UPD66 INS27 INS8 UPD27 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 MOV21 MOV27 INS27 INS60 INS70 MOV25 INS32 INS27 INS39 INS59 INS44 INS42 INS8 INS38 INS42 INS42 INS32 INS34 INS42 INS9 INS43 INS42 INS25 INS25 INS42 INS42 INS42 MOV42 INS32 INS8 INS38 INS8 INS42 UPD42 MOV42 UPD42 MOV42 INS18 INS32 MOV21 INS10 MOV42 UPD42 MOV42 INS42 INS7 INS42 INS9 DEL66 DEL66 DEL66 DEL66 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL42 DEL43 DEL43 DEL74 DEL42 DEL42 DEL43 DEL74 DEL42 DEL14 DEL59 DEL60 DEL32 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL66 DEL66
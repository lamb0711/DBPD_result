GEODE-2654: Backups can capture different members from different points in time
Online backup now takes a backup from a single point in time.
This is done by making all write operations get a backup lock which causes them to
wait until the oplogs are rolled by backup.

-  private Thread backupThread;
+  private final ThreadLocal<Boolean> isBackupThread = new ThreadLocal<Boolean>();
+  // test hook
+  private BackupLockTestHook hook = null;
+
+  public interface BackupLockTestHook {
+    /**
+     * Test hook called before the wait for backup to complete
+     */
+    public void beforeWaitForBackupCompletion();
+  }
+
+  public void setBackupLockTestHook(BackupLockTestHook testHook) {
+    hook = testHook;
+  }
+
-  public void setBackupThread(Thread thread) {
-    super.lock();
-    backupThread = thread;
-    super.unlock();
+  public void setBackupThread() {
+    isBackupThread.set(true);
-    backupThread = null;
+    isBackupThread.set(false);
-  /**
-   * Acquire this lock, waiting for an in progress backup if one is in progress.
-   */
+  public boolean isCurrentThreadDoingBackup() {
+    Boolean result = isBackupThread.get();
+    return (result != null) && result;
+  }
+
-  public void lock() {
-    lock(true);
+  public void unlock() {
+    // The backup thread does not need to unlock this lock since it never gets the lock. It is the
+    // only thread that has permission to modify disk files during backup.
+    if (!isCurrentThreadDoingBackup()) {
+      super.unlock();
+    }
-   * Acquire this lock, Optionally waiting for a backup to finish the first phase. Any operations
-   * that update metadata related to the distributed system state should pass true for this flag,
-   * because we need to make sure we get a point in time snapshot of the init files across members
-   * to for metadata consistentency.
+   * Acquire this lock, waiting for a backup to finish the first phase.
-   * Updates which update only record changes to the local state on this member(eg, switching
-   * oplogs), do not need to wait for the backup.
-   * 
-   * @param waitForBackup if true, we will wait for an in progress backup before acquiring this
-   *        lock.
-  public void lock(boolean waitForBackup) {
-    super.lock();
-    while (isBackingUp && waitForBackup && !(Thread.currentThread() == backupThread)) {
-      backupDone.awaitUninterruptibly();
+  @Override
+  public void lock() {
+    // The backup thread is a noop; it does not need to get the lock since it is the only thread
+    // with permission to modify disk files during backup
+    if (!isCurrentThreadDoingBackup()) {
+      super.lock();
+      while (isBackingUp) {
+        if (hook != null) {
+          hook.beforeWaitForBackupCompletion();
+        }
+        backupDone.awaitUninterruptibly();
+      }

MOV31 MOV31 INS23 INS55 INS31 INS31 INS83 INS74 INS83 INS43 INS59 INS83 INS42 INS31 UPD42 INS8 UPD42 INS83 INS39 INS42 INS8 INS78 INS83 INS39 INS42 INS8 MOV78 INS43 INS43 UPD42 INS14 INS42 INS42 INS33 INS29 INS83 INS39 INS42 UPD43 UPD42 INS21 INS60 INS41 INS42 INS25 INS25 UPD42 MOV42 INS42 INS74 INS65 UPD42 INS7 INS32 INS43 INS59 INS27 INS38 MOV8 UPD66 INS38 INS8 INS43 INS43 INS66 INS42 INS42 UPD42 INS42 INS42 INS42 INS9 INS42 INS42 INS32 INS36 INS42 INS32 INS32 MOV21 INS61 INS42 INS42 INS42 INS42 INS27 INS42 UPD42 MOV42 INS42 MOV8 INS42 INS33 INS25 INS27 INS8 INS42 INS33 INS21 INS32 INS42 INS42 DEL43 DEL66 DEL65 DEL29 DEL42 DEL33 DEL7 DEL42 DEL48 DEL21 DEL42 DEL42 DEL7 DEL21 DEL66 DEL66 DEL66 DEL66 DEL66 DEL42 DEL66 DEL66 DEL65 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL36 DEL38 DEL27 DEL61
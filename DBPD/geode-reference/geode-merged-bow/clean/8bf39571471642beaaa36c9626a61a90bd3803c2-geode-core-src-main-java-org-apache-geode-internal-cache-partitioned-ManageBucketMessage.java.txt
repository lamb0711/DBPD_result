Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
-  /** The key associated with the value that must be sent */ 
+
+  /** The key associated with the value that must be sent */
-  /** The value associated with the key that must be sent */ 
+  /** The value associated with the key that must be sent */
-  /** 
+  /**
-  
+
-  
+
-    this.forceCreation = hostItNow; 
+    this.forceCreation = hostItNow;
+
-  
-  @Override  
+
+  @Override
-   * @param recipient the member to which the bucket manage request is sent 
-   * @param r  the PartitionedRegion to which the bucket belongs
+   * 
+   * @param recipient the member to which the bucket manage request is sent
+   * @param r the PartitionedRegion to which the bucket belongs
-  public static NodeResponse send(InternalDistributedMember recipient, 
-      PartitionedRegion r, int bucketId, int bucketSize, boolean forceCreation) 
-      throws ForceReattemptException
-  {
+  public static NodeResponse send(InternalDistributedMember recipient, PartitionedRegion r,
+      int bucketId, int bucketSize, boolean forceCreation) throws ForceReattemptException {
-    ManageBucketMessage m = new ManageBucketMessage(recipient, r.getPRId(), p, bucketId, bucketSize, forceCreation);
+    ManageBucketMessage m =
+        new ManageBucketMessage(recipient, r.getPRId(), p, bucketId, bucketSize, forceCreation);
-      throw new ForceReattemptException(LocalizedStrings.ManageBucketMessage_FAILED_SENDING_0.toLocalizedString(m));
+      throw new ForceReattemptException(
+          LocalizedStrings.ManageBucketMessage_FAILED_SENDING_0.toLocalizedString(m));
-  
+
-   * This method is called upon receipt and make the desired changes to the
-   * PartitionedRegion
-   * Note: It is very important that this message does NOT cause any deadlocks as the sender will wait indefinitely for the acknowledgement
+   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:
+   * It is very important that this message does NOT cause any deadlocks as the sender will wait
+   * indefinitely for the acknowledgement
-  @Override  
-  protected boolean operateOnPartitionedRegion(DistributionManager dm, 
-      PartitionedRegion r, long startTime) {
+  @Override
+  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion r,
+      long startTime) {
-   
-    // This is to ensure that initialization is complete before bucket creation request is 
+
+    // This is to ensure that initialization is complete before bucket creation request is
-    
-    r.checkReadiness(); //  Don't allow closed PartitionedRegions that have datastores to host buckets
+
+    r.checkReadiness(); // Don't allow closed PartitionedRegions that have datastores to host
+                        // buckets
-    boolean managingBucket = prDs.handleManageBucketRequest(this.bucketId, this.bucketSize, this.sender, this.forceCreation);
-    r.getPrStats().endPartitionMessagesProcessing(startTime); 
+    boolean managingBucket = prDs.handleManageBucketRequest(this.bucketId, this.bucketSize,
+        this.sender, this.forceCreation);
+    r.getPrStats().endPartitionMessagesProcessing(startTime);
-      //fix for bug 39356 - If the sender died while we were creating the bucket
-      //notify other nodes that they should invoke grabBackupBuckets to 
-      //make copies of this bucket. Normally the sender would be responsible
-      //for creating those copies.
+      // fix for bug 39356 - If the sender died while we were creating the bucket
+      // notify other nodes that they should invoke grabBackupBuckets to
+      // make copies of this bucket. Normally the sender would be responsible
+      // for creating those copies.
-      
-      ManageBucketReplyMessage.sendAcceptance(getSender(), getProcessorId(), dm);      
+
+      ManageBucketReplyMessage.sendAcceptance(getSender(), getProcessorId(), dm);
-  
+
-   * Check that sender is still a participant in the partitioned region. If not,
-   * notify other nodes to create backup buckets
+   * Check that sender is still a participant in the partitioned region. If not, notify other nodes
+   * to create backup buckets
-  @Override  
-  public void fromData(DataInput in) throws IOException,
-      ClassNotFoundException
-  {
+  @Override
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-  @Override  
-  public void toData(DataOutput out) throws IOException
-  {
+  @Override
+  public void toData(DataOutput out) throws IOException {
-  
+
-  protected void appendFields(StringBuffer buff)
-  {
+  protected void appendFields(StringBuffer buff) {
-    buff.append("; bucketId=").append(this.bucketId)
-        .append("; bucketSize=").append(this.bucketSize);
+    buff.append("; bucketId=").append(this.bucketId).append("; bucketSize=")
+        .append(this.bucketSize);
-  
-  @Override  
+
+  @Override
-   * A class that contains the reply to a {@link ManageBucketMessage} message
-   * which contains the {@link Node} that has accepted to manage the bucket. 
+   * A class that contains the reply to a {@link ManageBucketMessage} message which contains the
+   * {@link Node} that has accepted to manage the bucket.
+   * 
-    
+
-    
+
-     * Empty constructor to conform to DataSerializable interface 
+     * Empty constructor to conform to DataSerializable interface
-    public ManageBucketReplyMessage() {
-    }
+    public ManageBucketReplyMessage() {}
-    private ManageBucketReplyMessage(int processorId, boolean accept, boolean initializing)
-    {
+    private ManageBucketReplyMessage(int processorId, boolean accept, boolean initializing) {
-      this.acceptedBucket= accept;
+      this.acceptedBucket = accept;
-    
+
-     * Refuse the request to manage the bucket 
+     * Refuse the request to manage the bucket
+     * 
-    public static void sendRefusal(InternalDistributedMember recipient, int processorId, DM dm) 
-    {
+    public static void sendRefusal(InternalDistributedMember recipient, int processorId, DM dm) {
-    
+
+     * 
-    public static void sendStillInitializing(InternalDistributedMember recipient,
-        int processorId, DM dm)
-    {
+    public static void sendStillInitializing(InternalDistributedMember recipient, int processorId,
+        DM dm) {
-      
+
+     * 
-    public static void sendAcceptance(InternalDistributedMember recipient, int processorId, 
-        DM dm) 
-    {
+    public static void sendAcceptance(InternalDistributedMember recipient, int processorId, DM dm) {
-}
+    }
-     * Processes this message.  This method is invoked by the receiver
-     * of the message.
+     * Processes this message. This method is invoked by the receiver of the message.
+     * 
-    @Override  
+    @Override
-        logger.trace(LogMarker.DM, "ManageBucketReplyMessage process invoking reply processor with processorId: {}", this.processorId);
+        logger.trace(LogMarker.DM,
+            "ManageBucketReplyMessage process invoking reply processor with processorId: {}",
+            this.processorId);
-      dm.getStats().incReplyMessageTime(DistributionStats.getStatTime()-startTime);
+      dm.getStats().incReplyMessageTime(DistributionStats.getStatTime() - startTime);
-    
-    @Override  
+
+    @Override
-    @Override  
-  public int getDSFID() {
-    return PR_MANAGE_BUCKET_REPLY_MESSAGE;
-  }
+    @Override
+    public int getDSFID() {
+      return PR_MANAGE_BUCKET_REPLY_MESSAGE;
+    }
-    @Override  
-    public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
+    @Override
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    @Override  
+    @Override
-      return new StringBuffer()
-      .append("ManageBucketReplyMessage ")
-      .append("processorid=").append(this.processorId)
-      .append(" accepted bucket=").append(this.acceptedBucket)
-      .append(" isInitializing=").append(this.notYetInitialized)
-      .toString();
+      return new StringBuffer().append("ManageBucketReplyMessage ").append("processorid=")
+          .append(this.processorId).append(" accepted bucket=").append(this.acceptedBucket)
+          .append(" isInitializing=").append(this.notYetInitialized).toString();
-  
+
+   * 
-  static public class NodeResponse extends ReplyProcessor21  {
+  static public class NodeResponse extends ReplyProcessor21 {
-     * the message that triggers return from waitForAcceptance.  This will
-     * be null if the target member exited
+     * the message that triggers return from waitForAcceptance. This will be null if the target
+     * member exited
-    @Override  
-    public void process(DistributionMessage msg)
-    {
+    @Override
+    public void process(DistributionMessage msg) {
-          ManageBucketReplyMessage reply =(ManageBucketReplyMessage) msg;
+          ManageBucketReplyMessage reply = (ManageBucketReplyMessage) msg;
-            logger.trace(LogMarker.DM, "NodeResponse return value is {} isInitializing {}", reply.acceptedBucket, reply.notYetInitialized);
+            logger.trace(LogMarker.DM, "NodeResponse return value is {} isInitializing {}",
+                reply.acceptedBucket, reply.notYetInitialized);
-    
-    
+
+
-     * Wait for the response to a {@link ManageBucketMessage} request. 
+     * Wait for the response to a {@link ManageBucketMessage} request.
+     * 
-     * @see org.apache.geode.internal.cache.PartitionedRegionDataStore#handleManageBucketRequest(int, int, InternalDistributedMember, boolean)
+     * @see org.apache.geode.internal.cache.PartitionedRegionDataStore#handleManageBucketRequest(int,
+     *      int, InternalDistributedMember, boolean)
-    public boolean waitForAcceptance()  throws ForceReattemptException
-    {
+    public boolean waitForAcceptance() throws ForceReattemptException {
-      }
-      catch (ReplyException e) {
+      } catch (ReplyException e) {
-         logger.debug("NodeResponse got remote cancellation, throwing PartitionedRegionCommunication Exception. {}", t.getMessage(), t);
-          throw new ForceReattemptException(LocalizedStrings.ManageBucketMessage_NODERESPONSE_GOT_REMOTE_CANCELLATION_THROWING_PARTITIONEDREGIONCOMMUNICATION_EXCEPTION.toLocalizedString(), t);
+          logger.debug(
+              "NodeResponse got remote cancellation, throwing PartitionedRegionCommunication Exception. {}",
+              t.getMessage(), t);
+          throw new ForceReattemptException(
+              LocalizedStrings.ManageBucketMessage_NODERESPONSE_GOT_REMOTE_CANCELLATION_THROWING_PARTITIONEDREGIONCOMMUNICATION_EXCEPTION
+                  .toLocalizedString(),
+              t);
-          logger.debug("NodeResponse got local destroy on the PartitionRegion , throwing ForceReattemptException. {}", t.getMessage(), t);
-          throw new ForceReattemptException(LocalizedStrings.ManageBucketMessage_NODERESPONSE_GOT_LOCAL_DESTROY_ON_THE_PARTITIONREGION_THROWING_FORCEREATTEMPTEXCEPTION.toLocalizedString(), t);
+          logger.debug(
+              "NodeResponse got local destroy on the PartitionRegion , throwing ForceReattemptException. {}",
+              t.getMessage(), t);
+          throw new ForceReattemptException(
+              LocalizedStrings.ManageBucketMessage_NODERESPONSE_GOT_LOCAL_DESTROY_ON_THE_PARTITIONREGION_THROWING_FORCEREATTEMPTEXCEPTION
+                  .toLocalizedString(),
+              t);
-          String msg = "NodeResponse got ForceReattemptException due to local destroy on the PartitionRegion.";
+          String msg =
+              "NodeResponse got ForceReattemptException due to local destroy on the PartitionRegion.";
-          throw (ForceReattemptException)t;
+          throw (ForceReattemptException) t;
-    
+
-     * After a response has been returned from waitForAcceptance, this method
-     * may be used to see if the other vm rejected the bucket because it was
-     * still initializing.
+     * After a response has been returned from waitForAcceptance, this method may be used to see if
+     * the other vm rejected the bucket because it was still initializing.

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66
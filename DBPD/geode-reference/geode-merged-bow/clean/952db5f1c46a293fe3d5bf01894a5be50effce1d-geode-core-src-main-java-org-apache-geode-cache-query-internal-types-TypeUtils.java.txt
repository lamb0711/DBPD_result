GEODE-1758: Refactor, test and clean up TypeUtils (#1367)

* GEODE-4436: JUnit tests for TypeUtils class.
* GEODE-4437: Improvements for TypeUtils class.
-
-import java.util.Iterator;
+import java.util.Date;
-import org.apache.geode.cache.query.types.MapType;
-  private static List _numericPrimitiveClasses = Arrays.asList(
+  protected static List<Class> _numericPrimitiveClasses = Arrays.asList(
-  private static List _numericWrapperClasses = Arrays.asList(
+  protected static List<Class> _numericWrapperClasses = Arrays.asList(
+  /**
+   * Enum to execute comparisons based on types.
+   */
+  private enum ComparisonStrategy {
+    TEMPORAL {
+      public Boolean execute(Object object1, Object object2, int comparator)
+          throws ClassCastException {
+        return applyComparator(getTemporalComparator().compare(object1, object2), comparator);
+      }
+    },
+
+    NUMERIC {
+      public Boolean execute(Object object1, Object object2, int comparator)
+          throws ClassCastException {
+        return applyComparator(getNumericComparator().compare(object1, object2), comparator);
+      }
+    },
+
+    BOOLEAN {
+      public Boolean execute(Object object1, Object object2, int comparator)
+          throws TypeMismatchException {
+        return booleanCompare(object1, object2, comparator);
+      }
+    },
+
+    COMPARABLE {
+      public Boolean execute(Object object1, Object object2, int comparator)
+          throws ClassCastException {
+        return applyComparator(((Comparable) object1).compareTo(object2), comparator);
+      }
+    },
+
+    ARBITRARY {
+      public Boolean execute(Object object1, Object object2, int comparator) {
+        if (comparator == TOK_EQ) {
+          return object1.equals(object2);
+        } else {
+          return !object1.equals(object2);
+        }
+      }
+    };
+
+    /**
+     *
+     * @param temporalResult
+     * @param comparator
+     * @return
+     * @throws IllegalArgumentException
+     */
+    protected Boolean applyComparator(int temporalResult, int comparator)
+        throws IllegalArgumentException {
+      switch (comparator) {
+        case TOK_EQ:
+          return temporalResult == 0;
+        case TOK_LT:
+          return temporalResult < 0;
+        case TOK_LE:
+          return temporalResult <= 0;
+        case TOK_GT:
+          return temporalResult > 0;
+        case TOK_GE:
+          return temporalResult >= 0;
+        case TOK_NE:
+          return temporalResult != 0;
+        default:
+          throw new IllegalArgumentException(LocalizedStrings.TypeUtils_UNKNOWN_OPERATOR_0
+              .toLocalizedString(Integer.valueOf(comparator)));
+      }
+    }
+
+    /**
+     *
+     * @param object1Class
+     * @param object2Class
+     * @param comparator
+     * @return
+     */
+    public static ComparisonStrategy get(Class object1Class, Class object2Class, int comparator)
+        throws TypeMismatchException {
+      if (isAssignableFrom(object1Class, Date.class)
+          && isAssignableFrom(object1Class, Date.class)) {
+        return TEMPORAL;
+      } else if (object1Class != object2Class && (isAssignableFrom(object1Class, Number.class)
+          && isAssignableFrom(object2Class, Number.class))) {
+        /*
+         * @todo check for NaN, in which case we should not call compareTo Must also handle this in
+         * the index lookup code to be consistent See bug 37716 NumericComparator cmprtr =
+         * getNumericComparator(); boolean b; if (obj1.equals(Float.NaN) || obj1.equals(Double.NaN))
+         * { return new Boolean(cmprtr.compareWithNaN(obj2)); } else if (obj2.equals(Float.NaN) ||
+         * obj2.equals(Float.NaN)) { return new Boolean(cmprtr.compareWithNaN(obj1)); }
+         */
+        return NUMERIC;
+      } else if (isAssignableFrom(object1Class, Boolean.class)
+          || isAssignableFrom(object2Class, Boolean.class)) {
+        return BOOLEAN;
+      } else if (isAssignableFrom(object1Class, Comparable.class)
+          && isAssignableFrom(object2Class, Comparable.class)) {
+        return COMPARABLE;
+      } else if ((comparator == TOK_EQ) || (comparator == TOK_NE)) {
+        return ARBITRARY;
+      } else {
+        throw new TypeMismatchException(
+            LocalizedStrings.TypeUtils_UNABLE_TO_USE_A_RELATIONAL_COMPARISON_OPERATOR_TO_COMPARE_AN_INSTANCE_OF_CLASS_0_WITH_AN_INSTANCE_OF_1
+                .toLocalizedString(new Object[] {object1Class.getName(), object2Class.getName()}));
+      }
+    }
+
+    /**
+     * Executes the comparison strategy.
+     *
+     * @param object1
+     * @param object2
+     * @param comparator
+     * @return
+     * @throws TypeMismatchException
+     * @throws ClassCastException
+     */
+    public abstract Boolean execute(Object object1, Object object2, int comparator)
+        throws TypeMismatchException, ClassCastException;
+  }
+
-
+  /**
+   * Creates an instance of {@link org.apache.geode.cache.query.internal.types.TemporalComparator}.
+   *
+   * @return Comparator for mixed comparisons between instances of java.util.Date, java.sql.Date,
+   *         java.sql.Time, and java.sql.Timestamp.
+   * @see org.apache.geode.cache.query.internal.types.TemporalComparator
+   */
+  public static Comparator getTemporalComparator() {
+    return new TemporalComparator();
+  }
+
+  /**
+   * Creates an instance of {@link org.apache.geode.cache.query.internal.types.NumericComparator}.
+   *
+   * @return Comparator for mixed comparisons between numbers.
+   * @see org.apache.geode.cache.query.internal.types.NumericComparator
+   */
+  public static Comparator getNumericComparator() {
+    return new NumericComparator();
+  }
+
+  /**
+   * Creates an instance of
+   * {@link org.apache.geode.cache.query.internal.types.ExtendedNumericComparator}.
+   *
+   * @return A general comparator that compares different numeric types for equality.
+   * @see org.apache.geode.cache.query.internal.types.ExtendedNumericComparator
+   */
+  public static Comparator getExtendedNumericComparator() {
+    return new ExtendedNumericComparator();
+  }
-    if (castTarget == null)
+    if (castTarget == null) {
+    }
+
+
-
-  // implicit conversion of numeric types:
-  // floating point type to other floating point type, or
-  // any integral type to any other integral type if possible
-  // if an integral conversion cannot be done then a TypeMismatchException
-  // is thrown.
-  /*
-   * public static Object convert(Object obj, Class toType) throws TypeMismatchException { // if obj
-   * is null, just leave it alone if (obj == null) return null;
+  /**
+   * Given an arbitrary object, return the value that should be used as the key for a particular
+   * index.
-   *
-   * if (toType.isInstance(obj)) return obj;
-   *
-   * if (Float.class.isAssignableFrom(toType) && obj instanceof Double) return new
-   * Float(((Double)obj).floatValue());
-   *
-   * if (Double.class.isAssignableFrom(toType) && obj instanceof Float) return
-   * Double.valueOf(((Float)obj).doubleValue());
-   *
-   * if (Long.class.isAssignableFrom(toType) && obj instanceof Byte || obj instanceof Short || obj
-   * instanceof Integer) return Long.valueOf(((Number)obj).longValue());
-   *
-   * if (Integer.class.isAssignableFrom(toType) && obj instanceof Byte || obj instanceof Short ||
-   * obj instanceof Long) { int newInt = ((Number)obj).intValue(); if (!(obj instanceof Long) ||
-   * (long)newInt == ((Long)obj).longValue()) return Integer.valueOf(newInt); }
-   *
-   * if (Short.class.isAssignableFrom(toType) && obj instanceof Byte || obj instanceof Integer ||
-   * obj instanceof Long) { short newShort = ((Number)obj).shortValue(); if (obj instanceof Byte ||
-   * (obj instanceof Long && (long)newShort == ((Long)obj).longValue()) || (obj instanceof Integer
-   * && (int)newShort == ((Integer)obj).intValue())) return new Short(newShort); }
-   *
-   * throw new
-   * TypeMismatchException(LocalizedStrings.TypeUtils_UNABLE_TO_CONVERT_0_TO_1.toLocalizedString(new
-   * Object[] {obj, toType})); }
+   * @param obj the object to evaluate.
+   * @return the value that should be used as the key for an index.
+   * @throws TypeMismatchException if the object type is not supported to be used as an index.
+  public static Object indexKeyFor(Object obj) throws TypeMismatchException {
+    if (obj == null) {
+      return null;
+    }
+
+    if (obj instanceof Byte) {
+      return Integer.valueOf(((Byte) obj).intValue());
+    }
+
+    if (obj instanceof Short) {
+      return Integer.valueOf(((Short) obj).intValue());
+    }
+
+    // Ketan : Added later. Indexes should be created
+    // if the IndexedExpr implements Comparable interface.
+    if (obj instanceof Comparable) {
+      if (obj instanceof Enum) {
+        obj = new PdxInstanceEnum((Enum<?>) obj);
+      }
+
+      return obj;
+    }
+
+    throw new TypeMismatchException(LocalizedStrings.TypeUtils_INDEXES_ARE_NOT_SUPPORTED_FOR_TYPE_0
+        .toLocalizedString(obj.getClass().getName()));
+  }
+
+  /**
+   * Determines if the Class represented by the first parameter is either the same as, or is a
+   * superclass or superinterface of, the class or interface represented by the second parameter.
+   *
+   * @param srcType the class to be checked.
+   * @param destType the class to be checked against.
+   * @return the {@code boolean} value indicating whether objects of the type {@code srcType} can be
+   *         assigned to objects of type {@code destType} .
+   */
+  protected static boolean isAssignableFrom(Class srcType, Class destType) {
+    return destType.isAssignableFrom(srcType);
+  }
+
+  /**
+   * Determines if the Class represented by the first parameter can be safely converted to the Class
+   * represented by the second parameter.
+   *
+   * @param srcType the source class to be converted.
+   * @param destType the target class to be converted to.
+   * @return the {@code boolean} value indicating whether objects of the type {@code srcType} can be
+   *         converted to objects of type {@code destType} .
+   */
+  public static boolean isTypeConvertible(Class srcType, Class destType) {
+    // handle null: if srcType is null, then it represents
+    // a null runtime value, and for our purposes it is type
+    // convertible to any type that is assignable from Object.class
+    if (srcType == null) {
+      // TODO: This should always be true as Object is assignable from everything, is the root type
+      // of all Java classes. Object.class is always assignable from every other Java class.
+      return isAssignableFrom(destType, Object.class);
+    }
+
+    // check to see if the classes are assignable
+    if (isAssignableFrom(srcType, destType)) {
+      return true;
+    }
+
+    // handle booleans: are we going from a wrapper Boolean
+    // to a primitive boolean or vice-versa?
+    if ((srcType == Boolean.TYPE || srcType == Boolean.class)
+        && (destType == Boolean.TYPE || destType == Boolean.class)) {
+      return true;
+    }
+
+    // a numeric primitive or wrapper can be converted to
+    // the same wrapper or a same or wider primitive.
+    // handle chars specially
+    int i = _numericPrimitiveClasses.indexOf(srcType);
+    if (i < 0) {
+      i = _numericWrapperClasses.indexOf(srcType);
+    }
+
+    int destP = _numericPrimitiveClasses.indexOf(destType);
+    int destW = -1;
+    if (destP < 0) {
+      destW = _numericWrapperClasses.indexOf(destType);
+    }
+
+    // same size wrapper
+    if (i >= 0 && destW == i) {
+      return true;
+    }
+
+    // same or wider primitive
+    if (i >= 0 && destP >= i) {
+      return true;
+    }
+
+    // chars
+    if (srcType == Character.class || srcType == Character.TYPE) {
+      // chars: same size wrapper/primitive
+      if (destType == Character.class || destType == Character.TYPE) {
+        return true;
+      }
+    }
+
+    // no other possibilities
+    return false;
+  }
+
+  /**
+   * Determines if the all classes represented by the first parameter can be safely converted to the
+   * classes represented by the second parameter.
+   *
+   * @param srcTypes the source classes to be converted.
+   * @param destTypes the target classes to be converted to.
+   * @return the {@code boolean} value indicating whether all objects of the first array can be
+   *         converted to objects of the second array.
+   */
+  public static boolean areTypesConvertible(Class[] srcTypes, Class[] destTypes) {
+    Support.assertArg(srcTypes.length == destTypes.length,
+        "Arguments 'srcTypes' and 'destTypes' must be of same length");
+
+    for (int i = 0; i < srcTypes.length; i++) {
+      if (!isTypeConvertible(srcTypes[i], destTypes[i])) {
+        return false;
+      }
+    }
+
+    return true;
+  }
+
+  /**
+   * Return the {@link org.apache.geode.cache.query.types.ObjectType} corresponding to the specified
+   * Class.
+   *
+   * @param cls
+   * @return the internal ObjectType implementation that represents the specified class.
+   */
+  public static ObjectType getObjectType(Class cls) {
+    if (cls == Object.class) {
+      return OBJECT_TYPE;
+    }
+
+    if (Collection.class.isAssignableFrom(cls)) {
+      // we don't have element type info here
+      return new CollectionTypeImpl(cls, OBJECT_TYPE);
+    }
+
+    if (cls.isArray()) {
+      return new CollectionTypeImpl(cls, getObjectType(cls.getComponentType()));
+    }
+
+    if (Region.class.isAssignableFrom(cls)) {
+      // we don't have access to the region itself for element type
+      return new CollectionTypeImpl(cls, OBJECT_TYPE);
+    }
+
+    if (Map.class.isAssignableFrom(cls)) {
+      return new MapTypeImpl(cls, OBJECT_TYPE, OBJECT_TYPE);
+    }
+
+    // if it's a struct we have no field info, so just return an ObjectTypeImpl
+    return new ObjectTypeImpl(cls);
+  }
+
+  /**
+   * Return a fixed {@link org.apache.geode.cache.query.types.ObjectType} representing a Region
+   * Entry.
+   *
+   * @param rgn
+   * @return the internal ObjectType implementation that represents a the region entry class.
+   */
+  public static ObjectType getRegionEntryType(Region rgn) {
+    // just use an ObjectType for now
+    return new ObjectTypeImpl(Region.Entry.class);
+  }
+
+  /**
+   * Compare two booleans.
+   *
+   * @param obj1
+   * @param obj2
+   * @param compOp
+   * @return a boolean indicating the result of applying the comparison operator on the arguments.
+   * @throws TypeMismatchException When either one of the arguments is not a Boolean, or the
+   *         comparison operator is not supported.
+   */
+  protected static boolean booleanCompare(Object obj1, Object obj2, int compOp)
+      throws TypeMismatchException {
+    if (!(obj1 instanceof Boolean) || !(obj2 instanceof Boolean)) {
+      throw new TypeMismatchException(
+          LocalizedStrings.TypeUtils_BOOLEANS_CAN_ONLY_BE_COMPARED_WITH_BOOLEANS
+              .toLocalizedString());
+    }
+
+    if (compOp == TOK_EQ) {
+      return obj1.equals(obj2);
+    } else if (compOp == TOK_NE) {
+      return !obj1.equals(obj2);
+    } else {
+      throw new TypeMismatchException(
+          LocalizedStrings.TypeUtils_BOOLEAN_VALUES_CAN_ONLY_BE_COMPARED_WITH_OR
+              .toLocalizedString());
+    }
+  }
+
+  /**
+   *
+   * @param obj1
+   * @param obj2
+   * @param compOp
+   * @return a Boolean, or null if UNDEFINED.
+   */
+  private static Boolean nullCompare(Object obj1, Object obj2, int compOp) {
+    Boolean result = null;
+
+    switch (compOp) {
+      case TOK_EQ: {
+        if (obj1 == null) {
+          result = Boolean.valueOf(obj2 == null);
+        } else { // obj1 is not null obj2 must be
+          result = Boolean.FALSE;
+        }
+
+        break;
+      }
+
+      case TOK_NE: {
+        if (obj1 == null) {
+          result = Boolean.valueOf(obj2 != null);
+        } else { // obj1 is not null so obj2 must be
+          result = Boolean.TRUE;
+        }
+
+        break;
+      }
+    }
+
+    return result;
+  }
+
+    // Check for nulls first.
-      if (result == null)
+
+      if (result == null) {
+      }
+
+    // Prepare pdx instances if needed.
+
-      int r;
-
-      if (obj1 instanceof java.util.Date && obj2 instanceof java.util.Date)
-        r = getTemporalComparator().compare(obj1, obj2);
-
-      else if (obj1.getClass() != obj2.getClass()
-          && (obj1 instanceof Number && obj2 instanceof Number)) {
-        /*
-         * @todo check for NaN, in which case we should not call compareTo Must also handle this in
-         * the index lookup code to be consistent See bug 37716 NumericComparator cmprtr =
-         * getNumericComparator(); boolean b; if (obj1.equals(Float.NaN) || obj1.equals(Double.NaN))
-         * { return new Boolean(cmprtr.compareWithNaN(obj2)); } else if (obj2.equals(Float.NaN) ||
-         * obj2.equals(Float.NaN)) { return new Boolean(cmprtr.compareWithNaN(obj1)); }
-         */
-        r = getNumericComparator().compare(obj1, obj2);
+      ComparisonStrategy strategy =
+          ComparisonStrategy.get(obj1.getClass(), obj2.getClass(), compOp);
+      return strategy.execute(obj1, obj2, compOp);
+    } catch (ClassCastException | TypeMismatchException e) {
+      // if a ClassCastException or TypeMismatchException was thrown and the operator is equals
+      // or not equals, then override and return true or false.
+      if (compOp == TOK_EQ) {
+        return Boolean.FALSE;
-      else if (obj1 instanceof Boolean || obj2 instanceof Boolean)
-        return Boolean.valueOf(booleanCompare(obj1, obj2, compOp));
+      if (compOp == TOK_NE) {
+        return Boolean.TRUE;
+      }
-
-      else if (obj1 instanceof Comparable && obj2 instanceof Comparable)
-        r = ((Comparable) obj1).compareTo(obj2);
-      // comparison of two arbitrary objects: use equals()
-      else if (compOp == TOK_EQ)
-        return Boolean.valueOf(obj1.equals(obj2));
-      else if (compOp == TOK_NE)
-        return Boolean.valueOf(!obj1.equals(obj2));
-      else
+      if (isAssignableFrom(e.getClass(), ClassCastException.class)) {
-            LocalizedStrings.TypeUtils_UNABLE_TO_USE_A_RELATIONAL_COMPARISON_OPERATOR_TO_COMPARE_AN_INSTANCE_OF_CLASS_0_WITH_AN_INSTANCE_OF_1
+            LocalizedStrings.TypeUtils_UNABLE_TO_COMPARE_OBJECT_OF_TYPE_0_WITH_OBJECT_OF_TYPE_1
-                    new Object[] {obj1.getClass().getName(), obj2.getClass().getName()}));
-
-
-      switch (compOp) {
-        case TOK_EQ:
-          return Boolean.valueOf(r == 0);
-        case TOK_LT:
-          return Boolean.valueOf(r < 0);
-        case TOK_LE:
-          return Boolean.valueOf(r <= 0);
-        case TOK_GT:
-          return Boolean.valueOf(r > 0);
-        case TOK_GE:
-          return Boolean.valueOf(r >= 0);
-        case TOK_NE:
-          return Boolean.valueOf(r != 0);
-        default:
-          throw new IllegalArgumentException(LocalizedStrings.TypeUtils_UNKNOWN_OPERATOR_0
-              .toLocalizedString(Integer.valueOf(compOp)));
+                    new Object[] {obj1.getClass().getName(), obj2.getClass().getName()}),
+            e);
+      } else {
+        throw e;
-    } catch (ClassCastException e) {
-      // if a ClassCastException was thrown and the operator is equals or not equals,
-      // then override and return true or false
-      if (compOp == TOK_EQ)
-        return Boolean.FALSE;
-      if (compOp == TOK_NE)
-        return Boolean.TRUE;
-
-      throw new TypeMismatchException(
-          LocalizedStrings.TypeUtils_UNABLE_TO_COMPARE_OBJECT_OF_TYPE_0_WITH_OBJECT_OF_TYPE_1
-              .toLocalizedString(
-                  new Object[] {obj1.getClass().getName(), obj2.getClass().getName()}),
-          e);
-    } catch (TypeMismatchException e) {
-      // same for TypeMismatchException
-      if (compOp == TOK_EQ)
-        return Boolean.FALSE;
-      if (compOp == TOK_NE)
-        return Boolean.TRUE;
-      throw e;
-
-  public static Comparator getTemporalComparator() {
-    return new TemporalComparator();
-  }
-
-  public static Comparator getNumericComparator() {
-    return new NumericComparator();
-  }
-
-  public static Comparator getExtendedNumericComparator() {
-    return new ExtendedNumericComparator();
-  }
-
-
-  public static Object indexKeyFor(Object obj) throws TypeMismatchException {
-    if (obj == null)
-      return null;
-    if (obj instanceof Byte)
-      return Integer.valueOf(((Byte) obj).intValue());
-    if (obj instanceof Short)
-      return Integer.valueOf(((Short) obj).intValue());
-    // Ketan : Added later. Indexes should be created
-    // if the IndexedExpr implements Comparable interface.
-    if (obj instanceof Comparable) {
-      if (obj instanceof Enum) {
-        obj = new PdxInstanceEnum((Enum<?>) obj);
-      }
-      return obj;
-    }
-    throw new TypeMismatchException(LocalizedStrings.TypeUtils_INDEXES_ARE_NOT_SUPPORTED_FOR_TYPE_0
-        .toLocalizedString(obj.getClass().getName()));
-  }
-
-  // returns null if this type doesn't need a Comparator
-  public static Comparator comparatorFor(Class pathType) {
-    Iterator i = _numericWrapperClasses.iterator();
-    while (i.hasNext())
-      if (((Class) i.next()).isAssignableFrom(pathType))
-        return getNumericComparator();
-    i = _numericPrimitiveClasses.iterator();
-    while (i.hasNext())
-      if (((Class) i.next()).isAssignableFrom(pathType))
-        return getNumericComparator();
-    if (java.util.Date.class.isAssignableFrom(pathType))
-      return getTemporalComparator();
-    return null;
-  }
-
-
-  // indexes are allowed on primitive types except char,
-  // plus Strings, and temporals
-  /**
-   * Return the type of the keys for a given path type.
-   *
-   * @param pathType the Class of the last attribute in the path
-   * @return the Class of the index keys
-   * @throws TypeMismatchException if indexes are not allowed on this type
-   */
-
-  public static Class indexTypeFor(Class pathType) throws TypeMismatchException {
-    if (Character.class.isAssignableFrom(pathType) || Character.TYPE == pathType)
-      return pathType;
-
-    if (Byte.class.isAssignableFrom(pathType) || Short.class.isAssignableFrom(pathType)
-        || Byte.TYPE == pathType || Short.TYPE == pathType)
-      return Integer.class;
-    Iterator i = _numericWrapperClasses.iterator();
-    while (i.hasNext()) {
-      Class cls = (Class) i.next();
-      if (cls.isAssignableFrom(pathType))
-        return pathType;
-    }
-    i = _numericPrimitiveClasses.iterator();
-    while (i.hasNext()) {
-      Class cls = (Class) i.next();
-      if (cls == pathType)
-        return pathType;
-    }
-
-    if (java.util.Date.class.isAssignableFrom(pathType) || pathType == String.class)
-      return pathType;
-    throw new TypeMismatchException(
-        LocalizedStrings.TypeUtils_INDEXES_ARE_NOT_SUPPORTED_ON_PATHS_OF_TYPE_0
-            .toLocalizedString(pathType.getName()));
-  }
-
-
-
-  public static boolean areTypesConvertible(Class[] srcTypes, Class[] destTypes) {
-    Support.assertArg(srcTypes.length == destTypes.length,
-        "Arguments 'srcTypes' and 'destTypes' must be of same length");
-
-    for (int i = 0; i < srcTypes.length; i++)
-      if (!isTypeConvertible(srcTypes[i], destTypes[i]))
-        return false;
-    return true;
-  }
-
-  public static boolean isTypeConvertible(Class srcType, Class destType) {
-    // handle null: if srcType is null, then it represents
-    // a null runtime value, and for our purposes it is type
-    // convertible to any type that is assignable from Object.class
-    if (srcType == null)
-      return (Object.class.isAssignableFrom(destType));
-
-    // check to see if the classes are assignable
-    if (destType.isAssignableFrom(srcType))
-      return true;
-
-    // handle booleans: are we going from a wrapper Boolean
-    // to a primitive boolean or vice-versa?
-    if ((srcType == Boolean.TYPE || srcType == Boolean.class)
-        && (destType == Boolean.TYPE || destType == Boolean.class))
-      return true;
-
-
-    // a numeric primitive or wrapper can be converted to
-    // the same wrapper or a same or wider primitive.
-    // handle chars specially
-    int i = _numericPrimitiveClasses.indexOf(srcType);
-    if (i < 0)
-      i = _numericWrapperClasses.indexOf(srcType);
-
-    int destP = _numericPrimitiveClasses.indexOf(destType);
-    int destW = -1;
-    if (destP < 0)
-      destW = _numericWrapperClasses.indexOf(destType);
-
-    // same size wrapper
-    if (i >= 0 && destW == i)
-      return true;
-
-    // same or wider primitive
-    if (i >= 0 && destP >= i)
-      return true;
-
-    // chars
-    if (srcType == Character.class || srcType == Character.TYPE) {
-      // chars: same size wrapper/primitive
-      if (destType == Character.class || destType == Character.TYPE)
-        return true;
-    }
-
-    // no other possibilities
-    return false;
-  }
-
-
-  private static boolean booleanCompare(Object obj1, Object obj2, int compOp)
-      throws TypeMismatchException {
-    if (!(obj1 instanceof Boolean) || !(obj2 instanceof Boolean))
-      throw new TypeMismatchException(
-          LocalizedStrings.TypeUtils_BOOLEANS_CAN_ONLY_BE_COMPARED_WITH_BOOLEANS
-              .toLocalizedString());
-
-    if (compOp == TOK_EQ)
-      return obj1.equals(obj2);
-    else if (compOp == TOK_NE)
-      return !obj1.equals(obj2);
-    else
-      throw new TypeMismatchException(
-          LocalizedStrings.TypeUtils_BOOLEAN_VALUES_CAN_ONLY_BE_COMPARED_WITH_OR
-              .toLocalizedString());
-  }
-
-
-  // returns a Boolean or null if UNDEFINED
-  private static Boolean nullCompare(Object obj1, Object obj2, int compOp) {
-    switch (compOp) {
-      case TOK_EQ:
-        if (obj1 == null)
-          return Boolean.valueOf(obj2 == null);
-        else // obj1 is not null obj2 must be
-          return Boolean.FALSE;
-      case TOK_NE:
-        if (obj1 == null)
-          return Boolean.valueOf(obj2 != null);
-        else // obj1 is not null so obj2 must be
-          return Boolean.TRUE;
-      default:
-        return null;
-    }
-  }
-
-  // public static boolean isList(Class clazz) {
-  // if( clazz == java.util.ArrayList.class ||
-  // clazz == java.util.LinkedList.class ||
-  // clazz == java.util.Vector.class)
-  // return true;
-  // return false;
-  // }
-
-  public static boolean isMap(ObjectType objType) {
-    return objType instanceof MapType;
-  }
-
-  // public static boolean isSet(Class clazz){
-  // if( clazz == java.util.HashSet.class ||
-  // clazz == java.util.LinkedHashSet.class ||
-  // clazz == java.util.TreeSet.class)
-  // return true;
-  // return false;
-  // }
-
-  public static ObjectType getObjectType(Class cls) {
-    if (cls == Object.class) {
-      return OBJECT_TYPE;
-    }
-    if (Collection.class.isAssignableFrom(cls)) {
-      // we don't have element type info here
-      return new CollectionTypeImpl(cls, OBJECT_TYPE);
-    }
-    if (cls.isArray()) {
-      return new CollectionTypeImpl(cls, getObjectType(cls.getComponentType()));
-    }
-    if (Region.class.isAssignableFrom(cls)) {
-      // we don't have access to the region itself for element type
-      return new CollectionTypeImpl(cls, OBJECT_TYPE);
-    }
-    if (Map.class.isAssignableFrom(cls)) {
-      return new MapTypeImpl(cls, OBJECT_TYPE, OBJECT_TYPE);
-    }
-    // if it's a struct we have no field info, so just return an ObjectTypeImpl
-    return new ObjectTypeImpl(cls);
-  }
-
-  public static ObjectType getRegionEntryType(Region rgn) {
-    // just use an ObjectType for now
-    return new ObjectTypeImpl(Region.Entry.class);
-  }
-

MOV31 MOV31 MOV31 MOV31 MOV31 MOV31 UPD40 INS71 INS31 UPD83 INS74 UPD83 INS74 INS29 INS83 INS42 INS72 INS72 INS72 INS72 INS72 INS31 INS31 INS31 INS29 INS83 INS83 MOV43 INS42 MOV8 INS29 INS29 INS29 INS29 UPD83 UPD42 INS44 INS8 INS29 INS29 INS29 INS29 INS29 UPD83 INS29 MOV43 MOV43 MOV43 INS43 INS65 INS42 INS1 INS42 INS1 INS42 INS1 INS42 INS1 INS42 INS1 MOV29 UPD83 MOV83 UPD43 MOV43 UPD42 MOV42 MOV44 INS44 INS43 INS8 INS29 INS83 INS83 INS43 INS42 INS44 MOV44 INS44 INS43 INS8 INS29 INS83 INS83 INS43 INS42 INS44 INS44 INS44 MOV43 INS43 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 UPD43 UPD42 INS43 INS42 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS60 INS41 INS42 INS42 INS66 INS31 INS31 INS31 INS31 INS31 UPD65 UPD42 INS39 INS42 INS39 INS42 INS42 INS50 INS65 INS65 INS65 INS65 INS42 MOV43 INS42 UPD42 INS39 INS42 UPD42 MOV42 INS25 INS65 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS66 INS65 INS66 INS66 INS66 INS40 INS66 INS65 INS66 INS66 INS40 INS66 INS65 INS66 INS66 INS40 INS8 INS66 INS66 INS42 INS66 INS66 INS42 INS66 INS8 INS8 INS8 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 UPD42 INS42 MOV32 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS8 INS32 INS8 INS8 INS8 INS8 INS8 INS8 INS66 INS66 INS42 INS66 INS42 INS66 INS66 INS65 INS66 INS66 INS8 INS66 INS65 INS66 INS66 INS42 INS66 INS66 INS65 INS66 INS66 INS42 INS66 INS66 INS42 INS42 INS42 INS66 INS42 INS66 INS66 INS8 INS8 INS42 INS42 INS42 INS66 INS43 INS59 INS8 INS8 INS42 MOV83 INS43 INS42 INS44 INS44 INS44 INS43 INS8 MOV83 UPD43 MOV43 INS42 INS44 INS44 INS44 INS43 INS8 INS83 INS43 INS42 INS44 INS44 INS44 MOV43 INS8 INS83 MOV43 INS42 INS44 INS44 INS44 INS43 INS8 INS83 MOV43 INS42 INS44 INS44 INS44 INS8 INS42 UPD42 UPD42 INS42 MOV49 INS41 MOV49 INS41 MOV49 INS41 MOV49 INS41 MOV49 INS41 MOV49 INS41 INS49 INS53 INS42 INS42 INS42 INS27 INS8 INS25 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS40 INS40 MOV41 MOV41 MOV41 MOV41 INS66 INS66 INS66 INS66 INS66 INS66 MOV41 INS42 INS42 INS42 MOV41 MOV41 MOV21 MOV21 MOV41 MOV41 INS66 MOV25 INS40 INS40 MOV53 MOV41 INS8 INS8 INS42 INS42 INS33 MOV25 INS10 MOV25 INS10 INS41 INS8 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS42 INS41 UPD42 INS43 INS42 INS43 INS42 INS39 INS42 UPD42 MOV42 INS41 INS42 INS43 INS42 INS43 INS42 INS39 INS42 INS41 INS43 INS42 INS43 INS42 INS39 INS42 UPD42 MOV42 INS41 INS43 INS42 INS43 INS42 INS39 INS42 MOV25 INS27 INS27 INS27 INS27 INS27 INS27 INS14 INS32 INS32 INS41 INS27 INS8 INS25 MOV32 MOV57 INS8 INS8 MOV41 MOV53 INS8 INS8 INS8 INS8 INS8 INS43 MOV32 INS84 INS25 INS25 INS25 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 MOV32 INS42 INS42 INS32 INS42 INS42 INS27 INS8 INS8 UPD42 MOV42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 INS42 INS34 UPD42 MOV42 INS34 MOV43 INS32 UPD42 MOV42 UPD42 MOV42 INS57 MOV42 INS42 INS57 UPD42 MOV42 INS27 INS36 INS41 INS27 INS8 INS25 MOV41 MOV41 INS21 INS21 INS21 INS21 MOV41 INS42 UPD42 MOV32 MOV32 UPD42 UPD42 MOV42 MOV42 MOV42 MOV42 MOV43 MOV43 MOV27 INS8 MOV27 INS8 INS32 MOV8 INS8 INS42 INS32 INS42 INS42 INS32 UPD42 MOV42 INS42 INS42 INS42 UPD42 INS42 INS32 UPD42 MOV42 INS42 INS42 INS41 INS41 INS40 INS42 INS32 INS43 INS43 INS42 INS42 INS27 INS42 INS32 INS32 INS41 UPD27 MOV27 INS8 INS25 INS7 INS7 INS7 INS7 INS42 UPD42 MOV32 INS42 MOV41 MOV41 INS42 INS32 INS57 MOV53 MOV32 INS42 INS42 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 INS42 INS36 UPD42 MOV42 INS42 INS32 INS38 INS42 INS42 INS42 INS42 INS42 INS32 INS32 INS42 INS42 INS57 UPD42 MOV42 UPD42 MOV42 INS57 INS42 INS32 INS32 INS41 MOV27 INS8 INS8 INS42 MOV32 INS42 INS40 INS42 MOV32 INS42 INS40 INS42 INS42 INS43 INS11 UPD42 MOV42 UPD42 MOV42 INS42 INS32 UPD42 MOV42 UPD42 MOV42 INS57 UPD42 MOV42 UPD42 MOV42 INS57 INS43 INS43 INS42 INS42 INS57 INS42 INS42 INS57 UPD42 MOV42 INS36 INS36 INS41 MOV53 INS42 MOV43 INS42 UPD42 MOV42 INS42 INS42 MOV43 MOV43 UPD42 MOV42 INS42 MOV43 MOV43 INS27 INS27 UPD42 MOV42 INS42 INS42 UPD42 MOV42 INS42 MOV43 UPD40 INS3 MOV5 INS4 INS32 INS32 UPD42 MOV42 MOV42 INS42 INS42 DEL40 DEL26 DEL40 DEL43 DEL57 DEL32 DEL32 DEL41 DEL66 DEL66 DEL66 DEL66 DEL42 DEL43 DEL42 DEL42 DEL42 DEL40 DEL43 DEL57 DEL42 DEL42 DEL32 DEL42 DEL43 DEL57 DEL27 DEL32 DEL83 DEL42 DEL31 DEL83 DEL42 DEL43 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL42 DEL42 DEL32 DEL11 DEL36 DEL42 DEL42 DEL32 DEL41 DEL25 DEL61 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL42 DEL32 DEL11 DEL36 DEL42 DEL32 DEL42 DEL32 DEL41 DEL25 DEL61 DEL33 DEL41 DEL8 DEL31 DEL83 DEL42 DEL43 DEL57 DEL42 DEL42 DEL32 DEL40 DEL27 DEL27 DEL42 DEL41 DEL25 DEL42 DEL43 DEL57 DEL42 DEL42 DEL32 DEL42 DEL43 DEL57 DEL42 DEL42 DEL32 DEL40 DEL27 DEL27 DEL40 DEL42 DEL27 DEL27 DEL42 DEL43 DEL57 DEL41 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL43 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL32 DEL41 DEL25 DEL8 DEL61 DEL42 DEL32 DEL7 DEL21 DEL32 DEL42 DEL43 DEL42 DEL43 DEL32 DEL11 DEL59 DEL60 DEL41 DEL25 DEL8 DEL61 DEL41 DEL25 DEL8 DEL31 DEL42 DEL42 DEL43 DEL62 DEL41 DEL8 DEL36 DEL41 DEL40 DEL41 DEL41 DEL40 DEL41 DEL49 DEL33 DEL41 DEL39 DEL42 DEL32 DEL42 DEL40 DEL43 DEL62 DEL42 DEL40 DEL43 DEL62 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL32 DEL27 DEL42 DEL62 DEL42 DEL62 DEL27 DEL36 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL62 DEL42 DEL62 DEL27 DEL41 DEL42 DEL62 DEL42 DEL62 DEL27 DEL42 DEL42 DEL11 DEL36 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL42 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL41 DEL42 DEL42 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL38 DEL32 DEL41 DEL40 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL4 DEL3 DEL32 DEL14 DEL53 DEL25 DEL25 DEL25 DEL25 DEL25 DEL25 DEL42 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL41 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL41 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL41 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL41 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL41 DEL42 DEL42 DEL42 DEL34 DEL27 DEL32 DEL41 DEL49 DEL40 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL14 DEL53 DEL50 DEL42 DEL42 DEL27 DEL40 DEL41 DEL25 DEL42 DEL42 DEL27 DEL40 DEL41 DEL25 DEL42 DEL44 DEL25 DEL25 DEL8 DEL12
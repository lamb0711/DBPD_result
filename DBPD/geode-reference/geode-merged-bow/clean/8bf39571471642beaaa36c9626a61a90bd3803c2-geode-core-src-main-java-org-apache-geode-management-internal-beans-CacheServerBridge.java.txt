Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Represents the GemFire CacheServer . Provides data and notifications about
- * server, subscriptions,durable queues and indices
+ * Represents the GemFire CacheServer . Provides data and notifications about server,
+ * subscriptions,durable queues and indices
-public class CacheServerBridge extends ServerBridge{  
+public class CacheServerBridge extends ServerBridge {
-  
+
-   
+
-  
+
-  
+
-  
+
-    }
-    catch (PidUnavailableException e) {
+    } catch (PidUnavailableException e) {
-    
+
-  public void stopMonitor(){
+  public void stopMonitor() {
-    monitor.stopListener();    
+    monitor.stopListener();
-    clientNotificationRate = new StatsRate(StatsKey.NUM_CLIENT_NOTIFICATION_REQUEST, StatType.INT_TYPE, monitor);
+    clientNotificationRate =
+        new StatsRate(StatsKey.NUM_CLIENT_NOTIFICATION_REQUEST, StatType.INT_TYPE, monitor);
-    clientNotificatioAvgLatency = new StatsAverageLatency(StatsKey.NUM_CLIENT_NOTIFICATION_REQUEST, StatType.INT_TYPE,
-        StatsKey.CLIENT_NOTIFICATION_PROCESS_TIME, monitor);
+    clientNotificatioAvgLatency = new StatsAverageLatency(StatsKey.NUM_CLIENT_NOTIFICATION_REQUEST,
+        StatType.INT_TYPE, StatsKey.CLIENT_NOTIFICATION_PROCESS_TIME, monitor);
-  
+
-  
+
-   * Get the frequency in milliseconds to poll the load probe on this cache
-   * server.
+   * Get the frequency in milliseconds to poll the load probe on this cache server.
-    ServerLoadData data = new ServerLoadData(load.getConnectionLoad(), load.getSubscriptionConnectionLoad(), load.getLoadPerConnection(), load
-        .getLoadPerSubscriptionConnection());
+    ServerLoadData data =
+        new ServerLoadData(load.getConnectionLoad(), load.getSubscriptionConnectionLoad(),
+            load.getLoadPerConnection(), load.getLoadPerSubscriptionConnection());
-   * Returns the maxium number of threads allowed in this server to service
-   * client requests.
+   * Returns the maxium number of threads allowed in this server to service client requests.
-   * Returns the time (in seconds ) after which a message in the client queue
-   * will expire.
+   * Returns the time (in seconds ) after which a message in the client queue will expire.
-   * Returns the eviction policy that is executed when capacity of the client
-   * queue is reached
+   * Returns the eviction policy that is executed when capacity of the client queue is reached
-   * The hostname or IP address to pass to the client as the loca- tion where
-   * the server is listening. When the server connects to the locator it tells
-   * the locator the host and port where it is listening for client connections.
-   * If the host the server uses by default is one that the client can’t
-   * translate into an IP address, the client will have no route to the server’s
-   * host and won’t be able to find the server. For this situation, you must
-   * supply the server’s alternate hostname for the locator to pass to the cli-
-   * ent. If null, the server’s bind-address (page 177) setting is used.
-   * Default: null.
+   * The hostname or IP address to pass to the client as the loca- tion where the server is
+   * listening. When the server connects to the locator it tells the locator the host and port where
+   * it is listening for client connections. If the host the server uses by default is one that the
+   * client can’t translate into an IP address, the client will have no route to the server’s host
+   * and won’t be able to find the server. For this situation, you must supply the server’s
+   * alternate hostname for the locator to pass to the cli- ent. If null, the server’s bind-address
+   * (page 177) setting is used. Default: null.
-   * The hostname or IP address that the server is to listen on for client
-   * connections. If null, the server listens on the machine’s default address.
-   * Default: null.
+   * The hostname or IP address that the server is to listen on for client connections. If null, the
+   * server listens on the machine’s default address. Default: null.
-  
+
-  
+
-    Collection<CacheClientProxy> clientProxies = acceptor.getCacheClientNotifier().getClientProxies();
+    Collection<CacheClientProxy> clientProxies =
+        acceptor.getCacheClientNotifier().getClientProxies();
-        ClientConnInfo clientConInfo = new ClientConnInfo(p.getProxyID(), p.getSocketHost(), p.getRemotePort(),
-            p.isPrimary());
+        ClientConnInfo clientConInfo =
+            new ClientConnInfo(p.getProxyID(), p.getSocketHost(), p.getRemotePort(), p.isPrimary());
-        if (uniqueIds.get(clientId.getDSMembership()) == null) {
-          ClientConnInfo clientConInfo = new ClientConnInfo(conn.getProxyID(), conn.getSocketHost(),
-              conn.getSocketPort(), false);
-          uniqueIds.put(clientId.getDSMembership(), clientConInfo);
-        }
+          if (uniqueIds.get(clientId.getDSMembership()) == null) {
+            ClientConnInfo clientConInfo = new ClientConnInfo(conn.getProxyID(),
+                conn.getSocketHost(), conn.getSocketPort(), false);
+            uniqueIds.put(clientId.getDSMembership(), clientConInfo);
+          }
-    
+
-    
+
-    public ClientConnInfo(ClientProxyMembershipID clientId, String hostName, int port, boolean isPrimary) {
+    public ClientConnInfo(ClientProxyMembershipID clientId, String hostName, int port,
+        boolean isPrimary) {
-    
-    public String toString(){
+
+    public String toString() {
-  
-  public Version getClientVersion(ClientConnInfo connInfo){
-    GemFireCacheImpl cache = (GemFireCacheImpl)CacheFactory.getAnyInstance();    
-    
+
+  public Version getClientVersion(ClientConnInfo connInfo) {
+    GemFireCacheImpl cache = (GemFireCacheImpl) CacheFactory.getAnyInstance();
+
-      return null;      
-    }
-       
-    CacheServerImpl server = (CacheServerImpl)cache.getCacheServers().iterator().next();
-    
-    if(server == null){
-    
-    AcceptorImpl  acceptorImpl  = server.getAcceptor(); 
-    if(acceptorImpl == null){
+
+    CacheServerImpl server = (CacheServerImpl) cache.getCacheServers().iterator().next();
+
+    if (server == null) {
-    }         
-       
-    ServerConnection[] serverConnections  = acceptorImpl.getAllServerConnectionList();  
-   
+    }
+
+    AcceptorImpl acceptorImpl = server.getAcceptor();
+    if (acceptorImpl == null) {
+      return null;
+    }
+
+    ServerConnection[] serverConnections = acceptorImpl.getAllServerConnectionList();
+
-    if(connInfo.toString().contains("primary=true")){
+    if (connInfo.toString().contains("primary=true")) {
-        
-    for (ServerConnection conn : serverConnections){       
+
+    for (ServerConnection conn : serverConnections) {
-      ClientConnInfo cci = new ClientConnInfo(conn.getProxyID(), conn.getSocketHost(), conn.getSocketPort(), flag);   
-      if (connInfo.toString().equals(cci.toString() )) {
-        return cliIdFrmProxy.getClientVersion();        
+      ClientConnInfo cci =
+          new ClientConnInfo(conn.getProxyID(), conn.getSocketHost(), conn.getSocketPort(), flag);
+      if (connInfo.toString().equals(cci.toString())) {
+        return cliIdFrmProxy.getClientVersion();
-    }  
-    
-    //check form ccp
+    }
+
+    // check form ccp
-    if(proxy != null){
+    if (proxy != null) {
-    }else{
+    } else {
-  } 
+  }
-  
-    if(proxy != null && !proxy.isConnected() && !proxyId.isDurable()){
+
+    if (proxy != null && !proxy.isConnected() && !proxyId.isDurable()) {
-    
+
-    
-    ClientHealthStatus status = new ClientHealthStatus();    
-    Region clientHealthMonitoringRegion = ClientHealthMonitoringRegion.getInstance((GemFireCacheImpl) cache);
+    ClientHealthStatus status = new ClientHealthStatus();
+
+    Region clientHealthMonitoringRegion =
+        ClientHealthMonitoringRegion.getInstance((GemFireCacheImpl) cache);
-    status.setClientCQCount(clientCQCount); 
-    
-    //Only available for clients having subscription enabled true
-    if(proxy != null){
+    status.setClientCQCount(clientCQCount);
+
+    // Only available for clients having subscription enabled true
+    if (proxy != null) {
-      status.setSubscriptionEnabled(true); 
-    }else{
+      status.setSubscriptionEnabled(true);
+    } else {
-      status.setSubscriptionEnabled(false); 
+      status.setSubscriptionEnabled(false);
-    ClientHealthStats stats = (ClientHealthStats) clientHealthMonitoringRegion.get(clientName);    
+    ClientHealthStats stats = (ClientHealthStats) clientHealthMonitoringRegion.get(clientName);
-   * closes a continuous query and releases all the resources associated with
-   * it.
+   * closes a continuous query and releases all the resources associated with it.
-  public void closeContinuousQuery(String queryName) throws Exception{
+  public void closeContinuousQuery(String queryName) throws Exception {
-  public void executeContinuousQuery(String queryName) throws Exception{
+  public void executeContinuousQuery(String queryName) throws Exception {
-    
+
-   * Stops a given query witout releasing any of the resources associated with
-   * it.
+   * Stops a given query witout releasing any of the resources associated with it.
-  public void stopContinuousQuery(String queryName) throws Exception{
+  public void stopContinuousQuery(String queryName) throws Exception {
-            return ;
+            return;
-  public void removeIndex(String indexName) throws Exception{
-    try{
+  public void removeIndex(String indexName) throws Exception {
+    try {
-          return ;
+          return;
-    }catch(Exception e){
+    } catch (Exception e) {
-  
+
- 
+
-  
+
-  public long getTotalIndexMaintenanceTime() {    
+  public long getTotalIndexMaintenanceTime() {
-  
+
-    if(cqService != null && cqService.isRunning()){
+    if (cqService != null && cqService.isRunning()) {
-  public void setClientMembershipListener(
-      ClientMembershipListener membershipListener) {
+  public void setClientMembershipListener(ClientMembershipListener membershipListener) {
-  
+
-  
+
-        Collection<CacheClientProxy> clientProxies = acceptor.getCacheClientNotifier().getClientProxies();
+        Collection<CacheClientProxy> clientProxies =
+            acceptor.getCacheClientNotifier().getClientProxies();
-  
+
-    
+
-  
+
-        Collection<CacheClientProxy> clientProxies = acceptor.getCacheClientNotifier().getClientProxies();
+        Collection<CacheClientProxy> clientProxies =
+            acceptor.getCacheClientNotifier().getClientProxies();

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class ConcurrentSerialGatewaySenderEventProcessor extends
-    AbstractGatewaySenderEventProcessor {
-  
+public class ConcurrentSerialGatewaySenderEventProcessor
+    extends AbstractGatewaySenderEventProcessor {
+
-  protected final List<SerialGatewaySenderEventProcessor> processors = new ArrayList<SerialGatewaySenderEventProcessor>();
+  protected final List<SerialGatewaySenderEventProcessor> processors =
+      new ArrayList<SerialGatewaySenderEventProcessor>();
+
-  public ConcurrentSerialGatewaySenderEventProcessor(
-      AbstractGatewaySender sender) {
-    super(LoggingThreadGroup.createThreadGroup("Event Processor for GatewaySender_"
-        + sender.getId(), logger),
+  public ConcurrentSerialGatewaySenderEventProcessor(AbstractGatewaySender sender) {
+    super(LoggingThreadGroup
+        .createThreadGroup("Event Processor for GatewaySender_" + sender.getId(), logger),
-    
+
-      processors.add(new SerialGatewaySenderEventProcessor(this.sender, id
-          + "." + i));
+      processors.add(new SerialGatewaySenderEventProcessor(this.sender, id + "." + i));
-  
+
-  //based on the fix for old wan Bug#46992 .revision is 39437  
+  // based on the fix for old wan Bug#46992 .revision is 39437
-  public void enqueueEvent(EnumListenerEvent operation, EntryEvent event,
-      Object substituteValue) throws IOException, CacheException {
+  public void enqueueEvent(EnumListenerEvent operation, EntryEvent event, Object substituteValue)
+      throws IOException, CacheException {
-    int index = Math.abs(getHashCode(((EntryEventImpl)event))
-        % this.processors.size());
+    int index = Math.abs(getHashCode(((EntryEventImpl) event)) % this.processors.size());
-      enqueueEvent(operation, event, substituteValue, index);
+    enqueueEvent(operation, event, substituteValue, index);
-  
-  public void enqueueEvent(EnumListenerEvent operation, EntryEvent event,
-      Object substituteValue, int index) throws CacheException, IOException {
-    // Get the appropriate gateway
-    SerialGatewaySenderEventProcessor serialProcessor = this.processors
-        .get(index);
-    if (sender.getOrderPolicy() == OrderPolicy.KEY || sender.getOrderPolicy() == OrderPolicy.PARTITION) {
+  public void enqueueEvent(EnumListenerEvent operation, EntryEvent event, Object substituteValue,
+      int index) throws CacheException, IOException {
+    // Get the appropriate gateway
+    SerialGatewaySenderEventProcessor serialProcessor = this.processors.get(index);
+
+    if (sender.getOrderPolicy() == OrderPolicy.KEY
+        || sender.getOrderPolicy() == OrderPolicy.PARTITION) {
-      @Released EntryEventImpl clonedEvent = new EntryEventImpl((EntryEventImpl)event);
+      @Released
+      EntryEventImpl clonedEvent = new EntryEventImpl((EntryEventImpl) event);
-      EventID originalEventId = clonedEvent.getEventId();
-      if (logger.isDebugEnabled()) {
-        logger.debug("The original EventId is {}", originalEventId);
-      }
-      // PARALLEL_THREAD_BUFFER * (index +1) + originalEventId.getThreadID();
-      // generating threadId by the algorithm explained above used to clash with
-      // fakeThreadId generated by putAll
-      // below is new way to generate threadId so that it doesn't clash with
-      // any.
-      long newThreadId = ThreadIdentifier.createFakeThreadIDForParallelGateway(
-          index, originalEventId.getThreadID(), 0 /*gateway sender event id index has already been applied in SerialGatewaySenderImpl.setModifiedEventId*/);
-      EventID newEventId = new EventID(originalEventId.getMembershipID(),
-          newThreadId, originalEventId.getSequenceID());
-      if (logger.isDebugEnabled()) {
-        logger.debug("{}: Generated event id for event with key={}, index={}, original event id={}, threadId={}, new event id={}, newThreadId={}",
-            this, event.getKey(), index, originalEventId, originalEventId.getThreadID(), newEventId, newThreadId);
-      }
-      clonedEvent.setEventId(newEventId);
-      serialProcessor.enqueueEvent(operation, clonedEvent, substituteValue);
+        EventID originalEventId = clonedEvent.getEventId();
+        if (logger.isDebugEnabled()) {
+          logger.debug("The original EventId is {}", originalEventId);
+        }
+        // PARALLEL_THREAD_BUFFER * (index +1) + originalEventId.getThreadID();
+        // generating threadId by the algorithm explained above used to clash with
+        // fakeThreadId generated by putAll
+        // below is new way to generate threadId so that it doesn't clash with
+        // any.
+        long newThreadId = ThreadIdentifier.createFakeThreadIDForParallelGateway(index,
+            originalEventId.getThreadID(),
+            0 /*
+               * gateway sender event id index has already been applied in
+               * SerialGatewaySenderImpl.setModifiedEventId
+               */);
+        EventID newEventId = new EventID(originalEventId.getMembershipID(), newThreadId,
+            originalEventId.getSequenceID());
+        if (logger.isDebugEnabled()) {
+          logger.debug(
+              "{}: Generated event id for event with key={}, index={}, original event id={}, threadId={}, new event id={}, newThreadId={}",
+              this, event.getKey(), index, originalEventId, originalEventId.getThreadID(),
+              newEventId, newThreadId);
+        }
+        clonedEvent.setEventId(newEventId);
+        serialProcessor.enqueueEvent(operation, clonedEvent, substituteValue);
-    for(int i = 0; i < this.processors.size(); i++){
+    for (int i = 0; i < this.processors.size(); i++) {
-    
+
-        if(logger.isDebugEnabled()) {
+        if (logger.isDebugEnabled()) {
-        }  
+        }
-  
+
-  
+
-        while (serialProcessor.getException() == null
-            && serialProcessor.isStopped()) {
+        while (serialProcessor.getException() == null && serialProcessor.isStopped()) {
-                  .toLocalizedString(new Object[] { this.getId(),
-                      ex.getMessage() }), ex.getCause());
+                  .toLocalizedString(new Object[] {this.getId(), ex.getMessage()}),
+              ex.getCause());
-  
+
-    case KEY:
-      // key ordering
-      eventHashCode = event.getKey().hashCode();
-      break;
-    case THREAD:
-      // member id, thread id ordering
-      // requires a lot of threads to achieve parallelism
-      EventID eventId = event.getEventId();
-      byte[] memberId = eventId.getMembershipID();
-      long threadId = eventId.getThreadID();
-      int memberIdHashCode = Arrays.hashCode(memberId);
-      int threadIdHashCode = (int)(threadId ^ (threadId >>> 32));
-      eventHashCode = memberIdHashCode + threadIdHashCode;
-      if (logger.isDebugEnabled()) {
-        logger.debug("{}: Generated hashcode for event with key={}, memberId={}, threadId={}: {}",
-            this, event.getKey(), Arrays.toString(memberId), threadId, eventHashCode);
-      }
-      break;
-    case PARTITION:
-      eventHashCode = PartitionRegionHelper.isPartitionedRegion(event
-          .getRegion()) ? PartitionedRegionHelper.getHashKey(event)
-      // Get the partition for the event
-          : event.getKey().hashCode();
-      // Fall back to key ordering if the region is not partitioned
-      if (logger.isDebugEnabled()) {
-        logger.debug("{}: Generated partition hashcode for event with key={}: {}", this, event.getKey(), eventHashCode);
-      }
-      break;
+      case KEY:
+        // key ordering
+        eventHashCode = event.getKey().hashCode();
+        break;
+      case THREAD:
+        // member id, thread id ordering
+        // requires a lot of threads to achieve parallelism
+        EventID eventId = event.getEventId();
+        byte[] memberId = eventId.getMembershipID();
+        long threadId = eventId.getThreadID();
+        int memberIdHashCode = Arrays.hashCode(memberId);
+        int threadIdHashCode = (int) (threadId ^ (threadId >>> 32));
+        eventHashCode = memberIdHashCode + threadIdHashCode;
+        if (logger.isDebugEnabled()) {
+          logger.debug("{}: Generated hashcode for event with key={}, memberId={}, threadId={}: {}",
+              this, event.getKey(), Arrays.toString(memberId), threadId, eventHashCode);
+        }
+        break;
+      case PARTITION:
+        eventHashCode = PartitionRegionHelper.isPartitionedRegion(event.getRegion())
+            ? PartitionedRegionHelper.getHashKey(event)
+            // Get the partition for the event
+            : event.getKey().hashCode();
+        // Fall back to key ordering if the region is not partitioned
+        if (logger.isDebugEnabled()) {
+          logger.debug("{}: Generated partition hashcode for event with key={}: {}", this,
+              event.getKey(), eventHashCode);
+        }
+        break;
-  
+
-        .createThreadGroup(
-            "ConcurrentSerialGatewaySenderEventProcessor Logger Group",
-            logger);
+        .createThreadGroup("ConcurrentSerialGatewaySenderEventProcessor Logger Group", logger);
-    ExecutorService stopperService = Executors.newFixedThreadPool(
-        processors.size(), threadFactory);
+    ExecutorService stopperService = Executors.newFixedThreadPool(processors.size(), threadFactory);
-      List<Future<Boolean>> futures = stopperService
-          .invokeAll(stopperCallables);
+      List<Future<Boolean>> futures = stopperService.invokeAll(stopperCallables);
-          }     
+          }
-          logger.warn(LocalizedMessage.create(LocalizedStrings.GatewaySender_0_CAUGHT_EXCEPTION_WHILE_STOPPING_1, new Object[] { sender, e.getCause() }));
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.GatewaySender_0_CAUGHT_EXCEPTION_WHILE_STOPPING_1,
+              new Object[] {sender, e.getCause()}));
-    //shutdown the stopperService. This will release all the stopper threads
+    // shutdown the stopperService. This will release all the stopper threads
-    
+
-  
+
-  
+
-  public void pauseDispatching(){
+  public void pauseDispatching() {
-  
+
-  
+
-    for(SerialGatewaySenderEventProcessor processor: processors) {
+    for (SerialGatewaySenderEventProcessor processor : processors) {
-  
+
-   // super.waitForDispatcherToPause();
+    // super.waitForDispatcherToPause();
-  
+
-    return this.processors.get(0).getDispatcher();//Suranjan is that fine??
+    return this.processors.get(0).getDispatcher();// Suranjan is that fine??
-    //no op for concurrent 
-    
+    // no op for concurrent
+


Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-//@todo Extend to support the keys or entries of a region.
+// @todo Extend to support the keys or entries of a region.
- * A CompactRangeIndex is a range index that has simple data structures to
- * minimize its footprint, at the expense of doing extra work at index
- * maintenance. It is selected as the index implementation when the indexed
- * expression is a path expression and the from clause has only one iterator.
- * This implies there is only one value in the index for each region entry.
+ * A CompactRangeIndex is a range index that has simple data structures to minimize its footprint,
+ * at the expense of doing extra work at index maintenance. It is selected as the index
+ * implementation when the indexed expression is a path expression and the from clause has only one
+ * iterator. This implies there is only one value in the index for each region entry.
- 
+
-  
+
-      String indexedExpression, String projectionAttributes,
-      String origFromClause, String origIndexExpr, String[] definitions,
-      IndexStatistics stats) {
-    super(indexName, region, fromClause, indexedExpression,
-        projectionAttributes, origFromClause, origIndexExpr, definitions, stats);
+      String indexedExpression, String projectionAttributes, String origFromClause,
+      String origIndexExpr, String[] definitions, IndexStatistics stats) {
+    super(indexName, region, fromClause, indexedExpression, projectionAttributes, origFromClause,
+        origIndexExpr, definitions, stats);
-      indexStore = new MapIndexStore(((LocalRegion)region).getIndexMap(indexName, indexedExpression, origFromClause), region);
-    }
-    else {
+      indexStore = new MapIndexStore(
+          ((LocalRegion) region).getIndexMap(indexName, indexedExpression, origFromClause), region);
+    } else {
-    this.internalIndexStats.incNumUpdates(((IMQEvaluator) this.evaluator)
-        .getTotalEntriesUpdated());
+    this.internalIndexStats.incNumUpdates(((IMQEvaluator) this.evaluator).getTotalEntriesUpdated());
-   * @param opCode
-   *          one of OTHER_OP, BEFORE_UPDATE_OP, AFTER_UPDATE_OP.
+   * @param opCode one of OTHER_OP, BEFORE_UPDATE_OP, AFTER_UPDATE_OP.
-         oldKeyValue.remove();
+        oldKeyValue.remove();
-  
+
-  
-  public List queryEquijoinCondition(IndexProtocol indx,
-      ExecutionContext context) throws TypeMismatchException,
-      FunctionDomainException, NameResolutionException,
+
+  public List queryEquijoinCondition(IndexProtocol indx, ExecutionContext context)
+      throws TypeMismatchException, FunctionDomainException, NameResolutionException,
-        inner = ((RangeIndex) indx).getValueToEntriesMap().entrySet()
-            .iterator();
+        inner = ((RangeIndex) indx).getValueToEntriesMap().entrySet().iterator();
-                innerValue = ((CompactRangeIndex) indx).getIndexStorage().get(
-                    outerKey);
+                innerValue = ((CompactRangeIndex) indx).getIndexStorage().get(outerKey);
-   * This evaluates the left and right side of a EQUI-JOIN where condition for
-   * which this Index was used. Like, if condition is "p.ID = e.ID",
-   * {@link IndexInfo} will contain Left as p.ID, Right as e.ID and operator as
-   * TOK_EQ. This method will evaluate p.ID OR e.ID based on if it is inner or
-   * outer RegionEntry, and verify the p.ID = e.ID.
+   * This evaluates the left and right side of a EQUI-JOIN where condition for which this Index was
+   * used. Like, if condition is "p.ID = e.ID", {@link IndexInfo} will contain Left as p.ID, Right
+   * as e.ID and operator as TOK_EQ. This method will evaluate p.ID OR e.ID based on if it is inner
+   * or outer RegionEntry, and verify the p.ID = e.ID.
-  protected boolean verifyInnerAndOuterEntryValues(IndexStoreEntry entry,
-      ExecutionContext context, IndexInfo indexInfo, Object keyVal)
-      throws FunctionDomainException, TypeMismatchException,
+  protected boolean verifyInnerAndOuterEntryValues(IndexStoreEntry entry, ExecutionContext context,
+      IndexInfo indexInfo, Object keyVal) throws FunctionDomainException, TypeMismatchException,
-      runtimeItr.setCurrent(((MemoryIndexStoreEntry) entry)
-          .getDeserializedValue());
+      runtimeItr.setCurrent(((MemoryIndexStoreEntry) entry).getDeserializedValue());
-      case OQLLexerTokenTypes.TOK_EQ: {
-        key = TypeUtils.indexKeyFor(key);
-        key = getPdxStringForIndexedPdxKeys(key);
-        size = indexStore.size(key);
-        break;
-      }
-      case OQLLexerTokenTypes.TOK_NE_ALT:
-      case OQLLexerTokenTypes.TOK_NE:
-        size = this.region.size();
-        key = TypeUtils.indexKeyFor(key);
-        key = getPdxStringForIndexedPdxKeys(key);
-        size -= indexStore.size(key);
-        break;
-      case OQLLexerTokenTypes.TOK_LE:
-      case OQLLexerTokenTypes.TOK_LT:
-        if (matchLevel <= 0 && (key instanceof Number)) {
+        case OQLLexerTokenTypes.TOK_EQ: {
+          key = TypeUtils.indexKeyFor(key);
+          key = getPdxStringForIndexedPdxKeys(key);
+          size = indexStore.size(key);
+          break;
+        }
+        case OQLLexerTokenTypes.TOK_NE_ALT:
+        case OQLLexerTokenTypes.TOK_NE:
+          size = this.region.size();
+          key = TypeUtils.indexKeyFor(key);
+          key = getPdxStringForIndexedPdxKeys(key);
+          size -= indexStore.size(key);
+          break;
+        case OQLLexerTokenTypes.TOK_LE:
+        case OQLLexerTokenTypes.TOK_LT:
+          if (matchLevel <= 0 && (key instanceof Number)) {
-          int totalSize = indexStore.size();
-          if (CompactRangeIndex.testHook != null) {
-            CompactRangeIndex.testHook.hook(1);
+            int totalSize = indexStore.size();
+            if (CompactRangeIndex.testHook != null) {
+              CompactRangeIndex.testHook.hook(1);
+            }
+            if (totalSize > 1) {
+              Number keyAsNum = (Number) key;
+              int x = 0;
+              IndexStoreEntry firstEntry = null;
+              CloseableIterator<IndexStoreEntry> iter1 = null;
+              CloseableIterator<IndexStoreEntry> iter2 = null;
+
+              try {
+                iter1 = indexStore.iterator(null);
+                if (iter1.hasNext()) {
+                  firstEntry = iter1.next();
+
+                  IndexStoreEntry lastEntry = null;
+
+                  iter2 = indexStore.descendingIterator(null);
+                  if (iter2.hasNext()) {
+                    lastEntry = iter2.next();
+                  }
+
+                  if (firstEntry != null && lastEntry != null) {
+                    Number first = (Number) firstEntry.getDeserializedKey();
+                    Number last = (Number) lastEntry.getDeserializedKey();
+                    if (first.doubleValue() != last.doubleValue()) {
+                      // Shobhit: Now without ReadLoack on index we can end up with 0
+                      // in denominator if the numbers are floating-point and
+                      // truncated with conversion to long, and the first and last
+                      // truncate to the same long, so safest calculation is to
+                      // convert to doubles.
+                      x = (int) (((keyAsNum.doubleValue() - first.doubleValue()) * totalSize)
+                          / (last.doubleValue() - first.doubleValue()));
+                    }
+                  }
+
+                  if (x < 0) {
+                    x = 0;
+                  }
+                  size = x;
+                }
+              } finally {
+                if (iter1 != null) {
+                  iter1.close();
+                }
+                if (iter2 != null) {
+                  iter1.close();
+                }
+              }
+
+            } else {
+              // not attempting to differentiate between LT & LE
+              size = indexStore.size(key) > 0 ? 1 : 0;
+            }
+          } else {
+            size = Integer.MAX_VALUE;
-          if (totalSize > 1) {
-            Number keyAsNum = (Number) key;
-            int x = 0;
-            IndexStoreEntry firstEntry = null;
-            CloseableIterator<IndexStoreEntry> iter1 = null;
-            CloseableIterator<IndexStoreEntry> iter2 = null;
+          break;
-            try {
-              iter1 = indexStore.iterator(null);
-              if (iter1.hasNext()) {
-                firstEntry = iter1.next();
-            
-              IndexStoreEntry lastEntry = null;
-  
+        case OQLLexerTokenTypes.TOK_GE:
+        case OQLLexerTokenTypes.TOK_GT:
+          if (matchLevel <= 0 && (key instanceof Number)) {
+            int totalSize = indexStore.size();
+            if (CompactRangeIndex.testHook != null) {
+              CompactRangeIndex.testHook.hook(2);
+            }
+            if (totalSize > 1) {
+              Number keyAsNum = (Number) key;
+              int x = 0;
+              IndexStoreEntry firstEntry = null;
+              CloseableIterator<IndexStoreEntry> iter1 = null;
+              CloseableIterator<IndexStoreEntry> iter2 = null;
+
+              try {
+                iter1 = indexStore.iterator(null);
+                if (iter1.hasNext()) {
+                  firstEntry = iter1.next();
+                }
+
+                IndexStoreEntry lastEntry = null;
+
-             
-              if (firstEntry != null && lastEntry != null) {
-                Number first = (Number) firstEntry.getDeserializedKey();
-                Number last = (Number) lastEntry.getDeserializedKey();
-                if (first.doubleValue() != last.doubleValue()) {
-                  // Shobhit: Now without ReadLoack on index we can end up with 0
-                  // in denominator if the numbers are floating-point and
-                  // truncated with conversion to long, and the first and last
-                  // truncate to the same long, so safest calculation is to
-                  // convert to doubles.
-                  x = (int) (((keyAsNum.doubleValue() - first.doubleValue()) * totalSize) / (last
-                      .doubleValue() - first.doubleValue()));
+
+
+                if (firstEntry != null && lastEntry != null) {
+                  Number first = (Number) firstEntry.getDeserializedKey();
+                  Number last = (Number) lastEntry.getDeserializedKey();
+                  if (first.doubleValue() != last.doubleValue()) {
+                    // Shobhit: Now without ReadLoack on index we can end up with 0
+                    // in denominator if the numbers are floating-point and
+                    // truncated with conversion to long, and the first and last
+                    // truncate to the same long, so safest calculation is to
+                    // convert to doubles.
+                    x = (int) (((last.doubleValue() - keyAsNum.doubleValue()) * totalSize)
+                        / (last.doubleValue() - first.doubleValue()));
+                  }
+                }
+                if (x < 0) {
+                  x = 0;
+                }
+                size = x;
+              } finally {
+                if (iter1 != null) {
+                  iter1.close();
-  
-              if (x < 0) {
-                x = 0;
-              }
-              size = x;
-              }
-            } finally {
-              if (iter1 != null) {
-                iter1.close();
-              }
-              if (iter2 != null) {
-                iter1.close();
-              }
-            }
-
-          } else {
-            // not attempting to differentiate between LT & LE
-            size = indexStore.size(key) > 0 ? 1 : 0;
-          }
-        } else {
-          size = Integer.MAX_VALUE;
-        }
-        break;
-
-      case OQLLexerTokenTypes.TOK_GE:
-      case OQLLexerTokenTypes.TOK_GT:
-        if (matchLevel <= 0 && (key instanceof Number)) {
-          int totalSize = indexStore.size();
-          if (CompactRangeIndex.testHook != null) {
-            CompactRangeIndex.testHook.hook(2);
-          }
-          if (totalSize > 1) {
-            Number keyAsNum = (Number) key;
-            int x = 0;
-            IndexStoreEntry firstEntry = null;
-            CloseableIterator<IndexStoreEntry> iter1 = null;
-            CloseableIterator<IndexStoreEntry> iter2 = null;
-
-            try {
-              iter1 = indexStore.iterator(null);
-              if (iter1.hasNext()) {
-                firstEntry = iter1.next();
-              }
-           
-            IndexStoreEntry lastEntry = null;
-
-              iter2 = indexStore.descendingIterator(null);
-              if (iter2.hasNext()) {
-                lastEntry = iter2.next();
-              }
-           
-
-            if (firstEntry != null && lastEntry != null) {
-              Number first = (Number) firstEntry.getDeserializedKey();
-              Number last = (Number) lastEntry.getDeserializedKey();
-              if (first.doubleValue() != last.doubleValue()) {
-                // Shobhit: Now without ReadLoack on index we can end up with 0
-                // in denominator if the numbers are floating-point and
-                // truncated with conversion to long, and the first and last
-                // truncate to the same long, so safest calculation is to
-                // convert to doubles.
-                x = (int) (((last.doubleValue() - keyAsNum.doubleValue()) * totalSize) / (last
-                    .doubleValue() - first.doubleValue()));
-              }
-            }
-            if (x < 0) {
-              x = 0;
-            }
-            size = x;
-            } finally {
-              if (iter1 != null) {
-                iter1.close();
-              }
+            } else {
+              // not attempting to differentiate between GT & GE
+              size = indexStore.size(key) > 0 ? 1 : 0;
-            // not attempting to differentiate between GT & GE
-            size = indexStore.size(key) > 0 ? 1 : 0;
+            size = Integer.MAX_VALUE;
-        } else {
-          size = Integer.MAX_VALUE;
-        }
-        break;
+          break;
+    } catch (EntryDestroyedException e) {
+      return Integer.MAX_VALUE;
-      CompiledValue iterOps, RuntimeIterator runtimeItr,
-      ExecutionContext context, Set keysToRemove, List projAttrib,
-      SelectResults intermediateResults, boolean isIntersection)
-      throws TypeMismatchException, FunctionDomainException,
-      NameResolutionException, QueryInvocationTargetException {
+      CompiledValue iterOps, RuntimeIterator runtimeItr, ExecutionContext context, Set keysToRemove,
+      List projAttrib, SelectResults intermediateResults, boolean isIntersection)
+      throws TypeMismatchException, FunctionDomainException, NameResolutionException,
+      QueryInvocationTargetException {
-    Boolean applyLimit = (Boolean) context
-        .cacheGet(CompiledValue.CAN_APPLY_LIMIT_AT_INDEX);
+    Boolean applyLimit = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_LIMIT_AT_INDEX);
-      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT))
-          .intValue();
+      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue();
-    Boolean orderByClause = (Boolean) context
-        .cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
+    Boolean orderByClause = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-    evaluate(key, operator, results, iterOps, runtimeItr, context,
-        keysToRemove, projAttrib, intermediateResults, isIntersection, limit,
-        applyOrderBy, orderByAttrs);
+    evaluate(key, operator, results, iterOps, runtimeItr, context, keysToRemove, projAttrib,
+        intermediateResults, isIntersection, limit, applyOrderBy, orderByAttrs);
-  void lockedQuery(Object lowerBoundKey, int lowerBoundOperator,
-      Object upperBoundKey, int upperBoundOperator, Collection results,
-      Set keysToRemove, ExecutionContext context) throws TypeMismatchException,
-      FunctionDomainException, NameResolutionException,
+  void lockedQuery(Object lowerBoundKey, int lowerBoundOperator, Object upperBoundKey,
+      int upperBoundOperator, Collection results, Set keysToRemove, ExecutionContext context)
+      throws TypeMismatchException, FunctionDomainException, NameResolutionException,
-    Boolean applyLimit = (Boolean) context
-        .cacheGet(CompiledValue.CAN_APPLY_LIMIT_AT_INDEX);
+    Boolean applyLimit = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_LIMIT_AT_INDEX);
-      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT))
-          .intValue();
+      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue();
-    Boolean orderByClause = (Boolean) context
-        .cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
+    Boolean orderByClause = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-        iterator = indexStore.iterator(lowerBoundKey, lowerBoundInclusive, 
-            upperBoundKey, upperBoundInclusive, keysToRemove);
+        iterator = indexStore.iterator(lowerBoundKey, lowerBoundInclusive, upperBoundKey,
+            upperBoundInclusive, keysToRemove);
+      } else {
+        iterator = indexStore.descendingIterator(lowerBoundKey, lowerBoundInclusive, upperBoundKey,
+            upperBoundInclusive, keysToRemove);
-      else {
-        iterator = indexStore.descendingIterator(lowerBoundKey,
-            lowerBoundInclusive, upperBoundKey, upperBoundInclusive,
-            keysToRemove);
-      }
-      addToResultsFromEntries(lowerBoundKey, upperBoundKey, lowerBoundOperator, upperBoundOperator, iterator, results, null, null, context, null,
-          null, true, multiColOrderBy ? -1 : limit);
+      addToResultsFromEntries(lowerBoundKey, upperBoundKey, lowerBoundOperator, upperBoundOperator,
+          iterator, results, null, null, context, null, null, true, multiColOrderBy ? -1 : limit);
-  private void evaluate(Object key, int operator, Collection results,
-      CompiledValue iterOps, RuntimeIterator runtimeItr,
-      ExecutionContext context, Set keysToRemove, List projAttrib,
-      SelectResults intermediateResults, boolean isIntersection, int limit,
-      boolean applyOrderBy, List orderByAttribs) throws TypeMismatchException,
-      FunctionDomainException, NameResolutionException,
-      QueryInvocationTargetException {
+  private void evaluate(Object key, int operator, Collection results, CompiledValue iterOps,
+      RuntimeIterator runtimeItr, ExecutionContext context, Set keysToRemove, List projAttrib,
+      SelectResults intermediateResults, boolean isIntersection, int limit, boolean applyOrderBy,
+      List orderByAttribs) throws TypeMismatchException, FunctionDomainException,
+      NameResolutionException, QueryInvocationTargetException {
-      case OQLLexerTokenTypes.TOK_EQ:
-        assert keysToRemove.isEmpty();
-        iterator = indexStore.get(key);
-        addToResultsFromEntries(key, operator, iterator, results, iterOps, runtimeItr,
-            context, projAttrib, intermediateResults, isIntersection,
-            multiColOrderBy ? -1 : limit);
-        break;
-      case OQLLexerTokenTypes.TOK_LT: {
-        if (asc) {
-          iterator = indexStore.iterator(null, true, key, false, keysToRemove);
-        } else {
-          iterator = indexStore.descendingIterator(null, true, key, false,
-              keysToRemove);
+        case OQLLexerTokenTypes.TOK_EQ:
+          assert keysToRemove.isEmpty();
+          iterator = indexStore.get(key);
+          addToResultsFromEntries(key, operator, iterator, results, iterOps, runtimeItr, context,
+              projAttrib, intermediateResults, isIntersection, multiColOrderBy ? -1 : limit);
+          break;
+        case OQLLexerTokenTypes.TOK_LT: {
+          if (asc) {
+            iterator = indexStore.iterator(null, true, key, false, keysToRemove);
+          } else {
+            iterator = indexStore.descendingIterator(null, true, key, false, keysToRemove);
+          }
+          addToResultsFromEntries(key, operator, iterator, results, iterOps, runtimeItr, context,
+              projAttrib, intermediateResults, isIntersection, multiColOrderBy ? -1 : limit);
-        addToResultsFromEntries(key, operator, iterator, results, iterOps, runtimeItr,
-            context, projAttrib, intermediateResults, isIntersection,
-            multiColOrderBy ? -1 : limit);
-      }
-        break;
-      case OQLLexerTokenTypes.TOK_LE: {
-        if (asc) {
-          iterator = indexStore.iterator(null, true, key, true, keysToRemove);
-        } else {
-          iterator = indexStore.descendingIterator(null, true, key, true,
-              keysToRemove);
-        }
+          break;
+        case OQLLexerTokenTypes.TOK_LE: {
+          if (asc) {
+            iterator = indexStore.iterator(null, true, key, true, keysToRemove);
+          } else {
+            iterator = indexStore.descendingIterator(null, true, key, true, keysToRemove);
+          }
-        addToResultsFromEntries(key, operator, iterator, results, iterOps, runtimeItr,
-            context, projAttrib, intermediateResults, isIntersection,
-            multiColOrderBy ? -1 : limit);
-      }
-        break;
-      case OQLLexerTokenTypes.TOK_GT: {
-        if (asc) {
-          iterator = indexStore.iterator(key, false, keysToRemove);
-        } else {
-          iterator = indexStore.descendingIterator(key, false, keysToRemove);
+          addToResultsFromEntries(key, operator, iterator, results, iterOps, runtimeItr, context,
+              projAttrib, intermediateResults, isIntersection, multiColOrderBy ? -1 : limit);
-        addToResultsFromEntries(key, operator, iterator, results, iterOps, runtimeItr,
-            context, projAttrib, intermediateResults, isIntersection,
-            multiColOrderBy ? -1 : limit);
-      }
-        break;
-      case OQLLexerTokenTypes.TOK_GE: {
-        if (asc) {
-          iterator = indexStore.iterator(key, true, keysToRemove);
-        } else {
-          iterator = indexStore.descendingIterator(key, true, keysToRemove);
+          break;
+        case OQLLexerTokenTypes.TOK_GT: {
+          if (asc) {
+            iterator = indexStore.iterator(key, false, keysToRemove);
+          } else {
+            iterator = indexStore.descendingIterator(key, false, keysToRemove);
+          }
+          addToResultsFromEntries(key, operator, iterator, results, iterOps, runtimeItr, context,
+              projAttrib, intermediateResults, isIntersection, multiColOrderBy ? -1 : limit);
+          break;
+        case OQLLexerTokenTypes.TOK_GE: {
+          if (asc) {
+            iterator = indexStore.iterator(key, true, keysToRemove);
+          } else {
+            iterator = indexStore.descendingIterator(key, true, keysToRemove);
+          }
-        addToResultsFromEntries(key, operator, iterator, results, iterOps, runtimeItr,
-            context, projAttrib, intermediateResults, isIntersection,
-            multiColOrderBy ? -1 : limit);
-      }
-        break;
-      case OQLLexerTokenTypes.TOK_NE_ALT:
-      case OQLLexerTokenTypes.TOK_NE: {
-        keysToRemove.add(key);
-        if (asc) {
-          iterator = indexStore.iterator(keysToRemove);
-        } else {
-          iterator = indexStore.descendingIterator(keysToRemove);
+          addToResultsFromEntries(key, operator, iterator, results, iterOps, runtimeItr, context,
+              projAttrib, intermediateResults, isIntersection, multiColOrderBy ? -1 : limit);
-        addToResultsFromEntries(key, operator, iterator, results, iterOps, runtimeItr,
-            context, projAttrib, intermediateResults, isIntersection,
-            multiColOrderBy ? -1 : limit);
-        //If the key is not null, then add the nulls to the results as this is a not equals query
-        if (!IndexManager.NULL.equals(key)) {
-          //we pass in the operator TOK_EQ because we want to add results where the key is equal to NULL
-          addToResultsFromEntries(IndexManager.NULL, OQLLexerTokenTypes.TOK_EQ, indexStore.get(IndexManager.NULL), results,
-            iterOps, runtimeItr, context, projAttrib, intermediateResults,
-            isIntersection, multiColOrderBy ? -1 : limit);
+          break;
+        case OQLLexerTokenTypes.TOK_NE_ALT:
+        case OQLLexerTokenTypes.TOK_NE: {
+          keysToRemove.add(key);
+          if (asc) {
+            iterator = indexStore.iterator(keysToRemove);
+          } else {
+            iterator = indexStore.descendingIterator(keysToRemove);
+          }
+          addToResultsFromEntries(key, operator, iterator, results, iterOps, runtimeItr, context,
+              projAttrib, intermediateResults, isIntersection, multiColOrderBy ? -1 : limit);
+          // If the key is not null, then add the nulls to the results as this is a not equals query
+          if (!IndexManager.NULL.equals(key)) {
+            // we pass in the operator TOK_EQ because we want to add results where the key is equal
+            // to NULL
+            addToResultsFromEntries(IndexManager.NULL, OQLLexerTokenTypes.TOK_EQ,
+                indexStore.get(IndexManager.NULL), results, iterOps, runtimeItr, context,
+                projAttrib, intermediateResults, isIntersection, multiColOrderBy ? -1 : limit);
+          }
+          // If the key is not undefined, then add the undefineds to the results as this is a not
+          // equals query
+          if (!QueryService.UNDEFINED.equals(key)) {
+            // we pass in the operator TOK_EQ because we want to add results where the key is equal
+            // to UNDEFINED
+            addToResultsFromEntries(QueryService.UNDEFINED, OQLLexerTokenTypes.TOK_EQ,
+                indexStore.get(QueryService.UNDEFINED), results, iterOps, runtimeItr, context,
+                projAttrib, intermediateResults, isIntersection, multiColOrderBy ? -1 : limit);
+          }
-        //If the key is not undefined, then add the undefineds to the results as this is a not equals query
-        if (!QueryService.UNDEFINED.equals(key)) {
-          //we pass in the operator TOK_EQ because we want to add results where the key is equal to UNDEFINED
-          addToResultsFromEntries(QueryService.UNDEFINED, OQLLexerTokenTypes.TOK_EQ, indexStore.get(QueryService.UNDEFINED),
-            results, iterOps, runtimeItr, context, projAttrib,
-            intermediateResults, isIntersection, multiColOrderBy ? -1 : limit);
-        }
-      }
-        break;
-      default:
-        throw new AssertionError("Operator = " + operator);
+          break;
+        default:
+          throw new AssertionError("Operator = " + operator);
-          }
-          else {
+          } else {
-          addToResultsFromEntries(key, OQLLexerTokenTypes.TOK_NE, iterator, results, iterOps, runtimeItr,
-              context, projAttrib, intermediateResults, isIntersection,
+          addToResultsFromEntries(key, OQLLexerTokenTypes.TOK_NE, iterator, results, iterOps,
+              runtimeItr, context, projAttrib, intermediateResults, isIntersection,
-  
-  //Only used by CompactMapRangeIndex.  This is due to the way the index initialization happens
-  //first we use the IMQEvaluator for CompactMapRangeIndex
-  //Each index in CMRI is a CRI that has the CRI.IMQ and not AbstractIndex.IMQ
-  //So instead we create create the evaluator 
-  //because we are not doing index init as usual (each value is just put directly?)
-  //we must set the result type to match
+
+  // Only used by CompactMapRangeIndex. This is due to the way the index initialization happens
+  // first we use the IMQEvaluator for CompactMapRangeIndex
+  // Each index in CMRI is a CRI that has the CRI.IMQ and not AbstractIndex.IMQ
+  // So instead we create create the evaluator
+  // because we are not doing index init as usual (each value is just put directly?)
+  // we must set the result type to match
-    ((IMQEvaluator)this.evaluator).indexResultSetType = objectType;
+    ((IMQEvaluator) this.evaluator).indexResultSetType = objectType;
-  
-  public ObjectType getResultSetType()  {
+
+  public ObjectType getResultSetType() {
-  
-  /*
-   * 
-   * @param lowerBoundKey the index key to match on
-   * @param lowerBoundOperator the operator to use to determine a match
-   */
-  private void addToResultsFromEntries(Object lowerBoundKey,
-      int lowerBoundOperator,
-      CloseableIterator<IndexStoreEntry> entriesIter, Collection result,
-      CompiledValue iterOps, RuntimeIterator runtimeItr,
-      ExecutionContext context, List projAttrib,
-      SelectResults intermediateResults, boolean isIntersection, int limit)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
-    addToResultsFromEntries(lowerBoundKey, null, lowerBoundOperator, -1
-        ,entriesIter, result, iterOps, runtimeItr, context, projAttrib
-        ,intermediateResults, isIntersection, limit);
-  }
-   * @param lowerBoundKey the index key to match on for a lower bound on a ranged query, otherwise the key to match on
-   * @param upperBoundKey the index key to match on for an upper bound on a ranged query, otherwise null
+   * @param lowerBoundKey the index key to match on
+   * 
+   * @param lowerBoundOperator the operator to use to determine a match
+   */
+  private void addToResultsFromEntries(Object lowerBoundKey, int lowerBoundOperator,
+      CloseableIterator<IndexStoreEntry> entriesIter, Collection result, CompiledValue iterOps,
+      RuntimeIterator runtimeItr, ExecutionContext context, List projAttrib,
+      SelectResults intermediateResults, boolean isIntersection, int limit)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
+    addToResultsFromEntries(lowerBoundKey, null, lowerBoundOperator, -1, entriesIter, result,
+        iterOps, runtimeItr, context, projAttrib, intermediateResults, isIntersection, limit);
+  }
+
+  /*
+   * 
+   * @param lowerBoundKey the index key to match on for a lower bound on a ranged query, otherwise
+   * the key to match on
+   * 
+   * @param upperBoundKey the index key to match on for an upper bound on a ranged query, otherwise
+   * null
+   * 
+   * 
-      CloseableIterator<IndexStoreEntry> entriesIter, Collection result,
-      CompiledValue iterOps, RuntimeIterator runtimeItr,
-      ExecutionContext context, List projAttrib,
+      CloseableIterator<IndexStoreEntry> entriesIter, Collection result, CompiledValue iterOps,
+      RuntimeIterator runtimeItr, ExecutionContext context, List projAttrib,
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-      boolean limitApplied = false;
-      if (entriesIter == null || (limitApplied =verifyLimit(result, limit, context))) {
-        if(limitApplied) {          
-          if(observer != null) {
-            observer.limitAppliedAtIndexLevel(this, limit, result);
-          }
+    boolean limitApplied = false;
+    if (entriesIter == null || (limitApplied = verifyLimit(result, limit, context))) {
+      if (limitApplied) {
+        if (observer != null) {
+          observer.limitAppliedAtIndexLevel(this, limit, result);
-        return;
-    
-      Set seenKey = null;
-      if (IndexManager.IS_TEST_EXPANSION) {
-        seenKey = new HashSet();
-      }
+      return;
+    }
+
+    Set seenKey = null;
+    if (IndexManager.IS_TEST_EXPANSION) {
+      seenKey = new HashSet();
+    }
-            this.region
-                .getCache()
-                .getLogger()
-                .fine(
-                    "IndexManager TestHook is set in addToResultsFromEntries.");
+            this.region.getCache().getLogger()
+                .fine("IndexManager TestHook is set in addToResultsFromEntries.");
-          List expandedResults = expandValue(context, lowerBoundKey,
-              upperBoundKey, lowerBoundOperator, upperBoundOperator, value);
+          List expandedResults = expandValue(context, lowerBoundKey, upperBoundKey,
+              lowerBoundOperator, upperBoundOperator, value);
-                  result.add(new CqEntry(indexEntry.getDeserializedRegionKey(),
-                      value));
+                  result.add(new CqEntry(indexEntry.getDeserializedRegionKey(), value));
-                  applyProjection(projAttrib, context, result, value,
-                      intermediateResults, isIntersection);
+                  applyProjection(projAttrib, context, result, value, intermediateResults,
+                      isIntersection);
-              IndexInfo indexInfo = (IndexInfo) context
-                  .cacheGet(CompiledValue.INDEX_INFO);
+              IndexInfo indexInfo = (IndexInfo) context.cacheGet(CompiledValue.INDEX_INFO);
-                result.add(new CqEntry(indexEntry.getDeserializedRegionKey(),
-                    value));
+                result.add(new CqEntry(indexEntry.getDeserializedRegionKey(), value));
-                applyProjection(projAttrib, context, result, value,
-                    intermediateResults, isIntersection);
+                applyProjection(projAttrib, context, result, value, intermediateResults,
+                    isIntersection);
-        
-      }
-      catch(EntryDestroyedException e) {
-        //ignore it
+
+      } catch (EntryDestroyedException e) {
+        // ignore it
-  
-  public List expandValue(ExecutionContext context, Object lowerBoundKey, Object upperBoundKey, int lowerBoundOperator, int upperBoundOperator, Object value) {
+
+  public List expandValue(ExecutionContext context, Object lowerBoundKey, Object upperBoundKey,
+      int lowerBoundOperator, int upperBoundOperator, Object value) {
-      this.evaluator.expansion(expandedResults, lowerBoundKey, upperBoundKey, lowerBoundOperator, upperBoundOperator, value);
+      this.evaluator.expansion(expandedResults, lowerBoundKey, upperBoundKey, lowerBoundOperator,
+          upperBoundOperator, value);
-    }
-    catch (IMQException e) {
+    } catch (IMQException e) {
-      throw new CacheException(e){};
+      throw new CacheException(e) {};
-   * This evaluates the left and right side of a where condition for which this
-   * Index was used. Like, if condition is "ID > 1", {@link IndexInfo} will
-   * contain Left as ID, Right as '1' and operator as TOK_GT. This method will
-   * evaluate ID from region entry value and verify the ID > 1.
+   * This evaluates the left and right side of a where condition for which this Index was used.
+   * Like, if condition is "ID > 1", {@link IndexInfo} will contain Left as ID, Right as '1' and
+   * operator as TOK_GT. This method will evaluate ID from region entry value and verify the ID > 1.
-   * Note: IndexInfo is created for each query separately based on the condition
-   * being evaluated using the Index.
+   * Note: IndexInfo is created for each query separately based on the condition being evaluated
+   * using the Index.
-   * @return true if RegionEntry value satisfies the where condition (contained
-   *         in IndexInfo).
+   * @return true if RegionEntry value satisfies the where condition (contained in IndexInfo).
-  protected boolean evaluateEntry(IndexInfo indexInfo,
-      ExecutionContext context, Object keyVal) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+  protected boolean evaluateEntry(IndexInfo indexInfo, ExecutionContext context, Object keyVal)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-      //This next check is for map queries with In Clause, in those cases the reevaluation creates a tuple.  In other cases it does not
-      if(null != right  && indexInfo._getIndex() instanceof CompactMapRangeIndex && right instanceof Object[]){
-        right = ((Object[])right)[0];
+      // This next check is for map queries with In Clause, in those cases the reevaluation creates
+      // a tuple. In other cases it does not
+      if (null != right && indexInfo._getIndex() instanceof CompactMapRangeIndex
+          && right instanceof Object[]) {
+        right = ((Object[]) right)[0];
-    
+
-          case CompiledValue.LITERAL:
-            right = ((CompiledLiteral) key).getSavedPdxString();
-            break;
-          case OQLLexerTokenTypes.QUERY_PARAM:
-            right = ((CompiledBindArgument) key).getSavedPdxString(context);
-            break;
-          case CompiledValue.FUNCTION:
-          case CompiledValue.PATH:
-            right = new PdxString((String) right);
+            case CompiledValue.LITERAL:
+              right = ((CompiledLiteral) key).getSavedPdxString();
+              break;
+            case OQLLexerTokenTypes.QUERY_PARAM:
+              right = ((CompiledBindArgument) key).getSavedPdxString(context);
+              break;
+            case CompiledValue.FUNCTION:
+            case CompiledValue.PATH:
+              right = new PdxString((String) right);
-      if (result == QueryService.UNDEFINED){
+      if (result == QueryService.UNDEFINED) {
-        if (operator != OQLLexerTokenTypes.TOK_NE 
-            || operator != OQLLexerTokenTypes.TOK_NE_ALT) {
-          return Boolean.TRUE;    
-        } else{
+        if (operator != OQLLexerTokenTypes.TOK_NE || operator != OQLLexerTokenTypes.TOK_NE_ALT) {
+          return Boolean.TRUE;
+        } else {
-      }  
+      }
-    if(numKeys > 0){
+    if (numKeys > 0) {
-    if(numValues > 0) {
+    if (numValues > 0) {
-    if(updates > 0) {
+    if (updates > 0) {
-      this.vsdStats = new IndexStats(getRegion().getCache()
-          .getDistributedSystem(), indexName);
+      this.vsdStats = new IndexStats(getRegion().getCache().getDistributedSystem(), indexName);
-     * Returns the total amount of time (in nanoseconds) spent updating this
-     * index.
+     * Returns the total amount of time (in nanoseconds) spent updating this index.
-     * Returns the total number of times this index has been accessed by a
-     * query.
+     * Returns the total number of times this index has been accessed by a query.
-    
+
-      sb.append("Total Update time = ").append(getTotalUpdateTime())
-          .append("\n");
+      sb.append("Total Update time = ").append(getTotalUpdateTime()).append("\n");
-     * Asif : The boolean if true indicates that the 0th iterator is on entries
-     * . If the 0th iterator is on collection of Region.Entry objects, then the
-     * RegionEntry object used in Index data objects is obtained directly from
-     * its corresponding Region.Entry object. However if the 0th iterator is not
-     * on entries then the boolean is false. In this case the additional
-     * projection attribute gives us the original value of the iterator while
-     * the Region.Entry object is obtained from 0th iterator. It is possible to
-     * have index being created on a Region Entry itself , instead of a Region.
-     * A Map operator( Compiled Index Operator) used with Region enables, us to
-     * create such indexes. In such case the 0th iterator, even if it represents
-     * a collection of Objects which are not Region.Entry objects, still the
-     * boolean remains true, as the Entry object can be easily obtained from the
-     * 0th iterator. In this case, the additional projection attribute s not
-     * null as it is used to evaluate the Entry object from the 0th iterator.
+     * Asif : The boolean if true indicates that the 0th iterator is on entries . If the 0th
+     * iterator is on collection of Region.Entry objects, then the RegionEntry object used in Index
+     * data objects is obtained directly from its corresponding Region.Entry object. However if the
+     * 0th iterator is not on entries then the boolean is false. In this case the additional
+     * projection attribute gives us the original value of the iterator while the Region.Entry
+     * object is obtained from 0th iterator. It is possible to have index being created on a Region
+     * Entry itself , instead of a Region. A Map operator( Compiled Index Operator) used with Region
+     * enables, us to create such indexes. In such case the 0th iterator, even if it represents a
+     * collection of Objects which are not Region.Entry objects, still the boolean remains true, as
+     * the Entry object can be easily obtained from the 0th iterator. In this case, the additional
+     * projection attribute s not null as it is used to evaluate the Entry object from the 0th
+     * iterator.
-      Object params1[] = { new QRegion(rgn, false) };
+      Object params1[] = {new QRegion(rgn, false)};
-        
-    public void expansion(List expandedResults, Object lowerBoundKey, Object upperBoundKey, int lowerBoundOperator, int upperBoundOperator, Object value) throws IMQException {
+
+    public void expansion(List expandedResults, Object lowerBoundKey, Object upperBoundKey,
+        int lowerBoundOperator, int upperBoundOperator, Object value) throws IMQException {
-        RuntimeIterator iter = (RuntimeIterator)iterators.get(0);
+        RuntimeIterator iter = (RuntimeIterator) iterators.get(0);
-        
-        //first iter level is region entries, we can ignore as we already broke it down in the index
-        doNestedExpansion(1, expansionContext, expandedResults, lowerBoundKey, upperBoundKey, lowerBoundOperator, upperBoundOperator, value);
-      }
-      catch (Exception e) {
-        throw new IMQException(e){};
+
+        // first iter level is region entries, we can ignore as we already broke it down in the
+        // index
+        doNestedExpansion(1, expansionContext, expandedResults, lowerBoundKey, upperBoundKey,
+            lowerBoundOperator, upperBoundOperator, value);
+      } catch (Exception e) {
+        throw new IMQException(e) {};
-    
-    private void doNestedExpansion(int level, ExecutionContext expansionContext, List expandedResults, Object lowerBoundKey, Object upperBoundKey, int lowerBoundOperator, int upperBoundOperator, Object value) throws TypeMismatchException,
-    AmbiguousNameException, FunctionDomainException,
-    NameResolutionException, QueryInvocationTargetException, IMQException {
+
+    private void doNestedExpansion(int level, ExecutionContext expansionContext,
+        List expandedResults, Object lowerBoundKey, Object upperBoundKey, int lowerBoundOperator,
+        int upperBoundOperator, Object value)
+        throws TypeMismatchException, AmbiguousNameException, FunctionDomainException,
+        NameResolutionException, QueryInvocationTargetException, IMQException {
-        expand(expansionContext, expandedResults, lowerBoundKey, upperBoundKey, lowerBoundOperator, upperBoundOperator, value);
-      }
-      else {
-        RuntimeIterator rIter = (RuntimeIterator)iterList.get(level);
+        expand(expansionContext, expandedResults, lowerBoundKey, upperBoundKey, lowerBoundOperator,
+            upperBoundOperator, value);
+      } else {
+        RuntimeIterator rIter = (RuntimeIterator) iterList.get(level);
-          doNestedExpansion(level + 1, expansionContext,expandedResults, lowerBoundKey, upperBoundKey, lowerBoundOperator, upperBoundOperator, value);
+          doNestedExpansion(level + 1, expansionContext, expandedResults, lowerBoundKey,
+              upperBoundKey, lowerBoundOperator, upperBoundOperator, value);
-    
+
-     * @param upperBoundKey if null, we do not do an upperbound check (may need to change this if we ever use null in a range query)
+     * @param upperBoundKey if null, we do not do an upperbound check (may need to change this if we
+     *        ever use null in a range query)
-    public void expand(ExecutionContext expansionContext, List expandedResults, Object lowerBoundKey, Object upperBoundKey, int lowerBoundOperator, int upperBoundOperator, Object value) throws IMQException {
+    public void expand(ExecutionContext expansionContext, List expandedResults,
+        Object lowerBoundKey, Object upperBoundKey, int lowerBoundOperator, int upperBoundOperator,
+        Object value) throws IMQException {
-        
+
-        //Check upper bound
+        // Check upper bound
-        
+
-          }
-          else if (lowerBoundOperator == OQLLexerTokenTypes.TOK_NE) {
+          } else if (lowerBoundOperator == OQLLexerTokenTypes.TOK_NE) {
-        }
-        else {
-          //Check lower bound
+        } else {
+          // Check lower bound
-        
-        //if the resultSetType is of structType, we need to create tuples
-        //this is due to the way the resultsSets are being created
+
+        // if the resultSetType is of structType, we need to create tuples
+        // this is due to the way the resultsSets are being created
-          RuntimeIterator iter = (RuntimeIterator)currentRuntimeIters.get(0);
+          RuntimeIterator iter = (RuntimeIterator) currentRuntimeIters.get(0);
-        }
-        else {
+        } else {
-              RuntimeIterator iter = (RuntimeIterator)currentRuntimeIters.get(i);
+              RuntimeIterator iter = (RuntimeIterator) currentRuntimeIters.get(i);
-            Support
-                .Assert(
-                    this.indexResultSetType instanceof StructTypeImpl,
-                    "The Index ResultType should have been an instance of StructTypeImpl rather than ObjectTypeImpl. The indxeResultType is "
-                        + this.indexResultSetType);
+            Support.Assert(this.indexResultSetType instanceof StructTypeImpl,
+                "The Index ResultType should have been an instance of StructTypeImpl rather than ObjectTypeImpl. The indxeResultType is "
+                    + this.indexResultSetType);
-          indxResultSet = new StructImpl(
-              (StructTypeImpl)this.indexResultSetType, tuple);
+          indxResultSet = new StructImpl((StructTypeImpl) this.indexResultSetType, tuple);
-        
+
-      }
-      catch (Exception e) {
+      } catch (Exception e) {
-    
+
-      dQRegion.setEntry(VMThinRegionEntryHeap.getEntryFactory().createEntry((RegionEntryContext)rgn, 0, value));
-      Object params[] = { dQRegion };
+      dQRegion.setEntry(
+          VMThinRegionEntryHeap.getEntryFactory().createEntry((RegionEntryContext) rgn, 0, value));
+      Object params[] = {dQRegion};
-          CompiledIteratorDef iterDef = (CompiledIteratorDef) fromIterators
-              .get(i);
+          CompiledIteratorDef iterDef = (CompiledIteratorDef) fromIterators.get(i);
-        Support
-            .Assert(
-                this.indexResultSetType != null,
-                "IMQEvaluator::evaluate:The StrcutType should have been initialized during index creation");
+        Support.Assert(this.indexResultSetType != null,
+            "IMQEvaluator::evaluate:The StrcutType should have been initialized during index creation");
-     * @param add
-     *          true if adding to index, false if removing
+     * @param add true if adding to index, false if removing
-      Object params[] = { dQRegion };
+      Object params[] = {dQRegion};
-          CompiledIteratorDef iterDef = (CompiledIteratorDef) fromIterators
-              .get(i);
+          CompiledIteratorDef iterDef = (CompiledIteratorDef) fromIterators.get(i);
-        Support
-            .Assert(
-                this.indexResultSetType != null,
-                "IMQEvaluator::evaluate:The StrcutType should have been initialized during index creation");
+        Support.Assert(this.indexResultSetType != null,
+            "IMQEvaluator::evaluate:The StrcutType should have been initialized during index creation");
-          //This code relies on current implementation of remove mapping, relying on behavior that will force a
-          //crawl through the index to remove the entry if it exists, even if it is not present at the provided key
+          // This code relies on current implementation of remove mapping, relying on behavior that
+          // will force a
+          // crawl through the index to remove the entry if it exists, even if it is not present at
+          // the provided key
-        }
-        else {
+        } else {
-          CompiledIteratorDef iterDef = (CompiledIteratorDef) this.indexInitIterators
-              .get(i);
+          CompiledIteratorDef iterDef = (CompiledIteratorDef) this.indexInitIterators.get(i);
-            this.initContext
-                .addToIndependentRuntimeItrMapForIndexCreation(iterDef);
+            this.initContext.addToIndependentRuntimeItrMapForIndexCreation(iterDef);
-        if(loadEntries) {
-          doNestedIterationsForIndexInit(0,
-              this.initContext.getCurrentIterators());
+        if (loadEntries) {
+          doNestedIterationsForIndexInit(0, this.initContext.getCurrentIterators());
-      }
-      finally {
+      } finally {
-        throws TypeMismatchException, AmbiguousNameException,
-        FunctionDomainException, NameResolutionException,
-        QueryInvocationTargetException, IMQException {
+        throws TypeMismatchException, AmbiguousNameException, FunctionDomainException,
+        NameResolutionException, QueryInvocationTargetException, IMQException {
-     * Asif : This function is used to obtain Index data at the time of index
-     * creation. Each element of the List is an Object Array of size 3. The 0th
-     * element of Object Array stores the value of Index Expression. The 1st
-     * element of ObjectArray contains the RegionEntry object ( If the booelan
-     * isFirstItrOnEntry is false, then the 0th iterator will give us the
-     * Region.Entry object which can be used to obtain the underlying
-     * RegionEntry object. If the boolean is true & additional projection
-     * attribute is not null, then the Region.Entry object can be obtained by
-     * evaluating the additional projection attribute. If the boolean
-     * isFirstItrOnEntry is tru e& additional projection attribute is null, then
-     * teh 0th iterator itself will evaluate to Region.Entry Object.
+     * Asif : This function is used to obtain Index data at the time of index creation. Each element
+     * of the List is an Object Array of size 3. The 0th element of Object Array stores the value of
+     * Index Expression. The 1st element of ObjectArray contains the RegionEntry object ( If the
+     * booelan isFirstItrOnEntry is false, then the 0th iterator will give us the Region.Entry
+     * object which can be used to obtain the underlying RegionEntry object. If the boolean is true
+     * & additional projection attribute is not null, then the Region.Entry object can be obtained
+     * by evaluating the additional projection attribute. If the boolean isFirstItrOnEntry is tru e&
+     * additional projection attribute is null, then teh 0th iterator itself will evaluate to
+     * Region.Entry Object.
-     * The 2nd element of Object Array contains the Struct object ( tuple)
-     * created. If the boolean isFirstItrOnEntry is false, then the first
-     * attribute of the Struct object is obtained by evaluating the additional
-     * projection attribute.
+     * The 2nd element of Object Array contains the Struct object ( tuple) created. If the boolean
+     * isFirstItrOnEntry is false, then the first attribute of the Struct object is obtained by
+     * evaluating the additional projection attribute.
-        throws FunctionDomainException, TypeMismatchException,
-        NameResolutionException, QueryInvocationTargetException, IMQException {
+        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+        QueryInvocationTargetException, IMQException {
-            LocalizedStrings.IndexCreationMsg_CANCELED_DUE_TO_LOW_MEMORY
-                .toLocalizedString());
+            LocalizedStrings.IndexCreationMsg_CANCELED_DUE_TO_LOW_MEMORY.toLocalizedString());
-      Object indexKey = this.isFirstItrOnEntry ? this.indexedExpr
-          .evaluate(this.initContext) : modifiedIndexExpr
-          .evaluate(this.initContext);
+      Object indexKey = this.isFirstItrOnEntry ? this.indexedExpr.evaluate(this.initContext)
+          : modifiedIndexExpr.evaluate(this.initContext);
-        temp = (LocalRegion.NonTXEntry) additionalProj
-            .evaluate(this.initContext);
+        temp = (LocalRegion.NonTXEntry) additionalProj.evaluate(this.initContext);
-        temp = (LocalRegion.NonTXEntry) (((RuntimeIterator) currentRuntimeIters
-            .get(0)).evaluate(this.initContext));
+        temp = (LocalRegion.NonTXEntry) (((RuntimeIterator) currentRuntimeIters.get(0))
+            .evaluate(this.initContext));
-     * @param add
-     *          true if adding to index, false if removing
+     * @param add true if adding to index, false if removing
-    private void doNestedIterations(int level, boolean add,
-        ExecutionContext context) throws TypeMismatchException,
-        AmbiguousNameException, FunctionDomainException,
+    private void doNestedIterations(int level, boolean add, ExecutionContext context)
+        throws TypeMismatchException, AmbiguousNameException, FunctionDomainException,
-     * @param add
-     *          true if adding, false if removing from index
+     * @param add true if adding, false if removing from index
-        throws FunctionDomainException, TypeMismatchException,
-        NameResolutionException, QueryInvocationTargetException, IMQException {
+        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+        QueryInvocationTargetException, IMQException {
-      RegionEntry entry = ((DummyQRegion) context.getBindArgument(1))
-          .getEntry();
+      RegionEntry entry = ((DummyQRegion) context.getBindArgument(1)).getEntry();
-    
+
-      type = (len == 1) ? fieldTypes[0] : new StructTypeImpl(
-          this.canonicalIterNames, fieldTypes);
+      type = (len == 1) ? fieldTypes[0] : new StructTypeImpl(this.canonicalIterNames, fieldTypes);
-  void lockedQuery(Object key, int operator, Collection results,
-      CompiledValue iterOps, RuntimeIterator indpndntItr,
-      ExecutionContext context, List projAttrib,
-      SelectResults intermediateResults, boolean isIntersection)
-      throws TypeMismatchException, FunctionDomainException,
-      NameResolutionException, QueryInvocationTargetException {
-    this.lockedQueryPrivate(key, operator, results, iterOps, indpndntItr,
-        context, null, projAttrib, intermediateResults, isIntersection);
+  void lockedQuery(Object key, int operator, Collection results, CompiledValue iterOps,
+      RuntimeIterator indpndntItr, ExecutionContext context, List projAttrib,
+      SelectResults intermediateResults, boolean isIntersection) throws TypeMismatchException,
+      FunctionDomainException, NameResolutionException, QueryInvocationTargetException {
+    this.lockedQueryPrivate(key, operator, results, iterOps, indpndntItr, context, null, projAttrib,
+        intermediateResults, isIntersection);
-  void lockedQuery(Object key, int operator, Collection results,
-      Set keysToRemove, ExecutionContext context) throws TypeMismatchException,
-      FunctionDomainException, NameResolutionException,
-      QueryInvocationTargetException {
-    this.lockedQueryPrivate(key, operator, results, null, null, context,
-        keysToRemove, null, null, true);
+  void lockedQuery(Object key, int operator, Collection results, Set keysToRemove,
+      ExecutionContext context) throws TypeMismatchException, FunctionDomainException,
+      NameResolutionException, QueryInvocationTargetException {
+    this.lockedQueryPrivate(key, operator, results, null, null, context, keysToRemove, null, null,
+        true);
-  void addMapping(Object key, Object value, RegionEntry entry)
-      throws IMQException
-  {
-    //Only called from CompactMapRangeIndex
-    indexStore.addMapping(key, entry);    
+  void addMapping(Object key, Object value, RegionEntry entry) throws IMQException {
+    // Only called from CompactMapRangeIndex
+    indexStore.addMapping(key, entry);
-  void saveMapping(Object key, Object value, RegionEntry entry)
-      throws IMQException {
+  void saveMapping(Object key, Object value, RegionEntry entry) throws IMQException {
-    throw new UnsupportedOperationException(
-        "valuesToEntriesMap should not be accessed directly");
+    throw new UnsupportedOperationException("valuesToEntriesMap should not be accessed directly");
-  
+
-  
+
-    
-    public void setOldKeyValuePair(Object oldKey, RegionEntry entry){
+
+    public void setOldKeyValuePair(Object oldKey, RegionEntry entry) {
-      //We obtain the object currently in vm, we are using this old value
-      //only to detect if in place modifications have occurred
-      //if the object is not in memory, obviously an in place modification could
-      //not have occured
+      // We obtain the object currently in vm, we are using this old value
+      // only to detect if in place modifications have occurred
+      // if the object is not in memory, obviously an in place modification could
+      // not have occured
-    
-    public Object getOldValue(){
+
+    public Object getOldValue() {
-    
-    public Object getOldKey(){
+
+    public Object getOldKey() {

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS12 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS44 INS8 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS43 INS42 INS41 INS42 INS40 DEL66 DEL66 DEL66 DEL66 DEL66
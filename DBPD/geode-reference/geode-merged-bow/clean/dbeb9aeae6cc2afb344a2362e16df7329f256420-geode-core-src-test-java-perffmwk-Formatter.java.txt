Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- *  Contains common code used to format reports.
+ * Contains common code used to format reports.
-  /** The width (in characters) of the report output.
+  /**
+   * The width (in characters) of the report output.
-   * @see #center(String, PrintWriter) */
+   * @see #center(String, PrintWriter)
+   */
-    "================================================================================";
+      "================================================================================";
-    "--------------------------------------------------------------------------------";
+      "--------------------------------------------------------------------------------";
-   *  Centers the given string on the <code>PrintWriter</code>
+   * Centers the given string on the <code>PrintWriter</code>
+
-   *  Returns a collection of decimals based on the given collection but with
-   *  the doubles formatted according to the pattern.  String values are ignored.
+   * Returns a collection of decimals based on the given collection but with the doubles formatted
+   * according to the pattern. String values are ignored.
-  public static Vector formatDecimal( Collection c, String pattern ) {
-    DecimalFormat f = new DecimalFormat( pattern );
+  public static Vector formatDecimal(Collection c, String pattern) {
+    DecimalFormat f = new DecimalFormat(pattern);
-    for ( Iterator i = c.iterator(); i.hasNext(); ) {
+    for (Iterator i = c.iterator(); i.hasNext();) {
-      if ( o instanceof Double ) 
-        v.add( f.format( o ) );
+      if (o instanceof Double)
+        v.add(f.format(o));
-        v.add( o );
+        v.add(o);
+
-   *  Returns a collection of doubles based on the given collection but with
-   *  the doubles formatted according to the pattern and all entries, both
-   *  doubles and string, padded on the left to the length of the longest one.
+   * Returns a collection of doubles based on the given collection but with the doubles formatted
+   * according to the pattern and all entries, both doubles and string, padded on the left to the
+   * length of the longest one.
-  public static Vector padLeft( Collection doubles, String pattern ) {
-    return padLeft( formatDecimal( doubles, pattern ) );
+  public static Vector padLeft(Collection doubles, String pattern) {
+    return padLeft(formatDecimal(doubles, pattern));
+
-   *  Returns a collection of doubles based on the given collection but with
-   *  the doubles formatted according to the pattern and all entries, both
-   *  doubles and string, padded on the right to the length of the longest one.
+   * Returns a collection of doubles based on the given collection but with the doubles formatted
+   * according to the pattern and all entries, both doubles and string, padded on the right to the
+   * length of the longest one.
-  public static Vector padRight( Collection doubles, String pattern ) {
-    return padRight( formatDecimal( doubles, pattern ) );
+  public static Vector padRight(Collection doubles, String pattern) {
+    return padRight(formatDecimal(doubles, pattern));
+
-   *  Returns a collection of strings based on the given collection but with
-   *  all strings padded on the left to the length of the longest one.
+   * Returns a collection of strings based on the given collection but with all strings padded on
+   * the left to the length of the longest one.
-  public static Vector padLeft( Collection strings ) {
+  public static Vector padLeft(Collection strings) {
-    int length = maxLength( strings );
-    for ( Iterator i = strings.iterator(); i.hasNext(); ) {
+    int length = maxLength(strings);
+    for (Iterator i = strings.iterator(); i.hasNext();) {
-      v.add( padLeft( string, length ) );
+      v.add(padLeft(string, length));
+
-   *  Returns a collection of strings based on the given collection but with
-   *  all strings padded on the right to the length of the longest one.
+   * Returns a collection of strings based on the given collection but with all strings padded on
+   * the right to the length of the longest one.
-  public static Vector padRight( Collection strings ) {
+  public static Vector padRight(Collection strings) {
-    int length = maxLength( strings );
-    for ( Iterator i = strings.iterator(); i.hasNext(); ) {
+    int length = maxLength(strings);
+    for (Iterator i = strings.iterator(); i.hasNext();) {
-      v.add( padRight( string, length ) );
+      v.add(padRight(string, length));
+
-   *  Returns a string that is the given string padded on the left to the given length.
+   * Returns a string that is the given string padded on the left to the given length.
-  public static String padLeft( String s, int length ) {
-    if ( s.length() > length ) {
-      throw new RuntimeException( s + " cannot be padded to length " + length + ", it is too long" );
+  public static String padLeft(String s, int length) {
+    if (s.length() > length) {
+      throw new RuntimeException(s + " cannot be padded to length " + length + ", it is too long");
-    for ( int i = 0; i < length - s.length(); i++ ) {
+    for (int i = 0; i < length - s.length(); i++) {
+
-   *  Returns a string that is the given string padded on the right to the given length.
+   * Returns a string that is the given string padded on the right to the given length.
-  public static String padRight( String s, int length ) {
-    if ( s.length() > length ) {
-      throw new RuntimeException( s + " cannot be padded to length " + length + ", it is too long" );
+  public static String padRight(String s, int length) {
+    if (s.length() > length) {
+      throw new RuntimeException(s + " cannot be padded to length " + length + ", it is too long");
-    String t = new String( s );
-    for ( int i = 0; i < length - s.length(); i++ ) {
+    String t = new String(s);
+    for (int i = 0; i < length - s.length(); i++) {
+
-   *  Returns the length of the longest string in the collection (0 if the
-   *  collection is empty).
+   * Returns the length of the longest string in the collection (0 if the collection is empty).
-  public static int maxLength( Collection strings ) {
+  public static int maxLength(Collection strings) {
-    for ( Iterator i = strings.iterator(); i.hasNext(); ) {
+    for (Iterator i = strings.iterator(); i.hasNext();) {
-      max = Math.max( max, string.length() );
+      max = Math.max(max, string.length());

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66
Merge branch 'release/1.5.0'

-import java.util.*;
-import java.util.concurrent.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+import java.util.SplittableRandom;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import org.apache.geode.cache.CacheClosedException;
-import org.apache.geode.cache.client.*;
-import org.apache.geode.cache.client.internal.*;
+import org.apache.geode.cache.client.AllConnectionsInUseException;
+import org.apache.geode.cache.client.NoAvailableServersException;
+import org.apache.geode.cache.client.ServerConnectivityException;
+import org.apache.geode.cache.client.ServerOperationException;
+import org.apache.geode.cache.client.ServerRefusedConnectionException;
+import org.apache.geode.cache.client.internal.Connection;
+import org.apache.geode.cache.client.internal.ConnectionFactory;
+import org.apache.geode.cache.client.internal.Endpoint;
+import org.apache.geode.cache.client.internal.EndpointManager;
+import org.apache.geode.cache.client.internal.PoolImpl;
+import org.apache.geode.cache.client.internal.QueueConnectionImpl;
-import org.apache.geode.distributed.internal.DistributionConfig;
-  static long AQUIRE_TIMEOUT = Long
-      .getLong(DistributionConfig.GEMFIRE_PREFIX + "ConnectionManager.AQUIRE_TIMEOUT", 10 * 1000)
-      .longValue();
-  protected final long prefillRetry; // ms // make this an int
-  // private final long pingInterval; // ms // make this an int
+  protected final long prefillRetry; // ms
+   * Adds an arbitrary variance to a positive temporal interval. Where possible, 10% of the interval
+   * is added or subtracted from the interval. Otherwise, 1 is added or subtracted from the
+   * interval. For all positive intervals, the returned value will <bold>not</bold> equal the
+   * supplied interval.
+   *
+   * @param interval Positive temporal interval.
+   * @return Adjusted interval including the variance for positive intervals; the unmodified
+   *         interval for non-positive intervals.
+   */
+  static int addVarianceToInterval(int interval) {
+    if (1 <= interval) {
+      final SplittableRandom random = new SplittableRandom();
+      final int variance = (interval < 10) ? 1 : (1 + random.nextInt((interval / 10) - 1));
+      final int sign = random.nextBoolean() ? 1 : -1;
+      return interval + (sign * variance);
+    }
+    return interval;
+  }
+
+  /**
-    this.lifetimeTimeout = lifetimeTimeout;
-    this.lifetimeTimeoutNanos = lifetimeTimeout * NANOS_PER_MS;
-    if (lifetimeTimeout != -1) {
-      if (idleTimeout > lifetimeTimeout || idleTimeout == -1) {
+    this.lifetimeTimeout = addVarianceToInterval(lifetimeTimeout);
+    this.lifetimeTimeoutNanos = this.lifetimeTimeout * NANOS_PER_MS;
+    if (this.lifetimeTimeout != -1) {
+      if (idleTimeout > this.lifetimeTimeout || idleTimeout == -1) {
-        idleTimeout = lifetimeTimeout;
+        idleTimeout = this.lifetimeTimeout;
-    // this.pingInterval = pingInterval;
-        // logger.info("DEBUG: borrowConnection conCount(+1)->" + connectionCount);
-        // getPoolStats().incConCount(1);
-          // getPoolStats().incConCount(-1);
-          // logger.info("DEBUG: borrowConnection conCount(-1)->" + connectionCount);
-  // public Connection borrowConnection(ServerLocation server, long acquireTimeout)
-  // throws AllConnectionsInUseException, NoAvailableServersException {
-  // return borrowConnection(server, acquireTimeout, false);
-  // }
-
-  // /**
-  // * Used to tell a caller of borrowConnection that it did not find an existing connnection.
-  // */
-  // public static final Connection NO_EXISTING_CONNECTION = new ConnectionImpl(null, null);
-
-      // logger.info("DEBUG: borrowConnection conCount(+1)->" + connectionCount);
-      // getPoolStats().incConCount(1);
-          // getPoolStats().incConCount(-1);
-          // logger.info("DEBUG: borrowConnection conCount(-1)->" + connectionCount);
-            // logger.info("DEBUG: exchangeConnection removeCon(" + oldPC +")");
-              // getPoolStats().incConCount(-1);
-              // logger.info("DEBUG: exchangeConnection conCount(-1)->" + connectionCount + "
-              // oldPC=" + oldPC);
-        // logger.info("DEBUG: exchangeConnection newConnection=" + newConnection);
-            // getPoolStats().incConCount(-1);
-            // logger.info("DEBUG: exchangeConnection conCount(-1)->" + connectionCount);
-    // logger.info("DEBUG: exchangeConnection internalDestroy(" + oldPC +")");
-        // getPoolStats().incConCount(-1);
-        // logger.info("DEBUG: destroyConnection conCount(-1)->" + connectionCount);
-          // this might not be true; they make have just had an exception
-          // itr.remove(); // someone else is destroying it
-      // getPoolStats().incConCount(-badConnections.size());
-      // logger.info("DEBUG: invalidateServer conCount(" + (-badConnections.size()) + ")->" +
-      // connectionCount);
-      // TODO (ashetkar) This for loop may well be outside the lock. But this
-      // change was tested thoroughly for #42185 and also it may not impact perf
-      // because this method gets called only when a server goes down.
-            // logger.info("DEBUG: returnConnection conCount(-1)->" + connectionCount);
-    // do this early as it might help lifetimeProcessor shutdown
-    // closeReplacementConnection();
-    // one more time in case of race with lifetimeProcessor
-    // closeReplacementConnection();
-    // closeReplacementConnection();
-        // getPoolStats().incConCount(1);
-        // logger.info("DEBUG: prefillConnection conCount(+1)->" + connectionCount);
-            // getPoolStats().incConCount(-1);
-            // logger.info("DEBUG: prefillConnection conCount(-1)->" + connectionCount);
-        // logger.info("DEBUG: lifetimeTask=" + this);
-        // NOTREACHED
-        throw e; // for safety
+        throw e;
-  // private final AR/*<ReplacementConnection>*/ replacement = CFactory.createAR();
-
-  // private void closeReplacementConnection() {
-  // ReplacementConnection rc = (ReplacementConnection)this.replacement.getAndSet(null);
-  // if (rc != null) {
-  // rc.getConnection().destroy();
-  // }
-  // }
-
-            // // target was destroyed; we have already removed it from
-            // // allConnectionsMap but didn't dec the stat
-            // getPoolStats().incPoolConnections(-1);
-            // logger.info("DEBUG: offerReplacementConnection incPoolConnections(-1)->" +
-            // getPoolStats().getPoolConnections());
-    // boolean replacementConsumed = false;
-          // logger.fine("DEBUG: creating replacement connection to " + sl);
-          // logger.fine("DEBUG: created replacement connection: " + con);
-    private final LinkedList/* <PooledConnection> */ allConnections =
-        new LinkedList/* <PooledConnection> */(); // in the order they were created
+    private List/* <PooledConnection> */ allConnections = new LinkedList/* <PooledConnection> */(); // in
+                                                                                                    // the
+                                                                                                    // order
+                                                                                                    // they
+                                                                                                    // were
+                                                                                                    // created
+    volatile boolean closing;
-      addToEndpointMap(connection);
-
-      // we want the smallest birthDate (e.g. oldest cnx) at the front of the list
-      getPoolStats().incPoolConnections(1);
-      // logger.info("DEBUG: addConnection incPoolConnections(1)->" +
-      // getPoolStats().getPoolConnections() + " con="+connection,
-      // new RuntimeException("STACK"));
-      this.allConnections.addLast(connection);
-      if (isIdleExpirePossible()) {
-        startBackgroundExpiration();
+      if (this.closing) {
+        throw new CacheClosedException("This pool is closing");
-      if (lifetimeTimeout != -1 && !haveLifetimeExpireConnectionsTask) {
-        if (checkForReschedule(true)) {
-          // something has already expired so start processing with no delay
-          // logger.info("DEBUG: rescheduling lifetime expire to be now");
-          startBackgroundLifetimeExpiration(0);
-        } else {
-          // either no possible lifetime expires or we scheduled one
+      synchronized (this) {
+
+        getPoolStats().incPoolConnections(1);
+
+        // we want the smallest birthDate (e.g. oldest cnx) at the front of the list
+        this.allConnections.add(connection);
+
+        addToEndpointMap(connection);
+
+        if (isIdleExpirePossible()) {
+          startBackgroundExpiration();
+        }
+        if (lifetimeTimeout != -1 && !haveLifetimeExpireConnectionsTask) {
+          if (checkForReschedule(true)) {
+            // something has already expired so start processing with no delay
+            startBackgroundLifetimeExpiration(0);
+          } else {
+            // either no possible lifetime expires or we scheduled one
+          }
+      if (this.closing) {
+        throw new CacheClosedException("This pool is closing");
+      }
-        this.allConnections.addLast(con);
+        this.allConnections.add(con);
-          // logger.info("DEBUG: removedEndpoint incPoolConnections(" + (-count) + ")->" +
-          // getPoolStats().getPoolConnections() + " cons.size=" + endpointConnections.size() + "
-          // cons=" + endpointConnections);
-      // @todo darrel: allConnections.remove could be optimized by making
-      // allConnections a linkedHashSet
-        // logger.info("DEBUG: removedConnection incPoolConnections(-1)->" +
-        // getPoolStats().getPoolConnections() + " con="+connection);
-    public synchronized void close(boolean keepAlive) {
-      map.clear();
+    public void close(boolean keepAlive) {
+      List<PooledConnection> connections;
-      while (!this.allConnections.isEmpty()) {
-        PooledConnection pc = (PooledConnection) this.allConnections.removeFirst();
+
+      synchronized (this) {
+        if (closing) {
+          return;
+        }
+        closing = true;
+        map.clear();
+        connections = allConnections;
+        allConnections = new ClosedPoolConnectionList();
+      }
+
+      for (PooledConnection pc : connections) {
-        // logger.info("DEBUG: close incPoolConnections(" + (-count) + ")->" +
-        // getPoolStats().getPoolConnections());
+      closing = true;
-        PooledConnection pc = (PooledConnection) this.allConnections.removeFirst();
+        PooledConnection pc = (PooledConnection) this.allConnections.remove(0);
-        // boolean idlePossible = isIdleExpirePossible();
-            /*
-             * if (idlePossible && pc.hasIdleExpired(now, idleTimeoutNanos)) { // this con has
-             * already idle expired so ignore it continue; } else
-             */ {
+            {
-                // logger.info("DEBUG: 2 rescheduling lifetime expire to be in: "
-                // + life + " nanos");
-     * See if any of the expired connections (that have not idle expired) are already connected to
-     * this sl and have not idle expired. If so then just update them in-place to simulate a
-     * replace.
-     *
-     * @param sl the location of the server we should see if we are connected to
-     * @return true if we were able to extend an existing connection's lifetime or if we have no
-     *         connection's whose lifetime has expired. false if we need to create a replacement
-     *         connection.
-     */
-    public synchronized boolean tryToExtendLifeTime(ServerLocation sl) {
-      // a better approach might be to get the most loaded server
-      // (if they are not balanced) and then scan through and extend the lifetime
-      // of everyone not connected to that server and do a replace on just one
-      // of the guys who has lifetime expired to the most loaded server
-      boolean result = true;
-      if (!this.allConnections.isEmpty()) {
-        final long now = System.nanoTime();
-        for (Iterator it = this.allConnections.iterator(); it.hasNext();) {
-          PooledConnection pc = (PooledConnection) it.next();
-          if (pc.remainingLife(now, lifetimeTimeoutNanos) > 0) {
-            // no more connections whose lifetime could have expired
-            break;
-            // note don't ignore idle guys because they are still connected
-            // } else if (pc.remainingIdle(now, idleTimeoutNanos) <= 0) {
-            // // this con has already idle expired so ignore it
-          } else if (pc.shouldDestroy()) {
-            // this con has already been destroyed so ignore it
-          } else if (sl.equals(pc.getEndpoint().getLocation())) {
-            // we found a guy to whose lifetime we can extend
-            it.remove();
-            // logger.fine("DEBUG: tryToExtendLifeTime extending life of: " + pc);
-            pc.setBirthDate(now);
-            getPoolStats().incLoadConditioningExtensions();
-            this.allConnections.addLast(pc);
-            return true;
-          } else {
-            // the current pc is a candidate for reconnection to another server
-            // so set result to false which will stick unless we find another con
-            // whose life can be extended.
-            result = false;
-          }
-        }
-      }
-      // if (result) {
-      // logger.fine("DEBUG: tryToExtendLifeTime found no one to extend");
-      // }
-      return result;
-    }
-
-    /**
-            // logger.fine("DEBUG: tryToExtendLifeTime extending life of: " + pc);
-            this.allConnections.addLast(pc);
+            this.allConnections.add(pc);
-          // logger.info("DEBUG: scheduling lifetime expire check in: " + delay + " ns");
-          // logger.info("DEBUG: scheduling lifetimeTask=" + task);
-        // logger.info("DEBUG: checkIdleExpiration incPoolConnections(" + (-expireCount) + ")->" +
-        // getPoolStats().getPoolConnections());
-          // getPoolStats().incConCount(-expireCount);
-          // logger.info("DEBUG: checkIdleExpiration conCount(" + (-expireCount) + ")->" +
-          // connectionCount);
-      // logger.info("DEBUG: Looking for connections whose lifetime has expired");
-            // logger.fine("DEBUG: life remaining in " + pc + " is: " + life);
-              // logger.fine("DEBUG: idleTimedOut=" + idleTimedOut
-              // + " destroyed=" + destroyed);
-          // logger.fine("DEBUG: calling createLifetimeReplacementConnection");
-          // logger.fine("DEBUG: createLifetimeReplacementConnection returned " + !done);
-          // logger.fine("DEBUG: reschedule " + firstLife);
-            // logger.info("DEBUG: rescheduling lifetime expire to be in: "
-            // + firstLife + " nanos");
+
+
+  private static class ClosedPoolConnectionList extends ArrayList {
+    @Override
+    public Object set(int index, Object element) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+
+    @Override
+    public boolean add(Object element) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+
+    @Override
+    public void add(int index, Object element) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+
+    @Override
+    public Object remove(int index) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+
+    @Override
+    public boolean addAll(Collection c) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+
+    @Override
+    public boolean addAll(int index, Collection c) {
+      throw new CacheClosedException("This pool has been closed");
+    }
+  }

MOV26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS26 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 INS40 UPD40 INS40 UPD40 UPD40 INS31 INS55 INS29 INS83 INS39 INS42 INS44 INS8 INS23 INS83 INS83 INS42 INS43 INS31 INS31 INS31 INS31 INS31 INS31 INS65 INS65 INS65 INS39 INS42 INS25 INS41 UPD43 INS83 INS39 INS59 INS8 INS42 INS78 INS83 INS43 INS42 INS44 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS78 INS83 INS43 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS8 INS78 INS83 INS39 INS42 INS44 INS44 INS8 INS66 INS66 INS66 INS66 INS42 INS66 INS66 INS66 INS27 INS8 INS42 UPD42 UPD42 MOV42 INS25 INS51 INS25 INS60 INS51 INS70 INS21 INS42 INS42 INS39 INS42 INS43 INS42 INS53 INS42 INS43 INS42 INS53 INS42 INS39 INS42 INS43 INS42 INS53 INS42 INS42 INS39 INS42 INS53 INS42 INS43 INS42 INS53 INS42 INS39 INS42 INS43 INS42 INS53 INS34 INS42 INS60 INS60 INS60 INS41 INS32 INS22 INS22 INS8 INS52 MOV8 MOV21 INS22 INS8 INS74 INS59 INS52 INS8 INS44 INS42 MOV8 INS7 INS42 INS14 INS42 INS14 INS42 INS14 INS14 INS42 INS14 INS42 INS14 INS83 INS43 INS59 INS83 INS39 INS59 INS83 INS39 INS59 INS27 INS42 INS42 INS22 INS52 INS42 INS52 INS42 INS53 INS52 INS42 INS53 INS43 MOV43 INS42 INS25 INS21 MOV21 INS21 INS21 MOV43 INS42 INS42 INS9 INS43 INS45 INS43 INS45 INS43 INS45 INS43 INS45 INS43 INS45 INS43 INS45 INS42 INS42 INS14 INS42 INS16 INS42 INS16 INS42 INS36 INS52 INS42 INS14 INS14 INS42 INS42 INS8 INS7 INS7 INS7 INS42 INS42 INS42 INS42 INS42 INS42 INS43 INS36 INS34 INS36 INS32 INS34 INS38 INS27 INS22 INS43 INS45 UPD42 INS43 INS45 MOV22 UPD42 INS41 INS42 INS9 INS42 INS42 INS42 INS14 INS42 INS27 INS27 INS42 INS42 INS34 INS42 INS42 INS52 INS42 INS22 INS42 INS42 MOV52 INS43 MOV43 INS42 INS34 INS34 INS32 INS52 INS42 INS42 UPD42 INS34 INS42 INS42 UPD27 MOV27 INS36 UPD34 INS27 INS42 MOV34 UPD42 DEL83 DEL39 DEL42 DEL42 DEL42 DEL40 DEL45 DEL27 DEL32 DEL42 DEL32 DEL59 DEL23 DEL42 DEL42 DEL42 DEL42 DEL42 DEL83 DEL83 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL32 DEL38 DEL61 DEL66 DEL66 DEL66 DEL65 DEL42 DEL66 DEL65 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL9 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL32 DEL38 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL34 DEL27 DEL10 DEL8 DEL42 DEL42 DEL32 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL32 DEL42 DEL42 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL32 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL21 DEL9 DEL41 DEL8 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL25 DEL25 DEL8 DEL24 DEL8 DEL25 DEL42 DEL41 DEL8 DEL31
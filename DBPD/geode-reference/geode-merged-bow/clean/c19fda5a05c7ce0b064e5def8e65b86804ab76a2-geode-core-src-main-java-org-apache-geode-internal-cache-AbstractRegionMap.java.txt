GEODE-5135: Refactor AbstractRegionMap dependencies (#3235)

`BaseRegionMap` will be an abstract base class for `AbstractRegionMap`
and `ProxyRegionMap`. Will move common functionality into this class.
Aims to remove dependency between `AbstractRegionMap` and `ProxyRegionMap`

Move ARMLockTestHook to RegionMap to remove circular dependency
while keeping the impact as small as possible.

Move `forceInvalidateEvent`, `shouldInvokeCallbacks` and
`switchEventOwnerAndOriginRemote` to `BaseRegionMap` to reduce
dependency between `ProxyRegionMap` and `AbstractRegionMap`

Move `createCallbackEvent` from `AbstractRegionMap` to `EntryEventImpl`
This reduces dependecy between `AbstractRegionMap` and `ProxyRegionMap`

Add `EntryEventFactory` class and move `createCallbackEvent`.
Also cleanup `BaseRegionMap` prefix refactoring artifact

Change `EntryEventFactory` to `EntryEventFactoryImpl` that
implements new `EntryEventFactory` interface to make it
availiable for Mockito testing. This requires `createCallbackEvent`
to be a non-static method.

Add private EntryEventFactory field in classes where it is used.
Reduce number of object instantiations.

Co-Authored-By: Patric Lantz <herrlantz@users.noreply.github.com>
Co-Authored-By: Sayyed Ali Kiaian Mousavy <sakm2@kth.se>
Co-Authored-By: Nicole Jagelid <nicolej@kth.se>
Co-Authored-By: ddahlgren95 <46962337+ddahlgren95@users.noreply.github.com>
-import org.apache.geode.cache.CacheEvent;
-import org.apache.geode.distributed.DistributedMember;
-import org.apache.geode.distributed.internal.DistributionConfig;
-import org.apache.geode.internal.cache.FilterRoutingInfo.FilterInfo;
-import org.apache.geode.internal.cache.eviction.EvictableEntry;
-import org.apache.geode.internal.cache.eviction.EvictionController;
-public abstract class AbstractRegionMap
-    implements RegionMap, FocusedRegionMap, CacheModificationLock {
+public abstract class AbstractRegionMap extends BaseRegionMap
+    implements FocusedRegionMap, CacheModificationLock {
+  private final EntryEventFactory entryEventFactory = new EntryEventFactoryImpl();
-
-  @Override
-  public void lruUpdateCallback() {
-    // By default do nothing; LRU maps needs to override this method
-  }
-
-  @Override
-  public boolean disableLruUpdateCallback() {
-    // By default do nothing; LRU maps needs to override this method
-    return false;
-  }
-
-  @Override
-  public void enableLruUpdateCallback() {
-    // By default do nothing; LRU maps needs to override this method
-  }
-
-  @Override
-  public void resetThreadLocals() {
-    // By default do nothing; LRU maps needs to override this method
-  }
-
-  @Override
-  public boolean lruLimitExceeded(DiskRegionView diskRegionView) {
-    return false;
-  }
-
-  @Override
-  public void lruCloseStats() {
-    // do nothing by default
-  }
-
-  @Override
-  public void lruEntryFaultIn(EvictableEntry entry) {
-    // do nothing by default
-  }
-
-              final EntryEventImpl callbackEvent = createCallbackEvent(owner, op, key, null, txId,
-                  txEvent, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext,
-                  txEntryState, versionTag, tailKey);
+              final EntryEventImpl callbackEvent = entryEventFactory
+                  .createCallbackEvent(owner, op, key, null, txId,
+                      txEvent, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext,
+                      txEntryState, versionTag, tailKey);
-                    callbackEvent = createCallbackEvent(owner, op, key, null, txId, txEvent,
-                        eventId, aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState,
-                        versionTag, tailKey);
+                    callbackEvent = entryEventFactory
+                        .createCallbackEvent(owner, op, key, null, txId, txEvent,
+                            eventId, aCallbackArgument, filterRoutingInfo, bridgeContext,
+                            txEntryState,
+                            versionTag, tailKey);
-              callbackEvent = createCallbackEvent(owner, op, key, null, txId, txEvent, eventId,
-                  aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState, versionTag,
-                  tailKey);
+              callbackEvent = entryEventFactory
+                  .createCallbackEvent(owner, op, key, null, txId, txEvent, eventId,
+                      aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState, versionTag,
+                      tailKey);
-            createCallbackEvent(owner, op, key, null, txId, txEvent, eventId, aCallbackArgument,
-                filterRoutingInfo, bridgeContext, txEntryState, versionTag, tailKey);
+            entryEventFactory
+                .createCallbackEvent(owner, op, key, null, txId, txEvent, eventId,
+                    aCallbackArgument,
+                    filterRoutingInfo, bridgeContext, txEntryState, versionTag, tailKey);
-  /**
-   * If true then invalidates that throw EntryNotFoundException or that are already invalid will
-   * first call afterInvalidate on CacheListeners. The old value on the event passed to
-   * afterInvalidate will be null. If the region is not initialized then callbacks will not be done.
-   * This property only applies to non-transactional invalidates. Transactional invalidates ignore
-   * this property. Note that empty "proxy" regions on a client will not be sent invalidates from
-   * the server unless they also set the proxy InterestPolicy to ALL. If the invalidate is not sent
-   * then this property will not cause a listener on that client to be notified of the invalidate. A
-   * non-empty "caching-proxy" will receive invalidates from the server.
-   */
-  @MutableForTesting
-  public static boolean FORCE_INVALIDATE_EVENT =
-      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "FORCE_INVALIDATE_EVENT");
-
-  /**
-   * If the FORCE_INVALIDATE_EVENT flag is true then invoke callbacks on the given event.
-   */
-  static void forceInvalidateEvent(EntryEventImpl event, LocalRegion owner) {
-    if (FORCE_INVALIDATE_EVENT) {
-      event.invokeCallbacks(owner, false, false);
-    }
-  }
-
-                  callbackEvent = createCallbackEvent(owner,
+                  callbackEvent = entryEventFactory.createCallbackEvent(owner,
-              callbackEvent = createCallbackEvent(owner,
+              callbackEvent = entryEventFactory.createCallbackEvent(owner,
-              callbackEvent = createCallbackEvent(owner,
+              callbackEvent = entryEventFactory.createCallbackEvent(owner,
-          callbackEvent = createCallbackEvent(owner,
+          callbackEvent = entryEventFactory.createCallbackEvent(owner,
-   * Switch the event's region from BucketRegion to owning PR and set originRemote to the given
-   * value
-   */
-  static EntryEventImpl switchEventOwnerAndOriginRemote(EntryEventImpl event,
-      boolean originRemote) {
-    assert event != null;
-    if (event.getRegion().isUsedForPartitionedRegionBucket()) {
-      LocalRegion pr = event.getRegion().getPartitionedRegion();
-      event.setRegion(pr);
-    }
-    event.setOriginRemote(originRemote);
-    return event;
-  }
-
-  /**
-  static boolean shouldInvokeCallbacks(final LocalRegion owner, final boolean isInitialized) {
-    LocalRegion lr = owner;
-    boolean isPartitioned = lr.isUsedForPartitionedRegionBucket();
-
-    if (isPartitioned) {
-      /*
-       * if(!((BucketRegion)lr).getBucketAdvisor().isPrimary()) {
-       * if(!BucketRegion.FORCE_LOCAL_LISTENERS_INVOCATION) { return false; } }
-       */
-      lr = owner.getPartitionedRegion();
-    }
-    return (isPartitioned || isInitialized) && (lr.shouldDispatchListenerEvent()
-        || lr.shouldNotifyBridgeClients() || lr.getConcurrencyChecksEnabled());
-  }
-
-    return createCallbackEvent(re, op, key, newValue, txId, txEvent, eventId, aCallbackArgument,
-        filterRoutingInfo, bridgeContext, txEntryState, versionTag, tailKey);
-  }
-
-  /** create a callback event for applying a transactional change to the local cache */
-  @Retained
-  public static EntryEventImpl createCallbackEvent(final InternalRegion internalRegion,
-      Operation op, Object key, Object newValue, TransactionId txId, TXRmtEvent txEvent,
-      EventID eventId, Object aCallbackArgument, FilterRoutingInfo filterRoutingInfo,
-      ClientProxyMembershipID bridgeContext, TXEntryState txEntryState, VersionTag versionTag,
-      long tailKey) {
-    DistributedMember originator = null;
-    // txId should not be null even on localOrigin
-    Assert.assertTrue(txId != null);
-    originator = txId.getMemberId();
-
-    InternalRegion eventRegion = internalRegion;
-    if (eventRegion.isUsedForPartitionedRegionBucket()) {
-      eventRegion = internalRegion.getPartitionedRegion();
-    }
-
-    @Retained
-    EntryEventImpl retVal = EntryEventImpl.create(internalRegion, op, key, newValue,
-        aCallbackArgument, txEntryState == null, originator);
-    boolean returnedRetVal = false;
-    try {
-
-
-      if (bridgeContext != null) {
-        retVal.setContext(bridgeContext);
-      }
-
-      if (eventRegion.generateEventID()) {
-        retVal.setEventId(eventId);
-      }
-
-      if (versionTag != null) {
-        retVal.setVersionTag(versionTag);
-      }
-
-      retVal.setTailKey(tailKey);
-
-      FilterInfo localRouting = null;
-      boolean computeFilterInfo = false;
-      if (filterRoutingInfo == null) {
-        computeFilterInfo = true;
-      } else {
-        localRouting = filterRoutingInfo.getLocalFilterInfo();
-        if (localRouting != null) {
-          // routing was computed in this VM but may need to perform local interest processing
-          computeFilterInfo = !filterRoutingInfo.hasLocalInterestBeenComputed();
-        } else {
-          // routing was computed elsewhere and is in the "remote" routing table
-          localRouting = filterRoutingInfo.getFilterInfo(internalRegion.getMyId());
-        }
-        if (localRouting != null) {
-          if (!computeFilterInfo) {
-            retVal.setLocalFilterInfo(localRouting);
-          }
-        } else {
-          computeFilterInfo = true;
-        }
-      }
-      if (logger.isTraceEnabled()) {
-        logger.trace("createCBEvent filterRouting={} computeFilterInfo={} local routing={}",
-            filterRoutingInfo, computeFilterInfo, localRouting);
-      }
-
-      if (internalRegion.isUsedForPartitionedRegionBucket()) {
-        BucketRegion bucket = (BucketRegion) internalRegion;
-        if (BucketRegion.FORCE_LOCAL_LISTENERS_INVOCATION
-            || bucket.getBucketAdvisor().isPrimary()) {
-          retVal.setInvokePRCallbacks(true);
-        } else {
-          retVal.setInvokePRCallbacks(false);
-        }
-
-        if (computeFilterInfo) {
-          if (bucket.getBucketAdvisor().isPrimary()) {
-            if (logger.isTraceEnabled()) {
-              logger.trace("createCBEvent computing routing for primary bucket");
-            }
-            FilterProfile fp =
-                ((BucketRegion) internalRegion).getPartitionedRegion().getFilterProfile();
-            if (fp != null) {
-              FilterRoutingInfo fri = fp.getFilterRoutingInfoPart2(filterRoutingInfo, retVal);
-              if (fri != null) {
-                retVal.setLocalFilterInfo(fri.getLocalFilterInfo());
-              }
-            }
-          }
-        }
-      } else if (computeFilterInfo) { // not a bucket
-        if (logger.isTraceEnabled()) {
-          logger.trace("createCBEvent computing routing for non-bucket");
-        }
-        FilterProfile fp = internalRegion.getFilterProfile();
-        if (fp != null) {
-          retVal.setLocalFilterInfo(fp.getLocalFilterRouting(retVal));
-        }
-      }
-      retVal.setTransactionId(txId);
-      returnedRetVal = true;
-      return retVal;
-    } finally {
-      if (!returnedRetVal) {
-        retVal.release();
-      }
-    }
+    return entryEventFactory
+        .createCallbackEvent(re, op, key, newValue, txId, txEvent, eventId, aCallbackArgument,
+            filterRoutingInfo, bridgeContext, txEntryState, versionTag, tailKey);
-  public long getEvictions() {
-    return 0;
-  }
-
-  @Override
-  public void incRecentlyUsed() {
-    // nothing by default
-  }
-
-  @Override
-  public EvictionController getEvictionController() {
-    return null;
-  }
-
-  @Override
-  @Override
-  public boolean beginChangeValueForm(EvictableEntry le,
-      CachedDeserializable vmCachedDeserializable, Object v) {
-    return false;
-  }
-
-  @Override
-  public void finishChangeValueForm() {}
-
-  @Override
-  public int centralizedLruUpdateCallback() {
-    return 0;
-  }
-
-  @Override
-  public void updateEvictionCounter() {}
-
-  public interface ARMLockTestHook {
-    void beforeBulkLock(InternalRegion region);
-
-    void afterBulkLock(InternalRegion region);
-
-    void beforeBulkRelease(InternalRegion region);
-
-    void afterBulkRelease(InternalRegion region);
-
-    void beforeLock(InternalRegion region, CacheEvent event);
-
-    void afterLock(InternalRegion region, CacheEvent event);
-
-    void beforeRelease(InternalRegion region, CacheEvent event);
-
-    void afterRelease(InternalRegion region, CacheEvent event);
-
-    void beforeStateFlushWait();
-  }
-

UPD43 INS23 UPD42 INS83 INS83 INS43 INS59 UPD42 MOV42 INS42 INS14 INS43 UPD42 MOV42 INS42 INS42 INS42 MOV16 INS42 INS42 INS42 MOV16 INS42 INS42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL42 DEL78 DEL83 DEL39 DEL42 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL9 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL9 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL65 DEL29 DEL42 DEL78 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL40 DEL45 DEL27 DEL32 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL42 DEL42 DEL9 DEL9 DEL32 DEL21 DEL8 DEL25 DEL8 DEL31 DEL66 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL33 DEL27 DEL6 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL83 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL27 DEL36 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL27 DEL36 DEL27 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL42 DEL78 DEL83 DEL83 DEL43 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL39 DEL42 DEL44 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL42 DEL42 DEL33 DEL27 DEL32 DEL21 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL43 DEL42 DEL42 DEL59 DEL60 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL78 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL27 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL39 DEL42 DEL9 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL9 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL32 DEL38 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL33 DEL27 DEL42 DEL38 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL32 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL40 DEL42 DEL42 DEL32 DEL42 DEL32 DEL27 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL42 DEL42 DEL9 DEL32 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL36 DEL42 DEL32 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL45 DEL32 DEL21 DEL8 DEL25 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL25 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL9 DEL7 DEL21 DEL42 DEL41 DEL8 DEL42 DEL38 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL54 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL34 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL8 DEL31 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL33 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL9 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL34 DEL41 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL8 DEL31 DEL83 DEL42 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL31 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL31 DEL39 DEL42 DEL31 DEL55
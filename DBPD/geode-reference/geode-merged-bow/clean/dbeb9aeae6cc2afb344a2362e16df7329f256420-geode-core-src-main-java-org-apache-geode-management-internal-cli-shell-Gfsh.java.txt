Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileReader;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.PrintStream;
-import java.net.URL;
-import java.text.MessageFormat;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Scanner;
-import java.util.Set;
-import java.util.TreeMap;
-import java.util.logging.Level;
-import java.util.logging.LogManager;
-import java.util.logging.Logger;
-
+import jline.Terminal;
+import jline.console.ConsoleReader;
+import org.apache.geode.internal.util.ArgumentRedactor;
-
-import jline.Terminal;
-import jline.console.ConsoleReader;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.net.URL;
+import java.text.MessageFormat;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Scanner;
+import java.util.Set;
+import java.util.TreeMap;
+import java.util.logging.Level;
+import java.util.logging.LogManager;
+import java.util.logging.Logger;
- * Extends an interactive shell provided by <a
- * href="https://github.com/SpringSource/spring-shell">Spring Shell</a> library.
+ * Extends an interactive shell provided by
+ * <a href="https://github.com/SpringSource/spring-shell">Spring Shell</a> library.
- * This class is used to plug-in implementations of the following Spring (Roo)
- * Shell components customized to suite GemFire Command Line Interface (CLI)
- * requirements:<ul>
- * <li> <code>org.springframework.roo.shell.ExecutionStrategy</code>
- * <li> <code>org.springframework.roo.shell.Parser</code>
+ * This class is used to plug-in implementations of the following Spring (Roo) Shell components
+ * customized to suite GemFire Command Line Interface (CLI) requirements:
+ * <ul>
+ * <li><code>org.springframework.roo.shell.ExecutionStrategy</code>
+ * <li><code>org.springframework.roo.shell.Parser</code>
- * Additionally, this class is used to maintain GemFire SHell (gfsh) specific
- * information like: environment TODO
- *
+ * Additionally, this class is used to maintain GemFire SHell (gfsh) specific information like:
+ * environment TODO
+ * 
-  public static final int     DEFAULT_APP_FETCH_SIZE                 = 1000;
-  public static final int     DEFAULT_APP_LAST_EXIT_STATUS           = 0;
-  public static final int     DEFAULT_APP_COLLECTION_LIMIT           = 20;
-  public static final boolean DEFAULT_APP_QUIET_EXECUTION            = false;
-  public static final String  DEFAULT_APP_QUERY_RESULTS_DISPLAY_MODE = "table";
-  public static final String  DEFAULT_APP_RESULT_VIEWER = "basic";
-  public static final String  EXTERNAL_RESULT_VIEWER = "external";
+  public static final int DEFAULT_APP_FETCH_SIZE = 1000;
+  public static final int DEFAULT_APP_LAST_EXIT_STATUS = 0;
+  public static final int DEFAULT_APP_COLLECTION_LIMIT = 20;
+  public static final boolean DEFAULT_APP_QUIET_EXECUTION = false;
+  public static final String DEFAULT_APP_QUERY_RESULTS_DISPLAY_MODE = "table";
+  public static final String DEFAULT_APP_RESULT_VIEWER = "basic";
+  public static final String EXTERNAL_RESULT_VIEWER = "external";
-  public static final int DEFAULT_WIDTH  = 100;
+  public static final int DEFAULT_WIDTH = 100;
-  public static final String ENV_APP_NAME                       = "APP_NAME";
-  public static final String ENV_APP_CONTEXT_PATH               = "APP_CONTEXT_PATH";
-  public static final String ENV_APP_FETCH_SIZE                 = "APP_FETCH_SIZE";
-  public static final String ENV_APP_LAST_EXIT_STATUS           = "APP_LAST_EXIT_STATUS";
-  public static final String ENV_APP_COLLECTION_LIMIT           = "APP_COLLECTION_LIMIT";
+  public static final String ENV_APP_NAME = "APP_NAME";
+  public static final String ENV_APP_CONTEXT_PATH = "APP_CONTEXT_PATH";
+  public static final String ENV_APP_FETCH_SIZE = "APP_FETCH_SIZE";
+  public static final String ENV_APP_LAST_EXIT_STATUS = "APP_LAST_EXIT_STATUS";
+  public static final String ENV_APP_COLLECTION_LIMIT = "APP_COLLECTION_LIMIT";
-  public static final String ENV_APP_QUIET_EXECUTION            = "APP_QUIET_EXECUTION";
-  public static final String ENV_APP_LOGGING_ENABLED            = "APP_LOGGING_ENABLED";
-  public static final String ENV_APP_LOG_FILE                   = "APP_LOG_FILE";
-  public static final String ENV_APP_PWD                        = "APP_PWD";
-  public static final String ENV_APP_RESULT_VIEWER              = "APP_RESULT_VIEWER";
+  public static final String ENV_APP_QUIET_EXECUTION = "APP_QUIET_EXECUTION";
+  public static final String ENV_APP_LOGGING_ENABLED = "APP_LOGGING_ENABLED";
+  public static final String ENV_APP_LOG_FILE = "APP_LOG_FILE";
+  public static final String ENV_APP_PWD = "APP_PWD";
+  public static final String ENV_APP_RESULT_VIEWER = "APP_RESULT_VIEWER";
-  public static final String ENV_SYS_USER                       = "SYS_USER";
-  public static final String ENV_SYS_USER_HOME                  = "SYS_USER_HOME";
-  public static final String ENV_SYS_HOST_NAME                  = "SYS_HOST_NAME";
-  public static final String ENV_SYS_CLASSPATH                  = "SYS_CLASSPATH";
-  public static final String ENV_SYS_JAVA_VERSION               = "SYS_JAVA_VERSION";
-  public static final String ENV_SYS_OS                         = "SYS_OS";
-  public static final String ENV_SYS_OS_LINE_SEPARATOR          = "SYS_OS_LINE_SEPARATOR";
-  public static final String ENV_SYS_GEMFIRE_DIR                = "SYS_GEMFIRE_DIR";
+  public static final String ENV_SYS_USER = "SYS_USER";
+  public static final String ENV_SYS_USER_HOME = "SYS_USER_HOME";
+  public static final String ENV_SYS_HOST_NAME = "SYS_HOST_NAME";
+  public static final String ENV_SYS_CLASSPATH = "SYS_CLASSPATH";
+  public static final String ENV_SYS_JAVA_VERSION = "SYS_JAVA_VERSION";
+  public static final String ENV_SYS_OS = "SYS_OS";
+  public static final String ENV_SYS_OS_LINE_SEPARATOR = "SYS_OS_LINE_SEPARATOR";
+  public static final String ENV_SYS_GEODE_HOME_DIR = "SYS_GEODE_HOME_DIR";
-  public static final String SSL_KEYSTORE                       = "javax.net.ssl.keyStore";
-  public static final String SSL_KEYSTORE_PASSWORD   = "javax.net.ssl.keyStorePassword";
-  public static final String SSL_TRUSTSTORE          = "javax.net.ssl.trustStore";
+  public static final String SSL_KEYSTORE = "javax.net.ssl.keyStore";
+  public static final String SSL_KEYSTORE_PASSWORD = "javax.net.ssl.keyStorePassword";
+  public static final String SSL_TRUSTSTORE = "javax.net.ssl.trustStore";
-  public static final String SSL_ENABLED_CIPHERS     = "javax.rmi.ssl.client.enabledCipherSuites";
-  public static final String SSL_ENABLED_PROTOCOLS   = "javax.rmi.ssl.client.enabledProtocols";
+  public static final String SSL_ENABLED_CIPHERS = "javax.rmi.ssl.client.enabledCipherSuites";
+  public static final String SSL_ENABLED_PROTOCOLS = "javax.rmi.ssl.client.enabledProtocols";
-//  private static final String ANIMATION_SLOT = "A"; //see 46072
+  // private static final String ANIMATION_SLOT = "A"; //see 46072
-  private static       Gfsh   instance;
+  private static Gfsh instance;
-  private final Map<String, String> env     = new TreeMap<String, String>();
+  private final Map<String, String> env = new TreeMap<String, String>();
-  private final CommandManager    commandManager;
+  private final CommandManager commandManager;
-  private final GfshParser        parser;
-  private       OperationInvoker  operationInvoker;
-  private       int               lastExecutionStatus;
-  private       Thread            runner;
-  private       boolean           debugON;
-  private final LogWrapper        gfshFileLogger;
-  private final GfshConfig        gfshConfig;
-  private final GfshHistory       gfshHistory;
-  private final ANSIHandler       ansiHandler;
-  private       Terminal          terminal;
-  private final boolean           isHeadlessMode;
-  private       boolean           supressScriptCmdOutput;
-  private       boolean           isScriptRunning;
+  private final GfshParser parser;
+  private OperationInvoker operationInvoker;
+  private int lastExecutionStatus;
+  private Thread runner;
+  private boolean debugON;
+  private final LogWrapper gfshFileLogger;
+  private final GfshConfig gfshConfig;
+  private final GfshHistory gfshHistory;
+  private final ANSIHandler ansiHandler;
+  private Terminal terminal;
+  private final boolean isHeadlessMode;
+  private boolean supressScriptCmdOutput;
+  private boolean isScriptRunning;
-  //This flag is used to restrict column trimming to table only types
+  // This flag is used to restrict column trimming to table only types
-   *
-   * @param args
-   *          arguments to be used to create a GemFire shell instance
+   * 
+   * @param args arguments to be used to create a GemFire shell instance
-   * Create a GemFire shell using the specified arguments. Console for user
-   * inputs is made available if <code>launchShell</code> is set to
-   * <code>true</code>.
-   *
-   * @param launchShell
-   *          whether to make Console available
-   * @param args
-   *          arguments to be used to create a GemFire shell instance or execute
-   *          command
+   * Create a GemFire shell using the specified arguments. Console for user inputs is made available
+   * if <code>launchShell</code> is set to <code>true</code>.
+   * 
+   * @param launchShell whether to make Console available
+   * @param args arguments to be used to create a GemFire shell instance or execute command
-  protected Gfsh(boolean launchShell, String[] args, GfshConfig gfshConfig) throws ClassNotFoundException, IOException {
-    //1. Disable suppressing of duplicate messages
+  protected Gfsh(boolean launchShell, String[] args, GfshConfig gfshConfig)
+      throws ClassNotFoundException, IOException {
+    // 1. Disable suppressing of duplicate messages
-    //2. set & use gfshConfig
+    // 2. set & use gfshConfig
-    this.ansiHandler = ANSIHandler.getInstance(this.gfshConfig.isANSISupported()); //TODO - Abhishek : should take it from ConsoleReader.terminal??
+    this.ansiHandler = ANSIHandler.getInstance(this.gfshConfig.isANSISupported()); // TODO -
+    // Abhishek :
+    // should take it
+    // from
+    // ConsoleReader.terminal??
-    /*3. log system properties & gfsh environment */
+    /* 3. log system properties & gfsh environment */
-    //4. Customized History implementation
+    // 4. Customized History implementation
-    //5. Create CommandManager & load Commands & Converters
+    // 5. Create CommandManager & load Commands & Converters
-    //6. Set System Environment here
+    // 6. Set System Environment here
-    //7. Create Roo/SpringShell framework objects
+    // 7. Create Roo/SpringShell framework objects
-    //8. Set max History file size
+    // 8. Set max History file size
-        "WARNING!!! Not running a Sun JVM.  Could not find the sun.misc.Signal class; Signal handling disabled."));
-      signalHandler = (CliUtil.isGfshVM() ? new GfshSignalHandler() : new AbstractSignalNotificationHandler() { });
-    }
-    catch (SunAPINotFoundException e) {
-      signalHandler = new AbstractSignalNotificationHandler() { };
+          "WARNING!!! Not running a Sun JVM.  Could not find the sun.misc.Signal class; Signal handling disabled."));
+      signalHandler = (CliUtil.isGfshVM() ? new GfshSignalHandler()
+          : new AbstractSignalNotificationHandler() {});
+    } catch (SunAPINotFoundException e) {
+      signalHandler = new AbstractSignalNotificationHandler() {};
-    env.put(ENV_SYS_USER,              System.getProperty("user.name"));
-    env.put(ENV_SYS_USER_HOME,         System.getProperty("user.home"));
-    env.put(ENV_SYS_HOST_NAME,         new HostName().determineHostName());
-    env.put(ENV_SYS_CLASSPATH,         System.getProperty("java.class.path"));
-    env.put(ENV_SYS_JAVA_VERSION,      System.getProperty("java.version"));
-    env.put(ENV_SYS_OS,                System.getProperty("os.name"));
+    env.put(ENV_SYS_USER, System.getProperty("user.name"));
+    env.put(ENV_SYS_USER_HOME, System.getProperty("user.home"));
+    env.put(ENV_SYS_HOST_NAME, new HostName().determineHostName());
+    env.put(ENV_SYS_CLASSPATH, System.getProperty("java.class.path"));
+    env.put(ENV_SYS_JAVA_VERSION, System.getProperty("java.version"));
+    env.put(ENV_SYS_OS, System.getProperty("os.name"));
-    env.put(ENV_SYS_GEMFIRE_DIR,       System.getenv("GEMFIRE"));
+    env.put(ENV_SYS_GEODE_HOME_DIR, System.getenv("GEODE_HOME"));
-    env.put(ENV_APP_NAME,                       org.apache.geode.management.internal.cli.shell.Gfsh.GFSH_APP_NAME);
+    env.put(ENV_APP_NAME, org.apache.geode.management.internal.cli.shell.Gfsh.GFSH_APP_NAME);
-    env.put(ENV_APP_LOGGING_ENABLED,                String.valueOf(!Level.OFF.equals(this.gfshConfig.getLogLevel())) );
+    env.put(ENV_APP_LOGGING_ENABLED,
+        String.valueOf(!Level.OFF.equals(this.gfshConfig.getLogLevel())));
-    env.put(ENV_APP_LOG_FILE,                   this.gfshConfig.getLogFilePath());
+    env.put(ENV_APP_LOG_FILE, this.gfshConfig.getLogFilePath());
-    env.put(ENV_APP_PWD,                        System.getProperty("user.dir"));
+    env.put(ENV_APP_PWD, System.getProperty("user.dir"));
-    env.put(ENV_APP_FETCH_SIZE,                 String.valueOf(DEFAULT_APP_FETCH_SIZE));
-    env.put(ENV_APP_LAST_EXIT_STATUS,           String.valueOf(DEFAULT_APP_LAST_EXIT_STATUS));
+    env.put(ENV_APP_FETCH_SIZE, String.valueOf(DEFAULT_APP_FETCH_SIZE));
+    env.put(ENV_APP_LAST_EXIT_STATUS, String.valueOf(DEFAULT_APP_LAST_EXIT_STATUS));
-    env.put(ENV_APP_COLLECTION_LIMIT,           String.valueOf(DEFAULT_APP_COLLECTION_LIMIT));
+    env.put(ENV_APP_COLLECTION_LIMIT, String.valueOf(DEFAULT_APP_COLLECTION_LIMIT));
-    env.put(ENV_APP_QUIET_EXECUTION,            String.valueOf(DEFAULT_APP_QUIET_EXECUTION));
-    env.put(ENV_APP_RESULT_VIEWER,            String.valueOf(DEFAULT_APP_RESULT_VIEWER));
+    env.put(ENV_APP_QUIET_EXECUTION, String.valueOf(DEFAULT_APP_QUIET_EXECUTION));
+    env.put(ENV_APP_RESULT_VIEWER, String.valueOf(DEFAULT_APP_RESULT_VIEWER));
-    throws ClassNotFoundException, IOException
-  {
+      throws ClassNotFoundException, IOException {
+  public String readPassword(String textToPrompt) throws IOException {
+    if (isHeadlessMode && isQuietMode())
+      return null;
+
+    return readWithMask(textToPrompt, '*');
+  }
+
+  public String readText(String textToPrompt) throws IOException {
+    if (isHeadlessMode && isQuietMode())
+      return null;
+
+    return interact(textToPrompt);
+
+  }
+
-//    flashMessage("\b"); // see 46072
+    // flashMessage("\b"); // see 46072
-  /* If an init file is provided, as a system property or in the default
-   * location, run it as a command script.
+  /*
+   * If an init file is provided, as a system property or in the default location, run it as a
+   * command script.
-//    return Collections.singleton(ClassPathLoader.getLatest().getResource(resourceName));
+    // return Collections.singleton(ClassPathLoader.getLatest().getResource(resourceName));
-   * Returns the {@link ExecutionStrategy} implementation used by this
-   * implementation of {@link AbstractShell}. {@link Gfsh} uses
-   * {@link GfshExecutionStrategy}.
-   *
+   * Returns the {@link ExecutionStrategy} implementation used by this implementation of
+   * {@link AbstractShell}. {@link Gfsh} uses {@link GfshExecutionStrategy}.
+   * 
-   *
+   * 
-   * Executes the given command string. We have over-ridden the behavior to
-   * extend the original implementation to store the 'last command execution
-   * status'.
-   *
-   * @param line
-   *          command string to be executed
+   * Executes the given command string. We have over-ridden the behavior to extend the original
+   * implementation to store the 'last command execution status'.
+   * 
+   * @param line command string to be executed
-      //expand env property if the string contains $
+      // expand env property if the string contains $
-          Gfsh.println("Post substitution: "+withPropsExpanded);
+          Gfsh.println("Post substitution: " + withPropsExpanded);
-      //TODO: should there be a way to differentiate error in shell & error on
-      //server. May be by exception type.
+      // TODO: should there be a way to differentiate error in shell & error on
+      // server. May be by exception type.
-    sb.append("/______/_/      /______/_/    /_/   ").append(" ").append(this.getVersion()).append(LINE_SEPARATOR);
+    sb.append("/______/_/      /______/_/    /_/   ").append(" ").append(this.getVersion())
+        .append(LINE_SEPARATOR);
-    return ansiHandler.decorateString("Monitor and Manage " + GemFireVersion.getProductName(), ANSIStyle.CYAN);
+    return ansiHandler.decorateString("Monitor and Manage " + GemFireVersion.getProductName(),
+        ANSIStyle.CYAN);
-  //Over-ridden to avoid default behavior which is:
-  //For Iterable: go through all elements & call toString
-  //For others: call toString
+  // Over-ridden to avoid default behavior which is:
+  // For Iterable: go through all elements & call toString
+  // For others: call toString
-        boolean isError = Result.Status.ERROR.equals(commandResult.getStatus());        
+        boolean isError = Result.Status.ERROR.equals(commandResult.getStatus());
-        
+
-        
+
-    boolean flag = EXTERNAL_RESULT_VIEWER.equals(getEnvProperty(Gfsh.ENV_APP_RESULT_VIEWER)) && isUnix();
-    if(result instanceof CommandResult) {
+    boolean flag =
+        EXTERNAL_RESULT_VIEWER.equals(getEnvProperty(Gfsh.ENV_APP_RESULT_VIEWER)) && isUnix();
+    if (result instanceof CommandResult) {
-      return flag && !commandResult.getType().equals("info");      
-    }else
+      return flag && !commandResult.getType().equals("info");
+    } else
-  
-  public static boolean isInfoResult(){
-    if(resultTypeTL.get()==null)
+
+  public static boolean isInfoResult() {
+    if (resultTypeTL.get() == null)
-// causes instability on MacOS See #46072
-//  public void flashMessage(String message) {
-//    if (reader != null) {
-//      flash(Level.FINE, message, ANIMATION_SLOT);
-//    }
-//  }
+  // causes instability on MacOS See #46072
+  // public void flashMessage(String message) {
+  // if (reader != null) {
+  // flash(Level.FINE, message, ANIMATION_SLOT);
+  // }
+  // }
-  ///////////////////// JLineShell Class Methods End  //////////////////////////
+  ///////////////////// JLineShell Class Methods End //////////////////////////
-  public static <T>void println(T toPrint) {
+  public static <T> void println(T toPrint) {
-  public static <T>void print(T toPrint) {
+  public static <T> void print(T toPrint) {
-  public static <T>void printlnErr(T toPrint) {
+  public static <T> void printlnErr(T toPrint) {
-    //APP_LAST_EXIT_STATUS
+    // APP_LAST_EXIT_STATUS
-   *
-   * @param lastExecutionStatus
-   *          last command execution status
+   * 
+   * @param lastExecutionStatus last command execution status
-      this.isScriptRunning = true;  
+      this.isScriptRunning = true;
-        String linesBufferString = ""; // used to check whether the string in a buffer contains a ";".
+        String linesBufferString = ""; // used to check whether the string in a buffer contains a
+        // ";".
-        LINEREAD_LOOP:
-        while (exitShellRequest == null && (lineRead = reader.readLine()) != null) {
+        LINEREAD_LOOP: while (exitShellRequest == null && (lineRead = reader.readLine()) != null) {
-            //String command = null;
-            
-            
+            // String command = null;
+
-            for(String cmdLet : commandList) {
-              String trimmedCommand = cmdLet.trim();
-              if (!trimmedCommand.isEmpty()) {
+            for (String cmdLet : commandList) {
+              if (!cmdLet.isEmpty()) {
+                String redactedCmdLet = ArgumentRedactor.redact(cmdLet);
-                Gfsh.println(commandSrNum+". Executing - " + cmdLet);                
+                Gfsh.println(commandSrNum + ". Executing - " + redactedCmdLet);
-                scriptInfo.addCommandAndStatus(cmdLet, getLastExecutionStatus() == -1 || getLastExecutionStatus() == -2 ? "FAILED" : "PASSED");                
-                if ((getLastExecutionStatus() == -1 || getLastExecutionStatus() == -2) && !continueOnError) {
+                scriptInfo.addCommandAndStatus(cmdLet,
+                    getLastExecutionStatus() == -1 || getLastExecutionStatus() == -2 ? "FAILED"
+                        : "PASSED");
+                if ((getLastExecutionStatus() == -1 || getLastExecutionStatus() == -2)
+                    && !continueOnError) {
-            
+
-            linesBuffer       = null;
+            linesBuffer = null;
-        throw new CommandProcessingException(scriptFile.getPath()+" doesn't exist.", CommandProcessingException.ARGUMENT_INVALID, scriptFile);
+        throw new CommandProcessingException(scriptFile.getPath() + " doesn't exist.",
+            CommandProcessingException.ARGUMENT_INVALID, scriptFile);
-      throw new CommandProcessingException("Error while reading file "+scriptFile, CommandProcessingException.RESOURCE_ACCESS_ERROR, e);
+      throw new CommandProcessingException("Error while reading file " + scriptFile,
+          CommandProcessingException.RESOURCE_ACCESS_ERROR, e);
-      throw new IllegalArgumentException("Environment Property name and/or value can not be set to null.");
+      throw new IllegalArgumentException(
+          "Environment Property name and/or value can not be set to null.");
-// Enable when "use region" command is required. See #46110
-//    env.put(CliConstants.ENV_APP_CONTEXT_PATH, currentContext);
+    // Enable when "use region" command is required. See #46110
+    // env.put(CliConstants.ENV_APP_CONTEXT_PATH, currentContext);
-//    System.out.println(env.get(CliConstants.ENV_APP_QUIET_EXECUTION));
+    // System.out.println(env.get(CliConstants.ENV_APP_QUIET_EXECUTION));
-    String line   = null;
+    String line = null;
-        if (!line.endsWith(SyntaxConstants.CONTINUATION_CHARACTER)) { // see 45893                   
+        if (!line.endsWith(SyntaxConstants.CONTINUATION_CHARACTER)) { // see 45893
-          for(String cmdLet : commandList) {
+          for (String cmdLet : commandList) {
-            if (!trimmedCommand.isEmpty()) {            
+            if (!trimmedCommand.isEmpty()) {
-          prompt = getPromptText();          
+          prompt = getPromptText();
-    String readLine    = null;
+    String readLine = null;
-    return operationInvoker != null
-            && operationInvoker.isConnected()
-              && operationInvoker.isReady();
+    return operationInvoker != null && operationInvoker.isConnected() && operationInvoker.isReady();
-  ////////////////////////Fields for TestableShell End  ////////////////////////
+  //////////////////////// Fields for TestableShell End ////////////////////////
-//          System.out.println(loggerName);
+          // System.out.println(loggerName);
-           * From Java Docs: It is also important to note that the Logger
-           * associated with the String name may be garbage collected at any
-           * time if there is no strong reference to the Logger. The caller of
-           * this method must check the return value for null in order to
-           * properly handle the case where the Logger has been garbage
-           * collected.
+           * From Java Docs: It is also important to note that the Logger associated with the String
+           * name may be garbage collected at any time if there is no strong reference to the
+           * Logger. The caller of this method must check the return value for null in order to
+           * properly handle the case where the Logger has been garbage collected.
-//      e.printStackTrace();
+      // e.printStackTrace();
-      return parser.obtainHelp(userInput, requiredCommandNames);
+    return parser.obtainHelp(userInput, requiredCommandNames);
-    if(!gfshConfig.deleteHistoryFile()){
+    if (!gfshConfig.deleteHistoryFile()) {
-    String contextPath = /*getEnvProperty(CliConstants.ENV_APP_CONTEXT_PATH)*/ "";
+    String contextPath = /* getEnvProperty(CliConstants.ENV_APP_CONTEXT_PATH) */ "";
-        clusterString = "Cluster-" + clusterId+" ";
+        clusterString = "Cluster-" + clusterId + " ";
-//  //As "use region" is not in scope for 7.0, see 46110.
-//      if (contextPath == null) {
-//        contextPath = "." + CliConstants.DEFAULT_APP_CONTEXT_PATH;
-//      } else {
-//        contextPath = "." + contextPath;
-//      }
-//    } else {
-//      contextPath = "." + CliConstants.DEFAULT_APP_CONTEXT_PATH;
+      // //As "use region" is not in scope for 7.0, see 46110.
+      // if (contextPath == null) {
+      // contextPath = "." + CliConstants.DEFAULT_APP_CONTEXT_PATH;
+      // } else {
+      // contextPath = "." + contextPath;
+      // }
+      // } else {
+      // contextPath = "." + CliConstants.DEFAULT_APP_CONTEXT_PATH;
-    String message = CliStrings.format(CliStrings.GFSH__MSG__NO_LONGER_CONNECTED_TO_0, new Object[] {endPoints});
+    String message =
+        CliStrings.format(CliStrings.GFSH__MSG__NO_LONGER_CONNECTED_TO_0, new Object[] {endPoints});
-    setPromptPath(org.apache.geode.management.internal.cli.converters.RegionPathConverter.DEFAULT_APP_CONTEXT_PATH);
+    setPromptPath(
+        org.apache.geode.management.internal.cli.converters.RegionPathConverter.DEFAULT_APP_CONTEXT_PATH);
-  public boolean getDebug(){
+  public boolean getDebug() {
-  public void setDebug(boolean flag){
+  public void setDebug(boolean flag) {
-  public GfshHistory getGfshHistory(){
+  public GfshHistory getGfshHistory() {
-    while ( (foundInLine = s.findInLine("(\\$[\\{]\\w+[\\}])"))  != null) {
+    while ((foundInLine = s.findInLine("(\\$[\\{]\\w+[\\}])")) != null) {
-  public static ConsoleReader getConsoleReader(){
+  public static ConsoleReader getConsoleReader() {
-   * Take a string and wrap it into multiple lines separated by CliConstants.LINE_SEPARATOR.
-   * Lines are separated based upon the terminal width, separated on word boundaries and may have
-   * extra spaces added to provide indentation.
+   * Take a string and wrap it into multiple lines separated by CliConstants.LINE_SEPARATOR. Lines
+   * are separated based upon the terminal width, separated on word boundaries and may have extra
+   * spaces added to provide indentation.
+   *
+   *
-      //   1. If the end of string is reached
-      //   2. If the width of the terminal has been reached
-      //   3. If a newline character was found in the string
-      while (index < string.length() && currentLineLength < maxLineLength && string.charAt(index) != '\n') {
+      // 1. If the end of string is reached
+      // 2. If the width of the terminal has been reached
+      // 3. If a newline character was found in the string
+      while (index < string.length() && currentLineLength < maxLineLength
+          && string.charAt(index) != '\n') {
-      // If the end of the string was reached or the last character just happened to be a space character
+        // If the end of the string was reached or the last character just happened to be a space
+        // character
-          stringBuf.append(string.substring(startOfCurrentLine, spaceCharIndex)).append(LINE_SEPARATOR);
-          index = spaceCharIndex+1;
+          stringBuf.append(string.substring(startOfCurrentLine, spaceCharIndex))
+              .append(LINE_SEPARATOR);
+          index = spaceCharIndex + 1;
-//  // for testing only
-//  public static void main(String[] args) {
-//    try {
-//      Gfsh gfsh = new Gfsh();
-//      String expandProperties = gfsh.expandProperties("execute function --id=group-with-arguments-with-result-collector --result-collector=management.operations.ops.FunctionOperations$CustomResultCollector --arguments=group-with-arguments-with-result-collector --group=managed1");
-////      String expandProperties = gfsh.expandProperties("My name is ${NAME}");
-//      System.out.println(expandProperties);
-//    } catch (ClassNotFoundException e) {
-//      e.printStackTrace();
-//    } catch (IOException e) {
-//      e.printStackTrace();
-//    }
-//  }
+  // // for testing only
+  // public static void main(String[] args) {
+  // try {
+  // Gfsh gfsh = new Gfsh();
+  // String expandProperties = gfsh.expandProperties("execute function
+  // --id=group-with-arguments-with-result-collector
+  // --result-collector=management.operations.ops.FunctionOperations$CustomResultCollector
+  // --arguments=group-with-arguments-with-result-collector --group=managed1");
+  //// String expandProperties = gfsh.expandProperties("My name is ${NAME}");
+  // System.out.println(expandProperties);
+  // } catch (ClassNotFoundException e) {
+  // e.printStackTrace();
+  // } catch (IOException e) {
+  // e.printStackTrace();
+  // }
+  // }
+
-    compositeResultData.setHeader("************************* Execution Summary ***********************\nScript file: " + filePath);
+    compositeResultData.setHeader(
+        "************************* Execution Summary ***********************\nScript file: "
+            + filePath);
-      SectionResultData section = compositeResultData.addSection(""+(i+1));
+      SectionResultData section = compositeResultData.addSection("" + (i + 1));
-      section.addData("Command-"+String.valueOf(commandSrNo), commandAndStatus.command);
+      section.addData("Command-" + String.valueOf(commandSrNo), commandAndStatus.command);
-      return command + "     " +status;
+      return command + "     " + status;

MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 MOV26 UPD40 INS31 INS31 INS83 INS43 INS42 INS44 INS43 INS8 INS83 INS43 INS42 INS44 INS43 INS8 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 UPD45 INS42 INS43 INS42 INS42 INS25 INS41 INS42 INS43 INS42 INS42 INS25 INS41 UPD66 UPD66 UPD66 UPD66 UPD66 INS42 INS27 INS41 INS32 INS42 INS27 INS41 INS32 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD42 INS42 INS32 INS33 INS42 INS42 INS13 INS42 INS32 INS33 INS42 INS42 UPD45 INS42 INS42 INS60 UPD42 MOV43 INS59 INS42 INS32 INS42 INS42 INS42 UPD42 DEL66 DEL66 DEL66 DEL66 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60
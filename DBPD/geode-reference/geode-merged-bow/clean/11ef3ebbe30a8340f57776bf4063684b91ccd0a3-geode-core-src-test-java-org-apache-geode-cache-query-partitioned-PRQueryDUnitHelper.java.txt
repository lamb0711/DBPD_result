GEODE-538: Add check for persistent data recovery

PartitionedRegion.getNodeForBucketReadOrLoad can return an invalid node
if persistent data recovery is in process and a get() targets a bucket
that
hasn't been recoverd yet. This can result in returning an incorrect
value (null) or throwing ConflictingPersistentDataException from a get()
or put() on the region.

This change adds a check for persistent recovery to be completed
before creating the new bucket. If recovery isn't complete then the
operation on the region will fail with a PartitionOfflineException.

Queries on a region while persistent recovery is in progress can also
result in incorrect results so a similar check is added to
DefaultQuery.checkQueryOnPR.

This closes #264

+import org.apache.geode.cache.DiskStore;
+  /**
+   * This function creates a colocated pair of PR's given the scope & the
+   * redundancy parameters for the parent *
+   *
+   * @param regionName
+   * @param redundancy
+   * @param constraint
+   * @param makePersistent
+   * @return cacheSerializable object
+   */
+  public CacheSerializableRunnable getCacheSerializableRunnableForColocatedPRCreate(
+    final String regionName, final int redundancy, final Class constraint, boolean makePersistent) {
+
+    final String childRegionName = regionName + "Child";
+    final String diskName = "disk";
+    SerializableRunnable createPrRegion;
+    createPrRegion = new CacheSerializableRunnable(regionName) {
+      @Override
+      public void run2() throws CacheException
+      {
+
+        Cache cache = getCache();
+        Region partitionedregion = null;
+        Region childRegion = null;
+        AttributesFactory attr = new AttributesFactory();
+        attr.setValueConstraint(constraint);
+        if (makePersistent) {
+          DiskStore ds = cache.findDiskStore(diskName);
+          if (ds == null) {
+            ds = cache.createDiskStoreFactory().setDiskDirs(JUnit4CacheTestCase.getDiskDirs())
+                .create(diskName);
+          }
+          attr.setDataPolicy(DataPolicy.PERSISTENT_PARTITION);
+          attr.setDiskStoreName(diskName);
+        } else {
+          attr.setDataPolicy(DataPolicy.PARTITION);
+          attr.setDiskStoreName(null);
+        }
+
+        PartitionAttributesFactory paf = new PartitionAttributesFactory();
+        paf.setRedundantCopies(redundancy);
+        attr.setPartitionAttributes(paf.create());
+
+        // parent region
+        partitionedregion = cache.createRegion(regionName, attr.create());
+        assertNotNull(
+            "PRQueryDUnitHelper#getCacheSerializableRunnableForPRCreateWithRedundancy: Partitioned Region "
+                + regionName + " not in cache", cache.getRegion(regionName));
+        assertNotNull(
+            "PRQueryDUnitHelper#getCacheSerializableRunnableForPRCreateWithRedundancy: Partitioned Region ref null",
+            partitionedregion);
+        assertTrue(
+            "PRQueryDUnitHelper#getCacheSerializableRunnableForPRCreateWithRedundancy: Partitioned Region ref claims to be destroyed",
+            !partitionedregion.isDestroyed());
+
+        // child region
+        attr.setValueConstraint(constraint);
+        paf.setColocatedWith(regionName);
+        attr.setPartitionAttributes(paf.create());
+        childRegion = cache.createRegion(childRegionName, attr.create());
+      }
+    };
+
+    return (CacheSerializableRunnable)createPrRegion;
+  }
+
+  /**
+   * This function creates the parent region of colocated pair of PR's given the scope & the
+   * redundancy parameters for the parent *
+   *
+   * @param regionName
+   * @param redundancy
+   * @param constraint
+   * @param makePersistent
+   * @return cacheSerializable object
+   */
+  public CacheSerializableRunnable getCacheSerializableRunnableForColocatedParentCreate(
+    final String regionName, final int redundancy, final Class constraint, boolean makePersistent) {
+
+    final String childRegionName = regionName + "Child";
+    final String diskName = "disk";
+    SerializableRunnable createPrRegion;
+    createPrRegion = new CacheSerializableRunnable(regionName + "-NoChildRegion") {
+      @Override
+      public void run2() throws CacheException
+      {
+
+        Cache cache = getCache();
+        Region partitionedregion = null;
+        Region childRegion = null;
+        AttributesFactory attr = new AttributesFactory();
+        attr.setValueConstraint(constraint);
+        if (makePersistent) {
+          DiskStore ds = cache.findDiskStore(diskName);
+          if (ds == null) {
+            ds = cache.createDiskStoreFactory().setDiskDirs(JUnit4CacheTestCase.getDiskDirs())
+                .create(diskName);
+          }
+          attr.setDataPolicy(DataPolicy.PERSISTENT_PARTITION);
+          attr.setDiskStoreName(diskName);
+        } else {
+          attr.setDataPolicy(DataPolicy.PARTITION);
+          attr.setDiskStoreName(null);
+        }
+
+        PartitionAttributesFactory paf = new PartitionAttributesFactory();
+        paf.setRedundantCopies(redundancy);
+        attr.setPartitionAttributes(paf.create());
+
+        // parent region
+        partitionedregion = cache.createRegion(regionName, attr.create());
+        assertNotNull(
+            "PRQueryDUnitHelper#getCacheSerializableRunnableForPRCreateWithRedundancy: Partitioned Region "
+                + regionName + " not in cache", cache.getRegion(regionName));
+        assertNotNull(
+            "PRQueryDUnitHelper#getCacheSerializableRunnableForPRCreateWithRedundancy: Partitioned Region ref null",
+            partitionedregion);
+        assertTrue(
+            "PRQueryDUnitHelper#getCacheSerializableRunnableForPRCreateWithRedundancy: Partitioned Region ref claims to be destroyed",
+            !partitionedregion.isDestroyed());
+      }
+    };
+
+    return (CacheSerializableRunnable)createPrRegion;
+  }
+
+  /**
+   * This function creates the parent region of colocated pair of PR's given the scope & the
+   * redundancy parameters for the parent *
+   *
+   * @param regionName
+   * @param redundancy
+   * @param constraint
+   * @param isPersistent
+   * @return cacheSerializable object
+   */
+  public CacheSerializableRunnable getCacheSerializableRunnableForColocatedChildCreate(
+    final String regionName, final int redundancy, final Class constraint, boolean isPersistent) {
+
+    final String childRegionName = regionName + "Child";
+    final String diskName = "disk";
+    SerializableRunnable createPrRegion;
+    createPrRegion = new CacheSerializableRunnable(regionName + "-ChildRegion") {
+      @Override
+      public void run2() throws CacheException
+      {
+
+        Cache cache = getCache();
+        Region partitionedregion = null;
+        Region childRegion = null;
+        AttributesFactory attr = new AttributesFactory();
+        attr.setValueConstraint(constraint);
+        if (isPersistent) {
+          DiskStore ds = cache.findDiskStore(diskName);
+          if (ds == null) {
+//            ds = cache.createDiskStoreFactory().setDiskDirs(getDiskDirs())
+            ds = cache.createDiskStoreFactory().setDiskDirs(org.apache.geode.test.dunit.cache.internal.JUnit4CacheTestCase.getDiskDirs())
+                .create(diskName);
+          }
+          attr.setDataPolicy(DataPolicy.PERSISTENT_PARTITION);
+          attr.setDiskStoreName(diskName);
+        } else {
+          attr.setDataPolicy(DataPolicy.PARTITION);
+          attr.setDiskStoreName(null);
+        }
+
+        PartitionAttributesFactory paf = new PartitionAttributesFactory();
+        paf.setRedundantCopies(redundancy);
+        attr.setPartitionAttributes(paf.create());
+
+        // skip parent region creation
+        // partitionedregion = cache.createRegion(regionName, attr.create());
+
+        // child region
+        attr.setValueConstraint(constraint);
+        paf.setColocatedWith(regionName);
+        attr.setPartitionAttributes(paf.create());
+        childRegion = cache.createRegion(childRegionName, attr.create());
+      }
+    };
+
+    return (CacheSerializableRunnable)createPrRegion;
+  }
+

INS26 INS40 INS31 INS31 INS31 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS8 INS29 INS83 INS43 INS42 INS44 INS44 INS44 INS44 INS8 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS83 INS43 INS42 INS83 INS39 INS42 INS83 INS43 INS42 INS39 INS42 INS60 INS60 INS60 INS21 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS83 INS43 INS42 INS83 INS39 INS42 INS83 INS43 INS42 INS39 INS42 INS60 INS60 INS60 INS21 INS41 INS65 INS65 INS65 INS65 INS65 INS65 INS42 INS83 INS43 INS42 INS83 INS39 INS42 INS83 INS43 INS42 INS39 INS42 INS60 INS60 INS60 INS21 INS41 INS66 INS66 INS42 INS42 INS42 INS42 INS66 INS42 INS42 INS83 INS43 INS59 INS83 INS43 INS59 INS43 INS59 INS7 INS11 INS66 INS66 INS42 INS42 INS42 INS42 INS66 INS42 INS42 INS83 INS43 INS59 INS83 INS43 INS59 INS43 INS59 INS7 INS11 INS66 INS66 INS42 INS42 INS42 INS42 INS66 INS42 INS42 INS83 INS43 INS59 INS83 INS43 INS59 INS43 INS59 INS7 INS11 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS42 INS42 INS14 INS43 INS42 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS42 INS42 INS14 INS43 INS42 INS42 INS42 INS27 INS42 INS42 INS45 INS42 INS42 INS42 INS14 INS43 INS42 INS42 INS45 INS43 INS42 INS1 INS42 INS42 INS45 INS43 INS27 INS1 INS42 INS42 INS45 INS43 INS27 INS1 INS42 INS42 INS31 INS42 INS42 INS45 INS31 INS42 INS42 INS45 INS31 INS78 INS83 INS39 INS42 INS43 INS8 INS78 INS83 INS39 INS42 INS43 INS8 INS78 INS83 INS39 INS42 INS43 INS8 INS42 INS42 INS60 INS60 INS60 INS60 INS21 INS25 INS60 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS60 INS60 INS60 INS60 INS21 INS25 INS60 INS21 INS21 INS21 INS21 INS21 INS21 INS42 INS42 INS60 INS60 INS60 INS60 INS21 INS25 INS60 INS21 INS21 INS21 INS21 INS21 INS21 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS32 INS42 INS8 INS8 INS43 INS59 INS32 INS32 INS7 INS32 INS32 INS32 INS32 INS32 INS32 INS7 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS32 INS42 INS8 INS8 INS43 INS59 INS32 INS32 INS7 INS32 INS32 INS32 INS43 INS59 INS43 INS59 INS43 INS59 INS43 INS59 INS32 INS42 INS8 INS8 INS43 INS59 INS32 INS32 INS32 INS32 INS32 INS7 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS42 INS14 INS42 INS42 INS42 INS60 INS25 INS21 INS21 INS21 INS21 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS27 INS32 INS42 INS45 INS42 INS42 INS45 INS38 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS42 INS14 INS42 INS42 INS42 INS60 INS25 INS21 INS21 INS21 INS21 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS27 INS32 INS42 INS45 INS42 INS42 INS45 INS38 INS42 INS42 INS32 INS42 INS42 INS33 INS42 INS42 INS33 INS42 INS42 INS14 INS42 INS42 INS42 INS60 INS25 INS21 INS21 INS21 INS21 INS42 INS42 INS14 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS42 INS43 INS43 INS59 INS27 INS8 INS32 INS32 INS32 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS32 INS45 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS43 INS43 INS59 INS27 INS8 INS32 INS32 INS32 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS32 INS45 INS42 INS45 INS42 INS42 INS42 INS32 INS42 INS43 INS43 INS59 INS27 INS8 INS32 INS32 INS32 INS32 INS43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS33 INS21 INS42 INS42 INS40 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS42 INS33 INS42 INS42 INS42 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS7 INS42 INS42 INS42 INS7 INS42 INS32 INS42 INS32 INS42 INS32 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS32 INS32 INS42 INS32 INS32 INS42 INS32 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This message is sent to all the nodes in the DistributedSystem. It contains
- * the list of messages that have been dispatched by this node. The messages are
- * received by other nodes and the processing is handed over to an executor
+ * This message is sent to all the nodes in the DistributedSystem. It contains the list of messages
+ * that have been dispatched by this node. The messages are received by other nodes and the
+ * processing is handed over to an executor
- *  
+ * 
-public final class QueueRemovalMessage extends PooledDistributionMessage
-  {
+public final class QueueRemovalMessage extends PooledDistributionMessage {
-//  /**
-//   * Executor for processing incoming messages
-//   */
-//  private static final Executor executor;
+  // /**
+  // * Executor for processing incoming messages
+  // */
+  // private static final Executor executor;
-//  /**
-//   * create the executor in a static block
-//   */
-//  static {
-//    //TODO:Mitul best implementation of executor for this task?
-//    executor = Executors.newCachedThreadPool();
-//  }
+  // /**
+  // * create the executor in a static block
+  // */
+  // static {
+  // //TODO:Mitul best implementation of executor for this task?
+  // executor = Executors.newCachedThreadPool();
+  // }
-   *  
+   * 
-  public void setMessagesList(List messages)
-  {
+  public void setMessagesList(List messages) {
-   * Extracts the region from the message list and hands over the message
-   * removal task to the executor
+   * Extracts the region from the message list and hands over the message removal task to the
+   * executor
-  protected void process(DistributionManager dm)
-  {
+  protected void process(DistributionManager dm) {
-    cache = GemFireCacheImpl.getInstance(); //CacheFactory.getAnyInstance();
+    cache = GemFireCacheImpl.getInstance(); // CacheFactory.getAnyInstance();
-      int oldLevel = LocalRegion.setThreadInitLevelRequirement(
-          LocalRegion.BEFORE_INITIAL_IMAGE); 
+      int oldLevel = LocalRegion.setThreadInitLevelRequirement(LocalRegion.BEFORE_INITIAL_IMAGE);
-      while (iterator.hasNext()) {
-        final String regionName = (String)iterator.next();
-        final int size = ((Integer)iterator.next()).intValue();
-          final LocalRegion region = (LocalRegion)cache.getRegion(regionName);
-        final HARegionQueue hrq;
+        while (iterator.hasNext()) {
+          final String regionName = (String) iterator.next();
+          final int size = ((Integer) iterator.next()).intValue();
+          final LocalRegion region = (LocalRegion) cache.getRegion(regionName);
+          final HARegionQueue hrq;
-          hrq = null;
+            hrq = null;
-            HARegionQueue tmp = ((HARegion)region).getOwner();
+            HARegionQueue tmp = ((HARegion) region).getOwner();
-        }
+            }
-        for (int i = 0; i < size; i++) {
-          final EventID id = (EventID)iterator.next();
+          for (int i = 0; i < size; i++) {
+            final EventID id = (EventID) iterator.next();
-              //dm.getWaitingThreadPool().execute(new Runnable() {
-              //  public void run()
-              //  {
-                  try {
-                    if (logger.isTraceEnabled()) {
-                      logger.trace("QueueRemovalMessage: removing dispatched events on queue {} for {}", regionName, id);
-                    }
-                    hrq.removeDispatchedEvents(id);
-                  } catch (RegionDestroyedException rde) {
-                    logger.info(LocalizedMessage.create(LocalizedStrings.QueueRemovalMessage_QUEUE_FOUND_DESTROYED_WHILE_PROCESSING_THE_LAST_DISPTACHED_SEQUENCE_ID_FOR_A_HAREGIONQUEUES_DACE_THE_EVENT_ID_IS_0_FOR_HAREGION_WITH_NAME_1, new Object[] {id, regionName}));
-                  } catch (CancelException e) {
-                    return;  // cache or DS is closing  
-                  } catch (CacheException e) {
-                    logger.error(LocalizedMessage.create(LocalizedStrings.QueueRemovalMessage_QUEUEREMOVALMESSAGEPROCESSEXCEPTION_IN_PROCESSING_THE_LAST_DISPTACHED_SEQUENCE_ID_FOR_A_HAREGIONQUEUES_DACE_THE_PROBLEM_IS_WITH_EVENT_ID__0_FOR_HAREGION_WITH_NAME_1, new Object[] {regionName, id}), e);
-                  } catch (InterruptedException ie) {
-                    return; // interrupt occurs during shutdown.  this runs in an executor, so just stop processing
-                  }
-            }
-            catch (RejectedExecutionException e) {
+              // dm.getWaitingThreadPool().execute(new Runnable() {
+              // public void run()
+              // {
+              try {
+                if (logger.isTraceEnabled()) {
+                  logger.trace("QueueRemovalMessage: removing dispatched events on queue {} for {}",
+                      regionName, id);
+                }
+                hrq.removeDispatchedEvents(id);
+              } catch (RegionDestroyedException rde) {
+                logger.info(LocalizedMessage.create(
+                    LocalizedStrings.QueueRemovalMessage_QUEUE_FOUND_DESTROYED_WHILE_PROCESSING_THE_LAST_DISPTACHED_SEQUENCE_ID_FOR_A_HAREGIONQUEUES_DACE_THE_EVENT_ID_IS_0_FOR_HAREGION_WITH_NAME_1,
+                    new Object[] {id, regionName}));
+              } catch (CancelException e) {
+                return; // cache or DS is closing
+              } catch (CacheException e) {
+                logger.error(LocalizedMessage.create(
+                    LocalizedStrings.QueueRemovalMessage_QUEUEREMOVALMESSAGEPROCESSEXCEPTION_IN_PROCESSING_THE_LAST_DISPTACHED_SEQUENCE_ID_FOR_A_HAREGIONQUEUES_DACE_THE_PROBLEM_IS_WITH_EVENT_ID__0_FOR_HAREGION_WITH_NAME_1,
+                    new Object[] {regionName, id}), e);
+              } catch (InterruptedException ie) {
+                return; // interrupt occurs during shutdown. this runs in an executor, so just stop
+                        // processing
+              }
+            } catch (RejectedExecutionException e) {
-            }
-            finally {
+            } finally {
-  public void toData(DataOutput out) throws IOException
-  {
+  public void toData(DataOutput out) throws IOException {
-     * first write the total list size then in a loop write the region name,
-     * number of eventIds and the event ids
-     *  
+     * first write the total list size then in a loop write the region name, number of eventIds and
+     * the event ids
+     * 
-    //write the size of the data list
+    // write the size of the data list
-      regionName = (String)iterator.next();
-      //write the regionName
+      regionName = (String) iterator.next();
+      // write the regionName
-      numberOfIds = (Integer)iterator.next();
-      //write the number of event ids
+      numberOfIds = (Integer) iterator.next();
+      // write the number of event ids
-      //write the event ids
+      // write the event ids
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException
-  {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-     * read the total list size, reconstruct the message list in a loop by reading
-     * the region name, number of eventIds and the event ids
-     *  
+     * read the total list size, reconstruct the message list in a loop by reading the region name,
+     * number of eventIds and the event ids
+     * 
-    //read the size of the message
+    // read the size of the message
-      //read the region name
+      // read the region name
-      //read the datasize
+      // read the datasize
-      //read the total number of events
+      // read the total number of events
-      // 
+      //

UPD66 UPD66 UPD66 UPD66 UPD66
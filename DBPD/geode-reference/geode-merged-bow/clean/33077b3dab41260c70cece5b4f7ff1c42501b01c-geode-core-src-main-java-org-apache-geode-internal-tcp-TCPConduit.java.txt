GEODE-2113 Implement SSL over NIO

This fixes several bugs in the original implementation of SSL over NIO.
Notably there were buffer handling problems in MsgReader and the
NioFilters.  This new commit includes code coverage for these classes
in new tests.

Original commit message:

This removes old-I/O use in TCPConduit peer-to-peer communications.
This was used for SSL/TLS secure commuications but Java has had an
SSLEngine implementation that allows you to implement secure communications
on new-I/O SocketChannels or any other transport mechanism.

A new NioSSLEngine class wraps the JDK's SSLEngine and provides the
SSL handshake as well as encryption/decryption of messages. SocketCreator
performs the SSL handshake and returns a NioSslEngine that TCPConduit
then uses for messaging.

The SSL handshake needs to be done in Connection.java now because the
ByteBuffer used to do the handshake is also used for reading messages
in Receivers. Because of this the Handshake pool in TCPConduit became
obsolete and I deleted it.

I've also done a lot of cleanup of compilation warnings in Connection.java
and removed references to "NIO". The primary SSL/TLS changes in that class
are in writeFully (renamed from nioWriteFully) and processBuffer (renamed
from processNIOBuffer).

While testing I noticed some places where we're creating non-daemon
threads that were keeping DUnit ChildVM processes from exiting.  I've
changed these places to use daemon threads.  Very few threads in Geode
should be non-daemon.

Porting client/server to use NioSSLEngine will be done under a separate
ticket and a different version of NioEngine may be created to secure
UDP messaging.

-import java.net.Inet6Address;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.ThreadPoolExecutor;
-
-import javax.net.ssl.SSLException;
-import org.apache.geode.internal.logging.LoggingExecutors;
-  static boolean useSSL;
-
-  /**
-   * Force use of Sockets rather than SocketChannels (NIO). Note from Bruce: due to a bug in the
-   * java VM, NIO cannot be used with IPv6 addresses on Windows. When that condition holds, the
-   * useNIO flag must be disregarded.
-   */
-  private static boolean USE_NIO;
-
-  /**
-   * use direct ByteBuffers instead of heap ByteBuffers for NIO operations
-   */
-  static boolean useDirectBuffers;
+  boolean useSSL;
-  /**
-   * true if NIO can be used for the server socket
-   */
-  private boolean useNIO;
-
-    useSSL = Boolean.getBoolean("p2p.useSSL");
-    // only use nio if not SSL
-    USE_NIO = !useSSL && !Boolean.getBoolean("p2p.oldIO");
-    useDirectBuffers = USE_NIO && !Boolean.getBoolean("p2p.nodirectBuffers");
-    LISTENER_CLOSE_TIMEOUT = Integer.getInteger("p2p.listenerCloseTimeout", 60000).intValue();
+    LISTENER_CLOSE_TIMEOUT = Integer.getInteger("p2p.listenerCloseTimeout", 60000);
-    BACKLOG = Integer.getInteger("p2p.backlog", 1280).intValue();
+    BACKLOG = Integer.getInteger("p2p.backlog", 1280);
+    if (Boolean.getBoolean("p2p.oldIO")) {
+      logger.warn("detected use of p2p.oldIO setting - this is no longer supported");
+    }
-  public int tcpBufferSize = DistributionConfig.DEFAULT_SOCKET_BUFFER_SIZE;
-  public int idleConnectionTimeout = DistributionConfig.DEFAULT_SOCKET_LEASE_TIME;
+  int tcpBufferSize = DistributionConfig.DEFAULT_SOCKET_BUFFER_SIZE;
+  int idleConnectionTimeout = DistributionConfig.DEFAULT_SOCKET_LEASE_TIME;
+    this.useSSL = socketCreator.useSSL();
-    this.useNIO = USE_NIO;
-    if (this.useNIO) {
-      InetAddress addr = address;
-      if (addr == null) {
-        try {
-          addr = SocketCreator.getLocalHost();
-        } catch (java.net.UnknownHostException e) {
-          throw new ConnectionException("Unable to resolve localHost address", e);
-        }
-      }
-      // JDK bug 6230761 - NIO can't be used with IPv6 on Windows
-      if (addr instanceof Inet6Address) {
-        String os = System.getProperty("os.name");
-        if (os != null) {
-          if (os.indexOf("Windows") != -1) {
-            this.useNIO = false;
-          }
-        }
+    InetAddress addr = address;
+    if (addr == null) {
+      try {
+        addr = SocketCreator.getLocalHost();
+      } catch (java.net.UnknownHostException e) {
+        throw new ConnectionException("Unable to resolve localHost address", e);
-  private ExecutorService hsPool;
-
-  private static final int HANDSHAKE_POOL_SIZE =
-      Integer.getInteger("p2p.HANDSHAKE_POOL_SIZE", 10).intValue();
-  private static final long HANDSHAKE_POOL_KEEP_ALIVE_TIME =
-      Long.getLong("p2p.HANDSHAKE_POOL_KEEP_ALIVE_TIME", 60).longValue();
-
-  /**
-   * added to fix bug 40436
-   */
-  public void setMaximumHandshakePoolSize(int maxSize) {
-    if (this.hsPool != null) {
-      ThreadPoolExecutor handshakePool = (ThreadPoolExecutor) this.hsPool;
-      if (maxSize > handshakePool.getMaximumPoolSize()) {
-        handshakePool.setMaximumPoolSize(maxSize);
-      }
-    }
-  }
-
-    InetAddress ba = this.address;
-    {
-      ExecutorService tmp_hsPool = null;
-      String threadName = "P2P-Handshaker " + ba + ":" + p + " Thread ";
-      try {
-        tmp_hsPool =
-            LoggingExecutors.newThreadPoolWithSynchronousFeedThatHandlesRejection(threadName, null,
-                null, 1, HANDSHAKE_POOL_SIZE, HANDSHAKE_POOL_KEEP_ALIVE_TIME);
-      } catch (IllegalArgumentException poolInitException) {
-        throw new ConnectionException(
-            "while creating handshake pool",
-            poolInitException);
-      }
-      this.hsPool = tmp_hsPool;
-    }
+
-        this.hsPool.shutdownNow();
-      if (this.useNIO) {
-        if (serverPort <= 0) {
+      if (serverPort <= 0) {
-          socket = socketCreator.createServerSocketUsingPortRange(bindAddress,
-              connectionRequestBacklog, isBindAddress,
-              this.useNIO, 0, tcpPortRange);
-        } else {
-          ServerSocketChannel channel = ServerSocketChannel.open();
-          socket = channel.socket();
-
-          InetSocketAddress inetSocketAddress =
-              new InetSocketAddress(isBindAddress ? bindAddress : null, serverPort);
-          socket.bind(inetSocketAddress, connectionRequestBacklog);
-        }
-
-        if (useNIO) {
-          try {
-            // set these buffers early so that large buffers will be allocated
-            // on accepted sockets (see java.net.ServerSocket.setReceiverBufferSize javadocs)
-            socket.setReceiveBufferSize(tcpBufferSize);
-            int newSize = socket.getReceiveBufferSize();
-            if (newSize != tcpBufferSize) {
-              logger.info("{} is {} instead of the requested {}",
-                  "Listener receiverBufferSize", Integer.valueOf(newSize),
-                  Integer.valueOf(tcpBufferSize));
-            }
-          } catch (SocketException ex) {
-            logger.warn("Failed to set listener receiverBufferSize to {}",
-                tcpBufferSize);
-          }
-        }
-        channel = socket.getChannel();
+        socket = socketCreator.createServerSocketUsingPortRange(bindAddress,
+            connectionRequestBacklog, isBindAddress,
+            true, 0, tcpPortRange);
-        try {
-          if (serverPort <= 0) {
-            socket = socketCreator.createServerSocketUsingPortRange(bindAddress,
-                connectionRequestBacklog, isBindAddress,
-                this.useNIO, this.tcpBufferSize, tcpPortRange);
-          } else {
-            socket = socketCreator.createServerSocket(serverPort, connectionRequestBacklog,
-                isBindAddress ? bindAddress : null,
-                this.tcpBufferSize);
-          }
-          int newSize = socket.getReceiveBufferSize();
-          if (newSize != this.tcpBufferSize) {
-            logger.info("Listener receiverBufferSize is {} instead of the requested {}",
-                Integer.valueOf(newSize),
-                Integer.valueOf(this.tcpBufferSize));
-          }
-        } catch (SocketException ex) {
-          logger.warn("Failed to set listener receiverBufferSize to {}",
-              this.tcpBufferSize);
+        ServerSocketChannel channel = ServerSocketChannel.open();
+        socket = channel.socket();
-        }
+        InetSocketAddress inetSocketAddress =
+            new InetSocketAddress(isBindAddress ? bindAddress : null, serverPort);
+        socket.bind(inetSocketAddress, connectionRequestBacklog);
+
+      try {
+        // set these buffers early so that large buffers will be allocated
+        // on accepted sockets (see java.net.ServerSocket.setReceiverBufferSize javadocs)
+        socket.setReceiveBufferSize(tcpBufferSize);
+        int newSize = socket.getReceiveBufferSize();
+        if (newSize != tcpBufferSize) {
+          logger.info("{} is {} instead of the requested {}",
+              "Listener receiverBufferSize", newSize,
+              tcpBufferSize);
+        }
+      } catch (SocketException ex) {
+        logger.warn("Failed to set listener receiverBufferSize to {}",
+            tcpBufferSize);
+      }
+      channel = socket.getChannel();
-              new Object[] {Integer.valueOf(serverPort), bindAddress}),
+              serverPort, bindAddress),
-    // this.hsPool.shutdownNow(); // I don't trust this not to allocate objects or to synchronize
-        Thread t = this.thread;;
+        Thread t = this.thread;
-              Integer.valueOf(LISTENER_CLOSE_TIMEOUT));
+              LISTENER_CLOSE_TIMEOUT);
-      } finally {
-        this.hsPool.shutdownNow();
-        if (this.useNIO) {
-          SocketChannel otherChannel = channel.accept();
-          othersock = otherChannel.socket();
-        } else {
-          try {
-            othersock = socket.accept();
-          } catch (SSLException ex) {
-            // SW: This is the case when there is a problem in P2P
-            // SSL configuration, so need to exit otherwise goes into an
-            // infinite loop just filling the logs
-            logger.warn("Stopping P2P listener due to SSL configuration problem.",
-                ex);
-            break;
-          }
-        }
+        SocketChannel otherChannel = channel.accept();
+        othersock = otherChannel.socket();
-  private void acceptConnection(final Socket othersock) {
-    try {
-      this.hsPool.execute(new Runnable() {
-        @Override
-        public void run() {
-          basicAcceptConnection(othersock);
-        }
-      });
-    } catch (RejectedExecutionException rejected) {
-      try {
-        othersock.close();
-      } catch (IOException ignore) {
-      }
-    }
-  }
-
-  protected void basicAcceptConnection(Socket othersock) {
+  private void acceptConnection(Socket othersock) {
-      othersock.setSoTimeout(0);
-      socketCreator.handshakeIfSocketIsSSL(othersock, idleConnectionTimeout);
-    } catch (IOException io) {
-      // exception is logged by the Connection
-      if (!stopped) {
-        this.getStats().incFailedAccept();
-      }
-    } catch (ConnectionException ex) {
+    } catch (IOException | ConnectionException io) {
-   * return true if "new IO" classes are being used for the server socket
-   */
-  protected boolean useNIO() {
-    return this.useNIO;
-  }
-
-  /**
+  public boolean useSSL() {
+    return useSSL;
+  }
+

MOV31 MOV8 UPD83 UPD42 UPD83 UPD42 INS25 MOV60 MOV25 MOV60 MOV60 MOV60 INS54 MOV32 INS8 MOV8 INS12 INS42 MOV32 MOV32 MOV21 INS32 MOV25 MOV21 MOV21 MOV44 INS8 INS32 UPD42 INS42 INS42 INS53 MOV8 INS84 UPD42 MOV42 UPD42 MOV42 UPD45 MOV45 INS14 MOV25 MOV21 MOV43 MOV43 INS42 INS42 MOV43 INS32 INS42 INS42 INS42 INS45 UPD42 MOV42 UPD42 MOV42 INS9 MOV42 MOV42 MOV42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL83 DEL66 DEL66 DEL66 DEL65 DEL29 DEL83 DEL83 DEL39 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL59 DEL23 DEL42 DEL42 DEL38 DEL38 DEL27 DEL7 DEL21 DEL42 DEL42 DEL42 DEL42 DEL45 DEL32 DEL38 DEL27 DEL7 DEL21 DEL42 DEL32 DEL42 DEL32 DEL42 DEL32 DEL7 DEL83 DEL83 DEL42 DEL52 DEL42 DEL22 DEL42 DEL42 DEL43 DEL62 DEL42 DEL43 DEL42 DEL42 DEL42 DEL45 DEL32 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL42 DEL45 DEL32 DEL34 DEL38 DEL27 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL83 DEL42 DEL43 DEL42 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL34 DEL32 DEL42 DEL32 DEL59 DEL23 DEL83 DEL83 DEL83 DEL39 DEL42 DEL42 DEL42 DEL45 DEL34 DEL32 DEL42 DEL32 DEL59 DEL23 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL33 DEL27 DEL42 DEL43 DEL42 DEL42 DEL43 DEL52 DEL42 DEL22 DEL11 DEL59 DEL60 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL31 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL59 DEL60 DEL42 DEL43 DEL42 DEL33 DEL59 DEL60 DEL42 DEL43 DEL42 DEL45 DEL42 DEL45 DEL42 DEL45 DEL27 DEL59 DEL60 DEL42 DEL42 DEL42 DEL42 DEL33 DEL33 DEL34 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL45 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL52 DEL42 DEL22 DEL42 DEL7 DEL21 DEL8 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL52 DEL42 DEL22 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL42 DEL25 DEL52 DEL42 DEL22 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL33 DEL16 DEL52 DEL42 DEL22 DEL32 DEL7 DEL21 DEL8 DEL25 DEL39 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL52 DEL42 DEL22 DEL27 DEL42 DEL42 DEL45 DEL42 DEL42 DEL42 DEL32 DEL42 DEL42 DEL52 DEL42 DEL22 DEL32 DEL32 DEL21 DEL8 DEL25 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL52 DEL42 DEL22 DEL32 DEL21 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL42 DEL42 DEL45 DEL42 DEL43 DEL85 DEL5 DEL42 DEL42 DEL42 DEL32 DEL42 DEL4 DEL3 DEL32 DEL42 DEL14 DEL53 DEL8 DEL12 DEL54 DEL8 DEL20 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL32 DEL7 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL45 DEL42 DEL32 DEL21 DEL10 DEL8 DEL12 DEL54 DEL8 DEL25 DEL8 DEL83 DEL39 DEL42 DEL83 DEL42 DEL43 DEL42 DEL44 DEL52 DEL42 DEL22 DEL42 DEL42 DEL43 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL1 DEL14 DEL32 DEL21 DEL8 DEL42 DEL43 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL8 DEL42 DEL44 DEL8 DEL12 DEL54 DEL8 DEL12 DEL54 DEL8 DEL31 DEL42 DEL42 DEL34 DEL32 DEL21 DEL42 DEL42 DEL42 DEL42 DEL32 DEL21 DEL42 DEL43 DEL42 DEL43 DEL42 DEL44 DEL42 DEL38 DEL52 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL12 DEL66 DEL65 DEL29 DEL52 DEL42 DEL22
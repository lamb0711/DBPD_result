GEODE-2632: refactor code to use interfaces instead of impls

* use getInternalDistributedSystem instead of overriding getDistributedSystem
* use InternalCache instead of GemFireCacheImpl
* remove dead code
* remove useless javadocs and comments

-import org.apache.geode.cache.Cache;
+import org.apache.geode.internal.cache.InternalCache;
-import org.apache.geode.internal.logging.LoggingThreadGroup;
-  final ThreadGroup loggerGroup =
-      LoggingThreadGroup.createThreadGroup("Remote Site Discovery Logger Group", logger);
-
-  public ParallelAsyncEventQueueImpl() {
-    super();
-    this.isParallel = true;
-  }
-
-  public ParallelAsyncEventQueueImpl(Cache cache, GatewaySenderAttributes attrs) {
+  public ParallelAsyncEventQueueImpl(InternalCache cache, GatewaySenderAttributes attrs) {
-        String locators =
-            ((GemFireCacheImpl) this.cache).getDistributedSystem().getConfig().getLocators();
+        String locators = this.cache.getInternalDistributedSystem().getConfig().getLocators();
-      /*
-       * if (getDispatcherThreads() > 1) { eventProcessor = new
-       * ConcurrentParallelGatewaySenderEventProcessor(this); } else { eventProcessor = new
-       * ParallelGatewaySenderEventProcessor(this); }
-       */
-
+
-  // /**
-  // * The sender is not started but only the message queue i.e. shadowPR is created on the node.
-  // * @param targetPr
-  // */
-  // private void createMessageQueueOnAccessorNode(PartitionedRegion targetPr) {
-  // eventProcessor = new ParallelGatewaySenderEventProcessor(this, targetPr);
-  // }
-
-
-  /*
-   * (non-Javadoc)
-   * 
-   * @see
-   * org.apache.geode.internal.cache.wan.AbstractGatewaySender#setModifiedEventId(org.apache.geode.
-   * internal.cache.EntryEventImpl)
-   */
-      // if (getOrderPolicy() == OrderPolicy.THREAD) {
-      // bucketId = PartitionedRegionHelper.getHashKey(
-      // ((EntryEventImpl)clonedEvent).getEventId().getThreadID(),
-      // getMaxParallelismForReplicatedRegion());
-      // }
-      // else
-    // we don't neet to generate different threadId for secondary buckets
+    // we don't need to generate different threadId for secondary buckets
-    // boolean isPrimary = ((PartitionedRegion)getQueue().getRegion())
-    // .getRegionAdvisor().getBucketAdvisor(bucketId).isPrimary();
-    // if (isPrimary) {
-    // newThreadId = ThreadIdentifier
-    // .createFakeThreadIDForParallelGSPrimaryBucket(bucketId,
-    // originatingThreadId);
-    // } else {
-    // newThreadId = ThreadIdentifier
-    // .createFakeThreadIDForParallelGSSecondaryBucket(bucketId,
-    // originatingThreadId);
-    // }
-
-

MOV26 UPD40 UPD43 UPD42 MOV22 UPD42 DEL40 DEL26 DEL83 DEL42 DEL43 DEL42 DEL42 DEL42 DEL45 DEL42 DEL32 DEL59 DEL23 DEL83 DEL42 DEL46 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL8 DEL31 DEL42 DEL43 DEL11 DEL36
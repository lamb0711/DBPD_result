Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class uses the JMX Attributes/Operations that use (return/throw) 
- * GemFire types. This is the single MBean accessible with ObjectName string
- * {@link MemberInfoWithStatsMBean#MBEAN_NAME}}. This MBean can be used to 
- * retrieve the all member details as plain java types.
+ * This class uses the JMX Attributes/Operations that use (return/throw) GemFire types. This is the
+ * single MBean accessible with ObjectName string {@link MemberInfoWithStatsMBean#MBEAN_NAME}}. This
+ * MBean can be used to retrieve the all member details as plain java types.
- * This MBean also acts as a Notification Hub for all the Notifications that are 
- * defined for Admin Distributed System. 
+ * This MBean also acts as a Notification Hub for all the Notifications that are defined for Admin
+ * Distributed System.
-public class MemberInfoWithStatsMBean extends AbstractDynamicMBean 
-                                 implements NotificationEmitter {
+public class MemberInfoWithStatsMBean extends AbstractDynamicMBean implements NotificationEmitter {
-  
+
-  private static final int MAX_ATTRIBUTES_COUNT    = 3;
-  private static final int MAX_OPERATIONS_COUNT    = 3;
+  private static final int MAX_ATTRIBUTES_COUNT = 3;
+  private static final int MAX_OPERATIONS_COUNT = 3;
-  
+
-  /* String constant used for a region that is used on admin side just as a root 
-   * for rootRegions defined on the member */
+  /*
+   * String constant used for a region that is used on admin side just as a root for rootRegions
+   * defined on the member
+   */
-  private static final String REGION_QUERY_EXPRESSION = "*GemFire.Cache*:*,owner={0},type=Region";  
-  private static final String STATS_QUERY_EXPRESSION  = "*GemFire.Statistic*:*,source={0},name={1}";
-  
+  private static final String REGION_QUERY_EXPRESSION = "*GemFire.Cache*:*,owner={0},type=Region";
+  private static final String STATS_QUERY_EXPRESSION = "*GemFire.Statistic*:*,source={0},name={1}";
+
-  /*default*/static final String  MBEAN_NAME = "GemFire:type=MemberInfoWithStatsMBean";
+  /* default */static final String MBEAN_NAME = "GemFire:type=MemberInfoWithStatsMBean";
-  
+
-  private String                        version;
-  private int                           refreshInterval;
-  private String                        id;
-  
-  private Agent                         agent;
+  private String version;
+  private int refreshInterval;
+  private String id;
+
+  private Agent agent;
-  
-  private NotificationForwarder         forwarder;
-  private boolean                       isInitialized;//needs synchronization?
+
+  private NotificationForwarder forwarder;
+  private boolean isInitialized;// needs synchronization?
-   * @throws MBeanRegistrationException 
-   * @throws AdminException 
+   * @throws MBeanRegistrationException
+   * @throws AdminException
-  MemberInfoWithStatsMBean(Agent agent) throws OperationsException, MBeanRegistrationException, AdminException {
-    this.agent           = agent;
-    this.objectName      = ObjectName.getInstance(MBEAN_NAME);
-    this.version         = GemFireVersion.getGemFireVersion();
+  MemberInfoWithStatsMBean(Agent agent)
+      throws OperationsException, MBeanRegistrationException, AdminException {
+    this.agent = agent;
+    this.objectName = ObjectName.getInstance(MBEAN_NAME);
+    this.version = GemFireVersion.getGemFireVersion();
-    this.id              = NOT_AVAILABLE_STR;
-    this.forwarder       = new NotificationForwarder(agent.getMBeanServer());
+    this.id = NOT_AVAILABLE_STR;
+    this.forwarder = new NotificationForwarder(agent.getMBeanServer());
-   * Returns attributes defined for this MBean as an array of 
-   * MBeanAttributeInfo objects.
+   * Returns attributes defined for this MBean as an array of MBeanAttributeInfo objects.
-    
-    /* First letter in attribute name has to be 'V' so that getVersion is 
-     * called. With 'v' it looks for getversion, same for others */
-    attributesInfo[0] = new MBeanAttributeInfo("Version", 
-                                               String.class.getName(), 
-                                               "GemFire Enterprise Version", 
-                                               true,  /*readable*/ 
-                                               false, /*writable*/ 
-                                               false);/*has getter with name like 'is****'*/
-    
-    attributesInfo[1] = new MBeanAttributeInfo("RefreshInterval", 
-                                               String.class.getName(), 
-                                               "The interval (in seconds) between auto-polling for updating member & statistics resources. If this is '-1', it means the this MBean has not yet been initialized. First call to getMembers operation will initialize this MBean.", 
-                                               true,  /*readable*/ 
-                                               false, /*writable*/ 
-                                               false);/*has getter with name like 'is****'*/
-    
-    attributesInfo[2] = new MBeanAttributeInfo("Id", 
-                                               String.class.getName(), 
-                                               "Identifier of the GemFire Enterprise. If this is 'N/A', it means the this MBean has not yet been initialized. First call to getMembers operation will initialize this MBean.", 
-                                               true,  /*readable*/ 
-                                               false, /*writable*/ 
-                                               false);/*has getter with name like 'is****'*/   
-    
-    
+
+    /*
+     * First letter in attribute name has to be 'V' so that getVersion is called. With 'v' it looks
+     * for getversion, same for others
+     */
+    attributesInfo[0] = new MBeanAttributeInfo("Version", String.class.getName(),
+        "GemFire Enterprise Version", true, /* readable */
+        false, /* writable */
+        false);/* has getter with name like 'is****' */
+
+    attributesInfo[1] = new MBeanAttributeInfo("RefreshInterval", String.class.getName(),
+        "The interval (in seconds) between auto-polling for updating member & statistics resources. If this is '-1', it means the this MBean has not yet been initialized. First call to getMembers operation will initialize this MBean.",
+        true, /* readable */
+        false, /* writable */
+        false);/* has getter with name like 'is****' */
+
+    attributesInfo[2] = new MBeanAttributeInfo("Id", String.class.getName(),
+        "Identifier of the GemFire Enterprise. If this is 'N/A', it means the this MBean has not yet been initialized. First call to getMembers operation will initialize this MBean.",
+        true, /* readable */
+        false, /* writable */
+        false);/* has getter with name like 'is****' */
+
+
-  
+
-   * Returns operations defined for this MBean as an array of 
-   * MBeanOperationInfo objects.
+   * Returns operations defined for this MBean as an array of MBeanOperationInfo objects.
-   * @return operations defined as an array of MBeanOperationInfo objects. 
+   * @return operations defined as an array of MBeanOperationInfo objects.
-    
-    operationsInfo[0] = new MBeanOperationInfo("getMembers", 
-                                               "Returns ids as strings for all the members - Application Peers & Cache Servers.", 
-                                               new MBeanParameterInfo[] {}, 
-                                               String[].class.getName(), 
-                                               MBeanOperationInfo.ACTION_INFO);
-    
-    MBeanParameterInfo[] getMemberDetailsArgs = new MBeanParameterInfo[1];
-    getMemberDetailsArgs[0] = new MBeanParameterInfo("memberId", String.class.getName(), "Id of the member for all the details are to be retrieved.");
-    operationsInfo[1] = new MBeanOperationInfo("getMemberDetails", 
-                                                "Returns details for a given member", 
-                                                getMemberDetailsArgs, 
-                                                Map.class.getName(), 
-                                                MBeanOperationInfo.ACTION_INFO);
-    
-    /* For retrieving ObjectNames of existing Region MBeans, MBeanServerConnection.queryMBeans(), could be called */
-    MBeanParameterInfo[] getRegionSnapArgs = new MBeanParameterInfo[1];
-    getRegionSnapArgs[0] = new MBeanParameterInfo("memberId", String.class.getName(), "Id of the member on which we want to discover all the region MBean.");
-    operationsInfo[2] = new MBeanOperationInfo("getRegions", 
-                                                "Returns a java.util.Map of details of regions on a member", 
-                                                getRegionSnapArgs, 
-                                                Map.class.getName(), 
-                                                MBeanOperationInfo.ACTION_INFO);
-    
+    operationsInfo[0] = new MBeanOperationInfo("getMembers",
+        "Returns ids as strings for all the members - Application Peers & Cache Servers.",
+        new MBeanParameterInfo[] {}, String[].class.getName(), MBeanOperationInfo.ACTION_INFO);
+
+    MBeanParameterInfo[] getMemberDetailsArgs = new MBeanParameterInfo[1];
+    getMemberDetailsArgs[0] = new MBeanParameterInfo("memberId", String.class.getName(),
+        "Id of the member for all the details are to be retrieved.");
+    operationsInfo[1] =
+        new MBeanOperationInfo("getMemberDetails", "Returns details for a given member",
+            getMemberDetailsArgs, Map.class.getName(), MBeanOperationInfo.ACTION_INFO);
+
+    /*
+     * For retrieving ObjectNames of existing Region MBeans, MBeanServerConnection.queryMBeans(),
+     * could be called
+     */
+    MBeanParameterInfo[] getRegionSnapArgs = new MBeanParameterInfo[1];
+    getRegionSnapArgs[0] = new MBeanParameterInfo("memberId", String.class.getName(),
+        "Id of the member on which we want to discover all the region MBean.");
+    operationsInfo[2] = new MBeanOperationInfo("getRegions",
+        "Returns a java.util.Map of details of regions on a member", getRegionSnapArgs,
+        Map.class.getName(), MBeanOperationInfo.ACTION_INFO);
+
+
-   * Returns notifications defined for this MBean as an array of
-   * MBeanNotificationInfo objects.
+   * Returns notifications defined for this MBean as an array of MBeanNotificationInfo objects.
-   * @return notification definitions as an array of MBeanNotificationInfo
-   *         objects.
+   * @return notification definitions as an array of MBeanNotificationInfo objects.
-    
-    String[] notificationTypes = new String[] {AdminDistributedSystemJmxImpl.NOTIF_MEMBER_JOINED};
-    notificationsInfo[0] = new MBeanNotificationInfo(notificationTypes,
-                                                    Notification.class.getName(), 
-                                                    "A GemFire manager, cache, or other member has joined this distributed system.");
-    
-    notificationTypes = new String[] {AdminDistributedSystemJmxImpl.NOTIF_MEMBER_LEFT};
-    notificationsInfo[1] = new MBeanNotificationInfo(notificationTypes, 
-                                                    Notification.class.getName(), 
-                                                    "A GemFire manager, cache, or other member has left the distributed system.");
-    
-    notificationTypes = new String[] {AdminDistributedSystemJmxImpl.NOTIF_MEMBER_CRASHED};
-    notificationsInfo[2] = new MBeanNotificationInfo(notificationTypes, 
-                                                    Notification.class.getName(), 
-                                                    "A member of this distributed system has crashed instead of leaving cleanly.");
-    
-    notificationTypes = new String[] {AdminDistributedSystemJmxImpl.NOTIF_ALERT};
-    notificationsInfo[3] = new MBeanNotificationInfo(notificationTypes, 
-                                                    Notification.class.getName(), 
-                                                    "A member of this distributed system has generated an alert.");
-    
-    notificationTypes = new String[] {AdminDistributedSystemJmxImpl.NOTIF_ADMIN_SYSTEM_DISCONNECT};
-    notificationsInfo[4] = new MBeanNotificationInfo(notificationTypes, 
-                                                    Notification.class.getName(), 
-                                                    "A GemFire manager, cache, or other member has joined this distributed system.");
-    
-    notificationTypes = new String[] {SystemMemberJmx.NOTIF_CACHE_CREATED};
-    notificationsInfo[5] = new MBeanNotificationInfo(notificationTypes, 
-                                                    Notification.class.getName(), 
-                                                    "A cache got created on a member of this distributed system.");
-    
-    notificationTypes = new String[] {SystemMemberJmx.NOTIF_CACHE_CLOSED};
-    notificationsInfo[6] = new MBeanNotificationInfo(notificationTypes, 
-                                                    Notification.class.getName(), 
-                                                    "A cache is closed on a member of this distributed system.");
-    
-    notificationTypes = new String[] {SystemMemberJmx.NOTIF_REGION_CREATED};
-    notificationsInfo[7] = new MBeanNotificationInfo(notificationTypes, 
-                                                    Notification.class.getName(), 
-                                                    "A region is created in a cache on a member of this distributed system.");
-    
-    notificationTypes = new String[] {SystemMemberJmx.NOTIF_REGION_LOST};
-    notificationsInfo[8] = new MBeanNotificationInfo(notificationTypes, 
-                                                    Notification.class.getName(), 
-                                                    "A region was removed from a cache on a member of this distributed system.");
-//  String[] notificationTypes5 = new String[] {AdminDistributedSystemJmxImpl.NOTIF_STAT_ALERT};
-//  notificationsInfo[9] = new MBeanNotificationInfo(notificationTypes5, 
-//                                                  Notification.class.getName(), 
-//                                                  "An alert based on statistic(s) has been raised.");    
+    String[] notificationTypes = new String[] {AdminDistributedSystemJmxImpl.NOTIF_MEMBER_JOINED};
+    notificationsInfo[0] =
+        new MBeanNotificationInfo(notificationTypes, Notification.class.getName(),
+            "A GemFire manager, cache, or other member has joined this distributed system.");
+
+    notificationTypes = new String[] {AdminDistributedSystemJmxImpl.NOTIF_MEMBER_LEFT};
+    notificationsInfo[1] =
+        new MBeanNotificationInfo(notificationTypes, Notification.class.getName(),
+            "A GemFire manager, cache, or other member has left the distributed system.");
+
+    notificationTypes = new String[] {AdminDistributedSystemJmxImpl.NOTIF_MEMBER_CRASHED};
+    notificationsInfo[2] =
+        new MBeanNotificationInfo(notificationTypes, Notification.class.getName(),
+            "A member of this distributed system has crashed instead of leaving cleanly.");
+
+    notificationTypes = new String[] {AdminDistributedSystemJmxImpl.NOTIF_ALERT};
+    notificationsInfo[3] =
+        new MBeanNotificationInfo(notificationTypes, Notification.class.getName(),
+            "A member of this distributed system has generated an alert.");
+
+    notificationTypes = new String[] {AdminDistributedSystemJmxImpl.NOTIF_ADMIN_SYSTEM_DISCONNECT};
+    notificationsInfo[4] =
+        new MBeanNotificationInfo(notificationTypes, Notification.class.getName(),
+            "A GemFire manager, cache, or other member has joined this distributed system.");
+
+    notificationTypes = new String[] {SystemMemberJmx.NOTIF_CACHE_CREATED};
+    notificationsInfo[5] =
+        new MBeanNotificationInfo(notificationTypes, Notification.class.getName(),
+            "A cache got created on a member of this distributed system.");
+
+    notificationTypes = new String[] {SystemMemberJmx.NOTIF_CACHE_CLOSED};
+    notificationsInfo[6] = new MBeanNotificationInfo(notificationTypes,
+        Notification.class.getName(), "A cache is closed on a member of this distributed system.");
+
+    notificationTypes = new String[] {SystemMemberJmx.NOTIF_REGION_CREATED};
+    notificationsInfo[7] =
+        new MBeanNotificationInfo(notificationTypes, Notification.class.getName(),
+            "A region is created in a cache on a member of this distributed system.");
+
+    notificationTypes = new String[] {SystemMemberJmx.NOTIF_REGION_LOST};
+    notificationsInfo[8] =
+        new MBeanNotificationInfo(notificationTypes, Notification.class.getName(),
+            "A region was removed from a cache on a member of this distributed system.");
+
+    // String[] notificationTypes5 = new String[] {AdminDistributedSystemJmxImpl.NOTIF_STAT_ALERT};
+    // notificationsInfo[9] = new MBeanNotificationInfo(notificationTypes5,
+    // Notification.class.getName(),
+    // "An alert based on statistic(s) has been raised.");
-  
+
-  /*default*/ ObjectName getObjectName() {
+  /* default */ ObjectName getObjectName() {
-   * @throws OperationsException
-   *           if connection to the DS fails
-   * @throws AdminException
-   *           if connection to the DS fails
+   * @throws OperationsException if connection to the DS fails
+   * @throws AdminException if connection to the DS fails
-    
+
-    if (adminDSJmx == null && adminDS instanceof AdminDistributedSystemJmxImpl) {//instanceof checks for null
-      adminDSJmx      = (AdminDistributedSystemJmxImpl) adminDS;
+    if (adminDSJmx == null && adminDS instanceof AdminDistributedSystemJmxImpl) {// instanceof
+                                                                                 // checks for null
+      adminDSJmx = (AdminDistributedSystemJmxImpl) adminDS;
-      id              = adminDSJmx.getId();
+      id = adminDSJmx.getId();
-  
+
-    
+
-      
+
-    
+
-   * @throws OperationsException
-   *           if (1)agent could not connect in the DS OR 
-   *           (2)Notification Listener could not be registered for the Admin 
-   *              DS MBean OR
-   *           (3)fails to retrieve information from Admin DS
+   * @throws OperationsException if (1)agent could not connect in the DS OR (2)Notification Listener
+   *         could not be registered for the Admin DS MBean OR (3)fails to retrieve information from
+   *         Admin DS
-      
+
-        initializeAll(); //initialize if not yet
+        initializeAll(); // initialize if not yet
-        CacheVm[]      cacheVms = adminDSJmx.getCacheVms();
-        SystemMember[] appVms   = adminDSJmx.getSystemMemberApplications();
-        
+        CacheVm[] cacheVms = adminDSJmx.getCacheVms();
+        SystemMember[] appVms = adminDSJmx.getSystemMemberApplications();
+
-        if (cacheVms != null && cacheVms.length !=0) {
+        if (cacheVms != null && cacheVms.length != 0) {
-        if (appVms != null && appVms.length !=0) {
+        if (appVms != null && appVms.length != 0) {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_FOR_OPERATION_0, "getMembers"), e);
+      logger.warn(
+          LocalizedMessage.create(
+              LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_FOR_OPERATION_0, "getMembers"),
+          e);
-      logger.warn(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_FOR_OPERATION_0, "getMembers"), e);
+      logger.warn(
+          LocalizedMessage.create(
+              LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_FOR_OPERATION_0, "getMembers"),
+          e);
-    
+
-   * Returns information including ObjectNames for all regions on a member with
-   * given member id.
+   * Returns information including ObjectNames for all regions on a member with given member id.
-   * @param memberId
-   *          member identifier as a String
+   * @param memberId member identifier as a String
-   * @throws OperationsException
-   *           if fails to retrieve the regions information
+   * @throws OperationsException if fails to retrieve the regions information
-    
+
-            Map<String, ObjectName> existingRegionMbeans = getExistingRegionMbeansFullPaths(memberId);
-            //TODO: this is in-efficient
-            //Can a region.create JMX notification be used?
+            Map<String, ObjectName> existingRegionMbeans =
+                getExistingRegionMbeansFullPaths(memberId);
+            // TODO: this is in-efficient
+            // Can a region.create JMX notification be used?
-        logger.warn(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_FOR_OPERATION_0_FOR_MEMBER_1, new Object[]{"getRegions", memberId}), e);
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_FOR_OPERATION_0_FOR_MEMBER_1,
+            new Object[] {"getRegions", memberId}), e);
-        logger.warn(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_FOR_OPERATION_0_FOR_MEMBER_1, new Object[]{"getRegions", memberId}), e);
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_FOR_OPERATION_0_FOR_MEMBER_1,
+            new Object[] {"getRegions", memberId}), e);
-    
+
-  
+
-        //Members are already inited after connectToSystem. Now init Cache, Region & Stats MBeans
+        // Members are already inited after connectToSystem. Now init Cache, Region & Stats MBeans
-            initializeCacheRegionsAndStats((SystemMemberJmx)cacheVms[i]);
+            initializeCacheRegionsAndStats((SystemMemberJmx) cacheVms[i]);
-            logger.info(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INTIALIZING_0_CONTINUING, 
-                           cacheVms[i].getId()), e);
+            logger.info(LocalizedMessage.create(
+                LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INTIALIZING_0_CONTINUING,
+                cacheVms[i].getId()), e);
-            initializeCacheRegionsAndStats((SystemMemberJmx)appVms[i]);
+            initializeCacheRegionsAndStats((SystemMemberJmx) appVms[i]);
-            logger.info(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INTIALIZING_0_CONTINUING, 
-                           appVms[i].getId()), e);
+            logger.info(LocalizedMessage.create(
+                LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INTIALIZING_0_CONTINUING,
+                appVms[i].getId()), e);
-      logger.warn(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INTIALIZING), e);
+      logger.warn(LocalizedMessage
+          .create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INTIALIZING), e);
-      logger.warn(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INTIALIZING), e);
+      logger.warn(LocalizedMessage
+          .create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INTIALIZING), e);
-    
+
-  
+
-   * @param memberJmx
-   *          Member Mbean instance
-   * @throws OperationsException
-   *           if fails to initialize required MBeans
-   * @throws AdminException
-   *           if fails to initialize required MBeans
+   * @param memberJmx Member Mbean instance
+   * @throws OperationsException if fails to initialize required MBeans
+   * @throws AdminException if fails to initialize required MBeans
-  private void initializeCacheRegionsAndStats(SystemMemberJmx memberJmx) 
-    throws OperationsException, AdminException {
+  private void initializeCacheRegionsAndStats(SystemMemberJmx memberJmx)
+      throws OperationsException, AdminException {
-   * @param memberJmx
-   *          Member Mbean instance
-   * @throws AdminException
-   *           if fails to initialize required statistic MBeans
+   * @param memberJmx Member Mbean instance
+   * @throws AdminException if fails to initialize required statistic MBeans
-   * Initializes all regions & its subregions using the Cache MBean and the
-   * RegionSubRegionSnapshot for this cache MBean.
+   * Initializes all regions & its subregions using the Cache MBean and the RegionSubRegionSnapshot
+   * for this cache MBean.
-   * @param cache
-   *          Cache MBean resource
-   * @param regionSnapshot
-   *          RegionSubRegionSnapshot instance for the cache
-   * @throws MalformedObjectNameException
-   *           if fails to initialize the region MBean
-   * @throws AdminException
-   *           if fails to initialize the region MBean
+   * @param cache Cache MBean resource
+   * @param regionSnapshot RegionSubRegionSnapshot instance for the cache
+   * @throws MalformedObjectNameException if fails to initialize the region MBean
+   * @throws AdminException if fails to initialize the region MBean
-  private void initializeRegionSubRegions(SystemMemberCacheJmxImpl cache, 
-                                 RegionSubRegionSnapshot regionSnapshot) 
-                                   throws MalformedObjectNameException, 
-                                          AdminException {
+  private void initializeRegionSubRegions(SystemMemberCacheJmxImpl cache,
+      RegionSubRegionSnapshot regionSnapshot) throws MalformedObjectNameException, AdminException {
-      fullPath = fullPath.substring(PLACE_HOLDER_ROOT_REGION.length()-1);
+      fullPath = fullPath.substring(PLACE_HOLDER_ROOT_REGION.length() - 1);
-    
+
-    
+
-        logger.info(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INTIALIZING_0_CONTINUING, subRegion.getFullPath()), e);
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INTIALIZING_0_CONTINUING,
+            subRegion.getFullPath()), e);
-  
-  
+
+
-  
+
-   * NOTE -
-   * (My Understanding about the followings - abhishek)  
-   * 1. CacheVM - a VM started using Cache Server Launcher. This is considered 
-   * to be a dedicated cache VM because there is only GemFire Cache code 
-   * running here.
-   * 2. ApplicationVM - a VM started with a written code using APIs and we can 
-   * not guarantee that there will be ONLY GemFire code running in this VM.
-   * 3. Cache Server - Responsible for serving requests from the clients. There 
-   * could be multiple of these per Cache and hence per VM - one of 1 or 2 above.
-   * These could be specified by <cache-server> (or deprecated <bridge-server>)
-   * element(s) in the cache-xml file or using an API Cache.addCacheServer().
+   * NOTE - (My Understanding about the followings - abhishek) 1. CacheVM - a VM started using Cache
+   * Server Launcher. This is considered to be a dedicated cache VM because there is only GemFire
+   * Cache code running here. 2. ApplicationVM - a VM started with a written code using APIs and we
+   * can not guarantee that there will be ONLY GemFire code running in this VM. 3. Cache Server -
+   * Responsible for serving requests from the clients. There could be multiple of these per Cache
+   * and hence per VM - one of 1 or 2 above. These could be specified by <cache-server> (or
+   * deprecated <bridge-server>) element(s) in the cache-xml file or using an API
+   * Cache.addCacheServer().
-//  private static final String VERSION          = "gemfire.version.string";
-//  private static final String MEMBER_COUNT     = "gemfire.membercount.int";
-//  private static final String GATEWAYHUB_COUNT = "gemfire.gatewayhubcount.int";
-//  private static final String CLIENT_COUNT     = "gemfire.clientcount.int";
+  // private static final String VERSION = "gemfire.version.string";
+  // private static final String MEMBER_COUNT = "gemfire.membercount.int";
+  // private static final String GATEWAYHUB_COUNT = "gemfire.gatewayhubcount.int";
+  // private static final String CLIENT_COUNT = "gemfire.clientcount.int";
-  private static final String MEMBER_NAME = DistributionConfig.GEMFIRE_PREFIX + "member.name.string";
-  private static final String MEMBER_HOST = DistributionConfig.GEMFIRE_PREFIX + "member.host.string";
+  private static final String MEMBER_NAME =
+      DistributionConfig.GEMFIRE_PREFIX + "member.name.string";
+  private static final String MEMBER_HOST =
+      DistributionConfig.GEMFIRE_PREFIX + "member.host.string";
-  private static final String MEMBER_UPTIME = DistributionConfig.GEMFIRE_PREFIX + "member.uptime.long";
-  private static final String MEMBER_CLIENTS = DistributionConfig.GEMFIRE_PREFIX + "member.clients.map";
-  private static final String MEMBER_REGIONS = DistributionConfig.GEMFIRE_PREFIX + "member.regions.map";
-  private static final String MEMBER_TYPE = DistributionConfig.GEMFIRE_PREFIX + "member.type.string";
-  private static final String IS_SERVER = DistributionConfig.GEMFIRE_PREFIX + "member.isserver.boolean";
-  private static final String IS_GATEWAY = DistributionConfig.GEMFIRE_PREFIX + "member.isgateway.boolean";
+  private static final String MEMBER_UPTIME =
+      DistributionConfig.GEMFIRE_PREFIX + "member.uptime.long";
+  private static final String MEMBER_CLIENTS =
+      DistributionConfig.GEMFIRE_PREFIX + "member.clients.map";
+  private static final String MEMBER_REGIONS =
+      DistributionConfig.GEMFIRE_PREFIX + "member.regions.map";
+  private static final String MEMBER_TYPE =
+      DistributionConfig.GEMFIRE_PREFIX + "member.type.string";
+  private static final String IS_SERVER =
+      DistributionConfig.GEMFIRE_PREFIX + "member.isserver.boolean";
+  private static final String IS_GATEWAY =
+      DistributionConfig.GEMFIRE_PREFIX + "member.isgateway.boolean";
-  private static final String MEMBER_STATSAMPLING_ENABLED = DistributionConfig.GEMFIRE_PREFIX + "member.config.statsamplingenabled.boolean";
-  private static final String MEMBER_TIME_STATS_ENABLED = DistributionConfig.GEMFIRE_PREFIX + "member.config.timestatsenabled.boolean";
+  private static final String MEMBER_STATSAMPLING_ENABLED =
+      DistributionConfig.GEMFIRE_PREFIX + "member.config.statsamplingenabled.boolean";
+  private static final String MEMBER_TIME_STATS_ENABLED =
+      DistributionConfig.GEMFIRE_PREFIX + "member.config.timestatsenabled.boolean";
-  private static final String STATS_PROCESSCPUTIME = DistributionConfig.GEMFIRE_PREFIX + "member.stat.processcputime.long";
-  private static final String STATS_CPUS = DistributionConfig.GEMFIRE_PREFIX + "member.stat.cpus.int";
-  private static final String STATS_USEDMEMORY = DistributionConfig.GEMFIRE_PREFIX + "member.stat.usedmemory.long";
-  private static final String STATS_MAXMEMORY = DistributionConfig.GEMFIRE_PREFIX + "member.stat.maxmemory.long";
-  private static final String STATS_GETS = DistributionConfig.GEMFIRE_PREFIX + "member.stat.gets.int";
-  private static final String STATS_GETTIME = DistributionConfig.GEMFIRE_PREFIX + "member.stat.gettime.long";
-  private static final String STATS_PUTS = DistributionConfig.GEMFIRE_PREFIX + "member.stat.puts.int";
-  private static final String STATS_PUTTIME = DistributionConfig.GEMFIRE_PREFIX + "member.stat.puttime.long";
+  private static final String STATS_PROCESSCPUTIME =
+      DistributionConfig.GEMFIRE_PREFIX + "member.stat.processcputime.long";
+  private static final String STATS_CPUS =
+      DistributionConfig.GEMFIRE_PREFIX + "member.stat.cpus.int";
+  private static final String STATS_USEDMEMORY =
+      DistributionConfig.GEMFIRE_PREFIX + "member.stat.usedmemory.long";
+  private static final String STATS_MAXMEMORY =
+      DistributionConfig.GEMFIRE_PREFIX + "member.stat.maxmemory.long";
+  private static final String STATS_GETS =
+      DistributionConfig.GEMFIRE_PREFIX + "member.stat.gets.int";
+  private static final String STATS_GETTIME =
+      DistributionConfig.GEMFIRE_PREFIX + "member.stat.gettime.long";
+  private static final String STATS_PUTS =
+      DistributionConfig.GEMFIRE_PREFIX + "member.stat.puts.int";
+  private static final String STATS_PUTTIME =
+      DistributionConfig.GEMFIRE_PREFIX + "member.stat.puttime.long";
-  private static final String REGION_NAME = DistributionConfig.GEMFIRE_PREFIX + "region.name.string";
-  private static final String REGION_PATH = DistributionConfig.GEMFIRE_PREFIX + "region.path.string";
-  private static final String REGION_SCOPE = DistributionConfig.GEMFIRE_PREFIX + "region.scope.string";
-  private static final String REGION_DATAPOLICY = DistributionConfig.GEMFIRE_PREFIX + "region.datapolicy.string";
-  private static final String REGION_INTERESTPOLICY = DistributionConfig.GEMFIRE_PREFIX + "region.interestpolicy.string";
-  private static final String REGION_ENTRYCOUNT = DistributionConfig.GEMFIRE_PREFIX + "region.entrycount.int";
-  private static final String REGION_DISKATTRS = DistributionConfig.GEMFIRE_PREFIX + "region.diskattrs.string";
+  private static final String REGION_NAME =
+      DistributionConfig.GEMFIRE_PREFIX + "region.name.string";
+  private static final String REGION_PATH =
+      DistributionConfig.GEMFIRE_PREFIX + "region.path.string";
+  private static final String REGION_SCOPE =
+      DistributionConfig.GEMFIRE_PREFIX + "region.scope.string";
+  private static final String REGION_DATAPOLICY =
+      DistributionConfig.GEMFIRE_PREFIX + "region.datapolicy.string";
+  private static final String REGION_INTERESTPOLICY =
+      DistributionConfig.GEMFIRE_PREFIX + "region.interestpolicy.string";
+  private static final String REGION_ENTRYCOUNT =
+      DistributionConfig.GEMFIRE_PREFIX + "region.entrycount.int";
+  private static final String REGION_DISKATTRS =
+      DistributionConfig.GEMFIRE_PREFIX + "region.diskattrs.string";
-  private static final String CLIENT_NAME = DistributionConfig.GEMFIRE_PREFIX + "client.name.string";
-  private static final String CLIENT_HOST = DistributionConfig.GEMFIRE_PREFIX + "client.host.string";
-  private static final String CLIENT_QUEUESIZE = DistributionConfig.GEMFIRE_PREFIX + "client.queuesize.int";
-  private static final String CLIENT_STATS_GETS = DistributionConfig.GEMFIRE_PREFIX + "client.stats.gets.int";
-  private static final String CLIENT_STATS_PUTS = DistributionConfig.GEMFIRE_PREFIX + "client.stats.puts.int";
-  private static final String CLIENT_STATS_CACHEMISSES = DistributionConfig.GEMFIRE_PREFIX + "client.stats.cachemisses.int";
-  private static final String CLIENT_STATS_CPUUSAGE = DistributionConfig.GEMFIRE_PREFIX + "client.stats.cpuusage.long";
-  private static final String CLIENT_STATS_CPUS = DistributionConfig.GEMFIRE_PREFIX + "client.stats.cpus.int";
-  private static final String CLIENT_STATS_UPDATETIME = DistributionConfig.GEMFIRE_PREFIX + "client.stats.updatetime.long";
-  private static final String CLIENT_STATS_THREADS = DistributionConfig.GEMFIRE_PREFIX + "client.stats.threads.int";
-  
+  private static final String CLIENT_NAME =
+      DistributionConfig.GEMFIRE_PREFIX + "client.name.string";
+  private static final String CLIENT_HOST =
+      DistributionConfig.GEMFIRE_PREFIX + "client.host.string";
+  private static final String CLIENT_QUEUESIZE =
+      DistributionConfig.GEMFIRE_PREFIX + "client.queuesize.int";
+  private static final String CLIENT_STATS_GETS =
+      DistributionConfig.GEMFIRE_PREFIX + "client.stats.gets.int";
+  private static final String CLIENT_STATS_PUTS =
+      DistributionConfig.GEMFIRE_PREFIX + "client.stats.puts.int";
+  private static final String CLIENT_STATS_CACHEMISSES =
+      DistributionConfig.GEMFIRE_PREFIX + "client.stats.cachemisses.int";
+  private static final String CLIENT_STATS_CPUUSAGE =
+      DistributionConfig.GEMFIRE_PREFIX + "client.stats.cpuusage.long";
+  private static final String CLIENT_STATS_CPUS =
+      DistributionConfig.GEMFIRE_PREFIX + "client.stats.cpus.int";
+  private static final String CLIENT_STATS_UPDATETIME =
+      DistributionConfig.GEMFIRE_PREFIX + "client.stats.updatetime.long";
+  private static final String CLIENT_STATS_THREADS =
+      DistributionConfig.GEMFIRE_PREFIX + "client.stats.threads.int";
+
-   * @return All the required details for a member with given memberId 
+   * @return All the required details for a member with given memberId
-  public Map<String, Object> getMemberDetails(String memberId) 
-    throws OperationsException {
+  public Map<String, Object> getMemberDetails(String memberId) throws OperationsException {
-          GemFireMemberStatus snapshot   = cache.getSnapshot();
-          boolean isServer     = snapshot.getIsServer();
+          GemFireMemberStatus snapshot = cache.getSnapshot();
+          boolean isServer = snapshot.getIsServer();
-          
-          //1. Member info
+
+          // 1. Member info
-          String host = member.getHost();//from of GemFireVM.getHost
+          String host = member.getHost();// from of GemFireVM.getHost
-          //possibility of null host address
+          // possibility of null host address
-          
+
-          } else {//Mark it of Application type if neither a gateway hub nor a server
+          } else {// Mark it of Application type if neither a gateway hub nor a server
-//          if (isGatewayHub) {
-//            memberType = TYPE_NAME_GATEWAYHUB;
-//          } else if (isServer) {
-//            memberType = TYPE_NAME_CACHESERVER;
-//          } else {//Mark it of Application type if neither a gateway nor a server
-//            memberType = TYPE_NAME_APPLICATION;
-//          }
+          // if (isGatewayHub) {
+          // memberType = TYPE_NAME_GATEWAYHUB;
+          // } else if (isServer) {
+          // memberType = TYPE_NAME_CACHESERVER;
+          // } else {//Mark it of Application type if neither a gateway nor a server
+          // memberType = TYPE_NAME_APPLICATION;
+          // }
-          //2. Region info
+          // 2. Region info
-          //3. Clients info
+          // 3. Clients info
-          
+
-          //assuming will never return as per current implementation
+          // assuming will never return as per current implementation
-              statSamplingEnabled = Boolean.parseBoolean(""+configParam.getValue());
+              statSamplingEnabled = Boolean.parseBoolean("" + configParam.getValue());
-          
-          //5. Stats info
+
+          // 5. Stats info
-          //attempt refreshing the cache info once
+          // attempt refreshing the cache info once
-             * Taking the first cache server port.
-             * We don't recommend multiple cache severs for a cache.
+             * Taking the first cache server port. We don't recommend multiple cache severs for a
+             * cache.
-        
+
-        logger.warn(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_FOR_OPERATION_0_FOR_MEMBER_1, 
-                          new Object[] {"getMemberDetails", memberId}), e);
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_FOR_OPERATION_0_FOR_MEMBER_1,
+            new Object[] {"getMemberDetails", memberId}), e);
-        logger.warn(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_FOR_OPERATION_0_FOR_MEMBER_1, 
-                          new Object[] {"getMemberDetails", memberId}), e);
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_FOR_OPERATION_0_FOR_MEMBER_1,
+            new Object[] {"getMemberDetails", memberId}), e);
-    
+
-  
+
-   * @return Map of client details 
+   * @return Map of client details
-    Map<String, Map<String, ?>> clientsInfo = 
-      new LinkedHashMap<String, Map<String, ?>>();
-    
+    Map<String, Map<String, ?>> clientsInfo = new LinkedHashMap<String, Map<String, ?>>();
+
-      
+
-        String host     = snapshot.getClientHostName(clientId);
+        String host = snapshot.getClientHostName(clientId);
-  
-        ClientHealthStats clientHealthStats = (ClientHealthStats) clientHealthStatsMap.get(clientId);
+
+        ClientHealthStats clientHealthStats =
+            (ClientHealthStats) clientHealthStatsMap.get(clientId);
-        
+
-    
+
-   * @param cache
-   *          Reference to an MBean representing a Cache on a member
-   * @param existingRegionMbeans
-   *          Map of Path against Region MBean ObjectNames
+   * @param cache Reference to an MBean representing a Cache on a member
+   * @param existingRegionMbeans Map of Path against Region MBean ObjectNames
-   * @throws OperationsException
-   *           if fails to retrieve
+   * @throws OperationsException if fails to retrieve
-  private Map<String, Map<String, ?>> getAllRegionsDetails(
-                                  SystemMemberCacheJmxImpl cache, 
-                                  Map<String, ObjectName> existingRegionMbeans) 
-                                  throws OperationsException {
-    Map<String, Map<String, ?>> regionsInfo = 
-                        new TreeMap<String, Map<String, ?>>();
-    
+  private Map<String, Map<String, ?>> getAllRegionsDetails(SystemMemberCacheJmxImpl cache,
+      Map<String, ObjectName> existingRegionMbeans) throws OperationsException {
+    Map<String, Map<String, ?>> regionsInfo = new TreeMap<String, Map<String, ?>>();
+
-        logger.warn(LocalizedMessage.create(LocalizedStrings.ONE_ARG, "Exception occurred while getting region details."), e);
+        logger.warn(LocalizedMessage.create(LocalizedStrings.ONE_ARG,
+            "Exception occurred while getting region details."), e);
-        logger.warn(LocalizedMessage.create(LocalizedStrings.ONE_ARG, "Exception occurred while getting region details."), e);
+        logger.warn(LocalizedMessage.create(LocalizedStrings.ONE_ARG,
+            "Exception occurred while getting region details."), e);
-    
+
-   * Collects all the region details from the RegionSubRegionSnapshot instance
-   * passed and the Cache MBean. Checks in the set of existingRegionMbeans
-   * before initializing Region Mbeans if there are not initialized yet.
+   * Collects all the region details from the RegionSubRegionSnapshot instance passed and the Cache
+   * MBean. Checks in the set of existingRegionMbeans before initializing Region Mbeans if there are
+   * not initialized yet.
-   * @param cache
-   *          Cache MBean instance
-   * @param regionSnapshot
-   *          RegionSubRegionSnapshot instance
-   * @param regionsInfo
-   *          Map of regions information that gets populated recursively
-   * @param existingRegionMbeans
-   *          Map of ObjectNames of existing region MBeans
-   * @throws AdminException
-   *           if unable to initialize region MBean
-   * @throws OperationsException
-   *           if fails to retrieve the Region MBean attribute info
-   * @throws MBeanException
-   *           if fails to retrieve the Region MBean attribute info
-   * @throws ReflectionException
-   *           if fails to retrieve the Region MBean attribute info
+   * @param cache Cache MBean instance
+   * @param regionSnapshot RegionSubRegionSnapshot instance
+   * @param regionsInfo Map of regions information that gets populated recursively
+   * @param existingRegionMbeans Map of ObjectNames of existing region MBeans
+   * @throws AdminException if unable to initialize region MBean
+   * @throws OperationsException if fails to retrieve the Region MBean attribute info
+   * @throws MBeanException if fails to retrieve the Region MBean attribute info
+   * @throws ReflectionException if fails to retrieve the Region MBean attribute info
-  private void collectAllRegionsDetails(SystemMemberCacheJmxImpl cache, 
-                                 RegionSubRegionSnapshot regionSnapshot, 
-                                 Map<String, Map<String, ?>> regionsInfo,
-                                 Map<String, ObjectName> existingRegionMbeans) 
-                                 throws AdminException, OperationsException, 
-                                        MBeanException, ReflectionException {
+  private void collectAllRegionsDetails(SystemMemberCacheJmxImpl cache,
+      RegionSubRegionSnapshot regionSnapshot, Map<String, Map<String, ?>> regionsInfo,
+      Map<String, ObjectName> existingRegionMbeans)
+      throws AdminException, OperationsException, MBeanException, ReflectionException {
-      fullPath = fullPath.substring(PLACE_HOLDER_ROOT_REGION.length()-1);
+      fullPath = fullPath.substring(PLACE_HOLDER_ROOT_REGION.length() - 1);
-      
+
-      if (regionObjectName == null) {//initialize if has not yet been 
+      if (regionObjectName == null) {// initialize if has not yet been
-      
+
-      SubscriptionAttributes interestPolicyAttr = 
-          (SubscriptionAttributes) getAttribute(regionObjectName, 
-                                                "subscriptionAttributes", null);
+      SubscriptionAttributes interestPolicyAttr =
+          (SubscriptionAttributes) getAttribute(regionObjectName, "subscriptionAttributes", null);
-      
+
-    
+
-    
+
-  
+
-   * @param host
-   *          host name string
+   * @param host host name string
-   * Checks if the given host name is actually a String representation of an
-   * IPv4 address.
+   * Checks if the given host name is actually a String representation of an IPv4 address.
-   * @param host
-   *          host name string
-   * @return true if given host name is a String representation of an IPv4
-   *         address, false otherwise
+   * @param host host name string
+   * @return true if given host name is a String representation of an IPv4 address, false otherwise
-    
+
-  
+
-   * Excludes the host name from the client id and returns the String. If the
-   * host name can not be detected, returns an empty string. Typically, the
-   * client id looks like: HOST(VM_PID:VM_KIND):PORT:RANDOM_STRING:CLIENT_NAME
+   * Excludes the host name from the client id and returns the String. If the host name can not be
+   * detected, returns an empty string. Typically, the client id looks like:
+   * HOST(VM_PID:VM_KIND):PORT:RANDOM_STRING:CLIENT_NAME
-   * Extracts the client name from the client id. If the client id is not in the
-   * expected format, returns 'N/A'
+   * Extracts the client name from the client id. If the client id is not in the expected format,
+   * returns 'N/A'
-   * @param clientId
-   *          string identifier for a client
-   * @param host
-   *          host name (FQDN) the client is running on
+   * @param clientId string identifier for a client
+   * @param host host name (FQDN) the client is running on
-   * Some examples of Client Id format: 
-   * (1) Java Client:
-   * nase(21716:loner):51789:42e9a0bf:client_nase_21716
-   * nase(2560:loner):2:7a84729a:Feeder
+   * Some examples of Client Id format: (1) Java Client:
+   * nase(21716:loner):51789:42e9a0bf:client_nase_21716 nase(2560:loner):2:7a84729a:Feeder
-   * (2) Native Client:
-   * nase(21045:loner):2:GFNative_OnNnEpyRWL:ExampleDistributedSystem
+   * (2) Native Client: nase(21045:loner):2:GFNative_OnNnEpyRWL:ExampleDistributedSystem
-   * fdf0:76cf:a0ed:9449:0:0:0:1001:51789:42e9a0b:client_nase_21716 
+   * fdf0:76cf:a0ed:9449:0:0:0:1001:51789:42e9a0b:client_nase_21716
-    /* This isIPv6, isIPv4, extractClientName is taken from GFMon code base*/
+    /* This isIPv6, isIPv4, extractClientName is taken from GFMon code base */
-    if ( (isIPv6(host) || isIPv4(host))&& clientId.startsWith(host)) {
+    if ((isIPv6(host) || isIPv4(host)) && clientId.startsWith(host)) {
-    
+
-    String regex             = "(\\<ec\\>)?:[0-9]+(:\\w+){2}+";
-    String name              = NOT_AVAILABLE;
-    String temp              = hostExcludedId;
+    String regex = "(\\<ec\\>)?:[0-9]+(:\\w+){2}+";
+    String name = NOT_AVAILABLE;
+    String temp = hostExcludedId;
-    if (openIndex != -1) {      
+    if (openIndex != -1) {
-    
+
-   * Returns a Map of all the statistics required for Hyperic currently. It
-   * relies on the attribute of the StatisticsResource Mbeans.
+   * Returns a Map of all the statistics required for Hyperic currently. It relies on the attribute
+   * of the StatisticsResource Mbeans.
-   * @param member
-   *          instance for which the stats are needed
+   * @param member instance for which the stats are needed
-   * @throws OperationsException
-   *           exceptions thrown while retrieving the attributes
+   * @throws OperationsException exceptions thrown while retrieving the attributes
-  private Map<String, Object> getRequiredStats(SystemMemberJmx member, boolean statSamplingEnabled) throws OperationsException {
+  private Map<String, Object> getRequiredStats(SystemMemberJmx member, boolean statSamplingEnabled)
+      throws OperationsException {
-    
+
-        Number defaultVal     = NOT_AVAILABLE_NUMBER;
+        Number defaultVal = NOT_AVAILABLE_NUMBER;
-        Number cpus           = defaultVal;
-        Number maxMemory      = defaultVal;
-        Number usedMemory     = defaultVal;
-        Number gets           = defaultVal;
-        Number getTime        = defaultVal;
-        Number puts           = defaultVal;
-        Number putTime        = defaultVal;
-        
+        Number cpus = defaultVal;
+        Number maxMemory = defaultVal;
+        Number usedMemory = defaultVal;
+        Number gets = defaultVal;
+        Number getTime = defaultVal;
+        Number puts = defaultVal;
+        Number putTime = defaultVal;
+
-        ObjectName[] vmStats            = getExistingStats(member.getId(), "vmStats");
-        ObjectName[] cachePerfStats     = getExistingStats(member.getId(), "cachePerfStats");
+        ObjectName[] vmStats = getExistingStats(member.getId(), "vmStats");
+        ObjectName[] cachePerfStats = getExistingStats(member.getId(), "cachePerfStats");
-          //if the StatisticResource MBeans are not created
+          // if the StatisticResource MBeans are not created
-        if(!needToReinit) {
+        if (!needToReinit) {
-           * To handle a case when the StatisticResource MBeans are created but 
-           * not registered with RefreshTimer. If VMMemoryUsageStats are 
-           * present, maxMemory should always be non-zero. */
-          for (int i = 0; i < vmMemoryUsageStats.length; i++) {//ideally there should be a single instance
+           * To handle a case when the StatisticResource MBeans are created but not registered with
+           * RefreshTimer. If VMMemoryUsageStats are present, maxMemory should always be non-zero.
+           */
+          for (int i = 0; i < vmMemoryUsageStats.length; i++) {// ideally there should be a single
+                                                               // instance
-            
-            if ("VMMemoryUsageStats".equals(type)) { //first instance that has Statistics Type name
-              maxMemory  = (Number) getAttribute(vmMemoryUsageStats[i], "maxMemory", defaultVal);
+
+            if ("VMMemoryUsageStats".equals(type)) { // first instance that has Statistics Type name
+              maxMemory = (Number) getAttribute(vmMemoryUsageStats[i], "maxMemory", defaultVal);
-          
-          needToReinit = 0 == maxMemory.longValue(); 
+
+          needToReinit = 0 == maxMemory.longValue();
-        if(needToReinit) {
-          logger.info(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_REINITIALIZING_STATS_FOR_0, member.getId()));
+        if (needToReinit) {
+          logger.info(LocalizedMessage.create(
+              LocalizedStrings.MemberInfoWithStatsMBean_REINITIALIZING_STATS_FOR_0,
+              member.getId()));
-          vmStats            = getExistingStats(member.getId(), "vmStats");
-          cachePerfStats     = getExistingStats(member.getId(), "cachePerfStats");
+          vmStats = getExistingStats(member.getId(), "vmStats");
+          cachePerfStats = getExistingStats(member.getId(), "cachePerfStats");
-        
-        for (int i = 0; i < vmMemoryUsageStats.length; i++) {//ideally there should be a single instance
+
+        for (int i = 0; i < vmMemoryUsageStats.length; i++) {// ideally there should be a single
+                                                             // instance
-          
-          if ("VMMemoryUsageStats".equals(type)) { //first instance that has Statistics Type name
-            maxMemory  = (Number) getAttribute(vmMemoryUsageStats[i], "maxMemory", defaultVal);
+
+          if ("VMMemoryUsageStats".equals(type)) { // first instance that has Statistics Type name
+            maxMemory = (Number) getAttribute(vmMemoryUsageStats[i], "maxMemory", defaultVal);
-        for (int i = 0; i < vmStats.length; i++) {//ideally there should be a single instance
+        for (int i = 0; i < vmStats.length; i++) {// ideally there should be a single instance
-          
-          if ("VMStats".equals(type)) { //first instance that has Statistics Type name
+
+          if ("VMStats".equals(type)) { // first instance that has Statistics Type name
-            cpus           = (Number) getAttribute(vmStats[i], "cpus", defaultVal);
+            cpus = (Number) getAttribute(vmStats[i], "cpus", defaultVal);
-        
-        for (int i = 0; i < cachePerfStats.length; i++) {//ideally there should be a single instance
+
+        for (int i = 0; i < cachePerfStats.length; i++) {// ideally there should be a single
+                                                         // instance
-          
-          if ("CachePerfStats".equals(type)) { //first instance that has Statistics Type name
-            gets    = (Number) getAttribute(cachePerfStats[i], "gets", defaultVal);
+
+          if ("CachePerfStats".equals(type)) { // first instance that has Statistics Type name
+            gets = (Number) getAttribute(cachePerfStats[i], "gets", defaultVal);
-            puts    = (Number) getAttribute(cachePerfStats[i], "puts", defaultVal);
+            puts = (Number) getAttribute(cachePerfStats[i], "puts", defaultVal);
-        
-        statDetails.put(STATS_PROCESSCPUTIME, processCpuTime == NOT_AVAILABLE_NUMBER ? NOT_AVAILABLE_NUMBER : processCpuTime.longValue());
-        statDetails.put(STATS_CPUS, cpus == NOT_AVAILABLE_NUMBER ? NOT_AVAILABLE_NUMBER : cpus.intValue());
-        statDetails.put(STATS_MAXMEMORY,  maxMemory == NOT_AVAILABLE_NUMBER ? NOT_AVAILABLE_NUMBER : maxMemory.longValue());
-        statDetails.put(STATS_USEDMEMORY, usedMemory == NOT_AVAILABLE_NUMBER ? NOT_AVAILABLE_NUMBER : usedMemory.longValue());
-        statDetails.put(STATS_GETS, gets == NOT_AVAILABLE_NUMBER ? NOT_AVAILABLE_NUMBER : gets.intValue());
-        statDetails.put(STATS_GETTIME, getTime == NOT_AVAILABLE_NUMBER ? NOT_AVAILABLE_NUMBER : getTime.intValue());
-        statDetails.put(STATS_PUTS, puts == NOT_AVAILABLE_NUMBER ? NOT_AVAILABLE_NUMBER : puts.intValue());
-        statDetails.put(STATS_PUTTIME, putTime == NOT_AVAILABLE_NUMBER ? NOT_AVAILABLE_NUMBER : putTime.longValue());
+
+        statDetails.put(STATS_PROCESSCPUTIME, processCpuTime == NOT_AVAILABLE_NUMBER
+            ? NOT_AVAILABLE_NUMBER : processCpuTime.longValue());
+        statDetails.put(STATS_CPUS,
+            cpus == NOT_AVAILABLE_NUMBER ? NOT_AVAILABLE_NUMBER : cpus.intValue());
+        statDetails.put(STATS_MAXMEMORY,
+            maxMemory == NOT_AVAILABLE_NUMBER ? NOT_AVAILABLE_NUMBER : maxMemory.longValue());
+        statDetails.put(STATS_USEDMEMORY,
+            usedMemory == NOT_AVAILABLE_NUMBER ? NOT_AVAILABLE_NUMBER : usedMemory.longValue());
+        statDetails.put(STATS_GETS,
+            gets == NOT_AVAILABLE_NUMBER ? NOT_AVAILABLE_NUMBER : gets.intValue());
+        statDetails.put(STATS_GETTIME,
+            getTime == NOT_AVAILABLE_NUMBER ? NOT_AVAILABLE_NUMBER : getTime.intValue());
+        statDetails.put(STATS_PUTS,
+            puts == NOT_AVAILABLE_NUMBER ? NOT_AVAILABLE_NUMBER : puts.intValue());
+        statDetails.put(STATS_PUTTIME,
+            putTime == NOT_AVAILABLE_NUMBER ? NOT_AVAILABLE_NUMBER : putTime.longValue());
-    
+
-   * @param objectName
-   *          ObjectName for the MBean
-   * @param attribute
-   *          attribute name
-   * @param unavailableValue
-   *          return this value if the attribute value is null
+   * @param objectName ObjectName for the MBean
+   * @param attribute attribute name
+   * @param unavailableValue return this value if the attribute value is null
-   * @throws OperationsException
-   *           if attribute is not found for MBean with this ObjectName or MBean
-   *           instance is not found
-   * @throws MBeanException
-   *           if MBeans getter throws exception
-   * @throws ReflectionException
-   *           thrown when trying to invoke the setter.
+   * @throws OperationsException if attribute is not found for MBean with this ObjectName or MBean
+   *         instance is not found
+   * @throws MBeanException if MBeans getter throws exception
+   * @throws ReflectionException thrown when trying to invoke the setter.
-  private Object getAttribute(ObjectName objectName, String attribute, 
-      Object unavailableValue) 
-        throws OperationsException, MBeanException, ReflectionException {
+  private Object getAttribute(ObjectName objectName, String attribute, Object unavailableValue)
+      throws OperationsException, MBeanException, ReflectionException {
-    
+
-    
-    value = (value != null)? value : unavailableValue;
-    
+
+    value = (value != null) ? value : unavailableValue;
+
-   * @param memberId
-   *          string identifier of a member
+   * @param memberId string identifier of a member
-   * @throws MalformedObjectNameException
-   *           If the query expression used is not valid
+   * @throws MalformedObjectNameException If the query expression used is not valid
-  private Map<String, ObjectName> getExistingRegionMbeansFullPaths(String memberId) throws MalformedObjectNameException {
+  private Map<String, ObjectName> getExistingRegionMbeansFullPaths(String memberId)
+      throws MalformedObjectNameException {
-    
+
-   * @param memberId
-   *          string identifier of a member
-   * @param name
-   *          text id of the stats which appears in the stats ObjectName as name
-   *          keyProperty
+   * @param memberId string identifier of a member
+   * @param name text id of the stats which appears in the stats ObjectName as name keyProperty
-   * @throws MalformedObjectNameException
-   *           If the query expression used is not valid
+   * @throws MalformedObjectNameException If the query expression used is not valid
-  private ObjectName[] getExistingStats(String memberId, String name) throws MalformedObjectNameException {
+  private ObjectName[] getExistingStats(String memberId, String name)
+      throws MalformedObjectNameException {
-    
+
-    
+
-   * Queries the MBean server with the string formed using placing the params in
-   * the parameterized string passed as queryStr.
+   * Queries the MBean server with the string formed using placing the params in the parameterized
+   * string passed as queryStr.
-   * @param queryStr
-   *          parameterized string
-   * @param params
-   *          params to put in the string
+   * @param queryStr parameterized string
+   * @param params params to put in the string
-   * @throws MalformedObjectNameException
-   *           If the query expression ObjectName formed is not valid
+   * @throws MalformedObjectNameException If the query expression ObjectName formed is not valid
-  private Set<ObjectName> queryObjectNames(String queryStr, Object ... params) 
-    throws MalformedObjectNameException {
-    Set<ObjectName> queried = Collections.emptySet();    
-    
-    queryStr = MessageFormat.format(queryStr, params);    
+  private Set<ObjectName> queryObjectNames(String queryStr, Object... params)
+      throws MalformedObjectNameException {
+    Set<ObjectName> queried = Collections.emptySet();
+
+    queryStr = MessageFormat.format(queryStr, params);
-    
+
-  
-  
+
+
-   * @see NotificationEmitter#addNotificationListener(NotificationListener, NotificationFilter, Object)
+   * @see NotificationEmitter#addNotificationListener(NotificationListener, NotificationFilter,
+   *      Object)
-  public void addNotificationListener(NotificationListener listener,
-      NotificationFilter filter, Object handback)
-      throws IllegalArgumentException {
+  public void addNotificationListener(NotificationListener listener, NotificationFilter filter,
+      Object handback) throws IllegalArgumentException {
-  
+
-   * @see NotificationEmitter#removeNotificationListener(NotificationListener, NotificationFilter, Object)
+   * @see NotificationEmitter#removeNotificationListener(NotificationListener, NotificationFilter,
+   *      Object)
-  public void removeNotificationListener(NotificationListener listener,
-      NotificationFilter filter, Object handback)
-      throws ListenerNotFoundException {
+  public void removeNotificationListener(NotificationListener listener, NotificationFilter filter,
+      Object handback) throws ListenerNotFoundException {
-  
+
+
- * This class acts as a hub for the Notifications defined on
- * AdminDistributedSystem & SystemMember MBeans. This acts as a listener for
- * these notifications and broadcasts them as notifications from the
- * {@link MemberInfoWithStatsMBean} MBean. This class extends
- * {@link NotificationBroadcasterSupport} only to have the functionality to send
- * notifications.
+ * This class acts as a hub for the Notifications defined on AdminDistributedSystem & SystemMember
+ * MBeans. This acts as a listener for these notifications and broadcasts them as notifications from
+ * the {@link MemberInfoWithStatsMBean} MBean. This class extends
+ * {@link NotificationBroadcasterSupport} only to have the functionality to send notifications.
-class NotificationForwarder extends NotificationBroadcasterSupport 
-  implements NotificationListener {
-  
+class NotificationForwarder extends NotificationBroadcasterSupport implements NotificationListener {
+
-  
+
-  private MBeanServer   mBeanServer;
+  private MBeanServer mBeanServer;
-   * @param mBeanServer
-   *          reference to the MBeanServer instance
+   * @param mBeanServer reference to the MBeanServer instance
-  /*default*/NotificationForwarder(MBeanServer mBeanServer) {
+  /* default */ NotificationForwarder(MBeanServer mBeanServer) {
-   * Handles notifications as: 1. Member Joined: Registers this
-   * NotificationForwarder as a notification listener for Cache/Region
-   * Notifications. 2. Member Left/Crashed: Unregisters this
-   * NotificationForwarder as a notification listener for Cache/Region
-   * Notifications. 3. AdminDistributedSystem Disconnected: Unregisters this
-   * NotificationForwarder as a notification listener for member Notifications.
+   * Handles notifications as: 1. Member Joined: Registers this NotificationForwarder as a
+   * notification listener for Cache/Region Notifications. 2. Member Left/Crashed: Unregisters this
+   * NotificationForwarder as a notification listener for Cache/Region Notifications. 3.
+   * AdminDistributedSystem Disconnected: Unregisters this NotificationForwarder as a notification
+   * listener for member Notifications.
-   * Forwards the notifications to the JMX Clients that have registered for
-   * notifications on this MBean
+   * Forwards the notifications to the JMX Clients that have registered for notifications on this
+   * MBean
-   * @param notification
-   *          notification to be handled
-   * @param handback
-   *          handback object used while NotificationForwarder was registered
+   * @param notification notification to be handled
+   * @param handback handback object used while NotificationForwarder was registered
-      //initialize statistics/register with refreshTimer for new member
+      // initialize statistics/register with refreshTimer for new member
-        ObjectName[] stats = (ObjectName[]) mBeanServer.invoke(source, "manageStats", noArgs, noArgs);
+        ObjectName[] stats =
+            (ObjectName[]) mBeanServer.invoke(source, "manageStats", noArgs, noArgs);
-        logger.info(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INITIALIZING_STATISICS_FOR_0, source.toString()), e);
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INITIALIZING_STATISICS_FOR_0,
+            source.toString()), e);
-        logger.info(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INITIALIZING_STATISICS_FOR_0, source.toString()), e);
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INITIALIZING_STATISICS_FOR_0,
+            source.toString()), e);
-        logger.info(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INITIALIZING_STATISICS_FOR_0, source.toString()), e);
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_INITIALIZING_STATISICS_FOR_0,
+            source.toString()), e);
-      //register this listener for joined member's cache/region notifications
+      // register this listener for joined member's cache/region notifications
-        logger.info(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_REGISTERING_NOTIFICATION_LISTENER_FOR_0, source.toString()), e);
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_REGISTERING_NOTIFICATION_LISTENER_FOR_0,
+            source.toString()), e);
-    } /*else if (AdminDistributedSystemJmxImpl.NOTIF_MEMBER_LEFT.equals(notification.getType()) || 
-               AdminDistributedSystemJmxImpl.NOTIF_MEMBER_CRASHED.equals(notification.getType())) {
-      ObjectName source = (ObjectName) notifSource;
-      //unregister this listener from left member's cache/region notifications
-      try {
-        unregisterNotificationListener(source);
-      } catch (OperationsException e) {
-        logwriter.info(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_UNREGISTERING_NOTIFICATION_LISTENER_FOR_0, source.toString(), e);
-      }
-    } else if (AdminDistributedSystemJmxImpl.NOTIF_ADMIN_SYSTEM_DISCONNECT.equals(notification.getType())) {
-      String source = (String) notifSource;
-      //This notification does not have ObjectName as a source. 
-      try {
-        ObjectName instance = ObjectName.getInstance(source);
-        unregisterNotificationListener(instance);
-      } catch (OperationsException e) {
-        logwriter.info(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_UNREGISTERING_NOTIFICATION_LISTENER_FOR_0, source.toString(), e);
-      } catch (NullPointerException e) {
-        logwriter.info(LocalizedMessage.create(LocalizedStrings.MemberInfoWithStatsMBean_EXCEPTION_WHILE_UNREGISTERING_NOTIFICATION_LISTENER_FOR_0, source.toString(), e);
-      }
-    } */
-    //NOTIF_ALERT is sent as is
-    
-    //TODO: Check if same notification instance can be reused by simply changing the sequence number 
-    notification = new Notification(notification.getType(), notifSource, 
-                                    notificationSequenceNumber.addAndGet(1L), 
-                                    notification.getTimeStamp(), 
-                                    notification.getMessage());
-    
+    } /*
+       * else if (AdminDistributedSystemJmxImpl.NOTIF_MEMBER_LEFT.equals(notification.getType()) ||
+       * AdminDistributedSystemJmxImpl.NOTIF_MEMBER_CRASHED.equals(notification.getType())) {
+       * ObjectName source = (ObjectName) notifSource; //unregister this listener from left member's
+       * cache/region notifications try { unregisterNotificationListener(source); } catch
+       * (OperationsException e) { logwriter.info(LocalizedMessage.create(LocalizedStrings.
+       * MemberInfoWithStatsMBean_EXCEPTION_WHILE_UNREGISTERING_NOTIFICATION_LISTENER_FOR_0,
+       * source.toString(), e); } } else if
+       * (AdminDistributedSystemJmxImpl.NOTIF_ADMIN_SYSTEM_DISCONNECT.equals(notification.getType())
+       * ) { String source = (String) notifSource; //This notification does not have ObjectName as a
+       * source. try { ObjectName instance = ObjectName.getInstance(source);
+       * unregisterNotificationListener(instance); } catch (OperationsException e) {
+       * logwriter.info(LocalizedMessage.create(LocalizedStrings.
+       * MemberInfoWithStatsMBean_EXCEPTION_WHILE_UNREGISTERING_NOTIFICATION_LISTENER_FOR_0,
+       * source.toString(), e); } catch (NullPointerException e) {
+       * logwriter.info(LocalizedMessage.create(LocalizedStrings.
+       * MemberInfoWithStatsMBean_EXCEPTION_WHILE_UNREGISTERING_NOTIFICATION_LISTENER_FOR_0,
+       * source.toString(), e); } }
+       */
+    // NOTIF_ALERT is sent as is
+
+    // TODO: Check if same notification instance can be reused by simply changing the sequence
+    // number
+    notification = new Notification(notification.getType(), notifSource,
+        notificationSequenceNumber.addAndGet(1L), notification.getTimeStamp(),
+        notification.getMessage());
+
-   * Registers itself as a NotificationListener for Notifications sent from
-   * MBean with the ObjectName given as source.
+   * Registers itself as a NotificationListener for Notifications sent from MBean with the
+   * ObjectName given as source.
-   * @param source
-   *          source of notifications
-   * @throws InstanceNotFoundException
-   *           The MBean name provided does not match any of the registered
-   *           MBeans.
+   * @param source source of notifications
+   * @throws InstanceNotFoundException The MBean name provided does not match any of the registered
+   *         MBeans.
-  /*default*/void registerNotificationListener(ObjectName source) 
-    throws InstanceNotFoundException {
-    mBeanServer.addNotificationListener(source, this, null/*handback*/, source);
+  /* default */void registerNotificationListener(ObjectName source)
+      throws InstanceNotFoundException {
+    mBeanServer.addNotificationListener(source, this, null/* handback */, source);
-   * Unregisters itself as a NotificationListener for Notifications sent from
-   * MBean with the ObjectName given as source.
+   * Unregisters itself as a NotificationListener for Notifications sent from MBean with the
+   * ObjectName given as source.
-   * @throws InstanceNotFoundException
-   *           The MBean name provided does not match any of the registered
-   *           MBeans.
-   * @throws ListenerNotFoundException
-   *           The listener is not registered in the MBean.
+   * @throws InstanceNotFoundException The MBean name provided does not match any of the registered
+   *         MBeans.
+   * @throws ListenerNotFoundException The listener is not registered in the MBean.
-  /*default*/void unregisterNotificationListener(ObjectName source) 
-    throws InstanceNotFoundException, ListenerNotFoundException {
+  /* default */void unregisterNotificationListener(ObjectName source)
+      throws InstanceNotFoundException, ListenerNotFoundException {

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
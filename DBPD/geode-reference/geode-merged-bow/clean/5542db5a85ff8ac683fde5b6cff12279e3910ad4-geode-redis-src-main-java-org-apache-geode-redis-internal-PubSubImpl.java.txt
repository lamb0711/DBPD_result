GEODE-7998: Do not block Netty threads when publishing (#5042)

- Now delegate PUBLISH responses to a background executor in order to
  free up the Netty worker thread. This prevents possible deadlocks.

Co-authored-by: Murtuza Boxwala <mboxwala@vmware.com>
Co-authored-by: Ray Ingles <ringles@vmware.com>
Co-authored-by: Jens Deppe <jdeppe@vmware.com>

-import java.util.Map;
-import java.util.stream.Collectors;
+
+import org.apache.logging.log4j.Logger;
+import org.apache.geode.logging.internal.log4j.api.LogService;
+  private static final Logger logger = LogService.getLogger();
+
-    List<Long> subscriberCounts = subscriberCountCollector.getResult();
+    List<Long> subscriberCounts = null;
+    try {
+      subscriberCounts = subscriberCountCollector.getResult();
+    } catch (Exception e) {
+      logger.warn("Failed to execute publish function {}", e.getMessage());
+      return 0;
+    }
+
+      /**
+       * Since the publish process uses an onMembers function call, we don't want to re-publish
+       * to members if one fails.
+       * TODO: Revisit this in the event that we instead use an onMember call against individual
+       * members.
+       */
+      @Override
+      public boolean isHA() {
+        return false;
+      }
-    Map<Boolean, List<PublishResult>> results = subscriptions
-        .findSubscriptions(channel)
-        .stream()
-        .map(subscription -> subscription.publishMessage(channel, message))
-        .collect(Collectors.partitioningBy(PublishResult::isSuccessful));
+    List<Subscription> foundSubscriptions = subscriptions
+        .findSubscriptions(channel);
+    if (foundSubscriptions.isEmpty()) {
+      return 0;
+    }
-    prune(results.get(false));
+    PublishResultCollector publishResultCollector =
+        new PublishResultCollector(foundSubscriptions.size(), subscriptions);
-    return results.get(true).size();
+    foundSubscriptions.forEach(
+        subscription -> subscription.publishMessage(channel, message, publishResultCollector));
+
+    return publishResultCollector.getSuccessCount();
-  private void prune(List<PublishResult> failedSubscriptions) {
-    failedSubscriptions.forEach(publishResult -> {
-      Client client = publishResult.getClient();
-      if (client.isDead()) {
-        subscriptions.remove(client);
-      }
-    });
-  }

MOV26 UPD40 UPD40 INS23 INS31 INS83 INS83 INS83 INS43 INS59 MOV78 INS39 INS42 MOV44 MOV44 INS8 UPD42 MOV42 INS42 INS32 INS54 INS60 INS25 INS60 MOV21 INS41 INS42 INS42 INS8 INS12 UPD74 MOV74 INS59 INS32 INS8 INS43 INS59 INS32 INS33 INS21 INS44 INS8 UPD43 INS42 MOV32 UPD42 MOV42 UPD42 MOV42 INS41 INS42 INS42 INS14 UPD42 INS42 INS42 INS7 INS43 INS42 INS21 INS41 UPD42 INS34 INS43 INS32 INS42 MOV59 INS32 INS42 MOV32 INS42 INS32 INS34 INS31 INS42 UPD42 MOV42 MOV42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 INS42 INS45 INS32 INS29 INS78 INS83 INS39 INS42 INS8 INS42 INS42 INS65 INS42 INS41 INS66 INS66 INS66 INS66 INS9 DEL42 DEL59 DEL42 DEL43 DEL42 DEL42 DEL32 DEL59 DEL60 DEL42 DEL32 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL39 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL74 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL86 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42 DEL90 DEL32 DEL32 DEL59 DEL60 DEL42 DEL42 DEL42 DEL9 DEL32 DEL32 DEL21 DEL42 DEL9 DEL32 DEL32 DEL41 DEL8 DEL31 DEL83 DEL39 DEL42 DEL42 DEL44 DEL8 DEL31
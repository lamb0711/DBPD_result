Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This proxy handler handles all the method call invoked on an MXBean It
- * follows same route as MBeanProxyInvocationHandler Only difference is after
- * obtaining the result it transforms the open type to the actual java type
+ * This proxy handler handles all the method call invoked on an MXBean It follows same route as
+ * MBeanProxyInvocationHandler Only difference is after obtaining the result it transforms the open
+ * type to the actual java type
-  private final Map<Method, MethodHandler> methodHandlerMap = OpenTypeUtil
-      .newMap();
+  private final Map<Method, MethodHandler> methodHandlerMap = OpenTypeUtil.newMap();
-  public MXBeanProxyInvocationHandler(ObjectName objectName,
-      Class<?> mxbeanInterface, MBeanProxyInvocationHandler proxyHandler)
-      throws Exception {
+  public MXBeanProxyInvocationHandler(ObjectName objectName, Class<?> mxbeanInterface,
+      MBeanProxyInvocationHandler proxyHandler) throws Exception {
-        methodHandlerMap
-            .put(m, new GetterHandler(attrName, OpenMethod.from(m)));
-      } else if (name.startsWith("set") && name.length() > 3
-          && m.getParameterTypes().length == 1
+        methodHandlerMap.put(m, new GetterHandler(attrName, OpenMethod.from(m)));
+      } else if (name.startsWith("set") && name.length() > 3 && m.getParameterTypes().length == 1
-        methodHandlerMap
-            .put(m, new SetterHandler(attrName, OpenMethod.from(m)));
+        methodHandlerMap.put(m, new SetterHandler(attrName, OpenMethod.from(m)));
-   * Eliminate methods that are overridden with a covariant return type.
-   * Reflection will return both the original and the overriding method but we
-   * need only the overriding one is of interest
+   * Eliminate methods that are overridden with a covariant return type. Reflection will return both
+   * the original and the overriding method but we need only the overriding one is of interest
-    final List<Method> methods = OpenTypeUtil.newList(Arrays
-        .asList(methodArray));
+    final List<Method> methods = OpenTypeUtil.newList(Arrays.asList(methodArray));
-   * A comparator that defines a total order so that methods have the same name
-   * and identical signatures appear next to each others. The methods are sorted
-   * in such a way that methods which override each other will sit next to each
-   * other, with the overridden method first - e.g. Object getFoo() is placed
-   * before Integer getFoo(). This makes it possible to determine whether a
-   * method overrides another one simply by looking at the method(s) that
-   * precedes it in the list. (see eliminateCovariantMethods).
+   * A comparator that defines a total order so that methods have the same name and identical
+   * signatures appear next to each others. The methods are sorted in such a way that methods which
+   * override each other will sit next to each other, with the overridden method first - e.g. Object
+   * getFoo() is placed before Integer getFoo(). This makes it possible to determine whether a
+   * method overrides another one simply by looking at the method(s) that precedes it in the list.
+   * (see eliminateCovariantMethods).
-    abstract Object invoke(Object proxy, Method method, Object[] args)
-        throws Throwable;
+    abstract Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
-      } else if (methodName.startsWith("is")
-          && method.getReturnType() == boolean.class) {
+      } else if (methodName.startsWith("is") && method.getReturnType() == boolean.class) {
-      return proxyHandler.delegateToFucntionService(objectName, methodName,
-          args, signature);
+      return proxyHandler.delegateToFucntionService(objectName, methodName, args, signature);
-      return proxyHandler.delegateToFucntionService(objectName, methodName,
-          args, signature);
+      return proxyHandler.delegateToFucntionService(objectName, methodName, args, signature);
-  public Object invoke(Object proxy, Method method, Object[] args)
-      throws Throwable {
+  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66
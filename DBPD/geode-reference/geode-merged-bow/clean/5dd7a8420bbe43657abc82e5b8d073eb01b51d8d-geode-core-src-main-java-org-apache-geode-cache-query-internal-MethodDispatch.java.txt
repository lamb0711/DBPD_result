GEODE-7756: Do not use authorization cache for CQs (#4677)

CQs are executed on individual entries whenever an event is triggered
for them and the execution context is always cleared before the actual
evaluation, thus using an internal cache to keep already authorized
methods is useless (will always be a cache miss and the computation
required just adds overhead).

- Fixed the CQ creation to always set the 'cqQueryContext' flag.
- Modified the query engine to avoid using the internal cache for
  already authorized methods when the context belongs to a CQ.
- Avoid the creation and concatenation of unnecessary Strings, using
  the Method class directly instead.
+import org.apache.geode.cache.query.security.MethodInvocationAuthorizer;
-      // Try to use cached result so authorizer gets invoked only once per query.
-      boolean authorizationResult;
-      String cacheKey = target.getClass().getCanonicalName() + "." + _method.getName();
-      Boolean cachedResult = (Boolean) executionContext.cacheGet(cacheKey);
+      MethodInvocationAuthorizer authorizer = executionContext.getMethodInvocationAuthorizer();
-      if (cachedResult != null) {
-        // Use cached result.
-        authorizationResult = cachedResult;
+      // CQs are generally executed on individual events, so caching is just an overhead.
+      if (executionContext.isCqQueryContext()) {
+        if (!authorizer.authorize(_method, target)) {
+          throw new NotAuthorizedException(UNAUTHORIZED_STRING + _method.getName());
+        }
-        // First time, evaluate and cache result.
-        authorizationResult =
-            executionContext.getMethodInvocationAuthorizer().authorize(_method, target);
-        executionContext.cachePut(cacheKey, authorizationResult);
-      }
+        // Try to use cached result so authorizer gets invoked only once per query.
+        boolean authorizationResult;
+        Boolean cachedResult = (Boolean) executionContext.cacheGet(_method);
-      if (!authorizationResult) {
-        throw new NotAuthorizedException(UNAUTHORIZED_STRING + _method.getName());
+        if (cachedResult != null) {
+          // Use cached result.
+          authorizationResult = cachedResult;
+        } else {
+          // First time, evaluate and cache result.
+          authorizationResult = authorizer.authorize(_method, target);
+          executionContext.cachePut(_method, authorizationResult);
+        }
+
+        if (!authorizationResult) {
+          throw new NotAuthorizedException(UNAUTHORIZED_STRING + _method.getName());
+        }

INS26 INS40 INS25 UPD43 INS32 INS8 INS8 UPD42 UPD42 MOV32 INS42 INS42 INS25 MOV60 MOV60 MOV25 MOV25 INS38 INS8 MOV43 INS32 INS53 INS42 INS42 INS42 INS42 INS14 MOV43 INS43 MOV27 UPD42 UPD42 INS42 INS42 INS42 DEL42 DEL42 DEL32 DEL42 DEL32 DEL45
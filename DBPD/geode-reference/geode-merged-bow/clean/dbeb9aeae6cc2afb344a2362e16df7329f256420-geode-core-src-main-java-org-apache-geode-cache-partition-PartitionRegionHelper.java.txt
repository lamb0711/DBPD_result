Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Utility methods for handling partitioned Regions, for example
- * during execution of {@link Function Functions} on a Partitioned
- * Region.
+ * Utility methods for handling partitioned Regions, for example during execution of {@link Function
+ * Functions} on a Partitioned Region.
- * <p>Example of a Function using utility methods:
+ * <p>
+ * Example of a Function using utility methods:
+ * 
-   * Given a partitioned Region, return a map of {@linkplain PartitionAttributesFactory#setColocatedWith(String) colocated Regions}.
-   * Given a local data reference to a partitioned region, return a map of local
-   * {@linkplain PartitionAttributesFactory#setColocatedWith(String) colocated Regions}.
-   * If there are no colocated regions, return an empty map.
+   * Given a partitioned Region, return a map of
+   * {@linkplain PartitionAttributesFactory#setColocatedWith(String) colocated Regions}. Given a
+   * local data reference to a partitioned region, return a map of local
+   * {@linkplain PartitionAttributesFactory#setColocatedWith(String) colocated Regions}. If there
+   * are no colocated regions, return an empty map.
+   * 
-   * @throws IllegalStateException if the Region is not a {@linkplain DataPolicy#PARTITION partitioned Region}
+   * @throws IllegalStateException if the Region is not a {@linkplain DataPolicy#PARTITION
+   *         partitioned Region}
-      final PartitionedRegion pr = (PartitionedRegion)r;
+      final PartitionedRegion pr = (PartitionedRegion) r;
-      LocalDataSet lds = (LocalDataSet)r;
+      LocalDataSet lds = (LocalDataSet) r;
-        ret = ColocationHelper.getColocatedLocalDataSetsForBuckets(lds.getProxy(), lds.getBucketSet());
+        ret = ColocationHelper.getColocatedLocalDataSetsForBuckets(lds.getProxy(),
+            lds.getBucketSet());
-    }
-    else {
+    } else {
-  
+
-  public static boolean isPartitionedRegion(final Region<?,?> r) {
+  public static boolean isPartitionedRegion(final Region<?, ?> r) {
-          LocalizedStrings.PartitionRegionHelper_ARGUMENT_REGION_IS_NULL
-              .toString());
+          LocalizedStrings.PartitionRegionHelper_ARGUMENT_REGION_IS_NULL.toString());
-    return r instanceof PartitionedRegion?true:false;
+    return r instanceof PartitionedRegion ? true : false;
-  
+
-  private static PartitionedRegion isPartitionedCheck(final Region<?,?> r) {
-    if (! isPartitionedRegion(r)) {
+  private static PartitionedRegion isPartitionedCheck(final Region<?, ?> r) {
+    if (!isPartitionedRegion(r)) {
-   * Gathers a set of details about all partitioned regions in the local Cache.
-   * If there are no partitioned regions then an empty set will be returned.
+   * Gathers a set of details about all partitioned regions in the local Cache. If there are no
+   * partitioned regions then an empty set will be returned.
-  public static Set<PartitionRegionInfo> getPartitionRegionInfo(
-      final Cache cache) {
-    Set<PartitionRegionInfo> prDetailsSet = 
-      new TreeSet<PartitionRegionInfo>();
+  public static Set<PartitionRegionInfo> getPartitionRegionInfo(final Cache cache) {
+    Set<PartitionRegionInfo> prDetailsSet = new TreeSet<PartitionRegionInfo>();
-   * Gathers details about the specified partitioned region. Returns null if
-   * the partitioned region is not locally defined.
+   * Gathers details about the specified partitioned region. Returns null if the partitioned region
+   * is not locally defined.
-  public static PartitionRegionInfo getPartitionRegionInfo(
-      final Region<?,?> region) {
+  public static PartitionRegionInfo getPartitionRegionInfo(final Region<?, ?> region) {
-      GemFireCacheImpl cache =  (GemFireCacheImpl) region.getCache();
-      return pr.getRedundancyProvider().buildPartitionedRegionInfo(
-          false, cache.getResourceManager().getLoadProbe()); // may return null
-    } 
-    catch (ClassCastException e) {
+      GemFireCacheImpl cache = (GemFireCacheImpl) region.getCache();
+      return pr.getRedundancyProvider().buildPartitionedRegionInfo(false,
+          cache.getResourceManager().getLoadProbe()); // may return null
+    } catch (ClassCastException e) {
-  
-  private static void fillInPartitionedRegionInfo(GemFireCacheImpl cache, final Set prDetailsSet, 
-                                              final boolean internal) {
+
+  private static void fillInPartitionedRegionInfo(GemFireCacheImpl cache, final Set prDetailsSet,
+      final boolean internal) {
-      PartitionRegionInfo prDetails = pr.getRedundancyProvider().
-          buildPartitionedRegionInfo(internal, cache.getResourceManager().getLoadProbe());
+      PartitionRegionInfo prDetails = pr.getRedundancyProvider()
+          .buildPartitionedRegionInfo(internal, cache.getResourceManager().getLoadProbe());
-   * Decide which partitions will host which buckets. Gemfire normally assigns
-   * buckets to partitions as needed when data is added to a partitioned region.
-   * This method provides way to assign all of the buckets without putting any
-   * data in partition region. This method should not be called until all of the
-   * partitions are running because it will divide the buckets between the
-   * running partitions. If the buckets are already assigned this method will
-   * have no effect.
+   * Decide which partitions will host which buckets. Gemfire normally assigns buckets to partitions
+   * as needed when data is added to a partitioned region. This method provides way to assign all of
+   * the buckets without putting any data in partition region. This method should not be called
+   * until all of the partitions are running because it will divide the buckets between the running
+   * partitions. If the buckets are already assigned this method will have no effect.
-   * @param region
-   *          The region which should have it's buckets assigned.
-   * @throws IllegalStateException
-   *          if the provided region is something other than a
+   * @param region The region which should have it's buckets assigned.
+   * @throws IllegalStateException if the provided region is something other than a
-  public static void assignBucketsToPartitions(Region<?,?> region) {
+  public static void assignBucketsToPartitions(Region<?, ?> region) {
-      for(int i = 0; i < getNumberOfBuckets(pr); i++) {
-        //This method will return quickly if the bucket already exists
+      for (int i = 0; i < getNumberOfBuckets(pr); i++) {
+        // This method will return quickly if the bucket already exists
-      if(lock != null) {
+      if (lock != null) {
-  
+
-   * Get the current primary owner for a key.  Upon return there is no guarantee that
-   * primary owner remains the primary owner, or that the member is still alive.
-   * <p>This method is not a substitute for {@link Region#containsKey(Object)}.</p>
+   * Get the current primary owner for a key. Upon return there is no guarantee that primary owner
+   * remains the primary owner, or that the member is still alive.
+   * <p>
+   * This method is not a substitute for {@link Region#containsKey(Object)}.
+   * </p>
+   * 
-   * @throws IllegalStateException
-   *         if the provided region is something other than a
-   *        {@linkplain DataPolicy#PARTITION partitioned Region}
+   * @throws IllegalStateException if the provided region is something other than a
+   *         {@linkplain DataPolicy#PARTITION partitioned Region}
-  public static <K,V> DistributedMember getPrimaryMemberForKey(final Region<K,V> r, final K key) {
+  public static <K, V> DistributedMember getPrimaryMemberForKey(final Region<K, V> r, final K key) {
-   * Get all potential redundant owners for a key.  If the key exists in the Region,
-   * upon return there is no guarantee that key has not been moved or that
-   * the members are still alive.
+   * Get all potential redundant owners for a key. If the key exists in the Region, upon return
+   * there is no guarantee that key has not been moved or that the members are still alive.
-   * <p>This method is not a substitute for {@link Region#containsKey(Object)}.</p>
-   * <p> This method is equivalent to:
-   * <code>
+   * <p>
+   * This method is not a substitute for {@link Region#containsKey(Object)}.
+   * </p>
+   * <p>
+   * This method is equivalent to: <code>
-   * </code></p>
+   * </code>
+   * </p>
+   * 
-   * @throws IllegalStateException
-   *        if the provided region is something other than a
-   *        {@linkplain DataPolicy#PARTITION partitioned Region}
+   * @throws IllegalStateException if the provided region is something other than a
+   *         {@linkplain DataPolicy#PARTITION partitioned Region}
-  public static <K,V> Set<DistributedMember> getRedundantMembersForKey(final Region<K,V> r, final K key) {
+  public static <K, V> Set<DistributedMember> getRedundantMembersForKey(final Region<K, V> r,
+      final K key) {
-   * Get all potential owners for a key.  If the key exists in the Region, upon return
-   * there is no guarantee that it has not moved nor does it guarantee all members are still
-   * alive.
-   * <p>This method is not a substitute for {@link Region#containsKey(Object)}.
+   * Get all potential owners for a key. If the key exists in the Region, upon return there is no
+   * guarantee that it has not moved nor does it guarantee all members are still alive.
+   * <p>
+   * This method is not a substitute for {@link Region#containsKey(Object)}.
-   * @throws IllegalStateException
-   *         if the provided region is something other than a
-   *        {@linkplain DataPolicy#PARTITION partitioned Region}
+   * @throws IllegalStateException if the provided region is something other than a
+   *         {@linkplain DataPolicy#PARTITION partitioned Region}
-  public static <K,V> Set<DistributedMember> getAllMembersForKey(final Region<K,V> r, final K key) {
+  public static <K, V> Set<DistributedMember> getAllMembersForKey(final Region<K, V> r,
+      final K key) {
-  private static <K,V> Set<? extends DistributedMember> getAllForKey(final Region<K,V> r, final K key) {
+
+  private static <K, V> Set<? extends DistributedMember> getAllForKey(final Region<K, V> r,
+      final K key) {
-  
+
-   * Given a RegionFunctionContext {@linkplain RegionFunctionContext#getDataSet()
-   * for a partitioned Region}, return a map of {@linkplain PartitionAttributesFactory#setColocatedWith(String) colocated Regions}
-   * with read access limited to the context of the function.
+   * Given a RegionFunctionContext {@linkplain RegionFunctionContext#getDataSet() for a partitioned
+   * Region}, return a map of {@linkplain PartitionAttributesFactory#setColocatedWith(String)
+   * colocated Regions} with read access limited to the context of the function.
-   * @throws IllegalStateException if the Region is not a {@linkplain DataPolicy#PARTITION partitioned Region}
+   * @throws IllegalStateException if the Region is not a {@linkplain DataPolicy#PARTITION
+   *         partitioned Region}
-    final InternalRegionFunctionContext rfci = (InternalRegionFunctionContext)c;
+    final InternalRegionFunctionContext rfci = (InternalRegionFunctionContext) c;
-   * Given a RegionFunctionContext
-   * {@linkplain RegionFunctionContext#getDataSet() for a partitioned Region},
-   * return a Region providing read access limited to the function context.<br>
+   * Given a RegionFunctionContext {@linkplain RegionFunctionContext#getDataSet() for a partitioned
+   * Region}, return a Region providing read access limited to the function context.<br>
-   * {@link PartitionAttributes#getRedundantCopies() redundantCopies} configured
-   * is more than 0. If the invoking Function is configured to have
-   * {@link Function#optimizeForWrite() optimizeForWrite} as true,the returned
-   * Region will only contain primary copy of the data.
+   * {@link PartitionAttributes#getRedundantCopies() redundantCopies} configured is more than 0. If
+   * the invoking Function is configured to have {@link Function#optimizeForWrite()
+   * optimizeForWrite} as true,the returned Region will only contain primary copy of the data.
-   * Writes using this Region have no constraints and behave the same as a
-   * partitioned Region.
+   * Writes using this Region have no constraints and behave the same as a partitioned Region.
-   * @param c
-   *          a functions context
-   * @throws IllegalStateException
-   *           if {@link RegionFunctionContext#getDataSet()} returns something
-   *           other than a {@linkplain DataPolicy#PARTITION partitioned Region}
+   * @param c a functions context
+   * @throws IllegalStateException if {@link RegionFunctionContext#getDataSet()} returns something
+   *         other than a {@linkplain DataPolicy#PARTITION partitioned Region}
-    InternalRegionFunctionContext rfci = (InternalRegionFunctionContext)c;
+    InternalRegionFunctionContext rfci = (InternalRegionFunctionContext) c;
-  
- /**
-   * Given a partitioned Region return a Region providing read access limited to
-   * the local heap, writes using this Region have no constraints and behave the
-   * same as a partitioned Region.<br>
+
+  /**
+   * Given a partitioned Region return a Region providing read access limited to the local heap,
+   * writes using this Region have no constraints and behave the same as a partitioned Region.<br>
-   * @param r
-   *                a partitioned region
-   * @throws IllegalStateException
-   *                 if the provided region is something other than a
-   *                 {@linkplain DataPolicy#PARTITION partitioned Region}
+   * @param r a partitioned region
+   * @throws IllegalStateException if the provided region is something other than a
+   *         {@linkplain DataPolicy#PARTITION partitioned Region}
-  public static <K,V> Region<K,V> getLocalData(final Region<K,V> r) {
+  public static <K, V> Region<K, V> getLocalData(final Region<K, V> r) {
-      PartitionedRegion pr = (PartitionedRegion)r;
+      PartitionedRegion pr = (PartitionedRegion) r;
+
-   * Given a partitioned Region return a Region providing read access to primary
-   * copy of the data which is limited to the local heap, writes using this
-   * Region have no constraints and behave the same as a partitioned Region.<br>
+   * Given a partitioned Region return a Region providing read access to primary copy of the data
+   * which is limited to the local heap, writes using this Region have no constraints and behave the
+   * same as a partitioned Region.<br>
-   * @param r
-   *          a partitioned region
-   * @throws IllegalStateException
-   *           if the provided region is something other than a
-   *           {@linkplain DataPolicy#PARTITION partitioned Region}
+   * @param r a partitioned region
+   * @throws IllegalStateException if the provided region is something other than a
+   *         {@linkplain DataPolicy#PARTITION partitioned Region}
-  public static <K,V> Region<K,V> getLocalPrimaryData(final Region<K,V> r) {
+  public static <K, V> Region<K, V> getLocalPrimaryData(final Region<K, V> r) {
-      PartitionedRegion pr = (PartitionedRegion)r;
+      PartitionedRegion pr = (PartitionedRegion) r;
-  
+
-   * Moves the bucket which contains the given key from the source member to the
-   * destination member. The bucket will be fully transferred once this method
-   * is complete, if the method does not throw an exception.
+   * Moves the bucket which contains the given key from the source member to the destination member.
+   * The bucket will be fully transferred once this method is complete, if the method does not throw
+   * an exception.
-   * Any data in colocated regions that are colocated with this key will also be
-   * moved.
+   * Any data in colocated regions that are colocated with this key will also be moved.
-   * This method allows direct control of what data to move. To automatically
-   * balance buckets, see {@link ResourceManager#createRebalanceFactory()}
+   * This method allows direct control of what data to move. To automatically balance buckets, see
+   * {@link ResourceManager#createRebalanceFactory()}
-   * @param region
-   *          The region in which to move the bucket. Data in regions colocated
-   *          with this region will also be moved.
-   * @param source
-   *          A member that is currently hosting this bucket. The bucket is
-   *          moved off of this member.
-   * @param destination
-   *          A member that is not currently hosting this bucket, but has the
-   *          partitioned region defined. The bucket is moved to this member.
-   * @param key
-   *          A key which maps to the bucket to move. This key does not actually
-   *          need to exist in the region, but if using a
-   *          {@link PartitionResolver} the resolver should be able to get the
-   *          routing object from this key to determine the bucket to move.
+   * @param region The region in which to move the bucket. Data in regions colocated with this
+   *        region will also be moved.
+   * @param source A member that is currently hosting this bucket. The bucket is moved off of this
+   *        member.
+   * @param destination A member that is not currently hosting this bucket, but has the partitioned
+   *        region defined. The bucket is moved to this member.
+   * @param key A key which maps to the bucket to move. This key does not actually need to exist in
+   *        the region, but if using a {@link PartitionResolver} the resolver should be able to get
+   *        the routing object from this key to determine the bucket to move.
-   * @throws IllegalStateException
-   *           if the bucket is not present on the source, if the source or
-   *           destination are not valid members of the system, if the
-   *           destination already hosts a copy of the bucket, or if the bucket
-   *           does not exist.
+   * @throws IllegalStateException if the bucket is not present on the source, if the source or
+   *         destination are not valid members of the system, if the destination already hosts a
+   *         copy of the bucket, or if the bucket does not exist.
-   public static <K> void moveBucketByKey(Region<K,?> region, DistributedMember source, DistributedMember destination, K key) {
-     PartitionedRegion pr = isPartitionedCheck(region);
-     if(pr.isFixedPartitionedRegion()) {
-       throw new IllegalStateException("Cannot move data in a fixed partitioned region");
-     }
-     int bucketId = pr.getKeyInfo(key).getBucketId();
-     ExplicitMoveDirector director = new ExplicitMoveDirector(key, bucketId, source, destination, region.getCache().getDistributedSystem());
-     PartitionedRegionRebalanceOp rebalance = new PartitionedRegionRebalanceOp(pr, false, director, true, true);
-     rebalance.execute();
-   }
+  public static <K> void moveBucketByKey(Region<K, ?> region, DistributedMember source,
+      DistributedMember destination, K key) {
+    PartitionedRegion pr = isPartitionedCheck(region);
+    if (pr.isFixedPartitionedRegion()) {
+      throw new IllegalStateException("Cannot move data in a fixed partitioned region");
+    }
+    int bucketId = pr.getKeyInfo(key).getBucketId();
+    ExplicitMoveDirector director = new ExplicitMoveDirector(key, bucketId, source, destination,
+        region.getCache().getDistributedSystem());
+    PartitionedRegionRebalanceOp rebalance =
+        new PartitionedRegionRebalanceOp(pr, false, director, true, true);
+    rebalance.execute();
+  }
-   /**
-   * Moves data from the source member to the destination member, up to the
-   * given percentage of data (measured in bytes). The data will be fully
-   * transferred once this method is complete, if the method does not throw an
-   * exception. The percentage is a percentage of the amount of data in bytes on
-   * the source member for this region.
+  /**
+   * Moves data from the source member to the destination member, up to the given percentage of data
+   * (measured in bytes). The data will be fully transferred once this method is complete, if the
+   * method does not throw an exception. The percentage is a percentage of the amount of data in
+   * bytes on the source member for this region.
-   * If this region has colocated regions, the colocated data will also be
-   * moved. The total amount of data in all colocated regions will be taken into
-   * consideration when determining what percentage of data will be moved.
+   * If this region has colocated regions, the colocated data will also be moved. The total amount
+   * of data in all colocated regions will be taken into consideration when determining what
+   * percentage of data will be moved.
-   * It may not be possible to move data to the destination member, if the
-   * destination member has no available space, no bucket smaller than the given
-   * percentage exists, or if moving data would violate redundancy constraints.
-   * If data cannot be moved, this method will return a RebalanceResult object
-   * with 0 total bucket transfers.
+   * It may not be possible to move data to the destination member, if the destination member has no
+   * available space, no bucket smaller than the given percentage exists, or if moving data would
+   * violate redundancy constraints. If data cannot be moved, this method will return a
+   * RebalanceResult object with 0 total bucket transfers.
-   * This method allows direct control of what data to move. To automatically
-   * balance buckets, see {@link ResourceManager#createRebalanceFactory()}
+   * This method allows direct control of what data to move. To automatically balance buckets, see
+   * {@link ResourceManager#createRebalanceFactory()}
-   * @param region
-   *          The region in which to move data. Data in regions colocated with
-   *          this region will also be moved.
-   * @param source
-   *          A member that is currently hosting data. The bucket is moved off
-   *          of this member.
-   * @param destination
-   *          A member that that has the partitioned region defined. Data is
-   *          moved to this member.
-   * @param percentage
-   *          the maximum amount of data to move, as a percentage from 0 to 100.
+   * @param region The region in which to move data. Data in regions colocated with this region will
+   *        also be moved.
+   * @param source A member that is currently hosting data. The bucket is moved off of this member.
+   * @param destination A member that that has the partitioned region defined. Data is moved to this
+   *        member.
+   * @param percentage the maximum amount of data to move, as a percentage from 0 to 100.
-   * @throws IllegalStateException
-   *           if the source or destination are not valid members of the system.
-   * @throws IllegalArgumentException
-   *           if the percentage is not between 0 to 100.
+   * @throws IllegalStateException if the source or destination are not valid members of the system.
+   * @throws IllegalArgumentException if the percentage is not between 0 to 100.
-   * @return A RebalanceResult object that contains information about what what
-   *         data was actually moved.
+   * @return A RebalanceResult object that contains information about what what data was actually
+   *         moved.
-   public static RebalanceResults moveData(Region<?,?> region, DistributedMember source, DistributedMember destination, float percentage) {
-     PartitionedRegion pr = isPartitionedCheck(region);
-     if(pr.isFixedPartitionedRegion()) {
-       throw new IllegalStateException("Cannot move data in a fixed partitioned region");
-     }
-     if(percentage <=0 || percentage > 100.0) {
-       throw new IllegalArgumentException("Percentage must be between 0 and 100");
-     }
-     
-     PercentageMoveDirector director = new PercentageMoveDirector(source, destination, percentage);
-     PartitionedRegionRebalanceOp rebalance = new PartitionedRegionRebalanceOp(pr, false, director, true, true);
-     Set<PartitionRebalanceInfo> results = rebalance.execute();
+  public static RebalanceResults moveData(Region<?, ?> region, DistributedMember source,
+      DistributedMember destination, float percentage) {
+    PartitionedRegion pr = isPartitionedCheck(region);
+    if (pr.isFixedPartitionedRegion()) {
+      throw new IllegalStateException("Cannot move data in a fixed partitioned region");
+    }
+    if (percentage <= 0 || percentage > 100.0) {
+      throw new IllegalArgumentException("Percentage must be between 0 and 100");
+    }
-     RebalanceResultsImpl rebalanceResults = new RebalanceResultsImpl();
-     for(PartitionRebalanceInfo details : results) {
-       rebalanceResults.addDetails(details);
-     }
-     
-     return rebalanceResults;
-   }
+    PercentageMoveDirector director = new PercentageMoveDirector(source, destination, percentage);
+    PartitionedRegionRebalanceOp rebalance =
+        new PartitionedRegionRebalanceOp(pr, false, director, true, true);
+    Set<PartitionRebalanceInfo> results = rebalance.execute();
+
+    RebalanceResultsImpl rebalanceResults = new RebalanceResultsImpl();
+    for (PartitionRebalanceInfo details : results) {
+      rebalanceResults.addDetails(details);
+    }
+
+    return rebalanceResults;
+  }

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 INS66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
GEODE-7886 Update strings tests to cover sad as well as happy paths (#4821)


Co-authored-by: Sarah Abbey <sabbey@pivotal.io>
+import org.apache.geode.cache.TimeoutException;
+import org.apache.geode.redis.internal.AutoCloseableLock;
+import org.apache.geode.redis.internal.RedisConstants;
-
-  private final String ERROR_VALUE_NOT_USABLE =
-      "The value at this key cannot be incremented numerically";
-
-  private final String ERROR_OVERFLOW = "This incrementation cannot be performed due to overflow";
+  private final String ERROR_OVERFLOW = "value is not an integer or out of range";
+    long value;
-    Region<ByteArrayWrapper, ByteArrayWrapper> r = context.getRegionProvider().getStringsRegion();
-    if (commandElems.size() < 2) {
+    if (commandElems.size() != 2) {
+    Region<ByteArrayWrapper, ByteArrayWrapper> region =
+        context.getRegionProvider().getStringsRegion();
+
-    ByteArrayWrapper valueWrapper = r.get(key);
+    try (AutoCloseableLock regionLock = withRegionLock(context, key)) {
+      ByteArrayWrapper valueWrapper = region.get(key);
-    /*
-     * Value does not exist
-     */
+      /*
+       * Value does not exist
+       */
-    if (valueWrapper == null) {
-      byte[] newValue = {Coder.NUMBER_1_BYTE};
-      r.put(key, new ByteArrayWrapper(newValue));
-      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), INIT_VALUE_INT));
-      return;
-    }
+      if (valueWrapper == null) {
+        byte[] newValue = {Coder.NUMBER_1_BYTE};
+        region.put(key, new ByteArrayWrapper(newValue));
+        command
+            .setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), INIT_VALUE_INT));
+        return;
+      }
-    /*
-     * Value exists
-     */
+      /*
+       * Value exists
+       */
-    String stringValue = valueWrapper.toString();
+      String stringValue = valueWrapper.toString();
-    long value;
-    try {
-      value = Long.parseLong(stringValue);
-    } catch (NumberFormatException e) {
+      try {
+        value = Long.parseLong(stringValue);
+      } catch (NumberFormatException e) {
+        command.setResponse(
+            Coder.getErrorResponse(context.getByteBufAllocator(), RedisConstants.ERROR_WRONG_TYPE));
+        return;
+      }
+
+      if (value == Long.MAX_VALUE) {
+        command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_OVERFLOW));
+        return;
+      }
+
+      value++;
+
+      stringValue = "" + value;
+      region.put(key, new ByteArrayWrapper(Coder.stringToBytes(stringValue)));
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
-          Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_VALUE_NOT_USABLE));
+          Coder.getErrorResponse(context.getByteBufAllocator(), "Thread interrupted."));
+      return;
+    } catch (TimeoutException e) {
+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
+          "Timeout acquiring lock. Please try again."));
-
-    if (value == Long.MAX_VALUE) {
-      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_OVERFLOW));
-      return;
-    }
-
-    value++;
-
-    stringValue = "" + value;
-    r.put(key, new ByteArrayWrapper(Coder.stringToBytes(stringValue)));
-
-
-

INS26 INS26 INS26 INS40 INS40 INS40 MOV60 MOV60 UPD45 INS54 UPD27 INS58 INS8 INS12 INS12 UPD42 INS43 INS59 MOV60 MOV25 MOV60 MOV54 MOV25 MOV21 MOV21 MOV21 INS44 INS8 INS44 INS8 INS42 INS42 INS32 INS43 INS42 INS21 INS21 INS41 INS43 INS42 INS21 INS41 INS42 INS42 INS42 UPD42 INS42 INS32 INS32 INS42 INS32 UPD42 INS32 INS42 INS42 INS42 INS32 INS42 INS42 INS32 UPD42 INS42 INS42 INS42 INS42 INS32 INS45 INS42 INS42 INS32 INS45 INS42 INS42 INS42 INS42 INS40 DEL83 DEL83 DEL42 DEL43 DEL42 DEL45 DEL59 DEL23 DEL42
Merge branch 'feature/GEODE-8' into develop

-  private boolean isOverFlowToDisk;
-  private boolean indexMaintenanceSynchronous = true;
+  private final boolean isOverFlowToDisk;
+  private final boolean offHeap;
+  private final boolean indexMaintenanceSynchronous;
+    this.offHeap = region.getAttributes().getOffHeap();
-          if (!getRegion().getAttributes().getIndexMaintenanceSynchronous()) {
+          if (!isIndexMaintenanceTypeSynchronous()) {
-        if(isOverFlowToDisk) {
+        if(isOverFlowRegion()) {
+        // OffHeap is not supported with range index.
+        if(isOffHeap()) {
+          if (!isIndexMaintenanceTypeSynchronous()) {
+            throw new UnsupportedOperationException(LocalizedStrings.DefaultQueryService_OFF_HEAP_INDEX_CREATION_IS_NOT_SUPPORTED_FOR_ASYNC_MAINTENANCE_THE_REGION_IS_0.toLocalizedString(region.getFullPath()));
+          } 
+          throw new UnsupportedOperationException(LocalizedStrings.DefaultQueryService_OFF_HEAP_INDEX_CREATION_IS_NOT_SUPPORTED_FOR_MULTIPLE_ITERATORS_THE_REGION_IS_0.toLocalizedString(region.getFullPath()));
+        }
-    if (indexMaintenanceSynchronous) {
+    if (isIndexMaintenanceTypeSynchronous()) {
+        // TODO OFFHEAP: this optimization (calling getValue to make sure it is faulted in to disk) has a performance problem.
+        // It also decompresses and deserializes the value and then throws that away. In the case of a heap region the deserialized
+        // value would be cached in a VMCachedDeserializable. But for compression and/or off-heap the decompression and/or deserialization
+        // this call does is lost and has to be done again. We could just add a method to RegionEntry that faults the value in without returning it.
+        // Even better (but more work): could we create a wrapper around RegionEntry that we create here to wrap "entry" and pass the wrapper to addIndexMapping?
+        // Any indexes that store a reference to the RegionEntry would need to ask the wrapper for the real one but any of them
+        // that want the value could get it from the wrapper. The first time the wrapper is asked for the value it could get it from
+        // the real RegionEntry it wraps and cache a reference to that value. I think that gives us the best of both worlds.
-    if (indexMaintenanceSynchronous) {
+    if (isIndexMaintenanceTypeSynchronous()) {
-    if (!indexMaintenanceSynchronous) updater.shutdown();
+    if (!isIndexMaintenanceTypeSynchronous()) updater.shutdown();
+  public boolean isOffHeap() {
+    return this.offHeap;
+  }
-      if (indexType == IndexType.HASH && isOverFlowToDisk) {
+      if (indexType == IndexType.HASH && isOverFlowRegion()) {

INS23 INS31 INS83 INS83 INS83 INS39 INS59 INS83 INS83 INS39 INS42 INS8 INS42 INS21 INS41 INS7 INS32 INS32 INS22 INS22 INS32 INS42 INS42 INS32 INS52 INS42 INS52 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS25 INS42 INS32 INS32 INS8 INS42 INS42 INS25 INS53 INS38 INS8 INS14 INS32 INS53 INS43 INS32 UPD42 INS42 INS14 INS42 INS40 INS42 INS32 INS43 INS32 INS42 INS42 INS42 INS40 INS42 INS32 INS42 INS42 DEL9 DEL42 DEL32 DEL42 DEL32 DEL42 DEL42 DEL42 DEL42 DEL42
GEODE-2113 Implement SSL over NIO

This fixes several bugs in the original implementation of SSL over NIO.
Notably there were buffer handling problems in MsgReader and the
NioFilters.  This new commit includes code coverage for these classes
in new tests.

Original commit message:

This removes old-I/O use in TCPConduit peer-to-peer communications.
This was used for SSL/TLS secure commuications but Java has had an
SSLEngine implementation that allows you to implement secure communications
on new-I/O SocketChannels or any other transport mechanism.

A new NioSSLEngine class wraps the JDK's SSLEngine and provides the
SSL handshake as well as encryption/decryption of messages. SocketCreator
performs the SSL handshake and returns a NioSslEngine that TCPConduit
then uses for messaging.

The SSL handshake needs to be done in Connection.java now because the
ByteBuffer used to do the handshake is also used for reading messages
in Receivers. Because of this the Handshake pool in TCPConduit became
obsolete and I deleted it.

I've also done a lot of cleanup of compilation warnings in Connection.java
and removed references to "NIO". The primary SSL/TLS changes in that class
are in writeFully (renamed from nioWriteFully) and processBuffer (renamed
from processNIOBuffer).

While testing I noticed some places where we're creating non-daemon
threads that were keeping DUnit ChildVM processes from exiting.  I've
changed these places to use daemon threads.  Very few threads in Geode
should be non-daemon.

Porting client/server to use NioSSLEngine will be done under a separate
ticket and a different version of NioEngine may be created to secure
UDP messaging.

-   * when the initial number of members is known, this method is invoked to ensure that connections
-   * to those members can be established in a reasonable amount of time. See bug 39848
-   *
-   */
-  public void setMembershipSize(int numberOfMembers) {
-    conduit.setMaximumHandshakePoolSize(numberOfMembers);
-  }
-
-  /**
-      int msToWait = (int) (ackTimeout - (System.currentTimeMillis() - startTime));
-      // if the wait threshold has already been reached during transmission
-      // of the message, set a small wait period just to make sure the
-      // acks haven't already come back
-      if (msToWait <= 0) {
-        msToWait = 10;
-      }
-      long msInterval = ackSDTimeout;
-      if (msInterval <= 0) {
-        msInterval = Math.max(ackTimeout, 1000);
-      }
-          con.readAck(msToWait, msInterval, processor);
+          con.readAck(processor);
-          c.readAck((int) ackSATimeout, ackSATimeout, processor);
+          c.readAck(processor);
-        c.readAck(0, 0, processor);
+        c.readAck(processor);

DEL66 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL39 DEL42 DEL39 DEL42 DEL42 DEL42 DEL32 DEL42 DEL27 DEL36 DEL27 DEL36 DEL11 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL34 DEL7 DEL21 DEL8 DEL25 DEL39 DEL42 DEL42 DEL59 DEL60 DEL42 DEL34 DEL27 DEL42 DEL42 DEL42 DEL42 DEL34 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL39 DEL42 DEL11 DEL42 DEL34 DEL34
GEODE-1292: change defragment to not create fragments > 2G

+  
+  /**
+   * Return true if the two chunks have been combined into one.
+   * If low and high are adjacent to each other
+   * and the combined size is small enough (see isSmallEnough)
+   * then low's size will be increased by the size of high
+   * and true will be returned.
+   */
+  boolean combineIfAdjacentAndSmallEnough(long lowAddr, long highAddr) {
+    assert lowAddr <= highAddr;
+    int lowSize = OffHeapStoredObject.getSize(lowAddr);
+    if (isAdjacent(lowAddr, lowSize, highAddr)) {
+      int highSize = OffHeapStoredObject.getSize(highAddr);
+      int combinedSize = lowSize + highSize;
+      if (isSmallEnough(combinedSize)) {
+        // append the highAddr chunk to lowAddr
+        OffHeapStoredObject.setSize(lowAddr, (int)combinedSize);
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Returns true if the area if memory (starting at lowAddr and extending to
+   * lowAddr+lowSize) is right before (i.e. adjacent) to highAddr.
+   */
+  boolean isAdjacent(long lowAddr, int lowSize, long highAddr) {
+    return (lowAddr + lowSize) == highAddr;
+  }
+  /**
+   * Return true if size is small enough to be set as the size
+   * of a OffHeapStoredObject.
+   */
+  boolean isSmallEnough(long size) {
+    return size <= Integer.MAX_VALUE;
+  }
+  
-        ArrayList<OffHeapStoredObjectAddressStack> freeChunks = new ArrayList<OffHeapStoredObjectAddressStack>();
-        collectFreeChunks(freeChunks);
-        final int SORT_ARRAY_BLOCK_SIZE = 128;
-        long[] sorted = new long[SORT_ARRAY_BLOCK_SIZE];
-        int sortedSize = 0;
-        boolean result = false;
-        int largestFragment = 0;
-        for (OffHeapStoredObjectAddressStack l: freeChunks) {
-          long addr = l.poll();
-          while (addr != 0) {
-            int idx = Arrays.binarySearch(sorted, 0, sortedSize, addr);
-            idx = -idx;
-            idx--;
-            if (idx == sortedSize) {
-              // addr is > everything in the array
-              if (sortedSize == 0) {
-                // nothing was in the array
-                sorted[0] = addr;
-                sortedSize++;
-              } else {
-                // see if we can conflate into sorted[idx]
-                long lowAddr = sorted[idx-1];
-                int lowSize = OffHeapStoredObject.getSize(lowAddr);
-                if (lowAddr + lowSize == addr) {
-                  // append the addr chunk to lowAddr
-                  OffHeapStoredObject.setSize(lowAddr, lowSize + OffHeapStoredObject.getSize(addr));
-                } else {
-                  if (sortedSize >= sorted.length) {
-                    long[] newSorted = new long[sorted.length+SORT_ARRAY_BLOCK_SIZE];
-                    System.arraycopy(sorted, 0, newSorted, 0, sorted.length);
-                    sorted = newSorted;
-                  }
-                  sortedSize++;
-                  sorted[idx] = addr;
-                }
-              }
-            } else {
-              int addrSize = OffHeapStoredObject.getSize(addr);
-              long highAddr = sorted[idx];
-              if (addr + addrSize == highAddr) {
-                // append highAddr chunk to addr
-                OffHeapStoredObject.setSize(addr, addrSize + OffHeapStoredObject.getSize(highAddr));
-                sorted[idx] = addr;
-              } else {
-                boolean insert = idx==0;
-                if (!insert) {
-                  long lowAddr = sorted[idx-1];
-                  //                  if (lowAddr == 0L) {
-                  //                    long[] tmp = Arrays.copyOf(sorted, sortedSize);
-                  //                    throw new IllegalStateException("addr was zero at idx=" + (idx-1) + " sorted="+ Arrays.toString(tmp));
-                  //                  }
-                  int lowSize = OffHeapStoredObject.getSize(lowAddr);
-                  if (lowAddr + lowSize == addr) {
-                    // append the addr chunk to lowAddr
-                    OffHeapStoredObject.setSize(lowAddr, lowSize + addrSize);
-                  } else {
-                    insert = true;
-                  }
-                }
-                if (insert) {
-                  if (sortedSize >= sorted.length) {
-                    long[] newSorted = new long[sorted.length+SORT_ARRAY_BLOCK_SIZE];
-                    System.arraycopy(sorted, 0, newSorted, 0, idx);
-                    newSorted[idx] = addr;
-                    System.arraycopy(sorted, idx, newSorted, idx+1, sortedSize-idx);
-                    sorted = newSorted;
-                  } else {
-                    System.arraycopy(sorted, idx, sorted, idx+1, sortedSize-idx);
-                    sorted[idx] = addr;
-                  }
-                  sortedSize++;
-                }
-              }
-            }
-            addr = l.poll();
-          }
-        }
-        for (int i=sortedSize-1; i > 0; i--) {
-          long addr = sorted[i];
-          long lowAddr = sorted[i-1];
-          int lowSize = OffHeapStoredObject.getSize(lowAddr);
-          if (lowAddr + lowSize == addr) {
-            // append addr chunk to lowAddr
-            OffHeapStoredObject.setSize(lowAddr, lowSize + OffHeapStoredObject.getSize(addr));
-            sorted[i] = 0L;
-          }
-        }
-        this.lastFragmentAllocation.set(0);
-        ArrayList<Fragment> tmp = new ArrayList<Fragment>();
-        for (int i=sortedSize-1; i >= 0; i--) {
-          long addr = sorted[i];
-          if (addr == 0L) continue;
-          int addrSize = OffHeapStoredObject.getSize(addr);
-          Fragment f = createFragment(addr, addrSize);
-          if (addrSize >= chunkSize) {
-            result = true;
-          }
-          if (addrSize > largestFragment) {
-            largestFragment = addrSize;
-            // TODO it might be better to sort them biggest first
-            tmp.add(0, f);
-          } else {
-            tmp.add(f);
-          }
-        }
-        this.fragmentList.addAll(tmp);
-
-        fillFragments();
+        boolean result = doDefragment(chunkSize);
-        this.ma.getStats().setLargestFragment(largestFragment);
-        this.ma.getStats().setFragments(tmp.size());        
-        this.ma.getStats().setFragmentation(getFragmentation());
-
+  
+  /**
+   * Simple interface the represents a "stack" of primitive longs.
+   * Currently this interface only allows supports poll but more
+   * could be added if needed in the future.
+   * This interface was introduced to aid unit testing.
+   * The only implementation of it is OffHeapStoredObjectAddressStack.
+   */
+  public interface LongStack {
+    /**
+     * Retrieves and removes the top of this stack,
+     * or returns {@code 0L} if this stack is empty.
+     */
+    public long poll();
+  }
+  /**
+   * Manages an array of primitive longs. The array can grow.
+   */
+  public static class ResizableLongArray {
+    private static final int SORT_ARRAY_BLOCK_SIZE = 128;
+    long[] data = new long[SORT_ARRAY_BLOCK_SIZE];
+    int size = 0;
+    
+    public int binarySearch(long l) {
+      return Arrays.binarySearch(data, 0, size, l);
+    }
+    public int size() {
+      return size;
+    }
+    public long get(int idx) {
+      return data[idx];
+    }
+    public void set(int idx, long l) {
+      data[idx] = l;
+    }
+    public void add(long l) {
+      if (size >= data.length) {
+        long[] newData = new long[data.length+SORT_ARRAY_BLOCK_SIZE];
+        System.arraycopy(data, 0, newData, 0, data.length);
+        data = newData;
+      }
+      data[size] = l;
+      size++;
+    }
+    public void insert(int idx, long l) {
+      if (size >= data.length) {
+        long[] newData = new long[data.length+SORT_ARRAY_BLOCK_SIZE];
+        System.arraycopy(data, 0, newData, 0, idx);
+        newData[idx] = l;
+        System.arraycopy(data, idx, newData, idx+1, size-idx);
+        data = newData;
+      } else {
+        System.arraycopy(data, idx, data, idx+1, size-idx);
+        data[idx] = l;
+      }
+      size++;
+    }
+  }
+  /**
+   * Defragments memory and returns true if enough memory to allocate chunkSize
+   * is freed. Otherwise returns false;
+   * Unlike the defragment method this method is not thread safe and does not check
+   * for a concurrent defragment. It should only be called by defragment and unit tests.
+   */
+  boolean doDefragment(int chunkSize) {
+    boolean result = false;
+    ArrayList<LongStack> freeChunks = new ArrayList<LongStack>();
+    collectFreeChunks(freeChunks);
+    ResizableLongArray sorted = new ResizableLongArray();
+    for (LongStack l: freeChunks) {
+      long addr = l.poll();
+      while (addr != 0) {
+        int idx = sorted.binarySearch(addr);
+        idx = -idx;
+        idx--;
+        int sortedSize = sorted.size();
+        if (idx == sortedSize) {
+          // addr is > everything in the array
+          if (sortedSize == 0) {
+            // nothing was in the array
+            sorted.add(addr);
+          } else {
+            if (!combineIfAdjacentAndSmallEnough(sorted.get(idx-1), addr)) {
+              sorted.add(addr);
+            }
+          }
+        } else {
+          if (combineIfAdjacentAndSmallEnough(addr, sorted.get(idx))) {
+            sorted.set(idx, addr);
+          } else {
+            if (idx == 0 || !combineIfAdjacentAndSmallEnough(sorted.get(idx-1), addr)) {
+              sorted.insert(idx, addr);
+            }
+          }
+        }
+        addr = l.poll();
+      }
+    }
+    for (int i=sorted.size()-1; i > 0; i--) {
+      if (combineIfAdjacentAndSmallEnough(sorted.get(i-1), sorted.get(i))) {
+        sorted.set(i, 0L);
+      }
+    }
+    
+    int largestFragment = 0;
+    this.lastFragmentAllocation.set(0);
+    ArrayList<Fragment> tmp = new ArrayList<Fragment>();
+    for (int i=sorted.size()-1; i >= 0; i--) {
+      long addr = sorted.get(i);
+      if (addr == 0L) continue;
+      int addrSize = OffHeapStoredObject.getSize(addr);
+      Fragment f = createFragment(addr, addrSize);
+      if (addrSize >= chunkSize) {
+        result = true;
+      }
+      if (addrSize > largestFragment) {
+        largestFragment = addrSize;
+        // TODO it might be better to sort them biggest first
+        tmp.add(0, f);
+      } else {
+        tmp.add(f);
+      }
+    }
+    this.fragmentList.addAll(tmp);
+
+    fillFragments();
+
+    this.ma.getStats().setLargestFragment(largestFragment);
+    this.ma.getStats().setFragments(tmp.size());        
+    this.ma.getStats().setFragmentation(getFragmentation());
+
+    return result;
+  }
-  private void collectFreeChunks(List<OffHeapStoredObjectAddressStack> l) {
+  private void collectFreeChunks(List<LongStack> l) {
-  private void collectFreeFragmentChunks(List<OffHeapStoredObjectAddressStack> l) {
+  private void collectFreeFragmentChunks(List<LongStack> l) {
-  private void collectFreeTinyChunks(List<OffHeapStoredObjectAddressStack> l) {
+  private void collectFreeTinyChunks(List<LongStack> l) {
-  private void collectFreeHugeChunks(List<OffHeapStoredObjectAddressStack> l) {
+  private void collectFreeHugeChunks(List<LongStack> l) {

INS31 INS31 INS31 INS31 INS55 INS55 INS31 INS29 MOV39 UPD42 MOV42 INS44 INS44 INS8 INS29 INS39 INS42 INS44 INS44 INS44 INS8 INS29 INS39 INS42 INS44 INS8 MOV29 INS39 INS42 INS44 INS8 INS29 INS83 INS42 INS31 INS29 INS83 INS83 INS42 INS23 INS23 INS23 INS31 INS31 INS31 INS31 INS31 INS31 INS29 INS39 INS42 MOV44 INS8 INS44 INS44 MOV44 MOV44 INS65 INS39 INS42 INS39 INS42 INS6 MOV60 INS25 INS41 INS65 INS39 INS42 INS39 INS42 INS39 INS42 INS41 INS65 INS39 INS42 INS41 INS39 INS42 MOV60 MOV60 MOV21 INS54 INS65 INS29 INS83 INS39 INS42 INS65 INS83 INS83 INS83 INS39 MOV59 MOV5 MOV59 INS39 INS59 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS83 INS39 INS42 INS44 INS8 INS83 INS39 INS42 INS44 INS44 INS8 INS65 MOV60 MOV60 MOV21 INS60 INS70 INS24 MOV60 MOV21 MOV60 MOV24 MOV21 MOV21 MOV21 MOV21 MOV21 MOV41 INS74 INS42 INS74 INS42 UPD74 UPD74 INS66 INS66 INS66 INS66 INS66 INS27 INS32 INS8 INS9 INS66 INS66 MOV27 INS66 INS66 INS27 INS8 MOV8 INS66 INS66 INS66 INS66 INS66 INS65 INS66 UPD42 INS42 INS34 INS39 INS42 INS41 INS41 INS39 INS42 INS41 INS39 INS42 INS39 INS42 INS21 INS39 INS42 INS25 MOV21 INS21 INS39 INS42 INS39 INS42 MOV25 MOV21 INS66 INS66 INS66 INS66 UPD74 MOV74 INS43 INS59 INS44 INS42 INS8 INS58 MOV27 MOV37 INS8 MOV43 INS43 MOV43 INS43 UPD43 UPD43 INS42 INS42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 UPD42 MOV42 INS60 MOV60 INS25 INS36 UPD42 UPD42 MOV42 UPD40 MOV40 INS51 INS66 INS66 INS65 INS66 INS32 INS42 INS2 INS7 UPD27 MOV27 MOV8 INS37 UPD43 INS42 UPD42 MOV42 INS14 INS43 INS42 MOV60 INS61 INS39 INS59 INS25 INS42 INS42 UPD42 UPD42 INS39 INS59 UPD39 INS32 INS8 MOV27 INS52 INS8 INS66 INS42 INS42 INS42 INS34 INS42 INS42 UPD42 MOV42 MOV42 INS2 INS42 UPD42 MOV42 INS40 MOV60 INS21 INS2 INS42 INS42 UPD42 UPD40 MOV60 UPD42 UPD42 UPD74 MOV74 INS43 INS42 MOV27 INS8 INS42 INS27 INS32 INS8 INS42 MOV32 INS42 INS27 INS42 INS42 INS21 INS41 MOV25 INS60 MOV21 INS41 UPD42 MOV42 INS42 MOV5 INS7 INS42 INS42 MOV5 UPD43 INS42 MOV60 MOV21 MOV21 MOV60 INS25 MOV21 INS32 INS34 INS42 INS32 INS32 MOV21 INS32 INS32 INS42 INS42 INS32 INS9 INS39 INS59 INS42 UPD42 UPD42 UPD42 UPD42 INS34 INS42 INS34 INS40 INS42 INS42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV27 UPD42 UPD42 UPD42 UPD42 MOV27 UPD42 UPD42 UPD39 UPD39 MOV27 INS8 INS8 INS42 INS42 INS42 INS42 MOV27 INS42 INS42 INS42 INS32 INS42 INS42 INS42 INS42 INS42 MOV42 MOV42 MOV42 INS11 INS42 INS32 MOV5 MOV5 UPD42 UPD42 UPD42 UPD42 UPD42 INS32 UPD42 INS32 INS25 INS25 INS42 INS42 INS42 INS34 INS39 INS42 UPD42 MOV42 INS42 UPD40 UPD40 INS42 INS42 INS42 INS42 INS42 MOV27 INS8 INS8 INS32 INS8 INS8 INS21 INS25 INS42 INS42 INS32 INS21 INS25 INS32 INS38 INS8 INS42 UPD42 MOV42 INS42 INS32 INS27 INS8 INS42 INS42 INS42 INS32 INS21 INS42 UPD42 MOV42 INS42 UPD42 MOV42 MOV27 INS38 INS21 UPD42 MOV42 INS32 UPD42 MOV42 INS32 INS32 INS32 INS42 UPD42 MOV42 MOV27 INS42 INS42 INS42 INS42 INS32 MOV42 INS42 INS42 INS42 INS42 UPD42 MOV42 UPD42 MOV42 MOV27 DEL42 DEL42 DEL2 DEL42 DEL27 DEL42 DEL42 DEL42 DEL27 DEL42 DEL9 DEL42 DEL42 DEL2 DEL42 DEL2 DEL42 DEL42 DEL2 DEL34 DEL7 DEL42 DEL42 DEL42 DEL2 DEL52 DEL83 DEL39 DEL60 DEL60 DEL39 DEL42 DEL34 DEL59 DEL60 DEL42 DEL43 DEL42 DEL44 DEL42 DEL39 DEL42 DEL42 DEL34 DEL32 DEL59 DEL60 DEL42 DEL34 DEL2 DEL42 DEL7 DEL21 DEL42 DEL37 DEL21 DEL8 DEL42 DEL42 DEL42 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL27 DEL42 DEL42 DEL42 DEL34 DEL34 DEL40 DEL32 DEL21 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL42 DEL37 DEL21 DEL42 DEL42 DEL2 DEL42 DEL7 DEL21 DEL8 DEL25 DEL8 DEL25 DEL8 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL2 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL27 DEL42 DEL42 DEL42 DEL42 DEL27 DEL32 DEL21 DEL2 DEL42 DEL7 DEL21 DEL8 DEL39 DEL42 DEL59 DEL60 DEL42 DEL38 DEL39 DEL42 DEL2 DEL59 DEL60 DEL39 DEL42 DEL42 DEL42 DEL42 DEL32 DEL59 DEL60 DEL8 DEL25 DEL8 DEL25 DEL42 DEL8 DEL25 DEL8 DEL25 DEL8 DEL25 DEL8 DEL61 DEL8 DEL70 DEL39 DEL42 DEL34 DEL27 DEL59 DEL58 DEL39 DEL42 DEL32 DEL59 DEL60 DEL42 DEL42 DEL27 DEL42 DEL27 DEL42 DEL32 DEL27 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL8 DEL51 DEL8 DEL54 DEL8 DEL31 DEL42 DEL43 DEL74 DEL42 DEL44 DEL42 DEL43 DEL74 DEL42 DEL44
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Executes Function with FunctionService#onRegion(Region region) in client server mode. 
+ * Executes Function with FunctionService#onRegion(Region region) in client server mode.
- * @see FunctionService#onRegion(Region) * 
+ * @see FunctionService#onRegion(Region) *
-  
+
-    this.region = (LocalRegion)r;    
+    this.region = (LocalRegion) r;
-  
-//  private ServerRegionFunctionExecutor(ServerRegionFunctionExecutor sre) {
-//    super(sre);
-//    this.region = sre.region;
-//    if (sre.filter != null) {
-//      this.filter.clear();
-//      this.filter.addAll(sre.filter);
-//    }
-//  }
-  private ServerRegionFunctionExecutor(
-      ServerRegionFunctionExecutor serverRegionFunctionExecutor,
+  // private ServerRegionFunctionExecutor(ServerRegionFunctionExecutor sre) {
+  // super(sre);
+  // this.region = sre.region;
+  // if (sre.filter != null) {
+  // this.filter.clear();
+  // this.filter.addAll(sre.filter);
+  // }
+  // }
+
+  private ServerRegionFunctionExecutor(ServerRegionFunctionExecutor serverRegionFunctionExecutor,
-    
+
-  
-  private ServerRegionFunctionExecutor(
-      ServerRegionFunctionExecutor serverRegionFunctionExecutor,
+
+  private ServerRegionFunctionExecutor(ServerRegionFunctionExecutor serverRegionFunctionExecutor,
-    
+
-  
-  private ServerRegionFunctionExecutor(
-      ServerRegionFunctionExecutor serverRegionFunctionExecutor,
+
+  private ServerRegionFunctionExecutor(ServerRegionFunctionExecutor serverRegionFunctionExecutor,
-    
+
-  private ServerRegionFunctionExecutor(
-      ServerRegionFunctionExecutor serverRegionFunctionExecutor, Set filter2) {
-    
+  private ServerRegionFunctionExecutor(ServerRegionFunctionExecutor serverRegionFunctionExecutor,
+      Set filter2) {
+
-    
+
-  
-  private ServerRegionFunctionExecutor(
-      ServerRegionFunctionExecutor serverRegionFunctionExecutor, 
+
+  private ServerRegionFunctionExecutor(ServerRegionFunctionExecutor serverRegionFunctionExecutor,
-    
+
-    
+
-  
+
-    return new ServerRegionFunctionExecutor(this, bucketIDs, true /* execute on bucketset*/);
+    return new ServerRegionFunctionExecutor(this, bucketIDs, true /* execute on bucketset */);
-        }
-        else { // Custome Result COllector
+        } else { // Custome Result COllector
-      }
-      else { // No results
+      } else { // No results
-    }
-    finally {
+    } finally {
-  protected ResultCollector executeFunction(final String functionId,
-      boolean resultReq, boolean isHA, boolean optimizeForWrite) {
+  protected ResultCollector executeFunction(final String functionId, boolean resultReq,
+      boolean isHA, boolean optimizeForWrite) {
-    byte hasResult = 0;
-    if (resultReq) { // have Results
-      hasResult = 1;
-      if (this.rc == null) { // Default Result Collector
-        ResultCollector defaultCollector = new DefaultResultCollector();
-        return executeOnServer(functionId, defaultCollector, hasResult, isHA, optimizeForWrite);
+      byte hasResult = 0;
+      if (resultReq) { // have Results
+        hasResult = 1;
+        if (this.rc == null) { // Default Result Collector
+          ResultCollector defaultCollector = new DefaultResultCollector();
+          return executeOnServer(functionId, defaultCollector, hasResult, isHA, optimizeForWrite);
+        } else { // Custome Result COllector
+          return executeOnServer(functionId, this.rc, hasResult, isHA, optimizeForWrite);
+        }
+      } else { // No results
+        executeOnServerNoAck(functionId, hasResult, isHA, optimizeForWrite);
+        return new NoResult();
-      else { // Custome Result COllector
-        return executeOnServer(functionId, this.rc, hasResult, isHA, optimizeForWrite);
-      }
-    }
-    else { // No results
-      executeOnServerNoAck(functionId, hasResult, isHA, optimizeForWrite);
-      return new NoResult();
-    }
-    }
-    finally {
+    } finally {
-  
-  private ResultCollector executeOnServer(Function function,
-      ResultCollector collector, byte hasResult) throws FunctionException {
+
+  private ResultCollector executeOnServer(Function function, ResultCollector collector,
+      byte hasResult) throws FunctionException {
-    FunctionStats stats = FunctionStats.getFunctionStats(function.getId(),
-        this.region.getSystem());
+    FunctionStats stats = FunctionStats.getFunctionStats(function.getId(), this.region.getSystem());
-      srp.executeFunction(this.region.getFullPath(), function, this, collector,
-            hasResult, false);
+      srp.executeFunction(this.region.getFullPath(), function, this, collector, hasResult, false);
-    }
-    catch(FunctionException functionException){
+    } catch (FunctionException functionException) {
-    }
-    catch (Exception exception) {
+    } catch (Exception exception) {
-  private ResultCollector executeOnServer(String functionId,
-      ResultCollector collector, byte hasResult, boolean isHA, boolean optimizeForWrite) throws FunctionException {
+  private ResultCollector executeOnServer(String functionId, ResultCollector collector,
+      byte hasResult, boolean isHA, boolean optimizeForWrite) throws FunctionException {
-    FunctionStats stats = FunctionStats.getFunctionStats(functionId,
-        this.region.getSystem());
+    FunctionStats stats = FunctionStats.getFunctionStats(functionId, this.region.getSystem());
-      srp.executeFunction(this.region.getFullPath(), functionId, this, collector,
-            hasResult, isHA, optimizeForWrite, false);
+      srp.executeFunction(this.region.getFullPath(), functionId, this, collector, hasResult, isHA,
+          optimizeForWrite, false);
-    }
-    catch(FunctionException functionException){
+    } catch (FunctionException functionException) {
-    }
-    catch (Exception exception) {
+    } catch (Exception exception) {
-  
-  private void executeOnServerNoAck(Function function, byte hasResult)
-      throws FunctionException {
+
+  private void executeOnServerNoAck(Function function, byte hasResult) throws FunctionException {
-    FunctionStats stats = FunctionStats.getFunctionStats(function.getId(),
-        this.region.getSystem());
+    FunctionStats stats = FunctionStats.getFunctionStats(function.getId(), this.region.getSystem());
-      srp.executeFunctionNoAck(this.region.getFullPath(), function, this,
-            hasResult, false);
+      srp.executeFunctionNoAck(this.region.getFullPath(), function, this, hasResult, false);
-    }
-    catch(FunctionException functionException){
+    } catch (FunctionException functionException) {
-    }
-    catch (Exception exception) {
+    } catch (Exception exception) {
-  private void executeOnServerNoAck(String functionId, byte hasResult,
-      boolean isHA, boolean optimizeForWrite) throws FunctionException {
+  private void executeOnServerNoAck(String functionId, byte hasResult, boolean isHA,
+      boolean optimizeForWrite) throws FunctionException {
-    FunctionStats stats = FunctionStats.getFunctionStats(functionId,
-        this.region.getSystem());
+    FunctionStats stats = FunctionStats.getFunctionStats(functionId, this.region.getSystem());
-      srp.executeFunctionNoAck(this.region.getFullPath(), functionId, this,
-            hasResult, isHA, optimizeForWrite, false);
+      srp.executeFunctionNoAck(this.region.getFullPath(), functionId, this, hasResult, isHA,
+          optimizeForWrite, false);
-    }
-    catch(FunctionException functionException){
+    } catch (FunctionException functionException) {
-    }
-    catch (Exception exception) {
+    } catch (Exception exception) {
-    }
-    else {
+    } else {
-      message
-          .append("No available connection was found. Server Region Proxy is not available for this region "
+      message.append(
+          "No available connection was found. Server Region Proxy is not available for this region "
-    return new StringBuffer().append("[ ServerRegionExecutor:").append("args=")
-        .append(this.args).append(" ;filter=").append(this.filter).append(
-            " ;region=").append(this.region.getName()).append("]").toString();
+    return new StringBuffer().append("[ ServerRegionExecutor:").append("args=").append(this.args)
+        .append(" ;filter=").append(this.filter).append(" ;region=").append(this.region.getName())
+        .append("]").toString();
+
-    return new ServerRegionFunctionExecutor(this, params); 
+    return new ServerRegionFunctionExecutor(this, params);
-  public InternalExecution withMemberMappedArgument(
-      MemberMappedArgument argument) {
+  public InternalExecution withMemberMappedArgument(MemberMappedArgument argument) {
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.execute.AbstractExecution#validateExecution(org.apache.geode.cache.execute.Function, java.util.Set)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.execute.AbstractExecution#validateExecution(org.apache.geode.
+   * cache.execute.Function, java.util.Set)
-  
-  
+
+
-        functionAttributes = (byte[])obj;
+        functionAttributes = (byte[]) obj;
-    }
-    else {
+    } else {
-  public ResultCollector execute(String functionName, boolean hasResult)
-      throws FunctionException {
+  public ResultCollector execute(String functionName, boolean hasResult) throws FunctionException {
-      return executeFunction(functionName,hasResult, hasResult, false);   
-    }
-    else {
-      byte registeredFunctionState = AbstractExecution.getFunctionState(
-          functionObject.isHA(), functionObject.hasResult(), functionObject
-              .optimizeForWrite());
+      return executeFunction(functionName, hasResult, hasResult, false);
+    } else {
+      byte registeredFunctionState = AbstractExecution.getFunctionState(functionObject.isHA(),
+          functionObject.hasResult(), functionObject.optimizeForWrite());
+
-  public ResultCollector execute(String functionName, boolean hasResult, boolean isHA) throws FunctionException {
+  public ResultCollector execute(String functionName, boolean hasResult, boolean isHA)
+      throws FunctionException {
-          LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH
-              .toLocalizedString());
+          LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH.toLocalizedString());
-      return executeFunction(functionName,hasResult, isHA, false);
-    }
-    else{
-      byte registeredFunctionState = AbstractExecution.getFunctionState(
-          functionObject.isHA(), functionObject.hasResult(), functionObject
-              .optimizeForWrite());
+      return executeFunction(functionName, hasResult, isHA, false);
+    } else {
+      byte registeredFunctionState = AbstractExecution.getFunctionState(functionObject.isHA(),
+          functionObject.hasResult(), functionObject.optimizeForWrite());
+
-  public ResultCollector execute(String functionName, boolean hasResult, boolean isHA, boolean isOptimizeForWrite) throws FunctionException {
+  public ResultCollector execute(String functionName, boolean hasResult, boolean isHA,
+      boolean isOptimizeForWrite) throws FunctionException {
-          LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH
-              .toLocalizedString());
+          LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH.toLocalizedString());
-      return executeFunction(functionName,hasResult, isHA, isOptimizeForWrite);
-    }
-    else {
-      byte registeredFunctionState = AbstractExecution.getFunctionState(
-          functionObject.isHA(), functionObject.hasResult(), functionObject
-              .optimizeForWrite());
+      return executeFunction(functionName, hasResult, isHA, isOptimizeForWrite);
+    } else {
+      byte registeredFunctionState = AbstractExecution.getFunctionState(functionObject.isHA(),
+          functionObject.hasResult(), functionObject.optimizeForWrite());
-      return executeFunction(functionObject);      
+      return executeFunction(functionObject);
-  
+
-  
- 
+
+

UPD66 UPD66
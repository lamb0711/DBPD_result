Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A limited functionality JSON parser. Its a DSF based JSON parser. It does not
- * create Object maps and serialize them like JSONObject. It just traverses an Object graph in
- * depth first search manner and appends key values to a String writer.
- * Hence we prevent creating a lot of garbage.
+ * A limited functionality JSON parser. Its a DSF based JSON parser. It does not create Object maps
+ * and serialize them like JSONObject. It just traverses an Object graph in depth first search
+ * manner and appends key values to a String writer. Hence we prevent creating a lot of garbage.
- * Although it has limited functionality,still a simple use of add() method
- * should suffice for most of the simple JSON use cases.
+ * Although it has limited functionality,still a simple use of add() method should suffice for most
+ * of the simple JSON use cases.
-  
-  Map<Object,List<Object>> forbidden = new java.util.IdentityHashMap<Object,List<Object>>();
+
+  Map<Object, List<Object>> forbidden = new java.util.IdentityHashMap<Object, List<Object>>();
-  
+
-  
+
-  
+
-    if(root == null || isPrimitiveOrWrapper(root.getClass())){
+    if (root == null || isPrimitiveOrWrapper(root.getClass())) {
-        
-        if(n == null){
+
+        if (n == null) {
-            if(list != null){
+            if (list != null) {
-            }else{
+            } else {
-            
+
- 
+
-   * TypedJson result = new TypedJson(); result.add(KEY,object); If users add
-   * more objects against the same key the newly added object will be appended
-   * to the existing key forming an array of objects.
+   * TypedJson result = new TypedJson(); result.add(KEY,object); If users add more objects against
+   * the same key the newly added object will be appended to the existing key forming an array of
+   * objects.
-   * @param key
-   *          Key against which an object will be added
-   * @param value
-   *          Object to be added
+   * @param key Key against which an object will be added
+   * @param value Object to be added
-        || klass.isAssignableFrom(java.util.Date.class) || klass.isAssignableFrom(java.math.BigDecimal.class);
+        || klass.isAssignableFrom(java.util.Date.class)
+        || klass.isAssignableFrom(java.math.BigDecimal.class);
-        || (object instanceof Struct) || (object instanceof Region.Entry) ){
+        || (object instanceof Struct) || (object instanceof Region.Entry)) {
-    if (isPrimitiveOrWrapper(clazz)) {      
+    if (isPrimitiveOrWrapper(clazz)) {
-      if(item != null){
+      if (item != null) {
-      }else{
+      } else {
-  
-  List<Object> getArrayChildren(Object object){
+
+  List<Object> getArrayChildren(Object object) {
-      
+
-    
+
-    
+
-    
+
-      }else{
+      } else {
-      }      
+      }
-      if(write)w.write('{');
+      if (write)
+        w.write('{');
-        if(write){
-          writeKeyValue(w, i, item, item !=null ? item.getClass() : null);
-        }else{
+        if (write) {
+          writeKeyValue(w, i, item, item != null ? item.getClass() : null);
+        } else {
-        
+
-      if(write)w.write('}');
+      if (write)
+        w.write('}');
-      if(write)w.write('{');
+      if (write)
+        w.write('{');
-        if(write){
-          writeKeyValue(w, e.getKey(), value, value !=null ? value.getClass(): null);
-        }else{
+        if (write) {
+          writeKeyValue(w, e.getKey(), value, value != null ? value.getClass() : null);
+        } else {
-      
+
-      if(write)w.write('}');
+      if (write)
+        w.write('}');
-      if(write)w.write('{');
+      if (write)
+        w.write('{');
-        if(write){
-          writeKeyValue(w, field, fieldValue, fieldValue !=null ? fieldValue.getClass() : null);
-        }else{
+        if (write) {
+          writeKeyValue(w, field, fieldValue, fieldValue != null ? fieldValue.getClass() : null);
+        } else {
-        
+
-      if(write)w.write('}');
+      if (write)
+        w.write('}');
-      if(write)w.write('{');
+      if (write)
+        w.write('{');
-        if(write){
-          writeKeyValue(w, fields[i], fieldValue, fieldValue !=null ? fieldValue.getClass() : null);
-        }else{
+        if (write) {
+          writeKeyValue(w, fields[i], fieldValue,
+              fieldValue != null ? fieldValue.getClass() : null);
+        } else {
-       
+
-      if(write)w.write('}');
+      if (write)
+        w.write('}');
-    
+
-     
-      if(write){
+
+      if (write) {
-        writeKeyValue(w, key, value, value !=null ? value.getClass() : null);
+        writeKeyValue(w, key, value, value != null ? value.getClass() : null);
-      }else{
+      } else {
-     
-     
+
+
-    
-    
+
+
+
-  String internalToExternal(Class clazz, Object value){
-    if(value != null && value instanceof Region.Entry){
+  String internalToExternal(Class clazz, Object value) {
+    if (value != null && value instanceof Region.Entry) {
-    if(value != null && value instanceof PdxInstance){
+    if (value != null && value instanceof PdxInstance) {
-    
+
- 
+
-    
+
-          if (key.length() > 0 && Character.isUpperCase(key.charAt(0)) && method.getParameterTypes().length == 0) {
+          if (key.length() > 0 && Character.isUpperCase(key.charAt(0))
+              && method.getParameterTypes().length == 0) {
-            if(write){
+            if (write) {
-              if(forbiddenList != null && forbiddenList.contains(result)){
+              if (forbiddenList != null && forbiddenList.contains(result)) {
-              }else{
+              } else {
-            }else{
+            } else {
-            
+
-  
-  
+
+
-   * This method returns method declared in a Class as well as all the super classes in the hierarchy.
-   * If class is a system class it wont include super class methods 
+   * This method returns method declared in a Class as well as all the super classes in the
+   * hierarchy. If class is a system class it wont include super class methods
-  Method[] getMethods(Object object){
+  Method[] getMethods(Object object) {
-    Map<String, Method> decMethodMap = new HashMap<String,Method>();
-    for(Method method : decMethods){
+    Map<String, Method> decMethodMap = new HashMap<String, Method>();
+    for (Method method : decMethods) {
-    
-    if(includeSuperClass){
+
+    if (includeSuperClass) {
-      for(Method method : allMethodList){
-        if(decMethodMap.get(method.getName()) != null){
-          //skip. This will ensure overriden methods wont be added again.
-        }else{
+      for (Method method : allMethodList) {
+        if (decMethodMap.get(method.getName()) != null) {
+          // skip. This will ensure overriden methods wont be added again.
+        } else {
-    
+
-   * @param number
-   *          A Number
+   * @param number A Number
-      case '\\':
-      case '"':
-        w.write('\\');
-        w.write(c);
-        break;
-      case '/':
-        if (b == '<') {
+        case '\\':
+        case '"':
-        }
-        w.write(c);
-        break;
-      case '\b':
-        w.write("\\b");
-        break;
-      case '\t':
-        w.write("\\t");
-        break;
-      case '\n':
-        w.write("\\n");
-        break;
-      case '\f':
-        w.write("\\f");
-        break;
-      case '\r':
-        w.write("\\r");
-        break;
-      default:
-        if (c < ' ' || (c >= '\u0080' && c < '\u00a0') || (c >= '\u2000' && c < '\u2100')) {
-          hhhh = "000" + Integer.toHexString(c);
-          w.write("\\u" + hhhh.substring(hhhh.length() - 4));
-        } else {
-        }
+          break;
+        case '/':
+          if (b == '<') {
+            w.write('\\');
+          }
+          w.write(c);
+          break;
+        case '\b':
+          w.write("\\b");
+          break;
+        case '\t':
+          w.write("\\t");
+          break;
+        case '\n':
+          w.write("\\n");
+          break;
+        case '\f':
+          w.write("\\f");
+          break;
+        case '\r':
+          w.write("\\r");
+          break;
+        default:
+          if (c < ' ' || (c >= '\u0080' && c < '\u00a0') || (c >= '\u2000' && c < '\u2100')) {
+            hhhh = "000" + Integer.toHexString(c);
+            w.write("\\u" + hhhh.substring(hhhh.length() - 4));
+          } else {
+            w.write(c);
+          }

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66
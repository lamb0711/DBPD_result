Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * RegionVersionVector tracks the highest region-level version number of
- * operations applied to a region for each member that has the region.<p>
+ * RegionVersionVector tracks the highest region-level version number of operations applied to a
+ * region for each member that has the region.
+ * <p>
-public abstract class RegionVersionVector<T extends VersionSource<?>> implements DataSerializableFixedID, MembershipListener {
-  
+public abstract class RegionVersionVector<T extends VersionSource<?>>
+    implements DataSerializableFixedID, MembershipListener {
+
-  public static boolean DEBUG = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "VersionVector.VERBOSE"); //TODO:LOG:CONVERT: REMOVE THIS
-  
-  
-  
-  ////////////////////  The following statics exist for unit testing. ////////////////////////////
-  
+  public static boolean DEBUG =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "VersionVector.VERBOSE"); // TODO:LOG:CONVERT:
+                                                                                       // REMOVE
+                                                                                       // THIS
+
+
+
+  //////////////////// The following statics exist for unit testing. ////////////////////////////
+
-  public static long MAX_DOMINANCE_WAIT_TIME = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "max-dominance-wait-time", 5000);
-  
+  public static long MAX_DOMINANCE_WAIT_TIME =
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "max-dominance-wait-time", 5000);
+
-  public static long DOMINANCE_PAUSE_TIME = Math.min(Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "dominance-pause-time", 300), MAX_DOMINANCE_WAIT_TIME);
-  
+  public static long DOMINANCE_PAUSE_TIME =
+      Math.min(Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "dominance-pause-time", 300),
+          MAX_DOMINANCE_WAIT_TIME);
+
-  
-  
-  /** map of member to version h older.  This is the actual version "vector" */
+
+
+  /** map of member to version h older. This is the actual version "vector" */
-   * The list of exceptions for the local member. The version held
-   * in this RegionVersionHolder may not be accurate, but the exception list
-   * is. We can have exceptions for our own id if we recover from disk
-   * or GII from a peer that has exceptions from us.
+   * The list of exceptions for the local member. The version held in this RegionVersionHolder may
+   * not be accurate, but the exception list is. We can have exceptions for our own id if we recover
+   * from disk or GII from a peer that has exceptions from us.
-   * The version held in this object can lag behind the localVersion atomic
-   * long, because that long is incremented without obtaining a lock.
-   * Operations that use the localException list are responsible for updating
-   * the version of the local exceptions under lock.
+   * The version held in this object can lag behind the localVersion atomic long, because that long
+   * is incremented without obtaining a lock. Operations that use the localException list are
+   * responsible for updating the version of the local exceptions under lock.
-  
+
-  
+
-  
-  
+
+
-   * a flag stating whether this vector contains only the version information
-   * for a single member.  This is used when a member crashed to transmit only
-   * the version information for that member.
+   * a flag stating whether this vector contains only the version information for a single member.
+   * This is used when a member crashed to transmit only the version information for that member.
-  
+
-  
+
-  
+
-  
+
-  private transient Map<T,T> canonicalIds = Collections.EMPTY_MAP;
-  
+  private transient Map<T, T> canonicalIds = Collections.EMPTY_MAP;
+
-  
+
-  
+
-  
+
-   * this read/write lock is used to stop generation of new versions by the vector
-   * while a region-level operation is underway.  The locking scheme assumes that
-   * only one region-level RVV operation is allowed at a time on a region across the
-   * distributed system.  If that changes then the locking scheme here may need
-   * additional work.
+   * this read/write lock is used to stop generation of new versions by the vector while a
+   * region-level operation is underway. The locking scheme assumes that only one region-level RVV
+   * operation is allowed at a time on a region across the distributed system. If that changes then
+   * the locking scheme here may need additional work.
-  private transient volatile boolean doUnlock; // this is only modified by the version locking thread
+  private transient volatile boolean doUnlock; // this is only modified by the version locking
+                                               // thread
-  
-  private transient final Object clearLockSync = new Object(); // sync for coordinating thread startup and lockOwner setting
+
+  private transient final Object clearLockSync = new Object(); // sync for coordinating thread
+                                                               // startup and lockOwner setting
-  
+
-    this.regionName = owner == null? "" : "region " + owner.getFullPath();
-    
+    this.regionName = owner == null ? "" : "region " + owner.getFullPath();
+
-    this.memberToVersion = new ConcurrentHashMap<T, RegionVersionHolder<T>>(INITIAL_CAPACITY, LOAD_FACTOR, CONCURRENCY_LEVEL);
-    this.memberToGCVersion = new ConcurrentHashMap<T, Long> (INITIAL_CAPACITY, LOAD_FACTOR, CONCURRENCY_LEVEL);
+    this.memberToVersion = new ConcurrentHashMap<T, RegionVersionHolder<T>>(INITIAL_CAPACITY,
+        LOAD_FACTOR, CONCURRENCY_LEVEL);
+    this.memberToGCVersion =
+        new ConcurrentHashMap<T, Long>(INITIAL_CAPACITY, LOAD_FACTOR, CONCURRENCY_LEVEL);
-  
+
-   * Retrieve a vector that can be sent to another member.  This clones all
-   * of the version information to protect against concurrent modification
-   * during serialization
+   * Retrieve a vector that can be sent to another member. This clones all of the version
+   * information to protect against concurrent modification during serialization
-    Map<T,RegionVersionHolder<T>> liveHolders;
-    liveHolders = new HashMap<T,RegionVersionHolder<T>>(this.memberToVersion);
-    ConcurrentHashMap<T, RegionVersionHolder<T>> clonedHolders = new ConcurrentHashMap<T, RegionVersionHolder<T>>(
-        liveHolders.size(), LOAD_FACTOR, CONCURRENCY_LEVEL);
-    for (Map.Entry<T, RegionVersionHolder<T>> entry: liveHolders.entrySet()) {
+    Map<T, RegionVersionHolder<T>> liveHolders;
+    liveHolders = new HashMap<T, RegionVersionHolder<T>>(this.memberToVersion);
+    ConcurrentHashMap<T, RegionVersionHolder<T>> clonedHolders =
+        new ConcurrentHashMap<T, RegionVersionHolder<T>>(liveHolders.size(), LOAD_FACTOR,
+            CONCURRENCY_LEVEL);
+    for (Map.Entry<T, RegionVersionHolder<T>> entry : liveHolders.entrySet()) {
-    RegionVersionHolder<T>  clonedLocalHolder;
+    RegionVersionHolder<T> clonedLocalHolder;
-    //Make sure the holder that we send to the peer does
-    //have an accurate RegionVersionHolder for our local version
-    return createCopy(this.myId, clonedHolders, this.localVersion.get(),
-        gcVersions, this.localGCVersion.get(), false, 
-        clonedLocalHolder);
+    // Make sure the holder that we send to the peer does
+    // have an accurate RegionVersionHolder for our local version
+    return createCopy(this.myId, clonedHolders, this.localVersion.get(), gcVersions,
+        this.localGCVersion.get(), false, clonedLocalHolder);
-  
+
-  
+
-   * Retrieve a vector that can be sent to another member.  This clones only
-   * the version information for the given ID.<p>
-   * The clone returned by this method does not have distributed garbage-collection
-   * information.
+   * Retrieve a vector that can be sent to another member. This clones only the version information
+   * for the given ID.
+   * <p>
+   * The clone returned by this method does not have distributed garbage-collection information.
-    Map<T,RegionVersionHolder<T>> liveHolders;
+    Map<T, RegionVersionHolder<T>> liveHolders;
-    return createCopy(
-        this.myId,
-        new ConcurrentHashMap<T, RegionVersionHolder<T>>(Collections.singletonMap(mbr, holder)),
-        0,
-        new ConcurrentHashMap<T, Long>(INITIAL_CAPACITY, LOAD_FACTOR, CONCURRENCY_LEVEL),
-        0, true,
+    return createCopy(this.myId,
+        new ConcurrentHashMap<T, RegionVersionHolder<T>>(Collections.singletonMap(mbr, holder)), 0,
+        new ConcurrentHashMap<T, Long>(INITIAL_CAPACITY, LOAD_FACTOR, CONCURRENCY_LEVEL), 0, true,
-  
+
-    synchronized(memberToGCVersion) {
+    synchronized (memberToGCVersion) {
-  
+
-    synchronized(this.memberToGCVersion) {
-      for (Map.Entry<T, Long> entry: regionGCVersions.entrySet()) {
+    synchronized (this.memberToGCVersion) {
+      for (Map.Entry<T, Long> entry : regionGCVersions.entrySet()) {
-  
-  /** locks against new version generation and returns the current region version number 
-   * @param regionPath 
+
+  /**
+   * locks against new version generation and returns the current region version number
+   * 
+   * @param regionPath
-  
+
-    synchronized(this.clearLockSync) { 
+    synchronized (this.clearLockSync) {
-      if(instance != null && logger.isDebugEnabled()) {
-        logger.debug("Unlocking for clear, from member {} RVV {}", locker, System.identityHashCode(this));
+      if (instance != null && logger.isDebugEnabled()) {
+        logger.debug("Unlocking for clear, from member {} RVV {}", locker,
+            System.identityHashCode(this));
-        if(instance != null && logger.isDebugEnabled()) {
+        if (instance != null && logger.isDebugEnabled()) {
-  
+
-   * This schedules a thread that owns the version-generation write-lock for this
-   * vector.  The method unlockVersionGeneration notifies the thread to release
-   * the lock and terminate its run.
-   * @param regionPath 
+   * This schedules a thread that owns the version-generation write-lock for this vector. The method
+   * unlockVersionGeneration notifies the thread to release the lock and terminate its run.
+   * 
+   * @param regionPath
-  private void lockVersionGeneration(final String regionPath, final DM dm, final InternalDistributedMember locker) {
+  private void lockVersionGeneration(final String regionPath, final DM dm,
+      final InternalDistributedMember locker) {
-      logger.debug("Locking version generation for {} region {} RVV {}", locker, regionPath, System.identityHashCode(this));
+      logger.debug("Locking version generation for {} region {} RVV {}", locker, regionPath,
+          System.identityHashCode(this));
-    dm.getWaitingThreadPool().execute(
-      new Runnable() {
-      @edu.umd.cs.findbugs.annotations.SuppressWarnings(value={"UL_UNRELEASED_LOCK","IMSE_DONT_CATCH_IMSE"})
+    dm.getWaitingThreadPool().execute(new Runnable() {
+      @edu.umd.cs.findbugs.annotations.SuppressWarnings(
+          value = {"UL_UNRELEASED_LOCK", "IMSE_DONT_CATCH_IMSE"})
-        synchronized(clearLockSync) {
+        synchronized (clearLockSync) {
-            while(locked && dm.isCurrentMember(locker)) {
+            while (locked && dm.isCurrentMember(locker)) {
-              logger.debug("Waiting thread is now locking version generation for {} region {} RVV {}", locker, regionPath, System.identityHashCode(this));
+              logger.debug(
+                  "Waiting thread is now locking version generation for {} region {} RVV {}",
+                  locker, regionPath, System.identityHashCode(this));
-            }
-            catch (IllegalMonitorStateException e) {
+            } catch (IllegalMonitorStateException e) {
-              logger.fatal(LocalizedMessage.create(LocalizedStrings.RVV_LOCKING_CONFUSED, new Object[]{locker, lockOwner}));
+              logger.fatal(LocalizedMessage.create(LocalizedStrings.RVV_LOCKING_CONFUSED,
+                  new Object[] {locker, lockOwner}));
-    while(dm.isCurrentMember(locker)) {
+    while (dm.isCurrentMember(locker)) {
-        if(acquiredLock.await(250, TimeUnit.MILLISECONDS)) {
+        if (acquiredLock.await(250, TimeUnit.MILLISECONDS)) {
-    if(interrupted) {
+    if (interrupted) {
-    
+
-  
+
-    synchronized(clearLockSync) {
+    synchronized (clearLockSync) {
-  
+
-  
+
-   * return the next local version number for a clear() operation,
-   * bypassing lock checks
+   * return the next local version number for a clear() operation, bypassing lock checks
-  
+
-      // this should never be the case.  If version generation is locked and we get here
+      // this should never be the case. If version generation is locked and we get here
-        logger.debug("Generating a version tag when version generation is locked by {}", this.lockOwner);
+        logger.debug("Generating a version tag when version generation is locked by {}",
+            this.lockOwner);
-  
+
-  
+
-  
+
-    
+
-    synchronized(localExceptions) {
+    synchronized (localExceptions) {
-          logger.debug("Adjust localExceptions.version {} to equal localVersion {}", localExceptions.version, localVersion.get());
+          logger.debug("Adjust localExceptions.version {} to equal localVersion {}",
+              localExceptions.version, localVersion.get());
-  
+
-    synchronized(localExceptions) {
+    synchronized (localExceptions) {
-  
+
-    } 
+    }
-  
-  
+
+
-   * turns off recording of versions for this vector.  This can be used when
-   * recording of versions is not necessary, as in an empty region
+   * turns off recording of versions for this vector. This can be used when recording of versions is
+   * not necessary, as in an empty region
-  
+
-   * client version vectors only record GC numbers and don't keep exceptions, etc, because
-   * there could be MANY of them
+   * client version vectors only record GC numbers and don't keep exceptions, etc, because there
+   * could be MANY of them
-  
+
-    synchronized(this.memberToVersion) {
-      for (Map.Entry<T, RegionVersionHolder<T>> entry: otherVector.getMemberToVersion().entrySet()) {
+    synchronized (this.memberToVersion) {
+      for (Map.Entry<T, RegionVersionHolder<T>> entry : otherVector.getMemberToVersion()
+          .entrySet()) {
-        
+
-      //Get the set of local exceptions from the other vector
+      // Get the set of local exceptions from the other vector
-      
-      if (otherVector.getCurrentVersion() > 0 &&
-          !this.memberToVersion.containsKey(otherVector.getOwnerId())) {
+
+      if (otherVector.getCurrentVersion() > 0
+          && !this.memberToVersion.containsKey(otherVector.getOwnerId())) {
-      
+
-      for (T mbr: this.memberToVersion.keySet()) {
-        if (!otherVector.memberToVersion.containsKey(mbr) && !mbr.equals(otherVector.getOwnerId())) {
+      for (T mbr : this.memberToVersion.keySet()) {
+        if (!otherVector.memberToVersion.containsKey(mbr)
+            && !mbr.equals(otherVector.getOwnerId())) {
-      if (!otherVector.memberToVersion.containsKey(myId) && !myId.equals(otherVector.getOwnerId())) {
+      if (!otherVector.memberToVersion.containsKey(myId)
+          && !myId.equals(otherVector.getOwnerId())) {
-      
-      synchronized(this.memberToGCVersion) {
-        for (Map.Entry<T, Long> entry: otherVector.getMemberToGCVersion().entrySet()) {
+
+      synchronized (this.memberToGCVersion) {
+        for (Map.Entry<T, Long> entry : otherVector.getMemberToGCVersion().entrySet()) {
-          if(member.equals(myId)) {
-            //If this entry is for our id, update our local GC version
+          if (member.equals(myId)) {
+            // If this entry is for our id, update our local GC version
-            while((currentValue = localGCVersion.get()) < value) {
+            while ((currentValue = localGCVersion.get()) < value) {
-            //Update the memberToGCVersionMap.
+            // Update the memberToGCVersionMap.
-  
+
-  
-  
-  
+
+
+
-   * Records a received region-version.  These are transmitted in VersionTags
-   * in messages between peers and from servers to clients.
+   * Records a received region-version. These are transmitted in VersionTags in messages between
+   * peers and from servers to clients.
+   * 
-    if(member == null) {
+    if (member == null) {
-    
-    if(this.myId.equals(member)) {
-      //We can be asked to record a version for the local member if a persistent
-      //member is restarted and an event is replayed after the persistent member
-      //recovers. So we can only assert that the local member has already seen
-      //the replayed event.
-      synchronized(localExceptions) {
-        if(this.localVersion.get() < tag.getRegionVersion()) {
+
+    if (this.myId.equals(member)) {
+      // We can be asked to record a version for the local member if a persistent
+      // member is restarted and an event is replayed after the persistent member
+      // recovers. So we can only assert that the local member has already seen
+      // the replayed event.
+      synchronized (localExceptions) {
+        if (this.localVersion.get() < tag.getRegionVersion()) {
-                "recordVersion invoked for a local version tag that is higher than our local version. rvv=" 
-                + this + ", tag=" + tag + " " + regionName);
+              "recordVersion invoked for a local version tag that is higher than our local version. rvv="
+                  + this + ", tag=" + tag + " " + regionName);
-    
+
-  
+
-   * Records a received region-version.  These are transmitted in VersionTags
-   * in messages between peers and from servers to clients.  In general you
-   * should use recordVersion(mbr, versionTag) so that the tag is marked as having
-   * been recorded.  This will keep DistributedCacheOperation.basicProcess()
-   * from trying to record it again.
+   * Records a received region-version. These are transmitted in VersionTags in messages between
+   * peers and from servers to clients. In general you should use recordVersion(mbr, versionTag) so
+   * that the tag is marked as having been recorded. This will keep
+   * DistributedCacheOperation.basicProcess() from trying to record it again.
-    
+
-    
+
-    
+
-      //If we are recording a version for the local member,
-      //use the local exception list.
+      // If we are recording a version for the local member,
+      // use the local exception list.
-      
-      synchronized(holder) {
-        //Advance the version held in the local
-        //exception list to match the atomic long
-        //we using for the local version.
+
+      synchronized (holder) {
+        // Advance the version held in the local
+        // exception list to match the atomic long
+        // we using for the local version.
-    } else { 
-      //Find the version holder object
+    } else {
+      // Find the version holder object
-        synchronized(memberToVersion) {
-          //Look for the holder under lock
+        synchronized (memberToVersion) {
+          // Look for the holder under lock
-    
-    //Update the version holder
+
+    // Update the version holder
-  
-  
-  
+
+
+
-   * Records a version holder that we have recovered from disk. This
-   * version holder replaces the current version holder if it dominates
-   * the version holder we already have. This method will called once for
-   * each oplog we recover.
-   * @param latestOplog 
+   * Records a version holder that we have recovered from disk. This version holder replaces the
+   * current version holder if it dominates the version holder we already have. This method will
+   * called once for each oplog we recover.
+   * 
+   * @param latestOplog
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD",
-      justification="sync on localExceptions guards concurrent modification but this is a replacement")
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(
+      value = "ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD",
+      justification = "sync on localExceptions guards concurrent modification but this is a replacement")
-    
-    if(member == null || member.equals(myId)) {
-      //if this is the version for the local member, update our local info
-      
-      //update the local exceptions
-      synchronized(localExceptions) {
-        //Fix for 45622 - We only take the version holder from the latest
-        //oplog. There may be more than one RVV in the latest oplog, in which
-        //case we want to end up with the last RVV from the latest oplog
-        if(latestOplog || localVersion.get() == 0) {
+
+    if (member == null || member.equals(myId)) {
+      // if this is the version for the local member, update our local info
+
+      // update the local exceptions
+      synchronized (localExceptions) {
+        // Fix for 45622 - We only take the version holder from the latest
+        // oplog. There may be more than one RVV in the latest oplog, in which
+        // case we want to end up with the last RVV from the latest oplog
+        if (latestOplog || localVersion.get() == 0) {
-            logger.trace(LogMarker.RVV, "initRecoveredVersion setting local version to {}", recovered.version);
+            logger.trace(LogMarker.RVV, "initRecoveredVersion setting local version to {}",
+                recovered.version);
-      //If this is not a local member, update the member to version map
+      // If this is not a local member, update the member to version map
-      synchronized(memberToVersion) {
+      synchronized (memberToVersion) {
-      //Fix for 45622 - We only take the version holder from the latest
-        //oplog. There may be more than one RVV in the latest oplog, in which
-        //case we want to end up with the last RVV from the latest oplog
-        if(latestOplog || oldVersion == null || oldVersion.version == 0) {
-          if(gcVersion != null) {
+        // Fix for 45622 - We only take the version holder from the latest
+        // oplog. There may be more than one RVV in the latest oplog, in which
+        // case we want to end up with the last RVV from the latest oplog
+        if (latestOplog || oldVersion == null || oldVersion.version == 0) {
+          if (gcVersion != null) {
-      if(mbr.equals(myId)) {
+      if (mbr.equals(myId)) {
-  
+
-   * Returns a list of the members that have been marked as having left the
-   * system.
+   * Returns a list of the members that have been marked as having left the system.
-    synchronized(this.memberToVersion) {
+    synchronized (this.memberToVersion) {
-      for (RegionVersionHolder<T> h: this.memberToVersion.values()) {
+      for (RegionVersionHolder<T> h : this.memberToVersion.values()) {
-          result.add((T)h.id);
+          result.add((T) h.id);
-  
+
-      if(getCurrentVersion() < version) {
+      if (getCurrentVersion() < version) {
-  
+
-   * Removes departed members not in the given collection of IDs from the
-   * version vector
+   * Removes departed members not in the given collection of IDs from the version vector
+   * 
-    synchronized(this.memberToVersion) {
-      for (Iterator<Map.Entry<T, RegionVersionHolder<T>>> it
-          = this.memberToVersion.entrySet().iterator(); it.hasNext(); ) {
+    synchronized (this.memberToVersion) {
+      for (Iterator<Map.Entry<T, RegionVersionHolder<T>>> it =
+          this.memberToVersion.entrySet().iterator(); it.hasNext();) {
-            synchronized(this.canonicalIdLock) {
+            synchronized (this.canonicalIdLock) {
-  
-  
-  
+
+
+
-    if (this.memberToVersion.containsKey(id)) return true;
-    if (this.memberToGCVersion.containsKey(id)) return true;
-    if (this.canonicalIds.containsKey(id)) return true;
+    if (this.memberToVersion.containsKey(id))
+      return true;
+    if (this.memberToGCVersion.containsKey(id))
+      return true;
+    if (this.canonicalIds.containsKey(id))
+      return true;
-   * This marks the given entry as departed, making it eligible to be
-   * removed during an operation like DistributedRegion.synchronizeWith()
+   * This marks the given entry as departed, making it eligible to be removed during an operation
+   * like DistributedRegion.synchronizeWith()
-    synchronized(this.memberToVersion) {
+    synchronized (this.memberToVersion) {
-  
+
-   * check to see if tombstone removal in this RVV indicates that tombstones
-   * have been removed from its Region that have not been removed from the
-   * argument's Region.  If this is the case, then a delta GII may leave
-   * entries in the other RVV's Region that should be deleted.
+   * check to see if tombstone removal in this RVV indicates that tombstones have been removed from
+   * its Region that have not been removed from the argument's Region. If this is the case, then a
+   * delta GII may leave entries in the other RVV's Region that should be deleted.
+   * 
-   * @return true if there have been tombstone removals in this vector's Region
-   *         that were not done in the argument's region
+   * @return true if there have been tombstone removals in this vector's Region that were not done
+   *         in the argument's region
-        return true; // this vector has removed locally created tombstones that the other hasn't reaped
+        return true; // this vector has removed locally created tombstones that the other hasn't
+                     // reaped
-    for (T mbr: this.memberToGCVersion.keySet()) {
+    for (T mbr : this.memberToGCVersion.keySet()) {
-    // vector.  If this happens we don't know if tombstones were removed
-    for (T id: other.memberToGCVersion.keySet()) {
+    // vector. If this happens we don't know if tombstones were removed
+    for (T id : other.memberToGCVersion.keySet()) {
-    for (Map.Entry<T, Long> entry: other.memberToGCVersion.entrySet()) {
+    for (Map.Entry<T, Long> entry : other.memberToGCVersion.entrySet()) {
-            return true;
+          return true;
-  
+
-   * Test to see if this vector's region may be able to provide updates
-   * that the given vector has not seen.  This method assumes that the argument
-   * is not a live vector and requires no synchronization.
+   * Test to see if this vector's region may be able to provide updates that the given vector has
+   * not seen. This method assumes that the argument is not a live vector and requires no
+   * synchronization.
-      // do the diff for only a single member.  This is typically a member that
+      // do the diff for only a single member. This is typically a member that
-      Map.Entry<T,RegionVersionHolder<T>> entry
-                        = other.memberToVersion.entrySet().iterator().next();
+      Map.Entry<T, RegionVersionHolder<T>> entry =
+          other.memberToVersion.entrySet().iterator().next();
-    for (Map.Entry<T, RegionVersionHolder<T>> entry: this.memberToVersion.entrySet()) {
+    for (Map.Entry<T, RegionVersionHolder<T>> entry : this.memberToVersion.entrySet()) {
-      } else if (mbr.equals(other.getOwnerId())){
+      } else if (mbr.equals(other.getOwnerId())) {
-  
-  private boolean isGCVersionDominatedByHolder(Long gcVersion, RegionVersionHolder<T>otherHolder) {
+
+  private boolean isGCVersionDominatedByHolder(Long gcVersion, RegionVersionHolder<T> otherHolder) {
-      RegionVersionHolder<T> holder = new RegionVersionHolder<T>(gcVersion.longValue());      
+      RegionVersionHolder<T> holder = new RegionVersionHolder<T>(gcVersion.longValue());
-  
+
-   * Test to see if this vector's rvvgc has updates that has not seen. 
+   * Test to see if this vector's rvvgc has updates that has not seen.
-      // do the diff for only a single member.  This is typically a member that
+      // do the diff for only a single member. This is typically a member that
-      Map.Entry<T,RegionVersionHolder<T>> entry
-                        = other.memberToVersion.entrySet().iterator().next();
- 
+      Map.Entry<T, RegionVersionHolder<T>> entry =
+          other.memberToVersion.entrySet().iterator().next();
+
-    
+
-    
-    for (Map.Entry<T, Long> entry: this.memberToGCVersion.entrySet()) {
+
+    for (Map.Entry<T, Long> entry : this.memberToGCVersion.entrySet()) {
-  
+
-   * wait for this vector to dominate the given vector.  This means that
-   * the receiver has seen all version changes that the given vector has seen.
+   * wait for this vector to dominate the given vector. This means that the receiver has seen all
+   * version changes that the given vector has seen.
-          waitTimeRemaining = MAX_DOMINANCE_WAIT_TIME - (now-startTime);
+          waitTimeRemaining = MAX_DOMINANCE_WAIT_TIME - (now - startTime);
-  
-  
+
+
-  
+
-   * Remove any exceptions for the given member that are older than the given version.
-   * This is used after a synchronization operation to get rid of unneeded history.
+   * Remove any exceptions for the given member that are older than the given version. This is used
+   * after a synchronization operation to get rid of unneeded history.
+   * 
-      synchronized(holder) {
+      synchronized (holder) {
-  
+
-   * This is used by clear() while version generation is locked to remove old
-   * exceptions and update the GC vector to be the same as the current version vector
+   * This is used by clear() while version generation is locked to remove old exceptions and update
+   * the GC vector to be the same as the current version vector
-    synchronized(this.memberToVersion) {
+    synchronized (this.memberToVersion) {
-      for (Map.Entry<T, RegionVersionHolder<T>> entry: this.memberToVersion.entrySet()) {
+      for (Map.Entry<T, RegionVersionHolder<T>> entry : this.memberToVersion.entrySet()) {
-        synchronized(this.localExceptions) {
+        synchronized (this.localExceptions) {
-    if(mbr.equals(this.myId)) {
+    if (mbr.equals(this.myId)) {
-  
-  /** constructor used to create a cloned vector 
-   * @param localExceptions */
-  protected RegionVersionVector(T ownerId,
-      ConcurrentHashMap<T, RegionVersionHolder<T>> vector, long version,
-      ConcurrentHashMap<T, Long> gcVersions, long gcVersion, boolean singleMember,
+
+  /**
+   * constructor used to create a cloned vector
+   * 
+   * @param localExceptions
+   */
+  protected RegionVersionVector(T ownerId, ConcurrentHashMap<T, RegionVersionHolder<T>> vector,
+      long version, ConcurrentHashMap<T, Long> gcVersions, long gcVersion, boolean singleMember,
-  
+
-    this.memberToVersion = new ConcurrentHashMap<T, RegionVersionHolder<T>>(INITIAL_CAPACITY, LOAD_FACTOR, CONCURRENCY_LEVEL);
-    this.memberToGCVersion = new ConcurrentHashMap<T, Long>(INITIAL_CAPACITY, LOAD_FACTOR, CONCURRENCY_LEVEL);
+    this.memberToVersion = new ConcurrentHashMap<T, RegionVersionHolder<T>>(INITIAL_CAPACITY,
+        LOAD_FACTOR, CONCURRENCY_LEVEL);
+    this.memberToGCVersion =
+        new ConcurrentHashMap<T, Long>(INITIAL_CAPACITY, LOAD_FACTOR, CONCURRENCY_LEVEL);
-  
+
-   * after deserializing a version tag or RVV the IDs in it should be replaced
-   * with references to IDs returned by this method.  This vastly reduces the
-   * memory footprint of tags/stamps/rvvs
+   * after deserializing a version tag or RVV the IDs in it should be replaced with references to
+   * IDs returned by this method. This vastly reduces the memory footprint of tags/stamps/rvvs
+   * 
-          can = (T)system.getDistributionManager().getCanonicalId((InternalDistributedMember)id);
+          can = (T) system.getDistributionManager().getCanonicalId((InternalDistributedMember) id);
-      synchronized(this.canonicalIdLock) {
-        HashMap<T,T> tmp = new HashMap<T,T>(this.canonicalIds);
+      synchronized (this.canonicalIdLock) {
+        HashMap<T, T> tmp = new HashMap<T, T>(this.canonicalIds);
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-    writeMember(this.myId,out);
+    writeMember(this.myId, out);
-    for (Map.Entry<T,RegionVersionHolder<T>> entry: this.memberToVersion.entrySet()) {
-      writeMember(entry.getKey(),out);
+    for (Map.Entry<T, RegionVersionHolder<T>> entry : this.memberToVersion.entrySet()) {
+      writeMember(entry.getKey(), out);
-    for (Map.Entry<T, Long> entry: this.memberToGCVersion.entrySet()) {
-      writeMember(entry.getKey(),out);
+    for (Map.Entry<T, Long> entry : this.memberToGCVersion.entrySet()) {
+      writeMember(entry.getKey(), out);
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-    for (int i=0; i<numHolders; i++) {
+    for (int i = 0; i < numHolders; i++) {
-    for (int i=0; i<numGCVersions; i++) {
+    for (int i = 0; i < numGCVersions; i++) {
-  
+
+
-  
+
-   * When a tombstone is removed from the entry map this method must be called
-   * to record the max region-version of any tombstone reaped.  Any older versions
-   * are then immediately eligible for reaping.
+   * When a tombstone is removed from the entry map this method must be called to record the max
+   * region-version of any tombstone reaped. Any older versions are then immediately eligible for
+   * reaping.
+   * 
-    if(mbr == null) {
+    if (mbr == null) {
-    //record the GC version to make sure we know we have seen this version
-    //during recovery, this will prevent us from recording exceptions
-    //for entries less than the GC version.
+    // record the GC version to make sure we know we have seen this version
+    // during recovery, this will prevent us from recording exceptions
+    // for entries less than the GC version.
-      synchronized(this.memberToGCVersion) {
+      synchronized (this.memberToGCVersion) {
-  
+
+   * 
-    for (Map.Entry<T, Long> entry: other.memberToGCVersion.entrySet()) {
+    for (Map.Entry<T, Long> entry : other.memberToGCVersion.entrySet()) {
-  
+
-   * returns true if tombstones newer than the given version have already been reaped.
-   * This means that a clear or GC has been received that should have wiped out the
-   * operation this version stamp represents, but this operation had not yet been
-   * received
+   * returns true if tombstones newer than the given version have already been reaped. This means
+   * that a clear or GC has been received that should have wiped out the operation this version
+   * stamp represents, but this operation had not yet been received
+   * 
-    if(mbr == null || mbr.equals(myId)) {
+    if (mbr == null || mbr.equals(myId)) {
-  
+
-   * returns the highest region-version of any tombstone owned by the given
-   * member that was reaped in this vector's region 
+   * returns the highest region-version of any tombstone owned by the given member that was reaped
+   * in this vector's region
-    if (mbr == null || mbr.equals(this.myId)){ 
+    if (mbr == null || mbr.equals(this.myId)) {
-      synchronized(this.memberToGCVersion) {
+      synchronized (this.memberToGCVersion) {
-  
+
-   * Get a map of the member to the version and exception list for that member,
-   * including the local member.
+   * Get a map of the member to the version and exception list for that member, including the local
+   * member.
-    HashMap<T, RegionVersionHolder<T>> results = new HashMap<T, RegionVersionHolder<T>>(memberToVersion);
+    HashMap<T, RegionVersionHolder<T>> results =
+        new HashMap<T, RegionVersionHolder<T>>(memberToVersion);
-  
+
-   * Get a map of member to the GC version of that member, including
-   * the local member. 
+   * Get a map of member to the GC version of that member, including the local member.
-    if(localGCVersion.get() > 0) {
+    if (localGCVersion.get() > 0) {
-  
+
-   * Remove an exceptions that are older than the current GC version
-   * for each member in the RVV.
+   * Remove an exceptions that are older than the current GC version for each member in the RVV.
-    
-    for(T member: members) {
+
+    for (T member : members) {
-      
+
-      holder =memberToVersion.get(member);
-      
-      if(holder != null && gcVersion != null) {
-        synchronized(holder) {
+      holder = memberToVersion.get(member);
+
+      if (holder != null && gcVersion != null) {
+        synchronized (holder) {
-    
+
-  
+
-      return "RegionVersionVector{rv"+this.localVersion+" gc"+this.localGCVersion+"}@"+System.identityHashCode(this);
+      return "RegionVersionVector{rv" + this.localVersion + " gc" + this.localGCVersion + "}@"
+          + System.identityHashCode(this);
-    sb.append("RegionVersionVector[")
-      .append(this.myId)
-      .append("={rv").append(this.localExceptions.version).append(" gc"+this.localGCVersion).append(" localVersion="+this.localVersion);
+    sb.append("RegionVersionVector[").append(this.myId).append("={rv")
+        .append(this.localExceptions.version).append(" gc" + this.localGCVersion)
+        .append(" localVersion=" + this.localVersion);
-      sb.append(" local exceptions="+this.localExceptions.exceptionsToString());
+      sb.append(" local exceptions=" + this.localExceptions.exceptionsToString());
-  public void memberJoined(InternalDistributedMember id) { }
-  public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected, String reason) {  }
-  public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {  }
+  public void memberJoined(InternalDistributedMember id) {}
-  /* 
-   * (non-Javadoc)
-   * this ensures that the version generation lock is released
-   * @see org.apache.geode.distributed.internal.MembershipListener#memberDeparted(org.apache.geode.distributed.internal.membership.InternalDistributedMember, boolean)
+  public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected,
+      String reason) {}
+
+  public void quorumLost(Set<InternalDistributedMember> failures,
+      List<InternalDistributedMember> remaining) {}
+
+  /*
+   * (non-Javadoc) this ensures that the version generation lock is released
+   * 
+   * @see org.apache.geode.distributed.internal.MembershipListener#memberDeparted(org.apache.geode.
+   * distributed.internal.membership.InternalDistributedMember, boolean)
-    if(versionMember instanceof DiskStoreID)  {
-      return new DiskRegionVersionVector((DiskStoreID)versionMember, owner);
+    if (versionMember instanceof DiskStoreID) {
+      return new DiskRegionVersionVector((DiskStoreID) versionMember, owner);
-      return new VMRegionVersionVector((InternalDistributedMember)versionMember, owner);
+      return new VMRegionVersionVector((InternalDistributedMember) versionMember, owner);
-  
+
-   * For test purposes, see if two RVVs have seen the same events
-   * and GC version vectors
+   * For test purposes, see if two RVVs have seen the same events and GC version vectors
+   * 
-    //Compare the version version vectors
+    // Compare the version version vectors
-    
+
-    for (Iterator<T> it = myMemberToVersion.keySet().iterator(); it.hasNext(); ) {
+    for (Iterator<T> it = myMemberToVersion.keySet().iterator(); it.hasNext();) {
-    
+
-    
-    if(!myGCVersion.equals(otherGCVersion)) {
+
+    if (!myGCVersion.equals(otherGCVersion)) {
-    
+
-  
+
-   * Note: test only. 
-   * If put in production will cause ConcurrentModificationException
-   * see if two RVVs have seen the same events and GC version vectors
-   * This will treat member with null version the same as member with version=0
+   * Note: test only. If put in production will cause ConcurrentModificationException see if two
+   * RVVs have seen the same events and GC version vectors This will treat member with null version
+   * the same as member with version=0
+   * 
-  
-  
+
+
-   * @return true if this vector represents the entry for a single member
-   * to be used in synchronizing caches for that member in the case of 
-   * a crash.  Otherwise return false.
+   * @return true if this vector represents the entry for a single member to be used in
+   *         synchronizing caches for that member in the case of a crash. Otherwise return false.
-  
+
-  public Version[] getSerializationVersions(){
+  public Version[] getSerializationVersions() {
-  
-//  /**
-//   * This class will wrap DM member IDs to provide integers that can be stored
-//   * on disk and be timed out in the vector.
-//   * 
-//   *
-//   */
-//  static class RVVMember implements Comparable {
-//    private static AtomicLong NextId = new AtomicLong();
-//    T memberId;
-//    long timeAdded;
-//    long internalId;
-//    
-//    RVVMember(T m, long timeAdded, long internalId) {
-//      this.memberId = m;
-//      this.timeAdded = timeAdded;
-//      this.internalId = internalId;
-//      if (NextId.get() < internalId) {
-//        NextId.set(internalId);
-//      }
-//    }
-//    
-//    RVVMember(T m) {
-//      this.memberId = m;
-//      this.timeAdded = System.currentTimeMillis();
-//      this.internalId = NextId.incrementAndGet();
-//    }
-//
-//    public int compareTo(Object o) {
-//      if (o instanceof T) {
-//        return -((T)o).compareTo(this.memberId);
-//      } else {
-//        return this.memberId.compareTo(((RVVMember)o).memberId);
-//      }
-//    }
-//
-//    @Override
-//    public int hashCode() {
-//      return this.memberId.hashCode();
-//    }
-//    
-//    @Override
-//    public boolean equals(Object o) {
-//      if (o instanceof T) {
-//        return ((T)o).equals(this.memberId);
-//      } else {
-//        return this.memberId.equals(((RVVMember)o).memberId);
-//      }
-//    }
-//    
-//    @Override
-//    public String toString() {
-//      return "vID(#"+this.internalId+"; time="+this.timeAdded+"; id="+this.memberId+")";
-//    }
-//  }
+
+  // /**
+  // * This class will wrap DM member IDs to provide integers that can be stored
+  // * on disk and be timed out in the vector.
+  // *
+  // *
+  // */
+  // static class RVVMember implements Comparable {
+  // private static AtomicLong NextId = new AtomicLong();
+  // T memberId;
+  // long timeAdded;
+  // long internalId;
+  //
+  // RVVMember(T m, long timeAdded, long internalId) {
+  // this.memberId = m;
+  // this.timeAdded = timeAdded;
+  // this.internalId = internalId;
+  // if (NextId.get() < internalId) {
+  // NextId.set(internalId);
+  // }
+  // }
+  //
+  // RVVMember(T m) {
+  // this.memberId = m;
+  // this.timeAdded = System.currentTimeMillis();
+  // this.internalId = NextId.incrementAndGet();
+  // }
+  //
+  // public int compareTo(Object o) {
+  // if (o instanceof T) {
+  // return -((T)o).compareTo(this.memberId);
+  // } else {
+  // return this.memberId.compareTo(((RVVMember)o).memberId);
+  // }
+  // }
+  //
+  // @Override
+  // public int hashCode() {
+  // return this.memberId.hashCode();
+  // }
+  //
+  // @Override
+  // public boolean equals(Object o) {
+  // if (o instanceof T) {
+  // return ((T)o).equals(this.memberId);
+  // } else {
+  // return this.memberId.equals(((RVVMember)o).memberId);
+  // }
+  // }
+  //
+  // @Override
+  // public String toString() {
+  // return "vID(#"+this.internalId+"; time="+this.timeAdded+"; id="+this.memberId+")";
+  // }
+  // }
-  

UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
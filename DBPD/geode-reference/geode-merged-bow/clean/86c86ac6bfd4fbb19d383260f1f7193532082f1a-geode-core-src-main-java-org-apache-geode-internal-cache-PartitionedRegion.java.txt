GEODE-5985 Possible integer overflow

We had a number of calculations that were taking place with ints instead
of longs.  I've modified them to, in most places, just add an L to the
constant multiplier.  In other places I had to change a variable type
from int to long.

There were a few places that were also assigning a long to an int
variable or an int to a byte variable.  In these I added bit AND
operators to reduce the chances of overflow.

IndexElemArray needed a lot of work due to its "size" instvar being
a byte.

This closes #2783

-        long ackSAThreshold = dm.getConfig().getAckSevereAlertThreshold() * 1000;
+        long ackSAThreshold = dm.getConfig().getAckSevereAlertThreshold() * 1000L;
-          ackWaitThreshold = dm.getConfig().getAckWaitThreshold() * 1000;
+          ackWaitThreshold = dm.getConfig().getAckWaitThreshold() * 1000L;
-          ackWaitThreshold = dm.getConfig().getAckWaitThreshold() * 1000;
+          ackWaitThreshold = dm.getConfig().getAckWaitThreshold() * 1000L;
-          cache.getInternalDistributedSystem().getConfig().getAckSevereAlertThreshold() * 1000;
+          cache.getInternalDistributedSystem().getConfig().getAckSevereAlertThreshold() * 1000L;
-            cache.getInternalDistributedSystem().getConfig().getAckWaitThreshold() * 1000;
+            cache.getInternalDistributedSystem().getConfig().getAckWaitThreshold() * 1000L;
-            Thread.sleep(AbstractGatewaySender.MAXIMUM_SHUTDOWN_WAIT_TIME * 1000);
+            Thread.sleep(AbstractGatewaySender.MAXIMUM_SHUTDOWN_WAIT_TIME * 1000L);
-    private int totalTimeInRetry;
+    private long totalTimeInRetry;
-    private final int maxTimeInRetry;
+    private final long maxTimeInRetry;
-    public int getRetryTime() {
+    public long getRetryTime() {

UPD39 UPD39 UPD39 UPD34 UPD34 UPD34 UPD34 UPD34 UPD34
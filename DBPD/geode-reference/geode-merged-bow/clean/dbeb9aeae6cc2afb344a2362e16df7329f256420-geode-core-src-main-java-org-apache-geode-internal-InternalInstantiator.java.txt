Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Contains the implementation of {@link org.apache.geode.Instantiator}
- * registration and distribution messaging (and shared memory management).
+ * Contains the implementation of {@link org.apache.geode.Instantiator} registration and
+ * distribution messaging (and shared memory management).
-  
+
-  private static final ConcurrentMap/*<String,Instantiator>*/ dsMap = new ConcurrentHashMap();
+  private static final ConcurrentMap/* <String,Instantiator> */ dsMap = new ConcurrentHashMap();
-  private static final ConcurrentMap/*<Integer,Instantiator|Marker>*/ idsToInstantiators = new ConcurrentHashMap();
+  private static final ConcurrentMap/* <Integer,Instantiator|Marker> */ idsToInstantiators =
+      new ConcurrentHashMap();
-   * Maps the name of the instantiated-class to an instance of
-   * InstantiatorAttributesHolder.
+   * Maps the name of the instantiated-class to an instance of InstantiatorAttributesHolder.
-  private static final ConcurrentHashMap<String, InstantiatorAttributesHolder> classNamesToHolders = new ConcurrentHashMap<String, InstantiatorAttributesHolder>();
+  private static final ConcurrentHashMap<String, InstantiatorAttributesHolder> classNamesToHolders =
+      new ConcurrentHashMap<String, InstantiatorAttributesHolder>();
-   * Maps the id of an instantiator to an instance of
-   * InstantiatorAttributesHolder.
+   * Maps the id of an instantiator to an instance of InstantiatorAttributesHolder.
-  private static final ConcurrentHashMap<Integer, InstantiatorAttributesHolder> idsToHolders = new ConcurrentHashMap<Integer, InstantiatorAttributesHolder>();
+  private static final ConcurrentHashMap<Integer, InstantiatorAttributesHolder> idsToHolders =
+      new ConcurrentHashMap<Integer, InstantiatorAttributesHolder>();
-  private static final String SERVER_CONNECTION_THREAD = "ServerConnection" ;
-  ///////////////////////  Static Methods  ///////////////////////
+  private static final String SERVER_CONNECTION_THREAD = "ServerConnection";
+  /////////////////////// Static Methods ///////////////////////
-   * Registers an <code>Instantiator</code> with the data
-   * serialization framework.
+   * Registers an <code>Instantiator</code> with the data serialization framework.
-  public static void register(Instantiator instantiator,
-                                           boolean distribute) {
+  public static void register(Instantiator instantiator, boolean distribute) {
-    if(!distribute || checkForThread()) {
+    if (!distribute || checkForThread()) {
-   * Actually registers an <code>Instantiator</code> with the data
-   * serialization framework.
+   * Actually registers an <code>Instantiator</code> with the data serialization framework.
-   * @throws IllegalArgumentException
-   *         If the instantiator has an id of zero
-   * @throws IllegalStateException
-   *         The instantiator cannot be registered
+   * @throws IllegalArgumentException If the instantiator has an id of zero
+   * @throws IllegalStateException The instantiator cannot be registered
-  private static void _register(Instantiator instantiator, boolean distribute)
-  {
+  private static void _register(Instantiator instantiator, boolean distribute) {
-      throw new NullPointerException(LocalizedStrings.InternalInstantiator_CANNOT_REGISTER_A_NULL_INSTANTIATOR.toLocalizedString());
+      throw new NullPointerException(
+          LocalizedStrings.InternalInstantiator_CANNOT_REGISTER_A_NULL_INSTANTIATOR
+              .toLocalizedString());
-      throw new IllegalArgumentException(LocalizedStrings.Instantiator_INSTANTIATOR_ID_CANNOT_BE_ZERO.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.Instantiator_INSTANTIATOR_ID_CANNOT_BE_ZERO.toLocalizedString());
-        throw new IllegalStateException(LocalizedStrings.InternalInstantiator_CLASS_0_IS_ALREADY_REGISTERED_WITH_ID_1_SO_IT_CANNOT_BE_REGISTERED_WTH_ID_2.toLocalizedString(new Object[] {c.getName(), Integer.valueOf(oldId), Integer.valueOf(classId)}));
+        throw new IllegalStateException(
+            LocalizedStrings.InternalInstantiator_CLASS_0_IS_ALREADY_REGISTERED_WITH_ID_1_SO_IT_CANNOT_BE_REGISTERED_WTH_ID_2
+                .toLocalizedString(
+                    new Object[] {c.getName(), Integer.valueOf(oldId), Integer.valueOf(classId)}));
-    synchronized(InternalInstantiator.class) {
+    synchronized (InternalInstantiator.class) {
-          }
-          else {
-            Class oldClass =
-              ((Instantiator) oldInst).getInstantiatedClass();
+          } else {
+            Class oldClass = ((Instantiator) oldInst).getInstantiatedClass();
-                LocalizedStrings.InternalInstantiator_CLASS_ID_0_IS_ALREADY_REGISTERED_FOR_CLASS_1_SO_IT_COULD_NOT_BE_REGISTED_FOR_CLASS_2
-                  .toLocalizedString(new Object[] { Integer.valueOf(classId), oldClass.getName(), cName }));
-            }
-            else {
+                  LocalizedStrings.InternalInstantiator_CLASS_ID_0_IS_ALREADY_REGISTERED_FOR_CLASS_1_SO_IT_COULD_NOT_BE_REGISTED_FOR_CLASS_2
+                      .toLocalizedString(
+                          new Object[] {Integer.valueOf(classId), oldClass.getName(), cName}));
+            } else {
-        }
-        else {
+        } else {
-      }
-      while (retry);
+      } while (retry);
-      logger.info(LocalizedMessage.create(LocalizedStrings.InternalInstantiator_REGISTERED, new Object[] { Integer.valueOf(classId), c.getName()} ));
+      logger.info(LocalizedMessage.create(LocalizedStrings.InternalInstantiator_REGISTERED,
+          new Object[] {Integer.valueOf(classId), c.getName()}));
-   * On receving on client, when the instantiator gets loaded, and if it has
-   * static initializer which registers instantiators having distribute
-   * flag as true. And as distribute flag is true, client sends
-   * instantiator registartion recursively to server.
-   * Similarly, on server side, when the instantiator gets loaded, and if it has
-   * static initializer which registers instantiators having distribute
-   * flag as true. But eventId is not set on this case so it generates
-   * itw own event ID , to avoid this just return
+   * On receving on client, when the instantiator gets loaded, and if it has static initializer
+   * which registers instantiators having distribute flag as true. And as distribute flag is true,
+   * client sends instantiator registartion recursively to server. Similarly, on server side, when
+   * the instantiator gets loaded, and if it has static initializer which registers instantiators
+   * having distribute flag as true. But eventId is not set on this case so it generates itw own
+   * event ID , to avoid this just return
-  private static boolean checkForThread(){
+  private static boolean checkForThread() {
-  public static EventID generateEventId(){
+  public static EventID generateEventId() {
-    if (cache == null){
+    if (cache == null) {
-  private static void sendRegistrationMessageToServers(Instantiator instantiator)
-  {
+  private static void sendRegistrationMessageToServers(Instantiator instantiator) {
-  
+
-  private static void sendRegistrationMessageToServers(InstantiatorAttributesHolder holder)
-  {
+  private static void sendRegistrationMessageToServers(InstantiatorAttributesHolder holder) {
-  private static void sendRegistrationMessageToClients(Instantiator instantiator)
-  {
+  private static void sendRegistrationMessageToClients(Instantiator instantiator) {
-      serializedInstantiators[0] = CacheServerHelper.serialize(instantiator
-          .getClass().toString().substring(6));
-      serializedInstantiators[1] = CacheServerHelper.serialize(instantiator
-          .getInstantiatedClass().toString().substring(6));
+      serializedInstantiators[0] =
+          CacheServerHelper.serialize(instantiator.getClass().toString().substring(6));
+      serializedInstantiators[1] =
+          CacheServerHelper.serialize(instantiator.getInstantiatedClass().toString().substring(6));
-    }
-    catch (IOException e) {
+    } catch (IOException e) {
-        logger.debug("IOException encountered while serializing instantiators using CacheServerHelper.serialize() method");
+        logger.debug(
+            "IOException encountered while serializing instantiators using CacheServerHelper.serialize() method");
-        (ClientProxyMembershipID)instantiator.getContext(), (EventID)instantiator.getEventId());
+        (ClientProxyMembershipID) instantiator.getContext(), (EventID) instantiator.getEventId());
-   * Creates a new <code>Instantiator</code> with the given class and
-   * id and {@linkplain #register(Instantiator, boolean) registers} it
-   * with the data serialization framework.
+   * Creates a new <code>Instantiator</code> with the given class and id and
+   * {@linkplain #register(Instantiator, boolean) registers} it with the data serialization
+   * framework.
-   * @throws IllegalArgumentException
-   *         The instantiator cannot be created
-   * @throws IllegalStateException
-   *         The instantiator cannot be registered
+   * @throws IllegalArgumentException The instantiator cannot be created
+   * @throws IllegalStateException The instantiator cannot be registered
-  public static void register(Class instantiatorClass,
-                              Class instantiatedClass,
-                              int id, boolean distribute) {
+  public static void register(Class instantiatorClass, Class instantiatedClass, int id,
+      boolean distribute) {
-    if(checkForThread()) {
-      Instantiator inst = newInstance(instantiatorClass,
-          instantiatedClass, id );
+    if (checkForThread()) {
+      Instantiator inst = newInstance(instantiatorClass, instantiatedClass, id);
-   * Creates a new <code>Instantiator</code> with the given class and
-   * id and {@linkplain #register(Instantiator, boolean) registers} it
-   * with the data serialization framework.
+   * Creates a new <code>Instantiator</code> with the given class and id and
+   * {@linkplain #register(Instantiator, boolean) registers} it with the data serialization
+   * framework.
-   * @throws IllegalArgumentException
-   *         The instantiator cannot be created
-   * @throws IllegalStateException
-   *         The instantiator cannot be registered
+   * @throws IllegalArgumentException The instantiator cannot be created
+   * @throws IllegalStateException The instantiator cannot be registered
-  public static void register(Class instantiatorClass,
-                              Class instantiatedClass,
-                              int id, boolean distribute, EventID eventId, ClientProxyMembershipID context) {
-    Instantiator inst = newInstance(instantiatorClass,
-                                    instantiatedClass, id );
-    //This method is only called when server connection and CacheClientUpdaterThread
+  public static void register(Class instantiatorClass, Class instantiatedClass, int id,
+      boolean distribute, EventID eventId, ClientProxyMembershipID context) {
+    Instantiator inst = newInstance(instantiatorClass, instantiatedClass, id);
+    // This method is only called when server connection and CacheClientUpdaterThread
-   * @throws IllegalArgumentException
-   *           The instantiator cannot be created
-   * @throws IllegalStateException
-   *           The instantiator cannot be registered
+   * @throws IllegalArgumentException The instantiator cannot be created
+   * @throws IllegalStateException The instantiator cannot be registered
-  public static void register(String instantiatorClass,
-                              String instantiatedClass,
-                              int id, boolean distribute) {
+  public static void register(String instantiatorClass, String instantiatedClass, int id,
+      boolean distribute) {
-      register(instantiatorClass, new InstantiatorAttributesHolder(
-          instantiatorClass, instantiatedClass, id), distribute);
+      register(instantiatorClass,
+          new InstantiatorAttributesHolder(instantiatorClass, instantiatedClass, id), distribute);
-   * This method is only called when server connection and
-   * CacheClientUpdaterThread
+   * This method is only called when server connection and CacheClientUpdaterThread
-   * @throws IllegalArgumentException
-   *           The instantiator cannot be created
-   * @throws IllegalStateException
-   *           The instantiator cannot be registered
+   * @throws IllegalArgumentException The instantiator cannot be created
+   * @throws IllegalStateException The instantiator cannot be registered
-  public static void register(String instantiatorClass,
-                              String instantiatedClass,
-                              int id, boolean distribute, 
-                              EventID eventId, 
-                              ClientProxyMembershipID context) {
-    register(instantiatorClass, new InstantiatorAttributesHolder(
-        instantiatorClass, instantiatedClass, id, eventId, context), distribute);
+  public static void register(String instantiatorClass, String instantiatedClass, int id,
+      boolean distribute, EventID eventId, ClientProxyMembershipID context) {
+    register(instantiatorClass, new InstantiatorAttributesHolder(instantiatorClass,
+        instantiatedClass, id, eventId, context), distribute);
-  private static void register(String instantiatorClassName,
-      InstantiatorAttributesHolder holder, boolean distribute) {
-    
+  private static void register(String instantiatorClassName, InstantiatorAttributesHolder holder,
+      boolean distribute) {
+
-    synchronized(InternalInstantiator.class) {
+    synchronized (InternalInstantiator.class) {
-          throw new IllegalArgumentException(LocalizedStrings.Instantiator_INSTANTIATOR_ID_CANNOT_BE_ZERO.toLocalizedString());
+          throw new IllegalArgumentException(
+              LocalizedStrings.Instantiator_INSTANTIATOR_ID_CANNOT_BE_ZERO.toLocalizedString());
-        InstantiatorAttributesHolder iah = classNamesToHolders.putIfAbsent(
-            holder.getInstantiatedClassName(), holder);
+        InstantiatorAttributesHolder iah =
+            classNamesToHolders.putIfAbsent(holder.getInstantiatedClassName(), holder);
-              .toLocalizedString(new Object[] {instantiatorClassName,
-                  iah.getId(), holder.getId()}));
+                  .toLocalizedString(
+                      new Object[] {instantiatorClassName, iah.getId(), holder.getId()}));
-        logger.info(LocalizedMessage.create(LocalizedStrings.InternalInstantiator_REGISTERED_HOLDER, new Object[] { Integer.valueOf(holder.getId()), holder.getInstantiatedClassName()} ));
+        logger.info(LocalizedMessage.create(LocalizedStrings.InternalInstantiator_REGISTERED_HOLDER,
+            new Object[] {Integer.valueOf(holder.getId()), holder.getInstantiatedClassName()}));
-    
+
-        instantiatorClass = InternalDataSerializer.getCachedClass(
-            holder.getInstantiatorClassName());
-        instantiatedClass = InternalDataSerializer.getCachedClass(
-            holder.getInstantiatedClassName());
+        instantiatorClass =
+            InternalDataSerializer.getCachedClass(holder.getInstantiatorClassName());
+        instantiatedClass =
+            InternalDataSerializer.getCachedClass(holder.getInstantiatedClassName());
-        if (cache != null && cache.getLoggerI18n() != null
-            && cache.getLoggerI18n().infoEnabled()) {
-          cache
-              .getLoggerI18n()
-              .info(
-                  LocalizedStrings.InternalInstantiator_COULD_NOT_LOAD_INSTANTIATOR_CLASS_0,
-                  new Object[] { cnfe.getMessage() });
+        if (cache != null && cache.getLoggerI18n() != null && cache.getLoggerI18n().infoEnabled()) {
+          cache.getLoggerI18n().info(
+              LocalizedStrings.InternalInstantiator_COULD_NOT_LOAD_INSTANTIATOR_CLASS_0,
+              new Object[] {cnfe.getMessage()});
-      synchronized(InternalInstantiator.class) {
+      synchronized (InternalInstantiator.class) {
-          register(instantiatorClass, instantiatedClass, holder.getId(),
-              distribute, holder.getEventId(), holder.getContext());
+          register(instantiatorClass, instantiatedClass, holder.getId(), distribute,
+              holder.getEventId(), holder.getContext());
-    public InstantiatorAttributesHolder(String instantiatorClass,
-        String instantiatedClass, int id) {
+    public InstantiatorAttributesHolder(String instantiatorClass, String instantiatedClass,
+        int id) {
-    public InstantiatorAttributesHolder(String instantiatorClass,
-        String instantiatedClass, int id, EventID eventId,
-        ClientProxyMembershipID context) {
+    public InstantiatorAttributesHolder(String instantiatorClass, String instantiatedClass, int id,
+        EventID eventId, ClientProxyMembershipID context) {
-      return "InstantiatorAttributesHolder[irName=" + this.instantiatorName
-          + ",idName=" + this.instantiatedName + ",id=" + this.id
+      return "InstantiatorAttributesHolder[irName=" + this.instantiatorName + ",idName="
+          + this.instantiatedName + ",id=" + this.id
+
-   * Unregisters the given class with the given class id with the
-   * <code>Instantiator</code>.
+   * Unregisters the given class with the given class id with the <code>Instantiator</code>.
-   * @throws IllegalArgumentException
-   *         If <code>c</code> was not previously registered with id
+   * @throws IllegalArgumentException If <code>c</code> was not previously registered with id
-   * @throws NullPointerException
-   *         If <code>c</code> is <code>null</code>
+   * @throws NullPointerException If <code>c</code> is <code>null</code>
-      throw new NullPointerException(LocalizedStrings.InternalInstantiator_CANNOT_UNREGISTER_A_NULL_CLASS.toLocalizedString());
+      throw new NullPointerException(
+          LocalizedStrings.InternalInstantiator_CANNOT_UNREGISTER_A_NULL_CLASS.toLocalizedString());
-    final Instantiator i = (Instantiator)idsToInstantiators.remove(idx);
+    final Instantiator i = (Instantiator) idsToInstantiators.remove(idx);
-      throw new IllegalArgumentException(LocalizedStrings.InternalInstantiator_CLASS_0_WAS_NOT_REGISTERED_WITH_ID_1.toLocalizedString(new Object[] {c.getName(), Integer.valueOf(classId)}));
+      throw new IllegalArgumentException(
+          LocalizedStrings.InternalInstantiator_CLASS_0_WAS_NOT_REGISTERED_WITH_ID_1
+              .toLocalizedString(new Object[] {c.getName(), Integer.valueOf(classId)}));
-  
+
-    final Instantiator i = (Instantiator)dsMap.get(c.getName());
+    final Instantiator i = (Instantiator) dsMap.get(c.getName());
-        marker = (Marker)o;
+        marker = (Marker) o;
-        return (Instantiator)o;
+        return (Instantiator) o;
-       instantiator = marker.getInstantiator();  
+      instantiator = marker.getInstantiator();
-    
+
-          Class instantiatorClass = InternalDataSerializer.getCachedClass(
-              holder.getInstantiatorClassName());
-          Class instantiatedClass = InternalDataSerializer.getCachedClass(
-              holder.getInstantiatedClassName());
+          Class instantiatorClass =
+              InternalDataSerializer.getCachedClass(holder.getInstantiatorClassName());
+          Class instantiatedClass =
+              InternalDataSerializer.getCachedClass(holder.getInstantiatedClassName());
-            instantiator = (Instantiator)idsToInstantiators.get(classId);
+            instantiator = (Instantiator) idsToInstantiators.get(classId);
-            cache
-                .getLoggerI18n()
-                .info(
-                    LocalizedStrings.InternalInstantiator_COULD_NOT_LOAD_INSTANTIATOR_CLASS_0,
-                    new Object[] {cnfe.getMessage()});
+            cache.getLoggerI18n().info(
+                LocalizedStrings.InternalInstantiator_COULD_NOT_LOAD_INSTANTIATOR_CLASS_0,
+                new Object[] {cnfe.getMessage()});
-   * If we are connected to a distributed system, send a message to
-   * other members telling them about a newly-registered instantiator.
+   * If we are connected to a distributed system, send a message to other members telling them about
+   * a newly-registered instantiator.
-    InternalDistributedSystem system =
-      InternalDistributedSystem.getAnyInstance();
+    InternalDistributedSystem system = InternalDistributedSystem.getAnyInstance();
-      RegistrationMessage m = null ;
-      if(s.getContext()== null){
+      RegistrationMessage m = null;
+      if (s.getContext() == null) {
-      }else{
+      } else {
-   * Reflectively instantiates an instance of
-   * <code>Instantiator</code>.
+   * Reflectively instantiates an instance of <code>Instantiator</code>.
-   * @param instantiatorClass
-   *        The implementation of <code>Instantiator</code> to
-   *        instantiate
-   * @param instantiatedClass
-   *        The implementation of <code>DataSerialization</code> that
-   *        will be produced by the <code>Instantiator</code>
+   * @param instantiatorClass The implementation of <code>Instantiator</code> to instantiate
+   * @param instantiatedClass The implementation of <code>DataSerialization</code> that will be
+   *        produced by the <code>Instantiator</code>
-   * @throws IllegalArgumentException
-   *         If the class can't be instantiated
+   * @throws IllegalArgumentException If the class can't be instantiated
-  protected static Instantiator newInstance(Class instantiatorClass,
-                                            Class instantiatedClass,
-                                            int id)  {
+  protected static Instantiator newInstance(Class instantiatorClass, Class instantiatedClass,
+      int id) {
-      throw new IllegalArgumentException(LocalizedStrings.InternalInstantiator_0_DOES_NOT_EXTEND_INSTANTIATOR.toLocalizedString(instantiatorClass.getName()));
+      throw new IllegalArgumentException(
+          LocalizedStrings.InternalInstantiator_0_DOES_NOT_EXTEND_INSTANTIATOR
+              .toLocalizedString(instantiatorClass.getName()));
-      types = new Class[] { Class.class, int.class };
+      types = new Class[] {Class.class, int.class};
-        types = new Class[] { Class.class, byte.class };
+        types = new Class[] {Class.class, byte.class};
-        StringId msg = LocalizedStrings.InternalInstantiator_CLASS_0_DOES_NOT_HAVE_A_TWOARGUMENT_CLASS_INT_CONSTRUCTOR;
-        Object[] msgArgs = new Object[] { instantiatorClass.getName() };
+        StringId msg =
+            LocalizedStrings.InternalInstantiator_CLASS_0_DOES_NOT_HAVE_A_TWOARGUMENT_CLASS_INT_CONSTRUCTOR;
+        Object[] msgArgs = new Object[] {instantiatorClass.getName()};
-          msg = LocalizedStrings.InternalInstantiator_CLASS_0_DOES_NOT_HAVE_A_TWOARGUMENT_CLASS_INT_CONSTRUCTOR_IT_IS_AN_INNER_CLASS_OF_1_SHOULD_IT_BE_A_STATIC_INNER_CLASS;
-          msgArgs = new Object[] { instantiatorClass.getName(), instantiatorClass.getDeclaringClass() };
+          msg =
+              LocalizedStrings.InternalInstantiator_CLASS_0_DOES_NOT_HAVE_A_TWOARGUMENT_CLASS_INT_CONSTRUCTOR_IT_IS_AN_INNER_CLASS_OF_1_SHOULD_IT_BE_A_STATIC_INNER_CLASS;
+          msgArgs =
+              new Object[] {instantiatorClass.getName(), instantiatorClass.getDeclaringClass()};
-                                    intConstructor
-                                    ? (Object)Integer.valueOf(id)
-                                    : (Object)Byte.valueOf((byte)id)};
+          intConstructor ? (Object) Integer.valueOf(id) : (Object) Byte.valueOf((byte) id)};
-      throw new IllegalArgumentException(LocalizedStrings.InternalInstantiator_COULD_NOT_ACCESS_ZEROARGUMENT_CONSTRUCTOR_OF_0.toLocalizedString(instantiatorClass.getName()));
+      throw new IllegalArgumentException(
+          LocalizedStrings.InternalInstantiator_COULD_NOT_ACCESS_ZEROARGUMENT_CONSTRUCTOR_OF_0
+              .toLocalizedString(instantiatorClass.getName()));
-      RuntimeException ex2 = new IllegalArgumentException(LocalizedStrings.InternalInstantiator_COULD_NOT_INSTANTIATE_AN_INSTANCE_OF_0.toLocalizedString(instantiatorClass.getName()));
+      RuntimeException ex2 = new IllegalArgumentException(
+          LocalizedStrings.InternalInstantiator_COULD_NOT_INSTANTIATE_AN_INSTANCE_OF_0
+              .toLocalizedString(instantiatorClass.getName()));
-      RuntimeException ex2 = new IllegalArgumentException(LocalizedStrings.InternalInstantiator_WHILE_INSTANTIATING_AN_INSTANCE_OF_0.toLocalizedString(instantiatorClass.getName()));
+      RuntimeException ex2 = new IllegalArgumentException(
+          LocalizedStrings.InternalInstantiator_WHILE_INSTANTIATING_AN_INSTANCE_OF_0
+              .toLocalizedString(instantiatorClass.getName()));
-          InstantiatorAttributesHolder holder = (InstantiatorAttributesHolder)it
-              .next();
-          Class instantiatorClass = InternalDataSerializer.getCachedClass(
-              holder.getInstantiatorClassName());
-          Class instantiatedClass = InternalDataSerializer.getCachedClass(
-              holder.getInstantiatedClassName());
+          InstantiatorAttributesHolder holder = (InstantiatorAttributesHolder) it.next();
+          Class instantiatorClass =
+              InternalDataSerializer.getCachedClass(holder.getInstantiatorClassName());
+          Class instantiatedClass =
+              InternalDataSerializer.getCachedClass(holder.getInstantiatedClassName());
-            cache
-                .getLoggerI18n()
-                .info(
-                    LocalizedStrings.InternalInstantiator_COULD_NOT_LOAD_INSTANTIATOR_CLASS_0,
-                    new Object[] {cnfe.getMessage()});
+            cache.getLoggerI18n().info(
+                LocalizedStrings.InternalInstantiator_COULD_NOT_LOAD_INSTANTIATOR_CLASS_0,
+                new Object[] {cnfe.getMessage()});
-   * Does not trigger loading of the instantiator/instantiated classes into the
-   * vm.
+   * Does not trigger loading of the instantiator/instantiated classes into the vm.
-  ///////////////////////  Inner Classes  ///////////////////////
+  /////////////////////// Inner Classes ///////////////////////
-   * A marker object for <Code>Instantiator</code>s that have not
-   * been registered.  Using this marker object allows us to
-   * asynchronously send <Code>Instantiator</code> registration
-   * updates.  If the serialized bytes arrive at a VM before the
-   * registration message does, the deserializer will wait an amount
-   * of time for the registration message to arrive.
+   * A marker object for <Code>Instantiator</code>s that have not been registered. Using this marker
+   * object allows us to asynchronously send <Code>Instantiator</code> registration updates. If the
+   * serialized bytes arrive at a VM before the registration message does, the deserializer will
+   * wait an amount of time for the registration message to arrive.
-     * Creates a new <code>Marker</code> whose {@link #getInstantiator}
-     * method will wait for the instantiator to be registered.
+     * Creates a new <code>Marker</code> whose {@link #getInstantiator} method will wait for the
+     * instantiator to be registered.
-     * Returns the instantiator associated with this marker.  If the
-     * instantiator has not been registered yet, then this method will
-     * wait until the instantiator is registered.  If this method has to
-     * wait for too long, then <code>null</code> is returned.
+     * Returns the instantiator associated with this marker. If the instantiator has not been
+     * registered yet, then this method will wait until the instantiator is registered. If this
+     * method has to wait for too long, then <code>null</code> is returned.
-     * Sets the instantiator associated with this marker.  It will
-     * notify any threads that are waiting for the instantiator to be
-     * registered.
+     * Sets the instantiator associated with this marker. It will notify any threads that are
+     * waiting for the instantiator to be registered.
+   * 
-  public static void loadRegistrations(DataInput in) throws IOException
-  {
+  public static void loadRegistrations(DataInput in) throws IOException {
-   * A distribution message that alerts other members of the
-   * distributed cache of a new <code>Instantiator</code> being
-   * registered.
+   * A distribution message that alerts other members of the distributed cache of a new
+   * <code>Instantiator</code> being registered.
-    /** The id of the <codE>Instantiator</code> that was
-     * registered */
+    /**
+     * The id of the <codE>Instantiator</code> that was registered
+     */
-    /** The eventId of the <codE>Instantiator</code> that was
-     * registered */
+    /**
+     * The eventId of the <codE>Instantiator</code> that was registered
+     */
-    /** Problems encountered while running fromData.  See bug
-     * 31573. */
+    /**
+     * Problems encountered while running fromData. See bug 31573.
+     */
-     * Creates a new <code>RegistrationMessage</code> that broadcasts
-     * that the given <code>Instantiator</code> was registered.
+     * Creates a new <code>RegistrationMessage</code> that broadcasts that the given
+     * <code>Instantiator</code> was registered.
-      this.eventId = (EventID)s.getEventId();
+      this.eventId = (EventID) s.getEventId();
-      if (this.instantiatorClass != null &&
-          this.instantiatedClass != null) {
-        Instantiator s = newInstance(this.instantiatorClass,
-                                     this.instantiatedClass, this.id);
+      if (this.instantiatorClass != null && this.instantiatedClass != null) {
+        Instantiator s = newInstance(this.instantiatorClass, this.instantiatedClass, this.id);
-      } else if (this.instantiatorClassName != null
-          && this.instantiatedClassName != null) {
-        InternalInstantiator.register(this.instantiatorClassName,
-            this.instantiatedClassName, this.id, false, this.eventId, null);
+      } else if (this.instantiatorClassName != null && this.instantiatedClassName != null) {
+        InternalInstantiator.register(this.instantiatorClassName, this.instantiatedClassName,
+            this.id, false, this.eventId, null);
-    public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-          this.instantiatorClass = InternalDataSerializer.getCachedClass(this.instantiatorClassName); // fix for bug 41206
+          this.instantiatorClass =
+              InternalDataSerializer.getCachedClass(this.instantiatorClassName); // fix for bug
+                                                                                 // 41206
-          fromDataProblem(
-              LocalizedStrings.InternalInstantiator_COULD_NOT_LOAD_INSTANTIATOR_CLASS_0
+          fromDataProblem(LocalizedStrings.InternalInstantiator_COULD_NOT_LOAD_INSTANTIATOR_CLASS_0
-          this.instantiatedClass = InternalDataSerializer.getCachedClass(this.instantiatedClassName); // fix for bug 41206
+          this.instantiatedClass =
+              InternalDataSerializer.getCachedClass(this.instantiatedClassName); // fix for bug
+                                                                                 // 41206
-          fromDataProblem(
-              LocalizedStrings.InternalInstantiator_COULD_NOT_LOAD_INSTANTIATED_CLASS_0
+          fromDataProblem(LocalizedStrings.InternalInstantiator_COULD_NOT_LOAD_INSTANTIATED_CLASS_0
-      this.eventId = (EventID)DataSerializer.readObject(in);
+      this.eventId = (EventID) DataSerializer.readObject(in);
-      String instatiatorName = (this.instantiatorClass == null) ? this.instantiatorClassName : this.instantiatorClass.getName();
-      String instatiatedName = (this.instantiatedClass == null) ? this.instantiatedClassName : this.instantiatedClass.getName();
-      return LocalizedStrings.InternalInstantiator_REGISTER_INSTANTIATOR_0_OF_CLASS_1_THAT_INSTANTIATES_A_2.toLocalizedString( new Object[] {Integer.valueOf(this.id), instatiatorName, instatiatedName});
+      String instatiatorName = (this.instantiatorClass == null) ? this.instantiatorClassName
+          : this.instantiatorClass.getName();
+      String instatiatedName = (this.instantiatedClass == null) ? this.instantiatedClassName
+          : this.instantiatedClass.getName();
+      return LocalizedStrings.InternalInstantiator_REGISTER_INSTANTIATOR_0_OF_CLASS_1_THAT_INSTANTIATES_A_2
+          .toLocalizedString(
+              new Object[] {Integer.valueOf(this.id), instatiatorName, instatiatedName});
-   * A distribution message that alerts other members of the
-   * distributed cache of a new <code>Instantiator</code> being
-   * registered.
+   * A distribution message that alerts other members of the distributed cache of a new
+   * <code>Instantiator</code> being registered.
-     * Creates a new <code>RegistrationContextMessage</code> that broadcasts
-     * that the given <code>Instantiator</code> was registered.
+     * Creates a new <code>RegistrationContextMessage</code> that broadcasts that the given
+     * <code>Instantiator</code> was registered.
-      this.eventId = (EventID)s.getEventId();
-      this.context = (ClientProxyMembershipID)s.getContext();
+      this.eventId = (EventID) s.getEventId();
+      this.context = (ClientProxyMembershipID) s.getContext();
-      if (this.instantiatorClass != null &&
-          this.instantiatedClass != null) {
-        Instantiator s = newInstance(this.instantiatorClass,
-                                     this.instantiatedClass, this.id);
+      if (this.instantiatorClass != null && this.instantiatedClass != null) {
+        Instantiator s = newInstance(this.instantiatorClass, this.instantiatedClass, this.id);
-      } else if (this.instantiatorClassName != null &&
-          this.instantiatedClassName != null) {
-        InternalInstantiator.register(this.instantiatorClassName, this.instantiatedClassName, this.id, false, this.eventId, this.context);
+      } else if (this.instantiatorClassName != null && this.instantiatedClassName != null) {
+        InternalInstantiator.register(this.instantiatorClassName, this.instantiatedClassName,
+            this.id, false, this.eventId, this.context);
-    
+
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException
-    {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    public void toData(DataOutput out) throws IOException
-    {
+    public void toData(DataOutput out) throws IOException {
+
-    for(Iterator itr = dsMap.values().iterator(); itr.hasNext(); ) {
+    for (Iterator itr = dsMap.values().iterator(); itr.hasNext();) {
-      logger.info(LocalizedMessage.create(LocalizedStrings.InternalInstantiator_REGISTERED, new Object[] { Integer.valueOf(instantiator.getId()), instantiator.getInstantiatedClass().getName()} ));
+      logger.info(LocalizedMessage.create(LocalizedStrings.InternalInstantiator_REGISTERED,
+          new Object[] {Integer.valueOf(instantiator.getId()),
+              instantiator.getInstantiatedClass().getName()}));
-    
-    for(Iterator itr = idsToHolders.values().iterator(); itr.hasNext(); ) {
+
+    for (Iterator itr = idsToHolders.values().iterator(); itr.hasNext();) {
-      logger.info(LocalizedMessage.create(LocalizedStrings.InternalInstantiator_REGISTERED_HOLDER, new Object[] { Integer.valueOf(holder.getId()), holder.getInstantiatedClassName()} ));
+      logger.info(LocalizedMessage.create(LocalizedStrings.InternalInstantiator_REGISTERED_HOLDER,
+          new Object[] {Integer.valueOf(holder.getId()), holder.getInstantiatedClassName()}));
-    
+

INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
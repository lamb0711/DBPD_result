Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A <code>CapacityController</code> that will remove the least
- * recently used (LRU) entry from a region once the region reaches a
- * certain byte {@linkplain #setMaximumMegabytes capacity}. Capacity
- * is determined by monitoring the size of entries added and evicted.
- * Capacity is specified in terms of megabytes.  GemFire uses an
- * efficient algorithm to determine the amount of space a region entry
- * occupies in the VM.  However, this algorithm may not yield optimal
- * results for all kinds of data.  The user may provide his or her own
- * algorithm for determining the size of objects by implementing an
- * {@link ObjectSizer}.
- *
- * <P>MemLRUCapacityController must be set in the {@link
- * RegionAttributes} before the region is created. A Region with
- * MemLRUCapacityController set will throw an {@link
- * IllegalStateException} if an attempt is made to replace the
- * Region's capacity controller. While the capacity controller cannot
- * be replaced, it does support changing the limit with the {@link
- * #setMaximumMegabytes} method.
+ * A <code>CapacityController</code> that will remove the least recently used (LRU) entry from a
+ * region once the region reaches a certain byte {@linkplain #setMaximumMegabytes capacity}.
+ * Capacity is determined by monitoring the size of entries added and evicted. Capacity is specified
+ * in terms of megabytes. GemFire uses an efficient algorithm to determine the amount of space a
+ * region entry occupies in the VM. However, this algorithm may not yield optimal results for all
+ * kinds of data. The user may provide his or her own algorithm for determining the size of objects
+ * by implementing an {@link ObjectSizer}.
- * If you are using a <code>cache.xml</code> file to create a JCache
- * region declaratively, you can include the following to associate a
- * <code>MemLRUCapacityController</code> with a region:
+ * MemLRUCapacityController must be set in the {@link RegionAttributes} before the region is
+ * created. A Region with MemLRUCapacityController set will throw an {@link IllegalStateException}
+ * if an attempt is made to replace the Region's capacity controller. While the capacity controller
+ * cannot be replaced, it does support changing the limit with the {@link #setMaximumMegabytes}
+ * method.
- *  <pre>
+ * <P>
+ * If you are using a <code>cache.xml</code> file to create a JCache region declaratively, you can
+ * include the following to associate a <code>MemLRUCapacityController</code> with a region:
+ *
+ * <pre>
- *  </pre>
+ * </pre>
-public final class MemLRUCapacityController extends LRUAlgorithm
-  implements Declarable {
+public final class MemLRUCapacityController extends LRUAlgorithm implements Declarable {
-  /** The default maximum number of entries allowed by MemLRU capacity
-   * controller is 10 megabytes. */
+  /**
+   * The default maximum number of entries allowed by MemLRU capacity controller is 10 megabytes.
+   */
-  /** The key for setting the maximum-entries
-   * property declaratively.
+  /**
+   * The key for setting the maximum-entries property declaratively.
-   * @see #init */
+   * @see #init
+   */
-  /** The {@link #init initialization} property that specifies the
-   * name of the {@link ObjectSizer} implementation class. */
+  /**
+   * The {@link #init initialization} property that specifies the name of the {@link ObjectSizer}
+   * implementation class.
+   */
-    
-    final String bytesAllowedDesc = 
-      "Number of total bytes allowed in this region.";
-    final String byteCountDesc = 
-      "Number of bytes in region.";
-    final String lruEvictionsDesc = 
-      "Number of total entry evictions triggered by LRU.";
-    final String lruDestroysDesc = "Number of entries destroyed in the region through both destroy cache operations and eviction. Reset to zero each time it exceeds lruDestroysLimit.";
+
+    final String bytesAllowedDesc = "Number of total bytes allowed in this region.";
+    final String byteCountDesc = "Number of bytes in region.";
+    final String lruEvictionsDesc = "Number of total entry evictions triggered by LRU.";
+    final String lruDestroysDesc =
+        "Number of entries destroyed in the region through both destroy cache operations and eviction. Reset to zero each time it exceeds lruDestroysLimit.";
-      "Maximum number of entry destroys triggered by LRU before scan occurs.";
-    final String lruEvaluationsDesc = 
-      "Number of entries evaluated during LRU operations.";
-    final String lruGreedyReturnsDesc =
-      "Number of non-LRU entries evicted during LRU operations";
-     
-    statType = f.createType( "MemLRUStatistics",
-      "Statistics about byte based Least Recently Used region entry disposal",
-      new StatisticDescriptor[] {
-        f.createLongGauge("bytesAllowed", bytesAllowedDesc, "bytes" ),
-        f.createLongGauge("byteCount", byteCountDesc, "bytes" ),
-        f.createLongCounter("lruEvictions", lruEvictionsDesc, "entries" ),
-        f.createLongCounter("lruDestroys", lruDestroysDesc, "entries" ),
-        f.createLongGauge("lruDestroysLimit", lruDestroysLimitDesc, "entries" ),
-        f.createLongCounter("lruEvaluations", lruEvaluationsDesc, "entries" ),
-        f.createLongCounter("lruGreedyReturns", lruGreedyReturnsDesc, "entries"),
-      }
-    );
+        "Maximum number of entry destroys triggered by LRU before scan occurs.";
+    final String lruEvaluationsDesc = "Number of entries evaluated during LRU operations.";
+    final String lruGreedyReturnsDesc = "Number of non-LRU entries evicted during LRU operations";
+
+    statType = f.createType("MemLRUStatistics",
+        "Statistics about byte based Least Recently Used region entry disposal",
+        new StatisticDescriptor[] {f.createLongGauge("bytesAllowed", bytesAllowedDesc, "bytes"),
+            f.createLongGauge("byteCount", byteCountDesc, "bytes"),
+            f.createLongCounter("lruEvictions", lruEvictionsDesc, "entries"),
+            f.createLongCounter("lruDestroys", lruDestroysDesc, "entries"),
+            f.createLongGauge("lruDestroysLimit", lruDestroysLimitDesc, "entries"),
+            f.createLongCounter("lruEvaluations", lruEvaluationsDesc, "entries"),
+            f.createLongCounter("lruGreedyReturns", lruGreedyReturnsDesc, "entries"),});
-  ////////////////////  Instance Fields  ////////////////////
+  //////////////////// Instance Fields ////////////////////
-  
+
-  ///////////////////////  Constructors  ///////////////////////
+  /////////////////////// Constructors ///////////////////////
-   * Create an instance of the capacity controller with default
-   * settings.  The default settings are 0
-   * <code>maximum-megabytes</code> and a default <code>sizer</code>,
-   * requiring either the {@link #init} method to be called, or the
-   * {@link #setMaximumMegabytes} method.
+   * Create an instance of the capacity controller with default settings. The default settings are 0
+   * <code>maximum-megabytes</code> and a default <code>sizer</code>, requiring either the
+   * {@link #init} method to be called, or the {@link #setMaximumMegabytes} method.
-    this(DEFAULT_MAXIMUM_MEGABYTES,region);
+    this(DEFAULT_MAXIMUM_MEGABYTES, region);
-   * @param megabytes
-   *                the amount of memory allowed in this region specified in
-   *                megabytes.<br>
-   *                <p>
-   *                For a region with
-   *                {@link org.apache.geode.cache.DataPolicy#PARTITION}, it
-   *                is overridden by
-   *                {@link  org.apache.geode.cache.PartitionAttributesFactory#setLocalMaxMemory(int)  " local max memory "}
-   *                specified for the
-   *                {@link org.apache.geode.cache.PartitionAttributes}. It
-   *                signifies the amount of memory allowed in the region,
-   *                collectively for its primary buckets and redundant copies
-   *                for this VM. It can be different for the same region in
-   *                different VMs.
+   * @param megabytes the amount of memory allowed in this region specified in megabytes.<br>
+   *        <p>
+   *        For a region with {@link org.apache.geode.cache.DataPolicy#PARTITION}, it is overridden
+   *        by {@link org.apache.geode.cache.PartitionAttributesFactory#setLocalMaxMemory(int) "
+   *        local max memory "} specified for the
+   *        {@link org.apache.geode.cache.PartitionAttributes}. It signifies the amount of memory
+   *        allowed in the region, collectively for its primary buckets and redundant copies for
+   *        this VM. It can be different for the same region in different VMs.
-  public MemLRUCapacityController( int megabytes,Region region )  {
-    this( megabytes, null /* sizerImpl */,region );
+  public MemLRUCapacityController(int megabytes, Region region) {
+    this(megabytes, null /* sizerImpl */, region);
-   * @param megabytes
-   *                the amount of memory allowed in this region specified in
-   *                megabytes.<br>
-   *                <p>
-   *                For a region with
-   *                {@link org.apache.geode.cache.DataPolicy#PARTITION}, it
-   *                is overridden by
-   *                {@link  org.apache.geode.cache.PartitionAttributesFactory#setLocalMaxMemory(int)  " local max memory "}
-   *                specified for the
-   *                {@link org.apache.geode.cache.PartitionAttributes}. It
-   *                signifies the amount of memory allowed in the region,
-   *                collectively for its primary buckets and redundant copies
-   *                for this VM. It can be different for the same region in
-   *                different VMs.
-   * @param sizerImpl
-   *                classname of a class that implements ObjectSizer, used to
-   *                compute object sizes for MemLRU
+   * @param megabytes the amount of memory allowed in this region specified in megabytes.<br>
+   *        <p>
+   *        For a region with {@link org.apache.geode.cache.DataPolicy#PARTITION}, it is overridden
+   *        by {@link org.apache.geode.cache.PartitionAttributesFactory#setLocalMaxMemory(int) "
+   *        local max memory "} specified for the
+   *        {@link org.apache.geode.cache.PartitionAttributes}. It signifies the amount of memory
+   *        allowed in the region, collectively for its primary buckets and redundant copies for
+   *        this VM. It can be different for the same region in different VMs.
+   * @param sizerImpl classname of a class that implements ObjectSizer, used to compute object sizes
+   *        for MemLRU
-  public MemLRUCapacityController( int megabytes , ObjectSizer sizerImpl,Region region)  {
-    this( megabytes, sizerImpl, EvictionAction.DEFAULT_EVICTION_ACTION ,region, false);
+  public MemLRUCapacityController(int megabytes, ObjectSizer sizerImpl, Region region) {
+    this(megabytes, sizerImpl, EvictionAction.DEFAULT_EVICTION_ACTION, region, false);
-   * @param megabytes
-   *                the amount of memory allowed in this region specified in
-   *                megabytes.<br>
-   *                <p>
-   *                For a region with
-   *                {@link org.apache.geode.cache.DataPolicy#PARTITION}, it
-   *                is overridden by
-   *                {@link  org.apache.geode.cache.PartitionAttributesFactory#setLocalMaxMemory(int)  " local max memory "}
-   *                specified for the
-   *                {@link org.apache.geode.cache.PartitionAttributes}. It
-   *                signifies the amount of memory allowed in the region,
-   *                collectively for its primary buckets and redundant copies
-   *                for this VM. It can be different for the same region in
-   *                different VMs.
-   * @param sizerImpl
-   *                classname of a class that implements ObjectSizer, used to
-   *                compute object sizes for MemLRU
+   * @param megabytes the amount of memory allowed in this region specified in megabytes.<br>
+   *        <p>
+   *        For a region with {@link org.apache.geode.cache.DataPolicy#PARTITION}, it is overridden
+   *        by {@link org.apache.geode.cache.PartitionAttributesFactory#setLocalMaxMemory(int) "
+   *        local max memory "} specified for the
+   *        {@link org.apache.geode.cache.PartitionAttributes}. It signifies the amount of memory
+   *        allowed in the region, collectively for its primary buckets and redundant copies for
+   *        this VM. It can be different for the same region in different VMs.
+   * @param sizerImpl classname of a class that implements ObjectSizer, used to compute object sizes
+   *        for MemLRU
-  public MemLRUCapacityController( int megabytes , ObjectSizer sizerImpl,
-                                   EvictionAction evictionAction,Region region, boolean isOffHeap)  {
-    super(evictionAction,region);
+  public MemLRUCapacityController(int megabytes, ObjectSizer sizerImpl,
+      EvictionAction evictionAction, Region region, boolean isOffHeap) {
+    super(evictionAction, region);
-  //////////////////////  Instance Methods  /////////////////////
+  ////////////////////// Instance Methods /////////////////////
-   * Declaratively initializes this capacity controller.  Supported
-   * properties are:
+   * Declaratively initializes this capacity controller. Supported properties are:
-   * <li>{@link #MAXIMUM_MEGABYTES maximum-megabytes}: The number of
-   *      megabytes to limit the region to.</li> 
-   * <li>{@link #EVICTION_ACTION eviction-action}: The action to
-   *     perform when the LRU region entry is evicted.</li>
-   * <li>{@link #SIZER_IMPL sizer}: The name of the {@link
-   *     ObjectSizer} implementation class to use for computing the
-   *     size of region entries.</li>
+   * <li>{@link #MAXIMUM_MEGABYTES maximum-megabytes}: The number of megabytes to limit the region
+   * to.</li>
+   * <li>{@link #EVICTION_ACTION eviction-action}: The action to perform when the LRU region entry
+   * is evicted.</li>
+   * <li>{@link #SIZER_IMPL sizer}: The name of the {@link ObjectSizer} implementation class to use
+   * for computing the size of region entries.</li>
-   * @throws NumberFormatException
-   *         The <code>maximum-megabytes</code> property cannot be
-   *         parsed as an integer
-   * @throws IllegalArgumentException
-   *         The value of the <code>eviction-action</code> property is
-   *         not recoginzed.
+   * @throws NumberFormatException The <code>maximum-megabytes</code> property cannot be parsed as
+   *         an integer
+   * @throws IllegalArgumentException The value of the <code>eviction-action</code> property is not
+   *         recoginzed.
-    if ( ( sizerStr = props.getProperty(SIZER_IMPL) ) != null ) {
+    if ((sizerStr = props.getProperty(SIZER_IMPL)) != null) {
-        setSizer((ObjectSizer)c.newInstance());
-      }
-      catch(Exception e) {
-        IllegalArgumentException ex = new IllegalArgumentException(LocalizedStrings.MemLRUCapacityController_COULD_NOT_CREATE_SIZER_INSTANCE_GIVEN_THE_CLASS_NAME_0.toLocalizedString(sizer));
+        setSizer((ObjectSizer) c.newInstance());
+      } catch (Exception e) {
+        IllegalArgumentException ex = new IllegalArgumentException(
+            LocalizedStrings.MemLRUCapacityController_COULD_NOT_CREATE_SIZER_INSTANCE_GIVEN_THE_CLASS_NAME_0
+                .toLocalizedString(sizer));
-    
-    if ( ( prop = props.getProperty( MAXIMUM_MEGABYTES ) ) != null ) {
-      this.limit = Integer.parseInt( prop ) * ONE_MEG;
+
+    if ((prop = props.getProperty(MAXIMUM_MEGABYTES)) != null) {
+      this.limit = Integer.parseInt(prop) * ONE_MEG;
-    if ( ( prop = props.getProperty( EVICTION_ACTION ) ) != null ) {
+    if ((prop = props.getProperty(EVICTION_ACTION)) != null) {
-  // Candidate for removal since capacity controller no longer part of 
+  // Candidate for removal since capacity controller no longer part of
-   * Reset the maximum allowed limit on memory to use for this region. This
-   * change takes effect on next region operation that could increase the
-   * region's byte size. If the region is shared, this change is seen by all vms
-   * on using the same GemFire shared memory system.
+   * Reset the maximum allowed limit on memory to use for this region. This change takes effect on
+   * next region operation that could increase the region's byte size. If the region is shared, this
+   * change is seen by all vms on using the same GemFire shared memory system.
-  public void setMaximumMegabytes( int megabytes ) {
+  public void setMaximumMegabytes(int megabytes) {
-      throw new IllegalArgumentException(LocalizedStrings.MemLRUCapacityController_MEMLRUCONTROLLER_LIMIT_MUST_BE_POSTIVE_0
-          .toLocalizedString(Integer.valueOf(megabytes)));
+      throw new IllegalArgumentException(
+          LocalizedStrings.MemLRUCapacityController_MEMLRUCONTROLLER_LIMIT_MUST_BE_POSTIVE_0
+              .toLocalizedString(Integer.valueOf(megabytes)));
-    }
-    else if (this.stats != null) {
+    } else if (this.stats != null) {
-  
+
-   * Sets the the number of bytes of overhead each object occupies in
-   * the VM.  This value may vary between VM implementations.
+   * Sets the the number of bytes of overhead each object occupies in the VM. This value may vary
+   * between VM implementations.
-//   public void writeExternal(ObjectOutput out)
-//     throws IOException {
-//     super.writeExternal(out);
-//     if (this.stats != null) {
-//       long limit = this.getLRUHelper().limit();
-//       Assert.assertTrue(limit > 0);
-//       out.writeLong(limit);
+  // public void writeExternal(ObjectOutput out)
+  // throws IOException {
+  // super.writeExternal(out);
+  // if (this.stats != null) {
+  // long limit = this.getLRUHelper().limit();
+  // Assert.assertTrue(limit > 0);
+  // out.writeLong(limit);
-//     } else {
-//       Assert.assertTrue(this.limit > 0);
-//       out.writeLong(this.limit);
-//     }
-//     if (this.sizer != null) {
-//       out.writeBoolean(true);
-//       out.writeUTF(this.sizer.getClass().getName());
+  // } else {
+  // Assert.assertTrue(this.limit > 0);
+  // out.writeLong(this.limit);
+  // }
+  // if (this.sizer != null) {
+  // out.writeBoolean(true);
+  // out.writeUTF(this.sizer.getClass().getName());
-//     } else {
-//       out.writeBoolean(false);
-//     }
-//   }
+  // } else {
+  // out.writeBoolean(false);
+  // }
+  // }
-//   public void readExternal(ObjectInput in)
-//     throws IOException, ClassNotFoundException {
-//     super.readExternal(in);
-//     long limit = in.readLong();
-//     setMaximumMegabytes((int) limit);
-//     if (in.readBoolean()) {
-//       String className = in.readUTF();
-//       setSizer(className);
-//     }
-//   }
+  // public void readExternal(ObjectInput in)
+  // throws IOException, ClassNotFoundException {
+  // super.readExternal(in);
+  // long limit = in.readLong();
+  // setMaximumMegabytes((int) limit);
+  // if (in.readBoolean()) {
+  // String className = in.readUTF();
+  // setSizer(className);
+  // }
+  // }
-   * Sets the {@link ObjectSizer} used to calculate the size of
-   * objects placed in the cache.
+   * Sets the {@link ObjectSizer} used to calculate the size of objects placed in the cache.
-   * @param sizer
-   *        The name of the sizer class
+   * @param sizer The name of the sizer class
-       * Indicate what kind of <code>EvictionAlgorithm</code> this helper implements 
+       * Indicate what kind of <code>EvictionAlgorithm</code> this helper implements
-      public int entrySize( Object key, Object value )
-        throws IllegalArgumentException {
+      public int entrySize(Object key, Object value) throws IllegalArgumentException {
-        
+
-//         org.apache.geode.internal.cache.GemFireCacheImpl.getInstance().getLogger().info("DEBUG MemLRUCC: overhead=" + size
-//                                                     + " keySize=" + keySize
-//                                                     + " valueSize=" + valueSize);
+        // org.apache.geode.internal.cache.GemFireCacheImpl.getInstance().getLogger().info("DEBUG
+        // MemLRUCC: overhead=" + size
+        // + " keySize=" + keySize
+        // + " valueSize=" + valueSize);
-      
+
-  static int basicSizeof(Object o, ObjectSizer sizer)
-      throws IllegalArgumentException {
+  static int basicSizeof(Object o, ObjectSizer sizer) throws IllegalArgumentException {
-      o = ((CDValueWrapper)o).getValue();
+      o = ((CDValueWrapper) o).getValue();
-    if (o == null || o == Token.INVALID || o == Token.LOCAL_INVALID
-        || o == Token.DESTROYED || o == Token.TOMBSTONE) {
+    if (o == null || o == Token.INVALID || o == Token.LOCAL_INVALID || o == Token.DESTROYED
+        || o == Token.TOMBSTONE) {
-//    Shouldn't we defer to the user's object sizer for these things?
-    if ( o instanceof byte[]  || o instanceof String) {
+    // Shouldn't we defer to the user's object sizer for these things?
+    if (o instanceof byte[] || o instanceof String) {
-    }
-    else if (o instanceof Sizeable) {
-      size = ((Sizeable)o).getSizeInBytes();
-    }
-    else if (sizer != null) {
+    } else if (o instanceof Sizeable) {
+      size = ((Sizeable) o).getSizeInBytes();
+    } else if (sizer != null) {
-    }
-    else {
+    } else {
+
-   * Return the size of an object as stored in GemFire... Typically
-   * this is the serialized size in bytes..  This implementation is
-   * slow....  Need to add Sizer interface and call it for customer
+   * Return the size of an object as stored in GemFire... Typically this is the serialized size in
+   * bytes.. This implementation is slow.... Need to add Sizer interface and call it for customer
-  protected int sizeof( Object o ) throws IllegalArgumentException {
+  protected int sizeof(Object o) throws IllegalArgumentException {
-  
+
-    if (!super.equals(cc)) return false;
-    MemLRUCapacityController other = (MemLRUCapacityController)cc;
-    if (this.limit != other.limit) return false;
+    if (!super.equals(cc))
+      return false;
+    MemLRUCapacityController other = (MemLRUCapacityController) cc;
+    if (this.limit != other.limit)
+      return false;
+   * 
-   * Note that we just need to make sure that equal objects return equal
-   * hashcodes; nothing really elaborate is done here.
+   * Note that we just need to make sure that equal objects return equal hashcodes; nothing really
+   * elaborate is done here.
-  
+
-    return "MemLRUCapacityController with a capacity of " +
-      this.getLimit() + " megabytes and and eviction action " + this.getEvictionAction();
+    return "MemLRUCapacityController with a capacity of " + this.getLimit()
+        + " megabytes and and eviction action " + this.getEvictionAction();

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 UPD66 INS66 UPD66 INS66 UPD66 UPD66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66
Merge branch 'release/1.5.0'

+  private static final int NO_HEADER_READ_TIMEOUT = 0;
+
-  private void read() throws IOException {
+  private void readHeaderAndBody(int headerReadTimeoutMillis) throws IOException {
-    readHeaderAndPayload();
-  }
-  /**
-   * Read the actual bytes of the header off the socket
-   */
-  void fetchHeader() throws IOException {
-    final ByteBuffer cb = getCommBuffer();
-    cb.clear();
-
-    // messageType is invalidated here and can be used as an indicator
-    // of problems reading the message
-    this.messageType = MessageType.INVALID;
-
-    final int headerLength = getHeaderLength();
-    if (this.socketChannel != null) {
-      cb.limit(headerLength);
-      do {
-        int bytesRead = this.socketChannel.read(cb);
-        if (bytesRead == -1) {
-          throw new EOFException(
-              LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_HEADER
-                  .toLocalizedString());
-        }
-        if (this.messageStats != null) {
-          this.messageStats.incReceivedBytes(bytesRead);
-        }
-      } while (cb.remaining() > 0);
-      cb.flip();
-
-    } else {
-      int hdr = 0;
-      do {
-        int bytesRead = this.inputStream.read(cb.array(), hdr, headerLength - hdr);
-        if (bytesRead == -1) {
-          throw new EOFException(
-              LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_HEADER
-                  .toLocalizedString());
-        }
-        hdr += bytesRead;
-        if (this.messageStats != null) {
-          this.messageStats.incReceivedBytes(bytesRead);
-        }
-      } while (hdr < headerLength);
-
-      // now setup the commBuffer for the caller to parse it
-      cb.rewind();
+    int timeout = socket.getSoTimeout();
+    try {
+      socket.setSoTimeout(headerReadTimeoutMillis);
+      fetchHeader();
+    } finally {
+      socket.setSoTimeout(timeout);
-  }
-  private void readHeaderAndPayload() throws IOException {
-    fetchHeader();
+   * Read the actual bytes of the header off the socket
+   */
+  void fetchHeader() throws IOException {
+    final ByteBuffer cb = getCommBuffer();
+    cb.clear();
+
+    // messageType is invalidated here and can be used as an indicator
+    // of problems reading the message
+    this.messageType = MessageType.INVALID;
+
+    final int headerLength = getHeaderLength();
+    if (this.socketChannel != null) {
+      cb.limit(headerLength);
+      do {
+        int bytesRead = this.socketChannel.read(cb);
+        if (bytesRead == -1) {
+          throw new EOFException(
+              LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_HEADER
+                  .toLocalizedString());
+        }
+        if (this.messageStats != null) {
+          this.messageStats.incReceivedBytes(bytesRead);
+        }
+      } while (cb.remaining() > 0);
+      cb.flip();
+
+    } else {
+      int hdr = 0;
+      do {
+        int bytesRead = this.inputStream.read(cb.array(), hdr, headerLength - hdr);
+        if (bytesRead == -1) {
+          throw new EOFException(
+              LocalizedStrings.Message_THE_CONNECTION_HAS_BEEN_RESET_WHILE_READING_THE_HEADER
+                  .toLocalizedString());
+        }
+        hdr += bytesRead;
+        if (this.messageStats != null) {
+          this.messageStats.incReceivedBytes(bytesRead);
+        }
+      } while (hdr < headerLength);
+
+      // now setup the commBuffer for the caller to parse it
+      cb.rewind();
+    }
+  }
+
+  /**
+  // Set up a message on the server side.
+  // Set up a message on the client side.
+  // Set up a message on the client side.
-   * Populates the stats of this {@code Message} with information received via its socket
+   * Read a message, populating the state of this {@code Message} with information received via its
+   * socket
+   *
+   * @param timeoutMillis timeout setting for reading the header (0 = no timeout)
+   * @throws IOException
-  public void recv() throws IOException {
+  public void receiveWithHeaderReadTimeout(int timeoutMillis) throws IOException {
-        read();
+        readHeaderAndBody(timeoutMillis);
-  public void recv(ServerConnection sc, int maxMessageLength, Semaphore dataLimiter,
+  /**
+   * Populates the state of this {@code Message} with information received via its socket
+   */
+  public void receive() throws IOException {
+    receiveWithHeaderReadTimeout(NO_HEADER_READ_TIMEOUT);
+  }
+
+  public void receive(ServerConnection sc, int maxMessageLength, Semaphore dataLimiter,
-    recv();
+    receive();

MOV31 MOV31 INS23 INS83 INS83 INS83 INS39 INS59 UPD42 INS44 UPD42 INS44 INS29 UPD83 UPD42 UPD42 INS42 INS34 INS39 INS42 MOV21 INS60 INS54 INS65 INS65 INS39 INS42 INS65 INS39 INS59 INS8 INS8 UPD66 UPD66 INS66 INS42 INS66 INS42 INS66 INS65 INS66 INS42 INS32 INS21 MOV21 INS21 INS66 UPD42 INS42 UPD42 INS42 INS42 INS32 INS32 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS42
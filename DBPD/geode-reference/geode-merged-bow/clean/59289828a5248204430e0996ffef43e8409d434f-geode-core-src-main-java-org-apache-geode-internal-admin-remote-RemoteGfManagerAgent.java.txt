GEODE-7256: Move CacheFactoryStaticsTest to IntegrationTest

RemoteGfManagerAgentTest and CacheFactoryStaticsTest failed in my PR
precheckin, so I studied the tests and related changes that were
recently merged in.

Move CacheFactoryStaticsTest to IntegrationTest. Rename to
CacheFactoryStaticsIntegrationTest. This test is creating a full Cache
which makes it an IntegrationTest.

Remove unnecessary spy from RemoteGfManagerAgentTest.

Even though RemoteGfManagerAgentTest was setting the system field in
RemoteGfManagerAgent, the test intermittently nulls out the system and
then creates a real connection to the DistributedSystem which is not
desirable in a unit test, so I replaced static dependencies with
factories that can be stubbed to inject the desired mocks.

Cleanup RemoteGfManagerAgent, RemoteGfManagerAgentTest, and
CacheFactoryStaticsIntegrationTest. Fix up unchecked types and make all
fields private again. Add VisibleForTesting annotation to applicable
methods. Use constructor injection to avoid breaking encapsulation.

+import static java.util.Collections.emptyList;
+import static java.util.Collections.emptyMap;
+import static java.util.Collections.emptySet;
+import static org.apache.geode.internal.logging.log4j.LogMarker.DM_VERBOSE;
+
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.concurrent.Callable;
+import java.util.function.Function;
+import org.apache.geode.annotations.VisibleForTesting;
+import org.apache.geode.distributed.DistributedSystem;
-import org.apache.geode.distributed.internal.DistributionConfig;
-import org.apache.geode.internal.logging.log4j.LogMarker;
- * An implementation of <code>GfManagerAgent</code> that uses a {@link ClusterDistributionManager}
+ * An implementation of {@code GfManagerAgent} that uses a {@link ClusterDistributionManager}
- * <code>MembershipListener</code> it is alerted when members join and leave the distributed system.
+ * {@code MembershipListener} it is alerted when members join and leave the distributed system.
-public
-// Note that since we export the instances in a public list,
-// I'm not permitting subclasses
-class RemoteGfManagerAgent implements GfManagerAgent {
+public class RemoteGfManagerAgent implements GfManagerAgent {
-  // instance variables
-
-  protected volatile InternalDistributedSystem system;
+  private volatile InternalDistributedSystem system;
+
-  /** Is this agent connected to the distributed system */
-  protected volatile boolean connected = false;
+  /**
+   * Is this agent connected to the distributed system
+   */
+  private volatile boolean connected;
-  /** Is this agent listening for messages from the distributed system? */
+  /**
+   * Is this agent listening for messages from the distributed system?
+   */
-  /** An alert listener that receives alerts */
+  /**
+   * An alert listener that receives alerts
+   */
-  /** The level at which alerts are logged */
-  protected /* final */ int alertLevel;
+  /**
+   * The level at which alerts are logged
+   */
+  private int alertLevel;
-  /** The transport configuration used to connect to the distributed system */
+  /**
+   * The transport configuration used to connect to the distributed system
+   */
-   * Optional display name used for
-   * {@link org.apache.geode.distributed.DistributedSystem#getName()}.
+   * Optional display name used for {@link DistributedSystem#getName()}.
-  /** The <code>JoinLeaveListener</code>s registered with this agent */
-  protected volatile Set listeners = Collections.EMPTY_SET;
+  /**
+   * The {@code JoinLeaveListener}s registered with this agent
+   */
+  private volatile Set<JoinLeaveListener> listeners = emptySet();
-  protected volatile Map membersMap = Collections.EMPTY_MAP;
+  private volatile Map<InternalDistributedMember, Future<RemoteApplicationVM>> membersMap =
+      emptyMap();
-  // LOG: used to log WARN for AuthenticationFailedException
-   * A queue of <code>SnapshotResultMessage</code>s the are processed by a SnapshotResultDispatcher
+   * A queue of {@code SnapshotResultMessage}s the are processed by a SnapshotResultDispatcher
-  protected BlockingQueue snapshotResults = new LinkedBlockingQueue();
+  private final BlockingQueue<SnapshotResultMessage> snapshotResults = new LinkedBlockingQueue<>();
-  /** A thread that asynchronously handles incoming cache snapshots. */
-  private SnapshotResultDispatcher snapshotDispatcher;
+  /**
+   * A thread that asynchronously handles incoming cache snapshots.
+   */
+  private final SnapshotResultDispatcher snapshotDispatcher;
-  /** Thread that processes membership joins */
-  protected JoinProcessor joinProcessor;
+  /**
+   * Thread that processes membership joins
+   */
+  private final JoinProcessor joinProcessor;
-  /** Ordered List for processing of pendingJoins; elements are InternalDistributedMember */
-  protected volatile List pendingJoins = Collections.EMPTY_LIST;
+  /**
+   * Ordered List for processing of pendingJoins; elements are InternalDistributedMember
+   */
+  private volatile List<InternalDistributedMember> pendingJoins = emptyList();
-  /** Lock for altering the contents of the pendingJoins Map and List */
+  /**
+   * Lock for altering the contents of the pendingJoins Map and List
+   */
-  /** Id of the currentJoin that is being processed */
-  protected volatile InternalDistributedMember currentJoin;
+  /**
+   * Id of the currentJoin that is being processed
+   */
+  private volatile InternalDistributedMember currentJoin;
-  protected volatile boolean abortCurrentJoin = false;
+  private volatile boolean abortCurrentJoin;
-   * Has this <code>RemoteGfManagerAgent</code> been initialized? That is, after it has been
+   * Has this {@code RemoteGfManagerAgent} been initialized? That is, after it has been
-  protected volatile boolean initialized = false;
+  private volatile boolean initialized;
-  private boolean disconnected = false;
+  private boolean disconnected;
-  /** DM MembershipListener for this RemoteGfManagerAgent */
+  /**
+   * DM MembershipListener for this RemoteGfManagerAgent
+   */
-  private DisconnectListener disconnectListener;
+  private final DisconnectListener disconnectListener;
-  private static volatile ArrayList allAgents = new ArrayList();
+  private static volatile List<RemoteGfManagerAgent> allAgents = new ArrayList<>();
+
+  /**
+   * break any potential circularity in {@link #loadEmergencyClasses()}
+   */
+  @MakeNotStatic
+  private static volatile boolean emergencyClassesLoaded;
+
+  /**
+   * Is this thread currently sending a message?
+   */
+  private static final ThreadLocal<Boolean> sending = ThreadLocal.withInitial(() -> Boolean.FALSE);
+
+  private final Function<Properties, InternalDistributedSystem> distributedSystemFactory;
+  private final Function<RemoteGfManagerAgent, DSConnectionDaemon> dsConnectionDaemonFactory;
+  private final Function<RemoteGfManagerAgent, MyMembershipListener> myMembershipListenerFactory;
-      ArrayList replace = new ArrayList(allAgents);
+      List<RemoteGfManagerAgent> replace = new ArrayList<>(allAgents);
-      ArrayList replace = new ArrayList(allAgents);
+      List<RemoteGfManagerAgent> replace = new ArrayList<>(allAgents);
-   * break any potential circularity in {@link #loadEmergencyClasses()}
-   */
-  @MakeNotStatic
-  private static volatile boolean emergencyClassesLoaded = false;
-
-  /**
-    if (emergencyClassesLoaded)
+    if (emergencyClassesLoaded) {
+    }
-    ArrayList members = allAgents; // volatile fetch
-    for (int i = 0; i < members.size(); i++) {
-      RemoteGfManagerAgent each = (RemoteGfManagerAgent) members.get(i);
+    // volatile fetch
+    List members = allAgents;
+    for (Object member : members) {
+      RemoteGfManagerAgent each = (RemoteGfManagerAgent) member;
-   * Return a recent (though possibly incomplete) list of all existing agents
-   *
-   * @return list of agents
-   */
-  public static ArrayList getAgents() {
-    return allAgents;
-  }
-
-  // constructors
-
-  /**
-   * Creates a new <code>RemoteGfManagerAgent</code> accord to the given config. Along the way it
+   * Creates a new {@code RemoteGfManagerAgent} accord to the given config. Along the way it
+    this(cfg,
+        props -> (InternalDistributedSystem) InternalDistributedSystem.connectForAdmin(props),
+        JoinProcessor::new,
+        SnapshotResultDispatcher::new,
+        DSConnectionDaemon::new,
+        MyMembershipListener::new);
+  }
+
+  @VisibleForTesting
+  RemoteGfManagerAgent(GfManagerAgentConfig cfg,
+      Function<Properties, InternalDistributedSystem> distributedSystemFactory,
+      Function<RemoteGfManagerAgent, JoinProcessor> joinProcessorFactory,
+      Function<RemoteGfManagerAgent, SnapshotResultDispatcher> snapshotResultDispatcherFactory,
+      Function<RemoteGfManagerAgent, DSConnectionDaemon> dsConnectionDaemonFactory,
+      Function<RemoteGfManagerAgent, MyMembershipListener> myMembershipListenerFactory) {
-          String.format("Expected %s to be a RemoteTransportConfig",
-              cfg.getTransport()));
+          String.format("Expected %s to be a RemoteTransportConfig", cfg.getTransport()));
-    this.transport = (RemoteTransportConfig) cfg.getTransport();
-    this.displayName = cfg.getDisplayName();
-    this.alertListener = cfg.getAlertListener();
-    if (this.alertListener != null) {
-      if (this.alertListener instanceof JoinLeaveListener) {
-        addJoinLeaveListener((JoinLeaveListener) this.alertListener);
+
+    this.distributedSystemFactory = distributedSystemFactory;
+    this.dsConnectionDaemonFactory = dsConnectionDaemonFactory;
+    this.myMembershipListenerFactory = myMembershipListenerFactory;
+
+    transport = (RemoteTransportConfig) cfg.getTransport();
+    displayName = cfg.getDisplayName();
+    alertListener = cfg.getAlertListener();
+    if (alertListener != null) {
+      if (alertListener instanceof JoinLeaveListener) {
+        addJoinLeaveListener((JoinLeaveListener) alertListener);
-    if (this.alertListener == null) {
+    if (alertListener == null) {
-      this.securityLogWriter = logWriter;
+      securityLogWriter = logWriter;
-      this.securityLogWriter = LogWriterFactory.toSecurityLogWriter(logWriter);
+      securityLogWriter = LogWriterFactory.toSecurityLogWriter(logWriter);
-    this.disconnectListener = cfg.getDisconnectListener();
+    disconnectListener = cfg.getDisconnectListener();
-    this.joinProcessor = new JoinProcessor();
-    this.joinProcessor.start();
+    joinProcessor = joinProcessorFactory.apply(this);
+    joinProcessor.start();
-    snapshotDispatcher = new SnapshotResultDispatcher();
+    snapshotDispatcher = snapshotResultDispatcherFactory.apply(this);
-    // Note that this makes this instance externally visible.
-    // This is why this class is final.
-    daemon = new DSConnectionDaemon();
+    daemon = dsConnectionDaemonFactory.apply(this);
-    } catch (InterruptedException ignore) {
+    } catch (InterruptedException e) {
-      this.system.getCancelCriterion().checkCancelInProgress(ignore);
+      system.getCancelCriterion().checkCancelInProgress(e);
-  // static methods
-
-
-   * Handles an <code>ExecutionException</code> by examining its cause and throwing an appropriate
+   * Handles an {@code ExecutionException} by examining its cause and throwing an appropriate
-      // Operation was cancelled, we don't necessary want to propagate
-      // this up to the user.
+      // Operation was cancelled, we don't necessary want to propagate this up to the user.
-        "An ExceputionException was thrown while waiting for Future.",
-        ex);
+        "An ExecutionException was thrown while waiting for Future.", ex);
-  // Object methodsg
-
-    return "Distributed System " + this.transport;
+    return "Distributed System " + transport;
-
-  // GfManagerAgent methods
-
-    boolean disconnectedTrue = false;
+    boolean disconnectedTrue;
-      // joinProcessor.interrupt();
-      boolean removeListener = this.alertLevel != Alert.OFF;
-      if (this.isConnected() || (this.membersMap.size() > 0)) { // Hot fix from 6.6.3
+      boolean removeListener = alertLevel != Alert.OFF;
+      if (isConnected() || !membersMap.isEmpty()) {
-        for (int i = 0; i < apps.length; i++) {
+        for (RemoteApplicationVM app : apps) {
-            apps[i].disconnect(removeListener); // hit NPE here in ConsoleDistributionManagerTest so
-                                                // fixed listApplications to exclude nulls returned
-                                                // from future
+            app.disconnect(removeListener);
+            // hit NPE here in ConsoleDistributionManagerTest so
+            // fixed listApplications to exclude nulls returned from future
-          synchronized (this.myMembershipListenerLock) {
-            if (this.myMembershipListener != null) {
-              dm.removeMembershipListener(this.myMembershipListener);
+          synchronized (myMembershipListenerLock) {
+            if (myMembershipListener != null) {
+              dm.removeMembershipListener(myMembershipListener);
-          if (system != null && ClusterDistributionManager.isDedicatedAdminVM()
+          if (system != null
+              && ClusterDistributionManager.isDedicatedAdminVM()
-          this.system = null;
+          system = null;
-        this.connected = false;
+        connected = false;
-    return this.initialized;
+    return initialized;
-    return this.connected && system != null && system.isConnected();
+    return connected && system != null && system.isConnected();
-  public ApplicationVM[] listApplications(boolean disconnected) {// Hot fix from 6.6.3
-    if (isConnected() || (this.membersMap.size() > 0 && disconnected)) {
+  private ApplicationVM[] listApplications(boolean disconnected) {
+    if (isConnected() || !membersMap.isEmpty() && disconnected) {
-      Collection remoteApplicationVMs = new ArrayList(this.membersMap.size());
-      VMS: for (Iterator iter = this.membersMap.values().iterator(); iter.hasNext();) {
-        Future future = (Future) iter.next();
+      Collection<RemoteApplicationVM> remoteApplicationVMs = new ArrayList<>(membersMap.size());
+      VMS: for (Future<RemoteApplicationVM> future : membersMap.values()) {
-            this.system.getCancelCriterion().checkCancelInProgress(null);
+            system.getCancelCriterion().checkCancelInProgress(null);
-            Object obj = future.get();
-            if (obj != null) {
-              remoteApplicationVMs.add(obj);
+            RemoteApplicationVM app = future.get();
+            if (app != null) {
+              remoteApplicationVMs.add(app);
-        } // for
-      } // VMS
+        }
+      }
-    } else {
-      return new RemoteApplicationVM[0];
+    return new RemoteApplicationVM[0];
-   * Registers a <code>JoinLeaveListener</code>. on this agent that is notified when membership in
+   * Registers a {@code JoinLeaveListener}. on this agent that is notified when membership in
-    synchronized (this.listenersLock) {
-      final Set oldListeners = this.listeners;
+    synchronized (listenersLock) {
+      Set<JoinLeaveListener> oldListeners = listeners;
-        final Set newListeners = new HashSet(oldListeners);
+        Set<JoinLeaveListener> newListeners = new HashSet<>(oldListeners);
-        this.listeners = newListeners;
+        listeners = newListeners;
-   * Deregisters a <code>JoinLeaveListener</code> from this agent.
+   * Deregisters a {@code JoinLeaveListener} from this agent.
-    synchronized (this.listenersLock) {
-      final Set oldListeners = this.listeners;
+    synchronized (listenersLock) {
+      Set<JoinLeaveListener> oldListeners = listeners;
-        final Set newListeners = new HashSet(oldListeners);
+        Set<JoinLeaveListener> newListeners = new HashSet<>(oldListeners);
-          this.listeners = newListeners;
+          listeners = newListeners;
-   * Sets the <code>CacheCollector</code> that <code>CacheSnapshot</code>s are delivered to.
+   * Sets the {@code CacheCollector} that {@code CacheSnapshot}s are delivered to.
-  // misc instance methods
-
-    return this.transport;
+    return transport;
-  /** Is this thread currently sending a message? */
-  private static final ThreadLocal sending = new ThreadLocal() {
-    @Override
-    protected Object initialValue() {
-      return Boolean.FALSE;
-    }
-  };
-
-      if (((Boolean) sending.get()).booleanValue()) {
+      if (sending.get()) {
-            String.format("Recursion detected while sending %s",
-                msg));
-
-      } else {
-        sending.set(Boolean.TRUE);
+            String.format("Recursion detected while sending %s", msg));
+      sending.set(Boolean.TRUE);
-      ClusterDistributionManager dm =
-          (ClusterDistributionManager) this.system.getDistributionManager();
+      ClusterDistributionManager dm = (ClusterDistributionManager) system.getDistributionManager();
-      } else {
-        // bug 39824: generate CancelException if we're shutting down
-        dm.getCancelCriterion().checkCancelInProgress(null);
-        throw new RuntimeAdminException(
-            String.format("%s is not currently connected.",
-                this));
+      // generate CancelException if we're shutting down
+      dm.getCancelCriterion().checkCancelInProgress(null);
+      throw new RuntimeAdminException(
+          String.format("%s is not currently connected.", this));
-   * <code>id</code>.
+   * {@code id}.
-  public RemoteGemFireVM getMemberById(InternalDistributedMember id) {
+  RemoteGemFireVM getMemberById(InternalDistributedMember id) {
-   * Returns the application VM with the given <code>id</code>.
+   * Returns the application VM with the given {@code id}.
-  public RemoteApplicationVM getApplicationById(InternalDistributedMember id) {
+  private RemoteApplicationVM getApplicationById(InternalDistributedMember id) {
-      // removed synchronized(members)
-      Future future = (Future) this.membersMap.get(id);
+      Future future = membersMap.get(id);
-        this.system.getCancelCriterion().checkCancelInProgress(null);
+        system.getCancelCriterion().checkCancelInProgress(null);
-      } // for
-    } else {
-      return null;
+      }
+    return null;
-  private RemoteApplicationVM addMember(final InternalDistributedMember id) {
+  private RemoteApplicationVM addMember(InternalDistributedMember id) {
-    FutureTask future;
-    synchronized (this.membersLock) {
-      final Map oldMembersMap = this.membersMap;
-      future = (FutureTask) oldMembersMap.get(id);
+    Future<RemoteApplicationVM> future;
+    synchronized (membersLock) {
+      Map<InternalDistributedMember, Future<RemoteApplicationVM>> oldMembersMap = membersMap;
+      future = oldMembersMap.get(id);
-        if (this.abortCurrentJoin)
+        if (abortCurrentJoin) {
-        future = new FutureTask(new Callable() {
-          @Override
-          public Object call() throws Exception {
-            // Do this work in a Future to avoid deadlock seen in
-            // bug 31562.
-            RemoteGfManagerAgent agent = RemoteGfManagerAgent.this;
-            RemoteApplicationVM result = new RemoteApplicationVM(agent, id, alertLevel);
-            result.startStatDispatcher();
-            if (agent.abortCurrentJoin) {
-              result.stopStatListening();
-              return null;
-            }
-            return result;
+        }
+        future = new FutureTask<>(() -> {
+          // Do this work in a Future to avoid deadlock
+          RemoteGfManagerAgent agent = this;
+          RemoteApplicationVM result = new RemoteApplicationVM(agent, id, alertLevel);
+          result.startStatDispatcher();
+          if (agent.abortCurrentJoin) {
+            result.stopStatListening();
+            return null;
+          return result;
-        Map newMembersMap = new HashMap(oldMembersMap);
+        Map<InternalDistributedMember, Future<RemoteApplicationVM>> newMembersMap =
+            new HashMap<>(oldMembersMap);
-        if (this.abortCurrentJoin)
+        if (abortCurrentJoin)
-        this.membersMap = newMembersMap;
+        membersMap = newMembersMap;
-      future.run();
+      ((Runnable) future).run();
-      this.system.getCancelCriterion().checkCancelInProgress(null);
+      system.getCancelCriterion().checkCancelInProgress(null);
-        return (RemoteApplicationVM) future.get();
+        return future.get();
-    } // for
+    }
-   * with the given <code>id</code>.
+   * with the given {@code id}.
-  protected RemoteApplicationVM removeMember(InternalDistributedMember id) {
+  @VisibleForTesting
+  RemoteApplicationVM removeMember(InternalDistributedMember id) {
-    synchronized (this.membersLock) {
-      Map oldMembersMap = this.membersMap;
+    synchronized (membersLock) {
+      Map<InternalDistributedMember, Future<RemoteApplicationVM>> oldMembersMap = membersMap;
-        Map newMembersMap = new HashMap(oldMembersMap);
-        future = (Future) newMembersMap.remove(id);
+        Map<InternalDistributedMember, Future<RemoteApplicationVM>> newMembersMap =
+            new HashMap<>(oldMembersMap);
+        future = newMembersMap.remove(id);
-          this.membersMap = newMembersMap;
+          membersMap = newMembersMap;
-          this.system.getCancelCriterion().checkCancelInProgress(null);
+          system.getCancelCriterion().checkCancelInProgress(null);
-      } // for
-
-    } else {
-      return null;
+      }
+    return null;
-   * Places a <code>SnapshotResultMessage</code> on a queue to be processed asynchronously.
+   * Places a {@code SnapshotResultMessage} on a queue to be processed asynchronously.
-      this.system.getCancelCriterion().checkCancelInProgress(null);
+      system.getCancelCriterion().checkCancelInProgress(null);
-   * Sends the given <code>alert</code> to this agent's {@link AlertListener}.
+   * Sends the given {@code alert} to this agent's {@link AlertListener}.
-    if (alertListener != null && alert.getLevel() >= this.alertLevel) {
+    if (alertListener != null && alert.getLevel() >= alertLevel) {
-  protected void callCacheCollector(CacheSnapshot results, InternalDistributedMember sender,
+  private void callCacheCollector(CacheSnapshot results, InternalDistributedMember sender,
-  protected DisconnectListener getDisconnectListener() {
+  private DisconnectListener getDisconnectListener() {
-      return this.disconnectListener;
+      return disconnectListener;
-   * exists, it is <code>disconnected</code> and a new one is created.
+   * exists, it is {@code disconnected} and a new one is created.
-  protected void connectToDS() {
+  private void connectToDS() {
-    Properties props = this.transport.toDSProperties();
-    if (this.displayName != null && this.displayName.length() > 0) {
-      props.setProperty("name", this.displayName);
+    Properties props = transport.toDSProperties();
+    if (displayName != null && !displayName.isEmpty()) {
+      props.setProperty("name", displayName);
-      this.system = (InternalDistributedSystem) InternalDistributedSystem.connectForAdmin(props);
+      system = distributedSystemFactory.apply(props);
-      this.disconnected = false;
+      disconnected = false;
-    this.system.addDisconnectListener(new InternalDistributedSystem.DisconnectListener() {
+    system.addDisconnectListener(new InternalDistributedSystem.DisconnectListener() {
-        return String.format("Disconnect listener for %s",
-            RemoteGfManagerAgent.this);
+        return String.format("Disconnect listener for %s", RemoteGfManagerAgent.this);
-        // itself for
-        // the disconnection. Hence the check for RemoteGfManagerAgent.this.isConnected() always
-        // returns false.
-        // Hence commenting the same.
-        // if(RemoteGfManagerAgent.this.isConnected()) {
+        // itself for the disconnection. Hence the check for RemoteGfManagerAgent.this.isConnected()
+        // always returns false. Hence commenting the same.
-          final DisconnectListener listener = RemoteGfManagerAgent.this.getDisconnectListener();
-          if (RemoteGfManagerAgent.this.disconnect()) { // returns true if disconnected during this
-                                                        // call
+          DisconnectListener listener = getDisconnectListener();
+          if (disconnect()) {
+            // returns true if disconnected during this call
-      public void reconnecting(InternalDistributedSystem oldsys) {}
+      public void reconnecting(InternalDistributedSystem oldsys) {
+        // nothing
+      }
-    synchronized (this.myMembershipListenerLock) {
-      this.myMembershipListener = new MyMembershipListener();
-      dm.addMembershipListener(this.myMembershipListener);
-      Set initialMembers = dm.getDistributionManagerIds();
-      this.myMembershipListener.addMembers(new HashSet(initialMembers));
+    synchronized (myMembershipListenerLock) {
+      myMembershipListener = myMembershipListenerFactory.apply(this);
+      dm.addMembershipListener(myMembershipListener);
+      Set<InternalDistributedMember> initialMembers = dm.getDistributionManagerIds();
+      myMembershipListener.addMembers(new HashSet<>(initialMembers));
-        StringBuffer sb = new StringBuffer("[RemoteGfManagerAgent] ");
+        StringBuilder sb = new StringBuilder("[RemoteGfManagerAgent] ");
-        for (Iterator it = initialMembers.iterator(); it.hasNext();) {
-          InternalDistributedMember member = (InternalDistributedMember) it.next();
+        for (InternalDistributedMember member : initialMembers) {
-        this.logger.debug(sb.toString());
+        logger.debug(sb.toString());
-      for (Iterator it = initialMembers.iterator(); it.hasNext();) {
-        InternalDistributedMember member = (InternalDistributedMember) it.next();
-
+      for (InternalDistributedMember member : initialMembers) {
-          if (logger.isTraceEnabled(LogMarker.DM_VERBOSE)) {
-            logger.trace(LogMarker.DM_VERBOSE, "join cancelled by departure");
+          if (logger.isTraceEnabled(DM_VERBOSE)) {
+            logger.trace(DM_VERBOSE, "join cancelled by departure");
-      this.initialized = true;
-    } // sync
+      initialized = true;
+    }
-  //////////// inner classes ///////////////////////////
-
-  /**
-   * A Daemon thread that asynchronously connects to the distributed system. It is necessary to
-   * nicely handle the situation when the user accidentally connects to a distributed system with no
-   * members or attempts to connect to a distributed system whose member run a different version of
-   * GemFire.
-   */
-  private class DSConnectionDaemon extends LoggingThread {
-    /** Has this thread been told to stop? */
-    private volatile boolean shutDown = false;
-
-    protected DSConnectionDaemon() {
-      super("DSConnectionDaemon");
-    }
-
-    public void shutDown() {
-      shutDown = true;
-      this.interrupt();
-    }
-
-    /**
-     * Keep trying to connect to the distributed system. If we have problems connecting, the agent
-     * will not be marked as "connected".
-     */
-    @Override
-    public void run() {
-      TOP: while (!shutDown) {
-        SystemFailure.checkFailure();
-        try {
-          connected = false;
-          initialized = false;
-          if (!shutDown) {
-            connectToDS();
-
-            // If we're successful, this thread is done
-            if (isListening()) {
-              Assert.assertTrue(system != null);
-            }
-            return;
-          }
-        } catch (IncompatibleSystemException ise) {
-          logger.fatal(ise.getMessage(), ise);
-          callAlertListener(new VersionMismatchAlert(RemoteGfManagerAgent.this, ise.getMessage()));
-        } catch (Exception e) {
-          for (Throwable cause = e; cause != null; cause = cause.getCause()) {
-            if (cause instanceof InterruptedException) {
-              // We were interrupted while connecting. Most likely we
-              // are being shutdown.
-              if (shutDown) {
-                break TOP;
-              }
-            }
-
-            if (cause instanceof AuthenticationFailedException) {
-              // Incorrect credentials. Log & Shutdown
-              shutDown = true;
-              securityLogWriter.warning(
-                  "[RemoteGfManagerAgent]: An AuthenticationFailedException was caught while connecting to DS",
-                  e);
-              break TOP;
-            }
-          }
-
-          logger.debug("[RemoteGfManagerAgent] While connecting to DS", e);
-        }
-        try {
-          sleep(1000);
-        } catch (InterruptedException ignore) {
-          // We're just exiting, no need to restore the interrupt bit.
-        }
-      }
-      connected = false;
-      initialized = false;
-    }
-
-  } // end DSConnectionDaemon
-
-  /**
-   * A daemon thread that reads {@link SnapshotResultMessage}s from a queue and invokes the
-   * <code>CacheCollector</code> accordingly.
-   */
-  private class SnapshotResultDispatcher extends LoggingThread {
-    private volatile boolean shutDown = false;
-
-    public SnapshotResultDispatcher() {
-      super("SnapshotResultDispatcher");
-    }
-
-    public void shutDown() {
-      shutDown = true;
-      this.interrupt();
-    }
-
-    @Override
-    public void run() {
-      while (!shutDown) {
-        SystemFailure.checkFailure();
-        try {
-          SnapshotResultMessage msg = (SnapshotResultMessage) snapshotResults.take();
-          callCacheCollector(msg.getSnapshot(), msg.getSender(), msg.getSnapshotId());
-          yield(); // TODO: this is a hot thread
-        } catch (InterruptedException ignore) {
-          // We'll just exit, no need to reset interrupt bit.
-          if (shutDown) {
-            break;
-          }
-          logger.warn("Ignoring strange interrupt", ignore);
-        } catch (Exception ex) {
-          logger.fatal(ex.getMessage(), ex);
-        }
-      }
-    }
-  } // end SnapshotResultDispatcher
-
-    InternalDistributedSystem sys = this.system;
+    InternalDistributedSystem sys = system;
-  /** Returns the bind address this vm uses to connect to this system (Kirk Lund) */
-  public String getBindAddress() {
-    return this.transport.getBindAddress();
-  }
-
-  /** Returns true if this vm is using a non-default bind address (Kirk Lund) */
-  public boolean hasNonDefaultBindAddress() {
-    if (getBindAddress() == null)
-      return false;
-    return !DistributionConfig.DEFAULT_BIND_ADDRESS.equals(getBindAddress());
-  }
-
-    this.alertLevel = level;
+    alertLevel = level;
-    return this.system;
+    return system;
-  protected void handleJoined(InternalDistributedMember id) {
+  private void handleJoined(InternalDistributedMember id) {
-    this.currentJoin = id;
+    currentJoin = id;
-          throw new IllegalArgumentException(String.format("Unknown VM Kind: %s",
-              Integer.valueOf(id.getVmKind())));
+          throw new IllegalArgumentException(String.format("Unknown VM Kind: %s", id.getVmKind()));
-      if (this.abortCurrentJoin) {
+      if (abortCurrentJoin) {
-        if (this.abortCurrentJoin) {
+        if (abortCurrentJoin) {
-        for (Iterator it = this.listeners.iterator(); it.hasNext();) {
-          if (this.abortCurrentJoin) {
+        for (JoinLeaveListener listener : listeners) {
+          if (abortCurrentJoin) {
-          JoinLeaveListener l = (JoinLeaveListener) it.next();
-            l.nodeJoined(RemoteGfManagerAgent.this, member);
+            listener.nodeJoined(this, member);
-      if (this.abortCurrentJoin) {
+      if (abortCurrentJoin) {
-      this.currentJoin = null;
-      this.abortCurrentJoin = false;
+      currentJoin = null;
+      abortCurrentJoin = false;
-  protected void addPendingJoin(InternalDistributedMember id) {
-    synchronized (this.pendingJoinsLock) {
-      List oldPendingJoins = this.pendingJoins;
+  private void addPendingJoin(InternalDistributedMember id) {
+    synchronized (pendingJoinsLock) {
+      List<InternalDistributedMember> oldPendingJoins = pendingJoins;
-        List newPendingJoins = new ArrayList(oldPendingJoins);
+        List<InternalDistributedMember> newPendingJoins = new ArrayList<>(oldPendingJoins);
-        this.pendingJoins = newPendingJoins;
+        pendingJoins = newPendingJoins;
-    synchronized (this.pendingJoinsLock) {
-      List oldPendingJoins = this.pendingJoins;
+    synchronized (pendingJoinsLock) {
+      List<InternalDistributedMember> oldPendingJoins = pendingJoins;
-        List newPendingJoins = new ArrayList(oldPendingJoins);
+        List<InternalDistributedMember> newPendingJoins = new ArrayList<>(oldPendingJoins);
-        this.pendingJoins = newPendingJoins;
+        pendingJoins = newPendingJoins;
-  protected void cancelPendingJoins(InternalDistributedMember id) {
+  private void cancelPendingJoins(InternalDistributedMember id) {
-      this.joinProcessor.pauseHandling();
+      joinProcessor.pauseHandling();
-      this.joinProcessor.abort(id);
+      joinProcessor.abort(id);
-      this.joinProcessor.resumeHandling();
+      joinProcessor.resumeHandling();
+    }
+  }
+
+  @VisibleForTesting
+  void setMembersMap(Map<InternalDistributedMember, Future<RemoteApplicationVM>> membersMap) {
+    synchronized (membersLock) {
+      this.membersMap = membersMap;
+    }
+  }
+
+  /**
+   * A Daemon thread that asynchronously connects to the distributed system. It is necessary to
+   * nicely handle the situation when the user accidentally connects to a distributed system with no
+   * members or attempts to connect to a distributed system whose member run a different version of
+   * GemFire.
+   */
+  @VisibleForTesting
+  static class DSConnectionDaemon extends LoggingThread {
+
+    private final RemoteGfManagerAgent agent;
+
+    /**
+     * Has this thread been told to stop?
+     */
+    private volatile boolean shutDown;
+
+    private DSConnectionDaemon(RemoteGfManagerAgent agent) {
+      super("DSConnectionDaemon");
+      this.agent = agent;
+    }
+
+    public void shutDown() {
+      shutDown = true;
+      interrupt();
+    }
+
+    /**
+     * Keep trying to connect to the distributed system. If we have problems connecting, the agent
+     * will not be marked as "connected".
+     */
+    @Override
+    public void run() {
+      TOP: while (!shutDown) {
+        SystemFailure.checkFailure();
+        try {
+          agent.connected = false;
+          agent.initialized = false;
+          if (!shutDown) {
+            agent.connectToDS();
+
+            // If we're successful, this thread is done
+            if (agent.isListening()) {
+              Assert.assertTrue(agent.system != null);
+            }
+            return;
+          }
+        } catch (IncompatibleSystemException ise) {
+          logger.fatal(ise.getMessage(), ise);
+          agent.callAlertListener(new VersionMismatchAlert(agent, ise.getMessage()));
+        } catch (Exception e) {
+          for (Throwable cause = e; cause != null; cause = cause.getCause()) {
+            if (cause instanceof InterruptedException) {
+              // We were interrupted while connecting. Most likely we are being shutdown.
+              if (shutDown) {
+                break TOP;
+              }
+            }
+
+            if (cause instanceof AuthenticationFailedException) {
+              // Incorrect credentials. Log & Shutdown
+              shutDown = true;
+              agent.securityLogWriter.warning(
+                  "[RemoteGfManagerAgent]: An AuthenticationFailedException was caught while connecting to DS",
+                  e);
+              break TOP;
+            }
+          }
+
+          logger.debug("[RemoteGfManagerAgent] While connecting to DS", e);
+        }
+        try {
+          sleep(1000);
+        } catch (InterruptedException ignore) {
+          // We're just exiting, no need to restore the interrupt bit.
+        }
+      }
+      agent.connected = false;
+      agent.initialized = false;
+    }
+  }
+
+  /**
+   * A daemon thread that reads {@link SnapshotResultMessage}s from a queue and invokes the
+   * {@code CacheCollector} accordingly.
+   */
+  @VisibleForTesting
+  static class SnapshotResultDispatcher extends LoggingThread {
+
+    private final RemoteGfManagerAgent agent;
+
+    private volatile boolean shutDown;
+
+    private SnapshotResultDispatcher(RemoteGfManagerAgent agent) {
+      super("SnapshotResultDispatcher");
+      this.agent = agent;
+    }
+
+    public void shutDown() {
+      shutDown = true;
+      interrupt();
+    }
+
+    @Override
+    public void run() {
+      while (!shutDown) {
+        SystemFailure.checkFailure();
+        try {
+          SnapshotResultMessage msg = agent.snapshotResults.take();
+          agent.callCacheCollector(msg.getSnapshot(), msg.getSender(), msg.getSnapshotId());
+          yield();
+        } catch (InterruptedException ignore) {
+          // We'll just exit, no need to reset interrupt bit.
+          if (shutDown) {
+            break;
+          }
+          logger.warn("Ignoring strange interrupt", ignore);
+        } catch (Exception ex) {
+          logger.fatal(ex.getMessage(), ex);
+        }
+      }
-  // FIXME: Revisit/redesign this code
-  private class JoinProcessor extends LoggingThread {
-    private volatile boolean paused = false;
-    private volatile boolean shutDown = false;
-    private volatile InternalDistributedMember id;
+  @VisibleForTesting
+  static class JoinProcessor extends LoggingThread {
+
+    private final RemoteGfManagerAgent agent;
-    public JoinProcessor() {
+    private volatile boolean paused;
+    private volatile boolean shutDown;
+    private volatile InternalDistributedMember id;
+
+    private JoinProcessor(RemoteGfManagerAgent agent) {
+      this.agent = agent;
-      if (logger.isTraceEnabled(LogMarker.DM_VERBOSE)) {
-        logger.trace(LogMarker.DM_VERBOSE, "JoinProcessor: shutting down");
+      if (logger.isTraceEnabled(DM_VERBOSE)) {
+        logger.trace(DM_VERBOSE, "JoinProcessor: shutting down");
-      this.shutDown = true;
-      this.interrupt();
+      shutDown = true;
+      interrupt();
-      this.paused = true;
+      paused = true;
-      if (logger.isTraceEnabled(LogMarker.DM_VERBOSE)) {
-        logger.trace(LogMarker.DM_VERBOSE, "JoinProcessor: resuming.  Is alive? {}",
-            this.isAlive());
+      if (logger.isTraceEnabled(DM_VERBOSE)) {
+        logger.trace(DM_VERBOSE, "JoinProcessor: resuming.  Is alive? {}",
+            isAlive());
-      this.paused = false;
+      paused = false;
-      synchronized (this.lock) {
-        this.lock.notify();
+      synchronized (lock) {
+        lock.notifyAll();
-      if (memberId.equals(RemoteGfManagerAgent.this.currentJoin)) {
-        RemoteGfManagerAgent.this.abortCurrentJoin = true;
-        this.interrupt();
+      if (memberId.equals(agent.currentJoin)) {
+        agent.abortCurrentJoin = true;
+        interrupt();
-      if (this.id != null && this.id.equals(memberId)) {
-        this.id = null;
+      if (memberId.equals(id)) {
+        id = null;
-      OUTER: while (!this.shutDown) {
+      OUTER: while (!shutDown) {
-          if (!RemoteGfManagerAgent.this.isListening()) {
+          if (!agent.isListening()) {
-          noPendingJoins = RemoteGfManagerAgent.this.pendingJoins.isEmpty();
+          noPendingJoins = agent.pendingJoins.isEmpty();
-          if (this.paused || noPendingJoins) {
-            if (logger.isTraceEnabled(LogMarker.DM_VERBOSE)) {
-              logger.trace(LogMarker.DM_VERBOSE, "JoinProcessor is about to wait...");
+          if (paused || noPendingJoins) {
+            if (logger.isTraceEnabled(DM_VERBOSE)) {
+              logger.trace(DM_VERBOSE, "JoinProcessor is about to wait...");
-            synchronized (this.lock) {
-              this.lock.wait();
+            synchronized (lock) {
+              lock.wait();
-          if (logger.isTraceEnabled(LogMarker.DM_VERBOSE)) {
-            logger.trace(LogMarker.DM_VERBOSE, "JoinProcessor has woken up...");
+          if (logger.isTraceEnabled(DM_VERBOSE)) {
+            logger.trace(DM_VERBOSE, "JoinProcessor has woken up...");
-          if (this.paused)
+          if (paused) {
+          }
-          if (this.id == null) {
-            List pendingJoinsRef = RemoteGfManagerAgent.this.pendingJoins;
-            if (logger.isTraceEnabled(LogMarker.DM_VERBOSE)) {
-              logger.trace(LogMarker.DM_VERBOSE, "JoinProcessor pendingJoins: {}",
-                  pendingJoinsRef.size());
+          if (id == null) {
+            List pendingJoinsRef = agent.pendingJoins;
+            if (logger.isTraceEnabled(DM_VERBOSE)) {
+              logger.trace(DM_VERBOSE, "JoinProcessor pendingJoins: {}", pendingJoinsRef.size());
-            if (pendingJoinsRef.size() > 0) {
-              this.id = (InternalDistributedMember) pendingJoinsRef.get(0);
-              if (logger.isTraceEnabled(LogMarker.DM_VERBOSE)) {
-                logger.trace(LogMarker.DM_VERBOSE, "JoinProcessor got a membership event for {}",
-                    this.id);
+            if (!pendingJoinsRef.isEmpty()) {
+              id = (InternalDistributedMember) pendingJoinsRef.get(0);
+              if (logger.isTraceEnabled(DM_VERBOSE)) {
+                logger.trace(DM_VERBOSE, "JoinProcessor got a membership event for {}", id);
-          if (this.paused)
+          if (paused) {
+          }
-          if (this.id != null) {
-            if (logger.isTraceEnabled(LogMarker.DM_VERBOSE)) {
-              logger.trace(LogMarker.DM_VERBOSE, "JoinProcessor handling join for {}", this.id);
+          if (id != null) {
+            if (logger.isTraceEnabled(DM_VERBOSE)) {
+              logger.trace(DM_VERBOSE, "JoinProcessor handling join for {}", id);
-              RemoteGfManagerAgent.this.handleJoined(this.id);
+              agent.handleJoined(id);
-              this.id = null;
+              id = null;
-        } catch (InterruptedException ignore) {
+        } catch (InterruptedException e) {
-          if (logger.isTraceEnabled(LogMarker.DM_VERBOSE)) {
-            logger.trace(LogMarker.DM_VERBOSE, "JoinProcessor has been interrupted...");
+          if (logger.isTraceEnabled(DM_VERBOSE)) {
+            logger.trace(DM_VERBOSE, "JoinProcessor has been interrupted...");
-          if (this.paused || noPendingJoins) {// fix for #39893
+          if (paused || noPendingJoins) {
-              logger.debug("JoinProcessor was interrupted when it was paused, now resuming ...",
-                  ignore);
+              logger.debug("JoinProcessor was interrupted when it was paused, now resuming ...", e);
-          if (logger.isTraceEnabled(LogMarker.DM_VERBOSE)) {
-            logger.trace(LogMarker.DM_VERBOSE, "join cancelled by departure");
+          if (logger.isTraceEnabled(DM_VERBOSE)) {
+            logger.trace(DM_VERBOSE, "join cancelled by departure");
-          continue;
-              if (logger.isTraceEnabled(LogMarker.DM_VERBOSE)) {
-                logger.trace(LogMarker.DM_VERBOSE, "JoinProcessor has been interrupted...");
+              if (logger.isTraceEnabled(DM_VERBOSE)) {
+                logger.trace(DM_VERBOSE, "JoinProcessor has been interrupted...");
-        } // catch Throwable
-      } // while !shutDown
+        }
+      }
-  private class MyMembershipListener implements MembershipListener {
+  @VisibleForTesting
+  static class MyMembershipListener implements MembershipListener {
-    private final Set distributedMembers = new HashSet();
+    private final Set<InternalDistributedMember> distributedMembers = new HashSet<>();
-    protected MyMembershipListener() {}
+    private final RemoteGfManagerAgent agent;
-    protected void addMembers(Set initMembers) {
+    private MyMembershipListener(RemoteGfManagerAgent agent) {
+      this.agent = agent;
+    }
+
+    private void addMembers(Set initMembers) {
-        final InternalDistributedMember id) {
-      if (!isListening()) {
+        InternalDistributedMember id) {
+      if (!agent.isListening()) {
-        if (!this.distributedMembers.contains(id)) {
-          this.distributedMembers.add(id);
-          addPendingJoin(id);
-          joinProcessor.resumeHandling();
+        if (!distributedMembers.contains(id)) {
+          distributedMembers.add(id);
+          agent.addPendingJoin(id);
+          agent.joinProcessor.resumeHandling();
-    @Override
-    public void memberSuspect(DistributionManager distributionManager, InternalDistributedMember id,
-        InternalDistributedMember whoSuspected, String reason) {}
-
-    @Override
-    public void quorumLost(DistributionManager distributionManager,
-        Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {}
-
-        if (!this.distributedMembers.remove(id)) {
+        if (!distributedMembers.remove(id)) {
-        cancelPendingJoins(id);
-        if (!isListening()) {
+        agent.cancelPendingJoins(id);
+        if (!agent.isListening()) {
-          member = removeMember(id);
+          member = agent.removeMember(id);
-          throw new IllegalArgumentException(
-              "Unknown VM Kind");
+          throw new IllegalArgumentException("Unknown VM Kind");
-        for (Iterator it = listeners.iterator(); it.hasNext();) {
-          JoinLeaveListener l = (JoinLeaveListener) it.next();
+        for (JoinLeaveListener listener : agent.listeners) {
-            l.nodeCrashed(RemoteGfManagerAgent.this, member);
+            listener.nodeCrashed(agent, member);
-            l.nodeLeft(RemoteGfManagerAgent.this, member);
+            listener.nodeLeft(agent, member);
-

MOV26 MOV26 MOV26 MOV26 MOV26 INS26 INS26 MOV23 MOV55 MOV55 UPD40 UPD40 UPD40 UPD40 INS40 UPD40 INS40 INS23 INS23 INS23 INS23 INS31 MOV23 UPD83 UPD83 UPD83 UPD83 INS74 UPD83 INS74 UPD83 INS83 INS74 INS83 UPD83 INS83 UPD83 INS74 UPD83 UPD83 UPD83 INS83 INS74 INS29 INS83 INS83 INS83 INS74 INS59 INS83 INS83 INS74 INS59 INS83 INS83 INS74 INS59 INS83 INS83 INS74 INS59 INS42 INS44 INS78 INS44 INS44 INS44 INS44 INS44 MOV21 UPD83 UPD83 INS78 UPD83 UPD83 MOV43 UPD83 UPD83 UPD83 UPD83 INS78 INS39 INS42 INS44 INS8 INS78 INS83 INS42 INS23 INS31 INS78 UPD83 INS23 INS31 MOV31 INS78 UPD83 INS23 INS78 UPD83 INS23 UPD66 INS65 INS66 INS65 UPD66 MOV43 INS43 INS32 MOV43 INS43 INS74 INS32 MOV43 MOV43 INS43 INS43 INS32 MOV43 INS43 INS65 MOV43 MOV43 INS42 INS32 INS43 INS43 INS43 INS42 INS43 INS43 INS43 INS42 INS43 INS43 INS43 INS42 INS70 INS65 INS43 INS42 INS17 INS42 INS74 INS42 INS74 INS42 INS74 INS42 INS74 INS42 INS74 INS42 INS21 INS21 INS21 MOV41 MOV41 INS43 INS42 INS41 INS42 INS74 INS42 INS51 INS42 INS83 INS83 INS43 INS59 UPD83 INS44 INS83 INS39 INS42 INS8 INS42 INS83 INS83 INS43 INS59 UPD83 MOV83 MOV42 INS44 MOV8 INS42 INS83 INS83 INS43 INS59 UPD83 INS44 INS42 INS74 INS83 INS83 INS43 INS59 UPD83 INS44 UPD83 MOV44 INS66 INS66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS66 INS65 UPD66 UPD42 MOV42 INS42 INS42 INS43 INS43 INS42 INS66 INS65 UPD66 INS74 UPD66 UPD66 UPD66 MOV42 INS42 INS42 UPD66 UPD66 INS66 INS65 UPD66 UPD66 UPD42 MOV42 INS74 INS66 INS42 INS42 INS86 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS8 MOV43 INS44 INS42 MOV8 UPD66 MOV66 INS65 INS66 INS66 UPD42 MOV42 INS42 INS86 INS89 INS89 INS89 INS89 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS43 INS7 INS7 INS7 INS66 INS65 UPD66 INS42 INS66 INS65 UPD66 INS42 INS66 INS65 UPD66 INS42 INS66 INS65 INS66 INS65 UPD66 INS42 INS65 UPD66 UPD66 INS65 INS66 INS42 INS74 INS42 UPD66 INS65 INS66 INS42 INS33 INS66 INS65 UPD66 UPD66 INS65 INS66 INS66 INS65 UPD66 INS42 INS42 INS42 INS42 INS43 MOV43 INS74 INS42 MOV8 INS42 INS42 INS43 INS42 INS21 INS21 INS21 INS65 UPD66 INS42 INS42 INS43 INS42 MOV46 INS42 INS42 INS43 INS42 INS21 INS43 INS43 INS42 INS42 INS43 INS42 INS21 INS66 INS42 INS42 INS66 MOV43 INS66 MOV43 INS40 INS41 INS42 INS43 INS42 UPD66 MOV66 INS59 MOV11 MOV43 MOV43 MOV43 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS22 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS32 INS42 INS32 INS32 INS66 UPD45 INS42 INS27 INS66 INS66 INS66 INS66 MOV21 MOV21 MOV53 INS66 INS66 MOV43 INS43 INS66 INS25 INS66 INS66 INS66 INS38 INS42 INS70 INS42 INS42 INS42 MOV25 INS42 INS43 INS43 UPD66 INS42 INS7 INS7 INS32 INS66 INS42 INS42 INS7 INS42 INS32 MOV42 INS42 INS74 INS42 INS7 INS42 INS74 INS74 INS42 MOV43 INS42 UPD42 INS52 INS42 INS52 INS42 INS42 INS42 INS52 INS42 INS42 INS52 INS42 INS42 INS52 UPD42 INS42 INS38 MOV42 INS74 INS70 INS74 INS74 MOV32 MOV43 MOV43 UPD42 MOV42 INS74 INS74 MOV32 INS8 INS42 INS42 INS42 INS42 INS32 MOV74 INS44 INS42 INS8 INS42 INS42 INS74 INS74 INS42 INS42 INS22 INS42 MOV42 MOV9 INS42 INS40 INS40 INS22 INS42 INS22 INS42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 MOV42 UPD42 MOV42 MOV43 INS22 INS42 INS70 MOV43 INS43 MOV43 INS43 INS42 INS42 INS42 INS38 INS70 INS32 MOV43 INS43 INS44 INS32 MOV8 MOV43 INS43 INS42 MOV60 MOV43 MOV43 INS42 MOV60 INS32 MOV43 MOV43 INS74 INS42 MOV32 INS60 INS36 MOV8 MOV43 MOV43 INS74 INS42 MOV60 MOV21 MOV25 INS42 UPD42 MOV42 INS42 INS42 INS32 INS42 INS42 INS32 INS42 INS42 INS70 MOV43 INS42 MOV54 INS42 INS70 INS42 INS42 INS43 INS43 INS42 MOV60 INS43 INS43 INS42 MOV60 INS42 INS42 MOV42 UPD42 INS52 INS42 INS52 INS42 INS52 INS42 INS42 INS52 INS42 INS42 INS8 MOV8 INS44 INS40 INS8 UPD42 MOV42 INS74 INS42 INS42 INS74 MOV43 INS42 UPD42 INS42 INS32 INS44 INS42 MOV8 INS42 UPD42 MOV42 INS42 INS74 INS74 INS42 INS42 MOV42 INS42 INS74 INS74 MOV43 INS42 MOV42 MOV42 MOV43 INS43 INS42 MOV8 INS74 INS59 INS42 INS11 INS42 INS32 MOV43 INS43 INS74 MOV27 INS42 INS42 INS42 INS42 INS42 INS42 INS52 INS74 UPD43 INS44 INS42 MOV8 MOV32 INS42 INS44 INS42 MOV8 MOV42 INS42 INS74 INS42 INS42 MOV74 INS42 INS42 INS42 UPD42 INS40 INS42 INS41 INS42 INS42 MOV43 INS42 MOV25 MOV43 MOV43 INS42 INS42 UPD42 MOV42 INS43 INS42 MOV42 MOV43 INS42 MOV43 INS43 MOV43 INS43 INS42 MOV43 MOV43 INS42 INS42 MOV14 MOV43 MOV43 INS74 INS42 INS14 INS42 INS43 INS42 MOV42 MOV42 INS42 MOV43 MOV43 INS74 MOV32 INS21 MOV43 UPD42 MOV43 INS42 INS42 UPD42 UPD42 INS45 MOV43 INS42 MOV25 INS43 INS43 INS42 INS42 MOV43 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS74 INS42 INS74 INS42 INS74 INS86 INS42 INS43 INS43 INS74 INS42 INS42 INS43 INS43 INS74 INS7 UPD43 INS42 INS42 INS42 INS74 INS74 INS32 INS42 INS42 INS8 INS42 INS8 UPD42 INS42 INS42 INS40 INS42 MOV43 MOV43 INS42 MOV43 MOV8 INS42 INS42 MOV43 INS42 INS42 MOV43 INS42 INS42 UPD42 MOV43 MOV43 INS40 INS40 INS40 MOV42 INS42 INS42 INS18 INS42 INS18 INS42 INS42 MOV43 INS42 INS42 INS42 INS40 INS42 INS38 INS42 INS42 INS42 UPD42 INS42 UPD42 INS42 INS42 INS42 UPD43 UPD42 INS42 INS42 INS42 INS42 INS42 INS40 INS42 INS32 INS42 UPD42 UPD42 UPD42 INS42 MOV42 UPD42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 INS40 INS40 UPD42 INS42 INS42 INS42 INS42 DEL9 DEL40 DEL43 DEL40 DEL40 DEL43 DEL40 DEL9 DEL9 DEL9 DEL43 DEL42 DEL43 DEL9 DEL43 DEL42 DEL43 DEL41 DEL42 DEL42 DEL42 DEL32 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL42 DEL42 DEL32 DEL27 DEL42 DEL37 DEL24 DEL65 DEL65 DEL83 DEL43 DEL42 DEL42 DEL41 DEL66 DEL66 DEL65 DEL29 DEL83 DEL14 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL14 DEL14 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL9 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL32 DEL34 DEL27 DEL36 DEL42 DEL42 DEL2 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL24 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL32 DEL34 DEL27 DEL27 DEL36 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL52 DEL42 DEL22 DEL43 DEL42 DEL52 DEL42 DEL22 DEL32 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL8 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL66 DEL65 DEL29 DEL83 DEL83 DEL83 DEL42 DEL43 DEL42 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL40 DEL41 DEL8 DEL31 DEL1 DEL14 DEL59 DEL23 DEL11 DEL36 DEL42 DEL32 DEL8 DEL52 DEL42 DEL22 DEL8 DEL83 DEL52 DEL42 DEL22 DEL32 DEL11 DEL52 DEL42 DEL22 DEL83 DEL43 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL42 DEL43 DEL11 DEL52 DEL42 DEL22 DEL42 DEL42 DEL43 DEL42 DEL78 DEL83 DEL42 DEL43 DEL42 DEL42 DEL43 DEL31 DEL1 DEL14 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL42 DEL43 DEL32 DEL11 DEL33 DEL41 DEL8 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL11 DEL42 DEL42 DEL14 DEL59 DEL60 DEL25 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL32 DEL34 DEL27 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL42 DEL52 DEL42 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL14 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL52 DEL42 DEL22 DEL40 DEL40 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL24 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL66 DEL65 DEL29 DEL83 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL41 DEL8 DEL31 DEL66 DEL65 DEL29 DEL83 DEL39 DEL42 DEL42 DEL32 DEL33 DEL27 DEL9 DEL41 DEL25 DEL40 DEL42 DEL42 DEL32 DEL32 DEL38 DEL41 DEL8 DEL31 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL45 DEL32 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL43 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL42 DEL9 DEL42 DEL42 DEL42 DEL42 DEL52 DEL42 DEL42 DEL9 DEL52 DEL42 DEL32 DEL21 DEL52 DEL8 DEL31 DEL83 DEL39 DEL42 DEL31 DEL42 DEL32 DEL11 DEL9 DEL9 DEL40 DEL40 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL40 DEL40 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL52 DEL52 DEL42 DEL22 DEL33 DEL27 DEL52 DEL42 DEL22 DEL32 DEL27 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL40 DEL40 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL40 DEL40 DEL52 DEL42 DEL22 DEL18 DEL52 DEL42 DEL22 DEL42 DEL52 DEL42 DEL22 DEL40 DEL40 DEL32 DEL34 DEL27 DEL52 DEL42 DEL22 DEL40 DEL40 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL18 DEL52 DEL42 DEL22 DEL40 DEL40 DEL52 DEL42 DEL22 DEL42 DEL52 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL40 DEL40 DEL52 DEL42 DEL22 DEL40 DEL40 DEL18 DEL40 DEL40 DEL43 DEL83 DEL42 DEL44 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL8 DEL31 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL44 DEL42 DEL44 DEL8 DEL31 DEL52 DEL42 DEL22 DEL41 DEL8 DEL42 DEL52 DEL42 DEL52 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL8 DEL24
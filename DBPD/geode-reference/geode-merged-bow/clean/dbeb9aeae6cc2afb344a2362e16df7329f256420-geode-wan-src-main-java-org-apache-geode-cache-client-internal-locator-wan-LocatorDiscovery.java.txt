Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class represent a runnable task which exchange the locator information
- * with local locators(within the site) as well as remote locators (across the
- * site)
+ * This class represent a runnable task which exchange the locator information with local
+ * locators(within the site) as well as remote locators (across the site)
-public class LocatorDiscovery{
+public class LocatorDiscovery {
-  
+
-  
+
-  
+
-  public static final int WAN_LOCATOR_CONNECTION_RETRY_ATTEMPT = Integer
-      .getInteger("WANLocator.CONNECTION_RETRY_ATTEMPT", 50000).intValue();
+  public static final int WAN_LOCATOR_CONNECTION_RETRY_ATTEMPT =
+      Integer.getInteger("WANLocator.CONNECTION_RETRY_ATTEMPT", 50000).intValue();
-  public static final int WAN_LOCATOR_CONNECTION_INTERVAL = Integer.getInteger(
-      "WANLocator.CONNECTION_INTERVAL", 10000).intValue();
+  public static final int WAN_LOCATOR_CONNECTION_INTERVAL =
+      Integer.getInteger("WANLocator.CONNECTION_INTERVAL", 10000).intValue();
-  public static final int WAN_LOCATOR_PING_INTERVAL = Integer.getInteger(
-      "WANLocator.PING_INTERVAL", 10000).intValue();
+  public static final int WAN_LOCATOR_PING_INTERVAL =
+      Integer.getInteger("WANLocator.PING_INTERVAL", 10000).intValue();
-  public LocatorDiscovery(WanLocatorDiscoverer discoverer, DistributionLocatorId locator,RemoteLocatorJoinRequest request,
-      LocatorMembershipListener locatorListener) {
+  public LocatorDiscovery(WanLocatorDiscoverer discoverer, DistributionLocatorId locator,
+      RemoteLocatorJoinRequest request, LocatorMembershipListener locatorListener) {
-    this.request = request; 
+    this.request = request;
-  
-  /**
-   * When a batch fails, then this keeps the last time when a failure was logged
-   * . We don't want to swamp the logs in retries due to same batch failures.
-   */
-  private final ConcurrentHashMap<DistributionLocatorId, long[]> failureLogInterval = new ConcurrentHashMap<DistributionLocatorId, long[]>();
-   * The maximum size of {@link #failureLogInterval} beyond which it will start
-   * logging all failure instances. Hopefully this should never happen in
-   * practice.
+   * When a batch fails, then this keeps the last time when a failure was logged . We don't want to
+   * swamp the logs in retries due to same batch failures.
-  private static final int FAILURE_MAP_MAXSIZE = Integer.getInteger(
-      DistributionConfig.GEMFIRE_PREFIX + "GatewaySender.FAILURE_MAP_MAXSIZE", 1000000);
+  private final ConcurrentHashMap<DistributionLocatorId, long[]> failureLogInterval =
+      new ConcurrentHashMap<DistributionLocatorId, long[]>();
+
+  /**
+   * The maximum size of {@link #failureLogInterval} beyond which it will start logging all failure
+   * instances. Hopefully this should never happen in practice.
+   */
+  private static final int FAILURE_MAP_MAXSIZE = Integer
+      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "GatewaySender.FAILURE_MAP_MAXSIZE", 1000000);
-            new long[] { System.currentTimeMillis(), 1000 });
+            new long[] {System.currentTimeMillis(), 1000});
-  
+
-        RemoteLocatorJoinResponse response = (RemoteLocatorJoinResponse)locatorClient
-            .requestToServer(locatorId.getHost(), locatorId.getPort(), request,
-                WanLocatorDiscoverer.WAN_LOCATOR_CONNECTION_TIMEOUT);
+        RemoteLocatorJoinResponse response =
+            (RemoteLocatorJoinResponse) locatorClient.requestToServer(locatorId.getHost(),
+                locatorId.getPort(), request, WanLocatorDiscoverer.WAN_LOCATOR_CONNECTION_TIMEOUT);
-          LocatorHelper.addExchangedLocators(response.getLocators(),
-              this.locatorListener);
-          logger.info(LocalizedMessage.create(LocalizedStrings.LOCATOR_DISCOVERY_TASK_EXCHANGED_LOCATOR_INFORMATION_0_WITH_1,
-              new Object[] { request.getLocator(), locatorId, response.getLocators() }));
+          LocatorHelper.addExchangedLocators(response.getLocators(), this.locatorListener);
+          logger.info(LocalizedMessage.create(
+              LocalizedStrings.LOCATOR_DISCOVERY_TASK_EXCHANGED_LOCATOR_INFORMATION_0_WITH_1,
+              new Object[] {request.getLocator(), locatorId, response.getLocators()}));
-      }
-      catch (IOException ioe) {
+      } catch (IOException ioe) {
-          ConnectionException coe = new ConnectionException(
-              "Not able to connect to local locator after "
-              + WAN_LOCATOR_CONNECTION_RETRY_ATTEMPT + " retry attempts",
-          ioe);
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.LOCATOR_DISCOVERY_TASK_COULD_NOT_EXCHANGE_LOCATOR_INFORMATION_0_WITH_1_AFTER_2,
-              new Object[] { request.getLocator(),locatorId, retryAttempt }), coe);
+          ConnectionException coe =
+              new ConnectionException("Not able to connect to local locator after "
+                  + WAN_LOCATOR_CONNECTION_RETRY_ATTEMPT + " retry attempts", ioe);
+          logger.fatal(LocalizedMessage.create(
+              LocalizedStrings.LOCATOR_DISCOVERY_TASK_COULD_NOT_EXCHANGE_LOCATOR_INFORMATION_0_WITH_1_AFTER_2,
+              new Object[] {request.getLocator(), locatorId, retryAttempt}), coe);
-          logger.warn(LocalizedMessage.create(LocalizedStrings.LOCATOR_DISCOVERY_TASK_COULD_NOT_EXCHANGE_LOCATOR_INFORMATION_0_WITH_1_AFTER_2_RETRYING_IN_3_MS,
-              new Object[] { request.getLocator(), locatorId, retryAttempt, WAN_LOCATOR_CONNECTION_INTERVAL }));
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.LOCATOR_DISCOVERY_TASK_COULD_NOT_EXCHANGE_LOCATOR_INFORMATION_0_WITH_1_AFTER_2_RETRYING_IN_3_MS,
+              new Object[] {request.getLocator(), locatorId, retryAttempt,
+                  WAN_LOCATOR_CONNECTION_INTERVAL}));
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-      }
-      catch (ClassNotFoundException classNotFoundException) {
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.LOCATOR_DISCOVERY_TASK_ENCOUNTERED_UNEXPECTED_EXCEPTION), classNotFoundException);
+      } catch (ClassNotFoundException classNotFoundException) {
+        logger.fatal(
+            LocalizedMessage
+                .create(LocalizedStrings.LOCATOR_DISCOVERY_TASK_ENCOUNTERED_UNEXPECTED_EXCEPTION),
+            classNotFoundException);
-  
+
-        response = (RemoteLocatorJoinResponse)locatorClient
-            .requestToServer(remoteLocator.getHost(), remoteLocator.getPort(),
-                request, WanLocatorDiscoverer.WAN_LOCATOR_CONNECTION_TIMEOUT);
+        response =
+            (RemoteLocatorJoinResponse) locatorClient.requestToServer(remoteLocator.getHost(),
+                remoteLocator.getPort(), request,
+                WanLocatorDiscoverer.WAN_LOCATOR_CONNECTION_TIMEOUT);
-          logger.info(LocalizedMessage.create(LocalizedStrings.LOCATOR_DISCOVERY_TASK_EXCHANGED_LOCATOR_INFORMATION_0_WITH_1,
-              new Object[] { request.getLocator(), locatorId, response.getLocators() }));
-          RemoteLocatorPingRequest pingRequest = new RemoteLocatorPingRequest(
-              "");
+          logger.info(LocalizedMessage.create(
+              LocalizedStrings.LOCATOR_DISCOVERY_TASK_EXCHANGED_LOCATOR_INFORMATION_0_WITH_1,
+              new Object[] {request.getLocator(), locatorId, response.getLocators()}));
+          RemoteLocatorPingRequest pingRequest = new RemoteLocatorPingRequest("");
-            RemoteLocatorPingResponse pingResponse = (RemoteLocatorPingResponse)locatorClient
-                .requestToServer(remoteLocator.getHost(),
+            RemoteLocatorPingResponse pingResponse =
+                (RemoteLocatorPingResponse) locatorClient.requestToServer(remoteLocator.getHost(),
-      }
-      catch (IOException ioe) {
+      } catch (IOException ioe) {
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.LOCATOR_DISCOVERY_TASK_COULD_NOT_EXCHANGE_LOCATOR_INFORMATION_0_WITH_1_AFTER_2,
-              new Object[] { request.getLocator(), remoteLocator, retryAttempt}), ioe);
+          logger.fatal(LocalizedMessage.create(
+              LocalizedStrings.LOCATOR_DISCOVERY_TASK_COULD_NOT_EXCHANGE_LOCATOR_INFORMATION_0_WITH_1_AFTER_2,
+              new Object[] {request.getLocator(), remoteLocator, retryAttempt}), ioe);
-          logger.warn(LocalizedMessage.create(LocalizedStrings.LOCATOR_DISCOVERY_TASK_COULD_NOT_EXCHANGE_LOCATOR_INFORMATION_0_WITH_1_AFTER_2_RETRYING_IN_3_MS,
-              new Object[] { request.getLocator(), remoteLocator, retryAttempt, WAN_LOCATOR_CONNECTION_INTERVAL }));
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.LOCATOR_DISCOVERY_TASK_COULD_NOT_EXCHANGE_LOCATOR_INFORMATION_0_WITH_1_AFTER_2_RETRYING_IN_3_MS,
+              new Object[] {request.getLocator(), remoteLocator, retryAttempt,
+                  WAN_LOCATOR_CONNECTION_INTERVAL}));
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-      }
-      catch (ClassNotFoundException classNotFoundException) {
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.LOCATOR_DISCOVERY_TASK_ENCOUNTERED_UNEXPECTED_EXCEPTION), classNotFoundException);
+      } catch (ClassNotFoundException classNotFoundException) {
+        logger.fatal(
+            LocalizedMessage
+                .create(LocalizedStrings.LOCATOR_DISCOVERY_TASK_ENCOUNTERED_UNEXPECTED_EXCEPTION),
+            classNotFoundException);
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66
Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-  private final Map/*<ServerLocation, ConnectionStats>*/<ServerLocation, ConnectionStats> statMap = new HashMap<ServerLocation, ConnectionStats>();
+  private final Map/* <ServerLocation, ConnectionStats> */<ServerLocation, ConnectionStats> statMap =
+      new HashMap<ServerLocation, ConnectionStats>();
-  
-  public EndpointManagerImpl(String poolName, DistributedSystem ds,CancelCriterion cancelCriterion, PoolStats poolStats) {
+
+  public EndpointManagerImpl(String poolName, DistributedSystem ds, CancelCriterion cancelCriterion,
+      PoolStats poolStats) {
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.client.internal.EndpointManager#referenceEndpoint(org.apache.geode.distributed.internal.ServerLocation)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.cache.client.internal.EndpointManager#referenceEndpoint(org.apache.geode.
+   * distributed.internal.ServerLocation)
-    //logger.warn("REFENDPOINT server:"+server+" memberId:"+memberId);
+    // logger.warn("REFENDPOINT server:"+server+" memberId:"+memberId);
-    if(endpoint == null || endpoint.isClosed()) {
-      synchronized(this) {
+    if (endpoint == null || endpoint.isClosed()) {
+      synchronized (this) {
-        if(endpoint == null || endpoint.isClosed()) {
-          ConnectionStats stats  = getStats(server);
-          Map<ServerLocation, Endpoint> endpointMapTemp = new HashMap<ServerLocation, Endpoint>(endpointMap);
+        if (endpoint == null || endpoint.isClosed()) {
+          ConnectionStats stats = getStats(server);
+          Map<ServerLocation, Endpoint> endpointMapTemp =
+              new HashMap<ServerLocation, Endpoint>(endpointMap);
-    
+
-    
-    if(addedEndpoint) {
-      //logger.warn("EMANFIRE2:JOIN:"+endpoint.getLocation()+" mid:"+endpoint.getMemberId());
+
+    if (addedEndpoint) {
+      // logger.warn("EMANFIRE2:JOIN:"+endpoint.getLocation()+" mid:"+endpoint.getMemberId());
-      //logger.warn("EMANFIRE33:NOJOIN:"+endpoint.getLocation()+" mid:"+endpoint.getMemberId());
+      // logger.warn("EMANFIRE33:NOJOIN:"+endpoint.getLocation()+" mid:"+endpoint.getMemberId());
-    
+
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.client.internal.EndpointManager#serverCrashed(org.apache.geode.cache.client.internal.Endpoint)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.client.internal.EndpointManager#serverCrashed(org.apache.geode.cache.
+   * client.internal.Endpoint)
-  
+
-  
+
-    synchronized(this) {
-      Map<ServerLocation, Endpoint> endpointMapTemp = new HashMap<ServerLocation, Endpoint>(endpointMap);
+    synchronized (this) {
+      Map<ServerLocation, Endpoint> endpointMapTemp =
+          new HashMap<ServerLocation, Endpoint>(endpointMap);
-      if(endpoint != null) {
+      if (endpoint != null) {
-    if(removedEndpoint) {
-      PoolImpl pool = (PoolImpl)PoolManager.find(this.poolName);
+    if (removedEndpoint) {
+      PoolImpl pool = (PoolImpl) PoolManager.find(this.poolName);
-        for (ProxyCache proxyCache : proxyCaches) {
-          try {
-            Long userId = proxyCache.getUserAttributes().getServerToId().remove(
-                endpoint.getLocation());
-            if (userId != null) {
-              ++size;
+          for (ProxyCache proxyCache : proxyCaches) {
+            try {
+              Long userId =
+                  proxyCache.getUserAttributes().getServerToId().remove(endpoint.getLocation());
+              if (userId != null) {
+                ++size;
+              }
+            } catch (CacheClosedException cce) {
+              // If this call is triggered by a Cache.close(), then this can be
+              // expected.
-          } catch (CacheClosedException cce) {
-            // If this call is triggered by a Cache.close(), then this can be
-            // expected.
-        }
-        if (logger.isDebugEnabled()) {
-          logger.debug("EndpointManagerImpl.removeEndpoint() Removed server {} from {} user's ProxyCache", endpoint.getLocation(), size);
-        }
+          if (logger.isDebugEnabled()) {
+            logger.debug(
+                "EndpointManagerImpl.removeEndpoint() Removed server {} from {} user's ProxyCache",
+                endpoint.getLocation(), size);
+          }
-            logger.debug("EndpointManagerImpl.removeEndpoint() Removed server {} from thread local variable", endpoint.getLocation());
+            logger.debug(
+                "EndpointManagerImpl.removeEndpoint() Removed server {} from thread local variable",
+                endpoint.getLocation());
-      if(crashed) {
+      if (crashed) {
-      }
-      else {
+      } else {
-  
-  
-  /* (non-Javadoc)
+
+
+  /*
+   * (non-Javadoc)
+   * 
-  /* (non-Javadoc)
+  /*
+   * (non-Javadoc)
+   * 
-    for(Iterator<ConnectionStats> itr = statMap.values().iterator(); itr.hasNext(); ) {
+    for (Iterator<ConnectionStats> itr = statMap.values().iterator(); itr.hasNext();) {
-    
+
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.client.internal.EndpointManager#addListener(org.apache.geode.cache.client.internal.EndpointManagerImpl.EndpointListener)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.cache.client.internal.EndpointManager#addListener(org.apache.geode.cache.
+   * client.internal.EndpointManagerImpl.EndpointListener)
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.client.internal.EndpointManager#removeListener(org.apache.geode.cache.client.internal.EndpointManagerImpl.EndpointListener)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.client.internal.EndpointManager#removeListener(org.apache.geode.cache.
+   * client.internal.EndpointManagerImpl.EndpointListener)
-  
+
-    if(stats == null) {
+    if (stats == null) {
-      PoolImpl pool = (PoolImpl)PoolManager.find(this.poolName);
+      PoolImpl pool = (PoolImpl) PoolManager.find(this.poolName);
-              this.poolStats/*, this.gatewayStats*/);
+              this.poolStats/* , this.gatewayStats */);
-        stats = new ConnectionStats(ds, statName, this.poolStats/*,
-            this.gatewayStats*/);
+        stats = new ConnectionStats(ds, statName, this.poolStats/*
+                                                                 * , this.gatewayStats
+                                                                 */);
-    
+
-  
+
-  
+
-    //do nothing
+    // do nothing
-  
+
-  
-    private volatile Set/*<EndpointListener>*/<EndpointListener> endpointListeners = Collections.emptySet();
-    
+
+    private volatile Set/* <EndpointListener> */<EndpointListener> endpointListeners =
+        Collections.emptySet();
+
-      for(Iterator<EndpointListener> itr = endpointListeners.iterator(); itr.hasNext(); ) {
+      for (Iterator<EndpointListener> itr = endpointListeners.iterator(); itr.hasNext();) {
-      for(Iterator<EndpointListener> itr = endpointListeners.iterator(); itr.hasNext(); ) {
+      for (Iterator<EndpointListener> itr = endpointListeners.iterator(); itr.hasNext();) {
-      //logger.warn("HIGHUP:JOIN:"+endpoint.getLocation());
-      for(Iterator<EndpointListener> itr = endpointListeners.iterator(); itr.hasNext(); ) {
+      // logger.warn("HIGHUP:JOIN:"+endpoint.getLocation());
+      for (Iterator<EndpointListener> itr = endpointListeners.iterator(); itr.hasNext();) {
-  
-  
-  
+
+
+
-    
+
-      if(endpoint.getMemberId()==null || cancelCriterion.isCancelInProgress()) {
+      if (endpoint.getMemberId() == null || cancelCriterion.isCancelInProgress()) {
-      //logger.warn("EMANFIRE:CRASH:"+endpoint.getLocation());
+      // logger.warn("EMANFIRE:CRASH:"+endpoint.getLocation());
-      if(endpoint.getMemberId()==null || cancelCriterion.isCancelInProgress()) {
+      if (endpoint.getMemberId() == null || cancelCriterion.isCancelInProgress()) {
-      //logger.warn("EMANFIRE:LEFT:"+endpoint.getLocation());
+      // logger.warn("EMANFIRE:LEFT:"+endpoint.getLocation());
-      if(cancelCriterion.isCancelInProgress()) {
+      if (cancelCriterion.isCancelInProgress()) {
-      //logger.warn("EMANFIRE:JOIN:"+endpoint.getLocation()+" mid:"+endpoint.getMemberId(),new Exception());
+      // logger.warn("EMANFIRE:JOIN:"+endpoint.getLocation()+" mid:"+endpoint.getMemberId(),new
+      // Exception());
-  }  
-  
+  }
+


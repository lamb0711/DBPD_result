Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-          String onlyLogLevel = ((String) args[2]);          
-          int numOfLogFilesForTesting = ((Number)args[5]).intValue();          
+          String onlyLogLevel = ((String) args[2]);
+          int numOfLogFilesForTesting = ((Number) args[5]).intValue();
-          InternalDistributedSystem ds = (InternalDistributedSystem) cache
-              .getDistributedSystem();
+          InternalDistributedSystem ds = (InternalDistributedSystem) cache.getDistributedSystem();
-            final String filterStr = filterString.substring(0, filterString
-                .lastIndexOf(".") > 0 ? filterString.lastIndexOf(".")
-                : filterString.length() - 1);
-            
-            File dir = ds.getConfig().getLogFile();  // get log file object
-            if(dir==null) {
-              context.getResultSender().lastResult(CliStrings.format(
-                  CliStrings.EXPORT_LOGS__MSG__FAILED_TO_EXPORT_LOG_FILES_FOR_MEMBER_0, ds.getMemberId()));
+            final String filterStr = filterString.substring(0, filterString.lastIndexOf(".") > 0
+                ? filterString.lastIndexOf(".") : filterString.length() - 1);
+
+            File dir = ds.getConfig().getLogFile(); // get log file object
+            if (dir == null) {
+              context.getResultSender()
+                  .lastResult(CliStrings.format(
+                      CliStrings.EXPORT_LOGS__MSG__FAILED_TO_EXPORT_LOG_FILES_FOR_MEMBER_0,
+                      ds.getMemberId()));
-              dir = dir.getAbsoluteFile();   // get absolute log file
+              dir = dir.getAbsoluteFile(); // get absolute log file
-              return;              
+              return;
-            String logFileDir = dir.getParent();  // get log file directory
-            if(logFileDir==null) logFileDir="/";  // this works in Windows too
+            String logFileDir = dir.getParent(); // get log file directory
+            if (logFileDir == null)
+              logFileDir = "/"; // this works in Windows too
-              logger.debug("For member={}: Exporting logs LogFileFunction logFileDir={}, filterStr={}",
+              logger.debug(
+                  "For member={}: Exporting logs LogFileFunction logFileDir={}, filterStr={}",
-            
-            dir = new File(logFileDir);  // get log file directory object
+
+            dir = new File(logFileDir); // get log file directory object
-              logger.debug("For member={}: Exporting logs LogFileFunction targetDirName={}", ds.getMemberId(), targetDirName);
+              logger.debug("For member={}: Exporting logs LogFileFunction targetDirName={}",
+                  ds.getMemberId(), targetDirName);
-            File targetDir = new File(targetDirName);            
+            File targetDir = new File(targetDirName);
-                String logsWritten = processLogs(dir, logFileDir, targetDirName, cache, logLevel, onlyLogLevel, filter, ((Number) args[3]).toString(), ((Number) args[4]).toString(), numOfLogFilesForTesting);
+                String logsWritten = processLogs(dir, logFileDir, targetDirName, cache, logLevel,
+                    onlyLogLevel, filter, ((Number) args[3]).toString(),
+                    ((Number) args[4]).toString(), numOfLogFilesForTesting);
-                  logger.debug("For member={}: Done with Exporting logs LogFileFunction targetDirName={}", ds.getMemberId(), targetDirName);
+                  logger.debug(
+                      "For member={}: Done with Exporting logs LogFileFunction targetDirName={}",
+                      ds.getMemberId(), targetDirName);
-                context.getResultSender().lastResult(ResultBuilder.createInfoResult(CliStrings.format(CliStrings.EXPORT_LOGS__MSG__TARGET_DIR_CANNOT_BE_CREATED,targetDir)));
+                context.getResultSender().lastResult(ResultBuilder.createInfoResult(CliStrings
+                    .format(CliStrings.EXPORT_LOGS__MSG__TARGET_DIR_CANNOT_BE_CREATED, targetDir)));
-              String logsWritten = processLogs(dir, logFileDir, targetDirName,cache, logLevel, onlyLogLevel, filter, ((Number) args[3]).toString(), ((Number) args[4]).toString(), numOfLogFilesForTesting);
+              String logsWritten = processLogs(dir, logFileDir, targetDirName, cache, logLevel,
+                  onlyLogLevel, filter, ((Number) args[3]).toString(),
+                  ((Number) args[4]).toString(), numOfLogFilesForTesting);
-                logger.debug("For member={}: Done with Exporting logs LogFileFunction targetDirName={} logsWritten={}",
+                logger.debug(
+                    "For member={}: Done with Exporting logs LogFileFunction targetDirName={} logsWritten={}",
-            context.getResultSender().lastResult(LocalizedStrings.InternalDistributedSystem_THIS_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_HAS_BEEN_DISCONNECTED.toLocalizedString());
+            context.getResultSender().lastResult(
+                LocalizedStrings.InternalDistributedSystem_THIS_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_HAS_BEEN_DISCONNECTED
+                    .toLocalizedString());
-          context.getResultSender().lastResult(e.getMessage());          
+          context.getResultSender().lastResult(e.getMessage());
-            ((InternalDistributedSystem) CacheFactory.getAnyInstance().getDistributedSystem() ).getMemberId());
+            ((InternalDistributedSystem) CacheFactory.getAnyInstance().getDistributedSystem())
+                .getMemberId());
-            ((InternalDistributedSystem) CacheFactory.getAnyInstance().getDistributedSystem() ).getMemberId()); 
+            ((InternalDistributedSystem) CacheFactory.getAnyInstance().getDistributedSystem())
+                .getMemberId());
-  public String processLogs(File dir, String logFileDir, String targetDirName,
-      Cache cache, String logLevel, String onlyLogLevel, FilenameFilter filter, String startTime, String endTime, int numOfLogFilesForTesting) {
+  public String processLogs(File dir, String logFileDir, String targetDirName, Cache cache,
+      String logLevel, String onlyLogLevel, FilenameFilter filter, String startTime, String endTime,
+      int numOfLogFilesForTesting) {
-        logger.debug("LogFileFunction  processLogs logsInDir={} sample={}", logsInDir.length, logsInDir[0]);
+        logger.debug("LogFileFunction  processLogs logsInDir={} sample={}", logsInDir.length,
+            logsInDir[0]);
-        //numOfLogFilesForTesting is used to limit the files that get copied while running entire dunit suite
-        //from user perspective numOfLogFilesForTesting is of no use
+        // numOfLogFilesForTesting is used to limit the files that get copied while running entire
+        // dunit suite
+        // from user perspective numOfLogFilesForTesting is of no use
-          logger.debug("LogFileFunction  before copy  numOfLogFilesForTesting={}", numOfLogFilesForTesting);
+          logger.debug("LogFileFunction  before copy  numOfLogFilesForTesting={}",
+              numOfLogFilesForTesting);
-        
-        for (int i = 0, j= 0 ; i < logsInDir.length && (j < numOfLogFilesForTesting || numOfLogFilesForTesting == 0 ); i++,j++) {
-          String fileName = new String(logFileDir + File.separator
-              + logsInDir[i]);
-        String logToBeWritten = targetDirName
-            + File.separator
-            + MBeanJMXAdapter.getMemberNameOrId(cache
-                .getDistributedSystem().getDistributedMember())
-            + "_"
-            + logsInDir[i].substring(0, logsInDir[i].length() - 4)
-            + "_"
-            + sdf.format(new java.util.Date())
-            + logsInDir[i].substring(logsInDir[i].length() - 4, logsInDir[i]
-                .length());
+        for (int i = 0, j = 0; i < logsInDir.length
+            && (j < numOfLogFilesForTesting || numOfLogFilesForTesting == 0); i++, j++) {
+          String fileName = new String(logFileDir + File.separator + logsInDir[i]);
-        // create a new process for log read and write
-        if (isDebugEnabled) {
-          logger.debug("LogFileFunction  processLogs fileName={} logToBeWritten={}", fileName, logToBeWritten);
-        }
-        List<String> commandList = new ArrayList<String>();
-        commandList.add(System.getProperty("java.home") + File.separatorChar
-            + "bin" + File.separatorChar + "java");
-        commandList.add("-classpath");
-        commandList.add(System.getProperty("java.class.path", "."));
-        commandList.add(ReadWriteFile.class.getName());
-        commandList.add(fileName);
-        commandList.add(logToBeWritten);
-        commandList.add(logLevel);
-        commandList.add(onlyLogLevel);
-        commandList.add(startTime);
-        commandList.add(endTime);
-        ProcessBuilder procBuilder = new ProcessBuilder(commandList);
-        
-        StringBuilder output = new StringBuilder();
-        String errorString = new String(), resultString = new String();
-        try {
-          Process copyLogProcess = procBuilder.redirectErrorStream(true)
-              .start();
-          if (isDebugEnabled) {
-            logger.debug("LogFileFunction  processLogs fileName before process waitfor");
-          }
-          int compacterProcessStatus= copyLogProcess.waitFor();
-          if (isDebugEnabled) {
-            logger.debug("LogFileFunction  processLogs fileName after process waitfor destroy compacterProcessStatus={}", compacterProcessStatus);
-          }
-          InputStream inputStream = copyLogProcess.getInputStream();
-          BufferedReader br = new BufferedReader(new InputStreamReader(
-              inputStream));
-          String line = null;
+          String logToBeWritten = targetDirName + File.separator
+              + MBeanJMXAdapter
+                  .getMemberNameOrId(cache.getDistributedSystem().getDistributedMember())
+              + "_" + logsInDir[i].substring(0, logsInDir[i].length() - 4) + "_"
+              + sdf.format(new java.util.Date())
+              + logsInDir[i].substring(logsInDir[i].length() - 4, logsInDir[i].length());
-          while ((line = br.readLine()) != null) {
-            output.append(line).append(GfshParser.LINE_SEPARATOR);
-          }          
-          copyLogProcess.destroy();
+          // create a new process for log read and write
-            logger.debug("LogFileFunction  processLogs fileName after process waitfor after destroy compacterProcessStatus={}", compacterProcessStatus);
+            logger.debug("LogFileFunction  processLogs fileName={} logToBeWritten={}", fileName,
+                logToBeWritten);
-          
-        } catch (IOException e) {
-          errorString = (new GemFireIOException(
-              " Exception in LogFileFunction is " + e, e)).toString();
-        } finally {
-          if (errorString != null) {
-            output.append(errorString).append(GfshParser.LINE_SEPARATOR);
+          List<String> commandList = new ArrayList<String>();
+          commandList.add(System.getProperty("java.home") + File.separatorChar + "bin"
+              + File.separatorChar + "java");
+          commandList.add("-classpath");
+          commandList.add(System.getProperty("java.class.path", "."));
+          commandList.add(ReadWriteFile.class.getName());
+          commandList.add(fileName);
+          commandList.add(logToBeWritten);
+          commandList.add(logLevel);
+          commandList.add(onlyLogLevel);
+          commandList.add(startTime);
+          commandList.add(endTime);
+          ProcessBuilder procBuilder = new ProcessBuilder(commandList);
+
+          StringBuilder output = new StringBuilder();
+          String errorString = new String(), resultString = new String();
+          try {
+            Process copyLogProcess = procBuilder.redirectErrorStream(true).start();
+            if (isDebugEnabled) {
+              logger.debug("LogFileFunction  processLogs fileName before process waitfor");
+            }
+            int compacterProcessStatus = copyLogProcess.waitFor();
+            if (isDebugEnabled) {
+              logger.debug(
+                  "LogFileFunction  processLogs fileName after process waitfor destroy compacterProcessStatus={}",
+                  compacterProcessStatus);
+            }
+            InputStream inputStream = copyLogProcess.getInputStream();
+            BufferedReader br = new BufferedReader(new InputStreamReader(inputStream));
+            String line = null;
+
+            while ((line = br.readLine()) != null) {
+              output.append(line).append(GfshParser.LINE_SEPARATOR);
+            }
+            copyLogProcess.destroy();
+            if (isDebugEnabled) {
+              logger.debug(
+                  "LogFileFunction  processLogs fileName after process waitfor after destroy compacterProcessStatus={}",
+                  compacterProcessStatus);
+            }
+
+          } catch (IOException e) {
+            errorString =
+                (new GemFireIOException(" Exception in LogFileFunction is " + e, e)).toString();
+          } finally {
+            if (errorString != null) {
+              output.append(errorString).append(GfshParser.LINE_SEPARATOR);
+            }
+            resultString = output.toString();
-          resultString = output.toString();
-        }
-          }else{
+          } else {
-              logger.debug("LogFileFunction wrote file logToBeWritten={} resultString={}", logToBeWritten, resultString);
+              logger.debug("LogFileFunction wrote file logToBeWritten={} resultString={}",
+                  logToBeWritten, resultString);
-      }else{
+      } else {
-          logger.debug(CliStrings.format("No file was found for exporting in export logs function"));
+          logger
+              .debug(CliStrings.format("No file was found for exporting in export logs function"));
-        logger.debug(CliStrings.format("logsWritten="+logsWritten));
+        logger.debug(CliStrings.format("logsWritten=" + logsWritten));


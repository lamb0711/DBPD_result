Merge branch 'release/1.8.0'

-import org.apache.geode.UnmodifiableException;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-    StringWriter sw = new StringWriter();
-    PrintWriter pw = new PrintWriter(sw);
-    printSourceSection(ConfigSource.runtime(), pw);
-    printSourceSection(ConfigSource.sysprop(), pw);
-    printSourceSection(ConfigSource.api(), pw);
+    StringWriter stringWriter = new StringWriter();
+    PrintWriter printWriter = new PrintWriter(stringWriter);
+    printSourceSection(ConfigSource.runtime(), printWriter);
+    printSourceSection(ConfigSource.sysprop(), printWriter);
+    printSourceSection(ConfigSource.api(), printWriter);
-      printSourceSection(fileSource, pw);
+      printSourceSection(fileSource, printWriter);
-    printSourceSection(ConfigSource.xml(), pw);
-    printSourceSection(ConfigSource.launcher(), pw); // fix for bug 46653
-    printSourceSection(null, pw);
-    pw.close();
-    return sw.toString();
+    printSourceSection(ConfigSource.xml(), printWriter);
+    printSourceSection(ConfigSource.launcher(), printWriter); // fix for bug 46653
+    printSourceSection(null, printWriter);
+    printWriter.close();
+    return stringWriter.toString();
-  /***
+  /**
-    for (String attName : validAttributeNames) {
-      if ((source == null && sm.get(attName) != null)
-          || (source != null && !source.equals(sm.get(attName)))) {
+    for (String name : validAttributeNames) {
+      if (source == null && sm.get(name) != null
+          || source != null && !source.equals(sm.get(name))) {
-      configProps.put(attName, this.getAttribute(attName));
+      configProps.put(name, getAttribute(name));
-  /****
+  /**
-    for (String attName : attNames) {
-      result.setProperty(attName, getAttribute(attName));
+    for (String name : attNames) {
+      result.setProperty(name, getAttribute(name));
-  public void toFile(File f) throws IOException {
-    try (FileOutputStream out = new FileOutputStream(f)) {
+  public void toFile(File file) throws IOException {
+    try (FileOutputStream out = new FileOutputStream(file)) {
-    if (!this.getClass().equals(other.getClass())) {
+    if (!getClass().equals(other.getClass())) {
-    for (String attName : validAttributeNames) {
-      Object thisAtt = this.getAttributeObject(attName);
-      Object otherAtt = other.getAttributeObject(attName);
+    for (String name : validAttributeNames) {
+      Object thisAtt = getAttributeObject(name);
+      Object otherAtt = other.getAttributeObject(name);
-
-  public String getAttribute(String attName) {
-    Object result = getAttributeObject(attName);
+  public String getAttribute(String name) {
+    Object result = getAttributeObject(name);
-    if (attName.equalsIgnoreCase(MEMBERSHIP_PORT_RANGE)) {
+    if (name.equalsIgnoreCase(MEMBERSHIP_PORT_RANGE)) {
-    if (result.getClass().isArray() && attName.startsWith("ssl-")) {
+    if (result.getClass().isArray() && name.startsWith("ssl-")) {
-        addrName = addr.getHostAddress(); // on Windows getHostName on mcast addrs takes ~5 seconds
+        // on Windows getHostName on mcast addrs takes ~5 seconds
+        addrName = addr.getHostAddress();
-  public ConfigSource getAttributeSource(String attName) {
-    return getAttSourceMap().get(attName);
+  public ConfigSource getAttributeSource(String name) {
+    return getAttSourceMap().get(name);
-  public void setAttribute(String attName, String attValue, ConfigSource source) {
+  public void setAttribute(String name, String value, ConfigSource source) {
-    Class valueType = getAttributeType(attName);
+    Class valueType = getAttributeType(name);
-        attObjectValue = attValue;
+        attObjectValue = value;
-        attObjectValue = attValue.split(",");
+        attObjectValue = value.split(",");
-        attObjectValue = Integer.valueOf(attValue);
+        attObjectValue = Integer.valueOf(value);
-        attObjectValue = Long.valueOf(attValue);
+        attObjectValue = Long.valueOf(value);
-        attObjectValue = Boolean.valueOf(attValue);
+        attObjectValue = Boolean.valueOf(value);
-        attObjectValue = new File(attValue);
+        attObjectValue = new File(value);
-        int[] value = new int[2];
-        int minus = attValue.indexOf('-');
+        int minus = value.indexOf('-');
-              "expected a setting in the form X-Y but found no dash for attribute " + attName);
+              "expected a setting in the form X-Y but found no dash for attribute " + name);
-        value[0] = Integer.valueOf(attValue.substring(0, minus));
-        value[1] = Integer.valueOf(attValue.substring(minus + 1));
-        attObjectValue = value;
+        int[] tempValue = new int[2];
+        tempValue[0] = Integer.valueOf(value.substring(0, minus));
+        tempValue[1] = Integer.valueOf(value.substring(minus + 1));
+        attObjectValue = tempValue;
-          attObjectValue = InetAddress.getByName(attValue);
+          attObjectValue = InetAddress.getByName(value);
-              LocalizedStrings.AbstractConfig_0_VALUE_1_MUST_BE_A_VALID_HOST_NAME_2
-                  .toLocalizedString(attName, attValue, ex.toString()));
-        }
-      } else if (valueType.equals(String[].class)) {
-        if (attValue == null || attValue.length() == 0) {
-          attObjectValue = null;
-        } else {
-          String trimAttName = attName.substring(0, attName.length() - 1);
-          throw new UnmodifiableException(
-              LocalizedStrings.AbstractConfig_THE_0_CONFIGURATION_ATTRIBUTE_CAN_NOT_BE_SET_FROM_THE_COMMAND_LINE_SET_1_FOR_EACH_INDIVIDUAL_PARAMETER_INSTEAD
-                  .toLocalizedString(attName, trimAttName));
+              String.format("%s value %s must be a valid host name. %s",
+                  name, value, ex.toString()));
-        String values[] = attValue.split(",");
+        String[] values = value.split(",");
-              LocalizedStrings.AbstractConfig_0_VALUE_1_MUST_HAVE_THREE_ELEMENTS_SEPARATED_BY_COMMAS
-                  .toLocalizedString(attName, attValue));
+              String.format("%s value %s must have three elements separated by commas",
+                  name, value));
-              LocalizedStrings.AbstractConfig_0_VALUE_1_MUST_BE_COMPOSED_OF_AN_INTEGER_A_FLOAT_AND_AN_INTEGER
-                  .toLocalizedString(attName, attValue));
+              String.format("%s value %s must be composed of an integer, a float, and an integer",
+                  name, value));
-        attObjectValue = commaDelimitedStringToSecurableCommunicationChannels(attValue);
+        attObjectValue = commaDelimitedStringToSecurableCommunicationChannels(value);
-            LocalizedStrings.AbstractConfig_UNHANDLED_ATTRIBUTE_TYPE_0_FOR_1
-                .toLocalizedString(valueType, attName));
+            String.format("unhandled attribute type %s for %s.",
+                valueType, name));
-      throw new IllegalArgumentException(LocalizedStrings.AbstractConfig_0_VALUE_1_MUST_BE_A_NUMBER
-          .toLocalizedString(attName, attValue));
+      throw new IllegalArgumentException(String.format("%s value %s must be a number.",
+          name, value));
-    setAttributeObject(attName, attObjectValue, source);
+    setAttributeObject(name, attObjectValue, source);
-  public String getAttributeDescription(String attName) {
-    checkAttributeName(attName);
-    if (!getAttDescMap().containsKey(attName)) {
+  public String getAttributeDescription(String name) {
+    checkAttributeName(name);
+    if (!getAttDescMap().containsKey(name)) {
-          LocalizedStrings.AbstractConfig_UNHANDLED_ATTRIBUTE_NAME_0.toLocalizedString(attName));
+          String.format("unhandled attribute name %s.", name));
-    return (String) getAttDescMap().get(attName);
+    return (String) getAttDescMap().get(name);
-  protected String _getUnmodifiableMsg(String attName) {
-    return LocalizedStrings.AbstractConfig_THE_0_CONFIGURATION_ATTRIBUTE_CAN_NOT_BE_MODIFIED
-        .toLocalizedString(attName);
+  protected String _getUnmodifiableMsg(String name) {
+    return String.format("The %s configuration attribute can not be modified.",
+        name);
-  protected void checkAttributeName(String attName) {
+  protected void checkAttributeName(String name) {
-    if (!Arrays.asList(validAttNames).contains(attName.toLowerCase())) {
+    if (!Arrays.asList(validAttNames).contains(name.toLowerCase())) {
-          LocalizedStrings.AbstractConfig_UNKNOWN_CONFIGURATION_ATTRIBUTE_NAME_0_VALID_ATTRIBUTE_NAMES_ARE_1
-              .toLocalizedString(attName, SystemAdmin.join(validAttNames)));
+          String.format("Unknown configuration attribute name %s. Valid attribute names are: %s .",
+              name, SystemAdmin.join(validAttNames)));
-  private void printSourceSection(ConfigSource source, PrintWriter pw) {
+  private void printSourceSection(ConfigSource source, PrintWriter printWriter) {
-    for (String attName : validAttributeNames) {
+    for (String name : validAttributeNames) {
-        if (sourceMap.get(attName) != null) {
+        if (sourceMap.get(name) != null) {
-      } else if (!source.equals(sourceMap.get(attName))) {
+      } else if (!source.equals(sourceMap.get(name))) {
-          pw.println(GEM_FIRE_PROPERTIES_USING_DEFAULT_VALUES);
+          printWriter.println(GEM_FIRE_PROPERTIES_USING_DEFAULT_VALUES);
-          pw.println(GEM_FIRE_PROPERTIES_DEFINED_WITH_PREFIX + source.getDescription()
+          printWriter.println(GEM_FIRE_PROPERTIES_DEFINED_WITH_PREFIX + source.getDescription()
-      if (attName.equals(SECURITY_SHIRO_INIT)) {
+      if (name.equals(SECURITY_SHIRO_INIT)) {
-        attributeValueToPrint = getAttribute(attName);
+        attributeValueToPrint = getAttribute(name);
-            ArgumentRedactor.redactArgumentIfNecessary(attName, getAttribute(attName));
+            ArgumentRedactor.redactArgumentIfNecessary(name, getAttribute(name));
-      pw.print(attName);
-      pw.print('=');
-      pw.println(attributeValueToPrint);
+      printWriter.print(name);
+      printWriter.print('=');
+      printWriter.println(attributeValueToPrint);

INS44 MOV44 INS44 MOV44 MOV44 UPD42 UPD42 MOV43 INS42 UPD42 UPD42 MOV43 INS42 UPD42 UPD42 UPD42 MOV43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV43 UPD42 UPD42 UPD42 MOV25 UPD42 UPD42 MOV32 MOV32 UPD42 INS42 INS45 UPD42 UPD42 MOV43 UPD42 MOV43 MOV43 UPD42 UPD42 UPD42 MOV32 UPD42 UPD42 UPD42 UPD42 MOV8 UPD42 INS27 INS27 UPD42 UPD42 MOV43 UPD42 MOV21 MOV32 MOV43 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 MOV27 MOV27 MOV27 MOV38 UPD42 UPD42 UPD42 UPD42 MOV32 MOV43 UPD42 INS42 INS45 UPD42 UPD42 INS42 INS45 UPD42 MOV8 MOV32 UPD42 INS42 INS45 UPD42 UPD42 UPD42 MOV32 INS8 UPD42 UPD42 UPD42 UPD42 UPD42 UPD42 INS45 INS21 MOV32 MOV8 UPD42 UPD42 UPD42 UPD42 UPD42 INS7 MOV32 MOV8 MOV60 UPD42 UPD42 UPD42 INS42 INS32 INS21 MOV32 MOV8 INS42 INS42 INS42 INS7 UPD42 UPD42 INS42 INS42 UPD42 UPD42 UPD42 INS5 UPD42 UPD42 MOV43 INS85 UPD42 UPD42 MOV43 UPD42 MOV43 UPD42 UPD42 INS42 INS45 UPD42 UPD42 INS42 INS45 UPD42 UPD42 UPD42 INS42 INS45 UPD42 UPD42 MOV43 UPD42 INS42 INS45 UPD42 UPD42 DEL40 DEL26 DEL40 DEL26 DEL27 DEL36 DEL27 DEL36 DEL52 DEL52 DEL52 DEL42 DEL44 DEL42 DEL42 DEL42 DEL45 DEL32 DEL7 DEL21 DEL42 DEL40 DEL42 DEL42 DEL42 DEL43 DEL85 DEL5 DEL57 DEL32 DEL42 DEL33 DEL27 DEL42 DEL42 DEL32 DEL34 DEL27 DEL27 DEL42 DEL33 DEL7 DEL21 DEL8 DEL42 DEL42 DEL42 DEL34 DEL42 DEL42 DEL32 DEL34 DEL27 DEL32 DEL59 DEL60 DEL42 DEL43 DEL40 DEL42 DEL42 DEL42 DEL32 DEL14 DEL53 DEL8 DEL25 DEL8 DEL85 DEL40 DEL40 DEL40 DEL42 DEL42 DEL7 DEL21 DEL8 DEL25 DEL40 DEL40 DEL40 DEL42 DEL43 DEL42 DEL44 DEL40
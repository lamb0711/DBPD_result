Merge branch 'release/1.8.0'

-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
-  private LockObject searchAndLock(Object keys[]) {
+  LockObject searchAndLock(Object keys[]) {
-  public void waitUntilLocked(Object keys[]) {
+  public boolean waitUntilLocked(Object keys[]) {
-              this.partitionedRegion.checkReadiness();
+              partitionedRegion.checkReadiness();
-        break;
+        return true;
-  // 2) distribute op to bucket secondaries and bridge servers with synchrony on local entry
+  // 2) distribute op to bucket secondaries and cache servers with synchrony on local entry
-    beginLocalWrite(event);
+    boolean locked = lockKeysAndPrimary(event);
-      endLocalWrite(event);
+      if (locked) {
+        releaseLockForKeysAndPrimary(event);
+      }
-      logger.error(LocalizedMessage.create(
-          LocalizedStrings.GatewaySender_SEQUENCENUMBER_GENERATED_FOR_EVENT_IS_INVALID,
-          new Object[] {key, getId()}));
+      logger.error("ERROR! The sequence number {} generated for the bucket {} is incorrect.",
+          new Object[] {key, getId()});
-          logger.error(LocalizedMessage.create(
-              LocalizedStrings.GatewaySender_SEQUENCENUMBER_GENERATED_FOR_EVENT_IS_INVALID,
-              new Object[] {key, getId()}));
+          logger.error("ERROR! The sequence number {} generated for the bucket {} is incorrect.",
+              new Object[] {key, getId()});
-   * stays the primary bucket while the write is in progress. Any call to this method must be
-   * followed with a call to endLocalWrite().
+   * stays the primary bucket while the write is in progress. This method must be followed with
+   * a call to releaseLockForKeysAndPrimary() if keys and primary are locked.
-  private boolean beginLocalWrite(EntryEventImpl event) {
+  boolean lockKeysAndPrimary(EntryEventImpl event) {
-    Object keys[] = new Object[1];
-    keys[0] = event.getKey();
+    Object[] keys = getKeysToBeLocked(event);
-      doLockForPrimary(false);
-      return lockedForPrimary = true;
+      lockedForPrimary = doLockForPrimary(false);
+      // tryLock is false means doLockForPrimary won't return false.
+      // either the method returns true or fails with an exception
+      assert lockedForPrimary : "expected doLockForPrimary returns true";
+      return lockedForPrimary;
+  Object[] getKeysToBeLocked(EntryEventImpl event) {
+    Object keys[] = new Object[1];
+    keys[0] = event.getKey();
+    return keys;
+  }
+
-    Lock activeWriteLock = this.getBucketAdvisor().getActiveWriteLock();
-    Lock parentLock = this.getBucketAdvisor().getParentActiveWriteLock();
+    Lock primaryMoveReadLock = getBucketAdvisor().getPrimaryMoveReadLock();
+    Lock parentLock = getBucketAdvisor().getParentPrimaryMoveReadLock();
-            boolean locked = activeWriteLock.tryLock();
+            boolean locked = primaryMoveReadLock.tryLock();
-            activeWriteLock.lockInterruptibly();
+            primaryMoveReadLock.lockInterruptibly();
-            boolean locked = activeWriteLock.tryLock();
+            boolean locked = primaryMoveReadLock.tryLock();
-            activeWriteLock.lockInterruptibly();
+            primaryMoveReadLock.lockInterruptibly();
-    Lock activeWriteLock = this.getBucketAdvisor().getActiveWriteLock();
-    activeWriteLock.unlock();
-    Lock parentLock = this.getBucketAdvisor().getParentActiveWriteLock();
+    Lock primaryMoveReadLock = getBucketAdvisor().getPrimaryMoveReadLock();
+    primaryMoveReadLock.unlock();
+    Lock parentLock = getBucketAdvisor().getParentPrimaryMoveReadLock();
+   * And release/remove the lockObject on the key(s)
-  private void endLocalWrite(EntryEventImpl event) {
-    if (!needWriteLock(event)) {
-      return;
-    }
-
-
+  void releaseLockForKeysAndPrimary(EntryEventImpl event) {
-    Object keys[] = new Object[1];
-    keys[0] = event.getKey();
+    Object[] keys = getKeysToBeLocked(event);
-  // 2) distribute op to bucket secondaries and bridge servers with synchrony on local entry
+  // 2) distribute op to bucket secondaries and cache servers with synchrony on local entry
-    beginLocalWrite(event);
+    boolean locked = lockKeysAndPrimary(event);
-      endLocalWrite(event);
+      if (locked) {
+        releaseLockForKeysAndPrimary(event);
+      }
-        logger.fatal(
-            LocalizedMessage.create(LocalizedStrings.LocalRegion_EXCEPTION_IN_EXPIRATION_TASK), ex);
+        logger.fatal("Exception in expiration task", ex);
-  // 2) distribute op to bucket secondaries and bridge servers with synchrony on local entry
+  // 2) distribute op to bucket secondaries and cache servers with synchrony on local entry
-    beginLocalWrite(event);
+    boolean locked = lockKeysAndPrimary(event);
-      endLocalWrite(event);
+      if (locked) {
+        releaseLockForKeysAndPrimary(event);
+      }
-    beginLocalWrite(event);
+    boolean locked = lockKeysAndPrimary(event);
-      endLocalWrite(event);
+      if (locked) {
+        releaseLockForKeysAndPrimary(event);
+      }
+
+    arm.lockForCacheModification(internalRegion, event);
+    final boolean locked = internalRegion.lockWhenRegionIsInitializing();
-      arm.lockForCacheModification(internalRegion, event);
-      beginLocalWrite(event);
+      boolean keysAndPrimaryLocked = lockKeysAndPrimary(event);
-        endLocalWrite(event);
+        if (keysAndPrimaryLocked) {
+          releaseLockForKeysAndPrimary(event);
+        }
+      if (locked) {
+        internalRegion.unlockWhenRegionIsInitializing();
+      }
-        LocalizedStrings.BucketRegion_THIS_SHOULD_NEVER_BE_CALLED_ON_0
-            .toLocalizedString(getClass()));
+        String.format("This should never be called on %s",
+            getClass()));
-              LocalizedStrings.DistributionManager_CAUGHT_EXCEPTION_WHILE_SENDING_DELTA
-                  .toLocalizedString(),
+              "Caught exception while sending delta. ",
-    if (cache.getLoggerI18n().fineEnabled())
-      cache.getLoggerI18n()
+    if (cache.getLogger().fineEnabled())
+      cache.getLogger()

INS31 UPD39 UPD42 INS5 INS42 INS44 INS8 UPD42 INS60 INS60 INS43 INS85 INS43 INS42 MOV60 MOV21 INS41 INS60 INS60 INS60 INS60 MOV21 INS60 INS39 INS59 INS8 UPD66 UPD66 INS5 INS59 INS42 INS42 INS42 MOV43 MOV43 MOV43 MOV43 INS66 INS5 INS59 INS39 INS59 INS8 INS39 INS59 INS8 INS39 INS59 INS8 INS83 INS39 INS59 INS42 INS32 INS25 INS43 INS85 INS42 INS32 INS6 UPD42 UPD42 UPD42 MOV43 MOV85 INS42 INS32 INS42 INS32 INS25 INS42 INS32 INS25 INS42 INS32 INS25 INS42 INS32 INS60 INS25 UPD42 MOV42 MOV42 INS42 INS8 MOV32 INS42 INS42 INS42 INS7 INS42 INS45 INS42 UPD42 UPD42 UPD42 UPD42 INS42 MOV42 UPD42 MOV42 MOV42 INS42 INS8 UPD42 MOV42 MOV42 INS42 INS8 UPD42 MOV42 MOV42 INS42 INS8 INS42 INS42 INS39 INS59 INS8 INS42 INS8 UPD42 INS42 INS45 UPD42 INS41 MOV21 UPD42 UPD42 INS45 INS42 MOV32 MOV21 MOV21 MOV21 INS42 INS32 INS25 INS21 UPD42 INS9 UPD42 MOV42 MOV42 INS42 INS8 INS32 UPD42 UPD42 UPD42 UPD42 MOV21 INS42 INS42 MOV32 INS45 UPD42 UPD42 INS45 UPD42 INS45 UPD42 UPD42 UPD42 UPD42 INS42 DEL40 DEL26 DEL40 DEL26 DEL83 DEL52 DEL42 DEL22 DEL10 DEL32 DEL21 DEL8 DEL40 DEL42 DEL42 DEL32 DEL40 DEL42 DEL42 DEL32 DEL83 DEL42 DEL9 DEL7 DEL52 DEL52 DEL52 DEL52 DEL83 DEL42 DEL42 DEL32 DEL38 DEL41 DEL8 DEL25 DEL42 DEL43 DEL42 DEL85 DEL5 DEL34 DEL3 DEL59 DEL60 DEL42 DEL34 DEL2 DEL42 DEL32 DEL7 DEL21 DEL32 DEL21 DEL8 DEL42 DEL42 DEL40 DEL32 DEL32 DEL21 DEL8 DEL32 DEL21 DEL8 DEL32 DEL21 DEL8 DEL40 DEL40 DEL42 DEL32
Merge branch 'release/1.8.0'

+import java.util.Optional;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.atomic.AtomicBoolean;
-import org.apache.geode.internal.i18n.LocalizedStrings;
+  private Optional<ScheduledFuture> expirationTask;
+
-  private volatile boolean isCanceled = false;
-
-  private CacheRuntimeException canceledException;
-
-  /**
-   * This is declared as array so that it can be synchronized between two threads to validate the
-   * state.
-   */
-  private final boolean[] queryCompletedForMonitoring = new boolean[] {false};
+  private volatile CacheRuntimeException queryCancelledException;
+  static final ThreadLocal<AtomicBoolean> queryCanceled =
+      ThreadLocal.withInitial(AtomicBoolean::new);
+
+  public Optional<ScheduledFuture> getCancelationTask() {
+    return expirationTask;
+  }
+
+  public void setCancelationTask(final ScheduledFuture expirationTask) {
+    this.expirationTask = Optional.of(expirationTask);
+  }
+    this.expirationTask = Optional.empty();
-          LocalizedStrings.DefaultQuery_PARAMETERS_CANNOT_BE_NULL.toLocalizedString());
+          "'parameters' cannot be null");
-          DefaultQuery.testHook.doTestHook(1);
+          DefaultQuery.testHook.doTestHook(DefaultQuery.TestHook.SPOTS.BEFORE_QUERY_EXECUTION,
+              this);
-        queryMonitor.monitorQueryThread(Thread.currentThread(), this);
+        queryMonitor.monitorQueryThread(this);
-      // query execution canceled exception will be thrown from the QueryMonitor
-      // canceled exception should not be null at this point as it should be set
-      // when query is canceled.
-      if (this.canceledException != null) {
-        throw this.canceledException;
-      } else {
-        throw new QueryExecutionCanceledException(
-            "Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
-      }
+      return reinterpretQueryExecutionCanceledException();
-        queryMonitor.stopMonitoringQueryThread(Thread.currentThread(), this);
+        queryMonitor.stopMonitoringQueryThread(this);
+   * This method attempts to reintrepret a {@link QueryExecutionCanceledException} using the
+   * the value returned by {@link #getQueryCanceledException} (set by the {@link QueryMonitor}).
+   *
+   * @throws if {@link #getQueryCanceledException} doesn't return {@code null} then throw that
+   *         {@link CacheRuntimeException}, otherwise throw {@link QueryExecutionCanceledException}
+   */
+  private Object reinterpretQueryExecutionCanceledException() {
+    final CacheRuntimeException queryCanceledException = getQueryCanceledException();
+    if (queryCanceledException != null) {
+      throw queryCanceledException;
+    } else {
+      throw new QueryExecutionCanceledException(
+          "Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
+    }
+  }
+
+  /**
-      queryMonitor.monitorQueryThread(Thread.currentThread(), this);
+      queryMonitor.monitorQueryThread(this);
-        queryMonitor.stopMonitoringQueryThread(Thread.currentThread(), this);
+        queryMonitor.stopMonitoringQueryThread(this);
-        DefaultQuery.testHook.doTestHook(6, this);
+        DefaultQuery.testHook.doTestHook(TestHook.SPOTS.BEFORE_QUERY_DEPENDENCY_COMPUTATION, this);
-          testHook.doTestHook(1);
+          testHook.doTestHook(DefaultQuery.TestHook.SPOTS.BEFORE_QUERY_EXECUTION, this);
-        // query execution canceled exception will be thrown from the QueryMonitor
-        // canceled exception should not be null at this point as it should be set
-        // when query is canceled.
-        if (this.canceledException != null) {
-          throw this.canceledException;
-        } else {
-          throw new QueryExecutionCanceledException(
-              "Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
-        }
+        reinterpretQueryExecutionCanceledException();
+      queryCanceled.remove();
-            LocalizedStrings.DefaultQuery_REGION_NOT_FOUND_0.toLocalizedString(regionPath));
+            String.format("Region not found: %s", regionPath));
-            LocalizedStrings.DefaultQuery_A_QUERY_ON_A_PARTITIONED_REGION_0_MAY_NOT_REFERENCE_ANY_OTHER_REGION_1
-                .toLocalizedString(prs.get(0).getName(), prs.get(1).getName()));
+            String.format(
+                "A query on a Partitioned Region ( %s ) may not reference any other region if query is NOT executed within a Function",
+                prs.get(0).getName()));
-              LocalizedStrings.DefaultQuery_A_QUERY_ON_A_PARTITIONED_REGION_0_MAY_NOT_REFERENCE_ANY_OTHER_NON_COLOCATED_PARTITIONED_REGION_1
-                  .toLocalizedString(eachPR.getName(), other.getName()));
+              String.format(
+                  "A query on a Partitioned Region ( %s ) may not reference any other region except Co-located Partitioned Region. PR region %s is not collocated with other PR region in the query.",
+                  eachPR.getName(), other.getName()));
-            LocalizedStrings.DefaultQuery_QUERY_MUST_BE_A_SIMPLE_SELECT_WHEN_REFERENCING_A_PARTITIONED_REGION
-                .toLocalizedString());
+            "query must be a simple select when referencing a Partitioned Region");
-              LocalizedStrings.DefaultQuery_THE_WHERE_CLAUSE_CANNOT_REFER_TO_A_REGION_WHEN_QUERYING_ON_A_PARTITIONED_REGION
-                  .toLocalizedString());
+              "The WHERE clause cannot refer to a region when querying on a Partitioned Region");
-                LocalizedStrings.DefaultQuery_WHEN_QUERYING_A_PARTITIONEDREGION_THE_FIRST_FROM_CLAUSE_ITERATOR_MUST_NOT_CONTAIN_A_SUBQUERY
-                    .toLocalizedString());
+                "When querying a PartitionedRegion, the first FROM clause iterator must not contain a subquery");
-                LocalizedStrings.DefaultQuery_WHEN_QUERYING_A_PARTITIONED_REGION_THE_FROM_CLAUSE_ITERATORS_OTHER_THAN_THE_FIRST_ONE_MUST_NOT_REFERENCE_ANY_REGIONS
-                    .toLocalizedString());
+                "When querying a Partitioned Region, the FROM clause iterators other than the first one must not reference any regions");
-                  LocalizedStrings.DefaultQuery_WHEN_QUERYING_A_PARTITIONED_REGION_THE_PROJECTIONS_MUST_NOT_REFERENCE_ANY_REGIONS
-                      .toLocalizedString());
+                  "When querying a Partitioned Region, the projections must not reference any regions");
-                  LocalizedStrings.DefaultQuery_WHEN_QUERYING_A_PARTITIONED_REGION_THE_ORDERBY_ATTRIBUTES_MUST_NOT_REFERENCE_ANY_REGIONS
-                      .toLocalizedString());
+                  "When querying a Partitioned Region, the order-by attributes must not reference any regions");
-        LocalizedStrings.DefaultQuery_NOT_YET_IMPLEMENTED.toLocalizedString());
+        "not yet implemented");
-    return this.isCanceled;
+    return getQueryCanceledException() != null;
-    return this.canceledException;
-  }
-
-  boolean[] getQueryCompletedForMonitoring() {
-    return this.queryCompletedForMonitoring;
-  }
-
-  // TODO: parameter value is always true
-  void setQueryCompletedForMonitoring(boolean value) {
-    this.queryCompletedForMonitoring[0] = value;
+    return queryCancelledException;
-  public void setCanceled(CacheRuntimeException canceledException) {
-    this.isCanceled = true;
-    this.canceledException = canceledException;
+  public void setQueryCanceledException(final CacheRuntimeException queryCanceledException) {
+    this.queryCancelledException = queryCanceledException;
-    sb.append(this.isCanceled);
+    sb.append(this.isCanceled());
-          LocalizedStrings.DefaultQuery_FUNCTIONCONTEXT_CANNOT_BE_NULL.toLocalizedString());
+          "'Function Context' cannot be null");
-          LocalizedStrings.DefaultQuery_PARAMETERS_CANNOT_BE_NULL.toLocalizedString());
+          "'parameters' cannot be null");
-            LocalizedStrings.DefaultQuery_API_ONLY_FOR_PR.toLocalizedString());
+            "This query API can only be used for Partition Region Queries.");
+  /**
+   * Test logic sets DefaultQuery.testHook to an implementation of this interface,
+   * to facilitate white-box testing.
+   *
+   * DefaultQuery and other classes in query* packages invoke doTestHook() at various points
+   * during query processing--identifying the location with a SPOT value.
+   */
+  @FunctionalInterface
-    default void doTestHook(int spot) {};
+    enum SPOTS {
-    default void doTestHook(int spot, DefaultQuery query) {
-      doTestHook(spot);
+      /*
+       * These spots pass a DefaultQuery
+       */
+      BEFORE_QUERY_EXECUTION, /* was 1 */
+      BEFORE_QUERY_DEPENDENCY_COMPUTATION, /* was 6 */
+
+      /*
+       * These spots do not pass a DefaultQuery
+       */
+      LOW_MEMORY_WHEN_DESERIALIZING_STREAMINGOPERATION, /* was 2 */
+      BEFORE_ADD_OR_UPDATE_MAPPING_OR_DESERIALIZING_NTH_STREAMINGOPERATION, /* was 3 */
+      BEFORE_BUILD_CUMULATIVE_RESULT, /* was 4 */
+      BEFORE_THROW_QUERY_CANCELED_EXCEPTION, /* was 5 */
+      BEGIN_TRANSITION_FROM_REGION_ENTRY_TO_ELEMARRAY,
+      TRANSITIONED_FROM_REGION_ENTRY_TO_ELEMARRAY,
+      COMPLETE_TRANSITION_FROM_REGION_ENTRY_TO_ELEMARRAY,
+      BEGIN_TRANSITION_FROM_ELEMARRAY_TO_CONCURRENT_HASH_SET,
+      TRANSITIONED_FROM_ELEMARRAY_TO_TOKEN,
+      COMPLETE_TRANSITION_FROM_ELEMARRAY_TO_CONCURRENT_HASH_SET,
+      ATTEMPT_REMOVE,
+      ATTEMPT_RETRY,
+      BEGIN_REMOVE_FROM_ELEM_ARRAY,
+      REMOVE_CALLED_FROM_ELEM_ARRAY,
+      COMPLETE_REMOVE_FROM_ELEM_ARRAY,
+      PULL_OFF_PR_QUERY_TRACE_INFO,
+      CREATE_PR_QUERY_TRACE_STRING,
+      CREATE_PR_QUERY_TRACE_INFO_FROM_LOCAL_NODE,
+      CREATE_PR_QUERY_TRACE_INFO_FOR_REMOTE_QUERY,
+      POPULATING_TRACE_INFO_FOR_REMOTE_QUERY
-    default void doTestHook(String spot) {};
+    /**
+     * Called (for side-effects) at various points in query processing, to facilitate
+     * white-box testing.
+     *
+     * @param spot identifies the (logical) calling code location. Some SPOT values represent
+     *        more than one physical location in the query processing code.
+     * @param query nullable, DefaultQuery, for SPOTS in the DefaultQuery class
+     */
+    void doTestHook(SPOTS spot, DefaultQuery query);
+

MOV26 INS26 INS26 MOV23 MOV23 MOV31 MOV31 MOV31 UPD40 INS40 INS40 INS31 INS74 INS83 INS43 UPD83 INS74 INS74 INS42 INS8 UPD39 UPD42 INS44 INS29 UPD83 INS43 INS42 INS8 MOV78 INS83 INS39 INS42 MOV8 MOV29 INS83 INS39 UPD42 INS83 MOV43 UPD42 UPD42 MOV25 MOV21 INS29 INS78 INS71 INS31 INS43 INS43 UPD42 INS42 UPD42 INS43 INS43 UPD42 INS32 INS43 INS43 INS41 INS83 INS43 INS42 INS21 INS21 INS65 INS65 INS42 INS60 INS25 MOV25 INS41 INS83 UPD42 INS65 INS42 INS42 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS72 INS29 MOV39 MOV42 MOV44 MOV44 INS42 INS42 INS42 INS42 INS42 INS42 INS89 INS42 UPD42 MOV42 INS42 INS42 INS7 INS7 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS66 INS65 INS66 INS65 INS66 INS65 INS66 INS65 INS83 MOV43 INS59 INS27 INS8 MOV8 INS27 INS42 MOV27 MOV27 INS66 INS66 INS66 INS66 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS65 INS65 INS65 UPD43 INS43 INS22 INS32 INS22 INS32 INS8 INS42 INS67 INS42 INS67 INS66 INS42 INS42 INS42 INS32 INS42 INS33 INS53 MOV25 INS21 INS45 INS32 INS33 UPD42 INS32 INS66 INS66 INS42 INS66 INS66 INS42 INS66 UPD42 INS42 MOV52 UPD42 MOV42 INS42 INS42 INS42 INS52 INS42 INS42 INS42 INS41 INS42 INS42 INS42 INS42 INS32 MOV25 INS42 UPD42 INS52 INS42 INS45 INS32 UPD42 INS8 INS42 INS42 MOV27 INS45 INS45 INS42 INS21 INS25 UPD42 INS40 INS32 MOV38 MOV8 INS45 INS42 UPD42 INS42 INS45 INS45 INS40 INS52 INS40 INS52 UPD42 UPD42 MOV42 INS45 INS38 INS45 INS32 UPD42 INS42 INS45 INS8 INS42 INS42 MOV38 MOV38 INS53 INS45 INS14 INS43 INS45 INS45 MOV43 INS45 INS42 MOV42 DEL83 DEL39 DEL9 DEL66 DEL66 DEL65 DEL29 DEL39 DEL85 DEL5 DEL39 DEL85 DEL5 DEL9 DEL4 DEL3 DEL39 DEL42 DEL40 DEL42 DEL32 DEL14 DEL53 DEL8 DEL22 DEL41 DEL40 DEL42 DEL32 DEL34 DEL42 DEL42 DEL32 DEL52 DEL42 DEL22 DEL33 DEL27 DEL52 DEL42 DEL22 DEL53 DEL8 DEL25 DEL8 DEL42 DEL42 DEL32 DEL42 DEL52 DEL42 DEL22 DEL41 DEL8 DEL42 DEL42 DEL32 DEL42 DEL42 DEL32 DEL34 DEL34 DEL52 DEL42 DEL22 DEL33 DEL27 DEL52 DEL42 DEL22 DEL53 DEL8 DEL42 DEL43 DEL45 DEL14 DEL53 DEL8 DEL25 DEL8 DEL40 DEL40 DEL42 DEL34 DEL32 DEL42 DEL32 DEL40 DEL40 DEL42 DEL32 DEL25 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL39 DEL85 DEL5 DEL52 DEL42 DEL22 DEL39 DEL39 DEL42 DEL44 DEL52 DEL42 DEL22 DEL34 DEL2 DEL42 DEL7 DEL21 DEL52 DEL42 DEL22 DEL9 DEL7 DEL21 DEL52 DEL42 DEL22 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL40 DEL42 DEL32 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL8 DEL31 DEL83 DEL39 DEL42 DEL39 DEL42 DEL44 DEL42 DEL42 DEL32 DEL21 DEL8 DEL31 DEL83 DEL8 DEL31
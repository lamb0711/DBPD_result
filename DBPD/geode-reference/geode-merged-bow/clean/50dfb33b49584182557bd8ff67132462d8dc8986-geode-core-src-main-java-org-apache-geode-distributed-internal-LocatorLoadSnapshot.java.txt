GEODE-6588: Cleanup generics and other static analyzer issues. (#3391)


+
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.Iterator;
-  public static final String LOAD_IMBALANCE_THRESHOLD_PROPERTY_NAME =
+  private static final String LOAD_IMBALANCE_THRESHOLD_PROPERTY_NAME =
-  private final Map/* <ServerLocation, String[]> */ serverGroupMap = new HashMap();
+  private final Map<ServerLocation, String[]> serverGroupMap = new HashMap<>();
-  private final Map/* <String(server group), Map<ServerLocation, LoadHolder> */
-  connectionLoadMap = new HashMap();
+  private final Map<String, Map<ServerLocation, LoadHolder>> connectionLoadMap = new HashMap<>();
-  private final Map/* <String(server group), Map<ServerLocation, LoadHolder> */
-  queueLoadMap = new HashMap();
+  private final Map<String, Map<ServerLocation, LoadHolder>> queueLoadMap = new HashMap<>();
-  private final ConcurrentMap/* <EstimateMapKey, LoadEstimateTask> */
-  estimateMap = new ConcurrentHashMap();
+  private final ConcurrentMap<EstimateMapKey, LoadEstimateTask> estimateMap =
+      new ConcurrentHashMap<>();
-    connectionLoadMap.put(null, new HashMap());
-    queueLoadMap.put(null, new HashMap());
+    connectionLoadMap.put(null, new HashMap<>());
+    queueLoadMap.put(null, new HashMap<>());
-    String[] groups = (String[]) serverGroupMap.remove(location);
+    String[] groups = serverGroupMap.remove(location);
-  public synchronized void updateLoad(ServerLocation location, ServerLoad newLoad,
-      List/* <ClientProxyMembershipID> */ clientIds) {
-    String[] groups = (String[]) serverGroupMap.get(location);
+  synchronized void updateLoad(ServerLocation location, ServerLoad newLoad,
+      List<ClientProxyMembershipID> clientIds) {
+    String[] groups = serverGroupMap.get(location);
-      for (Iterator itr = clientIds.iterator(); itr.hasNext();) {
-        cancelClientEstimate((ClientProxyMembershipID) itr.next(), location);
+      for (ClientProxyMembershipID clientId : clientIds) {
+        cancelClientEstimate(clientId, location);
-    Map groupServers = (Map) connectionLoadMap.get(group);
+    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
-  synchronized boolean thresholdCheck(float bestLoad, float worstLoad,
+  private synchronized boolean thresholdCheck(float bestLoad, float worstLoad,
-  public synchronized ServerLocation getServerForConnection(String group, Set excludedServers) {
+  public synchronized ServerLocation getServerForConnection(String group,
+      Set<ServerLocation> excludedServers) {
-    Map groupServers = (Map) connectionLoadMap.get(group);
+    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
-      if (bestLHs == null || bestLHs.isEmpty()) {
+      if (bestLHs.isEmpty()) {
-  /**
-   * Get the least loaded servers for the given groups as a map. If the given array of groups is
-   * null then returns the least loaded servers for all the known groups.
-   */
-  @SuppressWarnings("unchecked")
-  public synchronized Map<String, ServerLocation> getServersForConnection(Collection<String> groups,
-      Set excludedServers) {
-    final HashMap<String, ServerLocation> loadMap = new HashMap<String, ServerLocation>();
-    if (groups == null) {
-      groups = this.connectionLoadMap.keySet();
-    }
-    for (String group : groups) {
-      loadMap.put(group, getServerForConnection(group, excludedServers));
-    }
-    return loadMap;
-  }
-
-    Map groupServers = (Map) connectionLoadMap.get(group);
+    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
-    ArrayList servers = new ArrayList();
-    servers.addAll(groupServers.keySet());
-    return servers;
+
+    return new ArrayList<>(groupServers.keySet());
-    this.estimateTimeoutProcessor.shutdown();
+    estimateTimeoutProcessor.shutdown();
-      String group, Set excludedServers) {
+      String group, Set<ServerLocation> excludedServers) {
-    Map<ServerLocation, LoadHolder> groupServers = (Map) connectionLoadMap.get(group);
+    Map<ServerLocation, LoadHolder> groupServers = connectionLoadMap.get(group);
-      List bestLHs = findBestServers(groupServers, excludedServers, 1);
-      if (bestLHs == null || bestLHs.isEmpty()) {
+      List<LoadHolder> bestLHs = findBestServers(groupServers, excludedServers, 1);
+      if (bestLHs.isEmpty()) {
-      LoadHolder bestLH = (LoadHolder) bestLHs.get(0);
+      LoadHolder bestLH = bestLHs.get(0);
-  public List getServersForQueue(String group, Set excludedServers, int count) {
-    return getServersForQueue(null/* no id */, group, excludedServers, count);
+  public List getServersForQueue(String group, Set<ServerLocation> excludedServers, int count) {
+    return getServersForQueue(null, group, excludedServers, count);
-  public synchronized List getServersForQueue(ClientProxyMembershipID id, String group,
-      Set excludedServers, int count) {
+  synchronized List<ServerLocation> getServersForQueue(ClientProxyMembershipID id, String group,
+      Set<ServerLocation> excludedServers, int count) {
-    Map groupServers = (Map) queueLoadMap.get(group);
+    Map<ServerLocation, LoadHolder> groupServers = queueLoadMap.get(group);
-      return Collections.EMPTY_LIST;
+      return Collections.emptyList();
-      List/* <LoadHolder> */ bestLHs = findBestServers(groupServers, excludedServers, count);
-      ArrayList/* <ServerLocation> */ result = new ArrayList(bestLHs.size());
+      List<LoadHolder> bestLHs = findBestServers(groupServers, excludedServers, count);
+      ArrayList<ServerLocation> result = new ArrayList<>(bestLHs.size());
-        for (Iterator itr = bestLHs.iterator(); itr.hasNext();) {
-          LoadHolder load = (LoadHolder) itr.next();
+        for (LoadHolder load : bestLHs) {
-            task.setFuture(
-                this.estimateTimeoutProcessor.schedule(task, timeout, TimeUnit.MILLISECONDS));
+            task.setFuture(estimateTimeoutProcessor.schedule(task, timeout, TimeUnit.MILLISECONDS));
-        for (Iterator itr = bestLHs.iterator(); itr.hasNext();) {
-          LoadHolder load = (LoadHolder) itr.next();
+        for (LoadHolder load : bestLHs) {
-    Map connectionMap = (Map) connectionLoadMap.get(null);
-    Map queueMap = (Map) queueLoadMap.get(null);
-    Map result = new HashMap();
+    Map<ServerLocation, LoadHolder> connectionMap = connectionLoadMap.get(null);
+    Map<ServerLocation, LoadHolder> queueMap = queueLoadMap.get(null);
+    Map<ServerLocation, ServerLoad> result = new HashMap<>();
-    for (Iterator itr = connectionMap.entrySet().iterator(); itr.hasNext();) {
-      Map.Entry next = (Entry) itr.next();
-      ServerLocation location = (ServerLocation) next.getKey();
-      LoadHolder connectionLoad = (LoadHolder) next.getValue();
-      LoadHolder queueLoad = (LoadHolder) queueMap.get(location);
+    for (Entry<ServerLocation, LoadHolder> entry : connectionMap
+        .entrySet()) {
+      ServerLocation location = entry.getKey();
+      LoadHolder connectionLoad = entry.getValue();
+      LoadHolder queueLoad = queueMap.get(location);
-  private void addGroups(Map map, String[] groups, LoadHolder holder) {
-    for (int i = 0; i < groups.length; i++) {
-      Map groupMap = (Map) map.get(groups[i]);
-      if (groupMap == null) {
-        groupMap = new HashMap();
-        map.put(groups[i], groupMap);
-      }
+  private void addGroups(Map<String, Map<ServerLocation, LoadHolder>> map, String[] groups,
+      LoadHolder holder) {
+    for (String group : groups) {
+      Map<ServerLocation, LoadHolder> groupMap = map.computeIfAbsent(group, k -> new HashMap<>());
-    // Special case for GatewayReceiver where we don't put those serverlocation against
-    // holder
+    // Special case for GatewayReceiver where we don't put those serverlocation against holder
-      Map groupMap = (Map) map.get(null);
-      if (groupMap == null) {
-        groupMap = new HashMap();
-        map.put(null, groupMap);
-      }
+      Map<ServerLocation, LoadHolder> groupMap = map.computeIfAbsent(null, k -> new HashMap<>());
-  private void removeFromMap(Map map, String[] groups, ServerLocation location) {
-    for (int i = 0; i < groups.length; i++) {
-      Map groupMap = (Map) map.get(groups[i]);
+  private void removeFromMap(Map<String, Map<ServerLocation, LoadHolder>> map, String[] groups,
+      ServerLocation location) {
+    for (String group : groups) {
+      Map<ServerLocation, LoadHolder> groupMap = map.get(group);
-          map.remove(groupMap);
+          map.remove(group);
-    Map groupMap = (Map) map.get(null);
+    Map groupMap = map.get(null);
-  private List /* <LoadHolder> */ findBestServers(Map<ServerLocation, LoadHolder> groupServers,
-      Set excludedServers, int count) {
+  private List<LoadHolder> findBestServers(Map<ServerLocation, LoadHolder> groupServers,
+      Set<ServerLocation> excludedServers, int count) {
-    TreeSet bestEntries = new TreeSet(new Comparator() {
-      @Override
-      public int compare(Object o1, Object o2) {
-        LoadHolder l1 = (LoadHolder) o1;
-        LoadHolder l2 = (LoadHolder) o2;
-        int difference = Float.compare(l1.getLoad(), l2.getLoad());
-        if (difference != 0) {
-          return difference;
-        }
-        ServerLocation sl1 = l1.getLocation();
-        ServerLocation sl2 = l2.getLocation();
-        return sl1.compareTo(sl2);
+    TreeSet<LoadHolder> bestEntries = new TreeSet<>((l1, l2) -> {
+      int difference = Float.compare(l1.getLoad(), l2.getLoad());
+      if (difference != 0) {
+        return difference;
+      ServerLocation sl1 = l1.getLocation();
+      ServerLocation sl2 = l2.getLocation();
+      return sl1.compareTo(sl2);
-        LoadHolder lastBestHolder = (LoadHolder) bestEntries.last();
+        LoadHolder lastBestHolder = bestEntries.last();
-    return new ArrayList(bestEntries);
+    return new ArrayList<>(bestEntries);
-    LoadEstimateTask oldTask = null;
-    oldTask = (LoadEstimateTask) this.estimateMap.put(key, task);
+    LoadEstimateTask oldTask;
+    oldTask = estimateMap.put(key, task);
-  protected boolean removeIfPresentEstimate(EstimateMapKey key, LoadEstimateTask task) {
+  private boolean removeIfPresentEstimate(EstimateMapKey key, LoadEstimateTask task) {
-    LoadEstimateTask oldTask = null;
-    oldTask = (LoadEstimateTask) this.estimateMap.remove(key);
+    LoadEstimateTask oldTask;
+    oldTask = estimateMap.remove(key);
-    public EstimateMapKey(ClientProxyMembershipID.Identity clientId, ServerLocation serverId) {
+    EstimateMapKey(ClientProxyMembershipID.Identity clientId, ServerLocation serverId) {
-      return this.clientId.hashCode() ^ this.serverId.hashCode();
+      return clientId.hashCode() ^ serverId.hashCode();
-      if ((obj == null) || !(obj instanceof EstimateMapKey)) {
+      if (!(obj instanceof EstimateMapKey)) {
-      return this.clientId.equals(that.clientId) && this.serverId.equals(that.serverId);
+      return clientId.equals(that.clientId) && serverId.equals(that.serverId);
-    public LoadEstimateTask(EstimateMapKey key, LoadHolder lh) {
+    LoadEstimateTask(EstimateMapKey key, LoadHolder lh) {
-      if (removeIfPresentEstimate(this.key, this)) {
+      if (removeIfPresentEstimate(key, this)) {
-      this.future.cancel(false);
+      future.cancel(false);
-        this.lh.removeEstimate();
+        lh.removeEstimate();
-    public LoadHolder(ServerLocation location, float load, float loadPerConnection,
+    LoadHolder(ServerLocation location, float load, float loadPerConnection,
-    public void setLoad(float load, float loadPerConnection) {
+    void setLoad(float load, float loadPerConnection) {
-      this.load = load + (this.estimateCount * loadPerConnection);
+      this.load = load + (estimateCount * loadPerConnection);
-    public void incConnections() {
-      this.load += loadPerConnection;
+    void incConnections() {
+      load += loadPerConnection;
-    public void addEstimate() {
-      this.estimateCount++;
+    void addEstimate() {
+      estimateCount++;
-    public void removeEstimate() {
-      this.estimateCount--;
+    void removeEstimate() {
+      estimateCount--;
-    public void decConnections() {
-      this.load -= loadPerConnection;
+    void decConnections() {
+      load -= loadPerConnection;
-      return this.loadPollInterval;
+      return loadPollInterval;
-          + ((this.estimateCount != 0) ? (", estimates=" + this.estimateCount) : "") + ", "
+          + ((estimateCount != 0) ? (", estimates=" + estimateCount) : "") + ", "

INS23 UPD83 INS74 INS74 MOV59 MOV83 MOV83 INS74 INS59 INS74 MOV21 INS83 INS74 INS44 INS8 INS74 UPD83 MOV43 INS43 MOV5 MOV43 MOV43 INS74 UPD42 MOV43 MOV43 INS74 UPD42 MOV42 MOV14 MOV43 INS43 MOV43 INS74 INS74 INS60 INS74 MOV60 INS74 MOV43 INS43 INS74 INS60 INS70 INS74 INS42 INS70 MOV25 INS74 INS70 MOV60 MOV43 MOV43 INS74 MOV25 MOV25 UPD42 MOV42 INS74 INS43 INS43 INS43 INS74 INS43 MOV43 UPD43 MOV43 INS74 INS42 INS74 MOV5 MOV43 INS43 MOV5 INS74 MOV43 INS43 INS74 INS74 INS59 INS14 MOV43 MOV43 MOV74 MOV43 MOV43 INS42 MOV43 INS43 INS74 INS74 INS74 INS74 INS59 INS44 MOV32 MOV8 MOV43 MOV43 INS74 MOV44 INS42 INS8 MOV43 MOV43 INS74 INS44 INS42 MOV8 MOV43 INS43 INS74 MOV43 MOV43 MOV43 MOV42 INS42 INS42 MOV43 MOV42 UPD42 MOV43 MOV43 UPD42 UPD42 MOV14 MOV32 INS42 MOV32 INS70 INS43 INS43 INS43 MOV32 INS42 INS43 INS43 INS43 MOV32 MOV32 INS43 INS43 INS43 INS42 MOV32 INS74 MOV32 INS42 MOV32 INS74 MOV32 MOV43 UPD42 MOV42 INS43 INS43 INS43 MOV32 INS74 INS74 INS43 INS43 INS43 MOV32 INS43 INS43 INS43 MOV32 INS43 INS43 INS43 UPD42 MOV42 INS14 INS74 INS42 INS43 INS43 INS43 INS60 MOV21 INS60 MOV21 INS43 INS43 INS43 INS43 INS42 MOV32 INS42 MOV43 MOV43 MOV14 INS74 INS32 INS32 MOV38 INS42 INS74 INS74 INS44 INS42 INS8 INS42 INS42 INS42 INS42 INS42 INS42 INS42 INS42 UPD42 MOV42 MOV43 MOV42 INS43 MOV43 MOV32 MOV42 INS42 INS42 INS32 MOV43 MOV43 MOV43 INS43 INS70 INS70 MOV42 INS42 INS42 MOV42 INS42 INS42 INS42 UPD42 MOV42 INS42 INS74 MOV43 MOV43 MOV43 MOV43 MOV43 MOV42 INS42 UPD42 MOV42 INS74 INS59 INS74 INS59 MOV42 INS42 INS42 UPD42 MOV42 INS74 INS59 INS74 INS86 MOV43 INS42 MOV42 MOV42 MOV42 INS42 MOV42 MOV42 INS42 INS42 INS42 INS42 INS42 INS42 MOV43 MOV43 MOV43 INS42 MOV21 MOV42 INS42 INS42 INS42 INS74 INS44 INS42 MOV8 INS44 INS42 MOV8 MOV43 INS32 INS32 MOV32 INS43 INS43 INS43 INS42 INS32 INS43 INS43 INS43 INS42 INS32 INS43 INS43 INS43 INS42 INS32 MOV43 INS59 INS59 MOV8 INS42 INS42 INS42 INS42 MOV43 MOV43 INS42 MOV43 INS42 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV42 INS42 INS42 INS42 MOV42 UPD42 MOV42 INS42 INS86 INS42 INS42 UPD42 MOV42 MOV42 UPD42 MOV42 MOV33 INS86 MOV42 INS42 UPD42 MOV42 MOV42 MOV42 INS42 INS42 INS42 MOV43 INS42 UPD42 MOV42 INS59 MOV14 INS59 MOV14 MOV32 INS42 INS42 INS74 INS42 INS74 INS42 INS42 MOV43 MOV43 UPD42 INS42 DEL40 DEL26 DEL40 DEL26 DEL40 DEL26 DEL43 DEL43 DEL42 DEL59 DEL43 DEL23 DEL11 DEL83 DEL42 DEL43 DEL85 DEL5 DEL11 DEL42 DEL32 DEL11 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL8 DEL24 DEL11 DEL42 DEL43 DEL11 DEL42 DEL33 DEL27 DEL27 DEL66 DEL66 DEL65 DEL29 DEL42 DEL45 DEL79 DEL83 DEL83 DEL42 DEL43 DEL74 DEL42 DEL74 DEL42 DEL44 DEL42 DEL44 DEL83 DEL42 DEL43 DEL74 DEL42 DEL43 DEL74 DEL14 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL52 DEL42 DEL22 DEL42 DEL32 DEL7 DEL21 DEL8 DEL25 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL8 DEL70 DEL42 DEL41 DEL8 DEL31 DEL42 DEL43 DEL14 DEL59 DEL60 DEL32 DEL21 DEL42 DEL52 DEL42 DEL22 DEL43 DEL42 DEL43 DEL11 DEL42 DEL42 DEL43 DEL11 DEL59 DEL60 DEL43 DEL42 DEL33 DEL27 DEL27 DEL11 DEL83 DEL43 DEL43 DEL42 DEL43 DEL11 DEL40 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL52 DEL42 DEL22 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL43 DEL42 DEL43 DEL11 DEL43 DEL42 DEL43 DEL11 DEL40 DEL43 DEL42 DEL42 DEL42 DEL32 DEL11 DEL59 DEL60 DEL32 DEL11 DEL42 DEL43 DEL32 DEL11 DEL42 DEL43 DEL11 DEL42 DEL59 DEL60 DEL43 DEL42 DEL32 DEL59 DEL58 DEL42 DEL42 DEL32 DEL24 DEL42 DEL44 DEL42 DEL33 DEL27 DEL42 DEL14 DEL7 DEL21 DEL42 DEL32 DEL21 DEL8 DEL25 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL43 DEL42 DEL43 DEL42 DEL42 DEL42 DEL42 DEL2 DEL32 DEL11 DEL59 DEL60 DEL42 DEL33 DEL27 DEL42 DEL7 DEL21 DEL42 DEL42 DEL2 DEL42 DEL32 DEL21 DEL8 DEL25 DEL8 DEL24 DEL8 DEL43 DEL43 DEL42 DEL43 DEL42 DEL42 DEL2 DEL32 DEL11 DEL59 DEL42 DEL43 DEL11 DEL39 DEL42 DEL34 DEL59 DEL58 DEL42 DEL40 DEL27 DEL42 DEL37 DEL24 DEL43 DEL42 DEL42 DEL43 DEL42 DEL42 DEL33 DEL32 DEL11 DEL59 DEL60 DEL42 DEL42 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL42 DEL43 DEL42 DEL11 DEL59 DEL60 DEL42 DEL43 DEL42 DEL78 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL44 DEL42 DEL43 DEL42 DEL44 DEL31 DEL1 DEL14 DEL42 DEL43 DEL11 DEL33 DEL52 DEL42 DEL22 DEL32 DEL11 DEL33 DEL42 DEL43 DEL52 DEL42 DEL22 DEL32 DEL11 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL42 DEL33 DEL27 DEL36 DEL27 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL83 DEL83 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL83 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22 DEL52 DEL42 DEL22
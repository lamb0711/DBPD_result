Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * EventProcessor responsible for peeking from queue and handling over the events
- * to the dispatcher.
+ * EventProcessor responsible for peeking from queue and handling over the events to the dispatcher.
- *  {@link ConcurrentParallelGatewaySenderQueue}.
- * The dispatcher could be either GatewaySenderEventRemoteDispatcher or GatewaySenderEventCallbackDispatcher.
+ * {@link ConcurrentParallelGatewaySenderQueue}. The dispatcher could be either
+ * GatewaySenderEventRemoteDispatcher or GatewaySenderEventCallbackDispatcher.
-  
+
-  
+
-   * A boolean verifying whether this <code>AbstractGatewaySenderEventProcessor</code>
-   * is running.
+   * A boolean verifying whether this <code>AbstractGatewaySenderEventProcessor</code> is running.
-   * A boolean verifying whether this <code>AbstractGatewaySenderEventProcessor</code>
-   * is paused.
+   * A boolean verifying whether this <code>AbstractGatewaySenderEventProcessor</code> is paused.
-   * A boolean indicating that the dispatcher thread for
-   * this <code>AbstractGatewaySenderEventProcessor</code>
-   * is now waiting for resuming
+   * A boolean indicating that the dispatcher thread for this
+   * <code>AbstractGatewaySenderEventProcessor</code> is now waiting for resuming
-  
+
-   * A boolean verifying whether a warning has already been issued if the event
-   * queue has reached a certain threshold.
+   * A boolean verifying whether a warning has already been issued if the event queue has reached a
+   * certain threshold.
-  
-  /*
-   * The batchIdToEventsMap contains a mapping between batch id and an array of
-   * events. The first element of the array is the list of events peeked from
-   * the queue. The second element of the array is the list of filtered events.
-   * These are the events actually sent.
-   */
-  private Map<Integer, List<GatewaySenderEventImpl>[]> batchIdToEventsMap = Collections
-      .synchronizedMap(new HashMap<Integer, List<GatewaySenderEventImpl>[]>());
-  private Map<Integer, List<GatewaySenderEventImpl>> batchIdToPDXEventsMap = Collections
-      .synchronizedMap(new HashMap<Integer, List<GatewaySenderEventImpl>>());
-  private List<GatewaySenderEventImpl> pdxSenderEventsList = new ArrayList<GatewaySenderEventImpl>();
-  private Map<Object, GatewaySenderEventImpl> pdxEventsMap = new HashMap<Object,GatewaySenderEventImpl>();
+  /*
+   * The batchIdToEventsMap contains a mapping between batch id and an array of events. The first
+   * element of the array is the list of events peeked from the queue. The second element of the
+   * array is the list of filtered events. These are the events actually sent.
+   */
+  private Map<Integer, List<GatewaySenderEventImpl>[]> batchIdToEventsMap =
+      Collections.synchronizedMap(new HashMap<Integer, List<GatewaySenderEventImpl>[]>());
+  private Map<Integer, List<GatewaySenderEventImpl>> batchIdToPDXEventsMap =
+      Collections.synchronizedMap(new HashMap<Integer, List<GatewaySenderEventImpl>>());
+
+  private List<GatewaySenderEventImpl> pdxSenderEventsList =
+      new ArrayList<GatewaySenderEventImpl>();
+  private Map<Object, GatewaySenderEventImpl> pdxEventsMap =
+      new HashMap<Object, GatewaySenderEventImpl>();
-  
+
-  
+
-   * The batchSize is the batch size being used by this processor. By default, it is the
-   * configured batch size of the GatewaySender. It may be automatically reduced if a
-   * MessageTooLargeException occurs.
+   * The batchSize is the batch size being used by this processor. By default, it is the configured
+   * batch size of the GatewaySender. It may be automatically reduced if a MessageTooLargeException
+   * occurs.
-  
+
-  public AbstractGatewaySenderEventProcessor(LoggingThreadGroup createThreadGroup,
-      String string, GatewaySender sender) {
+  public AbstractGatewaySenderEventProcessor(LoggingThreadGroup createThreadGroup, String string,
+      GatewaySender sender) {
-    this.sender = (AbstractGatewaySender)sender;
+    this.sender = (AbstractGatewaySender) sender;
-  
-  public abstract void enqueueEvent(EnumListenerEvent operation,
-      EntryEvent event, Object substituteValue) throws IOException,
-      CacheException;
-  
+
+  public abstract void enqueueEvent(EnumListenerEvent operation, EntryEvent event,
+      Object substituteValue) throws IOException, CacheException;
+
-   * Increment the batch id. This method is not synchronized because this
-   * dispatcher is the caller
+   * Increment the batch id. This method is not synchronized because this dispatcher is the caller
-   * Reset the batch id. This method is not synchronized because this dispatcher
-   * is the caller
+   * Reset the batch id. This method is not synchronized because this dispatcher is the caller
-    //if (this.batchIdToEventsMap.size() == 1) {
-    //  if (this.batchIdToEventsMap.containsKey(0)) {
-    //    return;
-    //  }
-    //}
-    //this.batchIdToEventsMap.clear();
+    // if (this.batchIdToEventsMap.size() == 1) {
+    // if (this.batchIdToEventsMap.containsKey(0)) {
+    // return;
+    // }
+    // }
+    // this.batchIdToEventsMap.clear();
-          LocalizedStrings.AbstractGatewaySenderEventProcessor_ATTEMPT_TO_SET_BATCH_SIZE_FAILED, new Object[] { currentBatchSize, batchSize }));
+          LocalizedStrings.AbstractGatewaySenderEventProcessor_ATTEMPT_TO_SET_BATCH_SIZE_FAILED,
+          new Object[] {currentBatchSize, batchSize}));
-          LocalizedStrings.AbstractGatewaySenderEventProcessor_SET_BATCH_SIZE, new Object[] { currentBatchSize, this.batchSize }));
+          LocalizedStrings.AbstractGatewaySenderEventProcessor_SET_BATCH_SIZE,
+          new Object[] {currentBatchSize, this.batchSize}));
-  
-  protected void eventQueueRemove() throws CacheException,
-      InterruptedException {
-    this.queue.remove();
-  }
-    //return this.queue.take();
+    // return this.queue.take();
-    if(queue == null) {
+    if (queue == null) {
-    
+
-    } 
+    }
-  
+
-  //merge44957: WHile merging 44957, need this method hence picked up this method from revision 42024.
+  // merge44957: WHile merging 44957, need this method hence picked up this method from revision
+  // 42024.
-    boolean interrupted=false;
-    synchronized(this.pausedLock) {
-      while(!isDispatcherWaiting && !isStopped()
-            && sender.getSenderAdvisor().isPrimary()) {
+    boolean interrupted = false;
+    synchronized (this.pausedLock) {
+      while (!isDispatcherWaiting && !isStopped() && sender.getSenderAdvisor().isPrimary()) {
-        } catch(InterruptedException e) {
+        } catch (InterruptedException e) {
-    if(interrupted) {
+    if (interrupted) {
-  
+
-   * When a batch fails, then this keeps the last time when a failure was
-   * logged . We don't want to swamp the logs in retries due to same batch failures.
+   * When a batch fails, then this keeps the last time when a failure was logged . We don't want to
+   * swamp the logs in retries due to same batch failures.
-      
+
-   * The maximum size of {@link #failureLogInterval} beyond which it will start
-   * logging all failure instances. Hopefully this should never happen in
-   * practice.
+   * The maximum size of {@link #failureLogInterval} beyond which it will start logging all failure
+   * instances. Hopefully this should never happen in practice.
-  protected static final int FAILURE_MAP_MAXSIZE = Integer.getInteger(
-      DistributionConfig.GEMFIRE_PREFIX + "GatewaySender.FAILURE_MAP_MAXSIZE", 1000000);
+  protected static final int FAILURE_MAP_MAXSIZE = Integer
+      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "GatewaySender.FAILURE_MAP_MAXSIZE", 1000000);
-  
+
-            new long[] { System.currentTimeMillis(), 1000 });
+            new long[] {System.currentTimeMillis(), 1000});
-        }
-        else {
+        } else {
-   * After a successful batch execution remove from failure map if present (i.e.
-   * if the event had failed on a previous try).
+   * After a successful batch execution remove from failure map if present (i.e. if the event had
+   * failed on a previous try).
-  
+
-    
+
-    
+
-    //list of the events peeked from queue
+    // list of the events peeked from queue
-    // list of the above peeked events which are filtered through the filters attached 
+    // list of the above peeked events which are filtered through the filters attached
-    //list of the PDX events which are peeked from pDX region and needs to go acrossthe site 
+    // list of the PDX events which are peeked from pDX region and needs to go acrossthe site
-    
-    
+
+
-              logger.debug("GatewaySenderEventProcessor is stopped. Returning without peeking events.");
+              logger.debug(
+                  "GatewaySenderEventProcessor is stopped. Returning without peeking events.");
-          
+
-            if(resetLastPeekedEvents) {
+            if (resetLastPeekedEvents) {
-            
-             
+
+
-              
-            /*// Check if paused. If so, wait for resumption
-            if (this.isPaused) {
-              waitForResumption();
-            }
-            synchronized (this.getQueue()) {
-              // its quite possible that the queue region is
-              // destroyed(userRegion
-              // localdestroy destroys shadow region locally). In this case
-              // better to
-              // wait for shadows region to get recreated instead of keep loop
-              // for peeking events
-              if (this.getQueue().getRegion() == null
-                  || this.getQueue().getRegion().isDestroyed()) {
-                try {
-                  this.getQueue().wait();
-                  continue; // this continue is important to recheck the
-                            // conditions of stop/ pause after the wait of 1 sec
-                }
-                catch (InterruptedException e1) {
-                  Thread.currentThread().interrupt();
-                }
-              }
-            }*/
+              /*
+               * // Check if paused. If so, wait for resumption if (this.isPaused) {
+               * waitForResumption(); }
+               * 
+               * synchronized (this.getQueue()) { // its quite possible that the queue region is //
+               * destroyed(userRegion // localdestroy destroys shadow region locally). In this case
+               * // better to // wait for shadows region to get recreated instead of keep loop //
+               * for peeking events if (this.getQueue().getRegion() == null ||
+               * this.getQueue().getRegion().isDestroyed()) { try { this.getQueue().wait();
+               * continue; // this continue is important to recheck the // conditions of stop/ pause
+               * after the wait of 1 sec } catch (InterruptedException e1) {
+               * Thread.currentThread().interrupt(); } } }
+               */
-          //this list is access by ack reader thread so create new every time. #50220
+          // this list is access by ack reader thread so create new every time. #50220
-          
+
-              // This seems right place to prevent transmission of UPDATE_VERSION events if receiver's
+              // This seems right place to prevent transmission of UPDATE_VERSION events if
+              // receiver's
-              if (!sendUpdateVersionEvents && event.getOperation() == Operation.UPDATE_VERSION_STAMP) {
+              if (!sendUpdateVersionEvents
+                  && event.getOperation() == Operation.UPDATE_VERSION_STAMP) {
-                  logger.trace("Update Event Version event: {} removed from Gateway Sender queue: {}", event, sender);
+                  logger.trace(
+                      "Update Event Version event: {} removed from Gateway Sender queue: {}", event,
+                      sender);
-                
+
-              
+
-                  logger.debug("{}: Did not transmit event due to filtering: {}", sender.getId(), event);
+                  logger.debug("{}: Did not transmit event due to filtering: {}", sender.getId(),
+                      event);
-          /*if (filteredList.isEmpty()) {
-            eventQueueRemove(events.size());
-            continue;
-          }*/
-          
+          /*
+           * if (filteredList.isEmpty()) { eventQueueRemove(events.size()); continue; }
+           */
+
-              GatewaySenderEventImpl event = (GatewaySenderEventImpl)itr.next();
+              GatewaySenderEventImpl event = (GatewaySenderEventImpl) itr.next();
-                qpr = ((ConcurrentParallelGatewaySenderQueue)this.getQueue())
+                qpr = ((ConcurrentParallelGatewaySenderQueue) this.getQueue())
-              }
-              else {
-                qpr = ((ParallelGatewaySenderQueue)this.getQueue())
-                    .getRegion(event.getRegionPath());
+              } else {
+                qpr =
+                    ((ParallelGatewaySenderQueue) this.getQueue()).getRegion(event.getRegionPath());
-                BucketRegion bucket = qpr.getDataStore().getLocalBucketById(
-                    bucketId);
+                BucketRegion bucket = qpr.getDataStore().getLocalBucketById(bucketId);
-                logger.debug("Bucket id: {} is no longer primary on this node. The event {} will be dispatched from this node with possibleDuplicate set to true.",
+                logger.debug(
+                    "Bucket id: {} is no longer primary on this node. The event {} will be dispatched from this node with possibleDuplicate set to true.",
-          
+
-              this.batchIdToPDXEventsMap.put(getBatchId(),
-                  pdxEventsToBeDispatched);
+              this.batchIdToPDXEventsMap.put(getBatchId(), pdxEventsToBeDispatched);
-          
+
-          
+
-          List conflatedEventsToBeDispatched = conflate(eventsToBeDispatched);          
-          
+          List conflatedEventsToBeDispatched = conflate(eventsToBeDispatched);
+
-            logBatchFine("During normal processing, dispatching the following ", conflatedEventsToBeDispatched);
+            logBatchFine("During normal processing, dispatching the following ",
+                conflatedEventsToBeDispatched);
-          
+
-              logger.debug("During normal processing, successfully dispatched {} events (batch #{})",
+              logger.debug(
+                  "During normal processing, successfully dispatched {} events (batch #{})",
-                            removeEventFromFailureMap(getBatchId());
-          }
-          else {
-            if (!skipFailureLogging(getBatchId())) { 
-              logger.warn(LocalizedMessage.create(
-                  LocalizedStrings.GatewayImpl_EVENT_QUEUE_DISPATCH_FAILED, new Object[] { filteredList.size(), getBatchId() }));       
+            removeEventFromFailureMap(getBatchId());
+          } else {
+            if (!skipFailureLogging(getBatchId())) {
+              logger.warn(
+                  LocalizedMessage.create(LocalizedStrings.GatewayImpl_EVENT_QUEUE_DISPATCH_FAILED,
+                      new Object[] {filteredList.size(), getBatchId()}));
-            
+
-                    logger.debug("During normal processing, unsuccessfully dispatched {} events (batch #{})",
+                    logger.debug(
+                        "During normal processing, unsuccessfully dispatched {} events (batch #{})",
-            logger.debug("Finished processing events (batch #{})", (getBatchId()-1));
+            logger.debug("Finished processing events (batch #{})", (getBatchId() - 1));
-        //setting this flag will ensure that already peeked events will make 
-        //it to the next batch before new events are peeked (fix for #48784)
+        // setting this flag will ensure that already peeked events will make
+        // it to the next batch before new events are peeked (fix for #48784)
-        
+
-        
+
-          if (cause instanceof IOException
-              || e instanceof GatewaySenderConfigurationException) {
+          if (cause instanceof IOException || e instanceof GatewaySenderConfigurationException) {
-        
+
-        logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayImpl_AN_EXCEPTION_OCCURRED_THE_DISPATCHER_WILL_CONTINUE), e);
+        logger.warn(
+            LocalizedMessage.create(
+                LocalizedStrings.GatewayImpl_AN_EXCEPTION_OCCURRED_THE_DISPATCHER_WILL_CONTINUE),
+            e);
-  
-  private boolean shouldSendVersionEvents(
-      GatewaySenderEventDispatcher dispatcher) {
+
+  private boolean shouldSendVersionEvents(GatewaySenderEventDispatcher dispatcher) {
-    
+
-      Map<ConflationKey, GatewaySenderEventImpl> conflatedEventsMap = new LinkedHashMap<ConflationKey, GatewaySenderEventImpl>();
+      Map<ConflationKey, GatewaySenderEventImpl> conflatedEventsMap =
+          new LinkedHashMap<ConflationKey, GatewaySenderEventImpl>();
-          ConflationKey key = new ConflationKey(gsEvent.getRegion().getFullPath(), gsEvent.getKeyToConflate(),
-              gsEvent.getOperation());
+          ConflationKey key = new ConflationKey(gsEvent.getRegion().getFullPath(),
+              gsEvent.getKeyToConflate(), gsEvent.getOperation());
-        }
-        else {
+        } else {
-          ConflationKey key = new ConflationKey(gsEvent.getRegion().getFullPath(), gsEvent.getKeyToConflate(),
-              gsEvent.getOperation());
+          ConflationKey key = new ConflationKey(gsEvent.getRegion().getFullPath(),
+              gsEvent.getKeyToConflate(), gsEvent.getOperation());
-      this.sender.getStatistics().incEventsConflatedFromBatches(
-          events.size() - conflatedEvents.size());
-    }
-    else {
+      this.sender.getStatistics()
+          .incEventsConflatedFromBatches(events.size() - conflatedEvents.size());
+    } else {
-  } 
-  
+  }
+
-    
-    //getPDXRegion
+
+    // getPDXRegion
-    Region<Object, Object> pdxRegion = cache
-        .getRegion(PeerTypeRegistration.REGION_NAME);
-    
-    if(rebuildPdxList) {
+    Region<Object, Object> pdxRegion = cache.getRegion(PeerTypeRegistration.REGION_NAME);
+
+    if (rebuildPdxList) {
-    
+
-        if(!pdxEventsMap.containsKey(typeEntry.getKey())){
+        if (!pdxEventsMap.containsKey(typeEntry.getKey())) {
-          EntryEventImpl event = EntryEventImpl.create(
-              (LocalRegion) pdxRegion, Operation.UPDATE,
-              typeEntry.getKey(), typeEntry.getValue(), null, false,
-              cache.getMyId());
+          EntryEventImpl event = EntryEventImpl.create((LocalRegion) pdxRegion, Operation.UPDATE,
+              typeEntry.getKey(), typeEntry.getValue(), null, false, cache.getMyId());
-              event.getRawCallbackArgument(), this.sender.getMyDSId(),
-              allRemoteDSIds);
+              event.getRawCallbackArgument(), this.sender.getMyDSId(), allRemoteDSIds);
-          GatewaySenderEventImpl pdxSenderEvent = new GatewaySenderEventImpl(
-              EnumListenerEvent.AFTER_UPDATE, event, null); // OFFHEAP: event for pdx type meta data so it should never be off-heap
+          GatewaySenderEventImpl pdxSenderEvent =
+              new GatewaySenderEventImpl(EnumListenerEvent.AFTER_UPDATE, event, null); // OFFHEAP:
+                                                                                       // event for
+                                                                                       // pdx type
+                                                                                       // meta data
+                                                                                       // so it
+                                                                                       // should
+                                                                                       // never be
+                                                                                       // off-heap
-    
-    
+
+
-    while(iterator.hasNext()){
+    while (iterator.hasNext()) {
-    if(!pdxEventsToBeDispatched.isEmpty() && logger.isDebugEnabled()){
-      logger.debug("List of PDX Event to be dispatched : {}", pdxEventsToBeDispatched);  
+    if (!pdxEventsToBeDispatched.isEmpty() && logger.isDebugEnabled()) {
+      logger.debug("List of PDX Event to be dispatched : {}", pdxEventsToBeDispatched);
-    
+
-  
+
-   * Mark all PDX types as requiring dispatch so that they will be
-   * sent over the connection again.
-   * @param remotePdxSize 
+   * Mark all PDX types as requiring dispatch so that they will be sent over the connection again.
+   * 
+   * @param remotePdxSize
-    Region<Object, Object> pdxRegion = cache
-        .getRegion(PeerTypeRegistration.REGION_NAME);
-    
-    //The peer has not seen all of our PDX types. This may be because
-    //they have been lost on the remote side. Resend the PDX types.
-    if(pdxRegion != null && pdxRegion.size() > remotePdxSize) {
+    Region<Object, Object> pdxRegion = cache.getRegion(PeerTypeRegistration.REGION_NAME);
+
+    // The peer has not seen all of our PDX types. This may be because
+    // they have been lost on the remote side. Resend the PDX types.
+    if (pdxRegion != null && pdxRegion.size() > remotePdxSize) {
-  } 
+  }
-    for(Map.Entry<Integer, List<GatewaySenderEventImpl>> entry : this.batchIdToPDXEventsMap.entrySet()){
-      for(GatewaySenderEventImpl event : entry.getValue()){
+    for (Map.Entry<Integer, List<GatewaySenderEventImpl>> entry : this.batchIdToPDXEventsMap
+        .entrySet()) {
+      for (GatewaySenderEventImpl event : entry.getValue()) {
-    if(this.queue instanceof SerialGatewaySenderQueue)
-      ((SerialGatewaySenderQueue)this.queue).resetLastPeeked();
-    else if (this.queue instanceof ParallelGatewaySenderQueue){
-      ((ParallelGatewaySenderQueue)this.queue).resetLastPeeked();
-    }else{
-      //we will never come here
+    if (this.queue instanceof SerialGatewaySenderQueue)
+      ((SerialGatewaySenderQueue) this.queue).resetLastPeeked();
+    else if (this.queue instanceof ParallelGatewaySenderQueue) {
+      ((ParallelGatewaySenderQueue) this.queue).resetLastPeeked();
+    } else {
+      // we will never come here
-              filter.afterAcknowledgement((GatewaySenderEventImpl)o);
+              filter.afterAcknowledgement((GatewaySenderEventImpl) o);
-              logger
-              .fatal(
-                  LocalizedMessage
-                      .create(
-                          LocalizedStrings.GatewayEventFilter_EXCEPTION_OCCURED_WHILE_HANDLING_CALL_TO_0_AFTER_ACKNOWLEDGEMENT_FOR_EVENT_1,
-                          new Object[] { filter.toString(), o }), e);
+              logger.fatal(LocalizedMessage.create(
+                  LocalizedStrings.GatewayEventFilter_EXCEPTION_OCCURED_WHILE_HANDLING_CALL_TO_0_AFTER_ACKNOWLEDGEMENT_FOR_EVENT_1,
+                  new Object[] {filter.toString(), o}), e);
-          GatewaySenderEventImpl ge = (GatewaySenderEventImpl)o;
+          GatewaySenderEventImpl ge = (GatewaySenderEventImpl) o;
-            logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayImpl_EVENT_QUEUE_ALERT_OPERATION_0_REGION_1_KEY_2_VALUE_3_TIME_4,
-                new Object[] { ge.getOperation(), ge.getRegionPath(), ge.getKey(),
-                ge.getValueAsString(true), currentTime - ge.getCreationTime() }));
+            logger.warn(LocalizedMessage.create(
+                LocalizedStrings.GatewayImpl_EVENT_QUEUE_ALERT_OPERATION_0_REGION_1_KEY_2_VALUE_3_TIME_4,
+                new Object[] {ge.getOperation(), ge.getRegionPath(), ge.getKey(),
+                    ge.getValueAsString(true), currentTime - ge.getCreationTime()}));
-    if (this.eventQueueSizeWarning
-        && queueSize <= AbstractGatewaySender.QUEUE_SIZE_THRESHOLD) {
+    if (this.eventQueueSizeWarning && queueSize <= AbstractGatewaySender.QUEUE_SIZE_THRESHOLD) {
-              LocalizedStrings.GatewayImpl_THE_EVENT_QUEUE_SIZE_HAS_DROPPED_BELOW_THE_THRESHOLD_0,
-              AbstractGatewaySender.QUEUE_SIZE_THRESHOLD));
+          LocalizedStrings.GatewayImpl_THE_EVENT_QUEUE_SIZE_HAS_DROPPED_BELOW_THE_THRESHOLD_0,
+          AbstractGatewaySender.QUEUE_SIZE_THRESHOLD));
-  
+
-  
+
-        GatewaySenderEventImpl ge = (GatewaySenderEventImpl)o;
+        GatewaySenderEventImpl ge = (GatewaySenderEventImpl) o;
-  
+
-   * In case of BatchException we expect that the dispatcher has removed all
-   * the events till the event that threw BatchException.
+   * In case of BatchException we expect that the dispatcher has removed all the events till the
+   * event that threw BatchException.
-    List<GatewaySenderEventImpl> pdxEvents = this.batchIdToPDXEventsMap
-        .remove(batchId);
+    List<GatewaySenderEventImpl> pdxEvents = this.batchIdToPDXEventsMap.remove(batchId);
-    
-    List<GatewaySenderEventImpl>[] eventsArr = this.batchIdToEventsMap
-        .remove(batchId);
+
+    List<GatewaySenderEventImpl>[] eventsArr = this.batchIdToEventsMap.remove(batchId);
-            logger
-                .fatal(
-                    LocalizedMessage
-                        .create(
-                            LocalizedStrings.GatewayEventFilter_EXCEPTION_OCCURED_WHILE_HANDLING_CALL_TO_0_AFTER_ACKNOWLEDGEMENT_FOR_EVENT_1,
-                            new Object[] { filter.toString(), event }), e);
+            logger.fatal(LocalizedMessage.create(
+                LocalizedStrings.GatewayEventFilter_EXCEPTION_OCCURED_WHILE_HANDLING_CALL_TO_0_AFTER_ACKNOWLEDGEMENT_FOR_EVENT_1,
+                new Object[] {filter.toString(), event}), e);
-    
+
-  
+
-    if(eventsArr!=null){
+    if (eventsArr != null) {
-          GatewaySenderEventImpl ge = (GatewaySenderEventImpl)o;
+          GatewaySenderEventImpl ge = (GatewaySenderEventImpl) o;
-  
-  //merge44957: While merging 44957, changed this method as per revision 42024.
+
+  // merge44957: While merging 44957, changed this method as per revision 42024.
-  
+
-  
-  public GatewaySenderEventDispatcher getDispatcher(){
+
+  public GatewaySenderEventDispatcher getDispatcher() {
-  
+
+
-        logger.info(LocalizedMessage.create(LocalizedStrings.GatewayImpl_A_CANCELLATION_OCCURRED_STOPPING_THE_DISPATCHER));
+        logger.info(LocalizedMessage
+            .create(LocalizedStrings.GatewayImpl_A_CANCELLATION_OCCURRED_STOPPING_THE_DISPATCHER));
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.GatewayImpl_MESSAGE_DISPATCH_FAILED_DUE_TO_UNEXPECTED_EXCEPTION), e);
+      logger.fatal(LocalizedMessage.create(
+          LocalizedStrings.GatewayImpl_MESSAGE_DISPATCH_FAILED_DUE_TO_UNEXPECTED_EXCEPTION), e);
-    }
-    catch (GemFireException e) {
+    } catch (GemFireException e) {
-      }
-      else {
+      } else {
-  
-  public Exception getException(){
+
+  public Exception getException() {
+
-   * Stops the dispatcher from dispatching events . The dispatcher will stay
-   * alive for a predefined time OR until its queue is empty.
+   * Stops the dispatcher from dispatching events . The dispatcher will stay alive for a predefined
+   * time OR until its queue is empty.
-    
+
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-        }
-        catch (CancelException e) {
+        } catch (CancelException e) {
+    } else {
+      this.sender.getSenderAdvisor().notifyPrimaryLock();
-          logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayImpl_0_DISPATCHER_STILL_ALIVE_EVEN_AFTER_JOIN_OF_5_SECONDS, this));
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.GatewayImpl_0_DISPATCHER_STILL_ALIVE_EVEN_AFTER_JOIN_OF_5_SECONDS,
+              this));
-        logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayImpl_0_INTERRUPTEDEXCEPTION_IN_JOINING_WITH_DISPATCHER_THREAD, this));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.GatewayImpl_0_INTERRUPTEDEXCEPTION_IN_JOINING_WITH_DISPATCHER_THREAD,
+            this));
-    
+
-    
+
-  
+
-        logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayImpl_DESTROYING_GATEWAYEVENTDISPATCHER_WITH_ACTIVELY_QUEUED_DATA));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.GatewayImpl_DESTROYING_GATEWAYEVENTDISPATCHER_WITH_ACTIVELY_QUEUED_DATA));
-          logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayImpl_DESTROYING_GATEWAYEVENTDISPATCHER_WITH_ACTIVELY_QUEUED_DATA));
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.GatewayImpl_DESTROYING_GATEWAYEVENTDISPATCHER_WITH_ACTIVELY_QUEUED_DATA));
-         * ignore, 
+         * ignore,
-  
-  public void removeCacheListener(){
-    
+
+  public void removeCacheListener() {
+
-   * @param events
-   *          The batch of events to log
+   * @param events The batch of events to log
- 
+
-  public void clear(PartitionedRegion pr, int bucketId) {
-    ((ParallelGatewaySenderQueue)this.queue).clear(pr, bucketId);
-}
-/*public int size(PartitionedRegion pr, int bucketId)
-  throws ForceReattemptException {
-    return ((ParallelGatewaySenderQueue)this.queue).size(pr, bucketId);
-}*/
+  public void clear(PartitionedRegion pr, int bucketId) {
+    ((ParallelGatewaySenderQueue) this.queue).clear(pr, bucketId);
+  }
+
+  /*
+   * public int size(PartitionedRegion pr, int bucketId) throws ForceReattemptException { return
+   * ((ParallelGatewaySenderQueue)this.queue).size(pr, bucketId); }
+   */
-    return ((ParallelGatewaySenderQueue) this.queue).getBucketToTempQueueMap()
-        .get(bucketId);
+    return ((ParallelGatewaySenderQueue) this.queue).getBucketToTempQueueMap().get(bucketId);
-  public void conflateEvent(Conflatable conflatableObject, int bucketId,
-      Long tailKey) {
-    ((ParallelGatewaySenderQueue) this.queue).conflateEvent(conflatableObject,
-        bucketId, tailKey);
+  public void conflateEvent(Conflatable conflatableObject, int bucketId, Long tailKey) {
+    ((ParallelGatewaySenderQueue) this.queue).conflateEvent(conflatableObject, bucketId, tailKey);
-    ((ParallelGatewaySenderQueue) this.queue)
-        .addShadowPartitionedRegionForUserPR(pr);
+    ((ParallelGatewaySenderQueue) this.queue).addShadowPartitionedRegionForUserPR(pr);
-    ((ParallelGatewaySenderQueue) this.queue)
-        .addShadowPartitionedRegionForUserRR(userRegion);
+    ((ParallelGatewaySenderQueue) this.queue).addShadowPartitionedRegionForUserRR(userRegion);
-  
+
-    public Boolean call () {
+    public Boolean call() {
-  
+
-    
+
-      ConflationKey that = (ConflationKey)obj;
+      ConflationKey that = (ConflationKey) obj;
-  }   
+  }

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 INS8 UPD66 INS21 INS32 INS32 INS42 INS22 INS42 INS52 INS42 DEL66 DEL66 DEL66 DEL66 DEL66 DEL66 DEL83 DEL39 DEL42 DEL42 DEL43 DEL42 DEL43 DEL52 DEL42 DEL22 DEL42 DEL32 DEL21 DEL8 DEL31 DEL66 DEL66 DEL66
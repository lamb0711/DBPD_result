GEODE-6808: Restore JSON backward compatibility (#3688)

* GEODE-6808: Revert test changes & add new checks

- Added new unit tests.
- Reverted changes made to tests during the replacement of TypedJson
to be sure backward compatibility is achieved after the implementation
of this ticket.

* GEODE-6808: Restore JSON backward compatibility

Reverted some of the changes made when deleting the in-house JSON
implementation (TypedJson) to the jackson library
('QueryResultFormatter') to restore the backward compatibility.

- Everything is serialized as JSON array with 2 elements: type & value.
- Internal class names are hidden in the JSON document, public
  interfaces are included instead.
- Beans and primitive types only use the standard format when they are
  not being serialized as part of an array, in which case the type is
  ignored as it's already been serialized as ArrayElementType[].
+import java.util.HashSet;
+import java.util.Set;
+import org.apache.geode.cache.query.Struct;
+import org.apache.geode.management.internal.cli.util.JsonUtil;
+import org.apache.geode.pdx.internal.PdxInstanceImpl;
-
+  final boolean generateTypeInformation;
+  final Set<Class> nonOverridableSerializers;
-  /**
+  /*
-    this.serializedObjects = new IdentityHashMap<>();
+    this.serializedObjects = new IdentityHashMap<>();
+    this.generateTypeInformation = generateTypeInformation;
+    this.nonOverridableSerializers = new HashSet<>();
-    SimpleModule mapperModule =
-        new PreventReserializationModule(serializedObjects, serDepth);
+    SimpleModule mapperModule = new PreventReserializationModule(serializedObjects, serDepth);
+
+    // insert a Struct serializer that knows about its format
+    mapperModule.addSerializer(StructImpl.class, new StructSerializer());
+    nonOverridableSerializers.add(StructImpl.class);
+
+    // insert a PdxInstance serializer that knows about PDX fields/values
+    mapperModule.addSerializer(PdxInstance.class, new PdxInstanceSerializer());
+    nonOverridableSerializers.add(PdxInstanceImpl.class);
+
+    // insert a RegionEntry serializer because they're too messy looking
+    mapperModule.addSerializer(Region.Entry.class, new RegionEntrySerializer());
+    nonOverridableSerializers.add(Region.Entry.class);
-    // insert a PdxInstance serializer that knows about PDX fields/values
-    mapperModule.addSerializer(PdxInstance.class, new PdxInstanceSerializer());
-    // insert a Struct serializer that knows about its format
-    mapperModule.addSerializer(StructImpl.class, new StructSerializer());
-    // insert a RegionEntry serializer because they're too messy looking
-    mapperModule.addSerializer(Region.Entry.class, new RegionEntrySerializer());
+    // register the custom module
-    if (generateTypeInformation) {
-      // add type information (Jackson has no way to force it to do this for all values)
-      mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
-    }
-
+  // TODO: Re-Implement this class.
+  // Right now we avoid serializing objects that we've already serialized and, instead, just add
+  // some custom markers ('duplicate' / 'reference@') to the JSON document. These markers, however,
+  // can't be effectively used by clients of this class because the originally serialized objects
+  // don't have any kind of 'id' in the resulting document (the 'reference@' marker might be
+  // used BUT the document needs to be de-serialized within the same JVM on which it was
+  // serialized AND IT MUST be Java - System.identityHashCode(object).
-
-    private JsonSerializer defaultSerializer;
-    Map<Object, Object> serializedObjects;
-    private final int serializationDepth;
+    Map serializedObjects;
+    private JsonSerializer defaultSerializer;
+    private final int serializationDepth;
-    boolean isPrimitiveOrWrapper(Class<?> klass) {
-      return klass.isAssignableFrom(Byte.class) || klass.isAssignableFrom(byte.class)
-          || klass.isAssignableFrom(Short.class) || klass.isAssignableFrom(short.class)
-          || klass.isAssignableFrom(Integer.class) || klass.isAssignableFrom(int.class)
-          || klass.isAssignableFrom(Long.class) || klass.isAssignableFrom(long.class)
-          || klass.isAssignableFrom(Float.class) || klass.isAssignableFrom(float.class)
-          || klass.isAssignableFrom(Double.class) || klass.isAssignableFrom(double.class)
-          || klass.isAssignableFrom(Boolean.class) || klass.isAssignableFrom(boolean.class)
-          || klass.isAssignableFrom(String.class) || klass.isAssignableFrom(char.class)
-          || klass.isAssignableFrom(Character.class) || klass.isAssignableFrom(java.sql.Date.class)
-          || klass.isAssignableFrom(java.util.Date.class)
-          || klass.isAssignableFrom(java.math.BigDecimal.class);
+    private boolean isPrimitiveOrWrapper(Class<?> klass) {
+      return JsonUtil.isPrimitiveOrWrapper(klass);
+    @SuppressWarnings("unchecked")
-      if (value == null || isPrimitiveOrWrapper(value.getClass())) {
+      if (value == null || isPrimitiveOrWrapper(value.getClass()) || value.getClass().isEnum()) {
+    @SuppressWarnings("unchecked")
-      if (value == null || isPrimitiveOrWrapper(value.getClass())) {
+      if (value == null || isPrimitiveOrWrapper(value.getClass()) || value.getClass().isEnum()) {
-  private static class CollectionSerializer extends JsonSerializer<Collection> {
-    private final int maxCollectionElements;
-
-    public CollectionSerializer(int maxCollectionElements) {
-      this.maxCollectionElements = maxCollectionElements;
-    }
-
-    @Override
-    public void serializeWithType(Collection value, JsonGenerator gen,
-        SerializerProvider serializers, TypeSerializer typeSer)
-        throws IOException {
-      gen.setCurrentValue(value);
-      WritableTypeId typeIdDef = typeSer.writeTypePrefix(gen,
-          typeSer.typeId(value, JsonToken.START_OBJECT));
-      serializeElements(value, gen);
-      typeSer.writeTypeSuffix(gen, typeIdDef);
-    }
-
-    @Override
-    public void serialize(Collection value, JsonGenerator gen, SerializerProvider serializers)
-        throws IOException {
-      gen.writeStartObject();
-      serializeElements(value, gen);
-      gen.writeEndObject();
-    }
-
-    void serializeElements(Collection value, JsonGenerator gen) throws IOException {
-      Iterator<Object> objects = value.iterator();
-      for (int i = 0; i < maxCollectionElements && objects.hasNext(); i++) {
-        Object nextObject = objects.next();
-        gen.writeObjectField("" + i, nextObject);
-      }
-    }
-
-    @Override
-    public Class<Collection> handledType() {
-      return Collection.class;
-    }
-  }
-
-
-  private static class PdxInstanceSerializer extends JsonSerializer<PdxInstance> {
-    @Override
-    public void serializeWithType(PdxInstance value, JsonGenerator gen,
-        SerializerProvider serializers, TypeSerializer typeSer)
-        throws IOException {
-      WritableTypeId writableTypeId = typeSer.typeId(value, JsonToken.START_OBJECT);
-      typeSer.writeTypePrefix(gen, writableTypeId);
-      serializeFields(value, gen);
-      typeSer.writeTypeSuffix(gen, writableTypeId);
-    }
-
-    @Override
-    public void serialize(PdxInstance value, JsonGenerator gen, SerializerProvider serializers)
-        throws IOException {
-      gen.writeStartObject();
-      serializeFields(value, gen);
-      gen.writeEndObject();
-    }
-
-    void serializeFields(PdxInstance value, JsonGenerator gen) throws IOException {
-      for (String field : value.getFieldNames()) {
-        gen.writeObjectField(field, value.getField(field));
-      }
-    }
-
-    @Override
-    public Class<PdxInstance> handledType() {
-      return PdxInstance.class;
-    }
-  }
-
+  /**
+   * A custom JSON serializer for Struct.
+   */
-      typeSer.writeTypePrefix(gen, typeSer.typeId(value, JsonToken.START_OBJECT));
+      // We don't want to expose the internal classes, show interface instead.
+      WritableTypeId typeId = typeSer.typeId(value, Struct.class, JsonToken.START_OBJECT);
+      typeSer.writeTypePrefix(gen, typeId);
-      typeSer.writeTypeSuffix(gen, typeSer.typeId(value, JsonToken.START_OBJECT));
+      typeSer.writeTypeSuffix(gen, typeId);
+  /**
+   * A custom JSON serializer for PdxInstances.
+   */
+  private static class PdxInstanceSerializer extends JsonSerializer<PdxInstance> {
+    @Override
+    public void serializeWithType(PdxInstance value, JsonGenerator gen,
+        SerializerProvider serializers, TypeSerializer typeSer)
+        throws IOException {
+      // We don't want to expose the internal classes, show interface instead.
+      WritableTypeId typeId = typeSer.typeId(value, PdxInstance.class, JsonToken.START_OBJECT);
+      typeSer.writeTypePrefix(gen, typeId);
+      serializeFields(value, gen);
+      typeSer.writeTypeSuffix(gen, typeId);
+    }
+
+    @Override
+    public void serialize(PdxInstance value, JsonGenerator gen, SerializerProvider serializers)
+        throws IOException {
+      gen.writeStartObject();
+      serializeFields(value, gen);
+      gen.writeEndObject();
+    }
+
+    void serializeFields(PdxInstance value, JsonGenerator gen) throws IOException {
+      for (String field : value.getFieldNames()) {
+        gen.writeObjectField(field, value.getField(field));
+      }
+    }
+
+    @Override
+    public Class<PdxInstance> handledType() {
+      return PdxInstance.class;
+    }
+  }
+
+  /**
+   * A custom JSON serializer for region entries.
+   */
-      typeSer.writeTypePrefix(gen, typeSer.typeId(value, JsonToken.START_OBJECT));
+      typeSer.writeTypePrefix(gen,
+          typeSer.typeId(value, Region.Entry.class, JsonToken.START_OBJECT));
+   * A JSON serializer for collections to limit the number of elements written to the document.
+   */
+  private static class CollectionSerializer extends JsonSerializer<Collection> {
+    private final int maxCollectionElements;
+
+    CollectionSerializer(int maxCollectionElements) {
+      this.maxCollectionElements = maxCollectionElements;
+    }
+
+    @Override
+    public void serializeWithType(Collection value, JsonGenerator gen,
+        SerializerProvider serializers, TypeSerializer typeSer)
+        throws IOException {
+      gen.setCurrentValue(value);
+      WritableTypeId typeIdDef = typeSer.writeTypePrefix(gen,
+          typeSer.typeId(value, JsonToken.START_OBJECT));
+      serializeElements(value, gen);
+      typeSer.writeTypeSuffix(gen, typeIdDef);
+    }
+
+    @Override
+    public void serialize(Collection value, JsonGenerator gen, SerializerProvider serializers)
+        throws IOException {
+      gen.writeStartObject();
+      serializeElements(value, gen);
+      gen.writeEndObject();
+    }
+
+    void serializeElements(Collection value, JsonGenerator gen) throws IOException {
+      Iterator objects = value.iterator();
+      for (int i = 0; i < maxCollectionElements && objects.hasNext(); i++) {
+        Object nextObject = objects.next();
+        gen.writeObjectField("" + i, nextObject);
+      }
+    }
+
+    @Override
+    public Class<Collection> handledType() {
+      return Collection.class;
+    }
+  }
+
+  /**
-   * reserialization of objects that have already been serialized. W/o this
+   * re-serialization of objects that have already been serialized. W/o this
-

INS26 INS26 INS26 INS26 INS26 MOV55 MOV55 INS40 INS40 INS40 INS40 INS40 INS23 INS23 MOV23 MOV23 INS83 INS39 INS59 INS83 INS74 INS59 MOV21 MOV21 MOV21 INS29 INS29 INS29 INS29 INS42 INS43 INS43 INS42 INS21 INS21 INS21 INS21 MOV21 INS43 INS83 INS79 INS79 INS65 INS65 INS65 INS65 INS42 INS42 INS7 INS7 INS32 INS32 MOV42 INS42 INS45 INS42 INS45 INS66 INS60 INS21 INS21 INS66 INS66 INS66 UPD66 INS22 INS42 INS22 INS14 INS42 INS42 INS57 INS42 INS42 INS57 UPD42 UPD42 INS57 INS32 INS27 INS43 INS59 INS32 INS32 MOV43 INS52 INS42 INS52 INS42 INS74 INS43 INS43 INS43 UPD42 MOV42 INS42 MOV42 INS27 INS32 MOV27 INS42 INS42 INS32 MOV42 UPD42 MOV42 MOV42 INS42 MOV42 UPD42 MOV42 UPD42 MOV42 INS42 UPD42 UPD42 UPD42 INS43 INS42 INS42 INS40 MOV27 INS32 INS32 INS42 INS42 MOV42 MOV42 MOV42 INS57 MOV40 INS57 INS57 INS42 MOV42 INS32 INS42 INS42 INS43 INS43 INS43 INS42 INS42 INS42 INS42 INS40 DEL66 DEL66 DEL65 DEL29 DEL40 DEL42 DEL8 DEL25 DEL43 DEL42 DEL43 DEL42 DEL43 DEL74 DEL42 DEL42 DEL43 DEL57 DEL32 DEL42 DEL42 DEL39 DEL57 DEL32 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL42 DEL42 DEL39 DEL57 DEL32 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL42 DEL39 DEL57 DEL32 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL42 DEL42 DEL39 DEL57 DEL32 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL42 DEL42 DEL39 DEL57 DEL32 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL42 DEL42 DEL39 DEL57 DEL32 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL42 DEL42 DEL39 DEL57 DEL32 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL42 DEL42 DEL39 DEL57 DEL32 DEL42 DEL42 DEL42 DEL43 DEL57 DEL32 DEL42 DEL42 DEL40 DEL43 DEL57 DEL32 DEL42 DEL42 DEL40 DEL43 DEL57 DEL32 DEL42 DEL42 DEL40 DEL43 DEL57 DEL32 DEL27 DEL42 DEL42 DEL42 DEL32 DEL32 DEL21 DEL40 DEL32 DEL32 DEL21 DEL83 DEL42 DEL43 DEL74
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
-  public CountDownLatch someMemberRecoveredLatch = new CountDownLatch(1); 
+
+  public CountDownLatch someMemberRecoveredLatch = new CountDownLatch(1);
-  /** A listener to watch for removes during the recovery process.
-   *  After recovery is done, we know longer need to worry about removes.
+  /**
+   * A listener to watch for removes during the recovery process. After recovery is done, we know
+   * longer need to worry about removes.
-  
-  public BucketPersistenceAdvisor(CacheDistributionAdvisor advisor,
-      DistributedLockService dl, PersistentMemberView storage, String regionPath,
-      DiskRegionStats diskStats, PersistentMemberManager memberManager,
-      BucketLock bucketLock, ProxyBucketRegion proxyBucketRegion) {
+
+  public BucketPersistenceAdvisor(CacheDistributionAdvisor advisor, DistributedLockService dl,
+      PersistentMemberView storage, String regionPath, DiskRegionStats diskStats,
+      PersistentMemberManager memberManager, BucketLock bucketLock,
+      ProxyBucketRegion proxyBucketRegion) {
-    
+
-    if(!getPersistedMembers().isEmpty()) {
+    if (!getPersistedMembers().isEmpty()) {
-    //Make sure any removes that we saw during recovery are
-    //applied.
+    // Make sure any removes that we saw during recovery are
+    // applied.
-    for(PersistentMemberID id : recoveryListener.getRemovedMembers()) {
+    for (PersistentMemberID id : recoveryListener.getRemovedMembers()) {
-    if(someMemberRecoveredLatch.getCount() > 0) {
-      this.recoveryException =e;
+    if (someMemberRecoveredLatch.getCount() > 0) {
+      this.recoveryException = e;
-    } else if(recoveryException != null){
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.BucketPersistenceAdvisor_ERROR_RECOVERYING_SECONDARY_BUCKET_0, 
-          new Object[] {proxyBucket.getPartitionedRegion().getFullPath(), proxyBucket.getBucketId()}), 
+    } else if (recoveryException != null) {
+      logger.fatal(LocalizedMessage.create(
+          LocalizedStrings.BucketPersistenceAdvisor_ERROR_RECOVERYING_SECONDARY_BUCKET_0,
+          new Object[] {proxyBucket.getPartitionedRegion().getFullPath(),
+              proxyBucket.getBucketId()}),
-  
+
-  protected void beginWaitingForMembershipChange(
-      Set<PersistentMemberID> membersToWaitFor) {
-    if(recovering) {
+  protected void beginWaitingForMembershipChange(Set<PersistentMemberID> membersToWaitFor) {
+    if (recovering) {
-      if(membersToWaitFor != null && !membersToWaitFor.isEmpty()) {
-        String message = LocalizedStrings.PartitionedRegionDataStore_DATA_OFFLINE_MESSAGE.toLocalizedString(proxyBucket.getPartitionedRegion().getFullPath(), proxyBucket.getBucketId(), membersToWaitFor);
-        throw new PartitionOfflineException((Set)membersToWaitFor, message);
+      if (membersToWaitFor != null && !membersToWaitFor.isEmpty()) {
+        String message = LocalizedStrings.PartitionedRegionDataStore_DATA_OFFLINE_MESSAGE
+            .toLocalizedString(proxyBucket.getPartitionedRegion().getFullPath(),
+                proxyBucket.getBucketId(), membersToWaitFor);
+        throw new PartitionOfflineException((Set) membersToWaitFor, message);
-  
-  @Override
-  protected void logWaitingForMember(Set<PersistentMemberID> allMembersToWaitFor, Set<PersistentMemberID> offlineMembersToWaitFor) {
-    //We only log the bucket level information at fine level.
-    if (logger.isDebugEnabled(LogMarker.PERSIST_ADVISOR)) {
-      Set<String> membersToWaitForPrettyFormat = new HashSet<String>(); 
-      if(offlineMembersToWaitFor != null && !offlineMembersToWaitFor.isEmpty()) {
-        TransformUtils.transform(offlineMembersToWaitFor, membersToWaitForPrettyFormat, TransformUtils.persistentMemberIdToLogEntryTransformer);
-        logger.info(LogMarker.PERSIST_ADVISOR, LocalizedMessage.create(LocalizedStrings.BucketPersistenceAdvisor_WAITING_FOR_LATEST_MEMBER,
-            new Object[] {proxyBucket.getPartitionedRegion().getFullPath(), proxyBucket.getBucketId(), TransformUtils.persistentMemberIdToLogEntryTransformer.transform(getPersistentID()),
+  @Override
+  protected void logWaitingForMember(Set<PersistentMemberID> allMembersToWaitFor,
+      Set<PersistentMemberID> offlineMembersToWaitFor) {
+    // We only log the bucket level information at fine level.
+    if (logger.isDebugEnabled(LogMarker.PERSIST_ADVISOR)) {
+      Set<String> membersToWaitForPrettyFormat = new HashSet<String>();
+
+      if (offlineMembersToWaitFor != null && !offlineMembersToWaitFor.isEmpty()) {
+        TransformUtils.transform(offlineMembersToWaitFor, membersToWaitForPrettyFormat,
+            TransformUtils.persistentMemberIdToLogEntryTransformer);
+        logger.info(LogMarker.PERSIST_ADVISOR, LocalizedMessage.create(
+            LocalizedStrings.BucketPersistenceAdvisor_WAITING_FOR_LATEST_MEMBER,
+            new Object[] {proxyBucket.getPartitionedRegion().getFullPath(),
+                proxyBucket.getBucketId(),
+                TransformUtils.persistentMemberIdToLogEntryTransformer.transform(getPersistentID()),
-        TransformUtils.transform(allMembersToWaitFor, membersToWaitForPrettyFormat, TransformUtils.persistentMemberIdToLogEntryTransformer);
+        TransformUtils.transform(allMembersToWaitFor, membersToWaitForPrettyFormat,
+            TransformUtils.persistentMemberIdToLogEntryTransformer);
-          logger.debug(LogMarker.PERSIST_ADVISOR, "All persistent members being waited on are online, but they have not yet initialized");
+          logger.debug(LogMarker.PERSIST_ADVISOR,
+              "All persistent members being waited on are online, but they have not yet initialized");
-        logger.info(LogMarker.PERSIST_ADVISOR, LocalizedMessage.create(LocalizedStrings.BucketPersistenceAdvisor_WAITING_FOR_LATEST_MEMBER, 
-            new Object[] {proxyBucket.getPartitionedRegion().getFullPath(), proxyBucket.getBucketId(), TransformUtils.persistentMemberIdToLogEntryTransformer.transform(getPersistentID()),
+        logger.info(LogMarker.PERSIST_ADVISOR, LocalizedMessage.create(
+            LocalizedStrings.BucketPersistenceAdvisor_WAITING_FOR_LATEST_MEMBER,
+            new Object[] {proxyBucket.getPartitionedRegion().getFullPath(),
+                proxyBucket.getBucketId(),
+                TransformUtils.persistentMemberIdToLogEntryTransformer.transform(getPersistentID()),
-    if(recovering) {
+    if (recovering) {
-      //We allow regions with persistent colocated children to exceed redundancy
-      //so that we can create the child bucket. Otherwise, we need to check
-      //that redundancy has not already been met now that we've got the dlock
-      //the delock.
-      if(!proxyBucket.hasPersistentChildRegion() 
+      // We allow regions with persistent colocated children to exceed redundancy
+      // so that we can create the child bucket. Otherwise, we need to check
+      // that redundancy has not already been met now that we've got the dlock
+      // the delock.
+      if (!proxyBucket.hasPersistentChildRegion()
-          logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: After reacquiring dlock, we detected that redundancy is already satisfied",
+          logger.debug(LogMarker.PERSIST_ADVISOR,
+              "{}-{}: After reacquiring dlock, we detected that redundancy is already satisfied",
-        //Remove the persistent data for this bucket, since
-        //redundancy is already satisfied.
+        // Remove the persistent data for this bucket, since
+        // redundancy is already satisfied.
-  
+
-    if(recovering) {
+    if (recovering) {
-      //don't update the membership view, we already updated it during recovery.
+      // don't update the membership view, we already updated it during recovery.
-   * Wait for there to be initialized copies of this bucket. Get
-   * the latest membership view from those copies.
+   * Wait for there to be initialized copies of this bucket. Get the latest membership view from
+   * those copies.
-      while(!isClosed) {
+      while (!isClosed) {
-        //Look for any online copies of the bucket.
-        //If there are any, get a membership view from them.
-        Map<InternalDistributedMember, PersistentMemberID> onlineMembers = advisor.adviseInitializedPersistentMembers();
-        if(onlineMembers != null) {
-          if(updateMembershipView(onlineMembers.keySet())) {
+        // Look for any online copies of the bucket.
+        // If there are any, get a membership view from them.
+        Map<InternalDistributedMember, PersistentMemberID> onlineMembers =
+            advisor.adviseInitializedPersistentMembers();
+        if (onlineMembers != null) {
+          if (updateMembershipView(onlineMembers.keySet())) {
-        
-        Set<InternalDistributedMember> postRecoveryMembers = ((BucketAdvisor)advisor).adviseRecoveredFromDisk();
-        if(postRecoveryMembers != null) {
-          if(updateMembershipView(postRecoveryMembers)) {
+
+        Set<InternalDistributedMember> postRecoveryMembers =
+            ((BucketAdvisor) advisor).adviseRecoveredFromDisk();
+        if (postRecoveryMembers != null) {
+          if (updateMembershipView(postRecoveryMembers)) {
-        
+
-        
-        if(!membersToWaitFor.isEmpty()) {
+
+        if (!membersToWaitFor.isEmpty()) {
-      if(interrupted) {
+      if (interrupted) {
-  
+
-    for(InternalDistributedMember target: targets) {
+    for (InternalDistributedMember target : targets) {
-        //The member left?
+        // The member left?
-  
+
-  
+
-    //We don't actually need to get a dlock here for PRs, we're already
-    //holding the bucket lock when we create a bucket region
+    // We don't actually need to get a dlock here for PRs, we're already
+    // holding the bucket lock when we create a bucket region
-  
+
-    //We don't actually need to get a dlock here for PRs, we're already
-    //holding the bucket lock when we create a bucket region
+    // We don't actually need to get a dlock here for PRs, we're already
+    // holding the bucket lock when we create a bucket region
-  
-  
+
+
-    if(recovering) {
+    if (recovering) {
-  
+
-    if(id == null) {
+    if (id == null) {
-      id = new PersistentMemberID(id.diskStoreId, id.host, id.directory, this.proxyBucket
-          .getPartitionedRegion().getBirthTime(), version++);
+      id = new PersistentMemberID(id.diskStoreId, id.host, id.directory,
+          this.proxyBucket.getPartitionedRegion().getBirthTime(), version++);
-    private Set<PersistentMemberID> removedMembers = Collections.synchronizedSet(new HashSet<PersistentMemberID>());
+    private Set<PersistentMemberID> removedMembers =
+        Collections.synchronizedSet(new HashSet<PersistentMemberID>());
-    
+
-    } 
+    }
-  
+
-    
+
-    
+
-    
+
-   * Wait for this bucket to be recovered from disk, at least to the point
-   * where it starts doing a GII.
+   * Wait for this bucket to be recovered from disk, at least to the point where it starts doing a
+   * GII.
-   * This method will throw an exception if the recovery thread encountered
-   * an exception.
+   * This method will throw an exception if the recovery thread encountered an exception.
-    while(true) {
+    while (true) {
-    
-    if(interupted) {
+
+    if (interupted) {
-    
-    if(recoveryException != null) {
+
+    if (recoveryException != null) {
-     
+
-  
-  
+
+
-   * Overridden to fix bug 41336. We defer initialization of
-   * this member until after the atomic bucket creation phase is over.
+   * Overridden to fix bug 41336. We defer initialization of this member until after the atomic
+   * bucket creation phase is over.
-    if(atomicCreation) {
+    if (atomicCreation) {
-        logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: {} Deferring setInitializing until the EndBucketCreation phase for {}",
+        logger.debug(LogMarker.PERSIST_ADVISOR,
+            "{}-{}: {} Deferring setInitializing until the EndBucketCreation phase for {}",
-   * Overridden to fix bug 41336. We defer initialization of
-   * this member until after the atomic bucket creation phase is over.
+   * Overridden to fix bug 41336. We defer initialization of this member until after the atomic
+   * bucket creation phase is over.
-    //This is slightly confusing. If we're currently in the middle of an atomic
-    //creation, we will do nothing right now. Later, when endBucketCreation
-    //is called, we will pass the "wasAtomicCreation" flag down to the super
-    //class to ensure that it knows its coming online as part of an atomic creation.
-    if(this.atomicCreation) {
+    // This is slightly confusing. If we're currently in the middle of an atomic
+    // creation, we will do nothing right now. Later, when endBucketCreation
+    // is called, we will pass the "wasAtomicCreation" flag down to the super
+    // class to ensure that it knows its coming online as part of an atomic creation.
+    if (this.atomicCreation) {
-        logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: {} Deferring setOnline until the EndBucketCreation phase for {}",
+        logger.debug(LogMarker.PERSIST_ADVISOR,
+            "{}-{}: {} Deferring setOnline until the EndBucketCreation phase for {}",
-  /** Finish the atomic creation of this bucket on multiple members
-   * This method is called with the proxy bucket synchronized. 
+  /**
+   * Finish the atomic creation of this bucket on multiple members This method is called with the
+   * proxy bucket synchronized.
-    synchronized(lock) {
-      if(!atomicCreation) {
+    synchronized (lock) {
+      if (!atomicCreation) {
-          logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: {} In endBucketCreation - already online, skipping (possible concurrent endBucketCreation)",
+          logger.debug(LogMarker.PERSIST_ADVISOR,
+              "{}-{}: {} In endBucketCreation - already online, skipping (possible concurrent endBucketCreation)",
-        logger.debug(LogMarker.PERSIST_ADVISOR, "{}-{}: {} In endBucketCreation - now persisting the id {}",
-            shortDiskStoreId(), regionPath, regionPath, newId);
+        logger.debug(LogMarker.PERSIST_ADVISOR,
+            "{}-{}: {} In endBucketCreation - now persisting the id {}", shortDiskStoreId(),
+            regionPath, regionPath, newId);
-    synchronized(lock) {
+    synchronized (lock) {
-  
+
-    PartitionedRegion colocatedRegion = ColocationHelper
-        .getColocatedRegion(proxyBucket.getPartitionedRegion());
-    if(colocatedRegion == null) {
+    PartitionedRegion colocatedRegion =
+        ColocationHelper.getColocatedRegion(proxyBucket.getPartitionedRegion());
+    if (colocatedRegion == null) {
-    ProxyBucketRegion colocatedProxyBucket = colocatedRegion.getRegionAdvisor()
-        .getProxyBucketArray()[proxyBucket.getBucketId()];
+    ProxyBucketRegion colocatedProxyBucket =
+        colocatedRegion.getRegionAdvisor().getProxyBucketArray()[proxyBucket.getBucketId()];

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66
Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
-  /** 
+
+  /**
-  public PooledExecutorWithDMStats(SynchronousQueue<Runnable> q, int maxPoolSize, PoolStatHelper stats, ThreadFactory tf, int msTimeout, RejectedExecutionHandler reh) {
-    super(getCorePoolSize(maxPoolSize), maxPoolSize,
-          msTimeout, TimeUnit.MILLISECONDS,
-          q, tf, reh);
-//     if (getCorePoolSize() != 0 && getCorePoolSize() == getMaximumPoolSize()) {
-//       allowCoreThreadTimeOut(true); // deadcoded for 1.5
-//     }
+  public PooledExecutorWithDMStats(SynchronousQueue<Runnable> q, int maxPoolSize,
+      PoolStatHelper stats, ThreadFactory tf, int msTimeout, RejectedExecutionHandler reh) {
+    super(getCorePoolSize(maxPoolSize), maxPoolSize, msTimeout, TimeUnit.MILLISECONDS, q, tf, reh);
+    // if (getCorePoolSize() != 0 && getCorePoolSize() == getMaximumPoolSize()) {
+    // allowCoreThreadTimeOut(true); // deadcoded for 1.5
+    // }
-   * Used to buffer up tasks that would be have been rejected.
-   * Only used (i.e. non-null) if constructor queue is not a SynchronousQueue.
+   * Used to buffer up tasks that would be have been rejected. Only used (i.e. non-null) if
+   * constructor queue is not a SynchronousQueue.
-   * Used to consume items off the bufferQueue and put them into the pools
-   * synchronous queue.
-   * Only used (i.e. non-null) if constructor queue is not a SynchronousQueue.
+   * Used to consume items off the bufferQueue and put them into the pools synchronous queue. Only
+   * used (i.e. non-null) if constructor queue is not a SynchronousQueue.
-  
+
-      return new SynchronousQueue/*NoSpin*/<Runnable>();
+      return new SynchronousQueue/* NoSpin */<Runnable>();
-      //return new BlockHandler();
+      // return new BlockHandler();
-  
-  /** 
-   * Create a new pool that uses the supplied Channel for queuing, and
-   * with all default parameter settings except for pool size.
+
+  /**
+   * Create a new pool that uses the supplied Channel for queuing, and with all default parameter
+   * settings except for pool size.
-  public PooledExecutorWithDMStats(BlockingQueue<Runnable> q, int maxPoolSize, PoolStatHelper stats, ThreadFactory tf, int msTimeout) {
+  public PooledExecutorWithDMStats(BlockingQueue<Runnable> q, int maxPoolSize, PoolStatHelper stats,
+      ThreadFactory tf, int msTimeout) {
-          public void run() {
-            try {
-              for (;;) {
-                SystemFailure.checkFailure();
-                Runnable job = takeQueue.take();
-                putQueue.put(job);
-              }
+        public void run() {
+          try {
+            for (;;) {
+              SystemFailure.checkFailure();
+              Runnable job = takeQueue.take();
+              putQueue.put(job);
-            catch (InterruptedException ie) {
-              Thread.currentThread().interrupt();
-              // this thread is being shutdown so just return;
-              return;
-            }
+          } catch (InterruptedException ie) {
+            Thread.currentThread().interrupt();
+            // this thread is being shutdown so just return;
+            return;
-        };
+        }
+      };
-    }
-    finally {
+    } finally {
-  
+
-  
+
-  public PooledExecutorWithDMStats(BlockingQueue<Runnable> q, int poolSize, PoolStatHelper stats, ThreadFactory tf) {
-  /**
-   * How long an idle thread will wait, in milliseconds, before it is removed
-   * from its thread pool. Default is (30000 * 60) ms (30 minutes).
-   * It is not static so it can be set at runtime and pick up different values.
-   */
-    this(q, poolSize, stats, tf, Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "IDLE_THREAD_TIMEOUT", 30000 * 60).intValue());
+  public PooledExecutorWithDMStats(BlockingQueue<Runnable> q, int poolSize, PoolStatHelper stats,
+      ThreadFactory tf) {
+    /**
+     * How long an idle thread will wait, in milliseconds, before it is removed from its thread
+     * pool. Default is (30000 * 60) ms (30 minutes). It is not static so it can be set at runtime
+     * and pick up different values.
+     */
+    this(q, poolSize, stats, tf,
+        Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "IDLE_THREAD_TIMEOUT", 30000 * 60)
+            .intValue());
-    this(q, poolSize, null/*no stats*/, tf);
+    this(q, poolSize, null/* no stats */, tf);
-  
+
-//       int result = Runtime.getRuntime().availableProcessors();
-//       if (result < 2) {
-//         result = 2;
-//       }
-//       if (result > maxSize) {
-//         result = maxSize;
-//       }
-//       return result;
+      // int result = Runtime.getRuntime().availableProcessors();
+      // if (result < 2) {
+      // result = 2;
+      // }
+      // if (result > maxSize) {
+      // result = maxSize;
+      // }
+      // return result;
-  
+
-        throw new RejectedExecutionException(LocalizedStrings.PooledExecutorWithDMStats_EXECUTOR_HAS_BEEN_SHUTDOWN.toLocalizedString());
+        throw new RejectedExecutionException(
+            LocalizedStrings.PooledExecutorWithDMStats_EXECUTOR_HAS_BEEN_SHUTDOWN
+                .toLocalizedString());
-          RejectedExecutionException e = new RejectedExecutionException(LocalizedStrings.PooledExecutorWithDMStats_INTERRUPTED.toLocalizedString());
+          RejectedExecutionException e = new RejectedExecutionException(
+              LocalizedStrings.PooledExecutorWithDMStats_INTERRUPTED.toLocalizedString());
-   * This guy fronts a synchronous queue, that is owned by the parent
-   * ThreadPoolExecutor, with a the client supplied BlockingQueue that
-   * supports storage (the buffer queue).
-   * A dedicated thread is used to consume off the buffer queue and put
-   * into the synchronous queue.
+   * This guy fronts a synchronous queue, that is owned by the parent ThreadPoolExecutor, with a the
+   * client supplied BlockingQueue that supports storage (the buffer queue). A dedicated thread is
+   * used to consume off the buffer queue and put into the synchronous queue.
-        throw new RejectedExecutionException(LocalizedStrings.PooledExecutorWithDMStats_EXECUTOR_HAS_BEEN_SHUTDOWN.toLocalizedString());
+        throw new RejectedExecutionException(
+            LocalizedStrings.PooledExecutorWithDMStats_EXECUTOR_HAS_BEEN_SHUTDOWN
+                .toLocalizedString());
-          PooledExecutorWithDMStats pool = (PooledExecutorWithDMStats)executor;
+          PooledExecutorWithDMStats pool = (PooledExecutorWithDMStats) executor;
-          RejectedExecutionException e = new RejectedExecutionException(LocalizedStrings.PooledExecutorWithDMStats_INTERRUPTED.toLocalizedString());
+          RejectedExecutionException e = new RejectedExecutionException(
+              LocalizedStrings.PooledExecutorWithDMStats_INTERRUPTED.toLocalizedString());

UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 UPD66 DEL66 DEL66 DEL66
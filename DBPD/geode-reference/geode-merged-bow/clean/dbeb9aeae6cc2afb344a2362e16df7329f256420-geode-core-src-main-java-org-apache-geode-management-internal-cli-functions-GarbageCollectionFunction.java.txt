Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- *  
+ * 
- public static final String ID = GarbageCollectionFunction.class.getName();
-  
+  public static final String ID = GarbageCollectionFunction.class.getName();
+
-    try{     
-        Cache cache = CacheFactory.getAnyInstance();        
-        DistributedMember member = cache.getDistributedSystem().getDistributedMember();
-        long freeMemoeryBeforeGC = Runtime.getRuntime().freeMemory();
-        long totalMemoryBeforeGC = Runtime.getRuntime().totalMemory();
-        long timeBeforeGC = System.currentTimeMillis();
-        Runtime.getRuntime().gc(); 
-       
-        long freeMemoeryAfterGC = Runtime.getRuntime().freeMemory();
-        long totalMemoryAfterGC = Runtime.getRuntime().totalMemory();
-        long timeAfterGC = System.currentTimeMillis() ;
-        
-        long megaBytes = 131072;
-        resultMap = new HashMap<String,String>();
-        resultMap.put("MemberId", member.getId());
-        resultMap.put("HeapSizeBeforeGC", String.valueOf((totalMemoryBeforeGC - freeMemoeryBeforeGC) / megaBytes));
-        resultMap.put("HeapSizeAfterGC",String.valueOf( (totalMemoryAfterGC - freeMemoeryAfterGC)/megaBytes));
-        resultMap.put("TimeSpentInGC", String.valueOf(timeAfterGC - timeBeforeGC));      
-    }catch(Exception ex){
-      str1.append("Exception in GC:"+ ex.getMessage() + CliUtil.stackTraceAsString((Throwable)ex));
-      context.getResultSender().lastResult(str1.toString());    
-    }        
-    context.getResultSender().lastResult(resultMap);    
+    try {
+      Cache cache = CacheFactory.getAnyInstance();
+      DistributedMember member = cache.getDistributedSystem().getDistributedMember();
+      long freeMemoeryBeforeGC = Runtime.getRuntime().freeMemory();
+      long totalMemoryBeforeGC = Runtime.getRuntime().totalMemory();
+      long timeBeforeGC = System.currentTimeMillis();
+      Runtime.getRuntime().gc();
+
+      long freeMemoeryAfterGC = Runtime.getRuntime().freeMemory();
+      long totalMemoryAfterGC = Runtime.getRuntime().totalMemory();
+      long timeAfterGC = System.currentTimeMillis();
+
+      long megaBytes = 131072;
+      resultMap = new HashMap<String, String>();
+      resultMap.put("MemberId", member.getId());
+      resultMap.put("HeapSizeBeforeGC",
+          String.valueOf((totalMemoryBeforeGC - freeMemoeryBeforeGC) / megaBytes));
+      resultMap.put("HeapSizeAfterGC",
+          String.valueOf((totalMemoryAfterGC - freeMemoeryAfterGC) / megaBytes));
+      resultMap.put("TimeSpentInGC", String.valueOf(timeAfterGC - timeBeforeGC));
+    } catch (Exception ex) {
+      str1.append(
+          "Exception in GC:" + ex.getMessage() + CliUtil.stackTraceAsString((Throwable) ex));
+      context.getResultSender().lastResult(str1.toString());
+    }
+    context.getResultSender().lastResult(resultMap);
+
-    //no need of optimization since read-only.
+    // no need of optimization since read-only.


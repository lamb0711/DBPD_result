GEODE-6607: Moving client registration queue to CacheClientNotifier

To avoid client subscription data inconsistencies, we need to ensure
that we minimize the chance that an event is processed while a client is
registering but before it has fully registered.  There are two major
phases in registration - one is to request filter info from a peer
already hosting the queue for the client, and the other is doing a GII
of the queue from a peer.  If an event which a client would be
interested in is processed concurrently during registration, but before
the filter info has been fully received and processed, the event will be
missed by the client.  To reduce this window, we will start queueing
events for the registering client as soon as possible (deserialization
of the client proxy membership ID).  After registration is complete, we
drain the queued events and put them into the clients subscription
queue.

To make this code unit testable, it was necessary to extract the logic
reading data off the socket/deserializing that data into a separate
class which can be injected, the ClientRegistrationMetadata class.  This
allows us to mock a ClientRegistrationMetadata without actually doing any IO.
The CacheClientNotifier could be futher broken up to allow for even more
unit testability, but this was a first step in the right direction.

Co-authored-by: Ryan McMahon <rmcmahon@pivotal.io>
Co-authored-by: Murtuza Boxwala <mboxwala@pivotal.io>
Co-authored-by: Ernie Burghardt <eburghardt@pivotal.io>

-import java.util.concurrent.ConcurrentLinkedQueue;
-  /** To queue the events arriving during message dispatcher initialization */
-  private volatile ConcurrentLinkedQueue<Conflatable> queuedEvents =
-      new ConcurrentLinkedQueue<Conflatable>();
-
-  private final Object queuedEventsSync = new Object();
-
-  private volatile boolean messageDispatcherInit = false;
-
-      // If dispatcher is getting initialized, add the event to temporary queue.
-      if (this.messageDispatcherInit) {
-        synchronized (this.queuedEventsSync) {
-          if (this.messageDispatcherInit) { // Check to see value did not changed while getting the
-                                            // synchronize lock.
-            if (logger.isDebugEnabled()) {
-              logger.debug(
-                  "Message dispatcher for proxy {} is getting initialized. Adding message to the queuedEvents.",
-                  this);
-            }
-
-            if (conflatable instanceof HAEventWrapper) {
-              HAEventWrapper haEventWrapper = (HAEventWrapper) conflatable;
-              haEventWrapper.incrementPutInProgressCounter();
-              if (logger.isDebugEnabled()) {
-                logger.debug(
-                    "Incremented PutInProgressCounter on HAEventWrapper with Event ID hash code: "
-                        + haEventWrapper.hashCode()
-                        + "; System ID hash code: "
-                        + System.identityHashCode(haEventWrapper) + "; Wrapper details: "
-                        + haEventWrapper);
-              }
-            }
-
-            this.queuedEvents.add(conflatable);
-
-            return;
-          }
-        }
-      }
-
-    this.messageDispatcherInit = true; // Initialization process.
-
-      // Fix for 41375 - drain as many of the queued events
-      // as we can without synchronization.
-      if (logger.isDebugEnabled()) {
-        logger.debug("{} draining {} events from init queue into intialized queue", this,
-            this.queuedEvents.size());
-      }
-
-      drainQueuedEvents(false);
-
-      // Now finish emptying the queue with synchronization to make
-      // sure we don't miss any events.
-      synchronized (this.queuedEventsSync) {
-        drainQueuedEvents(true);
-
-        this.messageDispatcherInit = false; // Done initialization.
-      }
-    } finally {
-      if (this.messageDispatcherInit) { // If its not successfully completed.
-        this._statistics.close();
-      }
+    } catch (final Exception ex) {
+      this._statistics.close();
+      throw ex;
-  private void drainQueuedEvents(boolean withSynchronization) {
-    Conflatable nextEvent;
-    while ((nextEvent = queuedEvents.poll()) != null) {
-      if (logger.isDebugEnabled()) {
-        if (nextEvent instanceof HAEventWrapper) {
-          logger.debug(
-              "Draining events queued during message dispatcher initialization "
-                  + (withSynchronization ? "with" : "without")
-                  + " synchronization. Event ID hash code: "
-                  + nextEvent.hashCode()
-                  + "; System ID hash code: " + System.identityHashCode(nextEvent)
-                  + "; Wrapper details: " + nextEvent);
-        }
-      }
-
-      this._messageDispatcher.enqueueMessage(nextEvent);
-
-      if (nextEvent instanceof HAEventWrapper) {
-        ((HAEventWrapper) nextEvent).decrementPutInProgressCounter();
-      }
-    }
-  }
-

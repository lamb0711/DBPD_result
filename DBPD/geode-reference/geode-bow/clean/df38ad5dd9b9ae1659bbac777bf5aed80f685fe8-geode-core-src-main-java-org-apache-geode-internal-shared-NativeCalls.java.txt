GEODE-7729: Upgrades JNA to 5.5.0 (#4624)

* GEODE-7729: Upgrades JNA to 5.5.0

* Update Windows native APIs to use JNA Platform library to fix segfault.

* GEODE-7729: Cleanup comments, generics and other warnings.

* Deletes unused code.

-import java.io.FileDescriptor;
-import java.io.FileInputStream;
-import java.io.InputStream;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.net.Socket;
-import java.net.SocketException;
-import java.net.SocketImpl;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-   * Get the native kernel descriptor given the java Socket. This is a horribly implementation
-   * dependent code checking various cases to get to the underlying kernel socket descriptor but
-   * works for the JDK's we support or intend to support directly or indirectly (e.g. GCJ for ODBC
-   * clients).
-   *
-   * @param sock the java socket
-   * @param sockStream the {@link InputStream} of the java socket, if available
-   *
-   * @throws UnsupportedOperationException if the kernel descriptor could not be extracted
-   */
-  protected int getSocketKernelDescriptor(Socket sock, InputStream sockStream)
-      throws UnsupportedOperationException {
-    Method m;
-    Field f;
-    Object obj;
-    FileDescriptor fd = null;
-    // in some cases (for SSL) the Socket can be a wrapper one
-    try {
-      f = getAnyField(sock.getClass(), "self");
-      if (f != null) {
-        f.setAccessible(true);
-        final Object self = f.get(sock);
-        if (self instanceof Socket) {
-          sock = (Socket) self;
-          sockStream = sock.getInputStream();
-        }
-      }
-    } catch (NoSuchFieldException fe) {
-      // ignore if there is no such field
-    } catch (RuntimeException re) {
-      throw re;
-    } catch (Exception ex) {
-      throw new UnsupportedOperationException(ex);
-    }
-
-    // first try using FileInputStream
-    if (sockStream instanceof FileInputStream) {
-      try {
-        fd = ((FileInputStream) sockStream).getFD();
-      } catch (Exception e) {
-        // go the fallback route
-      }
-    }
-    // else fallback to SocketImpl route
-    try {
-      if (fd == null) {
-        try {
-          // package private Socket.getImpl() to get SocketImpl
-          m = getAnyMethod(sock.getClass(), "getImpl");
-        } catch (Exception ex) {
-          try {
-            m = getAnyMethod(sock.getClass(), "getPlainSocketImpl");
-          } catch (Exception e) {
-            // try forcing the InputStream route
-            m = null;
-            if (sockStream == null) {
-              sockStream = sock.getInputStream();
-              if (sockStream instanceof FileInputStream) {
-                fd = ((FileInputStream) sockStream).getFD();
-              }
-            } else {
-              throw e;
-            }
-          }
-        }
-        if (m != null) {
-          m.setAccessible(true);
-          final SocketImpl sockImpl = (SocketImpl) m.invoke(sock);
-          if (sockImpl != null) {
-            try {
-              m = getAnyMethod(sockImpl.getClass(), "getFileDescriptor");
-              if (m != null) {
-                m.setAccessible(true);
-                fd = (FileDescriptor) m.invoke(sockImpl);
-              }
-            } catch (NoSuchMethodException nme) {
-              // go to field reflection route
-            }
-          }
-        }
-      }
-      if (fd != null) {
-        // get the kernel descriptor using reflection
-        f = getAnyField(fd.getClass(), "fd");
-        if (f != null) {
-          f.setAccessible(true);
-          obj = f.get(fd);
-          if (obj instanceof Integer) {
-            return ((Integer) obj).intValue();
-          }
-        }
-      }
-      throw new UnsupportedOperationException();
-    } catch (SecurityException se) {
-      throw new UnsupportedOperationException(se);
-    } catch (RuntimeException re) {
-      throw re;
-    } catch (Exception ex) {
-      throw new UnsupportedOperationException(ex);
-    }
-  }
-
-  protected static Method getAnyMethod(Class<?> c, String name, Class<?>... parameterTypes)
-      throws NoSuchMethodException, SecurityException {
-    NoSuchMethodException firstEx = null;
-    for (;;) {
-      try {
-        return c.getDeclaredMethod(name, parameterTypes);
-      } catch (NoSuchMethodException nsme) {
-        if (firstEx == null) {
-          firstEx = nsme;
-        }
-        if ((c = c.getSuperclass()) == null) {
-          throw firstEx;
-        }
-        // else continue searching in superClass
-      }
-    }
-  }
-
-  protected static Field getAnyField(Class<?> c, String name)
-      throws NoSuchFieldException, SecurityException {
-    NoSuchFieldException firstEx = null;
-    for (;;) {
-      try {
-        return c.getDeclaredField(name);
-      } catch (NoSuchFieldException nsfe) {
-        if (firstEx == null) {
-          firstEx = nsfe;
-        }
-        if ((c = c.getSuperclass()) == null) {
-          throw firstEx;
-        }
-        // else continue searching in superClass
-      }
-    }
-  }
-
-  protected String getUnsupportedSocketOptionMessage(TCPSocketOptions opt) {
-    return "setSocketOption(): socket option " + opt + " not supported by current platform "
-        + getOSType();
-  }
-
-  /**
-   * Get the {@link OSType} of current system.
-   */
-  public abstract OSType getOSType();
-
-  /**
-    RandomAccessFile raf = new RandomAccessFile(path, "rw");
-    try {
+    try (RandomAccessFile raf = new RandomAccessFile(path, "rw")) {
-    } finally {
-      raf.close();
-   * Set given extended socket options on a Java {@link Socket}.
-   *
-   * @throws UnsupportedOperationException if the native API to set the option could not be found or
-   *         invoked
-   *
-   * @return the unsupported {@link TCPSocketOptions} for the current platform and the underlying
-   *         exception
-   *
-   * @see TCPSocketOptions
-   */
-  public abstract Map<TCPSocketOptions, Throwable> setSocketOptions(Socket sock,
-      InputStream sockStream, Map<TCPSocketOptions, Object> optValueMap)
-      throws UnsupportedOperationException;
-
-  // IPPROTO_TCP is used by setsockopt to denote a TCP option
-  protected static final int OPT_IPPROTO_TCP = 6;
-  // indicates an unsupported TCPSocketOptions enum
-  protected static final int UNSUPPORTED_OPTION = Integer.MIN_VALUE;
-
-  /**
-   * A generic implementation of {@link #setSocketOptions} for POSIX like systems that requires the
-   * child classes to implement a few platform specific methods.
-   */
-  protected Map<TCPSocketOptions, Throwable> setGenericSocketOptions(Socket sock,
-      InputStream sockStream, Map<TCPSocketOptions, Object> optValueMap)
-      throws UnsupportedOperationException {
-    final Set<Map.Entry<TCPSocketOptions, Object>> optValueEntries = optValueMap.entrySet();
-    for (Map.Entry<TCPSocketOptions, Object> e : optValueEntries) {
-      TCPSocketOptions opt = e.getKey();
-      Object value = e.getValue();
-      // just to check for unsupported option
-      getPlatformOption(opt);
-      // all options currently require an integer argument
-      if (value == null || !(value instanceof Integer)) {
-        throw new IllegalArgumentException("bad argument type "
-            + (value != null ? value.getClass().getName() : "NULL") + " for " + opt);
-      }
-    }
-
-    Map<TCPSocketOptions, Throwable> failures = new HashMap<TCPSocketOptions, Throwable>(4);
-    final int sockfd = getSocketKernelDescriptor(sock, sockStream);
-    for (Map.Entry<TCPSocketOptions, Object> e : optValueEntries) {
-      TCPSocketOptions opt = e.getKey();
-      Object value = e.getValue();
-      final int optName = getPlatformOption(opt);
-      if (optName == UNSUPPORTED_OPTION) {
-        failures.put(opt,
-            new UnsupportedOperationException(getUnsupportedSocketOptionMessage(opt)));
-        continue;
-      }
-      final int optSize = Integer.SIZE / Byte.SIZE;
-      try {
-        if (setPlatformSocketOption(sockfd, OPT_IPPROTO_TCP, optName, opt, (Integer) value,
-            optSize) != 0) {
-          failures.put(opt,
-              new SocketException(getOSType() + ": error setting option " + opt + " to " + value));
-        }
-      } catch (NativeErrorException ne) {
-        // check if the error indicates that option is not supported
-        if (isNoProtocolOptionCode(ne.getErrorCode())) {
-          failures.put(opt,
-              new UnsupportedOperationException(getUnsupportedSocketOptionMessage(opt), ne));
-        } else {
-          final SocketException se =
-              new SocketException(getOSType() + ": failed to set " + opt + " to " + value);
-          se.initCause(ne);
-          failures.put(opt, se);
-        }
-      }
-    }
-    return failures.size() > 0 ? failures : null;
-  }
-
-  protected int getPlatformOption(TCPSocketOptions opt) throws UnsupportedOperationException {
-    // no generic POSIX specification for this
-    throw new UnsupportedOperationException(
-        "setSocketOption not supported for generic POSIX platform");
-  }
-
-  protected int setPlatformSocketOption(int sockfd, int level, int optName, TCPSocketOptions opt,
-      Integer optVal, int optSize) throws UnsupportedOperationException, NativeErrorException {
-    // no generic POSIX specification for this
-    throw new UnsupportedOperationException(
-        "setSocketOption not supported for generic POSIX platform");
-  }
-
-  protected boolean isNoProtocolOptionCode(int errno) throws UnsupportedOperationException {
-    // no generic POSIX specification for this
-    throw new UnsupportedOperationException(
-        "setSocketOption not supported for generic POSIX platform");
-  }
-
-  /**
-   * whether o/s supports high resolution clock or equivalent perf counter.
-   *
-   * @return true if implemented, otherwise false.
-   */
-  public boolean isNativeTimerEnabled() {
-    return false;
-  }
-
-  /**
-   * This is fall back for jni based library implementation of NanoTimer which is more efficient
-   * than current impl through jna.
-   *
-   * Linux impls create temporary timespec object and marshals that for invoking native api.
-   * Shouldn't be used if to be called too many times, instead jni implementation is more desirable.
-   *
-   * @return nanosecond precision performance counter.
-   */
-  public long nanoTime(int clock_id) {
-    return System.nanoTime();
-  }
-
-  public long clockResolution(int clock_id) {
-    return 0;
-  }
-
-  public boolean isTTY() {
-    return false;
-  }
-
-  /**
-    private static final boolean isWin;
-
-    static {
-      isWin = System.getProperty("os.name").indexOf("Windows") >= 0;
-    }
-
-    /**
-     * @see NativeCalls#getOSType()
-     */
-    @Override
-    public OSType getOSType() {
-      return isWin ? OSType.WIN : OSType.GENERIC;
-    }
-
-    /**
-     * @see NativeCalls#getEnvironment(String)
-     */
-    /**
-     * @see NativeCalls#getProcessId()
-     */
-    /**
-     * @see NativeCalls#isProcessActive(int)
-     */
-    /**
-     * @see NativeCalls#killProcess(int)
-     */
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Map<TCPSocketOptions, Throwable> setSocketOptions(Socket sock, InputStream sockStream,
-        Map<TCPSocketOptions, Object> optValueMap) throws UnsupportedOperationException {
-      throw new UnsupportedOperationException("setting native socket options "
-          + optValueMap.keySet() + " not possible in generic implementation");
-    }

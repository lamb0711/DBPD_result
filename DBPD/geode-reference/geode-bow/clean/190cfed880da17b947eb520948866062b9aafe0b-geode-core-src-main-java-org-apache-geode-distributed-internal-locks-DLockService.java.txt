GEODE-3314 - Refactoring of DLockService to improve developer QoL. This now closes #683

* Write characterization tests for DLockService.
* Remove debugging code.
* Remove dead code.
* Remove comments.
* Extract the local lock granting into a separate function.

Between the characterization tests we've written and the existing DUnit
tests, the coverage should be fairly adequate.

Signed-off-by: Hitesh Khamesra <hkameshra@pivotal.io>
Signed-off-by: Galen O'Sullivan <gosullivan@pivotal.io>

-import org.apache.geode.InternalGemFireError;
-  public static final boolean DEBUG_DISALLOW_NOT_HOLDER = Boolean
-      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.disallowNotHolder");
-
-  public static final boolean DEBUG_LOCK_REQUEST_LOOP = Boolean
-      .getBoolean(DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.disallowLockRequestLoop");
-
-  public static final int DEBUG_LOCK_REQUEST_LOOP_COUNT = Integer
-      .getInteger(
-          DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.disallowLockRequestLoopCount", 20)
-      .intValue();
-
-  public static final boolean DEBUG_ENFORCE_SAFE_EXIT =
-      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "DLockService.debug.enforceSafeExit");
-
-    final boolean isDebugEnabled_DLS = logger.isTraceEnabled(LogMarker.DLS);
-
-    boolean safeExit = true;
-    try { // try-block for abnormalExit and safeExit
-
+    try {
-      if (isDebugEnabled_DLS) {
-        logger.trace(LogMarker.DLS, "{}, name: {} - entering lock()", this, name);
-      }
+      logger.trace(LogMarker.DLS, "{}, name: {} - entering lock()", this, name);
-        int loopCount = 0;
-          if (DEBUG_LOCK_REQUEST_LOOP) {
-            loopCount++;
-            if (loopCount > DEBUG_LOCK_REQUEST_LOOP_COUNT) {
-              Integer count = Integer.valueOf(DEBUG_LOCK_REQUEST_LOOP_COUNT);
-              String s =
-                  LocalizedStrings.DLockService_DEBUG_LOCKINTERRUPTIBLY_HAS_GONE_HOT_AND_LOOPED_0_TIMES
-                      .toLocalizedString(count);
-
-              InternalGemFireError e = new InternalGemFireError(s);
-              logger.error(LogMarker.DLS,
-                  LocalizedMessage.create(
-                      LocalizedStrings.DLockService_DEBUG_LOCKINTERRUPTIBLY_HAS_GONE_HOT_AND_LOOPED_0_TIMES,
-                      count),
-                  e);
-              throw e;
-            }
-            /*
-             * if (loopCount > 1) { Thread.sleep(1000); }
-             */
-          }
-
-              if (isDebugEnabled_DLS) {
-                logger.trace(LogMarker.DLS, "{} , name: {} - lock() is reentrant: {}", this, name,
-                    token);
-              }
+              logger.trace(LogMarker.DLS, "{} , name: {} - lock() is reentrant: {}", this, name,
+                  token);
-              leaseExpireTime = token.getLeaseExpireTime(); // moved here from processor null-check
-                                                            // under gotLock
-          DLockRequestProcessor processor = null;
-
-          // if reentrant w/ infinite lease TODO: remove false to restore this...
-          if (false && reentrant && leaseTimeMillis == Long.MAX_VALUE) {
-            // Optimization:
-            // thread is reentering lock and lease time is infinite so no
-            // need to trouble the poor grantor
-            gotLock = true;
-            // check for race condition...
-            Assert.assertTrue(token.isLeaseHeldByCurrentThread());
+          DLockRequestProcessor processor = createRequestProcessor(theLockGrantorId, name, threadId,
+              startTime, requestLeaseTime, requestWaitTime, reentrant, tryLock, disableAlerts);
+          if (reentrant) {
+            // check for race condition... reentrant expired already...
+            // related to bug 32765, but client-side... see bug 33402
+            synchronized (token) {
+              if (!token.isLeaseHeldByCurrentThread()) {
+                reentrant = false;
+                recursionBefore = -1;
+                token.checkForExpiration();
+              }
+            }
+          } else {
+            // set lockId since this is the first granting (non-reentrant)
+            lockId = processor.getProcessorId();
-          // non-reentrant or reentrant w/ non-infinite lease
-          else {
-            processor = createRequestProcessor(theLockGrantorId, name, threadId, startTime,
-                requestLeaseTime, requestWaitTime, reentrant, tryLock, disableAlerts);
-            if (reentrant) {
-              // check for race condition... reentrant expired already...
-              // related to bug 32765, but client-side... see bug 33402
-              synchronized (token) {
-                if (!token.isLeaseHeldByCurrentThread()) {
-                  reentrant = false;
-                  recursionBefore = -1;
-                  token.checkForExpiration();
-                }
-              }
-            } else {
-              // set lockId since this is the first granting (non-reentrant)
-              lockId = processor.getProcessorId();
-            }
+          gotLock = processor.requestLock(interruptible, lockId); // can throw
+                                                                  // InterruptedException
-            try {
-              safeExit = false;
-              gotLock = processor.requestLock(interruptible, lockId);
-            } catch (InterruptedException e) { // LOST INTERRUPT
-              if (interruptible) {
-                // TODO: BUG 37158: this can cause a stuck lock
-                throw e;
-              } else {
-                interrupted = true;
-                Assert.assertTrue(false,
-                    "Non-interruptible lock is trying to throw InterruptedException");
-              }
-            }
-            if (isDebugEnabled_DLS) {
-              logger.trace(LogMarker.DLS, "Grantor {} replied {}", theLockGrantorId,
-                  processor.getResponseCodeString());
-            }
-          } // else: non-reentrant or reentrant w/ non-infinite lease
+          logger.trace(LogMarker.DLS, "Grantor {} replied {}", theLockGrantorId,
+              processor.getResponseCodeString());
-            // if (processor != null) (cannot be null)
-            { // TODO: can be null after restoring above optimization
-              // non-reentrant lock needs to getLeaseExpireTime
-              leaseExpireTime = processor.getLeaseExpireTime();
-            }
+            leaseExpireTime = processor.getLeaseExpireTime();
-            boolean granted = false;
-            boolean needToReleaseOrphanedGrant = false;
-
-            Assert.assertHoldsLock(this.destroyLock, false);
-            synchronized (this.lockGrantorIdLock) {
-              if (!checkLockGrantorId(theLockGrantorId)) {
-                safeExit = true;
-                // race: grantor changed
-                if (isDebugEnabled_DLS) {
-                  logger.trace(LogMarker.DLS,
-                      "Cannot honor grant from {} because {} is now a grantor.", theLockGrantorId,
-                      this.lockGrantorId);
-                }
-                continue;
-              } else if (isDestroyed()) {
-                // race: dls was destroyed
-                if (isDebugEnabled_DLS) {
-                  logger.trace(LogMarker.DLS,
-                      "Cannot honor grant from {} because this lock service has been destroyed.",
-                      theLockGrantorId);
-                }
-                needToReleaseOrphanedGrant = true;
-              } else {
-                safeExit = true;
-                synchronized (this.tokens) {
-                  checkDestroyed();
-                  Assert.assertTrue(token == basicGetToken(name));
-                  RemoteThread rThread =
-                      new RemoteThread(getDistributionManager().getId(), threadId);
-                  granted = token.grantLock(leaseExpireTime, lockId, recursion, rThread);
-                } // tokens sync
-              }
-            }
-
-            if (needToReleaseOrphanedGrant /* && processor != null */) {
-              processor.getResponse().releaseOrphanedGrant(this.dm);
-              safeExit = true;
+            if (!grantLocalDLockAfterObtainingRemoteLock(name, token, threadId, leaseExpireTime,
+                lockId, theLockGrantorId, processor, recursion)) {
-            if (!granted) {
-              Assert.assertTrue(granted, "Failed to perform client-side granting on " + token
-                  + " which was granted by " + theLockGrantorId);
-            }
-
-            // make sure token is THE instance in the map to avoid race with
-            // freeResources... ok to overwrite a newer instance too since only
-            // one thread will own the lock at a time
-            // synchronized (tokens) { // TODO: verify if this is needed
-            // synchronized (token) {
-            // if (tokens.put(name, token) == null) {
-            // getStats().incTokens(1);
-            // }
-            // }
-            // }
-
-            if (isDebugEnabled_DLS) {
-              logger.trace(LogMarker.DLS, "{}, name: {} - granted lock: {}", this, name, token);
-            }
+            logger.trace(LogMarker.DLS, "{}, name: {} - granted lock: {}", this, name, token);
-          } // gotLock is true
-
-          // grantor replied destroyed (getLock is false)
-          else if (processor.repliedDestroyed()) {
-            safeExit = true;
-            checkDestroyed();
-            // should have thrown LockServiceDestroyedException
+          } else if (processor.repliedDestroyed()) {
+            checkDestroyed(); // throws LockServiceDestroyedException
-          } // grantor replied destroyed
-
-          // grantor replied NOT_GRANTOR or departed (getLock is false)
-          else if (processor.repliedNotGrantor() || processor.hadNoResponse()) {
-            safeExit = true;
+          } else if (processor.repliedNotGrantor() || processor.hadNoResponse()) {
-          } // grantor replied NOT_GRANTOR or departed
-
-          // grantor replied NOT_HOLDER for reentrant lock (getLock is false)
-          else if (processor.repliedNotHolder()) {
-            safeExit = true;
-            if (DEBUG_DISALLOW_NOT_HOLDER) {
-              String s = LocalizedStrings.DLockService_DEBUG_GRANTOR_REPORTS_NOT_HOLDER_FOR_0
-                  .toLocalizedString(token);
-              InternalGemFireError e = new InternalGemFireError(s);
-              logger.error(LogMarker.DLS,
-                  LocalizedMessage.create(
-                      LocalizedStrings.DLockService_DEBUG_GRANTOR_REPORTS_NOT_HOLDER_FOR_0, token),
-                  e);
-              throw e;
-            }
-
+          } else if (processor.repliedNotHolder()) {
-            safeExit = true;
-      } // try-block for end stats, token cleanup, and interrupt check
-
-      // finally-block for end stats, token cleanup, and interrupt check
-      finally {
+          // try-block for end stats, token cleanup, and interrupt check
+      } finally {
-      if (isDebugEnabled_DLS) {
-        logger.trace(LogMarker.DLS, "{}, name: {} - exiting lock() returning {}", this, name,
-            gotLock);
-      }
+      logger.trace(LogMarker.DLS, "{}, name: {} - exiting lock() returning {}", this, name,
+          gotLock);
-    } // try-block for abnormalExit and safeExit
-
-    // finally-block for abnormalExit and safeExit
-    finally {
-      if (isDebugEnabled_DLS) {
-        logger.trace(LogMarker.DLS, "{}, name: {} - exiting lock() without returning value", this,
-            name);
-      }
+    } finally {
+      logger.trace(LogMarker.DLS, "{}, name: {} - exiting lock() without returning value", this,
+          name);
-      if (DEBUG_ENFORCE_SAFE_EXIT) {
-        Assert.assertTrue(safeExit);
+    }
+  }
+
+  private boolean grantLocalDLockAfterObtainingRemoteLock(Object name, DLockToken token,
+      int threadId, long leaseExpireTime, int lockId, LockGrantorId theLockGrantorId,
+      DLockRequestProcessor processor, int recursion) {
+    boolean needToReleaseOrphanedGrant = false;
+
+    Assert.assertHoldsLock(this.destroyLock, false);
+    synchronized (this.lockGrantorIdLock) {
+      if (!checkLockGrantorId(theLockGrantorId)) {
+        // race: grantor changed
+        logger.trace(LogMarker.DLS, "Cannot honor grant from {} because {} is now a grantor.",
+            theLockGrantorId, this.lockGrantorId);
+      } else if (isDestroyed()) {
+        // race: dls was destroyed
+        logger.trace(LogMarker.DLS,
+            "Cannot honor grant from {} because this lock service has been destroyed.",
+            theLockGrantorId);
+        needToReleaseOrphanedGrant = true;
+      } else {
+        synchronized (this.tokens) {
+          checkDestroyed();
+          Assert.assertTrue(token == basicGetToken(name));
+          RemoteThread rThread = new RemoteThread(getDistributionManager().getId(), threadId);
+          token.grantLock(leaseExpireTime, lockId, recursion, rThread);
+          return true;
+        } // tokens sync
+
+    if (needToReleaseOrphanedGrant) {
+      processor.getResponse().releaseOrphanedGrant(this.dm);
+    }
+    return false;
-   * 
+   *
-  Set getLockTokensForRecovery(LockGrantorId newlockGrantorId) {
-    Set heldLockSet = Collections.EMPTY_SET;
+  Set<DLockRemoteToken> getLockTokensForRecovery(LockGrantorId newlockGrantorId) {
+    Set<DLockRemoteToken> heldLockSet = Collections.EMPTY_SET;
-                  heldLockSet = new HashSet();
+                  heldLockSet = new HashSet<>();

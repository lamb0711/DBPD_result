GEODE-5134: pendingCallbacks is never null (#1863)

The tx* method implementations now always expect the pendingCallbacks parameter to not be null.
Also "cb" was renamed to "callback" for clarity.


-      if (AbstractRegionMap.shouldCreateCBEvent(this.owner, !inTokenMode)) {
+      if (AbstractRegionMap.shouldCreateCallbackEvent(this.owner, !inTokenMode)) {
-        EntryEventImpl e = AbstractRegionMap.createCBEvent(this.owner, op, key, null, rmtOrigin,
-            event, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext, txEntryState,
-            versionTag, tailKey);
-        boolean cbEventInPending = false;
-        try {
-          AbstractRegionMap.switchEventOwnerAndOriginRemote(e, txEntryState == null);
-          if (pendingCallbacks == null) {
-            this.owner.invokeTXCallbacks(EnumListenerEvent.AFTER_DESTROY, e,
-                true/* callDispatchListenerEvent */);
-          } else {
-            pendingCallbacks.add(e);
-            cbEventInPending = true;
-          }
-        } finally {
-          if (!cbEventInPending)
-            e.release();
-        }
+        EntryEventImpl e = AbstractRegionMap.createCallbackEvent(this.owner, op, key, null,
+            rmtOrigin, event, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext,
+            txEntryState, versionTag, tailKey);
+        AbstractRegionMap.switchEventOwnerAndOriginRemote(e, txEntryState == null);
+        pendingCallbacks.add(e);
-      if (AbstractRegionMap.shouldCreateCBEvent(this.owner, this.owner.isInitialized())) {
+      if (AbstractRegionMap.shouldCreateCallbackEvent(this.owner, this.owner.isInitialized())) {
-        boolean cbEventInPending = false;
-        EntryEventImpl e = AbstractRegionMap.createCBEvent(this.owner,
+        EntryEventImpl e = AbstractRegionMap.createCallbackEvent(this.owner,
-        try {
-          AbstractRegionMap.switchEventOwnerAndOriginRemote(e, txEntryState == null);
-          if (pendingCallbacks == null) {
-            this.owner.invokeTXCallbacks(EnumListenerEvent.AFTER_INVALIDATE, e,
-                true/* callDispatchListenerEvent */);
-          } else {
-            pendingCallbacks.add(e);
-            cbEventInPending = true;
-          }
-        } finally {
-          if (!cbEventInPending)
-            e.release();
-        }
+        AbstractRegionMap.switchEventOwnerAndOriginRemote(e, txEntryState == null);
+        pendingCallbacks.add(e);
-      if (AbstractRegionMap.shouldCreateCBEvent(this.owner, this.owner.isInitialized())) {
+      if (AbstractRegionMap.shouldCreateCallbackEvent(this.owner, this.owner.isInitialized())) {
-        boolean cbEventInPending = false;
-        EntryEventImpl e = AbstractRegionMap.createCBEvent(this.owner, putOperation, key, newValue,
-            rmtOrigin, event, eventId, aCallbackArgument, filterRoutingInfo, bridgeContext,
-            txEntryState, versionTag, tailKey);
-        try {
-          AbstractRegionMap.switchEventOwnerAndOriginRemote(e, txEntryState == null);
-          if (pendingCallbacks == null) {
-            this.owner.invokeTXCallbacks(EnumListenerEvent.AFTER_CREATE, e,
-                true/* callDispatchListenerEvent */);
-          } else {
-            pendingCallbacks.add(e);
-            cbEventInPending = true;
-          }
-        } finally {
-          if (!cbEventInPending)
-            e.release();
-        }
+        EntryEventImpl e = AbstractRegionMap.createCallbackEvent(this.owner, putOperation, key,
+            newValue, rmtOrigin, event, eventId, aCallbackArgument, filterRoutingInfo,
+            bridgeContext, txEntryState, versionTag, tailKey);
+        AbstractRegionMap.switchEventOwnerAndOriginRemote(e, txEntryState == null);
+        pendingCallbacks.add(e);

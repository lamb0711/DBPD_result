Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-//import org.apache.geode.cache.query.*;
+// import org.apache.geode.cache.query.*;
-  
-  //////////////////  Static fields ///////////////////////////
-  
+
+  ////////////////// Static fields ///////////////////////////
+
-  ////////////////////////  Static methods  ////////////////////////
-  
+  //////////////////////// Static methods ////////////////////////
+
-    final String updateTimeDesc = "Total time spent updating this index";    
+    final String updateTimeDesc = "Total time spent updating this index";
-    type = f.createType(
-      "IndexStats", 
-      "Statistics about a query index",
-      new StatisticDescriptor[] {
-        f.createLongGauge("numKeys", numKeysDesc, "keys"),
-        f.createLongGauge("numValues", numValuesDesc, "values"),
-        f.createLongCounter("numUpdates", numUpdatesDesc, "operations"),
-        f.createLongCounter("numUses", numUsesDesc, "operations"),
-        f.createLongCounter("updateTime", updateTimeDesc, "nanoseconds"),
-        f.createLongCounter("useTime", "Total time spent using this index", "nanoseconds"),
-        f.createIntGauge("updatesInProgress", "Current number of updates in progress.", "updates"),
-        f.createIntGauge("usesInProgress", "Current number of uses in progress.", "uses"),
-        f.createIntGauge("readLockCount", "Current number of read locks taken.", "uses"),
-        f.createLongGauge("numMapIndexKeys", "Number of keys in this Map index", "keys"),
-        f.createIntGauge("numBucketIndexes", "Number of bucket indexes in the partitioned region", "indexes"),
-      }
-    );
+    type = f.createType("IndexStats", "Statistics about a query index",
+        new StatisticDescriptor[] {f.createLongGauge("numKeys", numKeysDesc, "keys"),
+            f.createLongGauge("numValues", numValuesDesc, "values"),
+            f.createLongCounter("numUpdates", numUpdatesDesc, "operations"),
+            f.createLongCounter("numUses", numUsesDesc, "operations"),
+            f.createLongCounter("updateTime", updateTimeDesc, "nanoseconds"),
+            f.createLongCounter("useTime", "Total time spent using this index", "nanoseconds"),
+            f.createIntGauge("updatesInProgress", "Current number of updates in progress.",
+                "updates"),
+            f.createIntGauge("usesInProgress", "Current number of uses in progress.", "uses"),
+            f.createIntGauge("readLockCount", "Current number of read locks taken.", "uses"),
+            f.createLongGauge("numMapIndexKeys", "Number of keys in this Map index", "keys"),
+            f.createIntGauge("numBucketIndexes",
+                "Number of bucket indexes in the partitioned region", "indexes"),});
-    updateTimeId = type.nameToId("updateTime");    
-    updatesInProgressId = type.nameToId("updatesInProgress");    
-    usesInProgressId = type.nameToId("usesInProgress");    
+    updateTimeId = type.nameToId("updateTime");
+    updatesInProgressId = type.nameToId("updatesInProgress");
+    usesInProgressId = type.nameToId("usesInProgress");
-  
-  ////////////////////////  Constructors  ////////////////////////
+
+  //////////////////////// Constructors ////////////////////////
-   * Creates a new <code>CachePerfStats</code> and registers itself
-   * with the given statistics factory.
+   * Creates a new <code>CachePerfStats</code> and registers itself with the given statistics
+   * factory.
-  //////////////////////  Accessing Stats  //////////////////////
+  ////////////////////// Accessing Stats //////////////////////
-   public long getNumberOfKeys() {
-     return stats.getLong(numKeysId);
-   }
-   
-   public long getNumberOfValues() {
-     return stats.getLong(numValuesId); 
-   }
-   
-   public long getNumUpdates() {
-     return stats.getLong(numUpdatesId);
-   }
+  public long getNumberOfKeys() {
+    return stats.getLong(numKeysId);
+  }
-   public long getTotalUses() {
-     return stats.getLong(numUsesId); 
-   }  
-  
-   public long getTotalUpdateTime() {
-     return CachePerfStats.enableClockStats? stats.getLong(updateTimeId) : 0;
-   }
-   
-   public long getUseTime() {
-     return CachePerfStats.enableClockStats? stats.getLong(useTimeId) : 0;
-   }
-   
-   public int getReadLockCount() {
-     return stats.getInt(readLockCountId);
-   }
-   
-   public long getNumberOfMapIndexKeys() {
-     return stats.getLong(numMapIndexKeysId);
-   }
+  public long getNumberOfValues() {
+    return stats.getLong(numValuesId);
+  }
-   public int getNumberOfBucketIndexes() {
-     return stats.getInt(numBucketIndexesId);
-   }
+  public long getNumUpdates() {
+    return stats.getLong(numUpdatesId);
+  }
-  //////////////////////  Updating Stats  //////////////////////
-  
-   public void incNumUpdates() {
-     this.stats.incLong(numUpdatesId, 1);
-   }
-   public void incNumUpdates(int delta) {
-     this.stats.incLong(numUpdatesId, delta);
-   }
-   public void incNumValues(int delta) {
-     this.stats.incLong(numValuesId, delta);
-   }
-  
-   public void updateNumKeys(long numKeys) {
-     this.stats.setLong(numKeysId, numKeys);
-   }
-   
-   public void incNumKeys(long numKeys) {
-     this.stats.incLong(numKeysId, numKeys);
-   }
-   
-   public void incUpdateTime(long delta) {
-     if (CachePerfStats.enableClockStats) {
-       this.stats.incLong(updateTimeId, delta);
-     }
-   }
-   
-   public void incNumUses() {
-     this.stats.incLong(numUsesId, 1);
-   }
-   public void incUpdatesInProgress(int delta) {
-     this.stats.incInt(updatesInProgressId, delta);
-   }
-   public void incUsesInProgress(int delta) {
-     this.stats.incInt(usesInProgressId, delta);
-   }
-   public void incUseTime(long delta) {
-     if (CachePerfStats.enableClockStats) {
-       this.stats.incLong(useTimeId, delta);
-     }
-   }
-   public void incReadLockCount(int delta) {
-     this.stats.incInt(readLockCountId, delta);
-   }
-   
-   public void incNumMapIndexKeys(long delta) {
-     this.stats.incLong(numMapIndexKeysId, delta);
-   }
-   
-   public void incNumBucketIndexes(int delta) {
-     this.stats.incInt(numBucketIndexesId, delta);
-   }   
+  public long getTotalUses() {
+    return stats.getLong(numUsesId);
+  }
+
+  public long getTotalUpdateTime() {
+    return CachePerfStats.enableClockStats ? stats.getLong(updateTimeId) : 0;
+  }
+
+  public long getUseTime() {
+    return CachePerfStats.enableClockStats ? stats.getLong(useTimeId) : 0;
+  }
+
+  public int getReadLockCount() {
+    return stats.getInt(readLockCountId);
+  }
+
+  public long getNumberOfMapIndexKeys() {
+    return stats.getLong(numMapIndexKeysId);
+  }
+
+  public int getNumberOfBucketIndexes() {
+    return stats.getInt(numBucketIndexesId);
+  }
+
+  ////////////////////// Updating Stats //////////////////////
+
+  public void incNumUpdates() {
+    this.stats.incLong(numUpdatesId, 1);
+  }
+
+  public void incNumUpdates(int delta) {
+    this.stats.incLong(numUpdatesId, delta);
+  }
+
+  public void incNumValues(int delta) {
+    this.stats.incLong(numValuesId, delta);
+  }
+
+  public void updateNumKeys(long numKeys) {
+    this.stats.setLong(numKeysId, numKeys);
+  }
+
+  public void incNumKeys(long numKeys) {
+    this.stats.incLong(numKeysId, numKeys);
+  }
+
+  public void incUpdateTime(long delta) {
+    if (CachePerfStats.enableClockStats) {
+      this.stats.incLong(updateTimeId, delta);
+    }
+  }
+
+  public void incNumUses() {
+    this.stats.incLong(numUsesId, 1);
+  }
+
+  public void incUpdatesInProgress(int delta) {
+    this.stats.incInt(updatesInProgressId, delta);
+  }
+
+  public void incUsesInProgress(int delta) {
+    this.stats.incInt(usesInProgressId, delta);
+  }
+
+  public void incUseTime(long delta) {
+    if (CachePerfStats.enableClockStats) {
+      this.stats.incLong(useTimeId, delta);
+    }
+  }
+
+  public void incReadLockCount(int delta) {
+    this.stats.incInt(readLockCountId, delta);
+  }
+
+  public void incNumMapIndexKeys(long delta) {
+    this.stats.incLong(numMapIndexKeysId, delta);
+  }
+
+  public void incNumBucketIndexes(int delta) {
+    this.stats.incInt(numBucketIndexesId, delta);
+  }
-   * Closes these stats so that they can not longer be used.  The
-   * stats are closed when the {@linkplain
-   * org.apache.geode.internal.cache.GemFireCacheImpl#close cache} 
-   * is closed.
+   * Closes these stats so that they can not longer be used. The stats are closed when the
+   * {@linkplain org.apache.geode.internal.cache.GemFireCacheImpl#close cache} is closed.
+   * 

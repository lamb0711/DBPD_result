Revert "GEODE-7436: Deploy jar using semantic versioning scheme (#4343)" (#4380)

This reverts commit 0d4c1912


+import static java.util.stream.Collectors.joining;
+import java.net.URL;
-import java.nio.file.Path;
+import java.util.Objects;
+import java.util.Optional;
-import org.apache.commons.io.FilenameUtils;
-  // The pound version scheme predates the sequenced version scheme
-  private static final Pattern POUND_VERSION_SCHEME =
-      Pattern.compile("^vf\\.gf#(?<artifact>.*)\\.jar#(?<version>\\d+)$");
-  // Every deployed file will use this scheme to signify the sequence it's been deployed
-  static final Pattern DEPLOYED_FILE_PATTERN =
-      Pattern.compile("(?<baseName>..*)\\.v(?<version>\\d++).jar$");
-  // we can recognize jar files with below pattern. If two jar files have the same artifact, then
-  // the latter will replace the former deployed jar
-  private static final Pattern USER_VERSION_PATTERN =
-      Pattern.compile("(?<artifact>.*?)[-.]\\d+.*\\.jar$");
-
+  public static final String JAR_PREFIX_FOR_REGEX = "";
+
+
+  // Split a versioned filename into its name and version
+  public static final Pattern versionedPattern =
+      Pattern.compile(JAR_PREFIX_FOR_REGEX + "(.*)\\.v(\\d++).jar$");
+
+  public File getDeployDirectory() {
+    return this.deployDirectory;
+  }
+
-   * not match the latest deployed version).
+   * not match the latest deployed version)
-  public DeployedJar deployWithoutRegistering(final File stagedJar)
+  public DeployedJar deployWithoutRegistering(final String jarName, final File stagedJar)
-    String stagedJarName = stagedJar.getName();
-    String artifactId = getArtifactId(stagedJarName);
+
-      boolean shouldDeployNewVersion = shouldDeployNewVersion(artifactId, stagedJar);
+      boolean shouldDeployNewVersion = shouldDeployNewVersion(jarName, stagedJar);
-        logger.debug("No need to deploy a new version of {}", stagedJarName);
+        logger.debug("No need to deploy a new version of {}", jarName);
-      Path deployedFile = getNextVersionedJarFile(stagedJarName).toPath();
-      Files.copy(stagedJar.toPath(), deployedFile);
-      return new DeployedJar(deployedFile.toFile());
+      File newVersionedJarFile = getNextVersionedJarFile(jarName);
+      Files.copy(stagedJar.toPath(), newVersionedJarFile.toPath());
+
+      return new DeployedJar(newVersionedJarFile, jarName);
-    int maxVersion = getMaxVersion(getArtifactId(unversionedJarName));
+    File[] oldVersions = findSortedOldVersionsOfJar(unversionedJarName);
-    String nextVersionJarName =
-        FilenameUtils.getBaseName(unversionedJarName) + ".v" + (maxVersion + 1) + ".jar";
+    String nextVersionedJarName;
+    if (oldVersions == null || oldVersions.length == 0) {
+      nextVersionedJarName = removeJarExtension(unversionedJarName) + ".v1.jar";
+    } else {
+      String latestVersionedJarName = oldVersions[0].getName();
+      int nextVersion = extractVersionFromFilename(latestVersionedJarName) + 1;
+      nextVersionedJarName = removeJarExtension(unversionedJarName) + ".v" + nextVersion + ".jar";
+    }
-    logger.debug("Next versioned jar name for {} is {}", unversionedJarName, nextVersionJarName);
+    logger.debug("Next versioned jar name for {} is {}", unversionedJarName, nextVersionedJarName);
-    return new File(deployDirectory, nextVersionJarName);
-  }
-
-  protected int getMaxVersion(String artifactId) {
-    return Arrays.stream(deployDirectory.list()).filter(x -> artifactId.equals(toArtifactId(x)))
-        .map(JarDeployer::extractVersionFromFilename)
-        .reduce(Integer::max).orElse(0);
+    return new File(deployDirectory, nextVersionedJarName);
-    final Matcher matcher = DEPLOYED_FILE_PATTERN.matcher(filename);
+    final Matcher matcher = versionedPattern.matcher(filename);
-  public static boolean isDeployedFile(String filename) {
-    return DEPLOYED_FILE_PATTERN.matcher(filename).find();
-  }
+  protected Set<String> findDistinctDeployedJarsOnDisk() {
+    // Find all deployed JAR files
+    final File[] oldFiles =
+        this.deployDirectory.listFiles((file, name) -> versionedPattern.matcher(name).matches());
-  public static boolean isSemanticVersion(String filename) {
-    return USER_VERSION_PATTERN.matcher(filename).find();
+    // Now add just the original JAR name to the set
+    final Set<String> jarNames = new HashSet<>();
+    for (File oldFile : oldFiles) {
+      Matcher matcher = versionedPattern.matcher(oldFile.getName());
+      matcher.find();
+      jarNames.add(matcher.group(1) + ".jar");
+    }
+    return jarNames;
-   * get the artifact id from the existing files on the server. This will skip files that
-   * do not have sequence id appended to them.
+   * Find all versions of the JAR file that are currently on disk and return them sorted from newest
+   * (highest version) to oldest
-   * @param sequencedJarFileName the file names that exists on the server, it should always ends
-   *        with a sequence number
-   * @return the artifact id. if a file with no sequence number is passed in, this will return null
+   * @param unversionedJarName Name of the JAR file that we want old versions of
+   * @return Sorted array of files that are older versions of the given JAR
-  static String toArtifactId(String sequencedJarFileName) {
-    String baseName = getDeployedFileBaseName(sequencedJarFileName);
-    if (baseName == null) {
-      return null;
-    }
+  protected File[] findSortedOldVersionsOfJar(final String unversionedJarName) {
+    logger.debug("Finding sorted old versions of {}", unversionedJarName);
+    // Find all matching files
+    final Pattern pattern = Pattern.compile(
+        JAR_PREFIX_FOR_REGEX + removeJarExtension(unversionedJarName) + "\\.v\\d++\\.jar$");
+    final File[] oldJarFiles =
+        this.deployDirectory.listFiles((file, name) -> (pattern.matcher(name).matches()));
-    return getArtifactId(baseName + ".jar");
+    // Sort them in order from newest (highest version) to oldest
+    Arrays.sort(oldJarFiles, (file1, file2) -> {
+      int file1Version = extractVersionFromFilename(file1.getName());
+      int file2Version = extractVersionFromFilename(file2.getName());
+      return file2Version - file1Version;
+    });
+
+    logger.debug("Found [{}]",
+        Arrays.stream(oldJarFiles).map(File::getAbsolutePath).collect(joining(",")));
+    return oldJarFiles;
-  /**
-   * get the artifact id from the files deployed by the user. This will recognize files with
-   * SEMANTIC_VERSION_PATTERN, it will strip off the version part from the filename. For all other
-   * file names, it will just return the basename.
-   *
-   * @param deployedJarFileName the filename that's deployed by the user. could be in the form of
-   *        abc.jar or abc-1.0.0.jar, both should return abc
-   * @return the artifact id of the string
-   */
-  public static String getArtifactId(String deployedJarFileName) {
-    Matcher semanticVersionMatcher = USER_VERSION_PATTERN.matcher(deployedJarFileName);
-    if (semanticVersionMatcher.matches()) {
-      return semanticVersionMatcher.group("artifact");
+  protected String removeJarExtension(String jarName) {
+    if (jarName != null && jarName.endsWith(".jar")) {
+      return jarName.replaceAll("\\.jar$", "");
-      return FilenameUtils.getBaseName(deployedJarFileName);
-    }
-  }
-
-  public static String getDeployedFileBaseName(String sequencedJarFileName) {
-    Matcher semanticVersionMatcher = DEPLOYED_FILE_PATTERN.matcher(sequencedJarFileName);
-    if (semanticVersionMatcher.matches()) {
-      return semanticVersionMatcher.group("baseName");
-    } else {
-      return null;
+      return jarName;
+  final Pattern oldNamingPattern = Pattern.compile("^vf\\.gf#(.*)\\.jar#(\\d+)$");
+
-    return POUND_VERSION_SCHEME.matcher(fileName).matches();
+    return oldNamingPattern.matcher(fileName).matches();
-    Matcher matcher = POUND_VERSION_SCHEME.matcher(oldJar.getName());
+    Matcher matcher = oldNamingPattern.matcher(oldJar.getName());
-   * It will clean up the old version of deployed jars that are in the deployed directory
-      // find all the artifacts and its max versions
-      Map<String, Integer> artifactToMaxVersion = findArtifactsAndMaxVersion();
+
+      final Set<String> jarNames = findDistinctDeployedJarsOnDisk();
+      if (jarNames.isEmpty()) {
+        return;
+      }
+
-      // clean up the old versions and find the latest version of each jar
-      for (File file : deployDirectory.listFiles()) {
-        String artifactId = toArtifactId(file.getName());
-        if (artifactId == null) {
-          continue;
-        }
-        int version = extractVersionFromFilename(file.getName());
-        if (version < artifactToMaxVersion.get(artifactId)) {
-          FileUtils.deleteQuietly(file);
-        } else {
-          latestVersionOfEachJar.add(new DeployedJar(file));
+      for (String jarName : jarNames) {
+        DeployedJar deployedJar = findLatestValidDeployedJarFromDisk(jarName);
+
+        if (deployedJar != null) {
+          latestVersionOfEachJar.add(deployedJar);
+          deleteOtherVersionsOfJar(deployedJar);
-  Map<String, Integer> findArtifactsAndMaxVersion() {
-    Map<String, Integer> artifactToMaxVersion = new HashMap<>();
-    for (String fileName : deployDirectory.list()) {
-      String artifactId = toArtifactId(fileName);
-      if (artifactId == null) {
-        continue;
-      }
-      int version = extractVersionFromFilename(fileName);
-      Integer maxVersion = artifactToMaxVersion.get(artifactId);
-      if (maxVersion == null || maxVersion < version) {
-        artifactToMaxVersion.put(artifactId, version);
-      }
-    }
-    return artifactToMaxVersion;
+  /**
+   * Deletes all versions of this jar on disk other than the given version
+   */
+  public void deleteOtherVersionsOfJar(DeployedJar deployedJar) {
+    logger.info("Deleting all versions of " + deployedJar.getJarName() + " other than "
+        + deployedJar.getFileName());
+    final File[] jarFiles = findSortedOldVersionsOfJar(deployedJar.getJarName());
+
+    Stream.of(jarFiles).filter(jarFile -> !jarFile.equals(deployedJar.getFile()))
+        .forEach(jarFile -> {
+          logger.info("Deleting old version of jar: " + jarFile.getAbsolutePath());
+          FileUtils.deleteQuietly(jarFile);
+        });
+  public DeployedJar findLatestValidDeployedJarFromDisk(String unversionedJarName)
+      throws IOException {
+    final File[] jarFiles = findSortedOldVersionsOfJar(unversionedJarName);
+
+    Optional<File> latestValidDeployedJarOptional = Arrays.stream(jarFiles).filter(Objects::nonNull)
+        .filter(jarFile -> DeployedJar.hasValidJarContent(jarFile)).findFirst();
+
+    if (!latestValidDeployedJarOptional.isPresent()) {
+      // No valid version of this jar
+      return null;
+    }
+
+    File latestValidDeployedJar = latestValidDeployedJarOptional.get();
+
+    return new DeployedJar(latestValidDeployedJar, unversionedJarName);
+  }
+
+  public URL[] getDeployedJarURLs() {
+    return this.deployedJars.values().stream().map(DeployedJar::getFileURL).toArray(URL[]::new);
+
+  }
-          DeployedJar oldJar = this.deployedJars.put(deployedJar.getArtifactId(), deployedJar);
+          DeployedJar oldJar = this.deployedJars.put(deployedJar.getJarName(), deployedJar);
-   * When deploying a jar file, it will always append a sequence number .v<digit> to the end of
-   * the file, no matter how the original file is named. This is to allow server on startup to
-   * know what's the last version that gets deployed without cluster configuration.
-   *
-  public List<DeployedJar> deploy(final Set<File> stagedJarFiles)
+  public List<DeployedJar> deploy(final Map<String, File> stagedJarFiles)
-    for (File jar : stagedJarFiles) {
+    for (File jar : stagedJarFiles.values()) {
-      for (File stagedJarFile : stagedJarFiles) {
-        deployedJars.add(deployWithoutRegistering(stagedJarFile));
+      for (String fileName : stagedJarFiles.keySet()) {
+        deployedJars.add(deployWithoutRegistering(fileName, stagedJarFiles.get(fileName)));
-  private boolean shouldDeployNewVersion(String artifactId, File stagedJar) throws IOException {
-    DeployedJar oldDeployedJar = this.deployedJars.get(artifactId);
+  private boolean shouldDeployNewVersion(String jarName, File stagedJar) throws IOException {
+    DeployedJar oldDeployedJar = this.deployedJars.get(jarName);
-  @VisibleForTesting
-    return this.deployedJars.get(getArtifactId(jarName));
+    return this.deployedJars.get(jarName);
-  public DeployedJar deploy(final File stagedJarFile)
+  public DeployedJar deploy(final String jarName, final File stagedJarFile)
-    Set<File> jarFiles = new HashSet();
-    jarFiles.add(stagedJarFile);
+    Map<String, File> jarFiles = new HashMap<>();
+    jarFiles.put(jarName, stagedJarFile);
+
-   * Undeploy the jar file identified by the given artifact ID.
+   * Undeploy the given JAR file.
-   * @param jarName The jarFile to undeploy
+   * @param jarName The name of the JAR file to undeploy
-    String artifactId = getArtifactId(jarName);
-      DeployedJar deployedJar = deployedJars.get(artifactId);
+      DeployedJar deployedJar = deployedJars.remove(jarName);
-        throw new IllegalArgumentException(jarName + " not deployed");
+        throw new IllegalArgumentException("JAR not deployed");
-      if (!deployedJar.getDeployedFileName().equals(jarName)) {
-        throw new IllegalArgumentException(jarName + " not deployed");
-      }
-
-      // remove the deployedJar
-      deployedJars.remove(artifactId);
-      ClassPathLoader.getLatest().unloadClassloaderForArtifact(artifactId);
+      ClassPathLoader.getLatest().unloadClassloaderForJar(jarName);
-  /**
-   *
-   * @param jarName a user deployed jar name (abc.jar or abc-1.0.jar)
-   */
-  public void deleteAllVersionsOfJar(String jarName) {
+  public void deleteAllVersionsOfJar(String unversionedJarName) {
-    String artifactId = getArtifactId(jarName);
-      for (File file : this.deployDirectory.listFiles()) {
-        if (artifactId.equals(toArtifactId(file.getName()))) {
-          logger.info("Deleting: {}", file.getAbsolutePath());
-          FileUtils.deleteQuietly(file);
-        }
+      File[] jarFiles = findSortedOldVersionsOfJar(unversionedJarName);
+      for (File jarFile : jarFiles) {
+        logger.info("Deleting: {}", jarFile.getAbsolutePath());
+        FileUtils.deleteQuietly(jarFile);

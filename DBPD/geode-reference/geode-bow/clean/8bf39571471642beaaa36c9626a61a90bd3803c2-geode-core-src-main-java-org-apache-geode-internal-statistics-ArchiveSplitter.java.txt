Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-//import java.text.*;
-//import java.util.*;
+// import java.text.*;
+// import java.util.*;
- * ArchiveSplitter provides APIs to read statistic snapshots from an archive
- * file.
+ * ArchiveSplitter provides APIs to read statistic snapshots from an archive file.
-  private final static int BUFFER_SIZE = 1024*1024;
+  private final static int BUFFER_SIZE = 1024 * 1024;
-  private static final long DEFAULT_SPLIT_DURATION = 24*60*60*1000; // one day
+  private static final long DEFAULT_SPLIT_DURATION = 24 * 60 * 60 * 1000; // one day
-  
+
+
-      this.myIs = new MyFilterInputStream(new BufferedInputStream(new GZIPInputStream(this.is, BUFFER_SIZE), BUFFER_SIZE));
+      this.myIs = new MyFilterInputStream(
+          new BufferedInputStream(new GZIPInputStream(this.is, BUFFER_SIZE), BUFFER_SIZE));
+
-      throw new GemFireIOException(LocalizedStrings.ArchiveSplitter_ARCHIVE_VERSION_0_IS_NO_LONGER_SUPPORTED.toLocalizedString(new Byte(archiveVersion)), null);
+      throw new GemFireIOException(
+          LocalizedStrings.ArchiveSplitter_ARCHIVE_VERSION_0_IS_NO_LONGER_SUPPORTED
+              .toLocalizedString(new Byte(archiveVersion)),
+          null);
-      throw new GemFireIOException(LocalizedStrings.ArchiveSplitter_UNSUPPORTED_ARCHIVE_VERSION_0_THE_SUPPORTED_VERSION_IS_1.toLocalizedString(new Object[] {new Byte(archiveVersion), new Byte(ARCHIVE_VERSION)}), null);
+      throw new GemFireIOException(
+          LocalizedStrings.ArchiveSplitter_UNSUPPORTED_ARCHIVE_VERSION_0_THE_SUPPORTED_VERSION_IS_1
+              .toLocalizedString(
+                  new Object[] {new Byte(archiveVersion), new Byte(ARCHIVE_VERSION)}),
+          null);
+
+
-    //dataIn.readBoolean();
+    // dataIn.readBoolean();
-//  private void skipByte() throws IOException {
-//    //dataIn.readByte();
-//    skipBytes(1);
-//  }
-//  private void skipUByte() throws IOException {
-//    //dataIn.readUnsignedByte();
-//    skipBytes(1);
-//  }
-//  private void skipShort() throws IOException {
-//    //dataIn.readShort();
-//    skipBytes(2);
-//  }
-//  private void skipUShort() throws IOException {
-//    //dataIn.readUnsignedShort();
-//    skipBytes(2);
-//  }
-//  private void skipInt() throws IOException {
-//    //dataIn.readInt();
-//    skipBytes(4);
-//  }
+
+  // private void skipByte() throws IOException {
+  // //dataIn.readByte();
+  // skipBytes(1);
+  // }
+  // private void skipUByte() throws IOException {
+  // //dataIn.readUnsignedByte();
+  // skipBytes(1);
+  // }
+  // private void skipShort() throws IOException {
+  // //dataIn.readShort();
+  // skipBytes(2);
+  // }
+  // private void skipUShort() throws IOException {
+  // //dataIn.readUnsignedShort();
+  // skipBytes(2);
+  // }
+  // private void skipInt() throws IOException {
+  // //dataIn.readInt();
+  // skipBytes(4);
+  // }
-    //dataIn.readLong();
+    // dataIn.readLong();
+
-    //dataIn.readUTF();
+    // dataIn.readUTF();
+
-      byte[][] tmp = new byte[globalTokenCount+128][];
+      byte[][] tmp = new byte[globalTokenCount + 128][];
+
-    skipUTF(); //String resourceTypeName = dataIn.readUTF();
-    skipUTF(); //String resourceTypeDesc = dataIn.readUTF();
+    skipUTF(); // String resourceTypeName = dataIn.readUTF();
+    skipUTF(); // String resourceTypeDesc = dataIn.readUTF();
-    for (int i=0; i < statCount; i++) {
-      skipUTF(); //String statName = dataIn.readUTF();
+    for (int i = 0; i < statCount; i++) {
+      skipUTF(); // String statName = dataIn.readUTF();
-      skipBoolean(); //boolean isCounter = dataIn.readBoolean();
+      skipBoolean(); // boolean isCounter = dataIn.readBoolean();
-        skipBoolean(); //boolean largerBetter = dataIn.readBoolean();
+        skipBoolean(); // boolean largerBetter = dataIn.readBoolean();
-      skipUTF(); //String units = dataIn.readUTF();
-      skipUTF(); //String desc = dataIn.readUTF();
+      skipUTF(); // String units = dataIn.readUTF();
+      skipUTF(); // String desc = dataIn.readUTF();
-      byte[][] tmp = new byte[resourceTypeId+128][];
+      byte[][] tmp = new byte[resourceTypeId + 128][];
+
-    skipUTF(); //String name = dataIn.readUTF();
-    skipLong(); //long id = dataIn.readLong();
+    skipUTF(); // String name = dataIn.readUTF();
+    skipLong(); // long id = dataIn.readLong();
-    
+
-      long[][] tmpBits = new long[resourceInstId+128][];
-      System.arraycopy(resourceInstanceBits, 0,
-                       tmpBits, 0, resourceInstanceBits.length);
+      long[][] tmpBits = new long[resourceInstId + 128][];
+      System.arraycopy(resourceInstanceBits, 0, tmpBits, 0, resourceInstanceBits.length);
-      byte[][] tmpTypeCodes = new byte[resourceInstId+128][];
-      System.arraycopy(resourceInstanceTypeCodes, 0,
-                       tmpTypeCodes, 0, resourceInstanceTypeCodes.length);
+      byte[][] tmpTypeCodes = new byte[resourceInstId + 128][];
+      System.arraycopy(resourceInstanceTypeCodes, 0, tmpTypeCodes, 0,
+          resourceInstanceTypeCodes.length);
-      byte[][] tmpTokens = new byte[resourceInstId+128][];
-      System.arraycopy(resourceInstanceTokens, 0,
-                       tmpTokens, 0, resourceInstanceTokens.length);
+      byte[][] tmpTokens = new byte[resourceInstId + 128][];
+      System.arraycopy(resourceInstanceTokens, 0, tmpTokens, 0, resourceInstanceTokens.length);
-      for (int i=0; i < instBits.length; i++) {
+      for (int i = 0; i < instBits.length; i++) {
-        case BOOLEAN_CODE:
-        case BYTE_CODE:
-        case CHAR_CODE:
-          instBits[i] = dataIn.readByte();
-          break;
-        case WCHAR_CODE:
-          instBits[i] = dataIn.readUnsignedShort();
-          break;
-        case SHORT_CODE:
-          instBits[i] = dataIn.readShort();
-          break;
-        case INT_CODE:
-        case FLOAT_CODE:
-        case LONG_CODE:
-        case DOUBLE_CODE:
-          instBits[i] = readCompactValue();
-          break;
-        default:
-          throw new IOException(LocalizedStrings.ArchiveSplitter_UNEXPECTED_TYPECODE_VALUE_0.toLocalizedString(new Byte(instTypeCodes[i])));
+          case BOOLEAN_CODE:
+          case BYTE_CODE:
+          case CHAR_CODE:
+            instBits[i] = dataIn.readByte();
+            break;
+          case WCHAR_CODE:
+            instBits[i] = dataIn.readUnsignedShort();
+            break;
+          case SHORT_CODE:
+            instBits[i] = dataIn.readShort();
+            break;
+          case INT_CODE:
+          case FLOAT_CODE:
+          case LONG_CODE:
+          case DOUBLE_CODE:
+            instBits[i] = readCompactValue();
+            break;
+          default:
+            throw new IOException(LocalizedStrings.ArchiveSplitter_UNEXPECTED_TYPECODE_VALUE_0
+                .toLocalizedString(new Byte(instTypeCodes[i])));
+
+
+
+
-        int bytesToRead = ((byte)v - COMPACT_VALUE_2_TOKEN) + 2;
+        int bytesToRead = ((byte) v - COMPACT_VALUE_2_TOKEN) + 2;
+
-      long[] bits =      resourceInstanceBits[resourceInstId];
+      long[] bits = resourceInstanceBits[resourceInstId];
-        case BOOLEAN_CODE:
-        case BYTE_CODE:
-        case CHAR_CODE:
-          statDeltaBits = dataIn.readByte();
-          break;
-        case WCHAR_CODE:
-          statDeltaBits = dataIn.readUnsignedShort();
-          break;
-        case SHORT_CODE:
-          statDeltaBits = dataIn.readShort();
-          break;
-        case INT_CODE:
-        case FLOAT_CODE:
-        case LONG_CODE:
-        case DOUBLE_CODE:
-          statDeltaBits = readCompactValue();
-          break;
-        default:
-          throw new IOException(LocalizedStrings.ArchiveSplitter_UNEXPECTED_TYPECODE_VALUE_0.toLocalizedString(new Byte(typeCodes[statOffset])));
+          case BOOLEAN_CODE:
+          case BYTE_CODE:
+          case CHAR_CODE:
+            statDeltaBits = dataIn.readByte();
+            break;
+          case WCHAR_CODE:
+            statDeltaBits = dataIn.readUnsignedShort();
+            break;
+          case SHORT_CODE:
+            statDeltaBits = dataIn.readShort();
+            break;
+          case INT_CODE:
+          case FLOAT_CODE:
+          case LONG_CODE:
+          case DOUBLE_CODE:
+            statDeltaBits = readCompactValue();
+            break;
+          default:
+            throw new IOException(LocalizedStrings.ArchiveSplitter_UNEXPECTED_TYPECODE_VALUE_0
+                .toLocalizedString(new Byte(typeCodes[statOffset])));
+
-     * Returns true if token read, false if eof.
-     */
+   * Returns true if token read, false if eof.
+   */
-      case HEADER_TOKEN:
-        readHeaderToken();
-        this.myIs.putBytes(this.dataOut);
-        break;
-      case RESOURCE_TYPE_TOKEN:
-        readResourceTypeToken();
-        this.myIs.putBytes(this.dataOut);
-        break;
-      case RESOURCE_INSTANCE_CREATE_TOKEN:
-      case RESOURCE_INSTANCE_INITIALIZE_TOKEN:
-        readResourceInstanceCreateToken(token == RESOURCE_INSTANCE_INITIALIZE_TOKEN);
-        this.myIs.putBytes(this.dataOut);
-        break;
-      case RESOURCE_INSTANCE_DELETE_TOKEN:
-        readResourceInstanceDeleteToken();
-        this.myIs.putBytes(this.dataOut);
-        break;
-      case SAMPLE_TOKEN:
-        readSampleToken();
-        this.myIs.putBytes(this.dataOut);
-        break;
-      default:
-        throw new IOException(LocalizedStrings.ArchiveSplitter_UNEXPECTED_TOKEN_BYTE_VALUE_0.toLocalizedString(new Byte(token)));
+        case HEADER_TOKEN:
+          readHeaderToken();
+          this.myIs.putBytes(this.dataOut);
+          break;
+        case RESOURCE_TYPE_TOKEN:
+          readResourceTypeToken();
+          this.myIs.putBytes(this.dataOut);
+          break;
+        case RESOURCE_INSTANCE_CREATE_TOKEN:
+        case RESOURCE_INSTANCE_INITIALIZE_TOKEN:
+          readResourceInstanceCreateToken(token == RESOURCE_INSTANCE_INITIALIZE_TOKEN);
+          this.myIs.putBytes(this.dataOut);
+          break;
+        case RESOURCE_INSTANCE_DELETE_TOKEN:
+          readResourceInstanceDeleteToken();
+          this.myIs.putBytes(this.dataOut);
+          break;
+        case SAMPLE_TOKEN:
+          readSampleToken();
+          this.myIs.putBytes(this.dataOut);
+          break;
+        default:
+          throw new IOException(LocalizedStrings.ArchiveSplitter_UNEXPECTED_TOKEN_BYTE_VALUE_0
+              .toLocalizedString(new Byte(token)));
-    StringBuffer buf = new StringBuffer(inName.length()+4);
+    StringBuffer buf = new StringBuffer(inName.length() + 4);
-    buf.append('-')
-      .append(this.splitCount);
+    buf.append('-').append(this.splitCount);
-    
-    for (int i=0; i < globalTokenCount; i++) {
+
+    for (int i = 0; i < globalTokenCount; i++) {
-    for (int i=0; i < resourceInstanceTokens.length; i++) {
+    for (int i = 0; i < resourceInstanceTokens.length; i++) {
-        for (int j=0; j < instBits.length; j++) {
+        for (int j = 0; j < instBits.length; j++) {
-  
+
+
-     * Writes all the bytes, read or skipped, since the last reset
-     * to the specified output stream.
+     * Writes all the bytes, read or skipped, since the last reset to the specified output stream.
-    
+
-    
+
-      makeRoom((int)n);
-      int result = super.read(readBytes, idx, (int)n);
+      makeRoom((int) n);
+      int result = super.read(readBytes, idx, (int) n);
-    
+
-      if (idx+n > readBytes.length) {
+      if (idx + n > readBytes.length) {
-        readBytes[idx] = (byte)result;
+        readBytes[idx] = (byte) result;
+
-  
+
-      System.err.println(LocalizedStrings.ArchiveSplitter_USAGE.toLocalizedString() + ": org.apache.geode.internal.statistics.ArchiveSplitter <archive.gfs>");
+      System.err.println(LocalizedStrings.ArchiveSplitter_USAGE.toLocalizedString()
+          + ": org.apache.geode.internal.statistics.ArchiveSplitter <archive.gfs>");

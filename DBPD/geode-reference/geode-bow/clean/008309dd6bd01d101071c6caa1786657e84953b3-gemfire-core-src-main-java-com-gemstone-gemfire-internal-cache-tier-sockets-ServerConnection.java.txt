Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import java.util.concurrent.LinkedBlockingQueue;
-import com.gemstone.gemfire.internal.cache.tier.InternalBridgeMembership;
+import com.gemstone.gemfire.internal.cache.tier.InternalClientMembership;
- 
-  public static ByteBuffer allocateCommBuffer(int size) {
-    return ByteBuffer.allocate(size);
+  // The key is the size of each ByteBuffer. The value is a queue of byte buffers all of that size.
+  private static final ConcurrentHashMap<Integer, LinkedBlockingQueue<ByteBuffer>> commBufferMap = new ConcurrentHashMap<>(4, 0.75f, 1);
+
+  public static ByteBuffer allocateCommBuffer(int size, Socket sock) {
+    // I expect that size will almost always be the same value
+    if (sock.getChannel() == null) {
+      // The socket this commBuffer will be used for is old IO (it has no channel).
+      // So the commBuffer should be heap based.
+      return ByteBuffer.allocate(size);
+    }
+    LinkedBlockingQueue<ByteBuffer> q = commBufferMap.get(size);
+    ByteBuffer result = null;
+    if (q != null) {
+      result = q.poll();
+    }
+    if (result == null) {
+      result = ByteBuffer.allocateDirect(size);
+    } else {
+      result.position(0);
+      result.limit(result.capacity());
+    }
+    return result;
+  }
+  
+  public static void releaseCommBuffer(ByteBuffer bb) {
+    if (bb != null && bb.isDirect()) {
+      LinkedBlockingQueue<ByteBuffer> q = commBufferMap.get(bb.capacity());
+      if (q == null) {
+        q = new LinkedBlockingQueue<>();
+        LinkedBlockingQueue<ByteBuffer> oldQ = commBufferMap.putIfAbsent(bb.capacity(), q);
+        if (oldQ != null) {
+          q = oldQ;
+        }
+      }
+      q.offer(bb);
+    }
+  }
+  
+  public static void emptyCommBufferPool() {
+    for (LinkedBlockingQueue<ByteBuffer> q: commBufferMap.values()) {
+      q.clear();
+    }
+    
+    
+    this.executeFunctionResponseMsg.setVersion(v);
-        logger.debug("{} registering client {}", (registerClient? "" : "not "), proxyId);
+        logger.debug("{}registering client {}", (registerClient? "" : "not "), proxyId);
-        InternalBridgeMembership.notifyJoined(this.proxyId.getDistributedMember(),
+        InternalClientMembership.notifyJoined(this.proxyId.getDistributedMember(),
-            InternalBridgeMembership.notifyLeft(proxyId.getDistributedMember(), true);
+            InternalClientMembership.notifyLeft(proxyId.getDistributedMember(), true);
-            InternalBridgeMembership.notifyCrashed(this.proxyId.getDistributedMember(), true);
+            InternalClientMembership.notifyCrashed(this.proxyId.getDistributedMember(), true);
-          commBuffer = allocateCommBuffer(socketBufferSize);
+          commBuffer = allocateCommBuffer(socketBufferSize, s);
-        requestMsg.setComms(theSocket, commBuffer, msgStats);
-        replyMsg.setComms(theSocket, commBuffer, msgStats);
-        responseMsg.setComms(theSocket, commBuffer, msgStats);
-        chunkedResponseMsg.setComms(theSocket, commBuffer, msgStats);
-        queryResponseMsg.setComms(theSocket, commBuffer, msgStats);
-        executeFunctionResponseMsg.setComms(theSocket, commBuffer, msgStats);
-        registerInterestResponseMsg.setComms(theSocket, commBuffer, msgStats);        
-        errorMsg.setComms(theSocket, commBuffer, msgStats);
+        requestMsg.setComms(this, theSocket, commBuffer, msgStats);
+        replyMsg.setComms(this, theSocket, commBuffer, msgStats);
+        responseMsg.setComms(this, theSocket, commBuffer, msgStats);
+        errorMsg.setComms(this, theSocket, commBuffer, msgStats);
+
+        chunkedResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
+        queryResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
+        executeFunctionResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
+        registerInterestResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
+        keySetResponseMsg.setComms(this, theSocket, commBuffer, msgStats);
+    releaseCommBuffer();
+  private void releaseCommBuffer() {
+    ByteBuffer bb = this.commBuffer;
+    if (bb != null) {
+      this.commBuffer = null;
+      ServerConnection.releaseCommBuffer(bb);
+    }
+  }
+  

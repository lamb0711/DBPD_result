Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * The redis command type used by the server. Each command is directly from
- * the redis protocol and calling {@link #getExecutor()} on a type returns the executor
- * class for that command.
+ * The redis command type used by the server. Each command is directly from the redis protocol and
+ * calling {@link #getExecutor()} on a type returns the executor class for that command.
-   * AUTH password <p>
+   * AUTH password
+   * <p>
+
+
+
-  }, 
-  
+  },
+
-   * DEL key [key ...] <p>
+   * DEL key [key ...]
+   * <p>
+
+
+
-  }, 
+  },
-   * EXISTS key <p>
+   * EXISTS key
+   * <p>
+
+
+
-  }, 
+  },
-   * EXPIRE key seconds <p>
+   * EXPIRE key seconds
+   * <p>
+
+
+
-  }, 
+  },
-   * EXPIREAT key timestamp <p>
+   * EXPIREAT key timestamp
+   * <p>
+
-    private final RedisDataType dataType = RedisDataType.NONE;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  }, 
-  /**
-   * FLUSHALL <p>
-   * Remove all keys from all databases
-   */
-  FLUSHALL {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new FlushAllExecutor();
-      }
-      return executor;
-    }
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  }, 
-  /**
-   * FLUSHDB<p>Remove all keys from the current database<p>Same as FLUSHALL for this implementation
-   */
-  FLUSHDB {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new FlushAllExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.NONE;
-   * KEYS pattern <p>
+   * FLUSHALL
+   * <p>
+   * Remove all keys from all databases
+   */
+  FLUSHALL {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new FlushAllExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.NONE;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * FLUSHDB
+   * <p>
+   * Remove all keys from the current database
+   * <p>
+   * Same as FLUSHALL for this implementation
+   */
+  FLUSHDB {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new FlushAllExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.NONE;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * KEYS pattern
+   * <p>
+
+
+
-  }, 
+  },
-   * PERSIST key <p>
+   * PERSIST key
+   * <p>
+
+
+
-  }, 
+  },
-   * PEXPIRE key milliseconds<p>Set a key's time to live in milliseconds
+   * PEXPIRE key milliseconds
+   * <p>
+   * Set a key's time to live in milliseconds
+
+
+
-  },  
+  },
-   * PEXPIREAT key milliseconds-timestamp<p>Set the expiration for a key as a UNIX timestamp specified in milliseconds
+   * PEXPIREAT key milliseconds-timestamp
+   * <p>
+   * Set the expiration for a key as a UNIX timestamp specified in milliseconds
+
+
+
-  },  
+  },
-   * PTTL key<p>Get the time to live for a key in milliseconds
+   * PTTL key
+   * <p>
+   * Get the time to live for a key in milliseconds
+
+
+
-  },  
+  },
-   * SCAN cursor [MATCH pattern] [COUNT count]<p>Incrementally iterate the keys space
+   * SCAN cursor [MATCH pattern] [COUNT count]
+   * <p>
+   * Incrementally iterate the keys space
+
+
+
-   * TTL key<p>Get the time to live for a key
+   * TTL key
+   * <p>
+   * Get the time to live for a key
+
+
+
-   * TYPE key<p>Determine the type stored at key
+   * TYPE key
+   * <p>
+   * Determine the type stored at key
+
+
+
-   * APPEND key value<p>Append a value to a key
+   * APPEND key value
+   * <p>
+   * Append a value to a key
+
+
+
-  },  
+  },
-   * BITCOUNT key start end [start end ...]<p>Count set bits in a string
+   * BITCOUNT key start end [start end ...]
+   * <p>
+   * Count set bits in a string
+
+
+
-  }, 
+  },
-   * BITOP operation destkey key [key ...]<p>Perform bitwise operations between strings
+   * BITOP operation destkey key [key ...]
+   * <p>
+   * Perform bitwise operations between strings
+
+
+
-   * BITPOS key bit [start] [end]<p>Find first bit set or clear in a string
+   * BITPOS key bit [start] [end]
+   * <p>
+   * Find first bit set or clear in a string
+
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  }, 
-  /**
-   * DECR key<p>Decrement the integer value of a key by one
-   */
-  DECR {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new DecrExecutor();
-      }
-      return executor;
-    }
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-  /**
-   * DECRBY key decrement<p>Decrement the integer value of a key by the given number
-   */
-  DECRBY {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new DecrByExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * GET key<p>Get the value of a key
-   */
-  GET {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new GetExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  }, 
-
-  /**
-   * GETBIT key offset<p>Returns the bit value at offset in the string value stored at key
-   */
-  GETBIT {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new GetBitExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  }, 
-
-  /**
-   * GETRANGE key start end<p>Get a substring of the string stored at a key
-   */
-  GETRANGE {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new GetRangeExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * GETSET key value<p>Set the string value of a key and return its old value
-   */
-  GETSET {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new GetSetExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * INCR key<p>Increment the integer value of a key by one
-   */
-  INCR {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new IncrExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * INCRBY key increment<p>Increment the integer value of a key by the given amount
-   */
-  INCRBY {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new IncrByExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * INCRBYFLOAT key increment<p>Increment the float value of a key by the given amount
-   */
-  INCRBYFLOAT {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new IncrByFloatExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * MGET key [key ...]<p>Get the values of all the given keys
-   */
-  MGET {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new MGetExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * MSET key value [key value ...]<p>Set multiple keys to multiple values
-   */
-  MSET {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new MSetExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * MSETNX key value [key value ...]<p>Set multiple keys to multiple values, only if none of the keys exist
-   */
-  MSETNX {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new MSetNXExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * PSETEX key milliseconds value<p>Set the value and expiration in milliseconds of a key
-   */
-  PSETEX {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new PSetEXExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * SETEX key seconds value<p>Set the value and expiration of a key
-   */
-  SETEX {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new SetEXExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * SET key value [EX seconds] [PX milliseconds] [NX|XX]<p>Set the string value of a key
-   */
-  SET {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new SetExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  }, 
-
-  /**
-   * SETBIT key offset value<P>Sets or clears the bit at offset in the string value stored at key
-   */
-  SETBIT {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new SetBitExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  }, 
-
-  /**
-   * SETNX key value<p>Set the value of a key, only if the key does not exist
-   */
-  SETNX {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new SetNXExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * SETRANGE key offset value<p>Overwrite part of a string at key starting at the specified offset
-   */
-  SETRANGE {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new SetRangeExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
-   * STRLEN key<p>Get the length of the value stored in a key
+   * DECR key
+   * <p>
+   * Decrement the integer value of a key by one
+   */
+  DECR {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new DecrExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * DECRBY key decrement
+   * <p>
+   * Decrement the integer value of a key by the given number
+   */
+  DECRBY {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new DecrByExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * GET key
+   * <p>
+   * Get the value of a key
+   */
+  GET {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new GetExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * GETBIT key offset
+   * <p>
+   * Returns the bit value at offset in the string value stored at key
+   */
+  GETBIT {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new GetBitExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * GETRANGE key start end
+   * <p>
+   * Get a substring of the string stored at a key
+   */
+  GETRANGE {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new GetRangeExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * GETSET key value
+   * <p>
+   * Set the string value of a key and return its old value
+   */
+  GETSET {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new GetSetExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * INCR key
+   * <p>
+   * Increment the integer value of a key by one
+   */
+  INCR {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new IncrExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * INCRBY key increment
+   * <p>
+   * Increment the integer value of a key by the given amount
+   */
+  INCRBY {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new IncrByExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * INCRBYFLOAT key increment
+   * <p>
+   * Increment the float value of a key by the given amount
+   */
+  INCRBYFLOAT {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new IncrByFloatExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * MGET key [key ...]
+   * <p>
+   * Get the values of all the given keys
+   */
+  MGET {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new MGetExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * MSET key value [key value ...]
+   * <p>
+   * Set multiple keys to multiple values
+   */
+  MSET {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new MSetExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * MSETNX key value [key value ...]
+   * <p>
+   * Set multiple keys to multiple values, only if none of the keys exist
+   */
+  MSETNX {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new MSetNXExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * PSETEX key milliseconds value
+   * <p>
+   * Set the value and expiration in milliseconds of a key
+   */
+  PSETEX {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new PSetEXExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * SETEX key seconds value
+   * <p>
+   * Set the value and expiration of a key
+   */
+  SETEX {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new SetEXExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * SET key value [EX seconds] [PX milliseconds] [NX|XX]
+   * <p>
+   * Set the string value of a key
+   */
+  SET {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new SetExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * SETBIT key offset value
+   * <P>
+   * Sets or clears the bit at offset in the string value stored at key
+   */
+  SETBIT {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new SetBitExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * SETNX key value
+   * <p>
+   * Set the value of a key, only if the key does not exist
+   */
+  SETNX {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new SetNXExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * SETRANGE key offset value
+   * <p>
+   * Overwrite part of a string at key starting at the specified offset
+   */
+  SETRANGE {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new SetRangeExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_STRING;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * STRLEN key
+   * <p>
+   * Get the length of the value stored in a key
+
+
+
-   * HDEL key field [field ...]<p>Delete one or more hash fields
+   * HDEL key field [field ...]
+   * <p>
+   * Delete one or more hash fields
+
-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-  /**
-   * HEXISTS key field<p>Determine if a hash field exists
-   */
-  HEXISTS {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new HExistsExecutor();
-      }
-      return executor;
-    }
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-  /**
-   * HGET key field<p>Get the value of a hash field
-   */
-  HGET {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new HGetExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * HGETALL key<p>Get all the fields and values in a hash
-   */
-  HGETALL {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new HGetAllExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * HINCRBY key field increment<p>Increment the integer value of a hash field by the given number
-   */
-  HINCRBY {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new HIncrByExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * HINCRBYFLOAT key field increment<p>Increment the float value of a hash field by the given amount
-   */
-  HINCRBYFLOAT {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new HIncrByFloatExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * HKEYS key<p>Get all the fields in a hash
-   */
-  HKEYS {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new HKeysExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * HLEN key<p>Get the number of fields in a hash
-   */
-  HLEN {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new HLenExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * HMGET key field [field ...]<p>Get the values of all the given hash fields
-   */
-  HMGET {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new HMGetExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * HMSET key field value [field value ...]<p>Set multiple hash fields to multiple values
-   */
-  HMSET {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new HMSetExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * HSCAN key cursor [MATCH pattern] [COUNT count]<p>Incrementally iterate hash fields and associated values
-   */
-  HSCAN {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new HScanExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
-   * HSET key field value<p>Set the string value of a hash field
+   * HEXISTS key field
+   * <p>
+   * Determine if a hash field exists
+   */
+  HEXISTS {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new HExistsExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * HGET key field
+   * <p>
+   * Get the value of a hash field
+   */
+  HGET {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new HGetExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * HGETALL key
+   * <p>
+   * Get all the fields and values in a hash
+   */
+  HGETALL {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new HGetAllExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * HINCRBY key field increment
+   * <p>
+   * Increment the integer value of a hash field by the given number
+   */
+  HINCRBY {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new HIncrByExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * HINCRBYFLOAT key field increment
+   * <p>
+   * Increment the float value of a hash field by the given amount
+   */
+  HINCRBYFLOAT {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new HIncrByFloatExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * HKEYS key
+   * <p>
+   * Get all the fields in a hash
+   */
+  HKEYS {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new HKeysExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * HLEN key
+   * <p>
+   * Get the number of fields in a hash
+   */
+  HLEN {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new HLenExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * HMGET key field [field ...]
+   * <p>
+   * Get the values of all the given hash fields
+   */
+  HMGET {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new HMGetExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * HMSET key field value [field value ...]
+   * <p>
+   * Set multiple hash fields to multiple values
+   */
+  HMSET {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new HMSetExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * HSCAN key cursor [MATCH pattern] [COUNT count]
+   * <p>
+   * Incrementally iterate hash fields and associated values
+   */
+  HSCAN {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new HScanExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_HASH;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * HSET key field value
+   * <p>
+   * Set the string value of a hash field
+
+
+
-  },  
+  },
-   * HSETNX key field value<p>Set the value of a hash field, only if the field does not exist
+   * HSETNX key field value
+   * <p>
+   * Set the value of a hash field, only if the field does not exist
+
+
+
-  },  
+  },
-   * HVALS key<p>Get all the values in a hash
+   * HVALS key
+   * <p>
+   * Get all the values in a hash
+
+
+
-   * PFADD key element [element ...]<p>Adds the specified elements to the specified HyperLogLog
+   * PFADD key element [element ...]
+   * <p>
+   * Adds the specified elements to the specified HyperLogLog
+
+
+
-   * PFCOUNT key [key ...]<p>Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s)
+   * PFCOUNT key [key ...]
+   * <p>
+   * Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s)
+
+
+
-   * PFMERGE destkey sourcekey [sourcekey ...]<p>Merge N different HyperLogLogs into a single one
+   * PFMERGE destkey sourcekey [sourcekey ...]
+   * <p>
+   * Merge N different HyperLogLogs into a single one
+
+
+
-   * LINDEX key index<p>Get an element from a list by its index
+   * LINDEX key index
+   * <p>
+   * Get an element from a list by its index
+
+
+
-  },   
+  },
-   * LINSERT key BEFORE|AFTER pivot value<p>Insert an element before or after another element in a list
+   * LINSERT key BEFORE|AFTER pivot value
+   * <p>
+   * Insert an element before or after another element in a list
+
+
+
-  },   
+  },
-   * LLEN key<p>Get the length of a list
+   * LLEN key
+   * <p>
+   * Get the length of a list
+
+
+
-  },   
+  },
-   * LPOP key<p>Remove and get the first element in a list
+   * LPOP key
+   * <p>
+   * Remove and get the first element in a list
+
+
+
-  },   
+  },
-   * LPUSH key value [value ...]<p>Prepend one or multiple values to a list
+   * LPUSH key value [value ...]
+   * <p>
+   * Prepend one or multiple values to a list
+
+
+
-  },   
+  },
-   * LPUSHX key value<p>Prepend a value to a list, only if the list exists
+   * LPUSHX key value
+   * <p>
+   * Prepend a value to a list, only if the list exists
+
+
+
-  },   
+  },
-   * LRANGE key start stop<p>Get a range of elements from a list
+   * LRANGE key start stop
+   * <p>
+   * Get a range of elements from a list
+
+
+
-  },   
+  },
-   * LREM key count value<p>Remove elements from a list
+   * LREM key count value
+   * <p>
+   * Remove elements from a list
+
+
+
-  },   
+  },
-   * LSET key index value<p>Set the value of an element in a list by its index
+   * LSET key index value
+   * <p>
+   * Set the value of an element in a list by its index
+
+
+
-  },  
+  },
-   * LTRIM key start stop<p>Trim a list to the specified range
+   * LTRIM key start stop
+   * <p>
+   * Trim a list to the specified range
+
+
+
-  },   
+  },
-   * RPOP key<p>Remove and get the last element in a list
+   * RPOP key
+   * <p>
+   * Remove and get the last element in a list
+
+
+
-  },   
+  },
-   * RPUSH key value [value ...]<p>Append one or multiple values to a list
+   * RPUSH key value [value ...]
+   * <p>
+   * Append one or multiple values to a list
+
+
+
-  },   
+  },
-   * RPUSHX key value<p>Append a value to a list, only if the list exists
+   * RPUSHX key value
+   * <p>
+   * Append a value to a list, only if the list exists
+
+
+
-   * SADD key member [member ...]<p>Add one or more members to a set
+   * SADD key member [member ...]
+   * <p>
+   * Add one or more members to a set
+
+
+
-  },   
+  },
-   * SCARD key<p>Get the number of members in a set
+   * SCARD key
+   * <p>
+   * Get the number of members in a set
+
+
+
-  },   
+  },
-   * SDIFF key [key ...]<p>Subtract multiple sets
+   * SDIFF key [key ...]
+   * <p>
+   * Subtract multiple sets
-  SDIFF { 
+  SDIFF {
+
+
+
-  },   
+  },
-   * SDIFFSTORE destination key [key ...]<p>Subtract multiple sets and store the resulting set in a key
+   * SDIFFSTORE destination key [key ...]
+   * <p>
+   * Subtract multiple sets and store the resulting set in a key
+
+
+
-  },   
+  },
-   * SISMEMBER key member<p>Determine if a given value is a member of a set
+   * SISMEMBER key member
+   * <p>
+   * Determine if a given value is a member of a set
+
+
+
-  },   
+  },
-   * SINTER key [key ...]<p>Intersect multiple sets
+   * SINTER key [key ...]
+   * <p>
+   * Intersect multiple sets
+
+
+
-  },   
+  },
-   * SINTERSTORE destination key [key ...]<p>Intersect multiple sets and store the resulting set in a key
+   * SINTERSTORE destination key [key ...]
+   * <p>
+   * Intersect multiple sets and store the resulting set in a key
+
+
+
-  },   
+  },
-   * SMEMBERS key<p>Get all the members in a set
+   * SMEMBERS key
+   * <p>
+   * Get all the members in a set
+
+
+
-  },   
+  },
-   * SMOVE source destination member<p>Move a member from one set to another
+   * SMOVE source destination member
+   * <p>
+   * Move a member from one set to another
+
+
+
-  }, 
+  },
-   * SPOP key<p>Remove and return a random member from a set
+   * SPOP key
+   * <p>
+   * Remove and return a random member from a set
+
+
+
-  }, 
+  },
-   * SRANDMEMBER key [count]<p>Get one or multiple random members from a set
+   * SRANDMEMBER key [count]
+   * <p>
+   * Get one or multiple random members from a set
+
+
+
-  }, 
+  },
-   * SUNION key [key ...]<p>Add multiple sets
+   * SUNION key [key ...]
+   * <p>
+   * Add multiple sets
+
+
+
-  },   
+  },
-   * SUNIONSTORE destination key [key ...]<p>Add multiple sets and store the resulting set in a key
+   * SUNIONSTORE destination key [key ...]
+   * <p>
+   * Add multiple sets and store the resulting set in a key
+
+
+
-   * SSCAN key cursor [MATCH pattern] [COUNT count]<p>Incrementally iterate Set elements
+   * SSCAN key cursor [MATCH pattern] [COUNT count]
+   * <p>
+   * Incrementally iterate Set elements
+
+
+
-   * SREM key member [member ...]<p>Remove one or more members from a set
+   * SREM key member [member ...]
+   * <p>
+   * Remove one or more members from a set
+
+
+
-   * ZADD key score member [score member ...]<p>Add one or more members to a sorted set, or update its score if it already exists
+   * ZADD key score member [score member ...]
+   * <p>
+   * Add one or more members to a sorted set, or update its score if it already exists
+
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-  /**
-   * ZCARD key<p>Get the number of members in a sorted set
-   */
-  ZCARD {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZCardExecutor();
-      }
-      return executor;
-    }
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-  /**
-   * ZCOUNT key min max<p>Count the members in a sorted set with scores within the given values
-   */
-  ZCOUNT {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZCountExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-
-  /**
-   * ZINCRBY key increment member<p>Increment the score of a member in a sorted set
-   */
-  ZINCRBY {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZIncrByExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-
-  /**
-   * ZLEXCOUNT key min max<p>Count the number of members in a sorted set between a given lexicographical range
-   */
-  ZLEXCOUNT {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZLexCountExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-
-  /**
-   * ZRANGE key start stop [WITHSCORES]<p>Return a range of members in a sorted set, by index
-   */
-  ZRANGE {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZRangeExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-
-  /**
-   * ZRANGEBYLEX key min max [LIMIT offset count]<p>Return a range of members in a sorted set, by lexicographical range
-   */
-  ZRANGEBYLEX {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZRangeByLexExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-
-  /**
-   * ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]<p>Return a range of members in a sorted set, by score
-   */
-  ZRANGEBYSCORE {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZRangeByScoreExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-
-  /**
-   * ZREVRANGE key start stop [WITHSCORES]<p>Return a range of members in a sorted set, by index, with scores ordered from high to low
-   */
-  ZREVRANGE {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZRevRangeExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-
-  /**
-   * ZRANK key member<p>Determine the index of a member in a sorted set
-   */
-  ZRANK {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZRankExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-
-  /**
-   * ZREM key member [member ...]<p>Remove one or more members from a sorted set
-   */
-  ZREM {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZRemExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-
-  /**
-   * ZREMRANGEBYLEX key min max<p>Remove all members in a sorted set between the given lexicographical range
-   */
-  ZREMRANGEBYLEX {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZRemRangeByLexExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-
-  /**
-   * ZREMRANGEBYRANK key start stop<p>Remove all members in a sorted set within the given indexes
-   */
-  ZREMRANGEBYRANK {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZRemRangeByRankExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-
-  /**
-   * ZREMRANGEBYSCORE key min max<p>Remove all members in a sorted set within the given scores
-   */
-  ZREMRANGEBYSCORE {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZRemRangeByScoreExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-
-  /**
-   * ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]<p>Return a range of members in a sorted set, by score, with scores ordered from high to low
-   */
-  ZREVRANGEBYSCORE {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZRevRangeByScoreExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-
-  /**
-   * ZREVRANK key member<p>Determine the index of a member in a sorted set, with scores ordered from high to low
-   */
-  ZREVRANK {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZRevRankExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },  
-
-  /**
-   * ZSCAN key cursor [MATCH pattern] [COUNT count]<P>Incrementally iterate sorted sets elements and associated scores
-   */
-  ZSCAN {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new ZScanExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
-   * ZSCORE key member<p>Get the score associated with the given member in a sorted set
+   * ZCARD key
+   * <p>
+   * Get the number of members in a sorted set
+   */
+  ZCARD {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZCardExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZCOUNT key min max
+   * <p>
+   * Count the members in a sorted set with scores within the given values
+   */
+  ZCOUNT {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZCountExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZINCRBY key increment member
+   * <p>
+   * Increment the score of a member in a sorted set
+   */
+  ZINCRBY {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZIncrByExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZLEXCOUNT key min max
+   * <p>
+   * Count the number of members in a sorted set between a given lexicographical range
+   */
+  ZLEXCOUNT {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZLexCountExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZRANGE key start stop [WITHSCORES]
+   * <p>
+   * Return a range of members in a sorted set, by index
+   */
+  ZRANGE {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZRangeExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZRANGEBYLEX key min max [LIMIT offset count]
+   * <p>
+   * Return a range of members in a sorted set, by lexicographical range
+   */
+  ZRANGEBYLEX {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZRangeByLexExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]
+   * <p>
+   * Return a range of members in a sorted set, by score
+   */
+  ZRANGEBYSCORE {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZRangeByScoreExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZREVRANGE key start stop [WITHSCORES]
+   * <p>
+   * Return a range of members in a sorted set, by index, with scores ordered from high to low
+   */
+  ZREVRANGE {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZRevRangeExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZRANK key member
+   * <p>
+   * Determine the index of a member in a sorted set
+   */
+  ZRANK {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZRankExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZREM key member [member ...]
+   * <p>
+   * Remove one or more members from a sorted set
+   */
+  ZREM {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZRemExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZREMRANGEBYLEX key min max
+   * <p>
+   * Remove all members in a sorted set between the given lexicographical range
+   */
+  ZREMRANGEBYLEX {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZRemRangeByLexExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZREMRANGEBYRANK key start stop
+   * <p>
+   * Remove all members in a sorted set within the given indexes
+   */
+  ZREMRANGEBYRANK {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZRemRangeByRankExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZREMRANGEBYSCORE key min max
+   * <p>
+   * Remove all members in a sorted set within the given scores
+   */
+  ZREMRANGEBYSCORE {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZRemRangeByScoreExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]
+   * <p>
+   * Return a range of members in a sorted set, by score, with scores ordered from high to low
+   */
+  ZREVRANGEBYSCORE {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZRevRangeByScoreExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZREVRANK key member
+   * <p>
+   * Determine the index of a member in a sorted set, with scores ordered from high to low
+   */
+  ZREVRANK {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZRevRankExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZSCAN key cursor [MATCH pattern] [COUNT count]
+   * <P>
+   * Incrementally iterate sorted sets elements and associated scores
+   */
+  ZSCAN {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new ZScanExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.REDIS_SORTEDSET;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * ZSCORE key member
+   * <p>
+   * Get the score associated with the given member in a sorted set
+
+
+
-   * DISCARD<p>Discard all commands issued after MULTI
+   * DISCARD
+   * <p>
+   * Discard all commands issued after MULTI
+
+
+
-   * EXEC<p>Execute all commands issued after MULTI
+   * EXEC
+   * <p>
+   * Execute all commands issued after MULTI
+
+
+
-   * MULTI<p>Mark the start of a transaction block
+   * MULTI
+   * <p>
+   * Mark the start of a transaction block
+
+
+
-   * UNWATCH<p>Forget about all watched keys
+   * UNWATCH
+   * <p>
+   * Forget about all watched keys
+
+
+
-   * WATCH key [key ...]<p>Watch the given keys to determine execution of the MULTI/EXEC block
+   * WATCH key [key ...]
+   * <p>
+   * Watch the given keys to determine execution of the MULTI/EXEC block
+
+
+
-   * DBSIZE<p>Return the number of keys in the selected database
+   * DBSIZE
+   * <p>
+   * Return the number of keys in the selected database
+
-    private final RedisDataType dataType = RedisDataType.NONE;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  }, 
-  /**
-   * ECHO message<p>Echo the given string
-   */
-  ECHO {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new EchoExecutor();
-      }
-      return executor;
-    }
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  }, 
-  /**
-   * TIME <p>Return the current server time
-   */
-  TIME {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new TimeExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.NONE;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  }, 
-
-  /**
-   * PING<p>Ping the server
-   */
-  PING {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new PingExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.NONE;
-    @Override
-    public RedisDataType getDataType() {
-      return this.dataType;
-    }
-  },   
-
-  /**
-   * QUIT<p>Close the connection
-   */
-  QUIT {
-    private Executor executor;
-    @Override
-    public Executor getExecutor() {
-      if (executor == null) {
-        executor = new QuitExecutor();
-      }
-      return executor;
-    }
-    private final RedisDataType dataType = RedisDataType.NONE;
-   * SHUTDOWN<p>Shut down the server
+   * ECHO message
+   * <p>
+   * Echo the given string
+   */
+  ECHO {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new EchoExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.NONE;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * TIME
+   * <p>
+   * Return the current server time
+   */
+  TIME {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new TimeExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.NONE;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * PING
+   * <p>
+   * Ping the server
+   */
+  PING {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new PingExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.NONE;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * QUIT
+   * <p>
+   * Close the connection
+   */
+  QUIT {
+    private Executor executor;
+
+    @Override
+    public Executor getExecutor() {
+      if (executor == null) {
+        executor = new QuitExecutor();
+      }
+      return executor;
+    }
+
+    private final RedisDataType dataType = RedisDataType.NONE;
+
+    @Override
+    public RedisDataType getDataType() {
+      return this.dataType;
+    }
+  },
+
+  /**
+   * SHUTDOWN
+   * <p>
+   * Shut down the server
+
+
+
+
+
+
-   * Abstract method overridden by each value in enum
-   * to get the executor associated with that command type
+   * Abstract method overridden by each value in enum to get the executor associated with that
+   * command type
-  private RedisCommandType (RedisDataType dataType) {
-    this.dataType = dataType;
-  }
+   * private RedisCommandType (RedisDataType dataType) { this.dataType = dataType; }

GEODE-2267: enable gfsh to download file from http connection (GEODE-2418)

-import java.io.BufferedInputStream;
-import java.io.BufferedReader;
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.OutputStream;
-import java.io.PrintWriter;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-import java.text.MessageFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.zip.DataFormatException;
-import java.util.zip.GZIPInputStream;
-import javax.management.ObjectName;
-
+import org.apache.commons.lang.StringUtils;
-import org.apache.geode.management.internal.cli.util.MergeLogs;
-
+import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.PrintWriter;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.text.MessageFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.zip.DataFormatException;
+import java.util.zip.GZIPInputStream;
+import javax.management.ObjectName;
+
+  private final static Logger logger = LogService.getLogger();
-    Cache cache = CacheFactory.getAnyInstance();
-    LogWriter logger = cache.getLogger();
-  @CliMetaData(shellOnly = false,
+  @CliMetaData(shellOnly = false, isFileDownloadOverHttp = true,
+      interceptor = "org.apache.geode.management.internal.cli.commands.MiscellaneousCommands$ExportLogsInterceptor",
-          mandatory = true) String dirName,
+          mandatory = false) String dirName,
-    Logger logger = LogService.getLogger();
-
-      GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
-
-      Set<DistributedMember> targetMembers = CliUtil.findMembersIncludingLocators(groups, memberIds);
+      Set<DistributedMember> targetMembers =
+          CliUtil.findMembersIncludingLocators(groups, memberIds);
-        CliUtil.executeFunction(new ExportLogsFunction(),
+        CliUtil
+            .executeFunction(new ExportLogsFunction(),
-      Path exportedLogsZipFile = workingDir.resolve("exportedLogs[" + System.currentTimeMillis() + "].zip").toAbsolutePath();
+      Path exportedLogsZipFile = workingDir
+          .resolve("exportedLogs_" + System.currentTimeMillis() + ".zip").toAbsolutePath();
-      result = ResultBuilder.createInfoResult("File exported to: " + exportedLogsZipFile.toString());
+      result = ResultBuilder.createInfoResult(exportedLogsZipFile.toString());
-      ex.printStackTrace();
-
-    LogWrapper.getInstance().fine("Exporting logs returning =" + result);
+    logger.debug("Exporting logs returning = {}", result);
-
+  /**
+   * after the export logs, will need to copy the tempFile to the desired location and delete the
+   * temp file.
+   */
+  public static class ExportLogsInterceptor extends AbstractCliAroundInterceptor {
+    @Override
+    public Result postExecution(GfshParseResult parseResult, Result commandResult, Path tempFile) {
+      // in the command over http case, the command result is in the downloaded temp file
+      if (tempFile != null) {
+        Path dirPath;
+        String dirName = parseResult.getParamValueStrings().get("dir");
+        if (StringUtils.isBlank(dirName)) {
+          dirPath = Paths.get(System.getProperty("user.dir"));
+        } else {
+          dirPath = Paths.get(dirName);
+        }
+        String fileName = "exportedLogs_" + System.currentTimeMillis() + ".zip";
+        File exportedLogFile = dirPath.resolve(fileName).toFile();
+        try {
+          FileUtils.copyFile(tempFile.toFile(), exportedLogFile);
+          FileUtils.deleteQuietly(tempFile.toFile());
+          commandResult = ResultBuilder
+              .createInfoResult("Logs exported to: " + exportedLogFile.getAbsolutePath());
+        } catch (IOException e) {
+          logger.error(e.getMessage(), e);
+          commandResult = ResultBuilder.createGemFireErrorResult(e.getMessage());
+        }
+      } else {
+        commandResult = ResultBuilder.createInfoResult(
+            "Logs exported to the connected member's file system: " + commandResult.nextLine());
+      }
+      return commandResult;
+    }
+  }
-
-
-      return ResultBuilder.createGemFireErrorResult("#SB" + CliUtil.stackTraceAsString(e));
+      logger.error(e.getMessage(), e);
+      return ResultBuilder.createGemFireErrorResult(CliUtil.stackTraceAsString(e));

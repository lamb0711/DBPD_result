Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A Java type is an instance of java.lang.reflect.Type representing all types
- * in Java.
+ * A Java type is an instance of java.lang.reflect.Type representing all types in Java.
- * Each Type is associated with an OpenTypeConverter. The OpenTypeConverter
- * defines an OpenType corresponding to the Type, plus a Java class
- * corresponding to the OpenType. For example:
+ * Each Type is associated with an OpenTypeConverter. The OpenTypeConverter defines an OpenType
+ * corresponding to the Type, plus a Java class corresponding to the OpenType. For example:
- * Apart from simple types, arrays, and collections, Java types are converted
- * through introspection into CompositeType
+ * Apart from simple types, arrays, and collections, Java types are converted through introspection
+ * into CompositeType
-   * getOpenType().getClassName(), except that it may be a primitive type or an
-   * array of primitive type.
+   * getOpenType().getClassName(), except that it may be a primitive type or an array of primitive
+   * type.
-  private static final class ConverterMap extends
-      WeakHashMap<Type, WeakReference<OpenTypeConverter>> {
+  private static final class ConverterMap
+      extends WeakHashMap<Type, WeakReference<OpenTypeConverter>> {
-  private final static Map<Type, Type> inProgress = OpenTypeUtil
-      .newIdentityHashMap();
+  private final static Map<Type, Type> inProgress = OpenTypeUtil.newIdentityHashMap();
-   * Following List simply serves to keep a reference to predefined
-   * OpenConverters so they don't get garbage collected.
+   * Following List simply serves to keep a reference to predefined OpenConverters so they don't get
+   * garbage collected.
-  private static final List<OpenTypeConverter> preDefinedConverters = OpenTypeUtil
-      .newList();
+  private static final List<OpenTypeConverter> preDefinedConverters = OpenTypeUtil.newList();
-  protected OpenTypeConverter(Type targetType, OpenType openType,
-      Class openClass) {
+  protected OpenTypeConverter(Type targetType, OpenType openType, Class openClass) {
-  abstract Object fromNonNullOpenValue(Object value)
-      throws InvalidObjectException;
+  abstract Object fromNonNullOpenValue(Object value) throws InvalidObjectException;
-   * Throw an appropriate InvalidObjectException if we will not be able to
-   * convert back from the open data to the original Java object.
+   * Throw an appropriate InvalidObjectException if we will not be able to convert back from the
+   * open data to the original Java object.
-   * @return True if and only if this OpenTypeConverter's toOpenValue and
-   *         fromOpenValue methods are the identity function.
+   * @return True if and only if this OpenTypeConverter's toOpenValue and fromOpenValue methods are
+   *         the identity function.
-  private static synchronized void putConverter(Type type,
-      OpenTypeConverter conv) {
-    WeakReference<OpenTypeConverter> wr = new WeakReference<OpenTypeConverter>(
-        conv);
+  private static synchronized void putConverter(Type type, OpenTypeConverter conv) {
+    WeakReference<OpenTypeConverter> wr = new WeakReference<OpenTypeConverter>(conv);
-  private static synchronized void putPreDefinedConverter(Type type,
-      OpenTypeConverter conv) {
+  private static synchronized void putPreDefinedConverter(Type type, OpenTypeConverter conv) {
-    final OpenType[] simpleTypes = { BIGDECIMAL, BIGINTEGER, BOOLEAN, BYTE,
-        CHARACTER, DATE, DOUBLE, FLOAT, INTEGER, LONG, OBJECTNAME, SHORT,
-        STRING, VOID, };
+    final OpenType[] simpleTypes = {BIGDECIMAL, BIGINTEGER, BOOLEAN, BYTE, CHARACTER, DATE, DOUBLE,
+        FLOAT, INTEGER, LONG, OBJECTNAME, SHORT, STRING, VOID,};
-        c = Class.forName(t.getClassName(), false, ObjectName.class
-            .getClassLoader());
+        c = Class.forName(t.getClassName(), false, ObjectName.class.getClassLoader());
-          final OpenTypeConverter primitiveConv = new IdentityConverter(
-              primitiveType, t, primitiveType);
+          final OpenTypeConverter primitiveConv =
+              new IdentityConverter(primitiveType, t, primitiveType);
-            final Class primitiveArrayType = Array
-                .newInstance(primitiveType, 0).getClass();
-            final OpenType primitiveArrayOpenType = ArrayType
-                .getPrimitiveArrayType(primitiveArrayType);
-            final OpenTypeConverter primitiveArrayConv = new IdentityConverter(
-                primitiveArrayType, primitiveArrayOpenType, primitiveArrayType);
+            final Class primitiveArrayType = Array.newInstance(primitiveType, 0).getClass();
+            final OpenType primitiveArrayOpenType =
+                ArrayType.getPrimitiveArrayType(primitiveArrayType);
+            final OpenTypeConverter primitiveArrayConv = new IdentityConverter(primitiveArrayType,
+                primitiveArrayOpenType, primitiveArrayType);
-  public static synchronized OpenTypeConverter toConverter(Type objType)
-      throws OpenDataException {
+  public static synchronized OpenTypeConverter toConverter(Type objType) throws OpenDataException {
-      throw new OpenDataException("Recursive data structure, including "
-          + typeName(objType));
+      throw new OpenDataException("Recursive data structure, including " + typeName(objType));
-  private static OpenTypeConverter makeConverter(Type objType)
-      throws OpenDataException {
+  private static OpenTypeConverter makeConverter(Type objType) throws OpenDataException {
-      Type componentType = ((GenericArrayType) objType)
-          .getGenericComponentType();
+      Type componentType = ((GenericArrayType) objType).getGenericComponentType();
-            new ManagementException(
-                " MXBean as an Return Type is not supported"));
+            new ManagementException(" MXBean as an Return Type is not supported"));
-  private static <T extends Enum<T>> OpenTypeConverter makeEnumConverter(
-      Class<T> enumClass) {
+  private static <T extends Enum<T>> OpenTypeConverter makeEnumConverter(Class<T> enumClass) {
-  private static OpenTypeConverter makeArrayOrCollectionConverter(
-      Type collectionType, Type elementType) throws OpenDataException {
+  private static OpenTypeConverter makeArrayOrCollectionConverter(Type collectionType,
+      Type elementType) throws OpenDataException {
-      return new CollectionConverter(collectionType, openType, openArrayClass,
-          elementConverter);
+      return new CollectionConverter(collectionType, openType, openArrayClass, elementConverter);
-        return new ArrayConverter(collectionType, openType, openArrayClass,
-            elementConverter);
+        return new ArrayConverter(collectionType, openType, openArrayClass, elementConverter);
-  protected static final String[] keyArray = { "key" };
-  protected static final String[] keyValueArray = { "key", "value" };
+  protected static final String[] keyArray = {"key"};
+  protected static final String[] keyValueArray = {"key", "value"};
-  private static OpenTypeConverter makeTabularConverter(Type objType,
-      boolean sortedMap, Type keyType, Type valueType) throws OpenDataException {
+  private static OpenTypeConverter makeTabularConverter(Type objType, boolean sortedMap,
+      Type keyType, Type valueType) throws OpenDataException {
-    final CompositeType rowType = new CompositeType(objTypeName, objTypeName,
-        keyValueArray, keyValueArray, new OpenType[] { keyOpenType,
-            valueOpenType });
-    final TabularType tabularType = new TabularType(objTypeName, objTypeName,
-        rowType, keyArray);
-    return new TableConverter(objType, sortedMap, tabularType, keyConverter,
-        valueConverter);
+    final CompositeType rowType = new CompositeType(objTypeName, objTypeName, keyValueArray,
+        keyValueArray, new OpenType[] {keyOpenType, valueOpenType});
+    final TabularType tabularType = new TabularType(objTypeName, objTypeName, rowType, keyArray);
+    return new TableConverter(objType, sortedMap, tabularType, keyConverter, valueConverter);
-   * Subclasses of the above types wont be supported as deserialize info wont be
-   * there.
+   * Subclasses of the above types wont be supported as deserialize info wont be there.
-   * Queue<E> won't be supported as Queue is more of a functional data structure
-   * rather than a data holder
+   * Queue<E> won't be supported as Queue is more of a functional data structure rather than a data
+   * holder
-  private static OpenTypeConverter makeParameterizedConverter(
-      ParameterizedType objType) throws OpenDataException {
+  private static OpenTypeConverter makeParameterizedConverter(ParameterizedType objType)
+      throws OpenDataException {
-          Type[] actuals = ((ParameterizedType) objType)
-              .getActualTypeArguments();
+          Type[] actuals = ((ParameterizedType) objType).getActualTypeArguments();
-          return makeTabularConverter(objType, sortedMap, actuals[0],
-              actuals[1]);
+          return makeTabularConverter(objType, sortedMap, actuals[0], actuals[1]);
-  private static OpenTypeConverter makeCompositeConverter(Class c)
-      throws OpenDataException {
+  private static OpenTypeConverter makeCompositeConverter(Class c) throws OpenDataException {
-      Method old = getterMap.put(OpenTypeUtil.decapitalize(propertyName),
-          method);
+      Method old = getterMap.put(OpenTypeUtil.decapitalize(propertyName), method);
-        final String msg = "Class " + c.getName() + " has method name clash: "
-            + old.getName() + ", " + method.getName();
+        final String msg = "Class " + c.getName() + " has method name clash: " + old.getName()
+            + ", " + method.getName();
-      throw new OpenDataException("Can't map " + c.getName()
-          + " to an open data type");
+      throw new OpenDataException("Can't map " + c.getName() + " to an open data type");
-    CompositeType compositeType = new CompositeType(c.getName(), c.getName(),
-        itemNames, // field names
+    CompositeType compositeType = new CompositeType(c.getName(), c.getName(), itemNames, // field
+                                                                                         // names
-   * Converts from a CompositeData to an instance of the targetClass Various
-   * subclasses override its functionality.
+   * Converts from a CompositeData to an instance of the targetClass Various subclasses override its
+   * functionality.
-     * If the subclass should be appropriate but there is a problem, then the
-     * method throws InvalidObjectException.
+     * If the subclass should be appropriate but there is a problem, then the method throws
+     * InvalidObjectException.
-     * @return If the subclass is appropriate for targetClass, then the method
-     *         returns null. If the subclass is not appropriate, then the method
-     *         returns an explanation of why not.
+     * @return If the subclass is appropriate for targetClass, then the method returns null. If the
+     *         subclass is not appropriate, then the method returns an explanation of why not.
-   * Builder if the target class has a method "public static
-   * from(CompositeData)"
+   * Builder if the target class has a method "public static from(CompositeData)"
-        Method fromMethod = targetClass.getMethod("from",
-            new Class[] { CompositeData.class });
+        Method fromMethod = targetClass.getMethod("from", new Class[] {CompositeData.class});
-              + typeName(fromMethod.getReturnType()) + " not "
-              + typeName(targetClass);
+              + typeName(fromMethod.getReturnType()) + " not " + typeName(targetClass);
-   * This builder never actually returns success. It simply serves to check
-   * whether the other builders in the same group have any chance of success. If
-   * any getter in the targetClass returns a type that we don't know how to
-   * reconstruct, then we will not be able to make a builder, and there is no
-   * point in repeating the error about the problematic getter as many times as
-   * there are candidate builders. Instead, the "applicable" method will return
-   * an explanatory string, and the other builders will be skipped. If all the
-   * getters are OK, then the "applicable" method will return an empty string
-   * and the other builders will be tried.
+   * This builder never actually returns success. It simply serves to check whether the other
+   * builders in the same group have any chance of success. If any getter in the targetClass returns
+   * a type that we don't know how to reconstruct, then we will not be able to make a builder, and
+   * there is no point in repeating the error about the problematic getter as many times as there
+   * are candidate builders. Instead, the "applicable" method will return an explanatory string, and
+   * the other builders will be skipped. If all the getters are OK, then the "applicable" method
+   * will return an empty string and the other builders will be tried.
-          return "not all getters have corresponding setters " + "(" + getter
-              + ")";
+          return "not all getters have corresponding setters " + "(" + getter + ")";
-    Object fromCompositeData(CompositeData cd, String[] itemNames,
-        OpenTypeConverter[] converters) throws InvalidObjectException {
+    Object fromCompositeData(CompositeData cd, String[] itemNames, OpenTypeConverter[] converters)
+        throws InvalidObjectException {
-   * Builder if the target class has a constructor that is annotated with @ConstructorProperties
-   * so we can derive the corresponding getters.
+   * Builder if the target class has a constructor that is annotated with @ConstructorProperties so
+   * we can derive the corresponding getters.
-  protected static final class CompositeBuilderViaConstructor extends
-      CompositeBuilder {
+  protected static final class CompositeBuilderViaConstructor extends CompositeBuilder {
-        String[] propertyNames = ((ConstructorProperties) constr
-            .getAnnotation(propertyNamesClass)).value();
+        String[] propertyNames =
+            ((ConstructorProperties) constr.getAnnotation(propertyNamesClass)).value();
-                msg += " (differs only in case from property " + getterName
-                    + ")";
+                msg += " (differs only in case from property " + getterName + ")";
-            final String msg = "@ConstructorProperties contains property "
-                + propertyName + " more than once: " + constr;
+            final String msg = "@ConstructorProperties contains property " + propertyName
+                + " more than once: " + constr;
-            final String msg = "@ConstructorProperties gives property "
-                + propertyName + " of type " + propertyType + " for parameter "
-                + " of type " + paramTypes[i] + ": " + constr;
+            final String msg = "@ConstructorProperties gives property " + propertyName + " of type "
+                + propertyType + " for parameter " + " of type " + paramTypes[i] + ": " + constr;
-              + "annotation with this set of names: "
-              + Arrays.toString(propertyNames);
+              + "annotation with this set of names: " + Arrays.toString(propertyNames);
-    Object fromCompositeData(CompositeData cd, String[] itemNames,
-        OpenTypeConverter[] converters) throws InvalidObjectException {
+    Object fromCompositeData(CompositeData cd, String[] itemNames, OpenTypeConverter[] converters)
+        throws InvalidObjectException {
-        final String msg = "Exception constructing "
-            + getTargetClass().getName();
+        final String msg = "Exception constructing " + getTargetClass().getName();
-   * Builder if the target class is an interface and contains no methods other
-   * than getters. Then we can make an instance using a dynamic proxy that
-   * forwards the getters to the source CompositeData
+   * Builder if the target class is an interface and contains no methods other than getters. Then we
+   * can make an instance using a dynamic proxy that forwards the getters to the source
+   * CompositeData
-  protected static final class CompositeBuilderViaProxy extends
-      CompositeBuilder {
+  protected static final class CompositeBuilderViaProxy extends CompositeBuilder {
-      Set<Method> methods = OpenTypeUtil.newSet(Arrays.asList(targetClass
-          .getMethods()));
+      Set<Method> methods = OpenTypeUtil.newSet(Arrays.asList(targetClass.getMethods()));
-      return Proxy.newProxyInstance(targetClass.getClassLoader(),
-          new Class[] { targetClass }, new CompositeDataInvocationHandler(cd));
+      return Proxy.newProxyInstance(targetClass.getClassLoader(), new Class[] {targetClass},
+          new CompositeDataInvocationHandler(cd));
-  static InvalidObjectException invalidObjectException(String msg,
-      Throwable cause) {
+  static InvalidObjectException invalidObjectException(String msg, Throwable cause) {
-  static void mustBeComparable(Class collection, Type element)
-      throws OpenDataException {
-    if (!(element instanceof Class)
-        || !Comparable.class.isAssignableFrom((Class<?>) element)) {
-      final String msg = "Parameter class " + element + " of "
-          + collection.getName() + " does not implement "
-          + Comparable.class.getName();
+  static void mustBeComparable(Class collection, Type element) throws OpenDataException {
+    if (!(element instanceof Class) || !Comparable.class.isAssignableFrom((Class<?>) element)) {
+      final String msg = "Parameter class " + element + " of " + collection.getName()
+          + " does not implement " + Comparable.class.getName();

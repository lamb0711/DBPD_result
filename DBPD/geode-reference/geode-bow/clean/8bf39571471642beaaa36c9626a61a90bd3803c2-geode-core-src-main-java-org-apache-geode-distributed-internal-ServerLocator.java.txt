Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-  private Map<ServerLocation, DistributedMember> ownerMap = new HashMap<ServerLocation, DistributedMember>();
+  private Map<ServerLocation, DistributedMember> ownerMap =
+      new HashMap<ServerLocation, DistributedMember>();
-  
+
-  private static final long SERVER_LOAD_LOG_INTERVAL = (60 * 60 * 1000); // log server load once an hour
-  
+  private static final long SERVER_LOAD_LOG_INTERVAL = (60 * 60 * 1000); // log server load once an
+                                                                         // hour
+
-  
+
-    this.hostNameForClients= this.hostName;
+    this.hostNameForClients = this.hostName;
-  
-  public ServerLocator(int port,
-                       InetAddress bindAddress,
-                       String hostNameForClients,
-                       File logFile,
-                       ProductUseLog productUseLogWriter,
-                       String memberName,
-                       InternalDistributedSystem ds,
-                       LocatorStats stats)
-    throws IOException
-  {
+
+  public ServerLocator(int port, InetAddress bindAddress, String hostNameForClients, File logFile,
+      ProductUseLog productUseLogWriter, String memberName, InternalDistributedSystem ds,
+      LocatorStats stats) throws IOException {
-      this.hostName= bindAddress.getHostAddress();
+      this.hostName = bindAddress.getHostAddress();
-      this.hostNameForClients= this.hostName;
+      this.hostNameForClients = this.hostName;
-    
+
-    this.advisor = ControllerAdvisor.createControllerAdvisor(this); // escapes constructor but allows field to be final
+    this.advisor = ControllerAdvisor.createControllerAdvisor(this); // escapes constructor but
+                                                                    // allows field to be final
-  
+
-  
+
-   * A ServerLocator may be in place but non-functional during auto-reconnect
-   * because peer location services have been initialized while the servers
-   * reconnect but server location services aren't reconnected until a cache
-   * is available
+   * A ServerLocator may be in place but non-functional during auto-reconnect because peer location
+   * services have been initialized while the servers reconnect but server location services aren't
+   * reconnected until a cache is available
-    
-    if(logger.isDebugEnabled()) {
+
+    if (logger.isDebugEnabled()) {
-    if ( ! (request instanceof ServerLocationRequest) ) {
-      throw new InternalGemFireException("Expected ServerLocationRequest, got " + request.getClass());
+    if (!(request instanceof ServerLocationRequest)) {
+      throw new InternalGemFireException(
+          "Expected ServerLocationRequest, got " + request.getClass());
-    int id = ((DataSerializableFixedID)request).getDSFID();
+    int id = ((DataSerializableFixedID) request).getDSFID();
-        response = new LocatorStatusResponse()
-          .initialize(this.port, this.hostName, this.logFile, this.memberName);
+        response = new LocatorStatusResponse().initialize(this.port, this.hostName, this.logFile,
+            this.memberName);
-    if(logger.isDebugEnabled()) {
+    if (logger.isDebugEnabled()) {
-    ServerLocation location = loadSnapshot.getServerForConnection(clientRequest
-        .getServerGroup(), clientRequest.getExcludedServers());
+    ServerLocation location = loadSnapshot.getServerForConnection(clientRequest.getServerGroup(),
+        clientRequest.getExcludedServers());
-    ServerLocation location = loadSnapshot
-      .getReplacementServerForConnection(clientRequest.getCurrentServer(),
-                                         clientRequest.getServerGroup(),
-                                         clientRequest.getExcludedServers());
+    ServerLocation location =
+        loadSnapshot.getReplacementServerForConnection(clientRequest.getCurrentServer(),
+            clientRequest.getServerGroup(), clientRequest.getExcludedServers());
-  
-  private GetAllServersResponse pickAllServers(
-      GetAllServersRequest clientRequest) {
+
+  private GetAllServersResponse pickAllServers(GetAllServersRequest clientRequest) {
-  
+
-  
+
-    
+
-    
+
-    if(clientRequest.isFindDurable() && clientRequest.getProxyId().isDurable()) {
-      servers = FindDurableQueueProcessor.sendAndFind(this, clientRequest.getProxyId(), getDistributionManager());
+    if (clientRequest.isFindDurable() && clientRequest.getProxyId().isDurable()) {
+      servers = FindDurableQueueProcessor.sendAndFind(this, clientRequest.getProxyId(),
+          getDistributionManager());
-      durableQueueFound = servers.size()>0;
+      durableQueueFound = servers.size() > 0;
-    
+
-    if(clientRequest.getRedundantCopies() == -1) {
+    if (clientRequest.getRedundantCopies() == -1) {
-                                                   clientRequest.getServerGroup(),
-                                                   excludedServers,-1);
-    } else if(clientRequest.getRedundantCopies() > servers.size()) {
+          clientRequest.getServerGroup(), excludedServers, -1);
+    } else if (clientRequest.getRedundantCopies() > servers.size()) {
-                                                   clientRequest.getServerGroup(),
-                                                   excludedServers,
-                                                   count);
+          clientRequest.getServerGroup(), excludedServers, count);
-   
-    if(candidates.size()>1) {
-       Collections.shuffle(candidates);
-     }
+
+    if (candidates.size() > 1) {
+      Collections.shuffle(candidates);
+    }
-    
+
-  public void restarting(DistributedSystem ds, GemFireCache cache, SharedConfiguration sharedConfig) {
+  public void restarting(DistributedSystem ds, GemFireCache cache,
+      SharedConfiguration sharedConfig) {
-      this.ds = (InternalDistributedSystem)ds;
-      this.advisor = ControllerAdvisor.createControllerAdvisor(this); // escapes constructor but allows field to be final
+      this.ds = (InternalDistributedSystem) ds;
+      this.advisor = ControllerAdvisor.createControllerAdvisor(this); // escapes constructor but
+                                                                      // allows field to be final
-        this.advisor.handshake();  // GEODE-1393: need to get server information during restart
+        this.advisor.handshake(); // GEODE-1393: need to get server information during restart
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-    ControllerProfile cp = (ControllerProfile)profile;
+    ControllerProfile cp = (ControllerProfile) profile;
-  
+
+
-  
-  public void endRequest(Object request,long startTime) {
+
+  public void endRequest(Object request, long startTime) {
-  
-  public void endResponse(Object request,long startTime) {
+
+  public void endResponse(Object request, long startTime) {
-  
-  
+
+
-    if(cachedLocators != null) {
+    if (cachedLocators != null) {
-    }
-    else {
-      synchronized(cachedLocatorsLock) {
+    } else {
+      synchronized (cachedLocatorsLock) {
-        for (ControllerProfile profile: profiles) {
+        for (ControllerProfile profile : profiles) {
-        result.add(new ServerLocation(hostNameForClients,port));
+        result.add(new ServerLocation(hostNameForClients, port));
-  
+
-  
+
-    if(profile instanceof CacheServerProfile) {
+    if (profile instanceof CacheServerProfile) {
-      loadSnapshot.addServer(location, groups,
-                             bp.getInitialLoad(),
-                             bp.getLoadPollInterval());
-      if(logger.isDebugEnabled()) {
-        logger.debug("ServerLocator: Received load from a new server {}, {}", location, bp.getInitialLoad());
+      loadSnapshot.addServer(location, groups, bp.getInitialLoad(), bp.getLoadPollInterval());
+      if (logger.isDebugEnabled()) {
+        logger.debug("ServerLocator: Received load from a new server {}, {}", location,
+            bp.getInitialLoad());
-      synchronized(ownerMap) {
+      synchronized (ownerMap) {
-    if(profile instanceof CacheServerProfile) {
+    if (profile instanceof CacheServerProfile) {
-      //InternalDistributedMember id = bp.getDistributedMember();
+      // InternalDistributedMember id = bp.getDistributedMember();
-      if(logger.isDebugEnabled()) {
+      if (logger.isDebugEnabled()) {
-      synchronized(ownerMap) {
+      synchronized (ownerMap) {
-    getLogWriterI18n().warning(LocalizedStrings.ServerLocator_SERVERLOCATOR_UNEXPECTED_PROFILE_UPDATE);
+    getLogWriterI18n()
+        .warning(LocalizedStrings.ServerLocator_SERVERLOCATOR_UNEXPECTED_PROFILE_UPDATE);
-  
+
-    if(getLogWriterI18n().fineEnabled()) {
-      getLogWriterI18n().fine("ServerLocator: Received a load update from " + location +", " + load);
+    if (getLogWriterI18n().fineEnabled()) {
+      getLogWriterI18n()
+          .fine("ServerLocator: Received a load update from " + location + ", " + load);
-      
+
-      
+
-      for (ServerLoad l: loadMap.values()) {
+      for (ServerLoad l : loadMap.values()) {
-        connections = (int)Math.ceil(l.getConnectionLoad() / l.getLoadPerConnection());
+        connections = (int) Math.ceil(l.getConnectionLoad() / l.getLoadPerConnection());
-      
+
-      synchronized(ownerMap) {
+      synchronized (ownerMap) {
-      sb.append("server count: ")
-        .append(servers.size())
-        .append(" connected client count: ")
-        .append(connections)
-        .append(" client subscription queue count: ")
-        .append(queues)
-        .append(System.lineSeparator())
-        .append("current servers : ");
-      
+      sb.append("server count: ").append(servers.size()).append(" connected client count: ")
+          .append(connections).append(" client subscription queue count: ").append(queues)
+          .append(System.lineSeparator()).append("current servers : ");
+
-      int i=0;
-      for (DistributedMember id: servers) {
+      int i = 0;
+      for (DistributedMember id : servers) {
-      for (i=0; i<ids.length; i++) {
+      for (i = 0; i < ids.length; i++) {
+
-   * Test hook to get the load on all of the servers. Returns a map of
-   * ServerLocation-> Load object with the current load on that server
+   * Test hook to get the load on all of the servers. Returns a map of ServerLocation-> Load object
+   * with the current load on that server
-  
+
-  
+

Merge branch 'release/1.5.0'

+import org.apache.geode.cache.CacheXmlException;
-import org.apache.geode.distributed.internal.DM;
+import org.apache.geode.distributed.internal.DistributionManager;
+import org.apache.geode.internal.cache.InternalRegion;
-import org.apache.geode.internal.cache.backup.BackupManager;
+import org.apache.geode.internal.cache.backup.BackupService;
+  private final List<DeclarableAndProperties> declarablePropertiesList = new ArrayList<>();
+
+  private static class DeclarableAndProperties {
+    private final Declarable declarable;
+    private final Properties properties;
+
+    public DeclarableAndProperties(Declarable d, Properties p) {
+      declarable = d;
+      properties = p;
+    }
+
+    public Declarable getDeclarable() {
+      return declarable;
+    }
+
+    public Properties getProperties() {
+      return properties;
+    }
+  }
+
+    initializeDeclarablesMap(cache);
+
+    if (hasFunctionService()) {
+      getFunctionServiceCreation().create();
+    }
+
-    cache.addDeclarableProperties(this.declarablePropertiesMap);
-    runInitializer();
+
+    runInitializer(cache);
+  public void initializeDeclarablesMap(InternalCache cache) {
+    for (DeclarableAndProperties struct : this.declarablePropertiesList) {
+      Declarable declarable = struct.getDeclarable();
+      Properties properties = struct.getProperties();
+      try {
+        declarable.initialize(cache, properties);
+        declarable.init(properties); // for backwards compatibility
+      } catch (Exception ex) {
+        throw new CacheXmlException(
+            "Exception while initializing an instance of " + declarable.getClass().getName(), ex);
+      }
+      this.declarablePropertiesMap.put(declarable, properties);
+    }
+    cache.addDeclarableProperties(this.declarablePropertiesMap);
+  }
+
+  void removeCacheServers(List<CacheServer> declarativeCacheServers, Cache cache,
+      Integer serverPort, String serverBindAdd, Boolean disableDefaultServer) {
+
+    throw new UnsupportedOperationException(LocalizedStrings.SHOULDNT_INVOKE.toLocalizedString());
+  }
+
+  public boolean removeCacheServer(final CacheServer cacheServer) {
+    throw new UnsupportedOperationException(LocalizedStrings.SHOULDNT_INVOKE.toLocalizedString());
+  }
+
+  @Override
-    this.declarablePropertiesMap.put(declarable, properties);
+    this.declarablePropertiesList.add(new DeclarableAndProperties(declarable, properties));
-  public Set<LocalRegion> getAllRegions() {
+  public Set<InternalRegion> getAllRegions() {
-  public Set<LocalRegion> getApplicationRegions() {
+  public Set<InternalRegion> getApplicationRegions() {
+  public void removeGatewayReceiver(GatewayReceiver receiver) {
+    throw new UnsupportedOperationException(LocalizedStrings.SHOULDNT_INVOKE.toLocalizedString());
+  }
+
+  public void closeDiskStores() {
+    throw new UnsupportedOperationException(LocalizedStrings.SHOULDNT_INVOKE.toLocalizedString());
+  }
+
+  @Override
+  private volatile boolean hasFunctionService = false;
+
+  boolean hasFunctionService() {
+    return this.hasFunctionService;
+  }
+
+    this.hasFunctionService = true;
+  public FunctionServiceCreation getFunctionServiceCreation() {
+    return this.functionServiceCreation;
+  }
+
-    return InternalDistributedSystem.getAnyInstance();
+    throw new UnsupportedOperationException(LocalizedStrings.SHOULDNT_INVOKE.toLocalizedString());
-  public BackupManager getBackupManager() {
-    throw new UnsupportedOperationException(LocalizedStrings.SHOULDNT_INVOKE.toLocalizedString());
-  }
-
-  @Override
-  public BackupManager startBackup(final InternalDistributedMember sender) throws IOException {
+  public BackupService getBackupService() {
-  void runInitializer() {
-    if (getInitializer() != null) {
-      getInitializer().init(getInitializerProps());
+  void runInitializer(InternalCache cache) {
+    Declarable initializer = getInitializer();
+    if (initializer != null) {
+      initializer.initialize(cache, getInitializerProps());
+      initializer.init(getInitializerProps()); // for backwards compatibility
-  public DM getDistributionManager() {
+  public DistributionManager getDistributionManager() {
-  public void setRegionByPath(final String path, final LocalRegion r) {
+  public void setRegionByPath(final String path, final InternalRegion r) {
-  public <K, V> RegionAttributes<K, V> invokeRegionBefore(final LocalRegion parent,
+  public <K, V> RegionAttributes<K, V> invokeRegionBefore(final InternalRegion parent,
-  public void invokeRegionAfter(final LocalRegion region) {
+  public void invokeRegionAfter(final InternalRegion region) {
-  public void invokeBeforeDestroyed(final LocalRegion region) {
+  public void invokeBeforeDestroyed(final InternalRegion region) {
-  public void invokeCleanupFailedInitialization(final LocalRegion region) {
+  public void invokeCleanupFailedInitialization(final InternalRegion region) {
-  public boolean removeRoot(final LocalRegion rootRgn) {
+  public boolean removeRoot(final InternalRegion rootRgn) {
+  public CacheClosedException getCacheClosedException(final String reason) {
+    throw new UnsupportedOperationException(LocalizedStrings.SHOULDNT_INVOKE.toLocalizedString());
+  }
+
+  @Override
-  public void clearBackupManager() {
-    throw new UnsupportedOperationException(LocalizedStrings.SHOULDNT_INVOKE.toLocalizedString());
-  }
-
-  @Override
-      InternalDistributedMember sender, LocalRegion region,
+      InternalDistributedMember sender, InternalRegion region,
+
+  @Override
+  public Object convertPdxInstanceIfNeeded(Object obj) {
+    throw new UnsupportedOperationException(LocalizedStrings.SHOULDNT_INVOKE.toLocalizedString());
+  }

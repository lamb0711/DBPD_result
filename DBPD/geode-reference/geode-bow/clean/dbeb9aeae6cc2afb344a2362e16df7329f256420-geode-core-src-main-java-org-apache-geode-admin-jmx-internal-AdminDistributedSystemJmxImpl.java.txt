Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * TODO: refactor to implement DistributedSystem and delegate to instance of
- * DistributedSystemImpl. Wrap all delegate calls w/ e.printStackTrace() since 
- * the HttpAdaptor devours them (what to do w/ template methods then?)
+ * TODO: refactor to implement DistributedSystem and delegate to instance of DistributedSystemImpl.
+ * Wrap all delegate calls w/ e.printStackTrace() since the HttpAdaptor devours them (what to do w/
+ * template methods then?)
- * @since GemFire     3.5
+ * @since GemFire 3.5
-public class AdminDistributedSystemJmxImpl 
-              extends AdminDistributedSystemImpl
-              implements ManagedResource, DistributedSystemConfig, StatAlertsAggregator {
+public class AdminDistributedSystemJmxImpl extends AdminDistributedSystemImpl
+    implements ManagedResource, DistributedSystemConfig, StatAlertsAggregator {
-  
+
-  
-  /** 
-   * Simple counter incrementing on each notification.  This this currently 
-   * resets at every restart of Agent
+
+  /**
+   * Simple counter incrementing on each notification. This this currently resets at every restart
+   * of Agent
-   * Variable to indicate if Statistics Alert definitions could be persisted 
-   * across runs/sessions.
+   * Variable to indicate if Statistics Alert definitions could be persisted across runs/sessions.
-  //   Constructor(s)
+  // Constructor(s)
-  
+
-   * Constructs new DistributedSystemJmxImpl and registers an MBean to represent
-   * it.
+   * Constructs new DistributedSystemJmxImpl and registers an MBean to represent it.
-   * @param config
-   *          configuration defining the JMX agent.
+   * @param config configuration defining the JMX agent.
-    mailProps.put(MailManager.PROPERTY_MAIL_FROM, 
-                    config.getEmailNotificationFrom());
-    mailProps.put(MailManager.PROPERTY_MAIL_HOST, 
-                    config.getEmailNotificationHost());
-    mailProps.put(MailManager.PROPERTY_MAIL_TO_LIST, 
-                    config.getEmailNotificationToList());
+    mailProps.put(MailManager.PROPERTY_MAIL_FROM, config.getEmailNotificationFrom());
+    mailProps.put(MailManager.PROPERTY_MAIL_HOST, config.getEmailNotificationHost());
+    mailProps.put(MailManager.PROPERTY_MAIL_TO_LIST, config.getEmailNotificationToList());
-    if (propFile!=null) {
-     if (propFile.isDirectory()) {
-       statAlertDefnSerFile = propFile.getAbsolutePath();
-     } else if (propFile.getParentFile()!=null) {
-       statAlertDefnSerFile = propFile.getParentFile().getAbsolutePath();
-     }
+    if (propFile != null) {
+      if (propFile.isDirectory()) {
+        statAlertDefnSerFile = propFile.getAbsolutePath();
+      } else if (propFile.getParentFile() != null) {
+        statAlertDefnSerFile = propFile.getParentFile().getAbsolutePath();
+      }
-  
+
-  //   MBean operations
+  // MBean operations
-  
+
-   * Registers the MBeans for monitoring the health of GemFire 
+   * Registers the MBeans for monitoring the health of GemFire
-   * Creates a new DistributionLocator for this system and registers an MBean
-   * for managing it.
+   * Creates a new DistributionLocator for this system and registers an MBean for managing it.
-   * If the Locator already exists, then this will simply register an MBean
-   * for it.
+   * If the Locator already exists, then this will simply register an MBean for it.
-   * @param host              the host name or IP address of the locator
-   * @param port              the port the locator service listens on
-   * @param workingDirectory  directory path for the locator and its log
-   * @param productDirectory  directory path to the GemFire product to use 
+   * @param host the host name or IP address of the locator
+   * @param port the port the locator service listens on
+   * @param workingDirectory directory path for the locator and its log
+   * @param productDirectory directory path to the GemFire product to use
-  public ObjectName createDistributionLocator(String host,
-                                              int port,
-                                              String workingDirectory,
-                                              String productDirectory) 
-                                       throws MalformedObjectNameException {
-    return createDistributionLocator(
-        host, port, workingDirectory, productDirectory, getRemoteCommand());
+  public ObjectName createDistributionLocator(String host, int port, String workingDirectory,
+      String productDirectory) throws MalformedObjectNameException {
+    return createDistributionLocator(host, port, workingDirectory, productDirectory,
+        getRemoteCommand());
-  
+
-   * Creates a new DistributionLocator for this system and registers an MBean
-   * for managing it.
+   * Creates a new DistributionLocator for this system and registers an MBean for managing it.
-   * If the Locator already exists, then this will simply register an MBean
-   * for it.
+   * If the Locator already exists, then this will simply register an MBean for it.
-   * @param host              the host name or IP address of the locator
-   * @param port              the port the locator service listens on
-   * @param workingDirectory  directory path for the locator and its log
-   * @param productDirectory  directory path to the GemFire product to use 
-   * @param remoteCommand     formatted remote command to control remotely
+   * @param host the host name or IP address of the locator
+   * @param port the port the locator service listens on
+   * @param workingDirectory directory path for the locator and its log
+   * @param productDirectory directory path to the GemFire product to use
+   * @param remoteCommand formatted remote command to control remotely
-  public ObjectName createDistributionLocator(String host,
-                                              int port,
-                                              String workingDirectory,
-                                              String productDirectory,
-                                              String remoteCommand) 
-                                       throws MalformedObjectNameException {
+  public ObjectName createDistributionLocator(String host, int port, String workingDirectory,
+      String productDirectory, String remoteCommand) throws MalformedObjectNameException {
-      DistributionLocatorJmxImpl locator =
-        (DistributionLocatorJmxImpl) addDistributionLocator();
-      
+      DistributionLocatorJmxImpl locator = (DistributionLocatorJmxImpl) addDistributionLocator();
+
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (Error e) { 
+    } catch (Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-  
+
-  //   Template methods overriden from superclass...
+  // Template methods overriden from superclass...
-  
+
-  throws org.apache.geode.admin.AdminException {
+      throws org.apache.geode.admin.AdminException {
-   * Constructs & returns a SystemMember instance using the corresponding
-   * InternalDistributedMember object.
+   * Constructs & returns a SystemMember instance using the corresponding InternalDistributedMember
+   * object.
-   * @param member
-   *          InternalDistributedMember instance for which a SystemMember
-   *          instance is to be constructed.
+   * @param member InternalDistributedMember instance for which a SystemMember instance is to be
+   *        constructed.
-   * @throws org.apache.geode.admin.AdminException
-   *           if construction of SystemMember instance fails
+   * @throws org.apache.geode.admin.AdminException if construction of SystemMember instance fails
-  
+
-  protected CacheServer createCacheServer(ApplicationVM member) 
-    throws AdminException {
+  protected CacheServer createCacheServer(ApplicationVM member) throws AdminException {
-  protected CacheServer createCacheServer(CacheServerConfigImpl config) 
-    throws AdminException {
+  protected CacheServer createCacheServer(CacheServerConfigImpl config) throws AdminException {
-  protected GemFireHealth createGemFireHealth(GfManagerAgent system) 
-    throws org.apache.geode.admin.AdminException {
+  protected GemFireHealth createGemFireHealth(GfManagerAgent system)
+      throws org.apache.geode.admin.AdminException {
-      throw new IllegalStateException(LocalizedStrings.AdminDistributedSystemJmxImpl_GFMANAGERAGENT_MUST_NOT_BE_NULL.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.AdminDistributedSystemJmxImpl_GFMANAGERAGENT_MUST_NOT_BE_NULL
+              .toLocalizedString());
-  
+
-  protected DistributionLocatorImpl 
-    createDistributionLocatorImpl(DistributionLocatorConfig config) {
+  protected DistributionLocatorImpl createDistributionLocatorImpl(
+      DistributionLocatorConfig config) {
-  //   Internal Admin listeners and JMX Notifications
+  // Internal Admin listeners and JMX Notifications
-  
+
-  
-  
+
+
-  /** 
+  /**
-   * React by creating an MBean for managing the SystemMember and then fire
-   * a Notification with the internal Id of the member VM.
+   * React by creating an MBean for managing the SystemMember and then fire a Notification with the
+   * internal Id of the member VM.
-   * @param source  the distributed system that fired nodeJoined
-   * @param joined  the VM that joined
+   * @param source the distributed system that fired nodeJoined
+   * @param joined the VM that joined
-      
-      /* super.nodeJoined results in creation of a new SystemMember which 
-       * registers itself as an MBean, so now we try to find it...
+
+      /*
+       * super.nodeJoined results in creation of a new SystemMember which registers itself as an
+       * MBean, so now we try to find it...
-      
-      if(null == member) {
+
+      if (null == member) {
-          logger.debug("AdminDistributedSystemJmxImpl.nodeJoined(), Could not find SystemMember for VM {}", joined);
+          logger.debug(
+              "AdminDistributedSystemJmxImpl.nodeJoined(), Could not find SystemMember for VM {}",
+              joined);
-      
+
-        
-        this.modelMBean.sendNotification(new Notification(
-            NOTIF_MEMBER_JOINED,
-            ((ManagedResource)member).getObjectName(), // Pass the ObjName of the Source Member
-            notificationSequenceNumber.addAndGet(1),
-            joined.getId().toString()));
-//      String mess = "Gemfire AlertNotification: System Member Joined, System member Id: " + joined.getId().toString();
-//      sendEmail("Gemfire AlertNotification: Member Joined, ID: " + joined.getId().toString(), mess);
+        this.modelMBean.sendNotification(
+            new Notification(NOTIF_MEMBER_JOINED, ((ManagedResource) member).getObjectName(), // Pass
+                                                                                              // the
+                                                                                              // ObjName
+                                                                                              // of
+                                                                                              // the
+                                                                                              // Source
+                                                                                              // Member
+                notificationSequenceNumber.addAndGet(1), joined.getId().toString()));
+
+        // String mess = "Gemfire AlertNotification: System Member Joined, System member Id: " +
+        // joined.getId().toString();
+        // sendEmail("Gemfire AlertNotification: Member Joined, ID: " + joined.getId().toString(),
+        // mess);
-          String mess = LocalizedStrings.AdminDistributedSystemJmxImpl_MEMBER_JOINED_THE_DISTRIBUTED_SYSTEM_MEMBER_ID_0.toLocalizedString(new Object[] {joined.getId().toString()} );
-        	sendEmail(
-        	    EML_SUBJ_PRFX_GFE_NOTFY + EML_SUBJ_ITEM_GFE_DS + getName() + " <" 
-        	    + LocalizedStrings.AdminDistributedSystemJmxImpl_MEMBER_JOINED.toLocalizedString() +">", 
-        	    mess);
+          String mess =
+              LocalizedStrings.AdminDistributedSystemJmxImpl_MEMBER_JOINED_THE_DISTRIBUTED_SYSTEM_MEMBER_ID_0
+                  .toLocalizedString(new Object[] {joined.getId().toString()});
+          sendEmail(EML_SUBJ_PRFX_GFE_NOTFY + EML_SUBJ_ITEM_GFE_DS + getName() + " <"
+              + LocalizedStrings.AdminDistributedSystemJmxImpl_MEMBER_JOINED.toLocalizedString()
+              + ">", mess);
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (Error e) { 
+    } catch (Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-  
-  /** 
+
+  /**
-   * React by removing the member's MBean.
-   * Also fire a Notification with the internal Id of the member VM.
+   * React by removing the member's MBean. Also fire a Notification with the internal Id of the
+   * member VM.
-   * @param source  the distributed system that fired nodeLeft
-   * @param left    the VM that left
+   * @param source the distributed system that fired nodeLeft
+   * @param left the VM that left
-        this.modelMBean.sendNotification(new Notification(
-            NOTIF_MEMBER_LEFT,
-            ((ManagedResource)member).getObjectName(), // Pass the ObjName of the Source Member
-            notificationSequenceNumber.addAndGet(1),
-            left.getId().toString()));
+        this.modelMBean.sendNotification(
+            new Notification(NOTIF_MEMBER_LEFT, ((ManagedResource) member).getObjectName(), // Pass
+                                                                                            // the
+                                                                                            // ObjName
+                                                                                            // of
+                                                                                            // the
+                                                                                            // Source
+                                                                                            // Member
+                notificationSequenceNumber.addAndGet(1), left.getId().toString()));
-//        String mess = "Gemfire AlertNotification: System Member Left the system, System member Id: " + left.getId().toString();
-//        sendEmail("Gemfire AlertNotification: Member Left, ID: " + left.getId().toString(), mess);
+        // String mess = "Gemfire AlertNotification: System Member Left the system, System member
+        // Id: " + left.getId().toString();
+        // sendEmail("Gemfire AlertNotification: Member Left, ID: " + left.getId().toString(),
+        // mess);
-          String mess = LocalizedStrings.AdminDistributedSystemJmxImpl_MEMBER_LEFT_THE_DISTRIBUTED_SYSTEM_MEMBER_ID_0.toLocalizedString(new Object[] {left.getId().toString()} );
-        	sendEmail( 
-        	    EML_SUBJ_PRFX_GFE_NOTFY + EML_SUBJ_ITEM_GFE_DS + getName() + " <" 
-        	    + LocalizedStrings.AdminDistributedSystemJmxImpl_MEMBER_LEFT.toLocalizedString() +">", 
-        	    mess);
-        }
-      } catch (javax.management.MBeanException e) { 
-        logger.warn(e.getMessage(), e);
-      }
-      
-      SystemMemberType memberType = member.getType();  
-      if (/* member != null && */ memberType.isApplication() || memberType.isCacheVm()) {
-        // automatically unregister the MBean...
-        MBeanUtil.unregisterMBean((ManagedResource) member);
-      }
-    } catch (RuntimeException e) {
-      logger.warn(e.getMessage(), e);
-      throw e;
-    } catch (VirtualMachineError err) {
-      SystemFailure.initiateFailure(err);
-      // If this ever returns, rethrow the error.  We're poisoned
-      // now, so don't let this thread continue.
-      throw err;
-    } catch (Error e) { 
-      // Whenever you catch Error or Throwable, you must also
-      // catch VirtualMachineError (see above).  However, there is
-      // _still_ a possibility that you are dealing with a cascading
-      // error condition, so you also need to check to see if the JVM
-      // is still usable:
-      SystemFailure.checkFailure();
-      logger.error(e.getMessage(), e);
-      throw e;
-    }
-  }
-  
-  /** 
-   * Listener callback for when a member of this DistributedSystem has crashed.
-   * <p>
-   * Also fires a Notification with the internal Id of the member VM.
-   *
-   * @param source  the distributed system that fired nodeCrashed
-   * @param crashed the VM that crashed
-   * @see org.apache.geode.internal.admin.JoinLeaveListener#nodeCrashed
-   */
-  @Override
-  public void nodeCrashed(GfManagerAgent source, GemFireVM crashed) {
-    try {
-      // SystemMember application has left...
-      SystemMember member = findSystemMember(crashed, false);
-      super.nodeCrashed(source, crashed);
-      if (logger.isDebugEnabled()) {
-        logger.debug("Processing node crash for: {}", member);
-      }
-      
-      try {
-        this.modelMBean.sendNotification(new Notification(
-            NOTIF_MEMBER_CRASHED,
-            ((ManagedResource)member).getObjectName(), // Pass the ObjName of the Source Member
-            notificationSequenceNumber.addAndGet(1),
-            crashed.getId().toString()));
-        
-//        String mess = "Gemfire AlertNotification: System Member Crashed, System member Id: " + crashed.getId().toString();
-//        sendEmail("Gemfire AlertNotification: Member Crashed, ID: " + crashed.getId().toString(), mess);
-        if (isEmailNotificationEnabled) {
-          String mess = LocalizedStrings.AdminDistributedSystemJmxImpl_MEMBER_CRASHED_IN_THE_DISTRIBUTED_SYSTEM_MEMBER_ID_0.toLocalizedString(new Object[] {crashed.getId().toString()} );
-        	sendEmail(
-        	    EML_SUBJ_PRFX_GFE_ALERT + EML_SUBJ_ITEM_GFE_DS + getName() + " <" 
-        	    + LocalizedStrings.AdminDistributedSystemJmxImpl_MEMBER_CRASHED.toLocalizedString() +">", 
-        	    mess);
+          String mess =
+              LocalizedStrings.AdminDistributedSystemJmxImpl_MEMBER_LEFT_THE_DISTRIBUTED_SYSTEM_MEMBER_ID_0
+                  .toLocalizedString(new Object[] {left.getId().toString()});
+          sendEmail(EML_SUBJ_PRFX_GFE_NOTFY + EML_SUBJ_ITEM_GFE_DS + getName() + " <"
+              + LocalizedStrings.AdminDistributedSystemJmxImpl_MEMBER_LEFT.toLocalizedString()
+              + ">", mess);
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (Error e) { 
+    } catch (Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
+      // _still_ a possibility that you are dealing with a cascading
+      // error condition, so you also need to check to see if the JVM
+      // is still usable:
+      SystemFailure.checkFailure();
+      logger.error(e.getMessage(), e);
+      throw e;
+    }
+  }
+
+  /**
+   * Listener callback for when a member of this DistributedSystem has crashed.
+   * <p>
+   * Also fires a Notification with the internal Id of the member VM.
+   *
+   * @param source the distributed system that fired nodeCrashed
+   * @param crashed the VM that crashed
+   * @see org.apache.geode.internal.admin.JoinLeaveListener#nodeCrashed
+   */
+  @Override
+  public void nodeCrashed(GfManagerAgent source, GemFireVM crashed) {
+    try {
+      // SystemMember application has left...
+      SystemMember member = findSystemMember(crashed, false);
+      super.nodeCrashed(source, crashed);
+      if (logger.isDebugEnabled()) {
+        logger.debug("Processing node crash for: {}", member);
+      }
+
+      try {
+        this.modelMBean.sendNotification(
+            new Notification(NOTIF_MEMBER_CRASHED, ((ManagedResource) member).getObjectName(), // Pass
+                                                                                               // the
+                                                                                               // ObjName
+                                                                                               // of
+                                                                                               // the
+                                                                                               // Source
+                                                                                               // Member
+                notificationSequenceNumber.addAndGet(1), crashed.getId().toString()));
+
+        // String mess = "Gemfire AlertNotification: System Member Crashed, System member Id: " +
+        // crashed.getId().toString();
+        // sendEmail("Gemfire AlertNotification: Member Crashed, ID: " + crashed.getId().toString(),
+        // mess);
+        if (isEmailNotificationEnabled) {
+          String mess =
+              LocalizedStrings.AdminDistributedSystemJmxImpl_MEMBER_CRASHED_IN_THE_DISTRIBUTED_SYSTEM_MEMBER_ID_0
+                  .toLocalizedString(new Object[] {crashed.getId().toString()});
+          sendEmail(EML_SUBJ_PRFX_GFE_ALERT + EML_SUBJ_ITEM_GFE_DS + getName() + " <"
+              + LocalizedStrings.AdminDistributedSystemJmxImpl_MEMBER_CRASHED.toLocalizedString()
+              + ">", mess);
+        }
+      } catch (javax.management.MBeanException e) {
+        logger.warn(e.getMessage(), e);
+      }
+
+      SystemMemberType memberType = member.getType();
+      if (/* member != null && */ memberType.isApplication() || memberType.isCacheVm()) {
+        // automatically unregister the MBean...
+        MBeanUtil.unregisterMBean((ManagedResource) member);
+      }
+    } catch (RuntimeException e) {
+      logger.warn(e.getMessage(), e);
+      throw e;
+    } catch (VirtualMachineError err) {
+      SystemFailure.initiateFailure(err);
+      // If this ever returns, rethrow the error. We're poisoned
+      // now, so don't let this thread continue.
+      throw err;
+    } catch (Error e) {
+      // Whenever you catch Error or Throwable, you must also
+      // catch VirtualMachineError (see above). However, there is
-  /** 
-   * Listener callback for when a SystemMember of this DistributedSystem has 
-   * crashed.
+  /**
+   * Listener callback for when a SystemMember of this DistributedSystem has crashed.
-        this.modelMBean.sendNotification(new Notification(
-            NOTIF_ALERT,
-            this.mbeanName,
-            notificationSequenceNumber.addAndGet(1),
-            strAlert));
-        
-//        String mess = "Gemfire AlertNotification: System Alert :" + alert.toString();
-//        sendEmail("Gemfire AlertNotification: System Alert", mess);
+        this.modelMBean.sendNotification(new Notification(NOTIF_ALERT, this.mbeanName,
+            notificationSequenceNumber.addAndGet(1), strAlert));
+
+        // String mess = "Gemfire AlertNotification: System Alert :" + alert.toString();
+        // sendEmail("Gemfire AlertNotification: System Alert", mess);
-          String mess = LocalizedStrings.AdminDistributedSystemJmxImpl_SYSTEM_ALERT_FROM_DISTRIBUTED_SYSTEM_0.toLocalizedString(strAlert);
-        	sendEmail( EML_SUBJ_PRFX_GFE_ALERT + EML_SUBJ_ITEM_GFE_DS + getName() + " <System Alert>", mess);
+          String mess =
+              LocalizedStrings.AdminDistributedSystemJmxImpl_SYSTEM_ALERT_FROM_DISTRIBUTED_SYSTEM_0
+                  .toLocalizedString(strAlert);
+          sendEmail(EML_SUBJ_PRFX_GFE_ALERT + EML_SUBJ_ITEM_GFE_DS + getName() + " <System Alert>",
+              mess);
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (Error e) { 
+    } catch (Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-  
+
-  	try {
-  		super.onDisconnect(sys);
-  		
-  		try {
-  			this.modelMBean.sendNotification(new Notification(
-  			        NOTIF_ADMIN_SYSTEM_DISCONNECT,
-  			        this.mbeanName,
-  			        notificationSequenceNumber.addAndGet(1),
-  			        null));
-  		} catch (MBeanException e) {
-  		  logger.warn(e.getMessage(), e);	
-  		}
-  	} catch (RuntimeException e) {
-  	  logger.warn(e.getMessage(), e);
-  	  throw e;
-  	} catch (VirtualMachineError err) {
-  	  SystemFailure.initiateFailure(err);
-  	  // If this ever returns, rethrow the error. We're poisoned
-  	  // now, so don't let this thread continue.
-  	  throw err;
-  	} catch (Error e) {
-  	  // Whenever you catch Error or Throwable, you must also
-  	  // catch VirtualMachineError (see above). However, there is
-  	  // _still_ a possibility that you are dealing with a cascading
-  	  // error condition, so you also need to check to see if the JVM
-  	  // is still usable:
-  	  SystemFailure.checkFailure();
-  	  logger.error(e.getMessage(), e);
-  	  throw e;
-  	}
-  	if (logger.isDebugEnabled()) {
-  	  this.logger.debug("Completed AdminDistributedSystemJmxImpl#onDisconnect");
-  	}
+    try {
+      super.onDisconnect(sys);
+
+      try {
+        this.modelMBean.sendNotification(new Notification(NOTIF_ADMIN_SYSTEM_DISCONNECT,
+            this.mbeanName, notificationSequenceNumber.addAndGet(1), null));
+      } catch (MBeanException e) {
+        logger.warn(e.getMessage(), e);
+      }
+    } catch (RuntimeException e) {
+      logger.warn(e.getMessage(), e);
+      throw e;
+    } catch (VirtualMachineError err) {
+      SystemFailure.initiateFailure(err);
+      // If this ever returns, rethrow the error. We're poisoned
+      // now, so don't let this thread continue.
+      throw err;
+    } catch (Error e) {
+      // Whenever you catch Error or Throwable, you must also
+      // catch VirtualMachineError (see above). However, there is
+      // _still_ a possibility that you are dealing with a cascading
+      // error condition, so you also need to check to see if the JVM
+      // is still usable:
+      SystemFailure.checkFailure();
+      logger.error(e.getMessage(), e);
+      throw e;
+    }
+    if (logger.isDebugEnabled()) {
+      this.logger.debug("Completed AdminDistributedSystemJmxImpl#onDisconnect");
+    }
-  
+
-  //   ManagedResource implementation
+  // ManagedResource implementation
-  
+
-  /** The remotable ObjectName that the  MBean is registered under */
+  /** The remotable ObjectName that the MBean is registered under */
-  
+
-  
-	public String getMBeanName() {
-		return this.mbeanName;
-	}
-  
-	public ModelMBean getModelMBean() {
-		return this.modelMBean;
-	}
-	public void setModelMBean(ModelMBean modelMBean) {
-		this.modelMBean = modelMBean;
-	}
+
+  public String getMBeanName() {
+    return this.mbeanName;
+  }
+
+  public ModelMBean getModelMBean() {
+    return this.modelMBean;
+  }
+
+  public void setModelMBean(ModelMBean modelMBean) {
+    this.modelMBean = modelMBean;
+  }
-  
+
-  //   Error traps added to overridden methods...
+  // Error traps added to overridden methods...
-  
+
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (java.lang.Error e) { 
+    } catch (java.lang.Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (java.lang.Error e) { 
+    } catch (java.lang.Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-  
+
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (java.lang.Error e) { 
+    } catch (java.lang.Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-  public boolean waitToBeConnected(long timeout)
-    throws InterruptedException {
+  public boolean waitToBeConnected(long timeout) throws InterruptedException {
-    if (Thread.interrupted()) throw new InterruptedException();
+    if (Thread.interrupted())
+      throw new InterruptedException();
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (java.lang.Error e) { 
+    } catch (java.lang.Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (java.lang.Error e) { 
+    } catch (java.lang.Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-  public ObjectName manageDistributionLocator()
-    throws MalformedObjectNameException {
+  public ObjectName manageDistributionLocator() throws MalformedObjectNameException {
-//     catch (AdminException e) { logger.warn(e.getMessage(), e); throw e; }
+    // catch (AdminException e) { logger.warn(e.getMessage(), e); throw e; }
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (Error e) { 
+    } catch (Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-  public ObjectName[] manageDistributionLocators() 
-  throws MalformedObjectNameException {
+  public ObjectName[] manageDistributionLocators() throws MalformedObjectNameException {
-    //catch (AdminException e) { logger.warn(e.getMessage(), e); throw e; }
-    catch (RuntimeException e) { 
-      logger.warn(e.getMessage(), e); 
-      throw e; 
+    // catch (AdminException e) { logger.warn(e.getMessage(), e); throw e; }
+    catch (RuntimeException e) {
+      logger.warn(e.getMessage(), e);
+      throw e;
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (Error e) { 
+    } catch (Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      logger.error(e.getMessage(), e); 
-      throw e; 
+      logger.error(e.getMessage(), e);
+      throw e;
-    
+
-  public ObjectName manageCacheServer()
-  throws AdminException, MalformedObjectNameException {
+  public ObjectName manageCacheServer() throws AdminException, MalformedObjectNameException {
-  public ObjectName manageCacheVm()
-  throws AdminException, MalformedObjectNameException {
+
+  public ObjectName manageCacheVm() throws AdminException, MalformedObjectNameException {
-    } catch (AdminException e) { 
-      logger.warn(e.getMessage(), e); 
-      throw e; 
-    } catch (RuntimeException e) { 
-      logger.warn(e.getMessage(), e); 
-      throw e; 
+    } catch (AdminException e) {
+      logger.warn(e.getMessage(), e);
+      throw e;
+    } catch (RuntimeException e) {
+      logger.warn(e.getMessage(), e);
+      throw e;
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (Error e) { 
+    } catch (Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      throw e; 
+      throw e;
-  public ObjectName[] manageCacheServers()
-  throws AdminException, MalformedObjectNameException {
+  public ObjectName[] manageCacheServers() throws AdminException, MalformedObjectNameException {
-  public ObjectName[] manageCacheVms()
-  throws AdminException, MalformedObjectNameException {
+  public ObjectName[] manageCacheVms() throws AdminException, MalformedObjectNameException {
-    } catch (AdminException e) { 
-      logger.warn(e.getMessage(), e); 
-      throw e; 
-    } catch (RuntimeException e) { 
-      logger.warn(e.getMessage(), e); 
-      throw e; 
+    } catch (AdminException e) {
+      logger.warn(e.getMessage(), e);
+      throw e;
+    } catch (RuntimeException e) {
+      logger.warn(e.getMessage(), e);
+      throw e;
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (Error e) { 
+    } catch (Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      throw e; 
+      throw e;
-  throws AdminException, MalformedObjectNameException {
+      throws AdminException, MalformedObjectNameException {
-    } catch (AdminException e) { 
-      logger.warn(e.getMessage(), e); 
-      throw e; 
-    } catch (RuntimeException e) { 
-      logger.warn(e.getMessage(), e); 
-      throw e; 
+    } catch (AdminException e) {
+      logger.warn(e.getMessage(), e);
+      throw e;
+    } catch (RuntimeException e) {
+      logger.warn(e.getMessage(), e);
+      throw e;
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (Error e) { 
+    } catch (Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      throw e; 
+      throw e;
-  
+
-   * Return the ObjectName for the SystemMemberMBean representing the
-   * specified distributed member or null if the member is not found.
+   * Return the ObjectName for the SystemMemberMBean representing the specified distributed member
+   * or null if the member is not found.
-  throws AdminException, MalformedObjectNameException {
+      throws AdminException, MalformedObjectNameException {
-      if (member == null) return null;
+      if (member == null)
+        return null;
-    } catch (AdminException e) { 
-      logger.warn(e.getMessage(), e); 
-      throw e; 
-    } catch (RuntimeException e) { 
-      logger.warn(e.getMessage(), e); 
-      throw e; 
+    } catch (AdminException e) {
+      logger.warn(e.getMessage(), e);
+      throw e;
+    } catch (RuntimeException e) {
+      logger.warn(e.getMessage(), e);
+      throw e;
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (Error e) { 
+    } catch (Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      throw e; 
+      throw e;
-  
+
-      
+
-    } catch (RuntimeException e) { 
+    } catch (RuntimeException e) {
-      throw e; 
+      throw e;
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-    } catch (Error e) { 
+    } catch (Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      throw e; 
+      throw e;
-  
+
-      
+
-      removeCacheListener(cacheRegionListener);      
-    } catch (RuntimeException e) { 
+      removeCacheListener(cacheRegionListener);
+    } catch (RuntimeException e) {
-      // If this ever returns, re-throw the error.  We're poisoned
+      // If this ever returns, re-throw the error. We're poisoned
-    } catch (Error e) { 
+    } catch (Error e) {
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-  
+
-    
+
-      logger.info(LocalizedStrings.AdminDistributedSystemJmxImpl_JMX_CLIENT_COUNT_HAS_DROPPED_TO_ZERO);
+      logger.info(
+          LocalizedStrings.AdminDistributedSystemJmxImpl_JMX_CLIENT_COUNT_HAS_DROPPED_TO_ZERO);
-  ///////////////////////  Configuration  ///////////////////////
+  /////////////////////// Configuration ///////////////////////
-    
+
+
+
-   return getConfig().getMemberTimeout();
+    return getConfig().getMemberTimeout();
+
-  
+
-  
+
-  
+
-  
+
-  
-  /* Note that the getter & setter for membership port range are referred from 
-   * the super class AdminDistributedSystemImpl */
+
+  /*
+   * Note that the getter & setter for membership port range are referred from the super class
+   * AdminDistributedSystemImpl
+   */
-  
+
-  
+
-  
+
-   * The interval (in seconds) between auto-polling for updating
-   * AdminDistributedSystem constituents including SystemMember,
-   * SystemMemberCache and StatisticResource. This applies only to the default
-   * interval set when the resource is created. Changes to this interval will
-   * not get propagated to existing resources but will apply to all new
-   * resources
+   * The interval (in seconds) between auto-polling for updating AdminDistributedSystem constituents
+   * including SystemMember, SystemMemberCache and StatisticResource. This applies only to the
+   * default interval set when the resource is created. Changes to this interval will not get
+   * propagated to existing resources but will apply to all new resources
-  
+
-  public void removeDistributionLocatorConfig(DistributionLocatorConfig config) 
-{
+  public void removeDistributionLocatorConfig(DistributionLocatorConfig config) {
-  
+
-  private static final String[] PERSISTENT_ID_DESCRIPTIONS = new String[] {"The host that was persisting the missing files", "The directory where the files were persisted", "The unique id for the persistent files"};
+  private static final String[] PERSISTENT_ID_DESCRIPTIONS =
+      new String[] {"The host that was persisting the missing files",
+          "The directory where the files were persisted", "The unique id for the persistent files"};
-  
-  { 
+
+  {
-      PERSISTENT_ID_TYPE = new CompositeType(PersistentID.class.getCanonicalName(), "A single member's a set of persistent files for a region", PERSISTENT_ID_FIELDS, PERSISTENT_ID_DESCRIPTIONS, new OpenType[] {SimpleType.STRING, SimpleType.STRING, SimpleType.STRING});
-      PERSISTENT_ID_TABLE_TYPE = new TabularType("TABLE_" + PERSISTENT_ID_TYPE.getTypeName(), "A table of persistent member ids", PERSISTENT_ID_TYPE, PERSISTENT_ID_FIELDS);
+      PERSISTENT_ID_TYPE = new CompositeType(PersistentID.class.getCanonicalName(),
+          "A single member's a set of persistent files for a region", PERSISTENT_ID_FIELDS,
+          PERSISTENT_ID_DESCRIPTIONS,
+          new OpenType[] {SimpleType.STRING, SimpleType.STRING, SimpleType.STRING});
+      PERSISTENT_ID_TABLE_TYPE = new TabularType("TABLE_" + PERSISTENT_ID_TYPE.getTypeName(),
+          "A table of persistent member ids", PERSISTENT_ID_TYPE, PERSISTENT_ID_FIELDS);
-  
+
-    
+
-      for(PersistentID id : members) {
-        CompositeData idData = new CompositeDataSupport(PERSISTENT_ID_TYPE, PERSISTENT_ID_FIELDS, new Object[] {id.getHost().toString(), id.getDirectory(), id.getUUID().toString()});
+      for (PersistentID id : members) {
+        CompositeData idData = new CompositeDataSupport(PERSISTENT_ID_TYPE, PERSISTENT_ID_FIELDS,
+            new Object[] {id.getHost().toString(), id.getDirectory(), id.getUUID().toString()});
-    } catch( OpenDataException e) {
+    } catch (OpenDataException e) {
-  public void revokePersistentMember(String host,
-      String directory) throws AdminException, UnknownHostException {
+  public void revokePersistentMember(String host, String directory)
+      throws AdminException, UnknownHostException {
-  
+
-  
+
-  
+
-  /* 
-   * This map contains list of stat alerts as a value for alert def ID as a key  
+  /*
+   * This map contains list of stat alerts as a value for alert def ID as a key
-  
-  //TODO: yet to set the timer task
-//  private SystemTimer systemwideAlertNotificationScheduler = new SystemTimer();
-  
+
+  // TODO: yet to set the timer task
+  // private SystemTimer systemwideAlertNotificationScheduler = new SystemTimer();
+
-  
+
-   * @param alertDefinitionId id of a stat alert definition 
+   * @param alertDefinitionId id of a stat alert definition
-    synchronized(ALERT_DEFINITIONS) {
-      return (StatAlertDefinition)ALERT_DEFINITIONS.get(Integer.valueOf(alertDefinitionId));
+    synchronized (ALERT_DEFINITIONS) {
+      return (StatAlertDefinition) ALERT_DEFINITIONS.get(Integer.valueOf(alertDefinitionId));
-  
-/*  private void setAlertDefinition(StatAlertDefinition alertDefinition) {
-    ALERT_DEFINITIONS.put(Integer.valueOf(alertDefinition.getId()), alertDefinition);
-  }*/
-  /** 
-   * This method can be used to get an alert definition. 
+  /*
+   * private void setAlertDefinition(StatAlertDefinition alertDefinition) {
+   * ALERT_DEFINITIONS.put(Integer.valueOf(alertDefinition.getId()), alertDefinition); }
+   */
+
+  /**
+   * This method can be used to get an alert definition.
-   * @return StatAlertDefinition 
+   * @return StatAlertDefinition
-  
+
-   * This method is used to write existing StatAlertDefinitions 
-   * to a file
+   * This method is used to write existing StatAlertDefinitions to a file
-      
+
-      
+
-        logger.debug("AdminDistributedSystemJmxImpl.readAlertDefinitionsAsSerializedObjects: File: {}", serFile.getPath());
+        logger.debug(
+            "AdminDistributedSystemJmxImpl.readAlertDefinitionsAsSerializedObjects: File: {}",
+            serFile.getPath());
-      defns = (StatAlertDefinition[])DataSerializer.readObjectArray(ooStr);
+      defns = (StatAlertDefinition[]) DataSerializer.readObjectArray(ooStr);
-      if (foStr!=null) {
+      if (foStr != null) {
-      if (ooStr!=null) { 
+      if (ooStr != null) {
-    
-    for (int i=0; i<defns.length; i++) {
+
+    for (int i = 0; i < defns.length; i++) {
-   * This method is used to write existing StatAlertDefinitions 
-   * to a file
+   * This method is used to write existing StatAlertDefinitions to a file
-      
-  
+
+
-        logger.debug("AdminDistributedSystemJmxImpl.saveAlertDefinitionsAsSerializedObjects: File: {}", serFile.getPath());
+        logger.debug(
+            "AdminDistributedSystemJmxImpl.saveAlertDefinitionsAsSerializedObjects: File: {}",
+            serFile.getPath());
-      
+
-      
+
-      
+
-        
+
-        for (Iterator iter=ALERT_DEFINITIONS.keySet().iterator(); iter.hasNext() ;) {
+        for (Iterator iter = ALERT_DEFINITIONS.keySet().iterator(); iter.hasNext();) {
-          i++; 
+          i++;
-      if (foStr!=null) 
+      if (foStr != null)
-      if (ooStr!=null) 
+      if (ooStr != null)
-   * @param file
-   *          file to check write permissions for
+   * @param file file to check write permissions for
-    // saving the stat-alert definitions, then appropriate warning message is 
-    // logged and the operation is aborted. In case the file doesn't exist, then 
-    // it attempts to create a file. If the attempt fails then it logs 
+    // saving the stat-alert definitions, then appropriate warning message is
+    // logged and the operation is aborted. In case the file doesn't exist, then
+    // it attempts to create a file. If the attempt fails then it logs
-    // a directory sometimes fails on Windows platform. Hence file creation is 
+    // a directory sometimes fails on Windows platform. Hence file creation is
-            new Object[] { file }));
+            new Object[] {file}));
-            new Object[] { file }), e);
+            new Object[] {file}), e);
-          logger.debug("Could not delete file :'{}' which is created for checking permissions.", file.getAbsolutePath());
+          logger.debug("Could not delete file :'{}' which is created for checking permissions.",
+              file.getAbsolutePath());
-  /** 
-   * This method can be used to update alert definition for the Stat mentioned.
-   * This method should update the collection maintained at the aggregator and 
-   * should notify members for the newly added alert definitions.
-   * A new alert definition will be created if matching one not found.
+  /**
+   * This method can be used to update alert definition for the Stat mentioned. This method should
+   * update the collection maintained at the aggregator and should notify members for the newly
+   * added alert definitions. A new alert definition will be created if matching one not found.
-   * @param alertDefinition alertDefinition to be updated 
+   * @param alertDefinition alertDefinition to be updated
-   */  
+   */
-      logger.debug("Entered AdminDistributedSystemJmxImpl.updateAlertDefinition(StatAlertDefinition) *****");
+      logger.debug(
+          "Entered AdminDistributedSystemJmxImpl.updateAlertDefinition(StatAlertDefinition) *****");
-     * What to update in the alert definition? There should be another argument 
-     * or arguments in a map.
-     * 1. Need to update the list/map of alert definitions across members.   
+     * What to update in the alert definition? There should be another argument or arguments in a
+     * map. 1. Need to update the list/map of alert definitions across members.
-      
+
-        logger.debug("AdminDistributedSystemJmxImpl.updateAlertDefinition : alertDefinition :: id={} :: {}", alertDefinition.getId(), alertDefinition.getStringRepresentation());
+        logger.debug(
+            "AdminDistributedSystemJmxImpl.updateAlertDefinition : alertDefinition :: id={} :: {}",
+            alertDefinition.getId(), alertDefinition.getStringRepresentation());
-      
+
-      logger.debug("Exiting AdminDistributedSystemJmxImpl.updateAlertDefinition(StatAlertDefinition) *****");
+      logger.debug(
+          "Exiting AdminDistributedSystemJmxImpl.updateAlertDefinition(StatAlertDefinition) *****");
-  /** 
-   * This method can be used to remove alert definition for the Stat 
-   * mentioned. 
-   * This method should update the collection maintained at the aggregator and 
-   * should notify members for the newly added alert definitions. 
+  /**
+   * This method can be used to remove alert definition for the Stat mentioned. This method should
+   * update the collection maintained at the aggregator and should notify members for the newly
+   * added alert definitions.
-   */  
+   */
-     * alert passed to be deleted from the list/map of alerts on JMX MBean 
-     * & all Member MBeans
+     * alert passed to be deleted from the list/map of alerts on JMX MBean & all Member MBeans
-      StatAlertDefinition alertDefinition = (StatAlertDefinition)ALERT_DEFINITIONS.get(defId);
-  	  if (alertDefinition != null) {
-    		ALERT_DEFINITIONS.remove(defId);
-    		synchronized (alertsStore) {
-    		  alertsStore.remove(defId);
-    		}
-    		/* TODO: add code to retry on failure */
-    		notifyMembersForAlertDefinitionRemoval(alertDefinition);
-  	  }      
+      StatAlertDefinition alertDefinition = (StatAlertDefinition) ALERT_DEFINITIONS.get(defId);
+      if (alertDefinition != null) {
+        ALERT_DEFINITIONS.remove(defId);
+        synchronized (alertsStore) {
+          alertsStore.remove(defId);
+        }
+        /* TODO: add code to retry on failure */
+        notifyMembersForAlertDefinitionRemoval(alertDefinition);
+      }
-  /** 
+  /**
-   * @return true if the alert definition is already created, false 
-   *         otherwise 
+   * @return true if the alert definition is already created, false otherwise
-     * Need to maintain a map of stat against the StatAlertDefinitions.
-     * check in that map whether the alert definition is there for the given 
-     * alert
+     * Need to maintain a map of stat against the StatAlertDefinitions. check in that map whether
+     * the alert definition is there for the given alert
-    synchronized(ALERT_DEFINITIONS) {
+    synchronized (ALERT_DEFINITIONS) {
-     * state to store the refresh interval set by the user/GFMon client 
+     * state to store the refresh interval set by the user/GFMon client
-   * This method is used to set the refresh interval for the Stats in 
-   * seconds 
+   * This method is used to set the refresh interval for the Stats in seconds
-     * change the state refresh interval here. 
+     * change the state refresh interval here.
-    notifyMembersForRefreshIntervalChange(this.refreshIntervalForStatAlerts*1000l);
+    notifyMembersForRefreshIntervalChange(this.refreshIntervalForStatAlerts * 1000l);
-   * Returns whether Statistics Alert definitions could be persisted across 
-   * runs/sessions
+   * Returns whether Statistics Alert definitions could be persisted across runs/sessions
-    GfManagerAgent  agent = getGfManagerAgent();
-    ApplicationVM[] VMs   = agent.listApplications();    
-    //TODO: is there any other way to get all VMs?
-    
+    GfManagerAgent agent = getGfManagerAgent();
+    ApplicationVM[] VMs = agent.listApplications();
+    // TODO: is there any other way to get all VMs?
+
-  
+
-   * An intermediate method to notify all members for change in stat alert 
-   * definition.
+   * An intermediate method to notify all members for change in stat alert definition.
-   */  
+   */
-      logger.debug("Entered AdminDistributedSystemJmxImpl.notifyMembersForAlertDefinitionChange(StatAlertDefinition) *****");
+      logger.debug(
+          "Entered AdminDistributedSystemJmxImpl.notifyMembersForAlertDefinitionChange(StatAlertDefinition) *****");
-    GfManagerAgent        agent     = getGfManagerAgent();
+    GfManagerAgent agent = getGfManagerAgent();
-    ApplicationVM[]       VMs       = agent.listApplications();
-    
+    ApplicationVM[] VMs = agent.listApplications();
+
-      VMs[i].updateAlertDefinitions(alertDefs, 
+      VMs[i].updateAlertDefinitions(alertDefs,
-      logger.debug("Exiting AdminDistributedSystemJmxImpl.notifyMembersForAlertDefinitionChange(StatAlertDefinition) "
-    		    + VMs.length+" members notified.*****");
+      logger.debug(
+          "Exiting AdminDistributedSystemJmxImpl.notifyMembersForAlertDefinitionChange(StatAlertDefinition) "
+              + VMs.length + " members notified.*****");
-   * An intermediate method to notify all members for removal of stat alert 
-   * definition.
+   * An intermediate method to notify all members for removal of stat alert definition.
-    GfManagerAgent        agent     = getGfManagerAgent();
+    GfManagerAgent agent = getGfManagerAgent();
-    ApplicationVM[]       VMs       = agent.listApplications();
-    
+    ApplicationVM[] VMs = agent.listApplications();
+
-      VMs[i].updateAlertDefinitions(alertDefs, 
+      VMs[i].updateAlertDefinitions(alertDefs,
-   * This method can be used to set the AlertsManager for the newly joined     
-   * member VM.
+   * This method can be used to set the AlertsManager for the newly joined member VM.
-     * 1. Who'll call this method? Who gets notified when a member joins? 
-     *    I think that's AdminDistributedSystemJmxImpl.nodeCreated()
-     * 2. Is the argument GemFireVM correct? Need to modify this interface to 
-     *    add method to set an interface. Need to see how it can be passed to 
-     *    the RemoteGemFireVM implementation. Also need to check whetherother 
-     *    implementors (like DistributedSystemHealthMonitor) of GemFireVM even 
-     *    need to have the AlertsManager
-     * 3. Would the alerts manager be set by aggregator or a JMXAgent i.e. AdminDistributedSystemJmxImpl
-     * 4. Setting the list of available alert definitions & refresh interval at 
-     *    this moment only would be better/easier.
-     * 5. Need to know Alerts Manager creation/construction. Need to decide how 
-     *    the object would be set & sent across to the Agent VM.
+     * 1. Who'll call this method? Who gets notified when a member joins? I think that's
+     * AdminDistributedSystemJmxImpl.nodeCreated() 2. Is the argument GemFireVM correct? Need to
+     * modify this interface to add method to set an interface. Need to see how it can be passed to
+     * the RemoteGemFireVM implementation. Also need to check whetherother implementors (like
+     * DistributedSystemHealthMonitor) of GemFireVM even need to have the AlertsManager 3. Would the
+     * alerts manager be set by aggregator or a JMXAgent i.e. AdminDistributedSystemJmxImpl 4.
+     * Setting the list of available alert definitions & refresh interval at this moment only would
+     * be better/easier. 5. Need to know Alerts Manager creation/construction. Need to decide how
+     * the object would be set & sent across to the Agent VM.
-    
+
-    
+
-    synchronized(ALERT_DEFINITIONS) {
+    synchronized (ALERT_DEFINITIONS) {
-    
-    alertDefs = (StatAlertDefinition[])alertDefsCollection.toArray(alertDefs);
-    
-    memberVM.setAlertsManager(alertDefs, getRefreshIntervalForStatAlerts()*1000l, true);
-    
+
+    alertDefs = (StatAlertDefinition[]) alertDefsCollection.toArray(alertDefs);
+
+    memberVM.setAlertsManager(alertDefs, getRefreshIntervalForStatAlerts() * 1000l, true);
+
-  /** 
-   * This method can be used to retrieve all available stat alert definitions. 
-   * Returns empty array if there are no stat alert definitions defined.
+  /**
+   * This method can be used to retrieve all available stat alert definitions. Returns empty array
+   * if there are no stat alert definitions defined.
-   * @return An array of all available StatAlertDefinition objects 
+   * @return An array of all available StatAlertDefinition objects
-    
+
-    synchronized(ALERT_DEFINITIONS) {
+    synchronized (ALERT_DEFINITIONS) {
-    
+
-    
+
-      alertDefsArr = (StatAlertDefinition[])alertDefs.toArray(alertDefsArr);
+      alertDefsArr = (StatAlertDefinition[]) alertDefs.toArray(alertDefsArr);
-    
+
-    
+
-   * This method can be used to process the notifications sent by the 
-   * member(s). Actual aggregation of stats can occur here. The array contains 
-   * alert objects with alert def. ID & value. AlertHelper class can be used to 
-   * retrieve the corresponding alert definition.
+   * This method can be used to process the notifications sent by the member(s). Actual aggregation
+   * of stats can occur here. The array contains alert objects with alert def. ID & value.
+   * AlertHelper class can be used to retrieve the corresponding alert definition.
-   * @param remoteVM Remote Member VM that sent Stat Alerts for processing the
-   *                 notifications to the clients
-   */  
+   * @param remoteVM Remote Member VM that sent Stat Alerts for processing the notifications to the
+   *        clients
+   */
-      logger.debug("Entered AdminDistributedSystemJmxImpl.processNotifications(StatAlert[{}], GemFireVM) *************", alerts.length);
+      logger.debug(
+          "Entered AdminDistributedSystemJmxImpl.processNotifications(StatAlert[{}], GemFireVM) *************",
+          alerts.length);
-    
-    /* 
-     * Notifications can not be processed if the remote VM is not available.
-     * NOTE: Should this method get the required GemFireVM information instead 
-     * of its reference so that even if the member leaves we still have the 
-     * information collected earlier to process the notification?
+
+    /*
+     * Notifications can not be processed if the remote VM is not available. NOTE: Should this
+     * method get the required GemFireVM information instead of its reference so that even if the
+     * member leaves we still have the information collected earlier to process the notification?
-    
+
-     * 1. The implementation idea is yet not clear.
-     * 2. The StatAlert array would received directly or from a request object. 
+     * 1. The implementation idea is yet not clear. 2. The StatAlert array would received directly
+     * or from a request object.
-    
+
-    
+
-    Integer   defId = null;
-//    Number[]  values = null;
+    Integer defId = null;
+    // Number[] values = null;
-      
-//      defId = Integer.valueOf(alert.getDefinitionId());
-      if (getAlertDefinition(alert.getDefinitionId())==null)
-        continue; // Ignore any removed AlertDefns 
-//      values = alert.getValues();
-      
-//      StatAlertDefinition statAlertDef = (StatAlertDefinition)ALERT_DEFINITIONS.get(defId);
-      
+
+      // defId = Integer.valueOf(alert.getDefinitionId());
+      if (getAlertDefinition(alert.getDefinitionId()) == null)
+        continue; // Ignore any removed AlertDefns
+      // values = alert.getValues();
+
+      // StatAlertDefinition statAlertDef = (StatAlertDefinition)ALERT_DEFINITIONS.get(defId);
+
-       * 1. check if it's system-wide.
-       * 2. if system-wide keep, it in a collection (that should get cleared on 
-       *    timeout). Process all alerts when notifications from all members are 
-       *    received. Need to check if the member leaves meanwhile. 
+       * 1. check if it's system-wide. 2. if system-wide keep, it in a collection (that should get
+       * cleared on timeout). Process all alerts when notifications from all members are received.
+       * Need to check if the member leaves meanwhile.
-       * 1. Check if function evaluation is required?
-       * 2. If it's not required, the notification should directly be sent to 
-       *    clients.
+       * 1. Check if function evaluation is required? 2. If it's not required, the notification
+       * should directly be sent to clients.
-      
-      //if (statAlertDef.getFunctionId() != 0) {
-        /*
-         * StatAlert with alert definitions having functions
-         * assigned will get evaluated at manager side only.
-         * 
-         * Is combination of systemwide alerts with function valid? It should 
-         * be & hence such evaluation should be skipped on manager side. Or is 
-         * it to be evaluated at manager as well as aggragator?
-         */
-      //}
-      
-      //TODO: is this object required? Or earlier canbe resused?
-      StatAlertNotification alertNotification = new StatAlertNotification(alert, memberId);
-      
+
+      // if (statAlertDef.getFunctionId() != 0) {
-       * variable isSystemWide is created only for convienience, there
-       * should be an indication for the same in the alert definition. 
-       * Currently there is no systemWide definition
+       * StatAlert with alert definitions having functions assigned will get evaluated at manager
+       * side only.
-       * Evaluating system wide alerts:
-       *   1. It'll take time for aggregator to gather alerts from all members.
-       *      Member might keep joining & leaving in between. The member for whom 
-       *      the stat-alert value was taken might have left & new ones might 
-       *      have joined leave until all the calculations are complete. 
-       *      A disclaimer to be put that these are not exact values.
-       *   2. How would the aggregator know that it has received alerts from all 
-       *      the managers? Is the concept of system-wide alerts valid? 
-       *      System-wide stats might be!
-       *      
+       * Is combination of systemwide alerts with function valid? It should be & hence such
+       * evaluation should be skipped on manager side. Or is it to be evaluated at manager as well
+       * as aggragator?
+       */
+      // }
+
+      // TODO: is this object required? Or earlier canbe resused?
+      StatAlertNotification alertNotification = new StatAlertNotification(alert, memberId);
+
+      /*
+       * variable isSystemWide is created only for convienience, there should be an indication for
+       * the same in the alert definition. Currently there is no systemWide definition
+       * 
+       * Evaluating system wide alerts: 1. It'll take time for aggregator to gather alerts from all
+       * members. Member might keep joining & leaving in between. The member for whom the stat-alert
+       * value was taken might have left & new ones might have joined leave until all the
+       * calculations are complete. A disclaimer to be put that these are not exact values. 2. How
+       * would the aggregator know that it has received alerts from all the managers? Is the concept
+       * of system-wide alerts valid? System-wide stats might be!
+       * 
-        accumulatedAlertValues = (HashSet)alertsStore.get(defId);
-        
+        accumulatedAlertValues = (HashSet) alertsStore.get(defId);
+
-    } //for ends
-    
+    } // for ends
+
-    
+
-      logger.debug("Exiting AdminDistributedSystemJmxImpl.processNotifications(StatAlert[], GemFireVM) *************");
+      logger.debug(
+          "Exiting AdminDistributedSystemJmxImpl.processNotifications(StatAlert[], GemFireVM) *************");
-      logger.debug("AdminDistributedSystemJmxImpl#convertNotificationsDataToByteArray: {} notifications", notificationObjects.size());
+      logger.debug(
+          "AdminDistributedSystemJmxImpl#convertNotificationsDataToByteArray: {} notifications",
+          notificationObjects.size());
-    } catch(IOException ex) {
+    } catch (IOException ex) {
-  private void sendNotifications(ArrayList notificationObjects, 
-      ObjectName objName) {
+  private void sendNotifications(ArrayList notificationObjects, ObjectName objName) {
-        logger.debug("AdminDistributedSystemJmxImpl#sendNotifications: sending {} notifications", notificationObjects.size());
+        logger.debug("AdminDistributedSystemJmxImpl#sendNotifications: sending {} notifications",
+            notificationObjects.size());
-      
+
-      if (notifBytes!=null) {
-        Notification notif = new Notification(NOTIF_STAT_ALERT,  
-            objName, // Pass the StatNotifications
+      if (notifBytes != null) {
+        Notification notif = new Notification(NOTIF_STAT_ALERT, objName, // Pass the
+                                                                         // StatNotifications
-      for (int i = 0; i < notificationObjects.size(); i ++) {
-        StatAlertNotification not = (StatAlertNotification)
-            notificationObjects.get(i);
+      for (int i = 0; i < notificationObjects.size(); i++) {
+        StatAlertNotification not = (StatAlertNotification) notificationObjects.get(i);
-//      sendEmail("Gemfire AlertNotification on Member:" + objName, buf.toString());
+      // sendEmail("Gemfire AlertNotification on Member:" + objName, buf.toString());
-        String mess = LocalizedStrings.AdminDistributedSystemJmxImpl_STATISTICS_ALERT_FROM_DISTRIBUTED_SYSTEM_MEMBER_0_STATISTICS_1.toLocalizedString(new Object[] {objName.getCanonicalName(), buf.toString()} );
-        sendEmail(
-            EML_SUBJ_PRFX_GFE_ALERT + EML_SUBJ_ITEM_GFE_DS + getName() 
-            + " <"+LocalizedStrings.AdminDistributedSystemJmxImpl_STATISTICS_ALERT_FOR_MEMBER.toLocalizedString()+">", 
-            mess);
+        String mess =
+            LocalizedStrings.AdminDistributedSystemJmxImpl_STATISTICS_ALERT_FROM_DISTRIBUTED_SYSTEM_MEMBER_0_STATISTICS_1
+                .toLocalizedString(new Object[] {objName.getCanonicalName(), buf.toString()});
+        sendEmail(EML_SUBJ_PRFX_GFE_ALERT + EML_SUBJ_ITEM_GFE_DS + getName() + " <"
+            + LocalizedStrings.AdminDistributedSystemJmxImpl_STATISTICS_ALERT_FOR_MEMBER
+                .toLocalizedString()
+            + ">", mess);
-  
+
-   * Sends an email to the configured recipients using configured email server.
-   * The given message will be the email body. NOTE: the check whether email
-   * notfication is enabled or not should done using
-   * {@link #isEmailNotificationEnabled} before calling this method.
+   * Sends an email to the configured recipients using configured email server. The given message
+   * will be the email body. NOTE: the check whether email notfication is enabled or not should done
+   * using {@link #isEmailNotificationEnabled} before calling this method.
-   * @param subject
-   *          subject of the email
-   * @param message
-   *          message body of the email
+   * @param subject subject of the email
+   * @param message message body of the email
-	  if (mailManager == null) {
-	    mailManager = new MailManager(mailProps);
-	  }
+    if (mailManager == null) {
+      mailManager = new MailManager(mailProps);
+    }
-  public void processSystemwideNotifications() {
-  }
+  public void processSystemwideNotifications() {}
-   * This method is used to process ClientMembership events sent for
-   * BridgeMembership by bridge servers to all admin members.
+   * This method is used to process ClientMembership events sent for BridgeMembership by bridge
+   * servers to all admin members.
-   * @param senderId
-   *          id of the member that sent the ClientMembership changes for
-   *          processing (could be null)
-   * @param clientId
-   *          id of a client for which the notification was sent
-   * @param clientHost
-   *          host on which the client is/was running
-   * @param eventType
-   *          denotes whether the client Joined/Left/Crashed should be one of
-   *          ClientMembershipMessage#JOINED, ClientMembershipMessage#LEFT,
-   *          ClientMembershipMessage#CRASHED
+   * @param senderId id of the member that sent the ClientMembership changes for processing (could
+   *        be null)
+   * @param clientId id of a client for which the notification was sent
+   * @param clientHost host on which the client is/was running
+   * @param eventType denotes whether the client Joined/Left/Crashed should be one of
+   *        ClientMembershipMessage#JOINED, ClientMembershipMessage#LEFT,
+   *        ClientMembershipMessage#CRASHED
-  public void processClientMembership(String senderId, String clientId,
-      String clientHost, int eventType) {
-    logger.info(LocalizedMessage.create(LocalizedStrings.AdminDistributedSystemJmxImpl_PROCESSING_CLIENT_MEMBERSHIP_EVENT_0_FROM_1_FOR_2_RUNNING_ON_3, new String[] {ClientMembershipMessage.getEventTypeString(eventType), senderId, clientId, clientHost}));
+  public void processClientMembership(String senderId, String clientId, String clientHost,
+      int eventType) {
+    logger.info(LocalizedMessage.create(
+        LocalizedStrings.AdminDistributedSystemJmxImpl_PROCESSING_CLIENT_MEMBERSHIP_EVENT_0_FROM_1_FOR_2_RUNNING_ON_3,
+        new String[] {ClientMembershipMessage.getEventTypeString(eventType), senderId, clientId,
+            clientHost}));
-      
+
-        if (cacheVm.getId().equals(senderId) && 
-            cacheVm instanceof CacheServerJmxImpl) {
+        if (cacheVm.getId().equals(senderId) && cacheVm instanceof CacheServerJmxImpl) {
-      
+
-        
+
-          if (appVm.getId().equals(senderId) && 
-              appVm instanceof SystemMemberJmxImpl) {
+          if (appVm.getId().equals(senderId) && appVm instanceof SystemMemberJmxImpl) {
-        
+
-              new Object[] { senderId, clientId }), e);
+          new Object[] {senderId, clientId}), e);
-      logger.warn(e.getMessage(), e);//failed to send notification
+      logger.warn(e.getMessage(), e);// failed to send notification
-  
+
-   * Finds the member as per details in the given event object and passes on
-   * this event for handling the cache creation.
+   * Finds the member as per details in the given event object and passes on this event for handling
+   * the cache creation.
-   * @param event
-   *          event object corresponding to the creation of the cache
+   * @param event event object corresponding to the creation of the cache
-    
+
-    
+
-   * Finds the member as per details in the given event object and passes on
-   * this event for handling the cache closure.
+   * Finds the member as per details in the given event object and passes on this event for handling
+   * the cache closure.
-   * @param event
-   *          event object corresponding to the closure of the cache
+   * @param event event object corresponding to the closure of the cache
-    
+
-    
+
-   * Finds the member as per details in the given event object and passes on
-   * this event for handling the region creation.
+   * Finds the member as per details in the given event object and passes on this event for handling
+   * the region creation.
-   * @param event
-   *          event object corresponding to the creation of a region
+   * @param event event object corresponding to the creation of a region
-    
+
-  }  
-  
+  }
+
-   * Finds the member as per details in the given event object and passes on 
-   * this event for handling the region loss.
+   * Finds the member as per details in the given event object and passes on this event for handling
+   * the region loss.
-   * @param event
-   *          event object corresponding to the loss of a region
+   * @param event event object corresponding to the loss of a region
-    
+
-  }  
-  
+  }
+
+
-  
+
-  
+
-  
+
+
- * <ol> <li> Cache Created </li>
- * <li> Cache Closed </li>
- * <li> Region Created </li>
- * <li> Region Loss </li>
+ * <ol>
+ * <li>Cache Created</li>
+ * <li>Cache Closed</li>
+ * <li>Region Created</li>
+ * <li>Region Loss</li>
-   * @param adminDSResource
-   *          instance of AdminDistributedSystemJmxImpl
+   * @param adminDSResource instance of AdminDistributedSystemJmxImpl
-  
+
-  
+
-  
+
-    adminDS.handleRegionCreateEvent(event);    
+    adminDS.handleRegionCreateEvent(event);
-  
+
-  }  
+  }

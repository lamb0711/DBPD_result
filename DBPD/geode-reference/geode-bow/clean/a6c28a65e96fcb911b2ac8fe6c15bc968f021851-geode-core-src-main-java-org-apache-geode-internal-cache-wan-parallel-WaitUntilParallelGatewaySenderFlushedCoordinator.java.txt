GEODE-2400: use a function to implement waitUntilFlushed, then accessor and client
can have this feature.

-import org.apache.geode.DataSerializer;
-import org.apache.geode.cache.Cache;
-import java.io.DataInput;
-import java.io.DataOutput;
-import java.io.IOException;
-import java.util.Set;
-    boolean remoteResult = true, localResult = true;
+    boolean localResult = true;
+    if (pr == null) {
+      sender.getCancelCriterion().checkCancelInProgress(null);
+    }
-    // Send message to remote buckets
-    if (this.initiator) {
-      remoteResult = false;
-      try {
-        remoteResult = waitUntilFlushedOnRemoteMembers(pr);
-      } catch (Throwable t) {
-        exceptionToThrow = t;
-      }
-      if (logger.isDebugEnabled()) {
-        logger.debug("WaitUntilParallelGatewaySenderFlushedCoordinator: Processed remote result="
-            + remoteResult + "; exceptionToThrow=" + exceptionToThrow);
-      }
-    }
-
-            + (remoteResult && localResult));
+            + (localResult));
-      return remoteResult && localResult;
+      return localResult;
-  protected boolean waitUntilFlushedOnRemoteMembers(PartitionedRegion pr) throws Throwable {
-    boolean result = true;
-    DM dm = this.sender.getDistributionManager();
-    Set<InternalDistributedMember> recipients = pr.getRegionAdvisor().adviseDataStore();
-    if (!recipients.isEmpty()) {
-      if (logger.isDebugEnabled()) {
-        logger.debug(
-            "WaitUntilParallelGatewaySenderFlushedCoordinator: About to send message recipients="
-                + recipients);
-      }
-      WaitUntilGatewaySenderFlushedReplyProcessor processor =
-          new WaitUntilGatewaySenderFlushedReplyProcessor(dm, recipients);
-      WaitUntilGatewaySenderFlushedMessage message = new WaitUntilGatewaySenderFlushedMessage(
-          recipients, processor.getProcessorId(), this.sender.getId(), this.timeout, this.unit);
-      dm.putOutgoing(message);
-      if (logger.isDebugEnabled()) {
-        logger.debug("WaitUntilParallelGatewaySenderFlushedCoordinator: Sent message recipients="
-            + recipients);
-      }
-      try {
-        processor.waitForReplies();
-        result = processor.getCombinedResult();
-      } catch (ReplyException e) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("WaitUntilParallelGatewaySenderFlushedCoordinator: Caught e=" + e
-              + "; cause=" + e.getCause());
-        }
-        throw e.getCause();
-      } catch (InterruptedException e) {
-        dm.getCancelCriterion().checkCancelInProgress(e);
-        Thread.currentThread().interrupt();
-        result = false;
-      }
-    }
-    return result;
-  }
-
-  public static class WaitUntilGatewaySenderFlushedMessage extends PooledDistributionMessage
-      implements MessageWithReply {
-
-    private int processorId;
-
-    private String gatewaySenderId;
-
-    private long timeout;
-
-    private TimeUnit unit;
-
-    /* For serialization */
-    public WaitUntilGatewaySenderFlushedMessage() {}
-
-    protected WaitUntilGatewaySenderFlushedMessage(Collection recipients, int processorId,
-        String gatewaySenderId, long timeout, TimeUnit unit) {
-      super();
-      setRecipients(recipients);
-      this.processorId = processorId;
-      this.gatewaySenderId = gatewaySenderId;
-      this.timeout = timeout;
-      this.unit = unit;
-    }
-
-    @Override
-    protected void process(DistributionManager dm) {
-      boolean result = false;
-      ReplyException replyException = null;
-      try {
-        if (logger.isDebugEnabled()) {
-          logger.debug("WaitUntilGatewaySenderFlushedMessage: Processing gatewaySenderId="
-              + this.gatewaySenderId + "; timeout=" + this.timeout + "; unit=" + this.unit);
-        }
-        Cache cache = GemFireCacheImpl.getInstance();
-        if (cache != null) {
-          AbstractGatewaySender sender =
-              (AbstractGatewaySender) cache.getGatewaySender(this.gatewaySenderId);
-          if (sender != null) {
-            try {
-              WaitUntilParallelGatewaySenderFlushedCoordinator coordinator =
-                  new WaitUntilParallelGatewaySenderFlushedCoordinator(sender, this.timeout,
-                      this.unit, false);
-              result = coordinator.waitUntilFlushed();
-            } catch (Throwable e) {
-              replyException = new ReplyException(e);
-            }
-          }
-        }
-      } finally {
-        ReplyMessage replyMsg = new ReplyMessage();
-        replyMsg.setRecipient(getSender());
-        replyMsg.setProcessorId(this.processorId);
-        if (replyException == null) {
-          replyMsg.setReturnValue(result);
-        } else {
-          replyMsg.setException(replyException);
-        }
-        if (logger.isDebugEnabled()) {
-          logger.debug("WaitUntilGatewaySenderFlushedMessage: Sending reply returnValue="
-              + replyMsg.getReturnValue() + "; exception=" + replyMsg.getException());
-        }
-        dm.putOutgoing(replyMsg);
-      }
-    }
-
-    @Override
-    public int getDSFID() {
-      return WAIT_UNTIL_GATEWAY_SENDER_FLUSHED_MESSAGE;
-    }
-
-    @Override
-    public void toData(DataOutput out) throws IOException {
-      super.toData(out);
-      out.writeInt(this.processorId);
-      DataSerializer.writeString(this.gatewaySenderId, out);
-      out.writeLong(this.timeout);
-      DataSerializer.writeEnum(this.unit, out);
-    }
-
-    @Override
-    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      super.fromData(in);
-      this.processorId = in.readInt();
-      this.gatewaySenderId = DataSerializer.readString(in);
-      this.timeout = in.readLong();
-      this.unit = DataSerializer.readEnum(TimeUnit.class, in);
-    }
-  }

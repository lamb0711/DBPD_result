Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Executes the function on server (possibly without region/cache).<br> 
+ * Executes the function on server (possibly without region/cache).<br>
+ * 
-  
+
-  
+
-   * Does a execute Function on a server using connections from the given pool
-   * to communicate with the server.
+   * Does a execute Function on a server using connections from the given pool to communicate with
+   * the server.
+   * 
-      ServerFunctionExecutor executor, Object args,
-      MemberMappedArgument memberMappedArg, boolean allServers, byte hasResult,
-      ResultCollector rc, boolean isFnSerializationReqd,
+      ServerFunctionExecutor executor, Object args, MemberMappedArgument memberMappedArg,
+      boolean allServers, byte hasResult, ResultCollector rc, boolean isFnSerializationReqd,
-    final AbstractOp op = new ExecuteFunctionOpImpl(function, args,
-        memberMappedArg, hasResult, rc, isFnSerializationReqd, (byte)0, groups, allServers, executor.isIgnoreDepartedMembers());
+    final AbstractOp op = new ExecuteFunctionOpImpl(function, args, memberMappedArg, hasResult, rc,
+        isFnSerializationReqd, (byte) 0, groups, allServers, executor.isIgnoreDepartedMembers());
-        logger.debug("ExecuteFunctionOp#execute : Sending Function Execution Message:{} to all servers using pool: {}", op.getMessage(), pool);
+        logger.debug(
+            "ExecuteFunctionOp#execute : Sending Function Execution Message:{} to all servers using pool: {}",
+            op.getMessage(), pool);
-      List callableTasks = constructAndGetFunctionTasks(pool, function, args,
-          memberMappedArg, hasResult, rc, isFnSerializationReqd, attributes);
+      List callableTasks = constructAndGetFunctionTasks(pool, function, args, memberMappedArg,
+          hasResult, rc, isFnSerializationReqd, attributes);
-      if(function.isHA())
+      if (function.isHA())
-      
+
-              logger.debug("ExecuteFunctionOp#execute.reexecuteForServ : Sending Function Execution Message:{} to server using pool: {} with groups:{} all members:{} ignoreFailedMembers:{}", op.getMessage(), pool, Arrays.toString(groups), allServers, executor.isIgnoreDepartedMembers());
+              logger.debug(
+                  "ExecuteFunctionOp#execute.reexecuteForServ : Sending Function Execution Message:{} to server using pool: {} with groups:{} all members:{} ignoreFailedMembers:{}",
+                  op.getMessage(), pool, Arrays.toString(groups), allServers,
+                  executor.isIgnoreDepartedMembers());
-            reexecOp = new ExecuteFunctionOpImpl(function, args,
-                memberMappedArg, hasResult, rc, isFnSerializationReqd,
-                (byte)1/* isReExecute */, groups, allServers, executor.isIgnoreDepartedMembers());
+            reexecOp = new ExecuteFunctionOpImpl(function, args, memberMappedArg, hasResult, rc,
+                isFnSerializationReqd, (byte) 1/* isReExecute */, groups, allServers,
+                executor.isIgnoreDepartedMembers());
-              logger.debug("ExecuteFunctionOp#execute : Sending Function Execution Message:{} to server using pool: {} with groups:{} all members:{} ignoreFailedMembers:{}", op.getMessage(), pool, Arrays.toString(groups), allServers, executor.isIgnoreDepartedMembers());
+              logger.debug(
+                  "ExecuteFunctionOp#execute : Sending Function Execution Message:{} to server using pool: {} with groups:{} all members:{} ignoreFailedMembers:{}",
+                  op.getMessage(), pool, Arrays.toString(groups), allServers,
+                  executor.isIgnoreDepartedMembers());
-            logger.debug("ExecuteFunctionOp#execute : Received InternalFunctionInvocationTargetException. The failed node is {}", e.getFailedNodeSet());
+            logger.debug(
+                "ExecuteFunctionOp#execute : Received InternalFunctionInvocationTargetException. The failed node is {}",
+                e.getFailedNodeSet());
-            logger.debug("ExecuteFunctionOp#execute : Received ServerConnectivityException. The exception is {} The retryAttempt is : {} maxRetryAttempts  {}", se, retryAttempts, maxRetryAttempts);
+            logger.debug(
+                "ExecuteFunctionOp#execute : Received ServerConnectivityException. The exception is {} The retryAttempt is : {} maxRetryAttempts  {}",
+                se, retryAttempts, maxRetryAttempts);
-        ExecuteFunctionOp.reexecute(pool, function,
-            executor, rc, hasResult, isFnSerializationReqd, maxRetryAttempts - 1, groups, allServers);
+        ExecuteFunctionOp.reexecute(pool, function, executor, rc, hasResult, isFnSerializationReqd,
+            maxRetryAttempts - 1, groups, allServers);
-  
+
-      ServerFunctionExecutor executor, Object args,
-      MemberMappedArgument memberMappedArg, boolean allServers, byte hasResult,
-      ResultCollector rc, boolean isFnSerializationReqd, boolean isHA,
-      boolean optimizeForWrite, UserAttributes properties, String[] groups) {
-    final AbstractOp op = new ExecuteFunctionOpImpl(functionId, args,
-        memberMappedArg, hasResult, rc, isFnSerializationReqd, isHA,
-        optimizeForWrite, (byte)0, groups, allServers, executor.isIgnoreDepartedMembers());
+      ServerFunctionExecutor executor, Object args, MemberMappedArgument memberMappedArg,
+      boolean allServers, byte hasResult, ResultCollector rc, boolean isFnSerializationReqd,
+      boolean isHA, boolean optimizeForWrite, UserAttributes properties, String[] groups) {
+    final AbstractOp op = new ExecuteFunctionOpImpl(functionId, args, memberMappedArg, hasResult,
+        rc, isFnSerializationReqd, isHA, optimizeForWrite, (byte) 0, groups, allServers,
+        executor.isIgnoreDepartedMembers());
-        logger.debug("ExecuteFunctionOp#execute : Sending Function Execution Message:{} to all servers using pool: {}", op.getMessage(), pool);
+        logger.debug(
+            "ExecuteFunctionOp#execute : Sending Function Execution Message:{} to all servers using pool: {}",
+            op.getMessage(), pool);
-      List callableTasks = constructAndGetFunctionTasks(pool, functionId, args,
-          memberMappedArg, hasResult, rc, isFnSerializationReqd, isHA,
-          optimizeForWrite, properties);
+      List callableTasks = constructAndGetFunctionTasks(pool, functionId, args, memberMappedArg,
+          hasResult, rc, isFnSerializationReqd, isHA, optimizeForWrite, properties);
-      if(isHA){
+      if (isHA) {
-      
+
-            reexecOp = new ExecuteFunctionOpImpl(functionId, args,
-                memberMappedArg, hasResult, rc, isFnSerializationReqd, isHA,
-                optimizeForWrite, (byte)1, groups, allServers, executor.isIgnoreDepartedMembers());
+            reexecOp = new ExecuteFunctionOpImpl(functionId, args, memberMappedArg, hasResult, rc,
+                isFnSerializationReqd, isHA, optimizeForWrite, (byte) 1, groups, allServers,
+                executor.isIgnoreDepartedMembers());
-              logger.debug("ExecuteFunctionOp#execute : Sending Function Execution Message:{} to server using pool:{} with groups:{} all members:{} ignoreFailedMembers:{}", op.getMessage(), pool, Arrays.toString(groups), allServers, executor.isIgnoreDepartedMembers());
+              logger.debug(
+                  "ExecuteFunctionOp#execute : Sending Function Execution Message:{} to server using pool:{} with groups:{} all members:{} ignoreFailedMembers:{}",
+                  op.getMessage(), pool, Arrays.toString(groups), allServers,
+                  executor.isIgnoreDepartedMembers());
-            logger.debug("ExecuteFunctionOp#execute : Received InternalFunctionInvocationTargetException. The failed node is {}", e.getFailedNodeSet());
+            logger.debug(
+                "ExecuteFunctionOp#execute : Received InternalFunctionInvocationTargetException. The failed node is {}",
+                e.getFailedNodeSet());
-            logger.debug("ExecuteFunctionOp#execute : Received ServerConnectivityException. The exception is {} The retryAttempt is : {} maxRetryAttempts {}", se, retryAttempts, maxRetryAttempts);
+            logger.debug(
+                "ExecuteFunctionOp#execute : Received ServerConnectivityException. The exception is {} The retryAttempt is : {} maxRetryAttempts {}",
+                se, retryAttempts, maxRetryAttempts);
-            isFnSerializationReqd, maxRetryAttempts - 1, args, isHA,
-            optimizeForWrite, groups, allServers);
+            isFnSerializationReqd, maxRetryAttempts - 1, args, isHA, optimizeForWrite, groups,
+            allServers);
-  
+
-      ServerFunctionExecutor serverExecutor, ResultCollector resultCollector,
-      byte hasResult, boolean isFnSerializationReqd, int maxRetryAttempts, String[] groups, boolean allMembers) {
+      ServerFunctionExecutor serverExecutor, ResultCollector resultCollector, byte hasResult,
+      boolean isFnSerializationReqd, int maxRetryAttempts, String[] groups, boolean allMembers) {
-          serverExecutor.getMemberMappedArgument(), hasResult, resultCollector, isFnSerializationReqd, (byte)1, groups, allMembers, serverExecutor.isIgnoreDepartedMembers());
+          serverExecutor.getMemberMappedArgument(), hasResult, resultCollector,
+          isFnSerializationReqd, (byte) 1, groups, allMembers,
+          serverExecutor.isIgnoreDepartedMembers());
-        logger.debug("ExecuteFunction#reexecute : Sending Function Execution Message:{} to Server using pool:{} with groups:{} all members:{} ignoreFailedMembers:{}", reExecuteOp.getMessage(), pool, Arrays.toString(groups), allMembers, serverExecutor.isIgnoreDepartedMembers());
+        logger.debug(
+            "ExecuteFunction#reexecute : Sending Function Execution Message:{} to Server using pool:{} with groups:{} all members:{} ignoreFailedMembers:{}",
+            reExecuteOp.getMessage(), pool, Arrays.toString(groups), allMembers,
+            serverExecutor.isIgnoreDepartedMembers());
-          pool.execute(reExecuteOp,0);
-      }
-      catch (InternalFunctionInvocationTargetException e) {
+        pool.execute(reExecuteOp, 0);
+      } catch (InternalFunctionInvocationTargetException e) {
-          logger.debug("ExecuteFunctionOp#reexecute : Recieved InternalFunctionInvocationTargetException. The failed nodes are {}", e.getFailedNodeSet());
+          logger.debug(
+              "ExecuteFunctionOp#reexecute : Recieved InternalFunctionInvocationTargetException. The failed nodes are {}",
+              e.getFailedNodeSet());
-      }
-      catch (ServerConnectivityException se) {
+      } catch (ServerConnectivityException se) {
-        
-        if(se instanceof ServerOperationException){
+
+        if (se instanceof ServerOperationException) {
-        if (retryAttempts > maxRetryAttempts && maxRetryAttempts != -2) 
+        if (retryAttempts > maxRetryAttempts && maxRetryAttempts != -2)
-  
+
-      ServerFunctionExecutor serverExecutor, ResultCollector resultCollector,
-      byte hasResult, boolean isFnSerializationReqd, int maxRetryAttempts,
-      Object args, boolean isHA, boolean optimizeForWrite, String[] groups, boolean allMembers) {
+      ServerFunctionExecutor serverExecutor, ResultCollector resultCollector, byte hasResult,
+      boolean isFnSerializationReqd, int maxRetryAttempts, Object args, boolean isHA,
+      boolean optimizeForWrite, String[] groups, boolean allMembers) {
-      
-      final AbstractOp op = new ExecuteFunctionOpImpl(functionId, args,
-          serverExecutor.getMemberMappedArgument(), hasResult, resultCollector, isFnSerializationReqd, isHA, optimizeForWrite, (byte)1, groups, allMembers, serverExecutor.isIgnoreDepartedMembers());
-      
+
+      final AbstractOp op =
+          new ExecuteFunctionOpImpl(functionId, args, serverExecutor.getMemberMappedArgument(),
+              hasResult, resultCollector, isFnSerializationReqd, isHA, optimizeForWrite, (byte) 1,
+              groups, allMembers, serverExecutor.isIgnoreDepartedMembers());
+
-        logger.debug("ExecuteFunction#reexecute : Sending Function Execution Message:{} to Server using pool:{} with groups:{} all members:{} ignoreFailedMembers:{}", op.getMessage(), pool, Arrays.toString(groups), allMembers, serverExecutor.isIgnoreDepartedMembers());
+        logger.debug(
+            "ExecuteFunction#reexecute : Sending Function Execution Message:{} to Server using pool:{} with groups:{} all members:{} ignoreFailedMembers:{}",
+            op.getMessage(), pool, Arrays.toString(groups), allMembers,
+            serverExecutor.isIgnoreDepartedMembers());
-          pool.execute(op,0);
-      }
-      catch (InternalFunctionInvocationTargetException e) {
+        pool.execute(op, 0);
+      } catch (InternalFunctionInvocationTargetException e) {
-          logger.debug("ExecuteFunctionOp#reexecute : Recieved InternalFunctionInvocationTargetException. The failed nodes are {}", e.getFailedNodeSet());
+          logger.debug(
+              "ExecuteFunctionOp#reexecute : Recieved InternalFunctionInvocationTargetException. The failed nodes are {}",
+              e.getFailedNodeSet());
-      }
-      catch (ServerConnectivityException se) {
+      } catch (ServerConnectivityException se) {
-        
-        if(se instanceof ServerOperationException){
+
+        if (se instanceof ServerOperationException) {
-        if (retryAttempts > maxRetryAttempts && maxRetryAttempts != -2) 
+        if (retryAttempts > maxRetryAttempts && maxRetryAttempts != -2)
-  static List constructAndGetFunctionTasks(final PoolImpl pool,
-      final Function function, Object args,
-      MemberMappedArgument memberMappedArg, byte hasResult, ResultCollector rc,
+  static List constructAndGetFunctionTasks(final PoolImpl pool, final Function function,
+      Object args, MemberMappedArgument memberMappedArg, byte hasResult, ResultCollector rc,
-    ArrayList<ServerLocation> servers = null;
-    if (pool.getLocators() == null || pool.getLocators().isEmpty()) { 
-      servers = ((ExplicitConnectionSourceImpl)pool.getConnectionSource())
-          .getAllServers();
-    }
-    else {
-      servers = ((AutoConnectionSourceImpl)pool.getConnectionSource())
-          .findAllServers(); // n/w call on locator
-    }
-
+    List<ServerLocation> servers = pool.getConnectionSource().getAllServers();
-      final AbstractOp op = new ExecuteFunctionOpImpl(function,
-          args, memberMappedArg, hasResult, rc, isFnSerializationReqd, (byte)0, null/*onGroups does not use single-hop for now*/, false, false);
-      SingleHopOperationCallable task = new SingleHopOperationCallable(server, pool, op, attributes);
+      final AbstractOp op = new ExecuteFunctionOpImpl(function, args, memberMappedArg, hasResult,
+          rc, isFnSerializationReqd, (byte) 0, null/* onGroups does not use single-hop for now */,
+          false, false);
+      SingleHopOperationCallable task =
+          new SingleHopOperationCallable(server, pool, op, attributes);
-      
-  static List constructAndGetFunctionTasks(final PoolImpl pool,
-      final String functionId, Object args,
-      MemberMappedArgument memberMappedArg, byte hasResult, ResultCollector rc,
-      boolean isFnSerializationReqd, boolean isHA, boolean optimizeForWrite, UserAttributes properties) {
+
+  static List constructAndGetFunctionTasks(final PoolImpl pool, final String functionId,
+      Object args, MemberMappedArgument memberMappedArg, byte hasResult, ResultCollector rc,
+      boolean isFnSerializationReqd, boolean isHA, boolean optimizeForWrite,
+      UserAttributes properties) {
-    ArrayList<ServerLocation> servers = null;
-    if (pool.getLocators() == null || pool.getLocators().isEmpty()) { 
-      servers = ((ExplicitConnectionSourceImpl)pool.getConnectionSource())
-          .getAllServers();
-    }
-    else {
-      servers = ((AutoConnectionSourceImpl)pool.getConnectionSource())
-          .findAllServers(); // n/w call on locator
-    }
-
+    List<ServerLocation> servers = pool.getConnectionSource().getAllServers();
-      final AbstractOp op = new ExecuteFunctionOpImpl(functionId,
-          args, memberMappedArg, hasResult, rc, isFnSerializationReqd, isHA, optimizeForWrite, (byte)0,null/*onGroups does not use single-hop for now*/, false, false);
-      SingleHopOperationCallable task = new SingleHopOperationCallable(server, pool, op, properties);
+      final AbstractOp op = new ExecuteFunctionOpImpl(functionId, args, memberMappedArg, hasResult,
+          rc, isFnSerializationReqd, isHA, optimizeForWrite, (byte) 0,
+          null/* onGroups does not use single-hop for now */, false, false);
+      SingleHopOperationCallable task =
+          new SingleHopOperationCallable(server, pool, op, properties);
-  
+
-      for (int i=0; i<flags.length; i++) {
+      for (int i = 0; i < flags.length; i++) {
-    
-   //To get the instance of the Function Statistics we need the function name or instance
+
+    // To get the instance of the Function Statistics we need the function name or instance
-     * [0] = allMembers
-     * [1] = ignoreFailedMembers
+     * [0] = allMembers [1] = ignoreFailedMembers
-        MemberMappedArgument memberMappedArg, byte hasResult,
-        ResultCollector rc, boolean isFnSerializationReqd, byte isReexecute, String[] groups, boolean allMembers, boolean ignoreFailedMembers) {
+        MemberMappedArgument memberMappedArg, byte hasResult, ResultCollector rc,
+        boolean isFnSerializationReqd, byte isReexecute, String[] groups, boolean allMembers,
+        boolean ignoreFailedMembers) {
-      byte fnState = AbstractExecution.getFunctionState(function.isHA(),
-          function.hasResult(), function.optimizeForWrite());
+      byte fnState = AbstractExecution.getFunctionState(function.isHA(), function.hasResult(),
+          function.optimizeForWrite());
-      if(isFnSerializationReqd){
-        getMessage().addStringOrObjPart(function); 
-      }
-      else{
-        getMessage().addStringOrObjPart(function.getId()); 
+      if (isFnSerializationReqd) {
+        getMessage().addStringOrObjPart(function);
+      } else {
+        getMessage().addStringOrObjPart(function.getId());
-      if(isReexecute == 1) {
+      if (isReexecute == 1) {
-        MemberMappedArgument memberMappedArg, byte hasResult,
-        ResultCollector rc, boolean isFnSerializationReqd, boolean isHA,
-        boolean optimizeForWrite, byte isReexecute, String[] groups, boolean allMembers, boolean ignoreFailedMembers) {
+        MemberMappedArgument memberMappedArg, byte hasResult, ResultCollector rc,
+        boolean isFnSerializationReqd, boolean isHA, boolean optimizeForWrite, byte isReexecute,
+        String[] groups, boolean allMembers, boolean ignoreFailedMembers) {
-      byte fnState = AbstractExecution.getFunctionState(isHA,
-          hasResult == (byte)1 ? true : false, optimizeForWrite);
+      byte fnState = AbstractExecution.getFunctionState(isHA, hasResult == (byte) 1 ? true : false,
+          optimizeForWrite);
-      if(isReexecute == 1) {
+      if (isReexecute == 1) {
-      } 
+      }
-      
+
-      if(this.isFnSerializationReqd){
-        getMessage().addStringOrObjPart(function); 
-      }
-      else{
-        getMessage().addStringOrObjPart(function.getId()); 
+      if (this.isFnSerializationReqd) {
+        getMessage().addStringOrObjPart(function);
+      } else {
+        getMessage().addStringOrObjPart(function.getId());
-      if(isReexecute == 1) {
+      if (isReexecute == 1) {
-      if (GemFireCacheImpl.getClientFunctionTimeout() == GemFireCacheImpl.DEFAULT_CLIENT_FUNCTION_TIMEOUT) {
+      if (GemFireCacheImpl
+          .getClientFunctionTimeout() == GemFireCacheImpl.DEFAULT_CLIENT_FUNCTION_TIMEOUT) {
-          getMessage().addBytesPart(new byte[] { AbstractExecution.getReexecuteFunctionState(fnStateOrHasResult) });
+          getMessage().addBytesPart(
+              new byte[] {AbstractExecution.getReexecuteFunctionState(fnStateOrHasResult)});
-          getMessage().addBytesPart(new byte[] { fnStateOrHasResult });
+          getMessage().addBytesPart(new byte[] {fnStateOrHasResult});
-    @Override  
-    protected Object processResponse(Message msg) throws Exception {      
-      ChunkedMessage executeFunctionResponseMsg = (ChunkedMessage)msg;
+    @Override
+    protected Object processResponse(Message msg) throws Exception {
+      ChunkedMessage executeFunctionResponseMsg = (ChunkedMessage) msg;
-              logger.debug("ExecuteFunctionOpImpl#processResponse: received message of type EXECUTE_FUNCTION_RESULT.");
+              logger.debug(
+                  "ExecuteFunctionOpImpl#processResponse: received message of type EXECUTE_FUNCTION_RESULT.");
-            do{
+            do {
-              Object resultResponse = executeFunctionResponseMsg.getPart(0)
-                  .getObject();
+              Object resultResponse = executeFunctionResponseMsg.getPart(0).getObject();
-                result = ((ArrayList)resultResponse).get(0);
-              }
-              else {
+                result = ((ArrayList) resultResponse).get(0);
+              } else {
-                //String s = "While performing a remote " + getOpName();
-                FunctionException ex = ((FunctionException)result);
+                // String s = "While performing a remote " + getOpName();
+                FunctionException ex = ((FunctionException) result);
-                  DistributedMember memberID = (DistributedMember)((ArrayList)resultResponse)
-                      .get(1);
+                  DistributedMember memberID =
+                      (DistributedMember) ((ArrayList) resultResponse).get(1);
-                  FunctionStats.getFunctionStats(this.functionId)
-                      .incResultsReceived();
+                  FunctionStats.getFunctionStats(this.functionId).incResultsReceived();
-                }
-                else {
+                } else {
-              }else if (result instanceof Throwable) {
+              } else if (result instanceof Throwable) {
-                exception = new ServerOperationException(s, (Throwable)result);
+                exception = new ServerOperationException(s, (Throwable) result);
-                //Part exceptionToStringPart = msg.getPart(1);
+                // Part exceptionToStringPart = msg.getPart(1);
+              } else {
+                DistributedMember memberID =
+                    (DistributedMember) ((ArrayList) resultResponse).get(1);
+                resultCollector.addResult(memberID, result);
+                FunctionStats.getFunctionStats(this.functionId).incResultsReceived();
-              else {
-                DistributedMember memberID = (DistributedMember)((ArrayList)resultResponse)
-                    .get(1);
-                synchronized (resultCollector) {
-                  resultCollector.addResult(memberID, result);                    
-                }
-                FunctionStats.getFunctionStats(this.functionId)
-                    .incResultsReceived();
-              }
-            }while(!executeFunctionResponseMsg.isLastChunk());
+            } while (!executeFunctionResponseMsg.isLastChunk());
-            if(exception != null) {
+            if (exception != null) {
-              logger.debug("ExecuteFunctionOpImpl#processResponse: received all the results from server successfully.");
+              logger.debug(
+                  "ExecuteFunctionOpImpl#processResponse: received all the results from server successfully.");
-            return null;          
+            return null;
-              logger.debug("ExecuteFunctionOpImpl#processResponse: received message of type EXCEPTION");
+              logger.debug(
+                  "ExecuteFunctionOpImpl#processResponse: received message of type EXCEPTION");
-              FunctionException ex = ((FunctionException)obj);
+              FunctionException ex = ((FunctionException) obj);
-            }
-            else {
-              String s = ": While performing a remote execute Function" + ((Throwable)obj).getMessage();
-              throw new ServerOperationException(s, (Throwable)obj);              
+            } else {
+              String s =
+                  ": While performing a remote execute Function" + ((Throwable) obj).getMessage();
+              throw new ServerOperationException(s, (Throwable) obj);
-              logger.debug("ExecuteFunctionOpImpl#processResponse: received message of type EXECUTE_FUNCTION_ERROR");
+              logger.debug(
+                  "ExecuteFunctionOpImpl#processResponse: received message of type EXECUTE_FUNCTION_ERROR");
-            String errorMessage = executeFunctionResponseMsg.getPart(0)
-                .getString();
+            String errorMessage = executeFunctionResponseMsg.getPart(0).getString();
-            throw new InternalGemFireError(
-                LocalizedStrings.Op_UNKNOWN_MESSAGE_TYPE_0
-                  .toLocalizedString(
-                     Integer.valueOf(executeFunctionResponseMsg.getMessageType())));
+            throw new InternalGemFireError(LocalizedStrings.Op_UNKNOWN_MESSAGE_TYPE_0
+                .toLocalizedString(Integer.valueOf(executeFunctionResponseMsg.getMessageType())));
-      }
-      finally {
+      } finally {
-      }      
+      }
-    @Override  
+    @Override
-    @Override  
+    @Override
-    
+
-    @Override  
+    @Override
-    @Override  
+    @Override
-    @Override  
+    @Override
-  
-  public static final int MAX_FE_THREADS = Integer.getInteger(
-      "DistributionManager.MAX_FE_THREADS",
+
+  public static final int MAX_FE_THREADS = Integer.getInteger("DistributionManager.MAX_FE_THREADS",

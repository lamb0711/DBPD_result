Merge branch 'release/1.5.0'

-  public static final char SEPARATOR_CHAR = '/';
+  char SEPARATOR_CHAR = '/';
-  public static final String SEPARATOR = "/";
+  String SEPARATOR = "/";
-  public String getName();
+  String getName();
-  public String getFullPath();
+  String getFullPath();
-  public <PK, PV> Region<PK, PV> getParentRegion();
+  <PK, PV> Region<PK, PV> getParentRegion();
-  public RegionAttributes<K, V> getAttributes();
+  RegionAttributes<K, V> getAttributes();
-  public AttributesMutator<K, V> getAttributesMutator();
+  AttributesMutator<K, V> getAttributesMutator();
-  public CacheStatistics getStatistics() throws StatisticsDisabledException;
+  CacheStatistics getStatistics() throws StatisticsDisabledException;
-  public void invalidateRegion() throws TimeoutException;
+  void invalidateRegion() throws TimeoutException;
-  public void invalidateRegion(Object aCallbackArgument) throws TimeoutException;
+  void invalidateRegion(Object aCallbackArgument) throws TimeoutException;
-  public void localInvalidateRegion();
+  void localInvalidateRegion();
-  public void localInvalidateRegion(Object aCallbackArgument);
+  void localInvalidateRegion(Object aCallbackArgument);
-  public void destroyRegion() throws CacheWriterException, TimeoutException;
+  void destroyRegion() throws CacheWriterException, TimeoutException;
-  public void destroyRegion(Object aCallbackArgument) throws CacheWriterException, TimeoutException;
+  void destroyRegion(Object aCallbackArgument) throws CacheWriterException, TimeoutException;
-  public void localDestroyRegion();
+  void localDestroyRegion();
-  public void localDestroyRegion(Object aCallbackArgument);
+  void localDestroyRegion(Object aCallbackArgument);
-  public void close();
+  void close();
-  public RegionSnapshotService<K, V> getSnapshotService();
+  RegionSnapshotService<K, V> getSnapshotService();
-  public void saveSnapshot(OutputStream outputStream) throws IOException;
+  void saveSnapshot(OutputStream outputStream) throws IOException;
-  public void loadSnapshot(InputStream inputStream)
+  void loadSnapshot(InputStream inputStream)
-  public <SK, SV> Region<SK, SV> getSubregion(String path);
+  <SK, SV> Region<SK, SV> getSubregion(String path);
-  public <SK, SV> Region<SK, SV> createSubregion(String subregionName,
+  <SK, SV> Region<SK, SV> createSubregion(String subregionName,
-  public Set<Region<?, ?>> subregions(boolean recursive);
+  Set<Region<?, ?>> subregions(boolean recursive);
-  public Entry<K, V> getEntry(Object key);
+  Entry<K, V> getEntry(Object key);
-  public V get(Object key) throws CacheLoaderException, TimeoutException;
+  V get(Object key) throws CacheLoaderException, TimeoutException;
-  public V get(Object key, Object aCallbackArgument) throws TimeoutException, CacheLoaderException;
+  V get(Object key, Object aCallbackArgument) throws TimeoutException, CacheLoaderException;
-  public V put(K key, V value) throws TimeoutException, CacheWriterException;
+  V put(K key, V value) throws TimeoutException, CacheWriterException;
-  public V put(K key, V value, Object aCallbackArgument)
-      throws TimeoutException, CacheWriterException;
+  V put(K key, V value, Object aCallbackArgument) throws TimeoutException, CacheWriterException;
-  public void create(K key, V value)
-      throws TimeoutException, EntryExistsException, CacheWriterException;
+  void create(K key, V value) throws TimeoutException, EntryExistsException, CacheWriterException;
-  public void create(K key, V value, Object aCallbackArgument)
+  void create(K key, V value, Object aCallbackArgument)
-  public void invalidate(Object key) throws TimeoutException, EntryNotFoundException;
+  void invalidate(Object key) throws TimeoutException, EntryNotFoundException;
-  public void invalidate(Object key, Object aCallbackArgument)
+  void invalidate(Object key, Object aCallbackArgument)
-  public void localInvalidate(Object key) throws EntryNotFoundException;
+  void localInvalidate(Object key) throws EntryNotFoundException;
-  public void localInvalidate(Object key, Object aCallbackArgument) throws EntryNotFoundException;
+  void localInvalidate(Object key, Object aCallbackArgument) throws EntryNotFoundException;
-  public V destroy(Object key)
-      throws TimeoutException, EntryNotFoundException, CacheWriterException;
+  V destroy(Object key) throws TimeoutException, EntryNotFoundException, CacheWriterException;
-  public V destroy(Object key, Object aCallbackArgument)
+  V destroy(Object key, Object aCallbackArgument)
-  public void localDestroy(Object key) throws EntryNotFoundException;
+  void localDestroy(Object key) throws EntryNotFoundException;
-  public void localDestroy(Object key, Object aCallbackArgument) throws EntryNotFoundException;
+  void localDestroy(Object key, Object aCallbackArgument) throws EntryNotFoundException;
-  public Set<K> keySet();
+  Set<K> keySet();
-  public Collection<V> values();
+  Collection<V> values();
-  public Set<Region.Entry<?, ?>> entrySet(boolean recursive);
+  Set<Region.Entry<?, ?>> entrySet(boolean recursive);
-  public Cache getCache();
+  Cache getCache();
-  public RegionService getRegionService();
+  RegionService getRegionService();
-  public Object getUserAttribute();
+  Object getUserAttribute();
-  public void setUserAttribute(Object value);
+  void setUserAttribute(Object value);
-  public boolean isDestroyed();
+  boolean isDestroyed();
-  public boolean containsValueForKey(Object key);
+  boolean containsValueForKey(Object key);
-  public boolean containsKey(Object key);
+  boolean containsKey(Object key);
-  public Lock getRegionDistributedLock() throws IllegalStateException;
+  Lock getRegionDistributedLock() throws IllegalStateException;
-  public Lock getDistributedLock(Object key) throws IllegalStateException;
+  Lock getDistributedLock(Object key) throws IllegalStateException;
-  public void writeToDisk();
+  void writeToDisk();
-  public boolean existsValue(String queryPredicate) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException, QueryInvocationTargetException;
+  boolean existsValue(String queryPredicate) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException;
-  public <E> SelectResults<E> query(String queryPredicate) throws FunctionDomainException,
+  <E> SelectResults<E> query(String queryPredicate) throws FunctionDomainException,
-  public Object selectValue(String queryPredicate) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException, QueryInvocationTargetException;
+  Object selectValue(String queryPredicate) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException;
-  public void forceRolling();
+  void forceRolling();
-  public void becomeLockGrantor();
+  void becomeLockGrantor();
-  public void localClear();
+  void localClear();
-  public void clear();
+  void clear();
-  public boolean containsValue(Object value);
+  boolean containsValue(Object value);
-  public Set<Map.Entry<K, V>> entrySet(); // @todo darrel: should be Region.Entry
+  Set<Map.Entry<K, V>> entrySet(); // @todo darrel: should be Region.Entry
-  public boolean isEmpty();
+  boolean isEmpty();
-  public void putAll(Map<? extends K, ? extends V> map);
+  void putAll(Map<? extends K, ? extends V> map);
-  public void putAll(Map<? extends K, ? extends V> map, Object aCallbackArgument);
+  void putAll(Map<? extends K, ? extends V> map, Object aCallbackArgument);
-  public void removeAll(Collection<? extends K> keys);
+  void removeAll(Collection<? extends K> keys);
-  public void removeAll(Collection<? extends K> keys, Object aCallbackArgument);
+  void removeAll(Collection<? extends K> keys, Object aCallbackArgument);
-  public Map<K, V> getAll(Collection<?> keys);
+  Map<K, V> getAll(Collection<?> keys);
-  public <T extends K> Map<T, V> getAll(Collection<T> keys, Object aCallbackArgument);
+  <T extends K> Map<T, V> getAll(Collection<T> keys, Object aCallbackArgument);
-  public V remove(Object key);
+  V remove(Object key);
-  public int size();
+  int size();
-  public boolean equals(Object other);
+  boolean equals(Object other);
-  public int hashCode();
+  int hashCode();
-   * @param key The key on which to register interest. If the key is a <code>List</code>, then all
-   *        the keys in the <code>List</code> will be registered. The key can also be the special
-   *        token 'ALL_KEYS', which will register interest in all keys in the region. In effect,
-   *        this will cause an update to any key in this region in the CacheServer to be pushed to
-   *        the client.
+   * @param key The key on which to register interest.
-   *        This method uses the default <code>InterestResultPolicy</code>.
+   *        ###Deprecated behavior###
+   *        </p>
+   *        <p>
+   *        The following <code>List</code> and
+   *        'ALL_KEYS' behavior is now deprecated. As an alternative, please use
+   *        </p>
+   *        <p>
+   *        {@link #registerInterestForKeys(Iterable, InterestResultPolicy)}
+   *        </p>
+   *        <p>
+   *        {@link #registerInterestForAllKeys(InterestResultPolicy)}
+   *        </p>
+   *
+   *        <p>
+   *        If the key is a <code>List</code>, then all the keys in the
+   *        <code>List</code> will be registered. The key can also be the special token 'ALL_KEYS',
+   *        which will register interest in all keys in the region. In effect, this will cause an
+   *        update to any key in this region in the CacheServer to be pushed to the client.
-   *        ".*" as the argument. This means that all keys any type are pushed to the client and
+   *        ".*" as the argument. This means that all keys of any type are pushed to the client and
+   *        ###End of deprecation###
+   *
+   *        <p>
+   *        This method uses the default <code>InterestResultPolicy</code>.
+   *        </p>
-  public void registerInterest(K key);
+  void registerInterest(K key);
-   * @param key The key on which to register interest. If the key is a <code>List</code>, then all
-   *        the keys in the <code>List</code> will be registered. The key can also be the special
-   *        token 'ALL_KEYS', which will register interest in all keys in the region. In effect,
-   *        this will cause an update to any key in this region in the CacheServer to be pushed to
-   *        the client.
+   * @param key The key on which to register interest.
+   *
+   *        <p>
+   *        ###Deprecated behavior###
+   *        </p>
+   *        <p>
+   *        The following <code>List</code> and
+   *        'ALL_KEYS' behavior is now deprecated. As an alternative, please use
+   *        </p>
+   *        <p>
+   *        {@link #registerInterestForKeys(Iterable, InterestResultPolicy)}
+   *        </p>
+   *        <p>
+   *        {@link #registerInterestForAllKeys(InterestResultPolicy)}
+   *        </p>
+   *
+   *        <p>
+   *        If the key is a <code>List</code>, then all the keys in the
+   *        <code>List</code> will be registered. The key can also be the special token 'ALL_KEYS',
+   *        which will register interest in all keys in the region. In effect, this will cause an
+   *        update to any key in this region in the CacheServer to be pushed to the client.
+   *        </p>
+   *        ###End of deprecation###
-  public void registerInterest(K key, InterestResultPolicy policy);
+  void registerInterest(K key, InterestResultPolicy policy);
+
+
+  /**
+   * Sends a request to the CacheServer to register interest in all keys for this client. Updates to
+   * any key by other clients will be pushed to this client by the CacheServer. This method is
+   * currently supported only on clients in a client server topology. The keys are first locally
+   * cleared from the client and current value for the keys are inserted into the local cache before
+   * this call returns.
+   *
+   * @since Geode 1.5
+   *
+   * @throws UnsupportedOperationException if the region is not configured with a pool name.
+   * @throws SubscriptionNotEnabledException if the region's pool does not have subscriptions
+   *         enabled.
+   * @throws UnsupportedOperationException if the region is a replicate with distributed scope.
+   */
+  default void registerInterestForAllKeys() {
+    registerInterestRegex(".*");
+  }
+
+
+  /**
+   * Sends a request to the CacheServer to register interest in for all keys for this client.
+   * Updates to any key by other clients will be pushed to this client by the CacheServer. This
+   * method is currently supported only on clients in a client server topology. The keys are first
+   * locally cleared from the client and current value for the keys are inserted into the local
+   * cache before this call returns. (if requested).
+   *
+   * <p>
+   * If you locally-destroy a key and your region has concurrency-checks-enabled turned off you will
+   * not receive invalidation events from your interest subscription for that key. When
+   * concurrency-checks-enabled is turned on GemFire will accept invalidation and deliver these
+   * events to your client cache.
+   * </p>
+   *
+   * @param policy The interest result policy. This can be one of:
+   *        <ul>
+   *        <li>InterestResultPolicy.NONE - does not initialize the local cache</li>
+   *        <li>InterestResultPolicy.KEYS - initializes the local cache with the keys satisfying the
+   *        request</li>
+   *        <li>InterestResultPolicy.KEYS_VALUES - initializes the local cache with the keys and
+   *        current values satisfying the request</li>
+   *        </ul>
+   * @throws UnsupportedOperationException if the region is not configured with a pool name.
+   * @throws SubscriptionNotEnabledException if the region's pool does not have subcriptions
+   *         enabled.
+   * @throws UnsupportedOperationException if the region is a replicate with distributed scope.
+   *
+   * @see InterestResultPolicy
+   *
+   * @since Geode 1.5
+   */
+  default void registerInterestForAllKeys(InterestResultPolicy policy) {
+    registerInterestRegex(".*", policy);
+  }
+
+  /**
+   * Sends a request to the CacheServer to register interest in all keys for this client. Updates to
+   * any key by other clients will be pushed to this client by the CacheServer. This method is
+   * currently supported only on clients in a client server topology. The keys are first locally
+   * cleared from the client and the current value for the keys are inserted into the local cache
+   * before this call returns (if requested).
+   *
+   * @param policy The interest result policy. This can be one of:
+   *        <ul>
+   *        <li>InterestResultPolicy.NONE - does not initialize the local cache</li>
+   *        <li>InterestResultPolicy.KEYS - initializes the local cache with the keys satisfying the
+   *        request</li>
+   *        <li>InterestResultPolicy.KEYS_VALUES - initializes the local cache with the keys and
+   *        current values satisfying the request</li>
+   *        </ul>
+   * @param isDurable true if the register interest is durable
+   * @throws UnsupportedOperationException if the region is not configured with a pool name.
+   * @throws SubscriptionNotEnabledException if the region's pool does not have subscriptions
+   *         enabled.
+   * @throws UnsupportedOperationException if the region is a replicate with distributed scope.
+   *
+   * @see InterestResultPolicy
+   *
+   * @since Geode 1.5
+   */
+  default void registerInterestForAllKeys(InterestResultPolicy policy, boolean isDurable) {
+    registerInterestRegex(".*", policy, isDurable);
+  }
+
+
+  /**
+   * Sends a request to the CacheServer to register interest in all keys for this client. Updates to
+   * any key by other clients will be pushed to this client by the CacheServer. This method is
+   * currently supported only on clients in a client server topology. The keys are first locally
+   * cleared from the client and the current value for the keys are inserted into the local cache
+   * before this call returns (if requested).
+   *
+   * <p>
+   * If you locally-destroy a key and your region has concurrency-checks-enabled turned off you will
+   * not receive invalidation events from your interest subscription for that key. When
+   * concurrency-checks-enabled is turned on GemFire will accept invalidation and deliver these
+   * events to your client cache.
+   * </p>
+   *
+   * @param policy The interest result policy. This can be one of:
+   *        <ul>
+   *        <li>InterestResultPolicy.NONE - does not initialize the local cache</li>
+   *        <li>InterestResultPolicy.KEYS - initializes the local cache with the keys satisfying the
+   *        request</li>
+   *        <li>InterestResultPolicy.KEYS_VALUES - initializes the local cache with the keys and
+   *        current values satisfying the request</li>
+   *        </ul>
+   * @param isDurable true if the register interest is durable
+   * @param receiveValues defaults to true. set to false to receive create or update events as
+   *        invalidates similar to notify-by-subscription false.
+   * @throws UnsupportedOperationException if the region is not configured with a pool name.
+   * @throws SubscriptionNotEnabledException if the region's pool does not have subscriptions
+   *         enabled.
+   * @throws UnsupportedOperationException if the region is a replicate with distributed scope.
+   *
+   * @see InterestResultPolicy
+   *
+   * @since Geode 1.5
+   */
+  default void registerInterestForAllKeys(InterestResultPolicy policy, boolean isDurable,
+      boolean receiveValues) {
+    registerInterestRegex(".*", policy, isDurable, receiveValues);
+  }
+
+  /**
+   * Sends a request to the CacheServer to register interest for all key in the iterable for this
+   * client. Updates to any of the keys in the iterable by other clients will be pushed to this
+   * client by the CacheServer. This method is currently supported only on clients in a client
+   * server topology. The keys are first locally cleared from the client and current value for the
+   * keys are inserted into the local cache before this call returns. (if requested).
+   *
+   * <p>
+   * If you locally-destroy a key and your region has concurrency-checks-enabled turned off you will
+   * not receive invalidation events from your interest subscription for that key. When
+   * concurrency-checks-enabled is turned on GemFire will accept invalidation and deliver these
+   * events to your client cache.
+   * </p>
+   *
+   * @param iterable The <code>Iterable</code> of keys on which to register interest.
+   * @throws UnsupportedOperationException if the region is not configured with a pool name.
+   * @throws SubscriptionNotEnabledException if the region's pool does not have subcriptions
+   *         enabled.
+   * @throws UnsupportedOperationException if the region is a replicate with distributed scope.
+   **
+   * @since Geode 1.5
+   */
+  default void registerInterestForKeys(Iterable<K> iterable) {
+    iterable.forEach(k -> registerInterest(k));
+  }
+
+  /**
+   * Sends a request to the CacheServer to register interest for all key in the iterable for this
+   * client. Updates to any of the keys in the iterable by other clients will be pushed to this
+   * client by the CacheServer. This method is currently supported only on clients in a client
+   * server topology. The keys are first locally cleared from the client and current value for the
+   * keys are inserted into the local cache before this call returns. (if requested).
+   *
+   * <p>
+   * If you locally-destroy a key and your region has concurrency-checks-enabled turned off you will
+   * not receive invalidation events from your interest subscription for that key. When
+   * concurrency-checks-enabled is turned on GemFire will accept invalidation and deliver these
+   * events to your client cache.
+   * </p>
+   *
+   * @param iterable The <code>Iterable</code> of keys on which to register interest.
+   * @param policy The interest result policy. This can be one of:
+   *        <ul>
+   *        <li>InterestResultPolicy.NONE - does not initialize the local cache</li>
+   *        <li>InterestResultPolicy.KEYS - initializes the local cache with the keys satisfying the
+   *        request</li>
+   *        <li>InterestResultPolicy.KEYS_VALUES - initializes the local cache with the keys and
+   *        current values satisfying the request</li>
+   *        </ul>
+   * @throws UnsupportedOperationException if the region is not configured with a pool name.
+   * @throws SubscriptionNotEnabledException if the region's pool does not have subcriptions
+   *         enabled.
+   * @throws UnsupportedOperationException if the region is a replicate with distributed scope.
+   *
+   * @see InterestResultPolicy
+   *
+   * @since Geode 1.5
+   */
+  default void registerInterestForKeys(Iterable<K> iterable, InterestResultPolicy policy) {
+    iterable.forEach(k -> registerInterest(k, policy));
+  }
+
+  /**
+   * Sends a request to the CacheServer to register interest for all key in the iterable for this
+   * client. Updates to any of the keys in the iterable by other clients will be pushed to this
+   * client by the CacheServer. This method is currently supported only on clients in a client
+   * server topology. The keys are first locally cleared from the client and current value for the
+   * keys are inserted into the local cache before this call returns. (if requested).
+   *
+   * <p>
+   * If you locally-destroy a key and your region has concurrency-checks-enabled turned off you will
+   * not receive invalidation events from your interest subscription for that key. When
+   * concurrency-checks-enabled is turned on GemFire will accept invalidation and deliver these
+   * events to your client cache.
+   * </p>
+   *
+   * @param iterable The <code>Iterable</code> of keys on which to register interest.
+   * @param policy The interest result policy. This can be one of:
+   *        <ul>
+   *        <li>InterestResultPolicy.NONE - does not initialize the local cache</li>
+   *        <li>InterestResultPolicy.KEYS - initializes the local cache with the keys satisfying the
+   *        request</li>
+   *        <li>InterestResultPolicy.KEYS_VALUES - initializes the local cache with the keys and
+   *        current values satisfying the request</li>
+   *        </ul>
+   * @param isDurable true if the register interest is durable
+   * @throws UnsupportedOperationException if the region is not configured with a pool name.
+   * @throws SubscriptionNotEnabledException if the region's pool does not have subcriptions
+   *         enabled.
+   * @throws UnsupportedOperationException if the region is a replicate with distributed scope.
+   *
+   * @see InterestResultPolicy
+   *
+   * @since Geode 1.5
+   */
+  default void registerInterestForKeys(Iterable<K> iterable, InterestResultPolicy policy,
+      boolean isDurable) {
+    iterable.forEach(k -> registerInterest(k, policy, isDurable));
+  }
+
+  /**
+   * Sends a request to the CacheServer to register interest for all key in the iterable for this
+   * client. Updates to any of the keys in the iterable by other clients will be pushed to this
+   * client by the CacheServer. This method is currently supported only on clients in a client
+   * server topology. The keys are first locally cleared from the client and current value for the
+   * keys are inserted into the local cache before this call returns. (if requested).
+   *
+   * <p>
+   * If you locally-destroy a key and your region has concurrency-checks-enabled turned off you will
+   * not receive invalidation events from your interest subscription for that key. When
+   * concurrency-checks-enabled is turned on GemFire will accept invalidation and deliver these
+   * events to your client cache.
+   * </p>
+   *
+   * @param iterable The <code>Iterable</code> of keys on which to register interest.
+   * @param policy The interest result policy. This can be one of:
+   *        <ul>
+   *        <li>InterestResultPolicy.NONE - does not initialize the local cache</li>
+   *        <li>InterestResultPolicy.KEYS - initializes the local cache with the keys satisfying the
+   *        request</li>
+   *        <li>InterestResultPolicy.KEYS_VALUES - initializes the local cache with the keys and
+   *        current values satisfying the request</li>
+   *        </ul>
+   * @param isDurable true if the register interest is durable
+   * @param receiveValues defaults to true. set to false to receive create or update events as
+   *        invalidates similar to notify-by-subscription false.
+   * @throws UnsupportedOperationException if the region is not configured with a pool name.
+   * @throws SubscriptionNotEnabledException if the region's pool does not have subcriptions
+   *         enabled.
+   * @throws UnsupportedOperationException if the region is a replicate with distributed scope.
+   *
+   * @see InterestResultPolicy
+   *
+   * @since Geode 1.5
+   */
+  default void registerInterestForKeys(Iterable<K> iterable, InterestResultPolicy policy,
+      boolean isDurable, boolean receiveValues) {
+    iterable.forEach(k -> registerInterest(k, policy, isDurable, receiveValues));
+  }
+
-  public void registerInterestRegex(String regex);
+  void registerInterestRegex(String regex);
-  public void registerInterestRegex(String regex, InterestResultPolicy policy);
+  void registerInterestRegex(String regex, InterestResultPolicy policy);
-  public void unregisterInterest(K key);
+  void unregisterInterest(K key);
-  public void unregisterInterestRegex(String regex);
+  void unregisterInterestRegex(String regex);
-  public List<K> getInterestList();
+  List<K> getInterestList();
-   * @param key The key on which to register interest. If the key is a <code>List</code>, then all
-   *        the keys in the <code>List</code> will be registered. The key can also be the special
-   *        token 'ALL_KEYS', which will register interest in all keys in the region. In effect,
-   *        this will cause an update to any key in this region in the CacheServer to be pushed to
-   *        the client.
+   * @param key The key on which to register interest.
-   *        This method uses the default <code>InterestResultPolicy</code>.
+   *        ###Deprecated behavior###
+   *        </p>
+   *        <p>
+   *        The following <code>List</code> and
+   *        'ALL_KEYS' behavior is now deprecated. As an alternative, please use
+   *        </p>
+   *        <p>
+   *        {@link #registerInterestForKeys(Iterable, InterestResultPolicy)}
+   *        </p>
+   *        <p>
+   *        {@link #registerInterestForAllKeys(InterestResultPolicy)}
+   *        </p>
+   *
+   *        <p>
+   *        If the key is a <code>List</code>, then all the keys in the
+   *        <code>List</code> will be registered. The key can also be the special token 'ALL_KEYS',
+   *        which will register interest in all keys in the region. In effect, this will cause an
+   *        update to any key in this region in the CacheServer to be pushed to the client.
-   *        ".*" as the argument. This means that all keys any type are pushed to the client and
+   *        ".*" as the argument. This means that all keys of any type are pushed to the client and
+   *        ###End of deprecation###
+   *
+   *        <p>
+   *        This method uses the default <code>InterestResultPolicy</code>.
+   *        </p>
-  public void registerInterest(K key, boolean isDurable);
+  void registerInterest(K key, boolean isDurable);
-   * @param key The key on which to register interest. If the key is a <code>List</code>, then all
-   *        the keys in the <code>List</code> will be registered. The key can also be the special
-   *        token 'ALL_KEYS', which will register interest in all keys in the region. In effect,
-   *        this will cause an update to any key in this region in the CacheServer to be pushed to
-   *        the client.
+   * @param key The key on which to register interest.
-   *        This method uses the default <code>InterestResultPolicy</code>.
+   *        ###Deprecated behavior###
+   *        </p>
+   *        <p>
+   *        The following <code>List</code> and
+   *        'ALL_KEYS' behavior is now deprecated. As an alternative, please use
+   *        </p>
+   *        <p>
+   *        {@link #registerInterestForKeys(Iterable, InterestResultPolicy)}
+   *        </p>
+   *        <p>
+   *        {@link #registerInterestForAllKeys(InterestResultPolicy)}
+   *        </p>
+   *
+   *        <p>
+   *        If the key is a <code>List</code>, then all the keys in the
+   *        <code>List</code> will be registered. The key can also be the special token 'ALL_KEYS',
+   *        which will register interest in all keys in the region. In effect, this will cause an
+   *        update to any key in this region in the CacheServer to be pushed to the client.
-   *        ".*" as the argument. This means that all keys any type are pushed to the client and
+   *        ".*" as the argument. This means that all keys of any type are pushed to the client and
+   *        ###End of deprecation###
+   *        <p>
+   *        This method uses the default <code>InterestResultPolicy</code>.
+   *        </p>
-  public void registerInterest(K key, boolean isDurable, boolean receiveValues);
+  void registerInterest(K key, boolean isDurable, boolean receiveValues);
-   * @param key The key on which to register interest. If the key is a <code>List</code>, then all
-   *        the keys in the <code>List</code> will be registered. The key can also be the special
-   *        token 'ALL_KEYS', which will register interest in all keys in the region. In effect,
-   *        this will cause an update to any key in this region in the CacheServer to be pushed to
-   *        the client.
+   * @param key The key on which to register interest.
+   *
+   *        <p>
+   *        ###Deprecated behavior###
+   *        </p>
+   *        <p>
+   *        The following <code>List</code> and
+   *        'ALL_KEYS' behavior is now deprecated. As an alternative, please use
+   *        </p>
+   *        <p>
+   *        {@link #registerInterestForKeys(Iterable, InterestResultPolicy)}
+   *        </p>
+   *        <p>
+   *        {@link #registerInterestForAllKeys(InterestResultPolicy)}
+   *        </p>
+   *
+   *        <p>
+   *        If the key is a <code>List</code>, then all the keys in the
+   *        <code>List</code> will be registered. The key can also be the special token 'ALL_KEYS',
+   *        which will register interest in all keys in the region. In effect, this will cause an
+   *        update to any key in this region in the CacheServer to be pushed to the client.
+   *        </p>
+   *        ###End of deprecation###
-  public void registerInterest(K key, InterestResultPolicy policy, boolean isDurable,
+  void registerInterest(K key, InterestResultPolicy policy, boolean isDurable,
-   * @param key The key on which to register interest. If the key is a <code>List</code>, then all
-   *        the keys in the <code>List</code> will be registered. The key can also be the special
-   *        token 'ALL_KEYS', which will register interest in all keys in the region. In effect,
-   *        this will cause an update to any key in this region in the CacheServer to be pushed to
-   *        the client.
+   * @param key The key on which to register interest.
+   *
+   *        <p>
+   *        ###Deprecated behavior###
+   *        </p>
+   *        <p>
+   *        The following <code>List</code> and
+   *        'ALL_KEYS' behavior is now deprecated. As an alternative, please use
+   *        </p>
+   *        <p>
+   *        {@link #registerInterestForKeys(Iterable, InterestResultPolicy)}
+   *        </p>
+   *        <p>
+   *        {@link #registerInterestForAllKeys(InterestResultPolicy)}
+   *        </p>
+   *
+   *        <p>
+   *        If the key is a <code>List</code>, then all the keys in the
+   *        <code>List</code> will be registered. The key can also be the special token 'ALL_KEYS',
+   *        which will register interest in all keys in the region. In effect, this will cause an
+   *        update to any key in this region in the CacheServer to be pushed to the client.
+   *        </p>
+   *        ###End of deprecation###
-  public void registerInterest(K key, InterestResultPolicy policy, boolean isDurable);
+  void registerInterest(K key, InterestResultPolicy policy, boolean isDurable);
-  public void registerInterestRegex(String regex, boolean isDurable);
+  void registerInterestRegex(String regex, boolean isDurable);
-  public void registerInterestRegex(String regex, boolean isDurable, boolean receiveValues);
+  void registerInterestRegex(String regex, boolean isDurable, boolean receiveValues);
-  public void registerInterestRegex(String regex, InterestResultPolicy policy, boolean isDurable);
+  void registerInterestRegex(String regex, InterestResultPolicy policy, boolean isDurable);
-  public void registerInterestRegex(String regex, InterestResultPolicy policy, boolean isDurable,
+  void registerInterestRegex(String regex, InterestResultPolicy policy, boolean isDurable,
-  public List<String> getInterestListRegex();
+  List<String> getInterestListRegex();
-  public Set<K> keySetOnServer();
+  Set<K> keySetOnServer();
-  public boolean containsKeyOnServer(Object key);
+  boolean containsKeyOnServer(Object key);
-  public int sizeOnServer();
+  int sizeOnServer();
-  public boolean isEmptyOnServer();
+  boolean isEmptyOnServer();
-  public interface Entry<K, V> extends Map.Entry<K, V> {
+  interface Entry<K, V> extends Map.Entry<K, V> {
-    public K getKey();
+    K getKey();
-    public V getValue();
+    V getValue();
-    public Region<K, V> getRegion();
+    Region<K, V> getRegion();
-    public boolean isLocal();
+    boolean isLocal();
-    public CacheStatistics getStatistics();
+    CacheStatistics getStatistics();
-    public Object getUserAttribute();
+    Object getUserAttribute();
-    public Object setUserAttribute(Object userAttribute);
+    Object setUserAttribute(Object userAttribute);
-    public boolean isDestroyed();
+    boolean isDestroyed();
-    public V setValue(V value);
+    V setValue(V value);

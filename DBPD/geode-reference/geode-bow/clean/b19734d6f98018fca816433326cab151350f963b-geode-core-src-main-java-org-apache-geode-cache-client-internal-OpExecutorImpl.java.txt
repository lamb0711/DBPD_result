GEODE-6595: Deprecates and ignore thread local connection pool attribute. (#3394)

* Remove internals of thread local connection.
* Cleanup test usage of deprecated methods.

-import java.util.HashMap;
-import java.util.Map;
-  private final boolean threadLocalConnections;
-  private final ThreadLocal<Connection> localConnection = new ThreadLocal<Connection>();
-  /**
-   * maps serverLocations to Connections when threadLocalConnections is enabled with single-hop.
-   */
-  private final ThreadLocal<Map<ServerLocation, Connection>> localConnectionMap =
-      new ThreadLocal<Map<ServerLocation, Connection>>();
-      long serverTimeout, boolean threadLocalConnections, CancelCriterion cancelCriterion,
+      long serverTimeout, CancelCriterion cancelCriterion,
-    this.threadLocalConnections = threadLocalConnections;
-    Connection conn = (Connection) (threadLocalConnections ? localConnection.get() : null);
-    if (conn == null || conn.isDestroyed()) {
-      conn = connectionManager.borrowConnection(serverTimeout);
-    } else if (threadLocalConnections) {
-      // Fix for 43718. Clear the thread local connection
-      // while we're performing the op. It will be reset
-      // if the op succeeds.
-      localConnection.set(null);
-      if (!conn.activate()) {
-        conn = connectionManager.borrowConnection(serverTimeout);
-      }
-    }
+    Connection conn = connectionManager.borrowConnection(serverTimeout);
-          // This method will throw an exception if we need to stop
-          // It also unsets the threadlocal connection and notifies
-          // the connection manager if there are failures.
-      if (threadLocalConnections) {
-        conn.passivate(success);
-        // Fix for 43718. If the thread local was set to a different
-        // connection deeper in the call stack, return that connection
-        // and set our connection on the thread local.
-        Connection existingConnection = localConnection.get();
-        if (existingConnection != null && existingConnection != conn) {
-          connectionManager.returnConnection(existingConnection);
-        }
-
-        if (!conn.isDestroyed()) {
-          localConnection.set(conn);
-        } else {
-          localConnection.set(null);
-        }
-      } else {
-        connectionManager.returnConnection(conn);
-      }
+      connectionManager.returnConnection(conn);
-    ServerLocation retVal = null;
-    Connection conn = (Connection) (threadLocalConnections ? localConnection.get() : null);
-    if (conn == null || conn.isDestroyed()) {
-      conn = connectionManager.borrowConnection(serverTimeout);
-      retVal = conn.getServer();
+    Connection conn = connectionManager.borrowConnection(serverTimeout);
+    try {
+      return conn.getServer();
+    } finally {
-    } else {
-      retVal = conn.getServer();
-    return retVal;
-      if (useThreadLocalConnection(op, pingOp)) {
-        // no need to set threadLocal to null while the op is in progress since
-        // 43718 does not impact single-hop
-        conn = getActivatedThreadLocalConnectionForSingleHop(server, onlyUseExistingCnx);
-        returnCnx = false;
-      } else {
-        conn = connectionManager.borrowConnection(server, serverTimeout, onlyUseExistingCnx);
-      }
+      conn = connectionManager.borrowConnection(server, serverTimeout, onlyUseExistingCnx);
-      // This method will throw an exception if we need to stop
-      // It also unsets the threadlocal connection and notifies
-      // the connection manager if there are failures.
-      if (useThreadLocalConnection(op, pingOp)) {
-        conn.passivate(success);
-        setThreadLocalConnectionForSingleHop(server, conn);
-      }
-  private boolean useThreadLocalConnection(Op op, boolean pingOp) {
-    return threadLocalConnections && !pingOp && op.useThreadLocalConnection();
-  }
-
-  /**
-   * gets a connection to the given serverLocation either by looking up the threadLocal
-   * {@link #localConnectionMap}. If a connection does not exist (or has been destroyed) we borrow
-   * one from connectionManager.
-   *
-   * @return the activated connection
-   */
-  private Connection getActivatedThreadLocalConnectionForSingleHop(ServerLocation server,
-      boolean onlyUseExistingCnx) {
-    assert threadLocalConnections;
-    Connection conn = null;
-    Map<ServerLocation, Connection> connMap = this.localConnectionMap.get();
-    if (connMap != null && !connMap.isEmpty()) {
-      conn = connMap.get(server);
-    }
-    boolean borrow = true;
-    if (conn != null) {
-      if (conn.activate()) {
-        borrow = false;
-        if (!conn.getServer().equals(server)) {
-          // poolLoadConditioningMonitor can replace the connection's
-          // endpoint from underneath us. fixes bug 45151
-          borrow = true;
-        }
-      }
-    }
-    if (conn == null || borrow) {
-      conn = connectionManager.borrowConnection(server, serverTimeout, onlyUseExistingCnx);
-    }
-    if (borrow && connMap != null) {
-      connMap.remove(server);
-    }
-    return conn;
-  }
-
-  /**
-   * initializes the threadLocal {@link #localConnectionMap} and adds mapping of serverLocation to
-   * Connection.
-   */
-  private void setThreadLocalConnectionForSingleHop(ServerLocation server, Connection conn) {
-    assert threadLocalConnections;
-    Map<ServerLocation, Connection> connMap = this.localConnectionMap.get();
-    if (connMap == null) {
-      connMap = new HashMap<ServerLocation, Connection>();
-      this.localConnectionMap.set(connMap);
-    }
-    connMap.put(server, conn);
-  }
-
-  @Override
-  public void releaseThreadLocalConnection() {
-    Connection conn = localConnection.get();
-    localConnection.set(null);
-    if (conn != null) {
-      connectionManager.returnConnection(conn);
-    }
-    Map<ServerLocation, Connection> connMap = localConnectionMap.get();
-    localConnectionMap.set(null);
-    if (connMap != null) {
-      for (Connection c : connMap.values()) {
-        connectionManager.returnConnection(c);
-      }
-    }
-  }
-
-      // This method will throw an exception if we need to stop
-      // It also unsets the threadlocal connection and notifies
-      // the connection manager if there are failures.
+  /**
+   * This method will throw an exception if we need to stop the connection manager if there are
+   * failures.
+   */
-  public Connection getThreadLocalConnection() {
-    return localConnection.get();
-  }
-
-  public void setThreadLocalConnection(Connection conn) {
-    localConnection.set(conn);
-  }
-

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class MapRangeIndex extends AbstractMapIndex
-{
+public class MapRangeIndex extends AbstractMapIndex {
-  MapRangeIndex(String indexName, Region region, String fromClause,
-      String indexedExpression, String projectionAttributes,
-      String origFromClause, String origIndxExpr, String[] defintions,
-      boolean isAllKeys, String[] multiIndexingKeysPattern, Object[] mapKeys, IndexStatistics stats) {
-    super(indexName, region, fromClause, indexedExpression,
-        projectionAttributes, origFromClause, origIndxExpr, defintions, 
-        isAllKeys, multiIndexingKeysPattern, mapKeys, stats);
+  MapRangeIndex(String indexName, Region region, String fromClause, String indexedExpression,
+      String projectionAttributes, String origFromClause, String origIndxExpr, String[] defintions,
+      boolean isAllKeys, String[] multiIndexingKeysPattern, Object[] mapKeys,
+      IndexStatistics stats) {
+    super(indexName, region, fromClause, indexedExpression, projectionAttributes, origFromClause,
+        origIndxExpr, defintions, isAllKeys, multiIndexingKeysPattern, mapKeys, stats);
-    this.entryToMapKeysMap = new RegionEntryToValuesMap(new java.util.concurrent.ConcurrentHashMap(ra.getInitialCapacity(),ra.getLoadFactor(), ra.getConcurrencyLevel()),
-        true /* user target list as the map keys will be unique*/);
+    this.entryToMapKeysMap =
+        new RegionEntryToValuesMap(
+            new java.util.concurrent.ConcurrentHashMap(ra.getInitialCapacity(), ra.getLoadFactor(),
+                ra.getConcurrencyLevel()),
+            true /* user target list as the map keys will be unique */);
-  
+
-  void recreateIndexData() throws IMQException
-  {
+  void recreateIndexData() throws IMQException {
-  
+
-  public boolean containsEntry(RegionEntry entry)
-  {
+  public boolean containsEntry(RegionEntry entry) {
-     * this.nullMappedEntries.containsEntry(entry) ||
-     * this.undefinedMappedEntries .containsEntry(entry));
+     * this.nullMappedEntries.containsEntry(entry) || this.undefinedMappedEntries
+     * .containsEntry(entry));
-  
+
-  void addMapping(RegionEntry entry) throws IMQException
-  {
+  void addMapping(RegionEntry entry) throws IMQException {
-  
+
-      ((RangeIndex)rangeInd).clearCurrState();
+      ((RangeIndex) rangeInd).clearCurrState();
-      ((RangeIndex)rangeInd).addSavedMappings(entry);
+      ((RangeIndex) rangeInd).addSavedMappings(entry);
-  protected void removeMapping(RegionEntry entry, int opCode) throws IMQException
-  {
+  protected void removeMapping(RegionEntry entry, int opCode) throws IMQException {
-    //Values in reverse coould be null if map in region value does not
-    //contain any key which matches to index expression keys.
-    if (values == null ) {
+    // Values in reverse coould be null if map in region value does not
+    // contain any key which matches to index expression keys.
+    if (values == null) {
-      Iterator valuesIter = ((Collection)values).iterator();
+      Iterator valuesIter = ((Collection) values).iterator();
-        RangeIndex ri = (RangeIndex)this.mapKeyToValueIndex.get(key);
+        RangeIndex ri = (RangeIndex) this.mapKeyToValueIndex.get(key);
-        long end = - start;
+        long end = -start;
-    }
-    else {
-      RangeIndex ri = (RangeIndex)this.mapKeyToValueIndex.get(values);
+    } else {
+      RangeIndex ri = (RangeIndex) this.mapKeyToValueIndex.get(values);
-  protected void doIndexAddition(Object mapKey, Object indexKey, Object value,
-      RegionEntry entry) throws IMQException
-  {
+  protected void doIndexAddition(Object mapKey, Object indexKey, Object value, RegionEntry entry)
+      throws IMQException {
-      rg = new RangeIndex(indexName+"-"+mapKey, region, fromClause, indexedExpression,
-          projectionAttributes, this.originalFromClause,
-          this.originalIndexedExpression, this.canonicalizedDefinitions, stats);
-      //Shobhit: We need evaluator to verify RegionEntry and IndexEntry inconsistency.
+      rg = new RangeIndex(indexName + "-" + mapKey, region, fromClause, indexedExpression,
+          projectionAttributes, this.originalFromClause, this.originalIndexedExpression,
+          this.canonicalizedDefinitions, stats);
+      // Shobhit: We need evaluator to verify RegionEntry and IndexEntry inconsistency.
-      if(!isPr) {
+      if (!isPr) {
-    //This call is skipped when addMapping is called from MapRangeIndex
-    //rg.internalIndexStats.incNumUpdates();
+    // This call is skipped when addMapping is called from MapRangeIndex
+    // rg.internalIndexStats.incNumUpdates();
-  protected void saveIndexAddition(Object mapKey, Object indexKey, Object value,
-      RegionEntry entry) throws IMQException
-  {
+  protected void saveIndexAddition(Object mapKey, Object indexKey, Object value, RegionEntry entry)
+      throws IMQException {
-      rg = new RangeIndex(indexName+"-"+mapKey, region, fromClause, indexedExpression,
-          projectionAttributes, this.originalFromClause,
-          this.originalIndexedExpression, this.canonicalizedDefinitions, stats);
+      rg = new RangeIndex(indexName + "-" + mapKey, region, fromClause, indexedExpression,
+          projectionAttributes, this.originalFromClause, this.originalIndexedExpression,
+          this.canonicalizedDefinitions, stats);
-      if(!isPr) {
+      if (!isPr) {
-    //rg.internalIndexStats.incUpdatesInProgress(1);
+    // rg.internalIndexStats.incUpdatesInProgress(1);
-    //This call is skipped when addMapping is called from MapRangeIndex
-    //rg.internalIndexStats.incNumUpdates();
+    // This call is skipped when addMapping is called from MapRangeIndex
+    // rg.internalIndexStats.incNumUpdates();

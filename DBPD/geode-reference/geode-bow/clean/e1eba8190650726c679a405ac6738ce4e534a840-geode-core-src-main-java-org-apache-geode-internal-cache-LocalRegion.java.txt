GEODE-6534: Encapsulate LocalRegion entryUserAttributes

Make entryUserAttributes final and thread safe.

Lots of threads were checking for null and constructing it as either
ConcurrentHashMap or HashTable. Now it is a final ConcurrentHashMap.

Reduced visibility to private and added accessor.

-  Map entryUserAttributes;
+  private final Map<Object, Object> entryUserAttributes = new ConcurrentHashMap<>();
-      if (this.entryUserAttributes != null) {
-        this.entryUserAttributes.remove(key);
-      }
+      entryUserAttributes.remove(key);
-    if (this.entryUserAttributes != null) {
-      this.entryUserAttributes.remove(key);
-    }
+    entryUserAttributes.remove(key);
-      if (this.entryUserAttributes != null) {
-        this.entryUserAttributes.remove(key);
-      }
+      entryUserAttributes.remove(key);
+  @Override
+  public Map<Object, Object> getEntryUserAttributes() {
+    return entryUserAttributes;
+  }
+
-    if (this.entryUserAttributes != null) {
-      this.entryUserAttributes.remove(event.getKey());
-    }
+    entryUserAttributes.remove(event.getKey());
-    if (this.entryUserAttributes != null) {
-      this.entryUserAttributes.remove(key);
-    }
+    entryUserAttributes.remove(key);
-      Map userAttr = this.region.entryUserAttributes;
-      if (userAttr == null) {
-        return null;
-      }
-      return userAttr.get(getKey());
+      return region.getEntryUserAttributes().get(getKey());
-      LocalRegion lr = this.region;
-      if (lr.entryUserAttributes == null) {
-        lr.entryUserAttributes = new ConcurrentHashMap();
-      }
-      return lr.entryUserAttributes.put(getKey(), userAttribute);
+      return region.getEntryUserAttributes().put(getKey(), userAttribute);
-    Map userAttr = this.entryUserAttributes;
-    if (userAttr == null) {
-      return null;
-    }
-    return userAttr.get(entryKey);
+    return entryUserAttributes.get(entryKey);
-      Map userAttributes = LocalRegion.this.entryUserAttributes;
-      if (userAttributes == null) {
-        return null;
-      }
-      return userAttributes.get(basicGetEntry().getKey());
+      return entryUserAttributes.get(basicGetEntry().getKey());
-      if (LocalRegion.this.entryUserAttributes == null) {
-        LocalRegion.this.entryUserAttributes = new ConcurrentHashMap();
-      }
-      return LocalRegion.this.entryUserAttributes.put(basicGetEntry().getKey(), userAttribute);
+      return entryUserAttributes.put(basicGetEntry().getKey(), userAttribute);
-    if (this.entryUserAttributes != null) {
-      this.entryUserAttributes.clear();
-    }
+    entryUserAttributes.clear();

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class allows sockets to be closed without blocking.
- * In some cases we have seen a call of socket.close block for minutes.
- * This class maintains a thread pool for every other member we have
- * connected sockets to. Any request to close by default returns immediately
- * to the caller while the close is called by a background thread.
- * The requester can wait for a configured amount of time by setting
- * the "p2p.ASYNC_CLOSE_WAIT_MILLISECONDS" system property.
- * Idle threads that are not doing a close will timeout after 2 minutes.
- * This can be configured by setting the
- * "p2p.ASYNC_CLOSE_POOL_KEEP_ALIVE_SECONDS" system property.
- * A pool exists for each remote address that we have a socket connected to.
- * That way if close is taking a long time to one address we can still get closes
- * done to another address.
- * Each address pool by default has at most 8 threads. This max threads can be
- * configured using the "p2p.ASYNC_CLOSE_POOL_MAX_THREADS" system property.
+ * This class allows sockets to be closed without blocking. In some cases we have seen a call of
+ * socket.close block for minutes. This class maintains a thread pool for every other member we have
+ * connected sockets to. Any request to close by default returns immediately to the caller while the
+ * close is called by a background thread. The requester can wait for a configured amount of time by
+ * setting the "p2p.ASYNC_CLOSE_WAIT_MILLISECONDS" system property. Idle threads that are not doing
+ * a close will timeout after 2 minutes. This can be configured by setting the
+ * "p2p.ASYNC_CLOSE_POOL_KEEP_ALIVE_SECONDS" system property. A pool exists for each remote address
+ * that we have a socket connected to. That way if close is taking a long time to one address we can
+ * still get closes done to another address. Each address pool by default has at most 8 threads.
+ * This max threads can be configured using the "p2p.ASYNC_CLOSE_POOL_MAX_THREADS" system property.
-  /** Number of seconds to wait before timing out an unused async close thread. Default is 120 (2 minutes). */
-  static final long ASYNC_CLOSE_POOL_KEEP_ALIVE_SECONDS = Long.getLong("p2p.ASYNC_CLOSE_POOL_KEEP_ALIVE_SECONDS", 120).longValue();
-  /** Maximum number of threads that can be doing a socket close. Any close requests over this max will queue up waiting for a thread. */
-  static final int ASYNC_CLOSE_POOL_MAX_THREADS = Integer.getInteger("p2p.ASYNC_CLOSE_POOL_MAX_THREADS", 8).intValue();
-  /** How many milliseconds the synchronous requester waits for the async close to happen. Default is 0. Prior releases waited 50ms. */ 
-  static final long ASYNC_CLOSE_WAIT_MILLISECONDS = Long.getLong("p2p.ASYNC_CLOSE_WAIT_MILLISECONDS", 0).longValue();
-  
+  /**
+   * Number of seconds to wait before timing out an unused async close thread. Default is 120 (2
+   * minutes).
+   */
+  static final long ASYNC_CLOSE_POOL_KEEP_ALIVE_SECONDS =
+      Long.getLong("p2p.ASYNC_CLOSE_POOL_KEEP_ALIVE_SECONDS", 120).longValue();
+  /**
+   * Maximum number of threads that can be doing a socket close. Any close requests over this max
+   * will queue up waiting for a thread.
+   */
+  static final int ASYNC_CLOSE_POOL_MAX_THREADS =
+      Integer.getInteger("p2p.ASYNC_CLOSE_POOL_MAX_THREADS", 8).intValue();
+  /**
+   * How many milliseconds the synchronous requester waits for the async close to happen. Default is
+   * 0. Prior releases waited 50ms.
+   */
+  static final long ASYNC_CLOSE_WAIT_MILLISECONDS =
+      Long.getLong("p2p.ASYNC_CLOSE_WAIT_MILLISECONDS", 0).longValue();
+
-  
+
-    this(ASYNC_CLOSE_POOL_KEEP_ALIVE_SECONDS, ASYNC_CLOSE_POOL_MAX_THREADS, ASYNC_CLOSE_WAIT_MILLISECONDS, TimeUnit.MILLISECONDS);
+    this(ASYNC_CLOSE_POOL_KEEP_ALIVE_SECONDS, ASYNC_CLOSE_POOL_MAX_THREADS,
+        ASYNC_CLOSE_WAIT_MILLISECONDS, TimeUnit.MILLISECONDS);
+
-    this(ASYNC_CLOSE_POOL_KEEP_ALIVE_SECONDS, asyncClosePoolMaxThreads, asyncCloseWaitMillis, TimeUnit.MILLISECONDS);
+    this(ASYNC_CLOSE_POOL_KEEP_ALIVE_SECONDS, asyncClosePoolMaxThreads, asyncCloseWaitMillis,
+        TimeUnit.MILLISECONDS);
-  public SocketCloser(long asyncClosePoolKeepAliveSeconds, int asyncClosePoolMaxThreads, long asyncCloseWaitTime, TimeUnit asyncCloseWaitUnits) {
+
+  public SocketCloser(long asyncClosePoolKeepAliveSeconds, int asyncClosePoolMaxThreads,
+      long asyncCloseWaitTime, TimeUnit asyncCloseWaitUnits) {
-  
+
-        ThreadFactory tf = new ThreadFactory() { 
-          public Thread newThread(final Runnable command) { 
-            Thread thread = new Thread(tg, command); 
+        ThreadFactory tf = new ThreadFactory() {
+          public Thread newThread(final Runnable command) {
+            Thread thread = new Thread(tg, command);
-          } 
-        }; 
-        BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<Runnable>(); 
-        pool = new ThreadPoolExecutor(this.asyncClosePoolMaxThreads, this.asyncClosePoolMaxThreads, this.asyncClosePoolKeepAliveSeconds, TimeUnit.SECONDS, workQueue, tf);
+          }
+        };
+        BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<Runnable>();
+        pool = new ThreadPoolExecutor(this.asyncClosePoolMaxThreads, this.asyncClosePoolMaxThreads,
+            this.asyncClosePoolKeepAliveSeconds, TimeUnit.SECONDS, workQueue, tf);
+
-   * Call this method if you know all the resources in the closer
-   * for the given address are no longer needed.
-   * Currently a thread pool is kept for each address and if you
-   * know that an address no longer needs its pool then you should
-   * call this method.
+   * Call this method if you know all the resources in the closer for the given address are no
+   * longer needed. Currently a thread pool is kept for each address and if you know that an address
+   * no longer needs its pool then you should call this method.
+
+
-   * Call close when you are all done with your socket closer.
-   * If you call asyncClose after close is called then the
-   * asyncClose will be done synchronously.
+   * Call close when you are all done with your socket closer. If you call asyncClose after close is
+   * called then the asyncClose will be done synchronously.
-        for (ThreadPoolExecutor pool: asyncCloseExecutors.values()) {
+        for (ThreadPoolExecutor pool : asyncCloseExecutors.values()) {
+
+
-   * Closes the specified socket in a background thread.
-   * In some cases we see close hang (see bug 33665).
-   * Depending on how the SocketCloser is configured (see ASYNC_CLOSE_WAIT_MILLISECONDS)
-   * this method may block for a certain amount of time.
-   * If it is called after the SocketCloser is closed then a normal
-   * synchronous close is done.
+   * Closes the specified socket in a background thread. In some cases we see close hang (see bug
+   * 33665). Depending on how the SocketCloser is configured (see ASYNC_CLOSE_WAIT_MILLISECONDS)
+   * this method may block for a certain amount of time. If it is called after the SocketCloser is
+   * closed then a normal synchronous close is done.
+   * 
-  
+
+   * 
-    // 36041 - segv in jrockit in pthread signaling code.  This
+    // 36041 - segv in jrockit in pthread signaling code. This
-      // If this ever returns, rethrow the error.  We're poisoned
+      // If this ever returns, rethrow the error. We're poisoned
-      // this exception.  See bug #40783
+      // this exception. See bug #40783
-      // catch VirtualMachineError (see above).  However, there is
+      // catch VirtualMachineError (see above). However, there is
-      // that are caused by IOExceptions.  If this is the case, it's
+      // that are caused by IOExceptions. If this is the case, it's

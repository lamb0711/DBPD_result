Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
-import com.gemstone.gemfire.internal.logging.SecurityLogWriter;
-    if (transport.isMcastDiscovery()) {
-      connectToDS();
-    } else {
-      daemon = new DSConnectionDaemon();
-      daemon.start();
-      // give the daemon some time to get us connected
-      // we don't want to wait forever since there may be no one to connect to
-      try {
-        long endTime = System.currentTimeMillis() + 2000; // wait 2 seconds
-        while (!connected && daemon.isAlive() && System.currentTimeMillis() < endTime) {
-          daemon.join(200);
-        }
-      } 
-      catch (InterruptedException ignore) {
-        Thread.currentThread().interrupt();
-        // Peremptory cancellation check, but keep going
-        this.system.getCancelCriterion().checkCancelInProgress(ignore);
+    daemon = new DSConnectionDaemon();
+    daemon.start();
+    // give the daemon some time to get us connected
+    // we don't want to wait forever since there may be no one to connect to
+    try {
+      long endTime = System.currentTimeMillis() + 2000; // wait 2 seconds
+      while (!connected && daemon.isAlive() && System.currentTimeMillis() < endTime) {
+        daemon.join(200);
+    } 
+    catch (InterruptedException ignore) {
+      Thread.currentThread().interrupt();
+      // Peremptory cancellation check, but keep going
+      this.system.getCancelCriterion().checkCancelInProgress(ignore);
-      if (!transport.isMcastDiscovery()) {
-        daemon.shutDown();
-      }
+
+      daemon.shutDown();
+      
-        InternalDistributedMember whoSuspected) {
+        InternalDistributedMember whoSuspected, String reason) {

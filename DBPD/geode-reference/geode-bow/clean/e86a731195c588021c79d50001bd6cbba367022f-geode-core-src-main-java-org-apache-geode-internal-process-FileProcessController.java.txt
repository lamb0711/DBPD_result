Merge branch 'release/1.3.0'

-import org.apache.commons.lang.StringUtils;
-import org.apache.geode.distributed.internal.DistributionConfig;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.LogService;
-import org.apache.geode.internal.process.ControlFileWatchdog.ControlRequestHandler;
-import org.apache.geode.lang.AttachAPINotFoundException;
-import org.apache.logging.log4j.Logger;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.apache.commons.lang.StringUtils.isBlank;
+import static org.apache.commons.lang.Validate.isTrue;
+import static org.apache.commons.lang.Validate.notNull;
+import org.apache.geode.internal.i18n.LocalizedStrings;
+import org.apache.geode.internal.process.ControlFileWatchdog.ControlRequestHandler;
+import org.apache.geode.lang.AttachAPINotFoundException;
+
-public class FileProcessController implements ProcessController {
-  private static final Logger logger = LogService.getLogger();
+class FileProcessController implements ProcessController {
-  public static final String STATUS_TIMEOUT_PROPERTY =
-      DistributionConfig.GEMFIRE_PREFIX + "FileProcessController.STATUS_TIMEOUT";
+  static final long DEFAULT_STATUS_TIMEOUT_MILLIS = 60 * 1000;
-  private final FileControllerParameters arguments;
+  private final FileControllerParameters parameters;
-   * @param arguments details about the controllable process
+   * @param parameters details about the controllable process
-  public FileProcessController(final FileControllerParameters arguments, final int pid) {
-    this(arguments, pid, Long.getLong(STATUS_TIMEOUT_PROPERTY, 60 * 1000), TimeUnit.MILLISECONDS);
+  FileProcessController(final FileControllerParameters parameters, final int pid) {
+    this(parameters, pid, DEFAULT_STATUS_TIMEOUT_MILLIS, MILLISECONDS);
-   * @param arguments details about the controllable process
+   * @param parameters details about the controllable process
-  public FileProcessController(final FileControllerParameters arguments, final int pid,
+  FileProcessController(final FileControllerParameters parameters, final int pid,
-    if (pid < 1) {
-      throw new IllegalArgumentException("Invalid pid '" + pid + "' specified");
-    }
+    notNull(parameters, "Invalid parameters '" + parameters + "' specified");
+    isTrue(pid > 0, "Invalid pid '" + pid + "' specified");
+    isTrue(timeout >= 0, "Invalid timeout '" + timeout + "' specified");
+    notNull(units, "Invalid units '" + units + "' specified");
+
-    this.arguments = arguments;
+    this.parameters = parameters;
-    return this.pid;
+    return pid;
-    return status(this.arguments.getWorkingDirectory(),
-        this.arguments.getProcessType().getStatusRequestFileName(),
-        this.arguments.getProcessType().getStatusFileName());
+    return status(parameters.getDirectory(), parameters.getProcessType().getStatusRequestFileName(),
+        parameters.getProcessType().getStatusFileName());
-    stop(this.arguments.getWorkingDirectory(),
-        this.arguments.getProcessType().getStopRequestFileName());
+    stop(parameters.getDirectory(), parameters.getProcessType().getStopRequestFileName());
+  long getStatusTimeoutMillis() {
+    return statusTimeoutMillis;
+  }
+
-    final File stopRequestFile = new File(workingDir, stopRequestFileName);
+    File stopRequestFile = new File(workingDir, stopRequestFileName);
-    final File statusFile = new File(workingDir, statusFileName);
-    final AtomicReference<String> statusRef = new AtomicReference<>();
+    File statusFile = new File(workingDir, statusFileName);
+    AtomicReference<String> statusRef = new AtomicReference<>();
-    final ControlRequestHandler statusHandler = new ControlRequestHandler() {
-      @Override
-      public void handleRequest() throws IOException {
-        // read the statusFile
-        final BufferedReader reader = new BufferedReader(new FileReader(statusFile));
-        final StringBuilder lines = new StringBuilder();
-        try {
-          String line = null;
-          while ((line = reader.readLine()) != null) {
-            lines.append(line);
-          }
-        } finally {
-          statusRef.set(lines.toString());
-          reader.close();
-        }
+    ControlRequestHandler statusHandler = () -> {
+      // read the statusFile
+      StringBuilder lines = new StringBuilder();
+      try (BufferedReader reader = new BufferedReader(new FileReader(statusFile))) {
+        reader.lines().forEach(lines::append);
+      } finally {
+        statusRef.set(lines.toString());
-    final ControlFileWatchdog statusFileWatchdog =
+    ControlFileWatchdog statusFileWatchdog =
-    final File statusRequestFile = new File(workingDir, statusRequestFileName);
+    File statusRequestFile = new File(workingDir, statusRequestFileName);
-    final long start = System.currentTimeMillis();
+    long start = System.currentTimeMillis();
-      if (System.currentTimeMillis() >= start + this.statusTimeoutMillis) {
-        final TimeoutException te =
-            new TimeoutException("Timed out waiting for process to create " + statusFile);
-        try {
-          statusFileWatchdog.stop();
-        } catch (InterruptedException e) {
-          logger.info("Interrupted while stopping status file watchdog.", e);
-        } catch (RuntimeException e) {
-          logger.info("Unexpected failure while stopping status file watchdog.", e);
-        }
-        throw te;
+      if (System.currentTimeMillis() >= start + statusTimeoutMillis) {
+        statusFileWatchdog.stop();
+        throw new TimeoutException("Timed out waiting for process to create " + statusFile);
-    final String lines = statusRef.get();
-    if (StringUtils.isBlank(lines)) {
-      throw new IllegalStateException("Failed to read status file");
+    String lines = statusRef.get();
+    if (isBlank(lines)) {
+      throw new IllegalStateException("Status file '" + statusFile + "' is blank");

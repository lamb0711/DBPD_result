GEODE-3622: Implement new algorithm for eviction (#1017)

* GEODE-3622: Implement new algorithm for eviction

  * Old algorithm is still used by default. Use "-Dgeode.EvictionScanAsync=true"
    to enable the new algorithm. Note that the new algorithm is still experimental
    and is subject to change. The new algorithm uses asynchronous sorting of the
    LRU list to prevent a long synchronous sort when the first item is evicted.
  * Moved region entries into their own package
  * Organized eviction code into new eviction package
  * General refactoring of eviction classes

-import org.apache.geode.internal.cache.lru.EnableLRU;
-import org.apache.geode.internal.cache.lru.HeapEvictor;
-import org.apache.geode.internal.cache.lru.HeapLRUCapacityController;
-import org.apache.geode.internal.cache.lru.LRUAlgorithm;
-import org.apache.geode.internal.cache.lru.LRUEntry;
-import org.apache.geode.internal.cache.lru.LRUStatistics;
-import org.apache.geode.internal.cache.lru.MemLRUCapacityController;
-import org.apache.geode.internal.cache.lru.NewLIFOClockHand;
-import org.apache.geode.internal.cache.lru.NewLRUClockHand;
+import org.apache.geode.internal.cache.eviction.CachedDeserializableValueWrapper;
+import org.apache.geode.internal.cache.eviction.EvictableEntry;
+import org.apache.geode.internal.cache.eviction.EvictionController;
+import org.apache.geode.internal.cache.eviction.EvictionList;
+import org.apache.geode.internal.cache.eviction.EvictionListBuilder;
+import org.apache.geode.internal.cache.eviction.EvictionStatistics;
+import org.apache.geode.internal.cache.eviction.HeapEvictor;
+import org.apache.geode.internal.cache.eviction.HeapLRUController;
+import org.apache.geode.internal.cache.eviction.MemoryLRUController;
-  protected abstract void _setCCHelper(EnableLRU ccHelper);
-
-  protected abstract EnableLRU _getCCHelper();
-
-  protected abstract void _setLruList(NewLRUClockHand lruList);
-
-  protected abstract NewLRUClockHand _getLruList();
-
-  private LRUAlgorithm evictionController;
+  private EvictionController evictionController;
+  protected abstract void setEvictionList(EvictionList evictionList);
+
+  public abstract EvictionList getEvictionList();
+
+  protected EvictionController getEvictionController() {
+    return evictionController;
+  }
+
+    super.initialize(owner, attr, internalRegionArgs, true);
+    createEvictionController(owner, internalRegionArgs);
+  }
-    super.initialize(owner, attr, internalRegionArgs, true/* isLRU */);
-
-    EvictionAlgorithm ea;
-    LRUAlgorithm ec;
+  private void createEvictionController(Object owner, InternalRegionArguments internalRegionArgs) {
+    EvictionAlgorithm evictionAlgorithm;
+    EvictionController evictionController;
-      ea = ((LocalRegion) owner).getEvictionAttributes().getAlgorithm();
-      ec = ((LocalRegion) owner).getEvictionController();
+      evictionAlgorithm = ((LocalRegion) owner).getEvictionAttributes().getAlgorithm();
+      evictionController = ((LocalRegion) owner).getEvictionController();
-      ea = phdr.getActualLruAlgorithm();
-      ec = phdr.getEvictionAttributes().createEvictionController(null, phdr.getOffHeap());
+      evictionAlgorithm = phdr.getActualLruAlgorithm();
+      evictionController =
+          phdr.getEvictionAttributes().createEvictionController(null, phdr.getOffHeap());
-    this.evictionController = ec;
-    if (ea.isLRUMemory()) {
-      ((MemLRUCapacityController) ec).setEntryOverHead(getEntryOverHead());
+    if (evictionAlgorithm.isLRUMemory()) {
+      ((MemoryLRUController) evictionController).setEntryOverHead(getEntryOverHead());
-    if (ea.isLRUHeap()) {
-      ((HeapLRUCapacityController) ec).setEntryOverHead(getEntryOverHead());
+    if (evictionAlgorithm.isLRUHeap()) {
+      ((HeapLRUController) evictionController).setEntryOverHead(getEntryOverHead());
-    _setCCHelper(getHelper(ec));
-
-    /*
-     * modification for LIFO Logic incubation
-     *
-     */
-    if (ea == EvictionAlgorithm.LIFO_ENTRY || ea == EvictionAlgorithm.LIFO_MEMORY) {
-      _setLruList(new NewLIFOClockHand(owner, _getCCHelper(), internalRegionArgs));
-    } else {
-      _setLruList(new NewLRUClockHand(owner, _getCCHelper(), internalRegionArgs));
-    }
+    this.evictionController = evictionController;
+    setEvictionList(new EvictionListBuilder(evictionAlgorithm).withArgs(internalRegionArgs)
+        .withRegion(owner).withEvictionController(getEvictionController()).create());
-    _getLruList().setBucketRegion(r);
+    getEvictionList().setBucketRegion(r);
-
-  /**
-   * Marker class to indicate that the wrapped value is owned by a CachedDeserializable and its form
-   * is changing from serialized to deserialized.
-   */
-  public static class CDValueWrapper {
-    private final Object v;
-
-    CDValueWrapper(Object v) {
-      this.v = v;
-    }
-
-    public Object getValue() {
-      return this.v;
-    }
-  }
-
-  public boolean beginChangeValueForm(LRUEntry le, CachedDeserializable cd, Object v) {
+  public boolean beginChangeValueForm(EvictableEntry le, CachedDeserializable cd, Object v) {
-    // @todo what if a clear is done and this entry is no longer in the region?
-      if (_getCCHelper().getEvictionAlgorithm().isLRUEntry()) {
+      if (getEvictionController().getEvictionAlgorithm().isLRUEntry()) {
-    int delta = le.updateEntrySize(_getCCHelper(), new CDValueWrapper(v));
+    int delta =
+        le.updateEntrySize(getEvictionController(), new CachedDeserializableValueWrapper(v));
-    if (_getCCHelper().getEvictionAlgorithm().isLRUHeap() && _isOwnerALocalRegion()
+    if (getEvictionController().getEvictionAlgorithm().isLRUHeap() && _isOwnerALocalRegion()
-  /** unsafe audit code. */
-  public void audit() {
-    if (logger.isTraceEnabled(LogMarker.LRU)) {
-      logger.trace(LogMarker.LRU, "Size of LRUMap = {}", sizeInVM());
-    }
-    _getLruList().audit();
-  }
-
-  protected int evictEntry(LRUEntry entry, LRUStatistics stats) throws RegionClearedException {
-    EvictionAction action = _getCCHelper().getEvictionAction();
+  protected int evictEntry(EvictableEntry entry, EvictionStatistics stats)
+      throws RegionClearedException {
+    EvictionAction action = getEvictionController().getEvictionAction();
+        stats.incDestroys();
-        change = DiskEntry.Helper.overflowToDisk((DiskEntry) entry, region, _getCCHelper());
+        change =
+            DiskEntry.Helper.overflowToDisk((DiskEntry) entry, region, getEvictionController());
-    _getLruList().stats().updateCounter(delta);
+    getEvictionList().getStatistics().updateCounter(delta);
-  /**
-   * access the getHelper method on the eviction controller to initialize the ccHelper field.
-   *
-   * @param ec The governing eviction controller.
-   * @return the helper instance from the eviction controller.
-   */
-  private static EnableLRU getHelper(LRUAlgorithm ec) {
-    return ec.getLRUHelper();
-  }
-
-    return _getLruList().stats().getLimit();
+    return getEvictionController().getStatistics().getLimit();
-  public LRUStatistics getLRUStatistics() {
-    return _getLruList().stats();
+  public EvictionStatistics getLRUStatistics() {
+    return getEvictionController().getStatistics();
-    return _getLruList().stats().getCounter();
+    return getEvictionController().getStatistics().getCounter();
-          getTotalEntrySize(), this._getLruList().getExpensiveListCount(), size(), delta,
-          getLimit(), _getOwner().getTombstoneCount());
+          getTotalEntrySize(), this.getEvictionList().size(), size(), delta, getLimit(),
+          _getOwner().getTombstoneCount());
-    LRUStatistics stats = _getLruList().stats();
+    EvictionStatistics stats = getEvictionList().getStatistics();
-    } else if (_getCCHelper().getEvictionAlgorithm().isLRUHeap()) {
+    } else if (getEvictionController().getEvictionAlgorithm().isLRUHeap()) {
-        while (bytesToEvict > 0 && _getCCHelper().mustEvict(stats, _getOwner(), bytesToEvict)) {
+        while (bytesToEvict > 0
+            && getEvictionController().mustEvict(stats, _getOwner(), bytesToEvict)) {
-            LRUEntry removalEntry = (LRUEntry) _getLruList().getLRUEntry();
+            EvictableEntry removalEntry = getEvictionList().getEvictableEntry();
-                _getCCHelper().afterEviction();
-        // TODO Auto-generated catch block
-          logger.trace(LogMarker.LRU, "exception ={}", e.getCause());
+          logger.trace(LogMarker.LRU, "exception ={}", e.getCause().getMessage(), e.getCause());
-        while (bytesToEvict > 0 && _getCCHelper().mustEvict(stats, _getOwner(), bytesToEvict)) {
-          LRUEntry removalEntry = (LRUEntry) _getLruList().getLRUEntry();
+        while (bytesToEvict > 0
+            && getEvictionController().mustEvict(stats, _getOwner(), bytesToEvict)) {
+          EvictableEntry removalEntry = (EvictableEntry) getEvictionList().getEvictableEntry();
-                    "evicted entry key(2)={} total entry size is now: {} bytesToEvict :",
+                    "evicted entry key(2)={} total entry size is now: {} bytesToEvict: {}",
-              _getCCHelper().afterEviction();
-        // TODO Auto-generated catch block
-          logger.debug("exception ={}", e.getCause());
+          logger.debug("exception ={}", e.getCause().getMessage(), e.getCause());
-          _getLruList().stats().getCounter());
+          getEvictionController().getStatistics().getCounter());
-    LRUStatistics stats = _getLruList().stats();
+    EvictionStatistics stats = getEvictionList().getStatistics();
-        LRUEntry removalEntry = (LRUEntry) _getLruList().getLRUEntry();
+        EvictableEntry removalEntry = getEvictionList().getEvictableEntry();
-            _getCCHelper().afterEviction();
-    } catch (RegionClearedException rce) {
+    } catch (RegionClearedException e) {
-        logger.trace(LogMarker.LRU, "exception ={}", rce.getCause());
+        logger.trace(LogMarker.LRU, "exception ={}", e.getCause().getMessage(), e.getCause());
-  // TODO this method acts as LRUupdateCallbacks
-  // do we need to put it here are insert one level up
-  // TODO rebalancing these methods are new on the
-  // rebalancing branch but never used???
-  public void disableLruUpdateCallbackForInline() {
-    setCallbackDisabled(true);
-  }
-
-  public void enableLruUpdateCallbackForInline() {
-    setCallbackDisabled(false);
-  }
-
-    _getLruList().clear(rvv);
+    getEvictionList().clear(rvv);
-    LRUEntry e = (LRUEntry) re;
+    EvictableEntry e = (EvictableEntry) re;
-          re.getKey(), getTotalEntrySize(), this._getLruList().getExpensiveListCount(), size(),
-          e.getEntrySize(), !e.testEvicted());
+          re.getKey(), getTotalEntrySize(), this.getEvictionList().size(), size(), e.getEntrySize(),
+          !e.isEvicted());
-    NewLRUClockHand lruList = _getLruList();
+    EvictionList lruList = getEvictionList();
-    final LRUEntry e = (LRUEntry) re;
-    setDelta(e.updateEntrySize(_getCCHelper()));
+    final EvictableEntry e = (EvictableEntry) re;
+    setDelta(e.updateEntrySize(getEvictionController()));
-    NewLRUClockHand lruList = _getLruList();
+    EvictionList lruList = getEvictionList();
-          if (!e.testEvicted()) {
+          if (!e.isEvicted()) {
-      if (!e.testEvicted()) {
+      if (!e.isEvicted()) {
-    final LRUEntry e = (LRUEntry) re;
+    final EvictableEntry e = (EvictableEntry) re;
-          re.getKey(), getTotalEntrySize(), this._getLruList().getExpensiveListCount(), size(),
-          e.getEntrySize(), !e.testEvicted());
+          re.getKey(), getTotalEntrySize(), this.getEvictionList().size(), size(), e.getEntrySize(),
+          !e.isEvicted());
-    /* boolean removed = */_getLruList().unlinkEntry(e);
+    /* boolean removed = */
+    getEvictionList().destroyEntry(e);
-    if (vTok == Token.DESTROYED || vTok == Token.TOMBSTONE) { // OFFHEAP noop TODO: use
-                                                              // re.isDestroyedOrTombstone
+    if (vTok == Token.DESTROYED || vTok == Token.TOMBSTONE) {
+      // OFFHEAP noop TODO: use re.isDestroyedOrTombstone
-      e.updateEntrySize(_getCCHelper());
+      e.updateEntrySize(getEvictionController());
-  public void lruEntryFaultIn(LRUEntry e) {
+  public void lruEntryFaultIn(EvictableEntry e) {
-    NewLRUClockHand lruList = _getLruList();
+    EvictionList lruList = getEvictionList();
-    ((LRUEntry) re).decRefCount(_getLruList(), lr);
+    re.decRefCount(getEvictionList(), lr);
-  public boolean lruLimitExceeded(DiskRegionView drv) {
-    return _getCCHelper().lruLimitExceeded(_getLruList().stats(), drv);
+  public boolean lruLimitExceeded(DiskRegionView diskRegionView) {
+    return getEvictionController().lruLimitExceeded(getEvictionController().getStatistics(),
+        diskRegionView);
-    _getLruList().closeStats();
+    getEvictionList().closeStats();
-    LRUEntry lruRe = (LRUEntry) re;
+    EvictableEntry lruRe = (EvictableEntry) re;
+
+  @Override
+  public long getEvictions() {
+    return this.getEvictionController().getStatistics().getEvictions();
+  }
+
+  @Override
+  public void incRecentlyUsed() {
+    getEvictionList().incrementRecentlyUsed();
+  }

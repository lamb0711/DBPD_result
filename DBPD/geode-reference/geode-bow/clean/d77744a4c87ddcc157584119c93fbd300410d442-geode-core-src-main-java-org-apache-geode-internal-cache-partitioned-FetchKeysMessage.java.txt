GEODE-5186: set operation in a client transaction could cause the transaction to hang (#1967)

GEODE-5186: Do not retry set operation on partitioned region if in a transaction.
FetchKeyMessage will be sent to peer members as non transactional if it is sent from the transaction host member.

+import org.apache.geode.internal.cache.TXManagerImpl;
+import org.apache.geode.internal.cache.TXStateProxy;
-  /** the interest policy to use in processing the keys */
+  /**
+   * the interest policy to use in processing the keys
+   */
-  /** the argument for the interest type (regex string, className, list of keys) */
+  /**
+   * the argument for the interest type (regex string, className, list of keys)
+   */
-    FetchKeysMessage tmp = new FetchKeysMessage();
-    FetchKeysResponse p =
-        (FetchKeysResponse) tmp.createReplyProcessor(r, Collections.singleton(recipient));
-    FetchKeysMessage m = new FetchKeysMessage(recipient, r.getPRId(), p, bucketId,
-        InterestType.REGULAR_EXPRESSION, ".*", allowTombstones);
-    m.setTransactionDistributed(r.getCache().getTxManager().isDistributed());
-
-    Set failures = r.getDistributionManager().putOutgoing(m);
-    if (failures != null && failures.size() > 0) {
-      throw new ForceReattemptException(
-          LocalizedStrings.FetchKeysMessage_FAILED_SENDING_0.toLocalizedString(m));
+    TXManagerImpl txManager = r.getCache().getTxManager();
+    boolean resetTxState = isTransactionInternalSuspendNeeded(txManager);
+    TXStateProxy txStateProxy = null;
+    if (resetTxState) {
+      txStateProxy = txManager.pauseTransaction();
-    return p;
+    try {
+      FetchKeysMessage tmp = new FetchKeysMessage();
+
+      FetchKeysResponse p =
+          (FetchKeysResponse) tmp.createReplyProcessor(r, Collections.singleton(recipient));
+      FetchKeysMessage m = new FetchKeysMessage(recipient, r.getPRId(), p, bucketId,
+          InterestType.REGULAR_EXPRESSION, ".*", allowTombstones);
+      m.setTransactionDistributed(txManager.isDistributed());
+
+      Set failures = r.getDistributionManager().putOutgoing(m);
+      if (failures != null && failures.size() > 0) {
+        throw new ForceReattemptException(
+            LocalizedStrings.FetchKeysMessage_FAILED_SENDING_0.toLocalizedString(m));
+      }
+      return p;
+    } finally {
+      if (resetTxState) {
+        txManager.unpauseTransaction(txStateProxy);
+      }
+    }
+  }
+
+  private static boolean isTransactionInternalSuspendNeeded(TXManagerImpl txManager) {
+    TXStateProxy txState = txManager.getTXState();
+    // handle distributed transaction when needed.
+    return txState != null && txState.isRealDealLocal() && !txState.isDistTx();
-   *
-    /** The number of the series */
+    /**
+     * The number of the series
+     */
-    /** The message number in the series */
+    /**
+     * The message number in the series
+     */
-    /** The total number of series */
+    /**
+     * The total number of series
+     */
-    /** Whether this is the last of a series */
+    /**
+     * Whether this is the last of a series
+     */
-    /** the stream holding the chunk to send */
+    /**
+     * the stream holding the chunk to send
+     */
-    /** the array holding data received */
+    /**
+     * the array holding data received
+     */
+
-    /** lock used to synchronize chunk processing */
+    /**
+     * lock used to synchronize chunk processing
+     */
-    /** number of chunks processed */
+    /**
+     * number of chunks processed
+     */
-    /** chunks expected (set when last chunk has been processed */
+    /**
+     * chunks expected (set when last chunk has been processed
+     */
-    /** whether the last chunk has been processed */
+    /**
+     * whether the last chunk has been processed
+     */

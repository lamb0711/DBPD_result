Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class keeps track of how many InitialImageMessages are in flight between the
- * initial image provider and the image target.
+ * This class keeps track of how many InitialImageMessages are in flight between the initial image
+ * provider and the image target.
- * The provider is responsible for calling acquirePermit before sending an initial image
- * chunk. The acquire will block if two many messages are in flight.
+ * The provider is responsible for calling acquirePermit before sending an initial image chunk. The
+ * acquire will block if two many messages are in flight.
- * The initial image target sends FlowControlPermitMessage to the image provider after
- * each processed chunk. Upon receiving the FlowControlPermit message, the provider
- * will increase the number of permits available.
+ * The initial image target sends FlowControlPermitMessage to the image provider after each
+ * processed chunk. Upon receiving the FlowControlPermit message, the provider will increase the
+ * number of permits available.
-  
+
-  
+
-    InitialImageFlowControl control =new InitialImageFlowControl(dm, target);
+    InitialImageFlowControl control = new InitialImageFlowControl(dm, target);
-    
+
-    if(!availableIds.contains(target)) {
+    if (!availableIds.contains(target)) {
-  
+
-  
+
-  
-  
+
+
-      }
-      catch (InterruptedException e) {
+      } catch (InterruptedException e) {
-      }
-      finally {
+      } finally {
-    if(!aborted.get()) {
+    if (!aborted.get()) {
-  
+
-    if (!aborted.get() && !permits.tryAcquire(timeout-timeSoFar-1, TimeUnit.MILLISECONDS)) {
+    if (!aborted.get() && !permits.tryAcquire(timeout - timeSoFar - 1, TimeUnit.MILLISECONDS)) {
-      final Object[] msgArgs = new Object[] {getAckWaitThreshold(), this, dm.getId(), activeMembers};
-      final StringId msg = LocalizedStrings.ReplyProcessor21_0_SEC_HAVE_ELAPSED_WHILE_WAITING_FOR_REPLIES_1_ON_2_WHOSE_CURRENT_MEMBERSHIP_LIST_IS_3;
+      final Object[] msgArgs =
+          new Object[] {getAckWaitThreshold(), this, dm.getId(), activeMembers};
+      final StringId msg =
+          LocalizedStrings.ReplyProcessor21_0_SEC_HAVE_ELAPSED_WHILE_WAITING_FOR_REPLIES_1_ON_2_WHOSE_CURRENT_MEMBERSHIP_LIST_IS_3;
-      
+
-      logger.info(LocalizedMessage.create(LocalizedStrings.ReplyProcessor21_WAIT_FOR_REPLIES_COMPLETED_1, "InitialImageFlowControl"));
+      logger.info(
+          LocalizedMessage.create(LocalizedStrings.ReplyProcessor21_WAIT_FOR_REPLIES_COMPLETED_1,
+              "InitialImageFlowControl"));
-      
+
-   * Return the time in sec to wait before sending an alert while
-   * waiting for ack replies.  Note that the ack wait threshold may
-   * change at runtime, so we have to consult the system every time.
+   * Return the time in sec to wait before sending an alert while waiting for ack replies. Note that
+   * the ack wait threshold may change at runtime, so we have to consult the system every time.
-  } 
+  }
-  
+
-  
+
-    if(id.equals(target)) {
+    if (id.equals(target)) {
-    
+
-    if(!aborted.getAndSet(true)) {
-      incMessagesInFlight(- (maxPermits - permits.availablePermits()));
+    if (!aborted.getAndSet(true)) {
+      incMessagesInFlight(-(maxPermits - permits.availablePermits()));
-    //Do nothing
+    // Do nothing
-  public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
-  }
+  public void quorumLost(Set<InternalDistributedMember> failures,
+      List<InternalDistributedMember> remaining) {}
-  public void memberSuspect(InternalDistributedMember id,
-      InternalDistributedMember whoSuspected, String reason) {
-    //Do nothing
+  public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected,
+      String reason) {
+    // Do nothing
-    return "<InitialImageFlowControl for GII to " + target + " with " + permits.availablePermits() + " available permits>";
+    return "<InitialImageFlowControl for GII to " + target + " with " + permits.availablePermits()
+        + " available permits>";
-  public static class FlowControlPermitMessage extends DistributionMessage implements DataSerializableFixedID {
+  public static class FlowControlPermitMessage extends DistributionMessage
+      implements DataSerializableFixedID {
-    
+
-    public FlowControlPermitMessage() {
-    }
+    public FlowControlPermitMessage() {}
-    
+
-      if(control != null) {
+      if (control != null) {
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    
-    
-    
+
+
+

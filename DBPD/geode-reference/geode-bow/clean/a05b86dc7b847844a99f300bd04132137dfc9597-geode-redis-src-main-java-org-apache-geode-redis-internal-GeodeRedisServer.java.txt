GEODE-8175: remove unsupported redis commands (#5146)

Removed list and zset commands.
Removed redis HyperLog commands.
Removed redis transaction commands.
-import java.util.Collection;
-import java.util.Map.Entry;
-import org.apache.geode.cache.EntryEvent;
-import org.apache.geode.cache.RegionDestroyedException;
-import org.apache.geode.cache.util.CacheListenerAdapter;
-import org.apache.geode.internal.hll.HyperLogLogPlus;
-  private final MetaCacheListener metaListener;
-
-   * The field that defines the name of the {@link Region} which holds all of the HyperLogLogs. The
-   * current value of this field is {@code HLL_REGION}.
-   */
-  public static final String HLL_REGION = "ReDiS_HlL";
-
-  /**
-    metaListener = new MetaCacheListener();
-  /**
-   * Initializes the {@link Cache}, and creates Redis necessities Region and protects declares that
-   * {@link Region} to be protected. Also, every {@code GeodeRedisServer} will check for entries
-   * already in the meta data Region.
-   */
-      Region<ByteArrayWrapper, HyperLogLogPlus> hLLRegion;
-      if ((hLLRegion = cache.getRegion(HLL_REGION)) == null) {
-        RegionFactory<ByteArrayWrapper, HyperLogLogPlus> regionFactory =
-            gemFireCache.createRegionFactory(DEFAULT_REGION_TYPE);
-        hLLRegion = regionFactory.create(HLL_REGION);
-      }
-        redisMetaDataFactory.addCacheListener(metaListener);
-      regionProvider = new RegionProvider(stringsRegion, hLLRegion, keyRegistrar,
-          expirationFutures, expirationExecutor, DEFAULT_REGION_TYPE, redisData);
-      keyRegistrar.register(Coder.stringToByteArrayWrapper(REDIS_DATA_REGION),
-          RedisDataType.REDIS_PROTECTED);
-      keyRegistrar.register(Coder.stringToByteArrayWrapper(HLL_REGION),
-          RedisDataType.REDIS_PROTECTED);
-      keyRegistrar.register(Coder.stringToByteArrayWrapper(STRING_REGION),
-          RedisDataType.REDIS_PROTECTED);
+      regionProvider = new RegionProvider(stringsRegion, keyRegistrar,
+          expirationFutures, expirationExecutor, redisData);
-    checkForRegions();
-  public static final int PROTECTED_KEY_COUNT = 3;
-
-  private void checkForRegions() {
-    Collection<Entry<ByteArrayWrapper, RedisData>> entrySet = keyRegistrar.keyInfos();
-    for (Entry<ByteArrayWrapper, RedisData> entry : entrySet) {
-      ByteArrayWrapper key = entry.getKey();
-      RedisDataType type = entry.getValue().getType();
-      if (!regionProvider.typeUsesDynamicRegions(type)) {
-        continue;
-      }
-      if (cache.getRegion(key.toString()) != null) {
-        // TODO: this seems to be correct (i.e. no need to call createRemoteRegionReferenceLocally
-        // if region already exists).
-        // HOWEVER: createRemoteRegionReferenceLocally ends up doing nothing if the region does not
-        // exist. So this caller of createRemoteRegionReferenceLocally basically does nothing.
-        // createRemoteRegionReferenceLocally might be needed even if the region exists because
-        // local state needs to be initialized (like indexes and queries).
-        continue;
-      }
-      try {
-        regionProvider.createRemoteRegionReferenceLocally(key, type);
-      } catch (Exception e) {
-        // TODO: this eats the exception so if something really is wrong we don't fail but just log.
-        if (logger.errorEnabled()) {
-          logger.error(e);
-        }
-      }
-    }
-  }
-
-   * Takes an entry event and processes it. If the entry denotes that a {@link
-   * RedisDataType#REDIS_LIST} or {@link RedisDataType#REDIS_SORTEDSET} was created then this
-   * function will call the necessary calls to create the parameterized queries for those keys.
-   *
-   * @param event EntryEvent from meta data region
-   */
-  private void afterKeyCreate(EntryEvent<ByteArrayWrapper, RedisData> event) {
-    if (event.isOriginRemote()) {
-      final ByteArrayWrapper key = event.getKey();
-      final RedisData value = event.getNewValue();
-      try {
-        regionProvider.createRemoteRegionReferenceLocally(key, value.getType());
-      } catch (RegionDestroyedException ignore) { // Region already destroyed, ignore
-      }
-    }
-  }
-
-  /**
-   * When a key is removed then this function will make sure the associated queries with the key are
-   * also removed from each vm to avoid unnecessary data retention
-   */
-  private void afterKeyDestroy(EntryEvent<ByteArrayWrapper, RedisData> event) {
-    if (event.isOriginRemote()) {
-      final ByteArrayWrapper key = event.getKey();
-      final RedisData value = event.getOldValue();
-      regionProvider.removeRegionReferenceLocally(key, value.getType());
-    }
-  }
-
-  private class MetaCacheListener extends CacheListenerAdapter<ByteArrayWrapper, RedisData> {
-    @Override
-    public void afterCreate(EntryEvent<ByteArrayWrapper, RedisData> event) {
-      afterKeyCreate(event);
-    }
-
-    @Override
-    public void afterDestroy(EntryEvent<ByteArrayWrapper, RedisData> event) {
-      afterKeyDestroy(event);
-    }
-  }
-
-  /**

GEODE-2261: do not use remote function calls to update the shared configuration

-import org.apache.geode.internal.cache.xmlcache.CacheXml;
-import java.io.FileInputStream;
-import java.util.stream.Collector;
-import java.util.stream.Stream;
-import javax.xml.xpath.XPathExpressionException;
+    Properties properties = cache.getDistributedSystem().getProperties();
-    String clusterConfigRootDir =
-        cache.getDistributedSystem().getProperties().getProperty(CLUSTER_CONFIGURATION_DIR);
+    String clusterConfigRootDir = properties.getProperty(CLUSTER_CONFIGURATION_DIR);
+
-  public void addXmlEntity(XmlEntity xmlEntity, String[] groups) throws Exception {
+  public void addXmlEntity(XmlEntity xmlEntity, String[] groups) {
-      final Document doc = createAndUpgradeDocumentFromXml(xmlContent);
-      XmlUtils.addNewNode(doc, xmlEntity);
-      configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
-      configRegion.put(group, configuration);
+      try {
+        final Document doc = XmlUtils.createAndUpgradeDocumentFromXml(xmlContent);
+        XmlUtils.addNewNode(doc, xmlEntity);
+        configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
+        configRegion.put(group, configuration);
+      } catch (Exception e) {
+        logger.error("error updating cluster configuration for group " + group, e);
+      }
-  public void deleteXmlEntity(final XmlEntity xmlEntity, String[] groups) throws Exception {
+  public void deleteXmlEntity(final XmlEntity xmlEntity, String[] groups) {
-        if (xmlContent != null && !xmlContent.isEmpty()) {
-          Document doc = createAndUpgradeDocumentFromXml(xmlContent);
-          XmlUtils.deleteNode(doc, xmlEntity);
-          configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
-          configRegion.put(group, configuration);
+        try {
+          if (xmlContent != null && !xmlContent.isEmpty()) {
+            Document doc = XmlUtils.createAndUpgradeDocumentFromXml(xmlContent);
+            XmlUtils.deleteNode(doc, xmlEntity);
+            configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
+            configRegion.put(group, configuration);
+          }
+        } catch (Exception e) {
+          logger.error("error updating cluster configuration for group " + group, e);
-  public void modifyXmlAndProperties(Properties properties, XmlEntity xmlEntity, String[] groups)
-      throws Exception {
+  public void modifyXmlAndProperties(Properties properties, XmlEntity xmlEntity, String[] groups) {
-
-        Document doc = createAndUpgradeDocumentFromXml(xmlContent);
-
-        // Modify the cache attributes
-        XmlUtils.modifyRootAttributes(doc, xmlEntity);
-
-        // Change the xml content of the configuration and put it the config region
-        configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
+        try {
+          Document doc = XmlUtils.createAndUpgradeDocumentFromXml(xmlContent);
+          // Modify the cache attributes
+          XmlUtils.modifyRootAttributes(doc, xmlEntity);
+          // Change the xml content of the configuration and put it the config region
+          configuration.setCacheXmlContent(XmlUtils.prettyXml(doc));
+        } catch (Exception e) {
+          logger.error("error updating cluster configuration for group " + group, e);
+        }
-        // will need the jars on file to upload to other locators.
+        // will need the jars on file to upload to other locators. Need to update the jars
+        // using a new copy of the Configuration so that the change listener will pick up the jar
+        // name changes.
-    // TODO: Should we check like this, or just check jar.exists below()?
-    if (configuration == null || !configuration.getJarNames().contains(jarName)) {
+    File jar = getPathToJarOnThisLocator(group, jarName).toFile();
+
+    if (configuration == null || !configuration.getJarNames().contains(jarName) || !jar.exists()) {
-    File jar = getPathToJarOnThisLocator(group, jarName).toFile();
-
-  /**
-   * Create a {@link Document} using {@link XmlUtils#createDocumentFromXml(String)} and if the
-   * version attribute is not equal to the current version then update the XML to the current schema
-   * and return the document.
-   * 
-   * @param xmlContent XML content to load and upgrade.
-   * @return {@link Document} from xmlContent.
-   * @since GemFire 8.1
-   */
-  static Document createAndUpgradeDocumentFromXml(final String xmlContent)
-      throws SAXException, ParserConfigurationException, IOException, XPathExpressionException {
-    Document doc = XmlUtils.createDocumentFromXml(xmlContent);
-    if (!CacheXml.VERSION_LATEST.equals(XmlUtils.getAttribute(doc.getDocumentElement(),
-        CacheXml.VERSION, CacheXml.GEODE_NAMESPACE))) {
-      doc = XmlUtils.upgradeSchema(doc, CacheXml.GEODE_NAMESPACE, CacheXml.LATEST_SCHEMA_LOCATION,
-          CacheXml.VERSION_LATEST);
-    }
-    return doc;
-  }

Merge branch 'develop' into feature/GEODE-9

-public final class TXCommitMessage extends PooledDistributionMessage implements MembershipListener, MessageWithReply
+public class TXCommitMessage extends PooledDistributionMessage implements MembershipListener, MessageWithReply
-
+  
-  private transient ArrayList farSideEntryOps;
+  protected transient ArrayList farSideEntryOps;
-  private void processCacheRuntimeException(CacheRuntimeException problem) {
+  protected void processCacheRuntimeException(CacheRuntimeException problem) {
+
+    /**
+     * Apply a single tx entry op on the far side
+     */
+    @SuppressWarnings("synthetic-access")
+    protected void txApplyEntryOpAdjunctOnly(FarSideEntryOp entryOp)
+    {
+      if (this.r == null) {
+        return;
+      }
+      EventID eventID = getEventId(entryOp);
+      boolean isDuplicate = this.r.hasSeenEvent(eventID);
+      boolean callbacksOnly = (this.r.getDataPolicy() == DataPolicy.PARTITION)
+          || isDuplicate;
+      if (this.r instanceof PartitionedRegion) {
+        
+        PartitionedRegion pr = (PartitionedRegion)r;
+        BucketRegion br = pr.getBucketRegion(entryOp.key);
+        Set bucketOwners = br.getBucketOwners();
+        InternalDistributedMember thisMember = GemFireCacheImpl.getExisting().getDistributionManager().getId();
+        if (bucketOwners.contains(thisMember)) {
+          return;
+        }
+        
+        /*
+         * This happens when we don't have the bucket and are getting adjunct notification
+         */
+        EntryEventImpl eei = AbstractRegionMap.createCBEvent(this.r, entryOp.op, entryOp.key, entryOp.value, this.msg.txIdent, txEvent, getEventId(entryOp), entryOp.callbackArg,entryOp.filterRoutingInfo,this.msg.bridgeContext, null, entryOp.versionTag, entryOp.tailKey);
+        try {
+        if(entryOp.filterRoutingInfo!=null) {
+          eei.setLocalFilterInfo(entryOp.filterRoutingInfo.getFilterInfo(this.r.getCache().getMyId()));
+        }
+        if (isDuplicate) {
+          eei.setPossibleDuplicate(true);
+        }
+        if (logger.isDebugEnabled()) {
+          logger.debug("invoking transactional callbacks for {} key={} needsUnlock={} event={}", entryOp.op, entryOp.key, this.needsUnlock, eei);
+        }
+        // we reach this spot because the event is either delivered to this member
+        // as an "adjunct" message or because the bucket was being created when
+        // the message was sent and already reflects the change caused by this event.
+        // In the latter case we need to invoke listeners
+        final boolean skipListeners = !isDuplicate;
+        eei.invokeCallbacks(this.r, skipListeners, true);
+        } finally {
+          eei.release();
+        }
+        return;
+      }
+    }
+
+    
+      public void processAdjunctOnly() {
+        txApplyEntryOpAdjunctOnly(this);
+      }
+      

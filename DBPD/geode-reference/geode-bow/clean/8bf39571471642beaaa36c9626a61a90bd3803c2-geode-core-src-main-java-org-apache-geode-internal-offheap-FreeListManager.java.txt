Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  /** The MemoryChunks that this allocator is managing by allocating smaller chunks of them.
-   * The contents of this array never change.
+  /**
+   * The MemoryChunks that this allocator is managing by allocating smaller chunks of them. The
+   * contents of this array never change.
-  
-  final private AtomicReferenceArray<OffHeapStoredObjectAddressStack> tinyFreeLists = new AtomicReferenceArray<OffHeapStoredObjectAddressStack>(TINY_FREE_LIST_COUNT);
-  // hugeChunkSet is sorted by chunk size in ascending order. It will only contain chunks larger than MAX_TINY.
-  private final ConcurrentSkipListSet<OffHeapStoredObject> hugeChunkSet = new ConcurrentSkipListSet<OffHeapStoredObject>();
+
+  final private AtomicReferenceArray<OffHeapStoredObjectAddressStack> tinyFreeLists =
+      new AtomicReferenceArray<OffHeapStoredObjectAddressStack>(TINY_FREE_LIST_COUNT);
+  // hugeChunkSet is sorted by chunk size in ascending order. It will only contain chunks larger
+  // than MAX_TINY.
+  private final ConcurrentSkipListSet<OffHeapStoredObject> hugeChunkSet =
+      new ConcurrentSkipListSet<OffHeapStoredObject>();
-    return (size-1)/TINY_MULTIPLE;
+    return (size - 1) / TINY_MULTIPLE;
+
-    for (int i=0; i < slabs.length; i++) {
+    for (int i = 0; i < slabs.length; i++) {
+
-    while (addr <= (slab.getMemoryAddress() + slab.getSize() - OffHeapStoredObject.MIN_CHUNK_SIZE)) {
+    while (addr <= (slab.getMemoryAddress() + slab.getSize()
+        - OffHeapStoredObject.MIN_CHUNK_SIZE)) {
+
-    for (Fragment f: this.fragmentList) {
+    for (Fragment f : this.fragmentList) {
+
+
+
-    for (Fragment f: this.fragmentList) {
+    for (Fragment f : this.fragmentList) {
+
-    for (int i=0; i < this.tinyFreeLists.length(); i++) {
+    for (int i = 0; i < this.tinyFreeLists.length(); i++) {
+
-    for (OffHeapStoredObject c: this.hugeChunkSet) {
+    for (OffHeapStoredObject c : this.hugeChunkSet) {
-    for (int i=0; i < slabs.length; i++) {
+    for (int i = 0; i < slabs.length; i++) {
-   * Create and return a Fragment.
-   * This method exists so that tests can override it.
+   * Create and return a Fragment. This method exists so that tests can override it.
-  
+
-   * Fills all fragments with a fill used for data integrity validation 
-   * if fill validation is enabled.
+   * Fills all fragments with a fill used for data integrity validation if fill validation is
+   * enabled.
-    for(Fragment fragment : this.fragmentList) {
+    for (Fragment fragment : this.fragmentList) {
-   * Allocate a chunk of memory of at least the given size.
-   * The basic algorithm is:
-   * 1. Look for a previously allocated and freed chunk close to the size requested.
-   * 2. See if the original chunk is big enough to split. If so do so.
-   * 3. Look for a previously allocated and freed chunk of any size larger than the one requested.
-   *    If we find one split it.
+   * Allocate a chunk of memory of at least the given size. The basic algorithm is: 1. Look for a
+   * previously allocated and freed chunk close to the size requested. 2. See if the original chunk
+   * is big enough to split. If so do so. 3. Look for a previously allocated and freed chunk of any
+   * size larger than the one requested. If we find one split it.
-   * It might be better not to include step 3 since we expect and freed chunk to be reallocated in the future.
-   * Maybe it would be better for 3 to look for adjacent free blocks that can be merged together.
-   * For now we will just try 1 and 2 and then report out of mem.
+   * It might be better not to include step 3 since we expect and freed chunk to be reallocated in
+   * the future. Maybe it would be better for 3 to look for adjacent free blocks that can be merged
+   * together. For now we will just try 1 and 2 and then report out of mem.
+   * 
-    
+
-      for (int i=lastAllocationId; i < this.fragmentList.size(); i++) {
+      for (int i = lastAllocationId; i < this.fragmentList.size(); i++) {
-      for (int i=0; i < lastAllocationId; i++) {
+      for (int i = 0; i < lastAllocationId; i++) {
-    final OutOfOffHeapMemoryException failure = new OutOfOffHeapMemoryException("Out of off-heap memory. Could not allocate size of " + chunkSize);
+    final OutOfOffHeapMemoryException failure = new OutOfOffHeapMemoryException(
+        "Out of off-heap memory. Could not allocate size of " + chunkSize);
-    lw.info("OutOfOffHeapMemory allocating size of " + chunkSize + ". allocated=" + this.allocatedSize.get() + " defragmentations=" + this.defragmentationCount.get() + " objects=" + stats.getObjects() + " free=" + stats.getFreeMemory() + " fragments=" + stats.getFragments() + " largestFragment=" + stats.getLargestFragment() + " fragmentation=" + stats.getFragmentation());
+    lw.info("OutOfOffHeapMemory allocating size of " + chunkSize + ". allocated="
+        + this.allocatedSize.get() + " defragmentations=" + this.defragmentationCount.get()
+        + " objects=" + stats.getObjects() + " free=" + stats.getFreeMemory() + " fragments="
+        + stats.getFragments() + " largestFragment=" + stats.getLargestFragment()
+        + " fragmentation=" + stats.getFragmentation());
-    for (OffHeapStoredObject c: this.hugeChunkSet) {
+    for (OffHeapStoredObject c : this.hugeChunkSet) {
+
-    for (int i=0; i < this.tinyFreeLists.length(); i++) {
+    for (int i = 0; i < this.tinyFreeLists.length(); i++) {
+
-    for (Fragment f: this.fragmentList) {
+    for (Fragment f : this.fragmentList) {
-        lw.info("Fragment at " + f.getAddress() + " of size " + f.getSize() + " has " + freeSpace + " bytes free.");
+        lw.info("Fragment at " + f.getAddress() + " of size " + f.getSize() + " has " + freeSpace
+            + " bytes free.");
-   * Set this to "true" to perform data integrity checks on allocated and reused Chunks.  This may clobber 
-   * performance so turn on only when necessary.
+   * Set this to "true" to perform data integrity checks on allocated and reused Chunks. This may
+   * clobber performance so turn on only when necessary.
-  final boolean validateMemoryWithFill = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "validateOffHeapWithFill");
+  final boolean validateMemoryWithFill =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "validateOffHeapWithFill");
-   * Every allocated chunk smaller than TINY_MULTIPLE*TINY_FREE_LIST_COUNT will allocate a chunk of memory that is a multiple of this value.
-   * Sizes are always rounded up to the next multiple of this constant
-   * so internal fragmentation will be limited to TINY_MULTIPLE-1 bytes per allocation
-   * and on average will be TINY_MULTIPLE/2 given a random distribution of size requests.
-   * This does not account for the additional internal fragmentation caused by the off-heap header
-   * which currently is always 8 bytes.
+   * Every allocated chunk smaller than TINY_MULTIPLE*TINY_FREE_LIST_COUNT will allocate a chunk of
+   * memory that is a multiple of this value. Sizes are always rounded up to the next multiple of
+   * this constant so internal fragmentation will be limited to TINY_MULTIPLE-1 bytes per allocation
+   * and on average will be TINY_MULTIPLE/2 given a random distribution of size requests. This does
+   * not account for the additional internal fragmentation caused by the off-heap header which
+   * currently is always 8 bytes.
-  public final static int TINY_MULTIPLE = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "OFF_HEAP_ALIGNMENT", 8);
+  public final static int TINY_MULTIPLE =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "OFF_HEAP_ALIGNMENT", 8);
-  public final static int TINY_FREE_LIST_COUNT = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "OFF_HEAP_FREE_LIST_COUNT", 65536);
+  public final static int TINY_FREE_LIST_COUNT =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "OFF_HEAP_FREE_LIST_COUNT", 65536);
-  public final static int MAX_TINY = TINY_MULTIPLE*TINY_FREE_LIST_COUNT;
-  
+  public final static int MAX_TINY = TINY_MULTIPLE * TINY_FREE_LIST_COUNT;
+
-   * Return true if the two chunks have been combined into one.
-   * If low and high are adjacent to each other
-   * and the combined size is small enough (see isSmallEnough)
-   * then low's size will be increased by the size of high
-   * and true will be returned.
+   * Return true if the two chunks have been combined into one. If low and high are adjacent to each
+   * other and the combined size is small enough (see isSmallEnough) then low's size will be
+   * increased by the size of high and true will be returned.
-        OffHeapStoredObject.setSize(lowAddr, (int)combinedSize);
+        OffHeapStoredObject.setSize(lowAddr, (int) combinedSize);
-   * Returns true if the area if memory (starting at lowAddr and extending to
-   * lowAddr+lowSize) is right before (i.e. adjacent) to highAddr.
+   * Returns true if the area if memory (starting at lowAddr and extending to lowAddr+lowSize) is
+   * right before (i.e. adjacent) to highAddr.
+
-   * Return true if size is small enough to be set as the size
-   * of a OffHeapStoredObject.
+   * Return true if size is small enough to be set as the size of a OffHeapStoredObject.
-  
+
-   * Defragments memory and returns true if enough memory to allocate chunkSize
-   * is freed. Otherwise returns false;
+   * Defragments memory and returns true if enough memory to allocate chunkSize is freed. Otherwise
+   * returns false;
-  
+
-   * Simple interface the represents a "stack" of primitive longs.
-   * Currently this interface only allows supports poll but more
-   * could be added if needed in the future.
-   * This interface was introduced to aid unit testing.
-   * The only implementation of it is OffHeapStoredObjectAddressStack.
+   * Simple interface the represents a "stack" of primitive longs. Currently this interface only
+   * allows supports poll but more could be added if needed in the future. This interface was
+   * introduced to aid unit testing. The only implementation of it is
+   * OffHeapStoredObjectAddressStack.
-     * Retrieves and removes the top of this stack,
-     * or returns {@code 0L} if this stack is empty.
+     * Retrieves and removes the top of this stack, or returns {@code 0L} if this stack is empty.
-    
+
+
+
+
+
-        long[] newData = new long[data.length+SORT_ARRAY_BLOCK_SIZE];
+        long[] newData = new long[data.length + SORT_ARRAY_BLOCK_SIZE];
+
-        long[] newData = new long[data.length+SORT_ARRAY_BLOCK_SIZE];
+        long[] newData = new long[data.length + SORT_ARRAY_BLOCK_SIZE];
-        System.arraycopy(data, idx, newData, idx+1, size-idx);
+        System.arraycopy(data, idx, newData, idx + 1, size - idx);
-        System.arraycopy(data, idx, data, idx+1, size-idx);
+        System.arraycopy(data, idx, data, idx + 1, size - idx);
+
-   * Defragments memory and returns true if enough memory to allocate chunkSize
-   * is freed. Otherwise returns false;
-   * Unlike the defragment method this method is not thread safe and does not check
+   * Defragments memory and returns true if enough memory to allocate chunkSize is freed. Otherwise
+   * returns false; Unlike the defragment method this method is not thread safe and does not check
-    for (LongStack l: freeChunks) {
+    for (LongStack l : freeChunks) {
-            if (!combineIfAdjacentAndSmallEnough(sorted.get(idx-1), addr)) {
+            if (!combineIfAdjacentAndSmallEnough(sorted.get(idx - 1), addr)) {
-            if (idx == 0 || !combineIfAdjacentAndSmallEnough(sorted.get(idx-1), addr)) {
+            if (idx == 0 || !combineIfAdjacentAndSmallEnough(sorted.get(idx - 1), addr)) {
-    for (int i=sorted.size()-1; i > 0; i--) {
-      if (combineIfAdjacentAndSmallEnough(sorted.get(i-1), sorted.get(i))) {
+    for (int i = sorted.size() - 1; i > 0; i--) {
+      if (combineIfAdjacentAndSmallEnough(sorted.get(i - 1), sorted.get(i))) {
-    
+
-    for (int i=sorted.size()-1; i >= 0; i--) {
+    for (int i = sorted.size() - 1; i >= 0; i--) {
-      if (addr == 0L) continue;
+      if (addr == 0L)
+        continue;
-    this.ma.getStats().setFragments(tmp.size());        
+    this.ma.getStats().setFragments(tmp.size());
-  protected void afterDefragmentationCountFetched() {
-  }
-  
+  protected void afterDefragmentationCountFetched() {}
+
-      throw new IllegalStateException(DistributionConfig.GEMFIRE_PREFIX + "OFF_HEAP_ALIGNMENT must be a multiple of 8.");
+      throw new IllegalStateException(
+          DistributionConfig.GEMFIRE_PREFIX + "OFF_HEAP_ALIGNMENT must be a multiple of 8.");
-      throw new IllegalStateException(DistributionConfig.GEMFIRE_PREFIX + "OFF_HEAP_ALIGNMENT must be <= 256 and a multiple of 8.");
+      throw new IllegalStateException(DistributionConfig.GEMFIRE_PREFIX
+          + "OFF_HEAP_ALIGNMENT must be <= 256 and a multiple of 8.");
+
-      throw new IllegalStateException(DistributionConfig.GEMFIRE_PREFIX + "OFF_HEAP_FREE_LIST_COUNT must be >= 1.");
+      throw new IllegalStateException(
+          DistributionConfig.GEMFIRE_PREFIX + "OFF_HEAP_FREE_LIST_COUNT must be >= 1.");
+
-      throw new IllegalStateException("HUGE_MULTIPLE must be >= 0 and <= 256 but it was " + hugeMultiple);
+      throw new IllegalStateException(
+          "HUGE_MULTIPLE must be >= 0 and <= 256 but it was " + hugeMultiple);
-  
+
-  
+
-    if(getUsedMemory() == 0) {
-      //when no memory is used then there is no fragmentation
+    if (getUsedMemory() == 0) {
+      // when no memory is used then there is no fragmentation
-        //zero fragments means no free memory then no fragmentation
+        // zero fragments means no free memory then no fragmentation
-        //free memory is available as one fragment, so no fragmentation
+        // free memory is available as one fragment, so no fragmentation
-        //more than 1 fragment is available so freeMemory is > ObjectChunk.MIN_CHUNK_SIZE
+        // more than 1 fragment is available so freeMemory is > ObjectChunk.MIN_CHUNK_SIZE
-        double fragmentation = ((double) availableFragments /(double) maxPossibleFragments) * 100d;
+        double fragmentation = ((double) availableFragments / (double) maxPossibleFragments) * 100d;
+
+
-    if (this.fragmentList.size() == 0) return;
+    if (this.fragmentList.size() == 0)
+      return;
-    for (Fragment f: this.fragmentList) {
+    for (Fragment f : this.fragmentList) {
-      } while (diff >= OffHeapStoredObject.MIN_CHUNK_SIZE && !f.allocate(offset, offset+diff));
+      } while (diff >= OffHeapStoredObject.MIN_CHUNK_SIZE && !f.allocate(offset, offset + diff));
-      long chunkAddr = f.getAddress()+offset;
+      long chunkAddr = f.getAddress() + offset;
+
-    for (int i=0; i < this.tinyFreeLists.length(); i++) {
+    for (int i = 0; i < this.tinyFreeLists.length(); i++) {
+
-    if (fragIdx >= this.fragmentList.size()) return null;
+    if (fragIdx >= this.fragmentList.size())
+      return null;
-          OffHeapStoredObject result = new OffHeapStoredObject(fragment.getAddress()+oldOffset, chunkSize+extraSize);
+          OffHeapStoredObject result =
+              new OffHeapStoredObject(fragment.getAddress() + oldOffset, chunkSize + extraSize);
-    return (int) ((((long)value + (multiple-1)) / multiple) * multiple);
+    return (int) ((((long) value + (multiple - 1)) / multiple) * multiple);
+
-    return basicAllocate(getNearestTinyMultiple(size), TINY_MULTIPLE, 0, this.tinyFreeLists, useFragments);
+    return basicAllocate(getNearestTinyMultiple(size), TINY_MULTIPLE, 0, this.tinyFreeLists,
+        useFragments);
-  private OffHeapStoredObject basicAllocate(int idx, int multiple, int offset, AtomicReferenceArray<OffHeapStoredObjectAddressStack> freeLists, boolean useFragments) {
+
+  private OffHeapStoredObject basicAllocate(int idx, int multiple, int offset,
+      AtomicReferenceArray<OffHeapStoredObjectAddressStack> freeLists, boolean useFragments) {
-      return allocateFromFragments(((idx+1)*multiple)+offset);
+      return allocateFromFragments(((idx + 1) * multiple) + offset);
+
-  
+
+
-   * Used by the FreeListManager to easily search its
-   * ConcurrentSkipListSet. This is not a real OffHeapStoredObject
-   * but only used for searching.
+   * Used by the FreeListManager to easily search its ConcurrentSkipListSet. This is not a real
+   * OffHeapStoredObject but only used for searching.
+
+
-    
+
+
-  private void basicFree(long addr, int idx, AtomicReferenceArray<OffHeapStoredObjectAddressStack> freeLists) {
+
+  private void basicFree(long addr, int idx,
+      AtomicReferenceArray<OffHeapStoredObjectAddressStack> freeLists) {
+
-  protected OffHeapStoredObjectAddressStack createFreeListForEmptySlot(AtomicReferenceArray<OffHeapStoredObjectAddressStack> freeLists, int idx) {
+  protected OffHeapStoredObjectAddressStack createFreeListForEmptySlot(
+      AtomicReferenceArray<OffHeapStoredObjectAddressStack> freeLists, int idx) {
-  
+
-    addBlocksFromChunks(this.hugeChunkSet, value);    // huge free chunks
-    addMemoryBlocks(getTinyFreeBlocks(), value);           // tiny free chunks
-    Collections.sort(value, 
-        new Comparator<MemoryBlock>() {
-          @Override
-          public int compare(MemoryBlock o1, MemoryBlock o2) {
-            return Long.valueOf(o1.getAddress()).compareTo(o2.getAddress());
-          }
+    addBlocksFromChunks(this.hugeChunkSet, value); // huge free chunks
+    addMemoryBlocks(getTinyFreeBlocks(), value); // tiny free chunks
+    Collections.sort(value, new Comparator<MemoryBlock>() {
+      @Override
+      public int compare(MemoryBlock o1, MemoryBlock o2) {
+        return Long.valueOf(o1.getAddress()).compareTo(o2.getAddress());
+      }
+
-  
+
-  
+
-  
+
-      if (this.tinyFreeLists.get(i) == null) continue;
+      if (this.tinyFreeLists.get(i) == null)
+        continue;
+
-    Collections.sort(value, 
-        new Comparator<MemoryBlock>() {
-          @Override
-          public int compare(MemoryBlock o1, MemoryBlock o2) {
-            return Long.valueOf(o1.getAddress()).compareTo(o2.getAddress());
-          }
+    Collections.sort(value, new Comparator<MemoryBlock>() {
+      @Override
+      public int compare(MemoryBlock o1, MemoryBlock o2) {
+        return Long.valueOf(o1.getAddress()).compareTo(o2.getAddress());
+      }
+
-    
+
-      return (int)(value ^ (value >>> 32));
+      return (int) (value ^ (value >>> 32));
-  
+
-    for (int i=0; i < slabs.length; i++) {
+    for (int i = 0; i < slabs.length; i++) {
+
-   * newSlabs will be non-null in unit tests.
-   * If the unit test gave us a different array
-   * of slabs then something is wrong because we
-   * are trying to reuse the old already allocated
-   * array which means that the new one will never
-   * be used. Note that this code does not bother
-   * comparing the contents of the arrays.
+   * newSlabs will be non-null in unit tests. If the unit test gave us a different array of slabs
+   * then something is wrong because we are trying to reuse the old already allocated array which
+   * means that the new one will never be used. Note that this code does not bother comparing the
+   * contents of the arrays.
-  
+
+
-    for (int i=0; i < this.slabs.length; i++) {
+    for (int i = 0; i < this.slabs.length; i++) {
+
-    for (int i=0; i < slabs.length; i++) {
+    for (int i = 0; i < slabs.length; i++) {
-      sb.append("[").append(Long.toString(startAddr, 16)).append("..").append(Long.toString(endAddr, 16)).append("] ");
+      sb.append("[").append(Long.toString(startAddr, 16)).append("..")
+          .append(Long.toString(endAddr, 16)).append("] ");
+
-    for (int i=0; i < slabs.length; i++) {
-      if (slabs[i].getMemoryAddress() <= addr && addr < (slabs[i].getMemoryAddress() + slabs[i].getSize())) {
+    for (int i = 0; i < slabs.length; i++) {
+      if (slabs[i].getMemoryAddress() <= addr
+          && addr < (slabs[i].getMemoryAddress() + slabs[i].getSize())) {
-          if (!(slabs[i].getMemoryAddress() <= (addr+size-1) && (addr+size-1) < (slabs[i].getMemoryAddress() + slabs[i].getSize()))) {
-            throw new IllegalStateException(" address 0x" + Long.toString(addr+size-1, 16) + " does not address the original slab memory");
+          if (!(slabs[i].getMemoryAddress() <= (addr + size - 1)
+              && (addr + size - 1) < (slabs[i].getMemoryAddress() + slabs[i].getSize()))) {
+            throw new IllegalStateException(" address 0x" + Long.toString(addr + size - 1, 16)
+                + " does not address the original slab memory");
-  
-}
+
+}

Merge branch 'release/1.8.0'

-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
-  private LockObject searchAndLock(Object keys[]) {
+  LockObject searchAndLock(Object keys[]) {
-  public void waitUntilLocked(Object keys[]) {
+  public boolean waitUntilLocked(Object keys[]) {
-              this.partitionedRegion.checkReadiness();
+              partitionedRegion.checkReadiness();
-        break;
+        return true;
-  // 2) distribute op to bucket secondaries and bridge servers with synchrony on local entry
+  // 2) distribute op to bucket secondaries and cache servers with synchrony on local entry
-    beginLocalWrite(event);
+    boolean locked = lockKeysAndPrimary(event);
-      endLocalWrite(event);
+      if (locked) {
+        releaseLockForKeysAndPrimary(event);
+      }
-      logger.error(LocalizedMessage.create(
-          LocalizedStrings.GatewaySender_SEQUENCENUMBER_GENERATED_FOR_EVENT_IS_INVALID,
-          new Object[] {key, getId()}));
+      logger.error("ERROR! The sequence number {} generated for the bucket {} is incorrect.",
+          new Object[] {key, getId()});
-          logger.error(LocalizedMessage.create(
-              LocalizedStrings.GatewaySender_SEQUENCENUMBER_GENERATED_FOR_EVENT_IS_INVALID,
-              new Object[] {key, getId()}));
+          logger.error("ERROR! The sequence number {} generated for the bucket {} is incorrect.",
+              new Object[] {key, getId()});
-   * stays the primary bucket while the write is in progress. Any call to this method must be
-   * followed with a call to endLocalWrite().
+   * stays the primary bucket while the write is in progress. This method must be followed with
+   * a call to releaseLockForKeysAndPrimary() if keys and primary are locked.
-  private boolean beginLocalWrite(EntryEventImpl event) {
+  boolean lockKeysAndPrimary(EntryEventImpl event) {
-    Object keys[] = new Object[1];
-    keys[0] = event.getKey();
+    Object[] keys = getKeysToBeLocked(event);
-      doLockForPrimary(false);
-      return lockedForPrimary = true;
+      lockedForPrimary = doLockForPrimary(false);
+      // tryLock is false means doLockForPrimary won't return false.
+      // either the method returns true or fails with an exception
+      assert lockedForPrimary : "expected doLockForPrimary returns true";
+      return lockedForPrimary;
+  Object[] getKeysToBeLocked(EntryEventImpl event) {
+    Object keys[] = new Object[1];
+    keys[0] = event.getKey();
+    return keys;
+  }
+
-    Lock activeWriteLock = this.getBucketAdvisor().getActiveWriteLock();
-    Lock parentLock = this.getBucketAdvisor().getParentActiveWriteLock();
+    Lock primaryMoveReadLock = getBucketAdvisor().getPrimaryMoveReadLock();
+    Lock parentLock = getBucketAdvisor().getParentPrimaryMoveReadLock();
-            boolean locked = activeWriteLock.tryLock();
+            boolean locked = primaryMoveReadLock.tryLock();
-            activeWriteLock.lockInterruptibly();
+            primaryMoveReadLock.lockInterruptibly();
-            boolean locked = activeWriteLock.tryLock();
+            boolean locked = primaryMoveReadLock.tryLock();
-            activeWriteLock.lockInterruptibly();
+            primaryMoveReadLock.lockInterruptibly();
-    Lock activeWriteLock = this.getBucketAdvisor().getActiveWriteLock();
-    activeWriteLock.unlock();
-    Lock parentLock = this.getBucketAdvisor().getParentActiveWriteLock();
+    Lock primaryMoveReadLock = getBucketAdvisor().getPrimaryMoveReadLock();
+    primaryMoveReadLock.unlock();
+    Lock parentLock = getBucketAdvisor().getParentPrimaryMoveReadLock();
+   * And release/remove the lockObject on the key(s)
-  private void endLocalWrite(EntryEventImpl event) {
-    if (!needWriteLock(event)) {
-      return;
-    }
-
-
+  void releaseLockForKeysAndPrimary(EntryEventImpl event) {
-    Object keys[] = new Object[1];
-    keys[0] = event.getKey();
+    Object[] keys = getKeysToBeLocked(event);
-  // 2) distribute op to bucket secondaries and bridge servers with synchrony on local entry
+  // 2) distribute op to bucket secondaries and cache servers with synchrony on local entry
-    beginLocalWrite(event);
+    boolean locked = lockKeysAndPrimary(event);
-      endLocalWrite(event);
+      if (locked) {
+        releaseLockForKeysAndPrimary(event);
+      }
-        logger.fatal(
-            LocalizedMessage.create(LocalizedStrings.LocalRegion_EXCEPTION_IN_EXPIRATION_TASK), ex);
+        logger.fatal("Exception in expiration task", ex);
-  // 2) distribute op to bucket secondaries and bridge servers with synchrony on local entry
+  // 2) distribute op to bucket secondaries and cache servers with synchrony on local entry
-    beginLocalWrite(event);
+    boolean locked = lockKeysAndPrimary(event);
-      endLocalWrite(event);
+      if (locked) {
+        releaseLockForKeysAndPrimary(event);
+      }
-    beginLocalWrite(event);
+    boolean locked = lockKeysAndPrimary(event);
-      endLocalWrite(event);
+      if (locked) {
+        releaseLockForKeysAndPrimary(event);
+      }
+
+    arm.lockForCacheModification(internalRegion, event);
+    final boolean locked = internalRegion.lockWhenRegionIsInitializing();
-      arm.lockForCacheModification(internalRegion, event);
-      beginLocalWrite(event);
+      boolean keysAndPrimaryLocked = lockKeysAndPrimary(event);
-        endLocalWrite(event);
+        if (keysAndPrimaryLocked) {
+          releaseLockForKeysAndPrimary(event);
+        }
+      if (locked) {
+        internalRegion.unlockWhenRegionIsInitializing();
+      }
-        LocalizedStrings.BucketRegion_THIS_SHOULD_NEVER_BE_CALLED_ON_0
-            .toLocalizedString(getClass()));
+        String.format("This should never be called on %s",
+            getClass()));
-              LocalizedStrings.DistributionManager_CAUGHT_EXCEPTION_WHILE_SENDING_DELTA
-                  .toLocalizedString(),
+              "Caught exception while sending delta. ",
-    if (cache.getLoggerI18n().fineEnabled())
-      cache.getLoggerI18n()
+    if (cache.getLogger().fineEnabled())
+      cache.getLogger()

GEODE-3096: pulling in refactoring work on HttpOperationInvoker

* Use HttpOperationInvoker to replace RestHttpOperationInvoker and SimpleHttpOperationInvoker
* Use one single ShellCommandController to replace all command controllers
* do not allow execution of commands that require client side file data gathering to be executed only on the locator/server
* deprecate CommandService and CommandStatement
* simplify CommandRequest, delete geode's ClientHttpRequest
* fix tests

+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
-import org.apache.geode.internal.util.IOUtils;
-import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.web.io.MultipartFileResourceAdapter;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
+import org.apache.geode.internal.util.IOUtils;
+import org.apache.geode.management.internal.cli.CliUtil;
+import org.apache.geode.management.internal.web.io.MultipartFileResourceAdapter;
-    if (fileData != null) {
-      final String[] fileNames = CliUtil.bytesToNames(fileData);
-      final byte[][] fileContent = CliUtil.bytesToData(fileData);
-
-      final List<Resource> resources = new ArrayList<Resource>(fileNames.length);
-
-      for (int index = 0; index < fileNames.length; index++) {
-        final String filename = fileNames[index];
-        resources.add(new ByteArrayResource(fileContent[index],
-            String.format("Contents of JAR file (%1$s).", filename)) {
-          @Override
-          public String getFilename() {
-            return filename;
-          }
-        });
-      }
-
-      return resources.toArray(new Resource[resources.size()]);
+    if (fileData == null) {
+      return new Resource[0];
-    return new Resource[0];
+    final String[] fileNames = CliUtil.bytesToNames(fileData);
+    final byte[][] fileContent = CliUtil.bytesToData(fileData);
+
+    final List<Resource> resources = new ArrayList<Resource>(fileNames.length);
+
+    for (int index = 0; index < fileNames.length; index++) {
+      final String filename = fileNames[index];
+      resources.add(new ByteArrayResource(fileContent[index],
+          String.format("Contents of JAR file (%1$s).", filename)) {
+        @Override
+        public String getFilename() {
+          return filename;
+        }
+      });
+    }
+
+    return resources.toArray(new Resource[resources.size()]);
-    if (files != null) {
-      final List<Resource> resources = new ArrayList<Resource>(files.length);
-
-      for (final MultipartFile file : files) {
-        resources.add(new MultipartFileResourceAdapter(file));
-      }
-
-      return convert(resources.toArray(new Resource[resources.size()]));
+    if (files == null) {
+      return new byte[0][];
-    return new byte[0][];
+    final List<Resource> resources = new ArrayList<Resource>(files.length);
+    for (final MultipartFile file : files) {
+      resources.add(new MultipartFileResourceAdapter(file));
+    }
+    return convert(resources.toArray(new Resource[resources.size()]));
-    if (resources != null) {
-      final List<byte[]> fileData = new ArrayList<byte[]>(resources.length * 2);
-
-      for (final Resource resource : resources) {
-        if (StringUtils.isBlank(resource.getFilename())) {
-          throw new IllegalArgumentException(String.format(
-              "The filename of Resource (%1$s) must be specified!", resource.getDescription()));
-        }
-
-        fileData.add(resource.getFilename().getBytes());
-        fileData.add(IOUtils.toByteArray(resource.getInputStream()));
-      }
-
-      return fileData.toArray(new byte[fileData.size()][]);
+    if (resources == null) {
+      return new byte[0][];
-    return new byte[0][];
-  }
+    final List<byte[]> fileData = new ArrayList<byte[]>(resources.length * 2);
+    for (final Resource resource : resources) {
+      if (StringUtils.isBlank(resource.getFilename())) {
+        throw new IllegalArgumentException(String.format(
+            "The filename of Resource (%1$s) must be specified!", resource.getDescription()));
+      }
+
+      fileData.add(resource.getFilename().getBytes());
+      fileData.add(IOUtils.toByteArray(resource.getInputStream()));
+    }
+
+    return fileData.toArray(new byte[fileData.size()][]);
+  }

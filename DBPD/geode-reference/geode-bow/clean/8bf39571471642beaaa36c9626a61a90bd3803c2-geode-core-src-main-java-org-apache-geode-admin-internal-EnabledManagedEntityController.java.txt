Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Implements the actual administration (starting, stopping, etc.) of
- * GemFire {@link ManagedEntity}s.  It {@link Runtime#exec(java.lang.String) executes}
- * commands to administer the entities based on information provided
- * by the {@link InternalManagedEntity} object.  Note that it does not
- * use <code>SystemAdmin</code> to manage "local" entities; it always
- * execs the scripts.
+ * Implements the actual administration (starting, stopping, etc.) of GemFire
+ * {@link ManagedEntity}s. It {@link Runtime#exec(java.lang.String) executes} commands to administer
+ * the entities based on information provided by the {@link InternalManagedEntity} object. Note that
+ * it does not use <code>SystemAdmin</code> to manage "local" entities; it always execs the scripts.
- * This class is a refactoring of <code>Systemcontroller</code>,
- * <code>RemoteCommand</code>, and <code>LocatorRemoteCommand</code>.
+ * This class is a refactoring of <code>Systemcontroller</code>, <code>RemoteCommand</code>, and
+ * <code>LocatorRemoteCommand</code>.
-//  /** A lock to ensure that only entity is managed at a time.  See bug
-//   * 31374. */
-//  private static Object startStopLock = new Object();
+  // /** A lock to ensure that only entity is managed at a time. See bug
+  // * 31374. */
+  // private static Object startStopLock = new Object();
-  private static final String[] ERROR_OUTPUTS = new String[] {
-    "No such file or directory",
-    "The system cannot find the file specified.",
-    "Access is denied.",
-    "cannot open",
-    "ERROR"
-  };
+  private static final String[] ERROR_OUTPUTS = new String[] {"No such file or directory",
+      "The system cannot find the file specified.", "Access is denied.", "cannot open", "ERROR"};
-  //////////////////////  Instance Fields  //////////////////////
+  ////////////////////// Instance Fields //////////////////////
-  /** The thread group in which threads launched by this system
-   * controller reside. */
+  /**
+   * The thread group in which threads launched by this system controller reside.
+   */
-  ///////////////////////  Constructors  ///////////////////////
+  /////////////////////// Constructors ///////////////////////
-   * Creates a new <code>ManagedEntityController</code> for entities
-   * in the given distributed system.
+   * Creates a new <code>ManagedEntityController</code> for entities in the given distributed
+   * system.
-      LoggingThreadGroup.createThreadGroup("ManagedEntityController threads", logger);
+        LoggingThreadGroup.createThreadGroup("ManagedEntityController threads", logger);
-  /////////////////////  Instance Methods  /////////////////////
+  ///////////////////// Instance Methods /////////////////////
-   * Returns <code>true</code> if the <code>output</code> string
-   * contains a known error message.
+   * Returns <code>true</code> if the <code>output</code> string contains a known error message.
-    if (output == null) return false;
+    if (output == null)
+      return false;
-      if (error) return error;
+      if (error)
+        return error;
-   * @param command
-   *        The full command to remotely execute
+   * @param command The full command to remotely execute
-   * @return Output from the command that was executed or
-   *         <code>null</code> if the executing the command failed.
+   * @return Output from the command that was executed or <code>null</code> if the executing the
+   *         command failed.
-  protected String execute(String command,
-                         InternalManagedEntity entity) {
-    /* TODO: this is getting ugly... clients of this method really need to
-       have the ability to do their own parsing/checking of 'output' */
+  protected String execute(String command, InternalManagedEntity entity) {
+    /*
+     * TODO: this is getting ugly... clients of this method really need to have the ability to do
+     * their own parsing/checking of 'output'
+     */
-      throw new IllegalArgumentException(LocalizedStrings.ManagedEntityController_EXECUTION_COMMAND_IS_EMPTY.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.ManagedEntityController_EXECUTION_COMMAND_IS_EMPTY.toLocalizedString());
-    File workingDir =
-      new File(entity.getEntityConfig().getWorkingDirectory());
-    logger.info(LocalizedMessage.create(LocalizedStrings.ManagedEntityController_EXECUTING_REMOTE_COMMAND_0_IN_DIRECTORY_1, new Object[] {command, workingDir}));
+    File workingDir = new File(entity.getEntityConfig().getWorkingDirectory());
+    logger.info(LocalizedMessage.create(
+        LocalizedStrings.ManagedEntityController_EXECUTING_REMOTE_COMMAND_0_IN_DIRECTORY_1,
+        new Object[] {command, workingDir}));
-      p = Runtime.getRuntime().exec(command, null /* env */,
-                                    workingDir);
+      p = Runtime.getRuntime().exec(command, null /* env */, workingDir);
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.ManagedEntityController_WHILE_EXECUTING_0, command), e);
+      logger.fatal(LocalizedMessage
+          .create(LocalizedStrings.ManagedEntityController_WHILE_EXECUTING_0, command), e);
-    logger.info(LocalizedMessage.create(LocalizedStrings.ManagedEntityController_RESULT_OF_EXECUTING_0_IS_1, new Object[] {command, Integer.valueOf(retCode)}));
-    logger.info(LocalizedMessage.create(LocalizedStrings.ManagedEntityController_OUTPUT_OF_0_IS_1, new Object[] {command, output}));
+    logger.info(
+        LocalizedMessage.create(LocalizedStrings.ManagedEntityController_RESULT_OF_EXECUTING_0_IS_1,
+            new Object[] {command, Integer.valueOf(retCode)}));
+    logger.info(LocalizedMessage.create(LocalizedStrings.ManagedEntityController_OUTPUT_OF_0_IS_1,
+        new Object[] {command, output}));
-      logger.warn(LocalizedMessage.create(LocalizedStrings.ManagedEntityController_REMOTE_EXECUTION_OF_0_FAILED, command));
+      logger.warn(LocalizedMessage
+          .create(LocalizedStrings.ManagedEntityController_REMOTE_EXECUTION_OF_0_FAILED, command));
-//  /** Returns true if the path is on Windows. */
-//  private boolean pathIsWindows(File path) {
-//    return pathIsWindows(path.toString());
-//  }
+  // /** Returns true if the path is on Windows. */
+  // private boolean pathIsWindows(File path) {
+  // return pathIsWindows(path.toString());
+  // }
-      return (Character.isLetter(path.charAt(0)) && path.charAt(1) == ':') ||
-        (path.startsWith("//") || path.startsWith("\\\\"));
+      return (Character.isLetter(path.charAt(0)) && path.charAt(1) == ':')
+          || (path.startsWith("//") || path.startsWith("\\\\"));
-   * If the managed entity resides on a remote host, then
-   * <code>command</code> is munged to take the remote command into account.
+   * If the managed entity resides on a remote host, then <code>command</code> is munged to take the
+   * remote command into account.
-   * @throws IllegalStateException
-   *        If a remote command is required, but one has not been
-   *        specified.
+   * @throws IllegalStateException If a remote command is required, but one has not been specified.
-  private String arrangeRemoteCommand(InternalManagedEntity entity,
-                                      String cmd) {
+  private String arrangeRemoteCommand(InternalManagedEntity entity, String cmd) {
-      throw new IllegalStateException(LocalizedStrings.ManagedEntityController_A_REMOTE_COMMAND_MUST_BE_SPECIFIED_TO_OPERATE_ON_A_MANAGED_ENTITY_ON_HOST_0
-          .toLocalizedString(host));
+      throw new IllegalStateException(
+          LocalizedStrings.ManagedEntityController_A_REMOTE_COMMAND_MUST_BE_SPECIFIED_TO_OPERATE_ON_A_MANAGED_ENTITY_ON_HOST_0
+              .toLocalizedString(host));
-      cmdIdx = prefix.indexOf(CMD); //recalculate;
+      cmdIdx = prefix.indexOf(CMD); // recalculate;
-   * Returns the full path to the executable in
-   * <code>$GEMFIRE/bin</code> taking into account the {@linkplain
-   * ManagedEntityConfig#getProductDirectory product directory} and the
-   * platform's file separator.
+   * Returns the full path to the executable in <code>$GEMFIRE/bin</code> taking into account the
+   * {@linkplain ManagedEntityConfig#getProductDirectory product directory} and the platform's file
+   * separator.
-   * Note: we should probably do a better job of determine whether or
-   * not the machine on which the entity runs is Windows or Linux.
+   * Note: we should probably do a better job of determine whether or not the machine on which the
+   * entity runs is Windows or Linux.
-   * @param executable
-   *        The name of the executable that resides in
-   *        <code>$GEMFIRE/bin</code>.
+   * @param executable The name of the executable that resides in <code>$GEMFIRE/bin</code>.
-  public String getProductExecutable(InternalManagedEntity entity,
-                                     String executable) {
-    String productDirectory =
-      entity.getEntityConfig().getProductDirectory();
+  public String getProductExecutable(InternalManagedEntity entity, String executable) {
+    String productDirectory = entity.getEntityConfig().getProductDirectory();
-//    if (productDir != null) (cannot be null)
+    // if (productDir != null) (cannot be null)
-//    else {
-//      path = "";
-//    }
+    // else {
+    // path = "";
+    // }
-   * Builds optional SSL command-line arguments.  Returns null if SSL is not
-   * enabled for the distributed system.
+   * Builds optional SSL command-line arguments. Returns null if SSL is not enabled for the
+   * distributed system.
-    if (sslProps == null) return null;
+    if (sslProps == null)
+      return null;
-   * Builds optional SSL properties for DistributionLocator. Returns null if SSL
-   * is not enabled for the distributed system.
+   * Builds optional SSL properties for DistributionLocator. Returns null if SSL is not enabled for
+   * the distributed system.
-   * @param forCommandLine
-   *                true indicates that
-   *                {@link DistributionConfig#GEMFIRE_PREFIX} should be
-   *                prepended so the argument will become -Dgemfire.xxxx
+   * @param forCommandLine true indicates that {@link DistributionConfig#GEMFIRE_PREFIX} should be
+   *        prepended so the argument will become -Dgemfire.xxxx
-  private Properties buildSSLProperties(DistributedSystemConfig config,
-                                        boolean forCommandLine) {
-    if (!config.isSSLEnabled()) return null;
+  private Properties buildSSLProperties(DistributedSystemConfig config, boolean forCommandLine) {
+    if (!config.isSSLEnabled())
+      return null;
-    if (forCommandLine) prefix = DistributionConfig.GEMFIRE_PREFIX;
+    if (forCommandLine)
+      prefix = DistributionConfig.GEMFIRE_PREFIX;
-    sslProps.setProperty(prefix +
-            MCAST_PORT,
-                         "0");
-    sslProps.setProperty(prefix +
-                         CLUSTER_SSL_ENABLED,
-                         String.valueOf(config.isSSLEnabled()));
-    sslProps.setProperty(prefix +
-                         CLUSTER_SSL_CIPHERS,
-                         config.getSSLCiphers());
-    sslProps.setProperty(prefix +
-                         CLUSTER_SSL_PROTOCOLS,
-                         config.getSSLProtocols());
-    sslProps.setProperty(prefix +
-                         CLUSTER_SSL_REQUIRE_AUTHENTICATION,
-                         String.valueOf(config.isSSLAuthenticationRequired()));
+    sslProps.setProperty(prefix + MCAST_PORT, "0");
+    sslProps.setProperty(prefix + CLUSTER_SSL_ENABLED, String.valueOf(config.isSSLEnabled()));
+    sslProps.setProperty(prefix + CLUSTER_SSL_CIPHERS, config.getSSLCiphers());
+    sslProps.setProperty(prefix + CLUSTER_SSL_PROTOCOLS, config.getSSLProtocols());
+    sslProps.setProperty(prefix + CLUSTER_SSL_REQUIRE_AUTHENTICATION,
+        String.valueOf(config.isSSLAuthenticationRequired()));
-    final String command =
-      arrangeRemoteCommand(entity, entity.getStartCommand());
+    final String command = arrangeRemoteCommand(entity, entity.getStartCommand());
-        public void run() {
-          execute(command, entity);
-        }
-      }, "Start " + entity.getEntityType());
+      public void run() {
+        execute(command, entity);
+      }
+    }, "Start " + entity.getEntityType());
-    final String command =
-      arrangeRemoteCommand(entity, entity.getStopCommand());
+    final String command = arrangeRemoteCommand(entity, entity.getStopCommand());
-        public void run() {
-          execute(command, entity);
-        }
-      }, "Stop " + entity.getEntityType());
+      public void run() {
+        execute(command, entity);
+      }
+    }, "Stop " + entity.getEntityType());
-    final String command =
-      arrangeRemoteCommand(entity, entity.getIsRunningCommand());
+    final String command = arrangeRemoteCommand(entity, entity.getIsRunningCommand());
-    if (output == null ||
-        (output.indexOf("stop" /* "ing" "ped" */) != -1) ||
-        (output.indexOf("killed") != -1) ||
-        (output.indexOf("starting") != -1)) {
+    if (output == null || (output.indexOf("stop" /* "ing" "ped" */) != -1)
+        || (output.indexOf("killed") != -1) || (output.indexOf("starting") != -1)) {
-      throw new IllegalStateException(LocalizedStrings.ManagedEntityController_COULD_NOT_DETERMINE_IF_MANAGED_ENTITY_WAS_RUNNING_0
-          .toLocalizedString(output));
+      throw new IllegalStateException(
+          LocalizedStrings.ManagedEntityController_COULD_NOT_DETERMINE_IF_MANAGED_ENTITY_WAS_RUNNING_0
+              .toLocalizedString(output));
-   * Returns the contents of a locator's log file.  Other APIs are
-   * used to get the log file of managed entities that are also system
-   * members.
+   * Returns the contents of a locator's log file. Other APIs are used to get the log file of
+   * managed entities that are also system members.
-    String command =
-      arrangeRemoteCommand(locator, locator.getLogCommand());
+    String command = arrangeRemoteCommand(locator, locator.getLogCommand());
-   * Returns the contents of the given directory using the given
-   * managed entity to determine the host and remote command.
+   * Returns the contents of the given directory using the given managed entity to determine the
+   * host and remote command.
-  private String listDirectory(InternalManagedEntity entity,
-                               String dir) {
+  private String listDirectory(InternalManagedEntity entity, String dir) {
-    String listFile =
-        pathIsWindows(config.getProductDirectory()) ? "dir " : "ls ";
-    String command =
-      arrangeRemoteCommand(entity, listFile + dir);
+    String listFile = pathIsWindows(config.getProductDirectory()) ? "dir " : "ls ";
+    String command = arrangeRemoteCommand(entity, listFile + dir);

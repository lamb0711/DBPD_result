Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-   
+
- * Represents the information about the manager that is stored
- * in its SystemAdmin  manager VM's main thread.
- * <p> For internal use only.
+ * Represents the information about the manager that is stored in its SystemAdmin manager VM's main
+ * thread.
+ * <p>
+ * For internal use only.
-   * The name of the file the locator will create when
-   * the system is started. It will be deleted when the system
-   * is stopped. It contains a single serialize copy of
-   * {@link ManagerInfo}. The file will always be located in
-   * the system directory.
+   * The name of the file the locator will create when the system is started. It will be deleted
+   * when the system is stopped. It contains a single serialize copy of {@link ManagerInfo}. The
+   * file will always be located in the system directory.
-   * <p>Current value is <code>0</code>.
+   * <p>
+   * Current value is <code>0</code>.
-   * <p>Current value is <code>1</code>.
+   * <p>
+   * Current value is <code>1</code>.
-   * <p>Current value is <code>2</code>.
+   * <p>
+   * Current value is <code>2</code>.
-   * <p>Current value is <code>3</code>.
+   * <p>
+   * Current value is <code>3</code>.
-   * <p>Current value is <code>4</code>.
+   * <p>
+   * Current value is <code>4</code>.
-    ManagerInfo.saveManagerInfo(OSProcess.getId(), STARTED_STATUS_CODE, directory, port, bindAddress);
+    ManagerInfo.saveManagerInfo(OSProcess.getId(), STARTED_STATUS_CODE, directory, port,
+        bindAddress);
+
-      throw new SystemIsRunningException(LocalizedStrings.ManagerInfo_0_1_IS_ALREADY_RUNNING.toLocalizedString(new Object[] {"Locator", directory.getPath()}));
+      throw new SystemIsRunningException(LocalizedStrings.ManagerInfo_0_1_IS_ALREADY_RUNNING
+          .toLocalizedString(new Object[] {"Locator", directory.getPath()}));
-    ManagerInfo.saveManagerInfo(OSProcess.getId(), STARTING_STATUS_CODE, directory, port, bindAddress);
+    ManagerInfo.saveManagerInfo(OSProcess.getId(), STARTING_STATUS_CODE, directory, port,
+        bindAddress);
-  // fix for bug #44059.  store the port and address for the locator in the persistent information
+
+  // fix for bug #44059. store the port and address for the locator in the persistent information
-    ManagerInfo.saveManagerInfo(OSProcess.getId(), STOPPING_STATUS_CODE, directory, port, bindAddress);
+    ManagerInfo.saveManagerInfo(OSProcess.getId(), STOPPING_STATUS_CODE, directory, port,
+        bindAddress);
+
-   * Saves the manager information to the info
-   * file in the given <code>directory</code>.
+   * Saves the manager information to the info file in the given <code>directory</code>.
+   * 
-  private static void saveManagerInfo(int pid, int status, File directory, int port, InetAddress bindAddress) {
+  private static void saveManagerInfo(int pid, int status, File directory, int port,
+      InetAddress bindAddress) {
-      throw new GemFireIOException(LocalizedStrings.ManagerInfo_COULD_NOT_WRITE_FILE_0.toLocalizedString(infoFile), io);
+      throw new GemFireIOException(
+          LocalizedStrings.ManagerInfo_COULD_NOT_WRITE_FILE_0.toLocalizedString(infoFile), io);
+
+
+
-  static final String[] statusNames = new String[] {
-    LocalizedStrings.ManagerInfo_STOPPED.toLocalizedString(),
-    LocalizedStrings.ManagerInfo_STOPPING.toLocalizedString(),
-    LocalizedStrings.ManagerInfo_KILLED.toLocalizedString(),
-    LocalizedStrings.ManagerInfo_STARTING.toLocalizedString(),
-    LocalizedStrings.ManagerInfo_RUNNING.toLocalizedString() 
-  };
+
+  static final String[] statusNames =
+      new String[] {LocalizedStrings.ManagerInfo_STOPPED.toLocalizedString(),
+          LocalizedStrings.ManagerInfo_STOPPING.toLocalizedString(),
+          LocalizedStrings.ManagerInfo_KILLED.toLocalizedString(),
+          LocalizedStrings.ManagerInfo_STARTING.toLocalizedString(),
+          LocalizedStrings.ManagerInfo_RUNNING.toLocalizedString()};
+
-     * Gets the string representation for the given <code>status</code> int code.
-     */
+   * Gets the string representation for the given <code>status</code> int code.
+   */
+
-     * Gets the status code for the given <code>statusName</code>.
-     * @throws IllegalArgumentException if an unknown status name is given.
-     */
+   * Gets the status code for the given <code>statusName</code>.
+   * 
+   * @throws IllegalArgumentException if an unknown status name is given.
+   */
-    for (int i=STOPPED_STATUS_CODE; i <= STARTED_STATUS_CODE; i++) {
+    for (int i = STOPPED_STATUS_CODE; i <= STARTED_STATUS_CODE; i++) {
-    throw new IllegalArgumentException(LocalizedStrings.ManagerInfo_UNKNOWN_STATUSNAME_0.toLocalizedString(statusName));
+    throw new IllegalArgumentException(
+        LocalizedStrings.ManagerInfo_UNKNOWN_STATUSNAME_0.toLocalizedString(statusName));
+
-      throw new UncreatedSystemException(LocalizedStrings.ManagerInfo__0_DOES_NOT_EXIST_OR_IS_NOT_A_DIRECTORY.toLocalizedString(directory.getPath()));
+      throw new UncreatedSystemException(
+          LocalizedStrings.ManagerInfo__0_DOES_NOT_EXIST_OR_IS_NOT_A_DIRECTORY
+              .toLocalizedString(directory.getPath()));
-      throw new UnstartedSystemException(LocalizedStrings.ManagerInfo_THE_INFO_FILE_0_DOES_NOT_EXIST.toLocalizedString(infoFile.getPath()));
+      throw new UnstartedSystemException(LocalizedStrings.ManagerInfo_THE_INFO_FILE_0_DOES_NOT_EXIST
+          .toLocalizedString(infoFile.getPath()));
-        throw new GemFireIOException(LocalizedStrings.ManagerInfo_COULD_NOT_LOAD_FILE_0_BECAUSE_THE_FILE_IS_EMPTY_WAIT_FOR_THE_1_TO_FINISH_STARTING.toLocalizedString(new Object[] {infoFile, (locator ? "locator" : "system")}), null);
+        throw new GemFireIOException(
+            LocalizedStrings.ManagerInfo_COULD_NOT_LOAD_FILE_0_BECAUSE_THE_FILE_IS_EMPTY_WAIT_FOR_THE_1_TO_FINISH_STARTING
+                .toLocalizedString(new Object[] {infoFile, (locator ? "locator" : "system")}),
+            null);
-      ManagerInfo result = 
-        (ManagerInfo) DataSerializer.readObject(dis);
+      ManagerInfo result = (ManagerInfo) DataSerializer.readObject(dis);
-      throw new GemFireIOException(LocalizedStrings.ManagerInfo_COULD_NOT_LOAD_FILE_0.toLocalizedString(infoFile), io);
+      throw new GemFireIOException(
+          LocalizedStrings.ManagerInfo_COULD_NOT_LOAD_FILE_0.toLocalizedString(infoFile), io);
-      throw new GemFireIOException(LocalizedStrings.ManagerInfo_COULD_NOT_LOAD_FILE_0_BECAUSE_A_CLASS_COULD_NOT_BE_FOUND.toLocalizedString(infoFile), ex);
+      throw new GemFireIOException(
+          LocalizedStrings.ManagerInfo_COULD_NOT_LOAD_FILE_0_BECAUSE_A_CLASS_COULD_NOT_BE_FOUND
+              .toLocalizedString(infoFile),
+          ex);
+
+
-      throw new IllegalArgumentException(LocalizedStrings.ManagerInfo_ONLY_LOCATORS_ARE_SUPPORTED.toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.ManagerInfo_ONLY_LOCATORS_ARE_SUPPORTED.toLocalizedString());
-        res = res.getCanonicalFile();
+      res = res.getCanonicalFile();
-        res = res.getAbsoluteFile();
+      res = res.getAbsoluteFile();
+
+
+
-      try {Thread.sleep(1000);} 
-      catch (InterruptedException ignore) {
+      try {
+        Thread.sleep(1000);
+      } catch (InterruptedException ignore) {
-    }
-    finally {
+    } finally {
+
+
+
+
-      if (status != STARTED_STATUS_CODE
-          && status != STARTING_STATUS_CODE
+      if (status != STARTED_STATUS_CODE && status != STARTING_STATUS_CODE
+
+
-    
+
-   * Constructs a manager info instance given the process id
-   * of the manager VM.
+   * Constructs a manager info instance given the process id of the manager VM.
+   * 
-  public ManagerInfo() { }
+  public ManagerInfo() {}
-  public void fromData(DataInput in) 
-    throws IOException, ClassNotFoundException {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {

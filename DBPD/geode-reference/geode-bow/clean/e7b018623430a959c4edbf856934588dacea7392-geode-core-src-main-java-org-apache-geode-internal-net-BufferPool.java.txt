GEODE-6636: Create multiple buffer pools (#4234)

* GEODE-6636: Create multiple buffer pools

* GEODE-6636: Remove new alerts

* GEODE-6636: Bug fix

* GEODE-6636: Update after review

* GEODE-6636: Added SMALL, MEDIUM constants

* GEODE-6636: Fix non-direct buffer added to direct buffer pool

* GEODE-6636: Update after rebase

* GEODE-6636: Update after rebase
+import org.apache.geode.distributed.internal.DistributionConfig;
+import org.apache.geode.internal.tcp.Connection;
-   * A list of soft references to byte buffers.
+   * A list of soft references to small byte buffers.
-  private final ConcurrentLinkedQueue<BBSoftReference> bufferQueue =
+  private final ConcurrentLinkedQueue<BBSoftReference> bufferSmallQueue =
+   * A list of soft references to middle byte buffers.
+   */
+  private final ConcurrentLinkedQueue<BBSoftReference> bufferMiddleQueue =
+      new ConcurrentLinkedQueue<>();
+
+  /**
+   * A list of soft references to large byte buffers.
+   */
+  private final ConcurrentLinkedQueue<BBSoftReference> bufferLargeQueue =
+      new ConcurrentLinkedQueue<>();
+
+  private final int SMALL_BUFFER_SIZE = Connection.SMALL_BUFFER_SIZE;
+
+
+  private final int MEDIUM_BUFFER_SIZE = DistributionConfig.DEFAULT_SOCKET_BUFFER_SIZE;
+
+
+  /**
+
-      IdentityHashMap<BBSoftReference, BBSoftReference> alreadySeen = null; // keys are used like a
-                                                                            // set
-      BBSoftReference ref = bufferQueue.poll();
-      while (ref != null) {
-        ByteBuffer bb = ref.getBB();
-        if (bb == null) {
-          // it was garbage collected
-          int refSize = ref.consumeSize();
-          if (refSize > 0) {
-            if (ref.getSend()) { // fix bug 46773
-              stats.incSenderBufferSize(-refSize, true);
-            } else {
-              stats.incReceiverBufferSize(-refSize, true);
-            }
-          }
-        } else if (bb.capacity() >= size) {
-          bb.rewind();
-          bb.limit(size);
-          return bb;
-        } else {
-          // wasn't big enough so put it back in the queue
-          Assert.assertTrue(bufferQueue.offer(ref));
-          if (alreadySeen == null) {
-            alreadySeen = new IdentityHashMap<>();
-          }
-          if (alreadySeen.put(ref, ref) != null) {
-            // if it returns non-null then we have already seen this item
-            // so we have worked all the way through the queue once.
-            // So it is time to give up and allocate a new buffer.
-            break;
-          }
-        }
-        ref = bufferQueue.poll();
+      if (size <= MEDIUM_BUFFER_SIZE) {
+        return acquirePredefinedFixedBuffer(send, size);
+      } else {
+        return acquireLargeBuffer(send, size);
-      result = ByteBuffer.allocateDirect(size);
-    if (send) {
-      stats.incSenderBufferSize(size, useDirectBuffers);
-    } else {
-      stats.incReceiverBufferSize(size, useDirectBuffers);
-    }
+    updateBufferStats(size, send, false);
+  /**
+   * Acquire direct buffer with predefined default capacity (4096 or 32768)
+   */
+  private ByteBuffer acquirePredefinedFixedBuffer(boolean send, int size) {
+    // set
+    int defaultSize;
+    ConcurrentLinkedQueue<BBSoftReference> bufferTempQueue;
+    ByteBuffer result;
+
+    if (size <= SMALL_BUFFER_SIZE) {
+      defaultSize = SMALL_BUFFER_SIZE;
+      bufferTempQueue = bufferSmallQueue;
+    } else {
+      defaultSize = MEDIUM_BUFFER_SIZE;
+      bufferTempQueue = bufferMiddleQueue;
+    }
+
+    BBSoftReference ref = bufferTempQueue.poll();
+    while (ref != null) {
+      ByteBuffer bb = ref.getBB();
+      if (bb == null) {
+        // it was garbage collected
+        updateBufferStats(-defaultSize, ref.getSend(), true);
+      } else {
+        bb.clear();
+        if (defaultSize > size) {
+          bb.limit(size);
+        }
+        return bb;
+      }
+      ref = bufferTempQueue.poll();
+    }
+    result = ByteBuffer.allocateDirect(defaultSize);
+    updateBufferStats(defaultSize, send, true);
+    if (defaultSize > size) {
+      result.limit(size);
+    }
+    return result;
+  }
+
+  private ByteBuffer acquireLargeBuffer(boolean send, int size) {
+    // set
+    ByteBuffer result;
+    IdentityHashMap<BBSoftReference, BBSoftReference> alreadySeen = null; // keys are used like a
+    // set
+    BBSoftReference ref = bufferLargeQueue.poll();
+    while (ref != null) {
+      ByteBuffer bb = ref.getBB();
+      if (bb == null) {
+        // it was garbage collected
+        int refSize = ref.consumeSize();
+        if (refSize > 0) {
+          updateBufferStats(-refSize, ref.getSend(), true);
+        }
+      } else if (bb.capacity() >= size) {
+        bb.clear();
+        if (bb.capacity() > size) {
+          bb.limit(size);
+        }
+        return bb;
+      } else {
+        // wasn't big enough so put it back in the queue
+        Assert.assertTrue(bufferLargeQueue.offer(ref));
+        if (alreadySeen == null) {
+          alreadySeen = new IdentityHashMap<>();
+        }
+        if (alreadySeen.put(ref, ref) != null) {
+          // if it returns non-null then we have already seen this item
+          // so we have worked all the way through the queue once.
+          // So it is time to give up and allocate a new buffer.
+          break;
+        }
+      }
+      ref = bufferLargeQueue.poll();
+    }
+    result = ByteBuffer.allocateDirect(size);
+    updateBufferStats(size, send, true);
+    return result;
+  }
+
-      bufferQueue.offer(bbRef);
-    } else {
-      if (send) {
-        stats.incSenderBufferSize(-bb.capacity(), false);
+      if (bb.capacity() <= SMALL_BUFFER_SIZE) {
+        bufferSmallQueue.offer(bbRef);
+      } else if (bb.capacity() <= MEDIUM_BUFFER_SIZE) {
+        bufferMiddleQueue.offer(bbRef);
-        stats.incReceiverBufferSize(-bb.capacity(), false);
+        bufferLargeQueue.offer(bbRef);
+    } else {
+      updateBufferStats(-bb.capacity(), send, false);
+    }
+  }
+
+  /**
+   * Update buffer stats.
+   */
+  private void updateBufferStats(int size, boolean send, boolean direct) {
+    if (send) {
+      stats.incSenderBufferSize(size, direct);
+    } else {
+      stats.incReceiverBufferSize(size, direct);

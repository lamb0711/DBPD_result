GEODE-7832: Remove Connection Semaphores (#4754)

Removed the semaphores and related methods from DirectChannel and
Connection classes. They were used to constrain messaging when some
undocumented system properties were set.
-import java.util.concurrent.Semaphore;
-import org.apache.geode.distributed.DistributedSystemDisconnectedException;
-import org.apache.geode.internal.util.concurrent.ReentrantSemaphore;
-      this.groupOrderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
-      this.groupUnorderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
-      this.groupOrderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
-      this.groupUnorderedSenderSem = new ReentrantSemaphore(MAX_GROUP_SENDERS);
-
-  /**
-   * Return how many concurrent operations should be allowed by default. since 6.6, this has been
-   * raised to Integer.MAX value from the number of available processors. Setting this to a lower
-   * value raises the possibility of a deadlock when serializing a message with PDX objects, because
-   * the PDX serialization can trigger further distribution.
-   */
-  public static final int DEFAULT_CONCURRENCY_LEVEL =
-      Integer.getInteger("p2p.defaultConcurrencyLevel", Integer.MAX_VALUE / 2).intValue();
-
-  /**
-   * The maximum number of concurrent senders sending a message to a group of recipients.
-   */
-  private static final int MAX_GROUP_SENDERS =
-      Integer.getInteger("p2p.maxGroupSenders", DEFAULT_CONCURRENCY_LEVEL).intValue();
-  private Semaphore groupUnorderedSenderSem;
-  private Semaphore groupOrderedSenderSem;
-
-  private Semaphore getGroupSem(boolean ordered) {
-    if (ordered) {
-      return this.groupOrderedSenderSem;
-    } else {
-      return this.groupUnorderedSenderSem;
-    }
-  }
-
-  private void acquireGroupSendPermission(boolean ordered) {
-    if (this.disconnected) {
-      throw new org.apache.geode.distributed.DistributedSystemDisconnectedException(
-          "Direct channel has been stopped");
-    }
-    // @todo darrel: add some stats
-    final Semaphore s = getGroupSem(ordered);
-    for (;;) {
-      this.conduit.getCancelCriterion().checkCancelInProgress(null);
-      boolean interrupted = Thread.interrupted();
-      try {
-        s.acquire();
-        break;
-      } catch (InterruptedException ex) {
-        interrupted = true;
-      } finally {
-        if (interrupted) {
-          Thread.currentThread().interrupt();
-        }
-      }
-    } // for
-    if (this.disconnected) {
-      s.release();
-      throw new DistributedSystemDisconnectedException(
-          "communications disconnected");
-    }
-  }
-
-  private void releaseGroupSendPermission(boolean ordered) {
-    final Semaphore s = getGroupSem(ordered);
-    s.release();
-  }
-
-        boolean sendingToGroup = cons.size() > 1;
-        Connection permissionCon = null;
-        if (sendingToGroup) {
-          acquireGroupSendPermission(orderedMsg);
-        } else {
-          // sending over just one connection
-          permissionCon = (Connection) cons.get(0);
-          if (permissionCon != null) {
-            try {
-              permissionCon.acquireSendPermission();
-            } catch (ConnectionException conEx) {
-              // Set retryInfo and then retry.
-              // We want to keep calling TCPConduit.getConnection until it doesn't
-              // return a connection.
-              retryInfo = new ConnectExceptions();
-              retryInfo.addFailure(permissionCon.getRemoteAddress(), conEx);
-              continue;
-            }
-          }
+        if (retry && logger.isDebugEnabled()) {
+          logger.debug("Retrying send ({}{}) to {} peers ({}) via tcp/ip",
+              msg, cons.size(), cons);
+        DMStats stats = getDMStats();
+        List<?> sentCons; // used for cons we sent to this time
+        final BaseMsgStreamer ms =
+            MsgStreamer.create(cons, msg, directReply, stats, getConduit().getBufferPool());
-          if (retry && logger.isDebugEnabled()) {
-            logger.debug("Retrying send ({}{}) to {} peers ({}) via tcp/ip",
-                msg, cons.size(), cons);
+          startTime = 0;
+          if (ackTimeout > 0) {
+            startTime = System.currentTimeMillis();
-          DMStats stats = getDMStats();
-          List<?> sentCons; // used for cons we sent to this time
+          ms.reserveConnections(startTime, ackTimeout, ackSDTimeout);
-          final BaseMsgStreamer ms =
-              MsgStreamer.create(cons, msg, directReply, stats, getConduit().getBufferPool());
-          try {
-            startTime = 0;
-            if (ackTimeout > 0) {
-              startTime = System.currentTimeMillis();
-            }
-            ms.reserveConnections(startTime, ackTimeout, ackSDTimeout);
-
-            int result = ms.writeMessage();
-            if (bytesWritten == 0) {
-              // bytesWritten only needs to be set once.
-              // if we have to do a retry we don't want to count
-              // each one's bytes.
-              bytesWritten = result;
-            }
-            ce = ms.getConnectExceptions();
-            sentCons = ms.getSentConnections();
-
-            totalSentCons.addAll(sentCons);
-          } catch (NotSerializableException e) {
-            throw e;
-          } catch (IOException ex) {
-            throw new InternalGemFireException(
-                "Unknown error serializing message",
-                ex);
-          } finally {
-            try {
-              ms.close();
-            } catch (IOException e) {
-              throw new InternalGemFireException("Unknown error serializing message", e);
-            }
+          int result = ms.writeMessage();
+          if (bytesWritten == 0) {
+            // bytesWritten only needs to be set once.
+            // if we have to do a retry we don't want to count
+            // each one's bytes.
+            bytesWritten = result;
+          ce = ms.getConnectExceptions();
+          sentCons = ms.getSentConnections();
-          if (ce != null) {
-            retryInfo = ce;
-            ce = null;
-          }
-
-          if (directReply && !sentCons.isEmpty()) {
-            long readAckStart = 0;
-            if (stats != null) {
-              readAckStart = stats.startReplyWait();
-            }
-            try {
-              ce = readAcks(sentCons, startTime, ackTimeout, ackSDTimeout, ce,
-                  directMsg.getDirectReplyProcessor());
-            } finally {
-              if (stats != null) {
-                stats.endReplyWait(readAckStart, startTime);
-              }
-            }
-          }
+          totalSentCons.addAll(sentCons);
+        } catch (NotSerializableException e) {
+          throw e;
+        } catch (IOException ex) {
+          throw new InternalGemFireException(
+              "Unknown error serializing message",
+              ex);
-          if (sendingToGroup) {
-            releaseGroupSendPermission(orderedMsg);
-          } else if (permissionCon != null) {
-            permissionCon.releaseSendPermission();
+          try {
+            ms.close();
+          } catch (IOException e) {
+            throw new InternalGemFireException("Unknown error serializing message", e);
+
+        if (ce != null) {
+          retryInfo = ce;
+          ce = null;
+        }
+
+        if (directReply && !sentCons.isEmpty()) {
+          long readAckStart = 0;
+          if (stats != null) {
+            readAckStart = stats.startReplyWait();
+          }
+          try {
+            ce = readAcks(sentCons, startTime, ackTimeout, ackSDTimeout, ce,
+                directMsg.getDirectReplyProcessor());
+          } finally {
+            if (stats != null) {
+              stats.endReplyWait(readAckStart, startTime);
+            }
+          }
+        }
+
-    try {
-      groupOrderedSenderSem.release();
-    } catch (Error e) {
-      // GEODE-1076 - already released
-    }
-    try {
-      groupUnorderedSenderSem.release();
-    } catch (Error e) {
-      // GEODE-1076 - already released
-    }

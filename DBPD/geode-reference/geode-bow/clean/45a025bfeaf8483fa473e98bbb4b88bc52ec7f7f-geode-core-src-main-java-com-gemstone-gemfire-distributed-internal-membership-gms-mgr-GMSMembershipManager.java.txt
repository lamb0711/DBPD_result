Merge branch 'develop' into feature/GEODE-420

# Conflicts:
#	geode-assembly/src/test/java/com/gemstone/gemfire/rest/internal/web/controllers/RestAPIsWithSSLDUnitTest.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/DistributionConfig.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/membership/gms/GMSUtil.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/AcceptorImpl.java
#	geode-core/src/main/java/com/gemstone/gemfire/management/internal/ManagementAgent.java
#	geode-core/src/main/java/org/apache/geode/redis/GeodeRedisServer.java
#	geode-core/src/test/java/com/gemstone/gemfire/distributed/LocatorDUnitTest.java

-import com.gemstone.gemfire.*;
+import java.io.IOException;
+import java.io.NotSerializableException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.*;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+import org.apache.logging.log4j.Logger;
+
+import com.gemstone.gemfire.CancelException;
+import com.gemstone.gemfire.ForcedDisconnectException;
+import com.gemstone.gemfire.GemFireConfigException;
+import com.gemstone.gemfire.InternalGemFireError;
+import com.gemstone.gemfire.SystemConnectException;
+import com.gemstone.gemfire.SystemFailure;
+import com.gemstone.gemfire.ToDataException;
-import com.gemstone.gemfire.distributed.internal.*;
+import com.gemstone.gemfire.distributed.internal.AdminMessageType;
+import com.gemstone.gemfire.distributed.internal.DMStats;
+import com.gemstone.gemfire.distributed.internal.DistributionConfig;
+import com.gemstone.gemfire.distributed.internal.DistributionException;
+import com.gemstone.gemfire.distributed.internal.DistributionManager;
+import com.gemstone.gemfire.distributed.internal.DistributionMessage;
+import com.gemstone.gemfire.distributed.internal.InternalDistributedSystem;
+import com.gemstone.gemfire.distributed.internal.InternalLocator;
+import com.gemstone.gemfire.distributed.internal.OverflowQueueWithDMStats;
+import com.gemstone.gemfire.distributed.internal.SizeableRunnable;
+import com.gemstone.gemfire.distributed.internal.StartupMessage;
-import com.gemstone.gemfire.distributed.internal.membership.*;
+import com.gemstone.gemfire.distributed.internal.membership.DistributedMembershipListener;
+import com.gemstone.gemfire.distributed.internal.membership.InternalDistributedMember;
+import com.gemstone.gemfire.distributed.internal.membership.MembershipManager;
+import com.gemstone.gemfire.distributed.internal.membership.MembershipTestHook;
+import com.gemstone.gemfire.distributed.internal.membership.NetView;
+import com.gemstone.gemfire.distributed.internal.membership.QuorumChecker;
-import org.apache.logging.log4j.Logger;
-
-import java.io.IOException;
-import java.io.NotSerializableException;
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.locks.*;
-  volatile boolean disableMulticastForRollingUpgrade;
+  private volatile boolean disableMulticastForRollingUpgrade;
-  boolean wasReconnectingSystem;
+  private boolean wasReconnectingSystem;
-  private ThreadLocal<Boolean> forceUseUDPMessaging = new ThreadLocal<Boolean>();
+  private final ThreadLocal<Boolean> forceUseUDPMessaging = new ThreadLocal<Boolean>() {
+    @Override protected Boolean initialValue() {
+      return Boolean.FALSE;
+    }
+  };
-    private int kind;
+    private final int kind;
-      StringBuffer sb = new StringBuffer();
+      StringBuilder sb = new StringBuilder();
-        sb.append("connect; member = <" + member + ">");
+        sb.append("connect; member = <").append(member).append(">");
-        sb.append("view <" + text + ">");
+        sb.append("view <").append(text).append(">");
-        sb.append("message <" + dmsg + ">");
+        sb.append("message <").append(dmsg).append(">");
-        sb.append("unknown=<" + kind + ">");
+        sb.append("unknown=<").append(kind).append(">");
-  protected final EventProcessingLock startupLock = new EventProcessingLock();
+  private final EventProcessingLock startupLock = new EventProcessingLock();
-  protected NetView latestView = new NetView();
+  private NetView latestView = new NetView();
-  protected ReadWriteLock latestViewLock = new ReentrantReadWriteLock();
+  private final ReadWriteLock latestViewLock = new ReentrantReadWriteLock();
-  protected com.gemstone.gemfire.distributed.internal.membership.DistributedMembershipListener listener;
+  private final com.gemstone.gemfire.distributed.internal.membership.DistributedMembershipListener listener;
-  List membershipTestHooks;
+  private List membershipTestHooks;
-  protected InternalDistributedMember address = null; // new DistributedMember(-1);
+  private InternalDistributedMember address = null; // new DistributedMember(-1);
-  protected DirectChannel directChannel;
+  private DirectChannel directChannel;
-  protected MyDCReceiver dcReceiver;
+  private MyDCReceiver dcReceiver;
-  volatile boolean hasJoined;
+  private volatile boolean hasJoined;
-  protected final Map shunnedMembers = new ConcurrentHashMap();
+  private final Map<DistributedMember, Long> shunnedMembers = new ConcurrentHashMap<>();
-  private final Map shutdownMembers = new BoundedLinkedHashMap(1000);
+  private final Map<DistributedMember, Object> shutdownMembers = new BoundedLinkedHashMap<>();
-  protected final HashSet shunnedAndWarnedMembers = new HashSet();
+  private final HashSet<DistributedMember> shunnedAndWarnedMembers = new HashSet<>();
-  protected final Map<InternalDistributedMember, Long> surpriseMembers = new ConcurrentHashMap();
+  private final Map<InternalDistributedMember, Long> surpriseMembers = new ConcurrentHashMap<>();
-  protected int surpriseMemberTimeout;
+  private int surpriseMemberTimeout;
-  private final Map<InternalDistributedMember, Long> suspectedMembers = new ConcurrentHashMap();
-  
-  /**
-   * the timeout interval for suspected members
-   */
-  private final long suspectMemberTimeout = 180000;
-  
+  private final Map<InternalDistributedMember, Long> suspectedMembers = new ConcurrentHashMap<>();
+
-  protected volatile boolean shutdownInProgress = false;
+  private volatile boolean shutdownInProgress = false;
-  protected volatile boolean processingEvents = false;
+  private volatile boolean processingEvents = false;
-  long latestViewId = -1;
+  private long latestViewId = -1;
-  /** distribution manager statistics */
-  DMStats stats;
-
-  protected LinkedList<StartupEvent> startupMessages = new LinkedList<StartupEvent>();
+  private final LinkedList<StartupEvent> startupMessages = new LinkedList<>();
-  final private HashMap memberLatch = new HashMap();
+  final private HashMap<DistributedMember, CountDownLatch> memberLatch = new HashMap<>();
-    DirectChannelListener upCall;
+    final DirectChannelListener upCall;
-  /** if we connect to a locator that has NPD enabled then we enable it in this VM */
-  public void enableNetworkPartitionDetection() {
-    if (logger.isDebugEnabled()) {
-      logger.debug("Network partition detection is being enabled");
-    }
-    this.services.getConfig().getDistributionConfig().setEnableNetworkPartitionDetection(true);
-    this.services.getConfig().setNetworkPartitionDetectionEnabled(true);
-  }
-  
-   * 
-   * @param newView
-  protected void processView(long newViewId, NetView newView)
-  {
+  protected void processView(long newViewId, NetView newView) {
-     if (logger.isDebugEnabled()) {
-      StringBuffer msg = new StringBuffer(200);
+    if (logger.isDebugEnabled()) {
+      StringBuilder msg = new StringBuilder(200);
-      msg.append("} on " + address.toString());
+      msg.append("} on ").append(address.toString());
+      logger.debug(msg);
-            LocalizedStrings.GroupMembershipService_THE_MEMBER_WITH_ID_0_IS_NO_LONGER_IN_MY_OWN_VIEW_1,
-            new Object[] {address, newView}));
+          LocalizedStrings.GroupMembershipService_THE_MEMBER_WITH_ID_0_IS_NO_LONGER_IN_MY_OWN_VIEW_1,
+          new Object[] {address, newView}));
-     
-//     if (newView.getCrashedMembers().size() > 0) {
-//       // dump stack for debugging #39827
-//       OSProcess.printStacks(0);
-//     }
+
-      for (Iterator<Map.Entry<InternalDistributedMember, Long>> it=surpriseMembers.entrySet().iterator(); it.hasNext(); ) {
-        InternalDistributedMember mbr = it.next().getKey();
+      for (final Entry<InternalDistributedMember, Long> internalDistributedMemberLongEntry : surpriseMembers.entrySet()) {
+        InternalDistributedMember mbr = internalDistributedMemberLongEntry.getKey();
-        InternalDistributedMember m = (InternalDistributedMember)newView.getMembers().get(i);
+        InternalDistributedMember m = newView.getMembers().get(i);
-          if ((currentLatch = (CountDownLatch)memberLatch.get(m)) != null) {
+          if ((currentLatch = memberLatch.get(m)) != null) {
-        InternalDistributedMember m = (InternalDistributedMember)priorView.getMembers().get(i);
+        InternalDistributedMember m = priorView.getMembers().get(i);
-        Long birthtime = (Long)entry.getValue();
+        Long birthtime = entry.getValue();
-      oldestAllowed = System.currentTimeMillis() - this.suspectMemberTimeout;
+      /*
+    the timeout interval for suspected members
+   */
+      final long suspectMemberTimeout = 180000;
+      oldestAllowed = System.currentTimeMillis() - suspectMemberTimeout;
-          InternalDistributedMember m = (InternalDistributedMember)entry.getKey();
-    this.stats = services.getStatistics();
-    RemoteTransportConfig transport = services.getConfig().getTransport();
-    int dcPort = 0;
-    if (directChannel != null) {
-      dcPort = directChannel.getPort();
-    }
-    
-      List<InternalDistributedMember> remaining = new ArrayList<InternalDistributedMember>(view.getMembers());
+      List<InternalDistributedMember> remaining = new ArrayList<>(view.getMembers());
-        this.listener.quorumLost(new HashSet<InternalDistributedMember>(failures),
+        this.listener.quorumLost(new HashSet<>(failures),
-   * 
-   * @param dm
-   * @param crashed
-   * @param reason
-  protected void removeWithViewLock(InternalDistributedMember dm,
-      boolean crashed, String reason) {
+  private void removeWithViewLock(InternalDistributedMember dm, boolean crashed, String reason) {
-    destroyMember(dm, crashed, reason);
+    destroyMember(dm, reason);
-        destroyMember(member, false, msg); // for good luck
+        destroyMember(member, msg); // for good luck
-  public void dispatchMessage(DistributionMessage msg) {
-    boolean isNew = false;
+  private void dispatchMessage(DistributionMessage msg) {
-      NetView newView = viewArg;
-      LocalViewMessage v = new LocalViewMessage(address, newId, newView,
+      LocalViewMessage v = new LocalViewMessage(address, newId, viewArg,
-   * 
-   * @param member
-          ev = (StartupEvent)startupMessages.removeFirst();
+          ev = startupMessages.removeFirst();
-    
-    for (InternalDistributedMember m: v.getMembers()) {
-      if (isShunned(m)) {
-        result.remove(m);
-      }
-    }
+
+    v.getMembers().stream().filter(this::isShunned).forEachOrdered(result::remove);
-  protected boolean isJoining() {
+  private boolean isJoining() {
-    return v.getMembers().contains(m);
+    return v.contains(m);
-  protected static volatile boolean inhibitForceDisconnectLogging;
+  private static volatile boolean inhibitForceDisconnectLogging;
-    final boolean DEBUG = SystemFailure.TRACE_CLOSE;
-    
-      if (DEBUG) {
-        System.err.println("DEBUG: emergency close of DirectChannel");
-      }
-    
-    if (DEBUG) {
-      System.err.println("DEBUG: done closing GroupMembershipService");
-    }
+
-  /**
-   * returns true if a shutdown message has been received from the given address but
-   * that member is still in the membership view or is a surprise member.
-   */
-  public boolean isShuttingDown(InternalDistributedMember mbr) {
-    synchronized(shutdownMembers) {
-      return shutdownMembers.containsKey(mbr);
-    }
-  }
-
-  
-          destroyMember(address, false, "orderly shutdown");
+          destroyMember(address, "orderly shutdown");
-          for (Iterator it=l.iterator(); it.hasNext(); ) {
-            MembershipTestHook dml = (MembershipTestHook)it.next();
+          for (final Object aL : l) {
+            MembershipTestHook dml = (MembershipTestHook) aL;
-          for (Iterator it=l.iterator(); it.hasNext(); ) {
-            MembershipTestHook dml = (MembershipTestHook)it.next();
+          for (final Object aL : l) {
+            MembershipTestHook dml = (MembershipTestHook) aL;
-  public void saveCacheXmlForReconnect() {
+  private void saveCacheXmlForReconnect() {
-    if (cache != null && (cache instanceof Cache)) {
+    if (cache != null) {
-        List<CacheServerCreation> list = new ArrayList<CacheServerCreation>(cache.getCacheServers().size());
-        for (Iterator it = cache.getCacheServers().iterator(); it.hasNext(); ) {
-          CacheServerImpl cs = (CacheServerImpl)it.next();
+        List<CacheServerCreation> list = new ArrayList<>(cache.getCacheServers().size());
+        for (final Object o : cache.getCacheServers()) {
+          CacheServerImpl cs = (CacheServerImpl) o;
-          problem = (Exception) cause;
+          problem = cause;
-    for (Iterator it=members.iterator(); it.hasNext(); ) {
-      verifyMember((DistributedMember)it.next(), reason);
+    for (final Object member : members) {
+      verifyMember((DistributedMember) member, reason);
-    if (mbr != null && memberExists((InternalDistributedMember)mbr)) {
-      return this.services.getHealthMonitor().checkIfAvailable(mbr, reason, true);
-    }
-    return false;
+    return mbr != null
+           && memberExists(mbr)
+           && this.services.getHealthMonitor().checkIfAvailable(mbr, reason, true);
-        keys = (InternalDistributedMember[])keySet.toArray(keys);
+        keys = keySet.toArray(keys);
-    int sentBytes = 0;
+    int sentBytes;
-      List members = ex.getMembers(); // We need to return this list of failures
+      List<InternalDistributedMember> members = (List<InternalDistributedMember>)ex.getMembers(); // We need to return this list of failures
-      return new HashSet<InternalDistributedMember>(members);
+      return new HashSet<>(members);
-    catch (RuntimeException e) {
-      if (logger.isDebugEnabled()) {
-        logger.debug("Membership: directChannelSend caught exception: {}", e.getMessage(), e);
-      }
-      throw e;
-    }
-    catch (Error e) {
+    catch (RuntimeException | Error e) {
-    if (this.hasJoined) {
-      return false;
-    } else {
-      return this.wasReconnectingSystem;
-    }
+    return !this.hasJoined && this.wasReconnectingSystem;
-    ((GMSQuorumChecker)checker).suspend();
+    checker.suspend();
-  public Set send(InternalDistributedMember dest, DistributionMessage msg)
-    throws NotSerializableException {
-    
-    InternalDistributedMember dests[] = new InternalDistributedMember[] { dest };
-    return send (dests, msg, null);
-  }
-  
-  public Set send(InternalDistributedMember[] destinations,
+  public Set<InternalDistributedMember> send(InternalDistributedMember[] destinations,
-    Set result = null;
+    Set<InternalDistributedMember> result;
-        result = new HashSet();
-        for (int i = 0; i < destinations.length; i ++)
-          result.add(destinations[i]);
+        result = new HashSet<>();
+        Collections.addAll(result, destinations);
-      return new HashSet(Arrays.asList(msg.getRecipients()));
+      return new HashSet<>(Arrays.asList(msg.getRecipients()));
-  // MembershipManager method
-  @Override
-  public void forceUDPMessagingForCurrentThread() {
-    forceUseUDPMessaging.set(null);
-  }
-  
-  
-  private boolean isForceUDPCommunications() {
-    Boolean forced = forceUseUDPMessaging.get();
-    return forced == Boolean.TRUE;
+
+  // MembershipManager method
+  @Override
+  public void forceUDPMessagingForCurrentThread() {
+    forceUseUDPMessaging.set(Boolean.TRUE);
-    // not currently supported by this manager
+    forceUseUDPMessaging.set(Boolean.FALSE);
-  
+
+  private boolean isForceUDPCommunications() {
+    return forceUseUDPMessaging.get();
+  }
+
-  protected void destroyMember(final InternalDistributedMember member,
-      boolean crashed, final String reason) {
+  private void destroyMember(final InternalDistributedMember member, final String reason) {
-   * @guarded.By latestViewLock
-      long shunTime = ((Long)shunnedMembers.get(m)).longValue();
+      long shunTime = shunnedMembers.get(m).longValue();
-  private final boolean isShunnedOrNew(final InternalDistributedMember m) {
+  private boolean isShunnedOrNew(final InternalDistributedMember m) {
-  private final boolean isNew(final InternalDistributedMember m) {
+  private boolean isNew(final InternalDistributedMember m) {
-        long birthTime = ((Long)surpriseMembers.get(m)).longValue();
+        long birthTime = surpriseMembers.get(m).longValue();
-  protected void addShunnedMember(InternalDistributedMember m) {
+ private void addShunnedMember(InternalDistributedMember m) {
-    Set oldMembers = new HashSet(shunnedMembers.entrySet());
+    Set<Map.Entry<DistributedMember, Long>> oldMembers = new HashSet<>(shunnedMembers.entrySet());
-    Set removedMembers = new HashSet();
-    
-    Iterator it = oldMembers.iterator();
-    while (it.hasNext()) {
-      Map.Entry e = (Map.Entry)it.next();
-      
-      // Key is the member.  Value is the time to remove it.
-      long ll = ((Long)e.getValue()).longValue(); 
-      if (ll >= deathTime) {
-        continue; // too new.
-      }
-      
-      InternalDistributedMember mm = (InternalDistributedMember)e.getKey();
+    Set<DistributedMember> removedMembers = new HashSet<>();
-      if (latestView.contains(mm)) {
-        // Fault tolerance: a shunned member can conceivably linger but never 
-        // disconnect.
-        //
-        // We may not delete it at the time that we shun it because the view 
-        // isn't necessarily stable.  (Note that a well-behaved cache member
-        // will depart on its own accord, but we force the issue here.)
-        destroyMember(mm, true, "shunned but never disconnected");
-      }
-      if (logger.isDebugEnabled()) {
-        logger.debug("Membership: finally removed shunned member entry <{}>", mm);
-      }
-      
-      removedMembers.add(mm);
-    }
+   for (final Object oldMember : oldMembers) {
+     Entry e = (Entry) oldMember;
+
+     // Key is the member.  Value is the time to remove it.
+     long ll = ((Long) e.getValue()).longValue();
+     if (ll >= deathTime) {
+       continue; // too new.
+     }
+
+     InternalDistributedMember mm = (InternalDistributedMember) e.getKey();
+
+     if (latestView.contains(mm)) {
+       // Fault tolerance: a shunned member can conceivably linger but never 
+       // disconnect.
+       //
+       // We may not delete it at the time that we shun it because the view 
+       // isn't necessarily stable.  (Note that a well-behaved cache member
+       // will depart on its own accord, but we force the issue here.)
+       destroyMember(mm, "shunned but never disconnected");
+     }
+     if (logger.isDebugEnabled()) {
+       logger.debug("Membership: finally removed shunned member entry <{}>", mm);
+     }
+
+     removedMembers.add(mm);
+   }
-      it = removedMembers.iterator();
-      while (it.hasNext()) {
-        InternalDistributedMember idm = (InternalDistributedMember)it.next();
+      for (final Object removedMember : removedMembers) {
+        InternalDistributedMember idm = (InternalDistributedMember) removedMember;
-   * Retrieve thread-local data for transport to another thread in hydra
-   */
-  public Object getThreadLocalData() {
-    Map result = new HashMap();
-    return result;
-  }
-  
-  /**
-            while (done[0] == false) {
+            while (!done[0]) {
-      else if ((currentLatch = (CountDownLatch)this.memberLatch.get(remoteId)) == null) {
+      else if ((currentLatch = this.memberLatch.get(remoteId)) == null) {
-  boolean beingSick;
-  boolean playingDead;
+  private boolean beingSick;
+  private boolean playingDead;
-   * @param b
-    inhibitForceDisconnectLogging = true;
+    inhibitForceDisconnectLogging = b;
-    boolean[] done;
+    final boolean[] done;
-  /**
-   * Sets cache time offset in {@link DistributionManager}.
-   * 
-   * @param coord
-   * @param timeOffset
-   * @see InternalDistributedSystem#getClock()
-   * @see DSClock#setCacheTimeOffset(DistributedMember, long, boolean)
-   */
-  public void setCacheTimeOffset(InternalDistributedMember coord, long timeOffset, boolean isJoin) {
-    if (this.listener != null) {
-      DistributionManager dm = this.listener.getDM();
-      dm.getSystem().getClock().setCacheTimeOffset(coord, timeOffset, isJoin);
-    }
-  }
-  
-    Thread reconnectThread = new Thread (new Runnable() {
-      public void run() {
-        // stop server locators immediately since they may not have correct
-        // information.  This has caused client failures in bridge/wan
-        // network-down testing
-        InternalLocator loc = (InternalLocator)Locator.getLocator();
-        if (loc != null) {
-          loc.stop(true, !services.getConfig().getDistributionConfig()
-              .getDisableAutoReconnect(), false);
-        }
-
-        uncleanShutdown(reason, shutdownCause);
+    Thread reconnectThread = new Thread (() -> {
+      // stop server locators immediately since they may not have correct
+      // information.  This has caused client failures in bridge/wan
+      // network-down testing
+      InternalLocator loc = (InternalLocator)Locator.getLocator();
+      if (loc != null) {
+        loc.stop(true, !services.getConfig().getDistributionConfig()
+            .getDisableAutoReconnect(), false);
+
+      uncleanShutdown(reason, shutdownCause);
-  static class BoundedLinkedHashMap extends LinkedHashMap
+  static class BoundedLinkedHashMap<K,V> extends LinkedHashMap
-     * The maximum number of entries allowed in this
-     * <code>BoundedLinkedHashMap</code>
-     */
-    protected int _maximumNumberOfEntries;
-
-    /**
-     * @param maximumNumberOfEntries The maximum number of allowed entries
-    public BoundedLinkedHashMap(int maximumNumberOfEntries) {
+    public BoundedLinkedHashMap() {
-      this._maximumNumberOfEntries = maximumNumberOfEntries;
-    protected boolean removeEldestEntry(Map.Entry entry) {
-      return size() > this._maximumNumberOfEntries;
+    protected boolean removeEldestEntry(Map.Entry eldest) {
+      return size() > 1000;

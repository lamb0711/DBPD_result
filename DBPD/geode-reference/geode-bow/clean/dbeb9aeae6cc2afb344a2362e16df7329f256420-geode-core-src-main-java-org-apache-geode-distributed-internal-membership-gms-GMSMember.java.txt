Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-
+import java.io.EOFException;
- * Unfortunately, this class serves two distinct functions.  First, it is the
- * fundamental element of membership in the GemFire distributed system.  As such,
- * it is used in enumerations and properly responds to hashing and equals() comparisons.
+ * Unfortunately, this class serves two distinct functions. First, it is the fundamental element of
+ * membership in the GemFire distributed system. As such, it is used in enumerations and properly
+ * responds to hashing and equals() comparisons.
- * Second, it is used as a cheap way of representing an address.  This is
- * unfortunate, because as a NetMember, it holds two separate port numbers: the
- * "membership" descriptor as well as a direct communication channel.
+ * Second, it is used as a cheap way of representing an address. This is unfortunate, because as a
+ * NetMember, it holds two separate port numbers: the "membership" descriptor as well as a direct
+ * communication channel.
-  private final static boolean SHOW_UUIDS = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "show_UUIDs");
-  
-  private int udpPort=0;
+  private final static boolean SHOW_UUIDS =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "show_UUIDs");
+
+  private int udpPort = 0;
-  private int vmKind;
+  private byte vmKind;
-  private short versionOrdinal;
+  private short versionOrdinal = Version.CURRENT_ORDINAL;
-  
-  
-  
+
+
+
-  public GMSMember() {
-  }
-  
+  public GMSMember() {}
+
-    return new MemberAttributes(directPort, processId,
-        vmKind, vmViewId, name, groups,
+    return new MemberAttributes(directPort, processId, vmKind, vmViewId, name, groups,
-    vmKind = attr.getVmKind();
+    vmKind = (byte) attr.getVmKind();
-  
+
-   * Create a CacheMember referring to the current host (as defined by
-   * the given string).
+   * Create a CacheMember referring to the current host (as defined by the given string).
-    udpPort=p;
+    udpPort = p;
-      inetAddr=InetAddress.getByName(i);
+      inetAddr = InetAddress.getByName(i);
-   * Create a CacheMember referring to the current host (as defined by
-   * the given string).
+   * Create a CacheMember referring to the current host (as defined by the given string).
-   * @param networkPartitionDetectionEnabled whether the member has network partition detection enabled
+   * @param networkPartitionDetectionEnabled whether the member has network partition detection
+   *        enabled
-  public GMSMember(MemberAttributes attr, InetAddress i, int p, boolean networkPartitionDetectionEnabled, boolean preferredForCoordinator,
-                   short version,
-                   long msbs, long lsbs) {
+  public GMSMember(MemberAttributes attr, InetAddress i, int p,
+      boolean networkPartitionDetectionEnabled, boolean preferredForCoordinator, short version,
+      long msbs, long lsbs) {
-    this.udpPort=p;
+    this.udpPort = p;
-  
-  public GMSMember(InetAddress i, int p, short version,
-      long msbs, long lsbs, int viewId) {
+
+  public GMSMember(InetAddress i, int p, short version, long msbs, long lsbs, int viewId) {
-    return false;  //ipAddr.isMulticastAddress();
+    return false; // ipAddr.isMulticastAddress();
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-   * return the jgroups logical address for this member,
-   * if it's been established
+   * return the jgroups logical address for this member, if it's been established
-  
+
-  
+
+   * 
+   * 
-   * @return a negative integer, zero, or a positive integer as this object is less than,
-   *         equal to, or greater than the specified object.
-   * @exception java.lang.ClassCastException - if the specified object's type prevents it
-   *            from being compared to this Object.
+   * 
+   * @return a negative integer, zero, or a positive integer as this object is less than, equal to,
+   * or greater than the specified object.
+   * 
+   * @exception java.lang.ClassCastException - if the specified object's type prevents it from being
+   * compared to this Object.
-    if (o == null || !(o instanceof GMSMember) ) {
-      throw new ClassCastException(LocalizedStrings.Member_MEMBERCOMPARETO_COMPARISON_BETWEEN_DIFFERENT_CLASSES.toLocalizedString());
+    if (o == null || !(o instanceof GMSMember)) {
+      throw new ClassCastException(
+          LocalizedStrings.Member_MEMBERCOMPARETO_COMPARISON_BETWEEN_DIFFERENT_CLASSES
+              .toLocalizedString());
-    GMSMember his = (GMSMember)o;
+    GMSMember his = (GMSMember) o;
-      for (int idx=0; idx < myAddr.length; idx++) {
+      for (int idx = 0; idx < myAddr.length; idx++) {
-      //After checking both addresses we have only gone up to myAddr.length, their address could be longer
+      // After checking both addresses we have only gone up to myAddr.length, their address could be
+      // longer
-    if (udpPort < his.udpPort) return -1;
-    if (his.udpPort < udpPort) return 1;
+    if (udpPort < his.udpPort)
+      return -1;
+    if (his.udpPort < udpPort)
+      return 1;
-    if (result == 0 && this.uuidMSBs != 0 && his.uuidMSBs != 0) { 
+    if (result == 0 && this.uuidMSBs != 0 && his.uuidMSBs != 0) {
+      if (this.uuidMSBs < his.uuidMSBs) {
+        result = -1;
+      } else if (his.uuidMSBs < this.uuidMSBs) {
+        result = 1;
+      } else if (this.uuidLSBs < his.uuidLSBs) {
+        result = -1;
+      } else if (his.uuidLSBs < this.uuidLSBs) {
+        result = 1;
+      }
+    }
+    return result;
+  }
+
+  @Override
+  public int compareAdditionalData(NetMember other) {
+    GMSMember his = (GMSMember) other;
+    int result = 0;
+    if (this.uuidMSBs != 0 && his.uuidMSBs != 0) {
-    return compareTo((GMSMember)obj) == 0;
+    return compareTo((GMSMember) obj) == 0;
-    String uuid = SHOW_UUIDS? (";uuid=" + getUUID().toStringLong()) 
-        : ((this.uuidLSBs == 0 && this.uuidMSBs == 0)? "; no uuid" : "; uuid set");
+    String uuid = SHOW_UUIDS ? (";uuid=" + getUUID().toStringLong())
+        : ((this.uuidLSBs == 0 && this.uuidMSBs == 0) ? "; no uuid" : "; uuid set");
-      .append(";processId=").append(processId).append(";name=").append(name)
-      .append(uuid)
-      .append("]");
+        .append(";processId=").append(processId).append(";name=").append(name).append(uuid)
+        .append("]");
-  
+
-  public int getVmKind() {
+  public byte getVmKind() {
+  @Override
+  public void setVmViewId(int id) {
+    this.vmViewId = id;
+  }
+
-    this.vmKind = vmKind;
+    this.vmKind = (byte) vmKind;
-  
+
-  public void setDurableClientAttributes(
-      DurableClientAttributes durableClientAttributes) {
+  public void setDurableClientAttributes(DurableClientAttributes durableClientAttributes) {
+  @Override
+  public String[] getGroups() {
+    return groups;
+  }
+
-  
+
-   * checks to see if this address has UUID information needed
-   * to send messages via JGroups
+   * checks to see if this address has UUID information needed to send messages via JGroups
-  
+
-    
+
-}
-  
+  }
+
-    
+
-    if (networkPartitionDetectionEnabled) flags |= NPD_ENABLED_BIT;
-    if (preferredForCoordinator) flags |= PREFERRED_FOR_COORD_BIT;
+    if (networkPartitionDetectionEnabled)
+      flags |= NPD_ENABLED_BIT;
+    if (preferredForCoordinator)
+      flags |= PREFERRED_FOR_COORD_BIT;
-    
+
-    
+
-  } 
-  
+  }
+
-    
+
-    
+
-    this.uuidLSBs = in.readLong();    
+    this.uuidLSBs = in.readLong();
+  }
+
+  @Override
+  public boolean hasAdditionalData() {
+    return uuidMSBs != 0 || uuidLSBs != 0 || memberWeight != 0;
-  public void readAdditionalData(DataInput in) throws ClassNotFoundException,
-      IOException {
-    this.uuidMSBs = in.readLong();
-    this.uuidLSBs = in.readLong();
-    memberWeight = (byte)(in.readByte() & 0xFF);
+  public void readAdditionalData(DataInput in) throws ClassNotFoundException, IOException {
+    try {
+      this.uuidMSBs = in.readLong();
+      this.uuidLSBs = in.readLong();
+      memberWeight = (byte) (in.readByte() & 0xFF);
+    } catch (EOFException e) {
+      // some IDs do not have UUID or membership weight information
+    }

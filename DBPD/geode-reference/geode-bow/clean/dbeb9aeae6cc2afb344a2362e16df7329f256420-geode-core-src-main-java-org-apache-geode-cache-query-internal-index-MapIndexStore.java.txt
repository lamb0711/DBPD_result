Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import org.apache.geode.cache.EntryDestroyedException;
-import org.apache.geode.internal.cache.RegionEntryContext;
-import org.apache.geode.internal.cache.Token;
-import org.apache.geode.internal.cache.LocalRegion.NonTXEntry;
-  
+
-  
+
-  
+
-  public CloseableIterator<IndexStoreEntry> iterator(Object start,
-      boolean startInclusive, Object end, boolean endInclusive) {
+  public CloseableIterator<IndexStoreEntry> iterator(Object start, boolean startInclusive,
+      Object end, boolean endInclusive) {
-  
-  public CloseableIterator<IndexStoreEntry> iterator(Object start,
-      boolean startInclusive, Object end, boolean endInclusive,
-      Collection keysToRemove) {
-    //REMOVE THESE CHECKS ONCE nulls are supported
-    //These checks will help us get past a certain number of tests but not all of them
-    //order by and what not will still probably fail
+
+  public CloseableIterator<IndexStoreEntry> iterator(Object start, boolean startInclusive,
+      Object end, boolean endInclusive, Collection keysToRemove) {
+    // REMOVE THESE CHECKS ONCE nulls are supported
+    // These checks will help us get past a certain number of tests but not all of them
+    // order by and what not will still probably fail
-    }
-    else if (end == null) {
+    } else if (end == null) {
-    return new MapIndexStoreIterator(indexMap.iterator(start, startInclusive, end, endInclusive), keysToRemove, indexOnValues, indexOnRegionKeys);
+    return new MapIndexStoreIterator(indexMap.iterator(start, startInclusive, end, endInclusive),
+        keysToRemove, indexOnValues, indexOnRegionKeys);
-  public CloseableIterator<IndexStoreEntry> iterator(Object start,
-      boolean startInclusive) {
-    return iterator(start, startInclusive, null); 
+  public CloseableIterator<IndexStoreEntry> iterator(Object start, boolean startInclusive) {
+    return iterator(start, startInclusive, null);
-  
-  public CloseableIterator<IndexStoreEntry> iterator(Object start,
-      boolean startInclusive, Collection keysToRemove) {
-    return new MapIndexStoreIterator(indexMap.iterator(start, startInclusive), keysToRemove, indexOnValues, indexOnRegionKeys);
+
+  public CloseableIterator<IndexStoreEntry> iterator(Object start, boolean startInclusive,
+      Collection keysToRemove) {
+    return new MapIndexStoreIterator(indexMap.iterator(start, startInclusive), keysToRemove,
+        indexOnValues, indexOnRegionKeys);
-    return new MapIndexStoreIterator(indexMap.iterator(), keysToRemove, indexOnValues, indexOnRegionKeys);
+    return new MapIndexStoreIterator(indexMap.iterator(), keysToRemove, indexOnValues,
+        indexOnRegionKeys);
-  public CloseableIterator<IndexStoreEntry> descendingIterator(Object end,
-      boolean endInclusive) {
+  public CloseableIterator<IndexStoreEntry> descendingIterator(Object end, boolean endInclusive) {
-  public CloseableIterator<IndexStoreEntry> descendingIterator(Object end,
-      boolean endInclusive, Collection keysToRemove) {
-    return new MapIndexStoreIterator(indexMap.descendingIterator(end, endInclusive), keysToRemove, indexOnValues, indexOnRegionKeys);
+  public CloseableIterator<IndexStoreEntry> descendingIterator(Object end, boolean endInclusive,
+      Collection keysToRemove) {
+    return new MapIndexStoreIterator(indexMap.descendingIterator(end, endInclusive), keysToRemove,
+        indexOnValues, indexOnRegionKeys);
-  public CloseableIterator<IndexStoreEntry> descendingIterator(
-      Collection keysToRemove) {
-   return new MapIndexStoreIterator(indexMap.descendingIterator(), keysToRemove, indexOnValues, indexOnRegionKeys);
+  public CloseableIterator<IndexStoreEntry> descendingIterator(Collection keysToRemove) {
+    return new MapIndexStoreIterator(indexMap.descendingIterator(), keysToRemove, indexOnValues,
+        indexOnRegionKeys);
-  public CloseableIterator<IndexStoreEntry> descendingIterator(Object start,
-      boolean startInclusive, Object end, boolean endInclusive,
-      Collection keysToRemove) {
-    //@todo change to descending once it is supported
-    return new MapIndexStoreIterator(indexMap.iterator(start, startInclusive, end, endInclusive), keysToRemove, indexOnValues, indexOnRegionKeys);
+  public CloseableIterator<IndexStoreEntry> descendingIterator(Object start, boolean startInclusive,
+      Object end, boolean endInclusive, Collection keysToRemove) {
+    // @todo change to descending once it is supported
+    return new MapIndexStoreIterator(indexMap.iterator(start, startInclusive, end, endInclusive),
+        keysToRemove, indexOnValues, indexOnRegionKeys);
-    return 1;//(int)this.indexMap.size();
+    return 1;// (int)this.indexMap.size();
-  
+
-    //return Long.valueOf(indexMap.size(key, key)).intValue();
+    // return Long.valueOf(indexMap.size(key, key)).intValue();
-  
+
-          return ((CachedDeserializable) o).getDeserializedValue(
-              region, entry);
+        return ((CachedDeserializable) o).getDeserializedValue(region, entry);
-          return ((CachedDeserializable) o).getDeserializedValue(
-              region, entry);
+        return ((CachedDeserializable) o).getDeserializedValue(region, entry);
-   * Wraps a CloseableIterator<IndexMap.IndexEntry> and returns a IndexStorageEntry when iterating over
+   * Wraps a CloseableIterator<IndexMap.IndexEntry> and returns a IndexStorageEntry when iterating
+   * over
-    
-    private MapIndexStoreIterator(CloseableIterator<IndexMap.IndexEntry> iterator, Collection keysToRemove, boolean indexOnValues, boolean indexOnRegionKeys) {
+
+    private MapIndexStoreIterator(CloseableIterator<IndexMap.IndexEntry> iterator,
+        Collection keysToRemove, boolean indexOnValues, boolean indexOnRegionKeys) {
-    
-    private MapIndexStoreIterator(CloseableIterator<IndexMap.IndexEntry> iterator, boolean indexOnValues, boolean indexOnRegionKeys) {
+
+    private MapIndexStoreIterator(CloseableIterator<IndexMap.IndexEntry> iterator,
+        boolean indexOnValues, boolean indexOnRegionKeys) {
-    
+
-              if (TypeUtils
-                  .compare(nextEntry.getDeserializedValue(), keysToRemoveIterator.next(), OQLLexerTokenTypes.TOK_EQ).equals(
-                      Boolean.TRUE)) {
+              if (TypeUtils.compare(nextEntry.getDeserializedValue(), keysToRemoveIterator.next(),
+                  OQLLexerTokenTypes.TOK_EQ).equals(Boolean.TRUE)) {
-    /** 
+    /**
-      //we set this again so that we know that has next needs to be called before the next call
-      //hasNext will unset it.  This forces us to call hasNext automatically if the user does not
-      needToCallHasNext = true;       
+      // we set this again so that we know that has next needs to be called before the next call
+      // hasNext will unset it. This forces us to call hasNext automatically if the user does not
+      needToCallHasNext = true;
-  
-  
+
+
-    
+
-     * sets the IndexEntry 
+     * sets the IndexEntry
-    
+
-    //Since we are not storing the actual value in the index, we need to 
-    //retreive the value from the region
+    // Since we are not storing the actual value in the index, we need to
+    // retreive the value from the region
-      }
-      else if (indexOnRegionKeys){
+      } else if (indexOnRegionKeys) {
-      }
-      else {
-        return new EntrySet(getDeserializedRegionKey(), region.get(entry.getRegionKey().getDeserializedForReading()));
+      } else {
+        return new EntrySet(getDeserializedRegionKey(),
+            region.get(entry.getRegionKey().getDeserializedForReading()));
-        return entry.getRegionKey().getDeserializedForReading();
+      return entry.getRegionKey().getDeserializedForReading();
-    
+
-  
-  //wrapper class for when the index is being queried with a map query
+
+  // wrapper class for when the index is being queried with a map query
+
-    
+
-    
+

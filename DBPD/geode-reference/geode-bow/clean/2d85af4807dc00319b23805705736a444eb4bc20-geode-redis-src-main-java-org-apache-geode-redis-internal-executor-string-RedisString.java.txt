GEODE-8166: reimplement redis expiration to use new data model (#5174)

* Added timestamp field to RedisData and implemented serialization and delta for it.
Both active and passive expiration have been implemented.

* RedisHash, RedisSet, and RedisString now subclass AbstractRedisData
* type command now uses function
* getset, incr, decr, incrby, and decrby now uses function and is atomic

-import org.apache.geode.DataSerializable;
-import org.apache.geode.InvalidDeltaException;
+import org.apache.geode.redis.internal.AbstractRedisData;
+import org.apache.geode.redis.internal.AppendDeltaInfo;
+import org.apache.geode.redis.internal.Coder;
+import org.apache.geode.redis.internal.DeltaInfo;
+import org.apache.geode.redis.internal.RedisConstants;
-public class RedisString implements DataSerializable, RedisData {
+public class RedisString extends AbstractRedisData {
-  private transient ByteArrayWrapper delta;
-
-    delta = appendValue;
-    region.put(key, this);
+    storeChanges(region, key, new AppendDeltaInfo(appendValue.toBytes()));
+  public long incr(Region<ByteArrayWrapper, RedisData> region, ByteArrayWrapper key)
+      throws NumberFormatException, ArithmeticException {
+    long longValue = parseValueAsLong();
+    if (longValue == Long.MAX_VALUE) {
+      throw new ArithmeticException(RedisConstants.ERROR_OVERFLOW);
+    }
+    longValue++;
+    String stringValue = Long.toString(longValue);
+    value.setBytes(Coder.stringToBytes(stringValue));
+    // numeric strings are short so no need to use delta
+    region.put(key, this);
+    return longValue;
+  }
+
+  public long incrby(Region<ByteArrayWrapper, RedisData> region, ByteArrayWrapper key,
+      long increment)
+      throws NumberFormatException, ArithmeticException {
+    long longValue = parseValueAsLong();
+    if (longValue >= 0 && increment > (Long.MAX_VALUE - longValue)) {
+      throw new ArithmeticException(RedisConstants.ERROR_OVERFLOW);
+    }
+    longValue += increment;
+    String stringValue = Long.toString(longValue);
+    value.setBytes(Coder.stringToBytes(stringValue));
+    // numeric strings are short so no need to use delta
+    region.put(key, this);
+    return longValue;
+  }
+
+  public long decrby(Region<ByteArrayWrapper, RedisData> region, ByteArrayWrapper key,
+      long decrement) {
+    long longValue = parseValueAsLong();
+    if (longValue <= 0 && -decrement < (Long.MIN_VALUE - longValue)) {
+      throw new ArithmeticException(RedisConstants.ERROR_OVERFLOW);
+    }
+    longValue -= decrement;
+    String stringValue = Long.toString(longValue);
+    value.setBytes(Coder.stringToBytes(stringValue));
+    // numeric strings are short so no need to use delta
+    region.put(key, this);
+    return longValue;
+  }
+
+  public long decr(Region<ByteArrayWrapper, RedisData> region, ByteArrayWrapper key)
+      throws NumberFormatException, ArithmeticException {
+    long longValue = parseValueAsLong();
+    if (longValue == Long.MIN_VALUE) {
+      throw new ArithmeticException(RedisConstants.ERROR_OVERFLOW);
+    }
+    longValue--;
+    String stringValue = Long.toString(longValue);
+    value.setBytes(Coder.stringToBytes(stringValue));
+    // numeric strings are short so no need to use delta
+    region.put(key, this);
+    return longValue;
+  }
+
+  private long parseValueAsLong() {
+    try {
+      return Long.parseLong(value.toString());
+    } catch (NumberFormatException ex) {
+      throw new NumberFormatException(RedisConstants.ERROR_NOT_INTEGER);
+    }
+  }
+
+    super.toData(out);
-  public void fromData(DataInput in) throws IOException {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
+    super.fromData(in);
+  protected void applyDelta(DeltaInfo deltaInfo) {
+    AppendDeltaInfo appendDeltaInfo = (AppendDeltaInfo) deltaInfo;
+    byte[] appendBytes = appendDeltaInfo.getBytes();
+    if (value == null) {
+      value = new ByteArrayWrapper(appendBytes);
+    } else {
+      value.append(appendBytes);
+    }
+  }
+
+  @Override
-  public boolean hasDelta() {
-    return delta != null;
-  }
-
-  @Override
-  public void toDelta(DataOutput out) throws IOException {
-    try {
-      DataSerializer.writeByteArray(delta.toBytes(), out);
-    } finally {
-      delta = null;
-    }
-  }
-
-  @Override
-  public void fromDelta(DataInput in) throws IOException, InvalidDeltaException {
-    try {
-      byte[] deltaBytes = DataSerializer.readByteArray(in);
-      if (value == null) {
-        value = new ByteArrayWrapper(deltaBytes);
-      } else {
-        value.append(deltaBytes);
-      }
-    } catch (Exception e) {
-      throw new RuntimeException(e);
-    }
+  protected boolean removeFromRegion() {
+    return false;

Initial import of geode-1.0.0.0-SNAPSHOT-2.
All the new sub-project directories (like jvsd) were not imported.
A diff was done to confirm that this commit is exactly the same as
the open directory the snapshot was made from.

+import com.gemstone.gemfire.internal.cache.EntryEventImpl.OldValueImporter;
+import com.gemstone.gemfire.internal.offheap.StoredObject;
+import com.gemstone.gemfire.internal.offheap.annotations.Unretained;
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_OLD_VALUE;
+import static com.gemstone.gemfire.internal.cache.DistributedCacheOperation.VALUE_IS_BYTES;
+import static com.gemstone.gemfire.internal.cache.DistributedCacheOperation.VALUE_IS_SERIALIZED_OBJECT;
+import static com.gemstone.gemfire.internal.cache.DistributedCacheOperation.VALUE_IS_OBJECT;
-public class RemoteDestroyMessage extends RemoteOperationMessageWithDirectReply {
+public class RemoteDestroyMessage extends RemoteOperationMessageWithDirectReply implements OldValueImporter {
+  @Unretained(ENTRY_EVENT_OLD_VALUE)
-      CachedDeserializable cd = (CachedDeserializable) event.getSerializedOldValue();
-      if (cd != null) {
-        {
-          this.oldValueIsSerialized = true;
-          Object o = cd.getValue();
-          if (o instanceof byte[]) {
-            setOldValBytes((byte[])o);
-          } else {
-            // Defer serialization until toData is called.
-            setOldValObj(o);
-          }
-        }
-      } else {
-        Object old = event.getRawOldValue();
-        if (old instanceof byte[]) {
-          this.oldValueIsSerialized = false;
-          setOldValBytes((byte[]) old);
-        } else {
-          this.oldValueIsSerialized = true;
-          setOldValObj(old);
-        }
-      }
+      event.exportOldValue(this);
-  
-  private void setOldValObj(Object o){
+
+  private final void setOldValObj(@Unretained(ENTRY_EVENT_OLD_VALUE) Object o) {
-        {
+        if (cd instanceof StoredObject && !((StoredObject) cd).isSerialized()) {
+          // it is a byte[]
+          this.oldValueIsSerialized = false;
+          setOldValBytes((byte[]) ((StoredObject) cd).getDeserializedForReading());
+        } else {
+    m.setTransactionDistributed(r.getCache().getTxManager().isDistributed());
+    try {
-      event = new EntryEventImpl(r, getOperation(), getKey(), null/*newValue*/,
+      event = EntryEventImpl.create(r, getOperation(), getKey(), null/*newValue*/,
-      event = new EntryEventImpl(
+      event = EntryEventImpl.create(
+    } finally {
+      if (event != null) {
+        event.release();
+      }
+    }
-      //out.writeBoolean(this.hasOldValue);
-      // below boolean is not strictly required, but this is for compatibility
-      // with SQLFire code which writes as byte here to indicate whether
-      // oldValue is an object, serialized object or byte[]
-      if (getOldValueBytes() != null) {
-        DataSerializer.writeByteArray(getOldValueBytes(), out);
-      } else {
-        DataSerializer.writeObjectAsByteArray(getOldValObj(), out);
-      }
+      byte policy = DistributedCacheOperation.valueIsToDeserializationPolicy(oldValueIsSerialized);
+      DistributedCacheOperation.writeValue(policy, getOldValObj(), getOldValueBytes(), out);
+  @Override
+  public boolean prefersOldSerialized() {
+    return true;
+  }
+
+  @Override
+  public boolean isUnretainedOldReferenceOk() {
+    return true;
+  }
+
+  @Override
+  public boolean isCachedDeserializableValueOk() {
+    return false;
+  }
+  
+  private void setOldValueIsSerialized(boolean isSerialized) {
+    if (isSerialized) {
+      if (CachedDeserializableFactory.preferObject()) {
+        this.oldValueIsSerialized = true; //VALUE_IS_OBJECT;
+      } else {
+        // Defer serialization until toData is called.
+        this.oldValueIsSerialized = true; //VALUE_IS_SERIALIZED_OBJECT;
+      }
+    } else {
+      this.oldValueIsSerialized = false; //VALUE_IS_BYTES;
+    }
+  }
+  
+  @Override
+  public void importOldObject(@Unretained(ENTRY_EVENT_OLD_VALUE) Object ov, boolean isSerialized) {
+    setOldValueIsSerialized(isSerialized);
+    // Defer serialization until toData is called.
+    setOldValObj(ov);
+  }
+
+  @Override
+  public void importOldBytes(byte[] ov, boolean isSerialized) {
+    setOldValueIsSerialized(isSerialized);
+    setOldValBytes(ov);
+  }
+

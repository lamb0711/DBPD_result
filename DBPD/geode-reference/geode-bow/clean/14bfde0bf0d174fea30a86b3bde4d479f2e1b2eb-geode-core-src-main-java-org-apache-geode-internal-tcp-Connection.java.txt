Merge branch 'release/1.8.0'

-import org.apache.geode.i18n.StringId;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.LoggingThreadGroup;
+import org.apache.geode.internal.logging.LoggingThread;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
-          logger.info(LocalizedMessage.create(
-              LocalizedStrings.Connection_SOCKET_0_IS_1_INSTEAD_OF_THE_REQUESTED_2,
-              new Object[] {(send ? "send buffer size" : "receive buffer size"),
-                  Integer.valueOf(actualSize), Integer.valueOf(requestedSize)}));
+          logger.info("Socket {} is {} instead of the requested {}.",
+              (send ? "send buffer size" : "receive buffer size"),
+              Integer.valueOf(actualSize), Integer.valueOf(requestedSize));
-            LocalizedStrings.Connection_COULD_NOT_START_READER_THREAD.toLocalizedString());
+            "could not start reader thread");
-          LocalizedStrings.Connection_NULL_CONNECTIONTABLE.toLocalizedString());
+          "Null ConnectionTable");
-        logger.fatal(LocalizedMessage
-            .create(LocalizedStrings.Connection_UNABLE_TO_GET_P2P_CONNECTION_STREAMS), io);
+        logger.fatal("Unable to get P2P connection streams", io);
-            LocalizedStrings.Connection_IDLE_CONNECTION_TIMED_OUT.toLocalizedString());
+            "idle connection timed out");
-      throw new IllegalStateException(LocalizedStrings.Connection_TCP_MESSAGE_EXCEEDED_MAX_SIZE_OF_0
-          .toLocalizedString(Integer.valueOf(MAX_MSG_SIZE)));
+      throw new IllegalStateException(String.format("tcp message exceeded max size of %s",
+          Integer.valueOf(MAX_MSG_SIZE)));
-          LocalizedStrings.Connection_DETECTED_WRONG_VERSION_OF_GEMFIRE_PRODUCT_DURING_HANDSHAKE_EXPECTED_0_BUT_FOUND_1
-              .toLocalizedString(new Object[] {new Byte(HANDSHAKE_VERSION), new Byte(ver)}));
+          String.format(
+              "Detected wrong version of GemFire product during handshake. Expected %s but found %s",
+              new Object[] {new Byte(HANDSHAKE_VERSION), new Byte(ver)}));
-          reason = LocalizedStrings.Connection_UNKNOWN.toLocalizedString();
+          reason = "unknown";
-              reason = LocalizedStrings.Connection_HANDSHAKE_TIMED_OUT.toLocalizedString();
+              reason = "handshake timed out";
-                    LocalizedStrings.Connection_CONNECTION_HANDSHAKE_WITH_0_TIMED_OUT_AFTER_WAITING_1_MILLISECONDS
-                        .toLocalizedString(
-                            new Object[] {peerName, Integer.valueOf(HANDSHAKE_TIMEOUT_MS)}));
+                    String.format(
+                        "Connection handshake with %s timed out after waiting %s milliseconds.",
+
+                        peerName, Integer.valueOf(HANDSHAKE_TIMEOUT_MS)));
-                  LocalizedStrings.Connection_CONNECTION_HANDSHAKE_WITH_0_TIMED_OUT_AFTER_WAITING_1_MILLISECONDS
-                      .toLocalizedString(
-                          new Object[] {peerName, Integer.valueOf(HANDSHAKE_TIMEOUT_MS)}));
+                  String.format(
+                      "Connection handshake with %s timed out after waiting %s milliseconds.",
+                      peerName, Integer.valueOf(HANDSHAKE_TIMEOUT_MS)));
-            reason = LocalizedStrings.Connection_INTERRUPTED.toLocalizedString();
+            reason = "interrupted";
-              logger.fatal(LocalizedMessage.create(
-                  LocalizedStrings.Connection_UNABLE_TO_FORM_A_TCPIP_CONNECTION_TO_0_IN_OVER_1_SECONDS,
-                  new Object[] {remoteAddr, (ackSATimeout + ackTimeout) / 1000}));
+              logger.fatal("Unable to form a TCP/IP connection to {} in over {} seconds",
+                  remoteAddr, (ackSATimeout + ackTimeout) / 1000);
-              logger.warn(LocalizedMessage.create(
-                  LocalizedStrings.Connection_UNABLE_TO_FORM_A_TCPIP_CONNECTION_TO_0_IN_OVER_1_SECONDS,
-                  new Object[] {remoteAddr, (ackTimeout) / 1000}));
+              logger.warn("Unable to form a TCP/IP connection to {} in over {} seconds",
+                  remoteAddr, (ackTimeout) / 1000);
-                LocalizedStrings.Connection_UNABLE_TO_FORM_A_TCPIP_CONNECTION_IN_A_REASONABLE_AMOUNT_OF_TIME
-                    .toLocalizedString());
+                "Unable to form a TCP/IP connection in a reasonable amount of time");
-              LocalizedStrings.Connection_UNABLE_TO_FORM_A_TCPIP_CONNECTION_IN_A_REASONABLE_AMOUNT_OF_TIME
-                  .toLocalizedString());
+              "Unable to form a TCP/IP connection in a reasonable amount of time");
-                LocalizedStrings.Connection_MEMBER_LEFT_THE_GROUP.toLocalizedString(remoteAddr));
+                String.format("Member %s left the group", remoteAddr));
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.Connection_CONNECTION_ATTEMPTING_RECONNECT_TO_PEER__0,
-                remoteAddr));
+            logger.warn("Connection: Attempting reconnect to peer {}",
+                remoteAddr);
-            logger.info(LocalizedMessage.create(
-                LocalizedStrings.Connection_CONNECTION_FAILED_TO_CONNECT_TO_PEER_0_BECAUSE_1,
-                new Object[] {sharedResource, preserveOrder, remoteAddr, ioe}));
+            logger.info("Connection: shared={} ordered={} failed to connect to peer {} because: {}",
+                sharedResource, preserveOrder, remoteAddr, ioe);
-              // and the socket was closed or this guy sent us a
+              // and the socket was closed or we were sent
-                throw new IOException(LocalizedStrings.Connection_MEMBER_LEFT_THE_GROUP
-                    .toLocalizedString(remoteAddr));
+                throw new IOException(String.format("Member %s left the group",
+                    remoteAddr));
-                  new IOException(LocalizedStrings.Connection_HANDSHAKE_FAILED.toLocalizedString());
+                  new IOException("Handshake failed");
-            logger.info(LocalizedMessage.create(
-                LocalizedStrings.Connection_CONNECTION_HANDSHAKE_FAILED_TO_CONNECT_TO_PEER_0_BECAUSE_1,
-                new Object[] {sharedResource, preserveOrder, remoteAddr, e}));
+            logger.info(
+                "Connection: shared={} ordered={} handshake failed to connect to peer {} because: {}",
+                sharedResource, preserveOrder, remoteAddr, e);
-            logger.info(LocalizedMessage.create(
-                LocalizedStrings.Connection_CONNECTION_HANDSHAKE_FAILED_TO_CONNECT_TO_PEER_0_BECAUSE_1,
-                new Object[] {sharedResource, preserveOrder, remoteAddr, e}));
+            logger.info(
+                "Connection: shared={} ordered={} handshake failed to connect to peer {} because: {}",
+                sharedResource, preserveOrder, remoteAddr, e);
-                conn.requestClose(LocalizedStrings.Connection_FAILED_HANDSHAKE.toLocalizedString());
+                conn.requestClose("failed handshake");
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.Connection_0_SUCCESSFULLY_REESTABLISHED_CONNECTION_TO_PEER_1,
-            new Object[] {mgr.getLocalMember(), remoteAddr}));
+        logger.info("{}: Successfully reestablished connection to peer {}",
+            mgr.getLocalMember(), remoteAddr);
-            conn.requestClose(LocalizedStrings.Connection_FAILED_CONSTRUCTION.toLocalizedString());
+            conn.requestClose("failed construction");
-          LocalizedStrings.Connection_CONNECTION_FAILED_CONSTRUCTION_FOR_PEER_0
-              .toLocalizedString(remoteAddr));
+          String.format("Connection: failed construction for peer %s",
+              remoteAddr));
-          LocalizedStrings.Connection_CONNECTIONTABLE_IS_NULL.toLocalizedString());
+          "ConnectionTable is null.");
-              LocalizedStrings.Connection_ATTEMPT_TO_CONNECT_TIMED_OUT_AFTER_0_MILLISECONDS
-                  .toLocalizedString(new Object[] {connectTime}));
+              String.format("Attempt timed out after %s milliseconds",
+                  new Object[] {connectTime}));
-      logger.debug("Connection: connected to {} with stub {}", remoteAddr, addr);
+      logger.debug("Connection: connected to {} with IP address {}", remoteAddr, addr);
-                  logger.fatal(LocalizedMessage.create(
-                      LocalizedStrings.Connection_EXCEPTION_FLUSHING_BATCH_SEND_BUFFER_0, ex));
+                  logger.fatal("Exception flushing batch send buffer: %s", ex);
-                  requestClose(LocalizedStrings.Connection_EXCEPTION_FLUSHING_BATCH_SEND_BUFFER_0
-                      .toLocalizedString(ex));
+                  requestClose(String.format("Exception flushing batch send buffer: %s",
+                      ex));
-                logger.info(LocalizedMessage.create(
-                    LocalizedStrings.Connection_TIMED_OUT_WAITING_FOR_READERTHREAD_ON_0_TO_FINISH,
-                    this));
+                logger.info("Timed out waiting for readerThread on {} to finish.",
+                    this);
-            LocalizedStrings.Connection_RUNNIOREADER_CAUGHT_CLOSED_CHANNEL.toLocalizedString());
+            "runNioReader caught closed channel");
-              LocalizedStrings.Connection_RUNNIOREADER_CAUGHT_SHUTDOWN.toLocalizedString());
+              "runNioReader caught shutdown");
-      logger.fatal(LocalizedMessage
-          .create(LocalizedStrings.Connection_FAILED_SETTING_CHANNEL_TO_BLOCKING_MODE_0, ex));
+      logger.fatal("Failed setting channel to blocking mode {}", ex);
-        requestClose(LocalizedStrings.Connection_FAILED_SETTING_CHANNEL_TO_BLOCKING_MODE_0
-            .toLocalizedString(ex));
+        requestClose(String.format("Failed setting channel to blocking mode %s",
+            ex));
-                  LocalizedStrings.Connection_SOCKETCHANNEL_READ_RETURNED_EOF.toLocalizedString());
+                  "SocketChannel.read returned EOF");
-                LocalizedStrings.Connection_CACHECLOSED_IN_CHANNEL_READ_0.toLocalizedString(e));
+                String.format("CacheClosed in channel read: %s", e));
-            requestClose(LocalizedStrings.Connection_CLOSEDCHANNELEXCEPTION_IN_CHANNEL_READ_0
-                .toLocalizedString(e));
+            requestClose(String.format("ClosedChannelException in channel read: %s",
+                e));
-                LocalizedStrings.Connection_IOEXCEPTION_IN_CHANNEL_READ_0.toLocalizedString(e));
+                String.format("IOException in channel read: %s", e));
-            logger.fatal(LocalizedMessage.create(
-                LocalizedStrings.Connection_0_EXCEPTION_IN_CHANNEL_READ, p2pReaderName()), e);
+            logger.fatal(String.format("%s exception in channel read", p2pReaderName()), e);
-                LocalizedStrings.Connection_0_EXCEPTION_IN_CHANNEL_READ.toLocalizedString(e));
+                String.format("%s exception in channel read", e));
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_UNABLE_TO_GET_INPUT_STREAM),
-          io);
+      logger.fatal("Unable to get input stream", io);
-          LocalizedStrings.Connection_OWNER_SHOULD_NOT_BE_NULL.toLocalizedString());
+          "owner should not be null");
-          logger.fatal(LocalizedMessage.create(
-              LocalizedStrings.Connection_UNKNOWN_P2P_MESSAGE_TYPE_0, Integer.valueOf(msgType)));
+          logger.fatal("Unknown P2P message type: {}", Integer.valueOf(msgType));
-          requestClose(LocalizedStrings.Connection_UNKNOWN_P2P_MESSAGE_TYPE_0
-              .toLocalizedString(Integer.valueOf(msgType)));
+          requestClose(String.format("Unknown P2P message type: %s",
+              Integer.valueOf(msgType)));
-                  logger.warn(LocalizedMessage.create(
-                      LocalizedStrings.Connection_MESSAGE_DESERIALIZATION_OF_0_DID_NOT_READ_1_BYTES,
-                      new Object[] {msg, Integer.valueOf(dis.available())}));
+                  logger.warn("Message deserialization of {} did not read {} bytes.",
+                      msg, Integer.valueOf(dis.available()));
-                  logger.fatal(LocalizedMessage
-                      .create(LocalizedStrings.Connection_ERROR_DISPATCHING_MESSAGE), de);
+                  logger.fatal("Error dispatching message", de);
-                      LocalizedStrings.Connection_ERROR_DESERIALIZING_MESSAGE.toLocalizedString();
+                      "Error deserializing message";
-                logger.fatal(LocalizedMessage
-                    .create(LocalizedStrings.Connection_ERROR_DESERIALIZING_MESSAGE), e);
+                logger.fatal("Error deserializing message", e);
-                logger.fatal(LocalizedMessage
-                    .create(LocalizedStrings.Connection_FAILED_HANDLING_CHUNK_MESSAGE), ex);
+                logger.fatal("Failed handling chunk message", ex);
-                logger.fatal(LocalizedMessage
-                    .create(LocalizedStrings.Connection_FAILED_HANDLING_END_CHUNK_MESSAGE), ex);
+                logger.fatal("Failed handling end chunk message", ex);
-                logger.warn(LocalizedMessage
-                    .create(LocalizedStrings.Connection_CLASSNOTFOUND_DESERIALIZING_MESSAGE_0, ex));
+                logger.warn("ClassNotFound deserializing message: {}", ex.toString());
-                failureMsg = LocalizedStrings.Connection_IOEXCEPTION_DESERIALIZING_MESSAGE
-                    .toLocalizedString();
+                failureMsg = "IOException deserializing message";
-                logger.fatal(LocalizedMessage.create(
-                    LocalizedStrings.Connection_IOEXCEPTION_DESERIALIZING_MESSAGE), failureEx);
+                logger.fatal("IOException deserializing message", failureEx);
-                failureMsg = LocalizedStrings.Connection_UNEXPECTED_FAILURE_DESERIALIZING_MESSAGE
-                    .toLocalizedString();
+                failureMsg = "Unexpected failure deserializing message";
-                logger.fatal(
-                    LocalizedMessage.create(
-                        LocalizedStrings.Connection_UNEXPECTED_FAILURE_DESERIALIZING_MESSAGE),
+                logger.fatal("Unexpected failure deserializing message",
-                  logger.fatal(LocalizedMessage
-                      .create(LocalizedStrings.Connection_ERROR_DISPATCHING_MESSAGE), de);
+                  logger.fatal("Error dispatching message", de);
-                  logger.fatal(LocalizedMessage
-                      .create(LocalizedStrings.Connection_THROWABLE_DISPATCHING_MESSAGE), t);
+                  logger.fatal("Throwable dispatching message", t);
-                String err = LocalizedStrings.Connection_UNKNOWN_HANDSHAKE_REPLY_CODE_0
-                    .toLocalizedString(replyCodeInteger);
+                String err = String.format("Unknown handshake reply code: %s",
+                    replyCodeInteger);
-                  logger.fatal(LocalizedMessage.create(
-                      LocalizedStrings.Connection_UNKNOWN_HANDSHAKE_REPLY_CODE_0,
-                      replyCodeInteger));
+                  logger.fatal("Unknown handshake reply code: {}",
+                      replyCodeInteger);
-                  logger.info(LocalizedMessage.create(
-                      LocalizedStrings.Connection_0_ASYNC_CONFIGURATION_RECEIVED_1,
-                      new Object[] {p2pReaderName(),
-                          " asyncDistributionTimeout=" + this.asyncDistributionTimeout
-                              + " asyncQueueTimeout=" + this.asyncQueueTimeout
-                              + " asyncMaxQueueSize=" + (this.asyncMaxQueueSize / (1024 * 1024))}));
+                  logger.info("{} async configuration received {}.",
+                      p2pReaderName(),
+                      " asyncDistributionTimeout=" + this.asyncDistributionTimeout
+                          + " asyncQueueTimeout=" + this.asyncQueueTimeout
+                          + " asyncMaxQueueSize="
+                          + (this.asyncMaxQueueSize / (1024 * 1024)));
-                    LocalizedStrings.Connection_DETECTED_OLD_VERSION_PRE_5_0_1_OF_GEMFIRE_OR_NONGEMFIRE_DURING_HANDSHAKE_DUE_TO_INITIAL_BYTE_BEING_0
-                        .toLocalizedString(new Byte(b)));
+                    String.format(
+                        "Detected old version (pre 5.0.1) of GemFire or non-GemFire during handshake due to initial byte being %s",
+                        new Byte(b)));
-                    LocalizedStrings.Connection_DETECTED_WRONG_VERSION_OF_GEMFIRE_PRODUCT_DURING_HANDSHAKE_EXPECTED_0_BUT_FOUND_1
-                        .toLocalizedString(
-                            new Object[] {new Byte(HANDSHAKE_VERSION), new Byte(handshakeByte)}));
+                    String.format(
+                        "Detected wrong version of GemFire product during handshake. Expected %s but found %s",
+
+                        new Object[] {new Byte(HANDSHAKE_VERSION), new Byte(handshakeByte)}));
-              Thread.currentThread().setName(LocalizedStrings.Connection_P2P_MESSAGE_READER_FOR_0
-                  .toLocalizedString(this.remoteAddr, this.socket.getPort()));
+              Thread.currentThread().setName(String.format("P2P message reader for %s on port %s",
+                  this.remoteAddr, this.socket.getPort()));
-                  logger.info(LocalizedMessage.create(
-                      LocalizedStrings.Connection_THREAD_OWNED_RECEIVER_FORCING_ITSELF_TO_SEND_ON_THREAD_OWNED_SOCKETS));
+                  logger
+                      .info("thread owned receiver forcing itself to send on thread owned sockets");
-                  logger.warn(LocalizedMessage.create(
-                      LocalizedStrings.Connection_0_TIMED_OUT_DURING_A_MEMBERSHIP_CHECK,
-                      p2pReaderName()));
+                  logger.warn("{} timed out during a membership check.",
+                      p2pReaderName());
-          logger.fatal(LocalizedMessage.create(
-              LocalizedStrings.Connection_0_STRAY_INTERRUPT_READING_MESSAGE, p2pReaderName()), e);
+          logger.fatal(String.format("%s Stray interrupt reading message", p2pReaderName()), e);
-            logger.fatal(LocalizedMessage
-                .create(LocalizedStrings.Connection_0_ERROR_READING_MESSAGE, p2pReaderName()), ioe);
+            logger.fatal(String.format("%s Error reading message", p2pReaderName()), ioe);
-              LocalizedStrings.Connection_CACHECLOSED_IN_CHANNEL_READ_0.toLocalizedString(e));
+              String.format("CacheClosed in channel read: %s", e));
-          requestClose(LocalizedStrings.Connection_IOEXCEPTION_RECEIVED_0.toLocalizedString(io));
+          requestClose(String.format("IOException received: %s", io));
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_0_EXCEPTION_RECEIVED,
+          logger.fatal(String.format("%s exception received",
-            requestClose(LocalizedStrings.Connection_0_EXCEPTION_RECEIVED.toLocalizedString(e));
+            requestClose(String.format("%s exception received", e));
-            requestClose(LocalizedStrings.Connection_STREAM_READ_RETURNED_NONPOSITIVE_LENGTH
-                .toLocalizedString());
+            requestClose("Stream read returned non-positive length");
-          requestClose(LocalizedStrings.Connection_CURRENT_THREAD_INTERRUPTED.toLocalizedString());
+          requestClose("Current thread interrupted");
-          LocalizedStrings.Connection_NOT_CONNECTED_TO_0.toLocalizedString(this.remoteAddr));
+          String.format("Not connected to %s", this.remoteAddr));
-      final long msAW = this.owner.getDM().getConfig().getAckWaitThreshold() * 1000;
-      final long msSA = this.owner.getDM().getConfig().getAckSevereAlertThreshold() * 1000;
+      final long msAW = this.owner.getDM().getConfig().getAckWaitThreshold() * 1000L;
+      final long msSA = this.owner.getDM().getConfig().getAckSevereAlertThreshold() * 1000L;
-      logger.fatal(LocalizedMessage.create(
-          LocalizedStrings.Connection_0_SECONDS_HAVE_ELAPSED_WAITING_FOR_A_RESPONSE_FROM_1_FOR_THREAD_2,
-          new Object[] {Long.valueOf((ackWaitTimeout + ackSATimeout) / 1000), getRemoteAddress(),
-              ackThreadName}));
+      logger.fatal("{} seconds have elapsed waiting for a response from {} for thread {}",
+          Long.valueOf((ackWaitTimeout + ackSATimeout) / 1000),
+          getRemoteAddress(),
+          ackThreadName);
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.Connection_0_SECONDS_HAVE_ELAPSED_WAITING_FOR_A_RESPONSE_FROM_1_FOR_THREAD_2,
-          new Object[] {Long.valueOf(ackWaitTimeout / 1000), getRemoteAddress(), ackThreadName}));
+      logger.warn("{} seconds have elapsed waiting for a response from {} for thread {}",
+          Long.valueOf(ackWaitTimeout / 1000), getRemoteAddress(), ackThreadName);
-      final StringId state = (connectionState == Connection.STATE_SENDING)
-          ? LocalizedStrings.Connection_TRANSMIT_ACKWAITTHRESHOLD
-          : LocalizedStrings.Connection_RECEIVE_ACKWAITTHRESHOLD;
+      final String state = (connectionState == Connection.STATE_SENDING)
+          ? "Sender has been unable to transmit a message within ack-wait-threshold seconds"
+          : "Sender has been unable to receive a response to a message within ack-wait-threshold seconds";
-            .suspectMembers(Collections.singleton(getRemoteAddress()), state.toLocalizedString());
+            .suspectMembers(Collections.singleton(getRemoteAddress()), state);
-          throw new ConnectionException(LocalizedStrings.Connection_FORCED_DISCONNECT_SENT_TO_0
-              .toLocalizedString(this.remoteAddr));
+          throw new ConnectionException(String.format("Forced disconnect sent to %s",
+              this.remoteAddr));
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.Connection_QUEUED_BYTES_0_EXCEEDS_MAX_OF_1_ASKING_SLOW_RECEIVER_2_TO_DISCONNECT,
-                new Object[] {newQueueSize, this.asyncMaxQueueSize, this.remoteAddr}));
+            logger.warn("Queued bytes {} exceeds max of {}, asking slow receiver {} to disconnect.",
+                newQueueSize, this.asyncMaxQueueSize, this.remoteAddr);
-      ThreadGroup group = LoggingThreadGroup.createThreadGroup("P2P Writer Threads", logger);
-      this.pusherThread = new Thread(group, new Runnable() {
-        public void run() {
-          Connection.this.runNioPusher();
-        }
-      }, "P2P async pusher to " + this.remoteAddr);
-      this.pusherThread.setDaemon(true);
+      this.pusherThread =
+          new LoggingThread("P2P async pusher to " + this.remoteAddr, this::runNioPusher);
-          LocalizedStrings.Connection_NO_DISTRIBUTION_MANAGER.toLocalizedString());
+          "no distribution manager");
-        LocalizedStrings.Connection_DISCONNECTED_AS_A_SLOWRECEIVER.toLocalizedString());
+        "Disconnected as a slow-receiver");
-        LocalizedStrings.Connection_FORCE_DISCONNECT_TIMED_OUT.toLocalizedString());
+        "Force disconnect timed out");
-                logger.warn(LocalizedMessage.create(
-                    LocalizedStrings.Connection_QUEUED_BYTES_0_EXCEEDS_MAX_OF_1_ASKING_SLOW_RECEIVER_2_TO_DISCONNECT,
-                    new Object[] {curQueuedBytes, this.asyncMaxQueueSize, this.remoteAddr}));
+                logger.warn(
+                    "Queued bytes {} exceeds max of {}, asking slow receiver {} to disconnect.",
+                    curQueuedBytes, this.asyncMaxQueueSize, this.remoteAddr);
-            LocalizedStrings.Connection_P2P_PUSHER_IO_EXCEPTION_FOR_0.toLocalizedString(this);
+            String.format("P2P pusher io exception for %s", this);
-        final String err = LocalizedStrings.Connection_P2P_PUSHER_0_CAUGHT_CACHECLOSEDEXCEPTION_1
-            .toLocalizedString(new Object[] {this, ex});
+        final String err = String.format("P2P pusher %s caught CacheClosedException: %s",
+            new Object[] {this, ex});
-          logger.fatal(
-              LocalizedMessage.create(LocalizedStrings.Connection_P2P_PUSHER_EXCEPTION_0, ex), ex);
+          logger.fatal(String.format("P2P pusher exception: %s", ex), ex);
-          requestClose(LocalizedStrings.Connection_P2P_PUSHER_EXCEPTION_0.toLocalizedString(ex));
+          requestClose(String.format("P2P pusher exception: %s", ex));
-                  logger.warn(LocalizedMessage.create(
-                      LocalizedStrings.Connection_QUEUED_BYTES_0_EXCEEDS_MAX_OF_1_ASKING_SLOW_RECEIVER_2_TO_DISCONNECT,
-                      new Object[] {Long.valueOf(curQueuedBytes),
-                          Long.valueOf(this.asyncMaxQueueSize), this.remoteAddr}));
+                  logger.warn(
+                      "Queued bytes {} exceeds max of {}, asking slow receiver {} to disconnect.",
+                      Long.valueOf(curQueuedBytes),
+                      Long.valueOf(this.asyncMaxQueueSize), this.remoteAddr);
-                  logger.warn(LocalizedMessage.create(
-                      LocalizedStrings.Connection_BLOCKED_FOR_0_MS_WHICH_IS_LONGER_THAN_THE_MAX_OF_1_MS_ASKING_SLOW_RECEIVER_2_TO_DISCONNECT,
-                      new Object[] {Long.valueOf(blockedMs),
-                          Integer.valueOf(this.asyncQueueTimeout), this.remoteAddr}));
+                  logger.warn(
+                      "Blocked for {}ms which is longer than the max of {}ms, asking slow receiver {} to disconnect.",
+                      Long.valueOf(blockedMs),
+                      Integer.valueOf(this.asyncQueueTimeout), this.remoteAddr);
-          LocalizedStrings.Connection_CONNECTION_IS_CLOSED.toLocalizedString());
+          "connection is closed");
-          LocalizedStrings.Connection_ACK_READ_IO_EXCEPTION_FOR_0.toLocalizedString(this);
+          String.format("ack read io exception for %s", this);
-          LocalizedStrings.Connection_UNABLE_TO_READ_DIRECT_ACK_BECAUSE_0.toLocalizedString(e));
+          String.format("Unable to read direct ack because: %s", e));
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.Connection_ACK_READ_EXCEPTION), e);
+        logger.fatal("ack read exception", e);
-        requestClose(LocalizedStrings.Connection_ACK_READ_EXCEPTION_0.toLocalizedString(e));
+        requestClose(String.format("ack read exception: %s", e));
-          LocalizedStrings.Connection_UNABLE_TO_READ_DIRECT_ACK_BECAUSE_0.toLocalizedString(e));
+          String.format("Unable to read direct ack because: %s", e));
-        logger.info(
-            LocalizedMessage.create(LocalizedStrings.Connection_FINISHED_WAITING_FOR_REPLY_FROM_0,
-                new Object[] {getRemoteAddress()}));
+        logger.info("Finished waiting for reply from {}",
+            getRemoteAddress());
-            logger.fatal(LocalizedMessage.create(
-                LocalizedStrings.Connection_UNKNOWN_P2P_MESSAGE_TYPE_0, nioMessageTypeInteger));
+            logger.fatal("Unknown P2P message type: {}", nioMessageTypeInteger);
-            requestClose(LocalizedStrings.Connection_UNKNOWN_P2P_MESSAGE_TYPE_0
-                .toLocalizedString(nioMessageTypeInteger));
+            requestClose(String.format("Unknown P2P message type: %s",
+                nioMessageTypeInteger));
-                  logger.warn(LocalizedMessage.create(
-                      LocalizedStrings.Connection_MESSAGE_DESERIALIZATION_OF_0_DID_NOT_READ_1_BYTES,
-                      new Object[] {msg, Integer.valueOf(bbis.available())}));
+                  logger.warn("Message deserialization of {} did not read {} bytes.",
+                      msg, Integer.valueOf(bbis.available()));
-                  logger.fatal(LocalizedMessage
-                      .create(LocalizedStrings.Connection_ERROR_DISPATCHING_MESSAGE), de);
+                  logger.fatal("Error dispatching message", de);
-                  logger.fatal(LocalizedMessage
-                      .create(LocalizedStrings.Connection_THROWABLE_DISPATCHING_MESSAGE), t);
+                  logger.fatal("Throwable dispatching message", t);
-                    LocalizedStrings.Connection_ERROR_DESERIALIZING_MESSAGE.toLocalizedString(), t,
+                    "Error deserializing message", t,
-                logger.fatal(LocalizedMessage
-                    .create(LocalizedStrings.Connection_ERROR_DESERIALIZING_MESSAGE), t);
+                logger.fatal("Error deserializing message", t);
-                logger.fatal(LocalizedMessage
-                    .create(LocalizedStrings.Connection_FAILED_HANDLING_CHUNK_MESSAGE), ex);
+                logger.fatal("Failed handling chunk message", ex);
-                logger.fatal(LocalizedMessage
-                    .create(LocalizedStrings.Connection_FAILED_HANDLING_END_CHUNK_MESSAGE), ex);
+                logger.fatal("Failed handling end chunk message", ex);
-                failureMsg = LocalizedStrings.Connection_CLASSNOTFOUND_DESERIALIZING_MESSAGE
-                    .toLocalizedString();
+                failureMsg = "ClassNotFound deserializing message";
-                logger.fatal(LocalizedMessage
-                    .create(LocalizedStrings.Connection_CLASSNOTFOUND_DESERIALIZING_MESSAGE_0, ex));
+                logger.fatal("ClassNotFound deserializing message: {}", ex.toString());
-                failureMsg = LocalizedStrings.Connection_IOEXCEPTION_DESERIALIZING_MESSAGE
-                    .toLocalizedString();
+                failureMsg = "IOException deserializing message";
-                logger.fatal(LocalizedMessage.create(
-                    LocalizedStrings.Connection_IOEXCEPTION_DESERIALIZING_MESSAGE), failureEx);
+                logger.fatal("IOException deserializing message", failureEx);
-                failureMsg = LocalizedStrings.Connection_UNEXPECTED_FAILURE_DESERIALIZING_MESSAGE
-                    .toLocalizedString();
+                failureMsg = "Unexpected failure deserializing message";
-                logger.fatal(
-                    LocalizedMessage.create(
-                        LocalizedStrings.Connection_UNEXPECTED_FAILURE_DESERIALIZING_MESSAGE),
+                logger.fatal("Unexpected failure deserializing message",
-                  logger.fatal(LocalizedMessage
-                      .create(LocalizedStrings.Connection_ERROR_DISPATCHING_MESSAGE), de);
+                  logger.fatal("Error dispatching message", de);
-                  logger.fatal(LocalizedMessage
-                      .create(LocalizedStrings.Connection_THROWABLE_DISPATCHING_MESSAGE), t);
+                  logger.fatal("Throwable dispatching message", t);
-                    logger.info(LocalizedMessage.create(
-                        LocalizedStrings.Connection_0_ASYNC_CONFIGURATION_RECEIVED_1,
-                        new Object[] {p2pReaderName(),
-                            " asyncDistributionTimeout=" + this.asyncDistributionTimeout
-                                + " asyncQueueTimeout=" + this.asyncQueueTimeout
-                                + " asyncMaxQueueSize="
-                                + (this.asyncMaxQueueSize / (1024 * 1024))}));
+                    logger.info("{} async configuration received {}.",
+                        p2pReaderName(),
+                        " asyncDistributionTimeout=" + this.asyncDistributionTimeout
+                            + " asyncQueueTimeout=" + this.asyncQueueTimeout
+                            + " asyncMaxQueueSize="
+                            + (this.asyncMaxQueueSize / (1024 * 1024)));
-                logger.fatal(LocalizedMessage.create(
-                    LocalizedStrings.Connection_ERROR_DESERIALIZING_P2P_HANDSHAKE_REPLY), e);
+                logger.fatal("Error deserializing P2P handshake reply", e);
-                requestClose(LocalizedStrings.Connection_ERROR_DESERIALIZING_P2P_HANDSHAKE_REPLY
-                    .toLocalizedString());
+                requestClose("Error deserializing P2P handshake reply");
-                logger.fatal(
-                    LocalizedMessage.create(
-                        LocalizedStrings.Connection_THROWABLE_DESERIALIZING_P2P_HANDSHAKE_REPLY),
+                logger.fatal("Throwable deserializing P2P handshake reply",
-                requestClose(LocalizedStrings.Connection_THROWABLE_DESERIALIZING_P2P_HANDSHAKE_REPLY
-                    .toLocalizedString());
+                requestClose("Throwable deserializing P2P handshake reply");
-                StringId err =
-                    LocalizedStrings.Connection_UNKNOWN_HANDSHAKE_REPLY_CODE_0_NIOMESSAGELENGTH_1_PROCESSORTYPE_2;
+                String err =
+                    "Unknown handshake reply code: %s nioMessageLength: %s";
-                      err.toLocalizedString(errArgs) + " (peer probably departed ungracefully)");
+                      String.format(err, errArgs) + " (peer probably departed ungracefully)");
-                  logger.fatal(LocalizedMessage.create(err, errArgs));
+                  logger.fatal(err, errArgs);
-                requestClose(err.toLocalizedString(errArgs));
+                requestClose(String.format(err, errArgs));
-                      LocalizedStrings.Connection_DETECTED_OLD_VERSION_PRE_501_OF_GEMFIRE_OR_NONGEMFIRE_DURING_HANDSHAKE_DUE_TO_INITIAL_BYTE_BEING_0
-                          .toLocalizedString(new Byte(b)));
+                      String.format(
+                          "Detected old version (pre 5.0.1) of GemFire or non-GemFire during handshake due to initial byte being %s",
+                          new Byte(b)));
-                      LocalizedStrings.Connection_DETECTED_WRONG_VERSION_OF_GEMFIRE_PRODUCT_DURING_HANDSHAKE_EXPECTED_0_BUT_FOUND_1
-                          .toLocalizedString(
-                              new Object[] {new Byte(HANDSHAKE_VERSION), new Byte(handshakeByte)}));
+                      String.format(
+                          "Detected wrong version of GemFire product during handshake. Expected %s but found %s",
+
+                          new Object[] {new Byte(HANDSHAKE_VERSION), new Byte(handshakeByte)}));
-                    logger.info(LocalizedMessage.create(
-                        LocalizedStrings.Connection_THREAD_OWNED_RECEIVER_FORCING_ITSELF_TO_SEND_ON_THREAD_OWNED_SOCKETS));
+                    logger.info(
+                        "thread owned receiver forcing itself to send on thread owned sockets");
-                logger.fatal(LocalizedMessage.create(
-                    LocalizedStrings.Connection_ERROR_DESERIALIZING_P2P_HANDSHAKE_MESSAGE), e);
+                logger.fatal("Error deserializing P2P handshake message", e);
-                requestClose(LocalizedStrings.Connection_ERROR_DESERIALIZING_P2P_HANDSHAKE_MESSAGE
-                    .toLocalizedString());
+                requestClose("Error deserializing P2P handshake message");
-                    logger.warn(LocalizedMessage.create(
-                        LocalizedStrings.Connection_0_TIMED_OUT_DURING_A_MEMBERSHIP_CHECK,
-                        p2pReaderName()));
+                    logger.warn("{} timed out during a membership check.",
+                        p2pReaderName());
-                    logger.fatal(LocalizedMessage
-                        .create(LocalizedStrings.Connection_UNCAUGHT_EXCEPTION_FROM_LISTENER), e);
+                    logger.fatal("Uncaught exception from listener", e);
-                final String err =
-                    LocalizedStrings.Connection_FAILED_SENDING_HANDSHAKE_REPLY.toLocalizedString();
+                final String err = "Failed sending handshake reply";
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.Connection_ALLOCATING_LARGER_NETWORK_READ_BUFFER_NEW_SIZE_IS_0_OLD_SIZE_WAS_1,
-          new Object[] {Integer.valueOf(allocSize), Integer.valueOf(oldBufferSize)}));
+      logger.info("Allocating larger network read buffer, new size is {} old size was {}.",
+          Integer.valueOf(allocSize), Integer.valueOf(oldBufferSize));
-          LocalizedStrings.Connection_SOCKET_HAS_BEEN_CLOSED.toLocalizedString());
+          "socket has been closed");
-   * return the DM id of the guy on the other side of this connection.
+   * return the DM id of the member on the other side of this connection.
-   * Return the version of the guy on the other side of this connection.
+   * Return the version of the member on the other side of this connection.
-          LocalizedStrings.Connection_CONNECTION_IS_CLOSED.toLocalizedString());
+          "connection is closed");
-          LocalizedStrings.Connection_CONNECTION_IS_CLOSED.toLocalizedString());
+          "connection is closed");
-    // just in case 1 or more guys are currently waiting to acquire.
-    // One of them will get it and then find out the connection is closed
-    // and then he will release it until all guys currently waiting to acquire
+    // just in case 1 or more connections are currently waiting to acquire.
+    // One of them will get the permit, then find out the connection is closed
+    // and release the permit until all the connections currently waiting to acquire

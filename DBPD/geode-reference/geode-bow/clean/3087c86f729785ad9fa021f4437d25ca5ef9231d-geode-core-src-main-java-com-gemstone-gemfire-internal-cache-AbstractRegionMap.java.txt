GEODE-982: refactor off-heap

- removed unused MemoryChunk implementations
- collapsed OffHeapCacheDeserializable into StoredObject
- Added Slab, SlabFactory, SlabImpl, and AddressableMemoryManager.
- collapsed MemoryChunkWithRefCount into StoredObject
- methods that access and modify the data now have Data in their name
- collapsed AddressableStoredObject into StoredObject
- changed product code to use the StoredObject interface
  instead of internal class implementations of it
- renamed DataAsAddress to TinyStoredObject
- renamed ObjectChunk to OffHeapStoredObject
- renamed ObjectChunkWithHeapForm to OffHeapStoredObjectWithHeapForm
- renamed allocateChunk to allocateOffHeapStoredObject
- renamed FakeChunk to SearchMarker
- renamed ObjectChunkSlice to OffHeapStoredObjectSlice
- renamed SyncChunkStack to OffHeapStoredObjectAddressStack
- renamed ChunkValueWrapper to OffHeapValueWrapper

-import com.gemstone.gemfire.internal.offheap.ObjectChunk;
+    assert indexUpdater == null : "indexUpdater should only exist if sqlfire";
-                // Neeraj: The below if block is to handle the special
-                // scenario witnessed in SqlFabric for now. (Though its
-                // a general scenario). The scenario is that during GII
-                // it is possible that updates start coming before the
-                // base value reaches through GII. In that scenario the deltas
-                // for that particular key is kept on being added to a list
-                // of deltas. When the base value arrives through this path
-                // of GII the oldValue will be that list of deltas. When the
-                // base values arrives the deltas are applied one by one on that list.
-                // The same scenario is applicable for GemFire also but the below 
-                // code will be executed only in case of sqlfabric now. Probably
-                // the code can be made more generic for both SQL Fabric and GemFire.
-                if (indexUpdater != null) {
-                  oldValue = oldRe.getValueInVM(owner); // OFFHEAP: ListOfDeltas
-                  if (oldValue instanceof ListOfDeltas) {
-                  // apply the deltas on this new value. update index
-                  // Make a new event object
-                  // make it an insert operation
-                  LocalRegion rgn = owner;
-                  if (owner instanceof BucketRegion) {
-                    rgn = ((BucketRegion)owner).getPartitionedRegion();
-                  }
-                  event = EntryEventImpl.create(rgn, Operation.CREATE, key, null,
-                      Boolean.TRUE /* indicate that GII is in progress */,
-                      false, null);
-                  try {
-                  event.setOldValue(newValue);
-                  if (logger.isDebugEnabled()) {
-                    logger.debug("initialImagePut: received base value for list of deltas; event: {}", event);
-                  }
-                  ((ListOfDeltas)oldValue).apply(event);
-                  Object preparedNewValue =oldRe.prepareValueForCache(owner,
-                      event.getNewValueAsOffHeapDeserializedOrRaw(), true);
-                  if(preparedNewValue instanceof ObjectChunk) {
-                    event.setNewValue(preparedNewValue);
-                  }
-                  oldRe.setValue(owner, preparedNewValue, event);
-                  //event.setNewValue(event.getOldValue());
-                  event.setOldValue(null);
-                  try {
-                    indexUpdater.onEvent(owner, event, oldRe);
-                    lruEntryUpdate(oldRe);
-                    owner.updateSizeOnPut(key, oldSize, owner.calculateRegionEntryValueSize(oldRe));
-                    EntryLogger.logInitialImagePut(_getOwnerObject(), key, newValue);
-                    result = true;
-                    done = true;
-                    break;
-                  } finally {
-                    // this must be done within the oldRe sync block
-                    indexUpdater.postEvent(owner, event, oldRe, done);
-                  }
-                  } finally {
-                    if (event != null) {
-                      event.release();
-                      event = null;
-                    }
-                  }
-                  }
-                }
-                  if (indexUpdater != null) {
-                    event = EntryEventImpl.create(owner, Operation.CREATE, key,
-                        newValue,
-                        Boolean.TRUE /* indicate that GII is in progress */,
-                        false, null);
-                    indexUpdater.onEvent(owner, event, oldRe);
-                  }
-                  if (indexUpdater != null) {
-                    indexUpdater.postEvent(owner, event, oldRe, result);
-                  }
-                if (indexUpdater != null) {
-                  event = EntryEventImpl.create(owner, Operation.CREATE, key,
-                      newValue,
-                      Boolean.TRUE /* indicate that GII is in progress */,
-                      false, null);
-                  indexUpdater.onEvent(owner, event, newRe);
-                }
-              if (result && indexUpdater != null) {
-                indexUpdater.postEvent(owner, event, newRe, done);
-              }

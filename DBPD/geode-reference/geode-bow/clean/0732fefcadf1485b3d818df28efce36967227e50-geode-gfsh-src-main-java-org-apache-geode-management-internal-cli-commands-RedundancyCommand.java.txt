Applying review feedback

- Refactored tests to reduce code duplication
- Refactored to condense duplicated Restore and Status command code into
one class
- Refactored to condense unit tests for the above classes into one class

Authored-by: Donal Evans <doevans@pivotal.io>

+import static org.apache.geode.management.internal.functions.CliFunctionResult.StatusState.ERROR;
+import java.util.Collections;
+import org.apache.geode.cache.configuration.CacheConfig;
+import org.apache.geode.management.cli.GfshCommand;
+import org.apache.geode.management.internal.cli.functions.RedundancyCommandFunction;
-public class RedundancyCommandUtils {
+public class RedundancyCommand extends GfshCommand {
-  public static final Version REDUNDANCY_COMMAND_ADDED_VERSION = Version.GEODE_1_13_0;
+  public static final Version ADDED_VERSION = Version.GEODE_1_13_0;
+  ResultModel execute(String[] includeRegions, String[] excludeRegions, boolean reassignPrimaries) {
+    return execute(includeRegions, excludeRegions, reassignPrimaries, false);
+  }
+
+  ResultModel execute(String[] includeRegions, String[] excludeRegions, boolean reassignPrimaries,
+      boolean isStatusCommand) {
+    List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion = new ArrayList<>();
+    List<String> includedRegionsWithNoMembers = new ArrayList<>();
+
+    populateLists(membersForEachRegion, includedRegionsWithNoMembers, includeRegions,
+        excludeRegions);
+
+    for (RebalanceOperationPerformer.MemberPRInfo prInfo : membersForEachRegion) {
+      // Filter out any members using older versions of Geode
+      List<DistributedMember> viableMembers = filterViableMembers(prInfo);
+
+      if (viableMembers.size() != 0) {
+        // Update the MemberPRInfo with the viable members
+        prInfo.dsMemberList = viableMembers;
+      } else {
+        // If no viable members were found, return with error status
+        ResultModel result = new ResultModel();
+        InfoResultModel errorSection = result.addInfo(ERROR_SECTION);
+        errorSection.setHeader(ERROR_SECTION_HEADER);
+        errorSection.addLine(String.format(NO_MEMBERS_WITH_VERSION_FOR_REGION,
+            ADDED_VERSION.getName(), prInfo.region));
+        result.setStatus(Result.Status.ERROR);
+        return result;
+      }
+    }
+
+    List<CliFunctionResult> functionResults = executeFunctionOnMembers(includeRegions,
+        excludeRegions, reassignPrimaries, isStatusCommand, membersForEachRegion);
+
+    return buildResultModelFromFunctionResults(functionResults, includedRegionsWithNoMembers,
+        isStatusCommand);
+  }
+
+  List<DistributedMember> filterViableMembers(
+      RebalanceOperationPerformer.MemberPRInfo prInfo) {
+    return prInfo.dsMemberList.stream()
+        .map(InternalDistributedMember.class::cast)
+        .filter(member -> member.getVersionObject().compareTo(ADDED_VERSION) >= 0)
+        .collect(Collectors.toList());
+  }
+
-      List<String> noMemberRegions, String[] includeRegions, String[] excludeRegions,
-      InternalCache cache) {
+      List<String> noMemberRegions, String[] includeRegions, String[] excludeRegions) {
-          getMembersForEachRegion(excludedRegionList, cache);
+          getMembersForEachRegion(excludedRegionList);
-        DistributedMember memberForRegion = getOneMemberForRegion(regionName, cache);
+        DistributedMember memberForRegion = getOneMemberForRegion(regionName);
-  // Extracted for testing
-  List<RebalanceOperationPerformer.MemberPRInfo> getMembersForEachRegion(
-      List<String> excludedRegionList, InternalCache cache) {
-    return RebalanceOperationPerformer.getMemberRegionList(
-        ManagementService.getManagementService(cache), cache, excludedRegionList);
-  }
-
-  // Extracted for testing
-  DistributedMember getOneMemberForRegion(String regionName, InternalCache cache) {
-    String regionNameWithSeparator = regionName;
-    // The getAssociatedMembers method requires region names start with '/'
-    if (!regionName.startsWith("/")) {
-      regionNameWithSeparator = "/" + regionName;
+  List<CliFunctionResult> executeFunctionOnMembers(String[] includeRegions, String[] excludeRegions,
+      boolean reassignPrimaries, boolean isStatusCommand,
+      List<RebalanceOperationPerformer.MemberPRInfo> membersForEachRegion) {
+    List<CliFunctionResult> functionResults = new ArrayList<>();
+    Object[] functionArgs =
+        new Object[] {includeRegions, excludeRegions, reassignPrimaries, isStatusCommand};
+    List<DistributedMember> completedMembers = new ArrayList<>();
+    for (RebalanceOperationPerformer.MemberPRInfo memberPRInfo : membersForEachRegion) {
+      // Check to see if an earlier function execution has already targeted a member hosting this
+      // region. If one has, there is no point sending a function for this region as it has already
+      // had redundancy restored
+      if (!Collections.disjoint(completedMembers, memberPRInfo.dsMemberList)) {
+        continue;
+      }
+      // Try the function on the first member for this region
+      DistributedMember targetMember = memberPRInfo.dsMemberList.get(0);
+      CliFunctionResult functionResult = executeFunctionAndGetFunctionResult(
+          new RedundancyCommandFunction(), functionArgs, targetMember);
+      if (functionResult.getStatus().equals(ERROR.name())) {
+        // Record the error and then give up
+        functionResults.add(functionResult);
+        break;
+      }
+      functionResults.add(functionResult);
+      completedMembers.add(targetMember);
-    return RebalanceOperationPerformer.getAssociatedMembers(regionNameWithSeparator, cache);
-  }
-
-  List<DistributedMember> filterViableMembersForVersion(
-      RebalanceOperationPerformer.MemberPRInfo memberPRInfo, Version version) {
-    return memberPRInfo.dsMemberList.stream()
-        .map(InternalDistributedMember.class::cast)
-        .filter(member -> member.getVersionObject().compareTo(version) >= 0)
-        .collect(Collectors.toList());
-  }
-
-  ResultModel getNoViableMembersResult(Version version, String regionName) {
-    ResultModel result = new ResultModel();
-    InfoResultModel errorSection = result.addInfo(ERROR_SECTION);
-    errorSection.setHeader(ERROR_SECTION_HEADER);
-    errorSection
-        .addLine(String.format(NO_MEMBERS_WITH_VERSION_FOR_REGION, version.getName(), regionName));
-    result.setStatus(Result.Status.ERROR);
-    return result;
+    return functionResults;
-    ResultModel result = new ResultModel();
-
-      return createNoMembersResultModel(result);
+      return createNoMembersResultModel();
-    List<String> errorStrings = new ArrayList<>();
-
+    String errorString = null;
-        errorStrings.add(String.format(EXCEPTION_MEMBER_MESSAGE, functionResult.getMemberIdOrName(),
-            functionResult.getStatusMessage()));
+        errorString =
+            String.format(EXCEPTION_MEMBER_MESSAGE, functionResult.getMemberIdOrName(),
+                functionResult.getStatusMessage());
+        break;
-    if (errorStrings.size() != 0) {
-      return createErrorResultModel(result, errorStrings);
+    if (errorString != null) {
+      return createErrorResultModel(errorString);
+    ResultModel result = new ResultModel();
-  private ResultModel createNoMembersResultModel(ResultModel result) {
+  private ResultModel createNoMembersResultModel() {
+    ResultModel result = new ResultModel();
-  private ResultModel createErrorResultModel(ResultModel result, List<String> errorStrings) {
+  private ResultModel createErrorResultModel(String errorString) {
+    ResultModel result = new ResultModel();
-    errorStrings.forEach(errorSection::addLine);
+    errorSection.addLine(errorString);
+  List<RebalanceOperationPerformer.MemberPRInfo> getMembersForEachRegion(
+      List<String> excludedRegionList) {
+    InternalCache cache = (InternalCache) getCache();
+    return RebalanceOperationPerformer.getMemberRegionList(
+        ManagementService.getManagementService(cache), cache, excludedRegionList);
+  }
+
+  // Extracted for testing
+  DistributedMember getOneMemberForRegion(String regionName) {
+    String regionNameWithSeparator = regionName;
+    // The getAssociatedMembers method requires region names start with '/'
+    if (!regionName.startsWith(CacheConfig.SEPARATOR)) {
+      regionNameWithSeparator = CacheConfig.SEPARATOR + regionName;
+    }
+    return RebalanceOperationPerformer.getAssociatedMembers(regionNameWithSeparator,
+        (InternalCache) getCache());
+  }
+
+  // Extracted for testing

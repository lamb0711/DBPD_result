GEODE-4518: Replace DSCODE with an enumeration. (#1738)

* GEODE-4518: Replace DSCODE with an enumeration.
- Deprecate DSCODE interface.
- Introduce HeaderByte enum.
- Replace explicit references to DSCODE with
  explicit references to HeaderByte.

* GEODE-4518: Update analysis files.

* GEODE-4518: Add unit test for value uniqueness.

* GEODE-4518: Convert DSCODE into enum that replaces HeaderByte.

-public abstract class InternalDataSerializer extends DataSerializer implements DSCODE {
+public abstract class InternalDataSerializer extends DataSerializer {
-        out.writeByte(INET_ADDRESS);
+        out.writeByte(DSCODE.INET_ADDRESS.toByte());
-        out.writeByte(INET_ADDRESS);
+        out.writeByte(DSCODE.INET_ADDRESS.toByte());
-        out.writeByte(INET_ADDRESS);
+        out.writeByte(DSCODE.INET_ADDRESS.toByte());
-          out.writeByte(CLASS);
+          out.writeByte(DSCODE.CLASS.toByte());
-        out.writeByte(BOOLEAN);
+        out.writeByte(DSCODE.BOOLEAN.toByte());
-        out.writeByte(CHARACTER);
+        out.writeByte(DSCODE.CHARACTER.toByte());
-        out.writeByte(BYTE);
+        out.writeByte(DSCODE.BYTE.toByte());
-        out.writeByte(SHORT);
+        out.writeByte(DSCODE.SHORT.toByte());
-        out.writeByte(INTEGER);
+        out.writeByte(DSCODE.INTEGER.toByte());
-        out.writeByte(LONG);
+        out.writeByte(DSCODE.LONG.toByte());
-        out.writeByte(FLOAT);
+        out.writeByte(DSCODE.FLOAT.toByte());
-        out.writeByte(DOUBLE);
+        out.writeByte(DSCODE.DOUBLE.toByte());
-            out.writeByte(BOOLEAN_ARRAY);
+            out.writeByte(DSCODE.BOOLEAN_ARRAY.toByte());
-            out.writeByte(BYTE_ARRAY);
+            out.writeByte(DSCODE.BYTE_ARRAY.toByte());
-            out.writeByte(CHAR_ARRAY);
+            out.writeByte(DSCODE.CHAR_ARRAY.toByte());
-            out.writeByte(DOUBLE_ARRAY);
+            out.writeByte(DSCODE.DOUBLE_ARRAY.toByte());
-            out.writeByte(FLOAT_ARRAY);
+            out.writeByte(DSCODE.FLOAT_ARRAY.toByte());
-            out.writeByte(INT_ARRAY);
+            out.writeByte(DSCODE.INT_ARRAY.toByte());
-            out.writeByte(LONG_ARRAY);
+            out.writeByte(DSCODE.LONG_ARRAY.toByte());
-            out.writeByte(SHORT_ARRAY);
+            out.writeByte(DSCODE.SHORT_ARRAY.toByte());
-            out.writeByte(STRING_ARRAY);
+            out.writeByte(DSCODE.STRING_ARRAY.toByte());
-        out.writeByte(TIME_UNIT);
+        out.writeByte(DSCODE.TIME_UNIT.toByte());
-        out.writeByte(TIME_UNIT);
+        out.writeByte(DSCODE.TIME_UNIT.toByte());
-        out.writeByte(TIME_UNIT);
+        out.writeByte(DSCODE.TIME_UNIT.toByte());
-        out.writeByte(TIME_UNIT);
+        out.writeByte(DSCODE.TIME_UNIT.toByte());
-        out.writeByte(DATE);
+        out.writeByte(DSCODE.DATE.toByte());
-        out.writeByte(FILE);
+        out.writeByte(DSCODE.FILE.toByte());
-        out.writeByte(ARRAY_LIST);
+        out.writeByte(DSCODE.ARRAY_LIST.toByte());
-        out.writeByte(LINKED_LIST);
+        out.writeByte(DSCODE.LINKED_LIST.toByte());
-        out.writeByte(VECTOR);
+        out.writeByte(DSCODE.VECTOR.toByte());
-        out.writeByte(STACK);
+        out.writeByte(DSCODE.STACK.toByte());
-        out.writeByte(HASH_SET);
+        out.writeByte(DSCODE.HASH_SET.toByte());
-        out.writeByte(LINKED_HASH_SET);
+        out.writeByte(DSCODE.LINKED_HASH_SET.toByte());
-        out.writeByte(HASH_MAP);
+        out.writeByte(DSCODE.HASH_MAP.toByte());
-        out.writeByte(IDENTITY_HASH_MAP);
+        out.writeByte(DSCODE.IDENTITY_HASH_MAP.toByte());
-        out.writeByte(HASH_TABLE);
+        out.writeByte(DSCODE.HASH_TABLE.toByte());
-        out.writeByte(PROPERTIES);
+        out.writeByte(DSCODE.PROPERTIES.toByte());
-        out.writeByte(TREE_MAP);
+        out.writeByte(DSCODE.TREE_MAP.toByte());
-        out.writeByte(TREE_SET);
+        out.writeByte(DSCODE.TREE_SET.toByte());
-          out.writeByte(BIG_INTEGER);
+          out.writeByte(DSCODE.BIG_INTEGER.toByte());
-          out.writeByte(BIG_DECIMAL);
+          out.writeByte(DSCODE.BIG_DECIMAL.toByte());
-          out.writeByte(UUID);
+          out.writeByte(DSCODE.UUID.toByte());
-          out.writeByte(TIMESTAMP);
+          out.writeByte(DSCODE.TIMESTAMP.toByte());
-      out.writeByte(DS_FIXED_ID_BYTE);
+      out.writeByte(DSCODE.DS_FIXED_ID_BYTE.toByte());
-      out.writeByte(DS_FIXED_ID_SHORT);
+      out.writeByte(DSCODE.DS_FIXED_ID_SHORT.toByte());
-      out.writeByte(DS_FIXED_ID_INT);
+      out.writeByte(DSCODE.DS_FIXED_ID_INT.toByte());
-      out.writeByte(DS_NO_FIXED_ID);
+      out.writeByte(DSCODE.DS_NO_FIXED_ID.toByte());
-          out.writeByte(USER_CLASS);
+          out.writeByte(DSCODE.USER_CLASS.toByte());
-          out.writeByte(USER_CLASS_2);
+          out.writeByte(DSCODE.USER_CLASS_2.toByte());
-          out.writeByte(USER_CLASS_4);
+          out.writeByte(DSCODE.USER_CLASS_4.toByte());
-      out.writeByte(ARRAY_OF_BYTE_ARRAYS);
+      out.writeByte(DSCODE.ARRAY_OF_BYTE_ARRAYS.toByte());
-      out.writeByte(OBJECT_ARRAY);
+      out.writeByte(DSCODE.OBJECT_ARRAY.toByte());
-      out.writeByte(BOOLEAN_TYPE);
+      out.writeByte(DSCODE.BOOLEAN_TYPE.toByte());
-      out.writeByte(CHARACTER_TYPE);
+      out.writeByte(DSCODE.CHARACTER_TYPE.toByte());
-      out.writeByte(BYTE_TYPE);
+      out.writeByte(DSCODE.BYTE_TYPE.toByte());
-      out.writeByte(SHORT_TYPE);
+      out.writeByte(DSCODE.SHORT_TYPE.toByte());
-      out.writeByte(INTEGER_TYPE);
+      out.writeByte(DSCODE.INTEGER_TYPE.toByte());
-      out.writeByte(LONG_TYPE);
+      out.writeByte(DSCODE.LONG_TYPE.toByte());
-      out.writeByte(FLOAT_TYPE);
+      out.writeByte(DSCODE.FLOAT_TYPE.toByte());
-      out.writeByte(DOUBLE_TYPE);
+      out.writeByte(DSCODE.DOUBLE_TYPE.toByte());
-      out.writeByte(VOID_TYPE);
+      out.writeByte(DSCODE.VOID_TYPE.toByte());
-      out.writeByte(NULL);
+      out.writeByte(DSCODE.NULL.toByte());
-    switch (typeCode) {
-      case BOOLEAN_TYPE:
-        return Boolean.TYPE;
-      case CHARACTER_TYPE:
-        return Character.TYPE;
-      case BYTE_TYPE:
-        return Byte.TYPE;
-      case SHORT_TYPE:
-        return Short.TYPE;
-      case INTEGER_TYPE:
-        return Integer.TYPE;
-      case LONG_TYPE:
-        return Long.TYPE;
-      case FLOAT_TYPE:
-        return Float.TYPE;
-      case DOUBLE_TYPE:
-        return Double.TYPE;
-      case VOID_TYPE:
-        return Void.TYPE;
-      case NULL:
-        return null;
-      default:
-        throw new InternalGemFireError(LocalizedStrings.InternalDataSerializer_UNEXPECTED_TYPECODE_0
-            .toLocalizedString(typeCode));
+    if (typeCode == DSCODE.BOOLEAN_TYPE.toByte()) {
+      return Boolean.TYPE;
+    if (typeCode == DSCODE.CHARACTER_TYPE.toByte()) {
+      return Character.TYPE;
+    }
+    if (typeCode == DSCODE.BYTE_TYPE.toByte()) {
+      return Byte.TYPE;
+    }
+    if (typeCode == DSCODE.SHORT_TYPE.toByte()) {
+      return Short.TYPE;
+    }
+    if (typeCode == DSCODE.INTEGER_TYPE.toByte()) {
+      return Integer.TYPE;
+    }
+    if (typeCode == DSCODE.LONG_TYPE.toByte()) {
+      return Long.TYPE;
+    }
+    if (typeCode == DSCODE.FLOAT_TYPE.toByte()) {
+      return Float.TYPE;
+    }
+    if (typeCode == DSCODE.DOUBLE_TYPE.toByte()) {
+      return Double.TYPE;
+    }
+    if (typeCode == DSCODE.VOID_TYPE.toByte()) {
+      return Void.TYPE;
+    }
+    if (typeCode == DSCODE.NULL.toByte()) {
+      return null;
+    }
+    throw new InternalGemFireError(
+        LocalizedStrings.InternalDataSerializer_UNEXPECTED_TYPECODE_0.toLocalizedString(typeCode));
-      out.writeByte(USER_DATA_SERIALIZABLE);
+      out.writeByte(DSCODE.USER_DATA_SERIALIZABLE.toByte());
-      out.writeByte(USER_DATA_SERIALIZABLE_2);
+      out.writeByte(DSCODE.USER_DATA_SERIALIZABLE_2.toByte());
-      out.writeByte(USER_DATA_SERIALIZABLE_4);
+      out.writeByte(DSCODE.USER_DATA_SERIALIZABLE_4.toByte());
-    return serializedForm.length == 1 && serializedForm[0] == NULL;
+    return serializedForm.length == 1 && serializedForm[0] == DSCODE.NULL.toByte();
-      out.writeByte(NULL);
+      out.writeByte(DSCODE.NULL.toByte());
-        out.writeByte(DATA_SERIALIZABLE);
+        out.writeByte(DSCODE.DATA_SERIALIZABLE.toByte());
-    out.writeByte(PDX_ENUM);
+    out.writeByte(DSCODE.PDX_ENUM.toByte());
-    DataSerializer.writePrimitiveByte(isGemFireObject ? GEMFIRE_ENUM : PDX_INLINE_ENUM, out);
+    DataSerializer.writePrimitiveByte(
+        isGemFireObject ? DSCODE.GEMFIRE_ENUM.toByte() : DSCODE.PDX_INLINE_ENUM.toByte(), out);
-    out.writeByte(SERIALIZABLE);
+    out.writeByte(DSCODE.SERIALIZABLE.toByte());
-    if (header == DS_FIXED_ID_BYTE) {
+    if (header == DSCODE.DS_FIXED_ID_BYTE.toByte()) {
-    } else if (header == DS_FIXED_ID_SHORT) {
+    } else if (header == DSCODE.DS_FIXED_ID_SHORT.toByte()) {
-    } else if (header == DS_NO_FIXED_ID) {
+    } else if (header == DSCODE.DS_NO_FIXED_ID.toByte()) {
-    } else if (header == DS_FIXED_ID_INT) {
+    } else if (header == DSCODE.DS_FIXED_ID_INT.toByte()) {
-    if (header == DS_FIXED_ID_BYTE) {
+    if (header == DSCODE.DS_FIXED_ID_BYTE.toByte()) {
-    } else if (header == DS_FIXED_ID_SHORT) {
+    } else if (header == DSCODE.DS_FIXED_ID_SHORT.toByte()) {
-    } else if (header == DS_NO_FIXED_ID) {
+    } else if (header == DSCODE.DS_NO_FIXED_ID.toByte()) {
-    } else if (header == DS_FIXED_ID_INT) {
+    } else if (header == DSCODE.DS_FIXED_ID_INT.toByte()) {
-    if (header == DSCODE.STRING_BYTES) {
+    if (header == DSCODE.STRING_BYTES.toByte()) {
-    } else if (header == DSCODE.STRING) {
+    } else if (header == DSCODE.STRING.toByte()) {
-    } else if (header == DSCODE.NULL_STRING) {
+    } else if (header == DSCODE.NULL_STRING.toByte()) {
-    } else if (header == DSCODE.HUGE_STRING_BYTES) {
+    } else if (header == DSCODE.HUGE_STRING_BYTES.toByte()) {
-    } else if (header == DSCODE.HUGE_STRING) {
+    } else if (header == DSCODE.HUGE_STRING.toByte()) {
-    switch (header) {
-      case DS_FIXED_ID_BYTE:
-        return DSFIDFactory.create(in.readByte(), in);
-      case DS_FIXED_ID_SHORT:
-        return DSFIDFactory.create(in.readShort(), in);
-      case DS_FIXED_ID_INT:
-        return DSFIDFactory.create(in.readInt(), in);
-      case DS_NO_FIXED_ID:
-        return readDataSerializableFixedID(in);
-      case NULL:
-        return null;
-      case NULL_STRING:
-      case STRING:
-      case HUGE_STRING:
-      case STRING_BYTES:
-      case HUGE_STRING_BYTES:
-        return readString(in, header);
-      case CLASS:
-        return readClass(in);
-      case DATE:
-        return readDate(in);
-      case FILE:
-        return readFile(in);
-      case INET_ADDRESS:
-        return readInetAddress(in);
-      case BOOLEAN:
-        return readBoolean(in);
-      case CHARACTER:
-        return readCharacter(in);
-      case BYTE:
-        return readByte(in);
-      case SHORT:
-        return readShort(in);
-      case INTEGER:
-        return readInteger(in);
-      case LONG:
-        return readLong(in);
-      case FLOAT:
-        return readFloat(in);
-      case DOUBLE:
-        return readDouble(in);
-      case BYTE_ARRAY:
-        return readByteArray(in);
-      case ARRAY_OF_BYTE_ARRAYS:
-        return readArrayOfByteArrays(in);
-      case SHORT_ARRAY:
-        return readShortArray(in);
-      case STRING_ARRAY:
-        return readStringArray(in);
-      case INT_ARRAY:
-        return readIntArray(in);
-      case LONG_ARRAY:
-        return readLongArray(in);
-      case FLOAT_ARRAY:
-        return readFloatArray(in);
-      case DOUBLE_ARRAY:
-        return readDoubleArray(in);
-      case BOOLEAN_ARRAY:
-        return readBooleanArray(in);
-      case CHAR_ARRAY:
-        return readCharArray(in);
-      case OBJECT_ARRAY:
-        return readObjectArray(in);
-      case ARRAY_LIST:
-        return readArrayList(in);
-      case LINKED_LIST:
-        return readLinkedList(in);
-      case HASH_SET:
-        return readHashSet(in);
-      case LINKED_HASH_SET:
-        return readLinkedHashSet(in);
-      case HASH_MAP:
-        return readHashMap(in);
-      case IDENTITY_HASH_MAP:
-        return readIdentityHashMap(in);
-      case HASH_TABLE:
-        return readHashtable(in);
-      case CONCURRENT_HASH_MAP:
-        return readConcurrentHashMap(in);
-      case PROPERTIES:
-        return readProperties(in);
-      case TIME_UNIT:
-        return readTimeUnit(in);
-      case USER_CLASS:
-        return readUserObject(in, in.readByte());
-      case USER_CLASS_2:
-        return readUserObject(in, in.readShort());
-      case USER_CLASS_4:
-        return readUserObject(in, in.readInt());
-      case VECTOR:
-        return readVector(in);
-      case STACK:
-        return readStack(in);
-      case TREE_MAP:
-        return readTreeMap(in);
-      case TREE_SET:
-        return readTreeSet(in);
-      case BOOLEAN_TYPE:
-        return Boolean.TYPE;
-      case CHARACTER_TYPE:
-        return Character.TYPE;
-      case BYTE_TYPE:
-        return Byte.TYPE;
-      case SHORT_TYPE:
-        return Short.TYPE;
-      case INTEGER_TYPE:
-        return Integer.TYPE;
-      case LONG_TYPE:
-        return Long.TYPE;
-      case FLOAT_TYPE:
-        return Float.TYPE;
-      case DOUBLE_TYPE:
-        return Double.TYPE;
-      case VOID_TYPE:
-        return Void.TYPE;
-
-      case USER_DATA_SERIALIZABLE:
-        return readUserDataSerializable(in, in.readByte());
-      case USER_DATA_SERIALIZABLE_2:
-        return readUserDataSerializable(in, in.readShort());
-      case USER_DATA_SERIALIZABLE_4:
-        return readUserDataSerializable(in, in.readInt());
-
-      case DATA_SERIALIZABLE:
-        return readDataSerializable(in);
-
-      case SERIALIZABLE: {
-        final boolean isDebugEnabled_SERIALIZER =
-            logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE);
-        Object serializableResult;
-        if (in instanceof DSObjectInputStream) {
-          serializableResult = ((DSObjectInputStream) in).readObject();
-        } else {
-          InputStream stream;
-          if (in instanceof InputStream) {
-            stream = (InputStream) in;
-          } else {
-            stream = new InputStream() {
-              @Override
-              public int read() throws IOException {
-                try {
-                  return in.readUnsignedByte(); // fix for bug 47249
-                } catch (EOFException ignored) {
-                  return -1;
-                }
-              }
-
-            };
-          }
-
-          ObjectInput ois = new DSObjectInputStream(stream);
-          serializationFilter.setFilterOn((ObjectInputStream) ois);
-          if (stream instanceof VersionedDataStream) {
-            Version v = ((VersionedDataStream) stream).getVersion();
-            if (v != null && v != Version.CURRENT) {
-              ois = new VersionedObjectInput(ois, v);
-            }
-          }
-
-          serializableResult = ois.readObject();
-
-          if (isDebugEnabled_SERIALIZER) {
-            logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read Serializable object: {}",
-                serializableResult);
-          }
-        }
-        if (isDebugEnabled_SERIALIZER) {
-          logger.trace(LogMarker.SERIALIZER_VERBOSE, "deserialized instanceof {}",
-              serializableResult.getClass());
-        }
-        return serializableResult;
-      }
-      case PDX:
-        return readPdxSerializable(in);
-      case PDX_ENUM:
-        return readPdxEnum(in);
-      case GEMFIRE_ENUM:
-        return readGemFireEnum(in);
-      case PDX_INLINE_ENUM:
-        return readPdxInlineEnum(in);
-      case BIG_INTEGER:
-        return readBigInteger(in);
-      case BIG_DECIMAL:
-        return readBigDecimal(in);
-      case UUID:
-        return readUUID(in);
-      case TIMESTAMP:
-        return readTimestamp(in);
-      default:
-        String s = "Unknown header byte: " + header;
-        throw new IOException(s);
+    if (header == DSCODE.DS_FIXED_ID_BYTE.toByte()) {
+      return DSFIDFactory.create(in.readByte(), in);
+    if (header == DSCODE.DS_FIXED_ID_SHORT.toByte()) {
+      return DSFIDFactory.create(in.readShort(), in);
+    }
+    if (header == DSCODE.DS_FIXED_ID_INT.toByte()) {
+      return DSFIDFactory.create(in.readInt(), in);
+    }
+    if (header == DSCODE.DS_NO_FIXED_ID.toByte()) {
+      return readDataSerializableFixedID(in);
+    }
+    if (header == DSCODE.NULL.toByte()) {
+      return null;
+    }
+    if (header == DSCODE.NULL_STRING.toByte() || header == DSCODE.STRING.toByte()
+        || header == DSCODE.HUGE_STRING.toByte() || header == DSCODE.STRING_BYTES.toByte()
+        || header == DSCODE.HUGE_STRING_BYTES.toByte()) {
+      return readString(in, header);
+    }
+    if (header == DSCODE.CLASS.toByte()) {
+      return readClass(in);
+    }
+    if (header == DSCODE.DATE.toByte()) {
+      return readDate(in);
+    }
+    if (header == DSCODE.FILE.toByte()) {
+      return readFile(in);
+    }
+    if (header == DSCODE.INET_ADDRESS.toByte()) {
+      return readInetAddress(in);
+    }
+    if (header == DSCODE.BOOLEAN.toByte()) {
+      return readBoolean(in);
+    }
+    if (header == DSCODE.CHARACTER.toByte()) {
+      return readCharacter(in);
+    }
+    if (header == DSCODE.BYTE.toByte()) {
+      return readByte(in);
+    }
+    if (header == DSCODE.SHORT.toByte()) {
+      return readShort(in);
+    }
+    if (header == DSCODE.INTEGER.toByte()) {
+      return readInteger(in);
+    }
+    if (header == DSCODE.LONG.toByte()) {
+      return readLong(in);
+    }
+    if (header == DSCODE.FLOAT.toByte()) {
+      return readFloat(in);
+    }
+    if (header == DSCODE.DOUBLE.toByte()) {
+      return readDouble(in);
+    }
+    if (header == DSCODE.BYTE_ARRAY.toByte()) {
+      return readByteArray(in);
+    }
+    if (header == DSCODE.ARRAY_OF_BYTE_ARRAYS.toByte()) {
+      return readArrayOfByteArrays(in);
+    }
+    if (header == DSCODE.SHORT_ARRAY.toByte()) {
+      return readShortArray(in);
+    }
+    if (header == DSCODE.STRING_ARRAY.toByte()) {
+      return readStringArray(in);
+    }
+    if (header == DSCODE.INT_ARRAY.toByte()) {
+      return readIntArray(in);
+    }
+    if (header == DSCODE.LONG_ARRAY.toByte()) {
+      return readLongArray(in);
+    }
+    if (header == DSCODE.FLOAT_ARRAY.toByte()) {
+      return readFloatArray(in);
+    }
+    if (header == DSCODE.DOUBLE_ARRAY.toByte()) {
+      return readDoubleArray(in);
+    }
+    if (header == DSCODE.BOOLEAN_ARRAY.toByte()) {
+      return readBooleanArray(in);
+    }
+    if (header == DSCODE.CHAR_ARRAY.toByte()) {
+      return readCharArray(in);
+    }
+    if (header == DSCODE.OBJECT_ARRAY.toByte()) {
+      return readObjectArray(in);
+    }
+    if (header == DSCODE.ARRAY_LIST.toByte()) {
+      return readArrayList(in);
+    }
+    if (header == DSCODE.LINKED_LIST.toByte()) {
+      return readLinkedList(in);
+    }
+    if (header == DSCODE.HASH_SET.toByte()) {
+      return readHashSet(in);
+    }
+    if (header == DSCODE.LINKED_HASH_SET.toByte()) {
+      return readLinkedHashSet(in);
+    }
+    if (header == DSCODE.HASH_MAP.toByte()) {
+      return readHashMap(in);
+    }
+    if (header == DSCODE.IDENTITY_HASH_MAP.toByte()) {
+      return readIdentityHashMap(in);
+    }
+    if (header == DSCODE.HASH_TABLE.toByte()) {
+      return readHashtable(in);
+    }
+    if (header == DSCODE.CONCURRENT_HASH_MAP.toByte()) {
+      return readConcurrentHashMap(in);
+    }
+    if (header == DSCODE.PROPERTIES.toByte()) {
+      return readProperties(in);
+    }
+    if (header == DSCODE.TIME_UNIT.toByte()) {
+      return readTimeUnit(in);
+    }
+    if (header == DSCODE.USER_CLASS.toByte()) {
+      return readUserObject(in, in.readByte());
+    }
+    if (header == DSCODE.USER_CLASS_2.toByte()) {
+      return readUserObject(in, in.readShort());
+    }
+    if (header == DSCODE.USER_CLASS_4.toByte()) {
+      return readUserObject(in, in.readInt());
+    }
+    if (header == DSCODE.VECTOR.toByte()) {
+      return readVector(in);
+    }
+    if (header == DSCODE.STACK.toByte()) {
+      return readStack(in);
+    }
+    if (header == DSCODE.TREE_MAP.toByte()) {
+      return readTreeMap(in);
+    }
+    if (header == DSCODE.TREE_SET.toByte()) {
+      return readTreeSet(in);
+    }
+    if (header == DSCODE.BOOLEAN_TYPE.toByte()) {
+      return Boolean.TYPE;
+    }
+    if (header == DSCODE.CHARACTER_TYPE.toByte()) {
+      return Character.TYPE;
+    }
+    if (header == DSCODE.BYTE_TYPE.toByte()) {
+      return Byte.TYPE;
+    }
+    if (header == DSCODE.SHORT_TYPE.toByte()) {
+      return Short.TYPE;
+    }
+    if (header == DSCODE.INTEGER_TYPE.toByte()) {
+      return Integer.TYPE;
+    }
+    if (header == DSCODE.LONG_TYPE.toByte()) {
+      return Long.TYPE;
+    }
+    if (header == DSCODE.FLOAT_TYPE.toByte()) {
+      return Float.TYPE;
+    }
+    if (header == DSCODE.DOUBLE_TYPE.toByte()) {
+      return Double.TYPE;
+    }
+    if (header == DSCODE.VOID_TYPE.toByte()) {
+      return Void.TYPE;
+    }
+    if (header == DSCODE.USER_DATA_SERIALIZABLE.toByte()) {
+      return readUserDataSerializable(in, in.readByte());
+    }
+    if (header == DSCODE.USER_DATA_SERIALIZABLE_2.toByte()) {
+      return readUserDataSerializable(in, in.readShort());
+    }
+    if (header == DSCODE.USER_DATA_SERIALIZABLE_4.toByte()) {
+      return readUserDataSerializable(in, in.readInt());
+    }
+    if (header == DSCODE.DATA_SERIALIZABLE.toByte()) {
+      return readDataSerializable(in);
+    }
+    if (header == DSCODE.SERIALIZABLE.toByte()) {
+      final boolean isDebugEnabled_SERIALIZER = logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE);
+      Object serializableResult;
+      if (in instanceof DSObjectInputStream) {
+        serializableResult = ((DSObjectInputStream) in).readObject();
+      } else {
+        InputStream stream;
+        if (in instanceof InputStream) {
+          stream = (InputStream) in;
+        } else {
+          stream = new InputStream() {
+            @Override
+            public int read() throws IOException {
+              try {
+                return in.readUnsignedByte(); // fix for bug 47249
+              } catch (EOFException ignored) {
+                return -1;
+              }
+            }
+
+          };
+        }
+
+        ObjectInput ois = new DSObjectInputStream(stream);
+        serializationFilter.setFilterOn((ObjectInputStream) ois);
+        if (stream instanceof VersionedDataStream) {
+          Version v = ((VersionedDataStream) stream).getVersion();
+          if (v != null && v != Version.CURRENT) {
+            ois = new VersionedObjectInput(ois, v);
+          }
+        }
+
+        serializableResult = ois.readObject();
+
+        if (isDebugEnabled_SERIALIZER) {
+          logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read Serializable object: {}",
+              serializableResult);
+        }
+      }
+      if (isDebugEnabled_SERIALIZER) {
+        logger.trace(LogMarker.SERIALIZER_VERBOSE, "deserialized instanceof {}",
+            serializableResult.getClass());
+      }
+      return serializableResult;
+    }
+    if (header == DSCODE.PDX.toByte()) {
+      return readPdxSerializable(in);
+    }
+    if (header == DSCODE.PDX_ENUM.toByte()) {
+      return readPdxEnum(in);
+    }
+    if (header == DSCODE.GEMFIRE_ENUM.toByte()) {
+      return readGemFireEnum(in);
+    }
+    if (header == DSCODE.PDX_INLINE_ENUM.toByte()) {
+      return readPdxInlineEnum(in);
+    }
+    if (header == DSCODE.BIG_INTEGER.toByte()) {
+      return readBigInteger(in);
+    }
+    if (header == DSCODE.BIG_DECIMAL.toByte()) {
+      return readBigDecimal(in);
+    }
+    if (header == DSCODE.UUID.toByte()) {
+      return readUUID(in);
+    }
+    if (header == DSCODE.TIMESTAMP.toByte()) {
+      return readTimestamp(in);
+    }
+
+    String s = "Unknown header byte: " + header;
+    throw new IOException(s);
-      if (type == PDX) {
+      if (type == DSCODE.PDX.toByte()) {
-      } else if (type == DSCODE.PDX_ENUM) {
+      } else if (type == DSCODE.PDX_ENUM.toByte()) {
-      } else if (type == DSCODE.PDX_INLINE_ENUM) {
+      } else if (type == DSCODE.PDX_INLINE_ENUM.toByte()) {

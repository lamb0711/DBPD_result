Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.  
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import com.gemstone.gemfire.internal.cache.AbstractRegionEntry;
-
-  /*
-   *  return the Entry that is considered most recently used
-   */
-  @Override
-   public LRUClockNode getLRUEntry() { // new getLIFOEntry
-    LRUClockNode aNode = null;
-    synchronized (this.lock) {
-      aNode = this.tail.prevLRUNode();
-      if(aNode == this.head) {
-        return null;
-      }
-      //TODO - Dan 9/23/09 We should probably
-      //do something like this to change the tail pointer.
-      //But this code wasn't changing the tail before
-      //I made this a doubly linked list, and I don't
-      //want to change it on this branch.
-//      LRUClockNode prev = aNode.prevLRUNode();
-//      prev.setNextLRUNode(this.tail);
-//      aNode.setNextLRUNode(null);
-//      aNode.setPrevLRUNode(null);
+  
+    /* Fetch the tail member which should be the last added value and remove it
+     * from the list
+     */
+    protected LRUClockNode getTailEntry() {
+        LRUClockNode aNode = null;
+        synchronized (this.lock) {
+            aNode = this.tail.prevLRUNode();
+            if (aNode == this.head) {
+                return null; //end of lru list
+            }
+            //remove entry from list
+            LRUClockNode prev = aNode.prevLRUNode();
+            prev.setNextLRUNode(this.tail);
+            this.tail.setPrevLRUNode(prev);
+            aNode.setNextLRUNode(null);
+            aNode.setPrevLRUNode(null);
+            super.size--;
+        }
+        return aNode;
-    /* no need to update stats here as when this function finished executing 
-       next few calls update stats */
-    return aNode.testEvicted()? null:aNode;
-  }
+
+    /*
+     *  return the Entry that is considered most recently used and available 
+     * to be evicted to overflow
+     */
+    @Override
+    public LRUClockNode getLRUEntry() {
+        long numEvals = 0;
+        LRUClockNode aNode = null;
+        //search for entry to return from list
+        for (;;) {
+            aNode = getTailEntry();
+            //end of Lifo list stop searching
+            if (aNode == null) {
+                break;
+            }
+            numEvals++;
+            synchronized (aNode) {
+                //look for another entry if in transaction
+		boolean inUseByTransaction = false;
+                if (aNode instanceof AbstractRegionEntry) {
+                    if (((AbstractRegionEntry) aNode).isInUseByTransaction()) {
+                       inUseByTransaction=true; 
+                    }
+                }
+                //if entry NOT used by transaction and NOT evicted return entry
+                if (!inUseByTransaction && !aNode.testEvicted()) {
+                    break;
+                }
+            }
+        }
+        this.stats().incEvaluations(numEvals);
+        return aNode;
+    }

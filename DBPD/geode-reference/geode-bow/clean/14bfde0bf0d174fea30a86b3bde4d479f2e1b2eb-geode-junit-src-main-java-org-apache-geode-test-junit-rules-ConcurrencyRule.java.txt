Merge branch 'release/1.8.0'

-import static org.assertj.core.api.Assertions.catchThrowable;
-    private Throwable expectedException;
-    private T expectedValue;
+    private Boolean expectedResultIsSet;
+    private T expectedValue;
+    private Throwable expectedException;
+    private Class expectedExceptionCauseType;
+      this.expectedResultIsSet = false;
+      expectedExceptionCauseType = null;
+      this.expectedResultIsSet = false;
+      expectedExceptionCauseType = null;
-      if (expectedExceptionType != null || expectedValue != null) {
+      if (expectedResultIsSet) {
+      this.expectedResultIsSet = true;
+      this.expectedResultIsSet = true;
+      return this;
+    }
+
+    /**
+     * Sets the expected result of running the thread to be an exception with a cause that is an
+     * instance of the given class
+     *
+     * @param expectedExceptionCauseType the class of the expected exception cause. The exception
+     *        itself will not be checked.
+     * @return this, the ConcurrentOperation (containing a callable) that has been set to repeat
+     */
+    public ConcurrentOperation expectExceptionCauseType(Class expectedExceptionCauseType) {
+      if (expectedException != null || expectedValue != null) {
+        throw new IllegalArgumentException("Specify only one expected outcome.");
+      }
+
+      this.expectedExceptionCauseType = expectedExceptionCauseType;
+      this.expectedResultIsSet = true;
-      if (expectedExceptionType != null || expectedException != null) {
+      if (this.expectedResultIsSet) {
+      this.expectedResultIsSet = true;
-      if (expectedValue != null) {
-        assertThat(this.callable.call()).isEqualTo(this.expectedValue);
-      } else if (expectedException != null) {
-        Throwable thrown = catchThrowable(() -> this.callable.call());
-        checkThrown(this.expectedException, thrown);
-      } else if (expectedExceptionType != null) {
-        Throwable thrown = catchThrowable(() -> this.callable.call());
-        assertThat(thrown).isInstanceOf(this.expectedExceptionType);
-      } else {
-        this.callable.call();
+      Exception exception = null;
+
+      try {
+        T retVal = this.callable.call();
+
+        if (this.expectedValue != null) {
+          assertThat(retVal).isEqualTo(this.expectedValue);
+        }
+      } catch (Exception e) {
+        exception = e;
+
+      if (this.expectedExceptionCauseType != null && this.expectedExceptionType != null) {
+        assertThat(exception).isInstanceOf(this.expectedExceptionType)
+            .hasCauseInstanceOf(this.expectedExceptionCauseType);
+      } else if (this.expectedExceptionType != null) {
+        assertThat(exception).isInstanceOf(this.expectedExceptionType);
+      } else if (this.expectedExceptionCauseType != null) {
+        assertThat(exception).hasCauseInstanceOf(this.expectedExceptionCauseType);
+      } else if (this.expectedException != null) {
+        checkThrown(exception, this.expectedException);
+      } else {
+        if (exception != null) {
+          throw exception; // rethrow if we weren't expecting any exception and got one
+        }
+      }
+
-    private void checkThrown(Throwable expected, Throwable actual) {
+    private void checkThrown(Throwable actual, Throwable expected) {
-        checkThrown(expected.getCause(), actual.getCause());
+        checkThrown(actual.getCause(), expected.getCause());

Merge branch 'release/1.1.0'

-* Licensed to the Apache Software Foundation (ASF) under one or more
-* contributor license agreements.  See the NOTICE file distributed with
-* this work for additional information regarding copyright ownership.
-* The ASF licenses this file to You under the Apache License, Version 2.0
-* (the "License"); you may not use this file except in compliance with
-* the License.  You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
-abstract public class DeltaSessionManager extends ManagerBase implements Lifecycle, PropertyChangeListener, SessionManager {
+abstract public class DeltaSessionManager extends ManagerBase
+    implements Lifecycle, PropertyChangeListener, SessionManager {
-   * This *MUST* only be assigned during start/startInternal otherwise it will be associated
-   * with the incorrect context class loader.
+   * This *MUST* only be assigned during start/startInternal otherwise it will be associated with
+   * the incorrect context class loader.
-  protected String regionAttributesId; // the default is different for client-server and peer-to-peer
+  protected String regionAttributesId; // the default is different for client-server and
+                                       // peer-to-peer
-  private static final long TIMER_TASK_PERIOD = Long.getLong("gemfiremodules.sessionTimerTaskPeriod", 10000);
+  private static final long TIMER_TASK_PERIOD =
+      Long.getLong("gemfiremodules.sessionTimerTaskPeriod", 10000);
-  private static final long TIMER_TASK_DELAY = Long.getLong("gemfiremodules.sessionTimerTaskDelay", 10000);
+  private static final long TIMER_TASK_DELAY =
+      Long.getLong("gemfiremodules.sessionTimerTaskDelay", 10000);
-    //return this.enableGatewayDeltaReplication;
+    // return this.enableGatewayDeltaReplication;
-   * This method was taken from StandardManager to set the default maxInactiveInterval based on the container (to 30
-   * minutes).
+   * This method was taken from StandardManager to set the default maxInactiveInterval based on the
+   * container (to 30 minutes).
-   * Set the Container with which this Manager has been associated. If it is a Context (the usual case), listen for
-   * changes to the session timeout property.
+   * Set the Container with which this Manager has been associated. If it is a Context (the usual
+   * case), listen for changes to the session timeout property.
-      getLogger().debug(this + ": Finding session " + id + " in " + getSessionCache().getOperatingRegionName());
+      getLogger().debug(
+          this + ": Finding session " + id + " in " + getSessionCache().getOperatingRegionName());
-     * Check that the context name for this session is the same as this manager's.
-     * This comes into play when multiple versions of a webapp are deployed and
-     * active at the same time; the context name will contain an embedded
-     * version number; something like /test###2.
+     * Check that the context name for this session is the same as this manager's. This comes into
+     * play when multiple versions of a webapp are deployed and active at the same time; the context
+     * name will contain an embedded version number; something like /test###2.
-    if (session != null &&
-        !session.getContextName().isEmpty() &&
-        !getContextName().equals(session.getContextName())) {
-      getLogger().info(this + ": Session " + id +
-          " rejected as container name and context do not match: " +
-          getContextName() + " != " + session.getContextName());
+    if (session != null && !session.getContextName().isEmpty()
+        && !getContextName().equals(session.getContextName())) {
+      getLogger()
+          .info(this + ": Session " + id + " rejected as container name and context do not match: "
+              + getContextName() + " != " + session.getContextName());
-        getLogger().debug(this + ": Did not find session " + id + " in " + getSessionCache().getOperatingRegionName());
+        getLogger().debug(this + ": Did not find session " + id + " in "
+            + getSessionCache().getOperatingRegionName());
-        getLogger().debug(
-            this + ": Found session " + id + " in " + getSessionCache().getOperatingRegionName() + ": " + session);
+        getLogger().debug(this + ": Found session " + id + " in "
+            + getSessionCache().getOperatingRegionName() + ": " + session);
-    this.sessionCache = cache.isClient() ? new ClientServerSessionCache(this, cache) : new PeerToPeerSessionCache(this,
-        cache);
+    this.sessionCache = cache.isClient() ? new ClientServerSessionCache(this, cache)
+        : new PeerToPeerSessionCache(this, cache);
-    //super.remove(session);
+    // super.remove(session);
-        getLogger().debug(
-            this + ": Expired session " + session.getId() + " from " + getSessionCache().getOperatingRegionName());
+        getLogger().debug(this + ": Expired session " + session.getId() + " from "
+            + getSessionCache().getOperatingRegionName());
-        getLogger().debug(
-            this + ": Destroying session " + session.getId() + " from " + getSessionCache().getOperatingRegionName());
+        getLogger().debug(this + ": Destroying session " + session.getId() + " from "
+            + getSessionCache().getOperatingRegionName());
-        getLogger().debug(
-            this + ": Destroyed session " + session.getId() + " from " + getSessionCache().getOperatingRegionName());
+        getLogger().debug(this + ": Destroyed session " + session.getId() + " from "
+            + getSessionCache().getOperatingRegionName());
-    //super.add(session);
+    // super.add(session);
-      getLogger().debug(
-          this + ": Storing session " + session.getId() + " into " + getSessionCache().getOperatingRegionName());
+      getLogger().debug(this + ": Storing session " + session.getId() + " into "
+          + getSessionCache().getOperatingRegionName());
-      getLogger().debug(
-          this + ": Stored session " + session.getId() + " into " + getSessionCache().getOperatingRegionName());
+      getLogger().debug(this + ": Stored session " + session.getId() + " into "
+          + getSessionCache().getOperatingRegionName());
-   * If local caching is enabled, add the session to the set of sessions to be
-   * touched. A timer task will be periodically invoked to get the session in
-   * the session region to update its last accessed time. This prevents the
-   * session from expiring in the case where the application is only getting
-   * attributes from the session and never putting attributes into the
-   * session. If local caching is disabled. the session's last accessed time
-   * would already have been updated properly in the sessions region.
+   * If local caching is enabled, add the session to the set of sessions to be touched. A timer task
+   * will be periodically invoked to get the session in the session region to update its last
+   * accessed time. This prevents the session from expiring in the case where the application is
+   * only getting attributes from the session and never putting attributes into the session. If
+   * local caching is disabled. the session's last accessed time would already have been updated
+   * properly in the sessions region.
-   * Note: Due to issues in GemFire expiry, sessions are always asynchronously
-   * touched using a function regardless whether or not local caching is
-   * enabled. This prevents premature expiration.
+   * Note: Due to issues in GemFire expiry, sessions are always asynchronously touched using a
+   * function regardless whether or not local caching is enabled. This prevents premature
+   * expiration.
-            getLogger().debug(DeltaSessionManager.this + ": Set max active sessions: " + currentActiveSessions);
+            getLogger().debug(
+                DeltaSessionManager.this + ": Set max active sessions: " + currentActiveSessions);
-   * Part of this method implementation was taken from StandardManager. The sessionTimeout can be changed in the web.xml
-   * which is processed after the context.xml. The context (and the default session timeout) would already have been set
-   * in this Manager. This is the way to get the new session timeout value specified in the web.xml.
+   * Part of this method implementation was taken from StandardManager. The sessionTimeout can be
+   * changed in the web.xml which is processed after the context.xml. The context (and the default
+   * session timeout) would already have been set in this Manager. This is the way to get the new
+   * session timeout value specified in the web.xml.
-   * <ol> <li>the max inactive interval is set based on the Manager defined in the context.xml <li>the max inactive
-   * interval is then overwritten by the value of the Context's session timeout when setContainer is called <li>the max
-   * inactive interval is then overwritten by the value of the session-timeout specified in the web.xml (if any) </ol>
+   * <ol>
+   * <li>the max inactive interval is set based on the Manager defined in the context.xml
+   * <li>the max inactive interval is then overwritten by the value of the Context's session timeout
+   * when setContainer is called
+   * <li>the max inactive interval is then overwritten by the value of the session-timeout specified
+   * in the web.xml (if any)
+   * </ol>
-          getLogger().warn(
-              "The configured session timeout of " + interval + " minutes is invalid. Using the original value of " + event
-                  .getOldValue() + " minutes.");
-          interval = ((Integer) event.getOldValue()).intValue();
-          ;
+          getLogger().warn("The configured session timeout of " + interval
+              + " minutes is invalid. Using the original value of " + event.getOldValue()
+              + " minutes.");
+          interval = ((Integer) event.getOldValue()).intValue();;
-        setMaxInactiveInterval(
-            interval == RegionConfiguration.DEFAULT_MAX_INACTIVE_INTERVAL ? RegionConfiguration.DEFAULT_MAX_INACTIVE_INTERVAL : interval * 60);
+        setMaxInactiveInterval(interval == RegionConfiguration.DEFAULT_MAX_INACTIVE_INTERVAL
+            ? RegionConfiguration.DEFAULT_MAX_INACTIVE_INTERVAL : interval * 60);
-        getLogger().error(sm.getString("standardManager.sessionTimeout", event.getNewValue().toString()));
+        getLogger()
+            .error(sm.getString("standardManager.sessionTimeout", event.getNewValue().toString()));
-   * Save any currently active sessions in the appropriate persistence mechanism, if any.  If persistence is not
-   * supported, this method returns without doing anything.
+   * Save any currently active sessions in the appropriate persistence mechanism, if any. If
+   * persistence is not supported, this method returns without doing anything.
-    Query query = querySvc.newQuery("select s.id from " + regionName +
-        " as s where s.contextName = '" + context.getPath() + "'");
+    Query query = querySvc.newQuery("select s.id from " + regionName
+        + " as s where s.contextName = '" + context.getPath() + "'");
-    if (getLogger().isDebugEnabled()) getLogger().debug("Unloading " + list.size() + " sessions");
+    if (getLogger().isDebugEnabled())
+      getLogger().debug("Unloading " + list.size() + " sessions");
-        }
-        else {
-          //All DeltaSessionInterfaces as of Geode 1.0 should be based on StandardSession
+        } else {
+          // All DeltaSessionInterfaces as of Geode 1.0 should be based on StandardSession
-//    // Expire all the sessions we just wrote
-//    if (getLogger().isDebugEnabled()) {
-//      getLogger().debug("Expiring " + list.size() + " persisted sessions");
-//    }
-//    Iterator<StandardSession> expires = list.iterator();
-//    while (expires.hasNext()) {
-//      StandardSession session = expires.next();
-//      try {
-//        session.expire(false);
-//      } catch (Throwable t) {
-////        ExceptionUtils.handleThrowable(t);
-//      } finally {
-//        session.recycle();
-//      }
-//    }
+    // // Expire all the sessions we just wrote
+    // if (getLogger().isDebugEnabled()) {
+    // getLogger().debug("Expiring " + list.size() + " persisted sessions");
+    // }
+    // Iterator<StandardSession> expires = list.iterator();
+    // while (expires.hasNext()) {
+    // StandardSession session = expires.next();
+    // try {
+    // session.expire(false);
+    // } catch (Throwable t) {
+    //// ExceptionUtils.handleThrowable(t);
+    // } finally {
+    // session.recycle();
+    // }
+    // }
-   * Load any currently active sessions that were previously unloaded to the appropriate persistence mechanism, if any.
-   * If persistence is not supported, this method returns without doing anything.
+   * Load any currently active sessions that were previously unloaded to the appropriate persistence
+   * mechanism, if any. If persistence is not supported, this method returns without doing anything.
-   * @throws IOException            if an input/output error occurs
+   * @throws IOException if an input/output error occurs
-        if (existingSession != null && existingSession.getLastAccessedTime() > session.getLastAccessedTime()) {
+        if (existingSession != null
+            && existingSession.getLastAccessedTime() > session.getLastAccessedTime()) {
-    return new StringBuilder().append(getClass().getSimpleName())
-        .append("[")
-        .append("container=")
-        .append(getTheContext())
-        .append("; regionName=")
-        .append(this.regionName)
-        .append("; regionAttributesId=")
-        .append(this.regionAttributesId)
-        .append("]")
-        .toString();
+    return new StringBuilder().append(getClass().getSimpleName()).append("[").append("container=")
+        .append(getTheContext()).append("; regionName=").append(this.regionName)
+        .append("; regionAttributesId=").append(this.regionAttributesId).append("]").toString();
-      return  (Context) getContainer();
+      return (Context) getContainer();
-      getLogger().error("Unable to unload sessions - container is of type " +
-                        getContainer().getClass().getName() + " instead of StandardContext");
+      getLogger().error("Unable to unload sessions - container is of type "
+          + getContainer().getClass().getName() + " instead of StandardContext");

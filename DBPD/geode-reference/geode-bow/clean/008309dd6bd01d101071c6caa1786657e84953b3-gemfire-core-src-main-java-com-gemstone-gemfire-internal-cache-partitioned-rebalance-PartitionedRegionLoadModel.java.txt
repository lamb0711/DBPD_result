Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
-  final MemberRollup INVALID_MEMBER = new MemberRollup(null, false);
+  final MemberRollup INVALID_MEMBER = new MemberRollup(null, false, false);
-  private final boolean enforceLocalMaxMemory;
-
-      boolean enforceLocalMaxMemory,
-    this.enforceLocalMaxMemory = enforceLocalMaxMemory;
-      Collection<? extends InternalPartitionDetails> memberDetailSet, OfflineMemberDetails offlineDetails) {
+      Collection<? extends InternalPartitionDetails> memberDetailSet, 
+      OfflineMemberDetails offlineDetails,
+      boolean enforceLocalMaxMemory) {
-          memberDetails.getPRLoad().getWeight(), memberDetails.getConfiguredMaxMemory(), isCritical);
+          memberDetails.getPRLoad().getWeight(), memberDetails.getConfiguredMaxMemory(), isCritical, enforceLocalMaxMemory);
-        memberSum = new MemberRollup(memberId, isCritical);
+        memberSum = new MemberRollup(memberId, isCritical, enforceLocalMaxMemory);
-  public void createRedundantBucket(BucketRollup bucket,
-      Member targetMember) {
+  /**
+   * Trigger the creation of a redundant bucket, potentially asynchronously.
+   * 
+   * This method will find the best node to create a redundant bucket and 
+   * invoke the bucket operator to create a bucket on that node. Because the bucket
+   * operator is asynchronous, the bucket may not be created immediately, but
+   * the model will be updated regardless. Invoke {@link #waitForOperations()}
+   * to wait for those operations to actually complete
+   */
+  public void createRedundantBucket(final BucketRollup bucket,
+      final Member targetMember) {
-    Move move = new Move(null, targetMember, bucket);
+    final Move move = new Move(null, targetMember, bucket);
-    if(!this.operator.createRedundantBucket(targetMember.getMemberId(), bucket.getId(), colocatedRegionSizes)) {
-      this.attemptedBucketCreations.add(move);
-    } else {
+    
+    this.operator.createRedundantBucket(targetMember.getMemberId(), bucket.getId(), colocatedRegionSizes, new BucketOperator.Completion() {
+      @Override
+      public void onSuccess() {
+
+      @Override
+      public void onFailure() {
+        //If the bucket creation failed, we need to undo the changes
+        //we made to the model
+        attemptedBucketCreations.add(move);
+        bucket.removeMember(targetMember);
+        if(bucket.getRedundancy() < requiredRedundancy) {
+          lowRedundancyBuckets.add(bucket);
+        }
+        resetAverages();
+      }
+    });
-      int totalPrimaryCount = 0;
+      float totalPrimaryCount = 0;
-      int totalLoad = 0;
+      float totalLoad = 0;
+  /**
+   * Wait for the bucket operator to complete
+   * any pending asynchronous operations.
+   */
+  public void waitForOperations() {
+    operator.waitForOperations();
+  }
+  
-    public MemberRollup(InternalDistributedMember memberId, boolean isCritical) {
-      super(memberId, isCritical);
+    public MemberRollup(InternalDistributedMember memberId, boolean isCritical, boolean enforceLocalMaxMemory) {
+      super(memberId, isCritical, enforceLocalMaxMemory);
+    private final boolean enforceLocalMaxMemory;
-    public Member(InternalDistributedMember memberId, boolean isCritical) {
+    public Member(InternalDistributedMember memberId, boolean isCritical, boolean enforceLocalMaxMemory) {
+      this.enforceLocalMaxMemory = enforceLocalMaxMemory;
-    public Member(InternalDistributedMember memberId, float weight, long localMaxMemory, boolean isCritical) {
-      this(memberId, isCritical);
+    public Member(InternalDistributedMember memberId, float weight, long localMaxMemory, boolean isCritical, boolean enforceLocalMaxMemory) {
+      this(memberId, isCritical, enforceLocalMaxMemory);
-      if(enforceLocalMaxMemory && this.totalBytes + bucket.getBytes() > this.localMaxMemory) {
+      if(this.enforceLocalMaxMemory && this.totalBytes + bucket.getBytes() > this.localMaxMemory) {

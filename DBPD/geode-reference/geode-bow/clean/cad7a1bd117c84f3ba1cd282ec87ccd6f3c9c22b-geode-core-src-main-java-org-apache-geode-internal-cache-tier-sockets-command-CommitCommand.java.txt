GEODE-5269 CommitConflictException after TransactionInDoubtException

Before sending a client a TransactionInDoubtException that is caused by
a server shutting down we now wait a bit for the server to finish shutting
down.  This allows any locks it held to be released and avoids a
CommitConflictException if the client should immediately try another
transaction with the same key(s).

The server will wait up to 1/2 of the client's read-timeout for the
other server to finish shutting down.

+import java.util.concurrent.TimeoutException;
+import org.apache.geode.CancelException;
+import org.apache.geode.cache.TransactionInDoubtException;
+import org.apache.geode.distributed.DistributedMember;
+
+
+    commitTransaction(clientMessage, serverConnection, txMgr, wasInProgress,
+        txProxy);
+  }
+
+  protected void commitTransaction(Message clientMessage, ServerConnection serverConnection,
+      TXManagerImpl txMgr,
+      boolean wasInProgress, TXStateProxy txProxy) throws IOException {
+    Exception txException = null;
+    TXCommitMessage commitMsg = null;
+    TXId txId = txProxy.getTxId();
-
-      txId = txProxy.getTxId();
-
+      logger.debug("Sending commit response to client: {}", commitMsg);
+
-      sendException(clientMessage, serverConnection, e);
+      txException = e;
+    if (txException != null) {
+      DistributedMember target = txProxy.getTarget();
+      // a TransactionInDoubtException caused by the TX host shutting down means that
+      // the transaction may still be active and hold locks. We must wait for the transaction
+      // host to finish shutting down before responding to the client or it could encounter
+      // conflicts in retrying the transaction
+      try {
+        if ((txException instanceof TransactionInDoubtException)
+            && (txException.getCause() instanceof CancelException)) {
+          // base the wait time on the client's read-timeout setting so that we respond before
+          // it gives up reading. Since we've already done a commit we've eaten up some time
+          // so we use a WAG of half the read-timeout
+          int timeToWait = serverConnection.getHandshake().getClientReadTimeout() / 2;
+          if (timeToWait < 0) {
+            return;
+          }
+          logger.info(
+              "Waiting up to {}ms for departure of {} before throwing TransactionInDoubtException.",
+              timeToWait, target);
+          try {
+            serverConnection.getCache().getDistributionManager().getMembershipManager()
+                .waitForDeparture(target, timeToWait);
+          } catch (TimeoutException e) {
+            // status will be logged below
+          } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+          }
+          logger.info("Done waiting.  Transaction host {} in the cluster.",
+              serverConnection.getCache().getDistributionManager().isCurrentMember(target)
+                  ? "is still"
+                  : "is no longer");
+        }
+      } finally {
+        sendException(clientMessage, serverConnection, txException);
+      }
+    }
-

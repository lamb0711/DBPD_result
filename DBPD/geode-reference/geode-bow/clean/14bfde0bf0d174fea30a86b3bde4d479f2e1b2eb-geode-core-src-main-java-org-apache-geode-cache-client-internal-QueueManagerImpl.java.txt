Merge branch 'release/1.8.0'

-import java.util.concurrent.ScheduledThreadPoolExecutor;
-import java.util.concurrent.ThreadFactory;
-import org.apache.geode.cache.client.internal.ServerBlackList.BlackListListener;
-import org.apache.geode.cache.client.internal.ServerBlackList.BlackListListenerAdapter;
-import org.apache.geode.cache.client.internal.ServerBlackList.FailureTracker;
+import org.apache.geode.cache.client.internal.ServerDenyList.DenyListListener;
+import org.apache.geode.cache.client.internal.ServerDenyList.DenyListListenerAdapter;
+import org.apache.geode.cache.client.internal.ServerDenyList.FailureTracker;
-import org.apache.geode.i18n.StringId;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+import org.apache.geode.internal.logging.LoggingExecutors;
-  protected final ServerBlackList blackList;
+  protected final ServerDenyList denyList;
-  private ScheduledThreadPoolExecutor recoveryThread;
+  private ScheduledExecutorService recoveryThread;
-    blackList = new ServerBlackList(redundancyRetryInterval);
+    denyList = new ServerDenyList(redundancyRetryInterval);
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.QueueManagerImpl_TIMEOUT_WAITING_FOR_RECOVERY_THREAD_TO_COMPLETE));
+          logger.warn("Timeout waiting for recovery thread to complete");
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.QueueManagerImpl_ERROR_CLOSING_PRIMARY_CONNECTION_TO_0,
-            primary.getEndpoint()), e);
+        logger.warn("Error closing primary connection to " +
+            primary.getEndpoint(),
+            e);
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.QueueManagerImpl_ERROR_CLOSING_BACKUP_CONNECTION_TO_0,
-              backup.getEndpoint()), e);
+          logger.warn("Error closing backup connection to " +
+              backup.getEndpoint(),
+              e);
-      blackList.start(background);
+      denyList.start(background);
-      this.recoveryThread = new ScheduledThreadPoolExecutor(1, new ThreadFactory() {
-
-        public Thread newThread(Runnable r) {
-          Thread result = new Thread(r, name);
-          result.setDaemon(true);
-          return result;
-        }
-
-
-      });
-      recoveryThread.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);
+      this.recoveryThread = LoggingExecutors.newScheduledThreadPool(name, 1, false);
-      // When a server is removed from the blacklist, try again
+      // When a server is removed from the denylist, try again
-      BlackListListener blackListListener = new BlackListListenerAdapter() {
+      DenyListListener denyListListener = new DenyListListenerAdapter() {
-      blackList.addListener(blackListListener);
-      factory.getBlackList().addListener(blackListListener);
+      denyList.addListener(denyListListener);
+      factory.getDenyList().addListener(denyListListener);
-          logger.info(LocalizedMessage.create(
-              LocalizedStrings.QueueManagerImpl_SENDING_READY_FOR_EVENTS_TO_PRIMARY_0, primary));
+          logger.info("Sending ready for events to primary: {}", primary);
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.QueueManagerImpl_SENDING_READY_FOR_EVENTS_TO_PRIMARY_0, primary));
+      logger.info("Sending ready for events to primary: {}", primary);
-          .info(LocalizedMessage.create(
-              LocalizedStrings.QueueManagerImpl_SUBSCRIPTION_ENDPOINT_CRASHED_SCHEDULING_RECOVERY,
+          .info("{} subscription endpoint {} crashed. Scheduling recovery.",
-                  ? (deadConnection.getUpdater().isPrimary() ? "Primary" : "Redundant") : "Queue",
-                  endpoint}));
+                  ? (deadConnection.getUpdater().isPrimary() ? "Primary" : "Redundant")
+                  : "Queue",
+                  endpoint});
-        .info(
-            LocalizedMessage.create(
-                LocalizedStrings.QueueManagerImpl_CACHE_CLIENT_UPDATER_FOR_ON_ENDPOINT_EXITING_SCHEDULING_RECOVERY,
-                new Object[] {(deadConnection != null && deadConnection.getUpdater() != null)
-                    ? (deadConnection.getUpdater().isPrimary() ? "Primary" : "Redundant") : "Queue",
-                    endpoint}));
+        .info("Cache client updater for {} on endpoint {} exiting. Scheduling recovery.",
+            (deadConnection != null && deadConnection.getUpdater() != null)
+                ? (deadConnection.getUpdater().isPrimary() ? "Primary" : "Redundant")
+                : "Queue",
+            endpoint);
-    Set excludedServers = new HashSet(blackList.getBadServers());
+    Set excludedServers = new HashSet(denyList.getBadServers());
-          LocalizedStrings.QueueManagerImpl_COULD_NOT_CREATE_A_QUEUE_NO_QUEUE_SERVERS_AVAILABLE);
+          "Could not create a queue. No queue servers available.");
-      logger.error(LocalizedMessage.create(
-          LocalizedStrings.QueueManagerImpl_COULD_NOT_INITIALIZE_A_PRIMARY_QUEUE_ON_STARTUP_NO_QUEUE_SERVERS_AVAILABLE));
+      logger.error("Could not initialize a primary queue on startup. No queue servers available.");
-                LocalizedStrings.QueueManagerImpl_COULD_NOT_INITIALIZE_A_PRIMARY_QUEUE_ON_STARTUP_NO_QUEUE_SERVERS_AVAILABLE
-                    .toLocalizedString()));
+                "Could not initialize a primary queue on startup. No queue servers available."));
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.QueueManagerImpl_UNABLE_TO_INITIALIZE_ENOUGH_REDUNDANT_QUEUES_ON_STARTUP_THE_REDUNDANCY_COUNT_IS_CURRENTLY_0,
-          getCurrentRedundancy()));
+      logger.warn(
+          "Unable to initialize enough redundant queues on startup. The redundancy count is currently {}.",
+          getCurrentRedundancy());
-        logger.info(LocalizedMessage.create(
-            LocalizedStrings.QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_REDUNDANT_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER));
+        logger.info(
+            "SubscriptionManager redundancy satisfier - redundant endpoint has been lost. Attempting to recover.");
-          LocalizedStrings.QueueManagerImpl_COULD_NOT_FIND_SERVER_TO_CREATE_REDUNDANT_CLIENT_QUEUE);
+          "Could not find any server to host redundant client queue. Number of excluded servers is %s and exception is %s");
-            logger.info(LocalizedMessage.create(
-                LocalizedStrings.QueueManagerImpl_REDUNDANCY_LEVEL_0_IS_NOT_SATISFIED_BUT_THERE_ARE_NO_MORE_SERVERS_AVAILABLE_REDUNDANCY_IS_CURRENTLY_1,
-                new Object[] {redundancyLevel, getCurrentRedundancy()}));
+            logger.info(
+                "Redundancy level {} is not satisfied, but there are no more servers available. Redundancy is currently {}.",
+                new Object[] {redundancyLevel, getCurrentRedundancy()});
-          LocalizedStrings.QueueManagerImpl_COULD_NOT_FIND_SERVER_TO_CREATE_PRIMARY_CLIENT_QUEUE);
+          "Could not find any server to host primary client queue. Number of excluded servers is %s and exception is %s");
-      boolean printErrorMessage, StringId msgId) {
+      boolean printErrorMessage, String msg) {
-        logger.error(LocalizedMessage.create(msgId,
+        logger.error(String.format(msg,
-      logger.info(LocalizedMessage.create(
-          LocalizedStrings.QueueManagerImpl_SUBSCRIPTION_MANAGER_REDUNDANCY_SATISFIER_PRIMARY_ENDPOINT_HAS_BEEN_LOST_ATTEMPTIMG_TO_RECOVER));
+      logger.info(
+          "SubscriptionManager redundancy satisfier - primary endpoint has been lost. Attempting to recover.");
-    FailureTracker failureTracker = blackList.getFailureTracker(connection.getServer());
+    FailureTracker failureTracker = denyList.getFailureTracker(connection.getServer());
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.QueueManagerImpl_UNABLE_TO_CREATE_A_SUBSCRIPTION_CONNECTION_TO_SERVER_0,
-            connection.getEndpoint()));
+        logger.warn("unable to create a subscription connection to server {}",
+            connection.getEndpoint());
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.QueueManagerImpl_QUEUEMANAGERIMPL_FAILED_TO_RECOVER_INTEREST_TO_SERVER_0,
-          newConnection.getServer()), t);
+      logger.warn("QueueManagerImpl failed to recover interest to server " +
+          newConnection.getServer(),
+          t);
-  protected void logError(StringId message, Throwable t) {
+  protected void logError(String message, Throwable t) {
-        excludedServers.addAll(blackList.getBadServers());
-        excludedServers.addAll(factory.getBlackList().getBadServers());
+        excludedServers.addAll(denyList.getBadServers());
+        excludedServers.addAll(factory.getDenyList().getBadServers());
-          logError(LocalizedStrings.QueueManagerImpl_ERROR_IN_REDUNDANCY_SATISFIER, t);
+          logError("Error in redundancy satisfier", t);

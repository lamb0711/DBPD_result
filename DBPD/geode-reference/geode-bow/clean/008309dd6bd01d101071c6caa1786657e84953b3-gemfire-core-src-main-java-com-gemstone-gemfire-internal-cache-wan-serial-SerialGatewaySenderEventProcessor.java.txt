Merge branch 'release/1.0.0-incubating.M1'

- * ========================================================================= 
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved. 
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- * =========================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import com.gemstone.gemfire.internal.cache.EventID;
-  private Map unprocessedEvents;
+  private Map<EventID, EventWrapper> unprocessedEvents;
-  private Map unprocessedTokens;
+  private Map<EventID, Long> unprocessedTokens;
-    this.unprocessedEvents = new LinkedHashMap();
-    this.unprocessedTokens = new LinkedHashMap();
+    this.unprocessedEvents = new LinkedHashMap<EventID, EventWrapper>();
+    this.unprocessedTokens = new LinkedHashMap<EventID, Long>();
-              if (this.unprocessedEvents.remove(ge.getEventId()) != null) {
+              EventWrapper unprocessedEvent = this.unprocessedEvents.remove(ge.getEventId());
+              if (unprocessedEvent != null) {
+                unprocessedEvent.event.release();
-          Iterator it = this.unprocessedEvents.values().iterator();
-          while (it.hasNext() && !stopped()) {
-            EventWrapper ew = (EventWrapper)it.next();
+          Iterator<Map.Entry<EventID, EventWrapper>> it = this.unprocessedEvents.entrySet().iterator();
+          while (it.hasNext()) {
+            if (stopped()) break;
+            Map.Entry<EventID, EventWrapper> me = it.next();
+            EventWrapper ew = me.getValue();
-            try {
-            } catch (IOException e) {
-              logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayImpl_EVENT_FAILED_TO_BE_INITIALIZED_0, gatewayEvent), e);
-            }
+            it.remove();
+            boolean queuedEvent = false;
+              queuedEvent = true;
+            } finally {
+              if (!queuedEvent) {
+                gatewayEvent.release();
+              }
-      this.unprocessedEvents = null;
+      releaseUnprocessedEvents();
+  
+  private void releaseUnprocessedEvents() {
+    synchronized (this.unprocessedEventsLock) {
+      Map<EventID, EventWrapper> m = this.unprocessedEvents;
+      if (m != null) {
+        for (EventWrapper ew: m.values()) {
+          GatewaySenderEventImpl gatewayEvent = ew.event;
+          gatewayEvent.release();
+        }
+        this.unprocessedEvents = null;
+      }
+    }
+  }
+  
+  @Override
+  public void closeProcessor() {
+    try {
+      super.closeProcessor();
+    } finally {
+      releaseUnprocessedEvents();
+    }
+  }
-          senderEvent = new GatewaySenderEventImpl(operation, event, substituteValue, false);
+          senderEvent = new GatewaySenderEventImpl(operation, event, substituteValue, false); // OFFHEAP ok
-      senderEvent = new GatewaySenderEventImpl(operation, event, substituteValue);
+      senderEvent = new GatewaySenderEventImpl(operation, event, substituteValue); // OFFHEAP ok
-    if (!sender.beforeEnque(gatewayEvent)) {
+    if (!sender.beforeEnqueue(gatewayEvent)) {
-      Object v = this.unprocessedEvents.remove(gatewayEvent.getEventId());
-      if (v != null) {
+      EventWrapper ew = this.unprocessedEvents.remove(gatewayEvent.getEventId());
+      if (ew != null) {
+        ew.event.release();
-      Object v = this.unprocessedEvents.remove(gatewayEvent.getEventId());
+      EventWrapper ew = this.unprocessedEvents.remove(gatewayEvent.getEventId());
-      if (v == null) {
+      if (ew == null) {
-          try {
-            gatewayEvent.initialize();
-          } catch (Exception e) {
-          }
-              sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(), deserialize(gatewayEvent.getValue()));
+              sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(), gatewayEvent.getValueAsString(true));
-          Object mapValue = Long.valueOf(System.currentTimeMillis()
+          Long mapValue = Long.valueOf(System.currentTimeMillis()
-          Object oldv = this.unprocessedTokens.put(gatewayEvent.getEventId(),
-              mapValue);
+          Long oldv = this.unprocessedTokens.put(gatewayEvent.getEventId(), mapValue);
-          try {
-            gatewayEvent.initialize();
-          } catch (Exception e) {
-          }
-              sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(), deserialize(gatewayEvent.getValue()));
+              sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(), gatewayEvent.getValueAsString(true));
+        ew.event.release();
-     GatewaySenderStats statistics = this.sender.getStatistics();
+    boolean freeGatewayEvent = true;
+    try {
+    GatewaySenderStats statistics = this.sender.getStatistics();
-      if (!sender.beforeEnque(gatewayEvent)) {
+      if (!sender.beforeEnqueue(gatewayEvent)) {
-    Object v = this.unprocessedTokens.remove(gatewayEvent.getEventId());
+    Long v = this.unprocessedTokens.remove(gatewayEvent.getEventId());
-            sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(), deserialize(gatewayEvent.getValue()));
+            sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(), gatewayEvent.getValueAsString(true));
-        Object mapValue = new EventWrapper(gatewayEvent);
-        Object oldv = this.unprocessedEvents.put(gatewayEvent.getEventId(), mapValue);
+        EventWrapper mapValue = new EventWrapper(gatewayEvent);
+        EventWrapper oldv = this.unprocessedEvents.put(gatewayEvent.getEventId(), mapValue);
+          freeGatewayEvent = false;
-            sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(), deserialize(gatewayEvent.getValue()));
+            sender.getId(), gatewayEvent.getEventId(), gatewayEvent.getKey(), gatewayEvent.getValueAsString(true));
+    } finally {
+      if (freeGatewayEvent) {
+        gatewayEvent.release();
+      }
+    }
-          Iterator it = this.unprocessedTokens.entrySet().iterator();
+          Iterator<Map.Entry<EventID, Long>> it = this.unprocessedTokens.entrySet().iterator();
-            Map.Entry me = (Map.Entry)it.next();
-            long meValue = ((Long)me.getValue()).longValue();
+            Map.Entry<EventID, Long> me = it.next();
+            long meValue = me.getValue().longValue();
-          Iterator it = this.unprocessedEvents.entrySet().iterator();
+          Iterator<Map.Entry<EventID, EventWrapper>> it = this.unprocessedEvents.entrySet().iterator();
-            Map.Entry me = (Map.Entry)it.next();
-            AbstractGatewaySender.EventWrapper ew = (AbstractGatewaySender.EventWrapper)me.getValue();
+            Map.Entry<EventID, EventWrapper> me = it.next();
+            EventWrapper ew = me.getValue();
+              ew.event.release();
-  protected Object deserialize(byte[] serializedBytes) {
-    Object deserializedObject = serializedBytes;
-    // This is a debugging method so ignore all exceptions like
-    // ClassNotFoundException
-    try {
-      deserializedObject = EntryEventImpl.deserialize(serializedBytes);
-    } catch (Exception e) {
-    }
-    return deserializedObject;
-  }
-

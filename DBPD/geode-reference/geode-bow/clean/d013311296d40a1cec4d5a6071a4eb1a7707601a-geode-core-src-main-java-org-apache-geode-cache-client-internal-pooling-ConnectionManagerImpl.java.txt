GEODE-7880: revert changes related to GEODE-6536 (#4810)

Revert "Feature/geode 6536 1: modify borrowConnection singleHop solution (#4753)"

This reverts commit 86defd40c6ba558b53753c51176e05f009bb32c3.

Co-authored-by: anilkumar gingade <agingade@pivotal.io>
Co-authored-by: Dale Emery <demery@pivotal.io>
-    return timeout <= System.nanoTime();
+    return timeout < System.nanoTime();
+  /**
+   * Borrow a connection to a specific server. This task currently allows us to break the connection
+   * limit, because it is used by tasks from the background thread that shouldn't be constrained by
+   * the limit. They will only violate the limit by 1 connection, and that connection will be
+   * destroyed when returned to the pool.
+   */
-  public PooledConnection borrowConnection(ServerLocation server, long acquireTimeout,
-      boolean onlyUseExistingCnx)
-      throws AllConnectionsInUseException, NoAvailableServersException,
-      ServerConnectivityException {
-
-    PooledConnection connection;
-    logger.trace("Connection borrowConnection single hop connection");
-
-    long waitStart = NOT_WAITING;
-    try {
-      long timeout = System.nanoTime() + MILLISECONDS.toNanos(acquireTimeout);
-      while (true) {
-
-        connection =
-            availableConnectionManager.useFirst((c) -> c.getServer().equals(server));
-
-        if (null != connection) {
-          return connection;
-        }
-
-        if (connectionAccounting.tryCreate()) {
-          try {
-            connection = createPooledConnection(server);
-
-            if (null != connection) {
-              return connection;
-            }
-            throw new NoAvailableServersException();
-          } finally {
-            if (connection == null) {
-              connectionAccounting.cancelTryCreate();
-              if (connectionAccounting.isUnderMinimum()) {
-                startBackgroundPrefill();
-              }
-            }
-          }
-        }
-
-        if (!onlyUseExistingCnx) {
-          connection = forceCreateConnection(server);
-          if (null != connection) {
-            return connection;
-          }
-          throw new ServerConnectivityException(BORROW_CONN_ERROR_MSG + server);
-        }
-
-        if (checkShutdownInterruptedOrTimeout(timeout)) {
-          break;
-        }
-
-        waitStart = beginConnectionWaitStatIfNotStarted(waitStart);
-
-        Thread.yield();
-      }
-    } finally {
-      endConnectionWaitStatIfStarted(waitStart);
+  public PooledConnection borrowConnection(ServerLocation server,
+      boolean onlyUseExistingCnx) throws AllConnectionsInUseException, NoAvailableServersException {
+    PooledConnection connection =
+        availableConnectionManager.useFirst((c) -> c.getServer().equals(server));
+    if (null != connection) {
+      return connection;
-    cancelCriterion.checkCancelInProgress(null);
+    if (onlyUseExistingCnx) {
+      throw new AllConnectionsInUseException();
+    }
-    throw new AllConnectionsInUseException();
+    connection = forceCreateConnection(server);
+    if (null != connection) {
+      return connection;
+    }
+
+    throw new ServerConnectivityException(BORROW_CONN_ERROR_MSG + server);

Revert GEODE-2644 because offline diskstore commands generate info level logs

GFSH forks the offline diskstore commands in a JVM using log4j2-cli.xml
which sets the log level to WARN. However, the forked JVM creates a
Cache which then starts generating info level statements to STDOUT.

Revert "GEODE-2644: Remove log level from MonitorQueryUnderContentionBenchmark"
This reverts commit 6691d310e1263966991e584f712156d919dabecf.

Revert "GEODE-2644: Update session state caching dependencies for logging"
This reverts commit 688f58a4a75cc1297faa1dda201b971346c3a9fe.

Revert "GEODE-5637: Fix flaky SingleHopClientExecutorWithLoggingIntegrationTest"
This reverts commit 0a8f3dffa1ebaa618fafecc15bbc92ba8ba83696.

Revert "GEODE-2644: Make LogWriterAppender optional and support log4j2.xml"
This reverts commit 591f3f7840ce38c6100bff2040f396ad2469175e.

Revert "GEODE-2644: Expand DistributedSystemMXBean tests"
This reverts commit cd2bba13e2fb7e79f7634053a6c612050b328e11.

Revert "GEODE-2644: Make AlertAppender optional and support log4j2.xml"
This reverts commit 02c3cae1d38098259ff6aa4635c6e74f795bdc50.

Revert "GEODE-2644: Add LogConfig and StatisticsConfig for logging"
This reverts commit a77c94b349b3ed7fc873fc29f6852f9936843790.

Revert "GEODE-2644: Add AlertingTest JUnit Category"
This reverts commit 731cd2a7d35b086d34f8bbcb94a83c40739ae8ee.

Revert "GEODE-2644: Add LogFileAssert and LogLevelAssert assertions"
This reverts commit 5e61da5301469cdbd71ac186573f56c38e9a6cf0.

Revert "GEODE-2644: Cleanup logging related files"
This reverts commit 763e4177f201eff9b140654e6858152a1a184b8c.

Revert "GEODE-2644: Define interfaces for new Log4j2 Appenders"
This reverts commit efd8a14027195b6dae1dd3e4d53a33696ed318bb.

-import org.apache.geode.LogWriter;
- * {@link LogWriter} together, sorting them by their timestamp. Note that this program assumes that
- * the entries in the individual log files are themselves sorted by timestamp.
+ * {@link org.apache.geode.LogWriter} together, sorting them by their timestamp. Note that
+ * this program assumes that the entries in the individual log files are themselves sorted by
+ * timestamp.
+ *
+ *
-
-  private static final PrintStream out = System.out;
-  private static final PrintStream err = System.err;
+  private static PrintStream out = System.out;
+  private static PrintStream err = System.err;
-   * <code>PrintWriter</code>.
+   * <code>PrinWriter</code>.
-  public static boolean mergeLogFiles(final Map<String, InputStream> logFiles,
-      final PrintWriter mergedFile) {
+  public static boolean mergeLogFiles(Map<String, InputStream> logFiles, PrintWriter mergedFile) {
-   * <code>PrintWriter</code>.
+   * <code>PrinWriter</code>.
-  public static boolean mergeLogFiles(final Map<String, InputStream> logFiles,
-      final PrintWriter mergedFile, final boolean tabOut, final boolean suppressBlanks,
-      final boolean multithreaded, final List<String> patterns) {
-    return Sorter.mergeLogFiles(logFiles, mergedFile, tabOut, suppressBlanks, multithreaded,
-        patterns);
+  public static boolean mergeLogFiles(Map<String, InputStream> logFiles,
+      PrintWriter mergedFile, boolean tabOut, boolean suppressBlanks, boolean multithreaded,
+      List<String> patterns) {
+    return Sorter.mergeLogFiles(logFiles, mergedFile, tabOut, suppressBlanks,
+        multithreaded, patterns);
+
+  // ////////////////// Main Program ////////////////////
+
-  private static void usage(final String s) {
+  private static void usage(String s) {
-    err.println();
+    // err.println("-regex pattern Case-insensitive search for a regular expression.");
+    // err.println(" May be used multiple times. Use Java regular ");
+    // err.println(" expression syntax (see java.util.regex.Pattern).");
+    err.println("");
-    err.println();
+    err.println("");
-    err.println();
+    err.println("");
-  static ArrayList<File> getLogFiles(final String dirName) {
+  static ArrayList<File> getLogFiles(String dirName) {
-  public static void main(final String... args) throws IOException {
+  public static void main(String[] args) throws IOException {
-    List<String> patterns = new LinkedList<>();
+    List<String> patterns = new LinkedList();
-      if (findPIDs && nickNames.get(i) != null) {
+      if (findPIDs && (nickNames.get(i) != null)) {
+  ////////////////////// Inner Classes //////////////////////
+
-  private static ArrayList findPIDs(final ArrayList files, final PrintWriter output) {
+  private static ArrayList findPIDs(ArrayList files, PrintWriter output) {
+    // System.out.println("findPids() invoked");
+
+      // System.out.println("considering " + name);
+          // System.out.println("no number found in directory name");
-          // see if this is a hydra-generated test directory name, like parReg-0504-161349
+          // see if this is a hydra-generated test directory name, like
+          // parReg-0504-161349
+          // System.out.println("using directory name: '" + name.substring(0, startIdx+1) + "'");
+          // System.out.println("using file name: '" + name.substring(0,startIdx+1) + "'");
+        // else {
+        // System.out.println("could not find a PID");
+        // }
-      // find the string of numbers at the end of the test area and use it as a PID
-      String PID;
+      // find the string of numbers at the end of the test area and use it
+      // as a PID
+      String PID = null;
-          if (i < name.length() - 1) { // have a number
+          if (i < (name.length() - 1)) { // have a number
-              int iPID = Integer.valueOf(PID);
+              int iPID = Integer.valueOf(PID).intValue();
-
+
+    /** The maximum size of the entry queue */
+    // private static int QUEUE_CAPACITY = 1000;
+
+    //////////////////// Instance Methods ////////////////////
+
-    private final String logFileName;
+    private String logFileName;
-    private final LogFileParser parser;
+    /** whether to suppress blank lines */
+    // private boolean suppressBlanks;
+
+    /** whether to align non-timestamped lines with timestamped lines */
+    // private boolean tabOut;
+
+    private LogFileParser parser;
-    private final List<Pattern> patterns;
+    private List<Pattern> patterns;
+
+    //////////////////// Constructors ////////////////////
-    public NonThreadedReader(final InputStream logFile, final String logFileName,
-        final ThreadGroup group, final boolean tabOut, final boolean suppressBlanks,
-        final List<Pattern> patterns) {
+    public NonThreadedReader(InputStream logFile, String logFileName, ThreadGroup group,
+        boolean tabOut, boolean suppressBlanks, List<Pattern> patterns) {
+      // super(group, "Reader for " + ((logFileName != null) ? logFileName : logFile.toString()));
-      parser = new LogFileParser(this.logFileName, this.logFile, tabOut, suppressBlanks);
+      // this.suppressBlanks = suppressBlanks;
+      // this.tabOut = tabOut;
+      this.parser = new LogFileParser(this.logFileName, this.logFile, tabOut, suppressBlanks);
-    @Override
-      return logFileName;
+      return this.logFileName;
-    @Override
-    public void setUniqueId(final int id) {
+    public void setUniqueId(int id) {
-    @Override
-    @Override
-      while (nextEntry == null) {
+      while (this.nextEntry == null) {
-    private boolean patternMatch(final LogFileParser.LogEntry entry) {
-      if (patterns == null || patterns.isEmpty()) {
+    private boolean patternMatch(LogFileParser.LogEntry entry) {
+      if (this.patterns == null || this.patterns.isEmpty()) {
-    @Override
-      if (nextEntry != null) {
-        returnValue = nextEntry;
+      if (this.nextEntry != null) {
+        returnValue = this.nextEntry;
-    private static final int QUEUE_CAPACITY = 1000;
+    private static int QUEUE_CAPACITY = 1000;
+
+    //////////////////// Instance Methods ////////////////////
-    private final String logFileName;
+    private String logFileName;
-    private final BlockingQueue queue;
+    private BlockingQueue queue;
-    private final boolean suppressBlanks;
+    private boolean suppressBlanks;
-    private final boolean tabOut;
+    private boolean tabOut;
-    private final List<Pattern> patterns;
+    private List<Pattern> patterns;
+
+    //////////////////// Constructors ////////////////////
+     *
+     * @param patterns TODO
+     *
+     * @see #run
-    public ThreadedReader(final InputStream logFile, final String logFileName,
-        final ThreadGroup group, final boolean tabOut, final boolean suppressBlanks,
-        final List<Pattern> patterns) {
+    public ThreadedReader(InputStream logFile, String logFileName, ThreadGroup group,
+        boolean tabOut, boolean suppressBlanks, List<Pattern> patterns) {
+      // super(group, "Reader for " + ((logFileName != null) ? logFileName : logFile.toString()));
-      queue = new LinkedBlockingQueue(QUEUE_CAPACITY);
+      this.queue = new LinkedBlockingQueue(QUEUE_CAPACITY);
+      // new UnsharedMessageQueue(QUEUE_CAPACITY,
+      // (75 * QUEUE_CAPACITY) / 100);
-      start();
+      this.start();
-    @Override
-      return logFileName;
+      return this.logFileName;
-    @Override
-    public void setUniqueId(final int id) {
+    public void setUniqueId(int id) {
-    @Override
-          new LogFileParser(logFileName, logFile, tabOut, suppressBlanks);
+          new LogFileParser(this.logFileName, this.logFile, tabOut, suppressBlanks);
-            queue.put(entry);
+            this.queue.put(entry);
-              notify();
+              this.notify();
-    private boolean patternMatch(final LogFileParser.LogEntry entry) {
-      if (patterns == null || patterns.isEmpty()) {
+    private boolean patternMatch(LogFileParser.LogEntry entry) {
+      if (this.patterns == null || this.patterns.isEmpty()) {
-    @Override
-      LogFileParser.LogEntry entry = (LogFileParser.LogEntry) queue.peek();
+      // out.println(this.getName() + " size " + this.queue.size());
+      LogFileParser.LogEntry entry = (LogFileParser.LogEntry) this.queue.peek();
-          entry = (LogFileParser.LogEntry) queue.peek();
+          entry = (LogFileParser.LogEntry) this.queue.peek();
-              wait();
-              entry = (LogFileParser.LogEntry) queue.peek();
+              this.wait();
+              entry = (LogFileParser.LogEntry) this.queue.peek();
-    @Override
-      return (LogFileParser.LogEntry) queue.poll();
+      return (LogFileParser.LogEntry) this.queue.poll();
-
-    ReaderGroup(final String groupName) {
+    ReaderGroup(String groupName) {
-      exceptionOccurred = false;
+      this.exceptionOccurred = false;
-    public void uncaughtException(final Thread t, final Throwable e) {
+    public void uncaughtException(Thread t, Throwable e) {
-      exceptionOccurred = true;
+      this.exceptionOccurred = true;
-      return exceptionOccurred;
+      return this.exceptionOccurred;
+     * @param patterns TODO
-    public static boolean mergeLogFiles(final Map<String, InputStream> logFiles,
-        final PrintWriter mergedFile, final boolean tabOut, final boolean suppressBlanks,
-        final boolean multithreaded, final List<String> patterns) {
-      List<Pattern> compiledPatterns = new LinkedList<>();
+    public static boolean mergeLogFiles(Map<String, InputStream> logFiles,
+        PrintWriter mergedFile, boolean tabOut, boolean suppressBlanks, boolean multithreaded,
+        List<String> patterns) {
+      List<Pattern> compiledPatterns = new LinkedList<Pattern>();
-        Reader oldest;
+        Reader oldest = null;
-        Reader nextInLine;
+        Reader nextInLine = null;
-        LogFileParser.LogEntry entry;
+        LogFileParser.LogEntry entry = null;
-    private static Set sortReaders(final Collection readers) {
+    private static Set sortReaders(Collection readers) {
+
-    @Override
-    public int compare(final Object o1, final Object o2) {
+    public int compare(Object o1, Object o2) {
+

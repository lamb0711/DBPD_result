Merge branch 'release/1.4.0'

-import org.apache.geode.cache.query.internal.InternalQueryService;
-import org.apache.geode.cache.query.internal.MethodInvocationAuthorizer;
-import org.apache.geode.cache.query.internal.RestrictedMethodInvocationAuthorizer;
-import org.apache.geode.internal.cache.event.EventTrackerExpiryTask;
-import org.apache.geode.internal.cache.wan.GatewaySenderQueueEntrySynchronizationListener;
-import org.apache.geode.internal.security.SecurityServiceFactory;
+import org.apache.geode.cache.query.internal.InternalQueryService;
+import org.apache.geode.internal.cache.backup.BackupManager;
+import org.apache.geode.internal.cache.event.EventTrackerExpiryTask;
+import org.apache.geode.internal.cache.eviction.HeapEvictor;
+import org.apache.geode.internal.cache.eviction.OffHeapEvictor;
-import org.apache.geode.internal.cache.lru.HeapEvictor;
-import org.apache.geode.internal.cache.lru.OffHeapEvictor;
+import org.apache.geode.internal.cache.wan.GatewaySenderQueueEntrySynchronizationListener;
+import org.apache.geode.internal.security.SecurityServiceFactory;
-   * 
+   *
-   * 
+   *
-   * 
+   *
+  private final ClusterConfigurationLoader ccLoader = new ClusterConfigurationLoader();
+
-   * 
+   *
-   * 
+   *
-   * 
+   *
-  /** Returns the last created instance of GemFireCache */
+  /**
+   * Returns the last created instance of GemFireCache
+   *
+   * @deprecated use DM.getCache instead
+   */
+  @Deprecated
-   * 
+   *
+   * @deprecated use DM.getExistingCache instead.
+  @Deprecated
+   * @deprecated use DM.getExistingCache instead.
+  @Deprecated
-   * 
+   *
-      ClusterConfigurationLoader.applyClusterPropertiesConfiguration(this.configurationResponse,
+      ccLoader.applyClusterPropertiesConfiguration(this.configurationResponse,
-   * 
+   *
-    // out
-    // if the locator is running in secure mode or not, if yes, then we need to throw an exception
-    // if server is not using cluster config
+    // out if the locator is running in secure mode or not, if yes, then we need to throw an
+    // exception if server is not using cluster config.
-    Map<InternalDistributedMember, Collection<String>> scl =
+    Map<InternalDistributedMember, Collection<String>> locatorsWithClusterConfig =
-    // without shared configuration
-    // then do not make requests to the locators
-    if (scl.isEmpty()) {
+    // without shared configuration then do not make requests to the locators.
+    if (locatorsWithClusterConfig.isEmpty()) {
-    List<String> locatorConnectionStrings = getSharedConfigLocatorConnectionStringList();
-
-      ConfigurationResponse response = ClusterConfigurationLoader
-          .requestConfigurationFromLocators(this.system.getConfig(), locatorConnectionStrings);
+      ConfigurationResponse response = ccLoader.requestConfigurationFromLocators(
+          this.system.getConfig().getGroups(), locatorsWithClusterConfig.keySet());
-  private List<String> getSharedConfigLocatorConnectionStringList() {
-    List<String> locatorConnectionStringList = new ArrayList<>();
-
-    Map<InternalDistributedMember, Collection<String>> locatorsWithClusterConfig =
-        getDistributionManager().getAllHostedLocatorsWithSharedConfiguration();
-
-    // If there are no locators with Shared configuration, that means the system has been started
-    // without shared configuration
-    // then do not make requests to the locators
-    if (!locatorsWithClusterConfig.isEmpty()) {
-      Set<Entry<InternalDistributedMember, Collection<String>>> locators =
-          locatorsWithClusterConfig.entrySet();
-
-      for (Entry<InternalDistributedMember, Collection<String>> loc : locators) {
-        Collection<String> locStrings = loc.getValue();
-        locatorConnectionStringList.addAll(locStrings);
-      }
-    }
-    return locatorConnectionStringList;
-  }
-
-      ClusterConfigurationLoader.deployJarsReceivedFromClusterConfiguration(this,
-          this.configurationResponse);
+      ccLoader.deployJarsReceivedFromClusterConfiguration(this.configurationResponse);
-      ClusterConfigurationLoader.applyClusterXmlConfiguration(this, this.configurationResponse,
-          this.system.getConfig());
+      ccLoader.applyClusterXmlConfiguration(this, this.configurationResponse,
+          this.system.getConfig().getGroups());
+    } catch (RuntimeException e) {
+      logger.error("Cache initialization failed because: " + e.toString()); // fix GEODE-3038
+      throw e;
+      logger.info("Initialized cache service {}", service.getClass().getName());
-   * 
+   *
-   * 
+   *
-          tx = this.transactionManager.internalSuspend();
+          tx = this.transactionManager.pauseTransaction();
-          this.transactionManager.internalResume(tx);
+          this.transactionManager.unpauseTransaction(tx);
-    return (Set<DistributedMember>) this.dm.getAdminMemberSet();
+    return (Set) this.dm.getAdminMemberSet();
-   * 
+   *
-   * 
+   *
-   * 
+   *
+  public void invokeBeforeDestroyed(LocalRegion region) {
+    for (RegionListener listener : this.regionListeners) {
+      listener.beforeDestroyed(region);
+    }
+  }
+
+  @Override
+  public void invokeCleanupFailedInitialization(LocalRegion region) {
+    for (RegionListener listener : this.regionListeners) {
+      listener.cleanupFailedInitialization(region);
+    }
+  }
+
+  @Override
-   * 
+   *
-   * 
+   *
-    return this.allVisibleAsyncEventQueues;
+    return getAsyncEventQueues(true);
+  }
+
+  @Override
+  public Set<AsyncEventQueue> getAsyncEventQueues(boolean visibleOnly) {
+    return visibleOnly ? this.allVisibleAsyncEventQueues : this.allAsyncEventQueues;
-   * 
+   *
+  @Override
+  public void setReadSerializedForCurrentThread(boolean value) {
+    PdxInstanceImpl.setPdxReadSerialized(value);
+    DefaultQuery.setPdxReadSerialized(value);
+  }
+
-  public void setReadSerialized(boolean value) {
+  public void setReadSerializedForTest(boolean value) {
-   * 
+   *

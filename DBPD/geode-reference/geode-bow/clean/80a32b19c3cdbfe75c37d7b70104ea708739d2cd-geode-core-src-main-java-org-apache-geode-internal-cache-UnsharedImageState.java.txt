 GEODE-6580: Cleanup static analyzer warnings. (#3415)


-import org.apache.logging.log4j.Logger;
-
-import org.apache.geode.cache.DiskAccessException;
-import org.apache.geode.internal.logging.LogService;
-  private static final Logger logger = LogService.getLogger();
-  private volatile ConcurrentMap destroyedEntryKeys;
+  private volatile ConcurrentMap<Object, Boolean> destroyedEntryKeys;
-  private volatile boolean mayDoRecovery = false;
+  private volatile boolean mayDoRecovery;
-  private volatile DiskAccessException dae = null;
-
-
-    this.riLock = isClient ? new StoppableReentrantReadWriteLock(stopper) : null;
-
-    this.giiLock = isReplicate ? new StoppableNonReentrantLock(stopper) : null;
-    this.destroyedEntryKeys = new ConcurrentHashMap();
+    riLock = isClient ? new StoppableReentrantReadWriteLock(stopper) : null;
+    giiLock = isReplicate ? new StoppableNonReentrantLock(stopper) : null;
+    destroyedEntryKeys = new ConcurrentHashMap<>();
-      this.inRecovery = true; // default to true to fix 41147
+      inRecovery = true; // default to true to fix 41147
-    return this.giiLock != null;
+    return giiLock != null;
-    return this.riLock != null;
+    return riLock != null;
-      this.wasRegionClearedDuringGII = false;
+      wasRegionClearedDuringGII = false;
-      return this.regionInvalidated;
+      return regionInvalidated;
-      this.regionInvalidated = b;
+      regionInvalidated = b;
-    if (this.mayDoRecovery) {
-      this.inRecovery = b;
+    if (mayDoRecovery) {
+      inRecovery = b;
-    if (this.mayDoRecovery) {
-      return this.inRecovery;
+    if (mayDoRecovery) {
+      return inRecovery;
-      this.destroyedEntryKeys.put(key, Boolean.TRUE);
+      destroyedEntryKeys.put(key, Boolean.TRUE);
-    this.destroyedEntryKeys.remove(key);
+    destroyedEntryKeys.remove(key);
-    return this.destroyedEntryKeys.containsKey(key);
+    return destroyedEntryKeys.containsKey(key);
-  public Iterator getDestroyedEntries() {
+  public Iterator<Object> getDestroyedEntries() {
-    Iterator result = this.destroyedEntryKeys.keySet().iterator();
-    this.destroyedEntryKeys = new ConcurrentHashMap();
+    Iterator<Object> result = destroyedEntryKeys.keySet().iterator();
+    destroyedEntryKeys = new ConcurrentHashMap<>();
-    this.versionTags = new ConcurrentHashSet<VersionTagEntry>(16);
+    versionTags = new ConcurrentHashSet<>(16);
-    this.versionTags.add(new VersionTagEntryImpl(key, tag.getMemberID(), tag.getRegionVersion()));
+    versionTags.add(new VersionTagEntryImpl(key, tag.getMemberID(), tag.getRegionVersion()));
-    Iterator<VersionTagEntry> result = this.versionTags.iterator();
+    Iterator<VersionTagEntry> result = versionTags.iterator();
-    this.leftMembers = new ConcurrentHashSet<VersionSource>(16);
+    leftMembers = new ConcurrentHashSet<>(16);
-    this.leftMembers.add(mbr);
+    leftMembers.add(mbr);
-    Set<VersionSource> result = this.leftMembers;
+    Set<VersionSource> result = leftMembers;
-    return this.leftMembers.size() > 0;
-  }
-
-  public void dumpDestroyedEntryKeys() {
-    if (this.destroyedEntryKeys == null) {
-      logger.info("region has no destroyedEntryKeys in its image state");
-    } else {
-      logger.info("dump of image state destroyed entry keys of size {}",
-          this.destroyedEntryKeys.size());
-      for (Iterator it = this.destroyedEntryKeys.keySet().iterator(); it.hasNext();) {
-        Object key = it.next();
-        logger.info("key={}", key);
-      }
-    }
+    return leftMembers.size() > 0;
-    return this.destroyedEntryKeys.size();
+    return destroyedEntryKeys.size();
-      this.clearRegionFlag = isClearOn;
+      clearRegionFlag = isClearOn;
-        this.clearRVV = rvv; // will be used to selectively clear content
-        this.wasRegionClearedDuringGII = true;
+        clearRVV = rvv; // will be used to selectively clear content
+        wasRegionClearedDuringGII = true;
-      return this.clearRegionFlag;
+      return clearRegionFlag;
-      return this.clearRVV;
+      return clearRVV;
-      boolean result = this.wasRegionClearedDuringGII;
+      boolean result = wasRegionClearedDuringGII;
-        this.wasRegionClearedDuringGII = false;
+        wasRegionClearedDuringGII = false;
-    this.giiLock.lock();
+    giiLock.lock();
-    this.giiLock.unlock();
+    giiLock.unlock();
-    this.riLock.readLock().lock();
+    riLock.readLock().lock();
-    this.riLock.readLock().unlock();
+    riLock.readLock().unlock();
-    this.riLock.writeLock().lock();
+    riLock.writeLock().lock();
-    this.riLock.writeLock().unlock();
+    riLock.writeLock().unlock();

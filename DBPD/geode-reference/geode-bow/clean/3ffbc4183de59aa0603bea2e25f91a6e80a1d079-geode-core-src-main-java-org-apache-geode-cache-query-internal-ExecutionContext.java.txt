GEODE-6488: Migrating cancellation state to execution context (#3322)

This work solves two problems.  One is that the query cancellation task
reference in DefaultQuery could be overwritten and thus never removed
from monitoring upon successful completion of a query.  Second is that
once a query execution timed out once, the query object was in an
unusable state which is undesirable.

The solution is to attach the cancellation state to the execution
context rather than the query object, so that cancellation is associated
with each independent execution of a query rather than having
cancellation state that applies to the entire query object.
+import java.util.Optional;
+import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.apache.geode.cache.CacheRuntimeException;
+  private Optional<ScheduledFuture> cancelationTask;
+  private volatile CacheRuntimeException canceledException;
+  static final ThreadLocal<AtomicBoolean> isCanceled =
+      ThreadLocal.withInitial(AtomicBoolean::new);
+
+    this.cancelationTask = Optional.empty();
+  }
+
+  Optional<ScheduledFuture> getCancelationTask() {
+    return cancelationTask;
+  }
+
+  void setCancelationTask(final ScheduledFuture cancelationTask) {
+    this.cancelationTask = Optional.of(cancelationTask);
-  public void setCqQueryContext(boolean cqQuery) {
-    throw new UnsupportedOperationException("Method should not have been called");
-  }
-
+  /**
+   * Check to see if the query execution was canceled. The query gets canceled by the QueryMonitor
+   * if it takes more than the max query execution time or low memory situations
+   */
+  public boolean isCanceled() {
+    return getQueryCanceledException() != null;
+  }
+
+  public CacheRuntimeException getQueryCanceledException() {
+    return canceledException;
+  }
+
+  public void setQueryCanceledException(final CacheRuntimeException queryCanceledException) {
+    this.canceledException = queryCanceledException;
+  }
+
+  /**
+   * This method attempts to reintrepret a {@link QueryExecutionCanceledException} using the
+   * the value returned by {@link #getQueryCanceledException} (set by the {@link QueryMonitor}).
+   *
+   * @throws if {@link #getQueryCanceledException} doesn't return {@code null} then throw that
+   *         {@link CacheRuntimeException}, otherwise throw {@link QueryExecutionCanceledException}
+   */
+  Object reinterpretQueryExecutionCanceledException() {
+    final CacheRuntimeException queryCanceledException = getQueryCanceledException();
+    if (queryCanceledException != null) {
+      throw queryCanceledException;
+    } else {
+      throw new QueryExecutionCanceledException(
+          "Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
+    }
+  }

Merge branch 'release/1.0.0-incubating.M3'

+import static com.gemstone.gemfire.distributed.ConfigurationProperties.LOCATORS;
+import static com.gemstone.gemfire.distributed.ConfigurationProperties.START_LOCATOR;
-  public static final String BYPASS_DISCOVERY_PROPERTY = "gemfire.bypass-discovery";
+  public static final String BYPASS_DISCOVERY_PROPERTY = DistributionConfig.GEMFIRE_PREFIX + "bypass-discovery";
-  private static final int DISCOVERY_TIMEOUT = Integer.getInteger("gemfire.discovery-timeout", 3000);
+  private static final int DISCOVERY_TIMEOUT = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "discovery-timeout", 3000);
-  private static final int JOIN_RETRY_SLEEP = Integer.getInteger("gemfire.join-retry-sleep", 1000);
+  private static final int JOIN_RETRY_SLEEP = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "join-retry-sleep", 1000);
-  private static final long BROADCAST_MESSAGE_SLEEP_TIME = Long.getLong("gemfire.broadcast-message-sleep-time", 1000);
+  private static final long BROADCAST_MESSAGE_SLEEP_TIME = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "broadcast-message-sleep-time", 1000);
-  private static final int MAX_DISCOVERY_NODES = Integer.getInteger("gemfire.max-discovery-nodes", 30);
+  private static final int MAX_DISCOVERY_NODES = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "max-discovery-nodes", 30);
-  private static final long VIEW_BROADCAST_INTERVAL = Long.getLong("gemfire.view-broadcast-interval", 60000);
+  private static final long VIEW_BROADCAST_INTERVAL = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "view-broadcast-interval", 60000);
-
-    if (response.getCurrentView() == null) {
-      logger.info("received join response with no membership view: {}", response);
-      return isJoined;
-    }
-
-    this.birthViewId = response.getMemberID().getVmViewId();
-    this.localAddress.setVmViewId(this.birthViewId);
-    GMSMember me = (GMSMember) this.localAddress.getNetMember();
-    me.setBirthViewId(birthViewId);
-    installView(response.getCurrentView());
-    return true;
+    
+    //there is no way we can rech here right now
+    throw new RuntimeException("Join Request Failed with response " + joinResponse );
+      
+      if (response != null && response.getCurrentView() != null && !isJoined) {
+        //reset joinResponse[0]
+        joinResponse[0] = null;
+        // we got view here that means either we have to wait for
+        NetView v = response.getCurrentView();
+        InternalDistributedMember coord = v.getCoordinator();
+        if (searchState.alreadyTried.contains(coord)) {
+          // we already sent join request to it..so lets wait some more time here
+          // assuming we got this response immediately, so wait for same timeout here..
+          long timeout = Math.max(services.getConfig().getMemberTimeout(), services.getConfig().getJoinTimeout() / 5);
+          joinResponse.wait(timeout);
+          response = joinResponse[0];
+        } else {
+          // try on this coordinator
+          searchState.possibleCoordinator = coord;
+          response = null;
+        }
+        searchState.view = v;
+      }
+      if (isJoined) {
+        return null;
+      }
-      rejection = services.getAuthenticator().authenticate(incomingRequest.getMemberID(), creds);
+      rejection = services.getAuthenticator().authenticate(incomingRequest.getMemberID(), (Properties)creds);
-      e.printStackTrace();
-      logger.debug("JoinLeave is checking to see if I should become coordinator");
+      logger.debug("Checking to see if I should become coordinator");
-      logger.debug("JoinLeave is checking to see if I should become coordinator");
+      logger.debug("Checking to see if I should become coordinator");
-    logger.debug("JoinLeave is recording the request to be processed in the next membership view");
+    logger.debug("Recording the request to be processed in the next membership view");
+    if (viewCreator != null) {
+      viewCreator.informToPendingJoinRequests();
+    }
-  private void sendRemoveMessages(List<InternalDistributedMember> removals, List<String> reasons, NetView newView) {
-    Iterator<String> reason = reasons.iterator();
-    for (InternalDistributedMember mbr : removals) {
-      RemoveMemberMessage response = new RemoveMemberMessage(mbr, mbr, reason.next());
+  private void sendJoinResponses(NetView newView, List<InternalDistributedMember> newMbrs) {
+    for (InternalDistributedMember mbr : newMbrs) {
+      JoinResponseMessage response = new JoinResponseMessage(mbr, newView);
-  boolean prepareView(NetView view, List<InternalDistributedMember> newMembers) {
+  private void sendRemoveMessages(List<InternalDistributedMember> removals, List<String> reasons, NetView newView, Set<InternalDistributedMember> oldIds) {
+    Iterator<String> reason = reasons.iterator();
+    for (InternalDistributedMember mbr : removals) {
+      //if olds not contains mbr then send remove request 
+      if (!oldIds.contains(mbr)) {
+        RemoveMemberMessage response = new RemoveMemberMessage(mbr, mbr, reason.next());
+        services.getMessenger().send(response);
+      } else {
+        reason.next();
+      }
+    }
+  }
+
+  boolean prepareView(NetView view, List<InternalDistributedMember> newMembers) throws InterruptedException {
-  void sendView(NetView view, List<InternalDistributedMember> newMembers) {
+  void sendView(NetView view, List<InternalDistributedMember> newMembers) throws InterruptedException {
-  private boolean sendView(NetView view, List<InternalDistributedMember> newMembers, boolean preparing, ViewReplyProcessor viewReplyProcessor) {
+  private boolean sendView(NetView view, List<InternalDistributedMember> newMembers, boolean preparing,
+      ViewReplyProcessor viewReplyProcessor) throws InterruptedException {
-      logger.info("no recipients for new view aside from myself");
+      if (!preparing) {
+        logger.info("no recipients for new view aside from myself");
+      }
-      if (!failedToRespond.isEmpty() && (services.getCancelCriterion().cancelInProgress() == null)) {
+      if (!failedToRespond.isEmpty() && (!services.getCancelCriterion().isCancelInProgress())) {
-    boolean flagsSet = false;
-              if (!flagsSet) {
-                flagsSet = true;
-                inheritSettingsFromLocator(addr, response);
-              }
-   * Some settings are gleaned from locator responses and set into the local
-   * configuration
-   */
-  private void inheritSettingsFromLocator(InetSocketAddress addr, FindCoordinatorResponse response) {
-    boolean enabled = response.isNetworkPartitionDetectionEnabled();
-    if (!enabled && services.getConfig().isNetworkPartitionDetectionEnabled()) {
-      throw new GemFireConfigException("locator at " + addr
-          + " does not have network-partition-detection enabled but my configuration has it enabled");
-    }
-
-    GMSMember mbr = (GMSMember) this.localAddress.getNetMember();
-    mbr.setSplitBrainEnabled(enabled);
-    services.getConfig().setNetworkPartitionDetectionEnabled(enabled);
-    services.getConfig().getDistributionConfig().setEnableNetworkPartitionDetection(enabled);
-
-    if (response.isUsePreferredCoordinators()) {
-      this.quorumRequired = enabled;
-      logger.debug("The locator indicates that all locators should be preferred as coordinators");
-      if (services.getLocator() != null
-          || Locator.hasLocator()
-          || !services.getConfig().getDistributionConfig().getStartLocator().isEmpty()
-          || localAddress.getVmKind() == DistributionManager.LOCATOR_DM_TYPE) {
-        ((GMSMember) localAddress.getNetMember()).setPreferredForCoordinator(true);
-      }
-    } else {
-      ((GMSMember) localAddress.getNetMember()).setPreferredForCoordinator(true);
-    }
-  }
-
-  /**
-      joinResponse[0] = rsp;
-      joinResponse.notifyAll();
+      if (!this.isJoined) {
+        joinResponse[0] = rsp;
+        joinResponse.notifyAll();
+      }
+      searchState.responses.notifyAll();
-            me.setSplitBrainEnabled(mbr.getNetMember().splitBrainEnabled());
+    GMSMember mbr = (GMSMember)this.localAddress.getNetMember();
+
+    if (services.getConfig().areLocatorsPreferredAsCoordinators()) {
+      boolean preferred = false;
+      if (services.getLocator() != null
+              || Locator.hasLocator()
+              || !services.getConfig().getDistributionConfig().getStartLocator().isEmpty()
+              || localAddress.getVmKind() == DistributionManager.LOCATOR_DM_TYPE) {
+        logger.info("This member is hosting a locator will be preferred as a membership coordinator");
+        preferred = true;
+      }
+      mbr.setPreferredForCoordinator(preferred);
+    } else {
+      mbr.setPreferredForCoordinator(true);
+    }
-          logger.debug("JoinLeave sending a leave request to {}", coords);
+          logger.debug("Sending my leave request to {}", coords);
-              + DistributionConfig.LOCATORS_NAME + " or " + DistributionConfig.START_LOCATOR_NAME + ".");
+              + LOCATORS + " or " + START_LOCATOR + ".");
-    ackCollectionTimeout = Integer.getInteger("gemfire.VIEW_ACK_TIMEOUT", ackCollectionTimeout).intValue();
+    ackCollectionTimeout = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "VIEW_ACK_TIMEOUT", ackCollectionTimeout).intValue();
-    Set<InternalDistributedMember> waitForResponses() {
-      Set<InternalDistributedMember> result = this.notRepliedYet;
+    Set<InternalDistributedMember> waitForResponses() throws InterruptedException {
+      Set<InternalDistributedMember> result = null;
-        while (System.currentTimeMillis() < endOfWait && (services.getCancelCriterion().cancelInProgress() == null)) {
+        while (System.currentTimeMillis() < endOfWait && (!services.getCancelCriterion().isCancelInProgress())) {
-              if (!waiting || result.isEmpty() || this.conflictingView != null) {
+              if (!waiting || this.notRepliedYet.isEmpty() || this.conflictingView != null) {
-            Thread.currentThread().interrupt();
-            return result;
+            throw e;
-            result = pendingRemovals;
+            result = new HashSet<>(pendingRemovals);
+            result = new HashSet<>(this.notRepliedYet);
-    Set<InternalDistributedMember> getUnresponsiveMembers() {
-      return this.notRepliedYet;
+    synchronized Set<InternalDistributedMember> getUnresponsiveMembers() {
+      return new HashSet<>(this.notRepliedYet);
-    boolean shutdown = false;
+    volatile boolean shutdown = false;
-      if (initialView == null) {
-        return;
-      }
-      NetView v = preparedView;
-      if (v != null) {
-        processPreparedView(v);
-      }
-        NetView iView;
-        List<InternalDistributedMember> iJoins;
-        Set<InternalDistributedMember> iLeaves;
-        Set<InternalDistributedMember> iRemoves;
-        synchronized (this) {
-          iView = initialView;
-          iJoins = initialJoins;
-          iLeaves = initialLeaving;
-          iRemoves = initialRemovals;
+        if (initialView == null) {
+          return;
-        if (iView != null) {
-          prepareAndSendView(iView, iJoins, iLeaves, iRemoves);
+        NetView v = preparedView;
+        if (v != null) {
+          processPreparedView(v);
-      } finally {
-        setInitialView(null, null, null, null);
+        try {
+          NetView iView;
+          List<InternalDistributedMember> iJoins;
+          Set<InternalDistributedMember> iLeaves;
+          Set<InternalDistributedMember> iRemoves;
+          synchronized (this) {
+            iView = initialView;
+            iJoins = initialJoins;
+            iLeaves = initialLeaving;
+            iRemoves = initialRemovals;
+          }
+          if (iView != null) {
+            prepareAndSendView(iView, iJoins, iLeaves, iRemoves);
+          }
+        } finally {
+          setInitialView(null, null, null, null);
+        }
+      } catch (InterruptedException e) {
+        shutdown = true;
+            } catch (InterruptedException e) {
+              shutdown = true;
+        informToPendingJoinRequests();
+      }
+    }
+    
+    synchronized void informToPendingJoinRequests() {
+      if (!shutdown) {
+        return;
+      }
+
+      ArrayList<DistributionMessage> requests = new ArrayList<>();
+      synchronized (viewRequests) {
+        if (viewRequests.size() > 0) {
+          requests.addAll(viewRequests);
+        } else {
+          return;
+        }
+        viewRequests.clear();
+      }
+
+      for (DistributionMessage msg : requests) {
+        switch (msg.getDSFID()) {
+        case JOIN_REQUEST:
+          logger.info("Informing to pending join requests {}", msg);
+
+          NetView v = currentView;
+          if (!v.getCoordinator().equals(localAddress)) {
+            //lets inform that coordinator has been changed
+            JoinResponseMessage jrm = new JoinResponseMessage(((JoinRequestMessage) msg).getMemberID(), v);
+            services.getMessenger().send(jrm);
+          }
+        default:
+          break;
+        }
+     * @throws InterruptedException 
-    void createAndSendView(List<DistributionMessage> requests) {
+    void createAndSendView(List<DistributionMessage> requests) throws InterruptedException {
-                  Collections.<String>singletonList(((RemoveMemberMessage) msg).getReason()), currentView);
+                  Collections.<String>singletonList(((RemoveMemberMessage) msg).getReason()), 
+                  currentView,
+                  new HashSet<InternalDistributedMember>());
-        mbr.getNetMember().setSplitBrainEnabled(services.getConfig().isNetworkPartitionDetectionEnabled());
-      sendRemoveMessages(removalReqs, removalReasons, newView);
+      sendRemoveMessages(removalReqs, removalReasons, newView, oldIDs);
+     * @throws InterruptedException 
-        Set<InternalDistributedMember> removalReqs) {
+        Set<InternalDistributedMember> removalReqs) throws InterruptedException {
-          try {
-            Thread.sleep(BROADCAST_MESSAGE_SLEEP_TIME);
-          } catch (InterruptedException e) {
-            // signal the run() method to exit
-            shutdown = true;
-            return;
-          }
+          Thread.sleep(BROADCAST_MESSAGE_SLEEP_TIME);
+          
-          try {
-            removeHealthyMembers(unresponsive);
-          } catch (InterruptedException e) {
-            // abort the view if interrupted
-            shutdown = true;
-            return;
+          removeHealthyMembers(unresponsive);
+          synchronized (viewRequests) {
+            //now lets get copy of it in viewRequests sync, as other thread might be accessing it 
+            unresponsive = new HashSet<>(unresponsive);
-          sendRemoveMessages(failures, reasons, newView);
+          sendRemoveMessages(failures, reasons, newView, new HashSet<InternalDistributedMember>());
+      // we also send a join response so that information like the multicast message digest
+      // can be transmitted to the new members w/o including it in the view message
+      sendJoinResponses(newView, joinReqs);
+

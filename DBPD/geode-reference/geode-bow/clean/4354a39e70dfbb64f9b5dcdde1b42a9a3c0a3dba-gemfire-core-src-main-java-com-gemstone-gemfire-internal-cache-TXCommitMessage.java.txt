GEODE-16 [DISTTX] Bringing pending changes for distributed transactions (still work in progress) from one of the internal gemfire branch (develop_dist_tx) to ASF i.e.

2053a3ae by vbhaskar
[DISTTX] Fixed a PutAll issue related to DistTxStateOnCoordinator when txState is set null in tx-manager during (pre)commit.
    There is a related issue in removeall that also need to be fixed. Added test for same.

ccdf76d5 by sjigyasu
Added a test for concurrent tx and non tx ops.

61a536a0 by sjigyasu
Added WAN test for distributed tx (disabled)

9e6c1b8e by sjigyasu
Changes for adjunct messaging for serial WAN.  For details read comments in DistTXState commit.

3d5c4f84 by vbhaskar
[DISTTX] Fixed an remoteall issue and enabled respective testcase.

226bf623 by shirishd
[DISTTX] Test changes only
Removed @Category and @Ignore Junit4 unsupported tags from disttx dunit tests

9fdfbe2c by shirishd
[DISTTX] Test change only
Remove few more @Category tags from dist tx dunit tests

ea00015c by shirishd
[DISTTX] Added entries for tests

f74a12b3 by shirishd
[DISTTX] Enabling few more existing tests with "distributed-transactions" set to true

b52ee0c5 by vivek bhaskar
[DISTTX] On Tx Coordinator, verify if there any change of region distribution.

a480794c by shirishd
[DISTTX] Some tests for conflict detection at commit time

be3dd356 by vivek bhaskar
[DISTTX] Clean txState even if final commit fails.

95ba17f9 by shirishd
[DISTTX] Added tests for conflict detection at commit time

cd50dbbc by shirishd
[DISTTX] Optimization in DistTxEntryEvent toData/fromData

Tests:
DUnits and Junits for Distributed Transactions

-public final class TXCommitMessage extends PooledDistributionMessage implements MembershipListener, MessageWithReply
+public class TXCommitMessage extends PooledDistributionMessage implements MembershipListener, MessageWithReply
-
+  
-  private transient ArrayList farSideEntryOps;
+  protected transient ArrayList farSideEntryOps;
-  private void processCacheRuntimeException(CacheRuntimeException problem) {
+  protected void processCacheRuntimeException(CacheRuntimeException problem) {
+
+    /**
+     * Apply a single tx entry op on the far side
+     */
+    @SuppressWarnings("synthetic-access")
+    protected void txApplyEntryOpAdjunctOnly(FarSideEntryOp entryOp)
+    {
+      if (this.r == null) {
+        return;
+      }
+      EventID eventID = getEventId(entryOp);
+      boolean isDuplicate = this.r.hasSeenEvent(eventID);
+      boolean callbacksOnly = (this.r.getDataPolicy() == DataPolicy.PARTITION)
+          || isDuplicate;
+      if (this.r instanceof PartitionedRegion) {
+        
+        PartitionedRegion pr = (PartitionedRegion)r;
+        BucketRegion br = pr.getBucketRegion(entryOp.key);
+        Set bucketOwners = br.getBucketOwners();
+        InternalDistributedMember thisMember = GemFireCacheImpl.getExisting().getDistributionManager().getId();
+        if (bucketOwners.contains(thisMember)) {
+          return;
+        }
+        
+        /*
+         * This happens when we don't have the bucket and are getting adjunct notification
+         */
+        EntryEventImpl eei = AbstractRegionMap.createCBEvent(this.r, entryOp.op, entryOp.key, entryOp.value, this.msg.txIdent, txEvent, getEventId(entryOp), entryOp.callbackArg,entryOp.filterRoutingInfo,this.msg.bridgeContext, null, entryOp.versionTag, entryOp.tailKey);
+        try {
+        if(entryOp.filterRoutingInfo!=null) {
+          eei.setLocalFilterInfo(entryOp.filterRoutingInfo.getFilterInfo(this.r.getCache().getMyId()));
+        }
+        if (isDuplicate) {
+          eei.setPossibleDuplicate(true);
+        }
+        if (logger.isDebugEnabled()) {
+          logger.debug("invoking transactional callbacks for {} key={} needsUnlock={} event={}", entryOp.op, entryOp.key, this.needsUnlock, eei);
+        }
+        // we reach this spot because the event is either delivered to this member
+        // as an "adjunct" message or because the bucket was being created when
+        // the message was sent and already reflects the change caused by this event.
+        // In the latter case we need to invoke listeners
+        final boolean skipListeners = !isDuplicate;
+        eei.invokeCallbacks(this.r, skipListeners, true);
+        } finally {
+          eei.release();
+        }
+        return;
+      }
+    }
+
+    
+      public void processAdjunctOnly() {
+        txApplyEntryOpAdjunctOnly(this);
+      }
+      

GEODE-6588: Properly type Function execution related interfaces. (#3691)

Co-authored-by: Joris Melchior <joris.melchior@gmail.com>
Co-authored-by: Peter Tran <ptran@gmail.com>

* Extensions and implementations of Execution and ResultCollector and the 
classes and interfaces involved in the execution chain were lacking the
ability to apply Generic types.
* Typing issues starting from MemberConfigManager.java class were fixed.
* Trivial IDE warnings were fixed.
-public abstract class AbstractExecution implements InternalExecution {
+public abstract class AbstractExecution<ArgumentT, ReturnT, AggregatorT>
+    implements InternalExecution<ArgumentT, ReturnT, AggregatorT> {
-  protected Set<String> failedNodes = new HashSet<String>();
+  protected Set<String> failedNodes = new HashSet<>();
-      new ConcurrentHashMap<String, byte[]>();
+      new ConcurrentHashMap<>();
-  public AbstractExecution setIsReExecute() {
+  public AbstractExecution<ArgumentT, ReturnT, AggregatorT> setIsReExecute() {
-      if (ServerConnection.isExecuteFunctionOnLocalNodeOnly().byteValue() == 1) {
+      if (ServerConnection.isExecuteFunctionOnLocalNodeOnly() == 1) {
-        newDM.getFunctionExecutor().execute(new Runnable() {
-          @Override
-          public void run() {
-            executeFunctionLocally(fn, cx, sender, newDM);
-            if (!sender.isLastResultReceived() && fn.hasResult()) {
-              ((InternalResultSender) sender).setException(new FunctionException(
-                  String.format("The function, %s, did not send last result",
-                      fn.getId())));
-            }
+        newDM.getFunctionExecutor().execute(() -> {
+          executeFunctionLocally(fn, cx, sender, newDM);
+          if (!sender.isLastResultReceived() && fn.hasResult()) {
+            ((InternalResultSender) sender).setException(new FunctionException(
+                String.format("The function, %s, did not send last result",
+                    fn.getId())));
-      newDM.getFunctionExecutor().execute(new Runnable() {
-        @Override
-        public void run() {
-          executeFunctionLocally(fn, cx, sender, newDM);
-          if (!((InternalResultSender) sender).isLastResultReceived() && fn.hasResult()) {
-            ((InternalResultSender) sender).setException(new FunctionException(
-                String.format("The function, %s, did not send last result",
-                    fn.getId())));
-          }
+      newDM.getFunctionExecutor().execute(() -> {
+        executeFunctionLocally(fn, cx, sender, newDM);
+        if (!((InternalResultSender) sender).isLastResultReceived() && fn.hasResult()) {
+          ((InternalResultSender) sender).setException(new FunctionException(
+              String.format("The function, %s, did not send last result",
+                  fn.getId())));
-      FunctionException functionException = null;
+      FunctionException functionException;
-      FunctionException functionException = null;
+      FunctionException functionException;
-  public ResultCollector execute(final String functionName) {
+  public ResultCollector<ReturnT, AggregatorT> execute(final String functionName) {
-  public ResultCollector execute(Function function) throws FunctionException {
+  public ResultCollector<ReturnT, AggregatorT> execute(Function function) throws FunctionException {
-  protected abstract ResultCollector executeFunction(Function fn);
+  protected abstract ResultCollector<ReturnT, AggregatorT> executeFunction(Function fn);
-  public LocalResultCollector<?, ?> getLocalResultCollector(Function function,
-      final ResultCollector<?, ?> rc) {
+  public LocalResultCollector<ReturnT, AggregatorT> getLocalResultCollector(Function function,
+      final ResultCollector<ReturnT, AggregatorT> rc) {

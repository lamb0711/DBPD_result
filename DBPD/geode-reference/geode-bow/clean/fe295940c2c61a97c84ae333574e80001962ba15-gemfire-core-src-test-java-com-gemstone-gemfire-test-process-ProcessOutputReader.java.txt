GEODE-291: Prevent stderr noise from com.gemstone.gemfire.test.process

Change classes in com.gemstone.gemfire.test.process package:

* Remove unused methods and variables..

* Change waitFor() to match the Process.waitFor(long, TimeUnit) method in
JDK 1.8. Pass in timeout parameters from ProcessWrapper instead of
hardcoding it.

* Separate waitFor() into waitFor(long, TimeUnit) and start(). Previously
waitFor() was performing both of these actions.

* Improve debugging by: 1) adding minor lifecycle to ProcessOutputReader,
2) include command string in stack trace of ProcessStreamReader. This
enabled identification of the source of unwanted stderr output.

Change DistributedSystem to enable testing:

* Change DistributedSystem to enable better unit testing by allowing tests
to provide different locations for gemfire.properties with
gemfirePropertyFile. Make same changes for gfsecurity.properties and
gemfireSecurityPropertyFile.

* Create unit and integration tests for DistributedSystem class.

Change tests that use com.gemstone.gemfire.test.process package:

* Use DistributedSystem.PROPERTIES_FILE_PROPERTY to override location of
gemfire.properties.

* Separate integration tests from UnitTest files to IntegrationTests.

* Add and use Catch-Exception for better unit testing.

* Remove unused code and class.

-import java.util.List;
+import java.util.concurrent.TimeUnit;
- * Reads the stdout and stderr from a running process and stores then for test 
- * validation. Also provides a mechanism to waitFor the process to terminate. 
+ * Starts the stdout and stderr reader threads for a running process. Provides
+ * a mechanism to waitFor the process to terminate.
+ * </p>
-  private static final long PROCESS_TIMEOUT_MILLIS = 10 * 60 * 1000L; // 10 minutes
-
-  private int exitCode;
+  private boolean started;
-  private final Process p;
+  private final Process process;
-  private final List<String> lines;
-  public ProcessOutputReader(final Process p, final ProcessStreamReader stdout, final ProcessStreamReader stderr, final List<String> lines) {
-    this.p = p;
+  public ProcessOutputReader(final Process process, final ProcessStreamReader stdout, final ProcessStreamReader stderr) {
+    this.process = process;
-    this.lines = lines;
+  }
+
+  public void start() {
+    synchronized(this) {
+      this.stdout.start();
+      this.stderr.start();
+      this.started = true;
+    }
-  public void waitFor() {
-    stdout.start();
-    stderr.start();
-
-    long startMillis = System.currentTimeMillis();
-    try {
-      stderr.join(PROCESS_TIMEOUT_MILLIS);
-    } catch (Exception ignore) {
-    }
-
-    long timeLeft = System.currentTimeMillis() + PROCESS_TIMEOUT_MILLIS - startMillis;
-    try {
-      stdout.join(timeLeft);
-    } catch (Exception ignore) {
-    }
-
-    this.exitCode = 0;
-    int retryCount = 9;
-    while (retryCount > 0) {
-      retryCount--;
-      try {
-        exitCode = p.exitValue();
-        break;
-      } catch (IllegalThreadStateException e) {
-        // due to bugs in Process we may not be able to get
-        // a process's exit value.
-        // We can't use Process.waitFor() because it can hang forever
-        if (retryCount == 0) {
-          if (stderr.linecount > 0) {
-            // The process wrote to stderr so manufacture
-            // an error exist code
-            synchronized (lines) {
-              lines.add("Failed to get exit status and it wrote"
-                  + " to stderr so setting exit status to 1.");
-            }
-            exitCode = 1;
-          }
-        } else {
-          // We need to wait around to give a chance for
-          // the child to be reaped.See bug 19682
-          try {
-            Thread.sleep(1000);
-          } catch (InterruptedException ignore) {
-          }
-        }
+  public boolean waitFor(final long timeout, final TimeUnit unit) throws InterruptedException {
+    synchronized(this) {
+      if (!this.started) {
+        throw new IllegalStateException("Must be started before waitFor");
+    
+    final long startTime = System.nanoTime();
+    
+    long millisToJoin = unit.toMillis(timeout);
+    this.stderr.join(millisToJoin);
+
+    long nanosRemaining = unit.toNanos(timeout) - (System.nanoTime() - startTime);
+    millisToJoin = unit.toMillis(nanosRemaining);
+    this.stdout.join(millisToJoin);
+
+    nanosRemaining = unit.toNanos(timeout) - (System.nanoTime() - startTime);
+    return waitForProcess(nanosRemaining, unit);
-  public int getExitCode() {
-    return exitCode;
+  private boolean waitForProcess(final long timeout, final TimeUnit unit) throws InterruptedException {
+    long startTime = System.nanoTime();
+    long nanosRemaining = unit.toNanos(timeout);
+
+    while (nanosRemaining > 0) {
+      try {
+        this.process.exitValue();
+        return true;
+      } catch(IllegalThreadStateException ex) {
+        if (nanosRemaining > 0) {
+          long millisToSleep =Math.min(TimeUnit.NANOSECONDS.toMillis(nanosRemaining) + 1, 100);
+          Thread.sleep(millisToSleep);
+        }
+      }
+      nanosRemaining = unit.toNanos(timeout) - (System.nanoTime() - startTime);
+    }
+    return false;

GEODE-3096: pulling in refactoring work on HttpOperationInvoker

* Use HttpOperationInvoker to replace RestHttpOperationInvoker and SimpleHttpOperationInvoker
* Use one single ShellCommandController to replace all command controllers
* do not allow execution of commands that require client side file data gathering to be executed only on the locator/server
* deprecate CommandService and CommandStatement
* simplify CommandRequest, delete geode's ClientHttpRequest
* fix tests

-import org.springframework.util.ReflectionUtils;
-import org.apache.geode.management.cli.CommandProcessingException;
+import org.apache.geode.management.internal.cli.remote.CommandExecutor;
- * Defines the {@link ExecutionStrategy} for commands that are executed in GemFire SHell (gfsh).
- * 
+ * Defines the {@link ExecutionStrategy} for commands that are executed in GemFire Shell (gfsh).
-  //////////////// ExecutionStrategy interface Methods Start ///////////////////
-  ///////////////////////// Implemented Methods ////////////////////////////////
-    Result result = null;
+    Result result;
-    try {
-      // check if it's a shell only command
-      if (isShellOnly(method)) {
-        Assert.notNull(parseResult, "Parse result required");
-        synchronized (mutex) {
-          Assert.isTrue(isReadyForCommands(),
-              "ProcessManagerHostedExecutionStrategy not yet ready for commands");
-          return ReflectionUtils.invokeMethod(parseResult.getMethod(), parseResult.getInstance(),
-              parseResult.getArguments());
-        }
-      }
+    // check if it's a shell only command
+    if (isShellOnly(method)) {
+      Assert.notNull(parseResult, "Parse result required");
+      synchronized (mutex) {
+        Assert.isTrue(isReadyForCommands(), "Not yet ready for commands");
-      // check if it's a GfshParseResult
-      if (!GfshParseResult.class.isInstance(parseResult)) {
-        throw new IllegalStateException("Configuration error!");
+        return new CommandExecutor().execute(parseResult);
-
-      result = executeOnRemote((GfshParseResult) parseResult);
-    } catch (NotAuthorizedException e) {
-      result = ResultBuilder
-          .createGemFireUnAuthorizedErrorResult("Unauthorized. Reason: " + e.getMessage());
-    } catch (JMXInvocationException | IllegalStateException e) {
-      Gfsh.getCurrentInstance().logWarning(e.getMessage(), e);
-    } catch (CommandProcessingException e) {
-      Gfsh.getCurrentInstance().logWarning(e.getMessage(), null);
-      Object errorData = e.getErrorData();
-      if (errorData != null && errorData instanceof Throwable) {
-        logWrapper.warning(e.getMessage(), (Throwable) errorData);
-      } else {
-        logWrapper.warning(e.getMessage());
-      }
-    } catch (Exception e) {
-      Gfsh.getCurrentInstance().logWarning("Unexpected exception occurred. " + e.getMessage(), e);
-      // Log other exceptions in gfsh log
-      logWrapper.warning("Unexpected error occurred while executing command : "
-          + ((GfshParseResult) parseResult).getUserInput(), e);
+
+    // check if it's a GfshParseResult
+    if (!GfshParseResult.class.isInstance(parseResult)) {
+      throw new IllegalStateException("Configuration error!");
+    }
+
+    result = executeOnRemote((GfshParseResult) parseResult);
-  //////////////// ExecutionStrategy interface Methods End /////////////////////
-   * @param parseResult
-   * 
-   * 
+    Path tempFile = null;
-      if (interceptor != null) {
-        Result preExecResult = interceptor.preExecution(parseResult);
-        if (Status.ERROR.equals(preExecResult.getStatus())) {
-          return preExecResult;
-        } else if (preExecResult instanceof FileResult) {
-          FileResult fileResult = (FileResult) preExecResult;
-          fileData = fileResult.toBytes();
-        }
-      } else {
+
+      if (interceptor == null) {
+
+      Result preExecResult = interceptor.preExecution(parseResult);
+      if (Status.ERROR.equals(preExecResult.getStatus())) {
+        return preExecResult;
+      }
+
+      // when the preExecution yields a FileResult, we will get the fileData out of it
+      if (preExecResult instanceof FileResult) {
+        FileResult fileResult = (FileResult) preExecResult;
+        fileData = fileResult.toBytes();
+      }
+      if (response == null) {
+        return ResultBuilder
+            .createBadResponseErrorResult("Response was null for: " + parseResult.getUserInput());
+      }
+      e.printStackTrace();
+      return ResultBuilder.createBadResponseErrorResult(
+          "Error occurred while executing \"" + parseResult.getUserInput() + "\" on manager.");
-    if (response == null) {
-      shell.logWarning("Response was null for: \"" + parseResult.getUserInput()
-          + "\". (gfsh.isConnected=" + shell.isConnectedAndReady() + ")", null);
-      return ResultBuilder.createBadResponseErrorResult(
-          " Error occurred while " + "executing \"" + parseResult.getUserInput() + "\" on manager. "
-              + "Please check manager logs for error.");
-    }
-
-    }
-
-    Path tempFile = null;
-    if (response instanceof Path) {
+    } else if (response instanceof Path) {
+    if (commandResult == null) {
+      commandResult = ResultBuilder
+          .createGemFireErrorResult("Unable to build commandResult using the remote response.");
+    }
+

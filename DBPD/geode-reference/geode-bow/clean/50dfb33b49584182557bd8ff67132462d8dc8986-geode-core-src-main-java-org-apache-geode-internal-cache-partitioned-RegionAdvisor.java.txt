GEODE-6588: Cleanup generics and other static analyzer issues. (#3391)


+import java.util.Objects;
-import java.util.TreeSet;
-import org.apache.geode.internal.cache.Node;
-import org.apache.geode.internal.cache.persistence.PersistenceAdvisor;
-import org.apache.geode.internal.cache.persistence.PersistentStateListener;
-  private Queue preInitQueue;
+  private Queue<QueuedBucketProfile> preInitQueue;
-      this.preInitQueue = new ConcurrentLinkedQueue();
+      this.preInitQueue = new ConcurrentLinkedQueue<>();
-    this.clientBucketProfilesMap = new ConcurrentHashMap<Integer, Set<ServerBucketProfile>>();
+    this.clientBucketProfilesMap = new ConcurrentHashMap<>();
-            for (int i = 0; i < this.buckets.length; i++) {
-              BucketAdvisor ba = this.buckets[i].getBucketAdvisor();
+            for (ProxyBucketRegion bucket : this.buckets) {
+              BucketAdvisor ba = bucket.getBucketAdvisor();
-    Map<Integer, List<BucketServerLocation66>> bucketToServerLocations =
-        new HashMap<Integer, List<BucketServerLocation66>>();
+    Map<Integer, List<BucketServerLocation66>> bucketToServerLocations = new HashMap<>();
-      ArrayList<BucketServerLocation66> clientBucketProfiles =
-          new ArrayList<BucketServerLocation66>();
+      ArrayList<BucketServerLocation66> clientBucketProfiles = new ArrayList<>();
-          List<BucketServerLocation66> clientBucketProfiles = bucketToServerLocations.get(bucketId);
-          if (clientBucketProfiles == null) {
-            clientBucketProfiles = new ArrayList<BucketServerLocation66>();
-            bucketToServerLocations.put(bucketId, clientBucketProfiles);
-          }
+          List<BucketServerLocation66> clientBucketProfiles =
+              bucketToServerLocations.computeIfAbsent(bucketId, k -> new ArrayList<>());
-    ConcurrentHashMap<Integer, Set<ServerBucketProfile>> map =
-        new ConcurrentHashMap<Integer, Set<ServerBucketProfile>>();
+    ConcurrentHashMap<Integer, Set<ServerBucketProfile>> map = new ConcurrentHashMap<>();
-        new HashMap<>(this.getAllClientBucketProfiles());
+        new HashMap<>(getAllClientBucketProfiles());
-    List primariesHeld = Collections.EMPTY_LIST;
-    if (this.buckets != null) {
-      for (int i = 0; i < this.buckets.length; i++) {
-        ProxyBucketRegion pbr = this.buckets[i];
+    List<Integer> primariesHeld = Collections.emptyList();
+    if (buckets != null) {
+      for (int i = 0; i < buckets.length; i++) {
+        ProxyBucketRegion pbr = buckets[i];
-          if (primariesHeld == Collections.EMPTY_LIST) {
-            primariesHeld = new ArrayList();
+          if (primariesHeld.isEmpty()) {
+            primariesHeld = new ArrayList<>();
-          primariesHeld.add(Integer.valueOf(i));
+          primariesHeld.add(i);
-      for (int i = 0; i < this.buckets.length; i++) {
-        this.buckets[i].close();
+      for (ProxyBucketRegion bucket : buckets) {
+        bucket.close();
-      if (this.preInitQueue != null) {
+      if (preInitQueue != null) {
-        assert memberId instanceof InternalDistributedMember;
-        this.preInitQueue.add(qbf);
+        preInitQueue.add(qbf);
-    if (removeBuckets && this.buckets != null) {
-      for (int i = 0; i < this.buckets.length; i++) {
-        ProxyBucketRegion pbr = this.buckets[i];
+    if (removeBuckets && buckets != null) {
+      for (ProxyBucketRegion pbr : buckets) {
-
-    boolean removedId = false;
+    boolean removedId;
-  public void removeIdAndBuckets(InternalDistributedMember memberId, int prSerial, int serials[],
+  public void removeIdAndBuckets(InternalDistributedMember memberId, int prSerial, int[] serials,
-    } // synchronized
+    }
+      Objects.requireNonNull(serials);
-      } // for
+      }
-        logger.debug("For bucket {} sick members are ",
+        logger.debug("For bucket {} sick members are {}.",
-          new Object[] {getPartitionedRegion().getFullPath(), key, sm}), sm);
+          getPartitionedRegion().getFullPath(), key, sm), sm);
-     * A lock used to order operations that need to know about the imminent closure/destruction of a
-     * Region
-     */
-    // private StoppableReentrantReadWriteLock isClosingLock = null;
-
-    /**
-    // public StoppableReentrantReadWriteLock.StoppableReadLock
-    // getIsClosingReadLock(CancelCriterion stopper) {
-    // synchronized (this) {
-    // if (isClosingLock == null) {
-    // this.isClosingLock = new StoppableReentrantReadWriteLock(stopper);
-    // }
-    // }
-    // return this.isClosingLock.readLock();
-    // }
-
-    // public Lock getIsClosingWriteLock() {
-    // return this.isClosingLock.writeLock();
-    // }
-
-    Set<InternalDistributedMember> s = adviseFilter(new Filter() {
-      @Override
-      public boolean include(Profile profile) {
-        // probably not needed as all profiles for a partitioned region are Partition profiles
-        if (profile instanceof PartitionProfile) {
-          PartitionProfile p = (PartitionProfile) profile;
-          return p.isDataStore && (!p.dataPolicy.withPersistence() || p.regionInitialized);
-        }
-        return false;
+    return adviseFilter(profile -> {
+      // probably not needed as all profiles for a partitioned region are Partition profiles
+      if (profile instanceof PartitionProfile) {
+        PartitionProfile p = (PartitionProfile) profile;
+        return p.isDataStore && (!p.dataPolicy.withPersistence() || p.regionInitialized);
+      return false;
-    return s;
-  public Set<InternalDistributedMember> adviseNotAtShutDownAllStatus(final int status) {
-    Set<InternalDistributedMember> s = adviseFilter(new Filter() {
-      @Override
-      public boolean include(Profile profile) {
-        // probably not needed as all profiles for a partitioned region are Partition profiles
-        if (profile instanceof PartitionProfile) {
-          PartitionProfile p = (PartitionProfile) profile;
-          return p.isDataStore && p.shutDownAllStatus < status;
-        }
-        return false;
+  private Set<InternalDistributedMember> adviseNotAtShutDownAllStatus(final int status) {
+    return adviseFilter(profile -> {
+      // probably not needed as all profiles for a partitioned region are Partition profiles
+      if (profile instanceof PartitionProfile) {
+        PartitionProfile p = (PartitionProfile) profile;
+        return p.isDataStore && p.shutDownAllStatus < status;
+      return false;
-    return s;
-      int memberNum = 0;
+      int memberNum;
-    Set<InternalDistributedMember> s = adviseFilter(new Filter() {
-      @Override
-      public boolean include(Profile profile) {
-        // probably not needed as all profiles for a partitioned region are Partition profiles
-        if (profile instanceof PartitionProfile) {
-          PartitionProfile p = (PartitionProfile) profile;
-          return p.isDataStore;
-        }
-        return false;
+    Set<InternalDistributedMember> s = adviseFilter(profile -> {
+      // probably not needed as all profiles for a partitioned region are Partition profiles
+      if (profile instanceof PartitionProfile) {
+        PartitionProfile p = (PartitionProfile) profile;
+        return p.isDataStore;
+      return false;
-        s = new HashSet<InternalDistributedMember>();
+        s = new HashSet<>();
-    Set<InternalDistributedMember> s = adviseFilter(new Filter() {
-      @Override
-      public boolean include(Profile profile) {
-        // probably not needed as all profiles for a partitioned region are
-        // Partition profiles
-        if (profile instanceof PartitionProfile) {
-          PartitionProfile p = (PartitionProfile) profile;
-          if (p.fixedPAttrs != null) {
-            for (FixedPartitionAttributesImpl fpa : p.fixedPAttrs) {
-              if (fpa.getPartitionName().equals(partitionName)) {
-                return true;
-              }
+    Set<InternalDistributedMember> s = adviseFilter(profile -> {
+      // probably not needed as all profiles for a partitioned region are
+      // Partition profiles
+      if (profile instanceof PartitionProfile) {
+        PartitionProfile p = (PartitionProfile) profile;
+        if (p.fixedPAttrs != null) {
+          for (FixedPartitionAttributesImpl fpa : p.fixedPAttrs) {
+            if (fpa.getPartitionName().equals(partitionName)) {
+              return true;
-        return false;
+      return false;
-      s = new HashSet<InternalDistributedMember>();
+      s = new HashSet<>();
-    final List<InternalDistributedMember> fixedPartitionDataStore =
-        new ArrayList<InternalDistributedMember>(1);
-    fetchProfiles(new Filter() {
-      @Override
-      public boolean include(Profile profile) {
-        if (profile instanceof PartitionProfile) {
-          PartitionProfile p = (PartitionProfile) profile;
-          if (p.fixedPAttrs != null) {
-            for (FixedPartitionAttributesImpl fpa : p.fixedPAttrs) {
-              if (fpa.isPrimary() && fpa.hasBucket(bucketId)) {
-                fixedPartitionDataStore.add(0, p.getDistributedMember());
-                return true;
-              }
+    final List<InternalDistributedMember> fixedPartitionDataStore = new ArrayList<>(1);
+    fetchProfiles(profile -> {
+      if (profile instanceof PartitionProfile) {
+        PartitionProfile p = (PartitionProfile) profile;
+        if (p.fixedPAttrs != null) {
+          for (FixedPartitionAttributesImpl fpa : p.fixedPAttrs) {
+            if (fpa.isPrimary() && fpa.hasBucket(bucketId)) {
+              fixedPartitionDataStore.add(0, p.getDistributedMember());
+              return true;
-        return false;
+      return false;
-    final List<FixedPartitionAttributesImpl> allFPAs =
-        new ArrayList<FixedPartitionAttributesImpl>();
-    fetchProfiles(new Filter() {
-      @Override
-      public boolean include(final Profile profile) {
-        if (profile instanceof PartitionProfile) {
-          final PartitionProfile pp = (PartitionProfile) profile;
-          if (pp.fixedPAttrs != null) {
-            allFPAs.addAll(pp.fixedPAttrs);
-            return true;
-          }
+    final List<FixedPartitionAttributesImpl> allFPAs = new ArrayList<>();
+    fetchProfiles(profile -> {
+      if (profile instanceof PartitionProfile) {
+        final PartitionProfile pp = (PartitionProfile) profile;
+        if (pp.fixedPAttrs != null) {
+          allFPAs.addAll(pp.fixedPAttrs);
+          return true;
-        return false;
+      return false;
-    final List<FixedPartitionAttributesImpl> sameFPAs =
-        new ArrayList<FixedPartitionAttributesImpl>();
+    final List<FixedPartitionAttributesImpl> sameFPAs = new ArrayList<>();
-    fetchProfiles(new Filter() {
-      @Override
-      public boolean include(final Profile profile) {
-        if (profile instanceof PartitionProfile) {
-          final PartitionProfile pp = (PartitionProfile) profile;
-          List<FixedPartitionAttributesImpl> fpaList = pp.fixedPAttrs;
-          if (fpaList != null) {
-            int index = fpaList.indexOf(fpa);
-            if (index != -1) {
-              sameFPAs.add(fpaList.get(index));
-            }
-            return true;
+    fetchProfiles(profile -> {
+      if (profile instanceof PartitionProfile) {
+        final PartitionProfile pp = (PartitionProfile) profile;
+        List<FixedPartitionAttributesImpl> fpaList = pp.fixedPAttrs;
+        if (fpaList != null) {
+          int index = fpaList.indexOf(fpa);
+          if (index != -1) {
+            sameFPAs.add(fpaList.get(index));
+          return true;
-        return false;
+      return false;
-    final List<FixedPartitionAttributesImpl> remotePrimaryFPAs =
-        new ArrayList<FixedPartitionAttributesImpl>();
+    final List<FixedPartitionAttributesImpl> remotePrimaryFPAs = new ArrayList<>();
-    fetchProfiles(new Filter() {
-      @Override
-      public boolean include(final Profile profile) {
-        if (profile instanceof PartitionProfile) {
-          final PartitionProfile pp = (PartitionProfile) profile;
-          List<FixedPartitionAttributesImpl> fpaList = pp.fixedPAttrs;
-          if (fpaList != null) {
-            for (FixedPartitionAttributesImpl fpa : fpaList) {
-              if (fpa.isPrimary()) {
-                remotePrimaryFPAs.add(fpa);
-                return true;
-              }
+    fetchProfiles(profile -> {
+      if (profile instanceof PartitionProfile) {
+        final PartitionProfile pp = (PartitionProfile) profile;
+        List<FixedPartitionAttributesImpl> fpaList = pp.fixedPAttrs;
+        if (fpaList != null) {
+          for (FixedPartitionAttributesImpl fpa : fpaList) {
+            if (fpa.isPrimary()) {
+              remotePrimaryFPAs.add(fpa);
+              return true;
-        return false;
+      return false;
-  /**
-   * TODO remove this when Primary Bucket impl. is permanently in place
-   *
-   * @return the node??
-   */
-  public Node adviseSmallestDataStore(final List limitNodeList) {
-    final HashMap filtSet = new HashMap(limitNodeList.size());
-    Node n = null;
-    for (Iterator filtI = limitNodeList.iterator(); filtI.hasNext();) {
-      n = (Node) filtI.next();
-      filtSet.put(n.getMemberId(), n);
-    }
-    final Object[] smallest = new Object[1];
-    adviseFilter(new Filter() {
-      short numBucks = Short.MAX_VALUE;
-
-      @Override
-      public boolean include(Profile profile) {
-        if (profile instanceof PartitionProfile) {
-          PartitionProfile p = (PartitionProfile) profile;
-          if (filtSet.containsKey(p.getDistributedMember()) && p.numBuckets < this.numBucks) {
-            smallest[0] = p.getDistributedMember();
-            this.numBucks = p.numBuckets;
-          }
-        }
-        return false;
-      }
-    });
-    return (Node) filtSet.get(smallest[0]);
-  }
-
-
-  public List<DistributedMember> orderDataStoresUsingBucketCount(final Set nodes) {
-    final Set<NodeBucketSize> orderedSet = new TreeSet<NodeBucketSize>();
-    final List<DistributedMember> orderedList = new ArrayList<DistributedMember>();
-    final DistributedMember self = getDistributionManager().getDistributionManagerId();
-    adviseFilter(new Filter() {
-      @Override
-      public boolean include(Profile profile) {
-        if (profile instanceof PartitionProfile && nodes.contains(profile.getDistributedMember())) {
-          PartitionProfile p = (PartitionProfile) profile;
-          orderedSet.add(new NodeBucketSize(p.numBuckets, p.getDistributedMember()));
-          return true;
-        } else if (profile instanceof PartitionProfile && nodes.contains(self)) {
-          orderedSet.add(new NodeBucketSize(getBucketSet().size(), self));
-          return true;
-        }
-        return false;
-      }
-    });
-
-    if (nodes.contains(self)
-        && !orderedSet.contains(new NodeBucketSize(getBucketSet().size(), self))) {
-      orderedSet.add(new NodeBucketSize(getBucketSet().size(), self));
-    }
-    for (NodeBucketSize node : orderedSet) {
-      orderedList.add(node.member);
-    }
-    return orderedList;
-  }
-
-  private class NodeBucketSize implements Comparable {
-    private final int numBuckets;
-
-    private final DistributedMember member;
-
-    public NodeBucketSize(final int numBuckets, final DistributedMember member) {
-      this.numBuckets = numBuckets;
-      this.member = member;
-    }
-
-    @Override
-    public int compareTo(Object o) {
-      assert o instanceof NodeBucketSize;
-      NodeBucketSize node = (NodeBucketSize) o;
-      if (node.numBuckets > this.numBuckets) {
-        return 1;
-      }
-      return -1;
-    }
-
-    @Override
-    public String toString() {
-      return "NodeBucketSize [ member =" + member + " numBuckets = " + numBuckets + "]";
-    }
-
-    @Override
-    public int hashCode() {
-      return super.hashCode();
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-      if (!(obj instanceof NodeBucketSize)) {
-        return false;
-      }
-      NodeBucketSize node = (NodeBucketSize) obj;
-      if (this.member.getId().equals(node.member.getId())) {
-        return true;
-      }
-      return false;
-    }
-  }
-
-    return adviseFilter(new Filter() {
-      @Override
-      public boolean include(Profile profile) {
-        CacheProfile prof = (CacheProfile) profile;
-        return prof.isPartitioned;
-      }
+    return adviseFilter(profile -> {
+      CacheProfile prof = (CacheProfile) profile;
+      return prof.isPartitioned;
-  public Set adviseAllServersWithInterest() {
-    return adviseFilter(new Filter() {
-      @Override
-      public boolean include(Profile profile) {
-        CacheProfile prof = (CacheProfile) profile;
-        return prof.hasCacheServer && prof.filterProfile != null
-            && prof.filterProfile.hasInterest();
-      }
+  Set adviseAllServersWithInterest() {
+    return adviseFilter(profile -> {
+      CacheProfile prof = (CacheProfile) profile;
+      return prof.hasCacheServer && prof.filterProfile != null
+          && prof.filterProfile.hasInterest();
-  private static final Filter prServerWithInterestFilter = new Filter() {
-    @Override
-    public boolean include(Profile profile) {
-      CacheProfile prof = (CacheProfile) profile;
-      return prof.isPartitioned && prof.hasCacheServer && prof.filterProfile != null
-          && prof.filterProfile.hasInterest();
-    }
+  private static final Filter prServerWithInterestFilter = profile -> {
+    CacheProfile prof = (CacheProfile) profile;
+    return prof.isPartitioned && prof.hasCacheServer && prof.filterProfile != null
+        && prof.filterProfile.hasInterest();
-    return adviseFilter(new Filter() {
-      @Override
-      public boolean include(Profile profile) {
-        if (profile instanceof PartitionProfile) {
-          PartitionProfile prof = (PartitionProfile) profile;
-          if (prof.isPartitioned) {
-            if (prof.hasCacheListener) {
-              InterestPolicy pol = prof.subscriptionAttributes.getInterestPolicy();
-              if (pol == InterestPolicy.ALL) {
-                return true;
-              }
-            }
-            if (prof.requiresNotification) {
+    return adviseFilter(profile -> {
+      if (profile instanceof PartitionProfile) {
+        PartitionProfile prof = (PartitionProfile) profile;
+        if (prof.isPartitioned) {
+          if (prof.hasCacheListener) {
+            InterestPolicy pol = prof.subscriptionAttributes.getInterestPolicy();
+            if (pol == InterestPolicy.ALL) {
-            return false;
+          return prof.requiresNotification;
-        return false;
+      return false;
-    Map<Integer, BucketAdvisor> map = new HashMap<Integer, BucketAdvisor>();
-    for (int i = 0; i < buckets.length; i++) {
-      ProxyBucketRegion pbr = this.buckets[i];
+    Map<Integer, BucketAdvisor> map = new HashMap<>();
+    for (ProxyBucketRegion pbr : buckets) {
-    int result[] = new int[this.buckets.length];
+    int[] result = new int[this.buckets.length];
-  public boolean waitForLocalBucketStorage(int bucketId) {
-    Assert.assertTrue(this.buckets != null);
-    return this.buckets[bucketId].getBucketAdvisor().waitForStorage();
-  }
-
-  private class BucketSet extends AbstractSet {
+  private class BucketSet extends AbstractSet<Integer> {
-    public BucketSet() {
+    BucketSet() {
-    @Override
-    public Object[] toArray() {
-      // A somewhat wasteful impl. but required because the size is not fixed
-      ArrayList ar = new ArrayList(this.pbrs.length);
-      try {
-        for (Iterator e = iterator(); e.hasNext();) {
-          ar.add(e.next());
-        }
-      } catch (NoSuchElementException allDone) {
-      }
-      return ar.toArray();
-    }
-
-    @Override
-    public Object[] toArray(Object p_a[]) {
-      Object a[] = p_a;
-      // Some what wasteful, but needed because size is not fixed
-      Object[] oa = toArray();
-
-      if (a.length < oa.length) {
-        a = (Object[]) java.lang.reflect.Array.newInstance(a.getClass().getComponentType(),
-            oa.length);
-        System.arraycopy(oa, 0, a, 0, oa.length);
-      }
-
-      for (int i = 0; i < oa.length; i++)
-        a[i] = oa[i];
-
-      if (a.length > oa.length)
-        a[oa.length] = null;
-
-      return a;
-    }
-
-
-    public Iterator iterator() {
+    public Iterator<Integer> iterator() {
-    class BucketSetIterator implements Iterator {
+    class BucketSetIterator implements Iterator<Integer> {
-      public Object next() {
+      public Integer next() {
-            return Integer.valueOf(this.currentItem);
+            return this.currentItem;
-                return Integer.valueOf(this.currentItem);
+                return this.currentItem;
-              return Integer.valueOf(this.currentItem);
+              return this.currentItem;
-    final HashMap<InternalDistributedMember, Integer> memberToPrimaryCount =
-        new HashMap<InternalDistributedMember, Integer>();
-    for (int i = 0; i < this.buckets.length; i++) {
-      ProxyBucketRegion pbr = this.buckets[i];
+    final HashMap<InternalDistributedMember, Integer> memberToPrimaryCount = new HashMap<>();
+    for (ProxyBucketRegion pbr : this.buckets) {
-        Integer count = memberToPrimaryCount.get(p);
-        if (count != null) {
-          memberToPrimaryCount.put(p, Integer.valueOf(count.intValue() + 1));
-        } else {
-          memberToPrimaryCount.put(p, Integer.valueOf(1));
-        }
+        memberToPrimaryCount.merge(p, 1, Integer::sum);
-    final ArrayList<DataStoreBuckets> ds = new ArrayList<DataStoreBuckets>(memberFilter.size());
-    adviseFilter(new Filter() {
-      @Override
-      public boolean include(Profile profile) {
-        if (profile instanceof PartitionProfile) {
-          PartitionProfile p = (PartitionProfile) profile;
-          if (memberFilter.contains(p.getDistributedMember())) {
-            Integer priCount = memberToPrimaryCount.get(p.getDistributedMember());
-            int primaryCount = 0;
-            if (priCount != null) {
-              primaryCount = priCount.intValue();
-            }
-            ds.add(new DataStoreBuckets(p.getDistributedMember(), p.numBuckets, primaryCount,
-                p.localMaxMemory));
+    final ArrayList<DataStoreBuckets> ds = new ArrayList<>(memberFilter.size());
+    adviseFilter(profile -> {
+      if (profile instanceof PartitionProfile) {
+        PartitionProfile p = (PartitionProfile) profile;
+        if (memberFilter.contains(p.getDistributedMember())) {
+          Integer priCount = memberToPrimaryCount.get(p.getDistributedMember());
+          int primaryCount = 0;
+          if (priCount != null) {
+            primaryCount = priCount;
+          ds.add(new DataStoreBuckets(p.getDistributedMember(), p.numBuckets, primaryCount,
+              p.localMaxMemory));
-        return false;
+      return false;
-    for (int i = 0; i < pbrs.length; i++) {
-      pbrs[i].getBucketAdvisor().dumpProfiles(infoMsg);
-      BucketPersistenceAdvisor persistentAdvisor = pbrs[i].getPersistenceAdvisor();
+    for (ProxyBucketRegion pbr : pbrs) {
+      pbr.getBucketAdvisor().dumpProfiles(infoMsg);
+      BucketPersistenceAdvisor persistentAdvisor = pbr.getPersistenceAdvisor();
-    HashSet hs = new HashSet();
+    HashSet<InternalDistributedMember> hs = new HashSet<>();
-    Assert.assertTrue(bucs != null);
+    Objects.requireNonNull(bucs);
-  public void putBucketProfile(int bucketId, BucketProfile profile) {
+  void putBucketProfile(int bucketId, BucketProfile profile) {
-    protected final BucketProfile bucketProfile;
+    final BucketProfile bucketProfile;
-    protected final boolean isRemoval;
+    final boolean isRemoval;
-    protected final boolean fromMembershipListener;
+    final boolean fromMembershipListener;
-    protected final int serials[];
+    final int[] serials;
-    public QueuedBucketProfile(int bId, BucketProfile p) {
+    QueuedBucketProfile(int bId, BucketProfile p) {
-    public QueuedBucketProfile(InternalDistributedMember mbr, boolean crashed, boolean destroyed,
+    QueuedBucketProfile(InternalDistributedMember mbr, boolean crashed, boolean destroyed,
-    public QueuedBucketProfile(InternalDistributedMember mbr, int serials[], boolean destroyed) {
+    QueuedBucketProfile(InternalDistributedMember mbr, int[] serials, boolean destroyed) {
-    adviseFilter(new Filter() {
-      @Override
-      public boolean include(Profile profile) {
-        // probably not needed as all profiles for a partitioned region are Partition profiles
-        if (profile instanceof PartitionProfile) {
-          PartitionProfile p = (PartitionProfile) profile;
-          total.addAndGet(p.localMaxMemory);
-        }
-        return false;
+    adviseFilter(profile -> {
+      // probably not needed as all profiles for a partitioned region are Partition profiles
+      if (profile instanceof PartitionProfile) {
+        PartitionProfile p = (PartitionProfile) profile;
+        total.addAndGet(p.localMaxMemory);
+      return false;
-  public long adviseTotalMemoryAllocationForFPR() {
-    final AtomicLong total = new AtomicLong();
-    adviseFilter(new Filter() {
-      @Override
-      public boolean include(Profile profile) {
-        // probably not needed as all profiles for a partitioned region are Partition profiles
-        if (profile instanceof PartitionProfile) {
-          PartitionProfile p = (PartitionProfile) profile;
-          if (p.fixedPAttrs != null) {
-            total.addAndGet(p.localMaxMemory);
-          }
-        }
-        return false;
-      }
-    });
-    return total.get();
-  }
-
-  /**
-   * Returns true if there are any buckets created anywhere in the distributed system for this
-   * partitioned region.
-   */
-  public boolean hasCreatedBuckets() {
-    final ProxyBucketRegion[] bucs = this.buckets;
-    if (bucs != null) {
-      for (int i = 0; i < bucs.length; i++) {
-        if (bucs[i].getBucketOwnersCount() > 0) {
-          return true;
-        }
-      }
-    }
-    return false;
-  }
-
-    for (int i = 0; i < bucs.length; i++) {
-      if (bucs[i].getBucketOwnersCount() > 0) {
+    for (ProxyBucketRegion buc : bucs) {
+      if (buc.getBucketOwnersCount() > 0) {
-    ArrayList result = new ArrayList(bucs.length);
+    ArrayList<BucketProfileAndId> result = new ArrayList<>(bucs.length);
-  public void putBucketRegionProfiles(ArrayList l) {
-    int size = l.size();
-    for (int i = 0; i < size; i++) {
-      BucketProfileAndId bp = (BucketProfileAndId) l.get(i);
+  public void putBucketRegionProfiles(ArrayList<BucketProfileAndId> l) {
+    for (BucketProfileAndId bp : l) {
-      for (int i = 0; i < this.buckets.length; i++) {
-        this.buckets[i].getBucketAdvisor().checkForLostPrimaryElector(profile);
-      }
-    }
-  }
-
-  public void addPersistenceListener(PersistentStateListener listener) {
-    for (int i = 0; i < buckets.length; i++) {
-      PersistenceAdvisor advisor = buckets[i].getPersistenceAdvisor();
-      if (advisor != null) {
-        advisor.addListener(listener);
+      for (ProxyBucketRegion bucket : this.buckets) {
+        bucket.getBucketAdvisor().checkForLostPrimaryElector(profile);
-    public BucketProfile getBucketProfile() {
+    BucketProfile getBucketProfile() {
-    public void waitForChange() {
+    void waitForChange() {
-          } catch (InterruptedException e) {
+          } catch (InterruptedException ignored) {

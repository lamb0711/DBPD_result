Merge branch 'release/1.5.0'

+import org.apache.geode.StatisticsFactory;
+import org.apache.geode.cache.EvictionAttributes;
+import org.apache.geode.internal.util.concurrent.ConcurrentMapWithReusableEntries;
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
-  public EvictionAttributesImpl getEvictionAttributes() {
+  @Override
+  public EvictionAttributes getEvictionAttributes() {
-        .setAction(getActualLruAction()).internalSetMaximum(getLruLimit());
+        .setAction(getActualLruAction()).setMaximum(getLruLimit());
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
-      this.entriesMapIncompatible = false;
-      if (this.entries != null) {
-        CustomEntryConcurrentHashMap<Object, Object> other =
-            ((AbstractRegionMap) this.entries)._getMap();
-        Iterator<Map.Entry<Object, Object>> it = other.entrySetWithReusableEntries().iterator();
-        while (it.hasNext()) {
-          Map.Entry<Object, Object> me = it.next();
+      entriesMapIncompatible = false;
+      if (entries != null) {
+        ConcurrentMapWithReusableEntries<Object, Object> other =
+            entries.getCustomEntryConcurrentHashMap();
+        for (Map.Entry<Object, Object> me : other.entrySetWithReusableEntries()) {
-      this.entries = null;
-      this.readyForRecovery = false;
+      entries = null;
+      readyForRecovery = false;
-    if (this.aboutToDestroyDataStorage) {
-      this.ds.endDestroyDataStorage(region, (DiskRegion) this);
+    if (aboutToDestroyDataStorage) {
+      ds.endDestroyDataStorage(region, (DiskRegion) this);
-      this.ds.endDestroyRegion(region, (DiskRegion) this);
+      ds.endDestroyRegion(region, (DiskRegion) this);
-
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+  @Override
+
+  @Override
+  public StatisticsFactory getStatisticsFactory() {
+    return this.ds.getStatisticsFactory();
+  }
+
+  @Override
+  public String getNameForStats() {
+    if (isBucket()) {
+      return getPrName();
+    } else {
+      return getName();
+    }
+  }
+
+  @Override
+  public InternalCache getCache() {
+    return getDiskStore().getCache();
+  }

GEODE-7348: Removing dependencies on core god classes from TcpServer (#4217)

- Removed DistributedSystem, GemFireCache,
  InternalConfiguratinPersistenceService dependencies that were used in the
  restarting method. Now there is a RestartableTcpHandler that lives inside core
  and extends TcpHandler. Core directly calls restarting on the
  RestartableTcpHandler.
- Extracted ProtocolChecker interface to remove Protobuf dependency.


-import org.apache.geode.cache.IncompatibleVersionException;
-import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;
-import org.apache.geode.distributed.internal.InternalDistributedSystem;
-import org.apache.geode.distributed.internal.InternalLocator;
-import org.apache.geode.internal.cache.InternalCache;
-import org.apache.geode.internal.cache.client.protocol.ClientProtocolProcessor;
-import org.apache.geode.internal.cache.client.protocol.ClientProtocolService;
-import org.apache.geode.internal.cache.client.protocol.ClientProtocolServiceLoader;
-import org.apache.geode.internal.cache.client.protocol.exception.ServiceLoadingFailureException;
-import org.apache.geode.internal.cache.client.protocol.exception.ServiceVersionNotFoundException;
-import org.apache.geode.internal.cache.tier.CommunicationMode;
-import org.apache.geode.internal.cache.tier.sockets.Handshake;
+  public static final int GOSSIP_BYTE = 0;
-  private static final Logger log = LogService.getLogger();
+  private static final Logger logger = LogService.getLogger();
+  private final ProtocolChecker protocolChecker;
-  private final InternalLocator internalLocator;
-  private final ClientProtocolServiceLoader clientProtocolServiceLoader;
-      String threadName, InternalLocator internalLocator,
-      ClientProtocolServiceLoader clientProtocolServiceLoader) {
+      String threadName, ProtocolChecker protocolChecker) {
-    this.internalLocator = internalLocator;
-    this.clientProtocolServiceLoader = clientProtocolServiceLoader;
+    this.protocolChecker = protocolChecker;
-  public void restarting(InternalDistributedSystem ds, InternalCache cache,
-      InternalConfigurationPersistenceService sharedConfig) throws IOException {
+  public void restarting() throws IOException {
-    this.handler.restarting(ds, cache, sharedConfig);
-    log.info("TcpServer@" + System.identityHashCode(this)
+    logger.info("TcpServer@" + System.identityHashCode(this)
-  public void restartCompleted(InternalDistributedSystem ds) {
-    this.handler.restartCompleted(ds);
-  }
-
-      if (log.isInfoEnabled()) {
-        log.info("Locator was created at " + new Date());
-        log.info("Listening on port " + getPort() + " bound on address " + bind_address);
+      if (logger.isInfoEnabled()) {
+        logger.info("Locator was created at " + new Date());
+        logger.info("Listening on port " + getPort() + " bound on address " + bind_address);
-          log.error("Locator stopping due to SSL configuration problem.", ex);
+          logger.error("Locator stopping due to SSL configuration problem.", ex);
-          log.error("exception=", ex);
+          logger.error("exception=", ex);
-        log.warn("exception closing server socket during shutdown", ex);
+        logger.warn("exception closing server socket during shutdown", ex);
-      log.info("locator shutting down");
+      logger.info("locator shutting down");
-          log.debug("Discarding illegal request from "
+          logger.debug("Discarding illegal request from "
-        if (firstByte == CommunicationMode.ReservedForGossip.getModeNumber()) {
-          processOneConnection(socket, startTime, input);
-        } else if (firstByte == CommunicationMode.ProtobufClientServerProtocol.getModeNumber()) {
-          handleProtobufConnection(socket, input);
-        } else if (CommunicationMode.isValidMode(firstByte)) {
-          socket.getOutputStream().write(Handshake.REPLY_SERVER_IS_LOCATOR);
-          throw new Exception("Improperly configured client detected - use addPoolLocator to "
-              + "configure its locators instead of addPoolServer.");
-        } else {
-          rejectUnknownProtocolConnection(socket, firstByte);
+        boolean handled = protocolChecker.checkProtocol(socket, input, firstByte);
+
+        if (!handled) {
+          if (firstByte == GOSSIP_BYTE) {
+            processOneConnection(socket, startTime, input);
+          } else {
+            rejectUnknownProtocolConnection(socket, firstByte);
+          }
-        log.info("Exception in processing request from " + sender + ": " + ex.getMessage());
+        logger.info("Exception in processing request from " + sender + ": " + ex.getMessage());
-        log.info("Unable to process request from " + sender + " exception=" + ex.getMessage());
+        logger.info("Unable to process request from " + sender + " exception=" + ex.getMessage());
-            log.info("Exception in processing request from " + sender, ex);
+            logger.info("Exception in processing request from " + sender, ex);
-          log.fatal("Exception in processing request from " + sender, ex);
+          logger.fatal("Exception in processing request from " + sender, ex);
-          log.fatal("Exception in processing request from " + sender, ex);
+          logger.fatal("Exception in processing request from " + sender, ex);
-      if (log.isDebugEnabled() && versionOrdinal != Version.CURRENT_ORDINAL) {
-        log.debug("Locator reading request from " + socket.getInetAddress() + " with version "
+      if (logger.isDebugEnabled() && versionOrdinal != Version.CURRENT_ORDINAL) {
+        logger.debug("Locator reading request from " + socket.getInetAddress() + " with version "
-      if (log.isDebugEnabled()) {
-        log.debug("Locator received request " + request + " from " + socket.getInetAddress());
+      if (logger.isDebugEnabled()) {
+        logger.debug("Locator received request " + request + " from " + socket.getInetAddress());
-      log.debug("exception in sending reply to process using unknown protocol " + gossipVersion, e);
-    }
-  }
-
-  private void handleProtobufConnection(Socket socket, DataInputStream input) throws Exception {
-    if (!Boolean.getBoolean("geode.feature-protobuf-protocol")) {
-      log.warn("Incoming protobuf connection, but protobuf not enabled on this locator.");
-      socket.close();
-      return;
-    }
-
-    try {
-      ClientProtocolService clientProtocolService = clientProtocolServiceLoader.lookupService();
-      clientProtocolService.initializeStatistics("LocatorStats",
-          internalLocator.getDistributedSystem());
-      try (ClientProtocolProcessor pipeline = clientProtocolService.createProcessorForLocator(
-          internalLocator, internalLocator.getCache().getSecurityService())) {
-        while (!pipeline.socketProcessingIsFinished()) {
-          pipeline.processMessage(input, socket.getOutputStream());
-        }
-      } catch (IncompatibleVersionException e) {
-        // should not happen on the locator as there is no handshake.
-        log.error("Unexpected exception in client message processing", e);
-      }
-    } catch (ServiceLoadingFailureException e) {
-      log.error("There was an error looking up the client protocol service", e);
-      socket.close();
-      throw new IOException("There was an error looking up the client protocol service", e);
-    } catch (ServiceVersionNotFoundException e) {
-      log.error("Unable to find service matching the client protocol version byte", e);
-      socket.close();
-      throw new IOException("Unable to find service matching the client protocol version byte", e);
+      logger
+          .debug("exception in sending reply to process using unknown protocol " + gossipVersion,
+              e);

GEODE-2919: Provide finer grained security

 - For full details, see https://cwiki.apache.org/confluence/display/GEODE/Finer+grained+security

+import java.io.BufferedReader;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.PrintStream;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.springframework.shell.core.annotation.CliCommand;
+import org.springframework.shell.core.annotation.CliOption;
+
-import org.apache.geode.security.ResourcePermission.Target;
-import org.springframework.shell.core.annotation.CliAvailabilityIndicator;
-import org.springframework.shell.core.annotation.CliCommand;
-import org.springframework.shell.core.annotation.CliOption;
-
-import java.io.BufferedReader;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.PrintStream;
-import java.net.URL;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicReference;
+import org.apache.geode.security.ResourcePermission.Target;
+
+  /**
+   * Internally, we also verify the resource operation permissions CLUSTER:WRITE:DISK if the region
+   * is persistent
+   */
-
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-    Result result = null;
+    getSecurityService().authorize(Resource.CLUSTER, Operation.WRITE, Target.DISK);
+    Result result;
-      BackupStatus backupStatus = null;
+      BackupStatus backupStatus;
-                writeToBackupDisktoreTable(backedupDiskStoresTable, memberName, UUID, hostName,
+                writeToBackupDiskStoreTable(backedupDiskStoresTable, memberName, UUID, hostName,
-                writeToBackupDisktoreTable(backedupDiskStoresTable, "", UUID, hostName, directory);
+                writeToBackupDiskStoreTable(backedupDiskStoresTable, "", UUID, hostName, directory);
-  private void writeToBackupDisktoreTable(TabularResultData backedupDiskStoreTable, String memberId,
-      String UUID, String host, String directory) {
+  private void writeToBackupDiskStoreTable(TabularResultData backedupDiskStoreTable,
+      String memberId, String UUID, String host, String directory) {
-  @CliMetaData(shellOnly = false, relatedTopic = {CliStrings.TOPIC_GEODE_DISKSTORE})
+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DISKSTORE})
-        new ArrayList<DiskStoreDetails>(results.size());
+        new ArrayList<>(results.size());
-  @CliMetaData(shellOnly = false, relatedTopic = {CliStrings.TOPIC_GEODE_DISKSTORE})
-  @ResourceOperation(resource = Resource.DATA, operation = Operation.MANAGE)
+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DISKSTORE})
+  @ResourceOperation(resource = Resource.CLUSTER, operation = Operation.MANAGE,
+      target = Target.DISK)
-  @CliMetaData(shellOnly = false, relatedTopic = {CliStrings.TOPIC_GEODE_DISKSTORE})
+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DISKSTORE})
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-    Result result = null;
+    Result result;
-        Map<DistributedMember, PersistentID> overallCompactInfo =
-            new HashMap<DistributedMember, PersistentID>();
+        Map<DistributedMember, PersistentID> overallCompactInfo = new HashMap<>();
-        Set<InternalDistributedMember> allMembers = new HashSet<InternalDistributedMember>();
+        Set<InternalDistributedMember> allMembers = new HashSet<>();
-        otherMembers = null;
-          final Set<InternalDistributedMember> selectedMembers =
-              new HashSet<InternalDistributedMember>();
+          final Set<InternalDistributedMember> selectedMembers = new HashSet<>();
-          for (Iterator<InternalDistributedMember> iterator = allMembers.iterator(); iterator
-              .hasNext();) {
-            InternalDistributedMember member = iterator.next();
+          for (InternalDistributedMember member : allMembers) {
-            SectionResultData section = null;
+            SectionResultData section;
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-    Result result = null;
+    Result result;
-    String errorMessage = "";
+    StringBuilder errorMessage = new StringBuilder();
-      List<String> commandList = new ArrayList<String>();
+      List<String> commandList = new ArrayList<>();
-        for (int i = 0; i < jvmProps.length; i++) {
-          commandList.add(jvmProps[i]);
-        }
+        commandList.addAll(Arrays.asList(jvmProps));
-      String line = null;
+      String line;
-      line = null;
-          errorMessage = errorMessage + line;
+          errorMessage.append(line);
-      if (!errorMessage.isEmpty()) {
-        throw new GemFireIOException(errorMessage);
+      if (errorMessage.length() > 0) {
+        throw new GemFireIOException(errorMessage.toString());
-      result = ResultBuilder.createUserErrorResult(errorMessage);
+      result = ResultBuilder.createUserErrorResult(errorMessage.toString());
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-    Result result = null;
+    Result result;
-    String errorMessage = "";
+    StringBuilder errorMessage = new StringBuilder();
-      List<String> commandList = new ArrayList<String>();
+      List<String> commandList = new ArrayList<>();
-        for (int i = 0; i < jvmProps.length; i++) {
-          commandList.add(jvmProps[i]);
-        }
+        commandList.addAll(Arrays.asList(jvmProps));
-      String line = null;
+      String line;
-      line = null;
-          errorMessage = errorMessage + line;
+          errorMessage.append(line);
-      if (!errorMessage.isEmpty()) {
-        throw new GemFireIOException(errorMessage);
+      if (errorMessage.length() > 0) {
+        throw new GemFireIOException(errorMessage.toString());
-      result = ResultBuilder.createUserErrorResult(errorMessage);
+      result = ResultBuilder.createUserErrorResult(errorMessage.toString());
-    File diskDir = null;
+    File diskDir;
-  @CliMetaData(shellOnly = false, relatedTopic = {CliStrings.TOPIC_GEODE_DISKSTORE})
+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DISKSTORE})
-    } catch (DiskStoreNotFoundException e) {
-      return ResultBuilder.createShellClientErrorResult(e.getMessage());
-    } catch (MemberNotFoundException e) {
+    } catch (DiskStoreNotFoundException | MemberNotFoundException e) {
-  @ResourceOperation(resource = Resource.DATA, operation = Operation.MANAGE)
+  @ResourceOperation(resource = Resource.CLUSTER, operation = Operation.MANAGE,
+      target = Target.DISK)
-    final List<Object> distributedPersistentRecoveryDetails = new ArrayList<Object>(results.size());
+    final List<Object> distributedPersistentRecoveryDetails = new ArrayList<>(results.size());
-    List<PersistentMemberPattern> missingDiskStores = new ArrayList<PersistentMemberPattern>();
-    List<ColocatedRegionDetails> missingColocatedRegions = new ArrayList<ColocatedRegionDetails>();
+    List<PersistentMemberPattern> missingDiskStores = new ArrayList<>();
+    List<ColocatedRegionDetails> missingColocatedRegions = new ArrayList<>();
-      for (PersistentMemberPattern peristentMemberDetails : missingDiskStores) {
-        missingDiskStoreData.accumulate("Disk Store ID", peristentMemberDetails.getUUID());
-        missingDiskStoreData.accumulate("Host", peristentMemberDetails.getHost());
-        missingDiskStoreData.accumulate("Directory", peristentMemberDetails.getDirectory());
+      for (PersistentMemberPattern persistentMemberDetails : missingDiskStores) {
+        missingDiskStoreData.accumulate("Disk Store ID", persistentMemberDetails.getUUID());
+        missingDiskStoreData.accumulate("Host", persistentMemberDetails.getHost());
+        missingDiskStoreData.accumulate("Directory", persistentMemberDetails.getDirectory());
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          help = CliStrings.DESCRIBE_OFFLINE_DISK_STORE__REGIONNAME__HELP,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE) String regionName) {
+          help = CliStrings.DESCRIBE_OFFLINE_DISK_STORE__REGIONNAME__HELP) String regionName) {
-      return ResultBuilder.createInfoResult(resultString.toString());
+      return ResultBuilder.createInfoResult(resultString);
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-      String resultString = new String();
-
-      for (int i = 0; i < diskDirs.length; i++) {
-        dirList.append(diskDirs[i]);
+      for (String diskDir : diskDirs) {
+        dirList.append(diskDir);
-      List<String> commandList = new ArrayList<String>();
+      List<String> commandList = new ArrayList<>();
-        for (int i = 0; i < jvmProps.length; i++) {
-          commandList.add(jvmProps[i]);
-        }
+        commandList.addAll(Arrays.asList(jvmProps));
-      String errorString = new String();
+      String errorString = "";
-      String line = null;
+      String line;
-      if (errorString != null) {
-        output.append(errorString).append(GfshParser.LINE_SEPARATOR);
-      }
-      resultString = "Validating " + diskStoreName + GfshParser.LINE_SEPARATOR + output.toString();
-      return ResultBuilder.createInfoResult(resultString.toString());
+      output.append(errorString).append(GfshParser.LINE_SEPARATOR);
+      String resultString =
+          "Validating " + diskStoreName + GfshParser.LINE_SEPARATOR + output.toString();
+      return ResultBuilder.createInfoResult(resultString);
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-      @CliOption(key = CliStrings.ALTER_DISK_STORE__COMPRESSOR,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          specifiedDefaultValue = "none",
+      @CliOption(key = CliStrings.ALTER_DISK_STORE__COMPRESSOR, specifiedDefaultValue = "none",
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          help = CliStrings.ALTER_DISK_STORE__REMOVE__HELP, mandatory = false,
-          specifiedDefaultValue = "true", unspecifiedDefaultValue = "false") boolean remove) {
+          help = CliStrings.ALTER_DISK_STORE__REMOVE__HELP, specifiedDefaultValue = "true",
+          unspecifiedDefaultValue = "false") boolean remove) {
-    Result result = null;
+    Result result;
-  @CliMetaData(shellOnly = false, relatedTopic = {CliStrings.TOPIC_GEODE_DISKSTORE})
-  @ResourceOperation(resource = Resource.DATA, operation = Operation.MANAGE)
+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DISKSTORE})
+  @ResourceOperation(resource = Resource.CLUSTER, operation = Operation.MANAGE,
+      target = Target.DISK)

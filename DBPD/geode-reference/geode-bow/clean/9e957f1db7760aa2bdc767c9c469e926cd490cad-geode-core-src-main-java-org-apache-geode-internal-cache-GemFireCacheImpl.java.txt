GEODE-8060: Fix flakiness in GemFireCacheImplCloseTest (#5041)


+    doClose(reason, systemFailureCause, keepAlive, keepDS, skipAwait);
+  }
+
+  /**
+   * Returns true if the caller performed the actual closing of the cache. Returns false if the
+   * caller simply waited for another thread to perform the close.
+   */
+  @VisibleForTesting
+  boolean doClose(String reason, Throwable systemFailureCause, boolean keepAlive,
+      boolean keepDS, boolean skipAwait) {
-    if (isClosed()) {
-      if (!skipAwait && !Thread.currentThread().equals(CLOSING_THREAD.get())) {
-        waitUntilClosed();
-      }
-      return;
+    if (waitIfClosing(skipAwait)) {
+      return false;
-      return;
+      return false;
-      if (isClosed()) {
-        if (!skipAwait && !Thread.currentThread().equals(CLOSING_THREAD.get())) {
-          waitUntilClosed();
-        }
-        return;
+      if (waitIfClosing(skipAwait)) {
+        return false;
+      return true;
-  private void waitUntilClosed() {
-    try {
-      isClosedLatch.await();
-    } catch (InterruptedException ignore) {
-      // ignored
+  /**
+   * Returns true if caller waited on the {@code isClosedLatch}.
+   */
+  private boolean waitIfClosing(boolean skipAwait) {
+    if (isClosing) {
+      if (!skipAwait && !Thread.currentThread().equals(CLOSING_THREAD.get())) {
+        boolean interrupted = false;
+        try {
+          isClosedLatch.await();
+        } catch (InterruptedException e) {
+          interrupted = true;
+        } finally {
+          if (interrupted) {
+            Thread.currentThread().interrupt();
+          }
+        }
+      }
+      return true;
+    return false;

Merge branch 'release/1.0.0-incubating.M3'

-
+import javax.management.Descriptor;
+import javax.management.MBeanFeatureInfo;
+import javax.management.Query;
+import com.gemstone.gemfire.management.internal.ManagementConstants;
+import com.gemstone.gemfire.security.GemFireSecurityException;
+import com.gemstone.gemfire.internal.security.GeodeSecurityUtil;
+import org.apache.geode.security.GeodePermission;
+
+/**
+ * This class intercepts all MBean requests for GemFire MBeans and passed it to
+ * ManagementInterceptor for authorization
+ * @since Geode 1.0
+ *
+ */
-  
-  private ManagementInterceptor interceptor;
-  
-  public MBeanServerWrapper(ManagementInterceptor interceptor){
-    this.interceptor = interceptor;
+
+  public MBeanServerWrapper(){
-  
-  private void doAuthorization(ObjectName name, String methodName, Object[] methodParams){
-    interceptor.authorize(name,methodName, methodParams);
+
+  private void checkDomain(ObjectName name){
+    if (ManagementConstants.OBJECTNAME__DEFAULTDOMAIN.equals(name.getDomain()))
+      throw new SecurityException(ResourceConstants.ACCESS_DENIED_MESSAGE);
-      InstanceAlreadyExistsException, MBeanRegistrationException, MBeanException, NotCompliantMBeanException {
-    doAuthorization(name, "createMBean", new Object[]{name});
+      InstanceAlreadyExistsException, MBeanException, NotCompliantMBeanException {
+    checkDomain(name);
-      throws ReflectionException, InstanceAlreadyExistsException, MBeanRegistrationException, MBeanException,
+      throws ReflectionException, InstanceAlreadyExistsException, MBeanException,
-    doAuthorization(name, "createMBean", new Object[]{name});
+    checkDomain(name);
-      throws ReflectionException, InstanceAlreadyExistsException, MBeanRegistrationException, MBeanException,
+      throws ReflectionException, InstanceAlreadyExistsException, MBeanException,
-    doAuthorization(name, "createMBean", new Object[]{name, params});
-    return mbs.createMBean(className,name,params,signature);
+    checkDomain(name);
+    return mbs.createMBean(className, name, params, signature);
-      String[] signature) throws ReflectionException, InstanceAlreadyExistsException, MBeanRegistrationException,
+      String[] signature) throws ReflectionException, InstanceAlreadyExistsException,
-    doAuthorization(name, "createMBean", new Object[]{name});
+    checkDomain(name);
-    doAuthorization(name, "registerMBean", new Object[]{name});
+    checkDomain(name);
-    doAuthorization(name, "registerMBean", new Object[]{});
+    checkDomain(name);
-  public ObjectInstance getObjectInstance(ObjectName name) throws InstanceNotFoundException {    
+  public ObjectInstance getObjectInstance(ObjectName name) throws InstanceNotFoundException {
+  private static QueryExp notAccessControlMBean = Query.not(Query.isInstanceOf(Query.value(AccessControlMXBean.class.getName())));
-    return mbs.queryMBeans(name, query);
+    // We need to filter out the AccessControlMXBean so that the clients wouldn't see it
+    if(query!=null)
+      return mbs.queryMBeans(name, Query.and(query, notAccessControlMBean));
+    else
+      return mbs.queryMBeans(name,notAccessControlMBean);
-    return mbs.queryNames(name, query);
+    if(query!=null)
+      return mbs.queryNames(name, Query.and(query, notAccessControlMBean));
+    else
+      return mbs.queryNames(name,notAccessControlMBean);
-  public Integer getMBeanCount() {    
+  public Integer getMBeanCount() {
-  public Object getAttribute(ObjectName name, String attribute) throws MBeanException, AttributeNotFoundException,
-      InstanceNotFoundException, ReflectionException {
-    doAuthorization(name, "getAttribute",  new Object[]{attribute});
-    return mbs.getAttribute(name, attribute);
+  public Object getAttribute(ObjectName name, String attribute) throws MBeanException, InstanceNotFoundException,
+      ReflectionException {
+    GeodePermission ctx = getOperationContext(name, attribute, false);
+    GeodeSecurityUtil.authorize(ctx);
+    Object result;
+    try {
+      result = mbs.getAttribute(name, attribute);
+    } catch (AttributeNotFoundException nex) {
+      return null;
+    }
+    return result;
-    doAuthorization(name, "getAttributes", new Object[]{attributes});
-    return mbs.getAttributes(name, attributes);
+    AttributeList results = new AttributeList();
+    for(String attribute:attributes){
+      try {
+        Object value = getAttribute(name, attribute);
+        Attribute att = new Attribute(attribute, value);
+        results.add(att);
+      } catch (Exception e) {
+        throw new GemFireSecurityException("error getting value of "+attribute+" from "+name, e);
+      }
+    }
+    return results;
-    doAuthorization(name, "setAttribute", new Object[]{attribute});
+    GeodePermission ctx = getOperationContext(name, attribute.getName(), false);
+    GeodeSecurityUtil.authorize(ctx);
-    doAuthorization(name, "setAttributes", new Object[]{attributes});
-    return mbs.setAttributes(name, attributes);
+    // call setAttribute instead to use the authorization logic
+    for(Attribute attribute:attributes.asList()){
+      try {
+        setAttribute(name, attribute);
+      } catch (Exception e) {
+        throw new GemFireSecurityException("error setting attribute "+attribute+" of "+name, e);
+      }
+    }
+    return attributes;
-    doAuthorization(name, operationName, new Object[]{params, signature});
-    return mbs.invoke(name, operationName, params, signature);
+
+    GeodePermission ctx = getOperationContext(name, operationName, true);
+    GeodeSecurityUtil.authorize(ctx);
+
+    Object result = mbs.invoke(name, operationName, params, signature);
+
+    return result;
+  // TODO: cache this
+  private GeodePermission getOperationContext(ObjectName objectName, String featureName, boolean isOp)
+      throws InstanceNotFoundException, ReflectionException {
+    MBeanInfo beanInfo = null;
+    try {
+      beanInfo = mbs.getMBeanInfo(objectName);
+    } catch (IntrospectionException e) {
+      throw new GemFireSecurityException("error getting beanInfo of "+objectName, e);
+    }
+    // If there is no annotation defined either in the class level or method level, we should consider this operation/attribute freely accessible
+    GeodePermission result = null;
+
+    // find the context in the beanInfo if defined in the class level
+    result = getOperationContext(beanInfo.getDescriptor(), result);
+
+    MBeanFeatureInfo[] featureInfos = null;
+    if(isOp){
+      featureInfos = beanInfo.getOperations();
+    }
+    else{
+      featureInfos = beanInfo.getAttributes();
+    }
+    // still look into the attributes/operations to see if it's defined in the method level
+    for(MBeanFeatureInfo info:featureInfos){
+      if(info.getName().equals(featureName)){
+        // found the featureInfo of this method on the bean
+        result = getOperationContext(info.getDescriptor(), result);
+        break;
+      }
+    }
+    return result;
+  }
+
+  private GeodePermission getOperationContext(Descriptor descriptor, GeodePermission defaultValue){
+    String resource = (String)descriptor.getFieldValue("resource");
+    String operationCode = (String)descriptor.getFieldValue("operation");
+    if(resource!=null && operationCode!=null){
+      return new GeodePermission(resource, operationCode);
+    }
+    return defaultValue;
+  }
+
+
+  @SuppressWarnings("deprecation")

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.security.AuthenticationRequiredException;
-import org.apache.logging.log4j.Logger;
- * GMSJoinLeave handles membership communication with other processes in the
- * distributed system.  It replaces the JGroups channel membership services
- * that Geode formerly used for this purpose.
+ * GMSJoinLeave handles membership communication with other processes in the distributed system. It
+ * replaces the JGroups channel membership services that Geode formerly used for this purpose.
-  public static final String BYPASS_DISCOVERY_PROPERTY = DistributionConfig.GEMFIRE_PREFIX + "bypass-discovery";
+  public static final String BYPASS_DISCOVERY_PROPERTY =
+      DistributionConfig.GEMFIRE_PREFIX + "bypass-discovery";
-  private static final int DISCOVERY_TIMEOUT = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "discovery-timeout", 3000);
+  private static final int DISCOVERY_TIMEOUT =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "discovery-timeout", 3000);
-  private static final int JOIN_RETRY_SLEEP = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "join-retry-sleep", 1000);
+  private static final int JOIN_RETRY_SLEEP =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "join-retry-sleep", 1000);
-  private static final long BROADCAST_MESSAGE_SLEEP_TIME = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "broadcast-message-sleep-time", 1000);
+  private static final long BROADCAST_MESSAGE_SLEEP_TIME =
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "broadcast-message-sleep-time", 1000);
-   * if the locators don't know who the coordinator is we send find-coord requests to this many nodes
+   * if the locators don't know who the coordinator is we send find-coord requests to this many
+   * nodes
-  private static final int MAX_DISCOVERY_NODES = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "max-discovery-nodes", 30);
+  private static final int MAX_DISCOVERY_NODES =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "max-discovery-nodes", 30);
-  private static final long VIEW_BROADCAST_INTERVAL = Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "view-broadcast-interval", 60000);
+  private static final long VIEW_BROADCAST_INTERVAL =
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "view-broadcast-interval", 60000);
-   * the currently installed view.  Guarded by viewInstallationLock
+   * the currently installed view. Guarded by viewInstallationLock
-   * the established request collection jitter.  This can be overridden for testing with delayViewCreationForTest
+   * the established request collection jitter. This can be overridden for testing with
+   * delayViewCreationForTest
-   * attempt to join the distributed system
-   * loop
-   * send a join request to a locator & get a response
+   * attempt to join the distributed system loop send a join request to a locator & get a response
-   * If the response indicates there's no coordinator it
-   * will contain a set of members that have recently contacted
-   * it.  The "oldest" member is selected as the coordinator
-   * based on ID sort order.
+   * If the response indicates there's no coordinator it will contain a set of members that have
+   * recently contacted it. The "oldest" member is selected as the coordinator based on ID sort
+   * order.
-          logger.debug("sleeping for {} before making another attempt to find the coordinator", retrySleep);
+          logger.debug("sleeping for {} before making another attempt to find the coordinator",
+              retrySleep);
-        logger.debug("giving up attempting to join the distributed system after " + (System.currentTimeMillis() - startTime) + "ms");
+        logger.debug("giving up attempting to join the distributed system after "
+            + (System.currentTimeMillis() - startTime) + "ms");
-   * send a join request and wait for a reply.  Process the reply.
-   * This may throw a SystemConnectException or an AuthenticationFailedException
+   * send a join request and wait for a reply. Process the reply. This may throw a
+   * SystemConnectException or an AuthenticationFailedException
-      logger.info("Attempting to join the distributed system through coordinator " + coord + " using address " + this.localAddress);
+      logger.info("Attempting to join the distributed system through coordinator " + coord
+          + " using address " + this.localAddress);
-      JoinRequestMessage req = new JoinRequestMessage(coord, this.localAddress, services.getAuthenticator().getCredentials(coord), port, 
+      JoinRequestMessage req = new JoinRequestMessage(coord, this.localAddress,
+          services.getAuthenticator().getCredentials(coord), port,
-      //services.getMessenger().send(req, state.view);
+      // services.getMessenger().send(req, state.view);
+      } else if (failReason.contains("Failed to find credentials")) {
+        throw new AuthenticationRequiredException(failReason);
-    
-    //there is no way we can rech here right now
-    throw new RuntimeException("Join Request Failed with response " + joinResponse[0] );
+
+    // there is no way we can rech here right now
+    throw new RuntimeException("Join Request Failed with response " + joinResponse[0]);
-        long timeout = Math.max(services.getConfig().getMemberTimeout(), services.getConfig().getJoinTimeout() / 5);
+        long timeout = Math.max(services.getConfig().getMemberTimeout(),
+            services.getConfig().getJoinTimeout() / 5);
-      
+
-        //reset joinResponse[0]
+        // reset joinResponse[0]
-          long timeout = Math.max(services.getConfig().getMemberTimeout(), services.getConfig().getJoinTimeout() / 5);
+          long timeout = Math.max(services.getConfig().getMemberTimeout(),
+              services.getConfig().getJoinTimeout() / 5);
-   * process a join request from another member. If this is the coordinator
-   * this method will enqueue the request for processing in another thread.
-   * If this is not the coordinator but the coordinator is known, the message
-   * is forwarded to the coordinator.
+   * process a join request from another member. If this is the coordinator this method will enqueue
+   * the request for processing in another thread. If this is not the coordinator but the
+   * coordinator is known, the message is forwarded to the coordinator.
-      logger.warn("detected an attempt to start a peer using an older version of the product {}", incomingRequest.getMemberID());
-      JoinResponseMessage m = new JoinResponseMessage("Rejecting the attempt of a member using an older version", incomingRequest.getRequestId());
+      logger.warn("detected an attempt to start a peer using an older version of the product {}",
+          incomingRequest.getMemberID());
+      JoinResponseMessage m =
+          new JoinResponseMessage("Rejecting the attempt of a member using an older version of the "
+              + "product to join the distributed system", incomingRequest.getRequestId());
-      rejection = services.getAuthenticator().authenticate(incomingRequest.getMemberID(), (Properties)creds);
+      rejection = services.getAuthenticator().authenticate(incomingRequest.getMemberID(),
+          (Properties) creds);
-    //      Remove JoinResponseMessage to fix GEODE-870
-//    if (!this.localAddress.getNetMember().preferredForCoordinator() &&
-//        incomingRequest.getMemberID().getNetMember().preferredForCoordinator()) {
-//      JoinResponseMessage joinResponseMessage = new JoinResponseMessage(incomingRequest.getMemberID(), currentView, true);
-//      services.getMessenger().send(joinResponseMessage);
-//      return;
-//    }
+    // Remove JoinResponseMessage to fix GEODE-870
+    // if (!this.localAddress.getNetMember().preferredForCoordinator() &&
+    // incomingRequest.getMemberID().getNetMember().preferredForCoordinator()) {
+    // JoinResponseMessage joinResponseMessage = new
+    // JoinResponseMessage(incomingRequest.getMemberID(), currentView, true);
+    // services.getMessenger().send(joinResponseMessage);
+    // return;
+    // }
-   * Process a Leave request from another member. This may cause this member
-   * to become the new membership coordinator. If this is the coordinator
-   * a new view will be triggered.
+   * Process a Leave request from another member. This may cause this member to become the new
+   * membership coordinator. If this is the coordinator a new view will be triggered.
-    logger.info("received leave request from {} for {}", incomingRequest.getSender(), incomingRequest.getMemberID());
+    logger.info("received leave request from {} for {}", incomingRequest.getSender(),
+        incomingRequest.getMemberID());
-      logger.debug("JoinLeave.processLeaveRequest invoked.  isCoordinator=" + isCoordinator + "; isStopping=" + isStopping
-          + "; cancelInProgress=" + services.getCancelCriterion().isCancelInProgress());
+      logger.debug("JoinLeave.processLeaveRequest invoked.  isCoordinator=" + isCoordinator
+          + "; isStopping=" + isStopping + "; cancelInProgress="
+          + services.getCancelCriterion().isCancelInProgress());
-      logger.info("I am being told to leave the distributed system by {}", incomingRequest.getSender());
+      logger.info("I am being told to leave the distributed system by {}",
+          incomingRequest.getSender());
-   * Process a Remove request from another member. This may cause this member
-   * to become the new membership coordinator. If this is the coordinator
-   * a new view will be triggered.
+   * Process a Remove request from another member. This may cause this member to become the new
+   * membership coordinator. If this is the coordinator a new view will be triggered.
-    boolean fromMe = incomingRequest.getSender() == null ||
-        incomingRequest.getSender().equals(localAddress);
+    boolean fromMe =
+        incomingRequest.getSender() == null || incomingRequest.getSender().equals(localAddress);
-      logger.info("Membership ignoring removal request for " + mbr + " from non-member " + incomingRequest.getSender());
+      logger.info("Membership ignoring removal request for " + mbr + " from non-member "
+          + incomingRequest.getSender());
-      logger.info("Membership received a request to remove " + mbr
-          + " from " + incomingRequest.getSender()
-          + " reason=" + incomingRequest.getReason());
+      logger.info("Membership received a request to remove " + mbr + " from "
+          + incomingRequest.getSender() + " reason=" + incomingRequest.getReason());
-      if (viewCreator != null) {
-        boolean joinResponseSent = viewCreator.informToPendingJoinRequests();
-
-        if (!joinResponseSent && request instanceof JoinRequestMessage) {
+      if (viewCreator != null && services.getMessenger().getClusterSecretKey() != null) {
+        if (request instanceof JoinRequestMessage) {
-          JoinResponseMessage response = new JoinResponseMessage(jreq.getSender(), services.getMessenger().getClusterSecretKey(), jreq.getRequestId());
+          JoinResponseMessage response = new JoinResponseMessage(jreq.getSender(),
+              services.getMessenger().getClusterSecretKey(), jreq.getRequestId());
-    
+
-  
+
-   * Test hook for delaying the creation of new views.
-   * This should be invoked before this member becomes coordinator
-   * and creates its ViewCreator thread.
+   * Test hook for delaying the creation of new views. This should be invoked before this member
+   * becomes coordinator and creates its ViewCreator thread.
-   * Transitions this member into the coordinator role.  This must
-   * be invoked under a synch on viewInstallationLock that was held
-   * at the time the decision was made to become coordinator so that
-   * the decision is atomic with actually becoming coordinator.
+   * Transitions this member into the coordinator role. This must be invoked under a synch on
+   * viewInstallationLock that was held at the time the decision was made to become coordinator so
+   * that the decision is atomic with actually becoming coordinator.
-      newView.setFailureDetectionPort(localAddress, services.getHealthMonitor().getFailureDetectionPort());
+      newView.setFailureDetectionPort(localAddress,
+          services.getHealthMonitor().getFailureDetectionPort());
-        viewCreator.setInitialView(newView, newView.getNewMembers(), newView.getShutdownMembers(), newView.getCrashedMembers());
+        viewCreator.setInitialView(newView, newView.getNewMembers(), newView.getShutdownMembers(),
+            newView.getCrashedMembers());
-      newView = new NetView(this.localAddress, viewNumber, mbrs, leaving,
-          removals);
+      newView = new NetView(this.localAddress, viewNumber, mbrs, leaving, removals);
-      newView.setFailureDetectionPort(this.localAddress, services.getHealthMonitor().getFailureDetectionPort());
+      newView.setFailureDetectionPort(this.localAddress,
+          services.getHealthMonitor().getFailureDetectionPort());
-  private void sendJoinResponses(NetView newView, List<InternalDistributedMember> newMbrs) {
-    for (InternalDistributedMember mbr : newMbrs) {
-      JoinResponseMessage response = new JoinResponseMessage(mbr, newView, 0);
-      services.getMessenger().send(response);
-    }
-  }
-
-  private void sendRemoveMessages(List<InternalDistributedMember> removals, List<String> reasons, Set<InternalDistributedMember> oldIds) {
+  private void sendRemoveMessages(List<InternalDistributedMember> removals, List<String> reasons,
+      Set<InternalDistributedMember> oldIds) {
-      //if olds not contains mbr then send remove request 
+      // if olds not contains mbr then send remove request
-  boolean prepareView(NetView view, List<InternalDistributedMember> newMembers) throws InterruptedException {
+  boolean prepareView(NetView view, List<InternalDistributedMember> newMembers)
+      throws InterruptedException {
+    if (services.getCancelCriterion().isCancelInProgress()
+        || services.getManager().shutdownInProgress()) {
+      throw new InterruptedException("shutting down");
+    }
-  void sendView(NetView view, List<InternalDistributedMember> newMembers) throws InterruptedException {
+  void sendView(NetView view, List<InternalDistributedMember> newMembers)
+      throws InterruptedException {
+    if (services.getCancelCriterion().isCancelInProgress()
+        || services.getManager().shutdownInProgress()) {
+      throw new InterruptedException("shutting down");
+    }
-  private boolean sendView(NetView view, boolean preparing, ViewReplyProcessor viewReplyProcessor) throws InterruptedException {
+  private boolean sendView(NetView view, boolean preparing, ViewReplyProcessor viewReplyProcessor)
+      throws InterruptedException {
-    InstallViewMessage msg = new InstallViewMessage(view, services.getAuthenticator().getCredentials(this.localAddress), preparing);
+    InstallViewMessage msg = new InstallViewMessage(view,
+        services.getAuthenticator().getCredentials(this.localAddress), preparing);
-      //Added a check in the view processor to turn off the ViewCreator
-      //if another server is the coordinator - GEODE-870
-      if (isCoordinator && !localAddress.equals(view.getCoordinator()) && getViewCreator() != null) {
+      // Added a check in the view processor to turn off the ViewCreator
+      // if another server is the coordinator - GEODE-870
+      if (isCoordinator && !localAddress.equals(view.getCoordinator())
+          && getViewCreator() != null) {
-      InternalDistributedMember conflictingViewSender = viewReplyProcessor.getConflictingViewSender();
+      InternalDistributedMember conflictingViewSender =
+          viewReplyProcessor.getConflictingViewSender();
+
-    
-    //If our current view doesn't contaion sender then we wanrt to ignore that view.
-    if(currentView != null && !currentView.contains(m.getSender())) {
-      //but if preparedView contains sender then we don't want to ignore that view.
-      //this may happen when we locator re-join and it take over coordinator's responsibility.
-      if(this.preparedView == null || !this.preparedView.contains(m.getSender())) 
-      { 
-        logger.info("Ignoring the view {} from member {}, which is not in my current view {} ", view, m.getSender(), currentView);
+
+    // If our current view doesn't contaion sender then we wanrt to ignore that view.
+    if (currentView != null && !currentView.contains(m.getSender())) {
+      // but if preparedView contains sender then we don't want to ignore that view.
+      // this may happen when we locator re-join and it take over coordinator's responsibility.
+      if (this.preparedView == null || !this.preparedView.contains(m.getSender())) {
+        logger.info("Ignoring the view {} from member {}, which is not in my current view {} ",
+            view, m.getSender(), currentView);
-        logger.fatal("This member is no longer in the membership view.  My ID is {} and the new view is {}", localAddress, view);
+        logger.fatal(
+            "This member is no longer in the membership view.  My ID is {} and the new view is {}",
+            localAddress, view);
-      services.getMessenger().send(new ViewAckMessage(m.getSender(), m.getView().getViewId(), m.isPreparing()));
+      services.getMessenger()
+          .send(new ViewAckMessage(m.getSender(), m.getView().getViewId(), m.isPreparing()));
-   * testing purpose.  Sets the TcpClient that is used by GMSJoinLeave
-   * to communicate with Locators.
+   * testing purpose. Sets the TcpClient that is used by GMSJoinLeave to communicate with Locators.
-   * This contacts the locators to find out who the current coordinator is.
-   * All locators are contacted. If they don't agree then we choose the oldest
-   * coordinator and return it.
+   * This contacts the locators to find out who the current coordinator is. All locators are
+   * contacted. If they don't agree then we choose the oldest coordinator and return it.
-    FindCoordinatorRequest request = new FindCoordinatorRequest(this.localAddress, state.alreadyTried, state.viewId, 
-        services.getMessenger().getPublicKey(localAddress), services.getMessenger().getRequestId(), dhalgo);
+    FindCoordinatorRequest request = new FindCoordinatorRequest(this.localAddress,
+        state.alreadyTried, state.viewId, services.getMessenger().getPublicKey(localAddress),
+        services.getMessenger().getRequestId(), dhalgo);
-    long giveUpTime = System.currentTimeMillis() + ((long) services.getConfig().getLocatorWaitTime() * 1000L);
+    long giveUpTime =
+        System.currentTimeMillis() + ((long) services.getConfig().getLocatorWaitTime() * 1000L);
-          FindCoordinatorResponse response = (o instanceof FindCoordinatorResponse) ? (FindCoordinatorResponse) o : null;
+          FindCoordinatorResponse response =
+              (o instanceof FindCoordinatorResponse) ? (FindCoordinatorResponse) o : null;
-            if(response.getRejectionMessage() != null ) {
+            if (response.getRejectionMessage() != null) {
-            if (!state.hasContactedAJoinedLocator &&
-                response.getSenderId() != null && response.getSenderId().getVmViewId() >= 0) {
+            if (!state.hasContactedAJoinedLocator && response.getSenderId() != null
+                && response.getSenderId().getVmViewId() >= 0) {
-              
+
-    
+
-    for (; it.hasNext(); ) {
+    for (; it.hasNext();) {
-    protected Object sendCoordinatorFindRequest(InetSocketAddress addr, FindCoordinatorRequest request, int connectTimeout)
+    protected Object sendCoordinatorFindRequest(InetSocketAddress addr,
+        FindCoordinatorRequest request, int connectTimeout)
-      return client.requestToServer(
-          addr.getAddress(), addr.getPort(), request, connectTimeout,
+      return client.requestToServer(addr.getAddress(), addr.getPort(), request, connectTimeout,
-    recipients.remove(localAddress);    
+    recipients.remove(localAddress);
-   // FindCoordinatorRequest req = new FindCoordinatorRequest(localAddress, state.alreadyTried, state.viewId, services.getMessenger().getPublickey(
-     //   localAddress), services.getMessenger().getRequestId());
-    //req.setRecipients(v.getMembers());
-    
+    // FindCoordinatorRequest req = new FindCoordinatorRequest(localAddress, state.alreadyTried,
+    // state.viewId, services.getMessenger().getPublickey(
+    // localAddress), services.getMessenger().getRequestId());
+    // req.setRecipients(v.getMembers());
+
-      
-      String dhalgo = services.getConfig().getDistributionConfig().getSecurityUDPDHAlgo(); 
+
+      String dhalgo = services.getConfig().getDistributionConfig().getSecurityUDPDHAlgo();
-        //Here we are sending message one-by-one to all recipients as we don't have cluster secret key yet.
-        //Usually this happens when locator re-joins the cluster and it has saved view.
+        // Here we are sending message one-by-one to all recipients as we don't have cluster secret
+        // key yet.
+        // Usually this happens when locator re-joins the cluster and it has saved view.
-          FindCoordinatorRequest req = new FindCoordinatorRequest(localAddress, state.alreadyTried, state.viewId, services.getMessenger().getPublicKey(
-              localAddress), services.getMessenger().getRequestId(), dhalgo);
+          FindCoordinatorRequest req = new FindCoordinatorRequest(localAddress, state.alreadyTried,
+              state.viewId, services.getMessenger().getPublicKey(localAddress),
+              services.getMessenger().getRequestId(), dhalgo);
-        FindCoordinatorRequest req = new FindCoordinatorRequest(localAddress, state.alreadyTried, state.viewId, services.getMessenger().getPublicKey(
-            localAddress), services.getMessenger().getRequestId(), dhalgo);
+        FindCoordinatorRequest req = new FindCoordinatorRequest(localAddress, state.alreadyTried,
+            state.viewId, services.getMessenger().getPublicKey(localAddress),
+            services.getMessenger().getRequestId(), dhalgo);
-        //1. our joinRequest rejected.
-        //2. Member which was coordinator but just now some other member became coordinator
-        //3. we got message with secret key, but still view is coming and that will inform the joining thread
+        // 1. our joinRequest rejected.
+        // 2. Member which was coordinator but just now some other member became coordinator
+        // 3. we got message with secret key, but still view is coming and that will inform the
+        // joining thread
-          //we got secret key lets add it
+          // we got secret key lets add it
-      resp = new FindCoordinatorResponse(v.getCoordinator(), localAddress, 
+      resp = new FindCoordinatorResponse(v.getCoordinator(), localAddress,
-      resp = new FindCoordinatorResponse(localAddress, localAddress, 
+      resp = new FindCoordinatorResponse(localAddress, localAddress,
-  
+
-      services.getMessenger().setPublicKey(response.getCoordinatorPublicKey(), response.getCoordinator());
+      services.getMessenger().setPublicKey(response.getCoordinatorPublicKey(),
+          response.getCoordinator());
-    String str = "Membership coordinator " + msg.getSender() + " has declared that a network partition has occurred";
+    String str = "Membership coordinator " + msg.getSender()
+        + " has declared that a network partition has occurred";
-          forceDisconnect(LocalizedStrings.Network_partition_detected.toLocalizedString(crashes.size(), crashes));
+          forceDisconnect(LocalizedStrings.Network_partition_detected
+              .toLocalizedString(crashes.size(), crashes));
-          for (Iterator<DistributionMessage> it = viewRequests.iterator(); it.hasNext(); ) {
+          for (Iterator<DistributionMessage> it = viewRequests.iterator(); it.hasNext();) {
-              it.remove();
+              if (currentView.contains(((JoinRequestMessage) m).getMemberID())) {
+                it.remove();
+              }
-  private void removeMembersFromCollectionIfNotInView(Collection<InternalDistributedMember> members, NetView currentView) {
+  private void removeMembersFromCollectionIfNotInView(Collection<InternalDistributedMember> members,
+      NetView currentView) {
-   * Sends a message declaring a network partition to the
-   * members of the given view via Messenger
+   * Sends a message declaring a network partition to the members of the given view via Messenger
-   * returns true if this member thinks it is the membership coordinator
-   * for the distributed system
+   * returns true if this member thinks it is the membership coordinator for the distributed system
-      if (logger.isInfoEnabled()
-          && newView.getCreator().equals(localAddress)) { // view-creator logs this
+      if (logger.isInfoEnabled() && newView.getCreator().equals(localAddress)) { // view-creator
+                                                                                 // logs this
-        logger.warn("total weight lost in this view change is {} of {}.  Quorum has been lost!", failedWeight, oldWeight);
+        logger.warn("total weight lost in this view change is {} of {}.  Quorum has been lost!",
+            failedWeight, oldWeight);
+      try {
+        viewCreator.join(1000);
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+      }
-    services.getTimer().schedule(new ViewBroadcaster(), VIEW_BROADCAST_INTERVAL, VIEW_BROADCAST_INTERVAL);
+    services.getTimer().schedule(new ViewBroadcaster(), VIEW_BROADCAST_INTERVAL,
+        VIEW_BROADCAST_INTERVAL);
-  public static void loadEmergencyClasses() {
-  }
+  public static void loadEmergencyClasses() {}
-  public void beSick() {
-  }
+  public void beSick() {}
-  public void start() {
-  }
+  public void start() {}
-    GMSMember mbr = (GMSMember)this.localAddress.getNetMember();
+    GMSMember mbr = (GMSMember) this.localAddress.getNetMember();
-      if (services.getLocator() != null
-              || Locator.hasLocator()
-              || !services.getConfig().getDistributionConfig().getStartLocator().isEmpty()
-              || localAddress.getVmKind() == DistributionManager.LOCATOR_DM_TYPE) {
-        logger.info("This member is hosting a locator will be preferred as a membership coordinator");
+      if (services.getLocator() != null || Locator.hasLocator()
+          || !services.getConfig().getDistributionConfig().getStartLocator().isEmpty()
+          || localAddress.getVmKind() == DistributionManager.LOCATOR_DM_TYPE) {
+        logger
+            .info("This member is hosting a locator will be preferred as a membership coordinator");
-  public void stopped() {
-  }
+  public void stopped() {}
-  public void memberSuspected(InternalDistributedMember initiator, InternalDistributedMember suspect, String reason) {
+  public void memberSuspected(InternalDistributedMember initiator,
+      InternalDistributedMember suspect, String reason) {
-          List<InternalDistributedMember> coords = view.getPreferredCoordinators(Collections.emptySet(), localAddress, 5);
+          List<InternalDistributedMember> coords =
+              view.getPreferredCoordinators(Collections.emptySet(), localAddress, 5);
-          LeaveRequestMessage m = new LeaveRequestMessage(coords, this.localAddress, "this member is shutting down");
+          LeaveRequestMessage m =
+              new LeaveRequestMessage(coords, this.localAddress, "this member is shutting down");
-      RemoveMemberMessage msg = new RemoveMemberMessage(v.getPreferredCoordinators(filter, getMemberID(), 5), m, reason);
+      RemoveMemberMessage msg =
+          new RemoveMemberMessage(v.getPreferredCoordinators(filter, getMemberID(), 5), m, reason);
-    LeaveRequestMessage msg = new LeaveRequestMessage(Collections.singleton(this.localAddress), (InternalDistributedMember) mbr, reason);
+    LeaveRequestMessage msg = new LeaveRequestMessage(Collections.singleton(this.localAddress),
+        (InternalDistributedMember) mbr, reason);
-    if (dc.getMcastPort() != 0 && dc.getLocators().trim().isEmpty() && dc.getStartLocator().trim().isEmpty()) {
-      throw new GemFireConfigException(
-          "Multicast cannot be configured for a non-distributed cache." + "  Please configure the locator services for this cache using "
-              + LOCATORS + " or " + START_LOCATOR + ".");
+    if (dc.getMcastPort() != 0 && dc.getLocators().trim().isEmpty()
+        && dc.getStartLocator().trim().isEmpty()) {
+      throw new GemFireConfigException("Multicast cannot be configured for a non-distributed cache."
+          + "  Please configure the locator services for this cache using " + LOCATORS + " or "
+          + START_LOCATOR + ".");
-    services.getMessenger().addHandler(JoinRequestMessage.class, this);
-    services.getMessenger().addHandler(JoinResponseMessage.class, this);
-    ackCollectionTimeout = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "VIEW_ACK_TIMEOUT", ackCollectionTimeout).intValue();
+    ackCollectionTimeout = Integer
+        .getInteger(DistributionConfig.GEMFIRE_PREFIX + "VIEW_ACK_TIMEOUT", ackCollectionTimeout)
+        .intValue();
-    this.quorumRequired = services.getConfig().getDistributionConfig().getEnableNetworkPartitionDetection();
+    this.quorumRequired =
+        services.getConfig().getDistributionConfig().getEnableNetworkPartitionDetection();
-    case JOIN_REQUEST:
-      assert m instanceof JoinRequestMessage;
-      processJoinRequest((JoinRequestMessage) m);
-      break;
-    case JOIN_RESPONSE:
-      assert m instanceof JoinResponseMessage;
-      processJoinResponse((JoinResponseMessage) m);
-      break;
-    case INSTALL_VIEW_MESSAGE:
-      assert m instanceof InstallViewMessage;
-      processViewMessage((InstallViewMessage) m);
-      break;
-    case VIEW_ACK_MESSAGE:
-      assert m instanceof ViewAckMessage;
-      processViewAckMessage((ViewAckMessage) m);
-      break;
-    case LEAVE_REQUEST_MESSAGE:
-      assert m instanceof LeaveRequestMessage;
-      processLeaveRequest((LeaveRequestMessage) m);
-      break;
-    case REMOVE_MEMBER_REQUEST:
-      assert m instanceof RemoveMemberMessage;
-      processRemoveRequest((RemoveMemberMessage) m);
-      break;
-    case FIND_COORDINATOR_REQ:
-      assert m instanceof FindCoordinatorRequest;
-      processFindCoordinatorRequest((FindCoordinatorRequest) m);
-      break;
-    case FIND_COORDINATOR_RESP:
-      assert m instanceof FindCoordinatorResponse;
-      processFindCoordinatorResponse((FindCoordinatorResponse) m);
-      break;
-    case NETWORK_PARTITION_MESSAGE:
-      assert m instanceof NetworkPartitionMessage;
-      processNetworkPartitionMessage((NetworkPartitionMessage) m);
-      break;
-    default:
-      throw new IllegalArgumentException("unknown message type: " + m);
+      case JOIN_REQUEST:
+        assert m instanceof JoinRequestMessage;
+        processJoinRequest((JoinRequestMessage) m);
+        break;
+      case JOIN_RESPONSE:
+        assert m instanceof JoinResponseMessage;
+        processJoinResponse((JoinResponseMessage) m);
+        break;
+      case INSTALL_VIEW_MESSAGE:
+        assert m instanceof InstallViewMessage;
+        processViewMessage((InstallViewMessage) m);
+        break;
+      case VIEW_ACK_MESSAGE:
+        assert m instanceof ViewAckMessage;
+        processViewAckMessage((ViewAckMessage) m);
+        break;
+      case LEAVE_REQUEST_MESSAGE:
+        assert m instanceof LeaveRequestMessage;
+        processLeaveRequest((LeaveRequestMessage) m);
+        break;
+      case REMOVE_MEMBER_REQUEST:
+        assert m instanceof RemoveMemberMessage;
+        processRemoveRequest((RemoveMemberMessage) m);
+        break;
+      case FIND_COORDINATOR_REQ:
+        assert m instanceof FindCoordinatorRequest;
+        processFindCoordinatorRequest((FindCoordinatorRequest) m);
+        break;
+      case FIND_COORDINATOR_RESP:
+        assert m instanceof FindCoordinatorResponse;
+        processFindCoordinatorResponse((FindCoordinatorResponse) m);
+        break;
+      case NETWORK_PARTITION_MESSAGE:
+        assert m instanceof NetworkPartitionMessage;
+        processNetworkPartitionMessage((NetworkPartitionMessage) m);
+        break;
+      default:
+        throw new IllegalArgumentException("unknown message type: " + m);
-   * returns the member IDs of the pending requests having the given
-   * DataSerializableFixedID
+   * returns the member IDs of the pending requests having the given DataSerializableFixedID
-    synchronized void processPendingRequests(Set<InternalDistributedMember> pendingLeaves, Set<InternalDistributedMember> pendingRemovals) {
+    synchronized void processPendingRequests(Set<InternalDistributedMember> pendingLeaves,
+        Set<InternalDistributedMember> pendingRemovals) {
-    synchronized void processViewResponse(int viewId, InternalDistributedMember sender, NetView conflictingView) {
+    synchronized void processViewResponse(int viewId, InternalDistributedMember sender,
+        NetView conflictingView) {
-      if (notRepliedYet.isEmpty() || (pendingRemovals != null && pendingRemovals.containsAll(notRepliedYet))) {
+      if (notRepliedYet.isEmpty()
+          || (pendingRemovals != null && pendingRemovals.containsAll(notRepliedYet))) {
-        while (System.currentTimeMillis() < endOfWait && (!services.getCancelCriterion().isCancelInProgress())) {
+        while (System.currentTimeMillis() < endOfWait
+            && (!services.getCancelCriterion().isCancelInProgress())) {
-   * ViewBroadcaster periodically sends the current view to all
-   * current and departed members.  This ensures that a member that
-   * missed the view will eventually see it and act on it.
+   * ViewBroadcaster periodically sends the current view to all current and departed members. This
+   * ensures that a member that missed the view will eventually see it and act on it.
-        InstallViewMessage msg = new InstallViewMessage(v, services.getAuthenticator().getCredentials(localAddress), false);
-        Collection<InternalDistributedMember> recips = new ArrayList<>(v.size() + v.getCrashedMembers().size());
+        InstallViewMessage msg = new InstallViewMessage(v,
+            services.getAuthenticator().getCredentials(localAddress), false);
+        Collection<InternalDistributedMember> recips =
+            new ArrayList<>(v.size() + v.getCrashedMembers().size());
-     * initial view to install.  guarded by synch on ViewCreator
+     * initial view to install. guarded by synch on ViewCreator
-     * initial joining members.  guarded by synch on ViewCreator
+     * initial joining members. guarded by synch on ViewCreator
-     * initial leaving members  guarded by synch on ViewCreator
+     * initial leaving members guarded by synch on ViewCreator
-     * initial crashed members.  guarded by synch on ViewCreator
+     * initial crashed members. guarded by synch on ViewCreator
-     * All views should be sent by the ViewCreator thread, so
-     * if this member becomes coordinator it may have an initial
-     * view to transmit that announces the removal of the former coordinator to
+     * All views should be sent by the ViewCreator thread, so if this member becomes coordinator it
+     * may have an initial view to transmit that announces the removal of the former coordinator to
-     * @param leaving  - members leaving in this view
+     * @param leaving - members leaving in this view
-     * During initial view processing a prepared view was discovered.
-     * This method will extract its new members and create a new
-     * initial view containing them.
+     * During initial view processing a prepared view was discovered. This method will extract its
+     * new members and create a new initial view containing them.
-        for (; ; ) {
+        for (;;) {
-            logger.info("View Creator is processing {} requests for the next membership view", requests.size());
+            logger.info("View Creator is processing {} requests for the next membership view",
+                requests.size());
-    
+
-      boolean joinResponseSent = false;
+
-        return joinResponseSent;
+        return false;
-      ArrayList<DistributionMessage> requests = new ArrayList<>();
-      synchronized (viewRequests) {
-        if (viewRequests.size() > 0) {
-          requests.addAll(viewRequests);
-        } else {
-          return joinResponseSent;
-        }
-        viewRequests.clear();
+      NetView v = currentView;
+      if (v.getCoordinator().equals(localAddress)) {
+        return false;
-      NetView v = currentView;
-      for (DistributionMessage msg : requests) {
-        switch (msg.getDSFID()) {
-        case JOIN_REQUEST:               
-          logger.debug("Informing to pending join requests {} myid {} coord {}", msg, localAddress, v.getCoordinator());
-          if (!v.getCoordinator().equals(localAddress)) {
-            joinResponseSent = true;
-            //lets inform that coordinator has been changed
-            JoinResponseMessage jrm = new JoinResponseMessage(((JoinRequestMessage) msg).getMemberID(), v, ((JoinRequestMessage) msg).getRequestId());
-            services.getMessenger().send(jrm);
+      ArrayList<JoinRequestMessage> requests = new ArrayList<>();
+      synchronized (viewRequests) {
+        if (viewRequests.isEmpty()) {
+          return false;
+        }
+        for (Iterator<DistributionMessage> iterator = viewRequests.iterator(); iterator
+            .hasNext();) {
+          DistributionMessage msg = iterator.next();
+          switch (msg.getDSFID()) {
+            case JOIN_REQUEST:
+              requests.add((JoinRequestMessage) msg);
+              break;
+            default:
+              break;
-        default:
-          break;
-      
-      return joinResponseSent;
+
+      if (requests.isEmpty()) {
+        return false;
+      }
+
+      for (JoinRequestMessage msg : requests) {
+        logger.debug("Sending coordinator to pending join request from {} myid {} coord {}",
+            msg.getSender(), localAddress, v.getCoordinator());
+        JoinResponseMessage jrm = new JoinResponseMessage(msg.getMemberID(), v, msg.getRequestId());
+        services.getMessenger().send(jrm);
+      }
+
+      return true;
-     * Create a new membership view and send it to members (including crashed members).
-     * Returns false if the view cannot be prepared successfully, true otherwise
-     * @throws InterruptedException 
+     * Create a new membership view and send it to members (including crashed members). Returns
+     * false if the view cannot be prepared successfully, true otherwise
+     * 
+     * @throws InterruptedException
-        case JOIN_REQUEST:
-          JoinRequestMessage jmsg = (JoinRequestMessage) msg;
-          mbr = jmsg.getMemberID();
-          int port = jmsg.getFailureDetectionPort();
-          // see if an old member ID is being reused. If
-          // so we'll remove it from the new view
-          for (InternalDistributedMember m : oldMembers) {
-            if (mbr.compareTo(m, false) == 0) {
-              oldIDs.add(m);
-              break;
+          case JOIN_REQUEST:
+            JoinRequestMessage jmsg = (JoinRequestMessage) msg;
+            mbr = jmsg.getMemberID();
+            int port = jmsg.getFailureDetectionPort();
+            // see if an old member ID is being reused. If
+            // so we'll remove it from the new view
+            for (InternalDistributedMember m : oldMembers) {
+              if (mbr.compareTo(m, false) == 0) {
+                oldIDs.add(m);
+                break;
+              }
-          }
-          if (!joinReqs.contains(mbr)) {
-            joinReqs.add(mbr);
-            joinPorts.put(mbr, port);
-          }
-          break;
-        case LEAVE_REQUEST_MESSAGE:
-          mbr = ((LeaveRequestMessage) msg).getMemberID();
-          if (oldMembers.contains(mbr) && !leaveReqs.contains(mbr)) {
-            leaveReqs.add(mbr);
-          }
-          break;
-        case REMOVE_MEMBER_REQUEST:
-          // process these after gathering all leave-requests so that
-          // we don't kick out a member that's shutting down
-          break;
-        default:
-          logger.warn("Unknown membership request encountered: {}", msg);
-          break;
+            if (!joinReqs.contains(mbr)) {
+              joinReqs.add(mbr);
+              joinPorts.put(mbr, port);
+            }
+            break;
+          case LEAVE_REQUEST_MESSAGE:
+            mbr = ((LeaveRequestMessage) msg).getMemberID();
+            if (oldMembers.contains(mbr) && !leaveReqs.contains(mbr)) {
+              leaveReqs.add(mbr);
+            }
+            break;
+          case REMOVE_MEMBER_REQUEST:
+            // process these after gathering all leave-requests so that
+            // we don't kick out a member that's shutting down
+            break;
+          default:
+            logger.warn("Unknown membership request encountered: {}", msg);
+            break;
-        case REMOVE_MEMBER_REQUEST:
-          InternalDistributedMember mbr = ((RemoveMemberMessage) msg).getMemberID();
-          if (!leaveReqs.contains(mbr)) {
-            if (oldMembers.contains(mbr) && !removalReqs.contains(mbr)) {
-              removalReqs.add(mbr);
-              removalReasons.add(((RemoveMemberMessage) msg).getReason());
-            } else {
-              sendRemoveMessages(Collections.singletonList(mbr),
-                  Collections.singletonList(((RemoveMemberMessage) msg).getReason()), new HashSet<InternalDistributedMember>());
+          case REMOVE_MEMBER_REQUEST:
+            InternalDistributedMember mbr = ((RemoveMemberMessage) msg).getMemberID();
+            if (!leaveReqs.contains(mbr)) {
+              if (oldMembers.contains(mbr) && !removalReqs.contains(mbr)) {
+                removalReqs.add(mbr);
+                removalReasons.add(((RemoveMemberMessage) msg).getReason());
+              } else {
+                sendRemoveMessages(Collections.singletonList(mbr),
+                    Collections.singletonList(((RemoveMemberMessage) msg).getReason()),
+                    new HashSet<InternalDistributedMember>());
+              }
-          }
-          break;
-        default:
-          break;
+            break;
+          default:
+            break;
-        newView = new NetView(localAddress, viewNumber, mbrs, leaveReqs, new HashSet<InternalDistributedMember>(removalReqs));
+        newView = new NetView(localAddress, viewNumber, mbrs, leaveReqs,
+            new HashSet<InternalDistributedMember>(removalReqs));
-     * @throws InterruptedException 
+     * 
+     * @throws InterruptedException
-    void prepareAndSendView(NetView newView, List<InternalDistributedMember> joinReqs, Set<InternalDistributedMember> leaveReqs,
-        Set<InternalDistributedMember> removalReqs) throws InterruptedException {
+    void prepareAndSendView(NetView newView, List<InternalDistributedMember> joinReqs,
+        Set<InternalDistributedMember> leaveReqs, Set<InternalDistributedMember> removalReqs)
+        throws InterruptedException {
-          
+
-          forceDisconnect(LocalizedStrings.Network_partition_detected.toLocalizedString(crashes.size(), crashes));
+          forceDisconnect(LocalizedStrings.Network_partition_detected
+              .toLocalizedString(crashes.size(), crashes));
-            //now lets get copy of it in viewRequests sync, as other thread might be accessing it 
+            // now lets get copy of it in viewRequests sync, as other thread might be accessing it
-        List<InternalDistributedMember> failures = new ArrayList<>(currentView.getCrashedMembers().size() + unresponsive.size());
+        List<InternalDistributedMember> failures =
+            new ArrayList<>(currentView.getCrashedMembers().size() + unresponsive.size());
-        if (conflictingView != null && !conflictingView.getCreator().equals(localAddress) && conflictingView.getViewId() > newView.getViewId()
-            && (lastConflictingView == null || conflictingView.getViewId() > lastConflictingView.getViewId())) {
+        if (conflictingView != null && !conflictingView.getCreator().equals(localAddress)
+            && conflictingView.getViewId() > newView.getViewId() && (lastConflictingView == null
+                || conflictingView.getViewId() > lastConflictingView.getViewId())) {
-          logger.info("adding these crashed members from a conflicting view to the crash-set for the next view: {}\nconflicting view: {}", unresponsive,
-              conflictingView);
+          logger.info(
+              "adding these crashed members from a conflicting view to the crash-set for the next view: {}\nconflicting view: {}",
+              unresponsive, conflictingView);
-            logger.info("adding these new members from a conflicting view to the new view: {}", newMembers);
+            logger.info("adding these new members from a conflicting view to the new view: {}",
+                newMembers);
-          logger.info("adding these unresponsive members to the crash-set for the next view: {}", unresponsive);
+          logger.info("adding these unresponsive members to the crash-set for the next view: {}",
+              unresponsive);
-          NetView tempView = new NetView(localAddress, newView.getViewId() + 1, newMembers, leaveReqs, removalReqs);
+          NetView tempView = new NetView(localAddress, newView.getViewId() + 1, newMembers,
+              leaveReqs, removalReqs);
-            reasons.add("Failed to acknowledge a new membership view and then failed tcp/ip connection attempt");
+            reasons.add(
+                "Failed to acknowledge a new membership view and then failed tcp/ip connection attempt");
-        // the current state as being prepared.  All members
+        // the current state as being prepared. All members
-     * performs health checks on the collection of members, removing any that
-     * are found to be healthy
+     * performs health checks on the collection of members, removing any that are found to be
+     * healthy
-    private void removeHealthyMembers(final Set<InternalDistributedMember> suspects) throws InterruptedException {
-      List<Callable<InternalDistributedMember>> checkers = new ArrayList<Callable<InternalDistributedMember>>(suspects.size());
+    private void removeHealthyMembers(final Set<InternalDistributedMember> suspects)
+        throws InterruptedException {
+      List<Callable<InternalDistributedMember>> checkers =
+          new ArrayList<Callable<InternalDistributedMember>>(suspects.size());
-      newRemovals.removeAll(newLeaves);  // if we received a Leave req the member is "healthy"
+      newRemovals.removeAll(newLeaves); // if we received a Leave req the member is "healthy"
-     * @param mbrs            collection of IDs to search for
+     * @param mbrs collection of IDs to search for
-     * @param requestType     leave/remove/join
+     * @param requestType leave/remove/join
-    protected void filterMembers(Collection<InternalDistributedMember> mbrs, Set<InternalDistributedMember> matchingMembers, short requestType) {
+    protected void filterMembers(Collection<InternalDistributedMember> mbrs,
+        Set<InternalDistributedMember> matchingMembers, short requestType) {
-        logger.debug("filterMembers: processing " + requests.size() + " requests for type " + requestType);
+        logger.debug(
+            "filterMembers: processing " + requests.size() + " requests for type " + requestType);
-    private <T> List<Future<T>> submitAll(ExecutorService executor, Collection<? extends Callable<T>> tasks) {
+    private <T> List<Future<T>> submitAll(ExecutorService executor,
+        Collection<? extends Callable<T>> tasks) {
-    if (services.getHealthMonitor().checkIfAvailable(fmbr, "Member failed to acknowledge a membership view", false)) {
+    if (services.getHealthMonitor().checkIfAvailable(fmbr,
+        "Member failed to acknowledge a membership view", false)) {
-  
-  private InternalDistributedMember getMemId(NetMember jgId, List<InternalDistributedMember> members) {
+
+  private InternalDistributedMember getMemId(NetMember jgId,
+      List<InternalDistributedMember> members) {
-    
+

Merge branch 'release/1.5.0'

-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Supplier;
-import org.apache.commons.lang.StringUtils;
+import org.apache.geode.cache.Cache;
-import org.apache.geode.cache.CacheFactory;
-import org.apache.geode.internal.cache.tier.sockets.CacheClientProxy;
+import org.apache.geode.internal.lang.StringUtils;
-  public static String cliDependenciesExist(boolean includeGfshDependencies) {
-    String jarProductName;
-
-    // Parser & CliCommand from Spring Shell
-    jarProductName =
-        checkLibraryByLoadingClass("org.springframework.shell.core.Parser", "Spring Shell");
-    jarProductName = checkLibraryByLoadingClass(
-        "org.springframework.shell.core.annotation.CliCommand", "Spring Shell");
-    if (jarProductName != null) {
-      return jarProductName;
+  /**
+   * Returns the InternalCache returned by the provided method.
+   * If the provided method would raise a CacheClosedException, returns null instead.
+   */
+  public static InternalCache getCacheIfExists(Supplier<InternalCache> getCacheMethod) {
+    InternalCache cache = null;
+    try {
+      cache = getCacheMethod.get();
+    } catch (CacheClosedException ignored) {
+    return cache;
-    // SpringVersion from Spring Core
-    jarProductName =
-        checkLibraryByLoadingClass("org.springframework.core.SpringVersion", "Spring Core");
-    if (jarProductName != null) {
-      return jarProductName;
-    }
-
-    if (includeGfshDependencies) {
-      // ConsoleReader from jline
-      jarProductName = checkLibraryByLoadingClass("jline.console.ConsoleReader", "JLine");
-      if (jarProductName != null) {
-        return jarProductName;
-      }
-    }
-
-    return jarProductName;
-  private static String checkLibraryByLoadingClass(String className, String jarProductName) {
+  public static String cliDependenciesExist(boolean includeGfshDependencies) {
+    // "Validate" each dependency by attempting to load an associated class
+    Map<String, String> classLibraryMap = new HashMap<>();
+    classLibraryMap.put("org.springframework.shell.core.Parser", "Spring Shell");
+    classLibraryMap.put("org.springframework.shell.core.annotation.CliCommand", "Spring Shell");
+    classLibraryMap.put("org.springframework.core.SpringVersion", "Spring Core");
+    if (includeGfshDependencies) {
+      classLibraryMap.put("jline.console.ConsoleReader", "JLine");
+    }
+
+    List<String> unloadableJars =
+        classLibraryMap.entrySet().stream().filter(entry -> !canLoadClass(entry.getKey()))
+            .map(Map.Entry::getValue).collect(Collectors.toList());
+    return unloadableJars.isEmpty() ? null : String.join(",", unloadableJars);
+  }
+
+  private static boolean canLoadClass(String className) {
-      return jarProductName;
+      return false;
-
-    return null;
-  }
-
-  public static InternalCache getCacheIfExists() {
-    InternalCache cache;
-    try {
-      cache = getInternalCache();
-    } catch (CacheClosedException e) {
-      // ignore & return null
-      cache = null;
-    }
-
-    return cache;
+    return true;
-   * Even thought this is only used in a test, caller of MemberMXBean.processCommand(String, Map,
-   * Byte[][]) will need to use this method to convert a fileList to Byte[][] to call that
-   * deprecated API.
+   * Returns a Set of DistributedMember for members that have the specified <code>region</code>.
+   * <code>returnAll</code> indicates whether to return all members or only the first member we
+   * find.
-   * Once that deprecated API is removed, we can delete this method and the tests.
+   * @param region region path for which members that have this region are required
+   * @param cache cache instance to use to find members
+   * @param returnAll if true, returns all matching members, else returns only first one found.
+   * @return a Set of DistributedMember for members that have the specified <code>region</code>.
-  public static Byte[][] filesToBytes(List<String> fileNames) throws IOException {
-    List<byte[]> filesDataList = new ArrayList<>();
+  public static Set<DistributedMember> getRegionAssociatedMembers(String region,
+      final InternalCache cache, boolean returnAll) {
+    if (region == null || region.isEmpty()) {
+      return Collections.emptySet();
+    }
-    for (String fileName : fileNames) {
-      File file = new File(fileName);
+    if (!region.startsWith(Region.SEPARATOR)) {
+      region = Region.SEPARATOR + region;
+    }
-      if (!file.exists()) {
-        throw new FileNotFoundException("Could not find " + file.getCanonicalPath());
-      }
+    DistributedRegionMXBean regionMXBean =
+        ManagementService.getManagementService(cache).getDistributedRegionMXBean(region);
-      if (file.isDirectory()) {
-        File[] childrenFiles = file.listFiles(JAR_FILE_FILTER);
-        for (File childrenFile : childrenFiles) {
-          // 1. add name of the file as bytes at even index
-          filesDataList.add(childrenFile.getName().getBytes());
-          // 2. add file contents as bytes at odd index
-          filesDataList.add(toByteArray(new FileInputStream(childrenFile)));
+    if (regionMXBean == null) {
+      return Collections.emptySet();
+    }
+
+    String[] regionAssociatedMemberNames = regionMXBean.getMembers();
+    Set<DistributedMember> matchedMembers = new HashSet<>();
+    Set<DistributedMember> allClusterMembers = new HashSet<>(cache.getMembers());
+    allClusterMembers.add(cache.getDistributedSystem().getDistributedMember());
+
+    for (DistributedMember member : allClusterMembers) {
+      for (String regionAssociatedMemberName : regionAssociatedMemberNames) {
+        String name = MBeanJMXAdapter.getMemberNameOrId(member);
+        if (name.equals(regionAssociatedMemberName)) {
+          matchedMembers.add(member);
+          if (!returnAll) {
+            return matchedMembers;
+          }
-      } else {
-        filesDataList.add(file.getName().getBytes());
-        filesDataList.add(toByteArray(new FileInputStream(file)));
-
-    List<Byte[]> convertedList =
-        filesDataList.stream().map(ArrayUtils::toObject).collect(Collectors.toList());
-
-    return convertedList.toArray(new Byte[convertedList.size()][]);
+    return matchedMembers;
-  public static byte[] toByteArray(InputStream input) throws IOException {
-    ByteArrayOutputStream output = new ByteArrayOutputStream();
-    int n = 0;
-    byte[] buffer = new byte[4096];
-    while (-1 != (n = input.read(buffer))) {
-      output.write(buffer, 0, n);
+  /**
+   * this finds the member that hosts all the regions passed in.
+   *
+   * @param returnAll if true, returns all matching members, otherwise, returns only one.
+   */
+  public static Set<DistributedMember> getQueryRegionsAssociatedMembers(Set<String> regions,
+      final InternalCache cache, boolean returnAll) {
+    Set<DistributedMember> results = regions.stream()
+        .map(region -> getRegionAssociatedMembers(region, cache, true)).reduce((s1, s2) -> {
+          s1.retainAll(s2);
+          return s1;
+        }).get();
+
+    if (returnAll || results.size() <= 1) {
+      return results;
-    return output.toByteArray();
+    // returns a set of only one item
+    return Collections.singleton(results.iterator().next());
-  public static List<String> bytesToFiles(Byte[][] fileData, String parentDirPath)
-      throws IOException, UnsupportedOperationException {
-    List<String> filesPaths = new ArrayList<>();
-    FileOutputStream fos = null;
-    File file = null;
-
-    File parentDir = new File(parentDirPath);
-    if (!parentDir.exists() && !parentDir.mkdirs()) {
-      throw new UnsupportedOperationException(
-          "Couldn't create required directory structure for " + parentDirPath);
+  public static String getMemberNameOrId(DistributedMember distributedMember) {
+    String nameOrId = null;
+    if (distributedMember != null) {
+      nameOrId = distributedMember.getName();
+      nameOrId = nameOrId != null && !nameOrId.isEmpty() ? nameOrId : distributedMember.getId();
-    for (int i = 0; i < fileData.length; i++) {
-      byte[] bytes = ArrayUtils.toPrimitive(fileData[i]);
-      if (i % 2 == 0) {
-        // Expect file name as bytes at even index
-        String fileName = new String(bytes);
-        file = new File(parentDir, fileName);
-        fos = new FileOutputStream(file);
-      } else {
-        // Expect file contents as bytes at odd index
-        fos.write(bytes);
-        fos.close();
-        filesPaths.add(file.getAbsolutePath());
-      }
-    }
-    return filesPaths;
+    return nameOrId;
-  private static InternalCache getInternalCache() {
-    return (InternalCache) CacheFactory.getAnyInstance();
+  /**
+   * Returns a set of all the members of the distributed system excluding locators.
+   */
+  @SuppressWarnings("unchecked")
+  public static Set<DistributedMember> getAllNormalMembers(InternalCache cache) {
+    return new HashSet<DistributedMember>(cache.getInternalDistributedSystem()
+        .getDistributionManager().getNormalDistributionManagerIds());
-  public static Set<String> getAllRegionNames() {
-    InternalCache cache = getInternalCache();
+  /**
+   * Returns a set of all the members of the distributed system including locators.
+   */
+  @SuppressWarnings("unchecked")
+  public static Set<DistributedMember> getAllMembers(InternalCache cache) {
+    return getAllMembers(cache.getInternalDistributedSystem());
+  }
+
+  @SuppressWarnings("unchecked")
+  public static Set<DistributedMember> getAllMembers(InternalDistributedSystem internalDS) {
+    return new HashSet<DistributedMember>(
+        internalDS.getDistributionManager().getDistributionManagerIds());
+  }
+
+  public static Set<DistributedMember> getMembersWithAsyncEventQueue(InternalCache cache,
+      String queueId) {
+    Set<DistributedMember> members = findMembers(null, null, cache);
+    return members.stream().filter(m -> getAsyncEventQueueIds(cache, m).contains(queueId))
+        .collect(Collectors.toSet());
+  }
+
+  public static Set<String> getAsyncEventQueueIds(InternalCache cache, DistributedMember member) {
+    SystemManagementService managementService =
+        (SystemManagementService) ManagementService.getExistingManagementService(cache);
+    return managementService.getAsyncEventQueueMBeanNames(member).stream()
+        .map(x -> x.getKeyProperty("queue")).collect(Collectors.toSet());
+  }
+
+  public static Set<String> getAllRegionNames(Cache cache) {
-  public static String convertStringSetToString(Set<String> stringSet, char delimiter) {
-    StringBuilder sb = new StringBuilder();
-    if (stringSet != null) {
-
-      for (String stringValue : stringSet) {
-        sb.append(stringValue);
-        sb.append(delimiter);
-      }
-    }
-    return sb.toString();
-  }
-
-  public static String convertStringListToString(List<String> stringList, char delimiter) {
-    StringBuilder sb = new StringBuilder();
-    if (stringList != null) {
-
-      for (String stringValue : stringList) {
-        sb.append(stringValue);
-        sb.append(delimiter);
-      }
-    }
-    return sb.toString();
-  }
-
-      String[] members) {
-    InternalCache cache = getInternalCache();
+      String[] members, InternalCache cache) {
-
-  public static Set<DistributedMember> findMembers(String[] groups, String[] members) {
-    InternalCache cache = getInternalCache();
+  public static Set<DistributedMember> findMembers(String[] groups, String[] members,
+      InternalCache cache) {
-  public static DistributedMember getDistributedMemberByNameOrId(String memberNameOrId) {
-    DistributedMember memberFound = null;
+  public static DistributedMember getDistributedMemberByNameOrId(String memberNameOrId,
+      InternalCache cache) {
+    if (memberNameOrId == null) {
+      return null;
+    }
-    if (memberNameOrId != null) {
-      InternalCache cache = getInternalCache();
-      Set<DistributedMember> memberSet = CliUtil.getAllMembers(cache);
-      for (DistributedMember member : memberSet) {
-        if (memberNameOrId.equalsIgnoreCase(member.getId())
-            || memberNameOrId.equalsIgnoreCase(member.getName())) {
-          memberFound = member;
-          break;
+    Set<DistributedMember> memberSet = CliUtil.getAllMembers(cache);
+    return memberSet.stream().filter(member -> memberNameOrId.equalsIgnoreCase(member.getId())
+        || memberNameOrId.equalsIgnoreCase(member.getName())).findFirst().orElse(null);
+  }
+
+
+  /**
+   * Even thought this is only used in a test, caller of MemberMXBean.processCommand(String, Map,
+   * Byte[][]) will need to use this method to convert a fileList to Byte[][] to call that
+   * deprecated API.
+   *
+   * Once that deprecated API is removed, we can delete this method and the tests.
+   */
+  public static Byte[][] filesToBytes(List<String> fileNames) throws IOException {
+    List<byte[]> filesDataList = new ArrayList<>();
+
+    for (String fileName : fileNames) {
+      File file = new File(fileName);
+
+      if (!file.exists()) {
+        throw new FileNotFoundException("Could not find " + file.getCanonicalPath());
+      }
+
+      if (file.isDirectory()) {
+        File[] childrenFiles = file.listFiles(JAR_FILE_FILTER);
+        for (File childrenFile : childrenFiles) {
+          // 1. add name of the file as bytes at even index
+          filesDataList.add(childrenFile.getName().getBytes());
+          // 2. add file contents as bytes at odd index
+          filesDataList.add(toByteArray(new FileInputStream(childrenFile)));
+      } else {
+        filesDataList.add(file.getName().getBytes());
+        filesDataList.add(toByteArray(new FileInputStream(file)));
-    return memberFound;
+
+    return filesDataList.stream().map(ArrayUtils::toObject).toArray(Byte[][]::new);
-  public static String stackTraceAsString(Throwable e) {
-    String stackAsString = "";
-    if (e != null) {
-      StringWriter writer = new StringWriter();
-      PrintWriter pw = new PrintWriter(writer);
-      e.printStackTrace(pw);
-      stackAsString = writer.toString();
+  public static byte[] toByteArray(InputStream input) throws IOException {
+    ByteArrayOutputStream output = new ByteArrayOutputStream();
+    int n;
+    byte[] buffer = new byte[4096];
+    while (-1 != (n = input.read(buffer))) {
+      output.write(buffer, 0, n);
-    return stackAsString;
+
+    return output.toByteArray();
-  @SuppressWarnings("unchecked")
+  public static List<String> bytesToFiles(Byte[][] fileData, String parentDirPath)
+      throws IOException, UnsupportedOperationException {
+    List<String> filesPaths = new ArrayList<>();
+    FileOutputStream fos = null;
+    File file = null;
+
+    File parentDir = new File(parentDirPath);
+    if (!parentDir.exists() && !parentDir.mkdirs()) {
+      throw new UnsupportedOperationException(
+          "Couldn't create required directory structure for " + parentDirPath);
+    }
+    for (int i = 0; i < fileData.length; i++) {
+      byte[] bytes = ArrayUtils.toPrimitive(fileData[i]);
+      if (i % 2 == 0) {
+        // Expect file name as bytes at even index
+        String fileName = new String(bytes);
+        file = new File(parentDir, fileName);
+        fos = new FileOutputStream(file);
+      } else {
+        // Expect file contents as bytes at odd index
+        fos.write(bytes);
+        fos.close();
+        filesPaths.add(file.getAbsolutePath());
+      }
+    }
+    return filesPaths;
+  }
+
+  public static DeflaterInflaterData compressBytes(byte[] input) {
+    Deflater compresser = new Deflater();
+    compresser.setInput(input);
+    compresser.finish();
+    byte[] buffer = new byte[100];
+    byte[] result = new byte[0];
+    int compressedDataLength;
+    int totalCompressedDataLength = 0;
+    do {
+      byte[] newResult = new byte[result.length + buffer.length];
+      System.arraycopy(result, 0, newResult, 0, result.length);
+
+      compressedDataLength = compresser.deflate(buffer);
+      totalCompressedDataLength += compressedDataLength;
+      System.arraycopy(buffer, 0, newResult, result.length, buffer.length);
+      result = newResult;
+    } while (compressedDataLength != 0);
+    return new DeflaterInflaterData(totalCompressedDataLength, result);
+  }
+
+  public static DeflaterInflaterData uncompressBytes(byte[] output, int compressedDataLength)
+      throws DataFormatException {
+    Inflater decompresser = new Inflater();
+    decompresser.setInput(output, 0, compressedDataLength);
+    byte[] buffer = new byte[512];
+    byte[] result = new byte[0];
+    int bytesRead;
+    while (!decompresser.needsInput()) {
+      bytesRead = decompresser.inflate(buffer);
+      byte[] newResult = new byte[result.length + bytesRead];
+      System.arraycopy(result, 0, newResult, 0, result.length);
+      System.arraycopy(buffer, 0, newResult, result.length, bytesRead);
+      result = newResult;
+    }
+    decompresser.end();
+
+    return new DeflaterInflaterData(result.length, result);
+  }
+
+  public static String decodeWithDefaultCharSet(String urlToDecode) {
+    try {
+      return URLDecoder.decode(urlToDecode, Charset.defaultCharset().name());
+    } catch (UnsupportedEncodingException e) {
+      return urlToDecode;
+    }
+  }
+
+  /**
+   * Resolves file system path relative to Gfsh. If the pathname is not specified, then pathname is
+   * returned.
+   *
+   * @param pathname a String value specifying the file system pathname to resolve.
+   * @return a String specifying a path relative to Gfsh.
+   */
+  public static String resolvePathname(final String pathname) {
+    return (StringUtils.isBlank(pathname) ? pathname
+        : IOUtils.tryGetCanonicalPathElseGetAbsolutePath(new File(pathname)));
+  }
+
-  public static Set<DistributedMember> getMembersWithAsyncEventQueue(InternalCache cache,
-      String queueId) {
-    Set<DistributedMember> members = findMembers(null, null);
-    return members.stream().filter(m -> getAsyncEventQueueIds(cache, m).contains(queueId))
-        .collect(Collectors.toSet());
-  }
-
-  public static Set<String> getAsyncEventQueueIds(InternalCache cache, DistributedMember member) {
-    SystemManagementService managementService =
-        (SystemManagementService) ManagementService.getExistingManagementService(cache);
-    return managementService.getAsyncEventQueueMBeanNames(member).stream()
-        .map(x -> x.getKeyProperty("queue")).collect(Collectors.toSet());
-  }
-
-  static class CustomFileFilter implements FileFilter {
-    private String extensionWithDot;
-
-    public CustomFileFilter(String extensionWithDot) {
-      this.extensionWithDot = extensionWithDot;
-    }
-
-    @Override
-    public boolean accept(File pathname) {
-      String name = pathname.getName();
-      return name.endsWith(extensionWithDot);
-    }
-  }
-
-  public static DeflaterInflaterData compressBytes(byte[] input) {
-    Deflater compresser = new Deflater();
-    compresser.setInput(input);
-    compresser.finish();
-    byte[] buffer = new byte[100];
-    byte[] result = new byte[0];
-    int compressedDataLength = 0;
-    int totalCompressedDataLength = 0;
-    do {
-      byte[] newResult = new byte[result.length + buffer.length];
-      System.arraycopy(result, 0, newResult, 0, result.length);
-
-      compressedDataLength = compresser.deflate(buffer);
-      totalCompressedDataLength += compressedDataLength;
-      System.arraycopy(buffer, 0, newResult, result.length, buffer.length);
-      result = newResult;
-    } while (compressedDataLength != 0);
-    return new DeflaterInflaterData(totalCompressedDataLength, result);
-  }
-
-  public static DeflaterInflaterData uncompressBytes(byte[] output, int compressedDataLength)
-      throws DataFormatException {
-    Inflater decompresser = new Inflater();
-    decompresser.setInput(output, 0, compressedDataLength);
-    byte[] buffer = new byte[512];
-    byte[] result = new byte[0];
-    int bytesRead;
-    while (!decompresser.needsInput()) {
-      bytesRead = decompresser.inflate(buffer);
-      byte[] newResult = new byte[result.length + bytesRead];
-      System.arraycopy(result, 0, newResult, 0, result.length);
-      System.arraycopy(buffer, 0, newResult, result.length, bytesRead);
-      result = newResult;
-    }
-    decompresser.end();
-
-    return new DeflaterInflaterData(result.length, result);
-  }
-
-  public static class DeflaterInflaterData implements Serializable {
-    private static final long serialVersionUID = 1104813333595216795L;
-
-    private final int dataLength;
-    private final byte[] data;
-
-    public DeflaterInflaterData(int dataLength, byte[] data) {
-      this.dataLength = dataLength;
-      this.data = data;
-    }
-
-    public int getDataLength() {
-      return dataLength;
-    }
-
-    public byte[] getData() {
-      return data;
-    }
-
-    @Override
-    public String toString() {
-      return String.valueOf(dataLength);
-    }
-  }
-
-  public static boolean contains(Object[] array, Object object) {
-    boolean contains = false;
-
-    if (array != null && object != null) {
-      contains = Arrays.asList(array).contains(object);
-    }
-
-    return contains;
-  }
-
-  /**
-   * Returns a set of all the members of the distributed system excluding locators.
-   *
-   * @param cache
-   */
-  @SuppressWarnings("unchecked")
-  public static Set<DistributedMember> getAllNormalMembers(InternalCache cache) {
-    return new HashSet<DistributedMember>(cache.getInternalDistributedSystem()
-        .getDistributionManager().getNormalDistributionManagerIds());
-  }
-
-  /**
-   * Returns a set of all the members of the distributed system including locators.
-   *
-   * @param cache
-   */
-  @SuppressWarnings("unchecked")
-  public static Set<DistributedMember> getAllMembers(InternalCache cache) {
-    return getAllMembers(cache.getInternalDistributedSystem());
-  }
-
-  @SuppressWarnings("unchecked")
-  public static Set<DistributedMember> getAllMembers(InternalDistributedSystem internalDS) {
-    return new HashSet<DistributedMember>(
-        internalDS.getDistributionManager().getDistributionManagerIds());
-  }
-
-  /**
-   * Returns a Set of DistributedMember for members that have the specified <code>region</code>.
-   * <code>returnAll</code> indicates whether to return all members or only the first member we
-   * find.
-   *
-   * @param region region path for which members that have this region are required
-   * @param cache cache instance to use to find members
-   * @param returnAll if true, returns all matching members, else returns only first one found.
-   * @return a Set of DistributedMember for members that have the specified <code>region</code>.
-   */
-  public static Set<DistributedMember> getRegionAssociatedMembers(String region,
-      final InternalCache cache, boolean returnAll) {
-    if (region == null || region.isEmpty()) {
-      return Collections.emptySet();
-    }
-    if (!region.startsWith(Region.SEPARATOR)) {
-      region = Region.SEPARATOR + region;
-    }
-
-    DistributedRegionMXBean regionMXBean =
-        ManagementService.getManagementService(cache).getDistributedRegionMXBean(region);
-
-    if (regionMXBean == null) {
-      return Collections.emptySet();
-    }
-
-    String[] regionAssociatedMemberNames = regionMXBean.getMembers();
-    Set<DistributedMember> matchedMembers = new HashSet<>();
-    Set<DistributedMember> allClusterMembers = new HashSet<>();
-    allClusterMembers.addAll(cache.getMembers());
-    allClusterMembers.add(cache.getDistributedSystem().getDistributedMember());
-
-    for (DistributedMember member : allClusterMembers) {
-      for (String regionAssociatedMemberName : regionAssociatedMemberNames) {
-        String name = MBeanJMXAdapter.getMemberNameOrId(member);
-        if (name.equals(regionAssociatedMemberName)) {
-          matchedMembers.add(member);
-          if (!returnAll) {
-            return matchedMembers;
-          }
-        }
-      }
-    }
-    return matchedMembers;
-  }
-
-  /**
-   * this finds the member that hosts all the regions passed in.
-   *
-   * @param regions
-   * @param cache
-   * @param returnAll if true, returns all matching members, otherwise, returns only one.
-   */
-  public static Set<DistributedMember> getQueryRegionsAssociatedMembers(Set<String> regions,
-      final InternalCache cache, boolean returnAll) {
-    Set<DistributedMember> results = regions.stream()
-        .map(region -> getRegionAssociatedMembers(region, cache, true)).reduce((s1, s2) -> {
-          s1.retainAll(s2);
-          return s1;
-        }).get();
-
-    if (returnAll || results.size() <= 1) {
-      return results;
-    }
-
-    // returns a set of only one item
-    return Collections.singleton(results.iterator().next());
-  }
-
-  public static String getMemberNameOrId(DistributedMember distributedMember) {
-    String nameOrId = null;
-    if (distributedMember != null) {
-      nameOrId = distributedMember.getName();
-      nameOrId = nameOrId != null && !nameOrId.isEmpty() ? nameOrId : distributedMember.getId();
-    }
-    return nameOrId;
-  }
-
-  public static <T> String arrayToString(T[] array) {
-    if (array == null) {
-      return "null";
-    }
-    return Arrays.stream(array).map(String::valueOf).collect(Collectors.joining(", "));
-  }
-
-  public static String decodeWithDefaultCharSet(String urlToDecode) {
-    try {
-      return URLDecoder.decode(urlToDecode, Charset.defaultCharset().name());
-    } catch (UnsupportedEncodingException e) {
-      return urlToDecode;
-    }
-  }
-
-  /**
-   * Resolves file system path relative to Gfsh. If the pathname is not specified, then pathname is
-   * returned.
-   *
-   * @param pathname a String value specifying the file system pathname to resolve.
-   * @return a String specifying a path relative to Gfsh.
-   */
-  public static String resolvePathname(final String pathname) {
-    return (StringUtils.isBlank(pathname) ? pathname
-        : IOUtils.tryGetCanonicalPathElseGetAbsolutePath(new File(pathname)));
-  }
-
-  public static void runLessCommandAsExternalViewer(Result commandResult, boolean isError) {
+  public static void runLessCommandAsExternalViewer(Result commandResult) {
-  public static String getClientIdFromCacheClientProxy(CacheClientProxy p) {
-    if (p == null) {
-      return null;
+  static class CustomFileFilter implements FileFilter {
+    private String extensionWithDot;
+
+    public CustomFileFilter(String extensionWithDot) {
+      this.extensionWithDot = extensionWithDot;
-    StringBuffer buffer = new StringBuffer();
-    buffer.append("[").append(p.getProxyID()).append(":port=").append(p.getRemotePort())
-        .append(":primary=").append(p.isPrimary()).append("]");
-    return buffer.toString();
+
+    @Override
+    public boolean accept(File pathname) {
+      String name = pathname.getName();
+      return name.endsWith(extensionWithDot);
+    }
+  public static class DeflaterInflaterData implements Serializable {
+    private static final long serialVersionUID = 1104813333595216795L;
+
+    private final int dataLength;
+    private final byte[] data;
+
+    public DeflaterInflaterData(int dataLength, byte[] data) {
+      this.dataLength = dataLength;
+      this.data = data;
+    }
+
+    public int getDataLength() {
+      return dataLength;
+    }
+
+    public byte[] getData() {
+      return data;
+    }
+
+    @Override
+    public String toString() {
+      return String.valueOf(dataLength);
+    }
+  }

Merge branch 'release/1.3.0'

-      InternalCache cache = GemFireCacheImpl.getInstance();
+      InternalCache cache = dm.getCache();
+  Queue<Thread> getWaitQueue(TransactionId transactionId) {
+    return waitMap.get(transactionId);
+  }
+
+  private Queue<Thread> getOrCreateWaitQueue(TransactionId transactionId) {
+    Queue<Thread> threadq = getWaitQueue(transactionId);
+    if (threadq == null) {
+      threadq = new ConcurrentLinkedQueue<Thread>();
+      Queue<Thread> oldq = waitMap.putIfAbsent(transactionId, threadq);
+      if (oldq != null) {
+        threadq = oldq;
+      }
+    }
+    return threadq;
+  }
+
-    Thread currentThread = Thread.currentThread();
-    long timeout = unit.toNanos(time);
-    long startTime = System.nanoTime();
-    Queue<Thread> threadq = null;
+    final Thread currentThread = Thread.currentThread();
+    final long endTime = System.nanoTime() + unit.toNanos(time);
+    final Queue<Thread> threadq = getOrCreateWaitQueue(transactionId);
-        threadq = waitMap.get(transactionId);
-        if (threadq == null) {
-          threadq = new ConcurrentLinkedQueue<Thread>();
-          Queue<Thread> oldq = waitMap.putIfAbsent(transactionId, threadq);
-          if (oldq != null) {
-            threadq = oldq;
-          }
+        if (!threadq.contains(currentThread)) {
+          threadq.add(currentThread);
-        threadq.add(currentThread);
-        // after putting this thread in waitMap, we should check for
-        // an entry in suspendedTXs. if no entry is found in suspendedTXs
-        // next invocation of suspend() will unblock this thread
-        } else if (!exists(transactionId)) {
+        }
+        if (!exists(transactionId)) {
-        LockSupport.parkNanos(timeout);
-        long nowTime = System.nanoTime();
-        timeout -= nowTime - startTime;
-        startTime = nowTime;
-        if (timeout <= 0) {
-          break;
+        long parkTimeout = endTime - System.nanoTime();
+        if (parkTimeout <= 0) {
+          return false;
+        parkToRetryResume(parkTimeout);
-      threadq = waitMap.get(transactionId);
-      if (threadq != null) {
-        threadq.remove(currentThread);
-        // the queue itself will be removed at commit/rollback
-      }
+      threadq.remove(currentThread);
+      // the queue itself will be removed at commit/rollback
-    return false;
+  }
+
+  void parkToRetryResume(long timeout) {
+    LockSupport.parkNanos(timeout);

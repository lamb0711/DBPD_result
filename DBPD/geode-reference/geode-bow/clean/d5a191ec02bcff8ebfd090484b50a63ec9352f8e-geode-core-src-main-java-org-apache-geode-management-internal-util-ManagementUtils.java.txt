GEODE-7536 - Break Gfsh out into separate module (#4422)


- ManagementUtils is split from CliUtil with non-CLI methods.
- Introduce new CommandProcessor interface which is a CacheService. This
  is implemented by OnlineCommandProcessor and is used in
  MemberMBeanBridge.
- Remove try/catch from ClusterConfigurationStatusRetriever since any
  exception will be handled at a higher level.

+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileFilter;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.text.MessageFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import org.apache.commons.lang3.ArrayUtils;
+
+import org.apache.geode.annotations.Immutable;
+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.Region;
+import org.apache.geode.distributed.internal.DistributionManager;
+import org.apache.geode.internal.ClassPathLoader;
+import org.apache.geode.management.DistributedRegionMXBean;
+import org.apache.geode.management.ManagementService;
+import org.apache.geode.management.internal.MBeanJMXAdapter;
+import org.apache.geode.management.internal.exceptions.UserErrorException;
+import org.apache.geode.management.internal.i18n.CliStrings;
+  @Immutable
+  public static final FileFilter JAR_FILE_FILTER = new CustomFileFilter(".jar");
+
+
+  public static <K> Class<K> forName(String classToLoadName, String neededFor) {
+    Class<K> loadedClass = null;
+    try {
+      // Set Constraints
+      ClassPathLoader classPathLoader = ClassPathLoader.getLatest();
+      if (classToLoadName != null && !classToLoadName.isEmpty()) {
+        loadedClass = (Class<K>) classPathLoader.forName(classToLoadName);
+      }
+    } catch (ClassNotFoundException | NoClassDefFoundError e) {
+      throw new RuntimeException(
+          MessageFormat.format(CliStrings.ERROR__MSG__COULD_NOT_FIND_CLASS_0_SPECIFIED_FOR_1,
+              classToLoadName, neededFor),
+          e);
+    } catch (ClassCastException e) {
+      throw new RuntimeException(MessageFormat.format(
+          CliStrings.ERROR__MSG__CLASS_0_SPECIFIED_FOR_1_IS_NOT_OF_EXPECTED_TYPE,
+          classToLoadName, neededFor), e);
+    }
+
+    return loadedClass;
+  }
+
+  public static DistributedMember getDistributedMemberByNameOrId(String memberNameOrId,
+      InternalCache cache) {
+    if (memberNameOrId == null) {
+      return null;
+    }
+
+    Set<DistributedMember> memberSet = getAllMembers(cache);
+    return memberSet.stream().filter(member -> memberNameOrId.equalsIgnoreCase(member.getId())
+        || memberNameOrId.equalsIgnoreCase(member.getName())).findFirst().orElse(null);
+  }
+
+  public static Set<String> getAllRegionNames(Cache cache) {
+    Set<String> regionNames = new HashSet<>();
+    Set<Region<?, ?>> rootRegions = cache.rootRegions();
+
+    for (Region<?, ?> rootRegion : rootRegions) {
+      regionNames.add(rootRegion.getFullPath().substring(1));
+
+      Set<Region<?, ?>> subRegions = rootRegion.subregions(true);
+
+      for (Region<?, ?> subRegion : subRegions) {
+        regionNames.add(subRegion.getFullPath().substring(1));
+      }
+    }
+    return regionNames;
+  }
+
+  public static List<String> bytesToFiles(Byte[][] fileData, String parentDirPath)
+      throws IOException, UnsupportedOperationException {
+    List<String> filesPaths = new ArrayList<>();
+    FileOutputStream fos = null;
+    File file = null;
+
+    File parentDir = new File(parentDirPath);
+    if (!parentDir.exists() && !parentDir.mkdirs()) {
+      throw new UnsupportedOperationException(
+          "Couldn't create required directory structure for " + parentDirPath);
+    }
+    for (int i = 0; i < fileData.length; i++) {
+      byte[] bytes = ArrayUtils.toPrimitive(fileData[i]);
+      if (i % 2 == 0) {
+        // Expect file name as bytes at even index
+        String fileName = new String(bytes);
+        file = new File(parentDir, fileName);
+        fos = new FileOutputStream(file);
+      } else {
+        // Expect file contents as bytes at odd index
+        fos.write(bytes);
+        fos.close();
+        filesPaths.add(file.getAbsolutePath());
+      }
+    }
+    return filesPaths;
+  }
+
+  /**
+   * Returns a Set of DistributedMember for members that have the specified <code>region</code>.
+   * <code>returnAll</code> indicates whether to return all members or only the first member we
+   * find.
+   *
+   * @param region region path for which members that have this region are required
+   * @param cache cache instance to use to find members
+   * @param returnAll if true, returns all matching members, else returns only first one found.
+   * @return a Set of DistributedMember for members that have the specified <code>region</code>.
+   */
+  public static Set<DistributedMember> getRegionAssociatedMembers(String region,
+      final InternalCache cache, boolean returnAll) {
+    if (region == null || region.isEmpty()) {
+      return Collections.emptySet();
+    }
+
+    if (!region.startsWith(Region.SEPARATOR)) {
+      region = Region.SEPARATOR + region;
+    }
+
+    DistributedRegionMXBean regionMXBean =
+        ManagementService.getManagementService(cache).getDistributedRegionMXBean(region);
+
+    if (regionMXBean == null) {
+      return Collections.emptySet();
+    }
+
+    String[] regionAssociatedMemberNames = regionMXBean.getMembers();
+    Set<DistributedMember> matchedMembers = new HashSet<>();
+    Set<DistributedMember> allClusterMembers = new HashSet<>(cache.getMembers());
+    allClusterMembers.add(cache.getDistributedSystem().getDistributedMember());
+
+    for (DistributedMember member : allClusterMembers) {
+      List<String> regionAssociatedMemberNamesList = Arrays.asList(regionAssociatedMemberNames);
+      String name = MBeanJMXAdapter.getMemberNameOrUniqueId(member);
+      if (regionAssociatedMemberNamesList.contains(name)) {
+        matchedMembers.add(member);
+        if (!returnAll) {
+          return matchedMembers;
+        }
+      }
+    }
+    return matchedMembers;
+  }
+
+  /**
+   * this finds the member that hosts all the regions passed in.
+   *
+   * @param returnAll if true, returns all matching members, otherwise, returns only one.
+   */
+  public static Set<DistributedMember> getQueryRegionsAssociatedMembers(Set<String> regions,
+      final InternalCache cache, boolean returnAll) {
+    Set<DistributedMember> results = regions.stream()
+        .map(region -> getRegionAssociatedMembers(region, cache, true)).reduce((s1, s2) -> {
+          s1.retainAll(s2);
+          return s1;
+        }).get();
+
+    if (returnAll || results.size() <= 1) {
+      return results;
+    }
+
+    // returns a set of only one item
+    return Collections.singleton(results.iterator().next());
+  }
+
+  public static Set<DistributedMember> findMembers(Set<DistributedMember> membersToConsider,
+      String[] groups, String[] members) {
+    if (groups == null) {
+      groups = new String[] {};
+    }
+
+    if (members == null) {
+      members = new String[] {};
+    }
+
+    if ((members.length > 0) && (groups.length > 0)) {
+      throw new UserErrorException(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE);
+    }
+
+    if (members.length == 0 && groups.length == 0) {
+      return membersToConsider;
+    }
+
+    Set<DistributedMember> matchingMembers = new HashSet<>();
+    // it will either go into this loop or the following loop, not both.
+    for (String memberNameOrId : members) {
+      for (DistributedMember member : membersToConsider) {
+        if (memberNameOrId.equalsIgnoreCase(member.getId())
+            || memberNameOrId.equalsIgnoreCase(member.getName())) {
+          matchingMembers.add(member);
+        }
+      }
+    }
+
+    for (String group : groups) {
+      for (DistributedMember member : membersToConsider) {
+        if (member.getGroups().contains(group)) {
+          matchingMembers.add(member);
+        }
+      }
+    }
+    return matchingMembers;
+  }
+
+  /**
+   * Finds all Members (including both servers and locators) which belong to the given arrays of
+   * groups or members.
+   */
+  public static Set<DistributedMember> findMembersIncludingLocators(String[] groups,
+      String[] members, InternalCache cache) {
+    Set<DistributedMember> allMembers = getAllMembers(cache);
+    return findMembers(allMembers, groups, members);
+  }
+
+  /**
+   * Finds all Servers which belong to the given arrays of groups or members. Does not include
+   * locators.
+   */
+  public static Set<DistributedMember> findMembers(String[] groups, String[] members,
+      InternalCache cache) {
+    Set<DistributedMember> allNormalMembers = getAllNormalMembers(cache);
+
+    return findMembers(allNormalMembers, groups, members);
+  }
+
+  /**
+   * Finds all Servers which belong to the given arrays of groups or members. Does not include
+   * locators.
+   */
+  public static Set<DistributedMember> findMembers(String[] groups, String[] members,
+      DistributionManager distributionManager) {
+    Set<DistributedMember> allNormalMembers = new HashSet<DistributedMember>(
+        distributionManager.getNormalDistributionManagerIds());
+
+    return findMembers(allNormalMembers, groups, members);
+  }
+
+  /**
+   * Even thought this is only used in a test, caller of MemberMXBean.processCommand(String, Map,
+   * Byte[][]) will need to use this method to convert a fileList to Byte[][] to call that
+   * deprecated API.
+   *
+   * Once that deprecated API is removed, we can delete this method and the tests.
+   */
+  public static Byte[][] filesToBytes(List<String> fileNames) throws IOException {
+    List<byte[]> filesDataList = new ArrayList<>();
+
+    for (String fileName : fileNames) {
+      File file = new File(fileName);
+
+      if (!file.exists()) {
+        throw new FileNotFoundException("Could not find " + file.getCanonicalPath());
+      }
+
+      if (file.isDirectory()) {
+        File[] childrenFiles = file.listFiles(JAR_FILE_FILTER);
+        for (File childrenFile : childrenFiles) {
+          // 1. add name of the file as bytes at even index
+          filesDataList.add(childrenFile.getName().getBytes());
+          // 2. add file contents as bytes at odd index
+          filesDataList.add(toByteArray(new FileInputStream(childrenFile)));
+        }
+      } else {
+        filesDataList.add(file.getName().getBytes());
+        filesDataList.add(toByteArray(new FileInputStream(file)));
+      }
+    }
+
+    return filesDataList.stream().map(ArrayUtils::toObject).toArray(Byte[][]::new);
+  }
+
+  public static byte[] toByteArray(InputStream input) throws IOException {
+    ByteArrayOutputStream output = new ByteArrayOutputStream();
+    int n;
+    byte[] buffer = new byte[4096];
+    while (-1 != (n = input.read(buffer))) {
+      output.write(buffer, 0, n);
+    }
+
+    return output.toByteArray();
+  }
+
+  static class CustomFileFilter implements FileFilter {
+    private String extensionWithDot;
+
+    public CustomFileFilter(String extensionWithDot) {
+      this.extensionWithDot = extensionWithDot;
+    }
+
+    @Override
+    public boolean accept(File pathname) {
+      String name = pathname.getName();
+      return name.endsWith(extensionWithDot);
+    }
+  }

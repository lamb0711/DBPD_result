Merge branch 'release/1.0.0-incubating.M1'

- * =========================================================================
- *  Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- *  This product is protected by U.S. and international copyright
- *  and intellectual property laws. Pivotal products are covered by
- *  more patents listed at http://www.pivotal.io/patents.
- * ========================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import java.util.concurrent.TimeUnit;
+
+import com.gemstone.gemfire.distributed.AbstractLauncher.Status;
-import com.gemstone.gemfire.internal.cache.AbstractBridgeServer;
+import com.gemstone.gemfire.internal.cache.AbstractCacheServer;
+
+    helpMap.put("hostname-for-clients", LocalizedStrings.ServerLauncher_SERVER_HOSTNAME_FOR_CLIENT_HELP.toLocalizedString());
+  private final Float criticalOffHeapPercentage;
+  private final Float evictionOffHeapPercentage;
+  
-    return Integer.getInteger(AbstractBridgeServer.TEST_OVERRIDE_DEFAULT_PORT_PROPERTY, CacheServer.DEFAULT_PORT);
+    return Integer.getInteger(AbstractCacheServer.TEST_OVERRIDE_DEFAULT_PORT_PROPERTY, CacheServer.DEFAULT_PORT);
+    this.criticalOffHeapPercentage = builder.getCriticalOffHeapPercentage();
+    this.evictionOffHeapPercentage = builder.getEvictionOffHeapPercentage();
+  public Float getCriticalOffHeapPercentage() {
+    return this.criticalOffHeapPercentage;
+  }
+  
+  public Float getEvictionOffHeapPercentage() {
+    return this.evictionOffHeapPercentage;
+  }
+  
+          if (this.criticalOffHeapPercentage != null) {
+            this.cache.getResourceManager().setCriticalOffHeapPercentage(getCriticalOffHeapPercentage());
+          } 
+          if (this.evictionOffHeapPercentage != null) {
+            this.cache.getResourceManager().setEvictionOffHeapPercentage(getEvictionOffHeapPercentage());
+          }
-      
+
+      if (getHostNameForClients() != null) {
+        cacheServer.setHostnameForClients(getHostNameForClients());
+      }
+
-      final ProcessController controller = new ProcessControllerFactory().createProcessController(this.controllerParameters, new File(getWorkingDirectory()), ProcessType.SERVER.getPidFileName());
+      final ProcessController controller = new ProcessControllerFactory().createProcessController(this.controllerParameters, new File(getWorkingDirectory()), ProcessType.SERVER.getPidFileName(), READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
-//    catch (NoClassDefFoundError error) {
-//      if (isAttachAPINotFound(error)) {
-//        throw new AttachAPINotFoundException(LocalizedStrings.Launcher_ATTACH_API_NOT_FOUND_ERROR_MESSAGE
-//          .toLocalizedString(), error);
-//      }
-//
-//      throw error;
-//    }
-//    catch (MalformedObjectNameException e) {
-//      // JMX object name is bad
-//      return createNoResponseState(e, "Failed to communicate with server with process id " + parsedPid);
-//    } 
+    catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+      return createNoResponseState(e, "Interrupted while trying to communicate with server with process id " + parsedPid);
+    } 
-      // TODO comment me
-      return createNoResponseState(e, "Failed to communicate with server with process id " + parsedPid);
-    } 
-    catch (InterruptedException e) {
-      // TODO comment me
-      // TODO comment me
-      final ProcessController controller = new ProcessControllerFactory().createProcessController(this.controllerParameters, new File(getWorkingDirectory()), ProcessType.SERVER.getPidFileName());
+      final ProcessController controller = new ProcessControllerFactory().createProcessController(this.controllerParameters, new File(getWorkingDirectory()), ProcessType.SERVER.getPidFileName(), READ_PID_FILE_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
-//    catch (NoClassDefFoundError error) {
-//      if (isAttachAPINotFound(error)) {
-//        throw new AttachAPINotFoundException(LocalizedStrings.Launcher_ATTACH_API_NOT_FOUND_ERROR_MESSAGE
-//          .toLocalizedString(), error);
-//      }
-//
-//      throw error;
-//    }
-//    catch (MalformedObjectNameException e) {
-//      // JMX object name is bad
-//      return createNoResponseState(e, "Failed to communicate with server with process id " + parsedPid);
-//    } 
+    catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+      return createNoResponseState(e, "Interrupted while trying to communicate with server with process id " + parsedPid);
+    } 
+    catch (TimeoutException e) {
+      return createNoResponseState(e, "Timed out trying to find usable process id within file " + ProcessType.SERVER.getPidFileName() + " in " + getWorkingDirectory());
+    } 
-      // TODO comment me
-    //info(errorMessage);
-    return new ServerState(this, Status.NOT_RESPONDING); // TODO: use errorMessage
+    return new ServerState(this, Status.NOT_RESPONDING, errorMessage);
+    private Float criticalOffHeapPercentage;
+    private Float evictionOffHeapPercentage;
+    
+      parser.accepts(CliStrings.START_SERVER__CRITICAL_OFF_HEAP_PERCENTAGE).withRequiredArg().ofType(Float.class);
+      parser.accepts(CliStrings.START_SERVER__EVICTION_OFF_HEAP_PERCENTAGE).withRequiredArg().ofType(Float.class);
+      parser.accepts(CliStrings.START_SERVER__HOSTNAME__FOR__CLIENTS).withRequiredArg().ofType(String.class);
-
+        
+        if (options.hasArgument(CliStrings.START_SERVER__CRITICAL__HEAP__PERCENTAGE)) {
+          setCriticalHeapPercentage(Float.parseFloat(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__CRITICAL__HEAP__PERCENTAGE))));
+        }
+        
+        if (options.hasArgument(CliStrings.START_SERVER__EVICTION__HEAP__PERCENTAGE)) {
+          setEvictionHeapPercentage(Float.parseFloat(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__EVICTION__HEAP__PERCENTAGE))));
+        }
+        
+        if (options.hasArgument(CliStrings.START_SERVER__CRITICAL_OFF_HEAP_PERCENTAGE)) {
+          setCriticalOffHeapPercentage(Float.parseFloat(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__CRITICAL_OFF_HEAP_PERCENTAGE))));
+        }
+        
+        if (options.hasArgument(CliStrings.START_SERVER__EVICTION_OFF_HEAP_PERCENTAGE)) {
+          setEvictionOffHeapPercentage(Float.parseFloat(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__EVICTION_OFF_HEAP_PERCENTAGE))));
+        }
+        
+        if (options.hasArgument(CliStrings.START_SERVER__MAX__CONNECTIONS)) {
+          setMaxConnections(Integer.parseInt(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__MAX__CONNECTIONS))));
+        }
+        
+        if (options.hasArgument(CliStrings.START_SERVER__MAX__MESSAGE__COUNT)) {
+          setMaxConnections(Integer.parseInt(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__MAX__MESSAGE__COUNT))));
+        }
+        
+        if (options.hasArgument(CliStrings.START_SERVER__MESSAGE__TIME__TO__LIVE)) {
+          setMaxConnections(Integer.parseInt(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__MESSAGE__TIME__TO__LIVE))));
+        }
+        
+        if (options.hasArgument(CliStrings.START_SERVER__SOCKET__BUFFER__SIZE)) {
+          setMaxConnections(Integer.parseInt(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__SOCKET__BUFFER__SIZE))));
+        } 
+        
+        if (options.hasArgument(CliStrings.START_SERVER__MAX__THREADS)) {
+          setMaxThreads(Integer.parseInt(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__MAX__THREADS))));
+        }
+        
-        } 
+        }
+
+        if (options.hasArgument(CliStrings.START_SERVER__HOSTNAME__FOR__CLIENTS)) {
+          setHostNameForClients(ObjectUtils.toString(options.valueOf(CliStrings.START_SERVER__HOSTNAME__FOR__CLIENTS)));
+        }
+
+
+    public Float getCriticalOffHeapPercentage() {
+      return this.criticalOffHeapPercentage;
+    }
+    
+    public Builder setCriticalOffHeapPercentage(final Float criticalOffHeapPercentage) {
+      if (criticalOffHeapPercentage != null) {
+        if (criticalOffHeapPercentage < 0 || criticalOffHeapPercentage > 100.0f) {
+          throw new IllegalArgumentException(String.format("Critical off-heap percentage (%1$s) must be between 0 and 100!", criticalOffHeapPercentage));
+        }
+      }
+     this.criticalOffHeapPercentage = criticalOffHeapPercentage;
+     return this;
+    }
-
+    
+    public Float getEvictionOffHeapPercentage() {
+      return this.evictionOffHeapPercentage;
+    }
+    
+    public Builder setEvictionOffHeapPercentage(final Float evictionOffHeapPercentage) {
+      if (evictionOffHeapPercentage != null) {
+        if (evictionOffHeapPercentage < 0 || evictionOffHeapPercentage > 100.0f) {
+          throw new IllegalArgumentException(String.format("Eviction off-heap percentage (%1$s) must be between 0 and 100", evictionOffHeapPercentage));
+        }
+      }
+      this.evictionOffHeapPercentage = evictionOffHeapPercentage;
+      return this;
+    }
+    
-        throw new IllegalArgumentException("Unable to create ServerStatus from JSON: " + json);
+        throw new IllegalArgumentException("Unable to create ServerStatus from JSON: " + json, e);
+    public ServerState(final ServerLauncher launcher, final Status status, final String errorMessage) {
+      this(status, // status
+          errorMessage, // statusMessage
+          System.currentTimeMillis(), // timestamp
+          null, // serverLocation
+          null, // pid
+          0L, // uptime
+          launcher.getWorkingDirectory(), // workingDirectory
+          Collections.<String>emptyList(), // jvmArguments
+          null, // classpath
+          GemFireVersion.getGemFireVersion(), // gemfireVersion
+          null, // javaVersion
+          null, // logFile
+          null, // host
+          null, // port
+          null);// memberName
+    }
+    

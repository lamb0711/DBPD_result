Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
-  private final Set<MemberRevocationListener> revocationListeners = new HashSet<MemberRevocationListener>();
-  private final Map<PersistentMemberPattern, Object> revokedMembers = new ConcurrentHashMap<PersistentMemberPattern, Object>();
-  private Map<PersistentMemberPattern, PendingRevokeListener> pendingRevokes 
-      = new HashMap<PersistentMemberPattern, PendingRevokeListener>();
-  
+
+  private final Set<MemberRevocationListener> revocationListeners =
+      new HashSet<MemberRevocationListener>();
+  private final Map<PersistentMemberPattern, Object> revokedMembers =
+      new ConcurrentHashMap<PersistentMemberPattern, Object>();
+  private Map<PersistentMemberPattern, PendingRevokeListener> pendingRevokes =
+      new HashMap<PersistentMemberPattern, PendingRevokeListener>();
+
-  
-  public PersistentMemberManager() {
-  }
-  
+
+  public PersistentMemberManager() {}
+
-    synchronized(this) {
-      if(revokedMembers.put(pattern, TOKEN) == null) {
-        logger.info(LocalizedMessage.create(LocalizedStrings.PersistenceAdvisorImpl_MEMBER_REVOKED,pattern));
-        for(MemberRevocationListener listener : revocationListeners) {
+    synchronized (this) {
+      if (revokedMembers.put(pattern, TOKEN) == null) {
+        logger.info(LocalizedMessage.create(LocalizedStrings.PersistenceAdvisorImpl_MEMBER_REVOKED,
+            pattern));
+        for (MemberRevocationListener listener : revocationListeners) {
-  
+
-   * @param listener
-   *          The revokocation listener
-   * @param recoveredRevokedMembers
-   *          a set of members which the listener knows have been revoked
+   * @param listener The revokocation listener
+   * @param recoveredRevokedMembers a set of members which the listener knows have been revoked
-  public HashSet<PersistentMemberPattern> addRevocationListener(
-      MemberRevocationListener listener,
+  public HashSet<PersistentMemberPattern> addRevocationListener(MemberRevocationListener listener,
-    synchronized(this) {
-      //Fix for 42607, don't allow us to start up a member if we're in the
-      //process of revoking that member.
-      for(PersistentMemberPattern pattern: pendingRevokes.keySet()) {
-        if(listener.matches(pattern)) {
-          throw new RevokedPersistentDataException(LocalizedStrings.PersistentMemberManager_Member_0_is_already_revoked.toLocalizedString(pattern));
+    synchronized (this) {
+      // Fix for 42607, don't allow us to start up a member if we're in the
+      // process of revoking that member.
+      for (PersistentMemberPattern pattern : pendingRevokes.keySet()) {
+        if (listener.matches(pattern)) {
+          throw new RevokedPersistentDataException(
+              LocalizedStrings.PersistentMemberManager_Member_0_is_already_revoked
+                  .toLocalizedString(pattern));
-      for(PersistentMemberPattern pattern: revokedMembers.keySet()) {
-        if(listener.matches(pattern)) {
-          throw new RevokedPersistentDataException(LocalizedStrings.PersistentMemberManager_Member_0_is_already_revoked.toLocalizedString(pattern));
+      for (PersistentMemberPattern pattern : revokedMembers.keySet()) {
+        if (listener.matches(pattern)) {
+          throw new RevokedPersistentDataException(
+              LocalizedStrings.PersistentMemberManager_Member_0_is_already_revoked
+                  .toLocalizedString(pattern));
-      for(PersistentMemberPattern pattern: recoveredRevokedMembers) {
+      for (PersistentMemberPattern pattern : recoveredRevokedMembers) {
-  
+
-    synchronized(this) {
+    synchronized (this) {
-  
+
-    synchronized(this) {
+    synchronized (this) {
-  
+
-   * Returns a map of the regions that are waiting to recover to
-   * the persistent member ids that each region is waiting for.
+   * Returns a map of the regions that are waiting to recover to the persistent member ids that each
+   * region is waiting for.
-    synchronized(this) {
-      Map<String, Set<PersistentMemberID>> missingMemberIds = new HashMap<String, Set<PersistentMemberID>>();
-      for(MemberRevocationListener listener : revocationListeners) {
+    synchronized (this) {
+      Map<String, Set<PersistentMemberID>> missingMemberIds =
+          new HashMap<String, Set<PersistentMemberID>>();
+      for (MemberRevocationListener listener : revocationListeners) {
-        if(ids != null) {
-          if(allIds != null) {
+        if (ids != null) {
+          if (allIds != null) {
-  
+
-    synchronized(this) {
+    synchronized (this) {
-      for(MemberRevocationListener listener : revocationListeners) {
+      for (MemberRevocationListener listener : revocationListeners) {
-  
+
-    for(PersistentMemberPattern member : revokedMembers.keySet()) {
-      if(member.matches(id)) {
+    for (PersistentMemberPattern member : revokedMembers.keySet()) {
+      if (member.matches(id)) {
-  
+
+   * 
-   * @return true if this member is not currently running the chosen disk store.
-   * false if the revoke should be aborted because the disk store is already running.
+   * @return true if this member is not currently running the chosen disk store. false if the revoke
+   *         should be aborted because the disk store is already running.
-  public boolean prepareRevoke(PersistentMemberPattern pattern, 
-      DistributionManager dm, 
+  public boolean prepareRevoke(PersistentMemberPattern pattern, DistributionManager dm,
-    
-    
-    PendingRevokeListener membershipListener= new PendingRevokeListener(pattern, sender, dm);
-    synchronized(this) {
-      for(MemberRevocationListener listener : revocationListeners) {
-        if(listener.matches(pattern)) {
+
+
+    PendingRevokeListener membershipListener = new PendingRevokeListener(pattern, sender, dm);
+    synchronized (this) {
+      for (MemberRevocationListener listener : revocationListeners) {
+        if (listener.matches(pattern)) {
-      
+
-    
-    //Add a membership listener to make sure we cancel the pending
-    //revoke if the sender goes away.
-    //DO this outside the synch block to avoid lock ordering issues.
+
+    // Add a membership listener to make sure we cancel the pending
+    // revoke if the sender goes away.
+    // DO this outside the synch block to avoid lock ordering issues.
-    if(! members.contains(sender) && sender.equals(dm.getId())) {
+    if (!members.contains(sender) && sender.equals(dm.getId())) {
-    
+
-  
+
-    synchronized(this) {
+    synchronized (this) {
-    if(listener != null) {
+    if (listener != null) {
-  
+
-     * Add the persistent id(s) of this listener to
-     * the passed in set.
+     * Add the persistent id(s) of this listener to the passed in set.
-     * Return true if this is a listener for a resource that matches
-     * the persistent member pattern in question.
+     * Return true if this is a listener for a resource that matches the persistent member pattern
+     * in question.
-    
+
-  
+
-    public PendingRevokeListener(PersistentMemberPattern pattern, InternalDistributedMember sender, DistributionManager dm) {
+    public PendingRevokeListener(PersistentMemberPattern pattern, InternalDistributedMember sender,
+        DistributionManager dm) {
-      
+
-      if(id.equals(sender)) {
+      if (id.equals(sender)) {
-      
+
-    public void memberSuspect(InternalDistributedMember id,
-        InternalDistributedMember whoSuspected, String reason) {
-    }
-    
+    public void memberSuspect(InternalDistributedMember id, InternalDistributedMember whoSuspected,
+        String reason) {}
+
-    public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
-    }
+    public void quorumLost(Set<InternalDistributedMember> failures,
+        List<InternalDistributedMember> remaining) {}

GEODE-5888: Only the thread locked objects can release/remove them (#2645)

 * A bulk opertion could remove lockObject due to RegionDestroyedException.
 * Now only the thread locked objects can release them.
 * Rename activeWriteLock to be primaryMoveReadLock as it is a readLock.

-  private LockObject searchAndLock(Object keys[]) {
+  LockObject searchAndLock(Object keys[]) {
-  public void waitUntilLocked(Object keys[]) {
+  public boolean waitUntilLocked(Object keys[]) {
-              this.partitionedRegion.checkReadiness();
+              partitionedRegion.checkReadiness();
-        break;
+        return true;
-    beginLocalWrite(event);
+    boolean locked = lockKeysAndPrimary(event);
-      endLocalWrite(event);
+      if (locked) {
+        releaseLockForKeysAndPrimary(event);
+      }
-   * stays the primary bucket while the write is in progress. Any call to this method must be
-   * followed with a call to endLocalWrite().
+   * stays the primary bucket while the write is in progress. This method must be followed with
+   * a call to releaseLockForKeysAndPrimary() if keys and primary are locked.
-  private boolean beginLocalWrite(EntryEventImpl event) {
+  boolean lockKeysAndPrimary(EntryEventImpl event) {
-    Object keys[] = new Object[1];
-    keys[0] = event.getKey();
+    Object[] keys = getKeysToBeLocked(event);
-      doLockForPrimary(false);
-      return lockedForPrimary = true;
+      lockedForPrimary = doLockForPrimary(false);
+      // tryLock is false means doLockForPrimary won't return false.
+      // either the method returns true or fails with an exception
+      assert lockedForPrimary : "expected doLockForPrimary returns true";
+      return lockedForPrimary;
+  Object[] getKeysToBeLocked(EntryEventImpl event) {
+    Object keys[] = new Object[1];
+    keys[0] = event.getKey();
+    return keys;
+  }
+
-    Lock activeWriteLock = this.getBucketAdvisor().getActiveWriteLock();
-    Lock parentLock = this.getBucketAdvisor().getParentActiveWriteLock();
+    Lock primaryMoveReadLock = getBucketAdvisor().getPrimaryMoveReadLock();
+    Lock parentLock = getBucketAdvisor().getParentPrimaryMoveReadLock();
-            boolean locked = activeWriteLock.tryLock();
+            boolean locked = primaryMoveReadLock.tryLock();
-            activeWriteLock.lockInterruptibly();
+            primaryMoveReadLock.lockInterruptibly();
-            boolean locked = activeWriteLock.tryLock();
+            boolean locked = primaryMoveReadLock.tryLock();
-            activeWriteLock.lockInterruptibly();
+            primaryMoveReadLock.lockInterruptibly();
-    Lock activeWriteLock = this.getBucketAdvisor().getActiveWriteLock();
-    activeWriteLock.unlock();
-    Lock parentLock = this.getBucketAdvisor().getParentActiveWriteLock();
+    Lock primaryMoveReadLock = getBucketAdvisor().getPrimaryMoveReadLock();
+    primaryMoveReadLock.unlock();
+    Lock parentLock = getBucketAdvisor().getParentPrimaryMoveReadLock();
+   * And release/remove the lockObject on the key(s)
-  private void endLocalWrite(EntryEventImpl event) {
-    if (!needWriteLock(event)) {
-      return;
-    }
-
-
+  void releaseLockForKeysAndPrimary(EntryEventImpl event) {
-    Object keys[] = new Object[1];
-    keys[0] = event.getKey();
+    Object[] keys = getKeysToBeLocked(event);
-    beginLocalWrite(event);
+    boolean locked = lockKeysAndPrimary(event);
-      endLocalWrite(event);
+      if (locked) {
+        releaseLockForKeysAndPrimary(event);
+      }
-    beginLocalWrite(event);
+    boolean locked = lockKeysAndPrimary(event);
-      endLocalWrite(event);
+      if (locked) {
+        releaseLockForKeysAndPrimary(event);
+      }
-    beginLocalWrite(event);
+    boolean locked = lockKeysAndPrimary(event);
-      endLocalWrite(event);
+      if (locked) {
+        releaseLockForKeysAndPrimary(event);
+      }
-      beginLocalWrite(event);
+      boolean keysAndPrimaryLocked = lockKeysAndPrimary(event);
-        endLocalWrite(event);
+        if (keysAndPrimaryLocked) {
+          releaseLockForKeysAndPrimary(event);
+        }

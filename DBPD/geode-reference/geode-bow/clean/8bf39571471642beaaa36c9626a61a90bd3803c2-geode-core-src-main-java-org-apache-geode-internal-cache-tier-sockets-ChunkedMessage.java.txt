Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Class <code>ChunkedMessage</code> is used to send messages from a server to
- * a client divided into chunks.
+ * Class <code>ChunkedMessage</code> is used to send messages from a server to a client divided into
+ * chunks.
- * This class encapsulates the wire protocol. It provides accessors to encode
- * and decode a message and serialize it out to the wire.
+ * This class encapsulates the wire protocol. It provides accessors to encode and decode a message
+ * and serialize it out to the wire.
- * We read the fixed length 15 bytes into a byte[] and populate a bytebuffer We
- * read the fixed length header tokens from the header parse the header and use
- * information contained in there to read the payload.
+ * We read the fixed length 15 bytes into a byte[] and populate a bytebuffer We read the fixed
+ * length header tokens from the header parse the header and use information contained in there to
+ * read the payload.
-public class ChunkedMessage extends Message
-{
+public class ChunkedMessage extends Message {
-    /**
-     * The chunk header length.
-     * The chunk header contains a 5-byte int chunk length (4 bytes for the chunk
-     * length and 1 byte for the last chunk boolean)
-     */
-    private static final int CHUNK_HEADER_LENGTH = 5;
-    /**
-     * The main header length. The main header contains 3 4-byte ints
-     */
-    private static final int CHUNK_MSG_HEADER_LENGTH = 12;
+  /**
+   * The chunk header length. The chunk header contains a 5-byte int chunk length (4 bytes for the
+   * chunk length and 1 byte for the last chunk boolean)
+   */
+  private static final int CHUNK_HEADER_LENGTH = 5;
+  /**
+   * The main header length. The main header contains 3 4-byte ints
+   */
+  private static final int CHUNK_MSG_HEADER_LENGTH = 12;
-    /**
-     * The chunk's payload length
-     */
-    protected int chunkLength;
+  /**
+   * The chunk's payload length
+   */
+  protected int chunkLength;
-//  /**
-//   * The main header length. The main header contains 3 4-byte ints
-//   */
-//  private static final int HEADER_LENGTH = 12;
+  // /**
+  // * The main header length. The main header contains 3 4-byte ints
+  // */
+  // private static final int HEADER_LENGTH = 12;
-   * Initially false; set to true once the message header is sent; set back to
-   * false when last chunk is sent.
+   * Initially false; set to true once the message header is sent; set back to false when last chunk
+   * is sent.
-    public String toString() {
-      StringBuffer sb = new StringBuffer();
-      
-      sb.append(super.toString());
-      sb.append("; chunkLength= " + chunkLength);
-      sb.append("; lastChunk=" + lastChunk);
-      return sb.toString();
-    }
-    
-    /**
-     * Creates a new message with the given number of parts
-     * @param numberOfParts The number of parts to create
-     */
-    public ChunkedMessage(int numberOfParts, Version version) {
-      super(numberOfParts, version);
-    }
+  public String toString() {
+    StringBuffer sb = new StringBuffer();
-    /**
-     * Returns the header length.
-     * @return the header length
-     */
-    @Override
-    public int getHeaderLength() {
-      return CHUNK_MSG_HEADER_LENGTH;
-    }
+    sb.append(super.toString());
+    sb.append("; chunkLength= " + chunkLength);
+    sb.append("; lastChunk=" + lastChunk);
+    return sb.toString();
+  }
+
+  /**
+   * Creates a new message with the given number of parts
+   * 
+   * @param numberOfParts The number of parts to create
+   */
+  public ChunkedMessage(int numberOfParts, Version version) {
+    super(numberOfParts, version);
+  }
+
+  /**
+   * Returns the header length.
+   * 
+   * @return the header length
+   */
+  @Override
+  public int getHeaderLength() {
+    return CHUNK_MSG_HEADER_LENGTH;
+  }
+   * 
-    //TODO:hitesh now it should send security header(connectionID)
-    if(lastChunk){
-      this.lastChunk=0X01;
+    // TODO:hitesh now it should send security header(connectionID)
+    if (lastChunk) {
+      this.lastChunk = 0X01;
-    }
-    else {
-      this.lastChunk= 0X00;
+    } else {
+      this.lastChunk = 0X00;
-  private void setFESpecialCase(){
-    byte  b = ServerConnection.isExecuteFunctionOnLocalNodeOnly();
-    if((b & 1) == 1) {
-      //we are in special function execution case, where filter key is one only
-      //now checking whether this function executed locally or not.
-      //if not then inform client so that it will refresh pr-meta-data
-      if(((b & 2) == 2)) {
-        
-        this.lastChunk |= 0x04;//setting third bit, we are okay
+  private void setFESpecialCase() {
+    byte b = ServerConnection.isExecuteFunctionOnLocalNodeOnly();
+    if ((b & 1) == 1) {
+      // we are in special function execution case, where filter key is one only
+      // now checking whether this function executed locally or not.
+      // if not then inform client so that it will refresh pr-meta-data
+      if (((b & 2) == 2)) {
+
+        this.lastChunk |= 0x04;// setting third bit, we are okay
+
-    setLastChunk(lastChunk);    
-    if (this.sc != null
-        && this.sc.getClientVersion().compareTo(Version.GFE_65) >= 0) {
-      //we us e three bits for number of parts in last chunk byte
-      //we us e three bits for number of parts in last chunk byte
-      byte localLastChunk = (byte)(numParts << 5);
+    setLastChunk(lastChunk);
+    if (this.sc != null && this.sc.getClientVersion().compareTo(Version.GFE_65) >= 0) {
+      // we us e three bits for number of parts in last chunk byte
+      // we us e three bits for number of parts in last chunk byte
+      byte localLastChunk = (byte) (numParts << 5);
-  
-  public void setServerConnection(ServerConnection servConn)
-  {    
-    if (this.sc != servConn) throw new IllegalStateException("this.sc was not correctly set");
+
+  public void setServerConnection(ServerConnection servConn) {
+    if (this.sc != servConn)
+      throw new IllegalStateException("this.sc was not correctly set");
-  
+
+   * 
-    if((this.lastChunk & 0X01) == 0X01) {
+    if ((this.lastChunk & 0X01) == 0X01) {
-    
+
-  public int getChunkLength()
-  {
+  public int getChunkLength() {
-    /**
-     *  Populates the header with information received via socket
-     */
-    public void readHeader() throws IOException {
-      if (this.socket != null) {
-        final ByteBuffer cb = getCommBuffer();
-        synchronized(cb) {
-          fetchHeader();
-          final int type = cb.getInt();
-          final int numParts = cb.getInt();
-          final int txid = cb.getInt();
-          cb.clear();
-          if (!MessageType.validate(type)) {
-            throw new IOException(LocalizedStrings.ChunkedMessage_INVALID_MESSAGE_TYPE_0_WHILE_READING_HEADER.toLocalizedString(Integer.valueOf(type)));
-          }
-
-          // Set the header and payload fields only after receiving all the
-          // socket data, providing better message consistency in the face
-          // of exceptional conditions (e.g. IO problems, timeouts etc.)
-          this.msgType = type;
-          this.numberOfParts = numParts;  // Already set in setPayloadFields via setNumberOfParts
-          this.transactionId = txid;
-        }
-      }
-      else {
-        throw new IOException(LocalizedStrings.ChunkedMessage_DEAD_CONNECTION.toLocalizedString());
-      }
-    }
-
-    /**
-     * Reads a chunk of this message.
-     */
-    public void receiveChunk() throws IOException {
-      if (this.socket != null) {
-        synchronized(getCommBuffer()) {
-          readChunk();
-        }
-      }
-      else {
-        throw new IOException(LocalizedStrings.ChunkedMessage_DEAD_CONNECTION.toLocalizedString());
-      }
-    }
-
-    /**
-     * Reads a chunk of this message.
-     */
-    private void readChunk() throws IOException {
+  /**
+   * Populates the header with information received via socket
+   */
+  public void readHeader() throws IOException {
+    if (this.socket != null) {
-      clearParts();
-      cb.clear();
-      int totalBytesRead = 0;
-      do {
-        int bytesRead = 0;
-        bytesRead = is.read(cb.array(), totalBytesRead, CHUNK_HEADER_LENGTH-totalBytesRead);
-        if (bytesRead == -1) {
-          throw new EOFException(LocalizedStrings.ChunkedMessage_CHUNK_READ_ERROR_CONNECTION_RESET.toLocalizedString());
+      synchronized (cb) {
+        fetchHeader();
+        final int type = cb.getInt();
+        final int numParts = cb.getInt();
+        final int txid = cb.getInt();
+        cb.clear();
+        if (!MessageType.validate(type)) {
+          throw new IOException(
+              LocalizedStrings.ChunkedMessage_INVALID_MESSAGE_TYPE_0_WHILE_READING_HEADER
+                  .toLocalizedString(Integer.valueOf(type)));
-        totalBytesRead += bytesRead;
-        if (this.msgStats != null) {
-          this.msgStats.incReceivedBytes(bytesRead);
-        }
-      } while (totalBytesRead < CHUNK_HEADER_LENGTH);
-      cb.rewind();
-
-      // Set chunk length and last chunk
-      this.chunkLength = cb.getInt();
-      //setLastChunk(cb.get() == 0x01);
-      byte lastChunk = cb.get();
-      setLastChunk((lastChunk & 0x01) == 0x01);
-      if ((lastChunk & 0x02) == 0x02) {
-        this.securePart = new Part();
-        if (logger.isDebugEnabled()) {
-          logger.debug("ChunkedMessage.readChunk() securePart present");
-        }
+        // Set the header and payload fields only after receiving all the
+        // socket data, providing better message consistency in the face
+        // of exceptional conditions (e.g. IO problems, timeouts etc.)
+        this.msgType = type;
+        this.numberOfParts = numParts; // Already set in setPayloadFields via setNumberOfParts
+        this.transactionId = txid;
+    } else {
+      throw new IOException(LocalizedStrings.ChunkedMessage_DEAD_CONNECTION.toLocalizedString());
+    }
+  }
+
+  /**
+   * Reads a chunk of this message.
+   */
+  public void receiveChunk() throws IOException {
+    if (this.socket != null) {
+      synchronized (getCommBuffer()) {
+        readChunk();
+      }
+    } else {
+      throw new IOException(LocalizedStrings.ChunkedMessage_DEAD_CONNECTION.toLocalizedString());
+    }
+  }
+
+  /**
+   * Reads a chunk of this message.
+   */
+  private void readChunk() throws IOException {
+    final ByteBuffer cb = getCommBuffer();
+    clearParts();
+    cb.clear();
+    int totalBytesRead = 0;
+    do {
+      int bytesRead = 0;
+      bytesRead = is.read(cb.array(), totalBytesRead, CHUNK_HEADER_LENGTH - totalBytesRead);
+      if (bytesRead == -1) {
+        throw new EOFException(
+            LocalizedStrings.ChunkedMessage_CHUNK_READ_ERROR_CONNECTION_RESET.toLocalizedString());
+      }
+      totalBytesRead += bytesRead;
+      if (this.msgStats != null) {
+        this.msgStats.incReceivedBytes(bytesRead);
+      }
+    } while (totalBytesRead < CHUNK_HEADER_LENGTH);
+
+    cb.rewind();
+
+    // Set chunk length and last chunk
+    this.chunkLength = cb.getInt();
+    // setLastChunk(cb.get() == 0x01);
+    byte lastChunk = cb.get();
+    setLastChunk((lastChunk & 0x01) == 0x01);
+    if ((lastChunk & 0x02) == 0x02) {
+      this.securePart = new Part();
+      if (logger.isDebugEnabled()) {
+        logger.debug("ChunkedMessage.readChunk() securePart present");
+      }
+    }
-    }
+  }
-    /**
-     * Sends the header of this message.
-     */
-    public void sendHeader() throws IOException {
-      if (this.socket != null) {
-        synchronized(getCommBuffer()) { 
-          getHeaderBytesForWrite();
-          flushBuffer();
-          // Darrel says: I see no need for the following os.flush() call
-          // so I've deadcoded it for performance.
-          // this.os.flush();
-        }
-        this.currentPart=0;
-        this.headerSent = true;
+  /**
+   * Sends the header of this message.
+   */
+  public void sendHeader() throws IOException {
+    if (this.socket != null) {
+      synchronized (getCommBuffer()) {
+        getHeaderBytesForWrite();
+        flushBuffer();
+        // Darrel says: I see no need for the following os.flush() call
+        // so I've deadcoded it for performance.
+        // this.os.flush();
-      else {
-        throw new IOException(LocalizedStrings.ChunkedMessage_DEAD_CONNECTION.toLocalizedString());
-      }
+      this.currentPart = 0;
+      this.headerSent = true;
+    } else {
+      throw new IOException(LocalizedStrings.ChunkedMessage_DEAD_CONNECTION.toLocalizedString());
+  }
-  public boolean headerHasBeenSent()
-  {
+  public boolean headerHasBeenSent() {
-  
+
-    if (this.sc != servConn) throw new IllegalStateException("this.sc was not correctly set");
+    if (this.sc != servConn)
+      throw new IllegalStateException("this.sc was not correctly set");
-  
+
-      //isLastChunk = (byte) 0x01 ;
-      isLastChunk = this.lastChunk ;
+      // isLastChunk = (byte) 0x01 ;
+      isLastChunk = this.lastChunk;
-        isLastChunk |= 0x02; 
+        isLastChunk |= 0x02;
-    //cb.put(isLastChunk() ? (byte) 0x01 : (byte) 0x00);
+    // cb.put(isLastChunk() ? (byte) 0x01 : (byte) 0x00);
-    /**
-     * Converts the header of this message into a <code>byte</code> array using a
-     * {@link ByteBuffer}.
-     */
-    protected void getHeaderBytesForWrite() {
-      final ByteBuffer cb = getCommBuffer();
-      cb.clear();
-      cb.putInt(this.msgType);
-      cb.putInt(this.numberOfParts); 
-      
-      cb.putInt(this.transactionId);
-    }
+  /**
+   * Converts the header of this message into a <code>byte</code> array using a {@link ByteBuffer}.
+   */
+  protected void getHeaderBytesForWrite() {
+    final ByteBuffer cb = getCommBuffer();
+    cb.clear();
+    cb.putInt(this.msgType);
+    cb.putInt(this.numberOfParts);
+
+    cb.putInt(this.transactionId);
+  }

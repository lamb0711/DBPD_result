Merge branch 'release/1.0.0-incubating.M3'

+import com.gemstone.gemfire.internal.security.GeodeSecurityUtil;
- * @since 6.6
+ * @since GemFire 6.6
-  static final ExecutorService execService = Executors
-      .newCachedThreadPool(new ThreadFactory() {
-        AtomicInteger threadNum = new AtomicInteger();
+  static final ExecutorService execService = Executors.newCachedThreadPool(new ThreadFactory() {
+    AtomicInteger threadNum = new AtomicInteger();
-        public Thread newThread(final Runnable r) {
-          Thread result = new Thread(r, "Function Execution Thread-"
-              + threadNum.incrementAndGet());
-          result.setDaemon(true);
-          return result;
-        }
-      });
-  
+    public Thread newThread(final Runnable r) {
+      Thread result = new Thread(r, "Function Execution Thread-" + threadNum.incrementAndGet());
+      result.setDaemon(true);
+      return result;
+    }
+  });
+
-  public void cmdExecute(Message msg, ServerConnection servConn, long start)
-      throws IOException {
+  public void cmdExecute(Message msg, ServerConnection servConn, long start) throws IOException {
-      }
-      else if (functionState == AbstractExecution.HA_HASRESULT_OPTIMIZEFORWRITE_REEXECUTE) {
+      } else if (functionState == AbstractExecution.HA_HASRESULT_OPTIMIZEFORWRITE_REEXECUTE) {
-        hasResult = (byte)((functionState & 2) - 1);
-      }
-      else {
+        hasResult = (byte) ((functionState & 2) - 1);
+      } else {
-        memberMappedArg = (MemberMappedArgument)part.getObject();
+        memberMappedArg = (MemberMappedArgument) part.getObject();
-    }
-    catch (ClassNotFoundException exception) {
+    } catch (ClassNotFoundException exception) {
-      }
-      else {
+      } else {
+
-          .toLocalizedString();
-      logger.warn(LocalizedMessage.create(LocalizedStrings.TWO_ARG_COLON, new Object[] { servConn.getName(), message }));
+        .toLocalizedString();
+      logger.warn(LocalizedMessage.create(LocalizedStrings.TWO_ARG_COLON, new Object[] {
+        servConn.getName(),
+        message
+      }));
-    else {
-      // Execute function on the cache
-      try {
-        Function functionObject = null;
-        if (function instanceof String) {
-          functionObject = FunctionService.getFunction((String)function);
-          if (functionObject == null) {
-            final String message = LocalizedStrings.ExecuteFunction_FUNCTION_NAMED_0_IS_NOT_REGISTERED
-                .toLocalizedString(function);
+
+    // Execute function on the cache
+    try {
+      Function functionObject = null;
+      if (function instanceof String) {
+        functionObject = FunctionService.getFunction((String) function);
+        if (functionObject == null) {
+          final String message = LocalizedStrings.ExecuteFunction_FUNCTION_NAMED_0_IS_NOT_REGISTERED.toLocalizedString(function);
+          logger.warn("{}: {}", servConn.getName(), message);
+          sendError(hasResult, msg, message, servConn);
+          return;
+        } else {
+          byte functionStateOnServerSide = AbstractExecution.getFunctionState(functionObject.isHA(), functionObject.hasResult(), functionObject
+            .optimizeForWrite());
+          if (logger.isDebugEnabled()) {
+            logger.debug("Function State on server side: {} on client: {}", functionStateOnServerSide, functionState);
+          }
+          if (functionStateOnServerSide != functionState) {
+            String message = LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH_CLIENT_SERVER.toLocalizedString(function);
-          else {
-            byte functionStateOnServerSide = AbstractExecution
-                .getFunctionState(functionObject.isHA(), functionObject
-                    .hasResult(), functionObject.optimizeForWrite());
-            if (logger.isDebugEnabled()) {
-              logger.debug("Function State on server side: {} on client: {}", functionStateOnServerSide, functionState);
-            }
-            if (functionStateOnServerSide != functionState) {
-              String message = LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH_CLIENT_SERVER
-                  .toLocalizedString(function);
-              logger.warn("{}: {}", servConn.getName(), message);
-              sendError(hasResult, msg, message, servConn);
-              return;
-            }
-          }
-        else {
-          functionObject = (Function)function;
-        }
-        FunctionStats stats = FunctionStats.getFunctionStats(functionObject
-            .getId(), null);
-        // check if the caller is authorized to do this operation on server
-        AuthorizeRequest authzRequest = servConn.getAuthzRequest();
-        ExecuteFunctionOperationContext executeContext = null;
-        if (authzRequest != null) {
-          executeContext = authzRequest.executeFunctionAuthorize(functionObject
-              .getId(), null, null, args, functionObject.optimizeForWrite());
-        }
-        ChunkedMessage m = servConn.getFunctionResponseMessage();
-        m.setTransactionId(msg.getTransactionId());
-        ServerToClientFunctionResultSender resultSender = new ServerToClientFunctionResultSender65(m,
-            MessageType.EXECUTE_FUNCTION_RESULT, servConn, functionObject,
-            executeContext);
-
-        InternalDistributedMember localVM = InternalDistributedSystem
-            .getAnyInstance().getDistributedMember();
-        FunctionContext context = null;
-
-        if (memberMappedArg != null) {
-          context = new FunctionContextImpl(functionObject.getId(),
-              memberMappedArg.getArgumentsForMember(localVM.getId()),
-              resultSender, isReexecute);
-        }
-        else {
-          context = new FunctionContextImpl(functionObject.getId(), args,
-              resultSender, isReexecute);
-        }
-        HandShake handShake = (HandShake)servConn.getHandshake();
-        int earlierClientReadTimeout = handShake.getClientReadTimeout();
-        handShake.setClientReadTimeout(functionTimeout);
-        try {
-          if (logger.isDebugEnabled()) {
-            logger.debug("Executing Function on Server: {} with context: {}", servConn, context);
-          }
-          GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
-          HeapMemoryMonitor hmm = ((InternalResourceManager) cache.getResourceManager()).getHeapMonitor();
-          if (functionObject.optimizeForWrite() && cache != null
-              && hmm.getState().isCritical()
-              && !MemoryThresholds.isLowMemoryExceptionDisabled()) {
-            Set<DistributedMember> sm = Collections
-                .singleton((DistributedMember)cache.getMyId());
-            Exception e = new LowMemoryException(
-                LocalizedStrings.ResourceManager_LOW_MEMORY_FOR_0_FUNCEXEC_MEMBERS_1
-                    .toLocalizedString(new Object[] { functionObject.getId(),
-                        sm }), sm);
-
-            sendException(hasResult, msg, e.getMessage(), servConn, e);
-            return;
-          }
-          /**
-           * if cache is null, then either cache has not yet been created on
-           * this node or it is a shutdown scenario.
-           */
-          DM dm = null;
-          if (cache != null) {
-            dm = cache.getDistributionManager();
-          }
-          if (groups != null && groups.length > 0) {
-            executeFunctionOnGroups(function, args, groups, allMembers,
-                functionObject, resultSender, ignoreFailedMembers);
-          } else {
-            executeFunctionaLocally(functionObject, context,
-                (ServerToClientFunctionResultSender65)resultSender, dm, stats);
-          }
-
-          if (!functionObject.hasResult()) {
-            writeReply(msg, servConn);
-          }
-        }
-        catch (FunctionException functionException) {
-          stats.endFunctionExecutionWithException(functionObject.hasResult());
-          throw functionException;
-        }
-        catch (Exception exception) {
-          stats.endFunctionExecutionWithException(functionObject.hasResult());
-          throw new FunctionException(exception);
-        }
-        finally {
-          handShake.setClientReadTimeout(earlierClientReadTimeout);
-        }
+      } else {
+        functionObject = (Function) function;
-      catch (IOException ioException) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, function), ioException);
-        String message = LocalizedStrings.ExecuteFunction_SERVER_COULD_NOT_SEND_THE_REPLY
-            .toLocalizedString();
-        sendException(hasResult, msg, message, servConn, ioException);
-      } 
-      catch (InternalFunctionInvocationTargetException internalfunctionException) {
-        // Fix for #44709: User should not be aware of
-        // InternalFunctionInvocationTargetException. No instance of
-        // InternalFunctionInvocationTargetException is giving useful
-        // information to user to take any corrective action hence logging
-        // this at fine level logging
-        // 1> When bucket is moved
-        // 2> Incase of HA FucntionInvocationTargetException thrown. Since
-        // it is HA, fucntion will be reexecuted on right node
-        // 3> Multiple target nodes found for single hop operation
-        // 4> in case of HA member departed
+
+      GeodeSecurityUtil.authorizeDataWrite();
+
+      FunctionStats stats = FunctionStats.getFunctionStats(functionObject.getId(), null);
+      // check if the caller is authorized to do this operation on server
+      AuthorizeRequest authzRequest = servConn.getAuthzRequest();
+      ExecuteFunctionOperationContext executeContext = null;
+      if (authzRequest != null) {
+        executeContext = authzRequest.executeFunctionAuthorize(functionObject.getId(), null, null, args, functionObject.optimizeForWrite());
+      }
+      ChunkedMessage m = servConn.getFunctionResponseMessage();
+      m.setTransactionId(msg.getTransactionId());
+      ServerToClientFunctionResultSender resultSender = new ServerToClientFunctionResultSender65(m, MessageType.EXECUTE_FUNCTION_RESULT, servConn, functionObject, executeContext);
+
+      InternalDistributedMember localVM = InternalDistributedSystem.getAnyInstance().getDistributedMember();
+      FunctionContext context = null;
+
+      if (memberMappedArg != null) {
+        context = new FunctionContextImpl(functionObject.getId(), memberMappedArg.getArgumentsForMember(localVM.getId()), resultSender, isReexecute);
+      } else {
+        context = new FunctionContextImpl(functionObject.getId(), args, resultSender, isReexecute);
+      }
+      HandShake handShake = (HandShake) servConn.getHandshake();
+      int earlierClientReadTimeout = handShake.getClientReadTimeout();
+      handShake.setClientReadTimeout(functionTimeout);
+      try {
-          logger.debug(LocalizedMessage.create(LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, new Object[] { function }), internalfunctionException);
+          logger.debug("Executing Function on Server: {} with context: {}", servConn, context);
-        final String message = internalfunctionException.getMessage();
-        sendException(hasResult, msg, message, servConn, internalfunctionException);
-      } 
-      catch (Exception e) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, function), e);
-        final String message = e.getMessage();
-        sendException(hasResult, msg, message, servConn, e);
+        GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
+        HeapMemoryMonitor hmm = ((InternalResourceManager) cache.getResourceManager()).getHeapMonitor();
+        if (functionObject.optimizeForWrite() && cache != null && hmm.getState()
+                                                                     .isCritical() && !MemoryThresholds.isLowMemoryExceptionDisabled()) {
+          Set<DistributedMember> sm = Collections.singleton((DistributedMember) cache.getMyId());
+          Exception e = new LowMemoryException(LocalizedStrings.ResourceManager_LOW_MEMORY_FOR_0_FUNCEXEC_MEMBERS_1.toLocalizedString(new Object[] {
+            functionObject.getId(), sm
+          }), sm);
+
+          sendException(hasResult, msg, e.getMessage(), servConn, e);
+          return;
+        }
+        /**
+         * if cache is null, then either cache has not yet been created on
+         * this node or it is a shutdown scenario.
+         */
+        DM dm = null;
+        if (cache != null) {
+          dm = cache.getDistributionManager();
+        }
+        if (groups != null && groups.length > 0) {
+          executeFunctionOnGroups(function, args, groups, allMembers, functionObject, resultSender, ignoreFailedMembers);
+        } else {
+          executeFunctionaLocally(functionObject, context, (ServerToClientFunctionResultSender65) resultSender, dm, stats);
+        }
+
+        if (!functionObject.hasResult()) {
+          writeReply(msg, servConn);
+        }
+      } catch (FunctionException functionException) {
+        stats.endFunctionExecutionWithException(functionObject.hasResult());
+        throw functionException;
+      } catch (Exception exception) {
+        stats.endFunctionExecutionWithException(functionObject.hasResult());
+        throw new FunctionException(exception);
+      } finally {
+        handShake.setClientReadTimeout(earlierClientReadTimeout);
+    } catch (IOException ioException) {
+      logger.warn(LocalizedMessage.create(LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, function), ioException);
+      String message = LocalizedStrings.ExecuteFunction_SERVER_COULD_NOT_SEND_THE_REPLY.toLocalizedString();
+      sendException(hasResult, msg, message, servConn, ioException);
+    } catch (InternalFunctionInvocationTargetException internalfunctionException) {
+      // Fix for #44709: User should not be aware of
+      // InternalFunctionInvocationTargetException. No instance of
+      // InternalFunctionInvocationTargetException is giving useful
+      // information to user to take any corrective action hence logging
+      // this at fine level logging
+      // 1> When bucket is moved
+      // 2> Incase of HA FucntionInvocationTargetException thrown. Since
+      // it is HA, fucntion will be reexecuted on right node
+      // 3> Multiple target nodes found for single hop operation
+      // 4> in case of HA member departed
+      if (logger.isDebugEnabled()) {
+        logger.debug(LocalizedMessage.create(LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, new Object[] {
+          function
+        }), internalfunctionException);
+      }
+      final String message = internalfunctionException.getMessage();
+      sendException(hasResult, msg, message, servConn, internalfunctionException);
+    } catch (Exception e) {
+      logger.warn(LocalizedMessage.create(LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, function), e);
+      final String message = e.getMessage();
+      sendException(hasResult, msg, message, servConn, e);
-  protected void executeFunctionOnGroups(Object function, Object args,
-      String[] groups, boolean allMembers, Function functionObject,
-      ServerToClientFunctionResultSender resultSender, boolean ignoreFailedMembers) {
+  protected void executeFunctionOnGroups(Object function,
+                                         Object args,
+                                         String[] groups,
+                                         boolean allMembers,
+                                         Function functionObject,
+                                         ServerToClientFunctionResultSender resultSender,
+                                         boolean ignoreFailedMembers) {
-      final FunctionContext cx,
-      final ServerToClientFunctionResultSender65 sender, DM dm,
-      final FunctionStats stats) throws IOException {
+                                       final FunctionContext cx,
+                                       final ServerToClientFunctionResultSender65 sender,
+                                       DM dm,
+                                       final FunctionStats stats) throws IOException {
-      if (!((ServerToClientFunctionResultSender65)sender)
-          .isLastResultReceived() && fn.hasResult()) {
-        throw new FunctionException(
-            LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT
-                .toString(fn.getId()));
+      if (!((ServerToClientFunctionResultSender65) sender).isLastResultReceived() && fn.hasResult()) {
+        throw new FunctionException(LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT.toString(fn
+          .getId()));
-              if (cache.getLoggerI18n().warningEnabled()
-                  && !ASYNC_TX_WARNING_ISSUED) {
+              if (cache.getLoggerI18n().warningEnabled() && !ASYNC_TX_WARNING_ISSUED) {
-                cache
-                    .getLoggerI18n()
-                    .warning(
-                        LocalizedStrings.ExecuteFunction66_TRANSACTIONAL_FUNCTION_WITHOUT_RESULT);
+                cache.getLoggerI18n().warning(LocalizedStrings.ExecuteFunction66_TRANSACTIONAL_FUNCTION_WITHOUT_RESULT);
-              logger.debug(LocalizedMessage.create(LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, new Object[] { fn }), internalfunctionException);
+              logger.debug(LocalizedMessage.create(LocalizedStrings.ExecuteFunction_EXCEPTION_ON_SERVER_WHILE_EXECUTIONG_FUNCTION_0, new Object[] {
+                fn
+              }), internalfunctionException);
-        final DistributionManager newDM = (DistributionManager)dm;
+        final DistributionManager newDM = (DistributionManager) dm;
-  private void sendException(byte hasResult, Message msg, String message,
-      ServerConnection servConn, Throwable e) throws IOException {
+  private void sendException(byte hasResult, Message msg, String message, ServerConnection servConn, Throwable e)
+    throws IOException {
-      writeFunctionResponseException(msg, MessageType.EXCEPTION, message,
-          servConn, e);
-    }
-    else {
+      writeFunctionResponseException(msg, MessageType.EXCEPTION, message, servConn, e);
+    } else {
-  private void sendError(byte hasResult, Message msg, String message,
-      ServerConnection servConn) throws IOException {
+  private void sendError(byte hasResult, Message msg, String message, ServerConnection servConn) throws IOException {
-      writeFunctionResponseError(msg, MessageType.EXECUTE_FUNCTION_ERROR,
-          message, servConn);
-    }
-    else {
-      writeErrorResponse(msg, MessageType.EXECUTE_FUNCTION_ERROR, message,
-          servConn);
+      writeFunctionResponseError(msg, MessageType.EXECUTE_FUNCTION_ERROR, message, servConn);
+    } else {
+      writeErrorResponse(msg, MessageType.EXECUTE_FUNCTION_ERROR, message, servConn);

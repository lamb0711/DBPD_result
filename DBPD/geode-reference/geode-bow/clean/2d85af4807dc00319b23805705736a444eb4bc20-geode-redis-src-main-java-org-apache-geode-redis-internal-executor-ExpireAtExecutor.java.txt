GEODE-8166: reimplement redis expiration to use new data model (#5174)

* Added timestamp field to RedisData and implemented serialization and delta for it.
Both active and passive expiration have been implemented.

* RedisHash, RedisSet, and RedisString now subclass AbstractRedisData
* type command now uses function
* getset, incr, decr, incrby, and decrby now uses function and is atomic

+import static java.util.concurrent.TimeUnit.SECONDS;
-import org.apache.geode.redis.internal.RegionProvider;
-    int SET = 1;
-    int NOT_SET = 0;
-    RegionProvider regionProvider = context.getRegionProvider();
-      timestamp = timestamp * millisInSecond;
+      timestamp = SECONDS.toMillis(timestamp);
-    long currentTimeMillis = System.currentTimeMillis();
-
-    if (timestamp <= currentTimeMillis) {
-      int result = NOT_SET;
-      RedisKeyCommands redisKeyCommands = getRedisKeyCommands(context);
-      if (redisKeyCommands.del(wKey)) {
-        result = SET;
-      }
-
-      command.setResponse(
-          Coder.getIntegerResponse(
-              context.getByteBufAllocator(),
-              result));
-      return;
-    }
-
-    long delayMillis = timestamp - currentTimeMillis;
-
-    boolean expirationSet;
-
-    if (regionProvider.hasExpiration(wKey)) {
-      expirationSet = regionProvider.modifyExpiration(wKey, delayMillis);
-    } else {
-      expirationSet = regionProvider.setExpiration(wKey, delayMillis);
-    }
-
-    if (expirationSet) {
-      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), SET));
-    } else {
-      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), NOT_SET));
-    }
+    RedisKeyCommands redisKeyCommands = getRedisKeyCommands(context);
+    int result = redisKeyCommands.pexpireat(wKey, timestamp);
+    command.setResponse(
+        Coder.getIntegerResponse(
+            context.getByteBufAllocator(),
+            result));

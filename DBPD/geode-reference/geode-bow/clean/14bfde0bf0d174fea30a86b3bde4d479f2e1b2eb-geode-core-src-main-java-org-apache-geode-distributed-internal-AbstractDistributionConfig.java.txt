Merge branch 'release/1.8.0'

+import static org.apache.geode.distributed.ConfigurationProperties.SSL_USE_DEFAULT_CONTEXT;
+import java.net.InetSocketAddress;
+import java.util.HashSet;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-  protected Object checkAttribute(String attName, Object value) {
+  Object checkAttribute(String attName, Object value) {
-
-  protected void minMaxCheck(String propName, int value, int minValue, int maxValue) {
+  private void minMaxCheck(String propName, int value, int minValue, int maxValue) {
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2
-              .toLocalizedString(
-                  new Object[] {propName, Integer.valueOf(value), Integer.valueOf(minValue)}));
+          String.format(
+              "Could not set \"%s\" to \"%s\" because its value can not be less than \"%s\".",
+
+              propName, value, minValue));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2
-              .toLocalizedString(
-                  new Object[] {propName, Integer.valueOf(value), Integer.valueOf(maxValue)}));
+          String.format(
+              "Could not set \"%s\" to \"%s\" because its value can not be greater than \"%s\".",
+              propName, value, maxValue));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_0_WHEN_2_IS_TRUE
-              .toLocalizedString(
-                  new Object[] {TCP_PORT, Integer.valueOf(value), CLUSTER_SSL_ENABLED}));
+          String.format("Could not set %s to %s because its value must be 0 when %s is true.",
+              TCP_PORT, value, CLUSTER_SSL_ENABLED));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_0_WHEN_2_IS_TRUE
-              .toLocalizedString(
-                  new Object[] {MCAST_PORT, Integer.valueOf(value), CLUSTER_SSL_ENABLED}));
+          String.format("Could not set %s to %s because its value must be 0 when %s is true.",
+              MCAST_PORT, value, CLUSTER_SSL_ENABLED));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_IT_WAS_NOT_A_MULTICAST_ADDRESS
-              .toLocalizedString(new Object[] {MCAST_ADDRESS, value}));
+          String.format("Could not set %s to %s because it was not a multicast address.",
+              MCAST_ADDRESS, value));
-          LocalizedStrings.AbstractDistributionConfig_BIND_ADDRESS_0_INVALID_MUST_BE_IN_1
-              .toLocalizedString(new Object[] {value, SocketCreator.getMyAddresses()}));
+          String.format(
+              "The bind-address %s is not a valid address for this machine.  These are the valid addresses for this machine: %s",
+              value, SocketCreator.getMyAddresses()));
-          LocalizedStrings.AbstractDistributionConfig_BIND_ADDRESS_0_INVALID_MUST_BE_IN_1
-              .toLocalizedString(new Object[] {value, SocketCreator.getMyAddresses()}));
+          String.format(
+              "The bind-address %s is not a valid address for this machine.  These are the valid addresses for this machine: %s",
+              value, SocketCreator.getMyAddresses()));
-    if (value.booleanValue() && (getMcastPort() != 0)) {
+    if (value && getMcastPort() != 0) {
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_FALSE_WHEN_2_IS_NOT_0
-              .toLocalizedString(new Object[] {CLUSTER_SSL_ENABLED, value, MCAST_PORT}));
+          String.format("Could not set %s to %s because its value must be false when %s is not 0.",
+              CLUSTER_SSL_ENABLED, value, MCAST_PORT));
-          LocalizedStrings.AbstractDistributionConfig_BIND_ADDRESS_0_INVALID_MUST_BE_IN_1
-              .toLocalizedString(new Object[] {value, SocketCreator.getMyAddresses()}));
+          String.format(
+              "The bind-address %s is not a valid address for this machine.  These are the valid addresses for this machine: %s",
+              value, SocketCreator.getMyAddresses()));
-    // this check is specific for Jayesh's use case of WAN BootStraping
+    // this check is specific for Jayesh's use case of WAN BootStrapping
-            LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2
-                .toLocalizedString(new Object[] {DISTRIBUTED_SYSTEM_ID, Integer.valueOf(value),
-                    Integer.valueOf(MIN_DISTRIBUTED_SYSTEM_ID)}));
+            String.format(
+                "Could not set \"%s\" to \"%s\" because its value can not be less than \"%s\".",
+                DISTRIBUTED_SYSTEM_ID, value,
+                MIN_DISTRIBUTED_SYSTEM_ID));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2
-              .toLocalizedString(new Object[] {DISTRIBUTED_SYSTEM_ID, Integer.valueOf(value),
-                  Integer.valueOf(MAX_DISTRIBUTED_SYSTEM_ID)}));
+          String.format(
+              "Could not set \"%s\" to \"%s\" because its value can not be greater than \"%s\".",
+              DISTRIBUTED_SYSTEM_ID, value,
+              MAX_DISTRIBUTED_SYSTEM_ID));
-   * <p>
-   * <p>
-    StringBuffer sb = new StringBuffer();
+    StringBuilder sb = new StringBuilder();
-    Set locs = new java.util.HashSet();
+    Set<InetSocketAddress> locs = new HashSet<>();
-      StringBuffer locatorsb = new StringBuffer(); // string for this locator is accumulated in this
-                                                   // buffer
+      // string for this locator is accumulated in this buffer
+      StringBuilder locatorsb = new StringBuilder();
-            LocalizedStrings.AbstractDistributionConfig_INVALID_LOCATOR_0_HOST_NAME_WAS_EMPTY
-                .toLocalizedString(value));
+            String.format("Invalid locator %s. Host name was empty.",
+                value));
-              LocalizedStrings.AbstractDistributionConfig_UNKNOWN_LOCATOR_BIND_ADDRESS_0
-                  .toLocalizedString(bindAddr));
+              String.format("Unknown locator bind address: %s",
+                  bindAddr));
-              LocalizedStrings.AbstractDistributionConfig_INVALID_LOCATOR_0
-                  .toLocalizedString(value));
+              String.format("Invalid locator: %s",
+                  value));
-      int portVal = 0;
+      int portVal;
-              LocalizedStrings.AbstractDistributionConfig_INVALID_LOCATOR_0_THE_PORT_1_WAS_NOT_GREATER_THAN_ZERO_AND_LESS_THAN_65536
-                  .toLocalizedString(new Object[] {value, Integer.valueOf(portVal)}));
+              String.format(
+                  "Invalid locator %s. The port %s was not greater than zero and less than 65,536.",
+                  value, portVal));
-            LocalizedStrings.AbstractDistributionConfig_INVALID_LOCATOR_0.toLocalizedString(value));
+            String.format("Invalid locator: %s", value));
-      java.net.InetSocketAddress sockAddr = new java.net.InetSocketAddress(hostAddress, portVal);
+      InetSocketAddress sockAddr = new InetSocketAddress(hostAddress, portVal);
-        locs.add(new java.net.InetSocketAddress(hostAddress, portVal));
+        locs.add(new InetSocketAddress(hostAddress, portVal));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_BYTEALLOWANCE_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2
-              .toLocalizedString(new Object[] {MCAST_FLOW_CONTROL, Integer.valueOf(value),
-                  Integer.valueOf(MIN_FC_BYTE_ALLOWANCE)}));
+          String.format(
+              "Could not set %s.byteAllowance to %s because its value can not be less than %s",
+              MCAST_FLOW_CONTROL, value,
+              MIN_FC_BYTE_ALLOWANCE));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGETHRESHOLD_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2
-              .toLocalizedString(new Object[] {MCAST_FLOW_CONTROL, new Float(fvalue),
-                  new Float(MIN_FC_RECHARGE_THRESHOLD)}));
+          String.format(
+              "Could not set %s.rechargeThreshold to %s because its value can not be less than %s",
+              MCAST_FLOW_CONTROL, fvalue,
+              MIN_FC_RECHARGE_THRESHOLD));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGETHRESHOLD_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2
-              .toLocalizedString(new Object[] {MCAST_FLOW_CONTROL, new Float(fvalue),
-                  new Float(MAX_FC_RECHARGE_THRESHOLD)}));
+          String.format(
+              "Could not set %s.rechargeThreshold to %s because its value can not be greater than %s",
+              MCAST_FLOW_CONTROL, fvalue,
+              MAX_FC_RECHARGE_THRESHOLD));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGEBLOCKMS_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2
-              .toLocalizedString(new Object[] {MCAST_FLOW_CONTROL, Integer.valueOf(value),
-                  Integer.valueOf(MIN_FC_RECHARGE_BLOCK_MS)}));
+          String.format(
+              "Could not set %s.rechargeBlockMs to %s because its value can not be less than %s",
+              MCAST_FLOW_CONTROL, value,
+              MIN_FC_RECHARGE_BLOCK_MS));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGEBLOCKMS_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2
-              .toLocalizedString(new Object[] {MCAST_FLOW_CONTROL, Integer.valueOf(value),
-                  Integer.valueOf(MAX_FC_RECHARGE_BLOCK_MS)}));
+          String.format(
+              "Could not set %s.rechargeBlockMs to %s because its value can not be greater than %s",
+              MCAST_FLOW_CONTROL, value,
+              MAX_FC_RECHARGE_BLOCK_MS));
-    minMaxCheck(MEMBERSHIP_PORT_RANGE, value[0], DEFAULT_MEMBERSHIP_PORT_RANGE[0], value[1]);
-    minMaxCheck(MEMBERSHIP_PORT_RANGE, value[1], value[0], DEFAULT_MEMBERSHIP_PORT_RANGE[1]);
+    minMaxCheck(MEMBERSHIP_PORT_RANGE, value[0], 1024, value[1]);
+    minMaxCheck(MEMBERSHIP_PORT_RANGE, value[1], value[0], 65535);
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2
-              .toLocalizedString(new Object[] {MEMBERSHIP_PORT_RANGE, value[0] + "-" + value[1],
-                  Integer.valueOf(3)}));
+          String.format(
+              "Could not set \"%s\" to \"%s\" because its value can not be less than \"%s\".",
+              MEMBERSHIP_PORT_RANGE, value[0] + "-" + value[1],
+              3));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_2_MUST_BE_0_WHEN_SECURITY_IS_ENABLED
-              .toLocalizedString(new Object[] {SECURITY_PEER_AUTH_INIT, value, mcastInfo}));
+          String.format("Could not set %s to %s because %s must be 0 when security is enabled.",
+              SECURITY_PEER_AUTH_INIT, value, mcastInfo));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_2_MUST_BE_0_WHEN_SECURITY_IS_ENABLED
-              .toLocalizedString(new Object[] {SECURITY_PEER_AUTHENTICATOR, value, mcastInfo}));
+          String.format("Could not set %s to %s because %s must be 0 when security is enabled.",
+              SECURITY_PEER_AUTHENTICATOR, value, mcastInfo));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2
-              .toLocalizedString(new Object[] {SECURITY_LOG_LEVEL,
-                  LogWriterImpl.levelToString(value), LogWriterImpl.levelToString(MIN_LOG_LEVEL)}));
+          String.format(
+              "Could not set \"%s\" to \"%s\" because its value can not be less than \"%s\".",
+              SECURITY_LOG_LEVEL,
+              LogWriterImpl.levelToString(value), LogWriterImpl.levelToString(MIN_LOG_LEVEL)));
-          LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2
-              .toLocalizedString(new Object[] {SECURITY_LOG_LEVEL,
-                  LogWriterImpl.levelToString(value), LogWriterImpl.levelToString(MAX_LOG_LEVEL)}));
+          String.format(
+              "Could not set \"%s\" to \"%s\" because its value can not be greater than \"%s\".",
+              SECURITY_LOG_LEVEL,
+              LogWriterImpl.levelToString(value), LogWriterImpl.levelToString(MAX_LOG_LEVEL)));
-        || (!protocol.equalsIgnoreCase(GemFireMemcachedServer.Protocol.ASCII.name())
-            && !protocol.equalsIgnoreCase(GemFireMemcachedServer.Protocol.BINARY.name()))) {
+        || !protocol.equalsIgnoreCase(GemFireMemcachedServer.Protocol.ASCII.name())
+            && !protocol.equalsIgnoreCase(GemFireMemcachedServer.Protocol.BINARY.name())) {
-          LocalizedStrings.AbstractDistributionConfig_MEMCACHED_PROTOCOL_MUST_BE_ASCII_OR_BINARY
-              .toLocalizedString());
+          "memcached-protocol must be ASCII or BINARY ");
-          LocalizedStrings.AbstractDistributionConfig_MEMCACHED_BIND_ADDRESS_0_INVALID_MUST_BE_IN_1
-              .toLocalizedString(new Object[] {value, SocketCreator.getMyAddresses()}));
+          String.format(
+              "The memcached-bind-address %s is not a valid address for this machine.  These are the valid addresses for this machine: %s",
+              value, SocketCreator.getMyAddresses()));
-          LocalizedStrings.AbstractDistributionConfig_REDIS_BIND_ADDRESS_0_INVALID_MUST_BE_IN_1
-              .toLocalizedString(new Object[] {value, SocketCreator.getMyAddresses()}));
+          String.format(
+              "The redis-bind-address %s is not a valid address for this machine.  These are the valid addresses for this machine: %s",
+              value, SocketCreator.getMyAddresses()));
-              LocalizedStrings.AbstractDistributionConfig_SSL_ENABLED_COMPONENTS_0_INVALID_TRY_1
-                  .toLocalizedString(new Object[] {value,
-                      StringUtils
-                          .join(new String[] {SecurableCommunicationChannel.ALL.getConstant(),
-                              SecurableCommunicationChannel.CLUSTER.getConstant(),
-                              SecurableCommunicationChannel.SERVER.getConstant(),
-                              SecurableCommunicationChannel.GATEWAY.getConstant(),
-                              SecurableCommunicationChannel.JMX.getConstant(),
-                              SecurableCommunicationChannel.WEB.getConstant(),
-                              SecurableCommunicationChannel.LOCATOR.getConstant()}, ",")}));
+              String.format("%s is not in the valid set of options %s",
+                  Arrays.toString(value),
+                  StringUtils
+                      .join(new String[] {SecurableCommunicationChannel.ALL.getConstant(),
+                          SecurableCommunicationChannel.CLUSTER.getConstant(),
+                          SecurableCommunicationChannel.SERVER.getConstant(),
+                          SecurableCommunicationChannel.GATEWAY.getConstant(),
+                          SecurableCommunicationChannel.JMX.getConstant(),
+                          SecurableCommunicationChannel.WEB.getConstant(),
+                          SecurableCommunicationChannel.LOCATOR.getConstant()}, ",")));
-            LocalizedStrings.AbstractDistributionConfig_SSL_ENABLED_COMPONENTS_SET_INVALID_DEPRECATED_SSL_SET
-                .toLocalizedString());
+            "When using ssl-enabled-components one cannot use any other SSL properties other than cluster-ssl-* or the corresponding aliases");
-  // AbstractConfig overriding methods
-
+  @Override
-            LocalizedStrings.AbstractDistributionConfig_0_VALUE_1_MUST_BE_OF_TYPE_2
-                .toLocalizedString(new Object[] {attName, attValue, validValueClass.getName()}));
+            String.format("%s value %s must be of type %s",
+                attName, attValue, validValueClass.getName()));
-      this.setSecurity(attName, attValue.toString());
+      setSecurity(attName, attValue.toString());
-      this.setSSLProperty(attName, attValue.toString());
+      setSSLProperty(attName, attValue.toString());
-          LocalizedStrings.AbstractDistributionConfig_UNHANDLED_ATTRIBUTE_NAME_0
-              .toLocalizedString(attName));
+          String.format("unhandled attribute name %s.",
+              attName));
+  @Override
-      return LogWriterImpl.levelToString(this.getLogLevel());
+      return LogWriterImpl.levelToString(getLogLevel());
-      return LogWriterImpl.levelToString(this.getSecurityLogLevel());
+      return LogWriterImpl.levelToString(getSecurityLogLevel());
-        return this.getSecurity(attName);
+        return getSecurity(attName);
-          LocalizedStrings.AbstractDistributionConfig_UNHANDLED_ATTRIBUTE_NAME_0
-              .toLocalizedString(attName));
+          String.format("unhandled attribute name %s.",
+              attName));
-
-  public boolean isAttributeModifiable(String attName) {
-    checkAttributeName(attName);
-    if (getModifiableAttributes().contains(attName)) {
+  @Override
+  public boolean isAttributeModifiable(String name) {
+    checkAttributeName(name);
+    if (getModifiableAttributes().contains(name)) {
-    if (getUnModifiableAttributes().contains(attName)) {
+    if (getUnModifiableAttributes().contains(name)) {
-
-  ;
-  public List<String> getUnModifiableAttributes() {
+  private List<String> getUnModifiableAttributes() {
+  @Override
-  public static Class _getAttributeType(String attName) {
+  static Class _getAttributeType(String attName) {
-          LocalizedStrings.AbstractDistributionConfig_UNHANDLED_ATTRIBUTE_NAME_0
-              .toLocalizedString(attName));
+          String.format("unhandled attribute name %s.",
+              attName));
-  protected static final Map dcAttDescriptions;
+  static final Map dcAttDescriptions;
-    Map<String, String> m = new HashMap<String, String>();
+    Map<String, String> m = new HashMap<>();
-        LocalizedStrings.AbstractDistributionConfig_DEFAULT_ACK_WAIT_THRESHOLD_0_1_2
-            .toLocalizedString(new Object[] {Integer.valueOf(DEFAULT_ACK_WAIT_THRESHOLD),
-                Integer.valueOf(MIN_ACK_WAIT_THRESHOLD), Integer.valueOf(MIN_ACK_WAIT_THRESHOLD)}));
+        String.format(
+            "The number of seconds a distributed message can wait for acknowledgment before it sends an alert to signal that something might be wrong with the system node that is unresponsive. After sending this alert the waiter continues to wait. The alerts are logged in the system log as warnings and if a gfc is running will cause a console alert to be signalled.  Defaults to %s.  Legal values are in the range [%s..%s].",
+            DEFAULT_ACK_WAIT_THRESHOLD,
+            MIN_ACK_WAIT_THRESHOLD, MIN_ACK_WAIT_THRESHOLD));
-        LocalizedStrings.AbstractDistributionConfig_ARCHIVE_FILE_SIZE_LIMIT_NAME
-            .toLocalizedString());
+        "The maximum size in megabytes of a statistic archive file. Once this limit is exceeded, a new statistic archive file is created, and the current archive file becomes inactive. If set to zero, file size is unlimited.");
-        LocalizedStrings.AbstractDistributionConfig_ACK_SEVERE_ALERT_THRESHOLD_NAME
-            .toLocalizedString(new Object[] {ACK_WAIT_THRESHOLD,
-                Integer.valueOf(DEFAULT_ACK_SEVERE_ALERT_THRESHOLD),
-                Integer.valueOf(MIN_ACK_SEVERE_ALERT_THRESHOLD),
-                Integer.valueOf(MAX_ACK_SEVERE_ALERT_THRESHOLD)}));
+        String.format(
+            "The number of seconds a distributed message can wait for acknowledgment past %s before it ejects unresponsive members from the distributed system.  Defaults to %s.  Legal values are in the range [%s..%s].",
+            ACK_WAIT_THRESHOLD,
+            DEFAULT_ACK_SEVERE_ALERT_THRESHOLD,
+            MIN_ACK_SEVERE_ALERT_THRESHOLD,
+            MAX_ACK_SEVERE_ALERT_THRESHOLD));
-        LocalizedStrings.AbstractDistributionConfig_ARCHIVE_DISK_SPACE_LIMIT_NAME
-            .toLocalizedString());
+        "The maximum size in megabytes of all inactive statistic archive files combined. If this limit is exceeded, inactive archive files will be deleted, oldest first, until the total size is within the limit. If set to zero, disk space usage is unlimited.");
-    m.put(CACHE_XML_FILE, LocalizedStrings.AbstractDistributionConfig_CACHE_XML_FILE_NAME_0
-        .toLocalizedString(DEFAULT_CACHE_XML_FILE));
+    m.put(CACHE_XML_FILE, String.format(
+        "The file whose contents is used, by default, to initialize a cache if one is created.  Defaults to %s.",
+        DEFAULT_CACHE_XML_FILE));
-    m.put(DISABLE_TCP, LocalizedStrings.AbstractDistributionConfig_DISABLE_TCP_NAME_0
-        .toLocalizedString(Boolean.valueOf(DEFAULT_DISABLE_TCP)));
+    m.put(DISABLE_TCP, String.format(
+        "Determines whether TCP/IP communications will be disabled, forcing use of datagrams between members of the distributed system. Defaults to %s",
+        Boolean.FALSE));
-        LocalizedStrings.AbstractDistributionConfig_ENABLE_TIME_STATISTICS_NAME
-            .toLocalizedString());
+        "Turns on timings in distribution and cache statistics.  These are normally turned off to avoid expensive clock probes.");
-    m.put(DEPLOY_WORKING_DIR, LocalizedStrings.AbstractDistributionConfig_DEPLOY_WORKING_DIR_0
-        .toLocalizedString(DEFAULT_DEPLOY_WORKING_DIR));
+    m.put(DEPLOY_WORKING_DIR, String.format(
+        "The working directory that can be used to persist JARs deployed during runtime. Defaults to %s.",
+        DEFAULT_DEPLOY_WORKING_DIR));
-    m.put(LOG_FILE, LocalizedStrings.AbstractDistributionConfig_LOG_FILE_NAME_0
-        .toLocalizedString(DEFAULT_LOG_FILE));
+    m.put(LOG_FILE,
+        String.format("The file a running system will write log messages to.  Defaults to %s.",
+            DEFAULT_LOG_FILE));
-        LocalizedStrings.AbstractDistributionConfig_LOG_LEVEL_NAME_0_1
-            .toLocalizedString(new Object[] {LogWriterImpl.levelToString(DEFAULT_LOG_LEVEL),
-                LogWriterImpl.allowedLogLevels()}));
+        String.format(
+            "Controls the type of messages that will actually be written to the system log.  Defaults to %s.  Allowed values %s.",
+            LogWriterImpl.levelToString(DEFAULT_LOG_LEVEL),
+            LogWriterImpl.allowedLogLevels()));
-        LocalizedStrings.AbstractDistributionConfig_LOG_FILE_SIZE_LIMIT_NAME.toLocalizedString());
+        "The maximum size in megabytes of a child log file. Once this limit is exceeded, a new child log is created, and the current child log becomes inactive. If set to zero, child logging is disabled.");
-        LocalizedStrings.AbstractDistributionConfig_LOG_DISK_SPACE_LIMIT_NAME.toLocalizedString());
+        "The maximum size in megabytes of all inactive log files combined. If this limit is exceeded, inactive log files will be deleted, oldest first, until the total size is within the limit. If set to zero, disk space usage is unlimited.");
-    m.put(LOCATORS, LocalizedStrings.AbstractDistributionConfig_LOCATORS_NAME_0
-        .toLocalizedString(DEFAULT_LOCATORS));
+    m.put(LOCATORS, String.format(
+        "A possibly empty list of locators used to find other system nodes. Each element of the list must be a host name followed by bracketed, [], port number. Host names may be followed by a colon and a bind address used by the locator on that host.  Multiple elements must be comma separated. Defaults to %s.",
+        DEFAULT_LOCATORS));
-    m.put(LOCATOR_WAIT_TIME, LocalizedStrings.AbstractDistributionConfig_LOCATOR_WAIT_TIME_NAME_0
-        .toLocalizedString(Integer.valueOf(DEFAULT_LOCATOR_WAIT_TIME)));
+    m.put(LOCATOR_WAIT_TIME, String.format(
+        "The amount of time, in seconds, to wait for a locator to be available before throwing an exception during startup.  The default is %s.",
+        DEFAULT_LOCATOR_WAIT_TIME));
-        LocalizedStrings.AbstractDistributionConfig_TCP_PORT_NAME_0_1_2
-            .toLocalizedString(new Object[] {Integer.valueOf(DEFAULT_TCP_PORT),
-                Integer.valueOf(MIN_TCP_PORT), Integer.valueOf(MAX_TCP_PORT)}));
+        String.format(
+            "The port used for tcp/ip communcations in the distributed system. If zero then a random available port is selected by the operating system.   Defaults to %s.  Legal values are in the range [%s..%s].",
+            DEFAULT_TCP_PORT,
+            MIN_TCP_PORT, MAX_TCP_PORT));
-        LocalizedStrings.AbstractDistributionConfig_MCAST_PORT_NAME_0_1_2
-            .toLocalizedString(new Object[] {Integer.valueOf(DEFAULT_MCAST_PORT),
-                Integer.valueOf(MIN_MCAST_PORT), Integer.valueOf(MAX_MCAST_PORT)}));
+        String.format(
+            "The port used for multicast communcations in the distributed system. If zero then locators are used, and multicast is disabled.   Defaults to %s.  Legal values are in the range [%s..%s].",
+            DEFAULT_MCAST_PORT,
+            MIN_MCAST_PORT, MAX_MCAST_PORT));
-        LocalizedStrings.AbstractDistributionConfig_MCAST_ADDRESS_NAME_0_1.toLocalizedString(
-            new Object[] {Integer.valueOf(DEFAULT_MCAST_PORT), DEFAULT_MCAST_ADDRESS}));
+        String.format(
+            "The address used for multicast communications. Only used if %s is non-zero.  Defaults to %s.",
+            DEFAULT_MCAST_PORT, DEFAULT_MCAST_ADDRESS));
-        LocalizedStrings.AbstractDistributionConfig_MCAST_TTL_NAME_0_1_2
-            .toLocalizedString(new Object[] {Integer.valueOf(DEFAULT_MCAST_TTL),
-                Integer.valueOf(MIN_MCAST_TTL), Integer.valueOf(MAX_MCAST_TTL)}));
+        String.format(
+            "Determines how far through your network mulicast packets will propogate. Defaults to %s.  Legal values are in the range [%s..%s].",
+            DEFAULT_MCAST_TTL,
+            MIN_MCAST_TTL, MAX_MCAST_TTL));
-        LocalizedStrings.AbstractDistributionConfig_MCAST_SEND_BUFFER_SIZE_NAME_0
-            .toLocalizedString(Integer.valueOf(DEFAULT_MCAST_SEND_BUFFER_SIZE)));
+        String.format(
+            "Sets the size of multicast socket transmission buffers, in bytes.  Defaults to %s but this may be limited by operating system settings",
+            DEFAULT_MCAST_SEND_BUFFER_SIZE));
-        LocalizedStrings.AbstractDistributionConfig_MCAST_RECV_BUFFER_SIZE_NAME_0
-            .toLocalizedString(Integer.valueOf(DEFAULT_MCAST_RECV_BUFFER_SIZE)));
+        String.format(
+            "Sets the size of multicast socket receive buffers, in bytes.  Defaults to %s but this may be limited by operating system settings",
+            DEFAULT_MCAST_RECV_BUFFER_SIZE));
-    m.put(MCAST_FLOW_CONTROL, LocalizedStrings.AbstractDistributionConfig_MCAST_FLOW_CONTROL_NAME_0
-        .toLocalizedString(DEFAULT_MCAST_FLOW_CONTROL));
+    m.put(MCAST_FLOW_CONTROL, String.format(
+        "Sets the flow-of-control parameters for multicast messaging.  Defaults to %s.",
+        DEFAULT_MCAST_FLOW_CONTROL));
-    m.put(MEMBER_TIMEOUT, LocalizedStrings.AbstractDistributionConfig_MEMBER_TIMEOUT_NAME_0
-        .toLocalizedString(Integer.valueOf(DEFAULT_MEMBER_TIMEOUT)));
+    m.put(MEMBER_TIMEOUT, String.format(
+        "Sets the number of milliseconds to wait for ping responses when determining whether another member is still alive. Defaults to %s.",
+        DEFAULT_MEMBER_TIMEOUT));
-    String msg = LocalizedStrings.AbstractDistributionConfig_MEMBERSHIP_PORT_RANGE_NAME_0
-        .toLocalizedString(srange);
+    String msg = String.format(
+        "Sets the range of datagram socket ports that can be used for membership ID purposes and unicast datagram messaging. Defaults to %s.",
+        srange);
-        LocalizedStrings.AbstractDistributionConfig_UDP_SEND_BUFFER_SIZE_NAME_0
-            .toLocalizedString(Integer.valueOf(DEFAULT_UDP_SEND_BUFFER_SIZE)));
+        String.format(
+            "Sets the size of datagram socket transmission buffers, in bytes.  Defaults to %s but this may be limited by operating system settings",
+            DEFAULT_UDP_SEND_BUFFER_SIZE));
-        LocalizedStrings.AbstractDistributionConfig_UDP_RECV_BUFFER_SIZE_NAME_0
-            .toLocalizedString(Integer.valueOf(DEFAULT_UDP_RECV_BUFFER_SIZE)));
+        String.format(
+            "Sets the size of datagram socket receive buffers, in bytes. Defaults to %s but this may be limited by operating system settings",
+            DEFAULT_UDP_RECV_BUFFER_SIZE));
-    m.put(UDP_FRAGMENT_SIZE, LocalizedStrings.AbstractDistributionConfig_UDP_FRAGMENT_SIZE_NAME_0
-        .toLocalizedString(Integer.valueOf(DEFAULT_UDP_FRAGMENT_SIZE)));
+    m.put(UDP_FRAGMENT_SIZE, String.format(
+        "Sets the maximum size of a datagram for UDP and multicast transmission.  Defaults to %s.",
+        DEFAULT_UDP_FRAGMENT_SIZE));
-        LocalizedStrings.AbstractDistributionConfig_SOCKET_LEASE_TIME_NAME_0_1_2
-            .toLocalizedString(new Object[] {Integer.valueOf(DEFAULT_SOCKET_LEASE_TIME),
-                Integer.valueOf(MIN_SOCKET_LEASE_TIME), Integer.valueOf(MAX_SOCKET_LEASE_TIME)}));
+        String.format(
+            "The number of milliseconds a thread can keep exclusive access to a socket that it is not actively using. Once a thread loses its lease to a socket it will need to re-acquire a socket the next time it sends a message. A value of zero causes socket leases to never expire. Defaults to %s .  Legal values are in the range [%s..%s].",
+            DEFAULT_SOCKET_LEASE_TIME,
+            MIN_SOCKET_LEASE_TIME, MAX_SOCKET_LEASE_TIME));
-        LocalizedStrings.AbstractDistributionConfig_SOCKET_BUFFER_SIZE_NAME_0_1_2
-            .toLocalizedString(new Object[] {Integer.valueOf(DEFAULT_SOCKET_BUFFER_SIZE),
-                Integer.valueOf(MIN_SOCKET_BUFFER_SIZE), Integer.valueOf(MAX_SOCKET_BUFFER_SIZE)}));
+        String.format(
+            "The size of each socket buffer, in bytes. Smaller buffers conserve memory. Larger buffers can improve performance; in particular if large messages are being sent. Defaults to %s.  Legal values are in the range [%s..%s].",
+            DEFAULT_SOCKET_BUFFER_SIZE,
+            MIN_SOCKET_BUFFER_SIZE, MAX_SOCKET_BUFFER_SIZE));
-    m.put(CONSERVE_SOCKETS, LocalizedStrings.AbstractDistributionConfig_CONSERVE_SOCKETS_NAME_0
-        .toLocalizedString(Boolean.valueOf(DEFAULT_CONSERVE_SOCKETS)));
+    m.put(CONSERVE_SOCKETS, String.format(
+        "If true then a minimal number of sockets will be used when connecting to the distributed system. This conserves resource usage but can cause performance to suffer. If false, the default, then every application thread that sends distribution messages to other members of the distributed system will own its own sockets and have exclusive access to them. Defaults to %s.",
+        DEFAULT_CONSERVE_SOCKETS));
-        LocalizedStrings.AbstractDistributionConfig_ROLES_NAME_0.toLocalizedString(DEFAULT_ROLES));
+        String.format(
+            "The application roles that this member performs in the distributed system. This is a comma delimited list of user-defined strings. Any number of members can be configured to perform the same role, and a member can be configured to perform any number of roles. Defaults to %s.",
+            DEFAULT_ROLES));
-    m.put(BIND_ADDRESS, LocalizedStrings.AbstractDistributionConfig_BIND_ADDRESS_NAME_0
-        .toLocalizedString(DEFAULT_BIND_ADDRESS));
+    m.put(BIND_ADDRESS, String.format(
+        "The address server sockets will listen on. An empty string causes the server socket to listen on all local addresses. Defaults to %s.",
+        DEFAULT_BIND_ADDRESS));
-        LocalizedStrings.AbstractDistributionConfig_SERVER_BIND_ADDRESS_NAME_0
-            .toLocalizedString(DEFAULT_BIND_ADDRESS));
+        String.format(
+            "The address server sockets in a client-server topology will listen on. An empty string causes the server socket to listen on all local addresses. Defaults to %s.",
+            DEFAULT_BIND_ADDRESS));
-        LocalizedStrings.AbstractDistributionConfig_STATISTIC_ARCHIVE_FILE_NAME_0
-            .toLocalizedString(DEFAULT_STATISTIC_ARCHIVE_FILE));
+        String.format("The file a running system will write statistic samples to.  Defaults to %s.",
+            DEFAULT_STATISTIC_ARCHIVE_FILE));
-        LocalizedStrings.AbstractDistributionConfig_STATISTIC_SAMPLE_RATE_NAME_0_1_2
-            .toLocalizedString(new Object[] {Integer.valueOf(DEFAULT_STATISTIC_SAMPLE_RATE),
-                Integer.valueOf(MIN_STATISTIC_SAMPLE_RATE),
-                Integer.valueOf(MAX_STATISTIC_SAMPLE_RATE)}));
+        String.format(
+            "The rate, in milliseconds, that a running system will sample statistics.  Defaults to %s.  Legal values are in the range [%s..%s].",
+            DEFAULT_STATISTIC_SAMPLE_RATE,
+            MIN_STATISTIC_SAMPLE_RATE,
+            MAX_STATISTIC_SAMPLE_RATE));
-        LocalizedStrings.AbstractDistributionConfig_STATISTIC_SAMPLING_ENABLED_NAME_0
-            .toLocalizedString(Boolean.valueOf(DEFAULT_STATISTIC_SAMPLING_ENABLED)));
+        String.format(
+            "If false then archiving is disabled and operating system statistics are no longer updated.  Defaults to %s.",
+            Boolean.TRUE));
-    m.put(SSL_CLUSTER_ALIAS, LocalizedStrings.AbstractDistributionConfig_CLUSTER_SSL_ALIAS_0
-        .toLocalizedString(Boolean.valueOf(DEFAULT_SSL_ALIAS)));
+    m.put(SSL_CLUSTER_ALIAS, String.format(
+        "SSL communication uses the this alias when determining the key to use from the keystore for SSL. Defaults to %s.",
+        Boolean.valueOf(DEFAULT_SSL_ALIAS)));
-    m.put(CLUSTER_SSL_ENABLED, LocalizedStrings.AbstractDistributionConfig_SSL_ENABLED_NAME_0
-        .toLocalizedString(Boolean.valueOf(DEFAULT_SSL_ENABLED)));
+    m.put(CLUSTER_SSL_ENABLED, String.format(
+        "Communication is performed through SSL when this property is set to true. Defaults to %s.",
+        Boolean.FALSE));
-    m.put(CLUSTER_SSL_PROTOCOLS, LocalizedStrings.AbstractDistributionConfig_SSL_PROTOCOLS_NAME_0
-        .toLocalizedString(DEFAULT_SSL_PROTOCOLS));
+    m.put(CLUSTER_SSL_PROTOCOLS, String.format(
+        "List of available SSL protocols that are to be enabled. Defaults to %s meaning your provider's defaults.",
+        DEFAULT_SSL_PROTOCOLS));
-    m.put(CLUSTER_SSL_CIPHERS, LocalizedStrings.AbstractDistributionConfig_SSL_CIPHERS_NAME_0
-        .toLocalizedString(DEFAULT_SSL_CIPHERS));
+    m.put(CLUSTER_SSL_CIPHERS, String.format(
+        "List of available SSL cipher suites that are to be enabled. Defaults to %s meaning your provider's defaults.",
+        DEFAULT_SSL_CIPHERS));
-        LocalizedStrings.AbstractDistributionConfig_SSL_REQUIRE_AUTHENTICATION_NAME
-            .toLocalizedString(Boolean.valueOf(DEFAULT_SSL_REQUIRE_AUTHENTICATION)));
+        String.format(
+            "if set to false, ciphers and protocols that permit anonymous peers are allowed. Defaults to %s.",
+            Boolean.TRUE));
-        LocalizedStrings.AbstractDistributionConfig_MAX_WAIT_TIME_FOR_RECONNECT
-            .toLocalizedString());
+        "Specifies the maximum time to wait before trying to reconnect to distributed system in the case of required role loss.");
-        LocalizedStrings.AbstractDistributionConfig_MAX_NUM_RECONNECT_TRIES.toLocalizedString());
+        "Maximum number of tries before shutting the member down in the case of required role loss.");
-        LocalizedStrings.AbstractDistributionConfig_ASYNC_DISTRIBUTION_TIMEOUT_NAME_0_1_2
-            .toLocalizedString(new Object[] {Integer.valueOf(DEFAULT_ASYNC_DISTRIBUTION_TIMEOUT),
-                Integer.valueOf(MIN_ASYNC_DISTRIBUTION_TIMEOUT),
-                Integer.valueOf(MAX_ASYNC_DISTRIBUTION_TIMEOUT)}));
-
+        String.format(
+            "The number of milliseconds before a publishing process should attempt to distribute a cache operation before switching over to asynchronous messaging for this process. Defaults to %s. Legal values are in the range [%s..%s].",
+            DEFAULT_ASYNC_DISTRIBUTION_TIMEOUT,
+            MIN_ASYNC_DISTRIBUTION_TIMEOUT,
+            MAX_ASYNC_DISTRIBUTION_TIMEOUT));
-        LocalizedStrings.AbstractDistributionConfig_ASYNC_QUEUE_TIMEOUT_NAME_0_1_2
-            .toLocalizedString(new Object[] {Integer.valueOf(DEFAULT_ASYNC_QUEUE_TIMEOUT),
-                Integer.valueOf(MIN_ASYNC_QUEUE_TIMEOUT),
-                Integer.valueOf(MAX_ASYNC_QUEUE_TIMEOUT)}));
+        String.format(
+            "The number of milliseconds a queuing may enqueue asynchronous messages without any distribution to this process before that publisher requests this process to depart. Defaults to %s Legal values are in the range [%s..%s].",
+            DEFAULT_ASYNC_QUEUE_TIMEOUT,
+            MIN_ASYNC_QUEUE_TIMEOUT,
+            MAX_ASYNC_QUEUE_TIMEOUT));
-        LocalizedStrings.AbstractDistributionConfig_ASYNC_MAX_QUEUE_SIZE_NAME_0_1_2
-            .toLocalizedString(new Object[] {Integer.valueOf(DEFAULT_ASYNC_MAX_QUEUE_SIZE),
-                Integer.valueOf(MIN_ASYNC_MAX_QUEUE_SIZE),
-                Integer.valueOf(MAX_ASYNC_MAX_QUEUE_SIZE)}));
+        String.format(
+            "The maximum size in megabytes that a publishing process should be allowed to asynchronously enqueue for this process before asking this process to depart from the distributed system. Defaults to %s. Legal values are in the range [%s..%s].",
+            DEFAULT_ASYNC_MAX_QUEUE_SIZE,
+            MIN_ASYNC_MAX_QUEUE_SIZE,
+            MAX_ASYNC_MAX_QUEUE_SIZE));
-        LocalizedStrings.AbstractDistributionConfig_START_LOCATOR_NAME.toLocalizedString());
+        "The host|bindAddress[port] of a Locator to start in this VM along with the DistributedSystem. The default is to not start a Locator.");
-    m.put(DURABLE_CLIENT_ID, LocalizedStrings.AbstractDistributionConfig_DURABLE_CLIENT_ID_NAME_0
-        .toLocalizedString(DEFAULT_DURABLE_CLIENT_ID));
+    m.put(DURABLE_CLIENT_ID, String.format(
+        "An id used by durable clients to identify themselves as durable to servers. Defaults to %s.",
+        DEFAULT_DURABLE_CLIENT_ID));
-    m.put(CONFLATE_EVENTS, LocalizedStrings.AbstractDistributionConfig_CLIENT_CONFLATION_PROP_NAME
-        .toLocalizedString());
+    m.put(CONFLATE_EVENTS, "Client override for server queue conflation setting");
-        LocalizedStrings.AbstractDistributionConfig_DURABLE_CLIENT_TIMEOUT_NAME_0
-            .toLocalizedString(Integer.valueOf(DEFAULT_DURABLE_CLIENT_TIMEOUT)));
+        String.format(
+            "The value (in seconds) used by the server to keep disconnected durable clients alive. Defaults to %s.",
+            DEFAULT_DURABLE_CLIENT_TIMEOUT));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_CLIENT_AUTH_INIT_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_CLIENT_AUTH_INIT));
+        String.format(
+            "User defined fully qualified method name implementing AuthInitialize interface for client. Defaults to %s. Legal values can be any method name of a static method that is present in the classpath.",
+            DEFAULT_SECURITY_CLIENT_AUTH_INIT));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_CLIENT_AUTHENTICATOR_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_CLIENT_AUTHENTICATOR));
+        String.format(
+            "User defined fully qualified method name implementing Authenticator interface for client verification. Defaults to %s. Legal values can be any method name of a static method that is present in the classpath.",
+            DEFAULT_SECURITY_CLIENT_AUTHENTICATOR));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_CLIENT_DHALGO_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_CLIENT_DHALGO));
+        String.format(
+            "User defined name for the symmetric encryption algorithm to use in Diffie-Hellman key exchange for encryption of credentials.  Defaults to %s. Legal values can be any of the available symmetric algorithm names in JDK like DES, DESede, AES, Blowfish. It may be required to install Unlimited Strength Jurisdiction Policy Files from Sun for some symmetric algorithms to work (like AES)",
+            DEFAULT_SECURITY_CLIENT_DHALGO));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_UDP_DHALGO_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_UDP_DHALGO));
+        String.format(
+            "User defined name for the symmetric encryption algorithm to use in Diffie-Hellman key exchange for encryption of udp messages.  Defaults to %s. Legal values can be any of the available symmetric algorithm names in JDK like DES, DESede, AES, Blowfish. It may be required to install Unlimited Strength Jurisdiction Policy Files from Sun for some symmetric algorithms to work (like AES)",
+            DEFAULT_SECURITY_UDP_DHALGO));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_PEER_AUTH_INIT_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_PEER_AUTH_INIT));
+        String.format(
+            "User defined fully qualified method name implementing AuthInitialize interface for peer. Defaults to %s. Legal values can be any method name of a static method that is present in the classpath.",
+            DEFAULT_SECURITY_PEER_AUTH_INIT));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_PEER_AUTHENTICATOR_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_PEER_AUTHENTICATOR));
+        String.format(
+            "User defined fully qualified method name implementing Authenticator interface for peer verificaiton. Defaults to %s. Legal values can be any method name of a static method that is present in the classpath.",
+            DEFAULT_SECURITY_PEER_AUTHENTICATOR));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_CLIENT_ACCESSOR_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_CLIENT_ACCESSOR));
+        String.format(
+            "User defined fully qualified method name implementing AccessControl interface for client authorization. Defaults to %s. Legal values can be any method name of a static method that is present in the classpath.",
+            DEFAULT_SECURITY_CLIENT_ACCESSOR));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_CLIENT_ACCESSOR_PP_NAME_0
-            .toLocalizedString(DEFAULT_SECURITY_CLIENT_ACCESSOR_PP));
+        String.format(
+            "User defined fully qualified method name implementing AccessControl interface for client authorization in post-processing phase. Defaults to %s. Legal values can be any method name of a static method that is present in the classpath.",
+            DEFAULT_SECURITY_CLIENT_ACCESSOR_PP));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_LOG_LEVEL_NAME_0_1
-            .toLocalizedString(new Object[] {LogWriterImpl.levelToString(DEFAULT_LOG_LEVEL),
-                LogWriterImpl.allowedLogLevels()}));
+        String.format(
+            "Controls the type of messages that will actually be written to the system security log. Defaults to %s.  Allowed values %s.",
+            LogWriterImpl.levelToString(DEFAULT_LOG_LEVEL),
+            LogWriterImpl.allowedLogLevels()));
-    m.put(SECURITY_LOG_FILE, LocalizedStrings.AbstractDistributionConfig_SECURITY_LOG_FILE_NAME_0
-        .toLocalizedString(DEFAULT_SECURITY_LOG_FILE));
+    m.put(SECURITY_LOG_FILE, String.format(
+        "The file a running system will write security log messages to. Defaults to %s.",
+        DEFAULT_SECURITY_LOG_FILE));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_PEER_VERIFYMEMBER_TIMEOUT_NAME_0
-            .toLocalizedString(Integer.valueOf(DEFAULT_SECURITY_PEER_VERIFYMEMBER_TIMEOUT)));
+        String.format(
+            "The timeout value (in milliseconds) used by a peer to verify membership of an unknown authenticated peer requesting a secure connection. Defaults to %s milliseconds. The timeout value should not exceed peer handshake timeout.",
+            DEFAULT_SECURITY_PEER_VERIFYMEMBER_TIMEOUT));
-        LocalizedStrings.AbstractDistributionConfig_SECURITY_PREFIX_NAME.toLocalizedString());
+        "Prefix for security related properties which are packed together and invoked as authentication parameter. Neither key nor value can be NULL. Legal tags can be [security-username, security-digitalid] and Legal values can be any string data.");
-        LocalizedStrings.AbstractDistributionConfig_USERDEFINED_PREFIX_NAME.toLocalizedString());
+        "Prefix for user defined properties which are used for replacements in Cache.xml. Neither key nor value can be NULL. Legal tags can be [custom-any-string] and Legal values can be any string data.");
-        LocalizedStrings.AbstractDistributionConfig_REMOVE_UNRESPONSIVE_CLIENT_PROP_NAME_0
-            .toLocalizedString(DEFAULT_REMOVE_UNRESPONSIVE_CLIENT));
+        String.format("Whether to remove unresponsive client or not. Defaults to %s.",
+            DEFAULT_REMOVE_UNRESPONSIVE_CLIENT));
-        LocalizedStrings.AbstractDistributionConfig_REMOTE_DISTRIBUTED_SYSTEMS_NAME_0
-            .toLocalizedString(DEFAULT_REMOTE_LOCATORS));
+        String.format(
+            "A possibly empty list of locators used to find other distributed systems. Each element of the list must be a host name followed by bracketed, [], port number. Host names may be followed by a colon and a bind address used by the locator on that host.  Multiple elements must be comma separated. Defaults to %s.",
+            DEFAULT_REMOTE_LOCATORS));
-    m.put(SSL_JMX_ALIAS, LocalizedStrings.AbstractDistributionConfig_JMX_MANAGER_SSL_ALIAS_0
-        .toLocalizedString(Boolean.valueOf(DEFAULT_SSL_ALIAS)));
+    m.put(SSL_JMX_ALIAS, String.format(
+        "SSL jmx communication uses the this alias when determining the key to use from the keystore for SSL. Defaults to %s.",
+        Boolean.valueOf(DEFAULT_SSL_ALIAS)));
-            + DEFAULT_JMX_MANAGER_SSL_CIPHERS + "\" meaning your provider''s defaults.");
+            + DEFAULT_JMX_MANAGER_SSL_CIPHERS + "\" meaning your provider's defaults.");
-    m.put(SSL_LOCATOR_ALIAS, LocalizedStrings.AbstractDistributionConfig_LOCATOR_SSL_ALIAS_0
-        .toLocalizedString(Boolean.valueOf(DEFAULT_SSL_ALIAS)));
+    m.put(SSL_LOCATOR_ALIAS, String.format(
+        "SSL locator communications uses this alias when determining the key to use from the keystore for SSL. Defaults to %s.",
+        Boolean.valueOf(DEFAULT_SSL_ALIAS)));
-        LocalizedStrings.AbstractDistributionConfig_ENABLE_SHARED_CONFIGURATION
-            .toLocalizedString());
+        "Enables cluster configuration support in dedicated locators.  This allows the locator to share configuration information amongst members and save configuration changes made using GFSH.");
-        LocalizedStrings.AbstractDistributionConfig_USE_SHARED_CONFIGURATION.toLocalizedString());
+        "Boolean flag that allows the cache to use the cluster configuration provided by the cluster config service");
-        LocalizedStrings.AbstractDistributionConfig_LOAD_SHARED_CONFIGURATION_FROM_DIR
-            .toLocalizedString(
-                InternalConfigurationPersistenceService.CLUSTER_CONFIG_ARTIFACTS_DIR_NAME));
+        String.format(
+            "Loads cluster configuration from the %s directory of a locator. This is property is only applicable to the locator(s)",
+
+            InternalConfigurationPersistenceService.CLUSTER_CONFIG_ARTIFACTS_DIR_NAME));
-        LocalizedStrings.AbstractDistributionConfig_CLUSTER_CONFIGURATION_DIR.toLocalizedString());
-    m.put(SSL_SERVER_ALIAS, LocalizedStrings.AbstractDistributionConfig_SERVER_SSL_ALIAS_0
-        .toLocalizedString(Boolean.valueOf(DEFAULT_SSL_ALIAS)));
+        "The directory to store the cluster configuration artifacts and disk-store. This property is only applicable to the locator(s)");
+    m.put(SSL_SERVER_ALIAS, String.format(
+        "SSL inter-server communication (peer-to-peer) uses the this alias when determining the key to use from the keystore for SSL. Defaults to %s.",
+        Boolean.valueOf(DEFAULT_SSL_ALIAS)));
-            + DEFAULT_SERVER_SSL_CIPHERS + "\" meaning your provider''s defaults.");
+            + DEFAULT_SERVER_SSL_CIPHERS + "\" meaning your provider's defaults.");
-    m.put(SSL_GATEWAY_ALIAS, LocalizedStrings.AbstractDistributionConfig_GATEWAY_SSL_ALIAS_0
-        .toLocalizedString(Boolean.valueOf(DEFAULT_SSL_ALIAS)));
+    m.put(SSL_GATEWAY_ALIAS, String.format(
+        "SSL gateway communication uses the this alias when determining the key to use from the keystore for SSL. Defaults to %s.",
+        Boolean.valueOf(DEFAULT_SSL_ALIAS)));
-            + DEFAULT_GATEWAY_SSL_CIPHERS + "\" meaning your provider''s defaults.");
+            + DEFAULT_GATEWAY_SSL_CIPHERS + "\" meaning your provider's defaults.");
-    m.put(SSL_WEB_ALIAS, LocalizedStrings.AbstractDistributionConfig_HTTP_SERVICE_SSL_ALIAS_0
-        .toLocalizedString(Boolean.valueOf(DEFAULT_SSL_ALIAS)));
+    m.put(SSL_WEB_ALIAS, String.format(
+        "SSL http service communication uses the this alias when determining the key to use from the keystore for SSL. Defaults to %s.",
+        Boolean.valueOf(DEFAULT_SSL_ALIAS)));
-            + DEFAULT_HTTP_SERVICE_SSL_CIPHERS + "\" meaning your provider''s defaults.");
+            + DEFAULT_HTTP_SERVICE_SSL_CIPHERS + "\" meaning your provider's defaults.");
-    m.put(OFF_HEAP_MEMORY_SIZE, LocalizedStrings.AbstractDistributionConfig_OFF_HEAP_MEMORY_SIZE_0
-        .toLocalizedString(DEFAULT_OFF_HEAP_MEMORY_SIZE));
-    m.put(LOCK_MEMORY, LocalizedStrings.AbstractDistributionConfig_LOCK_MEMORY
-        .toLocalizedString(DEFAULT_LOCK_MEMORY));
+    m.put(OFF_HEAP_MEMORY_SIZE, String.format(
+        "The amount of off-heap memory to be allocated for GemFire. Value is <n>[g|m], where <n> is the size and [g|m] specifies the units in gigabytes or megabytes. Defaults to %s.",
+        DEFAULT_OFF_HEAP_MEMORY_SIZE));
+    m.put(LOCK_MEMORY, String.format(
+        "Locks heap and off-heap memory pages into RAM, thereby preventing the operating system from swapping them out to disk. Defaults to %s",
+        DEFAULT_LOCK_MEMORY));
-        "If true, clients validate server hostname using server certificate during SSL handshake.");
+        "If true, clients validate server hostname using server certificate during SSL handshake. It defaults to true when ssl-use-default-context is true or else false.");
+
+    m.put(SSL_USE_DEFAULT_CONTEXT,
+        "When true, either uses the default context as returned by SSLContext.getInstance('Default') or uses the context as set by using SSLContext.setDefault(). "
+            + "If false, then specify the keystore and the truststore by setting ssl-keystore-* and ssl-truststore-* properties. If true, then ssl-endpoint-identification-enabled is set to true. This property does not enable SSL.");
-        + DEFAULT_SSL_CIPHERS + "\" meaning your provider''s defaults.");
+        + DEFAULT_SSL_CIPHERS + "\" meaning your provider's defaults.");
-        LocalizedStrings.AbstractDistributionConfig_THREAD_MONITOR_INTERVAL.toLocalizedString());
+        "Defines the time interval (in milliseconds) with which thread monitoring is scheduled to run.");
-        LocalizedStrings.AbstractDistributionConfig_THREAD_MONITOR_ENABLED.toLocalizedString());
+        "Defines whether thread monitoring is to be enabled.");
-        LocalizedStrings.AbstractDistributionConfig_THREAD_MONITOR_TIME_LIMIT.toLocalizedString());
+        "Defines the time period (in milliseconds) after which the monitored thread is considered to be stuck.");
-
+  @Override
+  @Override
-  public static InetAddress _getDefaultMcastAddress() {
+  static InetAddress _getDefaultMcastAddress() {
-    String ipLiteral = "239.192.81.1";
+      String ipLiteral = "239.192.81.1";
-          LocalizedStrings.AbstractDistributionConfig_UNEXPECTED_PROBLEM_GETTING_INETADDRESS_0
-              .toLocalizedString(ex),
+          String.format("Unexpected problem getting inetAddress: %s",
+              ex),
-  /****************************
-   * static initializers to gather all the checkers in this class
-   *************************/
-  static final Map<String, Method> checkers = new HashMap<String, Method>();
+  static final Map<String, Method> checkers = new HashMap<>();

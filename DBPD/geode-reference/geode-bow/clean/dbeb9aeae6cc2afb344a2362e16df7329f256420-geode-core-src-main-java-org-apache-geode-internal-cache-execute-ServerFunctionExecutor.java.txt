Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import org.apache.geode.internal.cache.execute.util.SynchronizedResultCollector;
+
-  
+
-    this.pool = (PoolImpl)p;
+    this.pool = (PoolImpl) p;
-  public ServerFunctionExecutor(Pool p, boolean allServers, ProxyCache proxyCache, String... groups) {
-    this.pool = (PoolImpl)p;
+  public ServerFunctionExecutor(Pool p, boolean allServers, ProxyCache proxyCache,
+      String... groups) {
+    this.pool = (PoolImpl) p;
-  
+
-  
-  private ServerFunctionExecutor(ServerFunctionExecutor sfe,Object args) {
+
+  private ServerFunctionExecutor(ServerFunctionExecutor sfe, Object args) {
-  
-  private ServerFunctionExecutor(ServerFunctionExecutor sfe, ResultCollector rs) {
+
+  private ServerFunctionExecutor(ServerFunctionExecutor sfe, ResultCollector collector) {
-    this.rc = rs;
+    this.rc = collector != null ? new SynchronizedResultCollector(collector) : collector;
-  
+
-  
-  protected ResultCollector executeFunction(final String functionId, boolean result, boolean isHA, boolean optimizeForWrite) {
+
+  protected ResultCollector executeFunction(final String functionId, boolean result, boolean isHA,
+      boolean optimizeForWrite) {
-    byte hasResult = 0;
-    if (result) { // have Results
-      hasResult = 1;
-      if (this.rc == null) { // Default Result Collector
-        ResultCollector defaultCollector = new DefaultResultCollector();
-        return executeOnServer(functionId, defaultCollector, hasResult, isHA, optimizeForWrite);
+      byte hasResult = 0;
+      if (result) { // have Results
+        hasResult = 1;
+        if (this.rc == null) { // Default Result Collector
+          ResultCollector defaultCollector = new DefaultResultCollector();
+          return executeOnServer(functionId, defaultCollector, hasResult, isHA, optimizeForWrite);
+        } else { // Custome Result COllector
+          return executeOnServer(functionId, this.rc, hasResult, isHA, optimizeForWrite);
+        }
+      } else { // No results
+        executeOnServerNoAck(functionId, hasResult, isHA, optimizeForWrite);
+        return new NoResult();
-      else { // Custome Result COllector
-        return executeOnServer(functionId, this.rc, hasResult, isHA, optimizeForWrite);
-      }
-    }
-    else { // No results
-      executeOnServerNoAck(functionId, hasResult, isHA, optimizeForWrite);
-      return new NoResult();
-    }
-        }
-        else { // Custome Result COllector
+        } else { // Custome Result COllector
-      }
-      else { // No results
+      } else { // No results
-    }
-    finally {
+    } finally {
-  private ResultCollector executeOnServer(Function function,
-      ResultCollector rc, byte hasResult) {
+  private ResultCollector executeOnServer(Function function, ResultCollector rc, byte hasResult) {
-      ExecuteFunctionOp.execute(this.pool, function, this, args, memberMappedArg,
-          this.allServers, hasResult, rc, this.isFnSerializationReqd,
-          UserAttributes.userAttributes.get(), groups);
+      ExecuteFunctionOp.execute(this.pool, function, this, args, memberMappedArg, this.allServers,
+          hasResult, rc, this.isFnSerializationReqd, UserAttributes.userAttributes.get(), groups);
-    }
-    catch(FunctionException functionException){
+    } catch (FunctionException functionException) {
-    }
-    catch(ServerConnectivityException exception){
+    } catch (ServerConnectivityException exception) {
-    }
-    catch (Exception exception) {
+    } catch (Exception exception) {
-  
-  private ResultCollector executeOnServer(String functionId,
-      ResultCollector rc, byte hasResult, boolean isHA, boolean optimizeForWrite) {
+
+  private ResultCollector executeOnServer(String functionId, ResultCollector rc, byte hasResult,
+      boolean isHA, boolean optimizeForWrite) {
-      ExecuteFunctionOp.execute(this.pool, functionId,this, args, memberMappedArg,
-          this.allServers, hasResult, rc, this.isFnSerializationReqd, isHA, optimizeForWrite, UserAttributes.userAttributes.get(), groups);
+      ExecuteFunctionOp.execute(this.pool, functionId, this, args, memberMappedArg, this.allServers,
+          hasResult, rc, this.isFnSerializationReqd, isHA, optimizeForWrite,
+          UserAttributes.userAttributes.get(), groups);
-    }
-    catch(FunctionException functionException){
+    } catch (FunctionException functionException) {
-    }
-    catch(ServerConnectivityException exception){
+    } catch (ServerConnectivityException exception) {
-    }
-    catch (Exception exception) {
+    } catch (Exception exception) {
-      ExecuteFunctionNoAckOp.execute(this.pool, function, args,
-          memberMappedArg, this.allServers, hasResult, this.isFnSerializationReqd, groups);
+      ExecuteFunctionNoAckOp.execute(this.pool, function, args, memberMappedArg, this.allServers,
+          hasResult, this.isFnSerializationReqd, groups);
-    }
-    catch(FunctionException functionException){
+    } catch (FunctionException functionException) {
-    }
-    catch(ServerConnectivityException exception){
+    } catch (ServerConnectivityException exception) {
-    }
-    catch (Exception exception) {
+    } catch (Exception exception) {
-  private void executeOnServerNoAck(String functionId, byte hasResult,
-      boolean isHA, boolean optimizeForWrite) {
+  private void executeOnServerNoAck(String functionId, byte hasResult, boolean isHA,
+      boolean optimizeForWrite) {
-      ExecuteFunctionNoAckOp.execute(this.pool, functionId, args,
-          memberMappedArg, this.allServers, hasResult, this.isFnSerializationReqd, isHA, optimizeForWrite, groups);
+      ExecuteFunctionNoAckOp.execute(this.pool, functionId, args, memberMappedArg, this.allServers,
+          hasResult, this.isFnSerializationReqd, isHA, optimizeForWrite, groups);
-    }
-    catch(FunctionException functionException){
+    } catch (FunctionException functionException) {
-    }
-    catch(ServerConnectivityException exception){
+    } catch (ServerConnectivityException exception) {
-    }
-    catch (Exception exception) {
+    } catch (Exception exception) {
-  
+
-  
+
-      }
+    }
-  public InternalExecution withMemberMappedArgument(
-      MemberMappedArgument argument) {
+  public InternalExecution withMemberMappedArgument(MemberMappedArgument argument) {
-  /* (non-Javadoc)
-   * @see org.apache.geode.internal.cache.execute.AbstractExecution#validateExecution(org.apache.geode.cache.execute.Function, java.util.Set)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.internal.cache.execute.AbstractExecution#validateExecution(org.apache.geode.
+   * cache.execute.Function, java.util.Set)
-        functionAttributes = (byte[])obj;
+        functionAttributes = (byte[]) obj;
-    }
-    else {
+    } else {
-  public ResultCollector execute(String functionName, boolean hasResult)
-      throws FunctionException {
+  public ResultCollector execute(String functionName, boolean hasResult) throws FunctionException {
-      return executeFunction(functionName,hasResult, hasResult, false);   
-    }
-    else {
-      byte registeredFunctionState = AbstractExecution.getFunctionState(
-          functionObject.isHA(), functionObject.hasResult(), functionObject
-              .optimizeForWrite());
+      return executeFunction(functionName, hasResult, hasResult, false);
+    } else {
+      byte registeredFunctionState = AbstractExecution.getFunctionState(functionObject.isHA(),
+          functionObject.hasResult(), functionObject.optimizeForWrite());
-  
-  public ResultCollector execute(String functionName, boolean hasResult, boolean isHA) throws FunctionException {
+
+  public ResultCollector execute(String functionName, boolean hasResult, boolean isHA)
+      throws FunctionException {
-          LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH
-              .toLocalizedString());
+          LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH.toLocalizedString());
-      return executeFunction(functionName,hasResult, isHA, false);
-    }
-    else{
-      byte registeredFunctionState = AbstractExecution.getFunctionState(
-          functionObject.isHA(), functionObject.hasResult(), functionObject
-              .optimizeForWrite());
+      return executeFunction(functionName, hasResult, isHA, false);
+    } else {
+      byte registeredFunctionState = AbstractExecution.getFunctionState(functionObject.isHA(),
+          functionObject.hasResult(), functionObject.optimizeForWrite());
-  
-  public ResultCollector execute(String functionName, boolean hasResult, boolean isHA, boolean isOptimizeForWrite) throws FunctionException {
+
+  public ResultCollector execute(String functionName, boolean hasResult, boolean isHA,
+      boolean isOptimizeForWrite) throws FunctionException {
-          LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH
-              .toLocalizedString());
+          LocalizedStrings.FunctionService_FUNCTION_ATTRIBUTE_MISMATCH.toLocalizedString());
-      return executeFunction(functionName,hasResult, isHA, isOptimizeForWrite);
-    }
-    else {
-      byte registeredFunctionState = AbstractExecution.getFunctionState(
-          functionObject.isHA(), functionObject.hasResult(), functionObject
-              .optimizeForWrite());
+      return executeFunction(functionName, hasResult, isHA, isOptimizeForWrite);
+    } else {
+      byte registeredFunctionState = AbstractExecution.getFunctionState(functionObject.isHA(),
+          functionObject.hasResult(), functionObject.optimizeForWrite());
-      return executeFunction(functionObject);      
+      return executeFunction(functionObject);

GEODE-7729: Upgrades JNA to 5.5.0 (#4624)

* GEODE-7729: Upgrades JNA to 5.5.0

* Update Windows native APIs to use JNA Platform library to fix segfault.

* GEODE-7729: Cleanup comments, generics and other warnings.

* Deletes unused code.

+import static java.util.Arrays.asList;
+import static java.util.Collections.singletonList;
+
-import java.io.InputStream;
-import java.net.Socket;
-import java.net.SocketException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-import com.sun.jna.Library;
-import com.sun.jna.NativeLibrary;
-import com.sun.jna.NativeLong;
-import com.sun.jna.Pointer;
+import com.sun.jna.platform.win32.Kernel32;
+import com.sun.jna.platform.win32.WinBase;
+import com.sun.jna.platform.win32.WinNT.HANDLE;
-import com.sun.jna.win32.StdCallLibrary;
-    if (Platform.isSolaris()) {
-      return new SolarisNativeCalls();
-    }
-    if (Platform.isMac()) {
-      return new MacOSXNativeCalls();
-    }
-    if (Platform.isFreeBSD()) {
-      return new FreeBSDNativeCalls();
-    }
-    public static native int setenv(String name, String value, int overwrite)
-        throws LastErrorException;
-
-    public static native int unsetenv(String name) throws LastErrorException;
-
-    public static native int setsockopt(int sockfd, int level, int optName, IntByReference optVal,
-        int optSize) throws LastErrorException;
-
-    public static native int isatty(int fd) throws LastErrorException;
-
-    /**
-     * the {@link RehashServerOnSIGHUP} instance sent to {@link #daemonize}
-     */
-    /**
-     * @see NativeCalls#getOSType()
-     */
-    @Override
-    public OSType getOSType() {
-      return OSType.GENERIC_POSIX;
-    }
-
-    /**
-     * @see NativeCalls#getEnvironment(String)
-     */
-    /**
-     * @see NativeCalls#getProcessId()
-     */
-    /**
-     * @see NativeCalls#isProcessActive(int)
-     */
-    /**
-     * @see NativeCalls#killProcess(int)
-     */
-    /**
-     * {@inheritDoc}
-     */
+      @SuppressWarnings("OctalInteger")
-      if ((oldMask & 077) > newMask) {
+      @SuppressWarnings("OctalInteger")
+      final int OCTAL_077 = 077;
+      if ((oldMask & OCTAL_077) > newMask) {
-      this.rehashCallback = callback;
-      this.hupHandler = new SignalHandler() {
-        @Override
-        public void callback(int signum) {
-          // invoke the rehash function if provided
-          final RehashServerOnSIGHUP rehashCb = rehashCallback;
-          if (signum == Signal.SIGHUP.getNumber() && rehashCb != null) {
-            rehashCb.rehash();
-          }
+      rehashCallback = callback;
+      hupHandler = signum -> {
+        // invoke the rehash function if provided
+        final RehashServerOnSIGHUP rehashCb = rehashCallback;
+        if (signum == Signal.SIGHUP.getNumber() && rehashCb != null) {
+          rehashCb.rehash();
-      signal(Signal.SIGHUP.getNumber(), this.hupHandler);
+      signal(Signal.SIGHUP.getNumber(), hupHandler);
-      signal(Signal.SIGCHLD.getNumber(), this.hupHandler);
-      signal(Signal.SIGINT.getNumber(), this.hupHandler);
+      signal(Signal.SIGCHLD.getNumber(), hupHandler);
+      signal(Signal.SIGINT.getNumber(), hupHandler);
-        fd = createFD(path, 00644);
+        @SuppressWarnings("OctalInteger")
+        final int OCTAL_0644 = 00644;
+        fd = createFD(path, OCTAL_0644);
-          unknownError = false;
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Map<TCPSocketOptions, Throwable> setSocketOptions(Socket sock, InputStream sockStream,
-        Map<TCPSocketOptions, Object> optValueMap) throws UnsupportedOperationException {
-      return super.setGenericSocketOptions(sock, sockStream, optValueMap);
-    }
-
-    @Override
-    protected int setPlatformSocketOption(int sockfd, int level, int optName, TCPSocketOptions opt,
-        Integer optVal, int optSize) throws NativeErrorException {
-      try {
-        return setsockopt(sockfd, level, optName, new IntByReference(optVal.intValue()), optSize);
-      } catch (LastErrorException le) {
-        throw new NativeErrorException(le.getMessage(), le.getErrorCode(), le.getCause());
-      }
-    }
-
-    @Override
-    public boolean isTTY() {
-      try {
-        return isatty(0) == 1;
-      } catch (Exception e) {
-        throw new RuntimeException("Couldn't find tty impl. ", e);
-      }
-    }
-
-    // #define values for keepalive options in /usr/include/netinet/tcp.h
-    static final int OPT_TCP_KEEPIDLE = 4;
-    static final int OPT_TCP_KEEPINTVL = 5;
-    static final int OPT_TCP_KEEPCNT = 6;
-
-    static final int ENOPROTOOPT = 92;
-    static final int ENOPROTOOPT_ALPHA = 42;
-    static final int ENOPROTOOPT_MIPS = 99;
-    static final int ENOPROTOOPT_PARISC = 220;
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public OSType getOSType() {
-      return OSType.LINUX;
-    }
-
-    @Override
-    protected int getPlatformOption(TCPSocketOptions opt) throws UnsupportedOperationException {
-      switch (opt) {
-        case OPT_KEEPIDLE:
-          return OPT_TCP_KEEPIDLE;
-        case OPT_KEEPINTVL:
-          return OPT_TCP_KEEPINTVL;
-        case OPT_KEEPCNT:
-          return OPT_TCP_KEEPCNT;
-        default:
-          throw new UnsupportedOperationException("unknown option " + opt);
-      }
-    }
-
-    @Override
-    protected boolean isNoProtocolOptionCode(int errno) {
-      switch (errno) {
-        case ENOPROTOOPT:
-          return true;
-        case ENOPROTOOPT_ALPHA:
-          return true;
-        case ENOPROTOOPT_MIPS:
-          return true;
-        case ENOPROTOOPT_PARISC:
-          return true;
-        default:
-          return false;
-      }
-    }
-
-    private ThreadLocal<Structure> tSpecs = new ThreadLocal<Structure>();
-
+    @SuppressWarnings("unused")
-
-      protected List getFieldOrder() {
-        return Arrays.asList(new String[] {"fsid"});
+      protected List<String> getFieldOrder() {
+        return singletonList("fsid");
+    @SuppressWarnings("unused")
-
-      protected List getFieldOrder() {
-        return Arrays.asList(new String[] {"fspare"});
+      protected List<String> getFieldOrder() {
+        return singletonList("fspare");
+    @SuppressWarnings("unused")
-          if (ret == 0) {
-            isStatFSEnabled = true;
-          } else {
-            isStatFSEnabled = false;
-          }
+          isStatFSEnabled = ret == 0;
-      protected List getFieldOrder() {
-        return Arrays.asList(new String[] {"f_type", "f_bsize", "f_blocks", "f_bfree", "f_bavail",
-            "f_files", "f_ffree", "f_fsid", "f_namelen", "f_frsize", "f_spare"});
+      protected List<String> getFieldOrder() {
+        return asList("f_type", "f_bsize", "f_blocks", "f_bfree", "f_bavail",
+            "f_files", "f_ffree", "f_fsid", "f_namelen", "f_frsize", "f_spare");
-        for (int i = 0; i < REMOTE_TYPES.length; i++) {
-          if (REMOTE_TYPES[i] == f_type) {
+        for (int remoteType : REMOTE_TYPES) {
+          if (remoteType == f_type) {
+    @SuppressWarnings("unused")
-      protected List getFieldOrder() {
-        return Arrays.asList(new String[] {"fspare"});
+      protected List<String> getFieldOrder() {
+        return singletonList("fspare");
+    @SuppressWarnings("unused")
-          new long[] {4283649346l, 1937076805l, 22092l, 26985l, 20859l, 16914836l};
+          new long[] {4283649346L, 1937076805L, 22092L, 26985L, 20859L, 16914836L};
-          if (ret == 0) {
-            isStatFSEnabled = true;
-          } else {
-            isStatFSEnabled = false;
-          }
+          isStatFSEnabled = ret == 0;
-      protected List getFieldOrder() {
-        return Arrays.asList(new String[] {"f_type", "f_bsize", "f_blocks", "f_bfree", "f_bavail",
-            "f_files", "f_ffree", "f_fsid", "f_namelen", "f_frsize", "f_spare"});
+      protected List<String> getFieldOrder() {
+        return asList("f_type", "f_bsize", "f_blocks", "f_bfree", "f_bavail",
+            "f_files", "f_ffree", "f_fsid", "f_namelen", "f_frsize", "f_spare");
-        for (int i = 0; i < REMOTE_TYPES.length; i++) {
-          if (REMOTE_TYPES[i] == f_type) {
+        for (long remoteType : REMOTE_TYPES) {
+          if (remoteType == f_type) {
-   * Implementation of {@link NativeCalls} for Solaris platform.
-   */
-  private static class SolarisNativeCalls extends POSIXNativeCalls {
-
-    static {
-      Native.register("nsl");
-      Native.register("socket");
-    }
-
-    // #define values for keepalive options in /usr/include/netinet/tcp.h
-    // Below are only available on Solaris 11 and above but older platforms will
-    // throw an exception which higher layers will handle appropriately
-    static final int OPT_TCP_KEEPALIVE_THRESHOLD = 0x16;
-    static final int OPT_TCP_KEEPALIVE_ABORT_THRESHOLD = 0x17;
-
-    static final int ENOPROTOOPT = 99;
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public OSType getOSType() {
-      return OSType.SOLARIS;
-    }
-
-    @Override
-    protected int getPlatformOption(TCPSocketOptions opt) throws UnsupportedOperationException {
-      switch (opt) {
-        case OPT_KEEPIDLE:
-          return OPT_TCP_KEEPALIVE_THRESHOLD;
-        case OPT_KEEPINTVL:
-        case OPT_KEEPCNT:
-          return UNSUPPORTED_OPTION;
-        default:
-          throw new UnsupportedOperationException("unknown option " + opt);
-      }
-    }
-
-    @Override
-    protected int setPlatformSocketOption(int sockfd, int level, int optName, TCPSocketOptions opt,
-        Integer optVal, int optSize) throws NativeErrorException {
-      try {
-        switch (optName) {
-          case OPT_TCP_KEEPALIVE_THRESHOLD:
-            // value required is in millis
-            final IntByReference timeout = new IntByReference(optVal.intValue() * 1000);
-            int result = setsockopt(sockfd, level, optName, timeout, optSize);
-            if (result == 0) {
-              // setting ABORT_THRESHOLD to be same as KEEPALIVE_THRESHOLD
-              return setsockopt(sockfd, level, OPT_TCP_KEEPALIVE_ABORT_THRESHOLD, timeout, optSize);
-            } else {
-              return result;
-            }
-          default:
-            throw new UnsupportedOperationException("unsupported option " + opt);
-        }
-      } catch (LastErrorException le) {
-        throw new NativeErrorException(le.getMessage(), le.getErrorCode(), le.getCause());
-      }
-    }
-
-    @Override
-    protected boolean isNoProtocolOptionCode(int errno) {
-      return (errno == ENOPROTOOPT);
-    }
-  }
-
-  /**
-   * Implementation of {@link NativeCalls} for MacOSX platform.
-   */
-  private static class MacOSXNativeCalls extends POSIXNativeCalls {
-
-    // #define values for keepalive options in /usr/include/netinet/tcp.h
-    static final int OPT_TCP_KEEPALIVE = 0x10;
-
-    static final int ENOPROTOOPT = 42;
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public OSType getOSType() {
-      return OSType.MACOSX;
-    }
-
-    @Override
-    protected int getPlatformOption(TCPSocketOptions opt) throws UnsupportedOperationException {
-      switch (opt) {
-        case OPT_KEEPIDLE:
-          return OPT_TCP_KEEPALIVE;
-        case OPT_KEEPINTVL:
-        case OPT_KEEPCNT:
-          return UNSUPPORTED_OPTION;
-        default:
-          throw new UnsupportedOperationException("unknown option " + opt);
-      }
-    }
-
-    @Override
-    protected boolean isNoProtocolOptionCode(int errno) {
-      return (errno == ENOPROTOOPT);
-    }
-  }
-
-  /**
-   * Implementation of {@link NativeCalls} for FreeBSD platform.
-   */
-  private static class FreeBSDNativeCalls extends POSIXNativeCalls {
-
-    // #define values for keepalive options in /usr/include/netinet/tcp.h
-    static final int OPT_TCP_KEEPALIVE = 0x100;
-    static final int OPT_TCP_KEEPINTVL = 0x200;
-    static final int OPT_TCP_KEEPCNT = 0x400;
-
-    static final int ENOPROTOOPT = 42;
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public OSType getOSType() {
-      return OSType.FREEBSD;
-    }
-
-    @Override
-    protected int getPlatformOption(TCPSocketOptions opt) throws UnsupportedOperationException {
-      switch (opt) {
-        case OPT_KEEPIDLE:
-          return OPT_TCP_KEEPALIVE;
-        case OPT_KEEPINTVL:
-          return OPT_TCP_KEEPINTVL;
-        case OPT_KEEPCNT:
-          return OPT_TCP_KEEPCNT;
-        default:
-          throw new UnsupportedOperationException("unknown option " + opt);
-      }
-    }
-
-    @Override
-    protected boolean isNoProtocolOptionCode(int errno) {
-      return (errno == ENOPROTOOPT);
-    }
-  }
-
-  /**
-    static {
-      // for socket operations
-      Native.register("Ws2_32");
-    }
-
-    @SuppressWarnings("unused")
-    public static class TcpKeepAlive extends Structure {
-      public int onoff;
-      public int keepalivetime;
-      public int keepaliveinterval;
-
-      @Override
-      protected List<String> getFieldOrder() {
-        return Arrays.asList(new String[] {"onoff", "keepalivetime", "keepaliveinterval"});
-      }
-    }
-
-    public static native int WSAIoctl(NativeLong sock, int controlCode, TcpKeepAlive value,
-        int valueSize, Pointer outValue, int outValueSize, IntByReference bytesReturned,
-        Pointer overlapped, Pointer completionRoutine) throws LastErrorException;
-
-    static final int WSAENOPROTOOPT = 10042;
-    static final int SIO_KEEPALIVE_VALS = -1744830460;
-
-    private static class Kernel32 {
-
-      static {
-        // kernel32 requires stdcall calling convention
-        Map<String, Object> kernel32Options = new HashMap<String, Object>();
-        kernel32Options.put(Library.OPTION_CALLING_CONVENTION, StdCallLibrary.STDCALL_CONVENTION);
-        kernel32Options.put(Library.OPTION_FUNCTION_MAPPER, StdCallLibrary.FUNCTION_MAPPER);
-        final NativeLibrary kernel32Lib = NativeLibrary.getInstance("kernel32", kernel32Options);
-        Native.register(kernel32Lib);
-      }
-
-      // Values below from windows.h header are hard-coded since there
-      // does not seem any simple way to get those at build or run time.
-      // Hopefully these will never change else all hell will break
-      // loose in Windows world ...
-      static final int PROCESS_QUERY_INFORMATION = 0x0400;
-      static final int PROCESS_TERMINATE = 0x0001;
-      static final int STILL_ACTIVE = 259;
-      static final int INVALID_HANDLE = -1;
-
-      public static native boolean SetEnvironmentVariableA(String name, String value)
-          throws LastErrorException;
-
-      public static native int GetEnvironmentVariableA(String name, byte[] pvalue, int psize);
-
-      public static native int GetCurrentProcessId();
-
-      public static native Pointer OpenProcess(int desiredAccess, boolean inheritHandle,
-          int processId) throws LastErrorException;
-
-      public static native boolean TerminateProcess(Pointer processHandle, int exitCode)
-          throws LastErrorException;
-
-      public static native boolean GetExitCodeProcess(Pointer processHandle,
-          IntByReference exitCode) throws LastErrorException;
-
-      public static native boolean CloseHandle(Pointer handle) throws LastErrorException;
-    }
-
-    /**
-     * @see NativeCalls#getOSType()
-     */
-    @Override
-    public OSType getOSType() {
-      return OSType.WIN;
-    }
-
-    /**
-     * @see NativeCalls#getEnvironment(String)
-     */
-      int psize = Kernel32.GetEnvironmentVariableA(name, null, 0);
+      int psize = Kernel32.INSTANCE.GetEnvironmentVariable(name, null, 0);
-          byte[] result = new byte[psize];
-          psize = Kernel32.GetEnvironmentVariableA(name, result, psize);
+          char[] result = new char[psize];
+          psize = Kernel32.INSTANCE.GetEnvironmentVariable(name, result, psize);
-    /**
-     * @see NativeCalls#getProcessId()
-     */
-      return Kernel32.GetCurrentProcessId();
+      return Kernel32.INSTANCE.GetCurrentProcessId();
-    /**
-     * @see NativeCalls#isProcessActive(int)
-     */
-        final Pointer procHandle =
-            Kernel32.OpenProcess(Kernel32.PROCESS_QUERY_INFORMATION, false, processId);
-        final long hval;
-        if (procHandle == null
-            || (hval = Pointer.nativeValue(procHandle)) == Kernel32.INVALID_HANDLE || hval == 0) {
+        final HANDLE procHandle =
+            Kernel32.INSTANCE.OpenProcess(Kernel32.PROCESS_QUERY_INFORMATION, false, processId);
+        if (procHandle == null || WinBase.INVALID_HANDLE_VALUE.equals(procHandle)) {
-          final boolean result =
-              Kernel32.GetExitCodeProcess(procHandle, status)
-                  && status.getValue() == Kernel32.STILL_ACTIVE;
-          Kernel32.CloseHandle(procHandle);
+          final boolean result = Kernel32.INSTANCE.GetExitCodeProcess(procHandle, status)
+              && status.getValue() == Kernel32.STILL_ACTIVE;
+          Kernel32.INSTANCE.CloseHandle(procHandle);
-    /**
-     * @see NativeCalls#killProcess(int)
-     */
-        final Pointer procHandle =
-            Kernel32.OpenProcess(Kernel32.PROCESS_TERMINATE, false, processId);
-        final long hval;
-        if (procHandle == null
-            || (hval = Pointer.nativeValue(procHandle)) == Kernel32.INVALID_HANDLE || hval == 0) {
+        final HANDLE procHandle =
+            Kernel32.INSTANCE.OpenProcess(Kernel32.PROCESS_TERMINATE, false, processId);
+        if (procHandle == null || Kernel32.INVALID_HANDLE_VALUE.equals(procHandle)) {
-          final boolean result = Kernel32.TerminateProcess(procHandle, -1);
-          Kernel32.CloseHandle(procHandle);
+          final boolean result = Kernel32.INSTANCE.TerminateProcess(procHandle, -1);
+          Kernel32.INSTANCE.CloseHandle(procHandle);
-    /**
-     * {@inheritDoc}
-     */
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public Map<TCPSocketOptions, Throwable> setSocketOptions(Socket sock, InputStream sockStream,
-        Map<TCPSocketOptions, Object> optValueMap) throws UnsupportedOperationException {
-      final TcpKeepAlive optValue = new TcpKeepAlive();
-      final int optSize = (Integer.SIZE / Byte.SIZE) * 3;
-      TCPSocketOptions errorOpt = null;
-      Throwable error = null;
-      for (Map.Entry<TCPSocketOptions, Object> e : optValueMap.entrySet()) {
-        TCPSocketOptions opt = e.getKey();
-        Object value = e.getValue();
-        // all options currently require an integer argument
-        if (value == null || !(value instanceof Integer)) {
-          throw new IllegalArgumentException("bad argument type "
-              + (value != null ? value.getClass().getName() : "NULL") + " for " + opt);
-        }
-        switch (opt) {
-          case OPT_KEEPIDLE:
-            optValue.onoff = 1;
-            // in millis
-            optValue.keepalivetime = ((Integer) value).intValue() * 1000;
-            break;
-          case OPT_KEEPINTVL:
-            optValue.onoff = 1;
-            // in millis
-            optValue.keepaliveinterval = ((Integer) value).intValue() * 1000;
-            break;
-          case OPT_KEEPCNT:
-            errorOpt = opt;
-            error = new UnsupportedOperationException(getUnsupportedSocketOptionMessage(opt));
-            break;
-          default:
-            throw new UnsupportedOperationException("unknown option " + opt);
-        }
-      }
-      final int sockfd = getSocketKernelDescriptor(sock, sockStream);
-      final IntByReference nBytes = new IntByReference(0);
-      try {
-        if (WSAIoctl(new NativeLong(sockfd), SIO_KEEPALIVE_VALS, optValue, optSize, null, 0, nBytes,
-            null, null) != 0) {
-          errorOpt = TCPSocketOptions.OPT_KEEPIDLE; // using some option here
-          error = new SocketException(getOSType() + ": error setting options: " + optValueMap);
-        }
-      } catch (LastErrorException le) {
-        // check if the error indicates that option is not supported
-        errorOpt = TCPSocketOptions.OPT_KEEPIDLE; // using some option here
-        if (le.getErrorCode() == WSAENOPROTOOPT) {
-          error = new UnsupportedOperationException(getUnsupportedSocketOptionMessage(errorOpt),
-              new NativeErrorException(le.getMessage(), le.getErrorCode(), le.getCause()));
-        } else {
-          final SocketException se =
-              new SocketException(getOSType() + ": failed to set options: " + optValueMap);
-          se.initCause(le);
-          error = se;
-        }
-      }
-      return errorOpt != null ? Collections.singletonMap(errorOpt, error) : null;
-    }

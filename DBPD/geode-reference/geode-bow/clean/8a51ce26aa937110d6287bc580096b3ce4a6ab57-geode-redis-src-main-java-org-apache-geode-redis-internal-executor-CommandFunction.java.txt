GEODE-8098: Refactor CommandFunction (#5082)

* CommandFunction code is now cleaner.
* Added SingleResultRedisFunction and a new ResultCollector class
to simplify and ensure that our function only has a single result.
* StripedExecutor has been simplified to only take a Callable

-import static org.apache.geode.redis.internal.RedisCommandType.HSET;
-
+import java.util.concurrent.Callable;
-import org.apache.geode.cache.execute.Function;
-import org.apache.geode.cache.execute.FunctionContext;
-import org.apache.geode.cache.execute.ResultSender;
-import org.apache.geode.internal.cache.execute.RegionFunctionContextImpl;
+import org.apache.geode.redis.internal.executor.set.SingleResultCollector;
-public class CommandFunction implements Function<Object[]> {
+@SuppressWarnings("unchecked")
+public class CommandFunction extends SingleResultRedisFunction {
+
-  public static ResultCollector execute(Region<?, ?> region,
-      RedisCommandType command,
+  public static <T> T execute(RedisCommandType command,
-      Object commandArguments) {
-    return FunctionService
+      Object commandArguments, Region region) {
+    SingleResultCollector<T> rc = new SingleResultCollector<>();
+    ResultCollector<T, T> execute = FunctionService
-        .execute(ID);
+        .withCollector(rc)
+        .execute(CommandFunction.ID);
+    return execute.getResult();
-  @SuppressWarnings("unchecked")
-  public void execute(FunctionContext<Object[]> context) {
-    RegionFunctionContextImpl regionFunctionContext =
-        (RegionFunctionContextImpl) context;
-    ByteArrayWrapper key =
-        (ByteArrayWrapper) regionFunctionContext.getFilter().iterator().next();
-    Region localRegion =
-        regionFunctionContext.getLocalDataSet(regionFunctionContext.getDataSet());
-    ResultSender resultSender = regionFunctionContext.getResultSender();
-    Object[] args = context.getArguments();
-    RedisCommandType command = (RedisCommandType) args[0];
+  public String getId() {
+    return ID;
+  }
+
+  @Override
+  protected Object compute(Region localRegion, ByteArrayWrapper key,
+      RedisCommandType command, Object[] args) {
+    Callable<Object> callable;
-        stripedExecutor.execute(key,
-            () -> RedisSet.sadd(localRegion, key, membersToAdd),
-            (addedCount) -> resultSender.lastResult(addedCount));
+        callable = () -> RedisSet.sadd(localRegion, key, membersToAdd);
-        AtomicBoolean setWasDeleted = new AtomicBoolean();
-        stripedExecutor.execute(key,
-            () -> RedisSet.srem(localRegion, key, membersToRemove, setWasDeleted),
-            (removedCount) -> {
-              resultSender.sendResult(removedCount);
-              resultSender.lastResult(setWasDeleted.get() ? 1L : 0L);
-            });
+        callable = () -> {
+          AtomicBoolean setWasDeleted = new AtomicBoolean();
+          long srem = RedisSet.srem(localRegion, key, membersToRemove, setWasDeleted);
+          return new Object[] {srem, setWasDeleted.get()};
+        };
-      case DEL: {
+      case DEL:
-        executeDel(key, localRegion, resultSender, delType);
+        callable = executeDel(key, localRegion, delType);
-      }
-        stripedExecutor.execute(key,
-            () -> RedisSet.smembers(localRegion, key),
-            (members) -> resultSender.lastResult(members));
+        callable = () -> RedisSet.smembers(localRegion, key);
-        stripedExecutor.execute(key,
-            () -> RedisSet.scard(localRegion, key),
-            (size) -> resultSender.lastResult(size));
+        callable = () -> RedisSet.scard(localRegion, key);
-        stripedExecutor.execute(key,
-            () -> RedisSet.sismember(localRegion, key, member),
-            (exists) -> resultSender.lastResult(exists));
+        callable = () -> RedisSet.sismember(localRegion, key, member);
-        stripedExecutor.execute(key,
-            () -> RedisSet.srandmember(localRegion, key, count),
-            (members) -> resultSender.lastResult(members));
+        callable = () -> RedisSet.srandmember(localRegion, key, count);
-        stripedExecutor.execute(key,
-            () -> RedisSet.spop(localRegion, key, popCount),
-            (members) -> resultSender.lastResult(members));
+        callable = () -> RedisSet.spop(localRegion, key, popCount);
-        stripedExecutor.execute(key,
-            () -> RedisSet.sscan(localRegion, key, matchPattern, count, cursor),
-            (members) -> resultSender.lastResult(members));
+        callable = () -> RedisSet.sscan(localRegion, key, matchPattern, count, cursor);
-        stripedExecutor.execute(key,
-            () -> RedisHash.hset(localRegion, key, fieldsToSet, NX),
-            (members) -> resultSender.lastResult(members));
+        callable = () -> RedisHash.hset(localRegion, key, fieldsToSet, NX);
-        stripedExecutor.execute(key,
-            () -> RedisHash.hdel(localRegion, key, fieldsToRemove),
-            (deletedCount) -> resultSender.lastResult(deletedCount));
+        callable = () -> RedisHash.hdel(localRegion, key, fieldsToRemove);
-        stripedExecutor.execute(key,
-            () -> RedisHash.hgetall(localRegion, key),
-            (entries) -> resultSender.lastResult(entries));
+        callable = () -> RedisHash.hgetall(localRegion, key);
+    return stripedExecutor.execute(key, callable);
+
-  private void executeDel(ByteArrayWrapper key, Region localRegion, ResultSender resultSender,
+  private Callable<Object> executeDel(ByteArrayWrapper key, Region localRegion,
-        stripedExecutor.execute(key,
-            () -> RedisSet.del(localRegion, key),
-            (deleted) -> resultSender.lastResult(deleted));
-        break;
+        return () -> RedisSet.del(localRegion, key);
-        stripedExecutor.execute(key,
-            () -> RedisHash.del(localRegion, key),
-            (deleted) -> resultSender.lastResult(deleted));
-        break;
+        return () -> RedisHash.del(localRegion, key);
-
-  @Override
-  public boolean optimizeForWrite() {
-    return true;
-  }
-
-  @Override
-  public String getId() {
-    return ID;
-  }

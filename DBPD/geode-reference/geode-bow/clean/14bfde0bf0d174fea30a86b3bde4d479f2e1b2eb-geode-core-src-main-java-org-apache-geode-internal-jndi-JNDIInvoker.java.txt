Merge branch 'release/1.8.0'

-import java.util.ArrayList;
+import java.sql.Connection;
+import java.sql.SQLException;
-import java.util.Iterator;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import javax.sql.DataSource;
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.LogWriter;
-import org.apache.geode.i18n.LogWriterI18n;
-import org.apache.geode.internal.datasource.AbstractDataSource;
-import org.apache.geode.internal.i18n.LocalizedStrings;
+import org.apache.geode.internal.logging.LogService;
+  private static final Logger logger = LogService.getLogger();
+
-   * List of DataSource bound to the context, used for cleaning gracefully closing datasource and
-   * associated threads.
+   * Maps data source name to the data source instance itself.
-  private static List dataSourceList = new ArrayList();
+  private static final ConcurrentMap<String, Object> dataSourceMap = new ConcurrentHashMap<>();
+  private static final DataSourceFactory dataSourceFactory = new DataSourceFactory();
+
-      TransactionUtils.setLogWriter(distSystem.getLogWriter().convertToLogWriterI18n());
+      TransactionUtils.setLogWriter(distSystem.getLogWriter());
-      LogWriterI18n writer = TransactionUtils.getLogWriterI18n();
+      LogWriter writer = TransactionUtils.getLogWriter();
-                LocalizedStrings.JNDIInvoker_JNDIINVOKERMAPTRANSACTIONSNAMINGEXCEPTION_WHILE_BINDING_TRANSACTIONMANAGERUSERTRANSACTION_TO_GEMFIRE_JNDI_TREE);
+                "JNDIInvoker::mapTransactions::NamingException while binding TransactionManager/UserTransaction to GemFire JNDI Tree");
-                LocalizedStrings.JNDIInvoker_JNDIINVOKERMAPTRANSACTIONSSYSTEMEXCEPTION_WHILE_BINDING_USERTRANSACTION_TO_GEMFIRE_JNDI_TREE);
+                "JNDIInvoker::mapTransactions::SystemException while binding UserTransaction to GemFire JNDI Tree");
-                LocalizedStrings.JNDIInvoker_JNDIINVOKERMAPTRANSACTIONSNAMINGEXCEPTION_WHILE_BINDING_TRANSACTIONMANAGERUSERTRANSACTION_TO_APPLICATION_SERVER_JNDI_TREE);
+                "JNDIInvoker::mapTransactions::NamingException while binding TransactionManager/UserTransaction to Application Server JNDI Tree");
-                LocalizedStrings.JNDIInvoker_JNDIINVOKERMAPTRANSACTIONSSYSTEMEXCEPTION_WHILE_BINDING_TRANSACTIONMANAGERUSERTRANSACTION_TO_APPLICATION_SERVER_JNDI_TREE);
+                "JNDIInvoker::mapTransactions::SystemException while binding TransactionManager/UserTransaction to Application Server JNDI Tree");
-    int len = dataSourceList.size();
-    for (int i = 0; i < len; i++) {
-      if (dataSourceList.get(i) instanceof AbstractDataSource)
-        ((AbstractDataSource) dataSourceList.get(i)).clearUp();
-      else if (dataSourceList.get(i) instanceof ClientConnectionFactoryWrapper) {
-        ((ClientConnectionFactoryWrapper) dataSourceList.get(i)).clearUp();
+    dataSourceMap.values().stream().forEach(JNDIInvoker::closeDataSource);
+    dataSourceMap.clear();
+    IGNORE_JTA = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "ignoreJTA");
+  }
+
+  private static void closeDataSource(Object dataSource) {
+    if (dataSource instanceof AutoCloseable) {
+      try {
+        ((AutoCloseable) dataSource).close();
+      } catch (Exception e) {
+        if (logger.isDebugEnabled()) {
+          logger.debug("Exception closing DataSource", e);
+        }
-    dataSourceList.clear();
-    IGNORE_JTA = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "ignoreJTA");
-    LogWriterI18n writer = TransactionUtils.getLogWriterI18n();
+    LogWriter writer = TransactionUtils.getLogWriter();
-          LocalizedStrings.JNDIInvoker_JNDIINVOKER_DOTRANSACTIONLOOKUP_FOUND_WEBSPHERE_TRANSACTIONMANAGER_FACTORY_CLASS_0_BUT_COULDNT_INVOKE_ITS_STATIC_GETTRANSACTIONMANAGER_METHOD,
-          clazz.getName(), ex);
+          String.format(
+              "JNDIInvoker::doTransactionLookup::Found WebSphere TransactionManager factory class [%s], but could not invoke its static 'getTransactionManager' method",
+              clazz.getName()),
+          ex);
-          LocalizedStrings.JNDIInvoker_JNDIINVOKER_DOTRANSACTIONLOOKUP_FOUND_WEBSPHERE_TRANSACTIONMANAGER_FACTORY_CLASS_0_BUT_COULDNT_INVOKE_ITS_STATIC_GETTRANSACTIONMANAGER_METHOD
-              .toLocalizedString(new Object[] {clazz.getName()}));
+          String.format(
+              "JNDIInvoker::doTransactionLookup::Found WebSphere TransactionManager factory class [%s], but could not invoke its static 'getTransactionManager' method",
+              new Object[] {clazz.getName()}));
-  public static void mapDatasource(Map map, List<ConfigProperty> props) {
+  public static void mapDatasource(Map map, List<ConfigProperty> props)
+      throws NamingException, DataSourceCreateException {
+    mapDatasource(map, props, dataSourceFactory, ctx);
+  }
+
+  static void mapDatasource(Map map, List<ConfigProperty> props,
+      DataSourceFactory dataSourceFactory, Context context)
+      throws NamingException, DataSourceCreateException {
-    LogWriterI18n writer = TransactionUtils.getLogWriterI18n();
-    Object ds = null;
-    try {
-      jndiName = (String) map.get("jndi-name");
-      if (value.equals("PooledDataSource")) {
-        ds = DataSourceFactory.getPooledDataSource(map, props);
-        ctx.rebind("java:/" + jndiName, ds);
-        dataSourceList.add(ds);
-        if (writer.fineEnabled())
-          writer.fine("Bound java:/" + jndiName + " to Context");
-      } else if (value.equals("XAPooledDataSource")) {
-        ds = DataSourceFactory.getTranxDataSource(map, props);
-        ctx.rebind("java:/" + jndiName, ds);
-        dataSourceList.add(ds);
-        if (writer.fineEnabled())
-          writer.fine("Bound java:/" + jndiName + " to Context");
-      } else if (value.equals("SimpleDataSource")) {
-        ds = DataSourceFactory.getSimpleDataSource(map);
-        ctx.rebind("java:/" + jndiName, ds);
-        dataSourceList.add(ds);
-        if (writer.fineEnabled())
-          writer.fine("Bound java:/" + jndiName + " to Context");
-      } else if (value.equals("ManagedDataSource")) {
-        ClientConnectionFactoryWrapper ds1 = DataSourceFactory.getManagedDataSource(map, props);
-        ctx.rebind("java:/" + jndiName, ds1.getClientConnFactory());
-        dataSourceList.add(ds1);
-        if (writer.fineEnabled())
-          writer.fine("Bound java:/" + jndiName + " to Context");
-      } else {
-        String exception = "JNDIInvoker::mapDataSource::No correct type of DataSource";
-        if (writer.fineEnabled())
-          writer.fine(exception);
-        throw new DataSourceCreateException(exception);
+    jndiName = (String) map.get("jndi-name");
+    if (value.equals("PooledDataSource")) {
+      validateAndBindDataSource(context, jndiName,
+          dataSourceFactory.getPooledDataSource(map, props));
+    } else if (value.equals("XAPooledDataSource")) {
+      validateAndBindDataSource(context, jndiName,
+          dataSourceFactory.getTranxDataSource(map, props));
+    } else if (value.equals("SimpleDataSource")) {
+      validateAndBindDataSource(context, jndiName, dataSourceFactory.getSimpleDataSource(map));
+    } else if (value.equals("ManagedDataSource")) {
+      ClientConnectionFactoryWrapper wrapper = dataSourceFactory.getManagedDataSource(map, props);
+      ctx.rebind("java:/" + jndiName, wrapper.getClientConnFactory());
+      dataSourceMap.put(jndiName, wrapper);
+      if (logger.isDebugEnabled()) {
+        logger.debug("Bound java:/" + jndiName + " to Context");
-      ds = null;
-    } catch (NamingException ne) {
-      if (writer.infoEnabled())
-        writer.info(
-            LocalizedStrings.JNDIInvoker_JNDIINVOKER_MAPDATASOURCE_0_WHILE_BINDING_1_TO_JNDI_CONTEXT,
-            new Object[] {"NamingException", jndiName});
-    } catch (DataSourceCreateException dsce) {
-      if (writer.infoEnabled())
-        writer.info(
-            LocalizedStrings.JNDIInvoker_JNDIINVOKER_MAPDATASOURCE_0_WHILE_BINDING_1_TO_JNDI_CONTEXT,
-            new Object[] {"DataSourceCreateException", jndiName});
+    } else {
+      String exception = "JNDIInvoker::mapDataSource::No correct type of DataSource";
+      if (logger.isDebugEnabled()) {
+        logger.debug(exception);
+      }
+      throw new DataSourceCreateException(exception);
+    }
+  }
+
+  private static void validateAndBindDataSource(Context context, String jndiName,
+      DataSource dataSource) throws NamingException, DataSourceCreateException {
+    try (Connection connection = dataSource.getConnection()) {
+    } catch (SQLException sqlEx) {
+      closeDataSource(dataSource);
+      throw new DataSourceCreateException(
+          "Failed to connect to \"" + jndiName + "\". See log for details", sqlEx);
+    }
+    context.rebind("java:/" + jndiName, dataSource);
+    dataSourceMap.put(jndiName, dataSource);
+    if (logger.isDebugEnabled()) {
+      logger.debug("Bound java:/" + jndiName + " to Context");
-    for (Iterator it = dataSourceList.iterator(); it.hasNext();) {
-      Object obj = it.next();
-      if (obj instanceof AbstractDataSource) {
-        ((AbstractDataSource) obj).clearUp();
-      } else if (obj instanceof ClientConnectionFactoryWrapper) {
-        ((ClientConnectionFactoryWrapper) obj).clearUp();
-      }
-      it.remove();
+    Object removedDataSource = dataSourceMap.remove(jndiName);
+    closeDataSource(removedDataSource);
+  }
+
+  public static DataSource getDataSource(String name) {
+    Object result = dataSourceMap.get(name);
+    if (result instanceof DataSource) {
+      return (DataSource) result;
+    } else {
+      return null;
-    return dataSourceList.size();
+    return dataSourceMap.size();

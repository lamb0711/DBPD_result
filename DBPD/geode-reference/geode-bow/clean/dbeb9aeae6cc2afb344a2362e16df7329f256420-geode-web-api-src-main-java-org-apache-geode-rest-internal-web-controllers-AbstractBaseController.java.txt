Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.io.UnsupportedEncodingException;
-import java.net.URI;
-import java.net.URLDecoder;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicLong;
-
-import javax.annotation.PostConstruct;
-
+import org.apache.geode.cache.query.Query;
-import org.apache.geode.internal.security.IntegratedSecurityService;
-import org.apache.geode.internal.security.SecurityService;
+import org.apache.geode.rest.internal.web.security.RestSecurityService;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.io.UnsupportedEncodingException;
+import java.net.URI;
+import java.net.URLDecoder;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicLong;
+import javax.annotation.PostConstruct;
+
- * AbstractBaseController class contains common functionalities required for other controllers. 
+ * AbstractBaseController class contains common functionalities required for other controllers.
+ * 
-  
-  private static final Logger logger = LogService.getLogger();
-  
+
-  
+  private static final Logger logger = LogService.getLogger();
-  protected SecurityService securityService = IntegratedSecurityService.getSecurityService();
-  
-  //private Cache cache = GemFireCacheImpl.getExisting(null);
-  
+
+  // private Cache cache = GemFireCacheImpl.getExisting(null);
+  @Autowired
+  protected RestSecurityService securityService;
-  protected Cache getCache(){
+  protected Cache getCache() {
-  
+
-    return ServletUriComponentsBuilder.fromCurrentContextPath().path(getRestApiVersion()).pathSegment(pathSegments)
-      .build().toUri();
+    return ServletUriComponentsBuilder.fromCurrentContextPath().path(getRestApiVersion())
+        .pathSegment(pathSegments).build().toUri();
-  
+
-  
-  protected String validateQuery(String queryInUrl, String queryInBody){
-    
+
+  protected String validateQuery(String queryInUrl, String queryInBody) {
+
-  
+
-    if(value == null) {
-      throw new GemfireRestException("could not process null value specified in query String"); 
+    if (value == null) {
+      throw new GemfireRestException("could not process null value specified in query String");
-    
+
-  protected PdxInstance convert(final String json){
-    try{
+  protected PdxInstance convert(final String json) {
+    try {
-    }catch(JSONFormatterException jpe){
-      throw new MalformedJsonException("Json doc specified is either not supported or invalid!", jpe);
+    } catch (JSONFormatterException jpe) {
+      throw new MalformedJsonException("Json doc specified is either not supported or invalid!",
+          jpe);
-  
-  protected String convert(final PdxInstance pdxObj){
+
+  protected String convert(final PdxInstance pdxObj) {
-    } catch(JSONFormatterException jpe) {
-      throw new GemfireRestException("Requested data could not convert into REST format(JSON)!", jpe);
+    } catch (JSONFormatterException jpe) {
+      throw new GemfireRestException("Requested data could not convert into REST format(JSON)!",
+          jpe);
-  
-  protected String convert(final Iterable<PdxInstance> pdxObjs){
+
+  protected String convert(final Iterable<PdxInstance> pdxObjs) {
-  protected <T> T casValue(String regionNamePath, String key, String jsonData){
+  protected <T> T casValue(String regionNamePath, String key, String jsonData) {
-  
+
-      
+
-    }              
-  }
-  
-  public ResponseEntity<String> processQueryResponse (Object  queryResult, String queryId) throws JSONException {
-    if(queryResult instanceof Collection<?>){
-      Collection<Object> result = (Collection<Object>) queryResult;
-      String queryResultAsJson =  JSONUtils.convertCollectionToJson(result);
-      
-      final HttpHeaders headers = new HttpHeaders();
-      headers.setLocation(toUri("queries", queryId));    
-      return new ResponseEntity<String>(queryResultAsJson, headers, HttpStatus.OK);
-    }else {
-      throw new GemfireRestException("Server has encountered error while generating query result into restful format(JSON)!");
-  
+
+  public ResponseEntity<String> processQueryResponse(Query query, Object args[], Object queryResult)
+      throws JSONException {
+    if (queryResult instanceof Collection<?>) {
+      Collection processedResults = new ArrayList(((Collection) queryResult).size());
+      for (Object result : (Collection) queryResult) {
+        processedResults.add(securityService.postProcess(null, null, result, false));
+      }
+      String queryResultAsJson = JSONUtils.convertCollectionToJson(processedResults);
+
+      final HttpHeaders headers = new HttpHeaders();
+      headers.setLocation(toUri("queries", query.getQueryString()));
+      return new ResponseEntity<>(queryResultAsJson, headers, HttpStatus.OK);
+    } else {
+      throw new GemfireRestException(
+          "Server has encountered error while generating query result into restful format(JSON)!");
+    }
+  }
+
-      
-      
-      for(int index=0; index < jsonArr.length(); index++){
-        //String element = jsonArr.getJSONObject(i).toString();
-        //String element  = jsonArr.getString(i);
-        Object object= jsonArr.get(index);
+
+      for (int index = 0; index < jsonArr.length(); index++) {
+        // String element = jsonArr.getJSONObject(i).toString();
+        // String element = jsonArr.getString(i);
+        Object object = jsonArr.get(index);
-        
+
-    
+
-  
-  
+
+
-  protected PdxInstance convertJsonIntoPdxCollection(final String jsonArray) {
-    JSONArray jsonArr = null;
-    
-      PdxInstance pi = convert(jsonArray);
-      System.out.println("Successfully converted into PdxInstance..!!");
-      return pi;
-    
-  }
-  */
-  
-  protected Object casValue(final String regionNamePath, final Object key, final Object oldValue, final Object newValue) {
+   * protected PdxInstance convertJsonIntoPdxCollection(final String jsonArray) { JSONArray jsonArr
+   * = null;
+   * 
+   * PdxInstance pi = convert(jsonArray);
+   * System.out.println("Successfully converted into PdxInstance..!!"); return pi;
+   * 
+   * }
+   */
+
+  protected Object casValue(final String regionNamePath, final Object key, final Object oldValue,
+      final Object newValue) {
-    } catch(UnsupportedOperationException use){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not support the requested operation!", regionNamePath), use);
-    }catch(ClassCastException cce){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not allow to store specified key or value type in this region!", regionNamePath), cce);
-    }catch(NullPointerException npe){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not allow null keys or values!", regionNamePath), npe);
-    }catch(IllegalArgumentException iae){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration prevents specified data from being stored in it!", regionNamePath), iae);
-    }catch(LeaseExpiredException lee){
-      throw new GemfireRestException("Server has encountered error while processing this request!", lee);
-    }catch(TimeoutException toe){
-      throw new GemfireRestException("Server has encountered timeout error while processing this request!", toe);
-    }catch(CacheWriterException cwe){
-      throw new GemfireRestException("Server has encountered CacheWriter error while processing this request!", cwe);
-    }catch(PartitionedRegionStorageException prse){
-      throw new GemfireRestException("Requested operation could not be completed on a partitioned region!", prse);
-    }catch(LowMemoryException lme){
-      throw new GemfireRestException("Server has detected low memory while processing this request!", lme);
-    } 
-  }
-    
-  protected void replaceValue(final String regionNamePath, final Object key, final PdxInstance value) {
-    try {
-      if(getRegion(regionNamePath).replace(key, value) == null){
-        throw new ResourceNotFoundException(String.format("No resource at (%1$s) exists!", toUri(regionNamePath, String.valueOf(key))));
-      }
-    }catch(UnsupportedOperationException use){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not support the requested operation!", regionNamePath), use);
-    }catch(ClassCastException cce){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not allow to store specified key or value type in this region!", regionNamePath), cce);
-    }catch(NullPointerException npe){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not allow null keys or values!", regionNamePath), npe);
-    }catch(IllegalArgumentException iae){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration prevents specified data from being stored in it!", regionNamePath), iae);
-    }catch(LeaseExpiredException lee){
-      throw new GemfireRestException("Server has encountered error while processing this request!", lee);
-    }catch(TimeoutException toe){
-      throw new GemfireRestException("Server has encountered timeout error while processing this request!", toe);
-    }catch(CacheWriterException cwe){
-      throw new GemfireRestException("Server has encountered CacheWriter error while processing this request!", cwe);
-    }catch(PartitionedRegionStorageException prse){
-      throw new GemfireRestException("Requested operation could not be completed on a partitioned region!", prse);
-    }catch(LowMemoryException lme){
-      throw new GemfireRestException("Server has detected low memory while processing this request!", lme);
+    } catch (UnsupportedOperationException use) {
+      throw new GemfireRestException(
+          String.format("Resource (%1$s) configuration does not support the requested operation!",
+              regionNamePath),
+          use);
+    } catch (ClassCastException cce) {
+      throw new GemfireRestException(String.format(
+          "Resource (%1$s) configuration does not allow to store specified key or value type in this region!",
+          regionNamePath), cce);
+    } catch (NullPointerException npe) {
+      throw new GemfireRestException(
+          String.format("Resource (%1$s) configuration does not allow null keys or values!",
+              regionNamePath),
+          npe);
+    } catch (IllegalArgumentException iae) {
+      throw new GemfireRestException(String.format(
+          "Resource (%1$s) configuration prevents specified data from being stored in it!",
+          regionNamePath), iae);
+    } catch (LeaseExpiredException lee) {
+      throw new GemfireRestException("Server has encountered error while processing this request!",
+          lee);
+    } catch (TimeoutException toe) {
+      throw new GemfireRestException(
+          "Server has encountered timeout error while processing this request!", toe);
+    } catch (CacheWriterException cwe) {
+      throw new GemfireRestException(
+          "Server has encountered CacheWriter error while processing this request!", cwe);
+    } catch (PartitionedRegionStorageException prse) {
+      throw new GemfireRestException(
+          "Requested operation could not be completed on a partitioned region!", prse);
+    } catch (LowMemoryException lme) {
+      throw new GemfireRestException(
+          "Server has detected low memory while processing this request!", lme);
-  }     
-  
+  }
+
+  protected void replaceValue(final String regionNamePath, final Object key,
+      final PdxInstance value) {
+    try {
+      if (getRegion(regionNamePath).replace(key, value) == null) {
+        throw new ResourceNotFoundException(String.format("No resource at (%1$s) exists!",
+            toUri(regionNamePath, String.valueOf(key))));
+      }
+    } catch (UnsupportedOperationException use) {
+      throw new GemfireRestException(
+          String.format("Resource (%1$s) configuration does not support the requested operation!",
+              regionNamePath),
+          use);
+    } catch (ClassCastException cce) {
+      throw new GemfireRestException(String.format(
+          "Resource (%1$s) configuration does not allow to store specified key or value type in this region!",
+          regionNamePath), cce);
+    } catch (NullPointerException npe) {
+      throw new GemfireRestException(
+          String.format("Resource (%1$s) configuration does not allow null keys or values!",
+              regionNamePath),
+          npe);
+    } catch (IllegalArgumentException iae) {
+      throw new GemfireRestException(String.format(
+          "Resource (%1$s) configuration prevents specified data from being stored in it!",
+          regionNamePath), iae);
+    } catch (LeaseExpiredException lee) {
+      throw new GemfireRestException("Server has encountered error while processing this request!",
+          lee);
+    } catch (TimeoutException toe) {
+      throw new GemfireRestException(
+          "Server has encountered timeout error while processing this request!", toe);
+    } catch (CacheWriterException cwe) {
+      throw new GemfireRestException(
+          "Server has encountered CacheWriter error while processing this request!", cwe);
+    } catch (PartitionedRegionStorageException prse) {
+      throw new GemfireRestException(
+          "Requested operation could not be completed on a partitioned region!", prse);
+    } catch (LowMemoryException lme) {
+      throw new GemfireRestException(
+          "Server has detected low memory while processing this request!", lme);
+    }
+  }
+
-    //still do we need to worry for race condition..?
+    // still do we need to worry for race condition..?
-      if(getRegion(regionNamePath).replace(key, value) == null){
-        throw new ResourceNotFoundException(String.format("No resource at (%1$s) exists!", toUri(regionNamePath, String.valueOf(key))));
+      if (getRegion(regionNamePath).replace(key, value) == null) {
+        throw new ResourceNotFoundException(String.format("No resource at (%1$s) exists!",
+            toUri(regionNamePath, String.valueOf(key))));
-    }catch(UnsupportedOperationException use){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not support the requested operation!", regionNamePath), use);
-    }catch(ClassCastException cce){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not allow to store specified key or value type in this region!", regionNamePath), cce);
-    }catch(NullPointerException npe){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not allow null keys or values!", regionNamePath), npe);
-    }catch(IllegalArgumentException iae){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration prevents specified data from being stored in it!", regionNamePath), iae);
-    }catch(LeaseExpiredException lee){
-      throw new GemfireRestException("Server has encountered error while processing this request!", lee);
-    }catch(TimeoutException toe){
-      throw new GemfireRestException("Server has encountered timeout error while processing this request!", toe);
-    }catch(CacheWriterException cwe){
-      throw new GemfireRestException("Server has encountered CacheWriter error while processing this request!", cwe);
-    }catch(PartitionedRegionStorageException prse){
-      throw new GemfireRestException("Requested operation could not be completed on a partitioned region!", prse);
-    }catch(LowMemoryException lme){
-      throw new GemfireRestException("Server has detected low memory while processing this request!", lme);
+    } catch (UnsupportedOperationException use) {
+      throw new GemfireRestException(
+          String.format("Resource (%1$s) configuration does not support the requested operation!",
+              regionNamePath),
+          use);
+    } catch (ClassCastException cce) {
+      throw new GemfireRestException(String.format(
+          "Resource (%1$s) configuration does not allow to store specified key or value type in this region!",
+          regionNamePath), cce);
+    } catch (NullPointerException npe) {
+      throw new GemfireRestException(
+          String.format("Resource (%1$s) configuration does not allow null keys or values!",
+              regionNamePath),
+          npe);
+    } catch (IllegalArgumentException iae) {
+      throw new GemfireRestException(String.format(
+          "Resource (%1$s) configuration prevents specified data from being stored in it!",
+          regionNamePath), iae);
+    } catch (LeaseExpiredException lee) {
+      throw new GemfireRestException("Server has encountered error while processing this request!",
+          lee);
+    } catch (TimeoutException toe) {
+      throw new GemfireRestException(
+          "Server has encountered timeout error while processing this request!", toe);
+    } catch (CacheWriterException cwe) {
+      throw new GemfireRestException(
+          "Server has encountered CacheWriter error while processing this request!", cwe);
+    } catch (PartitionedRegionStorageException prse) {
+      throw new GemfireRestException(
+          "Requested operation could not be completed on a partitioned region!", prse);
+    } catch (LowMemoryException lme) {
+      throw new GemfireRestException(
+          "Server has detected low memory while processing this request!", lme);
-  
-  protected void putValue(final String regionNamePath, final Object key, final Object value){
+
+  protected void putValue(final String regionNamePath, final Object key, final Object value) {
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not allow null keys or values!", regionNamePath), npe);
+      throw new GemfireRestException(
+          String.format("Resource (%1$s) configuration does not allow null keys or values!",
+              regionNamePath),
+          npe);
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not allow to store specified key or value type in this region!", regionNamePath), cce);
+      throw new GemfireRestException(String.format(
+          "Resource (%1$s) configuration does not allow to store specified key or value type in this region!",
+          regionNamePath), cce);
-      throw new GemfireRestException("Server has encountered error while processing this request!", lee);
+      throw new GemfireRestException("Server has encountered error while processing this request!",
+          lee);
-      throw new GemfireRestException("Server has encountered timeout error while processing this request!", toe);
+      throw new GemfireRestException(
+          "Server has encountered timeout error while processing this request!", toe);
-      throw new GemfireRestException("Server has encountered CacheWriter error while processing this request!", cwe);
+      throw new GemfireRestException(
+          "Server has encountered CacheWriter error while processing this request!", cwe);
-      throw new GemfireRestException("Requested operation could not be completed on a partitioned region!", prse);
+      throw new GemfireRestException(
+          "Requested operation could not be completed on a partitioned region!", prse);
-      throw new GemfireRestException("Server has detected low memory while processing this request!", lme);
+      throw new GemfireRestException(
+          "Server has detected low memory while processing this request!", lme);
-  
-  protected void deleteQueryId(final String regionNamePath, final String key){
+
+  protected void deleteQueryId(final String regionNamePath, final String key) {
-  
-  protected void deleteNamedQuery(final String regionNamePath, final String key){
-    //Check whether query ID exist in region or not
+
+  protected void deleteNamedQuery(final String regionNamePath, final String key) {
+    // Check whether query ID exist in region or not
-    deleteQueryId(regionNamePath, key);  
+    deleteQueryId(regionNamePath, key);
-  
+
-    if(!getQueryStore(region).containsKey(key)) {
+    if (!getQueryStore(region).containsKey(key)) {
-  
+
-    return  ValidationUtils.returnValueThrowOnNull(getCache().<String, String>getRegion(namePath),
-      new GemfireRestException(String.format("Query store does not exist!",
-        namePath)));
+    return ValidationUtils.returnValueThrowOnNull(getCache().<String, String>getRegion(namePath),
+        new GemfireRestException(String.format("Query store does not exist!", namePath)));
-  
+
-      return  getQueryStore(regionNamePath).get(key);
-    } catch(NullPointerException npe) {
+      return getQueryStore(regionNamePath).get(key);
+    } catch (NullPointerException npe) {
-    } catch(IllegalArgumentException iae) {
-      throw new GemfireRestException("Server has not allowed to perform the requested operation!", iae);
-    } catch(LeaseExpiredException lee) {
-      throw new GemfireRestException("Server has encountered error while processing this request!", lee);
-    } catch(TimeoutException te) {
-      throw new GemfireRestException("Server has encountered timeout error while processing this request!", te);
-    } 
+    } catch (IllegalArgumentException iae) {
+      throw new GemfireRestException("Server has not allowed to perform the requested operation!",
+          iae);
+    } catch (LeaseExpiredException lee) {
+      throw new GemfireRestException("Server has encountered error while processing this request!",
+          lee);
+    } catch (TimeoutException te) {
+      throw new GemfireRestException(
+          "Server has encountered timeout error while processing this request!", te);
+    }
-  
-  protected void updateNamedQuery(final String regionNamePath, final String key, final String value){
+
+  protected void updateNamedQuery(final String regionNamePath, final String key,
+      final String value) {
-      throw new GemfireRestException("Server has encountered error while processing this request!", lee);
+      throw new GemfireRestException("Server has encountered error while processing this request!",
+          lee);
-      throw new GemfireRestException("Server has encountered timeout error while processing this request!", toe);
+      throw new GemfireRestException(
+          "Server has encountered timeout error while processing this request!", toe);
-      throw new GemfireRestException("Server has detected low memory while processing this request!", lme);
+      throw new GemfireRestException(
+          "Server has detected low memory while processing this request!", lme);
-  
+
-  protected <T> T createNamedQuery(final String regionNamePath, final String key, final String value){
+  protected <T> T createNamedQuery(final String regionNamePath, final String key,
+      final String value) {
-    } catch(UnsupportedOperationException use){
+    } catch (UnsupportedOperationException use) {
-    } catch(ClassCastException cce){
+    } catch (ClassCastException cce) {
-    } catch(NullPointerException npe){
+    } catch (NullPointerException npe) {
-    } catch(IllegalArgumentException iae){
-      throw new GemfireRestException("Configuration does not allow to perform the requested operation!", iae);
-    } catch(LeaseExpiredException lee){
-      throw new GemfireRestException("Server has encountered error while processing this request!", lee);
-    } catch(TimeoutException toe){
-      throw new GemfireRestException("Server has encountered timeout error while processing this request!", toe);
-    } catch(LowMemoryException lme){
-      throw new GemfireRestException("Server has detected low memory while processing this request!", lme);
+    } catch (IllegalArgumentException iae) {
+      throw new GemfireRestException(
+          "Configuration does not allow to perform the requested operation!", iae);
+    } catch (LeaseExpiredException lee) {
+      throw new GemfireRestException("Server has encountered error while processing this request!",
+          lee);
+    } catch (TimeoutException toe) {
+      throw new GemfireRestException(
+          "Server has encountered timeout error while processing this request!", toe);
+    } catch (LowMemoryException lme) {
+      throw new GemfireRestException(
+          "Server has detected low memory while processing this request!", lme);
-  
-  protected void putPdxValues(final String regionNamePath, final Map<Object, PdxInstance> map){
+
+  protected void putPdxValues(final String regionNamePath, final Map<Object, PdxInstance> map) {
-    getRegion(regionNamePath).putAll(map);
+      getRegion(regionNamePath).putAll(map);
-  
+
-  
+
-    
+
-  
+
-  protected <T> T postValue(final String regionNamePath, final Object key, final Object value){ 
+  protected <T> T postValue(final String regionNamePath, final Object key, final Object value) {
-    }catch(UnsupportedOperationException use){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not support the requested operation!", regionNamePath), use);
-    }catch(ClassCastException cce){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not allow to store specified key or value type in this region!", regionNamePath), cce);
-    }catch(NullPointerException npe){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not allow null keys or values!", regionNamePath), npe);
-    }catch(IllegalArgumentException iae){
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration prevents specified data from being stored in it!", regionNamePath), iae);
-    }catch(LeaseExpiredException lee){
-      throw new GemfireRestException("Server has encountered error while processing this request!", lee);
-    }catch(TimeoutException toe){
-      throw new GemfireRestException("Server has encountered timeout error while processing this request!", toe);
-    }catch(CacheWriterException cwe){
-      throw new GemfireRestException("Server has encountered CacheWriter error while processing this request!", cwe);
-    }catch(PartitionedRegionStorageException prse){
-      throw new GemfireRestException("Requested operation could not be completed on a partitioned region!", prse);
-    }catch(LowMemoryException lme){
-      throw new GemfireRestException("Server has detected low memory while processing this request!", lme);
+    } catch (UnsupportedOperationException use) {
+      throw new GemfireRestException(
+          String.format("Resource (%1$s) configuration does not support the requested operation!",
+              regionNamePath),
+          use);
+    } catch (ClassCastException cce) {
+      throw new GemfireRestException(String.format(
+          "Resource (%1$s) configuration does not allow to store specified key or value type in this region!",
+          regionNamePath), cce);
+    } catch (NullPointerException npe) {
+      throw new GemfireRestException(
+          String.format("Resource (%1$s) configuration does not allow null keys or values!",
+              regionNamePath),
+          npe);
+    } catch (IllegalArgumentException iae) {
+      throw new GemfireRestException(String.format(
+          "Resource (%1$s) configuration prevents specified data from being stored in it!",
+          regionNamePath), iae);
+    } catch (LeaseExpiredException lee) {
+      throw new GemfireRestException("Server has encountered error while processing this request!",
+          lee);
+    } catch (TimeoutException toe) {
+      throw new GemfireRestException(
+          "Server has encountered timeout error while processing this request!", toe);
+    } catch (CacheWriterException cwe) {
+      throw new GemfireRestException(
+          "Server has encountered CacheWriter error while processing this request!", cwe);
+    } catch (PartitionedRegionStorageException prse) {
+      throw new GemfireRestException(
+          "Requested operation could not be completed on a partitioned region!", prse);
+    } catch (LowMemoryException lme) {
+      throw new GemfireRestException(
+          "Server has detected low memory while processing this request!", lme);
- 
-  protected Object getActualTypeValue(final String value, final String valueType){
+
+  protected Object getActualTypeValue(final String value, final String valueType) {
-    if(valueType != null){
+    if (valueType != null) {
-        actualValue  = NumberUtils.convertToActualType(value, valueType);
+        actualValue = NumberUtils.convertToActualType(value, valueType);
-      } 
+      }
-  
-  protected String generateKey(final String existingKey){
+
+  protected String generateKey(final String existingKey) {
-  
+
-    }
-    else if (domainObjectId != null) {
+    } else if (domainObjectId != null) {
-      }
-      else {
+      } else {
-    }
-    else {
+    } else {
-  
+
-    }
-    catch (UnsupportedEncodingException e) {
+    } catch (UnsupportedEncodingException e) {
-  
+
-    return (Region<Object, T>) ValidationUtils.returnValueThrowOnNull(getCache().getRegion(namePath),
-      new RegionNotFoundException(String.format("The Region identified by name (%1$s) could not be found!",
-        namePath)));
+    return (Region<Object, T>) ValidationUtils
+        .returnValueThrowOnNull(getCache().getRegion(namePath), new RegionNotFoundException(
+            String.format("The Region identified by name (%1$s) could not be found!", namePath)));
-  
+
-    if(!getRegion(region).containsKey(key)) {
-      throw new ResourceNotFoundException(String.format("Key (%1$s) does not exist for region (%2$s) in cache!", key, region));
+    if (!getRegion(region).containsKey(key)) {
+      throw new ResourceNotFoundException(
+          String.format("Key (%1$s) does not exist for region (%2$s) in cache!", key, region));
-  
+
-    for (int index=0; index < keys.length; index++) {
-      if(!getRegion(region).containsKey(keys[index])) {
-        //throw new ResourceNotFoundException(String.format("Key [(%1$s)] does not exist for region [(%2$s)] in cache!", key, region));
+    for (int index = 0; index < keys.length; index++) {
+      if (!getRegion(region).containsKey(keys[index])) {
+        // throw new ResourceNotFoundException(String.format("Key [(%1$s)] does not exist for region
+        // [(%2$s)] in cache!", key, region));
-  
+
-    return (!(keys == null || keys.length == 0) ? keys : getRegion(regionNamePath).keySet().toArray());
+    return (!(keys == null || keys.length == 0) ? keys
+        : getRegion(regionNamePath).keySet().toArray());
-  
-  protected <T> Map<Object, T> getValues(final String regionNamePath, Object... keys)  {
-    try{ 
+
+  protected <T> Map<Object, T> getValues(final String regionNamePath, Object... keys) {
+    try {
+      for (Object key : entries.keySet()) {
+        entries.put(key,
+            (T) securityService.postProcess(regionNamePath, key, entries.get(key), false));
+      }
-    } catch(SerializationException se) {
-      throw new DataTypeNotSupportedException("The resource identified could not convert into the supported content characteristics (JSON)!", se);
+    } catch (SerializationException se) {
+      throw new DataTypeNotSupportedException(
+          "The resource identified could not convert into the supported content characteristics (JSON)!",
+          se);
+
-    return getValues(regionNamePath, (Object[])keys);
-  }  
-  
-  protected <T extends PdxInstance> Collection<T> getPdxValues(final String regionNamePath, final Object... keys) {
+    return getValues(regionNamePath, (Object[]) keys);
+  }
+
+  protected <T extends PdxInstance> Collection<T> getPdxValues(final String regionNamePath,
+      final Object... keys) {
-    
+
-  
-  protected void deleteValue(final String regionNamePath, final Object key){
+
+  protected void deleteValue(final String regionNamePath, final Object key) {
-  
-  protected void deleteValues(final String regionNamePath, final Object...keys){
-    //Check whether all keys exist in cache or not
-    for(final Object key : keys){
+
+  protected void deleteValues(final String regionNamePath, final Object... keys) {
+    // Check whether all keys exist in cache or not
+    for (final Object key : keys) {
-    
-    for(final Object key : keys){
+
+    for (final Object key : keys) {
-  
-  protected void deleteValues(String regionNamePath){
-    try{
+
+  protected void deleteValues(String regionNamePath) {
+    try {
-    }catch(UnsupportedOperationException ue){
+    } catch (UnsupportedOperationException ue) {
-  
+
-      && rawDataBinding.containsKey(OLD_META_DATA_PROPERTY)
-      && rawDataBinding.containsKey(NEW_META_DATA_PROPERTY));
+        && rawDataBinding.containsKey(OLD_META_DATA_PROPERTY)
+        && rawDataBinding.containsKey(NEW_META_DATA_PROPERTY));
-  
+
-        rawDataBinding.put(OLD_META_DATA_PROPERTY, introspectAndConvert(rawDataBinding.get(OLD_META_DATA_PROPERTY)));
-        rawDataBinding.put(NEW_META_DATA_PROPERTY, introspectAndConvert(rawDataBinding.get(NEW_META_DATA_PROPERTY)));
+        rawDataBinding.put(OLD_META_DATA_PROPERTY,
+            introspectAndConvert(rawDataBinding.get(OLD_META_DATA_PROPERTY)));
+        rawDataBinding.put(NEW_META_DATA_PROPERTY,
+            introspectAndConvert(rawDataBinding.get(NEW_META_DATA_PROPERTY)));
-      }
-      else {
+      } else {
-        
-        //Added for the primitive types put. Not supporting primitive types 
-        if(NumberUtils.isPrimitiveOrObject(typeValue.toString())){ 
+
+        // Added for the primitive types put. Not supporting primitive types
+        if (NumberUtils.isPrimitiveOrObject(typeValue.toString())) {
-            throw new GemfireRestException("Server has encountered error (illegal or inappropriate arguments).", e);  
-          }   
+            throw new GemfireRestException(
+                "Server has encountered error (illegal or inappropriate arguments).", e);
+          }
-          
-          Assert.state(typeValue != null, "The class type of the object to persist in GemFire must be specified in JSON content using the '@type' property!");
-          Assert.state(ClassUtils.isPresent(String.valueOf(typeValue), Thread.currentThread().getContextClassLoader()),
-            String.format("Class (%1$s) could not be found!", typeValue));
-          
-          return (T) objectMapper.convertValue(rawDataBinding, ClassUtils.resolveClassName(String.valueOf(typeValue),
-            Thread.currentThread().getContextClassLoader()));
+
+          Assert.state(typeValue != null,
+              "The class type of the object to persist in GemFire must be specified in JSON content using the '@type' property!");
+          Assert.state(
+              ClassUtils.isPresent(String.valueOf(typeValue),
+                  Thread.currentThread().getContextClassLoader()),
+              String.format("Class (%1$s) could not be found!", typeValue));
+
+          return (T) objectMapper.convertValue(rawDataBinding, ClassUtils.resolveClassName(
+              String.valueOf(typeValue), Thread.currentThread().getContextClassLoader()));
-    return String.format("{\"message\" : \"%1$s\", \"stackTrace\" : \"%2$s\"}", t.getMessage(), writer.toString());
+    return String.format("{\"message\" : \"%1$s\", \"stackTrace\" : \"%2$s\"}", t.getMessage(),
+        writer.toString());
-  protected Map<?,?> convertJsonToMap(final String jsonString) {
-    Map<String,String> map = new HashMap<String,String>();
-    
-    //convert JSON string to Map
+  protected Map<?, ?> convertJsonToMap(final String jsonString) {
+    Map<String, String> map = new HashMap<String, String>();
+
+    // convert JSON string to Map
-      map = objectMapper.readValue(jsonString, new TypeReference<HashMap<String,String>>(){});
+      map = objectMapper.readValue(jsonString, new TypeReference<HashMap<String, String>>() {});
-      throw new MalformedJsonException("Bind params specified as JSON document in the request is incorrect!", e);
+      throw new MalformedJsonException(
+          "Bind params specified as JSON document in the request is incorrect!", e);
-      throw new MalformedJsonException("Server unable to process bind params specified as JSON document in the request!", e);
+      throw new MalformedJsonException(
+          "Server unable to process bind params specified as JSON document in the request!", e);
- }
-  
-  protected Object jsonToObject(final String jsonString) {
-    return introspectAndConvert(convertJsonToMap(jsonString));  
-  
+
+  protected Object jsonToObject(final String jsonString) {
+    return introspectAndConvert(convertJsonToMap(jsonString));
+  }
+
-    if(JSONTypes.JSON_ARRAY.equals(jsonType)){
+    if (JSONTypes.JSON_ARRAY.equals(jsonType)) {
-        JSONArray jsonArray  = new JSONArray(arguments);
-        Object[] args =  new Object[jsonArray.length()];
-        for(int index=0; index < jsonArray.length(); index++) {
-          args[index] = jsonToObject(jsonArray.get(index).toString());  
+        JSONArray jsonArray = new JSONArray(arguments);
+        Object[] args = new Object[jsonArray.length()];
+        for (int index = 0; index < jsonArray.length(); index++) {
+          args[index] = jsonToObject(jsonArray.get(index).toString());
-        throw new MalformedJsonException("Json document specified in request body is not valid!", je);
+        throw new MalformedJsonException("Json document specified in request body is not valid!",
+            je);
-      return new Object[] { jsonToObject(arguments) };
+      return new Object[] {jsonToObject(arguments)};
-    } 
+    }
-  
-  public ResponseEntity<String> updateSingleKey(final String region, final String key, final String json, final String opValue){    
-    
+
+  public ResponseEntity<String> updateSingleKey(final String region, final String key,
+      final String json, final String opValue) {
+
-    
+
-    
+
-      case CAS:  
+      case CAS:
-        
+
-        
+
-        if(JSONTypes.JSON_ARRAY.equals(jsonType)){
+        if (JSONTypes.JSON_ARRAY.equals(jsonType)) {
-          //putValue(region, key, convertJsonIntoPdxCollection(json));
-        }else {
+          // putValue(region, key, convertJsonIntoPdxCollection(json));
+        } else {
-        
+
-    return new ResponseEntity<String>(existingValue, headers, (existingValue == null ? HttpStatus.OK : HttpStatus.CONFLICT));        
+    return new ResponseEntity<String>(existingValue, headers,
+        (existingValue == null ? HttpStatus.OK : HttpStatus.CONFLICT));
-  
-  
-  public ResponseEntity<String> updateMultipleKeys(final String region, final String[] keys, final String json){
-    
+
+
+  public ResponseEntity<String> updateMultipleKeys(final String region, final String[] keys,
+      final String json) {
+
-      jsonArr = new JSONArray(json);  
+      jsonArr = new JSONArray(json);
-  
-    if(jsonArr.length() != keys.length){
-      throw new MalformedJsonException("Each key must have corresponding value (JSON document) specified in the request");
+
+    if (jsonArr.length() != keys.length) {
+      throw new MalformedJsonException(
+          "Each key must have corresponding value (JSON document) specified in the request");
-    
-    Map<Object, PdxInstance> map = new HashMap<Object, PdxInstance>();    
-    for(int i=0; i<keys.length; i++){
+
+    Map<Object, PdxInstance> map = new HashMap<Object, PdxInstance>();
+    for (int i = 0; i < keys.length; i++) {
-        logger.debug("Updating (put) Json document ({}) having key ({}) in Region ({})", json, keys[i], region);
+        logger.debug("Updating (put) Json document ({}) having key ({}) in Region ({})", json,
+            keys[i], region);
-        
+
-        PdxInstance pdxObj = convert( jsonArr.getJSONObject(i).toString());    
+        PdxInstance pdxObj = convert(jsonArr.getJSONObject(i).toString());
-        throw new MalformedJsonException(String.format("JSON document at index (%1$s) in the request body is incorrect", i), e);
+        throw new MalformedJsonException(
+            String.format("JSON document at index (%1$s) in the request body is incorrect", i), e);
-     
-    if(!CollectionUtils.isEmpty(map)){ 
+
+    if (!CollectionUtils.isEmpty(map)) {
-    
+
-  
-  public JSONTypes validateJsonAndFindType(String json){
+
+  public JSONTypes validateJsonAndFindType(String json) {
-    
-      if (jsonObj instanceof JSONObject){
-        return JSONTypes.JSON_OBJECT;    
-      }else if (jsonObj instanceof JSONArray){  
-        return JSONTypes.JSON_ARRAY;  
-      }else {
+
+      if (jsonObj instanceof JSONObject) {
+        return JSONTypes.JSON_OBJECT;
+      } else if (jsonObj instanceof JSONArray) {
+        return JSONTypes.JSON_ARRAY;
+      } else {
-    }    
+    }
-  
+
+    return getValue(regionNamePath, key, true);
+  }
+
+  protected <T> T getValue(final String regionNamePath, final Object key, boolean postProcess) {
-  
+
-      return (T) value;
-    } catch(SerializationException se) {
-      throw new DataTypeNotSupportedException("The resource identified could not convert into the supported content characteristics (JSON)!", se);
-    } catch(NullPointerException npe) {
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not allow null keys!", regionNamePath), npe);
-    } catch(IllegalArgumentException iae) {
-      throw new GemfireRestException(String.format("Resource (%1$s) configuration does not allow requested operation on specified key!", regionNamePath), iae);
-    } catch(LeaseExpiredException lee) {
-      throw new GemfireRestException("Server has encountered error while processing this request!", lee);
-    } catch(TimeoutException te) {
-      throw new GemfireRestException("Server has encountered timeout error while processing this request!", te);
-    } catch(CacheLoaderException cle){
-      throw new GemfireRestException("Server has encountered CacheLoader error while processing this request!", cle);
-    } catch(PartitionedRegionStorageException prse) {
-      throw new GemfireRestException("CacheLoader could not be invoked on partitioned region!", prse);
+      if (postProcess) {
+        return (T) securityService.postProcess(regionNamePath, key, value, false);
+      } else {
+        return (T) value;
+      }
+    } catch (SerializationException se) {
+      throw new DataTypeNotSupportedException(
+          "The resource identified could not convert into the supported content characteristics (JSON)!",
+          se);
+    } catch (NullPointerException npe) {
+      throw new GemfireRestException(
+          String.format("Resource (%1$s) configuration does not allow null keys!", regionNamePath),
+          npe);
+    } catch (IllegalArgumentException iae) {
+      throw new GemfireRestException(String.format(
+          "Resource (%1$s) configuration does not allow requested operation on specified key!",
+          regionNamePath), iae);
+    } catch (LeaseExpiredException lee) {
+      throw new GemfireRestException("Server has encountered error while processing this request!",
+          lee);
+    } catch (TimeoutException te) {
+      throw new GemfireRestException(
+          "Server has encountered timeout error while processing this request!", te);
+    } catch (CacheLoaderException cle) {
+      throw new GemfireRestException(
+          "Server has encountered CacheLoader error while processing this request!", cle);
+    } catch (PartitionedRegionStorageException prse) {
+      throw new GemfireRestException("CacheLoader could not be invoked on partitioned region!",
+          prse);
-    
+
- 
+
-    
-    ValidationUtils.returnValueThrowOnNull(memberIdNames, new GemfireRestException("No member found to run function"));
-    final Set<DistributedMember> targetedMembers = new HashSet<DistributedMember>(ArrayUtils.length(memberIdNames));
+
+    ValidationUtils.returnValueThrowOnNull(memberIdNames,
+        new GemfireRestException("No member found to run function"));
+    final Set<DistributedMember> targetedMembers =
+        new HashSet<DistributedMember>(ArrayUtils.length(memberIdNames));
-    GemFireCacheImpl c = (GemFireCacheImpl)getCache();
-    Set<DistributedMember> distMembers =  c.getDistributedSystem().getAllOtherMembers();
-   
-    //Add the local node to list
-    distMembers.add(c.getDistributedSystem().getDistributedMember());  
+    GemFireCacheImpl c = (GemFireCacheImpl) getCache();
+    Set<DistributedMember> distMembers = c.getDistributedSystem().getAllOtherMembers();
+
+    // Add the local node to list
+    distMembers.add(c.getDistributedSystem().getDistributedMember());
-      if (memberIdNameList.contains(member.getId()) || memberIdNameList.contains(member.getName())) {
+      if (memberIdNameList.contains(member.getId())
+          || memberIdNameList.contains(member.getName())) {
-    GemFireCacheImpl c = (GemFireCacheImpl)getCache();
-    Set<DistributedMember> distMembers =  c.getDistributedSystem().getAllOtherMembers();
+    GemFireCacheImpl c = (GemFireCacheImpl) getCache();
+    Set<DistributedMember> distMembers = c.getDistributedSystem().getAllOtherMembers();
-    
-    //find valid data nodes, i.e non locator, non-admin, non-loner nodes
+
+    // find valid data nodes, i.e non locator, non-admin, non-loner nodes
-      InternalDistributedMember idm = (InternalDistributedMember)member;
+      InternalDistributedMember idm = (InternalDistributedMember) member;
-    //Add the local node to list
+    // Add the local node to list

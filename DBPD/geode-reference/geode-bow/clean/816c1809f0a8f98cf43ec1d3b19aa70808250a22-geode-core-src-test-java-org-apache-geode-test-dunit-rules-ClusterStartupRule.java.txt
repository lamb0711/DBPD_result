GEODE-5306: add crashVM and forceDisconnect in ClusterStartupRule (#2048)

Co-authored-by: Helena Bales <hbales@pivotal.io>
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+import org.awaitility.Awaitility;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.test.dunit.RMIException;
- * A rule to help you start locators and servers inside of a
+ * A rule to help you start locators and servers or clients inside of a
- * by the DUnit framework.
+ * by the DUnit framework. Using this rule will eliminate the need to extends
+ * JUnit4DistributedTestCase when writing a Dunit test
+    if (memberStarter == null || !(memberStarter instanceof LocatorStarterRule)) {
+      return null;
+    }
+    if (memberStarter == null || !(memberStarter instanceof ServerStarterRule)) {
+      return null;
+    }
-      // stop all the clientsVM before stop all the memberVM
-      occupiedVMs.values().forEach(x -> x.stopVMIfNotLocator(true));
-      occupiedVMs.values().forEach(x -> x.stopVM(true));
+      // stop all the members in the order of clients, servers and locators
+      List<VMProvider> vms = new ArrayList<>();
+      vms.addAll(
+          occupiedVMs.values().stream().filter(x -> x.isClient()).collect(Collectors.toSet()));
+      vms.addAll(
+          occupiedVMs.values().stream().filter(x -> x.isServer()).collect(Collectors.toSet()));
+      vms.addAll(
+          occupiedVMs.values().stream().filter(x -> x.isLocator()).collect(Collectors.toSet()));
+      vms.forEach(x -> x.stopMember(true));
-  public void stopVM(int index) {
-    stopVM(index, true);
+  /**
+   * gracefully stop the member inside this vm
+   *
+   * @param index vm index
+   */
+  public void stopMember(int index) {
+    stopMember(index, true);
-  public void stopVM(int index, boolean cleanWorkingDir) {
+  /**
+   * gracefully stop the member inside this vm
+   */
+  public void stopMember(int index, boolean cleanWorkingDir) {
-    member.stopVM(cleanWorkingDir);
+    member.stopMember(cleanWorkingDir);
+  }
+
+  /**
+   * this forces a disconnect of the distributed system of the member.
+   * The member will automatically try to reconnect after 5 seconds.
+   *
+   * will throw a ClassCastException if this method is called on a client VM.
+   */
+  public void forceDisconnectMember(int index) {
+    MemberVM member = getMember(index);
+    if (member == null)
+      return;
+    member.forceDisconnectMember();
+  }
+
+  /**
+   * this crashes the VM hosting the member/client. It removes the VM from the occupied VM list
+   * so that we can ignore it at cleanup.
+   */
+  public void crashVM(int index) {
+    VMProvider member = occupiedVMs.remove(index);
+    member.invokeAsync(() -> {
+      if (InternalDistributedSystem.shutdownHook != null) {
+        Runtime.getRuntime().removeShutdownHook(InternalDistributedSystem.shutdownHook);
+      }
+      System.exit(1);
+    });
+
+    // wait till member is not reachable anymore.
+    Awaitility.await().until(() -> {
+      try {
+        member.invoke(() -> {
+        });
+      } catch (RMIException e) {
+        return true;
+      }
+      return false;
+    });
+
+    // delete the lingering files under this vm
+    Arrays.stream(member.getVM().getWorkingDirectory().listFiles())
+        .forEach(FileUtils::deleteQuietly);
+
+    member.getVM().bounce();

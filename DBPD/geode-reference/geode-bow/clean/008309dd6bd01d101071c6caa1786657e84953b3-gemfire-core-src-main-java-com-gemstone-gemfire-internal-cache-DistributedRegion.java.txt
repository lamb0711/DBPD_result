Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ABSTRACT_REGION_ENTRY_FILL_IN_VALUE;
+
+import com.gemstone.gemfire.internal.cache.control.InternalResourceManager.ResourceType;
+import com.gemstone.gemfire.internal.cache.wan.AbstractGatewaySender;
+import com.gemstone.gemfire.internal.cache.wan.AbstractGatewaySenderEventProcessor;
+import com.gemstone.gemfire.internal.offheap.Chunk;
+import com.gemstone.gemfire.internal.offheap.OffHeapHelper;
+import com.gemstone.gemfire.internal.offheap.annotations.Released;
+import com.gemstone.gemfire.internal.offheap.annotations.Retained;
-import com.gemstone.org.jgroups.util.StringId;
+import com.gemstone.gemfire.i18n.StringId;
-   * A reference counter to protected the heapThresholdReached boolean
+   * A reference counter to protected the memoryThresholdReached boolean
-  private final Set<DistributedMember> heapThresholdReachedMembers =
+  private final Set<DistributedMember> memoryThresholdReachedMembers =
+  private ConcurrentParallelGatewaySenderQueue hdfsQueue;
+
-        cache.getResourceManager().addResourceListener(this);
+        cache.getResourceManager().addResourceListener(ResourceType.MEMORY, this);
-    if (this.entries.size() > 0) {
-      this.entries.clear(null);
+    if (!this.entries.isEmpty()) {
+      closeEntries();
-        this.entries.clear(rvv);
+        clearEntries(rvv);
+    profile.isOffHeap = getOffHeap();
+  @Retained
-        boolean preferCD, ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent, boolean returnTombstones)
+        boolean preferCD, ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent, boolean returnTombstones, boolean allowReadFromHDFS)
+    @Retained Object result = null;
+    boolean incrementUseCountForSqlf = false;
+    try {
+        try {
-          event = new EntryEventImpl(this, op, key, value,
+          event = EntryEventImpl.create(this, op, key, value,
+        } finally {
+          holder.release();
+        }
-      event = new EntryEventImpl(this, op, key, null /*newValue*/,
+      event = EntryEventImpl.create(this, op, key, null /*newValue*/,
-    if (event.hasNewValue() && !isHeapThresholdReachedForLoad()) {
+    if (event.hasNewValue() && !isMemoryThresholdReachedForLoad()) {
-          
+          incrementUseCountForSqlf = GemFireCacheImpl.sqlfSystem() ;
-    Object result;
+    
-      result = event.getRawNewValue();
-      // fix for bug 42895
-      if (!(result instanceof CachedDeserializable)) {
+      if (event.hasDelta()) {
-      }
+      } else {
+        result = event.getRawNewValueAsHeapObject();
+      }    
-      result = event.getNewValue();
+      result = event.getNewValue();     
+    }
+    //For SQLFire , we need to increment the use count so that returned
+    //object has use count 2
+    if( incrementUseCountForSqlf && result instanceof Chunk) {
+      ((Chunk)result).retain();
+    } finally {
+      if (event != null) {
+        event.release();        
+      }
+    }
+  }
+  
+  protected ConcurrentParallelGatewaySenderQueue getHDFSQueue() {
+    if (this.hdfsQueue == null) {
+      String asyncQId = this.getPartitionedRegion().getHDFSEventQueueName();
+      final AsyncEventQueueImpl asyncQ =  (AsyncEventQueueImpl)this.getCache().getAsyncEventQueue(asyncQId);
+      final AbstractGatewaySender gatewaySender = (AbstractGatewaySender)asyncQ.getSender();
+      AbstractGatewaySenderEventProcessor ep = gatewaySender.getEventProcessor();
+      if (ep == null) return null;
+      hdfsQueue = (ConcurrentParallelGatewaySenderQueue)ep.getQueue();
+    }
+    return hdfsQueue;
-    if (isBridgeWriter(oldWriter)) {
-      oldWriter = null;
-    }
-    if (isBridgeLoader(oldLoader)) {
-      oldLoader = null;
-    }
-        InternalDistributedMember whoSuspected) {
+        InternalDistributedMember whoSuspected, String reason) {
-  protected void setHeapThresholdFlag(MemoryEvent event) {
+  protected void setMemoryThresholdFlag(MemoryEvent event) {
-      if (event.getType().isCriticalUp()) {
-        setHeapThresholdReachedCounterTrue(event.getMember());
-      } else if (event.getType().isCriticalDown() || event.getType().isCriticalDisabled()) {
+      if (event.getState().isCritical()
+          && !event.getPreviousState().isCritical()
+          && (event.getType() == ResourceType.HEAP_MEMORY || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
+        setMemoryThresholdReachedCounterTrue(event.getMember());
+      } else if (!event.getState().isCritical()
+          && event.getPreviousState().isCritical()
+          && (event.getType() == ResourceType.HEAP_MEMORY || (event.getType() == ResourceType.OFFHEAP_MEMORY && getOffHeap()))) {
-    synchronized(this.heapThresholdReachedMembers) {
-      this.heapThresholdReachedMembers.remove(member);
-      if (this.heapThresholdReachedMembers.size() == 0) {
-        heapThresholdReached.set(false);
+    synchronized(this.memoryThresholdReachedMembers) {
+      this.memoryThresholdReachedMembers.remove(member);
+      if (this.memoryThresholdReachedMembers.size() == 0) {
+        memoryThresholdReached.set(false);
-  public Set<DistributedMember> getHeapThresholdReachedMembers() {
-    synchronized (this.heapThresholdReachedMembers) {
-      return Collections.unmodifiableSet(this.heapThresholdReachedMembers);
+  public Set<DistributedMember> getMemoryThresholdReachedMembers() {
+    synchronized (this.memoryThresholdReachedMembers) {
+      return Collections.unmodifiableSet(this.memoryThresholdReachedMembers);
-  public void initialCriticalMembers(boolean localHeapIsCritical,
+  public void initialCriticalMembers(boolean localMemoryIsCritical,
-        setHeapThresholdReachedCounterTrue(idm);
+        setMemoryThresholdReachedCounterTrue(idm);
-  private void setHeapThresholdReachedCounterTrue(final DistributedMember idm) {
-    synchronized(this.heapThresholdReachedMembers) {
-      this.heapThresholdReachedMembers.add(idm);
-      if (this.heapThresholdReachedMembers.size() > 0) {
-        heapThresholdReached.set(true);
+  private void setMemoryThresholdReachedCounterTrue(final DistributedMember idm) {
+    synchronized(this.memoryThresholdReachedMembers) {
+      this.memoryThresholdReachedMembers.add(idm);
+      if (this.memoryThresholdReachedMembers.size() > 0) {
+        memoryThresholdReached.set(true);

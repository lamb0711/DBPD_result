Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public final class QueryMessage extends StreamingPartitionOperation.StreamingPartitionMessage
-  {
+public final class QueryMessage extends StreamingPartitionOperation.StreamingPartitionMessage {
-  
+
-//  private transient PRQueryResultCollector resultCollector = new PRQueryResultCollector();
+  // private transient PRQueryResultCollector resultCollector = new PRQueryResultCollector();
-  public QueryMessage(InternalDistributedMember recipient,  int regionId, ReplyProcessor21 processor,
+  public QueryMessage(InternalDistributedMember recipient, int regionId, ReplyProcessor21 processor,
-  /**  Provide results to send back to requestor.
-    *  terminate by returning END_OF_STREAM token object
-    */
+  /**
+   * Provide results to send back to requestor. terminate by returning END_OF_STREAM token object
+   */
-  throws CacheException, ForceReattemptException, InterruptedException {
+      throws CacheException, ForceReattemptException, InterruptedException {
-    
+
-      String reason = LocalizedStrings.QueryMonitor_LOW_MEMORY_CANCELED_QUERY.toLocalizedString(QueryMonitor.getMemoryUsedDuringLowMemory());
+      String reason = LocalizedStrings.QueryMonitor_LOW_MEMORY_CANCELED_QUERY
+          .toLocalizedString(QueryMonitor.getMemoryUsedDuringLowMemory());
-    if (Thread.interrupted()) throw new InterruptedException();
-    
+    if (Thread.interrupted())
+      throw new InterruptedException();
+
-        if(this.isTraceInfoIteration && this.currentResultIterator != null) {
+        if (this.isTraceInfoIteration && this.currentResultIterator != null) {
-        //Assert.assertTrue(this.resultCollector.isEmpty());
+        // Assert.assertTrue(this.resultCollector.isEmpty());
-    boolean isPostGFE_8_1 = this.getSender().getVersionObject().compareTo(Version.GFE_81) > 0 ;
-    //Asif: There is a bug in older versions of GFE such that the query node expects the structs to have
-    // type as ObjectTypes only & not specific types. So the new version needs to send the inaccurate 
-    //struct type for backward compatibility.
-    if(this.isStructType && !this.isTraceInfoIteration && isPostGFE_8_1) {
-      return ((Struct)data).getFieldValues(); 
-    }else if(this.isStructType && !this.isTraceInfoIteration) {
-      Struct s = (Struct)data;
+    boolean isPostGFE_8_1 = this.getSender().getVersionObject().compareTo(Version.GFE_81) > 0;
+    // Asif: There is a bug in older versions of GFE such that the query node expects the structs to
+    // have
+    // type as ObjectTypes only & not specific types. So the new version needs to send the
+    // inaccurate
+    // struct type for backward compatibility.
+    if (this.isStructType && !this.isTraceInfoIteration && isPostGFE_8_1) {
+      return ((Struct) data).getFieldValues();
+    } else if (this.isStructType && !this.isTraceInfoIteration) {
+      Struct s = (Struct) data;
-      for(int i = 0; i < fieldTypes.length; ++i) {
+      for (int i = 0; i < fieldTypes.length; ++i) {
-    }else {
+    } else {
-  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion r, long startTime)
-  throws CacheException, QueryException, ForceReattemptException, InterruptedException {
-    //calculate trace start time if trace is on
-    //this is because the start time is only set if enableClock stats is on
-    //in this case we still want to see trace time even if clock is not enabled
+  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion r,
+      long startTime)
+      throws CacheException, QueryException, ForceReattemptException, InterruptedException {
+    // calculate trace start time if trace is on
+    // this is because the start time is only set if enableClock stats is on
+    // in this case we still want to see trace time even if clock is not enabled
-    PRQueryTraceInfo queryTraceInfo = null; 
+    PRQueryTraceInfo queryTraceInfo = null;
-    if (Thread.interrupted()) throw new InterruptedException();
+    if (Thread.interrupted())
+      throw new InterruptedException();
-      logger.trace(LogMarker.DM, "QueryMessage operateOnPartitionedRegion: {} buckets {}", r.getFullPath(), buckets);
+      logger.trace(LogMarker.DM, "QueryMessage operateOnPartitionedRegion: {} buckets {}",
+          r.getFullPath(), buckets);
-    //PartitionedRegionDataStore ds = r.getDataStore();
+    // PartitionedRegionDataStore ds = r.getDataStore();
-    //if (ds != null) {
+    // if (ds != null) {
-      String reason = LocalizedStrings.QueryMonitor_LOW_MEMORY_CANCELED_QUERY.toLocalizedString(QueryMonitor.getMemoryUsedDuringLowMemory());
-      //throw query exception to piggyback on existing error handling as qp.executeQuery also throws the same error for low memory
+      String reason = LocalizedStrings.QueryMonitor_LOW_MEMORY_CANCELED_QUERY
+          .toLocalizedString(QueryMonitor.getMemoryUsedDuringLowMemory());
+      // throw query exception to piggyback on existing error handling as qp.executeQuery also
+      // throws the same error for low memory
-    
+
-      isQueryTraced = query.isTraced() && this.sender.getVersionObject().compareTo(Version.GFE_81) >= 0;
+      isQueryTraced =
+          query.isTraced() && this.sender.getVersionObject().compareTo(Version.GFE_81) >= 0;
-        
+
-      //Add the trace info list object after the NWayMergeResults is created so as to 
-      //exclude it from the sorted collection of NWayMergeResults
-      if(isQueryTraced) {
-        this.resultCollector.add(0,queryTraceList);
+      // Add the trace info list object after the NWayMergeResults is created so as to
+      // exclude it from the sorted collection of NWayMergeResults
+      if (isQueryTraced) {
+        this.resultCollector.add(0, queryTraceList);
-    //}
-    //else {
-    //  l.warning(LocalizedStrings.QueryMessage_QUERYMESSAGE_DATA_STORE_NOT_CONFIGURED_FOR_THIS_MEMBER);
-    //}
+    // }
+    // else {
+    // l.warning(LocalizedStrings.QueryMessage_QUERYMESSAGE_DATA_STORE_NOT_CONFIGURED_FOR_THIS_MEMBER);
+    // }
-  protected void appendFields(StringBuffer buff)
-  {
+  protected void appendFields(StringBuffer buff) {
-    buff.append("; query=").append(this.queryString)
-    .append("; bucketids=").append(this.buckets);
+    buff.append("; query=").append(this.queryString).append("; bucketids=").append(this.buckets);
-  /** send a reply message.  This is in a method so that subclasses can override the reply message type
-   *  @see PutMessage#sendReply
+  /**
+   * send a reply message. This is in a method so that subclasses can override the reply message
+   * type
+   * 
+   * @see PutMessage#sendReply
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex, PartitionedRegion pr, long startTime) {
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+      PartitionedRegion pr, long startTime) {
-    StreamingReplyMessage.send(member, procId, ex, dm, this.outStream,
-        this.numObjectsInChunk, this.replyMsgNum,
-        this.replyLastMsg, this.isPdxSerialized);
+    StreamingReplyMessage.send(member, procId, ex, dm, this.outStream, this.numObjectsInChunk,
+        this.replyMsgNum, this.replyLastMsg, this.isPdxSerialized);
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException
-  {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-  public void toData(DataOutput out) throws IOException
-  {
+  public void toData(DataOutput out) throws IOException {
-    DataSerializer.writeArrayList((ArrayList)this.buckets, out);
+    DataSerializer.writeArrayList((ArrayList) this.buckets, out);
-  
+

Merge branch 'develop' into feature/GEODE-7049

-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.locks.ReadWriteLock;
-import java.util.concurrent.locks.ReentrantLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import org.apache.geode.internal.concurrent.ConcurrentHashSet;
-class ClientRegistrationEventQueueManager {
+public class ClientRegistrationEventQueueManager {
-  private final Map<ClientProxyMembershipID, ClientRegistrationEventQueue> registeringProxyEventQueues =
-      new ConcurrentHashMap<>();
+  private final Set<ClientRegistrationEventQueue> registeringProxyEventQueues =
+      new ConcurrentHashSet<>();
-    for (final Map.Entry<ClientProxyMembershipID, ClientRegistrationEventQueue> eventsReceivedWhileRegisteringClient : registeringProxyEventQueues
-        .entrySet()) {
-      ClientProxyMembershipID clientProxyMembershipID =
-          eventsReceivedWhileRegisteringClient.getKey();
-      ClientRegistrationEventQueue registrationEventQueue =
-          eventsReceivedWhileRegisteringClient.getValue();
-
+    for (final ClientRegistrationEventQueue registrationEventQueue : registeringProxyEventQueues) {
+        ClientProxyMembershipID clientProxyMembershipID =
+            registrationEventQueue.getClientProxyMembershipID();
+
-        if (registeringProxyEventQueues.containsKey(clientProxyMembershipID)) {
+        if (registeringProxyEventQueues.contains(registrationEventQueue)) {
-          processEventAndDeliverConflatable(clientProxyMembershipID, cacheClientNotifier, event,
+          CacheClientProxy cacheClientProxy =
+              cacheClientNotifier.getClientProxy(clientProxyMembershipID);
+
+          processEventAndDeliverConflatable(cacheClientProxy, cacheClientNotifier, event,
+  void drain(final ClientRegistrationEventQueue clientRegistrationEventQueue,
+      final CacheClientNotifier cacheClientNotifier) {
+    try {
+      ClientProxyMembershipID clientProxyMembershipID =
+          clientRegistrationEventQueue.getClientProxyMembershipID();
+
+      if (logger.isDebugEnabled()) {
+        logger.debug("Draining events from registration queue for client proxy "
+            + clientProxyMembershipID
+            + " without synchronization");
+      }
+
+      CacheClientProxy cacheClientProxy = cacheClientNotifier
+          .getClientProxy(clientProxyMembershipID);
+
+      drainEventsReceivedWhileRegisteringClient(
+          cacheClientProxy,
+          clientRegistrationEventQueue,
+          cacheClientNotifier);
+
+      // Prevents additional events from being added to the queue while we process and remove it
+      clientRegistrationEventQueue.lockForDraining();
+
+      if (logger.isDebugEnabled()) {
+        logger.debug("Draining remaining events from registration queue for client proxy "
+            + clientProxyMembershipID
+            + " with synchronization");
+      }
+
+      drainEventsReceivedWhileRegisteringClient(
+          cacheClientProxy,
+          clientRegistrationEventQueue,
+          cacheClientNotifier);
+    } finally {
+      // The queue must be removed before attempting to release the drain lock
+      // so that no additional events can be added from add threads.
+      registeringProxyEventQueues.remove(clientRegistrationEventQueue);
+
+      if (clientRegistrationEventQueue.isLockForDrainingHeld()) {
+        clientRegistrationEventQueue.unlockForDraining();
+      }
+    }
+  }
+
+  ClientRegistrationEventQueue create(
+      final ClientProxyMembershipID clientProxyMembershipID,
+      final Queue<ClientRegistrationEvent> eventQueue,
+      final ReentrantReadWriteLock eventAddDrainLock) {
+    final ClientRegistrationEventQueue clientRegistrationEventQueue =
+        new ClientRegistrationEventQueue(clientProxyMembershipID, eventQueue,
+            eventAddDrainLock);
+    registeringProxyEventQueues.add(clientRegistrationEventQueue);
+    return clientRegistrationEventQueue;
+  }
+
+  private void processEventAndDeliverConflatable(final CacheClientProxy cacheClientProxy,
+      final CacheClientNotifier cacheClientNotifier,
+      final InternalCacheEvent internalCacheEvent,
+      final Conflatable conflatable,
+      final Set<ClientProxyMembershipID> originalFilterClientIDs) {
+    try {
+      // If the cache client proxy is null, the registration was not successful and the proxy
+      // was never added to the initialized proxy collection managed by the cache client notifier.
+      // If that is the case, we can just decrement the put in progress counter on the conflatable
+      // if it is an HAEventWrapper.
+      if (cacheClientProxy != null) {
+        // The first step is to repopulate the filter info for the event to determine if
+        // the client which was registering has a matching CQ or has registered interest
+        // in the key for this event. We need to get the filter profile, filter routing info,
+        // and local filter info in order to do so. If any of these are null, then there is
+        // no need to proceed as the client is not interested.
+        FilterProfile filterProfile =
+            ((LocalRegion) internalCacheEvent.getRegion()).getFilterProfile();
+
+        if (filterProfile != null) {
+          FilterRoutingInfo filterRoutingInfo =
+              filterProfile.getFilterRoutingInfoPart2(null, internalCacheEvent);
+
+          if (filterRoutingInfo != null) {
+            FilterRoutingInfo.FilterInfo filterInfo = filterRoutingInfo.getLocalFilterInfo();
+
+            if (filterInfo != null) {
+              ClientUpdateMessageImpl clientUpdateMessage = conflatable instanceof HAEventWrapper
+                  ? (ClientUpdateMessageImpl) ((HAEventWrapper) conflatable)
+                      .getClientUpdateMessage()
+                  : (ClientUpdateMessageImpl) conflatable;
+
+              internalCacheEvent.setLocalFilterInfo(filterInfo);
+
+              Set<ClientProxyMembershipID> newFilterClientIDs =
+                  cacheClientNotifier.getFilterClientIDs(internalCacheEvent, filterProfile,
+                      filterInfo,
+                      clientUpdateMessage);
+
+              ClientProxyMembershipID proxyID = cacheClientProxy.getProxyID();
+              if (eventNotInOriginalFilterClientIDs(proxyID, newFilterClientIDs,
+                  originalFilterClientIDs) && newFilterClientIDs.contains(proxyID)) {
+                cacheClientProxy.deliverMessage(conflatable);
+              }
+            }
+          }
+        }
+      }
+    } finally {
+      // Once we have processed the conflatable, if it is an HAEventWrapper we can
+      // decrement the PutInProgress counter, allowing the ClientUpdateMessage to be
+      // set to null. See decrementPutInProgressCounter() for more details.
+      if (conflatable instanceof HAEventWrapper) {
+        ((HAEventWrapper) conflatable).decrementPutInProgressCounter();
+      }
+    }
+  }
+
+  /*
+   * This is to handle the edge case where the original filter client IDs
+   * calculated by "normal" put processing did not include the registering client
+   * because the filter info had not been received yet, but we now found that the client
+   * is interested in the event so we should deliver it.
+   */
+  private boolean eventNotInOriginalFilterClientIDs(final ClientProxyMembershipID proxyID,
+      final Set<ClientProxyMembershipID> newFilterClientIDs,
+      final Set<ClientProxyMembershipID> originalFilterClientIDs) {
+    return originalFilterClientIDs == null
+        || (!originalFilterClientIDs.contains(proxyID) && newFilterClientIDs.contains(proxyID));
+  }
+
-  void drain(final ClientProxyMembershipID clientProxyMembershipID,
-      final CacheClientNotifier cacheClientNotifier) {
-    ClientRegistrationEventQueue registrationEventQueue =
-        registeringProxyEventQueues.get(clientProxyMembershipID);
-
-    if (registrationEventQueue != null) {
-      // It is possible that several client registration threads are active for the same
-      // ClientProxyMembershipID, in which case we only want a single drainer to drain
-      // and remove the queue.
-      registrationEventQueue.lockForSingleDrainer();
-      try {
-        // See if the queue is still available after acquiring the lock as it may have
-        // been removed from registeringProxyEventQueues by the previous thread
-        if (registeringProxyEventQueues.containsKey(clientProxyMembershipID)) {
-          // As an optimization, we drain as many events from the queue as we can
-          // before taking out a lock to drain the remaining events. When we lock for draining,
-          // it prevents additional events from being added to the queue while the queue is drained
-          // and removed.
-          if (logger.isDebugEnabled()) {
-            logger.debug("Draining events from registration queue for client proxy "
-                + clientProxyMembershipID
-                + " without synchronization");
-          }
-
-          drainEventsReceivedWhileRegisteringClient(clientProxyMembershipID, registrationEventQueue,
-              cacheClientNotifier);
-
-          // Prevents additional events from being added to the queue while we process and remove it
-          registrationEventQueue.lockForDraining();
-          try {
-            if (logger.isDebugEnabled()) {
-              logger.debug("Draining remaining events from registration queue for client proxy "
-                  + clientProxyMembershipID + " with synchronization");
-            }
-
-            drainEventsReceivedWhileRegisteringClient(clientProxyMembershipID,
-                registrationEventQueue,
-                cacheClientNotifier);
-
-            registeringProxyEventQueues.remove(clientProxyMembershipID);
-          } finally {
-            registrationEventQueue.unlockForDraining();
-          }
-        }
-      } finally {
-        registrationEventQueue.unlockForSingleDrainer();
-      }
-    }
-  }
-
-  private void drainEventsReceivedWhileRegisteringClient(final ClientProxyMembershipID proxyID,
+  private void drainEventsReceivedWhileRegisteringClient(
+      final CacheClientProxy cacheClientProxy,
-      processEventAndDeliverConflatable(proxyID, cacheClientNotifier, internalCacheEvent,
-          conflatable, null);
+      processEventAndDeliverConflatable(cacheClientProxy,
+          cacheClientNotifier, internalCacheEvent, conflatable, null);
-  public ClientRegistrationEventQueue create(
-      final ClientProxyMembershipID clientProxyMembershipID,
-      final Queue<ClientRegistrationEvent> eventQueue,
-      final ReadWriteLock eventAddDrainLock,
-      final ReentrantLock singleDrainerLock) {
-    final ClientRegistrationEventQueue clientRegistrationEventQueue =
-        new ClientRegistrationEventQueue(eventQueue,
-            eventAddDrainLock, singleDrainerLock);
-    registeringProxyEventQueues.putIfAbsent(clientProxyMembershipID,
-        clientRegistrationEventQueue);
-    return clientRegistrationEventQueue;
+  /**
+   * Represents a conflatable and event processed while a client was registering.
+   * This needs to be queued and processed after registration is complete. The conflatable
+   * is what we will actually be delivering to the MessageDispatcher (and thereby adding
+   * to the HARegionQueue). The internal cache event is required to rehydrate the filter
+   * info and determine if the client which was registering does have a CQ that matches or
+   * has registered interest in the key.
+   */
+  private class ClientRegistrationEvent {
+    private final Conflatable conflatable;
+    private final InternalCacheEvent internalCacheEvent;
+
+    ClientRegistrationEvent(final InternalCacheEvent internalCacheEvent,
+        final Conflatable conflatable) {
+      this.conflatable = conflatable;
+      this.internalCacheEvent = internalCacheEvent;
+    }
+    private final ClientProxyMembershipID clientProxyMembershipID;
-    private final ReadWriteLock eventAddDrainLock;
-    private final ReentrantLock singleDrainerLock;
+    private final ReentrantReadWriteLock eventAddDrainLock;
+        final ClientProxyMembershipID clientProxyMembershipID,
-        final ReadWriteLock eventAddDrainLock,
-        final ReentrantLock singleDrainerLock) {
+        final ReentrantReadWriteLock eventAddDrainLock) {
+      this.clientProxyMembershipID = clientProxyMembershipID;
-      this.singleDrainerLock = singleDrainerLock;
+    }
+
+    public ClientProxyMembershipID getClientProxyMembershipID() {
+      return clientProxyMembershipID;
+    private boolean isLockForDrainingHeld() {
+      return eventAddDrainLock.writeLock().isHeldByCurrentThread();
+    }
+
-
-    private void lockForSingleDrainer() {
-      singleDrainerLock.lock();
-    }
-
-    private void unlockForSingleDrainer() {
-      singleDrainerLock.unlock();
-    }
-  }
-
-  private void processEventAndDeliverConflatable(final ClientProxyMembershipID proxyID,
-      final CacheClientNotifier cacheClientNotifier,
-      final InternalCacheEvent internalCacheEvent,
-      final Conflatable conflatable,
-      final Set<ClientProxyMembershipID> originalFilterClientIDs) {
-    // The first step is to repopulate the filter info for the event to determine if
-    // the client which was registering has a matching CQ or has registered interest
-    // in the key for this event. We need to get the filter profile, filter routing info,
-    // and local filter info in order to do so. If any of these are null, then there is
-    // no need to proceed as the client is not interested.
-    FilterProfile filterProfile =
-        ((LocalRegion) internalCacheEvent.getRegion()).getFilterProfile();
-
-    if (filterProfile != null) {
-      FilterRoutingInfo filterRoutingInfo =
-          filterProfile.getFilterRoutingInfoPart2(null, internalCacheEvent);
-
-      if (filterRoutingInfo != null) {
-        FilterRoutingInfo.FilterInfo filterInfo = filterRoutingInfo.getLocalFilterInfo();
-
-        if (filterInfo != null) {
-          ClientUpdateMessageImpl clientUpdateMessage = conflatable instanceof HAEventWrapper
-              ? (ClientUpdateMessageImpl) ((HAEventWrapper) conflatable).getClientUpdateMessage()
-              : (ClientUpdateMessageImpl) conflatable;
-
-          internalCacheEvent.setLocalFilterInfo(filterInfo);
-
-          Set<ClientProxyMembershipID> newFilterClientIDs =
-              cacheClientNotifier.getFilterClientIDs(internalCacheEvent, filterProfile,
-                  filterInfo,
-                  clientUpdateMessage);
-
-          if (eventNotInOriginalFilterClientIDs(proxyID, newFilterClientIDs,
-              originalFilterClientIDs)) {
-            CacheClientProxy cacheClientProxy = cacheClientNotifier.getClientProxy(proxyID);
-
-            if (eventShouldBeDelivered(proxyID, newFilterClientIDs, cacheClientProxy)) {
-              cacheClientProxy.deliverMessage(conflatable);
-            }
-          }
-        }
-      }
-    }
-
-    // Once we have processed the conflatable, if it is an HAEventWrapper we can
-    // decrement the PutInProgress counter, allowing the ClientUpdateMessage to be
-    // set to null. See decrementPutInProgressCounter() for more details.
-    if (conflatable instanceof HAEventWrapper) {
-      ((HAEventWrapper) conflatable).decrementPutInProgressCounter();
-    }
-  }
-
-  private boolean eventShouldBeDelivered(final ClientProxyMembershipID proxyID,
-      final Set<ClientProxyMembershipID> filterClientIDs,
-      final CacheClientProxy cacheClientProxy) {
-    return filterClientIDs.contains(proxyID) && cacheClientProxy != null;
-  }
-
-  /*
-   * This is to handle the edge case where the original filter client IDs
-   * calculated by "normal" put processing did not include the registering client
-   * because the filter info had not been received yet, but we now found that the client
-   * is interested in the event so we should deliver it.
-   */
-  private boolean eventNotInOriginalFilterClientIDs(final ClientProxyMembershipID proxyID,
-      final Set<ClientProxyMembershipID> newFilterClientIDs,
-      final Set<ClientProxyMembershipID> originalFilterClientIDs) {
-    return originalFilterClientIDs == null
-        || (!originalFilterClientIDs.contains(proxyID) && newFilterClientIDs.contains(proxyID));
-  }
-
-  /**
-   * Represents a conflatable and event processed while a client was registering.
-   * This needs to be queued and processed after registration is complete. The conflatable
-   * is what we will actually be delivering to the MessageDispatcher (and thereby adding
-   * to the HARegionQueue). The internal cache event is required to rehydrate the filter
-   * info and determine if the client which was registering does have a CQ that matches or
-   * has registered interest in the key.
-   */
-  private class ClientRegistrationEvent {
-    private final Conflatable conflatable;
-    private final InternalCacheEvent internalCacheEvent;
-
-    ClientRegistrationEvent(final InternalCacheEvent internalCacheEvent,
-        final Conflatable conflatable) {
-      this.conflatable = conflatable;
-      this.internalCacheEvent = internalCacheEvent;
-    }

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-  
-  private FunctionRemoteContext context ;  
+
+  private FunctionRemoteContext context;
-  
-  public PartitionedRegionFunctionStreamingMessage(
-      InternalDistributedMember recipient, int regionId,
-      ReplyProcessor21 processor, FunctionRemoteContext context) {
+
+  public PartitionedRegionFunctionStreamingMessage(InternalDistributedMember recipient,
+      int regionId, ReplyProcessor21 processor, FunctionRemoteContext context) {
-   * An operation upon the messages partitioned region. Here we have to execute
-   * the function and send the result one by one.
+   * An operation upon the messages partitioned region. Here we have to execute the function and
+   * send the result one by one.
-  protected boolean operateOnPartitionedRegion(DistributionManager dm,
-      PartitionedRegion r, long startTime) {
+  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion r,
+      long startTime) {
-      logger.trace(LogMarker.DM, "PartitionedRegionFunctionResultStreamerMessage operateOnRegion: {}",  r.getFullPath());
+      logger.trace(LogMarker.DM,
+          "PartitionedRegionFunctionResultStreamerMessage operateOnRegion: {}", r.getFullPath());
-    
+
-      sendReply(getSender(), getProcessorId(), dm, new ReplyException(
-          new FunctionException(LocalizedStrings.ExecuteFunction_FUNCTION_NAMED_0_IS_NOT_REGISTERED
-              .toLocalizedString(this.context.getFunctionId()))), r, startTime);
+      sendReply(getSender(), getProcessorId(), dm,
+          new ReplyException(new FunctionException(
+              LocalizedStrings.ExecuteFunction_FUNCTION_NAMED_0_IS_NOT_REGISTERED
+                  .toLocalizedString(this.context.getFunctionId()))),
+          r, startTime);
-      ds.executeOnDataStore(context.getFilter(), context.getFunction(), context
-          .getArgs(), getProcessorId(), context.getBucketSet(), context
-          .isReExecute(), this, startTime, null, 0);
-              
+      ds.executeOnDataStore(context.getFilter(), context.getFunction(), context.getArgs(),
+          getProcessorId(), context.getBucketSet(), context.isReExecute(), this, startTime, null,
+          0);
+
-        sendReply(
-            getSender(),
-            getProcessorId(),
-            dm,
-            new ReplyException(
-                new FunctionException(
-                    LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT
-                        .toString(context.getFunction().getId()))), r,
-            startTime);
+        sendReply(getSender(), getProcessorId(), dm,
+            new ReplyException(new FunctionException(
+                LocalizedStrings.ExecuteFunction_THE_FUNCTION_0_DID_NOT_SENT_LAST_RESULT
+                    .toString(context.getFunction().getId()))),
+            r, startTime);
-    }
-    else {
+    } else {
-   * It sends message one by one until it gets lastMessage. Have to handle
-   * scenario when message is large, in that case message will be broken into
-   * chunks and then sent across.
+   * It sends message one by one until it gets lastMessage. Have to handle scenario when message is
+   * large, in that case message will be broken into chunks and then sent across.
-  public synchronized boolean sendReplyForOneResult(DM dm,
-      PartitionedRegion pr, long startTime, Object oneResult,
-      boolean lastResult, boolean sendResultsInOrder) throws CacheException,
-      ForceReattemptException, InterruptedException {
-    if(this.replyLastMsg) {
+  public synchronized boolean sendReplyForOneResult(DM dm, PartitionedRegion pr, long startTime,
+      Object oneResult, boolean lastResult, boolean sendResultsInOrder)
+      throws CacheException, ForceReattemptException, InterruptedException {
+    if (this.replyLastMsg) {
-    sendReply(getSender(), this.processorId, dm, null, oneResult, pr, startTime,
-        msgNum, lastResult, sendResultsInOrder);
-    
+    sendReply(getSender(), this.processorId, dm, null, oneResult, pr, startTime, msgNum, lastResult,
+        sendResultsInOrder);
+
-    
+
-  
-    
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm,
-      ReplyException ex, Object result, PartitionedRegion pr, long startTime,
-      int msgNum, boolean lastResult, boolean sendResultsInOrder) {
+
+
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+      Object result, PartitionedRegion pr, long startTime, int msgNum, boolean lastResult,
+      boolean sendResultsInOrder) {
-      FunctionStreamingOrderedReplyMessage.send(member, procId, ex, dm, result,
-          msgNum, lastResult);
-    }
-    else {
-      FunctionStreamingReplyMessage.send(member, procId, ex, dm, result,
-          msgNum, lastResult);
+      FunctionStreamingOrderedReplyMessage.send(member, procId, ex, dm, result, msgNum, lastResult);
+    } else {
+      FunctionStreamingReplyMessage.send(member, procId, ex, dm, result, msgNum, lastResult);
-    this.context =  DataSerializer.readObject(in);    
+    this.context = DataSerializer.readObject(in);
-    DataSerializer.writeObject(this.context, out);   
+    DataSerializer.writeObject(this.context, out);
-  
+
-	return true;
+    return true;
-  
+

GEODE-6808: Restore JSON backward compatibility (#3688)

* GEODE-6808: Revert test changes & add new checks

- Added new unit tests.
- Reverted changes made to tests during the replacement of TypedJson
to be sure backward compatibility is achieved after the implementation
of this ticket.

* GEODE-6808: Restore JSON backward compatibility

Reverted some of the changes made when deleting the in-house JSON
implementation (TypedJson) to the jackson library
('QueryResultFormatter') to restore the backward compatibility.

- Everything is serialized as JSON array with 2 elements: type & value.
- Internal class names are hidden in the JSON document, public
  interfaces are included instead.
- Beans and primitive types only use the standard format when they are
  not being serialized as part of an array, in which case the type is
  ignored as it's already been serialized as ArrayElementType[].
+import java.util.HashSet;
+import java.util.Set;
+import org.apache.geode.cache.query.Struct;
+import org.apache.geode.management.internal.cli.util.JsonUtil;
+import org.apache.geode.pdx.internal.PdxInstanceImpl;
-
+  final boolean generateTypeInformation;
+  final Set<Class> nonOverridableSerializers;
-  /**
+  /*
-    this.serializedObjects = new IdentityHashMap<>();
+    this.serializedObjects = new IdentityHashMap<>();
+    this.generateTypeInformation = generateTypeInformation;
+    this.nonOverridableSerializers = new HashSet<>();
-    SimpleModule mapperModule =
-        new PreventReserializationModule(serializedObjects, serDepth);
+    SimpleModule mapperModule = new PreventReserializationModule(serializedObjects, serDepth);
+
+    // insert a Struct serializer that knows about its format
+    mapperModule.addSerializer(StructImpl.class, new StructSerializer());
+    nonOverridableSerializers.add(StructImpl.class);
+
+    // insert a PdxInstance serializer that knows about PDX fields/values
+    mapperModule.addSerializer(PdxInstance.class, new PdxInstanceSerializer());
+    nonOverridableSerializers.add(PdxInstanceImpl.class);
+
+    // insert a RegionEntry serializer because they're too messy looking
+    mapperModule.addSerializer(Region.Entry.class, new RegionEntrySerializer());
+    nonOverridableSerializers.add(Region.Entry.class);
-    // insert a PdxInstance serializer that knows about PDX fields/values
-    mapperModule.addSerializer(PdxInstance.class, new PdxInstanceSerializer());
-    // insert a Struct serializer that knows about its format
-    mapperModule.addSerializer(StructImpl.class, new StructSerializer());
-    // insert a RegionEntry serializer because they're too messy looking
-    mapperModule.addSerializer(Region.Entry.class, new RegionEntrySerializer());
+    // register the custom module
-    if (generateTypeInformation) {
-      // add type information (Jackson has no way to force it to do this for all values)
-      mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
-    }
-
+  // TODO: Re-Implement this class.
+  // Right now we avoid serializing objects that we've already serialized and, instead, just add
+  // some custom markers ('duplicate' / 'reference@') to the JSON document. These markers, however,
+  // can't be effectively used by clients of this class because the originally serialized objects
+  // don't have any kind of 'id' in the resulting document (the 'reference@' marker might be
+  // used BUT the document needs to be de-serialized within the same JVM on which it was
+  // serialized AND IT MUST be Java - System.identityHashCode(object).
-
-    private JsonSerializer defaultSerializer;
-    Map<Object, Object> serializedObjects;
-    private final int serializationDepth;
+    Map serializedObjects;
+    private JsonSerializer defaultSerializer;
+    private final int serializationDepth;
-    boolean isPrimitiveOrWrapper(Class<?> klass) {
-      return klass.isAssignableFrom(Byte.class) || klass.isAssignableFrom(byte.class)
-          || klass.isAssignableFrom(Short.class) || klass.isAssignableFrom(short.class)
-          || klass.isAssignableFrom(Integer.class) || klass.isAssignableFrom(int.class)
-          || klass.isAssignableFrom(Long.class) || klass.isAssignableFrom(long.class)
-          || klass.isAssignableFrom(Float.class) || klass.isAssignableFrom(float.class)
-          || klass.isAssignableFrom(Double.class) || klass.isAssignableFrom(double.class)
-          || klass.isAssignableFrom(Boolean.class) || klass.isAssignableFrom(boolean.class)
-          || klass.isAssignableFrom(String.class) || klass.isAssignableFrom(char.class)
-          || klass.isAssignableFrom(Character.class) || klass.isAssignableFrom(java.sql.Date.class)
-          || klass.isAssignableFrom(java.util.Date.class)
-          || klass.isAssignableFrom(java.math.BigDecimal.class);
+    private boolean isPrimitiveOrWrapper(Class<?> klass) {
+      return JsonUtil.isPrimitiveOrWrapper(klass);
+    @SuppressWarnings("unchecked")
-      if (value == null || isPrimitiveOrWrapper(value.getClass())) {
+      if (value == null || isPrimitiveOrWrapper(value.getClass()) || value.getClass().isEnum()) {
+    @SuppressWarnings("unchecked")
-      if (value == null || isPrimitiveOrWrapper(value.getClass())) {
+      if (value == null || isPrimitiveOrWrapper(value.getClass()) || value.getClass().isEnum()) {
-  private static class CollectionSerializer extends JsonSerializer<Collection> {
-    private final int maxCollectionElements;
-
-    public CollectionSerializer(int maxCollectionElements) {
-      this.maxCollectionElements = maxCollectionElements;
-    }
-
-    @Override
-    public void serializeWithType(Collection value, JsonGenerator gen,
-        SerializerProvider serializers, TypeSerializer typeSer)
-        throws IOException {
-      gen.setCurrentValue(value);
-      WritableTypeId typeIdDef = typeSer.writeTypePrefix(gen,
-          typeSer.typeId(value, JsonToken.START_OBJECT));
-      serializeElements(value, gen);
-      typeSer.writeTypeSuffix(gen, typeIdDef);
-    }
-
-    @Override
-    public void serialize(Collection value, JsonGenerator gen, SerializerProvider serializers)
-        throws IOException {
-      gen.writeStartObject();
-      serializeElements(value, gen);
-      gen.writeEndObject();
-    }
-
-    void serializeElements(Collection value, JsonGenerator gen) throws IOException {
-      Iterator<Object> objects = value.iterator();
-      for (int i = 0; i < maxCollectionElements && objects.hasNext(); i++) {
-        Object nextObject = objects.next();
-        gen.writeObjectField("" + i, nextObject);
-      }
-    }
-
-    @Override
-    public Class<Collection> handledType() {
-      return Collection.class;
-    }
-  }
-
-
-  private static class PdxInstanceSerializer extends JsonSerializer<PdxInstance> {
-    @Override
-    public void serializeWithType(PdxInstance value, JsonGenerator gen,
-        SerializerProvider serializers, TypeSerializer typeSer)
-        throws IOException {
-      WritableTypeId writableTypeId = typeSer.typeId(value, JsonToken.START_OBJECT);
-      typeSer.writeTypePrefix(gen, writableTypeId);
-      serializeFields(value, gen);
-      typeSer.writeTypeSuffix(gen, writableTypeId);
-    }
-
-    @Override
-    public void serialize(PdxInstance value, JsonGenerator gen, SerializerProvider serializers)
-        throws IOException {
-      gen.writeStartObject();
-      serializeFields(value, gen);
-      gen.writeEndObject();
-    }
-
-    void serializeFields(PdxInstance value, JsonGenerator gen) throws IOException {
-      for (String field : value.getFieldNames()) {
-        gen.writeObjectField(field, value.getField(field));
-      }
-    }
-
-    @Override
-    public Class<PdxInstance> handledType() {
-      return PdxInstance.class;
-    }
-  }
-
+  /**
+   * A custom JSON serializer for Struct.
+   */
-      typeSer.writeTypePrefix(gen, typeSer.typeId(value, JsonToken.START_OBJECT));
+      // We don't want to expose the internal classes, show interface instead.
+      WritableTypeId typeId = typeSer.typeId(value, Struct.class, JsonToken.START_OBJECT);
+      typeSer.writeTypePrefix(gen, typeId);
-      typeSer.writeTypeSuffix(gen, typeSer.typeId(value, JsonToken.START_OBJECT));
+      typeSer.writeTypeSuffix(gen, typeId);
+  /**
+   * A custom JSON serializer for PdxInstances.
+   */
+  private static class PdxInstanceSerializer extends JsonSerializer<PdxInstance> {
+    @Override
+    public void serializeWithType(PdxInstance value, JsonGenerator gen,
+        SerializerProvider serializers, TypeSerializer typeSer)
+        throws IOException {
+      // We don't want to expose the internal classes, show interface instead.
+      WritableTypeId typeId = typeSer.typeId(value, PdxInstance.class, JsonToken.START_OBJECT);
+      typeSer.writeTypePrefix(gen, typeId);
+      serializeFields(value, gen);
+      typeSer.writeTypeSuffix(gen, typeId);
+    }
+
+    @Override
+    public void serialize(PdxInstance value, JsonGenerator gen, SerializerProvider serializers)
+        throws IOException {
+      gen.writeStartObject();
+      serializeFields(value, gen);
+      gen.writeEndObject();
+    }
+
+    void serializeFields(PdxInstance value, JsonGenerator gen) throws IOException {
+      for (String field : value.getFieldNames()) {
+        gen.writeObjectField(field, value.getField(field));
+      }
+    }
+
+    @Override
+    public Class<PdxInstance> handledType() {
+      return PdxInstance.class;
+    }
+  }
+
+  /**
+   * A custom JSON serializer for region entries.
+   */
-      typeSer.writeTypePrefix(gen, typeSer.typeId(value, JsonToken.START_OBJECT));
+      typeSer.writeTypePrefix(gen,
+          typeSer.typeId(value, Region.Entry.class, JsonToken.START_OBJECT));
+   * A JSON serializer for collections to limit the number of elements written to the document.
+   */
+  private static class CollectionSerializer extends JsonSerializer<Collection> {
+    private final int maxCollectionElements;
+
+    CollectionSerializer(int maxCollectionElements) {
+      this.maxCollectionElements = maxCollectionElements;
+    }
+
+    @Override
+    public void serializeWithType(Collection value, JsonGenerator gen,
+        SerializerProvider serializers, TypeSerializer typeSer)
+        throws IOException {
+      gen.setCurrentValue(value);
+      WritableTypeId typeIdDef = typeSer.writeTypePrefix(gen,
+          typeSer.typeId(value, JsonToken.START_OBJECT));
+      serializeElements(value, gen);
+      typeSer.writeTypeSuffix(gen, typeIdDef);
+    }
+
+    @Override
+    public void serialize(Collection value, JsonGenerator gen, SerializerProvider serializers)
+        throws IOException {
+      gen.writeStartObject();
+      serializeElements(value, gen);
+      gen.writeEndObject();
+    }
+
+    void serializeElements(Collection value, JsonGenerator gen) throws IOException {
+      Iterator objects = value.iterator();
+      for (int i = 0; i < maxCollectionElements && objects.hasNext(); i++) {
+        Object nextObject = objects.next();
+        gen.writeObjectField("" + i, nextObject);
+      }
+    }
+
+    @Override
+    public Class<Collection> handledType() {
+      return Collection.class;
+    }
+  }
+
+  /**
-   * reserialization of objects that have already been serialized. W/o this
+   * re-serialization of objects that have already been serialized. W/o this
-

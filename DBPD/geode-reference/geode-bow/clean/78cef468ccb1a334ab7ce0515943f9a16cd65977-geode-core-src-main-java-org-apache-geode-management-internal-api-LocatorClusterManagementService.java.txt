GEODE-7136: remove "groups" in management configuration (#3997)


+import static org.apache.geode.management.configuration.AbstractConfiguration.CLUSTER;
+import static org.apache.geode.management.configuration.AbstractConfiguration.isCluster;
+
-import org.apache.geode.management.internal.configuration.validators.CacheElementValidator;
+import org.apache.geode.management.internal.configuration.validators.CommonConfigurationValidator;
-  private final CacheElementValidator commonValidator;
+  private final CommonConfigurationValidator commonValidator;
-        new MemberValidator(cache, persistenceService), new CacheElementValidator(),
+        new MemberValidator(cache, persistenceService), new CommonConfigurationValidator(),
-      CacheElementValidator commonValidator,
+      CommonConfigurationValidator commonValidator,
-    String group = config.getConfigGroup();
+    String group = config.getGroup();
+    final String groupName =
+        isCluster(group) ? CLUSTER : group;
-    final String finalGroup = group; // the below lambda requires a reference that is final
-    persistenceService.updateCacheConfig(finalGroup, cacheConfigForGroup -> {
+    persistenceService.updateCacheConfig(groupName, cacheConfigForGroup -> {
-            "Successfully updated configuration for " + finalGroup + ".");
+            "Successfully updated configuration for " + groupName + ".");
-        String message = "Failed to update cluster configuration for " + finalGroup + ".";
+        String message = "Failed to update cluster configuration for " + groupName + ".";
-    // add the config object which includes the HATOS information of the element created
+    // add the config object which includes the HATEOAS information of the element created
-      // gather elements on all the groups, consolidate the group information and then do the filter
-      // so that when we filter by a specific group, we still show that a particular element might
-      // also belong to another group.
-      for (String group : persistenceService.getGroups()) {
-        CacheConfig currentPersistedConfig = persistenceService.getCacheConfig(group, true);
-        List<T> listInGroup = manager.list(filter, currentPersistedConfig);
-        for (T element : listInGroup) {
-          element.setGroup(group);
-          resultList.add(element);
-        }
-      }
-
-      // if empty result, return immediately
-      if (resultList.size() == 0) {
-        return result;
-      }
-
-      // right now the list contains [{regionA, group1}, {regionA, group2}...], we need to
-      // consolidate the list into [{regionA, [group1, group2]}
-      List<T> consolidatedResultList = new ArrayList<>();
-      for (T element : resultList) {
-        int index = consolidatedResultList.indexOf(element);
-        if (index >= 0) {
-          T exist = consolidatedResultList.get(index);
-          exist.addGroup(element.getGroup());
-        } else {
-          consolidatedResultList.add(element);
-        }
-      }
+      Set<String> groups;
-        consolidatedResultList = consolidatedResultList.stream()
-            .filter(e -> (e.getGroups().contains(filter.getConfigGroup())))
-            .collect(Collectors.toList());
+        groups = Collections.singleton(filter.getGroup());
+      } else {
+        groups = persistenceService.getGroups();
-      resultList = consolidatedResultList;
+
+      for (String group : groups) {
+        CacheConfig currentPersistedConfig =
+            persistenceService.getCacheConfig(isCluster(group) ? CLUSTER : group, true);
+        List<T> listInGroup = manager.list(filter, currentPersistedConfig);
+        if (!isCluster(group)) {
+          listInGroup.forEach(t -> t.setGroup(group));
+        }
+        resultList.addAll(listInGroup);
+      }
-      List<String> groups = element.getGroups();
-      // if "cluster" is the only group, clear it, so that the returning json does not show
-      // "cluster" as a group value
-      if (element.getGroups().size() == 1
-          && AbstractConfiguration.CLUSTER.equals(element.getGroup())) {
-        element.getGroups().clear();
-      }
-
-            memberValidator.findMembers(filter.getId(), filter.getGroups().toArray(new String[0]));
+            memberValidator.findMembers(filter.getId(), filter.getGroup());
-        members = memberValidator.findServers(groups.toArray(new String[0]));
+        members = memberValidator.findServers(element.getGroup());

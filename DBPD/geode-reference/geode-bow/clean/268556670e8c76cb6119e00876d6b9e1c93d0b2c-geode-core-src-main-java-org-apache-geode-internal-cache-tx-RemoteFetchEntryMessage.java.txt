GEODE-4372: clean up RemoteOperationMessage classes (#1338)


* throw RemoteOperationException instead of ForceReattemptException when cache is closing. All ForceReattemptException throwing by RemoteOperationMessage has been removed.

* now uses SERIAL_EXECUTOR for all RemoteOperationMessages.
Previously most of these messages where processed in the partitioned message
thread pool even though most all of these messages where not partitioned.
It is possible that RemotePutAll and RemoteRemoveAll will have some trouble
being SERIAL_EXECUTOR.

* added comments for all RemoteOperationMessages describing what
they are used for

* Improved RemoteOperationMessageTest

* added a BucketTXRegionStub to calculate bucket region size on a stub.

* removed GemFireCacheImpl.getInstance call

* added RemoteOperationResponse unit test

* renamed handleAsUnexpected to handleCause

* renamed waitForCacheException to waitForRemoteResponse

* moved RemoteOperation classes to tx package


-package org.apache.geode.internal.cache;
+package org.apache.geode.internal.cache.tx;
-import java.util.Collections;
-import org.apache.geode.admin.OperationCancelledException;
+import org.apache.geode.internal.cache.EntrySnapshot;
+import org.apache.geode.internal.cache.KeyInfo;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.NonLocalRegionEntry;
+import org.apache.geode.internal.cache.RemoteOperationException;
- * {@link org.apache.geode.internal.cache.RemoteFetchEntryMessage.FetchEntryReplyMessage}.
+ * {@link org.apache.geode.internal.cache.tx.RemoteFetchEntryMessage.FetchEntryReplyMessage}.
-   * @param key the object to which the value should be feteched
+   * @param key the object to which the value should be fetched
-    FetchEntryResponse p =
-        new FetchEntryResponse(r.getSystem(), Collections.singleton(recipient), r, key);
+    FetchEntryResponse p = new FetchEntryResponse(r.getSystem(), recipient, r, key);
-    Set failures = r.getDistributionManager().putOutgoing(m);
+    Set<?> failures = r.getDistributionManager().putOutgoing(m);
-  public boolean isSevereAlertCompatible() {
-    // allow forced-disconnect processing for all cache op messages
-    return true;
-  }
-
-  @Override
-    // RemoteFetchEntryMessage is used in refreshing client caches during interest list recovery,
-    // so don't be too verbose or hydra tasks may time out
-
-    if (!(r instanceof PartitionedRegion)) {
-      r.waitOnInitialization(); // bug #43371 - accessing a region before it's initialized
-    }
+    r.waitOnInitialization(); // bug #43371 - accessing a region before it's initialized
-      Region.Entry re = r.getDataView().getEntry(keyInfo, r, true);
+      Region.Entry<?, ?> re = r.getDataView().getEntry(keyInfo, r, true);
-      // r.getPrStats().endRemoteOperationMessagesProcessing(startTime);
-    } catch (PrimaryBucketException pbe) {
-      FetchEntryReplyMessage.send(getSender(), getProcessorId(), null, dm, new ReplyException(pbe));
-        // since the Entry object shares state with the PartitionedRegion,
-        // we have to find the region and ask it to create a new Entry instance
-        // to be populated from the DataInput
-        FetchEntryResponse processor =
-            (FetchEntryResponse) ReplyProcessor21.getProcessor(this.processorId);
-        if (processor == null) {
-          throw new OperationCancelledException("This operation was cancelled (null processor)");
-        }
-        this.value = new EntrySnapshot(in, processor.region);
+        // EntrySnapshot.setRegion is called later
+        this.value = new EntrySnapshot(in, null);
-   * {@link org.apache.geode.internal.cache.RemoteFetchEntryMessage.FetchEntryReplyMessage}
+   * {@link org.apache.geode.internal.cache.tx.RemoteFetchEntryMessage.FetchEntryReplyMessage}
-    public FetchEntryResponse(InternalDistributedSystem ds, Set recipients, LocalRegion theRegion,
-        Object key) {
-      super(ds, recipients);
+    public FetchEntryResponse(InternalDistributedSystem ds, InternalDistributedMember recipient,
+        LocalRegion theRegion, Object key) {
+      super(ds, recipient);
+          if (this.returnValue != null) {
+            this.returnValue.setRegion(this.region);
+          }
-     * @throws EntryNotFoundException
-     * @throws EntryNotFoundException
-        // waitForRepliesUninterruptibly();
-        waitForCacheException();
-      } catch (RemoteOperationException e) {
-        e.checkKey(key);
-        final String msg = "FetchEntryResponse got remote RemoteOperationException; rethrowing";
-        logger.debug(msg, e);
-        throw e;
+        waitForRemoteResponse();
-        logger.debug("FetchEntryResponse got remote CacheException; forcing reattempt.", ce);
-        throw new RemoteOperationException(
-            LocalizedStrings.RemoteFetchEntryMessage_FETCHENTRYRESPONSE_GOT_REMOTE_CACHEEXCEPTION_FORCING_REATTEMPT
-                .toLocalizedString(),
+        logger.debug("FetchEntryResponse failed with remote CacheException", ce);
+        throw new RemoteOperationException("FetchEntryResponse failed with remote CacheException",

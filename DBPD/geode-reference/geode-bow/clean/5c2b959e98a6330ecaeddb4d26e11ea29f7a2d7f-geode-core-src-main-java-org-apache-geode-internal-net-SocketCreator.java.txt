GEODE-7808: standardize on use of HostAndPort for creating connections (#4765)

* Squashed merge of feature/GEODE-7808

removed HostAddress
renamed LocatorAddress to HostAndPort
modified TcpClient methods to take a HostAndPort argument instead of
InetAddress
modified SocketCreator to take a HostAndPort argument instead of
InetAddress

* GEODE-7808 - standardize on use of HostAndPort for connection formation

This continues a previous PR that passed and was approved for merge.
This commit raises up several methods from SocketCreator into the
TcpSocketCreator interface.  This is an intermediate commit.  A
subsequent commit will refactor TcpSocketCreator to separate the client
and server methods for creating server-sockets and client connections to
server-sockets.

* refactored socket-creators to separate concerns

ServerSocketCreator holds methods for non-client comms
ClientSocketCreator holds methods that clients should use for comms
AdvancedSocketCreator holds methods for people who need to get around
the limitations of the other two interfaces

* adding missing interface

* move code out of inner-classes into first-class classes

* renaming interfaces and methods to be less confusing

* reinstate SocketCreator ip to hostname cache for performance

* changes from review comments

-import java.net.SocketAddress;
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-import javax.net.ssl.SSLServerSocket;
-import org.apache.geode.SystemConnectException;
+import org.apache.geode.annotations.VisibleForTesting;
-import org.apache.geode.distributed.internal.tcpserver.ConnectionWatcher;
+import org.apache.geode.distributed.internal.tcpserver.AdvancedSocketCreatorImpl;
- * Analyze configuration data (gemfire.properties) and configure sockets accordingly for SSL.
+ * SocketCreators are built using a SocketCreatorFactory using Geode distributed-system properties.
+ * They know how to properly configure sockets for TLS (SSL) communications and perform
+ * handshakes. Connection-initiation uses a HostAndPort instance that is similar to an
+ * InetSocketAddress.
- * gemfire.useSSL = (true|false) default false.<br/>
- * gemfire.ssl.debug = (true|false) default false.<br/>
- * gemfire.ssl.needClientAuth = (true|false) default true.<br/>
- * gemfire.ssl.protocols = <i>list of protocols</i><br/>
- * gemfire.ssl.ciphers = <i>list of cipher suites</i><br/>
- * <p>
- * The following may be included to configure the certificates used by the Sun Provider.
- * <p>
- * javax.net.ssl.trustStore = <i>pathname</i><br/>
- * javax.net.ssl.trustStorePassword = <i>password</i><br/>
- * javax.net.ssl.keyStore = <i>pathname</i><br/>
- * javax.net.ssl.keyStorePassword = <i>password</i><br/>
- * <p>
- * Additional properties will be set as System properties to be available as needed by other
- * provider implementations.
+ * SocketCreator also supports a client-socket-factory that is designated with the property
+ * gemfire.clientSocketFactory for use in creating client->server connections.
-  @MakeNotStatic
-  private static final ConcurrentHashMap<InetAddress, String> hostNames = new ConcurrentHashMap<>();
-
+  @MakeNotStatic
+  private static final ConcurrentHashMap<InetAddress, String> hostNames = new ConcurrentHashMap<>();
+
-  /**
-   * context for SSL socket factories
-   */
-  /**
-   * A factory used to create client <code>Sockets</code>.
-   */
-  public static final boolean ENABLE_TCP_KEEP_ALIVE = TcpSocketCreatorImpl.ENABLE_TCP_KEEP_ALIVE;
-
-  // -------------------------------------------------------------------------
-  // Constructor
-  // -------------------------------------------------------------------------
-
-  /**
-   * Constructs new SocketCreator instance.
-   */
-  public SocketCreator(final SSLConfig sslConfig) {
-    this.sslConfig = sslConfig;
-    initialize();
-  }
-
+  public static final boolean ENABLE_TCP_KEEP_ALIVE =
+      AdvancedSocketCreatorImpl.ENABLE_TCP_KEEP_ALIVE;
+
-   * returns the host name for the given inet address, using a local cache of names to avoid dns
-   * hits and duplicate strings
-   */
-  public static String getCanonicalHostName(InetAddress addr, String hostName) {
-    String result = hostNames.get(addr);
-    if (result == null) {
-      hostNames.put(addr, hostName);
-      return hostName;
-    }
-    return result;
-  }
-
-  /**
+
+  // -------------------------------------------------------------------------
+  // Constructor
+  // -------------------------------------------------------------------------
+
+  /**
+   * Constructs new SocketCreator instance.
+   */
+  public SocketCreator(final SSLConfig sslConfig) {
+    this.sslConfig = sslConfig;
+    initialize();
+  }
+
+
+  protected void initializeCreators() {
+    serverSocketCreator = new SCServerSocketCreator(this);
+    clientSocketCreator = new SCClientSocketCreator(this);
+    advancedSocketCreator = new SCAdvancedSocketCreator(this);
+  }
+
-        if (this.sslConfig.isEnabled() && sslContext == null) {
+        if (this.sslConfig.isEnabled() && getSslContext() == null) {
+  /**
+   * context for SSL socket factories
+   */
+  @VisibleForTesting
+  /**
+   * A factory used to create client <code>Sockets</code>.
+   */
+  public ClientSocketFactory getClientSocketFactory() {
+    return clientSocketFactory;
+  }
+
+  public SSLConfig getSslConfig() {
+    return sslConfig;
+  }
+
+  /**
+   * ExtendedAliasKeyManager supports use of certificate aliases in distributed system
+   * properties.
+   */
+  /**
+   * Returns true if this SocketCreator is configured to use SSL.
+   */
+  @Override
+  protected boolean useSSL() {
+    return this.sslConfig.isEnabled();
+  }
+
-   * Returns true if this SocketCreator is configured to use SSL.
-   */
-  @Override
-  public boolean useSSL() {
-    return this.sslConfig.isEnabled();
-  }
-
-  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
-      List<GatewayTransportFilter> transportFilters, int socketBufferSize) throws IOException {
-    if (transportFilters.isEmpty()) {
-      return createServerSocket(nport, backlog, bindAddr, socketBufferSize);
-    } else {
-      printConfig();
-      ServerSocket result = new TransportFilterServerSocket(transportFilters);
-      result.setReuseAddress(true);
-      // Set the receive buffer size before binding the socket so
-      // that large buffers will be allocated on accepted sockets (see
-      // java.net.ServerSocket.setReceiverBufferSize javadocs)
-      result.setReceiveBufferSize(socketBufferSize);
-      try {
-        result.bind(new InetSocketAddress(bindAddr, nport), backlog);
-      } catch (BindException e) {
-        BindException throwMe = new BindException(
-            String.format("Failed to create server socket on %s[%s]", bindAddr, nport));
-        throwMe.initCause(e);
-        throw throwMe;
-      }
-      return result;
-    }
-  }
-
-  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
-      int socketBufferSize) throws IOException {
-    return createServerSocket(nport, backlog, bindAddr, socketBufferSize, sslConfig.isEnabled());
-  }
-
-  @Override
-  protected ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
-      int socketBufferSize, boolean sslConnection) throws IOException {
-    printConfig();
-    if (!sslConnection) {
-      return super.createServerSocket(nport, backlog, bindAddr, socketBufferSize, sslConnection);
-    }
-    if (this.sslContext == null) {
-      throw new GemFireConfigException(
-          "SSL not configured correctly, Please look at previous error");
-    }
-    ServerSocketFactory ssf = this.sslContext.getServerSocketFactory();
-    SSLServerSocket serverSocket = (SSLServerSocket) ssf.createServerSocket();
-    serverSocket.setReuseAddress(true);
-    // If necessary, set the receive buffer size before binding the socket so
-    // that large buffers will be allocated on accepted sockets (see
-    // java.net.ServerSocket.setReceiverBufferSize javadocs)
-    if (socketBufferSize != -1) {
-      serverSocket.setReceiveBufferSize(socketBufferSize);
-    }
-    serverSocket.bind(new InetSocketAddress(bindAddr, nport), backlog);
-    finishServerSocket(serverSocket);
-    return serverSocket;
-  }
-
-  /**
-   * Creates or bind server socket to a random port selected from tcp-port-range which is same as
-   * membership-port-range.
-   *
-   *
-   * @return Returns the new server socket.
-   *
-   */
-  public ServerSocket createServerSocketUsingPortRange(InetAddress ba, int backlog,
-      boolean isBindAddress, boolean useNIO, int tcpBufferSize, int[] tcpPortRange)
-      throws IOException {
-    return createServerSocketUsingPortRange(ba, backlog, isBindAddress, useNIO, tcpBufferSize,
-        tcpPortRange, sslConfig.isEnabled());
-  }
-
-  @Override
-  protected RuntimeException problemCreatingSocketInPortRangeException(String s, IOException e) {
-    return new GemFireConfigException(s, e);
-  }
-
-  @Override
-  protected RuntimeException noFreePortException(String reason) {
-    return new SystemConnectException(reason);
-  }
-
-  /**
-   * Return a client socket. This method is used by client/server clients.
-   */
-  public Socket connectForClient(String host, int port, int timeout) throws IOException {
-    return connect(InetAddress.getByName(host), port, timeout, null, true, -1);
-  }
-
-  /**
-   * Return a client socket. This method is used by client/server clients.
-   */
-  public Socket connectForClient(String host, int port, int timeout, int socketBufferSize)
-      throws IOException {
-    return connect(InetAddress.getByName(host), port, timeout, null, true, socketBufferSize);
-  }
-
-  /**
-   * Return a client socket. This method is used by peers.
-   */
-  public Socket connectForServer(InetAddress inetadd, int port) throws IOException {
-    return connect(inetadd, port, 0, null, false, -1);
-  }
-
-  /**
-   * Return a client socket, timing out if unable to connect and timeout > 0 (millis). The parameter
-   * <i>timeout</i> is ignored if SSL is being used, as there is no timeout argument in the ssl
-   * socket factory
-   */
-  public Socket connect(InetAddress inetadd, int port, int timeout,
-      ConnectionWatcher optionalWatcher, boolean clientSide, int socketBufferSize)
-      throws IOException {
-    return connect(inetadd, port, timeout, optionalWatcher, clientSide, socketBufferSize,
-        sslConfig.isEnabled());
-  }
-
-  /**
-   * Return a client socket, timing out if unable to connect and timeout > 0 (millis). The parameter
-   * <i>timeout</i> is ignored if SSL is being used, as there is no timeout argument in the ssl
-   * socket factory
-   */
-  @Override
-  public Socket connect(InetAddress inetadd, int port, int timeout,
-      ConnectionWatcher optionalWatcher, boolean clientSide, int socketBufferSize,
-      boolean sslConnection) throws IOException {
-
-    printConfig();
-
-    if (!sslConnection) {
-      return super.connect(inetadd, port, timeout, optionalWatcher, clientSide, socketBufferSize,
-          sslConnection);
-    }
-
-    // create an SSL connection
-
-    Socket socket;
-    SocketAddress sockaddr = new InetSocketAddress(inetadd, port);
-    if (this.sslContext == null) {
-      throw new GemFireConfigException(
-          "SSL not configured correctly, Please look at previous error");
-    }
-    SocketFactory sf = this.sslContext.getSocketFactory();
-    socket = sf.createSocket();
-
-    // Optionally enable SO_KEEPALIVE in the OS network protocol.
-    socket.setKeepAlive(ENABLE_TCP_KEEP_ALIVE);
-
-    // If necessary, set the receive buffer size before connecting the
-    // socket so that large buffers will be allocated on accepted sockets
-    // (see java.net.Socket.setReceiverBufferSize javadocs for details)
-    if (socketBufferSize != -1) {
-      socket.setReceiveBufferSize(socketBufferSize);
-    }
-
-    try {
-      if (optionalWatcher != null) {
-        optionalWatcher.beforeConnect(socket);
-      }
-      socket.connect(sockaddr, Math.max(timeout, 0));
-      configureClientSSLSocket(socket, timeout);
-      return socket;
-
-    } finally {
-      if (optionalWatcher != null) {
-        optionalWatcher.afterConnect(socket);
-      }
-    }
-  }
-
-  @Override
-  protected Socket createCustomClientSocket(InetAddress inetadd, int port) throws IOException {
-    if (this.clientSocketFactory != null) {
-      return this.clientSocketFactory.createSocket(inetadd, port);
-    }
-    return null;
-  }
-
-  /**
-    return sslContext.createSSLEngine(hostName, port);
+    return getSslContext().createSSLEngine(hostName, port);
-  public void handshakeIfSocketIsSSL(Socket socket, int timeout) throws IOException {
+  void handshakeIfSocketIsSSL(Socket socket, int timeout) throws IOException {
+  /**
+   * Create a server socket with the given transport filters.<br>
+   * Note: This method is outside of the
+   * client/server/advanced interfaces because it references WAN classes that aren't
+   * available to them.
+   */
+  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
+      List<GatewayTransportFilter> transportFilters, int socketBufferSize) throws IOException {
+    if (transportFilters.isEmpty()) {
+      return ((SCServerSocketCreator) forCluster())
+          .createServerSocket(nport, backlog, bindAddr, socketBufferSize, useSSL());
+    } else {
+      printConfig();
+      ServerSocket result = new TransportFilterServerSocket(transportFilters);
+      result.setReuseAddress(true);
+      // Set the receive buffer size before binding the socket so
+      // that large buffers will be allocated on accepted sockets (see
+      // java.net.ServerSocket.setReceiverBufferSize javadocs)
+      result.setReceiveBufferSize(socketBufferSize);
+      try {
+        result.bind(new InetSocketAddress(bindAddr, nport), backlog);
+      } catch (BindException e) {
+        BindException throwMe = new BindException(
+            String.format("Failed to create server socket on %s[%s]", bindAddr, nport));
+        throwMe.initCause(e);
+        throw throwMe;
+      }
+      return result;
+    }
+  }
+
+
-  /**
-   * Configure the SSLServerSocket based on this SocketCreator's settings.
-   */
-  private void finishServerSocket(SSLServerSocket serverSocket) {
-    serverSocket.setUseClientMode(false);
-    if (this.sslConfig.isRequireAuth()) {
-      // serverSocket.setWantClientAuth( true );
-      serverSocket.setNeedClientAuth(true);
-    }
-    serverSocket.setEnableSessionCreation(true);
-
-    // restrict protocols
-    String[] protocols = this.sslConfig.getProtocolsAsStringArray();
-    if (!"any".equalsIgnoreCase(protocols[0])) {
-      serverSocket.setEnabledProtocols(protocols);
-    }
-    // restrict ciphers
-    String[] ciphers = this.sslConfig.getCiphersAsStringArray();
-    if (!"any".equalsIgnoreCase(ciphers[0])) {
-      serverSocket.setEnabledCipherSuites(ciphers);
-    }
-
-    SSLParameterExtension sslParameterExtension = this.sslConfig.getSSLParameterExtension();
-    if (sslParameterExtension != null) {
-      SSLParameters modifiedParams =
-          sslParameterExtension.modifySSLServerSocketParameters(serverSocket.getSSLParameters());
-      serverSocket.setSSLParameters(modifiedParams);
-    }
-
-  }
-  private void configureClientSSLSocket(Socket socket, int timeout) throws IOException {
+  void configureClientSSLSocket(Socket socket, int timeout) throws IOException {
-  private void printConfig() {
+  void printConfig() {
-
-

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * {@link org.apache.geode.cache.Region#get(Object)}operation. The reply is
- * sent in a {@link org.apache.geode.internal.cache.partitioned.GetMessage}. 
+ * {@link org.apache.geode.cache.Region#get(Object)}operation. The reply is sent in a
+ * {@link org.apache.geode.internal.cache.partitioned.GetMessage}.
- * Since the {@link org.apache.geode.cache.Region#get(Object)}operation is
- * used <bold>very </bold> frequently the performance of this class is critical.
+ * Since the {@link org.apache.geode.cache.Region#get(Object)}operation is used <bold>very </bold>
+ * frequently the performance of this class is critical.
-public final class GetMessage extends PartitionMessageWithDirectReply
-  {
+public final class GetMessage extends PartitionMessageWithDirectReply {
-  
+
-  
+
-  
+
-  public GetMessage() {
-  }
-  
+  public GetMessage() {}
+
-                     DirectReplyProcessor processor,
-                     final Object key, final Object aCallbackArgument, ClientProxyMembershipID context,
-                     boolean returnTombstones) {
+      DirectReplyProcessor processor, final Object key, final Object aCallbackArgument,
+      ClientProxyMembershipID context, boolean returnTombstones) {
-    private static final boolean ORDER_PR_GETS = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "order-pr-gets");
+  private static final boolean ORDER_PR_GETS =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "order-pr-gets");
-  final public int getProcessorType()
-  {
+  final public int getProcessorType() {
-    }
-    else if (ORDER_PR_GETS) {
+    } else if (ORDER_PR_GETS) {
-  
+
-  protected final boolean operateOnPartitionedRegion(
-      final DistributionManager dm, PartitionedRegion r, long startTime)
-      throws ForceReattemptException
-  {
+  protected final boolean operateOnPartitionedRegion(final DistributionManager dm,
+      PartitionedRegion r, long startTime) throws ForceReattemptException {
-    
+
-    if (ds != null) {
-      VersionTagHolder event = new VersionTagHolder();
-      try {
-        KeyInfo keyInfo = r.getKeyInfo(key, cbArg);
-        boolean lockEntry = forceUseOfPRExecutor || isDirectAck();
-        
-        val = r.getDataView().getSerializedValue(r, keyInfo, !lockEntry, this.context, event, returnTombstones);
-        
-        if(val == BucketRegion.REQUIRES_ENTRY_LOCK) {
-          Assert.assertTrue(!lockEntry);
-          this.forceUseOfPRExecutor = true;
-          if (logger.isDebugEnabled()) {
-            logger.debug("Rescheduling GetMessage due to possible cache-miss");
+      if (ds != null) {
+        VersionTagHolder event = new VersionTagHolder();
+        try {
+          KeyInfo keyInfo = r.getKeyInfo(key, cbArg);
+          boolean lockEntry = forceUseOfPRExecutor || isDirectAck();
+
+          val = r.getDataView().getSerializedValue(r, keyInfo, !lockEntry, this.context, event,
+              returnTombstones);
+
+          if (val == BucketRegion.REQUIRES_ENTRY_LOCK) {
+            Assert.assertTrue(!lockEntry);
+            this.forceUseOfPRExecutor = true;
+            if (logger.isDebugEnabled()) {
+              logger.debug("Rescheduling GetMessage due to possible cache-miss");
+            }
+            schedule(dm);
+            return false;
-          schedule(dm);
+          valueBytes = val instanceof RawValue ? (RawValue) val : new RawValue(val);
+        } catch (DistributedSystemDisconnectedException sde) {
+          sendReply(getSender(), this.processorId, dm,
+              new ReplyException(new ForceReattemptException(
+                  LocalizedStrings.GetMessage_OPERATION_GOT_INTERRUPTED_DUE_TO_SHUTDOWN_IN_PROGRESS_ON_REMOTE_VM
+                      .toLocalizedString(),
+                  sde)),
+              r, startTime);
+          return false;
+        } catch (PrimaryBucketException pbe) {
+          sendReply(getSender(), getProcessorId(), dm, new ReplyException(pbe), r, startTime);
+          return false;
+        } catch (DataLocationException e) {
+          sendReply(getSender(), getProcessorId(), dm, new ReplyException(e), r, startTime);
-        valueBytes = val instanceof RawValue ? (RawValue)val : new RawValue(val);
-      } 
-      catch(DistributedSystemDisconnectedException sde) {
-        sendReply(getSender(), this.processorId, dm, new ReplyException(new ForceReattemptException(LocalizedStrings.GetMessage_OPERATION_GOT_INTERRUPTED_DUE_TO_SHUTDOWN_IN_PROGRESS_ON_REMOTE_VM.toLocalizedString(), sde)), r, startTime);
-        return false;
-      }
-      catch (PrimaryBucketException pbe) {
-        sendReply(getSender(), getProcessorId(), dm, new ReplyException(pbe), r, startTime);
-        return false;
-      }
-      catch (DataLocationException e) {
-        sendReply(getSender(), getProcessorId(), dm, new ReplyException(e), r, startTime);
-        return false;
-      }
-      if (logger.isTraceEnabled(LogMarker.DM)) {
-        logger.debug("GetMessage sending serialized value {} back via GetReplyMessage using processorId: {}", valueBytes, getProcessorId());
+        if (logger.isTraceEnabled(LogMarker.DM)) {
+          logger.debug(
+              "GetMessage sending serialized value {} back via GetReplyMessage using processorId: {}",
+              valueBytes, getProcessorId());
+        }
+
+        r.getPrStats().endPartitionMessagesProcessing(startTime);
+        GetReplyMessage.send(getSender(), getProcessorId(), valueBytes, getReplySender(dm),
+            event.getVersionTag());
+        // Unless there was an exception thrown, this message handles sending the
+        // response
+        return false;
+      } else {
+        throw new InternalGemFireError(
+            LocalizedStrings.GetMessage_GET_MESSAGE_SENT_TO_WRONG_MEMBER.toLocalizedString());
-      
-      r.getPrStats().endPartitionMessagesProcessing(startTime); 
-      GetReplyMessage.send(getSender(), getProcessorId(), valueBytes, getReplySender(dm), event.getVersionTag());
-   // Unless there was an exception thrown, this message handles sending the
-      // response
-      return false;
-    }
-    else {
-      throw new InternalGemFireError(LocalizedStrings.GetMessage_GET_MESSAGE_SENT_TO_WRONG_MEMBER.toLocalizedString());
-    }
-    }finally {
+    } finally {
-    
+
-  protected void appendFields(StringBuffer buff)
-  {
+  protected void appendFields(StringBuffer buff) {
-      .append("; context=").append(this.context);
+        .append("; context=").append(this.context);
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException
-  {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-  public void toData(DataOutput out) throws IOException
-  {
+  public void toData(DataOutput out) throws IOException {
-  public void setKey(Object key)
-  {
+  public void setKey(Object key) {
-   * Sends a PartitionedRegion
-   * {@link org.apache.geode.cache.Region#get(Object)} message   
+   * Sends a PartitionedRegion {@link org.apache.geode.cache.Region#get(Object)} message
-   * @param recipient
-   *          the member that the get message is sent to
-   * @param r
-   *          the PartitionedRegion for which get was performed upon
-   * @param key
-   *          the object to which the value should be feteched
+   * @param recipient the member that the get message is sent to
+   * @param r the PartitionedRegion for which get was performed upon
+   * @param key the object to which the value should be feteched
-   * @return the processor used to fetch the returned value associated with the
-   *         key
+   * @return the processor used to fetch the returned value associated with the key
-  public static GetResponse send(InternalDistributedMember recipient,
-                                 PartitionedRegion r,
-                                 final Object key,
-                                 final Object aCallbackArgument,
-                                 ClientProxyMembershipID requestingClient,
-                                 boolean returnTombstones)
-      throws ForceReattemptException
-  {
-    Assert.assertTrue(recipient != null,
-        "PRDistribuedGetReplyMessage NULL reply message");
+  public static GetResponse send(InternalDistributedMember recipient, PartitionedRegion r,
+      final Object key, final Object aCallbackArgument, ClientProxyMembershipID requestingClient,
+      boolean returnTombstones) throws ForceReattemptException {
+    Assert.assertTrue(recipient != null, "PRDistribuedGetReplyMessage NULL reply message");
-    GetMessage m = new GetMessage(recipient, r.getPRId(), p,
-        key, aCallbackArgument, requestingClient, returnTombstones);
+    GetMessage m = new GetMessage(recipient, r.getPRId(), p, key, aCallbackArgument,
+        requestingClient, returnTombstones);
-      throw new ForceReattemptException(LocalizedStrings.GetMessage_FAILED_SENDING_0.toLocalizedString(m));
+      throw new ForceReattemptException(
+          LocalizedStrings.GetMessage_FAILED_SENDING_0.toLocalizedString(m));
-   * {@link org.apache.geode.cache.Region#get(Object)}operation This is the
-   * reply to a {@link GetMessage}.
+   * {@link org.apache.geode.cache.Region#get(Object)}operation This is the reply to a
+   * {@link GetMessage}.
-   * Since the {@link org.apache.geode.cache.Region#get(Object)}operation
-   * is used <bold>very </bold> frequently the performance of this class is
-   * critical.
+   * Since the {@link org.apache.geode.cache.Region#get(Object)}operation is used <bold>very </bold>
+   * frequently the performance of this class is critical.
-  public static final class GetReplyMessage extends ReplyMessage
-   {
-    /** 
-     * The raw value in the cache which may be serialized to the output stream, if 
-     * it is NOT already a byte array 
+  public static final class GetReplyMessage extends ReplyMessage {
+    /**
+     * The raw value in the cache which may be serialized to the output stream, if it is NOT already
+     * a byte array
-     * Indicates that the value already a byte array (aka user blob) and does
-     * not need de-serialization. Also indicates if the value has been
-     * serialized directly as an object rather than as a byte array and whether
-     * it is INVALID/LOCAL_INVALID or TOMBSTONE.
+     * Indicates that the value already a byte array (aka user blob) and does not need
+     * de-serialization. Also indicates if the value has been serialized directly as an object
+     * rather than as a byte array and whether it is INVALID/LOCAL_INVALID or TOMBSTONE.
-    //static final byte VALUE_IS_OBJECT = 2;
+    // static final byte VALUE_IS_OBJECT = 2;
-     * Used on the fromData side to transfer the value bytes to the requesting
-     * thread
+     * Used on the fromData side to transfer the value bytes to the requesting thread
-    
+
-    public GetReplyMessage() {
-    }
+    public GetReplyMessage() {}
-      }
-      else if (Token.isInvalid(rval)) {
+      } else if (Token.isInvalid(rval)) {
-      }
-      else if (val.isValueByteArray()) {
+      } else if (val.isValueByteArray()) {
-      }
-      else {
+      } else {
-    
+
-     * Return the value from the get operation, serialize it bytes as late as
-     * possible to avoid making un-neccesary byte[] copies.  De-serialize those 
-     * same bytes as late as possible to avoid using precious threads (aka P2P readers). 
+     * Return the value from the get operation, serialize it bytes as late as possible to avoid
+     * making un-neccesary byte[] copies. De-serialize those same bytes as late as possible to avoid
+     * using precious threads (aka P2P readers).
+     * 
-     * @param val the raw value that will eventually be serialized 
+     * @param val the raw value that will eventually be serialized
-    public static void send(InternalDistributedMember recipient, 
-        int processorId, RawValue val, ReplySender replySender, VersionTag versionTag)
-        throws ForceReattemptException
-    {
-      Assert.assertTrue(recipient != null,
-          "PRDistribuedGetReplyMessage NULL reply message");
+    public static void send(InternalDistributedMember recipient, int processorId, RawValue val,
+        ReplySender replySender, VersionTag versionTag) throws ForceReattemptException {
+      Assert.assertTrue(recipient != null, "PRDistribuedGetReplyMessage NULL reply message");
-     * Processes this message. This method is invoked by the receiver of the
-     * message.
+     * Processes this message. This method is invoked by the receiver of the message.
-     * @param dm
-     *          the distribution manager that is processing the message.
+     * @param dm the distribution manager that is processing the message.
-    public void process(final DM dm, ReplyProcessor21 processor)
-    {
+    public void process(final DM dm, ReplyProcessor21 processor) {
-        logger.trace(LogMarker.DM, "GetReplyMessage process invoking reply processor with processorId: {}", this.processorId);
+        logger.trace(LogMarker.DM,
+            "GetReplyMessage process invoking reply processor with processorId: {}",
+            this.processorId);
-      
+
-      
+
-    public void toData(DataOutput out) throws IOException
-    {
+    public void toData(DataOutput out) throws IOException {
-        DataSerializer.writeByteArray((byte[])this.rawVal.getRawValue(), out);
-      }
-      else {
+        DataSerializer.writeByteArray((byte[]) this.rawVal.getRawValue(), out);
+      } else {
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException
-    {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-        this.remoteVersion = InternalDataSerializer
-            .getVersionForDataStreamOrNull(in);
+        this.remoteVersion = InternalDataSerializer.getVersionForDataStreamOrNull(in);
-        this.versionTag = (VersionTag)DataSerializer.readObject(in);
+        this.versionTag = (VersionTag) DataSerializer.readObject(in);
-    public String toString()
-    {
+    public String toString() {
-      sb.append("GetReplyMessage ").append("processorid=").append(
-          this.processorId).append(" reply to sender ")
-          .append(this.getSender());
+      sb.append("GetReplyMessage ").append("processorid=").append(this.processorId)
+          .append(" reply to sender ").append(this.getSender());
-      }
-      else if (this.valueType == VALUE_IS_INVALID) {
+      } else if (this.valueType == VALUE_IS_INVALID) {
-      }
-      else if (this.rawVal != null) {
+      } else if (this.rawVal != null) {
-      }
-      else if (this.valueInBytes == null) {
+      } else if (this.valueInBytes == null) {
-        sb.append (" version=").append(this.versionTag);
+        sb.append(" version=").append(this.versionTag);
-   * A processor to capture the value returned by {@link 
-   * org.apache.geode.internal.cache.partitioned.GetMessage.GetReplyMessage}
+   * A processor to capture the value returned by
+   * {@link org.apache.geode.internal.cache.partitioned.GetMessage.GetReplyMessage}
-    public void process(DistributionMessage msg)
-    {
+    public void process(DistributionMessage msg) {
-        GetReplyMessage reply = (GetReplyMessage)msg;
+        GetReplyMessage reply = (GetReplyMessage) msg;
-        if (reply.valueInBytes != null
-            || reply.valueType == GetReplyMessage.VALUE_IS_INVALID
+        if (reply.valueInBytes != null || reply.valueType == GetReplyMessage.VALUE_IS_INVALID
-    
+
-     * De-seralize the value, if the value isn't already a byte array, this 
-     * method should be called in the context of the requesting thread for the
-     * best scalability
-     * @param preferCD 
+     * De-seralize the value, if the value isn't already a byte array, this method should be called
+     * in the context of the requesting thread for the best scalability
+     * 
+     * @param preferCD
-    public Object getValue(boolean preferCD) throws ForceReattemptException
-    {
+    public Object getValue(boolean preferCD) throws ForceReattemptException {
+                } else {
+                  return BlobHelper.deserializeBlob(reply.valueInBytes, reply.remoteVersion, null);
-                else {
-                  return BlobHelper.deserializeBlob(reply.valueInBytes,
-                      reply.remoteVersion, null);
-                }
-              }
-              else {
+              } else {
-      }
-      catch (IOException e) {
-        throw new ForceReattemptException(LocalizedStrings.GetMessage_UNABLE_TO_DESERIALIZE_VALUE_IOEXCEPTION.toLocalizedString(), e);
-      }
-      catch (ClassNotFoundException e) {
-        throw new ForceReattemptException(LocalizedStrings.GetMessage_UNABLE_TO_DESERIALIZE_VALUE_CLASSNOTFOUNDEXCEPTION.toLocalizedString(), e);
+      } catch (IOException e) {
+        throw new ForceReattemptException(
+            LocalizedStrings.GetMessage_UNABLE_TO_DESERIALIZE_VALUE_IOEXCEPTION.toLocalizedString(),
+            e);
+      } catch (ClassNotFoundException e) {
+        throw new ForceReattemptException(
+            LocalizedStrings.GetMessage_UNABLE_TO_DESERIALIZE_VALUE_CLASSNOTFOUNDEXCEPTION
+                .toLocalizedString(),
+            e);
-    
+
-     * @param preferCD 
+     * @param preferCD
-    public Object waitForResponse(boolean preferCD) 
-        throws ForceReattemptException {
+    public Object waitForResponse(boolean preferCD) throws ForceReattemptException {
-//        waitForRepliesUninterruptibly();
-          waitForCacheException();
-          if (DistributionStats.enableClockStats) {
-            getDistributionManager().getStats().incReplyHandOffTime(this.start);
-          }
+        // waitForRepliesUninterruptibly();
+        waitForCacheException();
+        if (DistributionStats.enableClockStats) {
+          getDistributionManager().getStats().incReplyHandOffTime(this.start);
+        }
-      }
-      catch (ForceReattemptException e) {
+      } catch (ForceReattemptException e) {
-        throw new ForceReattemptException(LocalizedStrings.GetMessage_NO_RETURN_VALUE_RECEIVED.toLocalizedString());
+        throw new ForceReattemptException(
+            LocalizedStrings.GetMessage_NO_RETURN_VALUE_RECEIVED.toLocalizedString());

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This class takes the responsibility of executing the query on a data store
- * for the buckets specified in bucketList. It contains a
- * <code>PRQueryExecutor</code> thread-pool executor that takes a
- * <code>Callable</code> task identified by <code>PartitionedRegion</code>,
- * queryString and bucketId.
+ * This class takes the responsibility of executing the query on a data store for the buckets
+ * specified in bucketList. It contains a <code>PRQueryExecutor</code> thread-pool executor that
+ * takes a <code>Callable</code> task identified by <code>PartitionedRegion</code>, queryString and
+ * bucketId.
- * The QueryTasks add results directly to a results queue.
- * The BucketQueryResult is used not only to indicate completion, and holds an exception if there one occurred while
- * processing a query.
+ * The QueryTasks add results directly to a results queue. The BucketQueryResult is used not only to
+ * indicate completion, and holds an exception if there one occurred while processing a query.
-public class PRQueryProcessor
-{
+public class PRQueryProcessor {
-  
+
-  public final static int NUM_THREADS = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "PRQueryProcessor.numThreads", 1).intValue();
+  public final static int NUM_THREADS = Integer
+      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "PRQueryProcessor.numThreads", 1).intValue();
-  
+
-  private volatile ObjectType resultType = null; 
- 
-  private boolean isIndexUsedForLocalQuery = false;
-//  private List _failedBuckets;
+  private volatile ObjectType resultType = null;
-  public PRQueryProcessor(PartitionedRegionDataStore prDS,
-      DefaultQuery query, Object[] parameters, List<Integer> buckets) {
+  private boolean isIndexUsedForLocalQuery = false;
+  // private List _failedBuckets;
+
+  public PRQueryProcessor(PartitionedRegionDataStore prDS, DefaultQuery query, Object[] parameters,
+      List<Integer> buckets) {
-    ((GemFireCacheImpl)prDS.partitionedRegion.getCache()).getLocalQueryService();
+    ((GemFireCacheImpl) prDS.partitionedRegion.getCache()).getLocalQueryService();
-  public PRQueryProcessor(PartitionedRegion pr,
-      DefaultQuery query, Object[] parameters, List buckets) {
+  public PRQueryProcessor(PartitionedRegion pr, DefaultQuery query, Object[] parameters,
+      List buckets) {
-  
+
-  
+
-   * Executes a pre-compiled query on a data store.
-   * Adds result objects to resultQueue
+   * Executes a pre-compiled query on a data store. Adds result objects to resultQueue
+   * 
-    throws QueryException, InterruptedException, ForceReattemptException {   
-    //Set indexInfoMap to this threads observer.
-    //QueryObserver observer = QueryObserverHolder.getInstance();
-    //if(observer != null && observer instanceof IndexTrackingQueryObserver){
-      //((IndexTrackingQueryObserver)observer).setIndexInfo(resultCollector.getIndexInfoMap());
-    //}
-    
-    if (NUM_THREADS > 1 || this.TEST_NUM_THREADS > 1) {  
+      throws QueryException, InterruptedException, ForceReattemptException {
+    // Set indexInfoMap to this threads observer.
+    // QueryObserver observer = QueryObserverHolder.getInstance();
+    // if(observer != null && observer instanceof IndexTrackingQueryObserver){
+    // ((IndexTrackingQueryObserver)observer).setIndexInfo(resultCollector.getIndexInfoMap());
+    // }
+
+    if (NUM_THREADS > 1 || this.TEST_NUM_THREADS > 1) {
-  
+
-    throws QueryException, InterruptedException, ForceReattemptException {
-    if (Thread.interrupted()) throw new InterruptedException();
-      
+      throws QueryException, InterruptedException, ForceReattemptException {
+    if (Thread.interrupted())
+      throw new InterruptedException();
+
-    
+
-      }
-      catch (RejectedExecutionException rejectedExecutionEx) {
-        //this._prds.partitionedRegion.checkReadiness();
+      } catch (RejectedExecutionException rejectedExecutionEx) {
+        // this._prds.partitionedRegion.checkReadiness();
-      
+
-          //this._prds.partitionedRegion.checkReadiness();
-          Future fut = (Future)itr.next();
+          // this._prds.partitionedRegion.checkReadiness();
+          Future fut = (Future) itr.next();
-          
+
-            bqr = (QueryTask.BucketQueryResult)fut.get(BUCKET_QUERY_TIMEOUT, TimeUnit.SECONDS);
-            //if (retry.booleanValue()) {
-            //  reattemptNeeded = true;
-              //fre = (ForceReattemptException)bqr.getException();
-            //} else {
-              bqr.handleAndThrowException(); // handles an exception if there was one,
-              //  otherwise, the results have already been added to the resultQueue
-            //}
+            bqr = (QueryTask.BucketQueryResult) fut.get(BUCKET_QUERY_TIMEOUT, TimeUnit.SECONDS);
+            // if (retry.booleanValue()) {
+            // reattemptNeeded = true;
+            // fre = (ForceReattemptException)bqr.getException();
+            // } else {
+            bqr.handleAndThrowException(); // handles an exception if there was one,
+            // otherwise, the results have already been added to the resultQueue
+            // }
-            
+
-            throw new InternalGemFireException(LocalizedStrings.PRQueryProcessor_TIMED_OUT_WHILE_EXECUTING_QUERY_TIME_EXCEEDED_0.toLocalizedString(
-                Integer.valueOf(BUCKET_QUERY_TIMEOUT)), e);
+            throw new InternalGemFireException(
+                LocalizedStrings.PRQueryProcessor_TIMED_OUT_WHILE_EXECUTING_QUERY_TIME_EXCEEDED_0
+                    .toLocalizedString(Integer.valueOf(BUCKET_QUERY_TIMEOUT)),
+                e);
-              throw (QueryException)cause;
-            }
-            else {
-              throw new InternalGemFireException(LocalizedStrings.PRQueryProcessor_GOT_UNEXPECTED_EXCEPTION_WHILE_EXECUTING_QUERY_ON_PARTITIONED_REGION_BUCKET.toLocalizedString(), 
-              cause);
+              throw (QueryException) cause;
+            } else {
+              throw new InternalGemFireException(
+                  LocalizedStrings.PRQueryProcessor_GOT_UNEXPECTED_EXCEPTION_WHILE_EXECUTING_QUERY_ON_PARTITIONED_REGION_BUCKET
+                      .toLocalizedString(),
+                  cause);
-        
+
-       
-        if(cs != null && (cs.isOrderBy() || cs.isGroupBy())) {      
+
+        if (cs != null && (cs.isOrderBy() || cs.isGroupBy())) {
-          Collection mergedResults =coalesceOrderedResults(resultCollector, context, cs, limit);
+          Collection mergedResults = coalesceOrderedResults(resultCollector, context, cs, limit);
-    
-    if (execService == null || execService.isShutdown()
-        || execService.isTerminated()) {
+
+    if (execService == null || execService.isShutdown() || execService.isTerminated()) {
-    
+
-    
+
-   * @throws ForceReattemptException
-   *           if bucket was moved so caller should try query again
+   * @throws ForceReattemptException if bucket was moved so caller should try query again
-  private void doBucketQuery(final Integer bId,
-                                    final PartitionedRegionDataStore prds,
-                                    final DefaultQuery query,
-                                    final Object[] params,
-                                    final PRQueryResultCollector rq)
-    throws QueryException, ForceReattemptException, InterruptedException {
-    final BucketRegion bukRegion = (BucketRegion)prds.localBucket2RegionMap.get(bId);
+  private void doBucketQuery(final Integer bId, final PartitionedRegionDataStore prds,
+      final DefaultQuery query, final Object[] params, final PRQueryResultCollector rq)
+      throws QueryException, ForceReattemptException, InterruptedException {
+    final BucketRegion bukRegion = (BucketRegion) prds.localBucket2RegionMap.get(bId);
-          throw new ForceReattemptException("Bucket id "
-                                            + pr.bucketStringForLogs(bId.intValue())
-                                            + " not found on VM "
-                                            + pr.getMyId());
+          throw new ForceReattemptException("Bucket id " + pr.bucketStringForLogs(bId.intValue())
+              + " not found on VM " + pr.getMyId());
-      
+
-      
-      if (!bukRegion.isBucketDestroyed()) {     
-        // If the result queue has reached the limit, no need to 
-        // execute the query. Handle the bucket destroy condition 
+
+      if (!bukRegion.isBucketDestroyed()) {
+        // If the result queue has reached the limit, no need to
+        // execute the query. Handle the bucket destroy condition
-          results = (SelectResults) query.prExecuteOnBucket(params, pr,
-              bukRegion);
-          this.resultType = results.getCollectionType().getElementType(); 
-        } 
-        
+          results = (SelectResults) query.prExecuteOnBucket(params, pr, bukRegion);
+          this.resultType = results.getCollectionType().getElementType();
+        }
+
-          // someday, when queries can return objects as a stream, the entire results set won't need to be manifested
+          // someday, when queries can return objects as a stream, the entire results set won't need
+          // to be manifested
-            for (Object r : results){
+            for (Object r : results) {
-                rq.put(DefaultQuery.NULL_RESULT);              
+                rq.put(DefaultQuery.NULL_RESULT);
-                // Count from each bucket should be > 0 otherwise limit makes the final result wrong.
-                // Avoid if query is distinct as this Integer could be a region value. 
-                if (!query.getSimpleSelect().isDistinct() && 
-                    query.getSimpleSelect().isCount() && r instanceof Integer) {
-                  if (((Integer) r).intValue() != 0 ) {
+                // Count from each bucket should be > 0 otherwise limit makes the final result
+                // wrong.
+                // Avoid if query is distinct as this Integer could be a region value.
+                if (!query.getSimpleSelect().isDistinct() && query.getSimpleSelect().isCount()
+                    && r instanceof Integer) {
+                  if (((Integer) r).intValue() != 0) {
-            
+
-   * @throws RegionDestroyedException if the given pr was destroyed 
+   * @throws RegionDestroyedException if the given pr was destroyed
-    throws ForceReattemptException, RegionDestroyedException {
+      throws ForceReattemptException, RegionDestroyedException {
-      throw new ForceReattemptException("Bucket id "
-                                        + pr.bucketStringForLogs(bId.intValue())
-                                        + " not found on VM "
-                                        + pr.getMyId());
+      throw new ForceReattemptException("Bucket id " + pr.bucketStringForLogs(bId.intValue())
+          + " not found on VM " + pr.getMyId());
-                                    
+
-    throws QueryException, InterruptedException, ForceReattemptException {
+      throws QueryException, InterruptedException, ForceReattemptException {
-    for (Iterator itr = _bucketsToQuery.iterator(); itr.hasNext(); ) {
-      Integer bId = (Integer)itr.next();
-      doBucketQuery(bId, this._prds, this.query, this.parameters, resultCollector);
-    }*/
-    
-    ExecutionContext context = new QueryExecutionContext(this.parameters, this.pr.getCache(), this.query);
-    
+     * for (Iterator itr = _bucketsToQuery.iterator(); itr.hasNext(); ) { Integer bId =
+     * (Integer)itr.next(); doBucketQuery(bId, this._prds, this.query, this.parameters,
+     * resultCollector); }
+     */
+
+    ExecutionContext context =
+        new QueryExecutionContext(this.parameters, this.pr.getCache(), this.query);
+
-    if(cs != null && cs.isOrderBy() ) {
-      for(Integer bucketID : this._bucketsToQuery) {
+    if (cs != null && cs.isOrderBy()) {
+      for (Integer bucketID : this._bucketsToQuery) {
-      }     
-      Collection mergedResults =coalesceOrderedResults(resultCollector, context, cs, limit);
+      }
+      Collection mergedResults = coalesceOrderedResults(resultCollector, context, cs, limit);
-      
-    }else {
-      context.setBucketList(buckets);        
+
+    } else {
+      context.setBucketList(buckets);
-  
-  private Collection coalesceOrderedResults(Collection<Collection> results, 
+
+  private Collection coalesceOrderedResults(Collection<Collection> results,
-    //TODO :Asif : Deal with UNDEFINED
-    for(Object o : results) {
-      if(o instanceof Collection) {
-        sortedResults.add((Collection)o);
-      }        
+    // TODO :Asif : Deal with UNDEFINED
+    for (Object o : results) {
+      if (o instanceof Collection) {
+        sortedResults.add((Collection) o);
+      }
-   
-    NWayMergeResults mergedResults = new NWayMergeResults(sortedResults, cs.isDistinct(), limit, 
-        cs.getOrderByAttrs(), context,cs.getElementTypeForOrderByQueries());
+
+    NWayMergeResults mergedResults = new NWayMergeResults(sortedResults, cs.isDistinct(), limit,
+        cs.getOrderByAttrs(), context, cs.getElementTypeForOrderByQueries());
-  
+
-      ExecutionContext context) throws ForceReattemptException,
-      QueryInvocationTargetException, QueryException {
+      ExecutionContext context)
+      throws ForceReattemptException, QueryInvocationTargetException, QueryException {
-    if (GemFireCacheImpl.getInstance() != null)
-    {
+    if (GemFireCacheImpl.getInstance() != null) {
-    
+
-      
+
-      
-      synchronized (resultCollector) {        
-        //TODO:Asif: In what situation would the results object itself be undefined?
+
+      synchronized (resultCollector) {
+        // TODO:Asif: In what situation would the results object itself be undefined?
-        /*if (results == QueryService.UNDEFINED) {
-          resultCollector.add(Collections.singleton(results));
-        } else {*/
-          this.resultType = ((SelectResults)results).getCollectionType().getElementType(); 
-          resultCollector.add((SelectResults) results);
-        //}
+        /*
+         * if (results == QueryService.UNDEFINED) {
+         * resultCollector.add(Collections.singleton(results)); } else {
+         */
+        this.resultType = ((SelectResults) results).getCollectionType().getElementType();
+        resultCollector.add((SelectResults) results);
+        // }
-      isIndexUsedForLocalQuery =((QueryExecutionContext)context).isIndexUsed();
-      
+      isIndexUsedForLocalQuery = ((QueryExecutionContext) context).isIndexUsed();
+
-      throw new ForceReattemptException("Query targeted local bucket not found." + bme.getMessage(), bme);
+      throw new ForceReattemptException("Query targeted local bucket not found." + bme.getMessage(),
+          bme);
-      throw new QueryInvocationTargetException("The Region on which query is executed may have been destroyed." +
-          rde.getMessage(), rde);
+      throw new QueryInvocationTargetException(
+          "The Region on which query is executed may have been destroyed." + rde.getMessage(), rde);
-        throw new ForceReattemptException("Local Partition Region or the targeted bucket has been moved");
-      } 
+        throw new ForceReattemptException(
+            "Local Partition Region or the targeted bucket has been moved");
+      }
-  private List buildCallableTaskList(Collection<Collection> resultsColl)
-  {
+  private List buildCallableTaskList(Collection<Collection> resultsColl) {
-      Integer bId = (Integer)itr.next();
+      Integer bId = (Integer) itr.next();
-  
+
-  
-  public static void shutdown()
-  {
-    PRQueryExecutor.shutdown();   
+
+  public static void shutdown() {
+    PRQueryExecutor.shutdown();
-  public static void shutdownNow()
-  {
+  public static void shutdownNow() {
-   * A ThreadPool ( Fixed Size ) with an executor service to execute the query
-   * execution spread over buckets.
+   * A ThreadPool ( Fixed Size ) with an executor service to execute the query execution spread over
+   * buckets.
-      if (execService == null || execService.isShutdown()
-          || execService.isTerminated()) {
+      if (execService == null || execService.isShutdown() || execService.isTerminated()) {
-  
+
-    * Status token placed in results stream to track completion of
-   * query results for a given bucket
+   * Status token placed in results stream to track completion of query results for a given bucket
-    
+
-    
+
-    public EndOfBucket() {
-    }
-    
+    public EndOfBucket() {}
+
-    
+
-    
+
-    
+
-    public void fromData(DataInput in)
-    throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    
+
-    }    
+    }
-  
+
-   * Implementation of call-able task to execute query on a bucket region. This
-   * task will be generated by the PRQueryProcessor.
+   * Implementation of call-able task to execute query on a bucket region. This task will be
+   * generated by the PRQueryProcessor.
-    
-    public QueryTask(DefaultQuery query, Object[] parameters, PartitionedRegionDataStore prDS, 
+
+    public QueryTask(DefaultQuery query, Object[] parameters, PartitionedRegionDataStore prDS,
-    
+
-        //Add indexInfo of this thread to result collector
+        // Add indexInfo of this thread to result collector
-          //((IndexTrackingQueryObserver)observer).setIndexInfo(resultColl.getIndexInfoMap());
+          // ((IndexTrackingQueryObserver)observer).setIndexInfo(resultColl.getIndexInfoMap());
-        
+
-        List<Integer> bucketList = Collections.singletonList(bId);       
-        ExecutionContext context = new QueryExecutionContext(this.parameters, pr.getCache(), this.query);
+        List<Integer> bucketList = Collections.singletonList(bId);
+        ExecutionContext context =
+            new QueryExecutionContext(this.parameters, pr.getCache(), this.query);
-        //executeSequentially(this.resultColl, bucketList);
+        // executeSequentially(this.resultColl, bucketList);
-        //doBucketQuery(bId, this._prDs, this.query, this.parameters, this.resultColl);
+        // doBucketQuery(bId, this._prDs, this.query, this.parameters, this.resultColl);
-    
+
-      * Encapsulates the result for the query on the bucket.
+     * Encapsulates the result for the query on the bucket.
-      
+
-      
+
-        * Constructor
+       * Constructor
-      
-      public Exception getException()
-      {
+
+      public Exception getException() {
-      
-      public boolean exceptionOccured()
-      {
+
+      public boolean exceptionOccured() {
-      
-      public void setException(Exception e)
-      {
+
+      public void setException(Exception e) {
-      
-      public Integer getBucketId()
-      {
+
+      public Integer getBucketId() {
-      
+
-      
-      public void handleAndThrowException() throws QueryException
-      {
+
+      public void handleAndThrowException() throws QueryException {
-            throw (QueryException)_ex;
-          }
-          else if (_ex instanceof CacheRuntimeException) {
-            throw (CacheRuntimeException)_ex;
+            throw (QueryException) _ex;
+          } else if (_ex instanceof CacheRuntimeException) {
+            throw (CacheRuntimeException) _ex;
-    }  
+    }

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-    
+
-        logger.debug("Acquired shared file lock w/ channel: {}, for JAR: {}", this.fileLock.channel(), file.getAbsolutePath());
+        logger.debug("Acquired shared file lock w/ channel: {}, for JAR: {}",
+            this.fileLock.channel(), file.getAbsolutePath());
-        throw new FileNotFoundException("JAR file was truncated prior to obtaining a lock: " + jarName);
+        throw new FileNotFoundException(
+            "JAR file was truncated prior to obtaining a lock: " + jarName);
-        throw new FileNotFoundException("JAR file: " + file.getAbsolutePath() + ", was modified prior to obtaining a lock: "
-            + jarName);
+        throw new FileNotFoundException("JAR file: " + file.getAbsolutePath()
+            + ", was modified prior to obtaining a lock: " + jarName);
-        
+
-            logger.debug("Prematurely releasing shared file lock due to bad content for JAR file: {}, w/ channel: {}", file.getAbsolutePath(), this.fileLock.channel());
+            logger.debug(
+                "Prematurely releasing shared file lock due to bad content for JAR file: {}, w/ channel: {}",
+                file.getAbsolutePath(), this.fileLock.channel());
-        throw new IllegalArgumentException("File does not contain valid JAR content: " + file.getAbsolutePath());
+        throw new IllegalArgumentException(
+            "File does not contain valid JAR content: " + file.getAbsolutePath());
-      
+
-          logger.debug("Prematurely releasing shared file lock due to file not found for JAR file: {}, w/ channel: {}", file.getAbsolutePath(), this.fileLock.channel());
+          logger.debug(
+              "Prematurely releasing shared file lock due to file not found for JAR file: {}, w/ channel: {}",
+              file.getAbsolutePath(), this.fileLock.channel());
-   * @param inputStream
-   *          InputStream containing data to be validated.
+   * @param inputStream InputStream containing data to be validated.
-  
+
-   * @param jarBytes
-   *          Bytes of data to be validated.
+   * @param jarBytes Bytes of data to be validated.
-  
+
-   * @param jarFile
-   *          File whose contents should be validated.
+   * @param jarFile File whose contents should be validated.
-    return hasValidJarContent(new FileInputStream(jarFile));
+      return hasValidJarContent(new FileInputStream(jarFile));
-  
+
-            logger.debug("Attempting to load class: {}, from JAR file: {}", jarEntry.getName(), this.file.getAbsolutePath());
+            logger.debug("Attempting to load class: {}, from JAR file: {}", jarEntry.getName(),
+                this.file.getAbsolutePath());
-          final String className = jarEntry.getName().replaceAll("/", "\\.").substring(0, (jarEntry.getName().length() - 6));
+          final String className = jarEntry.getName().replaceAll("/", "\\.").substring(0,
+              (jarEntry.getName().length() - 6));
-                logger.debug("Registering function class: {}, from JAR file: {}", className, this.file.getAbsolutePath());
+                logger.debug("Registering function class: {}, from JAR file: {}", className,
+                    this.file.getAbsolutePath());
-            logger.error("Unable to load all classes from JAR file: {}", this.file.getAbsolutePath(), cnfex);
+            logger.error("Unable to load all classes from JAR file: {}",
+                this.file.getAbsolutePath(), cnfex);
-            logger.error("Unable to load all classes from JAR file: {}", this.file.getAbsolutePath(), ncdfex);
+            logger.error("Unable to load all classes from JAR file: {}",
+                this.file.getAbsolutePath(), ncdfex);
-      TypeRegistry typeRegistry = ((GemFireCacheImpl) CacheFactory.getAnyInstance()).getPdxRegistry();
+      TypeRegistry typeRegistry =
+          ((GemFireCacheImpl) CacheFactory.getAnyInstance()).getPdxRegistry();
-        logger.debug("Released shared file lock on JAR file: {}, w/ channel: {}", this.file.getAbsolutePath(), this.fileLock.channel());
+        logger.debug("Released shared file lock on JAR file: {}, w/ channel: {}",
+            this.file.getAbsolutePath(), this.fileLock.channel());
-      logger.error("Could not release the shared lock for JAR file: {}", this.file.getAbsolutePath(), ioex);
+      logger.error("Could not release the shared lock for JAR file: {}",
+          this.file.getAbsolutePath(), ioex);
-   * Uses MD5 hashes to determine if the original byte content of this JarClassLoader is the same as that past in.
+   * Uses MD5 hashes to determine if the original byte content of this JarClassLoader is the same as
+   * that past in.
-   * @param compareToBytes
-   *          Bytes to compare the original content to
+   * @param compareToBytes Bytes to compare the original content to
-      logger.debug("For JAR file: {}, Comparing MD5 hash {} to {}", this.file.getAbsolutePath(), new String(this.md5hash), new String(compareToMd5));
+      logger.debug("For JAR file: {}, Comparing MD5 hash {} to {}", this.file.getAbsolutePath(),
+          new String(this.md5hash), new String(compareToMd5));
-    
+
-  public Class<?> loadClass(final String className, final boolean resolveIt) throws ClassNotFoundException {
+  public Class<?> loadClass(final String className, final boolean resolveIt)
+      throws ClassNotFoundException {
-  Class<?> loadClass(final String className, final boolean resolveIt, final boolean useClassPathLoader)
-      throws ClassNotFoundException {
+  Class<?> loadClass(final String className, final boolean resolveIt,
+      final boolean useClassPathLoader) throws ClassNotFoundException {
-   * Check to see if the class implements the Function interface. If so, it will be registered with FunctionService.
-   * Also, if the functions's class was originally declared in a cache.xml file then any properties specified at that
-   * time will be reused when re-registering the function.
+   * Check to see if the class implements the Function interface. If so, it will be registered with
+   * FunctionService. Also, if the functions's class was originally declared in a cache.xml file
+   * then any properties specified at that time will be reused when re-registering the function.
-   * @param clazz
-   *          Class to check for implementation of the Function class
+   * @param clazz Class to check for implementation of the Function class
-            final List<Properties> propertiesList = ((GemFireCacheImpl) CacheFactory.getAnyInstance())
-                .getDeclarableProperties(clazz.getName());
+            final List<Properties> propertiesList =
+                ((GemFireCacheImpl) CacheFactory.getAnyInstance())
+                    .getDeclarableProperties(clazz.getName());
-      logger.error("Attempting to register function from JAR file: " + this.file.getAbsolutePath(), ex);
+      logger.error("Attempting to register function from JAR file: " + this.file.getAbsolutePath(),
+          ex);
-  private Class<?> forName(final String className, final Collection<ClassLoader> classLoaders) throws ClassNotFoundException {
+  private Class<?> forName(final String className, final Collection<ClassLoader> classLoaders)
+      throws ClassNotFoundException {
-        logger.error("Zero-arg constructor is required, but not found for class: {}", clazz.getName(), nsmex);
+        logger.error("Zero-arg constructor is required, but not found for class: {}",
+            clazz.getName(), nsmex);
-          logger.debug("Not registering function because it doesn't have a zero-arg constructor: {}", clazz.getName());
+          logger.debug(
+              "Not registering function because it doesn't have a zero-arg constructor: {}",
+              clazz.getName());
-      logger.error("Zero-arg constructor of function not accessible for class: {}", clazz.getName(), sex);
+      logger.error("Zero-arg constructor of function not accessible for class: {}", clazz.getName(),
+          sex);
-      logger.error("Zero-arg constructor of function not accessible for class: {}", clazz.getName(), iae);
+      logger.error("Zero-arg constructor of function not accessible for class: {}", clazz.getName(),
+          iae);
-      logger.error("Error when attempting constructor for function for class: {}", clazz.getName(), ite);
+      logger.error("Error when attempting constructor for function for class: {}", clazz.getName(),
+          ite);
-   * When a lock is acquired it is done so through an open file (FileInputStream, etc.). If for any reason that same
-   * file is used to open another input stream, when the second input stream is closed the file lock will not be held
-   * (although an OverlappingFileLock exception will be thrown if an attempt is made to acquire the lock again). To get
-   * around this problem, this class is used to wrap the original file channel used by the lock with an InputStream.
-   * When this class is instantiated a lock is obtained to prevent other threads from attempting to use the file channel
-   * at the same time. The file channel can then be read as with any other InputStream. When the input stream is closed,
-   * instead of closing the file channel, the lock is released instead.
+   * When a lock is acquired it is done so through an open file (FileInputStream, etc.). If for any
+   * reason that same file is used to open another input stream, when the second input stream is
+   * closed the file lock will not be held (although an OverlappingFileLock exception will be thrown
+   * if an attempt is made to acquire the lock again). To get around this problem, this class is
+   * used to wrap the original file channel used by the lock with an InputStream. When this class is
+   * instantiated a lock is obtained to prevent other threads from attempting to use the file
+   * channel at the same time. The file channel can then be read as with any other InputStream. When
+   * the input stream is closed, instead of closing the file channel, the lock is released instead.
-   * This class is thread safe. However, multiple instances cannot be created by the same thread. The reason for this is
-   * that the lock will be obtained in all cases (it's reentrant), and then the channel position will be modified by
-   * both instances causing arbitrary values being returned from the read() method.
+   * This class is thread safe. However, multiple instances cannot be created by the same thread.
+   * The reason for this is that the lock will be obtained in all cases (it's reentrant), and then
+   * the channel position will be modified by both instances causing arbitrary values being returned
+   * from the read() method.

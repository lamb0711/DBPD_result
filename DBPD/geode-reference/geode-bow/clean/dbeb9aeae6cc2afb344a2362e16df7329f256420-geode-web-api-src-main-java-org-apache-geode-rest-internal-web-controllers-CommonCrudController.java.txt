Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Set;
-
-import com.wordnik.swagger.annotations.ApiOperation;
-import com.wordnik.swagger.annotations.ApiResponse;
-import com.wordnik.swagger.annotations.ApiResponses;
+import io.swagger.annotations.ApiOperation;
+import io.swagger.annotations.ApiResponse;
+import io.swagger.annotations.ApiResponses;
+import org.springframework.security.access.prepost.PreAuthorize;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
- * The CommonCrudController serves REST Requests related to listing regions, 
- * listing keys in region, delete keys or delete all data in region.
- * <p/>
+ * The CommonCrudController serves REST Requests related to listing regions, listing keys in region,
+ * delete keys or delete all data in region.
+ *
-
-  
+
-  
+
-   * list all available resources (Regions) in the GemFire cluster
+   * List all available resources (Regions) in the GemFire cluster
+   *
-  @RequestMapping(method = RequestMethod.GET, produces = { MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_JSON_VALUE })
-  @ApiOperation(
-    value = "list all resources (Regions)",
-    notes = "List all available resources (Regions) in the GemFire cluster",
-    response  = void.class
-  )
-  @ApiResponses( {
-    @ApiResponse( code = 200, message = "OK." ),
-    @ApiResponse( code = 401, message = "Invalid Username or Password." ),
-    @ApiResponse( code = 403, message = "Insufficient privileges for operation." ),
-    @ApiResponse( code = 500, message = "GemFire throws an error or exception." )
-  } )
+  @RequestMapping(method = RequestMethod.GET, produces = {MediaType.APPLICATION_JSON_UTF8_VALUE})
+  @ApiOperation(value = "list all resources (Regions)",
+      notes = "List all available resources (Regions) in the Geode cluster", response = void.class)
+  @ApiResponses({@ApiResponse(code = 200, message = "OK."),
+      @ApiResponse(code = 401, message = "Invalid Username or Password."),
+      @ApiResponse(code = 403, message = "Insufficient privileges for operation."),
+      @ApiResponse(code = 500, message = "GemFire throws an error or exception.")})
+  @PreAuthorize("@securityService.authorize('DATA', 'READ')")
-    securityService.authorizeDataRead();
-    if(logger.isDebugEnabled()){
-      logger.debug("Listing all resources (Regions) in GemFire...");
-    }
+    logger.debug("Listing all resources (Regions) in Geode...");
-    String listRegionsAsJson =  JSONUtils.formulateJsonForListRegions(regions, "regions");
+    String listRegionsAsJson = JSONUtils.formulateJsonForListRegions(regions, "regions");
-  
+
+   *
-                  produces = { MediaType.APPLICATION_JSON_VALUE } )
-  @ApiOperation(
-    value = "list all keys",
-    notes = "List all keys in region",
-    response  = void.class
-  )
-  @ApiResponses( {
-    @ApiResponse( code = 200, message = "OK" ),
-    @ApiResponse( code = 401, message = "Invalid Username or Password." ),
-    @ApiResponse( code = 403, message = "Insufficient privileges for operation." ),
-    @ApiResponse( code = 404, message = "Region does not exist" ),
-    @ApiResponse( code = 500, message = "GemFire throws an error or exception" )   
-  } )
-  public ResponseEntity<?> keys(@PathVariable("region") String region){
-    securityService.authorizeRegionRead(region);
-    if(logger.isDebugEnabled()){
-      logger.debug("Reading all Keys in Region ({})...", region);
-    }
-    
+      produces = {MediaType.APPLICATION_JSON_UTF8_VALUE})
+  @ApiOperation(value = "list all keys", notes = "List all keys in region", response = void.class)
+  @ApiResponses({@ApiResponse(code = 200, message = "OK"),
+      @ApiResponse(code = 401, message = "Invalid Username or Password."),
+      @ApiResponse(code = 403, message = "Insufficient privileges for operation."),
+      @ApiResponse(code = 404, message = "Region does not exist"),
+      @ApiResponse(code = 500, message = "GemFire throws an error or exception")})
+  @PreAuthorize("@securityService.authorize('DATA', 'READ', #region)")
+  public ResponseEntity<?> keys(@PathVariable("region") String region) {
+    logger.debug("Reading all Keys in Region ({})...", region);
+
-    
-    Object[] keys = getKeys(region, null);  
-    
-    String listKeysAsJson =  JSONUtils.formulateJsonForListKeys(keys, "keys");
-    final HttpHeaders headers = new HttpHeaders();  
+
+    Object[] keys = getKeys(region, null);
+
+    String listKeysAsJson = JSONUtils.formulateJsonForListKeys(keys, "keys");
+    final HttpHeaders headers = new HttpHeaders();
-  
+
+   *
-                  produces = { MediaType.APPLICATION_JSON_VALUE } )
-  @ApiOperation(
-    value = "delete data for key(s)",
-    notes = "Delete data for single key or specific keys in region",
-    response  = void.class
-  )
-  @ApiResponses( {
-    @ApiResponse( code = 200, message = "OK" ),
-    @ApiResponse( code = 401, message = "Invalid Username or Password." ),
-    @ApiResponse( code = 403, message = "Insufficient privileges for operation." ),
-    @ApiResponse( code = 404, message = "Region or key(s) does not exist" ),
-    @ApiResponse( code = 500, message = "GemFire throws an error or exception" )      
-  } )
+      produces = {MediaType.APPLICATION_JSON_VALUE})
+  @ApiOperation(value = "delete data for key(s)",
+      notes = "Delete data for single key or specific keys in region", response = void.class)
+  @ApiResponses({@ApiResponse(code = 200, message = "OK"),
+      @ApiResponse(code = 401, message = "Invalid Username or Password."),
+      @ApiResponse(code = 403, message = "Insufficient privileges for operation."),
+      @ApiResponse(code = 404, message = "Region or key(s) does not exist"),
+      @ApiResponse(code = 500, message = "GemFire throws an error or exception")})
+  @PreAuthorize("@securityService.authorize('WRITE', #region, #keys)")
-                                  @PathVariable("keys") final String[] keys){
-    for (String key : keys)
-      securityService.authorizeRegionWrite(region, key);
-    if(logger.isDebugEnabled()){
-      logger.debug("Delete data for key {} on region {}", ArrayUtils.toString((Object[])keys), region);
-    }
-    
+      @PathVariable("keys") final String[] keys) {
+    logger.debug("Delete data for key {} on region {}", ArrayUtils.toString((Object[]) keys),
+        region);
+
-    
-    deleteValues(region, (Object[])keys);
+
+    deleteValues(region, (Object[]) keys);
+   *
-  @ApiOperation(
-    value = "delete all data",
-    notes = "Delete all data in the region",
-    response  = void.class
-  )
-  @ApiResponses( {
-    @ApiResponse( code = 200, message = "OK" ),
-    @ApiResponse( code = 401, message = "Invalid Username or Password." ),
-    @ApiResponse( code = 403, message = "Insufficient privileges for operation." ),
-    @ApiResponse( code = 404, message = "Region does not exist" ),
-    @ApiResponse( code = 500, message = "if GemFire throws an error or exception" )   
-  } )
+  @ApiOperation(value = "delete all data", notes = "Delete all data in the region",
+      response = void.class)
+  @ApiResponses({@ApiResponse(code = 200, message = "OK"),
+      @ApiResponse(code = 401, message = "Invalid Username or Password."),
+      @ApiResponse(code = 403, message = "Insufficient privileges for operation."),
+      @ApiResponse(code = 404, message = "Region does not exist"),
+      @ApiResponse(code = 500, message = "if GemFire throws an error or exception")})
+  @PreAuthorize("@securityService.authorize('DATA', 'WRITE', #region)")
-    securityService.authorizeRegionWrite(region);
-    if(logger.isDebugEnabled()){
-      logger.debug("Deleting all data in Region ({})...", region);
-    }
+    logger.debug("Deleting all data in Region ({})...", region);
-    
+
-   * @return
-  @RequestMapping(method = { RequestMethod.GET, RequestMethod.HEAD }, value = "/ping")
-  @ApiOperation(
-    value = "Check Rest service status ",
-    notes = "Check whether gemfire REST service is up and running!",
-    response  = void.class
-  )
-  @ApiResponses( {
-    @ApiResponse( code = 200, message = "OK" ),
-    @ApiResponse( code = 500, message = "if GemFire throws an error or exception" )   
-  } )
+  @RequestMapping(method = {RequestMethod.GET, RequestMethod.HEAD}, value = "/ping")
+  @ApiOperation(value = "Check Rest service status ",
+      notes = "Check whether gemfire REST service is up and running!", response = void.class)
+  @ApiResponses({@ApiResponse(code = 200, message = "OK"),
+      @ApiResponse(code = 500, message = "if GemFire throws an error or exception")})
-  
-  @RequestMapping(method = { RequestMethod.GET }, value = "/servers")
-  @ApiOperation(
-    value = "fetch all REST enabled servers in the DS",
-    notes = "Find all gemfire node where developer REST service is up and running!",
-    response  = void.class
-  )
-  @ApiResponses( {
-    @ApiResponse( code = 200, message = "OK" ),
-    @ApiResponse( code = 401, message = "Invalid Username or Password." ),
-    @ApiResponse( code = 403, message = "Insufficient privileges for operation." ),
-    @ApiResponse( code = 500, message = "if GemFire throws an error or exception" )
-  } )
+
+  @RequestMapping(method = {RequestMethod.GET}, value = "/servers",
+      produces = {MediaType.APPLICATION_JSON_UTF8_VALUE})
+  @ApiOperation(value = "fetch all REST enabled servers in the DS",
+      notes = "Find all gemfire node where developer REST service is up and running!",
+      response = void.class)
+  @ApiResponses({@ApiResponse(code = 200, message = "OK"),
+      @ApiResponse(code = 401, message = "Invalid Username or Password."),
+      @ApiResponse(code = 403, message = "Insufficient privileges for operation."),
+      @ApiResponse(code = 500, message = "if GemFire throws an error or exception")})
+  @PreAuthorize("@securityService.authorize('CLUSTER', 'READ')")
-    securityService.authorizeClusterRead();
-    if(logger.isDebugEnabled()){
-      logger.debug("Executing function to get REST enabled gemfire nodes in the DS!");
-    }
+    logger.debug("Executing function to get REST enabled gemfire nodes in the DS!");
-    } catch(FunctionException fe) {
-      throw new GemfireRestException("Disributed system does not contain any valid data node that can host REST service!", fe);
+    } catch (FunctionException fe) {
+      throw new GemfireRestException(
+          "Disributed system does not contain any valid data node that can host REST service!", fe);
-        
+
-      final ResultCollector<?, ?> results = function.withCollector(new RestServersResultCollector()).execute(GemFireCacheImpl.FIND_REST_ENABLED_SERVERS_FUNCTION_ID);
+      final ResultCollector<?, ?> results = function.withCollector(new RestServersResultCollector())
+          .execute(GemFireCacheImpl.FIND_REST_ENABLED_SERVERS_FUNCTION_ID);
-      
-      if(functionResult instanceof List<?>) {
+
+      if (functionResult instanceof List<?>) {
-        try {    
-          String functionResultAsJson = JSONUtils.convertCollectionToJson((ArrayList<Object>)functionResult);
+        try {
+          String functionResultAsJson =
+              JSONUtils.convertCollectionToJson((ArrayList<Object>) functionResult);
-          throw new GemfireRestException("Could not convert function results into Restful (JSON) format!", e);
+          throw new GemfireRestException(
+              "Could not convert function results into Restful (JSON) format!", e);
-      }else {
-        throw new GemfireRestException("Function has returned results that could not be converted into Restful (JSON) format!");
+      } else {
+        throw new GemfireRestException(
+            "Function has returned results that could not be converted into Restful (JSON) format!");
-      
-    } catch(ClassCastException cce){
+
+    } catch (ClassCastException cce) {
-    } catch(NullPointerException npe){
-      throw new GemfireRestException("Specified key is null and this region does not permit null keys!", npe);
-    } catch(LowMemoryException lme){
+    } catch (NullPointerException npe) {
+      throw new GemfireRestException(
+          "Specified key is null and this region does not permit null keys!", npe);
+    } catch (LowMemoryException lme) {
-    }catch (FunctionException fe){
-      throw new GemfireRestException("Server has encountered error while executing the function!", fe);
+    } catch (FunctionException fe) {
+      throw new GemfireRestException("Server has encountered error while executing the function!",
+          fe);

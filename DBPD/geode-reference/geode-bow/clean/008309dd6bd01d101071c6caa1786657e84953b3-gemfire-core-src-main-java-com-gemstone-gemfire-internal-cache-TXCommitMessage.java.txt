Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
-public final class TXCommitMessage extends PooledDistributionMessage implements MembershipListener, MessageWithReply
+public class TXCommitMessage extends PooledDistributionMessage implements MembershipListener, MessageWithReply
-
+  
-  private transient ArrayList farSideEntryOps;
+  protected transient ArrayList farSideEntryOps;
+      try {
+    } finally {
+      if (txEvent != null) {
+        txEvent.freeOffHeapResources();
+      }
+    }
+      List<EntryEventImpl> pendingCallbacks = new ArrayList<>(this.farSideEntryOps.size());
-          entryOp.process();
+          entryOp.process(pendingCallbacks);
+      firePendingCallbacks(pendingCallbacks);
-  
-  private void processCacheRuntimeException(CacheRuntimeException problem) {
+
+  private void firePendingCallbacks(List<EntryEventImpl> callbacks) {
+    Iterator<EntryEventImpl> ci = callbacks.iterator();
+    while(ci.hasNext()) {
+      EntryEventImpl ee = ci.next();
+      try {
+        if (ee.getOperation().isDestroy()) {
+          ee.getRegion().invokeTXCallbacks(EnumListenerEvent.AFTER_DESTROY, ee, true);
+        } else if (ee.getOperation().isInvalidate()) {
+          ee.getRegion().invokeTXCallbacks(EnumListenerEvent.AFTER_INVALIDATE, ee, true);
+        } else if (ee.getOperation().isCreate()) {
+          ee.getRegion().invokeTXCallbacks(EnumListenerEvent.AFTER_CREATE, ee, true);
+        } else {
+          ee.getRegion().invokeTXCallbacks(EnumListenerEvent.AFTER_UPDATE, ee, true);
+        }
+      } finally {
+        ee.release();
+      }
+    }
+  }
+
+  protected void processCacheRuntimeException(CacheRuntimeException problem) {
-    protected void txApplyEntryOp(FarSideEntryOp entryOp)
+    protected void txApplyEntryOp(FarSideEntryOp entryOp, List<EntryEventImpl> pendingCallbacks)
-        eei.invokeCallbacks(this.r, skipListeners, true);
+        eei.setInvokePRCallbacks(!skipListeners);
+        pendingCallbacks.add(eei);
-                              null /* fire inline, no pending callbacks */,
+                              pendingCallbacks,
-                                 null /* fire inline, no pending callbacks */,
+                                 pendingCallbacks,
-                          null /* fire inline, no pending callbacks */,
+                          pendingCallbacks,
+
+    /**
+     * Apply a single tx entry op on the far side
+     */
+    @SuppressWarnings("synthetic-access")
+    protected void txApplyEntryOpAdjunctOnly(FarSideEntryOp entryOp)
+    {
+      if (this.r == null) {
+        return;
+      }
+      EventID eventID = getEventId(entryOp);
+      boolean isDuplicate = this.r.hasSeenEvent(eventID);
+      boolean callbacksOnly = (this.r.getDataPolicy() == DataPolicy.PARTITION)
+          || isDuplicate;
+      if (this.r instanceof PartitionedRegion) {
+        
+        PartitionedRegion pr = (PartitionedRegion)r;
+        BucketRegion br = pr.getBucketRegion(entryOp.key);
+        Set bucketOwners = br.getBucketOwners();
+        InternalDistributedMember thisMember = GemFireCacheImpl.getExisting().getDistributionManager().getId();
+        if (bucketOwners.contains(thisMember)) {
+          return;
+        }
+        
+        /*
+         * This happens when we don't have the bucket and are getting adjunct notification
+         */
+        EntryEventImpl eei = AbstractRegionMap.createCBEvent(this.r, entryOp.op, entryOp.key, entryOp.value, this.msg.txIdent, txEvent, getEventId(entryOp), entryOp.callbackArg,entryOp.filterRoutingInfo,this.msg.bridgeContext, null, entryOp.versionTag, entryOp.tailKey);
+        try {
+        if(entryOp.filterRoutingInfo!=null) {
+          eei.setLocalFilterInfo(entryOp.filterRoutingInfo.getFilterInfo(this.r.getCache().getMyId()));
+        }
+        if (isDuplicate) {
+          eei.setPossibleDuplicate(true);
+        }
+        if (logger.isDebugEnabled()) {
+          logger.debug("invoking transactional callbacks for {} key={} needsUnlock={} event={}", entryOp.op, entryOp.key, this.needsUnlock, eei);
+        }
+        // we reach this spot because the event is either delivered to this member
+        // as an "adjunct" message or because the bucket was being created when
+        // the message was sent and already reflects the change caused by this event.
+        // In the latter case we need to invoke listeners
+        final boolean skipListeners = !isDuplicate;
+        eei.invokeCallbacks(this.r, skipListeners, true);
+        } finally {
+          eei.release();
+        }
+        return;
+      }
+    }
+
+    
-      public void process() {
-        txApplyEntryOp(this);
+      public void process(List<EntryEventImpl> pendingCallbacks) {
+        txApplyEntryOp(this, pendingCallbacks);
+      }
+      
+      public void processAdjunctOnly() {
+        txApplyEntryOpAdjunctOnly(this);
-      InternalDistributedMember whoSuspected) {
+      InternalDistributedMember whoSuspected, String reason) {

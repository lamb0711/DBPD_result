Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import org.apache.geode.internal.concurrent.ConcurrentHashSet;
-import java.util.ArrayList;
-import java.util.Collections;
-  static final String ENABLE_MONITOR_THREAD = DistributionConfig.GEMFIRE_PREFIX + "stats.enableMonitorThread";
-  static final boolean enableMonitorThread = Boolean.getBoolean(ENABLE_MONITOR_THREAD);
-  
+  protected static final String ENABLE_MONITOR_THREAD =
+      DistributionConfig.GEMFIRE_PREFIX + "stats.enableMonitorThread";
+
+  private final boolean enableMonitorThread;
+
-  private volatile List<StatisticsMonitor> monitors = 
-      Collections.<StatisticsMonitor>emptyList();
-  
+  private final ConcurrentHashSet<StatisticsMonitor> monitors =
+      new ConcurrentHashSet<StatisticsMonitor>();
+
+    this.enableMonitorThread = Boolean.getBoolean(ENABLE_MONITOR_THREAD);
-  
+
-      List<StatisticsMonitor> oldMonitors = this.monitors;
-      if (!oldMonitors.contains(monitor)) {
-        List<StatisticsMonitor> newMonitors = new ArrayList<StatisticsMonitor>(oldMonitors);
-        added = newMonitors.add(monitor);
-        this.monitors = Collections.unmodifiableList(newMonitors);
+      if (!this.monitors.contains(monitor)) {
+        added = this.monitors.add(monitor);
-      if (enableMonitorThread && !this.monitors.isEmpty() && this.notifier == null) {
-        this.notifier = new StatMonitorNotifier();
-        this.notifier.start();
+      if (!this.monitors.isEmpty()) {
+        startNotifier_IfEnabledAndNotRunning();
-      List<StatisticsMonitor> oldMonitors = this.monitors;
-      if (oldMonitors.contains(monitor)) {
-        List<StatisticsMonitor> newMonitors = new ArrayList<StatisticsMonitor>(oldMonitors);
-        removed = newMonitors.remove(monitor);
-        this.monitors = Collections.unmodifiableList(newMonitors);
+      if (this.monitors.contains(monitor)) {
+        removed = this.monitors.remove(monitor);
-      if (enableMonitorThread && this.monitors.isEmpty() && this.notifier != null) {
-        this.notifier.stop();
-        this.notifier = null;
+      if (this.monitors.isEmpty()) {
+        stopNotifier_IfEnabledAndRunning();
-  
+
-      if (enableMonitorThread && this.notifier != null) {
-        this.notifier.stop();
-      }
+      stopNotifier_IfEnabledAndRunning();
-  
+
-      if (enableMonitorThread) {
+      if (this.enableMonitorThread) {
-  
+
-    List<StatisticsMonitor> currentMonitors = StatMonitorHandler.this.monitors;
-    for (StatisticsMonitor monitor : currentMonitors) {
+    for (StatisticsMonitor monitor : StatMonitorHandler.this.monitors) {
-      }
-      catch (Error e) {
+      } catch (Error e) {
-        logger.warn(LogMarker.STATISTICS, "StatisticsMonitor {} threw {}", monitor, e.getClass().getSimpleName(), e);
-      }
-      catch (RuntimeException e) {
-        logger.warn(LogMarker.STATISTICS, "StatisticsMonitor {} threw {}", monitor, e.getClass().getSimpleName(), e);
+        logger.warn(LogMarker.STATISTICS, "StatisticsMonitor {} threw {}", monitor,
+            e.getClass().getSimpleName(), e);
+      } catch (RuntimeException e) {
+        logger.warn(LogMarker.STATISTICS, "StatisticsMonitor {} threw {}", monitor,
+            e.getClass().getSimpleName(), e);
-  public void allocatedResourceType(ResourceType resourceType) {
-  }
+  public void allocatedResourceType(ResourceType resourceType) {}
-  public void allocatedResourceInstance(ResourceInstance resourceInstance) {
-  }
+  public void allocatedResourceInstance(ResourceInstance resourceInstance) {}
-  public void destroyedResourceInstance(ResourceInstance resourceInstance) {
-  }
+  public void destroyedResourceInstance(ResourceInstance resourceInstance) {}
-  List<StatisticsMonitor> getMonitorsSnapshot() {
-    return Collections.unmodifiableList(this.monitors);
+  ConcurrentHashSet<StatisticsMonitor> getMonitorsSnapshot() {
+    return this.monitors;
-  
+
-    synchronized (this) {
-      return this.notifier;
+    return this.notifier;
+  }
+
+  private void startNotifier_IfEnabledAndNotRunning() {
+    if (this.enableMonitorThread && this.notifier == null) {
+      this.notifier = new StatMonitorNotifier();
+      this.notifier.start();
-  
+
+  private void stopNotifier_IfEnabledAndRunning() {
+    if (this.enableMonitorThread && this.notifier != null) {
+      this.notifier.stop();
+      this.notifier = null;
+    }
+  }
+
-    
+
-    
+
-    
+
-    
+
-    StatMonitorNotifier() {
-    }
-    
+    StatMonitorNotifier() {}
+
-    
+
-            List<StatisticsMonitor> currentMonitors = StatMonitorHandler.this.monitors;
-            for (StatisticsMonitor monitor : currentMonitors) {
+            for (StatisticsMonitor monitor : StatMonitorHandler.this.monitors) {
-                monitor.monitor(latestTask.getSampleTimeMillis(), 
-                                latestTask.getResourceInstances());
+                monitor.monitor(latestTask.getSampleTimeMillis(),
+                    latestTask.getResourceInstances());
-              }
-              catch (Error e) {
+              } catch (Error e) {
-                logger.warn(LogMarker.STATISTICS, "StatisticsMonitor {} threw {}", monitor, e.getClass().getSimpleName(), e);
-              }
-              catch (RuntimeException e) {
-                logger.warn(LogMarker.STATISTICS, "StatisticsMonitor {} threw {}", monitor, e.getClass().getSimpleName(), e);
+                logger.warn(LogMarker.STATISTICS, "StatisticsMonitor {} threw {}", monitor,
+                    e.getClass().getSimpleName(), e);
+              } catch (RuntimeException e) {
+                logger.warn(LogMarker.STATISTICS, "StatisticsMonitor {} threw {}", monitor,
+                    e.getClass().getSimpleName(), e);
-      
+
-    
+
-    
+
-  
+
-    private final long sampleTimeMillis; 
+    private final long sampleTimeMillis;
-    
+
-    
+
-    
+

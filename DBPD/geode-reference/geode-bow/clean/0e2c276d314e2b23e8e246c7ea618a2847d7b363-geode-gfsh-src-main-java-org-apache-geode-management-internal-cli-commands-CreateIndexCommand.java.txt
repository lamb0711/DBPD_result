GEODE-8055: create index command should work on sub regions (#5034)


+import java.util.HashSet;
-import java.util.Objects;
-import java.util.stream.Collectors;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.geode.cache.configuration.CacheConfig;
+import org.apache.geode.distributed.ConfigurationPersistenceService;
-import org.apache.geode.management.api.ClusterManagementService;
-import org.apache.geode.management.configuration.Region;
+import org.apache.geode.management.configuration.AbstractConfiguration;
-    ClusterManagementService cms = getClusterManagementService();
-      regionName = getValidRegionName(regionPath, cms);
-      Set<String> calculatedGroups = getGroupsContainingRegion(cms, regionName);
+      regionName = getValidRegionName(regionPath);
+      Set<String> calculatedGroups = getGroupsContainingRegion(ccService, regionName);
-        // the calculatedGroups will have null value to indicate the "cluster" level, in thise case
+        // the calculatedGroups will have "cluster" value to indicate the "cluster" level, in thise
+        // case
-        groups = calculatedGroups.stream().filter(Objects::nonNull).toArray(String[]::new);
+        groups = calculatedGroups.stream().filter(s -> !AbstractConfiguration.CLUSTER.equals(s))
+            .toArray(String[]::new);
-    // group
-    // information.
+    // group information.
-  // this also handles the possibility when regionName has "." in it, like "/A.B". It's stripping
-  // . part one by one and check if the remaining part is a valid region name or not. If we
-  // could not find a region with any part of the name, (like, couldn't find A.B or A), then A is
-  // returned.
-  String getValidRegionName(String regionPath, ClusterManagementService cms) {
-    // Check to see if the region path contains an alias e.g "/region1 r1"
-    // Then the first string will be the regionPath
+  // since we can't create index on regions with . in it's name, we will assume tht regionName
+  // returned here should not have "."
+  String getValidRegionName(String regionPath) {
-    // check to see if the region path is in the form of "--region=region.entrySet() z"
-    while (regionName.contains(".")) {
-      Set<String> groupsContainingRegion = getGroupsContainingRegion(cms, regionName);
-      if (!groupsContainingRegion.isEmpty()) {
-        break;
-      }
-      // otherwise, strip one more . part off the regionName
-      else {
-        regionName = regionName.substring(0, regionName.lastIndexOf("."));
-      }
+    regionName = StringUtils.removeStart(regionName, "/");
+    if (regionName.contains(".")) {
+      regionName = regionName.substring(0, regionName.indexOf('.'));
-  // if region belongs to "cluster" level, it will return a set of one null value
-  Set<String> getGroupsContainingRegion(ClusterManagementService cms,
+  // if region belongs to "cluster" level, it will return a set containing "cluster" string
+  Set<String> getGroupsContainingRegion(ConfigurationPersistenceService cps,
-    Region regionConfig = new Region();
-    regionConfig.setName(regionName);
-    List<Region> regions = cms.list(regionConfig).getConfigResult();
-    return regions.stream().map(Region::getGroup)
-        .collect(Collectors.toSet());
+    Set<String> foundGroups = new HashSet<>();
+    for (String group : cps.getGroups()) {
+      CacheConfig cacheConfig = cps.getCacheConfig(group, true);
+      if (cacheConfig.findRegionConfiguration(regionName) != null) {
+        foundGroups.add(group);
+      }
+    }
+    return foundGroups;
-

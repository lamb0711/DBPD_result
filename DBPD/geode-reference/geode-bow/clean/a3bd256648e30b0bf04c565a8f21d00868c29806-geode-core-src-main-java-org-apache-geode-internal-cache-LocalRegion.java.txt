GEODE-706 Fixed race condition between expiry thread and put thread.

There was possibility that expiry thread destroying the entry and
another thread doing update on same key. In this case expiry thread
cancel's existing task and update thread adds expiry task. But this
tasks are refer by regionEntry, which is same for both the threads.
So in this case if expiry thread cancel's task after update thread
then that entry will never expire.

+  
+  void cancelExpiryTask(RegionEntry re) {
+    cancelExpiryTask(re, null);
+  }
-  void cancelExpiryTask(RegionEntry re)
+  void cancelExpiryTask(RegionEntry re, ExpiryTask expiryTask)
-    EntryExpiryTask oldTask = this.entryExpiryTasks.remove(re);
-    if (oldTask != null) {
-      if (oldTask.cancel()) {
+    if (expiryTask != null) {
+      this.entryExpiryTasks.remove(re, expiryTask);
+      if (expiryTask.cancel()) {
+    } else {
+      EntryExpiryTask oldTask = this.entryExpiryTasks.remove(re);
+      if (oldTask != null) {
+        if (oldTask.cancel()) {
+          this.cache.getExpirationScheduler().incCancels();
+        }
+      }

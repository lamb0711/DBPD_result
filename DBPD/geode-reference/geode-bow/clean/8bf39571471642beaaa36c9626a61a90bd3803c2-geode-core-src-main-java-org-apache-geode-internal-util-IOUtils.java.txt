Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ * 
-   * Gets a fully qualified path with the path elements appended to the specified pathname using the File.separator
-   * character.  If the pathname is unspecified (null, empty or blank) then path elements are considered relative to
-   * file system root, beginning with File.separator.  If array of path elements are null, then the pathname is
-   * returned as is.
+   * Gets a fully qualified path with the path elements appended to the specified pathname using the
+   * File.separator character. If the pathname is unspecified (null, empty or blank) then path
+   * elements are considered relative to file system root, beginning with File.separator. If array
+   * of path elements are null, then the pathname is returned as is.
+   * 
-   * Invokes the close method on any class instance implementing the Closeable interface, such as InputStreams
-   * and OutputStreams.  Note, this method silently ignores the possible IOException resulting from the close
-   * invocation.
+   * Invokes the close method on any class instance implementing the Closeable interface, such as
+   * InputStreams and OutputStreams. Note, this method silently ignores the possible IOException
+   * resulting from the close invocation.
+   * 
-      }
-      catch (IOException ignore) {
+      } catch (IOException ignore) {
+   * 
-   * @return a fully constructed pathname containing the elements from the given array as path elements separated
-   * by File.separator.
+   * @return a fully constructed pathname containing the elements from the given array as path
+   *         elements separated by File.separator.
+   * 
-   * @param separator a String specifying the separator of the path.  If the given String is null, then separator
-   * defaults to File.separator
-   * @return a fully constructor pathname containing the elements of the path from the given array separated
-   * by separator.
+   * @param separator a String specifying the separator of the path. If the given String is null,
+   *        then separator defaults to File.separator
+   * @return a fully constructor pathname containing the elements of the path from the given array
+   *         separated by separator.
+   * 
-  public static Object deserializeObject(final byte[] objBytes) throws IOException, ClassNotFoundException {
+  public static Object deserializeObject(final byte[] objBytes)
+      throws IOException, ClassNotFoundException {
-    }
-    finally {
+    } finally {
-   * Convenience method to de-serialize a byte array back into an Object who's Class type is resolved by the specific
-   * ClassLoader.
+   * Convenience method to de-serialize a byte array back into an Object who's Class type is
+   * resolved by the specific ClassLoader.
+   * 
-   * @throws ClassNotFoundException if the Class type of the serialized Object cannot be resolved by the specified
-   * ClassLoader.
-   * @throws IOException if an I/O error occurs while de-serializing the Object from the array of bytes.
+   * @throws ClassNotFoundException if the Class type of the serialized Object cannot be resolved by
+   *         the specified ClassLoader.
+   * @throws IOException if an I/O error occurs while de-serializing the Object from the array of
+   *         bytes.
-  public static Object deserializeObject(final byte[] objBytes, final ClassLoader loader) throws IOException, ClassNotFoundException {
+  public static Object deserializeObject(final byte[] objBytes, final ClassLoader loader)
+      throws IOException, ClassNotFoundException {
-    }
-    finally {
+    } finally {
+   * 
+   * 
-   * @return a boolean indicating whether the path represented by name (pathname) actually exists in the file system
-   * of the localhost (system).
+   * @return a boolean indicating whether the path represented by name (pathname) actually exists in
+   *         the file system of the localhost (system).
+   * 
-    }
-    finally {
+    } finally {
+   * 
-    }
-    finally {
+    } finally {
-   * This method attempts to get the canonical form of the specified file otherwise returns it's absolute form.
+   * This method attempts to get the canonical form of the specified file otherwise returns it's
+   * absolute form.
+   * 
-   * @return the canonical form of the specified File or the absolute form if an IOException occurs during the
-   * File.getCanonicalFile call.
+   * @return the canonical form of the specified File or the absolute form if an IOException occurs
+   *         during the File.getCanonicalFile call.
-    }
-    catch (IOException e) {
+    } catch (IOException e) {
-   * This method attempts to get the canonical path of the specified file otherwise returns it's absolute path.
+   * This method attempts to get the canonical path of the specified file otherwise returns it's
+   * absolute path.
+   * 
-   * @return the canonical path of the specified File or the absolute path if an IOException occurs during the
-   * File.getCanonicalPath call.
+   * @return the canonical path of the specified File or the absolute path if an IOException occurs
+   *         during the File.getCanonicalPath call.
-    }
-    catch (IOException e) {
+    } catch (IOException e) {
-   * Verifies that the specified pathname is valid and actually exists in the file system in localhost.  The pathname
-   * is considered valid if it is not null, empty or blank and exists in the file system as a file path (which could
-   * represent a file or a directory).
+   * Verifies that the specified pathname is valid and actually exists in the file system in
+   * localhost. The pathname is considered valid if it is not null, empty or blank and exists in the
+   * file system as a file path (which could represent a file or a directory).
+   * 
-   * @throws FileNotFoundException if the pathname is invalid or does not exist in the file system on localhost.
+   * @throws FileNotFoundException if the pathname is invalid or does not exist in the file system
+   *         on localhost.
-   * The ClassLoaderObjectInputStream class is a ObjectInputStream implementation that resolves the Class type of
-   * the Object being de-serialized with the specified ClassLoader.
+   * The ClassLoaderObjectInputStream class is a ObjectInputStream implementation that resolves the
+   * Class type of the Object being de-serialized with the specified ClassLoader.
+   * 
-    public ClassLoaderObjectInputStream(final InputStream in, final ClassLoader loader) throws IOException {
+    public ClassLoaderObjectInputStream(final InputStream in, final ClassLoader loader)
+        throws IOException {
-        throw new NullPointerException("The ClassLoader used by this ObjectInputStream to resolve Class types for serialized Objects cannot be null!");
+        throw new NullPointerException(
+            "The ClassLoader used by this ObjectInputStream to resolve Class types for serialized Objects cannot be null!");
-    protected Class<?> resolveClass(final ObjectStreamClass descriptor) throws IOException, ClassNotFoundException {
+    protected Class<?> resolveClass(final ObjectStreamClass descriptor)
+        throws IOException, ClassNotFoundException {

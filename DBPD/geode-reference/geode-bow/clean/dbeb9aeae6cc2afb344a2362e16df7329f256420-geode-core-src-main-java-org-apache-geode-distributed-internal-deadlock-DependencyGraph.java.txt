Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * It detects cycles in the graph by using the Depth First Search algorithm.
- * Calling findCycle will return the first cycle that is discovered in the
- * graph.
+ * It detects cycles in the graph by using the Depth First Search algorithm. Calling findCycle will
+ * return the first cycle that is discovered in the graph.
-   * The vertices of the graph. The key is the vertex, the value is the set of
-   * outgoing dependencies (ie the dependencies where this vertex is the
-   * depender).
+   * The vertices of the graph. The key is the vertex, the value is the set of outgoing dependencies
+   * (ie the dependencies where this vertex is the depender).
- 
+
-    for (Dependency dep: edges) {
+    for (Dependency dep : edges) {
-  
-  /** 
-   * Add an edge to the dependency graph. 
+
+  /**
+   * Add an edge to the dependency graph.
-      if(outboundEdges == null) {
+      if (outboundEdges == null) {
-      
-      if(vertices.get(dependency.getDependsOn()) == null) {
+
+      if (vertices.get(dependency.getDependsOn()) == null) {
-  
+
-   * This method works by starting at any vertex and doing a depth first search.
-   * If it ever encounters a vertex that is currently in the middle of the search
-   * (as opposed to a vertex whose dependencies have been completely analyzed), then
-   * it returns the chain that starts from our start vertex and includes the cycle.
+   * This method works by starting at any vertex and doing a depth first search. If it ever
+   * encounters a vertex that is currently in the middle of the search (as opposed to a vertex whose
+   * dependencies have been completely analyzed), then it returns the chain that starts from our
+   * start vertex and includes the cycle.
-    
-    while(unvisited.size() > 0) {
+
+    while (unvisited.size() > 0) {
-      
+
-      if(foundCycle) {
+      if (foundCycle) {
-    
+
-   * This will find the longest call chain in the graph.  If a
-   * cycle is detected it will be returned.  Otherwise all
-   * subgraphs are traversed to find the one that has the most
-   * depth.  This usually indicates the thread that is blocking
-   * the most other threads.<p>
+   * This will find the longest call chain in the graph. If a cycle is detected it will be returned.
+   * Otherwise all subgraphs are traversed to find the one that has the most depth. This usually
+   * indicates the thread that is blocking the most other threads.
+   * <p>
-   * The findDependenciesWith method can then be used to find all
-   * top-level threads that are blocked by the culprit.
+   * The findDependenciesWith method can then be used to find all top-level threads that are blocked
+   * by the culprit.
-    
-    for (Object dep: vertices.keySet()) {
+
+    for (Object dep : vertices.keySet()) {
-    
+
-  
-  
-  
+
+
+
-   * This returns a collection of top-level threads and their
-   * path to the given object.  The object name is some
-   * substring of the toString of the object
+   * This returns a collection of top-level threads and their path to the given object. The object
+   * name is some substring of the toString of the object
-    
-    // first find a dependency containing the node.  If we can't find one
+
+    // first find a dependency containing the node. If we can't find one
-    for (Dependency dep: edges) {
+    for (Dependency dep : edges) {
-    
+
-      for (Dependency dep: edges) {
-        if (dependsOnObj.contains(dep.dependsOn)
-            && !dependsOnObj.contains(dep.depender)) {
+      for (Dependency dep : edges) {
+        if (dependsOnObj.contains(dep.dependsOn) && !dependsOnObj.contains(dep.depender)) {
-    for (Dependency dep: edges) {
-      if ( (dep.dependsOn instanceof LocalThread) ) {
+    for (Dependency dep : edges) {
+      if ((dep.dependsOn instanceof LocalThread)) {
-    
+
-    for (Object depender: dependsOnObj) {
+    for (Object depender : dependsOnObj) {
-    
+
-  
+
-   * @param start
-   *          the node
-   * @param unvisited
-   *          the set of vertices that have not yet been visited
-   * @param finished
-   *          the set of vertices that have been completely analyzed
-   * @param cycle
-   *          an object used to record the any cycles that are detected
+   * @param start the node
+   * @param unvisited the set of vertices that have not yet been visited
+   * @param finished the set of vertices that have been completely analyzed
+   * @param cycle an object used to record the any cycles that are detected
-  private boolean visitCycle(Object start, Set<Object> unvisited,
-      Set<Object> finished, CycleHolder cycle, int depth) {
-    if(finished.contains(start)) {
+  private boolean visitCycle(Object start, Set<Object> unvisited, Set<Object> finished,
+      CycleHolder cycle, int depth) {
+    if (finished.contains(start)) {
-    
-    if(!unvisited.remove(start)) {
+
+    if (!unvisited.remove(start)) {
-    
+
-    
+
-    for(Dependency dep : vertices.get(start)) {
-      foundCycle |= visitCycle(dep.getDependsOn(), unvisited, finished, cycle, depth+1);
-      if(foundCycle) {
+    for (Dependency dep : vertices.get(start)) {
+      foundCycle |= visitCycle(dep.getDependsOn(), unvisited, finished, cycle, depth + 1);
+      if (foundCycle) {
-    
+
-    if(foundCycle) {
+    if (foundCycle) {
-  
+
-    
+
-    
+
-  
-  
-  
+
+
+
-    if(result.vertices.keySet().contains(start)) {
+    if (result.vertices.keySet().contains(start)) {
-    if(vertices.get(start) == null) {
+    if (vertices.get(start) == null) {
-    
+
-    for(Dependency dep: result.vertices.get(start)) {
+    for (Dependency dep : result.vertices.get(start)) {
-  
+
-  
+
-  
+
-    
+
-    
+
-    
+
-      if(cycleDone) {
+      if (cycleDone) {
-      
+
-      
+
-      
-      if(dep.depender.equals(lastVertex)) {
+
+      if (dep.depender.equals(lastVertex)) {
-  
+

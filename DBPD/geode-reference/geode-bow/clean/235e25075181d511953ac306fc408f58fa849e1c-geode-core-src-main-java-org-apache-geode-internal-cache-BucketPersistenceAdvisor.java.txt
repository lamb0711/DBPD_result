GEODE-7577: Log when waiting for missing persistent members (#4476)

* Separate StartupStatusListenerRegistry from StartupStatus to allow
  non-static injection of StartupStatus into classes that use it
* Add CollectionTransformer interface to TransformUtils to facilitate
  unit testing of classes depending on it
* Add new MembershipChangeListenerFactory with validation to ensure that
  warningDelay and pollDuration have correct values in relation to each
  other (to prevent recurrences of GEODE-7577)
* Fixed the formatting of missing persistent members messages in
  PersistenceAdvisorImpl
* Fixed warnings and minor issues primarily for readability and
  testability in every class touched
* Added shouldSyncForCrashedMember to InternalRegion and pulled the
  javadocs up to the interface

GEODE-4267: Fix PersistentRecoveryOrderOldConfigDUnitTest
* Replace thread sleeps with CountDownLatch
* Add a couple await calls
* Actual fix involved preventing late-running asynchronous actions that
  resulted in logging DistributedSystemDisconnectedException AFTER the
  test already removed the IgnoredException
* Major cleanup of PersistentRecoveryOrderDUnitTest including replace
  usage of Admin API with usage of DistributedSystemMXBean
* Replace Region close with Cache close in test that needs to list and
  revoke missing disk-stores
+import static java.lang.System.lineSeparator;
+import static java.time.Duration.ofSeconds;
+import static java.util.Collections.synchronizedSet;
+import static org.apache.geode.internal.cache.persistence.MembershipChangeListenerFactory.cancelCondition;
+
-import java.util.Collections;
+import java.util.function.Function;
+import org.apache.geode.CancelCriterion;
+import org.apache.geode.annotations.VisibleForTesting;
+import org.apache.geode.distributed.internal.DistributionConfig;
+import org.apache.geode.internal.cache.persistence.InternalPersistenceAdvisor;
+import org.apache.geode.internal.cache.persistence.MembershipChangeListenerFactory;
-  public CountDownLatch someMemberRecoveredLatch = new CountDownLatch(1);
-  public boolean recovering = true;
+  private final CountDownLatch someMemberRecoveredLatch = new CountDownLatch(1);
+  private boolean recovering = true;
+  private final Function<InternalPersistenceAdvisor, MembershipChangeListener> membershipChangeListenerProvider;
-  public BucketPersistenceAdvisor(CacheDistributionAdvisor advisor, DistributedLockService dl,
-      PersistentMemberView storage, String regionPath, DiskRegionStats diskStats,
-      PersistentMemberManager memberManager, BucketLock bucketLock,
-      ProxyBucketRegion proxyBucketRegion) {
-    super(advisor, dl, storage, regionPath, diskStats, memberManager);
+  BucketPersistenceAdvisor(CacheDistributionAdvisor cacheDistributionAdvisor,
+      DistributedLockService distributedLockService, PersistentMemberView storage,
+      String regionPath, DiskRegionStats diskStats, PersistentMemberManager memberManager,
+      BucketLock bucketLock, ProxyBucketRegion proxyBucketRegion) {
+    this(cacheDistributionAdvisor, distributedLockService, storage, regionPath, diskStats,
+        memberManager, bucketLock, proxyBucketRegion,
+        internalPersistenceAdvisor -> {
+          CacheDistributionAdvisor advisor =
+              internalPersistenceAdvisor.getCacheDistributionAdvisor();
+          DistributionConfig config = advisor.getDistributionManager().getConfig();
+          CancelCriterion stopper = advisor.getAdvisee().getCancelCriterion();
+
+          return new MembershipChangeListenerFactory()
+              .setWarningDelay(ofSeconds(config.getAckWaitThreshold() / 2))
+              .setPollDuration(ofSeconds(config.getAckWaitThreshold()))
+              .setCancelCondition(cancelCondition(internalPersistenceAdvisor, stopper))
+              .setWarning(internalPersistenceAdvisor::logWaitingForMembers)
+              .create();
+        });
+  }
+
+  private BucketPersistenceAdvisor(CacheDistributionAdvisor cacheDistributionAdvisor,
+      DistributedLockService distributedLockService, PersistentMemberView storage,
+      String regionPath, DiskRegionStats diskStats, PersistentMemberManager memberManager,
+      BucketLock bucketLock, ProxyBucketRegion proxyBucketRegion,
+      Function<InternalPersistenceAdvisor, MembershipChangeListener> membershipChangeListenerProvider) {
+    super(cacheDistributionAdvisor, distributedLockService, storage, regionPath, diskStats,
+        memberManager);
-    this.proxyBucket = proxyBucketRegion;
+    proxyBucket = proxyBucketRegion;
+    this.membershipChangeListenerProvider = membershipChangeListenerProvider;
-    this.recovering = false;
+    recovering = false;
-    // Make sure any removes that we saw during recovery are
-    // applied.
+    // Make sure any removes that we saw during recovery are applied.
-      this.recoveryException = e;
-      this.someMemberRecoveredLatch.countDown();
+      recoveryException = e;
+      someMemberRecoveredLatch.countDown();
-              new Object[] {proxyBucket.getPartitionedRegion().getFullPath(),
-                  proxyBucket.getBucketId()}),
+              proxyBucket.getPartitionedRegion().getFullPath(), proxyBucket.getBucketId()),
+  @VisibleForTesting
-    return this.recovering;
+    return recovering;
-      Set<String> membersToWaitForPrettyFormat = new HashSet<String>();
+      Set<String> membersToWaitForPrettyFormat = new HashSet<>();
-            new Object[] {proxyBucket.getPartitionedRegion().getFullPath(),
-                proxyBucket.getBucketId(),
-                TransformUtils.persistentMemberIdToLogEntryTransformer
-                    .transform(getPersistentID()),
-                membersToWaitForPrettyFormat});
+            proxyBucket.getPartitionedRegion().getFullPath(), proxyBucket.getBucketId(),
+            TransformUtils.persistentMemberIdToLogEntryTransformer.transform(getPersistentID()),
+            membersToWaitForPrettyFormat);
-            new Object[] {proxyBucket.getPartitionedRegion().getFullPath(),
-                proxyBucket.getBucketId(),
-                TransformUtils.persistentMemberIdToLogEntryTransformer
-                    .transform(getPersistentID()),
-                membersToWaitForPrettyFormat});
+            proxyBucket.getPartitionedRegion().getFullPath(), proxyBucket.getBucketId(),
+            TransformUtils.persistentMemberIdToLogEntryTransformer.transform(getPersistentID()),
+            membersToWaitForPrettyFormat);
-      // the delock.
-        // Remove the persistent data for this bucket, since
-        // redundancy is already satisfied.
+        // Remove the persistent data for this bucket, since redundancy is already satisfied.
-    } else {
-      // don't update the membership view, we already updated it during recovery.
+    // else don't update the membership view, we already updated it during recovery.
-   *
-  public void initializeMembershipView() {
-    MembershipChangeListener listener = new MembershipChangeListener(this);
+  void initializeMembershipView() {
+    MembershipChangeListener listener = membershipChangeListenerProvider.apply(this);
-  public void bucketRemoved() {
-    this.resetState();
+  void bucketRemoved() {
+    resetState();
-
-    } else {
-      Set<PersistentMemberID> offlineMembers = getPersistedMembers();
-      offlineMembers.removeAll(cacheDistributionAdvisor.advisePersistentMembers().values());
-      return offlineMembers;
+    Set<PersistentMemberID> offlineMembers = getPersistedMembers();
+    offlineMembers.removeAll(cacheDistributionAdvisor.advisePersistentMembers().values());
+    return offlineMembers;
-    } else {
-      id = new PersistentMemberID(id.getDiskStoreId(), id.getHost(), id.getDirectory(),
-          this.proxyBucket.getPartitionedRegion().getBirthTime(), version++);
-      return id;
-  }
-
-
-
-  private static class RecoveryListener extends PersistentStateAdapter {
-    private Set<PersistentMemberID> removedMembers =
-        Collections.synchronizedSet(new HashSet<PersistentMemberID>());
-
-    @Override
-    public void memberRemoved(PersistentMemberID persistentID, boolean revoked) {
-      this.removedMembers.add(persistentID);
-    }
-
-    public HashSet<PersistentMemberID> getRemovedMembers() {
-      synchronized (removedMembers) {
-        return new HashSet<PersistentMemberID>(removedMembers);
-      }
-    }
+    id = new PersistentMemberID(id.getDiskStoreId(), id.getHost(), id.getDirectory(),
+        proxyBucket.getPartitionedRegion().getBirthTime(), version++);
+    return id;
-   *
-    buf.append("\nMY PERSISTENT ID:\n");
+    buf.append(lineSeparator()).append("MY PERSISTENT ID:").append(lineSeparator());
-    buf.append("\nMY INITIALIZING ID:\n");
+    buf.append(lineSeparator()).append("MY INITIALIZING ID:").append(lineSeparator());
-    buf.append("\nONLINE MEMBERS:\n");
+    buf.append(lineSeparator()).append("ONLINE MEMBERS:").append(lineSeparator());
-      buf.append("\n");
+      buf.append(lineSeparator());
-    buf.append("\nOFFLINE MEMBERS:\n");
+    buf.append(lineSeparator()).append("OFFLINE MEMBERS:").append(lineSeparator());
-      buf.append("\n");
+      buf.append(lineSeparator());
-    buf.append("\nOFFLINE AND EQUAL MEMBERS:\n");
+    buf.append(lineSeparator()).append("OFFLINE AND EQUAL MEMBERS:").append(lineSeparator());
-      buf.append("\n");
+      buf.append(lineSeparator());
+   * <p>
-  public void waitForPrimaryPersistentRecovery() {
+  void waitForPrimaryPersistentRecovery() {
-      ArrayList<StackTraceElement> newStack = new ArrayList<StackTraceElement>();
+      ArrayList<StackTraceElement> newStack = new ArrayList<>();
-
-
-   * Overridden to fix bug 41336. We defer initialization of this member until after the atomic
-   * bucket creation phase is over.
+   * Overridden to defer initialization of this member until after the atomic bucket creation phase
+   * is over.
-   * Overridden to fix bug 41336. We defer initialization of this member until after the atomic
-   * bucket creation phase is over.
+   * Overridden to defer initialization of this member until after the atomic bucket creation phase
+   * is over.
-    if (this.atomicCreation) {
+    if (atomicCreation) {
-  public void endBucketCreation(PersistentMemberID newId) {
+  void endBucketCreation(PersistentMemberID newId) {
-  public boolean isAtomicCreation() {
-    return this.atomicCreation;
+  @VisibleForTesting
+  boolean isAtomicCreation() {
+    return atomicCreation;
-  public void setAtomicCreation(boolean atomicCreation) {
+  void setAtomicCreation(boolean atomicCreation) {
-  private BucketPersistenceAdvisor getColocatedPersistenceAdvisor() {
-    PartitionedRegion colocatedRegion =
-        ColocationHelper.getColocatedRegion(proxyBucket.getPartitionedRegion());
-    if (colocatedRegion == null) {
-      return null;
+  private static class RecoveryListener extends PersistentStateAdapter {
+
+    private final Set<PersistentMemberID> removedMembers = synchronizedSet(new HashSet<>());
+
+    @Override
+    public void memberRemoved(PersistentMemberID persistentID, boolean revoked) {
+      removedMembers.add(persistentID);
-    ProxyBucketRegion colocatedProxyBucket =
-        colocatedRegion.getRegionAdvisor().getProxyBucketArray()[proxyBucket.getBucketId()];
-    return colocatedProxyBucket.getPersistenceAdvisor();
+
+    private HashSet<PersistentMemberID> getRemovedMembers() {
+      synchronized (removedMembers) {
+        return new HashSet<>(removedMembers);
+      }
+    }

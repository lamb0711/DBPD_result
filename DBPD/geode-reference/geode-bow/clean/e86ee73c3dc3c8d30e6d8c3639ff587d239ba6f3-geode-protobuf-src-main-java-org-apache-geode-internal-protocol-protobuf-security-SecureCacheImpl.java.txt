GEODE-5041: Adding post processing to the new protocol


-package org.apache.geode.internal.protocol.protobuf.v1.authentication;
+package org.apache.geode.internal.protocol.protobuf.security;
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Collectors;
+import org.apache.geode.cache.query.SelectResults;
+import org.apache.geode.cache.query.Struct;
+import org.apache.geode.cache.query.internal.ResultsCollectionWrapper;
+import org.apache.geode.cache.query.internal.StructImpl;
+import org.apache.geode.cache.query.internal.types.StructTypeImpl;
-public class AuthorizingCacheImpl implements AuthorizingCache {
+public class SecureCacheImpl implements SecureCache {
-  protected final Authorizer authorizer;
-  private final AuthorizingFunctionService functionService;
+  protected final Security security;
+  private final SecureFunctionService functionService;
-  public AuthorizingCacheImpl(InternalCache cache, Authorizer authorizer) {
+  public SecureCacheImpl(InternalCache cache, Security security) {
-    this.authorizer = authorizer;
-    this.functionService = new AuthorizingFunctionServiceImpl(cache, authorizer);
+    this.security = security;
+    this.functionService = new SecureFunctionServiceImpl(cache, security);
-          authorizer.authorize(DATA, READ, regionName, key);
+          security.authorize(DATA, READ, regionName, key);
+        value = (V) security.postProcess(regionName, key, value);
-    authorizer.authorize(DATA, READ, regionName, key);
+    security.authorize(DATA, READ, regionName, key);
-    return region.get(key);
+    Object value = region.get(key);
+    return (V) security.postProcess(regionName, key, value);
-    authorizer.authorize(DATA, WRITE, regionName, key);
+    security.authorize(DATA, WRITE, regionName, key);
-          authorizer.authorize(DATA, WRITE, regionName, key);
+          security.authorize(DATA, WRITE, regionName, key);
-    authorizer.authorize(DATA, WRITE, regionName, key);
+    security.authorize(DATA, WRITE, regionName, key);
-    return region.remove(key);
+    Object oldValue = region.remove(key);
+    return (V) security.postProcess(regionName, key, oldValue);
-    authorizer.authorize(DATA, READ, ALL, ALL);
+    security.authorize(DATA, READ, ALL, ALL);
-    authorizer.authorize(DATA, READ, regionName, ALL);
+    security.authorize(DATA, READ, regionName, ALL);
-    authorizer.authorize(DATA, READ, regionName, ALL);
+    security.authorize(DATA, READ, regionName, ALL);
-  public AuthorizingFunctionService getFunctionService() {
+  public SecureFunctionService getFunctionService() {
-    authorizer.authorize(DATA, WRITE, regionName, ALL);
+    security.authorize(DATA, WRITE, regionName, ALL);
-    authorizer.authorize(DATA, WRITE, regionName, key);
+    security.authorize(DATA, WRITE, regionName, key);
-    return region.putIfAbsent(key, value);
+    Object oldValue = region.putIfAbsent(key, value);
+
+    return (V) security.postProcess(regionName, key, oldValue);
-      authorizer.authorize(DATA, READ, regionName, ALL);
+      security.authorize(DATA, READ, regionName, ALL);
-    return query.execute(bindParameters);
+    Object result = query.execute(bindParameters);
+
+    if (security.needsPostProcessing()) {
+      return postProcessQueryResults(result);
+    } else {
+      return result;
+    }
+  }
+
+  private Object postProcessQueryResults(Object value) {
+    // The result is a single value
+    if (!(value instanceof SelectResults)) {
+      // For query results, we don't have the region or the key
+      return security.postProcess(null, null, value);
+    }
+
+    SelectResults<?> selectResults = (SelectResults<?>) value;
+
+    // The result is a list of objects
+    if (!selectResults.getCollectionType().getElementType().isStructType()) {
+      List<Object> postProcessed = selectResults.stream()
+          .map(element -> security.postProcess(null, null, element)).collect(Collectors.toList());
+      return new ResultsCollectionWrapper(selectResults.getCollectionType().getElementType(),
+          postProcessed);
+    }
+
+    // The result is a list of structs
+    SelectResults<Struct> structResults = (SelectResults<Struct>) selectResults;
+
+    List<Struct> postProcessed =
+        structResults.stream().map(this::postProcessStruct).collect(Collectors.toList());
+
+
+    return new ResultsCollectionWrapper(selectResults.getCollectionType().getElementType(),
+        postProcessed);
+  }
+
+  private Struct postProcessStruct(Struct struct) {
+    List<Object> newValues = Arrays.stream(struct.getFieldValues())
+        .map(element -> security.postProcess(null, null, element)).collect(Collectors.toList());
+    StructImpl newStruct =
+        new StructImpl((StructTypeImpl) struct.getStructType(), newValues.toArray());
+
+    return newStruct;
-      authorizer.authorize(resource, operation, regionName, ALL);
+      security.authorize(resource, operation, regionName, ALL);

GEODE-3413: overhaul launcher and process classes and tests

This is primarily an overall of all ServerLauncher and LocatorLauncher
tests and org.apache.geode.internal.process tests. The main classes in
org.apachage.geode.internal.process package are also cleaned up.

In addition, several bugs involving these classes and tests are fixed.

Here is the complete list of tickets that are resolved in this overhaul:

* GEODE-1229: LocatorLauncherRemoteJUnitTest.testStartOverwritesStalePidFile
* GEODE-2791: LocatorLauncherAssemblyIntegrationTest.testLocatorStopsWhenJmxPortIsNonZero fails intermittently with AssertionError
* GEODE-1308: CI failure: LocatorLauncherTest.testSetBindAddressToNonLocalHost
* GEODE-1309: CI failure: ServerLauncherTest.testSetServerBindAddressToNonLocalHost
* GEODE-3193: locator pid file is removed even if there was a problem while shutting down
* GEODE-3413: Overhaul launcher tests and process tests
* GEODE-3414: Cleanup org.apache.geode.internal.process package

Note I moved all useful tests from LocatorLauncherAssemblyIntegrationTest
into the other launcher tests in geode-core.

-import java.io.BufferedReader;
-import java.io.IOException;
+import static org.apache.commons.lang.Validate.isTrue;
+import static org.apache.commons.lang.Validate.notNull;
+
-import java.io.InputStreamReader;
-import org.apache.logging.log4j.Logger;
-
-import org.apache.geode.internal.logging.LogService;
-  private static final int DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLISECONDS = 5000;
-  private static final Logger logger = LogService.getLogger();
+
+  private static final int DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLIS = 5000;
+    notNull(builder, "Invalid builder '" + builder + "' specified");
+
+
-  @Override
-  public void run() {
-    final boolean isDebugEnabled = logger.isDebugEnabled();
-    if (isDebugEnabled) {
-      logger.debug("Running {}", this);
-    }
-    BufferedReader reader = null;
-    try {
-      reader = new BufferedReader(new InputStreamReader(inputStream));
-      String line;
-      while ((line = reader.readLine()) != null) {
-        this.inputListener.notifyInputLine(line);
-      }
-    } catch (IOException e) {
-      if (isDebugEnabled) {
-        logger.debug("Failure reading from buffered input stream: {}", e.getMessage(), e);
-      }
-    } finally {
-      try {
-        reader.close();
-      } catch (IOException e) {
-        if (isDebugEnabled) {
-          logger.debug("Failure closing buffered input stream reader: {}", e.getMessage(), e);
-        }
-      }
-      if (isDebugEnabled) {
-        logger.debug("Terminating {}", this);
-      }
-    }
-  }
-
-      if (this.thread == null) {
-        this.thread = new Thread(this, createThreadName());
-        this.thread.setDaemon(true);
-        this.thread.start();
-      } else if (this.thread.isAlive()) {
+      if (thread == null) {
+        thread = new Thread(this, createThreadName());
+        thread.setDaemon(true);
+        thread.start();
+      } else if (thread.isAlive()) {
-      if (this.thread != null && this.thread.isAlive()) {
-        this.thread.interrupt();
-      } else if (this.thread != null) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("{} has already been stopped", this);
-        }
-      } else {
-        if (logger.isDebugEnabled()) {
-          logger.debug("{} has not been started", this);
-        }
+      if (thread != null && thread.isAlive()) {
+        thread.interrupt();
-    Runnable delayedStop = new Runnable() {
-      @Override
-      public void run() {
-        try {
-          Thread.sleep(delayMillis);
-        } catch (InterruptedException e) {
-        } finally {
-          stop();
-        }
+    Runnable delayedStop = () -> {
+      try {
+        Thread.sleep(delayMillis);
+      } catch (InterruptedException ignored) {
+      } finally {
+        stop();
+
-      if (this.thread != null) {
-        return this.thread.isAlive();
+      if (thread != null) {
+        return thread.isAlive();
-  public void join() throws InterruptedException {
+  public ProcessStreamReader join() throws InterruptedException {
+    return this;
-  public void join(final long millis) throws InterruptedException {
+  public ProcessStreamReader join(final long millis) throws InterruptedException {
+    return this;
-  public void join(final long millis, final int nanos) throws InterruptedException {
+  public ProcessStreamReader join(final long millis, final int nanos) throws InterruptedException {
+    return this;
-    final StringBuilder sb = new StringBuilder(getClass().getSimpleName());
+    StringBuilder sb = new StringBuilder(getClass().getSimpleName());
-    sb.append(" alive=").append(isRunning()); // this.thread == null ? false :
-                                              // this.thread.isAlive());
-    sb.append(" listener=").append(this.inputListener);
+    sb.append(" alive=").append(isRunning());
+    sb.append(" listener=").append(inputListener);
-    return getClass().getSimpleName() + "@" + Integer.toHexString(hashCode());
+    return getClass().getSimpleName() + '@' + Integer.toHexString(hashCode());
-  public static interface InputListener {
-    public void notifyInputLine(String line);
+  public interface InputListener {
+    void notifyInputLine(final String line);
-  public static enum ReadingMode {
-    BLOCKING, NON_BLOCKING;
+  public enum ReadingMode {
+    BLOCKING, NON_BLOCKING
-  public static String waitAndCaptureProcessStandardOutputStream(final Process process) {
-    return waitAndCaptureProcessStandardOutputStream(process,
-        DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLISECONDS);
-  }
-
-  public static String waitAndCaptureProcessStandardOutputStream(final Process process,
+  private static String waitAndCaptureProcessStandardOutputStream(final Process process,
+    notNull(process, "Invalid process '" + process + "' specified");
+
-        DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLISECONDS);
+        DEFAULT_PROCESS_OUTPUT_WAIT_TIME_MILLIS);
-      final InputStream processInputStream, long waitTimeMilliseconds) {
-    final StringBuffer buffer = new StringBuffer();
+      final InputStream processInputStream, final long waitTimeMilliseconds) {
+    StringBuffer buffer = new StringBuffer();
-      final long endTime = (System.currentTimeMillis() + waitTimeMilliseconds);
+      long endTime = System.currentTimeMillis() + waitTimeMilliseconds;
-   * 
+   *
-    protected Process process;
-    protected InputStream inputStream;
-    protected InputListener inputListener;
-    protected long continueReadingMillis = 0;
-    protected ReadingMode readingMode = ReadingMode.BLOCKING;
+
+    final Process process;
+    InputStream inputStream;
+    InputListener inputListener;
+    long continueReadingMillis = 0;
+    ReadingMode readingMode = ReadingMode.BLOCKING;
-      if (process == null) {
-        throw new NullPointerException("process may not be null");
-      }
-      if (inputStream == null) {
-        throw new NullPointerException("inputStream may not be null");
-      }
-      if (continueReadingMillis < 0) {
-        throw new IllegalArgumentException("continueReadingMillis must zero or positive");
-      }
-      switch (this.readingMode) {
+      notNull(process, "Invalid process '" + process + "' specified");
+      notNull(inputStream, "Invalid inputStream '" + inputStream + "' specified");
+      isTrue(continueReadingMillis >= 0,
+          "Invalid continueReadingMillis '" + continueReadingMillis + "' specified");
+
+      switch (readingMode) {

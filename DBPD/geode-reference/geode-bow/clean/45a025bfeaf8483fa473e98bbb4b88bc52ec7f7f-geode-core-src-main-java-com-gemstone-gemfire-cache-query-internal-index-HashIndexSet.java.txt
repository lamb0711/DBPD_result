Merge branch 'develop' into feature/GEODE-420

# Conflicts:
#	geode-assembly/src/test/java/com/gemstone/gemfire/rest/internal/web/controllers/RestAPIsWithSSLDUnitTest.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/DistributionConfig.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/membership/gms/GMSUtil.java
#	geode-core/src/main/java/com/gemstone/gemfire/internal/cache/tier/sockets/AcceptorImpl.java
#	geode-core/src/main/java/com/gemstone/gemfire/management/internal/ManagementAgent.java
#	geode-core/src/main/java/org/apache/geode/redis/GeodeRedisServer.java
#	geode-core/src/test/java/com/gemstone/gemfire/distributed/LocatorDUnitTest.java

-import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
-import java.util.Map;
-import com.gemstone.gemfire.cache.query.internal.index.AbstractIndex.InternalIndexStatistics;
-import com.gemstone.gemfire.internal.cache.CachedDeserializable;
-import com.gemstone.gemfire.internal.cache.RegionEntry;
-import com.gemstone.gemfire.internal.offheap.StoredObject;
+  final class HashIndexSetProperties{
+    /** the set of Objects */
+    final protected transient Object[] set;
+    /** used for hashing into the table**/
+    final protected int mask;
+
+    /** the current number of entries in the set */
+    protected transient int size = 0;
+
+    /** the current number of open slots in the hash.
+     * Originally used when we collapsed collided keys into collections
+     * Not really used now */
+    protected transient int free;
+
+    /** number of removed tokens in the set, these are index positions that may be reused*/
+    transient int removedTokens;
+
+    /** size of the backing table (-1)**/
+    protected int n;
+
+    /**
+     * The maximum number of elements before rehashing
+     */
+    protected int maxSize;
+
+    private int computeNumFree() {
+      return this.n - this.size;
+    }
+
+    public HashIndexSetProperties(final Object[] set, final int mask) {
+      this.set = set;
+      this.mask = mask;
+    }
+  }
-  /** the current number of entries in the set */
-  protected transient int _size;
-
-  /** the current number of open slots in the hash.
-   * Originally used when we collapsed collided keys into collections
-   * Not really used now */
-  protected transient int _free;
-
-  /** number of removed tokens in the set, these are index positions that may be reused*/
-  transient int _removedTokens;
-
-  
-  /** size of the backing table (-1)**/
-  protected int n;
-  
-  /** used for hashing into the table**/
-  protected int _mask;
-
-  /**
-   * The maximum number of elements before rehashing
-   */
-  protected int _maxSize;
-  /** the set of Objects */
-  protected transient Object[] _set;
+  HashIndexSetProperties hashIndexSetProperties;
+    HashIndexSetProperties metaData = hashIndexSetProperties;
-    Object[] set;
-    int mask = _mask;
-    set = _set;
+    Object[] set = metaData.set;
+    int mask = metaData.mask;
-    return new HashIndexSetIterator(keysToRemove, _set);
+    return new HashIndexSetIterator(keysToRemove, hashIndexSetProperties);
-    return new HashIndexSetIterator(indexKey, _set);
+    return new HashIndexSetIterator(indexKey, hashIndexSetProperties);
-    int indexSlot = insertionIndex(indexKey, obj, _set);
+    HashIndexSetProperties metaData = hashIndexSetProperties;
+    int indexSlot = insertionIndex(indexKey, metaData);
-    Object old = _set[indexSlot];
-    addObjectToSet(_set, indexSlot, obj);
-
+    Object old = metaData.set[indexSlot];
+    addObjectToSet(metaData.set, indexSlot, obj);
+    hashIndexSetProperties = metaData;
-   * @param obj
-   *          an <code>Object</code> value
-  protected int insertionIndex(Object indexKey, Object obj, Object[] set) {
+  protected int insertionIndex(Object indexKey, HashIndexSetProperties metaData) {
-    int mask = _mask;
+    int mask = metaData.mask;
-    final Object[] array = set;
+    final Object[] array = metaData.set;
-    Object[] set = _set;
+    Object[] set = hashIndexSetProperties.set;
+    HashIndexSetProperties metaData = hashIndexSetProperties;
-    int oldCapacity = _set.length;
-    Object[] oldSet = _set;
+    Object[] oldSet = metaData.set;
+    int oldCapacity = oldSet.length;
-    _removedTokens = 0;
+
+
-    n = newN;
-    _mask = n - 1;
-    _maxSize = computeMaxSize(n, _loadFactor);
-    _free = computeNumFree();
-    Object[] newSet = new Object[n + 1];
-    
+    int mask = newN - 1;
+    int _maxSize = computeMaxSize(newN, _loadFactor);
+    Object[] newSet = new Object[newN + 1];
+    HashIndexSetProperties newHashIndexProperties = new HashIndexSetProperties(newSet,mask);
+    newHashIndexProperties.size = metaData.size;
+    newHashIndexProperties.free = hashIndexSetProperties.computeNumFree();
+    newHashIndexProperties.removedTokens = 0;
+    newHashIndexProperties.n = newN;
+    newHashIndexProperties.maxSize = _maxSize;
-        int index = insertionIndex(key, o, newSet);
+        int index = insertionIndex(key, newHashIndexProperties);
-          addObjectToSet(newSet, index, o);
+          addObjectToSet(newHashIndexProperties.set, index, o);
-    _set = newSet;
+    hashIndexSetProperties = newHashIndexProperties;
+
-    _size = 0;
-    _free = capacity();
-    _removedTokens = 0;
-
-    Object[] set = _set;
-
+    HashIndexSetProperties metaData = hashIndexSetProperties;
+    metaData.size = 0;
+    metaData.free = capacity();
+    metaData.removedTokens = 0;
+    Object[] set = metaData.set;
+    hashIndexSetProperties = metaData;
-    return _set.length;
+    return hashIndexSetProperties.set.length;
-    return 0 == _size;
+    return 0 == hashIndexSetProperties.size;
-    return _size;
+    return hashIndexSetProperties.size;
-    return _size;
+    return hashIndexSetProperties.size;
-    trimToSize(_size);
+    trimToSize(hashIndexSetProperties.size);
-    if ( this.n <= l ) return true;
+    if (this.hashIndexSetProperties.n <= l ) return true;
-    cur = _set[index];
-
+    HashIndexSetProperties metaData = hashIndexSetProperties;
+    cur = metaData.set[index];
-      _set[index] = REMOVED;
-      _size--;
-      _removedTokens++;
+      metaData.set[index] = REMOVED;
+      metaData.size--;
+      metaData.removedTokens++;
+      hashIndexSetProperties = metaData;
+
-    n = arraySize( expectedCapacity, loadFactor );
+    int n = arraySize( expectedCapacity, loadFactor );
-    _maxSize = computeMaxSize(n, loadFactor);
-    _mask = n - 1;
-    _free = computeNumFree();
-    _set = new Object[n + 1];
+    int _maxSize = computeMaxSize(n, loadFactor);
+    int mask = n - 1;
+    Object[] set = new Object[n + 1];
+    HashIndexSetProperties metaData  = new HashIndexSetProperties(set,mask);
+    metaData.n = n;
+    metaData.maxSize = _maxSize;
+    hashIndexSetProperties = metaData;
+    hashIndexSetProperties.free = hashIndexSetProperties.computeNumFree();
+
-  private int computeNumFree() {
-    return n - _size;
-  }
-  
-      _free--;
+      hashIndexSetProperties.free--;
-      _removedTokens--;
+      hashIndexSetProperties.removedTokens--;
-    _size++;
+    hashIndexSetProperties.size++;
-    if (_size > _maxSize || _free == 0 || TEST_ALWAYS_REHASH) {
-      rehash(arraySize(_size + 1, _loadFactor));
+    if (hashIndexSetProperties.size > hashIndexSetProperties.maxSize || hashIndexSetProperties.free == 0 || TEST_ALWAYS_REHASH) {
+      rehash(arraySize(hashIndexSetProperties.size + 1, _loadFactor));
-      _free = computeNumFree();
-    } else if (_removedTokens > _maxSize * CONDITIONAL_REMOVED_TOKEN_REHASH_FACTOR) {
+      hashIndexSetProperties.free = hashIndexSetProperties.computeNumFree();
+    } else if (hashIndexSetProperties.removedTokens > hashIndexSetProperties.maxSize * CONDITIONAL_REMOVED_TOKEN_REHASH_FACTOR) {
-    private HashIndexSetIterator(Collection keysToRemove, Object[] objects) {
+    private HashIndexSetIterator(Collection keysToRemove, HashIndexSetProperties metaData) {
-      this.objects = objects;
+      this.objects = metaData.set;
-    private HashIndexSetIterator(Object keyToMatch, Object[] objects) {
+    private HashIndexSetIterator(Object keyToMatch , HashIndexSetProperties metaData) {
-      this.objects = objects;
-
-      mask = _mask;
+      this.objects = metaData.set;
+      mask = metaData.mask;
-      current = objects[pos];
+      current = this.objects[pos];

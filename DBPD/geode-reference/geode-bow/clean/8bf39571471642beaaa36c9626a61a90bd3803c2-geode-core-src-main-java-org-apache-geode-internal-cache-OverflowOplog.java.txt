Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * An oplog used for overflow-only regions.
- * For regions that are persistent (i.e. they can be recovered) see {@link Oplog}.
+ * An oplog used for overflow-only regions. For regions that are persistent (i.e. they can be
+ * recovered) see {@link Oplog}.
-  
+
-   * The oplog set this oplog is part of 
+   * The oplog set this oplog is part of
-  /** The max Oplog size (user configurable).
-   * Set to zero when oplog is deleted.
+  /**
+   * The max Oplog size (user configurable). Set to zero when oplog is deleted.
-   * Set to true when this oplog will no longer be written to.
-   * Never set to false once it becomes true.
+   * Set to true when this oplog will no longer be written to. Never set to false once it becomes
+   * true.
-//   /**
-//    * Creates new <code>Oplog</code> for the given region.
-//    * 
-//    * @param oplogId
-//    *          int identifying the new oplog
-//    * @param dirHolder
-//    *          The directory in which to create new Oplog
-//    * 
-//    * @throws DiskAccessException
-//    *           if the disk files can not be initialized
-//    */
-//   OverflowOplog(int oplogId, DiskStoreImpl parent, DirectoryHolder dirHolder) {
-//     this.oplogId = oplogId;
-//     this.parent = parent;
-//     this.dirHolder = dirHolder;
-//     this.opState = new OpState();
-//     long maxOplogSizeParam = this.parent.getMaxOplogSizeInBytes();
-//     long availableSpace = this.dirHolder.getAvailableSpace();
-//     if (availableSpace < maxOplogSizeParam) {
-//       this.maxOplogSize = availableSpace;
-//     } else {
-//       this.maxOplogSize = maxOplogSizeParam;
-//     }
-//     this.stats = this.parent.getStats();
+  // /**
+  // * Creates new <code>Oplog</code> for the given region.
+  // *
+  // * @param oplogId
+  // * int identifying the new oplog
+  // * @param dirHolder
+  // * The directory in which to create new Oplog
+  // *
+  // * @throws DiskAccessException
+  // * if the disk files can not be initialized
+  // */
+  // OverflowOplog(int oplogId, DiskStoreImpl parent, DirectoryHolder dirHolder) {
+  // this.oplogId = oplogId;
+  // this.parent = parent;
+  // this.dirHolder = dirHolder;
+  // this.opState = new OpState();
+  // long maxOplogSizeParam = this.parent.getMaxOplogSizeInBytes();
+  // long availableSpace = this.dirHolder.getAvailableSpace();
+  // if (availableSpace < maxOplogSizeParam) {
+  // this.maxOplogSize = availableSpace;
+  // } else {
+  // this.maxOplogSize = maxOplogSizeParam;
+  // }
+  // this.stats = this.parent.getStats();
-//     this.closed = false;
-//     String n = this.parent.getName();
-//     this.diskFile = new File(this.dirHolder.getDir(),
-//                              "OVERFLOW"
-//                              + n + "_" + oplogId);
-//     try {
-//       createCrf();
-//     }
-//     catch (IOException ex) {
-//       throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_CREATING_OPERATION_LOG_BECAUSE_0.toLocalizedString(ex), this.parent);
-//     }
-//   }
+  // this.closed = false;
+  // String n = this.parent.getName();
+  // this.diskFile = new File(this.dirHolder.getDir(),
+  // "OVERFLOW"
+  // + n + "_" + oplogId);
+  // try {
+  // createCrf();
+  // }
+  // catch (IOException ex) {
+  // throw new
+  // DiskAccessException(LocalizedStrings.Oplog_FAILED_CREATING_OPERATION_LOG_BECAUSE_0.toLocalizedString(ex),
+  // this.parent);
+  // }
+  // }
-   * Asif: A copy constructor used for creating a new oplog based on the
-   * previous Oplog. This constructor is invoked only from the function
-   * switchOplog
+   * Asif: A copy constructor used for creating a new oplog based on the previous Oplog. This
+   * constructor is invoked only from the function switchOplog
-   * @param oplogId
-   *          integer identifying the new oplog
-   * @param dirHolder
-   *          The directory in which to create new Oplog
+   * @param oplogId integer identifying the new oplog
+   * @param dirHolder The directory in which to create new Oplog
-    // fix for bug 42464
+        // fix for bug 42464
-    // fix for bug 42464
+        // fix for bug 42464
-    this.diskFile = new File(this.dirHolder.getDir(), "OVERFLOW"
-                             + n + "_" + oplogId);
+    this.diskFile = new File(this.dirHolder.getDir(), "OVERFLOW" + n + "_" + oplogId);
-    }
-    catch (IOException ex) {
-      throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_CREATING_OPERATION_LOG_BECAUSE_0.toLocalizedString(ex), this.parent);
+    } catch (IOException ex) {
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_FAILED_CREATING_OPERATION_LOG_BECAUSE_0.toLocalizedString(ex),
+          this.parent);
-  
+
-      final OplogFile olf = getOLF();
-      try {
-   	olf.raf.setLength(this.maxOplogSize);
-        olf.raf.seek(0);
-      }
-      catch (IOException ioe) {
-        // @todo need a warning since this can impact perf.
-        // I don't think I need any of this. If setLength throws then
-        // the file is still ok.
-//         raf.close();
-//         if (!this.opLogFile.delete() && this.opLogFile.exists()) {
-//           throw new DiskAccessException(LocalizedStrings.NewLBHTreeDiskRegion_COULD_NOT_DELETE__0_.toLocalizedString(this.opLogFile.getAbsolutePath()), this.owner);
-//         }
-//         f = new File(this.diskFile.getPath() + OPLOG_FILE_EXT);
-//         this.opLogFile = f;
-//         raf = new RandomAccessFile(f, "rw");
-      }
+    final OplogFile olf = getOLF();
+    try {
+      olf.raf.setLength(this.maxOplogSize);
+      olf.raf.seek(0);
+    } catch (IOException ioe) {
+      // @todo need a warning since this can impact perf.
+      // I don't think I need any of this. If setLength throws then
+      // the file is still ok.
+      // raf.close();
+      // if (!this.opLogFile.delete() && this.opLogFile.exists()) {
+      // throw new
+      // DiskAccessException(LocalizedStrings.NewLBHTreeDiskRegion_COULD_NOT_DELETE__0_.toLocalizedString(this.opLogFile.getAbsolutePath()),
+      // this.owner);
+      // }
+      // f = new File(this.diskFile.getPath() + OPLOG_FILE_EXT);
+      // this.opLogFile = f;
+      // raf = new RandomAccessFile(f, "rw");
+    }
+
-  private void createCrf(OverflowOplog previous) throws IOException
-  {
+  private void createCrf(OverflowOplog previous) throws IOException {
-  
+
-  public DiskStoreStats getStats()
-  {
+  public DiskStoreStats getStats() {
-  
+
-   * Test Method to be used only for testing purposes. Gets the underlying File
-   * object for the Oplog . Oplog class uses this File object to obtain the
-   * RandomAccessFile object. Before returning the File object , the dat present
-   * in the buffers of the RandomAccessFile object is flushed. Otherwise, for
-   * windows the actual file length does not match with the File size obtained
-   * from the File object
+   * Test Method to be used only for testing purposes. Gets the underlying File object for the Oplog
+   * . Oplog class uses this File object to obtain the RandomAccessFile object. Before returning the
+   * File object , the dat present in the buffers of the RandomAccessFile object is flushed.
+   * Otherwise, for windows the actual file length does not match with the File size obtained from
+   * the File object
-  File getOplogFile() throws SyncFailedException, IOException
-  {
+  File getOplogFile() throws SyncFailedException, IOException {
-  public int getOplogId()
-  {
+  public int getOplogId() {
-  /** Returns the unserialized bytes and bits for the given Entry. 
-   * If Oplog is destroyed while querying, then the DiskRegion is queried again to
-   * obatin the value This method should never get invoked for an entry which
-   * has been destroyed
+  /**
+   * Returns the unserialized bytes and bits for the given Entry. If Oplog is destroyed while
+   * querying, then the DiskRegion is queried again to obatin the value This method should never get
+   * invoked for an entry which has been destroyed
-   * @param id The DiskId for the entry @param offset The offset in
-   *        this OpLog where the entry is present. @param faultingIn @param
-   *        bitOnly boolean indicating whether to extract just the UserBit or
-   *        UserBit with value @return BytesAndBits object wrapping the value &
-   *        user bit
+   * @param id The DiskId for the entry @param offset The offset in this OpLog where the entry is
+   *        present. @param faultingIn @param bitOnly boolean indicating whether to extract just the
+   *        UserBit or UserBit with value @return BytesAndBits object wrapping the value & user bit
-                                            boolean bitOnly)
-  {
+      boolean bitOnly) {
-      int opId = (int)id.getOplogId();
+      int opId = (int) id.getOplogId();
-    }
-    catch (DiskAccessException dae) {
+    } catch (DiskAccessException dae) {
-          LocalizedStrings.Oplog_OPLOGBASICGET_ERROR_IN_READING_THE_DATA_FROM_DISK_FOR_DISK_ID_HAVING_DATA_AS_0, id), dae);
+          LocalizedStrings.Oplog_OPLOGBASICGET_ERROR_IN_READING_THE_DATA_FROM_DISK_FOR_DISK_ID_HAVING_DATA_AS_0,
+          id), dae);
-     * if (bb == null) { // TODO: added by mitul, remove it later
-     * Assert.assertTrue(id.getOplogId() != this.oplogId);
+     * if (bb == null) { // TODO: added by mitul, remove it later Assert.assertTrue(id.getOplogId()
+     * != this.oplogId);
-      throw new EntryDestroyedException(LocalizedStrings.Oplog_NO_VALUE_WAS_FOUND_FOR_ENTRY_WITH_DISK_ID_0_ON_A_REGION_WITH_SYNCHRONOUS_WRITING_SET_TO_1
-                                        .toLocalizedString(new Object[] {id, Boolean.valueOf(dr.isSync())}));
+      throw new EntryDestroyedException(
+          LocalizedStrings.Oplog_NO_VALUE_WAS_FOUND_FOR_ENTRY_WITH_DISK_ID_0_ON_A_REGION_WITH_SYNCHRONOUS_WRITING_SET_TO_1
+              .toLocalizedString(new Object[] {id, Boolean.valueOf(dr.isSync())}));
-   * Returns the object stored on disk with the given id. This method is used
-   * for testing purposes only. As such, it bypasses the buffer and goes
-   * directly to the disk. This is not a thread safe function , in the sense, it
-   * is possible that by the time the OpLog is queried , data might move HTree
-   * with the oplog being destroyed
+   * Returns the object stored on disk with the given id. This method is used for testing purposes
+   * only. As such, it bypasses the buffer and goes directly to the disk. This is not a thread safe
+   * function , in the sense, it is possible that by the time the OpLog is queried , data might move
+   * HTree with the oplog being destroyed
-   * @param id
-   *                A DiskId object for which the value on disk will be fetched
+   * @param id A DiskId object for which the value on disk will be fetched
-  public final BytesAndBits getNoBuffer(DiskRegion dr, DiskId id)
-  {
+  public final BytesAndBits getNoBuffer(DiskRegion dr, DiskId id) {
-      BytesAndBits bb = basicGet(dr, id.getOffsetInOplog(), false,
-                                 id.getValueLength(), id.getUserBits());
+      BytesAndBits bb =
+          basicGet(dr, id.getOffsetInOplog(), false, id.getValueLength(), id.getUserBits());
-    }
-    catch (DiskAccessException dae) {
+    } catch (DiskAccessException dae) {
-          LocalizedStrings.Oplog_OPLOGGETNOBUFFEREXCEPTION_IN_RETRIEVING_VALUE_FROM_DISK_FOR_DISKID_0, id), dae);
+          LocalizedStrings.Oplog_OPLOGGETNOBUFFEREXCEPTION_IN_RETRIEVING_VALUE_FROM_DISK_FOR_DISKID_0,
+          id), dae);
-    }
-    catch (IllegalStateException ise) {
+    } catch (IllegalStateException ise) {
-          LocalizedStrings.Oplog_OPLOGGETNOBUFFEREXCEPTION_IN_RETRIEVING_VALUE_FROM_DISK_FOR_DISKID_0, id), ise);
+          LocalizedStrings.Oplog_OPLOGGETNOBUFFEREXCEPTION_IN_RETRIEVING_VALUE_FROM_DISK_FOR_DISKID_0,
+          id), ise);
-   * Call this when the cache is closed or region is destroyed. Deletes the lock
-   * files and if it is Overflow only, deletes the oplog file as well
-   *  
+   * Call this when the cache is closed or region is destroyed. Deletes the lock files and if it is
+   * Overflow only, deletes the oplog file as well
+   * 
-  public void close()
-  {
+  public void close() {
-  
+
-    
+
-  
+
-   * Destroys this oplog. First it will call close which will cleanly close all
-   * Async threads. The
-   * deletion of lock files will be taken care of by the close. Close will also
-   * take care of deleting the files if it is overflow only mode
-   *  
+   * Destroys this oplog. First it will call close which will cleanly close all Async threads. The
+   * deletion of lock files will be taken care of by the close. Close will also take care of
+   * deleting the files if it is overflow only mode
+   * 
-  public void destroy()
-  {
+  public void destroy() {
-   * A check to confirm that the oplog has been closed because of the cache
-   * being closed
-   *  
+   * A check to confirm that the oplog has been closed because of the cache being closed
+   * 
-  private void checkClosed()
-  {
+  private void checkClosed() {
-  private void initOpState(DiskEntry entry,
-                           ValueWrapper value,
-                           byte userBits)
-  {
+  private void initOpState(DiskEntry entry, ValueWrapper value, byte userBits) {
-  
+
-   * Modifies a key/value pair from a region entry on disk. Updates all of the
-   * necessary {@linkplain DiskStoreStats statistics} and invokes basicModify
-   * @param entry
-   *          DiskEntry object representing the current Entry
-   * @param value
-   *          byte array representing the value
+   * Modifies a key/value pair from a region entry on disk. Updates all of the necessary
+   * {@linkplain DiskStoreStats statistics} and invokes basicModify
+   * 
+   * @param entry DiskEntry object representing the current Entry
+   * @param value byte array representing the value
-   * Asif: Modified the code so as to reuse the already created ByteBuffer
-   * during transition. Minimizing the synchronization allowing multiple put
-   * operations for different entries to proceed concurrently for asynch mode
+   * Asif: Modified the code so as to reuse the already created ByteBuffer during transition.
+   * Minimizing the synchronization allowing multiple put operations for different entries to
+   * proceed concurrently for asynch mode
+   * 
-  public final boolean modify(DiskRegion dr, DiskEntry entry, ValueWrapper value,
-                              boolean async)
-  {
+  public final boolean modify(DiskRegion dr, DiskEntry entry, ValueWrapper value, boolean async) {
-      throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()), ex, dr.getName());
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()),
+          ex, dr.getName());
-      throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0_DUE_TO_FAILURE_IN_ACQUIRING_READ_LOCK_FOR_ASYNCH_WRITING.toLocalizedString(this.diskFile.getPath()), ie, dr.getName());
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0_DUE_TO_FAILURE_IN_ACQUIRING_READ_LOCK_FOR_ASYNCH_WRITING
+              .toLocalizedString(this.diskFile.getPath()),
+          ie, dr.getName());
-  
-  public final boolean copyForwardForOverflowCompact(DiskEntry entry, byte[] value, int length, byte userBits) {
+
+  public final boolean copyForwardForOverflowCompact(DiskEntry entry, byte[] value, int length,
+      byte userBits) {
-      throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()), ex, getParent().getName());
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()),
+          ex, getParent().getName());
-      throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0_DUE_TO_FAILURE_IN_ACQUIRING_READ_LOCK_FOR_ASYNCH_WRITING.toLocalizedString(this.diskFile.getPath()), ie, getParent().getName());
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0_DUE_TO_FAILURE_IN_ACQUIRING_READ_LOCK_FOR_ASYNCH_WRITING
+              .toLocalizedString(this.diskFile.getPath()),
+          ie, getParent().getName());
-    
+
-   * Asif: A helper function which identifies whether to modify the entry in the
-   * current oplog or to make the switch to the next oplog. This function
-   * enables us to reuse the byte buffer which got created for an oplog which no
-   * longer permits us to use itself. It will also take acre of compaction if
-   * required
+   * Asif: A helper function which identifies whether to modify the entry in the current oplog or to
+   * make the switch to the next oplog. This function enables us to reuse the byte buffer which got
+   * created for an oplog which no longer permits us to use itself. It will also take acre of
+   * compaction if required
-   * @param entry
-   *          DiskEntry object representing the current Entry
+   * @param entry DiskEntry object representing the current Entry
-  private boolean basicModify(DiskEntry entry,
-                              ValueWrapper value,
-                              byte userBits, boolean async)
-    throws IOException, InterruptedException
-  {
+  private boolean basicModify(DiskEntry entry, ValueWrapper value, byte userBits, boolean async)
+      throws IOException, InterruptedException {
-          oldOplogId = (int)id.setOplogId(getOplogId());
+          oldOplogId = (int) id.setOplogId(getOplogId());
-      CacheObserverHolder.getInstance()
-        .afterSettingOplogOffSet(startPosForSynchOp);
+      CacheObserverHolder.getInstance().afterSettingOplogOffSet(startPosForSynchOp);
-   * @param entry
-   *          DiskEntry object on which remove operation is called
+   * @param entry DiskEntry object on which remove operation is called
-      throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()), ex, dr.getName());
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()),
+          ex, dr.getName());
-      throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0_DUE_TO_FAILURE_IN_ACQUIRING_READ_LOCK_FOR_ASYNCH_WRITING.toLocalizedString(this.diskFile.getPath()), ie, dr.getName());
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0_DUE_TO_FAILURE_IN_ACQUIRING_READ_LOCK_FOR_ASYNCH_WRITING
+              .toLocalizedString(this.diskFile.getPath()),
+          ie, dr.getName());
-   * Asif: A helper function which identifies whether to record a removal of
-   * entry in the current oplog or to make the switch to the next oplog. This
-   * function enables us to reuse the byte buffer which got created for an oplog
-   * which no longer permits us to use itself.
+   * Asif: A helper function which identifies whether to record a removal of entry in the current
+   * oplog or to make the switch to the next oplog. This function enables us to reuse the byte
+   * buffer which got created for an oplog which no longer permits us to use itself.
-   * @param entry
-   *          DiskEntry object representing the current Entry
+   * @param entry DiskEntry object representing the current Entry
-    throws IOException, InterruptedException
-  {
+      throws IOException, InterruptedException {
-//   /**
-//    * This is only used for an assertion check.
-//    */
-//   private long lastWritePos = -1;
+  // /**
+  // * This is only used for an assertion check.
+  // */
+  // private long lastWritePos = -1;
-//   /**
-//    * test hook
-//    */
-//   public final ByteBuffer getWriteBuf() {
-//     return this.crf.writeBuf;
-//   }
+  // /**
+  // * test hook
+  // */
+  // public final ByteBuffer getWriteBuf() {
+  // return this.crf.writeBuf;
+  // }
-      ByteBuffer bb = olf.writeBuf;
-      if (bb != null && bb.position() != 0) {
-        bb.flip();
-        int flushed = 0;
-        do {
-          flushed += olf.channel.write(bb);
-        } while (bb.hasRemaining());
-        // update bytesFlushed after entire writeBuffer is flushed to fix bug 41201
-        olf.bytesFlushed += flushed;
-        bb.clear();
-      }
+        ByteBuffer bb = olf.writeBuf;
+        if (bb != null && bb.position() != 0) {
+          bb.flip();
+          int flushed = 0;
+          do {
+            flushed += olf.channel.write(bb);
+          } while (bb.hasRemaining());
+          // update bytesFlushed after entire writeBuffer is flushed to fix bug 41201
+          olf.bytesFlushed += flushed;
+          bb.clear();
+        }
-  
+
-      throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()), ex, this.parent);
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_FAILED_WRITING_KEY_TO_0.toLocalizedString(this.diskFile.getPath()),
+          ex, this.parent);
-  
+
-   * Asif: Since the ByteBuffer being writen to can have additional bytes which
-   * are used for extending the size of the file, it is necessary that the
-   * ByteBuffer provided should have limit which is set to the position till
-   * which it contains the actual bytes. If the mode is synched write then only
-   * we will write up to the capacity & opLogSpace variable have any meaning.
-   * For asynch mode it will be zero. Also this method must be synchronized on
-   * the file , whether we use synch or asynch write because the fault in
-   * operations can clash with the asynch writing. Write the specified bytes to
-   * the oplog. Note that since extending a file is expensive this code will
-   * possibly write OPLOG_EXTEND_SIZE zero bytes to reduce the number of times
-   * the file is extended.
+   * Asif: Since the ByteBuffer being writen to can have additional bytes which are used for
+   * extending the size of the file, it is necessary that the ByteBuffer provided should have limit
+   * which is set to the position till which it contains the actual bytes. If the mode is synched
+   * write then only we will write up to the capacity & opLogSpace variable have any meaning. For
+   * asynch mode it will be zero. Also this method must be synchronized on the file , whether we use
+   * synch or asynch write because the fault in operations can clash with the asynch writing. Write
+   * the specified bytes to the oplog. Note that since extending a file is expensive this code will
+   * possibly write OPLOG_EXTEND_SIZE zero bytes to reduce the number of times the file is extended.
-   * @return The long offset at which the data present in the ByteBuffer gets
-   *         written to
+   * @return The long offset at which the data present in the ByteBuffer gets written to
-        Assert.assertTrue(
-                          false,
-                          toString()
-                          + " for store " + this.parent.getName()
-                          + " has been closed for synch mode while writing is going on. This should not happen");
+        Assert.assertTrue(false, toString() + " for store " + this.parent.getName()
+            + " has been closed for synch mode while writing is going on. This should not happen");
-          logger.trace(LogMarker.PERSIST_WRITES, "writeOpLogBytes startPos={} oplog#{}", startPos, getOplogId());
+          logger.trace(LogMarker.PERSIST_WRITES, "writeOpLogBytes startPos={} oplog#{}", startPos,
+              getOplogId());
-          logger.trace(LogMarker.PERSIST_WRITES, "writeOpLogBytes bytesWritten={} oldBytesFlushed={} byteFlushed={} oplog#{}",
+          logger.trace(LogMarker.PERSIST_WRITES,
+              "writeOpLogBytes bytesWritten={} oldBytesFlushed={} byteFlushed={} oplog#{}",
-      
-//       // Moved the set of lastWritePos to after write
-//       // so if write throws an exception it will not be updated.
-//       // This fixes bug 40449.
-//       this.lastWritePos = startPos;
+
+        // // Moved the set of lastWritePos to after write
+        // // so if write throws an exception it will not be updated.
+        // // This fixes bug 40449.
+        // this.lastWritePos = startPos;
-  private BytesAndBits attemptGet(DiskRegionView dr, long offsetInOplog,
-                                  int valueLength, byte userBits) throws IOException {
+  private BytesAndBits attemptGet(DiskRegionView dr, long offsetInOplog, int valueLength,
+      byte userBits) throws IOException {
-      //         if (this.closed || this.deleted.get()) {
-      //           throw new DiskAccessException("attempting get on "
-      //                                         + (this.deleted.get() ? "destroyed" : "closed")
-      //                                         + " oplog #" + getOplogId(), this.owner);
-      //         }
+      // if (this.closed || this.deleted.get()) {
+      // throw new DiskAccessException("attempting get on "
+      // + (this.deleted.get() ? "destroyed" : "closed")
+      // + " oplog #" + getOplogId(), this.owner);
+      // }
-          if (/*!getParent().isSync() since compactor groups writes
-                && */ (readPosition+valueLength) > this.crf.bytesFlushed
-                      && !this.closed) {
+          if (/*
+               * !getParent().isSync() since compactor groups writes &&
+               */ (readPosition + valueLength) > this.crf.bytesFlushed && !this.closed) {
-//           if (EntryBits.isSerialized(userBits)) {
-//             try {
-//               org.apache.geode.internal.util.BlobHelper.deserializeBlob(valueBytes);
-//             } catch (IOException ex) {
-//               throw new RuntimeException("DEBUG readPos=" + readPosition + " len=" + valueLength +  "doneApp=" + doneAppending + " userBits=" + userBits, ex);
-//             } catch (ClassNotFoundException ex2) {
-//               throw new RuntimeException(ex2);
-//             }
-//           }
+          // if (EntryBits.isSerialized(userBits)) {
+          // try {
+          // org.apache.geode.internal.util.BlobHelper.deserializeBlob(valueBytes);
+          // } catch (IOException ex) {
+          // throw new RuntimeException("DEBUG readPos=" + readPosition + " len=" + valueLength +
+          // "doneApp=" + doneAppending + " userBits=" + userBits, ex);
+          // } catch (ClassNotFoundException ex2) {
+          // throw new RuntimeException(ex2);
+          // }
+          // }
-        }
-        finally {
+        } finally {
-  private BytesAndBits attemptWriteBufferGet(long writePosition, long readPosition,
-                                             int valueLength, byte userBits) {
+  private BytesAndBits attemptWriteBufferGet(long writePosition, long readPosition, int valueLength,
+      byte userBits) {
-        && (writePosition+curWriteBufPos) >= (readPosition+valueLength)) {
-      int bufOffset = (int)(readPosition - writePosition);
+        && (writePosition + curWriteBufPos) >= (readPosition + valueLength)) {
+      int bufOffset = (int) (readPosition - writePosition);
-   * @param offsetInOplog
-   *          The starting position from which to read the data in the opLog
-   * @param bitOnly
-   *          boolean indicating whether the value needs to be extracted along
-   *          with the UserBit or not.
-   * @param valueLength
-   *          The length of the byte array which represents the value
-   * @param userBits
-   *          The userBits of the value.
+   * @param offsetInOplog The starting position from which to read the data in the opLog
+   * @param bitOnly boolean indicating whether the value needs to be extracted along with the
+   *        UserBit or not.
+   * @param valueLength The length of the byte array which represents the value
+   * @param userBits The userBits of the value.
-                                int valueLength, byte userBits)
-  {
+      int valueLength, byte userBits) {
-    if (EntryBits.isAnyInvalid(userBits) || EntryBits.isTombstone(userBits) || bitOnly || valueLength == 0) {
+    if (EntryBits.isAnyInvalid(userBits) || EntryBits.isTombstone(userBits) || bitOnly
+        || valueLength == 0) {
-    }
-    else {
-      if (offsetInOplog == -1) return null;
+    } else {
+      if (offsetInOplog == -1)
+        return null;
-          }
-          catch (InterruptedIOException e) { // bug 39756
+          } catch (InterruptedIOException e) { // bug 39756
-          }
-          finally {
+          } finally {
-      }
-      catch (IOException ex) {
-        throw new DiskAccessException(LocalizedStrings.Oplog_FAILED_READING_FROM_0_OPLOGID_1_OFFSET_BEING_READ_2_CURRENT_OPLOG_SIZE_3_ACTUAL_FILE_SIZE_4_IS_ASYNCH_MODE_5_IS_ASYNCH_WRITER_ALIVE_6
-            .toLocalizedString(
-                new Object[] {
-                    this.diskFile.getPath(),
-                    Long.valueOf(this.oplogId),
-                    Long.valueOf(offsetInOplog),
-                    Long.valueOf(this.crf.currSize),
-                    Long.valueOf(this.crf.bytesFlushed),
-                    Boolean.valueOf(!dr.isSync()),
-                    Boolean.valueOf(false)
-                }), ex, dr.getName());
-      }
-      catch (IllegalStateException ex) {
+      } catch (IOException ex) {
+        throw new DiskAccessException(
+            LocalizedStrings.Oplog_FAILED_READING_FROM_0_OPLOGID_1_OFFSET_BEING_READ_2_CURRENT_OPLOG_SIZE_3_ACTUAL_FILE_SIZE_4_IS_ASYNCH_MODE_5_IS_ASYNCH_WRITER_ALIVE_6
+                .toLocalizedString(new Object[] {this.diskFile.getPath(),
+                    Long.valueOf(this.oplogId), Long.valueOf(offsetInOplog),
+                    Long.valueOf(this.crf.currSize), Long.valueOf(this.crf.bytesFlushed),
+                    Boolean.valueOf(!dr.isSync()), Boolean.valueOf(false)}),
+            ex, dr.getName());
+      } catch (IllegalStateException ex) {
-  
+
-  
+
-    if (olf.f == null) return;
-    if (!olf.f.exists()) return;
+    if (olf.f == null)
+      return;
+    if (!olf.f.exists())
+      return;
-      throw new DiskAccessException(LocalizedStrings.Oplog_COULD_NOT_DELETE__0_.toLocalizedString(olf.f.getAbsolutePath()), this.parent);
+      throw new DiskAccessException(
+          LocalizedStrings.Oplog_COULD_NOT_DELETE__0_.toLocalizedString(olf.f.getAbsolutePath()),
+          this.parent);
-                  new Object[] {toString(), "crf", this.parent.getName()}));
+        new Object[] {toString(), "crf", this.parent.getName()}));
-  FileChannel getFileChannel()
-  {
+  FileChannel getFileChannel() {
-  DirectoryHolder getDirectoryHolder()
-  {
+  DirectoryHolder getDirectoryHolder() {
-   * The current size of Oplog. It may be less than the actual Oplog file size (
-   * in case of asynch writing as it also takes into account data present in
-   * asynch buffers which will get flushed in course of time o
+   * The current size of Oplog. It may be less than the actual Oplog file size ( in case of asynch
+   * writing as it also takes into account data present in asynch buffers which will get flushed in
+   * course of time o
-   * The number of records in this oplog that contain the most recent
-   * value of the entry.
+   * The number of records in this oplog that contain the most recent value of the entry.
-    if (suggestedOffset+length > this.maxOplogSize) {
+    if (suggestedOffset + length > this.maxOplogSize) {
+
+
-      //Fix for 49898 - by synchronizing on the live entries, we ensure
-      //that if the compaction thread does not find an entry in the live list,
-      //it will also see an updated totalLiveCount.
-      synchronized(this.liveEntries) {
-      if (this.liveEntries.remove(de)) {
-        this.totalLiveCount.decrementAndGet();
-        return true;
-      } else {
-        return false;
-      }
+      // Fix for 49898 - by synchronizing on the live entries, we ensure
+      // that if the compaction thread does not find an entry in the live list,
+      // it will also see an updated totalLiveCount.
+      synchronized (this.liveEntries) {
+        if (this.liveEntries.remove(de)) {
+          this.totalLiveCount.decrementAndGet();
+          return true;
+        } else {
+          return false;
+        }
-    if (!isCompactionPossible()) return false;
-    if (getParent().getCompactionThreshold() == 100) return true;
-    if (getParent().getCompactionThreshold() == 0) return false;
+    if (!isCompactionPossible())
+      return false;
+    if (getParent().getCompactionThreshold() == 100)
+      return true;
+    if (getParent().getCompactionThreshold() == 0)
+      return false;
-                    new Object[] {this.parent.getName(), toString()}));
+          new Object[] {this.parent.getName(), toString()}));
-        
+
-  
+
-//   // Comparable code //
-//   public int compareTo(Oplog o) {
-//     return getOplogId() - o.getOplogId();
-//   }
-//   public boolean equals(Object o) {
-//     if (o instanceof Oplog) {
-//       return compareTo((Oplog)o) == 0;
-//     } else {
-//       return false;
-//     }
-//   }
-//   public int hashCode() {
-//     return getOplogId();
-//   }
+  // // Comparable code //
+  // public int compareTo(Oplog o) {
+  // return getOplogId() - o.getOplogId();
+  // }
+  // public boolean equals(Object o) {
+  // if (o instanceof Oplog) {
+  // return compareTo((Oplog)o) == 0;
+  // } else {
+  // return false;
+  // }
+  // }
+  // public int hashCode() {
+  // return getOplogId();
+  // }
-   * Holds all the state for the current operation.
-   * Since an oplog can only have one operation in progress at any given
-   * time we only need a single instance of this class per oplog.
+   * Holds all the state for the current operation. Since an oplog can only have one operation in
+   * progress at any given time we only need a single instance of this class per oplog.
-    
-    public void initialize(DiskEntry entry,
-                           ValueWrapper value,
-                           byte userBits)
-    {
+
+    public void initialize(DiskEntry entry, ValueWrapper value, byte userBits) {
+
-//   private static String baToString(byte[] ba) {
-//     if ( ba == null) return "null";
-//     StringBuffer sb = new StringBuffer();
-//     for (int i=0; i < ba.length; i++) {
-//       sb.append(ba[i]).append(", ");
-//     }
-//     return sb.toString();
-//   }
+  // private static String baToString(byte[] ba) {
+  // if ( ba == null) return "null";
+  // StringBuffer sb = new StringBuffer();
+  // for (int i=0; i < ba.length; i++) {
+  // sb.append(ba[i]).append(", ");
+  // }
+  // return sb.toString();
+  // }
+
+
+
-  
+
-    if (!this.compacting) return false;
+    if (!this.compacting)
+      return false;
+
+
-    lockCompactor();
-    try {
-      if (hasNoLiveValues()) {
-        handleNoLiveValues();
-        return 0;
-      }
-      //Asif:Start with a fresh wrapper on every compaction so that 
-      //if previous run used some high memory byte array which was
-      // exceptional, it gets garbage collected.
-      long opStart = getStats().getStatTime();
-      BytesAndBitsForCompactor wrapper = new BytesAndBitsForCompactor();
+      lockCompactor();
+      try {
+        if (hasNoLiveValues()) {
+          handleNoLiveValues();
+          return 0;
+        }
+        // Asif:Start with a fresh wrapper on every compaction so that
+        // if previous run used some high memory byte array which was
+        // exceptional, it gets garbage collected.
+        long opStart = getStats().getStatTime();
+        BytesAndBitsForCompactor wrapper = new BytesAndBitsForCompactor();
-      DiskEntry de;
-      DiskEntry lastDe = null;
-      boolean compactFailed = !compactor.keepCompactorRunning();
-      int totalCount = 0;
-      boolean didCompact = false;
-      while ((de = getNextLiveEntry()) != null) {
-        if (!compactor.keepCompactorRunning()) {
-          compactFailed = true;
-          break;
-        }
-        if (lastDe != null) {
-          if (lastDe == de) {
-            throw new IllegalStateException("compactor would have gone into infinite loop");
+        DiskEntry de;
+        DiskEntry lastDe = null;
+        boolean compactFailed = !compactor.keepCompactorRunning();
+        int totalCount = 0;
+        boolean didCompact = false;
+        while ((de = getNextLiveEntry()) != null) {
+          if (!compactor.keepCompactorRunning()) {
+            compactFailed = true;
+            break;
-          assert lastDe != de;
-        }
-        lastDe = de;
-        didCompact = false;
-        synchronized (de) { // fix for bug 41797
-        DiskId did = de.getDiskId();
-        assert did != null;
-        synchronized (did) {
-          long oplogId = did.getOplogId();
-          if (oplogId != getOplogId()) {
-            if (oplogId == -1) {
-              // to prevent bug 42304 do a rmLive call
-              rmLive(de);
+          if (lastDe != null) {
+            if (lastDe == de) {
+              throw new IllegalStateException("compactor would have gone into infinite loop");
-            continue;
+            assert lastDe != de;
-          //Bug 42304 - If the entry has been invalidated, don't copy it forward.
-          boolean toCompact = getBytesAndBitsForCompaction(de, wrapper);
-          if (toCompact) {
-            byte[] valueBytes = wrapper.getBytes();
-            int length = wrapper.getValidLength();
-            byte userBits = wrapper.getBits();
-            if (oplogId != did.getOplogId()) {
-              // @todo: Is this even possible? Perhaps I should just assert here
-              // skip this guy his oplogId changed
-              if (did.getOplogId() == -1) {
-                // to prevent bug 42304 do a rmLive call
-                rmLive(de);
+          lastDe = de;
+          didCompact = false;
+          synchronized (de) { // fix for bug 41797
+            DiskId did = de.getDiskId();
+            assert did != null;
+            synchronized (did) {
+              long oplogId = did.getOplogId();
+              if (oplogId != getOplogId()) {
+                if (oplogId == -1) {
+                  // to prevent bug 42304 do a rmLive call
+                  rmLive(de);
+                }
+                continue;
-              if (!wrapper.isReusable()) {
-                wrapper = new BytesAndBitsForCompactor();
+              // Bug 42304 - If the entry has been invalidated, don't copy it forward.
+              boolean toCompact = getBytesAndBitsForCompaction(de, wrapper);
+              if (toCompact) {
+                byte[] valueBytes = wrapper.getBytes();
+                int length = wrapper.getValidLength();
+                byte userBits = wrapper.getBits();
+                if (oplogId != did.getOplogId()) {
+                  // @todo: Is this even possible? Perhaps I should just assert here
+                  // skip this guy his oplogId changed
+                  if (did.getOplogId() == -1) {
+                    // to prevent bug 42304 do a rmLive call
+                    rmLive(de);
+                  }
+                  if (!wrapper.isReusable()) {
+                    wrapper = new BytesAndBitsForCompactor();
+                  }
+                  continue;
+                }
+                if (EntryBits.isAnyInvalid(userBits)) {
+                  rmLive(de);
+                  if (!wrapper.isReusable()) {
+                    wrapper = new BytesAndBitsForCompactor();
+                  }
+                  continue;
+                }
+                // write it to the current oplog
+                getOplogSet().copyForwardForOverflowCompact(de, valueBytes, length, userBits);
+                // the did's oplogId will now be set to the current active oplog
+                didCompact = true;
-              continue;
+            } // did
+          } // de
+          if (didCompact) {
+            totalCount++;
+            getStats().endCompactionUpdate(opStart);
+            opStart = getStats().getStatTime();
+            // Asif: Check if the value byte array happens to be any of the constant
+            // static byte arrays or references the value byte array of underlying RegionEntry.
+            // If so for preventing data corruption across regions
+            // ( in case of static byte arrays) & for RegionEntry,
+            // recreate the wrapper
+            if (!wrapper.isReusable()) {
+              wrapper = new BytesAndBitsForCompactor();
-            if(EntryBits.isAnyInvalid(userBits)) {
-              rmLive(de);
-              if (!wrapper.isReusable()) {
-                wrapper = new BytesAndBitsForCompactor();
-              }
-              continue;
-            }
-            // write it to the current oplog
-            getOplogSet().copyForwardForOverflowCompact(de, valueBytes, length, userBits);
-            // the did's oplogId will now be set to the current active oplog
-            didCompact = true;
-          }
-        } // did
-        } // de
-        if (didCompact) {
-          totalCount++;
-          getStats().endCompactionUpdate(opStart);
-          opStart = getStats().getStatTime();
-          //Asif: Check if the value byte array happens to be any of the constant
-          //static byte arrays or references the value byte array of underlying RegionEntry.
-          // If so for  preventing data corruption across regions  
-          //( in case of static byte arrays) & for RegionEntry, 
-          //recreate the wrapper
-          if (!wrapper.isReusable()) {
-            wrapper = new BytesAndBitsForCompactor();
+
+        if (!compactFailed) {
+          // Need to still remove the oplog even if it had nothing to compact.
+          handleNoLiveValues();
+        }
+        return totalCount;
+      } finally {
+        unlockCompactor();
+        isCompactorThread.remove();
-    
-      if (!compactFailed) {
-        // Need to still remove the oplog even if it had nothing to compact.
-        handleNoLiveValues();
-      }
-      return totalCount;
-    } finally {
-      unlockCompactor();
-      isCompactorThread.remove();
-    } 
-   * Asif:This function retrieves the value for an entry being compacted subject to
-   * entry referencing the oplog being compacted. Attempt is made to retrieve the
-   * value from in memory , if available, else from asynch buffers ( if asynch
-   * mode is enabled), else from the Oplog being compacted. It is invoked from
-   * switchOplog as well as OplogCompactor's compact function.
+   * Asif:This function retrieves the value for an entry being compacted subject to entry
+   * referencing the oplog being compacted. Attempt is made to retrieve the value from in memory ,
+   * if available, else from asynch buffers ( if asynch mode is enabled), else from the Oplog being
+   * compacted. It is invoked from switchOplog as well as OplogCompactor's compact function.
-   * @param entry
-   *                DiskEntry being compacted referencing the Oplog being compacted
-   * @param wrapper
-   *                Object of type BytesAndBitsForCompactor. The data if found is
-   *                set in the wrapper Object. The wrapper Object also contains
-   *                the user bit associated with the entry
-   * @return boolean false indicating that entry need not be compacted. If true it
-   *         means that wrapper has been appropriately filled with data
+   * @param entry DiskEntry being compacted referencing the Oplog being compacted
+   * @param wrapper Object of type BytesAndBitsForCompactor. The data if found is set in the wrapper
+   *        Object. The wrapper Object also contains the user bit associated with the entry
+   * @return boolean false indicating that entry need not be compacted. If true it means that
+   *         wrapper has been appropriately filled with data
-  private boolean getBytesAndBitsForCompaction(DiskEntry entry,
-                                               BytesAndBitsForCompactor wrapper)
-  {
+  private boolean getBytesAndBitsForCompaction(DiskEntry entry, BytesAndBitsForCompactor wrapper) {
-      foundData = basicGetForCompactor(oplogOffset, false,
-                                       did.getValueLength(),
-                                       did.getUserBits(),
-                                       wrapper);
+      foundData = basicGetForCompactor(oplogOffset, false, did.getValueLength(), did.getUserBits(),
+          wrapper);
-          wrapper.setData(DiskEntry.INVALID_BYTES, userBits, DiskEntry.INVALID_BYTES.length, false/* Can not be reused*/);
+          wrapper.setData(DiskEntry.INVALID_BYTES, userBits, DiskEntry.INVALID_BYTES.length,
+              false/* Can not be reused */);
-          wrapper.setData(DiskEntry.LOCAL_INVALID_BYTES, userBits, DiskEntry.LOCAL_INVALID_BYTES.length, false/* Can not be reused*/);
+          wrapper.setData(DiskEntry.LOCAL_INVALID_BYTES, userBits,
+              DiskEntry.LOCAL_INVALID_BYTES.length, false/* Can not be reused */);
-        wrapper.setData(DiskEntry.TOMBSTONE_BYTES, userBits, DiskEntry.TOMBSTONE_BYTES.length, false/* Can not be reused*/);
+        wrapper.setData(DiskEntry.TOMBSTONE_BYTES, userBits, DiskEntry.TOMBSTONE_BYTES.length,
+            false/* Can not be reused */);
+
-   * Asif: Extracts the Value byte array & UserBit from the OpLog and inserts it
-   * in the wrapper Object of type BytesAndBitsForCompactor which is passed
+   * Asif: Extracts the Value byte array & UserBit from the OpLog and inserts it in the wrapper
+   * Object of type BytesAndBitsForCompactor which is passed
-   * @param offsetInOplog
-   *                The starting position from which to read the data in the
-   *                opLog
-   * @param bitOnly
-   *                boolean indicating whether the value needs to be extracted
-   *                along with the UserBit or not.
-   * @param valueLength
-   *                The length of the byte array which represents the value
-   * @param userBits
-   *                The userBits of the value.
-   * @param wrapper
-   *                Object of type BytesAndBitsForCompactor. The data is set in the
-   *                wrapper Object. The wrapper Object also contains the user
-   *                bit associated with the entry
+   * @param offsetInOplog The starting position from which to read the data in the opLog
+   * @param bitOnly boolean indicating whether the value needs to be extracted along with the
+   *        UserBit or not.
+   * @param valueLength The length of the byte array which represents the value
+   * @param userBits The userBits of the value.
+   * @param wrapper Object of type BytesAndBitsForCompactor. The data is set in the wrapper Object.
+   *        The wrapper Object also contains the user bit associated with the entry
-  private boolean basicGetForCompactor(long offsetInOplog, boolean bitOnly,
-      int valueLength, byte userBits, BytesAndBitsForCompactor wrapper) {
-    if (EntryBits.isAnyInvalid(userBits) || EntryBits.isTombstone(userBits) || bitOnly || valueLength == 0) {
+  private boolean basicGetForCompactor(long offsetInOplog, boolean bitOnly, int valueLength,
+      byte userBits, BytesAndBitsForCompactor wrapper) {
+    if (EntryBits.isAnyInvalid(userBits) || EntryBits.isTombstone(userBits) || bitOnly
+        || valueLength == 0) {
-        wrapper.setData(DiskEntry.INVALID_BYTES, userBits,
-                        DiskEntry.INVALID_BYTES.length, false /* Cannot be reused */);
+        wrapper.setData(DiskEntry.INVALID_BYTES, userBits, DiskEntry.INVALID_BYTES.length,
+            false /* Cannot be reused */);
-        wrapper.setData(DiskEntry.TOMBSTONE_BYTES, userBits,
-                        DiskEntry.TOMBSTONE_BYTES.length, false /* Cannot be reused */);
+        wrapper.setData(DiskEntry.TOMBSTONE_BYTES, userBits, DiskEntry.TOMBSTONE_BYTES.length,
+            false /* Cannot be reused */);
-                        DiskEntry.LOCAL_INVALID_BYTES.length, false /* Cannot be reused */);
+            DiskEntry.LOCAL_INVALID_BYTES.length, false /* Cannot be reused */);
-    }
-    else {
+    } else {
-          if (/*!getParent().isSync() since compactor groups writes
-                && */ (readPosition+valueLength) > this.crf.bytesFlushed
-              && !this.closed) {
+          if (/*
+               * !getParent().isSync() since compactor groups writes &&
+               */ (readPosition + valueLength) > this.crf.bytesFlushed && !this.closed) {
-          final long writePosition = (this.doneAppending)
-            ? this.crf.bytesFlushed
-            : this.crf.raf.getFilePointer();
-          if ((readPosition+valueLength) > writePosition) {
+          final long writePosition =
+              (this.doneAppending) ? this.crf.bytesFlushed : this.crf.raf.getFilePointer();
+          if ((readPosition + valueLength) > writePosition) {
-              LocalizedStrings.Oplog_TRIED_TO_SEEK_TO_0_BUT_THE_FILE_LENGTH_IS_1_OPLOG_FILE_OBJECT_USED_FOR_READING_2.toLocalizedString(
-                                                                                                                                        new Object[] {readPosition+valueLength, writePosition, this.crf.raf}), getParent().getName());
-          }
-          else if (readPosition < 0) {
+                LocalizedStrings.Oplog_TRIED_TO_SEEK_TO_0_BUT_THE_FILE_LENGTH_IS_1_OPLOG_FILE_OBJECT_USED_FOR_READING_2
+                    .toLocalizedString(
+                        new Object[] {readPosition + valueLength, writePosition, this.crf.raf}),
+                getParent().getName());
+          } else if (readPosition < 0) {
-              LocalizedStrings.Oplog_CANNOT_FIND_RECORD_0_WHEN_READING_FROM_1
-                .toLocalizedString(
-                                   new Object[] { Long.valueOf(offsetInOplog), this.diskFile.getPath()}), getParent().getName());
+                LocalizedStrings.Oplog_CANNOT_FIND_RECORD_0_WHEN_READING_FROM_1.toLocalizedString(
+                    new Object[] {Long.valueOf(offsetInOplog), this.diskFile.getPath()}),
+                getParent().getName());
-//           if (this.closed || this.deleted.get()) {
-//             throw new DiskAccessException("attempting get on "
-//                                           + (this.deleted.get() ? "destroyed" : "closed")
-//                                           + " oplog #" + getOplogId(), this.owner);
-//           }
+          // if (this.closed || this.deleted.get()) {
+          // throw new DiskAccessException("attempting get on "
+          // + (this.deleted.get() ? "destroyed" : "closed")
+          // + " oplog #" + getOplogId(), this.owner);
+          // }
-            }
-            else {
+            } else {
-          }
-          finally {
+          } finally {
-//             if (this.closed || this.deleted.get()) {
-//               throw new DiskAccessException("attempting get on "
-//                                             + (this.deleted.get() ? "destroyed" : "closed")
-//                                             + " oplog #" + getOplogId(), this.owner);
-//             }
+            // if (this.closed || this.deleted.get()) {
+            // throw new DiskAccessException("attempting get on "
+            // + (this.deleted.get() ? "destroyed" : "closed")
+            // + " oplog #" + getOplogId(), this.owner);
+            // }
-      }
-      catch (IOException ex) {
+      } catch (IOException ex) {
-          LocalizedStrings.Oplog_FAILED_READING_FROM_0_OPLOG_DETAILS_1_2_3_4_5_6
-          .toLocalizedString(
-                             new Object[] {  this.diskFile.getPath(), Long.valueOf(this.oplogId), Long.valueOf(offsetInOplog), Long.valueOf(this.crf.currSize), Long.valueOf(this.crf.bytesFlushed), Boolean.valueOf(/*!dr.isSync() @todo */false), Boolean.valueOf(false)}), ex, getParent().getName());
+            LocalizedStrings.Oplog_FAILED_READING_FROM_0_OPLOG_DETAILS_1_2_3_4_5_6
+                .toLocalizedString(new Object[] {this.diskFile.getPath(),
+                    Long.valueOf(this.oplogId), Long.valueOf(offsetInOplog),
+                    Long.valueOf(this.crf.currSize), Long.valueOf(this.crf.bytesFlushed),
+                    Boolean.valueOf(/* !dr.isSync() @todo */false), Boolean.valueOf(false)}),
+            ex, getParent().getName());
-      }
-      catch (IllegalStateException ex) {
+      } catch (IllegalStateException ex) {
-  } 
+  }

Merge branch 'feature/GEODE-8' into develop

+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.TX_ENTRY_STATE;
+
+import java.io.DataInput;
+import org.apache.logging.log4j.Logger;
+
-import com.gemstone.gemfire.distributed.internal.InternalDistributedSystem;
+import com.gemstone.gemfire.internal.DataSerializableFixedID;
+import com.gemstone.gemfire.internal.Version;
-import com.gemstone.gemfire.internal.cache.lru.LRUEntry;
+import com.gemstone.gemfire.internal.cache.versions.RegionVersionVector;
+import com.gemstone.gemfire.internal.logging.LogService;
+import com.gemstone.gemfire.internal.offheap.OffHeapHelper;
+import com.gemstone.gemfire.internal.offheap.Releasable;
+import com.gemstone.gemfire.internal.offheap.StoredObject;
+import com.gemstone.gemfire.internal.offheap.annotations.Released;
+import com.gemstone.gemfire.internal.offheap.annotations.Retained;
+import com.gemstone.gemfire.internal.offheap.annotations.Unretained;
-public class TXEntryState
+public class TXEntryState implements Releasable
+  private static final Logger logger = LogService.getLogger();
+  
+  @Retained(TX_ENTRY_STATE)
+   * Next region version generated on the primary
+   */
+  private long nextRegionVersion = -1;
+  
+  /*
+   * For Distributed Transaction.
+   * THis value is set when applying commit
+   */
+  private transient DistTxThinEntryState distTxThinEntryState;
+  
+  /**
-  protected TXEntryState(RegionEntry re, Object pvId, Object pv, TXRegionState txRegionState) {
+  protected TXEntryState(RegionEntry re, Object pvId, Object pv, TXRegionState txRegionState, boolean isDistributed) {
+    if (isDistributed) {
+      this.distTxThinEntryState = new DistTxThinEntryState();
+    }
+  @Unretained
+  @Retained
-  private String opToString()
+  String opToString()
+    // OFFHEAP: freeOffHeapResources on this event is called from TXEvent.freeOffHeapResources.
+    boolean returnedResult = false;
+    try {
+    returnedResult = true;
+    } finally {
+      if (!returnedResult) result.release();
+    }
+  
+
+  /* TODO OFFHEAP MERGE: is this code needed?
+  @Retained
+  protected final Object getRetainedValueInTXOrRegion() {
+    @Unretained Object val = this.getValueInTXOrRegion();
+    if (val instanceof Chunk) {
+      if (!((Chunk) val).retain()) {
+        throw new IllegalStateException("Could not retain OffHeap value=" + val);
+      }
+    }
+    return val;
+  }
+  */
+    if (o1 instanceof StoredObject) {
+      if (o1.equals(o2)) return true;
+    }
+      try {
+      } finally {
+        OffHeapHelper.release(curCmtVersionId);
+      }
+      if (o instanceof StoredObject && ((StoredObject) o).isCompressed()) {
+        // fix for bug 52113
+        return "<compressed value of size " + ((StoredObject) o).getValueSizeInBytes() + ">";
+      }
-    
+    if (LogService.getLogger().isDebugEnabled()) {
+      LogService.getLogger().debug(
+          "applyChanges txState=" + txState + " ,key=" + key + " ,r="
+              + r.getDisplayName() + " ,op=" + this.op + " ,isDirty="
+              + isDirty());
+    }
+
+  @Override
+  @Released(TX_ENTRY_STATE)
+  public void release() {
+    Object tmp = this.originalVersionId;
+    if (OffHeapHelper.release(tmp)) {
+      this.originalVersionId = null; // fix for bug 47900
+    }
+  }
+    close();
-          getNearSidePendingValue(),TXEntryState.this.getCallbackArgument(), false, r.getMyId());
+          getNearSidePendingValue(),TXEntryState.this.getCallbackArgument(), false, r.getMyId()
+          , true/* generateCallbacks */, true /*initializeId*/);
-    public TXEntryState createEntry(RegionEntry re, Object vId, Object pendingValue, Object entryKey,TXRegionState txrs)
+    public TXEntryState createEntry(RegionEntry re, Object vId, Object pendingValue, Object entryKey,TXRegionState txrs,boolean isDistributed)
-      return new TXEntryState(re, vId, pendingValue, txrs);
+      return new TXEntryState(re, vId, pendingValue, txrs, isDistributed);
-}
+
+  public void close() {
+    release();
+  }
+  
+  public void setNextRegionVersion(long v) {
+    this.nextRegionVersion = v;
+  }
+  
+  public long getNextRegionVersion() {
+    return this.nextRegionVersion;
+  }
+  
+  @Override
+  public String toString() {
+    StringBuilder str = new StringBuilder();
+    str.append("{").append(super.toString()).append(" ");
+    str.append(this.op);
+    str.append("}");
+    return str.toString();
+  }
+
+  public DistTxThinEntryState getDistTxEntryStates() {
+    return this.distTxThinEntryState;
+  }
+  
+  public void setDistTxEntryStates(DistTxThinEntryState thinEntryState) {
+    this.distTxThinEntryState = thinEntryState;
+  }
+
+  /**
+   * For Distributed Transaction Usage
+   * 
+   * This class is used to bring relevant information for DistTxEntryEvent from
+   * primary, after end of precommit. Same information are sent to all
+   * replicates during commit.
+   * 
+   * Whereas @see DistTxEntryEvent is used forstoring entry event information on
+   * TxCordinator and carry same to replicates.
+   * 
+   * @author vivekb
+   */
+  public static class DistTxThinEntryState implements DataSerializableFixedID {
+
+    private long regionVersion =1L;
+    private long tailKey = -1L;
+    private String memberID;
+
+    // For Serialization
+    public DistTxThinEntryState() {
+    }
+
+    @Override
+    public Version[] getSerializationVersions() {
+      // TODO Auto-generated method stub
+      return null;
+    }
+
+    @Override
+    public int getDSFID() {
+      return DIST_TX_THIN_ENTRY_STATE;
+    }
+
+    @Override
+    public void toData(DataOutput out) throws IOException {
+      DataSerializer.writeLong(this.regionVersion, out);
+      DataSerializer.writeLong(this.tailKey, out);
+    }
+
+    @Override
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
+      this.regionVersion = DataSerializer.readLong(in);
+      this.tailKey = DataSerializer.readLong(in);
+    }
+
+    @Override
+    public String toString() {
+      StringBuilder buf = new StringBuilder();
+      buf.append("DistTxThinEntryState: ");
+      buf.append(" ,regionVersion=" + this.regionVersion);
+      buf.append(" ,tailKey=" + this.tailKey);
+      buf.append(" ,memberID=" + this.memberID);
+      return buf.toString();
+    }
+
+    public long getRegionVersion() {
+      return this.regionVersion;
+    }
+
+    public void setRegionVersion(long regionVersion) {
+      this.regionVersion = regionVersion;
+    }
+
+    public long getTailKey() {
+      return this.tailKey;
+    }
+
+    public void setTailKey(long tailKey) {
+      this.tailKey = tailKey;
+    }
+
+    public String getMemberID() {
+      return memberID;
+    }
+
+    public void setMemberID(String memberID) {
+      this.memberID = memberID;
+    }
+  }
+}

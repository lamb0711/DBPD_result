Revert "GEODE-7177: Extract LogService to a separate submodule"

This reverts commit 0e3f884caa8af76e4db20d71e759838c39856455.

+import java.util.concurrent.Executor;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.ForkJoinPool.ForkJoinWorkerThreadFactory;
+import java.util.concurrent.ForkJoinWorkerThread;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
-public class CoreLoggingExecutors {
+public class LoggingExecutors {
+  private static ThreadPoolExecutor newFixedThreadPool(String threadName, boolean isDaemon,
+      int poolSize, long keepAliveSeconds, BlockingQueue<Runnable> feed) {
+    ThreadFactory threadFactory = new LoggingThreadFactory(threadName, isDaemon);
+    return new ThreadPoolExecutor(poolSize, poolSize,
+        keepAliveSeconds, SECONDS,
+        feed, threadFactory);
+  }
+
+  private static ThreadPoolExecutor newFixedThreadPool(String threadName, boolean isDaemon,
+      long keepAliveSeconds, int poolSize) {
+    LinkedBlockingQueue<Runnable> feed = new LinkedBlockingQueue<>();
+    return newFixedThreadPool(threadName, isDaemon, poolSize, keepAliveSeconds, feed);
+  }
+
+  public static ExecutorService newFixedThreadPool(String threadName, boolean isDaemon,
+      int poolSize) {
+    return newFixedThreadPool(threadName, isDaemon, 0L, poolSize);
+  }
+
+  public static ExecutorService newFixedThreadPoolWithTimeout(String threadName, int poolSize,
+      int keepAliveSeconds) {
+    return newFixedThreadPool(threadName, true, keepAliveSeconds, poolSize);
+  }
+
-    return LoggingExecutors.newFixedThreadPool(threadName, true, poolSize, keepAliveSeconds, feed);
+    return newFixedThreadPool(threadName, true, poolSize, keepAliveSeconds, feed);
+  }
+
+  public static ExecutorService newFixedThreadPoolWithFeedSize(String threadName,
+      int poolSize, int feedSize) {
+    LinkedBlockingQueue<Runnable> feed = new LinkedBlockingQueue<>(feedSize);
+    RejectedExecutionHandler rejectionHandler = new ThreadPoolExecutor.CallerRunsPolicy();
+    ThreadFactory threadFactory = new LoggingThreadFactory(threadName);
+    ThreadPoolExecutor executor = new ThreadPoolExecutor(poolSize, poolSize, 10, SECONDS, feed,
+        threadFactory, rejectionHandler);
+    executor.allowCoreThreadTimeOut(true);
+    return executor;
+  }
+
+  public static ExecutorService newSingleThreadExecutor(String threadName, boolean isDaemon) {
+    ThreadFactory threadFactory = new LoggingThreadFactory(threadName, isDaemon);
+    return new ThreadPoolExecutor(1, 1, 0L, SECONDS,
+        new LinkedBlockingQueue<Runnable>(),
+        threadFactory);
+  }
+
+  public static ExecutorService newCachedThreadPool(String threadName, boolean isDaemon) {
+    ThreadFactory threadFactory = new LoggingThreadFactory(threadName, isDaemon);
+    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
+        60L, TimeUnit.SECONDS,
+        new SynchronousQueue<Runnable>(),
+        threadFactory);
+  }
+
+  public static ExecutorService newWorkStealingPool(String threadName, int maxParallelThreads) {
+    final ForkJoinWorkerThreadFactory factory = pool -> {
+      ForkJoinWorkerThread worker = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+      LoggingUncaughtExceptionHandler.setOnThread(worker);
+      worker.setName(threadName + worker.getPoolIndex());
+      return worker;
+    };
+    return new ForkJoinPool(maxParallelThreads, factory, null, true);
+  }
+
+  public static Executor newThreadOnEachExecute(String threadName) {
+    return command -> new LoggingThread(threadName, command).start();
+  }
+
+  public static ScheduledExecutorService newScheduledThreadPool(String threadName, int poolSize) {
+    return newScheduledThreadPool(threadName, poolSize, true);
+  }
+
+  public static ScheduledExecutorService newScheduledThreadPool(String threadName, int poolSize,
+      boolean executeDelayedTasks) {
+    ScheduledThreadPoolExecutor result =
+        new ScheduledThreadPoolExecutor(poolSize, new LoggingThreadFactory(threadName));
+    result.setExecuteExistingDelayedTasksAfterShutdownPolicy(executeDelayedTasks);
+    return result;
+  }
+
+  public static ScheduledExecutorService newSingleThreadScheduledExecutor(String threadName) {
+    return newScheduledThreadPool(threadName, 1);
-  private CoreLoggingExecutors() {
+  private LoggingExecutors() {

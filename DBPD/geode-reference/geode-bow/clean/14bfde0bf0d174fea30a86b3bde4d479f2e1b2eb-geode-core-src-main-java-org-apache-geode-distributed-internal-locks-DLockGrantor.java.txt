Merge branch 'release/1.8.0'

-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+import org.apache.geode.internal.logging.LoggingThread;
-      // Now make sure the service still has this guy as its grantor
+      // Now make sure the service still has this member as its grantor
-          LocalizedStrings.DLockGrantor_GRANTOR_IS_DESTROYED.toLocalizedString());
+          "Grantor is destroyed");
-                    LocalizedMessage.create(
-                        LocalizedStrings.DLockGrantor_INITIALIZATION_OF_HELD_LOCKS_IS_SKIPPING_0_BECAUSE_LOCK_IS_ALREADY_HELD_1,
-                        new Object[] {token, grantToken}));
+                    "Initialization of held locks is skipping {} because lock is already held: {}",
+                    token, grantToken);
-            LocalizedMessage.create(
-                LocalizedStrings.DLockGrantor_DEBUGHANDLESUSPENDTIMEOUTS_SLEEPING_FOR__0,
-                localDebugHandleSuspendTimeouts));
+            "debugHandleSuspendTimeouts sleeping for  {}",
+            localDebugHandleSuspendTimeouts);
-      throw new IllegalArgumentException(LocalizedStrings.DLockGrantor_UNKNOWN_STATE_FOR_GRANTOR_0
-          .toLocalizedString(Integer.valueOf(state)));
+      throw new IllegalArgumentException(String.format("Unknown state for grantor: %s",
+          Integer.valueOf(state)));
-          LocalizedStrings.DLockGrantor_DLOCKGRANTOR_OPERATION_ONLY_ALLOWED_WHEN_INITIALIZING_NOT_0
-              .toLocalizedString(stateDesc));
+          String.format("DLockGrantor operation only allowed when initializing, not %s",
+              stateDesc));
-            + this.lockingSuspendedBy); // KIRK: assert fails in bug 37945
+            + this.lockingSuspendedBy);
-    // Assert.assertTrue(readLockCount > 0, rThread + " not found in " + readLockCountMap); // KIRK
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.DLockGrantor_RELEASED_REGULAR_LOCK_WITH_WAITING_READ_LOCK_0, s));
+        logger.warn("Released regular lock with waiting read lock: {}", s);
-            LocalizedStrings.DLockGrantor_RELEASED_REGULAR_LOCK_WITH_WAITING_READ_LOCK_0
-                .toString(s));
+            String.format("Released regular lock with waiting read lock: %s",
+                s));
-        logger.error(LocalizedMessage.create(
-            LocalizedStrings.DLockGrantor_PROCESSING_OF_POSTREMOTERELEASELOCK_THREW_UNEXPECTED_RUNTIMEEXCEPTION,
-            e));
+        logger.error(
+            "Processing of postRemoteReleaseLock threw unexpected RuntimeException",
+            e);
-        logger.info(LogMarker.DLS_MARKER, LocalizedMessage
-            .create(LocalizedStrings.DLockGrantor_IGNORING_LOCK_REQUEST_FROM_NONMEMBER_0, request));
+        logger.info(LogMarker.DLS_MARKER, "Ignoring lock request from non-member: {}", request);
-        logger.info(LogMarker.DLS_MARKER, LocalizedMessage
-            .create(LocalizedStrings.DLockGrantor_IGNORING_LOCK_REQUEST_FROM_NONMEMBER_0, request));
+        logger.info(LogMarker.DLS_MARKER, "Ignoring lock request from non-member: %s", request);
-      logger.info(LogMarker.DLS_MARKER, LocalizedMessage.create(LocalizedStrings.TESTING, buffer));
-      logger.info(LogMarker.DLS_MARKER, LocalizedMessage.create(LocalizedStrings.TESTING,
-          "\nreadLockCountMap:\n" + readLockCountMap));
+      logger.info(LogMarker.DLS_MARKER, "{}", buffer);
+      logger.info(LogMarker.DLS_MARKER, "{}",
+          "\nreadLockCountMap:\n" + readLockCountMap);
-      Assert.assertTrue(request.getRemoteThread() != null); // KIRK search for these assertions and
-                                                            // remove
+      Assert.assertTrue(request.getRemoteThread() != null);
-  private static class DLockGrantorThread extends Thread {
+  private static class DLockGrantorThread extends LoggingThread {
-      super(DLockService.getThreadGroup(), "Lock Grantor for " + grantor.dlock.getName());
-      setDaemon(true);
+      super("Lock Grantor for " + grantor.dlock.getName());
+        } catch (LockGrantorDestroyedException ex) {
+          this.shutdown = true;
+          return;
-            logger.warn(
-                LocalizedMessage.create(
-                    LocalizedStrings.DLockGrantor_DLOCKGRANTORTHREAD_WAS_UNEXPECTEDLY_INTERRUPTED),
+            logger.warn("DLockGrantorThread was unexpectedly interrupted",

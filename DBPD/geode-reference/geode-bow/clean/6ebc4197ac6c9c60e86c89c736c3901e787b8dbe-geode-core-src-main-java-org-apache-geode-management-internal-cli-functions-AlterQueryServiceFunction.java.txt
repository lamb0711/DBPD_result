GEODE-7497: Check CQs prior to change authorizer (#4385)

The QueryConfigurationService now requires an extra flag to determine,
in the presence of continuous queries, whether to update the configured
MethodInvocationAuthorizer and invalidate the CQ's internal cache or
throw an exception and abort the update.

- Fixed minor warnings.
- Added unit and distributed tests.
- Updated docs for alter query-service command.
- Added 'forceUpdate' flag to 'AlterQueryServiceFunction' and
  'AlterQueryServiceCommand'.
- Fixed 'AlterQueryServiceCommand' to always require the
  'method-authorizer' parameter.
-import static org.apache.geode.distributed.internal.DistributionConfig.GEMFIRE_PREFIX;
+import static org.apache.geode.cache.query.internal.QueryConfigurationServiceImpl.ALLOW_UNTRUSTED_METHOD_INVOCATION_SYSTEM_PROPERTY;
-import java.util.HashSet;
+import java.util.Collections;
+import org.apache.commons.lang3.StringUtils;
+
+import org.apache.geode.cache.query.internal.QueryConfigurationService;
-  static final String AUTHORIZER_UPDATED_MESSAGE =
+  private static final long serialVersionUID = 7155576168386556341L;
+  public static final String AUTHORIZER_UPDATED_MESSAGE =
+  public static final String EMPTY_AUTHORIZER_ERROR =
+      "MethodInvocationAuthorizer class name must not be empty.";
-  public static final String DEPRECATED_PROPERTY_ERROR =
-      "Deprecated System Property: \"" + GEMFIRE_PREFIX
-          + "QueryService.allowUntrustedMethodInvocation\" is set to TRUE. In order to use a MethodInvocationAuthorizer, this property must be FALSE or undefined.";
-  private static final long serialVersionUID = 7155576168386556341L;
-
-  @Override
-  @SuppressWarnings("unchecked")
-  public CliFunctionResult executeFunction(FunctionContext<Object[]> context) {
-
-    String authorizerName = (String) context.getArguments()[0];
-    Set<String> parameterSet;
-
-    if (context.getArguments()[1] != null) {
-      parameterSet = (Set<String>) context.getArguments()[1];
-    } else {
-      parameterSet = new HashSet<>();
-    }
-
-    if (authorizerName != null) {
-      if (!isSecurityEnabled()) {
-        return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.ERROR,
-            SECURITY_NOT_ENABLED_MESSAGE);
-      }
-      if (Boolean.parseBoolean(
-          System.getProperty(GEMFIRE_PREFIX + "QueryService.allowUntrustedMethodInvocation"))) {
-        return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.ERROR,
-            DEPRECATED_PROPERTY_ERROR);
-      }
-      try {
-        Cache cache = context.getCache();
-        ((InternalCache) cache)
-            .getService(org.apache.geode.cache.query.internal.QueryConfigurationService.class)
-            .updateMethodAuthorizer(cache, authorizerName, parameterSet);
-      } catch (Exception ex) {
-        return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.ERROR,
-            ex.getMessage());
-      }
-    }
-    String message = AUTHORIZER_UPDATED_MESSAGE + authorizerName + (parameterSet.size() > 0
-        ? AUTHORIZER_PARAMETERS_MESSAGE + String.join(", ", parameterSet) : "");
-    return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.OK,
-        message);
-  }
+  public static final String DEPRECATED_PROPERTY_ERROR = "Deprecated System Property: \""
+      + ALLOW_UNTRUSTED_METHOD_INVOCATION_SYSTEM_PROPERTY
+      + "\" is set to TRUE. In order to use a MethodInvocationAuthorizer, this property must be FALSE or undefined.";
+
+  @Override
+  @SuppressWarnings({"unchecked", "deprecation"})
+  public CliFunctionResult executeFunction(FunctionContext<Object[]> context) {
+    Set<String> parameterSet;
+    boolean forceUpdate = (boolean) context.getArguments()[0];
+    String authorizerName = (String) context.getArguments()[1];
+
+    if (context.getArguments()[2] != null) {
+      parameterSet = (Set<String>) context.getArguments()[2];
+    } else {
+      parameterSet = Collections.emptySet();
+    }
+
+    if (StringUtils.isEmpty(authorizerName)) {
+      return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.ERROR,
+          EMPTY_AUTHORIZER_ERROR);
+    }
+
+    if (!isSecurityEnabled()) {
+      return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.ERROR,
+          SECURITY_NOT_ENABLED_MESSAGE);
+    }
+
+    if (Boolean
+        .parseBoolean(System.getProperty(ALLOW_UNTRUSTED_METHOD_INVOCATION_SYSTEM_PROPERTY))) {
+      return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.ERROR,
+          DEPRECATED_PROPERTY_ERROR);
+    }
+
+    try {
+      Cache cache = context.getCache();
+      ((InternalCache) cache).getService(QueryConfigurationService.class)
+          .updateMethodAuthorizer(cache, forceUpdate, authorizerName, parameterSet);
+    } catch (Exception ex) {
+      return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.ERROR,
+          ex.getMessage());
+    }
+
+    String message = AUTHORIZER_UPDATED_MESSAGE + authorizerName + (parameterSet.size() > 0
+        ? AUTHORIZER_PARAMETERS_MESSAGE + String.join(", ", parameterSet) : "");
+    return new CliFunctionResult(context.getMemberName(), CliFunctionResult.StatusState.OK,
+        message);
+  }

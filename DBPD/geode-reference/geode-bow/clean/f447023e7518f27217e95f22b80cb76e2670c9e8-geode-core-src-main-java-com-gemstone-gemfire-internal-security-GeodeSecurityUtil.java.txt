GEODE-17: used new security interface for integrated security.

* Create new interface for integrated security
* separate jmx and cli from client-server security
* client-server security using integrated security

-import com.gemstone.gemfire.cache.operations.OperationContext;
-import com.gemstone.gemfire.cache.operations.OperationContext.OperationCode;
-import com.gemstone.gemfire.cache.operations.OperationContext.Resource;
-import com.gemstone.gemfire.internal.logging.LogService;
-import com.gemstone.gemfire.internal.security.shiro.CustomAuthRealm;
-import com.gemstone.gemfire.internal.security.shiro.ShiroPrincipal;
-import com.gemstone.gemfire.management.internal.security.ResourceOperation;
-import com.gemstone.gemfire.management.internal.security.ResourceOperationContext;
-import com.gemstone.gemfire.security.AuthenticationFailedException;
-import com.gemstone.gemfire.security.GemFireSecurityException;
-import com.gemstone.gemfire.security.NotAuthorizedException;
+import static com.gemstone.gemfire.distributed.ConfigurationProperties.*;
+
+import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.util.Properties;
+import java.util.Set;
+import java.util.concurrent.Callable;
+
+import org.apache.shiro.subject.support.SubjectThreadState;
+import org.apache.shiro.util.ThreadState;
-import java.security.AccessController;
-import java.util.Properties;
-import java.util.Set;
-import java.util.concurrent.Callable;
-
-import static com.gemstone.gemfire.distributed.ConfigurationProperties.*;
+import com.gemstone.gemfire.internal.ClassLoadUtil;
+import com.gemstone.gemfire.internal.logging.LogService;
+import com.gemstone.gemfire.internal.security.shiro.CustomAuthRealm;
+import com.gemstone.gemfire.internal.security.shiro.ShiroPrincipal;
+import com.gemstone.gemfire.management.internal.security.ResourceOperation;
+import com.gemstone.gemfire.security.AuthenticationFailedException;
+import com.gemstone.gemfire.security.AuthenticationRequiredException;
+import com.gemstone.gemfire.security.ExternalSecurity;
+import com.gemstone.gemfire.security.GemFireSecurityException;
+import com.gemstone.gemfire.security.GeodePermission;
+import com.gemstone.gemfire.security.GeodePermission.Operation;
+import com.gemstone.gemfire.security.GeodePermission.Resource;
+import com.gemstone.gemfire.security.NotAuthorizedException;
-   *
-  public static Subject getSubject(){
-    if(!isSecured())
+  public static Subject getSubject() {
+    if (!isSecured()) {
+    }
-    if(jmxSubject!=null){
+    if (jmxSubject != null) {
-      if(principals.size()>0){
+      if (principals.size() > 0) {
-    if(currentUser==null || currentUser.getPrincipal()==null){
+    if (currentUser == null || currentUser.getPrincipal() == null) {
-   *
-  public static Subject login(String username, String password){
-    if(!isSecured())
+  public static Subject login(String username, String password) {
+    if (!isSecured()) {
+    }
-      logger.info("Logging in "+username);
+      logger.info("Logging in " + username);
-    } catch (ShiroException e) {
+    }
+    catch (ShiroException e) {
-  public static void logout(){
+  public static void logout() {
-    if(currentUser==null)
+    if (currentUser == null) {
+    }
-      logger.info("Logging out "+currentUser.getPrincipal());
+      logger.info("Logging out " + currentUser.getPrincipal());
-    catch(ShiroException e){
+    catch (ShiroException e) {
-  public static Callable associateWith(Callable callable){
+  public static Callable associateWith(Callable callable) {
-    if(currentUser==null)
+    if (currentUser == null) {
+    }
+  /**
+   * this binds the passed-in subject to the executing thread, normally, you would do this:
+   * ThreadState state = null;
+   * try{
+   *   state = GeodeSecurityUtil.bindSubject(subject);
+   *   //do the rest of the work as this subject
+   * }
+   * finally{
+   *   if(state!=null)
+   *      state.clear();
+   * }
+   *
+   * @param subject
+   * @return
+   */
+  public static ThreadState bindSubject(Subject subject){
+    if (subject == null) {
+      return null;
+    }
+
+    ThreadState threadState = new SubjectThreadState(subject);
+    threadState.bind();
+    return threadState;
+  }
+
-    if(resourceOperation==null)
+    if (resourceOperation == null) {
+    }
-  public static void authorizeClusterManage(){
+  public static void authorizeClusterManage() {
-  public static void authorizeClusterWrite(){
+  public static void authorizeClusterWrite() {
-  public static void authorizeClusterRead(){
+  public static void authorizeClusterRead() {
-  public static void authorizeDataManage(){
+  public static void authorizeDataManage() {
-  public static void authorizeDataWrite(){
+  public static void authorizeDataWrite() {
-  public static void authorizeDataRead(){
+  public static void authorizeDataRead() {
-  public static void authorizeRegionManage(String regionName){
+  public static void authorizeRegionManage(String regionName) {
-  public static void authorizeRegionWrite(String regionName){
+  public static void authorizeRegionWrite(String regionName) {
-  public static void authorizeRegionRead(String regionName){
+  public static void authorizeRegionRead(String regionName) {
-  public static void authorize(String resource, String operation){
+  public static void authorize(String resource, String operation) {
-  private static void authorize(String resource, String operation, String regionName){
+  private static void authorize(String resource, String operation, String regionName) {
-    authorize(new ResourceOperationContext(resource, operation, regionName));
+    authorize(new GeodePermission(resource, operation, regionName));
-  public static void authorize(OperationContext context) {
-    if(context==null)
-      return;
-
-    if(context.getResource()== Resource.NULL && context.getOperationCode()== OperationCode.NULL)
-      return;
-
+  public static void authorize(GeodePermission context) {
-    if(currentUser==null)
+    if (currentUser == null) {
+    }
+
+    if (context == null) {
+      return;
+    }
+
+    if (context.getResource() == Resource.NULL && context.getOperation() == Operation.NULL) {
+      return;
+    }
-    catch(ShiroException e){
+    catch (ShiroException e) {
-  private static boolean isSecured(){
-    try{
+  private static boolean isSecured() {
+    try {
-    catch(UnavailableSecurityManagerException e){
+    catch (UnavailableSecurityManagerException e) {
-  public static void initSecurity(Properties securityProps){
-    if(securityProps==null)
+  public static void initSecurity(Properties securityProps) {
+    if (securityProps == null) {
+    }
-    String customAuthenticator =securityProps.getProperty(SECURITY_CLIENT_AUTHENTICATOR);
+    String customAuthenticator = securityProps.getProperty(SECURITY_CLIENT_AUTHENTICATOR);
+
+    Object auth = getAuthenticatorObject(customAuthenticator);
+
-      IniSecurityManagerFactory factory = new IniSecurityManagerFactory("classpath:"+shiroConfig);
+      IniSecurityManagerFactory factory = new IniSecurityManagerFactory("classpath:" + shiroConfig);
-      if(!main.containsKey("iniRealm.permissionResolver")) {
+      if (!main.containsKey("iniRealm.permissionResolver")) {
-    else if (!com.gemstone.gemfire.internal.lang.StringUtils.isBlank(customAuthenticator)) {
-      Realm realm = new CustomAuthRealm(securityProps);
+    // only set up shiro realm if user has implemented ExternalSecurity
+    else if (auth != null && auth instanceof ExternalSecurity) {
+      ExternalSecurity externalSecurity = (ExternalSecurity) auth;
+      externalSecurity.init(securityProps);
+      Realm realm = new CustomAuthRealm(externalSecurity);
-    else{
+    else {
+  public static Object getAuthenticatorObject(String authenticatorFactoryName) {
+    if (StringUtils.isBlank(authenticatorFactoryName)) {
+      return null;
+    }
+
+    try {
+      Method instanceGetter = ClassLoadUtil.methodFromName(authenticatorFactoryName);
+      return instanceGetter.invoke(null, (Object[]) null);
+    }
+    catch (Exception ex) {
+      throw new AuthenticationRequiredException(ex.toString(), ex);
+    }
+  }
+
+  public static boolean isIntegratedSecurity(String authenticatorFactoryName) {
+    Object auth = getAuthenticatorObject(authenticatorFactoryName);
+    return (auth instanceof ExternalSecurity);
+  }
+

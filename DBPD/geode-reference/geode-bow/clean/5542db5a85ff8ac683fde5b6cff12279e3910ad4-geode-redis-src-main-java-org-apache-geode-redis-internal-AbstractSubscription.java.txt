GEODE-7998: Do not block Netty threads when publishing (#5042)

- Now delegate PUBLISH responses to a background executor in order to
  free up the Netty worker thread. This prevents possible deadlocks.

Co-authored-by: Murtuza Boxwala <mboxwala@vmware.com>
Co-authored-by: Ray Ingles <ringles@vmware.com>
Co-authored-by: Jens Deppe <jdeppe@vmware.com>

-import java.nio.channels.ClosedChannelException;
-import java.util.concurrent.ExecutionException;
-
-import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
-  public PublishResult publishMessage(String channel, byte[] message) {
+  public void publishMessage(String channel, byte[] message,
+      PublishResultCollector publishResultCollector) {
-    if (messageByteBuffer == null) {
-      return new PublishResult(client, false);
-    }
-
-    return new PublishResult(client, writeToChannelSynchronously(messageByteBuffer));
+    writeToChannel(messageByteBuffer, publishResultCollector);
-  private boolean writeToChannelSynchronously(ByteBuf messageByteBuffer) {
-    ChannelFuture channelFuture = context.writeToChannel(messageByteBuffer);
-
-    try {
-      channelFuture.get();
-    } catch (ExecutionException e) {
-      if (e.getCause() instanceof ClosedChannelException) {
-        logger.warn("Unable to write to channel: {}", e.getMessage());
-      } else {
-        logger.warn("Unable to write to channel", e);
-      }
-      return false;
-    } catch (InterruptedException e) {
-      logger.warn("Unable to write to channel", e);
-      return false;
-    }
-
-    return channelFuture.cause() == null;
+  private void writeToChannel(ByteBuf messageByteBuffer, PublishResultCollector resultCollector) {
+    context.writeToChannel(messageByteBuffer)
+        .addListener((ChannelFutureListener) future -> {
+          if (future.cause() == null) {
+            resultCollector.success();
+          } else {
+            resultCollector.failure(client);
+          }
+        });

Merge branch 'release/1.8.0'

-import org.apache.geode.cache.CacheClosedException;
-import org.apache.geode.i18n.StringId;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+import org.apache.geode.internal.logging.LoggingThread;
-  public static final StringId TIMEOUT_MSG =
-      LocalizedStrings.PRHARedundancyProvider_IF_YOUR_SYSTEM_HAS_SUFFICIENT_SPACE_PERHAPS_IT_IS_UNDER_MEMBERSHIP_OR_REGION_CREATION_STRESS;
+  public static final String TIMEOUT_MSG =
+      "If your system has sufficient space, perhaps it is under membership or region creation stress?";
-        LocalizedStrings.PRHARedundancyProvider_TIMED_OUT_ATTEMPTING_TO_0_IN_THE_PARTITIONED_REGION__1_WAITED_FOR_2_MS
-            .toLocalizedString(new Object[] {opString,
+        String.format("Timed out attempting to %s in the partitioned region.%sWaited for: %s ms.",
+            new Object[] {opString,
-  public static final StringId INSUFFICIENT_STORES_MSG =
-      LocalizedStrings.PRHARedundancyProvider_CONSIDER_STARTING_ANOTHER_MEMBER;
+  public static final String INSUFFICIENT_STORES_MSG =
+      "Advise you to start enough data store nodes";
-  public static final StringId SUFFICIENT_STORES_MSG =
-      LocalizedStrings.PRHARRedundancyProvider_FOUND_A_MEMBER_TO_HOST_A_BUCKET;
+  public static final String SUFFICIENT_STORES_MSG =
+      "Found a member to host a bucket.";
-  private static final StringId ALLOCATE_ENOUGH_MEMBERS_TO_HOST_BUCKET =
-      LocalizedStrings.PRHARRedundancyProvider_ALLOCATE_ENOUGH_MEMBERS_TO_HOST_BUCKET;
+  private static final String ALLOCATE_ENOUGH_MEMBERS_TO_HOST_BUCKET =
+      "allocate enough members to host a new bucket";
-    final StringId notEnoughValidNodes;
+    final String notEnoughValidNodes;
-          LocalizedStrings.PRHARRedundancyProvider_UNABLE_TO_FIND_ANY_MEMBERS_TO_HOST_A_BUCKET_IN_THE_PARTITIONED_REGION_0;
+          "Unable to find any members to host a bucket in the partitioned region. %s.%s";
-          LocalizedStrings.PRHARRedundancyProvider_CONFIGURED_REDUNDANCY_LEVEL_COULD_NOT_BE_SATISFIED_0;
+          "Configured redundancy level could not be satisfied. %s to satisfy redundancy for the region.%s";
-      logger.warn(LocalizedMessage.create(notEnoughValidNodes, notEnoughValidNodesArgs));
+      logger.warn(String.format(notEnoughValidNodes, notEnoughValidNodesArgs));
-          notEnoughValidNodes.toLocalizedString(notEnoughValidNodesArgs));
+          String.format(notEnoughValidNodes, notEnoughValidNodesArgs));
-                ALLOCATE_ENOUGH_MEMBERS_TO_HOST_BUCKET.toLocalizedString(), computeTimeout());
+                ALLOCATE_ENOUGH_MEMBERS_TO_HOST_BUCKET, computeTimeout());
-                logger.warn(LocalizedMessage.create(
-                    LocalizedStrings.GemFireCache_ENFORCE_UNIQUE_HOST_NOT_APPLICABLE_FOR_LONER));
+                logger.warn(
+                    "enforce-unique-host and redundancy-zone properties have no effect for a LonerDistributedSystem.");
-            if (e instanceof CancelException || e instanceof CacheClosedException
+            if (e instanceof CancelException
-        final StringId logStr =
-            LocalizedStrings.PRHARRedundancyProvider_0_IN_THE_PARTITIONED_REGION_REGION_NAME_1;
+        final String logStr = "{} Region name, {}";
-            new Object[] {SUFFICIENT_STORES_MSG.toLocalizedString(), prRegion.getFullPath()};
+            new Object[] {SUFFICIENT_STORES_MSG, prRegion.getFullPath()};
-          logger.fatal(LocalizedMessage.create(logStr, logArgs));
+          logger.fatal(logStr, logArgs);
-          logger.info(LocalizedMessage.create(logStr, logArgs));
+          logger.info(logStr, logArgs);
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.PRHARedundancyProvider_EXCEPTION_CREATING_PARTITION_ON__0,
-              targetNMember), e);
+          logger.warn("Exception creating partition on " +
+              targetNMember,
+              e);
-          logger.warn(LocalizedMessage.create(
-              LocalizedStrings.PRHARedundancyProvider_EXCEPTION_CREATING_PARTITION_ON__0,
-              targetNMember), e);
+          logger.warn("Exception creating partition on " +
+              targetNMember,
+              e);
-          logger.error(
-              LocalizedMessage.create(
-                  LocalizedStrings.PRHARedundancyProvider_UNEXPECTED_EXCEPTION_DURING_BUCKET_RECOVERY),
+          logger.error("Unexpected exception during bucket recovery",
-        Thread loggingThread = new Thread(this.redundancyLogger,
-            "RedundancyLogger for region " + this.prRegion.getName());
+        Thread loggingThread = new LoggingThread(
+            "RedundancyLogger for region " + this.prRegion.getName(), false, this.redundancyLogger);
-            new Thread(recoveryRunnable, "Recovery thread for bucket " + proxyBucket.getName());
+            new LoggingThread("Recovery thread for bucket " + proxyBucket.getName(),
+                false, recoveryRunnable);
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.PRHARedundancyProvider_TIME_OUT_WAITING_0_MS_FOR_CREATION_OF_BUCKET_FOR_PARTITIONED_REGION_1_MEMBERS_REQUESTED_TO_CREATE_THE_BUCKET_ARE_2,
+            logger.warn(
+                "Time out waiting {} ms for creation of bucket for partitioned region {}. Members requested to create the bucket are: {}",
-                    expectedOwners}));
+                    expectedOwners});

Merge branch 'release/1.0.0-incubating.M3'

+import static com.gemstone.gemfire.distributed.ConfigurationProperties.*;
+
+import java.lang.reflect.Method;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.StringTokenizer;
+
-import java.lang.reflect.Method;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.*;
-
-
-  @ConfigAttributeChecker(name=START_LOCATOR_NAME)
+  @ConfigAttributeChecker(name = START_LOCATOR)
-
-  @ConfigAttributeChecker(name=TCP_PORT_NAME)
+  @ConfigAttributeChecker(name = TCP_PORT)
-      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_0_WHEN_2_IS_TRUE.toLocalizedString(new Object[] {TCP_PORT_NAME, Integer.valueOf(value), SSL_ENABLED_NAME}));
+      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_0_WHEN_2_IS_TRUE
+          .toLocalizedString(new Object[] { TCP_PORT, Integer.valueOf(value), SSL_ENABLED }));
-      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_0_WHEN_2_IS_TRUE.toLocalizedString(new Object[] {TCP_PORT_NAME, Integer.valueOf(value), CLUSTER_SSL_ENABLED_NAME}));
+      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_0_WHEN_2_IS_TRUE
+          .toLocalizedString(new Object[] { TCP_PORT, Integer.valueOf(value), CLUSTER_SSL_ENABLED }));
-  @ConfigAttributeChecker(name=MCAST_PORT_NAME)
+  @ConfigAttributeChecker(name = MCAST_PORT)
-      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_0_WHEN_2_IS_TRUE.toLocalizedString(new Object[] {MCAST_PORT_NAME, Integer.valueOf(value), SSL_ENABLED_NAME}));
+      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_0_WHEN_2_IS_TRUE
+          .toLocalizedString(new Object[] { MCAST_PORT, Integer.valueOf(value), SSL_ENABLED }));
-      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_0_WHEN_2_IS_TRUE.toLocalizedString(new Object[] {MCAST_PORT_NAME, Integer.valueOf(value), CLUSTER_SSL_ENABLED_NAME}));
+      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_0_WHEN_2_IS_TRUE
+          .toLocalizedString(new Object[] { MCAST_PORT, Integer.valueOf(value), CLUSTER_SSL_ENABLED }));
-
-  @ConfigAttributeChecker(name=MCAST_ADDRESS_NAME)
+  @ConfigAttributeChecker(name = MCAST_ADDRESS)
-      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_IT_WAS_NOT_A_MULTICAST_ADDRESS.toLocalizedString(new Object[] {MCAST_ADDRESS_NAME, value}));
+      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_IT_WAS_NOT_A_MULTICAST_ADDRESS
+          .toLocalizedString(new Object[] { MCAST_ADDRESS, value }));
-  @ConfigAttributeChecker(name=BIND_ADDRESS_NAME)
+  @ConfigAttributeChecker(name = BIND_ADDRESS)
-
-  @ConfigAttributeChecker(name=SERVER_BIND_ADDRESS_NAME)
+  @ConfigAttributeChecker(name = SERVER_BIND_ADDRESS)
-  @ConfigAttributeChecker(name=SSL_ENABLED_NAME)
+  @ConfigAttributeChecker(name=SSL_ENABLED)
-      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_FALSE_WHEN_2_IS_NOT_0.toLocalizedString(new Object[] {SSL_ENABLED_NAME, value, MCAST_PORT_NAME}));
+      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_FALSE_WHEN_2_IS_NOT_0
+          .toLocalizedString(new Object[] { SSL_ENABLED, value, MCAST_PORT }));
-  @ConfigAttributeChecker(name=CLUSTER_SSL_ENABLED_NAME)
+  @ConfigAttributeChecker(name=CLUSTER_SSL_ENABLED)
-      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_FALSE_WHEN_2_IS_NOT_0.toLocalizedString(new Object[] {CLUSTER_SSL_ENABLED_NAME, value, MCAST_PORT_NAME}));
+      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_MUST_BE_FALSE_WHEN_2_IS_NOT_0
+          .toLocalizedString(new Object[] { CLUSTER_SSL_ENABLED, value, MCAST_PORT }));
-  @ConfigAttributeChecker(name=HTTP_SERVICE_BIND_ADDRESS_NAME)
+  @ConfigAttributeChecker(name=HTTP_SERVICE_BIND_ADDRESS)
-  @ConfigAttributeChecker(name=DISTRIBUTED_SYSTEM_ID_NAME)
+  @ConfigAttributeChecker(name=DISTRIBUTED_SYSTEM_ID)
-    .getProperty("gemfire.DistributedSystemListener");
+        .getProperty(DistributionConfig.GEMFIRE_PREFIX + "DistributedSystemListener");
-                .toLocalizedString(new Object[] { DISTRIBUTED_SYSTEM_ID_NAME,
+                .toLocalizedString(new Object[] { DISTRIBUTED_SYSTEM_ID,
-      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2.toLocalizedString(new Object[] {DISTRIBUTED_SYSTEM_ID_NAME, Integer.valueOf(value), Integer.valueOf(MAX_DISTRIBUTED_SYSTEM_ID)}));
+      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2.toLocalizedString(new Object[] {DISTRIBUTED_SYSTEM_ID, Integer.valueOf(value), Integer.valueOf(MAX_DISTRIBUTED_SYSTEM_ID)}));
-  @ConfigAttributeChecker(name=LOCATORS_NAME)
+  @ConfigAttributeChecker(name = LOCATORS)
-        if (portVal < 1 || portVal > 65535) {
+        if(0 == portVal){
+          return "";
+        }
+        else if (portVal < 1 || portVal > 65535) {
-  @ConfigAttributeChecker(name=MCAST_FLOW_CONTROL_NAME)
+  @ConfigAttributeChecker(name=MCAST_FLOW_CONTROL)
-      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_BYTEALLOWANCE_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2.toLocalizedString(new Object[] {MCAST_FLOW_CONTROL_NAME, Integer.valueOf(value), Integer.valueOf(MIN_FC_BYTE_ALLOWANCE)}));
+      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_BYTEALLOWANCE_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2.toLocalizedString(new Object[] {MCAST_FLOW_CONTROL, Integer.valueOf(value), Integer.valueOf(MIN_FC_BYTE_ALLOWANCE)}));
-      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGETHRESHOLD_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2.toLocalizedString(new Object[] {MCAST_FLOW_CONTROL_NAME, new Float(fvalue), new Float(MIN_FC_RECHARGE_THRESHOLD)}));
+      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGETHRESHOLD_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2.toLocalizedString(new Object[] {MCAST_FLOW_CONTROL, new Float(fvalue), new Float(MIN_FC_RECHARGE_THRESHOLD)}));
-      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGETHRESHOLD_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2.toLocalizedString(new Object[] {MCAST_FLOW_CONTROL_NAME, new Float(fvalue), new Float(MAX_FC_RECHARGE_THRESHOLD)}));
+      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGETHRESHOLD_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2.toLocalizedString(new Object[] {MCAST_FLOW_CONTROL, new Float(fvalue), new Float(MAX_FC_RECHARGE_THRESHOLD)}));
-      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGEBLOCKMS_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2.toLocalizedString(new Object[] {MCAST_FLOW_CONTROL_NAME, Integer.valueOf(value), Integer.valueOf(MIN_FC_RECHARGE_BLOCK_MS)}));
+      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGEBLOCKMS_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_LESS_THAN_2.toLocalizedString(new Object[] {MCAST_FLOW_CONTROL, Integer.valueOf(value), Integer.valueOf(MIN_FC_RECHARGE_BLOCK_MS)}));
-      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGEBLOCKMS_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2.toLocalizedString(new Object[] {MCAST_FLOW_CONTROL_NAME, Integer.valueOf(value), Integer.valueOf(MAX_FC_RECHARGE_BLOCK_MS)}));
+      throw new IllegalArgumentException(LocalizedStrings.AbstractDistributionConfig_COULD_NOT_SET_0_RECHARGEBLOCKMS_TO_1_BECAUSE_ITS_VALUE_CAN_NOT_BE_GREATER_THAN_2.toLocalizedString(new Object[] {MCAST_FLOW_CONTROL, Integer.valueOf(value), Integer.valueOf(MAX_FC_RECHARGE_BLOCK_MS)}));
-  @ConfigAttributeChecker(name=MEMBERSHIP_PORT_RANGE_NAME)
+  @ConfigAttributeChecker(name=MEMBERSHIP_PORT_RANGE)
-    minMaxCheck(MEMBERSHIP_PORT_RANGE_NAME, value[0],
+    minMaxCheck(MEMBERSHIP_PORT_RANGE, value[0],
-    minMaxCheck(MEMBERSHIP_PORT_RANGE_NAME, value[1],
+    minMaxCheck(MEMBERSHIP_PORT_RANGE, value[1],
-          toLocalizedString(new Object[] {MEMBERSHIP_PORT_RANGE_NAME, value[0]+"-"+value[1], Integer.valueOf(3)}));
+          toLocalizedString(new Object[] {MEMBERSHIP_PORT_RANGE, value[0]+"-"+value[1], Integer.valueOf(3)}));
-  /** @since 5.7 */
+  /** @since GemFire 5.7 */
-      throw new IllegalArgumentException("Could not set \"" + CLIENT_CONFLATION_PROP_NAME + "\" to \"" + value + "\" because its value is not recognized");
+      throw new IllegalArgumentException("Could not set \"" + CONFLATE_EVENTS + "\" to \"" + value + "\" because its value is not recognized");
-  @ConfigAttributeChecker(name=SECURITY_PEER_AUTH_INIT_NAME)
+  @ConfigAttributeChecker(name=SECURITY_PEER_AUTH_INIT)
-      String mcastInfo = MCAST_PORT_NAME + "[" + getMcastPort() + "]";
+      String mcastInfo = MCAST_PORT + "[" + getMcastPort() + "]";
-             SECURITY_PEER_AUTH_INIT_NAME, value, mcastInfo }));
+             SECURITY_PEER_AUTH_INIT, value, mcastInfo }));
-  @ConfigAttributeChecker(name=SECURITY_PEER_AUTHENTICATOR_NAME)
+  @ConfigAttributeChecker(name=SECURITY_PEER_AUTHENTICATOR)
-       String mcastInfo = MCAST_PORT_NAME + "[" + getMcastPort() + "]";
+      String mcastInfo = MCAST_PORT + "[" + getMcastPort() + "]";
-            SECURITY_PEER_AUTHENTICATOR_NAME,
+            SECURITY_PEER_AUTHENTICATOR,
-  @ConfigAttributeChecker(name=SECURITY_LOG_LEVEL_NAME)
+  @ConfigAttributeChecker(name=SECURITY_LOG_LEVEL)
-              SECURITY_LOG_LEVEL_NAME,
+              SECURITY_LOG_LEVEL,
-            SECURITY_LOG_LEVEL_NAME,
+            SECURITY_LOG_LEVEL,
-  @ConfigAttributeChecker(name=MEMCACHED_PROTOCOL_NAME)
+  @ConfigAttributeChecker(name=MEMCACHED_PROTOCOL)
-  @ConfigAttributeChecker(name=MEMCACHED_BIND_ADDRESS_NAME)
+  @ConfigAttributeChecker(name=MEMCACHED_BIND_ADDRESS)
-  @ConfigAttributeChecker(name=REDIS_BIND_ADDRESS_NAME)
+  @ConfigAttributeChecker(name=REDIS_BIND_ADDRESS)
-    if(!attName.startsWith(SECURITY_PREFIX_NAME) && !attName.startsWith(USERDEFINED_PREFIX_NAME)
+    if(!attName.startsWith(SECURITY_PREFIX) && !attName.startsWith(USERDEFINED_PREFIX_NAME)
-    if(attName.equalsIgnoreCase(LOG_LEVEL_NAME) || attName.equalsIgnoreCase(SECURITY_LOG_LEVEL_NAME)){
-      attValue = LogWriterImpl.levelNameToCode((String)attValue);
+    if(attName.equalsIgnoreCase(LOG_LEVEL) || attName.equalsIgnoreCase(SECURITY_LOG_LEVEL)){
+      if(attValue instanceof String) {
+        attValue = LogWriterImpl.levelNameToCode((String) attValue);
+      }
+    }
+
+    if (attName.startsWith(SECURITY_PREFIX)) {
+      this.setSecurity(attName,attValue.toString());
+    }
+
+    if (attName.startsWith(SSL_SYSTEM_PROPS_NAME) || attName.startsWith(SYS_PROP_NAME)) {
+      this.setSSLProperty(attName, attValue.toString());
-      // if we cann't find the defined setter, look for two more special cases
-      if (attName.startsWith(SECURITY_PREFIX_NAME)) {
-        this.setSecurity(attName,(String)attValue);
-        getAttSourceMap().put(attName, source);
-        return;
-      }
-      if (attName.startsWith(SSL_SYSTEM_PROPS_NAME) || attName.startsWith(SYS_PROP_NAME)) {
-        this.setSSLProperty(attName, (String) attValue);
+      // if we cann't find the defined setter, but the attributeName starts with these special characters
+      // since we already set it in the respecitive properties above, we need to set the source then return
+      if (attName.startsWith(SECURITY_PREFIX) ||
+        attName.startsWith(SSL_SYSTEM_PROPS_NAME) ||
+        attName.startsWith(SYS_PROP_NAME)) {
-    if (attName.equalsIgnoreCase(LOG_LEVEL_NAME)) {
+    if (attName.equalsIgnoreCase(LOG_LEVEL)) {
-    if (attName.equalsIgnoreCase(SECURITY_LOG_LEVEL_NAME)) {
+    if (attName.equalsIgnoreCase(SECURITY_LOG_LEVEL)) {
-      if (attName.startsWith(SECURITY_PREFIX_NAME)) {
+      if (attName.startsWith(SECURITY_PREFIX)) {
-    String[] modifiables = {HTTP_SERVICE_PORT_NAME,JMX_MANAGER_HTTP_PORT_NAME};
+    String[] modifiables = {HTTP_SERVICE_PORT,JMX_MANAGER_HTTP_PORT};
-      if(attName.startsWith(SECURITY_PREFIX_NAME) || attName.startsWith(SSL_SYSTEM_PROPS_NAME) || attName.startsWith(SYS_PROP_NAME) ){
+      if(attName.startsWith(SECURITY_PREFIX) || attName.startsWith(SSL_SYSTEM_PROPS_NAME) || attName.startsWith(SYS_PROP_NAME) ){
-    m.put(ACK_WAIT_THRESHOLD_NAME, 
+    m.put(ACK_WAIT_THRESHOLD,
-    m.put(ARCHIVE_FILE_SIZE_LIMIT_NAME, 
+    m.put(ARCHIVE_FILE_SIZE_LIMIT,
-    m.put(ACK_SEVERE_ALERT_THRESHOLD_NAME, 
+    m.put(ACK_SEVERE_ALERT_THRESHOLD,
-           new Object[] { ACK_WAIT_THRESHOLD_NAME, 
+           new Object[] { ACK_WAIT_THRESHOLD,
-    m.put(ARCHIVE_DISK_SPACE_LIMIT_NAME,
+    m.put(ARCHIVE_DISK_SPACE_LIMIT,
-    m.put(CACHE_XML_FILE_NAME, 
+    m.put(CACHE_XML_FILE,
-    m.put(DISABLE_TCP_NAME, 
+    m.put(DISABLE_TCP,
-    m.put(ENABLE_TIME_STATISTICS_NAME, 
+    m.put(ENABLE_TIME_STATISTICS,
-    m.put(DEPLOY_WORKING_DIR, 
+    m.put(DEPLOY_WORKING_DIR,
-    m.put(LOG_FILE_NAME, 
+    m.put(LOG_FILE,
-    m.put(LOG_LEVEL_NAME,
+    m.put(LOG_LEVEL,
-    m.put(LOG_FILE_SIZE_LIMIT_NAME,
+    m.put(LOG_FILE_SIZE_LIMIT,
-    m.put(LOG_DISK_SPACE_LIMIT_NAME, 
+    m.put(LOG_DISK_SPACE_LIMIT,
-    m.put(LOCATORS_NAME, 
+    m.put(LOCATORS,
-    
-    m.put(LOCATOR_WAIT_TIME_NAME,
+
+    m.put(LOCATOR_WAIT_TIME,
-    m.put(TCP_PORT_NAME, 
+    m.put(TCP_PORT,
-    m.put(MCAST_PORT_NAME, 
+    m.put(MCAST_PORT,
-    m.put(MCAST_ADDRESS_NAME, 
+    m.put(MCAST_ADDRESS,
-    m.put(MCAST_TTL_NAME, 
+    m.put(MCAST_TTL,
-    m.put(MCAST_SEND_BUFFER_SIZE_NAME, 
+    m.put(MCAST_SEND_BUFFER_SIZE,
-    m.put(MCAST_RECV_BUFFER_SIZE_NAME, 
+    m.put(MCAST_RECV_BUFFER_SIZE,
-    m.put(MCAST_FLOW_CONTROL_NAME, 
+    m.put(MCAST_FLOW_CONTROL,
-    m.put(MEMBER_TIMEOUT_NAME, 
-      LocalizedStrings.AbstractDistributionConfig_MEMBER_TIMEOUT_NAME_0
+    m.put(MEMBER_TIMEOUT,
+        LocalizedStrings.AbstractDistributionConfig_MEMBER_TIMEOUT_NAME_0
-    m.put(MEMBERSHIP_PORT_RANGE_NAME,
+    m.put(MEMBERSHIP_PORT_RANGE,
-    m.put(UDP_SEND_BUFFER_SIZE_NAME, 
+    m.put(UDP_SEND_BUFFER_SIZE,
-    m.put(UDP_RECV_BUFFER_SIZE_NAME, 
+    m.put(UDP_RECV_BUFFER_SIZE,
-    m.put(UDP_FRAGMENT_SIZE_NAME, 
+    m.put(UDP_FRAGMENT_SIZE,
-    m.put(SOCKET_LEASE_TIME_NAME, 
+    m.put(SOCKET_LEASE_TIME,
-    m.put(SOCKET_BUFFER_SIZE_NAME, 
+    m.put(SOCKET_BUFFER_SIZE,
-    m.put(CONSERVE_SOCKETS_NAME, 
+    m.put(CONSERVE_SOCKETS,
-    m.put(ROLES_NAME,
+    m.put(ROLES,
-    m.put(BIND_ADDRESS_NAME, 
+    m.put(BIND_ADDRESS,
-    m.put(SERVER_BIND_ADDRESS_NAME, 
+    m.put(SERVER_BIND_ADDRESS,
-    m.put(NAME_NAME, "A name that uniquely identifies a member in its distributed system." +
+    m.put(NAME, "A name that uniquely identifies a member in its distributed system." +
-    m.put(STATISTIC_ARCHIVE_FILE_NAME, 
+    m.put(STATISTIC_ARCHIVE_FILE,
-    m.put(STATISTIC_SAMPLE_RATE_NAME, 
+    m.put(STATISTIC_SAMPLE_RATE,
-    m.put(STATISTIC_SAMPLING_ENABLED_NAME, 
+    m.put(STATISTIC_SAMPLING_ENABLED,
-    m.put(SSL_ENABLED_NAME, 
+    m.put(SSL_ENABLED,
-    m.put(SSL_PROTOCOLS_NAME, 
+    m.put(SSL_PROTOCOLS,
-    m.put(SSL_CIPHERS_NAME, 
+    m.put(SSL_CIPHERS,
-    m.put(SSL_REQUIRE_AUTHENTICATION_NAME, 
+    m.put(SSL_REQUIRE_AUTHENTICATION,
-    m.put(CLUSTER_SSL_ENABLED_NAME, 
+    m.put(CLUSTER_SSL_ENABLED,
-    m.put(CLUSTER_SSL_PROTOCOLS_NAME, 
+    m.put(CLUSTER_SSL_PROTOCOLS,
-    m.put(CLUSTER_SSL_CIPHERS_NAME, 
+    m.put(CLUSTER_SSL_CIPHERS,
-    m.put(CLUSTER_SSL_REQUIRE_AUTHENTICATION_NAME, 
+    m.put(CLUSTER_SSL_REQUIRE_AUTHENTICATION,
-    m.put(CLUSTER_SSL_KEYSTORE_NAME,"Location of the Java keystore file containing an distributed member's own certificate and private key.");
+    m.put(CLUSTER_SSL_KEYSTORE,"Location of the Java keystore file containing an distributed member's own certificate and private key.");
-    m.put(CLUSTER_SSL_KEYSTORE_TYPE_NAME, 
+    m.put(CLUSTER_SSL_KEYSTORE_TYPE,
-    m.put(CLUSTER_SSL_KEYSTORE_PASSWORD_NAME,"Password to access the private key from the keystore file specified by javax.net.ssl.keyStore.");
+    m.put(CLUSTER_SSL_KEYSTORE_PASSWORD,"Password to access the private key from the keystore file specified by javax.net.ssl.keyStore.");
-    m.put(CLUSTER_SSL_TRUSTSTORE_NAME,"Location of the Java keystore file containing the collection of CA certificates trusted by distributed member (trust store).");
+    m.put(CLUSTER_SSL_TRUSTSTORE,"Location of the Java keystore file containing the collection of CA certificates trusted by distributed member (trust store).");
-    m.put(CLUSTER_SSL_TRUSTSTORE_PASSWORD_NAME,"Password to unlock the keystore file (store password) specified by  javax.net.ssl.trustStore.");
+    m.put(CLUSTER_SSL_TRUSTSTORE_PASSWORD,"Password to unlock the keystore file (store password) specified by  javax.net.ssl.trustStore.");
-    m.put(MAX_WAIT_TIME_FOR_RECONNECT_NAME, 
+    m.put(MAX_WAIT_TIME_RECONNECT,
-    m.put(MAX_NUM_RECONNECT_TRIES, 
+    m.put(MAX_NUM_RECONNECT_TRIES,
-    m.put(ASYNC_DISTRIBUTION_TIMEOUT_NAME,
+    m.put(ASYNC_DISTRIBUTION_TIMEOUT,
-    m.put(ASYNC_QUEUE_TIMEOUT_NAME,
+    m.put(ASYNC_QUEUE_TIMEOUT,
-    m.put(ASYNC_MAX_QUEUE_SIZE_NAME,
+    m.put(ASYNC_MAX_QUEUE_SIZE,
-          Integer.valueOf(MAX_ASYNC_MAX_QUEUE_SIZE)}));       
+            Integer.valueOf(MAX_ASYNC_MAX_QUEUE_SIZE) }));
-    m.put(START_LOCATOR_NAME, 
+    m.put(START_LOCATOR,
-    m.put(DURABLE_CLIENT_ID_NAME, 
+    m.put(DURABLE_CLIENT_ID,
-    m.put(CLIENT_CONFLATION_PROP_NAME, 
+    m.put(CONFLATE_EVENTS,
-    m.put(DURABLE_CLIENT_TIMEOUT_NAME, 
+    m.put(DURABLE_CLIENT_TIMEOUT,
-    m.put(SECURITY_CLIENT_AUTH_INIT_NAME, 
+    m.put(SECURITY_CLIENT_AUTH_INIT,
-    m.put(ENABLE_NETWORK_PARTITION_DETECTION_NAME, "Whether network partitioning detection is enabled");
+    m.put(ENABLE_NETWORK_PARTITION_DETECTION, "Whether network partitioning detection is enabled");
-    m.put(DISABLE_AUTO_RECONNECT_NAME, "Whether auto reconnect is attempted after a network partition");
+    m.put(DISABLE_AUTO_RECONNECT, "Whether auto reconnect is attempted after a network partition");
-    m.put(SECURITY_CLIENT_AUTHENTICATOR_NAME, 
+    m.put(SECURITY_CLIENT_AUTHENTICATOR,
-    m.put(SECURITY_CLIENT_DHALGO_NAME, 
+    m.put(SECURITY_CLIENT_DHALGO,
-    m.put(SECURITY_PEER_AUTH_INIT_NAME, 
+    m.put(SECURITY_PEER_AUTH_INIT,
-    m.put(SECURITY_PEER_AUTHENTICATOR_NAME, 
+    m.put(SECURITY_PEER_AUTHENTICATOR,
-    m.put(SECURITY_CLIENT_ACCESSOR_NAME,
+    m.put(SECURITY_CLIENT_ACCESSOR,
-    m.put(SECURITY_CLIENT_ACCESSOR_PP_NAME, 
+    m.put(SECURITY_CLIENT_ACCESSOR_PP,
-    m.put(SECURITY_LOG_LEVEL_NAME, 
+    m.put(SECURITY_LOG_LEVEL,
-    m.put(SECURITY_LOG_FILE_NAME, 
+    m.put(SECURITY_LOG_FILE,
-    m.put(SECURITY_PEER_VERIFYMEMBER_TIMEOUT_NAME, 
+    m.put(SECURITY_PEER_VERIFY_MEMBER_TIMEOUT,
-    m.put(SECURITY_PREFIX_NAME,
+    m.put(SECURITY_PREFIX,
-    m.put(REMOVE_UNRESPONSIVE_CLIENT_PROP_NAME, 
+    m.put(REMOVE_UNRESPONSIVE_CLIENT,
-    m.put(DELTA_PROPAGATION_PROP_NAME, "Whether delta propagation is enabled");
+    m.put(DELTA_PROPAGATION, "Whether delta propagation is enabled");
-    m.put(REMOTE_LOCATORS_NAME, 
+    m.put(REMOTE_LOCATORS,
-    m.put(DISTRIBUTED_SYSTEM_ID_NAME, "An id that uniquely idenitifies this distributed system. " +
+    m.put(DISTRIBUTED_SYSTEM_ID, "An id that uniquely idenitifies this distributed system. " +
-    m.put(ENFORCE_UNIQUE_HOST_NAME, "Whether to require partitioned regions to put " +
+    m.put(ENFORCE_UNIQUE_HOST, "Whether to require partitioned regions to put " +
-    m.put(REDUNDANCY_ZONE_NAME, "The zone that this member is in. When this is set, " +
+    m.put(REDUNDANCY_ZONE, "The zone that this member is in. When this is set, " +
-    m.put(GROUPS_NAME, "A comma separated list of all the groups this member belongs to." +
+    m.put(GROUPS, "A comma separated list of all the groups this member belongs to." +
-    m.put(JMX_MANAGER_NAME, "If true then this member is willing to be a jmx manager. Defaults to false except on a locator.");
-    m.put(JMX_MANAGER_START_NAME, "If true then the jmx manager will be started when the cache is created. Defaults to false.");
-    m.put(JMX_MANAGER_SSL_NAME, "If true then the jmx manager will only allow SSL clients to connect. Defaults to false. This property is ignored if jmx-manager-port is \"0\".");
-    m.put(JMX_MANAGER_SSL_ENABLED_NAME, "If true then the jmx manager will only allow SSL clients to connect. Defaults to false. This property is ignored if jmx-manager-port is \"0\".");
-    m.put(JMX_MANAGER_SSL_CIPHERS_NAME, "List of available SSL cipher suites that are to be enabled for JMX Manager. Defaults to \""+DEFAULT_JMX_MANAGER_SSL_CIPHERS+"\" meaning your provider''s defaults.");
-    m.put(JMX_MANAGER_SSL_PROTOCOLS_NAME, "List of available SSL protocols that are to be enabled for JMX Manager. Defaults to \""+DEFAULT_JMX_MANAGER_SSL_PROTOCOLS+"\" meaning defaults of your provider.");
-    m.put(JMX_MANAGER_SSL_REQUIRE_AUTHENTICATION_NAME, "If set to false, ciphers and protocols that permit anonymous JMX Clients are allowed. Defaults to \""+DEFAULT_JMX_MANAGER_SSL_REQUIRE_AUTHENTICATION+"\".");
-    m.put(JMX_MANAGER_SSL_KEYSTORE_NAME,"Location of the Java keystore file containing jmx manager's own certificate and private key.");
-    m.put(JMX_MANAGER_SSL_KEYSTORE_TYPE_NAME, "For Java keystore file format, this property has the value jks (or JKS).");
-    m.put(JMX_MANAGER_SSL_KEYSTORE_PASSWORD_NAME,"Password to access the private key from the keystore file specified by javax.net.ssl.keyStore. ");
-    m.put(JMX_MANAGER_SSL_TRUSTSTORE_NAME,"Location of the Java keystore file containing the collection of CA certificates trusted by jmx manager.");
-    m.put(JMX_MANAGER_SSL_TRUSTSTORE_PASSWORD_NAME,"Password to unlock the keystore file (store password) specified by  javax.net.ssl.trustStore.");
+    m.put(JMX_MANAGER, "If true then this member is willing to be a jmx manager. Defaults to false except on a locator.");
+    m.put(JMX_MANAGER_START, "If true then the jmx manager will be started when the cache is created. Defaults to false.");
+    m.put(JMX_MANAGER_SSL, "If true then the jmx manager will only allow SSL clients to connect. Defaults to false. This property is ignored if jmx-manager-port is \"0\".");
+    m.put(JMX_MANAGER_SSL_ENABLED, "If true then the jmx manager will only allow SSL clients to connect. Defaults to false. This property is ignored if jmx-manager-port is \"0\".");
+    m.put(JMX_MANAGER_SSL_CIPHERS, "List of available SSL cipher suites that are to be enabled for JMX Manager. Defaults to \""+DEFAULT_JMX_MANAGER_SSL_CIPHERS+"\" meaning your provider''s defaults.");
+    m.put(JMX_MANAGER_SSL_PROTOCOLS, "List of available SSL protocols that are to be enabled for JMX Manager. Defaults to \""+DEFAULT_JMX_MANAGER_SSL_PROTOCOLS+"\" meaning defaults of your provider.");
+    m.put(JMX_MANAGER_SSL_REQUIRE_AUTHENTICATION, "If set to false, ciphers and protocols that permit anonymous JMX Clients are allowed. Defaults to \""+DEFAULT_JMX_MANAGER_SSL_REQUIRE_AUTHENTICATION+"\".");
+    m.put(JMX_MANAGER_SSL_KEYSTORE,"Location of the Java keystore file containing jmx manager's own certificate and private key.");
+    m.put(JMX_MANAGER_SSL_KEYSTORE_TYPE, "For Java keystore file format, this property has the value jks (or JKS).");
+    m.put(JMX_MANAGER_SSL_KEYSTORE_PASSWORD,"Password to access the private key from the keystore file specified by javax.net.ssl.keyStore. ");
+    m.put(JMX_MANAGER_SSL_TRUSTSTORE,"Location of the Java keystore file containing the collection of CA certificates trusted by jmx manager.");
+    m.put(JMX_MANAGER_SSL_TRUSTSTORE_PASSWORD,"Password to unlock the keystore file (store password) specified by  javax.net.ssl.trustStore.");
-    m.put(JMX_MANAGER_PORT_NAME, "The port the jmx manager will listen on. Default is \"" + DEFAULT_JMX_MANAGER_PORT + "\". Set to zero to disable GemFire's creation of a jmx listening port.");
-    m.put(JMX_MANAGER_BIND_ADDRESS_NAME, "The address the jmx manager will listen on for remote connections. Default is \"\" which causes the jmx manager to listen on the host's default address. This property is ignored if jmx-manager-port is \"0\".");
-    m.put(JMX_MANAGER_HOSTNAME_FOR_CLIENTS_NAME, "The hostname that will be given to clients when they ask a locator for the location of this jmx manager. Default is \"\" which causes the locator to report the jmx manager's actual ip address as its location. This property is ignored if jmx-manager-port is \"0\".");
-    m.put(JMX_MANAGER_PASSWORD_FILE_NAME, "The name of the file the jmx manager will use to only allow authenticated clients to connect. Default is \"\" which causes the jmx manager to allow all clients to connect. This property is ignored if jmx-manager-port is \"0\".");
-    m.put(JMX_MANAGER_ACCESS_FILE_NAME, "The name of the file the jmx manager will use to define the access level of authenticated clients. Default is \"\" which causes the jmx manager to allow all clients all access. This property is ignored if jmx-manager-port is \"0\".");
-    m.put(JMX_MANAGER_HTTP_PORT_NAME, "By default when a jmx-manager is started it will also start an http server on this port. This server is used by the GemFire Pulse application. Setting this property to zero disables the http server. It defaults to 8080. Ignored if jmx-manager is false.");
-    m.put(JMX_MANAGER_UPDATE_RATE_NAME, "The rate in milliseconds at which this member will send updates to each jmx manager. Default is " + DEFAULT_JMX_MANAGER_UPDATE_RATE + ". Values must be in the range " + MIN_JMX_MANAGER_UPDATE_RATE + ".." + MAX_JMX_MANAGER_UPDATE_RATE + ".");
-    m.put(MEMCACHED_PORT_NAME, "The port GemFireMemcachedServer will listen on. Default is 0. Set to zero to disable GemFireMemcachedServer.");
-    m.put(MEMCACHED_PROTOCOL_NAME, "The protocol that GemFireMemcachedServer understands. Default is ASCII. Values may be ASCII or BINARY");
-    m.put(MEMCACHED_BIND_ADDRESS_NAME, "The address the GemFireMemcachedServer will listen on for remote connections. Default is \"\" which causes the GemFireMemcachedServer to listen on the host's default address. This property is ignored if memcached-port is \"0\".");
-    m.put(REDIS_PORT_NAME, "The port GemFireRedisServer will listen on. Default is 0. Set to zero to disable GemFireRedisServer.");
-    m.put(REDIS_BIND_ADDRESS_NAME, "The address the GemFireRedisServer will listen on for remote connections. Default is \"\" which causes the GemFireRedisServer to listen on the host's default address. This property is ignored if redis-port is \"0\".");
-    m.put(REDIS_PASSWORD_NAME, "The password which client of GemFireRedisServer must use to authenticate themselves. The default is none and no authentication will be required.");
-    m.put(ENABLE_CLUSTER_CONFIGURATION_NAME, LocalizedStrings.AbstractDistributionConfig_ENABLE_SHARED_CONFIGURATION.toLocalizedString());
-    m.put(USE_CLUSTER_CONFIGURATION_NAME, LocalizedStrings.AbstractDistributionConfig_USE_SHARED_CONFIGURATION.toLocalizedString());
-    m.put(LOAD_CLUSTER_CONFIG_FROM_DIR_NAME, LocalizedStrings.AbstractDistributionConfig_LOAD_SHARED_CONFIGURATION_FROM_DIR.toLocalizedString(SharedConfiguration.CLUSTER_CONFIG_ARTIFACTS_DIR_NAME));
+    m.put(JMX_MANAGER_PORT, "The port the jmx manager will listen on. Default is \"" + DEFAULT_JMX_MANAGER_PORT + "\". Set to zero to disable GemFire's creation of a jmx listening port.");
+    m.put(JMX_MANAGER_BIND_ADDRESS, "The address the jmx manager will listen on for remote connections. Default is \"\" which causes the jmx manager to listen on the host's default address. This property is ignored if jmx-manager-port is \"0\".");
+    m.put(JMX_MANAGER_HOSTNAME_FOR_CLIENTS, "The hostname that will be given to clients when they ask a locator for the location of this jmx manager. Default is \"\" which causes the locator to report the jmx manager's actual ip address as its location. This property is ignored if jmx-manager-port is \"0\".");
+    m.put(JMX_MANAGER_PASSWORD_FILE, "The name of the file the jmx manager will use to only allow authenticated clients to connect. Default is \"\" which causes the jmx manager to allow all clients to connect. This property is ignored if jmx-manager-port is \"0\".");
+    m.put(JMX_MANAGER_ACCESS_FILE, "The name of the file the jmx manager will use to define the access level of authenticated clients. Default is \"\" which causes the jmx manager to allow all clients all access. This property is ignored if jmx-manager-port is \"0\".");
+    m.put(JMX_MANAGER_HTTP_PORT, "By default when a jmx-manager is started it will also start an http server on this port. This server is used by the GemFire Pulse application. Setting this property to zero disables the http server. It defaults to 8080. Ignored if jmx-manager is false.");
+    m.put(JMX_MANAGER_UPDATE_RATE, "The rate in milliseconds at which this member will send updates to each jmx manager. Default is " + DEFAULT_JMX_MANAGER_UPDATE_RATE + ". Values must be in the range " + MIN_JMX_MANAGER_UPDATE_RATE + ".." + MAX_JMX_MANAGER_UPDATE_RATE + ".");
+    m.put(MEMCACHED_PORT, "The port GemFireMemcachedServer will listen on. Default is 0. Set to zero to disable GemFireMemcachedServer.");
+    m.put(MEMCACHED_PROTOCOL, "The protocol that GemFireMemcachedServer understands. Default is ASCII. Values may be ASCII or BINARY");
+    m.put(MEMCACHED_BIND_ADDRESS, "The address the GemFireMemcachedServer will listen on for remote connections. Default is \"\" which causes the GemFireMemcachedServer to listen on the host's default address. This property is ignored if memcached-port is \"0\".");
+    m.put(REDIS_PORT, "The port GeodeRedisServer will listen on. Default is 0. Set to zero to disable GeodeRedisServer.");
+    m.put(REDIS_BIND_ADDRESS, "The address the GeodeRedisServer will listen on for remote connections. Default is \"\" which causes the GeodeRedisServer to listen on the host's default address. This property is ignored if redis-port is \"0\".");
+    m.put(REDIS_PASSWORD, "The password which client of GeodeRedisServer must use to authenticate themselves. The default is none and no authentication will be required.");
+    m.put(ENABLE_CLUSTER_CONFIGURATION, LocalizedStrings.AbstractDistributionConfig_ENABLE_SHARED_CONFIGURATION.toLocalizedString());
+    m.put(USE_CLUSTER_CONFIGURATION, LocalizedStrings.AbstractDistributionConfig_USE_SHARED_CONFIGURATION.toLocalizedString());
+    m.put(LOAD_CLUSTER_CONFIGURATION_FROM_DIR, LocalizedStrings.AbstractDistributionConfig_LOAD_SHARED_CONFIGURATION_FROM_DIR.toLocalizedString(SharedConfiguration.CLUSTER_CONFIG_ARTIFACTS_DIR_NAME));
-        SERVER_SSL_ENABLED_NAME,
+        SERVER_SSL_ENABLED,
-        SERVER_SSL_CIPHERS_NAME,
+        SERVER_SSL_CIPHERS,
-        SERVER_SSL_PROTOCOLS_NAME,
+        SERVER_SSL_PROTOCOLS,
-        SERVER_SSL_REQUIRE_AUTHENTICATION_NAME,
+        SERVER_SSL_REQUIRE_AUTHENTICATION,
-    m.put(SERVER_SSL_KEYSTORE_NAME,"Location of the Java keystore file containing server's or client's own certificate and private key.");
+    m.put(SERVER_SSL_KEYSTORE,"Location of the Java keystore file containing server's or client's own certificate and private key.");
-    m.put(SERVER_SSL_KEYSTORE_TYPE_NAME, 
+    m.put(SERVER_SSL_KEYSTORE_TYPE,
-    m.put(SERVER_SSL_KEYSTORE_PASSWORD_NAME,"Password to access the private key from the keystore file specified by javax.net.ssl.keyStore. ");
+    m.put(SERVER_SSL_KEYSTORE_PASSWORD,"Password to access the private key from the keystore file specified by javax.net.ssl.keyStore. ");
-    m.put(SERVER_SSL_TRUSTSTORE_NAME,"Location of the Java keystore file containing the collection of CA certificates trusted by server or client(trust store).");
+    m.put(SERVER_SSL_TRUSTSTORE,"Location of the Java keystore file containing the collection of CA certificates trusted by server or client(trust store).");
-    m.put(SERVER_SSL_TRUSTSTORE_PASSWORD_NAME,"Password to unlock the keystore file (store password) specified by  javax.net.ssl.trustStore.");
+    m.put(SERVER_SSL_TRUSTSTORE_PASSWORD,"Password to unlock the keystore file (store password) specified by  javax.net.ssl.trustStore.");
-        GATEWAY_SSL_ENABLED_NAME,
+        GATEWAY_SSL_ENABLED,
-        GATEWAY_SSL_CIPHERS_NAME,
+        GATEWAY_SSL_CIPHERS,
-        GATEWAY_SSL_PROTOCOLS_NAME,
+        GATEWAY_SSL_PROTOCOLS,
-        GATEWAY_SSL_REQUIRE_AUTHENTICATION_NAME,
+        GATEWAY_SSL_REQUIRE_AUTHENTICATION,
-    m.put(GATEWAY_SSL_KEYSTORE_NAME,"Location of the Java keystore file containing gateway's own certificate and private key.");
+    m.put(GATEWAY_SSL_KEYSTORE,"Location of the Java keystore file containing gateway's own certificate and private key.");
-    m.put(GATEWAY_SSL_KEYSTORE_TYPE_NAME, 
+    m.put(GATEWAY_SSL_KEYSTORE_TYPE,
-    m.put(GATEWAY_SSL_KEYSTORE_PASSWORD_NAME,"Password to access the private key from the keystore file specified by javax.net.ssl.keyStore.");
+    m.put(GATEWAY_SSL_KEYSTORE_PASSWORD,"Password to access the private key from the keystore file specified by javax.net.ssl.keyStore.");
-    m.put(GATEWAY_SSL_TRUSTSTORE_NAME,"Location of the Java keystore file containing the collection of CA certificates trusted by gateway.");
+    m.put(GATEWAY_SSL_TRUSTSTORE,"Location of the Java keystore file containing the collection of CA certificates trusted by gateway.");
-    m.put(GATEWAY_SSL_TRUSTSTORE_PASSWORD_NAME,"Password to unlock the keystore file (store password) specified by  javax.net.ssl.trustStore.");
+    m.put(GATEWAY_SSL_TRUSTSTORE_PASSWORD,"Password to unlock the keystore file (store password) specified by  javax.net.ssl.trustStore.");
-    m.put(HTTP_SERVICE_PORT_NAME, "If non zero, then the gemfire developer REST service will be deployed and started when the cache is created. Default value is 0.");
-    m.put(HTTP_SERVICE_BIND_ADDRESS_NAME, "The address where gemfire developer REST service will listen for remote REST connections. Default is \"\" which causes the Rest service to listen on the host's default address.");
+    m.put(HTTP_SERVICE_PORT, "If non zero, then the gemfire developer REST service will be deployed and started when the cache is created. Default value is 0.");
+    m.put(HTTP_SERVICE_BIND_ADDRESS, "The address where gemfire developer REST service will listen for remote REST connections. Default is \"\" which causes the Rest service to listen on the host's default address.");
-        HTTP_SERVICE_SSL_ENABLED_NAME,
+        HTTP_SERVICE_SSL_ENABLED,
-        HTTP_SERVICE_SSL_CIPHERS_NAME,
+        HTTP_SERVICE_SSL_CIPHERS,
-        HTTP_SERVICE_SSL_PROTOCOLS_NAME,
+        HTTP_SERVICE_SSL_PROTOCOLS,
-        HTTP_SERVICE_SSL_REQUIRE_AUTHENTICATION_NAME,
+        HTTP_SERVICE_SSL_REQUIRE_AUTHENTICATION,
-    m.put(HTTP_SERVICE_SSL_KEYSTORE_NAME,"Location of the Java keystore file containing Http Service's own certificate and private key.");
+    m.put(HTTP_SERVICE_SSL_KEYSTORE,"Location of the Java keystore file containing Http Service's own certificate and private key.");
-    m.put(HTTP_SERVICE_SSL_KEYSTORE_TYPE_NAME, 
+    m.put(HTTP_SERVICE_SSL_KEYSTORE_TYPE,
-    m.put(HTTP_SERVICE_SSL_KEYSTORE_PASSWORD_NAME,"Password to access the private key from the keystore file specified by javax.net.ssl.keyStore.");
+    m.put(HTTP_SERVICE_SSL_KEYSTORE_PASSWORD,"Password to access the private key from the keystore file specified by javax.net.ssl.keyStore.");
-    m.put(HTTP_SERVICE_SSL_TRUSTSTORE_NAME,"Location of the Java keystore file containing the collection of CA certificates trusted by Http Service.");
+    m.put(HTTP_SERVICE_SSL_TRUSTSTORE,"Location of the Java keystore file containing the collection of CA certificates trusted by Http Service.");
-    m.put(HTTP_SERVICE_SSL_TRUSTSTORE_PASSWORD_NAME,"Password to unlock the keystore file (store password) specified by  javax.net.ssl.trustStore.");
+    m.put(HTTP_SERVICE_SSL_TRUSTSTORE_PASSWORD,"Password to unlock the keystore file (store password) specified by  javax.net.ssl.trustStore.");
-    
-    m.put(START_DEV_REST_API_NAME, "If true then the developer(API) REST service will be started when the cache is created. Defaults to false.");
-    m.put(OFF_HEAP_MEMORY_SIZE_NAME, LocalizedStrings.AbstractDistributionConfig_OFF_HEAP_MEMORY_SIZE_0.toLocalizedString(DEFAULT_OFF_HEAP_MEMORY_SIZE));
+    m.put(START_DEV_REST_API, "If true then the developer(API) REST service will be started when the cache is created. Defaults to false.");
+    m.put(OFF_HEAP_MEMORY_SIZE, LocalizedStrings.AbstractDistributionConfig_OFF_HEAP_MEMORY_SIZE_0.toLocalizedString(DEFAULT_OFF_HEAP_MEMORY_SIZE));
+    m.put(LOCK_MEMORY, LocalizedStrings.AbstractDistributionConfig_LOCK_MEMORY.toLocalizedString(DEFAULT_LOCK_MEMORY));
+    m.put(DISTRIBUTED_TRANSACTIONS, "Flag to indicate whether all transactions including JTA should be distributed transactions.  Default is false, meaning colocated transactions.");
+
+    m.put(SECURITY_SHIRO_INIT, "The name of the shiro configuration file in the classpath, e.g. shiro.ini");
+    m.put(SECURITY_MANAGER, "User defined fully qualified class name implementing SecurityManager interface for integrated security. Defaults to \"{0}\". Legal values can be any \"class name\" implementing SecurityManager that is present in the classpath.");
+    m.put(SECURITY_POST_PROCESSOR, "User defined fully qualified class name implementing PostProcessor interface for integrated security. Defaults to \"{0}\". Legal values can be any \"class name\" implementing PostProcessor that is present in the classpath.");
+
-    m.put(LOCK_MEMORY_NAME, LocalizedStrings.AbstractDistributionConfig_LOCK_MEMORY.toLocalizedString(DEFAULT_LOCK_MEMORY));
-    m.put(DISTRIBUTED_TRANSACTIONS_NAME, "Flag to indicate whether all transactions including JTA should be distributed transactions.  Default is false, meaning colocated transactions.");
+
-  static final InetAddress _getDefaultMcastAddress() {
-    String ipLiteral;
-    if ( SocketCreator.preferIPv6Addresses() ) {
-      ipLiteral = "FF38::1234"; // fix for bug 30014
-    } else {
-      ipLiteral = "239.192.81.1"; // fix for bug 30014
-    }
+  public static final InetAddress _getDefaultMcastAddress() {
+    //Default MCast address can be just IPv4 address.
+    //On IPv6 machines, JGroups converts IPv4 address to equivalent IPv6 address.
+    String ipLiteral = "239.192.81.1";

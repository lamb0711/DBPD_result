Merge remote-tracking branch 'origin/develop' into feature/GEODE-77

+import com.gemstone.gemfire.internal.cache.partitioned.rebalance.ParallelBucketOperator;
+  private static final int MAX_PARALLEL_OPERATIONS = Integer.getInteger("gemfire.MAX_PARALLEL_BUCKET_RECOVERIES", 8);
+  
-      BucketOperatorWrapper operator = getBucketOperator(detailsMap);
-      model = buildModel(operator, detailsMap, resourceManager);
-      for(PartitionRebalanceDetailsImpl details : operator.getDetailSet()) {
+      BucketOperatorWrapper serialOperator = getBucketOperator(detailsMap);
+      ParallelBucketOperator parallelOperator = new ParallelBucketOperator(MAX_PARALLEL_OPERATIONS, cache.getDistributionManager().getWaitingThreadPool(), serialOperator);
+      model = buildModel(parallelOperator, detailsMap, resourceManager);
+      for(PartitionRebalanceDetailsImpl details : serialOperator.getDetailSet()) {
+          model.waitForOperations();
-          model = buildModel(operator, detailsMap, resourceManager);
+          model = buildModel(parallelOperator, detailsMap, resourceManager);
-      for(PartitionRebalanceDetailsImpl details : operator.getDetailSet()) {
+      for(PartitionRebalanceDetailsImpl details : serialOperator.getDetailSet()) {
-      return Collections.<PartitionRebalanceInfo>unmodifiableSet(operator.getDetailSet());
+      return Collections.<PartitionRebalanceInfo>unmodifiableSet(serialOperator.getDetailSet());
+    @Override
+    @Override
-    public boolean createRedundantBucket(
+    @Override
+    public void createRedundantBucket(
-        Map<String, Long> colocatedRegionBytes) {
-      return createRedundantBucketForRegion(targetMember, bucketId,
+        Map<String, Long> colocatedRegionBytes, Completion completion) {
+      boolean result = false;
+      try {
+        result = createRedundantBucketForRegion(targetMember, bucketId,
+      } finally {
+        if(result) {
+          completion.onSuccess();
+        } else {
+          completion.onFailure();
+        }
+      }
+    }
+    
+    @Override
+    public void waitForOperations() {
+      //do nothing, all operations are synchronous
+    @Override
-    
+    @Override
-    public boolean createRedundantBucket(
-        InternalDistributedMember targetMember, int i, 
-        Map<String, Long> colocatedRegionBytes) {
-      boolean result = false;
-      long elapsed = 0;
-      long totalBytes = 0;
-      
+    @Override
+    public void createRedundantBucket(
+        final InternalDistributedMember targetMember, final int i, 
+        final Map<String, Long> colocatedRegionBytes, final Completion completion) {
-      try {
-        long start = System.nanoTime();
-        result = delegate.createRedundantBucket(targetMember, i,  
-            colocatedRegionBytes);
-        elapsed= System.nanoTime() - start;
-        if (result) {
+      
+      final long start = System.nanoTime();
+      delegate.createRedundantBucket(targetMember, i,  
+          colocatedRegionBytes, new Completion() {
+
+        @Override
+        public void onSuccess() {
+          long totalBytes = 0;
+          long elapsed= System.nanoTime() - start;
-        } else {
+
+          if(stats != null) {
+            stats.endBucketCreate(regionCount, true, totalBytes, elapsed);
+          }
+
+        }
+
+        @Override
+        public void onFailure() {
+          long elapsed= System.nanoTime() - start;
+
+
+          if(stats != null) {
+            stats.endBucketCreate(regionCount, false, 0, elapsed);
+          }
-      } finally {
-        if(stats != null) {
-          stats.endBucketCreate(regionCount, result, totalBytes, elapsed);
-        }
-      }
-      
-      return result;
+      });
+    @Override
+    @Override
+    
+    @Override
+    public void waitForOperations() {
+      delegate.waitForOperations();
+    }

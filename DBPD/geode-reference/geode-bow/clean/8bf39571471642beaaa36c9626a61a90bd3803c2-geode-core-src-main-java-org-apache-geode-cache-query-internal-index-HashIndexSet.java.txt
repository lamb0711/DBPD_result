Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-/*           
- * insertionIndex(), index(), trimToSize() are based on code provided by fastutil
- * They are based from add(), contains() and other methods from ObjectOpenHashSet
- * We have used the traversing mechanism and the HashCommon.mix()
+/*
+ * insertionIndex(), index(), trimToSize() are based on code provided by fastutil They are based
+ * from add(), contains() and other methods from ObjectOpenHashSet We have used the traversing
+ * mechanism and the HashCommon.mix()
- * An implementation of the <tt>Set</tt> interface for the HashIndex
- * Not exactly a set as the hash keys can actually collide but will
- * continue to look for an empty location to store the value
+ * An implementation of the <tt>Set</tt> interface for the HashIndex Not exactly a set as the hash
+ * keys can actually collide but will continue to look for an empty location to store the value
-   * optional statistics object to track number of hash collisions and time
-   * spent probing based on hash collisions
+   * optional statistics object to track number of hash collisions and time spent probing based on
+   * hash collisions
-  final class HashIndexSetProperties{
+  final class HashIndexSetProperties {
-    /** used for hashing into the table**/
+    /** used for hashing into the table **/
-    /** the current number of open slots in the hash.
-     * Originally used when we collapsed collided keys into collections
-     * Not really used now */
+    /**
+     * the current number of open slots in the hash. Originally used when we collapsed collided keys
+     * into collections Not really used now
+     */
-    /** number of removed tokens in the set, these are index positions that may be reused*/
+    /** number of removed tokens in the set, these are index positions that may be reused */
-    /** size of the backing table (-1)**/
+    /** size of the backing table (-1) **/
+
-  /** If after an update, the number of removed tokens X percent of the max size,
-    * we will compact and rehash to remove the tokens.
-    */
+  /**
+   * If after an update, the number of removed tokens X percent of the max size, we will compact and
+   * rehash to remove the tokens.
+   */
- /**
-  * The removed token
-  */
+  /**
+   * The removed token
+   */
-   * Creates a new <code>HashIndexSet</code> instance with a prime capacity
-   * equal to or greater than <tt>initialCapacity</tt> and with the specified
-   * load factor.
+   * Creates a new <code>HashIndexSet</code> instance with a prime capacity equal to or greater than
+   * <tt>initialCapacity</tt> and with the specified load factor.
-    setUp(initialCapacity , loadFactor);
+    setUp(initialCapacity, loadFactor);
-   * Set the statistics object for tracking hash code collisions. Should be
-   * called before the first element is added.
+   * Set the statistics object for tracking hash code collisions. Should be called before the first
+   * element is added.
-   * @param obj
-   *          an <code>Object</code> value
+   * @param obj an <code>Object</code> value
-    /* Code originated from fastutils
-     * Copyright (C) 2002-2014 Sebastiano Vigna
+    /*
+     * Code originated from fastutils Copyright (C) 2002-2014 Sebastiano Vigna
-     * Licensed under the Apache License, Version 2.0 (the "License");
-     * you may not use this file except in compliance with the License.
-     * You may obtain a copy of the License at
+     * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
+     * except in compliance with the License. You may obtain a copy of the License at
-     * http://www.apache.org/licenses/LICENSE-2.0 
+     * http://www.apache.org/licenses/LICENSE-2.0
-    if (!((curr = set[pos = (it.unimi.dsi.fastutil.HashCommon.mix(hash)) & mask]) == null || curr == REMOVED)) {
+    if (!((curr = set[pos = (it.unimi.dsi.fastutil.HashCommon.mix(hash)) & mask]) == null
+        || curr == REMOVED)) {
-   * @param indexKey
-   *          an <code>Object</code> value that represents the index key
+   * @param indexKey an <code>Object</code> value that represents the index key
-   * @param index
-   *          the array index location to store the object. This should be
-   *          calculated by one of the insertionIndex methods
+   * @param index the array index location to store the object. This should be calculated by one of
+   *        the insertionIndex methods
-      throw new ArrayIndexOutOfBoundsException("Cannot add:" + newObject + " into array position:" + index);
+      throw new ArrayIndexOutOfBoundsException(
+          "Cannot add:" + newObject + " into array position:" + index);
-    } 
+    }
-    throw new UnsupportedOperationException("add(Object) not supported, try add(Object key, Object obj) instead");
+    throw new UnsupportedOperationException(
+        "add(Object) not supported, try add(Object key, Object obj) instead");
-   * @param indexKey 
+   * @param indexKey
-    // where old key == new key (when no reverse map) we end up not updating to the correct slot in this case
+    // where old key == new key (when no reverse map) we end up not updating to the correct slot in
+    // this case
-      /* Code originated from fastutils
-       * Copyright (C) 2002-2014 Sebastiano Vigna
+      /*
+       * Code originated from fastutils Copyright (C) 2002-2014 Sebastiano Vigna
-       * Licensed under the Apache License, Version 2.0 (the "License");
-       * you may not use this file except in compliance with the License.
-       * You may obtain a copy of the License at
+       * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
+       * except in compliance with the License. You may obtain a copy of the License at
-       * http://www.apache.org/licenses/LICENSE-2.0 
+       * http://www.apache.org/licenses/LICENSE-2.0
-      if (!((curr = array[pos = (it.unimi.dsi.fastutil.HashCommon.mix(hash)) & mask]) == null || curr == REMOVED)) {
+      if (!((curr = array[pos = (it.unimi.dsi.fastutil.HashCommon.mix(hash)) & mask]) == null
+          || curr == REMOVED)) {
-  
+
-    
-    HashIndexSetProperties newHashIndexProperties = new HashIndexSetProperties(newSet,mask);
+    HashIndexSetProperties newHashIndexProperties = new HashIndexSetProperties(newSet, mask);
-   * @param a
-   *          an <code>Object[]</code> value
+   * 
+   * @param a an <code>Object[]</code> value
-   * @param newIndexSlot if inplace modification occurs with out having a reversemap
-   *          we end up scanning the entire index. We want to remove the region entry from the index slot
-   *          but not the newly added (correct) slot. Rather only the "old/wrong" slot
+   * @param newIndexSlot if inplace modification occurs with out having a reversemap we end up
+   *        scanning the entire index. We want to remove the region entry from the index slot but
+   *        not the newly added (correct) slot. Rather only the "old/wrong" slot
-  
+
-    }
-    catch (TypeMismatchException e) {
+    } catch (TypeMismatchException e) {
-   * Creates an iterator over the values of the set. The iterator supports
-   * element deletion.
+   * Creates an iterator over the values of the set. The iterator supports element deletion.
-   * Returns the number of positions used in the backing array
-   * Is not a true representation of the number of elements in the array
-   * as the array may contain REMOVED tokens
+   * Returns the number of positions used in the backing array Is not a true representation of the
+   * number of elements in the array as the array may contain REMOVED tokens
-   * only used for query optimization.  Instead of crawling the entire array doing matches
-   * let's just return the size of the array as that is the worst case size
+   * only used for query optimization. Instead of crawling the entire array doing matches let's just
+   * return the size of the array as that is the worst case size
-  
-  public boolean trimToSize( final int n ) {
-    final int l = HashCommon.nextPowerOfTwo( (int)Math.ceil( n / _loadFactor ) );
-    if (this.hashIndexSetProperties.n <= l ) return true;
+
+  public boolean trimToSize(final int n) {
+    final int l = HashCommon.nextPowerOfTwo((int) Math.ceil(n / _loadFactor));
+    if (this.hashIndexSetProperties.n <= l)
+      return true;
-            rehash( l );
-    }
-    catch ( OutOfMemoryError cantDoIt ) {
-            return false;
+      rehash(l);
+    } catch (OutOfMemoryError cantDoIt) {
+      return false;
-}
+  }
-    int n = arraySize( expectedCapacity, loadFactor );
+    int n = arraySize(expectedCapacity, loadFactor);
-    HashIndexSetProperties metaData  = new HashIndexSetProperties(set,mask);
+    HashIndexSetProperties metaData = new HashIndexSetProperties(set, mask);
-  
+
-    return Math.min( (int)Math.ceil( n * loadFactor ), n - 1 );
+    return Math.min((int) Math.ceil(n * loadFactor), n - 1);
-    if (hashIndexSetProperties.size > hashIndexSetProperties.maxSize || hashIndexSetProperties.free == 0 || TEST_ALWAYS_REHASH) {
+    if (hashIndexSetProperties.size > hashIndexSetProperties.maxSize
+        || hashIndexSetProperties.free == 0 || TEST_ALWAYS_REHASH) {
-    } else if (hashIndexSetProperties.removedTokens > hashIndexSetProperties.maxSize * CONDITIONAL_REMOVED_TOKEN_REHASH_FACTOR) {
+    } else if (hashIndexSetProperties.removedTokens > hashIndexSetProperties.maxSize
+        * CONDITIONAL_REMOVED_TOKEN_REHASH_FACTOR) {
-    private HashIndexSetIterator(Object keyToMatch , HashIndexSetProperties metaData) {
+    private HashIndexSetIterator(Object keyToMatch, HashIndexSetProperties metaData) {
-    
+
-          setPos(pos+1);
+          setPos(pos + 1);
-        setPos(pos+1);
+        setPos(pos + 1);
-    
-    
+
+
-     
+
-           if (indexKey instanceof String) {
-             fieldValue = ((PdxString) fieldValue).toString(); 
-           }
-         }
-         else if (indexKey instanceof PdxString) {
-           if (fieldValue instanceof String) {
-             fieldValue = new PdxString((String)fieldValue);
-           }
-         }
-         return TypeUtils.compare(fieldValue, indexKey, OQLLexerTokenTypes.TOK_EQ).equals(Boolean.TRUE);
-        }
-        catch (TypeMismatchException e) {
+            if (indexKey instanceof String) {
+              fieldValue = ((PdxString) fieldValue).toString();
+            }
+          } else if (indexKey instanceof PdxString) {
+            if (fieldValue instanceof String) {
+              fieldValue = new PdxString((String) fieldValue);
+            }
+          }
+          return TypeUtils.compare(fieldValue, indexKey, OQLLexerTokenTypes.TOK_EQ)
+              .equals(Boolean.TRUE);
+        } catch (TypeMismatchException e) {

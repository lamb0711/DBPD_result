Merge branch 'release/1.3.0'

+import static org.apache.commons.lang.Validate.isTrue;
+import static org.apache.commons.lang.Validate.notNull;
+
-import java.lang.management.ManagementFactory;
-import java.lang.management.RuntimeMXBean;
-public class MBeanProcessController implements ProcessController {
+class MBeanProcessController implements ProcessController {
-  private static final String LOCAL_CONNECTOR_ADDRESS_PROP =
+  private static final String PROPERTY_LOCAL_CONNECTOR_ADDRESS =
+  private static final Object[] PARAMS = {};
+  private static final String[] SIGNATURE = {};
+
-  protected JMXConnector jmxc;
-  protected MBeanServerConnection server;
+  private JMXConnector jmxc;
+  private MBeanServerConnection server;
-  public MBeanProcessController(final MBeanControllerParameters arguments, final int pid) {
-    if (pid < 1) {
-      throw new IllegalArgumentException("Invalid pid '" + pid + "' specified");
-    }
+  MBeanProcessController(final MBeanControllerParameters arguments, final int pid) {
+    notNull(arguments, "Invalid arguments '" + arguments + "' specified");
+    isTrue(pid > 0, "Invalid pid '" + pid + "' specified");
+
-    return this.pid;
+    return pid;
-    return status(this.arguments.getNamePattern(), this.arguments.getPidAttribute(),
-        this.arguments.getStatusMethod(), this.arguments.getAttributes(),
-        this.arguments.getValues());
+    return status(arguments.getNamePattern(), arguments.getPidAttribute(),
+        arguments.getStatusMethod(), arguments.getAttributes(), arguments.getValues());
-    stop(this.arguments.getNamePattern(), this.arguments.getPidAttribute(),
-        this.arguments.getStopMethod(), this.arguments.getAttributes(), this.arguments.getValues());
+    stop(arguments.getNamePattern(), arguments.getPidAttribute(), arguments.getStopMethod(),
+        arguments.getAttributes(), arguments.getValues());
-  public void checkPidSupport() {}
+  public void checkPidSupport() {
+    // nothing
+  }
-      final QueryExp constraint = buildQueryExp(pidAttribute, attributes, values);
-      final Set<ObjectName> mbeanNames = this.server.queryNames(namePattern, constraint);
+      QueryExp constraint = buildQueryExp(pidAttribute, attributes, values);
+      Set<ObjectName> mbeanNames = server.queryNames(namePattern, constraint);
-            + "' with attribute '" + pidAttribute + "' of value '" + this.pid + "'");
+            + "' with attribute '" + pidAttribute + "' of value '" + pid + "'");
-            + namePattern + "' with attribute '" + pidAttribute + "' of value '" + this.pid + "'");
+            + namePattern + "' with attribute '" + pidAttribute + "' of value '" + pid + "'");
-    } catch (InstanceNotFoundException e) {
-      throw new MBeanInvocationFailedException(
-          "Failed to invoke " + methodName + " on " + objectName, e);
-    } catch (MBeanException e) {
-      throw new MBeanInvocationFailedException(
-          "Failed to invoke " + methodName + " on " + objectName, e);
-    } catch (ReflectionException e) {
+    } catch (InstanceNotFoundException | MBeanException | ReflectionException e) {
-      final JMXServiceURL jmxUrl = getJMXServiceURL();
-      this.jmxc = JMXConnectorFactory.connect(jmxUrl);
-      this.server = this.jmxc.getMBeanServerConnection();
+      JMXServiceURL jmxUrl = getJMXServiceURL();
+      jmxc = JMXConnectorFactory.connect(jmxUrl);
+      server = jmxc.getMBeanServerConnection();
-      throw new ConnectionFailedException("Failed to connect to process '" + this.pid + "'", e);
+      throw new ConnectionFailedException("Failed to connect to process '" + pid + "'", e);
-    this.server = null;
-    if (this.jmxc != null) {
+    server = null;
+    if (jmxc != null) {
-        this.jmxc.close();
-      } catch (IOException e) {
+        jmxc.close();
+      } catch (IOException ignored) {
-    this.jmxc = null;
-  }
-
-  /**
-   * Ensures that the other process identifies itself by the same pid used by this stopper to
-   * connect to that process. NOT USED EXCEPT IN TEST.
-   * 
-   * @return true if the pid matches
-   * 
-   * @throws IllegalStateException if the other process identifies itself by a different pid
-   * @throws IOException if a communication problem occurred when accessing the
-   *         MBeanServerConnection
-   * @throws PidUnavailableException if parsing the pid from the RuntimeMXBean name fails
-   */
-  boolean checkPidMatches() throws IllegalStateException, IOException, PidUnavailableException {
-    final RuntimeMXBean proxy = ManagementFactory.newPlatformMXBeanProxy(this.server,
-        ManagementFactory.RUNTIME_MXBEAN_NAME, RuntimeMXBean.class);
-    final int remotePid = ProcessUtils.identifyPid(proxy.getName());
-    if (remotePid != this.pid) {
-      throw new IllegalStateException(
-          "Process has different pid '" + remotePid + "' than expected pid '" + this.pid + "'");
-    } else {
-      return true;
-    }
+    jmxc = null;
-    String connectorAddress = null;
-    final VirtualMachine vm = VirtualMachine.attach(String.valueOf(this.pid));
+    String connectorAddress;
+    VirtualMachine vm = VirtualMachine.attach(String.valueOf(pid));
-      connectorAddress = (String) agentProps.get(LOCAL_CONNECTOR_ADDRESS_PROP);
+      connectorAddress = agentProps.getProperty(PROPERTY_LOCAL_CONNECTOR_ADDRESS);
-        final String javaHome = vm.getSystemProperties().getProperty("java.home");
+        String javaHome = vm.getSystemProperties().getProperty("java.home");
-        } catch (AgentLoadException e) {
-          IOException ioe = new IOException(e.getMessage());
-          ioe.initCause(e);
-          throw ioe;
-        } catch (AgentInitializationException e) {
-          IOException ioe = new IOException(e.getMessage());
-          ioe.initCause(e);
-          throw ioe;
+        } catch (AgentLoadException | AgentInitializationException e) {
+          throw new IOException(e);
-        connectorAddress = (String) agentProps.get(LOCAL_CONNECTOR_ADDRESS_PROP);
+        connectorAddress = agentProps.getProperty(PROPERTY_LOCAL_CONNECTOR_ADDRESS);
-    final QueryExp optionalAttributes = buildOptionalQueryExp(attributes, values);
+    QueryExp optionalAttributes = buildOptionalQueryExp(attributes, values);
-          Query.and(optionalAttributes, Query.eq(Query.attr(pidAttribute), Query.value(this.pid)));
+          Query.and(optionalAttributes, Query.eq(Query.attr(pidAttribute), Query.value(pid)));
-      constraint = Query.eq(Query.attr(pidAttribute), Query.value(this.pid));
+      constraint = Query.eq(Query.attr(pidAttribute), Query.value(pid));
-          queryExp = Query.eq(Query.attr(attributes[i]), Query.value(((Boolean) values[i])));
+          queryExp = Query.eq(Query.attr(attributes[i]), Query.value((Boolean) values[i]));
-              Query.eq(Query.attr(attributes[i]), Query.value(((Boolean) values[i]))));
+              Query.eq(Query.attr(attributes[i]), Query.value((Boolean) values[i])));
-    return this.server.invoke(objectName, method, new Object[] {}, new String[] {});
+    return server.invoke(objectName, method, PARAMS, SIGNATURE);

Initial import of geode-1.0.0.0-SNAPSHOT-2.
All the new sub-project directories (like jvsd) were not imported.
A diff was done to confirm that this commit is exactly the same as
the open directory the snapshot was made from.

+import com.gemstone.gemfire.cache.server.CacheServer;
+import com.gemstone.gemfire.distributed.internal.DM;
+import com.gemstone.gemfire.internal.cache.xmlcache.BridgeServerCreation;
-import com.gemstone.org.jgroups.stack.GFBasicAdapter;
-import com.gemstone.org.jgroups.stack.GFPeerAdapter;
+import com.gemstone.org.jgroups.spi.GFBasicAdapter;
+import com.gemstone.org.jgroups.spi.GFPeerAdapter;
-      saveCacheXmlForReconnect();
+      if (!dconfig.getDisableAutoReconnect()) {
+        saveCacheXmlForReconnect(dconfig.getUseSharedConfiguration());
+      }
+        InternalDistributedSystem system = InternalDistributedSystem.getAnyInstance();
+        if (system != null) {
+          DM dm = system.getDM();
+          if (dm != null) {
+            dm.setRootCause(e);
+          }
+        }
+    this.timer.cancel();
+    
-  private void saveCacheXmlForReconnect() {
-    if (!dconfig.getDisableAutoReconnect()) {
-      // first save the current cache description so reconnect can rebuild the cache
-      GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
-      if (cache != null && (cache instanceof Cache)) {
-        if (!Boolean.getBoolean("gemfire.autoReconnect-useCacheXMLFile")
-            && !cache.isSqlfSystem() && !dconfig.getUseSharedConfiguration()) {
-          try {
-            if (logger.isDebugEnabled()) {
-              logger.debug("generating XML to rebuild the cache after reconnect completes");
-            }
-            StringPrintWriter pw = new StringPrintWriter(); 
-            CacheXmlGenerator.generate((Cache)cache, pw, true, false);
-            String cacheXML = pw.toString();
-            cache.getCacheConfig().setCacheXMLDescription(cacheXML);
-            if (logger.isDebugEnabled()) {
-              logger.debug("XML generation completed: {}", cacheXML);
-            }
-          } catch (CancelException e) {
-            logger.info(LocalizedMessage.create(LocalizedStrings.JGroupMembershipManager_PROBLEM_GENERATING_CACHE_XML), e);
-          }
+  public void saveCacheXmlForReconnect(boolean sharedConfigEnabled) {
+    // first save the current cache description so reconnect can rebuild the cache
+    GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
+    if (cache != null && (cache instanceof Cache)) {
+      if (!Boolean.getBoolean("gemfire.autoReconnect-useCacheXMLFile")
+          && !cache.isSqlfSystem() && !sharedConfigEnabled) {
+        try {
+          logger.info("generating XML to rebuild the cache after reconnect completes");
+          StringPrintWriter pw = new StringPrintWriter(); 
+          CacheXmlGenerator.generate((Cache)cache, pw, true, false);
+          String cacheXML = pw.toString();
+          cache.getCacheConfig().setCacheXMLDescription(cacheXML);
+          logger.info("XML generation completed: {}", cacheXML);
+        } catch (CancelException e) {
+          logger.info(LocalizedMessage.create(LocalizedStrings.JGroupMembershipManager_PROBLEM_GENERATING_CACHE_XML), e);
+      } else if (sharedConfigEnabled && !cache.getCacheServers().isEmpty()) {
+        // we need to retain a cache-server description if this JVM was started by gfsh
+        List<BridgeServerCreation> list = new ArrayList<BridgeServerCreation>(cache.getCacheServers().size());
+        for (Iterator it = cache.getCacheServers().iterator(); it.hasNext(); ) {
+          CacheServer cs = (CacheServer)it.next();
+          BridgeServerCreation bsc = new BridgeServerCreation(cache, cs);
+          list.add(bsc);
+        }
+        cache.getCacheConfig().setCacheServerCreation(list);
+        logger.info("CacheServer configuration saved");
-        saveCacheXmlForReconnect();
+        if (!dconfig.getDisableAutoReconnect()) {
+          saveCacheXmlForReconnect(dconfig.getUseSharedConfiguration());
+        }

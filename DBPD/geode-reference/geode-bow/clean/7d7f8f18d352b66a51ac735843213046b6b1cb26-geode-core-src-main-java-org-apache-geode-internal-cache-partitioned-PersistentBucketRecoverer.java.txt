GEODE-6630: move allBucketsRecoveredFromDisk count down latch (#3477)

* Rename RedundancyLogger to PersistentBucketRecoverer
* Move allBucketsRecoveredFromDisk count down latch from PRHARedundancyProvider to PersistentBucketRecoverer.
* Provide utility methods for using the count down latch.

+import java.util.concurrent.TimeUnit;
+import org.apache.geode.internal.logging.LoggingThread;
- * member. This logger is meant to run in its own thread and utilizes the PRHARedundancyProvider's
- * count down latch in order to determine when it is finished.
- *
+ * member. The logger is meant to run in its own thread.
+ * It uses a count down latch to determine whether the recovery is finished.
-public class RedundancyLogger extends RecoveryRunnable implements PersistentStateListener {
+public class PersistentBucketRecoverer extends RecoveryRunnable implements PersistentStateListener {
-   * Creates a new RedundancyLogger.
+   * Creates a new PersistentBucketRecoverer.
-  public RedundancyLogger(PRHARedundancyProvider prhaRedundancyProvider) {
+  public PersistentBucketRecoverer(PRHARedundancyProvider prhaRedundancyProvider,
+      int proxyBuckets) {
-        ColocationHelper.getColocatedChildRegions(baseRegion);
+        getColocatedChildRegions(baseRegion);
-    this.regions = Collections.unmodifiableList(allRegions);
-
-
-    this.allBucketsRecoveredFromDisk = redundancyProvider.getAllBucketsRecoveredFromDiskLatch();
-    this.membershipChanged = true;
+    regions = Collections.unmodifiableList(allRegions);
+    allBucketsRecoveredFromDisk = new CountDownLatch(proxyBuckets);
+    membershipChanged = true;
+
+  }
+
+  List<PartitionedRegion> getColocatedChildRegions(PartitionedRegion baseRegion) {
+    return ColocationHelper.getColocatedChildRegions(baseRegion);
+  }
+
+  public void startLoggingThread() {
+    Thread loggingThread = new LoggingThread(
+        "PersistentBucketRecoverer for region " + redundancyProvider.prRegion.getName(), false,
+        this);
+    loggingThread.start();
-   * Add this RedundancyLogger as a persistence listener to all the region's bucket advisors.
+   * Add this PersistentBucketRecoverer as a persistence listener to all the region's bucket
+   * advisors.
-   * Removes this RedundancyLogger as a persistence listener from all the region's bucket advisors.
+   * Removes this PersistentBucketRecoverer as a persistence listener from all the region's bucket
+   * advisors.
-      while (this.allBucketsRecoveredFromDisk.getCount() > 0) {
+      while (getLatchCount() > 0) {
-     * The persistent identifier of the member running this RedundancyLogger.
+     * The persistent identifier of the member running this PersistentBucketRecoverer.
-        proxyBucket.getPersistenceAdvisor().removeListener(RedundancyLogger.this);
+        proxyBucket.getPersistenceAdvisor().removeListener(PersistentBucketRecoverer.this);
-        proxyBucket.getPersistenceAdvisor().addListener(RedundancyLogger.this);
+        proxyBucket.getPersistenceAdvisor().addListener(PersistentBucketRecoverer.this);
-      boolean thereAreBucketsToBeRecovered =
-          (RedundancyLogger.this.allBucketsRecoveredFromDisk.getCount() > 0);
+      boolean thereAreBucketsToBeRecovered = (getLatchCount() > 0);
+
+  public void await(long timeout, TimeUnit unit) {
+    boolean interrupted = false;
+    while (true) {
+      try {
+        redundancyProvider.prRegion.getCancelCriterion().checkCancelInProgress(null);
+        boolean done = allBucketsRecoveredFromDisk.await(timeout, unit);
+        if (done) {
+          break;
+        }
+      } catch (InterruptedException e) {
+        interrupted = true;
+      }
+    }
+    if (interrupted) {
+      Thread.currentThread().interrupt();
+    }
+  }
+
+  public void await() {
+    boolean interrupted = false;
+    while (true) {
+      try {
+        getAllBucketsRecoveredFromDiskLatch().await();
+        break;
+      } catch (InterruptedException e) {
+        interrupted = true;
+      }
+    }
+    if (interrupted) {
+      Thread.currentThread().interrupt();
+    }
+  }
+
+  public void countDown() {
+    allBucketsRecoveredFromDisk.countDown();
+  }
+
+  public void countDown(int size) {
+    while (size > 0) {
+      allBucketsRecoveredFromDisk.countDown();
+      --size;
+    }
+  }
+
+  public boolean hasRecoveryCompleted() {
+    if (getLatchCount() > 0) {
+      return false;
+    }
+    return true;
+  }
+
+  long getLatchCount() {
+    return allBucketsRecoveredFromDisk.getCount();
+  }
+
+  CountDownLatch getAllBucketsRecoveredFromDiskLatch() {
+    return allBucketsRecoveredFromDisk;
+  }
+

Merge branch 'feature/GEODE-8' into develop

+import java.util.LinkedHashMap;
+import antlr.collections.AST;
+import antlr.debug.misc.ASTFrame;
+
+import com.gemstone.gemfire.cache.query.QueryException;
-      GemFireAST n = (GemFireAST)parser.getAST ();    
+      GemFireAST n = (GemFireAST)parser.getAST ();
+  
+  public void compileGroupByClause(int numOfChildren) {
+    List list = new ArrayList();
+    for (int i = 0; i < numOfChildren; i++) {
+      Object csc = this.stack.pop();
+      list.add(0, csc);
+    }
+    push(list);
+  }
-  public void select() {    
-    // List of orderBy sortCriteria
-    Object limitObject = pop();
-    CompiledValue limit;
+  public void select(Map<Integer, Object> queryComponents) {
+    
+    CompiledValue limit = null;
+    Object limitObject = queryComponents.remove(OQLLexerTokenTypes.LIMIT);
-    }
-    else {
+    } else {
-    List orderByAttrs = (List)pop();
-    // whereClause
-    CompiledValue where = (CompiledValue)pop();
-    // fromClause: list of CompiledIteratorDefs
-    List iterators = (List)pop();
-    // pop the projection attributes
-    List projAttrs = (List)pop();
-    // "COUNT" or null
-    String aggrExpr = (String)pop();
-    // "DISTINCT" or null
-    String distinct = (String)pop();
-    
-    ArrayList<String> hints = null;
-    Object hintObject = pop();
-    if (hintObject != null) {
-      hints = (ArrayList<String>) hintObject;
+    List<CompiledSortCriterion> orderByAttrs = (List<CompiledSortCriterion>) queryComponents
+        .remove(OQLLexerTokenTypes.LITERAL_order);
+
+    List iterators = (List) queryComponents
+        .remove(OQLLexerTokenTypes.LITERAL_from);
+    List projAttrs = (List) queryComponents
+        .remove(OQLLexerTokenTypes.PROJECTION_ATTRS);
+    if (projAttrs == null) {
+      // remove any * or all attribute
+      queryComponents.remove(OQLLexerTokenTypes.TOK_STAR);
+      queryComponents.remove(OQLLexerTokenTypes.LITERAL_all);
+    // "COUNT" or null
+    /*String aggrExpr = (String) queryComponents
+        .remove(OQLLexerTokenTypes.LITERAL_count);*/
-    CompiledSelect select = new CompiledSelect(distinct != null, aggrExpr != null, where,
-        iterators, projAttrs, orderByAttrs, limit, hints);
+    // "DISTINCT" or null
+    String distinct = (String) queryComponents
+        .remove(OQLLexerTokenTypes.LITERAL_distinct);
+   List<String> hints = null;
+    Object hintObject = queryComponents.remove(OQLLexerTokenTypes.LITERAL_hint);
+    if (hintObject != null) {
+      hints = (List<String>) hintObject;
+    }
+
+    List<CompiledValue> groupByClause = (List<CompiledValue>) queryComponents
+        .remove(OQLLexerTokenTypes.LITERAL_group);
+
+    // whatever remains , treat it as where
+    // whereClause
+    CompiledValue where = null;
+
+    if (queryComponents.size() == 1) {
+      where = (CompiledValue) queryComponents.values().iterator().next();
+    } else if (queryComponents.size() > 1) {
+      throw new QueryInvalidException(
+          "Unexpected/unsupported query clauses found");
+    }
+    LinkedHashMap<Integer, CompiledAggregateFunction> aggMap = identifyAggregateExpressions(projAttrs);
+    boolean isCountOnly = checkForCountOnly(aggMap, projAttrs, groupByClause);
+    if(isCountOnly) {
+      projAttrs = null;
+    }
+    CompiledSelect select = createSelect(distinct != null,
+        isCountOnly, where, iterators, projAttrs, orderByAttrs, limit,
+        hints, groupByClause, aggMap);
+  private boolean checkForCountOnly(
+      Map<Integer, CompiledAggregateFunction> aggregateMap, List projAttribs, List<CompiledValue> groupBy) {
+    if (aggregateMap != null && aggregateMap.size() == 1
+        && projAttribs.size() == 1 && groupBy == null) {
+      for (Map.Entry<Integer, CompiledAggregateFunction> entry : aggregateMap
+          .entrySet()) {
+        CompiledAggregateFunction caf = entry.getValue();
+        if (caf.getFunctionType() == OQLLexerTokenTypes.COUNT
+            && caf.getParameter() == null) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }
+  
+  private CompiledSelect createSelect(boolean isDistinct, boolean isCountOnly, CompiledValue where,
+      List iterators, List projAttrs, List<CompiledSortCriterion> orderByAttrs, CompiledValue limit,
+      List<String> hints,List<CompiledValue> groupByClause, LinkedHashMap<Integer, 
+      CompiledAggregateFunction> aggMap    ) {
+    if(isCountOnly || (groupByClause == null  && aggMap == null) 
+        || (aggMap == null  && orderByAttrs == null)) {
+      return  new CompiledSelect(isDistinct,
+          isCountOnly, where, iterators, projAttrs, orderByAttrs, limit,
+          hints, groupByClause);
+    }else {
+      return new CompiledGroupBySelect(isDistinct,
+          isCountOnly, where, iterators, projAttrs, orderByAttrs, limit,
+          hints, groupByClause, aggMap);
+    }
+  }
+  
+  private LinkedHashMap<Integer, CompiledAggregateFunction> identifyAggregateExpressions(List projAttribs) {
+    if(projAttribs != null) {
+      LinkedHashMap<Integer, CompiledAggregateFunction> mapping = new LinkedHashMap<Integer,CompiledAggregateFunction>();
+      int index = 0;
+      for(Object o : projAttribs) {
+        CompiledValue proj =(CompiledValue) ((Object[])o)[1];
+        if( proj.getType() == OQLLexerTokenTypes.AGG_FUNC) {
+          mapping.put(index, (CompiledAggregateFunction)proj);
+        }
+        ++index;
+      }
+      return mapping.size() == 0 ? null : mapping;
+    }else {
+      return null;
+    }
+    
+  }
+  public void aggregateFunction (CompiledValue expr, int aggFuncType, boolean distinctOnly) {
+    push (new CompiledAggregateFunction(expr, aggFuncType, distinctOnly));
+  }
+  

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import org.apache.geode.GemFireException;
+import org.apache.geode.GemFireIOException;
+import org.apache.geode.distributed.internal.InternalDistributedSystem;
+import org.apache.geode.internal.i18n.LocalizedStrings;
+import org.apache.geode.internal.io.RollingFileHandler;
+import org.apache.geode.internal.logging.InternalLogWriter;
+import org.apache.geode.internal.logging.LogService;
+import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+import org.apache.geode.internal.logging.log4j.LogMarker;
+import org.apache.geode.internal.logging.log4j.LogWriterAppender;
+import org.apache.geode.internal.logging.log4j.LogWriterAppenders;
+import org.apache.geode.internal.logging.log4j.LogWriterLogger;
+import org.apache.logging.log4j.Logger;
+
-import java.util.regex.Pattern;
-
-import org.apache.logging.log4j.Logger;
-
-import org.apache.geode.GemFireException;
-import org.apache.geode.GemFireIOException;
-import org.apache.geode.distributed.internal.InternalDistributedSystem;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.InternalLogWriter;
-import org.apache.geode.internal.logging.LogService;
-import org.apache.geode.internal.logging.ManagerLogWriter;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
-import org.apache.geode.internal.logging.log4j.LogMarker;
-import org.apache.geode.internal.logging.log4j.LogWriterAppender;
-import org.apache.geode.internal.logging.log4j.LogWriterAppenders;
-import org.apache.geode.internal.logging.log4j.LogWriterLogger;
- * Extracted from {@link HostStatSampler} and
- * {@link GemFireStatSampler}.
+ * Extracted from {@link HostStatSampler} and {@link GemFireStatSampler}.
- * The StatArchiveHandler handles statistics samples by archiving them to a 
- * file. This handler provides archive file rolling (file size limit) and 
- * removal (disk space limit). This handler creates and uses an instance of
- * {@link StatArchiveWriter} for the currently
- * open archive file (unless archiving is disabled).
+ * The StatArchiveHandler handles statistics samples by archiving them to a file. This handler
+ * provides archive file rolling (file size limit) and removal (disk space limit). This handler
+ * creates and uses an instance of {@link StatArchiveWriter} for the currently open archive file
+ * (unless archiving is disabled).
-  
+
-  
+
-  
+
+  private final RollingFileHandler rollingFileHandler;
+
-   * Indicates if archiving has been disabled by specifying empty string for
-   * the archive file name. Other threads may call in to changeArchiveFile
-   * to manipulate this flag.
+   * Indicates if archiving has been disabled by specifying empty string for the archive file name.
+   * Other threads may call in to changeArchiveFile to manipulate this flag.
-  
+
-  
+
-   * Constructs a new instance. The {@link StatArchiveHandlerConfig} and 
-   * {@link SampleCollector} must not be null.
+   * Constructs a new instance. The {@link StatArchiveHandlerConfig} and {@link SampleCollector}
+   * must not be null.
-  public StatArchiveHandler(StatArchiveHandlerConfig config,
-                            SampleCollector sampleCollector) {
+  public StatArchiveHandler(StatArchiveHandlerConfig config, SampleCollector sampleCollector,
+      RollingFileHandler rollingFileHandler) {
+    this.rollingFileHandler = rollingFileHandler;
-  
+
+   * 
-  
+
-   * Closes any {@link StatArchiveWriter}
-   * currently in use by this handler.
+   * Closes any {@link StatArchiveWriter} currently in use by this handler.
+   * 
-  
+
-      logger.warn(LogMarker.STATISTICS, LocalizedMessage.create(LocalizedStrings.HostStatSampler_STATISTIC_ARCHIVER_SHUTTING_DOWN_BECAUSE__0, sw));
+      logger.warn(LogMarker.STATISTICS, LocalizedMessage.create(
+          LocalizedStrings.HostStatSampler_STATISTIC_ARCHIVER_SHUTTING_DOWN_BECAUSE__0, sw));
-        logger.warn(LogMarker.STATISTICS, LocalizedMessage.create(LocalizedStrings.HostStatSampler_STATISIC_ARCHIVER_SHUTDOWN_FAILED_BECAUSE__0, ignore.getMessage()));
+        logger.warn(LogMarker.STATISTICS,
+            LocalizedMessage.create(
+                LocalizedStrings.HostStatSampler_STATISIC_ARCHIVER_SHUTDOWN_FAILED_BECAUSE__0,
+                ignore.getMessage()));
-  
+
-        logger.trace(LogMarker.STATISTICS, "StatArchiveHandler#sampled resourceInstances={}", resourceInstances);
+        logger.trace(LogMarker.STATISTICS, "StatArchiveHandler#sampled resourceInstances={}",
+            resourceInstances);
-            logger.info(LogMarker.STATISTICS, LocalizedMessage.create(LocalizedStrings.GemFireStatSampler_ARCHIVING_STATISTICS_TO__0_, archiver.getArchiveName()));
+            logger.info(LogMarker.STATISTICS,
+                LocalizedMessage.create(
+                    LocalizedStrings.GemFireStatSampler_ARCHIVING_STATISTICS_TO__0_,
+                    archiver.getArchiveName()));
-          logger.warn(LogMarker.STATISTICS, "Use of java.lang.System.nanoTime() resulted in a non-positive timestamp delta. Skipping archival of statistics sample.", e);
+          logger.warn(LogMarker.STATISTICS,
+              "Use of java.lang.System.nanoTime() resulted in a non-positive timestamp delta. Skipping archival of statistics sample.",
+              e);
-  
+
-      logger.trace(LogMarker.STATISTICS, "StatArchiveHandler#allocatedResourceType resourceType={}", resourceType);
+      logger.trace(LogMarker.STATISTICS, "StatArchiveHandler#allocatedResourceType resourceType={}",
+          resourceType);
-      logger.trace(LogMarker.STATISTICS, "StatArchiveHandler#allocatedResourceInstance resourceInstance={}", resourceInstance);
+      logger.trace(LogMarker.STATISTICS,
+          "StatArchiveHandler#allocatedResourceInstance resourceInstance={}", resourceInstance);
-      logger.trace(LogMarker.STATISTICS, "StatArchiveHandler#destroyedResourceInstance resourceInstance={}", resourceInstance);
+      logger.trace(LogMarker.STATISTICS,
+          "StatArchiveHandler#destroyedResourceInstance resourceInstance={}", resourceInstance);
-  
+
-  
+
-   * Changes the archive file to the new file or disables archiving if an
-   * empty string is specified. This may be invoked by any thread other than 
-   * the stat sampler.
+   * Changes the archive file to the new file or disables archiving if an empty string is specified.
+   * This may be invoked by any thread other than the stat sampler.
-   * If the file name matches any archive file(s) already in {@link #archiveDir} 
-   * then this may trigger rolling and/or removal if appropriate based on {@link 
-   * StatArchiveHandlerConfig#getArchiveFileSizeLimit() file size limit} and 
-   * {@link StatArchiveHandlerConfig#getArchiveDiskSpaceLimit() disk space 
-   * limit}.
+   * If the file name matches any archive file(s) already in {@link #archiveDir} then this may
+   * trigger rolling and/or removal if appropriate based on
+   * {@link StatArchiveHandlerConfig#getArchiveFileSizeLimit() file size limit} and
+   * {@link StatArchiveHandlerConfig#getArchiveDiskSpaceLimit() disk space limit}.
-  
+
-  
+
-   * If the file name matches any archive file(s) already in {@link #archiveDir} 
-   * then this may trigger rolling and/or removal if appropriate based on {@link 
-   * StatArchiveHandlerConfig#getArchiveFileSizeLimit() file size limit} and 
-   * {@link StatArchiveHandlerConfig#getArchiveDiskSpaceLimit() disk space 
-   * limit}.
+   * If the file name matches any archive file(s) already in {@link #archiveDir} then this may
+   * trigger rolling and/or removal if appropriate based on
+   * {@link StatArchiveHandlerConfig#getArchiveFileSizeLimit() file size limit} and
+   * {@link StatArchiveHandlerConfig#getArchiveDiskSpaceLimit() disk space limit}.
-   * If resetHandler is true, then this handler will reset itself with the
-   * SampleCollector by removing and re-adding itself in order to receive 
-   * allocation notifications about all resource types and instances.
-   *  
-   * @param resetHandler true if the handler should reset itself with the
-   * SampleCollector in order to receive allocation notifications about all 
-   * resource types and instances
+   * If resetHandler is true, then this handler will reset itself with the SampleCollector by
+   * removing and re-adding itself in order to receive allocation notifications about all resource
+   * types and instances.
+   * 
+   * @param resetHandler true if the handler should reset itself with the SampleCollector in order
+   *        to receive allocation notifications about all resource types and instances
-  
+
-   * Changes the archive file to the new file or disables archiving if an
-   * empty string is specified. 
+   * Changes the archive file to the new file or disables archiving if an empty string is specified.
-   * If the file name matches any archive file(s) already in {@link #archiveDir} 
-   * then this may trigger rolling and/or removal if appropriate based on {@link 
-   * StatArchiveHandlerConfig#getArchiveFileSizeLimit() file size limit} and 
-   * {@link StatArchiveHandlerConfig#getArchiveDiskSpaceLimit() disk space 
-   * limit}.
+   * If the file name matches any archive file(s) already in {@link #archiveDir} then this may
+   * trigger rolling and/or removal if appropriate based on
+   * {@link StatArchiveHandlerConfig#getArchiveFileSizeLimit() file size limit} and
+   * {@link StatArchiveHandlerConfig#getArchiveDiskSpaceLimit() disk space limit}.
-   * If resetHandler is true, then this handler will reset itself with the
-   * SampleCollector by removing and re-adding itself in order to receive 
-   * allocation notifications about all resource types and instances.
+   * If resetHandler is true, then this handler will reset itself with the SampleCollector by
+   * removing and re-adding itself in order to receive allocation notifications about all resource
+   * types and instances.
-      logger.trace(LogMarker.STATISTICS, "StatArchiveHandler#changeArchiveFile newFile={}, nanosTimeStamp={}", newFile, nanosTimeStamp);
+      logger.trace(LogMarker.STATISTICS,
+          "StatArchiveHandler#changeArchiveFile newFile={}, nanosTimeStamp={}", newFile,
+          nanosTimeStamp);
-        logger.info(LogMarker.STATISTICS, LocalizedMessage.create(LocalizedStrings.GemFireStatSampler_DISABLING_STATISTIC_ARCHIVAL));
+        logger.info(LogMarker.STATISTICS, LocalizedMessage
+            .create(LocalizedStrings.GemFireStatSampler_DISABLING_STATISTIC_ARCHIVAL));
-                logger.trace(LogMarker.STATISTICS, "StatArchiveHandler#changeArchiveFile removing handler");
+                logger.trace(LogMarker.STATISTICS,
+                    "StatArchiveHandler#changeArchiveFile removing handler");
-              logger.warn(LogMarker.STATISTICS, LocalizedMessage.create(LocalizedStrings.GemFireStatSampler_STATISTIC_ARCHIVE_CLOSE_FAILED_BECAUSE__0, ignore.getMessage()));
+              logger.warn(LogMarker.STATISTICS,
+                  LocalizedMessage.create(
+                      LocalizedStrings.GemFireStatSampler_STATISTIC_ARCHIVE_CLOSE_FAILED_BECAUSE__0,
+                      ignore.getMessage()));
-          logger.warn(LogMarker.STATISTICS, LocalizedMessage.create(
-              LocalizedStrings.GemFireStatSampler_COULD_NOT_RENAME_0_TO_1,
-              new Object[] {newFile, oldFile}));
+          logger.warn(LogMarker.STATISTICS,
+              LocalizedMessage.create(LocalizedStrings.GemFireStatSampler_COULD_NOT_RENAME_0_TO_1,
+                  new Object[] {newFile, oldFile}));
-          logger.info(LogMarker.STATISTICS, LocalizedMessage.create(LocalizedStrings.GemFireStatSampler_RENAMED_OLD_EXISTING_ARCHIVE_TO__0_, oldFile));
+          logger.info(LogMarker.STATISTICS, LocalizedMessage.create(
+              LocalizedStrings.GemFireStatSampler_RENAMED_OLD_EXISTING_ARCHIVE_TO__0_, oldFile));
-            .setArchiveName(newFile.getPath())
-            .setSystemId(this.config.getSystemId())
+            .setArchiveName(newFile.getPath()).setSystemId(this.config.getSystemId())
-            .setProductDescription(this.config.getProductDescription())
-            .build();
+            .setProductDescription(this.config.getProductDescription()).build();
-        logger.warn(LogMarker.STATISTICS, LocalizedMessage.create(
-          LocalizedStrings.GemFireStatSampler_COULD_NOT_OPEN_STATISTIC_ARCHIVE_0_CAUSE_1,
-          new Object[] {newFile, ex.getLocalizedMessage()}));
+        logger.warn(LogMarker.STATISTICS,
+            LocalizedMessage.create(
+                LocalizedStrings.GemFireStatSampler_COULD_NOT_OPEN_STATISTIC_ARCHIVE_0_CAUSE_1,
+                new Object[] {newFile, ex.getLocalizedMessage()}));
-    
+
-          removeOldArchives(
-              newFile, this.config.getArchiveDiskSpaceLimit());
+          removeOldArchives(newFile, this.config.getArchiveDiskSpaceLimit());
-      if (resetHandler) {
-        if (isDebugEnabled_STATISTICS) {
-          logger.trace(LogMarker.STATISTICS, "StatArchiveHandler#changeArchiveFile removing handler");
+        if (resetHandler) {
+          if (isDebugEnabled_STATISTICS) {
+            logger.trace(LogMarker.STATISTICS,
+                "StatArchiveHandler#changeArchiveFile removing handler");
+          }
+          this.collector.removeSampleHandler(this);
-        this.collector.removeSampleHandler(this);
-      }
-      if (archiver != null) {
-        try {
-          archiver.close();
-        } catch (GemFireException ignore) {
-          logger.warn(LogMarker.STATISTICS, LocalizedMessage.create(LocalizedStrings.GemFireStatSampler_STATISTIC_ARCHIVE_CLOSE_FAILED_BECAUSE__0, ignore.getMessage()));
+        if (archiver != null) {
+          try {
+            archiver.close();
+          } catch (GemFireException ignore) {
+            logger.warn(LogMarker.STATISTICS,
+                LocalizedMessage.create(
+                    LocalizedStrings.GemFireStatSampler_STATISTIC_ARCHIVE_CLOSE_FAILED_BECAUSE__0,
+                    ignore.getMessage()));
+          }
+          removeOldArchives(newFile, this.config.getArchiveDiskSpaceLimit());
-        removeOldArchives(
-            newFile, this.config.getArchiveDiskSpaceLimit());
-      }
-   * Returns the modified archive file name to use after incrementing {@link 
-   * #mainArchiveId} and {@link #archiveId} based on existing files 
-   * {@link #archiveDir}. This is only used if {@link 
-   * StatArchiveHandlerConfig#getArchiveFileSizeLimit() file size limit} has
-   * been specified as non-zero (which enables file rolling).
+   * Returns the modified archive file name to use after incrementing {@link #mainArchiveId} and
+   * {@link #archiveId} based on existing files {@link #archiveDir}. This is only used if
+   * {@link StatArchiveHandlerConfig#getArchiveFileSizeLimit() file size limit} has been specified
+   * as non-zero (which enables file rolling).
-   * @param archiveClosed true if archive was just being written by us; false if it was written by the previous process.
+   * @param archiveClosed true if archive was just being written by us; false if it was written by
+   *        the previous process.
-   * @return the modified archive file name to use; it is modified by applying
-   * mainArchiveId and archiveId to the name for supporting file rolling
+   * @return the modified archive file name to use; it is modified by applying mainArchiveId and
+   *         archiveId to the name for supporting file rolling
-        mainArchiveId = ManagerLogWriter.calcNextMainId(archiveDir, false);
+        mainArchiveId = this.rollingFileHandler.calcNextMainId(archiveDir, false);
-      archiveId = ManagerLogWriter.calcNextChildId(archive, mainArchiveId);
+      archiveId = this.rollingFileHandler.calcNextChildId(archive, mainArchiveId);
-        buf
-          .append(ManagerLogWriter.formatId(mainArchiveId))
-          .append(ManagerLogWriter.formatId(archiveId));
+        buf.append(this.rollingFileHandler.formatId(mainArchiveId))
+            .append(this.rollingFileHandler.formatId(archiveId));
-        buf.insert(insertIdx, ManagerLogWriter.formatId(archiveId));
-        buf.insert(insertIdx, ManagerLogWriter.formatId(mainArchiveId));
+        buf.insert(insertIdx, this.rollingFileHandler.formatId(archiveId));
+        buf.insert(insertIdx, this.rollingFileHandler.formatId(mainArchiveId));
-      buf.append(ManagerLogWriter.formatId(mainArchiveId))
-         .append(ManagerLogWriter.formatId(0))
-         .append(".marker");
+      buf.append(this.rollingFileHandler.formatId(mainArchiveId))
+          .append(this.rollingFileHandler.formatId(0)).append(".marker");
-      buf.append(ManagerLogWriter.formatId(mainArchiveId))
-         .append(ManagerLogWriter.formatId(0))
-         .append(".marker");
+      buf.append(this.rollingFileHandler.formatId(mainArchiveId))
+          .append(this.rollingFileHandler.formatId(0)).append(".marker");
-      mainArchiveId = ManagerLogWriter.calcNextMainId(archiveDir, false);
+      mainArchiveId = this.rollingFileHandler.calcNextMainId(archiveDir, false);
-    buf.append(ManagerLogWriter.formatId(mainArchiveId))
-       .append(ManagerLogWriter.formatId(0))
-       .append(".marker");
+    buf.append(this.rollingFileHandler.formatId(mainArchiveId))
+        .append(this.rollingFileHandler.formatId(0)).append(".marker");
+
-   * Modifies the desired archive file name with a main id (similar to {@link 
-   * #mainArchiveId} if the archive file's dir already contains GemFire
-   * stat archive or log files containing a main id in the file name.
-   *  
+   * Modifies the desired archive file name with a main id (similar to {@link #mainArchiveId} if the
+   * archive file's dir already contains GemFire stat archive or log files containing a main id in
+   * the file name.
+   * 
-   * @return the modified archive file name to use; it is modified by applying
-   * the next main id if any files in the dir already have a main id in the file
-   * name
+   * @return the modified archive file name to use; it is modified by applying the next main id if
+   *         any files in the dir already have a main id in the file name
-  private static File getRenameArchiveName(File archive) {
+  private File getRenameArchiveName(File archive) {
-    int previousMainId = ManagerLogWriter.calcNextMainId(dir, false);
-    if (previousMainId==0) {
+    int previousMainId = this.rollingFileHandler.calcNextMainId(dir, false);
+    if (previousMainId == 0) {
-        buf
-          .append(ManagerLogWriter.formatId(previousMainId))
-          .append(ManagerLogWriter.formatId(1));
+        buf.append(this.rollingFileHandler.formatId(previousMainId))
+            .append(this.rollingFileHandler.formatId(1));
-        buf.insert(insertIdx, ManagerLogWriter.formatId(1));
-        buf.insert(insertIdx, ManagerLogWriter.formatId(previousMainId));
+        buf.insert(insertIdx, this.rollingFileHandler.formatId(1));
+        buf.insert(insertIdx, this.rollingFileHandler.formatId(previousMainId));
-   * Remove old versions of the specified archive file name in order to stay
-   * under the specified disk space limit. Old versions of the archive file
-   * are those that match based on using {@link #getArchivePattern(String)}
-   * which ignores mainArchiveId and archiveId.
+   * Remove old versions of the specified archive file name in order to stay under the specified
+   * disk space limit. Old versions of the archive file are those that match based on using a
+   * pattern which ignores mainArchiveId and archiveId.
-  private static void removeOldArchives(File archiveFile, long spaceLimit) {
-    if (spaceLimit == 0
-        || archiveFile == null
-        || archiveFile.getPath().equals("")) {
+  private void removeOldArchives(File archiveFile, long spaceLimit) {
+    if (spaceLimit == 0 || archiveFile == null || archiveFile.getPath().equals("")) {
-    ManagerLogWriter.checkDiskSpace("archive", archiveFile,
-        spaceLimit,
-        archiveDir,
-        getArchivePattern(archiveFile.getName()),
+    this.rollingFileHandler.checkDiskSpace("archive", archiveFile, spaceLimit, archiveDir,
-  
-  private static InternalLogWriter getOrCreateLogWriter() {
+
+  private InternalLogWriter getOrCreateLogWriter() {
-  
-  /**
-   * Create a regex pattern which will match the specified archive file name
-   * even if it has a mainArchiveId and/or archiveId.
-   * 
-   * @param name archive file name to create a regex pattern for
-   * @return regex pattern to use in finding matching file names
-   */
-  private static Pattern getArchivePattern(String name) {
-    String ext = "";
-
-    int extIdx = name.lastIndexOf('.');
-    if (extIdx != -1) {
-      ext = "\\Q" + name.substring(extIdx) + "\\E";
-      name = name.substring(0, extIdx);
-    }
-    
-    /* name may have -DD-DD on the end of it. Trim that part off. */
-    int dashIdx = name.indexOf('-');
-    if (dashIdx != -1) {
-      name = name.substring(0, dashIdx);
-    }
-    
-    name = "\\Q" + name + "\\E" + "-\\d+-\\d+" + ext;
-    return Pattern.compile(name);
-  }

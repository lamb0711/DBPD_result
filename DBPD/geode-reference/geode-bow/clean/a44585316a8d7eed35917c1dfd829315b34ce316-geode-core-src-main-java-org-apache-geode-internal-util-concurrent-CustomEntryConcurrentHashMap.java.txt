GEODE-2929: remove superfluous uses of final from internal classes

-  public static final int keyHash(final Object o, final boolean compareValues) {
+  public static int keyHash(final Object o, final boolean compareValues) {
-  final Segment<K, V> segmentFor(final int hash) {
+  Segment<K, V> segmentFor(final int hash) {
-  static final class HashEntryImpl<K, V> implements HashEntry<K, V> {
+  static class HashEntryImpl<K, V> implements HashEntry<K, V> {
-    public final K getKey() {
+    public K getKey() {
-    public final V getMapValue() {
+    public V getMapValue() {
-    public final void setMapValue(V newValue) {
+    public void setMapValue(V newValue) {
-    public final int getEntryHash() {
+    public int getEntryHash() {
-    public final HashEntry<K, V> getNextEntry() {
+    public HashEntry<K, V> getNextEntry() {
-    public final void setNextEntry(final HashEntry<K, V> n) {
+    public void setNextEntry(final HashEntry<K, V> n) {
-    final void setTable(final HashEntry<K, V>[] newTable) {
+    void setTable(final HashEntry<K, V>[] newTable) {
-    final HashEntry<K, V> getFirst(final int hash) {
+    HashEntry<K, V> getFirst(final int hash) {
-    final V readValueUnderLock(final HashEntry<K, V> e) {
+    V readValueUnderLock(final HashEntry<K, V> e) {
-    final V get(final Object key, final int hash) {
+    V get(final Object key, final int hash) {
-    final V getNoLock(final Object key, final int hash, final boolean lockListForRead) {
+    V getNoLock(final Object key, final int hash, final boolean lockListForRead) {
-    final boolean containsKey(final Object key, final int hash) {
+    boolean containsKey(final Object key, final int hash) {
-    final boolean containsValue(final Object value) {
+    boolean containsValue(final Object value) {
-    final boolean replace(final K key, final int hash, final V oldValue, final V newValue) {
+    boolean replace(final K key, final int hash, final V oldValue, final V newValue) {
-    final V replace(final K key, final int hash, final V newValue) {
+    V replace(final K key, final int hash, final V newValue) {
-    final V put(final K key, final int hash, final V value, final boolean onlyIfAbsent) {
+    V put(final K key, final int hash, final V value, final boolean onlyIfAbsent) {
-    final <C, P> V create(final K key, final int hash, final MapCallback<K, V, C, P> valueCreator,
+    <C, P> V create(final K key, final int hash, final MapCallback<K, V, C, P> valueCreator,
-    final V get(final Object key, final int hash, final MapCallback<K, V, ?, ?> readCallback) {
+    V get(final Object key, final int hash, final MapCallback<K, V, ?, ?> readCallback) {
-    final void rehash() {
+    void rehash() {
-    final <C, P> V remove(final Object key, final int hash, final Object value,
+    <C, P> V remove(final Object key, final int hash, final Object value,
-    final ArrayList<HashEntry<?, ?>> clear(ArrayList<HashEntry<?, ?>> clearedEntries) {
+    ArrayList<HashEntry<?, ?>> clear(ArrayList<HashEntry<?, ?>> clearedEntries) {
-  static final class IdentitySegment<K, V> extends Segment<K, V> implements Serializable {
+  static class IdentitySegment<K, V> extends Segment<K, V> implements Serializable {
-    static final <K, V> IdentitySegment<K, V>[] newArray(final int i) {
+    static <K, V> IdentitySegment<K, V>[] newArray(final int i) {
-    protected final boolean equalityKeyCompare(final Object key, final HashEntry<K, V> mapEntry) {
+    protected boolean equalityKeyCompare(final Object key, final HashEntry<K, V> mapEntry) {
-    protected final boolean equalityCompare(final Object key, final Object mapKey) {
+    protected boolean equalityCompare(final Object key, final Object mapKey) {
-    protected final boolean equalityCompareWithNulls(final Object key, final Object mapKey) {
+    protected boolean equalityCompareWithNulls(final Object key, final Object mapKey) {
-  static final class DefaultHashEntryCreator<K, V> implements HashEntryCreator<K, V>, Serializable {
+  static class DefaultHashEntryCreator<K, V> implements HashEntryCreator<K, V>, Serializable {
-    public final HashEntry<K, V> newEntry(final K key, final int hash, final HashEntry<K, V> next,
+    public HashEntry<K, V> newEntry(final K key, final int hash, final HashEntry<K, V> next,
-    public final int keyHashCode(final Object key, final boolean compareValues) {
+    public int keyHashCode(final Object key, final boolean compareValues) {
-  public final boolean isEmpty() {
+  public boolean isEmpty() {
-  public final int size() {
+  public int size() {
-  public final V get(final Object key) {
+  public V get(final Object key) {
-  public final boolean containsKey(final Object key) {
+  public boolean containsKey(final Object key) {
-  public final boolean containsValue(final Object value) {
+  public boolean containsValue(final Object value) {
-  public final boolean contains(final Object value) {
+  public boolean contains(final Object value) {
-  public final V put(final K key, final V value) {
+  public V put(final K key, final V value) {
-  public final V putIfAbsent(final K key, final V value) {
+  public V putIfAbsent(final K key, final V value) {
-  public final boolean create(final K key, final V value) {
+  public boolean create(final K key, final V value) {
-  public final <C, P> V create(final K key, final MapCallback<K, V, C, P> valueCreator,
-      final C context, final P createParams, final boolean lockForRead) {
+  public <C, P> V create(final K key, final MapCallback<K, V, C, P> valueCreator, final C context,
+      final P createParams, final boolean lockForRead) {
-  public final V get(final Object key, final MapCallback<K, V, ?, ?> readCallback) {
+  public V get(final Object key, final MapCallback<K, V, ?, ?> readCallback) {
-  public final <C, P> V removeConditionally(final Object key,
-      final MapCallback<K, V, C, P> condition, final C context, final P removeParams) {
+  public <C, P> V removeConditionally(final Object key, final MapCallback<K, V, C, P> condition,
+      final C context, final P removeParams) {
-  public final void putAll(final Map<? extends K, ? extends V> m) {
+  public void putAll(final Map<? extends K, ? extends V> m) {
-  public final V remove(final Object key) {
+  public V remove(final Object key) {
-  public final boolean remove(final Object key, final Object value) {
+  public boolean remove(final Object key, final Object value) {
-  public final boolean replace(final K key, final V oldValue, final V newValue) {
+  public boolean replace(final K key, final V oldValue, final V newValue) {
-  public final V replace(final K key, final V value) {
+  public V replace(final K key, final V value) {
-  public final void clear() {
+  public void clear() {
-  public final Set<K> keySet() {
+  public Set<K> keySet() {
-  public final Collection<V> values() {
+  public Collection<V> values() {
-  public final Set<Map.Entry<K, V>> entrySet() {
+  public Set<Map.Entry<K, V>> entrySet() {
-  public final Set<Map.Entry<K, V>> entrySetWithReusableEntries() {
+  public Set<Map.Entry<K, V>> entrySetWithReusableEntries() {
-  public final Enumeration<K> keys() {
+  public Enumeration<K> keys() {
-  public final Enumeration<V> elements() {
+  public Enumeration<V> elements() {
-    public final boolean hasMoreElements() {
+    public boolean hasMoreElements() {
-    final void advance() {
+    void advance() {
-    private final void copyEntriesToList() {
+    private void copyEntriesToList() {
-    public final boolean hasNext() {
+    public boolean hasNext() {
-    final HashEntry<K, V> nextEntry() {
+    HashEntry<K, V> nextEntry() {
-    public final void remove() {
+    public void remove() {
-  final class KeyIterator extends HashIterator implements Iterator<K>, Enumeration<K> {
+  class KeyIterator extends HashIterator implements Iterator<K>, Enumeration<K> {
-  final class ValueIterator extends HashIterator implements Iterator<V>, Enumeration<V> {
+  class ValueIterator extends HashIterator implements Iterator<V>, Enumeration<V> {
-    public final K getKey() {
+    public K getKey() {
-    public final V getValue() {
+    public V getValue() {
-  final class WriteThroughEntry extends SimpleReusableEntry {
+  class WriteThroughEntry extends SimpleReusableEntry {
-  final class EntryIterator extends HashIterator implements Iterator<Map.Entry<K, V>> {
+  class EntryIterator extends HashIterator implements Iterator<Map.Entry<K, V>> {
-  final class KeySet extends AbstractSet<K> {
+  class KeySet extends AbstractSet<K> {
-  final class Values extends AbstractCollection<V> {
+  class Values extends AbstractCollection<V> {
-  final class EntrySet extends AbstractSet<Map.Entry<K, V>> {
+  class EntrySet extends AbstractSet<Map.Entry<K, V>> {

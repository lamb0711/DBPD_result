GEODE-7828: Convert backing store for Redis Hashes and Sets to single regions (#4781)

* Revert "Revert "GEODE-7828: Convert backing store for Redis Hashes and Sets to single regions (#4745)" (#4780)"

This reverts commit f0982cdedf1b122f734919d0647434cca33ec254.

* Fix sporadic test failures for concurrent HSetNX
-import java.util.HashMap;
-import java.util.Map;
+import org.apache.geode.cache.TimeoutException;
+import org.apache.geode.redis.internal.AutoCloseableLock;
-  @SuppressWarnings("unchecked")
+
-    RegionProvider rC = context.getRegionProvider();
+
+    RegionProvider regionProvider = context.getRegionProvider();
-    if (isStorage())
+    if (isStorage()) {
+    }
-    if (!isStorage())
-      checkDataType(firstSetKey, RedisDataType.REDIS_SET, context);
-    Region<ByteArrayWrapper, Boolean> region =
-        (Region<ByteArrayWrapper, Boolean>) rC.getRegion(firstSetKey);
-    Set<ByteArrayWrapper> firstSet = null;
-    if (region != null) {
-      firstSet = new HashSet<ByteArrayWrapper>(region.keySet());
+    if (destination != null) {
+      try (AutoCloseableLock regionLock = withRegionLock(context, destination)) {
+        doActualSetOperation(command, context, commandElems, setsStartIndex, regionProvider,
+            destination, firstSetKey);
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+        command.setResponse(
+            Coder.getErrorResponse(context.getByteBufAllocator(), "Thread interrupted."));
+      } catch (TimeoutException e) {
+        command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
+            "Timeout acquiring lock. Please try again."));
+      }
+    } else {
+      doActualSetOperation(command, context, commandElems, setsStartIndex, regionProvider,
+          destination, firstSetKey);
-    ArrayList<Set<ByteArrayWrapper>> setList = new ArrayList<Set<ByteArrayWrapper>>();
+  }
+
+  private boolean doActualSetOperation(Command command, ExecutionHandlerContext context,
+      List<byte[]> commandElems, int setsStartIndex,
+      RegionProvider regionProvider, ByteArrayWrapper destination,
+      ByteArrayWrapper firstSetKey) {
+    Region<ByteArrayWrapper, Set<ByteArrayWrapper>> region = this.getRegion(context);
+    Set<ByteArrayWrapper> firstSet = region.get(firstSetKey);
+
+    List<Set<ByteArrayWrapper>> setList = new ArrayList<>();
-      checkDataType(key, RedisDataType.REDIS_SET, context);
-      region = (Region<ByteArrayWrapper, Boolean>) rC.getRegion(key);
-      if (region != null)
-        setList.add(region.keySet());
-      else if (this instanceof SInterExecutor)
-        setList.add(null);
-    }
-    if (setList.isEmpty()) {
-      if (isStorage()) {
-        command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), 0));
-        context.getRegionProvider().removeKey(destination);
-      } else {
-        respondBulkStrings(command, context, firstSet);
+
+      Set<ByteArrayWrapper> entry = region.get(key);
+      if (entry != null) {
+        setList.add(entry);
+      } else if (this instanceof SInterExecutor) {
+        setList.add(new HashSet<>());
-      return;
+    }
+
+    if (setList.isEmpty() && !isStorage()) {
+      respondBulkStrings(command, context, firstSet);
+      return true;
-      Region<ByteArrayWrapper, Boolean> newRegion = null; // (Region<ByteArrayWrapper, Boolean>)
-                                                          // rC.getRegion(destination);
-      rC.removeKey(destination);
+      Set<ByteArrayWrapper> newSet = null;
+      regionProvider.removeKey(destination);
-        Map<ByteArrayWrapper, Boolean> map = new HashMap<ByteArrayWrapper, Boolean>();
-        for (ByteArrayWrapper entry : resultSet)
-          map.put(entry, Boolean.TRUE);
-        if (!map.isEmpty()) {
-          newRegion = (Region<ByteArrayWrapper, Boolean>) rC.getOrCreateRegion(destination,
-              RedisDataType.REDIS_SET, context);
-          newRegion.putAll(map);
+        Set<ByteArrayWrapper> set = new HashSet<>();
+        for (ByteArrayWrapper entry : resultSet) {
+          set.add(entry);
+        }
+        if (!set.isEmpty()) {
+          newSet = new HashSet<>(set);
+          region.put(destination, newSet);
+          context.getKeyRegistrar().register(destination, RedisDataType.REDIS_SET);
-            .setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), resultSet.size()));
+            .setResponse(
+                Coder.getIntegerResponse(context.getByteBufAllocator(), resultSet.size()));
-      if (resultSet == null || resultSet.isEmpty())
+      if (resultSet == null || resultSet.isEmpty()) {
-      else
+      } else {
+      }
+    return false;

GEODE-7885: Improve RedisLockService - fix synchronization and memory leak (#4819)

* GEODE-7885: Improve RedisLockService - fix synchronization and memory leak

- RedisLockService was not able to automatically free keys/locks after
  unlocking since keys were also beging referenced in regions.
- Fix synchronization while iterating over keySet to avoid
  ConcurrentModifiactionExceptions.

-  private Map<ByteArrayWrapper, Lock> map = Collections.synchronizedMap(new WeakHashMap<>());
+  private final Map<KeyHashIdentifier, Lock> weakReferencesTolocks =
+      Collections.synchronizedMap(new WeakHashMap<>());
-    return map.size();
+    return weakReferencesTolocks.size();
+    KeyHashIdentifier lockKey = new KeyHashIdentifier(key.toBytes());
+    KeyHashIdentifier referencedKey = lockKey;
+
-    Lock oldLock = map.putIfAbsent(key, lock);
-    if (oldLock != null) {
-      lock = oldLock;
-      // we need to get a reference to the actual key object so that the backing WeakHashMap does
-      // not clean it up.
-      for (ByteArrayWrapper keyInSet : map.keySet()) {
-        if (keyInSet.equals(key)) {
-          key = keyInSet;
-          break;
+    do {
+      Lock oldLock = weakReferencesTolocks.putIfAbsent(lockKey, lock);
+
+      if (oldLock != null) {
+        lock = oldLock;
+
+        // we need to get a reference to the actual key object
+        // so that the backing WeakHashMap does not clean it up
+        // when garbage collection happens.
+        referencedKey = getReferenceToLockKey(lockKey);
+      }
+    } while (referencedKey == null);
+
+    if (!lock.tryLock(timeoutMS, TimeUnit.MILLISECONDS)) {
+      throw new TimeoutException("Couldn't get lock for " + lockKey.toString());
+    }
+
+    return new AutoCloseableLock(referencedKey, lock);
+  }
+
+  private KeyHashIdentifier getReferenceToLockKey(KeyHashIdentifier lockKey) {
+    synchronized (weakReferencesTolocks) {
+      for (KeyHashIdentifier keyInSet : weakReferencesTolocks.keySet()) {
+        if (keyInSet.equals(lockKey)) {
+          return keyInSet;
-    if (!lock.tryLock(timeoutMS, TimeUnit.MILLISECONDS)) {
-      throw new TimeoutException("Couldn't get lock for " + key.toString());
-    }
-
-    return new AutoCloseableLock(key, lock);
-  }
-
-  int getMapSize() {
-    return map.size();
+    return null;

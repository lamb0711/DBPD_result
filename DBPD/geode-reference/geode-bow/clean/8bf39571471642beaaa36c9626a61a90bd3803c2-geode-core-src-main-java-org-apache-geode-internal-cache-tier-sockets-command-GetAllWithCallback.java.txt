Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-          throws IOException, InterruptedException {
+      throws IOException, InterruptedException {
-      buffer
-              .append(servConn.getName())
-              .append(": Received getAll request (")
-              .append(msg.getPayloadLength())
-              .append(" bytes) from ")
-              .append(servConn.getSocketString())
-              .append(" for region ")
-              .append(regionName)
-              .append(" with callback ")
-              .append(callback)
-              .append(" keys ");
+      buffer.append(servConn.getName()).append(": Received getAll request (")
+          .append(msg.getPayloadLength()).append(" bytes) from ").append(servConn.getSocketString())
+          .append(" for region ").append(regionName).append(" with callback ").append(callback)
+          .append(" keys ");
-      //      if (regionName == null) (can only be null)
+      // if (regionName == null) (can only be null)
-        message = LocalizedStrings.GetAll_THE_INPUT_REGION_NAME_FOR_THE_GETALL_REQUEST_IS_NULL.toLocalizedString();
+        message = LocalizedStrings.GetAll_THE_INPUT_REGION_NAME_FOR_THE_GETALL_REQUEST_IS_NULL
+            .toLocalizedString();
-      logger.warn(LocalizedMessage.create(LocalizedStrings.TWO_ARG_COLON, new Object[]{servConn.getName(), message}));
-      writeChunkedErrorResponse(msg, MessageType.GET_ALL_DATA_ERROR, message,
-              servConn);
+      logger.warn(LocalizedMessage.create(LocalizedStrings.TWO_ARG_COLON,
+          new Object[] {servConn.getName(), message}));
+      writeChunkedErrorResponse(msg, MessageType.GET_ALL_DATA_ERROR, message, servConn);
-  private void fillAndSendGetAllResponseChunks(Region region,
-      String regionName, Object[] keys, ServerConnection servConn, Object callback)
-      throws IOException {
+  private void fillAndSendGetAllResponseChunks(Region region, String regionName, Object[] keys,
+      ServerConnection servConn, Object callback) throws IOException {
-    VersionedObjectList values = new VersionedObjectList(maximumChunkSize, false, region.getAttributes().getConcurrencyChecksEnabled(), false);
+    VersionedObjectList values = new VersionedObjectList(maximumChunkSize, false,
+        region.getAttributes().getConcurrencyChecksEnabled(), false);
-    AuthorizeRequest authzRequest = servConn.getAuthzRequest();
-    AuthorizeRequestPP postAuthzRequest = servConn.getPostAuthzRequest();
-    Get70 request = (Get70) Get70.getCommand();
-    for (int i = 0; i < numKeys; i++) {
-      // Send the intermediate chunk if necessary
-      if (values.size() == maximumChunkSize) {
-        // Send the chunk and clear the list
-        sendGetAllResponseChunk(region, values, false, servConn);
-        values.clear();
-      }
-      
-      Object key;
-      boolean keyNotPresent = false;
-      key = keys[i];
-      if (logger.isDebugEnabled()) {
-        logger.debug("{}: Getting value for key={}", servConn.getName(), key);
-      }
-      // Determine if the user authorized to get this key
-      GetOperationContext getContext = null;
-      if (authzRequest != null) {
-        try {
-          getContext = authzRequest.getAuthorize(regionName, key, callback);
-          if (logger.isDebugEnabled()) {
-            logger.debug("{}: Passed GET pre-authorization for key={}", servConn.getName(), key);
+      AuthorizeRequest authzRequest = servConn.getAuthzRequest();
+      AuthorizeRequestPP postAuthzRequest = servConn.getPostAuthzRequest();
+      Get70 request = (Get70) Get70.getCommand();
+      for (int i = 0; i < numKeys; i++) {
+        // Send the intermediate chunk if necessary
+        if (values.size() == maximumChunkSize) {
+          // Send the chunk and clear the list
+          sendGetAllResponseChunk(region, values, false, servConn);
+          values.clear();
+        }
+
+        Object key;
+        boolean keyNotPresent = false;
+        key = keys[i];
+        if (logger.isDebugEnabled()) {
+          logger.debug("{}: Getting value for key={}", servConn.getName(), key);
+        }
+        // Determine if the user authorized to get this key
+        GetOperationContext getContext = null;
+        if (authzRequest != null) {
+          try {
+            getContext = authzRequest.getAuthorize(regionName, key, callback);
+            if (logger.isDebugEnabled()) {
+              logger.debug("{}: Passed GET pre-authorization for key={}", servConn.getName(), key);
+            }
+          } catch (NotAuthorizedException ex) {
+            logger.warn(LocalizedMessage.create(
+                LocalizedStrings.GetAll_0_CAUGHT_THE_FOLLOWING_EXCEPTION_ATTEMPTING_TO_GET_VALUE_FOR_KEY_1,
+                new Object[] {servConn.getName(), key}), ex);
+            values.addExceptionPart(key, ex);
+            continue;
+        }
+
+        try {
+          this.securityService.authorizeRegionRead(regionName, key.toString());
-          logger.warn(LocalizedMessage.create(LocalizedStrings.GetAll_0_CAUGHT_THE_FOLLOWING_EXCEPTION_ATTEMPTING_TO_GET_VALUE_FOR_KEY_1,
-                  new Object[]{servConn.getName(), key}), ex);
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.GetAll_0_CAUGHT_THE_FOLLOWING_EXCEPTION_ATTEMPTING_TO_GET_VALUE_FOR_KEY_1,
+              new Object[] {servConn.getName(), key}), ex);
-      }
-      try {
-        this.securityService.authorizeRegionRead(regionName, key.toString());
-      } catch (NotAuthorizedException ex) {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.GetAll_0_CAUGHT_THE_FOLLOWING_EXCEPTION_ATTEMPTING_TO_GET_VALUE_FOR_KEY_1, new Object[] {
-          servConn.getName(),
-          key
-        }), ex);
-        values.addExceptionPart(key, ex);
-        continue;
-      }
+        // Get the value and update the statistics. Do not deserialize
+        // the value if it is a byte[].
+        // Getting a value in serialized form is pretty nasty. I split this out
+        // so the logic can be re-used by the CacheClientProxy.
+        Get70.Entry entry = request.getEntry(region, key, callback, servConn);
+        @Retained
+        final Object originalData = entry.value;
+        Object data = originalData;
+        if (logger.isDebugEnabled()) {
+          logger.debug("retrieved key={} {}", key, entry);
+        }
+        boolean addedToValues = false;
+        try {
+          boolean isObject = entry.isObject;
+          VersionTag versionTag = entry.versionTag;
+          keyNotPresent = entry.keyNotPresent;
-      // Get the value and update the statistics. Do not deserialize
-      // the value if it is a byte[].
-      // Getting a value in serialized form is pretty nasty. I split this out
-      // so the logic can be re-used by the CacheClientProxy.
-      Get70.Entry entry = request.getEntry(region, key, callback, servConn);
-      @Retained final Object originalData = entry.value;
-      Object data = originalData;
-      if (logger.isDebugEnabled()) {
-        logger.debug("retrieved key={} {}", key, entry);
-      }
-      boolean addedToValues = false;
-      try {
-        boolean isObject = entry.isObject;
-        VersionTag versionTag = entry.versionTag;
-        keyNotPresent = entry.keyNotPresent;
-
-        if (postAuthzRequest != null) {
-          try {
-            getContext = postAuthzRequest.getAuthorize(regionName, key, data,
-                isObject, getContext);
-            GetOperationContextImpl gci = (GetOperationContextImpl) getContext;
-            Object newData = gci.getRawValue();
-            if (newData != data) {
-              // user changed the value
-              isObject = getContext.isObject();
-              data = newData;
-            }
-          } catch (NotAuthorizedException ex) {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.GetAll_0_CAUGHT_THE_FOLLOWING_EXCEPTION_ATTEMPTING_TO_GET_VALUE_FOR_KEY_1,
-                new Object[]{servConn.getName(), key}), ex);
-            values.addExceptionPart(key, ex);
-            continue;
-          } finally {
-            if (getContext != null) {
-              ((GetOperationContextImpl)getContext).release();
+          if (postAuthzRequest != null) {
+            try {
+              getContext =
+                  postAuthzRequest.getAuthorize(regionName, key, data, isObject, getContext);
+              GetOperationContextImpl gci = (GetOperationContextImpl) getContext;
+              Object newData = gci.getRawValue();
+              if (newData != data) {
+                // user changed the value
+                isObject = getContext.isObject();
+                data = newData;
+              }
+            } catch (NotAuthorizedException ex) {
+              logger.warn(LocalizedMessage.create(
+                  LocalizedStrings.GetAll_0_CAUGHT_THE_FOLLOWING_EXCEPTION_ATTEMPTING_TO_GET_VALUE_FOR_KEY_1,
+                  new Object[] {servConn.getName(), key}), ex);
+              values.addExceptionPart(key, ex);
+              continue;
+            } finally {
+              if (getContext != null) {
+                ((GetOperationContextImpl) getContext).release();
+              }
-        }
-        // Add the entry to the list that will be returned to the client
-        if (keyNotPresent) {
-          values.addObjectPartForAbsentKey(key, data, versionTag);
-          addedToValues = true;
-        } else {
-          values.addObjectPart(key, data, isObject, versionTag);
-          addedToValues = true;
-        }
-      } finally {
-        if (!addedToValues || data != originalData) {
-          OffHeapHelper.release(originalData);
+          // Add the entry to the list that will be returned to the client
+          if (keyNotPresent) {
+            values.addObjectPartForAbsentKey(key, data, versionTag);
+            addedToValues = true;
+          } else {
+            values.addObjectPart(key, data, isObject, versionTag);
+            addedToValues = true;
+          }
+        } finally {
+          if (!addedToValues || data != originalData) {
+            OffHeapHelper.release(originalData);
+          }
-    }
-    // Send the last chunk even if the list is of zero size.
-    sendGetAllResponseChunk(region, values, true, servConn);
-    servConn.setAsTrue(RESPONDED);
+      // Send the last chunk even if the list is of zero size.
+      sendGetAllResponseChunk(region, values, true, servConn);
+      servConn.setAsTrue(RESPONDED);
-  private static void sendGetAllResponseChunk(Region region, ObjectPartList list,
-                                              boolean lastChunk, ServerConnection servConn) throws IOException {
+  private static void sendGetAllResponseChunk(Region region, ObjectPartList list, boolean lastChunk,
+      ServerConnection servConn) throws IOException {
-      logger.debug("{}: Sending {} getAll response chunk for region={}{}", servConn.getName(), (lastChunk ? " last " : " "), region.getFullPath(), (logger.isTraceEnabled()? " values=" + list + " chunk=<" + chunkedResponseMsg + ">" : ""));
+      logger.debug("{}: Sending {} getAll response chunk for region={}{}", servConn.getName(),
+          (lastChunk ? " last " : " "), region.getFullPath(), (logger.isTraceEnabled()
+              ? " values=" + list + " chunk=<" + chunkedResponseMsg + ">" : ""));

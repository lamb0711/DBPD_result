Merge branch 'feature/GEODE-8' into develop

+import com.gemstone.gemfire.internal.cache.EntryEventImpl.NewValueImporter;
+import com.gemstone.gemfire.internal.cache.EntryEventImpl.OldValueImporter;
+import com.gemstone.gemfire.internal.offheap.StoredObject;
+import com.gemstone.gemfire.internal.offheap.annotations.Unretained;
-import java.io.DataInput;
-import java.io.DataOutput;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Set;
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_OLD_VALUE;
+import static com.gemstone.gemfire.internal.offheap.annotations.OffHeapIdentifier.ENTRY_EVENT_NEW_VALUE;
+
+import static com.gemstone.gemfire.internal.cache.DistributedCacheOperation.VALUE_IS_BYTES;
+import static com.gemstone.gemfire.internal.cache.DistributedCacheOperation.VALUE_IS_SERIALIZED_OBJECT;
+import static com.gemstone.gemfire.internal.cache.DistributedCacheOperation.VALUE_IS_OBJECT;
-  {
+  implements NewValueImporter, OldValueImporter {
+  @Unretained(ENTRY_EVENT_NEW_VALUE) 
+  @Unretained(ENTRY_EVENT_OLD_VALUE) 
-      CachedDeserializable cd = (CachedDeserializable) event.getSerializedNewValue();
-      if (cd != null) {
-        {
-          this.deserializationPolicy =
-            DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY;
-          Object v = cd.getValue();
-          if (v instanceof byte[]) {
-            setValBytes((byte[])v);
-          }
-          else {
-            // Defer serialization until toData is called.
-            setValObj(v);
-          }
-        }
+      if (CachedDeserializableFactory.preferObject() || event.hasDelta()) {
+        this.deserializationPolicy = DistributedCacheOperation.DESERIALIZATION_POLICY_EAGER;
+      } else {
+        this.deserializationPolicy = DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY;
-      else {
-        Object v = event.getRawNewValue();
-        if (v instanceof byte[]) {
-          this.deserializationPolicy =
-            DistributedCacheOperation.DESERIALIZATION_POLICY_NONE;
-          setValBytes((byte[]) v);
-        }
-        else if (event.hasDelta()) {
-          this.deserializationPolicy =
-            DistributedCacheOperation.DESERIALIZATION_POLICY_EAGER;
-          if (event.getCachedSerializedNewValue() != null) {
-            setValBytes(event.getCachedSerializedNewValue());
-          } else {
-            setValObj(v);
-          }
-        }
-        else {
-          this.deserializationPolicy =
-            DistributedCacheOperation.DESERIALIZATION_POLICY_LAZY;
-          if (event.getCachedSerializedNewValue() != null) {
-            setValBytes(event.getCachedSerializedNewValue());
-          } else {
-            setValObj(v);
-          }
-        }
-      }
+      event.exportNewValue(this);
-      CachedDeserializable cd = (CachedDeserializable) event.getSerializedOldValue();
-      if (cd != null) {
-        {
-          this.oldValueIsSerialized = true;
-          Object o = cd.getValue();
-          if (o instanceof byte[]) {
-            setOldValBytes((byte[])o);
-          } else {
-            // Defer serialization until toData is called.
-            setOldValObj(o);
-          }
-        }
-      } else {
-        Object old = event.getRawOldValue();
-        if (old instanceof byte[]) {
-          this.oldValueIsSerialized = false;
-          setOldValBytes((byte[]) old);
-        } else {
-          this.oldValueIsSerialized = true;
-          setOldValObj(old);
-        }
-      }
+      event.exportOldValue(this);
-
+    m.setTransactionDistributed(r.getCache().getTxManager().isDistributed());
+    
-  private void setValObj(Object o) {
+  private void setValObj(@Unretained(ENTRY_EVENT_NEW_VALUE) Object o) {
-  private void setOldValObj(Object o){
+  private void setOldValObj(@Unretained(ENTRY_EVENT_OLD_VALUE) Object o){
-      if (this.oldValueIsSerialized) {
-        DataSerializer.writeObjectAsByteArray(getOldValObj(), out);
-      }
-      else {
-        DataSerializer.writeByteArray(getOldValueBytes(), out);
-      }
+      byte policy = DistributedCacheOperation.valueIsToDeserializationPolicy(oldValueIsSerialized);
+      DistributedCacheOperation.writeValue(policy, getOldValObj(), getOldValueBytes(), out);
-    byte[] newValBytes = null;
-    if (this.valObj != null) {
-      newValBytes = BlobHelper.serializeToBlob(this.valObj);
-      this.event.setCachedSerializedNewValue(newValBytes);
-    }
-    else {
-      newValBytes = getValBytes();
-    }
-    if (this.deserializationPolicy == DistributedCacheOperation.DESERIALIZATION_POLICY_EAGER) {
-      out.write(newValBytes);
-    } else {
-      DataSerializer.writeByteArray(newValBytes, out);
-    }
+    DistributedCacheOperation.writeValue(this.deserializationPolicy, this.valObj, getValBytes(), out);
-    this.event = new EntryEventImpl(
+    this.event = EntryEventImpl.create(
+    try {
-      Object oldValue = null;
-      if (this.requireOldValue) {
-        oldValue = event.getSerializedOldValue();
-        if (oldValue == null) {
-          oldValue = event.getRawOldValue();
-        }
-      }
-                oldValue,
+    } finally {
+      this.event.release(); // OFFHEAP this may be too soon to make this call
+    }
-                           Object oldValue,
-    PutReplyMessage.send(member, procId, getReplySender(dm), result, getOperation(), ex, oldValue, event);
+    PutReplyMessage.send(member, procId, getReplySender(dm), result,
+        getOperation(), ex, this, event);
+  // override reply message type from PartitionMessage
+  @Override
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm,
+      ReplyException ex, LocalRegion pr, long startTime) {
+    PutReplyMessage.send(member, procId, getReplySender(dm), result,
+        getOperation(), ex, this, null);
+  }
-  public static final class PutReplyMessage extends ReplyMessage {
+  public static final class PutReplyMessage extends ReplyMessage implements OldValueImporter {
+
+     * Set to true by the import methods if the oldValue
+     * is already serialized. In that case toData
+     * should just copy the bytes to the stream.
+     * In either case fromData just calls readObject.
+     */
+    private transient boolean oldValueIsSerialized;
+    
+    /**
+    @Unretained(ENTRY_EVENT_OLD_VALUE)
-                            Object oldValue, EntryEventImpl event) {
+                            RemotePutMessage sourceMessage,
+                            EntryEventImpl event) {
-      PutReplyMessage m = new PutReplyMessage(processorId, result, op, ex, oldValue, event.getVersionTag());
+      PutReplyMessage m = new PutReplyMessage(processorId, result, op, ex, null, event != null ? event.getVersionTag() : null);
+      
+      if (sourceMessage.requireOldValue && event != null) {
+        event.exportOldValue(m);
+      }
+
-      DataSerializer.writeObject(this.oldValue, out);
+      if (this.oldValueIsSerialized) {
+        byte[] oldValueBytes = (byte[]) this.oldValue;
+        out.write(oldValueBytes);
+      } else {
+        DataSerializer.writeObject(this.oldValue, out);
+      }
+
+    @Override
+    public boolean prefersOldSerialized() {
+      return true;
+    }
+
+    @Override
+    public boolean isUnretainedOldReferenceOk() {
+      return true;
+    }
+    
+    @Override
+    public boolean isCachedDeserializableValueOk() {
+      return true;
+    }
+
+    @Override
+    public void importOldObject(@Unretained(ENTRY_EVENT_OLD_VALUE) Object ov, boolean isSerialized) {
+      // isSerialized does not matter.
+      // toData will just call writeObject
+      // and fromData will just call readObject
+      this.oldValue = ov;
+    }
+
+    @Override
+    public void importOldBytes(byte[] ov, boolean isSerialized) {
+      if (isSerialized) {
+        this.oldValueIsSerialized = true;
+      }
+      this.oldValue = ov;
+    }
+
+  @Override
+  public boolean prefersNewSerialized() {
+    return true;
+  }
+
+  @Override
+  public boolean isUnretainedNewReferenceOk() {
+    return true;
+  }
+
+  private void setDeserializationPolicy(boolean isSerialized) {
+    if (!isSerialized) {
+      this.deserializationPolicy = DistributedCacheOperation.DESERIALIZATION_POLICY_NONE;
+    }
+  }
+
+  @Override
+  public void importNewObject(@Unretained(ENTRY_EVENT_NEW_VALUE) Object nv, boolean isSerialized) {
+    setDeserializationPolicy(isSerialized);
+    setValObj(nv);
+  }
+
+  @Override
+  public void importNewBytes(byte[] nv, boolean isSerialized) {
+    setDeserializationPolicy(isSerialized);
+    setValBytes(nv);
+  }
+
+  @Override
+  public boolean prefersOldSerialized() {
+    return true;
+  }
+
+  @Override
+  public boolean isUnretainedOldReferenceOk() {
+    return true;
+  }
+
+  @Override
+  public boolean isCachedDeserializableValueOk() {
+    return false;
+  }
+  
+  private void setOldValueIsSerialized(boolean isSerialized) {
+    if (isSerialized) {
+      if (CachedDeserializableFactory.preferObject()) {
+        this.oldValueIsSerialized = true; //VALUE_IS_OBJECT;
+      } else {
+        // Defer serialization until toData is called.
+        this.oldValueIsSerialized = true; //VALUE_IS_SERIALIZED_OBJECT;
+      }
+    } else {
+      this.oldValueIsSerialized = false; //VALUE_IS_BYTES;
+    }
+  }
+  
+  public void importOldObject(@Unretained(ENTRY_EVENT_OLD_VALUE) Object ov, boolean isSerialized) {
+    setOldValueIsSerialized(isSerialized);
+    // Defer serialization until toData is called.
+    setOldValObj(ov);
+  }
+
+  @Override
+  public void importOldBytes(byte[] ov, boolean isSerialized) {
+    setOldValueIsSerialized(isSerialized);
+    setOldValBytes(ov);
+  }

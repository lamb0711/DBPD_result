Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2010-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * one or more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import java.util.Collections;
-import com.gemstone.gemfire.InternalGemFireException;
+import com.gemstone.gemfire.distributed.internal.SerialDistributionMessage;
+import com.gemstone.gemfire.i18n.StringId;
-import com.gemstone.org.jgroups.util.StreamableFixedID;
-import com.gemstone.org.jgroups.util.StringId;
-import com.gemstone.org.jgroups.util.VersionedStreamable;
-    classesToSerializers.put("java.util.concurrent.TimeUnit",
-                             new WellKnownDS() {
-      @Override
-                               public final boolean toData(Object o, DataOutput out)
-                                 throws IOException {
-                                 TimeUnit unit = (TimeUnit) o;
-                                 out.writeByte(TIME_UNIT);
-                                 writeTimeUnit(unit, out);
-                                 return true;
-                               }});
+    classesToSerializers.put(TimeUnit.NANOSECONDS.getClass().getName(),
+        new WellKnownDS() {
+          @Override public final boolean toData(Object o, DataOutput out)
+            throws IOException {
+            out.writeByte(TIME_UNIT);
+            out.writeByte(TIME_UNIT_NANOSECONDS);
+            return true;
+          }});
+    classesToSerializers.put(TimeUnit.MICROSECONDS.getClass().getName(),
+        new WellKnownDS() {
+          @Override public final boolean toData(Object o, DataOutput out)
+            throws IOException {
+            out.writeByte(TIME_UNIT);
+            out.writeByte(TIME_UNIT_MICROSECONDS);
+            return true;
+          }});
+    classesToSerializers.put(TimeUnit.MILLISECONDS.getClass().getName(),
+        new WellKnownDS() {
+          @Override public final boolean toData(Object o, DataOutput out)
+            throws IOException {
+            out.writeByte(TIME_UNIT);
+            out.writeByte(TIME_UNIT_MILLISECONDS);
+            return true;
+          }});
+    classesToSerializers.put(TimeUnit.SECONDS.getClass().getName(),
+        new WellKnownDS() {
+          @Override public final boolean toData(Object o, DataOutput out)
+            throws IOException {
+            out.writeByte(TIME_UNIT);
+            out.writeByte(TIME_UNIT_SECONDS);
+            return true;
+          }});
+  // Writes just the header of a DataSerializableFixedID to out.
+  public static final void writeDSFIDHeader(int dsfid, DataOutput out) throws IOException {
+    if (dsfid == DataSerializableFixedID.ILLEGAL) {
+      throw new IllegalStateException(LocalizedStrings.InternalDataSerializer_ATTEMPTED_TO_SERIALIZE_ILLEGAL_DSFID.toLocalizedString());
+    }
+   if (dsfid <= Byte.MAX_VALUE && dsfid >= Byte.MIN_VALUE) {
+      out.writeByte(DS_FIXED_ID_BYTE);
+      out.writeByte(dsfid);
+    } else if (dsfid <= Short.MAX_VALUE && dsfid >= Short.MIN_VALUE) {
+      out.writeByte(DS_FIXED_ID_SHORT);
+      out.writeShort(dsfid);
+    } else {
+      out.writeByte(DS_FIXED_ID_INT);
+      out.writeInt(dsfid);
+    }
+  }
+  
-    if (dsfid == DataSerializableFixedID.ILLEGAL) {
-      throw new IllegalStateException(LocalizedStrings.InternalDataSerializer_ATTEMPTED_TO_SERIALIZE_ILLEGAL_DSFID.toLocalizedString());
-    }
-      if (dsfid != DataSerializableFixedID.NO_FIXED_ID) {
+      if (dsfid != DataSerializableFixedID.NO_FIXED_ID && dsfid != DataSerializableFixedID.ILLEGAL) {
-    if (dsfid <= Byte.MAX_VALUE && dsfid >= Byte.MIN_VALUE) {
-      out.writeByte(DS_FIXED_ID_BYTE);
-      out.writeByte(dsfid);
-    } else if (dsfid <= Short.MAX_VALUE && dsfid >= Short.MIN_VALUE) {
-      out.writeByte(DS_FIXED_ID_SHORT);
-      out.writeShort(dsfid);
-    } else if (dsfid == DataSerializableFixedID.NO_FIXED_ID) {
+    if (dsfid == DataSerializableFixedID.NO_FIXED_ID) {
-      out.writeByte(DS_FIXED_ID_INT);
-      out.writeInt(dsfid);
+      writeDSFIDHeader(dsfid, out);
-  public static final void writeStreamableFixedID(StreamableFixedID o, DataOutput out)
-      throws IOException
-    {
-      int dsfid = o.getDSFID();
-      if (dsfid == DataSerializableFixedID.ILLEGAL) {
-        throw new IllegalStateException(LocalizedStrings.InternalDataSerializer_ATTEMPTED_TO_SERIALIZE_ILLEGAL_DSFID.toLocalizedString());
-      }
-      if (dsfidToClassMap != null && logger.isTraceEnabled(LogMarker.DEBUG_DSFID)) {
-        logger.trace(LogMarker.DEBUG_DSFID, "writeDSFID {} class={}", dsfid, o.getClass());
-        if (dsfid != DataSerializableFixedID.NO_FIXED_ID) {
-          // consistency check to make sure that the same DSFID is not used
-          // for two different classes
-          String newClassName = o.getClass().getName();
-          String existingClassName = (String)dsfidToClassMap.putIfAbsent(Integer.valueOf(dsfid), newClassName);
-          if (existingClassName != null && !existingClassName.equals(newClassName)) {
-            logger.trace(LogMarker.DEBUG_DSFID, "dsfid={} is used for class {} and class {}", dsfid, existingClassName, newClassName);
-          }
-        }
-      }
-      if (dsfid <= Byte.MAX_VALUE && dsfid >= Byte.MIN_VALUE) {
-        out.writeByte(DS_FIXED_ID_BYTE);
-        out.writeByte(dsfid);
-      } else if (dsfid <= Short.MAX_VALUE && dsfid >= Short.MIN_VALUE) {
-        out.writeByte(DS_FIXED_ID_SHORT);
-        out.writeShort(dsfid);
-      } else if (dsfid == DataSerializableFixedID.NO_FIXED_ID) {
-        out.writeByte(DS_NO_FIXED_ID);
-        DataSerializer.writeClass(o.getClass(), out);
-      } else {
-        out.writeByte(DS_FIXED_ID_INT);
-        out.writeInt(dsfid);
-      }
-      try {
-        invokeToData(o, out);
-      } catch (IOException io) {
-        // Note: this is not a user code toData but one from our
-        // internal code since only GemFire product code implements DSFID
-        throw io;
-      } catch (CancelException ex) {
-        //Serializing a PDX can result in a cache closed exception. Just rethrow
-        throw ex;
-      } catch (ToDataException ex) {
-        throw ex;
-      } catch (GemFireRethrowable ex) {
-        throw ex;
-      } catch (VirtualMachineError err) {
-        SystemFailure.initiateFailure(err);
-        // If this ever returns, rethrow the error.  We're poisoned
-        // now, so don't let this thread continue.
-        throw err;
-      } catch (Throwable t) {
-        // Whenever you catch Error or Throwable, you must also
-        // catch VirtualMachineError (see above).  However, there is
-        // _still_ a possibility that you are dealing with a cascading
-        // error condition, so you also need to check to see if the JVM
-        // is still usable:
-        SystemFailure.checkFailure();
-        throw new ToDataException("toData failed on dsfid=" + dsfid+" msg:"+t.getMessage(),  t);
-      }
-    }
-
-    } else if (is662SerializationEnabled() && o.getClass().isEnum()) {
+    } else if (is662SerializationEnabled() && (o.getClass().isEnum()
+        /* for bug 52271 */ || (o.getClass().getSuperclass() != null && o.getClass().getSuperclass().isEnum()))) {
-   * Writes a <code>TimeUnit</code> to a <code>DataOutput</code>.
-   *
-   * @throws IOException
-   *         A problem occurs while writing to <code>out</code>
-   *
-   * @see #readTimeUnit
-   */
-  public static void writeTimeUnit(TimeUnit unit, DataOutput out)
-    throws IOException {
-
-    InternalDataSerializer.checkOut(out);
-
-    if (logger.isTraceEnabled(LogMarker.SERIALIZER)) {
-      logger.trace(LogMarker.SERIALIZER, "Writing TimeUnit: {}", unit);
-    }
-
-    if (unit.equals(TimeUnit.NANOSECONDS)) {
-      out.writeByte(TIME_UNIT_NANOSECONDS);
-
-    } else if (unit.equals(TimeUnit.MICROSECONDS)) {
-      out.writeByte(TIME_UNIT_MICROSECONDS);
-
-    } else if (unit.equals(TimeUnit.MILLISECONDS)) {
-      out.writeByte(TIME_UNIT_MILLISECONDS);
-
-    } else if (unit.equals(TimeUnit.SECONDS)) {
-      out.writeByte(TIME_UNIT_SECONDS);
-
-    } else {
-      throw new InternalGemFireException(LocalizedStrings.DataSerializer_UNSUPPORTED_TIMEUNIT_0.toLocalizedString(unit));
-    }
-  }
-
-  /**
-    } else if (o instanceof StreamableFixedID) {
-      if (isDebugEnabled_SERIALIZER) {
-        logger.trace(LogMarker.SERIALIZER, "Writing JGroups StreamableFixedID: {}", o);
-      }
-      StreamableFixedID sf = (StreamableFixedID)o;
-      writeStreamableFixedID(sf, out);
-    } else if (o instanceof VersionedStreamable) {
-      if (isDebugEnabled_SERIALIZER) {
-        logger.trace(LogMarker.SERIALIZER, "Writing JGroups VersionedStreamable: {}", o);
-      }
-      VersionedStreamable vs = (VersionedStreamable)o;
-      Class c = o.getClass();
-      out.writeByte(DATA_SERIALIZABLE);
-      DataSerializer.writeClass(c, out);
-      invokeToData(vs, out);
+      boolean wasDoNotCopy = false;
+      if (out instanceof HeapDataOutputStream) {
+        // To fix bug 52197 disable doNotCopy mode
+        // while serialize with an ObjectOutputStream.
+        // The problem is that ObjectOutputStream keeps
+        // an internal byte array that it reuses while serializing.
+        wasDoNotCopy = ((HeapDataOutputStream) out).setDoNotCopy(false);
+      }
+      try {
+      } finally {
+        if (wasDoNotCopy) {
+          ((HeapDataOutputStream) out).setDoNotCopy(true);
+        }
+      }
-    boolean isStreamable = (ds instanceof VersionedStreamable);
-        } else if (isStreamable) {
-          ((VersionedStreamable)ds).toData(out);
-        } else if (ds instanceof VersionedStreamable) {
-          VersionedStreamable vs = (VersionedStreamable)ds;
-          short[] ordinals = vs.getSerializationVersions();
-          if (ordinals==null || ordinals.length == 0) {
-            versions = null;
-          } else {
-            versions = new Version[ordinals.length];
-            for (int i=0; i<ordinals.length; i++) {
-              versions[i] = Version.fromOrdinalOrCurrent(ordinals[i]);
-            }
-          }
-        } else if (ds instanceof VersionedStreamable) {
-          ((VersionedStreamable)ds).fromData(in);
-      logger.fatal("exception in deserialization", ex);
-      Assert.assertTrue(o instanceof DataSerializable || (o instanceof VersionedStreamable));
+      Assert.assertTrue(o instanceof DataSerializable);
+   * Serializes a list of Integers.  The argument may be null.  Deserialize with
+   * readListOfIntegers().
+   */
+  public void writeListOfIntegers(List<Integer> list, DataOutput out) throws IOException {
+    int size;
+    if (list == null) {
+      size = -1;
+    } else {
+      size = list.size();
+    }
+    InternalDataSerializer.writeArrayLength(size, out);
+    if (size > 0) {
+      for (int i = 0; i < size; i++) {
+        out.writeInt(list.get(i).intValue());
+      }
+    }
+  }
+
+  /**
+   * Reads a list of integers serialized by writeListOfIntegers.  This
+   * will return null if the object serialized by writeListOfIntegers was null. 
+   */
+  public List<Integer> readListOfIntegers(DataInput in) throws IOException {
+    int size = InternalDataSerializer.readArrayLength(in);
+    if (size > 0) {
+      List<Integer> list = new ArrayList<Integer>(size);
+      for (int i = 0; i < size; i++) {
+        list.add(Integer.valueOf(in.readInt()));
+      }
+      return list;
+    }
+    else if (size == 0) {
+      return Collections.<Integer>emptyList();
+    }
+    else {
+      return null;
+    }
+  }
+  
+  /**
+   * Made public for unit test access.
-  static class GetMarker extends Marker {
+  public static class GetMarker extends Marker {
+     * Made public for unit test access.
-    static int WAIT_MS = Integer.getInteger("gemfire.InternalDataSerializer.WAIT_MS", 60 * 1000);
+    public static int WAIT_MS = Integer.getInteger("gemfire.InternalDataSerializer.WAIT_MS", 60 * 1000);
-  public static final class RegistrationMessage extends PooledDistributionMessage {
+  public static final class RegistrationMessage extends SerialDistributionMessage {
-  /**
-   * Interface to implement if your class supports sending itself directly to a DataOutput
-   * during serialization.
-   * Note that you are responsable for sending all the bytes that represent your instance,
-   * even bytes describing your class name if those are required.
-   * 
-   * @author darrel
-   * @since 6.6
-   */
-  public static interface Sendable {
-    /**
-     * Take all the bytes in the object and write them to the data output. It needs
-     * to be written in the GemFire wire format so that it will deserialize correctly.
-     * 
-     * @param out
-     *          the data output to send this object to
-     * @throws IOException
-     */
-    void sendTo(DataOutput out) throws IOException;
-  }
-

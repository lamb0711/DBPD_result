Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * AbstractPoolCache implements the ConnectionPoolCache interface. This is base
- * class for the all connection pools. The class also implements the
- * Serializable interface. The pool maintain a list for keeping the available
- * connections(not assigned to user) and the active connections(assigned to
- * user) This is a thread safe class.
+ * AbstractPoolCache implements the ConnectionPoolCache interface. This is base class for the all
+ * connection pools. The class also implements the Serializable interface. The pool maintain a list
+ * for keeping the available connections(not assigned to user) and the active connections(assigned
+ * to user) This is a thread safe class.
- *         Second Version .Modified the synchronization code & objects on
- *         which locks were being taken. Changed the logic of retrieval of
- *         connection & returning of connection. The beahviour of cleaner thread
- *         has been modified such that it waits on activeCache if it is empty.
- *         Prevention of deadlocks & optmization of code.
+ * Second Version .Modified the synchronization code & objects on which locks were being taken.
+ * Changed the logic of retrieval of connection & returning of connection. The beahviour of cleaner
+ * thread has been modified such that it waits on activeCache if it is empty. Prevention of
+ * deadlocks & optmization of code.
-public abstract class AbstractPoolCache implements ConnectionPoolCache,
-    Serializable {
+public abstract class AbstractPoolCache implements ConnectionPoolCache, Serializable {
-  
+
-//  private String error = "";
+  // private String error = "";
-  //Asif:expirationTime is for the available
-  //connection which are expired in milliseconds
+  // Asif:expirationTime is for the available
+  // connection which are expired in milliseconds
-  //Asif:timeOut is for the Active connection which are time out in
+  // Asif:timeOut is for the Active connection which are time out in
-  //Client Timeout in milliseconds
+  // Client Timeout in milliseconds
-//  private final boolean DEBUG = false;
+  // private final boolean DEBUG = false;
-  private Thread th = null;//cleaner thread
+  private Thread th = null;// cleaner thread
-   * @param configs The ConfiguredDataSourceProperties object containing the
-   *          configuration for the pool.
+   * @param configs The ConfiguredDataSourceProperties object containing the configuration for the
+   *        pool.
-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value="SC_START_IN_CTOR",
-      justification="the thread started is a cleanup thread and is not active until there is a timeout tx")
-  public AbstractPoolCache(EventListener eventListner,
-      ConfiguredDataSourceProperties configs) throws PoolException {
+  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = "SC_START_IN_CTOR",
+      justification = "the thread started is a cleanup thread and is not active until there is a timeout tx")
+  public AbstractPoolCache(EventListener eventListner, ConfiguredDataSourceProperties configs)
+      throws PoolException {
-        }
-        catch (Exception ex) {
+        } catch (Exception ex) {
-              logger.debug("AbstractPoolCache::initializePool:Error in creating connection", ex.getCause());
+            logger.debug("AbstractPoolCache::initializePool:Error in creating connection",
+                ex.getCause());
-   * public abstract void checkCredentials(String user, String pass)
+   *         public abstract void checkCredentials(String user, String pass)
-   * Returns the connection to the available pool Asif: When the connection is
-   * returned to the pool, notify any one thread waiting on availableCache so
-   * that it can go into connection seeking state.
+   * Returns the connection to the available pool Asif: When the connection is returned to the pool,
+   * notify any one thread waiting on availableCache so that it can go into connection seeking
+   * state.
-   *  
+   * 
-      //Asif: Take a lock on activeCache while removing the Connection
+      // Asif: Take a lock on activeCache while removing the Connection
-      //individual connection rather than complete activeMap
+      // individual connection rather than complete activeMap
-      //returning their own connections
+      // returning their own connections
-          //Asif: Remove teh connection from activeCache
+          // Asif: Remove teh connection from activeCache
-      //Asif: take the lock on availableCache & decrement the
+      // Asif: take the lock on availableCache & decrement the
-        this.availableCache.put(connectionObject, Long.valueOf(System
-            .currentTimeMillis()));
+        this.availableCache.put(connectionObject, Long.valueOf(System.currentTimeMillis()));
-   * @param connectionObject Asif: This function will set the timestamp
-   *          associated with the Connection object such that it will get timed
-   *          out by the cleaner thread. Normally when this function is called,
-   *          the connection object will be present in activeCache as there is
-   *          no way client can return the object. But it is possible that the
-   *          cleaner thread may have already picked it up ,so we still have to
-   *          check whether it is contained in the map or not
-   *  
+   * @param connectionObject Asif: This function will set the timestamp associated with the
+   *        Connection object such that it will get timed out by the cleaner thread. Normally when
+   *        this function is called, the connection object will be present in activeCache as there
+   *        is no way client can return the object. But it is possible that the cleaner thread may
+   *        have already picked it up ,so we still have to check whether it is contained in the map
+   *        or not
+   * 
-        //Change the time stamp associated with the object
+        // Change the time stamp associated with the object
-   * Gets the connection from the pool. The specified user and password are
-   * used. If the available pool is not empty a connection is fetched from the
-   * available pool. If the available pool is empty and the total connections in
-   * the pool(available + active) are less then the Max limit, a new connection
-   * is created and returned to the client. If the Max limit is reached the
-   * client waits for the connection to be available.
+   * Gets the connection from the pool. The specified user and password are used. If the available
+   * pool is not empty a connection is fetched from the available pool. If the available pool is
+   * empty and the total connections in the pool(available + active) are less then the Max limit, a
+   * new connection is created and returned to the client. If the Max limit is reached the client
+   * waits for the connection to be available.
-   * Asif: The client thread checks if the total number of active connections
-   * have exhausted the limit. If yes it waits on the availableCache. When
-   * another thread returns the connection to the pool, the waiting thread gets
-   * notified. If a thread experiences timeout while waiting , a SQLException
-   * will be thrown. Other case is that there are available connections in map.
-   * Now while getting connection from avaialbel map , we may or may not obtain
-   * connetion bcoz the connection in available map may have expired. But if the
-   * checkOutConnection() returns null , this iteslf guarantees that atleast one
-   * connection expired so the current thread can safely demand one new
-   * connection.
+   * Asif: The client thread checks if the total number of active connections have exhausted the
+   * limit. If yes it waits on the availableCache. When another thread returns the connection to the
+   * pool, the waiting thread gets notified. If a thread experiences timeout while waiting , a
+   * SQLException will be thrown. Other case is that there are available connections in map. Now
+   * while getting connection from avaialbel map , we may or may not obtain connetion bcoz the
+   * connection in available map may have expired. But if the checkOutConnection() returns null ,
+   * this iteslf guarantees that atleast one connection expired so the current thread can safely
+   * demand one new connection.
-    //checkCredentials(username, password);
-    /*if (availableCache == null) {
-      synchronized (this) {
-        if (availableCache == null) {
-          initializePool();
-        }
-      }
-    }*/
+    // checkCredentials(username, password);
+    /*
+     * if (availableCache == null) { synchronized (this) { if (availableCache == null) {
+     * initializePool(); } } }
+     */
-      while ((totalConnections - activeConnections) == 0
-          && totalConnections == MAX_LIMIT) {
+      while ((totalConnections - activeConnections) == 0 && totalConnections == MAX_LIMIT) {
-              throw new PoolException(LocalizedStrings.AbstractPoolCache_ABSTRACTPOOLEDCACHEGETPOOLEDCONNECTIONFROMPOOLLOGIN_TIMEOUT_EXCEEDED.toLocalizedString());
-        }
-        catch (InterruptedException e) {
+            throw new PoolException(
+                LocalizedStrings.AbstractPoolCache_ABSTRACTPOOLEDCACHEGETPOOLEDCONNECTIONFROMPOOLLOGIN_TIMEOUT_EXCEEDED
+                    .toLocalizedString());
+        } catch (InterruptedException e) {
-            logger.debug("AbstractPooledCache::getPooledConnectionFromPool:InterruptedException in waiting thread");
+            logger.debug(
+                "AbstractPooledCache::getPooledConnectionFromPool:InterruptedException in waiting thread");
-          throw new PoolException(LocalizedStrings.AbstractPoolCache_ABSTRACTPOOLEDCACHEGETPOOLEDCONNECTIONFROMPOOLINTERRUPTEDEXCEPTION_IN_WAITING_THREAD.toLocalizedString());
+          throw new PoolException(
+              LocalizedStrings.AbstractPoolCache_ABSTRACTPOOLEDCACHEGETPOOLEDCONNECTIONFROMPOOLINTERRUPTEDEXCEPTION_IN_WAITING_THREAD
+                  .toLocalizedString());
-    //Asif: Notify the cleaner thread if it is waiting
+    // Asif: Notify the cleaner thread if it is waiting
-   * Remove a connection from the pool. Modified by Asif : This function is
-   * called from a synch block where the lock is taken on this.availableCache
+   * Remove a connection from the pool. Modified by Asif : This function is called from a synch
+   * block where the lock is taken on this.availableCache
-//    boolean expiryCheck = false;
+    // boolean expiryCheck = false;
-      }
-      else {
-        //Asif : Take a lock on expiredConns, so that clean up thread
+      } else {
+        // Asif : Take a lock on expiredConns, so that clean up thread
-        //Asif :Reduce the total number of available connections
+        // Asif :Reduce the total number of available connections
-        //It will get notified whenever there is an elemnt added
+        // It will get notified whenever there is an elemnt added
-  //Code for Clean up thread
+  // Code for Clean up thread
-   * Asif: The Cleaner thread calls this function periodically to clear the
-   * expired connection list & also to add those connections to expiry list ,
-   * which have timed out while being active. The thread first iterates over the
-   * map of active connections. It does by getting array of keys contained in
-   * the map so that there is no backing of Map. It collects all the actiev
-   * connections timeout & if there is atleast one such connection , it will
-   * issue a notify or notify all ( if more than one connections have timed
-   * out). After that it will just clear the list of expired connections *
+   * Asif: The Cleaner thread calls this function periodically to clear the expired connection list
+   * & also to add those connections to expiry list , which have timed out while being active. The
+   * thread first iterates over the map of active connections. It does by getting array of keys
+   * contained in the map so that there is no backing of Map. It collects all the actiev connections
+   * timeout & if there is atleast one such connection , it will issue a notify or notify all ( if
+   * more than one connections have timed out). After that it will just clear the list of expired
+   * connections *
-    //Asif Get an array of keys in the activeConnection map
-    //Since we are using LinkedHashMap the keys are guaranteed to be in order
+    // Asif Get an array of keys in the activeConnection map
+    // Since we are using LinkedHashMap the keys are guaranteed to be in order
-    //  PooledConnection[] activeConnArr = (PooledConnection[])
+    // PooledConnection[] activeConnArr = (PooledConnection[])
-    //int len = activeConnArr.length;
-    //for (int i = 0; i < len; ++i) {
+    // int len = activeConnArr.length;
+    // for (int i = 0; i < len; ++i) {
-      //Get the connection which is the oldest
+      // Get the connection which is the oldest
-        }
-        else {
+        } else {
-          //Asif: We need to again get the assocaited value & check
-          //if it is same as before. As it is possibel that by the time
-          //we reach here , the connection was returned to available map
+          // Asif: We need to again get the assocaited value & check
+          // if it is same as before. As it is possibel that by the time
+          // we reach here , the connection was returned to available map
-          //at the extreme end !!! . So we cannot use it.
+          // at the extreme end !!! . So we cannot use it.
-          //Check the timeout
+          // Check the timeout
-            }
-            else {
-              //AsifTODO: Just keep a final expitry time
+            } else {
+              // AsifTODO: Just keep a final expitry time
-      //Asif : In case only one connection timed out , take a lock
-      //on availableCache & call notify . If more than one timed out
+      // Asif : In case only one connection timed out , take a lock
+      // on availableCache & call notify . If more than one timed out
-    //Asif : Create a temp list which copies the connections in
+    // Asif : Create a temp list which copies the connections in
-    //Asif: destroy the connections contained in the temp list
+    // Asif: destroy the connections contained in the temp list
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-          logger.debug("AbstractPoolCache::clearUp: Exception in interrupting the thread", e);
+        logger.debug("AbstractPoolCache::clearUp: Exception in interrupting the thread", e);
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-        logger.debug("AbstractPoolCache::clearUp: Exception in closing connections. Ignoring this exception)");
+        logger.debug(
+            "AbstractPoolCache::clearUp: Exception in closing connections. Ignoring this exception)");
-    //private int sleepTime;
+    // private int sleepTime;
-     * public ConnectionCleanUpThread(int time) { // poolCache = pool; sleepTime =
-     * time;
+     * public ConnectionCleanUpThread(int time) { // poolCache = pool; sleepTime = time;
-          if (sleepTime != -1) 
+          if (sleepTime != -1)
-          //Asif : The cleaner thread will wait on activeCache if it is
+          // Asif : The cleaner thread will wait on activeCache if it is
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-        }
-        catch (CancelException e) {
+        } catch (CancelException e) {
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
-              logger.debug("ConnectionCleanUpThread::run: Thread encountered Exception. e={}. Ignoring the exception",
-                  e.getMessage(), e);
+            logger.debug(
+                "ConnectionCleanUpThread::run: Thread encountered Exception. e={}. Ignoring the exception",
+                e.getMessage(), e);
-    
+

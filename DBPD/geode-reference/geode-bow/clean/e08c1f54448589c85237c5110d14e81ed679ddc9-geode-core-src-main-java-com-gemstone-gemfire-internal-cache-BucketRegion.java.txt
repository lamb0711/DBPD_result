GEODE-599: fix clear with concurrent writes

Cache modification lock was being released before operation distribution to other members.
This provided a small window in which an operation from another thread could update the
region prior to the other members receiving notification (i.e. down leveled)

This closes #232

-    beginLocalWrite(event);
+    LocalRegion lr = event.getLocalRegion();
+    AbstractRegionMap arm = ((AbstractRegionMap) lr.getRegionMap());
-      
-      if (!hasSeenEvent(event)) {
-        this.entries.updateEntryVersion(event);
-      } else {
-        if (logger.isTraceEnabled(LogMarker.DM)) {
-          logger.trace(LogMarker.DM, "BR.basicUpdateEntryVersion: this cache has already seen this event {}", event);
+      arm.lockForCacheModification(lr, event);
+      beginLocalWrite(event);
+      try {      
+        if (!hasSeenEvent(event)) {
+          this.entries.updateEntryVersion(event);
+        } else {
+          if (logger.isTraceEnabled(LogMarker.DM)) {
+            logger.trace(LogMarker.DM, "BR.basicUpdateEntryVersion: this cache has already seen this event {}", event);
+          }
+        if (!event.isOriginRemote() && getBucketAdvisor().isPrimary()) {
+          // This cache has processed the event, forward operation
+          // and event messages to backup buckets
+          if (!getConcurrencyChecksEnabled() || event.hasValidVersionTag()) {
+            distributeUpdateEntryVersionOperation(event);
+          }
+        }
+        return;
+      } finally {
+        endLocalWrite(event);
-      if (!event.isOriginRemote() && getBucketAdvisor().isPrimary()) {
-        // This cache has processed the event, forward operation
-        // and event messages to backup buckets
-    	if (!getConcurrencyChecksEnabled() || event.hasValidVersionTag()) {
-          distributeUpdateEntryVersionOperation(event);
-    	}
-      }
-      return;
-      endLocalWrite(event);
+      arm.releaseCacheModificationLock(event.getLocalRegion(), event);

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * EventTracker tracks the last sequence number for a particular
- * memberID:threadID.  It is used to avoid replaying events in
- * client/server and partitioned-region configurations.
+ * EventTracker tracks the last sequence number for a particular memberID:threadID. It is used to
+ * avoid replaying events in client/server and partitioned-region configurations.
-public class EventTracker
-{
+public class EventTracker {
-  
+
-   * a mapping of originator to the last event applied to this cache 
+   * a mapping of originator to the last event applied to this cache
-   * Keys are instances of {@link ThreadIdentifier}, values are instances
-   * of {@link org.apache.geode.internal.cache.EventTracker.EventSeqnoHolder}.
+   * Keys are instances of {@link ThreadIdentifier}, values are instances of
+   * {@link org.apache.geode.internal.cache.EventTracker.EventSeqnoHolder}.
-  protected final ConcurrentMap<ThreadIdentifier, EventSeqnoHolder> recordedEvents 
-      = new ConcurrentHashMap<ThreadIdentifier, EventSeqnoHolder>(100);
- 
-  /** a mapping of originator to bulkOp's last status (true means
-   * finished processing) applied to this cache. 
+  protected final ConcurrentMap<ThreadIdentifier, EventSeqnoHolder> recordedEvents =
+      new ConcurrentHashMap<ThreadIdentifier, EventSeqnoHolder>(100);
+
+  /**
+   * a mapping of originator to bulkOp's last status (true means finished processing) applied to
+   * this cache.
-   * Keys are instances of @link {@link ThreadIdentifier}, values are instances
-   * of {@link BulkOpProcessed}.
+   * Keys are instances of @link {@link ThreadIdentifier}, values are instances of
+   * {@link BulkOpProcessed}.
-  private final ConcurrentMap<ThreadIdentifier, BulkOpProcessed> recordedBulkOps 
-      = new ConcurrentHashMap<ThreadIdentifier, BulkOpProcessed>(100);
-  
-  /** a mapping of originator to bulkOperation's last version tags. This map
-   * differs from {@link #recordedBulkOps} in that the thread identifier used
-   * here is the base member id and thread id of the bulk op, as opposed to the fake
-   * thread id which is assigned for each bucket.
+  private final ConcurrentMap<ThreadIdentifier, BulkOpProcessed> recordedBulkOps =
+      new ConcurrentHashMap<ThreadIdentifier, BulkOpProcessed>(100);
+
+  /**
+   * a mapping of originator to bulkOperation's last version tags. This map differs from
+   * {@link #recordedBulkOps} in that the thread identifier used here is the base member id and
+   * thread id of the bulk op, as opposed to the fake thread id which is assigned for each bucket.
-   * Keys are instances of @link {@link ThreadIdentifier}, values are instances
-   * of {@link BulkOpHolder}.
+   * Keys are instances of @link {@link ThreadIdentifier}, values are instances of
+   * {@link BulkOpHolder}.
-  private final ConcurrentMap<ThreadIdentifier, BulkOpHolder> recordedBulkOpVersionTags 
-      = new ConcurrentHashMap<ThreadIdentifier, BulkOpHolder>(100);
-  
+  private final ConcurrentMap<ThreadIdentifier, BulkOpHolder> recordedBulkOpVersionTags =
+      new ConcurrentHashMap<ThreadIdentifier, BulkOpHolder>(100);
+
-   * The member that the region corresponding to this tracker (if any)
-   * received its initial image from (if a replicate)
+   * The member that the region corresponding to this tracker (if any) received its initial image
+   * from (if a replicate)
- 
+
- 
+
-  
+
-   * whether or not this tracker has been initialized with state from
-   * another process
+   * whether or not this tracker has been initialized with state from another process
- 
+
-   * object used to wait for initialization 
+   * object used to wait for initialization
-  
+
-  * Initialize the EventTracker's timer task.  This is stored in the cache
-  * for tracking and shutdown purposes
-  * @param cache the cache to schedule tasks with
-  */
+   * Initialize the EventTracker's timer task. This is stored in the cache for tracking and shutdown
+   * purposes
+   * 
+   * @param cache the cache to schedule tasks with
+   */
-    cache.getCCPTimer().scheduleAtFixedRate(result,
-        expiryTime, expiryTime);
-    //schedule(result, expiryTime);
+    cache.getCCPTimer().scheduleAtFixedRate(result, expiryTime, expiryTime);
+    // schedule(result, expiryTime);
-  
+
+   * 
- 
- /**
-  * Create an event tracker
-  * @param region the cache region to associate with this tracker
-  */
+
+  /**
+   * Create an event tracker
+   * 
+   * @param region the cache region to associate with this tracker
+   */
-   this.cache = region.cache;
-   this.name = "Event Tracker for " + region.getName();
-   this.initializationLatch = new StoppableCountDownLatch(region.stopper, 1);
- }
+    this.cache = region.cache;
+    this.name = "Event Tracker for " + region.getName();
+    this.initializationLatch = new StoppableCountDownLatch(region.stopper, 1);
+  }
-  
+
-  
+
-   * retrieve a deep copy of the state of the event tracker.  Synchronization
-   * is not used while copying the tracker's state.
+   * retrieve a deep copy of the state of the event tracker. Synchronization is not used while
+   * copying the tracker's state.
-    Map<ThreadIdentifier, EventSeqnoHolder> result = new HashMap<ThreadIdentifier, EventSeqnoHolder>(recordedEvents.size());
-    for (Iterator<Map.Entry<ThreadIdentifier, EventSeqnoHolder>> it=recordedEvents.entrySet().iterator(); it.hasNext(); ) {
+    Map<ThreadIdentifier, EventSeqnoHolder> result =
+        new HashMap<ThreadIdentifier, EventSeqnoHolder>(recordedEvents.size());
+    for (Iterator<Map.Entry<ThreadIdentifier, EventSeqnoHolder>> it =
+        recordedEvents.entrySet().iterator(); it.hasNext();) {
-      result.put(entry.getKey(), new EventSeqnoHolder(
-          holder.lastSeqno, null)); // don't transfer version tags - adds too much bulk just so we can do client tag recovery
+      result.put(entry.getKey(), new EventSeqnoHolder(holder.lastSeqno, null)); // don't transfer
+                                                                                // version tags -
+                                                                                // adds too much
+                                                                                // bulk just so we
+                                                                                // can do client tag
+                                                                                // recovery
-  
+
+   * 
-  public void recordState(InternalDistributedMember provider, Map<ThreadIdentifier, EventSeqnoHolder> state) {
+  public void recordState(InternalDistributedMember provider,
+      Map<ThreadIdentifier, EventSeqnoHolder> state) {
-      sb.append("Recording initial state for ")
-        .append(this.name)
-        .append(": ");
+      sb.append("Recording initial state for ").append(this.name).append(": ");
-    for (Iterator<Map.Entry<ThreadIdentifier, EventSeqnoHolder>> it=state.entrySet().iterator(); it.hasNext(); ) {
+    for (Iterator<Map.Entry<ThreadIdentifier, EventSeqnoHolder>> it =
+        state.entrySet().iterator(); it.hasNext();) {
-        sb.append("\n  ")
-          .append(entry.getKey().expensiveToString())
-          .append("; sequenceID=")
-          .append(entry.getValue()); 
+        sb.append("\n  ").append(entry.getKey().expensiveToString()).append("; sequenceID=")
+            .append(entry.getValue());
-    // fix for bug 41622 - hang in GII.  This keeps ops from waiting for the
+    // fix for bug 41622 - hang in GII. This keeps ops from waiting for the
-  
+
-  
+
-  
+
-   * Record an event sequence id if it is higher than what we currently have.
-   * This is intended for use during initial image transfer.
+   * Record an event sequence id if it is higher than what we currently have. This is intended for
+   * use during initial image transfer.
+   * 
-  protected void recordSeqno(ThreadIdentifier membershipID, EventSeqnoHolder evhObj){
+  protected void recordSeqno(ThreadIdentifier membershipID, EventSeqnoHolder evhObj) {
-  
+
-   * Record an event sequence id if it is higher than what we currently have.
-   * This is intended for use during initial image transfer.
+   * Record an event sequence id if it is higher than what we currently have. This is intended for
+   * use during initial image transfer.
+   * 
-      EventSeqnoHolder oldEvh = recordedEvents.putIfAbsent(
-          threadID, evh);
+      EventSeqnoHolder oldEvh = recordedEvents.putIfAbsent(threadID, evh);
-        synchronized(oldEvh) {
+        synchronized (oldEvh) {
-          }
-          else {
+          } else {
-//              Exception e = oldEvh.context;
-//              oldEvh.context = new Exception("stack trace");
-//              oldEvh.context.initCause(e);
+              // Exception e = oldEvh.context;
+              // oldEvh.context = new Exception("stack trace");
+              // oldEvh.context.initCause(e);
-      }
-      else {
+      } else {
-//        evh.context = new Exception("stack trace");
+        // evh.context = new Exception("stack trace");
-  
+
-    LocalRegion lr = (LocalRegion)event.getRegion();
+    LocalRegion lr = (LocalRegion) event.getRegion();
-    ThreadIdentifier membershipID = new ThreadIdentifier(eventID.getMembershipID(),
-        eventID.getThreadID());
+    ThreadIdentifier membershipID =
+        new ThreadIdentifier(eventID.getMembershipID(), eventID.getThreadID());
-    if (lr.getServerProxy() == null/* && event.hasClientOrigin()*/) { // clients do not need to store version tags for replayed events
+    if (lr.getServerProxy() == null/* && event.hasClientOrigin() */) { // clients do not need to
+                                                                       // store version tags for
+                                                                       // replayed events
-      RegionVersionVector v = ((LocalRegion)event.getRegion()).getVersionVector();
+      RegionVersionVector v = ((LocalRegion) event.getRegion()).getVersionVector();
-    
-    //If this is a bulkOp, and concurrency checks are enabled, we need to
-    //save the version tag in case we retry.
-    if (lr.concurrencyChecksEnabled 
-        && (event.getOperation().isPutAll() || event.getOperation().isRemoveAll()) && lr.getServerProxy() == null) {
+
+    // If this is a bulkOp, and concurrency checks are enabled, we need to
+    // save the version tag in case we retry.
+    if (lr.concurrencyChecksEnabled
+        && (event.getOperation().isPutAll() || event.getOperation().isRemoveAll())
+        && lr.getServerProxy() == null) {
-    if (logger.isTraceEnabled()){
+    if (logger.isTraceEnabled()) {
-    
+
-    
+
-      logger.debug("recording bulkOp event {} {} {} op={}", tid.expensiveToString(),
-          eventID, tag, event.getOperation());
+      logger.debug("recording bulkOp event {} {} {} op={}", tid.expensiveToString(), eventID, tag,
+          event.getOperation());
-    RegionVersionVector v = ((LocalRegion)event.getRegion()).getVersionVector();
+    RegionVersionVector v = ((LocalRegion) event.getRegion()).getVersionVector();
-    //Loop until we can successfully update the recorded bulk operations
-    //For this thread id.
+    // Loop until we can successfully update the recorded bulk operations
+    // For this thread id.
-      if(bulkOpTracker == null) {
+      if (bulkOpTracker == null) {
-        if(old != null) {
+        if (old != null) {
-      synchronized(bulkOpTracker) {
-        if(bulkOpTracker.removed) {
+      synchronized (bulkOpTracker) {
+        if (bulkOpTracker.removed) {
-        
-        //Add the version tag for bulkOp event.
+
+        // Add the version tag for bulkOp event.
-    } while(retry);
+    } while (retry);
-  
+
-//  ClientProxyMembershipID membershipID = event.getContext();
+    // ClientProxyMembershipID membershipID = event.getContext();
-  
+
-    ThreadIdentifier membershipID = new ThreadIdentifier(
-        eventID.getMembershipID(), eventID.getThreadID());
-//  if (membershipID == null || eventID == null) {
-//    return false;
-//  }
-        
+    ThreadIdentifier membershipID =
+        new ThreadIdentifier(eventID.getMembershipID(), eventID.getThreadID());
+    // if (membershipID == null || eventID == null) {
+    // return false;
+    // }
+
-    
+
-        logger.trace(LogMarker.DISTRIBUTION_BRIDGE_SERVER, "Cache encountered replay of event with ID {}.  Highest recorded for this source is {}",
+        logger.trace(LogMarker.DISTRIBUTION_BRIDGE_SERVER,
+            "Cache encountered replay of event with ID {}.  Highest recorded for this source is {}",
-        ((EntryEventImpl)tagHolder).setVersionTag(evh.versionTag);
+        ((EntryEventImpl) tagHolder).setVersionTag(evh.versionTag);
-    ThreadIdentifier threadID = new ThreadIdentifier(
-        eventID.getMembershipID(), eventID.getThreadID());
-        
+    ThreadIdentifier threadID =
+        new ThreadIdentifier(eventID.getMembershipID(), eventID.getThreadID());
+
-        logger.debug("search for version tag failed as no event is recorded for {}", threadID.expensiveToString());
+        logger.debug("search for version tag failed as no event is recorded for {}",
+            threadID.expensiveToString());
-    
+
-        logger.debug("search for version tag located last event for {}: {}",threadID.expensiveToString(), evh);
+        logger.debug("search for version tag located last event for {}: {}",
+            threadID.expensiveToString(), evh);
-        logger.trace(LogMarker.DISTRIBUTION_BRIDGE_SERVER, "Could not recover version tag.  Found event holder with no version tag for {}", eventID);
+        logger.trace(LogMarker.DISTRIBUTION_BRIDGE_SERVER,
+            "Could not recover version tag.  Found event holder with no version tag for {}",
+            eventID);
-  
+
-    ThreadIdentifier threadID = new ThreadIdentifier(
-        eventID.getMembershipID(), eventID.getThreadID());
-        
+    ThreadIdentifier threadID =
+        new ThreadIdentifier(eventID.getMembershipID(), eventID.getThreadID());
+
-        logger.debug("search for version tag failed as no event is recorded for {}", threadID.expensiveToString());
+        logger.debug("search for version tag failed as no event is recorded for {}",
+            threadID.expensiveToString());
-    
+
-        logger.debug("search for version tag located last event for {}: {} {}",threadID.expensiveToString(), evh, eventID.getSequenceID() );
+        logger.debug("search for version tag located last event for {}: {} {}",
+            threadID.expensiveToString(), evh, eventID.getSequenceID());
-      
+
-        logger.trace(LogMarker.DISTRIBUTION_BRIDGE_SERVER, "Could not recover version tag.  Found event holder with no version tag for {}", eventID);
+        logger.trace(LogMarker.DISTRIBUTION_BRIDGE_SERVER,
+            "Could not recover version tag.  Found event holder with no version tag for {}",
+            eventID);
-  
-  
+
+
-    ThreadIdentifier threadID = new ThreadIdentifier(
-        eventID.getMembershipID(), eventID.getThreadID());
-        
+    ThreadIdentifier threadID =
+        new ThreadIdentifier(eventID.getMembershipID(), eventID.getThreadID());
+
-        logger.debug("search for version tag failed as no events are recorded for {}", threadID.expensiveToString());
+        logger.debug("search for version tag failed as no events are recorded for {}",
+            threadID.expensiveToString());
-    
+
-        logger.debug("search for version tag located event holder for {}: {}", threadID.expensiveToString(), evh);
+        logger.debug("search for version tag located event holder for {}: {}",
+            threadID.expensiveToString(), evh);
-                   || ((LocalRegion)event.getRegion()).isUsedForPartitionedRegionBucket();
-      return (!isClient &&   // ignore if it originated on a server, and
-           isEntry &&        // it affects an entry and
-          !isPr);            // is not on a PR
+          || ((LocalRegion) event.getRegion()).isUsedForPartitionedRegionBucket();
+      return (!isClient && // ignore if it originated on a server, and
+          isEntry && // it affects an entry and
+          !isPr); // is not on a PR
-   * A routine to provide synchronization running based on <memberShipID, threadID> 
-   * of the requesting client
+   * A routine to provide synchronization running based on <memberShipID, threadID> of the
+   * requesting client
+   * 
-    ThreadIdentifier membershipID = new ThreadIdentifier(
-      eventID.getMembershipID(), eventID.getThreadID());
+    ThreadIdentifier membershipID =
+        new ThreadIdentifier(eventID.getMembershipID(), eventID.getThreadID());
-    BulkOpProcessed opSyncObj = recordedBulkOps.putIfAbsent(membershipID, new BulkOpProcessed(false));
+    BulkOpProcessed opSyncObj =
+        recordedBulkOps.putIfAbsent(membershipID, new BulkOpProcessed(false));
-        }
-        else {
+        } else {
-          
-          //Perform the bulk op
+
+          // Perform the bulk op
-          // set to true in case another thread is waiting at sync 
+          // set to true in case another thread is waiting at sync
-      }
-      finally {
+      } finally {
-  
+
-   * Called when a bulkOp is started on the local region. Used to clear
-   * event tracker state from the last bulkOp.
+   * Called when a bulkOp is started on the local region. Used to clear event tracker state from the
+   * last bulkOp.
-  
+
-  
+
-    return (this.initialImageProvider != null)
-      && (mbr != null)
-      && this.initialImageProvider.equals(mbr);
+    return (this.initialImageProvider != null) && (mbr != null)
+        && this.initialImageProvider.equals(mbr);
-  
+
-  
+
-    return ""+this.name+"(initialized=" + this.initialized+")";
+    return "" + this.name + "(initialized=" + this.initialized + ")";
-  
+
-   * A sequence number tracker to keep events from clients from being
-   * re-applied to the cache if they've already been seen.
+   * A sequence number tracker to keep events from clients from being re-applied to the cache if
+   * they've already been seen.
+   * 
-    /** event sequence number.  These  */
+    /** event sequence number. These */
-    
+
-    
+
-    
+
-    
+
-//    transient Exception context;
-    
+    // transient Exception context;
+
-    
-    public EventSeqnoHolder() {
-    }
-    
+
+    public EventSeqnoHolder() {}
+
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      versionTag = (VersionTag)DataSerializer.readObject(in);
+      versionTag = (VersionTag) DataSerializer.readObject(in);
-   * membershipID and threadID in the cache
-   * processed is true means the bulk op is processed by one thread 
-   * no need to redo it by other threads.
+   * membershipID and threadID in the cache processed is true means the bulk op is processed by one
+   * thread no need to redo it by other threads.
+   * 
-  
+
-     * creates a new instance to save status of a bulk op 
-     * @param status true if the op has been processed 
+     * creates a new instance to save status of a bulk op
+     * 
+     * @param status true if the op has been processed
-    
+
-     * @param status true if the op has been processed 
+     * 
+     * @param status true if the op has been processed
-    
+
+     * 
-    
+
-      return "BULKOP("+this.processed+")";
+      return "BULKOP(" + this.processed + ")";
-  
+
-   * @since GemFire 7.0
-   * protected for test purposes only.
+   * 
+   * @since GemFire 7.0 protected for test purposes only.
-  
+
-     * creates a new instance to save status of a putAllOperation 
+     * creates a new instance to save status of a putAllOperation
-    BulkOpHolder() {
-    }
-    
+    BulkOpHolder() {}
+
-    
+
-  
+
-    
+
-    
+
+
-      synchronized(trackers) {
+      synchronized (trackers) {
+
-      synchronized(trackers) {
+      synchronized (trackers) {
+
+
-      synchronized(trackers) {
-        for (Iterator it=trackers.iterator(); it.hasNext(); ) {
-          EventTracker tracker = (EventTracker)it.next();
+      synchronized (trackers) {
+        for (Iterator it = trackers.iterator(); it.hasNext();) {
+          EventTracker tracker = (EventTracker) it.next();
-            Map.Entry e = (Map.Entry)it2.next();
-            EventSeqnoHolder evh = (EventSeqnoHolder)e.getValue();
-            synchronized(evh) {
+            Map.Entry e = (Map.Entry) it2.next();
+            EventSeqnoHolder evh = (EventSeqnoHolder) e.getValue();
+            synchronized (evh) {
-                evh.endOfLifeTimer = now; // a new holder - start the timer 
+                evh.endOfLifeTimer = now; // a new holder - start the timer
-          
-          //Remove bulk operations we're tracking
-          for (Iterator<Map.Entry<ThreadIdentifier, BulkOpHolder>> it2 = tracker.recordedBulkOpVersionTags.entrySet().iterator(); it2.hasNext();) {
+
+          // Remove bulk operations we're tracking
+          for (Iterator<Map.Entry<ThreadIdentifier, BulkOpHolder>> it2 =
+              tracker.recordedBulkOpVersionTags.entrySet().iterator(); it2.hasNext();) {
-            synchronized(evh) {
+            synchronized (evh) {
-                evh.endOfLifeTimer = now; // a new holder - start the timer 
+                evh.endOfLifeTimer = now; // a new holder - start the timer
-              //Remove the PutAll tracker only if the put all is complete
-              //and it has expired.
+              // Remove the PutAll tracker only if the put all is complete
+              // and it has expired.
-    
+

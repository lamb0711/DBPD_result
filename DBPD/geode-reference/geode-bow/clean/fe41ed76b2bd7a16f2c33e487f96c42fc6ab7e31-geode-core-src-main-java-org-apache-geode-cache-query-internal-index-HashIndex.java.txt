GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-
-import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
+import static org.apache.geode.internal.lang.SystemUtils.*;
+import java.util.Map.Entry;
-import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
+import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap;
-import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
-import org.apache.geode.internal.Assert;
+import org.apache.geode.internal.cache.InternalCache;
- * 
+ * <p>
- * 
+ * <p>
- * 
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
-   * @param key
-   * @param entry
-   * @throws IMQException
-   * 
+   *
-   * @throws IMQException
+        // TODO: eliminate use of labels
-   * 
-   * @param entry
-   * @param context
-   * @param indexInfo
-   * @param keyVal
+   *
-   * @throws FunctionDomainException
-   * @throws TypeMismatchException
-   * @throws NameResolutionException
-   * @throws QueryInvocationTargetException
-  // TODO:Decsribe & test the function
-  /**
-   * @param outerEntries is a Set<RegionEntry>
-   * @param innerEntries is a Set<RegionEntry>
-   * @param key
-   * @throws QueryInvocationTargetException
-   * @throws NameResolutionException
-   * @throws TypeMismatchException
-   * @throws FunctionDomainException
-   */
-  private void populateListForEquiJoin(List list, Collection outerEntries, Collection innerEntries,
-      ExecutionContext context, Object key) throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
-
-    Assert.assertTrue((outerEntries != null && innerEntries != null),
-        "OuterEntries or InnerEntries must not be null");
-
-    Object values[][] = new Object[2][];
-    int j = 0;
-    Iterator itr = null;
-    while (j < 2) {
-      if (j == 0) {
-        itr = outerEntries.iterator();
-      } else {
-        itr = innerEntries.iterator();
-      }
-      // TODO :Asif Identify appropriate size of the List
-
-      // extract the values from the RegionEntries
-      List dummy = new ArrayList();
-      RegionEntry re = null;
-      while (itr.hasNext()) {
-        re = (RegionEntry) itr.next();
-        // Bug#41010: We need to verify if Inner and Outer Entries
-        // are consistent with index key values.
-        boolean ok = true;
-        if (re.isUpdateInProgress()) {
-          IndexInfo[] indexInfo = (IndexInfo[]) context.cacheGet(CompiledValue.INDEX_INFO);
-          IndexInfo indInfo = (j == 0) ? indexInfo[0] : indexInfo[1];
-
-          ok = verifyInnerAndOuterEntryValues(re, context, indInfo, key);
-        }
-        if (ok) {
-          dummy.add(getTargetObject(re));
-        }
-      }
-      dummy.toArray(values[j++] = new Object[dummy.size()]);
-    }
-    list.add(values);
-  }
-
-    if (applyLimit != null && applyLimit.booleanValue()) {
-      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue();
+    if (applyLimit != null && applyLimit) {
+      limit = (Integer) context.cacheGet(CompiledValue.RESULT_LIMIT);
-    boolean asc = true;
-    boolean multiColOrderBy = false;
-    if (orderByClause != null && orderByClause.booleanValue()) {
+    if (orderByClause != null && orderByClause) {
-      asc = !csc.getCriterion();
-      multiColOrderBy = orderByAttrs.size() > 1;
-  void instantiateEvaluator(IndexCreationHelper ich) {
-    this.evaluator = new IMQEvaluator(ich);
+  void instantiateEvaluator(IndexCreationHelper indexCreationHelper) {
+    this.evaluator = new IMQEvaluator(indexCreationHelper);
-   * 
+   *
-   * 
-   * @param indexInfo
-   * @param context
-   * @param keyVal
+   *
-   * @throws FunctionDomainException
-   * @throws TypeMismatchException
-   * @throws NameResolutionException
-   * @throws QueryInvocationTargetException
-      return ((Boolean) TypeUtils.compare(left, right, operator)).booleanValue();
+      return (Boolean) TypeUtils.compare(left, right, operator);
-      Object o = entry.getValue((LocalRegion) getRegion()); // OFFHEAP: incrc, deserialize, decrc
+      // OFFHEAP: incrc, deserialize, decrc
+      Object o = entry.getValue((LocalRegion) getRegion());
-      } catch (EntryDestroyedException ede) {
+      } catch (EntryDestroyedException ignored) {
-      } catch (EntryDestroyedException ede) {
+      } catch (EntryDestroyedException ignored) {
-    StringBuffer sb = new StringBuffer(toString()).append(" {\n");
-    // sb.append("Null Values\n");
-    // Iterator nI = nullMappedEntries.iterator();
-    // while (nI.hasNext()) {
-    // RegionEntry e = (RegionEntry) nI.next();
-    // Object value = getTargetObject(e);
-    // sb.append(" RegionEntry.key = ").append(e.getKey());
-    // sb.append(" Value.type = ").append(value.getClass().getName());
-    // if (value instanceof Collection) {
-    // sb.append(" Value.size = ").append(((Collection) value).size());
-    // }
-    // sb.append("\n");
-    // }
-    // sb.append(" -----------------------------------------------\n");
-    // sb.append("Undefined Values\n");
-    // Iterator uI = undefinedMappedEntries.iterator();
-    // while (uI.hasNext()) {
-    // RegionEntry e = (RegionEntry) uI.next();
-    // Object value = getTargetObject(e);
-    // sb.append(" RegionEntry.key = ").append(e.getKey());
-    // sb.append(" Value.type = ").append(value.getClass().getName());
-    // if (value instanceof Collection) {
-    // sb.append(" Value.size = ").append(((Collection) value).size());
-    // }
-    // sb.append("\n");
-    // }
-    sb.append(" -----------------------------------------------\n");
-    Iterator i1 = this.entriesSet.iterator();
-    while (i1.hasNext()) {
-      Map.Entry indexEntry = (Map.Entry) i1.next();
-      sb.append(" Key = " + indexEntry.getKey()).append("\n");
-      sb.append(" Value Type = ").append(" " + indexEntry.getValue().getClass().getName())
-          .append("\n");
+    StringBuilder sb = new StringBuilder(toString()).append(" {").append(getLineSeparator());
+    sb.append(" -----------------------------------------------").append(getLineSeparator());
+    for (Object anEntriesSet : this.entriesSet) {
+      Entry indexEntry = (Entry) anEntriesSet;
+      sb.append(" Key = ").append(indexEntry.getKey()).append(getLineSeparator());
+      sb.append(" Value Type = ").append(' ').append(indexEntry.getValue().getClass().getName())
+          .append(getLineSeparator());
-        sb.append(" Value Size = ").append(" " + ((Collection) indexEntry.getValue()).size())
-            .append("\n");
+        sb.append(" Value Size = ").append(' ').append(((Collection) indexEntry.getValue()).size())
+            .append(getLineSeparator());
-        sb.append(" Value Size = ").append(" " + 1).append("\n");
+        sb.append(" Value Size = ").append(" " + 1).append(getLineSeparator());
-      Iterator i2 = entrySet.iterator();
-      while (i2.hasNext()) {
-        RegionEntry e = (RegionEntry) i2.next();
+      for (Object anEntrySet : entrySet) {
+        RegionEntry e = (RegionEntry) anEntrySet;
-        sb.append("\n");
-        // sb.append(" Value.type = ").append(value).append("\n");
+        sb.append(getLineSeparator());
-      sb.append(" -----------------------------------------------\n");
+      sb.append(" -----------------------------------------------").append(getLineSeparator());
-      StringBuffer sb = new StringBuffer();
-      sb.append("No Keys = ").append(getNumberOfKeys()).append("\n");
-      sb.append("No Values = ").append(getNumberOfValues()).append("\n");
-      sb.append("No Uses = ").append(getTotalUses()).append("\n");
-      sb.append("No Updates = ").append(getNumUpdates()).append("\n");
-      sb.append("Total Update time = ").append(getTotalUpdateTime()).append("\n");
+      StringBuilder sb = new StringBuilder();
+      sb.append("No Keys = ").append(getNumberOfKeys()).append(getLineSeparator());
+      sb.append("No Values = ").append(getNumberOfValues()).append(getLineSeparator());
+      sb.append("No Uses = ").append(getTotalUses()).append(getLineSeparator());
+      sb.append("No Updates = ").append(getNumUpdates()).append(getLineSeparator());
+      sb.append("Total Update time = ").append(getTotalUpdateTime()).append(getLineSeparator());
-    private Cache cache;
+    private final InternalCache cache;
-    final private String[] canonicalIterNames;
+    private final String[] canonicalIterNames;
-      // The modified iterators for optmizing Index cxreation
+      // The modified iterators for optimizing Index creation
-     * 
+     *
-     * @param context
-     * @param context
-      try {
-        if (this.dependencyGraph != null) {
-          context.setDependencyGraph(dependencyGraph);
-        }
-        for (int i = 0; i < this.iteratorSize; i++) {
-          CompiledIteratorDef iterDef = (CompiledIteratorDef) fromIterators.get(i);
-          // We are re-using the same ExecutionContext on every evaluate -- this
-          // is not how ExecutionContext was intended to be used.
-          // Asif: Compute the dependency only once. The call to methods of this
-          // class are thread safe as for update lock on Index is taken .
-          if (this.dependencyGraph == null) {
-            iterDef.computeDependencies(context);
-          }
-          RuntimeIterator rIter = iterDef.getRuntimeIterator(context);
-          context.addToIndependentRuntimeItrMapForIndexCreation(iterDef);
-          context.bindIterator(rIter);
-        }
-        // Save the dependency graph for future updates.
-        if (dependencyGraph == null) {
-          dependencyGraph = context.getDependencyGraph();
-        }
-        Support.Assert(this.indexResultSetType != null,
-            "IMQEvaluator::evaluate:The StrcutType should have been initialized during index creation");
-      } finally {
-
+      if (this.dependencyGraph != null) {
+        context.setDependencyGraph(dependencyGraph);
+      for (int i = 0; i < this.iteratorSize; i++) {
+        CompiledIteratorDef iterDef = (CompiledIteratorDef) fromIterators.get(i);
+        // We are re-using the same ExecutionContext on every evaluate -- this
+        // is not how ExecutionContext was intended to be used.
+        // Asif: Compute the dependency only once. The call to methods of this
+        // class are thread safe as for update lock on Index is taken .
+        if (this.dependencyGraph == null) {
+          iterDef.computeDependencies(context);
+        }
+        RuntimeIterator rIter = iterDef.getRuntimeIterator(context);
+        context.addToIndependentRuntimeItrMapForIndexCreation(iterDef);
+        context.bindIterator(rIter);
+      }
+      // Save the dependency graph for future updates.
+      if (dependencyGraph == null) {
+        dependencyGraph = context.getDependencyGraph();
+      }
+
+      Support.Assert(this.indexResultSetType != null,
+          "IMQEvaluator::evaluate:The StructType should have been initialized during index creation");

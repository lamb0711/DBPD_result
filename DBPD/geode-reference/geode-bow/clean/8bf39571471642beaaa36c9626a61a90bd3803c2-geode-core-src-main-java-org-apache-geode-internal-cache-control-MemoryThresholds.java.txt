Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Stores eviction and critical thresholds for memory as well as the logic for
- * determining how memory transitions between states.
+ * Stores eviction and critical thresholds for memory as well as the logic for determining how
+ * memory transitions between states.
-    DISABLED,                   // Both eviction and critical disabled
-    EVICTION_DISABLED,          // Eviction disabled, critical enabled, critical threshold not exceeded
+    DISABLED, // Both eviction and critical disabled
+    EVICTION_DISABLED, // Eviction disabled, critical enabled, critical threshold not exceeded
-    CRITICAL_DISABLED,          // Critical disabled, eviction enabled, eviction threshold not exceeded
+    CRITICAL_DISABLED, // Critical disabled, eviction enabled, eviction threshold not exceeded
-    NORMAL,                     // Both eviction and critical enabled, neither threshold exceeded
-    EVICTION,                   // Both eviction and critical enabled, eviction threshold exceeded
-    CRITICAL,                   // Both eviction and critical enabled, critical threshold exceeded
-    EVICTION_CRITICAL;          // Both eviction and critical enabled, both thresholds exceeded
+    NORMAL, // Both eviction and critical enabled, neither threshold exceeded
+    EVICTION, // Both eviction and critical enabled, eviction threshold exceeded
+    CRITICAL, // Both eviction and critical enabled, critical threshold exceeded
+    EVICTION_CRITICAL; // Both eviction and critical enabled, both thresholds exceeded
-   * When this property is set to true, a {@link LowMemoryException} is not
-   * thrown, even when usage crosses the critical threshold.
+   * When this property is set to true, a {@link LowMemoryException} is not thrown, even when usage
+   * crosses the critical threshold.
-  private static final boolean DISABLE_LOW_MEM_EXCEPTION = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "disableLowMemoryException");
-  
-  /**
-   * The default percent of memory at which the VM is considered in a
-   * critical state.
-   */
-  public static final float DEFAULT_CRITICAL_PERCENTAGE = ResourceManager.DEFAULT_CRITICAL_PERCENTAGE;
+  private static final boolean DISABLE_LOW_MEM_EXCEPTION =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "disableLowMemoryException");
-   * The default percent of memory at which the VM should begin evicting
-   * data. Note that if a LRU is created and the eviction percentage
-   * has not been set then it will default to <code>80.0</code> unless the
-   * critical percentage has been set in which case it will default to a
-   * value <code>5.0</code> less than the critical percentage.
+   * The default percent of memory at which the VM is considered in a critical state.
-  public static final float DEFAULT_EVICTION_PERCENTAGE = ResourceManager.DEFAULT_EVICTION_PERCENTAGE;
+  public static final float DEFAULT_CRITICAL_PERCENTAGE =
+      ResourceManager.DEFAULT_CRITICAL_PERCENTAGE;
-   * Memory usage must fall below THRESHOLD-THRESHOLD_THICKNESS before we deliver
-   * a down event
+   * The default percent of memory at which the VM should begin evicting data. Note that if a LRU is
+   * created and the eviction percentage has not been set then it will default to <code>80.0</code>
+   * unless the critical percentage has been set in which case it will default to a value
+   * <code>5.0</code> less than the critical percentage.
-  private static final double THRESHOLD_THICKNESS = Double.parseDouble(System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "thresholdThickness",
-      "2.00"));
+  public static final float DEFAULT_EVICTION_PERCENTAGE =
+      ResourceManager.DEFAULT_EVICTION_PERCENTAGE;
-   * Memory usage must fall below THRESHOLD-THRESHOLD_THICKNESS_EVICT before we
-   * deliver an eviction down event
+   * Memory usage must fall below THRESHOLD-THRESHOLD_THICKNESS before we deliver a down event
-  private static final double THRESHOLD_THICKNESS_EVICT = Double.parseDouble(System.getProperty(
-      DistributionConfig.GEMFIRE_PREFIX + "eviction-thresholdThickness", Double.toString(THRESHOLD_THICKNESS)));
+  private static final double THRESHOLD_THICKNESS = Double.parseDouble(
+      System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "thresholdThickness", "2.00"));
+
+  /**
+   * Memory usage must fall below THRESHOLD-THRESHOLD_THICKNESS_EVICT before we deliver an eviction
+   * down event
+   */
+  private static final double THRESHOLD_THICKNESS_EVICT = Double.parseDouble(
+      System.getProperty(DistributionConfig.GEMFIRE_PREFIX + "eviction-thresholdThickness",
+          Double.toString(THRESHOLD_THICKNESS)));
-  
+
-      throw new IllegalArgumentException(LocalizedStrings.MemoryThresholds_CRITICAL_PERCENTAGE_GT_ZERO_AND_LTE_100
-          .toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.MemoryThresholds_CRITICAL_PERCENTAGE_GT_ZERO_AND_LTE_100
+              .toLocalizedString());
-      throw new IllegalArgumentException(LocalizedStrings.MemoryThresholds_EVICTION_PERCENTAGE_GT_ZERO_AND_LTE_100
-          .toLocalizedString());
+      throw new IllegalArgumentException(
+          LocalizedStrings.MemoryThresholds_EVICTION_PERCENTAGE_GT_ZERO_AND_LTE_100
+              .toLocalizedString());
-    
-    if (evictionThreshold != 0 && criticalThreshold != 0 && evictionThreshold >= criticalThreshold) {
-      throw new IllegalArgumentException(LocalizedStrings.MemoryThresholds_CRITICAL_PERCENTAGE_GTE_EVICTION_PERCENTAGE
-          .toLocalizedString());
+
+    if (evictionThreshold != 0 && criticalThreshold != 0
+        && evictionThreshold >= criticalThreshold) {
+      throw new IllegalArgumentException(
+          LocalizedStrings.MemoryThresholds_CRITICAL_PERCENTAGE_GTE_EVICTION_PERCENTAGE
+              .toLocalizedString());
-        
+
-    
+
-    this.criticalThresholdClearBytes = (long) (this.criticalThresholdBytes - (0.01 * THRESHOLD_THICKNESS * this.maxMemoryBytes));
-    
+    this.criticalThresholdClearBytes =
+        (long) (this.criticalThresholdBytes - (0.01 * THRESHOLD_THICKNESS * this.maxMemoryBytes));
+
-    this.evictionThresholdClearBytes = (long) (this.evictionThresholdBytes - (0.01 * THRESHOLD_THICKNESS_EVICT * this.maxMemoryBytes));
+    this.evictionThresholdClearBytes = (long) (this.evictionThresholdBytes
+        - (0.01 * THRESHOLD_THICKNESS_EVICT * this.maxMemoryBytes));
-  
+
-    
+
-      if (bytesUsed < this.evictionThresholdClearBytes || (!oldState.isEviction() && bytesUsed < this.evictionThresholdBytes)) {
+      if (bytesUsed < this.evictionThresholdClearBytes
+          || (!oldState.isEviction() && bytesUsed < this.evictionThresholdBytes)) {
-      if (bytesUsed < this.criticalThresholdClearBytes || (!oldState.isCritical() && bytesUsed < this.criticalThresholdBytes)) {
+      if (bytesUsed < this.criticalThresholdClearBytes
+          || (!oldState.isCritical() && bytesUsed < this.criticalThresholdBytes)) {
-    
+
-    
+
-      if (bytesUsed < this.criticalThresholdClearBytes || (!oldState.isCritical() && bytesUsed < this.criticalThresholdBytes)) {
+      if (bytesUsed < this.criticalThresholdClearBytes
+          || (!oldState.isCritical() && bytesUsed < this.criticalThresholdBytes)) {
-    
+
-    if (bytesUsed < this.evictionThresholdClearBytes || (!oldState.isEviction() && bytesUsed < this.evictionThresholdBytes)) {
+    if (bytesUsed < this.evictionThresholdClearBytes
+        || (!oldState.isEviction() && bytesUsed < this.evictionThresholdBytes)) {
-    
+
-        .append(", evictionThresholdClearBytes:" + this.evictionThresholdClearBytes)
-        .append("]").toString();
+        .append(", evictionThresholdClearBytes:" + this.evictionThresholdClearBytes).append("]")
+        .toString();
-  
+
-  
+
-   * @param in
-   *          DataInput from which to read the data
+   * @param in DataInput from which to read the data
-   * @param out
-   *          DataOutput on which to write internal state
+   * @param out DataOutput on which to write internal state

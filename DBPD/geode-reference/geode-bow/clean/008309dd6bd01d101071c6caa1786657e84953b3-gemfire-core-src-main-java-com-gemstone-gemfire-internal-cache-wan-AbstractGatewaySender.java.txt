Merge branch 'release/1.0.0-incubating.M1'

- * =========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved. 
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- * ========================================================================
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import com.gemstone.gemfire.internal.offheap.Releasable;
+import com.gemstone.gemfire.internal.offheap.annotations.Retained;
+import com.gemstone.gemfire.internal.offheap.annotations.Unretained;
- * Abstract implementation of both Serial and Parallel GatewaySener. It handles
+ * Abstract implementation of both Serial and Parallel GatewaySender. It handles
+  protected boolean isHDFSQueue;
+  
+  protected boolean isMetaQueue;
+  
-  protected volatile ConcurrentLinkedQueue<GatewaySenderEventImpl> tmpQueuedEvents = new ConcurrentLinkedQueue<GatewaySenderEventImpl>();
+  protected volatile ConcurrentLinkedQueue<TmpQueueEvent> tmpQueuedEvents = new ConcurrentLinkedQueue<>();
+    this.isHDFSQueue = attrs.isHDFSQueue();
+    this.isMetaQueue = attrs.isMetaQueue();
-      initializeEventIdIndex();
+      if (!attrs.isHDFSQueue())
+        initializeEventIdIndex();
-      initializeEventIdIndex();
+      if (!attrs.isHDFSQueue())
+        initializeEventIdIndex();
+    this.isHDFSQueue = attrs.isHDFSQueue();
+  public boolean getIsHDFSQueue() {
+    return this.isHDFSQueue;
+  }
+  
+  public boolean getIsMetaQueue() {
+    return this.isMetaQueue;
+  }
+  
-  public boolean beforeEnque(GatewayQueueEvent gatewayEvent) {
-    boolean enque = true;
+  public boolean beforeEnqueue(GatewayQueueEvent gatewayEvent) {
+    boolean enqueue = true;
-      enque = filter.beforeEnqueue(gatewayEvent);
-      if (!enque) {
-        return enque;
+      enqueue = filter.beforeEnqueue(gatewayEvent);
+      if (!enqueue) {
+        return enqueue;
-    return enque;
+    return enqueue;
-  
+
+  final public RegionQueue getQueue() {
+    if (this.eventProcessor != null) {
+      if (!(this.eventProcessor instanceof ConcurrentSerialGatewaySenderEventProcessor)) {
+        return this.eventProcessor.getQueue();
+      }
+      else {
+        throw new IllegalArgumentException(
+            "getQueue() for concurrent serial gateway sender");
+      }
+    }
+    return null;
+  }
+
-        enqueTempEvents();
+        enqueueTempEvents();
-        enqueTempEvents();
+        enqueueTempEvents();
+    if (getIsHDFSQueue() && event.getOperation().isEviction()) {
+      if (logger.isDebugEnabled())
+        logger.debug("Eviction event not queued: " + event);
+      stats.incEventsNotQueued();
+      return;
+    }
+    
+    EntryEventImpl clonedEvent = new EntryEventImpl(event, false);
+    boolean freeClonedEvent = true;
+    try {
-    EntryEventImpl clonedEvent = new EntryEventImpl(event/*, true*/); //this boolean is merged through 43643. looks like offheaprelated change.
-    //below try block is introduced in cheetah. This is offheap related change. 
-//    boolean freeClonedEvent = true;
-//    try {
+    Region region = event.getRegion();
-        if (getEventProcessor() != null && !(getEventProcessor().getDispatcher() instanceof GatewaySenderEventCallbackDispatcher)) {
+          AbstractGatewaySenderEventProcessor ep = getEventProcessor();
+        if (ep != null && !(ep.getDispatcher() instanceof GatewaySenderEventCallbackDispatcher)) {
-      try {
-        synchronized (this.queuedEventsSync) {
-          if (!this.enqueuedAllTempQueueEvents) {
-            if (!this.lifeCycleLock.readLock().tryLock()) {
-              // Get substitution value to enqueue if necessary
-              Object substituteValue = getSubstituteValue(clonedEvent, operation);
-              GatewaySenderEventImpl senderEvent = new GatewaySenderEventImpl(
-                  operation, clonedEvent, substituteValue, false);
-              if (isDebugEnabled) {
-                logger.debug("Event : {} is added to TempQueue", clonedEvent);
-              }
-              this.tmpQueuedEvents.add(senderEvent);
-              stats.incTempQueueSize();
-              return;
+      synchronized (this.queuedEventsSync) {
+        if (!this.enqueuedAllTempQueueEvents) {
+          if (!this.lifeCycleLock.readLock().tryLock()) {
+            Object substituteValue = getSubstituteValue(clonedEvent, operation);
+            this.tmpQueuedEvents.add(new TmpQueueEvent(operation, clonedEvent, substituteValue));
+            freeClonedEvent = false;
+            stats.incTempQueueSize();
+            if (isDebugEnabled) {
+              logger.debug("Event : {} is added to TempQueue", clonedEvent);
+            return;
-      } catch (IOException e) {
-        logger.fatal(LocalizedMessage.create(
-                LocalizedStrings.GatewayImpl_0_AN_EXCEPTION_OCCURRED_WHILE_QUEUEING_1_TO_PERFORM_OPERATION_2_FOR_3,
-                new Object[] { this, getId(), operation, clonedEvent }), e);
-        return;
-//    } finally {
-//      if (freeClonedEvent) {
-//        clonedEvent.release(); // fix for bug 48035
-//      }
-//    }
+    } finally {
+      if (freeClonedEvent) {
+        clonedEvent.release(); // fix for bug 48035
+      }
+    }
-  public void enqueTempEvents() {
+  public void enqueueTempEvents() {
-      GatewaySenderEventImpl nextEvent = null;
+      TmpQueueEvent nextEvent = null;
+          try {
-            this.eventProcessor.enqueueEvent(nextEvent.getEnumListenerEvent(),
-                nextEvent.getEntryEvent(), nextEvent.getSubstituteValue());
-            // below commented code is from cheetah. Offheap is considered here.
-            // Once we consider offheap in cedar, should we consider below code
-//=======
-//            try {
-//              if (!beforeEnqueue(nextEvent)) {
-//                // Yogesh: this should not be a warning message in SQLFire or
-//                // GemFire. In SQLFire it should be logged only TraceDBSynchronizer
-//                // is ON
-//                // logger.warning(LocalizedStrings
-//                // .GatewayEventProcessor_EVENT_0_IS_NOT_ADDED_TO_QUEUE, event);
-//                stats.incEventsFiltered();
-//                continue;
-//              }
-//              this.eventProcessor.enqueueEvent(nextEvent.getEventType(), nextEvent);
-//            } finally {
-//              nextEvent.freeOffHeapReferences();
-//            }
-//>>>>>>> .merge-right.r43020
+            this.eventProcessor.enqueueEvent(nextEvent.getOperation(),
+                nextEvent.getEvent(), nextEvent.getSubstituteValue());
+          } finally {
+            nextEvent.release();
+          }
-                new Object[] { this, getId(), nextEvent.getEnumListenerEvent(), nextEvent }), e);
+                new Object[] { this, getId(), nextEvent.getOperation(), nextEvent }), e);
-	synchronized (this.queuedEventsSync) {
-      Iterator<GatewaySenderEventImpl> itr = this.tmpQueuedEvents.iterator();
+    synchronized (this.queuedEventsSync) {
+      Iterator<TmpQueueEvent> itr = this.tmpQueuedEvents.iterator();
-        GatewaySenderEventImpl event = itr.next();
-        if (tailKey.equals(((EntryEventImpl) event.getEntryEvent()).getTailKey())) {
+        TmpQueueEvent event = itr.next();
+        if (tailKey.equals(event.getEvent().getTailKey())) {
-          //event.release(); //related to off-heap. Merged from cheetah r45415
+          event.release();
-    tmpQueuedEvents.clear(); // ultimately it poll on queue which will take
-                             // time. hence below synchronization
+    TmpQueueEvent nextEvent = null;
+    while ((nextEvent = tmpQueuedEvents.poll()) != null) {
+      nextEvent.release();
+    }
-      tmpQueuedEvents.clear();
+      while ((nextEvent = tmpQueuedEvents.poll()) != null) {
+        nextEvent.release();
+      }
+    
+    statistics.setQueueSize(0);
+    statistics.setTempQueueSize(0);
+  
+  /**
+   * Instances of this class allow us to delay queuing an incoming event.
+   * What used to happen was that the tmpQ would have a GatewaySenderEventImpl
+   * added to it. But then when we took it out we had to ask it for its EntryEventImpl.
+   * Then we created another GatewaySenderEventImpl.
+   * As part of the off-heap work, the GatewaySenderEventImpl no longer has a EntryEventImpl.
+   * So this class allows us to defer creation of the GatewaySenderEventImpl until we
+   * are ready to actually enqueue it.
+   * The caller is responsible for giving us an EntryEventImpl that we own and that
+   * we will release. This is done by making a copy/clone of the original event.
+   * This fixes bug 52029.
+   * 
+   * @author dschneider
+   *
+   */
+  public static class TmpQueueEvent implements Releasable {
+    private final EnumListenerEvent operation;
+    private final @Retained EntryEventImpl event;
+    private final Object substituteValue;
+    public TmpQueueEvent(EnumListenerEvent op, @Retained EntryEventImpl e, Object subValue) {
+      this.operation = op;
+      this.event = e;
+      this.substituteValue = subValue;
+    }
+    
+    public EnumListenerEvent getOperation() {
+      return this.operation;
+    }
+    
+    public @Unretained EntryEventImpl getEvent() {
+      return this.event;
+    }
+    
+    public Object getSubstituteValue() {
+      return this.substituteValue;
+    }
+
+    @Override
+    public void release() {
+      this.event.release();
+    }
+  }

Revert "GEODE-7808: standardize on use of HostAndPort to form client-side connections (#4743)" (#4761)

This reverts commit 0af626462642c6352840cd6e81a5265c74045c7f.
That commit seems to have caused a severe performance drop in several
Benchmark tests:

org.apache.geode.benchmark.tests.PartitionedGetBenchmark
              average ops/second  Baseline:    981794.46  Test:     41239.82  Difference:  -95.8%
org.apache.geode.benchmark.tests.ReplicatedGetBenchmark
              average ops/second  Baseline:    972769.18  Test:     41299.96  Difference:  -95.8%
org.apache.geode.benchmark.tests.PartitionedNonIndexedQueryBenchmark
              average ops/second  Baseline:        90.05  Test:        70.52  Difference:  -21.7%
+import java.net.SocketAddress;
+import java.util.concurrent.ConcurrentHashMap;
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import javax.net.ssl.SSLServerSocket;
+import org.apache.geode.SystemConnectException;
-import org.apache.geode.annotations.VisibleForTesting;
-import org.apache.geode.distributed.internal.tcpserver.AdvancedSocketCreatorImpl;
+import org.apache.geode.distributed.internal.tcpserver.ConnectionWatcher;
- * SocketCreators are built using a SocketCreatorFactory using Geode distributed-system properties.
- * They know how to properly configure sockets for TLS (SSL) communications and perform
- * handshakes. Connection-initiation uses a HostAndPort instance that is similar to an
- * InetSocketAddress.
+ * Analyze configuration data (gemfire.properties) and configure sockets accordingly for SSL.
- * SocketCreator also supports a client-socket-factory that is designated with the property
- * gemfire.clientSocketFactory for use in creating client->server connections.
+ * gemfire.useSSL = (true|false) default false.<br/>
+ * gemfire.ssl.debug = (true|false) default false.<br/>
+ * gemfire.ssl.needClientAuth = (true|false) default true.<br/>
+ * gemfire.ssl.protocols = <i>list of protocols</i><br/>
+ * gemfire.ssl.ciphers = <i>list of cipher suites</i><br/>
+ * <p>
+ * The following may be included to configure the certificates used by the Sun Provider.
+ * <p>
+ * javax.net.ssl.trustStore = <i>pathname</i><br/>
+ * javax.net.ssl.trustStorePassword = <i>password</i><br/>
+ * javax.net.ssl.keyStore = <i>pathname</i><br/>
+ * javax.net.ssl.keyStorePassword = <i>password</i><br/>
+ * <p>
+ * Additional properties will be set as System properties to be available as needed by other
+ * provider implementations.
+  @MakeNotStatic
+  private static final ConcurrentHashMap<InetAddress, String> hostNames = new ConcurrentHashMap<>();
+
+  /**
+   * context for SSL socket factories
+   */
+  /**
+   * A factory used to create client <code>Sockets</code>.
+   */
-  public static final boolean ENABLE_TCP_KEEP_ALIVE =
-      AdvancedSocketCreatorImpl.ENABLE_TCP_KEEP_ALIVE;
-
-  // -------------------------------------------------------------------------
-  // Static instance accessors
-  // -------------------------------------------------------------------------
-
-  /**
-   * @deprecated use LocalHostUtil.getLocalHost()
-   */
-  public static InetAddress getLocalHost() throws UnknownHostException {
-    return LocalHostUtil.getLocalHost();
-  }
+  public static final boolean ENABLE_TCP_KEEP_ALIVE = TcpSocketCreatorImpl.ENABLE_TCP_KEEP_ALIVE;
-  // Initializers (change SocketCreator state)
+  // Static instance accessors
-  protected void initializeCreators() {
-    serverSocketCreator = new SCServerSocketCreator(this);
-    clientSocketCreator = new SCClientSocketCreator(this);
-    advancedSocketCreator = new SCAdvancedSocketCreator(this);
+  /**
+   * @deprecated use LocalHostUtil.getLocalHost()
+   */
+  public static InetAddress getLocalHost() throws UnknownHostException {
+    return LocalHostUtil.getLocalHost();
+   * returns the host name for the given inet address, using a local cache of names to avoid dns
+   * hits and duplicate strings
+   */
+  public static String getHostName(InetAddress addr) {
+    String result = hostNames.get(addr);
+    if (result == null) {
+      result = addr.getHostName();
+      hostNames.put(addr, result);
+    }
+    return result;
+  }
+
+  /**
+   * returns the host name for the given inet address, using a local cache of names to avoid dns
+   * hits and duplicate strings
+   */
+  public static String getCanonicalHostName(InetAddress addr, String hostName) {
+    String result = hostNames.get(addr);
+    if (result == null) {
+      hostNames.put(addr, hostName);
+      return hostName;
+    }
+    return result;
+  }
+
+  /**
+   * Reset the hostNames caches
+   */
+  public static void resetHostNameCache() {
+    hostNames.clear();
+  }
+
+  // -------------------------------------------------------------------------
+  // Initializers (change SocketCreator state)
+  // -------------------------------------------------------------------------
+
+  /**
-        if (this.sslConfig.isEnabled() && getSslContext() == null) {
+        if (this.sslConfig.isEnabled() && sslContext == null) {
-  /**
-   * context for SSL socket factories
-   */
-  @VisibleForTesting
-  /**
-   * A factory used to create client <code>Sockets</code>.
-   */
-  public ClientSocketFactory getClientSocketFactory() {
-    return clientSocketFactory;
-  }
-
-  public SSLConfig getSslConfig() {
-    return sslConfig;
-  }
-
-  /**
-   * ExtendedAliasKeyManager supports use of certificate aliases in distributed system
-   * properties.
-   */
-  /**
-   * Returns true if this SocketCreator is configured to use SSL.
-   */
-  @Override
-  protected boolean useSSL() {
-    return this.sslConfig.isEnabled();
-  }
-
+   * Returns true if this SocketCreator is configured to use SSL.
+   */
+  @Override
+  public boolean useSSL() {
+    return this.sslConfig.isEnabled();
+  }
+
+  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
+      List<GatewayTransportFilter> transportFilters, int socketBufferSize) throws IOException {
+    if (transportFilters.isEmpty()) {
+      return createServerSocket(nport, backlog, bindAddr, socketBufferSize);
+    } else {
+      printConfig();
+      ServerSocket result = new TransportFilterServerSocket(transportFilters);
+      result.setReuseAddress(true);
+      // Set the receive buffer size before binding the socket so
+      // that large buffers will be allocated on accepted sockets (see
+      // java.net.ServerSocket.setReceiverBufferSize javadocs)
+      result.setReceiveBufferSize(socketBufferSize);
+      try {
+        result.bind(new InetSocketAddress(bindAddr, nport), backlog);
+      } catch (BindException e) {
+        BindException throwMe = new BindException(
+            String.format("Failed to create server socket on %s[%s]", bindAddr, nport));
+        throwMe.initCause(e);
+        throw throwMe;
+      }
+      return result;
+    }
+  }
+
+  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
+      int socketBufferSize) throws IOException {
+    return createServerSocket(nport, backlog, bindAddr, socketBufferSize, sslConfig.isEnabled());
+  }
+
+  @Override
+  protected ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
+      int socketBufferSize, boolean sslConnection) throws IOException {
+    printConfig();
+    if (!sslConnection) {
+      return super.createServerSocket(nport, backlog, bindAddr, socketBufferSize, sslConnection);
+    }
+    if (this.sslContext == null) {
+      throw new GemFireConfigException(
+          "SSL not configured correctly, Please look at previous error");
+    }
+    ServerSocketFactory ssf = this.sslContext.getServerSocketFactory();
+    SSLServerSocket serverSocket = (SSLServerSocket) ssf.createServerSocket();
+    serverSocket.setReuseAddress(true);
+    // If necessary, set the receive buffer size before binding the socket so
+    // that large buffers will be allocated on accepted sockets (see
+    // java.net.ServerSocket.setReceiverBufferSize javadocs)
+    if (socketBufferSize != -1) {
+      serverSocket.setReceiveBufferSize(socketBufferSize);
+    }
+    serverSocket.bind(new InetSocketAddress(bindAddr, nport), backlog);
+    finishServerSocket(serverSocket);
+    return serverSocket;
+  }
+
+  /**
+   * Creates or bind server socket to a random port selected from tcp-port-range which is same as
+   * membership-port-range.
+   *
+   *
+   * @return Returns the new server socket.
+   *
+   */
+  public ServerSocket createServerSocketUsingPortRange(InetAddress ba, int backlog,
+      boolean isBindAddress, boolean useNIO, int tcpBufferSize, int[] tcpPortRange)
+      throws IOException {
+    return createServerSocketUsingPortRange(ba, backlog, isBindAddress, useNIO, tcpBufferSize,
+        tcpPortRange, sslConfig.isEnabled());
+  }
+
+  @Override
+  protected RuntimeException problemCreatingSocketInPortRangeException(String s, IOException e) {
+    return new GemFireConfigException(s, e);
+  }
+
+  @Override
+  protected RuntimeException noFreePortException(String reason) {
+    return new SystemConnectException(reason);
+  }
+
+  /**
+   * Return a client socket. This method is used by client/server clients.
+   */
+  public Socket connectForClient(String host, int port, int timeout) throws IOException {
+    return connect(InetAddress.getByName(host), port, timeout, null, true, -1);
+  }
+
+  /**
+   * Return a client socket. This method is used by client/server clients.
+   */
+  public Socket connectForClient(String host, int port, int timeout, int socketBufferSize)
+      throws IOException {
+    return connect(InetAddress.getByName(host), port, timeout, null, true, socketBufferSize);
+  }
+
+  /**
+   * Return a client socket. This method is used by peers.
+   */
+  public Socket connectForServer(InetAddress inetadd, int port) throws IOException {
+    return connect(inetadd, port, 0, null, false, -1);
+  }
+
+  /**
+   * Return a client socket, timing out if unable to connect and timeout > 0 (millis). The parameter
+   * <i>timeout</i> is ignored if SSL is being used, as there is no timeout argument in the ssl
+   * socket factory
+   */
+  public Socket connect(InetAddress inetadd, int port, int timeout,
+      ConnectionWatcher optionalWatcher, boolean clientSide, int socketBufferSize)
+      throws IOException {
+    return connect(inetadd, port, timeout, optionalWatcher, clientSide, socketBufferSize,
+        sslConfig.isEnabled());
+  }
+
+  /**
+   * Return a client socket, timing out if unable to connect and timeout > 0 (millis). The parameter
+   * <i>timeout</i> is ignored if SSL is being used, as there is no timeout argument in the ssl
+   * socket factory
+   */
+  @Override
+  public Socket connect(InetAddress inetadd, int port, int timeout,
+      ConnectionWatcher optionalWatcher, boolean clientSide, int socketBufferSize,
+      boolean sslConnection) throws IOException {
+
+    printConfig();
+
+    if (!sslConnection) {
+      return super.connect(inetadd, port, timeout, optionalWatcher, clientSide, socketBufferSize,
+          sslConnection);
+    }
+
+    // create an SSL connection
+
+    Socket socket;
+    SocketAddress sockaddr = new InetSocketAddress(inetadd, port);
+    if (this.sslContext == null) {
+      throw new GemFireConfigException(
+          "SSL not configured correctly, Please look at previous error");
+    }
+    SocketFactory sf = this.sslContext.getSocketFactory();
+    socket = sf.createSocket();
+
+    // Optionally enable SO_KEEPALIVE in the OS network protocol.
+    socket.setKeepAlive(ENABLE_TCP_KEEP_ALIVE);
+
+    // If necessary, set the receive buffer size before connecting the
+    // socket so that large buffers will be allocated on accepted sockets
+    // (see java.net.Socket.setReceiverBufferSize javadocs for details)
+    if (socketBufferSize != -1) {
+      socket.setReceiveBufferSize(socketBufferSize);
+    }
+
+    try {
+      if (optionalWatcher != null) {
+        optionalWatcher.beforeConnect(socket);
+      }
+      socket.connect(sockaddr, Math.max(timeout, 0));
+      configureClientSSLSocket(socket, timeout);
+      return socket;
+
+    } finally {
+      if (optionalWatcher != null) {
+        optionalWatcher.afterConnect(socket);
+      }
+    }
+  }
+
+  @Override
+  protected Socket createCustomClientSocket(InetAddress inetadd, int port) throws IOException {
+    if (this.clientSocketFactory != null) {
+      return this.clientSocketFactory.createSocket(inetadd, port);
+    }
+    return null;
+  }
+
+  /**
-    return getSslContext().createSSLEngine(hostName, port);
+    return sslContext.createSSLEngine(hostName, port);
-  void handshakeIfSocketIsSSL(Socket socket, int timeout) throws IOException {
+  public void handshakeIfSocketIsSSL(Socket socket, int timeout) throws IOException {
-  /**
-   * Create a server socket with the given transport filters.<br>
-   * Note: This method is outside of the
-   * client/server/advanced interfaces because it references WAN classes that aren't
-   * available to them.
-   */
-  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
-      List<GatewayTransportFilter> transportFilters, int socketBufferSize) throws IOException {
-    if (transportFilters.isEmpty()) {
-      return ((SCServerSocketCreator) forCluster())
-          .createServerSocket(nport, backlog, bindAddr, socketBufferSize, useSSL());
-    } else {
-      printConfig();
-      ServerSocket result = new TransportFilterServerSocket(transportFilters);
-      result.setReuseAddress(true);
-      // Set the receive buffer size before binding the socket so
-      // that large buffers will be allocated on accepted sockets (see
-      // java.net.ServerSocket.setReceiverBufferSize javadocs)
-      result.setReceiveBufferSize(socketBufferSize);
-      try {
-        result.bind(new InetSocketAddress(bindAddr, nport), backlog);
-      } catch (BindException e) {
-        BindException throwMe = new BindException(
-            String.format("Failed to create server socket on %s[%s]", bindAddr, nport));
-        throwMe.initCause(e);
-        throw throwMe;
-      }
-      return result;
-    }
-  }
-
-
+  /**
+   * Configure the SSLServerSocket based on this SocketCreator's settings.
+   */
+  private void finishServerSocket(SSLServerSocket serverSocket) {
+    serverSocket.setUseClientMode(false);
+    if (this.sslConfig.isRequireAuth()) {
+      // serverSocket.setWantClientAuth( true );
+      serverSocket.setNeedClientAuth(true);
+    }
+    serverSocket.setEnableSessionCreation(true);
+
+    // restrict protocols
+    String[] protocols = this.sslConfig.getProtocolsAsStringArray();
+    if (!"any".equalsIgnoreCase(protocols[0])) {
+      serverSocket.setEnabledProtocols(protocols);
+    }
+    // restrict ciphers
+    String[] ciphers = this.sslConfig.getCiphersAsStringArray();
+    if (!"any".equalsIgnoreCase(ciphers[0])) {
+      serverSocket.setEnabledCipherSuites(ciphers);
+    }
+
+    SSLParameterExtension sslParameterExtension = this.sslConfig.getSSLParameterExtension();
+    if (sslParameterExtension != null) {
+      SSLParameters modifiedParams =
+          sslParameterExtension.modifySSLServerSocketParameters(serverSocket.getSSLParameters());
+      serverSocket.setSSLParameters(modifiedParams);
+    }
+
+  }
-  void configureClientSSLSocket(Socket socket, int timeout) throws IOException {
+  private void configureClientSSLSocket(Socket socket, int timeout) throws IOException {
-  void printConfig() {
+  private void printConfig() {
+
+

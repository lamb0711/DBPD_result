GEODE-1587: Replaced AtomicInteger with AtomicIntegerFieldUpdater

        * Use of AtomicIntegerFieldUpdater decereased the memory overhead per entry during index creation

	This closes #191

-import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-  
+
+  private static final AtomicIntegerFieldUpdater<RegionEntryToValuesMap> atomicUpdater =  AtomicIntegerFieldUpdater
+    .newUpdater(RegionEntryToValuesMap.class, "numValues");
+
-      ExecutionContext context) {   
+      ExecutionContext context) {
-    private AtomicInteger numValues = new AtomicInteger(0);
+    volatile int numValues;
-      numValues.incrementAndGet();
+      atomicUpdater.incrementAndGet(this);
-        numValues.addAndGet(values.size());
+        atomicUpdater.addAndGet(this,values.size());
-      numValues.addAndGet(values.size());
+      atomicUpdater.addAndGet(this,values.size());
-          numValues.decrementAndGet();
+          atomicUpdater.decrementAndGet(this);
-        this.numValues.decrementAndGet();
+        atomicUpdater.decrementAndGet(this);
-            numValues.addAndGet((retVal instanceof Collection) ?
+        atomicUpdater.addAndGet(this,(retVal instanceof Collection) ?
-      return this.numValues.get();
+      return atomicUpdater.get(this);
-      this.numValues.set(0);
+      atomicUpdater.set(this,0);
-      this.numValues.addAndGet(((values instanceof Collection) ? ((Collection) values)
+      atomicUpdater.addAndGet(this,((values instanceof Collection) ? ((Collection) values)

GEODE-5145: Added support for destroying an index during region creation


-import java.util.HashMap;
+import java.util.concurrent.ConcurrentHashMap;
+import org.apache.geode.cache.lucene.LuceneIndexDestroyedException;
-  private final HashMap<String, LuceneIndex> indexMap = new HashMap<String, LuceneIndex>();
-  private final HashMap<String, LuceneIndexCreationProfile> definedIndexMap = new HashMap<>();
+  private final Map<String, LuceneIndex> indexMap = new ConcurrentHashMap<>();
+  private final Map<String, LuceneIndexCreationProfile> definedIndexMap = new ConcurrentHashMap<>();
-    afterDataRegionCreated(luceneIndex);
+    try {
+      afterDataRegionCreated(luceneIndex);
+    } catch (LuceneIndexDestroyedException e) {
+      logger.warn(LocalizedStrings.LuceneIndexCreation_INDEX_WAS_DESTROYED_WHILE_BEING_CREATED
+          .toString(indexName, regionPath));
+      return;
+    }
-  public void registerIndex(LuceneIndex index) {
+  private boolean hasIndexBeenDestroyed(String uniqueIndexName) {
+    return !definedIndexMap.containsKey(uniqueIndexName);
+  }
+
+  private void registerIndex(LuceneIndex index) {
-    if (!indexMap.containsKey(regionAndIndex)) {
-      indexMap.put(regionAndIndex, index);
+    if (hasIndexBeenDestroyed(regionAndIndex)) {
+      ((InternalLuceneIndex) index).destroy(true);
+      throw new LuceneIndexDestroyedException(index.getName(), index.getRegionPath());
+    } else {
+      if (!indexMap.containsKey(regionAndIndex)) {
+        indexMap.put(regionAndIndex, index);
+      }
+      definedIndexMap.remove(regionAndIndex);
-    definedIndexMap.remove(regionAndIndex);

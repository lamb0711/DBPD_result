Merge branch 'release/1.0.0-incubating.M3'

+import static com.gemstone.gemfire.distributed.ConfigurationProperties.*;
+
-import java.util.Iterator;
+import org.apache.shiro.subject.Subject;
+import org.apache.shiro.util.ThreadState;
-import com.gemstone.gemfire.distributed.DistributedMember;
-import com.gemstone.gemfire.distributed.internal.DistributionConfig;
-import com.gemstone.gemfire.internal.SocketUtils;
+import com.gemstone.gemfire.internal.security.GeodeSecurityUtil;
- * @since 2.0.2
+ * @since GemFire 2.0.2
-
-  protected void setAuthorizeRequest(AuthorizeRequest authzRequest) {
-    this.authzRequest = authzRequest;
-  }
-
-  protected void setPostAuthorizeRequest(AuthorizeRequestPP postAuthzRequest) {
-    this.postAuthzRequest = postAuthzRequest;
-  }
-  //this is backward compability only, if any race condition happens.
-  //where server is unregistering the client and client is creating new connection.
-  private void resetUserAuthorizeAndPostAuthorizeRequest()
-  {
-    if (AcceptorImpl.isAuthenticationRequired()
-        && (this.handshake.getVersion().compareTo(Version.GFE_65) < 0
-            || this.getCommunicationMode() == Acceptor.GATEWAY_TO_GATEWAY))
-    {
-      ClientUserAuths cua = proxyIdVsClientUserAuths.get(this.proxyId);
-      if (cua != this.clientUserAuths)
-      {
-        UserAuthAttributes uaa = this.clientUserAuths.getUserAuthAttributes(this.userAuthId);
-        initializeClientUserAuths();
-        this.userAuthId = this.clientUserAuths.putUserAuth(uaa);
-      }
-    }
-  }
-      && this.acceptor.getCachedRegionHelper().getCache().getCancelCriterion().cancelInProgress() == null;
+      && !acceptor.getCachedRegionHelper().getCache().getCancelCriterion().isCancelInProgress();
-      this.handshake.accept(SocketUtils.getOutputStream(theSocket), SocketUtils.getInputStream(this.theSocket)//this.theSocket
+      this.handshake.accept(theSocket.getOutputStream(), theSocket.getInputStream()
-
-//  public static AuthorizeRequestPP getPostAuthorizeCallback(ClientProxyMembershipID proxyId, String cqName)
-//  {
-//    ClientUserAuths cua = proxyIdVsClientUserAuths.get(proxyId);
-//    UserAuthAttributes uaa =  cua.getUserAuthAttributes(cqName);
-//    if (uaa != null)
-//      return uaa.getPostAuthzRequest();
-//    return null;
-//  }
+    ThreadState threadState = null;
+
+        // if a subject exists for this uniqueId, binds the subject to this thread so that we can do authorization later
+        if(AcceptorImpl.isIntegratedSecurity() && !isInternalMessage()) {
+          long uniqueId = getUniqueId();
+          Subject subject = this.clientUserAuths.getSubject(uniqueId);
+          if(subject!=null) {
+            threadState = GeodeSecurityUtil.bindSubject(subject);
+          }
+        }
+
+      if(threadState!=null){
+        threadState.clear();
+      }
-        return this.clientUserAuths.removeUserId(aIds.getUniqueId(), keepalive);
+        // first try integrated security
+        boolean removed = this.clientUserAuths.removeSubject(aIds.getUniqueId());
+
+        // if not successfull, try the old way
+        if(!removed)
+          removed = this.clientUserAuths.removeUserId(aIds.getUniqueId(), keepalive);
+        return removed;
+
-        //throw exception not authorized 
+        throw new  AuthenticationFailedException("Authentication failed");
-      
-      
+
+      // When here, security is enfored on server, if login returns a subject, then it's the newly integrated security, otherwise, do it the old way.
+      long uniqueId;
+
-          DistributionConfig.SECURITY_CLIENT_AUTHENTICATOR_NAME);
-      
-      Principal principal = HandShake.verifyCredentials(methodName, credentials,
-          system.getSecurityProperties(), (InternalLogWriter)system.getLogWriter(), (InternalLogWriter)system
-              .getSecurityLogWriter(), this.proxyId.getDistributedMember());
-  
-      //this sets principal in map as well....
-      long uniqueId = ServerHandShakeProcessor.getUniqueId(this, principal);
-      
-      //create secure part which will be send in respones    
-      
+        SECURITY_CLIENT_AUTHENTICATOR);
+
+      Object principal = HandShake.verifyCredentials(methodName, credentials,
+        system.getSecurityProperties(), (InternalLogWriter) system.getLogWriter(), (InternalLogWriter) system
+          .getSecurityLogWriter(), this.proxyId.getDistributedMember());
+      if(principal instanceof Subject){
+        Subject subject = (Subject)principal;
+        uniqueId = this.clientUserAuths.putSubject(subject);
+        logger.info(this.clientUserAuths);
+      }
+      else {
+        //this sets principal in map as well....
+        uniqueId = ServerHandShakeProcessor.getUniqueId(this, (Principal)principal);
+      }
+
+      //create secure part which will be send in respones
-        && (!(this.requestMsg.msgType == MessageType.CLIENT_READY
+        && (!isInternalMessage())) {
+      setSecurityPart();
+      return this.securePart;
+    }
+    else {
+      if (AcceptorImpl.isAuthenticationRequired() && logger.isDebugEnabled()) {
+        logger.debug("ServerConnection.updateAndGetSecurityPart() not adding security part for msg type {}",
+            MessageType.getString(this.requestMsg.msgType));
+      }
+    }
+    return null;
+ }
+
+  private boolean isInternalMessage(){
+    return (this.requestMsg.msgType == MessageType.CLIENT_READY
-            || this.requestMsg.msgType == MessageType.GET_CLIENT_PR_METADATA 
+            || this.requestMsg.msgType == MessageType.GET_CLIENT_PR_METADATA
-            || this.requestMsg.msgType == MessageType.ROLLBACK))) {
-      setSecurityPart();
-      return this.securePart;
-    }
-    else {
-      if (AcceptorImpl.isAuthenticationRequired() && logger.isDebugEnabled()) {
-        logger.debug("ServerConnection.updateAndGetSecurityPart() not adding security part for msg type {}",
-            MessageType.getString(this.requestMsg.msgType));
-      }
-    }
-    return null;
- }
+            || this.requestMsg.msgType == MessageType.ROLLBACK);
+  }
-
-  
-
-  
-
-  
-
-  
-  
-
-  
-
-//  private void writePingReply(Message origMsg) throws IOException {
-//    replyMsg.setMessageType(MessageType.REPLY);
-//    replyMsg.setNumberOfParts(1);
-//    replyMsg.setTransactionId(origMsg.getTransactionId());
-//    replyMsg.addBytesPart(OK_BYTES);
-//    replyMsg.send(logger, origMsg.getTransactionId());
-//    if (logger.finerEnabled()) {
-//      logger.finer(getName() + ": rpl tx: " + origMsg.getTransactionId());
-//    }
-//  }
-
-  
-
-  
-
-  
-//  private void writeBatchException(Message origMsg, String message, int index) throws IOException {
-//    Exception be = new BatchException(message, index);
-//    errorMsg.setMessageType(MessageType.EXCEPTION);
-//    errorMsg.setNumberOfParts(2);
-//    errorMsg.setTransactionId(origMsg.getTransactionId());
-//    errorMsg.addObjPart(be);
-//    errorMsg.addStringPart(be.toString());
-//    errorMsg.send();
-//    if (logger.fineEnabled()) {
-//      logger.fine(this.name + ": Wrote batch exception: ", be);
-//    }
-//  }
-
-  
-
-  
-
-//   /**
-//    * Examine an entry, and build an InterestEvent for it
-//    * @param region region we're fetching from
-//    * @param entryKey entry key that we may want the event for
-//    * @return the event or null if entry does not exist
-//    */
-//   private InterestEvent getInterestEvent(Region region, Object entryKey)
-//   {
-//     Region.Entry entry = null;
-//     try {
-//       entry = region.getEntry(entryKey);
-//     } catch (Exception likelyAPartitionedRegion) { // ignore, change when a partitioned region supports getEntry
-//     }
-//     if (entry == null) {
-//       return null;
-//     }
-//     if (entry instanceof LocalRegion.NonTXEntry) {
-//       final LocalRegion.NonTXEntry regionEntry = (LocalRegion.NonTXEntry)entry;
-//       boolean isDeserialized = true;
-//       // Get the value in the VM
-//       Object value = regionEntry.getRegionEntry().getValueInVM();
-//       // If the value in the VM is a CachedDeserializable,
-//       // get its value. If it is Token.REMOVED, Token.DESTROYED,
-//       // Token.INVALID, or Token.LOCAL_INVALID
-//       // set it to null. If it is NOT_AVAILABLE, get the value from
-//       // disk. If it is already a byte[], set isObject to false.
-//       if (value instanceof CachedDeserializable) {
-//         value = ((CachedDeserializable)value).getValue();
-//         isDeserialized = !(value instanceof byte[]);
-//       }
-//       else if (value == Token.REMOVED || value == Token.DESTROYED) {
-//         return null;
-//       }
-//       else if (value == Token.INVALID || value == Token.LOCAL_INVALID) {
-//         return null; // fix for bug 35884
-//       }
-//       else if (value instanceof byte[]) {
-//         // key, value, and isDeserialized already set
-//       }
-//       else if (value == EntryEvent.NOT_AVAILABLE) {
-//         // This will occur with a disk region entry where the value
-//         // is on disk. Currently the getValue call will deserialize
-//         // the value. This means that for disk regions, value classes
-//         // must exist on the server. If this code is changed, look at
-//         // the run method above for similar code to change.
-//         value = regionEntry.getRegionEntry().getValue((LocalRegion)region);
-//         if (value instanceof CachedDeserializable) {
-//           value = ((CachedDeserializable)value).getValue();
-//           isDeserialized = !(value instanceof byte[]);
-//         }
-//       }
-//       return new InterestEvent(entryKey, value, isDeserialized);
-//     } else {
-//       return null;
-//     }
-//   }
-
-//   /**
-//    * Process an interest request of type {@link InterestType#FILTER_CLASS}
-//    * @param region the region
-//    * @param className the key
-//    * @param policy the policy
-//    * @throws IOException
-//    */
-//   private void handleFilter(LocalRegion region, String className,
-//       InterestResultPolicy policy) throws IOException
-//   {
-//     ArrayList keyList = new ArrayList(this.maximumChunkSize);
-
-//     // Handle the filtering class pattern
-
-//     Class filterClass;
-//     InterestFilter filter;
-//     try {
-//       filterClass = ClassLoadUtil.classFromName((String) className);
-//       filter = (InterestFilter) filterClass.newInstance();
-//     } catch(ClassNotFoundException cnfe) {
-//       throw new RuntimeException("Class " + className + " not found in classpath.", cnfe);
-//     } catch(Exception e) {
-//       throw new RuntimeException("Class " + className + " could not be instantiated.", e);
-//     }
-
-// //    if(!(filter instanceof InterestFilter)) {
-// //      throw new RuntimeException("Class " + key + " does not implement InterestFilter.");
-// //    }
-
-//     for (Iterator it = region.keys().iterator(); it.hasNext();) {
-//       Object entryKey = it.next();
-//       InterestEvent ie = getInterestEvent(region, entryKey);
-//       if (ie == null) {
-//         // key no longer existed so skip it
-//         continue;
-//       }
-//       if(!filter.notifyOnRegister(ie)) {
-//         //the filter does not want to know about this entry, so skip it.
-//          continue;
-//       }
-//       appendInterestResponseKey(region, className, entryKey, keyList, "filter list");
-//     }
-//     // Send the last chunk (the only chunk for individual and list keys)
-//     // always send it back, even if the list is of zero size.
-//     sendRegisterInterestResponseChunk(region, className, keyList, true);
-//   }
-
- 
-
-//  /**
-//   * Process an interest request of type {@link InterestType#FILTER_CLASS}
-//   * @param region the region
-//   * @param className the key
-//   * @param policy the policy
-//   * @throws IOException
-//   */
-//  private void handleFilterPR(PartitionedRegion region, String className,
-//      InterestResultPolicy policy) throws IOException
-//  {
-//    // this interest type isn't exposed to the customer yet
-//    throw new UnsupportedOperationException("filter classes not yet supporeted");
-//  }
-
-  
-  
- 
-  
-
-  
-
-  
-
-//       if (logger.fineEnabled()) {
-//         logger.fine (this.name + ": about to close socket");
-//       }
-//       try {
-//         theSocket.shutdownInput();
-//       } catch (Exception e) {
-//       }
-//       try {
-//         theSocket.shutdownOutput();
-//       } catch (Exception e) {
-//       }
-  
-  public AuthorizeRequest getAuthzRequest() 
-      throws AuthenticationRequiredException, IOException {
-    //look client version and return authzrequest
-    //for backward client it will be store in member variable userAuthId 
-    //for other look "requestMsg" here and get unique-id from this to get the authzrequest
-    
-    if (AcceptorImpl.isAuthenticationRequired()) {
-      long uniqueId = 0;
-      
-      if (this.handshake.getVersion().compareTo(Version.GFE_65) < 0
-          || this.communicationMode == Acceptor.GATEWAY_TO_GATEWAY) {
-        uniqueId = this.userAuthId;
-      } else {
-        try {
-          //this.logger.fine("getAuthzRequest() isSecureMode = " + this.requestMsg.isSecureMode());
-          if (this.requestMsg.isSecureMode()) {
-            //get uniqueID from message
-            byte [] secureBytes = this.requestMsg.getSecureBytes();
-            secureBytes =  ((HandShake)this.handshake).decryptBytes(secureBytes);
-            AuthIds aIds = new AuthIds(secureBytes);
+  public long getUniqueId(){
+    long uniqueId = 0;
-            if ( /*this.connectionId != Connection.DEFAULT_CONNECTION_ID &&*/ this.connectionId != aIds.getConnectionId()) {
-              throw new AuthenticationRequiredException(
-                  LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED
-                    .toLocalizedString());
-            } else {
-              uniqueId = aIds.getUniqueId();
-            }
-            
-          } else {
+    if (this.handshake.getVersion().compareTo(Version.GFE_65) < 0
+      || this.communicationMode == Acceptor.GATEWAY_TO_GATEWAY) {
+      uniqueId = this.userAuthId;
+    } else {
+      try {
+        //this.logger.fine("getAuthzRequest() isSecureMode = " + this.requestMsg.isSecureMode());
+        if (this.requestMsg.isSecureMode()) {
+          //get uniqueID from message
+          byte [] secureBytes = this.requestMsg.getSecureBytes();
+
+          secureBytes =  ((HandShake)this.handshake).decryptBytes(secureBytes);
+          AuthIds aIds = new AuthIds(secureBytes);
+
+          if (this.connectionId != aIds.getConnectionId()) {
-                LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED
-                  .toLocalizedString());
-          }
-        } catch (AuthenticationRequiredException are) {
-          throw are;
-        }
-        catch(Exception ex ) {
-          throw new AuthenticationRequiredException(
-        }
-      }
-      UserAuthAttributes uaa = null;
-      try {
-        uaa = this.clientUserAuths.getUserAuthAttributes(uniqueId);
-      } catch (NullPointerException npe) {
-        if (this.isTerminated()) {
-          // Bug #52023.
-          throw new IOException("Server connection is terminated.");
+          } else {
+            uniqueId = aIds.getUniqueId();
+          }
+
-          logger.debug("Unexpected exception {}", npe);
+          throw new AuthenticationRequiredException(
+            LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED
+              .toLocalizedString());
+      } catch (AuthenticationRequiredException are) {
+        throw are;
-      if (uaa == null) {
+      catch(Exception ex ) {
-            "User authorization attributes not found.");
+          LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED
+            .toLocalizedString());
-      AuthorizeRequest authReq = uaa.getAuthzRequest();
-      if (logger.isDebugEnabled()) {
-        logger.debug("getAuthzRequest() authrequest: {}", ((authReq == null) ? "NULL (only authentication is required)" : "not null"));
-      }
-      
-      return authReq;
-    else {
+    return uniqueId;
+  }
+
+  public AuthorizeRequest getAuthzRequest()
+      throws AuthenticationRequiredException, IOException {
+    //look client version and return authzrequest
+    //for backward client it will be store in member variable userAuthId
+    //for other look "requestMsg" here and get unique-id from this to get the authzrequest
+
+    if (!AcceptorImpl.isAuthenticationRequired())
+
+    if(AcceptorImpl.isIntegratedSecurity())
+      return null;
+
+    long uniqueId = getUniqueId();
+
+    UserAuthAttributes uaa = null;
+    try {
+      uaa = this.clientUserAuths.getUserAuthAttributes(uniqueId);
+    } catch (NullPointerException npe) {
+      if (this.isTerminated()) {
+        // Bug #52023.
+        throw new IOException("Server connection is terminated.");
+      } else {
+        logger.debug("Unexpected exception {}", npe);
+      }
+    if (uaa == null) {
+      throw new AuthenticationRequiredException(
+          "User authorization attributes not found.");
+    }
+    AuthorizeRequest authReq = uaa.getAuthzRequest();
+    if (logger.isDebugEnabled()) {
+      logger.debug("getAuthzRequest() authrequest: {}", ((authReq == null) ? "NULL (only authentication is required)" : "not null"));
+    }
+    return authReq;
-  //look client version and return authzrequest
-  //for backward client it will be store in member variable userAuthId 
-  //for other look "requestMsg" here and get unique-id from this to get the authzrequest
-    if (AcceptorImpl.isAuthenticationRequired()) {
-      long uniqueId = 0;
-      
-      if (this.handshake.getVersion().compareTo(Version.GFE_65) < 0
-          || this.communicationMode == Acceptor.GATEWAY_TO_GATEWAY) {
-        uniqueId = this.userAuthId;
-      } else {
-        try {
-          //this.logger.fine("getPostAuthzRequest() isSecureMode = " + this.requestMsg.isSecureMode());
-          if (this.requestMsg.isSecureMode()) {
-            byte [] secureBytes = this.requestMsg.getSecureBytes();
-            
-            secureBytes =  ((HandShake)this.handshake).decryptBytes(secureBytes);
-            
-            AuthIds aIds = new AuthIds(secureBytes);
-            if ( /*this.connectionId != Connection.DEFAULT_CONNECTION_ID && */this.connectionId != aIds.getConnectionId()) {
-              throw new AuthenticationRequiredException(
-                  LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED
-                    .toLocalizedString());
-            } else {
-              uniqueId = aIds.getUniqueId();
-            }
-            
-          } 
-          else{
-            throw new AuthenticationRequiredException(
-                LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED
-                  .toLocalizedString());
-          }
-        } catch (AuthenticationRequiredException are) {
-          throw are;
-        }
-        catch(Exception ex) {
-          throw new AuthenticationRequiredException(
-              LocalizedStrings.HandShake_NO_SECURITY_PROPERTIES_ARE_PROVIDED
-                .toLocalizedString());
-        }
-      }
-      
-      UserAuthAttributes uaa = null;
-      try {
-        uaa = this.clientUserAuths.getUserAuthAttributes(uniqueId);
-      } catch (NullPointerException npe) {
-        if (this.isTerminated()) {
-          // Bug #52023.
-          throw new IOException("Server connection is terminated.");
-        } else {
-          logger.debug("Unexpected exception {}", npe);
-        }
-      }
-      if (uaa == null) {
-        throw new AuthenticationRequiredException(
-            "User authorization attributes not found.");
-      }
-      
-      AuthorizeRequestPP postAuthReq = uaa.getPostAuthzRequest();
-      
-      return postAuthReq;
-    }
-    else
+    if (!AcceptorImpl.isAuthenticationRequired())
-    
-    //return this.postAuthzRequest;
+
+    if(AcceptorImpl.isIntegratedSecurity())
+      return null;
+
+    //look client version and return authzrequest
+    //for backward client it will be store in member variable userAuthId
+    //for other look "requestMsg" here and get unique-id from this to get the authzrequest
+    long uniqueId = getUniqueId();
+
+    UserAuthAttributes uaa = null;
+    try {
+      uaa = this.clientUserAuths.getUserAuthAttributes(uniqueId);
+    } catch (NullPointerException npe) {
+      if (this.isTerminated()) {
+        // Bug #52023.
+        throw new IOException("Server connection is terminated.");
+      } else {
+        logger.debug("Unexpected exception {}", npe);
+      }
+    }
+    if (uaa == null) {
+      throw new AuthenticationRequiredException(
+          "User authorization attributes not found.");
+    }
+
+    AuthorizeRequestPP postAuthReq = uaa.getPostAuthzRequest();
+
+    return postAuthReq;
-  
-  public boolean isSqlFabricSystem() {
-    return this.acceptor.isSqlFabricSystem();
-  }

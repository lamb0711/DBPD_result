Merge branch 'release/1.0.0-incubating.M3'

+import com.gemstone.gemfire.cache.Operation;
+import com.gemstone.gemfire.internal.offheap.annotations.Released;
- * @since 7.0
+ * @since GemFire 7.0
-  
+
+  protected boolean forwardExpirationDestroy;
+
-  protected boolean isHDFSQueue;
-  
-    this.isHDFSQueue = attrs.isHDFSQueue();
-      if (!attrs.isHDFSQueue())
-        initializeEventIdIndex();
+      initializeEventIdIndex();
+    this.forwardExpirationDestroy = attrs.isForwardExpirationDestroy();
-  
-  public void createSender(Cache cache, GatewaySenderAttributes attrs){
-    this.cache = cache;
-    this.id = attrs.getId();
-    this.socketBufferSize = attrs.getSocketBufferSize();
-    this.socketReadTimeout = attrs.getSocketReadTimeout();
-    this.queueMemory = attrs.getMaximumQueueMemory();
-    this.batchSize = attrs.getBatchSize();
-    this.batchTimeInterval = attrs.getBatchTimeInterval();
-    this.isConflation = attrs.isBatchConflationEnabled();
-    this.isPersistence = attrs.isPersistenceEnabled();
-    this.alertThreshold = attrs.getAlertThreshold();
-    this.manualStart = attrs.isManualStart();
-    this.isParallel = attrs.isParallel();
-    this.isForInternalUse = attrs.isForInternalUse();
-    this.diskStoreName = attrs.getDiskStoreName();
-    this.remoteDSId = attrs.getRemoteDSId();
-    this.eventFilters = attrs.getGatewayEventFilters();
-    this.transFilters = attrs.getGatewayTransportFilters();
-    this.listeners = attrs.getAsyncEventListeners();
-    this.substitutionFilter = attrs.getGatewayEventSubstitutionFilter();
-    this.locatorDiscoveryCallback = attrs.getGatewayLocatoDiscoveryCallback();
-    this.isDiskSynchronous = attrs.isDiskSynchronous();
-    this.policy = attrs.getOrderPolicy();
-    this.dispatcherThreads = attrs.getDispatcherThreads();
-    this.parallelismForReplicatedRegion = attrs.getParallelismForReplicatedRegion();
-    //divide the maximumQueueMemory of sender equally using number of dispatcher threads.
-    //if dispatcherThreads is 1 then maxMemoryPerDispatcherQueue will be same as maximumQueueMemory of sender
-    this.maxMemoryPerDispatcherQueue = this.queueMemory / this.dispatcherThreads;
-    this.myDSId = InternalDistributedSystem.getAnyInstance().getDistributionManager().getDistributedSystemId();
-    this.serialNumber = DistributionAdvisor.createSerialNumber();
-    if (!(this.cache instanceof CacheCreation)) {
-      this.stopper = new Stopper(cache.getCancelCriterion());
-      this.senderAdvisor = GatewaySenderAdvisor.createGatewaySenderAdvisor(this);
-      if (!this.isForInternalUse()) {
-        this.statistics = new AsyncEventQueueStats(cache.getDistributedSystem(),
-            id);
-      }
-      else {// this sender lies underneath the AsyncEventQueue. Need to have
-            // AsyncEventQueueStats
-        this.statistics = new AsyncEventQueueStats(
-            cache.getDistributedSystem(), AsyncEventQueueImpl
-                .getAsyncEventQueueIdFromSenderId(id));
-      }
-      if (!attrs.isHDFSQueue())
-        initializeEventIdIndex();
-    }
-    this.isBucketSorted = attrs.isBucketSorted();
-    this.isHDFSQueue = attrs.isHDFSQueue();
-   
-  }
-  
+
-  
+
+  public boolean isForwardExpirationDestroy() {
+    return this.forwardExpirationDestroy;
+  }
+
-  public boolean getIsHDFSQueue() {
-    return this.isHDFSQueue;
-  }
-  
+  /**
+   * Check if this event can be distributed by senders.
+   * @param event
+   * @param stats
+   * @return boolean True if the event is allowed.
+   */
+  private boolean checkForDistribution(EntryEventImpl event, GatewaySenderStats stats) {
+    if (event.getRegion().getDataPolicy().equals(DataPolicy.NORMAL))
+    {
+      return false;
+    }
+    // Check for eviction and expiration events.
+    if (event.getOperation().isLocal() || event.getOperation().isExpiration()) {
+      // Check if its AEQ and is configured to forward expiration destroy events.
+      if (event.getOperation().isExpiration() && this.isAsyncEventQueue() && this.isForwardExpirationDestroy()) {
+        return true;
+      }
+      return false;
+    }
+    return true;
+  }
+
+
+
-    
-    final GatewaySenderStats stats = getStatistics();
-    stats.incEventsReceived();
-    // If the event is local (see bug 35831) or an expiration ignore it.
-    //removed the check of isLocal as in notifyGAtewayHub this has been taken care
-    if (/*event.getOperation().isLocal() || */event.getOperation().isExpiration()
-        || event.getRegion().getDataPolicy().equals(DataPolicy.NORMAL)) {
-      getStatistics().incEventsNotQueued();
+
+    // If this gateway is not running, return
+    if (!isRunning()) {
+      if (isDebugEnabled) {
+        logger.debug("Returning back without putting into the gateway sender queue");
+      }
-    
-    if (getIsHDFSQueue() && event.getOperation().isEviction()) {
-      if (logger.isDebugEnabled())
-        logger.debug("Eviction event not queued: " + event);
+
+    final GatewaySenderStats stats = getStatistics();
+    stats.incEventsReceived();
+
+    if (!checkForDistribution(event, stats)) {
+
-    // not cinsidering this filter
+    // not considering this filter
-      getStatistics().incEventsFiltered();
+      stats.incEventsFiltered();
-    
-    EntryEventImpl clonedEvent = new EntryEventImpl(event, false);
+    // released by this method or transfers ownership to TmpQueueEvent
+    @Released EntryEventImpl clonedEvent = new EntryEventImpl(event, false);
-    
+
-          callbackArg, this.getMyDSId(), allRemoteDSIds, true);
+          callbackArg, this.getMyDSId(), allRemoteDSIds);
+      // The sender may have stopped, after we have checked the status in the beginning. 
+

GEODE-6143: Remove PowerMock from ExecuteFunction tests (#3045)

Remove PowerMock from:
* ExecuteFunctionTest
* ExecuteFunction65Test
* ExecuteFunction66Test

Add test for ExecuteFunction70Test by subclasses ExecuteFunction66Test.

Misc cleanup:
* Fixup logger statements and minor IDE warnings

+import org.apache.geode.cache.Cache;
+import org.apache.geode.cache.LowMemoryException;
-import org.apache.geode.cache.execute.FunctionService;
+import org.apache.geode.cache.execute.ResultSender;
+import org.apache.geode.internal.cache.execute.InternalFunctionExecutionService;
+import org.apache.geode.internal.cache.execute.InternalFunctionService;
-  protected static volatile boolean ASYNC_TX_WARNING_ISSUED = false;
+  private static volatile boolean asyncTxWarningIssued;
-  static final ExecutorService execService =
+  private static final ExecutorService execService =
-  ExecuteFunction66() {}
+  private final InternalFunctionExecutionService internalFunctionExecutionService;
+  private final ServerToClientFunctionResultSender65Factory serverToClientFunctionResultSender65Factory;
+  private final FunctionContextImplFactory functionContextImplFactory;
+
+  ExecuteFunction66() {
+    this(InternalFunctionService.getInternalFunctionExecutionService(),
+        new DefaultServerToClientFunctionResultSender65Factory(),
+        new DefaultFunctionContextImplFactory());
+  }
+
+  ExecuteFunction66(InternalFunctionExecutionService internalFunctionExecutionService,
+      ServerToClientFunctionResultSender65Factory serverToClientFunctionResultSender65Factory,
+      FunctionContextImplFactory functionContextImplFactory) {
+    this.internalFunctionExecutionService = internalFunctionExecutionService;
+    this.serverToClientFunctionResultSender65Factory = serverToClientFunctionResultSender65Factory;
+    this.functionContextImplFactory = functionContextImplFactory;
+  }
-    Object args = null;
+    Object args;
-    String[] groups = null;
+    String[] groups;
-    byte functionState = 0;
+    byte functionState;
-    boolean allMembers = false;
-    boolean ignoreFailedMembers = false;
+    boolean allMembers;
+    boolean ignoreFailedMembers;
+
-    } catch (ClassNotFoundException exception) {
-      logger.warn(String.format("Exception on server while executing function: %s",
-          function),
-          exception);
+    } catch (ClassNotFoundException e) {
+      logger.warn("Exception on server while executing function: {}", function, e);
-        writeChunkedException(clientMessage, exception, serverConnection);
+        writeChunkedException(clientMessage, e, serverConnection);
-        writeException(clientMessage, exception, false, serverConnection);
+        writeException(clientMessage, e, false, serverConnection);
-      final String message =
-          "The input function for the execute function request is null";
-      logger.warn("{} : {}",
-          new Object[] {serverConnection.getName(), message});
+      String message = "The input function for the execute function request is null";
+      logger.warn("{} : {}", serverConnection.getName(), message);
-      Function<?> functionObject = null;
+      Function<?> functionObject;
-        functionObject = FunctionService.getFunction((String) function);
+        functionObject = internalFunctionExecutionService.getFunction((String) function);
-          final String message =
-              String.format("Function named %s is not registered to FunctionService",
-                  function);
+          String message = String
+              .format("Function named %s is not registered to FunctionService for %s", function);
-            String message =
-                "Function attributes at client and server don't match for " +
-                    function;
+            String message = String
+                .format("Function attributes at client and server don't match for %s", function);
-      ChunkedMessage m = serverConnection.getFunctionResponseMessage();
-      m.setTransactionId(clientMessage.getTransactionId());
-      ServerToClientFunctionResultSender resultSender = new ServerToClientFunctionResultSender65(m,
-          MessageType.EXECUTE_FUNCTION_RESULT, serverConnection, functionObject, executeContext);
+      ChunkedMessage chunkedMessage = serverConnection.getFunctionResponseMessage();
+      chunkedMessage.setTransactionId(clientMessage.getTransactionId());
+      ServerToClientFunctionResultSender resultSender =
+          serverToClientFunctionResultSender65Factory.create(chunkedMessage,
+              MessageType.EXECUTE_FUNCTION_RESULT,
+              serverConnection, functionObject, executeContext);
-      FunctionContext context = null;
+      FunctionContext context;
-        context = new FunctionContextImpl(cache, functionObject.getId(),
+        context = functionContextImplFactory.create(cache, functionObject.getId(),
-        context =
-            new FunctionContextImpl(cache, functionObject.getId(), args, resultSender, isReexecute);
+        context = functionContextImplFactory.create(cache, functionObject.getId(), args,
+            resultSender, isReexecute);
+
-        Exception e = cache.getInternalResourceManager().getHeapMonitor()
+        LowMemoryException lowMemoryException = cache.getInternalResourceManager().getHeapMonitor()
-        if (e != null) {
-          sendException(hasResult, clientMessage, e.getMessage(), serverConnection, e);
+        if (lowMemoryException != null) {
+          sendException(hasResult, clientMessage, lowMemoryException.getMessage(), serverConnection,
+              lowMemoryException);
-        /*
-         * if cache is null, then either cache has not yet been created on this node or it is a
-         * shutdown scenario.
-         */
-        DistributionManager dm = null;
-        if (cache != null) {
-          dm = cache.getDistributionManager();
-        }
+
+        // cache is never null or the above invocations would have thrown NPE
+        DistributionManager dm = cache.getDistributionManager();
-          executeFunctionaLocally(functionObject, context,
+          executeFunctionLocally(functionObject, context,
-      } catch (FunctionException functionException) {
+      } catch (FunctionException e) {
-        throw functionException;
-      } catch (Exception exception) {
+        throw e;
+      } catch (Exception e) {
-        throw new FunctionException(exception);
+        throw new FunctionException(e);
-    } catch (IOException ioException) {
-      logger.warn(String.format("Exception on server while executing function: %s",
-          function),
-          ioException);
-      String message =
-          "Server could not send the reply";
-      sendException(hasResult, clientMessage, message, serverConnection, ioException);
-    } catch (InternalFunctionInvocationTargetException internalfunctionException) {
-      // Fix for #44709: User should not be aware of
-      // InternalFunctionInvocationTargetException. No instance of
-      // InternalFunctionInvocationTargetException is giving useful
-      // information to user to take any corrective action hence logging
-      // this at fine level logging
-      // 1> When bucket is moved
-      // 2> Incase of HA FucntionInvocationTargetException thrown. Since
-      // it is HA, fucntion will be reexecuted on right node
-      // 3> Multiple target nodes found for single hop operation
-      // 4> in case of HA member departed
-      if (logger.isDebugEnabled()) {
-        logger.debug(String.format("Exception on server while executing function: %s",
-            new Object[] {function}),
-            internalfunctionException);
-      }
-      final String message = internalfunctionException.getMessage();
-      sendException(hasResult, clientMessage, message, serverConnection, internalfunctionException);
-    } catch (Exception e) {
-      logger.warn(String.format("Exception on server while executing function: %s",
-          function),
-          e);
-      final String message = e.getMessage();
+
+    } catch (IOException e) {
+      logger.warn("Exception on server while executing function: {}}", function, e);
+      String message = "Server could not send the reply";
+
+    } catch (InternalFunctionInvocationTargetException e) {
+      /*
+       * TRAC #44709: InternalFunctionInvocationTargetException should not be logged
+       * Fix for #44709: User should not be aware of InternalFunctionInvocationTargetException. No
+       * instance is giving useful information to user to take any corrective action hence logging
+       * this at fine level logging. May occur when:
+       * 1> When bucket is moved
+       * 2> In case of HA FunctionInvocationTargetException thrown. Since it is HA, function will
+       * be re-executed on right node
+       * 3> Multiple target nodes found for single hop operation
+       * 4> in case of HA member departed
+       */
+      if (logger.isDebugEnabled()) {
+        logger.debug("Exception on server while executing function: {}", function, e);
+      }
+      sendException(hasResult, clientMessage, e.getMessage(), serverConnection, e);
+
+    } catch (Exception e) {
+      logger.warn("Exception on server while executing function: {}", function, e);
+      sendException(hasResult, clientMessage, e.getMessage(), serverConnection, e);
-  private void executeFunctionaLocally(final Function fn, final FunctionContext cx,
+  private void executeFunctionLocally(final Function fn, final FunctionContext cx,
-      if (sender.isOkayToSendResult()
-          && !((ServerToClientFunctionResultSender65) sender).isLastResultReceived()
-          && fn.hasResult()) {
+      if (sender.isOkayToSendResult() && !sender.isLastResultReceived() && fn.hasResult()) {
-            String.format("The function, %s, did not send last result",
-                fn.getId()));
+            String.format("The function, %s, did not send last result", fn.getId()));
-      final TXStateProxy txState = TXManagerImpl.getCurrentTXState();
-      Runnable functionExecution = new Runnable() {
-        public void run() {
-          InternalCache cache = null;
-          try {
-            if (txState != null) {
-              cache = GemFireCacheImpl.getExisting("executing function");
-              cache.getTxManager().masqueradeAs(txState);
-              if (cache.getLogger().warningEnabled() && !ASYNC_TX_WARNING_ISSUED) {
-                ASYNC_TX_WARNING_ISSUED = true;
-                cache.getLogger().warning(
-                    "Function invoked within transactional context, but hasResults() is false; ordering of transactional operations cannot be guaranteed.  This message is only issued once by a server.");
-              }
+      TXStateProxy txState = TXManagerImpl.getCurrentTXState();
+      Runnable functionExecution = () -> {
+        InternalCache cache = null;
+        try {
+          if (txState != null) {
+            cache = GemFireCacheImpl.getExisting("executing function");
+            cache.getTxManager().masqueradeAs(txState);
+            if (cache.getLogger().warningEnabled() && !asyncTxWarningIssued) {
+              asyncTxWarningIssued = true;
+              cache.getLogger().warning(
+                  "Function invoked within transactional context, but hasResults() is false; ordering of transactional operations cannot be guaranteed.  This message is only issued once by a server.");
-            fn.execute(cx);
-          } catch (InternalFunctionInvocationTargetException internalfunctionException) {
-            // Fix for #44709: User should not be aware of
-            // InternalFunctionInvocationTargetException. No instance of
-            // InternalFunctionInvocationTargetException is giving useful
-            // information to user to take any corrective action hence logging
-            // this at fine level logging
-            // 1> Incase of HA FucntionInvocationTargetException thrown. Since
-            // it is HA, function will be reexecuted on right node
-            // 2> in case of HA member departed
-            stats.endFunctionExecutionWithException(fn.hasResult());
-            if (logger.isDebugEnabled()) {
-              logger.debug(String.format("Exception on server while executing function: %s",
-                  new Object[] {fn}),
-                  internalfunctionException);
-            }
-          } catch (FunctionException functionException) {
-            stats.endFunctionExecutionWithException(fn.hasResult());
-            logger.warn(String.format("Exception on server while executing function: %s",
-                fn),
-                functionException);
-          } catch (Exception exception) {
-            stats.endFunctionExecutionWithException(fn.hasResult());
-            logger.warn(String.format("Exception on server while executing function: %s",
-                fn),
-                exception);
-          } finally {
-            if (txState != null && cache != null) {
-              cache.getTxManager().unmasquerade(txState);
-            }
+          }
+          fn.execute(cx);
+        } catch (InternalFunctionInvocationTargetException e) {
+          // TRAC #44709: InternalFunctionInvocationTargetException should not be logged
+          stats.endFunctionExecutionWithException(fn.hasResult());
+          if (logger.isDebugEnabled()) {
+            logger.debug("Exception on server while executing function: {}", fn, e);
+          }
+        } catch (Exception e) {
+          stats.endFunctionExecutionWithException(fn.hasResult());
+          logger.warn("Exception on server while executing function: {}", fn, e);
+        } finally {
+          if (txState != null && cache != null) {
+            cache.getTxManager().unmasquerade(txState);
-        final ClusterDistributionManager newDM = (ClusterDistributionManager) dm;
+        ClusterDistributionManager newDM = (ClusterDistributionManager) dm;
+  interface ServerToClientFunctionResultSender65Factory {
+    ServerToClientFunctionResultSender65 create(ChunkedMessage msg, int messageType,
+        ServerConnection sc, Function function, ExecuteFunctionOperationContext authzContext);
+  }
+
+  interface FunctionContextImplFactory {
+    FunctionContextImpl create(Cache cache, String functionId, Object args,
+        ResultSender resultSender, boolean isPossibleDuplicate);
+  }
+
+  private static class DefaultServerToClientFunctionResultSender65Factory
+      implements ServerToClientFunctionResultSender65Factory {
+    @Override
+    public ServerToClientFunctionResultSender65 create(ChunkedMessage msg, int messageType,
+        ServerConnection sc, Function function, ExecuteFunctionOperationContext authzContext) {
+      return new ServerToClientFunctionResultSender65(msg, messageType, sc, function, authzContext);
+    }
+  }
+
+  private static class DefaultFunctionContextImplFactory implements FunctionContextImplFactory {
+    @Override
+    public FunctionContextImpl create(Cache cache, String functionId, Object args,
+        ResultSender resultSender, boolean isPossibleDuplicat) {
+      return new FunctionContextImpl(cache, functionId, args, resultSender, isPossibleDuplicat);
+    }
+  }

GEODE-3521: Allow region set operations to bootstrap a transaction. (#891)

* GEODE-3521: Allow region set operations to bootstrap a transaction.

  * Now Geode will bootstrap a transaction on a region set op even though
    it is a first operation in the transaction.
 * Add a SystemPropertyHelper class to held system properties to be set.
  * User needs to set a system property to disable this new behavior.
  * Do not allow an accessor to bootstrap a transaction.
  * Add a PausedTXStateProxyImpl state to allow product to know if a transaction is paused.
   *Product now detects if only same thread can unpause a paused transaction.
  * Do not bootstrap a new transaction again when transaction is paused.
  * Add a test case for testing pause and unpause.
  * A thread can not pause a transaction and start a new transaction - use suspend and resume instead.
 * Handle a situation that RegionEntry can be set in the KeyInfo when iterate through keys.

-import org.apache.logging.log4j.Logger;
-
+import org.apache.logging.log4j.Logger;
+    {
+      TXStateProxy curProxy = txContext.get();
+      if (curProxy == PAUSED) {
+        throw new java.lang.IllegalStateException(
+            "Current thread has paused its transaction so it can not start a new transaction");
+      }
+    }
+    if (tsp == PAUSED) {
+      // treats paused transaction as no transaction.
+      return null;
+    }
+    assert tsp != PAUSED;
+  private static final TXStateProxy PAUSED = new PausedTXStateProxyImpl();
+
+  /**
+   * If the current thread is in a transaction then pause will cause it to no longer be in a
+   * transaction. The same thread is expected to unpause/resume the transaction later.
+   *
+   * @return the state of the transaction or null. Pass this value to
+   *         {@link TXManagerImpl#unpauseTransaction} to reactivate the puased/suspended
+   *         transaction.
+   */
+  public TXStateProxy pauseTransaction() {
+    return internalSuspend(true);
+  }
+
+  /**
+   * If the current thread is in a transaction then suspend will cause it to no longer be in a
+   * transaction. Currently only used in testing.
+   * 
+   * @return the state of the transaction or null. to reactivate the suspended transaction.
+   * @deprecated use {@link TXManagerImpl#pauseTransaction} or
+   *             {@link CacheTransactionManager#suspend} instead
+   */
+  @Deprecated
+  public TXStateProxy internalSuspend() {
+    return internalSuspend(false);
+  }
+
-   * 
-   * @return the state of the transaction or null. Pass this value to {@link TXManagerImpl#resume}
-   *         to reactivate the suspended transaction.
+   *
+   * @param needToResumeBySameThread whether a suspended transaction needs to be resumed by the same
+   *        thread.
+   * @return the state of the transaction or null. Pass this value to
+   *         {@link TXManagerImpl#internalResume(TXStateProxy, boolean)} to reactivate the suspended
+   *         transaction.
-  public TXStateProxy internalSuspend() {
+  private TXStateProxy internalSuspend(boolean needToResumeBySameThread) {
-      setTXState(null);
+      if (needToResumeBySameThread) {
+        setTXState(PAUSED);
+      } else {
+        setTXState(null);
+      }
-   * Activates the specified transaction on the calling thread.
-   * 
+   * Activates the specified transaction on the calling thread. Only the same thread that pause the
+   * transaction can unpause it.
+   *
+   * @param tx the transaction to be unpaused.
+   * @throws IllegalStateException if this thread already has an active transaction or this thread
+   *         did not pause the transaction.
+   */
+  public void unpauseTransaction(TXStateProxy tx) {
+    internalResume(tx, true);
+  }
+
+  /**
+   * Activates the specified transaction on the calling thread. Does not require the same thread to
+   * resume it. Currently only used in testing.
+   *
+   * 
+   * @deprecated use {@link TXManagerImpl#unpauseTransaction} or
+   *             {@link CacheTransactionManager#resume} instead
+  @Deprecated
+    internalResume(tx, false);
+  }
+
+  /**
+   * Activates the specified transaction on the calling thread.
+   *
+   * @param tx the transaction to activate.
+   * @param needToResumeBySameThread whether a suspended transaction needs to be resumed by the same
+   *        thread.
+   * @throws IllegalStateException if this thread already has an active transaction
+   */
+  private void internalResume(TXStateProxy tx, boolean needToResumeBySameThread) {
+      if (needToResumeBySameThread) {
+        TXStateProxy result = txContext.get();
+        if (result != PAUSED) {
+          throw new java.lang.IllegalStateException(
+              "try to unpause a transaction not paused by the same thread");
+        }
+      }
+
+  public boolean isTransactionPaused() {
+    return txContext.get() == PAUSED;
+  }
+
-    if (t != null) {
+    if (t != null && t != PAUSED) {
-      internalSuspend();
+      result.suspend();
+      setTXState(null);
-    internalResume(txProxy);
+    assert getTXState() == null;
+    setTXState(txProxy);
+    txProxy.resume();

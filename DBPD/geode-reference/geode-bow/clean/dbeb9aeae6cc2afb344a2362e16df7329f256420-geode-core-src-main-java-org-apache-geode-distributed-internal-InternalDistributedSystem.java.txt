Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import java.util.concurrent.atomic.AtomicLong;
+import org.apache.geode.cache.CacheXmlException;
-import org.apache.geode.internal.statistics.platform.LinuxProcFsStatistics;
-import org.apache.geode.internal.statistics.platform.OsStatisticsFactory;
+import org.apache.geode.internal.statistics.platform.LinuxProcFsStatistics;
+import org.apache.geode.internal.statistics.platform.OsStatisticsFactory;
-import org.apache.geode.internal.util.concurrent.StoppableCondition;
-import org.apache.geode.internal.util.concurrent.StoppableReentrantLock;
- * The concrete implementation of {@link DistributedSystem} that
- * provides internal-only functionality.
+ * The concrete implementation of {@link DistributedSystem} that provides internal-only
+ * functionality.
+ * 
-public class InternalDistributedSystem extends DistributedSystem implements OsStatisticsFactory, StatisticsManager {
+public class InternalDistributedSystem extends DistributedSystem
+    implements OsStatisticsFactory, StatisticsManager {
-  public static final String DISABLE_MANAGEMENT_PROPERTY = DistributionConfig.GEMFIRE_PREFIX + "disableManagement";
+  public static final String DISABLE_MANAGEMENT_PROPERTY =
+      DistributionConfig.GEMFIRE_PREFIX + "disableManagement";
-  public static final CreationStackGenerator DEFAULT_CREATION_STACK_GENERATOR = new CreationStackGenerator() {
-    @Override
-    public Throwable generateCreationStack(final DistributionConfig config) {
-      return null;
-    }
-  };
+  public static final CreationStackGenerator DEFAULT_CREATION_STACK_GENERATOR =
+      new CreationStackGenerator() {
+        @Override
+        public Throwable generateCreationStack(final DistributionConfig config) {
+          return null;
+        }
+      };
-  public static final AtomicReference<CreationStackGenerator> TEST_CREATION_STACK_GENERATOR = new AtomicReference<CreationStackGenerator>(DEFAULT_CREATION_STACK_GENERATOR);
+  public static final AtomicReference<CreationStackGenerator> TEST_CREATION_STACK_GENERATOR =
+      new AtomicReference<CreationStackGenerator>(DEFAULT_CREATION_STACK_GENERATOR);
-   * The distribution manager that is used to communicate with the
-   * distributed system.
+   * The distribution manager that is used to communicate with the distributed system.
-  //  /** The log writer was provided by an external entity */
-  //  private boolean externalLogWriterProvided = false;
+  // /** The log writer was provided by an external entity */
+  // private boolean externalLogWriterProvided = false;
-   * Is this <code>DistributedSystem</code> connected to a
-   * distributed system?
+   * Is this <code>DistributedSystem</code> connected to a distributed system?
-   * Concurrency: volatile for reads and protected by synchronization of {@link #isConnectedMutex} for writes
+   * Concurrency: volatile for reads and protected by synchronization of {@link #isConnectedMutex}
+   * for writes
-   * Set to true if this distributed system is a singleton; it will
-   * always be the only member of the system.
+   * Set to true if this distributed system is a singleton; it will always be the only member of the
+   * system.
-   * A set of listeners that are invoked when this connection to the
-   * distributed system is disconnected
+   * A set of listeners that are invoked when this connection to the distributed system is
+   * disconnected
-   * Set of listeners that are invoked whenever a connection is created to
-   * the distributed system
+   * Set of listeners that are invoked whenever a connection is created to the distributed system
-   * whether this DS is one created to reconnect to the distributed
-   * system after a forced-disconnect.  This state is cleared once reconnect
-   * is successful.
+   * whether this DS is one created to reconnect to the distributed system after a
+   * forced-disconnect. This state is cleared once reconnect is successful.
-   * During a reconnect attempt this is used to perform quorum checks
-   * before allowing a location service to be started up in this JVM.
-   * If quorum checks fail then we delay starting location services until
-   * a live locator can be contacted.
+   * During a reconnect attempt this is used to perform quorum checks before allowing a location
+   * service to be started up in this JVM. If quorum checks fail then we delay starting location
+   * services until a live locator can be contacted.
-   * A Constant that matches the ThreadGroup name of the shutdown hook.
-   * This constant is used to insure consistency with LoggingThreadGroup.
-   * Due to Bug 38407, be careful about moving this to another class.
+   * A Constant that matches the ThreadGroup name of the shutdown hook. This constant is used to
+   * insure consistency with LoggingThreadGroup. Due to Bug 38407, be careful about moving this to
+   * another class.
-   * A property to prevent shutdown hooks from being registered with the VM.
-   * This is regarding bug 38407
+   * A property to prevent shutdown hooks from being registered with the VM. This is regarding bug
+   * 38407
-  public final static String DISABLE_SHUTDOWN_HOOK_PROPERTY = DistributionConfig.GEMFIRE_PREFIX + "disableShutdownHook";
+  public final static String DISABLE_SHUTDOWN_HOOK_PROPERTY =
+      DistributionConfig.GEMFIRE_PREFIX + "disableShutdownHook";
-  ////////////////////  Configuration Fields  ////////////////////
+  //////////////////// Configuration Fields ////////////////////
-  private final boolean statsDisabled = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "statsDisabled");
+  private final boolean statsDisabled =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "statsDisabled");
-  /////////////////////  Static Methods  /////////////////////
+  ///////////////////// Static Methods /////////////////////
-   * Creates a new instance of <code>InternalDistributedSystem</code>
-   * with the given configuration.
+   * Creates a new instance of <code>InternalDistributedSystem</code> with the given configuration.
-        LoggingThreadGroup.cleanUpThreadGroups(); // bug44365 - logwriters accumulate, causing mem leak
+        LoggingThreadGroup.cleanUpThreadGroups(); // bug44365 - logwriters accumulate, causing mem
+                                                  // leak
+   * 
-   * Returns a connection to the distributed system that is suitable
-   * for administration.  For administration, we are not as strict
-   * when it comes to existing connections.
+   * Returns a connection to the distributed system that is suitable for administration. For
+   * administration, we are not as strict when it comes to existing connections.
+   * 
-   * Returns a connected distributed system for this VM, or null
-   * if there is no connected distributed system in this VM.
-   * This method synchronizes on the existingSystems collection.
+   * Returns a connected distributed system for this VM, or null if there is no connected
+   * distributed system in this VM. This method synchronizes on the existingSystems collection.
-   * <p>author bruce
+   * <p>
+   * author bruce
+   * 
-        InternalDistributedSystem existingSystem = (InternalDistributedSystem) existingSystems.get(0);
+        InternalDistributedSystem existingSystem =
+            (InternalDistributedSystem) existingSystems.get(0);
-   * Returns the current distributed system, if there is one.
-   * Note: this method is no longer unsafe size existingSystems uses copy-on-write.
-   * <p>author bruce
+   * Returns the current distributed system, if there is one. Note: this method is no longer unsafe
+   * size existingSystems uses copy-on-write.
+   * <p>
+   * author bruce
+   * 
-  //////////////////////  Constructors  //////////////////////
+  ////////////////////// Constructors //////////////////////
-   * Creates a new <code>InternalDistributedSystem</code> with the
-   * given configuration properties.  Does all of the magic of finding
-   * the "default" values of properties.  See {@link
-   * DistributedSystem#connect} for a list of exceptions that may be
-   * thrown.
-   * @param nonDefault The non-default configuration properties specified by the
-   * caller
+   * Creates a new <code>InternalDistributedSystem</code> with the given configuration properties.
+   * Does all of the magic of finding the "default" values of properties. See
+   * {@link DistributedSystem#connect} for a list of exceptions that may be thrown.
+   * 
+   * @param nonDefault The non-default configuration properties specified by the caller
-    ((DistributionConfigImpl) this.originalConfig).checkForDisallowedDefaults(); // throws IllegalStateEx
+    ((DistributionConfigImpl) this.originalConfig).checkForDisallowedDefaults(); // throws
+                                                                                 // IllegalStateEx
-    this.creationStack = TEST_CREATION_STACK_GENERATOR.get().generateCreationStack(this.originalConfig);
+    this.creationStack =
+        TEST_CREATION_STACK_GENERATOR.get().generateCreationStack(this.originalConfig);
-    //    if (DistributionConfigImpl.multicastTest) {
-    //      this.logger.warning("Use of multicast has been forced");
-    //    }
-    //    if (DistributionConfigImpl.forceDisableTcp) {
-    //      this.logger.warning("Use of UDP has been forced");
-    //    }
-    //    if (org.apache.geode.distributed.internal.membership.jgroup.JGroupMembershipManager.multicastTest) {
-    //      this.logger.warning("Use of multicast for all distributed cache operations has been forced");
-    //    }
+    // if (DistributionConfigImpl.multicastTest) {
+    // this.logger.warning("Use of multicast has been forced");
+    // }
+    // if (DistributionConfigImpl.forceDisableTcp) {
+    // this.logger.warning("Use of UDP has been forced");
+    // }
+    // if
+    // (org.apache.geode.distributed.internal.membership.jgroup.JGroupMembershipManager.multicastTest)
+    // {
+    // this.logger.warning("Use of multicast for all distributed cache operations has been forced");
+    // }
-  ////////////////////  Instance Methods  ////////////////////
+  //////////////////// Instance Methods ////////////////////
+   * 
+   * 
+   * 
-   * Initializes this connection to a distributed system with the
-   * current configuration state.
+   * Initializes this connection to a distributed system with the current configuration state.
-        throw new GemFireConfigException("The " + LOCATORS + " attribute can not be empty when the " + MCAST_PORT + " attribute is non-zero.");
+        throw new GemFireConfigException("The " + LOCATORS + " attribute can not be empty when the "
+            + MCAST_PORT + " attribute is non-zero.");
+      AlertAppender.getInstance().onConnect(this);
+
-      final boolean hasLogFile = this.config.getLogFile() != null && !this.config.getLogFile().equals(new File(""));
-      final boolean hasSecurityLogFile = this.config.getSecurityLogFile() != null && !this.config.getSecurityLogFile().equals(new File(""));
+      final boolean hasLogFile =
+          this.config.getLogFile() != null && !this.config.getLogFile().equals(new File(""));
+      final boolean hasSecurityLogFile = this.config.getSecurityLogFile() != null
+          && !this.config.getSecurityLogFile().equals(new File(""));
-          this.logWriterAppender = LogWriterAppenders.getOrCreateAppender(LogWriterAppenders.Identifier.MAIN, this.isLoner, this.config, true);
+          this.logWriterAppender = LogWriterAppenders.getOrCreateAppender(
+              LogWriterAppenders.Identifier.MAIN, this.isLoner, this.config, true);
-          this.securityLogWriterAppender = LogWriterAppenders.getOrCreateAppender(LogWriterAppenders.Identifier.SECURITY, this.isLoner, this.config, false);
+          this.securityLogWriterAppender = LogWriterAppenders.getOrCreateAppender(
+              LogWriterAppenders.Identifier.SECURITY, this.isLoner, this.config, false);
-      // LOG: create LogWriterLogger(s) for backwards compatibility of getLogWriter and getSecurityLogWriter
+      // LOG: create LogWriterLogger(s) for backwards compatibility of getLogWriter and
+      // getSecurityLogWriter
-        this.logWriter = LogWriterFactory.createLogWriterLogger(this.isLoner, false, this.config, true);
+        this.logWriter =
+            LogWriterFactory.createLogWriterLogger(this.isLoner, false, this.config, true);
-      //    logWriter.info("Created log writer for IDS@"+System.identityHashCode(this));
+      // logWriter.info("Created log writer for IDS@"+System.identityHashCode(this));
-        this.securityLogWriter = LogWriterFactory.createLogWriterLogger(this.isLoner, true, this.config, false);
+        this.securityLogWriter =
+            LogWriterFactory.createLogWriterLogger(this.isLoner, true, this.config, false);
-        logger.debug("This thread is initializing a new DistributedSystem in order to reconnect to other members");
+        logger.debug(
+            "This thread is initializing a new DistributedSystem in order to reconnect to other members");
-        throw new GemFireSecurityException(LocalizedStrings.InternalDistributedSystem_PROBLEM_IN_INITIALIZING_KEYS_FOR_CLIENT_AUTHENTICATION.toLocalizedString(), ex);
+        throw new GemFireSecurityException(
+            LocalizedStrings.InternalDistributedSystem_PROBLEM_IN_INITIALIZING_KEYS_FOR_CLIENT_AUTHENTICATION
+                .toLocalizedString(),
+            ex);
-      final long offHeapMemorySize = OffHeapStorage.parseOffHeapMemorySize(getConfig().getOffHeapMemorySize());
+      final long offHeapMemorySize =
+          OffHeapStorage.parseOffHeapMemorySize(getConfig().getOffHeapMemorySize());
-        // This calculation is not exact, but seems fairly close.  So far we have
+        // This calculation is not exact, but seems fairly close. So far we have
-            logger.warn(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT_WARN, size - avail));
+            logger.warn(LocalizedMessage.create(
+                LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT_WARN, size - avail));
-            throw new IllegalStateException(LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT.toLocalizedString(avail, size));
+            throw new IllegalStateException(
+                LocalizedStrings.InternalDistributedSystem_MEMORY_OVERCOMMIT
+                    .toLocalizedString(avail, size));
-            getDistributionManager().addHostedLocators(getDistributedMember(), InternalLocator.getLocatorStrings(), locator.isSharedConfigurationEnabled());
+            getDistributionManager().addHostedLocators(getDistributedMember(),
+                InternalLocator.getLocatorStrings(), locator.isSharedConfigurationEnabled());
-        // bug #48144 - The dm's channel threw an NPE.  It now throws this exception
+        // bug #48144 - The dm's channel threw an NPE. It now throws this exception
-        throw new SystemConnectException(LocalizedStrings.InternalDistributedSystem_DISTRIBUTED_SYSTEM_HAS_DISCONNECTED.toLocalizedString(), e);
+        throw new SystemConnectException(
+            LocalizedStrings.InternalDistributedSystem_DISTRIBUTED_SYSTEM_HAS_DISCONNECTED
+                .toLocalizedString(),
+            e);
-      //this.logger.info("ds created", new RuntimeException("DEBUG: STACK"));
+      // this.logger.info("ds created", new RuntimeException("DEBUG: STACK"));
-      //Log any instantiators that were registered before the log writer
-      //was created
+      // Log any instantiators that were registered before the log writer
+      // was created
-    if (locatorString.length() > 0) {
-      // when reconnecting we don't want to join with a colocated locator unless
-      // there is a quorum of the old members available
-      if (attemptingToReconnect && !this.isConnected) {
-        if (this.quorumChecker != null) {
-          logger.info("performing a quorum check to see if location services can be started early");
-          if (!quorumChecker.checkForQuorum(3 * this.config.getMemberTimeout())) {
-            logger.info("quorum check failed - not allowing location services to start early");
-            return;
-          }
-          logger.info("Quorum check passed - allowing location services to start early");
+    if (locatorString.length() == 0) {
+      return;
+    }
+
+    // when reconnecting we don't want to join with a colocated locator unless
+    // there is a quorum of the old members available
+    if (attemptingToReconnect && !this.isConnected) {
+      if (this.quorumChecker != null) {
+        logger.info("performing a quorum check to see if location services can be started early");
+        if (!quorumChecker.checkForQuorum(3 * this.config.getMemberTimeout())) {
+          logger.info("quorum check failed - not allowing location services to start early");
+          return;
+        logger.info("Quorum check passed - allowing location services to start early");
-      DistributionLocatorId locId = new DistributionLocatorId(locatorString);
+    }
+    DistributionLocatorId locId = new DistributionLocatorId(locatorString);
+    try {
+      this.startedLocator =
+          InternalLocator.createLocator(locId.getPort(), null, null, this.logWriter, // LOG: this is
+                                                                                     // after IDS
+                                                                                     // has created
+                                                                                     // LogWriterLoggers
+                                                                                     // and
+                                                                                     // Appenders
+              this.securityLogWriter, // LOG: this is after IDS has created LogWriterLoggers and
+                                      // Appenders
+              locId.getHost(), locId.getHostnameForClients(), this.originalConfig.toProperties(),
+              false);
+
+      // if locator is started this way, cluster config is not enabled, set the flag correctly
+      this.startedLocator.getConfig().setEnableClusterConfiguration(false);
+
+      boolean startedPeerLocation = false;
-        this.startedLocator = InternalLocator.createLocator(locId.getPort(), null, null, this.logWriter, // LOG: this is after IDS has created LogWriterLoggers and Appenders
-          this.securityLogWriter, // LOG: this is after IDS has created LogWriterLoggers and Appenders
-          locId.getHost(), locId.getHostnameForClients(), this.originalConfig.toProperties(), false);
-        if (locId.isPeerLocator()) {
-          boolean startedPeerLocation = false;
-          try {
-            this.startedLocator.startPeerLocation(true);
-            startedPeerLocation = true;
-          } finally {
-            if (!startedPeerLocation) {
-              this.startedLocator.stop();
-            }
-          }
+        this.startedLocator.startPeerLocation(true);
+        startedPeerLocation = true;
+      } finally {
+        if (!startedPeerLocation) {
+          this.startedLocator.stop();
-      } catch (IOException e) {
-        throw new GemFireIOException(LocalizedStrings.
-          InternalDistributedSystem_PROBLEM_STARTING_A_LOCATOR_SERVICE.toLocalizedString(), e);
+    } catch (IOException e) {
+      throw new GemFireIOException(
+          LocalizedStrings.InternalDistributedSystem_PROBLEM_STARTING_A_LOCATOR_SERVICE
+              .toLocalizedString(),
+          e);
-      String locatorString = this.originalConfig.getStartLocator();
-      //      DistributionLocatorId locId = new DistributionLocatorId(locatorString);
-        // during the period when the product is using only paper licenses we always
-        // start server location services in order to be able to log information
-        // about the use of cache servers
-        //      if(locId.isServerLocator()) {
-        //      }
-
-   * Checks whether or not this connection to a distributed system is
-   * closed.
-   * @throws DistributedSystemDisconnectedException This connection has been {@link #disconnect(boolean, String, boolean) disconnected}
+   * Checks whether or not this connection to a distributed system is closed.
+   * 
+   * @throws DistributedSystemDisconnectedException This connection has been
+   *         {@link #disconnect(boolean, String, boolean) disconnected}
-      throw new DistributedSystemDisconnectedException(LocalizedStrings.InternalDistributedSystem_THIS_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_HAS_BEEN_DISCONNECTED.toLocalizedString(), dm
-        .getRootCause());
+      throw new DistributedSystemDisconnectedException(
+          LocalizedStrings.InternalDistributedSystem_THIS_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_HAS_BEEN_DISCONNECTED
+              .toLocalizedString(),
+          dm.getRootCause());
-   * This class defers to the DM.  If we don't have a DM, we're dead.
+   * This class defers to the DM. If we don't have a DM, we're dead.
-  public Cache myCache;
-
-  public void setCache(Cache cache){
-	  myCache=cache;
-  }
-  public Cache getCache(){
-	  return myCache;
-  }
-  */
+   * public Cache myCache;
+   * 
+   * public void setCache(Cache cache){ myCache=cache; } public Cache getCache(){ return myCache; }
+   */
-   * Disconnects this VM from the distributed system.  Shuts down the
-   * distribution manager, and if necessary,
+   * Disconnects this VM from the distributed system. Shuts down the distribution manager, and if
+   * necessary,
-    disconnect(false, LocalizedStrings.InternalDistributedSystem_NORMAL_DISCONNECT.toLocalizedString(), false);
+    disconnect(false,
+        LocalizedStrings.InternalDistributedSystem_NORMAL_DISCONNECT.toLocalizedString(), false);
-   * Disconnects this member from the distributed system when an internal
-   * error has caused distribution to fail (e.g., this member was shunned)
+   * Disconnects this member from the distributed system when an internal error has caused
+   * distribution to fail (e.g., this member was shunned)
+   * 
-   * This is how much time, in milliseconds to allow a disconnect listener
-   * to run before we interrupt it.
+   * This is how much time, in milliseconds to allow a disconnect listener to run before we
+   * interrupt it.
-  static private final long MAX_DISCONNECT_WAIT = Long.getLong("DistributionManager.DISCONNECT_WAIT", 10 * 1000).longValue();
+  static private final long MAX_DISCONNECT_WAIT =
+      Long.getLong("DistributionManager.DISCONNECT_WAIT", 10 * 1000).longValue();
-   * Run a disconnect listener, checking for errors and
-   * honoring the timeout {@link #MAX_DISCONNECT_WAIT}.
+   * Run a disconnect listener, checking for errors and honoring the timeout
+   * {@link #MAX_DISCONNECT_WAIT}.
+   * 
-            logger.debug("Disconnect listener <{}> thwarted by cancellation: {}", dc, e, logger.isTraceEnabled() ? e : null);
+            logger.debug("Disconnect listener <{}> thwarted by cancellation: {}", dc, e,
+                logger.isTraceEnabled() ? e : null);
-      logger.warn(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_INTERRUPTED_WHILE_PROCESSING_DISCONNECT_LISTENER), e);
+      logger.warn(
+          LocalizedMessage.create(
+              LocalizedStrings.InternalDistributedSystem_INTERRUPTED_WHILE_PROCESSING_DISCONNECT_LISTENER),
+          e);
-      logger.warn(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_DISCONNECT_LISTENER_STILL_RUNNING__0, dc));
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.InternalDistributedSystem_DISCONNECT_LISTENER_STILL_RUNNING__0, dc));
-        logger.warn(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_DISCONNECT_LISTENER_IGNORED_ITS_INTERRUPT__0, dc));
+        logger.warn(LocalizedMessage.create(
+            LocalizedStrings.InternalDistributedSystem_DISCONNECT_LISTENER_IGNORED_ITS_INTERRUPT__0,
+            dc));
-    return disconnectListenerThreadBoolean != null && disconnectListenerThreadBoolean.booleanValue();
+    return disconnectListenerThreadBoolean != null
+        && disconnectListenerThreadBoolean.booleanValue();
+   * 
-        logger.debug("Disconnect listener <{}> thwarted by shutdown: {}", dc, e, logger.isTraceEnabled() ? e : null);
+        logger.debug("Disconnect listener <{}> thwarted by shutdown: {}", dc, e,
+            logger.isTraceEnabled() ? e : null);
-  private final ThreadGroup disconnectListenerThreadGroup = LoggingThreadGroup.createThreadGroup("Disconnect Listeners");
+  private final ThreadGroup disconnectListenerThreadGroup =
+      LoggingThreadGroup.createThreadGroup("Disconnect Listeners");
+   * 
-    for (; ; ) {
+    for (;;) {
-   * Process the shutdown listeners.  It is essential that the DM has been
-   * shut down before calling this step, to ensure that no new listeners are
-   * registering.
+   * Process the shutdown listeners. It is essential that the DM has been shut down before calling
+   * this step, to ensure that no new listeners are registering.
+   * 
-        // If this ever returns, rethrow the error.  We're poisoned
+        // If this ever returns, rethrow the error. We're poisoned
-        // catch VirtualMachineError (see above).  However, there is
+        // catch VirtualMachineError (see above). However, there is
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_SHUTDOWNLISTENER__0__THREW, s), t);
+        logger.fatal(LocalizedMessage
+            .create(LocalizedStrings.InternalDistributedSystem_SHUTDOWNLISTENER__0__THREW, s), t);
-    // set, no new ones will be created.  However, we must process any
+    // set, no new ones will be created. However, we must process any
-    for (; ; ) {
+    for (;;) {
-          // If this ever returns, rethrow the error.  We're poisoned
+          // If this ever returns, rethrow the error. We're poisoned
-          // catch VirtualMachineError (see above).  However, there is
+          // catch VirtualMachineError (see above). However, there is
-          logger.fatal(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_DISCONNECTLISTENERSHUTDOWN_THREW), t);
+          logger.fatal(LocalizedMessage.create(
+              LocalizedStrings.InternalDistributedSystem_DISCONNECTLISTENERSHUTDOWN_THREW), t);
+   * 
+   * 
-          getLogWriter().convertToLogWriterI18n().warning(LocalizedStrings.InternalDistributedSystem_DISCONNECT_WAIT_INTERRUPTED, e);
+          getLogWriter().convertToLogWriterI18n()
+              .warning(LocalizedStrings.InternalDistributedSystem_DISCONNECT_WAIT_INTERRUPTED, e);
-   * Disconnects this VM from the distributed system. Shuts down the
-   * distribution manager.
+   * Disconnects this VM from the distributed system. Shuts down the distribution manager.
+   * 
-   * @param keepAlive true if user requested durable subscriptions are to be retained at
-   * server.
+   * @param keepAlive true if user requested durable subscriptions are to be retained at server.
-      //      logger.info("disconnecting IDS@"+System.identityHashCode(this));
+      // logger.info("disconnecting IDS@"+System.identityHashCode(this));
-            disconnectListenerThread.set(Boolean.TRUE); // bug #42663 - this must be set while closing the cache
+            disconnectListenerThread.set(Boolean.TRUE); // bug #42663 - this must be set while
+                                                        // closing the cache
-              // check for fatal JVM error (see above).  However, there is
-              logger.warn(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_EXCEPTION_TRYING_TO_CLOSE_CACHE), e);
+              // check for fatal JVM error (see above). However, there is
+              logger.warn(
+                  LocalizedMessage.create(
+                      LocalizedStrings.InternalDistributedSystem_EXCEPTION_TRYING_TO_CLOSE_CACHE),
+                  e);
-      LoggingThreadGroup.cleanUpThreadGroups(); // bug35388 - logwriters accumulate, causing mem leak
+      LoggingThreadGroup.cleanUpThreadGroups(); // bug35388 - logwriters accumulate, causing mem
+                                                // leak
-   * Returns the distribution manager without checking for connected or not so
-   * can also return null.
+   * Returns the distribution manager without checking for connected or not so can also return null.
-   * If this DistributedSystem is attempting to reconnect to the distributed system
-   * this will return the quorum checker created by the old MembershipManager for
-   * checking to see if a quorum of old members can be reached.
+   * If this DistributedSystem is attempting to reconnect to the distributed system this will return
+   * the quorum checker created by the old MembershipManager for checking to see if a quorum of old
+   * members can be reached.
+   * 
-   * Returns true if this DS has been attempting to reconnect but
-   * the attempt has been cancelled.
+   * Returns true if this DS has been attempting to reconnect but the attempt has been cancelled.
-   * Returns whether or not this distributed system has the same
-   * configuration as the given set of properties.
+   * Returns whether or not this distributed system has the same configuration as the given set of
+   * properties.
+   * 
-   * Returns whether or not the given configuration properties refer
-   * to the same distributed system as this
-   * <code>InternalDistributedSystem</code> connection.
+   * Returns whether or not the given configuration properties refer to the same distributed system
+   * as this <code>InternalDistributedSystem</code> connection.
+   * 
+   * 
-    for (Iterator iter = sorted.iterator(); iter.hasNext(); ) {
+    for (Iterator iter = sorted.iterator(); iter.hasNext();) {
-   * Returns the id of this connection to the distributed system.
-   * This is actually the port of the distribution manager's
-   * distribution channel.
+   * Returns the id of this connection to the distributed system. This is actually the port of the
+   * distribution manager's distribution channel.
+   * 
-    //Search through the set of all members
+    // Search through the set of all members
-      //Check to see if the passed in address is matches one of the addresses on
-      //the given member.
+      // Check to see if the passed in address is matches one of the addresses on
+      // the given member.
-  ///////////////////////  Utility Methods  ///////////////////////
+  /////////////////////// Utility Methods ///////////////////////
-   * Since {@link DistributedSystem#connect} guarantees that there is
-   * a canonical instance of <code>DistributedSystem</code> for each
-   * configuration, we can use the default implementation of
+   * Since {@link DistributedSystem#connect} guarantees that there is a canonical instance of
+   * <code>DistributedSystem</code> for each configuration, we can use the default implementation of
+   * 
-   * Since we use the default implementation of {@link #equals
-   * equals}, we can use the default implementation of
-   * <code>hashCode</code>.
+   * Since we use the default implementation of {@link #equals equals}, we can use the default
+   * implementation of <code>hashCode</code>.
-   * Returns a string describing this connection to distributed system
-   * (including highlights of its configuration).
+   * Returns a string describing this connection to distributed system (including highlights of its
+   * configuration).
-  private long statsListUniqueId = 1;
-  private final Object statsListUniqueIdLock = new Object();
+  private AtomicLong statsListUniqueId = new AtomicLong(1);
-  private final ConcurrentHashMap<String, FunctionStats> functionExecutionStatsMap = new ConcurrentHashMap<String, FunctionStats>();
+  private final ConcurrentHashMap<String, FunctionStats> functionExecutionStatsMap =
+      new ConcurrentHashMap<String, FunctionStats>();
-    throw new RuntimeException(LocalizedStrings.PureStatSampler_COULD_NOT_FIND_STATISTICS_INSTANCE.toLocalizedString());
+    throw new RuntimeException(
+        LocalizedStrings.PureStatSampler_COULD_NOT_FIND_STATISTICS_INSTANCE.toLocalizedString());
-    return (Statistics[])statsList.toArray(new Statistics[0]);
+    return (Statistics[]) statsList.toArray(new Statistics[0]);
-  public Statistics createOsStatistics(StatisticsType type, String textId, long numericId, int osStatFlags) {
+  public Statistics createOsStatistics(StatisticsType type, String textId, long numericId,
+      int osStatFlags) {
-    long myUniqueId;
-    synchronized (statsListUniqueIdLock) {
-      myUniqueId = statsListUniqueId++; // fix for bug 30597
-    }
-    Statistics result = new LocalStatisticsImpl(type, textId, numericId, myUniqueId, false, osStatFlags, this);
+    long myUniqueId = statsListUniqueId.getAndIncrement();
+    Statistics result =
+        new LocalStatisticsImpl(type, textId, numericId, myUniqueId, false, osStatFlags, this);
-   * For every registered statistic instance call the specified visitor.
-   * This method was added to fix bug 40358
+   * For every registered statistic instance call the specified visitor. This method was added to
+   * fix bug 40358
+   * 
-    long myUniqueId;
-    synchronized (statsListUniqueIdLock) {
-      myUniqueId = statsListUniqueId++; // fix for bug 30597
-    }
+    long myUniqueId = statsListUniqueId.getAndIncrement();
-  public StatisticDescriptor createIntCounter(String name, String description, String units, boolean largerBetter) {
+  public StatisticDescriptor createIntCounter(String name, String description, String units,
+      boolean largerBetter) {
-  public StatisticDescriptor createLongCounter(String name, String description, String units, boolean largerBetter) {
+  public StatisticDescriptor createLongCounter(String name, String description, String units,
+      boolean largerBetter) {
-  public StatisticDescriptor createDoubleCounter(String name, String description, String units, boolean largerBetter) {
+  public StatisticDescriptor createDoubleCounter(String name, String description, String units,
+      boolean largerBetter) {
-  public StatisticDescriptor createIntGauge(String name, String description, String units, boolean largerBetter) {
+  public StatisticDescriptor createIntGauge(String name, String description, String units,
+      boolean largerBetter) {
-  public StatisticDescriptor createLongGauge(String name, String description, String units, boolean largerBetter) {
+  public StatisticDescriptor createLongGauge(String name, String description, String units,
+      boolean largerBetter) {
-  public StatisticDescriptor createDoubleGauge(String name, String description, String units, boolean largerBetter) {
+  public StatisticDescriptor createDoubleGauge(String name, String description, String units,
+      boolean largerBetter) {
-   * Makes note of a <code>ConnectListener</code> whose
-   * <code>onConnect</code> method will be invoked when a connection is
-   * created to a distributed system.
+   * Makes note of a <code>ConnectListener</code> whose <code>onConnect</code> method will be
+   * invoked when a connection is created to a distributed system.
+   * 
-   * Makes note of a <code>ReconnectListener</code> whose
-   * <code>onReconnect</code> method will be invoked when a connection is
-   * recreated to a distributed system during auto-reconnect.<p>
+   * Makes note of a <code>ReconnectListener</code> whose <code>onReconnect</code> method will be
+   * invoked when a connection is recreated to a distributed system during auto-reconnect.
+   * <p>
-    //    (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("registering reconnect listener: " + listener);
+    // (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("registering reconnect
+    // listener: " + listener);
-   * Removes a <code>ConnectListener</code> from the list of
-   * listeners that will be notified when a connection is created to
-   * a distributed system.
+   * Removes a <code>ConnectListener</code> from the list of listeners that will be notified when a
+   * connection is created to a distributed system.
+   * 
-   * Notifies all registered <code>ConnectListener</code>s that a
-   * connection to a distributed system has been created.
+   * Notifies all registered <code>ConnectListener</code>s that a connection to a distributed system
+   * has been created.
-      for (Iterator iter = connectListeners.iterator(); iter.hasNext(); ) {
+      for (Iterator iter = connectListeners.iterator(); iter.hasNext();) {
-          // If this ever returns, rethrow the error.  We're poisoned
+          // If this ever returns, rethrow the error. We're poisoned
-          // catch VirtualMachineError (see above).  However, there is
+          // catch VirtualMachineError (see above). However, there is
-          sys.getLogWriter().convertToLogWriterI18n().severe(LocalizedStrings.InternalDistributedSystem_CONNECTLISTENER_THREW, t);
+          sys.getLogWriter().convertToLogWriterI18n()
+              .severe(LocalizedStrings.InternalDistributedSystem_CONNECTLISTENER_THREW, t);
-   * Removes a <code>ReconnectListener</code> from the list of
-   * listeners that will be notified when a connection is recreated to
-   * a distributed system.
+   * Removes a <code>ReconnectListener</code> from the list of listeners that will be notified when
+   * a connection is recreated to a distributed system.
-   * Notifies all registered <code>ReconnectListener</code>s that a
-   * connection to a distributed system has been recreated.
+   * Notifies all registered <code>ReconnectListener</code>s that a connection to a distributed
+   * system has been recreated.
-  private static void notifyReconnectListeners(InternalDistributedSystem oldsys, InternalDistributedSystem newsys, boolean starting) {
+  private static void notifyReconnectListeners(InternalDistributedSystem oldsys,
+      InternalDistributedSystem newsys, boolean starting) {
-        // check for fatal JVM error (see above).  However, there is
+        // check for fatal JVM error (see above). However, there is
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_CONNECTLISTENER_THREW), t);
+        logger.fatal(LocalizedMessage
+            .create(LocalizedStrings.InternalDistributedSystem_CONNECTLISTENER_THREW), t);
-   * Notifies all resource event listeners. All exceptions are caught here and
-   * only a warning message is printed in the log
+   * Notifies all resource event listeners. All exceptions are caught here and only a warning
+   * message is printed in the log
+   * 
-    for (Iterator<ResourceEventsListener> iter = resourceListeners.iterator(); iter.hasNext(); ) {
+    for (Iterator<ResourceEventsListener> iter = resourceListeners.iterator(); iter.hasNext();) {
-        //ignore
-      } catch (GemFireSecurityException|ManagementException ex) {
+        // ignore
+      } catch (GemFireSecurityException | ManagementException ex) {
-   * Makes note of a <code>DisconnectListener</code> whose
-   * <code>onDisconnect</code> method will be invoked when this
-   * connection to the distributed system is disconnected.
+   * Makes note of a <code>DisconnectListener</code> whose <code>onDisconnect</code> method will be
+   * invoked when this connection to the distributed system is disconnected.
-      if (disconnectListenerThreadBoolean == null || !disconnectListenerThreadBoolean.booleanValue()) {
+      if (disconnectListenerThreadBoolean == null
+          || !disconnectListenerThreadBoolean.booleanValue()) {
-          throw new DistributedSystemDisconnectedException(LocalizedStrings.InternalDistributedSystem_NO_LISTENERS_PERMITTED_AFTER_SHUTDOWN_0.toLocalizedString(reason), dm
-            .getRootCause());
+          throw new DistributedSystemDisconnectedException(
+              LocalizedStrings.InternalDistributedSystem_NO_LISTENERS_PERMITTED_AFTER_SHUTDOWN_0
+                  .toLocalizedString(reason),
+              dm.getRootCause());
-   * A non-null value of Boolean.TRUE will identify a thread being used to
-   * execute disconnectListeners. {@link #addDisconnectListener} will
-   * not throw ShutdownException if the value is Boolean.TRUE.
+   * A non-null value of Boolean.TRUE will identify a thread being used to execute
+   * disconnectListeners. {@link #addDisconnectListener} will not throw ShutdownException if the
+   * value is Boolean.TRUE.
-   * Removes a <code>DisconnectListener</code> from the list of
-   * listeners that will be notified when this connection to the
-   * distributed system is disconnected.
+   * Removes a <code>DisconnectListener</code> from the list of listeners that will be notified when
+   * this connection to the distributed system is disconnected.
+   * 
-   * Returns any existing <code>InternalDistributedSystem</code> instance.
-   * Returns <code>null</code> if no instance exists.
+   * Returns any existing <code>InternalDistributedSystem</code> instance. Returns <code>null</code>
+   * if no instance exists.
-   * Fires an "informational" <code>SystemMembershipEvent</code> in
-   * admin VMs.
+   * Fires an "informational" <code>SystemMembershipEvent</code> in admin VMs.
+   * 
-    throw new UnsupportedOperationException(LocalizedStrings.InternalDistributedSystem_NOT_IMPLEMENTED_YET.toLocalizedString());
+    throw new UnsupportedOperationException(
+        LocalizedStrings.InternalDistributedSystem_NOT_IMPLEMENTED_YET.toLocalizedString());
-   * Installs a shutdown hook to ensure
-   * that we are disconnected if an application VM shuts down
+   * Installs a shutdown hook to ensure that we are disconnected if an application VM shuts down
-      //Added for bug 38407
+      // Added for bug 38407
-              DurableClientAttributes dca = ((InternalDistributedSystem) ds).getDistributedMember().getDurableClientAttributes();
+              DurableClientAttributes dca = ((InternalDistributedSystem) ds).getDistributedMember()
+                  .getDurableClientAttributes();
-              ((InternalDistributedSystem) ds).disconnect(false, LocalizedStrings.InternalDistributedSystem_NORMAL_DISCONNECT.toLocalizedString(), isDurableClient/*keep alive drive from this*/);
+              ((InternalDistributedSystem) ds).disconnect(false,
+                  LocalizedStrings.InternalDistributedSystem_NORMAL_DISCONNECT.toLocalizedString(),
+                  isDurableClient/* keep alive drive from this */);
-              //              InternalDistributedSystem ids = (InternalDistributedSystem)ds;
-              //              if (ids.getDistributionManager() != null &&
-              //                  ids.getDistributionManager().getMembershipManager() != null) {
-              //                ids.getDistributionManager().getMembershipManager()
-              //                  .uncleanShutdown("VM is exiting", null);
-              //              }
+              // InternalDistributedSystem ids = (InternalDistributedSystem)ds;
+              // if (ids.getDistributionManager() != null &&
+              // ids.getDistributionManager().getMembershipManager() != null) {
+              // ids.getDistributionManager().getMembershipManager()
+              // .uncleanShutdown("VM is exiting", null);
+              // }
-  ///////////////////////  Inner Classes  ///////////////////////
+  /////////////////////// Inner Classes ///////////////////////
-   * A listener that gets invoked before this connection to the
-   * distributed system is disconnected.
+   * A listener that gets invoked before this connection to the distributed system is disconnected.
-     * Invoked before a connection to the distributed system is
-     * disconnected.
-     * @param sys the the system we are disconnecting from
-     * process should take before returning.
+     * Invoked before a connection to the distributed system is disconnected.
+     * 
+     * @param sys the the system we are disconnecting from process should take before returning.
-     * @param oldSystem the old DS, which is in a partially disconnected state
-     * and cannot be used for messaging
+     * 
+     * @param oldSystem the old DS, which is in a partially disconnected state and cannot be used
+     *        for messaging
+     * 
-    public void onReconnect(InternalDistributedSystem oldSystem, InternalDistributedSystem newSystem);
+    public void onReconnect(InternalDistributedSystem oldSystem,
+        InternalDistributedSystem newSystem);
-   * A listener that gets invoked after this connection to the
-   * distributed system is disconnected
+   * A listener that gets invoked after this connection to the distributed system is disconnected
-     * Invoked after the connection to the distributed system has
-     * been disconnected
+     * Invoked after the connection to the distributed system has been disconnected
+     * 
-   * Integer representing number of tries already made
-   * to reconnect and that failed.
+   * Integer representing number of tries already made to reconnect and that failed.
-   * Boolean indicating if DS needs to reconnect and reconnect
-   * is in progress.
+   * Boolean indicating if DS needs to reconnect and reconnect is in progress.
-   * Boolean indicating that this member has been shunned by other members
-   * or a network partition has occurred
+   * Boolean indicating that this member has been shunned by other members or a network partition
+   * has occurred
-   * Was this distributed system started with FORCE_LOCATOR_DM_TYPE=true?
-   * We need to know when reconnecting.
+   * Was this distributed system started with FORCE_LOCATOR_DM_TYPE=true? We need to know when
+   * reconnecting.
-   * Returns true if we are reconnecting the distributed system or
-   * reconnect has completed.  If this returns true it means that
-   * this instance of the DS is now disconnected and unusable.
+   * Returns true if we are reconnecting the distributed system or reconnect has completed. If this
+   * returns true it means that this instance of the DS is now disconnected and unusable.
-   * Returns true if we are reconnecting the distributed system
-   * and this instance was created for one of the connection
-   * attempts.  If the connection succeeds this state is cleared
-   * and this method will commence to return false.
+   * Returns true if we are reconnecting the distributed system and this instance was created for
+   * one of the connection attempts. If the connection succeeds this state is cleared and this
+   * method will commence to return false.
-   * returns the membership socket of the old
-   * distributed system, if available, when
-   * isReconnectingDS returns true.  This is
-   * used to connect the new DM to the distributed
-   * system through RemoteTransportConfig.
+   * returns the membership socket of the old distributed system, if available, when
+   * isReconnectingDS returns true. This is used to connect the new DM to the distributed system
+   * through RemoteTransportConfig.
-   * Returns true if this DS reconnected to the distributed system after
-   * a forced disconnect or loss of required-roles
+   * Returns true if this DS reconnected to the distributed system after a forced disconnect or loss
+   * of required-roles
-   * Make sure this instance of DS never does a reconnect.
-   * Also if reconnect is in progress cancel it.
+   * Make sure this instance of DS never does a reconnect. Also if reconnect is in progress cancel
+   * it.
-    //    (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("cancelReconnect invoked", new Exception("stack trace"));
+    // (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("cancelReconnect invoked",
+    // new Exception("stack trace"));
-   * Tries to reconnect to the distributed system on role loss
-   * if configure to reconnect.
+   * Tries to reconnect to the distributed system on role loss if configure to reconnect.
+   * 
-    synchronized (CacheFactory.class) { // bug #51335 - deadlock with app thread trying to create a cache
+    synchronized (CacheFactory.class) { // bug #51335 - deadlock with app thread trying to create a
+                                        // cache
-          if (!forcedDisconnect && !oldCache.isClosed() && oldCache.getCachePerfStats().getReliableRegionsMissing() == 0) {
+          if (!forcedDisconnect && !oldCache.isClosed()
+              && oldCache.getCachePerfStats().getReliableRegionsMissing() == 0) {
-   * Returns the value for the number of time reconnect has been tried.
-   * Test method used by DUnit.
+   * Returns the value for the number of time reconnect has been tried. Test method used by DUnit.
-   * A reconnect is tried when gemfire is configured to reconnect in
-   * case of a required role loss. The reconnect will try reconnecting
-   * to the distributed system every max-time-out millseconds for
-   * max-number-of-tries configured in gemfire.properties file. It uses
-   * the cache.xml file to intialize the cache and create regions.
+   * A reconnect is tried when gemfire is configured to reconnect in case of a required role loss.
+   * The reconnect will try reconnecting to the distributed system every max-time-out millseconds
+   * for max-number-of-tries configured in gemfire.properties file. It uses the cache.xml file to
+   * intialize the cache and create regions.
-    //Close the cache,
+    // Close the cache,
-    // whether the reconnected system should stay up.  After max-tries we will
+    // whether the reconnected system should stay up. After max-tries we will
-    // first save the current cache description.  This is created by
-    // the membership manager when forced-disconnect starts.  If we're
+    // first save the current cache description. This is created by
+    // the membership manager when forced-disconnect starts. If we're
-              logger.debug("Stopping the checkrequiredrole thread because reconnect : {} reached the max number of reconnect tries : {}", reconnectAttemptCounter, maxTries);
+              logger.debug(
+                  "Stopping the checkrequiredrole thread because reconnect : {} reached the max number of reconnect tries : {}",
+                  reconnectAttemptCounter, maxTries);
-            throw new CacheClosedException(LocalizedStrings.InternalDistributedSystem_SOME_REQUIRED_ROLES_MISSING.toLocalizedString());
+            throw new CacheClosedException(
+                LocalizedStrings.InternalDistributedSystem_SOME_REQUIRED_ROLES_MISSING
+                    .toLocalizedString());
-          logger.warn(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_WAITING_THREAD_FOR_RECONNECT_GOT_INTERRUPTED));
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.InternalDistributedSystem_WAITING_THREAD_FOR_RECONNECT_GOT_INTERRUPTED));
-        logger.info(LocalizedMessage.create(LocalizedStrings.DISTRIBUTED_SYSTEM_RECONNECTING, new Object[] { reconnectAttemptCounter }));
+        logger.info(LocalizedMessage.create(LocalizedStrings.DISTRIBUTED_SYSTEM_RECONNECTING,
+            new Object[] {reconnectAttemptCounter}));
-            logger.warn(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_EXCEPTION_OCCURED_WHILE_TRYING_TO_CONNECT_THE_SYSTEM_DURING_RECONNECT), e);
+            logger.warn(
+                LocalizedMessage.create(
+                    LocalizedStrings.InternalDistributedSystem_EXCEPTION_OCCURED_WHILE_TRYING_TO_CONNECT_THE_SYSTEM_DURING_RECONNECT),
+                e);
-          logger.warn(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_EXCEPTION_OCCURED_WHILE_TRYING_TO_CONNECT_THE_SYSTEM_DURING_RECONNECT), ee);
+          logger.warn(
+              LocalizedMessage.create(
+                  LocalizedStrings.InternalDistributedSystem_EXCEPTION_OCCURED_WHILE_TRYING_TO_CONNECT_THE_SYSTEM_DURING_RECONNECT),
+              ee);
+            } catch (CacheXmlException e) {
+              logger.warn("Exception occured while trying to create the cache during reconnect", e);
+              reconnectDS.disconnect();
+              reconnectDS = null;
+              reconnectCancelled = true;
+              break;
-              logger.warn("Exception occured while trying to create the cache during reconnect", ignor);
+              logger.warn("Exception occured while trying to create the cache during reconnect",
+                  ignor);
-              logger.warn(LocalizedMessage.create(LocalizedStrings.InternalDistributedSystem_EXCEPTION_OCCURED_WHILE_TRYING_TO_CREATE_THE_CACHE_DURING_RECONNECT), e);
+              logger.warn(
+                  LocalizedMessage.create(
+                      LocalizedStrings.InternalDistributedSystem_EXCEPTION_OCCURED_WHILE_TRYING_TO_CREATE_THE_CACHE_DURING_RECONNECT),
+                  e);
-      logger.info("Reconnect completed.\nNew DistributedSystem is {}\nNew Cache is {}", reconnectDS, cache);
+      logger.info("Reconnect completed.\nNew DistributedSystem is {}\nNew Cache is {}", reconnectDS,
+          cache);
-   * after an auto-reconnect we may need to recreate a cache server
-   * and start it
+   * after an auto-reconnect we may need to recreate a cache server and start it
-  public void createAndStartCacheServers(List<CacheServerCreation> cacheServerCreation, GemFireCacheImpl cache) {
+  public void createAndStartCacheServers(List<CacheServerCreation> cacheServerCreation,
+      GemFireCacheImpl cache) {
-        throw new GemFireIOException(LocalizedStrings.CacheCreation_WHILE_STARTING_CACHE_SERVER_0.toLocalizedString(server), ex);
+        throw new GemFireIOException(
+            LocalizedStrings.CacheCreation_WHILE_STARTING_CACHE_SERVER_0.toLocalizedString(server),
+            ex);
+   * 
-        throw new IllegalStateException(LocalizedStrings.InternalDistributedSystem_A_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_ALREADY_EXISTS_IN_THIS_VM_IT_HAS_THE_FOLLOWING_CONFIGURATION_0
-          .toLocalizedString(sb.toString()));
+        throw new IllegalStateException(
+            LocalizedStrings.InternalDistributedSystem_A_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_ALREADY_EXISTS_IN_THIS_VM_IT_HAS_THE_FOLLOWING_CONFIGURATION_0
+                .toLocalizedString(sb.toString()));
-        throw new IllegalStateException(LocalizedStrings.InternalDistributedSystem_A_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_ALREADY_EXISTS_IN_THIS_VM_IT_HAS_THE_FOLLOWING_CONFIGURATION_0
-          .toLocalizedString(sb.toString()), this.creationStack);
+        throw new IllegalStateException(
+            LocalizedStrings.InternalDistributedSystem_A_CONNECTION_TO_A_DISTRIBUTED_SYSTEM_ALREADY_EXISTS_IN_THIS_VM_IT_HAS_THE_FOLLOWING_CONFIGURATION_0
+                .toLocalizedString(sb.toString()),
+            this.creationStack);
-    if(arrayLength > 0) {
+    if (arrayLength > 0) {
-   * A listener that gets invoked whenever a connection is created to
-   * a distributed system
+   * A listener that gets invoked whenever a connection is created to a distributed system
+   * 
-   * Provides synchronized time for this process based on other processes in
-   * this GemFire distributed system. GemFire distributed system coordinator
-   * adjusts each member's time by an offset. This offset for each member is
-   * calculated based on Berkeley Time Synchronization algorithm.
+   * Provides synchronized time for this process based on other processes in this GemFire
+   * distributed system. GemFire distributed system coordinator adjusts each member's time by an
+   * offset. This offset for each member is calculated based on Berkeley Time Synchronization
+   * algorithm.
+   * 
-    //    (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("stopReconnecting invoked", new Exception("stack trace"));
+    // (new ManagerLogWriter(LogWriterImpl.FINE_LEVEL, System.out)).fine("stopReconnecting invoked",
+    // new Exception("stack trace"));
-   * Provides hook for dunit to generate and store a detailed creation stack
-   * trace that includes the keys/values of DistributionConfig including
-   * security related attributes without introducing Privacy Violations that
-   * Fortify will complain about.
+   * Provides hook for dunit to generate and store a detailed creation stack trace that includes the
+   * keys/values of DistributionConfig including security related attributes without introducing
+   * Privacy Violations that Fortify will complain about.

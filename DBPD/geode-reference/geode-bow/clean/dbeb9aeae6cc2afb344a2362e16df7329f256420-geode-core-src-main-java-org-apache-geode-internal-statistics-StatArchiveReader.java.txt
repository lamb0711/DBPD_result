Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * StatArchiveReader provides APIs to read statistic snapshots from an archive
- * file.
+ * StatArchiveReader provides APIs to read statistic snapshots from an archive file.
-  
+
-   * @param autoClose if its <code>true</code> then the reader will close
-   *   input files as soon as it finds their end.
-   * @throws IOException if <code>archiveName</code> could not be opened
-   * read, or closed.
+   * 
+   * @param autoClose if its <code>true</code> then the reader will close input files as soon as it
+   *        finds their end.
+   * @throws IOException if <code>archiveName</code> could not be opened read, or closed.
-    throws IOException
-  {
+      throws IOException {
-    for (int i=0; i < archiveNames.length; i++) {
+    for (int i = 0; i < archiveNames.length; i++) {
-    
+
-   * @throws IOException if <code>archiveName</code> could not be opened
-   * read, or closed.
+   * 
+   * @throws IOException if <code>archiveName</code> could not be opened read, or closed.
-    this(new File[]{new File(archiveName)}, null, false);
+    this(new File[] {new File(archiveName)}, null, false);
-   * Returns an array of stat values that match the specified spec.
-   * If nothing matches then an empty array is returned.
+   * Returns an array of stat values that match the specified spec. If nothing matches then an empty
+   * array is returned.
-        return new StatValue[]{cv};
+        return new StatValue[] {cv};
-      for (int i=0; i < archives.length; i++) {
+      for (int i = 0; i < archives.length; i++) {
-      return (StatValue[])l.toArray(result);
+      return (StatValue[]) l.toArray(result);
-  
+
-   * Checks to see if any archives have changed since the StatArchiverReader
-   * instance was created or last updated. If an archive has additional
-   * samples then those are read the resource instances maintained by the
-   * reader are updated.
-   * <p>Once closed a reader can no longer be updated.
+   * Checks to see if any archives have changed since the StatArchiverReader instance was created or
+   * last updated. If an archive has additional samples then those are read the resource instances
+   * maintained by the reader are updated.
+   * <p>
+   * Once closed a reader can no longer be updated.
+   * 
-   * @throws IOException if an archive could not be opened
-   * read, or closed.
+   * @throws IOException if an archive could not be opened read, or closed.
+
-    for (int i=0; i < archives.length; i++) {
+    for (int i = 0; i < archives.length; i++) {
-   * Returns an unmodifiable list of all the {@link ResourceInst}
-   * this reader contains.
+   * Returns an unmodifiable list of all the {@link ResourceInst} this reader contains.
-  
+
-      for (int i=0; i < archives.length; i++) {
+      for (int i = 0; i < archives.length; i++) {
-  private int getMemoryUsed()  {
+  private int getMemoryUsed() {
-    for (int i=0; i < archives.length; i++) {
+    for (int i = 0; i < archives.length; i++) {
-    for (int i=0; i < archives.length; i++) {
+    for (int i = 0; i < archives.length; i++) {
-    case BOOLEAN_CODE:
-    case BYTE_CODE:
-    case CHAR_CODE:
-    case WCHAR_CODE:
-    case SHORT_CODE:
-    case INT_CODE:
-    case LONG_CODE:
-      return bits;
-    case FLOAT_CODE:
-      return Float.intBitsToFloat((int)bits);
-    case DOUBLE_CODE:
-      return Double.longBitsToDouble(bits);
-    default:
-      throw new InternalGemFireException(LocalizedStrings.StatArchiveReader_UNEXPECTED_TYPECODE_0.toLocalizedString(Integer.valueOf(type)));
+      case BOOLEAN_CODE:
+      case BYTE_CODE:
+      case CHAR_CODE:
+      case WCHAR_CODE:
+      case SHORT_CODE:
+      case INT_CODE:
+      case LONG_CODE:
+        return bits;
+      case FLOAT_CODE:
+        return Float.intBitsToFloat((int) bits);
+      case DOUBLE_CODE:
+        return Double.longBitsToDouble(bits);
+      default:
+        throw new InternalGemFireException(LocalizedStrings.StatArchiveReader_UNEXPECTED_TYPECODE_0
+            .toLocalizedString(Integer.valueOf(type)));
-  
+
+
+
+
+
+
+
-    
+
+
-      for (int i=0; i < archives.length; i++) {
+      for (int i = 0; i < archives.length; i++) {
+
-      for (int i=0; i < archives.length; i++) {
+      for (int i = 0; i < archives.length; i++) {
-      stream.println("  " + name + ": type=" + typeCode + " offset=" + offset
-                     + (isCounter? " counter" : "")
-                     + " units=" + units
-                     + " largerBetter=" + largerBetter
-                     + " desc=" + desc);
+      stream.println(
+          "  " + name + ": type=" + typeCode + " offset=" + offset + (isCounter ? " counter" : "")
+              + " units=" + units + " largerBetter=" + largerBetter + " desc=" + desc);
-    
-    protected StatDescriptor(String name, int offset, boolean isCounter,
-                           boolean largerBetter,
-                           byte typeCode, String units, String desc) {
+
+    protected StatDescriptor(String name, int offset, boolean isCounter, boolean largerBetter,
+        byte typeCode, String units, String desc) {
+
+
+
-     * Returns the type code of this statistic.
-     * It will be one of the following values:
+     * Returns the type code of this statistic. It will be one of the following values:
-     * <li> {@link #BOOLEAN_CODE}
-     * <li> {@link #WCHAR_CODE}
-     * <li> {@link #CHAR_CODE}
-     * <li> {@link #BYTE_CODE}
-     * <li> {@link #SHORT_CODE}
-     * <li> {@link #INT_CODE}
-     * <li> {@link #LONG_CODE}
-     * <li> {@link #FLOAT_CODE}
-     * <li> {@link #DOUBLE_CODE}
+     * <li>{@link #BOOLEAN_CODE}
+     * <li>{@link #WCHAR_CODE}
+     * <li>{@link #CHAR_CODE}
+     * <li>{@link #BYTE_CODE}
+     * <li>{@link #SHORT_CODE}
+     * <li>{@link #INT_CODE}
+     * <li>{@link #LONG_CODE}
+     * <li>{@link #FLOAT_CODE}
+     * <li>{@link #DOUBLE_CODE}
+
+
+
+
+
+
-     * {@link StatArchiveReader.StatValue} filter that causes the
-     * statistic values to be unfiltered. This causes the raw values
-     * written to the archive to be used.
-     * <p>This is the default filter for non-counter statistics.
-     * To determine if a statistic is not a counter use {@link StatArchiveReader.StatDescriptor#isCounter}.  */
+     * {@link StatArchiveReader.StatValue} filter that causes the statistic values to be unfiltered.
+     * This causes the raw values written to the archive to be used.
+     * <p>
+     * This is the default filter for non-counter statistics. To determine if a statistic is not a
+     * counter use {@link StatArchiveReader.StatDescriptor#isCounter}.
+     */
-     * {@link StatArchiveReader.StatValue} filter that causes the
-     * statistic values to be filtered to reflect how often they
-     * change per second.  Since the difference between two samples is
-     * used to calculate the value this causes the {@link StatArchiveReader.StatValue}
-     * to have one less sample than {@link #FILTER_NONE}. The instance
-     * time stamp that does not have a per second value is the
-     * instance's first time stamp {@link
-     * StatArchiveReader.ResourceInst#getFirstTimeMillis}.
-     * <p>This is the default filter for counter statistics.
-     * To determine if a statistic is a counter use {@link StatArchiveReader.StatDescriptor#isCounter}.  */
+     * {@link StatArchiveReader.StatValue} filter that causes the statistic values to be filtered to
+     * reflect how often they change per second. Since the difference between two samples is used to
+     * calculate the value this causes the {@link StatArchiveReader.StatValue} to have one less
+     * sample than {@link #FILTER_NONE}. The instance time stamp that does not have a per second
+     * value is the instance's first time stamp
+     * {@link StatArchiveReader.ResourceInst#getFirstTimeMillis}.
+     * <p>
+     * This is the default filter for counter statistics. To determine if a statistic is a counter
+     * use {@link StatArchiveReader.StatDescriptor#isCounter}.
+     */
-     * {@link StatArchiveReader.StatValue} filter that causes the
-     * statistic values to be filtered to reflect how much they
-     * changed between sample periods.  Since the difference between
-     * two samples is used to calculate the value this causes the
-     * {@link StatArchiveReader.StatValue} to have one less sample than {@link
-     * #FILTER_NONE}. The instance time stamp that does not have a per
-     * second value is the instance's first time stamp {@link
-     * StatArchiveReader.ResourceInst#getFirstTimeMillis}.
+     * {@link StatArchiveReader.StatValue} filter that causes the statistic values to be filtered to
+     * reflect how much they changed between sample periods. Since the difference between two
+     * samples is used to calculate the value this causes the {@link StatArchiveReader.StatValue} to
+     * have one less sample than {@link #FILTER_NONE}. The instance time stamp that does not have a
+     * per second value is the instance's first time stamp
+     * {@link StatArchiveReader.ResourceInst#getFirstTimeMillis}.
+
-     * Creates and returns a trimmed version of this stat value.
-     * Any samples taken before <code>startTime</code> and after
-     * <code>endTime</code> are discarded from the resulting value.
+     * Creates and returns a trimmed version of this stat value. Any samples taken before
+     * <code>startTime</code> and after <code>endTime</code> are discarded from the resulting value.
+
-     * Returns true if value has data that has been trimmed off it
-     * by a start timestamp.
+     * Returns true if value has data that has been trimmed off it by a start timestamp.
+
-     * Gets the {@link StatArchiveReader.ResourceType type} of the
-     * resources that this value belongs to.
+     * Gets the {@link StatArchiveReader.ResourceType type} of the resources that this value belongs
+     * to.
+
-     * Gets the {@link StatArchiveReader.ResourceInst resources} that this value
-     * belongs to.
+     * Gets the {@link StatArchiveReader.ResourceInst resources} that this value belongs to.
+
-     * Returns an array of timestamps for each unfiltered snapshot in this value.
-     * Each returned time stamp is the number of millis since
-     * midnight, Jan 1, 1970 UTC.
+     * Returns an array of timestamps for each unfiltered snapshot in this value. Each returned time
+     * stamp is the number of millis since midnight, Jan 1, 1970 UTC.
+
-     * Returns an array of timestamps for each unfiltered snapshot in this value.
-     * Each returned time stamp is the number of millis since
-     * midnight, Jan 1, 1970 UTC.
-     * The resolution is seconds.
+     * Returns an array of timestamps for each unfiltered snapshot in this value. Each returned time
+     * stamp is the number of millis since midnight, Jan 1, 1970 UTC. The resolution is seconds.
+
-     * Returns an array of doubles containing the unfiltered value of this
-     * statistic for each point in time that it was sampled.
+     * Returns an array of doubles containing the unfiltered value of this statistic for each point
+     * in time that it was sampled.
+
-     * Returns an array of doubles containing the filtered value of this
-     * statistic for each point in time that it was sampled.
+     * Returns an array of doubles containing the filtered value of this statistic for each point in
+     * time that it was sampled.
+
+
+
+
+
+
+
-     * Returns true if sample whose value was different from previous values
-     * has been added to this StatValue since the last time this method was
-     * called.
+     * Returns true if sample whose value was different from previous values has been added to this
+     * StatValue since the last time this method was called.
+
-     * Returns the current filter used to calculate this statistic's values.
-     * It will be one of these values:
+     * Returns the current filter used to calculate this statistic's values. It will be one of these
+     * values:
-     * <li> {@link #FILTER_NONE}
-     * <li> {@link #FILTER_PERSAMPLE}
-     * <li> {@link #FILTER_PERSEC}
+     * <li>{@link #FILTER_NONE}
+     * <li>{@link #FILTER_PERSAMPLE}
+     * <li>{@link #FILTER_PERSEC}
+
-     * Sets the current filter used to calculate this statistic's values.
-     * The default filter is {@link #FILTER_NONE} unless the statistic
-     * is a counter, {@link StatArchiveReader.StatDescriptor#isCounter},
-     * in which case its {@link #FILTER_PERSEC}.
+     * Sets the current filter used to calculate this statistic's values. The default filter is
+     * {@link #FILTER_NONE} unless the statistic is a counter,
+     * {@link StatArchiveReader.StatDescriptor#isCounter}, in which case its {@link #FILTER_PERSEC}.
+     * 
-     * <ul>
-     * <li> {@link #FILTER_NONE}
-     * <li> {@link #FILTER_PERSAMPLE}
-     * <li> {@link #FILTER_PERSEC}
-     * </ul>
+     *        <ul>
+     *        <li>{@link #FILTER_NONE}
+     *        <li>{@link #FILTER_PERSAMPLE}
+     *        <li>{@link #FILTER_PERSEC}
+     *        </ul>
+
+
+
+
+
+
+
+
-        if (filter != FILTER_NONE
-            && filter != FILTER_PERSEC
-            && filter != FILTER_PERSAMPLE) {
-          throw new IllegalArgumentException(LocalizedStrings.StatArchiveReader_FILTER_VALUE_0_MUST_BE_1_2_OR_3
-              .toLocalizedString(
-              new Object[] {
-                  Integer.valueOf(filter),
-                  Integer.valueOf(FILTER_NONE),
-                  Integer.valueOf(FILTER_PERSEC),
-                  Integer.valueOf(FILTER_PERSAMPLE)}));
+        if (filter != FILTER_NONE && filter != FILTER_PERSEC && filter != FILTER_PERSAMPLE) {
+          throw new IllegalArgumentException(
+              LocalizedStrings.StatArchiveReader_FILTER_VALUE_0_MUST_BE_1_2_OR_3.toLocalizedString(
+                  new Object[] {Integer.valueOf(filter), Integer.valueOf(FILTER_NONE),
+                      Integer.valueOf(FILTER_PERSEC), Integer.valueOf(FILTER_PERSAMPLE)}));
-        mostRecent = values[values.length-1];
+        mostRecent = values[values.length - 1];
-        for (int i=1; i < size; i++) {
+        for (int i = 1; i < size; i++) {
-          for (int i=0; i < size; i++) {
+          for (int i = 0; i < size; i++) {
-            stddev += (dv*dv);
+            stddev += (dv * dv);
-      result.append(": samples=")
-        .append(getSnapshotsSize());
+      result.append(": samples=").append(getSnapshotsSize());
-        result.append(" startTime=\"")
-          .append(new Date(startTime))
-          .append("\"");
+        result.append(" startTime=\"").append(new Date(startTime)).append("\"");
-        result.append(" endTime=\"")
-          .append(new Date(endTime))
-          .append("\"");
+        result.append(" endTime=\"").append(new Date(endTime)).append("\"");
-      result.append(" min=")
-        .append(nf.format(min));
-      result.append(" max=")
-        .append(nf.format(max));
-      result.append(" average=")
-        .append(nf.format(avg));
-      result.append(" stddev=")
-        .append(nf.format(stddev));
+      result.append(" min=").append(nf.format(min));
+      result.append(" max=").append(nf.format(max));
+      result.append(" average=").append(nf.format(avg));
+      result.append(" stddev=").append(nf.format(stddev));
-        .append(nf.format(mostRecent));
+          .append(nf.format(mostRecent));
-  
+
-   * A ComboValue is a value that is the logical combination of
-   * a set of other stat values.
-   * <p> For now ComboValue has a simple implementation that does not
-   * suppport updates.
+   * A ComboValue is a value that is the logical combination of a set of other stat values.
+   * <p>
+   * For now ComboValue has a simple implementation that does not suppport updates.
+
-      this((StatValue[])valueList.toArray(new StatValue[valueList.size()]));
+      this((StatValue[]) valueList.toArray(new StatValue[valueList.size()]));
+
-      for (int i=1; i < this.values.length; i++) {
+      for (int i = 1; i < this.values.length; i++) {
-          /* I'm not sure why this would happen.
-           * If it really can happen then this code should change
-           * the filter since a client has no way to select values
-           * based on the filter.
+          /*
+           * I'm not sure why this would happen. If it really can happen then this code should
+           * change the filter since a client has no way to select values based on the filter.
-          throw new IllegalArgumentException(LocalizedStrings.StatArchiveReader_CANT_COMBINE_VALUES_WITH_DIFFERENT_FILTERS.toLocalizedString());
+          throw new IllegalArgumentException(
+              LocalizedStrings.StatArchiveReader_CANT_COMBINE_VALUES_WITH_DIFFERENT_FILTERS
+                  .toLocalizedString());
-          throw new IllegalArgumentException(LocalizedStrings.StatArchiveReader_CANT_COMBINE_VALUES_WITH_DIFFERENT_TYPES.toLocalizedString());
+          throw new IllegalArgumentException(
+              LocalizedStrings.StatArchiveReader_CANT_COMBINE_VALUES_WITH_DIFFERENT_TYPES
+                  .toLocalizedString());
-          throw new IllegalArgumentException(LocalizedStrings.StatArchiveReader_CANT_COMBINE_DIFFERENT_STATS.toLocalizedString());
+          throw new IllegalArgumentException(
+              LocalizedStrings.StatArchiveReader_CANT_COMBINE_DIFFERENT_STATS.toLocalizedString());
-          } else if (this.values[bestTypeIdx].getDescriptor().isCounter()
-                     == this.values[bestTypeIdx].getDescriptor().isLargerBetter()) {
+          } else if (this.values[bestTypeIdx].getDescriptor()
+              .isCounter() == this.values[bestTypeIdx].getDescriptor().isLargerBetter()) {
-              bestTypeIdx = i;
+            bestTypeIdx = i;
-            if (this.values[bestTypeIdx].getDescriptor().isCounter()
-                == this.values[bestTypeIdx].getDescriptor().isLargerBetter()) {
+            if (this.values[bestTypeIdx].getDescriptor().isCounter() == this.values[bestTypeIdx]
+                .getDescriptor().isLargerBetter()) {
+
-      for (int i=0; i < this.values.length; i++) {
+      for (int i = 0; i < this.values.length; i++) {
+
+
+
-      for (int i=0; i < values.length; i++) {
+      for (int i = 0; i < values.length; i++) {
-      return (ResourceInst[])set.toArray(result);
+      return (ResourceInst[]) set.toArray(result);
+
-    
+
-      return (v1 == v2) || ((Math.abs(v1-v2)/2) <= delta);
+      return (v1 == v2) || ((Math.abs(v1 - v2) / 2) <= delta);
-    /**
-     * Return true if v is closer to prev.
-     * Return false if v is closer to next.
-     * Return true if v is the same distance from both.
-     */
-    public static boolean closer(long v, long prev, long next) {
-      return Math.abs(v-prev) <= Math.abs(v-next);
-    }
-      
-     * Return true if the current ts must be inserted instead of
-     * being mapped to the tsAtInsertPoint
+     * Return true if v is closer to prev. Return false if v is closer to next. Return true if v is
+     * the same distance from both.
+     */
+    public static boolean closer(long v, long prev, long next) {
+      return Math.abs(v - prev) <= Math.abs(v - next);
+    }
+
+
+    /**
+     * Return true if the current ts must be inserted instead of being mapped to the tsAtInsertPoint
-      return (nextIdx < valueTimeStamps.length)
-        && (valueTimeStamps[nextIdx] <= tsAtInsertPoint);
+      return (nextIdx < valueTimeStamps.length) && (valueTimeStamps[nextIdx] <= tsAtInsertPoint);
-    
+
-    
+
-//       for (int i=0; i < values.length; i++) {
-//         System.out.println("DEBUG: inst# " + i + " has "
-//                            + values[i].getRawAbsoluteTimeStamps().length
-//                            + " timestamps");
-//       }
+      // for (int i=0; i < values.length; i++) {
+      // System.out.println("DEBUG: inst# " + i + " has "
+      // + values[i].getRawAbsoluteTimeStamps().length
+      // + " timestamps");
+      // }
-      long[] ourTimeStamps = new long[(tsCount*2) + 1];
+      long[] ourTimeStamps = new long[(tsCount * 2) + 1];
-      for (int i=1; i < values.length; i++) {
+      for (int i = 1; i < values.length; i++) {
-        int j=0;
+        int j = 0;
-                 && !closeEnough(tsToInsert, tsAtInsertPoint, timeDelta)) {
-//             System.out.println("DEBUG: skipping " + ourIdx + " because it was not closeEnough");
+              && !closeEnough(tsToInsert, tsAtInsertPoint, timeDelta)) {
+            // System.out.println("DEBUG: skipping " + ourIdx + " because it was not closeEnough");
-              && !mustInsert(j+1, valueTimeStamps, tsAtInsertPoint)) {
+              && !mustInsert(j + 1, valueTimeStamps, tsAtInsertPoint)) {
-            while (!closer(tsToInsert, ourTimeStamps[ourIdx-1], ourTimeStamps[ourIdx])
+            while (!closer(tsToInsert, ourTimeStamps[ourIdx - 1], ourTimeStamps[ourIdx])
-//               System.out.println("DEBUG: skipping mergeTs[" + (ourIdx-1) + "]="
-//                                  + tsAtInsertPoint + " because it was closer to the next one");
+              // System.out.println("DEBUG: skipping mergeTs[" + (ourIdx-1) + "]="
+              // + tsAtInsertPoint + " because it was closer to the next one");
-            int endRunIdx=j+1;
+            int endRunIdx = j + 1;
-                   && valueTimeStamps[endRunIdx] < tsAtInsertPoint
-                   && !closeEnough(valueTimeStamps[endRunIdx], tsAtInsertPoint, timeDelta)) {
+                && valueTimeStamps[endRunIdx] < tsAtInsertPoint
+                && !closeEnough(valueTimeStamps[endRunIdx], tsAtInsertPoint, timeDelta)) {
-//             System.out.println("DEBUG: tsToInsert=" + tsToInsert
-//                                + " tsAtInsertPoint=" + tsAtInsertPoint
-//                                + " timeDelta=" + timeDelta
-//                                + " vDelta=" + (Math.abs(tsToInsert-tsAtInsertPoint)/2)
-//                                + " numToCopy=" + numToCopy);
-//             if (j > 0) {
-//               System.out.println("DEBUG: prevTsToInsert=" + valueTimeStamps[j-1]);
-//             }
-//             if (ourIdx > 0) {
-//               System.out.println("DEBUG ourTimeStamps[" + (ourIdx-1) + "]=" + ourTimeStamps[ourIdx-1]);
-//             }
+            // System.out.println("DEBUG: tsToInsert=" + tsToInsert
+            // + " tsAtInsertPoint=" + tsAtInsertPoint
+            // + " timeDelta=" + timeDelta
+            // + " vDelta=" + (Math.abs(tsToInsert-tsAtInsertPoint)/2)
+            // + " numToCopy=" + numToCopy);
+            // if (j > 0) {
+            // System.out.println("DEBUG: prevTsToInsert=" + valueTimeStamps[j-1]);
+            // }
+            // if (ourIdx > 0) {
+            // System.out.println("DEBUG ourTimeStamps[" + (ourIdx-1) + "]=" +
+            // ourTimeStamps[ourIdx-1]);
+            // }
-//             if (numToCopy > 1) {
-//               System.out.println("DEBUG: endRunTs=" + valueTimeStamps[endRunIdx-1]);
-//             }
-            if (tsCount+numToCopy > ourTimeStamps.length) {
+            // if (numToCopy > 1) {
+            // System.out.println("DEBUG: endRunTs=" + valueTimeStamps[endRunIdx-1]);
+            // }
+            if (tsCount + numToCopy > ourTimeStamps.length) {
-              long[] tmp = new long[(tsCount+numToCopy)*2];
+              long[] tmp = new long[(tsCount + numToCopy) * 2];
-            System.arraycopy(ourTimeStamps, ourIdx,
-                             ourTimeStamps, ourIdx+numToCopy,
-                             tsCount-ourIdx);
+            System.arraycopy(ourTimeStamps, ourIdx, ourTimeStamps, ourIdx + numToCopy,
+                tsCount - ourIdx);
-              System.arraycopy(valueTimeStamps, j,
-                               ourTimeStamps, ourIdx,
-                               numToCopy);
+              System.arraycopy(valueTimeStamps, j, ourTimeStamps, ourIdx, numToCopy);
-            // skip over all inserted elements 
+            // skip over all inserted elements
-//           System.out.println("DEBUG: inst #" + i
-//                              + " valueTs[" + (j-1) + "]=" + tsToInsert
-//                              + " found/inserted at"
-//                              + " mergeTs[" + (ourIdx-1) + "]=" + ourTimeStamps[ourIdx-1]);
+          // System.out.println("DEBUG: inst #" + i
+          // + " valueTs[" + (j-1) + "]=" + tsToInsert
+          // + " found/inserted at"
+          // + " mergeTs[" + (ourIdx-1) + "]=" + ourTimeStamps[ourIdx-1]);
-//       for (int i=0; i < tsCount; i++) {
-//         System.out.println("DEBUG: mergedTs[" + i + "]=" + ourTimeStamps[i]);
-//         if (i > 0 && ourTimeStamps[i] <= ourTimeStamps[i-1]) {
-//           System.out.println("DEBUG: ERROR ts was not greater than previous");
-//         }
-//       }
+      // for (int i=0; i < tsCount; i++) {
+      // System.out.println("DEBUG: mergedTs[" + i + "]=" + ourTimeStamps[i]);
+      // if (i > 0 && ourTimeStamps[i] <= ourTimeStamps[i-1]) {
+      // System.out.println("DEBUG: ERROR ts was not greater than previous");
+      // }
+      // }
-//       boolean changed;
-//       do {
-//         changed = false;
-//         for (int i=0; i < values.length; i++) {
-//           valueTimeStamps = values[i].getRawAbsoluteTimeStamps();
-//           if (valueTimeStamps.length == 0) {
-//             continue;
-//           }
-//           int ourIdx = 0;
-//           for (int j=0; j < valueTimeStamps.length; j++) {
-//             while ((ourIdx < (tsCount-1))
-//                    && !isClosest(valueTimeStamps[j], ourTimeStamps, ourIdx)) {
-//               ourIdx++;
-//             }
-//             if (ourIdx == (tsCount-1)) {
-//               // we are at the end so we need to append all our remaining stamps [j..valueTimeStamps.length-1]
-//               // and then reappend the Long.MAX_VALUE that
-//               // is currently at tsCount-1
-//               int numToCopy = valueTimeStamps.length - j;
-//               if (tsCount+numToCopy > ourTimeStamps.length) {
-//                 // grow our timestamp array
-//                 long[] tmp = new long[tsCount+numToCopy+1];
-//                 System.arraycopy(ourTimeStamps, 0, tmp, 0, tsCount);
-//                 ourTimeStamps = tmp;
-//               }
-//               System.arraycopy(valueTimeStamps, j,
-//                                ourTimeStamps, ourIdx,
-//                                numToCopy);
-//               tsCount += numToCopy;
-//               ourTimeStamps[tsCount-1] = Long.MAX_VALUE;
-//               //changed = true;
-//               System.out.println("DEBUG: had to add " + numToCopy
-//                                  + " timestamps for inst#" + i + " starting at index " + j + " starting with ts=" + valueTimeStamps[j]);
-//               break; // our of the for j loop since we just finished off this guy
-//             } else {
-//               ourIdx++;
-//             }
-//           }
-//         }
-//       } while (changed);
+      // boolean changed;
+      // do {
+      // changed = false;
+      // for (int i=0; i < values.length; i++) {
+      // valueTimeStamps = values[i].getRawAbsoluteTimeStamps();
+      // if (valueTimeStamps.length == 0) {
+      // continue;
+      // }
+      // int ourIdx = 0;
+      // for (int j=0; j < valueTimeStamps.length; j++) {
+      // while ((ourIdx < (tsCount-1))
+      // && !isClosest(valueTimeStamps[j], ourTimeStamps, ourIdx)) {
+      // ourIdx++;
+      // }
+      // if (ourIdx == (tsCount-1)) {
+      // // we are at the end so we need to append all our remaining stamps
+      // [j..valueTimeStamps.length-1]
+      // // and then reappend the Long.MAX_VALUE that
+      // // is currently at tsCount-1
+      // int numToCopy = valueTimeStamps.length - j;
+      // if (tsCount+numToCopy > ourTimeStamps.length) {
+      // // grow our timestamp array
+      // long[] tmp = new long[tsCount+numToCopy+1];
+      // System.arraycopy(ourTimeStamps, 0, tmp, 0, tsCount);
+      // ourTimeStamps = tmp;
+      // }
+      // System.arraycopy(valueTimeStamps, j,
+      // ourTimeStamps, ourIdx,
+      // numToCopy);
+      // tsCount += numToCopy;
+      // ourTimeStamps[tsCount-1] = Long.MAX_VALUE;
+      // //changed = true;
+      // System.out.println("DEBUG: had to add " + numToCopy
+      // + " timestamps for inst#" + i + " starting at index " + j + " starting with ts=" +
+      // valueTimeStamps[j]);
+      // break; // our of the for j loop since we just finished off this guy
+      // } else {
+      // ourIdx++;
+      // }
+      // }
+      // }
+      // } while (changed);
-        int endIdx = tsCount-1;
+        int endIdx = tsCount - 1;
-//           for (int i=0; i < tsCount; i++) {
-//             if (ourTimeStamps[i] >= startTime) {
-//               break;
-//             }
-//             startIdx++;
-//           }
+          // for (int i=0; i < tsCount; i++) {
+          // if (ourTimeStamps[i] >= startTime) {
+          // break;
+          // }
+          // startIdx++;
+          // }
-//           endIdx = startIdx-1;
-//           for (int i=startIdx; i < tsCount; i++) {
-//             if (ourTimeStamps[i] >= endTime) {
-//               break;
-//             }
-//             endIdx++;
-//           }
-          Assert.assertTrue(endIdx == startIdx-1 || ourTimeStamps[endIdx] < endTime);
+          // endIdx = startIdx-1;
+          // for (int i=startIdx; i < tsCount; i++) {
+          // if (ourTimeStamps[i] >= endTime) {
+          // break;
+          // }
+          // endIdx++;
+          // }
+          Assert.assertTrue(endIdx == startIdx - 1 || ourTimeStamps[endIdx] < endTime);
-        tsCount = (endIdx-startIdx) + 1;
-        
+        tsCount = (endIdx - startIdx) + 1;
+
+
+
-     * Returns true if the timeStamp at curIdx is the one that ts is
-     * the closest to.
-     * We know that timeStamps[curIdx-1], if it exists, was not the closest.
+     * Returns true if the timeStamp at curIdx is the one that ts is the closest to. We know that
+     * timeStamps[curIdx-1], if it exists, was not the closest.
-      return closer(ts, timeStamps[curIdx], timeStamps[curIdx+1]);
+      return closer(ts, timeStamps[curIdx], timeStamps[curIdx + 1]);
-      for (int i=0; i < this.values.length; i++) {
+      for (int i = 0; i < this.values.length; i++) {
-//       System.out.println("DEBUG: producing " + result.length + " values");
+      // System.out.println("DEBUG: producing " + result.length + " values");
-        for (int i=0; i < values.length; i++) {
+        for (int i = 0; i < values.length; i++) {
-//           System.out.println("DEBUG: inst#" + i + " has " + valueSnapshots.length + " values");
-          for (int j=0; j < valueSnapshots.length; j++) {
-//             System.out.println("DEBUG: Doing v with"
-//                                + " vTs[" + j + "]=" + valueTimeStamps[j]
-//                                + " at mergeTs[" + curIdx + "]=" + ourTimeStamps[curIdx]);
+          // System.out.println("DEBUG: inst#" + i + " has " + valueSnapshots.length + " values");
+          for (int j = 0; j < valueSnapshots.length; j++) {
+            // System.out.println("DEBUG: Doing v with"
+            // + " vTs[" + j + "]=" + valueTimeStamps[j]
+            // + " at mergeTs[" + curIdx + "]=" + ourTimeStamps[curIdx]);
-//               System.out.println("DEBUG: skipping curIdx=" + curIdx
-//                                  + " valueTimeStamps[" + j + "]=" + valueTimeStamps[j]
-//                                  + " ourTimeStamps[" + curIdx + "]=" + ourTimeStamps[curIdx]
-//                                  + " ourTimeStamps[" + (curIdx+1) + "]=" + ourTimeStamps[curIdx+1]);
-                                 
+              // System.out.println("DEBUG: skipping curIdx=" + curIdx
+              // + " valueTimeStamps[" + j + "]=" + valueTimeStamps[j]
+              // + " ourTimeStamps[" + curIdx + "]=" + ourTimeStamps[curIdx]
+              // + " ourTimeStamps[" + (curIdx+1) + "]=" + ourTimeStamps[curIdx+1]);
+
-            for (int j=curIdx; j < result.length; j++) {
+            for (int j = curIdx; j < result.length; j++) {
+
-        for (int i=0; i < result.length; i++) {
-          double valueDelta = snapshots[i+1] - snapshots[i];
+        for (int i = 0; i < result.length; i++) {
+          double valueDelta = snapshots[i + 1] - snapshots[i];
-            long timeDelta = timestamps[i+1] - timestamps[i];
+            long timeDelta = timestamps[i + 1] - timestamps[i];
-//             if (result[i] > valueDelta) {
-//               System.out.println("DEBUG:  timeDelta     was " + timeDelta + " ms.");
-//               System.out.println("DEBUG: valueDelta     was " + valueDelta);
-//               System.out.println("DEBUG: valueDelta/sec was " + result[i]);
-//             }
+            // if (result[i] > valueDelta) {
+            // System.out.println("DEBUG: timeDelta was " + timeDelta + " ms.");
+            // System.out.println("DEBUG: valueDelta was " + valueDelta);
+            // System.out.println("DEBUG: valueDelta/sec was " + result[i]);
+            // }
-  
+
-    
+
-    
+
-        for (int i=resource.getFirstTimeStampIdx();
-             i < resource.getFirstTimeStampIdx() + series.getSize();
-             i++) {
+        for (int i = resource.getFirstTimeStampIdx(); i < resource.getFirstTimeStampIdx()
+            + series.getSize(); i++) {
+
-      int endIdx = series.getSize()-1;
+      int endIdx = series.getSize() - 1;
-        endIdx = startIdx-1;
-        for (int i=resource.getFirstTimeStampIdx()+startIdx;
-             i < resource.getFirstTimeStampIdx() + series.getSize();
-             i++) {
+        endIdx = startIdx - 1;
+        for (int i = resource.getFirstTimeStampIdx() + startIdx; i < resource.getFirstTimeStampIdx()
+            + series.getSize(); i++) {
-        Assert.assertTrue(endIdx == startIdx-1 || timestamps[endIdx] < endTimeStamp);
+        Assert.assertTrue(endIdx == startIdx - 1 || timestamps[endIdx] < endTimeStamp);
+
-      int resultSize=(endIdx-startIdx) + 1;
-      
+      int resultSize = (endIdx - startIdx) + 1;
+
-        result = new double[resultSize-1];
-        int tsIdx = resource.getFirstTimeStampIdx()+startIdx;
+        result = new double[resultSize - 1];
+        int tsIdx = resource.getFirstTimeStampIdx() + startIdx;
-        for (int i=0; i < result.length; i++) {
-          double valueDelta = values[i+1] - values[i];
+        for (int i = 0; i < result.length; i++) {
+          double valueDelta = values[i + 1] - values[i];
-            double timeDelta = (timestamps[tsIdx+i+1] - timestamps[tsIdx+i]); // millis
+            double timeDelta = (timestamps[tsIdx + i + 1] - timestamps[tsIdx + i]); // millis
-    
+
-      int resultSize=(endIdx-startIdx) + 1;
+      int resultSize = (endIdx - startIdx) + 1;
-      for (int i=0; i < result.length; i++) {
+      for (int i = 0; i < result.length; i++) {
-      int resultSize=(endIdx-startIdx) + 1;
+      int resultSize = (endIdx - startIdx) + 1;
-        int tsIdx = resource.getFirstTimeStampIdx()+startIdx;
+        int tsIdx = resource.getFirstTimeStampIdx() + startIdx;
-        for (int i=0; i < resultSize; i++) {
-          result[i] = base + timestamps[tsIdx+i];
+        for (int i = 0; i < resultSize; i++) {
+          result[i] = base + timestamps[tsIdx + i];
+
-      stream.print("[size=" + getSnapshotsSize()
-                   + " min=" + nf.format(min)
-                   + " max=" + nf.format(max)
-                   + " avg=" + nf.format(avg)
-                   + " stddev=" + nf.format(stddev) + "]");
+      stream.print("[size=" + getSnapshotsSize() + " min=" + nf.format(min) + " max="
+          + nf.format(max) + " avg=" + nf.format(avg) + " stddev=" + nf.format(stddev) + "]");
-    
+
+
+
+
+
+
-    
+
-          return new BitZeroIntInterval((int)bits, count);
+          return new BitZeroIntInterval((int) bits, count);
-            return new BitNonZeroIntIntInterval((int)bits, (int)interval, count);
+            return new BitNonZeroIntIntInterval((int) bits, (int) interval, count);
-            return new BitNonZeroIntLongInterval((int)bits, interval, count);
+            return new BitNonZeroIntLongInterval((int) bits, interval, count);
-            return new BitNonZeroLongIntInterval(bits, (int)interval, count);
+            return new BitNonZeroLongIntInterval(bits, (int) interval, count);
+
+
-    
+
-      for (int i=0; i < fillcount; i++) {
-        values[valueOffset+i] = bitsToDouble(typeCode, base);
+      for (int i = 0; i < fillcount; i++) {
+        values[valueOffset + i] = bitsToDouble(typeCode, base);
+
+
-        if (addBits == (getBits() + (addInterval * (count-1)))) {
+        if (addBits == (getBits() + (addInterval * (count - 1)))) {
-  
+
+
+
-  
+
+
+
-  
+
+
+
-  
+
+
+
+
-    
+
-      for (int i=0; i < fillcount; i++) {
-        values[valueOffset+i] = value;
+      for (int i = 0; i < fillcount; i++) {
+        values[valueOffset + i] = value;
+
+
-  
+
+
+
-  
+
+
+
+
-      for (int i=0; i < skipCount; i++) {
+      for (int i = 0; i < skipCount; i++) {
-      for (int i=0; i < fillcount; i++) {
-        bitValue += bitIntervals[skipCount+i];
-        values[valueOffset+i] = bitsToDouble(typeCode, bitValue);
+      for (int i = 0; i < fillcount; i++) {
+        bitValue += bitIntervals[skipCount + i];
+        values[valueOffset + i] = bitsToDouble(typeCode, bitValue);
-      for (int i=0; i < count; i++) {
+      for (int i = 0; i < count; i++) {
+
-      lastValue = bits + (interval * (addCount-1));
-      bitIntervals = new byte[count*2];
+      lastValue = bits + (interval * (addCount - 1));
+      bitIntervals = new byte[count * 2];
-      for (int i=1; i < count; i++) {
-        bitIntervals[i] = (byte)interval;
+      for (int i = 1; i < count; i++) {
+        bitIntervals[i] = (byte) interval;
+
-            lastValue = addBits + (addInterval * (addCount-1));
+            lastValue = addBits + (addInterval * (addCount - 1));
-              byte[] tmp = new byte[(count+addCount)*2];
+              byte[] tmp = new byte[(count + addCount) * 2];
-            bitIntervals[count++] = (byte)firstInterval;
-            for (int i=1; i < addCount; i++) {
-              bitIntervals[count++] = (byte)addInterval;
+            bitIntervals[count++] = (byte) firstInterval;
+            for (int i = 1; i < addCount; i++) {
+              bitIntervals[count++] = (byte) addInterval;
-  
+
-      for (int i=0; i < skipCount; i++) {
+      for (int i = 0; i < skipCount; i++) {
-      for (int i=0; i < fillcount; i++) {
-        bitValue += bitIntervals[skipCount+i];
-        values[valueOffset+i] = bitsToDouble(typeCode, bitValue);
+      for (int i = 0; i < fillcount; i++) {
+        bitValue += bitIntervals[skipCount + i];
+        values[valueOffset + i] = bitsToDouble(typeCode, bitValue);
-      for (int i=0; i < count; i++) {
+      for (int i = 0; i < count; i++) {
+
-      lastValue = bits + (interval * (addCount-1));
-      bitIntervals = new short[count*2];
+      lastValue = bits + (interval * (addCount - 1));
+      bitIntervals = new short[count * 2];
-      for (int i=1; i < count; i++) {
-        bitIntervals[i] = (short)interval;
+      for (int i = 1; i < count; i++) {
+        bitIntervals[i] = (short) interval;
+
-            lastValue = addBits + (addInterval * (addCount-1));
+            lastValue = addBits + (addInterval * (addCount - 1));
-              short[] tmp = new short[(count+addCount)*2];
+              short[] tmp = new short[(count + addCount) * 2];
-            bitIntervals[count++] = (short)firstInterval;
-            for (int i=1; i < addCount; i++) {
-              bitIntervals[count++] = (short)addInterval;
+            bitIntervals[count++] = (short) firstInterval;
+            for (int i = 1; i < addCount; i++) {
+              bitIntervals[count++] = (short) addInterval;
-  
+
-      for (int i=0; i < skipCount; i++) {
+      for (int i = 0; i < skipCount; i++) {
-      for (int i=0; i < fillcount; i++) {
-        bitValue += bitIntervals[skipCount+i];
-        values[valueOffset+i] = bitsToDouble(typeCode, bitValue);
+      for (int i = 0; i < fillcount; i++) {
+        bitValue += bitIntervals[skipCount + i];
+        values[valueOffset + i] = bitsToDouble(typeCode, bitValue);
-      for (int i=0; i < count; i++) {
+      for (int i = 0; i < count; i++) {
+
-      lastValue = bits + (interval * (addCount-1));
-      bitIntervals = new int[count*2];
+      lastValue = bits + (interval * (addCount - 1));
+      bitIntervals = new int[count * 2];
-      for (int i=1; i < count; i++) {
-        bitIntervals[i] = (int)interval;
+      for (int i = 1; i < count; i++) {
+        bitIntervals[i] = (int) interval;
+
-            lastValue = addBits + (addInterval * (addCount-1));
+            lastValue = addBits + (addInterval * (addCount - 1));
-              int[] tmp = new int[(count+addCount)*2];
+              int[] tmp = new int[(count + addCount) * 2];
-            bitIntervals[count++] = (int)firstInterval;
-            for (int i=1; i < addCount; i++) {
-              bitIntervals[count++] = (int)addInterval;
+            bitIntervals[count++] = (int) firstInterval;
+            for (int i = 1; i < addCount; i++) {
+              bitIntervals[count++] = (int) addInterval;
-  
+
-      for (int i=0; i < fillcount; i++) {
-        values[valueOffset+i] = bitsToDouble(typeCode, bitArray[skipCount+i]);
+      for (int i = 0; i < fillcount; i++) {
+        values[valueOffset + i] = bitsToDouble(typeCode, bitArray[skipCount + i]);
-      for (int i=0; i < count; i++) {
+      for (int i = 0; i < count; i++) {
+
-      bitArray = new long[count*2];
-      for (int i=0; i < count; i++) {
+      bitArray = new long[count * 2];
+      for (int i = 0; i < count; i++) {
+
-          long[] tmp = new long[(count+addCount)*2];
+          long[] tmp = new long[(count + addCount) * 2];
-        for (int i=0; i < addCount; i++) {
+        for (int i = 0; i < addCount; i++) {
-                                  
+
-        for (int i=0; i <= intervalIdx; i++) {
+        for (int i = 0; i <= intervalIdx; i++) {
-    
+
+
-     * Gets the first "resultSize" values of this series
-     * skipping over the first "samplesToSkip" ones.
-     * The first value in a series is at index 0.
-     * The maximum result size can be obtained by calling "getSize()".
+     * Gets the first "resultSize" values of this series skipping over the first "samplesToSkip"
+     * ones. The first value in a series is at index 0. The maximum result size can be obtained by
+     * calling "getSize()".
-      while (samplesToSkip > 0
-             && firstInterval <= intervalIdx
-             && intervals[firstInterval].getSampleCount() <= samplesToSkip) {
+      while (samplesToSkip > 0 && firstInterval <= intervalIdx
+          && intervals[firstInterval].getSampleCount() <= samplesToSkip) {
-      for (int i=firstInterval; i <= intervalIdx; i++) {
+      for (int i = firstInterval; i <= intervalIdx; i++) {
-        idx += BitInterval.create(currentStartBits, currentInterval, currentCount).fill(result, idx, typeCode, samplesToSkip);
+        idx += BitInterval.create(currentStartBits, currentInterval, currentCount).fill(result, idx,
+            typeCode, samplesToSkip);
-        throw new InternalGemFireException(LocalizedStrings.StatArchiveReader_GETVALUESEX_DIDNT_FILL_THE_LAST_0_ENTRIES_OF_ITS_RESULT.toLocalizedString(Integer.valueOf(resultSize-idx)));
+        throw new InternalGemFireException(
+            LocalizedStrings.StatArchiveReader_GETVALUESEX_DIDNT_FILL_THE_LAST_0_ENTRIES_OF_ITS_RESULT
+                .toLocalizedString(Integer.valueOf(resultSize - idx)));
-    
+
-      stream.print("[size=" + count + " intervals=" + (intervalIdx+1)
-                   + " memused=" + getMemoryUsed() + " ");
-      for (int i=0; i <= intervalIdx; i++) {
+      stream.print("[size=" + count + " intervals=" + (intervalIdx + 1) + " memused="
+          + getMemoryUsed() + " ");
+      for (int i = 0; i <= intervalIdx; i++) {
-    
+
-    
+
-    
+
-            intervals[intervalIdx] = BitInterval.create(currentStartBits, currentInterval, currentCount);
+            intervals[intervalIdx] =
+                BitInterval.create(currentStartBits, currentInterval, currentCount);
+
-        int currentSize = intervalIdx+1;
+        int currentSize = intervalIdx + 1;
-  
+
-      for (int i=0; i < count; i++) {
+      for (int i = 0; i < count; i++) {
-          stream.print(timeStamps[i]-timeStamps[i-1]);
+          stream.print(timeStamps[i] - timeStamps[i - 1]);
-    
+
-    
+
-    
+
-        timeStamps[count] = timeStamps[count-1] + ts;
+        timeStamps[count] = timeStamps[count - 1] + ts;
-    
+
-    /** Provides direct access to underlying data.
-     * Do not modify contents and use getSize() to keep from reading
-     * past end of array.
+
+    /**
+     * Provides direct access to underlying data. Do not modify contents and use getSize() to keep
+     * from reading past end of array.
+
+
-     * Returns an array of time stamp values the first of which
-     * has the specified index.
-     * Each returned time stamp is the number of millis since
-     * midnight, Jan 1, 1970 UTC.
+     * Returns an array of time stamp values the first of which has the specified index. Each
+     * returned time stamp is the number of millis since midnight, Jan 1, 1970 UTC.
-      for (int i=0; i < resultSize; i++) {
-        result[i] = getMilliTimeStamp(idx+i);
+      for (int i = 0; i < resultSize; i++) {
+        result[i] = getMilliTimeStamp(idx + i);
-   * Defines a statistic resource type. Each resource instance must be
-   * of a single type. The type defines what statistics each instance
-   * of it will support. The type also has a description of itself.
+   * Defines a statistic resource type. Each resource instance must be of a single type. The type
+   * defines what statistics each instance of it will support. The type also has a description of
+   * itself.
-//    private final int id;
+    // private final int id;
-        for (int i=0; i < stats.length; i++) {
+        for (int i = 0; i < stats.length; i++) {
-    
+
-//      this.id = id;
+      // this.id = id;
-//      this.id = id;
+      // this.id = id;
+
+
-     * Frees up any resources no longer needed after the archive file is closed.
-     * Returns true if this guy is no longer needed.
+     * Frees up any resources no longer needed after the archive file is closed. Returns true if
+     * this guy is no longer needed.
-        for (int i=0; i < stats.length; i++) {
+        for (int i = 0; i < stats.length; i++) {
-    
+
-      for (int i=0; i < this.stats.length; i++) {
+      for (int i = 0; i < this.stats.length; i++) {
-    protected void addStatDescriptor(StatArchiveFile archive, int offset, String name, boolean isCounter,
-                                   boolean largerBetter,
-                                   byte typeCode, String units, String desc) {
-      StatDescriptor descriptor = new StatDescriptor(name, offset, isCounter, largerBetter, typeCode, units, desc);
+    protected void addStatDescriptor(StatArchiveFile archive, int offset, String name,
+        boolean isCounter, boolean largerBetter, byte typeCode, String units, String desc) {
+      StatDescriptor descriptor =
+          new StatDescriptor(name, offset, isCounter, largerBetter, typeCode, units, desc);
-//    private int getId() {
-//      return this.id;
-//    }
+    // private int getId() {
+    // return this.id;
+    // }
+
-     * Returns an array of descriptors for each statistic this resource
-     * type supports.
+     * Returns an array of descriptors for each statistic this resource type supports.
+
+     * 
-     * @return the descriptor that matches the name or null if the type
-     * does not have a stat of the given name
+     * @return the descriptor that matches the name or null if the type does not have a stat of the
+     *         given name
-      return (StatDescriptor)descriptorMap.get(name);
+      return (StatDescriptor) descriptorMap.get(name);
+
-    public ArchiveInfo(StatArchiveFile archive, byte archiveVersion,
-                       long startTimeStamp, long systemStartTimeStamp,
-                       int timeZoneOffset,String timeZoneName,
-                       String systemDirectory, long systemId,
-                       String productVersion, String os, String machine) {
+    public ArchiveInfo(StatArchiveFile archive, byte archiveVersion, long startTimeStamp,
+        long systemStartTimeStamp, int timeZoneOffset, String timeZoneName, String systemDirectory,
+        long systemId, String productVersion, String os, String machine) {
-     * Returns the difference, measured in milliseconds, between the time
-     * the archive file was create and midnight, January 1, 1970 UTC.
+     * Returns the difference, measured in milliseconds, between the time the archive file was
+     * create and midnight, January 1, 1970 UTC.
+
-     * Returns the difference, measured in milliseconds, between the time
-     * the archived system was started and midnight, January 1, 1970 UTC.
+     * Returns the difference, measured in milliseconds, between the time the archived system was
+     * started and midnight, January 1, 1970 UTC.
+
-     * Returns a numeric id of the archived system.  It can be used in
-     * conjunction with the {@link #getSystemStartTimeMillis} to
-     * uniquely identify an archived system.
+     * Returns a numeric id of the archived system. It can be used in conjunction with the
+     * {@link #getSystemStartTimeMillis} to uniquely identify an archived system.
+
-     * Returns a string describing the operating system the archive was
-     * written on.
+     * Returns a string describing the operating system the archive was written on.
+
-     * Returns a string describing the machine the archive was
-     * written on.
+     * Returns a string describing the machine the archive was written on.
+
-     * Returns  the time zone used when the archive was created.
-     * This can be used to print timestamps in the same time zone
-     * that was in effect when the archive was created.
+     * Returns the time zone used when the archive was created. This can be used to print timestamps
+     * in the same time zone that was in effect when the archive was created.
+
-     * Returns a string containing the version of the product that wrote
-     * this archive.
+     * Returns a string containing the version of the product that wrote this archive.
+
-     * Returns a numeric code that represents the format version used to
-     * encode the archive as a stream of bytes.
+     * Returns a numeric code that represents the format version used to encode the archive as a
+     * stream of bytes.
+
+
-     * Return the name of the file this archive was stored in or
-     * an empty string if the archive was not stored in a file.
+     * Return the name of the file this archive was stored in or an empty string if the archive was
+     * not stored in a file.
-    
+
-      // stream.println("startTimeStamp=" + startTimeStamp +" tz=" + timeZoneName + " tzOffset=" + timeZoneOffset);
+      // stream.println("startTimeStamp=" + startTimeStamp +" tz=" + timeZoneName + " tzOffset=" +
+      // timeZoneOffset);
-//    private final int uniqueId;
+    // private final int uniqueId;
-        for (int i=0; i < values.length; i++) {
+        for (int i = 0; i < values.length; i++) {
+
-      result.append(name)
-        .append(", ")
-        .append(id)
-        .append(", ")
-        .append(type.getName())
-        .append(": \"")
-        .append(archive.formatTimeMillis(getFirstTimeMillis()))
-        .append('\"');
+      result.append(name).append(", ").append(id).append(", ").append(type.getName()).append(": \"")
+          .append(archive.formatTimeMillis(getFirstTimeMillis())).append('\"');
-      result.append(" samples="+ getSampleCount());
+      result.append(" samples=" + getSampleCount());
+
-        return (lastTSidx+1) - firstTSidx;
+        return (lastTSidx + 1) - firstTSidx;
-    
+
-      stream.println(name + ":"
-                     + " file=" + getArchive().getFile()
-                     + " id=" + id
-                     + (active? "" : " deleted")
-                     + " start=" + archive.formatTimeMillis(getFirstTimeMillis()));
-      for (int i=0; i < values.length; i++) {
+      stream.println(
+          name + ":" + " file=" + getArchive().getFile() + " id=" + id + (active ? "" : " deleted")
+              + " start=" + archive.formatTimeMillis(getFirstTimeMillis()));
+      for (int i = 0; i < values.length; i++) {
-    protected ResourceInst(StatArchiveFile archive, int uniqueId, String name, long id, ResourceType type, boolean loaded) {
+    protected ResourceInst(StatArchiveFile archive, int uniqueId, String name, long id,
+        ResourceType type, boolean loaded) {
-//      this.uniqueId = uniqueId;
+      // this.uniqueId = uniqueId;
-        for (int i=0; i < stats.length; i++) {
+        for (int i = 0; i < stats.length; i++) {
-          for (int statIdx=0; statIdx < values.length; statIdx++) {
+          for (int statIdx = 0; statIdx < values.length; statIdx++) {
+
-    
+
-     * Frees up any resources no longer needed after the archive file is closed.
-     * Returns true if this guy is no longer needed.
+     * Frees up any resources no longer needed after the archive file is closed. Returns true if
+     * this guy is no longer needed.
-        for (int i=0; i < values.length; i++) {
+        for (int i = 0; i < values.length; i++) {
+
+
+
-     * Returns an array of doubles containing the timestamps at which
-     * this instances samples where taken. Each of these timestamps
-     * is the difference, measured in milliseconds, between the sample
-     * time and midnight, January 1, 1970 UTC.
-     * Although these values are double they can safely be converted
-     * to <code>long</code> with no loss of information.
+     * Returns an array of doubles containing the timestamps at which this instances samples where
+     * taken. Each of these timestamps is the difference, measured in milliseconds, between the
+     * sample time and midnight, January 1, 1970 UTC. Although these values are double they can
+     * safely be converted to <code>long</code> with no loss of information.
+
-     * Returns an array of statistic value descriptors. Each element
-     * of the array describes the corresponding statistic this instance
-     * supports. The <code>StatValue</code> instances can be used to
-     * obtain the actual sampled values of the instances statistics.
+     * Returns an array of statistic value descriptors. Each element of the array describes the
+     * corresponding statistic this instance supports. The <code>StatValue</code> instances can be
+     * used to obtain the actual sampled values of the instances statistics.
+
+     * 
-     * @return the value that matches the name or null if the instance
-     * does not have a stat of the given name
+     * @return the value that matches the name or null if the instance does not have a stat of the
+     *         given name
+
+
-     * Returns the difference, measured in milliseconds, between the time
-     * of the instance's first sample and midnight, January 1, 1970 UTC.
+     * Returns the difference, measured in milliseconds, between the time of the instance's first
+     * sample and midnight, January 1, 1970 UTC.
+
+
+
+
-        for (int i=0; i < values.length; i++) {
+        for (int i = 0; i < values.length; i++) {
-     * Causes all stats that matches this spec, in all archive files,
-     * to be combined into a single global stat value.
+     * Causes all stats that matches this spec, in all archive files, to be combined into a single
+     * global stat value.
-     * Causes all stats that matches this spec, in each archive file,
-     * to be combined into a single stat value for each file.
+     * Causes all stats that matches this spec, in each archive file, to be combined into a single
+     * stat value for each file.
+
-     * Returns one of the following values:
-     * {@link #GLOBAL}, {@link #FILE}, {@link #NONE}.
+     * Returns one of the following values: {@link #GLOBAL}, {@link #FILE}, {@link #NONE}.
-  
+
-   * Specifies what data from a statistic archive will be of interest
-   * to the reader. This is used when loading a statistic archive file
-   * to reduce the memory footprint. Only statistic data that matches
-   * all four will be selected for loading.
+   * Specifies what data from a statistic archive will be of interest to the reader. This is used
+   * when loading a statistic archive file to reduce the memory footprint. Only statistic data that
+   * matches all four will be selected for loading.
-     * Returns true if the specified archive file matches this spec.
-     * Any archives whose name does not match this spec will
-     * not be selected for loading by this spec.
+     * Returns true if the specified archive file matches this spec. Any archives whose name does
+     * not match this spec will not be selected for loading by this spec.
+
-     * Returns true if the specified type name matches this spec.
-     * Any types whose name does not match this spec will
-     * not be selected for loading by this spec.
+     * Returns true if the specified type name matches this spec. Any types whose name does not
+     * match this spec will not be selected for loading by this spec.
-     * Returns true if the specified statistic name matches this spec.
-     * Any stats whose name does not match this spec will
-     * not be selected for loading by this spec.
+     * Returns true if the specified statistic name matches this spec. Any stats whose name does not
+     * match this spec will not be selected for loading by this spec.
-     * Returns true if the specified instance matches this spec.
-     * Any instance whose text id and numeric id do not match this spec will
-     * not be selected for loading by this spec.
+     * Returns true if the specified instance matches this spec. Any instance whose text id and
+     * numeric id do not match this spec will not be selected for loading by this spec.
-  
+
-    private final DateFormat timeFormatter =
-      new SimpleDateFormat(DateFormatter.FORMAT_STRING);
-    private final static int BUFFER_SIZE = 1024*1024;
+    private final DateFormat timeFormatter = new SimpleDateFormat(DateFormatter.FORMAT_STRING);
+    private final static int BUFFER_SIZE = 1024 * 1024;
-    public StatArchiveFile(StatArchiveReader reader,
-                           File archiveName,
-                           boolean dump,
-                           ValueFilter[] filters)
-      throws IOException
-    {
+    public StatArchiveFile(StatArchiveReader reader, File archiveName, boolean dump,
+        ValueFilter[] filters) throws IOException {
-        this.dataIn = new DataInputStream(new BufferedInputStream(new GZIPInputStream(this.is, BUFFER_SIZE), BUFFER_SIZE));
+        this.dataIn = new DataInputStream(
+            new BufferedInputStream(new GZIPInputStream(this.is, BUFFER_SIZE), BUFFER_SIZE));
-      for (int i=0; i < allFilters.length; i++) {
+      for (int i = 0; i < allFilters.length; i++) {
-        return (ValueFilter[])l.toArray(result);
+        return (ValueFilter[]) l.toArray(result);
-    
+
-          ComboValue v = (ComboValue)it.next();
+          ComboValue v = (ComboValue) it.next();
-          for (int i=0; i < resources.length; i++) {
+          for (int i = 0; i < resources.length; i++) {
-        for (int instIdx=0; instIdx < resourceInstSize; instIdx++) {
+        for (int instIdx = 0; instIdx < resourceInstSize; instIdx++) {
-    
+
-     * Formats an archive timestamp in way consistent with GemFire log
-     * dates. It will also be formatted to reflect the time zone the
-     * archive was created in.
-     * @param ts The difference, measured in milliseconds, between the time
-     * marked by this time stamp and midnight, January 1, 1970 UTC.
+     * Formats an archive timestamp in way consistent with GemFire log dates. It will also be
+     * formatted to reflect the time zone the archive was created in.
+     * 
+     * @param ts The difference, measured in milliseconds, between the time marked by this time
+     *        stamp and midnight, January 1, 1970 UTC.
+
+
+
-     * Checks to see if the archive has changed since the StatArchiverReader
-     * instance was created or last updated. If the archive has additional
-     * samples then those are read the resource instances maintained by the
-     * reader are updated.
-     * <p>Once closed a reader can no longer be updated.
+     * Checks to see if the archive has changed since the StatArchiverReader instance was created or
+     * last updated. If the archive has additional samples then those are read the resource
+     * instances maintained by the reader are updated.
+     * <p>
+     * Once closed a reader can no longer be updated.
+     * 
-     * @throws IOException if <code>archiveName</code> could not be opened
-     * read, or closed.
+     * @throws IOException if <code>archiveName</code> could not be opened read, or closed.
-        throw new InternalGemFireException(LocalizedStrings.StatArchiveReader_UPDATE_OF_THIS_TYPE_OF_FILE_IS_NOT_SUPPORTED.toLocalizedString());
+        throw new InternalGemFireException(
+            LocalizedStrings.StatArchiveReader_UPDATE_OF_THIS_TYPE_OF_FILE_IS_NOT_SUPPORTED
+                .toLocalizedString());
-      for (int i=0; i < resourceTypeTable.length; i++) {
+      for (int i = 0; i < resourceTypeTable.length; i++) {
-      for (int i=0; i < resourceInstTable.length; i++) {
+      for (int i = 0; i < resourceInstTable.length; i++) {
-    
+
-    
+
-          for (int i=0; i < this.resourceTypeTable.length; i++) {
+          for (int i = 0; i < this.resourceTypeTable.length; i++) {
-          for (int i=0; i < this.resourceTypeTable.length; i++) {
+          for (int i = 0; i < this.resourceTypeTable.length; i++) {
-          for (int i=0; i < this.resourceInstTable.length; i++) {
+          for (int i = 0; i < this.resourceInstTable.length; i++) {
-          for (int i=0; i < this.resourceInstTable.length; i++) {
+          for (int i = 0; i < this.resourceInstTable.length; i++) {
-     * Returns global information about the read archive.
-     * Returns null if no information is available.
+     * Returns global information about the read archive. Returns null if no information is
+     * available.
-        throw new GemFireIOException(LocalizedStrings.StatArchiveReader_ARCHIVE_VERSION_0_IS_NO_LONGER_SUPPORTED.toLocalizedString(Byte.valueOf(archiveVersion)), null);
+        throw new GemFireIOException(
+            LocalizedStrings.StatArchiveReader_ARCHIVE_VERSION_0_IS_NO_LONGER_SUPPORTED
+                .toLocalizedString(Byte.valueOf(archiveVersion)),
+            null);
-        throw new GemFireIOException(LocalizedStrings.StatArchiveReader_UNSUPPORTED_ARCHIVE_VERSION_0_THE_SUPPORTED_VERSION_IS_1.toLocalizedString(new Object[] {Byte.valueOf(archiveVersion), Byte.valueOf(ARCHIVE_VERSION)}), null);
+        throw new GemFireIOException(
+            LocalizedStrings.StatArchiveReader_UNSUPPORTED_ARCHIVE_VERSION_0_THE_SUPPORTED_VERSION_IS_1
+                .toLocalizedString(
+                    new Object[] {Byte.valueOf(archiveVersion), Byte.valueOf(ARCHIVE_VERSION)}),
+            null);
-      this.info = new ArchiveInfo(this, archiveVersion,
-                                  startTimeStamp, systemStartTimeStamp,
-                                  timeZoneOffset, timeZoneName,
-                                  systemDirectory, systemId,
-                                  productVersion, os, machine);
+      this.info = new ArchiveInfo(this, archiveVersion, startTimeStamp, systemStartTimeStamp,
+          timeZoneOffset, timeZoneName, systemDirectory, systemId, productVersion, os, machine);
+
-        for (int i=0; i < filters.length; i++) {
+        for (int i = 0; i < filters.length; i++) {
-        //System.out.println("DEBUG: don't load type=" + typeName);
+        // System.out.println("DEBUG: don't load type=" + typeName);
+
-        for (int i=0; i < filters.length; i++) {
-          if (filters[i].statMatches(stat.getName())
-              && filters[i].typeMatches(type.getName())) {
+        for (int i = 0; i < filters.length; i++) {
+          if (filters[i].statMatches(stat.getName()) && filters[i].typeMatches(type.getName())) {
-        //System.out.println("DEBUG: don't load stat=" + stat.getName());
+        // System.out.println("DEBUG: don't load stat=" + stat.getName());
+
-        for (int i=0; i < filters.length; i++) {
+        for (int i = 0; i < filters.length; i++) {
-              for (int j=0; j < stats.length; j++) {
+              for (int j = 0; j < stats.length; j++) {
-        //System.out.println("DEBUG: don't load instance=" + textId);
-        //type.unload();
+        // System.out.println("DEBUG: don't load instance=" + textId);
+        // type.unload();
+
-        for (int i=0; i < filters.length; i++) {
-          if (filters[i].statMatches(stat.getName())
-              && filters[i].typeMatches(type.getName())
+        for (int i = 0; i < filters.length; i++) {
+          if (filters[i].statMatches(stat.getName()) && filters[i].typeMatches(type.getName())
+
-        ResourceType[] tmp = new ResourceType[resourceTypeTable.length+128];
+        ResourceType[] tmp = new ResourceType[resourceTypeTable.length + 128];
-        rt = new ResourceType(resourceTypeId,
-                              resourceTypeName,
-                              resourceTypeDesc,
-                              statCount);
+        rt = new ResourceType(resourceTypeId, resourceTypeName, resourceTypeDesc, statCount);
-          System.out.println("ResourceType id=" + resourceTypeId
-                             + " name=" + resourceTypeName
-                             + " statCount=" + statCount
-                             + " desc=" + resourceTypeDesc);
+          System.out.println("ResourceType id=" + resourceTypeId + " name=" + resourceTypeName
+              + " statCount=" + statCount + " desc=" + resourceTypeDesc);
-          System.out.println("Not loading ResourceType id=" + resourceTypeId
-                             + " name=" + resourceTypeName);
+          System.out.println(
+              "Not loading ResourceType id=" + resourceTypeId + " name=" + resourceTypeName);
-      for (int i=0; i < statCount; i++) {
+      for (int i = 0; i < statCount; i++) {
-          System.out.println("  " + i + "=" + statName + " isCtr=" + isCounter
-                             + " largerBetter=" + largerBetter
-                             + " typeCode=" + typeCode + " units=" + units
-                             + " desc=" + desc);
+          System.out.println("  " + i + "=" + statName + " isCtr=" + isCounter + " largerBetter="
+              + largerBetter + " typeCode=" + typeCode + " units=" + units + " desc=" + desc);
+
-        ResourceInst[] tmp = new ResourceInst[resourceInstTable.length+128];
+        ResourceInst[] tmp = new ResourceInst[resourceInstTable.length + 128];
-      if ((resourceInstId+1) > this.resourceInstSize) {
-        this.resourceInstSize = resourceInstId+1;
+      if ((resourceInstId + 1) > this.resourceInstSize) {
+        this.resourceInstSize = resourceInstId + 1;
+      }
+      ResourceType type = resourceTypeTable[resourceTypeId];
+      if (type == null) {
+        throw new IllegalStateException(
+            "ResourceType is missing for resourceTypeId " + resourceTypeId);
-      resourceInstTable[resourceInstId] = new ResourceInst(this, resourceInstId, name, id, resourceTypeTable[resourceTypeId], loadInstance);
+      resourceInstTable[resourceInstId] = new ResourceInst(this, resourceInstId, name, id,
+          resourceTypeTable[resourceTypeId], loadInstance);
-        System.out.println((loadInstance ? "Loaded": "Did not load") + " resource instance " + resourceInstId);
+        System.out.println(
+            (loadInstance ? "Loaded" : "Did not load") + " resource instance " + resourceInstId);
-        for (int i=0; i < stats.length; i++) {
+        for (int i = 0; i < stats.length; i++) {
-          switch(stats[i].getTypeCode()) {
-          case BOOLEAN_CODE:
-            v = dataIn.readByte();
-            break;
-          case BYTE_CODE:
-          case CHAR_CODE:
-            v = dataIn.readByte();
-            break;
-          case WCHAR_CODE:
-            v = dataIn.readUnsignedShort();
-            break;
-          case SHORT_CODE:
-            v = dataIn.readShort();
-            break;
-          case INT_CODE:
-          case FLOAT_CODE:
-          case LONG_CODE:
-          case DOUBLE_CODE:
-            v = readCompactValue();
-            break;
-          default:
-            throw new IOException(LocalizedStrings.StatArchiveReader_UNEXPECTED_TYPECODE_VALUE_0.toLocalizedString(Byte.valueOf(stats[i].getTypeCode())));
+          switch (stats[i].getTypeCode()) {
+            case BOOLEAN_CODE:
+              v = dataIn.readByte();
+              break;
+            case BYTE_CODE:
+            case CHAR_CODE:
+              v = dataIn.readByte();
+              break;
+            case WCHAR_CODE:
+              v = dataIn.readUnsignedShort();
+              break;
+            case SHORT_CODE:
+              v = dataIn.readShort();
+              break;
+            case INT_CODE:
+            case FLOAT_CODE:
+            case LONG_CODE:
+            case DOUBLE_CODE:
+              v = readCompactValue();
+              break;
+            default:
+              throw new IOException(LocalizedStrings.StatArchiveReader_UNEXPECTED_TYPECODE_VALUE_0
+                  .toLocalizedString(Byte.valueOf(stats[i].getTypeCode())));
+
+
-        if (this.archiveVersion <= 1) {
-        return dataIn.readInt();
-        }
-      */
+       * if (this.archiveVersion <= 1) { return dataIn.readInt(); }
+       */
+
-          switch(stats[statOffset].getTypeCode()) {
-          case BOOLEAN_CODE:
-            statDeltaBits = dataIn.readByte();
-            break;
-          case BYTE_CODE:
-          case CHAR_CODE:
-            statDeltaBits = dataIn.readByte();
-            break;
-          case WCHAR_CODE:
-            statDeltaBits = dataIn.readUnsignedShort();
-            break;
-          case SHORT_CODE:
-            statDeltaBits = dataIn.readShort();
-            break;
-          case INT_CODE:
-          case FLOAT_CODE:
-          case LONG_CODE:
-          case DOUBLE_CODE:
-            statDeltaBits = readCompactValue();
-            break;
-          default:
-            throw new IOException(LocalizedStrings.StatArchiveReader_UNEXPECTED_TYPECODE_VALUE_0.toLocalizedString(Byte.valueOf(stats[statOffset].getTypeCode())));
+          switch (stats[statOffset].getTypeCode()) {
+            case BOOLEAN_CODE:
+              statDeltaBits = dataIn.readByte();
+              break;
+            case BYTE_CODE:
+            case CHAR_CODE:
+              statDeltaBits = dataIn.readByte();
+              break;
+            case WCHAR_CODE:
+              statDeltaBits = dataIn.readUnsignedShort();
+              break;
+            case SHORT_CODE:
+              statDeltaBits = dataIn.readShort();
+              break;
+            case INT_CODE:
+            case FLOAT_CODE:
+            case LONG_CODE:
+            case DOUBLE_CODE:
+              statDeltaBits = readCompactValue();
+              break;
+            default:
+              throw new IOException(LocalizedStrings.StatArchiveReader_UNEXPECTED_TYPECODE_VALUE_0
+                  .toLocalizedString(Byte.valueOf(stats[statOffset].getTypeCode())));
-              System.out.print(  " [" + statOffset + "]=" + statDeltaBits);
+              System.out.print(" [" + statOffset + "]=" + statDeltaBits);
-      for (int i=0; i < resourceInstTable.length; i++) {
+      for (int i = 0; i < resourceInstTable.length; i++) {
+
-        case HEADER_TOKEN:
-          readHeaderToken();
-          break;
-        case RESOURCE_TYPE_TOKEN:
-          readResourceTypeToken();
-          break;
-        case RESOURCE_INSTANCE_CREATE_TOKEN:
-          readResourceInstanceCreateToken(false);
-          break;
-        case RESOURCE_INSTANCE_INITIALIZE_TOKEN:
-          readResourceInstanceCreateToken(true);
-          break;
-        case RESOURCE_INSTANCE_DELETE_TOKEN:
-          readResourceInstanceDeleteToken();
-          break;
-        case SAMPLE_TOKEN:
-          readSampleToken();
-          break;
-        default:
-          throw new IOException(LocalizedStrings.StatArchiveReader_UNEXPECTED_TOKEN_BYTE_VALUE_0.toLocalizedString(Byte.valueOf(token)));
+          case HEADER_TOKEN:
+            readHeaderToken();
+            break;
+          case RESOURCE_TYPE_TOKEN:
+            readResourceTypeToken();
+            break;
+          case RESOURCE_INSTANCE_CREATE_TOKEN:
+            readResourceInstanceCreateToken(false);
+            break;
+          case RESOURCE_INSTANCE_INITIALIZE_TOKEN:
+            readResourceInstanceCreateToken(true);
+            break;
+          case RESOURCE_INSTANCE_DELETE_TOKEN:
+            readResourceInstanceDeleteToken();
+            break;
+          case SAMPLE_TOKEN:
+            readSampleToken();
+            break;
+          default:
+            throw new IOException(LocalizedStrings.StatArchiveReader_UNEXPECTED_TOKEN_BYTE_VALUE_0
+                .toLocalizedString(Byte.valueOf(token)));
+
-      for (int i=0; i < resourceInstTable.length; i++) {
+      for (int i = 0; i < resourceInstTable.length; i++) {

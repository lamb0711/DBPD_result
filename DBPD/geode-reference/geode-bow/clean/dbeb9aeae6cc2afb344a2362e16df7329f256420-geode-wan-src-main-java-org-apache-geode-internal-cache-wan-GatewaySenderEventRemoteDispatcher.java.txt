Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class GatewaySenderEventRemoteDispatcher implements
-    GatewaySenderEventDispatcher {
+public class GatewaySenderEventRemoteDispatcher implements GatewaySenderEventDispatcher {
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-  
+
-//    this.ackReaderThread = new AckReaderThread(sender);
+    // this.ackReaderThread = new AckReaderThread(sender);
-    }
-    catch (GatewaySenderException e) {
+    } catch (GatewaySenderException e) {
-  
+
-          ack = (GatewayAck)sp.receiveAckFromReceiver(connection);
+          ack = (GatewayAck) sp.receiveAckFromReceiver(connection);
-        ex = (BatchException70)t;
-      } else if (e instanceof GatewaySenderException) { //This Exception is thrown from getConnection
+        ex = (BatchException70) t;
+      } else if (e instanceof GatewaySenderException) { // This Exception is thrown from
+                                                        // getConnection
-      }else {
+      } else {
-          || (ex instanceof ServerConnectivityException && !(ex.getCause() instanceof PdxRegistryMismatchException))
+          || (ex instanceof ServerConnectivityException
+              && !(ex.getCause() instanceof PdxRegistryMismatchException))
-          logger.fatal(LocalizedMessage.create(
+          logger.fatal(
+              LocalizedMessage.create(
-                  ex);
+              ex);
-  
+
-      success =_dispatchBatch(events, isRetry);
+      success = _dispatchBatch(events, isRetry);
-      } else if (t instanceof IOException
-          || t instanceof ServerConnectivityException
-          || t instanceof ConnectionDestroyedException
-          || t instanceof MessageTooLargeException
+      } else if (t instanceof IOException || t instanceof ServerConnectivityException
+          || t instanceof ConnectionDestroyedException || t instanceof MessageTooLargeException
-          logger.debug("Because of IOException, failed to dispatch a batch with id : {}", this.processor.getBatchId());
+          logger.debug("Because of IOException, failed to dispatch a batch with id : {}",
+              this.processor.getBatchId());
-      }
-      else {
-        logger.fatal(LocalizedMessage.create(
-            LocalizedStrings.GatewayEventRemoteDispatcher_STOPPING_THE_PROCESSOR_BECAUSE_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_PROCESSING_A_BATCH), ge);
+      } else {
+        logger.fatal(
+            LocalizedMessage.create(
+                LocalizedStrings.GatewayEventRemoteDispatcher_STOPPING_THE_PROCESSOR_BECAUSE_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_PROCESSING_A_BATCH),
+            ge);
-    }
-    catch (CancelException e) {
+    } catch (CancelException e) {
-        logger.debug("Stopping the processor because cancellation occurred while processing a batch");
+        logger
+            .debug("Stopping the processor because cancellation occurred while processing a batch");
-      logger.fatal(LocalizedMessage.create(
+      logger.fatal(
+          LocalizedMessage.create(
-              e);
+          e);
-    if (currentBatchId != batchIdForThisConnection
-        || this.processor.isConnectionReset()) {
+    if (currentBatchId != batchIdForThisConnection || this.processor.isConnectionReset()) {
-            logger.debug("{} : Dispatched batch (id={}) of {} events, queue size: {} on connection {}",
-                this.processor.getSender(), currentBatchId,  events.size(), this.processor.getQueue().size(), connection);
+            logger.debug(
+                "{} : Dispatched batch (id={}) of {} events, queue size: {} on connection {}",
+                this.processor.getSender(), currentBatchId, events.size(),
+                this.processor.getQueue().size(), connection);
-      }
-      finally{
+      } finally {
-    }
-    catch (ServerOperationException e) {
+    } catch (ServerOperationException e) {
-        ex = (BatchException70)t;
-      }
-      else {
+        ex = (BatchException70) t;
+      } else {
-          LocalizedStrings.GatewayEventRemoteDispatcher_0_EXCEPTION_DURING_PROCESSING_BATCH_1_ON_CONNECTION_2.toLocalizedString(
-              new Object[] {this, Integer.valueOf(currentBatchId), connection}), ex);
-    }
-    catch (GemFireIOException e) {
+          LocalizedStrings.GatewayEventRemoteDispatcher_0_EXCEPTION_DURING_PROCESSING_BATCH_1_ON_CONNECTION_2
+              .toLocalizedString(new Object[] {this, Integer.valueOf(currentBatchId), connection}),
+          ex);
+    } catch (GemFireIOException e) {
-        ex = (MessageTooLargeException)t;
-        // Reduce the batch size by half of the configured batch size or number of events in the current batch (whichever is less)
-        int newBatchSize = Math.min(events.size(), this.processor.getBatchSize())/2;
+        ex = (MessageTooLargeException) t;
+        // Reduce the batch size by half of the configured batch size or number of events in the
+        // current batch (whichever is less)
+        int newBatchSize = Math.min(events.size(), this.processor.getBatchSize()) / 2;
-            LocalizedStrings.GatewaySenderEventRemoteDispatcher_MESSAGE_TOO_LARGE_EXCEPTION, new Object[] { events.size(), newBatchSize }), e);
+            LocalizedStrings.GatewaySenderEventRemoteDispatcher_MESSAGE_TOO_LARGE_EXCEPTION,
+            new Object[] {events.size(), newBatchSize}), e);
-      }
-      else {
+      } else {
-          LocalizedStrings.GatewayEventRemoteDispatcher_0_EXCEPTION_DURING_PROCESSING_BATCH_1_ON_CONNECTION_2.toLocalizedString(
-              new Object[] {this, Integer.valueOf(currentBatchId), connection}), ex);
-    }
-    catch (IllegalStateException e) {
+          LocalizedStrings.GatewayEventRemoteDispatcher_0_EXCEPTION_DURING_PROCESSING_BATCH_1_ON_CONNECTION_2
+              .toLocalizedString(new Object[] {this, Integer.valueOf(currentBatchId), connection}),
+          ex);
+    } catch (IllegalStateException e) {
-          LocalizedStrings.GatewayEventRemoteDispatcher_0_EXCEPTION_DURING_PROCESSING_BATCH_1_ON_CONNECTION_2.toLocalizedString(
-              new Object[] {this, Integer.valueOf(currentBatchId), connection}), e);
-    }
-    catch (Exception e) {
+          LocalizedStrings.GatewayEventRemoteDispatcher_0_EXCEPTION_DURING_PROCESSING_BATCH_1_ON_CONNECTION_2
+              .toLocalizedString(new Object[] {this, Integer.valueOf(currentBatchId), connection}),
+          e);
+    } catch (Exception e) {
-        ex = (IOException)t;
+        ex = (IOException) t;
-      //the cause is not going to be BatchException70. So, destroy the connection
+      // the cause is not going to be BatchException70. So, destroy the connection
-      
+
-          LocalizedStrings.GatewayEventRemoteDispatcher_0_EXCEPTION_DURING_PROCESSING_BATCH_1_ON_CONNECTION_2.toLocalizedString(
-              new Object[] {this, Integer.valueOf(currentBatchId), connection}), ex);
+          LocalizedStrings.GatewayEventRemoteDispatcher_0_EXCEPTION_DURING_PROCESSING_BATCH_1_ON_CONNECTION_2
+              .toLocalizedString(new Object[] {this, Integer.valueOf(currentBatchId), connection}),
+          ex);
-  
+
-   * Acquires or adds a new <code>Connection</code> to the corresponding
-   * <code>Gateway</code>
+   * Acquires or adds a new <code>Connection</code> to the corresponding <code>Gateway</code>
-  public Connection getConnection(boolean startAckReaderThread) throws GatewaySenderException{
+  public Connection getConnection(boolean startAckReaderThread) throws GatewaySenderException {
-    // IF the connection is null 
+    // IF the connection is null
-    if(!this.sender.isParallel()) {
+    if (!this.sender.isParallel()) {
-          logger.debug("Initializing new connection as serverLocation of old connection is : {} and the serverLocation to connect is {}",
+          logger.debug(
+              "Initializing new connection as serverLocation of old connection is : {} and the serverLocation to connect is {}",
-    
+
-  
+
-        
+
-    }
-    finally {
+    } finally {
-  private void initializeConnection() throws GatewaySenderException,
-      GemFireSecurityException {
-    this.connectionLifeCycleLock.writeLock().lock(); 
+  private void initializeConnection() throws GatewaySenderException, GemFireSecurityException {
+    this.connectionLifeCycleLock.writeLock().lock();
-      if (this.sender.getProxy() == null
-          || this.sender.getProxy().isDestroyed()) {
+      if (this.sender.getProxy() == null || this.sender.getProxy().isDestroyed()) {
-           * TODO - The use of acquireConnection should be removed
-           * from the gateway code. This method is fine for tests,
-           * but these connections should really be managed inside
-           * the pool code. If the gateway needs to persistent connection
-           * to a single server, which should create have the OpExecutor
-           * that holds a reference to the connection (similar to the way
-           * we do with thread local connections).
-           * Use {@link ExecutablePool#setupServerAffinity(boolean)} for
-           * gateway code
+           * TODO - The use of acquireConnection should be removed from the gateway code. This
+           * method is fine for tests, but these connections should really be managed inside the
+           * pool code. If the gateway needs to persistent connection to a single server, which
+           * should create have the OpExecutor that holds a reference to the connection (similar to
+           * the way we do with thread local connections). Use {@link
+           * ExecutablePool#setupServerAffinity(boolean)} for gateway code
-          sender.setServerLocation(con.getServer());  
+          sender.setServerLocation(con.getServer());
-          synchronized (this.sender
-              .getLockForConcurrentDispatcher()) {
+          synchronized (this.sender.getLockForConcurrentDispatcher()) {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayEventRemoteDispatcher_0_COULD_NOT_CONNECT_1,
-                new Object[] { this.processor.getSender().getId(), ex.getMessage() }));
+            logger.warn(LocalizedMessage.create(
+                LocalizedStrings.GatewayEventRemoteDispatcher_0_COULD_NOT_CONNECT_1,
+                new Object[] {this.processor.getSender().getId(), ex.getMessage()}));
-        List<ServerLocation> servers = this.sender.getProxy()
-            .getCurrentServers();
+        List<ServerLocation> servers = this.sender.getProxy().getCurrentServers();
-          ioMsg = LocalizedStrings.GatewayEventRemoteDispatcher_NO_AVAILABLE_CONNECTION_WAS_FOUND_BUT_THE_FOLLOWING_ACTIVE_SERVERS_EXIST_0
-              .toLocalizedString(buffer.toString());
+          ioMsg =
+              LocalizedStrings.GatewayEventRemoteDispatcher_NO_AVAILABLE_CONNECTION_WAS_FOUND_BUT_THE_FOLLOWING_ACTIVE_SERVERS_EXIST_0
+                  .toLocalizedString(buffer.toString());
-          logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayEventRemoteDispatcher__0___COULD_NOT_CONNECT,
-                  this.processor.getSender().getId()));
+          logger.warn(LocalizedMessage.create(
+              LocalizedStrings.GatewayEventRemoteDispatcher__0___COULD_NOT_CONNECT,
+              this.processor.getSender().getId()));
-                .toLocalizedString(this.processor.getSender().getId()), ex);
+                .toLocalizedString(this.processor.getSender().getId()),
+            ex);
-        Object[] logArgs = new Object[] { this.processor.getSender().getId(),
-            con, Integer.valueOf(this.failedConnectCount) };
-        logger.info(LocalizedMessage.create(LocalizedStrings.GatewayEventRemoteDispatcher_0_USING_1_AFTER_2_FAILED_CONNECT_ATTEMPTS,
-                logArgs));
+        Object[] logArgs = new Object[] {this.processor.getSender().getId(), con,
+            Integer.valueOf(this.failedConnectCount)};
+        logger.info(LocalizedMessage.create(
+            LocalizedStrings.GatewayEventRemoteDispatcher_0_USING_1_AFTER_2_FAILED_CONNECT_ATTEMPTS,
+            logArgs));
-        Object[] logArgs = new Object[] { this.processor.getSender().getId(),
-            con };
-        logger.info(LocalizedMessage.create(LocalizedStrings.GatewayEventRemoteDispatcher_0_USING_1, logArgs));
+        Object[] logArgs = new Object[] {this.processor.getSender().getId(), con};
+        logger.info(LocalizedMessage.create(LocalizedStrings.GatewayEventRemoteDispatcher_0_USING_1,
+            logArgs));
-    }
-    catch (ConnectionDestroyedException e) {
+    } catch (ConnectionDestroyedException e) {
-          LocalizedStrings.GatewayEventRemoteDispatcher__0___COULD_NOT_CONNECT.toLocalizedString(this.processor
-              .getSender().getId()), e);
-    }
-    finally {
+          LocalizedStrings.GatewayEventRemoteDispatcher__0___COULD_NOT_CONNECT
+              .toLocalizedString(this.processor.getSender().getId()),
+          e);
+    } finally {
-	if (logger.isDebugEnabled() || this.failedConnectCount == 0) {
-	  return true;
-	}
-	else {
-	  // subsequent failures will be logged on 30th, 300th, 3000th try
-	  // each try is at 100millis from higher layer so this accounts for logging
-	  // after 3s, 30s and then every 5mins
-	  if (this.failedConnectCount >= 3000) {
-	    return (this.failedConnectCount % 3000) == 0;
-	  }
-	  else {
-	    return (this.failedConnectCount == 30 || this.failedConnectCount == 300);
-	  }
+    if (logger.isDebugEnabled() || this.failedConnectCount == 0) {
+      return true;
+    } else {
+      // subsequent failures will be logged on 30th, 300th, 3000th try
+      // each try is at 100millis from higher layer so this accounts for logging
+      // after 3s, 30s and then every 5mins
+      if (this.failedConnectCount >= 3000) {
+        return (this.failedConnectCount % 3000) == 0;
+      } else {
+        return (this.failedConnectCount == 30 || this.failedConnectCount == 300);
+      }
-  
+
-    
+
-      super("AckReaderThread for : " + processor.getName());
+      this(sender, processor.getName());
+    }
+
+    public AckReaderThread(GatewaySender sender, String name) {
+      super("AckReaderThread for : " + name);
-      this.cache = (GemFireCacheImpl)((AbstractGatewaySender)sender).getCache();
+      this.cache = (GemFireCacheImpl) ((AbstractGatewaySender) sender).getCache();
-              logger.info(LocalizedMessage.create(
+              logger.warn(LocalizedMessage.create(
-                      new Object[] { processor.getSender(), ack.getBatchId() }, ack.getBatchException()));
+                  new Object[] {processor.getSender(), ack.getBatchId()}));
-          logger.fatal(LocalizedMessage.create(
-              LocalizedStrings.GatewayEventRemoteDispatcher_STOPPING_THE_PROCESSOR_BECAUSE_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_PROCESSING_A_BATCH) ,e);
+          logger.fatal(
+              LocalizedMessage.create(
+                  LocalizedStrings.GatewayEventRemoteDispatcher_STOPPING_THE_PROCESSOR_BECAUSE_THE_FOLLOWING_EXCEPTION_OCCURRED_WHILE_PROCESSING_A_BATCH),
+              e);
-     * @param exception 
+     * @param exception
-    private void logBatchExceptions(BatchException70 exception) {
-      for (BatchException70 be : exception.getExceptions()) {
-        boolean logWarning = true;
-        if (be.getCause() instanceof RegionDestroyedException) {
-          RegionDestroyedException rde = (RegionDestroyedException)be
-              .getCause();
-          synchronized (notFoundRegionsSync) {
-            if (notFoundRegions.contains(rde.getRegionFullPath())) {
-              logWarning = false;
-            } else {
-              notFoundRegions.add(rde.getRegionFullPath());
+    protected void logBatchExceptions(BatchException70 exception) {
+      try {
+        for (BatchException70 be : exception.getExceptions()) {
+          boolean logWarning = true;
+          if (be.getCause() instanceof RegionDestroyedException) {
+            RegionDestroyedException rde = (RegionDestroyedException) be.getCause();
+            synchronized (notFoundRegionsSync) {
+              if (notFoundRegions.contains(rde.getRegionFullPath())) {
+                logWarning = false;
+              } else {
+                notFoundRegions.add(rde.getRegionFullPath());
+              }
-          }
-        } else if (be.getCause() instanceof IllegalStateException
-            && be.getCause().getMessage().contains("Unknown pdx type")) {
-          List<GatewaySenderEventImpl> pdxEvents = processor
-              .getBatchIdToPDXEventsMap().get(be.getBatchId());
-          if (logWarning) {
-            logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayEventRemoteDispatcher_A_BATCHEXCEPTION_OCCURRED_PROCESSING_PDX_EVENT__0,
-                    be.getIndex()), be);
-          }
-          if (pdxEvents != null) {
-            for (GatewaySenderEventImpl senderEvent : pdxEvents) {
-              senderEvent.isAcked = false;
-            }
-            GatewaySenderEventImpl gsEvent = pdxEvents.get(be.getIndex());
+          } else if (be.getCause() instanceof IllegalStateException
+              && be.getCause().getMessage().contains("Unknown pdx type")) {
+            List<GatewaySenderEventImpl> pdxEvents =
+                processor.getBatchIdToPDXEventsMap().get(be.getBatchId());
-                  LocalizedStrings.GatewayEventRemoteDispatcher_THE_EVENT_BEING_PROCESSED_WHEN_THE_BATCHEXCEPTION_OCCURRED_WAS__0, gsEvent));
+                  LocalizedStrings.GatewayEventRemoteDispatcher_A_BATCHEXCEPTION_OCCURRED_PROCESSING_PDX_EVENT__0,
+                  be.getIndex()), be);
+            if (pdxEvents != null) {
+              for (GatewaySenderEventImpl senderEvent : pdxEvents) {
+                senderEvent.isAcked = false;
+              }
+              GatewaySenderEventImpl gsEvent = pdxEvents.get(be.getIndex());
+              if (logWarning) {
+                logger.warn(LocalizedMessage.create(
+                    LocalizedStrings.GatewayEventRemoteDispatcher_THE_EVENT_BEING_PROCESSED_WHEN_THE_BATCHEXCEPTION_OCCURRED_WAS__0,
+                    gsEvent));
+              }
+            }
+            continue;
-          continue;
-        }
-        if (logWarning) {
-          logger.warn(LocalizedMessage.create(LocalizedStrings.GatewayEventRemoteDispatcher_A_BATCHEXCEPTION_OCCURRED_PROCESSING_EVENT__0,
-              be.getIndex()), be);
-        }
-        List<GatewaySenderEventImpl>[] eventsArr = processor.getBatchIdToEventsMap().get(be.getBatchId()); 
-        if (eventsArr != null) {
-          List<GatewaySenderEventImpl> filteredEvents = eventsArr[1];
-          GatewaySenderEventImpl gsEvent = (GatewaySenderEventImpl)filteredEvents
-              .get(be.getIndex());
-                LocalizedStrings.GatewayEventRemoteDispatcher_THE_EVENT_BEING_PROCESSED_WHEN_THE_BATCHEXCEPTION_OCCURRED_WAS__0, gsEvent));
+                LocalizedStrings.GatewayEventRemoteDispatcher_A_BATCHEXCEPTION_OCCURRED_PROCESSING_EVENT__0,
+                be.getIndex()), be);
+          }
+          List<GatewaySenderEventImpl>[] eventsArr =
+              processor.getBatchIdToEventsMap().get(be.getBatchId());
+          if (eventsArr != null) {
+            List<GatewaySenderEventImpl> filteredEvents = eventsArr[1];
+            GatewaySenderEventImpl gsEvent =
+                (GatewaySenderEventImpl) filteredEvents.get(be.getIndex());
+            if (logWarning) {
+              logger.warn(LocalizedMessage.create(
+                  LocalizedStrings.GatewayEventRemoteDispatcher_THE_EVENT_BEING_PROCESSED_WHEN_THE_BATCHEXCEPTION_OCCURRED_WAS__0,
+                  gsEvent));
+            }
+      } catch (Exception e) {
+        logger.warn(
+            LocalizedMessage.create(
+                LocalizedStrings.GatewayEventRemoteDispatcher_AN_EXCEPTION_OCCURRED_PROCESSING_A_BATCHEXCEPTION__0),
+            e);
-        logger.warn(LocalizedMessage.create(LocalizedStrings.GatewaySender_ACKREADERTHREAD_IGNORED_CANCELLATION));
+        logger.warn(LocalizedMessage
+            .create(LocalizedStrings.GatewaySender_ACKREADERTHREAD_IGNORED_CANCELLATION));
-      //attempt to unblock the ackReader thread by shutting down the inputStream, if it was stuck on a read
+      // attempt to unblock the ackReader thread by shutting down the inputStream, if it was stuck
+      // on a read
-    
+
-  
+
-      return connection != null;
+    return connection != null && !connection.isDestroyed();
-  
+
-    if(this.processor.isStopped()) {
+    if (this.processor.isStopped()) {

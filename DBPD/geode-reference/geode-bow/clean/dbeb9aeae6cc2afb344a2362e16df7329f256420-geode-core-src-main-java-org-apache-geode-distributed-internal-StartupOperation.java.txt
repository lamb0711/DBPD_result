Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-  
+
-  
-  /** send the startup message and wait for responses.  If timeout is zero,
-      this waits forever for all responses to come back.  This method may
-      throw jgroups and other io exceptions since it interacts with the
-      distribution manager at a low level to send the startup messages.  It
-      does this to ensure it knows which recipients didn't receive the message.
-      @return whether all recipients could be contacted.  The failure set can be fetched with getFailureSet??
-    */
-  boolean sendStartupMessage(Set recipients, long timeout, Set interfaces, 
-      String redundancyZone, boolean enforceUniqueZone)
-            throws InterruptedException, ReplyException,
-              java.net.UnknownHostException, IOException
-  {
-    if (Thread.interrupted()) throw new InterruptedException();
+
+  /**
+   * send the startup message and wait for responses. If timeout is zero, this waits forever for all
+   * responses to come back. This method may throw jgroups and other io exceptions since it
+   * interacts with the distribution manager at a low level to send the startup messages. It does
+   * this to ensure it knows which recipients didn't receive the message.
+   * 
+   * @return whether all recipients could be contacted. The failure set can be fetched with
+   *         getFailureSet??
+   */
+  boolean sendStartupMessage(Set recipients, long timeout, Set interfaces, String redundancyZone,
+      boolean enforceUniqueZone)
+      throws InterruptedException, ReplyException, java.net.UnknownHostException, IOException {
+    if (Thread.interrupted())
+      throw new InterruptedException();
-    StartupMessage msg = new StartupMessage(InternalLocator.getLocatorStrings(), isSharedConfigurationEnabled);
-    
+    StartupMessage msg =
+        new StartupMessage(InternalLocator.getLocatorStrings(), isSharedConfigurationEnabled);
+
-    this.newlyDeparted = dm.sendOutgoing(msg);  // set of departed jgroups ids
+    this.newlyDeparted = dm.sendOutgoing(msg); // set of departed jgroups ids
-//      Vector viewMembers = dm.getViewMembers();
-      for (Iterator it=this.newlyDeparted.iterator(); it.hasNext(); ) {
-        InternalDistributedMember id = (InternalDistributedMember)it.next();
-        this.dm.handleManagerDeparture(id, false, LocalizedStrings.StartupOperation_LEFT_THE_MEMBERSHIP_VIEW.toLocalizedString());
+      // Vector viewMembers = dm.getViewMembers();
+      for (Iterator it = this.newlyDeparted.iterator(); it.hasNext();) {
+        InternalDistributedMember id = (InternalDistributedMember) it.next();
+        this.dm.handleManagerDeparture(id, false,
+            LocalizedStrings.StartupOperation_LEFT_THE_MEMBERSHIP_VIEW.toLocalizedString());
-    
+
-    }
-    finally {
+    } finally {
-          for (Iterator it=unresponsive.iterator(); it.hasNext(); ) {
-            InternalDistributedMember um = (InternalDistributedMember)it.next();
+          for (Iterator it = unresponsive.iterator(); it.hasNext();) {
+            InternalDistributedMember um = (InternalDistributedMember) it.next();
-              dm.handleManagerDeparture(um, true, LocalizedStrings.StartupOperation_DISAPPEARED_DURING_STARTUP_HANDSHAKE.toLocalizedString());
-            }
-            else
-            if (dm.isCurrentMember(um)) {
+              dm.handleManagerDeparture(um, true,
+                  LocalizedStrings.StartupOperation_DISAPPEARED_DURING_STARTUP_HANDSHAKE
+                      .toLocalizedString());
+            } else if (dm.isCurrentMember(um)) {
-            } 
+            }
-          
+
-    
+
-//    problems = problems || 
-//        (unresponsive != null && unresponsive.size() > 0);
+    // problems = problems ||
+    // (unresponsive != null && unresponsive.size() > 0);

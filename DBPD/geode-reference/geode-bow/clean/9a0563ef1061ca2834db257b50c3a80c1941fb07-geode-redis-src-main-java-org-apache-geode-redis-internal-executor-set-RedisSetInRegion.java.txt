GEODE-8170: change all hash and set commands to use function (#5125)

All hash and set commands now use the new function+delta data model.
This allowed the synchronized keyword to be removed from RedisHash and RedisSet.

+import static java.util.Collections.emptySet;
+import org.apache.geode.internal.cache.LocalDataSet;
+  public int sunionstore(StripedExecutor stripedExecutor, ByteArrayWrapper destination,
+      ArrayList<ByteArrayWrapper> setKeys) {
+    ArrayList<Set<ByteArrayWrapper>> nonDestinationSets = fetchSets(setKeys, destination);
+    return stripedExecutor
+        .execute(destination, () -> doSunionstore(destination, nonDestinationSets));
+  }
+
+  private int doSunionstore(ByteArrayWrapper destination,
+      ArrayList<Set<ByteArrayWrapper>> nonDestinationSets) {
+    RedisSet redisSet = checkType(region.get(destination));
+    redisSet = new RedisSet(computeUnion(nonDestinationSets, redisSet));
+    region.put(destination, redisSet);
+    return redisSet.scard();
+  }
+
+  private Set<ByteArrayWrapper> computeUnion(ArrayList<Set<ByteArrayWrapper>> nonDestinationSets,
+      RedisSet redisSet) {
+    Set<ByteArrayWrapper> result = null;
+    if (nonDestinationSets.isEmpty()) {
+      return emptySet();
+    }
+    for (Set<ByteArrayWrapper> set : nonDestinationSets) {
+      if (set == null) {
+        set = redisSet.smembers();
+      }
+      if (result == null) {
+        result = set;
+      } else {
+        result.addAll(set);
+      }
+    }
+    return result;
+  }
+
+  public int sinterstore(StripedExecutor stripedExecutor, ByteArrayWrapper destination,
+      ArrayList<ByteArrayWrapper> setKeys) {
+    ArrayList<Set<ByteArrayWrapper>> nonDestinationSets = fetchSets(setKeys, destination);
+    return stripedExecutor
+        .execute(destination, () -> doSinterstore(destination, nonDestinationSets));
+  }
+
+  private int doSinterstore(ByteArrayWrapper destination,
+      ArrayList<Set<ByteArrayWrapper>> nonDestinationSets) {
+    RedisSet redisSet = checkType(region.get(destination));
+    redisSet = new RedisSet(computeIntersection(nonDestinationSets, redisSet));
+    region.put(destination, redisSet);
+    return redisSet.scard();
+  }
+
+  private Set<ByteArrayWrapper> computeIntersection(
+      ArrayList<Set<ByteArrayWrapper>> nonDestinationSets, RedisSet redisSet) {
+    Set<ByteArrayWrapper> result = null;
+    if (nonDestinationSets.isEmpty()) {
+      return emptySet();
+    }
+    for (Set<ByteArrayWrapper> set : nonDestinationSets) {
+      if (set == null) {
+        set = redisSet.smembers();
+      }
+      if (result == null) {
+        result = set;
+      } else {
+        result.retainAll(set);
+      }
+    }
+    return result;
+  }
+
+  public int sdiffstore(StripedExecutor stripedExecutor, ByteArrayWrapper destination,
+      ArrayList<ByteArrayWrapper> setKeys) {
+    ArrayList<Set<ByteArrayWrapper>> nonDestinationSets = fetchSets(setKeys, destination);
+    return stripedExecutor
+        .execute(destination, () -> doSdiffstore(destination, nonDestinationSets));
+  }
+
+  private int doSdiffstore(ByteArrayWrapper destination,
+      ArrayList<Set<ByteArrayWrapper>> nonDestinationSets) {
+    RedisSet redisSet = checkType(region.get(destination));
+    redisSet = new RedisSet(computeDiff(nonDestinationSets, redisSet));
+    region.put(destination, redisSet);
+    return redisSet.scard();
+  }
+
+  private Set<ByteArrayWrapper> computeDiff(ArrayList<Set<ByteArrayWrapper>> nonDestinationSets,
+      RedisSet redisSet) {
+    Set<ByteArrayWrapper> result = null;
+    if (nonDestinationSets.isEmpty()) {
+      return emptySet();
+    }
+    for (Set<ByteArrayWrapper> set : nonDestinationSets) {
+      if (set == null) {
+        set = redisSet.smembers();
+      }
+      if (result == null) {
+        result = set;
+      } else {
+        result.removeAll(set);
+      }
+    }
+    return result;
+  }
+
+  /**
+   * Gets the set data for the given keys, excluding the destination if it was in setKeys.
+   * The result will have an element for each corresponding key and a null element if
+   * the corresponding key is the destination.
+   * This is all done outside the striped executor to prevent a deadlock.
+   */
+  @SuppressWarnings("unchecked")
+  private ArrayList<Set<ByteArrayWrapper>> fetchSets(ArrayList<ByteArrayWrapper> setKeys,
+      ByteArrayWrapper destination) {
+    ArrayList<Set<ByteArrayWrapper>> result = new ArrayList<>(setKeys.size());
+    Region fetchRegion = region;
+    if (fetchRegion instanceof LocalDataSet) {
+      LocalDataSet lds = (LocalDataSet) fetchRegion;
+      fetchRegion = lds.getProxy();
+    }
+    RedisSetCommands redisSetCommands = new RedisSetCommandsFunctionExecutor(fetchRegion);
+    for (ByteArrayWrapper key : setKeys) {
+      if (key.equals(destination)) {
+        result.add(null);
+      } else {
+        result.add(redisSetCommands.smembers(key));
+      }
+    }
+    return result;
+  }
+
+  @Override
+  public int sunionstore(ByteArrayWrapper destination, ArrayList<ByteArrayWrapper> setKeys) {
+    throw new IllegalStateException("should never be called");
+  }
+
+  @Override
+  public int sinterstore(ByteArrayWrapper destination, ArrayList<ByteArrayWrapper> setKeys) {
+    throw new IllegalStateException("should never be called");
+  }
+
+  @Override
+  public int sdiffstore(ByteArrayWrapper destination, ArrayList<ByteArrayWrapper> setKeys) {
+    throw new IllegalStateException("should never be called");
+  }
+

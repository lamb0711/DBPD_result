Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public final class FetchBulkEntriesMessage extends PartitionMessage
-  {
+public final class FetchBulkEntriesMessage extends PartitionMessage {
-  
+
-  
-  private static final byte ALL_KEYS = (byte)0;
-  private static final byte KEY_LIST = (byte)1;
+  private static final byte ALL_KEYS = (byte) 0;
-  private static final byte REGEX = (byte)2;
+  private static final byte KEY_LIST = (byte) 1;
+
+  private static final byte REGEX = (byte) 2;
-  public FetchBulkEntriesMessage() {
-  }
+  public FetchBulkEntriesMessage() {}
-  private FetchBulkEntriesMessage(InternalDistributedMember recipient,
-      int regionId, ReplyProcessor21 processor,
-      HashMap<Integer, HashSet> bucketKeys, HashSet<Integer> bucketIds,
+  private FetchBulkEntriesMessage(InternalDistributedMember recipient, int regionId,
+      ReplyProcessor21 processor, HashMap<Integer, HashSet> bucketKeys, HashSet<Integer> bucketIds,
-   * @param recipient the member that the fetch keys message is sent to 
-   * @param r  the PartitionedRegion that contains the bucket
+   * 
+   * @param recipient the member that the fetch keys message is sent to
+   * @param r the PartitionedRegion that contains the bucket
-  public static FetchBulkEntriesResponse send(
-      InternalDistributedMember recipient, PartitionedRegion r,
-      HashMap<Integer, HashSet> bucketKeys, HashSet<Integer> bucketIds,
+  public static FetchBulkEntriesResponse send(InternalDistributedMember recipient,
+      PartitionedRegion r, HashMap<Integer, HashSet> bucketKeys, HashSet<Integer> bucketIds,
-      throw new ForceReattemptException(LocalizedStrings.FetchEntriesMessage_FAILED_SENDING_0.toLocalizedString(m));
+      throw new ForceReattemptException(
+          LocalizedStrings.FetchEntriesMessage_FAILED_SENDING_0.toLocalizedString(m));
-  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion pr, long startTime)
-      throws CacheException, ForceReattemptException
-  {
+  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion pr,
+      long startTime) throws CacheException, ForceReattemptException {
-    FetchBulkEntriesReplyMessage.sendReply(pr, getSender(), getProcessorId(),
-        dm, this.bucketKeys, this.bucketIds, regex, this.allowTombstones, startTime);
+    FetchBulkEntriesReplyMessage.sendReply(pr, getSender(), getProcessorId(), dm, this.bucketKeys,
+        this.bucketIds, regex, this.allowTombstones, startTime);
-  protected void appendFields(StringBuffer buff)
-  {
+  protected void appendFields(StringBuffer buff) {
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException
-  {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-  public void toData(DataOutput out) throws IOException
-  {
+  public void toData(DataOutput out) throws IOException {
-  
+
-    
+
-     * Empty constructor to conform to DataSerializable interface 
+     * Empty constructor to conform to DataSerializable interface
-    public FetchBulkEntriesReplyMessage() {
-    }
-  
-    private FetchBulkEntriesReplyMessage(InternalDistributedMember dest,
-        int processorId, HeapDataOutputStream chunk, int msgNum, boolean lastInSeries) {
+    public FetchBulkEntriesReplyMessage() {}
+
+    private FetchBulkEntriesReplyMessage(InternalDistributedMember dest, int processorId,
+        HeapDataOutputStream chunk, int msgNum, boolean lastInSeries) {
-    public static void sendReply(PartitionedRegion pr,
-        final InternalDistributedMember recipient, final int processorId,
-        final DM dm, final HashMap<Integer, HashSet> bucketKeys,
-        final HashSet<Integer> bucketIds, String regex,
-        boolean allowTombstones, long startTime) throws ForceReattemptException {
+    public static void sendReply(PartitionedRegion pr, final InternalDistributedMember recipient,
+        final int processorId, final DM dm, final HashMap<Integer, HashSet> bucketKeys,
+        final HashSet<Integer> bucketIds, String regex, boolean allowTombstones, long startTime)
+        throws ForceReattemptException {
-      
+
-          InitialImageOperation.CHUNK_SIZE_IN_BYTES + 2048,
-          recipient.getVersionObject());
+          InitialImageOperation.CHUNK_SIZE_IN_BYTES + 2048, recipient.getVersionObject());
-        }
-        catch (CancelException e) {
+        } catch (CancelException e) {
-            logger.debug("sendReply: acquireDestroyLock failed due to cache closure, region = {}", map.getFullPath());
+            logger.debug("sendReply: acquireDestroyLock failed due to cache closure, region = {}",
+                map.getFullPath());
-              it = map.getKeysWithInterest(InterestType.REGULAR_EXPRESSION,
-                  regex, allowTombstones).iterator();
+              it = map.getKeysWithInterest(InterestType.REGULAR_EXPRESSION, regex, allowTombstones)
+                  .iterator();
-            Object value = map.get(key, null, true, true, true, null,
-                clientEvent, allowTombstones);
+            Object value = map.get(key, null, true, true, true, null, clientEvent, allowTombstones);
-            entrySize = mos.size() - entrySize; 
+            entrySize = mos.size() - entrySize;
-            if ((mos.size() + entrySize) >= InitialImageOperation.CHUNK_SIZE_IN_BYTES || !it.hasNext()) {
+            if ((mos.size() + entrySize) >= InitialImageOperation.CHUNK_SIZE_IN_BYTES
+                || !it.hasNext()) {
-              FetchBulkEntriesReplyMessage reply = new FetchBulkEntriesReplyMessage(
-                  recipient, processorId, mos, msgNum, lastMsg);
+              FetchBulkEntriesReplyMessage reply =
+                  new FetchBulkEntriesReplyMessage(recipient, processorId, mos, msgNum, lastMsg);
-          throw new ForceReattemptException(LocalizedStrings.FetchEntriesMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCHENTRIES_REQUEST.toLocalizedString(), ioe);
+          throw new ForceReattemptException(
+              LocalizedStrings.FetchEntriesMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCHENTRIES_REQUEST
+                  .toLocalizedString(),
+              ioe);
-            throw new ForceReattemptException(LocalizedStrings.FetchEntriesMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCHENTRIES_REQUEST.toLocalizedString(), ioe);
+            throw new ForceReattemptException(
+                LocalizedStrings.FetchEntriesMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCHENTRIES_REQUEST
+                    .toLocalizedString(),
+                ioe);
-            DataSerializer.writeObject(null, mos); // end of entries of current bucket in current response
+            DataSerializer.writeObject(null, mos); // end of entries of current bucket in current
+                                                   // response
-            throw new ForceReattemptException(LocalizedStrings.FetchEntriesMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCHENTRIES_REQUEST.toLocalizedString(), ioe);
+            throw new ForceReattemptException(
+                LocalizedStrings.FetchEntriesMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCHENTRIES_REQUEST
+                    .toLocalizedString(),
+                ioe);
-        FetchBulkEntriesReplyMessage reply = new FetchBulkEntriesReplyMessage(
-            recipient, processorId, mos, msgNum, true);
+        FetchBulkEntriesReplyMessage reply =
+            new FetchBulkEntriesReplyMessage(recipient, processorId, mos, msgNum, true);
-     * Processes this message.  This method is invoked by the receiver
-     * of the message.
+     * Processes this message. This method is invoked by the receiver of the message.
+     * 
-      FetchBulkEntriesResponse processor = (FetchBulkEntriesResponse)p;
-  
+      FetchBulkEntriesResponse processor = (FetchBulkEntriesResponse) p;
+
-      dm.getStats().incReplyMessageTime(DistributionStats.getStatTime()
-          - startTime);
+      dm.getStats().incReplyMessageTime(DistributionStats.getStatTime() - startTime);
-    
-   
+
+
-    
+
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    
+
-      sb.append("FetchBulkEntriesReplyMessage ")
-        .append("processorid=").append(this.processorId);
-      if (getSender() != null) { 
+      sb.append("FetchBulkEntriesReplyMessage ").append("processorid=").append(this.processorId);
+      if (getSender() != null) {
-      }
-      else if (chunkStream != null) {
+      } else if (chunkStream != null) {
- 
+
-   * A processor to capture the value returned by {@link 
-   * org.apache.geode.internal.cache.partitioned.FetchBulkEntriesMessage}
+   * A processor to capture the value returned by
+   * {@link org.apache.geode.internal.cache.partitioned.FetchBulkEntriesMessage}
+   * 
-  public static class FetchBulkEntriesResponse extends ReplyProcessor21  {
+  public static class FetchBulkEntriesResponse extends ReplyProcessor21 {
-    private final Map<VersionSource,VersionSource> canonicalMembers = new ConcurrentHashMap<VersionSource,VersionSource>();
-    
+    private final Map<VersionSource, VersionSource> canonicalMembers =
+        new ConcurrentHashMap<VersionSource, VersionSource>();
+
-    
+
-    
+
-    
+
-    
-    public FetchBulkEntriesResponse(InternalDistributedSystem ds,
-        final PartitionedRegion pr, final InternalDistributedMember recipient) {
+
+    public FetchBulkEntriesResponse(InternalDistributedSystem ds, final PartitionedRegion pr,
+        final InternalDistributedMember recipient) {
-      
+
-      }
-      else {
+      } else {
-                    versionTag.setMemberID(canonicalMembers.get(versionTag
-                        .getMemberID()));
+                    versionTag.setMemberID(canonicalMembers.get(versionTag.getMemberID()));
-                    canonicalMembers.put(versionTag.getMemberID(),
-                        versionTag.getMemberID());
+                    canonicalMembers.put(versionTag.getMemberID(), versionTag.getMemberID());
-                  HashMap<Object, VersionTag> versionMap = returnVersions
-                      .get(currentId);
+                  HashMap<Object, VersionTag> versionMap = returnVersions.get(currentId);
-          }  // outer while
+          } // outer while
-          synchronized(this.endLock) {
+          synchronized (this.endLock) {
-  
+
-  
+
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
-            processException(new ReplyException(LocalizedStrings.FetchEntriesMessage_ERROR_DESERIALIZING_KEYS.toLocalizedString(), e));
+            processException(new ReplyException(
+                LocalizedStrings.FetchEntriesMessage_ERROR_DESERIALIZING_KEYS.toLocalizedString(),
+                e));
-            processException(new ReplyException(LocalizedStrings.FetchEntriesMessage_ERROR_DESERIALIZING_VALUES.toLocalizedString(), e)); // for bug 41202
+            processException(new ReplyException(
+                LocalizedStrings.FetchEntriesMessage_ERROR_DESERIALIZING_VALUES.toLocalizedString(),
+                e)); // for bug 41202
-  
+
-      }
-      catch (ReplyException e) {
+      } catch (ReplyException e) {
-          logger.debug("FetchBulkEntriesResponse got remote cancellation; forcing reattempt. {}", t.getMessage(), t);
-          throw new ForceReattemptException(LocalizedStrings.FetchEntriesMessage_FETCHKEYSRESPONSE_GOT_REMOTE_CANCELLATION_FORCING_REATTEMPT.toLocalizedString(), t);
-        }
-        else if (t instanceof ForceReattemptException) {
+          logger.debug("FetchBulkEntriesResponse got remote cancellation; forcing reattempt. {}",
+              t.getMessage(), t);
+          throw new ForceReattemptException(
+              LocalizedStrings.FetchEntriesMessage_FETCHKEYSRESPONSE_GOT_REMOTE_CANCELLATION_FORCING_REATTEMPT
+                  .toLocalizedString(),
+              t);
+        } else if (t instanceof ForceReattemptException) {
-          throw new ForceReattemptException(LocalizedStrings.FetchEntriesMessage_PEER_REQUESTS_REATTEMPT.toLocalizedString(), t);
+          throw new ForceReattemptException(
+              LocalizedStrings.FetchEntriesMessage_PEER_REQUESTS_REATTEMPT.toLocalizedString(), t);
-        throw new ForceReattemptException(LocalizedStrings.FetchEntriesMessage_NO_REPLIES_RECEIVED.toLocalizedString());
+        throw new ForceReattemptException(
+            LocalizedStrings.FetchEntriesMessage_NO_REPLIES_RECEIVED.toLocalizedString());
-        dumps[i] = new BucketDump(id, recipient, null, returnValue.get(id),
-            returnVersions.get(id));
+        dumps[i] = new BucketDump(id, recipient, null, returnValue.get(id), returnVersions.get(id));
-    
+

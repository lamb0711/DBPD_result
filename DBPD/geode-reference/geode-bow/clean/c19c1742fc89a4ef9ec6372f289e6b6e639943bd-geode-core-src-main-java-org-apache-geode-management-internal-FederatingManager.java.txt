GEODE-7221: Cleanup and unit test FederatingManager

* Move inner classes to bottom of outer class
* Extract addMemberArtifacts from GIITask
* Remove unnecessary code
* Create FederatingManagerTest

+import java.util.Collection;
-  public void addMember(DistributedMember member) {
+  @VisibleForTesting
+  public void addMember(InternalDistributedMember member) {
-      } catch (Exception e) {
+      } catch (RuntimeException e) {
-  public void removeMember(DistributedMember member, boolean crashed) {
-    RemoveMemberTask removeTask = new RemoveMemberTask(member, crashed);
-    executeTask(removeTask);
+  void removeMember(DistributedMember member, boolean crashed) {
+    executeTask(new RemoveMemberTask(member, crashed));
-  public void suspectMember(DistributedMember member, InternalDistributedMember whoSuspected,
+  void suspectMember(DistributedMember member, InternalDistributedMember whoSuspected,
-    List<Callable<DistributedMember>> giiTaskList = new ArrayList<>();
+    Collection<Callable<InternalDistributedMember>> giiTaskList = new ArrayList<>();
-    for (DistributedMember member : system.getDistributionManager()
+    for (InternalDistributedMember member : system.getDistributionManager()
-      List<Future<DistributedMember>> futureTaskList =
+      List<Future<InternalDistributedMember>> futureTaskList =
-      for (Future<DistributedMember> futureTask : futureTaskList) {
+      for (Future<InternalDistributedMember> futureTask : futureTaskList) {
-  private class RemoveMemberTask implements Runnable {
-
-    private final DistributedMember member;
-
-    boolean crashed;
-
-    RemoveMemberTask(DistributedMember member, boolean crashed) {
-      this.member = member;
-      this.crashed = crashed;
-    }
-
-    @Override
-    public void run() {
-      removeMemberArtifacts(member, crashed);
-    }
-  }
-
-  /**
-   * Actual task of doing the GII
-   *
-   * <p>
-   * It will perform the GII request which might originate from TransitionListener or Membership
-   * Listener.
-   *
-   * <p>
-   * Managing Node side resources are created per member which is visible to this node:
-   *
-   * <pre>
-   * 1)Management Region : its a Replicated NO_ACK region
-   * 2)Notification Region : its a Replicated Proxy NO_ACK region
-   * </pre>
-   *
-   * <p>
-   * Listeners are added to the above two regions:
-   *
-   * <pre>
-   * 1) ManagementCacheListener
-   * 2) NotificationCacheListener
-   * </pre>
-   *
-   * <p>
-   * This task can be cancelled from the calling thread if a timeout happens. In that case we have
-   * to handle the thread interrupt
-   */
-  private class GIITask implements Callable<DistributedMember> {
-
-    private final DistributedMember member;
-
-    GIITask(DistributedMember member) {
-
-      this.member = member;
-    }
-
-    @Override
-    public DistributedMember call() {
-      synchronized (member) {
-        String appender = MBeanJMXAdapter.getUniqueIDForMember(member);
-        String monitoringRegionName = ManagementConstants.MONITORING_REGION + "_" + appender;
-        String notificationRegionName = ManagementConstants.NOTIFICATION_REGION + "_" + appender;
-
-        if (cache.getInternalRegion(monitoringRegionName) != null
-            && cache.getInternalRegion(notificationRegionName) != null) {
-          return member;
-        }
-
-        try {
-
-          // GII wont start at all if its interrupted
-          if (!Thread.currentThread().isInterrupted()) {
-
-            // as the regions will be internal regions
-            InternalRegionArguments internalRegionArguments = new InternalRegionArguments();
-            internalRegionArguments.setIsUsedForMetaRegion(true);
-
-            // Create anonymous stats holder for Management Regions
-            HasCachePerfStats monitoringRegionStats =
-                () -> new CachePerfStats(cache.getDistributedSystem(),
-                    "RegionStats-managementRegionStats", statisticsClock);
-
-            internalRegionArguments.setCachePerfStatsHolder(monitoringRegionStats);
-
-            // Monitoring region for member is created
-            AttributesFactory<String, Object> monitorAttributesFactory = new AttributesFactory<>();
-            monitorAttributesFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
-            monitorAttributesFactory.setDataPolicy(DataPolicy.REPLICATE);
-            monitorAttributesFactory.setConcurrencyChecksEnabled(false);
-            ManagementCacheListener managementCacheListener =
-                new ManagementCacheListener(proxyFactory);
-            monitorAttributesFactory.addCacheListener(managementCacheListener);
-
-            RegionAttributes<String, Object> monitoringRegionAttrs =
-                monitorAttributesFactory.create();
-
-            // Notification region for member is created
-            AttributesFactory<NotificationKey, Notification> notificationAttributesFactory =
-                new AttributesFactory<>();
-            notificationAttributesFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
-            notificationAttributesFactory.setDataPolicy(DataPolicy.REPLICATE);
-            notificationAttributesFactory.setConcurrencyChecksEnabled(false);
-
-            // Fix for issue #49638, evict the internal region _notificationRegion
-            notificationAttributesFactory
-                .setEvictionAttributes(EvictionAttributes.createLRUEntryAttributes(
-                    ManagementConstants.NOTIF_REGION_MAX_ENTRIES, EvictionAction.LOCAL_DESTROY));
-
-            NotificationCacheListener notifListener = new NotificationCacheListener(proxyFactory);
-            notificationAttributesFactory.addCacheListener(notifListener);
-
-            RegionAttributes<NotificationKey, Notification> notifRegionAttrs =
-                notificationAttributesFactory.create();
-
-            boolean proxyMonitoringRegionCreated;
-
-            Region<String, Object> proxyMonitoringRegion;
-            try {
-              if (!running) {
-                return null;
-              }
-              proxyMonitoringRegion =
-                  cache.createInternalRegion(monitoringRegionName, monitoringRegionAttrs,
-                      internalRegionArguments);
-              proxyMonitoringRegionCreated = true;
-
-            } catch (TimeoutException | RegionExistsException | IOException
-                | ClassNotFoundException e) {
-              if (logger.isDebugEnabled()) {
-                logger.debug("Error During Internal Region creation", e);
-              }
-              throw new ManagementException(e);
-            }
-
-            boolean proxyNotificationRegionCreated = false;
-            Region<NotificationKey, Notification> proxyNotificationRegion;
-            try {
-              if (!running) {
-                return null;
-              }
-              proxyNotificationRegion =
-                  cache.createInternalRegion(notificationRegionName, notifRegionAttrs,
-                      internalRegionArguments);
-              proxyNotificationRegionCreated = true;
-            } catch (TimeoutException | RegionExistsException | IOException
-                | ClassNotFoundException e) {
-              if (logger.isDebugEnabled()) {
-                logger.debug("Error During Internal Region creation", e);
-              }
-              throw new ManagementException(e);
-            } finally {
-              if (!proxyNotificationRegionCreated && proxyMonitoringRegionCreated) {
-                // Destroy the proxy region if proxy notification region is not created
-                proxyMonitoringRegion.localDestroyRegion();
-              }
-            }
-
-            if (logger.isDebugEnabled()) {
-              logger.debug("Management Region created with Name : {}",
-                  proxyMonitoringRegion.getName());
-              logger.debug("Notification Region created with Name : {}",
-                  proxyNotificationRegion.getName());
-            }
-
-            // Only the exception case would have destroyed the proxy
-            // regions. We can safely proceed here.
-            repo.putEntryInMonitoringRegionMap(member, proxyMonitoringRegion);
-            repo.putEntryInNotifRegionMap(member, proxyNotificationRegion);
-            try {
-              if (!running) {
-                return null;
-              }
-              proxyFactory.createAllProxies(member, proxyMonitoringRegion);
-
-              managementCacheListener.markReady();
-              notifListener.markReady();
-            } catch (Exception e) {
-              if (logger.isDebugEnabled()) {
-                logger.debug("Error During GII Proxy creation", e);
-              }
-
-              throw new ManagementException(e);
-            }
-          }
-
-        } catch (Exception e) {
-          throw new ManagementException(e);
-        }
-
-        // Before completing task intimate all listening ProxyListener which might send
-        // notifications.
-        service.memberJoined((InternalDistributedMember) member);
-
-        // Send manager info to the added member
-        messenger.sendManagerInfo(member);
-
-        return member;
-      }
-    }
-  }
-
+  @VisibleForTesting
+
+  @VisibleForTesting
+  void addMemberArtifacts(InternalDistributedMember member) {
+    synchronized (member) {
+      String appender = MBeanJMXAdapter.getUniqueIDForMember(member);
+      String monitoringRegionName = ManagementConstants.MONITORING_REGION + "_" + appender;
+      String notificationRegionName = ManagementConstants.NOTIFICATION_REGION + "_" + appender;
+
+      if (cache.getInternalRegion(monitoringRegionName) != null
+          && cache.getInternalRegion(notificationRegionName) != null) {
+        return;
+      }
+
+      try {
+
+        // GII wont start at all if its interrupted
+        if (!Thread.currentThread().isInterrupted()) {
+
+          // as the regions will be internal regions
+          InternalRegionArguments internalRegionArguments = new InternalRegionArguments();
+          internalRegionArguments.setIsUsedForMetaRegion(true);
+
+          // Create anonymous stats holder for Management Regions
+          HasCachePerfStats monitoringRegionStats =
+              () -> new CachePerfStats(cache.getDistributedSystem(),
+                  "RegionStats-managementRegionStats", statisticsClock);
+
+          internalRegionArguments.setCachePerfStatsHolder(monitoringRegionStats);
+
+          // Monitoring region for member is created
+          AttributesFactory<String, Object> monitorAttributesFactory = new AttributesFactory<>();
+          monitorAttributesFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
+          monitorAttributesFactory.setDataPolicy(DataPolicy.REPLICATE);
+          monitorAttributesFactory.setConcurrencyChecksEnabled(false);
+          ManagementCacheListener managementCacheListener =
+              new ManagementCacheListener(proxyFactory);
+          monitorAttributesFactory.addCacheListener(managementCacheListener);
+
+          RegionAttributes<String, Object> monitoringRegionAttrs =
+              monitorAttributesFactory.create();
+
+          // Notification region for member is created
+          AttributesFactory<NotificationKey, Notification> notificationAttributesFactory =
+              new AttributesFactory<>();
+          notificationAttributesFactory.setScope(Scope.DISTRIBUTED_NO_ACK);
+          notificationAttributesFactory.setDataPolicy(DataPolicy.REPLICATE);
+          notificationAttributesFactory.setConcurrencyChecksEnabled(false);
+
+          // Fix for issue #49638, evict the internal region _notificationRegion
+          notificationAttributesFactory
+              .setEvictionAttributes(EvictionAttributes.createLRUEntryAttributes(
+                  ManagementConstants.NOTIF_REGION_MAX_ENTRIES, EvictionAction.LOCAL_DESTROY));
+
+          NotificationCacheListener notifListener = new NotificationCacheListener(proxyFactory);
+          notificationAttributesFactory.addCacheListener(notifListener);
+
+          RegionAttributes<NotificationKey, Notification> notifRegionAttrs =
+              notificationAttributesFactory.create();
+
+          Region<String, Object> proxyMonitoringRegion;
+          try {
+            if (!running) {
+              return;
+            }
+            proxyMonitoringRegion =
+                cache.createInternalRegion(monitoringRegionName, monitoringRegionAttrs,
+                    internalRegionArguments);
+
+          } catch (TimeoutException | RegionExistsException | IOException
+              | ClassNotFoundException e) {
+            if (logger.isDebugEnabled()) {
+              logger.debug("Error During Internal Region creation", e);
+            }
+            throw new ManagementException(e);
+          }
+
+          boolean proxyNotificationRegionCreated = false;
+          Region<NotificationKey, Notification> proxyNotificationRegion;
+          try {
+            if (!running) {
+              return;
+            }
+            proxyNotificationRegion =
+                cache.createInternalRegion(notificationRegionName, notifRegionAttrs,
+                    internalRegionArguments);
+            proxyNotificationRegionCreated = true;
+          } catch (TimeoutException | RegionExistsException | IOException
+              | ClassNotFoundException e) {
+            if (logger.isDebugEnabled()) {
+              logger.debug("Error During Internal Region creation", e);
+            }
+            throw new ManagementException(e);
+          } finally {
+            if (!proxyNotificationRegionCreated) {
+              // Destroy the proxy region if proxy notification region is not created
+              proxyMonitoringRegion.localDestroyRegion();
+            }
+          }
+
+          if (logger.isDebugEnabled()) {
+            logger.debug("Management Region created with Name : {}",
+                proxyMonitoringRegion.getName());
+            logger.debug("Notification Region created with Name : {}",
+                proxyNotificationRegion.getName());
+          }
+
+          // Only the exception case would have destroyed the proxy
+          // regions. We can safely proceed here.
+          repo.putEntryInMonitoringRegionMap(member, proxyMonitoringRegion);
+          repo.putEntryInNotifRegionMap(member, proxyNotificationRegion);
+          try {
+            if (!running) {
+              return;
+            }
+            proxyFactory.createAllProxies(member, proxyMonitoringRegion);
+
+            managementCacheListener.markReady();
+            notifListener.markReady();
+          } catch (Exception e) {
+            if (logger.isDebugEnabled()) {
+              logger.debug("Error During GII Proxy creation", e);
+            }
+
+            throw new ManagementException(e);
+          }
+        }
+
+      } catch (Exception e) {
+        throw new ManagementException(e);
+      }
+
+      // Before completing task intimate all listening ProxyListener which might send
+      // notifications.
+      service.memberJoined((InternalDistributedMember) member);
+
+      // Send manager info to the added member
+      messenger.sendManagerInfo(member);
+    }
+  }
+
+  /**
+   * Actual task of doing the GII
+   *
+   * <p>
+   * It will perform the GII request which might originate from TransitionListener or Membership
+   * Listener.
+   *
+   * <p>
+   * Managing Node side resources are created per member which is visible to this node:
+   *
+   * <pre>
+   * 1)Management Region : its a Replicated NO_ACK region
+   * 2)Notification Region : its a Replicated Proxy NO_ACK region
+   * </pre>
+   *
+   * <p>
+   * Listeners are added to the above two regions:
+   *
+   * <pre>
+   * 1) ManagementCacheListener
+   * 2) NotificationCacheListener
+   * </pre>
+   *
+   * <p>
+   * This task can be cancelled from the calling thread if a timeout happens. In that case we have
+   * to handle the thread interrupt
+   */
+  private class GIITask implements Callable<InternalDistributedMember> {
+
+    private final InternalDistributedMember member;
+
+    GIITask(InternalDistributedMember member) {
+      this.member = member;
+    }
+
+    @Override
+    public InternalDistributedMember call() {
+      addMemberArtifacts(member);
+      return member;
+    }
+  }
+
+  private class RemoveMemberTask implements Runnable {
+
+    private final DistributedMember member;
+    private final boolean crashed;
+
+    RemoveMemberTask(DistributedMember member, boolean crashed) {
+      this.member = member;
+      this.crashed = crashed;
+    }
+
+    @Override
+    public void run() {
+      removeMemberArtifacts(member, crashed);
+    }
+  }

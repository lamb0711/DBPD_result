Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * TODO - I think a better idea here would be consider
- * source vertices as "temporary" place holders that
- * will get coalesed in the nearest destination vertex
- * in time. That might help the visualization. Or
- * maybe that should happen in that layer...
+ * TODO - I think a better idea here would be consider source vertices as "temporary" place holders
+ * that will get coalesed in the nearest destination vertex in time. That might help the
+ * visualization. Or maybe that should happen in that layer...
-  
+
-  //A map used to find vertices by location id and timestamp.
-  //locationId-> map(timestamp->vertex)
-  private Map<String, SortedMap<Long, Vertex>> indexedVertices = new HashMap<String, SortedMap<Long, Vertex>>();
+  // A map used to find vertices by location id and timestamp.
+  // locationId-> map(timestamp->vertex)
+  private Map<String, SortedMap<Long, Vertex>> indexedVertices =
+      new HashMap<String, SortedMap<Long, Vertex>>();
+   * 
-   * @param isFromPattern 
+   * @param isFromPattern
-  public void addEdge(long timestamp, String edgeName, String state, String source,
-      String dest, boolean isFromPattern) {
+  public void addEdge(long timestamp, String edgeName, String state, String source, String dest,
+      boolean isFromPattern) {
-    SortedMap<Long, Vertex> map  = this.indexedVertices.get(dest);
-    if(map == null) {
+    SortedMap<Long, Vertex> map = this.indexedVertices.get(dest);
+    if (map == null) {
-    
-    //If this edge is being added by a pattern event, only
-    //add the edge if the destination changes state as a result
-    //of this edge. This cuts down on noise in the graph.
-    if(isFromPattern) {
+
+    // If this edge is being added by a pattern event, only
+    // add the edge if the destination changes state as a result
+    // of this edge. This cuts down on noise in the graph.
+    if (isFromPattern) {
-      if(headMap != null && !headMap.isEmpty()) {
+      if (headMap != null && !headMap.isEmpty()) {
-        if(previousVertex.getState().equals(state)) {
+        if (previousVertex.getState().equals(state)) {
-        //Super hack here. Don't add a transition from the non existent state to
-        //the destroyed state in a lifeline.
-        if(state.equals("destroyed")) {
+        // Super hack here. Don't add a transition from the non existent state to
+        // the destroyed state in a lifeline.
+        if (state.equals("destroyed")) {
-    
+
-   * Get the vertices in this graph, grouped by location id and then sorted
-   * by timestamp.
+   * Get the vertices in this graph, grouped by location id and then sorted by timestamp.

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import org.apache.geode.internal.i18n.LocalizedStrings;
+import org.apache.geode.internal.i18n.LocalizedStrings;
- * This structure contains all the filter evaluatable CompiledComparision
- * conditions which are using identical index. Presently this Object will be
- * formed only if the junction is an AND and will either be a part of a
- * GroupJunction or can be a stand alone Junction. In case it is a stand alone
- * Junction, then it can possibly have a not null Iter Operand, so that it can
- * be evaluated along with the expansion/truncation of index result.
+ * This structure contains all the filter evaluatable CompiledComparision conditions which are using
+ * identical index. Presently this Object will be formed only if the junction is an AND and will
+ * either be a part of a GroupJunction or can be a stand alone Junction. In case it is a stand alone
+ * Junction, then it can possibly have a not null Iter Operand, so that it can be evaluated along
+ * with the expansion/truncation of index result.
-  //moved to AbstractGroupOrRangeJunction
-  //private CompiledValue iterOperands;
+  // moved to AbstractGroupOrRangeJunction
+  // private CompiledValue iterOperands;
-  RangeJunction(int operator, RuntimeIterator[] indpndntItr,
-      boolean isCompleteExpansion, CompiledValue[] operands) {
+  RangeJunction(int operator, RuntimeIterator[] indpndntItr, boolean isCompleteExpansion,
+      CompiledValue[] operands) {
+
-	throw new UnsupportedOperationException("This method should not have been invoked");  
+    throw new UnsupportedOperationException("This method should not have been invoked");
+
-/*  void addIterOperands(CompiledValue iterOps) {
-    this.iterOperands = iterOps;
-  }*/
-  private RangeJunction(AbstractGroupOrRangeJunction oldGJ,
-      boolean completeExpansion, RuntimeIterator indpnds[], CompiledValue iterOp) {
+  /*
+   * void addIterOperands(CompiledValue iterOps) { this.iterOperands = iterOps; }
+   */
+  private RangeJunction(AbstractGroupOrRangeJunction oldGJ, boolean completeExpansion,
+      RuntimeIterator indpnds[], CompiledValue iterOp) {
-  AbstractGroupOrRangeJunction recreateFromOld(boolean completeExpansion,
-      RuntimeIterator indpnds[], CompiledValue iterOp) {
+  AbstractGroupOrRangeJunction recreateFromOld(boolean completeExpansion, RuntimeIterator indpnds[],
+      CompiledValue iterOp) {
-  AbstractGroupOrRangeJunction createNewOfSameType(int operator,
-      RuntimeIterator[] indpndntItr, boolean isCompleteExpansion,
-      CompiledValue[] operands) {
-    return new RangeJunction(operator, indpndntItr, isCompleteExpansion,
-        operands);
+  AbstractGroupOrRangeJunction createNewOfSameType(int operator, RuntimeIterator[] indpndntItr,
+      boolean isCompleteExpansion, CompiledValue[] operands) {
+    return new RangeJunction(operator, indpndntItr, isCompleteExpansion, operands);
-  public PlanInfo getPlanInfo(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  public PlanInfo getPlanInfo(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-     * This function would be called only if the RangeJunction is a part of
-     * GroupJunction.It would be invoked in the organized operands method of
-     * GroupJunction. In such case it is guaranteed that all the operands are
-     * the filter operand using the same index. In such case there is zero
-     * possibility o first iterator being either an iter operand or a constant.
-     * As those types of Operands would be part of Group Junction
+     * This function would be called only if the RangeJunction is a part of GroupJunction.It would
+     * be invoked in the organized operands method of GroupJunction. In such case it is guaranteed
+     * that all the operands are the filter operand using the same index. In such case there is zero
+     * possibility o first iterator being either an iter operand or a constant. As those types of
+     * Operands would be part of Group Junction
-  
-  public boolean isConditioningNeededForIndex(RuntimeIterator independentIter, ExecutionContext context,  boolean completeExpnsNeeded) throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+
+  public boolean isConditioningNeededForIndex(RuntimeIterator independentIter,
+      ExecutionContext context, boolean completeExpnsNeeded)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-  
+
-  
-  public boolean isBetterFilter(Filter comparedTo, ExecutionContext context, final int thisSize) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException 
-  {
-    //If the current filter is equality & comparedTo filter is also equality based , then 
+
+  public boolean isBetterFilter(Filter comparedTo, ExecutionContext context, final int thisSize)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
+    // If the current filter is equality & comparedTo filter is also equality based , then
-   
-    //Go with the lowest cost when hint is used.  
-    if (context instanceof QueryExecutionContext && ((QueryExecutionContext)context).hasHints()) {
+
+    // Go with the lowest cost when hint is used.
+    if (context instanceof QueryExecutionContext && ((QueryExecutionContext) context).hasHints()) {
-    
-    int thatOperator = comparedTo.getOperator() ;    
-    switch(thatOperator) {
-        case TOK_EQ:        
-           isThisBetter = false;
-           break;
-        case TOK_NE:
-        case TOK_NE_ALT:
-          //Give preference to Range
-          break;
-        case LITERAL_and:
-         //Asif: What to do? Let current be the better one for the want of better estimation
-         break;
-        case TOK_LE:
-        case TOK_LT:
-        case TOK_GE:
-        case TOK_GT:
-          //Give preference to this rather than single condition inequalities as a rangejunction
-          //would possibly be bounded resulting in lesser values
-          break;
-        default :
-            throw  new IllegalArgumentException("The operator type ="+ thatOperator + " is unknown");
-    }          
-      
+
+    int thatOperator = comparedTo.getOperator();
+    switch (thatOperator) {
+      case TOK_EQ:
+        isThisBetter = false;
+        break;
+      case TOK_NE:
+      case TOK_NE_ALT:
+        // Give preference to Range
+        break;
+      case LITERAL_and:
+        // Asif: What to do? Let current be the better one for the want of better estimation
+        break;
+      case TOK_LE:
+      case TOK_LT:
+      case TOK_GE:
+      case TOK_GT:
+        // Give preference to this rather than single condition inequalities as a rangejunction
+        // would possibly be bounded resulting in lesser values
+        break;
+      default:
+        throw new IllegalArgumentException("The operator type =" + thatOperator + " is unknown");
+    }
+
-   * Segregates the operands of the RangeJunction into iter evaluatable and
-   * filter evaluatable.
+   * Segregates the operands of the RangeJunction into iter evaluatable and filter evaluatable.
-  OrganizedOperands organizeOperands(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  OrganizedOperands organizeOperands(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    }
-    else {
+    } else {
-        LocalizedStrings.RangeJunction_IN_THE_CASE_OF_AN_OR_JUNCTION_A_RANGEJUNCTION_SHOULD_NOT_BE_FORMED_FOR_NOW.toLocalizedString());
+          LocalizedStrings.RangeJunction_IN_THE_CASE_OF_AN_OR_JUNCTION_A_RANGEJUNCTION_SHOULD_NOT_BE_FORMED_FOR_NOW
+              .toLocalizedString());
-   * For the filter evaluatable conditions , it creates the appropriate
-   * JunctionEvaluator ( NotEqualConditionEvaluator or SingleCondnEvaluator or
-   * DoubleCondnRangeJunctionEvaluator ). The junction Evaluator itself is
-   * filter evaluatable. The operands which are of type != null , == null , !=
-   * undefined, == undefined are left as it is & are not combined into a
-   * Junction Evaluator. Thus the organized operand of RangeJunction may created
-   * atmost one Condition Evaluator, will retain the operands containing null
-   * ,undefined conditions. In case there is a equality condition , then it may
-   * result in a filter having just that condition assuming other conditions
-   * satisfy the equality. In case it turns out that the conditions are mutually
-   * exclusive then the organized operand would just contain a single filter
-   * evaluatable CompiledLiteral (false) ( indicating empty resultset).
+   * For the filter evaluatable conditions , it creates the appropriate JunctionEvaluator (
+   * NotEqualConditionEvaluator or SingleCondnEvaluator or DoubleCondnRangeJunctionEvaluator ). The
+   * junction Evaluator itself is filter evaluatable. The operands which are of type != null , ==
+   * null , != undefined, == undefined are left as it is & are not combined into a Junction
+   * Evaluator. Thus the organized operand of RangeJunction may created atmost one Condition
+   * Evaluator, will retain the operands containing null ,undefined conditions. In case there is a
+   * equality condition , then it may result in a filter having just that condition assuming other
+   * conditions satisfy the equality. In case it turns out that the conditions are mutually
+   * exclusive then the organized operand would just contain a single filter evaluatable
+   * CompiledLiteral (false) ( indicating empty resultset).
-  private OrganizedOperands organizeOperandsForAndJunction(
-      ExecutionContext context) throws AmbiguousNameException,
-      FunctionDomainException, TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
+  private OrganizedOperands organizeOperandsForAndJunction(ExecutionContext context)
+      throws AmbiguousNameException, FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
-        Indexable cc = (Indexable)operand;
+        Indexable cc = (Indexable) operand;
-        CompiledValue ccKey = ((CompiledComparison)cc).getKey(context);
+        CompiledValue ccKey = ((CompiledComparison) cc).getKey(context);
-        int operator = ((CompiledComparison)cc).reflectOnOperator(ccKey);
+        int operator = ((CompiledComparison) cc).reflectOnOperator(ccKey);
-          emptyResults = !isConditionSatisfied(equalCondKey, evaluatedCCKey,
-              operator);
+          emptyResults = !isConditionSatisfied(equalCondKey, evaluatedCCKey, operator);
-          }
-          else {
+          } else {
-        case TOK_EQ:
-          possibleRangeFilter = false;
-          equalCondnOperand = (CompiledComparison)cc;
-          equalCondKey = evaluatedCCKey;
-          break;
-        case TOK_NE:
-        case TOK_NE_ALT:
-          possibleRangeFilter = true;
-          if (notEqualTypeKeys == null) {
-            notEqualTypeKeys = new HashSet(_operands.length);
-          }
-          evaluatedCCKey = TypeUtils.indexKeyFor(evaluatedCCKey);
-          notEqualTypeKeys.add(evaluatedCCKey);
-          break;
-        case TOK_GE:
-        case TOK_GT:
-          possibleRangeFilter = true;
-          if (greaterCondnOperand == null) {
-            greaterCondnOperand = (CompiledComparison)cc;
-            greaterCondnKey = evaluatedCCKey;
-            greaterCondnOp = operator;
-          }
-          else {
-            if (isConditionSatisfied(evaluatedCCKey, greaterCondnKey,
-                greaterCondnOp)) {
+          case TOK_EQ:
+            possibleRangeFilter = false;
+            equalCondnOperand = (CompiledComparison) cc;
+            equalCondKey = evaluatedCCKey;
+            break;
+          case TOK_NE:
+          case TOK_NE_ALT:
+            possibleRangeFilter = true;
+            if (notEqualTypeKeys == null) {
+              notEqualTypeKeys = new HashSet(_operands.length);
+            }
+            evaluatedCCKey = TypeUtils.indexKeyFor(evaluatedCCKey);
+            notEqualTypeKeys.add(evaluatedCCKey);
+            break;
+          case TOK_GE:
+          case TOK_GT:
+            possibleRangeFilter = true;
+            if (greaterCondnOperand == null) {
+              greaterCondnOperand = (CompiledComparison) cc;
-              greaterCondnOperand = (CompiledComparison)cc;
+            } else {
+              if (isConditionSatisfied(evaluatedCCKey, greaterCondnKey, greaterCondnOp)) {
+                greaterCondnKey = evaluatedCCKey;
+                greaterCondnOperand = (CompiledComparison) cc;
+                greaterCondnOp = operator;
+              }
-          }
-          break;
-        case TOK_LE:
-        case TOK_LT:
-          // Asif: if there exists a previous equal Operand & current
-          // condition's value is greater than the equal operand's value, it
-          // will be empty results
-          possibleRangeFilter = true;
-          if (lessCondnOperand == null) {
-            lessCondnOperand = (CompiledComparison)cc;
-            lessCondnKey = evaluatedCCKey;
-            lessCondnOp = operator;
-          }
-          else {
-            if (isConditionSatisfied(evaluatedCCKey, lessCondnKey, lessCondnOp)) {
+            break;
+          case TOK_LE:
+          case TOK_LT:
+            // Asif: if there exists a previous equal Operand & current
+            // condition's value is greater than the equal operand's value, it
+            // will be empty results
+            possibleRangeFilter = true;
+            if (lessCondnOperand == null) {
+              lessCondnOperand = (CompiledComparison) cc;
-              lessCondnOperand = (CompiledComparison)cc;
+            } else {
+              if (isConditionSatisfied(evaluatedCCKey, lessCondnKey, lessCondnOp)) {
+                lessCondnKey = evaluatedCCKey;
+                lessCondnOperand = (CompiledComparison) cc;
+                lessCondnOp = operator;
+              }
-          }
-          break;
+            break;
-      }
-      else if (!_operands[i].isDependentOnCurrentScope(context)) {
+      } else if (!_operands[i].isDependentOnCurrentScope(context)) {
-        Support
-            .assertionFailed("An independentoperand should not ever be present as operand inside a GroupJunction as it should always be present only in CompiledJunction");
-      }
-      else {
+        Support.assertionFailed(
+            "An independentoperand should not ever be present as operand inside a GroupJunction as it should always be present only in CompiledJunction");
+      } else {
-            && !this.isConditionSatisfied(equalCondKey, lessCondnKey,
-                lessCondnOp)) {
+            && !this.isConditionSatisfied(equalCondKey, lessCondnKey, lessCondnOp)) {
-        }
-        else if (greaterCondnOperand != null
-            && !this.isConditionSatisfied(equalCondKey, greaterCondnKey,
-                greaterCondnOp)) {
+        } else if (greaterCondnOperand != null
+            && !this.isConditionSatisfied(equalCondKey, greaterCondnKey, greaterCondnOp)) {
-        }
-        else if (notEqualTypeKeys != null) {
+        } else if (notEqualTypeKeys != null) {
-            emptyResults = !this.isConditionSatisfied(equalCondKey, itr.next(),
-                OQLLexerTokenTypes.TOK_NE);
+            emptyResults =
+                !this.isConditionSatisfied(equalCondKey, itr.next(), OQLLexerTokenTypes.TOK_NE);
-      }
-      else if (possibleRangeFilter) {
+      } else if (possibleRangeFilter) {
-          emptyResults = !checkForRangeBoundednessAndTrimNotEqualKeyset(
-              notEqualTypeKeys, lessCondnKey, lessCondnOp, greaterCondnKey,
-              greaterCondnOp);
+          emptyResults = !checkForRangeBoundednessAndTrimNotEqualKeyset(notEqualTypeKeys,
+              lessCondnKey, lessCondnOp, greaterCondnKey, greaterCondnOp);
-            filter = new DoubleCondnRangeJunctionEvaluator(lessCondnOp,
-                lessCondnKey, greaterCondnOp, greaterCondnKey,
-                (notEqualTypeKeys == null || notEqualTypeKeys.isEmpty()) ? null
-                    : notEqualTypeKeys, indxInfo);
+            filter = new DoubleCondnRangeJunctionEvaluator(lessCondnOp, lessCondnKey,
+                greaterCondnOp, greaterCondnKey,
+                (notEqualTypeKeys == null || notEqualTypeKeys.isEmpty()) ? null : notEqualTypeKeys,
+                indxInfo);
-        }
-        else if (greaterCondnOperand != null) {
-          filter = generateSingleCondnEvaluatorIfRequired(notEqualTypeKeys,
-              greaterCondnOperand, greaterCondnOp, greaterCondnKey, indxInfo);
-        }
-        else if (lessCondnOperand != null) {
-          filter = generateSingleCondnEvaluatorIfRequired(notEqualTypeKeys,
-              lessCondnOperand, lessCondnOp, lessCondnKey, indxInfo);
-        }
-        else {
+        } else if (greaterCondnOperand != null) {
+          filter = generateSingleCondnEvaluatorIfRequired(notEqualTypeKeys, greaterCondnOperand,
+              greaterCondnOp, greaterCondnKey, indxInfo);
+        } else if (lessCondnOperand != null) {
+          filter = generateSingleCondnEvaluatorIfRequired(notEqualTypeKeys, lessCondnOperand,
+              lessCondnOp, lessCondnKey, indxInfo);
+        } else {
-      }
-      else if (filter != null) {
+      } else if (filter != null) {
-    }
-    else {
+    } else {
-    
-    //If no hints were provided, we continue with our single index solution
-    if (!(context instanceof QueryExecutionContext) || !((QueryExecutionContext)context).hasMultiHints()) {
+
+    // If no hints were provided, we continue with our single index solution
+    if (!(context instanceof QueryExecutionContext)
+        || !((QueryExecutionContext) context).hasMultiHints()) {
-      if(getIterOperands() != null) {
+      if (getIterOperands() != null) {
-        // for the same operand. The protGetPlanInfo in CompiledLike could return evalAsFilter 
+        // for the same operand. The protGetPlanInfo in CompiledLike could return evalAsFilter
-        // Hence the evalOperands could contain  CompiledComparisons more than number of indexes.
-        
-        //Support.Assert(evalOperands.size() == evalCount);
+        // Hence the evalOperands could contain CompiledComparisons more than number of indexes.
+
+        // Support.Assert(evalOperands.size() == evalCount);
-    return ((Boolean)TypeUtils.compare(key1, key2, operator)).booleanValue();
+    return ((Boolean) TypeUtils.compare(key1, key2, operator)).booleanValue();
-   * Checks if the Range junction containing less & greater type of inequalities
-   * has a lower and upper bound , in the sense that they do not represent a
-   * mutually exclusive condition like a> 10 and a <9 etc. If the condition is
-   * bounded in nature, it further checks if the not equal type keys fall in the
-   * bounded range , else it removes it from the Not Equal Keys set
+   * Checks if the Range junction containing less & greater type of inequalities has a lower and
+   * upper bound , in the sense that they do not represent a mutually exclusive condition like a> 10
+   * and a <9 etc. If the condition is bounded in nature, it further checks if the not equal type
+   * keys fall in the bounded range , else it removes it from the Not Equal Keys set
-   * @param notEqualKeys
-   *                Set containing keys of operands having 'Not Equal' (!=) type
-   *                conditions
-   * @param lessCondnKey
-   *                Key of the 'Less' condition operand
-   * @param lessOperator
-   *                Type of 'less' operator ( < or <=)
-   * @param greaterCondnKey
-   *                Key of the 'greater' condition operand
-   * @param greaterCondnOp
-   *                Type of 'greater' operator ( > or >=)
+   * @param notEqualKeys Set containing keys of operands having 'Not Equal' (!=) type conditions
+   * @param lessCondnKey Key of the 'Less' condition operand
+   * @param lessOperator Type of 'less' operator ( < or <=)
+   * @param greaterCondnKey Key of the 'greater' condition operand
+   * @param greaterCondnOp Type of 'greater' operator ( > or >=)
-  private boolean checkForRangeBoundednessAndTrimNotEqualKeyset(
-      Set notEqualKeys, Object lessCondnKey, int lessOperator,
-      Object greaterCondnKey, int greaterCondnOp) throws TypeMismatchException {
+  private boolean checkForRangeBoundednessAndTrimNotEqualKeyset(Set notEqualKeys,
+      Object lessCondnKey, int lessOperator, Object greaterCondnKey, int greaterCondnOp)
+      throws TypeMismatchException {
-          if (!this
-              .isConditionSatisfied(neKey, greaterCondnKey, greaterCondnOp)
+          if (!this.isConditionSatisfied(neKey, greaterCondnKey, greaterCondnOp)
-    }
-    else {
+    } else {
-   * Creates a Filter of type SingleCondnEvaluator if there exists atleast one
-   * key of type "NOT EQUAL" which satisfies the 'less' or 'greater' type
-   * operand. Otherwise the Filter is nothing but the CompiledComparison
-   * representing the 'less' or 'greater' inequality
+   * Creates a Filter of type SingleCondnEvaluator if there exists atleast one key of type "NOT
+   * EQUAL" which satisfies the 'less' or 'greater' type operand. Otherwise the Filter is nothing
+   * but the CompiledComparison representing the 'less' or 'greater' inequality
-   * @param notEqualKeys
-   *                Set containing NotEqual type Keys
-   * @param operand
-   *                CompiledValue representing the 'Less' or 'Greater' operand
-   * @param operator
-   *                Type of 'Less' or 'Greater' operand
-   * @param condnKey
-   *                The Key corresponding to the Operand representing the 'Less'
-   *                or 'Greater' inequality
-   * @param indxInfo
-   *                The IndexInfo object for this RangeJunction
-   * @return Filter object of type CompiledComparison or
-   *         RangeJunction.SingleCondnEvaluator object
+   * @param notEqualKeys Set containing NotEqual type Keys
+   * @param operand CompiledValue representing the 'Less' or 'Greater' operand
+   * @param operator Type of 'Less' or 'Greater' operand
+   * @param condnKey The Key corresponding to the Operand representing the 'Less' or 'Greater'
+   *        inequality
+   * @param indxInfo The IndexInfo object for this RangeJunction
+   * @return Filter object of type CompiledComparison or RangeJunction.SingleCondnEvaluator object
-  private Filter generateSingleCondnEvaluatorIfRequired(Set notEqualKeys,
-      CompiledValue operand, int operator, Object condnKey, IndexInfo indxInfo)
-      throws TypeMismatchException {
+  private Filter generateSingleCondnEvaluatorIfRequired(Set notEqualKeys, CompiledValue operand,
+      int operator, Object condnKey, IndexInfo indxInfo) throws TypeMismatchException {
-        if (!((Boolean)TypeUtils.compare(neKey, condnKey, operator))
-            .booleanValue()) {
+        if (!((Boolean) TypeUtils.compare(neKey, condnKey, operator)).booleanValue()) {
-    rangeFilter = (notEqualKeys != null) ? new SingleCondnEvaluator(operator,
-        condnKey, notEqualKeys, indxInfo) : (Filter)operand;
+    rangeFilter = (notEqualKeys != null)
+        ? new SingleCondnEvaluator(operator, condnKey, notEqualKeys, indxInfo) : (Filter) operand;
-  public Object evaluate(ExecutionContext context)
-  throws FunctionDomainException, TypeMismatchException,
-  NameResolutionException, QueryInvocationTargetException {
+  public Object evaluate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-          + r.getClass().getName() + "'");
+              + r.getClass().getName() + "'");
-      if (ri == null || ri == QueryService.UNDEFINED
-          || r == QueryService.UNDEFINED) {
+      if (ri == null || ri == QueryService.UNDEFINED || r == QueryService.UNDEFINED) {
-            + ri.getClass().getName() + "'");
+                + ri.getClass().getName() + "'");
-      r = new Boolean(((Boolean) r).booleanValue()
-          && ((Boolean) ri).booleanValue());
+      r = new Boolean(((Boolean) r).booleanValue() && ((Boolean) ri).booleanValue());
-  public int getSizeEstimate(ExecutionContext context)
-  {
-    //TODO:Asif:Try to estimate better
-     return RANGE_SIZE_ESTIMATE;
+  public int getSizeEstimate(ExecutionContext context) {
+    // TODO:Asif:Try to estimate better
+    return RANGE_SIZE_ESTIMATE;
-   * private organizeOperandsForORJunction() {
-   *  }
+   * private organizeOperandsForORJunction() { }
-   * Test method which checks if the Filter operand is of type
-   * SingleCondnEvaluator
+   * Test method which checks if the Filter operand is of type SingleCondnEvaluator
-   * Test method which checks if the Filter operand is of type
-   * NotEqualConditionEvaluator
+   * Test method which checks if the Filter operand is of type NotEqualConditionEvaluator
-   * Test method which checks if the Filter operand is of type
-   * DoubleCondnRangeJunctionEvaluator
+   * Test method which checks if the Filter operand is of type DoubleCondnRangeJunctionEvaluator
-   * @param o
-   *                Object of type NotEqualConditionEvaluator from which the set
-   *                containing the keys for removal need to be retrieved
+   * @param o Object of type NotEqualConditionEvaluator from which the set containing the keys for
+   *        removal need to be retrieved
-      if (((NotEqualConditionEvaluator)o).notEqualTypeKeys == null) {
+      if (((NotEqualConditionEvaluator) o).notEqualTypeKeys == null) {
-      return Collections
-          .unmodifiableSet(((NotEqualConditionEvaluator)o).notEqualTypeKeys);
-    }
-    else {
+      return Collections.unmodifiableSet(((NotEqualConditionEvaluator) o).notEqualTypeKeys);
+    } else {
-          LocalizedStrings.
-            RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
-            .toLocalizedString());
+          LocalizedStrings.RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
+              .toLocalizedString());
-   * @param o
-   *                Object of type SingleCondnEvaluator from which the set
-   *                containing the keys for removal need to be retrieved
+   * @param o Object of type SingleCondnEvaluator from which the set containing the keys for removal
+   *        need to be retrieved
-      return ((SingleCondnEvaluator)o).condnOp;
-    }
-    else {
+      return ((SingleCondnEvaluator) o).condnOp;
+    } else {
-          LocalizedStrings.
-            RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
-            .toLocalizedString());
+          LocalizedStrings.RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
+              .toLocalizedString());
-   * Test function which retrieves the evaluated Key for a SingleCondnEvaluator
-   * operator
+   * Test function which retrieves the evaluated Key for a SingleCondnEvaluator operator
-   * @param o
-   *                Object of type SingleCondnEvaluator from which the set
-   *                containing the keys for removal need to be retrieved
+   * @param o Object of type SingleCondnEvaluator from which the set containing the keys for removal
+   *        need to be retrieved
-      return ((SingleCondnEvaluator)o).condnKey;
-    }
-    else {
+      return ((SingleCondnEvaluator) o).condnKey;
+    } else {
-          LocalizedStrings.
-            RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
-            .toLocalizedString());
+          LocalizedStrings.RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
+              .toLocalizedString());
-   * Test function which retrieves the LESS type evaluated Key for a
-   * DoubleCondnEvaluator operator
+   * Test function which retrieves the LESS type evaluated Key for a DoubleCondnEvaluator operator
-   * @param o
-   *                Object of type DoubleCondnEvaluator
+   * @param o Object of type DoubleCondnEvaluator
-      return ((DoubleCondnRangeJunctionEvaluator)o).lessCondnKey;
-    }
-    else {
+      return ((DoubleCondnRangeJunctionEvaluator) o).lessCondnKey;
+    } else {
-          LocalizedStrings.
-            RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
-            .toLocalizedString());
+          LocalizedStrings.RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
+              .toLocalizedString());
-   * Test function which retrieves the GREATER type evaluated Key for a
-   * DoubleCondnEvaluator operator
+   * Test function which retrieves the GREATER type evaluated Key for a DoubleCondnEvaluator
+   * operator
-   * @param o
-   *                Object of type DoubleCondnEvaluator
+   * @param o Object of type DoubleCondnEvaluator
-      return ((DoubleCondnRangeJunctionEvaluator)o).greaterCondnKey;
-    }
-    else {
+      return ((DoubleCondnRangeJunctionEvaluator) o).greaterCondnKey;
+    } else {
-          LocalizedStrings.
-            RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
-            .toLocalizedString());
+          LocalizedStrings.RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
+              .toLocalizedString());
-   * @param o
-   *                Object of type DoubleCondnEvaluator
+   * @param o Object of type DoubleCondnEvaluator
-      return ((DoubleCondnRangeJunctionEvaluator)o).lessCondnOp;
-    }
-    else {
+      return ((DoubleCondnRangeJunctionEvaluator) o).lessCondnOp;
+    } else {
-          LocalizedStrings.
-            RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
-            .toLocalizedString());
+          LocalizedStrings.RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
+              .toLocalizedString());
-   * @param o
-   *                Object of type DoubleCondnEvaluator
+   * @param o Object of type DoubleCondnEvaluator
-      return ((DoubleCondnRangeJunctionEvaluator)o).greaterCondnOp;
-    }
-    else {
+      return ((DoubleCondnRangeJunctionEvaluator) o).greaterCondnOp;
+    } else {
-          LocalizedStrings.
-            RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
-            .toLocalizedString());
+          LocalizedStrings.RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
+              .toLocalizedString());
-   * Test function which retrieves the underlying Index for a
-   * NotEqualConditionEvaluator operator
+   * Test function which retrieves the underlying Index for a NotEqualConditionEvaluator operator
-   * @param o
-   *                Object of type NotEqualConditionEvaluator from which the
-   *                index needs to be retrieved
+   * @param o Object of type NotEqualConditionEvaluator from which the index needs to be retrieved
-      return ((NotEqualConditionEvaluator)o).indxInfo._index;
-    }
-    else {
+      return ((NotEqualConditionEvaluator) o).indxInfo._index;
+    } else {
-          LocalizedStrings.
-            RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
-            .toLocalizedString());
+          LocalizedStrings.RangeJunction_THE_OBJECT_IS_NOT_OF_TYPE_NOTEQUALCONDITIONEVALUATOR
+              .toLocalizedString());
-   * Filter Object created by the RangeJunction on invocation of its
-   * organizedOperands method. The object of this class will be created only if
-   * RangeJunction contains more than one 'NOT EQUAL' ( != ) type conditions (
-   * apart from conditions having null or undefined as key). This class is also
-   * extended by SingleCondnEvaluator and DoubleCondnRangeJunctionEvaluator
+   * Filter Object created by the RangeJunction on invocation of its organizedOperands method. The
+   * object of this class will be created only if RangeJunction contains more than one 'NOT EQUAL' (
+   * != ) type conditions ( apart from conditions having null or undefined as key). This class is
+   * also extended by SingleCondnEvaluator and DoubleCondnRangeJunctionEvaluator
-  private static class NotEqualConditionEvaluator extends AbstractCompiledValue
-      implements Filter {
+  private static class NotEqualConditionEvaluator extends AbstractCompiledValue implements Filter {
-     * @param notEqualTypeKeys
-     *                java.utils.Set object containing the Keys of the 'NOT
-     *                EQUAL' type conditions ( a != 3 and a !=5) For
-     *                DoubleCondnRangeJunctionEvaluator , this may be null
-     * @param indxInfo
-     *                The IndexInfo object corresponding to the RangeJunction
+     * @param notEqualTypeKeys java.utils.Set object containing the Keys of the 'NOT EQUAL' type
+     *        conditions ( a != 3 and a !=5) For DoubleCondnRangeJunctionEvaluator , this may be
+     *        null
+     * @param indxInfo The IndexInfo object corresponding to the RangeJunction
-    public SelectResults filterEvaluate(ExecutionContext context,
-        SelectResults iterationLimit) throws FunctionDomainException,
-        TypeMismatchException, NameResolutionException,
+    public SelectResults filterEvaluate(ExecutionContext context, SelectResults iterationLimit)
+        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-    public SelectResults filterEvaluate(ExecutionContext context,
-        SelectResults iterationLimit, boolean completeExpansionNeeded,
-        CompiledValue iterOperands, RuntimeIterator[] indpndntItrs, boolean isIntersection,boolean conditioningNeeded, boolean evalProj)
-        throws FunctionDomainException, TypeMismatchException,
-        NameResolutionException, QueryInvocationTargetException {
+    public SelectResults filterEvaluate(ExecutionContext context, SelectResults iterationLimit,
+        boolean completeExpansionNeeded, CompiledValue iterOperands, RuntimeIterator[] indpndntItrs,
+        boolean isIntersection, boolean conditioningNeeded, boolean evalProj)
+        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+        QueryInvocationTargetException {
-      Boolean orderByClause = (Boolean)context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-      boolean useLinkedDataStructure = false;   
+      Boolean orderByClause = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
+      boolean useLinkedDataStructure = false;
-      if(orderByClause != null && orderByClause.booleanValue()) {
-        List orderByAttrs = (List)context.cacheGet(CompiledValue.ORDERBY_ATTRIB);        
-        useLinkedDataStructure =orderByAttrs.size()==1;
-        nullValuesAtStart = !((CompiledSortCriterion)orderByAttrs.get(0)).getCriterion();
+      if (orderByClause != null && orderByClause.booleanValue()) {
+        List orderByAttrs = (List) context.cacheGet(CompiledValue.ORDERBY_ATTRIB);
+        useLinkedDataStructure = orderByAttrs.size() == 1;
+        nullValuesAtStart = !((CompiledSortCriterion) orderByAttrs.get(0)).getCriterion();
-      
+
-          context.getCache().getLogger().fine(
-            "StructType resultType.class=" + resultType.getClass().getName());
+          context.getCache().getLogger()
+              .fine("StructType resultType.class=" + resultType.getClass().getName());
-          set = context.isDistinct() ? new LinkedStructSet((StructTypeImpl)resultType) 
-          : new SortedResultsBag<Struct>((StructTypeImpl)resultType, nullValuesAtStart);
+          set = context.isDistinct() ? new LinkedStructSet((StructTypeImpl) resultType)
+              : new SortedResultsBag<Struct>((StructTypeImpl) resultType, nullValuesAtStart);
-          set = QueryUtils.createStructCollection(context, (StructTypeImpl)resultType) ;
+          set = QueryUtils.createStructCollection(context, (StructTypeImpl) resultType);
-        indexFieldsSize = ((StructTypeImpl)resultType).getFieldNames().length;
-      }
-      else {
+        indexFieldsSize = ((StructTypeImpl) resultType).getFieldNames().length;
+      } else {
-          context.getCache().getLogger().fine(
-            "non-StructType resultType.class="
-                + resultType.getClass().getName());
+          context.getCache().getLogger()
+              .fine("non-StructType resultType.class=" + resultType.getClass().getName());
-          set = context.isDistinct() ? new LinkedResultSet(resultType) : new SortedResultsBag(resultType,
-              nullValuesAtStart); 
+          set = context.isDistinct() ? new LinkedResultSet(resultType)
+              : new SortedResultsBag(resultType, nullValuesAtStart);
-       * Asif : First obtain the match level of index resultset. If the match
-       * level happens to be zero , this implies that we just have to change the
-       * StructType ( again if only the Index resultset is a StructBag). If the
-       * match level is zero & expand to to top level flag is true & iff the
-       * total no. of iterators in current scope is greater than the no. of
-       * fields in StructBag , then only we need to do any expansion.
+       * Asif : First obtain the match level of index resultset. If the match level happens to be
+       * zero , this implies that we just have to change the StructType ( again if only the Index
+       * resultset is a StructBag). If the match level is zero & expand to to top level flag is true
+       * & iff the total no. of iterators in current scope is greater than the no. of fields in
+       * StructBag , then only we need to do any expansion.
-        observer.beforeIndexLookup(this.indxInfo._index,
-            OQLLexerTokenTypes.TOK_NE, this.notEqualTypeKeys);
+        observer.beforeIndexLookup(this.indxInfo._index, OQLLexerTokenTypes.TOK_NE,
+            this.notEqualTypeKeys);
-      }
-      finally {
+      } finally {
-      return QueryUtils.getconditionedIndexResults(set, this.indxInfo, context,
-          indexFieldsSize, completeExpansionNeeded, iterOperands, indpndntItrs);
+      return QueryUtils.getconditionedIndexResults(set, this.indxInfo, context, indexFieldsSize,
+          completeExpansionNeeded, iterOperands, indpndntItrs);
-        SelectResults intermediateResults) throws FunctionDomainException,
-        TypeMismatchException, NameResolutionException,
-        QueryInvocationTargetException {
+        SelectResults intermediateResults) throws FunctionDomainException, TypeMismatchException,
+        NameResolutionException, QueryInvocationTargetException {
-    public Object evaluate(ExecutionContext context) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-			Object evaluatedPath = this.indxInfo._path.evaluate(context); 
-			return evaluate(context,evaluatedPath);
+    public Object evaluate(ExecutionContext context) throws FunctionDomainException,
+        TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+      Object evaluatedPath = this.indxInfo._path.evaluate(context);
+      return evaluate(context, evaluatedPath);
-    
-    public boolean isConditioningNeededForIndex(RuntimeIterator independentIter, ExecutionContext context,  boolean completeExpnsNeeded) throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+
+    public boolean isConditioningNeededForIndex(RuntimeIterator independentIter,
+        ExecutionContext context, boolean completeExpnsNeeded)
+        throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-    public Object evaluate(ExecutionContext context, Object evaluatedPath) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {		 
-		Iterator itr = this.notEqualTypeKeys.iterator();
-		while(itr.hasNext()) {
-			Object  val = itr.next();
-			Object result = TypeUtils.compare(evaluatedPath, val, TOK_NE);
-			if( result instanceof Boolean) {
-			  if( !((Boolean)result).booleanValue()) {
-				  return Boolean.FALSE;
-			  }
-			}else {
-				throw new TypeMismatchException("NotEqualConditionEvaluator should evaluate to boolean type");
-			}
-		}
-		return Boolean.TRUE;
+    public Object evaluate(ExecutionContext context, Object evaluatedPath)
+        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+        QueryInvocationTargetException {
+      Iterator itr = this.notEqualTypeKeys.iterator();
+      while (itr.hasNext()) {
+        Object val = itr.next();
+        Object result = TypeUtils.compare(evaluatedPath, val, TOK_NE);
+        if (result instanceof Boolean) {
+          if (!((Boolean) result).booleanValue()) {
+            return Boolean.FALSE;
+          }
+        } else {
+          throw new TypeMismatchException(
+              "NotEqualConditionEvaluator should evaluate to boolean type");
+        }
+      }
+      return Boolean.TRUE;
+
-  	  return RANGE_SIZE_ESTIMATE;
+      return RANGE_SIZE_ESTIMATE;
+
-    public int getOperator()
-    {
+    public int getOperator() {
-    public boolean isBetterFilter(Filter comparedTo, ExecutionContext context, int thisSize) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException
-    {
-      //If the current filter is equality & comparedTo filter is also equality based , then 
+    public boolean isBetterFilter(Filter comparedTo, ExecutionContext context, int thisSize)
+        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+        QueryInvocationTargetException {
+      // If the current filter is equality & comparedTo filter is also equality based , then
-     
-      int thatOperator = comparedTo.getOperator() ;
-      
-      //Go with the lowest cost when hint is used.  
-      if (context instanceof QueryExecutionContext && ((QueryExecutionContext)context).hasHints()) {
+
+      int thatOperator = comparedTo.getOperator();
+
+      // Go with the lowest cost when hint is used.
+      if (context instanceof QueryExecutionContext
+          && ((QueryExecutionContext) context).hasHints()) {
-      
-      switch(thatOperator) {
-          case TOK_EQ:        
-             isThisBetter = false;
-             break;
-          case TOK_NE:
-          case TOK_NE_ALT:
-            //Give preference to Range
-            break;        
-          default :
-              throw  new IllegalArgumentException("The operator type ="+ thatOperator + " is unknown");
-      }          
-        
+
+      switch (thatOperator) {
+        case TOK_EQ:
+          isThisBetter = false;
+          break;
+        case TOK_NE:
+        case TOK_NE_ALT:
+          // Give preference to Range
+          break;
+        default:
+          throw new IllegalArgumentException("The operator type =" + thatOperator + " is unknown");
+      }
+
-   * Filter object of this type gets created if there exists atleast one "NOT
-   * EQUAL" type condition and a single condition containing an inequality of
-   * type 'Less' or 'Greater'. The Where clause may actually contain multiple
-   * 'Less' type inequality or multiple 'Greater' type inequality ( though not
-   * both 'Less' and 'Greater' together). The RangeJunction will identify the
-   * most specific inequality for the AND junction. Thus if something like a > 7
-   * and a >=6 , will be sufficiently represented by a > 7
+   * Filter object of this type gets created if there exists atleast one "NOT EQUAL" type condition
+   * and a single condition containing an inequality of type 'Less' or 'Greater'. The Where clause
+   * may actually contain multiple 'Less' type inequality or multiple 'Greater' type inequality (
+   * though not both 'Less' and 'Greater' together). The RangeJunction will identify the most
+   * specific inequality for the AND junction. Thus if something like a > 7 and a >=6 , will be
+   * sufficiently represented by a > 7
-    public SelectResults filterEvaluate(ExecutionContext context,
-        SelectResults iterationLimit) throws FunctionDomainException,
-        TypeMismatchException, NameResolutionException,
+    public SelectResults filterEvaluate(ExecutionContext context, SelectResults iterationLimit)
+        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-     * @param operator
-     *                integer identifying the type of 'Less' or 'Greater'
-     *                inequality
-     * @param key
-     *                Object representing the Key for the inequality
-     * @param notEqualKeys
-     *                Set containing the 'NOT EQUAL' Keys accompanying the
-     *                'Less' or 'Greater' inequality
-     * @param indxInfo
-     *                The IndexInfo object corresponding to the RangeJunction
+     * @param operator integer identifying the type of 'Less' or 'Greater' inequality
+     * @param key Object representing the Key for the inequality
+     * @param notEqualKeys Set containing the 'NOT EQUAL' Keys accompanying the 'Less' or 'Greater'
+     *        inequality
+     * @param indxInfo The IndexInfo object corresponding to the RangeJunction
-    SingleCondnEvaluator(int operator, Object key, Set notEqualKeys,
-        IndexInfo indxInfo) {
+    SingleCondnEvaluator(int operator, Object key, Set notEqualKeys, IndexInfo indxInfo) {
-    public SelectResults filterEvaluate(ExecutionContext context,
-        SelectResults iterationLimit, boolean completeExpansionNeeded,
-        CompiledValue iterOperands, RuntimeIterator[] indpndntItrs,
-        boolean isIntersection,boolean conditioningNeeded, boolean evalProj)
-        throws FunctionDomainException, TypeMismatchException,
-        NameResolutionException, QueryInvocationTargetException {
+    public SelectResults filterEvaluate(ExecutionContext context, SelectResults iterationLimit,
+        boolean completeExpansionNeeded, CompiledValue iterOperands, RuntimeIterator[] indpndntItrs,
+        boolean isIntersection, boolean conditioningNeeded, boolean evalProj)
+        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+        QueryInvocationTargetException {
-      Boolean orderByClause = (Boolean)context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
+      Boolean orderByClause = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-      if(orderByClause != null && orderByClause.booleanValue()) {
-        List orderByAttrs = (List)context.cacheGet(CompiledValue.ORDERBY_ATTRIB);        
-        useLinkedDataStructure =orderByAttrs.size()==1; 
-        nullValuesAtStart = !((CompiledSortCriterion)orderByAttrs.get(0)).getCriterion();
+      if (orderByClause != null && orderByClause.booleanValue()) {
+        List orderByAttrs = (List) context.cacheGet(CompiledValue.ORDERBY_ATTRIB);
+        useLinkedDataStructure = orderByAttrs.size() == 1;
+        nullValuesAtStart = !((CompiledSortCriterion) orderByAttrs.get(0)).getCriterion();
-          context.getCache().getLogger().fine(
-            "StructType resultType.class=" + resultType.getClass().getName());
+          context.getCache().getLogger()
+              .fine("StructType resultType.class=" + resultType.getClass().getName());
-          set = context.isDistinct() ? new LinkedStructSet((StructTypeImpl)resultType) 
-          : new SortedResultsBag<Struct>((StructTypeImpl)resultType, nullValuesAtStart);
+          set = context.isDistinct() ? new LinkedStructSet((StructTypeImpl) resultType)
+              : new SortedResultsBag<Struct>((StructTypeImpl) resultType, nullValuesAtStart);
-          set = QueryUtils.createStructCollection(context, (StructTypeImpl)resultType) ;
+          set = QueryUtils.createStructCollection(context, (StructTypeImpl) resultType);
-        indexFieldsSize = ((StructTypeImpl)resultType).getFieldNames().length;
-      }
-      else {
+        indexFieldsSize = ((StructTypeImpl) resultType).getFieldNames().length;
+      } else {
-          context.getCache().getLogger().fine(
-            "non-StructType resultType.class="
-                + resultType.getClass().getName());
+          context.getCache().getLogger()
+              .fine("non-StructType resultType.class=" + resultType.getClass().getName());
-          set = context.isDistinct() ? new LinkedResultSet(resultType) : new SortedResultsBag(resultType,
-              nullValuesAtStart); 
+          set = context.isDistinct() ? new LinkedResultSet(resultType)
+              : new SortedResultsBag(resultType, nullValuesAtStart);
-       * Asif : First obtain the match level of index resultset. If the match
-       * level happens to be zero , this implies that we just have to change the
-       * StructType ( again if only the Index resultset is a StructBag). If the
-       * match level is zero & expand to to top level flag is true & iff the
-       * total no. of iterators in current scope is greater than the no. of
-       * fields in StructBag , then only we need to do any expansion.
+       * Asif : First obtain the match level of index resultset. If the match level happens to be
+       * zero , this implies that we just have to change the StructType ( again if only the Index
+       * resultset is a StructBag). If the match level is zero & expand to to top level flag is true
+       * & iff the total no. of iterators in current scope is greater than the no. of fields in
+       * StructBag , then only we need to do any expansion.
-        observer.beforeIndexLookup(this.indxInfo._index, this.condnOp,
-            this.condnKey);
+        observer.beforeIndexLookup(this.indxInfo._index, this.condnOp, this.condnKey);
-        this.indxInfo._index.query(this.condnKey, this.condnOp, set,
-            notEqualTypeKeys, context);
-      }
-      finally {
+        this.indxInfo._index.query(this.condnKey, this.condnOp, set, notEqualTypeKeys, context);
+      } finally {
-      return QueryUtils.getconditionedIndexResults(set, this.indxInfo, context,
-          indexFieldsSize, completeExpansionNeeded, iterOperands, indpndntItrs);
+      return QueryUtils.getconditionedIndexResults(set, this.indxInfo, context, indexFieldsSize,
+          completeExpansionNeeded, iterOperands, indpndntItrs);
-    public Object evaluate(ExecutionContext context) throws TypeMismatchException, FunctionDomainException, NameResolutionException, QueryInvocationTargetException {
+    public Object evaluate(ExecutionContext context) throws TypeMismatchException,
+        FunctionDomainException, NameResolutionException, QueryInvocationTargetException {
-      Boolean result =(Boolean) super.evaluate(context,evaluatedPath);
-      if( result.booleanValue()) {
-    	  result = (Boolean)TypeUtils.compare(evaluatedPath, this.condnKey, this.condnOp);
+      Boolean result = (Boolean) super.evaluate(context, evaluatedPath);
+      if (result.booleanValue()) {
+        result = (Boolean) TypeUtils.compare(evaluatedPath, this.condnKey, this.condnOp);
-    
+
-        SelectResults intermediateResults) throws FunctionDomainException,
-        TypeMismatchException, NameResolutionException,
-        QueryInvocationTargetException {
+        SelectResults intermediateResults) throws FunctionDomainException, TypeMismatchException,
+        NameResolutionException, QueryInvocationTargetException {
-   * Filter object of this type gets created if there exists a bounded condition
-   * like a >7 and a > 8 and a< 10 and a <11. The RangeJunction will identify
-   * the most specific inequality of each type for the AND junction. Thus the
-   * conditions a > 8 and a <10 will be used to form the Object of this class.
-   * For this evaluator only, the notEqualTypeKeys present in its super class
-   * may be null ( if there is no 'NOT EQUAL' type condition satisfying the
-   * bounded condition)
+   * Filter object of this type gets created if there exists a bounded condition like a >7 and a > 8
+   * and a< 10 and a <11. The RangeJunction will identify the most specific inequality of each type
+   * for the AND junction. Thus the conditions a > 8 and a <10 will be used to form the Object of
+   * this class. For this evaluator only, the notEqualTypeKeys present in its super class may be
+   * null ( if there is no 'NOT EQUAL' type condition satisfying the bounded condition)
-  private static class DoubleCondnRangeJunctionEvaluator extends
-      NotEqualConditionEvaluator {
+  private static class DoubleCondnRangeJunctionEvaluator extends NotEqualConditionEvaluator {
-     * @param lessCondnOp
-     *                integer identifying the upper bound ( < or <= )
-     * @param lessCondnKey
-     *                Object representing the Upper Bound Key
-     * @param greaterCondnOp
-     *                integer identifying the lower bound ( > or >= )
-     * @param greaterCondnKey
-     *                Object representing the lower Bound Key
-     * @param notEqualTypeKeys
-     *                Set containing the 'NOT EQUAL' Keys accompanying the
-     *                'Less' or 'Greater' inequality
-     * @param indexInfo
-     *                The IndexInfo object corresponding to the RangeJunction
+     * @param lessCondnOp integer identifying the upper bound ( < or <= )
+     * @param lessCondnKey Object representing the Upper Bound Key
+     * @param greaterCondnOp integer identifying the lower bound ( > or >= )
+     * @param greaterCondnKey Object representing the lower Bound Key
+     * @param notEqualTypeKeys Set containing the 'NOT EQUAL' Keys accompanying the 'Less' or
+     *        'Greater' inequality
+     * @param indexInfo The IndexInfo object corresponding to the RangeJunction
-    DoubleCondnRangeJunctionEvaluator(int lessCondnOp, Object lessCondnKey,
-        int greaterCondnOp, Object greaterCondnKey, Set notEqualTypeKeys,
-        IndexInfo indexInfo) {
+    DoubleCondnRangeJunctionEvaluator(int lessCondnOp, Object lessCondnKey, int greaterCondnOp,
+        Object greaterCondnKey, Set notEqualTypeKeys, IndexInfo indexInfo) {
-    public SelectResults filterEvaluate(ExecutionContext context,
-        SelectResults iterationLimit) throws FunctionDomainException,
-        TypeMismatchException, NameResolutionException,
+    public SelectResults filterEvaluate(ExecutionContext context, SelectResults iterationLimit)
+        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-    public SelectResults filterEvaluate(ExecutionContext context,
-        SelectResults iterationLimit, boolean completeExpansionNeeded,
-        CompiledValue iterOperands, RuntimeIterator[] indpndntItrs,
-         boolean isIntersection,boolean conditioningNeeded, boolean evalProj)
-        throws FunctionDomainException, TypeMismatchException,
-        NameResolutionException, QueryInvocationTargetException {
+    public SelectResults filterEvaluate(ExecutionContext context, SelectResults iterationLimit,
+        boolean completeExpansionNeeded, CompiledValue iterOperands, RuntimeIterator[] indpndntItrs,
+        boolean isIntersection, boolean conditioningNeeded, boolean evalProj)
+        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+        QueryInvocationTargetException {
-      Boolean orderByClause = (Boolean)context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
-      boolean useLinkedDataStructure = false; 
+      Boolean orderByClause = (Boolean) context.cacheGet(CompiledValue.CAN_APPLY_ORDER_BY_AT_INDEX);
+      boolean useLinkedDataStructure = false;
-      if(orderByClause != null && orderByClause.booleanValue()) {
-        List orderByAttrs = (List)context.cacheGet(CompiledValue.ORDERBY_ATTRIB);        
-        useLinkedDataStructure =orderByAttrs.size()==1;
-        nullValuesAtStart = !((CompiledSortCriterion)orderByAttrs.get(0)).getCriterion();
+      if (orderByClause != null && orderByClause.booleanValue()) {
+        List orderByAttrs = (List) context.cacheGet(CompiledValue.ORDERBY_ATTRIB);
+        useLinkedDataStructure = orderByAttrs.size() == 1;
+        nullValuesAtStart = !((CompiledSortCriterion) orderByAttrs.get(0)).getCriterion();
-      
+
-          context.getCache().getLogger().fine(
-            "StructType resultType.class=" + resultType.getClass().getName());
-        }
-        if(useLinkedDataStructure) {
-          set = context.isDistinct() ? new LinkedStructSet((StructTypeImpl)resultType) 
-          : new SortedResultsBag<Struct>((StructTypeImpl)resultType, nullValuesAtStart);
-        }else {
-          set = QueryUtils.createStructCollection(context, (StructTypeImpl)resultType) ;
-        }
-        indexFieldsSize = ((StructTypeImpl)resultType).getFieldNames().length;
-      }
-      else {
-        if (context.getCache().getLogger().fineEnabled()) {
-          context.getCache().getLogger().fine(
-            "non-StructType resultType.class="
-                + resultType.getClass().getName());
+          context.getCache().getLogger()
+              .fine("StructType resultType.class=" + resultType.getClass().getName());
-          set = context.isDistinct() ? new  LinkedResultSet(resultType): 
-            new SortedResultsBag(resultType, nullValuesAtStart); 
+          set = context.isDistinct() ? new LinkedStructSet((StructTypeImpl) resultType)
+              : new SortedResultsBag<Struct>((StructTypeImpl) resultType, nullValuesAtStart);
+        } else {
+          set = QueryUtils.createStructCollection(context, (StructTypeImpl) resultType);
+        }
+        indexFieldsSize = ((StructTypeImpl) resultType).getFieldNames().length;
+      } else {
+        if (context.getCache().getLogger().fineEnabled()) {
+          context.getCache().getLogger()
+              .fine("non-StructType resultType.class=" + resultType.getClass().getName());
+        }
+        if (useLinkedDataStructure) {
+          set = context.isDistinct() ? new LinkedResultSet(resultType)
+              : new SortedResultsBag(resultType, nullValuesAtStart);
-       * Asif : First obtain the match level of index resultset. If the match
-       * level happens to be zero , this implies that we just have to change the
-       * StructType ( again if only the Index resultset is a StructBag). If the
-       * match level is zero & expand to to top level flag is true & iff the
-       * total no. of iterators in current scope is greater than the no. of
-       * fields in StructBag , then only we need to do any expansion.
+       * Asif : First obtain the match level of index resultset. If the match level happens to be
+       * zero , this implies that we just have to change the StructType ( again if only the Index
+       * resultset is a StructBag). If the match level is zero & expand to to top level flag is true
+       * & iff the total no. of iterators in current scope is greater than the no. of fields in
+       * StructBag , then only we need to do any expansion.
-        observer.beforeIndexLookup(this.indxInfo._index, this.greaterCondnOp,
-            this.greaterCondnKey, this.lessCondnOp, this.lessCondnKey,
-            this.notEqualTypeKeys);
+        observer.beforeIndexLookup(this.indxInfo._index, this.greaterCondnOp, this.greaterCondnKey,
+            this.lessCondnOp, this.lessCondnKey, this.notEqualTypeKeys);
-        this.indxInfo._index.query(this.greaterCondnKey, this.greaterCondnOp,
-            this.lessCondnKey, this.lessCondnOp, set, notEqualTypeKeys, context);
-      }
-      finally {
+        this.indxInfo._index.query(this.greaterCondnKey, this.greaterCondnOp, this.lessCondnKey,
+            this.lessCondnOp, set, notEqualTypeKeys, context);
+      } finally {
-      return QueryUtils.getconditionedIndexResults(set, this.indxInfo, context,
-          indexFieldsSize, completeExpansionNeeded, iterOperands, indpndntItrs);
+      return QueryUtils.getconditionedIndexResults(set, this.indxInfo, context, indexFieldsSize,
+          completeExpansionNeeded, iterOperands, indpndntItrs);
-        SelectResults intermediateResults) throws FunctionDomainException,
-        TypeMismatchException, NameResolutionException,
-        QueryInvocationTargetException {
+        SelectResults intermediateResults) throws FunctionDomainException, TypeMismatchException,
+        NameResolutionException, QueryInvocationTargetException {
-    public Object evaluate(ExecutionContext context) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-        Object evaluatedPath = this.indxInfo._path.evaluate(context);
-        Boolean result =(Boolean) super.evaluate(context,evaluatedPath);
-        if( result.booleanValue()) {
-      	  result = (Boolean)TypeUtils.compare(evaluatedPath, this.lessCondnKey, this.lessCondnOp);
-      	  result = result.booleanValue() ? (Boolean)TypeUtils.compare(evaluatedPath, this.greaterCondnKey, this.greaterCondnOp):Boolean.FALSE;
-        }
-        return result;
+    public Object evaluate(ExecutionContext context) throws FunctionDomainException,
+        TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+      Object evaluatedPath = this.indxInfo._path.evaluate(context);
+      Boolean result = (Boolean) super.evaluate(context, evaluatedPath);
+      if (result.booleanValue()) {
+        result = (Boolean) TypeUtils.compare(evaluatedPath, this.lessCondnKey, this.lessCondnOp);
+        result = result.booleanValue()
+            ? (Boolean) TypeUtils.compare(evaluatedPath, this.greaterCondnKey, this.greaterCondnOp)
+            : Boolean.FALSE;
+      }
+      return result;

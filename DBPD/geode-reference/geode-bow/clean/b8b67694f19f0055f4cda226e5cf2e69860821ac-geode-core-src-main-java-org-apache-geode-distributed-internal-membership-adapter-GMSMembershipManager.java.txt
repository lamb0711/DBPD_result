Merge branch 'develop' into feature/GEODE-7049

-package org.apache.geode.distributed.internal.membership.gms.mgr;
+package org.apache.geode.distributed.internal.membership.adapter;
-import org.apache.geode.distributed.internal.DMStats;
-import org.apache.geode.distributed.internal.direct.DirectChannelListener;
-import org.apache.geode.distributed.internal.membership.DistributedMembershipListener;
-import org.apache.geode.distributed.internal.membership.NetView;
+import org.apache.geode.distributed.internal.membership.MembershipView;
+import org.apache.geode.distributed.internal.membership.gms.GMSMembershipView;
+import org.apache.geode.distributed.internal.membership.gms.api.MembershipConfig;
+import org.apache.geode.distributed.internal.membership.gms.api.MembershipListener;
+import org.apache.geode.distributed.internal.membership.gms.api.MembershipStatistics;
+import org.apache.geode.distributed.internal.membership.gms.api.MessageListener;
+import org.apache.geode.distributed.internal.membership.gms.interfaces.GMSMessage;
+import org.apache.geode.distributed.internal.membership.gms.messenger.GMSQuorumChecker;
-import org.apache.geode.internal.Version;
-import org.apache.geode.internal.admin.remote.RemoteTransportConfig;
+import org.apache.geode.internal.serialization.DataSerializableFixedID;
+import org.apache.geode.internal.serialization.Version;
-public class GMSMembershipManager implements MembershipManager, Manager {
+public class GMSMembershipManager implements MembershipManager {
+  private final ClusterDistributionManager dm;
+
+  private final ManagerImpl gmsManager;
+
+  private long ackSevereAlertThreshold;
+  private long ackWaitThreshold;
+
-    NetView gmsView;
+    MembershipView gmsView;
-    StartupEvent(NetView v) {
+    StartupEvent(MembershipView v) {
-  private NetView latestView = new NetView();
+  private MembershipView latestView = new MembershipView();
-  private final DistributedMembershipListener listener;
+  private final MembershipListener listener;
+
+  /**
+   * This is the listener that accepts our membership messages
+   */
+  private final MessageListener messageListener;
-  private int surpriseMemberTimeout;
+  private long surpriseMemberTimeout;
-  class MyDCReceiver implements DirectChannelListener {
+  class MyDCReceiver implements MessageListener {
-    final DirectChannelListener upCall;
+    final MessageListener upCall;
-    MyDCReceiver(DirectChannelListener up) {
+    MyDCReceiver(MessageListener up) {
-      services.getHealthMonitor().contactedBy(msg.getSender());
+      services.getHealthMonitor()
+          .contactedBy(((GMSMemberAdapter) msg.getSender().getNetMember()).getGmsMember());
-    @Override
-    public ClusterDistributionManager getDM() {
-      return upCall.getDM();
-    }
-
-  protected void processView(long newViewId, NetView newView) {
+  protected void processView(long newViewId, MembershipView newView) {
-      NetView priorView = latestView;
+      MembershipView priorView = latestView;
-      latestView = new NetView(newView, newView.getViewId());
+      latestView = new MembershipView(newView, newView.getViewId());
-            this.services.getConfig().getDistributionConfig().getSecurityPeerAuthInit();
+            this.services.getConfig().getSecurityPeerAuthInit();
-  @Override
-  public boolean isMulticastAllowed() {
-    return !disableMulticastForRollingUpgrade;
-  }
-
-        NetView initialView = services.getJoinLeave().getView();
-        latestView = new NetView(initialView, initialView.getViewId());
+        MembershipView initialView = createGeodeView(services.getJoinLeave().getView());
+        latestView = new MembershipView(initialView, initialView.getViewId());
+  private MembershipView createGeodeView(GMSMembershipView view) {
+    return createGeodeView(view.getCreator(), view.getViewId(), view.getMembers(),
+        view.getShutdownMembers(),
+        view.getCrashedMembers());
+  }
-  public GMSMembershipManager(DistributedMembershipListener listener) {
+  private MembershipView createGeodeView(GMSMember gmsCreator, int viewId,
+      List<GMSMember> gmsMembers,
+      Set<GMSMember> gmsShutdowns, Set<GMSMember> gmsCrashes) {
+    InternalDistributedMember geodeCreator =
+        new InternalDistributedMember(new GMSMemberAdapter(gmsCreator));
+    List<InternalDistributedMember> geodeMembers = new ArrayList<>(gmsMembers.size());
+    for (GMSMember member : gmsMembers) {
+      geodeMembers.add(new InternalDistributedMember(new GMSMemberAdapter(member)));
+    }
+    Set<InternalDistributedMember> geodeShutdownMembers =
+        gmsMemberCollectionToInternalDistributedMemberSet(gmsShutdowns);
+    Set<InternalDistributedMember> geodeCrashedMembers =
+        gmsMemberCollectionToInternalDistributedMemberSet(gmsCrashes);
+    return new MembershipView(geodeCreator, viewId, geodeMembers, geodeShutdownMembers,
+        geodeCrashedMembers);
+  }
+
+  private Set<InternalDistributedMember> gmsMemberCollectionToInternalDistributedMemberSet(
+      Collection<GMSMember> gmsMembers) {
+    if (gmsMembers.size() == 0) {
+      return Collections.emptySet();
+    } else if (gmsMembers.size() == 1) {
+      return Collections.singleton(
+          new InternalDistributedMember(new GMSMemberAdapter(gmsMembers.iterator().next())));
+    } else {
+      Set<InternalDistributedMember> idmMembers = new HashSet<>(gmsMembers.size());
+      for (GMSMember member : gmsMembers) {
+        idmMembers.add(new InternalDistributedMember(new GMSMemberAdapter((member))));
+      }
+      return idmMembers;
+    }
+  }
+
+
+  private List<InternalDistributedMember> gmsMemberListToInternalDistributedMemberList(
+      List<GMSMember> gmsMembers) {
+    if (gmsMembers.size() == 0) {
+      return Collections.emptyList();
+    } else if (gmsMembers.size() == 1) {
+      return Collections
+          .singletonList(new InternalDistributedMember(new GMSMemberAdapter(gmsMembers.get(0))));
+    } else {
+      List<InternalDistributedMember> idmMembers = new ArrayList<>(gmsMembers.size());
+      for (GMSMember member : gmsMembers) {
+        idmMembers.add(new InternalDistributedMember(new GMSMemberAdapter((member))));
+      }
+      return idmMembers;
+    }
+  }
+
+
+
+  public GMSMembershipManager(MembershipListener listener, MessageListener messageListener,
+      ClusterDistributionManager dm) {
+    this.messageListener = messageListener;
+    this.gmsManager = new ManagerImpl();
+    this.dm = dm;
-  @Override
-  public void init(Services services) {
-    this.services = services;
-
-    Assert.assertTrue(services != null);
-
-    DistributionConfig config = services.getConfig().getDistributionConfig();
-    RemoteTransportConfig transport = services.getConfig().getTransport();
-
-    this.membershipCheckTimeout = config.getSecurityPeerMembershipTimeout();
-    this.wasReconnectingSystem = transport.getIsReconnectingDS();
-
-    // cache these settings for use in send()
-    this.mcastEnabled = transport.isMcastEnabled();
-    this.tcpDisabled = transport.isTcpDisabled();
-
-    if (!this.tcpDisabled) {
-      dcReceiver = new MyDCReceiver(listener);
-    }
-
-    surpriseMemberTimeout =
-        Math.max(20 * DistributionConfig.DEFAULT_MEMBER_TIMEOUT, 20 * config.getMemberTimeout());
-    surpriseMemberTimeout =
-        Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "surprise-member-timeout",
-            surpriseMemberTimeout).intValue();
-
+  public Manager getGMSManager() {
+    return this.gmsManager;
-  public void start() {
-    DistributionConfig config = services.getConfig().getDistributionConfig();
-
-    int dcPort = 0;
-    if (!tcpDisabled) {
-      directChannel = new DirectChannel(this, dcReceiver, config);
-      dcPort = directChannel.getPort();
-    }
-
-
-    services.getMessenger().getMemberID().setDirectChannelPort(dcPort);
-
-  }
-
-
-  @Override
-  public void joinDistributedSystem() {
-    long startTime = System.currentTimeMillis();
-
-    try {
-      join();
-    } catch (RuntimeException e) {
-      if (directChannel != null) {
-        directChannel.disconnect(e);
-      }
-      throw e;
-    }
-
-    this.address = services.getMessenger().getMemberID();
-
-    if (directChannel != null) {
-      directChannel.setLocalAddr(address);
-    }
-
-    this.hasJoined = true;
-
-    // in order to debug startup issues we need to announce the membership
-    // ID as soon as we know it
-    logger.info("Finished joining (took {}ms).",
-        "" + (System.currentTimeMillis() - startTime));
-
-  }
-
-  @Override
-  public void started() {
-    startCleanupTimer();
-  }
-
-
-  /** this is invoked by JoinLeave when there is a loss of quorum in the membership system */
-  @Override
-  public void quorumLost(Collection<InternalDistributedMember> failures, NetView view) {
-    // notify of quorum loss if split-brain detection is enabled (meaning we'll shut down) or
-    // if the loss is more than one member
-
-    boolean notify = failures.size() > 1;
-    if (!notify) {
-      notify = services.getConfig().isNetworkPartitionDetectionEnabled();
-    }
-
-    if (notify) {
-      List<InternalDistributedMember> remaining = new ArrayList<>(view.getMembers());
-      remaining.removeAll(failures);
-
-      if (inhibitForceDisconnectLogging) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("<ExpectedException action=add>Possible loss of quorum</ExpectedException>");
-        }
-      }
-      logger.fatal("Possible loss of quorum due to the loss of {} cache processes: {}",
-          failures.size(), failures);
-      if (inhibitForceDisconnectLogging) {
-        if (logger.isDebugEnabled()) {
-          logger.debug(
-              "<ExpectedException action=remove>Possible loss of quorum</ExpectedException>");
-        }
-      }
-
-
-      try {
-        this.listener.quorumLost(new HashSet<>(failures), remaining);
-      } catch (CancelException e) {
-        // safe to ignore - a forced disconnect probably occurred
-      }
-    }
-  }
-
-
-  @Override
-        NetView newMembers = new NetView(latestView, latestView.getViewId());
+        MembershipView newMembers = new MembershipView(latestView, latestView.getViewId());
-    if (this.listener == null || listener.getDM() == null) {
+    if (dm == null) {
-    DistributedSystem ds = this.listener.getDM().getSystem();
+    DistributedSystem ds = dm.getSystem();
-  @Override
-  public void processMessage(DistributionMessage msg) {
-    handleOrDeferMessage(msg);
-  }
-
-    // UDP messages received from surprise members will have partial IDs.
-    // Attempt to replace these with full IDs from the MembershipManager's view.
-    if (msg.getSender().isPartial()) {
-      replacePartialIdentifierInMessage(msg);
-    }
-
-    listener.messageReceived(msg);
+    messageListener.messageReceived(msg);
-    sender = this.services.getJoinLeave().getMemberID(sender.getNetMember());
-    if (sender.isPartial()) {
+    GMSMember oldID = ((GMSMemberAdapter) sender.getNetMember()).getGmsMember();
+    GMSMember newID = this.services.getJoinLeave().getMemberID(oldID);
+    if (newID != null && newID != oldID) {
+      sender.setNetMember(new GMSMemberAdapter(newID));
+      sender.setIsPartial(false);
+    } else {
-      sender = this.dcReceiver.getDM().getCanonicalId(sender);
+      sender = dm.getCanonicalId(sender);
-  protected void handleOrDeferViewEvent(NetView viewArg) {
+  protected void handleOrDeferViewEvent(MembershipView viewArg) {
-      listener.messageReceived(v);
+      messageListener.messageReceived(v);
-  @Override
-  public void memberSuspected(InternalDistributedMember initiator,
-      InternalDistributedMember suspect, String reason) {
-    SuspectMember s = new SuspectMember(initiator, suspect, reason);
-    handleOrDeferSuspect(s);
+  private InternalDistributedMember gmsMemberToDMember(GMSMember gmsMember) {
+    return new InternalDistributedMember(new GMSMemberAdapter(gmsMember));
-      InternalDistributedMember suspect = suspectInfo.suspectedMember;
-      InternalDistributedMember who = suspectInfo.whoSuspected;
+      InternalDistributedMember suspect = gmsMemberToDMember(suspectInfo.suspectedMember);
+      InternalDistributedMember who = gmsMemberToDMember(suspectInfo.whoSuspected);
+        o.dmsg.setSender(latestView.getCanonicalID(o.dmsg.getSender()));
-  public NetView getView() {
+  public MembershipView getView() {
-    NetView v;
+    MembershipView v;
-    NetView result = new NetView(v, v.getViewId());
+    MembershipView result = new MembershipView(v, v.getViewId());
-  /**
-   * test hook
-   * <p>
-   * The lead member is the eldest member with partition detection enabled.
-   * <p>
-   * If no members have partition detection enabled, there will be no lead member and this method
-   * will return null.
-   *
-   * @return the lead member associated with the latest view
-   */
-  @Override
-  public DistributedMember getLeadMember() {
-    latestViewReadLock.lock();
-    try {
-      return latestView == null ? null : latestView.getLeadMember();
-    } finally {
-      latestViewReadLock.unlock();
-    }
-  }
-
-    NetView v = latestView;
+    MembershipView v = latestView;
-  public void shutdownMessageReceived(InternalDistributedMember id, String reason) {
+  public void shutdownMessageReceived(DistributedMember id, String reason) {
-      services.getHealthMonitor().memberShutdown(id, reason);
-      services.getJoinLeave().memberShutdown(id, reason);
+      services.getHealthMonitor()
+          .memberShutdown(
+              ((GMSMemberAdapter) ((InternalDistributedMember) id).getNetMember()).getGmsMember(),
+              reason);
+      services.getJoinLeave().memberShutdown(getGMSMember((InternalDistributedMember) id), reason);
-  public void stop() {
-
-    // [bruce] Do not null out the channel w/o adding appropriate synchronization
-
-    logger.debug("MembershipManager closing");
-
-    if (directChannel != null) {
-      directChannel.disconnect(null);
-
-      if (address != null) {
-        // Make sure that channel information is consistent
-        // Probably not important in this particular case, but just
-        // to be consistent...
-        latestViewWriteLock.lock();
-        try {
-          destroyMember(address, "orderly shutdown");
-        } finally {
-          latestViewWriteLock.unlock();
-        }
-      }
-    }
-
-    if (cleanupTimer != null) {
-      cleanupTimer.cancel();
-    }
-
-    if (logger.isDebugEnabled()) {
-      logger.debug("Membership: channel closed");
-    }
-  }
-
-  @Override
-      services.getJoinLeave().remove((InternalDistributedMember) mbr, reason);
+      services.getJoinLeave().remove(getGMSMember((InternalDistributedMember) mbr), reason);
-  public void suspectMembers(Set<InternalDistributedMember> members, String reason) {
-    for (final InternalDistributedMember member : members) {
+  public void suspectMembers(Set<DistributedMember> members, String reason) {
+    for (final DistributedMember member : members) {
-  public void suspectMember(InternalDistributedMember mbr, String reason) {
+  public void suspectMember(DistributedMember mbr, String reason) {
-  public boolean verifyMember(InternalDistributedMember mbr, String reason) {
+  public boolean verifyMember(DistributedMember mbr, String reason) {
-        && this.services.getHealthMonitor().checkIfAvailable(mbr, reason, false);
+        && this.services.getHealthMonitor()
+            .checkIfAvailable(getGMSMember((InternalDistributedMember) mbr), reason, false);
-   * @param theStats the statistics object to update
-      InternalDistributedMember[] destinations, DistributionMessage content, DMStats theStats)
+      InternalDistributedMember[] destinations, DistributionMessage content)
+    MembershipStatistics theStats = services.getStatistics();
-      sentBytes = directChannel.send(this, keys, content,
-          this.services.getConfig().getDistributionConfig().getAckWaitThreshold(),
-          this.services.getConfig().getDistributionConfig().getAckSevereAlertThreshold());
+      sentBytes =
+          directChannel.send(this, keys, content, ackWaitThreshold, ackSevereAlertThreshold);
-      NetView view = services.getJoinLeave().getView();
+      GMSMembershipView view = services.getJoinLeave().getView();
-        if (!view.contains(member) || (th instanceof ShunnedMemberException)) {
+        if (!view.contains(getGMSMember(member)) || (th instanceof ShunnedMemberException)) {
+  /**
+   * retrieve the GMS member ID held in a Geode InternalDistributedMember
+   */
+  private GMSMember getGMSMember(InternalDistributedMember member) {
+    return ((GMSMemberAdapter) member.getNetMember()).getGmsMember();
+  }
+
-  /**
-   * Returns true if the distributed system is in the process of auto-reconnecting. Otherwise
-   * returns false.
-   */
-  @Override
-  public boolean isReconnectingDS() {
-    return this.wasReconnectingSystem && !this.reconnectCompleted;
-  }
-
-    if (this.quorumChecker != null) {
-      return this.quorumChecker;
+    if (quorumChecker != null) {
+      return quorumChecker;
-    QuorumChecker impl = services.getMessenger().getQuorumChecker();
-    this.quorumChecker = impl;
-    return impl;
+    GMSQuorumChecker impl = services.getMessenger().getQuorumChecker();
+    quorumChecker = new GMSQuorumCheckerAdapter(impl);
+    return quorumChecker;
-      DistributionMessage msg, DMStats theStats) throws NotSerializableException {
+      DistributionMessage msg) throws NotSerializableException {
-      result = services.getMessenger().send(msg);
+      Set<GMSMember> failures = services.getMessenger().send(new GMSMessageAdapter(msg));
+      if (failures == null || failures.size() == 0) {
+        return Collections.emptySet();
+      }
+      return gmsMemberCollectionToInternalDistributedMemberSet(failures);
-      result = directChannelSend(destinations, msg, theStats);
+      result = directChannelSend(destinations, msg);
+    GMSMembershipView view = services.getJoinLeave().getView();
-        GMSMember id = (GMSMember) m.getNetMember();
+        GMSMemberAdapter adapter = (GMSMemberAdapter) m.getNetMember();
+        GMSMember id = adapter.getGmsMember();
-          latestViewReadLock.lock();
-          try {
-            addresses[i] = latestView.getCanonicalID(addresses[i]);
-          } finally {
-            latestViewReadLock.unlock();
-          }
+          adapter.setGmsMember(view.getCanonicalID(id));
-  @Override
-  public boolean shutdownInProgress() {
-    // Impossible condition (bug36329): make sure that we check DM's
-    // view of shutdown here
-    ClusterDistributionManager dm = listener.getDM();
-    return shutdownInProgress || (dm != null && dm.shutdownInProgress());
-  }
-
-
-        NetView newView = new NetView(latestView, latestView.getViewId());
+        MembershipView newView = new MembershipView(latestView, latestView.getViewId());
-  public int getSurpriseMemberTimeout() {
+  public long getSurpriseMemberTimeout() {
-  @Override
-  public boolean isReconnectCompleted() {
-    return reconnectCompleted;
-  }
-
-    services.getMessenger().getMessageState((InternalDistributedMember) member, result,
+    services.getMessenger().getMessageState(getGMSMember((InternalDistributedMember) member),
+        result,
-    services.getMessenger().waitForMessageState((InternalDistributedMember) otherMember, state);
+    services.getMessenger().waitForMessageState(
+        getGMSMember((InternalDistributedMember) otherMember), state);
-        && !services.getConfig().getDistributionConfig().getDisableTcp()) {
+        && !services.getConfig().getDisableTcp()) {
-    int memberTimeout = this.services.getConfig().getDistributionConfig().getMemberTimeout();
+    long memberTimeout = this.services.getConfig().getMemberTimeout();
-  public boolean waitForDeparture(DistributedMember mbr, int timeoutMs)
+  public boolean waitForDeparture(DistributedMember mbr, long timeoutMs)
-    OverflowQueueWithDMStats<Runnable> serialQueue = listener.getDM().getSerialQueue(idm);
+    OverflowQueueWithDMStats<Runnable> serialQueue = dm.getSerialQueue(idm);
+  @Override
+  public boolean shutdownInProgress() {
+    // Impossible condition (bug36329): make sure that we check DM's
+    // view of shutdown here
+    return shutdownInProgress || (dm != null && dm.shutdownInProgress());
+  }
+
-  public boolean waitForNewMember(InternalDistributedMember remoteId) {
+  public boolean waitForNewMember(DistributedMember remoteId) {
-  @Override
-  public void stopped() {}
-
-  @Override
-  public void installView(NetView v) {
-    if (latestViewId < 0 && !isConnected()) {
-      latestViewId = v.getViewId();
-      latestView = v;
-      logger.debug("MembershipManager: initial view is {}", latestView);
-    } else {
-      handleOrDeferViewEvent(v);
-    }
-  }
-
-  @Override
-  public Set<InternalDistributedMember> send(DistributionMessage m)
-      throws NotSerializableException {
-    return send(m.getRecipients(), m, this.services.getStatistics());
-  }
-
-  @Override
-  public void forceDisconnect(final String reason) {
-    if (GMSMembershipManager.this.shutdownInProgress || isJoining()) {
-      return; // probably a race condition
-    }
-
-    setShutdown();
-
-    final Exception shutdownCause = new ForcedDisconnectException(reason);
-
-    // cache the exception so it can be appended to ShutdownExceptions
-    services.setShutdownCause(shutdownCause);
-    services.getCancelCriterion().cancel(reason);
-
-    AlertAppender.getInstance().stopSession();
-
-    if (!inhibitForceDisconnectLogging) {
-      logger.fatal(
-          String.format("Membership service failure: %s", reason),
-          shutdownCause);
-    }
-
-    if (this.isReconnectingDS()) {
-      logger.info("Reconnecting system failed to connect");
-      uncleanShutdown(reason,
-          new ForcedDisconnectException("reconnecting system failed to connect"));
-      return;
-    }
-
-    listener.saveConfig();
-
-    Thread reconnectThread = new LoggingThread("DisconnectThread", false, () -> {
-      // stop server locators immediately since they may not have correct
-      // information. This has caused client failures in bridge/wan
-      // network-down testing
-      InternalLocator loc = (InternalLocator) Locator.getLocator();
-      if (loc != null) {
-        loc.stop(true, !services.getConfig().getDistributionConfig().getDisableAutoReconnect(),
-            false);
-      }
-      uncleanShutdown(reason, shutdownCause);
-    });
-    reconnectThread.start();
-  }
-
-
-  public boolean isShutdownStarted() {
-    ClusterDistributionManager dm = listener.getDM();
-    return shutdownInProgress || (dm != null && dm.isCloseInProgress());
-  }
-
-  @Override
+
+
+  class ManagerImpl implements Manager {
+
+    @Override
+    public Services getServices() {
+      return services;
+    }
+
+    @Override
+    /* Service interface */
+    public void init(Services services) {
+      GMSMembershipManager.this.services = services;
+
+      Assert.assertTrue(services != null);
+
+      MembershipConfig config = services.getConfig();
+
+      membershipCheckTimeout = config.getSecurityPeerMembershipTimeout();
+      wasReconnectingSystem = config.getIsReconnectingDS();
+
+      // cache these settings for use in send()
+      mcastEnabled = config.isMcastEnabled();
+      tcpDisabled = config.isTcpDisabled();
+      ackSevereAlertThreshold = config.getAckSevereAlertThreshold();
+      ackWaitThreshold = config.getAckWaitThreshold();
+
+      if (!tcpDisabled) {
+        dcReceiver = new MyDCReceiver(messageListener);
+      }
+
+      surpriseMemberTimeout =
+          Math.max(20 * DistributionConfig.DEFAULT_MEMBER_TIMEOUT, 20 * config.getMemberTimeout());
+      surpriseMemberTimeout =
+          Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "surprise-member-timeout",
+              surpriseMemberTimeout).longValue();
+
+    }
+
+    /* Service interface */
+    @Override
+    public void start() {
+      int dcPort = 0;
+      if (!tcpDisabled) {
+        directChannel = new DirectChannel(GMSMembershipManager.this, dcReceiver, dm);
+        dcPort = directChannel.getPort();
+      }
+      services.getMessenger().getMemberID().setDirectPort(dcPort);
+    }
+
+    /* Service interface */
+    @Override
+    public void started() {
+      startCleanupTimer();
+      // see if a locator was started and put it in GMS Services
+      InternalLocator l = (InternalLocator) org.apache.geode.distributed.Locator.getLocator();
+      if (l != null && l.getLocatorHandler() != null) {
+        if (l.getLocatorHandler().setServices(services)) {
+          services.setLocator(((GMSLocatorAdapter) l.getLocatorHandler()).getGMSLocator());
+        }
+      }
+    }
+
+    /* Service interface */
+    @Override
+    public void stop() {
+      // [bruce] Do not null out the channel w/o adding appropriate synchronization
+
+      logger.debug("MembershipManager closing");
+
+      if (directChannel != null) {
+        directChannel.disconnect(null);
+
+        if (address != null) {
+          // Make sure that channel information is consistent
+          // Probably not important in this particular case, but just
+          // to be consistent...
+          latestViewWriteLock.lock();
+          try {
+            destroyMember(address, "orderly shutdown");
+          } finally {
+            latestViewWriteLock.unlock();
+          }
+        }
+      }
+
+      if (cleanupTimer != null) {
+        cleanupTimer.cancel();
+      }
+
+      if (logger.isDebugEnabled()) {
+        logger.debug("Membership: channel closed");
+      }
+    }
+
+    /* Service interface */
+    @Override
+    public void stopped() {}
+
+    /* Service interface */
+    @Override
+    public void installView(GMSMembershipView v) {
+      if (latestViewId < 0 && !isConnected()) {
+        latestViewId = v.getViewId();
+        latestView = createGeodeView(v);
+        logger.debug("MembershipManager: initial view is {}", latestView);
+      } else {
+        handleOrDeferViewEvent(createGeodeView(v));
+      }
+    }
+
+    @Override
+    public void beSick() {
+      // no-op
+    }
+
+    @Override
+    public void playDead() {
+      // no-op
+    }
+
+    @Override
+    public void beHealthy() {
+      // no-op
+    }
+
+    @Override
+    public void emergencyClose() {
+      // no-op
+    }
+
+
+    @Override
+    public void joinDistributedSystem() {
+      long startTime = System.currentTimeMillis();
+
+      try {
+        join();
+      } catch (RuntimeException e) {
+        if (directChannel != null) {
+          directChannel.disconnect(e);
+        }
+        throw e;
+      }
+
+      GMSMembershipManager.this.address =
+          new InternalDistributedMember(
+              new GMSMemberAdapter(services.getMessenger().getMemberID()));
+
+      if (directChannel != null) {
+        directChannel.setLocalAddr(address);
+      }
+
+      GMSMembershipManager.this.hasJoined = true;
+
+      // in order to debug startup issues we need to announce the membership
+      // ID as soon as we know it
+      logger.info("Finished joining (took {}ms).",
+          "" + (System.currentTimeMillis() - startTime));
+
+    }
+
+    @Override
+    public void memberSuspected(GMSMember initiator,
+        GMSMember suspect, String reason) {
+      SuspectMember s = new SuspectMember(initiator, suspect, reason);
+      handleOrDeferSuspect(s);
+    }
+
+
+    @Override
+    public void forceDisconnect(final String reason) {
+      if (GMSMembershipManager.this.shutdownInProgress || isJoining()) {
+        return; // probably a race condition
+      }
+
+      setShutdown();
+
+      final Exception shutdownCause = new ForcedDisconnectException(reason);
+
+      // cache the exception so it can be appended to ShutdownExceptions
+      services.setShutdownCause(shutdownCause);
+      services.getCancelCriterion().cancel(reason);
+
+      AlertAppender.stopSessionIfRunning();
+
+      if (!inhibitForceDisconnectLogging) {
+        logger.fatal(
+            String.format("Membership service failure: %s", reason),
+            shutdownCause);
+      }
+
+      if (this.isReconnectingDS()) {
+        logger.info("Reconnecting system failed to connect");
+        uncleanShutdown(reason,
+            new ForcedDisconnectException("reconnecting system failed to connect"));
+        return;
+      }
+
+      listener.saveConfig();
+
+      Thread reconnectThread = new LoggingThread("DisconnectThread", false, () -> {
+        // stop server locators immediately since they may not have correct
+        // information. This has caused client failures in bridge/wan
+        // network-down testing
+        InternalLocator loc = (InternalLocator) Locator.getLocator();
+        if (loc != null) {
+          loc.stop(true, !services.getConfig().getDisableAutoReconnect(),
+              false);
+        }
+        uncleanShutdown(reason, shutdownCause);
+      });
+      reconnectThread.start();
+    }
+
+
+    /** this is invoked by JoinLeave when there is a loss of quorum in the membership system */
+    @Override
+    public void quorumLost(Collection<GMSMember> failures, GMSMembershipView view) {
+      // notify of quorum loss if split-brain detection is enabled (meaning we'll shut down) or
+      // if the loss is more than one member
+
+      boolean notify = failures.size() > 1;
+      if (!notify) {
+        notify = services.getConfig().isNetworkPartitionDetectionEnabled();
+      }
+
+      if (notify) {
+        List<InternalDistributedMember> remaining =
+            gmsMemberListToInternalDistributedMemberList(view.getMembers());
+        remaining.removeAll(failures);
+
+        if (inhibitForceDisconnectLogging) {
+          if (logger.isDebugEnabled()) {
+            logger
+                .debug("<ExpectedException action=add>Possible loss of quorum</ExpectedException>");
+          }
+        }
+        logger.fatal("Possible loss of quorum due to the loss of {} cache processes: {}",
+            failures.size(), failures);
+        if (inhibitForceDisconnectLogging) {
+          if (logger.isDebugEnabled()) {
+            logger.debug(
+                "<ExpectedException action=remove>Possible loss of quorum</ExpectedException>");
+          }
+        }
+
+
+        try {
+          listener.quorumLost(
+              gmsMemberCollectionToInternalDistributedMemberSet(failures),
+              remaining);
+        } catch (CancelException e) {
+          // safe to ignore - a forced disconnect probably occurred
+        }
+      }
+    }
+
+    @Override
+    public void processMessage(GMSMessage msg) {
+      DistributionMessage distributionMessage =
+          (DistributionMessage) ((GMSMessageAdapter) msg).getGeodeMessage();
+      // UDP messages received from surprise members will have partial IDs.
+      // Attempt to replace these with full IDs from the MembershipManager's view.
+      if (distributionMessage.getSender().isPartial()) {
+        replacePartialIdentifierInMessage(distributionMessage);
+      }
+
+      handleOrDeferMessage(distributionMessage);
+    }
+
+    @Override
+    public boolean isMulticastAllowed() {
+      return !disableMulticastForRollingUpgrade;
+    }
+
+    @Override
+    public boolean shutdownInProgress() {
+      // Impossible condition (bug36329): make sure that we check DM's
+      // view of shutdown here
+      return shutdownInProgress || (dm != null && dm.shutdownInProgress());
+    }
+
+    @Override
+    public boolean isReconnectingDS() {
+      return wasReconnectingSystem && !reconnectCompleted;
+    }
+
+    @Override
+    public boolean isShutdownStarted() {
+      return shutdownInProgress || (dm != null && dm.isCloseInProgress());
+    }
+
+    @Override
+    public GMSMessage wrapMessage(Object receivedMessage) {
+      if (receivedMessage instanceof GMSMessage) {
+        return (GMSMessage) receivedMessage;
+      }
+      // Geode's DistributionMessage class isn't known by GMS classes
+      return new GMSMessageAdapter((DistributionMessage) receivedMessage);
+    }
+
+    @Override
+    public DataSerializableFixedID unwrapMessage(GMSMessage messageToSend) {
+      if (messageToSend instanceof GMSMessageAdapter) {
+        return ((GMSMessageAdapter) messageToSend).getGeodeMessage();
+      }
+      return (DataSerializableFixedID) messageToSend;
+    }
+
+  }

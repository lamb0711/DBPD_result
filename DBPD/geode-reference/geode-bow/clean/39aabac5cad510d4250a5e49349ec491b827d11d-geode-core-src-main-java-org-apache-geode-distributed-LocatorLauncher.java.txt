Merge remote-tracking branch 'origin/develop' into feature/GEODE-3239

+import org.apache.commons.lang.exception.ExceptionUtils;
-import org.apache.geode.internal.process.StartupStatusListener;
+import org.apache.geode.management.internal.cli.util.HostUtils;
- * 
+ *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-      // NOTE returning localhost/127.0.0.1 implies the bindAddress was null and no IP address for
+      // Returning localhost/127.0.0.1 implies the bindAddress was null and no IP address for
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-            new StartupStatusListener() {
-              @Override
-              public void setStatus(final String statusMessage) {
-                LocatorLauncher.this.statusMessage = statusMessage;
-              }
-            });
+            statusMessage -> LocatorLauncher.this.statusMessage = statusMessage);
-    Properties properties = super.getDistributedSystemProperties(getProperties());
-    return properties;
+    return super.getDistributedSystemProperties(getProperties());
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-    // launcher
-    // is used to get the Locator's status).
+    // launcher is used to get the Locator's status).
-      return createNoResponseState(handled, "Failed to connect to locator " + getId());
+      return createNoResponseState(handled,
+          "Failed to connect to locator " + getBindAddressAsString() + "[" + getPort() + "]");
-   * 
+   *
-   * 
+   *
-   * 
+   *
-    // else if (this.workingDirectorySpecified) {
-    debug(cause);
+    debug(ExceptionUtils.getFullStackTrace(cause) + errorMessage);
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-  public static enum Command {
+  public enum Command {
-          : Collections.<String>emptyList());
+          : Collections.emptyList());
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-     * 
+     *
-   * 
+   *
-     * 
+     *
-          null, // locatorLocation
+          getLocatorLocation(launcher), // locatorLocation
-          Collections.<String>emptyList(), // jvmArguments
+          ManagementFactory.getRuntimeMXBean().getInputArguments(), // jvmArguments
-          null, // javaVersion
+          System.getProperty("java.version"), // javaVersion
-          null, // host
-          null, // port
+          launcher.getBindAddressAsString(), // host
+          launcher.getPortAsString(), // port
+    /*
+     * Guards against throwing NPEs due to incorrect or missing host information while constructing
+     * error states
+     */
+    private static String getLocatorLocation(LocatorLauncher launcher) {
+      if (launcher.getPort() == null) {
+        return launcher.getId();
+      }
+      if (launcher.getBindAddress() == null) {
+        return HostUtils.getLocatorId(HostUtils.getLocalHost(), launcher.getPort());
+      }
+      return HostUtils.getLocatorId(launcher.getBindAddressAsString(), launcher.getPort());
+    }
+
-          if (isBlank(bindAddress.getHostAddress())) {
+          if (isNotBlank(bindAddress.getHostAddress())) {
-                                                  // safe
-            // check none-the-less.
+            // safe check none-the-less.

Merge branch 'release/1.8.0'

+import java.util.concurrent.locks.ReentrantReadWriteLock;
-import org.apache.geode.i18n.StringId;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+import org.apache.geode.internal.logging.LoggingThread;
+  private final ReentrantReadWriteLock failedInitialImageLock = new ReentrantReadWriteLock(true);
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.DistributedRegion_REGION_0_1_SPLITBRAIN_CONFIG_WARNING,
-          new Object[] {regionName, attrs.getScope()}));
+      logger.warn(
+          "Region {} is being created with scope {} but enable-network-partition-detection is enabled in the distributed system.  This can lead to cache inconsistencies if there is a network failure.",
+          new Object[] {regionName, attrs.getScope()});
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.DistributedRegion_REGION_0_ENABLE_NETWORK_PARTITION_WARNING,
-          new Object[] {regionName, attrs.getScope()}));
+      logger.warn(
+          "Creating persistent region {}, but enable-network-partition-detection is set to false. Running with network partition detection disabled can lead to an unrecoverable system in the event of a network split.",
+          regionName);
-              LocalizedStrings.DistributedRegion_OPERATION_IS_DISALLOWED_BY_LOSSACTION_0_BECAUSE_THESE_REQUIRED_ROLES_ARE_MISSING_1
-                  .toLocalizedString(getMembershipAttributes().getLossAction(), roles),
+              String.format(
+                  "Operation is disallowed by LossAction %s because these required roles are missing: %s.",
+                  getMembershipAttributes().getLossAction(), roles),
-              LocalizedStrings.DistributedRegion_OPERATION_IS_DISALLOWED_BY_LOSSACTION_0_BECAUSE_THESE_REQUIRED_ROLES_ARE_MISSING_1
-                  .toLocalizedString(getMembershipAttributes().getLossAction(), roles),
+              String.format(
+                  "Operation is disallowed by LossAction %s because these required roles are missing: %s.",
+                  getMembershipAttributes().getLossAction(), roles),
-          LocalizedStrings.DistributedRegion_OPERATION_DISTRIBUTION_MAY_HAVE_FAILED_TO_NOTIFY_THESE_REQUIRED_ROLES_0
-              .toLocalizedString(failedRoles),
+          String.format("Operation distribution may have failed to notify these required roles: %s",
+              failedRoles),
-          LocalizedStrings.DistributedRegion_OPERATION_DISTRIBUTION_WAS_NOT_DONE_TO_THESE_REQUIRED_ROLES_0
-              .toLocalizedString(failedRoles),
+          String.format("Operation distribution was not done to these required roles: %s",
+              failedRoles),
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION),
+      logger.fatal("Unexpected exception:",
-          logger.fatal(
-              LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION), e);
+          logger.fatal("Unexpected exception:", e);
-        if (this.isInitializingThread) {
-          doLostReliability(true, id, newlyMissingRoles);
-        } else {
-          doLostReliability(false, id, newlyMissingRoles);
-        }
-        // we don't do this in the waiting pool because we're going to
-        // disconnect
-        // the distributed system, and it will wait for the pool to empty
+        doLostReliability(isInitializingThread, id, newlyMissingRoles);
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION),
+      logger.fatal("Unexpected exception:",
-        Thread thread = new Thread(
-            LocalizedStrings.DistributedRegion_RECONNECT_DISTRIBUTED_SYSTEM.toLocalizedString()) {
-          @Override
-          public void run() {
-            try {
-              logger.debug(
-                  "Reliability loss with policy of reconnect and membership thread doing reconnect");
+        Thread thread = new LoggingThread("Reconnect Distributed System", () -> {
+          try {
+            logger.debug(
+                "Reliability loss with policy of reconnect and membership thread doing reconnect");
-              initializationLatchAfterMemberTimeout.await();
-              getSystem().tryReconnect(false, "Role Loss", getCache());
+            initializationLatchAfterMemberTimeout.await();
+            getSystem().tryReconnect(false, "Role Loss", getCache());
-              synchronized (missingRequiredRoles) {
-                // any number of threads may be waiting on missingRequiredRoles
-                missingRequiredRoles.notifyAll();
-                // need to fire an event if id is not null
-                if (hasListener() && id != null) {
-                  RoleEventImpl relEvent = new RoleEventImpl(DistributedRegion.this,
-                      Operation.CACHE_RECONNECT, null, true, id, newlyMissingRoles);
-                  dispatchListenerEvent(EnumListenerEvent.AFTER_ROLE_LOSS, relEvent);
-                }
+            synchronized (missingRequiredRoles) {
+              // any number of threads may be waiting on missingRequiredRoles
+              missingRequiredRoles.notifyAll();
+              // need to fire an event if id is not null
+              if (hasListener() && id != null) {
+                RoleEventImpl relEvent = new RoleEventImpl(DistributedRegion.this,
+                    Operation.CACHE_RECONNECT, null, true, id, newlyMissingRoles);
+                dispatchListenerEvent(EnumListenerEvent.AFTER_ROLE_LOSS, relEvent);
-            } catch (Exception e) {
-              logger.fatal(
-                  LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION),
-                  e);
+          } catch (Exception e) {
+            logger.fatal("Unexpected exception:", e);
-        };
-        thread.setDaemon(true);
+        });
-      logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION),
+      logger.fatal("Unexpected exception:",
-          LocalizedStrings.DistributedRegion_DISTRIBUTION_LOCKS_ARE_ONLY_SUPPORTED_FOR_REGIONS_WITH_GLOBAL_SCOPE_NOT_0
-              .toLocalizedString(this.scope));
+          String.format(
+              "Distribution locks are only supported for regions with GLOBAL scope, not %s",
+              this.scope));
-          LocalizedStrings.DistributedRegion_DISTRIBUTION_LOCKS_ARE_ONLY_SUPPORTED_FOR_REGIONS_WITH_GLOBAL_SCOPE_NOT_0
-              .toLocalizedString(this.scope));
+          String.format(
+              "Distribution locks are only supported for regions with GLOBAL scope, not %s",
+              this.scope));
-          LocalizedStrings.DistributedRegion_THIS_THREAD_HAS_SUSPENDED_ALL_LOCKING_FOR_THIS_REGION
-              .toLocalizedString());
+          "This thread has suspended all locking for this region");
-                LocalizedStrings.ParallelAsyncEventQueue_0_CAN_NOT_BE_USED_WITH_REPLICATED_REGION_1
-                    .toLocalizedString(
-                        AsyncEventQueueImpl.getAsyncEventQueueIdFromSenderId(sender.getId()),
-                        this.getFullPath()));
+                String.format(
+                    "Parallel Async Event Queue %s can not be used with replicated region %s",
+
+                    AsyncEventQueueImpl.getAsyncEventQueueIdFromSenderId(sender.getId()),
+                    this.getFullPath()));
-                LocalizedStrings.ParallelGatewaySender_0_CAN_NOT_BE_USED_WITH_REPLICATED_REGION_1
-                    .toLocalizedString(sender.getId(), this.getFullPath()));
+                String.format(
+                    "Parallel gateway sender %s can not be used with replicated region %s",
+                    sender.getId(), this.getFullPath()));
-    logger.info(LocalizedMessage.create(LocalizedStrings.DistributedRegion_INITIALIZING_REGION_0,
-        this.getName()));
+    logger.info("Initializing region {}",
+        this.getName());
-          LocalizedStrings.DistributedRegion_IF_LOADING_A_SNAPSHOT_THEN_SHOULD_NOT_BE_RECOVERING_ISRECOVERING_0_SNAPSHOTSTREAM_1
-              .toLocalizedString(new Object[] {true, snapshotInputStream}));
+          String.format(
+              "if loading a snapshot, then should not be recovering; isRecovering= %s ,snapshotStream= %s",
+              new Object[] {true, snapshotInputStream}));
-                LocalizedMessage.create(LocalizedStrings.DistributedRegion_INITIALIZED_FROM_DISK,
-                    new Object[] {this.getFullPath(), persistentId, getPersistentID()}));
+                "Region {} recovered from the local disk. Old persistent ID: {}, new persistent ID {}",
+                new Object[] {this.getFullPath(), persistentId, getPersistentID()});
-              logger.info(LocalizedMessage.create(
-                  LocalizedStrings.DistributedRegion_NEW_PERSISTENT_REGION_CREATED,
-                  new Object[] {this.getFullPath(), getPersistentID()}));
+              logger.info("Region {} was created on this member with the persistent id {}.",
+                  new Object[] {this.getFullPath(), getPersistentID()});
-    if (!this.entries.isEmpty()) {
-      closeEntries();
-      if (getDiskRegion() != null) {
-        getDiskRegion().clear(this, null);
-      }
-      // clear the left-members and version-tags sets in imageState
-      getImageState().getLeftMembers();
-      getImageState().getVersionTags();
-      // Clear OQL indexes
-      if (this.indexManager != null) {
-        try {
-          this.indexManager.rerunIndexCreationQuery();
-        } catch (Exception ex) {
-          if (logger.isDebugEnabled()) {
-            logger.debug("Exception while clearing indexes after GII failure.", ex);
+    if (!getRegionMap().isEmpty()) {
+      lockFailedInitialImageWriteLock();
+      try {
+        closeEntries();
+        if (getDiskRegion() != null) {
+          getDiskRegion().clear(this, null);
+        }
+        // clear the left-members and version-tags sets in imageState
+        getImageState().getLeftMembers();
+        getImageState().getVersionTags();
+        // Clear OQL indexes
+        if (this.indexManager != null) {
+          try {
+            this.indexManager.rerunIndexCreationQuery();
+          } catch (Exception ex) {
+            if (logger.isDebugEnabled()) {
+              logger.debug("Exception while clearing indexes after GII failure.", ex);
+            }
+      } finally {
+        unlockFailedInitialImageWriteLock();
+  void lockFailedInitialImageWriteLock() {
+    failedInitialImageLock.writeLock().lock();
+  }
+
+  void unlockFailedInitialImageWriteLock() {
+    failedInitialImageLock.writeLock().unlock();
+  }
+
+  void lockFailedInitialImageReadLock() {
+    failedInitialImageLock.readLock().lock();
+  }
+
+  void unlockFailedInitialImageReadLock() {
+    failedInitialImageLock.readLock().unlock();
+  }
+
+  @Override
+  public boolean lockWhenRegionIsInitializing() {
+    if (!isInitialized()) {
+      lockFailedInitialImageReadLock();
+      return true;
+    }
+    return false;
+  }
+
+  @Override
+  public void unlockWhenRegionIsInitializing() {
+    unlockFailedInitialImageReadLock();
+  }
+
+          boolean initiateLossAction = false;
-                lostReliability(null, null);
+                initiateLossAction = true;
+          if (initiateLossAction) {
+            lostReliability(null, null);
+          }
-        logger.fatal(
-            LocalizedMessage.create(LocalizedStrings.DistributedRegion_UNEXPECTED_EXCEPTION), e);
+        logger.fatal("Unexpected exception:", e);
-    logger.info(LocalizedMessage.create(
-        LocalizedStrings.DistributedRegion_INITIALIZING_REGION_COMPLETED_0, this.getName()));
+    logger.info("Initialization of region {} completed", this.getName());
-          LocalizedStrings.DistributedRegion_NOT_ALLOWED_TO_DO_A_LOCAL_INVALIDATION_ON_A_REPLICATED_REGION
-              .toLocalizedString());
+          "Not allowed to do a local invalidation on a replicated region");
-            LocalizedStrings.DistributedRegion_NOT_ALLOWED_TO_DO_A_LOCAL_INVALIDATION_ON_A_REPLICATED_REGION
-                .toLocalizedString());
+            "Not allowed to do a local invalidation on a replicated region");
+    regionMap.lockForCacheModification(internalRegion, event);
+    final boolean locked = internalRegion.lockWhenRegionIsInitializing();
-      regionMap.lockForCacheModification(internalRegion, event);
+      if (locked) {
+        internalRegion.unlockWhenRegionIsInitializing();
+      }
-          LocalizedStrings.DistributedRegion_LOCALCLEAR_IS_NOT_SUPPORTED_ON_DISTRIBUTED_REPLICATED_REGIONS
-              .toLocalizedString());
+          "localClear is not supported on distributed replicated regions.");
-          LocalizedStrings.DistributedRegion_DISTRIBUTION_LOCKS_ARE_ONLY_SUPPORTED_FOR_REGIONS_WITH_GLOBAL_SCOPE_NOT_0
-              .toLocalizedString(this.scope));
+          String.format(
+              "Distribution locks are only supported for regions with GLOBAL scope, not %s",
+              this.scope));
-        logger.warn(LocalizedMessage.create(
-            LocalizedStrings.DistributedRegion_DLS_DESTROY_MAY_HAVE_FAILED_FOR_0,
-            this.getFullPath()), ex);
+        logger.warn("DLS destroy may have failed for " +
+            this.getFullPath(),
+            ex);
+    waitForCurrentOperations();
+  }
+
+  protected void waitForCurrentOperations() {
-        logger.warn(LocalizedMessage.create(LocalizedStrings.GemFireCache_0_ERROR_CLOSING_REGION_1,
+        logger.warn(String.format("%s: error closing region %s",
-              logger.error(
-                  LocalizedMessage.create(
-                      LocalizedStrings.DistributedRegion_EXCEPTION_OCCURRED_IN_REGIONMEMBERSHIPLISTENER),
+              logger.error("Exception occurred in RegionMembershipListener",
-      logger.warn(LocalizedMessage.create(
-          LocalizedStrings.DistributedRegion_ERROR_CLEANING_UP_FAILED_INITIALIZATION, this), t);
+      logger.warn("Error cleaning up after failed region initialization of region " + this,
+          t);
-          LocalizedStrings.Region_REGION_0_HAS_1_GATEWAY_SENDER_IDS_ANOTHER_CACHE_HAS_THE_SAME_REGION_WITH_2_GATEWAY_SENDER_IDS_FOR_REGION_ACROSS_ALL_MEMBERS_IN_DS_GATEWAY_SENDER_IDS_SHOULD_BE_SAME
-              .toLocalizedString(
-                  new Object[] {this.getName(), senderIds.get(0), senderIds.get(1)}));
+          String.format(
+              "Region %s has %s gateway sender IDs. Another cache has same region with %s gateway sender IDs. For region across all members, gateway sender ids should be same.",
+
+              new Object[] {this.getName(), senderIds.get(0), senderIds.get(1)}));
-          LocalizedStrings.Region_REGION_0_HAS_1_ASYNC_EVENT_QUEUE_IDS_ANOTHER_CACHE_HAS_THE_SAME_REGION_WITH_2_ASYNC_EVENT_QUEUE_IDS_FOR_REGION_ACROSS_ALL_MEMBERS_IN_DS_ASYNC_EVENT_QUEUE_IDS_SHOULD_BE_SAME
-              .toLocalizedString(
-                  new Object[] {this.getName(), asycnQueueIds.get(0), asycnQueueIds.get(1)}));
+          String.format(
+              "Region %s has %s AsyncEvent queue IDs. Another cache has same region with %s AsyncEvent queue IDs. For region across all members, AsyncEvent queue IDs should be same.",
+
+              new Object[] {this.getName(), asycnQueueIds.get(0), asycnQueueIds.get(1)}));
-      StringId msg = null;
+      String msg = null;
-            msg =
-                LocalizedStrings.DistributedRegion_ATTEMPT_TO_ACQUIRE_DISTRIBUTED_LOCK_FOR_0_FAILED_AFTER_WAITING_1_SECONDS;
+            msg = "Attempt to acquire distributed lock for %s failed after waiting %s seconds.";
-        msg =
-            LocalizedStrings.DistributedRegion_TIMED_OUT_AFTER_WAITING_0_SECONDS_FOR_THE_DISTRIBUTED_LOCK_FOR_1;
+        msg = "Timed out after waiting %s seconds for the distributed lock for %s.";
-      throw new TimeoutException(msg.toLocalizedString(msgArgs));
+      throw new TimeoutException(String.format(msg, msgArgs));
-    return getCache().getLockLease() * 1000;
+    return (getCache().getLockLease()) * 1000L;
-      long ackSAThreshold = getSystem().getConfig().getAckSevereAlertThreshold() * 1000;
+      long ackSAThreshold = getSystem().getConfig().getAckSevereAlertThreshold() * 1000L;
-        ackWaitThreshold = getSystem().getConfig().getAckWaitThreshold() * 1000;
+        ackWaitThreshold = getSystem().getConfig().getAckWaitThreshold() * 1000L;
-                    logger.fatal(LocalizedMessage.create(
-                        LocalizedStrings.DistributedRegion_0_SECONDS_HAVE_ELAPSED_WAITING_FOR_GLOBAL_REGION_ENTRY_LOCK_HELD_BY_1,
-                        new Object[] {ackWaitThreshold + ackSAThreshold, lockHolder}));
+                    logger.fatal(
+                        "{} seconds have elapsed waiting for global region entry lock held by {}",
+                        ackWaitThreshold + ackSAThreshold, lockHolder);
-          LocalizedStrings.DistributedRegion_NEWCONDITION_UNSUPPORTED.toLocalizedString());
+          "newCondition unsupported");
-          LocalizedStrings.DistributedRegion_NEWCONDITION_UNSUPPORTED.toLocalizedString());
+          "newCondition unsupported");
-      getCache().getLoggerI18n().fine("DR.postRemoveAll: no data to distribute");
+      getCache().getLogger().fine("DR.postRemoveAll: no data to distribute");
-          LocalizedStrings.DistributedRegion_REGION_HAS_NOT_BEEN_CONFIGURED_WITH_REQUIRED_ROLES
-              .toLocalizedString());
+          "Region has not been configured with required roles.");
-            LocalizedStrings.DistributedRegion_NO_REPLICATED_REGION_FOUND_FOR_EXECUTING_FUNCTION_0
-                .toLocalizedString(function.getId()));
+            String.format("No Replicated Region found for executing function : %s.",
+                function.getId()));

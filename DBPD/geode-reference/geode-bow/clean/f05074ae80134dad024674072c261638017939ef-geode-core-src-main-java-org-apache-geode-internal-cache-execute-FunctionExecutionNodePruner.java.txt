GEODE-7134: Replace bucket Set with bucket int[] (#4002)


+import org.apache.geode.internal.cache.BucketSetHelper;
-  public static HashMap<InternalDistributedMember, HashSet<Integer>> pruneNodes(
+  public static HashMap<InternalDistributedMember, int[]> pruneNodes(
-    HashMap<InternalDistributedMember, HashSet<Integer>> nodeToBucketsMap =
-        new HashMap<InternalDistributedMember, HashSet<Integer>>();
-    HashMap<InternalDistributedMember, HashSet<Integer>> prunedNodeToBucketsMap =
-        new HashMap<InternalDistributedMember, HashSet<Integer>>();
+    HashMap<InternalDistributedMember, int[]> nodeToBucketsMap =
+        new HashMap();
+    HashMap<InternalDistributedMember, int[]> prunedNodeToBucketsMap =
+        new HashMap();
+
-            HashSet<Integer> bucketSet = new HashSet<Integer>();
-            bucketSet.add(bucketId);
-            nodeToBucketsMap.put(node, bucketSet);
+            int[] bucketArray = new int[buckets.size() + 1];
+            bucketArray[0] = 0;
+            BucketSetHelper.add(bucketArray, bucketId);
+            nodeToBucketsMap.put(node, bucketArray);
-            HashSet<Integer> bucketSet = nodeToBucketsMap.get(node);
-            bucketSet.add(bucketId);
-            nodeToBucketsMap.put(node, bucketSet);
+            int[] bucketArray = nodeToBucketsMap.get(node);
+            BucketSetHelper.add(bucketArray, bucketId);
+            // nodeToBucketsMap.put(node, bucketSet);
-    HashSet<Integer> currentBucketSet = new HashSet<Integer>();
+    int[] currentBucketArray = new int[buckets.size() + 1];
+    currentBucketArray[0] = 0;
-      HashSet<Integer> bucketSet = nodeToBucketsMap.get(localNode);
+      int[] bucketArray = nodeToBucketsMap.get(localNode);
-            "FunctionExecutionNodePruner: Adding the node: {} which is lcoal and buckets {} to prunedMap",
-            localNode, bucketSet);
+            "FunctionExecutionNodePruner: Adding the node: {} which is local and buckets {} to prunedMap",
+            localNode, bucketArray);
-      currentBucketSet.addAll(bucketSet);
-      prunedNodeToBucketsMap.put(localNode, bucketSet);
+      System.arraycopy(bucketArray, 0, currentBucketArray, 0, bucketArray[0] + 1);
+      prunedNodeToBucketsMap.put(localNode, bucketArray);
-    while (!currentBucketSet.equals(buckets)) {
+    while (!arrayAndSetAreEqual(buckets, currentBucketArray)) {
-      InternalDistributedMember node = findNextNode(nodeToBucketsMap.entrySet(), currentBucketSet);
+      // continue
+      InternalDistributedMember node =
+          findNextNode(nodeToBucketsMap.entrySet(), currentBucketArray);
-      HashSet<Integer> bucketSet = nodeToBucketsMap.get(node);
-      bucketSet.removeAll(currentBucketSet);
-      if (!bucketSet.isEmpty()) {
-        currentBucketSet.addAll(bucketSet);
-        prunedNodeToBucketsMap.put(node, bucketSet);
+      int[] bucketArray = nodeToBucketsMap.get(node);
+      bucketArray = removeAllElements(bucketArray, currentBucketArray);
+      if (BucketSetHelper.length(bucketArray) != 0) {
+        currentBucketArray = addAllElements(currentBucketArray, bucketArray);
+        prunedNodeToBucketsMap.put(node, bucketArray);
-              bucketSet);
+              bucketArray);
-      Set<Map.Entry<InternalDistributedMember, HashSet<Integer>>> entrySet,
-      HashSet<Integer> currentBucketSet) {
+      Set<Map.Entry<InternalDistributedMember, int[]>> entrySet,
+      int[] currentBucketArray) {
-    for (Map.Entry<InternalDistributedMember, HashSet<Integer>> entry : entrySet) {
-      HashSet<Integer> buckets = new HashSet<Integer>(entry.getValue());
-      buckets.removeAll(currentBucketSet);
-      if (max < buckets.size()) {
-        max = buckets.size();
+    for (Map.Entry<InternalDistributedMember, int[]> entry : entrySet) {
+      int[] buckets = entry.getValue();
+      int[] tempbuckets = new int[buckets.length];
+      System.arraycopy(buckets, 0, tempbuckets, 0, buckets[0] + 1);
+      tempbuckets = removeAllElements(tempbuckets, currentBucketArray);
+
+      if (max < BucketSetHelper.length(tempbuckets)) {
+        max = BucketSetHelper.length(tempbuckets);
-      } else if (max == buckets.size()) {
+      } else if (max == BucketSetHelper.length(tempbuckets)) {
-  public static HashSet<Integer> getBucketSet(PartitionedRegion pr, Set routingKeys,
+
+  public static int[] getBucketSet(PartitionedRegion pr, Set routingKeys,
-    HashSet<Integer> bucketSet = null;
+    int[] bucketArray = null;
-      if (bucketSet == null) {
-        bucketSet = new HashSet<Integer>();
+      if (bucketArray == null) {
+        bucketArray = new int[routingKeys.size() + 1];
+        bucketArray[0] = 0;
-      bucketSet.add(bucketId);
+      BucketSetHelper.add(bucketArray, bucketId);
-    return bucketSet;
+    return bucketArray;
-  public static HashMap<InternalDistributedMember, HashSet<Integer>> groupByMemberToBuckets(
+  public static HashMap<InternalDistributedMember, int[]> groupByMemberToBuckets(
-      HashMap<InternalDistributedMember, HashSet<Integer>> memberToBucketsMap = new HashMap();
+      HashMap<InternalDistributedMember, int[]> memberToBucketsMap = new HashMap();
-          HashSet buckets = memberToBucketsMap.get(mem);
-          if (buckets == null) {
-            buckets = new HashSet(); // faster if this was an ArrayList
-            memberToBucketsMap.put(mem, buckets);
+          int[] bucketArray = memberToBucketsMap.get(mem);
+          if (bucketArray == null) {
+            bucketArray = new int[bucketSet.size() + 1]; // faster if this was an ArrayList
+            memberToBucketsMap.put(mem, bucketArray);
+            bucketArray[0] = 0;
-          buckets.add(bucketId);
+          BucketSetHelper.add(bucketArray, bucketId);
+
+
+  private static boolean arrayAndSetAreEqual(Set<Integer> setA, int[] arrayB) {
+    Set<Integer> setB = BucketSetHelper.toSet(arrayB);
+
+    return setA.equals(setB);
+  }
+
+  private static int[] removeAllElements(int[] arrayA, int[] arrayB) {
+    if (BucketSetHelper.length(arrayA) == 0 || BucketSetHelper.length(arrayB) == 0) {
+      return arrayA;
+    }
+
+    Set<Integer> inSet = BucketSetHelper.toSet(arrayA);
+
+    Set<Integer> subSet = BucketSetHelper.toSet(arrayB);
+
+    inSet.removeAll(subSet);
+
+    int[] outArray = BucketSetHelper.fromSet(inSet);
+
+    return outArray;
+
+  }
+
+  private static int[] addAllElements(int[] arrayA, int[] arrayB) {
+    if (BucketSetHelper.length(arrayB) == 0) {
+      return arrayA;
+    }
+
+    Set<Integer> inSet = BucketSetHelper.toSet(arrayA);
+
+    Set<Integer> addSet = BucketSetHelper.toSet(arrayB);
+
+    inSet.addAll(addSet);
+
+    int[] outArray = BucketSetHelper.fromSet(inSet);
+
+    return outArray;
+
+  }
+

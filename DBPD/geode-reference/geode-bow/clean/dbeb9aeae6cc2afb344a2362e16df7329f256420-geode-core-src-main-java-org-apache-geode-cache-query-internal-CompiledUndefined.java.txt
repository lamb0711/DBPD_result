Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class CompiledUndefined extends AbstractCompiledValue implements
-    Negatable , Indexable {
+public class CompiledUndefined extends AbstractCompiledValue implements Negatable, Indexable {
-  
+
-  public Object evaluate(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  public Object evaluate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-   * Asif : Evaluates as a filter taking advantage of indexes if appropriate.
-   * This function has a meaningful implementation only in CompiledComparison &
-   * CompiledUndefined . It is unsupported in other classes. The additional
-   * parameters which it takes are a boolean which is used to indicate whether
-   * the index result set needs to be expanded to the top level or not. The
-   * second is a CompiledValue representing the operands which are only iter
-   * evaluatable. The CompiledValue passed will be null except if a
-   * GroupJunction has only one filter evaluatable condition & rest are iter
-   * operands. In such cases , the iter operands will be evaluated while
-   * expanding/cutting down the index resultset
+   * Asif : Evaluates as a filter taking advantage of indexes if appropriate. This function has a
+   * meaningful implementation only in CompiledComparison & CompiledUndefined . It is unsupported in
+   * other classes. The additional parameters which it takes are a boolean which is used to indicate
+   * whether the index result set needs to be expanded to the top level or not. The second is a
+   * CompiledValue representing the operands which are only iter evaluatable. The CompiledValue
+   * passed will be null except if a GroupJunction has only one filter evaluatable condition & rest
+   * are iter operands. In such cases , the iter operands will be evaluated while expanding/cutting
+   * down the index resultset
-  public SelectResults filterEvaluate(ExecutionContext context,
-      SelectResults intermediateResults, boolean completeExpansionNeeded,
-      CompiledValue iterOperands, RuntimeIterator[] indpndntItrs, boolean isIntersection, boolean conditioningNeeded, boolean evaluateProjAttrib)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
-    //  this method is called if we are independent of the iterator,
+  public SelectResults filterEvaluate(ExecutionContext context, SelectResults intermediateResults,
+      boolean completeExpansionNeeded, CompiledValue iterOperands, RuntimeIterator[] indpndntItrs,
+      boolean isIntersection, boolean conditioningNeeded, boolean evaluateProjAttrib)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
+    // this method is called if we are independent of the iterator,
-    Support
-        .Assert(
-            this._value.isDependentOnCurrentScope(context),
-            "For a condition which does not depend on any RuntimeIterator of current scope , we should not have been in this function");
+    Support.Assert(this._value.isDependentOnCurrentScope(context),
+        "For a condition which does not depend on any RuntimeIterator of current scope , we should not have been in this function");
-      set = QueryUtils.createStructCollection(context, (StructTypeImpl)resultType) ;
+      set = QueryUtils.createStructCollection(context, (StructTypeImpl) resultType);
-    }
-    else {
+    } else {
-      idxInfo[0]._index.query(key, op, set,context);
-    }
-    finally {
+      idxInfo[0]._index.query(key, op, set, context);
+    } finally {
-    return QueryUtils.getconditionedIndexResults(set, idxInfo[0], context,
-        indexFieldsSize, completeExpansionNeeded, iterOperands, indpndntItrs);
+    return QueryUtils.getconditionedIndexResults(set, idxInfo[0], context, indexFieldsSize,
+        completeExpansionNeeded, iterOperands, indpndntItrs);
-  public int getSizeEstimate(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException
-  {
+  public int getSizeEstimate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    
+
-    
+
-    return idxInfo[0]._index.getSizeEstimate(QueryService.UNDEFINED, op,
-        idxInfo[0]._matchLevel);
+    return idxInfo[0]._index.getSizeEstimate(QueryService.UNDEFINED, op, idxInfo[0]._matchLevel);
-  
+
-   * evaluate as a filter, producing an intermediate result set. This may
-   * require iteration if there is no index available. Asif :The boolean true
-   * implies that CompiledComparsion when existing on its own always requires a
-   * Complete expansion to top level iterators. This flag can get toggled to
-   * false only from inside a GroupJunction
+   * evaluate as a filter, producing an intermediate result set. This may require iteration if there
+   * is no index available. Asif :The boolean true implies that CompiledComparsion when existing on
+   * its own always requires a Complete expansion to top level iterators. This flag can get toggled
+   * to false only from inside a GroupJunction
-   * <p>param intermediateResults if this parameter is provided, and we have to
-   *          iterate, then iterate over this result set instead of the entire
-   *          base collection.
+   * <p>
+   * param intermediateResults if this parameter is provided, and we have to iterate, then iterate
+   * over this result set instead of the entire base collection.
-  public SelectResults filterEvaluate(ExecutionContext context,
-      SelectResults iterationLimit) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+  public SelectResults filterEvaluate(ExecutionContext context, SelectResults iterationLimit)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-    return filterEvaluate(context, iterationLimit,
-        true/* Complete Expansion needed */, null, null, true,isConditioningNeededForIndex(null, context, true), false);
+    return filterEvaluate(context, iterationLimit, true/* Complete Expansion needed */, null, null,
+        true, isConditioningNeededForIndex(null, context, true), false);
-   * Asif : This function should never get invoked as now if a CompiledJunction
-   * or GroupJunction contains a single filterable CompiledUndefined, it should
-   * directly call filterEvaluate rather than auxFilterEvalutae. Overriding this
-   * function just for ensuring that auxFilterEvaluate is not being called by
-   * mistake.
+   * Asif : This function should never get invoked as now if a CompiledJunction or GroupJunction
+   * contains a single filterable CompiledUndefined, it should directly call filterEvaluate rather
+   * than auxFilterEvalutae. Overriding this function just for ensuring that auxFilterEvaluate is
+   * not being called by mistake.
-      SelectResults intermediateResults) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException {
-    Support
-        .assertionFailed(" This auxFilterEvaluate of CompiledComparison should never have got invoked.");
+      SelectResults intermediateResults) throws FunctionDomainException, TypeMismatchException,
+      NameResolutionException, QueryInvocationTargetException {
+    Support.assertionFailed(
+        " This auxFilterEvaluate of CompiledComparison should never have got invoked.");
-    return context.addDependencies(this, this._value
-        .computeDependencies(context));
+    return context.addDependencies(this, this._value.computeDependencies(context));
-    if (indexInfo == null) return result;
-    Support
-        .Assert(
-            indexInfo.length == 1,
-            "For a CompiledUndefined  we cannot have a join of two indexes. There should be only a single index to use");
+    if (indexInfo == null)
+      return result;
+    Support.Assert(indexInfo.length == 1,
+        "For a CompiledUndefined  we cannot have a join of two indexes. There should be only a single index to use");
-  
+
-    if (!IndexUtils.indexesEnabled) return null;
-    //TODO:Asif : Check if the condition is such that Primary Key Index is used
+    if (!IndexUtils.indexesEnabled)
+      return null;
+    // TODO:Asif : Check if the condition is such that Primary Key Index is used
-    //, then are we returning all the values of the region ?
+    // , then are we returning all the values of the region ?
-    IndexData indexData = QueryUtils.getAvailableIndexIfAny(this._value,
-        context, _is_defined ? TOK_NE : TOK_EQ);
+    IndexData indexData =
+        QueryUtils.getAvailableIndexIfAny(this._value, context, _is_defined ? TOK_NE : TOK_EQ);
-      /* Pass the Key as null as the key is not of type CompiledValue( but of type QueryService.UNDEFINED)*/
-      newIndexInfo[0] = new IndexInfo(null, this._value, index,
-          indexData.getMatchLevel(), indexData.getMapping(),
-          _is_defined ? TOK_NE : TOK_EQ);
+      /*
+       * Pass the Key as null as the key is not of type CompiledValue( but of type
+       * QueryService.UNDEFINED)
+       */
+      newIndexInfo[0] = new IndexInfo(null, this._value, index, indexData.getMatchLevel(),
+          indexData.getMapping(), _is_defined ? TOK_NE : TOK_EQ);
-  public void generateCanonicalizedExpression(StringBuffer clauseBuffer,
-      ExecutionContext context) throws AmbiguousNameException,
-      TypeMismatchException, NameResolutionException {
+  public void generateCanonicalizedExpression(StringBuffer clauseBuffer, ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-  //_indexInfo is a transient field
+  // _indexInfo is a transient field
-  
+
-  
-  public boolean isProjectionEvaluationAPossibility(ExecutionContext context)
-  {
-    return true;
-  }
-  //TODO:Asif: This should ideally be treated like CompiledComparison in terms evaluation of
-  // iter operands etc
-  public boolean isConditioningNeededForIndex(RuntimeIterator independentIter, 
-      ExecutionContext context, boolean completeExpnsNeeded) throws AmbiguousNameException, TypeMismatchException, NameResolutionException  {    
+
+  public boolean isProjectionEvaluationAPossibility(ExecutionContext context) {
-  public boolean isBetterFilter(Filter comparedTo, ExecutionContext context, int thisSize) throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException
-  {
-    //If the current filter is equality & comparedTo filter is also equality based , then 
+  // TODO:Asif: This should ideally be treated like CompiledComparison in terms evaluation of
+  // iter operands etc
+  public boolean isConditioningNeededForIndex(RuntimeIterator independentIter,
+      ExecutionContext context, boolean completeExpnsNeeded)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+    return true;
+  }
+
+  public boolean isBetterFilter(Filter comparedTo, ExecutionContext context, int thisSize)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
+    // If the current filter is equality & comparedTo filter is also equality based , then
-    int thatOperator = comparedTo.getOperator() ;
-    
-    //Go with the lowest cost when hint is used.  
-    if (context instanceof QueryExecutionContext && ((QueryExecutionContext)context).hasHints()) {
+    int thatOperator = comparedTo.getOperator();
+
+    // Go with the lowest cost when hint is used.
+    if (context instanceof QueryExecutionContext && ((QueryExecutionContext) context).hasHints()) {
-        
-    switch(thatOperator) {
+
+    switch (thatOperator) {
-           isThisBetter = thisSize <= thatSize;
-           break;
+        isThisBetter = thisSize <= thatSize;
+        break;
-          //This is  possible only in case of RangeJunction
-          if(thisOperator== TOK_NE || thisOperator == TOK_NE_ALT ) {
-            //Asif: Give preference to range as I am assuming that range will fetch less data 
-            // as compared to NOT EQUALs
-            isThisBetter = false;            
-          }
-          break;
+        // This is possible only in case of RangeJunction
+        if (thisOperator == TOK_NE || thisOperator == TOK_NE_ALT) {
+          // Asif: Give preference to range as I am assuming that range will fetch less data
+          // as compared to NOT EQUALs
+          isThisBetter = false;
+        }
+        break;
-          //Give preference to this rather than that as this is more deterministic
-          break;
-      default :
-            throw  new IllegalArgumentException("The operator type ="+ thatOperator + " is unknown");
-    }   
+        // Give preference to this rather than that as this is more deterministic
+        break;
+      default:
+        throw new IllegalArgumentException("The operator type =" + thatOperator + " is unknown");
+    }

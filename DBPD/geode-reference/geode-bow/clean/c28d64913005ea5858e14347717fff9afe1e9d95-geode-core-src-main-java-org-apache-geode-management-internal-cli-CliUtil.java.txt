Merge branch 'release/1.4.0'

-import java.util.Collection;
+import java.util.Collections;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Map.Entry;
+import java.util.stream.Collectors;
+import org.apache.commons.lang.ArrayUtils;
-import org.apache.geode.management.DistributedSystemMXBean;
+import org.apache.geode.management.DistributedRegionMXBean;
-import org.apache.geode.management.internal.cli.functions.MembersForRegionFunction;
+import org.apache.geode.management.internal.MBeanJMXAdapter;
+import org.apache.geode.management.internal.SystemManagementService;
+import org.apache.geode.management.internal.cli.exceptions.UserErrorException;
+import org.apache.geode.management.internal.cli.result.ResultBuilder;
-  public static byte[][] filesToBytes(String[] fileNames) throws IOException {
+  /**
+   * Even thought this is only used in a test, caller of MemberMXBean.processCommand(String, Map,
+   * Byte[][]) will need to use this method to convert a fileList to Byte[][] to call that
+   * deprecated API.
+   *
+   * Once that deprecated API is removed, we can delete this method and the tests.
+   */
+  public static Byte[][] filesToBytes(List<String> fileNames) throws IOException {
-    byte[][] filesData = new byte[filesDataList.size()][];
+    List<Byte[]> convertedList =
+        filesDataList.stream().map(ArrayUtils::toObject).collect(Collectors.toList());
-    filesData = filesDataList.toArray(filesData);
-
-    return filesData;
+    return convertedList.toArray(new Byte[convertedList.size()][]);
-  public static String[] bytesToNames(byte[][] fileData) {
-    String[] names = new String[fileData.length / 2];
-    for (int i = 0; i < fileData.length; i += 2) {
-      names[i / 2] = new String(fileData[i]);
-    }
-
-    return names;
-  }
-
-  public static byte[][] bytesToData(byte[][] fileData) {
-    byte[][] data = new byte[fileData.length / 2][];
-    for (int i = 1; i < fileData.length; i += 2) {
-      data[i / 2] = fileData[i];
-    }
-
-    return data;
-  }
-
-  public static void bytesToFiles(byte[][] fileData, String parentDirPath, boolean mkRequireddirs)
+  public static List<String> bytesToFiles(Byte[][] fileData, String parentDirPath)
+    List<String> filesPaths = new ArrayList<>();
+    File file = null;
-    if (mkRequireddirs && !parentDir.exists()) {
-      if (!parentDir.mkdirs()) {
-        throw new UnsupportedOperationException(
-            "Couldn't create required directory structure for " + parentDirPath);
-      }
+    if (!parentDir.exists() && !parentDir.mkdirs()) {
+      throw new UnsupportedOperationException(
+          "Couldn't create required directory structure for " + parentDirPath);
+      byte[] bytes = ArrayUtils.toPrimitive(fileData[i]);
-        String fileName = new String(fileData[i]);
-        fos = new FileOutputStream(new File(parentDir, fileName));
+        String fileName = new String(bytes);
+        file = new File(parentDir, fileName);
+        fos = new FileOutputStream(file);
-        fos.write(fileData[i]);
+        fos.write(bytes);
+        filesPaths.add(file.getAbsolutePath());
+    return filesPaths;
-      throw new IllegalArgumentException(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE);
+      throw new UserErrorException(CliStrings.PROVIDE_EITHER_MEMBER_OR_GROUP_MESSAGE);
-            || memberNameOrId.equals(member.getName())) {
+            || memberNameOrId.equalsIgnoreCase(member.getName())) {
-            || memberNameOrId.equals(member.getName())) {
+            || memberNameOrId.equalsIgnoreCase(member.getName())) {
+  public static Result getFunctionResult(ResultCollector<?, ?> rc, String commandName) {
+    Result result;
+    List<Object> results = (List<Object>) rc.getResult();
+    if (results != null) {
+      Object resultObj = results.get(0);
+      if (resultObj instanceof String) {
+        result = ResultBuilder.createInfoResult((String) resultObj);
+      } else if (resultObj instanceof Exception) {
+        result = ResultBuilder.createGemFireErrorResult(((Exception) resultObj).getMessage());
+      } else {
+        result = ResultBuilder.createGemFireErrorResult(
+            CliStrings.format(CliStrings.COMMAND_FAILURE_MESSAGE, commandName));
+      }
+    } else {
+      result = ResultBuilder.createGemFireErrorResult(
+          CliStrings.format(CliStrings.COMMAND_FAILURE_MESSAGE, commandName));
+    }
+    return result;
+  }
+
+  public static Set<DistributedMember> getMembersWithAsyncEventQueue(InternalCache cache,
+      String queueId) {
+    Set<DistributedMember> members = findMembers(null, null);
+    return members.stream().filter(m -> getAsyncEventQueueIds(cache, m).contains(queueId))
+        .collect(Collectors.toSet());
+  }
+
+  public static Set<String> getAsyncEventQueueIds(InternalCache cache, DistributedMember member) {
+    SystemManagementService managementService =
+        (SystemManagementService) ManagementService.getExistingManagementService(cache);
+    return managementService.getAsyncEventQueueMBeanNames(member).stream()
+        .map(x -> x.getKeyProperty("queue")).collect(Collectors.toSet());
+  }
+
-   * 
+   *
-   * 
+   *
-    return new HashSet<DistributedMember>(
-        cache.getInternalDistributedSystem().getDistributionManager().getDistributionManagerIds());
+    return getAllMembers(cache.getInternalDistributedSystem());
-  /**
-   * Returns a set of all the members of the distributed system for the given groups.
-   */
-  public static Set<DistributedMember> getDistributedMembersByGroup(InternalCache cache,
-      String[] groups) {
-    Set<DistributedMember> groupMembers = new HashSet<>();
-    for (String group : groups) {
-      groupMembers.addAll(
-          cache.getInternalDistributedSystem().getDistributionManager().getGroupMembers(group));
-    }
-    return groupMembers;
-  }
-
-   * Executes a function with arguments on a set of members , ignores the departed members.
-   * 
+   * Executes a function with arguments on a set of members, ignoring the departed members.
+   *
-  /***
-   * Executes a function with arguments on a member , ignores the departed member.
-   * 
-   * @param function Function to be executed
-   * @param args Arguments passed to the function, pass null if you wish to pass no arguments to the
-   *        function.
-   * @param targetMember Member on which the function is to be executed.
-   * @return ResultCollector
-   */
-  public static ResultCollector<?, ?> executeFunction(final Function function, Object args,
-      final DistributedMember targetMember) {
-    Execution execution;
-
-    if (args != null) {
-      execution = FunctionService.onMember(targetMember).setArguments(args);
-    } else {
-      execution = FunctionService.onMember(targetMember);
-    }
-
-    ((AbstractExecution) execution).setIgnoreDepartedMembers(true);
-    return execution.execute(function);
-  }
-
+   * @param returnAll if true, returns all matching members, else returns only first one found.
-      final InternalCache cache) {
+      final InternalCache cache, boolean returnAll) {
-      return null;
+      return Collections.emptySet();
-    ManagementService managementService = ManagementService.getExistingManagementService(cache);
-    DistributedSystemMXBean distributedSystemMXBean =
-        managementService.getDistributedSystemMXBean();
-    Set<DistributedMember> matchedMembers = new HashSet<>();
+    DistributedRegionMXBean regionMXBean =
+        ManagementService.getManagementService(cache).getDistributedRegionMXBean(region);
+    if (regionMXBean == null) {
+      return Collections.emptySet();
+    }
+
+    String[] regionAssociatedMemberNames = regionMXBean.getMembers();
+    Set<DistributedMember> matchedMembers = new HashSet<>();
-      try {
-        if (distributedSystemMXBean.fetchRegionObjectName(CliUtil.getMemberNameOrId(member),
-            region) != null) {
+      for (String regionAssociatedMemberName : regionAssociatedMemberNames) {
+        String name = MBeanJMXAdapter.getMemberNameOrId(member);
+        if (name.equals(regionAssociatedMemberName)) {
+          if (!returnAll) {
+            return matchedMembers;
+          }
-      } catch (Exception ignored) {
+  /**
+   * this finds the member that hosts all the regions passed in.
+   *
+   * @param regions
+   * @param cache
+   * @param returnAll if true, returns all matching members, otherwise, returns only one.
+   */
+  public static Set<DistributedMember> getQueryRegionsAssociatedMembers(Set<String> regions,
+      final InternalCache cache, boolean returnAll) {
+    Set<DistributedMember> results = regions.stream()
+        .map(region -> getRegionAssociatedMembers(region, cache, true)).reduce((s1, s2) -> {
+          s1.retainAll(s2);
+          return s1;
+        }).get();
+
+    if (returnAll || results.size() <= 1) {
+      return results;
+    }
+
+    // returns a set of only one item
+    return Collections.singleton(results.iterator().next());
+  }
+
-  public static String collectionToString(Collection<?> col, int newlineAfter) {
-    if (col != null) {
-      StringBuilder builder = new StringBuilder();
-      int lastNewlineAt = 0;
-
-      for (Iterator<?> it = col.iterator(); it.hasNext();) {
-        Object object = it.next();
-        builder.append(String.valueOf(object));
-        if (it.hasNext()) {
-          builder.append(", ");
-        }
-        if (newlineAfter > 0 && (builder.length() - lastNewlineAt) / newlineAfter >= 1) {
-          builder.append(GfshParser.LINE_SEPARATOR);
-        }
-      }
-      return builder.toString();
-    } else {
-      return "" + null;
-    }
-  }
-
-    if (array != null) {
-      StringBuilder builder = new StringBuilder();
-      for (int i = 0; i < array.length; i++) {
-        Object object = array[i];
-        builder.append(String.valueOf(object));
-        if (i < array.length - 1) {
-          builder.append(", ");
-        }
-      }
-      return builder.toString();
-    } else {
-      return "" + null;
+    if (array == null) {
+      return "null";
+    return Arrays.stream(array).map(String::valueOf).collect(Collectors.joining(", "));
-  public static Set<DistributedMember> getMembersForeRegionViaFunction(InternalCache cache,
-      String regionPath, boolean returnAll) {
-    try {
-      Set<DistributedMember> regionMembers = new HashSet<>();
-      MembersForRegionFunction membersForRegionFunction = new MembersForRegionFunction();
-      FunctionService.registerFunction(membersForRegionFunction);
-      Set<DistributedMember> targetMembers = CliUtil.getAllMembers(cache);
-      List<?> resultList = (List<?>) CliUtil
-          .executeFunction(membersForRegionFunction, regionPath, targetMembers).getResult();
-
-      for (Object object : resultList) {
-        try {
-          if (object instanceof Exception) {
-            LogWrapper.getInstance().warning(
-                "Exception in getMembersForeRegionViaFunction " + ((Throwable) object).getMessage(),
-                ((Throwable) object));
-            continue;
-          } else if (object instanceof Throwable) {
-            LogWrapper.getInstance().warning(
-                "Exception in getMembersForeRegionViaFunction " + ((Throwable) object).getMessage(),
-                ((Throwable) object));
-            continue;
-          }
-          if (object != null) {
-            Map<String, String> memberDetails = (Map<String, String>) object;
-            for (Entry<String, String> entry : memberDetails.entrySet()) {
-              Set<DistributedMember> dsMems = CliUtil.getAllMembers(cache);
-              for (DistributedMember mem : dsMems) {
-                if (mem.getId().equals(entry.getKey())) {
-                  regionMembers.add(mem);
-                  if (!returnAll) {
-                    return regionMembers;
-                  }
-                }
-              }
-            }
-          }
-        } catch (Exception ex) {
-          LogWrapper.getInstance().warning("getMembersForeRegionViaFunction exception " + ex);
-        }
-      }
-      return regionMembers;
-    } catch (Exception e) {
-      LogWrapper.getInstance().warning("getMembersForeRegionViaFunction exception " + e);
-      return null;
-    }
-  }
-

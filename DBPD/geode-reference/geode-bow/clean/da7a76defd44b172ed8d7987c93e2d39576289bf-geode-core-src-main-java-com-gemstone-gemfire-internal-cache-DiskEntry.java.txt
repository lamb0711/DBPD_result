Merge branch 'develop' into feature/GEODE-17-2

-import com.gemstone.gemfire.internal.cache.DiskEntry.Helper.ValueWrapper;
-import com.gemstone.gemfire.internal.offheap.ObjectChunk;
+import com.gemstone.gemfire.internal.offheap.AddressableMemoryManager;
-import com.gemstone.gemfire.internal.offheap.Releasable;
-import com.gemstone.gemfire.internal.offheap.UnsafeMemoryChunk;
-     * This method is used for concurrent map operations, SQLFabric and CQ processing
+     * This method is used for concurrent map operations and CQ processing
-        if (v instanceof ObjectChunk) {
-          @Released ObjectChunk ohv = (ObjectChunk) v;
-          try {
-            v = ohv.getDeserializedValue(null, null);
-            if (v == ohv) {
-              throw new IllegalStateException("sqlf tried to use getValueOnDiskOrBuffer");
-            }
-          } finally {
-            ohv.release(); // OFFHEAP the offheap ref is decremented here
-          }
-        } else {
-          v = ((CachedDeserializable)v).getDeserializedValue(null, null);
+        CachedDeserializable cd = (CachedDeserializable) v;
+        try {
+          v = cd.getDeserializedValue(null, null);
+        } finally {
+          OffHeapHelper.release(cd); // If v was off-heap it is released here
+        CachedDeserializable cd = (CachedDeserializable) v;
-          if (v instanceof StoredObject && !((StoredObject) v).isSerialized()) {
+          if (!cd.isSerialized()) {
-            entry.value = ((StoredObject) v).getDeserializedForReading();
+            entry.value = cd.getDeserializedForReading();
-            Object tmp = ((CachedDeserializable)v).getValue();
+            Object tmp = cd.getValue();
-     * Note that the Chunk this ValueWrapper is created with
+     * Note that the StoredObject this ValueWrapper is created with
-     * the chunk releases it.
+     * the StoredObject releases it.
-     * Note that this class is only used with uncompressed chunks.
+     * Note that this class is only used with uncompressed StoredObjects.
-    public static class ChunkValueWrapper implements ValueWrapper {
-      private final @Unretained ObjectChunk chunk;
-      public ChunkValueWrapper(ObjectChunk c) {
-        assert !c.isCompressed();
-        this.chunk = c;
+    public static class OffHeapValueWrapper implements ValueWrapper {
+      private final @Unretained StoredObject offHeapData;
+      public OffHeapValueWrapper(StoredObject so) {
+        assert so.hasRefCount();
+        assert !so.isCompressed();
+        this.offHeapData = so;
-        return this.chunk.isSerialized();
+        return this.offHeapData.isSerialized();
-        return this.chunk.getDataSize();
+        return this.offHeapData.getDataSize();
-          ByteBuffer chunkbb = this.chunk.createDirectByteBuffer();
+          ByteBuffer chunkbb = this.offHeapData.createDirectByteBuffer();
-        final long bbAddress = ObjectChunk.getDirectByteBufferAddress(bb);
+        final long bbAddress = AddressableMemoryManager.getDirectByteBufferAddress(bb);
-          long addrToRead = this.chunk.getAddressForReading(0, maxOffset);
+          long addrToRead = this.offHeapData.getAddressForReadingData(0, maxOffset);
-              UnsafeMemoryChunk.copyMemory(addrToRead, addrToWrite, availableSpace);
+              AddressableMemoryManager.copyMemory(addrToRead, addrToWrite, availableSpace);
-          UnsafeMemoryChunk.copyMemory(addrToRead, addrToWrite, bytesRemaining);
+          AddressableMemoryManager.copyMemory(addrToRead, addrToWrite, bytesRemaining);
-          long addr = this.chunk.getAddressForReading(0, maxOffset);
+          long addr = this.offHeapData.getAddressForReadingData(0, maxOffset);
-            bb.put(UnsafeMemoryChunk.readAbsoluteByte(addr));
+            bb.put(AddressableMemoryManager.readByte(addr));
-        return this.chunk.getStringForm();
+        return this.offHeapData.getStringForm();
+    /**
+     * Returns true if the given object is off-heap
+     * and it is worth wrapping a reference to it
+     * instead of copying its data to the heap.
+     * Currently all StoredObject's with a refCount are
+     * wrapped.
+     */
+    public static boolean wrapOffHeapReference(Object o) {
+      if (o instanceof StoredObject) {
+        StoredObject so = (StoredObject) o;
+        if (so.hasRefCount()) {
+          // 
+          return true;
+        }
+      }
+      return false;
+    }
+    
-          if (proxy instanceof ObjectChunk) {
-            return new ChunkValueWrapper((ObjectChunk) proxy);
+          if (wrapOffHeapReference(proxy)) {
+            return new OffHeapValueWrapper((StoredObject) proxy);
-          if (proxy instanceof StoredObject) {
-            StoredObject ohproxy = (StoredObject) proxy;
-            isSerializedObject = ohproxy.isSerialized();
-            if (isSerializedObject) {
-              bytes = ohproxy.getSerializedValue();
-            } else {
-              bytes = (byte[]) ohproxy.getDeserializedForReading();
-            }
-          } else {
+          isSerializedObject = proxy.isSerialized();
+          if (isSerializedObject) {
+          } else {
+            bytes = (byte[]) proxy.getDeserializedForReading();
-        // to the file with using the off-heap memory with no extra copying.
+        // to the file using the off-heap memory with no extra copying.
-          if (rawValue instanceof ObjectChunk) {
-            return new ChunkValueWrapper((ObjectChunk) rawValue);
+          if (wrapOffHeapReference(rawValue)) {
+            return new OffHeapValueWrapper((StoredObject) rawValue);
-      if (result instanceof StoredObject) {
-        ((StoredObject) result).release();
-        throw new IllegalStateException("sqlf tried to use getValueInVMOrDiskWithoutFaultIn");
-      }

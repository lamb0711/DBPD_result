GEODE-2929: remove superfluous uses of final from internal classes

-  static final class HashEntry<V> {
+  static class HashEntry<V> {
-    static final <V> HashEntry<V>[] newArray(int i) {
+    static <V> HashEntry<V>[] newArray(int i) {
-  static final class Segment<V> extends ReentrantLock implements Serializable {
+  static class Segment<V> extends ReentrantLock implements Serializable {
-    static final <K, V> Segment<V>[] newArray(int i) {
+    static <K, V> Segment<V>[] newArray(int i) {
-   * final class KeyIterator extends HashIterator implements Iterator<K>, Enumeration<K> { public K
-   * next() { return super.nextEntry().key; } public K nextElement() { return super.nextEntry().key;
-   * } }
+   * class KeyIterator extends HashIterator implements Iterator<K>, Enumeration<K> { public K next()
+   * { return super.nextEntry().key; } public K nextElement() { return super.nextEntry().key; } }
-   * final class ValueIterator extends HashIterator implements Iterator<V>, Enumeration<V> { public
-   * V next() { return super.nextEntry().value; } public V nextElement() { return
+   * class ValueIterator extends HashIterator implements Iterator<V>, Enumeration<V> { public V
+   * next() { return super.nextEntry().value; } public V nextElement() { return
-  // final class WriteThroughEntry
+  // class WriteThroughEntry
-   * final class EntryIterator extends HashIterator implements Iterator<Entry<V>> { public Entry<V>
-   * next() { HashEntry<V> e = super.nextEntry(); return new WriteThroughEntry(e.key, e.value); } }
+   * class EntryIterator extends HashIterator implements Iterator<Entry<V>> { public Entry<V> next()
+   * { HashEntry<V> e = super.nextEntry(); return new WriteThroughEntry(e.key, e.value); } }
-   * final class KeySet extends AbstractSet<K> { public Iterator<K> iterator() { return new
-   * KeyIterator(); } public int size() { return ObjIdConcurrentMap.this.size(); } public boolean
-   * isEmpty() { return ObjIdConcurrentMap.this.isEmpty(); } public boolean contains(Object o) {
-   * return ObjIdConcurrentMap.this.containsKey(o); } public boolean remove(Object o) { return
+   * class KeySet extends AbstractSet<K> { public Iterator<K> iterator() { return new KeyIterator();
+   * } public int size() { return ObjIdConcurrentMap.this.size(); } public boolean isEmpty() {
+   * return ObjIdConcurrentMap.this.isEmpty(); } public boolean contains(Object o) { return
+   * ObjIdConcurrentMap.this.containsKey(o); } public boolean remove(Object o) { return
-   * final class Values extends AbstractCollection<V> { public Iterator<V> iterator() { return new
+   * class Values extends AbstractCollection<V> { public Iterator<V> iterator() { return new
-   * final class EntrySet extends AbstractSet<Map.Entry<K,V>> { public Iterator<Map.Entry<K,V>>
-   * iterator() { return new EntryIterator(); } public boolean contains(Object o) { if (!(o
-   * instanceof Map.Entry)) return false; Map.Entry<?,?> e = (Map.Entry<?,?>)o; V v =
+   * class EntrySet extends AbstractSet<Map.Entry<K,V>> { public Iterator<Map.Entry<K,V>> iterator()
+   * { return new EntryIterator(); } public boolean contains(Object o) { if (!(o instanceof
+   * Map.Entry)) return false; Map.Entry<?,?> e = (Map.Entry<?,?>)o; V v =

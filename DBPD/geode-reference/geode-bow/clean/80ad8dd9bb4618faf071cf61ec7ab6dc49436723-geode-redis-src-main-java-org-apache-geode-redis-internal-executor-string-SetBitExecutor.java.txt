GEODE-8219: Apply RedisResponse to all redis string commands (#5206)


+import org.apache.geode.redis.internal.RedisResponse;
-  public void executeCommand(Command command, ExecutionHandlerContext context) {
+  public RedisResponse executeCommandWithResponse(Command command,
+      ExecutionHandlerContext context) {
-      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ArityDef.SETBIT));
-      return;
+      return RedisResponse.error(ArityDef.SETBIT);
-      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_NOT_INT));
-      return;
+      return RedisResponse.error(ERROR_NOT_INT);
-      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_VALUE));
-      return;
+      return RedisResponse.error(ERROR_VALUE);
-      command
-          .setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_ILLEGAL_OFFSET));
-      return;
+      return RedisResponse.error(ERROR_ILLEGAL_OFFSET);
-      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), 0));
-    } else {
-
-      byte[] bytes = wrapper.toBytes();
-      if (byteIndex < bytes.length) {
-        returnBit = (bytes[byteIndex] & (0x80 >> offset)) >> (7 - offset);
-      } else {
-        returnBit = 0;
-      }
-
-      SetOptions setOptions = new SetOptions(NONE, 0L, true);
-      if (byteIndex < bytes.length) {
-        bytes[byteIndex] = value == 1 ? (byte) (bytes[byteIndex] | (0x80 >> offset))
-            : (byte) (bytes[byteIndex] & ~(0x80 >> offset));
-        stringCommands.set(key, new ByteArrayWrapper(bytes), setOptions);
-      } else {
-        byte[] newBytes = new byte[byteIndex + 1];
-        System.arraycopy(bytes, 0, newBytes, 0, bytes.length);
-        newBytes[byteIndex] = value == 1 ? (byte) (newBytes[byteIndex] | (0x80 >> offset))
-            : (byte) (newBytes[byteIndex] & ~(0x80 >> offset));
-        stringCommands.set(key, new ByteArrayWrapper(newBytes), setOptions);
-      }
-
-      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), returnBit));
+      return RedisResponse.integer(0);
+    byte[] bytes = wrapper.toBytes();
+    if (byteIndex < bytes.length) {
+      returnBit = (bytes[byteIndex] & (0x80 >> offset)) >> (7 - offset);
+    } else {
+      returnBit = 0;
+    }
+
+    SetOptions setOptions = new SetOptions(NONE, 0L, true);
+    if (byteIndex < bytes.length) {
+      bytes[byteIndex] = value == 1 ? (byte) (bytes[byteIndex] | (0x80 >> offset))
+          : (byte) (bytes[byteIndex] & ~(0x80 >> offset));
+      stringCommands.set(key, new ByteArrayWrapper(bytes), setOptions);
+    } else {
+      byte[] newBytes = new byte[byteIndex + 1];
+      System.arraycopy(bytes, 0, newBytes, 0, bytes.length);
+      newBytes[byteIndex] = value == 1 ? (byte) (newBytes[byteIndex] | (0x80 >> offset))
+          : (byte) (newBytes[byteIndex] & ~(0x80 >> offset));
+      stringCommands.set(key, new ByteArrayWrapper(newBytes), setOptions);
+    }
+
+    return RedisResponse.integer(returnBit);

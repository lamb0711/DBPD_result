GEODE-8166: reimplement redis expiration to use new data model (#5174)

* Added timestamp field to RedisData and implemented serialization and delta for it.
Both active and passive expiration have been implemented.

* RedisHash, RedisSet, and RedisString now subclass AbstractRedisData
* type command now uses function
* getset, incr, decr, incrby, and decrby now uses function and is atomic

+
-  private final String ERROR_VALUE_NOT_USABLE =
-      "The value at this key cannot be decremented numerically";
-
-  private final String ERROR_OVERFLOW = "This decrementation cannot be performed due to overflow";
-
-  private final byte[] INIT_VALUE_BYTES = Coder.stringToBytes("-1");
-
-  private final int INIT_VALUE_INT = -1;
-
-    long value;
+    RedisStringCommands stringCommands = getRedisStringCommands(context);
-    /*
-     * Value does not exist
-     */
-    ByteArrayWrapper valueWrapper = getRedisStringCommands(context).get(key);
-
-    if (valueWrapper == null) {
-      byte[] newValue = INIT_VALUE_BYTES;
-      getRedisStringCommands(context).set(key, new ByteArrayWrapper(newValue), null);
-      command
-          .setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), INIT_VALUE_INT));
-      return;
-    }
-
-    /*
-     * Value exists
-     */
-
-    String stringValue = valueWrapper.toString();
-    try {
-      value = Long.parseLong(stringValue);
-    } catch (NumberFormatException e) {
-      command.setResponse(
-          Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_VALUE_NOT_USABLE));
-      return;
-    }
-
-    if (value == Long.MIN_VALUE) {
-      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(), ERROR_OVERFLOW));
-      return;
-    }
-
-    value--;
-
-    stringValue = "" + value;
-    ByteArrayWrapper newValue = new ByteArrayWrapper(Coder.stringToBytes(stringValue));
-    getRedisStringCommands(context).set(key, newValue, null);
-
+    long value = stringCommands.decr(key);

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Called from the client and execute client to server
- * requests against servers. Handles retrying to different servers,
- * and marking servers dead if we get exception from them.
+ * Called from the client and execute client to server requests against servers. Handles retrying to
+ * different servers, and marking servers dead if we get exception from them.
+ * 
-  private static final boolean TRY_SERVERS_ONCE = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.TRY_SERVERS_ONCE");
-  private static final int TX_RETRY_ATTEMPT = Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "txRetryAttempt", 500);
-  
+  private static final boolean TRY_SERVERS_ONCE =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "PoolImpl.TRY_SERVERS_ONCE");
+  private static final int TX_RETRY_ATTEMPT =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "txRetryAttempt", 500);
+
-  private final ThreadLocal<Map<ServerLocation, Connection>> localConnectionMap = new ThreadLocal<Map<ServerLocation,Connection>>();
+  private final ThreadLocal<Map<ServerLocation, Connection>> localConnectionMap =
+      new ThreadLocal<Map<ServerLocation, Connection>>();
-  private /*final*/ PoolImpl pool;
+  private /* final */ PoolImpl pool;
-      return Boolean.FALSE;};
+      return Boolean.FALSE;
+    };
-  private final ThreadLocal<ServerLocation> affinityServerLocation = new ThreadLocal<ServerLocation>();
+  private final ThreadLocal<ServerLocation> affinityServerLocation =
+      new ThreadLocal<ServerLocation>();
-  
-  public OpExecutorImpl(ConnectionManager manager, QueueManager queueManager, EndpointManager endpointManager, RegisterInterestTracker riTracker, int retryAttempts,
-      long serverTimeout, boolean threadLocalConnections, CancelCriterion cancelCriterion, PoolImpl pool)  {
+
+  public OpExecutorImpl(ConnectionManager manager, QueueManager queueManager,
+      EndpointManager endpointManager, RegisterInterestTracker riTracker, int retryAttempts,
+      long serverTimeout, boolean threadLocalConnections, CancelCriterion cancelCriterion,
+      PoolImpl pool) {
-  }  
-  
+  }
+
-  
+
-    
+
-    
+
-    }
-    else if (threadLocalConnections) {
-      //Fix for 43718. Clear the thread local connection
-      //while we're performing the op. It will be reset
-      //if the op succeeds.
+    } else if (threadLocalConnections) {
+      // Fix for 43718. Clear the thread local connection
+      // while we're performing the op. It will be reset
+      // if the op succeeds.
-      }
-      catch (ConnectionDestroyedException ex) {
+      } catch (ConnectionDestroyedException ex) {
-      for(int attempt = 0; true; attempt++) {
+      for (int attempt = 0; true; attempt++) {
-          AbstractOp absOp = (AbstractOp)op;
+          AbstractOp absOp = (AbstractOp) op;
-        }
-        catch (Exception e) {
-          //This method will throw an exception if we need to stop
-          //It also unsets the threadlocal connection and notifies
-          //the connection manager if there are failures.
+        } catch (Exception e) {
+          // This method will throw an exception if we need to stop
+          // It also unsets the threadlocal connection and notifies
+          // the connection manager if there are failures.
-          }
-          catch(NoAvailableServersException nse) {
-            //if retries is -1, don't try again after the last server has failed
-            if(retries == -1 || TRY_SERVERS_ONCE) {
+          } catch (NoAvailableServersException nse) {
+            // if retries is -1, don't try again after the last server has failed
+            if (retries == -1 || TRY_SERVERS_ONCE) {
-            }
-            else {
-              //try one of the failed servers again, until we exceed the retry attempts.
+            } else {
+              // try one of the failed servers again, until we exceed the retry attempts.
-              }
-              catch(NoAvailableServersException nse2) {
+              } catch (NoAvailableServersException nse2) {
-      if(threadLocalConnections) {
+      if (threadLocalConnections) {
-        //Fix for 43718. If the thread local was set to a different
-        //connection deeper in the call stack, return that connection
-        //and set our connection on the thread local.
+        // Fix for 43718. If the thread local was set to a different
+        // connection deeper in the call stack, return that connection
+        // and set our connection on the thread local.
-        if(existingConnection != null && existingConnection != conn) {
+        if (existingConnection != null && existingConnection != conn) {
-        
-        if(!conn.isDestroyed()) {
+
+        if (!conn.isDestroyed()) {
-   * execute the given op on the given server. If the server cannot
-   * be reached, sends a TXFailoverOp, then retries the given op
+   * execute the given op on the given server. If the server cannot be reached, sends a
+   * TXFailoverOp, then retries the given op
+   * 
-      if ((retryAttempts != -1 && retryCount >= retryAttempts) ||
-          retryCount > TX_RETRY_ATTEMPT) { // prevent stack overflow fixes bug 46535
+      if ((retryAttempts != -1 && retryCount >= retryAttempts) || retryCount > TX_RETRY_ATTEMPT) { // prevent
+                                                                                                   // stack
+                                                                                                   // overflow
+                                                                                                   // fixes
+                                                                                                   // bug
+                                                                                                   // 46535
-    if(op instanceof ExecuteRegionFunctionOpImpl){
-      op = new ExecuteRegionFunctionOpImpl(
-          (ExecuteRegionFunctionOpImpl)op, (byte)1/*isReExecute*/, new HashSet<String>());
-      ((ExecuteRegionFunctionOpImpl)op).getMessage().setTransactionId(transactionId);
-    }else if (op instanceof ExecuteFunctionOpImpl){
-      op = new ExecuteFunctionOpImpl(
-          (ExecuteFunctionOpImpl)op, (byte)1/*isReExecute*/);
-      ((ExecuteFunctionOpImpl)op).getMessage().setTransactionId(transactionId);
+    if (op instanceof ExecuteRegionFunctionOpImpl) {
+      op = new ExecuteRegionFunctionOpImpl((ExecuteRegionFunctionOpImpl) op,
+          (byte) 1/* isReExecute */, new HashSet<String>());
+      ((ExecuteRegionFunctionOpImpl) op).getMessage().setTransactionId(transactionId);
+    } else if (op instanceof ExecuteFunctionOpImpl) {
+      op = new ExecuteFunctionOpImpl((ExecuteFunctionOpImpl) op, (byte) 1/* isReExecute */);
+      ((ExecuteFunctionOpImpl) op).getMessage().setTransactionId(transactionId);
-  
+
-  
+
-  
+
-  
+
-    this.connectionManager.returnConnection(conn);
+      this.connectionManager.returnConnection(conn);
-  
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.client.internal.OpExecutor#executeOn(org.apache.geode.distributed.internal.ServerLocation, org.apache.geode.cache.client.internal.Op)
+
+  /*
+   * (non-Javadoc)
+   * 
+   * @see org.apache.geode.cache.client.internal.OpExecutor#executeOn(org.apache.geode.distributed.
+   * internal.ServerLocation, org.apache.geode.cache.client.internal.Op)
-    return executeOn(server, op, true,false);
+    return executeOn(server, op, true, false);
-  public Object executeOn(ServerLocation p_server, Op op, boolean accessed,boolean onlyUseExistingCnx) {
+
+  public Object executeOn(ServerLocation p_server, Op op, boolean accessed,
+      boolean onlyUseExistingCnx) {
-  private Object executeOnServer(ServerLocation p_server, Op op, boolean accessed,boolean onlyUseExistingCnx) {
+
+  private Object executeOnServer(ServerLocation p_server, Op op, boolean accessed,
+      boolean onlyUseExistingCnx) {
-        Endpoint ep = (Endpoint)this.endpointManager.getEndpointMap().get(server);
+        Endpoint ep = (Endpoint) this.endpointManager.getEndpointMap().get(server);
-        conn = connectionManager.borrowConnection(server, serverTimeout,onlyUseExistingCnx);
+        conn = connectionManager.borrowConnection(server, serverTimeout, onlyUseExistingCnx);
-      //This method will throw an exception if we need to stop
-      //It also unsets the threadlocal connection and notifies
-      //the connection manager if there are failures.
+      // This method will throw an exception if we need to stop
+      // It also unsets the threadlocal connection and notifies
+      // the connection manager if there are failures.
-      //this shouldn't actually be reached, handle exception will throw something
+      // this shouldn't actually be reached, handle exception will throw something
-          logger.debug("setting server affinity to {} server:{}", conn.getEndpoint().getMemberId(), conn.getServer());
+          logger.debug("setting server affinity to {} server:{}", conn.getEndpoint().getMemberId(),
+              conn.getServer());
-   * gets a connection to the given serverLocation either by looking up the threadLocal {@link #localConnectionMap}.
-   * If a connection does not exist (or has been destroyed) we borrow one from connectionManager.
+   * gets a connection to the given serverLocation either by looking up the threadLocal
+   * {@link #localConnectionMap}. If a connection does not exist (or has been destroyed) we borrow
+   * one from connectionManager.
+   * 
-  private Connection getActivatedThreadLocalConnectionForSingleHop(ServerLocation server, boolean onlyUseExistingCnx) {
+  private Connection getActivatedThreadLocalConnectionForSingleHop(ServerLocation server,
+      boolean onlyUseExistingCnx) {
-  
+
-   * initializes the threadLocal {@link #localConnectionMap} and adds mapping
-   * of serverLocation to Connection.
+   * initializes the threadLocal {@link #localConnectionMap} and adds mapping of serverLocation to
+   * Connection.
-  private void setThreadLocalConnectionForSingleHop(ServerLocation server,
-      Connection conn) {
+  private void setThreadLocalConnectionForSingleHop(ServerLocation server, Connection conn) {
-   * @see org.apache.geode.cache.client.internal.ExecutablePool#executeOnPrimary(org.apache.geode.cache.client.internal.Op)
+   * 
+   * @see
+   * org.apache.geode.cache.client.internal.ExecutablePool#executeOnPrimary(org.apache.geode.cache.
+   * client.internal.Op)
-    if(queueManager == null) {
+    if (queueManager == null) {
-    
+
-    while(true) {
+    while (true) {
-        boolean finalAttempt = ! attemptedPrimaries.add(primary.getServer());
+        boolean finalAttempt = !attemptedPrimaries.add(primary.getServer());
-        //we shouldn't reach this code, but just in case
-        if(finalAttempt) {
+        // we shouldn't reach this code, but just in case
+        if (finalAttempt) {
-  
+
-    if(queueManager == null) {
+    if (queueManager == null) {
-    
+
-    
+
-    if(primary != null) {
+    if (primary != null) {
-        } catch(RuntimeException e2) {
+        } catch (RuntimeException e2) {
-    for(int i = 0; i < backups.size(); i++) {
+    for (int i = 0; i < backups.size(); i++) {
-        } catch(RuntimeException e2) {
+        } catch (RuntimeException e2) {
-    
+
-   * @see org.apache.geode.cache.client.internal.ExecutablePool#executeOnAllQueueServers(org.apache.geode.cache.client.internal.Op)
+   * 
+   * @see
+   * org.apache.geode.cache.client.internal.ExecutablePool#executeOnAllQueueServers(org.apache.geode
+   * .cache.client.internal.Op)
-    if(queueManager == null) {
+    if (queueManager == null) {
-    
+
-    for(int i = backups.size() - 1; i >= 0; i--) {
+    for (int i = backups.size() - 1; i >= 0; i--) {
-      } catch (Exception e)  {
+      } catch (Exception e) {
-    while(true) {
+    while (true) {
-          logger.trace(LogMarker.BRIDGE_SERVER, "caught exception sending to primary {}", e.getMessage(), e);
+          logger.trace(LogMarker.BRIDGE_SERVER, "caught exception sending to primary {}",
+              e.getMessage(), e);
-        //we shouldn't reach this code, but just in case
-        if(finalAttempt) {
+        // we shouldn't reach this code, but just in case
+        if (finalAttempt) {
-    if(conn != null) {
+    if (conn != null) {
-      //This method will throw an exception if we need to stop
-      //It also unsets the threadlocal connection and notifies
-      //the connection manager if there are failures.
-      handleException(op, e, conn, 0,  true, timeoutFatal);
-      //this shouldn't actually be reached, handle exception will throw something
+      // This method will throw an exception if we need to stop
+      // It also unsets the threadlocal connection and notifies
+      // the connection manager if there are failures.
+      handleException(op, e, conn, 0, true, timeoutFatal);
+      // this shouldn't actually be reached, handle exception will throw something
-    } 
+    }
+
-  
-  protected void handleException(Throwable e, 
-                                 Connection conn,
-                                 int retryCount, boolean finalAttempt) {
-    handleException(e, conn, retryCount, finalAttempt, false/*timeoutFatal*/);
+
+  protected void handleException(Throwable e, Connection conn, int retryCount,
+      boolean finalAttempt) {
+    handleException(e, conn, retryCount, finalAttempt, false/* timeoutFatal */);
-  protected void handleException(Op op, 
-                                 Throwable e,
-                                 Connection conn,
-                                 int retryCount,
-                                 boolean finalAttempt,
-                                 boolean timeoutFatal)
-  throws CacheRuntimeException {
+  protected void handleException(Op op, Throwable e, Connection conn, int retryCount,
+      boolean finalAttempt, boolean timeoutFatal) throws CacheRuntimeException {
-        throw (GemFireSecurityException)e;
+        throw (GemFireSecurityException) e;
-        throw (ServerRefusedConnectionException)e;
+        throw (ServerRefusedConnectionException) e;
-  protected void handleException(Throwable e, 
-                                 Connection conn,
-                                 int retryCount,
-                                 boolean finalAttempt,
-                                 boolean timeoutFatal)
-  throws CacheRuntimeException 
-  {
+  protected void handleException(Throwable e, Connection conn, int retryCount, boolean finalAttempt,
+      boolean timeoutFatal) throws CacheRuntimeException {
-    
+
-    if(logger.isDebugEnabled() && !(e instanceof java.io.EOFException)) {
-      if (e instanceof java.io.EOFException){
+    if (logger.isDebugEnabled() && !(e instanceof java.io.EOFException)) {
+      if (e instanceof java.io.EOFException) {
-        logger.debug("OpExecutor.handleException on Connection to {} read timed out", conn.getServer());
+        logger.debug("OpExecutor.handleException on Connection to {} read timed out",
+            conn.getServer());
-        logger.debug("OpExecutor.handleException on Connection to {}", conn.getServer(),e);
+        logger.debug("OpExecutor.handleException on Connection to {}", conn.getServer(), e);
-    
+
-    
+
-    }
-    else if (e instanceof NotSerializableException) {
-      title = null; //no message
+    } else if (e instanceof NotSerializableException) {
+      title = null; // no message
-    }
-    else if (e instanceof BatchException || e instanceof BatchException70) {
-      title = null; //no message
+    } else if (e instanceof BatchException || e instanceof BatchException70) {
+      title = null; // no message
-    }
-    else if (e instanceof RegionDestroyedException) {
+    } else if (e instanceof RegionDestroyedException) {
-      exToThrow =(RegionDestroyedException) e;
-    }
-    else if (e instanceof GemFireSecurityException) {
+      exToThrow = (RegionDestroyedException) e;
+    } else if (e instanceof GemFireSecurityException) {
-    }
-    else if (e instanceof SerializationException) {
+    } else if (e instanceof SerializationException) {
-    }
-    else if (e instanceof CopyException) {
+    } else if (e instanceof CopyException) {
-    }
-    else if (e instanceof ClassNotFoundException) {
+    } else if (e instanceof ClassNotFoundException) {
-    }
-    else if (e instanceof TransactionException) {
+    } else if (e instanceof TransactionException) {
-      exToThrow = (TransactionException)e;
+      exToThrow = (TransactionException) e;
-    }
-    else if (e instanceof SynchronizationCommitConflictException) {
+    } else if (e instanceof SynchronizationCommitConflictException) {
-      exToThrow = (SynchronizationCommitConflictException)e;
+      exToThrow = (SynchronizationCommitConflictException) e;
-    }
-    else if (e instanceof SocketException) {
-      if ("Socket closed".equals(e.getMessage())
-          || "Connection reset".equals(e.getMessage())
+    } else if (e instanceof SocketException) {
+      if ("Socket closed".equals(e.getMessage()) || "Connection reset".equals(e.getMessage())
-    }
-    else if (e instanceof SocketTimeoutException) {
+    } else if (e instanceof SocketTimeoutException) {
-    }
-    else if (e instanceof ConnectionDestroyedException) {
+    } else if (e instanceof ConnectionDestroyedException) {
-    }
-    else if (e instanceof java.io.EOFException) {
+    } else if (e instanceof java.io.EOFException) {
-//      it is still listening so make this into a timeout exception
-        invalidateServer = false;
-        title = "socket closed on server";
-        SocketTimeoutException ste = new SocketTimeoutException(title);
-        ste.setStackTrace(e.getStackTrace());
-        e = ste;
-        cause = null;
-        */ 
-      
+       * // it is still listening so make this into a timeout exception invalidateServer = false;
+       * title = "socket closed on server"; SocketTimeoutException ste = new
+       * SocketTimeoutException(title); ste.setStackTrace(e.getStackTrace()); e = ste; cause = null;
+       */
+
-       * note: the old code in ConnectionProxyImpl used to create a new socket here to the server to determine if it really crashed.
-       * We may have to add this back in for some reason, but hopefully not.
+       * note: the old code in ConnectionProxyImpl used to create a new socket here to the server to
+       * determine if it really crashed. We may have to add this back in for some reason, but
+       * hopefully not.
-       * note 05/21/08: an attempt to address this was made by increasing the time waited on server before closing timeoutd clients
-       * see ServerConnection.hasBeenTimedOutOnClient
+       * note 05/21/08: an attempt to address this was made by increasing the time waited on server
+       * before closing timeoutd clients see ServerConnection.hasBeenTimedOutOnClient
-    }
-    else if (e instanceof IOException) {
+    } else if (e instanceof IOException) {
-    }
-    else if (e instanceof BufferUnderflowException) {
+    } else if (e instanceof BufferUnderflowException) {
-    }
-    else if (e instanceof CancelException) {
+    } else if (e instanceof CancelException) {
-    }
-    else if (e instanceof InternalFunctionInvocationTargetException) {  
-      //In this case, function will be re executed
+    } else if (e instanceof InternalFunctionInvocationTargetException) {
+      // In this case, function will be re executed
-      exToThrow = (InternalFunctionInvocationTargetException)e;
-    }
-    else if (e instanceof FunctionInvocationTargetException) {  
-      //in this case function will not be re executed
-      title = null; 
-      exToThrow = (GemFireException)e;
-    }
-    else if (e instanceof PutAllPartialResultException) {
+      exToThrow = (InternalFunctionInvocationTargetException) e;
+    } else if (e instanceof FunctionInvocationTargetException) {
+      // in this case function will not be re executed
-      exToThrow =(PutAllPartialResultException) e;
+      exToThrow = (GemFireException) e;
+    } else if (e instanceof PutAllPartialResultException) {
+      title = null;
+      exToThrow = (PutAllPartialResultException) e;
-    }
-    else {
+    } else {
-      if ((t instanceof ConnectException)
-          || (t instanceof SocketException)
-          || (t instanceof SocketTimeoutException)
-          || (t instanceof IOException)
-          || (t instanceof SerializationException)
-          || (t instanceof CopyException)
-          || (t instanceof GemFireSecurityException)
-          || (t instanceof ServerOperationException)
-          || (t instanceof TransactionException)
-          || (t instanceof CancelException)) {
-        handleException(t,  conn, retryCount, finalAttempt, timeoutFatal);
+      if ((t instanceof ConnectException) || (t instanceof SocketException)
+          || (t instanceof SocketTimeoutException) || (t instanceof IOException)
+          || (t instanceof SerializationException) || (t instanceof CopyException)
+          || (t instanceof GemFireSecurityException) || (t instanceof ServerOperationException)
+          || (t instanceof TransactionException) || (t instanceof CancelException)) {
+        handleException(t, conn, retryCount, finalAttempt, timeoutFatal);
-          title = null; // no message
-          exToThrow = (ServerOperationException)e;
-          invalidateServer = false; // fix for bug #42225
-      }
-      else if (e instanceof FunctionException) {
+        title = null; // no message
+        exToThrow = (ServerOperationException) e;
+        invalidateServer = false; // fix for bug #42225
+      } else if (e instanceof FunctionException) {
-        }
-        else {
+        } else {
-          exToThrow = (FunctionException)e;
+          exToThrow = (FunctionException) e;
-          && e.getMessage()
-              .equals("Connection error while authenticating user")) {
+          && e.getMessage().equals("Connection error while authenticating user")) {
-      if(invalidateServer) {
+      if (invalidateServer) {
-            logger.warn(msg /*, e*/);
+            logger.warn(msg /* , e */);
-            logger.debug(msg /*, e*/);
+            logger.debug(msg /* , e */);
-  
-  private StringBuffer getExceptionMessage(String exceptionName, 
-      int retryCount,
-      boolean finalAttempt,
-      Connection connection,
-      Throwable ex) {
+
+  private StringBuffer getExceptionMessage(String exceptionName, int retryCount,
+      boolean finalAttempt, Connection connection, Throwable ex) {
-    message
-    .append("Pool unexpected ")
-    .append(exceptionName);
+    message.append("Pool unexpected ").append(exceptionName);
-      message
-      .append(" connection=")
-      .append(connection);
+      message.append(" connection=").append(connection);
-      message
-      .append(" attempt=")
-      .append(retryCount+1);
+      message.append(" attempt=").append(retryCount + 1);
-      message
-      .append(". Server unreachable: could not connect after ")
-      .append(retryCount+1)
-      .append(" attempts");
+      message.append(". Server unreachable: could not connect after ").append(retryCount + 1)
+          .append(" attempts");
-    
+
-      PoolImpl poolImpl = (PoolImpl)PoolManagerImpl.getPMI().find(
-          this.endpointManager.getPoolName());
+      PoolImpl poolImpl =
+          (PoolImpl) PoolManagerImpl.getPMI().find(this.endpointManager.getPoolName());
-      if (((AbstractOp)op).needsUserId()) {
+      if (((AbstractOp) op).needsUserId()) {
-    } else if (((AbstractOp)op).needsUserId()) {
+    } else if (((AbstractOp) op).needsUserId()) {
-        conn.getServer().setUserId(
-            (Long)AuthenticateUserOp.executeOn(connImpl, this.pool));
+        conn.getServer().setUserId((Long) AuthenticateUserOp.executeOn(connImpl, this.pool));
-          logger.debug("OpExecutorImpl.execute() - single user mode - authenticated this user on {}", conn);
+          logger.debug(
+              "OpExecutorImpl.execute() - single user mode - authenticated this user on {}", conn);
-  private void authenticateMultiuser(PoolImpl pool, Connection conn,
-      UserAttributes ua) {
+  private void authenticateMultiuser(PoolImpl pool, Connection conn, UserAttributes ua) {
-      Long userId = (Long)AuthenticateUserOp.executeOn(conn.getServer(),
-          pool, ua.getCredentials());
+      Long userId =
+          (Long) AuthenticateUserOp.executeOn(conn.getServer(), pool, ua.getCredentials());
-          logger.debug("OpExecutorImpl.execute() - multiuser mode - authenticated this user on {}", conn);
+          logger.debug("OpExecutorImpl.execute() - multiuser mode - authenticated this user on {}",
+              conn);
-      if (cause instanceof SocketException
-          || cause instanceof EOFException
-          || cause instanceof IOException
-          || cause instanceof BufferUnderflowException
+      if (cause instanceof SocketException || cause instanceof EOFException
+          || cause instanceof IOException || cause instanceof BufferUnderflowException
-          || (sce.getMessage() != null && (sce.getMessage().indexOf(
-              "Could not create a new connection to server") != -1
-              || sce.getMessage().indexOf("socket timed out on client") != -1 || sce
-              .getMessage().indexOf(
-                  "connection was asynchronously destroyed") != -1))) {
-        throw new ServerConnectivityException(
-            "Connection error while authenticating user");
+          || (sce.getMessage() != null
+              && (sce.getMessage().indexOf("Could not create a new connection to server") != -1
+                  || sce.getMessage().indexOf("socket timed out on client") != -1
+                  || sce.getMessage().indexOf("connection was asynchronously destroyed") != -1))) {
+        throw new ServerConnectivityException("Connection error while authenticating user");
-  private Object executeWithPossibleReAuthentication(Connection conn, Op op)
-      throws Exception {
+  private Object executeWithPossibleReAuthentication(Connection conn, Op op) throws Exception {
-          && "User authorization attributes not found.".equals(cause
-              .getMessage())) 
-          || sce.getMessage().contains(
-              "Connection error while authenticating user")) {
+          && "User authorization attributes not found.".equals(cause.getMessage()))
+          || sce.getMessage().contains("Connection error while authenticating user")) {
-        PoolImpl pool = (PoolImpl)PoolManagerImpl.getPMI().find(
-            this.endpointManager.getPoolName());
+        PoolImpl pool =
+            (PoolImpl) PoolManagerImpl.getPMI().find(this.endpointManager.getPoolName());
-          conn.getServer().setUserId(
-              (Long)AuthenticateUserOp.executeOn(connImpl, this));
+          conn.getServer().setUserId((Long) AuthenticateUserOp.executeOn(connImpl, this));

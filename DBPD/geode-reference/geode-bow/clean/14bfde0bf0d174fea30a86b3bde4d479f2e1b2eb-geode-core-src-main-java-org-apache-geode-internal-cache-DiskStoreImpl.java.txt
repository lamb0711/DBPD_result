Merge branch 'release/1.8.0'

+import java.util.concurrent.ExecutorService;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.ThreadPoolExecutor;
-import org.apache.geode.i18n.StringId;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.LoggingThreadGroup;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+import org.apache.geode.internal.logging.LoggingExecutors;
+import org.apache.geode.internal.logging.LoggingThread;
-  private final ThreadPoolExecutor diskStoreTaskPool;
+  private final ExecutorService diskStoreTaskPool;
-  private final ThreadPoolExecutor delayedWritePool;
+  private final ExecutorService delayedWritePool;
-    int MAXT = DiskStoreImpl.MAX_CONCURRENT_COMPACTIONS;
-    final ThreadGroup compactThreadGroup =
-        LoggingThreadGroup.createThreadGroup("Oplog Compactor Thread Group", logger);
-    final ThreadFactory compactThreadFactory =
-        GemfireCacheHelper.CreateThreadFactory(compactThreadGroup, "Idle OplogCompactor");
-    this.diskStoreTaskPool = new ThreadPoolExecutor(MAXT, MAXT, 10, TimeUnit.SECONDS,
-        new LinkedBlockingQueue(), compactThreadFactory);
-    this.diskStoreTaskPool.allowCoreThreadTimeOut(true);
-
-
-    final ThreadGroup deleteThreadGroup =
-        LoggingThreadGroup.createThreadGroup("Oplog Delete Thread Group", logger);
-
-    final ThreadFactory deleteThreadFactory =
-        GemfireCacheHelper.CreateThreadFactory(deleteThreadGroup, "Oplog Delete Task");
-    this.delayedWritePool = new ThreadPoolExecutor(1, 1, 10, TimeUnit.SECONDS,
-        new LinkedBlockingQueue(MAX_PENDING_TASKS), deleteThreadFactory,
-        new ThreadPoolExecutor.CallerRunsPolicy());
-    this.delayedWritePool.allowCoreThreadTimeOut(true);
+    this.diskStoreTaskPool = LoggingExecutors.newFixedThreadPoolWithFeedSize("Idle OplogCompactor",
+        MAX_CONCURRENT_COMPACTIONS, Integer.MAX_VALUE);
+    this.delayedWritePool =
+        LoggingExecutors.newFixedThreadPoolWithFeedSize("Oplog Delete Task", 1, MAX_PENDING_TASKS);
-              LocalizedStrings.DiskRegion_THE_DISKREGION_HAS_BEEN_CLOSED_OR_DESTROYED
-                  .toLocalizedString(),
+              "The DiskRegion has been closed or destroyed",
-              LocalizedStrings.DiskRegion_CLEAR_OPERATION_ABORTING_THE_ONGOING_ENTRY_0_OPERATION_FOR_ENTRY_WITH_DISKID_1
-                  .toLocalizedString(
-                      new Object[] {((doingCreate) ? "creation" : "modification"), id}));
+              String.format(
+                  "Clear operation aborting the ongoing Entry %s operation for Entry with DiskId, %s",
+
+                  new Object[] {((doingCreate) ? "creation" : "modification"), id}));
-            LocalizedStrings.DiskRegion_THE_DISKREGION_HAS_BEEN_CLOSED_OR_DESTROYED
-                .toLocalizedString(),
+            "The DiskRegion has been closed or destroyed",
-                LocalizedStrings.DiskRegion_THE_DISKREGION_HAS_BEEN_CLOSED_OR_DESTROYED
-                    .toLocalizedString(),
+                "The DiskRegion has been closed or destroyed",
-          LocalizedStrings.DiskRegion_THE_DISKREGION_HAS_BEEN_CLOSED_OR_DESTROYED
-              .toLocalizedString(),
+          "The DiskRegion has been closed or destroyed",
-          LocalizedStrings.DiskRegion_DATA_FOR_DISKENTRY_HAVING_DISKID_AS_0_COULD_NOT_BE_OBTAINED_FROM_DISK_A_CLEAR_OPERATION_MAY_HAVE_DELETED_THE_OPLOGS
-              .toLocalizedString(id),
+          String.format(
+              "Data  for DiskEntry having DiskId as %s could not be obtained from Disk. A clear operation may have deleted the oplogs",
+              id),
-            LocalizedStrings.DiskRegion_THE_DISKREGION_HAS_BEEN_CLOSED_OR_DESTROYED
-                .toLocalizedString(),
+            "The DiskRegion has been closed or destroyed",
-            LocalizedStrings.DiskRegion_ENTRY_HAS_BEEN_CLEARED_AND_IS_NOT_PRESENT_ON_DISK
-                .toLocalizedString(),
+            "Entry has been cleared and is not present on disk",
-            LocalizedStrings.DiskRegion_ENTRY_HAS_BEEN_CLEARED_AND_IS_NOT_PRESENT_ON_DISK
-                .toLocalizedString(),
+            "Entry has been cleared and is not present on disk",
-            LocalizedStrings.DiskRegion_THE_DISKREGION_HAS_BEEN_CLOSED_OR_DESTROYED
-                .toLocalizedString(),
+            "The DiskRegion has been closed or destroyed",
-            LocalizedStrings.DiskRegion_THE_DISKREGION_HAS_BEEN_CLOSED_OR_DESTROYED
-                .toLocalizedString(),
+            "The DiskRegion has been closed or destroyed",
-            LocalizedStrings.DiskRegion_CLEAR_OPERATION_ABORTING_THE_ONGOING_ENTRY_DESTRUCTION_OPERATION_FOR_ENTRY_WITH_DISKID_0
-                .toLocalizedString(entry.getDiskId()));
+            String.format(
+                "Clear operation aborting the ongoing Entry destruction operation for Entry with DiskId, %s",
+                entry.getDiskId()));
-        LocalizedStrings.DiskRegion_ASYNCHRONOUS_DISK_WRITER_0.toLocalizedString(getName());
-    this.flusherThread = new Thread(
-        LoggingThreadGroup.createThreadGroup(
-            LocalizedStrings.DiskRegion_DISK_WRITERS.toLocalizedString(), logger),
-        new FlusherThread(this), thName);
-    this.flusherThread.setDaemon(true);
+        String.format("Asynchronous disk writer for region %s", getName());
+    this.flusherThread = new LoggingThread(thName, new FlusherThread(this));
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.DiskStoreImpl_FATAL_ERROR_ON_FLUSH),
+        logger.fatal("Fatal error from asynchronous flusher thread",
-            LocalizedStrings.DiskStoreImpl_FATAL_ERROR_ON_FLUSH.toLocalizedString(), t, diskStore);
+            "Fatal error from asynchronous flusher thread", t, diskStore);
-          throw new IOException(LocalizedStrings.Oplog_THE_FILE_0_IS_BEING_USED_BY_ANOTHER_PROCESS
-              .toLocalizedString(f));
+          throw new IOException(String.format("The file %s is being used by another process.",
+              f));
-            LocalizedStrings.Oplog_COULD_NOT_LOCK_0.toLocalizedString(f.getPath()), ex, this);
+            String.format(
+                "Could not lock %s. Other JVMs might have created diskstore with same name using the same directory.",
+                f.getPath()),
+            ex, this);
-                + LocalizedStrings.DiskStoreAlreadyInVersion_0
-                    .toLocalizedString(getRecoveredGFVersionName()));
+                + String.format("This disk store is already at version %s.",
+                    getRecoveredGFVersionName()));
-                + LocalizedStrings.DiskStoreStillAtVersion_0
-                    .toLocalizedString(getRecoveredGFVersionName()));
+                + String.format("This disk store is still at version %s.",
+                    getRecoveredGFVersionName()));
-            LocalizedMessage.create(LocalizedStrings.DiskStoreImpl_RecoveredDiskStore_0_With_Id_1,
-                new Object[] {getName(), getDiskStoreID()}));
+            "Recovered disk store {} with unique id {}",
+            getName(), getDiskStoreID());
-            LocalizedMessage.create(LocalizedStrings.DiskStoreImpl_CreatedDiskStore_0_With_Id_1,
-                new Object[] {getName(), getDiskStoreID()}));
+            "Created disk store {} with unique id {}",
+            getName(), getDiskStoreID());
-                  LocalizedStrings.DiskRegion_THE_DISKREGION_HAS_BEEN_CLOSED_OR_DESTROYED
-                      .toLocalizedString(),
+                  "The DiskRegion has been closed or destroyed",
-          logger.warn(
-              LocalizedMessage.create(
-                  LocalizedStrings.DiskRegion_COMPLEXDISKREGION_CLOSE_EXCEPTION_IN_STOPPING_COMPACTOR),
-              e);
+          logger.warn("DiskRegion::close: Exception in stopping compactor", e);
-        for (int i = 0; i < oplogs.length && keepCompactorRunning() /*
-                                                                     * @todo && !owner. isDestroyed
-                                                                     */; i++) {
+        for (int i = 0; i < oplogs.length && keepCompactorRunning(); i++) {
-        // TODO:Asif : DiskRegion: How do we tackle
-      logger.info(LocalizedMessage.create(LocalizedStrings.DiskRegion_COMPACTION_SUMMARY,
-          new Object[] {totalCount, ((endTime - start) / 1000000)}));
-      return true /* @todo !owner.isDestroyed */;
+      logger.info("compaction did {} creates and updates in {} ms",
+          totalCount, ((endTime - start) / 1000000));
+      return true;
-          logger.info(LocalizedMessage.create(LocalizedStrings.DiskRegion_COMPACTION_OPLOGIDS,
-              new Object[] {getName(), ids}));
+          logger.info("OplogCompactor for {} compaction oplog id(s): {}",
+              getName(), ids);
-            logger.warn(LocalizedMessage.create(LocalizedStrings.DiskRegion_COMPACTION_FAILURE,
-                new Object[] {getName(), ids}));
+            logger.warn("OplogCompactor for {} did NOT complete compaction of oplog id(s): {}",
+                getName(), ids);
-                logger.warn(LocalizedMessage.create(
-                    LocalizedStrings.DisKRegion_OUTSTANDING_OPS_REMAIN_AFTER_0_SECONDS_FOR_DISK_REGION_1,
-                    new Object[] {loopCount, dr.getName()}));
+                logger.warn("Outstanding ops remain after {} seconds for disk region {}",
+                    loopCount, dr.getName());
-                logger.info(LocalizedMessage.create(
-                    LocalizedStrings.DisKRegion_OUTSTANDING_OPS_CLEARED_FOR_DISK_REGION_0,
-                    dr.getName()));
+                logger.info("Outstanding ops cleared for disk region {}",
+                    dr.getName());
-    final StringId sid =
-        LocalizedStrings.LocalRegion_A_DISKACCESSEXCEPTION_HAS_OCCURRED_WHILE_WRITING_TO_THE_DISK_FOR_DISKSTORE_0_THE_CACHE_WILL_BE_CLOSED;
-    logger.error(LocalizedMessage.create(sid, DiskStoreImpl.this.getName()), dae);
+    final String message = String.format(
+        "A DiskAccessException has occurred while writing to the disk for disk store %s. The cache will be closed.",
+        getName());
+    logger.error(message, dae);
-    final ThreadGroup exceptionHandlingGroup =
-        LoggingThreadGroup.createThreadGroup("Disk Store Exception Handling Group", logger);
-
-    Thread thread = new Thread(exceptionHandlingGroup, "Disk store exception handler") {
-      public void run() {
-        try {
-          // now close the cache
-          getCache().close(sid.toLocalizedString(DiskStoreImpl.this.getName(), dae), dae);
-          _testHandleDiskAccessException.countDown();
-
-        } catch (Exception e) {
-          logger.error(LocalizedMessage.create(
-              LocalizedStrings.LocalRegion_AN_EXCEPTION_OCCURRED_WHILE_CLOSING_THE_CACHE), e);
-        }
+    Thread thread = new LoggingThread("Disk store exception handler", false, () -> {
+      try {
+        // now close the cache
+        getCache().close(message, dae);
+        _testHandleDiskAccessException.countDown();
+      } catch (Exception e) {
+        logger.error("An Exception occurred while closing the cache.", e);
-    };
+    });
-    return executeDiskStoreAsyncTask(runnable, this.diskStoreTaskPool);
+    return executeAsyncTask(runnable, this.diskStoreTaskPool);
-    Future<?> f = executeDiskStoreTask(task, this.delayedWritePool);
+    Future<?> f = executeTask(task, this.delayedWritePool);
-  private Future<?> executeDiskStoreTask(final Runnable runnable, ThreadPoolExecutor executor) {
+  private Future<?> executeTask(final Runnable runnable, ExecutorService executor) {
-  private boolean executeDiskStoreAsyncTask(final Runnable runnable, ThreadPoolExecutor executor) {
+  private boolean executeAsyncTask(final Runnable runnable, ExecutorService executor) {
-  private Future<?> executeDiskStoreTask(DiskStoreTask r, ThreadPoolExecutor executor) {
+  private Future<?> executeDiskStoreTask(DiskStoreTask r, ExecutorService executor) {
-  private boolean executeDiskStoreAsyncTask(DiskStoreTask r, ThreadPoolExecutor executor) {
+  private boolean executeDiskStoreAsyncTask(DiskStoreTask r, ExecutorService executor) {
-            LocalizedStrings.DiskRegion_THE_DISKREGION_HAS_BEEN_CLOSED_OR_DESTROYED
-                .toLocalizedString(),
+            "The DiskRegion has been closed or destroyed",
-            LocalizedStrings.DiskRegion_THE_DISKREGION_HAS_BEEN_CLOSED_OR_DESTROYED
-                .toLocalizedString(),
+            "The DiskRegion has been closed or destroyed",

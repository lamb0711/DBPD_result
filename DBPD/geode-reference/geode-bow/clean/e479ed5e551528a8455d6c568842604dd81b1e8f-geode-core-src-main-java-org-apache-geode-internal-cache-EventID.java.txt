GEODE-3072: Events do not get removed from the client queue for 1.0 clients

EventID and ThreadIdentifier hold the serialized form of portions of an
InternalDistributedMember identifier.  This serialized form changed in
v1.0.0 and was causing .equals and .hashCode for these objects to return
false when they should have returned true owing to additional data being
in the serialized form of the identifier.

This change set modifies the equals and hashCode methods of the classes
to ensure that they return the correct results in the presence of this
additional ID data.

I created a dunit test to reproduce the problem but I think the behavior
of HARegionQueues isn't reliable enough to check in that test.  I'm
afraid that it would end up being a "flaky" test that fails periodically.
Instead, I'm relying on a new junit test and the test that Barry already
checked in.

Note: I've also included two other things in this change set.

First, LocalRegion.dumpBackingMap() is a test-hook that should log its
results at "info" level.  I used it in debugging this problem.

Second, I've added a new backward-compatibility version so now we have
100 and 110.

(cherry picked from commit ff6cbf317ab24bb0e582a3eca01c23e7b435ef35)

-    if (!Arrays.equals(membershipID, other.membershipID))
+    return equalMembershipIds(membershipID, other.membershipID);
+  }
+
+  /** GEODE_3072 - 1.0.0 client IDs contain a UUID and member-weight byte that are all zero */
+  static final int NULL_90_MEMBER_DATA_LENGTH = 17;
+
+  /** minimum length of an ID array */
+  static final int MINIMIM_ID_LENGTH = 19;
+
+  /**
+   * check to see if membership ID byte arrays are equal
+   */
+  static public boolean equalMembershipIds(byte[] m1, byte[] m2) {
+    int sizeDifference = Math.abs(m1.length - m2.length);
+    if (sizeDifference != 0 && sizeDifference != NULL_90_MEMBER_DATA_LENGTH) {
+    }
+    for (int i = 0; i < m1.length; i++) {
+      if (i >= m2.length) {
+        return nullUUIDCheck(m1, i);
+      }
+      if (m1[i] != m2[i]) {
+        return false;
+      }
+    }
+    if (m1.length != m2.length) {
+      return nullUUIDCheck(m2, m1.length);
+    }
+  /**
+   * GEODE-3072 - v1.0.0 memberIDs in EventIDs may have trailing bytes that should be ignored
+   */
+  static private boolean nullUUIDCheck(byte[] memberID, int position) {
+    if (memberID.length - position != NULL_90_MEMBER_DATA_LENGTH) {
+      return false;
+    }
+    for (int i = position; i < memberID.length; i++) {
+      if (memberID[i] != 0) {
+        return false;
+      }
+    }
+    return true;
+  }
-  @Override
+  /**
+   * form the hashcode for the memberID byte array
+   */
+  static public int hashCodeMemberId(byte[] memberID) {
+    if (memberID.length < (NULL_90_MEMBER_DATA_LENGTH + MINIMIM_ID_LENGTH)
+        || !nullUUIDCheck(memberID, memberID.length - NULL_90_MEMBER_DATA_LENGTH)) {
+      return Arrays.hashCode(memberID);
+    }
+    byte[] newID = new byte[memberID.length - NULL_90_MEMBER_DATA_LENGTH];
+    System.arraycopy(memberID, 0, newID, 0, newID.length);
+    return Arrays.hashCode(newID);
+  }
+
-      result = prime * result + Arrays.hashCode(membershipID);
+      result = prime * result + hashCodeMemberId(membershipID);
-      buf.append("[");
+      buf.append("id=").append(membershipID.length).append("bytes;");

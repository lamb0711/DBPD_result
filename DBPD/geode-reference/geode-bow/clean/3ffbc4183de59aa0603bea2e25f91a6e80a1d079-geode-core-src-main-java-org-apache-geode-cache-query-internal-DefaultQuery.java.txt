GEODE-6488: Migrating cancellation state to execution context (#3322)

This work solves two problems.  One is that the query cancellation task
reference in DefaultQuery could be overwritten and thus never removed
from monitoring upon successful completion of a query.  Second is that
once a query execution timed out once, the query object was in an
unusable state which is undesirable.

The solution is to attach the cancellation state to the execution
context rather than the query object, so that cancellation is associated
with each independent execution of a query rather than having
cancellation state that applies to the entire query object.
-import java.util.Optional;
-import java.util.concurrent.ScheduledFuture;
-import java.util.concurrent.atomic.AtomicBoolean;
-import org.apache.geode.cache.CacheRuntimeException;
-  private Optional<ScheduledFuture> cancelationTask;
-
-  private volatile CacheRuntimeException queryCancelledException;
-
-  static final ThreadLocal<AtomicBoolean> queryCanceled =
-      ThreadLocal.withInitial(AtomicBoolean::new);
-
-  public Optional<ScheduledFuture> getCancelationTask() {
-    return cancelationTask;
-  }
-
-  public void setCancelationTask(final ScheduledFuture cancelationTask) {
-    this.cancelationTask = Optional.of(cancelationTask);
-  }
-
-    this.cancelationTask = Optional.empty();
+    final ExecutionContext context = new QueryExecutionContext(params, this.cache, this);
+
-      ExecutionContext context = new QueryExecutionContext(params, this.cache, this);
-              this);
+              this, context);
-        result = qe.executeQuery(this, params, null);
+        result = qe.executeQuery(this, context, params, null);
-        queryMonitor.monitorQueryThread(this);
+        queryMonitor.monitorQueryExecution(context);
-      context.setCqQueryContext(this.isCqQuery);
-      return reinterpretQueryExecutionCanceledException();
+      return context.reinterpretQueryExecutionCanceledException();
-        queryMonitor.stopMonitoringQueryThread(this);
+        queryMonitor.stopMonitoringQueryExecution(context);
-   * This method attempts to reintrepret a {@link QueryExecutionCanceledException} using the
-   * the value returned by {@link #getQueryCanceledException} (set by the {@link QueryMonitor}).
-   *
-   * @throws if {@link #getQueryCanceledException} doesn't return {@code null} then throw that
-   *         {@link CacheRuntimeException}, otherwise throw {@link QueryExecutionCanceledException}
-   */
-  private Object reinterpretQueryExecutionCanceledException() {
-    final CacheRuntimeException queryCanceledException = getQueryCanceledException();
-    if (queryCanceledException != null) {
-      throw queryCanceledException;
-    } else {
-      throw new QueryExecutionCanceledException(
-          "Query was canceled. It may be due to low memory or the query was running longer than the MAX_QUERY_EXECUTION_TIME.");
-    }
-  }
-
-  /**
-    ExecutionContext context = new QueryExecutionContext(parameters, this.cache, this);
+    final ExecutionContext context = new QueryExecutionContext(parameters, this.cache, this);
-    context.setCqQueryContext(this.isCqQuery);
-      queryMonitor.monitorQueryThread(this);
+      queryMonitor.monitorQueryExecution(context);
-        queryMonitor.stopMonitoringQueryThread(this);
+        queryMonitor.stopMonitoringQueryExecution(context);
-        DefaultQuery.testHook.doTestHook(TestHook.SPOTS.BEFORE_QUERY_DEPENDENCY_COMPUTATION, this);
+        DefaultQuery.testHook.doTestHook(TestHook.SPOTS.BEFORE_QUERY_DEPENDENCY_COMPUTATION, this,
+            context);
-          testHook.doTestHook(DefaultQuery.TestHook.SPOTS.BEFORE_QUERY_EXECUTION, this);
+          testHook.doTestHook(DefaultQuery.TestHook.SPOTS.BEFORE_QUERY_EXECUTION, this, context);
-        reinterpretQueryExecutionCanceledException();
+        context.reinterpretQueryExecutionCanceledException();
-      queryCanceled.remove();
+      ExecutionContext.isCanceled.remove();
-  /**
-   * Check to see if the query execution got canceled. The query gets canceled by the QueryMonitor
-   * if it takes more than the max query execution time or low memory situations
-   */
-  public boolean isCanceled() {
-    return getQueryCanceledException() != null;
-  }
-
-  public CacheRuntimeException getQueryCanceledException() {
-    return queryCancelledException;
-  }
-
-  /**
-   * The query gets canceled by the QueryMonitor with the reason being specified
-   */
-  public void setQueryCanceledException(final CacheRuntimeException queryCanceledException) {
-    this.queryCancelledException = queryCanceledException;
-  }
-
-    sb.append(';');
-    sb.append("isCancelled = ");
-    sb.append(this.isCanceled());
-        result = qe.executeQuery(this, params, buckets);
+        final ExecutionContext executionContext = new ExecutionContext(null, cache);
+        result = qe.executeQuery(this, executionContext, params, buckets);
-    void doTestHook(SPOTS spot, DefaultQuery query);
+    void doTestHook(SPOTS spot, DefaultQuery query,
+        ExecutionContext executionContext);

GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

+import org.apache.geode.internal.cache.InternalCache;
-/**
- * Class Description
- * 
- * @version $Revision: 1.2 $
- */
-  // Asif: limits the SelectResults by the number specified.
+  // limits the SelectResults by the number specified.
-  // Shobhit: counts the no of results satisfying where condition for
+  // counts the no of results satisfying where condition for
-    context.cachePut(scopeID, context.assosciateScopeID());
+    context.cachePut(scopeID, context.associateScopeID());
-   * 
-   * @param context
-   * @throws AmbiguousNameException
-   * @throws TypeMismatchException
-   * @throws NameResolutionException
-      StringBuffer lhsBuffer = new StringBuffer();
-      StringBuffer rhsBuffer = new StringBuffer();
+      StringBuilder lhsBuffer = new StringBuilder();
+      StringBuilder rhsBuffer = new StringBuilder();
-        // Asif: Ideally for replicated regions, the requirement that
+        // Ideally for replicated regions, the requirement that
-
-      ExecutionContext context, StringBuffer buffer)
+      ExecutionContext context, StringBuilder buffer)
-  public SelectResults getEmptyResultSet(Object[] parameters, Cache cache, Query query)
+  public SelectResults getEmptyResultSet(Object[] parameters, InternalCache cache, Query query)
-        // Asif . Ideally the function below should always be called after binding has occurred
-        // So that the interal ID gets set during binding to the scope. If not so then chances
-        // are that internal_id is still null causing index_interanl_id to be null.
-        // Though in our case it may not be an issue as the compute depedency phase must have
+        // Ideally the function below should always be called after binding has occurred
+        // So that the internal ID gets set during binding to the scope. If not so then chances
+        // are that internal_id is still null causing index_internal_id to be null.
+        // Though in our case it may not be an issue as the compute dependency phase must have
-          } else if (((Boolean) b).booleanValue()) {
+          } else if ((Boolean) b) {
-            StringBuffer preferredIndexCondn = new StringBuffer();
+            StringBuilder preferredIndexCondn = new StringBuilder();
-              StringBuffer temp = null;
+              StringBuilder temp = null;
-                temp = new StringBuffer();
+                temp = new StringBuilder();
-      // TODO:Asif: It does not appear that results would be null ever.
+      // TODO: It does not appear that results would be null ever.
-            ((ResultsBag) res).addAndGetOccurence(countStartQueryResult);
+            ((Bag) res).addAndGetOccurence(countStartQueryResult);
-   * 
-   * 
-   * @param planInfo
-
-   * Retruns the size of region iterator for count(*) on a region without whereclause.
+   * Returns the size of region iterator for count(*) on a region without whereclause.
-   * @param collExpr
-   * @throws RegionNotFoundException
-    // TODO:Asif: SELF : Work on limit implementation on bulk get
+    // TODO: SELF : Work on limit implementation on bulk get
-    } catch (CompiledSelect.NullIteratorException cnie) {
+    } catch (CompiledSelect.NullIteratorException ignore) {
-  // @todo make this more general to work for any kind of map, not just regions
+  // TODO: make this more general to work for any kind of map, not just regions
-          addToResults = ((Boolean) result).booleanValue();
+          addToResults = (Boolean) result;
-            int operator = ((CompiledComparison) this.whereClause).getOperator();
+            int operator = ((Filter) this.whereClause).getOperator();
-        // Asif: If the occurence is greater than 1, then only in case of
+        // If the occurence is greater than 1, then only in case of
-          // Asif: (Unique i.e first time occurence) or subsequent occurence
+          // (Unique i.e first time occurence) or subsequent occurence
-      // Asif : If the projection attribute is null( ie.e specified as *) &
+      // If the projection attribute is null( ie.e specified as *) &
-            // Asif: (Unique i.e first time occurence) or subsequent occurence
+            // (Unique i.e first time occurence) or subsequent occurence
-            // Asif: (Unique i.e first time occurence) or subsequent occurence
+            // (Unique i.e first time occurence) or subsequent occurence
-    // Asif:if no projection attributes or '*'as projection attribute
+    // if no projection attributes or '*'as projection attribute
-                : new SortedStructBag(comparator, (StructTypeImpl) elementType, nullValuesAtStart);
+                : new SortedStructBag(comparator, (StructType) elementType, nullValuesAtStart);
-    // Asif:if no projection attributes or '*'as projection attribute
+    // if no projection attributes or '*'as projection attribute
-  /*
-   * private SelectResults prepareEmptySelectResults(ObjectType elementType, boolean isSorted,
-   * ExecutionContext context) { if (elementType.isStructType()) { if (isSorted) { // sorted struct
-   * return prepareEmptySortedStructSet((StructTypeImpl)elementType); } else { // unsorted struct
-   * return new StructBag((StructType)elementType, context.getCachePerfStats()); } } else { //
-   * non-struct if (isSorted) { // sorted non-struct return
-   * prepareEmptySortedResultSet(elementType); } else { // unsorted non-struct return new
-   * ResultsBag(elementType, context.getCachePerfStats()); } } }
-   */
-
-
-
-   * Asif: This function should be used to create a StructType for those queries which have * as
+   * This function should be used to create a StructType for those queries which have * as
-   * 
-        String path[] = (String[]) pathOnItr.toArray(new String[0]);
+        String path[] = (String[]) pathOnItr.toArray(new String[pathOnItr.size()]);
-    } catch (NameNotFoundException e) {
+    } catch (NameNotFoundException ignore) {
-
-  // Asif: The number returned indicates the occurence of the data in the SelectResults
+  // The number returned indicates the occurence of the data in the SelectResults
-
-
-    // TODO : Asif : Optimize this condition in some clean way
+    // TODO: Optimize this condition in some clean way
-              // Asif: TODO:Instead of a normal Map containing which holds
+              // TODO:Instead of a normal Map containing which holds
-                      } catch (EntryDestroyedException ede) {
-                        // Even though isDestory() check is made, the entry
-                        // could
-                        // throw EntryDestroyedException if the value becomes
-                        // null.
+                      } catch (EntryDestroyedException ignore) {
+                        // Even though isDestory() check is made, the entry could throw
+                        // EntryDestroyedException if the value becomes null.
-            // Asif: Occurence field is used to identify the corrcet number of
+            // Occurence field is used to identify the corrcet number of
-        name = new StringBuffer("field$").append(context.nextFieldNum()).toString();
+        name = new StringBuilder("field$").append(context.nextFieldNum()).toString();
-
-   * 
-   * @param context
-   * @return boolean
-   * @throws FunctionDomainException
-   * @throws TypeMismatchException
-   * @throws NameResolutionException
-   * @throws QueryInvocationTargetException
-          int operator = ((CompiledComparison) this.whereClause).getOperator();
+          int operator = ((Filter) this.whereClause).getOperator();
-        return (((Boolean) b).booleanValue());
+        return (Boolean) b;

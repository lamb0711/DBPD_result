Refactoring LuceneFunction, LuceneQueryProvider, and LuceneQueryFactory

LuceneFunction had a static RepositoryManager, I changed the code to get
look up the RepositoryManager from the LuceneService.

As part of that work, I noticed StringQueryProvider really needed access
to the index to lookup the field names, analyzer, etc. So I changed the
getQuery method to take an index, and removed the unneeded string
parameters.

Finally, I removed some of the mocking from
LuceneFunctionReadPathDUnitTest, which exposed some other issues:

* I switched RepositoryManager.getRepositories back to using a
RegionFunctionContext, because apparently context.getDataSet is *not*
the local data set.

* I canonicalized the regionPaths in LuceneService

+import com.gemstone.gemfire.cache.execute.RegionFunctionContext;
+import com.gemstone.gemfire.cache.partition.PartitionRegionHelper;
+import com.gemstone.gemfire.internal.cache.PartitionedRegionHelper;
+import com.gemstone.gemfire.internal.cache.execute.InternalRegionFunctionContext;
-  public Collection<IndexRepository> getRepositories(Region region) throws BucketNotFoundException {
-    if(!(region instanceof LocalDataSet)) {
-      throw new IllegalStateException("Trying to find the repositories for a region which is not the local data set of a function");
-    }
+  public Collection<IndexRepository> getRepositories(RegionFunctionContext ctx) throws BucketNotFoundException {
-    LocalDataSet dataSet = (LocalDataSet) region;
-    Set<Integer> buckets = dataSet.getBucketSet();
+    Region<Object, Object> region = ctx.getDataSet();
+    Set<Integer> buckets = ((InternalRegionFunctionContext) ctx).getLocalBucketSet(region);

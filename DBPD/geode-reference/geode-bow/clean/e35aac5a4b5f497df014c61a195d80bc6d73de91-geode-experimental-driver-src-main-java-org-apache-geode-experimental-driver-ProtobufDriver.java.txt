Merge branch 'release/1.5.0'

-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.Socket;
+import java.util.Objects;
-import org.apache.geode.internal.protocol.protobuf.ProtocolVersion;
-import org.apache.geode.internal.protocol.protobuf.v1.BasicTypes;
-import org.apache.geode.internal.protocol.protobuf.v1.LocatorAPI;
+import org.apache.geode.internal.protocol.protobuf.v1.ClientProtocol.Message;
+import org.apache.geode.internal.protocol.protobuf.v1.ClientProtocol.Message.MessageTypeCase;
+import org.apache.geode.internal.protocol.protobuf.v1.ConnectionAPI;
+import org.apache.geode.internal.protocol.protobuf.v1.RegionAPI.GetRegionNamesRequest;
-  /**
-   * Set of Internet-address-or-host-name/port pairs of the locators to use to find GemFire servers
-   * that have Protobuf enabled.
-   */
-  private final Set<InetSocketAddress> locators;
-  /**
-   * Socket to a GemFire locator that has Protobuf enabled.
-   */
-  private final Socket socket;
+  private final ProtobufChannel channel;
-    this.locators = locators;
-    InetSocketAddress server = findAServer();
-    socket = new Socket(server.getAddress(), server.getPort());
-
-    final OutputStream outputStream = socket.getOutputStream();
-    ProtocolVersion.NewConnectionClientVersion.newBuilder()
-        .setMajorVersion(ProtocolVersion.MajorVersions.CURRENT_MAJOR_VERSION_VALUE)
-        .setMinorVersion(ProtocolVersion.MinorVersions.CURRENT_MINOR_VERSION_VALUE).build()
-        .writeDelimitedTo(outputStream);
-
-    final InputStream inputStream = socket.getInputStream();
-    if (!ProtocolVersion.VersionAcknowledgement.parseDelimitedFrom(inputStream)
-        .getVersionAccepted()) {
-      throw new IOException("Failed protocol version verification.");
-    }
+    this.channel = new ProtobufChannel(locators);
-    final OutputStream outputStream = socket.getOutputStream();
-    ClientProtocol.Message.newBuilder()
-        .setRequest(ClientProtocol.Request.newBuilder()
-            .setGetRegionNamesRequest(RegionAPI.GetRegionNamesRequest.newBuilder()))
-        .build().writeDelimitedTo(outputStream);
+    final Message request =
+        Message.newBuilder().setGetRegionNamesRequest(GetRegionNamesRequest.newBuilder()).build();
-    final InputStream inputStream = socket.getInputStream();
-    final RegionAPI.GetRegionNamesResponse getRegionNamesResponse = ClientProtocol.Message
-        .parseDelimitedFrom(inputStream).getResponse().getGetRegionNamesResponse();
+    final RegionAPI.GetRegionNamesResponse getRegionNamesResponse = channel
+        .sendRequest(request, MessageTypeCase.GETREGIONNAMESRESPONSE).getGetRegionNamesResponse();
-    return new ProtobufRegion(regionName, socket);
+    return new ProtobufRegion(regionName, channel);
-  /**
-   * Queries locators for a Geode server that has Protobuf enabled.
-   *
-   * @return The server chosen by the Locator service for this client
-   * @throws IOException
-   */
-  private InetSocketAddress findAServer() throws IOException {
-    IOException lastException = null;
+  @Override
+  public QueryService getQueryService() {
+    return new ProtobufQueryService(channel);
+  }
-    for (InetSocketAddress locator : locators) {
+  @Override
+  public void close() {
+    try {
+      final Message disconnectClientRequest = ClientProtocol.Message.newBuilder()
+          .setDisconnectClientRequest(
+              ConnectionAPI.DisconnectClientRequest.newBuilder().setReason("Driver closed"))
+          .build();
+      final ConnectionAPI.DisconnectClientResponse disconnectClientResponse =
+          channel.sendRequest(disconnectClientRequest, MessageTypeCase.DISCONNECTCLIENTRESPONSE)
+              .getDisconnectClientResponse();
+      if (Objects.isNull(disconnectClientResponse)) {
+        // The server did not acknowledge the disconnect request; ignore for now.
+      }
+    } catch (IOException ioe) {
+      // NOP
+    } finally {
-        final Socket locatorSocket = new Socket(locator.getAddress(), locator.getPort());
-
-        final OutputStream outputStream = locatorSocket.getOutputStream();
-        final InputStream inputStream = locatorSocket.getInputStream();
-        ProtocolVersion.NewConnectionClientVersion.newBuilder()
-            .setMajorVersion(ProtocolVersion.MajorVersions.CURRENT_MAJOR_VERSION_VALUE)
-            .setMinorVersion(ProtocolVersion.MinorVersions.CURRENT_MINOR_VERSION_VALUE).build()
-            .writeDelimitedTo(outputStream);
-
-        // The locator does not currently send a reply to the ProtocolVersion...
-        if (!ProtocolVersion.VersionAcknowledgement.parseDelimitedFrom(inputStream)
-            .getVersionAccepted()) {
-          throw new IOException("Failed ProtocolVersion.");
-        }
-
-        ClientProtocol.Message.newBuilder()
-            .setRequest(ClientProtocol.Request.newBuilder()
-                .setGetServerRequest(LocatorAPI.GetServerRequest.newBuilder()))
-            .build().writeDelimitedTo(outputStream);
-
-        ClientProtocol.Response response =
-            ClientProtocol.Message.parseDelimitedFrom(inputStream).getResponse();
-        ClientProtocol.ErrorResponse errorResponse = response.getErrorResponse();
-
-        if (errorResponse != null && errorResponse.hasError()) {
-          throw new IOException(
-              "Error finding server: error code= " + errorResponse.getError().getErrorCode()
-                  + "; error message=" + errorResponse.getError().getMessage());
-        }
-
-        LocatorAPI.GetServerResponse getServerResponse = response.getGetServerResponse();
-
-        BasicTypes.Server server = getServerResponse.getServer();
-        return new InetSocketAddress(server.getHostname(), server.getPort());
+        this.channel.close();
-        lastException = e;
+        // ignore
-
-    if (lastException != null) {
-      throw lastException;
-    } else {
-      throw new IllegalStateException("No locators");
-    }
+
+  @Override
+  public boolean isConnected() {
+    return !this.channel.isClosed();
+  }
+

Merge branch 'release/1.0.0-incubating.M3'

+import com.gemstone.gemfire.cache.query.internal.cq.ServerCQ;
+import com.gemstone.gemfire.internal.cache.CacheDistributionAdvisor.CacheProfile;
+import com.gemstone.gemfire.internal.cache.tier.MessageType;
+import com.gemstone.gemfire.internal.offheap.annotations.Released;
-   * @since 5.7
+   * @since GemFire 5.7
-   * Deserialization policy: deserialize eagerly (for Deltas)
-   * 
-   * @since 5.7
-   */
-  public static final byte DESERIALIZATION_POLICY_EAGER = (byte)1;
-
-  /**
-   * @since 5.7
+   * @since GemFire 5.7
-   * @param deserializationPolicy must be one of the following: DESERIALIZATION_POLICY_NONE, DESERIALIZATION_POLICY_EAGER, DESERIALIZATION_POLICY_LAZY.
+   * @param deserializationPolicy must be one of the following: DESERIALIZATION_POLICY_NONE, DESERIALIZATION_POLICY_LAZY.
-      if (deserializationPolicy == DESERIALIZATION_POLICY_EAGER) {
-        // for DESERIALIZATION_POLICY_EAGER avoid extra byte array serialization
-        DataSerializer.writeObject(vObj, out);
-      } else if (deserializationPolicy == DESERIALIZATION_POLICY_NONE) {
+      if (deserializationPolicy == DESERIALIZATION_POLICY_NONE) {
-        // TODO OFFHEAP MERGE: cache the oldValue that is serialized here
-        // into the event
-      if (deserializationPolicy == DESERIALIZATION_POLICY_EAGER) {
-        // object is already in serialized form in the byte array.
-        // So just write the bytes to the stream.
-        // fromData will call readObject which will deserialize to object form.
-        out.write(vBytes);
-      } else {
-        DataSerializer.writeByteArray(vBytes, out);
-      }
+      DataSerializer.writeByteArray(vBytes, out);
-    if (CachedDeserializableFactory.preferObject()) return DESERIALIZATION_POLICY_EAGER;
-    case DESERIALIZATION_POLICY_EAGER:
-      return "EAGER";
-   * @since 5.0
+   * @since GemFire 5.0
-          msg.appendOldValueToMessage((EntryEventImpl)this.event); // TODO OFFHEAP optimize
+          msg.appendOldValueToMessage((EntryEventImpl)this.event);
+      if (region.isUsedForPartitionedRegionBucket() && filterRouting != null) {
+        removeDestroyTokensFromCqResultKeys(filterRouting);
+      }
+
+
+  /**
+   * Cleanup destroyed events in CQ result cache for remote CQs.
+   * While maintaining the CQ results key caching. the destroy event
+   * keys are marked as destroyed instead of removing them, this is
+   * to take care, arrival of duplicate events. The key marked as
+   * destroyed are  removed after the event is placed in clients 
+   * HAQueue or distributed to the peers.
+   *
+   * This is similar to CacheClientNotifier.removeDestroyTokensFromCqResultKeys()
+   * where the destroyed events for local CQs are handled.
+   */
+  private void removeDestroyTokensFromCqResultKeys(FilterRoutingInfo filterRouting) {
+    for (InternalDistributedMember m : filterRouting.getMembers()) {
+      FilterInfo filterInfo = filterRouting.getFilterInfo(m);
+      if (filterInfo.getCQs() == null) {
+        continue;
+      }
+
+      CacheProfile cf = (CacheProfile) ((BucketRegion)getRegion()).getPartitionedRegion()
+          .getCacheDistributionAdvisor().getProfile(m);
+
+      if (cf == null || cf.filterProfile == null || cf.filterProfile.isLocalProfile() 
+          || cf.filterProfile.getCqMap().isEmpty()) {
+        continue;
+      }
+
+
+      for (Object value : cf.filterProfile.getCqMap().values()) {
+        ServerCQ cq = (ServerCQ)value;
+
+        for (Map.Entry<Long, Integer> e: filterInfo.getCQs().entrySet()) {
+          Long cqID = e.getKey();
+          // For the CQs satisfying the event with destroy CQEvent, remove
+          // the entry form CQ cache.
+          if (cq.getFilterID() == cqID && (e.getValue().equals(Integer.valueOf(
+              MessageType.LOCAL_DESTROY)))) {
+            cq.removeFromCqResultKeys(((EntryEventImpl)event).getKey(), true);
+          }
+        }
+      }
+    }
+  }
+
+
-	protected final static short FETCH_FROM_HDFS = 0x200;
-    
-    protected final static short IS_PUT_DML = 0x100;
-
-     * @since 5.5
+     * @since GemFire 5.5
-     * @since 5.5
+     * @since GemFire 5.5
-     * @since 6.1
+     * @since GemFire 6.1
-     * @since 4.2.3
+     * @since GemFire 4.2.3
-      InternalCacheEvent event = null;
-        event = createEvent(rgn);
+        @Released InternalCacheEvent event = createEvent(rgn);
-	  if (this instanceof PutAllMessage) {
-        ((PutAllMessage) this).setFetchFromHDFS((extBits & FETCH_FROM_HDFS) != 0);
-        ((PutAllMessage) this).setPutDML((extBits & IS_PUT_DML) != 0);
-      }

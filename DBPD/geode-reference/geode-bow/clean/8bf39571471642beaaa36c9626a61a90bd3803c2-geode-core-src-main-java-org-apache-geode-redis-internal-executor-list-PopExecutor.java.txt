Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-    
+
-     * First attempt to hop over an index by moving the index 
-     * down one in the meta data region. The desired index to 
-     * remove is held within the field index
+     * First attempt to hop over an index by moving the index down one in the meta data region. The
+     * desired index to remove is held within the field index
-    
+
-    } while(!indexChanged);
-    
+    } while (!indexChanged);
+
-     * Now attempt to remove the value of the index. We must do a
-     * get to ensure a returned value and then call remove with the
-     * value to ensure no one else has removed it first. Otherwise, 
-     * try other indexes 
+     * Now attempt to remove the value of the index. We must do a get to ensure a returned value and
+     * then call remove with the value to ensure no one else has removed it first. Otherwise, try
+     * other indexes
-    
+
-      
+
-       * If remove has passed, our job is done and we can break and
-       * stop looking for a value
+       * If remove has passed, our job is done and we can break and stop looking for a value
-      
+
-       * If the index has not been removed, we need to look at other indexes.
-       * Two cases exist:
+       * If the index has not been removed, we need to look at other indexes. Two cases exist:
-       * ************************** FIRST MISS ***********************************
-       *   Push occurring at the same time, further index update first
-       *   |    This is location of miss
-       *   |      |
-       *   |      |
-       *   V      V
-       * [-4]    [X]    [-2]    [-1]    [0]     [1]     [2]
-       *        <-- Direction of index update
-       * If this is the first miss, the index is re obtained from the meta region
-       * and that index is trying. However, if the index in the meta data region
-       * is not further out, that index is not used and moves on to the second case
+       * ************************** FIRST MISS *********************************** Push occurring at
+       * the same time, further index update first | This is location of miss | | | | V V [-4] [X]
+       * [-2] [-1] [0] [1] [2] <-- Direction of index update If this is the first miss, the index is
+       * re obtained from the meta region and that index is trying. However, if the index in the
+       * meta data region is not further out, that index is not used and moves on to the second case
-       * ************************* SUBSEQUENT MISSES ******************************
-       *   Push occurring at the same time, further index update first
-       *   |    This is location of miss
-       *   |      |
-       *   |      |
-       *   V      V
-       * [-4]    [X]    [-2]    [-1]    [0]     [1]     [2]
-       * Direction of index update -->
-       * If this is not the first miss then we move down to the other end of the list
-       * which means the next not empty index will be attempted to be removed
+       * ************************* SUBSEQUENT MISSES ****************************** Push occurring
+       * at the same time, further index update first | This is location of miss | | | | V V [-4]
+       * [X] [-2] [-1] [0] [1] [2] Direction of index update --> If this is not the first miss then
+       * we move down to the other end of the list which means the next not empty index will be
+       * attempted to be removed
-      
+
-      if (i < 1 && (popType() == ListDirection.LEFT && metaIndex < originalIndex ||
-          popType() == ListDirection.RIGHT && metaIndex > originalIndex))
+      if (i < 1 && (popType() == ListDirection.LEFT && metaIndex < originalIndex
+          || popType() == ListDirection.RIGHT && metaIndex > originalIndex))
-      command.setResponse(Coder.getBulkStringResponse(context.getByteBufAllocator(), valueWrapper.toBytes()));
+      command.setResponse(
+          Coder.getBulkStringResponse(context.getByteBufAllocator(), valueWrapper.toBytes()));

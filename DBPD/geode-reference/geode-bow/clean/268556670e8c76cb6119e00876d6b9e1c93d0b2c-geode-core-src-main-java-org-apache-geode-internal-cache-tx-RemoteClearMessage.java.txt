GEODE-4372: clean up RemoteOperationMessage classes (#1338)


* throw RemoteOperationException instead of ForceReattemptException when cache is closing. All ForceReattemptException throwing by RemoteOperationMessage has been removed.

* now uses SERIAL_EXECUTOR for all RemoteOperationMessages.
Previously most of these messages where processed in the partitioned message
thread pool even though most all of these messages where not partitioned.
It is possible that RemotePutAll and RemoteRemoveAll will have some trouble
being SERIAL_EXECUTOR.

* added comments for all RemoteOperationMessages describing what
they are used for

* Improved RemoteOperationMessageTest

* added a BucketTXRegionStub to calculate bucket region size on a stub.

* removed GemFireCacheImpl.getInstance call

* added RemoteOperationResponse unit test

* renamed handleAsUnexpected to handleCause

* renamed waitForCacheException to waitForRemoteResponse

* moved RemoteOperation classes to tx package


-package org.apache.geode.internal.cache;
+package org.apache.geode.internal.cache.tx;
-import java.util.Collections;
+import org.apache.geode.internal.cache.DistributedRegion;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.RemoteOperationException;
- * This message is used be a replicate region to perform region-level ops like clear() and
- * invalidateRegion(). It is used when the target region has concurrency control enabled so that
- * region-version-vectors must be used to execute these operations.
+ * This message is used to implement clear. It is only used when a region is not a replica and has
+ * concurrency checks enabled and some other member has a replica. In that case it sends this
+ * message to the replica to ask it to do the clear.
-public class RemoteRegionOperation extends RemoteOperationMessageWithDirectReply {
+public class RemoteClearMessage extends RemoteOperationMessageWithDirectReply {
-    // INVALIDATE
-  private Operation op;
-  public RemoteRegionOperation() {}
+  public RemoteClearMessage() {}
-  public static RemoteRegionOperation clear(InternalDistributedMember recipient,
+  public static RemoteClearMessage create(InternalDistributedMember recipient,
-    return new RemoteRegionOperation(recipient, region, Operation.CLEAR);
+    return new RemoteClearMessage(recipient, region, Operation.CLEAR);
-  // public static RemoteRegionOperation invalidate(InternalDistributedMember recipient,
-  // DistributedRegion region) {
-  // return new RemoteRegionOperation(recipient, region, Operation.INVALIDATE);
-  // }
-
-  private RemoteRegionOperation(InternalDistributedMember recipient, DistributedRegion region,
+  private RemoteClearMessage(InternalDistributedMember recipient, DistributedRegion region,
-        new RemoteOperationResponse(region.getSystem(), Collections.singleton(recipient)));
-    this.op = op;
+        new RemoteOperationResponse(region.getSystem(), recipient));
-  /**
-   */
-    Set failures = region.getDistributionManager().putOutgoing(this);
+    Set<?> failures = region.getDistributionManager().putOutgoing(this);
-    p.waitForCacheException();
+    p.waitForRemoteResponse();
-      logger.trace(LogMarker.DM, "DistributedRemoteRegionOperation operateOnRegion: {}",
-          r.getFullPath());
+      logger.trace(LogMarker.DM, "RemoteClearMessage operateOnRegion: {}", r.getFullPath());
+    r.waitOnInitialization(); // bug #43371 - accessing a region before it's initialized
-    if (!(r instanceof PartitionedRegion)) {
-      r.waitOnInitialization(); // bug #43371 - accessing a region before it's initialized
-    }
+    r.clear();
-    if (op.equals(Operation.CLEAR)) {
-      r.clear();
-      // } else {
-      // r.invalidateRegion();
-    }
+    RemoteClearReplyMessage.send(getSender(), getProcessorId(), getReplySender(dm));
-    // r.getPrStats().endPartitionMessagesProcessing(startTime);
-    RemoteRegionOperationReplyMessage.send(getSender(), getProcessorId(), getReplySender(dm));
-
-    // Unless there was an exception thrown, this message handles sending the
-    // response
+    // Unless there was an exception thrown, this message handles sending the response
-    buff.append("; operation=").append(this.op);
-    return R_REGION_OP;
+    return R_CLEAR_MSG;
-    this.op = Operation.values()[in.readByte()];
+    in.readByte(); // for backwards compatibility
-    out.writeByte(this.op.ordinal());
+    out.writeByte(Operation.CLEAR.ordinal()); // for backwards compatibility
-  public static class RemoteRegionOperationReplyMessage extends ReplyMessage {
+  public static class RemoteClearReplyMessage extends ReplyMessage {
-    public RemoteRegionOperationReplyMessage() {}
+    public RemoteClearReplyMessage() {}
-    private RemoteRegionOperationReplyMessage(int processorId) {
+    private RemoteClearReplyMessage(int processorId) {
-      Assert.assertTrue(recipient != null, "RemoteRegionOperationReplyMessage NULL reply message");
-      RemoteRegionOperationReplyMessage m = new RemoteRegionOperationReplyMessage(processorId);
+      Assert.assertTrue(recipient != null, "RemoteClearReplyMessage NULL recipient");
+      RemoteClearReplyMessage m = new RemoteClearReplyMessage(processorId);
-          logger.trace(LogMarker.DM, "RemoteRegionOperationReplyMessage processor not found");
+          logger.trace(LogMarker.DM, "RemoteClearReplyMessage processor not found");
-      return R_REGION_OP_REPLY;
+      return R_CLEAR_MSG_REPLY;
-      sb.append("RemoteRegionOperationReplyMessage ").append("processorid=")
-          .append(this.processorId).append(" reply to sender ").append(this.getSender());
+      sb.append("RemoteClearReplyMessage ").append("processorid=").append(this.processorId)
+          .append(" reply to sender ").append(this.getSender());
-
-
-

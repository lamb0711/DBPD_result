Merge branch 'release/1.1.0'

-* Licensed to the Apache Software Foundation (ASF) under one or more
-* contributor license agreements.  See the NOTICE file distributed with
-* this work for additional information regarding copyright ownership.
-* The ASF licenses this file to You under the Apache License, Version 2.0
-* (the "License"); you may not use this file except in compliance with
-* the License.  You may obtain a copy of the License at
-*
-*      http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
- * Primary class which orchestrates everything. This is the class which gets
- * configured in the web.xml.
+ * Primary class which orchestrates everything. This is the class which gets configured in the
+ * web.xml.
-  private static final Logger LOG =
-      LoggerFactory.getLogger(SessionCachingFilter.class.getName());
+  private static final Logger LOG = LoggerFactory.getLogger(SessionCachingFilter.class.getName());
-   * The filter configuration object we are associated with.  If this value is
-   * null, this filter instance is not currently configured.
+   * The filter configuration object we are associated with. If this value is null, this filter
+   * instance is not currently configured.
-   * Some containers will want to instantiate multiple instances of this filter,
-   * but we only need one SessionManager
+   * Some containers will want to instantiate multiple instances of this filter, but we only need
+   * one SessionManager
-  private static AtomicInteger started =
-      new AtomicInteger(
-          Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "override.session.manager.count", 1));
+  private static AtomicInteger started = new AtomicInteger(
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "override.session.manager.count", 1));
-  private static int percentInactiveTimeTriggerRebuild =
-      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "session.inactive.trigger.rebuild", 80);
+  private static int percentInactiveTimeTriggerRebuild = Integer
+      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "session.inactive.trigger.rebuild", 80);
-   * This latch ensures that at least one thread/instance has fired up the
-   * session manager before any other threads complete the init method.
+   * This latch ensures that at least one thread/instance has fired up the session manager before
+   * any other threads complete the init method.
-   * This request wrapper class extends the support class
-   * HttpServletRequestWrapper, which implements all the methods in the
-   * HttpServletRequest interface, as delegations to the wrapped request. You
-   * only need to override the methods that you need to change. You can get
-   * access to the wrapped request using the method getRequest()
+   * This request wrapper class extends the support class HttpServletRequestWrapper, which
+   * implements all the methods in the HttpServletRequest interface, as delegations to the wrapped
+   * request. You only need to override the methods that you need to change. You can get access to
+   * the wrapped request using the method getRequest()
-    public RequestWrapper(SessionManager manager,
-        HttpServletRequest request,
+    public RequestWrapper(SessionManager manager, HttpServletRequest request,
-          if (cookie.getName().equalsIgnoreCase(
-              manager.getSessionCookieName()) &&
-              cookie.getValue().endsWith("-GF")) {
+          if (cookie.getName().equalsIgnoreCase(manager.getSessionCookieName())
+              && cookie.getValue().endsWith("-GF")) {
-            LOG.debug("Cookie contains sessionId: {}",
-                requestedSessionId);
+            LOG.debug("Cookie contains sessionId: {}", requestedSessionId);
-                /*
-                 * This is a massively gross hack. Currently, there is no way
-                 * to actually update the last accessed time for a session, so
-                 * what we do here is once we're into X% of the session's TTL
-                 * we grab a new session from the container.
-                 *
-                 * (inactive * 1000) * (pct / 100) ==> (inactive * 10 * pct)
-                 */
-        if (session.getLastAccessedTime() - session.getCreationTime() >
-            (session.getMaxInactiveInterval() * 10 * percentInactiveTimeTriggerRebuild)) {
+        /*
+         * This is a massively gross hack. Currently, there is no way to actually update the last
+         * accessed time for a session, so what we do here is once we're into X% of the session's
+         * TTL we grab a new session from the container.
+         *
+         * (inactive * 1000) * (pct / 100) ==> (inactive * 10 * pct)
+         */
+        if (session.getLastAccessedTime()
+            - session.getCreationTime() > (session.getMaxInactiveInterval() * 10
+                * percentInactiveTimeTriggerRebuild)) {
-        session = (GemfireHttpSession) manager.getSession(
-            requestedSessionId);
+        session = (GemfireHttpSession) manager.getSession(requestedSessionId);
-      Cookie cookie = new Cookie(manager.getSessionCookieName(),
-          session.getId());
+      Cookie cookie = new Cookie(manager.getSessionCookieName(), session.getId());
-      // Clear out all old cookies and just set ours
-
-      // Replace all other cookies which aren't JSESSIONIDs
-      if (cookies != null) {
-        for (Cookie c : cookies) {
-          if (manager.getSessionCookieName().equals(c.getName())) {
-            continue;
-          }
-          response.addCookie(c);
-        }
-      }
-
-        /*
-         * Hmmm... not sure if this is right or even good to do. So, in some
-         * cases - for ex. using a Spring security filter, we have 3 possible
-         * wrappers to deal with - the original, this one and one created by
-         * Spring. When a servlet or JSP is forwarded to the original request
-         * is passed in, but then this (the wrapped) request is used by the JSP.
-         * In some cases, the outer wrapper also contains information relevant
-         * to the request - in this case security info. So here we allow access
-         * to that. There's probably a better way....
-         */
+    /*
+     * Hmmm... not sure if this is right or even good to do. So, in some cases - for ex. using a
+     * Spring security filter, we have 3 possible wrappers to deal with - the original, this one and
+     * one created by Spring. When a servlet or JSP is forwarded to the original request is passed
+     * in, but then this (the wrapped) request is used by the JSP. In some cases, the outer wrapper
+     * also contains information relevant to the request - in this case security info. So here we
+     * allow access to that. There's probably a better way....
+     */
-   * This response wrapper class extends the support class
-   * HttpServletResponseWrapper, which implements all the methods in the
-   * HttpServletResponse interface, as delegations to the wrapped response. You
-   * only need to override the methods that you need to change. You can get
-   * access to the wrapped response using the method getResponse()
+   * This response wrapper class extends the support class HttpServletResponseWrapper, which
+   * implements all the methods in the HttpServletResponse interface, as delegations to the wrapped
+   * response. You only need to override the methods that you need to change. You can get access to
+   * the wrapped response using the method getResponse()
-  public SessionCachingFilter() {
-  }
+  public SessionCachingFilter() {}
-   * @param request  The servlet request we are processing
+   * @param request The servlet request we are processing
-   * @param chain    The filter chain we are processing
-   * @throws IOException      if an input/output error occurs
+   * @param chain The filter chain we are processing
+   * @throws IOException if an input/output error occurs
-  public void doFilter(ServletRequest request, ServletResponse response,
-      FilterChain chain)
+  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
-     * Early out if this isn't the right kind of request. We might see a
-     * RequestWrapper instance during a forward or include request.
+     * Early out if this isn't the right kind of request. We might see a RequestWrapper instance
+     * during a forward or include request.
-    final RequestWrapper wrappedRequest =
-        new RequestWrapper(manager, httpReq, wrappedResponse);
+    final RequestWrapper wrappedRequest = new RequestWrapper(manager, httpReq, wrappedResponse);
-    GemfireHttpSession session =
-        (GemfireHttpSession) wrappedRequest.getSession(false);
+    GemfireHttpSession session = (GemfireHttpSession) wrappedRequest.getSession(false);
-     * Commit any updates. What actually happens at that point is
-     * dependent on the type of attributes defined for use by the sessions.
+     * Commit any updates. What actually happens at that point is dependent on the type of
+     * attributes defined for use by the sessions.
-   * Test if a request has been wrapped with RequestWrapper somewhere
-   * in the chain of wrapped requests.
+   * Test if a request has been wrapped with RequestWrapper somewhere in the chain of wrapped
+   * requests.
-    if(request instanceof RequestWrapper) {
+    if (request instanceof RequestWrapper) {
-    if(!(request instanceof ServletRequestWrapper)) {
+    if (!(request instanceof ServletRequestWrapper)) {
-    if(nestedRequest == request) {
+    if (nestedRequest == request) {
-      String managerClassStr =
-          config.getInitParameter("session-manager-class");
+      String managerClassStr = config.getInitParameter("session-manager-class");
-        manager = (SessionManager) Class.forName(
-            managerClassStr).newInstance();
+        manager = (SessionManager) Class.forName(managerClassStr).newInstance();
-      LOG.debug("SessionManager and listener initialization skipped - "
-          + "already done.");
+      LOG.debug("SessionManager and listener initialization skipped - " + "already done.");
-        pw.print(
-            "<html>\n<head>\n<title>Error</title>\n</head>\n<body>\n"); //NOI18N
+        pw.print("<html>\n<head>\n<title>Error</title>\n</head>\n<body>\n"); // NOI18N
-        pw.print("</pre></body>\n</html>"); //NOI18N
+        pw.print("</pre></body>\n</html>"); // NOI18N
-   * Retrieve the SessionManager. This is only here so that tests can get access
-   * to the cache.
+   * Retrieve the SessionManager. This is only here so that tests can get access to the cache.
-   * @param nativeSession the native session for which the corresponding GemFire
-   *                      session should be returned.
-   * @return the GemFire session or null if no session maps to the native
-   * session
+   * @param nativeSession the native session for which the corresponding GemFire session should be
+   *        returned.
+   * @return the GemFire session or null if no session maps to the native session
-        /*
-         * This is a special case where the GemFire session has been set as a
-         * ThreadLocal during session creation.
-         */
+    /*
+     * This is a special case where the GemFire session has been set as a ThreadLocal during session
+     * creation.
+     */

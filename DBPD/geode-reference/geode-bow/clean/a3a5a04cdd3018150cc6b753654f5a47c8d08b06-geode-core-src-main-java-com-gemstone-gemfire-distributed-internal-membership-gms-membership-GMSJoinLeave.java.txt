Merge branch 'develop' into feature/GEODE-420

# Conflicts:
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/AbstractDistributionConfig.java
#	geode-core/src/main/java/com/gemstone/gemfire/distributed/internal/InternalLocator.java
#	geode-core/src/test/java/com/gemstone/gemfire/cache30/DistributedMulticastRegionDUnitTest.java
#	geode-core/src/test/java/com/gemstone/gemfire/distributed/LocatorDUnitTest.java
#	geode-core/src/test/java/com/gemstone/gemfire/distributed/internal/DistributionConfigJUnitTest.java

+import com.gemstone.gemfire.distributed.internal.membership.NetMember;
+
-  private NetView preparedView;
+  private volatile NetView preparedView;
-      JoinRequestMessage req = new JoinRequestMessage(coord, this.localAddress, services.getAuthenticator().getCredentials(coord), port);
+      JoinRequestMessage req = new JoinRequestMessage(coord, this.localAddress, services.getAuthenticator().getCredentials(coord), port, 
+          services.getMessenger().getRequestId());
+      //services.getMessenger().send(req, state.view);
+          searchState.view = response.getCurrentView();
-          searchState.possibleCoordinator = coord;
+          searchState.view = response.getCurrentView();
-      JoinResponseMessage m = new JoinResponseMessage("Rejecting the attempt of a member using an older version");
+      JoinResponseMessage m = new JoinResponseMessage("Rejecting the attempt of a member using an older version", incomingRequest.getRequestId());
-      JoinResponseMessage m = new JoinResponseMessage(rejection);
+      JoinResponseMessage m = new JoinResponseMessage(rejection, 0);
+      if (viewCreator != null) {
+        boolean joinResponseSent = viewCreator.informToPendingJoinRequests();
+
+        if (!joinResponseSent && request instanceof JoinRequestMessage) {
+          JoinRequestMessage jreq = (JoinRequestMessage) request;
+          // this will inform about cluster-secret key, as we have authenticated at this point
+          JoinResponseMessage response = new JoinResponseMessage(jreq.getSender(), services.getMessenger().getClusterSecretKey(), jreq.getRequestId());
+          services.getMessenger().send(response);
+        }
+      }
-    if (viewCreator != null) {
-      viewCreator.informToPendingJoinRequests();
-    }
+    
-
+  
+      services.getMessenger().initClusterKey();
-      JoinResponseMessage response = new JoinResponseMessage(mbr, newView);
+      JoinResponseMessage response = new JoinResponseMessage(mbr, newView, 0);
+    addPublicKeysToView(view);
+  private void addPublicKeysToView(NetView view) {
+    String sDHAlgo = services.getConfig().getDistributionConfig().getSecurityUDPDHAlgo();
+    if (sDHAlgo != null && !sDHAlgo.isEmpty()) {
+      List<InternalDistributedMember> mbrs = view.getMembers();
+      Iterator<InternalDistributedMember> itr = mbrs.iterator();
+
+      while (itr.hasNext()) {
+        InternalDistributedMember mbr = itr.next();
+        byte[] pk = services.getMessenger().getPublicKey(mbr);
+        view.setPublicKey(mbr, pk);
+      }
+    }
+  }
+    //If our current view doesn't contaion sender then we wanrt to ignore that view.
-      logger.info("Ignoring the view {} from member {}, which is not in my current view {} ", view, m.getSender(), currentView);
-      return;
+      //but if preparedView contains sender then we don't want to ignore that view.
+      //this may happen when we locator re-join and it take over coordinator's responsibility.
+      if(this.preparedView == null || !this.preparedView.contains(m.getSender())) 
+      { 
+        logger.info("Ignoring the view {} from member {}, which is not in my current view {} ", view, m.getSender(), currentView);
+        return;
+      }
-        ackView(m);
+        ackView(m);
-        if (!m.isRebroadcast()) { // no need to ack a rebroadcast view
-          ackView(m);
-        }
+        if (!m.isRebroadcast()) { // no need to ack a rebroadcast view
+          ackView(m);
+        }
-    FindCoordinatorRequest request = new FindCoordinatorRequest(this.localAddress, state.alreadyTried, state.viewId);
+    String dhalgo = services.getConfig().getDistributionConfig().getSecurityUDPDHAlgo();
+    FindCoordinatorRequest request = new FindCoordinatorRequest(this.localAddress, state.alreadyTried, state.viewId, 
+        services.getMessenger().getPublicKey(localAddress), services.getMessenger().getRequestId(), dhalgo);
+            if(response.getRejectionMessage() != null ) {
+              throw new GemFireConfigException(response.getRejectionMessage());
+            }
+            setCoordinatorPublicKey(response);
-    recipients.remove(localAddress);
-    FindCoordinatorRequest req = new FindCoordinatorRequest(localAddress, state.alreadyTried, state.viewId);
-    req.setRecipients(v.getMembers());
+    recipients.remove(localAddress);    
+   // FindCoordinatorRequest req = new FindCoordinatorRequest(localAddress, state.alreadyTried, state.viewId, services.getMessenger().getPublickey(
+     //   localAddress), services.getMessenger().getRequestId());
+    //req.setRecipients(v.getMembers());
+    
-      services.getMessenger().send(req);
+      
+      String dhalgo = services.getConfig().getDistributionConfig().getSecurityUDPDHAlgo(); 
+      if (!dhalgo.isEmpty()) {
+        //Here we are sending message one-by-one to all recipients as we don't have cluster secret key yet.
+        //Usually this happens when locator re-joins the cluster and it has saved view.
+        for (InternalDistributedMember mbr : v.getMembers()) {
+          Set<InternalDistributedMember> r = new HashSet<>();
+          r.add(mbr);
+          FindCoordinatorRequest req = new FindCoordinatorRequest(localAddress, state.alreadyTried, state.viewId, services.getMessenger().getPublicKey(
+              localAddress), services.getMessenger().getRequestId(), dhalgo);
+          req.setRecipients(r);
+
+          services.getMessenger().send(req, v);
+        }
+      } else {
+        FindCoordinatorRequest req = new FindCoordinatorRequest(localAddress, state.alreadyTried, state.viewId, services.getMessenger().getPublicKey(
+            localAddress), services.getMessenger().getRequestId(), dhalgo);
+        req.setRecipients(v.getMembers());
+
+        services.getMessenger().send(req, v);
+      }
-        joinResponse[0] = rsp;
-        joinResponse.notifyAll();
+        //1. our joinRequest rejected.
+        //2. Member which was coordinator but just now some other member became coordinator
+        //3. we got message with secret key, but still view is coming and that will inform the joining thread
+        if (rsp.getRejectionMessage() != null || rsp.getCurrentView() != null) {
+          joinResponse[0] = rsp;
+          joinResponse.notifyAll();
+        } else {
+          //we got secret key lets add it
+          services.getMessenger().setClusterSecretKey(rsp.getSecretPk());
+        }
-      resp = new FindCoordinatorResponse(v.getCoordinator(), localAddress);
+      resp = new FindCoordinatorResponse(v.getCoordinator(), localAddress, 
+          services.getMessenger().getPublicKey(v.getCoordinator()), req.getRequestId());
-      resp = new FindCoordinatorResponse(localAddress, localAddress);
+      resp = new FindCoordinatorResponse(localAddress, localAddress, 
+          services.getMessenger().getPublicKey(localAddress), req.getRequestId());
+    setCoordinatorPublicKey(resp);
+  }
+  
+  private void setCoordinatorPublicKey(FindCoordinatorResponse response) {
+    if (response.getCoordinator() != null && response.getCoordinatorPublicKey() != null)
+      services.getMessenger().setPublicKey(response.getCoordinatorPublicKey(), response.getCoordinator());
+          newView.setPublicKey(newMember, v.getPublicKey(newMember));
-    synchronized void informToPendingJoinRequests() {
+    synchronized boolean informToPendingJoinRequests() {
+      boolean joinResponseSent = false;
-        return;
+        return joinResponseSent;
-
-          return;
+          return joinResponseSent;
+      NetView v = currentView;
-        case JOIN_REQUEST:
-          logger.info("Informing to pending join requests {}", msg);
-
-          NetView v = currentView;
+        case JOIN_REQUEST:               
+          logger.debug("Informing to pending join requests {} myid {} coord {}", msg, localAddress, v.getCoordinator());
+            joinResponseSent = true;
-            JoinResponseMessage jrm = new JoinResponseMessage(((JoinRequestMessage) msg).getMemberID(), v);
+            JoinResponseMessage jrm = new JoinResponseMessage(((JoinRequestMessage) msg).getMemberID(), v, ((JoinRequestMessage) msg).getRequestId());
+      
+      return joinResponseSent;
+          newView.setPublicKeys(currentView);
+
-      sendJoinResponses(newView, joinReqs);
+  
+  private InternalDistributedMember getMemId(NetMember jgId, List<InternalDistributedMember> members) {
+    for (InternalDistributedMember m : members) {
+      if (((GMSMember) m.getNetMember()).equals(jgId)) {
+        return m;
+      }
+    }
+    return null;
+  }
+
+  @Override
+  public InternalDistributedMember getMemberID(NetMember jgId) {
+    NetView v = currentView;
+    InternalDistributedMember ret = null;
+    if (v != null) {
+      ret = getMemId(jgId, v.getMembers());
+    }
+
+    if (ret == null) {
+      v = preparedView;
+      if (v != null) {
+        ret = getMemId(jgId, v.getMembers());
+      }
+    }
+
+    if (ret == null) {
+      return new InternalDistributedMember(jgId);
+    }
+    
+    return ret;
+  }

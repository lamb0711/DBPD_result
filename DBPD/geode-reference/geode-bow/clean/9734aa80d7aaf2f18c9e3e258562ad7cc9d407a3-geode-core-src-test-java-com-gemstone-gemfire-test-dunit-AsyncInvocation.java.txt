Merge remote-tracking branch 'remotes/origin/feature/GEODE-1162' into feature/GEODE-17-2

+import java.util.concurrent.CancellationException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+ * @param <V> The result type returned by this AsyncInvocation's {@code get} methods
-public class AsyncInvocation<T> {
-  // TODO: davidw Add the ability to get a return value back from the
+public class AsyncInvocation<V> implements Future<V> {
+  // TODO:davidw: Add the ability to get a return value back from the
-  // TODO: reimplement using Futures
+  // TODO:?: reimplement using Futures
-  private final AtomicReference<T> resultValue = new AtomicReference<>();
+  private final AtomicReference<V> resultValue = new AtomicReference<>();
+
+  /** True if this {@code AsyncInvocation} has been cancelled */
+  private boolean cancelled;
-  public AsyncInvocation(final Object target, final String methodName, final Callable<T> work) {
+  public AsyncInvocation(final Object target, final String methodName, final Callable<V> work) {
+   *
+   * @deprecated This method is not required for anything.
+   *
+   * @deprecated This method is not required for anything.
-    checkIsDone("Exception status not available while thread is alive.");
+    try {
+      checkIsDone("Exception status not available while thread is alive.");
+    } catch (IllegalStateException illegalStateException) {
+      throw new AssertionError(illegalStateException);
+    }
-    if (this.resultThrowable.get() instanceof RMIException) {
+    if (this.resultThrowable.get() instanceof RMIException) { // TODO:klund: delete our RMIException
-  public AsyncInvocation<T> checkException() {
-    if (exceptionOccurred()) {
+  public AsyncInvocation<V> checkException() {
+    if (this.resultThrowable.get() != null) {
+   *
+   * @deprecated Please use {@link #get()} instead.
-  public T getResult() throws InterruptedException {
+  public V getResult() throws InterruptedException {
-    return getReturnValue();
+    checkIsDone("Return value not available while thread is alive.");
+    return this.resultValue.get();
+   *
+   * @deprecated Please use {@link #get(long, TimeUnit)} instead.
-  public T getResult(final long millis) throws InterruptedException {
-    join(millis);
-    timeoutIfAlive(millis);
-    checkException();
-    return getReturnValue();
+  public V getResult(final long millis) throws InterruptedException {
+    try {
+      return get(millis, TimeUnit.MILLISECONDS);
+    } catch (ExecutionException executionException) {
+      throw new AssertionError(executionException);
+    } catch (TimeoutException timeoutException) {
+      throw new AssertionError(timeoutException);
+    }
-   * @deprecated Please use {@link #getResult()} instead.
+   * @deprecated Please use {@link #get()} instead.
-  public T getReturnValue() {
+  public V getReturnValue() {
-   * @throws AssertionError wrapping a {@code TimeoutException} if this
-   *         {@code AsyncInvocation} fails to complete within the specified
-   *         timeout of {@code millis}.
-   *
-  public synchronized AsyncInvocation<T> join(final long millis) throws InterruptedException {
+  public synchronized AsyncInvocation<V> join(final long millis) throws InterruptedException {
-    timeoutIfAlive(millis);
-   * @throws AssertionError wrapping a {@code TimeoutException} if this
-   *         {@code AsyncInvocation} fails to complete within the specified
-   *         timeout of {@code millis}.
-   *
-  public synchronized AsyncInvocation<T> join(final long millis, final int nanos) throws InterruptedException {
+  public synchronized AsyncInvocation<V> join(final long millis, final int nanos) throws InterruptedException {
-    timeoutIfAlive(millis);
-   * @throws AssertionError wrapping a {@code TimeoutException} if this
-   *         {@code AsyncInvocation} fails to complete within the default
-   *         timeout of 60 seconds as defined by {@link #DEFAULT_JOIN_MILLIS}.
-   *
-  public AsyncInvocation<T> join() throws InterruptedException {
+  public AsyncInvocation<V> join() throws InterruptedException {
-    timeoutIfAlive(DEFAULT_JOIN_MILLIS);
-  public synchronized AsyncInvocation<T> start() {
+  public synchronized AsyncInvocation<V> start() {
+  @Override
+  public synchronized boolean isCancelled() {
+    return this.cancelled;
+  }
+
+  @Override
+  public synchronized boolean isDone() {
+    return !this.thread.isAlive(); //state != NEW;
+  }
+
+  @Override
+  public synchronized boolean cancel(final boolean mayInterruptIfRunning) {
+    if (this.thread.isAlive()) {
+      if (mayInterruptIfRunning) {
+        this.cancelled = true;
+        this.thread.interrupt();
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /**
+   * Waits if necessary for the work to complete, and then returns the result
+   * of this {@code AsyncInvocation}.
+   *
+   * @return the result of this {@code AsyncInvocation}
+   *
+   * @throws AssertionError wrapping any {@code Exception} thrown by this
+   *         {@code AsyncInvocation}.
+   *
+   * @throws AssertionError wrapping a {@code TimeoutException} if this
+   *         {@code AsyncInvocation} fails to complete within the default
+   *         timeout of 60 seconds as defined by {@link #DEFAULT_JOIN_MILLIS}.
+   *
+   * @throws CancellationException if the computation was cancelled
+   *
+   * @throws ExecutionException if the computation threw an exception
+   *
+   * @throws InterruptedException if the current thread is interrupted.
+   */
+  @Override
+  public V get() throws ExecutionException, InterruptedException {
+    try {
+      return get(DEFAULT_JOIN_MILLIS, TimeUnit.MILLISECONDS);
+    } catch (TimeoutException timeoutException) {
+      throw new AssertionError(timeoutException);
+    }
+  }
+
+  /**
+   * Waits if necessary for at most the given time for the computation
+   * to complete, and then retrieves its result, if available.
+   *
+   * @param  timeout the maximum time to wait
+   * @param  unit the time unit of the timeout argument
+   *
+   * @return the result of this {@code AsyncInvocation}
+   *
+   * @throws AssertionError wrapping any {@code Exception} thrown by this
+   *         {@code AsyncInvocation}.
+   *
+   * @throws AssertionError wrapping a {@code TimeoutException} if this
+   *         {@code AsyncInvocation} fails to complete within the default
+   *         timeout of 60 seconds as defined by {@link #DEFAULT_JOIN_MILLIS}.
+   *
+   * @throws CancellationException if the computation was cancelled
+   *
+   * @throws ExecutionException if the computation threw an exception
+   *
+   * @throws InterruptedException if the current thread is interrupted.
+   *
+   * @throws TimeoutException if the wait timed out
+   */
+  @Override
+  public V get(final long timeout, final TimeUnit unit) throws ExecutionException, InterruptedException, TimeoutException {
+    long millis = unit.toMillis(timeout);
+    join(millis);
+    timeoutIfAlive(millis);
+    checkException();
+    return this.resultValue.get();
+  }
+
-   * Throws {@code AssertionError} if this {@code AsyncInvocation} is not done.
+   * Throws {@code IllegalStateException} if this {@code AsyncInvocation} is
+   * not done.
-   * @throws AssertionError if this {@code AsyncInvocation} is not done.
+   * @throws IllegalStateException if this {@code AsyncInvocation} is not done.
-  private AsyncInvocation<T> checkIsDone(final String message) {
+  private AsyncInvocation<V> checkIsDone(final String message) {
-      throw new AssertionError(message);
+      throw new IllegalStateException(message);
-   * @throws AssertionError wrapping a {@code TimeoutException} if this
-   *         {@code AsyncInvocation} fails to complete within the default
-   *         timeout of 60 seconds as defined by {@link #DEFAULT_JOIN_MILLIS}.
+   * @throws TimeoutException if this {@code AsyncInvocation} fails to complete
+   *         within the default timeout of 60 seconds as defined by
+   *         {@link #DEFAULT_JOIN_MILLIS}.
-  private AsyncInvocation<T> timeoutIfAlive(final long timeout) {
+  private AsyncInvocation<V> timeoutIfAlive(final long timeout) throws TimeoutException {
-      throw new AssertionError(new TimeoutException("Timed out waiting " + timeout + " milliseconds for AsyncInvocation to complete."));
+      throw new TimeoutException("Timed out waiting " + timeout + " milliseconds for AsyncInvocation to complete.");
-  private Runnable runnable(final Callable<T> work) {
+  private Runnable runnable(final Callable<V> work) {

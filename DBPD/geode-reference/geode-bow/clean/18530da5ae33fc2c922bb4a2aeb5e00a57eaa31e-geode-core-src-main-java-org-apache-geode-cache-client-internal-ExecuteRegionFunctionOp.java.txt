GEODE-6798: Refactoring of client function execution logic (#3710)

* Some unit tests for the ExecuteRegionFunctionOpImplTest constructors
* Do not allocate failedNodes Collection unless necessary

+import java.util.Collections;
+  private static void execute(ExecutablePool pool, String region, String function,
+      ServerRegionFunctionExecutor serverRegionExecutor, ResultCollector resultCollector,
+      byte hasResult, int maxRetryAttempts, boolean isHA, boolean optimizeForWrite,
+      ExecuteRegionFunctionOpImpl op, boolean isReexecute, Set<String> failedNodes) {
+
+    if (!isHA) {
+      maxRetryAttempts = 0;
+    }
+
+    do {
+      try {
+        if (isReexecute) {
+          failedNodes = ensureMutability(failedNodes);
+          op = new ExecuteRegionFunctionOpImpl(op,
+              (byte) 1/* isReExecute */, failedNodes);
+        }
+        pool.execute(op, 0);
+        return;
+      } catch (InternalFunctionInvocationTargetException e) {
+        resultCollector.clearResults();
+        if (!isHA) {
+          return;
+        }
+        isReexecute = true;
+        Set<String> failedNodesIds = e.getFailedNodeSet();
+        failedNodes = ensureMutability(failedNodes);
+        failedNodes.clear();
+        if (failedNodesIds != null) {
+          failedNodes.addAll(failedNodesIds);
+        }
+      } catch (ServerOperationException | NoAvailableServersException failedException) {
+        throw failedException;
+      } catch (ServerConnectivityException se) {
+
+        if (maxRetryAttempts == PoolFactory.DEFAULT_RETRY_ATTEMPTS) {
+          // If the retryAttempt is set to default(-1). Try it on all servers once.
+          // Calculating number of servers when function is re-executed as it involves
+          // messaging locator.
+          maxRetryAttempts = ((PoolImpl) pool).getConnectionSource().getAllServers().size() - 1;
+        }
+
+        if ((maxRetryAttempts--) < 1) {
+          throw se;
+        }
+
+        isReexecute = true;
+        resultCollector.clearResults();
+        failedNodes = ensureMutability(failedNodes);
+        failedNodes.clear();
+      }
+    } while (true);
+  }
+
+  private static Set<String> ensureMutability(final Set<String> failedNodes) {
+    if (failedNodes == Collections.EMPTY_SET) {
+      return new HashSet<>();
+    }
+    return failedNodes;
+  }
+
+   * @param hasResult is used to collect the results from the Server
+   * @param maxRetryAttempts Maximum number of retry attempts
-  public static void execute(ExecutablePool pool, String region, Function function,
+  static void execute(ExecutablePool pool, String region, Function function,
-      byte hasResult, int mRetryAttempts, final int timeoutMs) {
+      byte hasResult, int maxRetryAttempts, final int timeoutMs) {
-    ExecuteRegionFunctionOpImpl op =
-        new ExecuteRegionFunctionOpImpl(region, function, serverRegionExecutor,
-            resultCollector, hasResult, new HashSet<>(), timeoutMs);
-    boolean reexecute = false;
-    boolean reexecuteForServ = false;
-    Set<String> failedNodes = new HashSet<>();
-    AbstractOp reexecOp;
+    ExecuteRegionFunctionOpImpl op = new ExecuteRegionFunctionOpImpl(region, function,
+        serverRegionExecutor, resultCollector, timeoutMs);
-    int maxRetryAttempts = mRetryAttempts;
-    if (!function.isHA()) {
-      maxRetryAttempts = 0;
-    }
-
-    do {
-      try {
-        if (reexecuteForServ) {
-          reexecOp = new ExecuteRegionFunctionOpImpl(op,
-              (byte) 1/* isReExecute */, failedNodes);
-          pool.execute(reexecOp, 0);
-        } else {
-          pool.execute(op, 0);
-        }
-        reexecute = false;
-        reexecuteForServ = false;
-      } catch (InternalFunctionInvocationTargetException e) {
-        reexecute = true;
-        resultCollector.clearResults();
-        Set<String> failedNodesIds = e.getFailedNodeSet();
-        failedNodes.clear();
-        if (failedNodesIds != null) {
-          failedNodes.addAll(failedNodesIds);
-        }
-      } catch (ServerOperationException | NoAvailableServersException failedException) {
-        throw failedException;
-      } catch (ServerConnectivityException se) {
-
-        if (maxRetryAttempts == PoolFactory.DEFAULT_RETRY_ATTEMPTS) {
-          // If the retryAttempt is set to default(-1). Try it on all servers once.
-          // Calculating number of servers when function is re-executed as it involves
-          // messaging locator.
-          maxRetryAttempts = ((PoolImpl) pool).getConnectionSource().getAllServers().size() - 1;
-        }
-
-        if ((maxRetryAttempts--) < 1) {
-          throw se;
-        }
-
-        reexecuteForServ = true;
-        resultCollector.clearResults();
-        failedNodes.clear();
-      }
-    } while (reexecuteForServ);
-
-    if (reexecute && function.isHA()) {
-      ExecuteRegionFunctionOp.reexecute(pool, region, function, serverRegionExecutor,
-          resultCollector, hasResult, failedNodes, maxRetryAttempts, timeoutMs);
-    }
+    execute(pool, region, function.getId(), serverRegionExecutor, resultCollector, hasResult,
+        maxRetryAttempts, function.isHA(), function.optimizeForWrite(), op, false,
+        Collections.emptySet());
-  public static void execute(ExecutablePool pool, String region, String function,
+  static void execute(ExecutablePool pool, String region, String function,
-      byte hasResult, int mRetryAttempts, boolean isHA, boolean optimizeForWrite,
+      byte hasResult, int maxRetryAttempts, boolean isHA, boolean optimizeForWrite,
-    ExecuteRegionFunctionOpImpl op =
-        new ExecuteRegionFunctionOpImpl(region, function, serverRegionExecutor,
-            resultCollector, hasResult, new HashSet<>(), isHA, optimizeForWrite, true, timeoutMs);
-    boolean reexecute = false;
-    boolean reexecuteForServ = false;
-    Set<String> failedNodes = new HashSet<>();
-    AbstractOp reexecOp;
+    ExecuteRegionFunctionOpImpl op = new ExecuteRegionFunctionOpImpl(region, function,
+        serverRegionExecutor, resultCollector, hasResult, isHA, optimizeForWrite,
+        true, timeoutMs);
-    int maxRetryAttempts = mRetryAttempts;
-    if (!isHA) {
-      maxRetryAttempts = 0;
-    }
-
-    do {
-      try {
-        if (reexecuteForServ) {
-          reexecOp = new ExecuteRegionFunctionOpImpl(op,
-              (byte) 1/* isReExecute */, failedNodes);
-          pool.execute(reexecOp, 0);
-        } else {
-          pool.execute(op, 0);
-        }
-        reexecute = false;
-        reexecuteForServ = false;
-      } catch (InternalFunctionInvocationTargetException e) {
-        reexecute = true;
-        resultCollector.clearResults();
-        Set<String> failedNodesIds = e.getFailedNodeSet();
-        failedNodes.clear();
-        if (failedNodesIds != null) {
-          failedNodes.addAll(failedNodesIds);
-        }
-      } catch (ServerOperationException | NoAvailableServersException failedException) {
-        throw failedException;
-      } catch (ServerConnectivityException se) {
-
-        if (maxRetryAttempts == PoolFactory.DEFAULT_RETRY_ATTEMPTS) {
-          // If the retryAttempt is set to default(-1). Try it on all servers once.
-          // Calculating number of servers when function is re-executed as it involves
-          // messaging locator.
-          maxRetryAttempts = ((PoolImpl) pool).getConnectionSource().getAllServers().size() - 1;
-        }
-
-        if ((maxRetryAttempts--) < 1) {
-          throw se;
-        }
-
-        reexecuteForServ = true;
-        resultCollector.clearResults();
-        failedNodes.clear();
-      }
-    } while (reexecuteForServ);
-
-    if (reexecute && isHA) {
-      ExecuteRegionFunctionOp.reexecute(pool, region, function, serverRegionExecutor,
-          resultCollector, hasResult, failedNodes, maxRetryAttempts, isHA, optimizeForWrite,
-          timeoutMs);
-    }
+    execute(pool, region, function, serverRegionExecutor, resultCollector, hasResult,
+        maxRetryAttempts, isHA, optimizeForWrite, op, false, Collections.emptySet());
-    ExecuteRegionFunctionOpImpl op =
-        new ExecuteRegionFunctionOpImpl(region, function, serverRegionExecutor,
-            resultCollector, hasResult, new HashSet<>(), timeoutMs);
-    boolean reexecute = true;
-    int maxRetryAttempts = retryAttempts;
+    ExecuteRegionFunctionOpImpl op = new ExecuteRegionFunctionOpImpl(region, function,
+        serverRegionExecutor, resultCollector, timeoutMs);
-    do {
-      AbstractOp reExecuteOp =
-          new ExecuteRegionFunctionOpImpl(op, (byte) 1/* isReExecute */, failedNodes);
-
-      try {
-        pool.execute(reExecuteOp, 0);
-        reexecute = false;
-      } catch (InternalFunctionInvocationTargetException e) {
-        resultCollector.clearResults();
-        Set<String> failedNodesIds = e.getFailedNodeSet();
-        failedNodes.clear();
-        if (failedNodesIds != null) {
-          failedNodes.addAll(failedNodesIds);
-        }
-      } catch (ServerOperationException | NoAvailableServersException failedException) {
-        throw failedException;
-      } catch (ServerConnectivityException se) {
-
-        if (maxRetryAttempts == PoolFactory.DEFAULT_RETRY_ATTEMPTS) {
-          // If the retryAttempt is set to default(-1). Try it on all servers once.
-          // Calculating number of servers when function is re-executed as it involves
-          // messaging locator.
-          maxRetryAttempts = ((PoolImpl) pool).getConnectionSource().getAllServers().size() - 1;
-        }
-
-        if ((maxRetryAttempts--) < 1) {
-          throw se;
-        }
-
-        resultCollector.clearResults();
-        failedNodes.clear();
-      }
-    } while (reexecute);
+    execute(pool, region, function.getId(), serverRegionExecutor, resultCollector, hasResult,
+        retryAttempts, function.isHA(), function.optimizeForWrite(), op, true, failedNodes);
-    ExecuteRegionFunctionOpImpl op =
-        new ExecuteRegionFunctionOpImpl(region, function, serverRegionExecutor,
-            resultCollector, hasResult, new HashSet<>(), isHA, optimizeForWrite, true, timeoutMs);
-    boolean reexecute = true;
-    int maxRetryAttempts = retryAttempts;
+    ExecuteRegionFunctionOpImpl op = new ExecuteRegionFunctionOpImpl(region, function,
+        serverRegionExecutor, resultCollector, hasResult, isHA,
+        optimizeForWrite, true, timeoutMs);
-    do {
-      ExecuteRegionFunctionOpImpl reExecuteOp =
-          new ExecuteRegionFunctionOpImpl(op, (byte) 1/* isReExecute */, failedNodes);
-
-      try {
-        pool.execute(reExecuteOp, 0);
-        reexecute = false;
-      } catch (InternalFunctionInvocationTargetException e) {
-        resultCollector.clearResults();
-        Set<String> failedNodesIds = e.getFailedNodeSet();
-        failedNodes.clear();
-        if (failedNodesIds != null) {
-          failedNodes.addAll(failedNodesIds);
-        }
-      } catch (ServerOperationException | NoAvailableServersException failedException) {
-        throw failedException;
-      } catch (ServerConnectivityException se) {
-
-        if (maxRetryAttempts == PoolFactory.DEFAULT_RETRY_ATTEMPTS) {
-          // If the retryAttempt is set to default(-1). Try it on all servers once.
-          // Calculating number of servers when function is re-executed as it involves
-          // messaging locator.
-          maxRetryAttempts = ((PoolImpl) pool).getConnectionSource().getAllServers().size() - 1;
-        }
-
-        if ((maxRetryAttempts--) < 1) {
-          throw se;
-        }
-
-        resultCollector.clearResults();
-        failedNodes.clear();
-      }
-    } while (reexecute);
+    execute(pool, region, function, serverRegionExecutor, resultCollector, hasResult,
+        retryAttempts, isHA, optimizeForWrite, op, true, failedNodes);
+    private static final int PART_COUNT = 8;
-    ExecuteRegionFunctionOpImpl(String region, Function function,
-        ServerRegionFunctionExecutor serverRegionExecutor, ResultCollector rc, byte hasResult,
-        Set<String> removedNodes, final int timeoutMs) {
-      super(MessageType.EXECUTE_REGION_FUNCTION,
-          8 + serverRegionExecutor.getFilter().size() + removedNodes.size(), timeoutMs);
+    private static int getMessagePartCount(int filterSize, int removedNodesSize) {
+      return PART_COUNT + filterSize + removedNodesSize;
+    }
+
+    private void fillMessage(String region, Function function, String functionId,
+        ServerRegionFunctionExecutor serverRegionExecutor,
+        Set<String> removedNodes, byte functionState, byte flags) {
-      byte functionState = AbstractExecution.getFunctionState(function.isHA(), function.hasResult(),
-          function.optimizeForWrite());
-
-      if (serverRegionExecutor.isFnSerializationReqd()) {
+      if (function != null && serverRegionExecutor.isFnSerializationReqd()) {
-        getMessage().addStringOrObjPart(function.getId());
+        getMessage().addStringOrObjPart(functionId);
+
-      executeOnBucketSet = serverRegionExecutor.getExecuteOnBucketSetFlag();
-      byte flags = ExecuteFunctionHelper.createFlags(executeOnBucketSet, isReExecute);
+    }
+    ExecuteRegionFunctionOpImpl(String region, Function function,
+        ServerRegionFunctionExecutor serverRegionExecutor, ResultCollector rc,
+        final int timeoutMs) {
+      super(MessageType.EXECUTE_REGION_FUNCTION,
+          getMessagePartCount(serverRegionExecutor.getFilter().size(), 0), timeoutMs);
+      executeOnBucketSet = serverRegionExecutor.getExecuteOnBucketSetFlag();
+      byte flags = ExecuteFunctionHelper.createFlags(executeOnBucketSet, isReExecute);
+      byte functionState = AbstractExecution.getFunctionState(function.isHA(), function.hasResult(),
+          function.optimizeForWrite());
+      failedNodes = Collections.emptySet();
+      fillMessage(region,
+          function, function.getId(),
+          serverRegionExecutor, failedNodes, functionState, flags);
-      this.hasResult = functionState;
-      failedNodes = removedNodes;
+      hasResult = functionState;
-    ExecuteRegionFunctionOpImpl(String region, String function,
+    ExecuteRegionFunctionOpImpl(String region, String functionId,
-        Set<String> removedNodes, boolean isHA, boolean optimizeForWrite,
+        boolean isHA, boolean optimizeForWrite,
-          8 + serverRegionExecutor.getFilter().size() + removedNodes.size(), timeoutMs);
-      Set routingObjects = serverRegionExecutor.getFilter();
+          getMessagePartCount(serverRegionExecutor.getFilter().size(), 0), timeoutMs);
+
-      Object args = serverRegionExecutor.getArguments();
-      MemberMappedArgument memberMappedArg = serverRegionExecutor.getMemberMappedArgument();
-      addBytes(functionState);
-      getMessage().addStringPart(region, true);
-      getMessage().addStringOrObjPart(function);
-      getMessage().addObjPart(args);
-      getMessage().addObjPart(memberMappedArg);
-      getMessage().addBytesPart(new byte[] {flags});
-      getMessage().addIntPart(routingObjects.size());
-      for (Object key : routingObjects) {
-        getMessage().addStringOrObjPart(key);
-      }
-      getMessage().addIntPart(removedNodes.size());
-      for (Object nodes : removedNodes) {
-        getMessage().addStringOrObjPart(nodes);
-      }
+      failedNodes = Collections.emptySet();
+      fillMessage(region, null, functionId, serverRegionExecutor, failedNodes, functionState,
+          flags);
-      functionId = function;
+      this.functionId = functionId;
-      failedNodes = removedNodes;
-          newop.getResultCollector(), newop.getHasResult(), new HashSet<>(), newop.isHA(),
+          newop.getResultCollector(), newop.getHasResult(), newop.isHA(),
-          8 + op.executor.getFilter().size() + removedNodes.size(), op.getTimeoutMs());
+          getMessagePartCount(op.executor.getFilter().size(), removedNodes.size()),
+          op.getTimeoutMs());
-      Set routingObjects = executor.getFilter();
-      Object args = executor.getArguments();
-      MemberMappedArgument memberMappedArg = executor.getMemberMappedArgument();
-      getMessage().clear();
-      addBytes(hasResult);
-      getMessage().addStringPart(regionName, true);
-      if (executor.isFnSerializationReqd()) {
-        getMessage().addStringOrObjPart(function);
-      } else {
-        getMessage().addStringOrObjPart(functionId);
-      }
-      getMessage().addObjPart(args);
-      getMessage().addObjPart(memberMappedArg);
-      getMessage().addBytesPart(new byte[] {flags});
-      getMessage().addIntPart(routingObjects.size());
-      for (Object key : routingObjects) {
-        getMessage().addStringOrObjPart(key);
-      }
-      getMessage().addIntPart(removedNodes.size());
-      for (Object nodes : removedNodes) {
-        getMessage().addStringOrObjPart(nodes);
-      }
+      fillMessage(regionName, function, functionId,
+          executor, removedNodes, hasResult, flags);
+                  failedNodes = ensureMutability(failedNodes);
+                      failedNodes = ensureMutability(failedNodes);
+                failedNodes = ensureMutability(failedNodes);

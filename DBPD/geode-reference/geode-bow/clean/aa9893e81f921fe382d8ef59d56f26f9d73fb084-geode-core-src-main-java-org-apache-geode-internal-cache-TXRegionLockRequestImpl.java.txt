GEODE-5557: Fix for false read conflict exception (#3492)

* Use HashMap instead of HashSet in TXRegionLockRequestImpl so that read and write lock held can be distinguished.
* Use boolean value to indicate a key is read locked by a read operation when detectReadConflicts is enabled.

+import java.util.HashMap;
-import java.util.Set;
+import java.util.Map;
+import org.apache.geode.internal.Version;
-  private Set<Object> entryKeys;
+  private Map<Object, Boolean> entryKeys;
-  public TXRegionLockRequestImpl(String regionPath, Set<Object> entryKeys) {
+  public TXRegionLockRequestImpl(String regionPath, Map<Object, Boolean> entryKeys) {
-  public void addEntryKeys(Set<Object> s) {
-    if (s == null || s.isEmpty()) {
+  public void addEntryKeys(Map<Object, Boolean> map) {
+    if (map == null || map.isEmpty()) {
-      // Create new temporary HashSet. Fix for defect # 44472.
-      final HashSet<Object> tmp = new HashSet<Object>(s.size());
-      tmp.addAll(s);
+      // Create new temporary HashMap. Fix for defect # 44472.
+      final HashMap<Object, Boolean> tmp = new HashMap<Object, Boolean>(map.size());
+      tmp.putAll(map);
-      final HashSet<Object> tmp = new HashSet<Object>(this.entryKeys.size() + s.size());
-      tmp.addAll(s);
-      tmp.addAll(this.entryKeys);
+      final HashMap<Object, Boolean> tmp =
+          new HashMap<Object, Boolean>(this.entryKeys.size() + map.size());
+      tmp.putAll(this.entryKeys);
+      for (Map.Entry<Object, Boolean> entry : map.entrySet()) {
+        addEntryKey(entry.getKey(), entry.getValue());
+      }
-  public void addEntryKey(Object key) {
+  public void addEntryKey(Object key, Boolean isEvent) {
-      this.entryKeys = new HashSet<Object>();
+      this.entryKeys = new HashMap<Object, Boolean>();
-    this.entryKeys.add(key);
+    if (!this.entryKeys.getOrDefault(key, Boolean.FALSE)) {
+      this.entryKeys.put(key, isEvent);
+    }
-      this.entryKeys = readEntryKeySet(size, in);
+      if (InternalDataSerializer.getVersionForDataStream(in).compareTo(Version.GEODE_1_10_0) >= 0) {
+        this.entryKeys = readEntryKeyMap(size, in);
+      } else {
+        this.entryKeys = readEntryKeySet(size, in);
+      }
+
-  private Set<Object> readEntryKeySet(final int size, final DataInput in)
+  private Map<Object, Boolean> readEntryKeyMap(final int size, final DataInput in)
+      throws IOException, ClassNotFoundException {
+
+    if (logger.isTraceEnabled(LogMarker.SERIALIZER_VERBOSE)) {
+      logger.trace(LogMarker.SERIALIZER_VERBOSE, "Reading HashMap with size {}", size);
+    }
+    if (size == -1) {
+      return null;
+    }
+
+    final HashMap<Object, Boolean> map = new HashMap<Object, Boolean>(size);
+    Object key;
+    Boolean value;
+    for (int i = 0; i < size; i++) {
+      key = DataSerializer.readObject(in);
+      value = DataSerializer.readObject(in);
+      map.put(key, value);
+    }
+
+    if (logger.isDebugEnabled()) {
+      logger.debug("Read HashMap with {} elements: {}", size, map);
+    }
+
+    return map;
+  }
+
+  private Map<Object, Boolean> readEntryKeySet(final int size, final DataInput in)
-    final HashSet<Object> set = new HashSet<Object>(size);
+    final HashMap<Object, Boolean> map = new HashMap<Object, Boolean>(size);
+    Boolean value;
-      set.add(key);
+      value = true;
+      map.put(key, value);
-      logger.debug("Read HashSet with {} elements: {}", size, set);
+      logger.debug("Read HashSet with {} elements: {}", size, map);
-    return set;
+    return map;
-    InternalDataSerializer.writeSet(this.entryKeys, out);
+    if (InternalDataSerializer.getVersionForDataStream(out).compareTo(Version.GEODE_1_10_0) >= 0) {
+      InternalDataSerializer.writeHashMap(this.entryKeys, out);
+    } else {
+      HashSet hashset = new HashSet(this.entryKeys.keySet());
+      InternalDataSerializer.writeHashSet(hashset, out);
+    }
-  public Set<Object> getKeys() {
+  public Map<Object, Boolean> getKeys() {

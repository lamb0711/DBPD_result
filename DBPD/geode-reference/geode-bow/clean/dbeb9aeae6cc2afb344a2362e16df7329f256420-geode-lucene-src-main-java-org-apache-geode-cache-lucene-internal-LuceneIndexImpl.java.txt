Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *   http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import org.apache.geode.cache.lucene.internal.filesystem.ChunkKey;
-import org.apache.geode.cache.lucene.internal.filesystem.File;
-import org.apache.geode.cache.lucene.internal.filesystem.FileSystemStats;
+import org.apache.geode.cache.asyncqueue.internal.AsyncEventQueueImpl;
-  
+
-    
+
- 
+
-    return (LocalRegion)cache.getRegion(regionPath);
+    return (LocalRegion) cache.getRegion(regionPath);
-  
+
-  public boolean waitUntilFlushed(int maxWaitInMillisecond) {
+  public boolean waitUntilFlushed(long timeout, TimeUnit unit) throws InterruptedException {
-    AsyncEventQueue queue = (AsyncEventQueue)cache.getAsyncEventQueue(aeqId);
-    boolean flushed = false;
+    AsyncEventQueueImpl queue = (AsyncEventQueueImpl) cache.getAsyncEventQueue(aeqId);
-      long start = System.nanoTime();
-      while (System.nanoTime() - start < TimeUnit.MILLISECONDS.toNanos(maxWaitInMillisecond)) {
-        if (0 == queue.size()) {
-          flushed = true;
-          break;
-        } else {
-          try {
-            Thread.sleep(200);
-          } catch (InterruptedException e) {
-          }
-        }
-      }
-    } else { 
-      throw new IllegalArgumentException("The AEQ does not exist for the index "+indexName+" region "+regionPath);
+      return queue.waitUntilFlushed(timeout, unit);
+    } else {
+      throw new IllegalArgumentException(
+          "The AEQ does not exist for the index " + indexName + " region " + regionPath);
-
-    return flushed;
-  
+
-  
+
-    this.fieldAnalyzers = fieldAnalyzers == null ? null : Collections.unmodifiableMap(fieldAnalyzers);
+    this.fieldAnalyzers =
+        fieldAnalyzers == null ? null : Collections.unmodifiableMap(fieldAnalyzers);
-      //assert dataRegion != null;
+      // assert dataRegion != null;
-      
+
-  
+
-  
+
-    AsyncEventQueueFactoryImpl factory = (AsyncEventQueueFactoryImpl) cache.createAsyncEventQueueFactory();
+    AsyncEventQueueFactoryImpl factory =
+        (AsyncEventQueueFactoryImpl) cache.createAsyncEventQueueFactory();
-/**
-   * Register an extension with the region
-   * so that xml will be generated for this index.
+  /**
+   * Register an extension with the region so that xml will be generated for this index.
-  protected <K, V> Region<K, V> createRegion(final String regionName, final RegionAttributes<K, V> attributes) {
-    // Create InternalRegionArguments to set isUsedForMetaRegion true to suppress xml generation (among other things)
-    InternalRegionArguments ira = new InternalRegionArguments().setDestroyLockFlag(true).setRecreateFlag(false)
-        .setSnapshotInputStream(null).setImageTarget(null).setIsUsedForMetaRegion(true);
+  protected <K, V> Region<K, V> createRegion(final String regionName,
+      final RegionAttributes<K, V> attributes) {
+    // Create InternalRegionArguments to set isUsedForMetaRegion true to suppress xml generation
+    // (among other things)
+    InternalRegionArguments ira =
+        new InternalRegionArguments().setDestroyLockFlag(true).setRecreateFlag(false)
+            .setSnapshotInputStream(null).setImageTarget(null).setIsUsedForMetaRegion(true);
-      return ((GemFireCacheImpl)this.cache).createVMRegion(regionName, attributes, ira);
+      return ((GemFireCacheImpl) this.cache).createVMRegion(regionName, attributes, ira);
-      InternalGemFireError ige = new InternalGemFireError(LocalizedStrings.GemFireCache_UNEXPECTED_EXCEPTION.toLocalizedString());
+      InternalGemFireError ige = new InternalGemFireError(
+          LocalizedStrings.GemFireCache_UNEXPECTED_EXCEPTION.toLocalizedString());

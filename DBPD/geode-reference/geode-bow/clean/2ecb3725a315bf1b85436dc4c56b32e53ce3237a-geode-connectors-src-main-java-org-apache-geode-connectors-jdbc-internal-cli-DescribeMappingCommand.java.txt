GEODE-4863: refactor jdbc commands to use this public cluster configuration api (#1776)

   * refactored jdbc connector commands to use public cc service
   * removed JdbcConnectorServiceXmlGenerator
   * removed RegionMappingBuilder & ConnectionConfigBuilder
   * if cc service is running then user can only alter whats available in CC
   * describe & List commands now list entries from cc service
   * converted some integration tests to junits
   * removed unwanted functions, tests

Signed-off-by: Jinmei Liao <jiliao@pivotal.io>

-import java.util.List;
-import java.util.Set;
-
-import org.apache.geode.cache.execute.ResultCollector;
-import org.apache.geode.connectors.jdbc.internal.RegionMapping;
-import org.apache.geode.distributed.DistributedMember;
+import org.apache.geode.connectors.jdbc.internal.configuration.ConnectorService;
+import org.apache.geode.distributed.ClusterConfigurationService;
+import org.apache.geode.management.internal.cli.exceptions.EntityNotFoundException;
-      EXPERIMENTAL + "Describe the specified jdbc mapping.";
+      EXPERIMENTAL + "Describe the jdbc mapping in cluster configuration";
-    // input
-    Set<DistributedMember> members = getMembers(null, null);
-    if (members.isEmpty()) {
-      return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
+    ClusterConfigurationService ccService = getConfigurationService();
+    if (ccService == null) {
+      return ResultBuilder.createInfoResult("cluster configuration service is not running");
-    DistributedMember targetMember = members.iterator().next();
-
-    // action
-    ResultCollector<RegionMapping, List<RegionMapping>> resultCollector =
-        execute(new DescribeMappingFunction(), regionName, targetMember);
-
-    // output
-    RegionMapping config = resultCollector.getResult().get(0);
-    if (config == null) {
-      return ResultBuilder.createInfoResult(
-          String.format(EXPERIMENTAL + "\n" + "Mapping for region '%s' not found", regionName));
+    // search for the connection that has this id to see if it exists
+    ConnectorService service =
+        ccService.getCustomCacheElement("cluster", "connector-service", ConnectorService.class);
+    if (service == null) {
+      throw new EntityNotFoundException(
+          EXPERIMENTAL + "\n" + "mapping for region '" + regionName + "' not found");
+    }
+    ConnectorService.RegionMapping mapping =
+        ccService.findIdentifiable(service.getRegionMapping(), regionName);
+    if (mapping == null) {
+      throw new EntityNotFoundException(
+          EXPERIMENTAL + "\n" + "mapping for region '" + regionName + "' not found");
-    fillResultData(config, resultData);
+    fillResultData(mapping, resultData);
-  ResultCollector<RegionMapping, List<RegionMapping>> execute(DescribeMappingFunction function,
-      String connectionName, DistributedMember targetMember) {
-    return (ResultCollector<RegionMapping, List<RegionMapping>>) executeFunction(function,
-        connectionName, targetMember);
-  }
-
-  private void fillResultData(RegionMapping mapping, CompositeResultData resultData) {
+  private void fillResultData(ConnectorService.RegionMapping mapping,
+      CompositeResultData resultData) {
-    if (mapping.getFieldToColumnMap() != null) {
-      mapping.getFieldToColumnMap().entrySet().forEach((entry) -> {
-        tabularResultData.accumulate("Field", entry.getKey());
-        tabularResultData.accumulate("Column", entry.getValue());
+    if (mapping.getFieldMapping() != null) {
+      mapping.getFieldMapping().forEach((entry) -> {
+        tabularResultData.accumulate("Field", entry.getFieldName());
+        tabularResultData.accumulate("Column", entry.getColumnName());

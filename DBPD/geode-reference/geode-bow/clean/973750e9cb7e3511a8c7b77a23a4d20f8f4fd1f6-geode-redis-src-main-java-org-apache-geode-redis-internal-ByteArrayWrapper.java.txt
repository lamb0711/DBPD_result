ByteArrayWrapper now implementes DataSerializableFixedID which should save us 40 bytes each time it is serialized. (#5180)

- It no longer caches its "hash" and "string" form which will cut down its memory overhead by over 70%.
- When we convert a sequence of bytes to a String, the Coder no longer calls intern which will also save some memory and time.
-import org.apache.geode.DataSerializable;
+import org.apache.geode.internal.serialization.DataSerializableFixedID;
+import org.apache.geode.internal.serialization.DeserializationContext;
+import org.apache.geode.internal.serialization.SerializationContext;
+import org.apache.geode.internal.serialization.Version;
-public class ByteArrayWrapper implements DataSerializable, Comparable<ByteArrayWrapper> {
-  /**
-   * Generated serialVerionUID
-   */
-  private static final long serialVersionUID = 9066391742266642992L;
-
+public class ByteArrayWrapper implements DataSerializableFixedID, Comparable<ByteArrayWrapper> {
-   * Hash of {@link #value}, this value is cached for performance
-   */
-  private transient int hashCode;
-
-  private transient String toString;
-
-  /**
-    this.hashCode = Arrays.hashCode(value);
-  }
-
-  @Override
-  public void toData(DataOutput out) throws IOException {
-    DataSerializer.writeByteArray(value, out);
-  }
-
-  @Override
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    this.value = DataSerializer.readByteArray(in);
-    this.hashCode = Arrays.hashCode(this.value);
-    if (toString == null) {
-      toString = Coder.bytesToString(this.value);
-    }
-    return toString;
+    return Coder.bytesToString(value);
-    this.toString = null;
-    this.hashCode = Arrays.hashCode(bytes);
-   * Hash code for byte[] wrapped by this object, the actual hashcode is determined by
-   * Arrays.hashCode(byte[])
+   * Hash code for byte[] wrapped by this object
-    return this.hashCode;
+    return Arrays.hashCode(value);
+
+  @Override
+  public int getDSFID() {
+    return DataSerializableFixedID.REDIS_BYTE_ARRAY_WRAPPER;
+  }
+
+  @Override
+  public void toData(DataOutput out, SerializationContext context) throws IOException {
+    DataSerializer.writeByteArray(value, out);
+  }
+
+  @Override
+  public void fromData(DataInput in, DeserializationContext context)
+      throws IOException, ClassNotFoundException {
+    value = DataSerializer.readByteArray(in);
+  }
+
+  @Override
+  public Version[] getSerializationVersions() {
+    return null;
+  }

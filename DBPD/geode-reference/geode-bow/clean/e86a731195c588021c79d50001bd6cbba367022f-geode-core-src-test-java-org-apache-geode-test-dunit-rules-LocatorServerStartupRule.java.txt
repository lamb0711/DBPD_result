Merge branch 'release/1.3.0'

-import org.apache.geode.internal.AvailablePortHelper;
-import org.apache.geode.test.dunit.VM;
-import org.apache.geode.test.dunit.standalone.DUnitLauncher;
-import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;
-import org.junit.rules.ExternalResource;
-import org.junit.rules.TemporaryFolder;
-
-import java.util.Arrays;
-import java.util.Objects;
+import java.util.stream.IntStream;
+
+import org.junit.rules.ExternalResource;
+import org.junit.rules.TemporaryFolder;
+
+import org.apache.geode.internal.AvailablePortHelper;
+import org.apache.geode.test.dunit.VM;
+import org.apache.geode.test.dunit.standalone.DUnitLauncher;
+import org.apache.geode.test.junit.rules.Locator;
+import org.apache.geode.test.junit.rules.LocatorStarterRule;
+import org.apache.geode.test.junit.rules.Member;
+import org.apache.geode.test.junit.rules.MemberStarterRule;
+import org.apache.geode.test.junit.rules.Server;
+import org.apache.geode.test.junit.rules.ServerStarterRule;
+import org.apache.geode.test.junit.rules.serializable.SerializableTemporaryFolder;
-
-  private TemporaryFolder temporaryFolder = new SerializableTemporaryFolder();
+  private TemporaryFolder tempWorkingDir;
+  private boolean logFile = false;
+
+  /**
+   * This will use a temporary folder to hold all the vm directories instead of using dunit folder.
+   * It will set each VM's working dir to its respective sub-directories.
+   *
+   * use this if you want to examine each member's file system without worrying about it's being
+   * contaminated with DUnitLauncher's log files that exists in each dunit/vm folder such as
+   * locator0View.dat and locator0views.log and other random log files. This will cause the VMs to
+   * be bounced after test is done, because it dynamically changes the user.dir system property.
+   */
+  public LocatorServerStartupRule withTempWorkingDir() {
+    tempWorkingDir = new SerializableTemporaryFolder();
+    return this;
+  }
+
+  public boolean useTempWorkingDir() {
+    return tempWorkingDir != null;
+  }
+
+  /**
+   * this will allow all the logs go into log files instead of going into the console output
+   */
+  public LocatorServerStartupRule withLogFile() {
+    this.logFile = true;
+    return this;
+  }
+
-    temporaryFolder.create();
-    members = new MemberVM[4];
+    if (useTempWorkingDir()) {
+      tempWorkingDir.create();
+    }
+    members = new MemberVM[DUnitLauncher.NUM_VMS];
-    DUnitLauncher.closeAndCheckForSuspects();
-    restoreSystemProperties.after();
-    temporaryFolder.delete();
-    Arrays.stream(members).filter(Objects::nonNull).forEach(MemberVM::stopMember);
+    try {
+      DUnitLauncher.closeAndCheckForSuspects();
+    } finally {
+      MemberStarterRule.disconnectDSIfAny();
+      IntStream.range(0, DUnitLauncher.NUM_VMS).forEach(this::stopVM);
+
+      if (useTempWorkingDir()) {
+        tempWorkingDir.delete();
+      }
+      restoreSystemProperties.after();
+    }
-  public MemberVM<Locator> startLocatorVM(int index, Properties properties) throws Exception {
-    String name = "locator-" + index;
-    properties.setProperty(NAME, name);
-    File workingDir = createWorkingDirForMember(name);
-    VM locatorVM = getHost(0).getVM(index);
+  public MemberVM<Locator> startLocatorVM(int index, Properties specifiedProperties)
+      throws Exception {
+    Properties properties = new Properties();
+    properties.putAll(specifiedProperties);
+
+    String defaultName = "locator-" + index;
+    properties.putIfAbsent(NAME, defaultName);
+    String name = properties.getProperty(NAME);
+
+    VM locatorVM = getVM(index);
-      locatorStarter = new LocatorStarterRule(workingDir);
+      locatorStarter = new LocatorStarterRule();
+      if (useTempWorkingDir()) {
+        File workingDirFile = createWorkingDirForMember(name);
+        locatorStarter.withWorkingDir(workingDirFile);
+      }
+      if (logFile) {
+        locatorStarter.withLogFile();
+      }
-    members[index] = new MemberVM(locator, locatorVM);
+    members[index] = new MemberVM(locator, locatorVM, useTempWorkingDir());
-
-  public MemberVM startServerAsJmxManager(int index) throws IOException {
+  /**
+   * Starts a cache server with given properties
+   */
+  public MemberVM startServerVM(int index, Properties specifiedProperties, int locatorPort)
+      throws IOException {
+    properties.putAll(specifiedProperties);
+
+    String defaultName = "server-" + index;
+    properties.putIfAbsent(NAME, defaultName);
+    String name = properties.getProperty(NAME);
+
+    VM serverVM = getVM(index);
+    Server server = serverVM.invoke(() -> {
+      serverStarter = new ServerStarterRule();
+      if (useTempWorkingDir()) {
+        File workingDirFile = createWorkingDirForMember(name);
+        serverStarter.withWorkingDir(workingDirFile);
+      }
+      if (logFile) {
+        serverStarter.withLogFile();
+      }
+      serverStarter.withProperties(properties).withConnectionToLocator(locatorPort).withAutoStart();
+      serverStarter.before();
+      return serverStarter;
+    });
+    members[index] = new MemberVM(server, serverVM, useTempWorkingDir());
+    return members[index];
+  }
+
+  public MemberVM startServerAsJmxManager(int index) throws IOException {
+    return startServerAsJmxManager(index, new Properties());
+  }
+
+  public MemberVM startServerAsJmxManager(int index, Properties properties) throws IOException {
+    return startServerAsEmbededLocator(index, new Properties());
+  }
+
+  public MemberVM startServerAsEmbededLocator(int index, Properties properties) throws IOException {
-    File workingDir = createWorkingDirForMember(name);
-    VM serverVM = getHost(0).getVM(index);
+
+    VM serverVM = getVM(index);
-      serverStarter = new ServerStarterRule(workingDir);
-      serverStarter.withEmbeddedLocator().withName(name).withJMXManager().withAutoStart();
+      serverStarter = new ServerStarterRule();
+      if (useTempWorkingDir()) {
+        File workingDirFile = createWorkingDirForMember(name);
+        serverStarter.withWorkingDir(workingDirFile);
+      }
+      if (logFile) {
+        serverStarter.withLogFile();
+      }
+      serverStarter.withEmbeddedLocator().withProperties(properties).withName(name).withJMXManager()
+          .withAutoStart();
-    members[index] = new MemberVM(server, serverVM);
+    members[index] = new MemberVM(server, serverVM, useTempWorkingDir());
-  public void stopMember(int index) {
+  public void stopVM(int index) {
-    member.stopMember();
+    // user has started a server/locator in this VM
+    if (member != null) {
+      member.stopMember();
+    }
+    // user may have used this VM as a client VM
+    else {
+      getVM(index).invoke(() -> MemberStarterRule.disconnectDSIfAny());
+    }
-   * Starts a cache server with given properties
-   */
-  public MemberVM startServerVM(int index, Properties properties, int locatorPort)
-      throws IOException {
-    String name = "server-" + index;
-    properties.setProperty(NAME, name);
-
-    File workingDir = createWorkingDirForMember(name);
-    VM serverVM = getHost(0).getVM(index);
-    Server server = serverVM.invoke(() -> {
-      serverStarter = new ServerStarterRule(workingDir);
-      serverStarter.withProperties(properties).withConnectionToLocator(locatorPort).withAutoStart();
-      serverStarter.before();
-      return serverStarter;
-    });
-    members[index] = new MemberVM(server, serverVM);
-    return members[index];
-  }
-
-
-  /**
-  public TemporaryFolder getTempFolder() {
-    return temporaryFolder;
+  public TemporaryFolder getTempWorkingDir() {
+    return tempWorkingDir;
+  }
+
+  public File getWorkingDirRoot() {
+    if (useTempWorkingDir())
+      return tempWorkingDir.getRoot();
+
+    // return the dunit folder
+    return new File(DUnitLauncher.DUNIT_DIR);
-    File workingDir = new File(temporaryFolder.getRoot(), dirName).getAbsoluteFile();
+    File workingDir = new File(tempWorkingDir.getRoot(), dirName).getAbsoluteFile();
-      temporaryFolder.newFolder(dirName);
+      tempWorkingDir.newFolder(dirName);

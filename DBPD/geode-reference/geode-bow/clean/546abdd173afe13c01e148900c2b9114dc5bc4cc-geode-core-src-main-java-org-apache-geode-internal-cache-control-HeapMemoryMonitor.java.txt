GEODE-6304: Refactor memory monitor to properly reset tolerance counter (#3102)

The tolerance counter was not properly being reset between
non-consecutive EVICTION and CRITICAL events.  To fix this and make it
more understandable, the threshold logic was combined with the logic to
compute the next state in the MemoryThreshold state machine.  The
counter is now reset between non-consecutive EVICTION and CRITICAL
events.

-  /*
-   * Number of eviction or critical state changes that have to occur before the event is delivered.
-   * This was introduced because we saw sudden memory usage spikes in jrockit VM.
-   */
-  private static final int memoryStateChangeTolerance;
-  static {
-    String vendor = System.getProperty("java.vendor");
-    if (vendor.contains("Sun") || vendor.contains("Oracle")) {
-      memoryStateChangeTolerance =
-          Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "memoryEventTolerance", 1);
-    } else {
-      memoryStateChangeTolerance =
-          Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "memoryEventTolerance", 5);
-    }
-  }
-
-  private Boolean started = false;
+  boolean started = false;
-  // Only change state when these counters exceed {@link
-  // HeapMemoryMonitor#memoryStateChangeTolerance}
-  private int criticalToleranceCounter;
-  private int evictionToleranceCounter;
-
+  public void setMemoryStateChangeTolerance(int memoryStateChangeTolerance) {
+    thresholds.setMemoryStateChangeTolerance(memoryStateChangeTolerance);
+  }
+
+  public int getMemoryStateChangeTolerance() {
+    return thresholds.getMemoryStateChangeTolerance();
+  }
+
-        testBytesUsedForThresholdSet != -1 ? testBytesUsedForThresholdSet : getBytesUsed());
+        testBytesUsedForThresholdSet != -1 ? testBytesUsedForThresholdSet : getBytesUsed(),
+        "notification");
-   * Public for testing.
-   *
+   * @param eventOrigin Indicates where the event originated e.g. notification vs polling
-  public void updateStateAndSendEvent(long bytesUsed) {
+  public void updateStateAndSendEvent(long bytesUsed, String eventOrigin) {
-        if (!skipEventDueToToleranceLimits(oldState, newState)) {
-          this.currentState = newState;
+        this.currentState = newState;
-          MemoryEvent event = new MemoryEvent(ResourceType.HEAP_MEMORY, oldState, newState,
-              this.cache.getMyId(), bytesUsed, true, this.thresholds);
+        MemoryEvent event = new MemoryEvent(ResourceType.HEAP_MEMORY, oldState, newState,
+            this.cache.getMyId(), bytesUsed, true, this.thresholds);
-          this.upcomingEvent.set(event);
-          processLocalEvent(event);
-          updateStatsFromEvent(event);
-        }
+        this.upcomingEvent.set(event);
+        processLocalEvent(event, eventOrigin);
+        updateStatsFromEvent(event);
-        processLocalEvent(event);
+        processLocalEvent(event, eventOrigin);
-   * To avoid memory spikes in jrockit, we only deliver events if we receive more than
-   * {@link HeapMemoryMonitor#memoryStateChangeTolerance} of the same state change.
-   *
-   * @return True if an event should be skipped, false otherwise.
-   */
-  private boolean skipEventDueToToleranceLimits(MemoryState oldState, MemoryState newState) {
-    if (testDisableMemoryUpdates) {
-      return false;
-    }
-
-    if (newState.isEviction() && !oldState.isEviction()) {
-      this.evictionToleranceCounter++;
-      this.criticalToleranceCounter = 0;
-      if (this.evictionToleranceCounter <= memoryStateChangeTolerance) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("State " + newState + " ignored. toleranceCounter:"
-              + this.evictionToleranceCounter + " MEMORY_EVENT_TOLERANCE:"
-              + memoryStateChangeTolerance);
-        }
-        return true;
-      }
-    } else if (newState.isCritical()) {
-      this.criticalToleranceCounter++;
-      this.evictionToleranceCounter = 0;
-      if (this.criticalToleranceCounter <= memoryStateChangeTolerance) {
-        if (logger.isDebugEnabled()) {
-          logger.debug("State " + newState + " ignored. toleranceCounter:"
-              + this.criticalToleranceCounter + " MEMORY_EVENT_TOLERANCE:"
-              + memoryStateChangeTolerance);
-        }
-        return true;
-      }
-    } else {
-      this.criticalToleranceCounter = 0;
-      this.evictionToleranceCounter = 0;
-      if (logger.isDebugEnabled()) {
-        logger.debug("TOLERANCE counters reset");
-      }
-    }
-    return false;
-  }
-
-  /**
+   * @param eventOrigin Indicates where the event originated e.g. notification vs polling
-  synchronized void processLocalEvent(MemoryEvent event) {
+  synchronized void processLocalEvent(MemoryEvent event, String eventOrigin) {
-          String.format("Member: %s above %s critical threshold",
-              new Object[] {event.getMember(), "heap"}));
+          String.format("Member: %s above %s critical threshold. Event generated via %s.",
+              event.getMember(), "heap", eventOrigin));
-          String.format("Member: %s below %s critical threshold",
-              new Object[] {event.getMember(), "heap"}));
+          String.format("Member: %s below %s critical threshold. Event generated via %s.",
+              event.getMember(), "heap", eventOrigin));
-          new Object[] {event.getMember(), "heap"}));
+          event.getMember(), "heap"));
-          new Object[] {event.getMember(), "heap"}));
+          event.getMember(), "heap"));
-              updateStateAndSendEvent(usedBytes);
+              updateStateAndSendEvent(usedBytes, "polling");
-        + this.mostRecentEvent + ", criticalToleranceCounter=" + this.criticalToleranceCounter
-        + ", evictionToleranceCounter=" + this.evictionToleranceCounter + "]";
+        + this.mostRecentEvent + "]";
-        updateStateAndSendEvent(getBytesUsed());
+        updateStateAndSendEvent(getBytesUsed(), "polling");

GEODE-4439 Refactor HandShake.java

Created ServerSideHandshake and ServerSideHandshakeImpl for servers.

Created ClientSideHandshake and ClientSideHandshakeImpl for clients.

Message encryption/decryption is now in an Encryptor interface.

HandShake is renamed Handshake.

-import org.apache.geode.internal.cache.tier.ClientHandShake;
+import org.apache.geode.internal.cache.tier.ServerSideHandshake;
-  protected ClientHandShake handshake;
-  private int handShakeTimeout;
-  private final Object handShakeMonitor = new Object();
+  protected ServerSideHandshake handshake;
+  private int handshakeTimeout;
+  private final Object handshakeMonitor = new Object();
-      this.handShakeTimeout = hsTimeout;
+      this.handshakeTimeout = hsTimeout;
-    synchronized (this.handShakeMonitor) {
+    synchronized (this.handshakeMonitor) {
-        boolean readHandShake =
-            ServerHandShakeProcessor.readHandShake(this, getSecurityService(), acceptor);
-        if (readHandShake) {
+        boolean readHandshake =
+            ServerHandshakeProcessor.readHandshake(this, getSecurityService(), acceptor);
+        if (readHandshake) {
+          // readHandshake will establish a handshake object in this ServerConnection
+            // is this branch ever taken?
-            logger.warn(LocalizedMessage.create(
-                LocalizedStrings.ServerConnection_0_RECEIVED_UNKNOWN_HANDSHAKE_REPLY_CODE_1,
-                new Object[] {this.name, new Byte(this.handshake.getCode())}));
+            logger.warn(LocalizedMessage
+                .create(LocalizedStrings.ServerConnection_RECEIVED_UNKNOWN_HANDSHAKE_REPLY_CODE));
-                .toLocalizedString(), ServerHandShakeProcessor.REPLY_INVALID);
+                .toLocalizedString(), ServerHandshakeProcessor.REPLY_INVALID);
-        // }
-    return this.handShakeTimeout;
+    return this.handshakeTimeout;
-  public ClientHandShake getHandshake() {
+  public ServerSideHandshake getHandshake() {
-  public void setHandshake(ClientHandShake handshake) {
+  public void setHandshake(ServerSideHandshake handshake) {
-        byte epType = (byte) 0;
-        int qSize = 0;
+        byte endpointType = (byte) 0;
+        int queueSize = 0;
-              epType = (byte) 2;
-              qSize = proxy.getQueueSize();
+              endpointType = (byte) 2;
+              queueSize = proxy.getQueueSize();
-              epType = (byte) 1;
-              qSize = proxy.getQueueSize();
+              endpointType = (byte) 1;
+              queueSize = proxy.getQueueSize();
-                  HandShake.REPLY_EXCEPTION_DUPLICATE_DURABLE_CLIENT);
+                  Handshake.REPLY_EXCEPTION_DUPLICATE_DURABLE_CLIENT);
-          if (acceptHandShake(epType, qSize)) {
+          if (acceptHandShake(endpointType, queueSize)) {
-          if (acceptHandShake(epType, qSize)) {
+          if (acceptHandShake(endpointType, queueSize)) {
-      ServerHandShakeProcessor.refuse(this.theSocket.getOutputStream(), msg, exception);
+      ServerHandshakeProcessor.refuse(this.theSocket.getOutputStream(), msg, exception);
-  protected boolean acceptHandShake(byte epType, int qSize) {
-    return doHandShake(epType, qSize) && handshakeAccepted();
+  protected boolean acceptHandShake(byte endpiontType, int queueSize) {
+    return doHandShake(endpiontType, queueSize) && handshakeAccepted();
-        secureBytes = ((HandShake) this.handshake).decryptBytes(secureBytes);
+        secureBytes = this.handshake.getEncryptor().decryptBytes(secureBytes);
-      secureBytes = ((HandShake) this.handshake).decryptBytes(secureBytes);
+      secureBytes = this.handshake.getEncryptor().decryptBytes(secureBytes);
-      secureBytes = ((HandShake) this.handshake).decryptBytes(secureBytes);
+      secureBytes = this.handshake.getEncryptor().decryptBytes(secureBytes);
-      credBytes = ((HandShake) this.handshake).decryptBytes(credBytes);
+      credBytes = this.handshake.getEncryptor().decryptBytes(credBytes);
-      Object principal = HandShake.verifyCredentials(methodName, credentials,
+      Object principal = Handshake.verifyCredentials(methodName, credentials,
-        uniqueId = ServerHandShakeProcessor.getUniqueId(this, (Principal) principal);
+        uniqueId = ServerHandshakeProcessor.getUniqueId(this, (Principal) principal);
-      return ((HandShake) this.handshake).encryptBytes(hdos.toByteArray());
+      return this.handshake.getEncryptor().encryptBytes(hdos.toByteArray());
-          (HandShake) this.handshake, this.connectionId);
+          this.handshake.getEncryptor(), this.connectionId);

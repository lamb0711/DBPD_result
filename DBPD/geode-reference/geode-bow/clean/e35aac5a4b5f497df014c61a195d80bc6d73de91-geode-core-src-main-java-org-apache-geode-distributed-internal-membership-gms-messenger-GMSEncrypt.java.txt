Merge branch 'release/1.5.0'

-import java.security.*;
+import java.security.KeyFactory;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.PrivateKey;
+import java.security.PublicKey;
-import java.util.Iterator;
-import java.util.List;
+import java.util.Arrays;
-import org.apache.geode.GemFireConfigException;
-public class GMSEncrypt implements Cloneable {
-
-  public static long encodingsPerformed;
-  public static long decodingsPerformed;
-
+public final class GMSEncrypt implements Cloneable {
-  public static final int numberOfPeerEncryptorCopies =
-      Integer.getInteger("GMSEncrypt.MAX_ENCRYPTORS",
-          Math.max(Runtime.getRuntime().availableProcessors() * 4, 16)).intValue();
+  private static final int numberOfPeerEncryptorCopies = Integer.getInteger(
+      "GMSEncrypt.MAX_ENCRYPTORS", Math.max(Runtime.getRuntime().availableProcessors() * 4, 16));
-  protected GMSEncrypt() {
+  private GMSEncrypt() {
-  public GMSEncrypt(Services services) throws Exception {
+  GMSEncrypt(Services services) throws Exception {
-  public GMSEncrypt(Services services, InternalDistributedMember mbr) throws Exception {
+  GMSEncrypt(Services services, InternalDistributedMember mbr) throws Exception {
-  void initEncryptors() {
+  private void initEncryptors() {
-      // createPeerEncryptor(mbr, publickey);
-  protected GMSEncrypt clone() throws CloneNotSupportedException {
+  protected GMSEncrypt clone() {
-      // PublicKey pubKey = keyFact.generatePublic(x509KeySpec);
-  protected PeerEncryptor getPeerEncryptor(InternalDistributedMember member) throws Exception {
+  private PeerEncryptor getPeerEncryptor(InternalDistributedMember member) throws Exception {
-          byte[] pk =
-              (byte[]) memberToPeerEncryptor.get(new InternalDistributedMemberWrapper(member));
+          byte[] pk = memberToPeerEncryptor.get(new InternalDistributedMemberWrapper(member));
-          m = new ConcurrentHashMap<InternalDistributedMember, PeerEncryptor>();
+          m = new ConcurrentHashMap<>();
-  public static byte[] encryptBytes(byte[] data, Cipher encrypt) throws Exception {
+  private static byte[] encryptBytes(byte[] data, Cipher encrypt) throws Exception {
-  public static byte[] decryptBytes(byte[] data, Cipher decrypt) throws Exception {
-    try {
-      byte[] decryptBytes = decrypt.doFinal(data);
-      return decryptBytes;
-    } catch (Exception ex) {
-      throw ex;
-    }
+  private static byte[] decryptBytes(byte[] data, Cipher decrypt) throws Exception {
+    return decrypt.doFinal(data);
+  private class PeerEncryptor {
-  protected class PeerEncryptor {
-
-    private PublicKey peerPublicKey = null;
+    private PublicKey peerPublicKey;
-    protected PeerEncryptor(byte[] peerPublicKeyBytes) throws Exception {
+    private PeerEncryptor(byte[] peerPublicKeyBytes) throws Exception {
-    public synchronized byte[] encryptBytes(byte[] data) throws Exception {
-      String algo = null;
+    private synchronized byte[] encryptBytes(byte[] data) throws Exception {
+      String algo;
-      try {
-        if (encrypt == null) {
-          encrypt = GMSEncrypt.getEncryptCipher(dhSKAlgo, dhPrivateKey, this.peerPublicKey);
-        }
-      } catch (Exception ex) {
-        throw ex;
+      if (encrypt == null) {
+        encrypt = GMSEncrypt.getEncryptCipher(dhSKAlgo, dhPrivateKey, this.peerPublicKey);
-  protected static synchronized Cipher getEncryptCipher(String dhSKAlgo, PrivateKey privateKey,
+  private static synchronized Cipher getEncryptCipher(String dhSKAlgo, PrivateKey privateKey,
-  protected static Cipher getEncryptCipher(String dhSKAlgo, byte[] secretBytes) throws Exception {
+  private static Cipher getEncryptCipher(String dhSKAlgo, byte[] secretBytes) throws Exception {
-  protected static synchronized Cipher getDecryptCipher(String dhSKAlgo, PrivateKey privateKey,
+  private static synchronized Cipher getDecryptCipher(String dhSKAlgo, PrivateKey privateKey,
-  protected static Cipher getDecryptCipher(String dhSKAlgo, byte[] secretBytes) throws Exception {
-    Cipher decrypt = null;
+  private static Cipher getDecryptCipher(String dhSKAlgo, byte[] secretBytes) throws Exception {
+    Cipher decrypt;
-  protected static byte[] generateSecret(String dhSKAlgo, PrivateKey privateKey,
+  private static byte[] generateSecret(String dhSKAlgo, PrivateKey privateKey,
-  protected static PublicKey getPublicKey(byte[] publicKeyBytes) throws Exception {
+  private static PublicKey getPublicKey(byte[] publicKeyBytes) throws Exception {
-    // PublicKey pubKey = keyFact.generatePublic(x509KeySpec);
-  protected static void initEncryptCipher(KeyAgreement ka, List<PublicKey> publicKeys)
-      throws Exception {
-    Iterator<PublicKey> itr = publicKeys.iterator();
-    while (itr.hasNext()) {
-      ka.doPhase(itr.next(), !itr.hasNext());
-    }
-  }
-
-  protected class ClusterEncryptor {
+  private class ClusterEncryptor {
-    public ClusterEncryptor(GMSEncrypt other) throws Exception {
+    private ClusterEncryptor(GMSEncrypt other) throws Exception {
-    public ClusterEncryptor(byte[] sb) {
+    private ClusterEncryptor(byte[] sb) {
-    public synchronized byte[] encryptBytes(byte[] data) throws Exception {
+    private synchronized byte[] encryptBytes(byte[] data) throws Exception {
-    public synchronized byte[] decryptBytes(byte[] data) throws Exception {
+    private synchronized byte[] decryptBytes(byte[] data) throws Exception {

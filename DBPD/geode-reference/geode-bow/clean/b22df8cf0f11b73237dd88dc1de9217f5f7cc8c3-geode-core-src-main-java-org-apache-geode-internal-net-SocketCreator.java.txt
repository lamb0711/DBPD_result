GEODE-8144: endpoint identification in servers is not working (#5131)

* GEODE-8144: endpoint identification in servers is not working

Set the SNI server-name field in SSL parameters for p2p communications,
allowing endpoint identification to work properly.

I modified one of the SNI haproxy tests to have keystores with the
proper subject-alternative-names for p2p communications in the docker
containers and for client/server off-platform communications.  I used
Sai's keystore/truststore construction CertificateMaterial/CertStores
classes to generate the stores...

      .sanDnsName("geode") // for inside the docker container
      .sanDnsName("localhost") // for inside the docker container
      .sanIpAddress(InetAddress.getByName("0.0.0.0")) // for inside the docker container
      .sanDnsName(certName) // for client endpoint validation (locator-maeve for instance)

* modified SocketCreator to look for a hostname if one is not present and endpoint verification is enabled

This fixes some problems when running in docker containers

* removed test shell script

* sanction used of getCanonicalHostName() in SocketCreator
+import org.apache.commons.validator.routines.InetAddressValidator;
-    return getSslContext().createSSLEngine(hostName, port);
+    SSLEngine engine = getSslContext().createSSLEngine(hostName, port);
+    SSLParameters parameters = engine.getSSLParameters();
+    // set server-names so that endpoint identification algorithms can find what's expected
+    if (setServerNames(parameters, new HostAndPort(hostName, port))) {
+      engine.setSSLParameters(parameters);
+    }
+    return engine;
-   * When a socket is accepted from a server socket, it should be passed to this method for SSL
+   * When a socket is connected to a server socket, it should be passed to this method for SSL
-  private void setServerNames(SSLParameters modifiedParams, HostAndPort addr) {
+  /**
+   * returns true if the SSLParameters are altered, false if not
+   */
+  private boolean setServerNames(SSLParameters modifiedParams, HostAndPort addr) {
-      return;
+      return false;
-    serverNames.add(new SNIHostName(addr.getHostName()));
+    String hostName = addr.getHostName();
+    if (this.sslConfig.doEndpointIdentification()
+        && InetAddressValidator.getInstance().isValid(hostName)) {
+      // endpoint validation typically uses a hostname in the sniServer parameter that the handshake
+      // will compare against the subject alternative addresses in the server's certificate. Here
+      // we attempt to get a hostname instead of the proffered numeric address
+      try {
+        hostName = InetAddress.getByName(hostName).getCanonicalHostName();
+      } catch (UnknownHostException e) {
+        // ignore - we'll see what happens with endpoint validation using a numeric address...
+      }
+    }
+    serverNames.add(new SNIHostName(hostName));
+    return true;

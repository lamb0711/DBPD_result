Merge branch 'release/1.5.0'

-package org.apache.geode.internal.cache;
-
-import static org.apache.geode.internal.cache.DistributedCacheOperation.VALUE_IS_BYTES;
-import static org.apache.geode.internal.cache.DistributedCacheOperation.VALUE_IS_SERIALIZED_OBJECT;
+package org.apache.geode.internal.cache.tx;
-import java.util.Iterator;
+import org.apache.geode.cache.RegionDestroyedException;
-import org.apache.geode.distributed.internal.DM;
+import org.apache.geode.distributed.internal.ClusterDistributionManager;
+import org.apache.geode.internal.cache.DistributedRegion;
+import org.apache.geode.internal.cache.EntryEventImpl;
+import org.apache.geode.internal.cache.LocalRegion;
+import org.apache.geode.internal.cache.RemoteOperationException;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+/**
+ * This message is used by transactions to invalidate an entry on a transaction hosted on a remote
+ * member. It is also used by non-transactional region invalidates that need to generate a
+ * VersionTag on a remote member.
+ */
-  private RemoteInvalidateMessage(Set recipients, String regionPath, DirectReplyProcessor processor,
-      EntryEventImpl event, boolean useOriginRemote, boolean possibleDuplicate) {
-    super(recipients, regionPath, processor, event, null,
-        DistributionManager.PARTITIONED_REGION_EXECUTOR, useOriginRemote, possibleDuplicate);
+  private RemoteInvalidateMessage(DistributedMember recipient, String regionPath,
+      DirectReplyProcessor processor, EntryEventImpl event, boolean useOriginRemote,
+      boolean possibleDuplicate) {
+    super(recipient, regionPath, processor, event, null, useOriginRemote, possibleDuplicate);
+  @SuppressWarnings("unchecked")
-    Collection replicates = onlyPersistent
+    Collection<InternalDistributedMember> replicates = onlyPersistent
-      ArrayList l = new ArrayList(replicates);
+      ArrayList<InternalDistributedMember> l = new ArrayList<>(replicates);
-    for (Iterator<InternalDistributedMember> it = replicates.iterator(); it.hasNext();) {
-      InternalDistributedMember replicate = it.next();
+    for (InternalDistributedMember replicate : replicates) {
-        InvalidateResponse processor = send(replicate, event.getRegion(), event,
-            DistributionManager.SERIAL_EXECUTOR, false, posDup);
-        processor.waitForCacheException();
-        VersionTag versionTag = processor.getVersionTag();
+        InvalidateResponse processor = send(replicate, event.getRegion(), event, false, posDup);
+        processor.waitForRemoteResponse();
+        VersionTag<?> versionTag = processor.getVersionTag();
-          logger.debug("RemoteDestroyMessage caught CacheException during distribution", e);
+          logger.debug("RemoteInvalidateMessage caught CacheException during distribution", e);
-      } catch (RemoteOperationException e) {
+      } catch (RegionDestroyedException | RemoteOperationException e) {
-              "RemoteDestroyMessage caught an unexpected exception during distribution", e);
+              "RemoteInvalidateMessage caught an exception during distribution; retrying to another member",
+              e);
-   * @param processorType the type of executor to use
-      EntryEventImpl event, int processorType, boolean useOriginRemote, boolean possibleDuplicate)
+      EntryEventImpl event, boolean useOriginRemote, boolean possibleDuplicate)
-    // Assert.assertTrue(recipient != null, "RemoteInvalidateMessage NULL recipient"); recipient may
-    // be null for remote notifications
-    Set recipients = Collections.singleton(recipient);
-    InvalidateResponse p = new InvalidateResponse(r.getSystem(), recipients, event.getKey());
-    RemoteInvalidateMessage m = new RemoteInvalidateMessage(recipients, r.getFullPath(), p, event,
+    InvalidateResponse p = new InvalidateResponse(r.getSystem(), recipient, event.getKey());
+    RemoteInvalidateMessage m = new RemoteInvalidateMessage(recipient, r.getFullPath(), p, event,
-    m.setTransactionDistributed(r.getCache().getTxManager().isDistributed());
-    Set failures = r.getDistributionManager().putOutgoing(m);
+    Set<?> failures = r.getDistributionManager().putOutgoing(m);
-   * This method is called upon receipt and make the desired changes to the PartitionedRegion Note:
-   * It is very important that this message does NOT cause any deadlocks as the sender will wait
-   * indefinitely for the acknowledgement
-   *
-   * @throws EntryExistsException
+   * This method is called upon receipt and make the desired changes to the region. Note: It is very
+   * important that this message does NOT cause any deadlocks as the sender will wait indefinitely
+   * for the acknowledgement
-  protected boolean operateOnRegion(DistributionManager dm, LocalRegion r, long startTime)
+  protected boolean operateOnRegion(ClusterDistributionManager dm, LocalRegion r, long startTime)
-      } catch (PrimaryBucketException pbe) {
-        sendReply(getSender(), getProcessorId(), dm, new ReplyException(pbe), r, startTime);
-        return false;
-
-  // override reply processor type from PartitionMessage
-  RemoteOperationResponse createReplyProcessor(PartitionedRegion r, Set recipients, Object key) {
-    return new InvalidateResponse(r.getSystem(), recipients, key);
-  }
-
-  // override reply message type from PartitionMessage
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
-      LocalRegion r, long startTime) {
+  protected void sendReply(InternalDistributedMember member, int procId, DistributionManager dm,
+      ReplyException ex, LocalRegion r, long startTime) {
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
-      LocalRegion r, VersionTag versionTag, long startTime) {
-    /*
-     * if (pr != null && startTime > 0) { pr.getPrStats().endPartitionMessagesProcessing(startTime);
-     * }
-     */
+  protected void sendReply(InternalDistributedMember member, int procId, DistributionManager dm,
+      ReplyException ex, LocalRegion r, VersionTag<?> versionTag, long startTime) {
-    private VersionTag versionTag;
+    private VersionTag<?> versionTag;
-    private InvalidateReplyMessage(int processorId, VersionTag versionTag, ReplyException ex) {
+    private InvalidateReplyMessage(int processorId, VersionTag<?> versionTag, ReplyException ex) {
-        ReplySender replySender, VersionTag versionTag, ReplyException ex) {
+        ReplySender replySender, VersionTag<?> versionTag, ReplyException ex) {
-    public void process(final DM dm, final ReplyProcessor21 rp) {
+    public void process(final DistributionManager dm, final ReplyProcessor21 rp) {
-    VersionTag versionTag;
+    VersionTag<?> versionTag;
-    public InvalidateResponse(InternalDistributedSystem ds, Set recipients, Object key) {
-      super(ds, recipients, true);
+    public InvalidateResponse(InternalDistributedSystem ds, DistributedMember recipient,
+        Object key) {
+      super(ds, (InternalDistributedMember) recipient, true);
-    public void setResponse(VersionTag versionTag) {
+    public void setResponse(VersionTag<?> versionTag) {
-      try {
-        waitForCacheException();
-      } catch (RemoteOperationException e) {
-        e.checkKey(key);
-        throw e;
-      }
+      waitForRemoteResponse();
-    public VersionTag getVersionTag() {
+    public VersionTag<?> getVersionTag() {
-
-
-

 GEODE-6580: Cleanup static analyzer warnings. (#3415)


+
-import java.util.Iterator;
-  public static final RawValue NULLVALUE = new RawValue(null);
+  private static final RawValue NULLVALUE = new RawValue(null);
-      this.rawValue = rawVal;
+      rawValue = rawVal;
-      return this.rawValue instanceof byte[];
+      return rawValue instanceof byte[];
-      return this.rawValue;
+      return rawValue;
-        DataSerializer.writeByteArray((byte[]) this.rawValue, out);
-      } else if (this.rawValue instanceof CachedDeserializable) {
-        ((CachedDeserializable) this.rawValue).writeValueAsByteArray(out);
-      } else if (Token.isInvalid(this.rawValue)) {
+        DataSerializer.writeByteArray((byte[]) rawValue, out);
+      } else if (rawValue instanceof CachedDeserializable) {
+        ((CachedDeserializable) rawValue).writeValueAsByteArray(out);
+      } else if (Token.isInvalid(rawValue)) {
-      } else if (this.rawValue == Token.TOMBSTONE) {
+      } else if (rawValue == Token.TOMBSTONE) {
-        DataSerializer.writeObjectAsByteArray(this.rawValue, out);
+        DataSerializer.writeObjectAsByteArray(rawValue, out);
-      return "RawValue(" + this.rawValue + ")";
+      return "RawValue(" + rawValue + ")";
-          byte[] src = (byte[]) this.rawValue;
+          byte[] src = (byte[]) rawValue;
-          System.arraycopy(this.rawValue, 0, dest, 0, dest.length);
+          System.arraycopy(rawValue, 0, dest, 0, dest.length);
-          return this.rawValue;
+          return rawValue;
-      } else if (this.rawValue instanceof CachedDeserializable) {
+      } else if (rawValue instanceof CachedDeserializable) {
-          return ((CachedDeserializable) this.rawValue).getDeserializedWritableCopy(null, null);
+          return ((CachedDeserializable) rawValue).getDeserializedWritableCopy(null, null);
-          return ((CachedDeserializable) this.rawValue).getDeserializedForReading();
+          return ((CachedDeserializable) rawValue).getDeserializedForReading();
-      } else if (Token.isInvalid(this.rawValue)) {
+      } else if (Token.isInvalid(rawValue)) {
-          return CopyHelper.copy(this.rawValue);
+          return CopyHelper.copy(rawValue);
-          return this.rawValue;
+          return rawValue;
-  private static final long serialVersionUID = 1L;
-
-  private final Map<Object, ExpiryTask> pendingSecondaryExpires = new HashMap<Object, ExpiryTask>();
+  private final Map<Object, ExpiryTask> pendingSecondaryExpires = new HashMap<>();
-  public HashMap allKeysMap = new HashMap();
+  private final HashMap<Object, LockObject> allKeysMap = new HashMap<>();
-  public AtomicLong5 getEventSeqNum() {
+  AtomicLong5 getEventSeqNum() {
-    this.redundancy = internalRegionArgs.getPartitionedRegionBucketRedundancy();
-    this.partitionedRegion = internalRegionArgs.getPartitionedRegion();
+    redundancy = internalRegionArgs.getPartitionedRegionBucketRedundancy();
+    partitionedRegion = internalRegionArgs.getPartitionedRegion();
-    if (this.partitionedRegion.isShadowPR() && this.partitionedRegion.getColocatedWith() != null) {
-      PartitionedRegion parentPR = ColocationHelper.getLeaderRegion(this.partitionedRegion);
+    if (partitionedRegion.isShadowPR() && partitionedRegion.getColocatedWith() != null) {
+      PartitionedRegion parentPR = ColocationHelper.getLeaderRegion(partitionedRegion);
-    if (this.partitionedRegion.getColocatedWith() == null) {
-      this.eventSeqNum = new AtomicLong5(getId());
+    if (partitionedRegion.getColocatedWith() == null) {
+      eventSeqNum = new AtomicLong5(getId());
-      PartitionedRegion parentPR = ColocationHelper.getLeaderRegion(this.partitionedRegion);
+      PartitionedRegion parentPR = ColocationHelper.getLeaderRegion(partitionedRegion);
-            this.partitionedRegion.getFullPath(), getId());
+            partitionedRegion.getFullPath(), getId());
-      this.eventSeqNum = parentBucket.eventSeqNum;
+      eventSeqNum = parentBucket.eventSeqNum;
-    this.createRegionReplyProcessor = processor;
+    createRegionReplyProcessor = processor;
-    if (this.createRegionReplyProcessor != null) {
+    if (createRegionReplyProcessor != null) {
-          this.createRegionReplyProcessor.getEventState(provider);
+          createRegionReplyProcessor.getEventState(provider);
-      this.createRegionReplyProcessor = null;
+      createRegionReplyProcessor = null;
-    if (getFilterProfile() != null) {
-      return true;
-    }
-    return false;
+    return getFilterProfile() != null;
-  LockObject searchAndLock(Object keys[]) {
+  LockObject searchAndLock(Object[] keys) {
-      for (int i = 0; i < keys.length; i++) {
-        if (allKeysMap.containsKey(keys[i])) {
-          foundLock = (LockObject) allKeysMap.get(keys[i]);
+      for (Object key : keys) {
+        if (allKeysMap.containsKey(key)) {
+          foundLock = allKeysMap.get(key);
-            logger.debug("LockKeys: found key: {}:{}", keys[i], foundLock.lockedTimeStamp);
+            logger.debug("LockKeys: found key: {}:{}", key, foundLock.lockedTimeStamp);
-        for (int i = 0; i < keys.length; i++) {
+        for (Object key : keys) {
-              new LockObject(keys[i], isDebugEnabled ? System.currentTimeMillis() : 0);
-          allKeysMap.put(keys[i], lockValue);
+              new LockObject(key, isDebugEnabled ? System.currentTimeMillis() : 0);
+          allKeysMap.put(key, lockValue);
-            logger.debug("LockKeys: add key: {}:{}", keys[i], lockValue.lockedTimeStamp);
+            logger.debug("LockKeys: add key: {}:{}", key, lockValue.lockedTimeStamp);
-  public void removeAndNotifyKeys(Object keys[]) {
+  public void removeAndNotifyKeys(Object[] keys) {
-      for (int i = 0; i < keys.length; i++) {
-        LockObject lockValue = (LockObject) allKeysMap.remove(keys[i]);
+      for (Object key : keys) {
+        LockObject lockValue = allKeysMap.remove(key);
-              logger.trace("LockKeys: remove key {}, notifyAll for {}. It waited {}", keys[i],
+              logger.trace("LockKeys: remove key {}, notifyAll for {}. It waited {}", key,
-  public boolean waitUntilLocked(Object keys[]) {
+  public boolean waitUntilLocked(Object[] keys) {
-      if (this.partitionedRegion.isParallelWanEnabled()) {
+      if (partitionedRegion.isParallelWanEnabled()) {
-        RegionEntry oldEntry = this.entries.basicPut(event, lastModified, ifNew, ifOld,
+        RegionEntry oldEntry = entries.basicPut(event, lastModified, ifNew, ifOld,
-  public long generateTailKey() {
-    long key = this.eventSeqNum.addAndGet(this.partitionedRegion.getTotalNumberOfBuckets());
+  long generateTailKey() {
+    long key = eventSeqNum.addAndGet(partitionedRegion.getTotalNumberOfBuckets());
-          this.eventSeqNum.get());
+          eventSeqNum.get());
-    if (this.eventSeqNum == null) {
+    if (eventSeqNum == null) {
-        long key = this.eventSeqNum.addAndGet(this.partitionedRegion.getTotalNumberOfBuckets());
+        long key = eventSeqNum.addAndGet(partitionedRegion.getTotalNumberOfBuckets());
-              this.eventSeqNum.get());
+              eventSeqNum.get());
-        Atomics.setIfGreater(this.eventSeqNum, event.getTailKey());
+        Atomics.setIfGreater(eventSeqNum, event.getTailKey());
-  public void updateEventSeqNum(long l) {
-    Atomics.setIfGreater(this.eventSeqNum, l);
+  void updateEventSeqNum(long l) {
+    Atomics.setIfGreater(eventSeqNum, l);
-          event.getPutAllOperation().addEntry(event, this.getId());
+          event.getPutAllOperation().addEntry(event, getId());
-            logger.debug("sent update operation : for region  : {}: with event: {}", this.getName(),
+            logger.debug("sent update operation : for region  : {}: with event: {}", getName(),
-      if (this.partitionedRegion.getDataStore().hasClientInterest(event)) {
+      if (partitionedRegion.getDataStore().hasClientInterest(event)) {
-              logger.debug("generated version tag {} in region {}", v, this.getName());
+              logger.debug("generated version tag {} in region {}", v, getName());
-          long start = this.partitionedRegion.getPrStats().startSendReplication();
+          long start = partitionedRegion.getPrStats().startSendReplication();
-            this.partitionedRegion.getPrStats().endSendReplication(start);
+            partitionedRegion.getPrStats().endSendReplication(start);
-      long lastModifiedTime =
-          super.basicPutPart2(event, entry, isInitialized, lastModified, clearConflict);
-      return lastModifiedTime;
+      return super.basicPutPart2(event, entry, isInitialized, lastModified, clearConflict);
-      event.setRegion(this.partitionedRegion);
-      this.partitionedRegion.notifyGatewaySender(operation, event);
+      event.setRegion(partitionedRegion);
+      partitionedRegion.notifyGatewaySender(operation, event);
-      this.partitionedRegion.checkReadiness();
+      partitionedRegion.checkReadiness();
-    Object keys[] = new Object[1];
+    Object[] keys = new Object[1];
-            this.entries.invalidate(event, invokeCallbacks, forceNewEntry, forceCallbacks);
+            entries.invalidate(event, invokeCallbacks, forceNewEntry, forceCallbacks);
-        return;
-        return;
-            logger.debug("generated version tag {} in region {}", v, this.getName());
+            logger.debug("generated version tag {} in region {}", v, getName());
-    event.region = this.partitionedRegion;
+    event.region = partitionedRegion;
-    return this.getConcurrencyChecksEnabled()
+    return getConcurrencyChecksEnabled()
-      return;
-    } catch (PrimaryBucketException e) {
+    } catch (PrimaryBucketException ignored) {
-      return;
-    ExpiryTask task = expiryTask;
-        synchronized (this.pendingSecondaryExpires) {
-          if (task.isPending()) {
-            Object key = task.getKey();
+        synchronized (pendingSecondaryExpires) {
+          if (expiryTask.isPending()) {
+            Object key = expiryTask.getKey();
-              this.pendingSecondaryExpires.put(key, task);
+              pendingSecondaryExpires.put(key, expiryTask);
-        super.performExpiryTimeout(task);
+        super.performExpiryTimeout(expiryTask);
-  protected boolean isEntryEvictDestroyEnabled() {
+  private boolean isEntryEvictDestroyEnabled() {
-  protected void processPendingSecondaryExpires() {
+  void processPendingSecondaryExpires() {
-      synchronized (this.pendingSecondaryExpires) {
-        if (this.pendingSecondaryExpires.isEmpty()) {
+      synchronized (pendingSecondaryExpires) {
+        if (pendingSecondaryExpires.isEmpty()) {
-        tasks = new ExpiryTask[this.pendingSecondaryExpires.size()];
-        tasks = this.pendingSecondaryExpires.values().toArray(tasks);
-        this.pendingSecondaryExpires.clear();
+        tasks = new ExpiryTask[pendingSecondaryExpires.size()];
+        tasks = pendingSecondaryExpires.values().toArray(tasks);
+        pendingSecondaryExpires.clear();
-        if (isCacheClosing() || isClosed() || this.isDestroyed) {
+        if (isCacheClosing() || isClosed() || isDestroyed) {
-        for (int i = 0; i < tasks.length; i++) {
+        for (ExpiryTask task : tasks) {
-              logger.debug("{} fired at {}", tasks[i], System.currentTimeMillis());
+              logger.debug("{} fired at {}", task, System.currentTimeMillis());
-            tasks[i].basicPerformTimeout(true);
+            task.basicPerformTimeout(true);
-      } catch (RegionDestroyedException re) {
+      } catch (RegionDestroyedException ignored) {
-      } catch (CancelException ex) {
+      } catch (CancelException ignored) {
-      if (this.partitionedRegion.isParallelWanEnabled()) {
+      if (partitionedRegion.isParallelWanEnabled()) {
-        return;
-        return;
-          event.getRemoveAllOperation().addEntry(event, this.getId());
+          event.getRemoveAllOperation().addEntry(event, getId());
-            logger.debug("generated version tag {} in region {}", v, this.getName());
+            logger.debug("generated version tag {} in region {}", v, getName());
-          this.entries.updateEntryVersion(event);
+          entries.updateEntryVersion(event);
-        return;
-    return this.redundancy;
+    return redundancy;
-        String.format("This should never be called on %s",
-            getClass()));
+        String.format("This should never be called on %s", getClass()));
-    return isBucketDestroyed() || (this.partitionedRegion != null
-        && this.partitionedRegion.isLocallyDestroyed && !isInDestroyingThread());
+    return isBucketDestroyed() || (partitionedRegion != null
+        && partitionedRegion.isLocallyDestroyed && !isInDestroyingThread());
-    return this.partitionedRegion;
+    return partitionedRegion;
-    return this.partitionedRegion.locallyDestroyingThread == Thread.currentThread();
+    return partitionedRegion.locallyDestroyingThread == Thread.currentThread();
-    bp.isInitializing = this.getInitializationLatchAfterGetInitialImage().getCount() > 0;
+    bp.isInitializing = getInitializationLatchAfterGetInitialImage().getCount() > 0;
-  public boolean isPartitionedRegionOpen() {
-    return !this.partitionedRegion.isLocallyDestroyed && !this.partitionedRegion.isClosed
-        && !this.partitionedRegion.isDestroyed();
+  boolean isPartitionedRegionOpen() {
+    return !partitionedRegion.isLocallyDestroyed && !partitionedRegion.isClosed
+        && !partitionedRegion.isDestroyed();
-   * @throws IOException if there is a serialization problem see
-   *         LocalRegion#getDeserializedValue(RegionEntry, KeyInfo, boolean, boolean, boolean,
-   *         EntryEventImpl, boolean, boolean, boolean)
-      throws EntryNotFoundException, IOException {
-    RegionEntry re = null;
-    re = this.entries.getEntry(key);
+      throws EntryNotFoundException {
+    RegionEntry re;
+    re = entries.getEntry(key);
-    Object v = null;
+    Object v;
-      this.handleDiskAccessException(dae);
+      handleDiskAccessException(dae);
-      RawValue valueBytes = NULLVALUE;
-      boolean isCreate = false;
+      boolean isCreate;
-    return new StringBuilder().append("BucketRegion").append("[path='").append(getFullPath())
-        .append(";serial=").append(getSerialNumber()).append(";primary=")
-        .append(getBucketAdvisor().getProxyBucketRegion().isPrimary()).append("]").toString();
+    return "BucketRegion" + "[path='" + getFullPath()
+        + ";serial=" + getSerialNumber() + ";primary="
+        + getBucketAdvisor().getProxyBucketRegion().isPrimary() + "]";
-    this.distAdvisor.removeMembershipListener(this.advisorListener);
+    distAdvisor.removeMembershipListener(advisorListener);
-  public void removeFromPeersAdvisors(boolean rebalance) {
+  void removeFromPeersAdvisors(boolean rebalance) {
-  EntryEventImpl createEventForPR(EntryEventImpl sourceEvent) {
+  private EntryEventImpl createEventForPR(EntryEventImpl sourceEvent) {
-      e2.setRegion(this.partitionedRegion);
+      e2.setRegion(partitionedRegion);
-      DistributedMember dm = this.getDistributionManager().getDistributionManagerId();
+      DistributedMember dm = getDistributionManager().getDistributionManagerId();
-    if (this.isInitialized()) {
+    if (isInitialized()) {
-      this.partitionedRegion.invokeTXCallbacks(eventType, prevent,
-          this.partitionedRegion.isInitialized() ? callDispatchListenerEvent : false);
+      partitionedRegion.invokeTXCallbacks(eventType, prevent,
+          partitionedRegion.isInitialized() && callDispatchListenerEvent);
-    if (this.isInitialized()) {
+    if (isInitialized()) {
-          && this.getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
+          && getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
-      this.partitionedRegion.invokeDestroyCallbacks(eventType, prevent,
-          this.partitionedRegion.isInitialized() ? callDispatchListenerEvent : false, false);
+      partitionedRegion.invokeDestroyCallbacks(eventType, prevent,
+          partitionedRegion.isInitialized() && callDispatchListenerEvent, false);
-    if (this.isInitialized()) {
+    if (isInitialized()) {
-          && this.getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
+          && getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
-      this.partitionedRegion.invokeInvalidateCallbacks(eventType, prevent,
-          this.partitionedRegion.isInitialized() ? callDispatchListenerEvent : false);
+      partitionedRegion.invokeInvalidateCallbacks(eventType, prevent,
+          partitionedRegion.isInitialized() && callDispatchListenerEvent);
-    if (this.isInitialized()) {
+    if (isInitialized()) {
-          && this.getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
+          && getEventTracker().isInitialImageProvider(event.getDistributedMember())) {
-      this.partitionedRegion.invokePutCallbacks(eventType, prevent,
-          this.partitionedRegion.isInitialized() ? callDispatchListenerEvent : false, false);
+      partitionedRegion.invokePutCallbacks(eventType, prevent,
+          partitionedRegion.isInitialized() && callDispatchListenerEvent, false);
-   * perform adjunct messaging for the given operation and return a set of members that should be
-   * attached to the operation's reply processor (if any)
+   * perform adjunct messaging for the given operation
-   * @return the set of failed recipients
-  protected Set performAdjunctMessaging(EntryEventImpl event, Set cacheOpRecipients,
-      Set adjunctRecipients, FilterRoutingInfo filterRoutingInfo, DirectReplyProcessor processor,
+  void performAdjunctMessaging(EntryEventImpl event, Set cacheOpRecipients,
+      Set adjunctRecipients, FilterRoutingInfo filterRoutingInfo,
+      DirectReplyProcessor processor,
-    Set failures = Collections.emptySet();
-      msg.setSender(this.partitionedRegion.getDistributionManager().getDistributionManagerId());
+      msg.setSender(partitionedRegion.getDistributionManager().getDistributionManagerId());
-      failures = msg.relayToListeners(cacheOpRecipients, adjunctRecipients, filterRoutingInfo,
-          event, this.partitionedRegion, processor);
+      msg.relayToListeners(cacheOpRecipients, adjunctRecipients, filterRoutingInfo,
+          event, partitionedRegion, processor);
-        failures = PutMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
-            filterRoutingInfo, this.partitionedRegion, event, op.isCreate(), !op.isCreate(),
+        PutMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
+            filterRoutingInfo, partitionedRegion, event, op.isCreate(), !op.isCreate(),
-        failures = DestroyMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
-            filterRoutingInfo, this.partitionedRegion, event, processor);
+        DestroyMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
+            filterRoutingInfo, partitionedRegion, event, processor);
-        failures = InvalidateMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
-            filterRoutingInfo, this.partitionedRegion, event, processor);
-      } else {
-        failures = adjunctRecipients;
+        InvalidateMessage.notifyListeners(cacheOpRecipients, adjunctRecipients,
+            filterRoutingInfo, partitionedRegion, event, processor);
-    return failures;
-    if (this.partitionedRegion.getSystem().getConfig().getDeltaPropagation()
+    if (partitionedRegion.getSystem().getConfig().getDeltaPropagation()
-          this.partitionedRegion.getCachePerfStats().endDeltaPrepared(start);
+          partitionedRegion.getCachePerfStats().endDeltaPrepared(start);
-   * @return the set of failed recipients
-  public Set performPutAllAdjunctMessaging(DistributedPutAllOperation dpao, Set cacheOpRecipients,
-      Set adjunctRecipients, FilterRoutingInfo filterRoutingInfo, DirectReplyProcessor processor) {
-    // create a PutAllPRMessage out of PutAllMessage to send to adjunct nodes
+  void performPutAllAdjunctMessaging(DistributedPutAllOperation dpao, Set cacheOpRecipients,
+      Set<InternalDistributedMember> adjunctRecipients, FilterRoutingInfo filterRoutingInfo,
+      DirectReplyProcessor processor) {
-    prMsg.initMessage(this.partitionedRegion, adjunctRecipients, true, processor);
-    prMsg.setSender(this.partitionedRegion.getDistributionManager().getDistributionManagerId());
-
-    // find members who have clients subscribed to this event and add them
-    // to the recipients list. Also determine if there are any FilterInfo
-    // routing tables for any of the receivers
-    // boolean anyWithRouting = false;
-    Set recipients = null;
-    Set membersWithRouting = filterRoutingInfo.getMembers();
-    for (Iterator it = membersWithRouting.iterator(); it.hasNext();) {
-      Object mbr = it.next();
-      if (!cacheOpRecipients.contains(mbr)) {
-        // anyWithRouting = true;
-        if (!adjunctRecipients.contains(mbr)) {
-          if (recipients == null) {
-            recipients = new HashSet();
-            recipients.add(mbr);
-          }
-        }
-      }
-    }
-    if (recipients == null) {
-      recipients = adjunctRecipients;
-    } else {
-      recipients.addAll(adjunctRecipients);
-    }
-
-    // Set failures = Collections.EMPTY_SET;
-
-    // if (!anyWithRouting) {
-    Set failures = this.partitionedRegion.getDistributionManager().putOutgoing(prMsg);
-
-    return failures;
+    prMsg.initMessage(partitionedRegion, adjunctRecipients, true, processor);
+    prMsg.setSender(partitionedRegion.getDistributionManager().getDistributionManagerId());
+    partitionedRegion.getDistributionManager().putOutgoing(prMsg);
-  public Set performRemoveAllAdjunctMessaging(DistributedRemoveAllOperation op,
-      Set cacheOpRecipients, Set adjunctRecipients, FilterRoutingInfo filterRoutingInfo,
+  void performRemoveAllAdjunctMessaging(DistributedRemoveAllOperation op,
+      Set cacheOpRecipients, Set<InternalDistributedMember> adjunctRecipients,
+      FilterRoutingInfo filterRoutingInfo,
-    prMsg.initMessage(this.partitionedRegion, adjunctRecipients, true, processor);
-    prMsg.setSender(this.partitionedRegion.getDistributionManager().getDistributionManagerId());
-
-    // find members who have clients subscribed to this event and add them
-    // to the recipients list. Also determine if there are any FilterInfo
-    // routing tables for any of the receivers
-    Set recipients = null;
-    Set membersWithRouting = filterRoutingInfo.getMembers();
-    for (Iterator it = membersWithRouting.iterator(); it.hasNext();) {
-      Object mbr = it.next();
-      if (!cacheOpRecipients.contains(mbr)) {
-        // anyWithRouting = true;
-        if (!adjunctRecipients.contains(mbr)) {
-          if (recipients == null) {
-            recipients = new HashSet();
-            recipients.add(mbr);
-          }
-        }
-      }
-    }
-    if (recipients == null) {
-      recipients = adjunctRecipients;
-    } else {
-      recipients.addAll(adjunctRecipients);
-    }
-
-    Set failures = this.partitionedRegion.getDistributionManager().putOutgoing(prMsg);
-    return failures;
+    prMsg.initMessage(partitionedRegion, adjunctRecipients, true, processor);
+    prMsg.setSender(partitionedRegion.getDistributionManager().getDistributionManagerId());
+    partitionedRegion.getDistributionManager().putOutgoing(prMsg);
-  protected Set getAdjunctReceivers(EntryEventImpl event, Set cacheOpReceivers, Set twoMessages,
+  protected Set<InternalDistributedMember> getAdjunctReceivers(EntryEventImpl event,
+      Set<InternalDistributedMember> cacheOpReceivers, Set<InternalDistributedMember> twoMessages,
-      Set r = this.partitionedRegion.getRegionAdvisor().adviseRequiresNotification(event);
-
-      if (r.size() > 0) {
-        r.removeAll(cacheOpReceivers);
-      }
+      Set<InternalDistributedMember> r =
+          partitionedRegion.getRegionAdvisor().adviseRequiresNotification();
+      r.removeAll(cacheOpReceivers);
-              r = new HashSet();
+              r = new HashSet<>();
-      event.setRegion(this.partitionedRegion);
-      this.partitionedRegion.cacheWriteBeforePut(event, netWriteRecipients, localWriter,
+      event.setRegion(partitionedRegion);
+      partitionedRegion.cacheWriteBeforePut(event, netWriteRecipients, localWriter,
-    boolean ret = false;
-      event.setRegion(this.partitionedRegion);
-      ret = this.partitionedRegion.cacheWriteBeforeDestroy(event, expectedOldValue);
+      event.setRegion(partitionedRegion);
+      return partitionedRegion.cacheWriteBeforeDestroy(event, expectedOldValue);
-    return ret;
-    // return super.cacheWriteBeforeDestroy(event);
-    return this.partitionedRegion.basicGetWriter();
+    return partitionedRegion.basicGetWriter();
-  public Set getBucketOwners() {
+  public Set<InternalDistributedMember> getBucketOwners() {
-  public void updateCounter(long delta) {
+  void updateCounter(long delta) {
-      this.counter.getAndAdd(delta);
+      counter.getAndAdd(delta);
-    if (this.counter.get() != 0) {
-      this.counter.set(0);
+    if (counter.get() != 0) {
+      counter.set(0);
-    if (this.limit == null) {
+    if (limit == null) {
-  static int calcMemSize(Object value) {
+  private static int calcMemSize(Object value) {
-    final PartitionedRegionDataStore prDs = this.partitionedRegion.getDataStore();
+    final PartitionedRegionDataStore prDs = partitionedRegion.getDataStore();
-    if (this.isDestroyed || this.isDestroyingDiskRegion) {
+    if (isDestroyed || isDestroyingDiskRegion) {
-      oldMemValue = this.bytesInMemory.getAndSet(BUCKET_DESTROYED);
+      oldMemValue = bytesInMemory.getAndSet(BUCKET_DESTROYED);
-    } else if (!this.isInitialized()) {
+    } else if (!isInitialized()) {
-      oldMemValue = this.bytesInMemory.getAndSet(0);
+      oldMemValue = bytesInMemory.getAndSet(0);
-      this.partitionedRegion.getPrStats().incDataStoreEntryCount(-sizeBeforeClear);
+      partitionedRegion.getPrStats().incDataStoreEntryCount(-sizeBeforeClear);
-    this.partitionedRegion.getPrStats().incDataStoreEntryCount(1);
+    partitionedRegion.getPrStats().incDataStoreEntryCount(1);
-    this.partitionedRegion.getPrStats().incDataStoreEntryCount(-1);
+    partitionedRegion.getPrStats().incDataStoreEntryCount(-1);
-    int newDiskSize = oldSize;
-    updateBucket2Size(oldSize, newDiskSize, SizeOp.EVICT);
-    return newDiskSize;
+    updateBucket2Size(oldSize, oldSize, SizeOp.EVICT);
+    return oldSize;
-    long result = this.bytesInMemory.get();
+    long result = bytesInMemory.get();
-    long result = this.bytesInMemory.get();
+    long result = bytesInMemory.get();
-  public void preDestroyBucket(int bucketId) {}
+  void preDestroyBucket(int bucketId) {}
-    this.preDestroyBucket(this.getId());
+    preDestroyBucket(getId());
-  protected void invokePartitionListenerAfterBucketRemoved() {
+  void invokePartitionListenerAfterBucketRemoved() {
-    for (int i = 0; i < partitionListeners.length; i++) {
-      PartitionListener listener = partitionListeners[i];
+    for (PartitionListener listener : partitionListeners) {
-  protected void invokePartitionListenerAfterBucketCreated() {
+  void invokePartitionListenerAfterBucketCreated() {
-    for (int i = 0; i < partitionListeners.length; i++) {
-      PartitionListener listener = partitionListeners[i];
+    for (PartitionListener listener : partitionListeners) {
-  void updateBucket2Size(int oldSize, int newSize, SizeOp op) {
+  private void updateBucket2Size(int oldSize, int newSize, SizeOp op) {
-  void updateBucketMemoryStats(final int memoryDelta) {
+  private void updateBucketMemoryStats(final int memoryDelta) {
-    final PartitionedRegionDataStore prDS = this.partitionedRegion.getDataStore();
+    final PartitionedRegionDataStore prDS = partitionedRegion.getDataStore();
-    return this.numOverflowOnDisk.get();
+    return numOverflowOnDisk.get();
-    return this.numOverflowBytesOnDisk.get();
+    return numOverflowBytesOnDisk.get();
-    return this.numEntriesInVM.get();
+    return numEntriesInVM.get();
-    this.numOverflowOnDisk.addAndGet(delta);
+    numOverflowOnDisk.addAndGet(delta);
-    this.numOverflowBytesOnDisk.addAndGet(delta);
+    numOverflowBytesOnDisk.addAndGet(delta);
-    this.numEntriesInVM.addAndGet(delta);
+    numEntriesInVM.addAndGet(delta);
-    this.evictions.getAndAdd(1);
+    evictions.getAndAdd(1);
-    return this.evictions.get();
+    return evictions.get();
-    EvictionAttributes ea = this.getAttributes().getEvictionAttributes();
+    EvictionAttributes ea = getAttributes().getEvictionAttributes();
-    int size =
-        action.isLocalDestroy() ? this.getRegionMap().sizeInVM() : (int) this.getNumEntriesInVM();
-    return size;
+    return action.isLocalDestroy() ? getRegionMap().sizeInVM() : (int) getNumEntriesInVM();
-    return this.partitionedRegion.getFilterProfile();
+    return partitionedRegion.getFilterProfile();
-    this.partitionedRegion.setCloningEnabled(isCloningEnabled);
+    partitionedRegion.setCloningEnabled(isCloningEnabled);
-    return this.partitionedRegion.getCloningEnabled();
+    return partitionedRegion.getCloningEnabled();
-  public void beforeReleasingPrimaryLockDuringDemotion() {}
+  void beforeReleasingPrimaryLockDuringDemotion() {}
-  public boolean areSecondariesPingable() {
-
-    Set<InternalDistributedMember> hostingservers =
-        this.partitionedRegion.getRegionAdvisor().getBucketOwners(this.getId());
-    hostingservers.remove(cache.getDistributedSystem().getDistributedMember());
-
-    if (cache.getLogger().fineEnabled())
-      cache.getLogger()
-          .fine("Pinging secondaries of bucket " + this.getId() + " on servers " + hostingservers);
-
-    if (hostingservers.size() == 0)
-      return true;
-
-    return ServerPingMessage.send(cache, hostingservers);
-
-  }
-
-    DiskRegion dr = this.getDiskRegion();
+    DiskRegion dr = getDiskRegion();
-    return this.getPartitionedRegion().getFullPath();
+    return getPartitionedRegion().getFullPath();
-    this.entries.close(this);
+    entries.close(this);
-    return this.entries.clear(rvv, this);
+    return entries.clear(rvv, this);

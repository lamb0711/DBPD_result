GEODE-1995: Removed ReliableMessageQueue, ReliableMessageQueueFactory, ReliableMessageQueueFactoryImpl and
it's usage in the code from GemfireCacheImpl and DistributedRegion.

GEODE-1995: Addressing Review Comments.
  Removed ReliableDistributionData
  CacheOperationMessage does not required now to implement ReliableDistributionData, as it is removed
  Removed all reference of getOperations and getOperationCount
  AbstractRegion#handleReliableDistribution does not use ReliableDistributionData removed the same.
  Removed SendQueueOperation
  Removed sendQueue from DistributedRegion
  Cleanup LocalizedStrings
  Removed SEND_QUEUE_MESSAGE from DataSerializableFixedID and DSFIDFactory

-   * Provides a queue for reliable message delivery
-   * 
-   * @since GemFire 5.0
-   */
-  protected final ReliableMessageQueue rmq;
-
-  /**
-    {
-      ReliableMessageQueue tmp = null;
-      if (this.requiresReliabilityCheck) {
-        // if
-        // (attrs.getMembershipAttributes().getLossAction().isAllAccessWithQueuing())
-        // {
-        // tmp = cache.getReliableMessageQueueFactory().create(this);
-        // }
-      }
-      this.rmq = tmp;
-    }
-
-  protected void handleReliableDistribution(ReliableDistributionData data,
-      Set successfulRecipients) {
-    handleReliableDistribution(data, successfulRecipients, Collections.EMPTY_SET,
-        Collections.EMPTY_SET);
+  protected void handleReliableDistribution(Set successfulRecipients) {
+    handleReliableDistribution(successfulRecipients, Collections.EMPTY_SET, Collections.EMPTY_SET);
-  protected void handleReliableDistribution(ReliableDistributionData data, Set successfulRecipients,
-      Set otherRecipients1, Set otherRecipients2) {
+  protected void handleReliableDistribution(Set successfulRecipients, Set otherRecipients1,
+      Set otherRecipients2) {
-  /**
-   * Sends a list of queued messages to members playing a specified role
-   * 
-   * @param list List of QueuedOperation instances to send. Any messages sent will be removed from
-   *        this list
-   * @param role the role that a recipient must be playing
-   * @return true if at least one message made it to at least one guy playing the role
-   */
-  boolean sendQueue(List list, Role role) {
-    SendQueueOperation op = new SendQueueOperation(getDistributionManager(), this, list, role);
-    return op.distribute();
-  }
-
-    if (this.rmq != null) {
-      this.rmq.close();
-    }
-
-    if (this.rmq != null && destroyDiskRegion) {
-      this.rmq.destroy();
-    }
-              if (DistributedRegion.this.rmq != null) {
-                Iterator it = newlyAcquiredRoles.iterator();
-                final DM dm = getDistributionManager();
-                while (it.hasNext()) {
-                  getCache().getCancelCriterion().checkCancelInProgress(null);
-                  final Role role = (Role) it.next();
-                  try {
-                    // do this in the waiting pool to make it async
-                    // @todo darrel/klund: add a single serial executor for
-                    // queue flush
-                    dm.getWaitingThreadPool().execute(new Runnable() {
-                      public void run() {
-                        DistributedRegion.this.rmq.roleReady(role);
-                      }
-                    });
-                    break;
-                  } catch (RejectedExecutionException ex) {
-                    throw ex;
-                  }
-                } // while
-              }

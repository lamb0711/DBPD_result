Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public final class FetchEntriesMessage extends PartitionMessage
-  {
+public final class FetchEntriesMessage extends PartitionMessage {
-  
+
-  
-  public FetchEntriesMessage() {
-  }
+
+  public FetchEntriesMessage() {}
-   * @param recipient the member that the fetch keys message is sent to 
-   * @param r  the PartitionedRegion that contains the bucket
+   * 
+   * @param recipient the member that the fetch keys message is sent to
+   * @param r the PartitionedRegion that contains the bucket
-  public static FetchEntriesResponse send(InternalDistributedMember recipient, 
-      PartitionedRegion r, int bucketId) 
-      throws ForceReattemptException
-  {
+  public static FetchEntriesResponse send(InternalDistributedMember recipient, PartitionedRegion r,
+      int bucketId) throws ForceReattemptException {
-    FetchEntriesResponse p = new FetchEntriesResponse(r.getSystem(), r,
-        recipient, bucketId);
-    FetchEntriesMessage m = new FetchEntriesMessage(recipient, r.getPRId(), p,
-        bucketId);
+    FetchEntriesResponse p = new FetchEntriesResponse(r.getSystem(), r, recipient, bucketId);
+    FetchEntriesMessage m = new FetchEntriesMessage(recipient, r.getPRId(), p, bucketId);
-      throw new ForceReattemptException(LocalizedStrings.FetchEntriesMessage_FAILED_SENDING_0.toLocalizedString(m));
+      throw new ForceReattemptException(
+          LocalizedStrings.FetchEntriesMessage_FAILED_SENDING_0.toLocalizedString(m));
-  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion pr, long startTime)
-      throws CacheException, ForceReattemptException
-  {
+  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion pr,
+      long startTime) throws CacheException, ForceReattemptException {
-        logger.trace(LogMarker.DM, "FetchKeysMessage send keys back using processorId: {}", getProcessorId());
+        logger.trace(LogMarker.DM, "FetchKeysMessage send keys back using processorId: {}",
+            getProcessorId());
-    }
-    else {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.FetchEntriesMessage_FETCHKEYSMESSAGE_DATA_STORE_NOT_CONFIGURED_FOR_THIS_MEMBER));
+    } else {
+      logger.warn(LocalizedMessage.create(
+          LocalizedStrings.FetchEntriesMessage_FETCHKEYSMESSAGE_DATA_STORE_NOT_CONFIGURED_FOR_THIS_MEMBER));
-    FetchEntriesReplyMessage.send(getSender(), getProcessorId(), dm, 
-        this.bucketId, entries);
-    
+    FetchEntriesReplyMessage.send(getSender(), getProcessorId(), dm, this.bucketId, entries);
+
-  protected void appendFields(StringBuffer buff)
-  {
+  protected void appendFields(StringBuffer buff) {
-  public void fromData(DataInput in) throws IOException, ClassNotFoundException
-  {
+  public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-  public void toData(DataOutput out) throws IOException
-  {
+  public void toData(DataOutput out) throws IOException {
-  
+
-    
+
-  
+
-    
+
-    
+
-     * Empty constructor to conform to DataSerializable interface 
+     * Empty constructor to conform to DataSerializable interface
-    public FetchEntriesReplyMessage() {
-    }
-  
-    protected FetchEntriesReplyMessage(InternalDistributedMember dest,
-        int processorId, int buckId, HeapDataOutputStream chunk,
-        int seriesNum, int msgNum, int numSeries, boolean lastInSeries, boolean hasRVV) {
+    public FetchEntriesReplyMessage() {}
+
+    protected FetchEntriesReplyMessage(InternalDistributedMember dest, int processorId, int buckId,
+        HeapDataOutputStream chunk, int seriesNum, int msgNum, int numSeries, boolean lastInSeries,
+        boolean hasRVV) {
-    
-    /** 
+
+    /**
+     * 
-                            final DM dm, final int bucketId, BucketRegion keys)   
-        throws ForceReattemptException {
+        final DM dm, final int bucketId, BucketRegion keys) throws ForceReattemptException {
-      
+
-      if(rvv != null) {
+      if (rvv != null) {
-        
+
-        boolean finished = chunkMap(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES, false,
-          new ObjectIntProcedure() {
-            int msgNum = 0;
-              
-            boolean last = false;
-            /**
-              * @param a byte[] chunk
-              * @param b positive if last chunk
-              * @return true to continue to next chunk
-              */
-            public boolean executeWith(Object a, int b) {
-//              if (this.last)
-//                throw new InternalGemFireError(LocalizedStrings.FetchEntriesMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());
-              HeapDataOutputStream chunk = (HeapDataOutputStream)a;
-              this.last = b > 0;
-              try {
-                boolean okay = sendChunk(recipient, processorId, bucketId, dm, chunk, seriesNum, msgNum++, numSeries, this.last, rvv != null);
-                return okay;
+        boolean finished = chunkMap(recipient, keys, InitialImageOperation.CHUNK_SIZE_IN_BYTES,
+            false, new ObjectIntProcedure() {
+              int msgNum = 0;
+
+              boolean last = false;
+
+              /**
+               * @param a byte[] chunk
+               * @param b positive if last chunk
+               * @return true to continue to next chunk
+               */
+              public boolean executeWith(Object a, int b) {
+                // if (this.last)
+                // throw new
+                // InternalGemFireError(LocalizedStrings.FetchEntriesMessage_ALREADY_PROCESSED_LAST_CHUNK.toLocalizedString());
+                HeapDataOutputStream chunk = (HeapDataOutputStream) a;
+                this.last = b > 0;
+                try {
+                  boolean okay = sendChunk(recipient, processorId, bucketId, dm, chunk, seriesNum,
+                      msgNum++, numSeries, this.last, rvv != null);
+                  return okay;
+                } catch (CancelException e) {
+                  return false;
+                }
-              catch (CancelException e) {
-                return false;
-              }
-            }
-          });
-  
+            });
+
-      }
-      catch (IOException io) {
+      } catch (IOException io) {
-        // One does not normally force a reply.  Is this correct?
-        throw new ForceReattemptException(LocalizedStrings.FetchEntriesMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCHENTRIES_REQUEST.toLocalizedString(), io);
+        // One does not normally force a reply. Is this correct?
+        throw new ForceReattemptException(
+            LocalizedStrings.FetchEntriesMessage_UNABLE_TO_SEND_RESPONSE_TO_FETCHENTRIES_REQUEST
+                .toLocalizedString(),
+            io);
-      
+
-                             DM dm, HeapDataOutputStream chunk,
-                             int seriesNum, int msgNum, int numSeries, boolean lastInSeries, boolean hasRVV) {
-      FetchEntriesReplyMessage reply = new FetchEntriesReplyMessage(recipient,
-          processorId, bucketId, chunk, seriesNum,
-          msgNum, numSeries, lastInSeries, hasRVV);
+        DM dm, HeapDataOutputStream chunk, int seriesNum, int msgNum, int numSeries,
+        boolean lastInSeries, boolean hasRVV) {
+      FetchEntriesReplyMessage reply = new FetchEntriesReplyMessage(recipient, processorId,
+          bucketId, chunk, seriesNum, msgNum, numSeries, lastInSeries, hasRVV);
-    
+
-     * Serialize the given map's entries into byte[] chunks, calling proc for each
-     * one. proc args: the byte[] chunk and an int indicating whether it
-     * is the last chunk (positive means last chunk, zero othewise).
-     * The return value of proc indicates whether to continue to the next
+     * Serialize the given map's entries into byte[] chunks, calling proc for each one. proc args:
+     * the byte[] chunk and an int indicating whether it is the last chunk (positive means last
+     * chunk, zero othewise). The return value of proc indicates whether to continue to the next
-    static boolean chunkMap(InternalDistributedMember receiver, BucketRegion map, int CHUNK_SIZE_IN_BYTES, boolean includeValues,
-                      ObjectIntProcedure proc)
-    throws IOException
-    {
+    static boolean chunkMap(InternalDistributedMember receiver, BucketRegion map,
+        int CHUNK_SIZE_IN_BYTES, boolean includeValues, ObjectIntProcedure proc)
+        throws IOException {
-          InitialImageOperation.CHUNK_SIZE_IN_BYTES+2048, receiver.getVersionObject());
+          InitialImageOperation.CHUNK_SIZE_IN_BYTES + 2048, receiver.getVersionObject());
-        while ((mos.size()+avgItemSize) < InitialImageOperation.CHUNK_SIZE_IN_BYTES && it.hasNext()) {
+        while ((mos.size() + avgItemSize) < InitialImageOperation.CHUNK_SIZE_IN_BYTES
+            && it.hasNext()) {
-          LocalRegion.NonTXEntry entry = (LocalRegion.NonTXEntry)it.next();
+          LocalRegion.NonTXEntry entry = (LocalRegion.NonTXEntry) it.next();
-          synchronized(re) {
+          synchronized (re) {
-            if (value == null) {
-              // only possible for disk entry
-              value = re.getSerializedValueOnDisk((LocalRegion)entry.getRegion());
-            }
-            if ( !Token.isRemoved(value) ) {
-              DataSerializer.writeObject(re.getKey(), mos);
-              if (Token.isInvalid(value)) {
-                value = null;
+              if (value == null) {
+                // only possible for disk entry
+                value = re.getSerializedValueOnDisk((LocalRegion) entry.getRegion());
-              VersionStamp stamp = re.getVersionStamp();
-              VersionTag versionTag = stamp != null ? stamp.asVersionTag() : null;
-              if(versionTag != null) {
-                versionTag.replaceNullIDs(map.getVersionMember());
-              }
-              DataSerializer.writeObject(value, mos);
-              DataSerializer.writeObject(versionTag, mos);
+              if (!Token.isRemoved(value)) {
+                DataSerializer.writeObject(re.getKey(), mos);
+                if (Token.isInvalid(value)) {
+                  value = null;
+                }
+                VersionStamp stamp = re.getVersionStamp();
+                VersionTag versionTag = stamp != null ? stamp.asVersionTag() : null;
+                if (versionTag != null) {
+                  versionTag.replaceNullIDs(map.getVersionMember());
+                }
+                DataSerializer.writeObject(value, mos);
+                DataSerializer.writeObject(versionTag, mos);
-              // Note we track the itemCount so we can compute avgItemSize
-              itemCount++;
-              // Note we track avgItemSize to help us not to always go one item
-              // past the max chunk size. When we go past it causes us to grow
-              // the ByteBuffer that the chunk is stored in resulting in a copy
-              // of the data.
-              avgItemSize = mos.size() / itemCount;
-            }
+                // Note we track the itemCount so we can compute avgItemSize
+                itemCount++;
+                // Note we track avgItemSize to help us not to always go one item
+                // past the max chunk size. When we go past it causes us to grow
+                // the ByteBuffer that the chunk is stored in resulting in a copy
+                // of the data.
+                avgItemSize = mos.size() / itemCount;
+              }
-        DataSerializer.writeObject((Object)null, mos);
+        DataSerializer.writeObject((Object) null, mos);
-    
+
-     * Processes this message.  This method is invoked by the receiver
-     * of the message.
+     * Processes this message. This method is invoked by the receiver of the message.
+     * 
-      FetchEntriesResponse processor = (FetchEntriesResponse)p;
-  
+      FetchEntriesResponse processor = (FetchEntriesResponse) p;
+
-      
+
-      dm.getStats().incReplyMessageTime(DistributionStats.getStatTime()
-          - startTime);
+      dm.getStats().incReplyMessageTime(DistributionStats.getStatTime() - startTime);
-    
-   
+
+
-    
+
-    public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    
+
-      sb.append("FetchEntriesReplyMessage ")
-        .append("processorid=").append(this.processorId)
-        .append(",bucketId=").append(this.bucketId);
-      if (getSender() != null) { 
+      sb.append("FetchEntriesReplyMessage ").append("processorid=").append(this.processorId)
+          .append(",bucketId=").append(this.bucketId);
+      if (getSender() != null) {
-      sb.append(",seriesNum=").append(seriesNum)
-        .append(",msgNum=").append(msgNum)
-        .append(",numSeries=").append(numSeries)
-        .append(",lastInSeries=").append(lastInSeries);
+      sb.append(",seriesNum=").append(seriesNum).append(",msgNum=").append(msgNum)
+          .append(",numSeries=").append(numSeries).append(",lastInSeries=").append(lastInSeries);
-      }
-      else if (chunkStream != null) {
+      } else if (chunkStream != null) {
- 
+
-   * A processor to capture the value returned by {@link 
-   * org.apache.geode.internal.cache.partitioned.GetMessage.GetReplyMessage}
+   * A processor to capture the value returned by
+   * {@link org.apache.geode.internal.cache.partitioned.GetMessage.GetReplyMessage}
+   * 
-  public static class FetchEntriesResponse extends ReplyProcessor21  {
+  public static class FetchEntriesResponse extends ReplyProcessor21 {
-    protected volatile RegionVersionVector returnRVV; 
+    protected volatile RegionVersionVector returnRVV;
-    private final Map<VersionSource,VersionSource> canonicalMembers = new ConcurrentHashMap<VersionSource,VersionSource>();
-    
+    private final Map<VersionSource, VersionSource> canonicalMembers =
+        new ConcurrentHashMap<VersionSource, VersionSource>();
+
-    
+
-    
+
-    
+
-    
-    public FetchEntriesResponse(InternalDistributedSystem ds,
-        final PartitionedRegion pr, final InternalDistributedMember recipient,
-        final int bucketId) {
+
+    public FetchEntriesResponse(InternalDistributedSystem ds, final PartitionedRegion pr,
+        final InternalDistributedMember recipient, final int bucketId) {
-        public String toString()
-        {
-//          int sz; 
-//          synchronized(this) {
-//            sz = this.size();
-//          }
-          return "Bucket id = " + bucketId + " from member = "
-              + recipient
-              + ": " + super.toString();
+        public String toString() {
+          // int sz;
+          // synchronized(this) {
+          // sz = this.size();
+          // }
+          return "Bucket id = " + bucketId + " from member = " + recipient + ": "
+              + super.toString();
-    
-    
-    
-    
+
+
+
-      //If the reply is a region version vector, store it in our RVV field.
-      if(msg instanceof ReplyMessage) {
+      // If the reply is a region version vector, store it in our RVV field.
+      if (msg instanceof ReplyMessage) {
-        if(returnValue instanceof RegionVersionVector) {
+        if (returnValue instanceof RegionVersionVector) {
-          synchronized(this.endLock) {
-            if(allMessagesReceived(true)) {
+          synchronized (this.endLock) {
+            if (allMessagesReceived(true)) {
-
-      // this processing algorighm won't work well if there are multiple recipients.  currently the
-      // retry logic for failed recipients is in PartitionedRegion.  If we parallelize the sending
+      // this processing algorighm won't work well if there are multiple recipients. currently the
+      // retry logic for failed recipients is in PartitionedRegion. If we parallelize the sending
-      
+
-      
+
-      }
-      else {
+      } else {
-          
+
-              
-              //Fix for 47260 - canonicalize the mebmer ids to avoid an OOME
-              VersionSource id = versionTag==null?null:versionTag.getMemberID();
+
+              // Fix for 47260 - canonicalize the mebmer ids to avoid an OOME
+              VersionSource id = versionTag == null ? null : versionTag.getMemberID();
-                if(canonicalMembers.containsKey(id)) {
+                if (canonicalMembers.containsKey(id)) {
-              
-              synchronized(returnValue) {
+
+              synchronized (returnValue) {
-            }
-            else {
+            } else {
-  
-          synchronized(this.endLock) {
+
+          synchronized (this.endLock) {
-  
-            if (((msg.seriesNum+1) == msg.numSeries)  &&  msg.lastInSeries) {
+
+            if (((msg.seriesNum + 1) == msg.numSeries) && msg.lastInSeries) {
-  
+
-              logger.trace(LogMarker.DM, "{} chunksProcessed={},lastChunkReceived={},chunksExpected={},done={}",
-                  this, chunksProcessed, lastChunkReceived, chunksExpected, doneProcessing);
+              logger.trace(LogMarker.DM,
+                  "{} chunksProcessed={},lastChunkReceived={},chunksExpected={},done={}", this,
+                  chunksProcessed, lastChunkReceived, chunksExpected, doneProcessing);
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
-            processException(new ReplyException(LocalizedStrings.FetchEntriesMessage_ERROR_DESERIALIZING_KEYS.toLocalizedString(), e));
+            processException(new ReplyException(
+                LocalizedStrings.FetchEntriesMessage_ERROR_DESERIALIZING_KEYS.toLocalizedString(),
+                e));
-            processException(new ReplyException(LocalizedStrings.FetchEntriesMessage_ERROR_DESERIALIZING_VALUES.toLocalizedString(), e)); // for bug 41202
+            processException(new ReplyException(
+                LocalizedStrings.FetchEntriesMessage_ERROR_DESERIALIZING_VALUES.toLocalizedString(),
+                e)); // for bug 41202
-  
+
-    
+
-      synchronized(this.endLock) {
-        return lastChunkReceived  &&  (chunksExpected == chunksProcessed) && (!hasRVV || returnRVV != null);
+      synchronized (this.endLock) {
+        return lastChunkReceived && (chunksExpected == chunksProcessed)
+            && (!hasRVV || returnRVV != null);
-    
+
-      }
-      catch (ReplyException e) {
+      } catch (ReplyException e) {
-          logger.debug("FetchKeysResponse got remote cancellation; forcing reattempt. {}", t.getMessage(), t);
-          throw new ForceReattemptException(LocalizedStrings.FetchEntriesMessage_FETCHKEYSRESPONSE_GOT_REMOTE_CANCELLATION_FORCING_REATTEMPT.toLocalizedString(), t);
-        }
-        else if (t instanceof ForceReattemptException) {
+          logger.debug("FetchKeysResponse got remote cancellation; forcing reattempt. {}",
+              t.getMessage(), t);
+          throw new ForceReattemptException(
+              LocalizedStrings.FetchEntriesMessage_FETCHKEYSRESPONSE_GOT_REMOTE_CANCELLATION_FORCING_REATTEMPT
+                  .toLocalizedString(),
+              t);
+        } else if (t instanceof ForceReattemptException) {
-          throw new ForceReattemptException(LocalizedStrings.FetchEntriesMessage_PEER_REQUESTS_REATTEMPT.toLocalizedString(), t);
+          throw new ForceReattemptException(
+              LocalizedStrings.FetchEntriesMessage_PEER_REQUESTS_REATTEMPT.toLocalizedString(), t);
-        throw new ForceReattemptException(LocalizedStrings.FetchEntriesMessage_NO_REPLIES_RECEIVED.toLocalizedString());
+        throw new ForceReattemptException(
+            LocalizedStrings.FetchEntriesMessage_NO_REPLIES_RECEIVED.toLocalizedString());
-      // Deserialize all CachedDeserializable here so we have access to applications thread context class loader
+      // Deserialize all CachedDeserializable here so we have access to applications thread context
+      // class loader
-        Map.Entry entry = (Map.Entry)it.next();
+        Map.Entry entry = (Map.Entry) it.next();
-          entry.setValue(((CachedDeserializable) value).getDeserializedValue(
-              null, null));
+          entry.setValue(((CachedDeserializable) value).getDeserializedValue(null, null));
- }
+}

GEODE-3539: add test coverage for "create async-event-queue" and "lisâ€¦ (#1093)



-import org.apache.geode.SystemFailure;
+import org.apache.geode.cache.asyncqueue.internal.AsyncEventQueueFactoryImpl;
+import org.apache.geode.cache.execute.Function;
-import org.apache.geode.management.internal.cli.CliUtil;
+import org.apache.geode.management.internal.cli.result.CommandResult;
-          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__PARALLEL__HELP) Boolean parallel,
+          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__PARALLEL__HELP) boolean parallel,
-          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__ENABLEBATCHCONFLATION__HELP) Boolean enableBatchConflation,
+          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__ENABLEBATCHCONFLATION__HELP) boolean enableBatchConflation,
-          unspecifiedDefaultValue = "1000",
+          unspecifiedDefaultValue = AsyncEventQueueFactoryImpl.DEFAULT_BATCH_TIME_INTERVAL + "",
-          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISKSYNCHRONOUS__HELP) Boolean diskSynchronous,
+          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISKSYNCHRONOUS__HELP) boolean diskSynchronous,
-          unspecifiedDefaultValue = "false", specifiedDefaultValue = "false",
-          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__FORWARD_EXPIRATION_DESTROY__HELP) Boolean ignoreEvictionAndExpiration,
+          unspecifiedDefaultValue = "false", specifiedDefaultValue = "true",
+          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__FORWARD_EXPIRATION_DESTROY__HELP) boolean forwardExpirationDestroy,
-          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISPATCHERTHREADS__HELP) Integer dispatcherThreads,
+          help = CliStrings.CREATE_ASYNC_EVENT_QUEUE__DISPATCHERTHREADS__HELP) int dispatcherThreads,
-    try {
-      if (listenerParamsAndValues != null) {
-        for (String listenerParamsAndValue : listenerParamsAndValues) {
-          final int hashPosition = listenerParamsAndValue.indexOf('#');
-          if (hashPosition == -1) {
-            listenerProperties.put(listenerParamsAndValue, "");
-          } else {
-            listenerProperties.put(listenerParamsAndValue.substring(0, hashPosition),
-                listenerParamsAndValue.substring(hashPosition + 1));
-          }
+    if (listenerParamsAndValues != null) {
+      for (String listenerParamsAndValue : listenerParamsAndValues) {
+        final int hashPosition = listenerParamsAndValue.indexOf('#');
+        if (hashPosition == -1) {
+          listenerProperties.put(listenerParamsAndValue, "");
+        } else {
+          listenerProperties.put(listenerParamsAndValue.substring(0, hashPosition),
+              listenerParamsAndValue.substring(hashPosition + 1));
-
-      TabularResultData tabularData = ResultBuilder.createTabularResultData();
-      boolean accumulatedData = false;
-
-      Set<DistributedMember> targetMembers = CliUtil.findMembers(groups, null);
-
-      if (targetMembers.isEmpty()) {
-        return ResultBuilder.createUserErrorResult(CliStrings.NO_MEMBERS_FOUND_MESSAGE);
-      }
-
-      AsyncEventQueueFunctionArgs aeqArgs = new AsyncEventQueueFunctionArgs(id, parallel,
-          enableBatchConflation, batchSize, batchTimeInterval, persistent, diskStore,
-          diskSynchronous, maxQueueMemory, dispatcherThreads, orderPolicy, gatewayEventFilters,
-          gatewaySubstitutionListener, listener, listenerProperties, ignoreEvictionAndExpiration);
-
-      ResultCollector<?, ?> rc =
-          CliUtil.executeFunction(new CreateAsyncEventQueueFunction(), aeqArgs, targetMembers);
-
-      List<CliFunctionResult> results = CliFunctionResult.cleanResults((List<?>) rc.getResult());
-
-      AtomicReference<XmlEntity> xmlEntity = new AtomicReference<>();
-      for (CliFunctionResult result : results) {
-        if (result.getThrowable() != null) {
-          tabularData.accumulate("Member", result.getMemberIdOrName());
-          tabularData.accumulate("Result", "ERROR: " + result.getThrowable().getClass().getName()
-              + ": " + result.getThrowable().getMessage());
-          accumulatedData = true;
-          tabularData.setStatus(Result.Status.ERROR);
-        } else if (result.isSuccessful()) {
-          tabularData.accumulate("Member", result.getMemberIdOrName());
-          tabularData.accumulate("Result", result.getMessage());
-          accumulatedData = true;
-
-          if (xmlEntity.get() == null) {
-            xmlEntity.set(result.getXmlEntity());
-          }
-        }
-      }
-
-      if (!accumulatedData) {
-        return ResultBuilder.createInfoResult("Unable to create async event queue(s).");
-      }
-
-      Result result = ResultBuilder.buildResult(tabularData);
-      if (xmlEntity.get() != null) {
-        persistClusterConfiguration(result,
-            () -> getSharedConfiguration().addXmlEntity(xmlEntity.get(), groups));
-      }
-      return result;
-    } catch (VirtualMachineError e) {
-      SystemFailure.initiateFailure(e);
-      throw e;
-    } catch (Throwable th) {
-      SystemFailure.checkFailure();
-      return ResultBuilder.createGemFireErrorResult(
-          CliStrings.format(CliStrings.CREATE_ASYNC_EVENT_QUEUE__ERROR_WHILE_CREATING_REASON_0,
-              new Object[] {th.getMessage()}));
+
+    Set<DistributedMember> targetMembers = getMembers(groups, null);
+
+    TabularResultData tabularData = ResultBuilder.createTabularResultData();
+    AsyncEventQueueFunctionArgs aeqArgs = new AsyncEventQueueFunctionArgs(id, parallel,
+        enableBatchConflation, batchSize, batchTimeInterval, persistent, diskStore, diskSynchronous,
+        maxQueueMemory, dispatcherThreads, orderPolicy, gatewayEventFilters,
+        gatewaySubstitutionListener, listener, listenerProperties, forwardExpirationDestroy);
+
+    CreateAsyncEventQueueFunction function = new CreateAsyncEventQueueFunction();
+    List<CliFunctionResult> results = execute(function, aeqArgs, targetMembers);
+
+    if (results.size() == 0) {
+      throw new RuntimeException("No results received.");
+    }
+
+    AtomicReference<XmlEntity> xmlEntity = new AtomicReference<>();
+    for (CliFunctionResult result : results) {
+      if (!result.isSuccessful()) {
+        tabularData.accumulate("Member", result.getMemberIdOrName());
+        tabularData.accumulate("Result", "ERROR: " + result.getErrorMessage());
+      } else {
+        tabularData.accumulate("Member", result.getMemberIdOrName());
+        tabularData.accumulate("Result", result.getMessage());
+
+        // if one member is successful in creating the AEQ and xmlEntity is not set yet,
+        // save the xmlEntity that is to be persisted
+        if (result.isSuccessful() && xmlEntity.get() == null) {
+          xmlEntity.set(result.getXmlEntity());
+        }
+      }
+    }
+    CommandResult commandResult = ResultBuilder.buildResult(tabularData);
+    if (xmlEntity.get() != null) {
+      persistClusterConfiguration(commandResult,
+          () -> getSharedConfiguration().addXmlEntity(xmlEntity.get(), groups));
+    }
+    return commandResult;
+  }
+
+  List<CliFunctionResult> execute(Function function, Object args,
+      Set<DistributedMember> targetMembers) {
+    ResultCollector rc = executeFunction(function, args, targetMembers);
+    return CliFunctionResult.cleanResults((List<?>) rc.getResult());

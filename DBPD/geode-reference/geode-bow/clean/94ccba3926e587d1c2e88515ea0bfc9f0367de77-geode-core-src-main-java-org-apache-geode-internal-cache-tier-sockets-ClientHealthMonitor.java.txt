GEODE-6649: Static analyzer warning cleanup.

cleanup

+
-import java.util.Iterator;
-      Map<ClientProxyMembershipID, Long> oldClientHeartbeats = this._clientHeartbeats;
+      Map<ClientProxyMembershipID, Long> oldClientHeartbeats = _clientHeartbeats;
-        this._clientHeartbeats = newClientHeartbeats;
+        _clientHeartbeats = newClientHeartbeats;
-      if (this.stats != null) {
-        this.stats.incClientRegisterRequests();
+      if (stats != null) {
+        stats.incClientRegisterRequests();
-      Map<ClientProxyMembershipID, Long> oldClientHeartbeats = this._clientHeartbeats;
+      Map<ClientProxyMembershipID, Long> oldClientHeartbeats = _clientHeartbeats;
-        this._clientHeartbeats = newClientHeartbeats;
+        _clientHeartbeats = newClientHeartbeats;
-            new Object[] {proxyID, clientDisconnectException == null ? "Unknown reason"
-                : clientDisconnectException.getLocalizedMessage()});
+            proxyID, clientDisconnectException == null ? "Unknown reason"
+                : clientDisconnectException.getLocalizedMessage());
-      if (this.stats != null) {
-        this.stats.incClientUnRegisterRequests();
+      if (stats != null) {
+        stats.incClientUnRegisterRequests();
-  public void unregisterClient(ClientProxyMembershipID proxyID, AcceptorImpl acceptor,
-      boolean clientDisconnectedCleanly, Throwable clientDisconnectException) {
+  void unregisterClient(ClientProxyMembershipID proxyID, AcceptorImpl acceptor,
+                        boolean clientDisconnectedCleanly, Throwable clientDisconnectException) {
-    final TXManagerImpl txMgr = (TXManagerImpl) this._cache.getCacheTransactionManager();
+    final TXManagerImpl txMgr = (TXManagerImpl) _cache.getCacheTransactionManager();
-    final TXManagerImpl txMgr = (TXManagerImpl) this._cache.getCacheTransactionManager();
+    final TXManagerImpl txMgr = (TXManagerImpl) _cache.getCacheTransactionManager();
-    if (this._cache.isClosed()) {
+    if (_cache.isClosed()) {
-  public void removeConnection(ClientProxyMembershipID proxyID, ServerConnection connection) {
+  void removeConnection(ClientProxyMembershipID proxyID, ServerConnection connection) {
-    if (this._clientMonitor == null) {
+    if (_clientMonitor == null) {
-      if (!this._clientHeartbeats.containsKey(proxyID)) {
+      if (!_clientHeartbeats.containsKey(proxyID)) {
-        this._clientHeartbeats.put(proxyID, Long.valueOf(System.currentTimeMillis()));
+        _clientHeartbeats.put(proxyID, System.currentTimeMillis());
-          String clientString = null;
+          String clientString;
-          Object[] data = null;
+          Object[] data;
-            map.put(membershipID, new Object[] {clientString, Integer.valueOf(connectionCount)});
+            map.put(membershipID, new Object[] {clientString, connectionCount});
-            data[1] = Integer.valueOf(((Integer) data[1]).intValue() + connectionCount);
+            data[1] = (Integer) data[1] + connectionCount;
-          /*
-           * Note: all client addresses are same... Iterator serverThreads = ((Set)
-           * entry.getValue()).iterator(); while (serverThreads.hasNext()) { ServerConnection
-           * connection = (ServerConnection) serverThreads.next(); InetAddress clientAddress =
-           * connection.getClientAddress(); logger.severe("getConnectedClients: proxyID=" + proxyID
-           * + " clientAddress=" + clientAddress + " FQDN=" + clientAddress.getCanonicalHostName());
-           * }
-           */
-          String memberId = null;
+          String memberId;
-          List socketPorts = new ArrayList();
-          List socketAddresses = new ArrayList();
+          List<Integer> socketPorts = new ArrayList<>();
+          List<InetAddress> socketAddresses = new ArrayList<>();
-            socketPorts.add(Integer.valueOf(sc.getSocketPort()));
+            socketPorts.add(sc.getSocketPort());
-            memberId = sc.getMembershipID(); // each ServerConnection has the
-            // same member id
+            memberId = sc.getMembershipID(); // each ServerConnection has the same member id
-  protected boolean cleanupClientThreads(ClientProxyMembershipID proxyID, boolean timedOut) {
+  private boolean cleanupClientThreads(ClientProxyMembershipID proxyID, boolean timedOut) {
-    Set serverConnections = null;
+    Set<ServerConnection> serverConnections = null;
-        for (Iterator it = serverConnections.iterator(); it.hasNext();) {
-          ServerConnection serverConnection = (ServerConnection) it.next();
+        for (ServerConnection serverConnection : serverConnections) {
-  protected void validateThreads(ClientProxyMembershipID proxyID) {
+  private void validateThreads(ClientProxyMembershipID proxyID) {
-            new Object[] {serverConnection,
-                Integer.valueOf(serverConnection.getClientReadTimeout())});
+            serverConnection, serverConnection.getClientReadTimeout());
-    synchronized (this._clientHeartbeatsLock) {
-      return new HashMap<>(this._clientHeartbeats);
+    synchronized (_clientHeartbeatsLock) {
+      return new HashMap<>(_clientHeartbeats);
-    if (this._clientMonitor != null) {
-      this._clientMonitor.stopMonitoring();
+    if (_clientMonitor != null) {
+      _clientMonitor.stopMonitoring();
-    this._cache = cache;
+    _cache = cache;
-    this.monitorInterval = Long.getLong(CLIENT_HEALTH_MONITOR_INTERVAL_PROPERTY,
+    monitorInterval = Long.getLong(CLIENT_HEALTH_MONITOR_INTERVAL_PROPERTY,
-    logger.debug("Setting monitorInterval to {}", this.monitorInterval);
+    logger.debug("Setting monitorInterval to {}", monitorInterval);
-      this._clientMonitor = new ClientHealthMonitorThread(maximumTimeBetweenPings);
-      this._clientMonitor.start();
+      _clientMonitor = new ClientHealthMonitorThread(maximumTimeBetweenPings);
+      _clientMonitor.start();
-      this._clientMonitor = null;
+      _clientMonitor = null;
-  public ServerConnectionCollection getProxyIdCollection(ClientProxyMembershipID proxyID) {
+  private ServerConnectionCollection getProxyIdCollection(ClientProxyMembershipID proxyID) {
-  public Map<ClientProxyMembershipID, MutableInt> getCleanupProxyIdTable() {
+  Map<ClientProxyMembershipID, MutableInt> getCleanupProxyIdTable() {
-  public Map<ServerSideHandshake, MutableInt> getCleanupTable() {
+  Map<ServerSideHandshake, MutableInt> getCleanupTable() {
-  public int getNumberOfClientsAtOrAboveVersion(Version version) {
+  private int getNumberOfClientsAtOrAboveVersion(Version version) {
-    protected void overrideHeartbeatTimeoutCheck(HeartbeatTimeoutCheck newCheck) {
+    void overrideHeartbeatTimeoutCheck(HeartbeatTimeoutCheck newCheck) {
-    protected final int _maximumTimeBetweenPings;
+    final int _maximumTimeBetweenPings;
-    protected volatile boolean _isStopped = false;
+    volatile boolean _isStopped = false;
-    protected ClientHealthMonitorThread(int maximumTimeBetweenPings) {
+    ClientHealthMonitorThread(int maximumTimeBetweenPings) {
-      this._maximumTimeBetweenPings = maximumTimeBetweenPings;
+      _maximumTimeBetweenPings = maximumTimeBetweenPings;
-          this._maximumTimeBetweenPings);
+          _maximumTimeBetweenPings);
-      this._isStopped = true;
-      this.interrupt();
+      _isStopped = true;
+      interrupt();
-      return this._isStopped;
+      return _isStopped;
-      while (!this._isStopped) {
+      while (!_isStopped) {
-          for (Iterator i = getClientHeartbeats().entrySet().iterator(); i.hasNext();) {
-            Map.Entry entry = (Map.Entry) i.next();
-            ClientProxyMembershipID proxyID = (ClientProxyMembershipID) entry.getKey();
+          for (Map.Entry<ClientProxyMembershipID, Long> entry : getClientHeartbeats().entrySet()) {
+            ClientProxyMembershipID proxyID = entry.getKey();
-            Long latestHeartbeatValue = (Long) entry.getValue();
+            Long latestHeartbeatValue = entry.getValue();
-              long latestHeartbeat = latestHeartbeatValue.longValue();
+              long latestHeartbeat = latestHeartbeatValue;
-                  this._maximumTimeBetweenPings)) {
+                  _maximumTimeBetweenPings)) {
-                        new Object[] {entry.getKey(), currentTime - latestHeartbeat,
-                            this._maximumTimeBetweenPings});
+                        entry.getKey(), currentTime - latestHeartbeat, _maximumTimeBetweenPings);
-          if (this._isStopped) {
+          if (_isStopped) {
-          if (!this._isStopped) {
+          if (!_isStopped) {

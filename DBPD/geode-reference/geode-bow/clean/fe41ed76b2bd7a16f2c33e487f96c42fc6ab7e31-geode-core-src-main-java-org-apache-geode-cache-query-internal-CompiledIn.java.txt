GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-
-/**
- * Class Description
- *
- * @version $Revision: 1.1 $
- */
-
-
-  /*
+  /**
-      Iterator iterator = ((Collection) evalColln).iterator();
+      Iterator iterator = ((Iterable) evalColln).iterator();
-  // Asif: If the size of aray is two this implies that it is
-  // a relation ship index & so the key field will be null in both the indexes
-  // as key is not a meaningful entity. The 0th element will refer to LHS
-  // operand
-  // and 1th element will refer to RHS operannd
+  /**
+   * If the size of aray is two this implies that it is a relation ship index & so the key field
+   * will be null in both the indexes as key is not a meaningful entity. The 0th element will refer
+   * to LHS operand and 1th element will refer to RHS operannd
+   */
+      // TODO: == check is identity only
-      IndexData indexData = QueryUtils.getAvailableIndexIfAny(path, context, this.TOK_EQ);
+      IndexData indexData = QueryUtils.getAvailableIndexIfAny(path, context, TOK_EQ);
-            indexData.getMapping(), this.TOK_EQ);
+            indexData.getMapping(), TOK_EQ);
-
-  // _indexInfo is a transient field
-  // if this is just faulted in then can be null
+  /**
+   * _indexInfo is a transient field if this is just faulted in then can be null
+   */
-  // Invariant: the receiver is dependent on the current iterator.
+  /**
+   * Invariant: the receiver is dependent on the current iterator.
+   */
-    // RuntimeIterator lIter = context.findRuntimeIterator(_left);
-    // RuntimeIterator rIter = context.findRuntimeIterator(_right);
+
-    // Asif Do not worry about the nature of the collection. As long as it
+    // Do not worry about the nature of the collection. As long as it
-
-   * Asif : Evaluates as a filter taking advantage of indexes if appropriate. This function has a
+   * Evaluates as a filter taking advantage of indexes if appropriate. This function has a
-    // RuntimeIterator itr = context.getCurrentIterator();
-    // Support.Assert(itr != null);
-    if (!isDependentOnCurrentScope(context))
+    if (!isDependentOnCurrentScope(context)) {
+    }
-  /**
-   * **************** PRIVATE METHODS **************************
-   * 
-   * @throws QueryInvocationTargetException
-   * @throws NameResolutionException
-   * @throws FunctionDomainException
-   * @throws TypeMismatchException
-   */
-
-        indpndntItrs == null ? null : indpndntItrs[0], context, projAttrib, null, false); // is
-                                                                                          // Intersection
-
-
-
+        indpndntItrs == null ? null : indpndntItrs[0], context, projAttrib, null, false);
+   *
+   * Invariant: the receiver is dependent on the current iterator.
-  // Invariant: the receiver is dependent on the current iterator.
-    if (orderByClause != null && orderByClause.booleanValue()) {
+    if (orderByClause != null && orderByClause) {
-    // ////////////////////////////////////////////////////////////////
+
-
-          Iterator iterator = ((ResultsSet) ((Object[]) key)[0]).iterator();
+          Iterator iterator = ((Iterable) ((Object[]) key)[0]).iterator();
-            this.queryIndex(Long.valueOf(a[i]), indexInfo, results, iterOperands, indpndntItr,
-                context, projAttrib, conditioningNeeded);
+            this.queryIndex(a[i], indexInfo, results, iterOperands, indpndntItr, context,
+                projAttrib, conditioningNeeded);
-            this.queryIndex(Double.valueOf(a[i]), indexInfo, results, iterOperands, indpndntItr,
-                context, projAttrib, conditioningNeeded);
+            this.queryIndex(a[i], indexInfo, results, iterOperands, indpndntItr, context,
+                projAttrib, conditioningNeeded);
-            this.queryIndex(new Float(a[i]), indexInfo, results, iterOperands, indpndntItr, context,
+            this.queryIndex(a[i], indexInfo, results, iterOperands, indpndntItr, context,
-            this.queryIndex(Integer.valueOf(a[i]), indexInfo, results, iterOperands, indpndntItr,
-                context, projAttrib, conditioningNeeded);
+            this.queryIndex(a[i], indexInfo, results, iterOperands, indpndntItr, context,
+                projAttrib, conditioningNeeded);
-            this.queryIndex(new Short(a[i]), indexInfo, results, iterOperands, indpndntItr, context,
+            this.queryIndex(a[i], indexInfo, results, iterOperands, indpndntItr, context,
-            this.queryIndex(new Character(a[i]), indexInfo, results, iterOperands, indpndntItr,
-                context, projAttrib, conditioningNeeded);
+            this.queryIndex(a[i], indexInfo, results, iterOperands, indpndntItr, context,
+                projAttrib, conditioningNeeded);
-            this.queryIndex(new Byte(a[i]), indexInfo, results, iterOperands, indpndntItr, context,
+            this.queryIndex(a[i], indexInfo, results, iterOperands, indpndntItr, context,
-
-        results = QueryUtils.getconditionedIndexResults(results, indexInfo, context,
+        results = QueryUtils.getConditionedIndexResults(results, indexInfo, context,
-
-
-
-   * is no index available. Asif :The booelan true implies that CompiledComparsion when existing on
-   * its own always requires a Completeexpansion to top level iterators. This flag can get toggled
-   * to false only from inside a GroupJunction
+   * is no index available. The boolean true implies that CompiledComparison when existing on its
+   * own always requires a CompleteExpansion to top level iterators. This flag can get toggled to
+   * false only from inside a GroupJunction
-    // Asif : This function can be invoked only if the where clause contains
+    // This function can be invoked only if the where clause contains
-    return filterEvaluate(context, intermediateResults, true/*
-                                                             * Complete Expansion needed
-                                                             */, null,
-        indpndntItr != null ? new RuntimeIterator[] {indpndntItr}
-            : null/*
-                   * Asif :It is safe to pass null as the independent iterator to which the
-                   * condition belongs is required only if boolean complete expansion turns out to
-                   * be false, which can happen only in case of CompiledComparison/CompiledUndefined
-                   * called from roupJunction or CompositeGroupJunction
-                   */,
-        true /* is intersection */, this.isConditioningNeededForIndex(indpndntItr, context, true),
-        true);
+    /*
+     * It is safe to pass null as the independent iterator to which the condition belongs is
+     * required only if boolean complete expansion turns out to be false, which can happen only in
+     * case of CompiledComparison/CompiledUndefined called from GroupJunction or
+     * CompositeGroupJunction
+     */
+    return filterEvaluate(context, intermediateResults, true, null,
+        indpndntItr != null ? new RuntimeIterator[] {indpndntItr} : null, true,
+        this.isConditioningNeededForIndex(indpndntItr, context, true), true);
-  /*
-   * Asif : This function should never get invoked as now if a CompiledJunction or GroupJunction
-   * contains a single filterable CompiledComparison it should directly call filterEvaluate rather
-   * than auxFilterEvalutae. Overriding this function just for ensuring that auxFilterEvaluate is
-   * not being called by mistake.
+  /**
+   * This function should never get invoked as now if a CompiledJunction or GroupJunction contains a
+   * single filterable CompiledComparison it should directly call filterEvaluate rather than
+   * auxFilterEvalutae. Overriding this function just for ensuring that auxFilterEvaluate is not
+   * being called by mistake.
-        // Asif: Give preference to IN . Is this right? It does not appear . Ideally we need to get
+        // Give preference to IN . Is this right? It does not appear . Ideally we need to get
-      // Asif: This implies it is an independent condition. So evaluate it first
-      // in filter operand
+      // This implies it is an independent condition. So evaluate it first in filter operand
-    if (key != null && key.equals(QueryService.UNDEFINED))
+    if (key != null && key.equals(QueryService.UNDEFINED)) {
+    }
-          size +=
-              idxInfo[0]._index.getSizeEstimate(Long.valueOf(a[i]), TOK_EQ, idxInfo[0]._matchLevel);
+          size += idxInfo[0]._index.getSizeEstimate(a[i], TOK_EQ, idxInfo[0]._matchLevel);
-          size += idxInfo[0]._index.getSizeEstimate(Double.valueOf(a[i]), TOK_EQ,
-              idxInfo[0]._matchLevel);
+          size += idxInfo[0]._index.getSizeEstimate(a[i], TOK_EQ, idxInfo[0]._matchLevel);
-          size +=
-              idxInfo[0]._index.getSizeEstimate(new Float(a[i]), TOK_EQ, idxInfo[0]._matchLevel);
-
+          size += idxInfo[0]._index.getSizeEstimate(a[i], TOK_EQ, idxInfo[0]._matchLevel);
-          size += idxInfo[0]._index.getSizeEstimate(Integer.valueOf(a[i]), TOK_EQ,
-              idxInfo[0]._matchLevel);
+          size += idxInfo[0]._index.getSizeEstimate(a[i], TOK_EQ, idxInfo[0]._matchLevel);
-          size +=
-              idxInfo[0]._index.getSizeEstimate(new Short(a[i]), TOK_EQ, idxInfo[0]._matchLevel);
-
+          size += idxInfo[0]._index.getSizeEstimate(a[i], TOK_EQ, idxInfo[0]._matchLevel);
-          size += idxInfo[0]._index.getSizeEstimate(new Character(a[i]), TOK_EQ,
-              idxInfo[0]._matchLevel);
+          size += idxInfo[0]._index.getSizeEstimate(a[i], TOK_EQ, idxInfo[0]._matchLevel);
-          size += idxInfo[0]._index.getSizeEstimate(new Byte(a[i]), TOK_EQ, idxInfo[0]._matchLevel);
-
+          size += idxInfo[0]._index.getSizeEstimate(a[i], TOK_EQ, idxInfo[0]._matchLevel);
-
-
+  public boolean isRangeEvaluatable() {
+    return false;
+  }
-  /* Inner classes for passing stuff around */
-  class PathAndKey {
+  static class PathAndKey {
-
-
-  public boolean isRangeEvaluatable() {
-    return false;
-  }
-

Merge branch 'release/1.8.0'

+import java.util.Arrays;
+import java.util.Optional;
+import java.util.stream.Collectors;
+import org.apache.geode.cache.configuration.CacheConfig;
+import org.apache.geode.cache.configuration.DeclarableType;
-import org.apache.geode.distributed.internal.InternalConfigurationPersistenceService;
+import org.apache.geode.management.cli.SingleGfshCommand;
-import org.apache.geode.management.internal.cli.result.CommandResult;
-import org.apache.geode.management.internal.configuration.domain.XmlEntity;
+import org.apache.geode.management.internal.cli.result.model.ResultModel;
-public class CreateGatewaySenderCommand extends InternalGfshCommand {
+public class CreateGatewaySenderCommand extends SingleGfshCommand {
-  public Result createGatewaySender(@CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},
+  public ResultModel createGatewaySender(@CliOption(key = {CliStrings.GROUP, CliStrings.GROUPS},
-    GatewaySenderFunctionArgs gatewaySenderFunctionArgs =
-        new GatewaySenderFunctionArgs(id, remoteDistributedSystemId, parallel, manualStart,
+    CacheConfig.GatewaySender configuration =
+        buildConfiguration(id, remoteDistributedSystemId, parallel, manualStart,
+    GatewaySenderFunctionArgs gatewaySenderFunctionArgs =
+        new GatewaySenderFunctionArgs(configuration);
-      return ResultBuilder.createUserErrorResult(
+      return ResultModel.createError(
-    CommandResult result = ResultBuilder.buildResult(gatewaySenderCreateResults);
-    XmlEntity xmlEntity = findXmlEntity(gatewaySenderCreateResults);
+    ResultModel resultModel = ResultModel.createMemberStatusResult(gatewaySenderCreateResults);
+    resultModel.setConfigObject(configuration);
-    // no xml needs to be updated, simply return
-    if (xmlEntity == null) {
-      return result;
-    }
+    return resultModel;
+  }
-    // has xml but unable to persist to cluster config, need to print warning message and return
-    if (onMember != null || getConfigurationPersistenceService() == null) {
-      result.setCommandPersisted(false);
-      return result;
-    }
-
-    // update cluster config
-    ((InternalConfigurationPersistenceService) getConfigurationPersistenceService())
-        .addXmlEntity(xmlEntity, onGroups);
-    return result;
+  @Override
+  public void updateClusterConfig(String group, CacheConfig config, Object configObject) {
+    config.getGatewaySenders().add((CacheConfig.GatewaySender) configObject);
+  private CacheConfig.GatewaySender buildConfiguration(String id, Integer remoteDSId,
+      Boolean parallel,
+      Boolean manualStart,
+      Integer socketBufferSize,
+      Integer socketReadTimeout,
+      Boolean enableBatchConflation,
+      Integer batchSize,
+      Integer batchTimeInterval,
+      Boolean enablePersistence,
+      String diskStoreName,
+      Boolean diskSynchronous,
+      Integer maxQueueMemory,
+      Integer alertThreshold,
+      Integer dispatcherThreads,
+      String orderPolicy,
+      String[] gatewayEventFilters,
+      String[] gatewayTransportFilters) {
+    CacheConfig.GatewaySender sender = new CacheConfig.GatewaySender();
+    sender.setId(id);
+    sender.setRemoteDistributedSystemId(int2string(remoteDSId));
+    sender.setParallel(parallel);
+    sender.setManualStart(manualStart);
+    sender.setSocketBufferSize(int2string(socketBufferSize));
+    sender.setSocketReadTimeout(int2string(socketReadTimeout));
+    sender.setEnableBatchConflation(enableBatchConflation);
+    sender.setBatchSize(int2string(batchSize));
+    sender.setBatchTimeInterval(int2string(batchTimeInterval));
+    sender.setEnablePersistence(enablePersistence);
+    sender.setDiskStoreName(diskStoreName);
+    sender.setDiskSynchronous(diskSynchronous);
+    sender.setMaximumQueueMemory(int2string(maxQueueMemory));
+    sender.setAlertThreshold(int2string(alertThreshold));
+    sender.setDispatcherThreads(int2string(dispatcherThreads));
+    sender.setOrderPolicy(orderPolicy);
+    if (gatewayEventFilters != null) {
+      sender.getGatewayEventFilters().addAll((stringsToDeclarableTypes(gatewayEventFilters)));
+    }
+    if (gatewayTransportFilters != null) {
+      sender.getGatewayTransportFilters().addAll(stringsToDeclarableTypes(gatewayTransportFilters));
+    }
+
+    return sender;
+  }
+
+  private List<DeclarableType> stringsToDeclarableTypes(String[] objects) {
+    return Arrays.stream(objects).map(fullyQualifiedClassName -> {
+      DeclarableType thisFilter = new DeclarableType();
+      thisFilter.setClassName(fullyQualifiedClassName);
+      return thisFilter;
+    }).collect(Collectors.toList());
+  }
+
+  private String int2string(Integer i) {
+    return Optional.ofNullable(i).map(in -> in.toString()).orElse(null);
+  }
+

Merge branch 'release/1.0.0-incubating.M3'

+import static com.gemstone.gemfire.distributed.ConfigurationProperties.*;
+
+import org.apache.shiro.subject.Subject;
-import com.gemstone.gemfire.cache.query.internal.cq.InternalCqQuery;
-import com.gemstone.gemfire.internal.SocketUtils;
-import com.gemstone.gemfire.internal.cache.ClientServerObserver;
-import com.gemstone.gemfire.internal.cache.ClientServerObserverHolder;
-import com.gemstone.gemfire.internal.cache.ClientRegionEventImpl;
-import com.gemstone.gemfire.internal.cache.CacheServerImpl;
-import com.gemstone.gemfire.internal.cache.CachedDeserializable;
+import com.gemstone.gemfire.internal.cache.CacheServerImpl;
+import com.gemstone.gemfire.internal.cache.ClientRegionEventImpl;
+import com.gemstone.gemfire.internal.cache.ClientServerObserver;
+import com.gemstone.gemfire.internal.cache.ClientServerObserverHolder;
-import com.gemstone.gemfire.internal.cache.EntryEventImpl.SerializedCacheValueImpl;
- * @since 3.2
+ * @since GemFire 3.2
-   * @param transactionTimeToLive - ttl for txstates for disconnected clients
-      int transactionTimeToLive,
-          messageTimeToLive, transactionTimeToLive,
-          listener, overflowAttributesList, isGatewayReceiver);
+          messageTimeToLive, listener, overflowAttributesList, isGatewayReceiver);
-
-  /** the amount of time in seconds to keep a disconnected client's txstates around */
-  private final int transactionTimeToLive;
-    DataInputStream dis = new DataInputStream(SocketUtils.getInputStream(socket));//socket.getInputStream());
-    DataOutputStream dos = new DataOutputStream(SocketUtils.getOutputStream(socket));//socket.getOutputStream());
+    DataInputStream dis = new DataInputStream(socket.getInputStream());
+    DataOutputStream dos = new DataOutputStream(socket.getOutputStream());
-          .getProperty(DistributionConfig.SECURITY_CLIENT_AUTHENTICATOR_NAME);
+          .getProperty(SECURITY_CLIENT_AUTHENTICATOR);
-      
+
+      proxy = registerClient(socket, proxyID, proxy, isPrimary, clientConflation,
+        clientVersion, acceptorId, notifyBySubscription);
-      Properties credentials = HandShake.readCredentials(dis, dos,
-          authenticator, system);
-      if (credentials != null) {
+      Properties credentials = HandShake.readCredentials(dis, dos, system);
+      if (credentials != null && proxy!=null) {
-        Principal principal = HandShake.verifyCredentials(authenticator,
+        Object subject = HandShake.verifyCredentials(authenticator,
-        if (securityLogWriter.fineEnabled()) {
-          securityLogWriter.fine("CacheClientNotifier: successfully verified credentials for proxyID: " + proxyID + " having principal: " + principal.getName());
-        }
-        String postAuthzFactoryName = sysProps
-            .getProperty(DistributionConfig.SECURITY_CLIENT_ACCESSOR_PP_NAME);
-        if (postAuthzFactoryName != null && postAuthzFactoryName.length() > 0) {
-          if (principal == null) {
-            securityLogWriter.warning(LocalizedStrings.CacheClientNotifier_CACHECLIENTNOTIFIER_POST_PROCESS_AUTHORIZATION_CALLBACK_ENABLED_BUT_AUTHENTICATION_CALLBACK_0_RETURNED_WITH_NULL_CREDENTIALS_FOR_PROXYID_1, new Object[] {DistributionConfig.SECURITY_CLIENT_AUTHENTICATOR_NAME, proxyID});
+        if(subject instanceof Principal){
+          Principal principal = (Principal) subject;
+          if (securityLogWriter.fineEnabled()) {
+            securityLogWriter.fine("CacheClientNotifier: successfully verified credentials for proxyID: " + proxyID + " having principal: " + principal.getName());
-          Method authzMethod = ClassLoadUtil
-              .methodFromName(postAuthzFactoryName);
-          authzCallback = (AccessControl)authzMethod.invoke(null,
-              (Object[])null);
-          authzCallback.init(principal, member, this.getCache());
+
+          String postAuthzFactoryName = sysProps
+              .getProperty(SECURITY_CLIENT_ACCESSOR_PP);
+          if (postAuthzFactoryName != null && postAuthzFactoryName.length() > 0) {
+            if (principal == null) {
+              securityLogWriter.warning(LocalizedStrings.CacheClientNotifier_CACHECLIENTNOTIFIER_POST_PROCESS_AUTHORIZATION_CALLBACK_ENABLED_BUT_AUTHENTICATION_CALLBACK_0_RETURNED_WITH_NULL_CREDENTIALS_FOR_PROXYID_1, new Object[] {
+                SECURITY_CLIENT_AUTHENTICATOR, proxyID
+              });
+            }
+            Method authzMethod = ClassLoadUtil.methodFromName(postAuthzFactoryName);
+            authzCallback = (AccessControl) authzMethod.invoke(null, (Object[]) null);
+            authzCallback.init(principal, member, this.getCache());
+          }
+          proxy.setPostAuthzCallback(authzCallback);
+        }
+        else if(subject instanceof Subject){
+          proxy.setSubject((Subject)subject);
-
-    catch (Exception ex) {
-      logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientNotifier_AN_EXCEPTION_WAS_THROWN_FOR_CLIENT_0_1, new Object[] {proxyID, ""}), ex);
-      writeException(dos, Acceptor.UNSUCCESSFUL_SERVER_TO_CLIENT, ex, clientVersion);
-      return;
-    }
-    try {
-      proxy = registerClient(socket, proxyID, proxy, isPrimary, clientConflation,
-		  clientVersion, acceptorId, notifyBySubscription);
-    }
-    if (authzCallback != null && proxy != null) {
-      proxy.setPostAuthzCallback(authzCallback);
+    catch (Exception ex) {
+      logger.warn(LocalizedMessage.create(LocalizedStrings.CacheClientNotifier_AN_EXCEPTION_WAS_THROWN_FOR_CLIENT_0_1, new Object[] {proxyID, ""}), ex);
+      writeException(dos, Acceptor.UNSUCCESSFUL_SERVER_TO_CLIENT, ex, clientVersion);
+      return;
+
+
+      boolean toCreateNewProxy = true;
-        // A proxy exists for this non-durable client. It must be closed.
-        if (logger.isDebugEnabled()) {
-          logger.debug("CacheClientNotifier: A proxy exists for this non-durable client. It must be closed.");
-        }
-        if (staleClientProxy.startRemoval()) {
-          staleClientProxy.waitRemoval();
-        }
-        else {
-          staleClientProxy.close(false, false); // do not check for queue, just close it
-          removeClientProxy(staleClientProxy); // remove old proxy from proxy set
+        if (staleClientProxy.isConnected() && staleClientProxy.getSocket().isConnected()) {
+          successful = false;
+          toCreateNewProxy = false;
+        } else {
+          // A proxy exists for this non-durable client. It must be closed.
+          if (logger.isDebugEnabled()) {
+            logger.debug("CacheClientNotifier: A proxy exists for this non-durable client. It must be closed.");
+          }
+          if (staleClientProxy.startRemoval()) {
+            staleClientProxy.waitRemoval();
+          }
+          else {
+            staleClientProxy.close(false, false); // do not check for queue, just close it
+            removeClientProxy(staleClientProxy); // remove old proxy from proxy set
+          }
-      // Create the new proxy for this non-durable client
-      l_proxy = new CacheClientProxy(this, socket, proxyId,
-          isPrimary, clientConflation, clientVersion, acceptorId, notifyBySubscription);
-      successful = this.initializeProxy(l_proxy);
+      if (toCreateNewProxy) {
+        // Create the new proxy for this non-durable client
+        l_proxy = new CacheClientProxy(this, socket, proxyId,
+            isPrimary, clientConflation, clientVersion, acceptorId, notifyBySubscription);
+        successful = this.initializeProxy(l_proxy);
+      }
-          SocketUtils.getOutputStream(socket)));//socket.getOutputStream()));
+          socket.getOutputStream()));
-   * @since 5.7
+   * @since GemFire 5.7
-   * @since 6.1
+   * @since GemFire 6.1
-   * @since 5.7
+   * @since GemFire 5.7
+    if (haContainer == null) {
+      return;
+    }
-   * @since 5.6
+   * @since GemFire 5.6
-   * @since 5.6
+   * @since GemFire 5.6
-   * @since 5.8Beta
+   * @since GemFire 5.8Beta
-   * @since 5.8Beta
+   * @since GemFire 5.8Beta
-   * @since 5.8Beta
+   * @since GemFire 5.8Beta
-   * @since 5.8Beta
+   * @since GemFire 5.8Beta
-   * @since 5.8Beta
+   * @since GemFire 5.8Beta
-   * @param transactionTimeToLive - ttl for txstates for disconnected clients
-      int maximumMessageCount, int messageTimeToLive, int transactionTimeToLive,
-      ConnectionListener listener,
-      List overflowAttributesList, boolean isGatewayReceiver) {
+      int maximumMessageCount, int messageTimeToLive, 
+      ConnectionListener listener, List overflowAttributesList, boolean isGatewayReceiver) {
-    this.transactionTimeToLive = transactionTimeToLive;
-  private HAContainerWrapper haContainer;
+  private volatile HAContainerWrapper haContainer;
-  public static final String MAX_QUEUE_LOG_FREQUENCY = "gemfire.logFrequency.clientQueueReachedMaxLimit";
+  public static final String MAX_QUEUE_LOG_FREQUENCY = DistributionConfig.GEMFIRE_PREFIX + "logFrequency.clientQueueReachedMaxLimit";
-  public static final String EVENT_ENQUEUE_WAIT_TIME_NAME = "gemfire.subscription.EVENT_ENQUEUE_WAIT_TIME";
+  public static final String EVENT_ENQUEUE_WAIT_TIME_NAME = DistributionConfig.GEMFIRE_PREFIX + "subscription.EVENT_ENQUEUE_WAIT_TIME";
-    Long.getLong("gemfire.serverToClientPingPeriod", 60000);
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "serverToClientPingPeriod", 60000);
-    Long.getLong("gemfire.serverToClientPingCounter", 3);
+      Long.getLong(DistributionConfig.GEMFIRE_PREFIX + "serverToClientPingCounter", 3);
-
-
-  /**
-   * @return the time-to-live for abandoned transactions, in seconds
-   */
-  public int getTransactionTimeToLive() {
-    return this.transactionTimeToLive;
-  }

Merge branch 'release/1.3.0'

-import static org.apache.geode.distributed.ConfigurationProperties.*;
+import static org.apache.geode.distributed.ConfigurationProperties.LOCATORS;
+import static org.apache.geode.distributed.ConfigurationProperties.MCAST_PORT;
-import org.apache.geode.cache.CacheXmlException;
+import org.apache.geode.cache.CacheXmlException;
+import org.apache.geode.internal.security.SecurityService;
+import org.apache.geode.internal.security.SecurityServiceFactory;
+import org.apache.geode.security.PostProcessor;
+import org.apache.geode.security.SecurityManager;
+import org.apache.logging.log4j.Logger;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.Reader;
+import java.lang.reflect.Array;
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Properties;
+import java.util.Set;
+import java.util.SortedSet;
+import java.util.StringTokenizer;
+import java.util.TreeSet;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicReference;
+  private volatile SecurityService securityService;
+
+    return newInstance(config, SecurityConfig.get());
+  }
+
+  public static InternalDistributedSystem newInstance(Properties config,
+      SecurityConfig securityConfig) {
+    if (securityConfig == null) {
+      return newInstance(config, null, null);
+    } else {
+      return newInstance(config, securityConfig.getSecurityManager(),
+          securityConfig.getPostProcessor());
+    }
+  }
+
+  public static InternalDistributedSystem newInstance(Properties config,
+      SecurityManager securityManager, PostProcessor postProcessor) {
-      newSystem.initialize();
+      newSystem.initialize(securityManager, postProcessor);
-        LoggingThreadGroup.cleanUpThreadGroups(); // bug44365 - logwriters accumulate, causing mem
-                                                  // leak
+        // bug44365 - logwriters accumulate, causing mem leak
+        LoggingThreadGroup.cleanUpThreadGroups();
-
-   * 
+   *
-
-    // if (DistributionConfigImpl.multicastTest) {
-    // this.logger.warning("Use of multicast has been forced");
-    // }
-    // if (DistributionConfigImpl.forceDisableTcp) {
-    // this.logger.warning("Use of UDP has been forced");
-    // }
-    // if
-    // (org.apache.geode.distributed.internal.membership.jgroup.JGroupMembershipManager.multicastTest)
-    // {
-    // this.logger.warning("Use of multicast for all distributed cache operations has been forced");
-    // }
-
+  public SecurityService getSecurityService() {
+    return this.securityService;
+  }
+
+  public void setSecurityService(SecurityService securityService) {
+    this.securityService = securityService;
+  }
+
-  private void initialize() {
+  private void initialize(SecurityManager securityManager, PostProcessor postProcessor) {
+
+    this.securityService = SecurityServiceFactory.create(this.config.getSecurityProps(),
+        securityManager, postProcessor);
+
-              locId.getHost(), locId.getHostnameForClients(), this.originalConfig.toProperties(),
-              false);
+              locId.getHost().getAddress(), locId.getHostnameForClients(),
+              this.originalConfig.toProperties(), false);
-        canonical.append(locId.getHost().getHostAddress());
+        canonical.append(locId.getHostName());
-    return (Statistics[]) statsList.toArray(new Statistics[0]);
+    return statsList.toArray(new Statistics[0]);
-    FunctionStats stats = (FunctionStats) functionExecutionStatsMap.get(textId);
+    FunctionStats stats = functionExecutionStatsMap.get(textId);
-    public void visit(Statistics stat);
+    void visit(Statistics stat);
-    for (Iterator<ResourceEventsListener> iter = resourceListeners.iterator(); iter.hasNext();) {
+    for (ResourceEventsListener listener : resourceListeners) {
-        ResourceEventsListener listener = (ResourceEventsListener) iter.next();
-                isDurableClient = ((dca.getId() == null || dca.getId().isEmpty()) ? false : true);
+                isDurableClient = (!(dca.getId() == null || dca.getId().isEmpty()));
-    public void onDisconnect(InternalDistributedSystem sys);
+    void onDisconnect(InternalDistributedSystem sys);
-    public void reconnecting(InternalDistributedSystem oldSystem);
+    void reconnecting(InternalDistributedSystem oldSystem);
-    public void onReconnect(InternalDistributedSystem oldSystem,
-        InternalDistributedSystem newSystem);
+    void onReconnect(InternalDistributedSystem oldSystem, InternalDistributedSystem newSystem);
-    public void onShutdown(InternalDistributedSystem sys);
+    void onShutdown(InternalDistributedSystem sys);
-    if (!newDsConnected) {
-      return false;
-    }
-    return true;
+    return newDsConnected;
+          logger.warn("Caught SystemConnectException in reconnect", e);
+          logger.warn("Caught GemFireConfigException in reconnect", e);
-          if (((DistributionManager) newDM).getDMType() != DistributionManager.ADMIN_ONLY_DM_TYPE) {
+          if (newDM.getDMType() != DistributionManager.ADMIN_ONLY_DM_TYPE) {
-    public void onConnect(InternalDistributedSystem sys);
+    void onConnect(InternalDistributedSystem sys);
-  public static interface CreationStackGenerator {
+  public interface CreationStackGenerator {
-    public Throwable generateCreationStack(final DistributionConfig config);
+    Throwable generateCreationStack(final DistributionConfig config);
+  }
+
+  public void setCache(InternalCache instance) {
+    this.dm.setCache(instance);

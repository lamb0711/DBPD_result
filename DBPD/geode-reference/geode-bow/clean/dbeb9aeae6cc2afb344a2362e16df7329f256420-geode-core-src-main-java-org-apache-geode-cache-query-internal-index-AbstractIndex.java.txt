Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
-import org.apache.geode.cache.query.internal.parse.OQLLexerTokenTypes;
-import org.apache.geode.internal.offheap.StoredObject;
-import org.apache.geode.internal.offheap.annotations.Released;
- * This class implements abstract algorithms common to all indexes, such as
- * index creation, use of a path evaluator object, etc. It serves as the factory
- * for a path evaluator object and maintains the path evaluator object to use
- * for index creation and index maintenance. It also maintains a reference to
- * the root collection on which the index is created. This class also implements
- * the abstract methods to add and remove entries to an underlying storage
- * structure (e.g. a btree), and as part of this algorithm, maintains a map of
- * entries that map to null at the end of the index path, and entries that
- * cannot be traversed to the end of the index path (traversal is undefined).
+ * This class implements abstract algorithms common to all indexes, such as index creation, use of a
+ * path evaluator object, etc. It serves as the factory for a path evaluator object and maintains
+ * the path evaluator object to use for index creation and index maintenance. It also maintains a
+ * reference to the root collection on which the index is created. This class also implements the
+ * abstract methods to add and remove entries to an underlying storage structure (e.g. a btree), and
+ * as part of this algorithm, maintains a map of entries that map to null at the end of the index
+ * path, and entries that cannot be traversed to the end of the index path (traversal is undefined).
-public abstract class AbstractIndex implements IndexProtocol
-{
+public abstract class AbstractIndex implements IndexProtocol {
-  private static final AtomicIntegerFieldUpdater<RegionEntryToValuesMap> atomicUpdater =  AtomicIntegerFieldUpdater
-    .newUpdater(RegionEntryToValuesMap.class, "numValues");
+  private static final AtomicIntegerFieldUpdater<RegionEntryToValuesMap> atomicUpdater =
+      AtomicIntegerFieldUpdater.newUpdater(RegionEntryToValuesMap.class, "numValues");
-  
+
-  
+
-  //For PartitionedIndex for now
+  // For PartitionedIndex for now
-  //Flag to indicate if index map has keys as PdxString
-  //All the keys in the index map should be either Strings or PdxStrings
+  // Flag to indicate if index map has keys as PdxString
+  // All the keys in the index map should be either Strings or PdxStrings
-  
-  //Flag to indicate if the flag isIndexedPdxKeys is set
+
+  // Flag to indicate if the flag isIndexedPdxKeys is set
-  
+
-  //Flag to indicate if the index is populated with data
+  // Flag to indicate if the index is populated with data
-  AbstractIndex(String indexName, Region region, String fromClause,
-      String indexedExpression, String projectionAttributes,
-      String origFromClause, String origIndxExpr, String[] defintions, IndexStatistics stats) {
+  AbstractIndex(String indexName, Region region, String fromClause, String indexedExpression,
+      String projectionAttributes, String origFromClause, String origIndxExpr, String[] defintions,
+      IndexStatistics stats) {
-      this.internalIndexStats = (InternalIndexStatistics)stats;
+      this.internalIndexStats = (InternalIndexStatistics) stats;
-   * Must be implemented by all implementing classes
-   * iff they have any forward map for index-key->RE.
+   * Must be implemented by all implementing classes iff they have any forward map for
+   * index-key->RE.
+
-  public IndexStatistics getStatistics()
-  {
+  public IndexStatistics getStatistics() {
-  public void destroy()
-  {
+  public void destroy() {
-  long updateIndexUpdateStats()
-  {
+  long updateIndexUpdateStats() {
-  void updateIndexUpdateStats(long start)
-  {
+  void updateIndexUpdateStats(long start) {
-  
+
-  
-  long updateIndexUseStats(boolean updateStats)
-  {
+
+  long updateIndexUseStats(boolean updateStats) {
-  
-  void updateIndexUseEndStats(long start, boolean updateStats)
-  {
+
+  void updateIndexUseEndStats(long start, boolean updateStats) {
-  public IndexedExpressionEvaluator getEvaluator()
-  {
+  public IndexedExpressionEvaluator getEvaluator() {
-  public Region getRegion()
-  {
+  public Region getRegion() {
-  public String getName()
-  {
+  public String getName() {
-  throws TypeMismatchException, FunctionDomainException,
-  NameResolutionException, QueryInvocationTargetException {
+      throws TypeMismatchException, FunctionDomainException, NameResolutionException,
+      QueryInvocationTargetException {
-        PartitionedRegion pr = ((BucketRegion)region).getPartitionedRegion();
-        long start = updateIndexUseStats();
-        try {
-          for (Object b :context.getBucketList()) {
-            AbstractIndex i = PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer)b);
-            if (i == null) {
-              continue;
-            }
-            i.lockedQuery(key, operator, results, null/* No Keys to be removed */, context);
-          
+      PartitionedRegion pr = ((BucketRegion) region).getPartitionedRegion();
+      long start = updateIndexUseStats();
+      try {
+        for (Object b : context.getBucketList()) {
+          AbstractIndex i = PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer) b);
+          if (i == null) {
+            continue;
-        } finally {
-          updateIndexUseEndStats(start);
+          i.lockedQuery(key, operator, results, null/* No Keys to be removed */, context);
+
+      } finally {
+        updateIndexUseEndStats(start);
+      }
-  public void query(Object key, int operator, Collection results,
-      @Retained CompiledValue iterOp, RuntimeIterator indpndntIr,
-      ExecutionContext context, List projAttrib,
-      SelectResults intermediateResults, boolean isIntersection)
-  throws TypeMismatchException, FunctionDomainException,
-      NameResolutionException, QueryInvocationTargetException {
+  public void query(Object key, int operator, Collection results, @Retained CompiledValue iterOp,
+      RuntimeIterator indpndntIr, ExecutionContext context, List projAttrib,
+      SelectResults intermediateResults, boolean isIntersection) throws TypeMismatchException,
+      FunctionDomainException, NameResolutionException, QueryInvocationTargetException {
-    if (context.getBucketList() != null
-        && (this.region instanceof BucketRegion)) {
+    if (context.getBucketList() != null && (this.region instanceof BucketRegion)) {
-          AbstractIndex i = PartitionedIndex.getBucketIndex(pr, this.indexName,
-              (Integer) b);
+          AbstractIndex i = PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer) b);
-          i.lockedQuery(key, operator, results, iterOp, indpndntIr, context,
-              projAttrib, intermediateResults, isIntersection);
+          i.lockedQuery(key, operator, results, iterOp, indpndntIr, context, projAttrib,
+              intermediateResults, isIntersection);
-        lockedQuery(key, operator, results, iterOp, indpndntIr, context,
-            projAttrib, intermediateResults, isIntersection);
+        lockedQuery(key, operator, results, iterOp, indpndntIr, context, projAttrib,
+            intermediateResults, isIntersection);
-  
-  public void query(Object key, int operator, Collection results,
-      Set keysToRemove, ExecutionContext context) throws TypeMismatchException, FunctionDomainException,
+
+  public void query(Object key, int operator, Collection results, Set keysToRemove,
+      ExecutionContext context) throws TypeMismatchException, FunctionDomainException,
-        PartitionedRegion pr = ((BucketRegion)region).getPartitionedRegion();
-        long start = updateIndexUseStats();
-        try {
-          for (Object b :context.getBucketList()) {
-            AbstractIndex i = PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer)b);
-            if (i == null) {
-              continue;
-            }
-            i.lockedQuery(key, operator, results, keysToRemove, context);
+      PartitionedRegion pr = ((BucketRegion) region).getPartitionedRegion();
+      long start = updateIndexUseStats();
+      try {
+        for (Object b : context.getBucketList()) {
+          AbstractIndex i = PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer) b);
+          if (i == null) {
+            continue;
-        } finally {
-          updateIndexUseEndStats(start);
+          i.lockedQuery(key, operator, results, keysToRemove, context);
+      } finally {
+        updateIndexUseEndStats(start);
+      }
-  throws TypeMismatchException, FunctionDomainException,
-  NameResolutionException, QueryInvocationTargetException {
+      throws TypeMismatchException, FunctionDomainException, NameResolutionException,
+      QueryInvocationTargetException {
-        PartitionedRegion pr = ((BucketRegion)region).getPartitionedRegion();
-        for (Object b :context.getBucketList()) {
-          AbstractIndex i = PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer)b);
+        PartitionedRegion pr = ((BucketRegion) region).getPartitionedRegion();
+        for (Object b : context.getBucketList()) {
+          AbstractIndex i = PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer) b);
-            itr.hasNext() ? keysToRemove : null, context);
-        } 
+              itr.hasNext() ? keysToRemove : null, context);
+        }
-        lockedQuery(temp, OQLLexerTokenTypes.TOK_NE, results,
-            itr.hasNext() ? keysToRemove : null, context);
+        lockedQuery(temp, OQLLexerTokenTypes.TOK_NE, results, itr.hasNext() ? keysToRemove : null,
+            context);
-  public void query(Object lowerBoundKey, int lowerBoundOperator,
-      Object upperBoundKey, int upperBoundOperator, Collection results,
-      Set keysToRemove, ExecutionContext context) throws TypeMismatchException, FunctionDomainException,
-      NameResolutionException, QueryInvocationTargetException {
+  public void query(Object lowerBoundKey, int lowerBoundOperator, Object upperBoundKey,
+      int upperBoundOperator, Collection results, Set keysToRemove, ExecutionContext context)
+      throws TypeMismatchException, FunctionDomainException, NameResolutionException,
+      QueryInvocationTargetException {
-        PartitionedRegion pr = ((BucketRegion)region).getPartitionedRegion();
+        PartitionedRegion pr = ((BucketRegion) region).getPartitionedRegion();
-          for (Object b :context.getBucketList()) {
-            AbstractIndex i = PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer)b);
+          for (Object b : context.getBucketList()) {
+            AbstractIndex i = PartitionedIndex.getBucketIndex(pr, this.indexName, (Integer) b);
-            i.lockedQuery(lowerBoundKey, lowerBoundOperator, upperBoundKey,
-                upperBoundOperator, results, keysToRemove, context);
-         }
+            i.lockedQuery(lowerBoundKey, lowerBoundOperator, upperBoundKey, upperBoundOperator,
+                results, keysToRemove, context);
+          }
-        lockedQuery(lowerBoundKey, lowerBoundOperator, upperBoundKey,
-            upperBoundOperator, results, keysToRemove, context);
+        lockedQuery(lowerBoundKey, lowerBoundOperator, upperBoundKey, upperBoundOperator, results,
+            keysToRemove, context);
-  
+
-      throws TypeMismatchException, FunctionDomainException, NameResolutionException, QueryInvocationTargetException
-  {
-    Support
-        .assertionFailed(" This function should have never got invoked as its meaningful implementation is present only in RangeIndex class");
+      throws TypeMismatchException, FunctionDomainException, NameResolutionException,
+      QueryInvocationTargetException {
+    Support.assertionFailed(
+        " This function should have never got invoked as its meaningful implementation is present only in RangeIndex class");
-   * @return the projectionAttributes, or "*" if there were none specified at
-   *         index creation.
+   * @return the projectionAttributes, or "*" if there were none specified at index creation.
-  public String getProjectionAttributes()
-  {
+  public String getProjectionAttributes() {
-   * @return the projectionAttributes, or "*" if there were none specified at
-   *         index creation.
+   * @return the projectionAttributes, or "*" if there were none specified at index creation.
-  public String getCanonicalizedProjectionAttributes()
-  {
+  public String getCanonicalizedProjectionAttributes() {
-  public String getIndexedExpression()
-  {
+  public String getIndexedExpression() {
-  public String getCanonicalizedIndexedExpression()
-  {
+  public String getCanonicalizedIndexedExpression() {
-  public String getFromClause()
-  {
+  public String getFromClause() {
-  public String getCanonicalizedFromClause()
-  {
+  public String getCanonicalizedFromClause() {
-  public boolean isMapType()
-  {
+  public boolean isMapType() {
-  public boolean addIndexMapping(RegionEntry entry) throws IMQException
-  {
+  public boolean addIndexMapping(RegionEntry entry) throws IMQException {
-  public boolean addAllIndexMappings(Collection c) throws IMQException
-  {
+  public boolean addAllIndexMappings(Collection c) throws IMQException {
-      this.addMapping((RegionEntry)iterator.next());
+      this.addMapping((RegionEntry) iterator.next());
-   * @param opCode
-   *          one of OTHER_OP, BEFORE_UPDATE_OP, AFTER_UPDATE_OP.
+   * @param opCode one of OTHER_OP, BEFORE_UPDATE_OP, AFTER_UPDATE_OP.
-  public boolean removeIndexMapping(RegionEntry entry, int opCode)
-      throws IMQException
-  {
+  public boolean removeIndexMapping(RegionEntry entry, int opCode) throws IMQException {
-  public boolean removeAllIndexMappings(Collection c) throws IMQException
-  {
+  public boolean removeAllIndexMappings(Collection c) throws IMQException {
-      removeMapping((RegionEntry)iterator.next(), OTHER_OP);
+      removeMapping((RegionEntry) iterator.next(), OTHER_OP);
-  public boolean isValid()
-  {
+  public boolean isValid() {
-  public void markValid(boolean b)
-  {
+  public void markValid(boolean b) {
-  public boolean isMatchingWithIndexExpression(CompiledValue indexExpr,
-      String conditionExprStr, ExecutionContext context)
-      throws AmbiguousNameException, TypeMismatchException,
-      NameResolutionException
-  {
+  public boolean isMatchingWithIndexExpression(CompiledValue indexExpr, String conditionExprStr,
+      ExecutionContext context)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-      if (((StructImpl)value).isHasPdx() && !((GemFireCacheImpl)
-          this.region.getCache()).getPdxReadSerializedByAnyGemFireServices()) {
+      if (((StructImpl) value).isHasPdx() && !((GemFireCacheImpl) this.region.getCache())
+          .getPdxReadSerializedByAnyGemFireServices()) {
-        StructImpl v = (StructImpl)value;
+        StructImpl v = (StructImpl) value;
-        return new StructImpl((StructTypeImpl)v.getStructType(), fieldValues);
+        return new StructImpl((StructTypeImpl) v.getStructType(), fieldValues);
-    } else if (value instanceof PdxInstance && !((GemFireCacheImpl) 
-        this.region.getCache()).getPdxReadSerializedByAnyGemFireServices()) {
-      return ((PdxInstance)value).getObject();
+    } else if (value instanceof PdxInstance && !((GemFireCacheImpl) this.region.getCache())
+        .getPdxReadSerializedByAnyGemFireServices()) {
+      return ((PdxInstance) value).getObject();
-      SelectResults intermediateResults, boolean isIntersection, Object value)
-  {
+      SelectResults intermediateResults, boolean isIntersection, Object value) {
-    
+
-    }
-    else {
+    } else {
-      }
-      else {
+      } else {
-      SelectResults intermediateResults, boolean isIntersection, Object[] values)
-  {
-    for (int i=0; i < values.length; i++) {
+      SelectResults intermediateResults, boolean isIntersection, Object[] values) {
+    for (int i = 0; i < values.length; i++) {
-    
+
-      if( results instanceof StructFields) {
-        ((StructFields)results).addFieldValues(values);
-      }else {
-        //The results could be LinkedStructSet or SortedResultsBag or StructSet
-        //LinkedStructSet lss = (LinkedStructSet)results;
-        SelectResults sr = (SelectResults)results;
-        StructImpl structImpl = new StructImpl( (StructTypeImpl)sr.getCollectionType().getElementType(), values);
-        //lss.add(structImpl);
+      if (results instanceof StructFields) {
+        ((StructFields) results).addFieldValues(values);
+      } else {
+        // The results could be LinkedStructSet or SortedResultsBag or StructSet
+        // LinkedStructSet lss = (LinkedStructSet)results;
+        SelectResults sr = (SelectResults) results;
+        StructImpl structImpl =
+            new StructImpl((StructTypeImpl) sr.getCollectionType().getElementType(), values);
+        // lss.add(structImpl);
-    }
-    else {
+    } else {
-        if(results instanceof StructFields) {
+        if (results instanceof StructFields) {
-            ((StructFields)results).addFieldValues(values);
-            ((StructFields)intermediateResults).removeFieldValues(values);
+            ((StructFields) results).addFieldValues(values);
+            ((StructFields) intermediateResults).removeFieldValues(values);
-        }else {
-          //LinkedStructSet lss = (LinkedStructSet)results;
+        } else {
+          // LinkedStructSet lss = (LinkedStructSet)results;
-          SelectResults sr = (SelectResults)results;
-          StructImpl structImpl = new StructImpl( (StructTypeImpl)sr.getCollectionType().getElementType(), values);
-          if( intermediateResults.remove(structImpl)) {
+          SelectResults sr = (SelectResults) results;
+          StructImpl structImpl =
+              new StructImpl((StructTypeImpl) sr.getCollectionType().getElementType(), values);
+          if (intermediateResults.remove(structImpl)) {
-          }          
+          }
-      }
-      else {
-        if( results instanceof StructFields) {
-          ((StructFields)results).addFieldValues(values);
-        }else {
+      } else {
+        if (results instanceof StructFields) {
+          ((StructFields) results).addFieldValues(values);
+        } else {
-          SelectResults sr = (SelectResults)results;
-          //LinkedStructSet lss = (LinkedStructSet)results;
-          StructImpl structImpl = new StructImpl( (StructTypeImpl)sr.getCollectionType().getElementType(), values);
-          if( ((SelectResults)intermediateResults).remove(structImpl)) {
+          SelectResults sr = (SelectResults) results;
+          // LinkedStructSet lss = (LinkedStructSet)results;
+          StructImpl structImpl =
+              new StructImpl((StructTypeImpl) sr.getCollectionType().getElementType(), values);
+          if (((SelectResults) intermediateResults).remove(structImpl)) {
-  void applyProjection(List projAttrib, ExecutionContext context,
-      Collection result, Object iterValue, SelectResults intermediateResults,
-      boolean isIntersection) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException
-  {
+  void applyProjection(List projAttrib, ExecutionContext context, Collection result,
+      Object iterValue, SelectResults intermediateResults, boolean isIntersection)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-      this.addToResultsWithUnionOrIntersection(result, intermediateResults,
-          isIntersection, iterValue);
-    }
-    else {
-      //TODO : Asif : Optimize this . This condition looks ugly.
-     /* if (result instanceof StructBag || result instanceof LinkedStructSet
-          || result instanceof LinkedStructBag) {*/
-      boolean isStruct = result instanceof SelectResults 
-          && ((SelectResults)result).getCollectionType().getElementType() != null
-          && ((SelectResults)result).getCollectionType().getElementType().isStructType();
+      this.addToResultsWithUnionOrIntersection(result, intermediateResults, isIntersection,
+          iterValue);
+    } else {
+      // TODO : Asif : Optimize this . This condition looks ugly.
+      /*
+       * if (result instanceof StructBag || result instanceof LinkedStructSet || result instanceof
+       * LinkedStructBag) {
+       */
+      boolean isStruct = result instanceof SelectResults
+          && ((SelectResults) result).getCollectionType().getElementType() != null
+          && ((SelectResults) result).getCollectionType().getElementType().isStructType();
-          Object projDef[] = (Object[])projIter.next();
-          values[i] = deserializePdxForLocalDistinctQuery(context, ((CompiledValue)projDef[1]).evaluate(context));
+          Object projDef[] = (Object[]) projIter.next();
+          values[i] = deserializePdxForLocalDistinctQuery(context,
+              ((CompiledValue) projDef[1]).evaluate(context));
-        this.addToStructsWithUnionOrIntersection(result, intermediateResults,
-            isIntersection, values);
-      }
-      else {
-        Object[] temp = (Object[])projAttrib.get(0);
-        Object val = deserializePdxForLocalDistinctQuery(context, ((CompiledValue)temp[1]).evaluate(context));
-        this.addToResultsWithUnionOrIntersection(result,
-            intermediateResults, isIntersection, val);
+        this.addToStructsWithUnionOrIntersection(result, intermediateResults, isIntersection,
+            values);
+      } else {
+        Object[] temp = (Object[]) projAttrib.get(0);
+        Object val = deserializePdxForLocalDistinctQuery(context,
+            ((CompiledValue) temp[1]).evaluate(context));
+        this.addToResultsWithUnionOrIntersection(result, intermediateResults, isIntersection, val);
-  // We still have to honor the cache level readserialized flag in 
+  // We still have to honor the cache level readserialized flag in
-  private Object deserializePdxForLocalDistinctQuery(ExecutionContext context,
-      Object val) throws QueryInvocationTargetException {
+  private Object deserializePdxForLocalDistinctQuery(ExecutionContext context, Object val)
+      throws QueryInvocationTargetException {
-  
+
-      SelectResults intermediateResults, boolean isIntersection, Object value)
-  {
+      SelectResults intermediateResults, boolean isIntersection, Object value) {
-    }
-    else {
+    } else {
-        int numOcc = ((SelectResults)results).occurrences(value);
+        int numOcc = ((SelectResults) results).occurrences(value);
-      }
-      else {
+      } else {
-      SelectResults intermediateResults, boolean isIntersection,
-      Object values[], ExecutionContext context)
-  {
-    if (intermediateResults == null) {      
-        ((StructFields)results).removeFieldValues(values);      
-    }
-    else {
+      SelectResults intermediateResults, boolean isIntersection, Object values[],
+      ExecutionContext context) {
+    if (intermediateResults == null) {
+      ((StructFields) results).removeFieldValues(values);
+    } else {
-        int numOcc = ((SelectResults)results).occurrences(values);
+        int numOcc = ((SelectResults) results).occurrences(values);
-            ((StructFields)results).removeFieldValues(values);
-            ((StructFields)intermediateResults).addFieldValues(values);
-          
+          ((StructFields) results).removeFieldValues(values);
+          ((StructFields) intermediateResults).addFieldValues(values);
+
-      }
-      else {        
-        ((StructFields)results).removeFieldValues(values);        
+      } else {
+        ((StructFields) results).removeFieldValues(values);
-  void removeProjection(List projAttrib, ExecutionContext context,
-      Collection result, Object iterValue, SelectResults intermediateResults,
-      boolean isIntersection) throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
-      QueryInvocationTargetException
-  {
+  void removeProjection(List projAttrib, ExecutionContext context, Collection result,
+      Object iterValue, SelectResults intermediateResults, boolean isIntersection)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-      this.removeFromResultsWithUnionOrIntersection(result,
-          intermediateResults, isIntersection, iterValue);
-    }
-    else {
+      this.removeFromResultsWithUnionOrIntersection(result, intermediateResults, isIntersection,
+          iterValue);
+    } else {
-          Object projDef[] = (Object[])projIter.next();
-          values[i++] = ((CompiledValue)projDef[1]).evaluate(context);
+          Object projDef[] = (Object[]) projIter.next();
+          values[i++] = ((CompiledValue) projDef[1]).evaluate(context);
-        this.removeFromStructsWithUnionOrIntersection(result,
-            intermediateResults, isIntersection, values, context);
-      }
-      else {
-        Object[] temp = (Object[])projAttrib.get(0);
-        Object val = ((CompiledValue)temp[1]).evaluate(context);
-        this.removeFromResultsWithUnionOrIntersection(result,
-            intermediateResults, isIntersection, val);
+        this.removeFromStructsWithUnionOrIntersection(result, intermediateResults, isIntersection,
+            values, context);
+      } else {
+        Object[] temp = (Object[]) projAttrib.get(0);
+        Object val = ((CompiledValue) temp[1]).evaluate(context);
+        this.removeFromResultsWithUnionOrIntersection(result, intermediateResults, isIntersection,
+            val);
-   * This function returns the canonicalized defintions of the from clauses used
-   * in Index creation TODO:Asif :How to make it final so that it is immutable
+   * This function returns the canonicalized defintions of the from clauses used in Index creation
+   * TODO:Asif :How to make it final so that it is immutable
-  public String[] getCanonicalizedIteratorDefinitions()
-  {
+  public String[] getCanonicalizedIteratorDefinitions() {
-  public boolean containsEntry(RegionEntry entry)
-  {
+  public boolean containsEntry(RegionEntry entry) {
-  void instantiateEvaluator(IndexCreationHelper ich)
-  {
-  }
+  void instantiateEvaluator(IndexCreationHelper ich) {}
-  public void initializeIndex(boolean loadEntries) throws IMQException
-  {
-  }
-  
-  
+  public void initializeIndex(boolean loadEntries) throws IMQException {}
+
+
-  public String toString()
-  {
+  public String toString() {
-  
+
-  abstract void removeMapping(RegionEntry entry, int opCode)
-      throws IMQException;
+  abstract void removeMapping(RegionEntry entry, int opCode) throws IMQException;
-  abstract void addMapping(Object key, Object value, RegionEntry entry)
-      throws IMQException;
+  abstract void addMapping(Object key, Object value, RegionEntry entry) throws IMQException;
-   * Shobhit: This is used to buffer the index entries evaluated from a
-   * RegionEntry which is getting updated at present. These buffered index
-   * entries are replaced into the index later all together to avoid
-   * remove-add sequence.
+   * Shobhit: This is used to buffer the index entries evaluated from a RegionEntry which is getting
+   * updated at present. These buffered index entries are replaced into the index later all together
+   * to avoid remove-add sequence.
+   * 
-  abstract void saveMapping(Object key, Object value, RegionEntry entry)
-  throws IMQException;
+  abstract void saveMapping(Object key, Object value, RegionEntry entry) throws IMQException;
-  abstract void lockedQuery(Object key, int operator, Collection results,
-      CompiledValue iterOps, RuntimeIterator indpndntItr,
-      ExecutionContext context, List projAttrib,
-      SelectResults intermediateResults, boolean isIntersection)
-      throws TypeMismatchException, FunctionDomainException,
+  abstract void lockedQuery(Object key, int operator, Collection results, CompiledValue iterOps,
+      RuntimeIterator indpndntItr, ExecutionContext context, List projAttrib,
+      SelectResults intermediateResults, boolean isIntersection) throws TypeMismatchException,
+      FunctionDomainException, NameResolutionException, QueryInvocationTargetException;
+
+  abstract void lockedQuery(Object lowerBoundKey, int lowerBoundOperator, Object upperBoundKey,
+      int upperBoundOperator, Collection results, Set keysToRemove, ExecutionContext context)
+      throws TypeMismatchException, FunctionDomainException, NameResolutionException,
+      QueryInvocationTargetException;
+
+  abstract void lockedQuery(Object key, int operator, Collection results, Set keysToRemove,
+      ExecutionContext context) throws TypeMismatchException, FunctionDomainException,
-  abstract void lockedQuery(Object lowerBoundKey, int lowerBoundOperator,
-      Object upperBoundKey, int upperBoundOperator, Collection results,
-      Set keysToRemove, ExecutionContext context) throws TypeMismatchException, FunctionDomainException,
-      NameResolutionException, QueryInvocationTargetException;
-
-  abstract void lockedQuery(Object key, int operator, Collection results,
-      Set keysToRemove, ExecutionContext context) throws TypeMismatchException, FunctionDomainException,
-      NameResolutionException, QueryInvocationTargetException;
-  
-  protected static abstract class InternalIndexStatistics implements
-      IndexStatistics
-  {
-    public long getNumUpdates()
-    {
+  protected static abstract class InternalIndexStatistics implements IndexStatistics {
+    public long getNumUpdates() {
-    public long getTotalUpdateTime()
-    {
+    public long getTotalUpdateTime() {
-    public long getTotalUses()
-    {
+    public long getTotalUses() {
-    public long getNumberOfKeys()
-    {
+    public long getNumberOfKeys() {
-    public long getNumberOfValues()
-    {
+    public long getNumberOfValues() {
-    public long getNumberOfValues(Object key)
-    {
+    public long getNumberOfValues(Object key) {
-    
+
-   
+
-    
+
-    public int getNumberOfBucketIndexes(){
+    public int getNumberOfBucketIndexes() {
-    
-    public void close()
-    {
-    }
-    public void incNumValues(int delta)
-    {
-    }
+    public void close() {}
-    public void incNumUpdates()
-    {
-    }
+    public void incNumValues(int delta) {}
-    public void incNumUpdates(int delta)
-    {
-    }
+    public void incNumUpdates() {}
-    public void incUpdatesInProgress(int delta)
-    {
-    }
+    public void incNumUpdates(int delta) {}
-    public void incUsesInProgress(int delta)
-    {
-    }
+    public void incUpdatesInProgress(int delta) {}
-    public void updateNumKeys(long count)
-    {
-    }
+    public void incUsesInProgress(int delta) {}
-    public void incNumKeys(long count)
-    {
-    }
+    public void updateNumKeys(long count) {}
-    public void incNumMapIndexKeys(long numKeys) {
-    }
+    public void incNumKeys(long count) {}
-    public void incUpdateTime(long delta)
-    {
-    }
+    public void incNumMapIndexKeys(long numKeys) {}
-    public void incNumUses()
-    {
-    }
+    public void incUpdateTime(long delta) {}
-    public void incUseTime(long delta)
-    {
-    }
+    public void incNumUses() {}
-    public void incReadLockCount(int delta) 
-    {
-    }
-    
-    public void incNumBucketIndexes(int delta) 
-    {
-    }
+    public void incUseTime(long delta) {}
+
+    public void incReadLockCount(int delta) {}
+
+    public void incNumBucketIndexes(int delta) {}
-  class IMQEvaluator implements IndexedExpressionEvaluator
-  {
+  class IMQEvaluator implements IndexedExpressionEvaluator {
-     * Asif : The boolean if true indicates that the 0th iterator is on entries
-     * . If the 0th iterator is on collection of Region.Entry objects, then the
-     * RegionEntry object used in Index data objects is obtained directly from
-     * its corresponding Region.Entry object. However if the 0th iterator is not
-     * on entries then the boolean is false. In this case the additional
-     * projection attribute gives us the original value of the iterator while
-     * the Region.Entry object is obtained from 0th iterator. It is possible to
-     * have index being created on a Region Entry itself , instead of a Region.
-     * A Map operator( Compiled Index Operator) used with Region enables, us to
-     * create such indexes. In such case the 0th iterator, even if it represents
-     * a collection of Objects which are not Region.Entry objects, still the
-     * boolean remains true, as the Entry object can be easily obtained from the
-     * 0th iterator. In this case, the additional projection attribute s not
-     * null as it is used to evaluate the Entry object from the 0th iterator.
+     * Asif : The boolean if true indicates that the 0th iterator is on entries . If the 0th
+     * iterator is on collection of Region.Entry objects, then the RegionEntry object used in Index
+     * data objects is obtained directly from its corresponding Region.Entry object. However if the
+     * 0th iterator is not on entries then the boolean is false. In this case the additional
+     * projection attribute gives us the original value of the iterator while the Region.Entry
+     * object is obtained from 0th iterator. It is possible to have index being created on a Region
+     * Entry itself , instead of a Region. A Map operator( Compiled Index Operator) used with Region
+     * enables, us to create such indexes. In such case the 0th iterator, even if it represents a
+     * collection of Objects which are not Region.Entry objects, still the boolean remains true, as
+     * the Entry object can be easily obtained from the 0th iterator. In this case, the additional
+     * projection attribute s not null as it is used to evaluate the Entry object from the 0th
+     * iterator.
-    //Shobhit: The boolean if true indicates that the 0th iterator is on keys.
+    // Shobhit: The boolean if true indicates that the 0th iterator is on keys.
-      this.rgn  = helper.getRegion();
+      this.rgn = helper.getRegion();
-      isFirstItrOnEntry = ((FunctionalIndexCreationHelper)helper).isFirstIteratorRegionEntry;
-      isFirstItrOnKey = ((FunctionalIndexCreationHelper)helper).isFirstIteratorRegionKey;
-      additionalProj = ((FunctionalIndexCreationHelper)helper).additionalProj;
-      Object params1[] = { new QRegion(rgn, false) };
+      isFirstItrOnEntry = ((FunctionalIndexCreationHelper) helper).isFirstIteratorRegionEntry;
+      isFirstItrOnKey = ((FunctionalIndexCreationHelper) helper).isFirstIteratorRegionKey;
+      additionalProj = ((FunctionalIndexCreationHelper) helper).additionalProj;
+      Object params1[] = {new QRegion(rgn, false)};
-      this.canonicalIterNames = ((FunctionalIndexCreationHelper)helper).canonicalizedIteratorNames;
+      this.canonicalIterNames = ((FunctionalIndexCreationHelper) helper).canonicalizedIteratorNames;
-      }
-      else {
-        this.indexInitIterators = ((FunctionalIndexCreationHelper)helper).indexInitIterators;
-        modifiedIndexExpr = ((FunctionalIndexCreationHelper)helper).modifiedIndexExpr;
-        addnlProjType = ((FunctionalIndexCreationHelper)helper).addnlProjType;
+      } else {
+        this.indexInitIterators = ((FunctionalIndexCreationHelper) helper).indexInitIterators;
+        modifiedIndexExpr = ((FunctionalIndexCreationHelper) helper).modifiedIndexExpr;
+        addnlProjType = ((FunctionalIndexCreationHelper) helper).addnlProjType;
-    public String getIndexedExpression()
-    {
+    public String getIndexedExpression() {
-    public String getProjectionAttributes()
-    {
+    public String getProjectionAttributes() {
-    public String getFromClause()
-    {
+    public String getFromClause() {
-    
-    public void expansion(List expandedResults, Object lowerBoundKey, Object upperBoundKey, int lowerBoundOperator, int upperBoundOperator, Object value) throws IMQException {
-      //no-op
+
+    public void expansion(List expandedResults, Object lowerBoundKey, Object upperBoundKey,
+        int lowerBoundOperator, int upperBoundOperator, Object value) throws IMQException {
+      // no-op
-    public void evaluate(RegionEntry target, boolean add) throws IMQException
-    {
+    public void evaluate(RegionEntry target, boolean add) throws IMQException {
-      Object params[] = { dQRegion };
+      Object params[] = {dQRegion};
-        
+
-        
-        Support
-            .Assert(
-                this.indexResultSetType != null,
-                "IMQEvaluator::evaluate:The StrcutType should have been initialized during index creation");
+
+        Support.Assert(this.indexResultSetType != null,
+            "IMQEvaluator::evaluate:The StrcutType should have been initialized during index creation");
-      }
-      catch (IMQException imqe) {
+      } catch (IMQException imqe) {
-      }
-      catch (Exception e) {
+      } catch (Exception e) {
-      }
-      finally {
+      } finally {
-    public void initializeIndex(boolean loadEntries) throws IMQException
-    {
+    public void initializeIndex(boolean loadEntries) throws IMQException {
-          CompiledIteratorDef iterDef = (CompiledIteratorDef)this.indexInitIterators.get(i);
+          CompiledIteratorDef iterDef = (CompiledIteratorDef) this.indexInitIterators.get(i);
-        if(loadEntries) {
-          doNestedIterationsForIndexInit(0, this.initContext
-            .getCurrentIterators());
+        if (loadEntries) {
+          doNestedIterationsForIndexInit(0, this.initContext.getCurrentIterators());
-      }
-      catch (IMQException imqe) {
+      } catch (IMQException imqe) {
-      }
-      catch (Exception e) {
+      } catch (Exception e) {
-      }
-      finally {
+      } finally {
-        throws TypeMismatchException, AmbiguousNameException,
-        FunctionDomainException, NameResolutionException,
-        QueryInvocationTargetException, IMQException
-    {
+        throws TypeMismatchException, AmbiguousNameException, FunctionDomainException,
+        NameResolutionException, QueryInvocationTargetException, IMQException {
-      }
-      else {
-        RuntimeIterator rIter = (RuntimeIterator)runtimeIterators.get(level);
+      } else {
+        RuntimeIterator rIter = (RuntimeIterator) runtimeIterators.get(level);
-     * Asif : This function is used to obtain Indxe data at the time of index
-     * creation. Each element of the List is an Object Array of size 3. The 0th
-     * element of Object Array stores the value of Index Expression. The 1st
-     * element of ObjectArray contains the RegionEntry object ( If the booelan
-     * isFirstItrOnEntry is false, then the 0th iterator will give us the
-     * Region.Entry object which can be used to obtain the underlying
-     * RegionEntry object. If the boolean is true & additional projection
-     * attribute is not null, then the Region.Entry object can be obtained by
-     * evaluating the additional projection attribute. If the boolean
-     * isFirstItrOnEntry is tru e& additional projection attribute is null, then
-     * teh 0th iterator itself will evaluate to Region.Entry Object.
+     * Asif : This function is used to obtain Indxe data at the time of index creation. Each element
+     * of the List is an Object Array of size 3. The 0th element of Object Array stores the value of
+     * Index Expression. The 1st element of ObjectArray contains the RegionEntry object ( If the
+     * booelan isFirstItrOnEntry is false, then the 0th iterator will give us the Region.Entry
+     * object which can be used to obtain the underlying RegionEntry object. If the boolean is true
+     * & additional projection attribute is not null, then the Region.Entry object can be obtained
+     * by evaluating the additional projection attribute. If the boolean isFirstItrOnEntry is tru e&
+     * additional projection attribute is null, then teh 0th iterator itself will evaluate to
+     * Region.Entry Object.
-     * The 2nd element of Object Array contains the Struct object ( tuple)
-     * created. If the boolean isFirstItrOnEntry is false, then the first
-     * attribute of the Struct object is obtained by evaluating the additional
-     * projection attribute.
+     * The 2nd element of Object Array contains the Struct object ( tuple) created. If the boolean
+     * isFirstItrOnEntry is false, then the first attribute of the Struct object is obtained by
+     * evaluating the additional projection attribute.
-        throws FunctionDomainException, TypeMismatchException,
-        NameResolutionException, QueryInvocationTargetException, IMQException
-    {
+        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+        QueryInvocationTargetException, IMQException {
-        throw new IMQException(LocalizedStrings.IndexCreationMsg_CANCELED_DUE_TO_LOW_MEMORY.toLocalizedString());
+        throw new IMQException(
+            LocalizedStrings.IndexCreationMsg_CANCELED_DUE_TO_LOW_MEMORY.toLocalizedString());
-      
+
-      //Evaluate NonTXEntry for index on entries or additional projections
-      //on Entry or just entry value.
+      // Evaluate NonTXEntry for index on entries or additional projections
+      // on Entry or just entry value.
-        temp = (LocalRegion.NonTXEntry)additionalProj
-            .evaluate(this.initContext);
-      }
-      else {
-        temp = (LocalRegion.NonTXEntry)(((RuntimeIterator)currrentRuntimeIters
-            .get(0)).evaluate(this.initContext));
+        temp = (LocalRegion.NonTXEntry) additionalProj.evaluate(this.initContext);
+      } else {
+        temp = (LocalRegion.NonTXEntry) (((RuntimeIterator) currrentRuntimeIters.get(0))
+            .evaluate(this.initContext));
-        indxResultSet = this.isFirstItrOnEntry ? ((this.additionalProj == null) ? temp
-            : ((RuntimeIterator)currrentRuntimeIters.get(0))
-                .evaluate(this.initContext))
+        indxResultSet = this.isFirstItrOnEntry
+            ? ((this.additionalProj == null) ? temp
+                : ((RuntimeIterator) currrentRuntimeIters.get(0)).evaluate(this.initContext))
-      }
-      else {
+      } else {
-          RuntimeIterator iter = (RuntimeIterator)currrentRuntimeIters.get(i);
+          RuntimeIterator iter = (RuntimeIterator) currrentRuntimeIters.get(i);
-        Support
-            .Assert(
-                this.indexResultSetType instanceof StructTypeImpl,
-                "The Index ResultType should have been an instance of StructTypeImpl rather than ObjectTypeImpl. The indxeResultType is "
-                    + this.indexResultSetType);
-        indxResultSet = new StructImpl(
-            (StructTypeImpl)this.indexResultSetType, tuple);
+        Support.Assert(this.indexResultSetType instanceof StructTypeImpl,
+            "The Index ResultType should have been an instance of StructTypeImpl rather than ObjectTypeImpl. The indxeResultType is "
+                + this.indexResultSetType);
+        indxResultSet = new StructImpl((StructTypeImpl) this.indexResultSetType, tuple);
-      //Key must be evaluated after indexResultSet evaluation is done as Entry might be getting destroyed
-      //and so if value is UNDEFINED, key will definitely will be UNDEFINED.
-      Object indexKey = this.isFirstItrOnEntry ? this.indexedExpr
-          .evaluate(this.initContext) : modifiedIndexExpr
-          .evaluate(this.initContext);
-      //based on the first key convert the rest to PdxString or String
-      if(!isIndexedPdxKeysFlagSet){
+      // Key must be evaluated after indexResultSet evaluation is done as Entry might be getting
+      // destroyed
+      // and so if value is UNDEFINED, key will definitely will be UNDEFINED.
+      Object indexKey = this.isFirstItrOnEntry ? this.indexedExpr.evaluate(this.initContext)
+          : modifiedIndexExpr.evaluate(this.initContext);
+      // based on the first key convert the rest to PdxString or String
+      if (!isIndexedPdxKeysFlagSet) {
-    private void doNestedIterations(int level, ExecutionContext context) throws TypeMismatchException,
-        AmbiguousNameException, FunctionDomainException,
-        NameResolutionException, QueryInvocationTargetException, IMQException
-    {
+    private void doNestedIterations(int level, ExecutionContext context)
+        throws TypeMismatchException, AmbiguousNameException, FunctionDomainException,
+        NameResolutionException, QueryInvocationTargetException, IMQException {
-      }
-      else {
-        RuntimeIterator rIter = (RuntimeIterator)iterList.get(level);
+      } else {
+        RuntimeIterator rIter = (RuntimeIterator) iterList.get(level);
-    private void applyProjection(ExecutionContext context) throws FunctionDomainException,
-        TypeMismatchException, NameResolutionException,
-        QueryInvocationTargetException, IMQException
-    {
+    private void applyProjection(ExecutionContext context)
+        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+        QueryInvocationTargetException, IMQException {
-      //based on the first key convert the rest to PdxString or String
-      if(!isIndexedPdxKeysFlagSet){
+      // based on the first key convert the rest to PdxString or String
+      if (!isIndexedPdxKeysFlagSet) {
-        RuntimeIterator iter = (RuntimeIterator)currrentRuntimeIters.get(0);
+        RuntimeIterator iter = (RuntimeIterator) currrentRuntimeIters.get(0);
-      }
-      else {
+      } else {
-          RuntimeIterator iter = (RuntimeIterator)currrentRuntimeIters.get(i);
+          RuntimeIterator iter = (RuntimeIterator) currrentRuntimeIters.get(i);
-        Support
-            .Assert(
-                this.indexResultSetType instanceof StructTypeImpl,
-                "The Index ResultType should have been an instance of StructTypeImpl rather than ObjectTypeImpl. The indxeResultType is "
-                    + this.indexResultSetType);
-        indxResultSet = new StructImpl(
-            (StructTypeImpl)this.indexResultSetType, tuple);
+        Support.Assert(this.indexResultSetType instanceof StructTypeImpl,
+            "The Index ResultType should have been an instance of StructTypeImpl rather than ObjectTypeImpl. The indxeResultType is "
+                + this.indexResultSetType);
+        indxResultSet = new StructImpl((StructTypeImpl) this.indexResultSetType, tuple);
-      //Keep Entry value in fly untill all keys are evaluated
+      // Keep Entry value in fly untill all keys are evaluated
-    private ObjectType createIndexResultSetType()
-    {
+    private ObjectType createIndexResultSetType() {
-        RuntimeIterator iter = (RuntimeIterator)currentIterators.get(start);
+        RuntimeIterator iter = (RuntimeIterator) currentIterators.get(start);
-      type = (len == 1) ? fieldTypes[0] : new StructTypeImpl(
-          this.canonicalIterNames, fieldTypes);
+      type = (len == 1) ? fieldTypes[0] : new StructTypeImpl(this.canonicalIterNames, fieldTypes);
-    private void printList(List list)
-    {
+    private void printList(List list) {
-        Object arr[] = (Object[])list.get(i);
+        Object arr[] = (Object[]) list.get(i);
-    int getTotalEntriesUpdated()
-    {
+    int getTotalEntriesUpdated() {
-    public ObjectType getIndexResultSetType()
-    {
+    public ObjectType getIndexResultSetType() {
-   * Checks the limit for the resultset for distinct and non-distinct
-   * queries separately. In case of non-distinct distinct elements size
-   * of result-set is matched against limit passed in as an argument.
+   * Checks the limit for the resultset for distinct and non-distinct queries separately. In case of
+   * non-distinct distinct elements size of result-set is matched against limit passed in as an
+   * argument.
-  protected boolean verifyLimit(Collection result, int limit,
-      ExecutionContext context) {
+  protected boolean verifyLimit(Collection result, int limit, ExecutionContext context) {
-     /* if (!context.isDistinct()) {
-        return ((Bag)result).size() == limit;
-      } else if (result.size() == limit) {
-        return true;
-      }*/
+      /*
+       * if (!context.isDistinct()) { return ((Bag)result).size() == limit; } else if (result.size()
+       * == limit) { return true; }
+       */
-  
+
-   * This will verify the consistency between RegionEntry and IndexEntry.
-   * RangeIndex has following entry structure,
+   * This will verify the consistency between RegionEntry and IndexEntry. RangeIndex has following
+   * entry structure,
-   *  IndexKey --> [RegionEntry, [Iterator1, Iterator2....., IteratorN]]
+   * IndexKey --> [RegionEntry, [Iterator1, Iterator2....., IteratorN]]
-   * For example: "/portfolio p, p.positions.values pos" from clause has two
-   * iterators where p is independent iterator and pos is dependent iterator.
+   * For example: "/portfolio p, p.positions.values pos" from clause has two iterators where p is
+   * independent iterator and pos is dependent iterator.
-   * Query iterators can be a subset, superset or exact match of index iterators.
-   * But we take query iterators which are matching with index iterators to evaluate
-   * RegionEntry for new value and compare it with index value which could be
-   * a plain object or a Struct. 
+   * Query iterators can be a subset, superset or exact match of index iterators. But we take query
+   * iterators which are matching with index iterators to evaluate RegionEntry for new value and
+   * compare it with index value which could be a plain object or a Struct.
-   * Note: Struct evaluated from RegionEntry can NOT have more field values than
-   * Index Value Struct as we filter out iterators in query context before evaluating
-   * Struct from RegionEntry.
+   * Note: Struct evaluated from RegionEntry can NOT have more field values than Index Value Struct
+   * as we filter out iterators in query context before evaluating Struct from RegionEntry.
+   * 
-   * @param context 
+   * @param context
-  protected boolean verifyEntryAndIndexVaue(RegionEntry re, Object value, ExecutionContext context) {
-    IMQEvaluator evaluator = (IMQEvaluator)getEvaluator();
+  protected boolean verifyEntryAndIndexVaue(RegionEntry re, Object value,
+      ExecutionContext context) {
+    IMQEvaluator evaluator = (IMQEvaluator) getEvaluator();
-      } else{
+      } else {
-          val = ((CachedDeserializable)val).getDeserializedValue(getRegion(), re);
+          val = ((CachedDeserializable) val).getDeserializedValue(getRegion(), re);
-        val = verifyAndGetPdxDomainObject(val);   
+        val = verifyAndGetPdxDomainObject(val);
-        logger.debug("Exception occured while verifying a Region Entry value during a Query when the Region Entry is under update operation", e);
+        logger.debug(
+            "Exception occured while verifying a Region Entry value during a Query when the Region Entry is under update operation",
+            e);
-   * This method compares two objects in which one could be StructType and
-   * other ObjectType.
-   * Fur conditions are possible,
-   * Object1 -> Struct  Object2-> Struct
-   * Object1 -> Struct  Object2-> Object
-   * Object1 -> Object  Object2-> Struct
-   * Object1 -> Object  Object2-> Object
+   * This method compares two objects in which one could be StructType and other ObjectType. Fur
+   * conditions are possible, Object1 -> Struct Object2-> Struct Object1 -> Struct Object2-> Object
+   * Object1 -> Object Object2-> Struct Object1 -> Object Object2-> Object
-   * @return true if valueInRegion's all objects are part of valueInIndex. 
+   * @return true if valueInRegion's all objects are part of valueInIndex.
-  private boolean compareStructWithNonStruct(Object valueInRegion,
-      Object valueInIndex) {
+  private boolean compareStructWithNonStruct(Object valueInRegion, Object valueInIndex) {
-   * Returns evaluated collection for dependent runtime iterator for this index
-   * from clause and given RegionEntry.
+   * Returns evaluated collection for dependent runtime iterator for this index from clause and
+   * given RegionEntry.
-   * @throws QueryInvocationTargetException 
-   * @throws NameResolutionException 
-   * @throws TypeMismatchException 
-   * @throws FunctionDomainException 
+   * @throws QueryInvocationTargetException
+   * @throws NameResolutionException
+   * @throws TypeMismatchException
+   * @throws FunctionDomainException
-      throws FunctionDomainException,
-      TypeMismatchException, NameResolutionException,
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
-    //We need NonTxEntry to call getValue() on it. RegionEntry does
-    //NOT have public getValue() method.
+    // We need NonTxEntry to call getValue() on it. RegionEntry does
+    // NOT have public getValue() method.
-      value = ((LocalRegion) this.getRegion()).new NonTXEntry(
-          (RegionEntry) value);
+      value = ((LocalRegion) this.getRegion()).new NonTXEntry((RegionEntry) value);
-  private List evaluateLastColl(Object value, ExecutionContext context,
-      List itrs, int level)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  private List evaluateLastColl(Object value, ExecutionContext context, List itrs, int level)
+      throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+      QueryInvocationTargetException {
-    
+
-          RuntimeIterator iter = (RuntimeIterator)itrs.get(i);
+          RuntimeIterator iter = (RuntimeIterator) itrs.get(i);
-          tuples.addAll(evaluateLastColl(nextLevelValue, context,
-              itrs, level + 1));
+          tuples.addAll(evaluateLastColl(nextLevelValue, context, itrs, level + 1));
-   * Matches the Collection reference in given context for this index's
-   * from-clause in all current independent collection references associated to
-   * the context. For example, if a join Query has "/region1 p, region2 e" from clause
-   * context contains two region references for p and e and Index could be used for
-   * any of those of both of those regions.
+   * Matches the Collection reference in given context for this index's from-clause in all current
+   * independent collection references associated to the context. For example, if a join Query has
+   * "/region1 p, region2 e" from clause context contains two region references for p and e and
+   * Index could be used for any of those of both of those regions.
-   * Note: This Index contains its own from clause definition which corresponds to
-   * a region collection reference in given context and must be contained at 0th index
-   * in {@link AbstractIndex#canonicalizedDefinitions}.  
+   * Note: This Index contains its own from clause definition which corresponds to a region
+   * collection reference in given context and must be contained at 0th index in
+   * {@link AbstractIndex#canonicalizedDefinitions}.
-    Region rgn  = this.getRegion();
-    if (rgn instanceof BucketRegion) {
-      rgn = ((BucketRegion)rgn).getPartitionedRegion();
-    }
-    String regionPath = rgn.getFullPath();
-    String definition = this.getCanonicalizedIteratorDefinitions()[0];
-    for (RuntimeIterator itr: indItrs) {
-      //GemFireCacheImpl.getInstance().getLogger().fine("Shobhit: "+ itr.getDefinition() + "  "+ this.getRegion().getFullPath());
-      if (itr.getDefinition().equals(regionPath) || itr.getDefinition().equals(definition)) {
-        return itr;
-      }
-    }
-    return null;
-  }
-  
-  /**
-   * Similar to {@link #getRuntimeIteratorForThisIndex(ExecutionContext)} except
-   * that this one also matches the iterator name if present with alias used
-   * in the {@link IndexInfo}
-   * 
-   * @param context
-   * @param info
-   * @return {@link RuntimeIterator}
-   */
-  public RuntimeIterator getRuntimeIteratorForThisIndex(
-      ExecutionContext context, IndexInfo info) {
-    List<RuntimeIterator> indItrs = context.getCurrentIterators();
-      if ((itr.getDefinition().equals(regionPath) || itr.getDefinition()
-          .equals(definition))) {
+      // GemFireCacheImpl.getInstance().getLogger().fine("Shobhit: "+ itr.getDefinition() + " "+
+      // this.getRegion().getFullPath());
+      if (itr.getDefinition().equals(regionPath) || itr.getDefinition().equals(definition)) {
+        return itr;
+      }
+    }
+    return null;
+  }
+
+  /**
+   * Similar to {@link #getRuntimeIteratorForThisIndex(ExecutionContext)} except that this one also
+   * matches the iterator name if present with alias used in the {@link IndexInfo}
+   * 
+   * @param context
+   * @param info
+   * @return {@link RuntimeIterator}
+   */
+  public RuntimeIterator getRuntimeIteratorForThisIndex(ExecutionContext context, IndexInfo info) {
+    List<RuntimeIterator> indItrs = context.getCurrentIterators();
+    Region rgn = this.getRegion();
+    if (rgn instanceof BucketRegion) {
+      rgn = ((BucketRegion) rgn).getPartitionedRegion();
+    }
+    String regionPath = rgn.getFullPath();
+    String definition = this.getCanonicalizedIteratorDefinitions()[0];
+    for (RuntimeIterator itr : indItrs) {
+      if ((itr.getDefinition().equals(regionPath) || itr.getDefinition().equals(definition))) {
-        if(itr.getName() != null){
+        if (itr.getName() != null) {
-          if(path.getType() == OQLLexerTokenTypes.Identifier
-              || itr.getName().equals(pathName)) {
+          if (path.getType() == OQLLexerTokenTypes.Identifier || itr.getName().equals(pathName)) {
-        } else{
+        } else {
-  
+
-    }
-    else if (path instanceof CompiledPath) {
+    } else if (path instanceof CompiledPath) {
-    }
-    else if (path instanceof CompiledOperation) {
+    } else if (path instanceof CompiledOperation) {
-    }
-    else if (path instanceof CompiledIndexOperation) {
-      return getReceiverNameFromPath(((CompiledIndexOperation)path).getReceiver());
+    } else if (path instanceof CompiledIndexOperation) {
+      return getReceiverNameFromPath(((CompiledIndexOperation) path).getReceiver());
-   * Take all independent iterators from context and remove the one which
-   * matches for this Index's independent iterator. Then get all Dependent
-   * iterators from given context for this Index's independent iterator. 
+   * Take all independent iterators from context and remove the one which matches for this Index's
+   * independent iterator. Then get all Dependent iterators from given context for this Index's
+   * independent iterator.
-   * This map is not thread-safe. We rely on the fact that every thread which is
-   * trying to update this kind of map (In Indexes), must have RegionEntry lock
-   * before adding OR removing elements.
+   * This map is not thread-safe. We rely on the fact that every thread which is trying to update
+   * this kind of map (In Indexes), must have RegionEntry lock before adding OR removing elements.
-   * This map does NOT provide an iterator. To iterate over its element caller
-   * has to get inside the map itself through addValuesToCollection() calls.
+   * This map does NOT provide an iterator. To iterate over its element caller has to get inside the
+   * map itself through addValuesToCollection() calls.
-  class RegionEntryToValuesMap
-  {
+  class RegionEntryToValuesMap {
-      this.useList = useList; 
+      this.useList = useList;
-     * We do NOT use any locks here as every add is for a RegionEntry
-     * which is locked before coming here. No two threads can be
-     * entering in this method together for a RegionEntry.
+     * We do NOT use any locks here as every add is for a RegionEntry which is locked before coming
+     * here. No two threads can be entering in this method together for a RegionEntry.
-    public void add(RegionEntry entry, Object value)
-    {
+    public void add(RegionEntry entry, Object value) {
-            coll.add(value); 
+            coll.add(value);
-        Collection coll = useList?new ArrayList(2):new IndexConcurrentHashSet(2, 0.75f, 1);
+        Collection coll = useList ? new ArrayList(2) : new IndexConcurrentHashSet(2, 0.75f, 1);
-    public void addAll(RegionEntry entry, Collection values)
-    {
+    public void addAll(RegionEntry entry, Collection values) {
-        Collection coll = useList?new ArrayList(values.size()):new IndexConcurrentHashSet(values.size(), 0.75f, 1);
+        Collection coll = useList ? new ArrayList(values.size())
+            : new IndexConcurrentHashSet(values.size(), 0.75f, 1);
-        atomicUpdater.addAndGet(this,values.size());
+        atomicUpdater.addAndGet(this, values.size());
-        Collection coll = useList?new ArrayList(values.size() + 1):new IndexConcurrentHashSet(values.size()+1, 0.75f, 1);
+        Collection coll = useList ? new ArrayList(values.size() + 1)
+            : new IndexConcurrentHashSet(values.size() + 1, 0.75f, 1);
-      atomicUpdater.addAndGet(this,values.size());
+      atomicUpdater.addAndGet(this, values.size());
-    public Object get(RegionEntry entry)
-    {
+    public Object get(RegionEntry entry) {
-     * We do NOT use any locks here as every remove is for a RegionEntry
-     * which is locked before coming here. No two threads can be
-     * entering in this method together for a RegionEntry.
+     * We do NOT use any locks here as every remove is for a RegionEntry which is locked before
+     * coming here. No two threads can be entering in this method together for a RegionEntry.
-    public void remove(RegionEntry entry, Object value)
-    {
+    public void remove(RegionEntry entry, Object value) {
-        Collection coll= (Collection)object;
+        Collection coll = (Collection) object;
-      }
-      else {
+      } else {
-    public Object remove(RegionEntry entry)
-    {
+    public Object remove(RegionEntry entry) {
-        atomicUpdater.addAndGet(this,(retVal instanceof Collection) ?
-              - ((Collection) retVal).size() : -1 );
+        atomicUpdater.addAndGet(this,
+            (retVal instanceof Collection) ? -((Collection) retVal).size() : -1);
-    public int getNumValues(RegionEntry entry)
-    {
+    public int getNumValues(RegionEntry entry) {
-    public int getNumValues()
-    {
+    public int getNumValues() {
-    public int getNumEntries()
-    {
+    public int getNumEntries() {
-    public void addValuesToCollection(Collection result, int limit, ExecutionContext context )
-    {
+    public void addValuesToCollection(Collection result, int limit, ExecutionContext context) {
-        Map.Entry e = (Map.Entry)entriesIter.next();
+        Map.Entry e = (Map.Entry) entriesIter.next();
-                //Shobhit: Compare the value in index with in RegionEntry.
+                // Shobhit: Compare the value in index with in RegionEntry.
-              } 
+              }
-              //Shobhit: Compare the value in index with in RegionEntry.
+              // Shobhit: Compare the value in index with in RegionEntry.
-        }
-        else {
-          if (!reUpdateInProgress
-              || verifyEntryAndIndexVaue(re, value, context)) {
+        } else {
+          if (!reUpdateInProgress || verifyEntryAndIndexVaue(re, value, context)) {
-              result
-                  .add(new CqEntry(((RegionEntry) e.getKey()).getKey(), value));
+              result.add(new CqEntry(((RegionEntry) e.getKey()).getKey(), value));
-        throws FunctionDomainException, TypeMismatchException,
-        NameResolutionException, QueryInvocationTargetException
-    {
+        throws FunctionDomainException, TypeMismatchException, NameResolutionException,
+        QueryInvocationTargetException {
-        Map.Entry e = (Map.Entry)entries.next();
+        Map.Entry e = (Map.Entry) entries.next();
-        //Key is a RegionEntry here.
-        RegionEntry entry = (RegionEntry)e.getKey();
+        // Key is a RegionEntry here.
+        RegionEntry entry = (RegionEntry) e.getKey();
-                Iterator itr = ((Collection)value).iterator();
+                Iterator itr = ((Collection) value).iterator();
-                    //Shobhit: Compare the value in index with value in RegionEntry.
+                    // Shobhit: Compare the value in index with value in RegionEntry.
-                    applyProjection(projAttrib, context, result, val,
-                        intermediateResults, isIntersection);
+                    applyProjection(projAttrib, context, result, val, intermediateResults,
+                        isIntersection);
-                } 
+                }
-              Iterator itr = ((Collection)value).iterator();
+              Iterator itr = ((Collection) value).iterator();
-                  //Shobhit: Compare the value in index with value in RegionEntry.
+                  // Shobhit: Compare the value in index with value in RegionEntry.
-                  applyProjection(projAttrib, context, result, val,
-                      intermediateResults, isIntersection);
+                  applyProjection(projAttrib, context, result, val, intermediateResults,
+                      isIntersection);
-          }
-          else {
+          } else {
-              //Shobhit: Compare the value in index with in RegionEntry.
+              // Shobhit: Compare the value in index with in RegionEntry.
-                result.add(new CqEntry(((RegionEntry)e.getKey()).getKey(),
-                    value));
-              }
-              else {
-                applyProjection(projAttrib, context, result, value,
-                    intermediateResults, isIntersection);
+                result.add(new CqEntry(((RegionEntry) e.getKey()).getKey(), value));
+              } else {
+                applyProjection(projAttrib, context, result, value, intermediateResults,
+                    isIntersection);
-    public void removeValuesFromCollection(Collection result,
-        CompiledValue iterOps, RuntimeIterator runtimeItr,
-        ExecutionContext context, List projAttrib,
-        SelectResults intermediateResults, boolean isIntersection)
-        throws FunctionDomainException, TypeMismatchException,
-        NameResolutionException, QueryInvocationTargetException
-    {
+    public void removeValuesFromCollection(Collection result, CompiledValue iterOps,
+        RuntimeIterator runtimeItr, ExecutionContext context, List projAttrib,
+        SelectResults intermediateResults, boolean isIntersection) throws FunctionDomainException,
+        TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-        Map.Entry e = (Map.Entry)entries.next();
+        Map.Entry e = (Map.Entry) entries.next();
-          Iterator itr = ((Collection)value).iterator();
+          Iterator itr = ((Collection) value).iterator();
-              removeProjection(projAttrib, context, result, val,
-                  intermediateResults, isIntersection);
+              removeProjection(projAttrib, context, result, val, intermediateResults,
+                  isIntersection);
-        }
-        else {
+        } else {
-              result.remove(new CqEntry(((RegionEntry)e.getKey()).getKey(),
-                  value));
-            }
-            else {
-              removeProjection(projAttrib, context, result, value,
-                  intermediateResults, isIntersection);
+              result.remove(new CqEntry(((RegionEntry) e.getKey()).getKey(), value));
+            } else {
+              removeProjection(projAttrib, context, result, value, intermediateResults,
+                  isIntersection);
-    public void removeValuesFromCollection(Collection result)
-    {
+    public void removeValuesFromCollection(Collection result) {
-          result.removeAll((Collection)value);
+          result.removeAll((Collection) value);
-    private boolean verifylimit(Collection result, int limit,
-        ExecutionContext context) {     
+    private boolean verifylimit(Collection result, int limit, ExecutionContext context) {
-          return ((Bag)result).size() == limit;
+          return ((Bag) result).size() == limit;
-    public boolean containsEntry(RegionEntry entry)
-    {
+    public boolean containsEntry(RegionEntry entry) {
-    public boolean containsValue(Object value)
-    {
+    public boolean containsValue(Object value) {
-    public void clear()
-    {
+    public void clear() {
-      atomicUpdater.set(this,0);
+      atomicUpdater.set(this, 0);
-    public Set entrySet()
-    {
+    public Set entrySet() {
-     * This replaces a key's value along with updating the numValues
-     * correctly.
+     * This replaces a key's value along with updating the numValues correctly.
+     * 
-      atomicUpdater.addAndGet(this,((values instanceof Collection) ? ((Collection) values)
-          .size() : 1) - numOldValues);
+      atomicUpdater.addAndGet(this,
+          ((values instanceof Collection) ? ((Collection) values).size() : 1) - numOldValues);
-   * This will populate resultset from both type of indexes,
-   * {@link CompactRangeIndex} and {@link RangeIndex}.
+   * This will populate resultset from both type of indexes, {@link CompactRangeIndex} and
+   * {@link RangeIndex}.
-  protected void populateListForEquiJoin(List list, Object outerEntries,
-      Object innerEntries, ExecutionContext context, Object key)
-      throws FunctionDomainException, TypeMismatchException,
+  protected void populateListForEquiJoin(List list, Object outerEntries, Object innerEntries,
+      ExecutionContext context, Object key) throws FunctionDomainException, TypeMismatchException,
-    Assert.assertTrue((outerEntries != null && innerEntries != null), "OuterEntries or InnerEntries must not be null");
-    
+    Assert.assertTrue((outerEntries != null && innerEntries != null),
+        "OuterEntries or InnerEntries must not be null");
+
-          itr = ((RegionEntryToValuesMap)outerEntries).map.entrySet().iterator();
+          itr = ((RegionEntryToValuesMap) outerEntries).map.entrySet().iterator();
-        } else if (outerEntries instanceof CloseableIterator){
+        } else if (outerEntries instanceof CloseableIterator) {
-        } 
-      }
-      else {
+        }
+      } else {
-          itr = ((RegionEntryToValuesMap)innerEntries).map.entrySet().iterator();
+          itr = ((RegionEntryToValuesMap) innerEntries).map.entrySet().iterator();
-        } else if (innerEntries instanceof CloseableIterator){
+        } else if (innerEntries instanceof CloseableIterator) {
-        } 
+        }
-      //TODO :Asif Identify appropriate size of the List
-      
+      // TODO :Asif Identify appropriate size of the List
+
-          Map.Entry entry = (Map.Entry)itr.next();
+          Map.Entry entry = (Map.Entry) itr.next();
-            entryVal = ((Collection)val).iterator().next();
+            entryVal = ((Collection) val).iterator().next();
-          ie = (IndexStoreEntry)itr.next();
+          ie = (IndexStoreEntry) itr.next();
-        //Bug#41010: We need to verify if Inner and Outer Entries
+        // Bug#41010: We need to verify if Inner and Outer Entries
-          if(re.isUpdateInProgress()) {
-           ok = ((RangeIndex) indInfo._getIndex()).verifyEntryAndIndexVaue(re,
-              entryVal, context);
+          if (re.isUpdateInProgress()) {
+            ok = ((RangeIndex) indInfo._getIndex()).verifyEntryAndIndexVaue(re, entryVal, context);
-          ok = ((CompactRangeIndex) indInfo._getIndex())
-              .verifyInnerAndOuterEntryValues(ie, context, indInfo, key);
+          ok = ((CompactRangeIndex) indInfo._getIndex()).verifyInnerAndOuterEntryValues(ie, context,
+              indInfo, key);
-            }
-            else {
+            } else {
-              dummy.addAll(((CompactRangeIndex)indInfo._getIndex()).expandValue(context, key, null, OQLLexerTokenTypes.TOK_EQ, -1, ie.getDeserializedValue()));
-            }
-            else {
+              dummy.addAll(((CompactRangeIndex) indInfo._getIndex()).expandValue(context, key, null,
+                  OQLLexerTokenTypes.TOK_EQ, -1, ie.getDeserializedValue()));
+            } else {
-   * Sets the isIndexedPdxKeys flag indicating if all the keys in the index are
-   * Strings or PdxStrings. Also sets another flag isIndexedPdxKeysFlagSet that
-   * indicates isIndexedPdxKeys has been set/reset to avoid frequent calculation
-   * of map size
+   * Sets the isIndexedPdxKeys flag indicating if all the keys in the index are Strings or
+   * PdxStrings. Also sets another flag isIndexedPdxKeysFlagSet that indicates isIndexedPdxKeys has
+   * been set/reset to avoid frequent calculation of map size
-    if (key == null || key == IndexManager.NULL
-        || key == QueryService.UNDEFINED) {
+    if (key == null || key == IndexManager.NULL || key == QueryService.UNDEFINED) {
-   * Converts Strings to PdxStrings and vice-versa based on the isIndexedPdxKeys
-   * flag
+   * Converts Strings to PdxStrings and vice-versa based on the isIndexedPdxKeys flag
-      if (key instanceof String){
+      if (key instanceof String) {
-       return ((PdxString) key).toString();
+      return ((PdxString) key).toString();
-    return key; 
+    return key;
-  
+
-        if (TypeUtils.compare(key, iterator.next(), OQLLexerTokenTypes.TOK_EQ).equals(Boolean.TRUE)) {
+        if (TypeUtils.compare(key, iterator.next(), OQLLexerTokenTypes.TOK_EQ)
+            .equals(Boolean.TRUE)) {
-      }
-      catch (TypeMismatchException e) {
-        //they are not equals, so we just continue iterating
+      } catch (TypeMismatchException e) {
+        // they are not equals, so we just continue iterating
- 
+
-  
+
-  
-  
+
+

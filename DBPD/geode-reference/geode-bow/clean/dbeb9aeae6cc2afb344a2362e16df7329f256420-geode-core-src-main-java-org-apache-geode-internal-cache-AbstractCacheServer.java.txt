Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Abstract class that contains common code that all true implementations
- * of {@link CacheServer} can use.
+ * Abstract class that contains common code that all true implementations of {@link CacheServer} can
+ * use.
-  public static final String TEST_OVERRIDE_DEFAULT_PORT_PROPERTY = DistributionConfig.GEMFIRE_PREFIX + "test.CacheServer.OVERRIDE_DEFAULT_PORT";
+  public static final String TEST_OVERRIDE_DEFAULT_PORT_PROPERTY =
+      DistributionConfig.GEMFIRE_PREFIX + "test.CacheServer.OVERRIDE_DEFAULT_PORT";
-  
+
-  
+
-   * The buffer size in bytes of the socket for this 
-   * <code>BridgeServer</code>
+   * The buffer size in bytes of the socket for this <code>BridgeServer</code>
-  
+
-  
+
-   * The maximum amount of time between client pings. This value is used by
-   * the <code>ClientHealthMonitor</code> to determine the health of this
-   * <code>BridgeServer</code>'s clients.
+   * The maximum amount of time between client pings. This value is used by the
+   * <code>ClientHealthMonitor</code> to determine the health of this <code>BridgeServer</code>'s
+   * clients.
-  
+
-  
+
-   * the time (in seconds) after which a message in the client queue will
-   * expire.
+   * the time (in seconds) after which a message in the client queue will expire.
+   * 
-  
+
+   * 
-   * The ip address or host name that will be given to clients so they can connect
-   * to this server
+   * The ip address or host name that will be given to clients so they can connect to this server
+   * 
-  
+
-  
+
-  
-  /**
-   * Listens to client membership events and notifies any admin 
-   * members as clients of this server leave/crash. 
-   */
-  protected final ClientMembershipListener listener;
-  
-  //////////////////////  Constructors  //////////////////////
-   * Creates a new <code>BridgeServer</code> with the default
-   * configuration.
+   * Listens to client membership events and notifies any admin members as clients of this server
+   * leave/crash.
+   */
+  protected final ClientMembershipListener listener;
+
+  ////////////////////// Constructors //////////////////////
+
+  /**
+   * Creates a new <code>BridgeServer</code> with the default configuration.
-   * @param cache
-   *        The cache being served
+   * @param cache The cache being served
-    this.messageTimeToLive = CacheServer.DEFAULT_MESSAGE_TIME_TO_LIVE;    
+    this.messageTimeToLive = CacheServer.DEFAULT_MESSAGE_TIME_TO_LIVE;
-      
+
-       * Method to create & send the ClientMembershipMessage to admin members.
-       * The message is sent only if there are any admin members in the
-       * distribution system.
+       * Method to create & send the ClientMembershipMessage to admin members. The message is sent
+       * only if there are any admin members in the distribution system.
-       * @param event
-       *          describes a change in client membership
-       * @param type
-       *          type of event - one of ClientMembershipMessage.JOINED,
-       *          ClientMembershipMessage.LEFT, ClientMembershipMessage.CRASHED
+       * @param event describes a change in client membership
+       * @param type type of event - one of ClientMembershipMessage.JOINED,
+       *        ClientMembershipMessage.LEFT, ClientMembershipMessage.CRASHED
-          ds = (InternalDistributedSystem)cacheInstance.getDistributedSystem();
+          ds = (InternalDistributedSystem) cacheInstance.getDistributedSystem();
-        //ds could be null
+        // ds could be null
-          DM dm =  ds.getDistributionManager();
+          DM dm = ds.getDistributionManager();
-            ClientMembershipMessage msg = 
-              new ClientMembershipMessage(event.getMemberId(), 
-                                      member == null ? null : member.getHost(), 
-                                      type);
-            
+            ClientMembershipMessage msg = new ClientMembershipMessage(event.getMemberId(),
+                member == null ? null : member.getHost(), type);
+
-  /////////////////////  Instance Methods  /////////////////////
+  ///////////////////// Instance Methods /////////////////////
-  
+
-  
+
-    //this.notifyBySubscription = true;
+    // this.notifyBySubscription = true;
-  
+
-  
+
-  
+
-  
+
-  
+
-    }
-    else if (groups.length > 0) {
+    } else if (groups.length > 0) {
-      String [] copy = new String[groups.length];
+      String[] copy = new String[groups.length];
-      String [] copy = new String[result.length];
+      String[] copy = new String[result.length];
-  
+
-  
+
-  
+
-  
+
-   * Returns whether or not this bridge server has the same
-   * configuration as another bridge server.
+   * Returns whether or not this bridge server has the same configuration as another bridge server.
-    return getPort() == other.getPort()
-      && eq(getBindAddress(), other.getBindAddress())
-      && getSocketBufferSize() == other.getSocketBufferSize()
-      && getMaximumTimeBetweenPings() == other.getMaximumTimeBetweenPings()
-      && getNotifyBySubscription() == other.getNotifyBySubscription()
-      && getMaxConnections() == other.getMaxConnections()
-      && getMaxThreads() == other.getMaxThreads()
-      && getMaximumMessageCount() == other.getMaximumMessageCount()
-      && getMessageTimeToLive() == other.getMessageTimeToLive()
-      && Arrays.equals(getGroups(), other.getGroups())
-      && getLoadProbe().equals(other.getLoadProbe())
-      && getLoadPollInterval() == other.getLoadPollInterval()
-      && getTcpNoDelay() == other.getTcpNoDelay();
+    return getPort() == other.getPort() && eq(getBindAddress(), other.getBindAddress())
+        && getSocketBufferSize() == other.getSocketBufferSize()
+        && getMaximumTimeBetweenPings() == other.getMaximumTimeBetweenPings()
+        && getNotifyBySubscription() == other.getNotifyBySubscription()
+        && getMaxConnections() == other.getMaxConnections()
+        && getMaxThreads() == other.getMaxThreads()
+        && getMaximumMessageCount() == other.getMaximumMessageCount()
+        && getMessageTimeToLive() == other.getMessageTimeToLive()
+        && Arrays.equals(getGroups(), other.getGroups())
+        && getLoadProbe().equals(other.getLoadProbe())
+        && getLoadPollInterval() == other.getLoadPollInterval()
+        && getTcpNoDelay() == other.getTcpNoDelay();

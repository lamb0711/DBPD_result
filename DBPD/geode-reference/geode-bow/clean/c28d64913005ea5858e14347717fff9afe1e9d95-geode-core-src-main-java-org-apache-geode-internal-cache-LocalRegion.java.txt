Merge branch 'release/1.4.0'

+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.internal.cache.entries.DiskEntry;
+import org.apache.geode.internal.cache.eviction.EvictableEntry;
-import org.apache.geode.internal.cache.lru.LRUEntry;
+import org.apache.geode.internal.lang.SystemPropertyHelper;
+import org.apache.geode.internal.util.concurrent.CopyOnWriteHashMap;
-import org.apache.logging.log4j.Logger;
-   * 
+   *
-   * 
+   *
-   * 
+   *
+  @Override
-  Map<String, CacheServiceProfile> cacheServiceProfiles;
+  private final CopyOnWriteHashMap<String, CacheServiceProfile> cacheServiceProfiles =
+      new CopyOnWriteHashMap<>();
-    this.cacheServiceProfiles =
-        internalRegionArgs.getCacheServiceProfiles() == null ? Collections.emptyMap()
-            : Collections.unmodifiableMap(internalRegionArgs.getCacheServiceProfiles());
+    if (internalRegionArgs.getCacheServiceProfiles() != null) {
+      this.cacheServiceProfiles.putAll(internalRegionArgs.getCacheServiceProfiles());
+    }
+  @Override
-   * 
+   *
+  @Override
+  @Override
+  @Override
+    this.cache.invokeBeforeDestroyed(this);
-  protected void invokeBeforeRegionDestroyInServices() {
-    for (CacheService service : this.cache.getServices()) {
-      if (service instanceof RegionService) {
-        ((RegionService) service).beforeRegionDestroyed(this);
-      }
-    }
-  }
-
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-  boolean isThisRegionBeingClosedOrDestroyed() {
+  @Override
+  public boolean isThisRegionBeingClosedOrDestroyed() {
+    if (!restoreSetOperationTransactionBehavior) {
+      discoverJTA();
+    }
-   * 
+   *
+    if (!restoreSetOperationTransactionBehavior) {
+      discoverJTA();
+    }
-   * 
+   *
+    if (!restoreSetOperationTransactionBehavior) {
+      discoverJTA();
+    }
-   * 
+   *
+  @Override
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-  boolean cacheWriteBeforeDestroy(EntryEventImpl event, Object expectedOldValue)
+  @Override
+  public boolean cacheWriteBeforeDestroy(EntryEventImpl event, Object expectedOldValue)
+      event.setReadOldValueFromDisk(true);
+        event.setReadOldValueFromDisk(false);
-   * 
+   *
+      event.setReadOldValueFromDisk(true);
+        event.setReadOldValueFromDisk(false);
-  void incTombstoneCount(int delta) {
+  public void incTombstoneCount(int delta) {
-  void scheduleTombstone(RegionEntry entry, VersionTag destroyedVersion) {
+  @Override
+  public void scheduleTombstone(RegionEntry entry, VersionTag destroyedVersion) {
-  void unscheduleTombstone(RegionEntry entry) {
+  @Override
+  public void unscheduleTombstone(RegionEntry entry) {
-   * 
+   *
-   * 
+   *
+  @Override
-   * 
+   *
+  @Override
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
+  @Override
-   * 
+   *
-   * 
+   *
-   * 
+   *
+  @Override
-   * 
+   *
-  void generateAndSetVersionTag(InternalCacheEvent event, RegionEntry entry) {
+  @Override
+  public void generateAndSetVersionTag(InternalCacheEvent event, RegionEntry entry) {
+  @Override
+  @Override
+  public boolean isConcurrencyChecksEnabled() {
+    return this.concurrencyChecksEnabled;
+  }
+
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-    final TXStateProxy tx = this.cache.getTXMgr().internalSuspend();
+    final TXStateProxy tx = this.cache.getTXMgr().pauseTransaction();
-      this.cache.getTXMgr().internalResume(tx);
+      this.cache.getTXMgr().unpauseTransaction(tx);
+  protected final boolean restoreSetOperationTransactionBehavior =
+      SystemPropertyHelper.restoreSetOperationTransactionBehavior();
+
-   * 
+   *
+  private boolean isTransactionPaused() {
+    TXManagerImpl txMgr = (TXManagerImpl) getCache().getCacheTransactionManager();
+    return txMgr.isTransactionPaused();
+  }
+
-   * 
+   *
-  boolean evictDestroy(LRUEntry entry) {
+  boolean evictDestroy(EvictableEntry entry) {
+  @Override
-    final TXStateProxy tx = this.cache.getTXMgr().internalSuspend();
+    final TXStateProxy tx = this.cache.getTXMgr().pauseTransaction();
-      this.cache.getTXMgr().internalResume(tx);
+      this.cache.getTXMgr().unpauseTransaction(tx);
-  void dispatchListenerEvent(EnumListenerEvent op, InternalCacheEvent event) {
+  @Override
+  public void dispatchListenerEvent(EnumListenerEvent op, InternalCacheEvent event) {
+      // Clean up region in RegionListeners
+      this.cache.invokeCleanupFailedInitialization(this);
-  long updateStatsForPut(RegionEntry entry, long lastModified, boolean lruRecentUse) {
+  @Override
+  public long updateStatsForPut(RegionEntry entry, long lastModified, boolean lruRecentUse) {
-      entry.setRecentlyUsed();
+      entry.setRecentlyUsed(this);
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-  void addExpiryTaskIfAbsent(RegionEntry re) {
-    addExpiryTask(re, true);
+  @Override
+  public void addExpiryTaskIfAbsent(RegionEntry entry) {
+    addExpiryTask(entry, true);
-     * 
+     *
-   * 
+   *
-  ImageState getImageState() {
+  @Override
+  public ImageState getImageState() {
-            if (regionEntry instanceof DiskEntry && regionEntry instanceof LRUEntry) {
-              LRUEntry le = (LRUEntry) regionEntry;
-              if (le.testEvicted()) {
+            if (regionEntry instanceof DiskEntry && regionEntry instanceof EvictableEntry) {
+              EvictableEntry le = (EvictableEntry) regionEntry;
+              if (le.isEvicted()) {
+          if (isTransactionPaused()) {
+            // Do not bootstrap JTA again, if the transaction has been paused.
+            return null;
+          }
-  /*****************************************************************************
-   * INNER CLASSES
-   ****************************************************************************/
+  @Override
+  public void incRecentlyUsed() {
+    // nothing
+    this.entries.incRecentlyUsed();
+  }
+  /*****************************************************************************
+   * INNER CLASSES
+   ****************************************************************************/
+
+        @Override
-     * 
+     *
+  @Override
-   * 
+   *
-              TXStateProxy txState = this.cache.getTXMgr().internalSuspend();
+              TXStateProxy txState = this.cache.getTXMgr().pauseTransaction();
-                this.cache.getTXMgr().internalResume(txState);
+                this.cache.getTXMgr().unpauseTransaction(txState);
-   * 
+   *
-   * 
+   *
-   * 
+   *
-       * If this is tx, do removeEntry, unless it is a local region?
+       * If this is tx, do destroyEntry, unless it is a local region?
-  /**
-   * @return Returns the isUsedForPartitionedRegionAdmin.
-   */
-  boolean isUsedForPartitionedRegionAdmin() {
+  @Override
+  public boolean isUsedForPartitionedRegionAdmin() {
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-    return Collections.unmodifiableMap(this.cacheServiceProfiles);
+    return this.cacheServiceProfiles.getSnapshot();
+  }
+
+  public void addCacheServiceProfile(CacheServiceProfile profile) {
+    this.cacheServiceProfiles.put(profile.getId(), profile);
-   * 
+   *
+  @Override
-   * 
+   *
-  int updateSizeOnEvict(Object key, int oldSize) {
+  @Override
+  public int updateSizeOnEvict(Object key, int oldSize) {
-   * 
+   *
-   * 
+   *
-   * 
+   *
+  public boolean canStoreDataLocally() {
+    return this.dataPolicy.withStorage();
+  }
+
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
-   * 
+   *
+  /**
+   * Send a message to all other members that can have this same region entry and return the latest
+   * last access time.
+   */
+  public long getLatestLastAccessTimeFromOthers(Object key) {
+    // local regions have no other members so return 0.
+    return 0L;
+  }
+
+  /**
+   * Returns the number of LRU evictions done by this region.
+   */
+  @Override
+  public long getEvictions() {
+    return this.entries.getEvictions();
+  }
+

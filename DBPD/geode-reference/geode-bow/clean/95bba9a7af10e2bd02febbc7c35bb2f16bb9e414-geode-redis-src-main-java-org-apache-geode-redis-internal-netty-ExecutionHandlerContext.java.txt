Revert "GEODE-8333: Fix PUBSUB hang (#5349)" (#5415)

This reverts commit 067194e8f82414b6103c4335beb6567947edcfbc.

The fix for GEODE-8333 had a bug in which responses to the client could be out of order.
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.LinkedBlockingQueue;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.EventLoopGroup;
+  private final EventLoopGroup subscriberGroup;
-  private final ExecutorService backgroundExecutor;
-  private final LinkedBlockingQueue<Command> commandQueue = new LinkedBlockingQueue<>();
+      EventLoopGroup subscriberGroup,
-      ExecutorService backgroundExecutor,
+    this.subscriberGroup = subscriberGroup;
-    this.backgroundExecutor = backgroundExecutor;
+  public ChannelFuture writeToChannel(ByteBuf message) {
+    return channel.writeAndFlush(message, channel.newPromise());
+  }
+
-    command.setChannelHandlerContext(ctx);
-    synchronized (commandQueue) {
-      if (!commandQueue.isEmpty()) {
-        commandQueue.offer(command);
-        return;
+    try {
+      if (logger.isDebugEnabled()) {
+        logger.debug("Executing Redis command: {}", command);
-      if (command.getCommandType().isAsync()) {
-        commandQueue.offer(command);
-        startAsyncCommandExecution(command);
-        return;
-      }
-      executeCommand(command);
+
+      executeCommand(ctx, command);
+    } catch (Exception e) {
+      logger.warn("Execution of Redis command {} failed: {}", command, e);
+      throw e;
+
-  private void startAsyncCommandExecution(Command command) {
-    if (logger.isDebugEnabled()) {
-      logger.debug("Starting execution of async Redis command: {}", command);
-    }
-    final long start = redisStats.startCommand(command.getCommandType());
-    command.setAsyncStartTime(start);
-    command.execute(this);
-  }
-
-  public void endAsyncCommandExecution(Command command, RedisResponse response) {
-    synchronized (commandQueue) {
-      Command head = takeFromCommandQueue();
-      if (head != command) {
-        throw new IllegalStateException(
-            "expected " + command + " but found " + head + " in the queue");
-      }
-      try {
-        writeToChannel(response);
-      } finally {
-        redisStats.endCommand(command.getCommandType(), command.getAsyncStartTime());
-      }
-      drainCommandQueue();
-    }
-  }
-
-  public void endAsyncCommandExecution(Command command, Throwable exception) {
-    synchronized (commandQueue) {
-      Command head = takeFromCommandQueue();
-      if (head != command) {
-        throw new IllegalStateException(
-            "expected " + command + " but found " + head + " in the queue");
-      }
-      try {
-        exceptionCaught(command.getChannelHandlerContext(), exception);
-      } finally {
-        redisStats.endCommand(command.getCommandType(), command.getAsyncStartTime());
-      }
-      drainCommandQueue();
-    }
-  }
-
-  private Command takeFromCommandQueue() {
-    try {
-      return commandQueue.take();
-    } catch (InterruptedException e) {
-      Thread.interrupted();
-      throw new IllegalStateException("unexpected interrupt");
-    }
-  }
-
-  /**
-   * execute all commands in the queue until an async one is found.
-   * If an async one is found start it.
-   */
-  private void drainCommandQueue() {
-    Command command;
-    while ((command = commandQueue.peek()) != null) {
-      if (command.getCommandType().isAsync()) {
-        startAsyncCommandExecution(command);
-        return;
-      } else {
-        takeFromCommandQueue();
-        try {
-          executeCommand(command);
-        } catch (Throwable ex) {
-          exceptionCaught(command.getChannelHandlerContext(), ex);
-        }
-      }
-    }
-  }
-
-  private void executeCommand(Command command) {
+  private void executeCommand(ChannelHandlerContext ctx, Command command) {
+
+    if (!isAuthenticated()) {
+      response = handleUnAuthenticatedCommand(command);
+      writeToChannel(response);
+      return;
+    }
+
+    if (command.isUnsupported() && !allowUnsupportedCommands()) {
+      writeToChannel(
+          RedisResponse.error(command.getCommandType() + RedisConstants.ERROR_UNSUPPORTED_COMMAND));
+      return;
+    }
+
+    if (command.isUnimplemented()) {
+      logger.info("Failed " + command.getCommandType() + " because it is not implemented.");
+      writeToChannel(RedisResponse.error(command.getCommandType() + " is not implemented."));
+      return;
+    }
+
+    final long start = redisStats.startCommand(command.getCommandType());
-      if (logger.isDebugEnabled()) {
-        logger.debug("Executing Redis command: {}", command);
-      }
+      response = command.execute(this);
+      logResponse(response);
+      writeToChannel(response);
+    } finally {
+      redisStats.endCommand(command.getCommandType(), start);
+    }
-      if (!isAuthenticated()) {
-        response = handleUnAuthenticatedCommand(command);
-        writeToChannel(response);
-        return;
-      }
-
-      if (command.isUnsupported() && !allowUnsupportedCommands()) {
-        writeToChannel(
-            RedisResponse
-                .error(command.getCommandType() + RedisConstants.ERROR_UNSUPPORTED_COMMAND));
-        return;
-      }
-
-      if (command.isUnimplemented()) {
-        logger.info("Failed " + command.getCommandType() + " because it is not implemented.");
-        writeToChannel(RedisResponse.error(command.getCommandType() + " is not implemented."));
-        return;
-      }
-
-      final long start = redisStats.startCommand(command.getCommandType());
-      try {
-        response = command.execute(this);
-        if (response == null) {
-          return;
-        }
-        logResponse(response);
-        writeToChannel(response);
-      } finally {
-        redisStats.endCommand(command.getCommandType(), start);
-      }
-
-      if (command.isOfType(RedisCommandType.QUIT)) {
-        channelInactive(command.getChannelHandlerContext());
-      }
-    } catch (Exception e) {
-      logger.warn("Execution of Redis command {} failed: {}", command, e);
-      throw e;
+    if (command.isOfType(RedisCommandType.QUIT)) {
+      channelInactive(ctx);
+  public EventLoopGroup getSubscriberGroup() {
+    return subscriberGroup;
+  }
+
+  public void changeChannelEventLoopGroup(EventLoopGroup newGroup) {
+    if (newGroup.equals(channel.eventLoop())) {
+      // already registered with newGroup
+      return;
+    }
+    channel.deregister().addListener((ChannelFutureListener) future -> {
+      newGroup.register(channel).sync();
+    });
+  }
+
-  public ExecutorService getBackgroundExecutor() {
-    return backgroundExecutor;
-  }
+

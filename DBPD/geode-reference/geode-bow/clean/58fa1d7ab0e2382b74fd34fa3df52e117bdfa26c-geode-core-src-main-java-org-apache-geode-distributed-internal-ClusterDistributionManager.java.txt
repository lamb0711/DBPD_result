Merge remote-tracking branch 'upstream/develop' into develop

+import org.apache.geode.internal.alerting.AlertingService;
-import org.apache.geode.internal.logging.log4j.AlertAppender;
-  private static final int MAX_FE_THREADS = Integer.getInteger("DistributionManager.MAX_FE_THREADS",
+  public static final int MAX_FE_THREADS = Integer.getInteger("DistributionManager.MAX_FE_THREADS",
-
+  protected static final String FUNCTION_EXECUTION_PROCESSOR_THREAD_PREFIX =
+      "Function Execution Processor";
+  private final AlertingService alertingService;
+
-      distributionManager = new ClusterDistributionManager(system, transport);
+      distributionManager =
+          new ClusterDistributionManager(system, transport, system.getAlertingService());
-      InternalDistributedSystem system) {
+      InternalDistributedSystem system, AlertingService alertingService) {
+    this.alertingService = alertingService;
-            LoggingExecutors.newFunctionThreadPoolWithFeedStatistics("Function Execution Processor",
+            LoggingExecutors.newFunctionThreadPoolWithFeedStatistics(
+                FUNCTION_EXECUTION_PROCESSOR_THREAD_PREFIX,
-            LoggingExecutors.newSerialThreadPoolWithFeedStatistics("Function Execution Processor",
+            LoggingExecutors.newSerialThreadPoolWithFeedStatistics(
+                FUNCTION_EXECUTION_PROCESSOR_THREAD_PREFIX,
-      RemoteTransportConfig transport) {
-    this(transport, system);
+      RemoteTransportConfig transport, AlertingService alertingService) {
+    this(transport, system, alertingService);
-        if (locators == null || locators.isEmpty()) {
-          throw new IllegalArgumentException("Cannot use empty collection of locators");
-        }
+  @Override
+  public AlertingService getAlertingService() {
+    return alertingService;
+  }
+
-    AlertAppender.getInstance().removeAlertListener(theId);
+    alertingService.removeAlertListener(theId);

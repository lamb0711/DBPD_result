GEODE-7808: standardize on use of HostAndPort for connection formation  (#4778)

* GEODE-7808: standardize on use of HostAndPort for connection formation

Adding two tests that limit the use of InetAddress and of
InetSocketAddress.getAddress().  Ideally we could whittle down the
list of exceptions currently being "sanctioned" by the InetAddress test.

I tried using the PMD tool that's already built into our gradle builds
to perform these restrictions but it fails with parsing errors.  Instead
I turned to the "decode" package that's used by
AnalyzeSerializablesTestBase and refactored that into a Rule that can be
used by any test to load its module's class files in partially
decompiled form.  I added a couple of query methods to CompiledClass to
search for uses of InetAddress and InetSocketAddress.getAddress().

The InetAddress test turned up 74 violations.  I removed some of these
by getting rid of unnecessary code or moving it to LocalHostUtil and
categorized the other violations and moved them into a "sanctioned" list
that we should work on making as small as possible.

* adding missing test and rule

* finished analyzing classes having InetAddress in method signatures

* modified the test to only restrict InetAddress lookup by name

* added another test to restrict use of Admin API's InetAddress utilities
+import org.apache.geode.codeAnalysis.decode.cp.CpMethodref;
- * Decoder represents a jdk ClassFile header
+ * Decoder represents a jdk ClassFile header. See "The Java Virtual Machine Specification"
+ * for a detailed description of all of the fields in this and other classes in this
+ * package and the "cp" (constant pool) package
+ * <p>
+ * Basically, all of the other classes hold indexes into one of the fields in this
+ * class. Cp classes hold indexes into the constant_pool, which holds all of the Cp
+ * instances associated with this CompiledClass. A CpMethodref, for instance, holds an
+ * index into the constant_pool to locate the CpClass implementing the method as well
+ * as an index into the constant_pool of the CpNameAndType of the method itself.
+  public boolean refersToClass(String name) {
+    for (Cp constantPoolEntry : constant_pool) {
+      if (constantPoolEntry instanceof CpClass &&
+          ((CpClass) constantPoolEntry).className(this).equals(name)) {
+        return true;
+      }
+    }
+    for (CompiledMethod compiledMethod : methods) {
+      if (compiledMethod == null) {
+        continue;
+      }
+      if (compiledMethod.descriptor().equals(name) || compiledMethod.hasArgumentOfType(name)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  public boolean refersToMethod(String className, String methodName) {
+    for (Cp constantPoolEntry : constant_pool) {
+      if (constantPoolEntry instanceof CpMethodref) {
+        CpMethodref methodref = (CpMethodref) constantPoolEntry;
+        if (methodref.className(this).equals(className)
+            && methodref.methodName(this).equals(methodName)) {
+          return true;
+        }
+      }
+    }
+    return false;
+  }

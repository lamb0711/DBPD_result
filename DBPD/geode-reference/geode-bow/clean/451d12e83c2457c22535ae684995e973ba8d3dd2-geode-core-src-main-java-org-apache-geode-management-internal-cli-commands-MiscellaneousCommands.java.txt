GEODE-2919: Provide finer grained security

 - For full details, see https://cwiki.apache.org/confluence/display/GEODE/Finer+grained+security

+import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.PrintWriter;
+import java.text.MessageFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.zip.DataFormatException;
+import java.util.zip.GZIPInputStream;
+
+import javax.management.ObjectName;
+
+import org.apache.logging.log4j.Logger;
+import org.springframework.shell.core.annotation.CliCommand;
+import org.springframework.shell.core.annotation.CliOption;
+
-import org.apache.geode.management.internal.cli.result.CommandResultException;
-import org.apache.logging.log4j.Logger;
-import org.springframework.shell.core.annotation.CliAvailabilityIndicator;
-import org.springframework.shell.core.annotation.CliCommand;
-import org.springframework.shell.core.annotation.CliOption;
-
-import java.io.BufferedInputStream;
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.io.PrintWriter;
-import java.text.MessageFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-import java.util.Set;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.zip.DataFormatException;
-import java.util.zip.GZIPInputStream;
-import javax.management.ObjectName;
-      // convert to mili-seconds
+      // convert to milliseconds
-          Set<DistributedMember> lsSet = new HashSet<DistributedMember>();
+          Set<DistributedMember> lsSet = new HashSet<>();
-      Set<DistributedMember> mgrSet = new HashSet<DistributedMember>();
+      Set<DistributedMember> mgrSet = new HashSet<>();
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-    Result result = null;
+    Result result;
-    Set<DistributedMember> dsMembers = new HashSet<DistributedMember>();
+    Set<DistributedMember> dsMembers = new HashSet<>();
-      List<?> resultList = null;
+      List<?> resultList;
-      for (int i = 0; i < resultList.size(); i++) {
-        Object object = resultList.get(i);
+      for (Object object : resultList) {
-      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS}, mandatory = false,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
+      @CliOption(key = {CliStrings.MEMBER, CliStrings.MEMBERS},
-      @CliOption(key = CliStrings.GROUP, mandatory = false,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          optionContext = ConverterHint.MEMBERGROUP,
+      @CliOption(key = CliStrings.GROUP, optionContext = ConverterHint.MEMBERGROUP,
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-    Result result = null;
+    Result result;
-    Map<String, DistributedMember> hostMemberMap = new HashMap<String, DistributedMember>();
-    Map<String, List<String>> hostMemberListMap = new HashMap<String, List<String>>();
+    Map<String, DistributedMember> hostMemberMap = new HashMap<>();
+    Map<String, List<String>> hostMemberListMap = new HashMap<>();
-        Set<String> notFoundMembers = new HashSet<String>();
+        Set<String> notFoundMembers = new HashSet<>();
-        Set<DistributedMember> membersToExecuteOn = null;
+        Set<DistributedMember> membersToExecuteOn;
-      String lineSeparatorToUse = null;
+      String lineSeparatorToUse;
-        Set<DistributedMember> membersToExecuteOn =
-            new HashSet<DistributedMember>(hostMemberMap.values());
+        Set<DistributedMember> membersToExecuteOn = new HashSet<>(hostMemberMap.values());
-        for (int i = 0; i < resultList.size(); i++) {
-          NetstatFunctionResult netstatFunctionResult = (NetstatFunctionResult) resultList.get(i);
+        for (Object aResultList : resultList) {
+          NetstatFunctionResult netstatFunctionResult = (NetstatFunctionResult) aResultList;
-    List<String> list = null;
+    List<String> list;
-      list = new ArrayList<String>();
+      list = new ArrayList<>();
-  @CliMetaData(shellOnly = false, relatedTopic = {CliStrings.TOPIC_GEODE_DEBUG_UTIL})
+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DEBUG_UTIL})
-    Result result = null;
+    Result result;
-  @CliMetaData(shellOnly = false, relatedTopic = {CliStrings.TOPIC_GEODE_DEBUG_UTIL})
+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DEBUG_UTIL})
-          unspecifiedDefaultValue = CliMetaData.ANNOTATION_NULL_VALUE,
-          help = CliStrings.SHOW_LOG_LINE_NUM_HELP, mandatory = false) int numberOfLines) {
-    Result result = null;
+          help = CliStrings.SHOW_LOG_LINE_NUM_HELP) int numberOfLines) {
+    Result result;
-      MemberMXBean bean = null;
+      MemberMXBean bean;
-  @CliMetaData(shellOnly = false, relatedTopic = {CliStrings.TOPIC_GEODE_DEBUG_UTIL})
+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_DEBUG_UTIL})
-    Result result = null;
+    Result result;
-      Map<String, byte[]> dumps = new HashMap<String, byte[]>();
+      Map<String, byte[]> dumps = new HashMap<>();
-        // we dont to show any info result
+        // we don't to show any info result
-    String filePath = null;
-    OutputStream os = null;
-    PrintWriter ps = null;
-    File outputFile = null;
+    String filePath;
+    PrintWriter ps;
+    File outputFile;
-    try {
-      outputFile = new File(fileName);
-      os = new FileOutputStream(outputFile);
+    outputFile = new File(fileName);
+    try (OutputStream os = new FileOutputStream(outputFile)) {
-      for (Map.Entry<String, byte[]> entry : dumps.entrySet()) {
+      for (Entry<String, byte[]> entry : dumps.entrySet()) {
-    } finally {
-      os.close();
-  @CliMetaData(shellOnly = false, relatedTopic = {CliStrings.TOPIC_GEODE_STATISTICS})
+  @CliMetaData(relatedTopic = {CliStrings.TOPIC_GEODE_STATISTICS})
-    Result result = null;
+    Result result;
-  private ResultData getSystemWideMetrics(String export_to_report_to, String[] categoriesArr)
-      throws Exception {
+  private ResultData getSystemWideMetrics(String export_to_report_to, String[] categoriesArr) {
-    final ManagementService managmentService = ManagementService.getManagementService(cache);
-    DistributedSystemMXBean dsMxBean = managmentService.getDistributedSystemMXBean();
+    final ManagementService managementService = ManagementService.getManagementService(cache);
+    DistributedSystemMXBean dsMxBean = managementService.getDistributedSystemMXBean();
-        Set<String> checkSet = new HashSet<String>(categoriesMap.keySet());
+        Set<String> checkSet = new HashSet<>(categoriesMap.keySet());
-      if (categoriesMap.get("cluster").booleanValue()) {
+      if (categoriesMap.get("cluster")) {
-      if (categoriesMap.get("cache").booleanValue()) {
+      if (categoriesMap.get("cache")) {
-      if (categoriesMap.get("diskstore").booleanValue()) {
+      if (categoriesMap.get("diskstore")) {
-      if (categoriesMap.get("query").booleanValue()) {
+      if (categoriesMap.get("query")) {
-    ObjectName csMxBeanName = null;
+    ObjectName csMxBeanName;
-        Set<String> checkSet = new HashSet<String>(categoriesMap.keySet());
+        Set<String> checkSet = new HashSet<>(categoriesMap.keySet());
-      if (categoriesMap.get("member").booleanValue()) {
+      if (categoriesMap.get("member")) {
-      if (categoriesMap.get("jvm").booleanValue()) {
+      if (categoriesMap.get("jvm")) {
-      if (categoriesMap.get("region").booleanValue()) {
+      if (categoriesMap.get("region")) {
-        // Not available from stats. After Stats re-org it will be avaialble
+        // Not available from stats. After Stats re-org it will be available
-      if (categoriesMap.get("serialization").booleanValue()) {
+      if (categoriesMap.get("serialization")) {
-      if (categoriesMap.get("communication").booleanValue()) {
+      if (categoriesMap.get("communication")) {
-      if (categoriesMap.get("function").booleanValue()) {
+      if (categoriesMap.get("function")) {
-        // Not Avaialble from Stats
-        // writeToTableAndCsv(metricsTable, "", "funcExecutionQueueSize",
-        // memberMxBean.getFuncExecutionQueueSize(), csvBuilder);
-      if (categoriesMap.get("transaction").booleanValue()) {
+      if (categoriesMap.get("transaction")) {
-      if (categoriesMap.get("diskstore").booleanValue()) {
+      if (categoriesMap.get("diskstore")) {
-      if (categoriesMap.get("lock").booleanValue()) {
+      if (categoriesMap.get("lock")) {
-      if (categoriesMap.get("eviction").booleanValue()) {
+      if (categoriesMap.get("eviction")) {
-      if (categoriesMap.get("distribution").booleanValue()) {
+      if (categoriesMap.get("distribution")) {
-            memberMxBean.getInitialImagesInProgres(), csvBuilder);
+            memberMxBean.getInitialImagesInProgress(), csvBuilder);
-      if (categoriesMap.get("offheap").booleanValue()) {
+      if (categoriesMap.get("offheap")) {
-        Set<String> checkSet = new HashSet<String>(categoriesMap.keySet());
+        Set<String> checkSet = new HashSet<>(categoriesMap.keySet());
-      if (categoriesMap.get("cluster").booleanValue()) {
+      if (categoriesMap.get("cluster")) {
-      if (categoriesMap.get("region").booleanValue()) {
+      if (categoriesMap.get("region")) {
-      if (categoriesMap.get("partition").booleanValue()) {
+      if (categoriesMap.get("partition")) {
-      if (categoriesMap.get("diskstore").booleanValue()) {
+      if (categoriesMap.get("diskstore")) {
-      if (categoriesMap.get("callback").booleanValue()) {
+      if (categoriesMap.get("callback")) {
-      if (categoriesMap.get("eviction").booleanValue()) {
+      if (categoriesMap.get("eviction")) {
-        Set<String> checkSet = new HashSet<String>(categoriesMap.keySet());
+        Set<String> checkSet = new HashSet<>(categoriesMap.keySet());
-      if (categoriesMap.get("region").booleanValue()) {
+      if (categoriesMap.get("region")) {
-      if (categoriesMap.get("partition").booleanValue()) {
+      if (categoriesMap.get("partition")) {
-      if (categoriesMap.get("diskstore").booleanValue()) {
+      if (categoriesMap.get("diskstore")) {
-      if (categoriesMap.get("callback").booleanValue()) {
+      if (categoriesMap.get("callback")) {
-      if (categoriesMap.get("eviction").booleanValue()) {
+      if (categoriesMap.get("eviction")) {
-    metricsTable.accumulate(CliStrings.SHOW_METRICS__VALUE__HEADER, Double.valueOf(metricValue));
+    metricsTable.accumulate(CliStrings.SHOW_METRICS__VALUE__HEADER, metricValue);
-    Set<String> categoriesSet = new HashSet<String>();
-    for (String category : categories) {
-      categoriesSet.add(category);
-    }
+    Set<String> categoriesSet = new HashSet<>();
+    Collections.addAll(categoriesSet, categories);
-    Map<String, Boolean> categories = new HashMap<String, Boolean>();
+    Map<String, Boolean> categories = new HashMap<>();
-    Map<String, Boolean> categories = new HashMap<String, Boolean>();
+    Map<String, Boolean> categories = new HashMap<>();
-    Map<String, Boolean> categories = new HashMap<String, Boolean>();
+    Map<String, Boolean> categories = new HashMap<>();
-      Set<DistributedMember> dsMembers = new HashSet<DistributedMember>();
+      Set<DistributedMember> dsMembers = new HashSet<>();
-          Iterator<DistributedMember> it = ds.iterator();
-          while (it.hasNext()) {
-            DistributedMember mem = it.next();
+          for (DistributedMember mem : ds) {
-          continue;
-    Set<String> setDifference = new HashSet<String>();
+    Set<String> setDifference = new HashSet<>();

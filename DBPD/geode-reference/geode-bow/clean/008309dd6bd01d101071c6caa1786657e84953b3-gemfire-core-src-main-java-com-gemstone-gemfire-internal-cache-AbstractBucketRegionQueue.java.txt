Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2010-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * one or more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import java.util.concurrent.atomic.AtomicReference;
+import com.gemstone.gemfire.cache.hdfs.internal.HDFSBucketRegionQueue;
+import com.gemstone.gemfire.cache.hdfs.internal.HDFSGatewayEventImpl;
+import com.gemstone.gemfire.internal.cache.versions.RegionVersionVector;
+import com.gemstone.gemfire.internal.cache.versions.VersionSource;
+import com.gemstone.gemfire.internal.offheap.OffHeapRegionEntryHelper;
-  private static final Logger logger = LogService.getLogger();
+  protected static final Logger logger = LogService.getLogger();
-      //merge42180: are we considering offheap in cedar. Comment freeOffHeapReference intentionally
-      //event.freeOffHeapReferences();
+      event.release();
-              /*if (event != null) {
-                event.release();  // merge44873: this is offheap related change from cheetah
-              }*/
+              if (event != null) {
+                event.release();
+              }
-              /*for (GatewaySenderEventImpl e: tempQueue) {
-                e.release(); // merge44873: this is offheap related change from cheetah
-              }*/
+              for (GatewaySenderEventImpl e: tempQueue) {
+                e.release();
+              }
-     
+       GatewaySenderEventImpl.release(event.getRawOldValue());
+	GatewaySenderEventImpl.release(event.getRawOldValue());
-    EntryEventImpl event = new EntryEventImpl(this, Operation.UPDATE, key,
+    EntryEventImpl event = EntryEventImpl.create(this, Operation.UPDATE, key,
-    //event.copyOffHeapToHeap();
+    event.copyOffHeapToHeap();
-
+    
+    int sizeOfHdfsEvent = -1;
+      if (this instanceof HDFSBucketRegionQueue) {
+        // need to fetch the size before event is inserted in queue.
+        // fix for #50016
+        if (this.getBucketAdvisor().isPrimary()) {
+          HDFSGatewayEventImpl hdfsEvent = (HDFSGatewayEventImpl)event.getValue();
+          sizeOfHdfsEvent = hdfsEvent.getSizeOnHDFSInBytes(!((HDFSBucketRegionQueue)this).isBucketSorted);
+        }
+      }
+      
-      //if (!didPut) {
-      //  GatewaySenderEventImpl gwVal = (GatewaySenderEventImpl) value;
-      //  gwVal.release();
-      //}
+      if (!didPut) {
+        GatewaySenderEventImpl.release(value);
+      }
-      addToEventQueue(key, didPut, event);
+      addToEventQueue(key, didPut, event, sizeOfHdfsEvent);
+  @Override
+  public void closeEntries() {
+    OffHeapRegionEntryHelper.doWithOffHeapClear(new Runnable() {
+      @Override
+      public void run() {
+        AbstractBucketRegionQueue.super.closeEntries();
+      }
+    });
+    clearQueues();
+    
+  }
-//  @Override
-//  public void closeEntries() {
-//    OffHeapRegionEntryHelper.doWithOffHeapClear(new Runnable() {
-//      @Override
-//      public void run() {
-//        AbstractBucketRegionQueue.super.closeEntries();
-//      }
-//    });
-//    clearQueues();
-//    
-//  }
-//  
-//  @Override
-//  public Set<VersionSource> clearEntries(final RegionVersionVector rvv) {
-//    final AtomicReference<Set<VersionSource>> result = new AtomicReference<Set<VersionSource>>();
-//    OffHeapRegionEntryHelper.doWithOffHeapClear(new Runnable() {
-//      @Override
-//      public void run() {
-//        result.set(AbstractBucketRegionQueue.super.clearEntries(rvv));
-//      }
-//    });
-//    clearQueues();
-//    return result.get();
-//  }
+  @Override
+  public Set<VersionSource> clearEntries(final RegionVersionVector rvv) {
+    final AtomicReference<Set<VersionSource>> result = new AtomicReference<Set<VersionSource>>();
+    OffHeapRegionEntryHelper.doWithOffHeapClear(new Runnable() {
+      @Override
+      public void run() {
+        result.set(AbstractBucketRegionQueue.super.clearEntries(rvv));
+      }
+    });
+    clearQueues();
+    return result.get();
+  }
-  protected abstract void addToEventQueue(Object key, boolean didPut, EntryEventImpl event);
+  protected abstract void addToEventQueue(Object key, boolean didPut, EntryEventImpl event, 
+      int sizeOfHdfsEvent);

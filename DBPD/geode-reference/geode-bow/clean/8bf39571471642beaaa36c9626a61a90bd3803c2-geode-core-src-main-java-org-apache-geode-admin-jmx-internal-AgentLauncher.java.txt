Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A command line utility inspired by the <code>CacheServerLauncher</code> that is responsible for administering
- * a stand-along GemFire JMX {@link Agent}.
+ * A command line utility inspired by the <code>CacheServerLauncher</code> that is responsible for
+ * administering a stand-along GemFire JMX {@link Agent}.
+ * 
-  
+
-  public static final boolean PRINT_LAUNCH_COMMAND = Boolean.getBoolean(AgentLauncher.class.getSimpleName()
-      + ".PRINT_LAUNCH_COMMAND");
+  public static final boolean PRINT_LAUNCH_COMMAND =
+      Boolean.getBoolean(AgentLauncher.class.getSimpleName() + ".PRINT_LAUNCH_COMMAND");
-  /** A flag to indicate if the current log file should be kept. Used only when 'start' is used to fork off the 'server' */
+  /**
+   * A flag to indicate if the current log file should be kept. Used only when 'start' is used to
+   * fork off the 'server'
+   */
-   * Instantiates an AgentLauncher for execution and control of the GemFire JMX Agent process.  This constructor is
-   * package private to prevent direct instantiation or subclassing by classes outside this package, but does allow
-   * the class to be tested as needed.
+   * Instantiates an AgentLauncher for execution and control of the GemFire JMX Agent process. This
+   * constructor is package private to prevent direct instantiation or subclassing by classes
+   * outside this package, but does allow the class to be tested as needed.
+   * 
-    for (Iterator<Object> iter = props.keySet().iterator(); iter.hasNext(); ) {
+    for (Iterator<Object> iter = props.keySet().iterator(); iter.hasNext();) {
-      map.put(prop, AgentConfigImpl.getPropertyDescription(prop) +
-              " (" + LocalizedStrings.AgentLauncher_DEFAULT.toLocalizedString() + "  \"" + props.getProperty(prop) + "\")");
+      map.put(prop,
+          AgentConfigImpl.getPropertyDescription(prop) + " ("
+              + LocalizedStrings.AgentLauncher_DEFAULT.toLocalizedString() + "  \""
+              + props.getProperty(prop) + "\")");
-   * Returns a map that maps the name of the start options to its value on the command line.  If no value is
-   * specified on the command line, a default one is provided.
+   * Returns a map that maps the name of the start options to its value on the command line. If no
+   * value is specified on the command line, a default one is provided.
-      }
-      else if (arg.startsWith("-dir=")) {
+      } else if (arg.startsWith("-dir=")) {
-          new File(workingDirectory, AgentConfig.DEFAULT_PROPERTY_FILE).getPath());
-      }
-      else if (arg.startsWith("-J")) {
+            new File(workingDirectory, AgentConfig.DEFAULT_PROPERTY_FILE).getPath());
+      } else if (arg.startsWith("-J")) {
-      }
-      else if (arg.contains("=")) {
+      } else if (arg.contains("=")) {
-        // if appendto-log-file is set, put it in options;  it is not set as an agent prop
+        // if appendto-log-file is set, put it in options; it is not set as an agent prop
-        // Note, the gfAgentPropertyFile System property is ultimately read in the constructor of the AgentImpl class
-        // in order to make any properties defined in this file not only accessible to the DistributedSystem but to
+        // Note, the gfAgentPropertyFile System property is ultimately read in the constructor of
+        // the AgentImpl class
+        // in order to make any properties defined in this file not only accessible to the
+        // DistributedSystem but to
-        // The Agent properties file (specified with the command-line key=value) is used to pass configuration settings
-        // to the GemFire DistributedSystem.  A property file can be passed using the property-file command-line switch
-        // is a large number of properties are specified, or the properties maybe individually specified on the
+        // The Agent properties file (specified with the command-line key=value) is used to pass
+        // configuration settings
+        // to the GemFire DistributedSystem. A property file can be passed using the property-file
+        // command-line switch
+        // is a large number of properties are specified, or the properties maybe individually
+        // specified on the
-   * After parsing the command line arguments, spawn the Java VM that will host the GemFire JMX Agent.
+   * After parsing the command line arguments, spawn the Java VM that will host the GemFire JMX
+   * Agent.
-    // verify that any GemFire JMX Agent process has been properly shutdown and delete any remaining status files...
+    // verify that any GemFire JMX Agent process has been properly shutdown and delete any remaining
+    // status files...
-    // it is also possible the Agent process may fail to start, so this should not wait indefinitely unless
+    // it is also possible the Agent process may fail to start, so this should not wait indefinitely
+    // unless
-      throw new IllegalStateException(LocalizedStrings.AgentLauncher_JMX_AGENT_EXISTS_BUT_WAS_NOT_SHUTDOWN.toLocalizedString());
+      throw new IllegalStateException(
+          LocalizedStrings.AgentLauncher_JMX_AGENT_EXISTS_BUT_WAS_NOT_SHUTDOWN.toLocalizedString());
-    final List<String> commands = JavaCommandBuilder.buildCommand(AgentLauncher.class.getName(), (String) options.get(CLASSPATH), null,
-      (List<String>) options.get(VMARGS));
+    final List<String> commands = JavaCommandBuilder.buildCommand(AgentLauncher.class.getName(),
+        (String) options.get(CLASSPATH), null, (List<String>) options.get(VMARGS));
-  private int runCommandLine(final Map<String, Object> options, final String[] commandLine) throws IOException {
-    // initialize the startup log starting with a fresh log file (where all startup messages are printed)
-    final File startLogFile = IOUtils.tryGetCanonicalFileElseGetAbsoluteFile(
-      new File(workingDirectory, startLogFileName));
+  private int runCommandLine(final Map<String, Object> options, final String[] commandLine)
+      throws IOException {
+    // initialize the startup log starting with a fresh log file (where all startup messages are
+    // printed)
+    final File startLogFile = IOUtils
+        .tryGetCanonicalFileElseGetAbsoluteFile(new File(workingDirectory, startLogFileName));
-      throw new IOException(LocalizedStrings.AgentLauncher_UNABLE_TO_DELETE_FILE_0.toLocalizedString(
-        startLogFile.getAbsolutePath()));
+      throw new IOException(LocalizedStrings.AgentLauncher_UNABLE_TO_DELETE_FILE_0
+          .toLocalizedString(startLogFile.getAbsolutePath()));
-    System.out.println(LocalizedStrings.AgentLauncher_STARTING_JMX_AGENT_WITH_PID_0.toLocalizedString(pid));
+    System.out.println(
+        LocalizedStrings.AgentLauncher_STARTING_JMX_AGENT_WITH_PID_0.toLocalizedString(pid));
-    // TODO this loop could recurse indefinitely if the GemFire JMX Agent's state never changes from STARTING
-    // to something else (like RUNNING), which could happen if server process fails to startup correctly
+    // TODO this loop could recurse indefinitely if the GemFire JMX Agent's state never changes from
+    // STARTING
+    // to something else (like RUNNING), which could happen if server process fails to startup
+    // correctly
-    // TODO should we really allow the InterruptedException from the Thread.sleep call to break this loop (yeah, I
+    // TODO should we really allow the InterruptedException from the Thread.sleep call to break this
+    // loop (yeah, I
-    }
-    else {
+    } else {
-    OSProcess.redirectOutput(new File(config.getLogFile())); // redirect output to the configured log file
+    OSProcess.redirectOutput(new File(config.getLogFile())); // redirect output to the configured
+                                                             // log file
-        @Override
-        public void uncaughtException(final Thread t, final Throwable e) {
-          if (e instanceof VirtualMachineError) {
-            SystemFailure.setFailure((VirtualMachineError) e);
-          }
-          setServerError(LocalizedStrings.AgentLauncher_UNCAUGHT_EXCEPTION_IN_THREAD_0.toLocalizedString(t.getName()), e);
+      @Override
+      public void uncaughtException(final Thread t, final Throwable e) {
+        if (e instanceof VirtualMachineError) {
+          SystemFailure.setFailure((VirtualMachineError) e);
-      };
+        setServerError(LocalizedStrings.AgentLauncher_UNCAUGHT_EXCEPTION_IN_THREAD_0
+            .toLocalizedString(t.getName()), e);
+      }
+    };
-        }
-        catch (IOException e) {
+        } catch (IOException e) {
-        }
-        catch (GemFireException e) {
+        } catch (GemFireException e) {
-        String message = LocalizedStrings.AgentLauncher_SERVER_FAILED_TO_START_0.toLocalizedString(e.getMessage());
+        String message = LocalizedStrings.AgentLauncher_SERVER_FAILED_TO_START_0
+            .toLocalizedString(e.getMessage());
-      writeStatus(createStatus(this.basename, SHUTDOWN_PENDING_AFTER_FAILED_STARTUP, OSProcess.getId(), message, cause));
-    }
-    catch (Exception e) {
+      writeStatus(createStatus(this.basename, SHUTDOWN_PENDING_AFTER_FAILED_STARTUP,
+          OSProcess.getId(), message, cause));
+    } catch (Exception e) {
-   * Extracts configuration information for stopping a agent based on the
-   * contents of the command line.  This method can also be used with getting
-   * the status of a agent.
+   * Extracts configuration information for stopping a agent based on the contents of the command
+   * line. This method can also be used with getting the status of a agent.
-      }
-      else if (arg.startsWith("-dir=")) {
+      } else if (arg.startsWith("-dir=")) {
-      }
-      else {
-        throw new Exception(LocalizedStrings.AgentLauncher_UNKNOWN_ARGUMENT_0.toLocalizedString(arg));
+      } else {
+        throw new Exception(
+            LocalizedStrings.AgentLauncher_UNKNOWN_ARGUMENT_0.toLocalizedString(arg));
-        System.out.println(LocalizedStrings.AgentLauncher_0_HAS_STOPPED.toLocalizedString(this.basename));
+        System.out
+            .println(LocalizedStrings.AgentLauncher_0_HAS_STOPPED.toLocalizedString(this.basename));
+      } else {
+        System.out
+            .println(LocalizedStrings.AgentLauncher_TIMEOUT_WAITING_FOR_0_TO_SHUTDOWN_STATUS_IS_1
+                .toLocalizedString(this.basename, status));
-      else {
-        System.out.println(LocalizedStrings.AgentLauncher_TIMEOUT_WAITING_FOR_0_TO_SHUTDOWN_STATUS_IS_1
-          .toLocalizedString(this.basename, status));
-      }
-    }
-    else {
-      System.out.println(LocalizedStrings.AgentLauncher_THE_SPECIFIED_WORKING_DIRECTORY_0_CONTAINS_NO_STATUS_FILE
-        .toLocalizedString(workingDirectory));
+    } else {
+      System.out.println(
+          LocalizedStrings.AgentLauncher_THE_SPECIFIED_WORKING_DIRECTORY_0_CONTAINS_NO_STATUS_FILE
+              .toLocalizedString(workingDirectory));
-    this.workingDirectory = IOUtils.tryGetCanonicalFileElseGetAbsoluteFile((File) getStopOptions(args).get(DIR));
+    this.workingDirectory =
+        IOUtils.tryGetCanonicalFileElseGetAbsoluteFile((File) getStopOptions(args).get(DIR));
-    }
-    else {
-      status = createStatus(this.basename, SHUTDOWN, 0, LocalizedStrings.AgentLauncher_0_IS_NOT_RUNNING_IN_SPECIFIED_WORKING_DIRECTORY_1
-        .toLocalizedString(this.basename, this.workingDirectory), null);
+    } else {
+      status = createStatus(this.basename, SHUTDOWN, 0,
+          LocalizedStrings.AgentLauncher_0_IS_NOT_RUNNING_IN_SPECIFIED_WORKING_DIRECTORY_1
+              .toLocalizedString(this.basename, this.workingDirectory),
+          null);
-   * Determines if the Status.state is one of the specified states in the given array of states.  Note, the status
-   * of the Agent, as indicated in the .agent.ser status file, should never have a written value of UNKNOWN.
+   * Determines if the Status.state is one of the specified states in the given array of states.
+   * Note, the status of the Agent, as indicated in the .agent.ser status file, should never have a
+   * written value of UNKNOWN.
-   * @param states an array of possible acceptable states satisfying the condition of the Agent's status.
-   * @return a boolean value indicating whether the Agent's status satisfies one of the specified states.
+   * 
+   * @param states an array of possible acceptable states satisfying the condition of the Agent's
+   *        status.
+   * @return a boolean value indicating whether the Agent's status satisfies one of the specified
+   *         states.
-    return (this.status != null && Arrays.asList(defaultToUnknownStateIfNull(states)).contains(this.status.state));
+    return (this.status != null
+        && Arrays.asList(defaultToUnknownStateIfNull(states)).contains(this.status.state));
-   * Reads the GemFire JMX Agent's status from the status file (.agent.ser) in it's working directory.
+   * Reads the GemFire JMX Agent's status from the status file (.agent.ser) in it's working
+   * directory.
-   * @return a Status object containing the state persisted to the .agent.ser file in the working directory
-   * and representing the status of the Agent
+   * 
+   * @return a Status object containing the state persisted to the .agent.ser file in the working
+   *         directory and representing the status of the Agent
-   * @throws RuntimeException if the class of the object written to the .agent.ser file is not of type Status.
+   * @throws RuntimeException if the class of the object written to the .agent.ser file is not of
+   *         type Status.
-    }
-    catch (ClassNotFoundException e) {
+    } catch (ClassNotFoundException e) {
-    }
-    finally {
+    } finally {
-   * A wrapper method for the readStatus method to make one last check for the GemFire JMX Agent process if running
-   * with the native libraries.
-   * @return the Status object as returned from readStatus unless running in native mode and a determination is made
-   * such that the Agent process is not running.
-   * @throws IOException if the state of the Agent process could not be read from the .agent.ser status file.
+   * A wrapper method for the readStatus method to make one last check for the GemFire JMX Agent
+   * process if running with the native libraries.
+   * 
+   * @return the Status object as returned from readStatus unless running in native mode and a
+   *         determination is made such that the Agent process is not running.
+   * @throws IOException if the state of the Agent process could not be read from the .agent.ser
+   *         status file.
-   * Reads the JMX Agent's status from the .agent.ser status file.  If the status file cannot be read due
-   * to I/O problems, the method will keep attempting to read the file for up to 20 seconds.
+   * Reads the JMX Agent's status from the .agent.ser status file. If the status file cannot be read
+   * due to I/O problems, the method will keep attempting to read the file for up to 20 seconds.
-   * @return the Status of the GemFire JMX Agent as determined by the .agent.ser status file, or natively
-   * based on the presence/absence of the Agent process.
+   * 
+   * @return the Status of the GemFire JMX Agent as determined by the .agent.ser status file, or
+   *         natively based on the presence/absence of the Agent process.
-      }
-      catch (Exception ignore) {
+      } catch (Exception ignore) {
-        // try again after a short delay... the status file might have been read prematurely before it existed
-        // or while the server was trying to write to it resulting in a possible EOFException, or other IOException.
+        // try again after a short delay... the status file might have been read prematurely before
+        // it existed
+        // or while the server was trying to write to it resulting in a possible EOFException, or
+        // other IOException.
-      }
-      finally {
+      } finally {
-   * Sets the status of the GemFire JMX Agent by serializing a <code>Status</code> object to a status file
-   * in the Agent's working directory.
+   * Sets the status of the GemFire JMX Agent by serializing a <code>Status</code> object to a
+   * status file in the Agent's working directory.
+   * 
-    }
-    finally {
+    } finally {
-  protected static Status createStatus(final String basename, final int state, final int pid, final String msg, final Throwable t) {
+  protected static Status createStatus(final String basename, final int state, final int pid,
+      final String msg, final Throwable t) {
-    return (states != null ? states : new Integer[] { UNKNOWN });
+    return (states != null ? states : new Integer[] {UNKNOWN});
-    }
-    catch (InterruptedException e) {
+    } catch (InterruptedException e) {
-  protected static File processDirOption(final Map<String, Object> options, final String dirValue) throws FileNotFoundException {
+  protected static File processDirOption(final Map<String, Object> options, final String dirValue)
+      throws FileNotFoundException {
-      throw new FileNotFoundException(LocalizedStrings.AgentLauncher_THE_INPUT_WORKING_DIRECTORY_DOES_NOT_EXIST_0
-        .toLocalizedString(dirValue));
+      throw new FileNotFoundException(
+          LocalizedStrings.AgentLauncher_THE_INPUT_WORKING_DIRECTORY_DOES_NOT_EXIST_0
+              .toLocalizedString(dirValue));
+   * 
-    out.println("\t" + LocalizedStrings.AgentLauncher_VMARG.toLocalizedString() );
+    out.println("\t" + LocalizedStrings.AgentLauncher_VMARG.toLocalizedString());
-    out.println(LocalizedStrings.AgentLauncher_REPORTS_THE_STATUS_AND_THE_PROCESS_ID_OF_A_GEMFIRE_JMX_AGENT.toLocalizedString());
+    out.println(
+        LocalizedStrings.AgentLauncher_REPORTS_THE_STATUS_AND_THE_PROCESS_ID_OF_A_GEMFIRE_JMX_AGENT
+            .toLocalizedString());
-   * Bootstrap method to launch the GemFire JMX Agent process to monitor and manage a GemFire Distributed System/Cache.
-   * Main will read the arguments passed on the command line and dispatch the command to the appropriate handler.
+   * Bootstrap method to launch the GemFire JMX Agent process to monitor and manage a GemFire
+   * Distributed System/Cache. Main will read the arguments passed on the command line and dispatch
+   * the command to the appropriate handler.
-    // TODO is this only needed on 'agent server'?  'agent {start|stop|status}' technically do no run any GemFire Cache
+    // TODO is this only needed on 'agent server'? 'agent {start|stop|status}' technically do no run
+    // any GemFire Cache
-      }
-      else if (command.equalsIgnoreCase("server")) {
+      } else if (command.equalsIgnoreCase("server")) {
-      }
-      else if (command.equalsIgnoreCase("stop")) {
+      } else if (command.equalsIgnoreCase("stop")) {
-      }
-      else if (command.equalsIgnoreCase("status")) {
+      } else if (command.equalsIgnoreCase("status")) {
-      }
-      else if (command.toLowerCase().matches("-{0,2}help")) {
+      } else if (command.toLowerCase().matches("-{0,2}help")) {
-          }
-          else {
+          } else {
-      }
-      else {
+      } else {
-    }
-    catch (VirtualMachineError e) {
+    } catch (VirtualMachineError e) {
-    }
-    catch (Throwable t) {
+    } catch (Throwable t) {
-      System.err.println(LocalizedStrings.AgentLauncher_ERROR_0.toLocalizedString(t.getLocalizedMessage()));
+      System.err.println(
+          LocalizedStrings.AgentLauncher_ERROR_0.toLocalizedString(t.getLocalizedMessage()));
-   * A class representing the current state of the GemFire JMX Agent process.  Instances of this class are serialized
-   * to a {@linkplain #statusFileName file} on disk in the specified working directory {@linkplain #workingDirectory}.
+   * A class representing the current state of the GemFire JMX Agent process. Instances of this
+   * class are serialized to a {@linkplain #statusFileName file} on disk in the specified working
+   * directory {@linkplain #workingDirectory}.
+   * 
-      }
-      else {
-        buffer.append(LocalizedStrings.AgentLauncher_0_PID_1_STATUS.toLocalizedString(this.baseName, pid));
+      } else {
+        buffer.append(
+            LocalizedStrings.AgentLauncher_0_PID_1_STATUS.toLocalizedString(this.baseName, pid));
-            buffer.append(LocalizedStrings.AgentLauncher_SHUTDOWN_PENDING_AFTER_FAILED_STARTUP.toLocalizedString());
+            buffer.append(LocalizedStrings.AgentLauncher_SHUTDOWN_PENDING_AFTER_FAILED_STARTUP
+                .toLocalizedString());
-          }
-          else {
+          } else {
-              .toLocalizedString(this.baseName, exception.getMessage()) + " - ");
+                .toLocalizedString(this.baseName, exception.getMessage()) + " - ");
-          buffer.append(LocalizedStrings.AgentLauncher_SEE_LOG_FILE_FOR_DETAILS.toLocalizedString());
+          buffer
+              .append(LocalizedStrings.AgentLauncher_SEE_LOG_FILE_FOR_DETAILS.toLocalizedString());

Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This program merges entries from multiple GemFire log files (those
- * written using a {@link org.apache.geode.i18n.LogWriterI18n} together,
- * sorting them by their timestamp.  Note that this program assumes
- * that the entries in the individual log files are themselves sorted
- * by timestamp.<p>
+ * This program merges entries from multiple GemFire log files (those written using a
+ * {@link org.apache.geode.i18n.LogWriterI18n} together, sorting them by their timestamp. Note that
+ * this program assumes that the entries in the individual log files are themselves sorted by
+ * timestamp.
+ * <p>
- * <b>-pids</b> tells the program to look for hydra-style naming and pick out
- * process identifiers, then use these to distinguish log entries instead of
- * full log file names.<br>
+ * <b>-pids</b> tells the program to look for hydra-style naming and pick out process identifiers,
+ * then use these to distinguish log entries instead of full log file names.<br>
- * <b>-dirCount x</b> when <i>-pids</i> is not being used, or it is being used
- * and a process ID can't be found, the <i>-dirCount</i> option instructs the
- * program as to how many parent directory names should be included in the name
- * of each log file.<br>
+ * <b>-dirCount x</b> when <i>-pids</i> is not being used, or it is being used and a process ID
+ * can't be found, the <i>-dirCount</i> option instructs the program as to how many parent directory
+ * names should be included in the name of each log file.<br>
- * <b>-align</b> tells the program to align log content not having timestamps with
- * log content that does have timestamps.<br>
+ * <b>-align</b> tells the program to align log content not having timestamps with log content that
+ * does have timestamps.<br>
- * <b>-threads</b> tells the program to attempt to make use of multiple CPUs<p>
+ * <b>-threads</b> tells the program to attempt to make use of multiple CPUs
+ * <p>
- * The <i>-pids</i> option will cause a file nickname table to be built and
- * emitted at the beginning of the merged log files.  Nicknames are of the
- * form pid-x, where <i>pid</i> is the process ID that emitted the log entry, and
- * <i>x</i> is the position of this log file in the ordered set of log files
- * created by that process.<p>
+ * The <i>-pids</i> option will cause a file nickname table to be built and emitted at the beginning
+ * of the merged log files. Nicknames are of the form pid-x, where <i>pid</i> is the process ID that
+ * emitted the log entry, and <i>x</i> is the position of this log file in the ordered set of log
+ * files created by that process.
+ * <p>
- * Normally, one log file reader is created per log file, and they are iterated
- * over repeatedly to find and write the next earliest timestamped line to
- * the output stream.  Text without a timestamp is associated with the prior
- * timestamped line in the file.<p>
+ * Normally, one log file reader is created per log file, and they are iterated over repeatedly to
+ * find and write the next earliest timestamped line to the output stream. Text without a timestamp
+ * is associated with the prior timestamped line in the file.
+ * <p>
- * The <i>-threads</i> option will cause the program to also create threads
- * for each reader that are backed by bounded {@link BlockingQueue queues},
- * as outlined in the diagram below.  This can consume more memory, so it is
- * wise to increase the Xmx of the java virtual machine if you are going to
- * use this option.<p>
+ * The <i>-threads</i> option will cause the program to also create threads for each reader that are
+ * backed by bounded {@link BlockingQueue queues}, as outlined in the diagram below. This can
+ * consume more memory, so it is wise to increase the Xmx of the java virtual machine if you are
+ * going to use this option.
+ * <p>
- * <CENTER>
- * <IMG SRC="{@docRoot}/javadoc-images/merge-log-files.gif"
- *      WIDTH="353" HEIGHT="246"/>
+ * <CENTER> <IMG SRC="{@docRoot}/javadoc-images/merge-log-files.gif" WIDTH="353" HEIGHT="246"/>
-   * Merges the log files from a given set of
-   * <code>InputStream</code>s into a <code>PrinWriter</code>.
+   * Merges the log files from a given set of <code>InputStream</code>s into a
+   * <code>PrinWriter</code>.
-   * @param logFiles
-   *        The log files to be merged
-   * @param logFileNames
-   *        The names of the log files to be printed in the merged log
-   * @param mergedFile
-   *        Where the merged logs are printed to
+   * @param logFiles The log files to be merged
+   * @param logFileNames The names of the log files to be printed in the merged log
+   * @param mergedFile Where the merged logs are printed to
-   * @return Whether or not problems occurred while merging the log
-   *         files. 
+   * @return Whether or not problems occurred while merging the log files.
-   * @throws IllegalArgumentException
-   *         If the length of <code>logFiles</code> is not the same
-   *         as the length of <code>logFileNames</code>
+   * @throws IllegalArgumentException If the length of <code>logFiles</code> is not the same as the
+   *         length of <code>logFileNames</code>
-  public static boolean mergeLogFiles(InputStream[] logFiles,
-      String[] logFileNames, PrintWriter mergedFile) {
+  public static boolean mergeLogFiles(InputStream[] logFiles, String[] logFileNames,
+      PrintWriter mergedFile) {
-  
+
-   * Merges the log files from a given set of
-   * <code>InputStream</code>s into a <code>PrinWriter</code>.
+   * Merges the log files from a given set of <code>InputStream</code>s into a
+   * <code>PrinWriter</code>.
-   * @param logFiles
-   *        The log files to be merged
-   * @param logFileNames
-   *        The names of the log files to be printed in the merged log
-   * @param mergedFile
-   *        Where the merged logs are printed to
-   * @param tabOut
-   *        Whether to align non-timestamped lines with timestamped lines
-   * @param suppressBlanks
-   *        Whether to omit blank lines
-   * @param patterns
-   *        Regular expression patterns that lines must match to be included
-   * @return Whether or not problems occurred while merging the log
-   *         files. 
+   * @param logFiles The log files to be merged
+   * @param logFileNames The names of the log files to be printed in the merged log
+   * @param mergedFile Where the merged logs are printed to
+   * @param tabOut Whether to align non-timestamped lines with timestamped lines
+   * @param suppressBlanks Whether to omit blank lines
+   * @param patterns Regular expression patterns that lines must match to be included
+   * @return Whether or not problems occurred while merging the log files.
-   * @throws IllegalArgumentException
-   *         If the length of <code>logFiles</code> is not the same
-   *         as the length of <code>logFileNames</code>
+   * @throws IllegalArgumentException If the length of <code>logFiles</code> is not the same as the
+   *         length of <code>logFileNames</code>
-  public static boolean mergeLogFiles(InputStream[] logFiles,
-      String[] logFileNames, PrintWriter mergedFile,
-      boolean tabOut, boolean suppressBlanks, boolean multithreaded, List<String> patterns) {
-    return Sorter.mergeLogFiles(logFiles, logFileNames, mergedFile,
-        tabOut, suppressBlanks, multithreaded, patterns);
+  public static boolean mergeLogFiles(InputStream[] logFiles, String[] logFileNames,
+      PrintWriter mergedFile, boolean tabOut, boolean suppressBlanks, boolean multithreaded,
+      List<String> patterns) {
+    return Sorter.mergeLogFiles(logFiles, logFileNames, mergedFile, tabOut, suppressBlanks,
+        multithreaded, patterns);
-  
+
-    err.println(LocalizedStrings.MergeLogFiles_USAGE.toLocalizedString() + ": java MergeLogFiles [(directory | logFile)]+");
-    err.println("-dirCount n      " + LocalizedStrings.MergeLogFiles_NUMBER_OF_PARENT_DIRS_TO_PRINT.toLocalizedString());
-    err.println("-mergeFile file  " + LocalizedStrings.MergeLogFiles_FILE_IN_WHICH_TO_PUT_MERGED_LOGS.toLocalizedString());
-    err.println("-pids            " + LocalizedStrings.MergeLogFiles_SEARCH_FOR_PIDS_IN_FILE_NAMES_AND_USE_THEM_TO_IDENTIFY_FILES.toLocalizedString());
-    err.println("-align           " + LocalizedStrings.MergeLogFiles_ALIGN_NONTIMESTAMPED_LINES_WITH_OTHERS.toLocalizedString());
-    err.println("-noblanks        " + LocalizedStrings.MergeLogFiles_SUPPRESS_OUTPUT_OF_BLANK_LINES.toLocalizedString());
-    err.println("-threaded        " + LocalizedStrings.MergeLogFiles_USE_MULTITHREADING_TO_TAKE_ADVANTAGE_OF_MULTIPLE_CPUS.toLocalizedString());
-//    err.println("-regex  pattern   Case-insensitive search for a regular expression.");
-//    err.println("                 May be used multiple times.  Use Java regular ");
-//    err.println("                 expression syntax (see java.util.regex.Pattern).");
+    err.println(LocalizedStrings.MergeLogFiles_USAGE.toLocalizedString()
+        + ": java MergeLogFiles [(directory | logFile)]+");
+    err.println("-dirCount n      "
+        + LocalizedStrings.MergeLogFiles_NUMBER_OF_PARENT_DIRS_TO_PRINT.toLocalizedString());
+    err.println("-mergeFile file  "
+        + LocalizedStrings.MergeLogFiles_FILE_IN_WHICH_TO_PUT_MERGED_LOGS.toLocalizedString());
+    err.println("-pids            "
+        + LocalizedStrings.MergeLogFiles_SEARCH_FOR_PIDS_IN_FILE_NAMES_AND_USE_THEM_TO_IDENTIFY_FILES
+            .toLocalizedString());
+    err.println(
+        "-align           " + LocalizedStrings.MergeLogFiles_ALIGN_NONTIMESTAMPED_LINES_WITH_OTHERS
+            .toLocalizedString());
+    err.println("-noblanks        "
+        + LocalizedStrings.MergeLogFiles_SUPPRESS_OUTPUT_OF_BLANK_LINES.toLocalizedString());
+    err.println("-threaded        "
+        + LocalizedStrings.MergeLogFiles_USE_MULTITHREADING_TO_TAKE_ADVANTAGE_OF_MULTIPLE_CPUS
+            .toLocalizedString());
+    // err.println("-regex pattern Case-insensitive search for a regular expression.");
+    // err.println(" May be used multiple times. Use Java regular ");
+    // err.println(" expression syntax (see java.util.regex.Pattern).");
-    err.println(LocalizedStrings.MergeLogFiles_MERGES_MULTIPLE_GEMFIRE_LOG_FILES_AND_SORTS_THEM_BY_TIMESTAMP.toLocalizedString());
-    err.println(LocalizedStrings.MergeLogFiles_THE_MERGED_LOG_FILE_IS_WRITTEN_TO_SYSTEM_OUT_OR_A_FILE.toLocalizedString());
+    err.println(
+        LocalizedStrings.MergeLogFiles_MERGES_MULTIPLE_GEMFIRE_LOG_FILES_AND_SORTS_THEM_BY_TIMESTAMP
+            .toLocalizedString());
+    err.println(
+        LocalizedStrings.MergeLogFiles_THE_MERGED_LOG_FILE_IS_WRITTEN_TO_SYSTEM_OUT_OR_A_FILE
+            .toLocalizedString());
-    err.println(LocalizedStrings.MergeLogFiles_IF_A_DIRECTORY_IS_SPECIFIED_ALL_LOG_FILES_IN_THAT_DIRECTORY_ARE_MERGED.toLocalizedString());
+    err.println(
+        LocalizedStrings.MergeLogFiles_IF_A_DIRECTORY_IS_SPECIFIED_ALL_LOG_FILES_IN_THAT_DIRECTORY_ARE_MERGED
+            .toLocalizedString());
+   * 
-    
+
-    for (int i = 0; i < names.length; i ++) {
+    for (int i = 0; i < names.length; i++) {
-  
+
-    
+
-      }
-      else if (args[i].equals("-noblanks")) {
+      } else if (args[i].equals("-noblanks")) {
-      }
-      else if (args[i].equals("-pids")) {
+      } else if (args[i].equals("-pids")) {
-      }
-      else if (args[i].equals("-threaded")) {
+      } else if (args[i].equals("-threaded")) {
-      }
-      else if (args[i].equals("-regex")) {
-        if (i+1 >= args.length) {
+      } else if (args[i].equals("-regex")) {
+        if (i + 1 >= args.length) {
-        patterns.add(args[i+1]);
+        patterns.add(args[i + 1]);
-      }
-      else if (args[i].equals("-dirCount")) {
+      } else if (args[i].equals("-dirCount")) {
-          usage(LocalizedStrings.MergeLogFiles_MISSING_NUMBER_OF_PARENT_DIRECTORIES.toLocalizedString());
+          usage(LocalizedStrings.MergeLogFiles_MISSING_NUMBER_OF_PARENT_DIRECTORIES
+              .toLocalizedString());
-    if ( files.isEmpty() ) {
+    if (files.isEmpty()) {
-    for (int i = 0; i <  files.size(); i ++) {
-      File f = (File)files.get(i);
+    for (int i = 0; i < files.size(); i++) {
+      File f = (File) files.get(i);
-       ArrayList moreFiles = getLogFiles(n);
-       expandedFiles.addAll(moreFiles);
-       continue; 
+        ArrayList moreFiles = getLogFiles(n);
+        expandedFiles.addAll(moreFiles);
+        continue;
-      usage(LocalizedStrings.MergeLogFiles_FILE_0_IS_NEITHER_A_FILE_NOR_A_DIRECTORY.toLocalizedString(n));
+      usage(LocalizedStrings.MergeLogFiles_FILE_0_IS_NEITHER_A_FILE_NOR_A_DIRECTORY
+          .toLocalizedString(n));
-    
+
-    for (int i = 0; i < expandedFiles.size(); i ++) {
+    for (int i = 0; i < expandedFiles.size(); i++) {
-    
+
-      if (findPIDs  &&  (nickNames.get(i) != null)) {
+      if (findPIDs && (nickNames.get(i) != null)) {
-          logFileNames[i] = (String)nickNames.get(i)+".gz";
+          logFileNames[i] = (String) nickNames.get(i) + ".gz";
-          logFileNames[i] = (String)nickNames.get(i);
+          logFileNames[i] = (String) nickNames.get(i);
-      }
-      else {
+      } else {
-        }                    
+        }
-  
+
-    
-    mergeLogFiles(logFiles, logFileNames, mergedFile, tabOut, suppressBlanks,
-        multithreaded, patterns);
+
+    mergeLogFiles(logFiles, logFileNames, mergedFile, tabOut, suppressBlanks, multithreaded,
+        patterns);
-  //////////////////////  Inner Classes  //////////////////////
+  ////////////////////// Inner Classes //////////////////////
-   * hydra log files usually have the process's PID in their path name.
-   * This method extracts the PID number and assigns the corresponding File
-   * a nickname using the PID and the position of the File in the list of those
-   * also having this PID.<p>
-   * e.g., bgexec32414_1043.log          --> 1043-1<br>
-   *       gemfire_1043/system.log       --> 1043-2<br>
-   *       gemfire_1043/system_01_00.log --> 1043-3<br>
+   * hydra log files usually have the process's PID in their path name. This method extracts the PID
+   * number and assigns the corresponding File a nickname using the PID and the position of the File
+   * in the list of those also having this PID.
+   * <p>
+   * e.g., bgexec32414_1043.log --> 1043-1<br>
+   * gemfire_1043/system.log --> 1043-2<br>
+   * gemfire_1043/system_01_00.log --> 1043-3<br>
-//    System.out.println("findPids() invoked");
-    
-    for (Iterator it=files.iterator(); it.hasNext(); ) {
-      File f = (File)it.next();
+    // System.out.println("findPids() invoked");
+
+    for (Iterator it = files.iterator(); it.hasNext();) {
+      File f = (File) it.next();
-//      System.out.println("considering " + name);
-      
+      // System.out.println("considering " + name);
+
-      
+
-      
+
-        if ( ! ('0' <= c  &&  c <= '9') ) {
-//          System.out.println("no number found in directory name");
+        if (!('0' <= c && c <= '9')) {
+          // System.out.println("no number found in directory name");
-        }
-        else {
+        } else {
-          int testIdx = startIdx-1;
+          int testIdx = startIdx - 1;
-//          System.out.println("using directory name: '" + name.substring(0, startIdx+1) + "'");
+          // System.out.println("using directory name: '" + name.substring(0, startIdx+1) + "'");
-      
+
-        if (startIdx > 6
-            && name.charAt(startIdx) == 'z'
-            && name.charAt(startIdx-1) == 'g'
-            && name.charAt(startIdx-2) == '.'
-            && name.charAt(startIdx-3) == 'g'
-            && name.charAt(startIdx-4) == 'o'
-            && name.charAt(startIdx-5) == 'l'
-            && name.charAt(startIdx-6) == '.') {
+        if (startIdx > 6 && name.charAt(startIdx) == 'z' && name.charAt(startIdx - 1) == 'g'
+            && name.charAt(startIdx - 2) == '.' && name.charAt(startIdx - 3) == 'g'
+            && name.charAt(startIdx - 4) == 'o' && name.charAt(startIdx - 5) == 'l'
+            && name.charAt(startIdx - 6) == '.') {
-        }
-        else if (startIdx > 3
-            && name.charAt(startIdx) == 'g'
-            && name.charAt(startIdx-1) == 'o'
-            && name.charAt(startIdx-2) == 'l'
-            && name.charAt(startIdx-3) == '.') {
+        } else if (startIdx > 3 && name.charAt(startIdx) == 'g' && name.charAt(startIdx - 1) == 'o'
+            && name.charAt(startIdx - 2) == 'l' && name.charAt(startIdx - 3) == '.') {
-//          System.out.println("using file name: '" + name.substring(0,startIdx+1) + "'");
+          // System.out.println("using file name: '" + name.substring(0,startIdx+1) + "'");
-//        else {
-//          System.out.println("could not find a PID");
-//        }
+        // else {
+        // System.out.println("could not find a PID");
+        // }
-      
+
-      for (int i=startIdx; i>=0; i--) {
+      for (int i = startIdx; i >= 0; i--) {
-//        System.out.println("charAt("+i+")="+c);
-        if ( ! ('0' <= c  &&  c <= '9') ) {
-          if (i < (name.length()-1)) { // have a number
+        // System.out.println("charAt("+i+")="+c);
+        if (!('0' <= c && c <= '9')) {
+          if (i < (name.length() - 1)) { // have a number
-            PID = name.substring(i+1, startIdx+1);
-//            System.out.println("parsing '" + PID + "'");
+            PID = name.substring(i + 1, startIdx + 1);
+            // System.out.println("parsing '" + PID + "'");
-//                System.out.println("Found PID " + iPID);
+                // System.out.println("Found PID " + iPID);
-                // a new slot.  increment the number of files for this PID and
+                // a new slot. increment the number of files for this PID and
-                for ( ; p<pidTable.length; p++) {
+                for (; p < pidTable.length; p++) {
-                  }
-                  else if (pidTable[p] == iPID) {
+                  } else if (pidTable[p] == iPID) {
-                nickNames.add(""+iPID+"-"+pidTableCounter[p]);
-                output.println("nickname " + iPID + "-" + pidTableCounter[p] + ": " + name); 
-              }
-              else {
+                nickNames.add("" + iPID + "-" + pidTableCounter[p]);
+                output.println("nickname " + iPID + "-" + pidTableCounter[p] + ": " + name);
+              } else {
-            }
-            catch (NumberFormatException nfe) {
+            } catch (NumberFormatException nfe) {
+
+
+
+
-  
-  
+
+
-   * Thread that reads an entry from a GemFire log file and adds it a
-   * bounded queue.  The entries are consumed by a {@link
-   * MergeLogFiles.Sorter}.
+   * Thread that reads an entry from a GemFire log file and adds it a bounded queue. The entries are
+   * consumed by a {@link MergeLogFiles.Sorter}.
-//    private static int QUEUE_CAPACITY = 1000;
+    // private static int QUEUE_CAPACITY = 1000;
-    ////////////////////  Instance Methods  ////////////////////
+    //////////////////// Instance Methods ////////////////////
-//    private boolean suppressBlanks;
-    
+    // private boolean suppressBlanks;
+
-//    private boolean tabOut;
+    // private boolean tabOut;
-    
+
-    ////////////////////  Constructors  ////////////////////
+    //////////////////// Constructors ////////////////////
-     * Creates a new <code>Reader</code> that reads from the given log
-     * file with the given name.  Invoking this constructor will start
-     * this reader thread.
+     * Creates a new <code>Reader</code> that reads from the given log file with the given name.
+     * Invoking this constructor will start this reader thread.
+     * 
-    public NonThreadedReader(InputStream logFile, String logFileName,
-                  ThreadGroup group, boolean tabOut, boolean suppressBlanks, List<Pattern> patterns) {
-//         super(group, "Reader for " + ((logFileName != null) ? logFileName : logFile.toString()));
+    public NonThreadedReader(InputStream logFile, String logFileName, ThreadGroup group,
+        boolean tabOut, boolean suppressBlanks, List<Pattern> patterns) {
+      // super(group, "Reader for " + ((logFileName != null) ? logFileName : logFile.toString()));
-        this.logFile =
-          new BufferedReader(new InputStreamReader(logFile));
+        this.logFile = new BufferedReader(new InputStreamReader(logFile));
-//      this.suppressBlanks = suppressBlanks;
-//      this.tabOut = tabOut;
+      // this.suppressBlanks = suppressBlanks;
+      // this.tabOut = tabOut;
-                
+
-    
+
+
+
-                
+
-     * Peeks at the oldest log entry read from the log file, waits for
-     * a log entry to become available.
+     * Peeks at the oldest log entry read from the log file, waits for a log entry to become
+     * available.
-        }
-        catch (IOException ioe) {
+        } catch (IOException ioe) {
-    
+
-      for (Pattern p: patterns) {
+      for (Pattern p : patterns) {
-      }
-      else {
+      } else {
-          }
-          catch (IOException ioe) {
+          } catch (IOException ioe) {
-   * Thread that reads an entry from a GemFire log file and adds it a
-   * bounded queue.  The entries are consumed by a {@link
-   * MergeLogFiles.Sorter}.
+   * Thread that reads an entry from a GemFire log file and adds it a bounded queue. The entries are
+   * consumed by a {@link MergeLogFiles.Sorter}.
-    ////////////////////  Instance Methods  ////////////////////
+    //////////////////// Instance Methods ////////////////////
-    
+
-    
+
-    ////////////////////  Constructors  ////////////////////
+    //////////////////// Constructors ////////////////////
-     * Creates a new <code>Reader</code> that reads from the given log
-     * file with the given name.  Invoking this constructor will start
-     * this reader thread.
+     * Creates a new <code>Reader</code> that reads from the given log file with the given name.
+     * Invoking this constructor will start this reader thread.
+     * 
-    public ThreadedReader(InputStream logFile, String logFileName,
-                  ThreadGroup group, boolean tabOut, boolean suppressBlanks, List<Pattern> patterns) {
-//       super(group, "Reader for " + ((logFileName != null) ? logFileName : logFile.toString()));
+    public ThreadedReader(InputStream logFile, String logFileName, ThreadGroup group,
+        boolean tabOut, boolean suppressBlanks, List<Pattern> patterns) {
+      // super(group, "Reader for " + ((logFileName != null) ? logFileName : logFile.toString()));
-        this.logFile =
-          new BufferedReader(new InputStreamReader(logFile));
+        this.logFile = new BufferedReader(new InputStreamReader(logFile));
-//        new UnsharedMessageQueue(QUEUE_CAPACITY,
-//                                 (75 * QUEUE_CAPACITY) / 100);
+      // new UnsharedMessageQueue(QUEUE_CAPACITY,
+      // (75 * QUEUE_CAPACITY) / 100);
-    
+
-                
+
-    
+
-                
+
-     * Reads the log file and places {@link LogFileParser.LogEntry}
-     * objects into the queue.  When it is finished, it places a
-     * <code>LogEntry</code> that whose {@link
-     * LogFileParser.LogEntry#isLast isLast} method will return
-     * <code>true</code>.
-     */ 
+     * Reads the log file and places {@link LogFileParser.LogEntry} objects into the queue. When it
+     * is finished, it places a <code>LogEntry</code> that whose
+     * {@link LogFileParser.LogEntry#isLast isLast} method will return <code>true</code>.
+     */
-        new LogFileParser(this.logFileName, this.logFile, tabOut, suppressBlanks);
+          new LogFileParser(this.logFileName, this.logFile, tabOut, suppressBlanks);
-      for (Pattern p: patterns) {
+      for (Pattern p : patterns) {
-     * Peeks at the oldest log entry read from the log file, waits for
-     * a log entry to become available.
+     * Peeks at the oldest log entry read from the log file, waits for a log entry to become
+     * available.
-//       out.println(this.getName() + " size " + this.queue.size());
-      LogFileParser.LogEntry entry =
-        (LogFileParser.LogEntry) this.queue.peek();
+      // out.println(this.getName() + " size " + this.queue.size());
+      LogFileParser.LogEntry entry = (LogFileParser.LogEntry) this.queue.peek();
-            }
-            catch (InterruptedException e) {
+            } catch (InterruptedException e) {
-            }
-            finally {
+            } finally {
-   * A thread group that contains the reader threads and logs uncaught
-   * exceptions to standard error.
+   * A thread group that contains the reader threads and logs uncaught exceptions to standard error.
-        SystemFailure.setFailure((VirtualMachineError)e); // don't throw
+        SystemFailure.setFailure((VirtualMachineError) e); // don't throw
-     * Returns whether or not an uncaught exception occurred in one of
-     * the threads in this group.
+     * Returns whether or not an uncaught exception occurred in one of the threads in this group.
-   * Examines the {@link MergeLogFiles.Reader#peek oldest entry} in
-   * each log file and writes it to a merged log file.
+   * Examines the {@link MergeLogFiles.Reader#peek oldest entry} in each log file and writes it to a
+   * merged log file.
-     * Merges the log files from a given set of
-     * <code>InputStream</code>s into a <code>PrintWriter</code>.
+     * Merges the log files from a given set of <code>InputStream</code>s into a
+     * <code>PrintWriter</code>.
-     * @param logFiles
-     *        The log files to be merged
-     * @param logFileNames
-     *        The names of the log files to be printed in the merged log
-     * @param mergedFile
-     *        Where the merged logs are printed to
-     * @param tabOut
-     *        Whether to align non-timestamped lines with others
-     * @param suppressBlanks
-     *        Whether to suppress output of blank lines
+     * @param logFiles The log files to be merged
+     * @param logFileNames The names of the log files to be printed in the merged log
+     * @param mergedFile Where the merged logs are printed to
+     * @param tabOut Whether to align non-timestamped lines with others
+     * @param suppressBlanks Whether to suppress output of blank lines
-     * @return Whether or not problems occurred while merging the log
-     *         files. 
+     * @return Whether or not problems occurred while merging the log files.
-     * @throws IllegalArgumentException
-     *         If the length of <code>logFiles</code> is not the same
-     *         as the length of <code>logFileNames</code>
+     * @throws IllegalArgumentException If the length of <code>logFiles</code> is not the same as
+     *         the length of <code>logFileNames</code>
-    public static boolean mergeLogFiles(InputStream[] logFiles,
-        String[] logFileNames, PrintWriter mergedFile,
-        boolean tabOut, boolean suppressBlanks, boolean multithreaded, List<String> patterns) {
+    public static boolean mergeLogFiles(InputStream[] logFiles, String[] logFileNames,
+        PrintWriter mergedFile, boolean tabOut, boolean suppressBlanks, boolean multithreaded,
+        List<String> patterns) {
-        throw new IllegalArgumentException(LocalizedStrings.MergeLogFiles_NUMBER_OF_LOG_FILES_0_IS_NOT_THE_SAME_AS_THE_NUMBER_OF_LOG_FILE_NAMES_1.toLocalizedString(new Object[] {Integer.valueOf(logFiles.length), Integer.valueOf(logFileNames.length)}));
+        throw new IllegalArgumentException(
+            LocalizedStrings.MergeLogFiles_NUMBER_OF_LOG_FILES_0_IS_NOT_THE_SAME_AS_THE_NUMBER_OF_LOG_FILE_NAMES_1
+                .toLocalizedString(new Object[] {Integer.valueOf(logFiles.length),
+                    Integer.valueOf(logFileNames.length)}));
-      
+
-      for (String pattern: patterns) {
+      for (String pattern : patterns) {
-      ReaderGroup group = new ReaderGroup(LocalizedStrings.MergeLogFiles_READER_THREADS.toLocalizedString());
+      ReaderGroup group =
+          new ReaderGroup(LocalizedStrings.MergeLogFiles_READER_THREADS.toLocalizedString());
-          readers.add(new ThreadedReader(logFiles[i], logFileNames[i], group,
-              tabOut, suppressBlanks, compiledPatterns));
-        }
-        else {
-          readers.add(new NonThreadedReader(logFiles[i], logFileNames[i], group,
-              tabOut, suppressBlanks, compiledPatterns));
+          readers.add(new ThreadedReader(logFiles[i], logFileNames[i], group, tabOut,
+              suppressBlanks, compiledPatterns));
+        } else {
+          readers.add(new NonThreadedReader(logFiles[i], logFileNames[i], group, tabOut,
+              suppressBlanks, compiledPatterns));
-      
+
-        oldest = (Reader)sortedIt.next();
+        oldest = (Reader) sortedIt.next();
-          nextInLine = (Reader)sortedIt.next();
+          nextInLine = (Reader) sortedIt.next();
-        
+
-          
+
-        
+
-    
+
-      for (Iterator iter = readers.iterator(); iter.hasNext(); ) {
-        Reader reader = (Reader)iter.next();
+      for (Iterator iter = readers.iterator(); iter.hasNext();) {
+        Reader reader = (Reader) iter.next();
-  
+
-      Reader reader1 = (Reader)o1;
+      Reader reader1 = (Reader) o1;
-      Reader reader2 = (Reader)o2;
+      Reader reader2 = (Reader) o2;
-  
+

Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class PRFunctionStreamingResultCollector extends  FunctionStreamingResultCollector implements
-    ResultCollector {
+public class PRFunctionStreamingResultCollector extends FunctionStreamingResultCollector
+    implements ResultCollector {
-  
-  private boolean hasResult = false ;
-  
+
+  private boolean hasResult = false;
+
+
-   * Contract of {@link ReplyProcessor21#stillWaiting()} is that it never
-   * returns true after returning false.
+   * Contract of {@link ReplyProcessor21#stillWaiting()} is that it never returns true after
+   * returning false.
-  
+
-      InternalDistributedSystem system, Set<InternalDistributedMember> members,
-      ResultCollector rc, Function functionObject, PartitionedRegion pr,
-      AbstractExecution execution) {
-    super(partitionedRegionFunctionResultWaiter, system, members, rc,
-        functionObject, execution);
+      InternalDistributedSystem system, Set<InternalDistributedMember> members, ResultCollector rc,
+      Function functionObject, PartitionedRegion pr, AbstractExecution execution) {
+    super(partitionedRegionFunctionResultWaiter, system, members, rc, functionObject, execution);
-  
+
-  public void addResult(DistributedMember memId , Object resultOfSingleExecution) {
-    if(!this.endResultRecieved){
+  public void addResult(DistributedMember memId, Object resultOfSingleExecution) {
+    if (!this.endResultRecieved) {
-        resultOfSingleExecution = ((InternalFunctionException)resultOfSingleExecution)
-            .getCause();
+        resultOfSingleExecution = ((InternalFunctionException) resultOfSingleExecution).getCause();
-    if(this.resultCollected ){
+    if (this.resultCollected) {
-    
+
-        if (!this.execution.getFailedNodes().isEmpty()
-            && !this.execution.isClientServerMode()) {
+        if (!this.execution.getFailedNodes().isEmpty() && !this.execution.isClientServerMode()) {
-          }
-          else {
+          } else {
-      }
-      catch (FunctionInvocationTargetException fite) {
+      } catch (FunctionInvocationTargetException fite) {
-        if(!execution.getWaitOnExceptionFlag()) {
-        if (!this.fn.isHA()) {
-          throw new FunctionException(fite);
-        }
-        else if (execution.isClientServerMode()) {
-          clearResults();
-          FunctionInvocationTargetException iFITE = new InternalFunctionInvocationTargetException(
-              fite.getMessage(), this.execution.getFailedNodes());
-          throw new FunctionException(iFITE);
-        }
-        else {
-          clearResults();
-          this.execution = this.execution.setIsReExecute();
-          ResultCollector newRc = null;
-          if (execution.isFnSerializationReqd()) {
-            newRc = this.execution.execute(this.fn);
+        if (!execution.getWaitOnExceptionFlag()) {
+          if (!this.fn.isHA()) {
+            throw new FunctionException(fite);
+          } else if (execution.isClientServerMode()) {
+            clearResults();
+            FunctionInvocationTargetException iFITE = new InternalFunctionInvocationTargetException(
+                fite.getMessage(), this.execution.getFailedNodes());
+            throw new FunctionException(iFITE);
+          } else {
+            clearResults();
+            this.execution = this.execution.setIsReExecute();
+            ResultCollector newRc = null;
+            if (execution.isFnSerializationReqd()) {
+              newRc = this.execution.execute(this.fn);
+            } else {
+              newRc = this.execution.execute(this.fn.getId());
+            }
+            return newRc.getResult();
-          else {
-            newRc = this.execution.execute(this.fn.getId());
+        }
+      } catch (BucketMovedException e) {
+        if (!execution.getWaitOnExceptionFlag()) {
+          if (!this.fn.isHA()) {
+            // endResults();
+            FunctionInvocationTargetException fite =
+                new FunctionInvocationTargetException(e.getMessage());
+            throw new FunctionException(fite);
+          } else if (execution.isClientServerMode()) {
+            // endResults();
+            clearResults();
+            FunctionInvocationTargetException fite =
+                new InternalFunctionInvocationTargetException(e.getMessage());
+            throw new FunctionException(fite);
+          } else {
+            // endResults();
+            clearResults();
+            this.execution = this.execution.setIsReExecute();
+            ResultCollector newRc = null;
+            if (execution.isFnSerializationReqd()) {
+              newRc = this.execution.execute(this.fn);
+            } else {
+              newRc = this.execution.execute(this.fn.getId());
+            }
+            return newRc.getResult();
-          return newRc.getResult();
-        }
-      }
-      catch (BucketMovedException e) {
-        if(!execution.getWaitOnExceptionFlag()){
-        if (!this.fn.isHA()) {
-          //endResults();
-          FunctionInvocationTargetException fite = new FunctionInvocationTargetException(
-              e.getMessage());
-          throw new FunctionException(fite);
-        }
-        else if (execution.isClientServerMode()) {
-          //endResults();
-          clearResults();
-          FunctionInvocationTargetException fite = new InternalFunctionInvocationTargetException(
-              e.getMessage());
-          throw new FunctionException(fite);
-        }
-        else {
-          //endResults();
-          clearResults();
-          this.execution = this.execution.setIsReExecute();
-          ResultCollector newRc = null;
-          if (execution.isFnSerializationReqd()) {
-            newRc = this.execution.execute(this.fn);
+      } catch (CacheClosedException e) {
+        if (!execution.getWaitOnExceptionFlag()) {
+          if (!this.fn.isHA()) {
+            // endResults();
+            FunctionInvocationTargetException fite =
+                new FunctionInvocationTargetException(e.getMessage());
+            throw new FunctionException(fite);
+          } else if (execution.isClientServerMode()) {
+            // endResults();
+            clearResults();
+            FunctionInvocationTargetException fite = new InternalFunctionInvocationTargetException(
+                e.getMessage(), this.execution.getFailedNodes());
+            throw new FunctionException(fite);
+          } else {
+            // endResults();
+            clearResults();
+            this.execution = this.execution.setIsReExecute();
+            ResultCollector newRc = null;
+            if (execution.isFnSerializationReqd()) {
+              newRc = this.execution.execute(this.fn);
+            } else {
+              newRc = this.execution.execute(this.fn.getId());
+            }
+            return newRc.getResult();
-          else {
-            newRc = this.execution.execute(this.fn.getId());
-          }
-          return newRc.getResult();
-        }
-      }
-      catch (CacheClosedException e) {
-        if(!execution.getWaitOnExceptionFlag()) {
-        if (!this.fn.isHA()) {
-          //endResults();
-          FunctionInvocationTargetException fite = new FunctionInvocationTargetException(e.getMessage());
-          throw new FunctionException(fite);
-        }
-        else if (execution.isClientServerMode()) {
-          //endResults();
-          clearResults();
-          FunctionInvocationTargetException fite = new InternalFunctionInvocationTargetException(
-              e.getMessage(), this.execution.getFailedNodes());
-          throw new FunctionException(fite);
-        }
-        else {
-          //endResults();
-          clearResults();
-          this.execution = this.execution.setIsReExecute();
-          ResultCollector newRc = null;
-          if (execution.isFnSerializationReqd()) {
-            newRc = this.execution.execute(this.fn);
-          }
-          else {
-            newRc = this.execution.execute(this.fn.getId());
-          }
-          return newRc.getResult();
-        }
-        }
-      }
-      catch (CacheException e) {
-        //endResults();
+      } catch (CacheException e) {
+        // endResults();
-      }
-      catch (ForceReattemptException e) {
+      } catch (ForceReattemptException e) {
-        }
-        else if (execution.isClientServerMode()) {
+        } else if (execution.isClientServerMode()) {
-        }
-        else {
+        } else {
-          }
-          else {
+          } else {
-    if(this.resultCollected ){
+    if (this.resultCollected) {
-          throw new FunctionException(
-              "All results not recieved in time provided.");
+          throw new FunctionException("All results not recieved in time provided.");
-        if (!this.execution.getFailedNodes().isEmpty()
-            && !this.execution.isClientServerMode()) {
+        if (!this.execution.getFailedNodes().isEmpty() && !this.execution.isClientServerMode()) {
-          }
-          else {
+          } else {
-      }
-      catch (FunctionInvocationTargetException fite) {
+      } catch (FunctionInvocationTargetException fite) {
-        }
-        else if (execution.isClientServerMode()) {
+        } else if (execution.isClientServerMode()) {
-        }
-        else {
+        } else {
-          }
-          else {
+          } else {
-      }
-      catch (BucketMovedException e) {
+      } catch (BucketMovedException e) {
-          //endResults();
-          FunctionInvocationTargetException fite = new FunctionInvocationTargetException(e.getMessage());
+          // endResults();
+          FunctionInvocationTargetException fite =
+              new FunctionInvocationTargetException(e.getMessage());
-        }
-        else if (execution.isClientServerMode()) {
-          //endResults();
+        } else if (execution.isClientServerMode()) {
+          // endResults();
-          FunctionInvocationTargetException fite = new FunctionInvocationTargetException(e.getMessage());
+          FunctionInvocationTargetException fite =
+              new FunctionInvocationTargetException(e.getMessage());
-        }
-        else {
-          //endResults();
+        } else {
+          // endResults();
-          }
-          else {
+          } else {
-        }  
-      }
-      catch (CacheClosedException e) {
-        if (!this.fn.isHA()) {
-          //endResults();
-          FunctionInvocationTargetException fite = new FunctionInvocationTargetException(e.getMessage());
-          throw new FunctionException(fite);
-        else if (execution.isClientServerMode()) {
-          //endResults();
+      } catch (CacheClosedException e) {
+        if (!this.fn.isHA()) {
+          // endResults();
+          FunctionInvocationTargetException fite =
+              new FunctionInvocationTargetException(e.getMessage());
+          throw new FunctionException(fite);
+        } else if (execution.isClientServerMode()) {
+          // endResults();
-        }
-        else {
-          //endResults();
+        } else {
+          // endResults();
-          }
-          else {
+          } else {
-      }
-      catch (CacheException e) {
-        //endResults();
+      } catch (CacheException e) {
+        // endResults();
-      }
-      catch (ForceReattemptException e) {
+      } catch (ForceReattemptException e) {
-        }
-        else if (execution.isClientServerMode()) {
+        } else if (execution.isClientServerMode()) {
-        }
-        else {
+        } else {
-          }
-          else {
+          } else {
-    return this.userRC.getResult(timeoutInMillis, unit); // As we have already waited for timeout earlier we expect results to be ready
-  }  
-  
+    return this.userRC.getResult(timeoutInMillis, unit); // As we have already waited for timeout
+                                                         // earlier we expect results to be ready
+  }
+
-  public void memberDeparted(final InternalDistributedMember id,
-      final boolean crashed) {
+  public void memberDeparted(final InternalDistributedMember id, final boolean crashed) {
-                    .toLocalizedString(new Object[] { id,
-                        Boolean.valueOf(crashed) }), id);
-            } else {
+                    .toLocalizedString(new Object[] {id, Boolean.valueOf(crashed)}),
+                id);
+          } else {
-                    .toLocalizedString(new Object[] { id,
-                        Boolean.valueOf(crashed) }), id);
+                    .toLocalizedString(new Object[] {id, Boolean.valueOf(crashed)}),
+                id);
-          LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID
-              .toLocalizedString());
+          LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID.toLocalizedString());
-              LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID_CRASHED_0,
-              Boolean.valueOf(crashed)), e);
+          LocalizedStrings.PartitionMessage_MEMBERDEPARTED_GOT_NULL_MEMBERID_CRASHED_0,
+          Boolean.valueOf(crashed)), e);
-  
-  
+
+
-  protected synchronized void processException(DistributionMessage msg,
-      ReplyException ex) {
-    logger.debug("StreamingPartitionResponseWithResultCollector received exception {} from member {}", ex.getCause(), msg.getSender());
-    
+  protected synchronized void processException(DistributionMessage msg, ReplyException ex) {
+    logger.debug(
+        "StreamingPartitionResponseWithResultCollector received exception {} from member {}",
+        ex.getCause(), msg.getSender());
+
-    
-    /** 
-     * Below two cases should also be handled
-     * and not thrown exception
-     * Saving the exception
-     * ForeceReattempt can also be added here? 
-     * Also, if multipel nodes throw exception, one may override another
-     * TODO: Wrap exception among each other or create a list of exceptions like this.fite.
+
+    /**
+     * Below two cases should also be handled and not thrown exception Saving the exception
+     * ForeceReattempt can also be added here? Also, if multipel nodes throw exception, one may
+     * override another TODO: Wrap exception among each other or create a list of exceptions like
+     * this.fite.
-    if ( ex.getCause() instanceof CacheClosedException) {
-      ((PartitionedRegionFunctionExecutor)this.execution).addFailedNode(msg
-          .getSender().getId());
+    if (ex.getCause() instanceof CacheClosedException) {
+      ((PartitionedRegionFunctionExecutor) this.execution).addFailedNode(msg.getSender().getId());
-    }
-    else if (ex.getCause() instanceof BucketMovedException) {
+    } else if (ex.getCause() instanceof BucketMovedException) {
-    }
-    else if (!execution.getWaitOnExceptionFlag()) {
+    } else if (!execution.getWaitOnExceptionFlag()) {

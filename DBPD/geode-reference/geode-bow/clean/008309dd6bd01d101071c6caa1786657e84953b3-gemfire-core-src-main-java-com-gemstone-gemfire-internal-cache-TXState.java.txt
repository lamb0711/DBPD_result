Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+
-import com.gemstone.gemfire.internal.cache.control.InternalResourceManager;
+import com.gemstone.gemfire.internal.cache.control.MemoryThresholds;
+import com.gemstone.gemfire.internal.offheap.annotations.Retained;
-  private static final Logger logger = LogService.getLogger();
+  protected static final Logger logger = LogService.getLogger();
-  private boolean completionStarted;
+  protected boolean completionStarted;
-  private boolean closed = false;
+  protected boolean closed = false;
-  private final Object completionGuard = new Object();
+  protected final Object completionGuard = new Object();
-  private TXLockRequest locks = null;
+  protected TXLockRequest locks = null;
-  private Runnable internalAfterConflictCheck;
-  private Runnable internalAfterApplyChanges;
-  private Runnable internalAfterReleaseLocalLocks;
+  protected Runnable internalAfterConflictCheck;
+  protected Runnable internalAfterApplyChanges;
+  protected Runnable internalAfterReleaseLocalLocks;
-  private Runnable internalAfterSend;
-  private Runnable internalBeforeSend;
+  protected Runnable internalAfterSend;
+  protected Runnable internalBeforeSend;
-  private final TXStateProxy proxy;
-  private boolean firedWriter = false;
-  private final boolean onBehalfOfRemoteStub;
-  private boolean gotBucketLocks = false;
-  private TXCommitMessage commitMessage = null;
+  protected final TXStateProxy proxy;
+  protected boolean firedWriter = false;
+  protected final boolean onBehalfOfRemoteStub;
+  protected boolean gotBucketLocks = false;
+  protected TXCommitMessage commitMessage = null;
+  public void freePendingCallbacks() {
+    for (EntryEventImpl ee: getPendingCallbacks()) {
+      ee.release();
+    }
+  }
+
+    if (logger.isDebugEnabled()) {
+      logger.debug("TXState writeRegion flag {} region-state {} ",
+          false, result/*, new Throwable()*/);
+    }
-  private void reserveAndCheck() throws CommitConflictException {
+  protected void reserveAndCheck() throws CommitConflictException {
+  @Override
+  public void precommit() throws CommitConflictException,
+      UnsupportedOperationInTransactionException {
+    throw new UnsupportedOperationInTransactionException(
+        LocalizedStrings.Dist_TX_PRECOMMIT_NOT_SUPPORTED_IN_A_TRANSACTION
+            .toLocalizedString("precommit"));
+  }
+  
-  private void attachFilterProfileInformation(List entries) {
+  protected void attachFilterProfileInformation(List entries) {
+            try {
+            } finally {
+              ev.release();
+            }
-  private List/*<TXEntryStateWithRegionAndKey>*/ generateEventOffsets() {
+  protected List/*<TXEntryStateWithRegionAndKey>*/ generateEventOffsets() {
+    if (logger.isDebugEnabled()) {
+      logger.debug("generateEventOffsets() entries " + entries
+          + " RegionState Map=" + this.regions);
+    }
-  private void lockBucketRegions() throws PrimaryBucketException {
+  protected void lockBucketRegions() throws PrimaryBucketException {
-        if (r instanceof BucketRegion) {
+        if (r instanceof BucketRegion && (((BucketRegion)r).getBucketAdvisor().isPrimary())) {
-  private void cleanupNonDirtyRegions() {
+  protected void cleanupNonDirtyRegions() {
-  private TXCommitMessage buildMessage() {
+  protected TXCommitMessage buildMessage() {
-  private TXCommitMessage buildCompleteMessage() {
+  protected TXCommitMessage buildCompleteMessage() {
-  private void applyChanges(List/*<TXEntryStateWithRegionAndKey>*/ entries) {
+  protected void applyChanges(List/*<TXEntryStateWithRegionAndKey>*/ entries) {
-  private void cleanup() {
+  /**
+   * Note that cleanup does more than is needed in this method.
+   * This method only needs to do stuff that is required when a
+   * Cache close is done and we have txs that are still in progress.
+   * Currently the only thing that is needed is to decrement off-heap
+   * refcounts since off-heap memory lives after a cache close.
+   */
+  @Override 
+  public void close() {
+    if (!this.closed) {
+      this.closed = true;
+      for (TXRegionState r: this.regions.values()) {
+        r.close();
+      }
+    }
+  }
+  
+  protected void cleanup() {
+      freePendingCallbacks();
-          if (r instanceof BucketRegion) {
+          if (r instanceof BucketRegion && (((BucketRegion)r).getBucketAdvisor().isPrimary())) {
-      if (!InternalResourceManager.isLowMemoryExceptionDisabled()) {
+      if (!MemoryThresholds.isLowMemoryExceptionDisabled()) {
-  private TXEntryState txReadEntry(KeyInfo keyInfo, LocalRegion localRegion,
+  protected TXEntryState txReadEntry(KeyInfo keyInfo, LocalRegion localRegion,
-        if (!AbstractRegionEntry.checkExpectedOldValue(expectedOldValue, val)) {
+        if (!AbstractRegionEntry.checkExpectedOldValue(expectedOldValue, val, localRegion)) {
-  public Object getDeserializedValue(KeyInfo keyInfo, LocalRegion localRegion, boolean updateStats, boolean disableCopyOnRead, boolean preferCD, EntryEventImpl clientEvent, boolean returnTombstones) {
+  public Object getDeserializedValue(KeyInfo keyInfo, LocalRegion localRegion, boolean updateStats, boolean disableCopyOnRead, boolean preferCD, EntryEventImpl clientEvent, boolean returnTombstones, boolean allowReadFromHDFS, boolean retainResult) {
-      return localRegion.getDeserializedValue(keyInfo, updateStats, disableCopyOnRead, preferCD, clientEvent, returnTombstones);
+      return localRegion.getDeserializedValue(null, keyInfo, updateStats, disableCopyOnRead, preferCD, clientEvent, returnTombstones, allowReadFromHDFS, retainResult);
-  public Object getSerializedValue(LocalRegion localRegion, KeyInfo keyInfo, boolean doNotLockEntry, ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent, boolean returnTombstones) throws DataLocationException {
+  @Retained
+  public Object getSerializedValue(LocalRegion localRegion, KeyInfo keyInfo, boolean doNotLockEntry, ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent, 
+      boolean returnTombstones, boolean allowReadFromHDFS) throws DataLocationException {
-            true, val, false, false, requestingClient, clientEvent, false);
+            true, val, false, false, requestingClient, clientEvent, false, allowReadFromHDFS);
-      return pr.getDataStore().getSerializedLocally(keyInfo, doNotLockEntry, null, returnTombstones);
+      return pr.getDataStore().getSerializedLocally(keyInfo, doNotLockEntry, null, returnTombstones, allowReadFromHDFS);
+  @Retained
-      boolean generateCallbacks, Object value, boolean disableCopyOnRead, boolean preferCD, ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent, boolean returnTombstones) {
-    return r.findObjectInSystem(key, isCreate, this, generateCallbacks, value, disableCopyOnRead, preferCD, requestingClient, clientEvent, returnTombstones);
+      boolean generateCallbacks, Object value, boolean disableCopyOnRead, boolean preferCD, ClientProxyMembershipID requestingClient, EntryEventImpl clientEvent, boolean returnTombstones, boolean allowReadFromHDFS) {
+    return r.findObjectInSystem(key, isCreate, this, generateCallbacks, value, disableCopyOnRead, preferCD, requestingClient, clientEvent, returnTombstones, allowReadFromHDFS);
-	          EntryEventImpl ev = PutAllPRMessage.getEventFromEntry(theRegion, myId,myId, i, putallOp.putAllData, false, putallOp.getBaseEvent().getContext(), false, !putallOp.getBaseEvent().isGenerateCallbacks());
+	          EntryEventImpl ev = PutAllPRMessage.getEventFromEntry(theRegion, myId,myId, i, putallOp.putAllData, false, putallOp.getBaseEvent().getContext(), false, !putallOp.getBaseEvent().isGenerateCallbacks(), false);
+	          try {
+	          } finally {
+	            ev.release();
+	          }
+  
+  @Override
+  public boolean isTxState() {
+    return true;
+  }
+  
+  @Override
+  public boolean isTxStateStub() {
+    return false;
+  }
+  
+  @Override
+  public boolean isTxStateProxy() {
+    return false;
+  }
+  
+  @Override
+  public boolean isDistTx() {
+    return false;
+  }
+  
+  @Override
+  public boolean isCreatedOnDistTxCoordinator() {
+    return false;
+  }

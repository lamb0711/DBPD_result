GEODE-6861: separate static config object from runtime info in the Clâ€¦ (#3754)

Co-authored-by: Joris Melchior <joris.melchior@gmail.com>

* use ConfigRealizer to retrieve the runtime information for configuration on each member
* list result would return a List of Response object which has a configuration object and a list runtime objects
* use existing object for runtime member info and move them to geode-management module.

+import java.util.ArrayList;
+import java.util.Objects;
+import java.util.stream.Collectors;
-import org.apache.geode.management.configuration.RuntimeRegionConfig;
+import org.apache.geode.management.api.Response;
+import org.apache.geode.management.runtime.RuntimeInfo;
+import org.apache.geode.management.runtime.RuntimeRegionInfo;
-  public ResponseEntity<ClusterManagementResult<RegionConfig>> createRegion(
+  public ResponseEntity<ClusterManagementResult> createRegion(
-    ClusterManagementResult<RegionConfig> result =
+    ClusterManagementResult result =
-  public ClusterManagementResult<RuntimeRegionConfig> listRegion(
+  public ClusterManagementResult<RegionConfig, RuntimeRegionInfo> listRegion(
-  public ClusterManagementResult<RuntimeRegionConfig> getRegion(
+  public ClusterManagementResult<RegionConfig, RuntimeRegionInfo> getRegion(
-  public ClusterManagementResult<RegionConfig> deleteRegion(
+  public ClusterManagementResult deleteRegion(
-  public ClusterManagementResult<RegionConfig.Index> listIndex(
+  public ClusterManagementResult<RegionConfig.Index, RuntimeInfo> listIndex(
-    ClusterManagementResult<RuntimeRegionConfig> result0 = getRegion(regionName);
-    RuntimeRegionConfig runtimeRegion = result0.getResult().get(0);
+    ClusterManagementResult<RegionConfig, RuntimeRegionInfo> result0 = getRegion(regionName);
+    RegionConfig regionConfig = result0.getResult().get(0).getConfig();
-    List<RegionConfig.Index> runtimeIndexes = runtimeRegion.getIndexes(id);
-    ClusterManagementResult<RegionConfig.Index> result = new ClusterManagementResult<>();
-    result.setResult(runtimeIndexes);
+    List<RegionConfig.Index> indexList = regionConfig.getIndexes().stream().map(e -> {
+      if (StringUtils.isNotBlank(id) && !e.getId().equals(id)) {
+        return null;
+      }
+      e.setRegionName(regionName);
+      return e;
+    }).filter(Objects::nonNull).collect(Collectors.toList());
+    List<Response<RegionConfig.Index, RuntimeInfo>> responses = new ArrayList<>();
+    for (RegionConfig.Index index : indexList) {
+      responses.add(new Response<>(index));
+    }
+
+    ClusterManagementResult<RegionConfig.Index, RuntimeInfo> result =
+        new ClusterManagementResult<>();
+    result.setResult(responses);
-  public ClusterManagementResult<RegionConfig.Index> getIndex(
+  public ClusterManagementResult<RegionConfig.Index, RuntimeInfo> getIndex(
-    ClusterManagementResult<RegionConfig.Index> result = listIndex(regionName, id);
-    List<RegionConfig.Index> indexList = result.getResult();
+    ClusterManagementResult<RegionConfig.Index, RuntimeInfo> result = listIndex(regionName, id);
+    List<Response<RegionConfig.Index, RuntimeInfo>> indexList = result.getResult();

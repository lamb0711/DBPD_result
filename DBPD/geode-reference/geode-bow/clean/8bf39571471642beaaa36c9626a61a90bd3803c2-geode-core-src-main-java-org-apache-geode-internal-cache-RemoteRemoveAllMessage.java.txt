Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * A Replicate Region removeAll message.  Meant to be sent only to
- * the peer who hosts transactional data.
+ * A Replicate Region removeAll message. Meant to be sent only to the peer who hosts transactional
+ * data.
-public final class RemoteRemoveAllMessage extends RemoteOperationMessageWithDirectReply
-  {
+public final class RemoteRemoveAllMessage extends RemoteOperationMessageWithDirectReply {
-  
+
-  /** An additional object providing context for the operation, e.g., for BridgeServer notification */
+  /**
+   * An additional object providing context for the operation, e.g., for BridgeServer notification
+   */
-  
+
-  
+
-  
+
-   * this is similar to send() but it selects an initialized replicate
-   * that is used to proxy the message
+   * this is similar to send() but it selects an initialized replicate that is used to proxy the
+   * message
-  public static boolean distribute(EntryEventImpl event, RemoveAllEntryData[] data,
-      int dataCount) {
+  public static boolean distribute(EntryEventImpl event, RemoveAllEntryData[] data, int dataCount) {
-    DistributedRegion r = (DistributedRegion)event.getRegion();
+    DistributedRegion r = (DistributedRegion) event.getRegion();
-    for (Iterator<InternalDistributedMember> it=replicates.iterator(); it.hasNext(); ) {
+    for (Iterator<InternalDistributedMember> it = replicates.iterator(); it.hasNext();) {
-      
+
-      
+
-      } catch(RemoteOperationException e) {
+      } catch (RemoteOperationException e) {
-          logger.trace(LogMarker.DM, "RemoteRemoveAllMessage caught an unexpected exception during distribution", e);
+          logger.trace(LogMarker.DM,
+              "RemoteRemoveAllMessage caught an unexpected exception during distribution", e);
-      RemoveAllEntryData[] removeAllData, int removeAllDataCount,
-      boolean useOriginRemote, int processorType, boolean possibleDuplicate) {
+      RemoveAllEntryData[] removeAllData, int removeAllDataCount, boolean useOriginRemote,
+      int processorType, boolean possibleDuplicate) {
-    this.processorId = p==null? 0 : p.getProcessorId();
+    this.processorId = p == null ? 0 : p.getProcessorId();
-  public RemoteRemoveAllMessage() {
-  }
+  public RemoteRemoveAllMessage() {}
+   * 
-   * @param r  the LocalRegion for which the op was performed
-   * @return the processor used to await acknowledgement that the message was
-   *         sent, or null to indicate that no acknowledgement will be sent
+   * 
+   * @param r the LocalRegion for which the op was performed
+   * 
+   * @return the processor used to await acknowledgement that the message was sent, or null to
+   * indicate that no acknowledgement will be sent
+   * 
-    //Assert.assertTrue(recipient != null, "RemoteRemoveAllMessage NULL recipient");  recipient can be null for event notifications
+    // Assert.assertTrue(recipient != null, "RemoteRemoveAllMessage NULL recipient"); recipient can
+    // be null for event notifications
-    RemoteRemoveAllMessage msg = new RemoteRemoveAllMessage(event, recipients, p,
-        removeAllData, removeAllDataCount, useOriginRemote, processorType, possibleDuplicate);
+    RemoteRemoveAllMessage msg = new RemoteRemoveAllMessage(event, recipients, p, removeAllData,
+        removeAllDataCount, useOriginRemote, processorType, possibleDuplicate);
-      throw new RemoteOperationException(LocalizedStrings.RemotePutMessage_FAILED_SENDING_0.toLocalizedString(msg));
+      throw new RemoteOperationException(
+          LocalizedStrings.RemotePutMessage_FAILED_SENDING_0.toLocalizedString(msg));
-  
+
-  public final void fromData(DataInput in) throws IOException,
-      ClassNotFoundException {
+  public final void fromData(DataInput in) throws IOException, ClassNotFoundException {
-    this.eventId = (EventID)DataSerializer.readObject(in);
+    this.eventId = (EventID) DataSerializer.readObject(in);
-    this.removeAllDataCount = (int)InternalDataSerializer.readUnsignedVL(in);
+    this.removeAllDataCount = (int) InternalDataSerializer.readUnsignedVL(in);
-      final Version version = InternalDataSerializer
-          .getVersionForDataStreamOrNull(in);
+      final Version version = InternalDataSerializer.getVersionForDataStreamOrNull(in);
-        this.removeAllData[i] = new RemoveAllEntryData(in, this.eventId, i, version,
-            bytesIn);
+        this.removeAllData[i] = new RemoveAllEntryData(in, this.eventId, i, version, bytesIn);
-    if (this.posDup) flags |= POS_DUP;
-    if (this.bridgeContext != null) flags |= HAS_BRIDGE_CONTEXT;
+    if (this.posDup)
+      flags |= POS_DUP;
+    if (this.bridgeContext != null)
+      flags |= HAS_BRIDGE_CONTEXT;
-  protected boolean operateOnRegion(DistributionManager dm,
-      LocalRegion r,long startTime) throws RemoteOperationException {
+  protected boolean operateOnRegion(DistributionManager dm, LocalRegion r, long startTime)
+      throws RemoteOperationException {
-    }
-    catch (RemoteOperationException e) {
-      sendReply(getSender(), getProcessorId(), dm, 
-          new ReplyException(e), r, startTime);
+    } catch (RemoteOperationException e) {
+      sendReply(getSender(), getProcessorId(), dm, new ReplyException(e), r, startTime);
-   * This method is called by both operateOnLocalRegion() when processing a remote msg
-   * or by sendMsgByBucket() when processing a msg targeted to local Jvm. 
-   * LocalRegion Note: It is very important that this message does NOT
-   * cause any deadlocks as the sender will wait indefinitely for the
-   * acknowledgment
+   * This method is called by both operateOnLocalRegion() when processing a remote msg or by
+   * sendMsgByBucket() when processing a msg targeted to local Jvm. LocalRegion Note: It is very
+   * important that this message does NOT cause any deadlocks as the sender will wait indefinitely
+   * for the acknowledgment
+   * 
-  public final boolean doLocalRemoveAll(final LocalRegion r, final InternalDistributedMember eventSender)
-    throws EntryExistsException, RemoteOperationException {
-    final DistributedRegion dr = (DistributedRegion)r;
-    
+  public final boolean doLocalRemoveAll(final LocalRegion r,
+      final InternalDistributedMember eventSender)
+      throws EntryExistsException, RemoteOperationException {
+    final DistributedRegion dr = (DistributedRegion) r;
+
-    @Released EntryEventImpl baseEvent = EntryEventImpl.create(
-        r, Operation.REMOVEALL_DESTROY,
-        null, null, this.callbackArg, false, eventSender, true);
+    @Released
+    EntryEventImpl baseEvent = EntryEventImpl.create(r, Operation.REMOVEALL_DESTROY, null, null,
+        this.callbackArg, false, eventSender, true);
-    baseEvent.setCausedByMessage(this);
-    
-    // set baseEventId to the first entry's event id. We need the thread id for DACE
-    baseEvent.setEventId(this.eventId);
-    if (this.bridgeContext != null) {
-      baseEvent.setContext(this.bridgeContext);
-    }
-    baseEvent.setPossibleDuplicate(this.posDup);
-    if (logger.isDebugEnabled()) {
-      logger.debug("RemoteRemoveAllMessage.doLocalRemoveAll: eventSender is {}, baseEvent is {}, msg is {}",
-          eventSender, baseEvent, this);
-    }
-    final DistributedRemoveAllOperation op = new DistributedRemoveAllOperation(baseEvent, removeAllDataCount, false);
-    try {
-    final VersionedObjectList versions = new VersionedObjectList(removeAllDataCount, true, dr.concurrencyChecksEnabled);
-    dr.syncBulkOp(new Runnable() {
-      @SuppressWarnings("synthetic-access")
-      public void run() {
-        InternalDistributedMember myId = r.getDistributionManager().getDistributionManagerId();
-        for (int i = 0; i < removeAllDataCount; ++i) {
-          @Released EntryEventImpl ev = RemoveAllPRMessage.getEventFromEntry(r, myId, eventSender, i, removeAllData, false, bridgeContext, posDup, false);
-          try {
-          ev.setRemoveAllOperation(op);
-          if (logger.isDebugEnabled()) {
-            logger.debug("invoking basicDestroy with {}", ev);
-          }
-          try {
-            dr.basicDestroy(ev, true, null);
-          } catch (EntryNotFoundException ignore) {
-          }
-          removeAllData[i].versionTag = ev.getVersionTag();
-          versions.addKeyAndVersion(removeAllData[i].key, ev.getVersionTag());
-          } finally {
-            ev.release();
-          }
-        }
+      baseEvent.setCausedByMessage(this);
+
+      // set baseEventId to the first entry's event id. We need the thread id for DACE
+      baseEvent.setEventId(this.eventId);
+      if (this.bridgeContext != null) {
+        baseEvent.setContext(this.bridgeContext);
-    }, baseEvent.getEventId());
-    if(getTXUniqId()!=TXManagerImpl.NOTX || dr.getConcurrencyChecksEnabled()) {
-        dr.getDataView().postRemoveAll(op, versions, dr);
-    }
-    RemoveAllReplyMessage.send(getSender(), this.processorId, 
-        getReplySender(r.getDistributionManager()), versions, this.removeAllData, this.removeAllDataCount);
-    return false;
-    } finally {
-      op.freeOffHeapResources();
-    }
+      baseEvent.setPossibleDuplicate(this.posDup);
+      if (logger.isDebugEnabled()) {
+        logger.debug(
+            "RemoteRemoveAllMessage.doLocalRemoveAll: eventSender is {}, baseEvent is {}, msg is {}",
+            eventSender, baseEvent, this);
+      }
+      final DistributedRemoveAllOperation op =
+          new DistributedRemoveAllOperation(baseEvent, removeAllDataCount, false);
+      try {
+        final VersionedObjectList versions =
+            new VersionedObjectList(removeAllDataCount, true, dr.concurrencyChecksEnabled);
+        dr.syncBulkOp(new Runnable() {
+          @SuppressWarnings("synthetic-access")
+          public void run() {
+            InternalDistributedMember myId = r.getDistributionManager().getDistributionManagerId();
+            for (int i = 0; i < removeAllDataCount; ++i) {
+              @Released
+              EntryEventImpl ev = RemoveAllPRMessage.getEventFromEntry(r, myId, eventSender, i,
+                  removeAllData, false, bridgeContext, posDup, false);
+              try {
+                ev.setRemoveAllOperation(op);
+                if (logger.isDebugEnabled()) {
+                  logger.debug("invoking basicDestroy with {}", ev);
+                }
+                try {
+                  dr.basicDestroy(ev, true, null);
+                } catch (EntryNotFoundException ignore) {
+                }
+                removeAllData[i].versionTag = ev.getVersionTag();
+                versions.addKeyAndVersion(removeAllData[i].key, ev.getVersionTag());
+              } finally {
+                ev.release();
+              }
+            }
+          }
+        }, baseEvent.getEventId());
+        if (getTXUniqId() != TXManagerImpl.NOTX || dr.getConcurrencyChecksEnabled()) {
+          dr.getDataView().postRemoveAll(op, versions, dr);
+        }
+        RemoveAllReplyMessage.send(getSender(), this.processorId,
+            getReplySender(r.getDistributionManager()), versions, this.removeAllData,
+            this.removeAllDataCount);
+        return false;
+      } finally {
+        op.freeOffHeapResources();
+      }
-  
+
-  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex, LocalRegion r, long startTime) {
+  protected void sendReply(InternalDistributedMember member, int procId, DM dm, ReplyException ex,
+      LocalRegion r, long startTime) {
-  protected final void appendFields(StringBuffer buff)
-  {
+  protected final void appendFields(StringBuffer buff) {
-    for (int i=0; i<removeAllDataCount; i++) {
-      buff.append("; entry"+i+":").append(removeAllData[i]==null? "null" : removeAllData[i].getKey());
+    for (int i = 0; i < removeAllDataCount; i++) {
+      buff.append("; entry" + i + ":")
+          .append(removeAllData[i] == null ? "null" : removeAllData[i].getKey());
-    private RemoveAllReplyMessage(int processorId, VersionedObjectList versionList, RemoveAllEntryData[] removeAllData, int removeAllCount)  {
+    private RemoveAllReplyMessage(int processorId, VersionedObjectList versionList,
+        RemoveAllEntryData[] removeAllData, int removeAllCount) {
-    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm, VersionedObjectList versions,
-        RemoveAllEntryData[] removeAllData, int removeAllDataCount)  {
+    public static void send(InternalDistributedMember recipient, int processorId, ReplySender dm,
+        VersionedObjectList versions, RemoveAllEntryData[] removeAllData, int removeAllDataCount) {
-      RemoveAllReplyMessage m = new RemoveAllReplyMessage(processorId, versions, removeAllData, removeAllDataCount);
+      RemoveAllReplyMessage m =
+          new RemoveAllReplyMessage(processorId, versions, removeAllData, removeAllDataCount);
-     * Processes this message.  This method is invoked by the receiver
-     * of the message.
+     * Processes this message. This method is invoked by the receiver of the message.
+     * 
-        RemoveAllResponse processor = (RemoveAllResponse)rp;
+        RemoveAllResponse processor = (RemoveAllResponse) rp;
-      dm.getStats().incReplyMessageTime(NanoTimer.getTime()-startTime);
+      dm.getStats().incReplyMessageTime(NanoTimer.getTime() - startTime);
-    public RemoveAllReplyMessage() {
-    }
+    public RemoveAllReplyMessage() {}
-    public void fromData(DataInput in)
-      throws IOException, ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      this.versions = (VersionedObjectList)DataSerializer.readObject(in); 
+      this.versions = (VersionedObjectList) DataSerializer.readObject(in);
-      sb.append("RemoveAllReplyMessage ")
-        .append(" processorid=").append(this.processorId)
-        .append(" returning versionTags=").append(this.versions);
+      sb.append("RemoveAllReplyMessage ").append(" processorid=").append(this.processorId)
+          .append(" returning versionTags=").append(this.versions);
-  
+
-    
+

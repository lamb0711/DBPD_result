Merge branch 'release/1.4.0'

+import java.io.BufferedInputStream;
-  public DeployedJar(File versionedJarFile, String jarName) throws IOException {
-    this(versionedJarFile, jarName, Files.readAllBytes(versionedJarFile.toPath()));
-  }
-
-  public DeployedJar(File versionedJarFile, final String jarName, byte[] jarBytes)
-      throws FileNotFoundException {
-    Assert.assertTrue(jarBytes != null, "jarBytes cannot be null");
+  public DeployedJar(File versionedJarFile, final String jarName) {
-    final byte[] fileContent = getJarContent();
-    if (!Arrays.equals(fileContent, jarBytes)) {
-      throw new IllegalStateException("JAR file: " + versionedJarFile.getAbsolutePath()
-          + ", does not have the expected content.");
-    }
-
-    if (!hasValidJarContent(fileContent)) {
+    if (!hasValidJarContent(versionedJarFile)) {
-    if (messageDigest != null) {
-      this.md5hash = messageDigest.digest(jarBytes);
-    } else {
-      this.md5hash = null;
+    byte[] digest = null;
+    try {
+      if (messageDigest != null) {
+        digest = fileDigest(this.file);
+      }
+    } catch (IOException e) {
+      // Ignored
+    this.md5hash = digest;
-   * @param inputStream InputStream containing data to be validated.
+   * @param jarFile Jar containing data to be validated.
-  private static boolean hasValidJarContent(final InputStream inputStream) {
+  public static boolean hasValidJarContent(File jarFile) {
-      jarInputStream = new JarInputStream(inputStream);
+      jarInputStream = new JarInputStream(new FileInputStream(jarFile));
-   * Peek into the JAR data and make sure that it is valid JAR content.
-   *
-   * @param jarBytes Bytes of data to be validated.
-   * @return True if the data has JAR content, false otherwise
-   */
-  static boolean hasValidJarContent(final byte[] jarBytes) {
-    return hasValidJarContent(new ByteArrayInputStream(jarBytes));
-  }
-
-  /**
-    ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(this.getJarContent());
+    BufferedInputStream bufferedInputStream;
+    try {
+      bufferedInputStream = new BufferedInputStream(new FileInputStream(this.file));
+    } catch (Exception ex) {
+      logger.error("Unable to scan jar file for functions");
+      return;
+    }
-      jarInputStream = new JarInputStream(byteArrayInputStream);
+      jarInputStream = new JarInputStream(bufferedInputStream);
-   * @param compareToBytes Bytes to compare the original content to
+   * @param stagedFile File to compare the original content to
-  boolean hasSameContentAs(final byte[] compareToBytes) {
+  boolean hasSameContentAs(final File stagedFile) {
-      return Arrays.equals(compareToBytes, getJarContent());
+      return false;
-    byte[] compareToMd5 = messageDigest.digest(compareToBytes);
+    byte[] compareToMd5;
+    try {
+      compareToMd5 = fileDigest(stagedFile);
+    } catch (IOException ex) {
+      return false;
+    }
+  private byte[] fileDigest(File file) throws IOException {
+    BufferedInputStream fis = new BufferedInputStream(new FileInputStream(file));
+    byte[] data = new byte[8192];
+
+    int read;
+    while ((read = fis.read(data)) > 0) {
+      messageDigest.update(data, 0, read);
+    }
+
+    return messageDigest.digest();
+  }
+
-  private byte[] getJarContent() {
-    try {
-      InputStream channelInputStream = new FileInputStream(this.file);
-
-      final ByteArrayOutputStream byteOutStream = new ByteArrayOutputStream();
-      final byte[] bytes = new byte[4096];
-
-      int bytesRead;
-      while ((bytesRead = channelInputStream.read(bytes)) != -1) {
-        byteOutStream.write(bytes, 0, bytesRead);
-      }
-      channelInputStream.close();
-      return byteOutStream.toByteArray();
-    } catch (IOException e) {
-      logger.error("Error when attempting to read jar contents: ", e);
-    }
-
-    return ZERO_BYTES;
-  }
-

GEODE-8166: reimplement redis expiration to use new data model (#5174)

* Added timestamp field to RedisData and implemented serialization and delta for it.
Both active and passive expiration have been implemented.

* RedisHash, RedisSet, and RedisString now subclass AbstractRedisData
* type command now uses function
* getset, incr, decr, incrby, and decrby now uses function and is atomic

+import static java.util.concurrent.TimeUnit.SECONDS;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
+import java.util.Map;
-import java.util.concurrent.ScheduledFuture;
+import org.apache.geode.cache.partition.PartitionRegionHelper;
+import org.apache.geode.redis.internal.executor.RedisKeyCommands;
+import org.apache.geode.redis.internal.executor.RedisKeyCommandsFunctionExecutor;
-  private static final int numExpirationThreads = 1;
-   * Map of futures to be executed for key expirations
-   */
-  private final ConcurrentMap<ByteArrayWrapper, ScheduledFuture<?>> expirationFutures;
-
-  /**
-    expirationFutures = new ConcurrentHashMap<>();
-    expirationExecutor =
-        Executors.newScheduledThreadPool(numExpirationThreads,
-            new NamedThreadFactory("GemFireRedis-ScheduledExecutor-", true));
+    expirationExecutor = Executors.newSingleThreadScheduledExecutor(
+        new NamedThreadFactory("GemFireRedis-ExpirationExecutor-", true));
-      regionProvider = new RegionProvider(expirationFutures, expirationExecutor, redisData);
+      regionProvider = new RegionProvider(redisData);
-      CommandFunction.register(regionProvider);
+      CommandFunction.register();
+      scheduleDataExpiration(redisData);
+    }
+  }
+
+  private void scheduleDataExpiration(
+      Region<ByteArrayWrapper, RedisData> redisData) {
+    int INTERVAL = 1;
+    expirationExecutor.scheduleAtFixedRate(() -> doDataExpiration(redisData), INTERVAL, INTERVAL,
+        SECONDS);
+  }
+
+  private void doDataExpiration(
+      Region<ByteArrayWrapper, RedisData> redisData) {
+    final long now = System.currentTimeMillis();
+    Region<ByteArrayWrapper, RedisData> localPrimaryData =
+        PartitionRegionHelper.getLocalPrimaryData(redisData);
+    RedisKeyCommands redisKeyCommands = new RedisKeyCommandsFunctionExecutor(redisData);
+    for (Map.Entry<ByteArrayWrapper, RedisData> entry : localPrimaryData.entrySet()) {
+      if (entry.getValue().hasExpired(now)) {
+        // pttl will do its own check using active expiration and expire the key if needed
+        redisKeyCommands.pttl(entry.getKey());
+      }
-      regionProvider.close();
-      for (ScheduledFuture<?> f : expirationFutures.values()) {
-        f.cancel(true);
-      }
-      expirationFutures.clear();

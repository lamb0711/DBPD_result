Merge remote-tracking branch 'origin/develop' into feature/GEODE-3239

+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.security.cert.X509Certificate;
-import java.util.Map;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
-import org.springframework.shell.core.annotation.CliCommand;
-import org.springframework.shell.core.annotation.CliOption;
-
-import org.apache.geode.internal.lang.Initializer;
+import org.apache.geode.management.internal.cli.CliUtil;
-import org.apache.geode.management.internal.web.domain.LinkIndex;
-import org.apache.geode.management.internal.web.http.support.SimpleHttpRequester;
-import org.apache.geode.management.internal.web.shell.RestHttpOperationInvoker;
+import org.springframework.shell.core.annotation.CliCommand;
+import org.springframework.shell.core.annotation.CliOption;
-  private static UserInputProperty[] USERINPUTPROPERTIES =
+  private static final UserInputProperty[] USER_INPUT_PROPERTIES =
-    // ssl options are passed in in the order defined in USERINPUTPROPERTIES, note the two types
+    // ssl options are passed in in the order defined in USER_INPUT_PROPERTIES, note the two types
-      if (skipSslValidation) {
-        HttpsURLConnection.setDefaultHostnameVerifier((String s, SSLSession sslSession) -> true);
-      }
-      result = httpConnect(gfProperties, url);
+      result = httpConnect(gfProperties, url, skipSslValidation);
-   * @param sslOptionValues an array of 9 in this order, as defined in USERINPUTPROPERTIES
+   * @param sslOptionValues an array of 9 in this order, as defined in USER_INPUT_PROPERTIES
-    for (int i = 0; i < USERINPUTPROPERTIES.length; i++) {
-      UserInputProperty userInputProperty = USERINPUTPROPERTIES[i];
+    for (int i = 0; i < USER_INPUT_PROPERTIES.length; i++) {
+      UserInputProperty userInputProperty = USER_INPUT_PROPERTIES[i];
-        properties.putAll(ShellCommands.loadProperties(file));
+        properties.putAll(loadPropertiesFromFile(file));
-  static boolean containsSSLConfig(Properties properties) {
+  private static boolean containsSSLConfig(Properties properties) {
-  Result httpConnect(Properties gfProperties, String url) {
+  Result httpConnect(Properties gfProperties, String url, boolean skipSslVerification) {
-        configureHttpsURLConnection(sslConfig);
+        configureHttpsURLConnection(sslConfig, skipSslVerification);
-      // This is so that SSL termination results in https URLs being returned
-      String query = (url.startsWith("https")) ? "?scheme=https" : "";
+      // authentication check will be triggered inside the constructor
+      HttpOperationInvoker operationInvoker = new HttpOperationInvoker(gfsh, url, gfProperties);
-      LogWrapper.getInstance().warning(String.format(
-          "Sending HTTP request for Link Index at (%1$s)...", url.concat("/index").concat(query)));
-
-      LinkIndex linkIndex =
-          new SimpleHttpRequester(gfsh, CONNECT_LOCATOR_TIMEOUT_MS, (Map) gfProperties)
-              .exchange(url.concat("/index").concat(query), LinkIndex.class);
-
-      LogWrapper.getInstance()
-          .warning(String.format("Received Link Index (%1$s)", linkIndex.toString()));
-
-      HttpOperationInvoker operationInvoker =
-          new RestHttpOperationInvoker(linkIndex, gfsh, url, (Map) gfProperties);
-
-      Initializer.init(operationInvoker);
-      return httpConnect(gfProperties, url);
+      return httpConnect(gfProperties, url, skipSslVerification);
-  private void configureHttpsURLConnection(SSLConfig sslConfig) throws Exception {
+  private KeyManager[] getKeyManagers(SSLConfig sslConfig) throws Exception {
-    FileInputStream trustStoreStream = null;
+    KeyManagerFactory keyManagerFactory = null;
+
-      KeyManagerFactory keyManagerFactory = null;
+    } finally {
+      if (keyStoreStream != null) {
+        keyStoreStream.close();
+      }
+    }
+    return keyManagerFactory != null ? keyManagerFactory.getKeyManagers() : null;
+  }
+
+  private TrustManager[] getTrustManagers(SSLConfig sslConfig, boolean skipSslVerification)
+      throws Exception {
+    FileInputStream trustStoreStream = null;
+    TrustManagerFactory trustManagerFactory = null;
+
+    if (skipSslVerification) {
+      TrustManager[] trustAllCerts = new TrustManager[] {new X509TrustManager() {
+        public java.security.cert.X509Certificate[] getAcceptedIssuers() {
+          return null;
+        }
+
+        public void checkClientTrusted(X509Certificate[] certs, String authType) {}
+
+        public void checkServerTrusted(X509Certificate[] certs, String authType) {}
+
+      }};
+      return trustAllCerts;
+    }
+
+    try {
-      TrustManagerFactory trustManagerFactory = null;
-
-      SSLContext ssl =
-          SSLContext.getInstance(SSLUtil.getSSLAlgo(SSLUtil.readArray(sslConfig.getProtocols())));
-
-      ssl.init(keyManagerFactory != null ? keyManagerFactory.getKeyManagers() : null,
-          trustManagerFactory != null ? trustManagerFactory.getTrustManagers() : null,
-          new SecureRandom());
-
-      HttpsURLConnection.setDefaultSSLSocketFactory(ssl.getSocketFactory());
-      if (keyStoreStream != null) {
-        keyStoreStream.close();
-      }
+    return trustManagerFactory != null ? trustManagerFactory.getTrustManagers() : null;
+  }
+
+  private void configureHttpsURLConnection(SSLConfig sslConfig, boolean skipSslVerification)
+      throws Exception {
+    KeyManager[] keyManagers = getKeyManagers(sslConfig);
+    TrustManager[] trustManagers = getTrustManagers(sslConfig, skipSslVerification);
+
+    if (skipSslVerification) {
+      HttpsURLConnection.setDefaultHostnameVerifier((String s, SSLSession sslSession) -> true);
+    }
+
+    SSLContext ssl =
+        SSLContext.getInstance(SSLUtil.getSSLAlgo(SSLUtil.readArray(sslConfig.getProtocols())));
+
+    ssl.init(keyManagers, trustManagers, new SecureRandom());
+
+    HttpsURLConnection.setDefaultSSLSocketFactory(ssl.getSocketFactory());
+
+  private static Properties loadPropertiesFromFile(File propertyFile) {
+    try {
+      return loadPropertiesFromUrl(propertyFile.toURI().toURL());
+    } catch (MalformedURLException e) {
+      throw new RuntimeException(
+          CliStrings.format("Failed to load configuration properties from pathname (%1$s)!",
+              propertyFile.getAbsolutePath()),
+          e);
+    }
+  }
+
+  private static Properties loadPropertiesFromUrl(URL url) {
+    Properties properties = new Properties();
+
+    if (url == null) {
+      return properties;
+    }
+
+    try (InputStream inputStream = url.openStream()) {
+      properties.load(inputStream);
+    } catch (IOException io) {
+      throw new RuntimeException(
+          CliStrings.format(CliStrings.CONNECT__MSG__COULD_NOT_READ_CONFIG_FROM_0,
+              CliUtil.decodeWithDefaultCharSet(url.getPath())),
+          io);
+    }
+
+    return properties;
+  }

GEODE-6626: Cleanup ServerConnection warnings

Co-authored-by: Mark Hanson <mhanson@pivotal.io>

+import java.lang.reflect.InvocationTargetException;
+import java.nio.channels.ClosedChannelException;
+import org.apache.geode.security.NotAuthorizedException;
-      !(Boolean.getBoolean(DISALLOW_INTERNAL_MESSAGES_WITHOUT_CREDENTIALS_NAME));
+      !Boolean.getBoolean(DISALLOW_INTERNAL_MESSAGES_WITHOUT_CREDENTIALS_NAME);
-  private Message replyMessage = new Message(1, Version.CURRENT);
-  private Message responseMessage = new Message(1, Version.CURRENT);
-  private Message errorMessage = new Message(1, Version.CURRENT);
+  private final Message replyMessage = new Message(1, Version.CURRENT);
+  private final Message responseMessage = new Message(1, Version.CURRENT);
+  private final Message errorMessage = new Message(1, Version.CURRENT);
-  private ChunkedMessage queryResponseMessage = new ChunkedMessage(2, Version.CURRENT);
-  private ChunkedMessage chunkedResponseMessage = new ChunkedMessage(1, Version.CURRENT);
-  private ChunkedMessage executeFunctionResponseMessage = new ChunkedMessage(1, Version.CURRENT);
-  private ChunkedMessage registerInterestResponseMessage = new ChunkedMessage(1, Version.CURRENT);
-  private ChunkedMessage keySetResponseMessage = new ChunkedMessage(1, Version.CURRENT);
+  private final ChunkedMessage queryResponseMessage = new ChunkedMessage(2, Version.CURRENT);
+  private final ChunkedMessage chunkedResponseMessage = new ChunkedMessage(1, Version.CURRENT);
+  private final ChunkedMessage executeFunctionResponseMessage =
+      new ChunkedMessage(1, Version.CURRENT);
+  private final ChunkedMessage registerInterestResponseMessage =
+      new ChunkedMessage(1, Version.CURRENT);
+  private final ChunkedMessage keySetResponseMessage = new ChunkedMessage(1, Version.CURRENT);
-   * The communication mode for this <code>ServerConnection</code>. Valid types include
+   * The communication mode for this {@code ServerConnection}. Valid types include
-  private Random randomConnectionIdGen;
+  private final Random randomConnectionIdGen;
-  private Part securePart = null;
+  private Part securePart;
-  private static boolean TEST_VERSION_AFTER_HANDSHAKE_FLAG = false;
+  private static boolean TEST_VERSION_AFTER_HANDSHAKE_FLAG;
-   * Creates a new <code>ServerConnection</code> that processes messages received from an edge
-   * client over a given <code>Socket</code>.
+   * Creates a new {@code ServerConnection} that processes messages received from an edge
+   * client over a given {@code Socket}.
-        } else {
-          // is this branch ever taken?
-          crHelper.checkCancelInProgress(null);
-          logger.warn("Received Unknown handshake reply code.");
-          refuseHandshake("Received Unknown handshake reply code.", Handshake.REPLY_INVALID);
-          return false;
+        // is this branch ever taken?
+        crHelper.checkCancelInProgress(null); // bug 37113?
+        logger.warn("Received Unknown handshake reply code.");
+        refuseHandshake("Received Unknown handshake reply code.", Handshake.REPLY_INVALID);
+        return false;
+        // Bug #52023.
-  private boolean incedCleanupTableRef = false;
-  private boolean incedCleanupProxyIdTableRef = false;
+  private boolean incedCleanupTableRef;
+  private boolean incedCleanupProxyIdTableRef;
-  private boolean chmRegistered = false;
+  private boolean chmRegistered;
-    boolean registerClient = false;
-        } else {
-          if (acceptHandShake(endpointType, queueSize)) {
-            clientJoined = true;
-            getCleanupTable().put(handshake, new MutableInt(1));
-            incedCleanupTableRef = true;
-            stats.incCurrentClients();
-            result = true;
-          }
-          return result;
+        if (acceptHandShake(endpointType, queueSize)) {
+          clientJoined = true;
+          getCleanupTable().put(handshake, new MutableInt(1));
+          incedCleanupTableRef = true;
+          stats.incCurrentClients();
+          result = true;
+        }
+        return result;
+      boolean registerClient = false;
-        logger.debug("{}registering client {}", (registerClient ? "" : "not "), proxyId);
+        logger.debug("{}registering client {}", registerClient ? "" : "not ", proxyId);
-  private boolean clientDisconnectedCleanly = false;
+  private boolean clientDisconnectedCleanly;
-  private int failureCount = 0;
+  private int failureCount;
-    Message message;
-    message = BaseCommand.readRequest(this);
+    Message message = BaseCommand.readRequest(this);
-            } else {
-              return;
+            return;
-            logger.warn(
-                "Failed to bind the subject of uniqueId {} for message {} with {} : Possible re-authentication required",
+            logger.error("Failed to bind the subject of uniqueId {} for message {} with {}",
-  private boolean terminated = false;
+  private boolean terminated;
-    boolean cleanupStats = false;
-    boolean clientDeparted = false;
-    boolean unregisterClient = false;
+    boolean clientDeparted = false;
+    boolean cleanupStats = false;
+    boolean unregisterClient = false;
-    } else {
-      if (AcceptorImpl.isAuthenticationRequired() && logger.isDebugEnabled()) {
-        logger.debug(
-            "ServerConnection.updateAndGetSecurityPart() not adding security part for message type {}",
-            MessageType.getString(requestMessage.messageType));
-      }
+    }
+    if (AcceptorImpl.isAuthenticationRequired() && logger.isDebugEnabled()) {
+      logger.debug(
+          "ServerConnection.updateAndGetSecurityPart() not adding security part for message type {}",
+          MessageType.getString(requestMessage.messageType));
-          if (processMessages && !(crHelper.isShutdown())) {
+          if (processMessages && !crHelper.isShutdown()) {
-      } catch (java.nio.channels.ClosedChannelException | CancelException ignore) {
+      } catch (ClosedChannelException | CancelException ignore) {
-        logger.warn(ex.toString() + " : Unexpected Exception");
+        logger.warn(ex + " : Unexpected Exception");
-        while (processMessages && !(crHelper.isShutdown())) {
+        while (processMessages && !crHelper.isShutdown()) {
-  void registerWithSelector2(Selector s) throws IOException {
+  void registerWithSelector2(Selector s) throws ClosedChannelException {
-  private static boolean forceClientCrashEvent = false;
+  private static boolean forceClientCrashEvent;
-    } else {
-      return requestSpecificTimeout;
+    return requestSpecificTimeout;
-  private void setOwner() {
+  private void setOwner() { // TODO:KIRK
+      owner = Thread.currentThread();
-  private void unsetOwner() {
+  private void unsetOwner() { // TODO:KIRK
+      owner = null;
-      ServerConnection.releaseCommBuffer(byteBuffer);
+      releaseCommBuffer(byteBuffer);
-  private Object modKey = null;
-  private String modRegion = null;
+  private Object modKey;
+  private String modRegion;
-      } else {
-        logger.debug("Unexpected exception", npe);
+      logger.debug("Unexpected exception {}", npe);
-          ((authReq == null) ? "NULL (only authentication is required)" : "not null"));
+          authReq == null ? "NULL (only authentication is required)" : "not null");
-    UserAuthAttributes uaa = getUserAuthAttributes();
-    if (uaa == null)
+    if (!AcceptorImpl.isAuthenticationRequired()) {
+    }
+
+    if (securityService.isIntegratedSecurity()) {
+      return null;
+    }
+
+    // look client version and return authzrequest
+    // for backward client it will be store in member variable userAuthId
+    // for other look "requestMessage" here and get unique-id from this to get the authzrequest
+    long uniqueId = getUniqueId();
+
+    UserAuthAttributes uaa = null;
+    try {
+      uaa = clientUserAuths.getUserAuthAttributes(uniqueId);
+    } catch (NullPointerException npe) {
+      if (isTerminated()) {
+        throw new IOException("Server connection is terminated.");
+      }
+      logger.debug("Unexpected exception", npe);
+    }
+    if (uaa == null) {
+      throw new AuthenticationRequiredException("User authorization attributes not found.");
+    }
-  private void setAuthAttributes() throws Exception {
+  private void setAuthAttributes()
+      throws AuthenticationRequiredException, AuthenticationFailedException, ClassNotFoundException,
+      NoSuchMethodException, InvocationTargetException, IOException, IllegalAccessException {
-  private long getUniqueId(Principal principal) throws Exception {
+  private long getUniqueId(Principal principal)
+      throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException,
+      InvocationTargetException, NotAuthorizedException, IOException {
-    AuthorizeRequestPP postAuthzRequest = null;
-    if (authzFactoryName != null && authzFactoryName.length() > 0) {
+    if (authzFactoryName != null && !authzFactoryName.isEmpty()) {
-    if (postAuthzFactoryName != null && postAuthzFactoryName.length() > 0) {
+    AuthorizeRequestPP postAuthzRequest = null;
+    if (postAuthzFactoryName != null && !postAuthzFactoryName.isEmpty()) {

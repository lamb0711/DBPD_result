GEODE-3685: MBean wrappers are properly invoked over http

This closes #838.

-import java.io.BufferedReader;
-import java.io.InputStreamReader;
+import org.apache.commons.lang.StringUtils;
-import org.springframework.http.HttpStatus;
-import org.springframework.web.client.ResponseErrorHandler;
-import org.apache.geode.internal.lang.StringUtils;
-import org.apache.geode.security.AuthenticationFailedException;
-import org.apache.geode.security.NotAuthorizedException;
-  protected static final long DEFAULT_INITIAL_DELAY = TimeUnit.SECONDS.toMillis(1);
-  protected static final long DEFAULT_PERIOD = TimeUnit.MILLISECONDS.toMillis(2000);
+  private static final long DEFAULT_INITIAL_DELAY = TimeUnit.SECONDS.toMillis(1);
+  private static final long DEFAULT_PERIOD = TimeUnit.MILLISECONDS.toMillis(2000);
-  protected static final String REST_API_BASE_URL = "http://localhost:8080";
-  protected static final String REST_API_VERSION = "/v1";
-  protected static final String REST_API_WEB_APP_CONTEXT = "/geode-mgmt";
-  protected static final String REST_API_URL =
+  private static final String REST_API_BASE_URL = "http://localhost:8080";
+  private static final String REST_API_VERSION = "/v1";
+  private static final String REST_API_WEB_APP_CONTEXT = "/geode-mgmt";
+  private static final String REST_API_URL =
-  protected static final String USER_AGENT_HTTP_REQUEST_HEADER_VALUE =
+  private static final String USER_AGENT_HTTP_REQUEST_HEADER_VALUE =
-  protected static final TimeUnit DEFAULT_TIME_UNIT = TimeUnit.MILLISECONDS;
+  private static final TimeUnit DEFAULT_TIME_UNIT = TimeUnit.MILLISECONDS;
-  protected static final String RESOURCES_REQUEST_PARAMETER = "resources";
+  private static final String RESOURCES_REQUEST_PARAMETER = "resources";
-  HttpOperationInvoker(final String baseUrl) {
+  private HttpOperationInvoker(final String baseUrl) {
-   * via HTTP for procsessing along with the base URL to the GemFire Manager's embedded HTTP service
+   * via HTTP for processing along with the base URL to the GemFire Manager's embedded HTTP service
-    // add our custom HttpMessageConverter for serializing DTO Objects into the HTTP request message
-    // body
-    // and de-serializing HTTP response message body content back into DTO Objects
+    // add our custom HttpMessageConverter for serializing DTO Objects into the HTTP request
+    // message body and de-serializing HTTP response message body content back into DTO Objects
-    this.restTemplate.setErrorHandler(new ResponseErrorHandler() {
-      @Override
-      public boolean hasError(final ClientHttpResponse response) throws IOException {
-        final HttpStatus status = response.getStatusCode();
+    this.restTemplate.setErrorHandler(new RestOperationErrorHandler(gfsh));
-        switch (status) {
-          case BAD_REQUEST: // 400 *
-          case UNAUTHORIZED: // 401
-          case FORBIDDEN: // 403
-          case NOT_FOUND: // 404 *
-          case METHOD_NOT_ALLOWED: // 405 *
-          case NOT_ACCEPTABLE: // 406 *
-          case REQUEST_TIMEOUT: // 408
-          case CONFLICT: // 409
-          case REQUEST_ENTITY_TOO_LARGE: // 413
-          case REQUEST_URI_TOO_LONG: // 414
-          case UNSUPPORTED_MEDIA_TYPE: // 415 *
-          case TOO_MANY_REQUESTS: // 429
-          case INTERNAL_SERVER_ERROR: // 500 *
-          case NOT_IMPLEMENTED: // 501
-          case BAD_GATEWAY: // 502 ?
-          case SERVICE_UNAVAILABLE: // 503
-            return true;
-          default:
-            return false;
-        }
-      }
-
-      @Override
-      public void handleError(final ClientHttpResponse response) throws IOException {
-        String body = readBody(response);
-        final String message = String.format("The HTTP request failed with: %1$d - %2$s.",
-            response.getRawStatusCode(), body);
-
-        if (gfsh.getDebug()) {
-          gfsh.logSevere(body, null);
-        }
-
-        if (response.getRawStatusCode() == 401) {
-          throw new AuthenticationFailedException(message);
-        } else if (response.getRawStatusCode() == 403) {
-          throw new NotAuthorizedException(message);
-        } else {
-          throw new RuntimeException(message);
-        }
-      }
-
-      private String readBody(final ClientHttpResponse response) throws IOException {
-        BufferedReader responseBodyReader = null;
-
-        try {
-          responseBodyReader = new BufferedReader(new InputStreamReader(response.getBody()));
-
-          final StringBuilder buffer = new StringBuilder();
-          String line;
-
-          while ((line = responseBodyReader.readLine()) != null) {
-            buffer.append(line).append(StringUtils.LINE_SEPARATOR);
-          }
-
-          return buffer.toString().trim();
-        } finally {
-          IOUtils.close(responseBodyReader);
-        }
-      }
-    });
-  protected void setupBackgroundPingRequest() {
+  private void setupBackgroundPingRequest() {
-  protected ScheduledExecutorService getExecutorService() {
+  private ScheduledExecutorService getExecutorService() {
-  protected RestTemplate getRestTemplate() {
+  private RestTemplate getRestTemplate() {
-  protected void printDebug(final String message, final Object... args) {
+  private void printDebug(final String message, final Object... args) {
-  void addHeaderValues(org.springframework.http.client.ClientHttpRequest request)
-      throws IOException {
+  private void addHeaderValues(org.springframework.http.client.ClientHttpRequest request) {
-  protected void initClusterId() {
+  private void initClusterId() {
-    MultiValueMap<String, Object> content = new LinkedMultiValueMap<String, Object>();
+    MultiValueMap<String, Object> content = new LinkedMultiValueMap<>();
-      return IOUtils
-          .deserializeObject(post(link, MediaType.MULTIPART_FORM_DATA, content, byte[].class));
+      byte[] postResult = post(link, MediaType.MULTIPART_FORM_DATA, content, byte[].class);
+      return IOUtils.deserializeObject(postResult);
-      MultiValueMap<String, Object> content = new LinkedMultiValueMap<String, Object>();
+      MultiValueMap<String, Object> content = new LinkedMultiValueMap<>();

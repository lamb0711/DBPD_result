Merge remote-tracking branch 'origin/develop' into wan_cq_donation

-import com.gemstone.gemfire.OutOfOffHeapMemoryException;
-    MemoryAllocator result;
-      result = null;
-    } else {
-      // Ensure that using off-heap will work with this JVM.
-      validateVmCompatibility();
-      
-      final OffHeapMemoryStats stats = new OffHeapStorage(sf);
-      
-      if (offHeapMemorySize < MIN_SLAB_SIZE) {
-        throw new IllegalArgumentException("The amount of off heap memory must be at least " + MIN_SLAB_SIZE + " but it was set to " + offHeapMemorySize);
-      }
-      
-      // determine off-heap and slab sizes
-      final long maxSlabSize = calcMaxSlabSize(offHeapMemorySize);
-      
-      final int slabCount = calcSlabCount(maxSlabSize, offHeapMemorySize);
-
-      if (system == null) {
-        throw new IllegalArgumentException("InternalDistributedSystem is null");
-      }
-      // ooohml provides the hook for disconnecting and closing cache on OutOfOffHeapMemoryException
-      OutOfOffHeapMemoryListener ooohml = new DisconnectingOutOfOffHeapMemoryListener((InternalDistributedSystem) system);
-      result = SimpleMemoryAllocatorImpl.create(ooohml, stats, lw, slabCount, offHeapMemorySize, maxSlabSize);
+      return null;
-    return result;
+
+    if (offHeapMemorySize < MIN_SLAB_SIZE) {
+      throw new IllegalArgumentException("The amount of off heap memory must be at least " + MIN_SLAB_SIZE + " but it was set to " + offHeapMemorySize);
+    }
+
+    // Ensure that using off-heap will work with this JVM.
+    validateVmCompatibility();
+
+    if (system == null) {
+      throw new IllegalArgumentException("InternalDistributedSystem is null");
+    }
+    // ooohml provides the hook for disconnecting and closing cache on OutOfOffHeapMemoryException
+    OutOfOffHeapMemoryListener ooohml = new DisconnectingOutOfOffHeapMemoryListener((InternalDistributedSystem) system);
+    return basicCreateOffHeapStorage(lw, sf, offHeapMemorySize, ooohml);
+  }
+  
+  static MemoryAllocator basicCreateOffHeapStorage(LogWriter lw, StatisticsFactory sf, long offHeapMemorySize, OutOfOffHeapMemoryListener ooohml) {
+    final OffHeapMemoryStats stats = new OffHeapStorage(sf);
+
+   // determine off-heap and slab sizes
+    final long maxSlabSize = calcMaxSlabSize(offHeapMemorySize);
+
+    final int slabCount = calcSlabCount(maxSlabSize, offHeapMemorySize);
+
+    return SimpleMemoryAllocatorImpl.create(ooohml, stats, lw, slabCount, offHeapMemorySize, maxSlabSize);
-  
-  static class DisconnectingOutOfOffHeapMemoryListener implements OutOfOffHeapMemoryListener {
-    private final Object lock = new Object();
-    private InternalDistributedSystem ids;
-    
-    DisconnectingOutOfOffHeapMemoryListener(InternalDistributedSystem ids) {
-      this.ids = ids;
-    }
-    
-    public void close() {
-      synchronized (lock) {
-        this.ids = null; // set null to prevent memory leak after closure!
-      }
-    }
-    
-    @Override
-    public void outOfOffHeapMemory(final OutOfOffHeapMemoryException cause) {
-      synchronized (lock) {
-        if (this.ids == null) {
-          return;
-        }
-        if (Boolean.getBoolean(STAY_CONNECTED_ON_OUTOFOFFHEAPMEMORY_PROPERTY)) {
-          return;
-        }
-        
-        final InternalDistributedSystem dsToDisconnect = this.ids;
-        this.ids = null; // set null to prevent memory leak after closure!
-        
-        if (dsToDisconnect.getDistributionManager().getRootCause() == null) {
-          dsToDisconnect.getDistributionManager().setRootCause(cause);
-        }
-          
-        Runnable runnable = new Runnable() {
-          @Override
-          public void run() {
-            dsToDisconnect.getLogWriter().info("OffHeapStorage about to invoke disconnect on " + dsToDisconnect);
-            dsToDisconnect.disconnect(cause.getMessage(), cause, false);
-          }
-        };
-        
-        // invoking disconnect is async because caller may be a DM pool thread which will block until DM shutdown times out
-
-        //LogWriterImpl.LoggingThreadGroup group = LogWriterImpl.createThreadGroup("MemScale Threads", ids.getLogWriterI18n());
-        String name = this.getClass().getSimpleName()+"@"+this.hashCode()+" Handle OutOfOffHeapMemoryException Thread";
-        //Thread thread = new Thread(group, runnable, name);
-        Thread thread = new Thread(runnable, name);
-        thread.setDaemon(true);
-        thread.start();
-      }
-    }
-  }

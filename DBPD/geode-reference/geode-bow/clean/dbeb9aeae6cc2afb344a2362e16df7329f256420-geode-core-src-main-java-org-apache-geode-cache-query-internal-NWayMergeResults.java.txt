Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * The n - way merge results returns a sorted results on the cumulative sorted
- * results for partitioned region based query
+ * The n - way merge results returns a sorted results on the cumulative sorted results for
+ * partitioned region based query
-public class NWayMergeResults<E> implements SelectResults<E>, Ordered,
-    DataSerializableFixedID {
+public class NWayMergeResults<E> implements SelectResults<E>, Ordered, DataSerializableFixedID {
-  public NWayMergeResults() {
-  }
+  public NWayMergeResults() {}
-  public NWayMergeResults(Collection<? extends Collection<E>> sortedResults,
-      boolean isDistinct, int limit,
-      List<CompiledSortCriterion> orderByAttribs, ExecutionContext context,
+  public NWayMergeResults(Collection<? extends Collection<E>> sortedResults, boolean isDistinct,
+      int limit, List<CompiledSortCriterion> orderByAttribs, ExecutionContext context,
-    this.collectionType = new CollectionTypeImpl(Ordered.class,
-        elementType);
-    this.data = new NWayMergeResultsCollection(sortedResults, limit,
-        orderByAttribs, context);
+    this.collectionType = new CollectionTypeImpl(Ordered.class, elementType);
+    this.data = new NWayMergeResultsCollection(sortedResults, limit, orderByAttribs, context);
-    throw new UnsupportedOperationException(
-        "Addition to collection not supported");
+    throw new UnsupportedOperationException("Addition to collection not supported");
-    throw new UnsupportedOperationException(
-        "Removal from collection not supported");
+    throw new UnsupportedOperationException("Removal from collection not supported");
-    throw new UnsupportedOperationException(
-        "Addition to collection not supported");
+    throw new UnsupportedOperationException("Addition to collection not supported");
-    throw new UnsupportedOperationException(
-        "Removal from collection not supported");
+    throw new UnsupportedOperationException("Removal from collection not supported");
-    throw new UnsupportedOperationException(
-        "Removal from collection not supported");
+    throw new UnsupportedOperationException("Removal from collection not supported");
-    throw new UnsupportedOperationException(
-        "Removal from collection not supported");
+    throw new UnsupportedOperationException("Removal from collection not supported");
-    for (Iterator<E> itr = this.iterator()/* this.base.iterator() */; itr
-        .hasNext();) {
+    for (Iterator<E> itr = this.iterator()/* this.base.iterator() */; itr.hasNext();) {
-    public NWayMergeResultsCollection(
-        Collection<? extends Collection<E>> sortedResults, int limit,
+    public NWayMergeResultsCollection(Collection<? extends Collection<E>> sortedResults, int limit,
-      this.comparator = new OrderByComparator(orderByAttribs,
-          collectionType.getElementType(), context);
+      this.comparator =
+          new OrderByComparator(orderByAttribs, collectionType.getElementType(), context);
-     * @Override public boolean isEmpty() { boolean isEmpty = true; for
-     * (SelectResults<E> result : this.sortedResults) { isEmpty =
-     * result.isEmpty(); if (!isEmpty) { break; } } return isEmpty; }
+     * @Override public boolean isEmpty() { boolean isEmpty = true; for (SelectResults<E> result :
+     * this.sortedResults) { isEmpty = result.isEmpty(); if (!isEmpty) { break; } } return isEmpty;
+     * }
-          IteratorWrapper<E> temp = new IteratorWrapper<E>(listIter.next()
-              .iterator());
+          IteratorWrapper<E> temp = new IteratorWrapper<E>(listIter.next().iterator());
-          int compareResult = compare(currentOptima, temp); 
-              
+          int compareResult = compare(currentOptima, temp);
+
-      
+
-            .compare(((StructImpl) obj1).getFieldValues(),
-                ((StructImpl) obj2).getFieldValues()) : comparator.compare(
-            obj1, obj2);
-            
+            .compare(((StructImpl) obj1).getFieldValues(), ((StructImpl) obj2).getFieldValues())
+            : comparator.compare(obj1, obj2);
+
-      NWayMergeDistinctIterator() {
-      }
+      NWayMergeDistinctIterator() {}
-          if (this.uninitialized) {            
+          if (this.uninitialized) {
-                }// else if (!this.lastReturned.equals(this.iterators[i].get()))
-                 // {
+                } // else if (!this.lastReturned.equals(this.iterators[i].get()))
+                  // {
-                else if (compare(this.iterators[i].get(),
-                    this.lastReturned) != 0) {
+                else if (compare(this.iterators[i].get(), this.lastReturned) != 0) {
-      
+
-    
+
-    this.collectionType = new CollectionTypeImpl(NWayMergeResults.class, elementType );
+    this.collectionType = new CollectionTypeImpl(NWayMergeResults.class, elementType);
-      if(isStruct) {
+      if (isStruct) {
-        this.data.add((E)new StructImpl((StructTypeImpl) elementType, fields));
-      }else {
+        this.data.add((E) new StructImpl((StructTypeImpl) elementType, fields));
+      } else {
-      E data = iter.next();      
-      if(isStruct) {
-        Object[] fields = ((Struct)data).getFieldValues();
+      E data = iter.next();
+      if (isStruct) {
+        Object[] fields = ((Struct) data).getFieldValues();
-      }else {
+      } else {
-    StringBuilder builder = new StringBuilder("NWayMergeResults:: isDistinct="
-        + this.isDistinct).append(":");
+    StringBuilder builder =
+        new StringBuilder("NWayMergeResults:: isDistinct=" + this.isDistinct).append(":");
-    if(this.data instanceof NWayMergeResults.NWayMergeResultsCollection) {
-      return ((NWayMergeResultsCollection)this.data).comparator;
-    }else {
+    if (this.data instanceof NWayMergeResults.NWayMergeResultsCollection) {
+      return ((NWayMergeResultsCollection) this.data).comparator;
+    } else {
-    if(this.data instanceof NWayMergeResults.NWayMergeResultsCollection) {
+    if (this.data instanceof NWayMergeResults.NWayMergeResultsCollection) {
-    }else {
+    } else {

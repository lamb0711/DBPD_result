Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * Provides advice on sending distribution messages. For a given operation,
- * this advisor will provide a list of recipients that a message should be
- * sent to, and other information depending on the operation. Each distributed
- * entity that can have remote counterparts maintains an instance of
- * <code>DistributionAdvisor</code> and maintains it by giving it a
- * <code>Profile</code> for each of its remote counterparts, and telling it
- * to delete a profile when that counterpart no longer exists.
- *<p>
- * Provides <code>advise</code> methods for each type of operation that requires
- * specialized decision making based on the profiles. For all other operations
- * that do not require specialized decision making, the {@link #adviseGeneric}
- * method is provided.
- *<p>
- * A primary design goal of this class is scalability: the footprint must be
- * kept to a minimum as the number of instances grows across a growing number
- * of members in the distributed system.
+ * Provides advice on sending distribution messages. For a given operation, this advisor will
+ * provide a list of recipients that a message should be sent to, and other information depending on
+ * the operation. Each distributed entity that can have remote counterparts maintains an instance of
+ * <code>DistributionAdvisor</code> and maintains it by giving it a <code>Profile</code> for each of
+ * its remote counterparts, and telling it to delete a profile when that counterpart no longer
+ * exists.
+ * <p>
+ * Provides <code>advise</code> methods for each type of operation that requires specialized
+ * decision making based on the profiles. For all other operations that do not require specialized
+ * decision making, the {@link #adviseGeneric} method is provided.
+ * <p>
+ * A primary design goal of this class is scalability: the footprint must be kept to a minimum as
+ * the number of instances grows across a growing number of members in the distributed system.
-public class DistributionAdvisor  {
+public class DistributionAdvisor {
-   * Specifies the starting version number for the  
-   * profileVersionSequencer.
+   * Specifies the starting version number for the profileVersionSequencer.
-  public static final int START_VERSION_NUMBER = Integer.getInteger(
-      DistributionConfig.GEMFIRE_PREFIX + "DistributionAdvisor.startVersionNumber", 1).intValue();
-  
+  public static final int START_VERSION_NUMBER = Integer
+      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "DistributionAdvisor.startVersionNumber", 1)
+      .intValue();
+
-  public static final int START_SERIAL_NUMBER = Integer.getInteger(
-      DistributionConfig.GEMFIRE_PREFIX + "Cache.startSerialNumber",
-      1 // Integer.MAX_VALUE-10
+  public static final int START_SERIAL_NUMBER =
+      Integer.getInteger(DistributionConfig.GEMFIRE_PREFIX + "Cache.startSerialNumber", 1 // Integer.MAX_VALUE-10
-   * Used to compare profile versioning numbers against 
-   * {@link Integer#MAX_VALUE} and {@link Integer#MIN_VALUE} to determine
-   * if a rollover has occurred.
+   * Used to compare profile versioning numbers against {@link Integer#MAX_VALUE} and
+   * {@link Integer#MIN_VALUE} to determine if a rollover has occurred.
-  public static final int ROLLOVER_THRESHOLD = Integer.getInteger(
-      DistributionConfig.GEMFIRE_PREFIX + "CacheDistributionAdvisor.rolloverThreshold",
-      1000).intValue();
-  
-  /**
-   * {@link Integer#MAX_VALUE} minus {@link #ROLLOVER_THRESHOLD} determines the
-   * upper threshold for rollover comparison.
-   */
-  private static final int ROLLOVER_THRESHOLD_UPPER = 
-    Integer.MAX_VALUE - ROLLOVER_THRESHOLD;
+  public static final int ROLLOVER_THRESHOLD = Integer
+      .getInteger(DistributionConfig.GEMFIRE_PREFIX + "CacheDistributionAdvisor.rolloverThreshold",
+          1000)
+      .intValue();
-   * {@link Integer#MIN_VALUE} plus {@link #ROLLOVER_THRESHOLD} determines the
-   * lower threshold for rollover comparison.
+   * {@link Integer#MAX_VALUE} minus {@link #ROLLOVER_THRESHOLD} determines the upper threshold for
+   * rollover comparison.
-  private static final int ROLLOVER_THRESHOLD_LOWER = 
-    Integer.MIN_VALUE + ROLLOVER_THRESHOLD;
+  private static final int ROLLOVER_THRESHOLD_UPPER = Integer.MAX_VALUE - ROLLOVER_THRESHOLD;
+
+  /**
+   * {@link Integer#MIN_VALUE} plus {@link #ROLLOVER_THRESHOLD} determines the lower threshold for
+   * rollover comparison.
+   */
+  private static final int ROLLOVER_THRESHOLD_LOWER = Integer.MIN_VALUE + ROLLOVER_THRESHOLD;
+   * 
-  
-  /** This system property is not supported and disabling intelligent messaging
-   *  is currently problematic
+
+  /**
+   * This system property is not supported and disabling intelligent messaging is currently
+   * problematic
-  
-  /** Indicates whether this advisor is has been initialized. This will be
-   * false when a shared region is mapped into the cache but there has
-   * been no distributed operations done on it yet.
+
+  /**
+   * Indicates whether this advisor is has been initialized. This will be false when a shared region
+   * is mapped into the cache but there has been no distributed operations done on it yet.
-  /** Synchronization lock used for controlling access to initialization.
-   * We do not synchronize on this advisor itself because we use that
-   * synchronization for putProfile and we can not lock out putProfile
-   * while we are doing initialization
+  /**
+   * Synchronization lock used for controlling access to initialization. We do not synchronize on
+   * this advisor itself because we use that synchronization for putProfile and we can not lock out
+   * putProfile while we are doing initialization
-  
+
+   * 
-  
+
-   * whether membership ops are closed (because the DA's been closed).
-   * Access under synchronization on (this)
+   * whether membership ops are closed (because the DA's been closed). Access under synchronization
+   * on (this)
-  
+
-   * the number of operations in-progress for previous versions
-   * of the profile set.  Guarded by opCountLock
+   * the number of operations in-progress for previous versions of the profile set. Guarded by
+   * opCountLock
-   * the number of operations in-progress for the current version of
-   * the profile set.  Guarded by opCountLock
+   * the number of operations in-progress for the current version of the profile set. Guarded by
+   * opCountLock
-   * Hold onto removed profiles to compare to late-processed profiles. Fix for
-   * bug 36881. Protected by synchronizing on this DistributionAdvisor.
-   * guarded.By this DistributionAdvisor
+   * Hold onto removed profiles to compare to late-processed profiles. Fix for bug 36881. Protected
+   * by synchronizing on this DistributionAdvisor. guarded.By this DistributionAdvisor
-  
+
-   * A collection of MembershipListeners that want to be notified when
-   * a profile is added to or removed from this DistributionAdvisor.
-   * The keys are membership listeners and the values are Boolean.TRUE.
+   * A collection of MembershipListeners that want to be notified when a profile is added to or
+   * removed from this DistributionAdvisor. The keys are membership listeners and the values are
+   * Boolean.TRUE.
-  
+
-   * A collection of listeners for changes to profiles. These listeners
-   * are notified if a profile is added, removed, or updated.
+   * A collection of listeners for changes to profiles. These listeners are notified if a profile is
+   * added, removed, or updated.
-  
-  /** The resource getting advise from this.
+
+  /**
+   * The resource getting advise from this.
-  /** The membership listener registered with the dm.
+  /**
+   * The membership listener registered with the dm.
-      public void quorumLost(Set<InternalDistributedMember> failures, List<InternalDistributedMember> remaining) {
-      }
+      public void quorumLost(Set<InternalDistributedMember> failures,
+          List<InternalDistributedMember> remaining) {}
-        boolean removed = removeId(id, crashed, false/*destroyed*/, true/*fromMembershipListener*/);
+        boolean removed =
+            removeId(id, crashed, false/* destroyed */, true/* fromMembershipListener */);
-        // sync with other members in case an update was lost.  We do this in the
+        // sync with other members in case an update was lost. We do this in the
-          InternalDistributedMember whoSuspected, String reason) {
-      }
-      
-   };
+          InternalDistributedMember whoSuspected, String reason) {}
+
+    };
-  
+
-  
+
-  
+
-   * determine whether a delta-gii synchronization should be performed for
-   * this lost member
+   * determine whether a delta-gii synchronization should be performed for this lost member
+   * 
-    return (this.advisee instanceof DistributedRegion) && ((DistributedRegion)this.advisee).shouldSyncForCrashedMember(id);
+    return (this.advisee instanceof DistributedRegion)
+        && ((DistributedRegion) this.advisee).shouldSyncForCrashedMember(id);
-  
+
-                logger.debug("da.syncForCrashedMember waiting for region to finish initializing: {}", dr);
+                logger.debug(
+                    "da.syncForCrashedMember waiting for region to finish initializing: {}", dr);
-        if(dr.getDataPolicy().withPersistence() && persistentId==null) {
-          //Fix for 46704. The lost member may be a replicate
-          //or an empty accessor. We don't need to to a synchronization
-          //in that case, because those members send their writes to
-          //a persistent member.
+        if (dr.getDataPolicy().withPersistence() && persistentId == null) {
+          // Fix for 46704. The lost member may be a replicate
+          // or an empty accessor. We don't need to to a synchronization
+          // in that case, because those members send their writes to
+          // a persistent member.
-            logger.debug("da.syncForCrashedMember skipping sync because crashed member is not persistent: {}", id);
+            logger.debug(
+                "da.syncForCrashedMember skipping sync because crashed member is not persistent: {}",
+                id);
-        
-        
+
+
-        if(persistentId != null) {
+        if (persistentId != null) {
-  
+
-      return (DistributedRegion)this.advisee;
+      return (DistributedRegion) this.advisee;
-   * Increment and get next profile version from {@link 
-   * #profileVersionSequencer}.
+   * Increment and get next profile version from {@link #profileVersionSequencer}.
+   * 
-  
+
-   * Generates a serial number for identifying a logical resource. Later instances of
-   * the same logical resource will have a greater serial number than earlier
-   * instances. This number increments statically throughout the life of this
-   * JVM. Rollover to negative is allowed.
+   * Generates a serial number for identifying a logical resource. Later instances of the same
+   * logical resource will have a greater serial number than earlier instances. This number
+   * increments statically throughout the life of this JVM. Rollover to negative is allowed.
+   * 
-      synchronized(this) {
+      synchronized (this) {
-        synchronized(this.opCountLock) {
+        synchronized (this.opCountLock) {
-    }
-    catch (CancelException e) {
+    } catch (CancelException e) {
-    }
-    catch (IllegalArgumentException ignore) {
+    } catch (IllegalArgumentException ignore) {
-   * Atomically add listener to the list to receive notification when a 
-   * *new* profile is added or a profile is removed, and return adviseGeneric(). 
-   * This ensures that no membership listener calls are missed, but there is no guarantee
-   * that there won't be redundant listener calls.
+   * Atomically add listener to the list to receive notification when a *new* profile is added or a
+   * profile is removed, and return adviseGeneric(). This ensures that no membership listener calls
+   * are missed, but there is no guarantee that there won't be redundant listener calls.
-   * Add listener to the list to receive notification when a 
-   * profile is added or removed. Note that there is no guarantee that
-   * the listener will not get redundant calls, but the listener is guaranteed
-   * to get a call.
+   * Add listener to the list to receive notification when a profile is added or removed. Note that
+   * there is no guarantee that the listener will not get redundant calls, but the listener is
+   * guaranteed to get a call.
-  
+
-  
+
-   * Remove listener from the list to receive notification when a provile is 
-   * added or removed.
+   * Remove listener from the list to receive notification when a provile is added or removed.
+   * 
-    if(this.initialized) {
+    if (this.initialized) {
-   * Polls the isInitialized state. Unlike {@link #isInitialized} it will
-   * not wait for it to become initialized if it is in the middle of being
-   * initialized.
+   * Polls the isInitialized state. Unlike {@link #isInitialized} it will not wait for it to become
+   * initialized if it is in the middle of being initialized.
+   * 
-  /** 
+  /**
+   * 
-   * @param profile
-   *        the profile, referenced by this advisor after this method returns.
+   * 
+   * @param profile the profile, referenced by this advisor after this method returns.
-  public synchronized boolean putProfile(Profile newProfile, 
-                                         boolean forceProfile) {
+  public synchronized boolean putProfile(Profile newProfile, boolean forceProfile) {
-    }
-    finally {
+    } finally {
-   * Return true if the memberId on the specified Profile is a current
-   * member of the distributed system.
+   * Return true if the memberId on the specified Profile is a current member of the distributed
+   * system.
+   * 
-  
+
-   * Update the Advisor with profiles
-   * describing remote instances of the
-   * {@link DistributionAdvisor#getAdvisee()}. Profile
-   * information is versioned via
-   * {@link Profile#getVersion()} 
-   * and may be ignored if an older version is
-   * received after newer versions.
+   * Update the Advisor with profiles describing remote instances of the
+   * {@link DistributionAdvisor#getAdvisee()}. Profile information is versioned via
+   * {@link Profile#getVersion()} and may be ignored if an older version is received after newer
+   * versions.
-   * @param forceProfile true will force profile to be added even if member is
-   * not in distributed view (should only ever be true for tests that need to
-   * inject a bad profile)
+   * @param forceProfile true will force profile to be added even if member is not in distributed
+   *        view (should only ever be true for tests that need to inject a bad profile)
-  private synchronized boolean doPutProfile(Profile newProfile, 
-                                            boolean forceProfile) {
+  private synchronized boolean doPutProfile(Profile newProfile, boolean forceProfile) {
-          logger.trace(LogMarker.DA, "putProfile: ignoring {}; not in current view for {}", newProfile.getDistributedMember(), getAdvisee().getFullPath());
+          logger.trace(LogMarker.DA, "putProfile: ignoring {}; not in current view for {}",
+              newProfile.getDistributedMember(), getAdvisee().getFullPath());
-        
+
-    
+
-    Integer removedSerialNumber = 
-      (Integer) this.removedProfiles.get(newProfile.getId());
-    if (removedSerialNumber != null &&
-        !isNewerSerialNumber(newProfile.getSerialNumber(), 
-                             removedSerialNumber.intValue())) {
+    Integer removedSerialNumber = (Integer) this.removedProfiles.get(newProfile.getId());
+    if (removedSerialNumber != null
+        && !isNewerSerialNumber(newProfile.getSerialNumber(), removedSerialNumber.intValue())) {
-        logger.trace(LogMarker.DA, "putProfile: Skipping putProfile: {} is not newer than serialNumber {} for {}", newProfile, removedSerialNumber, getAdvisee().getFullPath());
+        logger.trace(LogMarker.DA,
+            "putProfile: Skipping putProfile: {} is not newer than serialNumber {} for {}",
+            newProfile, removedSerialNumber, getAdvisee().getFullPath());
-      logger.trace(LogMarker.DA, "putProfile: Updating existing profile: {} with new profile: {} for {}", oldProfile, newProfile, getAdvisee().getFullPath());
+      logger.trace(LogMarker.DA,
+          "putProfile: Updating existing profile: {} with new profile: {} for {}", oldProfile,
+          newProfile, getAdvisee().getFullPath());
-        logger.trace(LogMarker.DA, "putProfile: Ignoring {} because it's older than or same as {} for {}", newProfile, oldProfile,getAdvisee().getFullPath());
+        logger.trace(LogMarker.DA,
+            "putProfile: Ignoring {} because it's older than or same as {} for {}", newProfile,
+            oldProfile, getAdvisee().getFullPath());
-    
+
-      }
-      else {
+      } else {
-            logger.trace(LogMarker.STATE_FLUSH_OP, "StateFlush incremented membership version: {}", membershipVersion);
+            logger.trace(LogMarker.STATE_FLUSH_OP, "StateFlush incremented membership version: {}",
+                membershipVersion);
-    }
-    else {
+    } else {
-    
+
-    }
-    else {
+    } else {
-  
+
+   * 
-   * Returns true if newProfile is newer than oldProfile. This is determined by
-   * comparing {@link Profile#getSerialNumber()} and {@link 
-   * Profile#getVersion()}. If the old versioning number being compared
-   * is above {@link #ROLLOVER_THRESHOLD_UPPER} and the new versioning number
-   * is below {@link #ROLLOVER_THRESHOLD_LOWER} then a rollover is assumed to
-   * have occurred, which means the new versioning number is newer.
+   * Returns true if newProfile is newer than oldProfile. This is determined by comparing
+   * {@link Profile#getSerialNumber()} and {@link Profile#getVersion()}. If the old versioning
+   * number being compared is above {@link #ROLLOVER_THRESHOLD_UPPER} and the new versioning number
+   * is below {@link #ROLLOVER_THRESHOLD_LOWER} then a rollover is assumed to have occurred, which
+   * means the new versioning number is newer.
-  protected boolean isNewerProfile(Profile newProfile, 
-                                   Profile oldProfile) {
-    Assert.assertHoldsLock(this,true);
+  protected boolean isNewerProfile(Profile newProfile, Profile oldProfile) {
+    Assert.assertHoldsLock(this, true);
-    //boolean serialRolled = oldSerial > 0 && newSerial < 0;
-    boolean serialRolled = oldSerial > ROLLOVER_THRESHOLD_UPPER && 
-                           newSerial < ROLLOVER_THRESHOLD_LOWER;
-    
+    // boolean serialRolled = oldSerial > 0 && newSerial < 0;
+    boolean serialRolled =
+        oldSerial > ROLLOVER_THRESHOLD_UPPER && newSerial < ROLLOVER_THRESHOLD_LOWER;
+
-    //boolean versionRolled = oldVersion > 0 && newVersion < 0;
-    boolean versionRolled = oldVersion > ROLLOVER_THRESHOLD_UPPER && 
-                            newVersion < ROLLOVER_THRESHOLD_LOWER;
-    
+    // boolean versionRolled = oldVersion > 0 && newVersion < 0;
+    boolean versionRolled =
+        oldVersion > ROLLOVER_THRESHOLD_UPPER && newVersion < ROLLOVER_THRESHOLD_LOWER;
+
-    }
-    else {
+    } else {
+   * 
-  static public boolean isNewerSerialNumber(int newSerialNumber, 
-                                            int oldSerialNumber) {
-    boolean serialRolled = oldSerialNumber > ROLLOVER_THRESHOLD_UPPER && 
-                           newSerialNumber < ROLLOVER_THRESHOLD_LOWER;
+  static public boolean isNewerSerialNumber(int newSerialNumber, int oldSerialNumber) {
+    boolean serialRolled =
+        oldSerialNumber > ROLLOVER_THRESHOLD_UPPER && newSerialNumber < ROLLOVER_THRESHOLD_LOWER;
-   * Create a new version of the membership profile set.  This is
-   * used in flushing state out of the VM for previous versions of
-   * the set.
+   * Create a new version of the membership profile set. This is used in flushing state out of the
+   * VM for previous versions of the set.
+   * 
-        logger.trace(LogMarker.STATE_FLUSH_OP, "StateFlush forced new membership version: {}", membershipVersion);
+        logger.trace(LogMarker.STATE_FLUSH_OP, "StateFlush forced new membership version: {}",
+            membershipVersion);
-      synchronized(this.opCountLock) {
+      synchronized (this.opCountLock) {
-          logger.trace(LogMarker.DISTRIBUTION_STATE_FLUSH_OP, "advisor for {} forced new membership version to {} previousOpCount={}", getAdvisee(), membershipVersion, previousVersionOpCount);
+          logger.trace(LogMarker.DISTRIBUTION_STATE_FLUSH_OP,
+              "advisor for {} forced new membership version to {} previousOpCount={}", getAdvisee(),
+              membershipVersion, previousVersionOpCount);
-   * this method must be invoked at the start of every operation
-   * that can modify the state of resource.  The return value must be
-   * recorded and sent to the advisor in an endOperation message when
-   * messages for the operation have been put in the DistributionManager's
-   * outgoing "queue".
+   * this method must be invoked at the start of every operation that can modify the state of
+   * resource. The return value must be recorded and sent to the advisor in an endOperation message
+   * when messages for the operation have been put in the DistributionManager's outgoing "queue".
+   * 
-      logger.trace(LogMarker.DISTRIBUTION_STATE_FLUSH_OP, "startOperation() op count is now {} in view version {}", currentVersionOpCount+1, membershipVersion);
+      logger.trace(LogMarker.DISTRIBUTION_STATE_FLUSH_OP,
+          "startOperation() op count is now {} in view version {}", currentVersionOpCount + 1,
+          membershipVersion);
-    synchronized(this.opCountLock) {
+    synchronized (this.opCountLock) {
-        logger.trace(LogMarker.STATE_FLUSH_OP, "StateFlush current opcount incremented: {}", currentVersionOpCount);
+        logger.trace(LogMarker.STATE_FLUSH_OP, "StateFlush current opcount incremented: {}",
+            currentVersionOpCount);
-   * This method must be invoked when messages for an operation have
-   * been put in the DistributionManager's outgoing queue.
-   * @param version
-   *    The membership version returned by startOperation
+   * This method must be invoked when messages for an operation have been put in the
+   * DistributionManager's outgoing queue.
+   * 
+   * @param version The membership version returned by startOperation
-    synchronized(this.opCountLock) {
+    synchronized (this.opCountLock) {
-          logger.trace(LogMarker.STATE_FLUSH_OP, "StateFlush current opcount deccremented: {}", currentVersionOpCount);
+          logger.trace(LogMarker.STATE_FLUSH_OP, "StateFlush current opcount deccremented: {}",
+              currentVersionOpCount);
-      }
-      else {
+      } else {
-          logger.trace(LogMarker.STATE_FLUSH_OP, "StateFlush previous opcount incremented: {}", previousVersionOpCount);
+          logger.trace(LogMarker.STATE_FLUSH_OP, "StateFlush previous opcount incremented: {}",
+              previousVersionOpCount);
-    long timeout = 1000L * this.getDistributionManager().getSystem()
-        .getConfig().getAckWaitThreshold();
+    long timeout =
+        1000L * this.getDistributionManager().getSystem().getConfig().getAckWaitThreshold();
-   * wait for the current operations being sent on views prior to the joining
-   * of the given member to be placed on communication channels before returning
+   * wait for the current operations being sent on views prior to the joining of the given member to
+   * be placed on communication channels before returning
+   * 
-  public void waitForCurrentOperations(long timeout)
-  {
-    //CacheProfile profile = (CacheProfile)getProfile(member);
-    //long targetVersion = profile.initialMembershipVersion - 1;
-    
+  public void waitForCurrentOperations(long timeout) {
+    // CacheProfile profile = (CacheProfile)getProfile(member);
+    // long targetVersion = profile.initialMembershipVersion - 1;
+
-      synchronized(this.opCountLock) {
+      synchronized (this.opCountLock) {
-      // The advisor's close() method will set the pVOC to zero.  This loop
+      // The advisor's close() method will set the pVOC to zero. This loop
-        logger.trace(LogMarker.STATE_FLUSH_OP, "Waiting for current operations to finish({})", opCount);
+        logger.trace(LogMarker.STATE_FLUSH_OP, "Waiting for current operations to finish({})",
+            opCount);
-            Long.toString((warnTime-startTime)/1000L)));
-      }
-      else if (warned && (now >= quitTime)) {
-//        OSProcess.printStacks(0);
-        throw new GemFireIOException("Current operations did not distribute within " + (now - startTime) + " milliseconds");
+            Long.toString((warnTime - startTime) / 1000L)));
+      } else if (warned && (now >= quitTime)) {
+        // OSProcess.printStacks(0);
+        throw new GemFireIOException(
+            "Current operations did not distribute within " + (now - startTime) + " milliseconds");
-        logger.trace(LogMarker.STATE_FLUSH_OP, "State Flush stopped waiting for operations to distribute because advisor has been closed");
+        logger.trace(LogMarker.STATE_FLUSH_OP,
+            "State Flush stopped waiting for operations to distribute because advisor has been closed");
-   * Bypass the distribution manager and ask the membership manager directly
-   * if a given member is still in the view.
+   * Bypass the distribution manager and ask the membership manager directly if a given member is
+   * still in the view.
-   * We need this because we're asking membership questions from within
-   * listeners, and we don't know whether the DM's membership listener
-   * fires before or after our own.
+   * We need this because we're asking membership questions from within listeners, and we don't know
+   * whether the DM's membership listener fires before or after our own.
-   * @return true if we are still in the JGroups view
-   *         (must return false if id == null)
+   * @return true if we are still in the JGroups view (must return false if id == null)
-      InternalDistributedMember memberId = (InternalDistributedMember)id;
+      InternalDistributedMember memberId = (InternalDistributedMember) id;
-   * Given member is no longer pertinent to this advisor; remove
-   * it.
+   * Given member is no longer pertinent to this advisor; remove it.
-   * This is often overridden in subclasses, but they need to
-   * defer to their superclass at some point in their re-implementation.
+   * This is often overridden in subclasses, but they need to defer to their superclass at some
+   * point in their re-implementation.
-  private boolean basicRemoveId(ProfileId memberId, 
-      boolean crashed,
-      boolean destroyed) {
+  private boolean basicRemoveId(ProfileId memberId, boolean crashed, boolean destroyed) {
-    
+
-        logger.trace(LogMarker.DA, "DistributionAdvisor.removeId: no profile to remove for {}", memberId);
+        logger.trace(LogMarker.DA, "DistributionAdvisor.removeId: no profile to remove for {}",
+            memberId);
+   * 
-    return removeId(profile.getId(), false, destroyed, false/*fromMembershipListener*/);
+    return removeId(profile.getId(), false, destroyed, false/* fromMembershipListener */);
-  
+
-   * Removes the profile for the given member. This method is meant to be
-   * overriden by subclasses.
+   * Removes the profile for the given member. This method is meant to be overriden by subclasses.
-   * @param memberId
-   *          the member whose profile should be removed
-   * @param crashed
-   *          true if the member crashed
+   * @param memberId the member whose profile should be removed
+   * @param crashed true if the member crashed
-   * @param fromMembershipListener
-   *          true if this call is a result of MembershipEvent invocation (fixes #42000)
+   * @param fromMembershipListener true if this call is a result of MembershipEvent invocation
+   *        (fixes #42000)
-  public boolean removeId(final ProfileId memberId,
-                          boolean crashed,
-                          boolean destroyed,
-                          boolean fromMembershipListener) {
+  public boolean removeId(final ProfileId memberId, boolean crashed, boolean destroyed,
+      boolean fromMembershipListener) {
-  private boolean doRemoveId(ProfileId memberId,
-                             boolean crashed,
-                             boolean destroyed,
-                             boolean fromMembershipListener) {
+  private boolean doRemoveId(ProfileId memberId, boolean crashed, boolean destroyed,
+      boolean fromMembershipListener) {
-      logger.trace(LogMarker.DA, "removeId: removing member {} from resource {}", memberId, getAdvisee().getFullPath());
+      logger.trace(LogMarker.DA, "removeId: removing member {} from resource {}", memberId,
+          getAdvisee().getFullPath());
-    synchronized(this) {
+    synchronized (this) {
-        //Assert.assertTrue(!crashed); // should not get here :-)
+        // Assert.assertTrue(!crashed); // should not get here :-)
-        // Is there an existing profile?  If so, add it to list of those removed.
+        // Is there an existing profile? If so, add it to list of those removed.
-          this.removedProfiles.put(profileToRemove.getDistributedMember(), 
+          this.removedProfiles.put(profileToRemove.getDistributedMember(),
-      }
-      else {
+      } else {
-  public boolean removeIdWithSerial(InternalDistributedMember memberId,
-                                    int serialNum,
-                                    boolean regionDestroyed) {
+  public boolean removeIdWithSerial(InternalDistributedMember memberId, int serialNum,
+      boolean regionDestroyed) {
-      logger.trace(LogMarker.DA, "removeIdWithSerial: removing member {} with serial {} from resource {}", memberId, serialNum, getAdvisee().getName());
+      logger.trace(LogMarker.DA,
+          "removeIdWithSerial: removing member {} with serial {} from resource {}", memberId,
+          serialNum, getAdvisee().getName());
-   * Update the list of removed profiles based on given serial number, and
-   * ensure that the given member is no longer in the list of bucket owners.
+   * Update the list of removed profiles based on given serial number, and ensure that the given
+   * member is no longer in the list of bucket owners.
-  private synchronized boolean updateRemovedProfiles(
-      InternalDistributedMember memberId,
-      int serialNum,
-      boolean regionDestroyed) {
+  private synchronized boolean updateRemovedProfiles(InternalDistributedMember memberId,
+      int serialNum, boolean regionDestroyed) {
-      logger.trace(LogMarker.DA, "updateRemovedProfiles: ensure member {} with serial {} is removed from region {}", memberId, serialNum, getAdvisee().getFullPath());
+      logger.trace(LogMarker.DA,
+          "updateRemovedProfiles: ensure member {} with serial {} is removed from region {}",
+          memberId, serialNum, getAdvisee().getFullPath());
-      
+
-            logger.trace(LogMarker.DA, "updateRemovedProfiles: member {} has profile {} which is newer than serial {}", memberId, profileToRemove, serialNum);
+            logger.trace(LogMarker.DA,
+                "updateRemovedProfiles: member {} has profile {} which is newer than serial {}",
+                memberId, profileToRemove, serialNum);
-          
+
-      
+
-        Integer oldSerial = (Integer)this.removedProfiles.get(memberId);
-        if (oldSerial != null 
-            && isNewerSerialNumber(oldSerial.intValue(), serialNum)) {
+        Integer oldSerial = (Integer) this.removedProfiles.get(memberId);
+        if (oldSerial != null && isNewerSerialNumber(oldSerial.intValue(), serialNum)) {
-            logger.trace(LogMarker.DA, "updateRemovedProfiles: member {} sent removal of serial {} but we hae already removed {}", memberId, serialNum, oldSerial);
+            logger.trace(LogMarker.DA,
+                "updateRemovedProfiles: member {} sent removal of serial {} but we hae already removed {}",
+                memberId, serialNum, oldSerial);
-      
+
-          logger.trace(LogMarker.DA, "updateRemovedProfiles: adding serial {} for member {} to removedProfiles", serialNum, memberId);
+          logger.trace(LogMarker.DA,
+              "updateRemovedProfiles: adding serial {} for member {} to removedProfiles", serialNum,
+              memberId);
-        // a new one.  Remember this removal, and ensure that its profile
+        // a new one. Remember this removal, and ensure that its profile
-        
+
-    
+
-    
+
+   * 
-  
-//  /**
-//   * get the profile for a specific member
-//   * @since GemFire 5.1
-//   * @return the Profile or null
-//   */
-//  synchronized public Profile getProfile(InternalDistributedMember memberId) {
-//    int index = indexOfMemberId(memberId);
-//    if (index >= 0) {
-//      return profiles[index];
-//    }
-//    return null;
-//  }
-  
+
+  // /**
+  // * get the profile for a specific member
+  // * @since GemFire 5.1
+  // * @return the Profile or null
+  // */
+  // synchronized public Profile getProfile(InternalDistributedMember memberId) {
+  // int index = indexOfMemberId(memberId);
+  // if (index >= 0) {
+  // return profiles[index];
+  // }
+  // return null;
+  // }
+
+
-   * Caller must be synchronized on this.
-   * Overridden in BucketAdvisor.
+   * Caller must be synchronized on this. Overridden in BucketAdvisor.
-    Assert.assertHoldsLock(this,false); // causes deadlock
-    Assert.assertHoldsLock(this.initializeLock,true);
+    Assert.assertHoldsLock(this, false); // causes deadlock
+    Assert.assertHoldsLock(this.initializeLock, true);
-    Profile newProfile = instantiateProfile(
-        getDistributionManager().getId(), incrementAndGetVersion());
+    Profile newProfile =
+        instantiateProfile(getDistributionManager().getId(), incrementAndGetVersion());
-  protected Profile instantiateProfile(
-      InternalDistributedMember memberId, int version) {
+  protected Profile instantiateProfile(InternalDistributedMember memberId, int version) {
-   * Provide recipient information for any other operation.
-   * Returns the set of members that have remote counterparts.
-   * @return Set of Serializable members;
-   * no reference to Set kept by advisor so caller is free to modify it
+   * Provide recipient information for any other operation. Returns the set of members that have
+   * remote counterparts.
+   * 
+   * @return Set of Serializable members; no reference to Set kept by advisor so caller is free to
+   *         modify it
-  
-  /** Provide recipients for profile exchange,
-   * called by UpdateAttributesProcessor and CreateRegionProcessor.
-   * Can not be initialized at this point because it is only called in
-   * the following scenarios:
-   * 1) We're doing a lazy initialization and synchronization on initializeLock
-   *    prevents other threads from causing initialization on this advisor.
-   * 2) We're creating a new region and doing profile exchange as part of region
-   *    initialization, in which case no other threads have access to the region
-   *    or this advisor.
+
+  /**
+   * Provide recipients for profile exchange, called by UpdateAttributesProcessor and
+   * CreateRegionProcessor. Can not be initialized at this point because it is only called in the
+   * following scenarios: 1) We're doing a lazy initialization and synchronization on initializeLock
+   * prevents other threads from causing initialization on this advisor. 2) We're creating a new
+   * region and doing profile exchange as part of region initialization, in which case no other
+   * threads have access to the region or this advisor.
+   * 
-    }
-    else {
+    } else {
-   * Returns true if all members including ADMIN are required for distribution
-   * of update attributes message by {@link #getDefaultDistributionMembers()}.
+   * Returns true if all members including ADMIN are required for distribution of update attributes
+   * message by {@link #getDefaultDistributionMembers()}.
-        ((MembershipListener)it.next()).memberJoined(member);
-      }
-      catch (Exception e) {
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributionAdvisor_UNEXPECTED_EXCEPTION), e);
+        ((MembershipListener) it.next()).memberJoined(member);
+      } catch (Exception e) {
+        logger.fatal(
+            LocalizedMessage.create(LocalizedStrings.DistributionAdvisor_UNEXPECTED_EXCEPTION), e);
-  
-  private void notifyListenersMemberRemoved(InternalDistributedMember member,
-                                            boolean crashed) {
+
+  private void notifyListenersMemberRemoved(InternalDistributedMember member, boolean crashed) {
-        ((MembershipListener)it.next()).memberDeparted(member, crashed);
-      }
-      catch (Exception e) {
-        logger.fatal(LocalizedMessage.create(LocalizedStrings.DistributionAdvisor_UNEXPECTED_EXCEPTION), e);
+        ((MembershipListener) it.next()).memberDeparted(member, crashed);
+      } catch (Exception e) {
+        logger.fatal(
+            LocalizedMessage.create(LocalizedStrings.DistributionAdvisor_UNEXPECTED_EXCEPTION), e);
-  
+
-      ((ProfileListener)it.next()).profileRemoved(profile, destroyed);
+      ((ProfileListener) it.next()).profileRemoved(profile, destroyed);
-  
+
-      ((ProfileListener)it.next()).profileCreated(profile);
+      ((ProfileListener) it.next()).profileCreated(profile);
-  
+
-      ((ProfileListener)it.next()).profileUpdated(profile);
+      ((ProfileListener) it.next()).profileUpdated(profile);
-  
+
-   * Template method for sub-classes to override. Method is invoked after
-   * a new profile is created/added to profiles.
+   * Template method for sub-classes to override. Method is invoked after a new profile is
+   * created/added to profiles.
+   * 
-  
+
-   * Template method for sub-classes to override. Method is invoked after
-   * a profile is updated in profiles.
+   * Template method for sub-classes to override. Method is invoked after a profile is updated in
+   * profiles.
+   * 
-  
+
-   * Template method for sub-classes to override. Method is invoked after
-   * a profile is removed from profiles.
+   * Template method for sub-classes to override. Method is invoked after a profile is removed from
+   * profiles.
+   * 
-  
+
-   * {@link DistributionAdvisor#accept(ProfileVisitor, Object)}. Unlike the
-   * {@link Filter} class this does not assume of two state visit of inclusion
-   * or exclusion rather allows manipulation of an arbitrary aggregator that has
-   * been passed to the {@link #visit} method. In addition this is public for
-   * use by other classes.
+   * {@link DistributionAdvisor#accept(ProfileVisitor, Object)}. Unlike the {@link Filter} class
+   * this does not assume of two state visit of inclusion or exclusion rather allows manipulation of
+   * an arbitrary aggregator that has been passed to the {@link #visit} method. In addition this is
+   * public for use by other classes.
-     * Visit a given {@link Profile} accumulating the results in the given
-     * aggregate. Returns false when the visit has to be terminated.
+     * Visit a given {@link Profile} accumulating the results in the given aggregate. Returns false
+     * when the visit has to be terminated.
-     * @param advisor
-     *          the DistributionAdvisor that invoked this visitor
-     * @param profile
-     *          the profile being visited
-     * @param profileIndex
-     *          the index of current profile
-     * @param numProfiles
-     *          the total number of profiles being visited
-     * @param aggregate
-     *          result aggregated so far, if any
+     * @param advisor the DistributionAdvisor that invoked this visitor
+     * @param profile the profile being visited
+     * @param profileIndex the index of current profile
+     * @param numProfiles the total number of profiles being visited
+     * @param aggregate result aggregated so far, if any
-     * @return false if the visit has to be terminated immediately and false
-     *         otherwise
+     * @return false if the visit has to be terminated immediately and false otherwise
-    boolean visit(DistributionAdvisor advisor, Profile profile,
-        int profileIndex, int numProfiles, T aggregate);
+    boolean visit(DistributionAdvisor advisor, Profile profile, int profileIndex, int numProfiles,
+        T aggregate);
-   * Invoke the given {@link ProfileVisitor} on all the {@link Profile}s exiting
-   * when the {@link ProfileVisitor#visit} method returns false. Unlike the
-   * {@link #adviseFilter(Filter)} method this does assume the return type to be
-   * a Set of qualifying members rather allows for population of an arbitrary
-   * aggregator passed as the argument to this method.
+   * Invoke the given {@link ProfileVisitor} on all the {@link Profile}s exiting when the
+   * {@link ProfileVisitor#visit} method returns false. Unlike the {@link #adviseFilter(Filter)}
+   * method this does assume the return type to be a Set of qualifying members rather allows for
+   * population of an arbitrary aggregator passed as the argument to this method.
-   * @param <T>
-   *          the type of object used for aggregation of results
-   * @param visitor
-   *          the {@link ProfileVisitor} to use for the visit
-   * @param aggregate
-   *          an aggregate object that will be used to for aggregation of
-   *          results by the {@link ProfileVisitor#visit} method; this allows
-   *          the {@link ProfileVisitor} to not maintain any state so that in
-   *          many situations a global static object encapsulating the required
-   *          behaviour will work
+   * @param <T> the type of object used for aggregation of results
+   * @param visitor the {@link ProfileVisitor} to use for the visit
+   * @param aggregate an aggregate object that will be used to for aggregation of results by the
+   *        {@link ProfileVisitor#visit} method; this allows the {@link ProfileVisitor} to not
+   *        maintain any state so that in many situations a global static object encapsulating the
+   *        required behaviour will work
-   * @return true if all the profiles were visited and false if the
-   *         {@link ProfileVisitor#visit} cut it short by returning false
+   * @return true if all the profiles were visited and false if the {@link ProfileVisitor#visit} cut
+   *         it short by returning false
-  /** Get an unmodifiable list of the <code>Profile</code>s
-   * that match the given <code>Filter</code>.
+  /**
+   * Get an unmodifiable list of the <code>Profile</code>s that match the given <code>Filter</code>.
+   * 
-  protected List/*<Profile>*/ fetchProfiles(Filter f) {
+  protected List/* <Profile> */ fetchProfiles(Filter f) {
-  
+
+   * 
-  
+
-   * @return true if new profile added, false if already had
-   * profile (but profile is still replaced with new one)
+   * @return true if new profile added, false if already had profile (but profile is still replaced
+   *         with new one)
-//    try {
+    // try {
-    
+
-    Profile[] newProfiles = (Profile[])
-        ArrayUtils.insert(snap, snap.length, p);
+    Profile[] newProfiles = (Profile[]) ArrayUtils.insert(snap, snap.length, p);
-//    System.out.println("newprofiles = " + newProfiles.length);
-//    for (int i = 0; i < newProfiles.length; i ++)
-//      System.out.println("profile " + i + ": " + newProfiles[i].getId().toString());
+    // System.out.println("newprofiles = " + newProfiles.length);
+    // for (int i = 0; i < newProfiles.length; i ++)
+    // System.out.println("profile " + i + ": " + newProfiles[i].getId().toString());
-      this.profiles = newProfiles; // volatile write
-      setNumActiveProfiles(newProfiles.length);
-    
-     return true;
-//    }
-//    finally {
-//      Assert.assertTrue(indexOfMemberId(p.getId()) >= 0);
-//      boolean containsOne = false;
-//      for (int i = 0; i < this.profiles.length; i++) {
-//        if (this.profiles[i].getId() == p.getId()) {
-//          Assert.assertTrue(!containsOne);
-//          containsOne = true;
-//        }
-//      }
-//      Assert.assertTrue(containsOne);
-//    }
+    this.profiles = newProfiles; // volatile write
+    setNumActiveProfiles(newProfiles.length);
+
+    return true;
+    // }
+    // finally {
+    // Assert.assertTrue(indexOfMemberId(p.getId()) >= 0);
+    // boolean containsOne = false;
+    // for (int i = 0; i < this.profiles.length; i++) {
+    // if (this.profiles[i].getId() == p.getId()) {
+    // Assert.assertTrue(!containsOne);
+    // containsOne = true;
+    // }
+    // }
+    // Assert.assertTrue(containsOne);
+    // }
-    
+
-//    try {
+    // try {
-    }
-    else
+    } else
-//    } finally {
-//      Assert.assertTrue(-1 == indexOfMemberId(id));
-//    }
+    // } finally {
+    // Assert.assertTrue(-1 == indexOfMemberId(id));
+    // }
-  
+
-    Assert.assertHoldsLock(this,true);
+    Assert.assertHoldsLock(this, true);
-        if (p.getDistributedMember().equals(id)) return i;
+        if (p.getDistributedMember().equals(id))
+          return i;
-        if (p.getId().equals(id)) return i;
+        if (p.getId().equals(id))
+          return i;
-  
+
-    Assert.assertHoldsLock(this,true);    
+    Assert.assertHoldsLock(this, true);
-    System.arraycopy(oldProfiles, index + 1, newProfiles, index,
-                     newProfiles.length - index);
+    System.arraycopy(oldProfiles, index + 1, newProfiles, index, newProfiles.length - index);
-  
- 
+
+
-   * Marker interface to designate on object that serves and the unique
-   * id that identifies a Profile.
+   * Marker interface to designate on object that serves and the unique id that identifies a
+   * Profile.
-     * The DistributionAdvisor's membership version where this member
-     * was added
+     * The DistributionAdvisor's membership version where this member was added
+     * 
-    public Profile() {
-    }
+    public Profile() {}
-        throw new IllegalArgumentException(LocalizedStrings.DistributionAdvisor_MEMBERID_CANNOT_BE_NULL.toLocalizedString());
+        throw new IllegalArgumentException(
+            LocalizedStrings.DistributionAdvisor_MEMBERID_CANNOT_BE_NULL.toLocalizedString());
+     * 
+
-    
+
-    
+
-      if (obj == this) return true;
-      if (obj == null) return false;
-      if (!this.getClass().equals(obj.getClass())) return false;
-      return getId().equals(((Profile)obj).getId());
+      if (obj == this)
+        return true;
+      if (obj == null)
+        return false;
+      if (!this.getClass().equals(obj.getClass()))
+        return false;
+      return getId().equals(((Profile) obj).getId());
-    /** Return the DistributedMember associated with this profile
+    /**
+     * Return the DistributedMember associated with this profile
+     * 
-    
+
-    
+
-    public void processIncoming(DistributionManager dm, String adviseePath,
-        boolean removeProfile, boolean exchangeProfiles,
-        final List<Profile> replyProfiles) {
+    public void processIncoming(DistributionManager dm, String adviseePath, boolean removeProfile,
+        boolean exchangeProfiles, final List<Profile> replyProfiles) {
-        logger.debug("While processing UpdateAttributes message ignored incoming profile: {}", this);
+        logger.debug("While processing UpdateAttributes message ignored incoming profile: {}",
+            this);
-     * Attempts to process this message with the specified
-     * {@link DistributionAdvisee}. Also if exchange profiles then add the
-     * profile from {@link DistributionAdvisee} to reply.
+     * Attempts to process this message with the specified {@link DistributionAdvisee}. Also if
+     * exchange profiles then add the profile from {@link DistributionAdvisee} to reply.
-     * @param advisee
-     *          the CacheDistributionAdvisee to apply this profile to
-     * @param removeProfile
-     *          true to remove profile else add profile
-     * @param exchangeProfiles
-     *          true to add the profile to reply
+     * @param advisee the CacheDistributionAdvisee to apply this profile to
+     * @param removeProfile true to remove profile else add profile
+     * @param exchangeProfiles true to add the profile to reply
-        boolean removeProfile, boolean exchangeProfiles,
-        final List<Profile> replyProfiles) {
+        boolean removeProfile, boolean exchangeProfiles, final List<Profile> replyProfiles) {
-        }
-        else {
+        } else {
-    
+
-     * This will be get called when profile will be removed from advisor
-     * Do local cleanup in this thread, otherwsie spawn another thread to
-     * do cleanup 
+     * This will be get called when profile will be removed from advisor Do local cleanup in this
+     * thread, otherwsie spawn another thread to do cleanup
-    public void cleanUp(){
-      
+    public void cleanUp() {
+
-       return null;
+      return null;

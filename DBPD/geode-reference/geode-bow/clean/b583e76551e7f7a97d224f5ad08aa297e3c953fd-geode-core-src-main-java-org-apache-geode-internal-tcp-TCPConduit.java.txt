GEODE-7256: Cleanup Connection classes and tests

* Minor cleanup of classes and tests

+import static org.apache.geode.distributed.internal.DistributionConfig.DEFAULT_MEMBERSHIP_PORT_RANGE;
+import static org.apache.geode.distributed.internal.DistributionConfig.DEFAULT_SOCKET_BUFFER_SIZE;
+import static org.apache.geode.distributed.internal.DistributionConfig.DEFAULT_SOCKET_LEASE_TIME;
+
+import java.net.UnknownHostException;
- * </p>
- * <pre>
- * DistributionMessage - message is delivered to the server's
- * ServerDelegate
- * <p>
- * </pre>
+ * DistributionMessage - message is delivered to the server's ServerDelegate
+ *
+ *
- * </p>
-
+   *
-  boolean useSSL;
+  private final boolean useSSL;
-
-  private Membership<InternalDistributedMember> membership;
+  private final Membership<InternalDistributedMember> membership;
-  public Membership<InternalDistributedMember> getMembership() {
-    return membership;
-  }
-
-  public static int getBackLog() {
-    return BACKLOG;
-  }
-
-  public static void init() {
-    // only use direct buffers if we are using nio
-    LISTENER_CLOSE_TIMEOUT = Integer.getInteger("p2p.listenerCloseTimeout", 60000);
-    // note: bug 37730 concerned this defaulting to 50
-    BACKLOG = Integer.getInteger("p2p.backlog", 1280);
-    if (Boolean.getBoolean("p2p.oldIO")) {
-      logger.warn("detected use of p2p.oldIO setting - this is no longer supported");
-    }
-  }
-
-  ///////////////// permanent conduit state
-
-  int tcpBufferSize = DistributionConfig.DEFAULT_SOCKET_BUFFER_SIZE;
-  int idleConnectionTimeout = DistributionConfig.DEFAULT_SOCKET_LEASE_TIME;
+  int tcpBufferSize = DEFAULT_SOCKET_BUFFER_SIZE;
+  int idleConnectionTimeout = DEFAULT_SOCKET_LEASE_TIME;
-  private int[] tcpPortRange = new int[] {DistributionConfig.DEFAULT_MEMBERSHIP_PORT_RANGE[0],
-      DistributionConfig.DEFAULT_MEMBERSHIP_PORT_RANGE[1]};
+  private final int[] tcpPortRange =
+      new int[] {DEFAULT_MEMBERSHIP_PORT_RANGE[0], DEFAULT_MEMBERSHIP_PORT_RANGE[1]};
-  ////////////////// runtime state that is re-initialized on a restart
-
-  protected volatile boolean stopped;
+  private volatile boolean stopped;
+   * the reason for a shutdown, if abnormal
+   */
+  private volatile Exception shutdownCause;
+
+  private final Stopper stopper = new Stopper();
+
+  /**
-   * </p>
+   *
-   * </p>
-    this.directChannel = receiver;
-    this.stats = null;
-    this.config = null;
-    this.membership = mgr;
+    directChannel = receiver;
+    stats = null;
+    config = null;
+    membership = mgr;
-      this.stats = directChannel.getDMStats();
-      this.config = directChannel.getDMConfig();
+      stats = directChannel.getDMStats();
+      config = directChannel.getDMConfig();
-    if (this.getStats() == null) {
-      this.stats = new LonerDistributionManager.DummyDMStats();
+    if (getStats() == null) {
+      stats = new LonerDistributionManager.DummyDMStats();
-    try {
-      this.conTable = ConnectionTable.create(this);
-    } catch (IOException io) {
-      throw new ConnectionException(
-          "Unable to initialize connection table",
-          io);
-    }
+    conTable = ConnectionTable.create(this);
-    this.socketCreator =
+    socketCreator =
-    this.useSSL = socketCreator.useSSL();
+    useSSL = socketCreator.useSSL();
-    InetAddress addr = address;
-    if (addr == null) {
+    if (address == null) {
-        addr = SocketCreator.getLocalHost();
-      } catch (java.net.UnknownHostException e) {
+        SocketCreator.getLocalHost();
+      } catch (UnknownHostException e) {
+  public static void init() {
+    // only use direct buffers if we are using nio
+    LISTENER_CLOSE_TIMEOUT = Integer.getInteger("p2p.listenerCloseTimeout", 60000);
+    BACKLOG = Integer.getInteger("p2p.backlog", 1280);
+    if (Boolean.getBoolean("p2p.oldIO")) {
+      logger.warn("detected use of p2p.oldIO setting - this is no longer supported");
+    }
+  }
+
+  public Membership<InternalDistributedMember> getMembership() {
+    return membership;
+  }
+
+  public static int getBackLog() {
+    return BACKLOG;
+  }
-      String s;
-      s = p.getProperty("p2p.tcpBufferSize", "" + tcpBufferSize);
+      String s = p.getProperty("p2p.tcpBufferSize", String.valueOf(tcpBufferSize));
-        logger.warn("exception parsing p2p.tcpBufferSize",
-            e);
+        logger.warn("exception parsing p2p.tcpBufferSize", e);
-      s = p.getProperty("p2p.idleConnectionTimeout", "" + idleConnectionTimeout);
+      s = p.getProperty("p2p.idleConnectionTimeout", String.valueOf(idleConnectionTimeout));
-        logger.warn("Exception parsing membership-port-range end port.",
-            e);
+        logger.warn("Exception parsing membership-port-range end port.", e);
-
-   * the reason for a shutdown, if abnormal
-   */
-  private volatile Exception shutdownCause;
-
-  /**
-    int localPort;
-    int p = this.port;
+    int p = port;
+    int localPort;
-    this.port = localPort;
+    port = localPort;
-    int serverPort = this.port;
+    int serverPort = port;
-    InetAddress bindAddress = this.address;
+    InetAddress bindAddress = address;
-
-            connectionRequestBacklog, isBindAddress,
-            true, 0, tcpPortRange);
+            connectionRequestBacklog, isBindAddress, true, 0, tcpPortRange);
+
-              "Listener receiverBufferSize", newSize,
-              tcpBufferSize);
+              "Listener receiverBufferSize", newSize, tcpBufferSize);
-  /* stops the conduit, closing all tcp/ip connections */
+  /**
+   * stops the conduit, closing all tcp/ip connections
+   */
-        // set timeout endpoint here since interrupt() has been known
-        // to hang
+        // set timeout endpoint here since interrupt() has been known to hang
-        Thread t = this.thread;
+        Thread t = thread;
-          // NOTE: do not try to interrupt the listener thread at this point.
-          // Doing so interferes with the channel's socket logic.
+          // NOTE: do not try to interrupt the listener thread at this point;
+          // doing so interferes with the channel's socket logic.
-          ServerSocket s = this.socket;
+          ServerSocket s = socket;
-          t = this.thread;
+          t = thread;
-      this.conTable.close();
+      conTable.close();
-   * Returns whether or not this conduit is stopped
-   *
-   * @since GemFire 3.0
-   */
-  public boolean isStopped() {
-    return this.stopped;
-  }
-
-  /**
-    this.stats = null;
+    stats = null;
-      this.stats = directChannel.getDMStats();
+      stats = directChannel.getDMStats();
-    if (this.getStats() == null) {
-      this.stats = new LonerDistributionManager.DummyDMStats();
+    if (getStats() == null) {
+      stats = new LonerDistributionManager.DummyDMStats();
-    try {
-      this.conTable = ConnectionTable.create(this);
-    } catch (IOException io) {
-      throw new ConnectionException(
-          "Unable to initialize connection table",
-          io);
-    }
+    conTable = ConnectionTable.create(this);
-      if (stopper.isCancelInProgress()) {
-        break; // part of bug 37271
-      }
+            // ignored
-        this.getStats().incFailedAccept();
+        getStats().incFailedAccept();
-            // safe to ignore; see bug 31156
+            // safe to ignore
-                logger.fatal("Unable to close and recreate server socket",
-                    ioe);
+                logger.fatal("Unable to close and recreate server socket", ioe);
-        // NOTE: do not check for distributed system closing here. Messaging
-        // may need to occur during the closing of the DS or cache
+        // NOTE: do not check for distributed system closing here.
+        // Messaging may need to occur during the closing of the DS or cache
-    } // for
+    }
-    ConnectionTable result = this.conTable;
+    ConnectionTable result = conTable;
-      throw new DistributedSystemDisconnectedException(
-          "tcp layer has been shutdown");
+      throw new DistributedSystemDisconnectedException("tcp layer has been shutdown");
-  private void acceptConnection(Socket othersock) {
+  private void acceptConnection(Socket otherSocket) {
-      getConTable().acceptConnection(othersock, new PeerConnectionFactory());
+      getConTable().acceptConnection(otherSocket, new PeerConnectionFactory());
-        this.getStats().incFailedAccept();
+        getStats().incFailedAccept();
+      // ignored
-        this.getStats().incFailedAccept();
+        getStats().incFailedAccept();
-            othersock.getInetAddress(), e);
+            otherSocket.getInetAddress(), e);
-  protected void messageReceived(Connection receiver, DistributionMessage message, int bytesRead) {
+  void messageReceived(Connection receiver, DistributionMessage message, int bytesRead) {
-      DistributionMessage msg = message;
-      msg.setBytesRead(bytesRead);
-      msg.setSender(receiver.getRemoteAddress());
-      msg.setSharedReceiver(receiver.isSharedResource());
-      directChannel.receive(msg, bytesRead);
+      message.setBytesRead(bytesRead);
+      message.setSender(receiver.getRemoteAddress());
+      message.setSharedReceiver(receiver.isSharedResource());
+      directChannel.receive(message, bytesRead);
-    return this.localAddr;
+    return localAddr;
-
-
-      long ackSATimeout) throws java.io.IOException, DistributedSystemDisconnectedException {
+      long ackSATimeout) throws IOException, DistributedSystemDisconnectedException {
-      throw new DistributedSystemDisconnectedException(
-          "The conduit is stopped");
+      throw new DistributedSystemDisconnectedException("The conduit is stopped");
-    Connection conn = null;
-    boolean breakLoop = false;
-    for (;;) {
+    Connection conn = null;
+    for (boolean breakLoop = false;;) {
-        // If this is the second time through this loop, we had
-        // problems. Tear down the connection so that it gets
-        // rebuilt.
+        // If this is the second time through this loop, we had problems.
+        // Tear down the connection so that it gets rebuilt.
-            throw new IOException(
-                "TCP/IP connection lost and member is not in view");
+            throw new IOException("TCP/IP connection lost and member is not in view");
-          // bug35953: Member is still in view; we MUST NOT give up!
+          // Member is still in view; we MUST NOT give up!
-            throw new IOException(
-                "TCP/IP connection lost and member is not in view");
+            throw new IOException("TCP/IP connection lost and member is not in view");
-          this.getStats().incReconnectAttempts();
+          getStats().incReconnectAttempts();
+              // ignored
-          // bug36202: this could generate a ConnectionException, so it
-          // must be caught and retried
+          // this could generate a ConnectionException, so it must be caught and retried
-          // [sumedh] No need to retry since Connection.createSender has already
+          // No need to retry since Connection.createSender has already
-          // bug #43962 don't keep trying to connect to an alert listener
+          // don't keep trying to connect to an alert listener
-              logger.info("Ending reconnect attempt because {} has disappeared.",
-                  memberInTrouble);
+              logger.info("Ending reconnect attempt because {} has disappeared.", memberInTrouble);
-            throw new IOException(String.format("Peer has disappeared from view: %s",
-                memberAddress));
+            throw new IOException(
+                String.format("Peer has disappeared from view: %s", memberAddress));
-            logger.warn("Error sending message to {} (will reattempt): {}",
-                memberAddress, problem);
+            logger.warn("Error sending message to {} (will reattempt): {}", memberAddress, problem);
-              logger.warn("Throwing IOException after finding breakLoop=true",
-                  problem);
+              logger.warn("Throwing IOException after finding breakLoop=true", problem);
-            } else {
-              IOException ioe = new IOException(String.format("Problem connecting to %s",
-                  memberAddress));
-              ioe.initCause(problem);
-              throw ioe;
+            throw new IOException(
+                String.format("Problem connecting to %s", memberAddress), problem);
-        } // problem != null
+        }
-    } // for(;;)
+    }
-    return "" + id;
+    return String.valueOf(id);
-    ConnectionTable ct = this.conTable;
+    ConnectionTable ct = conTable;
-    ConnectionTable ct = this.conTable;
-    return (ct != null) && ct.hasReceiversFor(endPoint);
+    ConnectionTable ct = conTable;
+    return ct != null && ct.hasReceiversFor(endPoint);
-    return this.conTable.getBufferPool();
+    return conTable.getBufferPool();
-  protected class Stopper extends CancelCriterion {
+  public CancelCriterion getCancelCriterion() {
+    return stopper;
+  }
+
+  /**
+   * if the conduit is disconnected due to an abnormal condition, this will describe the reason
+   *
+   * @return exception that caused disconnect
+   */
+  Exception getShutdownCause() {
+    return shutdownCause;
+  }
+
+  /**
+   * returns the SocketCreator that should be used to produce sockets for TCPConduit connections.
+   */
+  protected SocketCreator getSocketCreator() {
+    return socketCreator;
+  }
+
+  /**
+   * Called by Connection before handshake reply is sent. Returns true if member is part of
+   * view, false if membership is not confirmed before timeout.
+   */
+  boolean waitForMembershipCheck(InternalDistributedMember remoteId) {
+    return membership.waitForNewMember(remoteId);
+  }
+
+  private class Stopper extends CancelCriterion {
-      if (TCPConduit.this.stopped) {
+      if (stopped) {
-      result = new DistributedSystemDisconnectedException("Conduit has been stopped");
-      result.initCause(e);
+      result = new DistributedSystemDisconnectedException("Conduit has been stopped", e);
-
-  private final Stopper stopper = new Stopper();
-
-  public CancelCriterion getCancelCriterion() {
-    return stopper;
-  }
-
-
-  /**
-   * if the conduit is disconnected due to an abnormal condition, this will describe the reason
-   *
-   * @return exception that caused disconnect
-   */
-  public Exception getShutdownCause() {
-    return this.shutdownCause;
-  }
-
-  /**
-   * returns the SocketCreator that should be used to produce sockets for TCPConduit connections.
-   */
-  protected SocketCreator getSocketCreator() {
-    return socketCreator;
-  }
-
-  /**
-   * ARB: Called by Connection before handshake reply is sent. Returns true if member is part of
-   * view, false if membership is not confirmed before timeout.
-   */
-  public boolean waitForMembershipCheck(InternalDistributedMember remoteId) {
-    return membership.waitForNewMember(remoteId);
-  }

GEODE-7828: Convert backing store for Redis Hashes and Sets to single regions (#4781)

* Revert "Revert "GEODE-7828: Convert backing store for Redis Hashes and Sets to single regions (#4745)" (#4780)"

This reverts commit f0982cdedf1b122f734919d0647434cca33ec254.

* Fix sporadic test failures for concurrent HSetNX
+import java.util.HashSet;
+import java.util.Set;
+import org.apache.geode.cache.TimeoutException;
+import org.apache.geode.redis.internal.AutoCloseableLock;
-  private final int MOVED = 1;
+  private static final int MOVED = 1;
-  private final int NOT_MOVED = 0;
+  private static final int NOT_MOVED = 0;
-    if (commandElems.size() < 4) {
+    if (commandElems.size() != 4) {
-    ByteArrayWrapper mem = new ByteArrayWrapper(commandElems.get(3));
+    ByteArrayWrapper member = new ByteArrayWrapper(commandElems.get(3));
-    @SuppressWarnings("unchecked")
-    Region<ByteArrayWrapper, Boolean> sourceRegion =
-        (Region<ByteArrayWrapper, Boolean>) context.getRegionProvider().getRegion(source);
-    if (sourceRegion == null) {
-      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), NOT_MOVED));
+    Region<ByteArrayWrapper, Set<ByteArrayWrapper>> region = getRegion(context);
+
+    try (AutoCloseableLock regionLock = withRegionLock(context, source)) {
+      Set<ByteArrayWrapper> sourceSet = region.get(source);
+
+      if (sourceSet == null) {
+        command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), NOT_MOVED));
+        return;
+      }
+
+      sourceSet = new HashSet<>(sourceSet); // copy to support transactions;
+      boolean removed = sourceSet.remove(member);
+
+      if (!removed) {
+        command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), NOT_MOVED));
+      } else {
+        try (AutoCloseableLock destinationLock = withRegionLock(context, destination)) {
+          Set<ByteArrayWrapper> destinationSet = region.get(destination);
+
+          if (destinationSet == null) {
+            destinationSet = new HashSet<>();
+          } else {
+            destinationSet = new HashSet<>(destinationSet); // copy to support transactions
+          }
+
+          destinationSet.add(member);
+
+          region.put(destination, destinationSet);
+          context.getKeyRegistrar().register(destination, RedisDataType.REDIS_SET);
+
+          region.put(source, sourceSet);
+          context.getKeyRegistrar().register(source, RedisDataType.REDIS_SET);
+
+          command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), MOVED));
+        } catch (InterruptedException e) {
+          Thread.currentThread().interrupt();
+          System.out.println("Interrupt exception!!");
+          command.setResponse(
+              Coder.getErrorResponse(context.getByteBufAllocator(), "Thread interrupted."));
+          return;
+        } catch (TimeoutException e) {
+          System.out.println("Timeout exception!!");
+          command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
+              "Timeout acquiring lock. Please try again."));
+          return;
+        } catch (Exception e) {
+          System.out.println("Unexpected exception: " + e);
+          command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
+              "Unexpected exception."));
+        }
+      }
+    } catch (InterruptedException e) {
+      Thread.currentThread().interrupt();
+      System.out.println("Interrupt exception!!");
+      command.setResponse(
+          Coder.getErrorResponse(context.getByteBufAllocator(), "Thread interrupted."));
-    }
-
-    Object oldVal = sourceRegion.get(mem);
-    sourceRegion.remove(mem);
-
-    if (oldVal == null) {
-      command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), NOT_MOVED));
+    } catch (TimeoutException e) {
+      System.out.println("Timeout exception!!");
+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
+          "Timeout acquiring lock. Please try again."));
+    } catch (Exception e) {
+      System.out.println("Unexpected exception: " + e);
+      command.setResponse(Coder.getErrorResponse(context.getByteBufAllocator(),
+          "Unexpected exception."));
-
-    @SuppressWarnings("unchecked")
-    Region<ByteArrayWrapper, Boolean> destinationRegion =
-        (Region<ByteArrayWrapper, Boolean>) getOrCreateRegion(context, destination,
-            RedisDataType.REDIS_SET);
-    destinationRegion.put(mem, true);
-
-    command.setResponse(Coder.getIntegerResponse(context.getByteBufAllocator(), MOVED));
-

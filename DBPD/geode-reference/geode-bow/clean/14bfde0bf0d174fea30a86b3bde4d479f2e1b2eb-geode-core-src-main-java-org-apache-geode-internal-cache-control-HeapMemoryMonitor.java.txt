Merge branch 'release/1.8.0'

-import java.util.concurrent.Executors;
-import java.util.concurrent.ThreadFactory;
+import org.apache.geode.Statistics;
-import org.apache.geode.internal.i18n.LocalizedStrings;
-import org.apache.geode.internal.logging.LoggingThreadGroup;
-import org.apache.geode.internal.logging.log4j.LocalizedMessage;
+import org.apache.geode.internal.logging.LoggingExecutors;
-import org.apache.geode.internal.statistics.StatisticsImpl;
+import org.apache.geode.internal.statistics.StatisticsManager;
-      logger.error(LocalizedMessage.create(LocalizedStrings.HeapMemoryMonitor_NO_POOL_FOUND_POOLS_0,
-          getAllMemoryPoolNames()));
+      logger.error("No tenured pools found.  Known pools are: {}",
+          getAllMemoryPoolNames());
-    throw new IllegalStateException(LocalizedStrings.HeapMemoryMonitor_NO_POOL_FOUND_POOLS_0
-        .toLocalizedString(getAllMemoryPoolNames()));
+    throw new IllegalStateException(String.format("No tenured pools found.  Known pools are: %s",
+        getAllMemoryPoolNames()));
-        this.cache.getLoggerI18n().fine("Removed Memory MXBean notification listener" + this);
+        if (logger.isDebugEnabled()) {
+          logger.debug("Removed Memory MXBean notification listener" + this);
+        }
-        logger.debug("This instance '{}' was not registered as a Memory MXBean listener", this);
+        if (logger.isDebugEnabled()) {
+          logger.debug("This instance '{}' was not registered as a Memory MXBean listener", this);
+        }
+  public static Statistics getTenuredPoolStatistics(StatisticsManager statisticsManager) {
+    String tenuredPoolName = getTenuredMemoryPoolMXBean().getName();
+    String tenuredPoolType = "PoolStats";
+    for (Statistics si : statisticsManager.getStatsList()) {
+      if (si.getTextId().contains(tenuredPoolName)
+          && si.getType().getName().contains(tenuredPoolType)) {
+        return si;
+      }
+    }
+    return null;
+  }
+
-      String tenuredPoolName = getTenuredMemoryPoolMXBean().getName();
-      List list = this.cache.getInternalDistributedSystem().getStatsList();
-      for (Object o : list) {
-        if (o instanceof StatisticsImpl) {
-          StatisticsImpl si = (StatisticsImpl) o;
-          if (si.getTextId().contains(tenuredPoolName)
-              && si.getType().getName().contains("PoolStats")) {
-            sampler.addLocalStatListener(this.statListener, si, "currentUsedMemory");
-            if (this.cache.getLoggerI18n().fineEnabled()) {
-              this.cache.getLoggerI18n().fine("Registered stat listener for " + si.getTextId());
-            }
-
-            return true;
-          }
+      Statistics si = getTenuredPoolStatistics(this.cache.getInternalDistributedSystem());
+      if (si != null) {
+        sampler.addLocalStatListener(this.statListener, si, "currentUsedMemory");
+        if (logger.isDebugEnabled()) {
+          logger.debug("Registered stat listener for " + si.getTextId());
+
+        return true;
-    final ThreadGroup threadGroup = LoggingThreadGroup.createThreadGroup("HeapPoller", logger);
-    final ThreadFactory threadFactory = new ThreadFactory() {
-      @Override
-      public Thread newThread(Runnable r) {
-        Thread thread = new Thread(threadGroup, r, "GemfireHeapPoller");
-        thread.setDaemon(true);
-        return thread;
-      }
-    };
-
-    this.pollerExecutor = Executors.newScheduledThreadPool(1, threadFactory);
+    this.pollerExecutor = LoggingExecutors.newScheduledThreadPool("GemfireHeapPoller", 1);
-    if (this.cache.getLoggerI18n().fineEnabled()) {
-      this.cache.getLoggerI18n().fine(
+    if (logger.isDebugEnabled()) {
+      logger.debug(
-            LocalizedStrings.MemoryThresholds_CRITICAL_PERCENTAGE_GT_ZERO_AND_LTE_100
-                .toLocalizedString());
+            "Critical percentage must be greater than 0.0 and less than or equal to 100.0.");
-        throw new IllegalStateException(LocalizedStrings.HeapMemoryMonitor_NO_POOL_FOUND_POOLS_0
-            .toLocalizedString(getAllMemoryPoolNames()));
+        throw new IllegalStateException(
+            String.format("No tenured pools found.  Known pools are: %s",
+                getAllMemoryPoolNames()));
-            LocalizedStrings.MemoryThresholds_CRITICAL_PERCENTAGE_GTE_EVICTION_PERCENTAGE
-                .toLocalizedString());
+            "Critical percentage must be greater than the eviction percentage.");
-            LocalizedStrings.MemoryThresholds_EVICTION_PERCENTAGE_GT_ZERO_AND_LTE_100
-                .toLocalizedString());
+            "Eviction percentage must be greater than 0.0 and less than or equal to 100.0.");
-        throw new IllegalStateException(LocalizedStrings.HeapMemoryMonitor_NO_POOL_FOUND_POOLS_0
-            .toLocalizedString(getAllMemoryPoolNames()));
+        throw new IllegalStateException(
+            String.format("No tenured pools found.  Known pools are: %s",
+                getAllMemoryPoolNames()));
-            LocalizedStrings.MemoryMonitor_EVICTION_PERCENTAGE_LTE_CRITICAL_PERCENTAGE
-                .toLocalizedString());
+            "Eviction percentage must be less than the critical percentage.");
-    this.cache.getLoggerI18n().info(
-        LocalizedStrings.HeapMemoryMonitor_OVERRIDDING_MEMORYPOOLMXBEAN_HEAP_0_NAME_1,
-        new Object[] {usageThreshold, memoryPoolMXBean.getName()});
+    this.cache.getLogger().info(
+        String.format("Overridding MemoryPoolMXBean heap threshold bytes %s on pool %s",
+            new Object[] {usageThreshold, memoryPoolMXBean.getName()}));
-        if (this.cache.getLoggerI18n().fineEnabled()) {
-          this.cache.getLoggerI18n()
-              .fine("State " + newState + " ignored. toleranceCounter:"
-                  + this.evictionToleranceCounter + " MEMORY_EVENT_TOLERANCE:"
-                  + memoryStateChangeTolerance);
+        if (logger.isDebugEnabled()) {
+          logger.debug("State " + newState + " ignored. toleranceCounter:"
+              + this.evictionToleranceCounter + " MEMORY_EVENT_TOLERANCE:"
+              + memoryStateChangeTolerance);
-        if (this.cache.getLoggerI18n().fineEnabled()) {
-          this.cache.getLoggerI18n()
-              .fine("State " + newState + " ignored. toleranceCounter:"
-                  + this.criticalToleranceCounter + " MEMORY_EVENT_TOLERANCE:"
-                  + memoryStateChangeTolerance);
+        if (logger.isDebugEnabled()) {
+          logger.debug("State " + newState + " ignored. toleranceCounter:"
+              + this.criticalToleranceCounter + " MEMORY_EVENT_TOLERANCE:"
+              + memoryStateChangeTolerance);
-      if (this.cache.getLoggerI18n().fineEnabled()) {
-        this.cache.getLoggerI18n().fine("TOLERANCE counters reset");
+      if (logger.isDebugEnabled()) {
+        logger.debug("TOLERANCE counters reset");
-    if (this.cache.getLoggerI18n().fineEnabled()) {
-      this.cache.getLoggerI18n().fine("Handling new local event " + event);
+    if (logger.isDebugEnabled()) {
+      logger.debug("Handling new local event " + event);
-      this.cache.getLoggerI18n().error(
-          LocalizedStrings.MemoryMonitor_MEMBER_ABOVE_CRITICAL_THRESHOLD,
-          new Object[] {event.getMember(), "heap"});
+      this.cache.getLogger().error(
+          String.format("Member: %s above %s critical threshold",
+              new Object[] {event.getMember(), "heap"}));
-        this.cache.getQueryMonitor().cancelAllQueriesDueToMemory();
-      this.cache.getLoggerI18n().error(
-          LocalizedStrings.MemoryMonitor_MEMBER_BELOW_CRITICAL_THRESHOLD,
-          new Object[] {event.getMember(), "heap"});
+      this.cache.getLogger().error(
+          String.format("Member: %s below %s critical threshold",
+              new Object[] {event.getMember(), "heap"}));
-      this.cache.getLoggerI18n().info(LocalizedStrings.MemoryMonitor_MEMBER_ABOVE_HIGH_THRESHOLD,
-          new Object[] {event.getMember(), "heap"});
+      this.cache.getLogger().info(String.format("Member: %s above %s eviction threshold",
+          new Object[] {event.getMember(), "heap"}));
-      this.cache.getLoggerI18n().info(LocalizedStrings.MemoryMonitor_MEMBER_BELOW_HIGH_THRESHOLD,
-          new Object[] {event.getMember(), "heap"});
+      this.cache.getLogger().info(String.format("Member: %s below %s eviction threshold",
+          new Object[] {event.getMember(), "heap"}));
-    if (this.cache.getLoggerI18n().fineEnabled()) {
-      this.cache.getLoggerI18n().fine("Informing remote members of event " + event);
+    if (logger.isDebugEnabled()) {
+      logger.debug("Informing remote members of event " + event);
-        this.cache.getLoggerI18n()
-            .error(LocalizedStrings.MemoryMonitor_EXCEPTION_OCCURRED_WHEN_NOTIFYING_LISTENERS, t);
+        this.cache.getLogger()
+            .error("Exception occurred when notifying listeners ", t);
-            LocalizedStrings.ResourceManager_LOW_MEMORY_FOR_0_FUNCEXEC_MEMBERS_1
-                .toLocalizedString(function.getId(), criticalMembersFrom),
+            String.format(
+                "Function: %s cannot be executed because the members %s are running low on memory",
+                function.getId(), criticalMembersFrom),
-        if (HeapMemoryMonitor.this.cache.getLoggerI18n().fineEnabled()) {
-          HeapMemoryMonitor.this.cache.getLoggerI18n().fine(
+        if (HeapMemoryMonitor.logger.isDebugEnabled()) {
+          HeapMemoryMonitor.logger.debug(
-          logger.warn(LocalizedMessage
-              .create(LocalizedStrings.ResourceManager_REJECTED_EXECUTION_CAUSE_NOHEAP_EVENTS));
+          logger.warn("No memory events will be delivered because of RejectedExecutionException");
-        HeapMemoryMonitor.this.cache.getLoggerI18n().fine("Poller Thread caught exception:", e);
+        HeapMemoryMonitor.logger.debug("Poller Thread caught exception:", e);
-      this.cache.getLoggerI18n().fine(builder.toString());
+      logger.debug(builder.toString());

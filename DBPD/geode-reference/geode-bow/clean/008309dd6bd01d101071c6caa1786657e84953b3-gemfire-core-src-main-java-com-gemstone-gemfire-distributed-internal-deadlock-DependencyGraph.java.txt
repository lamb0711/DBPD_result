Merge branch 'release/1.0.0-incubating.M1'

-/*=========================================================================
- * Copyright (c) 2002-2014 Pivotal Software, Inc. All Rights Reserved.
- * This product is protected by U.S. and international copyright
- * and intellectual property laws. Pivotal products are covered by
- * more patents listed at http://www.pivotal.io/patents.
- *=========================================================================
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+import java.util.Collections;
+import java.util.List;
+import com.gemstone.gemfire.distributed.internal.deadlock.MessageDependencyMonitor.MessageKey;
+import com.gemstone.gemfire.internal.util.PluckStacks;
+
+ * @author bschuchardt
+  /** add a collection of edges to this graph */
+  public void addEdges(Collection<Dependency> edges) {
+    for (Dependency dep: edges) {
+      addEdge(dep);
+    }
+  }
+  
-    edges.add(dependency);
-    Set<Dependency> outboundEdges = vertices.get(dependency.getDepender());
-    if(outboundEdges == null) {
-      outboundEdges = new HashSet();
-      vertices.put(dependency.getDepender(), outboundEdges);
+    if (!edges.contains(dependency)) {
+      edges.add(dependency);
+      Set<Dependency> outboundEdges = vertices.get(dependency.getDepender());
+      if(outboundEdges == null) {
+        outboundEdges = new HashSet();
+        vertices.put(dependency.getDepender(), outboundEdges);
+      }
+      outboundEdges.add(dependency);
+      
+      if(vertices.get(dependency.getDependsOn()) == null) {
+        vertices.put(dependency.getDependsOn(), new HashSet());
+      }
-    outboundEdges.add(dependency);
-    
-    if(vertices.get(dependency.getDependsOn()) == null) {
-      vertices.put(dependency.getDependsOn(), new HashSet());
-    }
-    
-      boolean foundCycle = visitCycle(start, unvisited, finished, cycle);
+      boolean foundCycle = visitCycle(start, unvisited, finished, cycle, 0);
+   * This will find the longest call chain in the graph.  If a
+   * cycle is detected it will be returned.  Otherwise all
+   * subgraphs are traversed to find the one that has the most
+   * depth.  This usually indicates the thread that is blocking
+   * the most other threads.<p>
+   * 
+   * The findDependenciesWith method can then be used to find all
+   * top-level threads that are blocked by the culprit.
+   */
+  public DependencyGraph findLongestCallChain() {
+    int depth = 0;
+    DependencyGraph deepest = null;
+    
+    for (Object dep: vertices.keySet()) {
+      int itsDepth = getDepth(dep);
+      if (itsDepth > depth) {
+        deepest = getSubGraph(dep);
+        depth = itsDepth;
+      }
+    }
+    
+    return deepest;
+  }
+  
+  
+  
+  /**
+   * This returns a collection of top-level threads and their
+   * path to the given object.  The object name is some
+   * substring of the toString of the object
+   *
+   * @param objectName
+   */
+  public List<DependencyGraph> findDependenciesWith(String objectName) {
+    
+    // first find a dependency containing the node.  If we can't find one
+    // we can just quit
+    Object obj = null;
+    Dependency objDep = null;
+    for (Dependency dep: edges) {
+      if (dep.depender.toString().contains(objectName)) {
+        obj = dep.depender;
+        objDep = dep;
+        break;
+      }
+      if (dep.dependsOn.toString().contains(objectName)) {
+        obj = dep.dependsOn;
+        objDep = dep;
+        break;
+      }
+    }
+    if (obj == null) {
+      return Collections.emptyList();
+    }
+    
+    // expand the dependency set to include all incoming
+    // references, references to those references, etc.
+    // This should give us a collection that includes all
+    // top-level nodes that have no references to them
+    Set<Object> dependsOnObj = new HashSet<>();
+    dependsOnObj.add(obj);
+    boolean anyAdded = true;
+    while (anyAdded) {
+      anyAdded = false;
+      for (Dependency dep: edges) {
+        if (dependsOnObj.contains(dep.dependsOn)
+            && !dependsOnObj.contains(dep.depender)) {
+          anyAdded = true;
+          dependsOnObj.add(dep.depender);
+        }
+      }
+    }
+
+    // find all terminal nodes having no incoming
+    // dependers.
+    Set<Object> allDependants = new HashSet<>();
+    for (Dependency dep: edges) {
+      if ( (dep.dependsOn instanceof LocalThread) ) {
+        if (dep.depender instanceof MessageKey) {
+          allDependants.add(dep.dependsOn);
+        }
+      } else {
+        allDependants.add(dep.dependsOn);
+      }
+    }
+    
+    List<DependencyGraph> result = new LinkedList<>();
+    for (Object depender: dependsOnObj) {
+      if (!allDependants.contains(depender)) {
+        result.add(getSubGraph(depender));
+      }
+    }
+    
+    return result;
+  }
+  
+  /**
+   * @param depth the depth of the recursion chain up to this point
-      Set<Object> finished, CycleHolder cycle) {
+      Set<Object> finished, CycleHolder cycle, int depth) {
+    cycle.processDepth(depth);
+    
-      foundCycle |= visitCycle(dep.getDependsOn(), unvisited, finished, cycle);
+      foundCycle |= visitCycle(dep.getDependsOn(), unvisited, finished, cycle, depth+1);
+  /** return the depth of the subgraph for the given object */
+  private int getDepth(Object depender) {
+    Set<Object> unvisited = new HashSet<Object>(vertices.keySet());
+    Set<Object> finished = new HashSet<Object>(vertices.size());
+
+    Object start = depender;
+    CycleHolder cycle = new CycleHolder();
+
+    boolean foundCycle = visitCycle(start, unvisited, finished, cycle, 0);
+
+    if(foundCycle) {
+      return Integer.MAX_VALUE;
+    } else {
+      return cycle.getMaxDepth();
+    }
+  }
+  
+
+    private int maxDepth = 0;
+    
+    public void processDepth(int depth) {
+      if (depth > maxDepth) {
+        maxDepth = depth;
+      }
+    }
+    
+    public int getMaxDepth() {
+      return maxDepth;
+    }
+  

GEODE-8130: use a single region for redis Sets and Hashes  (#5120)

* Replaced replicated metaRegion with a partitioned dataRegion.
Currently the dataRegion is used the same way as the metaRegion
except for sets and hashes which store their actual data in it.
* Exception handling now correctly deals with FunctionException
* Disabled a test until GEODE-8127 if fixed.
* Now uses the ByteArrayWrapper as the key on the meta region
and the locks map instead of using a String.
Since a ByteArrayWrapper is used as the key in the data region
this will end up saving memory.

* Found a problem with redis dynamic region management.
Some of the code was executing when we added a new set or hash to
the metaDataRegion. It was only ignoring STRING and HLL.
This caused some extra memory to be used for every redis set/hash.
Now the dynamic region code is only used for lists and sortedSet.

* This commit has some TODO comments of what looks like a bug in
the dynamic region code when a new server is started. It looks
like the new server will not create already existing dynamic regions.
We could test this by starting one server, create a LIST, then
start another server, and then shutdown the first server. Does
the LIST still exist? If we change them not to use dynamic regions
then this issue will go away.
+import static org.apache.geode.redis.internal.RedisDataType.REDIS_SET;
-import java.util.concurrent.atomic.AtomicBoolean;
-import org.apache.geode.DataSerializable;
-import org.apache.geode.Delta;
+import org.apache.geode.redis.internal.RedisData;
+import org.apache.geode.redis.internal.RedisDataType;
-public class RedisSet implements Delta, DataSerializable {
+public class RedisSet implements RedisData {
+
-      Region<ByteArrayWrapper, RedisSet> region, ByteArrayWrapper key, int popCount) {
+      Region<ByteArrayWrapper, RedisData> region, ByteArrayWrapper key, int popCount) {
-      // TODO: need to also cause key to be removed from the metaregion
-   * @return the number of members actually added; -1 if concurrent modification
+   * @return the number of members actually added
-      Region<ByteArrayWrapper, RedisSet> region,
+      Region<ByteArrayWrapper, RedisData> region,
-   * @param setWasDeleted set to true if this method deletes the set
-   * @return the number of members actually removed; -1 if concurrent modification
+   * @return the number of members actually removed
-      Region<ByteArrayWrapper, RedisSet> region,
-      ByteArrayWrapper key, AtomicBoolean setWasDeleted) {
+      Region<ByteArrayWrapper, RedisData> region,
+      ByteArrayWrapper key) {
-        if (setWasDeleted != null) {
-          setWasDeleted.set(true);
-        }
+
+  @Override
+  public RedisDataType getType() {
+    return REDIS_SET;
+  }

GEODE-2632: refactor code to use interfaces instead of impls

* use getInternalDistributedSystem instead of overriding getDistributedSystem
* use InternalCache instead of GemFireCacheImpl
* remove dead code
* remove useless javadocs and comments

-import org.apache.geode.cache.Cache;
+import org.apache.geode.internal.cache.InternalCache;
-import org.apache.geode.internal.logging.LoggingThreadGroup;
-  final ThreadGroup loggerGroup =
-      LoggingThreadGroup.createThreadGroup("Remote Site Discovery Logger Group", logger);
-
-  public ParallelAsyncEventQueueImpl() {
-    super();
-    this.isParallel = true;
-  }
-
-  public ParallelAsyncEventQueueImpl(Cache cache, GatewaySenderAttributes attrs) {
+  public ParallelAsyncEventQueueImpl(InternalCache cache, GatewaySenderAttributes attrs) {
-        String locators =
-            ((GemFireCacheImpl) this.cache).getDistributedSystem().getConfig().getLocators();
+        String locators = this.cache.getInternalDistributedSystem().getConfig().getLocators();
-      /*
-       * if (getDispatcherThreads() > 1) { eventProcessor = new
-       * ConcurrentParallelGatewaySenderEventProcessor(this); } else { eventProcessor = new
-       * ParallelGatewaySenderEventProcessor(this); }
-       */
-
+
-  // /**
-  // * The sender is not started but only the message queue i.e. shadowPR is created on the node.
-  // * @param targetPr
-  // */
-  // private void createMessageQueueOnAccessorNode(PartitionedRegion targetPr) {
-  // eventProcessor = new ParallelGatewaySenderEventProcessor(this, targetPr);
-  // }
-
-
-  /*
-   * (non-Javadoc)
-   * 
-   * @see
-   * org.apache.geode.internal.cache.wan.AbstractGatewaySender#setModifiedEventId(org.apache.geode.
-   * internal.cache.EntryEventImpl)
-   */
-      // if (getOrderPolicy() == OrderPolicy.THREAD) {
-      // bucketId = PartitionedRegionHelper.getHashKey(
-      // ((EntryEventImpl)clonedEvent).getEventId().getThreadID(),
-      // getMaxParallelismForReplicatedRegion());
-      // }
-      // else
-    // we don't neet to generate different threadId for secondary buckets
+    // we don't need to generate different threadId for secondary buckets
-    // boolean isPrimary = ((PartitionedRegion)getQueue().getRegion())
-    // .getRegionAdvisor().getBucketAdvisor(bucketId).isPrimary();
-    // if (isPrimary) {
-    // newThreadId = ThreadIdentifier
-    // .createFakeThreadIDForParallelGSPrimaryBucket(bucketId,
-    // originatingThreadId);
-    // } else {
-    // newThreadId = ThreadIdentifier
-    // .createFakeThreadIDForParallelGSSecondaryBucket(bucketId,
-    // originatingThreadId);
-    // }
-
-

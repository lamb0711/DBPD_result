 GEODE-6580: Cleanup static analyzer warnings. (#3415)

+
-import java.util.Collection;
-import java.util.Iterator;
+import org.apache.geode.annotations.VisibleForTesting;
-import org.apache.geode.cache.Cache;
-  /** Maps Classes to their ids */
-  private static final ConcurrentMap/* <String,Instantiator> */ dsMap = new ConcurrentHashMap();
+  private static final ConcurrentMap<String, Instantiator> dsMap = new ConcurrentHashMap<>();
-  private static final ConcurrentMap/* <Integer,Instantiator|Marker> */ idsToInstantiators =
-      new ConcurrentHashMap();
+  private static final ConcurrentMap<Integer, Object> idsToInstantiators =
+      new ConcurrentHashMap<>();
-      new ConcurrentHashMap<String, InstantiatorAttributesHolder>();
+      new ConcurrentHashMap<>();
-  private static final ConcurrentHashMap<Integer, InstantiatorAttributesHolder> idsToHolders =
-      new ConcurrentHashMap<Integer, InstantiatorAttributesHolder>();
+  private static final ConcurrentHashMap<Integer, InstantiatorAttributesHolder> idsToHolders;
+
+  static {
+    idsToHolders = new ConcurrentHashMap<>();
+  }
-    // [sumedh] Skip the checkForThread() check if the instantiation has not
+    // Skip the checkForThread() check if the instantiation is not
-      throw new NullPointerException(
-          "Cannot register a null Instantiator.");
+      throw new NullPointerException("Cannot register a null Instantiator.");
-      throw new IllegalArgumentException(
-          "Instantiator id cannot be zero");
+      throw new IllegalArgumentException("Instantiator id cannot be zero");
-        throw new IllegalStateException(
-            String.format(
-                "Class %s is already registered with id %s so it can not be registered with id %s",
-
-                new Object[] {c.getName(), Integer.valueOf(oldId), Integer.valueOf(classId)}));
+        throw new IllegalStateException(String.format(
+            "Class %s is already registered with id %s so it can not be registered with id %s",
+            c.getName(), oldId, classId));
-    final Integer idx = Integer.valueOf(classId);
+    final Integer idx = classId;
-              throw new IllegalStateException(
-                  String.format(
-                      "Class id %s is already registered for class %s so it could not be registered for class %s",
-
-                      new Object[] {Integer.valueOf(classId), oldClass.getName(), cName}));
+              throw new IllegalStateException(String.format(
+                  "Class id %s is already registered for class %s so it could not be registered for class %s",
+                  classId, oldClass.getName(), cName));
-              return; // it was already registered
+              // it was already registered
+              return;
-      // if instantiator is getting registered for first time
-      // its EventID will be null, so generate a new event id
-      // the the distributed system is connected
-      InternalCache cache = GemFireCacheImpl.getInstance();
-      if (cache != null && instantiator.getEventId() == null) {
-        instantiator.setEventId(new EventID(cache.getDistributedSystem()));
-      }
+      setEventIdIfNew(instantiator);
-      logger
-          .info("Instantiator registered with id {} class {}",
-              Integer.valueOf(classId), c.getName());
+      logger.info("Instantiator registered with id {} class {}", classId, c.getName());
-    if (distribute) { // originated in this VM
-      // send a message to other peers telling them about a newly-registered
-      // instantiator, it also send event id of the originator along with the
-      // instantiator
+    if (distribute) {
+      // originated in this VM
-      // send it to cache servers if it is a client
-    // send it to all cache clients irrelevant of distribute
-    // cache servers send it all the clients irrelevant of
-    // originator VM
+   * if instantiator is getting registered for first time its EventID will be null, so generate a
+   * new event id the the distributed system is connected
+   */
+  private static void setEventIdIfNew(final Instantiator instantiator) {
+    final InternalCache cache = getInternalCache();
+    if (cache != null && instantiator.getEventId() == null) {
+      instantiator.setEventId(new EventID(cache.getDistributedSystem()));
+    }
+  }
+
+  @SuppressWarnings("deprecation")
+  private static InternalCache getInternalCache() {
+    return GemFireCacheImpl.getInstance();
+  }
+
+  /**
-    InternalCache cache = GemFireCacheImpl.getInstance();
-    if (cache == null) {
-      // A cache has not yet created
-      return null;
+    if (isCacheCreated()) {
+      return new EventID(InternalDistributedSystem.getAnyInstance());
-    return new EventID(InternalDistributedSystem.getAnyInstance());
+    return null;
-    Cache cache = GemFireCacheImpl.getInstance();
-    if (cache == null) {
-      // A cache has not yet been created.
-      // we can't propagate it to clients
+    if (!isCacheCreated()) {
+  private static boolean isCacheCreated() {
+    return getInternalCache() != null;
+  }
+
-    Object inst = null;
+    Object inst;
-          throw new IllegalArgumentException(
-              "Instantiator id cannot be zero");
+          throw new IllegalArgumentException("Instantiator id cannot be zero");
-          throw new IllegalStateException(
-              String.format(
-                  "Class %s is already registered with id %s so it can not be registered with id %s",
-
-                  new Object[] {instantiatorClassName, iah.getId(), holder.getId()}));
+          throw new IllegalStateException(String.format(
+              "Class %s is already registered with id %s so it can not be registered with id %s",
+              instantiatorClassName, iah.getId(), holder.getId()));
-        logger.info("Instantiator registered with holder id {} class {}",
-            Integer.valueOf(holder.getId()),
+        logger.info("Instantiator registered with holder id {} class {}", holder.getId(),
-        // fix bug 46355, need to move getCachedClass() outside of sync
-      } catch (ClassNotFoundException cnfe) {
-        InternalCache cache = GemFireCacheImpl.getInstance();
-        if (cache != null && cache.getLogger() != null && cache.getLogger().infoEnabled()) {
-          cache.getLogger().info(
-              String.format("Could not load instantiator class: %s",
-                  new Object[] {cnfe.getMessage()}));
-        }
+      } catch (ClassNotFoundException e) {
+        logClassNotFoundException(e);
-            // recurse
-          } else {
-            // already registered
-            return;
+  private static void logClassNotFoundException(final ClassNotFoundException e) {
+    final InternalCache cache = getInternalCache();
+    if (cache != null && cache.getLogger() != null && cache.getLogger().infoEnabled()) {
+      cache.getLogger()
+          .info(String.format("Could not load instantiator class: %s", e.getMessage()));
+    }
+  }
+
-    public InstantiatorAttributesHolder(String instantiatorClass, String instantiatedClass,
+    InstantiatorAttributesHolder(String instantiatorClass, String instantiatedClass,
-      this.instantiatorName = instantiatorClass;
-      this.instantiatedName = instantiatedClass;
+      instantiatorName = instantiatorClass;
+      instantiatedName = instantiatedClass;
-    public InstantiatorAttributesHolder(String instantiatorClass, String instantiatedClass, int id,
+    InstantiatorAttributesHolder(String instantiatorClass, String instantiatedClass, int id,
-      this.instantiatorName = instantiatorClass;
-      this.instantiatedName = instantiatedClass;
+      instantiatorName = instantiatorClass;
+      instantiatedName = instantiatedClass;
-      return "InstantiatorAttributesHolder[irName=" + this.instantiatorName + ",idName="
-          + this.instantiatedName + ",id=" + this.id
-          + (this.eventId != null ? ",this.eventId=" + this.eventId : "")
-          + (this.context != null ? ",this.context=" + this.context : "") + "]";
+      return "InstantiatorAttributesHolder[irName=" + instantiatorName + ",idName="
+          + instantiatedName + ",id=" + id
+          + (eventId != null ? ",this.eventId=" + eventId : "")
+          + (context != null ? ",this.context=" + context : "") + "]";
-    final Integer idx = Integer.valueOf(classId);
+    final Integer idx = classId;
-          String.format("Class %s was not registered with id %s",
-              new Object[] {c.getName(), Integer.valueOf(classId)}));
+          String.format("Class %s was not registered with id %s", c.getName(), classId));
-  // testhook that removes all registed instantiators
+  /**
+   * testhook that removes all registed instantiators
+   */
+  @VisibleForTesting
-    final Instantiator i = (Instantiator) dsMap.get(c.getName());
+    final Instantiator i = dsMap.get(c.getName());
-    final Integer idx = Integer.valueOf(classId);
+    final Integer idx = classId;
-        } catch (ClassNotFoundException cnfe) {
-          InternalCache cache = GemFireCacheImpl.getInstance();
-          if (cache != null && cache.getLogger() != null
-              && cache.getLogger().infoEnabled()) {
-            cache.getLogger().info(
-                String.format("Could not load instantiator class: %s", cnfe.getMessage()));
-          }
+        } catch (ClassNotFoundException e) {
+          logClassNotFoundException(e);
-      RegistrationMessage m = null;
+      RegistrationMessage m;
-  protected static Instantiator newInstance(Class instantiatorClass, Class instantiatedClass,
-      int id) {
+  protected static Instantiator newInstance(Class<?> instantiatorClass, Class<?> instantiatedClass,
+      int id) throws IllegalArgumentException {
-    Class[] types;
-      types = new Class[] {Class.class, int.class};
-      init = instantiatorClass.getDeclaredConstructor(types);
+      init = instantiatorClass.getDeclaredConstructor(Class.class, int.class);
-        types = new Class[] {Class.class, byte.class};
-        init = instantiatorClass.getDeclaredConstructor(types);
+        init = instantiatorClass.getDeclaredConstructor(Class.class, byte.class);
-          String msg = String.format(
+          throw new IllegalArgumentException(String.format(
-              instantiatorClass.getName(), instantiatorClass.getDeclaringClass());
-          throw new IllegalArgumentException(msg);
+              instantiatorClass.getName(), instantiatorClass.getDeclaringClass()));
-        String msg = String.format(
-            "Class %s does not have a two-argument (Class, int) constructor.",
-            instantiatorClass.getName());
-        throw new IllegalArgumentException(msg);
+        throw new IllegalArgumentException(
+            String.format("Class %s does not have a two-argument (Class, int) constructor.",
+                instantiatorClass.getName()));
-      Object[] args = new Object[] {instantiatedClass,
-          intConstructor ? (Object) Integer.valueOf(id) : (Object) Byte.valueOf((byte) id)};
-      s = (Instantiator) init.newInstance(args);
-
+      s = (Instantiator) init.newInstance(instantiatedClass, convertId(id, intConstructor));
-      throw new IllegalArgumentException(
-          String.format("Could not access zero-argument constructor of %s",
-              instantiatorClass.getName()));
+      throw new IllegalArgumentException(String
+          .format("Could not access zero-argument constructor of %s", instantiatorClass.getName()));
-      RuntimeException ex2 = new IllegalArgumentException(
-          String.format("Could not instantiate an instance of %s",
-              instantiatorClass.getName()));
-      ex2.initCause(ex);
-      throw ex2;
+      throw new IllegalArgumentException(
+          String.format("Could not instantiate an instance of %s", instantiatorClass.getName()),
+          ex);
-      RuntimeException ex2 = new IllegalArgumentException(
-          String.format("While instantiating an instance of %s",
-              instantiatorClass.getName()));
-      ex2.initCause(ex);
-      throw ex2;
+      throw new IllegalArgumentException(
+          String.format("While instantiating an instance of %s", instantiatorClass.getName()), ex);
+  private static Object convertId(int id, boolean asInteger) {
+    if (asInteger) {
+      return id;
+    }
+    return (byte) id;
+  }
+
-    Collection coll = new ArrayList();
-      Iterator it = classNamesToHolders.values().iterator();
-      while (it.hasNext()) {
+      for (InstantiatorAttributesHolder holder : classNamesToHolders.values()) {
-          InstantiatorAttributesHolder holder = (InstantiatorAttributesHolder) it.next();
-        } catch (ClassNotFoundException cnfe) {
-          InternalCache cache = GemFireCacheImpl.getInstance();
-          if (cache != null && cache.getLogger() != null
-              && cache.getLogger().infoEnabled()) {
-            cache.getLogger().info(
-                String.format("Could not load instantiator class: %s",
-                    cnfe.getMessage()));
-          }
+        } catch (ClassNotFoundException e) {
+          logClassNotFoundException(e);
-    coll.addAll(dsMap.values()); // Don't move it before the if block above.
-    return (Instantiator[]) coll.toArray(new Instantiator[coll.size()]);
+    return dsMap.values().toArray(new Instantiator[0]);
-    Collection coll = new ArrayList(dsMap.size() + idsToHolders.size());
-    coll.addAll(dsMap.values());
-    coll.addAll(classNamesToHolders.values()); // TODO (ashetkar) will it add duplicates?
-    return coll.toArray(new Object[coll.size()]);
+    ArrayList<Object> instantiators = new ArrayList<>(dsMap.size() + idsToHolders.size());
+    instantiators.addAll(dsMap.values());
+    instantiators.addAll(classNamesToHolders.values());
+    return instantiators.toArray();
-  public static int getIdsToHoldersSize() {
-    return idsToHolders.size();
-  }
-
-  public static int getNamesToHoldersSize() {
-    return classNamesToHolders.size();
-  }
-  /////////////////////// Inner Classes ///////////////////////
-
-        if (this.instantiator == null) {
+        if (instantiator == null) {
-            this.wait(InternalDataSerializer.GetMarker.WAIT_MS);
+            wait(InternalDataSerializer.GetMarker.WAIT_MS);
-        return this.instantiator;
+        return instantiator;
-        this.notifyAll();
+        notifyAll();
-   * Persist this class's map to out
-   */
-  public static void saveRegistrations(DataOutput out) throws IOException {
-    for (Instantiator inst : InternalInstantiator.getInstantiators()) {
-      out.writeInt(inst.getId());
-      DataSerializer.writeClass(inst.getClass(), out);
-      DataSerializer.writeClass(inst.getInstantiatedClass(), out);
-    }
-    // We know that Instantiator id's must not be 0 so write a zero
-    // to mark then end of the instantiators.
-    out.writeInt(0);
-  }
-
-  /**
-   * Read the data from in and register it with this class.
-   *
-   * @throws IllegalArgumentException if a registration fails
-   */
-  public static void loadRegistrations(DataInput in) throws IOException {
-    int instId;
-    while ((instId = in.readInt()) != 0) {
-      Class instClass = null;
-      Class instantiatedClass = null;
-      boolean skip = false;
-      try {
-        instClass = DataSerializer.readClass(in);
-      } catch (ClassNotFoundException ex) {
-        skip = true;
-      }
-      try {
-        instantiatedClass = DataSerializer.readClass(in);
-      } catch (ClassNotFoundException ex) {
-        skip = true;
-      }
-      if (skip) {
-        continue;
-      }
-      register(newInstance(instClass, instantiatedClass, instId), true);
-    }
-  }
-
-  /**
-    protected Class instantiatorClass;
+    Class instantiatorClass;
-    protected Class instantiatedClass;
+    Class instantiatedClass;
-    protected transient StringBuffer fromDataProblems;
+    transient StringBuffer fromDataProblems;
-    protected String instantiatorClassName;
+    String instantiatorClassName;
-    protected String instantiatedClassName;
+    String instantiatedClassName;
-      this.instantiatorClass = s.getClass();
-      this.instantiatedClass = s.getInstantiatedClass();
-      this.id = s.getId();
-      this.eventId = (EventID) s.getEventId();
+      instantiatorClass = s.getClass();
+      instantiatedClass = s.getInstantiatedClass();
+      id = s.getId();
+      eventId = (EventID) s.getEventId();
-      if (this.fromDataProblems != null) {
+      if (fromDataProblems != null) {
-          logger.debug(this.fromDataProblems);
+          logger.debug(fromDataProblems);
-      if (this.instantiatorClass != null && this.instantiatedClass != null) {
-        Instantiator s = newInstance(this.instantiatorClass, this.instantiatedClass, this.id);
+      if (instantiatorClass != null && instantiatedClass != null) {
+        Instantiator s = newInstance(instantiatorClass, instantiatedClass, id);
-      } else if (this.instantiatorClassName != null && this.instantiatedClassName != null) {
-        InternalInstantiator.register(this.instantiatorClassName, this.instantiatedClassName,
-            this.id, false, this.eventId, null);
+      } else if (instantiatorClassName != null && instantiatedClassName != null) {
+        InternalInstantiator.register(instantiatorClassName, instantiatedClassName,
+            id, false, eventId, null);
-      DataSerializer.writeNonPrimitiveClassName(this.instantiatorClass.getName(), out);
-      DataSerializer.writeNonPrimitiveClassName(this.instantiatedClass.getName(), out);
-      out.writeInt(this.id);
-      DataSerializer.writeObject(this.eventId, out);
+      DataSerializer.writeNonPrimitiveClassName(instantiatorClass.getName(), out);
+      DataSerializer.writeNonPrimitiveClassName(instantiatedClass.getName(), out);
+      out.writeInt(id);
+      DataSerializer.writeObject(eventId, out);
-      if (this.fromDataProblems == null) {
-        this.fromDataProblems = new StringBuffer();
+      if (fromDataProblems == null) {
+        fromDataProblems = new StringBuffer();
-      this.fromDataProblems.append(s);
-      this.fromDataProblems.append("\n\n");
+      fromDataProblems.append(s);
+      fromDataProblems.append("\n\n");
-      this.instantiatorClassName = DataSerializer.readNonPrimitiveClassName(in);
-      this.instantiatedClassName = DataSerializer.readNonPrimitiveClassName(in);
+      instantiatorClassName = DataSerializer.readNonPrimitiveClassName(in);
+      instantiatedClassName = DataSerializer.readNonPrimitiveClassName(in);
-          this.instantiatorClass =
-              InternalDataSerializer.getCachedClass(this.instantiatorClassName); // fix for bug
-                                                                                 // 41206
+          instantiatorClass = InternalDataSerializer.getCachedClass(instantiatorClassName);
-          recordFromDataProblem(
-              String.format("Could not load instantiator class: %s",
-                  ex));
-          this.instantiatorClass = null;
+          recordFromDataProblem(String.format("Could not load instantiator class: %s", ex));
+          instantiatorClass = null;
-          this.instantiatedClass =
-              InternalDataSerializer.getCachedClass(this.instantiatedClassName); // fix for bug
-                                                                                 // 41206
+          instantiatedClass = InternalDataSerializer.getCachedClass(instantiatedClassName);
-          recordFromDataProblem(
-              String.format("Could not load instantiated class: %s",
-                  ex));
-          this.instantiatedClass = null;
+          recordFromDataProblem(String.format("Could not load instantiated class: %s", ex));
+          instantiatedClass = null;
-      this.id = in.readInt();
-      this.eventId = (EventID) DataSerializer.readObject(in);
+      id = in.readInt();
+      eventId = DataSerializer.readObject(in);
-      String instatiatorName = (this.instantiatorClass == null) ? this.instantiatorClassName
-          : this.instantiatorClass.getName();
-      String instatiatedName = (this.instantiatedClass == null) ? this.instantiatedClassName
-          : this.instantiatedClass.getName();
-      return String.format("Register Instantiator %s of class %s that instantiates a %s",
-
-          new Object[] {Integer.valueOf(this.id), instatiatorName, instatiatedName});
+      String instatiatorName = (instantiatorClass == null) ? instantiatorClassName
+          : instantiatorClass.getName();
+      String instatiatedName = (instantiatedClass == null) ? instantiatedClassName
+          : instantiatedClass.getName();
+      return String.format("Register Instantiator %s of class %s that instantiates a %s", id,
+          instatiatorName, instatiatedName);
-      this.instantiatorClass = s.getClass();
-      this.instantiatedClass = s.getInstantiatedClass();
-      this.id = s.getId();
-      this.eventId = (EventID) s.getEventId();
-      this.context = (ClientProxyMembershipID) s.getContext();
+      instantiatorClass = s.getClass();
+      instantiatedClass = s.getInstantiatedClass();
+      id = s.getId();
+      eventId = (EventID) s.getEventId();
+      context = (ClientProxyMembershipID) s.getContext();
-      if (this.instantiatorClass != null && this.instantiatedClass != null) {
-        Instantiator s = newInstance(this.instantiatorClass, this.instantiatedClass, this.id);
-        s.setEventId(this.eventId);
-        s.setContext(this.context);
+      if (instantiatorClass != null && instantiatedClass != null) {
+        Instantiator s = newInstance(instantiatorClass, instantiatedClass, id);
+        s.setEventId(eventId);
+        s.setContext(context);
-      } else if (this.instantiatorClassName != null && this.instantiatedClassName != null) {
-        InternalInstantiator.register(this.instantiatorClassName, this.instantiatedClassName,
-            this.id, false, this.eventId, this.context);
+      } else if (instantiatorClassName != null && instantiatedClassName != null) {
+        InternalInstantiator.register(instantiatorClassName, instantiatedClassName,
+            id, false, eventId, context);
-      this.context = ClientProxyMembershipID.readCanonicalized(in);
+      context = ClientProxyMembershipID.readCanonicalized(in);
-      DataSerializer.writeObject(this.context, out);
+      DataSerializer.writeObject(context, out);
-    for (Iterator itr = dsMap.values().iterator(); itr.hasNext();) {
-      Instantiator instantiator = (Instantiator) itr.next();
-
-      logger
-          .info("Instantiator registered with id {} class {}",
-              Integer.valueOf(instantiator.getId()),
-              instantiator.getInstantiatedClass().getName());
+    for (Instantiator instantiator : dsMap.values()) {
+      logger.info("Instantiator registered with id {} class {}", instantiator.getId(),
+          instantiator.getInstantiatedClass().getName());
-    for (Iterator itr = idsToHolders.values().iterator(); itr.hasNext();) {
-      InstantiatorAttributesHolder holder = (InstantiatorAttributesHolder) itr.next();
-
-      logger.info("Instantiator registered with holder id {} class {}",
-          Integer.valueOf(holder.getId()), holder.getInstantiatedClassName());
+    for (InstantiatorAttributesHolder holder : idsToHolders.values()) {
+      logger.info("Instantiator registered with holder id {} class {}", holder.getId(),
+          holder.getInstantiatedClassName());

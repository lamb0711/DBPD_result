Revert "GEODE-2113 Implement SSL over NIO"

Regression testing encountered some hangs when using message "chunking"
in TCPConduit.  This needs to be investigated and fixed.

This reverts commit a075b0e1a13a7a57378973bbfb7f14a63f29bf87.

+import java.net.Inet6Address;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ThreadPoolExecutor;
+
+import javax.net.ssl.SSLException;
+import org.apache.geode.internal.logging.LoggingExecutors;
+   * Force use of Sockets rather than SocketChannels (NIO). Note from Bruce: due to a bug in the
+   * java VM, NIO cannot be used with IPv6 addresses on Windows. When that condition holds, the
+   * useNIO flag must be disregarded.
+   */
+  private static boolean USE_NIO;
+
+  /**
+   * use direct ByteBuffers instead of heap ByteBuffers for NIO operations
+   */
+  static boolean useDirectBuffers;
+
+  /**
+  /**
+   * true if NIO can be used for the server socket
+   */
+  private boolean useNIO;
+
+    // only use nio if not SSL
+    USE_NIO = !useSSL && !Boolean.getBoolean("p2p.oldIO");
-    LISTENER_CLOSE_TIMEOUT = Integer.getInteger("p2p.listenerCloseTimeout", 60000);
+    useDirectBuffers = USE_NIO && !Boolean.getBoolean("p2p.nodirectBuffers");
+    LISTENER_CLOSE_TIMEOUT = Integer.getInteger("p2p.listenerCloseTimeout", 60000).intValue();
-    BACKLOG = Integer.getInteger("p2p.backlog", 1280);
-    if (Boolean.getBoolean("p2p.oldIO")) {
-      logger.warn("detected use of p2p.oldIO setting - this is no longer supported");
-    }
+    BACKLOG = Integer.getInteger("p2p.backlog", 1280).intValue();
-  int tcpBufferSize = DistributionConfig.DEFAULT_SOCKET_BUFFER_SIZE;
-  int idleConnectionTimeout = DistributionConfig.DEFAULT_SOCKET_LEASE_TIME;
+  public int tcpBufferSize = DistributionConfig.DEFAULT_SOCKET_BUFFER_SIZE;
+  public int idleConnectionTimeout = DistributionConfig.DEFAULT_SOCKET_LEASE_TIME;
-    InetAddress addr = address;
-    if (addr == null) {
-      try {
-        addr = SocketCreator.getLocalHost();
-      } catch (java.net.UnknownHostException e) {
-        throw new ConnectionException("Unable to resolve localHost address", e);
+    this.useNIO = USE_NIO;
+    if (this.useNIO) {
+      InetAddress addr = address;
+      if (addr == null) {
+        try {
+          addr = SocketCreator.getLocalHost();
+        } catch (java.net.UnknownHostException e) {
+          throw new ConnectionException("Unable to resolve localHost address", e);
+        }
+      }
+      // JDK bug 6230761 - NIO can't be used with IPv6 on Windows
+      if (addr instanceof Inet6Address) {
+        String os = System.getProperty("os.name");
+        if (os != null) {
+          if (os.indexOf("Windows") != -1) {
+            this.useNIO = false;
+          }
+        }
+  private ExecutorService hsPool;
+
+  private static final int HANDSHAKE_POOL_SIZE =
+      Integer.getInteger("p2p.HANDSHAKE_POOL_SIZE", 10).intValue();
+  private static final long HANDSHAKE_POOL_KEEP_ALIVE_TIME =
+      Long.getLong("p2p.HANDSHAKE_POOL_KEEP_ALIVE_TIME", 60).longValue();
+
+  /**
+   * added to fix bug 40436
+   */
+  public void setMaximumHandshakePoolSize(int maxSize) {
+    if (this.hsPool != null) {
+      ThreadPoolExecutor handshakePool = (ThreadPoolExecutor) this.hsPool;
+      if (maxSize > handshakePool.getMaximumPoolSize()) {
+        handshakePool.setMaximumPoolSize(maxSize);
+      }
+    }
+  }
+
+    InetAddress ba = this.address;
+    {
+      ExecutorService tmp_hsPool = null;
+      String threadName = "P2P-Handshaker " + ba + ":" + p + " Thread ";
+      try {
+        tmp_hsPool =
+            LoggingExecutors.newThreadPoolWithSynchronousFeedThatHandlesRejection(threadName, null,
+                null, 1, HANDSHAKE_POOL_SIZE, HANDSHAKE_POOL_KEEP_ALIVE_TIME);
+      } catch (IllegalArgumentException poolInitException) {
+        throw new ConnectionException(
+            "while creating handshake pool",
+            poolInitException);
+      }
+      this.hsPool = tmp_hsPool;
+    }
-
+        this.hsPool.shutdownNow();
-      if (serverPort <= 0) {
+      if (this.useNIO) {
+        if (serverPort <= 0) {
-        socket = socketCreator.createServerSocketUsingPortRange(bindAddress,
-            connectionRequestBacklog, isBindAddress,
-            true, 0, tcpPortRange);
-      } else {
-        ServerSocketChannel channel = ServerSocketChannel.open();
-        socket = channel.socket();
+          socket = socketCreator.createServerSocketUsingPortRange(bindAddress,
+              connectionRequestBacklog, isBindAddress,
+              this.useNIO, 0, tcpPortRange);
+        } else {
+          ServerSocketChannel channel = ServerSocketChannel.open();
+          socket = channel.socket();
-        InetSocketAddress inetSocketAddress =
-            new InetSocketAddress(isBindAddress ? bindAddress : null, serverPort);
-        socket.bind(inetSocketAddress, connectionRequestBacklog);
-      }
-
-      try {
-        // set these buffers early so that large buffers will be allocated
-        // on accepted sockets (see java.net.ServerSocket.setReceiverBufferSize javadocs)
-        socket.setReceiveBufferSize(tcpBufferSize);
-        int newSize = socket.getReceiveBufferSize();
-        if (newSize != tcpBufferSize) {
-          logger.info("{} is {} instead of the requested {}",
-              "Listener receiverBufferSize", newSize,
-              tcpBufferSize);
+          InetSocketAddress inetSocketAddress =
+              new InetSocketAddress(isBindAddress ? bindAddress : null, serverPort);
+          socket.bind(inetSocketAddress, connectionRequestBacklog);
-      } catch (SocketException ex) {
-        logger.warn("Failed to set listener receiverBufferSize to {}",
-            tcpBufferSize);
+
+        if (useNIO) {
+          try {
+            // set these buffers early so that large buffers will be allocated
+            // on accepted sockets (see java.net.ServerSocket.setReceiverBufferSize javadocs)
+            socket.setReceiveBufferSize(tcpBufferSize);
+            int newSize = socket.getReceiveBufferSize();
+            if (newSize != tcpBufferSize) {
+              logger.info("{} is {} instead of the requested {}",
+                  "Listener receiverBufferSize", Integer.valueOf(newSize),
+                  Integer.valueOf(tcpBufferSize));
+            }
+          } catch (SocketException ex) {
+            logger.warn("Failed to set listener receiverBufferSize to {}",
+                tcpBufferSize);
+          }
+        }
+        channel = socket.getChannel();
+      } else {
+        try {
+          if (serverPort <= 0) {
+            socket = socketCreator.createServerSocketUsingPortRange(bindAddress,
+                connectionRequestBacklog, isBindAddress,
+                this.useNIO, this.tcpBufferSize, tcpPortRange);
+          } else {
+            socket = socketCreator.createServerSocket(serverPort, connectionRequestBacklog,
+                isBindAddress ? bindAddress : null,
+                this.tcpBufferSize);
+          }
+          int newSize = socket.getReceiveBufferSize();
+          if (newSize != this.tcpBufferSize) {
+            logger.info("Listener receiverBufferSize is {} instead of the requested {}",
+                Integer.valueOf(newSize),
+                Integer.valueOf(this.tcpBufferSize));
+          }
+        } catch (SocketException ex) {
+          logger.warn("Failed to set listener receiverBufferSize to {}",
+              this.tcpBufferSize);
+
+        }
-      channel = socket.getChannel();
-              serverPort, bindAddress),
+              new Object[] {Integer.valueOf(serverPort), bindAddress}),
+    // this.hsPool.shutdownNow(); // I don't trust this not to allocate objects or to synchronize
-        Thread t = this.thread;
+        Thread t = this.thread;;
-              LISTENER_CLOSE_TIMEOUT);
+              Integer.valueOf(LISTENER_CLOSE_TIMEOUT));
+      } finally {
+        this.hsPool.shutdownNow();
-        SocketChannel otherChannel = channel.accept();
-        othersock = otherChannel.socket();
+        if (this.useNIO) {
+          SocketChannel otherChannel = channel.accept();
+          othersock = otherChannel.socket();
+        } else {
+          try {
+            othersock = socket.accept();
+          } catch (SSLException ex) {
+            // SW: This is the case when there is a problem in P2P
+            // SSL configuration, so need to exit otherwise goes into an
+            // infinite loop just filling the logs
+            logger.warn("Stopping P2P listener due to SSL configuration problem.",
+                ex);
+            break;
+          }
+        }
+  private void acceptConnection(final Socket othersock) {
+    try {
+      this.hsPool.execute(new Runnable() {
+        public void run() {
+          basicAcceptConnection(othersock);
+        }
+      });
+    } catch (RejectedExecutionException rejected) {
+      try {
+        othersock.close();
+      } catch (IOException ignore) {
+      }
+    }
+  }
+
-  private void acceptConnection(Socket othersock) {
+  protected void basicAcceptConnection(Socket othersock) {
+      othersock.setSoTimeout(0);
+      socketCreator.handshakeIfSocketIsSSL(othersock, idleConnectionTimeout);
-    } catch (IOException | ConnectionException io) {
+    } catch (IOException io) {
+      // exception is logged by the Connection
+      if (!stopped) {
+        this.getStats().incFailedAccept();
+      }
+    } catch (ConnectionException ex) {
+   * return true if "new IO" classes are being used for the server socket
+   */
+  protected boolean useNIO() {
+    return this.useNIO;
+  }
+
+  /**

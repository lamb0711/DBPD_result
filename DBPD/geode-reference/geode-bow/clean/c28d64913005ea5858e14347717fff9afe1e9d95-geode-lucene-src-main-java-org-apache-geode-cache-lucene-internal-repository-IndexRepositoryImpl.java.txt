Merge branch 'release/1.4.0'

- * 
+ *
- * 
+ *
-import org.apache.geode.cache.Region;
-import org.apache.geode.cache.lucene.internal.LuceneIndexStats;
-import org.apache.geode.cache.lucene.internal.repository.serializer.LuceneSerializer;
-import org.apache.geode.cache.lucene.internal.repository.serializer.SerializerUtil;
-import org.apache.geode.distributed.DistributedLockService;
-import org.apache.geode.distributed.internal.DistributionConfig;
-import org.apache.geode.internal.cache.BucketRegion;
-import org.apache.geode.internal.cache.DistributedRegion;
-import org.apache.geode.internal.logging.LogService;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.function.IntSupplier;
+
-import org.apache.geode.distributed.LockNotHeldException;
-import java.io.IOException;
-import java.util.function.IntSupplier;
+import org.apache.geode.cache.Region;
+import org.apache.geode.cache.lucene.LuceneIndex;
+import org.apache.geode.cache.lucene.LuceneSerializer;
+import org.apache.geode.cache.lucene.internal.LuceneIndexStats;
+import org.apache.geode.cache.lucene.internal.repository.serializer.SerializerUtil;
+import org.apache.geode.distributed.DistributedLockService;
+import org.apache.geode.distributed.LockNotHeldException;
+import org.apache.geode.distributed.internal.DistributionConfig;
+import org.apache.geode.internal.cache.BucketRegion;
+import org.apache.geode.internal.cache.DistributedRegion;
+import org.apache.geode.internal.logging.LogService;
+  private LuceneIndex index;
-  // For test purposes
-  IndexRepositoryImpl(Region<?, ?> region, IndexWriter writer, LuceneSerializer serializer,
-      LuceneIndexStats stats, Region<?, ?> userRegion) throws IOException {
-    this(region, writer, serializer, stats, userRegion,
-        ((DistributedRegion) region).getLockService(), "NoLockFile");
-  }
-
-      String lockName) throws IOException {
+      String lockName, LuceneIndex index) throws IOException {
-    searcherManager = new SearcherManager(writer, APPLY_ALL_DELETES, true, null);
+    searcherManager = createSearchManager();
+    this.index = index;
+  }
+
+  protected SearcherManager createSearchManager() throws IOException {
+    return new SearcherManager(writer, APPLY_ALL_DELETES, true, null);
+    Collection<Document> docs = Collections.emptyList();
+    boolean exceptionHappened = false;
-      Document doc = new Document();
-      SerializerUtil.addKey(key, doc);
-      serializer.toDocument(value, doc);
-      writer.addDocument(doc);
+      try {
+        docs = serializer.toDocuments(index, value);
+      } catch (Exception e) {
+        exceptionHappened = true;
+        stats.incFailedEntries();
+        logger.info("Failed to add index for " + value + " due to " + e.getMessage());
+      }
+      if (!exceptionHappened) {
+        docs.forEach(doc -> SerializerUtil.addKey(key, doc));
+        writer.addDocuments(docs);
+      }
+    Collection<Document> docs = Collections.emptyList();
+    boolean exceptionHappened = false;
-      Document doc = new Document();
-      SerializerUtil.addKey(key, doc);
-      serializer.toDocument(value, doc);
-      writer.updateDocument(SerializerUtil.getKeyTerm(doc), doc);
+      try {
+        docs = serializer.toDocuments(index, value);
+      } catch (Exception e) {
+        exceptionHappened = true;
+        stats.incFailedEntries();
+        logger.info("Failed to update index for " + value + " due to " + e.getMessage());
+      }
+      if (!exceptionHappened) {
+        docs.forEach(doc -> SerializerUtil.addKey(key, doc));
+        Term keyTerm = SerializerUtil.toKeyTerm(key);
+        writer.updateDocuments(keyTerm, docs);
+      }

GEODE-8166: reimplement redis expiration to use new data model (#5174)

* Added timestamp field to RedisData and implemented serialization and delta for it.
Both active and passive expiration have been implemented.

* RedisHash, RedisSet, and RedisString now subclass AbstractRedisData
* type command now uses function
* getset, incr, decr, incrby, and decrby now uses function and is atomic

+import static org.apache.geode.redis.internal.RedisConstants.ERROR_NOT_INTEGER;
+import static org.apache.geode.redis.internal.RedisConstants.ERROR_OVERFLOW;
+
-import org.apache.geode.InvalidDeltaException;
+import org.apache.geode.redis.internal.AbstractRedisData;
+import org.apache.geode.redis.internal.AddsDeltaInfo;
+import org.apache.geode.redis.internal.DeltaInfo;
+import org.apache.geode.redis.internal.RemsDeltaInfo;
-public class RedisHash implements RedisData {
+public class RedisHash extends AbstractRedisData {
-  /**
-   * When deltas are adds it will always contain an even number of field/value pairs.
-   * When deltas are removes it will just contain field names.
-   */
-  private transient ArrayList<ByteArrayWrapper> deltas;
-  // true if deltas contains adds; false if removes
-  private transient boolean deltasAreAdds;
-
+    super.toData(out);
+    super.fromData(in);
-  @Override
-  public boolean hasDelta() {
-    return deltas != null;
-  }
-  public void toDelta(DataOutput out) throws IOException {
-    DataSerializer.writeBoolean(deltasAreAdds, out);
-    DataSerializer.writeArrayList(deltas, out);
-  }
-
-  @Override
-  public void fromDelta(DataInput in) throws IOException, InvalidDeltaException {
-    boolean deltaAdds = DataSerializer.readBoolean(in);
-    try {
-      ArrayList<ByteArrayWrapper> deltas = DataSerializer.readArrayList(in);
-      if (deltas != null) {
-        Iterator<ByteArrayWrapper> iterator = deltas.iterator();
-        while (iterator.hasNext()) {
-          ByteArrayWrapper field = iterator.next();
-          if (deltaAdds) {
-            ByteArrayWrapper value = iterator.next();
-            hash.put(field, value);
-          } else {
-            hash.remove(field);
-          }
-        }
+  protected void applyDelta(DeltaInfo deltaInfo) {
+    if (deltaInfo instanceof AddsDeltaInfo) {
+      AddsDeltaInfo addsDeltaInfo = (AddsDeltaInfo) deltaInfo;
+      Iterator<ByteArrayWrapper> iterator = addsDeltaInfo.getAdds().iterator();
+      while (iterator.hasNext()) {
+        ByteArrayWrapper field = iterator.next();
+        ByteArrayWrapper value = iterator.next();
+        hash.put(field, value);
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException(e);
+    } else {
+      RemsDeltaInfo remsDeltaInfo = (RemsDeltaInfo) deltaInfo;
+      for (ByteArrayWrapper field : remsDeltaInfo.getRemoves()) {
+        hash.remove(field);
+      }
+    AddsDeltaInfo deltaInfo = null;
-        if (deltas == null) {
-          deltas = new ArrayList<>();
+        if (deltaInfo == null) {
+          deltaInfo = new AddsDeltaInfo();
-        deltas.add(field);
-        deltas.add(value);
+        deltaInfo.add(field);
+        deltaInfo.add(value);
-    storeChanges(region, key, true);
+    storeChanges(region, key, deltaInfo);
+    RemsDeltaInfo deltaInfo = null;
-        if (deltas == null) {
-          deltas = new ArrayList<>();
+        if (deltaInfo == null) {
+          deltaInfo = new RemsDeltaInfo();
-        deltas.add(fieldToRemove);
+        deltaInfo.add(fieldToRemove);
-    storeChanges(region, key, false);
+    storeChanges(region, key, deltaInfo);
-      deltas = new ArrayList<>(2);
-      deltas.add(field);
-      deltas.add(newValue);
-      storeChanges(region, key, true);
+      AddsDeltaInfo deltaInfo = new AddsDeltaInfo();
+      deltaInfo.add(field);
+      deltaInfo.add(newValue);
+      storeChanges(region, key, deltaInfo);
-    long value = Long.parseLong(oldValue.toString());
+    long value;
+    try {
+      value = Long.parseLong(oldValue.toString());
+    } catch (NumberFormatException ex) {
+      throw new NumberFormatException(ERROR_NOT_INTEGER);
+    }
-      throw new ArithmeticException("overflow");
+      throw new ArithmeticException(ERROR_OVERFLOW);
-    deltas = new ArrayList<>(2);
-    deltas.add(field);
-    deltas.add(modifiedValue);
-    storeChanges(region, key, true);
+    AddsDeltaInfo deltaInfo = new AddsDeltaInfo();
+    deltaInfo.add(field);
+    deltaInfo.add(modifiedValue);
+    storeChanges(region, key, deltaInfo);
-      deltas = new ArrayList<>(2);
-      deltas.add(field);
-      deltas.add(newValue);
-      storeChanges(region, key, true);
+      AddsDeltaInfo deltaInfo = new AddsDeltaInfo();
+      deltaInfo.add(field);
+      deltaInfo.add(newValue);
+      storeChanges(region, key, deltaInfo);
-      throw new NumberFormatException("could not convert " + valueS + " to a double");
+      throw new NumberFormatException("hash value is not a float");
-    double value = Coder.stringToDouble(valueS);
+    double value;
+    try {
+      value = Coder.stringToDouble(valueS);
+    } catch (NumberFormatException ex) {
+      throw new NumberFormatException("hash value is not a float");
+    }
-    deltas = new ArrayList<>(2);
-    deltas.add(field);
-    deltas.add(modifiedValue);
-    storeChanges(region, key, true);
+    AddsDeltaInfo deltaInfo = new AddsDeltaInfo();
+    deltaInfo.add(field);
+    deltaInfo.add(modifiedValue);
+    storeChanges(region, key, deltaInfo);
-  private void storeChanges(Region<ByteArrayWrapper, RedisData> region, ByteArrayWrapper key,
-      boolean doingAdds) {
-    if (hasDelta()) {
-      if (!doingAdds && hash.isEmpty()) {
-        region.remove(key);
-      } else {
-        deltasAreAdds = doingAdds;
-        try {
-          region.put(key, this);
-        } finally {
-          deltas = null;
-        }
-      }
-    }
-  }
-
+
+  @Override
+  protected boolean removeFromRegion() {
+    return hash.isEmpty();
+  }

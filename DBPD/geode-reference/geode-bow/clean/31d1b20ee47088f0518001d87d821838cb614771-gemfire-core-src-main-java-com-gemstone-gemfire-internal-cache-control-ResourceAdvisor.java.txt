Initial import of geode-1.0.0.0-SNAPSHOT-2.
All the new sub-project directories (like jvsd) were not imported.
A diff was done to confirm that this commit is exactly the same as
the open directory the snapshot was made from.

+import java.util.ArrayList;
+import com.gemstone.gemfire.DataSerializer;
+import com.gemstone.gemfire.internal.DSCODE;
+import com.gemstone.gemfire.internal.Version;
-import com.gemstone.gemfire.internal.cache.control.InternalResourceManager.Thresholds;
+import com.gemstone.gemfire.internal.cache.control.InternalResourceManager.ResourceType;
+import com.gemstone.gemfire.internal.cache.control.MemoryThresholds.MemoryState;
+    // As of 9.0 this message will only ever have a single profile.
+    // But to be compatible with previous releases we still support
+    // multiple profiles so that we can handle these messages during
+    // a rolling upgrade.
-     * Constructor used to send
-     * @param recips
-     * @param ps
+     * Constructor used to send profiles to other members.
+     * 
+     * @param recips Members to send the profile to.
+     * @param profile Profile to send.
-        final ResourceManagerProfile[] ps) {
+        final ResourceManagerProfile profile) {
-      this.profiles = ps;
+      this.profiles = new ResourceManagerProfile[]{profile};
-              p = this.profiles[i];
-              ra.putProfile(p);
+              ra.putProfile(this.profiles[i]);
+    @Override
-     * @param profiles one or more profiles to send in this message
+     * @param profile Profile to send in this message
-        ResourceManagerProfile[] profiles) {
+        ResourceManagerProfile profile) {
-      ResourceProfileMessage r = new ResourceProfileMessage(recips, profiles);
+      ResourceProfileMessage r = new ResourceProfileMessage(recips, profile);
+  @SuppressWarnings("synthetic-access")
-    // Evaluate profiles before adding them to the ResourceAdvisor so that we
-    // can deliver the events for each type, yet forget those which are DISABLED,
-    // except the very first profile.  It is necessary to forget the DISABLED
-    // state in this scenario:
-    // 1) CRITICAL_UP, 2) CRITICAL_DISABLED, 3) EVICTION_DOWN
-    // to make it possible to deliver the EVICTION_DOWN event.
-    ResourceManagerProfile newp = (ResourceManagerProfile) newProfile;
-    ResourceManagerProfile oldp = (ResourceManagerProfile) oldProfile;
-    final MemoryEventImpl oldEvent;
-    if (oldp != null) {
-      oldEvent = oldp.getMemoryEvent();
+
+    ResourceManagerProfile oldRMProfile = (ResourceManagerProfile) oldProfile;
+    ResourceManagerProfile newRMProfile = (ResourceManagerProfile) newProfile;
+    
+    List<ResourceEvent> eventsToDeliver = new ArrayList<ResourceEvent>();
+    
+    if (oldRMProfile == null) {
+      eventsToDeliver.add(new MemoryEvent(ResourceType.HEAP_MEMORY, MemoryState.DISABLED, newRMProfile.heapState, newRMProfile.getDistributedMember(),
+          newRMProfile.heapBytesUsed, false, newRMProfile.heapThresholds));
+      eventsToDeliver.add(new MemoryEvent(ResourceType.OFFHEAP_MEMORY, MemoryState.DISABLED, newRMProfile.offHeapState, newRMProfile.getDistributedMember(),
+          newRMProfile.offHeapBytesUsed, false, newRMProfile.offHeapThresholds));
+      
-      oldEvent = generateMemoryEventUnknown(newp.getDistributedMember());
+      if (oldRMProfile.heapState != newRMProfile.heapState) {
+        eventsToDeliver.add(new MemoryEvent(ResourceType.HEAP_MEMORY, oldRMProfile.heapState, newRMProfile.heapState, newRMProfile.getDistributedMember(),
+            newRMProfile.heapBytesUsed, false, newRMProfile.heapThresholds));
+      }
+  
+      if (newRMProfile.heapState == MemoryState.DISABLED) {
+        newRMProfile.setHeapData(oldRMProfile.heapBytesUsed, oldRMProfile.heapState, oldRMProfile.heapThresholds);
+      }
+      
+      if (oldRMProfile.offHeapState != newRMProfile.offHeapState) {
+        eventsToDeliver.add(new MemoryEvent(ResourceType.OFFHEAP_MEMORY, oldRMProfile.offHeapState, newRMProfile.offHeapState, newRMProfile.getDistributedMember(),
+            newRMProfile.offHeapBytesUsed, false, newRMProfile.offHeapThresholds));
+      }
+      
+      if (newRMProfile.offHeapState == MemoryState.DISABLED) {
+        newRMProfile.setOffHeapData(oldRMProfile.offHeapBytesUsed, oldRMProfile.offHeapState, oldRMProfile.offHeapThresholds);
+      }
-    MemoryEventImpl newEvent = newp.getMemoryEvent();
-    boolean delivered = getResourceManager().informListenersOfRemoteEvent(newEvent, oldEvent);
-    if (oldp != null && (!delivered || newEvent.isDisableEvent())) {
-      // Erase new profile state info, keep the new profile version.
-      MemoryEventImpl ome = oldp.getMemoryEvent();
-      newp.setEventState(ome.getCurrentHeapUsagePercent(), ome.getCurrentHeapBytesUsed(),
-          ome.getType(), ome.getThresholds());
-      // Remembering the new profile version is essential in handling race conditions e.g.
-      // Sender:  1) Critical UP (v1), 2) Critical DOWN (v2)
-      // Recipient:  1) Critical DOWN (v2), 2 Critical UP (v1)
+    for (ResourceEvent event : eventsToDeliver) {
+      getResourceManager().deliverEventFromRemote(event);
+    
-  /**
-   * Construct a new MemoryEventImpl with {@link MemoryEventType#UNKNOWN} type
-   * and the provided member id. 
-   * @param distributedMember the member the memory event should take
-   * @return the new MemoryEventImpl instance
-   */
-  private static MemoryEventImpl generateMemoryEventUnknown(
-      InternalDistributedMember distributedMember) {
-    return new MemoryEventImpl(MemoryEventType.UNKNOWN, distributedMember,
-                               0, 0, 0, false, new Thresholds(0, false, 0, false, 0, false));
-  }
-
-   * deliver a {@link MemoryEventImpl} for any of the CRITICAL {@link MemoryEventType}s 
+   * deliver a {@link MemoryEvent} for any of the CRITICAL {@link MemoryState}s 
+   * @author David Hoots
-    
-    private int currentHeapUsagePercent;
-    private long currentHeapBytesUsed;
-    private MemoryEventType type;
-    private Thresholds thresholds;
+    private long heapBytesUsed;
+    private MemoryState heapState;
+    private MemoryThresholds heapThresholds;
+    
+    private long offHeapBytesUsed;
+    private MemoryState offHeapState;
+    private MemoryThresholds offHeapThresholds;
-
+    
-    public synchronized ResourceManagerProfile setEventState(int currentHeapUsagePercent,
-        long currentHeapBytesUsed, MemoryEventType type, Thresholds thr) {
-      this.currentHeapUsagePercent = currentHeapUsagePercent;
-      this.currentHeapBytesUsed = currentHeapBytesUsed;
-      this.type = type;
-      this.thresholds = thr;
+    public synchronized ResourceManagerProfile setHeapData(final long heapBytesUsed, final MemoryState heapState,
+        final MemoryThresholds heapThresholds) {
+      this.heapBytesUsed = heapBytesUsed;
+      this.heapState = heapState;
+      this.heapThresholds = heapThresholds;
-    /**
-     * @return a new memory event derived from the state of this profile
-     */
-    public synchronized MemoryEventImpl getMemoryEvent() {
-      return new MemoryEventImpl(this.type, getDistributedMember(),
-          this.currentHeapUsagePercent, this.currentHeapBytesUsed, 0, false, this.thresholds);
+    public synchronized ResourceManagerProfile setOffHeapData(final long offHeapBytesUsed, final MemoryState offHeapState,
+        final MemoryThresholds offHeapThresholds) {
+      this.offHeapBytesUsed = offHeapBytesUsed;
+      this.offHeapState = offHeapState;
+      this.offHeapThresholds = offHeapThresholds;
+      return this;
+    }
+    
+    public synchronized MemoryEvent createDisabledMemoryEvent(ResourceType resourceType) {
+      if (resourceType == ResourceType.HEAP_MEMORY) {
+        return new MemoryEvent(ResourceType.HEAP_MEMORY, this.heapState, MemoryState.DISABLED, getDistributedMember(), this.heapBytesUsed,
+            false, this.heapThresholds);
+      }
+      
+      return new MemoryEvent(ResourceType.OFFHEAP_MEMORY, this.offHeapState, MemoryState.DISABLED, getDistributedMember(), this.offHeapBytesUsed,
+          false, this.offHeapThresholds);
-        sb.append("; state=").append(this.type)
-        .append("; currentHeapUsagePercent=").append(this.currentHeapUsagePercent)
-        .append("; currentHeapBytesUsed=").append(this.currentHeapBytesUsed);
+        sb.append("; heapState=").append(this.heapState)
+        .append("; heapBytesUsed=").append(this.heapBytesUsed)
+        .append("; heapThresholds=").append(this.heapThresholds)
+        .append("; offHeapState=").append(this.offHeapState)
+        .append("; offHeapBytesUsed=").append(this.offHeapBytesUsed)
+        .append("; offHeapThresholds=").append(this.offHeapThresholds);
-      final int chup = in.readInt();
-      final long chbu = in.readLong();
-      MemoryEventType s = MemoryEventType.fromData(in);
-      Thresholds t = Thresholds.fromData(in);
-      setEventState(chup, chbu, s, t);
+      
+      if (InternalDataSerializer.getVersionForDataStream(in).compareTo(Version.GFE_90) >= 0) {
+        final long heapBytesUsed = in.readLong();
+        MemoryState heapState = MemoryState.fromData(in);
+        MemoryThresholds heapThresholds = MemoryThresholds.fromData(in);
+        setHeapData(heapBytesUsed, heapState, heapThresholds);
+
+        final long offHeapBytesUsed = in.readLong();
+        MemoryState offHeapState = MemoryState.fromData(in);
+        MemoryThresholds offHeapThresholds = MemoryThresholds.fromData(in);
+        setOffHeapData(offHeapBytesUsed, offHeapState, offHeapThresholds);
+      } else {
+        // pre 9.0
+        in.readInt(); // currentHeapUsagePercent
+        long currentHeapBytesUsed = in.readLong();
+        //enum MemoryEventType (the byte GEMFIRE_ENUM followed by two Strings. The enums: UNKNOWN, EVICTION_UP, EVICT_MORE, EVICTION_DOWN, EVICTION_DISABLED, CRITICAL_UP, CRITICAL_DOWN, CRITICAL_DISABLED)
+        byte b = in.readByte();
+        String enumName;
+        if (b == DSCODE.GEMFIRE_ENUM) {
+          String enumClass = DataSerializer.readString(in);
+          assert enumClass.equals("com.gemstone.gemfire.internal.cache.control.MemoryEventType");
+          enumName = DataSerializer.readString(in);
+        } else if (b == DSCODE.SERIALIZABLE) {
+          final byte TC_ENUM = 0x7e;
+          final byte TC_CLASSDESC = 0x72;
+          final byte TC_ENDBLOCK = 0x78;
+          final byte TC_NULL = 0x70;
+          final byte TC_STRING = 0x74;
+          in.readShort(); // STREAM_MAGIC
+          in.readShort(); // STREAM_VERSION
+          b = in.readByte();
+          assert b == TC_ENUM : "expected " + b + " to be TC_ENUM " + TC_ENUM;
+          b = in.readByte();
+          assert b == TC_CLASSDESC : "expected " + b + " to be TC_CLASSDESC " + TC_CLASSDESC;
+          String cn = in.readUTF();
+          //System.out.println("DEBUG enum className=" + cn);
+          assert cn.equals("com.gemstone.gemfire.internal.cache.control.MemoryEventType");
+          in.readLong();
+          in.readByte();
+          int fields = in.readShort();
+          while (fields != 0) {
+            in.readByte();
+            in.readUTF();
+            fields--;
+          }
+          b = in.readByte();
+          assert b == TC_ENDBLOCK : "expected " + b + " to be TC_ENDBLOCK " + TC_ENDBLOCK;
+          // parent classDesc
+          b = in.readByte();
+          assert b == TC_CLASSDESC : "expected " + b + " to be TC_CLASSDESC " + TC_CLASSDESC;
+          cn = in.readUTF();
+          //System.out.println("DEBUG parent className=" + cn);
+          assert cn.equals("java.lang.Enum");
+          in.readLong();
+          in.readByte();
+          fields = in.readShort();
+          while (fields != 0) {
+            in.readByte();
+            in.readUTF();
+            fields--;
+          }
+          b = in.readByte();
+          assert b == TC_ENDBLOCK : "expected " + b + " to be TC_ENDBLOCK " + TC_ENDBLOCK;
+          b = in.readByte();
+          assert b == TC_NULL : "expected " + b + " to be TC_NULL " + TC_NULL;
+          b = in.readByte();
+          assert b == TC_STRING : "expected " + b + " to be TC_STRING " + TC_STRING;
+
+          enumName = in.readUTF();
+          //System.out.println("DEBUG enumName=" + enumName);
+        } else {
+          throw new IllegalStateException("Unexpected byte " + b);
+        }
+        in.readDouble(); // tenuredGenerationMaxBytes
+        in.readBoolean(); // hasTenuredGenerationMaxBytes
+        float criticalThreshold = in.readFloat();
+        in.readBoolean(); // hasCriticalThreshold
+        float evictionThreshold = in.readFloat();
+        in.readBoolean(); // hasEvictionThreshold
+        MemoryState heapState;
+        if (enumName.equals("CRITICAL_UP")) {
+          heapState = MemoryState.CRITICAL;
+        } else if (enumName.equals("CRITICAL_DISABLED")) {
+          heapState = MemoryState.CRITICAL_DISABLED;
+        } else if (enumName.equals("CRITICAL_DOWN")) {
+          heapState = MemoryState.NORMAL;
+        } else {
+          // We really don't care about the other old states so we just call them normal
+          heapState = MemoryState.NORMAL;
+        }
+        setHeapData(currentHeapBytesUsed, heapState, new MemoryThresholds(0, criticalThreshold, evictionThreshold));
+        setOffHeapData(0, MemoryState.DISABLED, new MemoryThresholds(0));
+      }
-      final int chup;  final long chbu; final MemoryEventType s; final Thresholds t;
+      final long heapBytesUsed; final MemoryState heapState; final MemoryThresholds heapThresholds;
+      final long offHeapBytesUsed; final MemoryState offHeapState; final MemoryThresholds offHeapThresholds;
-        chup = this.currentHeapUsagePercent;
-        chbu = this.currentHeapBytesUsed;
-        s = this.type;
-        t = this.thresholds;
+        heapBytesUsed = this.heapBytesUsed;
+        heapState = this.heapState;
+        heapThresholds = this.heapThresholds;
+        
+        offHeapBytesUsed = this.offHeapBytesUsed;
+        offHeapState = this.offHeapState;
+        offHeapThresholds = this.offHeapThresholds;
-      out.writeInt(chup);
-      out.writeLong(chbu);
-      s.toData(out);
-      t.toData(out);
+      
+      if (InternalDataSerializer.getVersionForDataStream(out).compareTo(Version.GFE_90) >= 0) {
+        out.writeLong(heapBytesUsed);
+        heapState.toData(out);
+        heapThresholds.toData(out);
+
+        out.writeLong(offHeapBytesUsed);
+        offHeapState.toData(out);
+        offHeapThresholds.toData(out);
+      } else {
+        out.writeInt(0); // currentHeapUsagePercent
+        out.writeLong(heapBytesUsed); // currentHeapBytesUsed
+        String memoryEventTypeName;
+        switch (heapState) {
+        case EVICTION_CRITICAL:
+        case CRITICAL: memoryEventTypeName = "CRITICAL_UP"; break;
+        case EVICTION_CRITICAL_DISABLED:
+        case CRITICAL_DISABLED: memoryEventTypeName = "CRITICAL_DISABLED"; break;
+        default: memoryEventTypeName = "CRITICAL_DOWN";
+        }
+        out.writeByte(DSCODE.GEMFIRE_ENUM);
+        DataSerializer.writeString("com.gemstone.gemfire.internal.cache.control.MemoryEventType", out);
+        DataSerializer.writeString(memoryEventTypeName, out);
+        out.writeDouble(0.0); // tenuredGenerationMaxBytes
+        out.writeBoolean(false); // hasTenuredGenerationMaxBytes
+        out.writeFloat(heapThresholds.getCriticalThreshold());
+        out.writeBoolean(heapThresholds.isCriticalThresholdEnabled());
+        out.writeFloat(heapThresholds.getEvictionThreshold());
+        out.writeBoolean(heapThresholds.isEvictionThresholdEnabled());
+      }
-    public synchronized MemoryEventType getType() {
-      return this.type;
+    public synchronized MemoryState getHeapState() {
+      return this.heapState;
+    }
+    
+    public synchronized MemoryState getoffHeapState() {
+      return this.offHeapState;
+      @Override
-        return rmp.getType().isCriticalUp();
+        return rmp.getHeapState().isCritical();
-  
-  /**
-   * @param eventsToDeliver
-   */
-  public void informRemoteManagers(final MemoryEventImpl[] eventsToDeliver) {
-    Set<InternalDistributedMember> recips = adviseGeneric();
-    final ResourceManagerProfile[] ps = new ResourceManagerProfile[eventsToDeliver.length];
-    for (int i=0; i<eventsToDeliver.length; i++) {
-      MemoryEventImpl e = eventsToDeliver[i];
-      ResourceManagerProfile rmp = new ResourceManagerProfile(getDistributionManager().getId(), incrementAndGetVersion());
-      ps[i] = rmp.setEventState(e.getCurrentHeapUsagePercent(), e.getCurrentHeapBytesUsed(), e.getType(), e.getThresholds());
-    }
-    ResourceProfileMessage.send(getResourceManager(), recips, ps);
+  public final boolean isHeapCritical(final InternalDistributedMember member) {
+    ResourceManagerProfile rmp = (ResourceManagerProfile)getProfile(member);
+    return rmp != null ? rmp.getHeapState().isCritical() : false;
+  }
+
+  public synchronized void updateRemoteProfile() {
+    Set<InternalDistributedMember> recips = adviseGeneric();
+    ResourceManagerProfile profile = new ResourceManagerProfile(getDistributionManager().getId(), incrementAndGetVersion());
+    getResourceManager().fillInProfile(profile);
+    ResourceProfileMessage.send(getResourceManager(), recips, profile);
-    MemoryEventImpl event = new MemoryEventImpl(oldp.getMemoryEvent(),
-        MemoryEventType.CRITICAL_DISABLED);
-    getResourceManager().informListenersOfRemoteEvent(event, oldp.getMemoryEvent());
+    getResourceManager().deliverEventFromRemote(oldp.createDisabledMemoryEvent(ResourceType.HEAP_MEMORY));
+    getResourceManager().deliverEventFromRemote(oldp.createDisabledMemoryEvent(ResourceType.OFFHEAP_MEMORY));

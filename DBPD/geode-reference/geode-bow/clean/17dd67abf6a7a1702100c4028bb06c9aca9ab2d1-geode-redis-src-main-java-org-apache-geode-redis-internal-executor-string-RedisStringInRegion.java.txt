GEODE-8182: change String commands to use one region (#5165)

* changed all String commands to use the function and to use a single region
* renabled tests ignored for GEODE-8182
* removed the RedisLockService since it is not used in the new data model
* removed the unused del methods on RedisSetCommands and RedisHashCommands
* removed the KeyRegistar since it was no longer needed with a single data region

Co-authored-by: Ray Ingles <ringles@pivotal.io>
+import static org.apache.geode.redis.internal.RedisDataType.REDIS_STRING;
+
+import org.apache.geode.redis.internal.RedisConstants;
+import org.apache.geode.redis.internal.RedisData;
+import org.apache.geode.redis.internal.RedisDataTypeMismatchException;
-  private final Region<ByteArrayWrapper, RedisString> region;
+  private final Region<ByteArrayWrapper, RedisData> region;
-  public RedisStringInRegion(Region<ByteArrayWrapper, RedisString> region) {
+  public RedisStringInRegion(Region<ByteArrayWrapper, RedisData> region) {
-    RedisString redisString = region.get(key);
+    RedisString redisString = checkType(region.get(key));
-      region.create(key, new RedisString(valueToAppend));
+      region.put(key, new RedisString(valueToAppend));
-    RedisString redisString = region.get(key);
+    RedisString redisString = checkType(region.get(key));
-      return redisString.get(region, key);
+      return redisString.get();
-  public RedisString set(ByteArrayWrapper key, ByteArrayWrapper value, SetOptions options) {
-    RedisString redisString = region.get(key);
+  public boolean set(ByteArrayWrapper key, ByteArrayWrapper value, SetOptions options) {
+    if (options != null) {
+      if (options.getExists().equals(SetOptions.Exists.NX)) {
+        return setnx(key, value);
+      }
-    if (options.getExists().equals(SetOptions.Exists.NX) && redisString != null) {
-      return null;
+      if (options.getExists().equals(SetOptions.Exists.XX) && region.get(key) == null) {
+        return false;
+      }
-    if (options.getExists().equals(SetOptions.Exists.XX) && redisString == null) {
-      return null;
-    }
+    RedisString redisString = checkTypeIsString(region.get(key));
-      RedisString newValue = new RedisString(value);
-      region.create(key, newValue);
-      return newValue;
+      region.put(key, new RedisString(value));
+    } else {
+      redisString.set(value);
+      region.put(key, redisString);
-    return redisString.set(value, region, key);
+    return true;
-  public Boolean setnx(ByteArrayWrapper key, ByteArrayWrapper value) {
-    return new RedisString().setnx(key, region, value);
+  private boolean setnx(ByteArrayWrapper key, ByteArrayWrapper value) {
+    if (region.get(key) != null) {
+      return false;
+    }
+    region.put(key, new RedisString(value));
+    return true;
+  }
+
+  private RedisString checkType(RedisData redisData) {
+    if (redisData == null) {
+      return null;
+    }
+    if (redisData.getType() != REDIS_STRING) {
+      throw new RedisDataTypeMismatchException(RedisConstants.ERROR_WRONG_TYPE);
+    }
+    return (RedisString) redisData;
+  }
+
+  private RedisString checkTypeIsString(RedisData redisData) {
+    if (redisData == null || redisData.getType() != REDIS_STRING) {
+      return null;
+    }
+    return (RedisString) redisData;
+  }
+
+  private RedisString checkExists(RedisData redisData) {
+    if (redisData == null) {
+      return null;
+    }
+    return (RedisString) redisData;

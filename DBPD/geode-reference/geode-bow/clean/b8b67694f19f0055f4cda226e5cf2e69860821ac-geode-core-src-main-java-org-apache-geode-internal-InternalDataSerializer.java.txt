Merge branch 'develop' into feature/GEODE-7049

-import org.apache.geode.internal.util.DscodeHelper;
+import org.apache.geode.internal.serialization.DSCODE;
+import org.apache.geode.internal.serialization.DSFIDSerializer;
+import org.apache.geode.internal.serialization.DSFIDSerializerFactory;
+import org.apache.geode.internal.serialization.DataSerializableFixedID;
+import org.apache.geode.internal.serialization.DeserializationContext;
+import org.apache.geode.internal.serialization.DscodeHelper;
+import org.apache.geode.internal.serialization.ObjectDeserializer;
+import org.apache.geode.internal.serialization.ObjectSerializer;
+import org.apache.geode.internal.serialization.SerializationContext;
+import org.apache.geode.internal.serialization.SerializationVersions;
+import org.apache.geode.internal.serialization.StaticSerialization;
+import org.apache.geode.internal.serialization.Version;
+import org.apache.geode.internal.serialization.VersionedDataStream;
-  // array is null
-  public static final byte NULL_ARRAY = -1;
-  /**
-   * array len encoded as int in next 4 bytes
-   *
-   * @since GemFire 5.7
-   */
-  public static final byte INT_ARRAY_LEN = -3;
-  private static final byte TIME_UNIT_NANOSECONDS = -1;
-  private static final byte TIME_UNIT_MICROSECONDS = -2;
-  private static final byte TIME_UNIT_MILLISECONDS = -3;
-  private static final byte TIME_UNIT_SECONDS = -4;
-  /**
-   * array len encoded as unsigned short in next 2 bytes
-   *
-   * @since GemFire 5.7
-   */
-  private static final byte SHORT_ARRAY_LEN = -2;
-  private static final int MAX_BYTE_ARRAY_LEN = (byte) -4 & 0xFF;
-  // Variable Length long encoded as int in next 4 bytes
-  private static final byte INT_VL = 126;
-  // Variable Length long encoded as long in next 8 bytes
-  private static final byte LONG_VL = 127;
-  private static final int MAX_BYTE_VL = 125;
+
+  @MakeNotStatic
+  private static final DSFIDSerializer dsfidSerializer;
+
+  @MakeNotStatic
+  private static final DSFIDFactory dsfidFactory;
+
+    dsfidSerializer = new DSFIDSerializerFactory().setObjectSerializer(new ObjectSerializer() {
+      @Override
+      public void writeObject(Object obj, DataOutput output) throws IOException {
+        InternalDataSerializer.writeObject(obj, output);
+      }
+
+      @Override
+      public void invokeToData(Object ds, DataOutput out) throws IOException {
+        InternalDataSerializer.invokeToData(ds, out);
+      }
+
+      @Override
+      public void writeDSFID(DataSerializableFixedID object, int dsfid, DataOutput out)
+          throws IOException {
+        InternalDataSerializer.writeDSFID(object, dsfid, out);
+      }
+    }).setObjectDeserializer(new ObjectDeserializer() {
+      @Override
+      public Object readObject(DataInput input) throws IOException, ClassNotFoundException {
+        return InternalDataSerializer.readObject(input);
+      }
+
+      @Override
+      public void invokeFromData(Object ds, DataInput in)
+          throws IOException, ClassNotFoundException {
+        InternalDataSerializer.invokeFromData(ds, in);
+      }
+    }).create();
+    dsfidFactory = new DSFIDFactory(dsfidSerializer);
-            out.writeByte(TIME_UNIT_NANOSECONDS);
+            out.writeByte(StaticSerialization.TIME_UNIT_NANOSECONDS);
-            out.writeByte(TIME_UNIT_MICROSECONDS);
+            out.writeByte(StaticSerialization.TIME_UNIT_MICROSECONDS);
-            out.writeByte(TIME_UNIT_MILLISECONDS);
+            out.writeByte(StaticSerialization.TIME_UNIT_MILLISECONDS);
-            out.writeByte(TIME_UNIT_SECONDS);
+            out.writeByte(StaticSerialization.TIME_UNIT_SECONDS);
-    if (dsfidToClassMap != null
-        && logger.isTraceEnabled(LogMarker.SERIALIZER_WRITE_DSFID_VERBOSE)) {
-      logger.trace(LogMarker.SERIALIZER_WRITE_DSFID_VERBOSE, "writeDSFID {} class={}", dsfid,
-          o.getClass());
-      if (dsfid != DataSerializableFixedID.NO_FIXED_ID
-          && dsfid != DataSerializableFixedID.ILLEGAL) {
-        // consistency check to make sure that the same DSFID is not used
-        // for two different classes
-        String newClassName = o.getClass().getName();
-        String existingClassName = dsfidToClassMap.putIfAbsent(dsfid, newClassName);
-        if (existingClassName != null && !existingClassName.equals(newClassName)) {
-          logger.trace(LogMarker.SERIALIZER_WRITE_DSFID_VERBOSE,
-              "dsfid={} is used for class {} and class {}", dsfid, existingClassName, newClassName);
-        }
+    writeDSFID(o, dsfid, out);
+  }
+
+  public static void writeDSFID(DataSerializableFixedID o, int dsfid, DataOutput out)
+      throws IOException {
+    try {
+      if (dsfid != DataSerializableFixedID.NO_FIXED_ID) {
+        dsfidSerializer.writeDSFID(o, dsfid, out);
+        return;
-    }
-    if (dsfid == DataSerializableFixedID.NO_FIXED_ID) {
-    } else {
-      writeDSFIDHeader(dsfid, out);
-    }
-    try {
-      case TIME_UNIT_NANOSECONDS:
+      case StaticSerialization.TIME_UNIT_NANOSECONDS:
-      case TIME_UNIT_MICROSECONDS:
+      case StaticSerialization.TIME_UNIT_MICROSECONDS:
-      case TIME_UNIT_MILLISECONDS:
+      case StaticSerialization.TIME_UNIT_MILLISECONDS:
-      case TIME_UNIT_SECONDS:
+      case StaticSerialization.TIME_UNIT_SECONDS:
-      writeDSFID(dsfid, out);
+      dsfidSerializer.writeDSFID(dsfid, out);
-    boolean isDSFID = ds instanceof DataSerializableFixedID;
+      if (ds instanceof DataSerializableFixedID) {
+        dsfidSerializer.invokeToData(ds, out);
+        return;
+      }
-        if (isDSFID) {
-          ((DataSerializableFixedID) ds).toData(out);
-        } else {
-          ((DataSerializable) ds).toData(out);
-        }
+        ((DataSerializable) ds).toData(out);
-      // DSFID serialization expects an IOException but otherwise
-      // we want to catch it and transform into a ToDataException
-      // since it might be in user code and we want to report it
-      // as a problem with the plugin code
-      if (isDSFID) {
-        throw io;
-      } else {
-        throw new ToDataException("toData failed on DataSerializable " + ds.getClass(), io);
-      }
+      throw new ToDataException("toData failed on DataSerializable " + ds.getClass(), io);
+    if (ds instanceof DataSerializableFixedID) {
+      dsfidSerializer.invokeFromData(ds, in);
+      return;
+    }
-        if (ds instanceof DataSerializableFixedID) {
-          ((DataSerializableFixedID) ds).fromData(in);
-        } else {
-          ((DataSerializable) ds).fromData(in);
-        }
+        ((DataSerializable) ds).fromData(in);
-          logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read {} {}",
-              ds instanceof DataSerializableFixedID ? "DataSerializableFixedID"
-                  : "DataSerializable",
+          logger.trace(LogMarker.SERIALIZER_VERBOSE, "Read DataSerializable {}",
-   * Get the {@link Version} of the peer or disk store that created this {@link DataInput}.
+   * Get the {@link Version} of the peer or disk store that created this
+   * {@link DataInput}.
-   * Get the {@link Version} of the peer or disk store that created this {@link DataInput}. Returns
+   * Get the {@link Version} of the peer or disk store that created this
+   * {@link DataInput}. Returns
-   * Get the {@link Version} of the peer or disk store that created this {@link DataOutput}.
+   * Get the {@link Version} of the peer or disk store that created this
+   * {@link DataOutput}.
-   * Get the {@link Version} of the peer or disk store that created this {@link DataOutput}. Returns
+   * Get the {@link Version} of the peer or disk store that created this
+   * {@link DataOutput}. Returns
-      out.writeByte(NULL_ARRAY);
-    } else if (len <= MAX_BYTE_ARRAY_LEN) {
+      out.writeByte(StaticSerialization.NULL_ARRAY);
+    } else if (len <= StaticSerialization.MAX_BYTE_ARRAY_LEN) {
-      out.writeByte(SHORT_ARRAY_LEN);
+      out.writeByte(StaticSerialization.SHORT_ARRAY_LEN);
-      out.writeByte(INT_ARRAY_LEN);
+      out.writeByte(StaticSerialization.INT_ARRAY_LEN);
-    if (code == NULL_ARRAY) {
+    if (code == StaticSerialization.NULL_ARRAY) {
-      if (result > MAX_BYTE_ARRAY_LEN) {
-        if (code == SHORT_ARRAY_LEN) {
+      if (result > StaticSerialization.MAX_BYTE_ARRAY_LEN) {
+        if (code == StaticSerialization.SHORT_ARRAY_LEN) {
-        } else if (code == INT_ARRAY_LEN) {
+        } else if (code == StaticSerialization.INT_ARRAY_LEN) {
-        return DSFIDFactory.create(in.readByte(), in);
+        return dsfidFactory.create(in.readByte(), in);
-        return DSFIDFactory.create(in.readShort(), in);
+        return dsfidFactory.create(in.readShort(), in);
-        return DSFIDFactory.create(in.readInt(), in);
+        return dsfidFactory.create(in.readInt(), in);
-  private static int readDSFIDHeader(final DataInput in, DSCODE dscode) throws IOException {
-    switch (dscode) {
-      case DS_FIXED_ID_BYTE:
-        return in.readByte();
-      case DS_FIXED_ID_SHORT:
-        return in.readShort();
-      case DS_FIXED_ID_INT:
-        return in.readInt();
-      default:
-        throw new IllegalStateException("unexpected byte: " + dscode + " while reading dsfid");
-    }
-  }
-
-  public static int readDSFIDHeader(final DataInput in) throws IOException {
-    checkIn(in);
-    return readDSFIDHeader(in, DscodeHelper.toDSCODE(in.readByte()));
-  }
-
-  @MakeNotStatic("not tied to the cache lifecycle")
-  private static final ThreadLocalByteArrayCache threadLocalByteArrayCache =
-      new ThreadLocalByteArrayCache(65535);
-
-  /**
-   * Returns a byte array for use by the calling thread.
-   * The returned byte array may be longer than minimumLength.
-   * The byte array belongs to the calling thread but callers must
-   * be careful to not call other methods that may also use this
-   * byte array.
-   */
-  public static byte[] getThreadLocalByteArray(int minimumLength) {
-    return threadLocalByteArrayCache.get(minimumLength);
-  }
-
-    byte[] buf = getThreadLocalByteArray(len);
+    byte[] buf = StaticSerialization.getThreadLocalByteArray(len);
-    return readString(in, DscodeHelper.toDSCODE(header));
+    return StaticSerialization.readString(in, header);
-        return DSFIDFactory.create(in.readByte(), in);
+        return dsfidFactory.create(in.readByte(), in);
-        return DSFIDFactory.create(in.readShort(), in);
+        return dsfidFactory.create(in.readShort(), in);
-        return DSFIDFactory.create(in.readInt(), in);
+        return dsfidFactory.create(in.readInt(), in);
-    if (data <= MAX_BYTE_VL) {
+    if (data <= StaticSerialization.MAX_BYTE_VL) {
-      out.writeByte(INT_VL);
+      out.writeByte(StaticSerialization.INT_VL);
-      out.writeByte(LONG_VL);
+      out.writeByte(StaticSerialization.LONG_VL);
-    } else if (code <= MAX_BYTE_VL) {
+    } else if (code <= StaticSerialization.MAX_BYTE_VL) {
-    } else if (code == INT_VL) {
+    } else if (code == StaticSerialization.INT_VL) {
+  public static DSFIDSerializer getDSFIDSerializer() {
+    return dsfidSerializer;
+  }
+
+  /**
+   * shortcut for getDSFIDSerializer().createDeserializationContext(), this should be used
+   * when you need to create a deserialization "context" to pass to a fromData method
+   * and don't have one available
+   */
+  public static DeserializationContext createDeserializationContext(DataInput in) {
+    return dsfidSerializer.createDeserializationContext(in);
+  }
+
+  /**
+   * shortcut for getDSFIDSerializer().createSerializationContext(), this should be used
+   * when you need to create a deserialization "context" to pass to a toData method and
+   * don't have a one available
+   */
+  public static SerializationContext createSerializationContext(DataOutput out) {
+    return dsfidSerializer.createSerializationContext(out);
+  }
+
+  public static DSFIDFactory getDSFIDFactory() {
+    return dsfidFactory;
+  }
+
-    public void toData(DataOutput out) throws IOException {
-      super.toData(out);
+    public void toData(DataOutput out,
+        SerializationContext context) throws IOException {
+      super.toData(out, context);
-    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      super.fromData(in);
+    public void fromData(DataInput in,
+        DeserializationContext context) throws IOException, ClassNotFoundException {
+      super.fromData(in, context);

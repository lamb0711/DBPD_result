Overhauling the javadocs for the LuceneService

Enhancing the javadocs with more detailed descriptions of what the
classes do, adding links to lucene classes where appropriate, and
removing some cruft that didn't match the current implementation.

This closes #410

+import org.apache.geode.cache.DataPolicy;
- * LuceneService instance is a singleton for each cache.
- * 
- * It provides handle for managing the {@link LuceneIndex} and create the {@link LuceneQuery} via
- * {@link LuceneQueryFactory}
- * 
+ *
+ * The LuceneService provides the capability to create Lucene indexes and execute lucene queries on
+ * data stored in Geode regions. The Lucene indexes are automatically maintained by Geode whenever
+ * entries are updated in the associated regions.
+ *
+ * <p>
+ * To obtain an instance of LuceneService, use {@link LuceneServiceProvider#get(GemFireCache)}.
- * Example: <br>
+ * <p>
+ * Lucene indexes can be created using gfsh, xml, or the java API. Below is an example of creating a
+ * Lucene index with the java API. The Lucene index created on each member that will host data for
+ * the region.
+ * </p>
- * At client and server JVM, initializing cache will create the LuceneServiceImpl object, 
- * which is a singleton at each JVM. 
- * 
- * At each server JVM, for data region to create index, create the index on fields with default analyzer:
- * LuceneIndex index = luceneService.createIndex(indexName, regionName, "field1", "field2", "field3"); 
- * or create index on fields with specified analyzer:
- * LuceneIndex index = luceneService.createIndex(indexName, regionName, analyzerPerField);
- * 
- * We can also create index via cache.xml or gfsh.
- * 
- * At client side, create query and run the search:
- * 
- * LuceneQuery query = luceneService.createLuceneQueryFactory().setLimit(200).setPageSize(20)
- * .setResultTypes(SCORE, VALUE, KEY).setFieldProjection("field1", "field2")
- * .create(indexName, regionName, querystring, analyzer);
- * 
- * The querystring is using lucene's queryparser syntax, such as "field1:zhou* AND field2:gzhou@pivotal.io"
- *  
- * PageableLuceneQueryResults results = query.search();
- * 
- * If pagination is not specified:
- * List list = results.getNextPage(); // return all results in one getNextPage() call
- * or if paging is specified:
- * if (results.hasNextPage()) {
- *   List page = results.nextPage(); // return resules page by page
+ * {
+ *   &#64;code
+ *   LuceneIndex index =
+ *       luceneService.createIndex(indexName, regionName, "field1", "field2", "field3");
- * 
- * The item of the list is either the domain object or instance of {@link LuceneResultStruct}
+ * <p>
+ * You can also specify what {@link Analyzer} to use for each field.
+ * </p>
+ * <pre>
+ * {
+ *   &#64;code
+ *   LuceneIndex index = luceneService.createIndex(indexName, regionName, analyzerPerField);
+ * }
+ * </pre>
+ * Indexes should be created on all peers that host the region being indexed. Clients do not need to
+ * define the index, they can directly execute queries using this service.
+ *
+ * <p>
+ * Queries on this service can return either the region keys, values, or both that match a Lucene
+ * query expression. To execute a query, start with the {@link #createLuceneQueryFactory()} method.
+ * </p>
+ *
+ * <pre>
+ * {
+ *   &#64;code
+ *   LuceneQuery query = luceneService.createLuceneQueryFactory().setLimit(200).create(indexName,
+ *       regionName, "name:John AND zipcode:97006", defaultField);
+ *   Collection<Object> results = query.findValues();
+ * }
+ * </pre>
+ *
+ * <p>
+ * The Lucene index data is colocated with the region that is indexed. This means that the index
+ * data will be partitioned, copied, or persisted using the same configuration options you provide
+ * for the region that is indexed. Queries will automatically be distributed in parallel to cover
+ * all partitions of a partitioned region.
+ * </p>
+ * <p>
+ * Indexes are maintained asynchronously, so changes to regions may not be immediately reflected in
+ * the index. This means that queries executed using this service may return stale results. Use the
+ * {@link #waitUntilFlushed(String, String, long, TimeUnit)} method if you need to wait for your
+ * changes to be indexed before executing a query, however this method should be used sparingly
+ * because it is an expensive operation.
+ * </p>
+ *
+ * <p>
+ * Currently, only partitioned regions are supported. Creating an index on a region with
+ * {@link DataPolicy#REPLICATE} will fail.
+ * </p>
+ * 
-   * only work if the region value is a String or Number, in which case a lucene document will be
+   * only work if the region value is a String or Number, in which case a Lucene document will be
-  String REGION_VALUE_FIELD = "__REGION_VALUE_FIELD";
+  public String REGION_VALUE_FIELD = "__REGION_VALUE_FIELD";
-   * Create a lucene index using default analyzer.
+   * Create a Lucene index using default analyzer.
-   *        java fields on the object otherwise. The special field name
-   *        {{@link #REGION_VALUE_FIELD}} indicates that the entire value should be stored as a
-   *        single field in the index.
+   *        java fields on the object otherwise. The special field name {@link #REGION_VALUE_FIELD}
+   *        indicates that the entire value should be stored as a single field in the index.
-   * Create a lucene index using specified analyzer per field
+   * Create a Lucene index using specified {@link Analyzer} per field. Analyzers are used by Lucene
+   * to tokenize your field into individual words.
-   *        {{@link #createIndex(String, String, String...)}} for details on valid values for
-   *        fields. Each field will be tokenized using the provided Analyzer.
+   *        {@link #createIndex(String, String, String...)} for details on valid values for fields.
+   *        Each field will be tokenized using the provided Analyzer.
-   * Destroy the lucene index
+   * Destroy the Lucene index
-   * Destroy all the lucene indexes for the region
+   * Destroy all the Lucene indexes for the region
-   * Get the lucene index object specified by region name and index name
+   * Get the Lucene index object specified by region name and index name
-   * get all the lucene indexes.
+   * get all the Lucene indexes.
-   * create LuceneQueryFactory
-   * 
-   * @return LuceneQueryFactory object
+   * Create a factory for building a Lucene query.
-  /**
-   * wait until the current entries in cache are indexed
-   * 
+  /*
+   * Wait until the current entries in cache are indexed.
+   *
+   * Lucene indexes are maintained asynchronously. This means that updates to the region will not be
+   * immediately reflected in the Lucene index. This method will either timeout or wait until any
+   * data put into the region before this method call is flushed to the lucene index.
+   *
+   * This method is an expensive operation, so using it before every query is highly discouraged.
+   *
+   * 
+   * 
-   * @param unit granularity of the timeout
-   * @return if entries are flushed within timeout
+   * 
+   * @param unit Time unit associated with the max wait time
+   * 
+   * @return true if entries are flushed within timeout, false if the timeout has elapsed

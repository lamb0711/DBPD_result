Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-import java.util.Collection;
-import java.util.Collections;
-
-import org.apache.geode.cache.query.IndexType;
-  private boolean isMapTypeIndex ; 
-  //If true means pattern is *, if false & still map type index that means 
+  private boolean isMapTypeIndex;
+  // If true means pattern is *, if false & still map type index that means
-  
+
-  String []  multiIndexKeysPattern ;
-  Object [] mapKeys;
+  String[] multiIndexKeysPattern;
+  Object[] mapKeys;
-   * Asif : The Iterators for index creation are different then those which are
-   * used for index updates as in case of Index creation the 0th iterator is
-   * modified such that it always represents collection of Region.Entry objects.
-   * As a result all the rest of iterators as well as indexed expression have to
-   * be modified to appropriately resolve the dependency on 0th iterator.The
-   * missing link indicates the dependency. The original 0th iterator is
-   * evaluated as additional projection attribute. These changes provide
-   * significant improvement in Index creation as compared to previous method.
-   * In this approach the IMQ acts on all the entries of the region while in
-   * previous , it iterated over the individual entry of the Region & applied
+   * Asif : The Iterators for index creation are different then those which are used for index
+   * updates as in case of Index creation the 0th iterator is modified such that it always
+   * represents collection of Region.Entry objects. As a result all the rest of iterators as well as
+   * indexed expression have to be modified to appropriately resolve the dependency on 0th
+   * iterator.The missing link indicates the dependency. The original 0th iterator is evaluated as
+   * additional projection attribute. These changes provide significant improvement in Index
+   * creation as compared to previous method. In this approach the IMQ acts on all the entries of
+   * the region while in previous , it iterated over the individual entry of the Region & applied
-  
+
-  //TODO: Asif Remove the fromClause being passed as parameter to the
+  // TODO: Asif Remove the fromClause being passed as parameter to the
-      String projectionAttributes, String imports, Cache cache, ExecutionContext externalContext, 
-      IndexManager imgr)
-      throws IndexInvalidException {
+      String projectionAttributes, String imports, Cache cache, ExecutionContext externalContext,
+      IndexManager imgr) throws IndexInvalidException {
-    if( externalContext == null) {
+    if (externalContext == null) {
-    Object data[] = modfiyIterDefToSuiteIMQ((CompiledIteratorDef) fromClauseIterators
-        .get(0));
+    Object data[] = modfiyIterDefToSuiteIMQ((CompiledIteratorDef) fromClauseIterators.get(0));
-      throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_INVALID_FROM_CLAUSE_0.toLocalizedString(fromClause));
+      throw new IndexInvalidException(
+          LocalizedStrings.FunctionalIndexCreationHelper_INVALID_FROM_CLAUSE_0
+              .toLocalizedString(fromClause));
-  
+
-    return this.isMapTypeIndex; 
-  } 
-  
+    return this.isMapTypeIndex;
+  }
+
-  
- 
-  
+
+
+
-   * Asif : The function is modified to optmize the index creation code. If the
-   * 0th iterator of from clause is not on Entries, then the 0th iterator is
-   * replaced with that of entries & the value corresponding to original
-   * iterator is derived from the 0th iterator as additional projection
-   * attribute. All the other iterators & index expression if were dependent on
-   * 0th iterator are also appropriately modified such that they are correctly
-   * derived on the modified 0th iterator.
+   * Asif : The function is modified to optmize the index creation code. If the 0th iterator of from
+   * clause is not on Entries, then the 0th iterator is replaced with that of entries & the value
+   * corresponding to original iterator is derived from the 0th iterator as additional projection
+   * attribute. All the other iterators & index expression if were dependent on 0th iterator are
+   * also appropriately modified such that they are correctly derived on the modified 0th iterator.
-  private void prepareFromClause(IndexManager imgr)
-      throws IndexInvalidException {
-    if( imports != null) {
+  private void prepareFromClause(IndexManager imgr) throws IndexInvalidException {
+    if (imports != null) {
-     
-    if (list == null ) { throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_INVALID_FROM_CLAUSE_0.toLocalizedString(fromClause)); }
-    
+
+    if (list == null) {
+      throw new IndexInvalidException(
+          LocalizedStrings.FunctionalIndexCreationHelper_INVALID_FROM_CLAUSE_0
+              .toLocalizedString(fromClause));
+    }
+
-        RuntimeIterator rIter = iterDef.getRuntimeIterator(this.context);      
+        RuntimeIterator rIter = iterDef.getRuntimeIterator(this.context);
-        if (i != 0 && !iterDef.isDependentOnCurrentScope(this.context)) { throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_INVALID_FROM_CLAUSE_0_SUBSEQUENT_ITERATOR_EXPRESSIONS_IN_FROM_CLAUSE_MUST_BE_DEPENDENT_ON_PREVIOUS_ITERATORS.toLocalizedString(fromClause)); }
+        if (i != 0 && !iterDef.isDependentOnCurrentScope(this.context)) {
+          throw new IndexInvalidException(
+              LocalizedStrings.FunctionalIndexCreationHelper_INVALID_FROM_CLAUSE_0_SUBSEQUENT_ITERATOR_EXPRESSIONS_IN_FROM_CLAUSE_MUST_BE_DEPENDENT_ON_PREVIOUS_ITERATORS
+                  .toLocalizedString(fromClause));
+        }
-        //      Asif: Bind the Index_Internal_ID to the RuntimeIterator
+        // Asif: Bind the Index_Internal_ID to the RuntimeIterator
-      
+
-          //if (iterDef.getCollectionExpr() instanceof CompiledRegion || iterDef.getCollectionExpr() instanceof CompiledPath) {
-          //  pr.getIndexManager().putCanonicalizedIteratorName(pr.getFullPath(), this.canonicalizedIteratorNames[i]);
-          //} else {
-          this.canonicalizedIteratorNames[i] = pr.getIndexManager().putCanonicalizedIteratorNameIfAbsent(definition);
-          //}
+          // if (iterDef.getCollectionExpr() instanceof CompiledRegion ||
+          // iterDef.getCollectionExpr() instanceof CompiledPath) {
+          // pr.getIndexManager().putCanonicalizedIteratorName(pr.getFullPath(),
+          // this.canonicalizedIteratorNames[i]);
+          // } else {
+          this.canonicalizedIteratorNames[i] =
+              pr.getIndexManager().putCanonicalizedIteratorNameIfAbsent(definition);
+          // }
-          this.canonicalizedIteratorNames[i] = imgr.putCanonicalizedIteratorNameIfAbsent(definition);
+          this.canonicalizedIteratorNames[i] =
+              imgr.putCanonicalizedIteratorNameIfAbsent(definition);
- 
+
-        tempBuff.append(definition).append(' ').append(
-            this.canonicalizedIteratorNames[i]).append(", ");
+        tempBuff.append(definition).append(' ').append(this.canonicalizedIteratorNames[i])
+            .append(", ");
-            //In case the name of iterator is null or balnk set it to
+            // In case the name of iterator is null or balnk set it to
-          CompiledValue newCollExpr = new CompiledPath(
-              new CompiledBindArgument(1), "entries");
-          //TODO Asif : What if cv is not an instance of CompiledRegion
+          CompiledValue newCollExpr = new CompiledPath(new CompiledBindArgument(1), "entries");
+          // TODO Asif : What if cv is not an instance of CompiledRegion
-            //missingLinkPath = name + ".value";
+            // missingLinkPath = name + ".value";
-          }
-          else if (cv instanceof CompiledOperation
-              || cv instanceof CompiledPath
+          } else if (cv instanceof CompiledOperation || cv instanceof CompiledPath
-              }
-              else if (cv instanceof CompiledPath) {
+              } else if (cv instanceof CompiledPath) {
-              }
-              else if (cv instanceof CompiledIndexOperation) {
-                reconstruct.add(0, ((CompiledIndexOperation) cv)
-                    .getExpression());
+              } else if (cv instanceof CompiledIndexOperation) {
+                reconstruct.add(0, ((CompiledIndexOperation) cv).getExpression());
-              }
-              else {
-                throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSEFROM_CLAUSE_IS_NEITHER_A_COMPILEDPATH_NOR_COMPILEDOPERATION.toLocalizedString());
+              } else {
+                throw new IndexInvalidException(
+                    LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSEFROM_CLAUSE_IS_NEITHER_A_COMPILEDPATH_NOR_COMPILEDOPERATION
+                        .toLocalizedString());
-              //            CompiledPath cp = (CompiledPath) reconstruct.get(1);
+              // CompiledPath cp = (CompiledPath) reconstruct.get(1);
-              if (tailID.equals("asList") || tailID.equals("asSet")
-                  || tailID.equals("values") || tailID.equals("toArray")
-                  || tailID.equals("getValues")) {
+              if (tailID.equals("asList") || tailID.equals("asSet") || tailID.equals("values")
+                  || tailID.equals("toArray") || tailID.equals("getValues")) {
-                //  missingLinkPath = name + ".value";
-              }
-              else if (tailID.equals("keys") || tailID.equals("getKeys") ||  tailID.equals("keySet")) {
+                // missingLinkPath = name + ".value";
+              } else if (tailID.equals("keys") || tailID.equals("getKeys")
+                  || tailID.equals("keySet")) {
-                //missingLinkPath = name + ".key";
-              }
-              else if (tailID.equals("entries") || tailID.equals("getEntries")|| tailID.equals("entrySet")) {
+                // missingLinkPath = name + ".key";
+              } else if (tailID.equals("entries") || tailID.equals("getEntries")
+                  || tailID.equals("entrySet")) {
-              }
-              else {
-                throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSEFROM_CLAUSE_DOES_NOT_EVALUATE_TO_VALID_COLLECTION.toLocalizedString());
+              } else {
+                throw new IndexInvalidException(
+                    LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSEFROM_CLAUSE_DOES_NOT_EVALUATE_TO_VALID_COLLECTION
+                        .toLocalizedString());
-              int secondTokenType = (reconstruct.size() > 1) ? ((Integer) reconstruct
-                  .get(0)).intValue()
-                  : -1;
+              int secondTokenType =
+                  (reconstruct.size() > 1) ? ((Integer) reconstruct.get(0)).intValue() : -1;
-                //Asif: If the field just next to region , is values or
+                // Asif: If the field just next to region , is values or
-                //able to take care of it by adding a flag in CompiledIndexOp
+                // able to take care of it by adding a flag in CompiledIndexOp
-                //is asList or toArray , we have a problem as we don't have a
+                // is asList or toArray , we have a problem as we don't have a
-                //list of entries. If the field is keys , an exception should
+                // list of entries. If the field is keys , an exception should
-                //as IndexOpn on set is not defined.
+                // as IndexOpn on set is not defined.
-                  additionalProj = new CompiledIndexOperation(
-                      new CompiledBindArgument(1), (CompiledValue) reconstruct
-                          .get(1), returnEntryForRegionCollection);
+                  additionalProj = new CompiledIndexOperation(new CompiledBindArgument(1),
+                      (CompiledValue) reconstruct.get(1), returnEntryForRegionCollection);
-                }
-                else if (tailID.equals("toList") || tailID.equals("toArray")) {
-                  //TODO:Asif . This needs to be supported
-                  throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSETOLIST_TOARRAY_NOT_SUPPORTED.toLocalizedString());
-                }
-                else {
-                  throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSETOLIST_TOARRAY_NOT_SUPPORTED.toLocalizedString());
+                } else if (tailID.equals("toList") || tailID.equals("toArray")) {
+                  // TODO:Asif . This needs to be supported
+                  throw new IndexInvalidException(
+                      LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSETOLIST_TOARRAY_NOT_SUPPORTED
+                          .toLocalizedString());
+                } else {
+                  throw new IndexInvalidException(
+                      LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSETOLIST_TOARRAY_NOT_SUPPORTED
+                          .toLocalizedString());
-              }
-              else if (!isFirstIteratorRegionEntry
-                  && (secondTokenType == OQLLexerTokenTypes.METHOD_INV || secondTokenType == CompiledValue.PATH)
+              } else if (!isFirstIteratorRegionEntry
+                  && (secondTokenType == OQLLexerTokenTypes.METHOD_INV
+                      || secondTokenType == CompiledValue.PATH)
-                      || tailID.equals("keySet") || tailID.equals("keys") || tailID.equals("getKeys"))) {
-                //Asif :Check if the second token name is toList or toArray or
+                      || tailID.equals("keySet") || tailID.equals("keys")
+                      || tailID.equals("getKeys"))) {
+                // Asif :Check if the second token name is toList or toArray or
-                  remove(reconstruct,
-                      ((secondTokenType == OQLLexerTokenTypes.METHOD_INV) ? 3
-                          : 2), 0);
+                  remove(reconstruct, ((secondTokenType == OQLLexerTokenTypes.METHOD_INV) ? 3 : 2),
+                      0);
-            }
-            else if (firstTokenType == OQLLexerTokenTypes.TOK_LBRACK) {
+            } else if (firstTokenType == OQLLexerTokenTypes.TOK_LBRACK) {
-              additionalProj = new CompiledIndexOperation(
-                  new CompiledBindArgument(1), (CompiledValue) reconstruct
-                      .get(1), returnEntryForRegionCollection);
+              additionalProj = new CompiledIndexOperation(new CompiledBindArgument(1),
+                  (CompiledValue) reconstruct.get(1), returnEntryForRegionCollection);
-            }
-            else if (firstTokenType == OQLLexerTokenTypes.METHOD_INV) {
+            } else if (firstTokenType == OQLLexerTokenTypes.METHOD_INV) {
-                  || methodName.equals("values")
-                  || methodName.equals("toArray")
+                  || methodName.equals("values") || methodName.equals("toArray")
-                //missingLinkPath = name + ".value";
-              }
-              else if (methodName.equals("keys")
-                  || methodName.equals("getKeys") || methodName.equals("keySet")) {
+                // missingLinkPath = name + ".value";
+              } else if (methodName.equals("keys") || methodName.equals("getKeys")
+                  || methodName.equals("keySet")) {
-                //missingLinkPath = name + ".key";
-              }
-              else if (methodName.equals("entries")
-                  || methodName.equals("getEntries") || methodName.equals("entrySet") ) {
+                // missingLinkPath = name + ".key";
+              } else if (methodName.equals("entries") || methodName.equals("getEntries")
+                  || methodName.equals("entrySet")) {
-                  if (obj instanceof CompiledBindArgument) { throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSEENTRIES_METHOD_CALLED_WITH_COMPILEDBINDARGUMENT.toLocalizedString()); }
+                  if (obj instanceof CompiledBindArgument) {
+                    throw new IndexInvalidException(
+                        LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSEENTRIES_METHOD_CALLED_WITH_COMPILEDBINDARGUMENT
+                            .toLocalizedString());
+                  }
-              int secondTokenType = (reconstruct.size() > 1) ? ((Integer) reconstruct
-                  .get(0)).intValue()
-                  : -1;
+              int secondTokenType =
+                  (reconstruct.size() > 1) ? ((Integer) reconstruct.get(0)).intValue() : -1;
-                if (methodName.equals("values")
-                    || methodName.equals("getValues")) {
+                if (methodName.equals("values") || methodName.equals("getValues")) {
-                  newCollExpr = new CompiledIndexOperation(
-                      new CompiledBindArgument(1), (CompiledValue) reconstruct
-                          .get(1), returnEntryForRegionCollection);
-                }
-                else if (methodName.equals("toList")
-                    || methodName.equals("toArray")) {
-                  //TODO:Asif . This needs to be supported
-                  throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSETOLIST_TOARRAY_NOT_SUPPORTED_YET.toLocalizedString());
-                }
-                else {
-                  throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSETOLIST_TOARRAY_NOT_SUPPORTED_YET.toLocalizedString());
+                  newCollExpr = new CompiledIndexOperation(new CompiledBindArgument(1),
+                      (CompiledValue) reconstruct.get(1), returnEntryForRegionCollection);
+                } else if (methodName.equals("toList") || methodName.equals("toArray")) {
+                  // TODO:Asif . This needs to be supported
+                  throw new IndexInvalidException(
+                      LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSETOLIST_TOARRAY_NOT_SUPPORTED_YET
+                          .toLocalizedString());
+                } else {
+                  throw new IndexInvalidException(
+                      LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSETOLIST_TOARRAY_NOT_SUPPORTED_YET
+                          .toLocalizedString());
-              }
-              else if (!isFirstIteratorRegionEntry
-                  && (secondTokenType == OQLLexerTokenTypes.METHOD_INV || secondTokenType == CompiledValue.PATH)
-                  && (methodName.equals("values")
-                      || methodName.equals("getValues")
-                      || methodName.equals("keys") || methodName
-                      .equals("getKeys") || methodName.equals("keySet"))) {
-                //Asif :Check if the second token name is toList or toArray or
+              } else if (!isFirstIteratorRegionEntry
+                  && (secondTokenType == OQLLexerTokenTypes.METHOD_INV
+                      || secondTokenType == CompiledValue.PATH)
+                  && (methodName.equals("values") || methodName.equals("getValues")
+                      || methodName.equals("keys") || methodName.equals("getKeys")
+                      || methodName.equals("keySet"))) {
+                // Asif :Check if the second token name is toList or toArray or
-                  remove(reconstruct,
-                      ((secondTokenType == OQLLexerTokenTypes.METHOD_INV) ? 3
-                          : 2), 0);
+                  remove(reconstruct, ((secondTokenType == OQLLexerTokenTypes.METHOD_INV) ? 3 : 2),
+                      0);
-                    additionalProj = new CompiledPath(additionalProj,
-                        (String) reconstruct.get(++j));
-                  }
-                  else if (tokenType == OQLLexerTokenTypes.TOK_LBRACK) {
+                    additionalProj =
+                        new CompiledPath(additionalProj, (String) reconstruct.get(++j));
+                  } else if (tokenType == OQLLexerTokenTypes.TOK_LBRACK) {
-                  }
-                  else if (tokenType == OQLLexerTokenTypes.METHOD_INV) {
+                  } else if (tokenType == OQLLexerTokenTypes.METHOD_INV) {
-                        (String) reconstruct.get(++j), (List) reconstruct
-                            .get(++j));
+                        (String) reconstruct.get(++j), (List) reconstruct.get(++j));
-          }
-          else {
-            throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSEFROM_CLAUSE_IS_NEITHER_A_COMPILEDPATH_NOR_COMPILEDOPERATION.toLocalizedString());
+          } else {
+            throw new IndexInvalidException(
+                LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSEFROM_CLAUSE_IS_NEITHER_A_COMPILEDPATH_NOR_COMPILEDOPERATION
+                    .toLocalizedString());
-        }
-        else if (!this.isFirstIteratorRegionEntry) {
+        } else if (!this.isFirstIteratorRegionEntry) {
-            newItr = (CompiledIteratorDef) getModifiedDependentCompiledValue(
-                context, i, iterDef, true);
+            newItr =
+                (CompiledIteratorDef) getModifiedDependentCompiledValue(context, i, iterDef, true);
-    }
-    catch (Exception e) {
-      if (e instanceof IndexInvalidException) throw (IndexInvalidException) e;
+    } catch (Exception e) {
+      if (e instanceof IndexInvalidException)
+        throw (IndexInvalidException) e;
-        throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_INVALID_FROM_CLAUSE_0.toLocalizedString(fromClause));
+      throw new IndexInvalidException(
+          LocalizedStrings.FunctionalIndexCreationHelper_INVALID_FROM_CLAUSE_0
+              .toLocalizedString(fromClause));
-   * Asif: This fuinction is modified so that if the indexed expression has any
-   * dependency on the 0th iterator, then it needs to modified by using the
-   * missing link so that it is derivable from the 0th iterator.
+   * Asif: This fuinction is modified so that if the indexed expression has any dependency on the
+   * 0th iterator, then it needs to modified by using the missing link so that it is derivable from
+   * the 0th iterator.
-  private void prepareIndexExpression(String indexedExpression)
-      throws IndexInvalidException {
+  private void prepareIndexExpression(String indexedExpression) throws IndexInvalidException {
-    //List indexedExprs = this.compiler.compileProjectionAttributes(indexedExpression);
-    if (expr == null  ) {
-      throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_INVALID_INDEXED_EXPRESSION_0.toLocalizedString(indexedExpression)); 
+    // List indexedExprs = this.compiler.compileProjectionAttributes(indexedExpression);
+    if (expr == null) {
+      throw new IndexInvalidException(
+          LocalizedStrings.FunctionalIndexCreationHelper_INVALID_INDEXED_EXPRESSION_0
+              .toLocalizedString(indexedExpression));
-    
+
-        || expr instanceof CompiledComparison
-        || expr instanceof CompiledBindArgument
+        || expr instanceof CompiledComparison || expr instanceof CompiledBindArgument
-        throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_INVALID_INDEXED_EXPRESSION_0.toLocalizedString(indexedExpression));
+      throw new IndexInvalidException(
+          LocalizedStrings.FunctionalIndexCreationHelper_INVALID_INDEXED_EXPRESSION_0
+              .toLocalizedString(indexedExpression));
-      if(expr instanceof MapIndexable) {
-        MapIndexable mi = (MapIndexable)expr;
-        //CompiledIndexOperation cio = (CompiledIndexOperation)expr;
+      if (expr instanceof MapIndexable) {
+        MapIndexable mi = (MapIndexable) expr;
+        // CompiledIndexOperation cio = (CompiledIndexOperation)expr;
-        if( indexingKeys.size() == 1 && indexingKeys.get(0) == CompiledValue.MAP_INDEX_ALL_KEYS) {
+        if (indexingKeys.size() == 1 && indexingKeys.get(0) == CompiledValue.MAP_INDEX_ALL_KEYS) {
-          //Strip the index operator
+          // Strip the index operator
-          sb.append('[').append('*').append(']');          
-          
-        }else if(indexingKeys.size() == 1) {
+          sb.append('[').append('*').append(']');
+
+        } else if (indexingKeys.size() == 1) {
-        }else {
+        } else {
-          
+
-          for(int j=0; j < size;++j) {
-            CompiledValue cv = indexingKeys.get(size-j-1);
-            this.mapKeys[size-j-1] = cv.evaluate(context);
+          for (int j = 0; j < size; ++j) {
+            CompiledValue cv = indexingKeys.get(size - j - 1);
+            this.mapKeys[size - j - 1] = cv.evaluate(context);
-            sbuff.insert(0,prefixStr);
+            sbuff.insert(0, prefixStr);
-            this.multiIndexKeysPattern[j] = sbuff.toString();            
+            this.multiIndexKeysPattern[j] = sbuff.toString();
-            buff2.insert(0,',');            
+            buff2.insert(0, ',');
-          sb.append(']'); 
-          
+          sb.append(']');
+
-      }else {
+      } else {
-      
-      //expr.generateCanonicalizedExpression(sb, this.context);
+
+      // expr.generateCanonicalizedExpression(sb, this.context);
-//      String tempStr = this.indexedExpression;
+      // String tempStr = this.indexedExpression;
-        modifiedIndexExpr = getModifiedDependentCompiledValue(context, -1,
-            expr, true);
+        modifiedIndexExpr = getModifiedDependentCompiledValue(context, -1, expr, true);
-    }
-    catch (Exception e) {
-      //e.printStackTrace();
-      throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_INVALID_INDEXED_EXPRESSION_0.toLocalizedString(indexedExpression), e);
+    } catch (Exception e) {
+      // e.printStackTrace();
+      throw new IndexInvalidException(
+          LocalizedStrings.FunctionalIndexCreationHelper_INVALID_INDEXED_EXPRESSION_0
+              .toLocalizedString(indexedExpression),
+          e);
-    if (projectionAttributes != null && !projectionAttributes.equals("*")) { throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_INVALID_PROJECTION_ATTRIBUTES_0.toLocalizedString(projectionAttributes)); }
+    if (projectionAttributes != null && !projectionAttributes.equals("*")) {
+      throw new IndexInvalidException(
+          LocalizedStrings.FunctionalIndexCreationHelper_INVALID_PROJECTION_ATTRIBUTES_0
+              .toLocalizedString(projectionAttributes));
+    }
-    Object retValues[] = { null, null};
+    Object retValues[] = {null, null};
-      //System.out.println("def = "+def);
+      // System.out.println("def = "+def);
-        CompiledIteratorDef newDef = new CompiledIteratorDef(iterDef.getName(),
-            null, bindArg);
+        CompiledIteratorDef newDef = new CompiledIteratorDef(iterDef.getName(), null, bindArg);
-          }
-          else if (cv instanceof CompiledPath) {
+          } else if (cv instanceof CompiledPath) {
-          }
-          else if (cv instanceof CompiledIndexOperation) {
+          } else if (cv instanceof CompiledIndexOperation) {
-          }
-          else {
-            throw new IndexInvalidException(LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSEFROM_CLAUSE_IS_NEITHER_A_COMPILEDPATH_NOR_COMPILEDOPERATION.toLocalizedString());
+          } else {
+            throw new IndexInvalidException(
+                LocalizedStrings.FunctionalIndexCreationHelper_FUNCTIONALINDEXCREATIONHELPERPREPAREFROMCLAUSEFROM_CLAUSE_IS_NEITHER_A_COMPILEDPATH_NOR_COMPILEDOPERATION
+                    .toLocalizedString());
-            }
-            else if (tokenType == OQLLexerTokenTypes.TOK_LBRACK) {
-              cv = new CompiledIndexOperation(cv, (CompiledValue) reconstruct
-                  .get(++j));
-            }
-            else if (tokenType == OQLLexerTokenTypes.METHOD_INV) {
+            } else if (tokenType == OQLLexerTokenTypes.TOK_LBRACK) {
+              cv = new CompiledIndexOperation(cv, (CompiledValue) reconstruct.get(++j));
+            } else if (tokenType == OQLLexerTokenTypes.METHOD_INV) {
-        CompiledIteratorDef newDef = new CompiledIteratorDef(iterDef.getName(),
-            null, cv);
+        CompiledIteratorDef newDef = new CompiledIteratorDef(iterDef.getName(), null, cv);
-    }
-    catch (Exception e) {
+    } catch (Exception e) {
-   * Asif : This function is used to correct the complied value's dependency ,
-   * in case the compiledvalue is dependent on the 0th RuntimeIterator in some
-   * way. Thus the dependent compiled value is prefixed with the missing link so
-   * that it is derivable from the 0th iterator.
+   * Asif : This function is used to correct the complied value's dependency , in case the
+   * compiledvalue is dependent on the 0th RuntimeIterator in some way. Thus the dependent compiled
+   * value is prefixed with the missing link so that it is derivable from the 0th iterator.
-  private CompiledValue getModifiedDependentCompiledValue(
-      ExecutionContext context, int currItrID, CompiledValue cv,
-      boolean isDependent) throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
+  private CompiledValue getModifiedDependentCompiledValue(ExecutionContext context, int currItrID,
+      CompiledValue cv, boolean isDependent)
+      throws AmbiguousNameException, TypeMismatchException, NameResolutionException {
-      RuntimeIterator rItr = (RuntimeIterator) context.getCurrentIterators()
-          .get(currItrID);
+      RuntimeIterator rItr = (RuntimeIterator) context.getCurrentIterators().get(currItrID);
-          getModifiedDependentCompiledValue(context, currItrID, iterDef
-              .getCollectionExpr(), isDependent));
-    }
-    else if (cv instanceof CompiledPath) {
+          getModifiedDependentCompiledValue(context, currItrID, iterDef.getCollectionExpr(),
+              isDependent));
+    } else if (cv instanceof CompiledPath) {
-      return new CompiledPath(getModifiedDependentCompiledValue(context,
-          currItrID, path.getReceiver(), isDependent), path.getTailID());
-    }
-    else if (cv instanceof CompiledOperation) {
+      return new CompiledPath(
+          getModifiedDependentCompiledValue(context, currItrID, path.getReceiver(), isDependent),
+          path.getTailID());
+    } else if (cv instanceof CompiledOperation) {
-          newList.add(getModifiedDependentCompiledValue(context, currItrID,
-              cv1, true));
-        }
-        else {
-          newList.add(getModifiedDependentCompiledValue(context, currItrID,
-              cv1, false));
+          newList.add(getModifiedDependentCompiledValue(context, currItrID, cv1, true));
+        } else {
+          newList.add(getModifiedDependentCompiledValue(context, currItrID, cv1, false));
-      //Asif: What if the receiver is null?
+      // Asif: What if the receiver is null?
+      } else {
+        return new CompiledOperation(
+            getModifiedDependentCompiledValue(context, currItrID, rec, isDependent),
+            oper.getMethodName(), newList);
-      else {
-        return new CompiledOperation(getModifiedDependentCompiledValue(context,
-            currItrID, rec, isDependent), oper.getMethodName(), newList);
-      }
-    }
-    else if (cv instanceof CompiledFunction) {
+    } else if (cv instanceof CompiledFunction) {
-          newCvArray[i] = getModifiedDependentCompiledValue(context, currItrID,
-              cv1, true);
-        }
-        else {
-          newCvArray[i] = getModifiedDependentCompiledValue(context, currItrID,
-              cv1, false);
+          newCvArray[i] = getModifiedDependentCompiledValue(context, currItrID, cv1, true);
+        } else {
+          newCvArray[i] = getModifiedDependentCompiledValue(context, currItrID, cv1, false);
-    }
-    else if (cv instanceof CompiledID) {
+    } else if (cv instanceof CompiledID) {
-      RuntimeIterator rItr0 = (RuntimeIterator) context.getCurrentIterators()
-          .get(0);
+      RuntimeIterator rItr0 = (RuntimeIterator) context.getCurrentIterators().get(0);
-          //Asif: The CompiledID is a RuneTimeIterator & so it needs to be
-          //replaced by the missing link
+          // Asif: The CompiledID is a RuneTimeIterator & so it needs to be
+          // replaced by the missing link
-        }
-        else {
-          //Asif: The compiledID is a compiledpath
+        } else {
+          // Asif: The compiledID is a compiledpath
-      }
-      else {
+      } else {
-    }
-    else if (cv instanceof CompiledIndexOperation) {
+    } else if (cv instanceof CompiledIndexOperation) {
-      }
-      else {
+      } else {
-      return new CompiledIndexOperation(getModifiedDependentCompiledValue(
-          context, currItrID, co.getReceiver(), isDependent), cv1);
-    }
-    else {
+      return new CompiledIndexOperation(
+          getModifiedDependentCompiledValue(context, currItrID, co.getReceiver(), isDependent),
+          cv1);
+    } else {

GEODE-8130: use a single region for redis Sets and Hashes  (#5120)

* Replaced replicated metaRegion with a partitioned dataRegion.
Currently the dataRegion is used the same way as the metaRegion
except for sets and hashes which store their actual data in it.
* Exception handling now correctly deals with FunctionException
* Disabled a test until GEODE-8127 if fixed.
* Now uses the ByteArrayWrapper as the key on the meta region
and the locks map instead of using a String.
Since a ByteArrayWrapper is used as the key in the data region
this will end up saving memory.

* Found a problem with redis dynamic region management.
Some of the code was executing when we added a new set or hash to
the metaDataRegion. It was only ignoring STRING and HLL.
This caused some extra memory to be used for every redis set/hash.
Now the dynamic region code is only used for lists and sortedSet.

* This commit has some TODO comments of what looks like a bug in
the dynamic region code when a new server is started. It looks
like the new server will not create already existing dynamic regions.
We could test this by starting one server, create a LIST, then
start another server, and then shutdown the first server. Does
the LIST still exist? If we change them not to use dynamic regions
then this issue will go away.
-import org.apache.geode.redis.internal.RedisDataType;
+import org.apache.geode.redis.internal.RedisData;
+import org.apache.geode.redis.internal.executor.RedisHashInRegion;
-  protected RedisHash getMap(ExecutionHandlerContext context,
+  protected RedisHash getRedisHash(ExecutionHandlerContext context,
-    Region<ByteArrayWrapper, RedisHash> region =
-        context.getRegionProvider().getHashRegion();
+    Region<ByteArrayWrapper, RedisData> region =
+        context.getRegionProvider().getDataRegion();
-    RedisHash map = region.get(key);
-    if (map == null) {
-      map = new RedisHash(emptyList());
+    RedisData data = region.get(key);
+    if (data == null) {
+      return RedisHash.EMPTY;
+    return RedisHashInRegion.checkType(data);
+  }
-    return map;
+  protected RedisHash getModifiableRedisHash(ExecutionHandlerContext context,
+      ByteArrayWrapper key) {
+    Region<ByteArrayWrapper, RedisData> region =
+        context.getRegionProvider().getDataRegion();
+
+    RedisData data = region.get(key);
+    if (data == null) {
+      return new RedisHash(emptyList());
+    }
+    return RedisHashInRegion.checkType(data);
-   * Save the map information to a region
+   * Save the redisHash information to a region
-   * @param map the map to save
+   * @param redisHash the redisHash to save
-  protected void saveMap(RedisHash map,
-      ExecutionHandlerContext context, ByteArrayWrapper key) {
+  protected void saveRedishHash(RedisHash redisHash,
+      ExecutionHandlerContext context,
+      ByteArrayWrapper key) {
-    if (map == null) {
+    if (redisHash == null) {
-    rp.getHashRegion().put(key, map);
-    context.getKeyRegistrar().register(key, RedisDataType.REDIS_HASH);
+    rp.getDataRegion().put(key, redisHash);

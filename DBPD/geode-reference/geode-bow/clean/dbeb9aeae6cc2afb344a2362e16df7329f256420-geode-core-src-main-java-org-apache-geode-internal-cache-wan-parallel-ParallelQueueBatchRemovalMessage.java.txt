Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-public class ParallelQueueBatchRemovalMessage  extends PartitionMessage {
+public class ParallelQueueBatchRemovalMessage extends PartitionMessage {
-  
+
-  public ParallelQueueBatchRemovalMessage(
-      Set<InternalDistributedMember> recipient, int regionId,
+  public ParallelQueueBatchRemovalMessage(Set<InternalDistributedMember> recipient, int regionId,
-  protected boolean operateOnPartitionedRegion(DistributionManager dm,
-      PartitionedRegion pr, long startTime) throws CacheException {
+  protected boolean operateOnPartitionedRegion(DistributionManager dm, PartitionedRegion pr,
+      long startTime) throws CacheException {
-          BucketRegionQueue bucketRegionQueue = (BucketRegionQueue)pr
-              .getDataStore().getInitializedBucketForId(null, bucketId);
+          BucketRegionQueue bucketRegionQueue =
+              (BucketRegionQueue) pr.getDataStore().getInitializedBucketForId(null, bucketId);
-                GatewayQueueEvent eventForFilter = (GatewayQueueEvent)bucketRegionQueue
-                    .get(key);
+                GatewayQueueEvent eventForFilter = (GatewayQueueEvent) bucketRegionQueue.get(key);
-                }
-                catch (Exception e) {
-                  logger
-                      .fatal(
-                          LocalizedMessage
-                              .create(
-                                  LocalizedStrings.GatewayEventFilter_EXCEPTION_OCCURED_WHILE_HANDLING_CALL_TO_0_AFTER_ACKNOWLEDGEMENT_FOR_EVENT_1,
-                                  new Object[] { filter.toString(),
-                                      eventForFilter }), e);
+                } catch (Exception e) {
+                  logger.fatal(LocalizedMessage.create(
+                      LocalizedStrings.GatewayEventFilter_EXCEPTION_OCCURED_WHILE_HANDLING_CALL_TO_0_AFTER_ACKNOWLEDGEMENT_FOR_EVENT_1,
+                      new Object[] {filter.toString(), eventForFilter}), e);
-            }
-            catch (EntryNotFoundException e) {
+            } catch (EntryNotFoundException e) {
-                logger.debug("WARNING! Got EntryNotFoundException while destroying the key {} for bucket {}", key, bucketId);
+                logger.debug(
+                    "WARNING! Got EntryNotFoundException while destroying the key {} for bucket {}",
+                    key, bucketId);
-        }
-        catch (ForceReattemptException fe) {
+        } catch (ForceReattemptException fe) {
-            logger.debug("Got ForceReattemptException while getting bucket {} to destroyLocally the keys.", bucketId);
+            logger.debug(
+                "Got ForceReattemptException while getting bucket {} to destroyLocally the keys.",
+                bucketId);
-    BatchRemovalReplyMessage.sendWithException(getSender(), getProcessorId(),
-        dm, null);
+    BatchRemovalReplyMessage.sendWithException(getSender(), getProcessorId(), dm, null);
-  public static ParallelQueueBatchRemovalResponse send(
-      Set<InternalDistributedMember> recipients, PartitionedRegion pr,
-      Map<Integer, List> bucketToTailKey) {
-    Assert
-        .assertTrue(recipients != null, "BatchRemovalResponse NULL recipient");
+  public static ParallelQueueBatchRemovalResponse send(Set<InternalDistributedMember> recipients,
+      PartitionedRegion pr, Map<Integer, List> bucketToTailKey) {
+    Assert.assertTrue(recipients != null, "BatchRemovalResponse NULL recipient");
-    ParallelQueueBatchRemovalResponse response = new ParallelQueueBatchRemovalResponse(
-        pr.getSystem(), recipients, pr);
-    ParallelQueueBatchRemovalMessage msg = new ParallelQueueBatchRemovalMessage(
-        recipients, pr.getPRId(), response, bucketToTailKey);
+    ParallelQueueBatchRemovalResponse response =
+        new ParallelQueueBatchRemovalResponse(pr.getSystem(), recipients, pr);
+    ParallelQueueBatchRemovalMessage msg =
+        new ParallelQueueBatchRemovalMessage(recipients, pr.getPRId(), response, bucketToTailKey);
-    Set<InternalDistributedMember> failures = pr.getDistributionManager()
-        .putOutgoing(msg);
+    Set<InternalDistributedMember> failures = pr.getDistributionManager().putOutgoing(msg);
-    this.bucketToTailKey = (Map)DataSerializer.readObject(in);
+    this.bucketToTailKey = (Map) DataSerializer.readObject(in);
-    public BatchRemovalReplyMessage() {
-    }
+    public BatchRemovalReplyMessage() {}
-    public BatchRemovalReplyMessage(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public BatchRemovalReplyMessage(DataInput in) throws IOException, ClassNotFoundException {
-        logger.debug("BatchRemovalReplyMessage process invoking reply processor with processorId: {}", this.processorId);
+        logger.debug(
+            "BatchRemovalReplyMessage process invoking reply processor with processorId: {}",
+            this.processorId);
-    private static void sendWithException(InternalDistributedMember recipient,
-        int processorId, DM dm, ReplyException re) {
-      Assert.assertTrue(recipient != null,
-          "BecomePrimaryBucketReplyMessage NULL recipient");
+    private static void sendWithException(InternalDistributedMember recipient, int processorId,
+        DM dm, ReplyException re) {
+      Assert.assertTrue(recipient != null, "BecomePrimaryBucketReplyMessage NULL recipient");
-    public void fromData(DataInput in) throws IOException,
-        ClassNotFoundException {
+    public void fromData(DataInput in) throws IOException, ClassNotFoundException {
-      sb.append("BatchRemovalReplyMessage ").append("processorid=")
-          .append(this.processorId).append(" reply to sender ")
-          .append(this.getSender());
+      sb.append("BatchRemovalReplyMessage ").append("processorid=").append(this.processorId)
+          .append(" reply to sender ").append(this.getSender());
-  public static class ParallelQueueBatchRemovalResponse extends
-      PartitionResponse {
+  public static class ParallelQueueBatchRemovalResponse extends PartitionResponse {
-      }
-      catch (EntryNotFoundException enfe) {
+      } catch (EntryNotFoundException enfe) {
-      }
-      catch (ForceReattemptException e) {
+      } catch (ForceReattemptException e) {
-      }
-      catch (TransactionDataNotColocatedException e) {
+      } catch (TransactionDataNotColocatedException e) {

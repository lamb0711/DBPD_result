Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-/** <p>MsgStreamer supports streaming a message to a tcp Connection
- * in chunks. This allows us to send a message without needing to
- * perserialize it completely in memory thus saving buffer memory.
+/**
+ * <p>
+ * MsgStreamer supports streaming a message to a tcp Connection in chunks. This allows us to send a
+ * message without needing to perserialize it completely in memory thus saving buffer memory.
+ * 
+ * @since GemFire 5.0.2
+ * 
+ */
-    @since GemFire 5.0.2
-   
-    */
-
-public class MsgStreamer extends OutputStream implements
-    ObjToByteArraySerializer, BaseMsgStreamer, ByteBufferWriter {
+public class MsgStreamer extends OutputStream
+    implements ObjToByteArraySerializer, BaseMsgStreamer, ByteBufferWriter {
-  
+
-   * The byte buffer we used for preparing a chunk of the message.
-   * Currently this buffer is obtained from the connection.
+   * The byte buffer we used for preparing a chunk of the message. Currently this buffer is obtained
+   * from the connection.
-   * True if this message went out as a normal one (it fit it one chunk)
-   * False if this message needed to be chunked.
+   * True if this message went out as a normal one (it fit it one chunk) False if this message
+   * needed to be chunked.
-   * Set to true when we have started serializing a message.
-   * If this is true and doneWritingMsg is false
-   * and we think we have finished writing the msg then we have a problem.
+   * Set to true when we have started serializing a message. If this is true and doneWritingMsg is
+   * false and we think we have finished writing the msg then we have a problem.
-   * Called to free up resources used by this streamer after the streamer has
-   * produced its message.
+   * Called to free up resources used by this streamer after the streamer has produced its message.
-   * Returns an exception the describes which cons the message was not sent to.
-   * Call this after {@link #writeMessage}.
+   * Returns an exception the describes which cons the message was not sent to. Call this after
+   * {@link #writeMessage}.
-   * Returns a list of the Connections that the message was sent to.
-   * Call this after {@link #writeMessage}.
+   * Returns a list of the Connections that the message was sent to. Call this after
+   * {@link #writeMessage}.
-   * Note: This is no longer supposed to be called directly rather the
-   * {@link #create} method should now be used.
+   * Note: This is no longer supposed to be called directly rather the {@link #create} method should
+   * now be used.
-  MsgStreamer(List<?> cons, DistributionMessage msg,
-      boolean directReply, DMStats stats, int sendBufferSize) {
+  MsgStreamer(List<?> cons, DistributionMessage msg, boolean directReply, DMStats stats,
+      int sendBufferSize) {
-   * Create message streamers splitting into versioned streamers, if required,
-   * for given list of connections to remote nodes. This method can either
-   * return a single MsgStreamer object or a List of MsgStreamer objects.
+   * Create message streamers splitting into versioned streamers, if required, for given list of
+   * connections to remote nodes. This method can either return a single MsgStreamer object or a
+   * List of MsgStreamer objects.
-  public static BaseMsgStreamer create(List<?> cons,
-      final DistributionMessage msg, final boolean directReply,
-      final DMStats stats) {
-    final Connection firstCon = (Connection)cons.get(0);
+  public static BaseMsgStreamer create(List<?> cons, final DistributionMessage msg,
+      final boolean directReply, final DMStats stats) {
+    final Connection firstCon = (Connection) cons.get(0);
-        con = (Connection)c;
+        con = (Connection) c;
-          ArrayList<Object> vcons = (ArrayList<Object>)versionToConnMap
-              .get(version);
+          ArrayList<Object> vcons = (ArrayList<Object>) versionToConnMap.get(version);
-        return new MsgStreamer(cons, msg, directReply, stats,
-            firstCon.getSendBufferSize());
-      }
-      else {
+        return new MsgStreamer(cons, msg, directReply, stats, firstCon.getSendBufferSize());
+      } else {
-        final ArrayList<MsgStreamer> streamers = new ArrayList<MsgStreamer>(
-            versionToConnMap.size() + 1);
+        final ArrayList<MsgStreamer> streamers =
+            new ArrayList<MsgStreamer>(versionToConnMap.size() + 1);
-          final ArrayList<Object> unversionedCons = new ArrayList<Object>(
-              numCons);
+          final ArrayList<Object> unversionedCons = new ArrayList<Object>(numCons);
-            con = (Connection)c;
+            con = (Connection) c;
-          streamers.add(new MsgStreamer(unversionedCons, msg, directReply,
-              stats, sendBufferSize));
+          streamers.add(new MsgStreamer(unversionedCons, msg, directReply, stats, sendBufferSize));
-        for (ObjectIterator<Object2ObjectMap.Entry> itr = versionToConnMap.object2ObjectEntrySet().fastIterator(); itr.hasNext(); ) {
+        for (ObjectIterator<Object2ObjectMap.Entry> itr =
+            versionToConnMap.object2ObjectEntrySet().fastIterator(); itr.hasNext();) {
-          streamers.add(new VersionedMsgStreamer((List<?>)l, msg,
-                directReply, stats, sendBufferSize, (Version)ver));
+          streamers.add(new VersionedMsgStreamer((List<?>) l, msg, directReply, stats,
+              sendBufferSize, (Version) ver));
-    }
-    else if ((version = firstCon.getRemoteVersion()) == null) {
-      return new MsgStreamer(cons, msg, directReply, stats,
-          firstCon.getSendBufferSize());
-    }
-    else {
+    } else if ((version = firstCon.getRemoteVersion()) == null) {
+      return new MsgStreamer(cons, msg, directReply, stats, firstCon.getSendBufferSize());
+    } else {
-      return new VersionedMsgStreamer(cons, msg, directReply, stats,
-          firstCon.getSendBufferSize(), version);
+      return new VersionedMsgStreamer(cons, msg, directReply, stats, firstCon.getSendBufferSize(),
+          version);
+   * 
-  public void reserveConnections(long startTime, long ackTimeout,
-      long ackSDTimeout) {
-    for (Iterator it=cons.iterator(); it.hasNext(); ) {
-      Connection con = (Connection)it.next();
+  public void reserveConnections(long startTime, long ackTimeout, long ackSDTimeout) {
+    for (Iterator it = cons.iterator(); it.hasNext();) {
+      Connection con = (Connection) it.next();
-//    if (logger.isTraceEnabled()) logger.trace(this.msg);
-    
+    // if (logger.isTraceEnabled()) logger.trace(this.msg);
+
-  
+
-//    if (logger.isTraceEnabled()) logger.trace(" byte={}", b);
-    
+    // if (logger.isTraceEnabled()) logger.trace(" byte={}", b);
+
-    this.buffer.put((byte)b);
+    this.buffer.put((byte) b);
+
+
-        this.overflowBuf = new HeapDataOutputStream(this.buffer.capacity()-Connection.MSG_HEADER_BYTES, Version.CURRENT);
+        this.overflowBuf = new HeapDataOutputStream(
+            this.buffer.capacity() - Connection.MSG_HEADER_BYTES, Version.CURRENT);
-    final int serializedBytes = this.buffer.limit(); 
+    final int serializedBytes = this.buffer.limit();
-    for (Iterator it=this.cons.iterator(); it.hasNext();) {
-      Connection con = (Connection)it.next();
+    for (Iterator it = this.cons.iterator(); it.hasNext();) {
+      Connection con = (Connection) it.next();
-        con.sendPreserialized(this.buffer, lastFlushForMessage && this.msg.containsRegionContentChange(),
-            conflationMsg);
+        con.sendPreserialized(this.buffer,
+            lastFlushForMessage && this.msg.containsRegionContentChange(), conflationMsg);
-        if (this.ce == null) this.ce = new ConnectExceptions();
+        if (this.ce == null)
+          this.ce = new ConnectExceptions();
-        con.closeForReconnect(LocalizedStrings.MsgStreamer_CLOSING_DUE_TO_0.toLocalizedString("IOException"));
+        con.closeForReconnect(
+            LocalizedStrings.MsgStreamer_CLOSING_DUE_TO_0.toLocalizedString("IOException"));
-        if (this.ce == null) this.ce = new ConnectExceptions();
+        if (this.ce == null)
+          this.ce = new ConnectExceptions();
-        con.closeForReconnect(LocalizedStrings.MsgStreamer_CLOSING_DUE_TO_0.toLocalizedString("ConnectionException"));
+        con.closeForReconnect(
+            LocalizedStrings.MsgStreamer_CLOSING_DUE_TO_0.toLocalizedString("ConnectionException"));
-          for (Iterator it=this.cons.iterator(); it.hasNext();) {
-            Connection con = (Connection)it.next();
+          for (Iterator it = this.cons.iterator(); it.hasNext();) {
+            Connection con = (Connection) it.next();
-  
+
-//    if (logger.isTraceEnabled()) {
-//      logger.trace(" bytes={} offset={} len={}", source, offset, len);
-//    }
+    // if (logger.isTraceEnabled()) {
+    // logger.trace(" bytes={} offset={} len={}", source, offset, len);
+    // }
-//    if (logger.isTraceEnabled()) {
-//      logger.trace(" bytes={} offset={} len={}", source, offset, len);
-//    }
+    // if (logger.isTraceEnabled()) {
+    // logger.trace(" bytes={} offset={} len={}", source, offset, len);
+    // }
-        bb.limit(bb.position()+chunkSize);
+        bb.limit(bb.position() + chunkSize);
-  /** write the header after the message has been written to the
-      stream */
+  /**
+   * write the header after the message has been written to the stream
+   */
-//    int processorType = this.msg.getProcessorType();
+    // int processorType = this.msg.getProcessorType();
-    this.buffer.putInt(Connection.MSG_HEADER_SIZE_OFFSET, Connection.calcHdrSize(this.buffer.limit()-Connection.MSG_HEADER_BYTES));
-    this.buffer.put(Connection.MSG_HEADER_TYPE_OFFSET, (byte)(msgType&0xff));
+    this.buffer.putInt(Connection.MSG_HEADER_SIZE_OFFSET,
+        Connection.calcHdrSize(this.buffer.limit() - Connection.MSG_HEADER_BYTES));
+    this.buffer.put(Connection.MSG_HEADER_TYPE_OFFSET, (byte) (msgType & 0xff));
-    
+
-     * Writes a <code>boolean</code> value to this output stream.
-     * If the argument <code>v</code>
-     * is <code>true</code>, the value <code>(byte)1</code>
-     * is written; if <code>v</code> is <code>false</code>,
-     * the  value <code>(byte)0</code> is written.
-     * The byte written by this method may
-     * be read by the <code>readBoolean</code>
-     * method of interface <code>DataInput</code>,
-     * which will then return a <code>boolean</code>
-     * equal to <code>v</code>.
-     *
-     * @param      v   the boolean to be written.
-     */
+   * Writes a <code>boolean</code> value to this output stream. If the argument <code>v</code> is
+   * <code>true</code>, the value <code>(byte)1</code> is written; if <code>v</code> is
+   * <code>false</code>, the value <code>(byte)0</code> is written. The byte written by this method
+   * may be read by the <code>readBoolean</code> method of interface <code>DataInput</code>, which
+   * will then return a <code>boolean</code> equal to <code>v</code>.
+   *
+   * @param v the boolean to be written.
+   */
-     * Writes to the output stream the eight low-
-     * order bits of the argument <code>v</code>.
-     * The 24 high-order bits of <code>v</code>
-     * are ignored. (This means  that <code>writeByte</code>
-     * does exactly the same thing as <code>write</code>
-     * for an integer argument.) The byte written
-     * by this method may be read by the <code>readByte</code>
-     * method of interface <code>DataInput</code>,
-     * which will then return a <code>byte</code>
-     * equal to <code>(byte)v</code>.
-     *
-     * @param      v   the byte value to be written.
-     */
+   * Writes to the output stream the eight low- order bits of the argument <code>v</code>. The 24
+   * high-order bits of <code>v</code> are ignored. (This means that <code>writeByte</code> does
+   * exactly the same thing as <code>write</code> for an integer argument.) The byte written by this
+   * method may be read by the <code>readByte</code> method of interface <code>DataInput</code>,
+   * which will then return a <code>byte</code> equal to <code>(byte)v</code>.
+   *
+   * @param v the byte value to be written.
+   */
-     * Writes two bytes to the output
-     * stream to represent the value of the argument.
-     * The byte values to be written, in the  order
-     * shown, are: <p>
-     * <pre><code>
-     * (byte)(0xff &amp; (v &gt;&gt; 8))
-     * (byte)(0xff &amp; v)
-     * </code> </pre> <p>
-     * The bytes written by this method may be
-     * read by the <code>readShort</code> method
-     * of interface <code>DataInput</code> , which
-     * will then return a <code>short</code> equal
-     * to <code>(short)v</code>.
-     *
-     * @param      v   the <code>short</code> value to be written.
-     */
+   * Writes two bytes to the output stream to represent the value of the argument. The byte values
+   * to be written, in the order shown, are:
+   * <p>
+   * 
+   * <pre>
+   * <code>
+   * (byte)(0xff &amp; (v &gt;&gt; 8))
+   * (byte)(0xff &amp; v)
+   * </code>
+   * </pre>
+   * <p>
+   * The bytes written by this method may be read by the <code>readShort</code> method of interface
+   * <code>DataInput</code> , which will then return a <code>short</code> equal to
+   * <code>(short)v</code>.
+   *
+   * @param v the <code>short</code> value to be written.
+   */
-//    if (logger.isTraceEnabled()) logger.trace(" short={}", v);
-    
+    // if (logger.isTraceEnabled()) logger.trace(" short={}", v);
+
-    this.buffer.putShort((short)v);
+    this.buffer.putShort((short) v);
-     * Writes a <code>char</code> value, wich
-     * is comprised of two bytes, to the
-     * output stream.
-     * The byte values to be written, in the  order
-     * shown, are:
-     * <p><pre><code>
-     * (byte)(0xff &amp; (v &gt;&gt; 8))
-     * (byte)(0xff &amp; v)
-     * </code></pre><p>
-     * The bytes written by this method may be
-     * read by the <code>readChar</code> method
-     * of interface <code>DataInput</code> , which
-     * will then return a <code>char</code> equal
-     * to <code>(char)v</code>.
-     *
-     * @param      v   the <code>char</code> value to be written.
-     */
+   * Writes a <code>char</code> value, wich is comprised of two bytes, to the output stream. The
+   * byte values to be written, in the order shown, are:
+   * <p>
+   * 
+   * <pre>
+   * <code>
+   * (byte)(0xff &amp; (v &gt;&gt; 8))
+   * (byte)(0xff &amp; v)
+   * </code>
+   * </pre>
+   * <p>
+   * The bytes written by this method may be read by the <code>readChar</code> method of interface
+   * <code>DataInput</code> , which will then return a <code>char</code> equal to
+   * <code>(char)v</code>.
+   *
+   * @param v the <code>char</code> value to be written.
+   */
-//    if (logger.isTraceEnabled()) logger.trace(" char={}", v);
+    // if (logger.isTraceEnabled()) logger.trace(" char={}", v);
-    this.buffer.putChar((char)v);
+    this.buffer.putChar((char) v);
-     * Writes an <code>int</code> value, which is
-     * comprised of four bytes, to the output stream.
-     * The byte values to be written, in the  order
-     * shown, are:
-     * <p><pre><code>
-     * (byte)(0xff &amp; (v &gt;&gt; 24))
-     * (byte)(0xff &amp; (v &gt;&gt; 16))
-     * (byte)(0xff &amp; (v &gt;&gt; &#32; &#32;8))
-     * (byte)(0xff &amp; v)
-     * </code></pre><p>
-     * The bytes written by this method may be read
-     * by the <code>readInt</code> method of interface
-     * <code>DataInput</code> , which will then
-     * return an <code>int</code> equal to <code>v</code>.
-     *
-     * @param      v   the <code>int</code> value to be written.
-     */
+   * Writes an <code>int</code> value, which is comprised of four bytes, to the output stream. The
+   * byte values to be written, in the order shown, are:
+   * <p>
+   * 
+   * <pre>
+   * <code>
+   * (byte)(0xff &amp; (v &gt;&gt; 24))
+   * (byte)(0xff &amp; (v &gt;&gt; 16))
+   * (byte)(0xff &amp; (v &gt;&gt; &#32; &#32;8))
+   * (byte)(0xff &amp; v)
+   * </code>
+   * </pre>
+   * <p>
+   * The bytes written by this method may be read by the <code>readInt</code> method of interface
+   * <code>DataInput</code> , which will then return an <code>int</code> equal to <code>v</code>.
+   *
+   * @param v the <code>int</code> value to be written.
+   */
-//    if (logger.isTraceEnabled()) logger.trace(" int={}", v);
+    // if (logger.isTraceEnabled()) logger.trace(" int={}", v);
-     * Writes a <code>long</code> value, which is
-     * comprised of eight bytes, to the output stream.
-     * The byte values to be written, in the  order
-     * shown, are:
-     * <p><pre><code>
-     * (byte)(0xff &amp; (v &gt;&gt; 56))
-     * (byte)(0xff &amp; (v &gt;&gt; 48))
-     * (byte)(0xff &amp; (v &gt;&gt; 40))
-     * (byte)(0xff &amp; (v &gt;&gt; 32))
-     * (byte)(0xff &amp; (v &gt;&gt; 24))
-     * (byte)(0xff &amp; (v &gt;&gt; 16))
-     * (byte)(0xff &amp; (v &gt;&gt;  8))
-     * (byte)(0xff &amp; v)
-     * </code></pre><p>
-     * The bytes written by this method may be
-     * read by the <code>readLong</code> method
-     * of interface <code>DataInput</code> , which
-     * will then return a <code>long</code> equal
-     * to <code>v</code>.
-     *
-     * @param      v   the <code>long</code> value to be written.
-     */
+   * Writes a <code>long</code> value, which is comprised of eight bytes, to the output stream. The
+   * byte values to be written, in the order shown, are:
+   * <p>
+   * 
+   * <pre>
+   * <code>
+   * (byte)(0xff &amp; (v &gt;&gt; 56))
+   * (byte)(0xff &amp; (v &gt;&gt; 48))
+   * (byte)(0xff &amp; (v &gt;&gt; 40))
+   * (byte)(0xff &amp; (v &gt;&gt; 32))
+   * (byte)(0xff &amp; (v &gt;&gt; 24))
+   * (byte)(0xff &amp; (v &gt;&gt; 16))
+   * (byte)(0xff &amp; (v &gt;&gt;  8))
+   * (byte)(0xff &amp; v)
+   * </code>
+   * </pre>
+   * <p>
+   * The bytes written by this method may be read by the <code>readLong</code> method of interface
+   * <code>DataInput</code> , which will then return a <code>long</code> equal to <code>v</code>.
+   *
+   * @param v the <code>long</code> value to be written.
+   */
-//    if (logger.isTraceEnabled()) logger.trace(" long={}", v);
+    // if (logger.isTraceEnabled()) logger.trace(" long={}", v);
-     * Writes a <code>float</code> value,
-     * which is comprised of four bytes, to the output stream.
-     * It does this as if it first converts this
-     * <code>float</code> value to an <code>int</code>
-     * in exactly the manner of the <code>Float.floatToIntBits</code>
-     * method  and then writes the <code>int</code>
-     * value in exactly the manner of the  <code>writeInt</code>
-     * method.  The bytes written by this method
-     * may be read by the <code>readFloat</code>
-     * method of interface <code>DataInput</code>,
-     * which will then return a <code>float</code>
-     * equal to <code>v</code>.
-     *
-     * @param      v   the <code>float</code> value to be written.
-     */
+   * Writes a <code>float</code> value, which is comprised of four bytes, to the output stream. It
+   * does this as if it first converts this <code>float</code> value to an <code>int</code> in
+   * exactly the manner of the <code>Float.floatToIntBits</code> method and then writes the
+   * <code>int</code> value in exactly the manner of the <code>writeInt</code> method. The bytes
+   * written by this method may be read by the <code>readFloat</code> method of interface
+   * <code>DataInput</code>, which will then return a <code>float</code> equal to <code>v</code>.
+   *
+   * @param v the <code>float</code> value to be written.
+   */
-//    if (logger.isTraceEnabled()) logger.trace(" float={}", v);
+    // if (logger.isTraceEnabled()) logger.trace(" float={}", v);
-     * Writes a <code>double</code> value,
-     * which is comprised of eight bytes, to the output stream.
-     * It does this as if it first converts this
-     * <code>double</code> value to a <code>long</code>
-     * in exactly the manner of the <code>Double.doubleToLongBits</code>
-     * method  and then writes the <code>long</code>
-     * value in exactly the manner of the  <code>writeLong</code>
-     * method. The bytes written by this method
-     * may be read by the <code>readDouble</code>
-     * method of interface <code>DataInput</code>,
-     * which will then return a <code>double</code>
-     * equal to <code>v</code>.
-     *
-     * @param      v   the <code>double</code> value to be written.
-     */
+   * Writes a <code>double</code> value, which is comprised of eight bytes, to the output stream. It
+   * does this as if it first converts this <code>double</code> value to a <code>long</code> in
+   * exactly the manner of the <code>Double.doubleToLongBits</code> method and then writes the
+   * <code>long</code> value in exactly the manner of the <code>writeLong</code> method. The bytes
+   * written by this method may be read by the <code>readDouble</code> method of interface
+   * <code>DataInput</code>, which will then return a <code>double</code> equal to <code>v</code>.
+   *
+   * @param v the <code>double</code> value to be written.
+   */
-//    if (logger.isTraceEnabled()) logger.trace(" double={}", v);
+    // if (logger.isTraceEnabled()) logger.trace(" double={}", v);
-     * Writes a string to the output stream.
-     * For every character in the string
-     * <code>s</code>,  taken in order, one byte
-     * is written to the output stream.  If
-     * <code>s</code> is <code>null</code>, a <code>NullPointerException</code>
-     * is thrown.<p>  If <code>s.length</code>
-     * is zero, then no bytes are written. Otherwise,
-     * the character <code>s[0]</code> is written
-     * first, then <code>s[1]</code>, and so on;
-     * the last character written is <code>s[s.length-1]</code>.
-     * For each character, one byte is written,
-     * the low-order byte, in exactly the manner
-     * of the <code>writeByte</code> method . The
-     * high-order eight bits of each character
-     * in the string are ignored.
-     *
-     * @param      str the string of bytes to be written.
-     */
+   * Writes a string to the output stream. For every character in the string <code>s</code>, taken
+   * in order, one byte is written to the output stream. If <code>s</code> is <code>null</code>, a
+   * <code>NullPointerException</code> is thrown.
+   * <p>
+   * If <code>s.length</code> is zero, then no bytes are written. Otherwise, the character
+   * <code>s[0]</code> is written first, then <code>s[1]</code>, and so on; the last character
+   * written is <code>s[s.length-1]</code>. For each character, one byte is written, the low-order
+   * byte, in exactly the manner of the <code>writeByte</code> method . The high-order eight bits of
+   * each character in the string are ignored.
+   *
+   * @param str the string of bytes to be written.
+   */
-//    if (logger.isTraceEnabled()) logger.trace(" bytes={}", str);
+    // if (logger.isTraceEnabled()) logger.trace(" bytes={}", str);
-        writeByte((byte)str.charAt(i));
+        writeByte((byte) str.charAt(i));
-     * Writes every character in the string <code>s</code>,
-     * to the output stream, in order,
-     * two bytes per character. If <code>s</code>
-     * is <code>null</code>, a <code>NullPointerException</code>
-     * is thrown.  If <code>s.length</code>
-     * is zero, then no characters are written.
-     * Otherwise, the character <code>s[0]</code>
-     * is written first, then <code>s[1]</code>,
-     * and so on; the last character written is
-     * <code>s[s.length-1]</code>. For each character,
-     * two bytes are actually written, high-order
-     * byte first, in exactly the manner of the
-     * <code>writeChar</code> method.
-     *
-     * @param      s   the string value to be written.
-     */
+   * Writes every character in the string <code>s</code>, to the output stream, in order, two bytes
+   * per character. If <code>s</code> is <code>null</code>, a <code>NullPointerException</code> is
+   * thrown. If <code>s.length</code> is zero, then no characters are written. Otherwise, the
+   * character <code>s[0]</code> is written first, then <code>s[1]</code>, and so on; the last
+   * character written is <code>s[s.length-1]</code>. For each character, two bytes are actually
+   * written, high-order byte first, in exactly the manner of the <code>writeChar</code> method.
+   *
+   * @param s the string value to be written.
+   */
-//    if (logger.isTraceEnabled()) logger.trace(" chars={}", s);
+    // if (logger.isTraceEnabled()) logger.trace(" chars={}", s);
-      int remainingCharSpace = (this.buffer.capacity() - this.buffer.position())/2;
+      int remainingCharSpace = (this.buffer.capacity() - this.buffer.position()) / 2;
-        for (int i=0; i < chunkSize; i++) {
-          this.buffer.putChar(s.charAt(offset+i));
+        for (int i = 0; i < chunkSize; i++) {
+          this.buffer.putChar(s.charAt(offset + i));
-   * Use -Dgemfire.ASCII_STRINGS=true if all String instances contain
-   * ASCII characters. Setting this to true gives a performance improvement.
+   * Use -Dgemfire.ASCII_STRINGS=true if all String instances contain ASCII characters. Setting this
+   * to true gives a performance improvement.
-  private static final boolean ASCII_STRINGS = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "ASCII_STRINGS");
-  
+  private static final boolean ASCII_STRINGS =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "ASCII_STRINGS");
+
-     * Writes two bytes of length information
-     * to the output stream, followed
-     * by the Java modified UTF representation
-     * of  every character in the string <code>s</code>.
-     * If <code>s</code> is <code>null</code>,
-     * a <code>NullPointerException</code> is thrown.
-     * Each character in the string <code>s</code>
-     * is converted to a group of one, two, or
-     * three bytes, depending on the value of the
-     * character.<p>
-     * If a character <code>c</code>
-     * is in the range <code>&#92;u0001</code> through
-     * <code>&#92;u007f</code>, it is represented
-     * by one byte:<p>
-     * <pre>(byte)c </pre>  <p>
-     * If a character <code>c</code> is <code>&#92;u0000</code>
-     * or is in the range <code>&#92;u0080</code>
-     * through <code>&#92;u07ff</code>, then it is
-     * represented by two bytes, to be written
-     * in the order shown:<p> <pre><code>
-     * (byte)(0xc0 | (0x1f &amp; (c &gt;&gt; 6)))
-     * (byte)(0x80 | (0x3f &amp; c))
-     *  </code></pre>  <p> If a character
-     * <code>c</code> is in the range <code>&#92;u0800</code>
-     * through <code>uffff</code>, then it is
-     * represented by three bytes, to be written
-     * in the order shown:<p> <pre><code>
-     * (byte)(0xe0 | (0x0f &amp; (c &gt;&gt; 12)))
-     * (byte)(0x80 | (0x3f &amp; (c &gt;&gt;  6)))
-     * (byte)(0x80 | (0x3f &amp; c))
-     *  </code></pre>  <p> First,
-     * the total number of bytes needed to represent
-     * all the characters of <code>s</code> is
-     * calculated. If this number is larger than
-     * <code>65535</code>, then a <code>UTFDataFormatException</code>
-     * is thrown. Otherwise, this length is written
-     * to the output stream in exactly the manner
-     * of the <code>writeShort</code> method;
-     * after this, the one-, two-, or three-byte
-     * representation of each character in the
-     * string <code>s</code> is written.<p>  The
-     * bytes written by this method may be read
-     * by the <code>readUTF</code> method of interface
-     * <code>DataInput</code> , which will then
-     * return a <code>String</code> equal to <code>s</code>.
-     *
-     * @param      str   the string value to be written.
-     * @exception  IOException  if an I/O error occurs.
-     */
+   * Writes two bytes of length information to the output stream, followed by the Java modified UTF
+   * representation of every character in the string <code>s</code>. If <code>s</code> is
+   * <code>null</code>, a <code>NullPointerException</code> is thrown. Each character in the string
+   * <code>s</code> is converted to a group of one, two, or three bytes, depending on the value of
+   * the character.
+   * <p>
+   * If a character <code>c</code> is in the range <code>&#92;u0001</code> through
+   * <code>&#92;u007f</code>, it is represented by one byte:
+   * <p>
+   * 
+   * <pre>
+   * (byte) c
+   * </pre>
+   * <p>
+   * If a character <code>c</code> is <code>&#92;u0000</code> or is in the range
+   * <code>&#92;u0080</code> through <code>&#92;u07ff</code>, then it is represented by two bytes,
+   * to be written in the order shown:
+   * <p>
+   * 
+   * <pre>
+   * <code>
+   * (byte)(0xc0 | (0x1f &amp; (c &gt;&gt; 6)))
+   * (byte)(0x80 | (0x3f &amp; c))
+   *  </code>
+   * </pre>
+   * <p>
+   * If a character <code>c</code> is in the range <code>&#92;u0800</code> through
+   * <code>uffff</code>, then it is represented by three bytes, to be written in the order shown:
+   * <p>
+   * 
+   * <pre>
+   * <code>
+   * (byte)(0xe0 | (0x0f &amp; (c &gt;&gt; 12)))
+   * (byte)(0x80 | (0x3f &amp; (c &gt;&gt;  6)))
+   * (byte)(0x80 | (0x3f &amp; c))
+   *  </code>
+   * </pre>
+   * <p>
+   * First, the total number of bytes needed to represent all the characters of <code>s</code> is
+   * calculated. If this number is larger than <code>65535</code>, then a
+   * <code>UTFDataFormatException</code> is thrown. Otherwise, this length is written to the output
+   * stream in exactly the manner of the <code>writeShort</code> method; after this, the one-, two-,
+   * or three-byte representation of each character in the string <code>s</code> is written.
+   * <p>
+   * The bytes written by this method may be read by the <code>readUTF</code> method of interface
+   * <code>DataInput</code> , which will then return a <code>String</code> equal to <code>s</code>.
+   *
+   * @param str the string value to be written.
+   * @exception IOException if an I/O error occurs.
+   */
-//    if (logger.isTraceEnabled()) logger.trace(" utf={}", str);
+    // if (logger.isTraceEnabled()) logger.trace(" utf={}", str);
+
-          this.buffer.put((byte)str.charAt(offset+i));
+          this.buffer.put((byte) str.charAt(offset + i));
+
-      if (remainingSpace >= ((strlen*3) + 2)) {
+      if (remainingSpace >= ((strlen * 3) + 2)) {
-        writeByte((byte)c);
+        writeByte((byte) c);
-        writeByte((byte) (0x80 | ((c >>  6) & 0x3F)));
-        writeByte((byte) (0x80 | ((c >>  0) & 0x3F)));
+        writeByte((byte) (0x80 | ((c >> 6) & 0x3F)));
+        writeByte((byte) (0x80 | ((c >> 0) & 0x3F)));
-        writeByte((byte) (0xC0 | ((c >>  6) & 0x1F)));
-        writeByte((byte) (0x80 | ((c >>  0) & 0x3F)));
+        writeByte((byte) (0xC0 | ((c >> 6) & 0x1F)));
+        writeByte((byte) (0x80 | ((c >> 0) & 0x3F)));
+
-    this.buffer.position(utfSizeIdx+2);
+    this.buffer.position(utfSizeIdx + 2);
-        this.buffer.put((byte)c);
+        this.buffer.put((byte) c);
-        this.buffer.put((byte) (0x80 | ((c >>  6) & 0x3F)));
-        this.buffer.put((byte) (0x80 | ((c >>  0) & 0x3F)));
+        this.buffer.put((byte) (0x80 | ((c >> 6) & 0x3F)));
+        this.buffer.put((byte) (0x80 | ((c >> 0) & 0x3F)));
-        this.buffer.put((byte) (0xC0 | ((c >>  6) & 0x1F)));
-        this.buffer.put((byte) (0x80 | ((c >>  0) & 0x3F)));
+        this.buffer.put((byte) (0xC0 | ((c >> 6) & 0x1F)));
+        this.buffer.put((byte) (0x80 | ((c >> 0) & 0x3F)));
-    int utflen = this.buffer.position() - (utfSizeIdx+2);
+    int utflen = this.buffer.position() - (utfSizeIdx + 2);
-    this.buffer.putShort(utfSizeIdx, (short)utflen);
+    this.buffer.putShort(utfSizeIdx, (short) utflen);
-   * Attempt to fit v into the current buffer as a serialized byte array.
-   * This is done by reserving 5 bytes for the length
-   * and then starting the serialization. If all the bytes fit
-   * then the length is fixed up and we are done.
-   * If it doesn't fit then we need to serialize the remainder to a temporary
-   * HeapDataOutputStream and then fix the length flush the first chunk and
-   * then send the contents of the HeapDataOutputStream to this streamer.
-   * All of this is done to prevent an extra copy when the serialized form
-   * will all fit into our current buffer.
+   * Attempt to fit v into the current buffer as a serialized byte array. This is done by reserving
+   * 5 bytes for the length and then starting the serialization. If all the bytes fit then the
+   * length is fixed up and we are done. If it doesn't fit then we need to serialize the remainder
+   * to a temporary HeapDataOutputStream and then fix the length flush the first chunk and then send
+   * the contents of the HeapDataOutputStream to this streamer. All of this is done to prevent an
+   * extra copy when the serialized form will all fit into our current buffer.
-      HeapDataOutputStream other = (HeapDataOutputStream)v;
+      HeapDataOutputStream other = (HeapDataOutputStream) v;
-      other.sendTo((ByteBufferWriter)this);
+      other.sendTo((ByteBufferWriter) this);
-        this.overflowBuf = new HeapDataOutputStream(this.buffer.capacity()-Connection.MSG_HEADER_BYTES, Version.CURRENT);
+        this.overflowBuf = new HeapDataOutputStream(
+            this.buffer.capacity() - Connection.MSG_HEADER_BYTES, Version.CURRENT);
-      ensureCapacity(5+1024); /* need 5 bytes for length plus enough room for
-                              * an 'average' small object.
-                              * I pulled 1024 as the average out of thin air.
-                              */
+      ensureCapacity(5 + 1024); /*
+                                 * need 5 bytes for length plus enough room for an 'average' small
+                                 * object. I pulled 1024 as the average out of thin air.
+                                 */
-    this.buffer.position(lengthPos+5);
+    this.buffer.position(lengthPos + 5);
-        RuntimeException e2 = new IllegalArgumentException(LocalizedStrings.MsgStreamer_AN_EXCEPTION_WAS_THROWN_WHILE_SERIALIZING.toLocalizedString());
+        RuntimeException e2 = new IllegalArgumentException(
+            LocalizedStrings.MsgStreamer_AN_EXCEPTION_WAS_THROWN_WHILE_SERIALIZING
+                .toLocalizedString());
-      int baLength = this.buffer.position()-(lengthPos+5);
+      int baLength = this.buffer.position() - (lengthPos + 5);
-      this.buffer.putInt(lengthPos+1, baLength);
+      this.buffer.putInt(lengthPos + 1, baLength);
-        overBuf.sendTo((ByteBufferWriter)this);
+        overBuf.sendTo((ByteBufferWriter) this);
-  
+

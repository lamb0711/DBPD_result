Merge branch 'develop' into feature/GEODE-6187

-import java.io.PrintWriter;
+import java.io.IOException;
-import java.io.StringWriter;
+import java.rmi.NotBoundException;
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.internal.logging.LogService;
-import org.apache.geode.test.dunit.internal.BounceResult;
+import org.apache.geode.test.dunit.internal.ChildVMLauncher;
+import org.apache.geode.test.dunit.internal.ProcessHolder;
+  private static final Logger logger = LogService.getLogger();
+
+  private transient volatile ProcessHolder processHolder;
+
+  private transient ChildVMLauncher childVMLauncher;
+
-  public VM(final Host host, final int id, final RemoteDUnitVMIF client) {
-    this(host, VersionManager.CURRENT_VERSION, id, client);
+  public VM(final Host host, final int id, final RemoteDUnitVMIF client,
+      final ProcessHolder processHolder, final ChildVMLauncher childVMLauncher) {
+    this(host, VersionManager.CURRENT_VERSION, id, client, processHolder, childVMLauncher);
-  public VM(final Host host, final String version, final int id, final RemoteDUnitVMIF client) {
+  public VM(final Host host, final String version, final int id, final RemoteDUnitVMIF client,
+      final ProcessHolder processHolder, final ChildVMLauncher childVMLauncher) {
+    this.processHolder = processHolder;
+    this.childVMLauncher = childVMLauncher;
-    return invoke(targetClass, methodName, new Object[0]);
+    checkAvailability(targetClass.getName(), methodName);
+    return executeMethodOnClass(targetClass, methodName, new Object[0]);
-    if (!available) {
-      throw new RMIException(this, targetClass.getName(), methodName,
-          new IllegalStateException("VM not available: " + this));
-    }
-
-    MethodInvokerResult result = execute(targetClass, methodName, args);
-
-    if (!result.exceptionOccurred()) {
-      return (V) result.getResult();
-
-    } else {
-      throw new RMIException(this, targetClass.getName(), methodName, result.getException(),
-          result.getStackTrace());
-    }
+    checkAvailability(targetClass.getName(), methodName);
+    return executeMethodOnClass(targetClass, methodName, args);
-    invoke(new NamedRunnable(name, runnable), "run");
+    checkAvailability(NamedRunnable.class.getName(), "run");
+    executeMethodOnObject(new NamedRunnable(name, runnable), "run", new Object[0]);
-    invoke(runnable, "run");
+    checkAvailability(runnable.getClass().getName(), "run");
+    executeMethodOnObject(runnable, "run", new Object[0]);
-    return invoke(new NamedCallable<>(name, callable), "call");
+    checkAvailability(NamedCallable.class.getName(), "call");
+    return executeMethodOnObject(new NamedCallable<>(name, callable), "call", new Object[0]);
-    return invoke(callable, "call");
+    checkAvailability(callable.getClass().getName(), "call");
+    return executeMethodOnObject(callable, "call", new Object[0]);
-    return invoke(targetObject, methodName, new Object[0]);
+    checkAvailability(targetObject.getClass().getName(), methodName);
+    return executeMethodOnObject(targetObject, methodName, new Object[0]);
-    if (!available) {
-      throw new RMIException(this, targetObject.getClass().getName(), methodName,
-          new IllegalStateException("VM not available: " + this));
-    }
-
-    MethodInvokerResult result = execute(targetObject, methodName, args);
-
-    if (!result.exceptionOccurred()) {
-      return (V) result.getResult();
-
-    } else {
-      throw new RMIException(this, targetObject.getClass().getName(), methodName,
-          result.getException(), result.getStackTrace());
-    }
+    checkAvailability(targetObject.getClass().getName(), methodName);
+    return executeMethodOnObject(targetObject, methodName, args);
-    if (!available) {
-      throw new RMIException(this, getClass().getName(), "bounceVM",
-          new IllegalStateException("VM not available: " + this));
-    }
+    checkAvailability(getClass().getName(), "bounceVM");
+    logger.info("Bouncing {} old pid is {}", id, getPid());
-
-      BounceResult result = DUnitEnv.get().bounce(targetVersion, id, force);
-      id = result.getNewId();
-      client = result.getNewClient();
+      if (force) {
+        processHolder.killForcibly();
+      } else {
+        SerializableRunnableIF runnable = () -> new Thread(() -> {
+          try {
+            // sleep before exit so that the rmi call is returned
+            Thread.sleep(100);
+            System.exit(0);
+          } catch (InterruptedException e) {
+            logger.error("VM bounce thread interrupted before exiting.", e);
+          }
+        }).start();
+        executeMethodOnObject(runnable, "run", new Object[0]);
+      }
+      processHolder.waitFor();
+      processHolder = childVMLauncher.launchVM(targetVersion, id, true);
+      client = childVMLauncher.getStub(id);
+      logger.info("Bounced {} new pid is {}", id, getPid());
+    } catch (InterruptedException | IOException | NotBoundException e) {
+      throw new Error("Unable to restart VM " + id, e);
+    }
+  }
-    } catch (UnsupportedOperationException e) {
-      available = true;
-      throw e;
-
-    } catch (RemoteException e) {
-      StringWriter sw = new StringWriter();
-      e.printStackTrace(new PrintWriter(sw, true));
-      throw new RMIException(this, getClass().getName(), "bounceVM", e, sw.toString());
+  private void checkAvailability(String className, String methodName) {
+    if (!available) {
+      throw new RMIException(this, className, methodName,
+          new IllegalStateException("VM not available: " + this));
-  private MethodInvokerResult execute(final Class<?> targetClass, final String methodName,
+  private <V> V executeMethodOnObject(final Object targetObject, final String methodName,
-      return client.executeMethodOnClass(targetClass.getName(), methodName, args);
-    } catch (RemoteException exception) {
-      throw new RMIException(this, targetClass.getName(), methodName, exception);
-    }
-  }
-
-  private MethodInvokerResult execute(final Object targetObject, final String methodName,
-      final Object[] args) {
-    try {
-      if (args == null) {
-        return client.executeMethodOnObject(targetObject, methodName);
-      } else {
-        return client.executeMethodOnObject(targetObject, methodName, args);
+      MethodInvokerResult result = client.executeMethodOnObject(targetObject, methodName, args);
+      if (result.exceptionOccurred()) {
+        throw new RMIException(this, targetObject.getClass().getName(), methodName,
+            result.getException(), result.getStackTrace());
+      return (V) result.getResult();
+  private <V> V executeMethodOnClass(final Class<?> targetClass, final String methodName,
+      final Object[] args) {
+    try {
+      MethodInvokerResult result =
+          client.executeMethodOnClass(targetClass.getName(), methodName, args);
+      if (result.exceptionOccurred()) {
+        throw new RMIException(this, targetClass.getName(), methodName, result.getException(),
+            result.getStackTrace());
+      }
+      return (V) result.getResult();
+    } catch (RemoteException exception) {
+      throw new RMIException(this, targetClass.getName(), methodName, exception);
+    }
+  }

Merge branch 'develop' into feature/GEODE-1801

-import org.apache.geode.redis.GeodeRedisServer;
+import org.apache.commons.lang.StringUtils;
+import org.apache.geode.GemFireConfigException;
-import org.apache.geode.cache.CacheRuntimeException;
+import org.apache.geode.distributed.ConfigurationProperties;
+import org.apache.geode.distributed.internal.SharedConfiguration;
-import org.apache.geode.internal.net.SocketCreator;
+import org.apache.geode.internal.security.SecurityService;
+import org.apache.geode.management.internal.configuration.domain.Configuration;
+import org.apache.geode.redis.GeodeRedisServer;
+  private static SecurityService securityService = SecurityService.getSecurityService();
+
-   * Applies the shared configuration to this cache, only if its a GEMFIRE && NON-LOCATOR && NON-CLIENT cache 
-  public void requestAndApplySharedConfiguration() {
+  public ConfigurationResponse requestSharedConfiguration() {
-    if (dm instanceof DistributionManager) {
-      if (((DistributionManager) dm).getDMType() != DistributionManager.LOCATOR_DM_TYPE
-          && !isClient
-          && Locator.getLocator() == null
-          ) {
-        
-        boolean useSharedConfiguration = config.getUseSharedConfiguration();
+    if (!(dm instanceof DistributionManager))
+      return null;
-        if (useSharedConfiguration) {
-          Map<InternalDistributedMember, Collection<String>> scl = this.getDistributionManager().getAllHostedLocatorsWithSharedConfiguration();
+    // do nothing if this vm is/has locator or this is a client
+    if( ((DistributionManager)dm).getDMType() == DistributionManager.LOCATOR_DM_TYPE
+      || isClient
+      || Locator.getLocator() !=null )
+      return null;
-          //If there are no locators with Shared configuration, that means the system has been started without shared configuration 
-          //then do not make requests to the locators
-          if (!scl.isEmpty()) {
-            String groupsString = config.getGroups();
-            ConfigurationResponse response = null;
-            List<String> locatorConnectionStrings = getSharedConfigLocatorConnectionStringList();
-            
-            try {
-              response = ClusterConfigurationLoader.requestConfigurationFromLocators(ClusterConfigurationLoader.getGroups(groupsString), locatorConnectionStrings);
+    Map<InternalDistributedMember, Collection<String>> scl = this.getDistributionManager().getAllHostedLocatorsWithSharedConfiguration();
-              //log the configuration received from the locator
-              logger.info(LocalizedMessage.create(LocalizedStrings.GemFireCache_RECEIVED_SHARED_CONFIGURATION_FROM_LOCATORS));
-              logger.info(response.describeConfig());
-              
-              //deploy the Jars
-              ClusterConfigurationLoader.deployJarsReceivedFromClusterConfiguration(this, response);
+    //If there are no locators with Shared configuration, that means the system has been started without shared configuration
+    //then do not make requests to the locators
+    if(scl.isEmpty()) {
+      logger.info(LocalizedMessage.create(LocalizedStrings.GemFireCache_NO_LOCATORS_FOUND_WITH_SHARED_CONFIGURATION));
+      return null;
+    }
-              //Apply the xml configuration 
-              ClusterConfigurationLoader.applyClusterConfiguration(this, response, ClusterConfigurationLoader.getGroups(groupsString));
+    String groupsString = config.getGroups();
+    ConfigurationResponse response = null;
+    List<String> locatorConnectionStrings = getSharedConfigLocatorConnectionStringList();
-            } catch (ClusterConfigurationNotAvailableException e) {
-              throw new CacheRuntimeException(LocalizedStrings.GemFireCache_SHARED_CONFIGURATION_NOT_AVAILABLE.toLocalizedString(), e) {
-                private static final long serialVersionUID = 1L;
-              };
-            } catch (IOException e) {
-              throw new CacheRuntimeException(LocalizedStrings.GemFireCache_EXCEPTION_OCCURED_WHILE_DEPLOYING_JARS_FROM_SHARED_CONDFIGURATION.toLocalizedString(), e) {
-                private static final long serialVersionUID = 1L;
-              };      
-            } catch (ClassNotFoundException e) {
-              throw new CacheRuntimeException(LocalizedStrings.GemFireCache_EXCEPTION_OCCURED_WHILE_DEPLOYING_JARS_FROM_SHARED_CONDFIGURATION.toLocalizedString(), e) {
-                private static final long serialVersionUID = 1L;
-              };
-            }
-          } else {
-            logger.info(LocalizedMessage.create(LocalizedStrings.GemFireCache_NO_LOCATORS_FOUND_WITH_SHARED_CONFIGURATION));
-          }
+    try {
+      response = ClusterConfigurationLoader.requestConfigurationFromLocators(system.getConfig(), locatorConnectionStrings);
+
+      //log the configuration received from the locator
+      logger.info(LocalizedMessage.create(LocalizedStrings.GemFireCache_RECEIVED_SHARED_CONFIGURATION_FROM_LOCATORS));
+      logger.info(response.describeConfig());
+
+      Configuration clusterConfig = response.getRequestedConfiguration().get(SharedConfiguration.CLUSTER_CONFIG);
+      Properties clusterSecProperties = (clusterConfig==null) ? new Properties():clusterConfig.getGemfireProperties();
+
+      // If not using shared configuration, return null or throw an exception is locator is secured
+      if(!config.getUseSharedConfiguration()){
+        if (clusterSecProperties.containsKey(ConfigurationProperties.SECURITY_MANAGER)) {
+          throw new GemFireConfigException(LocalizedStrings.GEMFIRE_CACHE_SECURITY_MISCONFIGURATION_2.toLocalizedString());
+          return null;
+
+      Properties serverSecProperties = config.getSecurityProps();
+      //check for possible mis-configuration
+      if (isMisConfigured(clusterSecProperties, serverSecProperties, ConfigurationProperties.SECURITY_MANAGER)
+       || isMisConfigured(clusterSecProperties, serverSecProperties, ConfigurationProperties.SECURITY_POST_PROCESSOR)) {
+        throw new GemFireConfigException(LocalizedStrings.GEMFIRE_CACHE_SECURITY_MISCONFIGURATION.toLocalizedString());
+      }
+      return response;
+
+    } catch (ClusterConfigurationNotAvailableException e) {
+      throw new GemFireConfigException(LocalizedStrings.GemFireCache_SHARED_CONFIGURATION_NOT_AVAILABLE.toLocalizedString(), e);
+    } catch (UnknownHostException e) {
+      throw new GemFireConfigException(e.getLocalizedMessage(), e);
-  
+
+  public void deployJarsRecevedFromClusterConfiguration(ConfigurationResponse response){
+    try{
+      ClusterConfigurationLoader.deployJarsReceivedFromClusterConfiguration(this, response);
+    } catch (IOException e) {
+      throw new GemFireConfigException(LocalizedStrings.GemFireCache_EXCEPTION_OCCURED_WHILE_DEPLOYING_JARS_FROM_SHARED_CONDFIGURATION.toLocalizedString(), e);
+    } catch (ClassNotFoundException e) {
+      throw new GemFireConfigException(LocalizedStrings.GemFireCache_EXCEPTION_OCCURED_WHILE_DEPLOYING_JARS_FROM_SHARED_CONDFIGURATION.toLocalizedString(), e);
+    }
+  }
+
+
+  // When called, clusterProps and serverProps and key could not be null
+  public static boolean isMisConfigured(Properties clusterProps, Properties serverProps, String key){
+    String clusterPropValue = clusterProps.getProperty(key);
+    String serverPropValue = serverProps.getProperty(key);
+
+    // if this server prop is not specified, this is always OK.
+    if(StringUtils.isBlank(serverPropValue))
+      return false;
+
+    // server props is not blank, but cluster props is blank, NOT OK.
+    if(StringUtils.isBlank(clusterPropValue))
+      return true;
+
+    // at this point check for eqality
+    return !clusterPropValue.equals(serverPropValue);
+  }
+
+
+    //request and check cluster configuration
+    ConfigurationResponse configurationResponse = requestSharedConfiguration();
+    deployJarsRecevedFromClusterConfiguration(configurationResponse);
+
+    // apply the cluster's properties configuration and initialize security using that configuration
+    ClusterConfigurationLoader.applyClusterPropertiesConfiguration(this, configurationResponse, system.getConfig());
+    securityService.initSecurity(system.getConfig().getSecurityProps());
-    
+
-    this.jmxAdvisor.initializationGate();  
+    this.jmxAdvisor.initializationGate();
+
+    // this starts up the ManagementService, register and federate the internal beans
-    
-    
+
-    
+
-      requestAndApplySharedConfiguration();
+      ClusterConfigurationLoader.applyClusterXmlConfiguration(this, configurationResponse, system.getConfig());
+    securityService.close();
+

Merge branch 'release/1.4.0'

+import joptsimple.internal.Strings;
-import org.apache.geode.cache.execute.FunctionAdapter;
+import org.apache.geode.cache.execute.Function;
-import org.apache.geode.management.internal.cli.CliUtil;
-public class GatewayReceiverCreateFunction extends FunctionAdapter implements InternalEntity {
+public class GatewayReceiverCreateFunction implements Function, InternalEntity {
-    String memberNameOrId =
-        CliUtil.getMemberNameOrId(cache.getDistributedSystem().getDistributedMember());
+    String memberNameOrId = context.getMemberName();
-
-
-      resultSender.lastResult(handleException(memberNameOrId, e.getMessage(), e));
+      // no need to log the stack trace
+      resultSender.lastResult(new CliFunctionResult(memberNameOrId, e, e.getMessage()));
-      String exceptionMsg = e.getMessage();
-      if (exceptionMsg == null) {
-        exceptionMsg = CliUtil.stackTraceAsString(e);
-      }
-      resultSender.lastResult(handleException(memberNameOrId, exceptionMsg, e));
+      logger.error(e.getMessage(), e);
+      resultSender.lastResult(new CliFunctionResult(memberNameOrId, e, e.getMessage()));
-  private CliFunctionResult handleException(final String memberNameOrId, final String exceptionMsg,
-      final Exception e) {
-    if (e != null && logger.isDebugEnabled()) {
-      logger.debug(e.getMessage(), e);
-    }
-    if (exceptionMsg != null) {
-      return new CliFunctionResult(memberNameOrId, false, exceptionMsg);
-    }
-
-    return new CliFunctionResult(memberNameOrId);
-  }
-
-   * 
+   *
-  private static GatewayReceiver createGatewayReceiver(Cache cache,
-      GatewayReceiverFunctionArgs gatewayReceiverCreateArgs) {
+  GatewayReceiver createGatewayReceiver(Cache cache,
+      GatewayReceiverFunctionArgs gatewayReceiverCreateArgs)
+      throws IllegalAccessException, InstantiationException, ClassNotFoundException {
-        Class gatewayTransportFilterKlass = forName(gatewayTransportFilter,
-            CliStrings.CREATE_GATEWAYRECEIVER__GATEWAYTRANSPORTFILTER);
-            (GatewayTransportFilter) newInstance(gatewayTransportFilterKlass,
-                CliStrings.CREATE_GATEWAYRECEIVER__GATEWAYTRANSPORTFILTER));
+            (GatewayTransportFilter) newInstance(gatewayTransportFilter));
-  @SuppressWarnings("unchecked")
-  private static Class forName(String classToLoadName, String neededFor) {
-    Class loadedClass = null;
-    try {
-      // Set Constraints
-      ClassPathLoader classPathLoader = ClassPathLoader.getLatest();
-      if (classToLoadName != null && !classToLoadName.isEmpty()) {
-        loadedClass = classPathLoader.forName(classToLoadName);
-      }
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException(
-          CliStrings.format(CliStrings.CREATE_REGION__MSG__COULD_NOT_FIND_CLASS_0_SPECIFIED_FOR_1,
-              classToLoadName, neededFor),
-          e);
-    } catch (ClassCastException e) {
-      throw new RuntimeException(CliStrings.format(
-          CliStrings.CREATE_REGION__MSG__CLASS_SPECIFIED_FOR_0_SPECIFIED_FOR_1_IS_NOT_OF_EXPECTED_TYPE,
-          classToLoadName, neededFor), e);
+
+  private Object newInstance(String className)
+      throws ClassNotFoundException, IllegalAccessException, InstantiationException {
+    if (Strings.isNullOrEmpty(className)) {
+      return null;
-    return loadedClass;
-  }
-
-  private static Object newInstance(Class klass, String neededFor) {
-    Object instance = null;
-    try {
-      instance = klass.newInstance();
-    } catch (InstantiationException e) {
-      throw new RuntimeException(CliStrings.format(
-          CliStrings.CREATE_GATEWAYSENDER__MSG__COULD_NOT_INSTANTIATE_CLASS_0_SPECIFIED_FOR_1,
-          klass, neededFor), e);
-    } catch (IllegalAccessException e) {
-      throw new RuntimeException(CliStrings.format(
-          CliStrings.CREATE_GATEWAYSENDER__MSG__COULD_NOT_ACCESS_CLASS_0_SPECIFIED_FOR_1, klass,
-          neededFor), e);
-    }
-    return instance;
+    return ClassPathLoader.getLatest().forName(className).newInstance();

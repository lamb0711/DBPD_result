Merge pull request #2376 from jujoramos/feature/GEODE-5353

GEODE-5353: gfsh hint should be case independent
- Added integration tests for `gfsh hint` command.
- Removed some minor warnings from the `Helper` class.
- Replaced the internal `HashMap` containing the `topics` for a
  `TreeMap` with the `String.CASE_INSENSITIVE_ORDER` comparator.
-  static final String REQUIRED_SUB_NAME = "Required: ";
-  static final String SYNONYMS_SUB_NAME = "Synonyms: ";
-  static final String SPECIFIEDDEFAULTVALUE_SUB_NAME =
+  private static final String REQUIRED_SUB_NAME = "Required: ";
+  private static final String SYNONYMS_SUB_NAME = "Synonyms: ";
+  private static final String SPECIFIEDDEFAULTVALUE_SUB_NAME =
-  static final String UNSPECIFIEDDEFAULTVALUE_VALUE_SUB_NAME =
+  private static final String UNSPECIFIEDDEFAULTVALUE_VALUE_SUB_NAME =
-  static final String VALUE_FIELD = "value";
-  static final String TRUE_TOKEN = "true";
-  static final String FALSE_TOKEN = "false";
-  static final String AVAILABLE = "Available";
-  static final String NOT_AVAILABLE = "Not Available";
+  private static final String VALUE_FIELD = "value";
+  private static final String TRUE_TOKEN = "true";
+  private static final String FALSE_TOKEN = "false";
+  private static final String AVAILABLE = "Available";
+  private static final String NOT_AVAILABLE = "Not Available";
-  private final Map<String, Topic> topics = new HashMap<>();
-  private final Map<String, Method> commands = new TreeMap<String, Method>();
-  private final Map<String, MethodTarget> availabilityIndicators =
-      new HashMap<String, MethodTarget>();
+  private final Map<String, Topic> topics = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
+  private final Map<String, Method> commands = new TreeMap<>();
+  private final Map<String, MethodTarget> availabilityIndicators = new HashMap<>();
-    Arrays.stream(command.value()).forEach(cmd -> {
-      commands.put(cmd, commandMethod);
-    });
+    Arrays.stream(command.value()).forEach(cmd -> commands.put(cmd, commandMethod));
-    Arrays.stream(availability.value()).forEach(command -> {
-      availabilityIndicators.put(command, target);
-    });
+    Arrays.stream(availability.value())
+        .forEach(command -> availabilityIndicators.put(command, target));
-  boolean isAvailable(String command) {
+  private boolean isAvailable(String command) {
-    commands.keySet().stream().sorted().map(commands::get).forEach(method -> {
-      root.addChild(getHelp(method.getDeclaredAnnotation(CliCommand.class), null, null));
-    });
+    commands.keySet().stream().sorted().map(commands::get).forEach(method -> root
+        .addChild(getHelp(method.getDeclaredAnnotation(CliCommand.class), null, null)));
+
-      for (int i = 0; i < annotations.length; i++) {
-        CliOption cliOption = getAnnotation(annotations[i], CliOption.class);
+      for (Annotation[] annotation : annotations) {
+        CliOption cliOption = getAnnotation(annotation, CliOption.class);
+
-    StringBuffer buffer = new StringBuffer();
+    StringBuilder buffer = new StringBuilder();
-    StringBuffer buffer = new StringBuffer();
+    StringBuilder buffer = new StringBuilder();

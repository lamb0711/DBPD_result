GEODE-6862: Extract Patterns from LogConsumer

* Use System.lineSeparator instead of "\n"
* Make more fields final
* Reorder fields
* Move public methods to top of methods
* Rename some fields and variables

+import static java.lang.System.lineSeparator;
+import static java.util.regex.Pattern.compile;
+import static org.apache.geode.test.greplogs.Patterns.BLANK;
+import static org.apache.geode.test.greplogs.Patterns.CAUSED_BY;
+import static org.apache.geode.test.greplogs.Patterns.DEBUG_WROTE_EXCEPTION;
+import static org.apache.geode.test.greplogs.Patterns.ERROR_OR_MORE_LOG_LEVEL;
+import static org.apache.geode.test.greplogs.Patterns.ERROR_SHORT_NAME;
+import static org.apache.geode.test.greplogs.Patterns.EXCEPTION;
+import static org.apache.geode.test.greplogs.Patterns.EXCEPTION_2;
+import static org.apache.geode.test.greplogs.Patterns.EXCEPTION_3;
+import static org.apache.geode.test.greplogs.Patterns.EXCEPTION_4;
+import static org.apache.geode.test.greplogs.Patterns.IGNORED_EXCEPTION;
+import static org.apache.geode.test.greplogs.Patterns.JAVA_LANG_ERROR;
+import static org.apache.geode.test.greplogs.Patterns.LOG_STATEMENT;
+import static org.apache.geode.test.greplogs.Patterns.MISFORMATTED_I18N_MESSAGE;
+import static org.apache.geode.test.greplogs.Patterns.RMI_WARNING;
+import static org.apache.geode.test.greplogs.Patterns.RVV_BIT_SET_MESSAGE;
+import static org.apache.geode.test.greplogs.Patterns.WARN_OR_LESS_LOG_LEVEL;
+
+import java.util.Collection;
-import java.util.List;
+import java.util.Map;
+import java.util.regex.MatchResult;
-  private final List<Pattern> expectedExceptions = new ArrayList<>();
-  private boolean skipLogMsgs = false;
-  private boolean infoMsgFlag = false;
-  private int eatLines = 0;
-  private boolean tmpErrFlag = false;
-  private int tmpErrLines = 0;
-  private boolean saveFlag = false;
-  private int savelinenum = 0;
-  private final List<Pattern> testExpectStrs;
-  private StringBuilder all = null;
-  private int lineNumber;
-  private String fileName;
-  private HashMap<String, Integer> individualErrorCount = new HashMap<>();
-  private final int repeatLimit;
-  private static final Pattern ExpectedExceptionPattern =
-      Pattern.compile("<ExpectedException action=(add|remove)>(.*)</ExpectedException>");
-  private static final Pattern logPattern =
-      Pattern.compile("^\\[(?:fatal|error|warn|info|debug|trace|severe|warning|fine|finer|finest)");
-  private static final Pattern blankPattern = Pattern.compile("^\\s*$");
-  /**
-   * Any messages at these levels will be skipped
-   */
-  private static final Pattern skipLevelPattern =
-      Pattern.compile("^\\[(?:warn|warning|info|debug|trace|fine|finer|finest)");
-  private static final Pattern fatalOrErrorPattern = Pattern.compile("^\\[(?:fatal|error|severe)");
-  private static final Pattern causedByPattern = Pattern.compile("Caused by");
-  private static final Pattern shortErrPattern =
-      Pattern.compile("^\\[[^\\]]+\\](.*)$", Pattern.MULTILINE | Pattern.DOTALL);
-  private static final Pattern wroteExceptionPattern =
-      Pattern.compile("\\[debug.*Wrote exception:");
-  private static final Pattern rmiWarnPattern = Pattern.compile(
-      "^WARNING: Failed to .*java.rmi.ConnectException: Connection refused to host: .*; nested exception is:");
-  private static final Pattern javaLangErrorPattern = Pattern.compile("^java\\.lang\\.\\S+Error$");
-  private static final Pattern exceptionPattern = Pattern.compile("Exception:");
-  private static final Pattern exceptionPattern2 =
-      Pattern.compile("( [\\w\\.]+Exception: (([\\S]+ ){0,6}))");
-  private static final Pattern exceptionPattern3 = Pattern.compile("( [\\w\\.]+Exception)$");
-  private static final Pattern exceptionPattern4 = Pattern.compile("^([^:]+: (([\\w\"]+ ){0,6}))");
-  private static final Pattern misformatedI18nMessagePattern = Pattern.compile("[^\\d]\\{\\d+\\}");
-  private static final Pattern rvvBitSetMessagePattern =
-      Pattern.compile("RegionVersionVector.+bsv\\d+.+bs=\\{\\d+\\}");
-  private static int ERROR_BUFFER_LIMIT = 128;
+  private static final int ERROR_BUFFER_LIMIT = 128;
+  private final String logName;
+  private final Collection<Pattern> dynamicIgnoredPatterns = new ArrayList<>();
+  private final Collection<Pattern> constantIgnoredPatterns = new ArrayList<>();
+  private final boolean enableLogLevelThreshold;
+  private final int skipLimit;
+  private final Map<String, Integer> individualErrorCount = new HashMap<>();
-  public LogConsumer(boolean skipLogMsgs, List<Pattern> testExpectStrs, String fileName,
+  private boolean infoMsgFlag;
+  private int eatLines;
+  private boolean tmpErrFlag;
+  private int tmpErrLines;
+  private boolean saveFlag;
+  private int savelinenum;
+  private StringBuilder all;
+  private int lineNumber;
+
+  public LogConsumer(boolean enableLogLevelThreshold, Collection<Pattern> constantIgnoredPatterns,
+      String logName,
-    super();
-    this.skipLogMsgs = skipLogMsgs;
-    this.testExpectStrs = testExpectStrs;
-    this.fileName = fileName;
-    this.repeatLimit = repeatLimit;
+    this.enableLogLevelThreshold = enableLogLevelThreshold;
+    this.constantIgnoredPatterns.addAll(constantIgnoredPatterns);
+    this.logName = logName;
+    this.skipLimit = repeatLimit;
-    Matcher expectedExceptionMatcher = ExpectedExceptionPattern.matcher(line);
+    Matcher expectedExceptionMatcher = IGNORED_EXCEPTION.matcher(line);
-    if (skipLogMsgs && skipThisLogMsg(line)) {
+    if (enableLogLevelThreshold && skipLine(line)) {
-    if (saveFlag || fatalOrErrorPattern.matcher(line).find()) {
+    if (saveFlag || ERROR_OR_MORE_LOG_LEVEL.matcher(line).find()) {
-        if (!causedByPattern.matcher(line).find() && checkExpectedStrs(line, expectedExceptions)) {
+        if (!CAUSED_BY.matcher(line).find() && matchesIgnoredPatterns(line)) {
-        if (blankPattern.matcher(line).matches()) {
+        if (BLANK.matcher(line).matches()) {
+
+
-      if (!checkExpectedStrs(line, expectedExceptions)) {
+      if (!matchesIgnoredPatterns(line)) {
+  public StringBuilder close() {
+    if (saveFlag) {
+      saveFlag = false;
+      return enforceErrorLimit(1, all.toString(), savelinenum, logName);
+    }
+    return null;
+  }
+
-    return wroteExceptionPattern.matcher(line).find() || rmiWarnPattern.matcher(line).find();
+    return DEBUG_WROTE_EXCEPTION.matcher(line).find() || RMI_WARNING.matcher(line).find();
-    // along with the next six words and define to shortline
-    // shortline is only used for the unique sting to count the
+    // along with the next six words and define to shortName
+
+    // shortName is only used for the unique string to count the
+
-      int occurrences = (i == null) ? 1 : i + 1;
+      int occurrences = i == null ? 1 : i + 1;
-      return enforceErrorLimit(occurrences, line + "\n", lineNumber, fileName);
-    } else {
-      return enforceErrorLimit(1, line + "\n", lineNumber, fileName);
+      return enforceErrorLimit(occurrences, line + lineSeparator(), lineNumber, logName);
+
+    return enforceErrorLimit(1, line + lineSeparator(), lineNumber, logName);
-    return exceptionPattern.matcher(line).find()
-        || javaLangErrorPattern.matcher(line).find()
-        || (misformatedI18nMessagePattern.matcher(line).find()
-            && !(skipLevelPattern.matcher(line).find()
-                && rvvBitSetMessagePattern.matcher(line).find()));
+    return EXCEPTION.matcher(line).find() ||
+        JAVA_LANG_ERROR.matcher(line).find() ||
+        MISFORMATTED_I18N_MESSAGE.matcher(line).find() &&
+            !(WARN_OR_LESS_LOG_LEVEL.matcher(line).find()
+                && RVV_BIT_SET_MESSAGE.matcher(line).find());
-      all.append(line).append("\n");
+      all.append(line).append(lineSeparator());
-          .append(" the error was too long to display completely.\n");
+          .append(" the error was too long to display completely.").append(lineSeparator());
-    Matcher shortErrMatcher = shortErrPattern.matcher(all.toString());
+
+    Matcher shortErrMatcher = ERROR_SHORT_NAME.matcher(all.toString());
-      int occurrences = (i == null) ? 1 : i + 1;
+      int occurrences = i == null ? 1 : i + 1;
-      return enforceErrorLimit(occurrences, all.toString(), savelinenum, fileName);
-
-    } else {
-      // error in determining shortName, wing it
-      return enforceErrorLimit(1, all.toString(), lineNumber, fileName);
+      return enforceErrorLimit(occurrences, all.toString(), savelinenum, logName);
+
+    // error in determining shortName, wing it
+    return enforceErrorLimit(1, all.toString(), lineNumber, logName);
-    if (checkExpectedStrs(line, expectedExceptions)) {
+    if (matchesIgnoredPatterns(line)) {
-      all.append("\n");
+      all.append(lineSeparator());
-    Matcher m2 = exceptionPattern2.matcher(line);
-    if (m2.find()) {
-      return m2.group(1);
+    Matcher exception2Matcher = EXCEPTION_2.matcher(line);
+    if (exception2Matcher.find()) {
+      return exception2Matcher.group(1);
-    Matcher m3 = exceptionPattern3.matcher(line);
-    if (m3.find()) {
-      return m3.group(1);
+    Matcher exception3Matcher = EXCEPTION_3.matcher(line);
+    if (exception3Matcher.find()) {
+      return exception3Matcher.group(1);
-    Matcher m4 = exceptionPattern4.matcher(line);
-    if (m4.find()) {
-      return m4.group(1);
+    Matcher exception4Matcher = EXCEPTION_4.matcher(line);
+    if (exception4Matcher.find()) {
+      return exception4Matcher.group(1);
-  private boolean skipThisLogMsg(CharSequence line) {
+  private boolean skipLine(CharSequence line) {
-      if (logPattern.matcher(line).find()) {
+      if (LOG_STATEMENT.matcher(line).find()) {
-      } else if (blankPattern.matcher(line).matches()) {
-        infoMsgFlag = false;
-        return true;
+        if (BLANK.matcher(line).matches()) {
+          infoMsgFlag = false;
+        }
-    if (skipLevelPattern.matcher(line).find()) {
+    if (WARN_OR_LESS_LOG_LEVEL.matcher(line).find()) {
-  private void expectedExceptionMatcherHandler(Matcher expectedExceptionMatcher) {
+  private void expectedExceptionMatcherHandler(MatchResult expectedExceptionMatcher) {
-      expectedExceptions.add(Pattern.compile(expectedExceptionMatcher.group(2)));
+      dynamicIgnoredPatterns.add(compile(expectedExceptionMatcher.group(2)));
-      expectedExceptions.remove(Pattern.compile(expectedExceptionMatcher.group(2)));
+      dynamicIgnoredPatterns.remove(compile(expectedExceptionMatcher.group(2)));
-  public StringBuilder close() {
-    if (saveFlag) {
-      // Bug fix for severe that occurs at the end of a log file. Since we
-      // collect lines up to a blank line that never happens this prints the
-      // collection of in process suspect strings if we close the file and
-      // we're still trying to save lines
-
-      saveFlag = false;
-      return enforceErrorLimit(1, all.toString(), savelinenum, fileName);
-    }
-    return null;
-  }
-
-  private boolean checkExpectedStrs(CharSequence line, List<Pattern> expectedExceptions) {
-    return expectedExceptions.stream().anyMatch(expected -> expected.matcher(line).find())
-        || testExpectStrs.stream().anyMatch(testExpected -> testExpected.matcher(line).find());
+  private boolean matchesIgnoredPatterns(CharSequence line) {
+    return dynamicIgnoredPatterns.stream().anyMatch(p -> p.matcher(line).find()) ||
+        constantIgnoredPatterns.stream().anyMatch(p -> p.matcher(line).find());
-    if (hits < repeatLimit) {
-      StringBuilder buffer = new StringBuilder();
-      buffer.append("-----------------------------------------------------------------------\n")
+    if (hits < skipLimit) {
+      StringBuilder string = new StringBuilder();
+      string
+          .append("-----------------------------------------------------------------------")
+          .append(lineSeparator())
-          .append("\n\n").append(line).append("\n");
-      return buffer;
+          .append(lineSeparator()).append(lineSeparator())
+          .append(line).append(lineSeparator());
+      return string;
-    if (hits == repeatLimit) {
-      StringBuilder buffer = new StringBuilder();
-      buffer.append("\n\nHit occurrence limit of ").append(hits).append(" for this string.\n")
-          .append("Further reporting of this type of error will be suppressed.\n");
-      return buffer;
+
+    if (hits == skipLimit) {
+      StringBuilder string = new StringBuilder();
+      string
+          .append(lineSeparator()).append(lineSeparator())
+          .append("Hit occurrence limit of ").append(hits).append(" for this string.")
+          .append(lineSeparator())
+          .append("Further reporting of this type of error will be suppressed.")
+          .append(lineSeparator());
+      return string;
-

GEODE-2632: change dependencies on GemFireCacheImpl to InternalCache

* misc cleanup of code where possible

-
-import org.apache.geode.cache.Cache;
+import org.apache.logging.log4j.Logger;
+
+import org.apache.geode.internal.cache.InternalCache;
+import org.apache.geode.internal.logging.LogService;
-// @todo Extend to support the keys or entries of a region.
+  private static final Logger logger = LogService.getLogger();
-      // boolean incrementOuter = true;
-        // if (incrementOuter) {
-        // }
+        // TODO: eliminate all labels
-            // Asif :The outer key is smaller than the inner key. That means
+            // The outer key is smaller than the inner key. That means
-            // Asif : The outer key is greater than inner key , so increment the
+            // The outer key is greater than inner key , so increment the
-   * @param entry
-   * @param context
-   * @param indexInfo
-   * @param keyVal
-   * @throws FunctionDomainException
-   * @throws TypeMismatchException
-   * @throws NameResolutionException
-   * @throws QueryInvocationTargetException
-    } catch (EntryDestroyedException e) {
+    } catch (EntryDestroyedException ignore) {
-    if (applyLimit != null && applyLimit.booleanValue()) {
-      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue();
+    if (applyLimit != null && applyLimit) {
+      limit = (Integer) context.cacheGet(CompiledValue.RESULT_LIMIT);
-    boolean asc = true;
-    boolean multiColOrderBy = false;
-    if (orderByClause != null && orderByClause.booleanValue()) {
+    if (orderByClause != null && orderByClause) {
-      asc = !csc.getCriterion();
-      multiColOrderBy = orderByAttrs.size() > 1;
-    if (applyLimit != null && applyLimit.booleanValue()) {
-      limit = ((Integer) context.cacheGet(CompiledValue.RESULT_LIMIT)).intValue();
+    if (applyLimit != null && applyLimit) {
+      limit = (Integer) context.cacheGet(CompiledValue.RESULT_LIMIT);
-    List orderByAttrs = null;
+    List orderByAttrs;
-    if (orderByClause != null && orderByClause.booleanValue()) {
+    if (orderByClause != null && orderByClause) {
-  void instantiateEvaluator(IndexCreationHelper ich) {
-    this.evaluator = new IMQEvaluator(ich);
+  void instantiateEvaluator(IndexCreationHelper indexCreationHelper) {
+    this.evaluator = new IMQEvaluator(indexCreationHelper);
-    if (entriesIter == null || (limitApplied = verifyLimit(result, limit, context))) {
+    if (entriesIter == null || (limitApplied = verifyLimit(result, limit))) {
-        } catch (NoSuchElementException ex) {
+        } catch (NoSuchElementException ignore) {
-          // Some code that we might be able to use to optimize skipping the
-          // expansion of a value if no expansion is needed
-          // if
-          // (((CompactRangeIndex.IMQEvaluator)evaluator).getInitContext().getCurrentIterators().size()
-          // == 1) {
-          // boolean structType = (evaluator.getIndexResultSetType() instanceof
-          // StructType);
-          // if (!structType) {
-          // boolean ok = true;
-          // if (indexEntry.isUpdateInProgress()) {
-          // IndexInfo indexInfo =
-          // (IndexInfo)context.cacheGet(CompiledValue.INDEX_INFO);
-          // if (runtimeItr == null) {
-          // runtimeItr = getRuntimeIteratorForThisIndex(context, indexInfo);
-          // }
-          // runtimeItr.setCurrent(value);
-          // // Verify index key in region entry value.
-          // ok = evaluateEntry((IndexInfo) indexInfo, context, null);
-          // }
-          // if (runtimeItr != null) {
-          // runtimeItr.setCurrent(value);
-          // }
-          // if (ok && runtimeItr != null && iterOps != null) {
-          // ok = QueryUtils.applyCondition(iterOps, context);
-          // }
-          // if (ok) {
-          // if (context != null && context.isCqQueryContext()) {
-          // result.add(new CqEntry(indexEntry.getDeserializedRegionKey(),
-          // value));
-          // } else {
-          // applyProjection(projAttrib, context, result, value,
-          // intermediateResults, isIntersection);
-          // }
-          // if (verifyLimit(result, limit, context)) {
-          // observer.limitAppliedAtIndexLevel(this, limit, result);
-          // return;
-          // }
-          // }
-          // continue;
-          // }
-          // }
-          //
+
-              // We should not need to call the commented out code if expansion
-              // is occuring as we already reevaluate the index key per value
-              // if (indexEntry.isUpdateInProgress()) {
-              // IndexInfo indexInfo =
-              // (IndexInfo)context.cacheGet(CompiledValue.INDEX_INFO);
-              // if (runtimeItr == null) {
-              // runtimeItr = getRuntimeIteratorForThisIndex(context,
-              // indexInfo);
-              // }
-              // runtimeItr.setCurrent(value);
-              // // Verify index key in region entry value.
-              // ok = evaluateEntry((IndexInfo) indexInfo, context, null);
-              // }
+
-                if (verifyLimit(result, limit, context)) {
+                if (verifyLimit(result, limit)) {
-              if (verifyLimit(result, limit, context)) {
+              if (verifyLimit(result, limit)) {
-      } catch (ClassCastException e) {
-
-      } catch (EntryDestroyedException e) {
+      } catch (ClassCastException | EntryDestroyedException ignore) {
-      e.printStackTrace();
+      // TODO: never throw an anonymous inner class
-   * @param indexInfo
-   * @param context
-   * @param keyVal
-   * @throws FunctionDomainException
-   * @throws TypeMismatchException
-   * @throws NameResolutionException
-   * @throws QueryInvocationTargetException
-        return ((Boolean) result).booleanValue();
+        return (Boolean) result;
-      StringBuffer sb = new StringBuffer();
+      StringBuilder sb = new StringBuilder();
-  /**
-   * 
-   */
-    private Cache cache;
+    private InternalCache cache;
-    final private String[] canonicalIterNames;
+    private final String[] canonicalIterNames;
-     * Asif : The boolean if true indicates that the 0th iterator is on entries . If the 0th
-     * iterator is on collection of Region.Entry objects, then the RegionEntry object used in Index
-     * data objects is obtained directly from its corresponding Region.Entry object. However if the
-     * 0th iterator is not on entries then the boolean is false. In this case the additional
-     * projection attribute gives us the original value of the iterator while the Region.Entry
-     * object is obtained from 0th iterator. It is possible to have index being created on a Region
-     * Entry itself , instead of a Region. A Map operator( Compiled Index Operator) used with Region
-     * enables, us to create such indexes. In such case the 0th iterator, even if it represents a
-     * collection of Objects which are not Region.Entry objects, still the boolean remains true, as
-     * the Entry object can be easily obtained from the 0th iterator. In this case, the additional
-     * projection attribute s not null as it is used to evaluate the Entry object from the 0th
-     * iterator.
+     * The boolean if true indicates that the 0th iterator is on entries . If the 0th iterator is on
+     * collection of Region.Entry objects, then the RegionEntry object used in Index data objects is
+     * obtained directly from its corresponding Region.Entry object. However if the 0th iterator is
+     * not on entries then the boolean is false. In this case the additional projection attribute
+     * gives us the original value of the iterator while the Region.Entry object is obtained from
+     * 0th iterator. It is possible to have index being created on a Region Entry itself , instead
+     * of a Region. A Map operator( Compiled Index Operator) used with Region enables, us to create
+     * such indexes. In such case the 0th iterator, even if it represents a collection of Objects
+     * which are not Region.Entry objects, still the boolean remains true, as the Entry object can
+     * be easily obtained from the 0th iterator. In this case, the additional projection attribute s
+     * not null as it is used to evaluate the Entry object from the 0th iterator.
-    // Asif: List of modified iterators, not null only when the boolean
+    // List of modified iterators, not null only when the boolean
-    // Asif : The additional Projection attribute representing the value of the
+    // The additional Projection attribute representing the value of the
-    // Asif : This is not null iff the boolean isFirstItrOnEntry is false.
+    // This is not null iff the boolean isFirstItrOnEntry is false.
-      // Asif : The modified iterators for optmizing Index cxreation
+      // The modified iterators for optmizing Index cxreation
-        throw new IMQException(e) {};
+        throw new IMQException(e);
-     * 
-     * @param expansionContext
-     * @param expandedResults
-     * @param lowerBoundKey
-     * @param lowerBoundOperator
-     * @param upperBoundOperator
-     * @param value
-     * @throws IMQException
-            if (!ok.booleanValue()) {
+            if (!ok) {
-            if (!ok.booleanValue()) {
+            if (!ok) {
-        e.printStackTrace(System.out);
+        logger.debug(e);
-      } finally {
-
-          // Asif: Compute the dependency only once. The call to methods of this
+          // Compute the dependency only once. The call to methods of this
-     * Asif : This function is used for creating Index data at the start
-     * 
+     * This function is used for creating Index data at the start
-        // Asif: Since an index initialization can happen multiple times
+        // Since an index initialization can happen multiple times
-     * Asif : This function is used to obtain Index data at the time of index creation. Each element
-     * of the List is an Object Array of size 3. The 0th element of Object Array stores the value of
-     * Index Expression. The 1st element of ObjectArray contains the RegionEntry object ( If the
-     * booelan isFirstItrOnEntry is false, then the 0th iterator will give us the Region.Entry
-     * object which can be used to obtain the underlying RegionEntry object. If the boolean is true
-     * & additional projection attribute is not null, then the Region.Entry object can be obtained
-     * by evaluating the additional projection attribute. If the boolean isFirstItrOnEntry is tru e&
-     * additional projection attribute is null, then teh 0th iterator itself will evaluate to
-     * Region.Entry Object.
+     * This function is used to obtain Index data at the time of index creation. Each element of the
+     * List is an Object Array of size 3. The 0th element of Object Array stores the value of Index
+     * Expression. The 1st element of ObjectArray contains the RegionEntry object ( If the booelan
+     * isFirstItrOnEntry is false, then the 0th iterator will give us the Region.Entry object which
+     * can be used to obtain the underlying RegionEntry object. If the boolean is true & additional
+     * projection attribute is not null, then the Region.Entry object can be obtained by evaluating
+     * the additional projection attribute. If the boolean isFirstItrOnEntry is tru e& additional
+     * projection attribute is null, then teh 0th iterator itself will evaluate to Region.Entry
+     * Object.
-     * @param context
-     * @param context
-    // TODO :Asif: Test this function .
-      // String fieldNames[] = new String[len];
-        // fieldNames[start] = iter.getInternalId();
-        // fieldNames[0] = "iter1";

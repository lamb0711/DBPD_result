GEODE-7597: Factor out code needed in Membership from SocketCreator (#4637)

* GEODE-7597: Factor out code needed in Membership from SocketCreator

Implemented a new TcpSocketCreatorImpl.  Due to GeodeHttpClientRule
dependencies this and associated interfaces are in geode-common.  I'd
rather have them in geode-tcp-server.

SocketCreator now subclasses TcpSocketCreatorImpl and I've removed the
adapter class, which is no longer needed.

* added missing files

* fixing dunit failure and moving TcpSocketCreator back to the tcp-server project

* fixing bind address and inheritance problems in socket creators

* fixes for unit test failures

* spotless

* relax assertion in test that fails stress-testing

-import java.nio.channels.ServerSocketChannel;
-import java.util.concurrent.ThreadLocalRandom;
+import org.apache.geode.distributed.internal.tcpserver.TcpSocketCreatorImpl;
-public class SocketCreator {
+public class SocketCreator extends TcpSocketCreatorImpl {
-  public static final boolean ENABLE_TCP_KEEP_ALIVE;
-
-  static {
-    // bug #49484 - customers want tcp/ip keep-alive turned on by default
-    // to avoid dropped connections. It can be turned off by setting this
-    // property to false
-    String str = System.getProperty(GeodeGlossary.GEMFIRE_PREFIX + "setTcpKeepAlive");
-    if (str != null) {
-      ENABLE_TCP_KEEP_ALIVE = Boolean.valueOf(str);
-    } else {
-      ENABLE_TCP_KEEP_ALIVE = true;
-    }
-  }
+  public static final boolean ENABLE_TCP_KEEP_ALIVE = TcpSocketCreatorImpl.ENABLE_TCP_KEEP_ALIVE;
+  @Override
-  /**
-   * Return a ServerSocket possibly configured for SSL. SSL configuration is left up to JSSE
-   * properties in java.security file.
-   */
-  public ServerSocket createServerSocket(int nport, int backlog) throws IOException {
-    return createServerSocket(nport, backlog, null);
-  }
-
-  /**
-   * Return a ServerSocket possibly configured for SSL. SSL configuration is left up to JSSE
-   * properties in java.security file.
-   */
-  public ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr)
-      throws IOException {
-    return createServerSocket(nport, backlog, bindAddr, -1, sslConfig.isEnabled());
-  }
-
-  private ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
+  @Override
+  protected ServerSocket createServerSocket(int nport, int backlog, InetAddress bindAddr,
-    if (sslConnection) {
-      if (this.sslContext == null) {
-        throw new GemFireConfigException(
-            "SSL not configured correctly, Please look at previous error");
-      }
-      ServerSocketFactory ssf = this.sslContext.getServerSocketFactory();
-      SSLServerSocket serverSocket = (SSLServerSocket) ssf.createServerSocket();
-      serverSocket.setReuseAddress(true);
-      // If necessary, set the receive buffer size before binding the socket so
-      // that large buffers will be allocated on accepted sockets (see
-      // java.net.ServerSocket.setReceiverBufferSize javadocs)
-      if (socketBufferSize != -1) {
-        serverSocket.setReceiveBufferSize(socketBufferSize);
-      }
-      serverSocket.bind(new InetSocketAddress(bindAddr, nport), backlog);
-      finishServerSocket(serverSocket);
-      return serverSocket;
-    } else {
-      // log.info("Opening server socket on " + nport, new Exception("SocketCreation"));
-      ServerSocket result = new ServerSocket();
-      result.setReuseAddress(true);
-      // If necessary, set the receive buffer size before binding the socket so
-      // that large buffers will be allocated on accepted sockets (see
-      // java.net.ServerSocket.setReceiverBufferSize javadocs)
-      if (socketBufferSize != -1) {
-        result.setReceiveBufferSize(socketBufferSize);
-      }
-      try {
-        result.bind(new InetSocketAddress(bindAddr, nport), backlog);
-      } catch (BindException e) {
-        BindException throwMe =
-            new BindException(String.format("Failed to create server socket on %s[%s]",
-                bindAddr == null ? InetAddress.getLocalHost() : bindAddr,
-                String.valueOf(nport)));
-        throwMe.initCause(e);
-        throw throwMe;
-      }
-      return result;
+    if (!sslConnection) {
+      return super.createServerSocket(nport, backlog, bindAddr, socketBufferSize, sslConnection);
+    if (this.sslContext == null) {
+      throw new GemFireConfigException(
+          "SSL not configured correctly, Please look at previous error");
+    }
+    ServerSocketFactory ssf = this.sslContext.getServerSocketFactory();
+    SSLServerSocket serverSocket = (SSLServerSocket) ssf.createServerSocket();
+    serverSocket.setReuseAddress(true);
+    // If necessary, set the receive buffer size before binding the socket so
+    // that large buffers will be allocated on accepted sockets (see
+    // java.net.ServerSocket.setReceiverBufferSize javadocs)
+    if (socketBufferSize != -1) {
+      serverSocket.setReceiveBufferSize(socketBufferSize);
+    }
+    serverSocket.bind(new InetSocketAddress(bindAddr, nport), backlog);
+    finishServerSocket(serverSocket);
+    return serverSocket;
-  /**
-   * Creates or bind server socket to a random port selected from tcp-port-range which is same as
-   * membership-port-range.
-   *
-   * @param sslConnection whether to connect using SSL
-   *
-   * @return Returns the new server socket.
-   *
-   */
-  public ServerSocket createServerSocketUsingPortRange(InetAddress ba, int backlog,
-      boolean isBindAddress, boolean useNIO, int tcpBufferSize, int[] tcpPortRange,
-      boolean sslConnection) {
+  @Override
+  protected RuntimeException problemCreatingSocketInPortRangeException(String s, IOException e) {
+    return new GemFireConfigException(s, e);
+  }
-    try {
-      // Get a random port from range.
-      int startingPort = tcpPortRange[0]
-          + ThreadLocalRandom.current().nextInt(tcpPortRange[1] - tcpPortRange[0] + 1);
-      int localPort = startingPort;
-      int portLimit = tcpPortRange[1];
-
-      while (true) {
-        if (localPort > portLimit) {
-          if (startingPort != 0) {
-            localPort = tcpPortRange[0];
-            portLimit = startingPort - 1;
-            startingPort = 0;
-          } else {
-            throw new SystemConnectException(
-                "Unable to find a free port in the membership-port-range");
-          }
-        }
-        ServerSocket socket = null;
-        try {
-          if (useNIO) {
-            ServerSocketChannel channel = ServerSocketChannel.open();
-            socket = channel.socket();
-
-            InetSocketAddress address = new InetSocketAddress(isBindAddress ? ba : null, localPort);
-            socket.bind(address, backlog);
-          } else {
-            socket = this.createServerSocket(localPort, backlog, isBindAddress ? ba : null,
-                tcpBufferSize, sslConnection);
-          }
-          return socket;
-        } catch (java.net.SocketException ex) {
-          if (socket != null && !socket.isClosed()) {
-            socket.close();
-          }
-          localPort++;
-        }
-      }
-    } catch (IOException e) {
-      throw new GemFireConfigException("unable to create a socket in the membership-port range", e);
-    }
+  @Override
+  protected RuntimeException noFreePortException(String reason) {
+    return new SystemConnectException(reason);
-      ConnectionWatcher optionalWatcher, boolean clientSide) throws IOException {
-    return connect(inetadd, port, timeout, optionalWatcher, clientSide, -1);
-  }
-
-  /**
-   * Return a client socket, timing out if unable to connect and timeout > 0 (millis). The parameter
-   * <i>timeout</i> is ignored if SSL is being used, as there is no timeout argument in the ssl
-   * socket factory
-   */
-  public Socket connect(InetAddress inetadd, int port, int timeout,
+  @Override
-    Socket socket = null;
-    SocketAddress sockaddr = new InetSocketAddress(inetadd, port);
+
+
+    if (!sslConnection) {
+      return super.connect(inetadd, port, timeout, optionalWatcher, clientSide, socketBufferSize,
+          sslConnection);
+    }
+
+    // create an SSL connection
+
+    Socket socket;
+    SocketAddress sockaddr = new InetSocketAddress(inetadd, port);
+    if (this.sslContext == null) {
+      throw new GemFireConfigException(
+          "SSL not configured correctly, Please look at previous error");
+    }
+    SocketFactory sf = this.sslContext.getSocketFactory();
+    socket = sf.createSocket();
+
+    // Optionally enable SO_KEEPALIVE in the OS network protocol.
+    socket.setKeepAlive(ENABLE_TCP_KEEP_ALIVE);
+
+    // If necessary, set the receive buffer size before connecting the
+    // socket so that large buffers will be allocated on accepted sockets
+    // (see java.net.Socket.setReceiverBufferSize javadocs for details)
+    if (socketBufferSize != -1) {
+      socket.setReceiveBufferSize(socketBufferSize);
+    }
+
-      if (sslConnection) {
-        if (this.sslContext == null) {
-          throw new GemFireConfigException(
-              "SSL not configured correctly, Please look at previous error");
-        }
-        SocketFactory sf = this.sslContext.getSocketFactory();
-        socket = sf.createSocket();
-
-        // Optionally enable SO_KEEPALIVE in the OS network protocol.
-        socket.setKeepAlive(ENABLE_TCP_KEEP_ALIVE);
-
-        // If necessary, set the receive buffer size before connecting the
-        // socket so that large buffers will be allocated on accepted sockets
-        // (see java.net.Socket.setReceiverBufferSize javadocs for details)
-        if (socketBufferSize != -1) {
-          socket.setReceiveBufferSize(socketBufferSize);
-        }
-
-        if (optionalWatcher != null) {
-          optionalWatcher.beforeConnect(socket);
-        }
-        socket.connect(sockaddr, Math.max(timeout, 0));
-        configureClientSSLSocket(socket, timeout);
-        return socket;
-      } else {
-        if (clientSide && this.clientSocketFactory != null) {
-          socket = this.clientSocketFactory.createSocket(inetadd, port);
-        } else {
-          socket = new Socket();
-
-          // Optionally enable SO_KEEPALIVE in the OS network protocol.
-          socket.setKeepAlive(ENABLE_TCP_KEEP_ALIVE);
-
-          // If necessary, set the receive buffer size before connecting the
-          // socket so that large buffers will be allocated on accepted sockets
-          // (see java.net.Socket.setReceiverBufferSize javadocs for details)
-          if (socketBufferSize != -1) {
-            socket.setReceiveBufferSize(socketBufferSize);
-          }
-
-          if (optionalWatcher != null) {
-            optionalWatcher.beforeConnect(socket);
-          }
-          socket.connect(sockaddr, Math.max(timeout, 0));
-        }
-        return socket;
+      if (optionalWatcher != null) {
+        optionalWatcher.beforeConnect(socket);
+      socket.connect(sockaddr, Math.max(timeout, 0));
+      configureClientSSLSocket(socket, timeout);
+      return socket;
+
+  @Override
+  protected Socket createCustomClientSocket(InetAddress inetadd, int port) throws IOException {
+    if (this.clientSocketFactory != null) {
+      return this.clientSocketFactory.createSocket(inetadd, port);
+    }
+    return null;
+  }
+
-    if (socket instanceof SSLSocket) {
-      int oldTimeout = socket.getSoTimeout();
-      socket.setSoTimeout(timeout);
-      SSLSocket sslSocket = (SSLSocket) socket;
-      try {
-        sslSocket.startHandshake();
-      } catch (SSLPeerUnverifiedException ex) {
-        if (this.sslConfig.isRequireAuth()) {
-          logger.fatal(String.format("SSL Error in authenticating peer %s[%s].",
-              socket.getInetAddress(), socket.getPort()), ex);
-          throw ex;
-        }
+    if (!(socket instanceof SSLSocket)) {
+      return;
+    }
+    int oldTimeout = socket.getSoTimeout();
+    socket.setSoTimeout(timeout);
+    SSLSocket sslSocket = (SSLSocket) socket;
+    try {
+      sslSocket.startHandshake();
+    } catch (SSLPeerUnverifiedException ex) {
+      if (this.sslConfig.isRequireAuth()) {
+        logger.fatal(String.format("SSL Error in authenticating peer %s[%s].",
+            socket.getInetAddress(), socket.getPort()), ex);
+        throw ex;
-      // Pre jkd11, startHandshake is throwing SocketTimeoutException.
-      // in jdk 11 it is throwing SSLProtocolException with a cause of SocketTimeoutException.
-      // this is to keep the exception consistent across jdk
-      catch (SSLProtocolException ex) {
-        if (ex.getCause() instanceof SocketTimeoutException) {
-          throw (SocketTimeoutException) ex.getCause();
-        } else {
-          throw ex;
-        }
-      } finally {
-        try {
-          socket.setSoTimeout(oldTimeout);
-        } catch (SocketException ignored) {
-        }
+    }
+    // Pre jkd11, startHandshake is throwing SocketTimeoutException.
+    // in jdk 11 it is throwing SSLProtocolException with a cause of SocketTimeoutException.
+    // this is to keep the exception consistent across jdk
+    catch (SSLProtocolException ex) {
+      if (ex.getCause() instanceof SocketTimeoutException) {
+        throw (SocketTimeoutException) ex.getCause();
+      } else {
+        throw ex;
+      }
+    } finally {
+      try {
+        socket.setSoTimeout(oldTimeout);
+      } catch (SocketException ignored) {

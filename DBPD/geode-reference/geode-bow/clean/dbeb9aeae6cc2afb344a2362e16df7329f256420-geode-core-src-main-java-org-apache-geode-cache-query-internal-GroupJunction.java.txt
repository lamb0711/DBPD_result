Merge branch 'release/1.1.0'

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This structure contains the filter evaluable and iter evaluable
- * conditions which are dependent on a group of iterators derived from a single
- * independent iterator ( an iterator on the region) . The iter evaluatable
- * conditions belonging to other group of iterators can be a part of
+ * This structure contains the filter evaluable and iter evaluable conditions which are dependent on
+ * a group of iterators derived from a single independent iterator ( an iterator on the region) .
+ * The iter evaluatable conditions belonging to other group of iterators can be a part of
- *  
+ * 
-  private List unevaluatedFilterOperands = null; 
+  private List unevaluatedFilterOperands = null;
-  GroupJunction(int operator, RuntimeIterator[] indpndntItr,
-      boolean isCompleteExpansion, CompiledValue[] operands) {
-    super(operator, indpndntItr,isCompleteExpansion,  operands);
-    
+  GroupJunction(int operator, RuntimeIterator[] indpndntItr, boolean isCompleteExpansion,
+      CompiledValue[] operands) {
+    super(operator, indpndntItr, isCompleteExpansion, operands);
+
-	this.unevaluatedFilterOperands = unevaluatedFilterOps;  
+    this.unevaluatedFilterOperands = unevaluatedFilterOps;
-  
+
-	return this.unevaluatedFilterOperands;  
+    return this.unevaluatedFilterOperands;
-  
+
-    super(oldGJ, completeExpansion,indpnds, iterOp);    
+    super(oldGJ, completeExpansion, indpnds, iterOp);
-  
+
-  AbstractGroupOrRangeJunction recreateFromOld( boolean completeExpansion, RuntimeIterator indpnds[], CompiledValue iterOp) {
-    return new GroupJunction(this,completeExpansion,indpnds,iterOp);      
+  AbstractGroupOrRangeJunction recreateFromOld(boolean completeExpansion, RuntimeIterator indpnds[],
+      CompiledValue iterOp) {
+    return new GroupJunction(this, completeExpansion, indpnds, iterOp);
-  
+
-  AbstractGroupOrRangeJunction createNewOfSameType(int operator,
-      RuntimeIterator[] indpndntItr, boolean isCompleteExpansion,
-      CompiledValue[] operands) {
-    return new GroupJunction(operator, indpndntItr, isCompleteExpansion,
-        operands);
+  AbstractGroupOrRangeJunction createNewOfSameType(int operator, RuntimeIterator[] indpndntItr,
+      boolean isCompleteExpansion, CompiledValue[] operands) {
+    return new GroupJunction(operator, indpndntItr, isCompleteExpansion, operands);
-  
+
-  OrganizedOperands organizeOperands(ExecutionContext context)
-      throws FunctionDomainException, TypeMismatchException,
-      NameResolutionException, QueryInvocationTargetException {
+  OrganizedOperands organizeOperands(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
-    
+
-    boolean foundPreferredCondition = false; 
+    boolean foundPreferredCondition = false;
-      if (context instanceof QueryExecutionContext && ((QueryExecutionContext)context).hasHints() && ((QueryExecutionContext)context).hasMultiHints()) {
-        //Hint was provided, so allow multi index usage
+      if (context instanceof QueryExecutionContext && ((QueryExecutionContext) context).hasHints()
+          && ((QueryExecutionContext) context).hasMultiHints()) {
+        // Hint was provided, so allow multi index usage
-          if (_operands[i].getPlanInfo(context).evalAsFilter) { 
-                            indexCount++; 
-                        evalOperands.add(0, _operands[i]); 
-          }
-          else {
+          if (_operands[i].getPlanInfo(context).evalAsFilter) {
+            indexCount++;
+            evalOperands.add(0, _operands[i]);
+          } else {
-      }
-      else {
-        //Hint was not provided so continue with our single index solution
+      } else {
+        // Hint was not provided so continue with our single index solution
-        The idea is to use only one index in case of AND Junction .
-        Ideally the best index to be used should have been decided during the initial phase itself
-        when the compiled junction tree is being probed for indexable operands. But there are issues in
-        it as we need to tackle comlex cases like detection of those conditions which can actually form
-        a closed range or those which belong to different independent runtime iterators ( in case of multi
-        region queries). So going for the  quick fix of sorting here. The filter operands present here 
-        could be Comaprisn, IN or Range. The priority of sorting will be equality/IN/Range/Inequality    
-        */    
-        
+         * The idea is to use only one index in case of AND Junction . Ideally the best index to be
+         * used should have been decided during the initial phase itself when the compiled junction
+         * tree is being probed for indexable operands. But there are issues in it as we need to
+         * tackle comlex cases like detection of those conditions which can actually form a closed
+         * range or those which belong to different independent runtime iterators ( in case of multi
+         * region queries). So going for the quick fix of sorting here. The filter operands present
+         * here could be Comaprisn, IN or Range. The priority of sorting will be
+         * equality/IN/Range/Inequality
+         */
+
-        int currentBestFilterSize =-1;
+        int currentBestFilterSize = -1;
-      
+
-          //we check for size == 1 now because of the join optimization can 
-          //leave an operand with two indexes, but the key element is not set
-          //this will throw an npe
-          if (pi.evalAsFilter && pi.indexes.size() == 1) {       
-            if(pi.isPreferred) {
-              if(currentBestFilter != null) {
+          // we check for size == 1 now because of the join optimization can
+          // leave an operand with two indexes, but the key element is not set
+          // this will throw an npe
+          if (pi.evalAsFilter && pi.indexes.size() == 1) {
+            if (pi.isPreferred) {
+              if (currentBestFilter != null) {
-              currentBestFilter = (Filter)_operands[i];
-              currentBestFilterSize = ((Filter)_operands[i]).getSizeEstimate(context);
+              currentBestFilter = (Filter) _operands[i];
+              currentBestFilterSize = ((Filter) _operands[i]).getSizeEstimate(context);
-              currentBestFilter = (Filter)_operands[i];            
-              currentBestFilterSize = ((Filter)_operands[i]).getSizeEstimate(context);
-            }
-            else if ( foundPreferredCondition ||currentBestFilter.isBetterFilter((Filter)_operands[i], context, currentBestFilterSize)) {
+              currentBestFilter = (Filter) _operands[i];
+              currentBestFilterSize = ((Filter) _operands[i]).getSizeEstimate(context);
+            } else if (foundPreferredCondition || currentBestFilter
+                .isBetterFilter((Filter) _operands[i], context, currentBestFilterSize)) {
-            }
-            else {
+            } else {
-              currentBestFilter = (Filter)_operands[i];
+              currentBestFilter = (Filter) _operands[i];
-              // comparison return some how the size of comparedTo operand. 
-              currentBestFilterSize = ((Filter)_operands[i]).getSizeEstimate(context);
-  
+              // comparison return some how the size of comparedTo operand.
+              currentBestFilterSize = ((Filter) _operands[i]).getSizeEstimate(context);
+
-          }
-          else if (!_operands[i].isDependentOnCurrentScope(context)) {
+          } else if (!_operands[i].isDependentOnCurrentScope(context)) {
-            Support
-                .assertionFailed("An independentoperand should not ever be present as operand inside a GroupJunction as it should always be present only in CompiledJunction");
-          }
-          else {
+            Support.assertionFailed(
+                "An independentoperand should not ever be present as operand inside a GroupJunction as it should always be present only in CompiledJunction");
+          } else {
-    }else {
-      indexCount =_operands.length ;
+    } else {
+      indexCount = _operands.length;
-    
-    if(getIterOperands() != null) {
+
+    if (getIterOperands() != null) {
-    return createOrganizedOperandsObject(indexCount,evalOperands);    
+    return createOrganizedOperandsObject(indexCount, evalOperands);
-  
-  public int getSizeEstimate(ExecutionContext context)throws FunctionDomainException, TypeMismatchException, NameResolutionException, QueryInvocationTargetException  {
-	return 1;
+
+  public int getSizeEstimate(ExecutionContext context) throws FunctionDomainException,
+      TypeMismatchException, NameResolutionException, QueryInvocationTargetException {
+    return 1;

GEODE-1915: Prevent deadlock registering instantiators with gateways

Don't hold a lock while distributing instantiators. This prevents the
deadlock because incoming registrations won't wait for registrations
that are being distributed.

This change might cause instantiators to be distributed in a different
order that they were registered in, but that's ok because the order in
which different instantiators are registered is not important.

-  public static synchronized void register(Instantiator instantiator,
+  public static void register(Instantiator instantiator,
-  private static synchronized void _register(Instantiator instantiator, boolean distribute)
+  private static void _register(Instantiator instantiator, boolean distribute)
-    
-    boolean retry;
-    do {
-      retry = false;
-      Object oldInst = idsToInstantiators.putIfAbsent(idx, instantiator);
-      if (oldInst != null) {
-        if (oldInst instanceof Marker) {
-          retry = !idsToInstantiators.replace(idx, oldInst, instantiator);
-          if (!retry) {
-            dsMap.put(cName, instantiator);
-            ((Marker) oldInst).setInstantiator(instantiator);
+
+    synchronized(InternalInstantiator.class) {
+      boolean retry;
+      do {
+        retry = false;
+        Object oldInst = idsToInstantiators.putIfAbsent(idx, instantiator);
+        if (oldInst != null) {
+          if (oldInst instanceof Marker) {
+            retry = !idsToInstantiators.replace(idx, oldInst, instantiator);
+            if (!retry) {
+              dsMap.put(cName, instantiator);
+              ((Marker) oldInst).setInstantiator(instantiator);
+            }
-        } else {
-          Class oldClass =
-            ((Instantiator) oldInst).getInstantiatedClass();
-          if (!oldClass.getName().equals(cName)) {
-            throw new IllegalStateException(LocalizedStrings.InternalInstantiator_CLASS_ID_0_IS_ALREADY_REGISTERED_FOR_CLASS_1_SO_IT_COULD_NOT_BE_REGISTED_FOR_CLASS_2.toLocalizedString(new Object[] {Integer.valueOf(classId), oldClass.getName(), cName}));
-          } else {
-            return; // it was already registered
+          else {
+            Class oldClass =
+              ((Instantiator) oldInst).getInstantiatedClass();
+            if (!oldClass.getName().equals(cName)) {
+              throw new IllegalStateException(
+                LocalizedStrings.InternalInstantiator_CLASS_ID_0_IS_ALREADY_REGISTERED_FOR_CLASS_1_SO_IT_COULD_NOT_BE_REGISTED_FOR_CLASS_2
+                  .toLocalizedString(new Object[] { Integer.valueOf(classId), oldClass.getName(), cName }));
+            }
+            else {
+              return; // it was already registered
+            }
-      } else {
-        dsMap.put(cName, instantiator);
+        else {
+          dsMap.put(cName, instantiator);
+        }
-    } while (retry);
+      while (retry);
-    // if instantiator is getting registered for first time
-    // its EventID will be null, so generate a new event id
-    // the the distributed system is connected
-    GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
-    if (cache != null && instantiator.getEventId() == null) {
-      instantiator.setEventId(new EventID(cache.getDistributedSystem()));
+      // if instantiator is getting registered for first time
+      // its EventID will be null, so generate a new event id
+      // the the distributed system is connected
+      GemFireCacheImpl cache = GemFireCacheImpl.getInstance();
+      if (cache != null && instantiator.getEventId() == null) {
+        instantiator.setEventId(new EventID(cache.getDistributedSystem()));
+      }
+
+      logger.info(LocalizedMessage.create(LocalizedStrings.InternalInstantiator_REGISTERED, new Object[] { Integer.valueOf(classId), c.getName()} ));
-    
-    logger.info(LocalizedMessage.create(LocalizedStrings.InternalInstantiator_REGISTERED, new Object[] { Integer.valueOf(classId), c.getName()} ));
+

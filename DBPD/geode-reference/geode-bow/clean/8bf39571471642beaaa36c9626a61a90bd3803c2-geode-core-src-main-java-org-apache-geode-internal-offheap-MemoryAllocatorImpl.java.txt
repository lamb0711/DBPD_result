Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
- * This allocator is somewhat like an Arena allocator.
- * We start out with an array of multiple large chunks of memory.
- * We also keep lists of any chunk that have been allocated and freed.
- * An allocation will always try to find a chunk in a free list that is a close fit to the requested size.
- * If no close fits exist then it allocates the next slice from the front of one the original large chunks.
- * If we can not find enough free memory then all the existing free memory is defragmented.
- * If we still do not have enough to make the allocation an exception is thrown.
+ * This allocator is somewhat like an Arena allocator. We start out with an array of multiple large
+ * chunks of memory. We also keep lists of any chunk that have been allocated and freed. An
+ * allocation will always try to find a chunk in a free list that is a close fit to the requested
+ * size. If no close fits exist then it allocates the next slice from the front of one the original
+ * large chunks. If we can not find enough free memory then all the existing free memory is
+ * defragmented. If we still do not have enough to make the allocation an exception is thrown.
-  public static final String FREE_OFF_HEAP_MEMORY_PROPERTY = DistributionConfig.GEMFIRE_PREFIX + "free-off-heap-memory";
-  
+  public static final String FREE_OFF_HEAP_MEMORY_PROPERTY =
+      DistributionConfig.GEMFIRE_PREFIX + "free-off-heap-memory";
+
-  
+
-  
+
-  
+
-  
+
-  private static final boolean DO_EXPENSIVE_VALIDATION = Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "OFF_HEAP_DO_EXPENSIVE_VALIDATION");
-  
-  public static MemoryAllocator create(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats, int slabCount, 
-      long offHeapMemorySize, long maxSlabSize) {
+  private static final boolean DO_EXPENSIVE_VALIDATION =
+      Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + "OFF_HEAP_DO_EXPENSIVE_VALIDATION");
+
+  public static MemoryAllocator create(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats,
+      int slabCount, long offHeapMemorySize, long maxSlabSize) {
-      @Override
-      public Slab create(int size) {
-        return new SlabImpl(size);
-      }
-    });
+          @Override
+          public Slab create(int size) {
+            return new SlabImpl(size);
+          }
+        });
-  private static MemoryAllocatorImpl create(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats, int slabCount, 
-      long offHeapMemorySize, long maxSlabSize, Slab[] slabs, 
-      SlabFactory slabFactory) {
+  private static MemoryAllocatorImpl create(OutOfOffHeapMemoryListener ooohml,
+      OffHeapMemoryStats stats, int slabCount, long offHeapMemorySize, long maxSlabSize,
+      Slab[] slabs, SlabFactory slabFactory) {
-    if (result != null) {
-      result.reuse(ooohml, stats, offHeapMemorySize, slabs);
-      logger.info("Reusing {}  bytes of off-heap memory. The maximum size of a single off-heap object is {}  bytes.", result.getTotalMemory(), result.freeList.getLargestSlabSize());
-      created = true;
-      LifecycleListener.invokeAfterReuse(result);
-    } else {
-      if (slabs == null) {
-        // allocate memory chunks
-        logger.info("Allocating {} bytes of off-heap memory. The maximum size of a single off-heap object is {} bytes.", offHeapMemorySize, maxSlabSize);
-        slabs = new SlabImpl[slabCount];
-        long uncreatedMemory = offHeapMemorySize;
-        for (int i=0; i < slabCount; i++) {
-          try {
-            if (uncreatedMemory >= maxSlabSize) {
-              slabs[i] = slabFactory.create((int) maxSlabSize);
-              uncreatedMemory -= maxSlabSize;
-            } else {
-              // the last slab can be smaller then maxSlabSize
-              slabs[i] = slabFactory.create((int) uncreatedMemory);
-            }
-          } catch (OutOfMemoryError err) {
-            if (i > 0) {
-              logger.error("Off-heap memory creation failed after successfully allocating {} bytes of off-heap memory.", (i*maxSlabSize));
-            }
-            for (int j=0; j < i; j++) {
-              if (slabs[j] != null) {
-                slabs[j].free();
+      if (result != null) {
+        result.reuse(ooohml, stats, offHeapMemorySize, slabs);
+        logger.info(
+            "Reusing {}  bytes of off-heap memory. The maximum size of a single off-heap object is {}  bytes.",
+            result.getTotalMemory(), result.freeList.getLargestSlabSize());
+        created = true;
+        LifecycleListener.invokeAfterReuse(result);
+      } else {
+        if (slabs == null) {
+          // allocate memory chunks
+          logger.info(
+              "Allocating {} bytes of off-heap memory. The maximum size of a single off-heap object is {} bytes.",
+              offHeapMemorySize, maxSlabSize);
+          slabs = new SlabImpl[slabCount];
+          long uncreatedMemory = offHeapMemorySize;
+          for (int i = 0; i < slabCount; i++) {
+            try {
+              if (uncreatedMemory >= maxSlabSize) {
+                slabs[i] = slabFactory.create((int) maxSlabSize);
+                uncreatedMemory -= maxSlabSize;
+              } else {
+                // the last slab can be smaller then maxSlabSize
+                slabs[i] = slabFactory.create((int) uncreatedMemory);
+            } catch (OutOfMemoryError err) {
+              if (i > 0) {
+                logger.error(
+                    "Off-heap memory creation failed after successfully allocating {} bytes of off-heap memory.",
+                    (i * maxSlabSize));
+              }
+              for (int j = 0; j < i; j++) {
+                if (slabs[j] != null) {
+                  slabs[j].free();
+                }
+              }
+              throw err;
-            throw err;
-      }
-      result = new MemoryAllocatorImpl(ooohml, stats, slabs);
-      singleton = result;
-      LifecycleListener.invokeAfterCreate(result);
-      created = true;
-    }
+        result = new MemoryAllocatorImpl(ooohml, stats, slabs);
+        singleton = result;
+        LifecycleListener.invokeAfterCreate(result);
+        created = true;
+      }
-  static MemoryAllocatorImpl createForUnitTest(OutOfOffHeapMemoryListener ooohml, OffHeapMemoryStats stats, int slabCount, 
-      long offHeapMemorySize, long maxSlabSize, SlabFactory memChunkFactory) {
-    return create(ooohml, stats, slabCount, offHeapMemorySize, maxSlabSize, null, 
-        memChunkFactory);
+
+  static MemoryAllocatorImpl createForUnitTest(OutOfOffHeapMemoryListener ooohml,
+      OffHeapMemoryStats stats, int slabCount, long offHeapMemorySize, long maxSlabSize,
+      SlabFactory memChunkFactory) {
+    return create(ooohml, stats, slabCount, offHeapMemorySize, maxSlabSize, null, memChunkFactory);
-  public static MemoryAllocatorImpl createForUnitTest(OutOfOffHeapMemoryListener oooml, OffHeapMemoryStats stats, Slab[] slabs) {
+
+  public static MemoryAllocatorImpl createForUnitTest(OutOfOffHeapMemoryListener oooml,
+      OffHeapMemoryStats stats, Slab[] slabs) {
-      for (int i=0; i < slabCount; i++) {
+      for (int i = 0; i < slabCount; i++) {
-  
-  
-  private void reuse(OutOfOffHeapMemoryListener oooml, OffHeapMemoryStats newStats, long offHeapMemorySize, Slab[] slabs) {
+
+
+  private void reuse(OutOfOffHeapMemoryListener oooml, OffHeapMemoryStats newStats,
+      long offHeapMemorySize, Slab[] slabs) {
-      logger.warn("Using {} bytes of existing off-heap memory instead of the requested {}.", getTotalMemory(), offHeapMemorySize);
+      logger.warn("Using {} bytes of existing off-heap memory instead of the requested {}.",
+          getTotalMemory(), offHeapMemorySize);
-      throw new IllegalStateException("attempted to reuse existing off-heap memory even though new off-heap memory was allocated");
+      throw new IllegalStateException(
+          "attempted to reuse existing off-heap memory even though new off-heap memory was allocated");
-  private MemoryAllocatorImpl(final OutOfOffHeapMemoryListener oooml, final OffHeapMemoryStats stats, final Slab[] slabs) {
+  private MemoryAllocatorImpl(final OutOfOffHeapMemoryListener oooml,
+      final OffHeapMemoryStats stats, final Slab[] slabs) {
-    
+
-    
+
-  
+
-  
+
-      Iterator<Region<?,?>> rootIt = gfc.rootRegions().iterator();
+      Iterator<Region<?, ?>> rootIt = gfc.rootRegions().iterator();
-        Region<?,?> rr = rootIt.next();
+        Region<?, ?> rr = rootIt.next();
-        Iterator<Region<?,?>> srIt = rr.subregions(true).iterator();
+        Iterator<Region<?, ?>> srIt = rr.subregions(true).iterator();
-  private void getRegionLiveChunks(Region<?,?> r, List<OffHeapStoredObject> result) {
+  private void getRegionLiveChunks(Region<?, ?> r, List<OffHeapStoredObject> result) {
-  
+
-  
+
-    //System.out.println("allocating " + size);
+    // System.out.println("allocating " + size);
-    //("allocated off heap object of size " + size + " @" + Long.toHexString(result.getMemoryAddress()), true);
+    // ("allocated off heap object of size " + size + " @" +
+    // Long.toHexString(result.getMemoryAddress()), true);
-  
+
-  
+
+
-  public StoredObject allocateAndInitialize(byte[] v, boolean isSerialized, boolean isCompressed, byte[] originalHeapData) {
+  public StoredObject allocateAndInitialize(byte[] v, boolean isSerialized, boolean isCompressed,
+      byte[] originalHeapData) {
-    //debugLog("allocated off heap object of size " + v.length + " @" + Long.toHexString(result.getMemoryAddress()), true);
-    //debugLog("allocated off heap object of size " + v.length + " @" + Long.toHexString(result.getMemoryAddress()) +  "chunkSize=" + result.getSize() + " isSerialized=" + isSerialized + " v=" + Arrays.toString(v), true);
+    // debugLog("allocated off heap object of size " + v.length + " @" +
+    // Long.toHexString(result.getMemoryAddress()), true);
+    // debugLog("allocated off heap object of size " + v.length + " @" +
+    // Long.toHexString(result.getMemoryAddress()) + "chunkSize=" + result.getSize() + "
+    // isSerialized=" + isSerialized + " v=" + Arrays.toString(v), true);
-  
+
-  
+
-  
+
-  
+
-  
+
+
+
-   * Returns true if caller is the one who should close; false if some other thread
-   * is already closing.
+   * Returns true if caller is the one who should close; false if some other thread is already
+   * closing.
-  
+
-  
+
-  
+
-  
+
-      final MemoryUsageListener[] newMemoryUsageListeners = Arrays.copyOf(this.memoryUsageListeners, this.memoryUsageListeners.length + 1);
+      final MemoryUsageListener[] newMemoryUsageListeners =
+          Arrays.copyOf(this.memoryUsageListeners, this.memoryUsageListeners.length + 1);
-  
+
-        final MemoryUsageListener[] newMemoryUsageListeners = new MemoryUsageListener[this.memoryUsageListeners.length - 1];
+        final MemoryUsageListener[] newMemoryUsageListeners =
+            new MemoryUsageListener[this.memoryUsageListeners.length - 1];
-        System.arraycopy(this.memoryUsageListeners, listenerIndex + 1, newMemoryUsageListeners, listenerIndex,
-            this.memoryUsageListeners.length - listenerIndex - 1);
+        System.arraycopy(this.memoryUsageListeners, listenerIndex + 1, newMemoryUsageListeners,
+            listenerIndex, this.memoryUsageListeners.length - listenerIndex - 1);
-  
+
-    
+
-  
+
-  
+
-     }
+      }
-          throw new IllegalStateException(" address 0x" + Long.toString(addr, 16) + " does not address the original slab memory");
+          throw new IllegalStateException(" address 0x" + Long.toString(addr, 16)
+              + " does not address the original slab memory");
-    for (OffHeapStoredObject chunk: liveChunks) {
+    for (OffHeapStoredObject chunk : liveChunks) {
-    Collections.sort(orphans,
-        new Comparator<MemoryBlock>() {
-          @Override
-          public int compare(MemoryBlock o1, MemoryBlock o2) {
-            return Long.valueOf(o1.getAddress()).compareTo(o2.getAddress());
-          }
-        });
-    //this.memoryBlocks = new WeakReference<List<MemoryBlock>>(orphans);
+    Collections.sort(orphans, new Comparator<MemoryBlock>() {
+      @Override
+      public int compare(MemoryBlock o1, MemoryBlock o2) {
+        return Long.valueOf(o1.getAddress()).compareTo(o2.getAddress());
+      }
+    });
+    // this.memoryBlocks = new WeakReference<List<MemoryBlock>>(orphans);
-  
+

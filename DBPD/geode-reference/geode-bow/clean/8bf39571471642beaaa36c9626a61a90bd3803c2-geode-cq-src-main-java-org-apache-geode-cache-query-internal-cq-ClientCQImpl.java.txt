Added Spotless plugin to enforce formatting standards.
Added Google Java Style guide formatter templates, removed existing formatter templates.

Ran './gradlew clean build' for verification

This closes #268

- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license
+ * agreements. See the NOTICE file distributed with this work for additional information regarding
+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at
- *      http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
-  
+
-  
+
-  
+
-  
-  /** To queue the CQ Events arriving during CQ execution with 
-   * initial Results.
+
+  /**
+   * To queue the CQ Events arriving during CQ execution with initial Results.
-  
+
-  
+
-  
-  public ClientCQImpl(CqServiceImpl cqService, String cqName, String queryString, CqAttributes cqAttributes, ServerCQProxyImpl serverProxy, boolean isDurable)  {
+
+  public ClientCQImpl(CqServiceImpl cqService, String cqName, String queryString,
+      CqAttributes cqAttributes, ServerCQProxyImpl serverProxy, boolean isDurable) {
-  
+
-  
-  /* (non-Javadoc)
+
+  /*
+   * (non-Javadoc)
+   * 
-  
+
-   * Initializes the connection using the pool from the client region.
-   * Also sets the cqBaseRegion value of this CQ.
+   * Initializes the connection using the pool from the client region. Also sets the cqBaseRegion
+   * value of this CQ.
+   * 
-    cqBaseRegion = (LocalRegion)cqService.getCache().getRegion(regionName);
+    cqBaseRegion = (LocalRegion) cqService.getCache().getRegion(regionName);
-    if (cqBaseRegion == null){
-      throw new RegionNotFoundException( LocalizedStrings.CqQueryImpl_REGION_ON_WHICH_QUERY_IS_SPECIFIED_NOT_FOUND_LOCALLY_REGIONNAME_0
-          .toLocalizedString(regionName));
+    if (cqBaseRegion == null) {
+      throw new RegionNotFoundException(
+          LocalizedStrings.CqQueryImpl_REGION_ON_WHICH_QUERY_IS_SPECIFIED_NOT_FOUND_LOCALLY_REGIONNAME_0
+              .toLocalizedString(regionName));
-    
+
-      if (logger.isTraceEnabled()){
+      if (logger.isTraceEnabled()) {
-      if(!srp.getPool().getSubscriptionEnabled()) {
-         throw new CqException("The 'queueEnabled' flag on Pool installed on Region " + regionName + " is set to false.");
+      if (!srp.getPool().getSubscriptionEnabled()) {
+        throw new CqException("The 'queueEnabled' flag on Pool installed on Region " + regionName
+            + " is set to false.");
-      throw new CqException("Unable to get the connection pool. The Region does not have a pool configured.");
+      throw new CqException(
+          "Unable to get the connection pool. The Region does not have a pool configured.");
-    
-//    if (proxy == null) {
-//      throw new CqException(LocalizedStrings.CqQueryImpl_UNABLE_TO_GET_THE_CONNECTIONPROXY_THE_REGION_MAY_NOT_HAVE_A_BRIDGEWRITER_OR_BRIDGECLIENT_INSTALLED_ON_IT.toLocalizedString());
-//    } else if(!proxy.getEstablishCallbackConnection()){
-//      throw new CqException(LocalizedStrings.CqQueryImpl_THE_ESTABLISHCALLBACKCONNECTION_ON_BRIDGEWRITER_CLIENT_INSTALLED_ON_REGION_0_IS_SET_TO_FALSE
-//        .toLocalizedString(regionName));
-//    }
+
+    // if (proxy == null) {
+    // throw new
+    // CqException(LocalizedStrings.CqQueryImpl_UNABLE_TO_GET_THE_CONNECTIONPROXY_THE_REGION_MAY_NOT_HAVE_A_BRIDGEWRITER_OR_BRIDGECLIENT_INSTALLED_ON_IT.toLocalizedString());
+    // } else if(!proxy.getEstablishCallbackConnection()){
+    // throw new
+    // CqException(LocalizedStrings.CqQueryImpl_THE_ESTABLISHCALLBACKCONNECTION_ON_BRIDGEWRITER_CLIENT_INSTALLED_ON_REGION_0_IS_SET_TO_FALSE
+    // .toLocalizedString(regionName));
+    // }
-  
+
-      logger.debug("Started closing CQ CqName: {} SendRequestToServer: {}", cqName, sendRequestToServer);
-    }   
+      logger.debug("Started closing CQ CqName: {} SendRequestToServer: {}", cqName,
+          sendRequestToServer);
+    }
-    synchronized(this.cqState) {
+    synchronized (this.cqState) {
-        //throw new CqClosedException("CQ is already closed, CqName : " + this.cqName);
-        if (isDebugEnabled){
+        // throw new CqClosedException("CQ is already closed, CqName : " + this.cqName);
+        if (isDebugEnabled) {
-      this.cqState.setState(CqStateImpl.CLOSING);      
+      this.cqState.setState(CqStateImpl.CLOSING);
-      // Close request to server.    
+      // Close request to server.
-            UserAttributes.userAttributes.set(this.proxyCache
-                .getUserAttributes());
+            UserAttributes.userAttributes.set(this.proxyCache.getUserAttributes());
-        } 
-        catch (CancelException e) {
+        } catch (CancelException e) {
-        } 
-        catch(Exception ex) {
-          if(shutdownInProgress()) {
+        } catch (Exception ex) {
+          if (shutdownInProgress()) {
-      this.removeFromCqMap(); 
+      this.removeFromCqMap();
-      if (cqProxy == null || !sendRequestToServer || isClosed) {       
+      if (cqProxy == null || !sendRequestToServer || isClosed) {
-        if(this.stats != null)
+        if (this.stats != null)
-        if(shutdownInProgress()) {
+        if (shutdownInProgress()) {
-          throw new CqException(LocalizedStrings.CqQueryImpl_FAILED_TO_CLOSE_THE_CQ_CQNAME_0_ERROR_FROM_LAST_ENDPOINT_1
-              .toLocalizedString(new Object[] {this.cqName, exception.getLocalizedMessage()}), exception.getCause());   
+          throw new CqException(
+              LocalizedStrings.CqQueryImpl_FAILED_TO_CLOSE_THE_CQ_CQNAME_0_ERROR_FROM_LAST_ENDPOINT_1
+                  .toLocalizedString(new Object[] {this.cqName, exception.getLocalizedMessage()}),
+              exception.getCause());
-          throw new CqException(LocalizedStrings.CqQueryImpl_FAILED_TO_CLOSE_THE_CQ_CQNAME_0_THE_SERVER_ENDPOINTS_ON_WHICH_THIS_CQ_WAS_REGISTERED_WERE_NOT_FOUND
-              .toLocalizedString(this.cqName));   
+          throw new CqException(
+              LocalizedStrings.CqQueryImpl_FAILED_TO_CLOSE_THE_CQ_CQNAME_0_THE_SERVER_ENDPOINTS_ON_WHICH_THIS_CQ_WAS_REGISTERED_WERE_NOT_FOUND
+                  .toLocalizedString(this.cqName));
-        if (isDebugEnabled){
-          logger.debug("Invoking CqListeners close() api for the CQ, CqName: {} Number of CqListeners: {}", cqName, cqListeners.length);
+        if (isDebugEnabled) {
+          logger.debug(
+              "Invoking CqListeners close() api for the CQ, CqName: {} Number of CqListeners: {}",
+              cqName, cqListeners.length);
-        for (int lCnt=0; lCnt < cqListeners.length; lCnt++) {
+        for (int lCnt = 0; lCnt < cqListeners.length; lCnt++) {
-          } 
-          catch (VirtualMachineError err) {
+          } catch (VirtualMachineError err) {
-            // If this ever returns, rethrow the error.  We're poisoned
+            // If this ever returns, rethrow the error. We're poisoned
-          }
-          catch (Throwable t) {
+          } catch (Throwable t) {
-            // catch VirtualMachineError (see above).  However, there is
+            // catch VirtualMachineError (see above). However, there is
-          }        
+          }
-  
+
+   * 
-    this.cqService.removeFromBaseRegionToCqNameMap(this.regionName, this.getServerCqName());      
+    this.cqService.removeFromBaseRegionToCqNameMap(this.regionName, this.getServerCqName());
-  
+
-  
-  
+
+
-    
+
-  
-  
+
+
-   * Start or resume executing the query.
-   * Gets or updates the CQ results and returns them.
+   * Start or resume executing the query. Gets or updates the CQ results and returns them.
-  public CqResults executeWithInitialResults() 
-    throws CqClosedException, RegionNotFoundException, CqException {
-    
-    synchronized(queuedEventsSynchObject) {
-      //Prevents multiple calls to executeWithInitialResults from squishing
-      //each others queuedEvents.  Forces the second call to wait
-      //until first call is completed.      
+  public CqResults executeWithInitialResults()
+      throws CqClosedException, RegionNotFoundException, CqException {
+
+    synchronized (queuedEventsSynchObject) {
+      // Prevents multiple calls to executeWithInitialResults from squishing
+      // each others queuedEvents. Forces the second call to wait
+      // until first call is completed.
-        }
-        catch (InterruptedException e) {
+        } catch (InterruptedException e) {
-      //At this point we know queuedEvents is null and no one is adding to queuedEvents yet.
+      // At this point we know queuedEvents is null and no one is adding to queuedEvents yet.
-    
+
-    //If an exception is thrown, we need to clean up the queuedEvents 
-    //or else client will hang on next executeWithInitialResults
+    // If an exception is thrown, we need to clean up the queuedEvents
+    // or else client will hang on next executeWithInitialResults
-      initialResults = (CqResults)executeCqOnRedundantsAndPrimary(true);
-    }
-    catch (CqClosedException e) { 
+      initialResults = (CqResults) executeCqOnRedundantsAndPrimary(true);
+    } catch (CqClosedException e) {
+      queuedEvents = null;
+      throw e;
+    } catch (RegionNotFoundException e) {
+      queuedEvents = null;
+      throw e;
+    } catch (CqException e) {
+      queuedEvents = null;
+      throw e;
+    } catch (RuntimeException e) {
-    catch (RegionNotFoundException e) {
-      queuedEvents = null;
-      throw e;
-    }
-    catch (CqException e) {
-      queuedEvents = null;
-      throw e;
-    }
-    catch (RuntimeException e) {
-      queuedEvents = null;
-      throw e;
-    }
-    
-    //lock was released earlier so that events that are received while executing 
-    //initial results can be added to the queue.
-    synchronized(queuedEventsSynchObject) {
+
+    // lock was released earlier so that events that are received while executing
+    // initial results can be added to the queue.
+    synchronized (queuedEventsSynchObject) {
-            Runnable r = new Runnable(){
-              public void run(){ 
+            Runnable r = new Runnable() {
+              public void run() {
-                synchronized (queuedEventsSynchObject){
+                synchronized (queuedEventsSynchObject) {
-                  
-                     //Process through the events
-                    for (Object cqEvent : eventArray) { 
-                      cqService.invokeListeners(cqName, ClientCQImpl.this, 
-                          (CqEventImpl)cqEvent);
+
+                    // Process through the events
+                    for (Object cqEvent : eventArray) {
+                      cqService.invokeListeners(cqName, ClientCQImpl.this, (CqEventImpl) cqEvent);
-                    } 
-                  }
-                  finally {
-                    //Make sure that we notify waiting threads or else possible dead lock
+                    }
+                  } finally {
+                    // Make sure that we notify waiting threads or else possible dead lock
-              LoggingThreadGroup.createThreadGroup("CQEventHandler", logger);
+                LoggingThreadGroup.createThreadGroup("CQEventHandler", logger);
-            thread.start();    
+            thread.start();
-            if (logger.isDebugEnabled()){
+            if (logger.isDebugEnabled()) {
-      }
-      finally {
+      } finally {
-  
+
-   * This executes the CQ first on the redundant server and then on the primary server.
-   * This is required to keep the redundancy behavior in accordance with the HAQueue
-   * expectation (wherein the events are delivered only from the primary).
+   * This executes the CQ first on the redundant server and then on the primary server. This is
+   * required to keep the redundancy behavior in accordance with the HAQueue expectation (wherein
+   * the events are delivered only from the primary).
+   * 
-  public Object executeCqOnRedundantsAndPrimary(boolean executeWithInitialResults) 
-  throws CqClosedException, RegionNotFoundException, CqException {
+  public Object executeCqOnRedundantsAndPrimary(boolean executeWithInitialResults)
+      throws CqClosedException, RegionNotFoundException, CqException {
-    
+
-        throw new CqClosedException(LocalizedStrings.CqQueryImpl_CQ_IS_CLOSED_CQNAME_0
-            .toLocalizedString(this.cqName));
+        throw new CqClosedException(
+            LocalizedStrings.CqQueryImpl_CQ_IS_CLOSED_CQNAME_0.toLocalizedString(this.cqName));
-        logger.debug("Performing Execute {} request for CQ. CqName: {}", ((executeWithInitialResults)?"WithInitialResult":""), this.cqName);
+        logger.debug("Performing Execute {} request for CQ. CqName: {}",
+            ((executeWithInitialResults) ? "WithInitialResult" : ""), this.cqName);
-      this.cqBaseRegion = (LocalRegion)cqService.getCache().getRegion(this.regionName); 
+      this.cqBaseRegion = (LocalRegion) cqService.getCache().getRegion(this.regionName);
-        // pool that initializes the CQ. Else its set using the Region proxy. 
-        if (this.cqProxy == null){
+        // pool that initializes the CQ. Else its set using the Region proxy.
+        if (this.cqProxy == null) {
-            UserAttributes.userAttributes.set(this.proxyCache
-                .getUserAttributes());
+            UserAttributes.userAttributes.set(this.proxyCache.getUserAttributes());
-          if(executeWithInitialResults) {
+          if (executeWithInitialResults) {
-              String errMsg = "Failed to execute the CQ.  CqName: " + 
-              this.cqName + ", Query String is: " + this.queryString;
-              throw new CqException(errMsg);                    
+              String errMsg = "Failed to execute the CQ.  CqName: " + this.cqName
+                  + ", Query String is: " + this.queryString;
+              throw new CqException(errMsg);
-          if (this.shutdownInProgress()){
-            throw new CqException("System shutdown in progress.");  
+          if (this.shutdownInProgress()) {
+            throw new CqException("System shutdown in progress.");
-              securityLogWriter.warning(LocalizedStrings.CqQueryImpl_EXCEPTION_WHILE_EXECUTING_CQ_EXCEPTION_0, ex, null);              
+              securityLogWriter.warning(
+                  LocalizedStrings.CqQueryImpl_EXCEPTION_WHILE_EXECUTING_CQ_EXCEPTION_0, ex, null);
-          } else if(ex instanceof CqException) {
-            throw (CqException)ex;
+          } else if (ex instanceof CqException) {
+            throw (CqException) ex;
-            String errMsg = 
-              LocalizedStrings.CqQueryImpl_FAILED_TO_EXECUTE_THE_CQ_CQNAME_0_QUERY_STRING_IS_1_ERROR_FROM_LAST_SERVER_2
-              .toLocalizedString(new Object[] {this.cqName, this.queryString, ex.getLocalizedMessage()});
-            if (logger.isDebugEnabled()){
+            String errMsg =
+                LocalizedStrings.CqQueryImpl_FAILED_TO_EXECUTE_THE_CQ_CQNAME_0_QUERY_STRING_IS_1_ERROR_FROM_LAST_SERVER_2
+                    .toLocalizedString(
+                        new Object[] {this.cqName, this.queryString, ex.getLocalizedMessage()});
+            if (logger.isDebugEnabled()) {
-          if(!success && !this.shutdownInProgress()) {
+          if (!success && !this.shutdownInProgress()) {
-            } catch(Exception e) {
+            } catch (Exception e) {
-      } 
+      }
-    //If client side, alert listeners that a cqs have been connected
+    // If client side, alert listeners that a cqs have been connected
-      for (int lCnt=0; lCnt < cqListeners.length; lCnt++) {
+      for (int lCnt = 0; lCnt < cqListeners.length; lCnt++) {
-            listener.onCqConnected(); 
+            listener.onCqConnected();
-  
+
+   * 
-  private boolean shutdownInProgress() {    
+  private boolean shutdownInProgress() {
-      return true; //bail, things are shutting down
+      return true; // bail, things are shutting down
-    
-    
+
+
-    }  
+    }
-    
+
-  
+
-  public void stop()throws CqClosedException, CqException {
+  public void stop() throws CqClosedException, CqException {
-        throw new CqClosedException(LocalizedStrings.CqQueryImpl_CQ_IS_CLOSED_CQNAME_0
-            .toLocalizedString(this.cqName));
+        throw new CqClosedException(
+            LocalizedStrings.CqQueryImpl_CQ_IS_CLOSED_CQNAME_0.toLocalizedString(this.cqName));
-      
+
-        throw new IllegalStateException(LocalizedStrings.CqQueryImpl_CQ_IS_NOT_IN_RUNNING_STATE_STOP_CQ_DOES_NOT_APPLY_CQNAME_0
-            .toLocalizedString(this.cqName));
+        throw new IllegalStateException(
+            LocalizedStrings.CqQueryImpl_CQ_IS_NOT_IN_RUNNING_STATE_STOP_CQ_DOES_NOT_APPLY_CQNAME_0
+                .toLocalizedString(this.cqName));
-      
+
-          UserAttributes.userAttributes.set(this.proxyCache
-              .getUserAttributes());
+          UserAttributes.userAttributes.set(this.proxyCache.getUserAttributes());
-      } catch(Exception e ) {
+      } catch (Exception e) {
-       if (cqProxy == null || isStopped) {
-         // Change state and stats on the client side
-         this.cqState.setState(CqStateImpl.STOPPED);
-         this.cqService.stats.incCqsStopped();
-         this.cqService.stats.decCqsActive();
-         if (logger.isDebugEnabled()) {
-           logger.debug("Successfully stopped the CQ. {}", cqName);
-         }
-       } else {
-         // Hasn't able to send stop request to any server.
-         if (exception != null) {
-           throw new CqException(LocalizedStrings.CqQueryImpl_FAILED_TO_STOP_THE_CQ_CQNAME_0_ERROR_FROM_LAST_SERVER_1
-              .toLocalizedString(new Object[] {this.cqName, exception.getLocalizedMessage()}),
+      if (cqProxy == null || isStopped) {
+        // Change state and stats on the client side
+        this.cqState.setState(CqStateImpl.STOPPED);
+        this.cqService.stats.incCqsStopped();
+        this.cqService.stats.decCqsActive();
+        if (logger.isDebugEnabled()) {
+          logger.debug("Successfully stopped the CQ. {}", cqName);
+        }
+      } else {
+        // Hasn't able to send stop request to any server.
+        if (exception != null) {
+          throw new CqException(
+              LocalizedStrings.CqQueryImpl_FAILED_TO_STOP_THE_CQ_CQNAME_0_ERROR_FROM_LAST_SERVER_1
+                  .toLocalizedString(new Object[] {this.cqName, exception.getLocalizedMessage()}),
-         } else {
-           throw new CqException(LocalizedStrings.CqQueryImpl_FAILED_TO_STOP_THE_CQ_CQNAME_0_THE_SERVER_ENDPOINTS_ON_WHICH_THIS_CQ_WAS_REGISTERED_WERE_NOT_FOUND
-              .toLocalizedString(this.cqName));
-         }
-       }
+        } else {
+          throw new CqException(
+              LocalizedStrings.CqQueryImpl_FAILED_TO_STOP_THE_CQ_CQNAME_0_THE_SERVER_ENDPOINTS_ON_WHICH_THIS_CQ_WAS_REGISTERED_WERE_NOT_FOUND
+                  .toLocalizedString(this.cqName));
+        }
+      }
-  
+
-    return (CqAttributesMutator)this.cqAttributes;
+    return (CqAttributesMutator) this.cqAttributes;
-  
-  
+
+
-  /* (non-Javadoc)
-   * @see org.apache.geode.cache.query.internal.InternalCqQuery2#setProxyCache(org.apache.geode.cache.client.internal.ProxyCache)
+  /*
+   * (non-Javadoc)
+   * 
+   * @see
+   * org.apache.geode.cache.query.internal.InternalCqQuery2#setProxyCache(org.apache.geode.cache.
+   * client.internal.ProxyCache)
-  public void setProxyCache(ProxyCache proxyCache){
+  public void setProxyCache(ProxyCache proxyCache) {
-  
+
-  
+
-    
-    byte regionDataPolicyOrdinal = getCqBaseRegion() == null ? (byte)0
+
+    byte regionDataPolicyOrdinal = getCqBaseRegion() == null ? (byte) 0
-    
+
-    this.cqProxy.createOn(getName(), conn, getQueryString(), state, isDurable, regionDataPolicyOrdinal);
+    this.cqProxy.createOn(getName(), conn, getQueryString(), state, isDurable,
+        regionDataPolicyOrdinal);
-  
-  
+
+

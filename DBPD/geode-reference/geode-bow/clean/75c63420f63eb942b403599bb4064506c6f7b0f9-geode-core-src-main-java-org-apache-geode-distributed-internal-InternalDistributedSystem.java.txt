GEODE-7184: Add function execution timers (#4135)

- Add micrometer timers for recording function executions
- Refactor FunctionStats and FunctionServiceStats
- Change static fields to instance fields on FunctionStatsManager
- Mark static field as @Immutable on NoopMeterRegistry
- Rename FunctionServiceStats.endFunctionExecutionWithElapsedTime to
distinguish it from FunctionStats.endFunctionExecution which takes a
start time.
- Remove extra call to FunctionStats.getTime() in
MemberFunctionStreamingMessage and add boolean to prevent calling
endFunctionExecutionWithException before startFunctionExecution was
called.
- Remove FunctionStats.getTime() in favor of returning the time from
FunctionStats.startFunctionExecution()

Functions with hasResult()=false execute asynchronously on an executor.
Previously, the instrumentation code recorded a successful function
execution after submitting a function to an executor, which is incorrect
because the function has not necessarily executed at that point. Now, we
record the execution time only after the function actually executes.

Co-authored-by: Aaron Lindsey <alindsey@pivotal.io>
Co-authored-by: Kirk Lund <klund@apache.org>
Co-authored-by: Dale Emery <demery@pivotal.io>
Co-authored-by: Mark Hanson <mhanson@pivotal.io>
-import java.util.concurrent.ConcurrentHashMap;
-import org.apache.geode.internal.cache.execute.FunctionServiceStats;
-import org.apache.geode.internal.cache.execute.FunctionStats;
+import org.apache.geode.internal.cache.execute.metrics.FunctionStatsManager;
-import org.apache.geode.internal.util.JavaWorkarounds;
+import org.apache.geode.metrics.internal.MeterRegistrySupplier;
+  private final FunctionStatsManager functionStatsManager;
-      StatisticsManagerFactory statisticsManagerFactory) {
+      StatisticsManagerFactory statisticsManagerFactory,
+      FunctionStatsManager.Factory functionStatsManagerFactory) {
+
+    this.functionStatsManager = functionStatsManagerFactory.create(statsDisabled, statisticsManager,
+        new MeterRegistrySupplier(() -> this));
-      // closing the Aggregate stats
-      if (functionServiceStats != null) {
-        functionServiceStats.close();
-      }
-      // closing individual function stats
-      for (FunctionStats functionstats : functionExecutionStatsMap.values()) {
-        functionstats.close();
-      }
+      functionStatsManager.close();
-  // As the function execution stats can be lot in number, its better to put
-  // them in a map so that it will be accessible immediately
-  private final ConcurrentHashMap<String, FunctionStats> functionExecutionStatsMap =
-      new ConcurrentHashMap<>();
-  private FunctionServiceStats functionServiceStats = null;
-
-  public FunctionStats getFunctionStats(String textId) {
-    if (statsDisabled) {
-      return FunctionStats.dummy;
-    }
-    return JavaWorkarounds.computeIfAbsent(functionExecutionStatsMap, textId,
-        key -> new FunctionStats(this, key));
+  public FunctionStatsManager getFunctionStatsManager() {
+    return functionStatsManager;
-
-  public synchronized FunctionServiceStats getFunctionServiceStats() {
-    if (functionServiceStats == null) {
-      functionServiceStats = new FunctionServiceStats(this, "FunctionExecution");
-    }
-    return functionServiceStats;
-  }
-
-
-        InternalDistributedSystem newSystem =
-            new InternalDistributedSystem(new ConnectionConfigImpl(
-                configProperties), defaultStatisticsManagerFactory());
+        InternalDistributedSystem newSystem = new InternalDistributedSystem(
+            new ConnectionConfigImpl(configProperties), defaultStatisticsManagerFactory(),
+            FunctionStatsManager::new);
-      InternalDistributedSystem internalDistributedSystem =
-          new InternalDistributedSystem(connectionConfig, statisticsManagerFactory);
+      InternalDistributedSystem internalDistributedSystem = new InternalDistributedSystem(
+          connectionConfig, statisticsManagerFactory, FunctionStatsManager::new);
